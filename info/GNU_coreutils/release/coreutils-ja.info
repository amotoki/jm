This is coreutils-ja.info, produced by makeinfo version 4.13 from
./coreutils-ja.texi.

INFO-DIR-SECTION Basics (in Japanese)
START-INFO-DIR-ENTRY
* Coreutils-ja: (coreutils-ja).  Core GNU (file, text, shell) utilities.
* Common options-ja: (coreutils-ja)Common options.
* File permissions-ja: (coreutils-ja)File permissions.  Access modes.
* Date input formats-ja: (coreutils-ja)Date input formats.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Individual utilities (in Japanese)
START-INFO-DIR-ENTRY
* arch-ja: (coreutils-ja)arch invocation.          Print machine hardware name.
* base64-ja: (coreutils-ja)base64 invocation.      Base64 encode/decode data.
* basename-ja: (coreutils-ja)basename invocation.  Strip directory and suffix.
* cat-ja: (coreutils-ja)cat invocation.            Concatenate and write files.
* chcon-ja: (coreutils-ja)chcon invocation.        Change SELinux CTX of files.
* chgrp-ja: (coreutils-ja)chgrp invocation.        Change file groups.
* chmod-ja: (coreutils-ja)chmod invocation.        Change access permissions.
* chown-ja: (coreutils-ja)chown invocation.        Change file owners and groups.
* chroot-ja: (coreutils-ja)chroot invocation.      Specify the root directory.
* cksum-ja: (coreutils-ja)cksum invocation.        Print POSIX CRC checksum.
* comm-ja: (coreutils-ja)comm invocation.          Compare sorted files by line.
* cp-ja: (coreutils-ja)cp invocation.              Copy files.
* csplit-ja: (coreutils-ja)csplit invocation.      Split by context.
* cut-ja: (coreutils-ja)cut invocation.            Print selected parts of lines.
* date-ja: (coreutils-ja)date invocation.          Print/set system date and time.
* dd-ja: (coreutils-ja)dd invocation.              Copy and convert a file.
* df-ja: (coreutils-ja)df invocation.              Report file system disk usage.
* dir-ja: (coreutils-ja)dir invocation.            List directories briefly.
* dircolors-ja: (coreutils-ja)dircolors invocation.   Color setup for ls.
* dirname-ja: (coreutils-ja)dirname invocation.    Strip last file name component.
* du-ja: (coreutils-ja)du invocation.              Report on disk usage.
* echo-ja: (coreutils-ja)echo invocation.          Print a line of text.
* env-ja: (coreutils-ja)env invocation.            Modify the environment.
* expand-ja: (coreutils-ja)expand invocation.      Convert tabs to spaces.
* expr-ja: (coreutils-ja)expr invocation.          Evaluate expressions.
* factor-ja: (coreutils-ja)factor invocation.      Print prime factors
* false-ja: (coreutils-ja)false invocation.        Do nothing, unsuccessfully.
* fmt-ja: (coreutils-ja)fmt invocation.            Reformat paragraph text.
* fold-ja: (coreutils-ja)fold invocation.          Wrap long input lines.
* groups-ja: (coreutils-ja)groups invocation.      Print group names a user is in.
* head-ja: (coreutils-ja)head invocation.          Output the first part of files.
* hostid-ja: (coreutils-ja)hostid invocation.      Print numeric host identifier.
* hostname-ja: (coreutils-ja)hostname invocation.  Print or set system name.
* id-ja: (coreutils-ja)id invocation.              Print user identity.
* install-ja: (coreutils-ja)install invocation.    Copy and change attributes.
* join-ja: (coreutils-ja)join invocation.          Join lines on a common field.
* kill-ja: (coreutils-ja)kill invocation.          Send a signal to processes.
* link-ja: (coreutils-ja)link invocation.          Make hard links between files.
* ln-ja: (coreutils-ja)ln invocation.              Make links between files.
* logname-ja: (coreutils-ja)logname invocation.    Print current login name.
* ls-ja: (coreutils-ja)ls invocation.              List directory contents.
* md5sum-ja: (coreutils-ja)md5sum invocation.      Print or check MD5 digests.
* mkdir-ja: (coreutils-ja)mkdir invocation.        Create directories.
* mkfifo-ja: (coreutils-ja)mkfifo invocation.      Create FIFOs (named pipes).
* mknod-ja: (coreutils-ja)mknod invocation.        Create special files.
* mktemp-ja: (coreutils-ja)mktemp invocation.      Create temporary files.
* mv-ja: (coreutils-ja)mv invocation.              Rename files.
* nice-ja: (coreutils-ja)nice invocation.          Modify niceness.
* nl-ja: (coreutils-ja)nl invocation.              Number lines and write files.
* nohup-ja: (coreutils-ja)nohup invocation.        Immunize to hangups.
* nproc-ja: (coreutils-ja)nproc invocation.        Print the number of processors.
* od-ja: (coreutils-ja)od invocation.              Dump files in octal, etc.
* paste-ja: (coreutils-ja)paste invocation.        Merge lines of files.
* pathchk-ja: (coreutils-ja)pathchk invocation.    Check file name portability.
* pr-ja: (coreutils-ja)pr invocation.              Paginate or columnate files.
* printenv-ja: (coreutils-ja)printenv invocation.  Print environment variables.
* printf-ja: (coreutils-ja)printf invocation.      Format and print data.
* ptx-ja: (coreutils-ja)ptx invocation.            Produce permuted indexes.
* pwd-ja: (coreutils-ja)pwd invocation.            Print working directory.
* readlink-ja: (coreutils-ja)readlink invocation.  Print referent of a symlink.
* realpath-ja: (coreutils-ja)realpath invocation.  Print resolved file names.
* rm-ja: (coreutils-ja)rm invocation.              Remove files.
* rmdir-ja: (coreutils-ja)rmdir invocation.        Remove empty directories.
* runcon-ja: (coreutils-ja)runcon invocation.      Run in specified SELinux CTX.
* seq-ja: (coreutils-ja)seq invocation.            Print numeric sequences
* sha1sum-ja: (coreutils-ja)sha1sum invocation.    Print or check SHA-1 digests.
* sha2-ja: (coreutils-ja)sha2 utilities.           Print or check SHA-2 digests.
* shred-ja: (coreutils-ja)shred invocation.        Remove files more securely.
* shuf-ja: (coreutils-ja)shuf invocation.          Shuffling text files.
* sleep-ja: (coreutils-ja)sleep invocation.        Delay for a specified time.
* sort-ja: (coreutils-ja)sort invocation.          Sort text files.
* split-ja: (coreutils-ja)split invocation.        Split into pieces.
* stat-ja: (coreutils-ja)stat invocation.          Report file(system) status.
* stdbuf-ja: (coreutils-ja)stdbuf invocation.      Modify stdio buffering.
* stty-ja: (coreutils-ja)stty invocation.          Print/change terminal settings.
* sum-ja: (coreutils-ja)sum invocation.            Print traditional checksum.
* sync-ja: (coreutils-ja)sync invocation.          Synchronize memory and disk.
* tac-ja: (coreutils-ja)tac invocation.            Reverse files.
* tail-ja: (coreutils-ja)tail invocation.          Output the last part of files.
* tee-ja: (coreutils-ja)tee invocation.            Redirect to multiple files.
* test-ja: (coreutils-ja)test invocation.          File/string tests.
* timeout-ja: (coreutils-ja)timeout invocation.    Run with time limit.
* touch-ja: (coreutils-ja)touch invocation.        Change file timestamps.
* tr-ja: (coreutils-ja)tr invocation.              Translate characters.
* true-ja: (coreutils-ja)true invocation.          Do nothing, successfully.
* truncate-ja: (coreutils-ja)truncate invocation.  Shrink/extend size of a file.
* tsort-ja: (coreutils-ja)tsort invocation.        Topological sort.
* tty-ja: (coreutils-ja)tty invocation.            Print terminal name.
* uname-ja: (coreutils-ja)uname invocation.        Print system information.
* unexpand-ja: (coreutils-ja)unexpand invocation.  Convert spaces to tabs.
* uniq-ja: (coreutils-ja)uniq invocation.          Uniquify files.
* unlink-ja: (coreutils-ja)unlink invocation.      Removal via unlink(2).
* uptime-ja: (coreutils-ja)uptime invocation.      Print uptime and load.
* users-ja: (coreutils-ja)users invocation.        Print current user names.
* vdir-ja: (coreutils-ja)vdir invocation.          List directories verbosely.
* wc-ja: (coreutils-ja)wc invocation.              Line, word, and byte counts.
* who-ja: (coreutils-ja)who invocation.            Print who is logged in.
* whoami-ja: (coreutils-ja)whoami invocation.      Print effective user ID.
* yes-ja: (coreutils-ja)yes invocation.            Print a string indefinitely.
END-INFO-DIR-ENTRY

   このマニュアルは、GNU core utilities version 8.20
の詳細な解説である。 core utilities
には、テキストやファイルを操作するための標準的な
プログラムが入っている。

   Copyright (C) 1994-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled "GNU Free Documentation License".

   【訳者から一言】 info コマンドは日本語の行末の表示があまり上手では
ない。そのため、しばしば行末に余計な文字が入って、読みにくいことがある。
そうしたときは、Ctrl キーと l (エル) キーを同時に押して、画面を再描画
していただきたい。たぶん、表示が正常になるはずである。


File: coreutils-ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU Coreutils
*************

このマニュアルは、GNU core utilities version 8.20 の詳細な解説である。
core utilities には、テキストやファイルを操作するための標準的な
プログラムが入っている。

   Copyright (C) 1994-2012 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled "GNU Free Documentation License".

   【訳者から一言】 info コマンドは日本語の行末の表示があまり上手では
ない。そのため、しばしば行末に余計な文字が入って、読みにくいことがある。
そうしたときは、Ctrl キーと l (エル) キーを同時に押して、画面を再描画
していただきたい。たぶん、表示が正常になるはずである。

* Menu:

* Introduction::             注意事項、概観、著者
* Common options::           共通オプション
* Output of entire files::   ファイル全体の出力 (cat tac nl od base64)
* Formatting file contents:: ファイルの整形 (fmt pr fold)
* Output of parts of files:: ファイルの部分出力 (head tail split csplit)
* Summarizing files::      チェックサムなど (wc sum cksum md5sum sha1sum sha2)
* Operating on sorted files::  ソートなど (sort shuf uniq comm ptx tsort)
* Operating on fields::      フィールド操作 (cut paste join)
* Operating on characters::  文字操作 (tr expand unexpand)
* Directory listing::        ディレクトリ一覧 (ls dir vdir dircolors)
* Basic operations::         基本操作 (cp dd install mv rm shred)
* Special file types::       特殊ファイル型 (mkdir rmdir unlink mkfifo mknod
                               ln link readlink)
* Changing file attributes::  ファイルの属性変更 (chgrp chmod chown touch)
* Disk usage::               ディスク使用量 (df du stat sync truncate)
* Printing text::            テキストの表示 (echo printf yes)
* Conditions::               条件 (false true test expr)
* Redirection::              リダイレクション (tee)
* File name manipulation::   ファイル名の操作 (dirname basename pathchk
                               mktemp realpath)
* Working context::          作業環境 (pwd stty printenv tty)
* User information::         ユーザ情報 (id logname whoami groups users who)
* System context::           システム情報 (date arch nproc uname hostname
                               hostid uptime)
* SELinux context::          chcon runcon
* Modified command invocation::  実行環境の変更 (chroot env nice nohup stdbuf
                                   timeout)
* Process control::          プロセス制御 (kill)
* Delaying::                 一時停止 (sleep)
* Numeric operations::       数値の操作 (factor seq)
* File permissions::         アクセス・モード
* Date input formats::       日付文字列の指定法
* Opening the software toolbox::  ソフトウェア工具という考え方
* About this translation::    翻訳について
* GNU Free Documentation License::  Copying and sharing this manual
* Concept index::            General index

 --- ノードの詳細なリスト ---

共通オプション

* Exit status::              プログラムが実行に成功したか失敗したかの指標
* Backup options::           バックアップ・オプション
* Block size::               ブロックサイズ
* Floating point::           浮動小数点数の表現
* Signal specifications::    シグナルの指定
* Disambiguating names and IDs::  chgrp や chown のシンタクス
* Random sources::           ランダムデータのソース
* Target directory::         出力先ディレクトリ
* Trailing slashes::         末尾のスラッシュ
* Traversing symlinks::      シンボリックリンクをたどる
* Treating / specially::     / (ルート) を特別扱いする
* Standards conformance::    標準への準拠

ファイル全体の出力

* cat invocation::           ファイルを結合して、書き出す
* tac invocation::           ファイルを結合して、ファイルごとに逆順で書き出す
* nl invocation::            行番号を付けて、ファイルを書き出す
* od invocation::            ファイルを 8 進数などの形式で書き出す
* base64 invocation::        データを ASCII 文字で表示可能なデータに変換する

ファイル内容の整形

* fmt invocation::           パラグラフに分かれたテキストを整形し直す
* pr invocation::            ページ付けや段組みをしてファイルを表示する
* fold invocation::          入力行を指定された幅に合わせて折り返す

ファイルの部分出力

* head invocation::          ファイルの先頭部分を出力する
* tail invocation::          ファイルの末尾部分を出力する
* split invocation::         ファイルを一定のサイズに分割する
* csplit invocation::        ファイルを内容を目印にして分割する

ファイルの要約

* wc invocation::            行数、単語数、バイト数を表示する
* sum invocation::           チェックサムとブロック数を表示する
* cksum invocation::         CRC チェックサムとバイト数を表示する
* md5sum invocation::        MD5 ダイジェストの表示、または検査をする
* sha1sum invocation::       SHA-1 ダイジェストの表示、または検査をする
* sha2 utilities::           SHA-2 ダイジェストの表示、または検査をする

ソートしたファイルの操作

* sort invocation::          テキストファイルを並べ替える
* shuf invocation::          テキストファイルをシャッフルする
* uniq invocation::          ファイルから重複を省く
* comm invocation::          ソート済みの二つのファイルを一行づつ比較する
* ptx invocation::           Produce a permuted index of file contents
* tsort invocation::         Topological sort

`ptx': Produce permuted indexes

* General options in ptx::   Options which affect general program behavior
* Charset selection in ptx::  Underlying character set considerations
* Input processing in ptx::  Input fields, contexts, and keyword selection
* Output formatting in ptx::  Types of output format, and sizing the fields
* Compatibility in ptx::     The GNU extensions to `ptx'

フィールド操作

* cut invocation::           各行の選択した部分を表示する
* paste invocation::         複数のファイルの各行をマージする
* join invocation::          共通のフィールドに基づいて行を連結する

文字操作

* tr invocation::            文字の置換、圧縮、削除を行う
* expand invocation::        タブをスペースに変換する
* unexpand invocation::      スペースをタブに変換する

`tr': 文字の置換、圧縮、削除を行う

* Character sets::           文字集合の指定
* Translating::              ある文字集合を別の文字集合に変換する
* Squeezing::                連続する文字の圧縮と文字の削除

ディレクトリの一覧表示

* ls invocation::            ディレクトリの内容を一覧表示する
* dir invocation::           ディレクトリの内容を簡潔に表示する
* vdir invocation::          ディレクトリの内容を詳細に表示する
* dircolors invocation::     `ls' のカラー設定

`ls': ディレクトリの内容を一覧表示する

* Which files are listed::      表示対象にするファイル
* What information is listed::  表示する情報
* Sorting the output::          出力のソート
* Details about version sort::  バージョン・ソートの詳細
* General output formatting::   出力全体の形式
* Formatting the file names::   ファイル名のフォーマット

基本的なファイル操作

* cp invocation::            ファイルやディレクトリをコピーする
* dd invocation::            ファイルの変換とコピー
* install invocation::       ファイルをコピーし属性をセットする
* mv invocation::            ファイルの移動 (名前の変更) を行う
* rm invocation::            ファイルやディレクトリを削除する
* shred invocation::         セキュリティを向上させたファイルの削除

特殊なファイル型

* link invocation::     システムコール link を使って、ハードリンクを作成する
* ln invocation::       ファイル間のリンクを作成する
* mkdir invocation::    ディレクトリを作成する
* mkfifo invocation::   FIFO (名前付きパイプ) を作成する
* mknod invocation::    ブロック型やキャラクタ型のスペシャルファイルを作成する
* readlink invocation:: シムリンクの値、または正規化されたファイル名を表示する
* rmdir invocation::    空のディレクトリを削除する
* unlink invocation::   システムコール unlink を使って、ファイルを削除する

ファイルの属性変更

* chown invocation::         ファイルの所有者やグループを変更する
* chgrp invocation::         ファイルの所有グループを変更する
* chmod invocation::         アクセス権を変更する
* touch invocation::         ファイルのタイムスタンプを変更する

ディスク使用量

* df invocation::            ファイルシステムのディスク使用状量を報告する
* du invocation::            ファイルのディスク使用量を概算する
* stat invocation::          ファイルやファイルシステムの状態を報告する
* sync invocation::          ディスク上のデータをメモリと同期する
* truncate invocation::      ファイルサイズの短縮・伸長を行う

テキストの表示

* echo invocation::          テキストを 1 行表示する
* printf invocation::        データを整形して表示する
* yes invocation::           中断されるまで文字列を表示する

条件

* false invocation::         何もせず、実行失敗のステータスを返す
* true invocation::          何もせず、正常終了する
* test invocation::          ファイルタイプのチェックや値の比較を行う
* expr invocation::          式を評価する

`test': ファイルタイプのチェックや値の比較を行う

* File type tests::            ファイルタイプのテスト
* Access permission tests::    アクセス許可のテスト
* File characteristic tests::  ファイル特性のテスト
* String tests::               文字列のテスト
* Numeric tests::              数値のテスト

`expr': 式を評価する

* String expressions::       文字列式 (+ : match substr index length)
* Numeric expressions::      数式 (+ - * / %)
* Relations for expr::       論理結合と関係表現 (| & < <= = == != >= >)
* Examples of expr::         `expr' の使用例

リダイレクション

* tee invocation::           出力を複数のファイルやプロセスにリダイレクトする

ファイル名操作

* basename invocation::      ファイル名からディレクトリと接尾辞を取り除く
* dirname invocation::       ファイル名から最後の要素を取り除く
* pathchk invocation::       ファイル名の有効性や可搬性を検査する
* mktemp invocation::        テンポラリファイルやディレクトリを作成する
* realpath invocation::      ファイル名を展開して表示する

作業環境

* pwd invocation::           現在作業中のディレクトリを表示する
* stty invocation::          端末の諸特性を表示・変更する
* printenv invocation::      環境変数のすべて、あるいは一部を表示する
* tty invocation::           標準出力に接続している端末のファイル名を表示する

`stty': 端末の諸特性を表示・変更する

* Control::                  制御関係の設定
* Input::                    入力に関する設定
* Output::                   出力に関する設定
* Local::                    ローカル設定
* Combination::              組み合わせ設定
* Characters::               特殊文字
* Special::                  特殊設定

ユーザ情報

* id invocation::            ユーザの ID を表示する
* logname invocation::       現在のログイン名を表示する
* whoami invocation::        実効ユーザ ID を表示する
* groups invocation::        ユーザが所属しているグループ名を表示する
* users invocation::         現在ログインしている全ユーザのログイン名を表示する
* who invocation::           現在誰がログインしているかを表示する

システム情報

* arch invocation::          マシンのハードウェア名を表示する
* date invocation::          システムの日付や時刻を表示、設定する
* nproc invocation::         Print the number of processors
* uname invocation::         システムについて情報を表示する
* hostname invocation::      システム名を表示、設定する
* hostid invocation::        数値によるホストの識別名を表示する
* uptime invocation::        システムの連続稼働時間と負荷を表示する

`date': システムの日付や時刻を表示、設定する

* Time conversion specifiers:: 時刻関係の変換指定子 %[HIklMNpPrRsSTXzZ]
* Date conversion specifiers:: 日付関係の変換指定子 %[aAbBcCdDeFgGhjmuUVwWxyY]
* Literal conversion specifiers::  文字変換指定子 %[%nt]
* Padding and other flags::  0 や空白による空き埋め、その他。
* Setting the time::         システムクロックの変更
* Options for date::         現在時以外の指定
* Date input formats::       日付文字列の指定法
* Examples of date::         用例

SELinux context

* chcon invocation::         Change SELinux context of file
* runcon invocation::        Run a command in specified SELinux context

コマンド実行条件の変更

* chroot invocation::    ルートディレクトリを変更して、コマンドを実行する
* env invocation::       変更した環境でコマンドを実行する
* nice invocation::      niceness を変更して、コマンドを実行する
* nohup invocation::     ハングアップ・シグナルで終了しないコマンドを実行する
* stdbuf invocation::    I/O バッファリングを変更して、コマンドを実行する
* timeout invocation::   タイムリミット付きでコマンドを実行する

プロセス制御

* kill invocation::          プロセスにシグナルを送る。

一時停止

* sleep invocation::         指定された時間、停止する

数値の操作

* factor invocation::        素因数を表示する
* seq invocation::           数列を表示する

ファイルの許可属性

* Mode Structure::           ファイルのモードビットの構成
* Symbolic Modes::           ファイルのモードビットの憶えやすい表記
* Numeric Modes::            ファイルのモードビットの 8 進数による表記
* Directory Setuid and Setgid::  ディレクトリの Set-User-ID と
                                   Set-Group-ID ビット

日付入力の書式

* General date syntax::      共通規則
* Calendar date items::      19 Dec 1994
* Time of day items::        9:20pm
* Time zone items::          EST, PDT, GMT
* Day of week items::        Monday, Tuesday
* Relative items in date strings::  next tuesday, 2 years ago
* Pure numbers in date strings::  19931219, 1440
* Seconds since the Epoch::  @1078100502
* Specifying time zone rules::  TZ="America/New_York", TZ="UTC0"
* Authors of parse_datetime::  Bellovin, Eggert, Salz, Berets, et al

ソフトウェアの道具箱

* Toolbox introduction::     はじめに
* I/O redirection::          I/O リダイレクション
* The who command::          `who' コマンド
* The cut command::          `cut' コマンド
* The sort command::         `sort' コマンド
* The uniq command::         `uniq' コマンド
* Putting the tools together::  工具を組み合わせる

翻訳について

* About this translation::   翻訳について

Copying This Manual

* GNU Free Documentation License::  Copying and sharing this manual


File: coreutils-ja.info,  Node: Introduction,  Next: Common options,  Prev: Top,  Up: Top

1 序
*****

このマニュアルは作成の途上にある。たとえば、多くのセクションで、基本的な
概念を初心者にわかりやすく説明するといった試みがなされていない。そこで、
お願いがある。もし、関心がおありなら、このマニュアルの改良に参加して
いただきたい。そうしていただければ、GNU コミュニティ全体が恩恵に浴する
ことになる。

   このマニュアルで説明している GNU ユーティリティは、POSIX の規格に
おおむね準拠している。 バグの報告は、<bug-coreutils@gnu.org> になさって
いただきたい。そのとき、バージョン番号、マシンのアーキテクチャ、入力に
使ったファイルといった情報はもとより、バグの再現に必要な他のいかなる
情報も、忘れずに記載していただきたい。たとえば、どんな入力をしたか、
どんな結果を期待していたか、実際の結果はどうだったか、それがおかしいと
考える理由は何なのかといったことである。差分の投稿は歓迎するが、何がどう
問題なのかの説明もやはり付けていただきたい。推測するのが難しいこともある
からだ。*Note Bugs: (gcc)Bugs.

   このマニュアルは、ユーティリティ・プログラムの配布に含まれる Unix の
man page 群を元にして作られたものである。そうした man page は、David
MacKenzie によって書かれ、Jim Meyering によって改訂されていた。現在読者
がお読みになっているこのマニュアルは、そうしたユーティリティについての
公式文書であり、man page の方は、今では改訂作業が行われていない。なお、
`fmt' の最初の man page の著者は、 Ross Paterson だった。Texinfo 形式
への変換を最初に行ったのは、Franc,ois Pinard である。Karl Berry が索引を
作成し、構成に若干の変更を加えて、その結果に手を入れた。Free Software
Foundation の職員である Brian Youman が textutils, fileutils, sh-utils
のマニュアルを統合し、多数の項目を含む現在のマニュアルを作成した。こうした
作業全般に渡って、Richard Stallman が例によって洞察力に富む貴重な意見を
寄せてくれた。


File: coreutils-ja.info,  Node: Common options,  Next: Output of entire files,  Prev: Introduction,  Up: Top

2 共通オプション
***********************

いくつかのオプションは、このマニュアルで取り上げるすべてのプログラムで
利用することができる。そうしたオプションについては、個々のプログラムで
同じ説明を繰り返すことはせず、この場で説明しておく (実のところ、こうした
オプションは、GNU のすべてのプログラムで使用できる (はずである))。

   通常、オプションとオペランドは、どんな順番で指定してもよい。プログ
ラムは、すべてのオプションがいかなるオペランドよりも前にあるかのごとく
振る舞うようになっている。たとえば、`sort -r passwd -t :' は、`:' が
`-t' のオプション引数 (option-argument) なので、`sort -r -t : passwd'
と同じ動作をする。しかしながら、環境変数 `POSIXLY_CORRECT' が設定されて
いる場合は、オプションはオペランドの前に置かなければならない。ただし、
オプションとオペランドの順番について、そのコマンドに別の決まりがある
ときはこのかぎりではない。

   若干のプログラムでは、二番目以降のオペランドとして先頭に `-' が付く
オペランドが使えると都合がよい。そうしたプログラムでは、`POSIXLY_CORRECT'
が設定されていない場合でも、オプションをオペランドの前に置く必要がある。
そこで、そうしたプログラムの説明には、その旨注意書きを付けておいた。
たとえば、`env' コマンドのオプションは、オペランドの前に置かなければ
ならない。オペランドとして指定したコマンドが、それ自身のオプションを
伴うことがあるからだ。

   ロングオプションが使えるたいていのプログラムは、誤解の余地がない
かぎり、そうしたオプションの省略形を認識する。たとえば、`rmdir
--ignore-fail-on-non-empty' は、`rmdir --ignore-fail' という形でも
起動できるし、`rmdir --i' でも大丈夫だ。`ls --h' のような誤解の余地の
あるオプションは、まさに曖昧だと判定される。

   このマニュアルで説明するプログラムの中には、`--help' や`--version'
が唯一のコマンドライン引数である場合しか、そうしたオプションを認識し
ないものがある。そうしたプログラムの場合、ロングオプションの省略形は、
常に認識されるとはかぎらない。

`--help'
     使用法を表示して利用できるすべてのオプションを列挙し、正常終了する。

`--version'
     バージョン番号を表示し、正常終了する。

`--'
     オプション群の末尾を示す。これ以降に引数があれば、それが `-' で
     始まっている場合でも、オペランドとして扱われる。たとえば、`sort --
     -r' は、`-r' という名前のファイルから読み込むということである。


   単独の `-' はオペランドであって、オプションのように見えるが、オプ
ションでは全くない。単独の `-' は、標準入力、または標準出力を表して
いる。後者は、前後の状況からそれが明白な場合だ。たとえば、`sort -' は、
標準入力から読み込むということであり、ただの `sort' と同じである。また、
`tee -' は、入力したもののコピーを標準出力に二重に書き出す。使用できない
とはっきり断っていないかぎり、`-' は、ファイル名が要求されるいかなる
ところでもオペランドとして使用することができる。

* Menu:

* Exit status::              プログラムが成功したか失敗したかの指標。
* Backup options::           バックアップ・オプション (-b と -S)。
* Block size::               ブロックサイズ (BLOCK_SIZE と --block-size)。
* Floating point::           浮動小数点数の表現。
* Signal specifications::    --signal オプションによるシグナルの指定。
* Disambiguating names and IDs::  chgrp や chown のシンタクス。
* Random sources::           ランダムデータのソース (--random-source)。
* Target directory::         出力先ディレクトリの指定。
* Trailing slashes::         末尾のスラッシュ (--strip-trailing-slashes)。
* Traversing symlinks::      シムリンクをたどる (-H, -L, -P)。
* Treating / specially::     --preserve-root や --no-preserve-root の使用。
* Special built-in utilities::  組み込みコマンド `break', `:' など。
* Standards conformance::    POSIX 規格への準拠。


File: coreutils-ja.info,  Node: Exit status,  Next: Backup options,  Up: Common options

2.1 終了ステータス
=========================

ほとんどすべてのコマンドは、実行すると、整数の終了ステータス ("exit
status") を返し、それは他のコマンドの動作を変更するために使用することが
できる。大多数のコマンドにとって、終了ステータス `0' は成功を意味して
いる。失敗は `0' 以外の値によって示され、普通は `1' であるが、非標準的な
プラットフォームでは違うこともある。POSIX の規定が、`0' 以外であること
しか要求していないからである。

   しかしながら、ここで詳述しているプログラムの中にも、終了ステータスと
して上記以外の値を返すものがあり、`0' や `1' という値に別の意味を与えて
いるプログラムさえ、少数ながらある。そうした例外をいくつか挙げると、
`chroot', `env', `expr', `nice', `nohup', `printenv', `sort', `stdbuf',
`test', `timeout', `tty' などである。


File: coreutils-ja.info,  Node: Backup options,  Next: Block size,  Prev: Exit status,  Up: Common options

2.2 バックアップ・オプション
========================================

GNU のプログラムの中には、ファイルの新しいバージョンを書き出す前に、
バックアップの作成を選択できるものがある (少なくとも `cp', `install',
`ln', `mv' がそうだ)。下記のオプションは、そうしたバックアップを細かく
制御する。こうしたオプションについては、個々のプログラムの説明でも簡単に
触れている。

`-b'
`--backup[=METHOD]'
     通常では上書きされたり、消去されたりする各ファイルのバックアップを
     作成する。このオプションを指定しないと、元のバージョンは破棄される
     わけだ。作成するバックアップのタイプを決めるには、METHOD を使用
     する。METHOD を指定せずに、このオプションを使った場合は、環境変数
     `VERSION_CONTROL' の値が使用される。`VERSION_CONTROL' が設定されて
     いない場合、デフォルトのバックアップタイプは `existing' である。

     このオプションの短縮形である `-b' は、引数を取らないことに注意して
     いただきたい。`-b' の使用は、`--backup=existing' を使用するのと
     同じことである。

     このオプションは、Emacs の `version-control' 変数に対応している。
     すなわち、METHOD の値は、Emacs で使用される値と同じものである。
     とは言え、このオプションでは、より説明的な名前も使用できる。METHOD
     の有効な値は、以下のものである (他と区別できるならば、省略した表現
     も使用できる)。

    `none'
    `off'
          バックアップを作成しない。

    `numbered'
    `t'
          どんな場合でも番号付きのバックアップを作成する。

    `existing'
    `nil'
          番号付きのバックアップがすでに存在する場合は番号付きで、それ
          以外の場合は単純形式で、ファイルのバックアップを作成する。
          (訳注: 単純形式というのは、バックアップファイル名に番号を付け
          ない形式である、`--suffix=SUFFIX' の説明を参照。)

    `simple'
    `never'
          どんな場合でも単純形式のバックアップを作成する。`never' と
          `none' を混同なさらないようにしていただきたい。


`-S SUFFIX'
`--suffix=SUFFIX'
     `-b' で作成される各バックアップファイルの名前の末尾に SUFFIX を
     付ける。このオプションが指定されていない場合は、環境変数
     `SIMPLE_BACKUP_SUFFIX' の値が使用される。`SIMPLE_BACKUP_SUFFIX'
     が設定されていない場合、デフォルトは Emacs の場合と同じで、`~'
     である。



File: coreutils-ja.info,  Node: Block size,  Next: Floating point,  Prev: Backup options,  Up: Common options

2.3 ブロックサイズ
=========================

GNU プログラムには、ディスクの使用量を「ブロック数」で表示するものが
いくつかある (少なくとも、`df', `du',`ls' がそうだ)。ブロックのサイズや
表示の書式は、使用量をわかりやすくするために、変更することができる。
表示に使用されるブロックサイズは、ファイルシステムのブロックサイズとは、
無関係である。ブロック数に端数が出る場合は、切り上げて整数にする。

   デフォルトのブロックサイズの選択は、次の環境変数を順番に調べることで
行われる。設定されている最初のものがブロックサイズを決めることになる。

`DF_BLOCK_SIZE'
     この環境変数は、`df' コマンドで使うデフォルトのブロックサイズを
     設定する。同様に、`DU_BLOCK_SIZE' は `du' のデフォルトを、
     `LS_BLOCK_SIZE' は `ls' のデフォルトを設定する。

`BLOCK_SIZE'
     この環境変数は、上記のようなコマンド専用の環境変数が設定されて
     いない場合に、三つのコマンドすべてに対してデフォルトのブロック
     サイズを指定する。

`BLOCKSIZE'
     この環境変数は、上記のようなコマンド専用の環境変数と `BLOCK_SIZE'
     のどちらも設定されていない場合に、通常ブロック数として表示される
     すべての値に対してデフォルトのブロックサイズを指定する。ほかの環境
     変数とは違って、`BLOCKSIZE' は、たとえば `ls -l' の出力に含まれる
     ファイルサイズのような、通常バイト数として表示される値には影響を
     及ぼさない。

`POSIXLY_CORRECT'
     `COMMAND_BLOCK_SIZE', `BLOCK_SIZE', `BLOCKSIZE' のいづれも
     設定されていず、この変数が設定されている場合は、ブロックサイズの
     デフォルトは、512 バイトになる。


   上記の環境変数のいづれも設定されていない場合、ブロックサイズの
デフォルトは、現在のところたいていの場合、 1024 バイトである。ただし、
この数値は、将来変更されるかもしれない。なお、`ls' の表示するファイル
サイズについては、ブロックサイズのデフォルトは 1 バイトである。

   ブロックサイズの指定には、1 ブロックあたりのバイト数を示す正の整数を
使えばよい。あるいは、`human-readable' や `si' を指定して、「人間に読み
やすい」書式を選ぶこともできる。整数には接尾辞 (suffix) を付けることが
できるが、そうした接尾辞は、`10' の累乗倍 (訳注: 10^3 倍、10^6 倍など)
を示す場合は、SI (国際単位系) の単位の前に付ける接頭辞 (prefix) の上位
互換であり、`2' の累乗倍 (訳注: 2^10 倍、2^20 倍など) を示す場合は、
ISO/IEC 80000-13 (以前は IEC 60027-2 だった) の接頭辞の上位互換である。
単位の前に付ける接頭辞については、次の URL を参照していただきたい。
SI prefixes:
(http://www.bipm.org/en/si/si_brochure/chapter3/prefixes.html).
ISO/IEC 80000-13 prefixes:
(http://physics.nist.gov/cuu/Units/binary.html).

   「人間に読みやすい」書式の場合、出力するサイズの後ろに、メガバイト
なら `M' といった、大きさを表す文字が付く。`BLOCK_SIZE=human-readable'
の方は、1024 の累乗を使うので、`M' は 1,048,576 バイトを意味している。
`BLOCK_SIZE=si' も似ているが、こちらは 1000 の累乗を使用し、さらに `B'
が後ろに続く。そこで、`MB' は 1,000,000 バイトを意味することになる。

   ブロックサイズの指定の先頭に `'' を付けると、出力するサイズを数桁
ごとに区切って表示することができる。区切りに使う記号や区切りの位置は、
`LC_NUMERIC' のロケールによって決まる。たとえば、アメリカ英語のロケール
では、`--block-size="'1kB"' と指定すれば、1234000 バイトという容量が
`1,234' と表示されることになるだろう。デフォルトの C ロケールの場合は、
区切り記号が存在しないので、先頭の `'' に効果はない。

   ブロックサイズを指定する整数の後ろに接尾辞を付けて、その整数の何倍
かを示すことができる。大きさを表す (訳注: M, G などの) 文字の後ろに何も
続けないときや、`iB' を続けるときは、1024 の累乗倍ということである。
それに対して、大きさを表す文字に `B' を続ける場合は、1000 の累乗倍
ということになる。たとえば、`1M' や `1MiB' は `1048576' と同じであり、
`1MB' は `1000000' と同じである。

   整数を前に付けずに、接尾辞だけを指定したときの動作は、`1' が前に
付いているときとほぼ同じだが、大きさの表示が出力の後ろに付く点が違う。
たとえば、`--block-size="kB"' は、3000 を `3kB' という形で表示する。

   以下の接尾辞が定義されている。`1Y' のような大きな量は、算術計算の
限界のためにお使いのコンピュータでは使用できないかもしれない。

`kB'
     キロバイト (kilobyte): 10^3 = 1000 バイト。

`k'
`K'
`KiB'
     キビバイト (kibibyte): 2^10 = 1024 バイト。`K' も使えるのは、おまけ
     である。なお本来、SI の接頭辞 (訳注: すなわち 10^3 倍を表す接頭辞)
     が `k' であり、ISO/IEC 80000-13 の接頭辞 (訳注: すなわち 2^10 倍を
     表す接頭辞) が `Ki' だが、これまでの習慣や POSIX の用法では、`KiB'
     の意味で `k' を使っている。

`MB'
     メガバイト (megabyte): 10^6 = 1,000,000 バイト。

`M'
`MiB'
     メビバイト (mebibyte): 2^20 = 1,048,576 バイト。

`GB'
     ギガバイト (gigabyte): 10^9 = 1,000,000,000 バイト。

`G'
`GiB'
     ギビバイト (gibibyte): 2^30 = 1,073,741,824 バイト。

`TB'
     テラバイト (terabyte): 10^12 = 1,000,000,000,000 バイト。

`T'
`TiB'
     テビバイト (tebibyte): 2^40 = 1,099,511,627,776 バイト。

`PB'
     ペタバイト (petabyte): 10^15 = 1,000,000,000,000,000 バイト。

`P'
`PiB'
     ペビバイト (pebibyte): 2^50 = 1,125,899,906,842,624 バイト。

`EB'
     エクサバイト (exabyte): 10^18 = 1,000,000,000,000,000,000 バイト。

`E'
`EiB'
     エクスビバイト (exbibyte): 2^60 = 1,152,921,504,606,846,976
     バイト。

`ZB'
     ゼタバイト (zettabyte): 10^21 = 1,000,000,000,000,000,000,000
     バイト。

`Z'
`ZiB'
     ゼビバイト (zebibyte): 2^70 = 1,180,591,620,717,411,303,424
     バイト。

`YB'
     ヨタバイト (yottabyte): 10^24 = 1,000,000,000,000,000,000,000,000
     バイト。

`Y'
`YiB'
     ヨビバイト (yobibyte): 2^80 = 1,208,925,819,614,629,174,706,176
     バイト。

   デフォルトのブロックサイズは、コマンドに対して `--block-size=SIZE'
オプションを明示的に指定することで変更することができる。`-k' オプション
は、`--block-size=1K' と同じであり、環境変数 `POSIXLY_CORRECT' が設定
されていないときのデフォルトである。`-h' オプションや `--human-readable'
オプションは、`--block-size=human-readable' と同じである。`--si' オプ
ションは、`--block-size=si' と同じだ。


File: coreutils-ja.info,  Node: Floating point,  Next: Signal specifications,  Prev: Block size,  Up: Common options

2.4 浮動小数点数
======================

浮動小数点数を受け取ったり、生成したりするコマンドは、基盤になっている
システムの浮動小数点表現法を使用しており、丸めエラー、オーバーフローなど、
浮動小数点にかかわる問題をかかえている。最近のシステムでは、ほとんど
すべてが IEEE-754 の浮動小数点を採用しているので、今日では IEEE-754 の
動作を想定しておけば、たいていどこでも問題がない。IEEE-754 には、正と負
の無限があり、正と負のゼロを区別する。また、NaN (訳注: not a number)
という特別な値を使って、ゼロをゼロで割るといった無効な演算を表現する。
より詳しい情報については、デイビッド・ゴールドバーグの論文 "What Every
Computer Scientist Should Know About Floating-Point Arithmetic"
(http://www.validlab.com/goldberg/paper.pdf) をご覧になるとよい。

   浮動小数点数をオプションやオペランドや入力として受け取るコマンドは、
C の標準関数 `strtod' や `strtold' を使って、テキストを浮動小数点数に
変換している。従って、そうした浮動小数点数には、`1.0e-34' や `-10e100'
といった指数表現が使用できる。最近の C の実装では、16 進の浮動小数点数
も使える。たとえば、`-0x.ep-3' といったものだが、これは -14/16 掛ける
2^-3 を表し、-0.109375 に等しい。小数点を表す記号が何になるかは、
`LC_NUMERIC' のロケールによって決まる。*Note Parsing of Floats:
(libc)Parsing of Floats.


File: coreutils-ja.info,  Node: Signal specifications,  Next: Disambiguating names and IDs,  Prev: Floating point,  Up: Common options

2.5 シグナルの指定
=========================

SIGNAL の指定には、`HUP' のようなシグナル名や `1' のようなシグナル番号、
それに、シグナルによって終了するときのプロセスの終了ステータスを使うこと
ができる (訳注: 最後のものは、GNU coreutils の `kill' コマンドでは使用
できるが、他の系統の `kill' では使えないかもしれない)。シグナル名は、
標準的な形式でも、頭に `SIG' を付けた形式でも構わない。大文字小文字は
区別されない。以下に挙げるシグナル名とシグナル番号は、POSIX の規格に
従っているすべてのシステムで使用できる。

`HUP'
     1.  ハングアップ (Hangup)。

`INT'
     2.  端末からの割り込みシグナル (Terminal interrupt)。

`QUIT'
     3.  端末からの中止シグナル (Terminal quit)。

`ABRT'
     6. プロセスの中断 (Process abort)。

`KILL'
     9.  強制終了 (Kill) (キャッチすることも無視することもできない)。

`ALRM'
     14.  アラームクロック (Alarm Clock)。

`TERM'
     15.  終了 (Termination)。

これ以外にもサポートされているシグナル名があるが、それに対応する
シグナル番号はシステムによって様々である。POSIX 1003.1-2001
に準拠しているすべてのシステムでは、以下のシグナルも使用できる。

`BUS'
     メモリオブジェクトの未定義領域へのアクセス。

`CHLD'
     チャイルドプロセスが終了 (terminate)、一時停止 (stop)、または再開
     (continue) した。

`CONT'
     実行が停止 (stop) しているならば、再開 (continue) する。

`FPE'
     誤った算術演算。

`ILL'
     不正な命令。

`PIPE'
     読み手のないパイプへの書き出し。

`SEGV'
     無効なメモリ参照。

`STOP'
     実行を一時停止する (stop) (キャッチすることも無視することも
     できない)。

`TSTP'
     端末からの一時停止シグナル。

`TTIN'
     バックグラウンドプロセスが端末から読み込もうとしている。

`TTOU'
     バックグラウンドプロセスが端末へ書き出そうとしている。

`URG'
     高帯域幅のデータがソケットに達している。

`USR1'
     ユーザ定義シグナル 1。

`USR2'
     ユーザ定義シグナル 2。

XSI 拡張に対応している POSIX 1003.1-2001 のシステムでは、以下の
シグナルも使用できる。

`POLL'
     ポーリング可能なイベント。

`PROF'
     プロファイリング・タイマーがタイムアウトした。

`SYS'
     不正なシステムコール。

`TRAP'
     Trace/breakpoint トラップ。

`VTALRM'
     バーチャル・タイマーがタイムアウトした。

`XCPU'
     CPU 時間の上限を超過した。

`XFSZ'
     ファイルサイズの上限を超過した。

XRT 拡張に対応している POSIX 1003.1-2001 のシステムでは、上記以外にも、
少なくとも 8 個のリアルタイム・シグナルが使用できる。すなわち、`RTMIN',
`RTMIN+1', ..., `RTMAX-1', `RTMAX' などだ。


File: coreutils-ja.info,  Node: Disambiguating names and IDs,  Next: Random sources,  Prev: Signal specifications,  Up: Common options

2.6 chown と chgrp: ユーザ名かユーザ ID かを明確にする
======================================================================

`chown' や `chgrp' コマンドでは、引数として OWNER や GROUP を渡す際に、
名前で指定しても、ID 番号で指定してもよい。この指定法が曖昧であること
は明らかである。もし、ユーザ名やグループ名が数字の連続だったら、どう
だろう？ (1) コマンドはそれをユーザ名と解釈すべきだろうか？ ID 番号と
解釈すべきだろうか？ POSIX では、「`chown' や `chgrp' は、指定された
文字列をまず名前として解決することを試み、それに失敗した場合のみ、ID
番号として解釈しようとすること」と規定している。この規定では、ユーザが
引数として ID 番号、たとえば 42 を指定しようとすると、厄介なことになる。
42 というユーザ名が存在し、それにユーザ ID として別の数字、たとえば
1000 が割り当てられているといったややこしい状況でも、うまく処理でき
なければならないとすると、困ったことになるのだ。単に `chown 42 F' を
実行したのでは、ファイル `F' の所有者の ID 番号が 1000 になってしまう。
これはユーザが意図した動作ではない。

   GNU の `chown' や `chgrp' は、この問題に対する回避策を提供している。
この回避策を使用すると、データベースの検索を省略するので、処理速度が
著しく向上することがあるというおまけまである。ユーザ ID 番号やグループ
ID 番号を指定する際には、その前に `+' を付けさえすればよいのだ。そうする
ことで、整数として解釈するように強制できるのである。

     chown +42 F
     chgrp +$numeric_group_id another-file
     chown +0:+0 /

   GNU の `chown' や `chgrp' は、`+' が前に付く各文字列に対してユーザ名
の検索プロセスを省略する。何故なら、`+' を含む文字列が有効なユーザ名や
グループ名であることは絶対にないからだ。この書き方は、よく使われている
たいていの Unix システムで使用できるが、Solaris 10 では使用できない。

   ---------- Footnotes ----------

   (1) 環境によっては、ユーザ名に数字を使うのは、よくあることである。


File: coreutils-ja.info,  Node: Random sources,  Next: Target directory,  Prev: Disambiguating names and IDs,  Up: Common options

2.7 ランダムデータのソース
=====================================

`shuf', `shred', `sort' コマンドは作業を行うためにランダムデータを必要
とすることがある。たとえば、`sort -R' ではハッシュ関数をランダムに選ば
ねばならず、その選択のためにランダムデータを必要としている。

   デフォルトでは、こうしたコマンドは、プログラム内部の擬似乱数ジェネ
レータを、少量のエントロピーによって初期化して使用するが、
`--random-source=FILE' オプションで、外部ソースを使うように指示すること
もできる。FILE の中身のバイト数が不十分なときは、エラーが通知される。

   たとえば、デバイスファイル `/dev/urandom' を、ランダムデータのソース
として使用してもよい。通常、このデバイスは、デバイスドライバーなどのソース
から環境ノイズを集めて、エントロピー・プールに入れ、そのプールを使って、
ランダムなビットを生成する。プールにデータが足りない場合は、内部プールを
再利用し、暗号的に安全な擬似乱数ジェネレータを使って、より多くのビットを
作り出す。とは言え、このデバイスは、大量のランダムデータの生成のために
設計されたものではなく、比較的動作が遅いことは、承知しておいた方がよい。

   たいていの実用には、`/dev/urandom' で十分だが、プライベートなデータの
高度で長期に渡る保護が必要になるアプリケーションでは、`/dev/random' や
`/dev/arandom' のような他のデータソースが必要になるかもしれない。どんな
データソースが利用できるかは、ご使用のオペレーティング・システム次第である。

   前回コマンドを実行したときの結果を再現するには、何らかのランダム
データをファイルに保存しておき、そのコマンドの一回目の実行でも二回目
の実行でも、ランダムソースとしてそのファイルを使用すればよい。


File: coreutils-ja.info,  Node: Target directory,  Next: Trailing slashes,  Prev: Random sources,  Up: Common options

2.8 出力先ディレクトリ
===============================

通常、`cp', `install', `ln', `mv' といったコマンドは、最後のオペランドが
ディレクトリやディレクトリへのシンボリックリンクの場合、それを特別
扱いする。たとえば、`cp source dest' は、`dest' がディレクトリならば、
`cp source dest/source' と同じことである。時には、そうした動作が、
ユーザが求めている動作とは違うこともある。そこで、こうしたコマンドは、
よりきめ細かな制御ができるように、以下のオプションをサポートしている。

`-T'
`--no-target-directory'
     最後のオペランドが、ディレクトリやディレクトリへのシンボリック
     リンクであっても、それを特別扱いしない。このオプションは、共有領域
     で作業する複数のプログラムが、競合状態にならないようにしてくれる。
     たとえば、`mv /tmp/source /tmp/dest' というコマンドが正常終了して
     も、`/tmp/source' が `/tmp/dest' にリネームされたという保証はない。
     もし、何かほかのプロセスが `/tmp/dest' をディレクトリとして作成して
     いたら、`/tmp/dest/source' という名前のファイルになってしまうかも
     しれないのだ。それに対して、`mv -T /tmp/source /tmp/dest' が正常
     終了した場合は、`/tmp/source' は間違いなく `/tmp/dest' にリネーム
     されている。

     反対に、最後のオペランドをディレクトリとして扱わせたい、それが
     できない場合は、エラーメッセージを出したい、ということもある。
     そういうときは、`--target-directory' (`-t') オプションを使用すれば
     よい。(訳注: ターゲット・ディレクトリをコマンドラインの最後に置く
     代わりに、`--target-directory' オプションの引数にするということ
     である。)

`-t DIRECTORY'
`--target-directory=DIRECTORY'
     DIRECTORY を出力先ファイルすべてのディレクトリ部分として使用する。

     ほとんどのプログラムで、コマンドラインの扱いは次のようになって
     いる -- オプションや、一定数の (0 個のこともある) 位置の固定した
     引数の処理が終われば、引数リストにはもう何も残っていないか、
     残っているとすれば、それは、すべて同じように処理される項目 (通常は
     ファイル) のリストはずだ。`xargs' プログラムは、こうした約束ごとに
     沿ってうまく動くように作られている。

     `mv' ファミリーのコマンドが変わっているのは、引数の数が不定であり、
     しかも最後の引数を特別扱いするという点である (すなわちターゲット・
     ディレクトリとして扱う)。そのため、ある種の作業の実行は、一筋縄では
     いかない。たとえば、「すべてのファイルをここから ../d/ に移動する」
     がそうだ。何故なら、`mv * ../d/' では、引数を入れておくための領域を
     使い切ってしまうかもしれないし、そうかと言って、`ls | xargs ...'
     には、実行対象コマンド (訳注: ここでは、`mv') を起動するたびに
     最後の引数を特別に指定するためのすっきりした方法がないからである。
     (あるシェル・コマンドを駆使すれば、やることができるが、それでは、
     人間の労力と脳力を不当に要求することになる。)

     `--target-directory' (`-t') オプションを使用すると、`cp', `mv',
     `ln', `install' といったプログラムを `xargs' と一緒に使うとき、
     たいへん都合がよい。たとえば、カレントディレクトリから、同じディ
     レクトリ階層にある  `d' ディレクトリへファイルを移動するには、
     こんなふうにすればよい。

          ls | xargs mv -t ../d --

     しかし、これでは、ファイル名の先頭に `.' の付くファイルが移動しな
     い。GNU `find' プログラムを使用しているなら、次のコマンドでそうした
     ファイルも移動させることができる。

          find . -mindepth 1 -maxdepth 1 \
            | xargs mv -t ../d

     とは言え、上記のどちらの方法も、カレントディレクトリにファイルが
     一つもない場合や、空白などの特殊文字を名前に含むファイルがある場合
     には、うまく行かない。次の例はそうした制限を一掃しているが、GNU
     `find' と GNU `xargs' の両方が必要である。

          find . -mindepth 1 -maxdepth 1 -print0 \
            | xargs --null --no-run-if-empty \
                mv -t ../d


`--target-directory' (`-t') オプションと `--no-target-directory' (`-T')
オプションを一緒に使うことはできない。


File: coreutils-ja.info,  Node: Trailing slashes,  Next: Traversing symlinks,  Prev: Target directory,  Up: Common options

2.9 末尾のスラッシュ
============================

いくつかの GNU プログラム (少なくとも、`cp' と `mv') では、SOURCE 引数を
処理する前に、その引数の末尾にスラッシュが付いていたら、それを除去する
ことができるようになっている。`--strip-trailing-slashes' オプションを
使用することによって、この動作が有効になる。

   これが役に立つのは、SOURCE 引数の末尾にスラッシュが付いていて、
しかも、その引数がディレクトリへのシンボリックリンクを指定している
かもしれないときだ。そうした状況は、実のところ、それほど珍しくない。
と言うのも、シェルの中には、そうしたシンボリックリンクに対して
ファイル名の補完を行うとき、末尾にスラッシュを自動的に付加するものが
あるからだ。このオプションを指定しないと、たとえば `mv' は、(システムの
rename 関数を通してだが、) 末尾にスラッシュが付いていることを、「シン
ボリックリンクの参照をたどれ」という指示として解釈しなければならず、
その結果、シンボリックリンクではなく、間接的に参照されたディレクトリの
方をリネームしなければならなくなる。こうした動作がデフォルトになって
いるのは意外に思えるかもしれないが、POSIX で要求されている動作であり、
POSIX の規格のほかの部分とも首尾一貫している。


File: coreutils-ja.info,  Node: Traversing symlinks,  Next: Treating / specially,  Prev: Trailing slashes,  Up: Common options

2.10 シンボリックリンクをたどる
============================================

以下のオプションは、`--recursive' (`-R') オプションも同時に指定されて
いるとき、`chown' コマンドや `chgrp' コマンドがディレクトリ階層をどう
たどるか、そのたどり方を変更する。以下のオプションを複数個指定した場合
は、最後に指定したものだけが効果を持つ。こうしたオプションが指定して
いるのは、ディレクトリに対するシンボリックリンクを処理する際に、その
シンボリックリンクそのものを操作の対象にするのか、それとも、そのディレ
クトリ以下の階層にあるすべてのファイルを操作の対象にするのかということ
である。

   こうしたオプションは、`--dereference' や `--no-dereference' (`-h')
とは、全く別のものである。あちらは、シンボリックリンクを変更するのか、
それとも、その参照先を変更するのかを制御している。

`-H'
     `--recursive' (`-R') オプションが指定されている場合に、コマンド
     ラインで指定された引数がディレクトリへのシンボリックリンクならば、
     それをたどる。

`-L'
     ディレクトリ階層を再帰的にたどる際に、ディレクトリへのシンボリック
     リンクに出会ったら、必ずそれをたどる。

`-P'
     シンボリックリンクを一切たどらない。これが、`-H', `-L', `-P' の
     どれも指定されていないときの、デフォルトである。



File: coreutils-ja.info,  Node: Treating / specially,  Next: Special built-in utilities,  Prev: Traversing symlinks,  Up: Common options

2.11 `/' (ルート) を特別扱いする
==========================================

ある種のコマンドは、ディレクトリ階層全体に対して破壊的な作用を及ぼす
可能性がある。たとえば、しかるべき特権を持ったユーザが、間違えて `rm
-rf / tmp/junk' を実行したら、システム全体のすべてのファイルが消えて
しまうかもしれないのだ。そうしたコマンドの使用が正当であることは、
めったにないので、GNU の `rm' は、`/' に還元されるようないかなるディレ
クトリに対しても、通常では、操作を拒否するようになっている。もし、本当に
システムのすべてのファイルを消去しようと思うのなら、`--no-preserve-root'
オプションを使用すればよい。とは言え、ほとんどの用途で、デフォルトの動作
(明示的に指定するには、`--preserve-root' オプションを使う) の方が安全で
ある。

   `chgrp', `chmod', `chown' などのコマンドも、ディレクトリ階層全体に
対して破壊的な作用を及ぼす可能性がある。従って、こうしたコマンドもまた、
上記のオプションをサポートしている。こうしたコマンドは、`rm' とは
違って、ファイルを実際に削除してしまうわけではないが、`/' から再帰的に
働くときは、一層危険だと言うこともできる。と言うのは、たいていの場合、
処理速度がずっと早いので、注意力のあるユーザがコマンドを中断できるより
前に、`rm' の場合より、もっと多くのファイルに被害を与えてしまうからだ。
Unix の習慣も POSIX の規格も、こうしたコマンドが `/' から再帰的に働く
ことを要求している。それ故、デフォルトが `--no-preserve-root' になって
いるのだが、こうしたコマンドは、`--preserve-root' オプションを使った方
が、ほとんどの用途でより安全である。面倒ならば、エイリアスか、シェル関数
を作って、`--preserve-root' を指定しておけばよいのだ。

   また、`--preserve-root' を指定すると、`/' を指すシンボリックリンクの
参照を行っている場合でも、`chgrp' や `chown' が、`/' のグループや所有者
を変更しなくなることも、憶えておいていただきたい。(訳注: `chgrp' や
`chown' の解説を見ていただけばわかるが、これは、`--recursive' (`-R') を
同時に使っている場合の話である。)


File: coreutils-ja.info,  Node: Special built-in utilities,  Next: Standards conformance,  Prev: Treating / specially,  Up: Common options

2.12 特殊ビルトイン・ユーティリティ
==================================================

プログラムの中には、`nice' のように、ほかのプログラムを起動できるものが
ある。たとえば、`nice cat file' というコマンドは、コマンド `cat file' を
実行することによって、`cat' プログラムを起動する。しかしながら、`exit'
のような特殊ビルトイン・ユーティリティ ("special built-in utilities")
は、この方法で起動することができない。一例を挙げれば、`nice exit' と
いうコマンドは、どんな動作をするかが明確に定義されていない。終了する
代わりに、エラーメッセージを出すかもしれないのだ。

   POSIX 1003.1-2004 の規格では、特殊ビルトイン・ユーティリティとして
次のものを挙げている。

     . : break continue eval exec exit export readonly return set shift
     times trap unset

   たとえば、`.', `:', `exec' は、特殊ビルトイン・ユーティリティなので、
`nice . foo.sh', `nice :', `nice exec pwd' といったコマンドの動作は、
読者が予想なさるかもしれないようなものにはならない。

   (訳注: exec, exit など対して、同じシェルの組み込みコマンドでも、cd,
alias, fg, kill, pwd, true, umask などは、通常ビルトイン・ユーティリティ
("regular built-in utilities") と呼ばれている。もっとも、nice などから
実行できないという点では、特殊ビルトイン・ユーティリティも通常ビルト
イン・ユーティリティも変わりがない。nice などから起動できるとすれば、
それは同名の実行ファイルが存在するからだ)。

   多くのシェルは、上記のリストを拡張している。たとえば、bash では、
`history' や `suspend' といったコマンドが特殊ビルトイン・ユーティリティ
に追加されている。そこで、bash の場合、`nice suspend' というコマンドを
実行すると、シェルのサスペンドは起こらず、エラーメッセージが出力される。


File: coreutils-ja.info,  Node: Standards conformance,  Prev: Special built-in utilities,  Up: Common options

2.13 標準への準拠
=======================

GNU ユーティリティのデフォルトの動作が POSIX の規格と一致しない場合
が、若干ながら存在する。そうした非互換性を抑制するには、環境変数
`POSIXLY_CORRECT' を設定すればよい。もっとも、POSIX に準拠しているか
否かを点検しているのでもないかぎり、`POSIXLY_CORRECT' を設定する必要は、
おそらくないだろうが。

   POSIX の新しいバージョンが、古いバージョンと非互換であることが、
ときどきある。たとえば、POSIX の昔のバージョンでは、`sort +1' という
コマンドは、各入力行の二番目以後のフィールドに基づいて、行の並べ替えを
行うことになっていた。ところが、POSIX 1003.1-2001 以降では、同じコマンド
が `+1' という名前のファイルの行を並べ替えることになっている。そこで、
フィールドに基づいた並べ替えを行うには、`sort -k 2' という別のコマンド
を使わなければならないのだ。

   通常 GNU のユーティリティは、お使いのシステムにとって標準である POSIX
のバージョンに従っている。GNU ユーティリティを POSIX の別のバージョンに
準拠させるには、環境変数 `_POSIX2_VERSION' を設定すればよい。この環境
変数の値は、YYYYMM という形式であり、その規格が採用されたのが何年の何月
かを示している。`_POSIX2_VERSION' の値としては、現在のところ、次の三つが
サポートされている。すなわち、`199209', `200112', `200809' であり、それ
ぞれ POSIX 1003.2-1992, POSIX 1003.1-2001, POSIX 1003.1-2008 を表して
いる。一例を挙げよう。使っているシステムが比較的新しいのに、動かして
いるソフトウェアが POSIX の昔のバージョンを前提としていて、`sort +1' や
`tail +10' を使用している場合は、環境に `_POSIX2_VERSION=199209' を設定
することで、互換性の問題を回避することができる。


File: coreutils-ja.info,  Node: Output of entire files,  Next: Formatting file contents,  Prev: Common options,  Up: Top

3 ファイル全体の出力
*****************************

次のコマンドはファイル全体を読み込んで、書き出す。内容に対して何らかの
変換を行うこともある。

* Menu:

* cat invocation::           ファイルを結合して、書き出す。
* tac invocation::           ファイルを結合し、ファイルごとに逆順で書き出す。
* nl invocation::            行番号を付けて、ファイルを書き出す。
* od invocation::            ファイルを 8 進数などの形式で書き出す。
* base64 invocation::        データを ASCII 文字で表示可能なデータに変換する。


File: coreutils-ja.info,  Node: cat invocation,  Next: tac invocation,  Up: Output of entire files

3.1 `cat': ファイルを結合して、書き出す
=====================================================

`cat' は、各 FILE (`-' は標準入力を意味する) を標準出力にコピーする。
FILE が一つも指定されていない場合は、標準入力から読み込む。

   書式:

     cat [OPTION] [FILE]...

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-A'
`--show-all'
     `-vET' と同じ。

`-b'
`--number-nonblank'
     空行以外のすべての出力行に、1 から始まる番号を付ける。

`-e'
     `-vE' と同じ。

`-E'
`--show-ends'
     各行の末尾に `$' 記号を付ける。

`-n'
`--number'
     すべての出力行に、1 から始まる番号を付ける。このオプションは、`-b'
     が有効になっているときは、無視される。

`-s'
`--squeeze-blank'
     連続する空行の表示を抑制する。すなわち、連続する複数の空行の代わりに、
     たった 1 行だけ空行を出力する。

`-t'
     `-vT' と同じ。

`-T'
`--show-tabs'
     TAB 文字を `^I' と表示する。

`-u'
     無視される。POSIX との互換のためにある。

`-v'
`--show-nonprinting'
     LFD と TAB 以外の制御文字を `^' 表記を使って表示する。高位ビットの
     セットされている文字の前には、`M-' を付ける。


   テキストファイルとバイナリファイルを区別する MS-DOS のようなシステム
では、`cat' は通常、バイナリモードで読み書きを行う。しかしながら、
`-bensAE' といったオプションの一つが使われている場合や、読み込みの
対象が標準入力で、しかも、標準入力が端末である場合は、`cat' はテキスト
モードで読み込みを行う。同様に出力においても、`-bensAE' といったオプ
ションの一つが使用されていたり、標準出力が端末である場合は、`cat' は
テキストモードで書き出しを行う。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例:

     # f の内容、標準入力、g の内容の順で出力する。
     cat f - g

     # 標準入力を標準出力にコピーする。
     cat


File: coreutils-ja.info,  Node: tac invocation,  Next: nl invocation,  Prev: cat invocation,  Up: Output of entire files

3.2 `tac': ファイルを結合し、ファイルごとに逆順で書き出す
================================================================================

`tac' は、各 FILE (`-' は標準入力を意味する) を、FILE ごとにレコード
(records、デフォルトでは行) の順番を逆にして、標準出力にコピーする。
FILE が一つも指定されていない場合は、標準入力から読み込む。

   書式:

     tac [OPTION]... [FILE]...

   レコード ("records") は、ある文字列 (デフォルトでは改行) が出現する
ことによって区切られる。出力の際、デフォルトでは、この区切り文字列は、
ファイル中でその区切り文字列の直前にあるレコードの末尾に付加される。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--before'
     出力の際、区切り文字列は、ファイル中でその区切り文字列の直後に来る
     レコードの先頭に付加される。

`-r'
`--regex'
     区切り文字列を正規表現として処理する。MS-DOS/MS-Windows 上で `tac'
     を使用するユーザは、`tac' はバイナリモードでファイルを読み込む
     ので、テキストファイルの各行の末尾が、Unix 流の LF ではなく、CR/LF
     になっているかもしれないことに注意するべきである。

`-s SEPARATOR'
`--separator=SEPARATOR'
     改行の代わりに、SEPARATOR をレコード区切り文字列 (record separator)
     として使用する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: nl invocation,  Next: od invocation,  Prev: tac invocation,  Up: Output of entire files

3.3 `nl': 行番号を付けて、ファイルを書き出す
=============================================================

`nl' は、各 FILE (`-' は標準入力を意味する) を、全部の行、または、
一部の行に行番号を付けて、標準出力に書き出す。FILE が一つも指定されて
いない場合は、標準入力から読み込む。

   書式:

     nl [OPTION]... [FILE]...

   `nl' は、入力されたものを (論理) ページに分解する。デフォルトでは、
行番号は各論理ページの先頭で 1 にリセットされる。`nl' は、すべての
入力ファイルをまとめて、一つのドキュメントとして扱う。従って、入力
ファイルが変わるたびに、論理ページや行番号がリセットされることはない。

   論理ページは、三つのセクションからなる。すなわち、ヘッダ、本文、
フッタである。どのセクションも空であって構わない。セクションごとに
他のセクションとは異なる番号付けの方式を選ぶこともできる。

   入力ファイル中で論理ページの各セクションが始まる位置を指示するには、
以下の区切り文字列の一つのみからなる行を使用する。

`\:\:\:'
     ヘッダの先頭。

`\:\:'
     本文の先頭。

`\:'
     フッタの先頭。

   上記の文字列を構成する二文字は、オプションを使って (下記参照)、`\'
と `:' の組み合わせ以外のものに、変更することができる。だが、各文字列
のパターンや長さは、変えることができない。

   セクションの区切りは、出力では空行に置き換えられる。入力ファイル中の
最初のセクション区切り文字列より前にあるテキストは、いかなるテキストも、
本文セクションの一部と見なされる。従って、`nl' は、セクションの区切りを
全く含まないファイルを、一個の本文セクションとして扱う。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b STYLE'
`--body-numbering=STYLE'
     各論理ページの本文セクションにおける行の番号付けの方式を選択する。
     行に番号が付かない場合、行番号の現在値は増加しないが、それでも行番号
     の区切り文字は行の前に付く (訳注: 手元にある coreutils-8.20 の nl
     の場合、空行のような行番号が付かない行には、行番号とテキストの区切り
     文字も付かないようだ)。番号付けの方式には、以下のものがある。

    `a'
          すべての行に番号を振る。

    `t'
          空ではない行にのみ番号を振る (本文のデフォルト)。

    `n'
          行番号を付けない (ヘッダとフッタのデフォルト)。

    `pBRE'
          基本正規表現 BRE にマッチする部分を含む行にのみ番号を振る。
          *Note Regular Expressions: (grep)Regular Expressions.

`-d CD'
`--section-delimiter=CD'
     セクションの区切り文字を CD にする。デフォルトは `\:'。C のみを指定
     すると、二番目の文字は、デフォルトと同じ `:' になる。(`\' などの
     メタ文字は、シェルが展開しないように、引用符やバックスラッシュで保護
     するのをお忘れなく。)

`-f STYLE'
`--footer-numbering=STYLE'
     `--body-numbering' と同様。

`-h STYLE'
`--header-numbering=STYLE'
     `--body-numbering' と同様。

`-i NUMBER'
`--line-increment=NUMBER'
     行番号を NUMBER づつ増やす (デフォルトは 1)。

`-l NUMBER'
`--join-blank-lines=NUMBER'
     空行にも番号を付けるとき、連続する NUMBER (デフォルトは 1) 行の
     空行を 1 論理行と数え、最後の空行にのみ番号を振る。連続する空行が
     NUMBER 行未満のときは、番号を振らない。空行というのは、文字を全く
     含まない、スペースやタブさえも含まない行のことである。

`-n FORMAT'
`--number-format=FORMAT'
     行番号付けのフォーマットを選択する (デフォルトは `rn')。

    `ln'
          左詰めにする。先頭を 0 で埋めない。

    `rn'
          右詰めにする。先頭を 0 で埋めない。

    `rz'
          右詰めにする。先頭を 0 で埋める。

`-p'
`--no-renumber'
     論理ページの先頭で行番号をリセットしない。

`-s STRING'
`--number-separator=STRING'
     出力中で行番号とテキスト部分との区切りに STRING を使う (デフォルト
     はタブ文字)。

`-v NUMBER'
`--starting-line-number=NUMBER'
     論理ページごとに行番号を NUMBER から始める (デフォルトは 1)。

`-w NUMBER'
`--number-width=NUMBER'
     行番号に  NUMBER 個の文字を使用する (デフォルトは 6 文字)。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: od invocation,  Next: base64 invocation,  Prev: nl invocation,  Up: Output of entire files

3.4 `od': ファイルを 8 進数などの形式で書き出す
================================================================

`od' は、各 FILE (`-' は標準入力を意味する) の内容を、曖昧さの余地がない
形で標準出力に書き出す。FILE が一つも指定されていない場合は、標準入力
から読み込む。

   書式:

     od [OPTION]... [FILE]...
     od [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]
     od [OPTION]... --traditional [FILE] [[+]OFFSET[.][b] [[+]LABEL[.][b]]]

   各出力行の構成は、入力中の位置をオフセットで表したものの後に、
ファイルのデータをいくつかのまとまりに分けたものが続くという形に
なっている。デフォルトでは、`od' はオフセットを 8 進数で表示する。
ファイル・データの個々のまとまりは、入力を C 言語の `short int' ごとに
分けたものであり、一つの 8 進数として表示される。

   OFFSET を指定した場合、それは、整形と出力を始める前に、入力を
何バイト読み飛ばすかを示している。デフォルトでは、OFFSET は 8 進数と
見なされるが、数字の後ろに小数点を付ければ、10 進数と見なされる。
小数点が指定されず、オフセットの数字が `0x' や `0X' で始まっている場合
は、16 進数として解釈される。もし、数字の後ろに `b' が付いているなら
ば、読み飛ばすバイト数は、OFFSET に 512 を掛けたものになる。

   (訳注: 数字の後ろに小数点を付けることで OFFSET が 10 進数であること
を示す方法は、現在では無効のようである。オフセットを 10 進数で指定した
ければ、`-j' オプションを使用した方がよい。)

   コマンドが「書式」における第一の型と第二の型のどちらとも取れるとき
は、最後のオペランドが `+' で始まっている場合や、オペランドが 2 個で 2
番目のオペランドが数字で始まっている場合は、第二の型だと見なされる。
たとえば、`od foo 10' や `od +10' では、`10' はオフセットである。
それに対して、`od 10' では、`10' はファイル名である。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-A RADIX'
`--address-radix=RADIX'
     ファイル・オフセットの表示に使う基数を選択する。RADIX には、以下の
     一つが使える。

    `d'
          10 進数

    `o'
          8 進数

    `x'
          16 進数

    `n'
          なし (オフセットを表示しない)

     デフォルトは 8 進数である。

`-j BYTES'
`--skip-bytes=BYTES'
     整形と出力を行う前に、入力を BYTES バイト読み飛ばす。BYTES が `0x'
     や `0X' で始まっている場合は、16 進数として解釈される。`0' のみで
     始まっている場合は、8 進数だ。どちらでもない場合は、10 進数である。
     BYTES は整数であり、以下に挙げるような、何倍かを表す接尾辞を
     後ろに付けることもできる。
          `b'  =>            512 ("blocks")
          `KB' =>           1000 (KiloBytes)
          `K'  =>           1024 (KibiBytes)
          `MB' =>      1000*1000 (MegaBytes)
          `M'  =>      1024*1024 (MebiBytes)
          `GB' => 1000*1000*1000 (GigaBytes)
          `G'  => 1024*1024*1024 (GibiBytes)
     `T', `P', `E', `Z', `Y' についても同様。

`-N BYTES'
`--read-bytes=BYTES'
     入力から最大で BYTES バイト出力する。`bytes' に接頭辞や接尾辞を
     付けると、`-j' オプションの場合と同じように解釈される。

`-S BYTES'
`--strings[=BYTES]'
     通常の出力はせず、文字列定数 ("string constants") のみを出力する。
     すなわち、BYTES バイト以上の連続する ASCII 表示文字で、ゼロバイト
     (ASCII NUL) が続くものを出力するわけだ。BYTES に接頭辞や接尾辞を
     付けると、`-j' オプションの場合と同じように解釈される。

     `--strings' に続く BYTES が省略された場合、デフォルトは 3 である。

`-t TYPE'
`--format=TYPE'
     ファイルデータの出力形式を選択する。TYPE は、1 個以上の下記の形式
     指定文字からなる文字列である。一つの TYPE 文字列に複数の形式指定
     文字が含まれている場合や、このオプションを複数回使用した場合は、`od'
     は出力行ごとに、指定された各データ形式で表現したその行を、指定された
     順番で書き出す。

     どんな形式指定であれ、その最後に "z" を付けると、形式指定によって
     生成された出力行の後ろに、表示可能文字を ASCII 文字によって表現した
     ものが、出力される。

    `a'
          文字の名称 (訳注: たとえば、A は A、改行文字は nl)。最上位
          ビットは無視する。

    `c'
          ASCII 文字かバックスラッシュ・エスケープ

    `d'
          符号付き 10 進数

    `f'
          浮動小数点数 (*note Floating point::)

    `o'
          8 進数

    `u'
          符号なし 10 進数

    `x'
          16 進数

     `a' 形式の出力では、空白文字は `sp'、改行は文字 `nl'、ゼロバイトは
     `nul' といった具合に表現される。このとき、各バイトの下位 7 ビット
     のみが使われ、最上位ビットは無視される。`c' 形式の出力では、上記の
     例は、それぞれ ` '、`\n'、`\0' になる。

     `a' と `c' 形式を除き、形式指定文字の後ろに 10 進数の整数を置くこと
     で、指定されたデータ形式の各数値を解釈する際に、何バイトづつ使用する
     かを指定することができる。あるいは、形式指定文字の後ろに以下の文字の
     一つを置くことによって、C コンパイラの組み込みデータ型のサイズを
     指定することも可能だ。すなわち、整数 (`d', `o', `u', `x') に対して
     は、以下を後置する。

    `C'
          char

    `S'
          short

    `I'
          int

    `L'
          long

     浮動小数点数 (`f') に対しては、

    F
          float

    D
          double

    L
          long double

`-v'
`--output-duplicates'
     連続する行が同一であっても出力する。デフォルトでは、出力する行が、
     二行以上連続して全く同一になりそうな場合、`od' は最初の行だけを
     出力し、次の行にはアステリスクのみを置いて、二行目以下を省略した
     ことを示す。

`-w[N]'
`--width[=N]'
     1 出力行当たり、`n' バイトの入力をダンプする。この値は、指定した
     各出力形式に結び付いているサイズの最小公倍数の倍数でなければ
     ならない。

     このオプションが全く指定されないときのデフォルトは 16 である。
     このオプションが N なしで指定されたときのデフォルトは 32 である。


   以下に挙げるいくつかのオプションは、形式指定の簡易版である。GNU `od'
では、形式指定オプションと簡易版オプションをどのように組み合わせても
構わない。こうしたオプションは、累加されていく。

`-a'
     文字の名称で出力する。`-t a' と同じ。

`-b'
     1 バイトづつ 8 進数として出力する。`-t o1' と同じ。

`-c'
     ASCII 文字かバックスラッシュ・エスケープとして出力する。 `-t c'
     と同じ。

`-d'
     2 バイトづつ符号なし 10 進数として出力する。`-t u2' と同じ。

`-f'
     浮動小数点数として出力する。`-t fF' と同じ。

`-i'
     10 進数の int として出力する。`-t dI' と同じ。

`-l'
     10 進数の long int として出力する。`-t dL' と同じ。

`-o'
     2 バイトづつ 8 進数として出力する。`-t o2' と同じ。

`-s'
     2 バイトづつ 10 進数として出力する。`-t d2' と同じ。

`-x'
     2 バイトづつ 16 進数として出力する。`-t x2' と同じ。

`--traditional'
     昔の `od' で使用できた、オプションではない引数 LABEL を認識する。
     書式は次のようになる。

          od --traditional [FILE] [[+]OFFSET[.][b] [[+]LABEL[.][b]]]

     この書式を使用すると、ファイルは 1 個までしか指定できないが、必要
     なら、オフセットを示す引数や、LABEL という、開始位置の仮アドレス
     を示す引数を、続けて指定することができる。引数 LABEL は OFFSET と
     全く同じように解釈されるが、出力を開始する位置の仮アドレスを指定
     している。仮アドレスは、通常のアドレスの後ろに、カッコで囲まれて、
     表示される。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: base64 invocation,  Prev: od invocation,  Up: Output of entire files

3.5 `base64': データを表示可能データ (printable data) に変換する
================================================================================

"`base64' はファイル、または標準入力から読み込んだデータを、base64 で
エンコードした形式に変換する (あるいは、その逆を行う)。base64 で
エンコードした形式は、表示可能な ASCII 文字を用いて、バイナリデータを
表現する。

   書式:

     base64 [OPTION]... [FILE]
     base64 --decode [OPTION]... [FILE]

   base64 でエンコードすると、データが元のデータのほぼ 133% に増大する。
base64 エンコード形式は、RFC4648 に準拠している。
`ftp://ftp.rfc-editor.org/in-notes/rfc4648.txt'

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-w COLS'
`--wrap=COLS'
     エンコード中に、出力が COLS 文字に達したら改行する。この値は、正の
     整数でなければならない。

     デフォルトでは、76 文字で改行する。改行を全く行わないようにする
     には、値を 0 にする。

`-d'
`--decode'
     動作モードを変更する。デフォルトの、データをエンコードするモード
     ではなく、データをデコードするモードになる。入力には、base64 で
     エンコードしたデータが期待され、出力は、エンコードする前のデータ
     になる。

`-i'
`--ignore-garbage'
     デコードする際、改行文字がどこに現れても、適切に処理する。デコード
     中に ASCII 表示可能文字以外を表すバイトが現れたら、一部壊れたデータ
     でもデコードできるように、それを無視する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Formatting file contents,  Next: Output of parts of files,  Prev: Output of entire files,  Up: Top

4 ファイル内容の整形
*****************************

以下のコマンドは、ファイルの内容の再整形を行う。

* Menu:

* fmt invocation::           パラグラフに分かれたテキストを整形し直す。
* pr invocation::            ページ付けや段組みをしてファイルを表示する。
* fold invocation::          入力行を指定された幅に合わせて折り返す。


File: coreutils-ja.info,  Node: fmt invocation,  Next: pr invocation,  Up: Formatting file contents

4.1 `fmt': パラグラフに分かれたテキストを整形し直す
=======================================================================

`fmt' は行を折り返したり、結合したりして、出力する各行が指定された
文字数に納まるように調整する。1 行のデフォルトは 75 文字である。(訳注:
日本語のテキストは、通常単語を空白で区切らないので、うまく整形できない。)

   書式:

     fmt [OPTION]... [FILE]...

   `fmt' は、指定された引数 FILE から (指定されていない場合は、標準
出力から) テキストを読み込んで、標準出力に書き出す。

   デフォルトでは、空行、単語間の空白、インデント (字下げ) は、出力でも
そのまま維持される。インデントの違う入力行が連続する場合は、行の結合は
行われない。タブは入力のときにスペースに展開され、出力でタブに戻される。

   `fmt' は、できるだけ文の終わりで改行しようとする。また、文の最初の
単語の直後や、文の最後の単語の直前で改行するのは避けようとする。「文の
終わり ("sentence break")」の定義は、パラグラフがそこで終わっているか、
あるいは、単語の末尾に `.?!' のどれかが付き、さらにスペースが 2 個
続くか、行末が来ることである。後者の場合、ピリオドなどとスペース 2 個、
あるいは行末の間にカッコや引用符が入っても、構わない。TeX と同様、`fmt'
は、どこで行を折り返すかを決める前に、パラグラフ全体を読み込む。使用して
いるアルゴリズムは、Donald E. Knuth と Michael F. Plass が "Breaking
Paragraphs Into Lines" で提示しているものに変更を加えたものである
(`Software--Practice & Experience 誌'、第 11 巻 第 11 号 (November
1981) 1119-1184 ページ)。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--crown-margin'
     クラウンマージン・モード ("Crown margin" mode) である。パラグラフの
     最初の 2 行のインデントはそのまま踏襲し、それに続く各行の左の余白を
     2 行目のインデントに揃える。

`-t'
`--tagged-paragraph'
     タグ付きパラグラフ・モード ("Tagged paragraph" mode)。クラウンマー
     ジン・モードに似ているが、次の点が違う。パラグラフの最初の行と
     二番目の行のインデントが同じ場合、最初の行は 1 行からなるパラグラフ
     として扱われる。

`-s'
`--split-only'
     行の分割のみを行う。短い行を結合して、長い行を作ることはしない。
     その結果、サンプル・コードの行のような、すでに整形されたテキストを
     むやみに結合しないで済む。

`-u'
`--uniform-spacing'
     空白の数を一定にする。すなわち、単語間の空白は 1 個に、文の間の
     空白は 2 個にする。

`-WIDTH'
`-w WIDTH'
`--width=WIDTH'
     出力する各行を、長くても WIDTH 文字までにする (デフォルトは 75
     文字。GOAL が指定されている場合は、GOAL プラス 10 文字)。

`-g GOAL'
`--goal=GOAL'
     とりあえず、各行を GOAL 文字の長さにしてみようとする。これは、
     デフォルトでは WIDTH より 7% 短い。

`-p PREFIX'
`--prefix=PREFIX'
     PREFIX で始まる行のみを整形の対象にする (PREFIX の前にホワイト
     スペースがあってもよい)。PREFIX とそれに先行するホワイトスペース
     は、整形の際に取り除かれ、整形後に各出力行に付け直される。この
     オプションの用途を一つ挙げると、プログラムのコメントのような行
     だけを整形し、コードには手を加えないことが考えられる。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: pr invocation,  Next: fold invocation,  Prev: fmt invocation,  Up: Formatting file contents

4.2 `pr': ページ付けや段組みをしてファイルを表示する
=========================================================================

`pr' は、各 FILE (`-' は標準入力を表す) を標準出力に書き出す。FILE が
指定されていない場合は、標準入力を対象にする。その際、ページ付けを行い、
指定があれば段組みをして出力する。また、すべての FILE を一つに統合し、
1 段 1 ファイルの形で平行して表示することもできる。(訳注: `pr' の
日本語対応は完全ではない。とくに段組みがうまく行かない。)

   書式:

     pr [OPTION]... [FILE]...

   デフォルトでは、5 行のヘッダが各ページに付く。2 行の空行、日付、
ファイル名、ページ番号からなる 1 行、そしてもう 2 行の空行である。 5
行の空行からなるフッタも出力される。デフォルトのページ長 (PAGE_LENGTH)
は 66 行なので、本文に使用されるデフォルトの行数は、56 行である。
ヘッダのテキスト行は、`DATE STRING PAGE' の形を取り、STRING の両側に
空白を入れて、行の幅がページ幅 (PAGE_WIDTH) いっぱいになるように
している。DATE は日付であり (詳細については、`--date-format' (`-D')
オプションを参照)、STRING は中央揃えのヘッダ文字列 (訳注: デフォルト
ではファイル名)、PAGE はページ番号である。PAGE という単語の綴りは、
`LC_MESSAGES' ロケール・カテゴリによって変わってくる。デフォルトの C
ロケールでは、`Page NUMBER' であり、NUMBER は 10 進数のページ番号だ。

   入力にフォームフィード (Form feed) があると、出力では改ページが行われ
る。フォームフィードが続くと、白紙のページが生ずる。

   段組みをした場合、どの段の幅も同じであり、段の間には任意の文字列
(デフォルトはスペース) が置かれる。多段組みの出力では、`-J' オプション
を使用しないかぎり、各行は常に PAGE_WIDTH (デフォルトは 72) 文字までに
切り詰められる (訳注: これは、各段や段間の空白などを合計した 1 行の
長さが、最長でも PAGE_WIDTH 文字までになるということであって、格段が
それぞれ PAGE_WIDTH 文字になるということではない)。1 段のみの出力では、
デフォルトでは行の切り詰めは行われない。その場合でも、行の切り詰めを
行うには、`-W' を使用する。

   次の変更がバージョン 1.22i で行われた。従って、`pr' のそれ以後の
バージョンにも当てはまる。 (Brian 記)
   * 小文字のオプションのいくつか (`-s', `-w') は、POSIX に一層忠実に
     準拠するよう、再定義された。また、より高度な用法の出力の中には、他の
     Unix システムの動作に合わせたものもある。こうした変更は、`pr' の
     前のバージョンと互換性がない。

   * 小文字のオプションによる思いがけない副作用をなくすために、大文字の
     オプションが新たにいくつか導入された (`-J', `-S', `-W')。また `-N'
     オプションと `+FIRST_PAGE' の第二引数 LAST_PAGE によって、より柔軟
     な操作が可能になっている。入力ファイルにあるフォームフィードを細かく
     操作するには、`-T' オプションを使う必要がある。

   * 大文字のオプションは、小文字のオプションに優先する。

   * オプションに対する引数の中には、オプション文字とその引数の間に
     空白を挟むことができないものがある (`-s', `-e', `-i', `-n' など。
     これについては、POSIX の仕様にすでに言及がある)。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`+FIRST_PAGE[:LAST_PAGE]'
`--pages=FIRST_PAGE[:LAST_PAGE]'
     表示を FIRST_PAGE ページから始めて、 LAST_PAGE ページで終了する。
     `:LAST_PAGE' の指定を省略するのは、ファイルの最後までということで
     ある。スキップするページ数を計算する際、入力ファイル中にフォーム
     フィードがあると、そのたびに 1 ページ増えることになる。ページ番号
     は、`+FIRST_PAGE' があってもなくても、同じになる。デフォルトでは、
     入力ファイルの最初のページからカウントを始めるからだ (表示される
     最初のページからではない)。行番号については `-N' オプションで変更す
     ることができる。

`-COLUMN'
`--columns=COLUMN'
     FILE ごとに COLUMN 段に段組みした出力を生成する (デフォルトは 1
     段)。`-a' オプションを使用しない場合、ページ内で本文は、段内を
     上から下へと進む。段が増えると、段の幅は自動的に狭くなる。ただし、
     `-W/-w' を使用して、PAGE_WIDTH も増加させている場合は、そのかぎり
     ではない。このオプションを使うと、切り詰められる行がたぶん生じる
     だろう。ページごとの各段の行数は、できるだけ揃うように調整される。
     多段組みの本文出力では、オプション `-e' と `-i' が有効になる。
     `-J' オプションと一緒に使うと、段の整列と行の切り詰めは行われない。
     各行は、元の長さのまま、不定長フィールドとして (free field format)
     結合されるわけだ。その際、`-S' オプションでフィールド・セパレータを
     決めることができる。なお `-COLUMN' は、`-m' オプションと一緒に使用
     できない。

`-a'
`--across'
     FILE ごとに段組みして表示するとき、本文各行の並び方を、段内を
     上から下へではなく、左の段から右の段への順にする。`-COLUMN' オプ
     ションに指定する段の数は、2 以上でなければならない。行が段の幅に
     納まらないほど長い場合、その行は切り詰められる。

`-c'
`--show-control-chars'
     制御文字をハット表記 (たとえば、`^G') を使って表示する。他の非表示
     文字は、バックスラッシュ付きの 8 進数表記になる。`pr' のデフォルト
     では、非表示文字の表示変更は行われない。

`-d'
`--double-space'
     ダブルスペースで出力する (訳注: すなわち、行間を 1 行分あける)。

`-D FORMAT'
`--date-format=FORMAT'
     ヘッダの日付を FORMAT を用いて整形する。FORMAT には、コマンド
     `date +FORMAT' で使うのと同じ指定法が使用できる。*Note date
     invocation::.  `%' で始まる日時の指定を除いて、FORMAT 中の文字は
     そのまま表示される。従って、このオプションを使用すれば、ヘッダの
     日付の位置に任意の文字列を指定することもできるわけだ。たとえば、
     `--date-format="Monday morning"' といった具合に。

     デフォルトの日付書式は `%Y-%m-%d %H:%M' という形である (たとえば、
     `2001-12-04 23:59')。だが、環境変数 `POSIXLY_CORRECT' が設定され、
     しかも `LC_TIME' ロケール・カテゴリが POSIX ロケールを指定して
     いる場合は、デフォルトの書式は `%b %e %H:%M %Y' になる (たとえば、
     `Dec  4 23:59 2001')。

     タイムスタンプは、タイムゾーンのルールに従って表示されるが、その
     ルールを指定しているのは、環境変数 `TZ' である。`TZ' が設定されて
     いない場合は、システムのデフォルトのルールに従って表示される。
     *Note Specifying the Time Zone with `TZ': (libc)TZ Variable.

`-e[IN-TABCHAR[IN-TABWIDTH]]'
`--expand-tabs[=IN-TABCHAR[IN-TABWIDTH]]'
     入力の際にタブをスペースに展開する。省略できる引数 IN-TABCHAR は、
     入力で使われるタブ文字である (デフォルトは TAB 文字)。これも省略
     できる二番目の引数 IN-TABWIDTH は、入力で使われるタブ文字の幅で
     ある。(デフォルトは 8 桁)。

`-f'
`-F'
`--form-feed'
     複数個の改行文字ではなく、1 個フォームフィードを使用して、出力する
     各ページを分離する。このオプションによって、66 行というデフォルトの
     ページの長さが変わることはない。

`-h HEADER'
`--header=HEADER'
     ヘッダのファイル名の部分を、中央揃えの HEADER という文字列で置き換
     える。シェル上では、HEADER はクォートするべきである。また、`-h'
     との間に空白を入れた方がよい。

`-i[OUT-TABCHAR[OUT-TABWIDTH]]'
`--output-tabs[=OUT-TABCHAR[OUT-TABWIDTH]]'
     出力の際にスペースをタブで置き換える。省略できる引数 OUT-TABCHAR
     は、出力で使われるタブ文字である (デフォルトは TAB 文字)。これも
     省略できる二番目の引数 OUT-TABWIDTH は、出力で使われるタブ文字の
     幅である (デフォルトは 8 桁)。

`-J'
`--join-lines'
     長い行は長いまま結合する。段組みオプション `-COLUMN', `-a -COLUMN',
     `-m' と併せて使用する。`-W/-w' による行の切り詰めが無効になる。段の
     整列も行わなくなる。`--sep-string[=STRING]' と併せて使ってもよい。
     `-J' というオプションが (`-W' や `--sep-string' と一緒に) 新たに
     設けられたのは、`-w' や `-s' という、前からある (POSIX に準拠した)
     オプションを 3 種の段組みオプションと組み合わせて使う場合の混乱を
     解決するためである。

`-l PAGE_LENGTH'
`--length=PAGE_LENGTH'
     1 ページの行数を、ヘッダ行 (及び フッタ行) を含めて、PAGE_LENGTH
     行にする (デフォルトは 66 行)。PAGE_LENGTH が 10 行以下だったら、
     `-t' オプションが指定されたかのように、 ヘッダとフッタは省略する。

`-m'
`--merge'
     すべての FILE を統合し、各段に 1 ファイルを割り当てて、平行表示
     する。長すぎて段に納まらない行があれば、`-J' オプションが使用
     されていないかぎり、切り詰めが行われる。`--sep-string[=STRING]' を
     指定してもよい。いづれかの FILE に (フォームフィードの指定により)
     空白のページが存在すると、空白の段が生ずるが、それでも段を分離する
     記号の STRING は表示される。すなわち、統合されたファイルの最初から
     最後まで、行番号と (訳注: これはもちろん、`-n' オプションが指定され
     ている場合) 段の分離記号は、連続して表示されるわけだ。ただし、統合
     されたページのどの段も空白の場合は、分離記号も行番号も表示されない。
     デフォルトのヘッダは、`DATE PAGE' という形式になり、中央には空白が
     挿入される。`-h' や `--header' オプションを `-m' と一緒に使えば、
     この中央の空白部分に文字列を入れることができる。

`-n[NUMBER-SEPARATOR[DIGITS]]'
`--number-lines[=NUMBER-SEPARATOR[DIGITS]]'
     DIGITS の幅の行番号を表示する (DIGITS のデフォルトは 5 桁)。通常の
     多段組みの出力では、行番号は、各段ごとに本文の最初の DIGITS 桁分の
     位置を占めるが、`-m' の出力の場合は、各行の先頭だけに表示される。
     1 段組みでは、`-m' の場合と同様、各行の先頭に付く。デフォルトでは、
     行数は、入力ファイルの最初の行から数え始める (表示される最初の行
     からではない。`--page' や `-N' オプションを参照)。省略可能な引数
     NUMBER-SEPARATOR は、行番号の後ろに付けて、後に続く本文と区別する
     ための文字であり、デフォルトのセパレータはタブ文字である。厳密に
     言うと、常にタブが表示されるのは、1 段組みの出力のときだけである。
     タブの幅は、本来タブの現れる位置によって変化し、たとえば、`-o'
     オプションで指定される左の余白 (MARGIN) によって変わってくるもの
     である。しかし、多段組みの出力では、「出力される段の幅が同じになる」
     ことが優先されるので (POSIX の仕様)、タブの幅は、最初の段における
     値に固定され、左の余白の値が変わっても、変化することはない。すなわち、
     NUMBER-SEPARATOR のタブの位置には、常に一定数のスペースが表示される
     ということである。スペースをタブに置き換えるかどうかは、出力される
     位置次第である。

`-N LINE_NUMBER'
`--first-line-number=LINE_NUMBER'
     表示される最初のページの最初の行を LINE_NUMBER として行を数えて
     行く (入力ファイルの最初の行以外から表示を始めるときによく使う)。

`-o MARGIN'
`--indent=MARGIN'
     スペース MARGIN 個分の余白で各行をインデントする (デフォルトは、
     スペース 0 個)。ページの横幅は、`-W/-w' で指定した PAGE_WIDTH と
     余白を合計したサイズになる。行番号付きの 1 段組み出力では、行から
     少しはみ出す文字が生ずるかもしれない (`-n' オプション参照)。

`-r'
`--no-file-warnings'
     引数 FILE がオープンできないときも、警告メッセージを表示しない
     (終了ステータスは、それでもやはり 0 以外になる)。

`-s[CHAR]'
`--separator[=CHAR]'
     段と段の区切りに 1 個の文字 CHAR を使う。`-s' オプションの
     デフォルトの CHAR は、`-w' オプションを同時に指定しなければ
     タブ、指定すれば「なし」である。なお、`-s' オプションを指定
     しない場合、デフォルトのセパレータはスペースである。`-s[char]'
     オプションを使用すると、`-w' も同時に指定しないかぎり、3 種の
     段組みオプション (`-COLUMN'|`-a -COLUMN'|`-m') のすべてにおいて、
     行の切り詰めが行われない。これは、POSIX に準拠した仕様である。

`-S[STRING]'
`--sep-string[=STRING]'
     出力される段の区切りに、文字列 STRING を使用する。`-s' オプション
     が `-W/-w' オプションに影響を及ぼすのとは異なり、`-S' オプション
     は `-W/-w' オプションに影響を及ぼさない。また、行の切り詰めや段の
     整列にも影響しない。`-S' オプションを指定せずに、`-J' オプション
     を指定すると、`pr' はデフォルトの出力セパレータであるタブを使用
     する (訳注: `-J' 使用時のデフォルトということだと思う)。`-S' も
     `-J' も指定しない場合、`pr' が区切りに使用するのはスペースである
     (`-S" "' と同じこと)。`-S' だけで、引数の `STRING' を指定しないと、
     空文字列 (`""') を指定したことになる。

`-t'
`--omit-header'
     各ページにいつものようにヘッダ (とフッタ) を表示しない。また、
     ページの最下部を (空行やフォームフィードで) 埋めることもしない。
     ページ構成は行わないが、入力ファイルにあるフォームフィードは、
     そのままにしておく。つまり、あらかじめ決めておいたページ分割は、
     変わらないわけだ。`-t' や `-T' オプションは、他のオプションと
     組み合わせて使うと、便利なことがある。たとえば、`-t -e4' は、入力
     ファイルのタブ文字を 4 個のスペースに展開するが、それ以外何の
     変更も行わない。`-t' オプションを使用すると、`-h' オプションが
     無効になる。

`-T'
`--omit-pagination'
     ヘッダ (とフッタ) を表示しない。さらに、入力ファイルにあるフォーム
     フィードをすべて取り除く。

`-v'
`--show-nonprinting'
     非表示文字をバックスラッシュ付きの 8 進数表記で表示する。

`-w PAGE_WIDTH'
`--width=PAGE_WIDTH'
     本文を多段組み出力にしたときのみ、ページの幅を PAGE_WIDTH 文字に
     する (PAGE_WIDTH のデフォルトは 72 字)。多段組みで `-w' オプション
     を同時に指定せずに `-s[CHAR]' オプションを指定すると、デフォルトの
     ページ幅は無効になり、行の切り詰めや段の整列も行われない。すなわち、
     多段組みのオプションが指定されているのに、各行が長いものは長いまま
     結合されるてしまうのである。なお、1 段組みの出力では、PAGE_WIDTH の
     指定はできない。以上は、POSIX に準拠した仕様である。

`-W PAGE_WIDTH'
`--page_width=PAGE_WIDTH'
     ページの幅を PAGE_WIDTH 文字にする。この指定は、段組みオプションが
     あってもなくても、有効である。`-J' オプションを使用しないかぎり、
     本文の行が切り詰められる。3 種の段組みオプション (`-COLUMN', `-a
     -COLUMN', `-m') と組み合わせて使った場合、段の整列が常に行われる。
     セパレータを指定するオプションの `-S' や `-s' は、`-W' オプションに
     影響を及ぼさない。デフォルトは 72 文字である。`-W PAGE_WIDTH' も
     なく、段組みオプションも全く指定されていない場合に、行の切り詰めが
     行われることは絶対にない (下位互換を維持しつつ、よく行われる作業の
     ほとんどに対応するために、そうなっている)。この動作は、`-W 72 -J'
     と同じである。なお、ヘッダ行が切り詰められることは絶対にない。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: fold invocation,  Prev: pr invocation,  Up: Formatting file contents

4.3 `fold': 入力行を指定された幅に合わせて折り返す
=====================================================================

`fold' は、各 FILE (`-' は標準入力を表す) を、長い行は折り返して、標準
出力に書き出す。FILE が指定されていない場合は、標準入力を対象にする。
(訳注: `fold' の日本語対応は完全ではない。)

   書式:

     fold [OPTION]... [FILE]...

   デフォルトでは、`fold' は 80 桁よりも長い行を折り返す。出力は必要なら
何行にも分割されることになる。

   `fold' はデフォルトでは、画面上の桁数を数える。従って、タブは 2 桁
以上に数えられるかもしれないし、バックスペースは桁数を減らすことになる。
また、復帰文字 (carriage return) は、桁数を 0 にする。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--bytes'
     桁数ではなく、バイト数を数える。従って、タブ、バックスペース、復帰
     文字も、他の文字と全く同じように、それぞれ 1 桁を占めるものとして
     計算される。

`-s'
`--spaces'
     単語境界で折り返す。行は、行の最大長より前にある最後の空白の後ろで
     折り返される。行にそうした空白がない場合は、通常通り、行の最大長で
     折り返される。

`-w WIDTH'
`--width=WIDTH'
     行の最大長に 80 桁ではなく、WIDTH 桁を使用する。

     互換性のために、`fold' は古い書式のオプション `-WIDTH' もサポート
     している。新しいスクリプトでは、`-w WIDTH' の方を使用すべきである。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Output of parts of files,  Next: Summarizing files,  Prev: Formatting file contents,  Up: Top

5 ファイルの部分出力
*****************************

以下のコマンドは、入力の一部を出力する。

* Menu:

* head invocation::          ファイルの先頭部分を出力する。
* tail invocation::          ファイルの末尾部分を出力する。
* split invocation::         ファイルを分割する
* csplit invocation::        ファイルを内容を目印にして分割する。


File: coreutils-ja.info,  Node: head invocation,  Next: tail invocation,  Up: Output of parts of files

5.1 `head': ファイルの先頭部分を出力する
======================================================

`head' は、各 FILE の先頭部分 (デフォルトでは 10 行) を表示する。
ファイルが指定されていない場合や、FILE として `-' が指定されている
場合は、標準入力から読み込む。

   書式:

     head [OPTION]... [FILE]...

   指定された FILE が 2 個以上あると、`head' は、次のような 1 行
からなるヘッダを出力する。

     ==> FILE NAME <==

このヘッダは、各 FILE の出力の前に置かれる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c K'
`--bytes=K'
     ファイルの先頭数行を表示する代わりに、先頭から K バイトを表示する。
     ただし、K が `-' で始まっている場合は、各ファイルについて、末尾の
     K バイトを除いたすべてを表示することになる。K
     は整数であり、以下に挙げるような、何倍かを表す接尾辞を
     後ろに付けることもできる。
          `b'  =>            512 ("blocks")
          `KB' =>           1000 (KiloBytes)
          `K'  =>           1024 (KibiBytes)
          `MB' =>      1000*1000 (MegaBytes)
          `M'  =>      1024*1024 (MebiBytes)
          `GB' => 1000*1000*1000 (GigaBytes)
          `G'  => 1024*1024*1024 (GibiBytes)
     `T', `P', `E', `Z', `Y' についても同様。

`-n K'
`--lines=K'
     ファイルの先頭から K 行を表示する。ただし、K が `-' で始まっている
     場合は、各ファイルについて、末尾の K 行を除いたすべてを表示すること
     になる。サイズの乗数接尾辞は、`-c' オプションの場合と同様である。

`-q'
`--quiet'
`--silent'
     ファイル名を示すヘッダを出力しない。

`-v'
`--verbose'
     ファイル名を示すヘッダを常に出力する。


   `head' は、互換性を考慮して、`-COUNTOPTIONS' というオプション指定の
古い書式もサポートしている。ただし、この書式が認識されるのは、最初の
オプションとして指定されたときだけである。COUNT は 10 進数であり、`-c'
オプションの場合と同様、サイズを示す文字 (`b', `k', `m') を後ろに続けて
もよく、また、行数であることを明示する `l' や、ほかのオプション文字
(`cqv') を続けることもできる。標準的なホストで使うことを意図したスク
リプトでは、古い書式ではなく、`-c COUNT' や `-n COUNT' を使用するべきで
ある。そのスクリプトが、古い書式にしか対応していないホストでも動かな
ければならない場合は、`head' を使わないで済ました方が、たいていの場合
簡明である。たとえば、`head -5' の代わりに、`sed 5q' を使用するわけだ。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: tail invocation,  Next: split invocation,  Prev: head invocation,  Up: Output of parts of files

5.2 `tail': ファイルの末尾部分を出力する
======================================================

`tail' は、各 FILE の末尾部分 (デフォルトでは 10 行) を表示する。
ファイルが指定されていない場合や、FILE として `-' が指定されている
場合は、標準入力から読み込む。

   書式:

     tail [OPTION]... [FILE]...

   指定された FILE が 2 個以上あると、`tail' は、以下のような 1 行
からなるヘッダを出力する。

     ==> FILE NAME <==

このヘッダは、各 FILE の出力の前に置かれる。

   GNU の `tail' は、出力するデータの量に制限がない (ほかの系統の
`tail' には、制限があるものもある)。また、GNU の `tail' には、 `-r'
オプション (逆順で表示する) が存在しない。ファイルを逆順にするのは、
ファイルの末端部分を表示するのとは、全く別の仕事だからである。BSD の
`tail' には、`-r' があるが、バッファの大きさまでのファイルしか逆順に
できず、それは通常 32 KiB である。ファイルを逆順にするなら、GNU の
`tac' コマンドの方が、信頼性という点でも、用途の広さという点でも
優れている。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c K'
`--bytes=K'
     ファイルの末尾数行を出力する代わりに、末尾の K バイトを出力する。
     ただし、K が `+' で始まっている場合は、各ファイルの末端から K
     バイト目ではなく、先頭から K バイト目を始点として出力を開始する。
     K は整数であり、以下に挙げるような、何倍かを表す接尾辞を
     後ろに付けることもできる。
          `b'  =>            512 ("blocks")
          `KB' =>           1000 (KiloBytes)
          `K'  =>           1024 (KibiBytes)
          `MB' =>      1000*1000 (MegaBytes)
          `M'  =>      1024*1024 (MebiBytes)
          `GB' => 1000*1000*1000 (GigaBytes)
          `G'  => 1024*1024*1024 (GibiBytes)
     `T', `P', `E', `Z', `Y' についても同様。

`-f'
`--follow[=HOW]'
     ファイルの末端まで達しても、さらに文字を読み込もうとして、無限
     ループする。たぶん、ファイルのサイズが増加し続けているからだろう。
     複数のファイルが指定されている場合、`tail' は、異なるファイル
     から出力があるたびに、その出力がどのファイルから来たのかがわかる
     ように、ヘッダを表示する。

     このオプションを使ってファイルの追跡をするとき、二つの方法が選択
     できるが、その違いがわかるのは、追いかけているファイルが消去され
     たり、名前を変更されたりしたときだけである。もし、増大しつつある
     ファイルが削除されたあとでも、そのファイルの末尾の追跡を続行したい
     ならば、`--follow=descriptor' を使用すればよい。これがデフォルト
     の動作だが、ログファイルを追跡している際には、役に立たない。ログ
     ファイルは、ローテートされる (すなわち、消去、または名前を変更
     されてから、改めてオープンされる) 可能性があるからだ。そうした
     場合には、`--follow=name' を使用すれば、指定した名前のファイルを
     追跡することができる。おそらく追跡には、定期的にその名前のファイル
     をオープンし直すことで、何らかのプログラムによってファイルが消去
     されてから再作成されなかったかどうかを確かめるといった方法が、
     使われることだろう。なお、inotify をベースにした実装では、こうした
     ケースを処理するのに、ファイルを定期的に再オープンする必要がない
     ことを付記しておく。

     どちらの方法を使った場合でも、追跡中のファイルのサイズが小さく
     なっていることがわかると、 `tail' は、ファイルが短縮されたという
     メッセージを出し、ファイルの終端と改めて判断したところからファイル
     の追尾を再開する。

     ファイルが消去されたときの `tail' の動作は、追いかけているものが、
     名前か (`--follow=name')、ディスクリプタか (`--follow=descriptor')
     によって異なっている。名前による追跡の場合、tail はファイルが消去
     されたことを検出できるので、その旨メッセージを表示する。このとき、
     `--retry' も指定されていると、同じ名前のファイルが再作成されている
     かどうか、定期的な検査を継続して行う。ディスクリプタを追跡する場合は、
     ファイルが削除されたり、名前の変更が行われたりしても、tail はそれを
     検出しないので、メッセージを出さない。そうしたファイルが、もはや元の
     名前ではアクセスできなくなっていても、なお増大し続けているということ
     もありえる。

     `descriptor' や `name' というオプションの値は、長い方のオプションの
     形式によってのみ指定できる。`-f' では指定できない。

     オペランド FILE が全く指定されていず、しかも標準入力が FIFO や
     パイプである場合、`-f' オプションは無視される。また、標準入力が
     FIFO やパイプである場合は、`-' という形で指定されたオペランドが
     あっても、`-f' はそれに対して効果を持たない。

     カーネルが inotify をサポートしていると、出力はファイルの変更が
     引き金になるので、一般に反応がキビキビしている。それに対して、
     カーネルが inotify をサポートしていないと、`tail' はチェック
     ごとに 1 秒間スリープするので (このデフォルトを変更するには、
     `--sleep-interval=N' を使用する)、出力の反応がやや遅めに感じられ
     たり、断続的に感じられたりするかもしれない。inotify のサポート
     なしで tail を使用する場合、反応を向上させるには、sleep する間隔を
     1 秒以下に設定すればよい。たとえば、次のようなエイリアスを作成する
     わけだ。

          alias tail='tail -s.1'

`-F'
     このオプションは `--follow=name --retry' と同じである。すなわち、
     ファイルが消去された場合、tail はその名前のファイルをオープン
     し直そうとする。それに失敗しても、ファイルに再びアクセスできるように
     なるまで、再オープンを試み続ける。

`--retry'
     このオプションが役に立つのは、主として名前による追跡を行うときである
     (すなわち、`--follow=name' とともに使うときだ)。このオプションを
     付けないと、 tail はファイルが存在しなくなったり、何かほかの理由で
     ファイルにアクセスできなくなったりしたとき、その旨報告するだけで、
     以後再検査を行うことがない。

`--sleep-interval=NUMBER'
     何秒間隔で追尾・表示動作を行うかを変更する (デフォルトは 1.0 秒
     である)。`tail' は動作の繰り返しごとに、指定されたすべてのファイル
     について、サイズが変わっていないかどうか、チェックを行う。`tail'
     の伝統的な実装では、NUMBER は整数であることが求められていた。だが、
     GNU の `tail' では、任意の浮動小数点数を指定することができる。
     *Note Floating point::.  `tail' が inotify を使用していると、この
     ポーリング関係の (polling-related) オプションは通常無視される。
     ただし、`--pid=P' も一緒に指定している場合は別で、`tail' は、
     プロセス P が生きているかどうかを、少なくとも NUMBER 間隔でチェック
     する。

`--pid=PID'
     追跡が名前によって行われようと、ディスクリプタによって行われ
     ようと、すべての  FILE 引数に対して書き込みをするプログラムがたった
     一つならば、そのプログラムのプロセス番号 PID を指定することが
     できる。そうしておくと、そのプロセスが終了するのとほとんど同時に、
     tail も終了するようになるのだ。これがきちんと動作するのは、書き込み
     プログラムと tail のプロセスが、同じマシンで動いているときだけで
     ある。たとえば、プログラムをビルドするとき、その出力をファイルに保存
     しながら、ファイルが増大して行くのを見守りたいならば、下記のように
     `make' と `tail' を実行すればよい。そうすれば、ビルドが完了した
     とき、tail のプロセスも終了する。このオプションを使わない場合は、
     `tail -f' のプロセスを自分で止めなければならないだろう。

          $ make >& makerr & tail --pid=$! -f makerr

     使用されていない PID を指定した場合や、tail が対象とするファイルに
     書き込んでいるプロセスとは別のプロセスの PID を指定した場合は、
     `tail' は、FILE の増大が止まるずっと前に終了してしまうかもしれ
     ないし、実際に書き込んでいるプログラムが終了してしまっても、当分
     の間終了しないかもしれない。気をつけてほしいが、システムによっては、
     `--pid' が使えないことがある。その場合、`tail' は警告メッセージ
     を出すはずだ。

`--max-unchanged-stats=N'
     名前によってファイルの追尾を行っているとき、連続して N 回 (デフォ
     ルトは n=5) 追尾動作を実行しても、その間にファイルに変更がなかった
     場合に、ファイルを `open' し、`fstat' して、そのファイル名と結び
     ついている「デバイス番号/inode 番号」の組み合わせが、今でも前と同じ
     ままかどうかを確認する。ローテートを行うログファイルを追跡している
     場合、この N は、tail がローテートする前に最後の行を表示してから、
     新しいログファイルに溜まっている行を表示するまでの秒数に、ほぼ等
     しい。このオプションに意味があるのは、ポーリングを使用して (すな
     わち、inotify を使わずに)、名前による追跡を行うときだけである。

`-n K'
`--lines=K'
     末尾の  K 行を出力する。ただし、K が `+' で始まっている場合は、
     各ファイルの末端から K 行目ではなく、先頭から K 行目を始点として
     出力を開始する。サイズの乗数接尾辞は、`-c' の場合と同様である。

`-q'
`--quiet'
`--silent'
     ファイル名を示すヘッダを出力しない。

`-v'
`--verbose'
     ファイル名を示すヘッダを常に出力する。


   `tail' は互換性のために、`tail -[COUNT][bcl][f] [FILE]' という古い
用法もサポートしているが、それが認識されるのは、上で説明した用法と衝突
しないときだけである。この旧式の書式では、オプションはただ 1 個しか指定
できず、ファイルも 1 個までしか指定できない。オプション中の COUNT は、
省略可能な 10 進数であり、サイズを表す文字 (`b', `c', `l') を後ろに
続けて、1 ブロック当たり 512 バイトのブロック数か、バイト数か、行数かを
示すことができる。また、`-f' と同じ意味を持つ、`f' を続けてもよい。

   古いシステムでは、旧式のオプション書式において、先頭の `-' を `-c'
や `-n' オプションの場合と同じ意味で `+' に置き換えることができる。
また、そうしたシステムでは、古い用法と標準の用法が衝突する場合には、
古い用法が優先される。そうした古い動作を有効にしたり、無効にしたりする
には、環境変数 `_POSIX2_VERSION' を使用すればよい (*note Standards
conformance::)。

   標準的なホストで使用するためのスクリプトでは、古い書式を使わずに、
`-c COUNT[b]', `-n COUNT' オプションや `-f' オプションの方を使うべきで
ある。そのスクリプトが、古い書式にしか対応していないホストでも動作しな
ければならない場合でも、問題を起こしかねない表現を避けるように書き直す
ことが、たいていはできるものだ。たとえば、`tail -1' の代わりに、 `sed
-n '$p'' を使うといった具合である。それさえ不可能な場合は、どちらの
書式を使うべきかを判断するために、`if tail -c +1 </dev/null >/dev/null
2>&1; then ...' といった条件文をスクリプトで使用すればよい。

   作成するスクリプトが標準的な動作を想定している場合でも、POSIX の
バージョンによって動作に違いのある用法には、気を付けた方がよい。
たとえば、`tail - main.c' は避けるべきである。`tail main.c' と解釈する
ことも、`tail -- - main.c' と解釈することもできるからだ。`tail -c 4'
も避けるべきである。`tail -c4' を意味するかもしれないし、`tail -c 10 4'
を意味するかもしれない。`tail +4' も使わない方がよい。`tail ./+4' の
意味にも、`tail -n +4' の意味にも取れるからである。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: split invocation,  Next: csplit invocation,  Prev: tail invocation,  Up: Output of parts of files

5.3 `split': ファイルを分割する。
===========================================

`split' は、INPUT を分割して複数のファイルを作成する。各出力ファイル
には、INPUT の断片が、連続した形で、もしくは 1 行づつ順番に分配された
形で含まれることになる (訳注: 前者は単純な分割であり、後者は後述の
「ラウンド・ロビン方式」である。`-n' オプションを参照)。INPUT が全く
指定されない場合や、`-' である場合には、標準入力から読み込む。

   書式:

     split [OPTION] [INPUT [PREFIX]]

   デフォルトでは、`split' は INPUT を 1000 行づつ各出力ファイルに
書き込む (最後の断片については、何行であれ残っている行を書き込む)。

   出力ファイルの名前は、上記書式の PREFIX (デフォルトでは `x') に複数
の文字 (デフォルトでは、`aa', `ab', ...) を続けたものであり、各出力
ファイルをファイル名による伝統的なソート順で結合すると、元の入力ファイル
が再構成されるようになっている (ただし、`-nr/N' オプションを指定した場合
は除く)。デフォルトでは、split はまず、作成するファイルに 2 文字からなる
接尾辞 (訳注: suffix、すなわち上記の `aa', `ab' など) を生成して付け、
その接尾辞の 1 番目の文字がアルファベットの最後に達した時点で、接尾辞を
2 文字づつ増やして行く (つまり、`yz', `zaaa', `zaab', ... と接尾辞を
付けていく)。こうした命名法を使えば、出力ファイルがいくつあっても対応
できるし、また `--additional-suffix' オプションを付けたときでも、出力
ファイルが上で述べたような順に並ぶことになるわけだ。`-a' オプション
が指定されている場合に、出力ファイルの名前が種切れになってしまうと、
`split' はエラーメッセージを出すが、作成した出力ファイルを消去する
ことはない。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-l LINES'
`--lines=LINES'
     INPUT から LINES 行づつ各出力ファイルに書き込む。

     互換性を考慮して、`split' は `-LINES' という古いオプションの書式も
     サポートしている。新規にスクリプトを書くなら、`-l LINES' の方を使う
     べきである。

`-b SIZE'
`--bytes=SIZE'
     INPUT から SIZE バイトづつ各出力ファイルに書き込む。 SIZE
     は整数であり、以下に挙げるような、何倍かを表す接尾辞を
     後ろに付けることもできる。
          `b'  =>            512 ("blocks")
          `KB' =>           1000 (KiloBytes)
          `K'  =>           1024 (KibiBytes)
          `MB' =>      1000*1000 (MegaBytes)
          `M'  =>      1024*1024 (MebiBytes)
          `GB' => 1000*1000*1000 (GigaBytes)
          `G'  => 1024*1024*1024 (GibiBytes)
     `T', `P', `E', `Z', `Y' についても同様。

`-C SIZE'
`--line-bytes=SIZE'
     各出力ファイルに、ファイルサイズが SIZE バイトを超過しない範囲で、
     INPUT の完全な行をできるだけ多く書き込む。1 行の長さが SIZE バイト
     を越える行は、複数のファイルに分割される。SIZE の書式は、`--bytes'
     オプションの場合と同じである。

`--filter=COMMAND'
     このオプションを使用すると、各出力は、そのままファイルに書き出さ
     れるのではなく、パイプを通して一つづつ、指定されたシェルの COMMAND
     に引き渡される。COMMAND では、環境変数 $FILE を使用するべきであり、
     この変数には、シェルコマンドを実行するごとに、異なる出力ファイル名
     が代入される。たとえば、1TiB の圧縮ファイルがあるとしよう。伸長
     したら、サイズが大きすぎて、ディスクに納まり切らない。しかし、
     それを分割して、もっと扱いやすいサイズの、それぞれ圧縮したファイル
     を作らねばならない。そうした課題を解決するには、次のようなコマンド
     を実行すればよいだろう。

          xz -dc BIG.xz | split -b200G --filter='xz > $FILE.xz' - big-

     圧縮率が 10:1 だとすると、上のコマンドは 20GiB のファイルを 50 個
     ほど生成するだろう。ファイルの名前は、`big-aa.xz', `big-ab.xz',
     `big-ac.xz' などになる。

`-n CHUNKS'
`--number=CHUNKS'
     INPUT を CHUNKS 個の出力ファイルに分割する。CHUNKS の部分には以下の
     ものが指定できる。

          N      INPUT の現在のサイズに基づいて N 個のファイルを生成する。
          K/N    N 個中の K 番目のみを標準出力へ出力する。
          l/N    N 個のファイルを生成する。行の途中で分割しない。
          l/K/N  同上。ただし、N 個中の K 番目のみを標準出力に出力する。
          r/N    `l' に似ている。ただし、行をラウンド・ロビン方式で分配する。
                 (訳注： トランプの親がカードを 1 枚づつ子に配るように、
                         入力から 1 行づつ各出力ファイルに分配して行く。)
          r/K/N  同上。ただし、N 個中の K 番目のみを標準出力に出力する。

     INPUT を  N 個の「部分 (chunk)」に分けたときに出た余りのバイトは、
     最後の「部分」に割り振られる。最初に行われる分割のための計算の後で
     追加されるバイトがあっても、それは捨て去られる (`r' モードを使用
     している場合を除く)。

     行数が N 行に足りなかったり、INPUT が短縮された場合でも、N 個の
     ファイルすべてが作成される。

     `l' モードについて言うと、「部分」の大きさは、「INPUT サイズ / N」
     前後になる。INPUT は、まず N 個の同一サイズの区画 (partition) に
     分割され、余りがあれば、それは最後の区画に割り当てられる。ある行の
     先頭が、ある区画の内側にある場合、その行は行末まで、その区画に対応
     するファイルに書き込まれる。行は、たとえ後続する区画にまではみ出して
     いても分割されないので、書き出されるファイルは、区画のサイズより
     大きくなることもあれば、小さくなることもある。行が後続する区画を
     すっぽり覆ってしまうほど長い場合には、空っぽのファイルができること
     さえある。

     `r' モードでは、INPUT のサイズは問題にならない。だから、入力は、
     たとえば、パイプからであっても構わない。

`-a LENGTH'
`--suffix-length=LENGTH'
     使用する接尾辞の長さを LENGTH 文字にする。LENGTH に 0 を指定する
     と、`-a' オプションを (すでに指定していた場合でも) 全く指定しな
     かったのと、同じことになり、従って、デフォルトの動作が有効になる。
     すなわち、接尾辞は、2 文字から始まり、`-n' や `--numeric-suffixes
     =FROM' オプションが指定されていないかぎり、必要になるごとに、2 文字
     づつ自動的に増えて行く。

`-d'
`--numeric-suffixes[=FROM]'
     接尾辞にアルファベットの小文字ではなく、数字を使用する。数字の接尾
     辞では、 FROM が指定されていれば FROM から、指定されていなければ 0
     から数を数えて行く。注意していただきたいが、FROM の値を指定すると、
     上で述べた接尾辞の長さを自動的に増やして行くデフォルトの機能まで無効
     になる。そこで、ユーザとしては、99 を越える数字を接尾辞として使える
     ようにするため、`-a' オプションも併せて指定したくなるかもしれない。

`--additional-suffix=SUFFIX'
     出力ファイル名の末尾に SUFFIX をさらに追加する。SUFFIX 中に
     スラッシュが含まれていてはならない。

`-e'
`--elide-empty-files'
     サイズ 0 の出力ファイルができないようにする。そうしたものが生成
     されることがあるのは、`--number' を使ったときである。入力ファイル
     が (短縮されて) 指定された数に分割するには分量が足りなくなって
     いる場合や、1 行が長すぎて、後続する「部分」をすっぽり飲み込んで
     いる場合などがそれに当たる。このオプションが指定されているときでも、
     出力ファイルの連続番号が、順番に増えていくことに変わりはない。

`-u'
`--unbuffered'
     `--number r/...' モードにおいて入力を即座に出力する。このモードは、
     作業にかなり時間がかかるのだ。

`--verbose'
     各出力ファイルをオープンする直前に、診断メッセージを表示する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   `--number' (`-n') の動作を説明するために、具体的な例をいくつか
挙げる。

   デフォルトでは、1 行が 2 行以上に分割されることがあるのに、注目して
いただきたい。

     $ seq -w 6 10 > k; split -n3 k; head xa?
     ==> xaa <==
     06
     07
     ==> xab <==

     08
     0
     ==> xac <==
     9
     10

   "l/" 修飾子を使用して、行の途中で分割しないようにする。

     $ seq -w 6 10 > k; split -nl/3 k; head xa?
     ==> xaa <==
     06
     07

     ==> xab <==
     08
     09

     ==> xac <==
     10

   "r/" 修飾子を使用して、ラウンド・ロビン方式で分配する。

     $ seq -w 6 10 > k; split -nr/3 k; head xa?
     ==> xaa <==
     06
     09

     ==> xab <==
     07
     10

     ==> xac <==
     08

   K 番目の「部分」だけ取り出すこともできる。次の例は、33 の「部分」に
分け、そのうちの  7 番目だけを取り出して、表示している。

     $ seq 100 > k; split -nl/7/33 k
     20
     21
     22


File: coreutils-ja.info,  Node: csplit invocation,  Prev: split invocation,  Up: Output of parts of files

5.4 `csplit': ファイルを内容を目印にして分割する。
====================================================================

`csplit' は、INPUT の断片からなる 0 個以上の出力ファイルを生成する。
INPUT が `-' である場合は、標準入力から読み込む。

   書式:

     csplit [OPTION]... INPUT PATTERN...

   出力ファイルの中身がどうなるかは、以下で詳しく述べるように、引数
PATTERN によって決まってくる。引数 PATTERN が、入力ファイル中に存在
しない行を指している場合は、エラーになる (たとえば、入力の残りの
部分に、指定された正規表現にマッチする行がもう存在しない場合)。
すべてのパターン・マッチが終わったとき、残っている入力があれば、
最後の出力ファイルに書き出される。

   デフォルトでは、`csplit' は、出力ファイルを生成した後で、各出力
ファイルに書き込んだバイト数を表示する。

   パターン引数 PATTERN には、以下のタイプがある。

`N'
     入力の最初から N 行目の直前までを含む (つまり、N-1 行目までの)
     出力ファイルを作成する (N は正の整数)。繰り返し回数の指定が後に
     続く場合は、繰り返しごとに、入力ファイルの次の N 行を含む出力
     ファイルを作成していく。

`/REGEXP/[OFFSET]'
     現在行から、入力ファイル中の次に REGEXP にマッチする行の直前までを
     内容とする (すなわち、マッチする行は含まない) 出力ファイルを作成
     する。整数の OFFSET を指定してもよい。指定した場合は、マッチする行
     にプラス/マイナス OFFSET した行の直前までの入力が (つまり、その行は
     含まない)、出力ファイルに書き込まれ、書き込まれた次の行から入力の
     後続部分が始まることになる。

`%REGEXP%[OFFSET]'
     上記のタイプと同様だが、出力ファイルを作成しない点が異なる。要するに、
     入力ファイルのその部分は捨てられることになるわけだ。

`{REPEAT-COUNT}'
     すぐ前で指定されているパターンをさらに REPEAT-COUNT 回繰り返す。
     REPEAT-COUNT には正の整数か、アステリスクを指定できる。後者は、
     入力がなくなるまで、必要なだけ何回でも繰り返すことを意味する。
     (訳注: `csplit INPUT '/PATTERN_1/' '{3}' '/PATTERN_2/' '{*}'' の
     ように使用する。)


   出力ファイルの名前は、接頭辞 (prefix、デフォルトでは `xx') に接尾辞
(suffix) を続けたものになる。デフォルトの接尾辞は、二桁の 10 進数を `00'
から `99' まで順番に増やして行ったものである。いかなる場合でも、出力
ファイルを、ファイルの名前によってソートした順番で結合すると、元の入力
ファイルが生成されるようになっている。

   デフォルトでは、`csplit' は、エラーになった場合や、ハングアップ、
割り込み、中止、終了といったシグナルを受け取った場合は、それまでに
作成した出力ファイルをすべて消去してから終了する。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-f PREFIX'
`--prefix=PREFIX'
     PREFIX を出力ファイル名の接頭辞として使用する。

`-b SUFFIX'
`--suffix=SUFFIX'
     SUFFIX を出力ファイル名の接尾辞として使用する。このオプションを
     指定する場合、接尾辞として指定する文字列には、`printf(3)' 方式の
     変換指定が必ず一つ (ただ一つだけ) 含まれていなければならない。
     形式指定フラグ、フィールド幅、精度指定といった類の、どんな修飾子
     を付けてもよい。フォーマット文字は、バイナリの符号なし整数である
     引数を、人間に読みやすい形式に変換するものでなければならない。
     フォーマット文字の `d' と `i' は、`u' の別名であり、`u', `o', `x',
     `X' 変換が可能である。SUFFIX の全体が (現在の出力ファイルが何番目か
     という情報とともに) `sprintf(3)' 関数に引き渡され、出力ファイルの
     一つ一つに対して、ファイル名に使う接尾辞が順番に作られることになる。
     なお、このオプションを使用すると、`--digits' オプションは無視
     される。

`-n DIGITS'
`--digits=DIGITS'
     出力ファイル名に含まれる数字の桁数を、デフォルトの 2 から DIGITS
     にする。

`-k'
`--keep-files'
     エラーが起きても、出力ファイルを消去しない。

`-z'
`--elide-empty-files'
     サイズ 0 の出力ファイルができないようにする (入力ファイルを各部分
     に区切る行が、どの部分においても最初の行になることを期待している
     場合に、このオプションを使わないと、一番目の出力ファイルがたいてい
     サイズ 0 になる)。このオプションが指定されているときでも、出力
     ファイルの連続番号が 0 から始まって、順番に増えていくことに変わり
     はない。

`-s'
`-q'
`--silent'
`--quiet'
     出力ファイルのサイズを表示しない。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例を挙げてみよう。まず、練習用に空のディレクトリを作って、そこに
移動する。

     $ mkdir d && cd d

   次に、1 から 14 まで連続する数を、0 または 5 で終わる行で分割する。

     $ seq 14 | csplit - '/[05]$/' '{*}'
     8
     10
     15

   ここで表示された各数字は、csplit が今作成した出力ファイルのサイズ
である。その出力ファイルの名前をリストする。

     $ ls
     xx00  xx01  xx02

   `head' を使って、内容を見る。

     $ head xx*
     ==> xx00 <==
     1
     2
     3
     4

     ==> xx01 <==
     5
     6
     7
     8
     9

     ==> xx02 <==
     10
     11
     12
     13
     14


File: coreutils-ja.info,  Node: Summarizing files,  Next: Operating on sorted files,  Prev: Output of parts of files,  Up: Top

6 ファイルの要約 (行数、単語数、チェックサム)
*****************************************************************

以下のコマンドは、ファイル内容全体を表現する若干の数字を生成する。

* Menu:

* wc invocation::            行数、単語数、バイト数を表示する。
* sum invocation::           チェックサムとブロック数を表示する。
* cksum invocation::         CRC チェックサムとバイト数を表示する。
* md5sum invocation::        MD5 ダイジェストの表示、または検査をする。
* sha1sum invocation::       SHA-1 ダイジェストの表示、または検査をする。
* sha2 utilities::           SHA-2 ダイジェストの表示、または検査をする。


File: coreutils-ja.info,  Node: wc invocation,  Next: sum invocation,  Up: Summarizing files

6.1 `wc': 行数、単語数、バイト数を表示する
==========================================================

`wc' は、指定された各 FILE に含まれる、バイト数、文字数、ホワイト
スペース (訳注: 空白、タブ、改行など) で区切られた単語数、改行数を算出
する。FILE が指定されなかった場合や、FILE として `-' が指定された
場合は、標準入力を対象とする。

   書式:

     wc [OPTION]... [FILE]...

   `wc' は各ファイルにつき、一行の算出結果を出力する。引数として
ファイルが指定されていれば、そのファイル名を数値の後ろに表示する。
複数の FILE が指定されている場合は、最後の行で合計を表示し、ファイル
名の部分に、`total' と書き込む。表示される数値の順番は、改行数、単語数、
文字数、バイト数、最長行の長さになる。各数値は、フィールドに右詰めで
表示され、フィールド間には、少なくとも一個の空白が置かれる。そうする
ことで、複数の数字とファイル名が、たいていの場合きちんと整列するように
なっているのだ。数値の入るフィールドの幅は、入力に応じて変化するので、
一定のフィールド幅を当てにするべきではない。ただし、GNU の拡張として、
表示される数値がただ 1 個だけの場合は、その数値の頭に空白を入れない
ことになっている。

   デフォルトでは、`wc' は 3 個の数値を表示する。すなわち、改行数、単語
数、バイト数である。オプションによって、特定の数値のみを表示するように
指定することもできる。どんなオプションも、それ以前に指定されたオプション
を取り消すことはない。従って、

     wc --bytes --words

上記のコマンドは、バイト数と単語数の両方を表示することになる。

   `--max-line-length' を指定すると、`wc' はファイルごとの最長行の
長さを表示する。さらに、複数のファイルが存在する場合は、(各最長行の
合計ではなく) 最長行中の最長のものを表示する。ここで言う行の長さは、
画面に表示される桁数のことである。表示桁数の計算は現在のロケールに
従って行われ、タブ位置は 8 桁ごとに来るものとされる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--bytes'
     バイト数のみを表示する。

`-m'
`--chars'
     文字数のみを表示する。

`-w'
`--words'
     単語数のみを表示する。

`-l'
`--lines'
     改行数のみを表示する。

`-L'
`--max-line-length'
     最長行の長さのみを表示する。

`--files0-from=FILE'
     コマンドラインで名前を指定されたファイルの処理を行わない。その代わり
     に、ファイル FILE に名前が書き込まれているファイルの処理を行う。
     なお、FILE 中に書かれている各ファイル名は、ゼロバイト (ASCII NUL)
     で終端されていなければならない。このオプションは、ファイル名のリスト
     が長すぎて、コマンドライン長の上限を超過してしまいそうなときに、
     便利である。そうした場合、`wc' を `xargs' 経由で実行するのは、
     望ましくない。なぜなら、`xargs' はファイルのリストをいくつかの部分
     に分割して `wc' に渡すので、`wc' はリスト全体の合計ではなく、
     部分リストごとの合計を表示してしまうからである。 ASCII NUL
     で終端されたファイル名のリストを得る方法の一つは、 GNU `find' に
     `-print0' を付けて使うことである。FILE に `-' を指定すれば、 ASCII
     NUL で終端されたファイル名が標準入力から読み込まれる。

     たとえば、カレント・ディレクトリ以下にある、すべての `.c' ファイル
     や `.h' ファイルの内で、最長の行の長さを知るには、次のようにする。

          find . -name '*.[ch]' -print0 |
            wc -L --files0-from=- | tail -n1


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: sum invocation,  Next: cksum invocation,  Prev: wc invocation,  Up: Summarizing files

6.2 `sum': チェックサムとブロック数を表示する
==============================================================

`sum' は、指定された各 FILE の 16-bit チェックサムを計算する。 FILE
が指定されなかった場合や、FILE として `-' が指定された場合は、
標準入力を対象とする。

   書式:

     sum [OPTION]... [FILE]...

   `sum' は各 FILE のチェックサムを表示し、その後にファイルのブロック数
(整数に切り上げたもの) を続ける。複数の FILE が指定されていると、
ファイル名も表示される (デフォルト)。(`--sysv' オプションが指定されて
いる場合は、引数に一つでもファイルがあれば、そのファイル名が表示される。)

   デフォルトでは、GNU の `sum' は、BSD の `sum' と互換性のある
アルゴリズムを使って、チェックサムを計算し、1 ブロック 1024 バイトの
ブロック数でファイルサイズを表示する。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-r'
     デフォルトの (BSD と互換性のある) アルゴリズムを使用する。この
     オプションが存在しているのは、System V の `sum' との互換性のため
     である。前方に `-s' オプションも指定されているとき以外、このオプ
     ションは効果を持たない。

`-s'
`--sysv'
     System V の `sum' のデフォルトと互換性のあるアルゴリズムを使って、
     チェックサムを計算し、1 ブロック 512 バイトのブロック数でファイル
     サイズを表示する。


   `sum' は、互換性のために提供されている。新しいアプリケーションでは、
`cksum' プログラム (次のセクションを参照) を使う方がよい。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: cksum invocation,  Next: md5sum invocation,  Prev: sum invocation,  Up: Summarizing files

6.3 `cksum': CRC チェックサムとバイト数を表示する
=================================================================

`cksum' は、指定された各 FILE の CRC (cyclic redundancy check、巡回
冗長検査) チェックサムを計算する。FILE が指定されなかった場合や、 FILE
として `-' が指定された場合は、標準入力を対象とする。

   書式:

     cksum [OPTION]... [FILE]...

   `cksum' は、各ファイルの CRC チェックサムとバイト数を表示する。また、
引数が指定されていない場合を除いて、ファイル名も表示する。

   `cksum' は通常、信頼性の低い方法 (たとえば、netnews) によって転送
されたファイルに損傷がないことを確認するために使用される。受信した
ファイルに対する `cksum' の出力を、元のファイルに対する `cksum' の出力
(たいてい、配布物中に入っている) と比較するわけである。

   CRC のアルゴリズムは、POSIX 規格によって規定されており、BSD や
System V の `sum' のアルゴリズム (直前のセクションを参照) と互換性が
ない。CRC アルゴリズムの方が信頼性が高い。

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: md5sum invocation,  Next: sha1sum invocation,  Prev: cksum invocation,  Up: Summarizing files

6.4 `md5sum': MD5 ダイジェストの表示、または検査をする
========================================================================

`md5sum' は、指定された各 FILE の 128-bit チェックサムを計算する。
チェックサムは、指紋 ("fingerprint") とか、メッセージ・ダイジェスト
("message-digest") とも呼ばれる (訳注: ハッシュ値と呼ばれることもある)。

   注意: MD5 ダイジェストは、ファイルの不測の損傷を検知することに
関して、単純な CRC (`cksum' コマンドで使用できる) よりも信頼性が高い。
二つのファイルがたまたま同一の MD5 値を持っている確率は、ほとんどゼロ
だからである。だからと言って、悪意のある改竄に対して安全だと考えては
ならない。ある特定の MD5 指紋を持つファイルを見つけ出すことは、現在の
ところ事実上不可能だと考えられているが、デジタル証明書などのファイルが
署名に MD5 ダイジェストを使用しているとき、そうしたファイルに手を
加えて、正当に見えるようする方法なら、周知のことだからである。もっと
安全なハッシュ値が必要なら、SHA-2 の使用を考慮した方がよい。 *Note sha2
utilities::.

   指定された FILE が `-' の場合や、ファイルが全く指定されなかった
場合は、`md5sum' は標準入力のチェックサムを計算する。また、`md5sum' は、
ファイルとチェックサムの間に矛盾がないかどうかを判定することもできる。

   書式:

     md5sum [OPTION]... [FILE]...

   各 FILE に対して `md5sum' は、MD5 チェックサム、入力モードがバイ
ナリかテキストかを示すフラグ、それにファイル名を出力する。FILE に
バックスラッシュや改行文字が含まれている場合は、出力する行の先頭に
バックスラッシュを付け、さらに、ファイル名中の問題のある各文字を
バックスラッシュでエスケープする。そうすることで、わがままなファイル
名があっても、出力に誤解の余地がないようにしているわけだ。FILE が
指定されていなかったり、`-' という形で指定されている場合は、標準入力
から読み込む。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--binary'
     各入力ファイルをバイナリとして扱う。すなわち、入力ファイルをバイナリ
     モードで読み込み、出力に `*' というフラグを付ける。このオプションは
     `--text' の反対である。バイナリファイルとテキストファイルを区別しな
     い GNU のようなシステムでは、このオプションは入力モードがバイナリ
     であるとのフラグを付けるだけであり、MD5 チェックサムの値には影響を
     及ぼさない。このオプションは、バイナリファイルとテキストファイルを
     区別する MS-DOS のようなシステムでは、デフォルトである。だだし、
     読み込みを標準入力から行い、その標準入力が端末であるときは除く。

`-c'
`--check'
     各 FILE から (FILE が指定されなかった場合は、標準入力から)、ファ
     イル名とチェックサム情報を読み込み (FILE をチェックサム計算の対象と
     なるデータとして読み込むわけはない)、そのチェックサム情報が、名前を
     挙げられているファイルの内容に対応しているかどうかを報告する。この
     モードの `md5sum' に対する入力は、たいていの場合、事前に `md5sum'
     を実行してチェックサムを作成したときの出力である。入力の有効な行は
     それぞれ、MD5 チェックサム、バイナリかテキストかのフラグ、ファイル
     名の順になっている。バイナリモードには `*' の指標が付き、テキスト
     モードには、` ' (空白) の指標が付く。そうした各行に対して、`md5sum'
     は、そこに名前を挙げられたファイルを読み込み、その MD5 チェックサム
     を計算する。そして、算出したメッセージダイジェストが、そのファイル名
     と同じ行にあるチェックサムと一致しない場合は、そのファイルがテストに
     失敗したことを通告するのである。両者が一致した場合は、テストにパス
     したことになる。デフォルトでは、有効な各行に対して標準出力にメッ
     セージを 1 行づつ書き出し、指名されたファイルがテストにパスしたか
     どうかを明かにする。また、すべてのチェックが完了したとき、テストに
     失敗したものが一つでもあれば、警告メッセージを標準エラーに出力する。
     この出力を抑制したければ、`--status' オプションを使用すればよい。
     リストされたファイルの中に、オープンできなかったり、読み込めなかっ
     たりするものがあった場合や、有効な行に書いてあるチェックサムが対応
     するファイルの実際の値と一致しなかった場合、それに、有効な行が全く
     存在しなかった場合は、`md5sum' は 0 以外のステータスで終了する。
     それ以外の場合は正常終了することになる。

`--quiet'
     このオプションが役に立つのは、チェックサムを照合するときだけである。
     このオプションを指定すると、チェックサムを照合する際、検査に成功した
     ファイル一つ一つに 'OK' (訳注: 日本語では「成功」) のメッセージを
     出さなくなる。ただし、ファイルが照合に失敗した場合は、デフォルトと
     同じ 1 ファイル 1 行の形式で結果を報告する。チェックサムの不一致が
     あった場合は、失敗を総括した警告メッセージも標準出力に表示する。

`--status'
     このオプションが役に立つのは、チェックサムを照合するときだけである。
     このオプションを指定すると、チェックサムを照合する際、デフォルトの
     1 ファイルに付き 1 行の判定メッセージを出さなくなる。また、照合の
     失敗があっても、それを総括した警告メッセージを出力することがない。
     とは言え、ファイルのオープンや読み込みに失敗した場合は、やはり
     それぞれの診断結果を標準エラーに表示する。リストされたすべての
     ファイルを読み込むことができ、しかも、すべてのファイルについて、
     対応する MD5 チェックサムと矛盾がなければ、正常終了する。それ以外
     の場合は、失敗があったことを示すステータスコードで終了する。

`--tag'
     BSD スタイルのチェックサムを出力する。つまり、使用したチェックサム
     のアルゴリズムも表示するということだ。GNU の拡張として、問題を起こ
     しかねない文字を含むファイル名は、上述したようにエスケープされ、
     さらに、行の先頭に エスケープの指標に使われたのと同じ `\' 文字が
     付けられる。`--tag' オプションはバイナリ・モードを意味し、`--text'
     オプションと一緒に使うことは認められていない。そんなことをサポート
     しても、出力の書式をむやみに複雑にするだけで、利益はほとんどない
     からである。

`-t'
`--text'
     各入力ファイルをテキストとして扱う。すなわち、入力ファイルをテキスト
     モードで読み込み、出力に ` ' というフラグを付ける。このオプションは
     `--binary' の反対である。バイナリファイルとテクストファイルを区別
     しない GNU のようなシステムでは、このオプションはデフォルトである。
     ほかのシステムでも、読み込みを標準入力から行い、その標準入力が端末で
     あるときは、デフォルトになる。ただし、`--tag' が使用されているとき
     に、このモードがデフォルトになることはない。

`-w'
`--warn'
     チェックサムを照合する際、MD5 チェックサムを記載した行の書式が
     正しくないと、警告を発する。このオプションが役に立つのは、チェック
     される入力中の、数行を除いたすべての行が、有効なときだけである。

`--strict'
     チェックサムを照合する際、無効な入力行が 1 行でもあれば、そうした
     行のすべてについて警告を発したのち、0 以外の終了ステータスで終了
     する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: sha1sum invocation,  Next: sha2 utilities,  Prev: md5sum invocation,  Up: Summarizing files

6.5 `sha1sum': SHA-1 ダイジェストの表示、または検査をする
===========================================================================

`sha1sum' は、指定された各 FILE の 160-bit チェックサムを計算する。
このコマンドの使用法やオプションは、`md5sum' と全く同じである。 *Note
md5sum invocation::.

   注意: SHA-1 ダイジェストは MD5 より安全であり、コリジョン
(collision、衝突。別のファイルが同一の指紋を持つこと) が起きたという
話を聞いたことはない。しかしながら、大量の -- と言っても非現実的な
ほどではない -- リソースがあれば、コリジョンを作り出せることがわかって
いる。この理由から、SHA-1 は、もっと安全な SHA-2 ハッシュ・アルゴリズム
に徐々に移行すべきだと、一般に考えられている。 *Note sha2 utilities::.


File: coreutils-ja.info,  Node: sha2 utilities,  Prev: sha1sum invocation,  Up: Summarizing files

6.6 sha2 utilities: SHA-2 ダイジェストの表示、または検査をする
================================================================================

コマンド `sha224sum', `sha256sum', `sha384sum', `sha512sum' は、一まとめ
にして SHA-2 ハッシュと呼ばれる様々な長さのチェックサムを計算する
(それぞれ、224, 256, 384, 512 bits である)。こうしたコマンドの使用法
とオプションは、`md5sum' と全く同じである。*Note md5sum invocation::.

   注意: SHA384 と SHA512 のダイジェストは、SHA224 や SHA256 に比べて、
計算にかなり時間がかかる。32 ビットのコンピュータではなおさらである。


File: coreutils-ja.info,  Node: Operating on sorted files,  Next: Operating on fields,  Prev: Summarizing files,  Up: Top

7 ソートしたファイルの操作
**************************************

以下のコマンドは、ソートしたファイルを操作 (生成) する。

* Menu:

* sort invocation::          テキストファイルを並べ替える。
* shuf invocation::          テキストファイルをシャッフルする。
* uniq invocation::          ファイルから重複を省く。
* comm invocation::          ソート済みの二つのファイルを一行づつ比較する。
* ptx invocation::           Produce a permuted index of file contents.
* tsort invocation::         Topological sort.


File: coreutils-ja.info,  Node: sort invocation,  Next: shuf invocation,  Up: Operating on sorted files

7.1 `sort': テキストファイルを並べ替える
======================================================

`sort' は、指定されたファイルから読み込んだすべての行に対して、ソート
(sort、一定の基準に従った並べ替え)、マージ (merge、統合)、比較を行う。
ファイルが一つも指定されなかった場合や、FILE として `-' が指定された
場合は、標準入力から読み込む。デフォルトでは、`sort' は結果を標準出力
に書き出す。

   書式:

     sort [OPTION]... [FILE]...

   `sort' には三つの動作モードがある。ソート (これがデフォルト)、
マージ、それに、すでにソートされているかどうかのチェックである。
動作モードの変更には、以下のオプションを使用する。

`-c'
`--check'
`--check=diagnose-first'
     指定されたファイルがすでにソートされているかどうかをチェックする。
     ファイル全体がソート済みでない場合は、診断メッセージを出し、順番
     から外れている最初の箇所を示してから、ステータス 1 で終了する。
     ファイルがソート済みの場合は、正常終了する。入力ファイルは、1 個
     しか指定できない。

`-C'
`--check=quiet'
`--check=silent'
     指定されたファイルがすでにソート済みだったら、正常終了する。
     さもなければ、ステータス 1 で終了。入力ファイルは、1 個しか指定
     できない。このオプションは `-c' と同様だが、診断メッセージを
     出さない点が異なる。

`-m'
`--merge'
     指定された複数のファイルを、一つのグループとしてソートすることで
     統合を行う。各入力ファイルは、必ずそれぞれがソート済みでなければ
     ならない。マージモードの代わりにソートモードを使えば、そうした条件
     なしで、ソートとマージを行うことができる。マージモードがあるのは、
     それが使える場合は、その方が高速だからである。


   二つの行の比較は、次のように行われる。`sort' は、対になる各フィールド
を、コマンドラインで指定された順番で、そのフィールドに結びついた順序関係
のオプションに従いつつ比較し、相違が見つかるか、比較するフィールドが
なくなるまでそれを続ける。キーとなるフィールドが指定されていない場合に
比較に使用されるのは、デフォルトのキーである行全体である。最後に、すべて
のキーが同じだったときは、最後の手段として、`--reverse' (`-r') 以外の
順序関係のどんなオプションも指定されていないかのように、行全体を比較
する。`--stable' オプションを指定すると、この最後の手段の比較
("last-resort comparison") を行わないようになり、その結果、すべての
キー・フィールドが等価である行は、互いに対する元の順序がそのまま維持
される。`--unique' (`-u') オプションも、最後の手段の比較を無効にする。

   別の指定がなされていないかぎり、すべての比較は、`LC_COLLATE' の
ロケールによって指定されている、文字の照合順序で行われる。 (1)

   GNU の `sort' は (GNU のすべてのユーティリティについて規定されている
とおり)、入力行の長さに上限がない。言い換えれば、各行に入れられるバイト
数に制限がない。また、入力ファイルの最後のバイトが改行でなければ、GNU の
`sort' は黙って改行を追加する。なお、行末の改行は、比較に当たっては、
行の一部として扱わない。

   終了ステータス:

     0: エラーが起きなかった
     1: `-c' や `-C' を付けて実行した際に、入力がソートされていなかった
     2: エラーが起きた

   環境変数 `TMPDIR' が設定されていれば、`sort' はその値をテンポラリ・
ファイルを置くディレクトリとして `/tmp' の代わりに使用する。
`--temporary-directory' (`-T') オプションは、環境変数よりさらに優先さ
れる。

   以下に挙げるオプションは、出力する行の順序に影響を与える。こうした
オプションは、グローバルなオプションとして指定することもできるし、キー
となる特定のフィールドに対してのみ働くように指定することもできる。キー
となるフィールドが全く指定されていない場合は、グローバルなオプションが
行全体の比較に使用される。キー・フィールドの指定がある場合は、グローバル
なオプションは、キー・フィールドのうち、それ自身のオプションが特に指定
されていないフィールドに継承される。POSIX 以前の `sort' のバージョンを
使用している場合、グローバルなオプションが効果を持つのは、それより後で
指定されるキー・フィールドに対してだけなので、移植を考慮したシェルスク
リプトでは、グローバル・オプションを最初に指定した方がよい。

`-b'
`--ignore-leading-blanks'
     各行中でソートに使うキーを捜すときに、文字の前にある空白を無視する。
     デフォルトの空白は、スペースまたはタブだが、`LC_CTYPE' のロケールに
     よっては違うかもしれない。なお、次のことに留意してほしい。空白は、
     使用しているロケールの照合ルールによっては無視されることがあるが、
     このオプションを指定しておかないと、`-k' オプションで指定される
     キー中の文字の位置に関して、空白が意味を持つことになる。

`-d'
`--dictionary-order'
     電話帳 ("phone directory") 順にソートする。ソートする際、表示可能
     文字、数字、空白以外のすべての文字を無視する。デフォルトの表示可能
     文字と数字は ASCII のそれであり、空白はスペースまたはタブだが、その
     あたりは `LC_CTYPE' のロケールによって違うかもしれない。

`-f'
`--ignore-case'
     アルファベットの小文字を、一回すべて対応する大文字に直してから、
     比較する。その結果、たとえば、`b' と `B' は等価なものとしてソート
     される。どの文字がどのタイプに属するか (訳注: たとえば、大文字か
     小文字か) を決めているのは、`LC_CTYPE' のロケールである。`--unique'
     オプションと一緒に使用したとき、小文字を使っている等価な行があると、
     その小文字の行は捨てられることになる。(大文字を使っている等価な行の
     方を捨てる方法は、現在のところ存在しない。(`--reverse' オプションが
     あっても、それが効果を発揮するのは、小文字の行が捨てられた後の最終
     結果に対してだけなのだ。)) (訳注: 実際の動作はこの説明と少し違う。
     最近の `sort' では、`--unique' と併せて使用した場合、小文字を
     使っている行が捨てられるのではなく、等価な行のうち、最初に現れた
     行が残り、それ以外のすべてが捨てられるようである。)

`-g'
`--general-numeric-sort'
`--sort=general-numeric'
     各行の先頭部分を倍精度浮動小数点数 (long double-precision floating
     point number) に変換して、数値としてソートする。 *Note Floating
     point::.  オーバーフロー、アンダーフロー、変換エラーが起きても、
     通知しない。行の並ぶ順番は以下のようになる。

        * 数字で始まっていない行 (すべて同じ数値と見なされる)。

        * NaNs (IEEE の浮動小数点演算で使う "Not a Number" を表す値) を
          一貫した、ただし、マシンに依存する順番で並べる。

        * マイナスの無限大。

        * 有限数を数値として昇順で並べる (-0 と +0 は等価とする)。

        * プラスの無限大。

     このオプションを使うのは、他に方法がないときのみにすること。
     処理速度が `--numeric-sort' (`-n') よりずっと遅いし、浮動小数点数に
     変換するとき、情報を失う恐れがある。

`-h'
`--human-numeric-sort'
`--sort=human-numeric'
     数値としてソートする。その際、ソートを、まず数が正か負かによって
     行い (負の数、ゼロ、正の数の順)、次に SI 接尾辞 によって行い
     (接尾辞なし、`k' や `K'、そして `MGTPEZY' の順  *note Block
     size::)、 最後に数値によって行う。たとえば、`1023M' は `1G' の
     前に来る。SI 接尾辞として `M'(メガ) は `G' (ギガ) の前になるから
     だ。つまり、このオプションでソートする対象は、接尾辞の意味が 1000
     の累乗か、1024 の累乗かを問わず、一貫したやり方で、数値の規模に
     もっともふさわしい接尾辞を付けられている数値である。従って、この
     オプションは、`df', `du', `ls' などのコマンドに `--human-readable'
     や `--si' オプションを付けて実行したときの、一回分の出力をソート
     するのに用いられる。数値の書式は、`--numeric-sort' の場合と同じ
     である (訳注: すなわち、数値の前に付けた `+' 符号を理解しない)。
     SI 接尾辞は、数値の直後に置かなければならない。

`-i'
`--ignore-nonprinting'
     表示できない文字を無視する。どの文字がどのタイプに属するかを決めて
     いるのは、 `LC_CTYPE' のロケールである。より強力なオプションである
     `--dictionary-order' (`-d') が一緒に指定されていると、このオプ
     ションは効果を持たない。

`-M'
`--month-sort'
`--sort=month'
     比較する部分の先頭が、0 個以上の空白に続いて、月名の短縮形になって
     いるとき、すべての文字を大文字に直して `JAN' < `FEB' < ... < `DEC'
     の順序で比較する。月名として無効な名前は、有効な月名より前に置かれる。
     月名のつづりを決めているのは、`LC_TIME' カテゴリのロケールである
     (訳注: だから、英語の月名によってソートするには、ロケールを英語か
     C にしておく必要がある)。デフォルトの空白は、スペースまたはタブ
     だが、`LC_CTYPE' のロケールによっては違うかもしれない。

`-n'
`--numeric-sort'
`--sort=numeric'
     数値としてソートする。数値は行頭から始まり (訳注: 比較する位置が
     指定されていれば、実は行頭でなくてもよい)、任意個の空白、必要なら
     `-' 符号、それに、0 個以上の数字から構成される。数値は、区切り
     記号で 3 桁づつ区切られていてもよく、小数点記号と 0 個以上の数字
     が続いていてもよい。数字がない場合は、`0' と見なされる。小数点記号
     や桁区切りの記号を規定しているのは、`LC_NUMERIC' のロケールである。
     デフォルトの空白は、スペースまたはタブだが、`LC_CTYPE' のロケール
     によっては違うかもしれない。

     比較は厳密であり、丸めによるエラーはない。

     このオプションは、数値の前に付けた `+' 符号や指数表記を理解しない。
     そうした文字列を数値として比較するには、`--general-numeric-sort'
     (`-g') を使用するべきである。

`-V'
`--version-sort'
     バージョン名とバージョン番号によってソートする。標準用法のソートと
     動作が似ているが、10 進数の数字が連続する各部分をインデックス番号や
     バージョン番号と見なして、数値として取り扱う点が違う。(*Note
     Details about version sort::.)

`-r'
`--reverse'
     比較の結果を逆順にする。その結果、出力ではより大きなキーの値を
     持つ行が、後ではなく、先に表示される。

`-R'
`--random-sort'
`--sort=random'
     ソートを行うのに、入力中のキーをハッシュしてから、そのハッシュ値
     をソートするという方法を用いる。ハッシュ関数はランダムに選択する。
     その際、衝突 (collision) が絶対起きないように関数を選択するので、
     値の違うキーは必ず違うハッシュ値を持つようになる。これは、入力の
     ランダムな並び替えに似ているが (*note shuf invocation::)、同じ値を
     持つキーは一緒に並べるという点が、異なっている。

     ランダムソートを行うフィールドが複数指定されている場合は、ランダムに
     選択された一つの同じハッシュ関数が、すべてのフィールドで使用される。
     フィールドごとに別のランダムなハッシュ関数を使うようにするには、
     `sort' を複数回呼び出せばよい。

     ハッシュ関数の選択は、 `--random-source' オプションの影響を受ける。


   その他のオプション。

`--compress-program=PROG'
     テンポラリ・ファイルを PROG というプログラムで圧縮する。

     PROG プログラムは、引数を一つも指定しない場合に、標準入力を圧縮
     して、標準出力に書き出すものでなければならない。またそのとき、`-d'
     オプションの指定があれば、標準入力を展開して、標準出力に書き出す
     ものでなければならない。

     PROG が 0 以外のステータスで終了した場合は、エラーメッセージを
     出して、`sort' の実行を中止する。

     PROG の指定中でホワイト・スペース (訳注: 空白、タブ、改行など) や
     バックスラッシュ文字を使ってはならない。そうした文字は、将来の
     使用のために、予約されている。

`--files0-from=FILE'
     コマンドラインで名前を指定されたファイルの処理を行わない。その代わり
     に、ファイル FILE に名前が書き込まれているファイルの処理を行う。
     なお、FILE 中に書かれている各ファイル名は、ゼロバイト (ASCII NUL)
     で終端されていなければならない。このオプションは、ファイル名のリスト
     が長すぎて、コマンドライン長の上限を超過してしまいそうなときに、
     便利である。そうした場合、`sort' を `xargs' 経由で実行するのは、
     望ましくない。なぜなら、`xargs' はファイルのリストをいくつかの部分
     に分割して `sort' に渡すので、`sort'
     はリスト全体のソートした結果ではなく、
     部分リストごとのソートした結果を表示してしまうからである。 ASCII
     NUL で終端されたファイル名のリストを得る方法の一つは、 GNU `find'
     に `-print0' を付けて使うことである。FILE に `-' を指定すれば、
     ASCII NUL で終端されたファイル名が標準入力から読み込まれる。

`-k POS1[,POS2]'
`--key=POS1[,POS2]'
     行中の POS1 から POS2 までの部分 (両者を含む) を、ソートの対象
     となる場所として指定する。POS2 が省略されている場合は、POS1 から
     行末までがソートの対象になる。

     各 POS は、`F[.C][OPTS]' という形式を取る。F は、比較に使用する
     フィールドは何番目かということであり、C は、そのフィールドの始め
     から数えて何番目の文字かということである。フィールドや文字の位置は、
     1 から数える。なお、POS2 の文字の位置として 0 を指定すると、その
     フィールドの最後の文字を指すことになる。`.C' が、POS1 で省略されて
     いる場合は、デフォルトの 1 (フィールドの最初の文字) を指定したこと
     になり、POS2 で省略されている場合は、デフォルトの 0 (フィールドの
     最後の文字) を指定したことになる。OPTS は順序関連のオプションで
     あり、これを指定することで、各キーを異なったルールでソートすること
     が可能になる。詳細については後述しているので、参照していただきたい。
     なお、キーは複数のフィールドにまたがることができる。

     たとえば、二番目のフィールドでソートするには、`--key=2,2' (`-k
     2,2') を使用する。後述部分で、キーについてさらに説明し、用例も
     もっとたくさん挙げているので、ご覧になっていただきたい。また、
     `--debug' オプションの説明もご覧になるとよい。`--debug' オプション
     を使うと、行中のどの部分がソートに使用されているかが明らかになる。

`--debug'
     各行のソートに使われている部分を強調表示する。また、使用法に問題が
     あるときは、標準エラーに警告メッセージを出す。

`--batch-size=NMERGE'
     一度にマージする入力ファイルの数を多くても NMERGE 個までとする。

     NMERGE 個を越える入力ファイルをマージしなければならない場合、`sort'
     は NMERGE 個のファイルからなるグループを作ってマージし、その結果を
     テンポラリ・ファイルに保存する。そして、今度はそれを入力として使用
     して、後に続くマージを行うのである。

     NMERGE の値が大きいと、実行速度が向上し、ハードディスクの一時的な
     使用が減るかもしれないが、その分、メモリの使用量と I/O が増加する。
     逆に、NMERGE の値が小さいと、メモリに対する要求と I/O は減少する
     かもしれないが、その分、ハードディスクの一時的な使用が増え、実行速度
     が低下することになる。

     NMERGE の値は、2 以上でなければならない。デフォルトの値は 16 だが、
     これは実装次第なので、将来は変わるかもしれない。

     NMERGE の値は、オープンできるファイル・ディスクリプタの上限によって
     制限されているかもしれない。`ulimit -n' や `getconf OPEN_MAX'
     コマンドを使えば、使用しているシステムの上限を知ることができる。
     ただし、そうした上限がさらに小さくなっていることもあり、使用中の
     プログラムがすでにファイルをいくつかオープンしている場合や、オープン
     できるファイルの数についてオペレーティング・システムに他の制限がある
     場合が、それに当たる。NMERGE がリソースの上限を越えているときは、
     `sort' は警告メッセージを出さずに、より小さい値を使用する。

`-o OUTPUT-FILE'
`--output=OUTPUT-FILE'
     出力を標準出力ではなく、OUTPUT-FILE に書き出す。通常、`sort' は、
     入力をすべて読み込んでから、OUTPUT-FILE をオープンする。従って、
     `sort -o F F' や "`cat F | sort -o F' といったコマンドを使って、
     ファイルを直接書き変えるやり方で、ソートをしても問題がない。
     これに対して、`--merge' (`-m') オプションを指定した場合は、 `sort'
     は、入力をすべて読み込む前に、出力ファイルをオープンするかも
     しれない。そのため、`cat F | sort -m -o F - G' といったコマンドは
     安全ではない。`cat' が `F' の読み込みを済ます前に、 `sort' が `F'
     への書き込みを始めてしまうかもしれないからだ。

     比較的新しいシステムでも、環境変数 `POSIXLY_CORRECT' を設定して
     いる場合は、たとえば `sort F -o F' のように、入力ファイルの後に
     `-o' オプションを置くことはできない。移植を考慮したスクリプトでは、
     `-o OUTPUT-FILE' を入力ファイルの前で指定するべきである。

`--random-source=FILE'
     FILE をランダムデータのソースとして使用する。そのランダムデータは、
     `-R' オプションでどのランダムハッシュ関数を使うかを決定するのに
     使用される。 *Note Random sources::.

`-s'
`--stable'
     最後の手段の比較 (last-resort comparison) を行うのを止めて、`sort'
     を入力順尊重 (stable) にする。このオプションは、フィールド指定オプ
     ションや、`--reverse' (`-r') 以外のグローバルな順序関係のオプション
     が指定されていなければ、効果を持たない。(訳注: いわゆる安定ソート
     (stable sort) である。たとえば、`-b' オプションを使って、先行する
     空白を無視して比較した場合に、等価となる行があったとしよう。通常では、
     それでも、最後の手段の比較によって、先行する空白の有無も考慮に入れた
     行全体の比較が行われ、等価な行に順序を付けることになるが、`--stable'
     オプションが指定されていると、それをしないので、等価な行は入力された
     ときの順序で出力される)。

`-S SIZE'
`--buffer-size=SIZE'
     指定された SIZE のメインメモリをソート用のバッファとして使用する。
     デフォルトでは、SIZE は 1024 バイト単位である。`%' を後ろに付ける
     と、SIZE は、物理メモリの何パーセントの意味になる。後置するのが `K'
     ならば、SIZE は 1024 倍され (デフォルトと同じ)、`M' なら 1,048,576
     倍、`G' なら 1,073,741,824 倍される。`T', `P', `E', `Z', `Y' の後置
     も、同じ理屈である。`b' を後置すると、SIZE はバイト数と見なされ、
     掛け算は行われない。

     このオプションを指定すると、`sort' は作業を始めるとき、デフォルト
     よりも大きかったり、小さかったりするソート用のバッファを使用する
     ことになり、そのために動作速度が向上することがある。とは言え、この
     オプションは起動直後のバッファサイズにしか影響を持たない。`sort' が
     SIZE を越える入力行に出会うと、バッファのサイズは SIZE 以上に拡大
     されるからである。

`-t SEPARATOR'
`--field-separator=SEPARATOR'
     各行でソートに使うキーを探すとき、文字 SEPARATOR をフィールド・
     セパレータとして使用する。デフォルトでフィールドを区分するのは、
     非空白文字と空白文字の間の空文字列である。デフォルトの空白は、
     スペースとタブだが、`LC_CTYPE' のロケールによっては、違うかも
     しれない。

     たとえば、入力行が ` foo bar' だったとしよう。`sort' はこれを
     ` foo' と ` bar' のフィールドに分割する。フィールド・セパレータは
     前後どちらのフィールドにも属さないことになっているので、 `sort
     -t " "' を使用した場合、上記の入力行は、 空っぽのフィールド、
     `foo'、それに `bar' という 3 個のフィールドを持つことになる。
     とは言え、キー・フィールドが、`-k 2' のように、行末まで続く場合や、
     `-k 2,3' のように、範囲からなる場合は、範囲の両端の間に存在する
     フィールド・セパレータは、キー・フィールド中にそのまま保持される。

     ASCII NUL をフィールド・セパレータに指定するには、二文字からなる
     文字列 `\0' を使用すればよい。`sort -t '\0'' のようにだ。

`-T TEMPDIR'
`--temporary-directory=TEMPDIR'
     テンポラリファイルの置き場所にディレクトリ TEMPDIR を使用する。
     この指定は、環境変数 `TMPDIR' に優先する。このオプションを二回
     以上指定すると、テンポラリファイルの置き場所として、指定された
     すべてのディレクトリが使用されることになる。大規模なソートや
     マージを行って、I/O が足枷になる場合、このオプションを使って、
     別のディスクやコントローラを使用している複数のディレクトリを
     指定すると、実行速度が向上することがよくある。

`--parallel=N'
     平行して実行するソートの数を  N に設定する。デフォルトでは、 N
     は、利用できるプロセッサーの数になっている。ただし、上限は 8
     であり、これは、それ以上にしても、速度の向上が頭打ちになるからだ。
     N 個のスレッドを使用すると、メモリの使用量が log N 倍になること
     にも注意していただきたい。参照 *note nproc invocation::.

`-u'
`--unique'
     通常は、比較して等価と評価された複数の行の内、最初のもののみを出力
     する。`--check' (`-c' または `-C') オプションが指定されている場合
     は、等価な行が連続して二行存在しないかをチェックする (訳注: 等価な
     行の連続があると、終了ステータスが 1 になる)。

     また、このオプションを指定すると、デフォルトでは実行する最後の
     手段の比較を行わなくなる。

     コマンド `sort -u' と `sort | uniq' は等価である。しかし、その
     等価性は、`sort' に何か他のオプションが付いたときにまでは及ばない。
     たとえば、`sort -n -u' は、唯一性のチェックをするとき、行頭にある
     数字の並びの値しか調べないが、`sort -n | uniq' の方は、行全体を検査
     するのである。*Note uniq invocation::.

`-z'
`--zero-terminated'
     項目の区切りに、改行 (ASCII LF) ではなく、ゼロバイトを使用する。
     すなわち、入力を ASCII NUL で分離された項目として扱い、出力する
     各項目の末尾に ASCII NUL を付加する。このオプションは、`perl -0',
     `find -print0', `xargs -0' などと組み合わせて使用すると、便利な
     ことがある。そうしたコマンドも、わがままなファイル名を (空白など
     の特殊文字を含んでいる場合でも) きちんと確実に処理するために、
     同様なことをしているのである。


   `sort' の従来の (すなわち BSD と System V の) 実装では、いくつかの
オプションの解釈が互いに異なっていた。とりわけ、`-b', `-f', `-n' に
ついてそうだった。GNU の sort は、POSIX 規格の動作に従っており、これは、
たいていの場合 (常にではない！)、System V の動作と同じである。POSIX
によると、 `-n' はもはや `-b' を暗黙のうちに設定しない。そこで、動作の
一貫性のために、`-M' も同様に変更した。この変更によって、フィールドを
指定するとき、文字の位置がどこを指すかが、微妙なケースでは変わってくる
かもしれない。これに対する唯一の対処法は、明示的に `-b' オプションを
指定することである。

   `-k' によってソート・フィールドを指定するとき、その位置指定の後ろに
オプション文字 `MbdfghinRrV' のうち任意のものを付けることができる。その
場合、そのフィールドは、グローバルな順序関係のオプションを一切引き継が
ないことになる。`-b' オプションは、フィールド限定のオプションとしては、
フィールド指定の開始位置と終端位置の片方、あるいは両方に付けることが
できるが、グローバル・オプションから継承した場合は、両方に付いている
ことになる。入力行が、行頭やフィールド間に複数の空白を含んでいる可能性
があって、しかも `-t' を使っていない場合は、`-k' を使用するとき、`-b'
と組み合わせるか、先行する空白を暗黙のうちに無視するオプション (すなわち
`Mghn') と組み合わせるのが普通だ。そうしないと、フィールドにある先行する
空白の数の違いのせいで、結果がわけのわからないものになりかねないからで
ある。

   ソートフィールド指定の開始位置が、行末より後ろや、終端側のフィールド
より後ろに来てしまうと、そのフィールドは空になる。`-b' オプションを
指定した場合、フィールド指定の `.C' の部分は、そのフィールドの最初の
非空白文字から数えることになる。

   古いシステムの `sort' では、ソート・キーの指定に、`+POS1 [-POS2]'
という 0 から数える旧式の書式が使える。`sort +A.X -B.Y' という旧式の
表現は、もし Y が `0' であるか、指定されていない場合は、 `sort -k
A+1.X+1,B' と同じである。それ以外の場合は、 `sort -k A+1.X+1,B+1.Y' と
同じだ。

   この旧式の動作は、環境変数 `_POSIX2_VERSION' を使って (*note
Standards conformance::) 有効にしたり、無効にしたりすることができる。
また、`POSIXLY_CORRECT' が設定されていないときに、`-POS2' が存在する旧式
の書式を使っても、有効になる。

   標準的なホストで使用することを意図したスクリプトでは、旧式の書式は
使わずに、`-k' の方を使用するべきである。たとえば、`sort +2' は使わない
方がよい。`sort ./+2' と解釈されるか、`sort -k 3' と解釈されるか、わから
ないからである。そのスクリプトが、旧式の書式にしか対応していないホスト
でも動作しなければならないのなら、スクリプト中で
`if sort -k 1 </dev/null >/dev/null 2>&1; then ...' といったテストを
行って、どちらの書式を使うべきかを判断すればよい。

   用例をいくつか挙げて、オプションの様々な組み合わせを説明する。

   * 数値としてソートし、降順に (つまり、通常の逆に) 並べる。

          sort -n -r

   * 同時にソートを 4 つまで行う。バッファサイズを 10M にする。

          sort --parallel=4 -S 10M

   * 1 番目と 2 番目のフィールドを無視し、さらに 3 番目のフィールドの
     先頭の空白も無視して、アルファベット順に並べる。ここで使っている
     キーは一つであり、それは 3 番目のフィールドの最初の非空白文字に
     始まって、各行の末尾まで続くすべての文字からなっている。

          sort -k 3b

   * 2 番目のフィールドを数値としてソートし、同点の決着を付けるために、
     5 番目のフィールドの 3 番目と 4 番目の文字をアルファベット順で
     ソートする。フィールドの区切りには `:' を使用する。

          sort -t : -k 2,2n -k 5.3,5.4

     ここで注意していただきたいが、もし `-k 2,2n' の代わりに `-k 2n'
     と書いたなら、`sort' は、2 番目のフィールドに始まり、行末まで
     続くすべての文字を、主キー (primary key) として、それも「数値」の
     キーとして使用したことだろう。`sort' の実行のたいていの場合に
     ついて言えることだが、複数のフィールドにまたがるキーを数値として
     使用しても、期待する結果は得られないものである。

     もう一つ注意していただきたい。上の例では、`n' 修飾子を最初のキーの
     フィールド終端指定に付けている。これは、`-k 2n,2' とか `-k 2n,2n'
     とか指定しても、同じことだったろう。`b' を除くすべての修飾子は、
     キー指定のフィールド開始側に付けるか、フィールド終端側に付けるか、
     あるいは、その両方に付けるかにかかわりなく、付けられた「キー・
     フィールド全体」に適用されるのである。

   * パスワードファイルを 5 番目のフィールドでソートする。このとき、
     先頭の空白は無視する。5 番目のフィールドが同じ値になる行について
     は、3 番目のフィールドのユーザ ID 番号でソートする。フィールドの
     区切りは、`:' という文字である。

          sort -t : -k 5b,5 -k 3,3n /etc/passwd
          sort -t : -n -k 5b,5 -k 3,3 /etc/passwd
          sort -t : -b -k 5,5 -k 3,3n /etc/passwd

     この三つのコマンドは同じ働きをする。1 番目のコマンドは、最初の
     キーの開始位置では先行する空白を無視し、二番目のキーを数値として
     ソートするように指定している。他の二つのコマンドは、グローバル・
     オプションは、修飾子がないソート・キーによって継承されるという
     特性を利用している。この場合、継承がうまく働くのは、`-k 5b,5b' と
     `-k 5b,5' が同じことだからだ (訳注: 「`-b' オプションは ...
     グローバル・オプションから継承した場合は、(開始位置と終端位置の)
     両方に付いていることになる」ので、3 番目のコマンドは、`-k 5b,5b'
     と指定するのと事実上等しい)。両者が同じになるのは、`.C' という
     文字位置を欠いたフィールド終端の指定では、先頭の空白をスキップしても
     しなくても、終端位置は変わらないからである。

   * 一群のログファイルをソートする。主キーとして IPv4 アドレスを
     使用し、副キーとしてタイムスタンプを使用する。二つの行の
     主キーと副キーが全く同じ場合は、入力されたときと同じ順番で、
     その行を出力する。ログファイルは、次のような行からなっている。

          4.150.156.3 - - [01/Apr/2004:06:31:51 +0000] message 1
          211.24.3.231 - - [24/Apr/2004:20:17:39 +0000] message 2

     フィールドは、ただ 1 個の空白で区切られている。IPv4 アドレスの
     ソートは辞書順で行う。たとえば、212.61.52.2 は 212.129.233.201 の
     前に来る。61 は 129 よりも小さいからだ。

          sort -s -t ' ' -k 4.9n -k 4.5M -k 4.2n -k 4.14,4.21 file*.log |
          sort -s -t '.' -k 1,1n -k 2,2n -k 3,3n -k 4,4n

     この例の場合は、`sort' を一回起動するだけでは、ことがすまない。
     日付が空白 1 個のすぐ後に置かれているだけなのに対して、IPv4 の
     構成要素は `.' で区切られているからである。そこで、作業を分割し、
     `sort' を 2 回起動している。1 回目はタイムスタンプでソートし、 2
     回目は IPv4 アドレスでソートするわけだ。タイムスタンプは、年、月、
     日のフィールドの順番でソートし、最後に、時・分・秒のフィールドで
     ソートしているが、それは `-k' オプションを使って、各フィールドを
     分離することで実現している。時・分・秒を除いて、各キー・フィールド
     の終端を指定する必要はない。`n' や `M' 修飾子は、フィールドの先頭
     にある文字列に基づいてソートを行うが、そうした文字列は、フィールド
     の境界を越えられないからである。IPv4 アドレスのソートは、辞書順で
     行っている。なお、二回目のソートで `-s' を使っているのは、主キーで
     一ヶ所にまとめられる行が、副キーによってソートされているようにする
     ためである。それに対して、一回目のソートで  `-s' を使っているのは、
     二つのソートの組み合わせ全体を入力順尊重 (stable) にするためだ。

   * アルファベットの大文字小文字の違いを無視してソートし、その順番で
     tags ファイルを作成する。

          find src -type f -print0 | sort -z -f | xargs -0 etags --append

     この例では、`-print0', `-z', `-0' といったオプションを使っている。
     そのため、空白などの特殊文字を含んでいるファイル名が、ソート操作に
     よって分断されることがない。

   * 慣用句 DSU (Decorate Sort Undecorate) の手法 (訳注: 指標を付けて、
     ソートして、指標を取る) を採用して、短いものから長いものへと、
     行を並べる。

          awk '{print length, $0}' /etc/passwd | sort -n | cut -f2- -d' '

     一般に、あるデータが `sort' コマンドでは直接ソートできないとか、
     効率が悪いというとき、そうしたデータをソートするのに、この手法が
     役に立つ。

   * ディレクトリをランダムな順番でで並べる。ただし、各ディレクトリ内の
     ファイルについては、その順番を維持する。一例を挙げると、この方法で
     演奏リストを作れば、アルバムはシャッフルするけれど、各アルバム内の
     曲は順番に演奏するといったことが可能になる。

          ls */* | sort -t / -k 1,1R -k 2,2


   ---------- Footnotes ----------

   (1) POSIX 以外のロケールを使用すると (たとえば、`LC_ALL' を `en_US'
に設定すると)、`sort' の出力が、見慣れない順序でソートされたものに
なるかもしれない。その場合は、環境変数 `LC_ALL' を `C' にすればよい。
注意すべきは、`LC_COLLATE' だけを設定したのでは、二つの問題が生じて
しまうということだ。一つは、`LC_ALL' も設定されている場合、`LC_COLLATE'
は無効だということ。二つ目は、`LC_CTYPE' が (`LC_CTYPE' が設定されて
いないときは `LANG' が)、矛盾する値に設定されている場合は、動作が未定義
だということである。一例を挙げると、`LC_CTYPE' が `ja_JP.PCK' なのに、
`LC_COLLATE' が `en_US.UTF-8' の場合、`sort' の動作は未定義である。


File: coreutils-ja.info,  Node: shuf invocation,  Next: uniq invocation,  Prev: sort invocation,  Up: Operating on sorted files

7.2 `shuf': テキストをシャッフルする
================================================

`shuf' は、入力された行をランダムに並べ替えてから出力することによって、
入力のシャッフルを行う。どの並び替えが出力されるかは、確率的に等しい。

   書式:

     shuf [OPTION]... [FILE]
     shuf -e [OPTION]... [ARG]...
     shuf -i LO-HI [OPTION]...

   `shuf' には三つの動作モードがあり、それぞれ、入力行をどこから取得
するかが違っている。デフォルトでは、標準入力から行を読み込む。以下の
オプションは、動作モードを変更する。

`-e'
`--echo'
     コマンドラインの各オペランドを入力行として扱う。

`-i LO-HI'
`--input-range=LO-HI'
     LO から HI の範囲の符号なしの 10 進整数を 1 行に 1 個含むファイル
     から入力があったかのように動作する。


   `shuf' の他のオプションは、どの動作モードでも、その動作に影響を
与える。

`-n LINES'
`--head-count=COUNT'
     最大でも COUNT 行までしか出力しない。デフォルトでは、入力された
     すべての行を出力する。

`-o OUTPUT-FILE'
`--output=OUTPUT-FILE'
     出力を、標準出力ではなく、OUTPUT-FILE に書き出す。`shuf' は、
     入力をすべて読み込んでから、OUTPUT-FILE をオープンする。従って、
     `shuf -o F <F' や `cat F | shuf -o F' というコマンドを使って、
     ファイルを直接書き変える形でシャッフルしても安全である。

`--random-source=FILE'
     ランダムデータのソースとして  FILE を使用する。そのランダムデータは
     どんな並べ替えになるかを決めるのに使用される。*Note Random
     sources::.

`-z'
`--zero-terminated'
     項目の区切りに、改行 (ASCII LF) ではなく、ゼロバイトを使用する。
     すなわち、入力を ASCII NUL で分離された項目として扱い、出力する
     各項目の末尾に ASCII NUL を付加する。このオプションは、`perl -0',
     `find -print0', `xargs -0' などと組み合わせて使用すると、便利な
     ことがある。そうしたコマンドも、わがままなファイル名を (空白など
     の特殊文字を含んでいる場合でも) きちんと確実に処理するために、
     同様なことをしているのである。


   例を挙げる。

     shuf <<EOF
     A man,
     a plan,
     a canal:
     Panama!
     EOF

上記の結果は、こんな出力になるかもしれない。

     Panama!
     A man,
     a canal:
     a plan,

同様に、次のコマンドの出力は、

     shuf -e clubs hearts diamonds spades

こうなるかもしれない。

     clubs
     diamonds
     spades
     hearts

下記は、`shuf -i 1-4' というコマンドの出力の一例である。

     4
     2
     1
     3

上記のどの例でも、入力行は 4 行である。従って、入力は 24 とおりに並べ
替えることが可能であり、`shuf' が生成するのは、そのどれか一つである。
一般的に言うと、入力行が N 行なら、N! とおりに (N の階乗、すなわち、
N * (N - 1) * ... * 1 とおりに) 並べ替えて、出力することができる。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: uniq invocation,  Next: comm invocation,  Prev: shuf invocation,  Up: Operating on sorted files

7.3 `uniq': ファイルから重複を省く
=============================================

`uniq' は、指定された INPUT ファイルにある行を、重複を省いて書き出す。
ファイルが指定されていない場合や、INPUT として `-' が指定されている
場合は、標準入力を対象とする。

   書式:

     uniq [OPTION]... [INPUT [OUTPUT]]

   デフォルトでは、`uniq' は入力された行を表示するとき、隣接する同一行
があれば、出力に重複する行が現れないように、最初の行だけを残して、残りの
行を捨ててしまう。また、オプションによっては、重複しない行を捨てることや、
すべての隣接する同一行を捨てることもできる。

   入力はソートされている必要はないが、重複する入力行が検出されるのは、
それが隣接しているときだけである。もし、隣接していない重複行も捨てたい
のなら、`sort -u' を使うとよいだろう。 *Note sort invocation::.

   比較には `LC_COLLATE' ロケール・カテゴリが指定しているルールを使用
する。

   OUTPUT ファイルが指定されていない場合、`uniq' は標準出力に書き出す。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-f N'
`--skip-fields=N'
     重複の検査を行う前に、各行のフィールドを N 個スキップする。その行に
     N 個より少ないフィールドしかない場合は、比較に null 文字列を使用
     する。フィールドとは、少なくとも 1 個以上のスペースやタブで間を区切
     られた、スペースやタブを含まない文字の連続である。

     互換性のために、`uniq' は `-N' という古いオプションの書式をサポート
     している。新しいスクリプトでは、`-f N' の方を使うべきである。

`-s N'
`--skip-chars=N'
     重複の検査を行う前に、N 文字スキップする。その行に N 個より少ない
     文字しかない場合は、比較に null 文字列を使用する。フィールドを
     スキップするオプションと、文字をスキップするオプションの両方を
     使っている場合は、フィールドのスキップが先に行われる。

     古めのシステムでは、`uniq' が `+N' という古いオプションの書式を
     サポートしている。環境変数 `_POSIX2_VERSION' を使えば、この旧式の
     動作を有効したり、無効にしたりできる (*note Standards
     conformance::)。 とは言え、移植を考慮したスクリプトでは、
     この環境変数に動作が依存するコマンドの使用は、避けた方がよい。
     たとえば、`uniq +10' ではなく、`uniq ./+10' や `uniq -s 10' を使う
     べきである。前者では、`+10' が、オプションかファイル名か、まぎらわ
     しいからだ。

`-c'
`--count'
     各行に出現回数を付けて表示する。

`-i'
`--ignore-case'
     行を比較するとき、アルファベットの大文字小文字を区別しない。

`-d'
`--repeated'
     重複していない行を除去する。このオプションを単独で使った場合、`uniq'
     は、連続する同一行のうち、最初の 1 行だけを表示し、それ以外の何も
     表示しない。

`-D'
`--all-repeated[=DELIMIT-METHOD]'
     入力行のうち、連続する同一行の二行目以降を除去せず、重複していない
     行だけを除去する。このオプションが役に立つのは、主として、大文字
     小文字を無視するとか、選択したフィールドのみを比較するとかいった、
     他のオプションと組み合わせて使うときである。DELIMIT-METHOD は
     省略可能であり、重複行のグループ間をどのように区切るかを指定して
     いる。DELIMIT-METHOD は、以下の一つでなければならない。

    `none'
          重複行のグループ間に、区切りの印を置かない。`--all-repeated'
          (`-D') とのみ指定するのと同じことである。

    `prepend'
          重複行の各グループの前に改行を出力する。`--zero-terminated'
          (`-z') を指定している場合は、改行の代わりに、ゼロバイト
          (ASCII NUL) を使用する。

    `separate'
          重複行のグループ間を 1 個の改行で分離する。`--zero-terminated'
          (`-z') を指定している場合は、改行の代わりに、ゼロバイト (ASCII
          NUL) を使用する。これは、`prepend' を使うのとほぼ同じだが、
          最初のグループの前に区切りの印を挿入しないのが異なっている。
          それ故、ユーザが出力を直接見る場合に、より適しているかもしれない。

     注意していただきたいが、グループ同士を改行で分離しているとき、
     入力ストリームに連続する 2 行以上の空行があると、出力がまぎらわ
     しいものになる。これを避けるには、入力を `tr -s '\n'' でフィルタ
     リングして、連続する改行をそれぞれの場所で 1 個の改行に置き換え
     ればよい。

     このオプションは、GNU による拡張である。

`-u'
`--unique'
     連続する同一行は、1 行目も除去する。このオプションを単独で使うと、
     `uniq' はユニークな (訳注: この場合、同一行が直後に続かないという
     意味) 行だけを表示し、それ以外の何も表示しない。

`-w N'
`--check-chars=N'
     各行で (フィールドや文字をスキップする指定があれば、スキップした
     後で) 文字を何個まで比較するかを指定する。デフォルトでは、行の残り
     全部が比較の対象になる。

`-z'
`--zero-terminated'
     項目の区切りに、改行 (ASCII LF) ではなく、ゼロバイトを使用する。
     すなわち、入力を ASCII NUL で分離された項目として扱い、出力する
     各項目の末尾に ASCII NUL を付加する。このオプションは、`perl -0',
     `find -print0', `xargs -0' などと組み合わせて使用すると、便利な
     ことがある。そうしたコマンドも、わがままなファイル名を (空白など
     の特殊文字を含んでいる場合でも) きちんと確実に処理するために、
     同様なことをしているのである。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: comm invocation,  Next: ptx invocation,  Prev: uniq invocation,  Up: Operating on sorted files

7.4 `comm': ソート済みの二つのファイルを一行づつ比較する
==============================================================================

`comm' は、二つの入力ファイルの共通する行と独自な行を、標準出力に区別
して書き出す。`-' というファイル名は、標準入力を意味している。

   書式:

     comm [OPTION]... FILE1 FILE2

   入力ファイルは、`comm' に渡す前に、`LC_COLLATE' のロケールによって
規定された照合順序でソートされていなければならない。入力ファイルが
改行以外の文字で終わっている場合は、自動的に改行が追加される。 `sort'
コマンドをオプションなしで実行すると、`comm' の入力にふさわしい
ファイルが必ず得られる。

   オプションを付けずに実行すると、`comm' は 3 列の出力を生成する。 1
列目は FILE1 にのみある行であり、2 列目は FILE2 にのみある行、そして 3
列目は両方のファイルに共通する行である。各列は、1 個のタブ文字で
区切られている。

   `-1', `-2', `-3' というオプションは、対応する列 (と区切り記号) を
表示しないようにする。オプションについては、「共通オプション」の章も
参照すること。*note Common options::.

   比較のための他のユーティリティとは違って、`comm' の終了ステータスは、
比較結果の如何によらない。`comm' は、正常終了すると 0 の終了コードを
返す。エラーがあれば、0 以外のステータスで終了する。

   `--check-order' を指定した場合、入力がソートされていないと、エラー
メッセージを出して、実行を中断する。`--nocheck-order' オプションを指定
した場合は、入力がソートされていなくても、エラーメッセージを出すことは
ない。どちらのオプションも指定されていない場合、入力がソートされて
いないと診断されるのは、 片方の入力ファイルにもう一方と対にならない
行が見つかったときだけである。 `comm' は、入力ファイルがソートされて
いないと診断すると、0 以外のステータスで終了する (従って、そうした
出力は使用しない方がよい)。

   入力ファイルがきちんとソートされていず、しかも、対にならない行を
含む場合に、`--nocheck-order' を指定して、そうしたファイルを `comm' で
無理矢理処理しても、何か特定の結果をもたらすことは保証できない。おそらく
出力は、期待に添わないものになるだろう。

`--check-order'
     入力ファイルのどちらかの内容がきちんとした順番になっていないと、
     エラーメッセージを出して、実行に失敗する。

`--nocheck-order'
     入力ファイルの内容がソートされた順番になっているかどうかを、
     どちらのファイルについてもチェックしない。

     その他のオプション。

`--output-delimiter=STR'
     出力における隣り合う列の間に、デフォルトのタブ文字 1 個ではなく、
     STR を出力する。

     区切り記号の STR は、空であってはならない。



File: coreutils-ja.info,  Node: ptx invocation,  Next: tsort invocation,  Prev: comm invocation,  Up: Operating on sorted files

7.5 `ptx': Produce permuted indexes
===================================

`ptx' reads a text file and essentially produces a permuted index, with
each keyword in its context.  The calling sketch is either one of:

     ptx [OPTION ...] [FILE ...]
     ptx -G [OPTION ...] [INPUT [OUTPUT]]

   The `-G' (or its equivalent: `--traditional') option disables all
GNU extensions and reverts to traditional mode, thus introducing some
limitations and changing several of the program's default option
values.  When `-G' is not specified, GNU extensions are always enabled.
GNU extensions to `ptx' are documented wherever appropriate in this
document.  *Note Compatibility in ptx::, for the full list.

   Individual options are explained in the following sections.

   When GNU extensions are enabled, there may be zero, one or several
FILEs after the options.  If there is no FILE, the program reads the
standard input.  If there is one or several FILEs, they give the name
of input files which are all read in turn, as if all the input files
were concatenated.  However, there is a full contextual break between
each file and, when automatic referencing is requested, file names and
line numbers refer to individual text input files.  In all cases, the
program outputs the permuted index to the standard output.

   When GNU extensions are _not_ enabled, that is, when the program
operates in traditional mode, there may be zero, one or two parameters
besides the options.  If there are no parameters, the program reads the
standard input and outputs the permuted index to the standard output.
If there is only one parameter, it names the text INPUT to be read
instead of the standard input.  If two parameters are given, they give
respectively the name of the INPUT file to read and the name of the
OUTPUT file to produce.  _Be very careful_ to note that, in this case,
the contents of file given by the second parameter is destroyed.  This
behavior is dictated by System V `ptx' compatibility; GNU Standards
normally discourage output parameters not introduced by an option.

   Note that for _any_ file named as the value of an option or as an
input text file, a single dash `-' may be used, in which case standard
input is assumed.  However, it would not make sense to use this
convention more than once per program invocation.

* Menu:

* General options in ptx::   Options which affect general program behavior.
* Charset selection in ptx::  Underlying character set considerations.
* Input processing in ptx::  Input fields, contexts, and keyword selection.
* Output formatting in ptx::  Types of output format, and sizing the fields.
* Compatibility in ptx::


File: coreutils-ja.info,  Node: General options in ptx,  Next: Charset selection in ptx,  Up: ptx invocation

7.5.1 General options
---------------------

`-G'
`--traditional'
     As already explained, this option disables all GNU extensions to
     `ptx' and switches to traditional mode.

`--help'
     簡単なヘルプメッセージを標準出力に表示し、それ以上の処理をする
     ことなく終了する。

`--version'
     プログラムのバージョンを標準出力に表示し、それ以上の処理をする
     ことなく、終了する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Charset selection in ptx,  Next: Input processing in ptx,  Prev: General options in ptx,  Up: ptx invocation

7.5.2 Charset selection
-----------------------

As it is set up now, the program assumes that the input file is coded
using 8-bit ISO 8859-1 code, also known as Latin-1 character set,
_unless_ it is compiled for MS-DOS, in which case it uses the character
set of the IBM-PC.  (GNU `ptx' is not known to work on smaller MS-DOS
machines anymore.)  Compared to 7-bit ASCII, the set of characters
which are letters is different; this alters the behavior of regular
expression matching.  Thus, the default regular expression for a
keyword allows foreign or diacriticized letters.  Keyword sorting,
however, is still crude; it obeys the underlying character set ordering
quite blindly.

`-f'
`--ignore-case'
     Fold lower case letters to upper case for sorting.



File: coreutils-ja.info,  Node: Input processing in ptx,  Next: Output formatting in ptx,  Prev: Charset selection in ptx,  Up: ptx invocation

7.5.3 Word selection and input processing
-----------------------------------------

`-b FILE'
`--break-file=FILE'
     This option provides an alternative (to `-W') method of describing
     which characters make up words.  It introduces the name of a file
     which contains a list of characters which can_not_ be part of one
     word; this file is called the "Break file".  Any character which
     is not part of the Break file is a word constituent.  If both
     options `-b' and `-W' are specified, then `-W' has precedence and
     `-b' is ignored.

     When GNU extensions are enabled, the only way to avoid newline as a
     break character is to write all the break characters in the file
     with no newline at all, not even at the end of the file.  When GNU
     extensions are disabled, spaces, tabs and newlines are always
     considered as break characters even if not included in the Break
     file.

`-i FILE'
`--ignore-file=FILE'
     The file associated with this option contains a list of words
     which will never be taken as keywords in concordance output.  It
     is called the "Ignore file".  The file contains exactly one word
     in each line; the end of line separation of words is not subject
     to the value of the `-S' option.

`-o FILE'
`--only-file=FILE'
     The file associated with this option contains a list of words
     which will be retained in concordance output; any word not
     mentioned in this file is ignored.  The file is called the "Only
     file".  The file contains exactly one word in each line; the end
     of line separation of words is not subject to the value of the
     `-S' option.

     There is no default for the Only file.  When both an Only file and
     an Ignore file are specified, a word is considered a keyword only
     if it is listed in the Only file and not in the Ignore file.

`-r'
`--references'
     On each input line, the leading sequence of non-white space
     characters will be taken to be a reference that has the purpose of
     identifying this input line in the resulting permuted index.
     *Note Output formatting in ptx::, for more information about
     reference production.  Using this option changes the default value
     for option `-S'.

     Using this option, the program does not try very hard to remove
     references from contexts in output, but it succeeds in doing so
     _when_ the context ends exactly at the newline.  If option `-r' is
     used with `-S' default value, or when GNU extensions are disabled,
     this condition is always met and references are completely
     excluded from the output contexts.

`-S REGEXP'
`--sentence-regexp=REGEXP'
     This option selects which regular expression will describe the end
     of a line or the end of a sentence.  In fact, this regular
     expression is not the only distinction between end of lines or end
     of sentences, and input line boundaries have no special
     significance outside this option.  By default, when GNU extensions
     are enabled and if `-r' option is not used, end of sentences are
     used.  In this case, this REGEX is imported from GNU Emacs:

          [.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*

     Whenever GNU extensions are disabled or if `-r' option is used,
     end of lines are used; in this case, the default REGEXP is just:

          \n

     Using an empty REGEXP is equivalent to completely disabling end of
     line or end of sentence recognition.  In this case, the whole file
     is considered to be a single big line or sentence.  The user might
     want to disallow all truncation flag generation as well, through
     option `-F ""'.  *Note Syntax of Regular Expressions:
     (emacs)Regexps.

     When the keywords happen to be near the beginning of the input
     line or sentence, this often creates an unused area at the
     beginning of the output context line; when the keywords happen to
     be near the end of the input line or sentence, this often creates
     an unused area at the end of the output context line.  The program
     tries to fill those unused areas by wrapping around context in
     them; the tail of the input line or sentence is used to fill the
     unused area on the left of the output line; the head of the input
     line or sentence is used to fill the unused area on the right of
     the output line.

     As a matter of convenience to the user, many usual backslashed
     escape sequences from the C language are recognized and converted
     to the corresponding characters by `ptx' itself.

`-W REGEXP'
`--word-regexp=REGEXP'
     This option selects which regular expression will describe each
     keyword.  By default, if GNU extensions are enabled, a word is a
     sequence of letters; the REGEXP used is `\w+'.  When GNU
     extensions are disabled, a word is by default anything which ends
     with a space, a tab or a newline; the REGEXP used is `[^ \t\n]+'.

     An empty REGEXP is equivalent to not using this option.  *Note
     Syntax of Regular Expressions: (emacs)Regexps.

     As a matter of convenience to the user, many usual backslashed
     escape sequences, as found in the C language, are recognized and
     converted to the corresponding characters by `ptx' itself.



File: coreutils-ja.info,  Node: Output formatting in ptx,  Next: Compatibility in ptx,  Prev: Input processing in ptx,  Up: ptx invocation

7.5.4 Output formatting
-----------------------

Output format is mainly controlled by the `-O' and `-T' options
described in the table below.  When neither `-O' nor `-T' are selected,
and if GNU extensions are enabled, the program chooses an output format
suitable for a dumb terminal.  Each keyword occurrence is output to the
center of one line, surrounded by its left and right contexts.  Each
field is properly justified, so the concordance output can be readily
observed.  As a special feature, if automatic references are selected
by option `-A' and are output before the left context, that is, if
option `-R' is _not_ selected, then a colon is added after the
reference; this nicely interfaces with GNU Emacs `next-error'
processing.  In this default output format, each white space character,
like newline and tab, is merely changed to exactly one space, with no
special attempt to compress consecutive spaces.  This might change in
the future.  Except for those white space characters, every other
character of the underlying set of 256 characters is transmitted
verbatim.

   Output format is further controlled by the following options.

`-g NUMBER'
`--gap-size=NUMBER'
     Select the size of the minimum white space gap between the fields
     on the output line.

`-w NUMBER'
`--width=NUMBER'
     Select the maximum output width of each final line.  If references
     are used, they are included or excluded from the maximum output
     width depending on the value of option `-R'.  If this option is
     not selected, that is, when references are output before the left
     context, the maximum output width takes into account the maximum
     length of all references.  If this option is selected, that is,
     when references are output after the right context, the maximum
     output width does not take into account the space taken by
     references, nor the gap that precedes them.

`-A'
`--auto-reference'
     Select automatic references.  Each input line will have an
     automatic reference made up of the file name and the line ordinal,
     with a single colon between them.  However, the file name will be
     empty when standard input is being read.  If both `-A' and `-r'
     are selected, then the input reference is still read and skipped,
     but the automatic reference is used at output time, overriding the
     input reference.

`-R'
`--right-side-refs'
     In the default output format, when option `-R' is not used, any
     references produced by the effect of options `-r' or `-A' are
     placed to the far right of output lines, after the right context.
     With default output format, when the `-R' option is specified,
     references are rather placed at the beginning of each output line,
     before the left context.  For any other output format, option `-R'
     is ignored, with one exception: with `-R' the width of references
     is _not_ taken into account in total output width given by `-w'.

     This option is automatically selected whenever GNU extensions are
     disabled.

`-F STRING'
`--flac-truncation=STRING'
     This option will request that any truncation in the output be
     reported using the string STRING.  Most output fields
     theoretically extend towards the beginning or the end of the
     current line, or current sentence, as selected with option `-S'.
     But there is a maximum allowed output line width, changeable
     through option `-w', which is further divided into space for
     various output fields.  When a field has to be truncated because
     it cannot extend beyond the beginning or the end of the current
     line to fit in, then a truncation occurs.  By default, the string
     used is a single slash, as in `-F /'.

     STRING may have more than one character, as in `-F ...'.  Also, in
     the particular case when STRING is empty (`-F ""'), truncation
     flagging is disabled, and no truncation marks are appended in this
     case.

     As a matter of convenience to the user, many usual backslashed
     escape sequences, as found in the C language, are recognized and
     converted to the corresponding characters by `ptx' itself.

`-M STRING'
`--macro-name=STRING'
     Select another STRING to be used instead of `xx', while generating
     output suitable for `nroff', `troff' or TeX.

`-O'
`--format=roff'
     Choose an output format suitable for `nroff' or `troff'
     processing.  Each output line will look like:

          .xx "TAIL" "BEFORE" "KEYWORD_AND_AFTER" "HEAD" "REF"

     so it will be possible to write a `.xx' roff macro to take care of
     the output typesetting.  This is the default output format when GNU
     extensions are disabled.  Option `-M' can be used to change `xx'
     to another macro name.

     In this output format, each non-graphical character, like newline
     and tab, is merely changed to exactly one space, with no special
     attempt to compress consecutive spaces.  Each quote character: `"'
     is doubled so it will be correctly processed by `nroff' or `troff'.

`-T'
`--format=tex'
     Choose an output format suitable for TeX processing.  Each output
     line will look like:

          \xx {TAIL}{BEFORE}{KEYWORD}{AFTER}{HEAD}{REF}

     so it will be possible to write a `\xx' definition to take care of
     the output typesetting.  Note that when references are not being
     produced, that is, neither option `-A' nor option `-r' is
     selected, the last parameter of each `\xx' call is inhibited.
     Option `-M' can be used to change `xx' to another macro name.

     In this output format, some special characters, like `$', `%',
     `&', `#' and `_' are automatically protected with a backslash.
     Curly brackets `{', `}' are protected with a backslash and a pair
     of dollar signs (to force mathematical mode).  The backslash
     itself produces the sequence `\backslash{}'.  Circumflex and tilde
     diacritical marks produce the sequence `^\{ }' and `~\{ }'
     respectively.  Other diacriticized characters of the underlying
     character set produce an appropriate TeX sequence as far as
     possible.  The other non-graphical characters, like newline and
     tab, and all other characters which are not part of ASCII, are
     merely changed to exactly one space, with no special attempt to
     compress consecutive spaces.  Let me know how to improve this
     special character processing for TeX.



File: coreutils-ja.info,  Node: Compatibility in ptx,  Prev: Output formatting in ptx,  Up: ptx invocation

7.5.5 The GNU extensions to `ptx'
---------------------------------

This version of `ptx' contains a few features which do not exist in
System V `ptx'.  These extra features are suppressed by using the `-G'
command line option, unless overridden by other command line options.
Some GNU extensions cannot be recovered by overriding, so the simple
rule is to avoid `-G' if you care about GNU extensions.  Here are the
differences between this program and System V `ptx'.

   * This program can read many input files at once, it always writes
     the resulting concordance on standard output.  On the other hand,
     System V `ptx' reads only one file and sends the result to
     standard output or, if a second FILE parameter is given on the
     command, to that FILE.

     Having output parameters not introduced by options is a dangerous
     practice which GNU avoids as far as possible.  So, for using `ptx'
     portably between GNU and System V, you should always use it with a
     single input file, and always expect the result on standard
     output.  You might also want to automatically configure in a `-G'
     option to `ptx' calls in products using `ptx', if the configurator
     finds that the installed `ptx' accepts `-G'.

   * The only options available in System V `ptx' are options `-b',
     `-f', `-g', `-i', `-o', `-r', `-t' and `-w'.  All other options
     are GNU extensions and are not repeated in this enumeration.
     Moreover, some options have a slightly different meaning when GNU
     extensions are enabled, as explained below.

   * By default, concordance output is not formatted for `troff' or
     `nroff'.  It is rather formatted for a dumb terminal.  `troff' or
     `nroff' output may still be selected through option `-O'.

   * Unless `-R' option is used, the maximum reference width is
     subtracted from the total output line width.  With GNU extensions
     disabled, width of references is not taken into account in the
     output line width computations.

   * All 256 bytes, even ASCII NUL bytes, are always read and processed
     from input file with no adverse effect, even if GNU extensions are
     disabled.  However, System V `ptx' does not accept 8-bit
     characters, a few control characters are rejected, and the tilde
     `~' is also rejected.

   * Input line length is only limited by available memory, even if GNU
     extensions are disabled.  However, System V `ptx' processes only
     the first 200 characters in each line.

   * The break (non-word) characters default to be every character
     except all letters of the underlying character set, diacriticized
     or not.  When GNU extensions are disabled, the break characters
     default to space, tab and newline only.

   * The program makes better use of output line width.  If GNU
     extensions are disabled, the program rather tries to imitate
     System V `ptx', but still, there are some slight disposition
     glitches this program does not completely reproduce.

   * The user can specify both an Ignore file and an Only file.  This
     is not allowed with System V `ptx'.



File: coreutils-ja.info,  Node: tsort invocation,  Prev: ptx invocation,  Up: Operating on sorted files

7.6 `tsort': Topological sort
=============================

`tsort' performs a topological sort on the given FILE, or standard
input if no input file is given or for a FILE of `-'.  For more details
and some history, see *note tsort background::.  Synopsis:

     tsort [OPTION] [FILE]

   `tsort' reads its input as pairs of strings, separated by blanks,
indicating a partial ordering.  The output is a total ordering that
corresponds to the given partial ordering.

   For example

     tsort <<EOF
     a b c
     d
     e f
     b c d e
     EOF

will produce the output

     a
     b
     c
     d
     e
     f

   Consider a more realistic example.  You have a large set of
functions all in one file, and they may all be declared static except
one.  Currently that one (say `main') is the first function defined in
the file, and the ones it calls directly follow it, followed by those
they call, etc.  Let's say that you are determined to take advantage of
prototypes, so you have to choose between declaring all of those
functions (which means duplicating a lot of information from the
definitions) and rearranging the functions so that as many as possible
are defined before they are used.  One way to automate the latter
process is to get a list for each function of the functions it calls
directly.  Many programs can generate such lists.  They describe a call
graph.  Consider the following list, in which a given line indicates
that the function on the left calls the one on the right directly.

     main parse_options
     main tail_file
     main tail_forever
     tail_file pretty_name
     tail_file write_header
     tail_file tail
     tail_forever recheck
     tail_forever pretty_name
     tail_forever write_header
     tail_forever dump_remainder
     tail tail_lines
     tail tail_bytes
     tail_lines start_lines
     tail_lines dump_remainder
     tail_lines file_lines
     tail_lines pipe_lines
     tail_bytes xlseek
     tail_bytes start_bytes
     tail_bytes dump_remainder
     tail_bytes pipe_bytes
     file_lines dump_remainder
     recheck pretty_name

   then you can use `tsort' to produce an ordering of those functions
that satisfies your requirement.

     example$ tsort call-graph | tac
     dump_remainder
     start_lines
     file_lines
     pipe_lines
     xlseek
     start_bytes
     pipe_bytes
     tail_lines
     tail_bytes
     pretty_name
     write_header
     tail
     recheck
     parse_options
     tail_file
     tail_forever
     main

   `tsort' detects any cycles in the input and writes the first cycle
encountered to standard error.

   Note that for a given partial ordering, generally there is no unique
total ordering.  In the context of the call graph above, the function
`parse_options' may be placed anywhere in the list as long as it
precedes `main'.

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

* Menu:

* tsort background::         Where tsort came from.


File: coreutils-ja.info,  Node: tsort background,  Up: tsort invocation

7.6.1 `tsort': Background
-------------------------

`tsort' exists because very early versions of the Unix linker processed
an archive file exactly once, and in order.  As `ld' read each object
in the archive, it decided whether it was needed in the program based
on whether it defined any symbols which were undefined at that point in
the link.

   This meant that dependencies within the archive had to be handled
specially.  For example, `scanf' probably calls `read'.  That means
that in a single pass through an archive, it was important for
`scanf.o' to appear before read.o, because otherwise a program which
calls `scanf' but not `read' might end up with an unexpected unresolved
reference to `read'.

   The way to address this problem was to first generate a set of
dependencies of one object file on another.  This was done by a shell
script called `lorder'.  The GNU tools don't provide a version of
lorder, as far as I know, but you can still find it in BSD
distributions.

   Then you ran `tsort' over the `lorder' output, and you used the
resulting sort to define the order in which you added objects to the
archive.

   This whole procedure has been obsolete since about 1980, because Unix
archives now contain a symbol table (traditionally built by `ranlib',
now generally built by `ar' itself), and the Unix linker uses the
symbol table to effectively make multiple passes over an archive file.

   Anyhow, that's where tsort came from.  To solve an old problem with
the way the linker handled archive files, which has since been solved
in different ways.


File: coreutils-ja.info,  Node: Operating on fields,  Next: Operating on characters,  Prev: Operating on sorted files,  Up: Top

8 フィールド操作
***********************

* Menu:

* cut invocation::           各行の選択した部分を表示する。
* paste invocation::         複数のファイルの各行をマージする。
* join invocation::          共通のフィールドに基づいて行を連結する。


File: coreutils-ja.info,  Node: cut invocation,  Next: paste invocation,  Up: Operating on fields

8.1 `cut': 各行の選択した部分を表示する
=====================================================

`cut' は、各ファイルから各行の一部を選択して、標準出力に書き出す。
ファイルが指定されていない場合や、ファイル名として `-' が指定されて
いる場合は、標準入力を対象とする。

   書式:

     cut OPTION... [FILE]...

   以下のオプション一覧で BYTE-LIST, CHARACTER-LIST, FIELD-LIST と
表記されているものは、コンマで区切られた、1 個以上の数字か範囲 (ダッシュ
で区切られた 2 個の数字) からなるリストである。バイト、文字、フィールド
は 1 から数える。不完全な範囲を指定することもでき、`-M' は `1-M' と同じ
ことであり、`N-' は `N' から行末、あるいは最後のフィールドまでと同じこと
である。リストの要素は、繰り返してもよく、部分的に重なり合ってもよく、
どんな順序で指定してもよい。ただし、入力中の選択した部分が書き出される
のは、読み込まれたときと同じ順序であり、しかも、ただ一度だけである。
(訳注: たとえば、`-f 3,1,3' などと指定することはできるが、出力される
ときは field-1, field-3 の順番であり、field-3 が二度出力されることも
ない。)

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b BYTE-LIST'
`--bytes=BYTE-LIST'
     BYTE-LIST で指定された位置にあるバイトのみを選択して、表示する。
     タブやバックスペースも他の文字と同様に扱う。すなわち、そうした
     ものも 1 バイトを占める。出力用のデリミタ (delimiter、区切りの印)
     が指定されている場合は (`--output-delimiter' の説明を参照)、選択
     されたバイトからなる範囲同士の間にデリミタ文字列を出力する。

`-c CHARACTER-LIST'
`--characters=CHARACTER-LIST'
     CHARACTER-LIST で指定された位置にある文字のみを選択して、表示する。
     現在のところ、`-b' と同じだが、プログラムの国際化が進むと、動作が
     変わることになるだろう。タブやバックスペースも他の文字と同様に扱う。
     すなわち、そうしたものも 1 文字と数える。出力用のデリミタが指定され
     ている場合は (`--output-delimiter' の説明を参照)、選択された文字
     からなる範囲同士の間にデリミタ文字列を出力する。

`-f FIELD-LIST'
`--fields=FIELD-LIST'
     FIELD-LIST で指定されたフィールドのみを選択して、表示する。
     フィールドの区切りは、デフォルトではタブ文字 1 個である。なお、
     `--only-delimited' (`-s') オプションが指定されていない場合は、
     デリミタ文字を全く含まない行も表示する。

     一言言っておくと、`awk' を使えば、もっと洗練されたフィールド処理が
     可能になる。また、`awk' ならデフォルトで、フィールドの区切りに空白
     文字の連続を使用し (すなわち、フィールドの前後から除去し)、さらに、
     行頭と行末の空白を無視してくれるだろう。
          awk '{print $2}'      # 2 番目のフィールドを表示する
          awk '{print $(NF-1)}' # 最後から 2 番目のフィールドを表示する
          awk '{print $2,$1}'   # 最初の 2 フィールドを逆に並べる

     ありそうにないことだが、`awk' が利用できないないとしよう。その場合
     は、`join' コマンドを使って、上記で `awk' がやっているように、空白
     文字を処理することができる。
          join -a1 -o 1.2     - /dev/null # 2 番目のフィールドを表示する
          join -a1 -o 1.2,1.1 - /dev/null # 最初の 2 フィールドを逆に並べる

`-d INPUT_DELIM_BYTE'
`--delimiter=INPUT_DELIM_BYTE'
     `-f' と併せて使うと、入力のフィールド区切りに INPUT_DELIM_BYTE の
     最初のバイトを使用する (デフォルトはタブ)。

`-n'
     マルチバイト文字を分割しない (現在のところ、機能しない)。

`-s'
`--only-delimited'
     `-f' を使うとき、フィールド区切り文字を含まない行の表示をしない。
     通常は、フィールド区切り文字を含まない行は、行全体がそのまま表示
     される。

`--output-delimiter=OUTPUT_DELIM_STRING'
     `-f' と一緒に使った場合は、出力フィールド間が OUTPUT_DELIM_STRING
     で区切られる。`-f' を指定したときのデフォルトは、入力時のデリミタを
     使用することである。`-b' や `-c' を使用して、(フィールドの範囲では
     なく) バイト位置や文字位置の範囲を選択した場合は、選択されたバイト
     の重なり合わない範囲同士の間に OUTPUT_DELIM_STRING が出力される。

`--complement'
     このオプションは GNU の拡張である。`-b', `-c', `-f' オプションで
     選択されたバイト、文字、フィールドを含まない部分を選択して、表示する。
     言い換えれば、そうしたオプションによって指定されたバイトや文字や
     フィールドは「表示しない」ということだ。このオプションは、フィールドが
     たくさんあるとき、そのうちの一部を除いたすべてを表示したい場合に
     便利である。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: paste invocation,  Next: join invocation,  Prev: cut invocation,  Up: Operating on fields

8.2 `paste': 複数のファイルの各行をマージする
=============================================================

`paste' は、指定された各ファイルの行番号が同じ行を、タブ文字を
間にはさんで連結して、標準出力に書き出す。入力ファイルが全く
指定されていない場合や、ファイル名が `-' だった場合は、標準入力が
使用される。

   例を挙げる。

     $ cat num2
     1
     2
     $ cat let3
     a
     b
     c
     $ paste num2 let3
     1       a
     2       b
             c

   書式:

     paste [OPTION]... [FILE]...

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-s'
`--serial'
     各ファイルから 1 行づつ取り出して連結するのではなく、一つの
     ファイルのすべての行をまとめて 1 行に連結する。上の例のデータを
     使用すると、

          $ paste -s num2 let3
          1       2
          a       b       c

`-d DELIM-LIST'
`--delimiters=DELIM-LIST'
     連結する行の区切りに、タブではなく、DELIM-LIST の各文字を順番に
     使用する。DELIM-LIST を使い切ってしまった場合は、最初の文字に
     戻って使用して行く。上記のデータを例に取ると、

          $ paste -d '%_' num2 let3 num2
          1%a_1
          2%b_2
          %c_


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: join invocation,  Prev: paste invocation,  Up: Operating on fields

8.3 `join': 共通のフィールドに基づいて行を結合する
=====================================================================

`join' は、二つの入力ファイルを対象に、同一の共通フィールド (join
field) を持つことで「対」になっている各行を、1 行にまとめて、標準出力
に書き出す。

   書式:

     join [OPTION]... FILE1 FILE2

   FILE1 と FILE2 の片方は `-'、すなわち標準入力であってもよい (両方とも
標準入力は不可)。FILE1 と FILE2 は、共通フィールドに基づいてソートされて
いるべきである。

   通常、ソート順は、`LC_COLLATE' のロケールが規定している照合順序で
ある。`-t' オプションが指定されていない場合は、両ファイルについて
並び方を比較する際、`sort -b' の場合と同様に、共通フィールドの先頭に
ある空白が無視される。また、`--ignore-case' が指定されている場合は、
`sort -f' と同様、共通フィールドでアルファベットの大文字と小文字は
区別されない。

   `sort' の出力を `join' に渡すなら、`sort' と `join' が使用する
ロケールやオプションは首尾一貫していなければならない。`sort -k 1b,1'
のようなコマンドを使用すれば、デフォルトの共通フィールドに基づいて、
ファイルをソートすることができる。しかし、ロケール、共通フィールド、
区切り記号、比較オプションなどにデフォルト以外のものを使用する場合は、
`join' と `sort' の間で矛盾が起きないように、そうしたものを選択
しなければならないのだ。`join -t ''' が指定された場合は、行全体が共通
フィールドとして考慮の対象になるが、これは、sort のデフォルトの動作に
対応している。

   入力のすべての行が対になっている場合は、GNU による拡張が利用できる。
この場合、並んでいる順番は、対になる二つのフィールドが同じであると判断
されるならば、どんな順番でもよい。ただし、並び方の比較を上述のように
行ったとき、二つのフィールドが同じだと判断される場合であり、その場合
のみである。例を挙げよう。

     $ cat file1
     a a1
     c c1
     b b1
     $ cat file2
     a a2
     c c2
     b b2
     $ join file1 file2
     a a1 a2
     c c1 c2
     b b1 b2

   `--check-order' を指定した場合、入力がソートされていないと、エラー
メッセージを出して、実行を中断する。`--nocheck-order' オプションを指定
した場合は、入力がソートされていなくても、エラーメッセージを出すことは
ない。どちらのオプションも指定されていない場合、入力がソートされて
いないと診断されるのは、 片方の入力ファイルにもう一方と対にならない
行が見つかったときだけであり、それも入力ファイルの少なくともどちらかが
空ではないときだけである。 `join' は、入力ファイルがソートされて
いないと診断すると、0 以外のステータスで終了する (従って、そうした
出力は使用しない方がよい)。

   入力ファイルがきちんとソートされていず、しかも、対にならない行を
含む場合に、`--nocheck-order' を指定して、そうしたファイルを `join' で
無理矢理処理しても、何か特定の結果をもたらすことは保証できない。おそらく
出力は、期待に添わないものになるだろう。

   デフォルトの動作は次のようになっている。
   * 共通フィールド (join field) は、各行の最初のフィールドである。

   * 入力の各フィールドは、1 個以上の空白で区切られる。行頭の空白は
     無視される。

   * 出力の各フィールドは、1 個のスペースで区切られる。

   * 各出力行の構成は、共通フィールド、FILE1 の残りのフィールド、 FILE2
     の残りのフィールドの順になる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a FILE-NUMBER'
     FILE-NUMBER (`1' か `2') のファイルに、もう一方のファイルと対に
     ならない行がある場合、通常の出力のほかに、その行も表示する。

`--check-order'
     入力ファイルのどちらかの内容がきちんとした順番になっていないと、
     エラーメッセージを出して、実行に失敗する。

`--nocheck-order'
     入力ファイルの内容がソートされた順番になっているかどうかを、どちらの
     ファイルについてもチェックしない。これが、デフォルトである。

`-e STRING'
     入力では欠けているフィールドを、出力では STRING で補う。すなわち、
     オプション `-1', `-2', `-j', `-o' などを指定したときに、欠けている
     フィールドがそれに当たる。

`--header'
     各入力ファイルの最初の行をヘッダ行と見なす。ヘッダ行も結合され、
     最初の出力行として表示される。`-o' を使って、出力フォーマットを
     指定している場合は、ヘッダ行もそのフォーマットに従って出力される。
     ヘッダ行は、`--check-order' が指定されていても、並び順のチェックを
     受けない。なお、両ファイルのヘッダ行がマッチしない場合は、一番目の
     ファイルのヘッダ・フィールドが使用される。

`-i'
`--ignore-case'
     キーを比較する際、アルファベットの大文字小文字を区別しない。この
     オプションを使用するときは、両方の入力ファイルの行が、同じように
     大文字小文字を区別せず並んでいなければならない。そうした順番で並
     べるには、`sort -f' を使えばよい。

`-1 FIELD'
     ファイル 1 では FIELD 番目のフィールドを共通フィールドとする
     (FIELD は正の整数)。

`-2 FIELD'
     ファイル 2 では FIELD 番目のフィールドを共通フィールドとする
     (FIELD は正の整数)。

`-j FIELD'
     `-1 FIELD -2 FIELD' と等価。

`-o FIELD-LIST'
`-o auto'
     キーワードの `auto' が指定されると、`join' は各ファイルの最初の
     行を元にして、出力フォーマットを推測する。それは、デフォルトの出力
     フォーマットとほぼ同じだが、それに加えて、各行に必ず同数のフィー
     ルドを出力するようにしている。また、欠けているフィールドがあれば、
     `-e' オプションの指定する文字列で補う。余分なフィールドは除去する。

     `auto' が指定されていない場合は、FIELD-LIST のフォーマットに従っ
     て、各出力行を構成する。FIELD-LIST の各要素は、`0' 一文字か、M.N
     という形を取る。ここで、M はファイル番号であり、`1' か `2' である。
     N はフィールド番号であり、正の整数である。

     `0' というフィールド指定は、共通フィールドを指している。ほとんどの
     場合、`0' というフィールド指定と同じことが、共通フィールドを明示的
     に M.N で示すことでも、実現できるだろう。しかしながら、(`-a' オプ
     ションなり `-v' オプションなりを使用して)、対にならない行を表示
     する場合、対にならない行が両方のファイルに存在すると、FIELD-LIST で
     M.N をどう使おうと、共通フィールドを指定できないのだ。`join' で共通
     フィールドの指定が常に可能になるように、POSIX は `0' というフィー
     ルド指定法を考案したのである。

     FIELD-LIST の各要素は、コンマ、または空白で区切られる。区切りに空白
     を使用するときは、シェルによって解釈されないように、たいていの場合
     引用符で囲む必要がある。たとえば、コマンド `join -o 1.2,2.2' と
     `join -o '1.2 2.2'' は、同じ動作になる。

     FIELD-LIST の指定は、すべての出力行に適用される。これは、`-a' や
     `-v' オプションによって、出力されるものにも当てはまる。

`-t CHAR'
     入出力のフィールドの区切りに、文字 CHAR を使用する。CHAR は、入力
     ファイルに現れる一つ一つが、有意なものとして扱われる。`sort -t
     CHAR' を `-b' なしで実行すれば、このオプションに対応する順序に行を
     並べることができる。`join -t ''' を指定すると、行全体が共通フィー
     ルドとして考慮の対象になり、これは sort のデフォルトの動作に対応
     する。`-t '\0'' を指定すると、ASCII NUL 文字がフィールドの区切りに
     使用される。

`-v FILE-NUMBER'
     通常の出力はせず、FILE-NUMBER (`1' か `2' である) のファイルに存在
     する、対にならない各行を表示する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Operating on characters,  Next: Directory listing,  Prev: Operating on fields,  Up: Top

9 文字操作
**************

以下のコマンドは、個々の文字に対して操作を行う。

* Menu:

* tr invocation::            文字の置換、圧縮、削除を行う。
* expand invocation::        タブをスペースに変換する。
* unexpand invocation::      スペースをタブに変換する。


File: coreutils-ja.info,  Node: tr invocation,  Next: expand invocation,  Up: Operating on characters

9.1 `tr': 文字の置換、圧縮、削除を行う
====================================================

書式:

     tr [OPTION]... SET1 [SET2]

   `tr' は標準入力を標準出力にコピーする際に、次の操作の一つを行う。

   * 文字を置換する。置換した結果に同一文字の連続があるときは、それを 1
     文字に圧縮することもできる。

   * 同一文字の連続を 1 文字に圧縮する。

   * 文字を削除する。

   * 文字を削除する。さらに、削除した結果に同一文字の連続があるときは、
     それを 1 文字に圧縮する。

   上記書式の SET1 と (もし、指定しているなら) SET2 の二つの引数には、
順序が意味を持つ文字の集合を指定する。以下の説明で、それぞれ SET1、SET2
と呼ばれることになるそうした文字集合こそ、入力中に存在する文字のうちで
`tr' が操作の対象とする文字群である。`--complement' (`-c', `-C')
オプションを指定すると、SET1 の代わりにその補集合 (SET1 に含まれない
すべての文字) が使われることになる。

   現在のところ、`tr' が完全に対応しているのは、シングルバイト文字
だけである。将来は、マルチバイト文字もサポートすることになるだろうが、
そのときは、`-C' オプションで文字集合の補集合を作り、`-c' オプションで
値 (訳注: いわゆる文字コード) の集合の補集合を作ることになるだろう。
この区別が意味を持つのは、指定する値の中に文字ではないものがあるとき
だけだが、そういった事態は、マルチバイト・エンコーディングを使用して
いるロケールで、入力にエンコーディング・エラーが含まれるときしか起き
そうにない。

   このプログラムでは、`--help' や `--version' オプションも使える。
*Note Common options::. なお、オプションは、オペランドの前で指定しなけ
ればならない。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

* Menu:

* Character sets::           文字集合の指定。
* Translating::              ある文字集合の別の文字集合への変換。
* Squeezing::                連続する同一文字の圧縮と文字の削除。


File: coreutils-ja.info,  Node: Character sets,  Next: Translating,  Up: tr invocation

9.1.1 文字集合の指定
---------------------------

SET1 や SET2 引数の書式は、正規表現の書式に似ているが、正規表現では
なく、文字のリストにすぎない。そうした文字列中のほとんどの文字は、単に
その文字自身を表しているだけだが、便宜のため文字列中では以下に列挙する
簡易記法も使うことができる。簡易記法によっては、以下で述べているように、
SET1 と SET2 のどちらか一方でしか使えないこともある。

バックスラッシュ・エスケープ
     以下のバックスラッシュ・エスケープ・シーケンスを認識する。

    `\a'
          Control-G (ベル).

    `\b'
          Control-H (バックスペース).

    `\f'
          Control-L (フォームフィード).

    `\n'
          Control-J (改行).

    `\r'
          Control-M (復帰).

    `\t'
          Control-I (水平タブ).

    `\v'
          Control-K (垂直タブ).

    `\OOO'
          1 から 3 桁の 8 進数 OOO によって表される値を持つ 8 ビット
          文字。`\400' は、`\040' `0' という連続する 2 バイトに解釈
          されるので、注意すること。

    `\\'
          1 個のバックスラッシュ。

     上記以外の 1 個の文字がバックスラッシュに続く場合は、その文字
     として解釈される。またバックスラッシュには、特別な意味を打ち消す
     働きもあるので、`[', `]', `*', `-' をエスケープするのにも使用
     できる。

範囲指定
     `M-N' という表記は、昇順で M から N までのすべての文字に展開され
     る。M は照合順序で N より前のものでなければならず、さもないと、
     エラーになる。たとえば、`0-9' は `0123456789' と同じである。

     System V の書式では、角カッコ (square brackets）を使って範囲を囲む
     ことになっているが、GNU の `tr' はこの書式をサポートしていない。
     System V の書式で指定した場合でも、置換が期待どおり行われることも
     あるが、それは、角カッコが角カッコに置換されることがしばしばある
     からだ。そうだとしても、予想外の動作をすることもあるので、角カッコ
     の使用は避けた方がよい。たとえば、`tr -d '[0-9]'' は、数字だけで
     なく、角カッコも削除してしまう。

     昔からよく使われている範囲の指定法の多くが -- 正しい用法として
     認められているものでさえ -- 他のシステムで使えるとはかぎらない。
     たとえば、EBCDIC のホストでは、 `A-Z' という範囲の指定をしても、
     たいていの人が予想するような結果は得られないだろう。なぜなら、
     そこでは `A' から `Z' までが、ASCII におけるように隣り合っては
     いないからである。POSIX 準拠の `tr' を使うことができるならば、
     この問題を回避する最善の方法は、文字クラスを使用することである
     (下記参照)。それができない場合は、範囲の要素を一つ一つ書き込むのが、
     一番可搬性のある方法だ (一番野暮ったい方法でもあるけれど)。

文字の繰り返し
     SET2 における `[C*N]' という表記は、文字 C の N 個の連続に展開
     される。従って、`[y*6]' は `yyyyyy' と同じである。また、SET2 に
     おける `[C*]' という表記は、SET2 を SET1 と同じ長さにするのに
     必要な数の C の連続に展開される。N が `0' で始まっている場合は、 8
     進数として扱われる。それ以外の場合は、10 進数である。

文字クラス
     `[:CLASS:]' という表記は、(あらかじめ定義されている) 文字クラス
     CLASS に属するすべての文字に展開される。展開された文字に特定の
     順序はないが、`upper' と `lower' の文字クラスは別で、この二つは、
     昇順に展開される。`--delete' (`-d') と `--squeeze-repeats' (`-s')
     オプションの両方を指定している場合は、SET2 でどんな文字クラスでも
     使用することができる。それ以外の場合、SET2 で使えるのは、`lower'
     と `upper' の文字クラスだけであり、それも、対応する文字クラスを
     (すなわち、`upper' に対しては `lower'、`lower' に対しては `upper'
     を)、SET1 の対応する位置で指定しているときだけである。その場合は、
     大文字小文字の変換を指定していることになるわけだ。以下に文字クラス
     の名前を列挙する。なお、無効なクラス名を指定すると、エラーになる。

    `alnum'
          アルファベットの文字と数字。

    `alpha'
          アルファベットの文字。

    `blank'
          水平方向の空白 (Horizontal whitespace)。

    `cntrl'
          制御文字。

    `digit'
          数字。

    `graph'
          表示可能文字。空白を含まない (訳注: スペースもタブも改行も、
          すなわち、ホワイトスペースを一切含まない)。

    `lower'
          アルファベットの小文字。

    `print'
          表示可能文字。空白を含む (訳注: タブや改行は含まないが、
          スペース (0x20) は含む)。

    `punct'
          句読点。

    `space'
          水平方向や垂直方向の空白 (Horizontal or vertical whitespace)。

    `upper'
          アルファベットの大文字。

    `xdigit'
          16 進数の数字。

等価クラス
     `[=C=]' という書式は、C と等価な文字のすべてに展開される。
     展開される文字の間に特定の順序はない。等価クラスは、比較的最近の
     発明であり、英語以外のアルファベットをサポートするためのものである。
     しかしながら、等価クラスを定義したり、何が等価クラスに含まれるかを
     決定したりする標準的な方法は存在しないようだ。そのため、GNU の
     `tr' は、等価クラスを十分に実装していない。各文字の等価クラスには
     その文字しか含まれていないので、あまり使い道がない。



File: coreutils-ja.info,  Node: Translating,  Next: Squeezing,  Prev: Character sets,  Up: tr invocation

9.1.2 置換
------------

`tr' は、SET1 と SET2 の両方が指定され、`--delete' (`-d') オプションが
指定されていない場合は、文字の置換を行う。`tr' は入力の中に SET1 に存在
する文字が現れるたびに、それを SET2 の対応する文字に置き換える。入力中の
SET1 に存在しない文字は、読み飛ばして、変更しない。ある文字が SET1 中に
2 個以上存在し、SET2 中のそれに対応する文字がすべて同じでない場合、置換
に使用するのは、最後の文字だけである。たとえば、次の二つのコマンドは、
同じ動作をする。

     tr aaa xyz
     tr a z

   `tr' がよく使われるのは、アルファベットの小文字を大文字に変換する
ときである。それには、いろいろな方法がある。例を三つほど挙げてみる。

     tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
     tr a-z A-Z
     tr '[:lower:]' '[:upper:]'

ただし、上記の `a-z' のような範囲指定の使用は、可搬性がないことに
注意していただきたい。

   `tr' で置換を行う際には、普通 SET1 と SET2 を同じ長さにする。SET1 が
SET2 より短いと、SET2 の後尾にある余分な文字が無視されることになる。

   逆に、SET1 が SET2 より長い場合は、可搬性がなくなる。POSIX の規定で
は、結果は未定義なのだ。こうした場合、BSD の `tr' は、SET2 の最後の
文字を必要なだけ繰り返して、SET2 が SET1 と同じ長さになるようにする。
System V の `tr' は、SET1 を SET2 と同じ長さに切り詰める。

   デフォルトでは、GNU 版の `tr' は、この問題を BSD の `tr' と同じ
やり方で処理する。そして、`--truncate-set1' (`-t') オプションが指定
されている場合は、System V の `tr' のように処理するのである。このオプ
ション (`--truncate-set1') は、置換以外の操作では無視される。

   この問題で System V の `tr' の動作を選ぶと、比較的よく使われる、 BSD
式の次の慣用表現が使えなくなる。

     tr -cs A-Za-z0-9 '\012'

なぜなら、System V の動作では、アルファベットと数字以外のすべての文字を
改行文字に変換するのではなく、ゼロバイトしか (ASCII NUL 文字、それが
SET1 の補集合の最初の要素である) 改行文字に変換しないからだ。

ちなみに、上記の慣用表現は、システムによってはうまく動作しない。
なぜなら、範囲指定を使っているからであり、また、改行の 8 進数による
コードを 012 と決め込んでいるからである。`tr' が POSIX に準拠している
なら、以下の方が、よりよい書き方である。

     tr -cs '[:alnum:]' '[\n*]'


File: coreutils-ja.info,  Node: Squeezing,  Prev: Translating,  Up: tr invocation

9.1.3 連続する文字の圧縮と文字の削除
---------------------------------------------------

`--delete' (`-d') オプションのみが指定された場合、`tr' は、SET1 に
存在する文字が入力中にあれば、それを削除する。

   `--squeeze-repeats' (`-s') オプションのみが指定された場合、`tr' は、
SET1 に存在する文字が入力中に連続して現れるたびに、その部分をただ 1 個
のその文字に置き換える。

   `--delete' と `--squeeze-repeats' の両方が指定された場合、`tr' は、
まず SET1 を使って削除を行い、その後で、残っている文字に対して、 SET2
を使って連続する同一文字の圧縮を行う。

   `--squeeze-repeats' オプションは、置換の際に使用することもできる。
その場合、`tr' は、まず置換を実行し、その後で、置換結果に対して、 SET2
を使って連続する同一文字の圧縮を行う。

   例をいくつか挙げて、オプションの様々な組み合わせを説明する。

   * すべてのゼロバイトを削除する。

          tr -d '\0'

   * 入力中のすべての単語 (訳注: 空白などで前後を区切られた文字列) を 1
     行に 1 個づつ書き出す。このコマンドは、アルファベットと数字以外の
     すべてを改行文字に変換し、さらに、改行が連続して現れるそれぞれの
     箇所を 1 個の改行文字に圧縮している。

          tr -cs '[:alnum:]' '[\n*]'

   * 連続する改行文字が現れるごとに、それを一個の改行文字に変換する。

          tr -s '\n'

   * 文書中の単語の重複を探し出す。たとえば、 改行を挟んで同じ単語を
     繰り返して、"the the" のように書いてしまうとことは、よくあること
     である。以下の Bourne シェルのスクリプトは、次のように動作する。
     まず、句読点や空白文字が 1 個以上続けて現れるたびに、それを 1 個の
     改行文字に置き換える。そうすることで、単語が 1 行に 1 個づつ
     出力されることになるわけだ。次には、すべての大文字を小文字に
     変換する。そして、最後に、`uniq' を `-d' オプション付きで実行して、
     重複した単語のみを書き出すのである。

          #!/bin/sh
          cat -- "$@" \
            | tr -s '[:punct:][:blank:]' '[\n*]' \
            | tr '[:upper:]' '[:lower:]' \
            | uniq -d

   * 文字のちょっとした集団を削除するのは、たいていの場合ごく簡単
     である。たとえば、`a', `x', `M' という文字をすべて消すには、次の
     ようにするだけでよい。

          tr -d axM

     ところが、削除する文字の一つに  `-' があると、`-' は特殊な意味を
     もっているので、厄介なことになりかねない。上記と同様の作業を行う
     けれど、今度は `-' という文字もついでにすべて削除するとしよう。
     `tr -d -axM' をやってみるかもしれないが、うまく行かないだろう。
     `tr' が `-a' をコマンドライン・オプションとして解釈しようとする
     からである。それではと、ハイフンを文字列の内側に入れてみることも
     できる。`tr -d a-xM' のようにだ。だが、これもうまく行きそうにない。
     `tr' が `a-x' を 3 個の文字としてではなく、`a'...`x' という文字の
     範囲として解釈することになるからだ。この問題を解決する方法の一つは、
     ハイフンを文字のリストの最後に置くことである。

          tr -d axM-

     あるいは、`--' を使って、オプション処理はここで終わりと明示する
     こともできる。

          tr -d -- -axM

     より普遍的な方法は、等価クラスの記法  `[=c=]' を、`c' を `-' で
     (あるいは、他の任意の文字で) 置き換えて使うことである。

          tr -d '[=-=]axM'

     上記の例では、角カッコがシェルによって解釈されないように、シングル
     クォートを使っていることに注意していただきたい。



File: coreutils-ja.info,  Node: expand invocation,  Next: unexpand invocation,  Prev: tr invocation,  Up: Operating on characters

9.2 `expand': タブをスペースに変換する
==================================================

`expand' は指定された各 FILE の内容を標準出力に書き出し、その際に
タブ文字を適切な数のスペースに変換する。FILE が指定されていない
場合や、FILE として `-' が指定されている場合は、標準入力を対象にする。

   書式:

     expand [OPTION]... [FILE]...

   デフォルトでは、`expand' はすべてのタブをスペースに変換する。
バックスペース文字は、出力にそのまま残しておく。バックスペースには、
タブ幅を計算する際に、桁数を減らす働きがあるのだ。デフォルトの動作は、
`-t 8' を指定したときと同じである (タブ位置を 8 桁ごとにする)。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-t TAB1[,TAB2]...'
`--tabs=TAB1[,TAB2]...'
     タブ位置 (tab stop) が一つだけ指定された場合には、(訳注: 入力行に
     おける) タブ位置を TAB1 桁ごとにする (デフォルトは 8 桁ごと)。
     それ以外の場合は、タブ位置を TAB1, TAB2, ... 桁目に置き (行頭を 0
     桁目として数える)、指定された最後のタブ位置より後ろにあるタブは 1
     個のスペースで置き換える。タブ位置の指定は、コンマで区切っても
     よく、空白で区切ってもよい。

     互換性を考慮して、GNU の `expand' は、`-TAB1[,TAB2]...' という、
     このオプションの古い書式も認めている。新しいスクリプトでは、 `-t
     TAB1[,TAB2]...' の方を使うべきである。

`-i'
`--initial'
     各行の行頭にあるタブ群だけを (言い換えれば、スペースでもタブでも
     ないどんな文字よりも前にある 1 個以上のタブだけを) スペースに変換
     する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: unexpand invocation,  Prev: expand invocation,  Up: Operating on characters

9.3 `unexpand': スペースをタブに変換する
====================================================

`unexpand' は、指定された各 FILE の内容を標準出力に書き出し、その際に
各行の先頭にある複数の空白 (blank) を、必要な数のタブ文字に変換する。
FILE が指定されていない場合や、FILE として `-' が指定されている場合は、
標準入力を対象にする。デフォルトの POSIX ロケールでは、空白 ("blank")
とは、スペースかタブのことである。他のロケールでは、ほかの空白文字が
追加されているかもしれない。

   書式:

     unexpand [OPTION]... [FILE]...

   デフォルトでは、`unexpand' が変換するのは、各行の行頭にある複数の
空白だけである (言い換えれば、空白以外のどんな文字よりも前にある複数
の空白だけ)。バックスペース文字は、出力にそのまま残しておく。バック
スペースには、タブ幅を計算する際に、桁数を減らす働きがあるのだ。
デフォルトでは、タブ位置は 8 桁ごとに置かれる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-t TAB1[,TAB2]...'
`--tabs=TAB1[,TAB2]...'
     タブ位置 (tab stop) が一つだけ指定された場合には、(訳注: 入力行に
     おける) タブ位置をデフォルトの 8 桁ごとではなく、TAB1 桁ごとに
     設定する。それ以外の場合は、タブ位置を TAB1, TAB2, ... 桁目に置き
     (行頭を 0 桁目として数える)、指定された最後のタブ位置より後ろに
     ある空白は、変換せず、そのままにする。タブ位置の指定は、コンマで
     区切ってもよく、空白で区切ってもよい。このオプションを指定すると、
     `-a' オプションが自動的に設定される。

     (訳注: 一例を挙げておく。たとえば、`-t 8,12' なら、入力行は、先頭を
     0 桁目として、8 桁目、12 桁目にタブ位置があると見なされる。そこで、
     先頭に 12 個のスペースがある行に対して `unexpand -t 8,12' を行う
     と、空白がタブ 2 個に変換される。出力におけるタブ位置はデフォルトの
     ままなので、出力ではその行は、 0 から数えて 16 桁目から文字が始まる
     ことになる。)

     互換性を考慮して、GNU の `unexpand' は、`-TAB1[,TAB2]...' という、
     このオプションの古い書式も認めている。そちらを使う場合は、タブ位置を
     必ずコンマで区切らなければならない。なお、`-t' とは違って、この古い
     オプションは、`-a' を自動的に設定しない。新しいスクリプトでは
     (訳注: 古い書式と同じ動作をさせたいなら)、古い書式に代えて、
     `--first-only -t TAB1[,TAB2]...' を使うべきである。

`-a'
`--all'
     空白の連続が、行の中で空白以外の文字の後ろにある場合でも、タブ位置の
     直前にある 2 個以上の空白の連続は、すべて変換する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Directory listing,  Next: Basic operations,  Prev: Operating on characters,  Up: Top

10 ディレクトリの一覧表示
************************************

この章では、`ls' とその変種の `dir' 及び `vdir' について説明する。
こうしたコマンドは、ファイルに関する情報を一覧表示する。

* Menu:

* ls invocation::            ディレクトリの内容を一覧表示する。
* dir invocation::           簡潔な ls。
* vdir invocation::          詳細な ls。
* dircolors invocation::     ls のカラー設定など。


File: coreutils-ja.info,  Node: ls invocation,  Next: dir invocation,  Up: Directory listing

10.1 `ls': ディレクトリの内容を一覧表示する
===========================================================

`ls' プログラムはファイルに関する情報を一覧表示する (ファイルは、
いかなるタイプでもよく、ディレクトリでもよい)。オプションとファイルを
示す引数は、ほとんどのコマンドと同様、どんな順番で指定しても構わない。

   オプション以外のコマンドライン引数がディレクトリである場合、
デフォルトでは、`ls' はそのディレクトリの内容を一覧表示する。
その際、再帰的な表示はせず、名前が `.' で始まるファイルも表示
しない。オプションではない他の引数に対しては、単にファイル名だけを
表示するのが、`ls' のデフォルトの動作である。オプション以外の引数が
一つも指定されていない場合は、`ls' はカレントディレクトリを対象にし、
あたかも `.' という引数を一つだけ付けて起動したかのように動作する。

   デフォルトでは、出力を、現在のロケール設定に従って、アルファベット
順でソートする (1)。 標準出力が端末の場合は、出力を段組みで (訳注:
すなわち、1 行に複数ファイルの形式で) 表示し (ソートは縦方向に行う)、
制御文字を疑問符として出力する。それ以外の場合は、出力が 1 行 1 ファイル
の形式になり、制御文字はそのまま手を加えずに出力する。

   `ls' はきわめて基本的なプログラムなので、長年の間にオプションが
どんどん増えてしまった。以下のサブセクションでは、そうしたオプション
について説明している。各セクション内では、オプションを (大文字小文字
を無視して) アルファベット順に並べている。このようにオプションをサブ
セクションに分けてみたが、この分類法が絶対的なものだと言うつもりは
ない。オプションの中には、`ls' の動作の複数の側面に作用するものも
あるからである。

   終了ステータス:

     0: 成功
     1: 軽微な問題 (たとえば、コマンドライン引数として指定されていない
        ファイルやディレクトリにアクセスできなかった場合。ディレクトリの
        内容を一覧表示しようとしたとき、その中にあるエントリが今まさに
        削除やリネームの最中だと、そういうことが起きる)
     2: 深刻なトラブル (たとえば、メモリの不足、無効なオプション、
        コマンドライン引数として指定されたファイルやディレクトリに
        アクセスできなかった場合、ディレクトリのループなど)

   参照 *note Common options::.

* Menu:

* Which files are listed::          表示対象にするファイル。
* What information is listed::      表示する情報。
* Sorting the output::              出力のソート。
* Details about version sort::      バージョン・ソートの詳細。
* General output formatting::       出力全体の形式。
* Formatting file timestamps::      タイムスタンプのフォーマット。
* Formatting the file names::       ファイル名のフォーマット。

   ---------- Footnotes ----------

   (1) POSIX 以外のロケールを使用している場合は (たとえば、`LC_ALL' を
`en_US' に設定している場合は)、`ls' の出力が、見慣れない順序で並んで
いるかもしれない。そうした場合は、環境変数 `LC_ALL' を `C' にしてみる
とよい。


File: coreutils-ja.info,  Node: Which files are listed,  Next: What information is listed,  Up: ls invocation

10.1.1 表示対象にするファイル
----------------------------------------

以下のオプションは、どんなファイルについて `ls' が情報を表示するか
を決定する。デフォルトで `ls' が表示するのは、コマンドラインで指定
されたファイルだが、ディレクトリが指定された場合は、その内容になる。
ただし、ディレクトリの内容のうち、名前が `.' で始まるファイルは表示
しない。

`-a'
`--all'
     ディレクトリの内容を表示する際、`.' で始まるファイル名も無視
     しない。

`-A'
`--almost-all'
     ディレクトリの内容を表示する際、`.' と `..' は無視するが、
     それ以外の `.' で始まるいかなるファイル名も無視しない。`--all'
     (`-a') オプションは、このオプションに優先する。

`-B'
`--ignore-backups'
     ディレクトリの内容表示において、`~' で終わるファイルを無視する。
     このオプションは、`--ignore='*~' --ignore='.*~'' と同じである。

`-d'
`--directory'
     ディレクトリについても、ディレクトリ内容の一覧ではなく、他のタイプ
     のファイルの場合と同じように、名前だけを表示する。また、
     `--dereference-command-line' (`-H'), `--dereference' (`-L'),
     `--dereference-command-line-symlink-to-dir' といったオプションが
     指定されていないかぎり、コマンドラインでシンボリック・リンクが指定
     されても、それをたどらない。

`-H'
`--dereference-command-line'
     コマンドライン引数がシンボリック・リンクを指定している場合、リンク
     そのものではなく、リンクが参照しているファイルの情報を表示する。

`--dereference-command-line-symlink-to-dir'
     原則としてシンボリックリンクの参照を行わないが、一つだけ例外が
     ある。すなわち、コマンドライン引数がシンボリック・リンクを指定し、
     それがディレクトリを指している場合は、リンクそのものではなく、
     そのディレクトリの情報を表示する。この動作は、リンクの参照に関係
     する他のオプションが全く指定されていないときの、`ls' のデフォルトの
     動作である (リンクの参照に関係する他のオプションには、`--classify'
     (`-F'), `--directory' (`-d'), `-l', `--dereference' (`-L'),
     `--dereference-command-line' (`-H') がある)。

`--group-directories-first'
     すべてのディレクトリをまとめてファイルの前に置き、その上で、選択
     したソート・キーを使って (`--sort' オプション参照)、ディレクトリと
     ファイルをそれぞれ別々にソートする。別の言い方をすると、このオプ
     ションはソートする際の主キーを設定し、`--sort' オプションが副キー
     を設定するということだ。ただし、`--sort=none' (`-U') を使ったり
     すると、このオプションは全く無効になる。

`--hide=PATTERN'
     ディレクトリの内容表示において、`--all' (`-a') や `--almost-all'
     (`-A') が同時に指定されていないかぎり、シェルのパターン PATTERN
     に名前がマッチするファイルを無視する。このオプションの動作は、
     `--ignore=PATTERN' とほぼ同じだが、`--all' (`-a') や `--almost-all'
     (`-A') が併せて指定されていると、効果がないという点が違う。

     このオプションは、シェルのエイリアスで使うと、便利かもしれない。
     たとえば、`lx' が `ls --hide='*~'' のエイリアスで、`ly' は `ls
     --ignore='*~'' のエイリアスだとしよう。その場合、`lx -A' という
     コマンドは、ファイル `README~' を表示するが、`ly -A' は表示しない
     ことになる。

`-I PATTERN'
`--ignore=PATTERN'
     ディレクトリの内容表示において、シェルのパターン (正規表現ではない)
     PATTERN に名前がマッチするファイルを無視する。シェルの場合と同様、
     ファイル名の先頭にある `.' は PATTERN の先頭のワイルドカードに
     マッチしない。このオプションを二度以上使うと、便利なことがある。
     たとえば、

          $ ls --ignore='.??*' --ignore='.[^.]' --ignore='#*'

     最初のオプションは `.' で始まる 3 文字以上のファイル名を無視する。
     二番目のオプションは `.' で始まる二文字のファイル名のうち、 `..'
     を除くすべて無視し、三番目のオプションは `#' で始まるファイル名を
     無視する。

`-L'
`--dereference'
     シンボリックリンクについてファイル情報を表示する際、リンクそのもの
     ではなく、リンクが参照しているファイルの情報を表示する。とは言え、
     このオプションを使用した場合でも、表示されるファイル名については、
     リンクそのものの名前のままであり、リンクが指しているファイルの名前
     にはならない。

`-R'
`--recursive'
     すべてのディレクトリの内容を再帰的に一覧表示する。



File: coreutils-ja.info,  Node: What information is listed,  Next: Sorting the output,  Prev: Which files are listed,  Up: ls invocation

10.1.2 表示する情報
-------------------------

以下のオプションは、`ls' がどんな情報を表示するかに関係している。 `ls'
がデフォルトで表示するのは、ファイル名だけである。

`--author'
     詳細形式でディレクトリ内容のリストを出力する際、各ファイルの作成者
     情報を表示する。GNU/Hurd では、ファイルの作成者 (author) はファイル
     の所有者 (owner) と別人であることがあるが、他のオペレーティング・
     システムでは、両者は同一である。

`-D'
`--dired'
     詳細表示形式 (`-l') と併せて使用すると、出力本体の後ろに以下の
     ような追加の行を表示する。

          //DIRED// BEG1 END1 BEG2 END2 ...

     BEGN や ENDN は符号なしの整数であり、出力における各ファイル名の
     開始バイト位置と終了バイト位置を示している。このようにすることで、
     ファイル名に空白や改行のような普段使わない文字が含まれている場合
     でも、手の込んだ検索をするまでもなく、Emacs で簡単にファイル名が
     見つかるようにしているのである。

     ディレクトリを再帰的にリストしている場合には (`-R')、
     各サブディレクトリ名のオフセットを記した同様の行も出力する。

          //SUBDIRED// BEG1 END1 ...

     そして最後に、次の形式の行を出力する。

          //DIRED-OPTIONS// --quoting-style=WORD

     ここで、WORD はクォートの方式である (*note Formatting the file
     names::)。

     実例を挙げてみる。

          $ mkdir -p a/sub/deeper a/sub2
          $ touch a/f1 a/f2
          $ touch a/sub/deeper/file
          $ ls -gloRF --dired a
            a:
            total 8
            -rw-r--r-- 1    0 Jun 10 12:27 f1
            -rw-r--r-- 1    0 Jun 10 12:27 f2
            drwxr-xr-x 3 4096 Jun 10 12:27 sub/
            drwxr-xr-x 2 4096 Jun 10 12:27 sub2/

            a/sub:
            total 4
            drwxr-xr-x 2 4096 Jun 10 12:27 deeper/

            a/sub/deeper:
            total 0
            -rw-r--r-- 1 0 Jun 10 12:27 file

            a/sub2:
            total 0
          //DIRED// 48 50 84 86 120 123 158 162 217 223 282 286
          //SUBDIRED// 2 3 167 172 228 240 290 296
          //DIRED-OPTIONS// --quoting-style=literal

     上記 `//DIRED//' 行の 2 個づつ組になっているオフセットは、次の 6
     個の名前の区切りとなるバイト位置を示している (訳注: 別の言い方を
     するなら、出力の先頭からある名前の直前までのバイト数と、その名前の
     最後の文字までのバイト数を示している)。6 個の名前とは、すなわち
     `f1', `f2', `sub', `sub2', `deeper', `file' である。`//SUBDIRED//'
     の行のオフセットが示しているのは、次のディレクトリ名の区切りである。
     `a', `a/sub', `a/sub/deeper', `a/sub2'。

     下記の例では、5 番目の項目の名前 `deeper' を抜き出してみせている。
     この項目の名前は、217 と 223 のオフセットの組に対応している。

          $ ls -gloRF --dired a > out
          $ dd bs=1 skip=217 count=6 < out 2>/dev/null; echo
          deeper

     上記のファイル一覧表示では、`deeper' という項目の後ろにスラッシュ
     が付いているが、オフセットが名前として選択しているのは、後ろの
     スラッシュを除いた部分であることに注目していただきたい。しかしながら、
     `ls' を `--dired' とともに `--escape' (短縮形は `-b') のような
     オプションを付けて実行し、名前に特殊文字が入っているファイルを処理の
     対象にする場合には、バックスラッシュがオフセットの示す範囲のうちに
     含まれることに注意しなければならない。

          $ touch 'a b'
          $ ls -blog --dired 'a b'
            -rw-r--r-- 1 0 Jun 10 12:28 a\ b
          //DIRED// 30 34
          //DIRED-OPTIONS// --quoting-style=escape

     引用符を付加するクォート方式を使用している場合には (たとえば、
     `--quoting-style=c')、引用符もオフセットの示す範囲に含まれる。
     そこで、気をつけるべきことがある。ユーザが環境変数 `QUOTING_STYLE'
     を設定して、そうしたクォート方式を選択しているかもしれないのだ。
     従って、`--dired' を使用するアプリケーションでは、コマンドラインで
     明示的に `--quoting-style=literal' オプションを指定するか (`-N' や
     `--literal' オプションでも同じこと)、あるいは、エスケープされた
     名前を解析できるするようにしておくか、どちらかをするべきだという
     ことになる。

`--full-time'
     詳細形式でディレクトリ内容のリストを生成し、日時の情報を省略なしで
     表示する。これは、`--format=long' を `--time-style=full-iso' と
     一緒に使うのと同じである (*note Formatting file timestamps::)。

`-g'
     詳細形式でディレクトリ内容のリストを生成するが、所有者情報は表示しない。

`-G'
`--no-group'
     詳細形式でディレクトリ内容をリスト表示するとき、グループ情報を
     表示しない (GNU 版以外の `ls' には、この動作がデフォルトの
     ものがある。そこで、互換性のために、このオプションを用意している)。

`-h'
`--human-readable'
     各サイズの後ろに、メビバイトなら `M' といった、大きさを示す文字を
     付ける。1000 ではなく、1024 の累乗が使われるので、`M' は 1,048,576
     バイトを表している。このオプションは、`--block-size=human-readable'
     と同じである。1000 の累乗が使いたければ、"`--si' オプションを使用
     すればよい。

`-i'
`--inode'
     ファイル名の左側にそのファイルの inode 番号を表示する (inode
     番号は、ファイル連続番号とか、インデックスナンバーとも呼ばれる。
     この番号は、ある特定のファイルシステムにある各ファイルを、一意に
     指し示す)。

`-l'
`--format=long'
`--format=verbose'
     各ファイルの名前のほかに、ファイルのタイプ、ファイルのモードビット
     (訳注: 一般に「アクセス権」とか「許可属性」と言われるもの)、
     ハードリンク数、所有者名、グループ名、サイズ、タイムスタンプを
     表示する (*note Formatting file timestamps::)。タイムスタンプは、
     通常は更新日時 (訳注: いわゆる mtime) である。特定することの
     できない情報については、疑問符を表示する。

     通常、サイズは、桁を区切る記号を付けずに、バイト数で表示されるが、
     この表示法は変更することができる (*note Block size::)。たとえば、
     `-h' オプションを指定すると、人間に読みやすい短縮表示になり、
     `--block-size="'1"' を指定すると、現在のロケールの区切り記号で 3
     桁ごとに区切ったバイト数が表示される。

     ディレクトリの内容をリストする場合は、対象となるディレクトリ
     ごとに、ファイルのリストの前に `total BLOCKS' という行を置く。
     ここで、BLOCKS は、そのディレクトリにあるすべてのファイルに
     割り当てられたディスク容量の合計である。現在のところブロック
     サイズはデフォルトでは 1024 バイトであるが、この値は変更する
     ことができる (*note Block size::)。BLOCKS の計算では、
     各ハードリンクを別のものとして計算している。これはバグだと
     言えないこともない。

     ファイルタイプには、以下の文字の一つが使われる。

    `-'
          通常ファイル

    `b'
          ブロック・スペシャルファイル

    `c'
          キャラクタ・スペシャルファイル

    `C'
          ハイパフォーマンス ("contiguous data") ファイル

    `d'
          ディレクトリ

    `D'
          ドア (Solaris 2.5 以上)

    `l'
          シンボリックリンク

    `M'
          オフライン ("migrated") ファイル (Cray DMF)

    `n'
          ネットワーク・スペシャルファイル (HP-UX)

    `p'
          FIFO (名前付きパイプ)

    `P'
          ポート (Solaris 10 以上)

    `s'
          ソケット

    `?'
          上記以外のファイルタイプ

     ファイルのモードビットの表示は、アクセス権を設定する際のシンボ
     リックモードの仕様とほとんど同じである (*note Symbolic Modes::)。
     ただし、`ls' は、以下のように、モードを表す複数のビットを一つに
     まとめて、アクセス権の各セットの 3 番目の文字で表現している。

    `s'
          set-user-ID ビット、または set-group-ID ビットと、対応する
          実行ビットの両方が立っている場合。

    `S'
          set-user-ID ビット、または set-group-ID ビットが立っているが、
          対応する実行ビットは立っていない場合。

    `t'
          削除制限フラグ、またはスティキー・ビット (sticky bit) と、
          その他のユーザ (other) の実行ビットの両方が立っている場合。
          削除制限フラグは、スティッキー・ビットの別名である。*Note
          Mode Structure::.

    `T'
          削除制限フラグ、またはスティキー・ビットが立っているが、その他の
          ユーザの実行ビットが立っていない場合。

    `x'
          実行ビットが立っていて、上記のどれにも当てはまらない場合。

    `-'
          それ以外。

     ファイルのモードビットの後に続く 1 個の文字は、アクセス・コント
     ロール・リスト (ACL) のような他のアクセス方式が、そのファイルに
     使われているかどうかを表している。ファイルのモードビットに続く
     文字が空白の場合は、他のアクセス方式を使用していないということ
     である。表示文字が続く場合は、そうしたアクセス方式を使用している
     ということだ。

     GNU の `ls' は、SELinux セキュリティ・コンテキストを持つが、
     それ以外に他のアクセス方式を使用していないファイルを示すのに、
     ピリオド (`.') を使う。

     それ以外で、ファイルが、標準以外のアクセス方式の何らかの組み
     合わせを使用している場合には、`+' 文字が印として付く。

`-n'
`--numeric-uid-gid'
     詳細形式でディレクトリの内容をリストするが、所有者やグループの
     名前の代わりに、数字の user-ID や group-ID を表示する。

`-o'
     詳細形式でディレクトリの内容をリストするが、グループ情報を表示
     しない。これは、`--format=long' を `--no-group' と併せて使うのと
     同じである。

`-s'
`--size'
     各ファイルに対するディスク割り当て量をファイル名の左側に表示する。
     これはファイルが使用しているディスクスペースの量であり、普通は
     ファイルのサイズより少し多いが、穴空きファイル (sparse file) の
     場合は、少ないこともある。

     通常、ディスク割り当て量は 1024 バイトを単位として表示されるが、
     これは変更することができる (*note Block size::)。

     ファイルが HP-UX のシステムから BSD のシステムに NFS マウント
     されている場合、このオプションで報告されるディスク使用量は、正確な
     値の半分である。それに対して、HP-UX システムの場合は、BSD システム
     から NFS マウントされているファイルについて、このオプションは正確な
     値の 2 倍の量を報告する。これは、HP-UX システムにある欠陥のせい
     であり、HP-UX の `ls' プログラムも、そのとばっちりを受けている
     のである。

`--si'
     各サイズにの後ろに、メガバイトなら `M' といった、SI 形式の略号
     を付ける。1024 ではなく、1000 の累乗が使用されるので、`M' は
     1,000,000 バイトを表している。このオプションは、`--block-size=si'
     と同じことである。1024 の累乗が使いたければ、`-h' や
     `--human-readable' を使用すればよい。

`-Z'
`--context'
     SELinux セキュリティ・コンテキストを表示する。ない場合は、`?' を
     表示する。`-l' オプションと一緒に使った場合は、サイズの左に
     セキュリティ・コンテキストを出力する。



File: coreutils-ja.info,  Node: Sorting the output,  Next: Details about version sort,  Prev: What information is listed,  Up: ls invocation

10.1.3 出力のソート
-------------------------

以下のオプションは、`ls' が出力する情報を並べる際の順序を変更する。
デフォルトでは、情報は文字コードによってソートされる (たとえば ASCII
コード順)。

`-c'
`--time=ctime'
`--time=status'
     詳細表示形式 (たとえば、`-l', `-o') を使用しているときは、更新日時
     (modification time) の代わりに、ステータス変更日時 (status change
     time、inode の `ctime') を表示する。日時によって明示的にソートして
     いるときや (`--sort=time' あるいは `-t')、詳細表示形式を使用して
     いないときは、ステータス変更日時によってソートする。

`-f'
     主な働きは、`-U' と同じで、ソートしないことである。すなわち、
     ファイルをリストする際、ファイルがディレクトリにどんな順序で
     格納されていようと、そのままの順序で出力する。それだけでなく、
     `-a' (すべてのファイルをリストする) を有効にし、`-l', `--color',
     `-s' を (`-f' より前で指定されていたら) 無効にする働きもある。

`-r'
`--reverse'
     どんな方法でソートされていようと、逆順にする。たとえば、ファイルを
     並べる際に、アルファベットの後ろから並べる、最新バージョンから先に
     並べる、サイズの小さいものから先に並べる、などなど。

`-S'
`--sort=size'
     ファイルのサイズによってソートし、大きいものから順に並べる。

`-t'
`--sort=time'
     更新日時 (modification time、inode の `mtime') によってソートし、
     新しいものから順に並べる。

`-u'
`--time=atime'
`--time=access'
`--time=use'
     詳細表示形式 (たとえば、`--format=long') を使用しているときは、
     最終アクセス日時 (last access time、inode の `atime') を表示する。
     日時によって明示的にソートしているときや (`--sort=time' あるいは
     `-t')、詳細表示形式を使用していないときは、アクセス日時によって
     ソートする。

`-U'
`--sort=none'
     ソートを行わない。すなわち、ファイルをリストする際、ファイルが
     ディレクトリにどんな順序で格納されていようと、そのままの順序で
     出力する (`-f' が行う、ソートに無関係な他のことは、何もしない)。
     このオプションは非常に大きなディレクトリを一覧表示するとき、
     ことのほか役に立つ。ソートを全くしないことで、作業速度が著しく
     向上するからである。

`-v'
`--sort=version'
     バージョンの名前と番号によってソートし、低いバージョンから順に
     並べる。デフォルトのソート方法と動作が似ているが、10 進数の数字が
     連続する各部分をインデックス番号やバージョン番号と見なして、
     数値として取り扱う点が違う。(*Note Details about version sort::.)

`-X'
`--sort=extension'
     ディレクトリの内容をファイルの拡張子 (最後の `.' の後に続く文字)
     によってアルファベット順でソートする。拡張子のないファイルは、
     最初に並べられる。



File: coreutils-ja.info,  Node: Details about version sort,  Next: General output formatting,  Prev: Sorting the output,  Up: ls invocation

10.1.4 バージョン・ソートの詳細
-------------------------------------------

ファイル名にはインデックス番号やバージョン番号が含まれていることが
しばしばあるが、バージョン・ソートは、そうした状況に対処している。
通常のソートでは、1 文字づつ比較を行うので、結果がこちらの期待する
順番にならないことがよくあるのだ。バージョン・ソートが特に役に立つのは、
インデックス番号やバージョン番号を名前に含むファイルがたくさんある
ディレクトリを一覧するときである。

     $ ls -1            $ ls -1v
     abc.zml-1.gz       abc.zml-1.gz
     abc.zml-12.gz      abc.zml-2.gz
     abc.zml-2.gz       abc.zml-12.gz

   バージョン・ソートにおける文字列の比較は、次のように行われる。 VER1
と VER2 がバージョン番号で、PREFIX (前置部分) と SUFFIX (後置部分)
が文字列だとしよう (SUFFIX は正規表現の `(\.[A-Za-z~][A-Za-z0-9~]*)*'
にマッチするもの)。その場合、VER1 < VER2 ならば、"PREFIX VER1 SUFFIX"
から構成される名前は "PREFIX VER2 SUFFIX" より前に来る。

   数字の部分の先行する 0 は無視されることにも注意していただきたい。

     $ ls -1            $ ls -1v
     abc-1.007.tgz      abc-1.01a.tgz
     abc-1.012b.tgz     abc-1.007.tgz
     abc-1.01a.tgz      abc-1.012b.tgz

   この機能は gnulib の `filevercmp' 関数を使って実装されている。
そこで、知っておいた方がよい注意事項がいくつかある。

   * `LC_COLLATE' は無視される。そのため、`ls -v' や `sort -V' は、
     数値ではない PREFIX (前置部分) を、`LC_COLLATE' ロケール・カテゴリ
     が `C' に設定されているかのようにソートする。

   * SUFFIX (後置部分) に上記の正規表現がマッチしてくれないことがある。
     従って、以下の例は、期待通りの順序ではないかもしれない。

          abc-1.2.3.4.7z
          abc-1.2.3.7z

          abc-1.2.3.4.x86_64.rpm
          abc-1.2.3.x86_64.rpm


File: coreutils-ja.info,  Node: General output formatting,  Next: Formatting file timestamps,  Prev: Details about version sort,  Up: ls invocation

10.1.5 出力全体の形式
----------------------------

以下のオプションは出力全体の見かけに影響を及ぼす。

`-1'
`--format=single-column'
     1 行 に 1 ファイルを表示する。標準出力が端末でないときの `ls'
     のデフォルトである。

`-C'
`--format=vertical'
     ファイルのリストを段組みで (訳注: すなわち、1 行に複数ファイルの
     形式で) 表示し、ソートは縦方向に行う。これは、標準出力が端末の
     ときの `ls' のデフォルトである。`dir' コマンドにとっては、これが
     常にデフォルトになる。GNU の `ls' は、できるだけ少ない行数でできる
     だけ多くのファイルを表示するために、段の幅を可変にしている。

`--color [=WHEN]'
     ファイルのタイプを区別するためにカラー表示を使用するかどうかを
     指定する。WHEN は省略してもよく、以下の一つでもよい。
        * none カラー表示を全く使用しない。これがデフォルトである。

        * auto 標準出力が端末の場合のみ、カラー表示を使用する。

        * always 常にカラー表示を使用する。
     `--color' を WHEN を付けずに指定するのは、"`--color=always' と
     同じことである。カラー表示にしたファイル・リストをパイプで `more'
     や `less' のようなページャに送ると、たいての場合、判読に苦しむ
     羽目になる。ただし、`more -f' を使うと、うまく行くようだ。(訳注:
     訳者の手元では、`less -R' や `lv -c' で一応問題なくカラー表示が
     できているように見える。)

     留意すべきは、`--color' オプションを使用すると、大量のファイルが
     あるディレクトリで `ls' を実行したとき、目に見えて動作速度が低下
     するかもしれないことである。これは、カラー表示のデフォルトの設定
     では、`ls' は、リストするファイルを一つづつ `stat' システムコールで
     調べる必要があるからだ。とは言え、ファイルタイプのカラー表示は
     おおむね使用したいけれど、他の色付けオプションは使わなくてもよい
     こともある (たとえば、実行属性、リンク切れ、スティッキー・ビット、
     その他のユーザの書き込み権限、ケーパビリティなどは、色で表示しなく
     てもよい)。その場合は、こんなふうに、`dircolors' コマンドを使用
     して、環境変数 `LS_COLORS' を設定すればよい。
          eval $(dircolors -p | perl -pe \
            's/^((CAP|S[ET]|O[TR]|M|E)\w+).*/$1 00/' | dircolors -)
     そうすれば、`dirent.d_type' が使えるファイルシステムなら、`ls' は
     各コマンドライン引数に対してたった一回だけ `stat' システムコールを
     行うだけですむようになる。

`-F'
`--classify'
`--indicator-style=classify'
     各ファイル名の後ろに、ファイルタイプを示す 1 文字を付ける。
     通常ファイルの場合も、実行可能ファイルならば、`*' を後置する。
     ファイルタイプの指標は、ディレクトリならば `/'、シンボリック
     リンクならば `@'、FIFO ならば `|'、ソケットならば `='、ドアならば
     `>' であり、通常ファイルを表す指標はない。なお、
     `--dereference-command-line' (`-H'), `--dereference' (`-L'),
     `--dereference-command-line-symlink-to-dir' といったオプションが
     指定されていないかぎり、コマンドラインで指定されたシンボリックリンク
     をたどることはない。

`--file-type'
`--indicator-style=file-type'
     各ファイル名の後ろに、ファイルタイプを示す 1 文字を付ける。 `-F'
     に似ているが、こちらは、実行ファイルに指標を付けない。

`--indicator-style=WORD'
     ファイル名の後ろに指標文字を付けるとき、WORD というスタイルを
     使用する。WORD には次のものがある。

    `none'
          指標文字を全く付けない。これがデフォルトである。

    `slash'
          ディレクトリの後ろに `/' を付ける。これは、`-p' オプションと
          同じである。

    `file-type'
          ディレクトリ、シンボリックリンク、FIFO、ソケットの後ろに、
          それぞれ `/', `@', `|',  `=' を付け、通常ファイルの後ろには
          何も付けない。これは、`--file-type' オプションと同じである。

    `classify'
          実行可能な通常ファイルの後ろに `*' を付ける。それ以外は、
          `file-type' の場合と同じ動作をする。これは、`-F' や
          `--classify' オプションと同じである。

`-k'
`--kibibytes'
     デフォルトのブロックサイズを標準の値の 1024 バイトに設定する。
     そのとき、環境変数でそれ以外のどんな値が設定されていても、
     それを上書きする (*note Block size::)。このオプション自身も、
     `--block-size', `--human-readable' (`-h'), `--si' オプションが
     現れれば、それによって上書きされる。

     `--kibibytes' (`-k') オプションが影響を及ぼすのは、`-l' などの
     オプションが書き出すディレクトリごとのブロック数や、`--size'
     (`-s') オプションが表示するディスク割り当て量に対してである。 `-l'
     の表示するファイルサイズには影響を及ぼさない。

`-m'
`--format=commas'
     ファイルを横に並べて、一行に収まる範囲でできるだけ多く表示する。
     ファイル同士は `, ' (コンマとスペース) で区切る。

`-p'
`--indicator-style=slash'
     ディレクトリ名の後ろに `/' を付ける。

`-x'
`--format=across'
`--format=horizontal'
     ファイルのリストを段組みで (訳注: すなわち、1 行に複数ファイルの
     形式で) 表示し、ソートは横方向に行う。

`-T COLS'
`--tabsize=COLS'
     タブ位置が COLS 桁ごとにあると想定する。デフォルトは 8 桁ごと。
     `ls' は効率を考慮し、使えるときはタブを出力で使用する。 COLS が 0
     の場合は、タブを使用しない。

     端末エミュレータの中には、ASCII 以外のバイトが前にあると、
     列をタブ位置の右にきちんと揃えてくれないものがある (少なくとも、
     Mac OS X 10.4.8 の Apple Terminal 1.5 (133) がそうだ)。そうした
     端末エミュレータを使用している場合は、`-T0' オプションを使うか、
     環境変数 `TABSIZE=0' を設定するかして、列を揃えるのにタブではなく、
     スペースを使うよう、`ls' に指示するとよい。

`-w'
`--width=COLS'
     スクリーンの横幅が COLS 桁だと想定する。デフォルトの値は、
     可能ならば端末の設定から取得する。取得できないときは、環境変数
     `COLUMNS' を使用し、それも設定されていなければ、80 をデフォルト
     にする。



File: coreutils-ja.info,  Node: Formatting file timestamps,  Next: Formatting the file names,  Prev: General output formatting,  Up: ls invocation

10.1.6 タイムスタンプのフォーマット
-------------------------------------------------

デフォルトでは、ファイルのタイムスタンプは短縮形式で表示される。
すなわち、最近のタイムスタンプ以外は、`Mar 30  2002' といった
日付表示になり、最近のタイムスタンプは、`Mar 30 23:45' といった
年度なしの日付と時刻の表示になる。この書式は、後で詳しく述べる
ように、現在のロケールによっては違ったものになるかもしれない。

   タイムスタンプは、ここ 6 ヶ月以内のもので、未来の日付が付いて
いなければ、最近 ("recent") として扱われる。今日の日付のタイム
スタンプが、最近用の書式で表示されない場合、そのタイムスタンプは
未来扱いされている。それは、おそらく時計に狂いが生じているという
ことであり、`make' のような、ファイルのタイムスタンプに頼っている
プログラムは、まともに動かないかもしれない。

   タイムスタンプは、タイムゾーンのルールに従って表示されるが、その
ルールを指定しているのは、環境変数 `TZ' である。`TZ' が設定されて
いない場合は、システムのデフォルトのルールに従って表示される。 *Note
Specifying the Time Zone with `TZ': (libc)TZ Variable.

   以下のオプションは、ファイルのタイムスタンプの表示方法を変更する。

`--time-style=STYLE'
     タイムスタンプを STYLE 形式で表示する。STYLE は以下の一つで
     なければならない。

    `+FORMAT'
          FORMAT を使って、タイムスタンプを表示する。その場合、FORMAT
          は、`date' コマンドの書式引数と同じように解釈される (*note
          date invocation::)。 たとえば、`--time-style="+%Y-%m-%d
          %H:%M:%S"' と指定すると、 `ls' の表示するタイムスタンプは、
          `2002-03-30 23:45:56' のようになる。`date' の場合と同様、
          FORMAT の解釈は、`LC_TIME' ロケール・カテゴリの影響を受ける。

          FORMAT に改行で分離された二つの書式文字列がある場合、前半は
          最近のファイル以外に使用され、後半は最近のファイルに使用される。
          出力される列をきちんと揃えたいならば、二つの書式のどちらかに、
          空白をいくつか入れる必要があるかもしれない。

    `full-iso'
          タイムスタンプを省略なしで表示する。すなわち、ISO 8601 の
          日付、時刻、タイムゾーンという書式を nanosecond (10 億分の 1
          秒) の精度で使用するわけだ。一例を挙げると、`2002-03-30
          23:45:56.477817180 -0700' といった表示になる。この形式は、
          `+%Y-%m-%d %H:%M:%S.%N %z' と同じである。

          これが有用なのは、タイムスタンプが、オペレーティング・システム
          から取得できる時間関係のすべての情報を含んでいるからである。
          たとえば、GNU の `make' は、あるファイルが古いかどうかを
          判定するのに、省略なしのタイムスタンプを使用する。そのため、
          この情報が、`make' の動作を説明してくれるのである。

    `long-iso'
          ISO 8601 の書式で日付と時刻を分の単位まで表示する。たとえば、
          `2002-03-30 23:45'。このタイムスタンプは、`full-iso' タイム
          スタンプより短く、日常作業にはたいてい十分である。この形式は
          `+%Y-%m-%d %H:%M' と同じである。

    `iso'
          最近以外のタイムスタンプでは、ISO 8601 書式の日付を表示し
          (たとえば `2002-03-30 ')、最近のタイムスタンプでは、ISO 8601
          書式の月・日・時・分を表示する (たとえば `03-30 23:45')。
          この形式は、`long-iso' の形式に比べて見かけがよくないが、より
          狭いスペースでほぼ同量の情報を伝えており、また、簡潔なので
          `ls' の出力を伝統的な 1 行 80 桁の出力行に納めるのに都合が
          よい。`ls' を実行する以下の二つの方法は、同じことである。

               newline='
               '
               ls -l --time-style="+%Y-%m-%d $newline%m-%d %H:%M"
               ls -l --time-style="iso"

    `locale'
          タイムスタンプをロケール依存形式で表示する。たとえば、
          フィンランド語のロケールだと、最近以外のタイムスタンプを
          `maalis 30  2002' のように表示し、最近のタイムスタンプは
          `maalis 30 23:45' のように表示するかもしれない。ロケール
          依存のタイムスタンプは、概して `iso' のタイムスタンプより
          長くなるし、ロケールごとの規則の違いは非常に大きいので、
          プログラムによる解析がずっと難しくなる。だが、こちらの方が
          わかりやすい人も大勢いる。

          タイムスタンプの書式を決めているのは、`LC_TIME' ロケール・
          カテゴリである。デフォルトの POSIX ロケールでは、`Mar 30
          2002' や `Mar 30 23:45' といったタイムスタンプを使っている。
          POSIX ロケールでは、`ls' を実行する次の二つの方法は、同じこと
          である。

               newline='
               '
               ls -l --time-style="+%b %e  %Y$newline%b %e %H:%M"
               ls -l --time-style="locale"

          しかし、他のロケールでは動作が違う。たとえば、ドイツ語の
          ロケールだと、`--time-style="locale"' は `--time-style="+%e.
          %b %Y $newline%e. %b %H:%M"' とおそらく同じになり、`30. Ma"r
          2002 ' や `30. Ma"r 23:45' といったタイムスタンプを生成する
          だろう。

    `posix-STYLE'
          `LC_TIME' ロケール・カテゴリが POSIX なら、POSIX ロケールの
          タイムスタンプを表示し、それ以外なら、STYLE 形式のタイム
          スタンプを表示する。たとえば、`posix-long-iso' という指定は、
          POSIX ロケールでは `Mar 30  2002' や `Mar 30 23:45' といった
          タイムスタンプを表示し、それ以外のロケールでは `2002-03-30
          23:45' といったタイムスタンプを表示する。

   `--time-style' オプションのデフォルト値は、環境変数 `TIME_STYLE'
を使って指定することができる。`TIME_STYLE' が設定されていない場合、
デフォルトの形式は `locale' である。GNU Emacs の 21.3 以降は `--dired'
オプションを使用しており (訳注: `ls' の `--dired' オプションのこと
だろう)、従って、どんな日付のフォーマットでも解析することができる。
しかし、Emacs 21.1 や 21.2 を使っていて、POSIX 以外のロケールを
指定している場合は、`TIME_STYLE="posix-long-iso"' を設定する必要が
あるかもしれない。

   ある種の サービス不能化攻撃 (denial-of-service attacks) を回避する
ため、1000 バイトより長くなりそうなタイムスタンプは、エラーとして処理
されることがある。


File: coreutils-ja.info,  Node: Formatting the file names,  Prev: Formatting file timestamps,  Up: ls invocation

10.1.7 ファイル名のフォーマット
-------------------------------------------

以下のオプションは、ファイル名の表示方法を変更する。

`-b'
`--escape'
`--quoting-style=escape'
     ファイル名中の非表示文字 (nongraphic characters) を、C 言語で
     使うような、バックスラッシュにアルファベットや 8 進数を続ける方法を
     使用して、クォートする。

`-N'
`--literal'
`--quoting-style=literal'
     ファイル名をクォートしない。とは言え、`ls' では、出力先が端末の
     場合、`--show-control-chars' が指定されていなければ、非表示文字を
     疑問符として表示するぐらいのことは行う。

`-q'
`--hide-control-chars'
     ファイル名中の非表示文字に代えて、疑問符を表示する、この動作は、
     出力先が端末で、プログラムが `ls' の場合のデフォルトである。

`-Q'
`--quote-name'
`--quoting-style=c'
     ファイル名をダブル・クォートで囲み、非表示文字を C 言語と同じ
     やり方でクォートする。

`--quoting-style=WORD'
     ファイル名などの文字列には、通常使われない文字が含まれているかも
     しれない。このオプションを指定すると、WORD というスタイルを使って、
     そうした文字列をクォートすることになる。WORD は、以下に挙げるものの
     一つでなければならない。

    `literal'
          文字列に手を加えず、そのまま出力する。これは、`-N' や
          `--literal' オプションと同じである。

    `shell'
          文字列にシェルのメタ文字がある場合や、出力が誤解を招くものに
          なりそうな場合に、シェル向けのクォートを施す。このクォート
          方法は、`bash' のような POSIX 互換のシェルにはふさわしいもの
          だが、`csh' のような非互換のシェルでは、必ずしもうまく働く
          とはかぎらない。

    `shell-always'
          普通ならクォートが不要な場合でも、文字列にシェル向けのクォートを
          施す。

    `c'
          C 言語の文字列リテラルをクォートするときのように、文字列を
          クォートする。文字列をダブル・クォートで囲むことも行う。
          これは、`-Q' や `--quote-name' オプションと同じである。

    `escape'
          C 言語の文字列リテラルをクォートするときのように、文字列を
          クォートする。ただし、文字列をダブル・クォートで囲むことは
          しない。これは、`-b' や `--escape' と同じである。

    `clocale'
          C 言語の文字列リテラルをクォートするときのように、文字列を
          クォートする。ただし、文字列を囲む引用符には、ロケールに
          ふさわしいものを使う。

    `locale'
          C 言語の文字列リテラルをクォートするときのように、文字列を
          クォートする。ただし、文字列を囲む引用符には、ロケールに
          ふさわしいものを使い、さらに、デフォルトの C ロケールで
          言うと、"like this" ではなく、'like this' のように
          クォートを行う。この方が見栄えのよいディスプレイが多い。

     `--quoting-style' オプションのデフォルト値は、環境変数
     `QUOTING_STYLE' によって指定することができる。この環境変数が
     設定されていない場合、デフォルトの値は `literal' だが、
     このパッケージの将来のバージョンでは、デフォルトを `shell' に
     変更するかもしれない。

`--show-control-chars'
     非表示文字に手を加えず、ファイル名中にそのまま出力する。
     これは、出力先が端末でない場合や、プログラムが `ls' でない場合の
     デフォルトである。



File: coreutils-ja.info,  Node: dir invocation,  Next: vdir invocation,  Prev: ls invocation,  Up: Directory listing

10.2 `dir': ディレクトリの内容を簡潔に表示する
===============================================================

`dir' の動作は、`ls -C -b' と同じである。すなわち、デフォルトでは、
ファイルのリストを段組みで (訳注: 1 行に複数ファイルの形式で) 表示し、
ソートは縦方向に行う。また、特殊文字は、バックスラッシュ・エスケープ
シーケンスを使って表示する。

   *Note `ls': ls invocation.


File: coreutils-ja.info,  Node: vdir invocation,  Next: dircolors invocation,  Prev: dir invocation,  Up: Directory listing

10.3 `vdir': ディレクトリの内容を詳細に表示する
================================================================

`vdir' の動作は、`ls -l -b' と同じである。すなわち、デフォルトでは、
詳細形式でファイルをリストし、特殊文字は、バックスラッシュ・エスケープ
シーケンスを使って表示する。


File: coreutils-ja.info,  Node: dircolors invocation,  Prev: vdir invocation,  Up: Directory listing

10.4 `dircolors': `ls' のカラー設定
=========================================

`dircolors' は、`ls' (や `dir' など) でカラー出力をするのに必要な
端末設定のためのシェル・コマンドのシーケンスを出力する。通常、次の
ような形で使用される。

     eval "$(dircolors [OPTION]... [FILE])"

   FILE が指定されていると、`dircolors' はそれを読み込んで、
どのファイルタイプや拡張子に対してどの色を使うかを決定する。 FILE
が指定されていない場合は、あらかじめ組み込まれているデータベースが
使用される。そうした設定ファイルの書式について詳しいことを知りたかっ
たら、`dircolors --print-database' を実行してみるとよい。

   ファイル `~/.dircolors' が存在していたら、`dircolors' がそれを
読み込むようにするには、以下の行を自分の `~/.bashrc' に書き込めばよい
(お気に入りのシェルが bash でないなら、適切に書き直すこと)。

     d=.dircolors
     test -r $d && eval "$(dircolors $d)"

   `dircolors' の出力は、環境変数 `LS_COLORS' を設定するシェル・
コマンドである。どのシェルの文法にするかは、コマンドラインで
指定することができる。指定しない場合は、環境変数 `SHELL' の値から
`dircolors' が推測する。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--sh'
`--bourne-shell'
     Bourne シェルのコマンドを出力する。これが、環境変数 `SHELL' が
     設定されていて、その値が `csh' や `tcsh' で終わっていないときの
     デフォルトである。

`-c'
`--csh'
`--c-shell'
     C シェルのコマンドを出力する。これは、環境変数 `SHELL' の値が、
     `csh' や `tcsh' で終わっているときのデフォルトである。

`-p'
`--print-database'
     (プログラムに組み込まれている) デフォルトのカラー設定データベースを
     出力する。この出力は、それ自体有効な設定ファイルであり、どういう
     設定が可能かについてかなり詳しく説明している。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Basic operations,  Next: Special file types,  Prev: Directory listing,  Up: Top

11 基本的なファイル操作
*********************************

この章では、基本的なファイル操作のためのコマンドを説明する。
すなわち、コピー、移動 (名前の変更)、消去 (削除) といった操作である。

* Menu:

* cp invocation::            ファイルをコピーする。
* dd invocation::            ファイルの変換とコピー。
* install invocation::       ファイルをコピーし属性をセットする。
* mv invocation::            ファイルの移動 (名前の変更) を行う。
* rm invocation::            ファイルやディレクトリを削除する。
* shred invocation::         セキュリティを向上させたファイルの削除。


File: coreutils-ja.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations

11.1 `cp': ファイルやディレクトリをコピーする
==============================================================

`cp' はファイルをコピーする (オプションによっては、ディレクトリの
コピーも行う)。コピーによって作られたファイルは、コピー元から全く
独立したものになる。一つのファイルを別のファイルにコピーすることも
できるし、好きなだけたくさんのファイルをコピー先のディレクトリに
一遍にコピーすることもできる。

   書式:

     cp [OPTION]... [-T] SOURCE DEST
     cp [OPTION]... SOURCE... DIRECTORY
     cp [OPTION]... -t DIRECTORY SOURCE...

   * ファイル名を二つ指定すると、`cp' は最初のファイルを 2 番目の
     ファイルにコピーする。

   * `--target-directory' (`-t') オプションを指定した場合や、あるいは
     それを指定しないでも、最後のファイルがディレクトリであり、しかも
     `--no-target-directory' (`-T') オプションが指定されていない場合は、
     `cp' は、各コピー元 (SOURCE) ファイルを、指定されたディレクトリに
     コピー元 (SOURCE) と同じ名前でコピーする。

   ほとんどの場合、ファイルは読み込まれたとおりに書き出される。例外に
ついては、後述の `--sparse' オプションをご覧になっていただきたい。

   デフォルトでは、`cp' はディレクトリをコピーしない。ただし、 `-R',
`-a', `-r' オプションを指定すると、`cp' は再帰的なコピーを行う。
すなわち、コピー元のディレクトリを段階的に下って、対応するコピー先の
ディレクトリにファイルをコピーすることになる。

   コピー元がシンボリックリンクの場合、`cp' がリンクをたどるのは (訳注:
すなわち、リンクそのものではなく、参照先のファイルをコピーするのは)、
原則として、再帰的なコピーをしていないときだけである。このデフォルトの
動作は、次に挙げるオプションによって変更することができる。`--archive'
(`-a'), `-d', `--dereference' (`-L'), `--no-dereference' (`-P'), `-H'。
こうしたオプションを二つ以上指定した場合、`cp' は警告を出さず、最後の
オプションが他のものを上書きする。

   コピー先がシンボリックリンクの場合、`cp' がリンクをたどるのは、
(訳注: すなわち、コピー元ファイルで、リンクそのものではなく、参照先の
ファイルを上書きするのは)、そのリンクが、存在する通常ファイルを指して
いるときだけである。それに対して、コピー先のシンボリックリンクがリンク
切れしている場合は、`cp' は、デフォルトではコピーを拒否し、エラーメッ
セージを出して、実行に失敗する。そうした操作は、本質的に危険だからで
ある。この動作は、伝統的な習慣や POSIX の仕様に反している。たとえリスク
があろうとも、リンク切れしたシンボリックリンクの参照先を `cp' が作成する
ようにしたいなら、環境変数 `POSIXLY_CORRECT' を設定すればよい。なお
`--backup' や `--link' といったオプションが、コピーする前にコピー先
ファイルの名前変更や削除を行う場合、`cp' は、リンクが指しているファイル
ではなく、シンボリックリンクの名前変更や削除を行う。

   デフォルトでは、`cp' がスペシャルファイルの内容をコピーするのは、
再帰的なコピーをしていないときだけである。このデフォルトの動作は、
`--copy-contents' によって変更できる。

   `cp' は通常、ファイルを自分自身にコピーすることを拒否するが、次の
例外がある。SOURCE と DEST が同一で、しかも、通常ファイルを指している
場合、`cp' は `--force --backup' オプションが指定されると、バックアップ
ファイルを作成することになる。標準のものであれ (訳注: ファイルの末尾に
チルダ `~' が 1 個付く)、番号付きのものであれ、いつもの方法で指定された
とおりのバックアップファイルを作るわけだ (*note Backup options::)。
存在するファイルに変更を加える前に、そのバックアップをちょっと作って
おきたい場合、この動作は便利である。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--archive'
     コピーを行う際、コピー元ファイルの構造や属性をできるかぎり維持
     する (ただし、ディレクトリの内部構造を維持しようとはしない。その
     ため、コピー先で `ls -U' を実行すると、コピー元とは違った順序で
     ファイルをリストするかもしれない)。SELinux コンテキストや拡張属性
     (xattr) も維持しようとするが、そうした操作に失敗しても無視し、
     その旨エラーメッセージを表示することはない。エラーメッセージが
     少ないだけで、`-dR --preserve=all' と同じある。

`--attributes-only'
     コピー元ファイルの指定された属性のみを、コピー先にコピーする。
     コピー先ファイルがすでに存在している場合、その内容を変更する
     ことはない。属性のうち、何をコピーするかを決める方法については、
     `--preserve' オプションの項を見ていただきたい。

`-b'
`--backup[=METHOD]'
     *Note Backup options::.  そのままでは、上書きされるか、消去されて
     しまう各ファイルのバックアップを作成する。特殊な用法としては、
     次のものがある。force と backup の両方のオプションが指定されて
     いるとき、`cp' は、コピー元 (SOURCE) とコピー先 (DEST) が同じ名前
     で、しかも存在する通常ファイルを指していると、コピー元 (SOURCE) の
     バックアップを作成する。次のちょっとした Bourne シェルのスクリプト
     は、オプションのこの組み合わせの応用だが、便利である。

          #!/bin/sh
          # Usage: backup FILE...
          # リストされた各 FILE について GNU スタイルのバックアップを
          # 作成する
          fail=0
          for i; do
            cp --backup --force --preserve=all -- "$i" "$i" || fail=1
          done
          exit $fail

`--copy-contents'
     再帰的なコピーを行っている際に、スペシャルファイル (たとえば、
     FIFO やデバイスファイル) の内容を、それが通常ファイルであるかの
     ようにコピーする。要するに、コピー元の各ファイルからデータを
     読み込んで、それをコピー先に書き出そうとするということだ。
     このオプションを使うのは、ほとんどの場合誤りである。なぜなら、
     FIFO や、通常 `/dev' ディレクトリにあるようなスペシャルファイルを
     対象にした場合、望ましくない結果を生ずることが、珍しくないからだ。
     `cp -R --copy-contents' は、FIFO や `/dev/console' のような
     スペシャルファイルからデータを読み込もうとすると、たいていの
     場合、いつまでも無反応になるだろうし、`/dev/zero' をコピーしよう
     とすれば、コピー先のファイルが存在するディスクを溢れさせてしまう
     だろう。このオプションは、再帰的なコピーをするとき以外、効果を
     持たない。また、シンボリックリンクのコピーには影響しない。

`-d'
     シンボリックリンクをコピーする際、リンクが指しているファイルを
     コピーするのではなく、シンボリックリンクとしてコピーする。また、
     コピー元においてファイル同士がハードリンクの関係にある場合は、
     コピー先でもそれを維持する。`--no-dereference --preserve=links'
     と同じである。

`-f'
`--force'
     このオプションを付けずにコピーを行う場合、コピー先ファイルが
     すでに存在し、しかも書き込みモードでオープンできないと、コピー
     に失敗する。それに対して、`--force' を付けた場合は、コピー先
     ファイルがオープンできないと、`cp' は、まずそれを削除してから、
     再度オープンを試みる。この動作を、`--force' と一緒に `--link' や
     `--symbolic-link' を使用した場合に実行される動作と対比していただき
     たい。その場合は、すでに存在するコピー先ファイルは一度もオープン
     されず、むしろ無条件で削除されるのである。`--remove-destination' の
     説明も参照すること。

     このオプションは、`--interactive' や `-i' オプションとは無関係
     である。どちらも他方の効果を無効にすることはない。

     `--no-clobber' や `-n' オプションを使用している場合、このオプション
     を指定しても、無駄である。

`-H'
     コマンドラインの引数がシンボリックリンクを指定している場合には、
     シンボリックリンクそのものではなく、それが指しているファイルを
     コピーする。とは言え、再帰的にディレクトリ・ツリーをたどっている
     ときにシンボリックに出会った場合は、そのまま (つまり、シンボリック
     リンクとして) コピーする。

`-i'
`--interactive'
     ディレクトリ以外のファイルをコピーする際に、コピー先ファイルが
     すでに存在していると、プロンプトを出して、ファイルを上書きして
     よいかどうか、ユーザに問い合わせる。`-i' オプションは、`-n'
     オプションが前にあるとき、それを無効にする。

`-l'
`--link'
     コピー元がディレクトリ以外の場合、コピーする代わりに、ハードリンクを
     作成する。

`-L'
`--dereference'
     コピー元がシンボリックリンクの場合は、その参照先をコピーする。
     また、このオプションを使った場合、`cp' はシンボリックリンクを
     作ることができない。たとえば、コピー元のディレクトリ・ツリー中に
     (通常ファイルに対する) シンボリックリンクがあると、コピー先のディ
     レクトリ・ツリーには、通常ファイルとしてコピーされることになる。

`-n'
`--no-clobber'
     存在するファイルを上書きしない。`-n' オプションは、`-i' オプション
     が前にあるとき、それを無効にする。このオプションと `-b'
     (`--backup') オプションは、どちらか一方しか指定できない。

`-P'
`--no-dereference'
     コピー元がシンボリックリンクの場合、それが指しているファイルを
     コピーするのではなく、シンボリックリンクとしてコピーする。この
     オプションが作用を及ぼすのは、コピー元のシンボリックリンクに対して
     だけであり、コピー先に指定されたシンボリックリンクについては、
     可能なかぎり常に参照先がたどられる。

`-p'
`--preserve[=ATTRIBUTE_LIST]'
     コピー元ファイルの属性のうち、指定されたものをコピー先でも維持する。
     ATTRIBUTE_LIST を指定する場合は、一つ以上の以下の文字列をコンマで
     区切ったリストでなければならない。

    `mode'
          ファイルのモードビット (訳注: 一般にアクセス権とか、許可属性と
          言われるもの) やアクセス・コントロール・リストを維持する。

    `ownership'
          所有者とグループを維持する。ほとんどの最近のシステムでは、
          ファイルの所有者を変更できるのは、しかるべき権限を持ったユーザ
          だけである。また、一般ユーザにファイルのグループが維持できるの
          は、維持しようとするグループに、たまたまそのユーザが属している
          ときのみである。

    `timestamps'
          最終アクセス日時と最終更新日時 (modification time) を、
          可能ならば、維持する。古いシステムでは、対象となるファイルが
          シンボリックリンクの場合、そうした属性を維持することができない。
          それに対して、最近のシステムでは、たいていのものが `utimensat'
          関数を用意しているので、シンボリックリンクの場合でも、日時関係の
          属性維持が可能である。

    `links'
          コピー元のファイル同士が (ハードリンクであれ、シンボリック
          リンクであれ）リンクの関係にあるとき、コピー先の対応する
          ファイル同士でも、その関係を維持する。ただし、`-L' や `-H' と
          一緒に使った場合、このオプションがシンボリックリンクを
          ハードリンクに変更することがあるのに、注意していただきたい。
          一例を挙げる。
               $ mkdir c; : > a; ln -s a b; cp -aH a b c; ls -i1 c
               74161745 a
               74161745 b
          コピー元に注目していただきたい。`b' は、通常ファイル `a' を
          指すシンボリックリンクである。ところが、コピー先ディレクトリ
          `c/' の二つのファイルは、ハードリンクになっている。`-a' は
          `--preserve=links' を意味し、`-H' は `cp' にコマンドライン
          引数の参照をたどるよう指示している。そのため、`cp' は、二つの
          コピー元ファイルの inod が同じであることに気づき、両者を
          ハードリンクと認識して、その関係をコピー先で維持するのである。

          次のものは、`cp' の `-L' を使った場合の類似例である。
               $ mkdir b c; (cd b; : > a; ln -s a b); cp -aL b c; ls -i1 c/b
               74163295 a
               74163295 b

    `context'
          ファイルの SELinux セキュリティ・コンテキストを維持する。
          それができないときは、詳細なエラーメッセージを出し、失敗の
          ステータスで終了する。

    `xattr'
          ファイルの拡張属性を維持する。それができないときは、詳細な
          エラーメッセージを出し、失敗のステータスで終了する。`cp' が
          xattr のサポートなしでビルドされている場合、このオプションは
          無視される。SELinux コンテキスト、ACL、ケーパビリティなどを
          xattr を使って実装している場合は、そうした属性もこのオプション
          によって維持される。

    `all'
          ファイルの属性をすべて維持する。上記のすべてを指定するのと
          同じことだが、SELinux セキュリティ・コンテキストや拡張属性の
          維持に失敗しても、`cp' の終了ステータスが変わらないという点が
          異なっている。`-a' とは違って、`Operation not supported'
          以外のすべての 警告メッセージを出力する。

     ATTRIBUTE_LIST なしで `--preserve' を使用するのは、
     `--preserve=mode,ownership,timestamps' と同じことである。

     このオプションを使わない場合、各コピー先ファイルは、対応する
     コピー元ファイルのモードビットを付けて作成される。ただし、 umask
     で設定されているビットと、set-user-ID や set-group-ID ビットは
     落とされる。*Note File permissions::.

`--no-preserve=ATTRIBUTE_LIST'
     指定された属性を維持しない。ATTRIBUTE_LIST の書式は、`--preserve'
     の場合と同じである。

`--parents'
     コピー先の各ファイル名を作成するとき、出力先ディレクトリ名の後ろ
     にスラッシュを置き、さらにコピー元として指定されたファイル名を
     続けることによってそれを行う。`cp' に渡す最後の引数は、実在する
     ディレクトリの名前でなければならない。一例を挙げる。

          cp --parents a/b/c existing_dir

     上記のコマンドは、`a/b/c' というファイルを `existing_dir/a/b/c' に
     コピーする。途中のディレクトリが存在していなければ、それも作成する。

`-R'
`-r'
`--recursive'
     ディレクトリを再帰的にコピーする。デフォルトでは、コピー元にある
     シンボリックリンクの参照先をたどることをしない。`--archive' (`-a'),
     `-d',`--dereference' (`-L'), `--no-dereference' (`-P'), and `-H'
     などのオプションを参照。スペシャルファイルについては、コピーする
     際に、コピー元ファイルと同じファイル型のコピー先ファイルを作成する。
     `--copy-contents' を参照。シンボリックリンクやスペシャルファイルの
     コピーに `-r' オプションを使用するのは、どのシステムでも通用する
     ことではない。GNU 以外のシステムの中には、歴史的な理由から、 `-r'
     が、`-L' と `--copy-contents' を同時に指定するのと等価になっている
     ものもあるのだ。また、シンボリックリンクをコピーするのに `-R' を
     使用するのも、`-P' も併せて指定しないかぎり、どのシステムでも通用
     することではない。デフォルトでシンボリックリンクの参照先をたどる
     実装が、POSIX で認められているからである。

`--reflink[=WHEN]'
     ファイルシステムがサポートしていれば、軽便コピー、すなわち、
     書き込み時コピー(copy-on-write (COW) copy) を行う。留意すべきは、
     これが成功した場合、コピー元とコピー先のファイルは、どちらかに
     対して変更が加えられるまで、ディスクの同じデータブロックを共有
     しているということである。従って、ディスク I/O エラーが起きて、
     片方のファイルのデータブロックが損傷を受ければ、もう一方の
     ファイルも同じ被害に会う。

     WHEN の値には、次のうちの一つが使える。

    `always'
          デフォルトの動作である。copy-on-write がサポートされていない
          場合は、各ファイルについて失敗した旨を報告し、失敗を示す
          ステータスで終了する。

    `auto'
          copy-on-write 操作がサポートされていない場合は、copy-on-write
          をあきらめて、標準のコピー動作を行う。

     このオプションは、`--link', `--symbolic-link' `--attributes-only'
     オプションによって無効になるので、データをコピーする際の `cp' の
     デフォルト動作の設定に使用することができる。たとえば、次のエイリ
     アスを使うと、`cp' は、ファイルシステムがサポートする最小のディスク
     スペースを使用するようになる。

          alias cp='cp --reflink=auto --sparse=always'

`--remove-destination'
     コピー先ファイルがすでに存在する場合、その各々についてオープンを
     試みる前に、削除する (上述の `-f' と比較すること)。

`--sparse=WHEN'
     穴空きファイル ("sparse file") とは、穴 ("holes") を含むファイル
     である。穴というのは、物理的なディスクブロック上には存在しない
     ゼロバイトの連続で、`read' システムコールがそれを読む込むとき、
     ゼロの連続として扱うものである。バイナリ・ファイルには、連続する
     ゼロバイトがたくさん含まれていることが多いので、この仕組みは、
     ディスクスペースを大いに節約してくれるし、動作速度の向上を
     もたらしてもくれる。デフォルトで `cp' は、かなり大雑把な発見的
     手法を使って、コピー元ファイルにある穴を検出し、対応するコピー先
     ファイルも穴空きファイルにする。なお、穴空きファイルになれるのは、
     通常ファイルだけである。

     WHEN の値には、次のうちの一つが使える。

    `auto'
          デフォルトの動作である。すなわち、コピー元が穴空きファイルなら、
          コピー先も穴空きファイルにしようとする。ただし、コピー先
          ファイルがすでに存在し、通常ファイル以外を指している場合は、
          それを穴空きにしようとはしない。

    `always'
          たとえ、コピー元ファイルが穴空きファイルに見えなくても、十分に
          長いゼロバイトの連続があれば、その各々に対応する穴をコピー先
          ファイルに設けようとする。この動作が役に立つのは、コピー元
          ファイルが、穴空きファイルをサポートしていないファイルシステム
          にあるのに対し (たとえば、SGI IRIX 5.3 以前の `efs' ファイル
          システム)、コピー先ファイルは穴空きファイルをしっかりサポート
          するタイプのファイルシステムにある場合である。穴を作ることが
          できるのは、通常ファイルだけなので、コピー先が通常ファイル以外
          なら、`cp' がそのファイルを穴空きにしようと試みることもない。

    `never'
          コピー先ファイルを穴空きにしない。これは、`mkswap' コマンドで
          使用するファイルを作成するときに役に立つ。そうしたファイルには、
          穴があってはならないからである。

`--strip-trailing-slashes'
     SOURCE 引数の後ろにスラッシュが付いていたら、それを削除する。
     *Note Trailing slashes::.

`-s'
`--symbolic-link'
     コピー元がディレクトリ以外の場合、コピーする代わりに、シンボリック
     リンクを作成する。出力先ファイルをカレント・ディレクトリに作成する
     場合を除いて、コピー元ファイルの名前は、すべて (`/' で始まる) 絶対
     パス表記でなければならない。シンボリックリンクをサポートしていない
     システムでは、このオプションはエラーメッセージを出すだけである。

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b' によって作られる各バックアップファイルの後ろに SUFFIX を
     付ける。 *Note Backup options::.

`-t DIRECTORY'
`--target-directory=DIRECTORY'
     DIRECTORY を出力先ディレクトリに指定する。 *Note Target
     directory::.

`-T'
`--no-target-directory'
     最後のオペランドがディレクトリやディレクトリへのシンボリックリンク
     でも、それを特別扱いしない。 *Note Target directory::.

`-u'
`--update'
     ディレクトリ以外のものをコピーする際、それがコピー先にも存在し、
     しかもその更新日時 (modification time) がコピー元と同じか、より
     新しい場合、コピーを行わない。コピー元からコピー先へタイムスタンプを
     引き継がせている場合には、コピー元のタイムスタンプの精度を、コピー先
     のファイルシステム、及びタイプスタンプの更新に使われるシステムコール
     の精度に落とした上で、比較を行う。これは、同じコピー元とコピー先の
     ファイルに対して `cp -pu' コマンドを何回か実行する場合に、余計な
     コピー作業が起きるのを避けるためである。`--preserve=links' が一緒に
     指定されている場合は (たとえば、`cp -au' だとそうなる)、そちらが
     優先されることになる。その結果、コピー元でファイルが処理される順番
     によっては、コピー元のハードリンクを反映させるために、コピー先の
     より新しいファイルが置き換えられることもある。

`-v'
`--verbose'
     コピーを行う前に、コピーするファイル名を表示する。

`-x'
`--one-file-system'
     あるファイルシステムでコピーを始めた場合、別のファイルシステム
     にあるサブディレクトリをスキップする。ただし、マウントポイントの
     ディレクトリはコピーされる。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: dd invocation,  Next: install invocation,  Prev: cp invocation,  Up: Basic operations

11.2 `dd': ファイルの変換とコピー
============================================

`dd' はファイルをコピーする (デフォルトでは、標準入力から標準出力へ
コピーする)。その際、入出力のブロックサイズを変更することができる。
また、コピーと同時にデータ形式の変換を行うこともできる。

   書式:

     dd [OPERAND]...
     dd OPTION

   指定できるオプションは、`--help' と `--version' だけである。 *Note
Common options::.  `dd' では、以下のオペランドが使える。

`if=FILE'
     標準入力の代わりに、FILE から読み込む。

`of=FILE'
     標準出力の代わりに、FILE に書き出す。`conv=notrunc' が指定されて
     いない場合、`dd' は、出力を開始する前に、FILE を 0 バイトに
     (あるいは、`seek=' で指定されたサイズに) 短縮する。

`ibs=BYTES'
     入力ブロックサイズを BYTES にする。`dd' が 1 ブロック BYTES
     バイトで読み込みを行うようになる。デフォルトは 512 バイトである。

`obs=BYTES'
     出力ブロックサイズを BYTES にする。`dd' が 1 ブロック BYTES
     バイトで書き出しを行うようになる。デフォルトは 512 バイトである。

`bs=BYTES'
     入力、出力、両方のブロックサイズを BYTES にする。`dd' が 1
     ブロック BYTES バイトで読み書きを行うようになり、`ibs' や `obs'
     の指定は、あっても無効になる。さらに、データ変換を行う `conv'
     オプションが指定されていない場合には、入力は、それがブロックサイズ
     より小さくても、読み込まれるやいなや、出力にコピーされることになる。

`cbs=BYTES'
     変換ブロックサイズを BYTES にする。可変長のレコードを固定長の
     レコードに変換するときや (`conv=block')、その逆を行うとき
     (`conv=unblock')、固定長レコードの長さとして BYTES の値を使用する。

`skip=N'
     入力ファイルで `ibs' バイトのブロックを N 個読み飛ばしてから、
     コピーを行う。`iflag=skip_bytes' が指定されている場合は、N は
     ブロック数ではなく、バイト数と見なされる。

`seek=N'
     出力ファイルで `obs' バイトのブロックを N 個スキップしてから、
     コピーを行う。`oflag=seek_bytes' が指定されている場合は、 N は
     ブロック数ではなく、バイト数と見なされる。

`count=N'
     入力ファイルの末尾まで全部ではなく、`ibs' バイトのブロックを N 個
     だけ入力ファイルからコピーする。`iflag=count_bytes' が指定されて
     いる場合は、N はブロック数ではなく、バイト数と見なされる。

`status=WHICH'
     通常、`INFO' シグナルを受け取った場合や、`dd' が終了したときに、
     転送情報が標準エラーに出力される。WHICH を指定することで、どの
     情報を表示しないかを設定できる。

    `noxfer'
          転送速度や転送量の統計を表示しない。通常は、そうした情報が
          ステータス表示の最後の行になる。

    `none'
          情報メッセージを標準エラーに全く表示しない。エラーメッセージは
          通常どおり出力する。


`conv=CONVERSION[,CONVERSION]...'
     CONVERSION 引数 (複数可) で指定されたようにファイルを変換する。
     (コンマの前後にスペースを入れてはいけない。)

     CONVERSION には次のものが指定できる:

    `ascii'
          POSIX が規定している変換テーブルを使って、EBCDIC を ASCII に
          変換する。変換テーブル中の 256 バイトのすべてについて、 1 対
          1 の変換を行う。

    `ebcdic'
          ASCII を EBCDIC に変換する。これは `ascii' 変換の逆の動作で
          ある。

    `ibm'
          POSIX が規定しているもう一つの変換テーブルを使って、ASCII を
          EBCDIC の別の形式に変換する。こちらは 1 対 1 の変換ではない
          が、`~', `[', `]' について、よく使われる伝統的な慣行を反映
          している。

          `ascii', `ebcdic', `ibm' は、どれか一つしか指定できない。

    `block'
          入力 1 行あたり、`cbs' バイト分を出力する。入力中の改行は
          スペースに置き換え、`cbs' バイトに足りない分はスペースで
          埋める。

    `unblock'
          `cbs' バイトの大きさからなる各入力ブロックに対して、末尾にある
          スペースをすべて削除し、改行を追加する。

          `block' と `unblock' は、どちらか一方しか指定できない。

    `lcase'
          大文字を小文字に変換する。

    `ucase'
          小文字を大文字に変換する。

          `lcase' と `ucase' は、どちらか一方しか指定できない。

    `sparse'
          出力ブロックが NUL のみからなっているとき、それを書き出さず
          に、seek を試みる。穴空きファイル (sparse file) をサポート
          しているシステムでは、この動作は、出力ファイルを書き出して
          いるときに、穴空きの出力を作成することになる。このオプションを
          `conv=notrunc' や `oflag=append' と一緒に使う際は、気をつけ
          なければならない。`conv=notrunc' が付いていると、入力中の NUL
          ブロックに対応する位置にある、出力ファイル中の存在するデータは、
          そのまま保持されることになる。`oflag=append' を付けた場合は、
          seek は行っても効果がない。なお、`conv=sparse' では、出力先が
          ファイルではなく、デバイスの場合も、入力中の NUL ブロックは
          やはりコピーされない。そんなわけで、このオプションが最も役に
          立つのは、仮想デバイスや、前もって 0 で初期化したデバイスに
          対してである。

    `swab'
          入力された全バイトを 2 個づつ組にして、前後を入れ替える。GNU
          の `dd' は、他の `dd' とは違って、読み込むバイトが奇数個でも
          動作する。最後のバイトは （入れ替えるものがないので) そのまま
          コピーするのである。

    `sync'
          すべての入力ブロックに対して `ibs' の大きさになるまで、末尾を
          ゼロバイトで埋める。`block' や `unblock' と一緒に使用する
          と、ゼロバイトの代わりにスペースで埋める。


     以下の CONVERSION は、実のところファイルの扱いに関するフラグ
     なので、内的な処理には影響を及ぼさない。

    `excl'
          出力ファイルがすでに存在する場合は、実行に失敗する。
          言い換えれば、`dd' が出力ファイルを自分で作成しなければ
          ならないということである。

    `nocreat'
          出力ファイルを作成しない。言い換えれば、出力ファイルは前もって
          存在していなければならないということである。

          `excl' と `nocreat' は、どちらか一方しか指定できない。

    `notrunc'
          出力ファイルに対して短縮操作をしない (訳注: `of=FILE' の項を
          参照)。

    `noerror'
          読み込みエラーがあっても、作業を続行する。

    `fdatasync'
          コマンドを終了する直前に、出力データを同期させる。すなわち、
          出力データをディスクに実際に書き込む。

    `fsync'
          コマンドを終了する直前に、出力データだけでなく、メタデータも
          同期させる。すなわち、出力データとメタデータをディスクに
          実際に書き込む。


`iflag=FLAG[,FLAG]...'
     引数 FLAG によって指定されたフラグを使って、入力ファイルに
     アクセスする。(コンマの前後にスペースを入れてはいけない。)

`oflag=FLAG[,FLAG]...'
     引数 FLAG によって指定されたフラグを使って、出力ファイルに
     アクセスする。(コンマの前後にスペースを入れてはいけない。)

     フラグには次のものがある。どのオペレーティング・システムでも、
     すべてのフラグが使えるわけではない。

    `append'
          追加モードで書き込む。従って、何か別のプロセスが問題の
          ファイルに書き出している場合でも、`dd' の書き込みは、
          書き込むたびに、そのファイルの今現在の内容に追加されること
          になる。このフラグは出力に対してしか意味がない。なお、この
          フラグを `of=FILE' オペランドと組み合わせて使うのなら、
          `conv=notrunc' も一緒に指定した方がよい。さもないと、出力
          ファイルは、追加書き込みが始まる前に、短縮操作を受けること
          になる。

    `cio'
          データに対してコンカレント I/O (CIO) モードを使用する。この
          モードでは、ダイレクト I/O を行いつつ、同じファイルに対する
          すべての I/O は順番に行わなければならないという POSIX の
          要件は無視する。一つのファイルを CIO モードと標準的な方法の
          両方で同時にオープンすることはできない。

    `direct'
          データに対してダイレクト I/O を使用し、バッファ・キャッシュを
          介さないようにする。カーネルが read バッファや write バッファ
          のサイズに制限をかけていることがあるのに注意していただきたい。
          たとえば、出力先のファイルシステムが ext4 で、カーネルが linux
          ベースの場合、出力バッファのサイズが 512 の倍数でなければ、
          `oflag=direct' を指定すると、`EINVAL' で書き込みに失敗する。

    `directory'
          ファイルがディレクトリでなければ、実行に失敗する。ほとんどの
          オペレーティング・システムがディレクトリに対する I/O を許して
          いない。従って、このフラグが役に立つ機会はめったにない。

    `dsync'
          データに対して同期 I/O を使用する。出力ファイルについては、
          このフラグは、各書き込みごとに出力データをディスクに実際に
          書き込ませる。入力ファイルについてこのフラグが意味を持つかも
          しれないのは、読み込んでいるのがリモートのファイルであり、
          それが何か他のプロセスによって同期的に書き込まれているとき
          である。メタデータ (たとえば、最終アクセス日時や最終更新日時)
          は、必ずしも同期されない。

    `sync'
          データとメタデータに対して同期された I/O を使用する。

    `nocache'
          ファイルのデータ・キャッシュを廃棄する。count=0 の場合は、
          キャッシュが全部捨てられる。それ以外の場合は、ファイルの
          キャッシュのうち、処理の対象になる部分だけが捨てられる。
          また、count=0 のとき、キャッシュの廃棄に失敗すると、その旨
          メッセージが表示され、終了ステータスに反映する。以下に、
          使用法の例をいくつか挙げておく。

               # ファイル全体のキャッシュを捨てるように指示する。
               dd if=ifile iflag=nocache count=0

               # ファイル全体のキャッシュを確実に捨てる。
               dd of=ofile oflag=nocache conv=notrunc,fdatasync count=0

               # ファイル中の一部分のキャッシュを捨てる。
               dd if=ifile iflag=nocache skip=10 count=10 of=/dev/null

               # read-ahead キャッシュのみを使って、データを転送する。
               dd if=ifile of=ofile iflag=nocache oflag=nocache

    `nonblock'
          ノンブロッキング I/O を使用する。

    `noatime'
          ファイルのアクセス日時を更新しない。古いシステムの中には、
          エラーや警告も出さずに、このフラグを無視するものがある。
          そこで、このフラグを使用する前に、有効かどうか、お手元の
          ファイルで試してみるとよい。

    `noctty'
          入力 (または、出力) ファイルを `dd' の制御端末にしない。この
          フラグは、そのファイルが端末でなければ、効果がない。このフラグが
          全く効果を持たないホストが、たくさんある (たとえば、GNU/Linux
          ホストがそうである)。

    `nofollow'
          シンボリックリンクをたどらない。

    `nolinks'
          ファイルに複数のハードリンクがあれば、実行に失敗する。

    `binary'
          バイナリ I/O を使用する。このフラグは、バイナリ I/O と
          テキスト I/O を区別する非標準的なプラットフォームでしか
          効果がない。

    `text'
          テキスト I/O を使用する。このフラグが標準的なプラットフォーム
          で効果がないのは、`binary' と同様である。

    `fullblock'
          各ブロックが一杯になるまで入力から読み込む。`read' システム
          コールは、入力がブロックの分量に足らない場合、早めに戻って
          くることがある。そうした場合に、`read' の呼び出しを繰り返
          して、ブロックの残りを埋めようとする。このフラグは、`iflag'
          でのみ使える。

    `count_bytes'
          `count=' オペランドをブロック数ではなく、バイト数の指定と
          見なす。そうすることで、I/O ブロックサイズの倍数ではない
          長さが、指定できるようになるわけだ。このフラグは `iflag'
          でしか使用できない。

    `skip_bytes'
          `skip=' オペランドをブロック数ではなく、バイト数の指定と
          見なす。そうすることで、I/O ブロックサイズの倍数ではない
          オフセットが、指定できるようになるわけだ。このフラグは
          `iflag' でしか使用できない。

    `seek_bytes'
          `seek=' オペランドをブロック数ではなく、バイト数の指定と
          見なす。そうすることで、I/O ブロックサイズの倍数ではない
          オフセットが、指摘できるようになるわけだ。このフラグは
          `oflag' でしか使用できない。


     以上のフラグは、すべてのシステムでサポートされているわけではなく、
     サポートされていないシステムで使用しようとすると、`dd' に拒否
     される。標準入力から読み込んでいる場合や、標準出力に書き出して
     いる場合は、`nofollow' や `noctty' フラグは指定するべきではない。
     また、他のフラグ (たとえば `nonblock') は、対象となるファイルの
     ファイル・ディスクリプタに対する他のプロセスの動作に、`dd' が
     終了した後までも、影響を及ぼすかもしれない。


   上記中の数値を表す文字列  (N や BYTES) には、乗数を示す文字を後ろに
付けることができる。すなわち、`b'=512, `c'=1, `w'=2, `xM'=M といった
文字である (訳注: 最後のものは、10xM という表記は、10M と書くのと同じだ
ということ)。あるいは、`k'=1024 のような、ブロックサイズに付ける標準の
接尾辞の一つを続けてもよい (*note Block size::)。

   `bs=', `ibs=', `obs=', "`cbs=' を使って指定するブロックサイズは、
大きすぎない方がよい。数メガバイトを越える値は、一般的に言って無駄だし、
(ギガバイト ... エクサバイトを使ったときのように) 全く逆効果だったり、
エラーの元になったりする。

   データのオフセット位置やサイズが I/O ブロックサイズの倍数ではない
場合に、そうしたデータを処理するには、`skip_bytes', `seek_bytes',
`count_bytes' といったフラグを使用すればよい。あるいは、`dd' を別々に
呼び出すという伝統的な手法を使用することもできる。一例を挙げると、
以下のシェルコマンドは、1 ブロック を 512 KiB にして、ディスクと
テープの間でデータをコピーしている。ただし、ディスクの先頭にある 4 KiB
のラベルについては、保存も復元も行っていない。

     disk=/dev/rdsk/c0t1d0s2
     tape=/dev/rmt/0

     # ラベル以外のすべてをディスクからテープへコピーする。
     (dd bs=4k skip=1 count=0 && dd bs=512k) <$disk >$tape

     # テープからディスクへ書き戻す。ただし、ディスクのラベルには手を
     # 付けない。
     (dd bs=4k seek=1 count=0 && dd bs=512k) <$tape >$disk

   実行中の `dd' のプロセスに `INFO' シグナルを送ると、`dd' は入出力の
統計情報を標準エラーに書き出してから、コピー作業を続行する。以下の
例では、`dd' がバックグラウンドで動作し、1 千万ブロックのコピーを行って
いる。`kill' コマンドが実行されると、`dd' は実行途中の入出力統計を
表示する。そして、正常に作業を完了するか、`SIGINT' シグナルによって
キルされたとき、最終的な統計情報を出力する。

     $ dd if=/dev/zero of=/dev/null count=10MB & pid=$!
     $ kill -s INFO $pid; wait $pid
     3385223+0 records in
     3385223+0 records out
     1733234176 bytes (1.7 GB) copied, 6.42173 seconds, 270 MB/s
     10000000+0 records in
     10000000+0 records out
     5120000000 bytes (5.1 GB) copied, 18.913 seconds, 271 MB/s

   `INFO' シグナルが存在しないシステムでは、 環境変数 `POSIXLY_CORRECT'
が設定されていないかぎり、`dd' は `INFO' の代わりに `USR1' に反応する。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: install invocation,  Next: mv invocation,  Prev: dd invocation,  Up: Basic operations

11.3 `install': ファイルをコピーし属性をセットする
===================================================================

`install' はファイルをコピーするとき、ファイルのモードビット (訳注:
一般にアクセス権とか、許可属性と言われるもの) をセットし、可能ならば、
所有者やグループも設定する。

   書式:

     install [OPTION]... [-T] SOURCE DEST
     install [OPTION]... SOURCE... DIRECTORY
     install [OPTION]... -t DIRECTORY SOURCE...
     install [OPTION]... -d DIRECTORY...

   * ファイル名を二つ指定すると、`install' は最初のファイルを 2 番目の
     ファイルにコピーする。

   * `--target-directory' (`-t') オプションを指定した場合や、あるいは
     それを指定しないでも、最後のファイルがディレクトリであり、しかも
     `--no-target-directory' (`-T') オプションが指定されていない場合は、
     `install' は各 SOURCE ファイルを指定されたディレクトリに、SOURCE
     の名前でコピーする。

   * `--directory' (`-d') を指定すると、`install' は各 DIRECTORY を
     作成する。このとき、親ディレクトリが存在しなければ、それも
     作成する。作成される親ディレクトリのモードは、`-m' オプションの
     指定や現在の umask にかかわりなく、`u=rwx,go=rx' (755) になる。
     親ディレクトリの set-user-ID ビットや set-group-ID ビットの継承が
     どうなるかについては、注が示す節を参照すること。*Note Directory
     Setuid and Setgid::.

   `install' は `cp' に似ているが、コピー先ファイルの属性を自由に
設定できる点が違う。`install' は通常、Makefile の中で、プログラムを
目標のディレクトリにコピーするために使用される。`install' では、ファイル
をそれ自身にコピーすることはできない。

   `install' が拡張属性 (xattr) を保存することはない。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--backup[=METHOD]'
     *Note Backup options::.  そのままでは、上書きされるか、消去されて
     しまう各ファイルのバックアップを作成する。

`-C'
`--compare'
     インストール元とインストール先の対応するファイルを比較し、
     インストール先ファイルがインストール元と同じ内容で、しかも指定の
     所有者、グループ、許可属性、場合によっては SELinux コンテキストを
     持っているときは、インストール先を更新しない (訳注: 要するに、
     コピーが必要なときだけコピーするということ)。

`-c'
     無視する。Unix の古いバージョンの  `install' との互換性のために
     ある。

`-D'
     DEST の指定中に存在していない親ディレクトリがあれば、それを作成
     してから、SOURCE を DEST にコピーする。インストール先ディレクトリ
     が `--target-directory=DIR' によって指定されている場合は、この
     オプションは無視される。

`-d'
`--directory'
     まず、存在していない親ディレクトリがあれば作成し、それにデフォルトの
     属性を与える。それから、指定された各ディレクトリを作成し、所有者、
     グループ、許可属性を、コマンドラインで指定されたとおりに、または
     デフォルトの値に設定する。

`-g GROUP'
`--group=GROUP'
     インストールするファイルやディレクトリの所有グループを GROUP に
     設定する。デフォルトは、プロセスの現在のグループである。GROUP は、
     グループ名でも、グループの ID 番号でもよい。

`-m MODE'
`--mode=MODE'
     インストールするファイルやディレクトリのモードビットを MODE に
     設定する。MODE の指定は、`a=' (誰にもアクセスを許さない) を
     基点として行い、8 進数でも、`chmod' で使うようなシンボリック・
     モードでもよい (*note File permissions::)。デフォルトのモードは、
     `u=rwx,go=rx,a-s' である。すなわち、所有者には読み、書き、実行を
     許可し、グループとその他のユーザには読みと実行のみを許可、
     set-user-ID と set-group-ID は無効にする。このデフォルトは、`755'
     と全く同じではない。なぜなら、デフォルトの方は、ディレクトリに
     ついて set-user-ID や set-group-ID を引き継がず、無効にしている
     からである。 *Note Directory Setuid and Setgid::.

`-o OWNER'
`--owner=OWNER'
     `install' が適切な権限を持っている場合に (つまり、root 権限で
     実行されている場合に)、インストールするファイルやディレクトリの
     所有者を OWNER に設定する。デフォルトは `root' である。OWNER の
     指定は、ユーザ名でも、ユーザの ID 番号でもよい。

`--preserve-context'
     ファイルやディレクトリの SElinux セキュリティ・コンテキストを引き
     継ぐ。ファイルやディレクトリすべてのセキュリティ・コンテキストを
     引き継げなかった場合は、終了ステータスが 1 になる。SElinux が
     無効になっているときは、警告を出し、このオプションを無視する。

`-p'
`--preserve-timestamps'
     インストール先各ファイルの最終アクセス日時 (last access time) と
     最終更新日時 (last modification time) を、対応するインストール元
     各ファイルのそれぞれの日時に合わせる。このオプションを付けずに
     インストールした場合、各ファイルの最終アクセス日時と最終更新日時は、
     両方ともインストールした日時になる。インストール先ファイルの最終
     更新日時を、最後にインストールした日付ではなく、最後にビルドした
     日付の記録として使用したい場合、このオプションは便利である。

`-s'
`--strip'
     インストールされるバイナリの実行ファイルからシンボル・テーブルを
     取り除く。

`--strip-program=PROGRAM'
     バイナリからシンボル・テーブルを取り除くために使用するプログラムを
     指定する。

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b' によって作られる各バックアップファイルの後ろに SUFFIX を
     付ける。 *Note Backup options::.

`-t DIRECTORY'
`--target-directory=DIRECTORY'
     DIRECTORY を出力先ディレクトリに指定する。 *Note Target
     directory::.

`-T'
`--no-target-directory'
     最後のオペランドがディレクトリやディレクトリへのシンボリックリンク
     でも、それを特別扱いしない。 *Note Target directory::.

`-v'
`--verbose'
     コピーを行う前に、コピーするファイル名を表示する。

`-Z CONTEXT'
`--context=CONTEXT'
     作成するファイルやディレクトリに対して使用するデフォルトの SElinux
     セキュリティ・コンテキストを設定する。SElinux が無効になっている
     ときは、警告を出し、このオプションを無視する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: mv invocation,  Next: rm invocation,  Prev: install invocation,  Up: Basic operations

11.4 `mv': ファイルの移動 (名前の変更) を行う
============================================================

`mv' は、ファイル (やディレクトリ) の移動、または名前の変更を行う。

   書式:

     mv [OPTION]... [-T] SOURCE DEST
     mv [OPTION]... SOURCE... DIRECTORY
     mv [OPTION]... -t DIRECTORY SOURCE...

   * ファイル名を二つ指定すると、`mv' は最初のファイルを 2 番目の
     ファイルに移動する。

   * `--target-directory' (`-t') オプションを指定した場合や、あるいは
     それを指定しないでも、最後のファイルがディレクトリであり、しかも
     `--no-target-directory' (`-T') オプションが指定されていない場合は、
     `mv' は各 SOURCE ファイルを指定されたディレクトリに、SOURCE の
     名前で移動する。

   `mv' はいかなるタイプのファイルでも、一つのファイルシステムから
別のファイルシステムへ移動させることができる。fileutils パッケージの
バージョン `4.0' 以前では、`mv' がファイルシステム間を移動させる
ことができたのは、通常ファイルだけだった。それに対して、現在の `mv'
では、たとえば、スペシャル・デバイスファイルを含むディレクトリ階層の
全体を、あるパーティションから別のパーティションへ移動させることが
可能になっている。`mv' は、まず `cp -a' が使用するのと同じコードを
使って、指定されたディレクトリやファイルをコピーし、その後で (コピーに
成功した場合は) コピー元を削除する。コピーに失敗した場合は、移動先の
パーティションにすでにコピーした部分は消去することになる。仮に、ある
パーティションから別のパーティションに、3 個のディレクトリをコピー
しようとして、最初のディレクトリのコピーには成功したものの、2 番目の
ディレクトリのコピーに失敗したとしよう。その場合、最初のディレクトリ
は、移動先のパーティションに残るが、2 番目と 3 番目のディレクトリは、
元のパーティションに残ることになる。

   `mv' は拡張属性 (xattr) を常にコピーしようとする。この拡張属性は、
SELinux コンテキストや ACL、ケーパビリティであってもよい。拡張属性の
コピーに失敗したときは、`Operation not supported' 以外のすべての
警告が出力される。

   移動先ファイルがすでに存在し、それが普通なら書き込みのできないもの
である場合、標準入力が端末であり、`-f' や `--force' オプションが指定
されていなければ、`mv' はプロンプトを出して、ファイルを置き換えるか
どうか、ユーザに問い合わせる (ファイルの書き込み権限がなくても、自分
がそのファイルの所有者であったり、そのディレクトリの書き込み権限を
持っていたりすることは、ありえることである)。答えが肯定でなければ、
そのファイルはスキップされる。

   警告: 名前変更の対象 (または、移動元) がディレクトリへのシンボリック
リンクかもしれないときは、その名前を指定する際に、末尾にスラッシュを
付けてはいけない。さもないと、`mv' の動作は内部で使っている rename
システムコール次第なので、全く予想外のことが起きるかもしれないのだ。
Linux ベースの最近のカーネルを使っているシステムでは、`errno=ENOTDIR'
で実行に失敗する。しかし、他のシステムでは (少なくとも、FreeBSD 6.1 や
Solaris 10 では)、シンボリックリンクではなく、リンクが参照している
ディレクトリの名前の方を、警告なしで変更するのである。 *Note Trailing
slashes::.

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--backup[=METHOD]'
     *Note Backup options::.  そのままでは、上書きされるか、消去されて
     しまう各ファイルのバックアップを作成する。

`-f'
`--force'
     移動先のファイルを消去する前にプロンプトを出してユーザに尋ねない。
     `-i', `-f', `-n' オプションを同時に
     指定している場合は、最後に指定したもののみが効果を持つ。

`-i'
`--interactive'
     ファイルの許可属性に関係なく、存在する各移動先ファイルを上書きするか
     どうかを、プロンプトを出してユーザに尋ねる。答えが肯定でなければ、
     そのファイルはスキップされる。`-i', `-f', `-n' オプションを同時に
     指定している場合は、最後に指定したもののみが効果を持つ。

`-n'
`--no-clobber'
     存在するファイルを上書きしない。`-i', `-f', `-n' オプションを同時に
     指定している場合は、最後に指定したもののみが効果を持つ。
     このオプションは、`-b' や `--backup' オプションと一緒には使えない。

`-u'
`--update'
     ディレクトリ以外のものを移動する際、それが移動先にも存在して、
     しかもその更新日時 (modification time) が移動元と同じか、より
     新しい場合、移動を行わない。移動が別のファイルシステムに向かって
     行われる場合、タイムスタンプの比較は、移動元のタイムスタンプを
     移動先のファイルシステム、及びタイムスタンプの更新に使われる
     システムコールの精度に落とした上で行われる。これは、同じ移動元と
     移動先に対して、`mv -u' コマンドが何回か実行される場合に、コピー
     作業が繰り返されるのを避けるためである。

`-v'
`--verbose'
     移動する前に各ファイルの名前を表示する。

`--strip-trailing-slashes'
     SOURCE 引数の後ろにスラッシュが付いていたら、それを削除する。
     *Note Trailing slashes::.

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b' によって作られる各バックアップファイルの後ろに SUFFIX を
     付ける。 *Note Backup options::.

`-t DIRECTORY'
`--target-directory=DIRECTORY'
     DIRECTORY を出力先ディレクトリに指定する。 *Note Target
     directory::.

`-T'
`--no-target-directory'
     最後のオペランドがディレクトリやディレクトリへのシンボリックリンク
     でも、それを特別扱いしない。 *Note Target directory::.


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: rm invocation,  Next: shred invocation,  Prev: mv invocation,  Up: Basic operations

11.5 `rm': ファイルやディレクトリを削除する
===========================================================

`rm' は、指定された各ファイルを削除する。デフォルトでは、ディレクトリ
の削除は行わない。

   書式:

     rm [OPTION]... [FILE]...

   `-I' または `--interactive=once' オプションが指定されている場合に、
削除するファイルが 4 個以上あるか、あるいは `-r', `-R', `--recursive'
などのオプションが指定されていると、`rm' はプロンプトを出して、作業を
最後まで行うかどうか、ユーザに問い合わせる。答えが肯定でなければ、
コマンド全体が中止になる。

   それ以外の場合で、`-i' または `--interactive=always' オプションが
指定されている場合や、ファイルが書き込み不可のとき、標準入力が端末で、
しかも `--force' (`-f') オプションが指定されていない場合は、`rm' は
プロンプトを出して、そのファイルを削除するかどうか、ユーザに問い合わ
せる。答えが肯定でなければ、そのファイルをスキップする。

   ファイル名の最後の構成要素 (訳注: ファイル名 (いわゆるパス名) の
最後の / より後ろの部分) が `.' や `..' であるファイルを削除しようと
しても、`rm' はそれを実行しない。ユーザに問い合わせることもない。

   警告: `rm' を使って、ファイルを削除しても、たいていの場合、その
ファイルの内容を復元することが可能である。ファイルの内容が間違いなく
復元不可能であるとの、より一層の保証が欲しいのなら、`shred' コマンドの
使用をお考えになるとよい。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-d'
`--dir'
     指定されたディレクトリが空ならば、それを削除する。

`-f'
`--force'
     指定したファイルが存在しなかったり、ユーザが削除の対象を指定し
     なかったりしても、問題にしない (訳注: つまり、エラーにしない)。
     また、ユーザに問い合わせることも全くない。`--interactive' (`-i')
     オプションが前にあっても、それを無視する。

`-i'
     プロンプトを出して、各ファイルを削除するかどうか、ユーザに問い
     合わせる。答えが肯定でなければ、そのファイルをスキップする。
     `--force' (`-f') オプションが前にあっても、それを無視する。

`-I'
     4 個以上のファイルが指定された場合や、再帰的な削除が要求された
     場合に、プロンプトを出して、コマンドを続行するかどうか、ユーザに
     一度だけ尋ねる。`--force' (`-f') オプションが前にあっても、それを
     無視する。`--interactive=once' と同じである。

`--interactive [=WHEN]'
     問い合わせのプロンプトをいつ出すかを指定する。WHEN には以下の一つを
     指定するが、なくてもよい。
        * never - 問い合わせを全くしない。

        * once - 4 個以上のファイルが指定された場合や、再帰的な削除が
          要求された場合に、一度だけ問い合わせをする。`-I' と同じ。

        * always - 削除されるすべてのファイルに対して問い合わせをする。
          `-i' と同じ。
     `--interactive' に WHEN を指定しないのは、`--interactive=always' と
     同じである。

`--one-file-system'
     ディレクトリ階層を再帰的に削除する際に、コマンドラインで引数として
     指定したディレクトリが存在するのとは別のファイルシステム上にある、
     いかなるディレクトリも削除しない。

     このオプションが役に立つのは、ビルド用の "chroot" ディレクトリ
     階層を削除する場合である。通常、そうしたディレクトリ階層に重要な
     データは含まれていない。しかしながら、普段使っているスタートアップ・
     ファイルを利用しやすくするために、そうしたディレクトリ階層に
     `/home' を bind-mount するのは、珍しいことではない。問題は、`/home'
     のアンマウントを忘れやすいことである。アンマウントをやり忘れたまま、
     `rm -rf' を使って、通常使い捨てにする chroot 環境を削除しようと
     すると、`/home' 以下にあるすべてまで削除してしまうことになる。
     `--one-file-system' オプションを使えば、`rm' は警告を出した上で、
     他のファイルシステムにあるディレクトリをスキップしてくれる。
     当然ながら、`/home' と chroot 環境が同じファイルシステムにある
     場合は、このオプションを使っても、`/home' が助かるわけではない。

`--preserve-root'
     `--recursive' オプションと一緒に使うと、ルートディレクトリ (`/') を
     削除しようとする動きがあり次第、エラーになる。これがデフォルトの
     動作である。 *Note Treating / specially::.

`--no-preserve-root'
     再帰的に削除を行う際、`/' を特別扱いしない。コンピュータ上にある
     すべてのファイルを本当に削除したい場合以外、このオプションの使用は
     お勧めできない。 *Note Treating / specially::.

`-r'
`-R'
`--recursive'
     コマンドラインにリストされたディレクトリとその中身を再帰的に削除する。

`-v'
`--verbose'
     削除を行う前に、各ファイルの名前を表示する。


   よくある質問の一つに、名前が `-' で始まるファイルを削除するには、
どうしたらよいか、というものがある。GNU の `rm' では、`getopt' を
使用して引数の解析を行っているあらゆるプログラムと同様、`--' オプション
を使って、以下の引数はすべてオプションではない、と示すことが可能に
なっている。カレントディレクトリにある `-f' というファイルを削除する
には、次のどちらかをタイプすればよい。

     rm -- -f

あるいは、

     rm ./-f

   Unix の `rm' プログラムが、この用途に `-' を 1 個だけ使っていたのは、
getopt の標準シンタックスが開発される以前のことである。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: shred invocation,  Prev: rm invocation,  Up: Basic operations

11.6 `shred': セキュリティを向上させたファイルの削除
=======================================================================

`shred' はデバイスやファイルを上書きして、非常に高価なハードウェアを
もってしても、データの復元ができないようにする。

   通常、ファイルを削除しても (*note rm invocation::)、データが実際に
消去されるわけではない。単に、ファイルが格納されている場所をリストした
インデックスが破棄されるだけであり、そうすることで、そのデータの
格納場所が再利用可能になるのである。世の中には、インデックスの再構築を
試みる復元ソフト (undelete utilities) というものが存在する。そうした
ものは、ファイルの存在したスペースが再利用されていなければ、ファイルを
復元することができるのだ。

   頻繁に使われているシステムで、ディスクがほとんど一杯になっている
場合、スペースは数秒のうちに再利用されるかもしれない。だが、それを
確実に知る方法は全くないのだ。また、他人に見られては困るデータが
あったところで、見られても構わないデータでそのファイルを上書きして
しまえば、復元は絶対不可能だと考えたいかもしれない。

   しかしながら、そういうことをした後でも、ディスクを研究所に持ち
込んで、高感度の (そして高価な) 装置を山ほど使用すれば、上書きされた
データの下にある元のデータのかすかな「痕跡 (echoes)」を検出することが
可能なのだ。もし、データがたった一回しか上書きされていなかったら、
それはさほど難しいことでもない。

   データを復元できないように消去する最善の方法は、それが載っている
メディアを酸で破壊するとか、熱で溶かすとかすることである。フロッピー
ディスクのような廉価なリムーバブル・メディアの場合、それがよく使わ
れる方法だ。だが、ハードディスクは高価だし、熱で溶かすのも難しい。
そこで、`shred' ユーティリティは、物質的な破壊以外の方法で、同様の
効果を実現しようとするのである。

   そのためには、元のデータに与える損傷を最大にするように選ばれた
データパターンで繰り返し上書きするという方法が採られる。この方法は、
フロッピーディスクにも効果があるものの、パターンはハードディスクで
最も効果を上げるように工夫されたものだ。詳細については、ソースコード
や、第 6 回 USENIX セキュリティ・シンポジウム (San Jose, California,
July 22-25, 1996) の議事録にある Peter Gutmann の次の論文をご覧に
なっていただきたい。
`Secure Deletion of Data from Magnetic and Solid-State Memory'
(http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html)

   ここで心に銘記してしていただきたいのは、`shred' には非常に重要な
前提があるということである。すなわち、ファイルシステムはデータを、
それが存在する場所で上書きするものでなければならない。それは、こうした
操作を行うときの伝統的な方法であるが、最近のファイルシステムの設計には、
この前提を満たさないものが多い。そうした例外には、次のようなものがある。

   * ログ構造化 (log-structured) ファイルシステムや、ジャーナル化
     (journaled) ファイルシステム。ATX や Solaris で提供されている
     ようなものだ。JFS, ReiserFS, XFS, Ext3 (`data=journal' モードの
     場合), BFS, NTFS などが、「データ」のジャーナリングをするように
     設定されている場合もこれに当たる。

   * データを冗長化して書き込んだり、一部の書き込みに失敗することが
     あっても、動作し続けるファイルシステム。たとえば、RAID ベースの
     ファイルシステムだ。

   * Network Appliance の NFS サーバのように、スナップショットを作成する
     ファイルシステム。

   * NFS バージョン 3 のクライアントのように、一時領域にキャッシュを作る
     ファイルシステム。

   * 圧縮ファイルシステム。

   特に ext3 ファイルシステムについて言うと、上記の例外に当てはまるのは
(その結果、`shred' が限定された効果しか持たないのは)、`data=journal'
モードの場合だけである。これは、メタデータだけでなく、ファイルデータも
ジャーナリングするモードだ。`data=ordered' (デフォルト) と
`data=writeback' の両モードでは、`shred' は通常どおり役に立つ。ext3 の
ジャーナリング・モードを変更するには、mount のマニュアルに書いてある
ように (man mount)、`/etc/fstab' ファイルで問題のファイルシステムの
マウントオプションに `data=something' オプションを追加すればよい。

   ファイルシステムがどういう動作をしているか、よくわからない場合は、
データをそれが存在する場所で上書きしていないと考えておいた方がよい。
すなわち、そのファイルシステムでは、通常ファイルに対する `shred' の
動作は、信頼できないということである。

   一般的に言って、`shred' は、ファイルよりデバイスに対して使った方が
信頼できる。そうすれば、上に述べたファイルシステムの設計の問題を回避
できるからだ。しかしながら、`shred' のデバイスに対する使用も、必ずしも
全面的に信頼できるわけではない。たとえば、ほとんどのディスクが、バッド
セクターを使用に割り当てる領域から外して、アプリケーションから見えない
ようにしている。そこで、バッドセクターに他人に見られたくないデータが
ある場合、`shred' はそれを破壊できないことになる。

   `shred' は、バックアップに対して何の対処もしないのと全く同様、上記の
問題についても、検知しようともしないし、通知しようともしない。それでも、
`shred' はファイルに対して行うより、デバイスに対して行う方が信頼できる
ので、デフォルトでは、出力ファイルをサイズ 0 に短縮したり、削除したり
しないようになっている。このデフォルトは、ファイルよりデバイスに適した
動作なのである。デバイスは一般に短縮できないし、削除するべきでもない
からだ。

   最後になったが、バックアップやミラーの持つリスクも考慮した方がよい。
削除することのできないファイルのコピーが、ファイルシステムのバックアップ
やリモートのミラーに存在するかもしれないのだ。そして、そうしたものが
存在すれば、`shred' で破壊したファイルを後日復元することが可能になる。
だから、後で `shred' を使って抹消したくなるようなデータがある場合には、
そのバックアップやミラーがないことを確認するべきなのである。

     shred [OPTION]... FILE[...]

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-f'
`--force'
     必要ならば、ファイルの許可属性を無視して、上書きできるようにする。

`-NUMBER'
`-n NUMBER'
`--iterations=NUMBER'
     デフォルトで `shred' は、上書きを 3 回する。時間を節約するために、
     回数を減らすこともできるし、その方がよいと思えば、回数を増やすことも
     できる。25 回上書きすると、プログラムが内部に持っている上書き用の
     パターンのすべてが、少なくとも一回は使われたことになる。

`--random-source=FILE'
     上書きに使用するランダムデータのソースとして FILE を使用する。
     また、このランダムデータは、上書きパターンの順番を決めるのにも
     使用される。

`-s BYTES'
`--size=BYTES'
     ファイルの最初の BYTES バイトを shred 処理する。デフォルトは、
     ファイル全体の shred である。BYTES の後ろには、その何倍かを示す
     ために `K', `M', `G' といった、サイズの指定を付けることができる。
     *Note Block size::.

`-u'
`--remove'
     shred 処理したファイルを (可能ならば) サイズ 0 に短縮し
     (truncate)、その上で削除する。ファイルが複数のリンクを持って
     いる場合、削除されるのは、名前を指定されたリンクだけである。

`-v'
`--verbose'
     shred 処理が進行する間、更新される進行状態の情報のすべてを
     標準エラーに表示する。

`-x'
`--exact'
     デフォルトでは、`shred' は、ファイルの最後のブロックを完全に消す
     ために、通常ファイルのサイズを、ファイルシステムのブロックサイズの
     倍数に切り上げることになっている。この動作を抑制したかったら、
     `--exact' オプションを使用すればよい。すなわち、デフォルトでは、 1
     ブロック 512 バイトのシステムで 10 バイトの通常ファイルを shred
     すると、結果として 512 バイトのファイルが出来上がる。ところが、
     このオプションを使えば、shred はファイルの見かけのサイズを増加
     させないのである。

`-z'
`--zero'
     通常、`shred' は、最後の 1 回でもランダムデータを書き込む。
     そんなファイルがハードディスクにあると、(たとえば、暗号化された
     データに見えて) 目立つのではないかと思うのなら、あるいは、単に
     そっちの方がもっとすっきりしていると思うのなら、`--zero' オプション
     を指定して、もう一回、 すべて 0 ビットで上書きさせればよい。
     これは、`--iterations' オプションで指定した上書き回数のほかに、
     もう一回ということである。


   第 1 ドライブのフロッピーディスクに作成したファイルシステムを跡形
もなく消し去るには、次のコマンドを使えばよいだろう。このコマンドで
"1.44MB" (実際には 1440 KiB) のフロッピーを消去するには、約 20 分
かかる。

     shred --verbose /dev/fd0

   同様に、ハードディスクの選択したパーティションからすべてのデータを
消去するには、以下のコマンドを打ち込めばよい。

     shred --verbose /dev/sda5

   最近のディスクでは、1 回の書き込みで十分なはずだ。それならば、
書き込みを 3 回行うデフォルトの 3 分の 1 の時間ですむ。

     # 擬似ランダムデータを 1 回書き込む。デフォルトより 3 倍速い。
     shred --verbose -n1 /dev/sda5

   念のため、少なくとも 1 回は擬似ランダムデータで上書きをした方がよい。
言い換えると、つい使いたくなっても、`-n0 --zero' を使ってはいけない。
ディスク・コントローラの中には、すべてが 0 のブロックを書き込む際に、
処理の最適化を行っているものがあり、そのため、ブロック中のバイト
すべてがクリアされない恐れがあるからである。SSD の中には、まさにそう
いうことをするものがある。

   `-' という FILE は、標準出力を表している。これの使い道は、削除した
テンポラリ・ファイルを shred することである。たとえば、次のようにだ。

     i=$(mktemp)
     exec 3<>"$i"
     rm -- "$i"
     echo "Hello, world" >&3
     shred - >&3
     exec 3>&-

   しかしながら、`shred - >file' というコマンドを使っても、ファイルの
内容を shred することにはならない。なぜなら、シェルは `shred' を呼び
出す前に、ファイルをサイズ 0 に短縮 (truncate) してしまうからである。
`shred file'、あるいは (Bourne 互換シェルをお使いなら) `shred - 1<>file'
というコマンドを、代わりに使った方がよい。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Special file types,  Next: Changing file attributes,  Prev: Basic operations,  Up: Top

12 特殊なファイル型
***************************

この章では、特殊なタイプのファイルを作成するコマンドの説明を行う
(さらに `rmdir' の説明もするが、これはディレクトリという特殊な
ファイル型の一つを削除するコマンドである)。

   Unix 系統のオペレーティング・システムでは、ほかのオペレーティング・
システムと比べて、特殊なファイル型というものが著しく少ないが、それでも
普通のファイル ("normal files") がそうであるような、のっぺらぼうなバイト
ストリームとして、何でもかんでも扱えさえすればよいというものではない。
たとえば、ファイルを作成したり、削除したりするとき、システムはその情報
を記録しなければならないが、それはディレクトリ ("directory") -- これも
特殊なタイプのファイルである -- に書き込まれる。もし興味があれば、
ディレクトリを普通のファイルのように読むこともできるが、システムが
システムとしての役割を果たすためには、ディレクトリはそのファイル内容
であるバイトに、構造というか、何らかの秩序を持っていなければならない。
そういう意味で、ディレクトリは、「特殊な」タイプのファイルなのである。

   ディレクトリ以外の特殊なファイル型としては、名前付きパイプ (FIFO)、
シンボリックリンク、ソケット、それに、いわゆるスペシャルファイル
("special files") がある。

* Menu:

* link invocation::     システムコール link を使って、ハードリンクを作成する。
* ln invocation::       ファイル間のリンクを作成する。
* mkdir invocation::    ディレクトリを作成する。
* mkfifo invocation::   FIFO (名前付きパイプ) を作成する。
* mknod invocation::    ブロック型やキャラクタ型のスペシャルファイルを作成する。
* readlink invocation:: シムリンクの値、または正規化されたファイル名を表示する。
* rmdir invocation::    空のディレクトリを削除する。
* unlink invocation::   システムコール unlink を使って、ファイルを削除する。


File: coreutils-ja.info,  Node: link invocation,  Next: ln invocation,  Up: Special file types

12.1 `link': システムコール link を使って、ハードリンクを作成する
========================================================================================

`link' は、一度に 1 個のハードリンクを作成する。これは、システムが
提供する `link' 関数への必要最小のインターフェースである。 *Note Hard
Links: (libc)Hard Links.  従って、より一般に使われる `ln' コマンドの
ような、様々な付加機能をあえて備えていない (*note ln invocation::)。

   書式:

     link FILENAME LINKNAME

   FILENAME は、実在するファイルを指していなければならない。また、
LINKNAME は、実在するディレクトリ中の実在しないファイルを指していな
ければならない。`link' は、リンクを作成するために、`link (FILENAME,
LINKNAME)' をコールするだけである。

   GNU のシステムでは、このコマンドは、`ln --directory
--no-target-directory FILENAME LINKNAME' と同様に振る舞う。しかし、
`--directory' や `--no-target-directory' は、POSIX の規格にあるオプ
ションではないので、`link' の方が、実用上より可搬性がある。

   FILENAME がシンボリックリンクの場合、LINKNAME がシンボリックリンク
へのハードリンクになるか、シンボリックリンクの参照先へのハードリンクに
なるかは、規定されていない。望む方の動作をはっきり指定するには、`ln -P'
や `ln -L' を使用するべきである。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: ln invocation,  Next: mkdir invocation,  Prev: link invocation,  Up: Special file types

12.2 `ln': ファイル間のリンクを作成する
=====================================================

`ln' はファイル間のリンクを作成する。デフォルトではハードリンクを作成
するが、`-s' オプションを指定すると、シンボリックリンク ("soft" link
とも言う) を作ることになる。

   書式:

     ln [OPTION]... [-T] TARGET LINKNAME
     ln [OPTION]... TARGET
     ln [OPTION]... TARGET... DIRECTORY
     ln [OPTION]... -t DIRECTORY TARGET...

   * ファイル名を二つ指定すると、`ln' は 1 番目に対するリンクを 2 番目
     の名前で作成する。

   * TARGET のみを指定すると、`ln' はそのファイルに対するリンクを
     カレントディレクトリに作成する。

   * `--target-directory' (`-t') オプションを指定した場合や、あるいは
     それを指定しないでも、最後のファイルがディレクトリであり、しかも
     `--no-target-directory' (`-T') オプションが指定されていない場合は、
     `ln' は各 TARGET ファイルに対するリンクを、指定されたディレクトリに
     TARGET の名前で作成する。


   通常 `ln' は存在するファイルを削除しない。既存のファイルを無条件で
削除するには、`--force' (`-f') オプションを使う。また、ユーザに問い
合わせた上で削除するには、`--interactive' (`-i') オプションを使う。
既存のファイルを、名前を変更して残すには、`--backup' (`-b') オプション
を使用する。(訳注: これは、存在するファイルの名前をリンク名として使う
場合の話である。)

   ハードリンク ("hard link") というのは、存在するファイルが持つ別の名前
である。だから、リンクとオリジナルは、区別ができない。専門的な言い方を
すると、両者は同じ inode を共有するものである。inode には、ファイルに
関する情報がすべて含まれているので、全くのところ、inode こそファイル
であると言っても、過言ではない。たいていのシステムでは、ディレクトリに
対するハードリンクの作成は禁じられている。許可されているシステムでも、
それができるのは、スーパーユーザだけである (その場合でも、ファイル
システムにループが生じると、ほかの様々なユーティリティ・プログラムで
問題が起きるので、慎重にやらなければならない)。なお、ハードリンクは、
ファイルシステムの境界を越えることができない。(もっとも、ハードリンクに
対するこうした制限は、POSIX で規定されているわけではない。)

   それに対して、シンボリックリンク ("Symbolic links"、略称はシムリンク
"symlinks") は、特殊なファイル型の一つである (すべてのカーネルが
サポートしているわけではない。たとえば、System V release 3 やそれ
以前のシステムにはシムリンクが存在しない)。このファイル型では、
リンクファイルは、実際には別のファイルを、名前を使って参照している。
ほとんどのファイル操作において (ファイルのオープン、読み込み、書き
出しなど) シンボリックリンク・ファイルが渡された場合、カーネルは
自動的にリンクの参照を読み解いて ("dereferences")、リンクの参照先
を操作の対象にする。ただし、操作によっては (たとえば、ファイルの
削除)、参照先ではなく、リンクファイルそのものを対象にするものもある。
シムリンクの所有者やグループは、リンクを通して行われるファイルアクセス
に対して意味を持たないが、削除制限ビットが立っているディレクトリから
シンボリックリンクを削除する際には、かかわりを持ってくる。GNU の
システムでは、シムリンクのモードには意味がなく、変更することもでき
ない。だが、BSD システムの中には、モードが変更でき、ファイル名の解決に
おいてシムリンクをたどるかどうかに影響するものもある。 *Note Symbolic
Links: (libc)Symbolic Links.

   シンボリックリンクは、どんな文字列を含んでいてもよい。シンボリック
リンクに含まれる文字列が、実在するファイルの名前になっていないときは、
リンク切れ ("dangling symlink") が生ずる。リンク切れのシンボリック
リンクを作成することは、禁止されているわけではない。シムリンクの作成に
絶対パスを使うか、相対パスを使うかには、それぞれ一長一短がある。絶対
パスのシムリンクは、リンクファイルの存在するディレクトリが移動しても、
常に同じファイルを指す。もっとも、そのシムリンクが複数のマシンから
見えるような場合には (たとえば、ネットワークでつながったファイル
システムにあるような場合には)、リンクが指しているファイルは、必ずしも
同じではないかもしれない。相対パスのシンボリックリンクの方は、それが
存在しているディレクトリからの相対パスで参照先が決まる。そこで、
ネットワークでつながっているマシンからリンクファイルがアクセスされる
場合に、リンクと同じデバイス上に存在するファイルを、そのデバイスの
マウントポイントが何という名前かを気にせずに指すことができて、便利で
あることが多い。

   相対パスのシムリンクをカレントディレクトリ以外の場所に作成すると、
そのシムリンクが実際に指しているファイルは、同じ文字列がカレント
ディレクトリを基点として指しているファイルとは別のものになる。
そのため、ユーザの多くが、まずカレントディレクトリを変更して、相対
パスのシムリンクを作成する場所へ移動することを好んでいる。そうすれば、
タブ補完などのファイル名参照方法を用いて、シムリンクに格納する参照先の
適切な相対パスを見つけることができるからである。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-b'
`--backup[=METHOD]'
     *Note Backup options::.  そのままでは、上書きされるか、消去されて
     しまう各ファイルのバックアップを作成する。

`-d'
`-F'
`--directory'
     ユーザが適切な権限を持っていれば、ディレクトリに対するハードリンク
     を作成しようとしても許可する。とは言え、たぶんシステムによって禁止
     されているため、たとえスパーユーザでも失敗するだろう。

`-f'
`--force'
     リンクの作成先に、作成するリンクファイルと同名のファイルがすでに
     存在していたら、それを削除する。

`-i'
`--interactive'
     リンクの作成先に、作成するリンクファイルと同名のファイルがすでに
     存在していたら、削除するかどうか、ユーザに問い合わせる。

`-L'
`--logical'
     `-s' オプションが有効になっていないとき、リンク対象として指定
     されたファイル (訳注: 上記書式の TARGET) がシンボリックリンク
     ならば、シンボリックリンクそのものではなく、シンボリックリンクが
     参照しているファイルへのハードリンクを作成する。

`-n'
`--no-dereference'
     最後のオペランドがディレクトリに対するシンボリックリンクである
     とき、それをディレクトリとして特別扱いしない (訳注: すなわち、
     ディレクトリ内に TARGET と同名でリンクを作ることはしない)。
     むしろ、普通のファイルであるかのように扱う。

     リンクの作成先として指定されたのが (ディレクトリに対するシムリンク
     ではなく) 本物のディレクトリならば、曖昧なところは全くない。その
     ディレクトリ内にリンクを作るだけの話だ。ところが、指定された作成先
     が、ディレクトリに対するシムリンクの場合は、ユーザの要求を処理する
     のに、二つの行き方がある。`ln' は、通常のディレクトリを扱う場合と
     全く同じように作成先を扱って、そこにリンクを作成することができる。
     あるいは、作成先をディレクトリではないもの、すなわち、他ならぬシム
     リンクと見なすことも可能だ。後者の場合、`ln' は、新しいリンクを
     作成する前に、そのシムリンクを消去するなり、バックアップするなり
     しなければならない。`ln' のデフォルトは、作成先がディレクトリに
     対するシムリンクであっても、ディレクトリと全く同様に扱うことである。

     このオプションは、`--no-target-directory' (`-T') の弱いバージョン
     である。従って、両方のオプションを指定した場合、こちらは効果がない。

`-P'
`--physical'
     `-s' オプションが有効になっていないとき、リンク対象として指定
     されたファイル (訳注: 上記書式の TARGET) がシンボリックリンク
     ならば、シンボリックリンクそのものへのハードリンクを作成する。
     そういった動作をカーネルがサポートしていないプラットホームでは、
     このオプションを指定すると、リンク対象のシンボリックリンクと全く
     同じ内容を持つシンボリックリンクが作成される。このとき、シンボ
     リックリンクの内容に手が加えられることは決してないので、どちらの
     シンボリックリンクを使って行われるファイル名の解決も、シンボリック
     リンクへのハードリンクが作成された場合と結局同じになる。

`-r'
`--relative'
     リンクファイルを置く場所を基点とする相対パスのシンボリックリンクを
     作成する。

     用例:

          ln -srv /a/file /tmp
          '/tmp/file' -> '../a/file'

     *Note realpath invocation::.  `realpath' を使えば、相対パスを
     生成する際に、もっと複雑なことができる。

`-s'
`--symbolic'
     ハードリンクではなく、シンボリックリンクを作る。このオプションは、
     シンボリックリンクをサポートしていないシステムでは、エラー・
     メッセージを表示するだけである。

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b' によって作られる各バックアップファイルの後ろに SUFFIX を
     付ける。 *Note Backup options::.

`-t DIRECTORY'
`--target-directory=DIRECTORY'
     DIRECTORY を出力先ディレクトリに指定する。 *Note Target
     directory::.

`-T'
`--no-target-directory'
     最後のオペランドがディレクトリやディレクトリへのシンボリックリンク
     でも、それを特別扱いしない。 *Note Target directory::.

`-v'
`--verbose'
     リンクの作成に成功した後で、各ファイルの名前を表示する。


   `-L' と `-P' の両方を指定すると、最後に指定したものが効果を持つ。
さらに `-s' も指定した場合は、エラーや警告は出ないが、`-L' や `-P' は
無視される。`-L' と `-P' のどちらのオプションも指定しない場合、`ln' の
この実装では、システムの `link' 関数がシンボリックリンクに対するハード
リンクをサポートしていれば (たとえば、GNU のシステム)、デフォルトの
動作は `-P' になる。`link' 関数がシンボリックリンクをたどるものならば
(たとえば、BSD)、デフォルトの動作は `-L' である。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例:

     悪い例:

     # カレントディレクトリにあるファイル a を指す ../a というリンクを
     # 作成する。実のところ役に立たない。../a が自分自身を指すリンクに
     # なってしまうからだ。
     ln -s a ..

     よりよい例:

     # 頭がこんがらかってしまわないように、シムリンクを作成する前に、
     # リンクを作るディレクトリに移動する。
     cd ..
     ln -s adir/a .

     悪い例:

     # 絶対パスによるリンク対象の指定は、リンク対象の位置が変わると、
     # 役に立たない。
     ln -s $(pwd)/a /some/dir/

     よりよい例:

     # 相対パスによるリンク対象の指定は、リンクやその対象を含む
     # ディレクトリが移動しても、両者の相対的な位置関係が変わらない
     # かぎり、問題がない。また、ネットワークでつながったファイル
     # システム間でも通用する。
     ln -s afile anotherfile
     ln -s ../adir/afile yetanotherfile


File: coreutils-ja.info,  Node: mkdir invocation,  Next: mkfifo invocation,  Prev: ln invocation,  Up: Special file types

12.3 `mkdir': ディレクトリを作成する
===============================================

`mkdir' は、指定された名前でディレクトリを作成する。

   書式:

     mkdir [OPTION]... NAME...

   `mkdir' は、NAME で指定された各ディレクトリを、指定された順番で
作成する。NAME がすでに存在していると、エラーになり、その旨メッセージ
を出すが、NAME がすでに存在していても、`-p' オプションが指定され、NAME
がディレクトリの場合は、エラーにならない。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-m MODE'
`--mode=MODE'
     作成するディレクトリの許可属性ビットを MODE に設定する。MODE には
     `chmod' と同じ書式を使用し、`a=rwx' (すべてのユーザに、読み、書き、
     実効を許可する) を基点とする。*Note File permissions::.

     通常、ディレクトリには、作成された時点で、要求したとおりのファイル
     モードビットが付く。GNU の拡張として、MODE で特殊モードビットも指定
     できるが、その場合、ディレクトリは存在しているが、特殊モードビット
     は要求どおりではないという、時間の隙間が生じるかもしれない。ディレ
     クトリの set-user-ID ビットと set-group-ID ビットが、このオプション
     を使って変更しない場合にどのように継承されるかについては、次の節を
     参照していただきたい。*Note Directory Setuid and Setgid::.

`-p'
`--parents'
     各引数について、存在していない親ディレクトリがあれば、それを作成し、
     その許可属性ビットを、`u+wx' になるように調整した umask を基にして
     設定する。親ディレクトリがすでに存在している場合は、このオプション
     は何もせず、その許可属性ビットを変更することもない。

     新たに作成するいかなる親ディレクトリの許可属性ビットも、`u+wx'
     を含むある一定の値に設定するには、`mkdir' を実行する前に、umask
     を設定すればよい。たとえば、`(umask u=rwx,go=rx; mkdir -p P/Q)'
     というシェルのコマンドで `P' という親ディレクトリを作れば、その
     許可属性ビットは `u=rwx,go=rx' になる。また、親ディレクトリに特殊
     モードビットも設定するには、`chmod' を `mkdir' の後で実行すれば
     よい。新たに作成される親ディレクトリの set-user-ID ビットと
     set-group-ID ビットがどのように継承されるかについては、次の節を
     参照していただきたい。 *Note Directory Setuid and Setgid::.

`-v'
`--verbose'
     ディレクトリを作成するごとに、メッセージを表示する。`--parents'
     と併せて使うと、大変便利である。

`-Z CONTEXT'
`--context=CONTEXT'
     作成するディレクトリに対して使用する、デフォルトの  SELinux
     セキュリティ・コンテキストを設定する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: mkfifo invocation,  Next: mknod invocation,  Prev: mkdir invocation,  Up: Special file types

12.4 `mkfifo': FIFO (名前付きパイプ) を作成する
===========================================================

`mkfifo' は、指定された名前で FIFO (名前付きパイプ "named pipes"
とも言う) を作成する。

   書式:

     mkfifo [OPTION] NAME...

   "FIFO" は特殊なファイル型の一つであり、これを利用すると、独立した
プロセスの間でデータのやりとりが可能になる。片方のプロセスが FIFO を
書き出し用にオープンし、もう一方のプロセスが読み込み用にオープンする。
そうすると、シェルなどにある普通の名前のない (anonymous) パイプを
使ったときのように、データを一方から他方へ流すことができるのである。

   このプログラムでは、以下のオプションが使える。参照: *note Common
options::.

`-m MODE'
`--mode=MODE'
     作成する FIFO の許可属性を MODE にする。MODE は `chmod' で
     使用するのと同じシンボル表記であり、`a=rw' (すべてのユーザに、
     読み、書きを許可する) を基点として使う。MODE で指定するのは、
     ファイルの許可属性ビットのみにするべきである。 *Note File
     permissions::.

`-Z CONTEXT'
`--context=CONTEXT'
     作成する FIFO に対して使用する、デフォルトの SELinux セキュリティ・
     コンテキストを設定する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: mknod invocation,  Next: readlink invocation,  Prev: mkfifo invocation,  Up: Special file types

12.5 `mknod': ブロック型やキャラクタ型のスペシャルファイルを作成する。
==================================================================================================

`mknod' は、指定された名前で FIFO、キャラクター・スペシャルファイル、
ブロック・スペシャルファイルを作成する。

   書式:

     mknod [OPTION]... NAME TYPE [MAJOR MINOR]

   これまでに使ってきた「特殊なファイル型 ("special file type"」
という言い回しとは違って、「スペシャルファイル ("special file")」
という用語には、Unix では技術的な意味が存在する。すなわち、それは、
データを生成したり、受け取ったりできるもののことである。たいていの
場合、それはハードウェアという物理的なものを指し、たとえば、プリンタ
やディスクがそれに当たる。(なお、そうしたスペシャルファイルは、通常、
システムの設定時に作られる。) `mknod' は、このタイプのファイルを
作成するコマンドである。そうしたデバイスには、そこから一度に 1 文字 (a
character) づつしか読むことのできないものもあれば、一度に 1 ブロックを
(すなわち、たくさんの character を) 読み込むことのできるものもある。
それ故、スペシャルファイルには、ブロック・スペシャルファイル ("block
special" files) とキャラクタ・スペシャルファイル ("character special"
files) があると言われるのである。

   シェルの組み込み機能の `mknod' やエイリアスのために、`mknod' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `mknod' を起動すればよい (すなわち、 `env
mknod ...' のようにだ)。

   NAME に続く引数では、作成するファイルのタイプを指定する。

`p'
     FIFO を作成する

`b'
     ブロック・スペシャルファイルを作成する

`c'
     キャラクタ・スペシャルファイルを作成する


   ブロック型やキャラクタ型のスペシャルファイルを作成する際には、
ファイルタイプに続いて、メージャー・デバイス番号とマイナー・デバイス
番号を指定する必要がある。メージャーやマイナーのデバイス番号が `0x' や
`0X' で始まっていれば、番号は 16 進数と見なされる。`0' で始まっていれば
8 進数、それ以外の場合は 10 進数である。

   このプログラムでは、以下のオプションが使える。参照: *note Common
options::.

`-m MODE'
`--mode=MODE'
     作成するファイルの許可属性を MODE にする。MODE は `chmod' で
     使用するのと同じシンボル表記であり、`a=rw' を基点として使う。 MODE
     で指定するのは、ファイルの許可属性ビットのみにするべきである。
     *Note File permissions::.

`-Z CONTEXT'
`--context=CONTEXT'
     作成するファイルに対して使用する、デフォルトの SELinux
     セキュリティ・ コンテキストを設定する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: readlink invocation,  Next: rmdir invocation,  Prev: mknod invocation,  Up: Special file types

12.6 `readlink': シムリンクの値、または正規化されたファイル名を表示する
==================================================================================================

`readlink' には、二つの動作モードがある。

`Readlink モード'
     このモードでは、`readlink' は、指定されたシンボリックリンクの値を
     表示する。引数がシンボリックの名前以外だったときは、何も出力せず、
     0 以外の終了コードで終了する。

`Canonicalize (正規化) モード'
     このモードでは、`readlink' は、指定されたファイルの絶対パスによる
     名前を表示する。その絶対パスには、`.' や `..' といった構成要素や
     重複するパスの区切り (`/')、シンボリックリンクは含まれない。


     readlink [OPTION] FILE

   デフォルトでは、`readlink' は readlink モードで動作する。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-f'
`--canonicalize'
     canonicalize モードで動かす。ファイル名を構成する要素のうち、最後の
     要素以外のどれかが、存在しなかったり、利用できなかったりすると、
     `readlink' は何も出力せず、0 以外の終了コードで終了する。引数の
     末尾のスラッシュは無視される。

`-e'
`--canonicalize-existing'
     canonicalize モードで動かす。ファイル名を構成する要素に、存在しな
     かったり、利用できなかったりするものが一つでもあれば、`readlink' は
     何も出力せず、 0 以外の終了コードで終了する。ファイル名のの末尾に
     スラッシュを付けると、その名前はディレクトリであるという指定になる。

`-m'
`--canonicalize-missing'
     canonicalize モードで動かす。ファイル名を構成する要素に、存在しな
     かったり、利用できなかったりするものがあれば、`readlink' はそれを
     ディレクトリとして処理する。

`-n'
`--no-newline'
     出力の末尾に改行を付けない。

`-s'
`-q'
`--silent'
`--quiet'
     ほとんどのエラーメッセージを出さないようにする。

`-v'
`--verbose'
     エラーメッセージを表示する。


   `readlink' ユーティリティが初めて登場したのは、OpenBSD 2.1. だった。

   `realpath' コマンドをオプションなしで使うと、canonicalize モードの
`readlink' と同じ動作をする。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: rmdir invocation,  Next: unlink invocation,  Prev: readlink invocation,  Up: Special file types

12.7 `rmdir': 空のディレクトリを削除する
=====================================================

`rmdir' は、空のディレクトリを削除する。

   書式:

     rmdir [OPTION]... DIRECTORY...

   引数 DIRECTORY が実在する空のディレクトリを指していない場合、
エラーになる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`--ignore-fail-on-non-empty'
     ディレクトリの削除に失敗しても、その理由が単にディレクトリが空では
     ないせいならば、その失敗を無視する。

`-p'
`--parents'
     DIRECTORY を削除するとき、DIRECTORY を構成する各要素の削除を
     試みる。そこで、たとえば、`rmdir -p a/b/c' は、`rmdir a/b/c a/b a'
     と同じになる。従って、そうしたディレクトリのどれかが空ではないこと
     が判明すると、動作に失敗する。動作に失敗しても、エラーメッセージを
     出して失敗のステータスで終了しないようにするには、
     `--ignore-fail-on-non-empty' オプションを使えばよい。

`-v'
`--verbose'
     DIRECTORY の削除に成功するごとに、その旨メッセージを出す。


   空ではないディレクトリを (再帰的に) 削除する方法については、`rm'
コマンドの説明を参照していただきたい。*Note rm invocation::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: unlink invocation,  Prev: rmdir invocation,  Up: Special file types

12.8 `unlink': システムコール unlink を使って、ファイルを削除する
======================================================================================

`unlink' は、指定された 1 個のファイル名の削除を行う。これは、
システムが提供する `unlink' 関数への必要最小のインターフェース
である。*Note Deleting Files: (libc)Deleting Files.
従って、より一般に使われる `rm' コマンドのような、様々な付加機能を
あえて備えていない (*note rm invocation::)。

   書式:

     unlink FILENAME

   システムによっては、`unlink' を使って、ディレクトリの名前を削除
できるものもある。また、それができるのは、特権を持ったユーザだけである
システムもある。GNU のシステムでは、`unlink' は、ディレクトリの名前を
全く削除できない。

   `unlink' コマンドは、`--help' と `--version' オプションを認識する。
名前が `-' で始まるファイルを削除するには、名前の前に `./' を付ければ
よい。たとえば、`unlink ./--help' のようにだ。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Changing file attributes,  Next: Disk usage,  Prev: Special file types,  Up: Top

13 ファイルの属性変更
******************************

ファイルについては、内容と名前とファイル型 (*note Special file types::)
で、すべてが尽くされるわけではない。ファイルには、他の情報も存在する。
たとえば、所有者 (ユーザ ID)、グループ (グループ ID)、アクセス権
(そのファイルに対して、所有者には何ができ、グループに属するユーザには
何ができ、それ以外の一般ユーザには何ができるか)、様々なタイムスタンプ、
といった情報も存在するのである。そうしたものは、一まとめにして、
ファイルの属性 ("attributes") と呼ばれている。

   以下のコマンドは、ファイルの属性を変更する。

* Menu:

* chown invocation::         ファイルの所有者やグループを変更する。
* chgrp invocation::         ファイルのグループを変更する。
* chmod invocation::         アクセス権を変更する。
* touch invocation::         ファイルのタイムスタンプを変更する。


File: coreutils-ja.info,  Node: chown invocation,  Next: chgrp invocation,  Up: Changing file attributes

13.1 `chown': ファイルの所有者やグループを変更する
====================================================================

`chown' は、指定された各 FILE の所有者や所有グループを NEW-OWNER に
変更する。所有者とグループを、存在する参照用ファイル (reference file)
のそれと同じものに変更することもできる。

   書式:

     chown [OPTION]... {NEW-OWNER | --reference=REF_FILE} FILE...

   NEW-OWNER では、新しい所有者やグループを以下のような形で指定する
(`:' の前後に空白を入れてはいけない)。

     [OWNER] [ : [GROUP] ]

   細かく説明しよう。

OWNER
     OWNER (ユーザ名、またはユーザ ID 番号) だけが指定されている場合は、
     そのユーザが指定された各ファイルの所有者になる。ファイルの
     グループは変化しない。

OWNER`:'GROUP
     OWNER の後に、コロンと GROUP (グループ名、またはグループ ID 番号)
     が、間に空白をはさまずに続く場合は、ファイルの所有グループも
     (GROUP に) 変更される。

OWNER`:'
     OWNER の後ろにコロンがあるのみで、グループ名が続かない場合は、
     そのユーザがファイルの所有者になり、ファイルのグループは、OWNER
     のログイン・グループに変更される。

`:'GROUP
     コロンとそれに続く GROUP のみが指定され、所有者が省略されている
     場合は、ファイルのグループだけが変更される。この場合、`chown'
     は、`chgrp' と同じ動作をするわけだ。

`:'
     コロンのみが指定されている場合や、NEW-OWNER に何も指定されていない
     場合は、所有者もグループも変更されない。


   OWNER や GROUP にユーザ ID 番号やグループ ID 番号を使用する場合は、
番号の頭に `+' を付ければ、ID 番号だと明示することができる。 *Note
Disambiguating names and IDs::.

   古めのスクリプトの中には、区切りの印として `:' ではなく、`.' を
今だに使っているものがあるかもしれない。POSIX 1003.1-2001 (*note
Standards conformance::) では、これに対するサポートを要求していないが、
後方互換のために、GNU の `chown' では、曖昧さが生じないかぎり、`.' の
使用をサポートしている。とは言え、新しく書くスクリプトでは、`.' の
使用を避けるべきである。他のシステムでも使えるとはかぎらないし、また、
OWNER`.'GROUP という全体が、名前に `.' を含むユーザを指していたり
すると、不都合が生じるからだ。

   `chown' コマンドを実行すると、set-user-ID ビットや set-group-ID
ビットが消えてしまうことがある。そうしたことが起きるかどうかは、裏で
動いている `chown' システムコールのポリシーや機能次第であり、その
ために、システムによっては行われることがあるファイルモードの変更が、
`chown' コマンドのコントロール外になることがあるのだ。たとえば、
しかるべき特権を持ったユーザが実行した場合や、問題のビットが実行権
とは関係のない何か別の機能 (強制ロックなど) を表している場合には、
`chown' コマンドの実行でそうしたビットが変わらないこともありえる。
よくわからない場合は、裏で動いているシステムの動作を調べるとよい。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--changes'
     所有者の変更が実際に行われた各 FILE について、何を実行したかを
     詳しく表示する。

`-f'
`--silent'
`--quiet'
     所有者を変更できないファイルがあっても、エラーメッセージを表示
     しない。

`--from=OLD-OWNER'
     FILE が OLD-OWNER で指定された属性を現在持っているときにのみ、
     その所有者を変更する。OLD-OWNER の書式は、上記の NEW-OWNER と同じ
     である。このオプションは、ファイルの不正使用が可能になる時間を
     大幅に狭めるという点で、主としてセキュリティの見地から役に立つ。
     一例を挙げると、この種のオプションを使わない場合、ユーザの ID
     番号の変更を、そのユーザのファイルに反映させるために、`root' は
     次のようなコマンドを実行するかもしれない。

          find / -user OLDUSER -print0 | xargs -0 chown -h NEWUSER

     しかし、これは危険なことである。なぜなら、`find' が存在する
     ファイルの所有者を検査するときと、`chown' が実際に実行される
     ときとの間にある時間差は、かなり大きいかもしれないからだ。この
     時間差を小さくする方法の一つは、ファイルが見つかるごとに、`chown'
     を実行することだろう。

          find / -user OLDUSER -exec chown -h NEWUSER {} \;

     しかし、動作の対象になるファイルがたくさんあると、この方法は
     非常に時間がかかる。`--from=OLD-OWNER' オプションを使う方が、
     完璧とまでは言えないにしても、より安全である (時間差がさらに
     小さくなるので)。

          chown -h -R --from=OLDUSER NEWUSER /

`--dereference'
     シンボリックリンクそのものを動作の対象とせず、リンクが指している
     ものを動作の対象にする。これがデフォルトである。

`-h'
`--no-dereference'
     シンボリックリンクが指しているものではなく、シンボリックリンク
     そのものを動作の対象にする。このモードは、システムコール `lchown'
     に依存している。システムコール `lchown' を提供していないシステム
     では、コマンドラインで指定されたファイルがシンボリックリンクだと、
     `chown' は実行に失敗する。なお、再帰的にディレクトリ階層をたどって
     いる際にシンボリックリンクに出会っても、デフォルトでは診断メッセージ
     を表示しない。ただし、`--verbose' を指定しているときは別なので、
     そちらの説明も参照していただきたい。

`--preserve-root'
     ルートディレクトリ (`/') を再帰的に変更しようとする動きがあり次第、
     エラーになる。`--recursive' オプションを指定していない場合、
     このオプションは効果がない。 *Note Treating / specially::.

`--no-preserve-root'
     `--preserve-root' オプションが前にあれば、その効果を無効にする。
     *Note Treating / specially::.

`--reference=REF_FILE'
     各 FILE の所有者とグループを REF_FILE のそれと同じものに変更する。
     REF_FILE がシンボリックリンクの場合は、シンボリックリンクの
     所有者とグループではなく、リンクが指しているファイルの所有者と
     グループを使用する。

`-v'
`--verbose'
     処理したすべてのファイルについてメッセージを表示する。システム
     コール `lchown' を持っていないシステムで、再帰的にディレクトリ
     階層をたどっている際にシンボリックリンクに出会った場合は、
     `--no-dereference' が有効になっていれば、「シンボリックリンクも
     その参照先も変更しない」というメッセージを出す。

`-R'
`--recursive'
     ディレクトリとその中身の所有者を再帰的に変更する。

`-H'
     `--recursive' (`-R') オプションが指定されている場合に、コマンド
     ラインで指定された引数がディレクトリへのシンボリックリンクならば、
     それをたどる。 *Note Traversing symlinks::.

`-L'
     ディレクトリ階層を再帰的にたどる際に、ディレクトリへのシンボリック
     リンクに出会ったら、必ずそれをたどる。 *Note Traversing symlinks::.

`-P'
     シンボリックリンクを一切たどらない。これが、`-H', `-L', `-P' の
     どれも指定されていないときの、デフォルトである。 *Note Traversing
     symlinks::.


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例:

     # /u の所有者を "root" に変更する。
     chown root /u

     # 同様だが、グループも "staff" に変更する。
     chown root:staff /u

     # /u 及び、それ以下にあるファイルの所有者を "root" に変更する。
     chown -hR root /u


File: coreutils-ja.info,  Node: chgrp invocation,  Next: chmod invocation,  Prev: chown invocation,  Up: Changing file attributes

13.2 `chgrp': ファイルの所有グループを変更する
==============================================================

`chgrp' は、指定された各 FILE の所有グループを GROUP に変更する (GROUP
は、グループ名でもグループ ID 番号でもよい)。所有グループを、存在する
参照用ファイル (reference file) のグループと同じものに変更することも
できる。

   書式:

     chgrp [OPTION]... {GROUP | --reference=REF_FILE} FILE...

   GROUP にグループ ID 番号を使用する場合は、番号の頭に `+' を付ければ、
ID 番号だと明示することができる。 *Note Disambiguating names and IDs::.

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--changes'
     グループの変更が実際に行われた各 FILE について、何を実行したかを
     詳しく表示する。

`-f'
`--silent'
`--quiet'
     グループを変更できないファイルがあっても、エラーメッセージを
     表示しない。

`--dereference'
     シンボリックリンクそのものを動作の対象とせず、リンクが指している
     ものを動作の対象にする。これがデフォルトである。

`-h'
`--no-dereference'
     シンボリックリンクが指しているものではなく、シンボリックリンク
     そのものを動作の対象にする。このモードは、システムコール `lchown'
     に依存している。システムコール `lchown' を提供していないシステム
     では、コマンドラインで指定されたファイルがシンボリックリンクだと、
     `chgrp' は実行に失敗する。なお、再帰的にディレクトリ階層をたどって
     いる際にシンボリックリンクに出会っても、デフォルトでは診断メッセージ
     を表示しない。ただし、`--verbose' を指定しているときは別なので、
     そちらの説明も参照していただきたい。

`--preserve-root'
     ルートディレクトリ (`/') を再帰的に変更しようとする動きがあり次第、
     エラーになる。`--recursive' オプションを指定していない場合、
     このオプションは効果がない。 *Note Treating / specially::.

`--no-preserve-root'
     `--preserve-root' オプションが前にあれば、その効果を無効にする。
     *Note Treating / specially::.

`--reference=REF_FILE'
     各 FILE のグループを REF_FILE のグループと同じものに変更する。
     REF_FILE がシンボリックリンクの場合は、シンボリックリンクの
     グループではなく、リンクが指しているファイルのグループを使用する。

`-v'
`--verbose'
     処理したすべてのファイルについてメッセージを表示する。システム
     コール `lchown' を持っていないシステムで、再帰的にディレクトリ
     階層をたどっている際にシンボリックリンクに出会った場合は、
     `--no-dereference' が有効になっていれば、「シンボリックリンクも
     その参照先も変更しない」というメッセージを出す。

`-R'
`--recursive'
     ディレクトリとその中身の所有グループを再帰的に変更する。

`-H'
     `--recursive' (`-R') オプションが指定されている場合に、コマンド
     ラインで指定された引数がディレクトリへのシンボリックリンクならば、
     それをたどる。 *Note Traversing symlinks::.

`-L'
     ディレクトリ階層を再帰的にたどる際に、ディレクトリへのシンボリック
     リンクに出会ったら、必ずそれをたどる。 *Note Traversing symlinks::.

`-P'
     シンボリックリンクを一切たどらない。これが、`-H', `-L', `-P' の
     どれも指定されていないときの、デフォルトである。 *Note Traversing
     symlinks::.


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例:

     # /u のグループを "staff" に変更する。
     chgrp staff /u

     # /u 及び、それ以下にあるファイルのグループを "staff" に変更する。
     chgrp -hR staff /u


File: coreutils-ja.info,  Node: chmod invocation,  Next: touch invocation,  Prev: chgrp invocation,  Up: Changing file attributes

13.3 `chmod': アクセス権を変更する
============================================

`chmod' は、名前を指定したファイルのアクセス権を変更する。

   書式:

     chmod [OPTION]... {MODE | --reference=REF_FILE} FILE...

   `chmod' コマンドがシンボリックリンクのアクセス権を変更することは
ない。`chmod' システムコールがシンボリックリンクのアクセス権を変更
できないからである。シンボリックリンクのアクセス権が利用されることは
全くないので、この制限は問題にならない。とは言え、シンボリックリンク
がコマンドラインで指定されていることはありうる。そうした場合、`chmod'
は、各リンクが参照しているファイルのアクセス権を変更する。それに
対して、ディレクトリを再帰的にたどっている最中にシンボリックリンクに
出会った場合は、`chmod' はそれを無視することになる。

   `chmod' の実行に成功したとき、通常ファイルの set-group-ID ビットが
消えることがあるが、それは、ファイルのグループ ID が、`chmod' を実行
したユーザの実効グループ ID や、補助グループ ID の一つに一致しなかった
場合である。もっとも、そのユーザがしかるべき特権を持っている場合は、
set-group-ID ビットが消えることはない。また、制限事項が他にも存在して、
指定した MODE 中や REF_FILE の、set-user-ID ビットや set-group-ID
ビットが無視されることもある。そうした動作は、裏で動いている `chmod'
システムコールのポリシーや機能次第なのだ。よくわからないときは、裏で
動いているシステムの動作を調べればよい。

   MODE には、ファイルの新しいモードビット (訳注: すなわち、アクセス
権) を指定する。詳細については、「ファイルの許可属性」の章を参照して
いただきたい (*note File permissions::)。MODE を指定するとき、MODE を
どうしても `-' で始めたいのなら、前に `--' を置いた方がよい。たとえば、
`chmod -- -w file' のようにだ。とは言え、たいていの場合、`chmod a-w
file' の方が望ましい。なお、`chmod -w file' (`--' がない) が `chmod a-w
file' と別の動作になる場合には、警告が出る。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--changes'
     アクセス権の変更が実際に行われた各 FILE について、何を実行したかを
     詳しく表示する。

`-f'
`--silent'
`--quiet'
     アクセス権が変更できないファイルがあっても、エラーメッセージを
     表示しない。

`--preserve-root'
     ルートディレクトリ (`/') を再帰的に変更しようとする動きがあり次第、
     エラーになる。`--recursive' オプションを指定していない場合、
     このオプションは効果がない。 *Note Treating / specially::.

`--no-preserve-root'
     `--preserve-root' オプションが前にあれば、その効果を無効にする。
     *Note Treating / specially::.

`-v'
`--verbose'
     すべての FILE について、何を実行し、何を実行しなかったかを詳しく
     表示する。

`--reference=REF_FILE'
     各 FILE のモードを REF_FILE のそれと同じものに変更する。 *Note
     File permissions::.  REF_FILE がシンボリックリンクの場合は、
     シンボリックリンクのモードではなく、リンクが参照しているファイルの
     モードを使用する。

`-R'
`--recursive'
     ディレクトリとその中身のアクセス権を再帰的に変更する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: touch invocation,  Prev: chmod invocation,  Up: Changing file attributes

13.4 `touch': ファイルのタイムスタンプを変更する
=================================================================

`touch' は指定されたファイルのアクセス日時 (access time) や更新日時
(modification time) を変更する。

   書式:

     touch [OPTION]... FILE...

   引数 FILE に存在しないファイルを指定すると、空のファイルが作成
される。ただし、`--no-create' (`-c') や `--no-dereference' (`-h') が
有効な場合は、ファイルは作成されない。

   引数 FILE が `-' という文字列の場合は、特別な扱いする。`touch' は、
標準出力に結びついているファイルの日時を変更するのである。

   `touch' は、デフォルトではファイルのタイムスタンプを現在の日時に
セットする。`touch' はオペランドを左から右へと順番に処理するので、
生成されたタイムスタンプが、前後のオペランドで一致しないこともある。
また、「現在」とはいつかを決めるのは、プラットフォーム次第である。
ネットワーク・ファイルシステムを使用しているプラットフォームでは、
しばしばオペレーティング・システムとファイルシステムとで別のクロック
を使用している。`touch' は通常、デフォルトではファイルシステムの
クロックを使用するので、クロックのずれのために、生成されたファイルの
タイムスタンプが、あるプログラムにとっては「未来」に見えたり、「過去」
に見えたりすることがある。

   `touch' コマンドは、ファイルのタイムスタンプを、ユーザが指定した
日時よりも精度が高くならない範囲で、表現できる最大の値にセットする。
この値がユーザが指定した日時と違うことがあるが、それにはいくつかの
理由がある。第一に、ユーザが指定した日時が、サポートされている精度を
越えていることがある。第二に、ファイルシステムが、日時のタイプに
よって別の精度を使っていることがある。第三に、ファイルのタイム
スタンプが、オペレーティング・システムのタイムスタンプとは別の精度を
使っていることがある。第四に、オペレーティング・システムでタイム
スタンプの更新に使用されている基本データ型が、さらに違う精度を採用
していることがある。そんなわけで、理屈の上では、たとえば、ファイル
システムでは、アクセス日時には 10 マイクロ秒の精度を、更新日時には 100
ナノ秒の精度を使用し、オペレーティング・システムの方では、現在の
時刻にはナノ秒の精度を、`touch' がファイルのタイムスタンプを任意の
値に設定するために使う基本データ型には、マイクロ秒の精度を使用して
いる、そういうこともありえるのである。

   タイムスタンプを現在の時刻にセットする場合には、ユーザが所有して
いないファイルでも、書き込み権限さえ持っていれば、`touch' はその
タイムスタンプを変更することができる。しかし、現在の時刻以外にセット
するには、ユーザはそのファイルを所有していなければならない。古い
システムの中には、制限がさらに厳しいものもある。そこでは、アクセス
日時と更新日時の両方を現在の時刻にセットするとき以外、対象となる
ファイルを所有していなければならないのである。

   `touch' が提供するオプションを使えば、ファイルの 2 種類の日時 --
最終アクセス日時と最終更新日時 -- を変更することができるが、標準の
日時には、実はそのほかに 3 番目のものがある。すなわち、inode の変更日時
(inode change time) だ。これは、ファイルの `ctime' と呼ばれることが
多い。inode の変更日時は、ファイルのメタ情報が最後に変更された日時を
表している。メタ情報の変更のよくある例の一つは、ファイルのアクセス権
の変更である。アクセス権の変更では、ファイルにアクセスするわけではない
ので、atime (アクセス日時) は変化しないし、またファイルの内容を変更
するわけでもないので、mtime (更新日時) も変化しない。しかし、ファイル
そのものに関する何ものかが変化しているわけであり、それはどこかに記録
されなければならない。まさにそれが、inode の ctime フィールドの役割
なのだ。たとえば、バックアップ・プログラムが、ファイルのアクセス権に
変更があった場合も含めて、ファイルのコピーを最新に保つことができる
ようにするには、ctime が不可欠である。ファイルの ctime は変更するが、
他の日時には影響を及ぼさない別の操作には、ファイル名の変更がある。
なお、いかなる場合であれ、通常の操作では、ユーザが ctime フィールドを
自分で指定する値に変更することはできない。オペーレーティングシステムや
ファイルシステムの中には、4 番目の日時をサポートしているものもある。
すなわち、作成日時 (birth time) であり、ファイルが最初に作られた日時だ。
名前からして当然だが、このタイムスタンプが変更されることはない。

   タイムスタンプは、タイムゾーンのルールに従うが、そのルールを指定して
いるのは、環境変数 `TZ' である。`TZ' が設定されていない場合は、システム
のデフォルトのルールに従う。 *Note Specifying the Time Zone with `TZ':
(libc)TZ Variable.  なお、UTC のタイムスタンプを使えば、夏 (冬) 時間への
移行時の曖昧さを避けることができる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--time=atime'
`--time=access'
`--time=use'
     アクセス日時のみ変更する。

`-c'
`--no-create'
     存在しないファイルについて警告を出さず、ファイルの作成もしない。

`-d'
`--date=TIME'
     現在の日時の代わりに TIME を使用する。TIME には、月の名前、
     タイムゾーン、`am' や `pm'、`yesterday' なども使うことができる。
     たとえば、`--date="2004-02-27 14:19:13.489392193 +0530"' とすると、
     UTC より 5 時間 30 分東のタイムゾーンで、2004 年 2 月 27 日 午後 2
     時 19 分 13 秒 から 489,392,193 ナノ秒経過した瞬間を指定することに
     なる。*Note Date input formats::.  精度の高いタイムスタンプを
     サポートしていないファイルシステムでは、精度の超過分は単に無視
     される。

`-f'
     何もしない。BSD 版の `touch' との互換性のためにある。

`-h'
`--no-dereference'
     シンボリックリンクが参照しているファイルではなく、シンボリック
     リンクのタイムスタンプの変更を試みる。このオプションを使用すると、
     空のファイルは作成されないが、ファイルが存在しないという警告まで
     出ないようにするには、`-c' オプションも併せて使用する必要がある。
     すべてのシステムが、シンボリックリンクのタイムスタンプの変更を
     サポートしているわけではない。なぜならば、POSIX 2008 までは、
     下層で動いているシステムに対して、そうした動作のサポートを要求
     していなかったからである。また、システムによっては、シンボリック
     リンクは、調べるだけでアクセス日時が変わってしまうので、変更の
     結果が後々まで残って観察できるのは、更新日時だけだというものも
     ある。なお、このオプションを `-r' オプションと一緒に使用すると、
     参照するタイムスタンプが、リンクが指しているファイルからではなく、
     シンボリックリンクから取得される。

`-m'
`--time=mtime'
`--time=modify'
     更新日時 (modification time) のみ変更する。

`-r FILE'
`--reference=FILE'
     現在の日時の代わりに、参照ファイル FILE の日時を使用する。この
     オプションを `--date=TIME' (`-d TIME') オプションと組み合わせて
     使うと、TIME が相対時間で指定されている場合は、参照ファイル FILE
     の日時がその基点となるが、それ以外の場合は、FILE の日時は無視され
     る。たとえば、`-r foo -d '-5 seconds'' は、`foo' のタイムスタンプ
     より 5 秒前のタイムスタンプを指定している。FILE がシンボリック
     リンクの場合は、`-h' が同時に有効になっていないかぎり、参照する
     タイムスタンプは、シンボリックリンクの参照先から取得される。

`-t [[CC]YY]MMDDHHMM[.SS]'
     現在の日時の代わりに、`-t' オプションの引数を使用する (引数の構成
     は、4 桁または 2 桁の年 (省略可)、月、日、時、分、秒 (秒も省略可)
     である)。年が 2 桁のみ指定された場合、0 ... 68 の範囲の年ならば、
     CC は 20 であり、69 ... 99 の範囲の年では、CC は 19 である。
     年が全く指定されない場合は、引数は今年の日付だと解釈される。閏秒に
     対応している例外的なシステムでは、SS が `60' のこともありえる。


   古めのシステムでは、`touch' は次のような旧式の書式もサポートして
いる。すなわち、`-d', `-r', `-t' のいづれによってもタイムスタンプが指定
されていず、しかも、2 個以上の FILE が指定されていて、最初の FILE が
`MMDDHHMM[YY]' の形を持ち、それが (YY が存在するなら、それを先頭に
移せば) `-t' オプションに対する有効な引数と見なすことができる場合は、
その引数の表している年度が 1969-1999 の範囲にあるならば、その引数を
ファイル名ではなく、他のファイルに適用する日時と解釈する、というもの
である。この旧式の動作は、環境変数 `_POSIX2_VERSION' によって有効に
したり、無効にしたりできるが (*note Standards conformance::)、移植を
考慮したスクリプトでは、動作がこの環境変数に依存するコマンドの使用は
避けるべきである。たとえば、二通りの解釈ができる `touch 12312359 main.c'
を使うより、`touch ./12312359 main.c' や `touch -t 12312359 main.c' を
使用した方がよい。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Disk usage,  Next: Printing text,  Prev: Changing file attributes,  Up: Top

14 ディスク使用量
************************

データをいくらでも無限に入れることのできるディスクはない。この章で説明
するコマンドには、使用しているディスク容量や利用可能なディスク容量を報告
するもの、それ以外のファイル情報やファイルステータス情報を報告するもの、
それに、バッファの内容をディスクに書き込むものがある。

* Menu:

* df invocation::            ファイルシステムのディスク使用量を報告する。
* du invocation::            ファイルのディスク使用量を概算する。
* stat invocation::          ファイルやファイルシステムのステータスを報告する。
* sync invocation::          メモリとディスクを同期させる。
* truncate invocation::      ファイルサイズの短縮・伸長を行う。


File: coreutils-ja.info,  Node: df invocation,  Next: du invocation,  Up: Disk usage

14.1 `df': ファイルシステムのディスク使用状量を報告する
=============================================================================

`df' は、ファイルシステムごとに、使用されているディスク容量と利用可能な
ディスクス容量を報告する。

   書式:

     df [OPTION]... [FILE]...

   引数を指定しないと、`df' は、現在マウントされているすべてのファイル
システム (ファイルシステムのタイプは問わない) について、使用されている
ディスク容量と、利用可能なディスク容量を報告する。引数が指定されている
場合は、引数として指定された各 FILE が存在するファイルシステムについて
報告する。

   通常、ディスク容量は 1024 バイトを 1 単位として表示するが、この動作は
変更することができる (*note Block size::)。なお、小数点以下は切り上げて
整数にする。

   引数 FILE がディスク・デバイスファイルで、そのディスク・デバイス
上に存在するファイルシステムが現在マウントされている場合、`df' が
表示するのは、そのファイルシステムの利用可能な容量であって、デバイス・
ノードが存在するファイルシステム (すなわち、ルート・ファイルシステム)
の利用可能な容量ではない。また、GNU の `df' は、マウントされていない
ファイルシステムのディスク使用量を測定しようとはしない。なぜなら、
ほとんどのファイルシステムにおいて、そういうことを行うには、ファイル
システムの構造について他と全く共通性のない内奥の知識が必要だからである。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--all'
     一覧表示にダミーのファイルシステムを含める。そうしたものは、デフォルト
     の表示では省略されている。たいていの場合、そうしたファイルシステムは、
     たとえばオートマウンタのエントリのような、特殊な用途のための擬似
     ファイルシステムである。

`-B SIZE'
`--block-size=SIZE'
     SIZE によって単位の大きさを変更してから、サイズを表示する (*note
     Block size::)。 たとえば、`-BG' と指定すれば、1,073,741,824 バイト
     を 1 単位として、サイズを表示する。

`--total'
     すべての引数を処理した後で、全引数からなる総計を表示する。
     このオプションを使用すれば、ディスクの容量、使用した量、使用可能
     な量について、リストされたすべてのデバイスを合わせた総量を知ること
     ができる。

`-h'
`--human-readable'
     各サイズの後ろに、メビバイトなら `M' といった、大きさを示す文字を
     付ける。1000 ではなく、1024 の累乗が使われるので、`M' は 1,048,576
     バイトを表している。このオプションは、`--block-size=human-readable'
     と同じである。1000 の累乗が使いたければ、"`--si' オプションを使用
     すればよい。

`-H'
     `--si' オプションと同じである。

`-i'
`--inodes'
     ブロックの使用量ではなく、inode の使用情報を一覧表示する。inode
     (index node の略称) には、ファイルの所有者、許可属性、タイム
     スタンプ、ディスク上の位置といった、ファイルに関する情報が含まれ
     ている。

`-k'
     デフォルトのブロックサイズがどうなっていようと、1 ブロック 1024
     バイトでサイズを表示する (*note Block size::)。このオプションは
     `--block-size=1K' に等しい。

`-l'
`--local'
     一覧表示するのをローカルのファイルシステムに限定する。デフォルトでは、
     リモートのファイルシステムも表示される。

`--no-sync'
     使用量に関するデータを取得する前に `sync' システムコールを実行
     しない。そのため、多数のディスクを搭載しているシステムでは、`df'
     の実行速度が目に見えて向上するが、システムによっては (特に SunOS
     では)、出力結果がほんの少し古いものになるかもしれない。これが
     デフォルトの動作である。

`-P'
`--portability'
     POSIX の出力形式を使用する。デフォルトの形式に似ているが、次の
     点で異なっている。

       1. 各ファイルシステムついての情報が、常にぴったり 1 行で表示
          され、マウントされるデバイスが、それのみで 1 行を占めることが
          ない。そのため、マウントされるデバイスの名前の長さが 20 字を
          越えると (たとえば、ネットワーク・マウントの場合にそういう
          ことがありそうだ)、各項目の列がずれることになる。

       2. ヘッダ行の項目名が、POSIX に準拠したものになる。

       3. デフォルトのブロックサイズや出力の書式が、環境変数
          `DF_BLOCK_SIZE', `BLOCK_SIZE', `BLOCKSIZE' の影響を受けなく
          なる。とは言え、デフォルトのブロックサイズについては、
          `POSIXLY_CORRECT' の影響だけは、やはり受ける。すなわち、
          `POSIXLY_CORRECT' が設定されていれば、ブロックサイズは 512
          バイトであり、さもなければ 1024 バイトである。 *Note Block
          size::.

`--si'
     各サイズにの後ろに、メガバイトなら `M' といった、SI 形式の略号
     を付ける。1024 ではなく、1000 の累乗が使用されるので、`M' は
     1,000,000 バイトを表している。このオプションは、`--block-size=si'
     と同じことである。1024 の累乗が使いたければ、`-h' や
     `--human-readable' を使用すればよい。

`--sync'
     使用量に関するデータを取得する前に `sync' システムコールを実行
     する。システムによっては (特に SunOS では)、そうすることでより
     最近の結果が得られるが、一般的に言って、このオプションを使用すると、
     `df' の実行速度がかなり低下する。ファイルシステムをたくさんマウント
     している場合や、作業が頻繁に行われているファイルシステムでは、
     とりわけ遅くなる。

`-t FSTYPE'
`--type=FSTYPE'
     一覧表示するファイルシステムを FSTYPE というタイプに限定する。
     `-t' オプションを複数回使うことによって、複数のタイプのファイル
     システムを指定することができる。デフォルトでは、いかなるタイプの
     ファイルシステムも除外しない。

`-T'
`--print-type'
     各ファイルシステムのタイプを表示する。このとき表示されるタイプは、
     `-t' や `-x' オプションを使って、一覧表示に含めたり、一覧表示から
     除外したりできるタイプと同じものである。すなわち、表示されるタイプ
     は何であれ、システムによってサポートされているということだ。以下に、
     よく見受けられるタイプの名前をいくつか挙げておく (当然ながら、
     ここに挙げるものがすべてではない)。

    `nfs'
          NFS ファイルシステム。すなわち、ネットワーク越しにほかの
          マシンからマウントしているファイルシステム。このタイプ名は、
          あらゆるシステムで共通して使われているようである。

    `4.2, ufs, efs...'
          ローカルでマウントしているハードディスクのファイルシステム。
          (ローカルのマウントでは、システムが複数のタイプをサポートして
          いることもある。たとえば、Linux がそうだ。)

    `hsfs, cdfs'
          CD-ROM ドライブのファイルシステム。HP-UX は `cdfs' を使用し、
          ほかのシステムのほとんどは `hsfs' (`hs' は "High Sierra" を
          表している) を使用している。

    `pcfs'
          MS-DOS のファイルシステム。普通フロッピーディスクで使われる。


`-x FSTYPE'
`--exclude-type=FSTYPE'
     一覧表示するファイルシステムを FSTYPE というタイプ以外のものに
     限定する。`-x' オプションを複数回使うことによって、複数のタイプの
     ファイルシステムを除外することができる。デフォルトでは、いかなる
     タイプのファイルシステムも除外しない。

`-v'
     無視される。System V 版の `df' との互換のためにある。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。 実行に失敗
しても、何もメッセージが出力されないことがある。そこで、そうしたときに、
ディレクトリ DIR が `ext3' や `reiserfs' というタイプのファイルシステム
上にあるかどうかを調べるには、`df -t ext3 -t reiserfs DIR' といった
コマンドを実行して、終了ステータスを検査すればよい。

   ファイルシステムのタイプを判断するには、ファイルシステムのリスト
(MTAB) が必要である。従って、実行の失敗には、ファイルシステムのリストを
読み込むことができないときに、ファイル名引数とともに `-a', `-l', `-t',
`-x' といったオプションが一つ以上使われた場合が含まれる。


File: coreutils-ja.info,  Node: du invocation,  Next: stat invocation,  Prev: df invocation,  Up: Disk usage

14.2 `du': ファイルのディスク使用量を概算する
==============================================================

`du' は、指定したファイルのディスク使用量を報告する。引数がディレ
クトリの場合は、サブディレクトリごとのディスク使用量も報告する。

   書式:

     du [OPTION]... [FILE]...

   引数を指定しないと、`du' は、カレントディレクトリのディスク使用量を
報告する。通常、ディスク使用量は 1024 バイトを 1 単位として表示するが、
この動作は変更することができる (*note Block size::)。なお、小数点以下
は、切り上げて整数にする。

   2 個以上のハードリンクが同一のファイルを指している場合は、そのうちの
1 個のみが計算の対象になる。引数 FILE の順番によって、どのリンクが計算の
対象になるかが変わってくるので、引数の順番を変更すると、`du' が出力する
数値が変化するかもしれない。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--all'
     ディレクトリだけでなく、すべてのファイルについて使用量を表示する。

`--apparent-size'
     ディスクの使用量ではなく、見かけのサイズを表示する。ファイルの
     見かけのサイズとは、通常ファイルに対して `wc -c'、あるいは、もっと
     普通に `ls -l --block-size=1' や `stat --format=%s' を実行したとき
     に返されるバイト数である。たとえば、`zoo' という単語を改行を付けず
     に書き込んだファイルなら、当然ながら、見かけのサイズは 3 になる。
     だが、そうした小さなファイルも、そのファイルが存在するファイル
     システムのタイプと設定次第で、0 から 16 KiB、あるいは、それ以上の
     ディスクスペースを占有するかもしれないのだ。もっとも、穴空きファ
     イル (sparse file) の場合は事情が別である。たとえば、

          dd bs=1 seek=2GiB if=/dev/null of=big

     上記のコマンドで作成した穴空きファイルは、見かけのサイズこそ 2 GiB
     だが、最近のほとんどのシステムでは、実際に使用するディスクスペースは、
     ほとんど 0 である。

`-b'
`--bytes'
     `--apparent-size --block-size=1' と同じ。

`-B SIZE'
`--block-size=SIZE'
     SIZE によって単位の大きさを変更してから、サイズを表示する (*note
     Block size::)。 たとえば、`-BG' と指定すれば、1,073,741,824 バイト
     を 1 単位として、サイズを表示する。

`-c'
`--total'
     すべての引数を処理した後で、全引数からなる総計を表示する。
     このオプションを使用すれば、指定したファイルやディレクトリについて
     ディスク使用量の合計を知ることができる。

`-D'
`--dereference-args'
     コマンドラインで引数に指定されたシンボリックリンクの参照を行う。
     コマンドライン引数以外のシンボリックリンクには影響がない。この
     オプションは、`/usr/tmp' のような、シンボリックリンクであることが
     多いディレクトリのディスク使用量を調べるときに、重宝である。

`--files0-from=FILE'
     コマンドラインで名前を指定されたファイルの処理を行わない。その代わり
     に、ファイル FILE に名前が書き込まれているファイルの処理を行う。
     なお、FILE 中に書かれている各ファイル名は、ゼロバイト (ASCII NUL)
     で終端されていなければならない。このオプションは、ファイル名のリスト
     が長すぎて、コマンドライン長の上限を超過してしまいそうなときに、
     便利である。そうした場合、`du' を `xargs' 経由で実行するのは、
     望ましくない。なぜなら、`xargs' はファイルのリストをいくつかの部分
     に分割して `du' に渡すので、`du' はリスト全体の `--total' (`-c')
     オプションを使用した結果ではなく、 部分リストごとの `--total'
     (`-c') オプションを使用した結果を表示してしまうからである。 ASCII
     NUL で終端されたファイル名のリストを得る方法の一つは、 GNU `find'
     に `-print0' を付けて使うことである。FILE に `-' を指定すれば、
     ASCII NUL で終端されたファイル名が標準入力から読み込まれる。

`-h'
`--human-readable'
     各サイズの後ろに、メビバイトなら `M' といった、大きさを示す文字を
     付ける。1000 ではなく、1024 の累乗が使われるので、`M' は 1,048,576
     バイトを表している。このオプションは、`--block-size=human-readable'
     と同じである。1000 の累乗が使いたければ、"`--si' オプションを使用
     すればよい。

`-H'
     `--dereference-args' (`-D') と同じである。

`-k'
     デフォルトのブロックサイズがどうなっていようと、1 ブロック 1024
     バイトでサイズを表示する (*note Block size::)。このオプションは
     `--block-size=1K' に等しい。

`-l'
`--count-links'
     すべてのファイルを計算に入れる。すなわち、(ハードリンクとして) 前に
     現れたことがあっても、計算に入れる。

`-L'
`--dereference'
     シンボリックリンクの参照を行う (リンク自体のディスク使用量では
     なく、リンクが指しているファイルやディレクトリの使用量を表示する)。

`-m'
     デフォルトのブロックサイズを変更し、1 ブロック 1,048,576 バイトの
     ブロック数でサイズを表示する (*note Block size::)。
     このオプションは、`--block-size=1M' と同じである。

`-P'
`--no-dereference'
     `du' が出会った各シンボリックリンクについて、シンボリック自体の
     使用ディスクスペースを計算する。

`-d DEPTH'

`--max-depth=DEPTH'
     ディレクトリ階層の基点 (訳注: 要するに、コマンドラインで指定
     されたディレクトリ) から最大 DEPTH 段階下がったところまでにある
     各ディレクトリについて、ディスク使用量の合計を表示する (`--all'
     オプションが付いているときは、ファイルについても表示する)。基点
     自体は、段階 0 なので、`du --max-depth=0' は `du -s' と同じことに
     なる。

`-0'
`--null'
     各行の末尾に改行ではなく、ゼロバイト (ASCII NUL) を出力する。この
     オプションを使用すると、`du' の出力するデータに、途中に改行を
     挟むものがあっても、他のプログラムがその出力を解析できるようになる。

`--si'
     各サイズにの後ろに、メガバイトなら `M' といった、SI 形式の略号
     を付ける。1024 ではなく、1000 の累乗が使用されるので、`M' は
     1,000,000 バイトを表している。このオプションは、`--block-size=si'
     と同じことである。1024 の累乗が使いたければ、`-h' や
     `--human-readable' を使用すればよい。

`-s'
`--summarize'
     各引数についてディスク使用量の合計だけを表示する。

`-S'
`--separate-dirs'
     通常、(`--summarize' オプションを使用しない場合の) `du' の出力に
     おいて、D というディレクトリ名の隣に表示されるサイズは、D 以下に
     あるすべてのエントリのサイズの合計に、D 自体のサイズを加えたもの
     である。それに対して、`--separate-dirs' オプションを指定すると、 D
     というディレクトリ名に対して報告されるサイズは、ディレクトリエントリ
     D の `stat.st_size' から取り出したサイズのみになる。

`--time'
     そのディレクトリ以下にあるすべてのファイルやサブディレクトリの更新
     日時 (modification time) のうちで、最も新しいものを表示する。

`--time=ctime'
`--time=status'
`--time=use'
     更新日時の代わりに、そのディレクトリ以下にあるすべてのファイルの
     ステータス変更日時 (inode 中の `ctime') のうちで、最も新しいもの
     を表示する。

`--time=atime'
`--time=access'
     更新日時の代わりに、そのディレクトリ以下にあるすべてのファイルの
     アクセス日時 (inode 中の `atime') のうちで、最も新しいものを表示
     する。

`--time-style=STYLE'
     タイムスタンプを STYLE 形式で表示する。このオプションは、`--time'
     オプションと併せて指定したときにのみ効果がある。STYLE は以下の一つ
     でなければならない。

    `+FORMAT'
          FORMAT を使って、タイムスタンプを表示する。その場合、FORMAT
          は、`date' コマンドの書式引数と同じように解釈される (*note
          date invocation::)。 たとえば、`--time-style="+%Y-%m-%d
          %H:%M:%S"' と指定すると、 `du' の表示するタイムスタンプは、
          `2002-03-30 23:45:56' のようになる。`date' の場合と同様、
          FORMAT の解釈は、`LC_TIME' ロケール・カテゴリの影響を受ける。

    `full-iso'
          タイムスタンプを省略なしで表示する。すなわち、ISO 8601 の
          日付、時刻、タイムゾーンという書式を nanosecond (10 億分の 1
          秒) の精度で使用するわけだ。一例を挙げると、`2002-03-30
          23:45:56.477817180 -0700' といった表示になる。この形式は、
          `+%Y-%m-%d %H:%M:%S.%N %z' と同じである。

    `long-iso'
          ISO 8601 の書式で日付と時刻を分の単位まで表示する。たとえば、
          `2002-03-30 23:45'。このタイムスタンプは、`full-iso' タイム
          スタンプより短く、日常作業にはたいてい十分である。この形式は
          `+%Y-%m-%d %H:%M' と同じである。

    `iso'
          タイムスタンプに ISO 8601 書式の日付を表示する。たとえば、
          `2002-03-30' といった具合である。この形式は、`+%Y-%m-%d' と
          同じである。

     `--time-style' オプションのデフォルト値は、環境変数 `TIME_STYLE' を
     使って指定することができる。`TIME_STYLE' が設定されていない場合、
     デフォルトの形式は `long-iso' である。`ls' と共通の `TIME_STYLE' を
     使えるようにするため、`+' で始まる `TIME_STYLE' の値が、改行を
     含んでいる場合は、改行以後の文字は無視されることになる。また、
     `TIME_STYLE' の値が `posix-' で始まる場合、`posix-' は無視される。
     さらに、`TIME_STYLE' の値が `locale' の場合、`TIME_STYLE' は無視
     される。

`-x'
`--one-file-system'
     処理される引数が存在するファイルシステムとは別のファイルシステムに
     あるディレクトリをスキップする。

`--exclude=PATTERN'
     再帰的な処理を行っているとき、PATTERN にマッチするサブディレクトリ
     やファイルをスキップする。たとえば、`du --exclude='*.o'' と指定
     すると、名前が `.o' で終わるファイルを除外することになる。

`-X FILE'
`--exclude-from=FILE'
     `--exclude' に似ているが、除外するパターンを FILE から 1 行につき
     1 パターン読み込む点が違う。FILE が `-' なら、パターンを標準入力
     から読み込む。


   BSD システムでは、HP-UX システムから NFS マウントしているファイルに
ついて、`du' は正確な値の半分のサイズを報告する。逆に、HP-UX システム
では、BSD システムから NFS マウントしているファイルについて、`du' は
正確な値の 2 倍のサイズを報告する。これは HP-UX にある欠陥のせいであり、
HP-UX の `du' プログラムも、そのとばっちりを受けているのである。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: stat invocation,  Next: sync invocation,  Prev: du invocation,  Up: Disk usage

14.3 `stat': ファイルやファイルシステムの状態を報告する
============================================================================

`stat' は指定されたファイルに関する情報を表示する。

   書式:

     stat [OPTION]... [FILE]...

   オプションなしで実行すると、`stat' は指定されたファイルについて
すべての情報を報告する。また、`stat' を使って、指定されたファイルが
存在しているファイルシステムの情報を報告させることも可能だ。ファイル
がリンクの場合、`stat' は、リンクが指しているファイルについて情報を
提供することもできる。

   シェルの組み込み機能の `stat' やエイリアスのために、`stat' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `stat' を起動すればよい (すなわち、 `env
stat ...' のようにだ)。

`-L'
`--dereference'
     `stat' がシンボリックリンクを処理する方法を変更する。この
     オプションを付けると、`stat' は、引数中の各シンボリックリンク
     が参照しているファイルを動作の対象にする。このオプションがないと、
     `stat' が対象にするのは、引数のシンボリックリンクそのものになる。

`-f'
`--file-system'
     指定されたファイルそのものについての情報ではなく、そのファイルが
     存在しているファイルシステムについての情報を報告する。このオプション
     を指定すると、自動的に `-L' オプションも指定される。

`-c'
`--format=FORMAT'
     デフォルトの書式の代わりに、FORMAT を使用する。FORMAT の末尾には
     自動的に改行が付けられるので、下記のようなコマンドを 2 個以上の
     FILE オペランドに対して実行すると、各オペランドあたり 1 行の
     出力を生じることになる。
          $ stat --format=%d:%i / /usr
          2050:2
          2057:2

`--printf=FORMAT'
     デフォルトの書式の代わりに、FORMAT を使用する。`--format' に似て
     いるが、バックスラッシュ・エスケープを解釈して変換する。また、
     行末に自動的に改行を付けることもしない。そこで、改行がしたければ、
     FORMAT の中で `\n' を指定する必要がある。`--printf' を使って `/'
     と `/usr' のデバイス番号と inode 番号を表示するには、こんなふうに
     する。
          $ stat --printf='%d:%i\n' / /usr
          2050:2
          2057:2

`-t'
`--terse'
     情報を簡潔な形式で表示する。他のプログラムで解析するときに都合がよい。


   `--format' や "`--printf' の FORMAT 中で、ファイルに対して使用できる
書式指定子には以下のものがある。

   * %a - 8 進数で表現したアクセス権

   * %A - 人間にわかりやすい形式で表現したアクセス権

   * %b - 割り当てられているブロック数 (`%B' を参照)

   * %B - `%b' の報告で使われる 1 ブロックのバイト数

   * %C - ファイルの SELinux セキュリティ・コンテキスト (取得できる場合)

   * %d - 10 進数で表現したデバイス番号

   * %D - 16 進数で表現したデバイス番号

   * %f - 16 進数で表現した Raw モード

   * %F - ファイルの種類

   * %g - 所有グループの ID 番号

   * %G - 所有グループ名

   * %h - ハードリンク数

   * %i - Inode 番号

   * %m - マウントポイント (下記の説明を参照)

   * %n - ファイル名

   * %N - 引用符で囲んだファイル名。シンボリックリンクなら、参照先も表示

   * %o - I/O 転送サイズの最適値の提案

   * %s - ファイル全体の大きさ。サイズはバイト数

   * %t - 16 進数で表現したメジャー・デバイス番号

   * %T - 16 進数で表現したマイナー・デバイス番号

   * %u - 所有者のユーザ ID 番号

   * %U - 所有者のユーザ名

   * %w - ファイルの作成日時 (the birth time)。不明の場合は `-' を表示

   * %W - Unix 紀元からの秒数で表したファイルの作成日時、または `0'

   * %x - 最終アクセス日時 (atime)

   * %X - Unix 紀元からの秒数で表した最終アクセス日時

   * %y - 最終更新日時 (mtime)

   * %Y - Unix 紀元からの秒数で表した最終更新日時

   * %z - 最終ステータス変更日時 (ctime)

   * %Z - Unix 紀元からの秒数で表した最終ステータス変更日時

   `%W', `%X', `%Y', `%Z' では、ピリオドに続けて精度を書くことで、
小数点以下何桁まで表示するかを指定することができる。たとえば、`%.3X'
と指定すると、最終アクセス日時がミリ秒の精度で出力される。ピリオド
だけ指定して、精度を省略すると、`stat' は 9 桁を使用する。従って、
`%.X' は `%.9X' と同じことになるわけだ。なお、余分な精度を捨てる際、
タイムスタンプは負の無限大方向に切り下げられる (訳注: 日常の言葉で
言うと、タイムスタンプのような正の数値の場合、指定された桁数より下の
部分は切り捨てられるということ。以下の例を参照)。

     0 で埋める:
       $ stat -c '[%015Y]' /usr
       [000001288929712]
     スペースで位置を揃える:
       $ stat -c '[%15Y]' /usr
       [     1288929712]
       $ stat -c '[%-15Y]' /usr
       [1288929712     ]
     精度指定:
       $ stat -c '[%.3Y]' /usr
       [1288929712.114]
       $ stat -c '[%.Y]' /usr
       [1288929712.114951834]

   `%m' によって表示されるマウントポイントは、`df' によるマウント
ポイントの出力とほぼ同じである。ただし、以下の点が違う。
   * stat はデフォルトでは、シムリンクの参照を行わない (そのためには、
     `-L' を指定する必要がある)。

   * 引数としてデバイスノードが指定された場合、stat はファイルシステムの
     リストを参照するのではなく、デバイスノードに対して直接操作を行う。

   * bind マウントされているファイルについては、stat はそのファイルが
     載っているデバイスの最初のマウントポイントではなく、bind マウントで
     指定された別名 (訳注: 原文は alias。`mount --bind olddir newdir'
     における newdir のことか) の方を出力する。出力に変化がなくなる
     まで、再帰的に stat を呼び出せば、現在ベースになっているマウント
     ポイントを知ることができる。

     (訳注: 訳者には意味不明。「現在ベースになっているマウントポイント
     (the current base mount point)」が、上記訳注の newdir のことなら、
     stat を再帰的に呼び出すまでもない。`stat -c "%m" newdir/FILE' は、
     newdir を表示する。また the current base mount point が「根底にある
     (すなわち、デバイスを最初にマウントした) マウントポイント」のこと
     なら、stat を再帰的に呼び出しても、それを突き止めることはできない。
     ひょっとすると、書式指定子に `%m' が追加された最近の stat を
     linux-2.6 の古いカーネルと組み合わせて使ったときの動作を言っている
     のかもしれない。その場合は、`stat -c "%m" newdir/FILE' は上記の
     olddir を出力する。その結果、stat を再帰的に実行することで、最初に
     デバイスをマウントしたときのマウントポイントを知ることができる)。

   ファイルシステムの情報をリストする際には (すなわち、`--file-system'
(`-f') 使用時には)、書式指定子の別の一群を使わなければならない。

   * %a - スーパーユーザ以外にも利用できる未使用ブロック数

   * %b - ファイルシステムの総データブロック数。

   * %c - ファイルシステムの総 inode 数

   * %d - ファイルシステムの未使用 inode 数

   * %f - ファイルシステムの未使用ブロック数

   * %i - 16 進数で表現したファイルシステム ID

   * %l - ファイル名の最大長

   * %n - ファイル名

   * %s - ブロックサイズ (高速転送用)

   * %S - 基本ブロックサイズ (ブロック計算用)

   * %t - 16 進数で表現したファイルシステムのタイプ

   * %T - 人間にわかりやすい形式で表現したファイルシステムのタイプ

   タイムスタンプは、タイムゾーンのルールに従って表示されるが、その
ルールを指定しているのは、環境変数 `TZ' である。`TZ' が設定されて
いない場合は、システムのデフォルトのルールに従って表示される。 *Note
Specifying the Time Zone with `TZ': (libc)TZ Variable.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: sync invocation,  Next: truncate invocation,  Prev: stat invocation,  Up: Disk usage

14.4 `sync': ディスク上のデータをメモリと同期する
===================================================================

`sync' は、メモリにバッファされているあらゆるデータをディスクに
書き出す。そうした書き出しには、スーパーブロックの変更、 inode の
変更、遅延読み書きを含むことができる (が、それだけに止まらない)。
この機能はカーネルによって実装されていなければならない。`sync'
プログラムは、`sync' システムコールを実行する以外、何もしないのである。

   カーネルは、(比較的遅い) ディスクの読み書きをできるだけしないで
済ますために、メモリにデータを保持している。このことによって、動作速度
が向上するが、コンピュータがクラッシュした場合、データが失われたり、
ファイルシステムが壊れたりという結果が生じかねない。`sync' コマンドを
使えば、メモリ上にあるすべてが間違いなくディスクに書き出されることに
なる。

   `--help' や `--version' を単独で使用することはできるが、それ以外の
いかなる引数も無視される (*note Common options::)。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: truncate invocation,  Prev: sync invocation,  Up: Disk usage

14.5 `truncate': ファイルサイズの短縮・伸長を行う
=================================================================

`truncate' は、各 FILE のサイズを指定したサイズにまで短縮したり、引き
伸ばしたりする。

   書式:

     truncate OPTION... FILE...

   FILE が存在していないときは、作成する。

   FILE が指定したサイズより大きい場合は、データのサイズを越える部分
は失われる。FILE が指定したサイズより小さい場合は、ファイルは引き伸ば
され、引き伸ばされた部分は、ゼロバイト (ASCII NUL) の連続に見えるよう
になる (引き伸ばされた部分は、穴空きファイル (sparse file) の穴になる)。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--no-create'
     ファイルが存在しない場合、作成しない。

`-o'
`--io-blocks'
     SIZE をバイト数ではなく、FILE を構成する I/O ブロック数として
     処理する。

`-r RFILE'
`--reference=RFILE'
     RFILE のサイズを基準に、各 FILE のサイズを揃える。

`-s SIZE'
`--size=SIZE'
     各 FILE のサイズを SIZE にする。SIZE
     は整数であり、以下に挙げるような、何倍かを表す接尾辞を
     後ろに付けることもできる。
          `KB' =>           1000 (KiloBytes)
          `K'  =>           1024 (KibiBytes)
          `MB' =>      1000*1000 (MegaBytes)
          `M'  =>      1024*1024 (MebiBytes)
          `GB' => 1000*1000*1000 (GigaBytes)
          `G'  => 1024*1024*1024 (GibiBytes)
     `T', `P', `E', `Z', `Y' についても同様。

     SIZE の前に以下の記号の一つを置くと、現在のサイズを元にして、各
     FILE のサイズを 調節することができる。
          `+'  => SIZE だけ増やす
          `-'  => SIZE だけ減らす
          `<'  => SIZE 以下
          `>'  => SIZE 以上
          `/'  => SIZE の倍数に切り下げる
          `%'  => SIZE の倍数に切り上げる


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Printing text,  Next: Conditions,  Prev: Disk usage,  Up: Top

15 テキストの表示
************************

この章では、テキスト文字列を表示するコマンドについて説明する。

* Menu:

* echo invocation::          テキストを 1 行表示する。
* printf invocation::        データを整形して表示する。
* yes invocation::           中断されるまで文字列を表示する。


File: coreutils-ja.info,  Node: echo invocation,  Next: printf invocation,  Up: Printing text

15.1 `echo': テキストを 1 行表示する
==============================================

`echo' は、指定された STRING を標準出力に書き出す。その際、各 STRING
の間に 1 個のスペースを置き、行末に改行を付け加える。

   書式:

     echo [OPTION]... [STRING]...

   シェルの組み込み機能の `echo' やエイリアスのために、`echo' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `echo' を起動すればよい (すなわち、 `env
echo ...' のようにだ)。

   このプログラムでは、以下のオプションが使える。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。また、
通常は特別な引数として使われる `--' は、特別な意味を持たず、他の
いかなる STRING とも同じように扱われる。

`-n'
     出力の末尾に改行を付けない。

`-e'
     各 "STRING の中に以下に挙げるバックスラッシュでエスケープした
     文字があると、それを解釈して変換する。

    `\a'
          警告 (ベル)

    `\b'
          バックスペース

    `\c'
          この位置より後を出力しない

    `\e'
          エスケープ

    `\f'
          フォームフィード (form feed)

    `\n'
          改行 (newline)

    `\r'
          復帰 (carriage return)

    `\t'
          水平タブ

    `\v'
          垂直タブ

    `\\'
          バックスラッシュ

    `\0NNN'
          8 進数 NNN (0 桁から 3 桁までの 8 進数) で表される 8 ビットの
          値に対応する文字。NNN が 9 ビットの値だと、9 ビット目 (最上位
          ビット) は無視される。

    `\NNN'
          8 進数 NNN (1 桁から 3 桁までの 8 進数) で表される 8 ビットの
          値に対応する文字。NNN が 9 ビットの値だと、9 ビット目 (最上位
          ビット) は無視される。

    `\xHH'
          16 進数 HH (1 または 2 桁の 16 進数) で表される 8 ビットの
          値に対応する文字。

`-E'
     各 STRING の中にあるバックスラッシュ・エスケープの解釈をしない。
     これがデフォルトである。`-e' と `-E' の両方が指定されている場合は、
     後で指定した方が効果を持つ。


   環境変数 `POSIXLY_CORRECT' が指定されている場合に、`echo' の最初の
引数が (単独の) `-n' 以外だと、`echo' はそうした引数をオプション
として扱わずに、形がオプションに似た引数として出力する。たとえば、
`echo -ne hello' は、単なる `hello' ではなく、`-ne hello' を出力する。

   POSIX では、いかなるオプションのサポートも要求していない。また、
POSIX では、STRING がバックスラッシュを含む場合や、最初の引数が `-n'
の場合に、`echo' がどう振る舞うかは、実装側で決めることになっている。
従って、他のシステムでも使うことを想定したプログラムでは、行末の改行
を省略したり、制御文字やバックスラッシュ・エスケープを出力したりする
必要があるのなら、`printf' コマンドの使用を考えてもよい。 *Note printf
invocation::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: printf invocation,  Next: yes invocation,  Prev: echo invocation,  Up: Printing text

15.2 `printf': データを整形して表示する
===================================================

`printf' は、テキストを整形して表示する。

   書式:

     printf FORMAT [ARGUMENT]...

   `printf' は、文字列 FORMAT を表示する。その際、C の `printf' 関数と
ほとんど同じやり方で、`%' 書式指定子と `\' エスケープシーケンスを解釈
して、数値や文字列の引数を整形する。詳細については、次の項目を参照する
こと。 *Note `printf' format directives: (libc)Output Conversion Syntax.
C の関数との相違点については、以下の箇条書きのとおりである。

   シェルの組み込み機能の `printf' やエイリアスのために、`printf' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `printf' を起動すればよい (すなわち、 `env
printf ...' のようにだ)。

   * FORMAT 引数は、指定された ARGUMENT のすべてを変換するのに必要な
     だけ、繰り返し使用される。たとえば、`printf %s a b' という
     コマンドは、`ab' を出力する。

   * 欠けている引数は (訳注: FORMAT 中の書式指定子に対応する、文字列
     なり、数値なりの引数が存在しないということ)、文脈が文字列と数値の
     どちらを期待しているかによって、空文字列、または 0 と見なされる。
     たとえば、`printf %sx%d' というコマンドは、`0' を表示する。

   * `\c' というエスケープシーケンスが追加されている。`\c' より後の部分
     を、`printf' は出力しない。たとえば、`printf 'A%sC\cD%sF' B E' と
     いうコマンドは、`ABC' を表示する。

   * 16 進数エスケープシーケンス `\xHH' は、最大でも 2 桁である。
     桁数に制限のない C と、その点が違う。たとえば、`printf '\x07e''
     というコマンドは、2 バイトを表示するが (訳注: \x07 (ベル) と e)、
     C の `printf ("\x07e")' という文の方は、1 バイトしか表示しない。

   * `printf' コマンドの書式指定子には、`%b' が追加されている。`%b'
     は、対応する引数文字列中の `\' エスケープシーケンスを、それが
     FORMAT 文字列中にあるときと同じように解釈・変換して、引数文字列
     を表示する。ただし、引数中の 8 進数エスケープシーケンスは `\0OOO'
     の形を取る。OOO は 0 から 3 桁の 8 進数である。`\OOO' が 9 ビット
     の値ならば、9 ビット目 (訳注: すなわち最上位ビット) は無視される。
     `%b' に精度も指定すると、変換した文字列の先頭から何バイトを表示
     するかが、それによって決まる。

   * 数値の引数は、単独の C の定数でなければならない。前に `+' や `-'
     が付いていてもよい。たとえば、`printf %.4d -3' は、`-0003' を
     出力する。

   * 数値が期待される引数の先頭文字が `"' や `'' である場合、その引数の
     値は、引用符の直後に来る文字の数値である (訳注: すなわち、一般に
     は、その文字の ASCII コードの 10 進数表記が出力される)。その後に
     さらに文字が続く場合は、`POSIXLY_CORRECT' が設定されていれば、ただ
     単に無視され、設定されていなければ、警告が出される。一例を挙げて
     おくと、`printf "%d" "'a"' は、ASCII 文字セットを使用しているホスト
     では、`97' を出力する。ASCII における `a' の数値は、10 進数表記で
     97 だからだ。


   引数が浮動小数点数の場合は、小数部の前にはピリオドを置かなければ
ならない。ただし、表示は、現在のロケールの `LC_NUMERIC' カテゴリの
ルールに合わせたものになる。たとえば、小数点を表す文字がコンマの
ロケールでは、`printf %g 3.14' というコマンドは、`3,14' を出力するが、
`printf %g 3,14' というコマンドはエラーになる。 *Note Floating point::.

   `printf' は、FORMAT 中の `\OOO' を (OOO が 1 から 3 桁の 8 進数なら
ば)、表示する 1 バイトを指定している 8 進数と見なす。また、`\xHH' を
(HH が 1 から 2 桁の 16 進数ならば)、表示する文字を指定している 16
進数だと解釈する。ただし、注意していただきたいが、`\OOO' が 255 より
大きな 10 進数に相当するときは、`printf' は 9 ビット目を無視する。
従って、たとえば、`printf '\400'' は、`printf '\0'' と同じである。

   `printf' は、ISO C 99 で導入された 2 種類のキャラクタ・シンタクス
(訳注: 要するに、コードによる文字の指定法) を解釈することができる。
一つは、16 ビットの Unicode (ISO/IEC 10646) 文字を表す `\u' であり、 4
桁の 16 進数 HHHH で指定する。もう一つは、32 ビットの Unicode 文字を
表す `\U' で、こちらは 8 桁の 16 進数 HHHHHHHH で指定する。`printf' は
Unicode の文字を出力するに当たって、`LC_CTYPE' のロケールに従う。なお、
U+0000...U+009F と U+D800...U+DFFF の範囲にある Unicode の文字は、
U+0024 ($), U+0040 (@), U+0060 (`) を除いて、このシンタクスでは指定
することができない。

   `\u' や `\U' を処理するには、フル装備の `iconv' の能力が必要である。
glibc 2.2 以降を採用しているシステムでは、そうした能力は使えるように
なっている。coreutils パッケージをインストールする前に、`libiconv' を
インストールしている場合も同様だ。どちらにも当てはまらない場合は、`\u'
や `\U' は、変換されずに、そのままの形で表示される。

   オプションとして指定できるのは、単独の `--help' か `--version' だけ
である。*Note Common options::.  オプションはオペランドの前に置かなけれ
ばならない。

   Unicode のキャラクタ・シンタクスを使えば、ロケールに影響されない方法
で文字列を書くことができて、便利である。たとえば、次のようにすれば、

     $ env printf '\u20AC 14.95'

ユーロ通貨記号を含む文字列が、ユーロ記号をサポートするすべてのロケール
(ISO-8859-15, UTF-8 など) で正しく出力されることになる。同様に、

     $ env printf '\u4e2d\u6587'

とすれば、漢字の文字列が、すべての中国語のロケール (GB2312, BIG5, UTF-8
など) で正しく表示される。

   上記の例では、`printf' コマンドを `env' 経由で呼び出していることに
注目していただきたい。これは、シェルのエイリアスや組み込み関数ではなく、
シェルのサーチパスを使って見つけたプログラムを、確実に実行するためである。

   文字列がもっと長い場合でも、各文字に対応する 16 進数コードを一つ
一つ捜す必要はない。 ASCII 文字に \u エスケープ・シーケンスを混ぜる
書き方は、JAVA のソースファイルで使用されるエンコーディング (JAVA
source file encoding) としても知られているが、GNU の recode コマンド
3.5c 以降を使用すれば、任意の文字列をそのエンコーディングに変換する
ことができるのだ。以下に示すのは、一つのテキストを、ロケールに影響
されずにそのテキストを出力するシェルスクリプトに変換する方法である。

     $ LC_CTYPE=zh_CN.big5 /usr/local/bin/printf \
         '中文\n' > sample.txt
     $ recode BIG5..JAVA < sample.txt \
         | sed -e "s|^|/usr/local/bin/printf '|" -e "s|$|\\\\n'|" \
         > sample.sh

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: yes invocation,  Prev: printf invocation,  Up: Printing text

15.3 `yes': 中断されるまで文字列を表示する
=========================================================

`yes' は、コマンドラインで指定された引数を、空白で区切り、末尾に
改行を付けて、kill されるまで延々と表示する。引数が指定されていない
場合は、`y' の後ろに改行を付けて、kill されるまで延々と表示する。

   書き込みエラーがあると、`yes' はステータス `1' で終了する。

   指定できるオプションは、単独の `--help' か `--version' だけである。
`-' で始まる引数を出力するには、その引数の前に `--' を置けばよい。
たとえば、`yes -- --help' というようにだ。*Note Common options::.


File: coreutils-ja.info,  Node: Conditions,  Next: Redirection,  Prev: Printing text,  Up: Top

16 条件
*********

この章で説明するのは、その出力よりも終了ステータスの方が主として役に
立つコマンドである。従って、こうしたコマンドは、シェルの `if' 文の
条件として、あるいは、パイプラインの最後のコマンドとして使用される
ことが多い。

* Menu:

* false invocation::         何もせず、実行失敗のステータスを返す。
* true invocation::          何もせず、正常終了する。
* test invocation::          ファイルタイプのチェックや値の比較を行う。
* expr invocation::          式を評価する。


File: coreutils-ja.info,  Node: false invocation,  Next: true invocation,  Up: Conditions

16.1 `false': 何もせず、実行失敗のステータスを返す
====================================================================

`false' は、実行に失敗したこと ("failure") を示す終了ステータス 1 を
返す以外、何もしない。従って、シェルスクリプト中の、実行に失敗する
コマンドが必要な場所で、仮のコマンドとして使用することができる。
最近のほとんどのシェルでは、`false' は組み込みコマンドになっている
ので、スクリプト中で `false' を使う際に使用しているのは、ここで説明
している `false' ではなく、たぶん組み込みコマンドの方である。

   `false' は、`--help' と `--version' オプションを認識する。

   このバージョンの `false' は、C のプログラムとして実装されている。
従って、シェルスクリプトによる実装より安全かつ高速であり、アカウントを
無効化するための安全なダミー・シェルとして使用することができる。

   注意していただきたいが、`false' は、`--help' や`--version' を付けて
実行した場合でも (このマニュアルで説明している他のすべてのプログラム
とは違って)、実行失敗のステータスで終了する。

   移植を考慮したプログラムでは、`false' の終了ステータスを 1 だと
決めてかからない方がよい。GNU 以外のホストでは、終了ステータスが 1
より大きいこともあるからだ。


File: coreutils-ja.info,  Node: true invocation,  Next: test invocation,  Prev: false invocation,  Up: Conditions

16.2 `true': 何もせず、正常終了する
==============================================

`true' は、実行に成功したこと ("success") を示す終了ステータス 0 を
返す以外、何もしない。従って、シェルスクリプト中の、実行に成功する
コマンドが必要な場所で、仮のコマンドとして使用することができる。
とは言え、シェルの組み込みコマンド `:' (コロン) の方が、同じことを
より高速に実行してくれるかもしれない。最近のほとんどのシェルでは、
`true' は組み込みコマンドになっているので、スクリプト中で `true' を
使う際に使用しているのは、ここで説明している `true' ではなく、たぶん
組み込みコマンドの方である。

   `true' は、`--help' と `--version' オプションを認識する。

   もっとも、`true' を 0 以外のステータスで終了させることも可能だと
いうことも、心に留めておいていただきたい。`--help' や `--version' を
使用したとき、標準出力がすでにクローズされていたり、I/O エラーを引き
起こすようなファイルにリダイレクトしたりすると、そういうことが起きる。
たとえば、Bourne 互換のシェルを使用して、次のようにするときだ。

     $ ./true --version >&-
     ./true: write error: Bad file number
     $ ./true --version > /dev/full
     ./true: write error: No space left on device

   このバージョンの `true' は、C のプログラムとして実装されている。
従って、シェルスクリプトによる実装より安全かつ高速であり、アカウントを
無効化するための安全なダミー・シェルとして使用することができる。


File: coreutils-ja.info,  Node: test invocation,  Next: expr invocation,  Prev: true invocation,  Up: Conditions

16.3 `test': ファイルタイプのチェックや値の比較を行う
=========================================================================

`test' は、条件式 EXPRESSION の評価次第で、0 (真) または 1 (偽) の
ステータスを返す。式を構成する各部分は、独立した引数でなければならない。

   `test' は、ファイルのステータスを検査することができる。また、文字列を
扱う演算子や、数値を比較するための演算子を備えている。

   `test' には、`test' で始める書式のほかに、一対の角カッコを使用する
もう一つの書式がある。たとえば、`test -d /' の代わりに、`[ -d / ]' と
書いても構わない。角カッコは、それぞれ独立した引数でなければならない
(訳注: 言い換えれば、他の引数と空白で分離されていなければならない)。
だから、たとえば、`[-d /]' では、望みの結果を得られないわけだ。`test
EXPRESSION' と `[ EXPRESSION ]' は、同じ意味なので、以下では前者の書式
についてのみ解説する。

   書式:

     test EXPRESSION
     test
     [ EXPRESSION ]
     [ ]
     [ OPTION

   シェルの組み込み機能の `test' やエイリアスのために、`test' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `test' を起動すればよい (すなわち、 `env
test ...' のようにだ)。

   EXPRESSION を省略した場合、`test' は、偽を返す。EXPRESSION が引数 1
個だけだった場合、`test' は、その引数が空 (null) ならば、偽を返し、さも
なければ、真を返す。引数には、`-d', `-1', `--', `--help', `--version' と
いった、他のほとんどのプログラムでなら、オプションとして扱われるものも
含めて、どんな文字列でも指定することができる。そこで、ヘルプやバージョン
情報を取得するには、`[ --help' や `[ --version' という形でコマンドを
実行する必要がある。この場合、いつもと違って、閉じカッコは付けない。
*Note Common options::.

   終了ステータス:

     0: 式が真の場合。
     1: 式が偽の場合。
     2: エラーが起きた場合。

* Menu:

* File type tests::          ファイルタイプのテスト (-[gkruwxOG])。
* Access permission tests::  アクセス許可のテスト (-[gkruwxOG])。
* File characteristic tests::  ファイル特性のテスト (-e -s -nt -ot -ef)。
* String tests::             文字列のテスト (-z -n = == !=)。
* Numeric tests::            数値のテスト (-eq -ne -lt -le -gt -ge)。
* Connectives for test::     `test' の論理演算子 (! -a -o)。


File: coreutils-ja.info,  Node: File type tests,  Next: Access permission tests,  Up: test invocation

16.3.1 ファイルタイプのテスト
----------------------------------------

以下のオプションは、ある特定のファイルタイプかどうかの検査を行う。
(Unix では、あらゆるものがファイルだ。だが、ファイルならみんな同じだ
というわけではない！)

`-b FILE'
     FILE が存在し、ブロック・スペシャルデバイスならば、真。

`-c FILE'
     FILE が存在し、キャラクタ・スペシャルデバイスならば、真。

`-d FILE'
     FILE が存在し、ディレクトリならば、真。

`-f FILE'
     FILE が存在し、通常ファイルならば、真。

`-h FILE'
`-L FILE'
     FILE が存在し、シンボリックリンクならば、真。ファイル関係の他の
     すべてのテストとは違って、このテストは、FILE がシンボリックリンク
     の場合、リンクの参照を行わない。

`-p FILE'
     FILE が存在し、名前付きパイプならば、真。

`-S FILE'
     FILE が存在し、ソケットならば、真。

`-t FD'
     FD が端末と結びついているファイルディスクリプタならば、真。



File: coreutils-ja.info,  Node: Access permission tests,  Next: File characteristic tests,  Prev: File type tests,  Up: test invocation

16.3.2 アクセス許可のテスト
-------------------------------------

以下のオプションは、特定のアクセス許可について検査をする。

`-g FILE'
     FILE が存在し、set-group-ID ビットが立っていれば、真。

`-k FILE'
     FILE が存在し、"sticky" ビットが立っていれば、真

`-r FILE'
     FILE が存在し、読み出しが許可されていれば、真。

`-u FILE'
     FILE が存在し、set-user-ID ビットが立っていれば、真。

`-w FILE'
     FILE が存在し、書き込みが許可されていれば、真。

`-x FILE'
     FILE が存在し、実行が許可されていれば (ディレクトリの場合は、
     検索が許可されていれば)、真。

`-O FILE'
     FILE が存在し、その所有者が test コマンド実行者の実効ユーザ ID
     と同じならば、真。

`-G FILE'
     FILE が存在し、そのグループが test コマンド実行者の実効グループ ID
     と同じならば、真。



File: coreutils-ja.info,  Node: File characteristic tests,  Next: String tests,  Prev: Access permission tests,  Up: test invocation

16.3.3 ファイル特性のテスト
-------------------------------------

以下のオプションは、ファイルの他の特性を検査する。

`-e FILE'
     FILE が存在すれば、真。

`-s FILE'
     FILE が存在し、サイズが 0 よりも大きければ、真。

`FILE1 -nt FILE2'
     FILE1 が FILE2 より (更新日時 (modification date) で比較して)
     新しいか、あるいは、FILE1 が存在して、FILE2 が存在しなければ、真。

`FILE1 -ot FILE2'
     FILE1 が FILE2 より (更新日時で比較して) 古いか、あるいは、FILE2 が
     存在して、FILE1 が存在しなければ、真。

`FILE1 -ef FILE2'
     FILE1 と FILE2 が同じデバイス番号と同じ inode 番号を持っていれば、
     言い換えれば、両者が互いのハードリンクならば、真。



File: coreutils-ja.info,  Node: String tests,  Next: Numeric tests,  Prev: File characteristic tests,  Up: test invocation

16.3.4 文字列のテスト
----------------------------

以下のオプションは、文字列の特性を検査する。シェルに対して STRING を
引用符で保護する必要があるかもしれない。たとえば、こんなふうにだ。

     test -n "$V"

   ここで引用符は、`$V' が空だったり、特殊文字を含んでいたりする場合に、
意図に反した引数が `test' に渡ることを防いでいる。

`-z STRING'
     STRING の長さが 0 ならば、真。

`-n STRING'
`STRING'
     STRING の長さが 0 でなければ、真。

`STRING1 = STRING2'
     両文字列が等しければ、真。

`STRING1 == STRING2'
     両文字列が等しければ、真 (= と同じ意味)。

`STRING1 != STRING2'
     両文字列が等しくなければ、真。



File: coreutils-ja.info,  Node: Numeric tests,  Next: Connectives for test,  Prev: String tests,  Up: test invocation

16.3.5 数値のテスト
-------------------------

数値の関係を調べる演算子を挙げる。引数は、数字以外のものが混じらない
純粋な数値か (負数も使用できる)、`-l STRING' という特別な式でなければ
ならない。後者は STRING の長さとして評価される。

`ARG1 -eq ARG2'
`ARG1 -ne ARG2'
`ARG1 -lt ARG2'
`ARG1 -le ARG2'
`ARG1 -gt ARG2'
`ARG1 -ge ARG2'
     こうした二項算術演算子は、それぞれ次の場合に真を返す。上から順に、
     ARG1 が ARG2 と比べて、等しい場合、等しくない場合、より小さい場合、
     より小さいか等しい場合、より大きい場合、より大きいか等しい場合。


   例を挙げる。

     test -1 -gt -2 && echo yes
     => yes
     test -l abc -gt 1 && echo yes
     => yes
     test 0x100 -eq 1
     error--> test: integer expression expected before -eq


File: coreutils-ja.info,  Node: Connectives for test,  Prev: Numeric tests,  Up: test invocation

16.3.6 `test' の論理演算子
--------------------------------

おなじみの論理演算子である。

`! EXPR'
     EXPR が偽ならば、真。

`EXPR1 -a EXPR2'
     EXPR1 と EXPR2 の両方が真ならば、真。

`EXPR1 -o EXPR2'
     EXPR1 と EXPR2 のどちらかが真ならば、真。



File: coreutils-ja.info,  Node: expr invocation,  Prev: test invocation,  Up: Conditions

16.4 `expr': 式を評価する
===============================

`expr' は、式を評価して、結果を標準出力に書き出す。式の各構成要素
(token) は、独立した引数でなければならない。

   オペランドは、整数か文字列である。整数は、1 個以上の 10 進数の数字
から構成され、先頭に `-' が付いていてもよい。`expr' は、オペランドの
位置にあるものが何であれ、それを整数、または、文字列に変換する。
どちらになるかは、それに対して行われる演算次第である。

   `expr' そのものに対しては、文字列をクォートする必要がない。だが、
シェルにとって特別な意味がある、たとえば空白のような文字を保護する
ためには、文字列を引用符で囲むなどの方法でクォートする必要があるかも
しれない。とは言え、クォートされているかどうかに関わりなく、文字列の
オペランドは、丸カッコ 1 個であってはならないし、`+' のような `expr'
の演算子の一つであるべきでもない。すなわち、シェルに対してクォートする
だけでは、エラーを引き起こすことなく、任意の文字列 `$str' を `expr' に
渡すことはできないのだ。この問題を回避する方法の一つは、GNU の拡張
である `+' 演算子 (訳注: この `+' は、算術演算子の `+' ではなく、直後に
来る引数が文字列であることを示す文字列演算子である) を使用することだ
(たとえば、`+ "$str" = foo' といった具合に)。もっと移植性のある方法は、
`" $str"' という先頭に空白を入れた表現を使用し、式の残りの部分でも
それに合わせて、先頭のスペースを考慮に入れるようにすることである
(たとえば、`" $str" = " foo"' のように)。

   負の整数や、`-' で始まる文字列を `expr' の 1 番目の引数として渡す
べきではない。オプションと間違われかねないからだ。それを避けるため
には、カッコでくくればよい (訳注: たとえば、`expr \( -1 + 1 \)')。
また、移植を考慮したスクリプトでは、文字列のオペランドに、形が整数と
同じになってしまうものを使うべきではない。こちらは、先頭にスペースを
入れる上記の方法で回避できる。

   演算子には、記号としてオペランドとオペランドの間に置くものもあれば、
キーワードとしてオペランドの前に付けるものもある。丸カッコは、おなじみの
やり方で、グループ化に使用できる。ただし、丸カッコや、演算子の多くは、
シェルによって評価されないように、クォートしなければならない。

   GNU MP ライブラリ対応でビルドされた場合、`expr' は任意精度演算を
使用する。そうでない場合は、ネイティブな算術型を使用するので、算術
オーバーフローのために実行に失敗することがあるかもしれない。

   指定できるオプションは、`--help' と `--version' だけである。 *Note
Common options::.  オプションはオペランドの前に置かなければならない。

   終了ステータス:

     0: 式が null でも 0 でもない場合。
     1: 式が null または 0 の場合。
     2: 式が無効な場合。
     3: 内部エラーが起きた場合 (例: 算術オーバーフロー)。

* Menu:

* String expressions::       文字列式 (+ : match substr index length)。
* Numeric expressions::      数式 (+ - * / %)。
* Relations for expr::       論理結合と関係表現 (| & < <= = == != >= >)。
* Examples of expr::         用例。


File: coreutils-ja.info,  Node: String expressions,  Next: Numeric expressions,  Up: expr invocation

16.4.1 文字列式
-------------------

`expr' は、パターンマッチなどの文字列演算子をサポートしている。文字列
演算子の優先順位は、算術演算子や関係演算子よりも高い (算術/関係演算子
については後述する)。

`STRING : REGEX'
     パターンマッチを行う。まず、左右の項を文字列に変換し、右項を、
     先頭に `^' が暗黙のうちに付いている正規表現と見なす (`grep' 風の
     基本正規表現)。それから、その正規表現と左項がマッチするかどうかを
     調べる。

     マッチが成功した場合、REGEX 中でカッコ (`\(' と `\)') を使用して
     いれば、`:' 演算子は、そのカッコ内の部分表現にマッチした STRING
     中の部分文字列を返す。カッコを使っていなければ、返すのはマッチした
     文字数である。

     マッチに失敗した場合、`:' 演算子は、REGEX 中でカッコ (`\(' と `\)')
     を使用していれば、空文字列を、さもなければ、0 を返す。

     最初の `\( ... \)' のペアだけが、返り値に関係する。二番目以降の
     カッコのペアには、正規表現の演算子をグループ化する働きしかない。

     正規表現では、`\+', `\?', `\|' は演算子であり、それぞれ、1 個以上
     にマッチする、あってもなくてもよい、候補のうちのどちらか、を意味して
     いる。ところが、SunOS などの `expr' では、こうした記号を通常の文字
     として扱っている (POSIX は、どちらの動作も認めている)。正規表現の
     文法については次のものが詳しい。*Note Regular Expression Library:
     (regex)Top.  実例をいくつか、「`expr' の使用例」に挙げておいた。
     *note Examples of expr::.

`match STRING REGEX'
     パターンマッチを行う別の方法。これは、`STRING : REGEX' と同じ
     である。

`substr STRING POSITION LENGTH'
     STRING の部分文字列を返す。部分文字列は、POSITION の位置から
     始まり、最長でも LENGTH の長さである。POSITION と LENGTH のどちらか
     が、負数や 0 だったり、数値以外だったりする場合は、空文字列を返す。

`index STRING CHARSET'
     CHARSET 中の文字が最初に見つかった STRING 中の位置を返す。STRING
     中に CHARSET 中のどの文字も見つからなかった場合は、0 を返す。

`length STRING'
     STRING の長さを返す。

`+ TOKEN'
     たとえ、TOKEN が `match' のようなキーワードや、 `/' のような演算子
     であっても、TOKEN を文字列として解釈する。これを使用すると、`expr
     length + "$x"' や `expr + "$x" : '.*/\(.\)'' を実行したとき、`$x'
     の値が (たとえば) たまたま `/' や `index' であっても、適切な動作を
     させることができる。この演算子は、GNU の拡張である。移植を考慮した
     シェルスクリプトでは、`+ "$token"' ではなく、`" $token" :
     ' \(.*\)'' を使うべきである。


   `expr' にキーワードを文字列として解釈させるためには、クォート演算子
(すなわち、上で述べている `+' 演算子) を使用しなければならない。


File: coreutils-ja.info,  Node: Numeric expressions,  Next: Relations for expr,  Prev: String expressions,  Up: expr invocation

16.4.2 数式
-------------

`expr' は、以下に挙げる通常の算術演算子を、昇順の優先順位で、サポート
している。こうした算術演算子は、前節で述べた文字列演算子より優先順位が
低く、次節で述べる関係演算子より優先順位が高い。

`+ -'
     加算と減算。左右の項は両方とも整数に変換される。整数に変換できない
     場合は、エラーになる。

`* / %'
     乗算、除算、剰余演算、左右の項は両方とも整数に変換される。整数に
     変換できない場合は、エラーになる。



File: coreutils-ja.info,  Node: Relations for expr,  Next: Examples of expr,  Prev: Numeric expressions,  Up: expr invocation

16.4.3 `expr' の関係表現
-----------------------------

`expr' は、通常の論理結合や関係表現をサポートしている。そうした演算子
は、前の節で述べた文字列演算子や算術演算子より優先順位が低い。論理結合や
関係表現の演算子を、優先順位の低いものから高いものへ順に並べておく。

`|'
     左項が null でも 0 でもなければ、左項を返す。左項が null または 0
     の場合は、右項が null でも 0 でもなければ、右項を返す。両項とも
     null または 0 の場合は、0 を返す。左項が null でも 0 でもない場合、
     右項の評価は行わない。

`&'
     両項とも null でも 0 でもなければ、左項を返し、それ以外の場合は、0
     を返す。左項が null または 0 の場合、右項の評価は行わない。

`< <= = == != >= >'
     両項を比較し、関係が真ならば、1 を返し、偽の場合は、0 を返す。
     `==' は `=' と同じ意味である。`expr' は、まず両項を整数に変換し、
     数値としての比較を試みる。左右どちらかの項の変換に失敗した場合は、
     `LC_COLLATE' のロケールで指定されている、文字の照合順を使用して、
     辞書的な比較を行う。



File: coreutils-ja.info,  Node: Examples of expr,  Prev: Relations for expr,  Up: expr invocation

16.4.4 `expr' の使用例
--------------------------

シェルのメタ文字をクオートする例も含めて、用例をいくつか挙げておく。

   Bourne 互換シェルで、シェル変数 `foo' に 1 を加える。

     foo=$(expr $foo + 1)

   変数 `$fname' に格納されているファイル名から、ディレクトリではない
部分を取り出して、表示する。`$fname' に `/' が含まれていなくてもよい。

     expr $fname : '.*/\(.*\)' '|' $fname

   次の例で `\+' は演算子である (訳注: 細かいことを言うと、`grep' 流
の基本正規表現の演算子。ちなみに、最後の例の `+' は、`expr' の文字列
演算子である)。

     expr aaa : 'a\+'
     => 3

     expr abc : 'a\(.\)c'
     => b
     expr index abcdef cz
     => 3
     expr index index a
     error--> expr: syntax error
     expr index + index a
     => 0


File: coreutils-ja.info,  Node: Redirection,  Next: File name manipulation,  Prev: Conditions,  Up: Top

17 リダイレクション
***************************

Unix のシェルは、いくつかの形式のリダイレクション ("redirection") --
コマンドの入力元や出力先を変更する手段 -- をたいてい用意している。
しかし、ある一つの便利なリダイレクションは、シェルではなく、独立した
コマンドによって行われる。この章では、そのコマンドについて説明する。

* Menu:

* tee invocation::           出力を複数のファイルやプロセスにリダイレクトする。


File: coreutils-ja.info,  Node: tee invocation,  Up: Redirection

17.1 `tee': 出力を複数のファイルやプロセスにリダイレクトする
====================================================================================

`tee' コマンドは、標準入力を標準出力にコピーするとともに、引数として
指定されたファイル (複数可) にもコピーする。これは、あるデータをパイプ
に送るだけでなく、同時にそのコピーを保存したい場合に、便利である。

   書式:

     tee [OPTION]... [FILE]...

   書き出し先のファイルがまだ存在していなければ、作成される。書き出し
先のファイルがすでに存在している場合は、`-a' オプションを使用しない
かぎり、ファイルに前からあったデータは上書きされる。

   FILE の一つに `-' を指定すると、`tee' は、入力のコピーをもう一つ、
標準出力に送出する。だが、コピー同士が重なり合うので、たいていの場合、
これはあまり役に立たない。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--append'
     指定されたファイルの末尾に標準入力を追加する。すなわち、ファイルを
     上書きしない。

`-i'
`--ignore-interrupts'
     割り込みシグナルを無視する。


   大量のデータの転送を行いながら、同時にそのデータのサマライズも
行いたい、改めてデータを読み直すようなことはしたくない。`tee' は、
そういうときに便利である。たとえば、DVD イメージをダウンロードして
いるとき、その場ですぐ、署名やチェックサムを確認したくなることがよく
ある。単に次のようにするのは、効率が悪い。

     wget http://example.com/some.iso && sha1sum some.iso

   上記コマンドの問題点の一つは、ただでさえ時間のかかる SHA1 の計算に
取りかかる前に、ダウンロードが完了するのを待たなければならないことで
ある。たぶん、さらに問題なのは、上記のやり方では、DVD イメージを改めて
読み直さなければならないことだろう (一度目の読み込みは、ネットワーク
から)。

   こうした作業を行う効率的な方法は、ダウンロードと SHA1 の計算を
同時に、交互に実行することである。そうすれば、プロセス全体が平行して
スムーズに進むので、無駄な時間を使わずに、チェックサムが手に入る。

     # ちょっと凝った方法。プロセス置換の実例をご覧に入れるため。
     wget -O - http://example.com/dvd.iso \
       | tee >(sha1sum > dvd.sha1) > dvd.iso

   こうすれば、`tee' は、出力を目当てのファイルに書き出すだけでなく、
パイプにも書き出す。そして、後者では、 `sha1sum' を実行し、最終的に
チェックサムを `dvd.sha1' という名前のファイルに保存することになる。

   しかし、気をつけていただきたい。上記の例は、プロセス置換 ("process
substitution") と呼ばれる最近のシェルの機能を当てにしている (上記の
`>(command)' という構文のことである。*Note Process Substitution:
(bashref)Process Substitution.)。 そのため、`zsh', `bash', `ksh' では
うまく動作するが、`/bin/sh' では動作しない。従って、こうしたコードを
シェルスクリプトで使用するときは、スクリプトの先頭に `#!/bin/bash' など
と書くことを忘れてはいけない。

   上記の例は、1 個のファイルと 1 個のプロセスに書き出しているだけだ。
その程度なら、もっと普通の、もっと移植性のある使い方をした方が、ずっと
よい。

     wget -O - http://example.com/dvd.iso \
       | tee dvd.iso | sha1sum > dvd.sha1

   `tee' が二つのプロセスに書き込むように、この例を拡張して、MD5 と
SHA1 のチェックサムを平行して計算させることもできる。その場合は、
プロセス置換が必要になる。

     wget -O - http://example.com/dvd.iso \
       | tee >(sha1sum > dvd.sha1) \
             >(md5sum > dvd.md5) \
       > dvd.iso

   このテクニックは、パイプから入ってくるデータの圧縮したコピーを作り
たいときにも、役に立つ。`du -ak' の出力するディスク使用量のデータを
要約して、グラフィカルに表示してくれるツールを考えていただきたい。
ディレクトリ階層が膨大だと、`du -ak' は実行に長い時間がかかるだろう
し、いともたやすくテラバイトのデータを作成してくれるだろう。そこで、
こちらとしては、`du' コマンドをむやみに再実行したくない。また、圧縮
される前のデータを保存しておきたくもない。

   これを効率の悪い方法でやると、`du' の出力全部の圧縮を済ませるまで、
GUI ツールを起動することすらできない。

     du -ak | gzip -9 > /tmp/du.gz
     gzip -d /tmp/du.gz | xdiskusage -a

   `tee' とプロセス置換を使えば、GUI ツールを直ちに起動できるし、
圧縮ファイルの展開も全くやらないですむ。

     du -ak | tee >(gzip -9 > /tmp/du.gz) | xdiskusage -a

   最後にもう一つ。常に 2 種類以上の圧縮した tar アーカイブ (tarball)
を一度に作ることにしている場合は、より効率のよいやり方ができるかも
しれない。たとえば、`make dist' が `gzip' と `bzip2' の両方で圧縮した
tar アーカイブを作成するような場合だ。`automake' が生成する `Makefile'
のルールは、たいてい、こんなふうにコマンドを連続して実行することで、
圧縮した tar アーカイブを二つ作成している (少し単純化してある)。

     tardir=your-pkg-M.N
     tar chof - "$tardir" | gzip  -9 -c > your-pkg-M.N.tar.gz
     tar chof - "$tardir" | bzip2 -9 -c > your-pkg-M.N.tar.bz2

   しかしながら、アーカイブの作成・圧縮の対象になっているディレクトリ
階層が、数メガバイトより大きい場合は -- 使用しているシステムがマルチ
プロセッサを搭載し、メモリがふんだんにある場合はなおさらそうだが --
ディレクトリの中身を 1 回だけ読み込み、圧縮プログラムを平行して走ら
せることで、ずっと効率のよい仕事ができる。

     tardir=your-pkg-M.N
     tar chof - "$tardir" \
       | tee >(gzip -9 -c > your-pkg-M.N.tar.gz) \
       | bzip2 -9 -c > your-pkg-M.N.tar.bz2

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: File name manipulation,  Next: Working context,  Prev: Redirection,  Up: Top

18 ファイル名操作
************************

この章では、ファイル名操作に使うコマンドについて説明する。

* Menu:

* basename invocation::      ファイル名からディレクトリと接尾辞を取り除く。
* dirname invocation::       ファイル名から最後の要素を取り除く。
* pathchk invocation::       ファイル名の有効性や可搬性を検査する。
* mktemp invocation::        テンポラリファイルやディレクトリを作成する。
* realpath invocation::      ファイル名を展開して表示する。


File: coreutils-ja.info,  Node: basename invocation,  Next: dirname invocation,  Up: File name manipulation

18.1 `basename': ファイル名からディレクトリと接尾辞を取り除く
===================================================================================

`basename' は、NAME の先頭にディレクトリ部分があれば、それを取り除く。

   書式:

     basename NAME [SUFFIX]
     basename OPTION... NAME...

   SUFFIX が指定されていて、それが NAME の末尾と同一ならば、SUFFIX の
部分も NAME から取り除かれる。気をつけていただきたいが、ファイル名の
末尾のスラッシュは、接尾辞のマッチングに先立って除去されるので、SUFFIX
にスラッシュが含まれていると、指定に効果がないことになる。`basename'
は、 結果を標準出力に表示する。

   `basename' と `dirname' は合わせて設計されており、もし `ls "$name"'
が成功するならば、`cd "$(dirname "$name")"; ls "$(basename "$name")"'
というコマンドの連続も成功するようになっている。これは、ファイル名の
末尾に改行が付いている場合を除いて、あらゆる場合にうまく行く。

   POSIX によれば、NAME が空の場合や `//' の場合に、結果がどうなるかは、
実装側で決めてよいことになっている。前者の場合、GNU の `basename' は、
空文字列を返す。後者の場合、// と / とが別のものであるプラットフォーム
では、結果は `//' になり、全く区別しないプラットフォームでは、結果は `/'
になる。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`-a'
`--multiple'
     複数の引数を受け付ける。すべての引数は NAME として処理される。この
     オプションを使用する場合、SUFFIX を指定するならば、`-s' オプション
     を使わなければならない。

`-s SUFFIX'
`--suffix=SUFFIX'
     末尾にある SUFFIX を除去する。このオプションを指定すると `-a' オプ
     ションも指定したことになる。

`-z'
`--zero'
     出力する項目を NUL 文字で区切る。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例:

     # "sort" を出力する。
     basename /usr/bin/sort

     # "stdio" を出力する。
     basename include/stdio.h .h

     # "stdio" を出力する。
     basename -s .h include/stdio.h

     # "stdio", "stdlib" の順に出力する。
     basename -a -s .h include/stdio.h include/stdlib.h


File: coreutils-ja.info,  Node: dirname invocation,  Next: pathchk invocation,  Prev: basename invocation,  Up: File name manipulation

18.2 `dirname': ファイル名から最後の要素を取り除く
===================================================================

`dirname' は、各 NAME からスラッシュで区切られた最後の要素を取り除いて、
残りのすべてを表示する。その際、最後の要素の左右どちらにあるスラッシュ
も削除される。NAME を構成する文字列にスラッシュが一つも含まれない場合、
`dirname' は (カレントディレクトリを意味する) `.' を表示する。

   書式:

     dirname [OPTION] NAME...

   NAME は実在するファイル名でなくても構わないが、実在するファイル名
ならば、この操作によって、最後の要素が存在するディレクトリが、最後の
要素それ自体がディレクトリである場合も含めて、利用できる形で表示される。

   `basename' と `dirname' は合わせて設計されており、もし `ls "$name"'
が成功するならば、`cd "$(dirname "$name")"; ls "$(basename "$name")"'
というコマンドの連続も成功するようになっている。これは、ファイル名の
末尾に改行が付いている場合を除いて、あらゆる場合にうまく行く。

   POSIX によれば、NAME が `//' の場合に、結果がどうなるかは、実装側で
決めてよいことになっている。GNU の `dirname' について言うと、// と /
とが別のものであるプラットフォームでは、結果は `//' になり、全く区別
しないプラットフォームでは、結果は `/' になる。

   このプログラムでは、以下のオプションが使える。参照: *note Common
options::.

`-z'
`--zero'
     出力する項目を NUL 文字で区切る。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   用例:

     # "/usr/bin" を出力する。
     dirname /usr/bin/sort
     dirname /usr/bin//.//

     # "dir1", "dir2" の順に出力する。
     dirname dir1/str dir2/str

     # "." を出力する。
     dirname stdio.h


File: coreutils-ja.info,  Node: pathchk invocation,  Next: mktemp invocation,  Prev: dirname invocation,  Up: File name manipulation

18.3 `pathchk': ファイル名の有効性や可搬性を検査する
======================================================================

`pathchk' は、ファイル名が有効かどうか、可搬性があるかどうかを検査する。

   書式:

     pathchk [OPTION]... NAME...

   `pathchk' は各 NAME に対して、以下の条件のどれかが真ならば、エラー
メッセージを表示する。

  1. NAME 中の実在するディレクトリの一つが、検索 (実行) 許可を持って
     いない。

  2. NAME の長さが、オペレーティング・システムによってサポートされている
     最大長を越えている。

  3. NAME の構成要素の一つの長さが、それが存在することになるファイル
     システムによってサポートされている最大長を越えている。

   実在しないファイル名を指定しても、エラーにはならない。その名前の
ファイルが、上記の条件内で作成できればよい。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`-p'
     実際に使用しているファイルシステムに基づいて検査を行うのではなく、
     以下の条件を調べて、そのどれかが真ならば、エラーメッセージを表示
     する。

       1. ファイル名が空である。

       2. ファイル名に、どのシステムでもファイル名に使用できる文字と
          して POSIX が規定している文字セット以外の文字が含まれている。
          すなわち、ASCII 英数字、`.'、`_'、`-'、`/' 以外の文字が使用
          されている。

       3. ファイル名の長さや、その構成要素の一つの長さが、POSIX の規格で
          可搬性のために最小限必要とされている長さを越えている。

`-P'
     ファイル名が空だったり、`-' で始まる構成要素を含んでいたりすると、
     エラーメッセージを表示する。

`--portability'
     ファイル名が POSIX に準拠しているすべてのホストで使えるもので
     なければ、エラーメッセージを表示する。このオプションは、`-p -P' と
     同じことである。


   終了ステータス:

     0: 指定されたすべてのファイル名が検査のすべてにパスした場合。
     1: それ以外。


File: coreutils-ja.info,  Node: mktemp invocation,  Next: realpath invocation,  Prev: pathchk invocation,  Up: File name manipulation

18.4 `mktemp': テンポラリファイルやディレクトリを作成する
==============================================================================

`mktemp' は、テンポラリファイルやテンポラリディレクトリの作成を行う。

   書式:

     mktemp [OPTION]... [TEMPLATE]

   `mktemp' は、TEMPLATE を基にして、安全なテンポラリファイルや
ディレクトリを作成し、その名前を表示する。TEMPLATE を指定する場合、
その最後の構成部分に少なくとも 3 個の連続する `X' が含まれていなければ
ならない。省略した場合は、`tmp.XXXXXXXXXX' というテンプレートが使用
され、 `--tmpdir' オプションが暗黙のうちに指定されることになる。
TEMPLATE 中の `X' が連続する最後の部分は、英数字で置き換えられる。
従って、大文字小文字を区別するファイルシステムなら、テンプレートに
連続する N 個の `X' が含まれていると、作成されるファイル名には、 62 の
N 乗とおりの可能性があることになる。

   昔のスクリプトでは、テンポラリファイルを作成する際に、単にプログラム
の名前にプロセス ID (`$$') を拡張子として付けるのが習慣だった。しかし、
この命名法は、名前の推測が容易であり、従って、競合状態を起こしやすい
という弱点がある。攻撃者としては、テンポラリファイルに使われそうな名前で
シンボリックリンクを作っておけばよい。そうすれば、スクリプトが未使用の
ファイルだと考えて、テンポラリファイルのファイルハンドルを開いたとき、
実際にはすでに存在しているファイルに書き込みをしているという羽目になる。
同じ命名法を使ってディレクトリを作成するのは、もう少し安全である。
作成対象のディレクトリがすでに存在していると、`mkdir' は実行に失敗
するからだ。とは言え、こちらもサービス不能化攻撃 (denial of service
attacks) を許してしまうわけで、やはり良策とは言えない。それ故、新しい
スクリプトでは `mktemp' コマンドを使用するべきである。そうすれば、
生成されるファイル名が確実に予測不可能になるので、実行中のスクリプトが
テンポラリファイルの名前を知っているというまさにその事実が、ファイルを
作成したのがそのスクリプトであり、他のユーザはそのファイルをいじることが
できないと、間違いなく示すことになる。

   ファイルを作成する場合、作成されるファイルには現在のユーザに対する
読み込みと書き出しの許可が付くが、グループやその他のユーザに対しては、
いかなる許可も付かない。現在の umask がより厳格な場合、付けられる許可は
さらに厳しくなる。

   用例をいくつか挙げてみる (ただし、注意していただきたいが、お手元で
この通り実行しても、おそらくファイル名は違ったものになるはずだ)。

   * カレントディレクトリにテンポラリファイルを作成する。
          $ mktemp file.XXXX
          file.H47c

   * 一般的な拡張子を付けて、テンポラリファイルを作成する。
          $ mktemp --suffix=.txt file-XXXX
          file-H08W.txt
          $ mktemp file-XXXX-XXXX.txt
          file-XXXX-eI9L.txt

   * ユーザが環境変数 `TMPDIR' で指定しているディレクトリを基点として、
     その下に安全な FIFO を作成する。`TMPDIR' が設定されていない場合は、
     `/tmp' ではなく、カレントディレクトリを基点として使用する。肝腎な
     点は、`mktemp' は FIFO を作成しないが、FIFO を置くことができる
     安全なディレクトリなら作成できるということである。ディレクトリや
     FIFO を作成することができなかったときは、シェルを終了する。
          $ dir=$(mktemp -p "${TMPDIR:-.}" -d dir-XXXX) || exit 1
          $ fifo=$dir/fifo
          $ mkfifo "$fifo" || { rmdir "$dir"; exit 1; }

   * 可能ならば、テンポラリファイルを作成して使用するが、作成に失敗
     しても、エラーメッセージを出さない。ファイルは、環境変数 `TMPDIR'
     が設定されていれば、そこで指名されているディレクトリに作られるが、
     設定されていなければ、`/tmp' に作られる。
          $ file=$(mktemp -q) && {
          >   # $file の使用をこのブロックの内側に限定しておけば、
          >   # 安全である。$file を引用符で囲んでいるのは、$TMPDIR が、
          >   # 従って、$file が、ホワイトスペースを含んでいるかも
          >   # しれないからだ。
          >   echo ... > "$file"
          >   rm "$file"
          > }

   * 擬似ランダム文字発生装置として動作する (カレントディレクトリの内容
     によって影響を受けるので、完全にランダムではない)。セキュリティ
     ホールを避けたいならば、生成された名前を使って、ファイルを作っては
     いけない。
          $ mktemp -u XXX
          Gb9
          $ mktemp -u XXX
          nzC


   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-d'
`--directory'
     ファイルではなく、ディレクトリを作成する。作成されるディレクトリには
     現在のユーザに対して、読み、書き、検索の許可が付くが、グループや
     その他のユーザに対しては、いかなる許可も付かない。現在の umask が
     より厳格な場合、付けられる許可はさらに厳しくなる。

`-q'
`--quiet'
     ファイルやディレクトリの作成に失敗しても、エラーメッセージを出さない。
     終了ステータスは、ファイルが作成されたかどうかをやはり反映する。

`-u'
`--dry-run'
     既存のファイルの名前と重ならないテンポラリファイル用の名前を生成
     するが、ファイルシステムの内容を変更することはない (訳注: 要する
     に、テンポラリファイル名を生成表示するだけで、実際にファイルを
     作成することはないということ)。このコマンドの出力を使って、新しい
     ファイルを作るのは、本質的に安全ではない。名前の生成とその使用との
     間には、時間差があり、その間に他のプロセスが同じ名前でオブジェクト
     を作成することが可能だからである。

`-p DIR'
`--tmpdir[=DIR]'
     TEMPLATE をディレクトリ DIR を基点とする相対パスとして扱う。 DIR
     が指定されていない場合や (ロングオプションの `--tmpdir' でのみ
     可能)、空文字列の場合は、環境変数 `TMPDIR' が設定されていれば、その
     値を使用し、設定されていなければ、`/tmp' を使用する。このオプション
     を指定する場合、 TEMPLATE は絶対パスであってはならない。とは言え、
     TEMPLATE にスラッシュが含まれていても構わないが、その場合、途中に
     あるディレクトリはすでに存在していなければならない。

`--suffix=SUFFIX'
     TEMPLATE の末尾に SUFFIX を追加する。SUFFIX はスラッシュを含んで
     いてはならない。`--suffix' を指定する場合、TEMPLATE は `X' で終わっ
     ていなければならない。`--suffix' が指定されていない場合は、TEMPLATE
     中の最後の `X' の位置を調べることで、SUFFIX としてふさわしいもの
     を割り出す。このオプションが存在するのは、デフォルトの TEMPLATE を
     使用しているとき、`X' で始まる SUFFIX を付けられるようにするため
     である。

`-t'
     TEMPLATE を、環境変数 `TMPDIR' が設定されていれば、その値である
     ディレクトリ直下の 1 個のファイルとして扱う。`TMPDIR' が設定されて
     いなければ、`-p' で指定されるディレクトリ直下、それ以外の場合は、
     `/tmp' 直下になる。なお、TEMPLATE にスラッシュが含まれていてはなら
     ない。このオプションは非推奨である。`-t' なしで `-p' を使う方が
     (`TMPDIR' よりコマンドラインの指定を優先するという点で) デフォルト
     の動作として優れているし、(途中のディレクトリも指定できるという
     点で) 柔軟性も上だからである。


   終了ステータス:

     0: ファイルが作成された場合。
     1: それ以外。


File: coreutils-ja.info,  Node: realpath invocation,  Prev: mktemp invocation,  Up: File name manipulation

18.5 `realpath': ファイル名を展開して表示する
===========================================================

`realpath' は、すべてのシンボリックリンクを展開し、`/./' や `/../' に
対する参照を解決する。さらに、余分な `/' 文字の削除も行う。デフォルト
では、指定したファイル名のうち、最後の要素以外のすべての要素が実在して
いなければならない。

   書式:

     realpath [OPTION]... FILE...

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-e'
`--canonicalize-existing'
     指定されたファイル名中のすべての構成要素が実在することを確認する。
     存在しなかったり、利用できなかったりする要素があると、`-q' オプ
     ションが指定されていないかぎり、`realpath' はエラーメッセージを
     出し、0 以外の終了コードで終了する。ファイル名の末尾にスラッシュ
     を付けると、その名前はディレクトリであるという指定になる。

`-m'
`--canonicalize-missing'
     指定されたファイル名中に存在しなかったり、使用できなかったりする
     構成要素があれば、それをディレクトリとして処理する。

`-L'
`--logical'
     指定されたファイル名中にあるシンボリックリンクを展開する。ただし、
     シンボリックリンクに `..' という要素が後続している場合は、シンボ
     リックリンクの展開を行う前に、そちらを先に処理する。(訳注: 例を
     挙げた方が、わかりやすいだろう。`symlink-directory/../..' といった
     ファイル名が与えられた場合、symlink-directory というシンボリック
     リンクそのものの親ディレクトリの親ディレクトリに展開するという
     こと。次項の注と比較していただきたい。)

`-P'
`--physical'
     指定されたファイル名中にあるシンボリックリンクを展開する。シンボ
     リックリンクに `..' という要素が後続している場合も、シンボリック
     リンクを展開してから、`..' の処理を行う。こちらがデフォルトの動作
     モードである。(訳注: すなわち、`symlink-directory/../..' といった
     ファイル名が与えられた場合、シンボリックリンクの参照先の親ディレ
     クトリの親ディレクトリに展開する。)

`-q'
`--quiet'
     指定されたファイル名についてエラーメッセージを出力しない。

`-s'
`--strip'
`--no-symlinks'
     シンボリックリンクの展開を行わない。すなわち、`/./' や `/../' の
     参照の解決と、余分な `/' 文字の削除だけを行う。`-m' オプションと
     組み合わせた場合、`realpath' は与えられたファイル名の操作を行う
     だけであって、実在のファイルとは全くかかわりを持たない。

`-z'
`--zero'
     出力する項目を NUL 文字で区切る。

`--relative-to=FILE'
     オプション引数に指定したファイルを基点とする相対パスとして、
     ファイル名を展開する。このオプションは、ファイルの存在に関して
     `-m' や `-e' オプションを認識することに注意していただきたい。

`--relative-base=BASE'
     このオプションは `--relative-to' と一緒に使うこともでき、その
     場合は、操作対象の FILE が BASE 以下のディレクトリに存在するとき
     にのみ、相対パス名を表示するように、`--relative-to' の出力に制限
     を課す。FILE が BASE 以下のディレクトリに存在しないときは、出力
     は絶対パスのファイル名になる。`--relative-to' を指定しなかった
     場合、BASE 以下のディレクトリに存在するファイルは、BASE を基点
     とする相対パスで表示される。`--relative-to' も指定するなら、その
     ディレクトリは BASE の下位ディレクトリでなければならず、さもない
     と、このオプションは効果を持たない。このオプションは、ファイル
     の存在に関して `-m' や `-e' オプションを認識することに注意して
     いただきたい。例を挙げよう。

          realpath --relative-to=/usr /tmp /usr/bin
          => ../tmp
          => bin
          realpath --relative-base=/usr /tmp /usr/bin
          => /tmp
          => bin


   終了ステータス:

     0: すべてのファイル名が問題なく表示できた場合。
     1: それ以外。


File: coreutils-ja.info,  Node: Working context,  Next: User information,  Prev: File name manipulation,  Up: Top

19 作業環境
***************

この章では、現在作業中の環境を表示したり、変更したりするコマンドを説明
する。ここで環境というのは、カレントディレクトリ、端末の設定などである。
次章で取り上げるユーザ関係のコマンドも参照していただきたい。

* Menu:

* pwd invocation::           現在作業中のディレクトリを表示する。
* stty invocation::          端末の諸特性を表示・変更する。
* printenv invocation::      環境変数を表示する。
* tty invocation::           標準出力に接続している端末のファイル名を表示する。


File: coreutils-ja.info,  Node: pwd invocation,  Next: stty invocation,  Up: Working context

19.1 `pwd': 現在作業中のディレクトリを表示する
===============================================================

`pwd' は、カレントディレクトリの名前を表示する。

   書式:

     pwd [OPTION]...

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-L'
`--logical'
     環境変数 `PWD' の値が、`.' や `..' を含まないカレントディレクトリ
     の絶対パス名であっても、シンボリックリンクは含んでいるかもしれない。
     その場合でも、その値をそのまま出力する。それ以外の場合は、デフォルト
     の `-P' オプションと同じ処理を行う。

`-P'
`--physical'
     カレントディレクトリについて、参照を完全に解決した名前を表示する。
     すなわち、表示される名前のすべての要素が、本物のディレクトリの名前
     になり、シンボリックリンクは一つも含まれない。

   `-L' と `-P' のオプションが両方とも指定されている場合は、最後に
指定された方が優先される。どちらのオプションも指定されない場合は、
環境変数  `POSIXLY_CORRECT' が設定されていないかぎり、この実装では、
`-P' がデフォルトとして使用される。

   シェルの組み込み機能の `pwd' やエイリアスのために、`pwd' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `pwd' を起動すればよい (すなわち、 `env
pwd ...' のようにだ)。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: stty invocation,  Next: printenv invocation,  Prev: pwd invocation,  Up: Working context

19.2 `stty': 端末の諸特性を表示・変更する
=======================================================

`stty' は、たとえばボーレート (baud rate) のような、端末の諸特性を表示、
または変更する。

   書式:

     stty [OPTION] [SETTING]...
     stty [OPTION]

   tty ラインの設定を指定しない場合、`stty' はボーレートと (サポート
しているシステムでは) ライン制御規則番号 (line discipline number)、
それに、ライン設定のうち `stty sane' によって設定される値から変更の
あるものを表示する。デフォルトでは、モードの取得や設定は、標準入力
に結びついている tty ラインに対して行うが、これは `--file' オプション
によって変更することができる。

   `stty' では、以下で述べるように、オプションではないたくさんの
引数が使える。そうした引数は、端末ライン運用の様々な面を変更する。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--all'
     現在のすべての設定を人間に読みやすい形で表示する。このオプションを
     指定したときには、ラインの設定はできない。

`-F DEVICE'
`--file=DEVICE'
     標準入力に結びついている tty ラインを操作の対象にする代わりに、
     DEVICE で指定されたファイル名を使ってオープンするラインを操作の
     対象にする。このオプションが必要なのは、POSIX 準拠の tty を
     オープンするには、`O_NONDELAY' フラグを使う必要があるからである。
     そうしないと、POSIX 準拠の tty は、`clocal' フラグがセットされて
     いない場合に、キャリア検出線 (carrier detect line) が活発化する
     まで、ブロッキングを起こす。そんなわけで、シェルがいつもどおりの
     やり方で (訳注: たとえば、`stty < /dev/ttyS1' のような方法で)
     デバイスをオープンすることは、いつでも可能というわけではないのだ。

`-g'
`--save'
     現在の設定を別の `stty' コマンドを使って再現する際に、その引数と
     して使えるような形で、現在のすべての設定を表示する。このオプション
     を指定したときには、ラインの設定はできない。


   設定の多くは、前に `-' を付けることで OFF にすることができる。以下
では、そうした引数については、説明中に「無効化できる」と記しておいた。
説明そのものは、有効にする場合について、すなわち、`-' で OFF にしない
場合について述べている (「無効にした場合」とはっきりことわっている場合
は、もちろん別である)。

   設定の中には、すべての POSIX 準拠システムで利用できるとはかぎらない
ものもある。そうしたものは、拡張機能を使用しているからだ。以下では、
そうした引数については、説明中に「非 POSIX」と記しておいた。非 POSIX
のシステムであっても、そうした設定が使えないことがあるかもしれないが、
あらゆる場合について書いておくことは、不可能である。とりあえず、試して
みていただきたい。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

* Menu:

* Control::                  制御関係の設定
* Input::                    入力に関する設定
* Output::                   出力に関する設定
* Local::                    ローカル設定
* Combination::              組み合わせ設定
* Characters::               特殊文字
* Special::                  特殊設定


File: coreutils-ja.info,  Node: Control,  Next: Input,  Up: stty invocation

19.2.1 制御関係の設定
----------------------------

制御関係の設定:

`parenb'
     出力にパリティビットを生成し、入力にもパリティビットがあるものと
     期待する。無効化できる。

`parodd'
     パリティを奇数に設定する。無効化できる (この設定の場合、`-' の前置
     は偶数パリティを意味する)。

`cs5'
`cs6'
`cs7'
`cs8'
     キャラクタ・サイズを 5, 6, 7, 8 ビットにする。

`hup'
`hupcl'
     最後のプロセスが tty をクローズするとき、ハングアップ・シグナルを
     送る。無効化できる。

`cstopb'
     1 キャラクタにつき 2 個のストップビットを使用する。無効化できる
     (この設定の場合、`-' の前置は 1 個のストップビット使用を意味する)。

`cread'
     入力の受信を許可する。無効化できる。

`clocal'
     モデムのコントロール・シグナルを無効にする。無効化できる。

`crtscts'
     RTS/CTS フロー制御を有効にする。非 POSIX。無効化できる。


File: coreutils-ja.info,  Node: Input,  Next: Output,  Prev: Control,  Up: stty invocation

19.2.2 入力に関する設定
-------------------------------

以下の設定は、端末から受け取るデータに対する操作を制御する。

`ignbrk'
     ブレーク (break) 文字を無視する。無効化できる。

`brkint'
     ブレークが割り込みシグナルを発生するようにする。無効化できる。

`ignpar'
     パリティエラーのある文字を無視する。無効化できる。

`parmrk'
     パリティエラーをマークする (その印として 255, 0 (0xFF, 0x00) という
     2 文字の連続を使う)。無効化できる。

`inpck'
     入力のパリティチェックを有効にする。無効化できる。

`istrip'
     入力文字の高位ビット (8 番目のビット) をクリアする。無効化できる。

`inlcr'
     改行文字 (newline) を復帰文字 (carriage return) に変換する。無効化
     できる。

`igncr'
     復帰文字を無視する。無効化できる。

`icrnl'
     復帰文字を改行文字に変換する。無効化できる。

`iutf8'
     入力文字が UTF-8 で符号化されていると見なす。無効化できる。

`ixon'
     XON/XOFF フロー制御を有効にする (すなわち、`CTRL-S'/`CTRL-Q' を
     有効にする)。無効化できる。

`ixoff'
`tandem'
     システムの入力バッファが一杯になりかけたら、`stop' 文字を送り、
     バッファがほぼ空に戻ったら、`start' 文字を送るようにする。
     無効化できる。

`iuclc'
     大文字を小文字に変換する。非 POSIX。無効化できる。ilcuc は実装
     されていないことに注意していただきたい。そんなものを有効にしたら、
     ほとんどの (小文字である) Unix のコマンドが、打ち込めなくなって
     しまうからである。

`ixany'
     どんな文字でも出力を再開できるようにする (これを無効にすると、start
     文字のみが出力を再開する)。非 POSIX。無効化できる。

`imaxbel'
     入力バッファが一杯のとき、文字を受け取ると、入力バッファをフラッシュ
     せずに、ビープ音を鳴らすようにする。非 POSIX。無効化できる。


File: coreutils-ja.info,  Node: Output,  Next: Local,  Prev: Input,  Up: stty invocation

19.2.3 出力に関する設定
-------------------------------

以下の設定は、端末に送るデータに対する操作を制御する。

`opost'
     出力に対して後処理 (postprocess) を行う (訳注: すなわち、以下に列挙
     するようなことをする)。無効化できる。

`olcuc'
     小文字を大文字に変換する。非 POSIX。無効化できる。(ouclc は現在の
     ところ、実装されていないことに注意。)

`ocrnl'
     復帰文字 (carriage return) を改行文字 (newline) に変換する。 非
     POSIX。無効化できる。

`onlcr'
     改行文字を復帰文字 + 改行文字に変換する。非 POSIX。無効化できる。

`onocr'
     行頭に復帰文字を出力しない。非 POSIX。無効化できる。

`onlret'
     改行が復帰として動作する。非 POSIX。無効化できる。

`ofill'
     時間で間合いを計る代りに、充填文字 (埋め草文字) を何字か送る
     ことで、遅延を行う。非 POSIX。無効化できる。(訳注: 遅延という
     のは、端末側の処理が済むまで、データの送出を遅らせること)。

`ofdel'
     充填文字として ASCII NUL 文字ではなく、ASCII DEL 文字を使う。 非
     POSIX。無効化できる。

`nl1'
`nl0'
     改行 (newline) 用の遅延方式。非 POSIX。

`cr3'
`cr2'
`cr1'
`cr0'
     復帰 (carriage return) 用の遅延方式。非 POSIX。

`tab3'
`tab2'
`tab1'
`tab0'
     水平タブ用の遅延方式。非 POSIX。

`bs1'
`bs0'
     バックスペース用の遅延方式。非 POSIX。

`vt1'
`vt0'
     垂直タブ用の遅延方式。非 POSIX。

`ff1'
`ff0'
     改ページ (form feed) 用の遅延方式。非 POSIX。


File: coreutils-ja.info,  Node: Local,  Next: Combination,  Prev: Output,  Up: stty invocation

19.2.4 ローカル設定
-------------------------

`isig'
     特殊文字 `interrupt', `quit', `suspend' を有効にする。無効化
     できる。

`icanon'
     特殊文字 `erase', `kill', `werase', `rprnt' を有効にする。無効化
     できる。

`iexten'
     POSIX にない特殊文字を有効にする。無効化できる。

`echo'
     入力した文字をエコーする。無効化できる。

`echoe'
`crterase'
     `erase' 文字を「バックスペース、スペース、バックスペース」として
     エコーする。無効化できる。

`echok'
     `kill' 文字に続けて、改行文字をエコーする。無効化できる。

`echonl'
     他の文字のエコーを行わないない場合でも、改行文字はエコーする。
     無効化できる。

`noflsh'
     特殊文字 `interrupt' や `quit' の後で、フラッシュを行わない。無効化
     できる。

`xcase'
     `icanon' が設定されているとき、小文字を表す文字の頭に `\' を付ける
     ことで、大文字の入出力を可能にする。非 POSIX。無効化できる。
     (訳注: たとえば、大文字しか入出力できない端末で、ただの `A' なら
     小文字の a を意味し、`\A' なら大文字の A を意味するということ。
     「19.2.5 組み合わせ設定」の lcase と termios(3) を参照。)

`tostop'
     端末に書き込もうとしているバックグラウンドジョブを止める。 非
     POSIX。無効化できる。

`echoprt'
`prterase'
     削除した文字を `\' と `/' で囲んで、逆順にエコーする。非 POSIX。
     無効化できる。(訳注: プリンタ端末で使用する設定らしい。)

`echoctl'
`ctlecho'
     制御文字をそのまま表示するのではなく、ハット記法 (`^C') で
     エコーする。非 POSIX。無効化できる。

`echoke'
`crtkill'
     行上の各文字を削除することで、特殊文字 `kill' のエコーを行う際、
     `echoctl' や `echok' の設定ではなく、`echoprt' や `echoe' の設定が
     指示するところに従う。非 POSIX。無効化できる。


File: coreutils-ja.info,  Node: Combination,  Next: Characters,  Prev: Local,  Up: stty invocation

19.2.5 組み合わせ設定
----------------------------

組み合わせ設定:

`evenp'
`parity'
     `parenb -parodd cs7' に相当する。無効化できる。無効化した場合、
     `-parenb cs8' と同じになる。

`oddp'
     `parenb parodd cs7' に相当する。無効化できる。無効化した場合、
     `-parenb cs8' と同じになる。

`nl'
     `-icrnl -onlcr' に相当する。無効化できる。無効化した場合、`icrnl
     -inlcr -igncr onlcr -ocrnl -onlret' と同じになる。

`ek'
     特殊文字 `erase' と `kill' をデフォルトの値に戻す。

`sane'
     以下の設定に相当する。

          cread -ignbrk brkint -inlcr -igncr icrnl -ixoff
          -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr
          -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0
          ff0 isig icanon iexten echo echoe echok -echonl
          -noflsh -xcase -tostop -echoprt echoctl echoke

     さらに、すべての特殊文字をそのデフォルトの値に設定する。

`cooked'
     `brkint ignpar istrip icrnl ixon opost isig icanon' に相当する。
     さらに、特殊文字 `eof' と `eol' が `min' 及び `time' 文字と同じ
     ならば、`eof' と `eol' をデフォルトの値に設定する。無効化できる。
     無効化した場合は、`raw' と同じになる。

`raw'
     以下の設定に相当する。

          -ignbrk -brkint -ignpar -parmrk -inpck -istrip
          -inlcr -igncr -icrnl -ixon -ixoff -iuclc -ixany
          -imaxbel -opost -isig -icanon -xcase min 1 time 0

     無効化できる。無効化した場合は、`cooked' と同じになる。

`cbreak'
     `-icanon' と同じである。無効化できる。無効化した場合は、`icanon'
     と同じになる。

`pass8'
     `-parenb -istrip cs8' に相当する。無効化できる。無効化した場合は、
     `parenb istrip cs7' と同じになる。

`litout'
     `-parenb -istrip -opost cs8' に相当する。無効化できる。無効化した
     場合は、`parenb istrip opost cs7' と同じになる。

`decctlq'
     `-ixany' と同じである。非 POSIX。無効化できる。

`tabs'
     `tab0' と同じである。非 POSIX。無効化できる。無効化した場合は、
     `tab3' と同じになる。

`lcase'
`LCASE'
     `xcase iuclc olcuc' に相当する。非 POSIX。無効化できる。(この設定
     は、大文字しか扱えない端末で使用する。)

`crt'
     `echoe echoctl echoke' に相当する。

`dec'
     `echoe echoctl echoke -ixany intr ^C erase ^? kill ^U' に相当する。


File: coreutils-ja.info,  Node: Characters,  Next: Special,  Prev: Combination,  Up: stty invocation

19.2.6 特殊文字
-------------------

特殊文字のデフォルトの値は、システムによって様々である。特殊文字を設定
するには、`name value' という書式を用いる。この name に何が指定できる
かは、以下に列挙するが、value には、文字そのもの、ハット記法 (`^C')、
整数のいづれかを指定することができる。整数は、`0x' で始まっていれば 16
進数、`0' で始まっていれば 8 進数、それ以外の数字なら 10 進数と
見なされる。

   GNU の stty では、値に `^-' や `undef' を指定すると、その特殊文字を
無効にする。(これは、Ultrix の `stty' と互換性がない。そこでは、特殊
文字を無効にするには `u' という値が使用されるのだ。GNU の `stty' は、
`u' という値を特別扱いしない。すなわち、その特殊文字として <U> を設定
するだけである。)

`intr'
     割り込み (interrupt) シグナルを送る。

`quit'
     終了 (quit) シグナルを送る。

`erase'
     直前にタイプした文字を削除する。

`kill'
     現在行を削除する。

`eof'
     ファイル終端 (end of file) 文字を送る (入力を終了する)。

`eol'
     行を終端する。

`eol2'
     行を終端する別の文字。非 POSIX。

`swtch'
     シェルの別の層 (a different shell layer) に切り換える。非 POSIX。

`start'
     停止している出力を再開する。

`stop'
     出力を停止する。

`susp'
     端末停止シグナル (terminal stop signal) を送る。

`dsusp'
     入力をフラッシュしてから、端末停止シグナルを送る。非 POSIX。

`rprnt'
     現在行を表示し直す。非 POSIX。

`werase'
     直前にタイプした単語 (word) を削除する。非 POSIX。

`lnext'
     次にタイプする文字が特殊文字であっても、タイプしたとおりの文字として
     入力する。非 POSIX。(訳注: たとえば、lnext が ^V の場合、^V^D と
     続けてタイプすると、^D を入力終了の印としてではなく、^D という文字
     そのものとして入力できるということ。)


File: coreutils-ja.info,  Node: Special,  Prev: Characters,  Up: stty invocation

19.2.7 特殊設定
-------------------

`min N'
     `-icanon' が設定されている際、time の値として指定されている時間が
     経過するまでの間に、1 回分の読み込みの条件を満たす最少限の文字数を
     設定する。

`time N'
     `-icanon' が設定されている際、最小限の文字数が読み込まれなかった
     場合に、読み込みが時間切れになるまでの時間を 10 分の 1 秒単位で
     設定する。

`ispeed N'
     入力速度を N に設定する。

`ospeed N'
     出力速度を N に設定する。

`rows N'
     端末の行数は N 行だと、tty カーネルドライバに伝える。非 POSIX。

`cols N'
`columns N'
     端末の横幅は N 桁だと、カーネルに伝える。非 POSIX。

`size'
     端末の行数と桁数を表示する。これは、端末が持っていると、カーネルが
     考えている行数と桁数である。(カーネル中に行数や桁数を保持しない
     システムでは、通常その代わりに、環境変数 `LINES' や `COLUMNS' を
     使用する。それに対して、GNU の `stty' は、そうした環境変数に全く
     関知しない。) 非 POSIX。

`line N'
     ライン制御規則 (line discipline) N を使用する。非 POSIX。

`speed'
     端末速度を表示する。

`N'
     入出力の速度を N に設定する。N には次の一つが使える。0 50 75 110
     134 134.5 150 200 300 600 1200 1800 2400 4800 9600 19200 38400
     `exta' `extb'。`exta' は 19200 と同じであり、`extb' は 38400 と
     同じである。GNU/Linux を含む多くのシステムが、もっと早い速度を
     サポートしている。`stty' は、システムがサポートしているならという
     条件で、次の速度もサポートしている。57600 115200 230400 460800
     500000 576000 921600 1000000 1152000 1500000 2000000 2500000
     3000000 3500000 4000000。なお、0 は、`-clocal' が設定されている場合
     に、ラインを切断する。


File: coreutils-ja.info,  Node: printenv invocation,  Next: tty invocation,  Prev: stty invocation,  Up: Working context

19.3 `printenv': 環境変数のすべて、あるいは一部を表示する
=============================================================================

`printenv' は、環境変数の値を表示する。

   書式:

     printenv [OPTION] [VARIABLE]...

   VARIABLE が一つも指定されていない場合、`printenv' はすべての環境変数
の値を表示する。VARIABLE が指定されている場合は、その変数それぞれに
ついて、設定されていれば値を表示し、設定されていなければ何も表示しない。

   このプログラムでは、以下のオプションが使える。参照: *note Common
options::.

`-0'
`--null'
     各行の末尾に改行ではなく、ゼロバイト (ASCII NUL) を出力する。この
     オプションを使用すると、`printenv' の出力するデータに、途中に改行を
     挟むものがあっても、他のプログラムがその出力を解析できるようになる。


   終了ステータス:

     0: 指定されているすべての変数が見つかった。
     1: 指定されている変数のうちに、見つからなかったものがある。
     2: 書き込みエラーが生じた。


File: coreutils-ja.info,  Node: tty invocation,  Prev: printenv invocation,  Up: Working context

19.4 `tty': 標準出力に接続している端末のファイル名を表示する
====================================================================================

`tty' は、自分の標準入力に接続している端末のファイル名を表示する。
標準入力が端末ではない場合は、`not a tty' というメッセージを出す。

   書式:

     tty [OPTION]...

   このプログラムでは、以下のオプションが使える。参照: *note Common
options::.

`-s'
`--silent'
`--quiet'
     何も表示しない。終了ステータスを返すだけ。


   終了ステータス:

     0: 標準入力が端末である。
     1: 標準入力が端末ではない。
     2: 指定した引数が正しくない。
     3: 書き込みエラーが生じた。


File: coreutils-ja.info,  Node: User information,  Next: System context,  Prev: Working context,  Up: Top

20 ユーザ情報
******************

この章では、ユーザ関係の情報を表示するコマンドの説明をする。誰がログイン
しているか、どんなグループに所属しているか、などである。

* Menu:

* id invocation::        ユーザの ID を表示する。
* logname invocation::   現在のログイン名を表示する。
* whoami invocation::    実効ユーザ ID を表示する。
* groups invocation::    ユーザが所属しているグループ名を表示する。
* users invocation::     現在ログインしている全ユーザのログイン名を表示する。
* who invocation::       現在誰がログインしているかを表示する。


File: coreutils-ja.info,  Node: id invocation,  Next: logname invocation,  Up: User information

20.1 `id': ユーザの ID を表示する
==========================================

`id' は、指定されたユーザについて情報を表示する。ユーザが指定されて
いない場合は、`id' を実行しているプロセスについて情報を表示する。

   書式:

     id [OPTION]... [USERNAME]

   デフォルトで表示するのは、実ユーザ ID、実グループ ID、実効ユーザ ID
(実ユーザ ID と違う場合)、実効グループ ID (実グループID と違う場合)、
それに、補助 (supplemental) グループ ID である。さらに、SELinux が
有効になっていて、環境変数 `POSIXLY_CORRECT' が設定されていない場合は、
`context=C' も表示する。この C はセキュリティ・コンテキストである。

   表示される各数値には、それが何であるかを示す文字列が前に付き、対応
するユーザ名やグループ名がカッコで囲まれて後ろに続く。

   オプションを指定すると、`id' は上で述べた情報のうち、一部のみを表示
する。参照: *note Common options::.

`-g'
`--group'
     グループ ID のみ表示する。

`-G'
`--groups'
     グループ ID と補助グループ ID のみ表示する。

`-n'
`--name'
     ID 番号の代りに、ユーザ名やグループ名を表示する。`-u', `-g', `-G'
     の一つを指定する必要がある。

`-r'
`--real'
     実効ユーザや実効グループの ID ではなく、実ユーザや実グループの ID
     を表示する。`-u', `-g', `-G' のどれか一つを指定する必要がある。

`-u'
`--user'
     ユーザ ID のみ表示する。

`-Z'
`--context'
     実行中のユーザのセキュリティ・コンテキストのみを表示する。SELinux
     が無効になっている場合は、警告メッセージを出し、終了ステータスを 1
     にする。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

   プロセスの基本 (primary) グループや 補助 (supplementary) グループは、
通常その親プロセスから継承され、普通はログイン後ずっと変わらないものだ。
従って、ログイン後にグループ・データベースを変更しても、現在のログイン
セッションが続いている間は、`id' コマンドはその変更を反映しない。
しかし、引数にユーザの名前を指定して `id' を実行した場合は、ユーザ・
データベースやグループ・データベースの参照が、改めて行われるので、
変更した結果が表示されることになる。


File: coreutils-ja.info,  Node: logname invocation,  Next: whoami invocation,  Prev: id invocation,  Up: User information

20.2 `logname': 現在のログイン名を表示する
=======================================================

`logname' は、自分を呼び出したユーザの名前を、システムが管理して
いるファイル (たいていは `/var/run/utmp' か `/etc/utmp') で調べて
表示し、ステータス 0 で終了する。自分を呼び出したプロセスに対する
エントリが存在しない場合は、`logname' はエラーメッセージを出し、
ステータス 1 で終了する。

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: whoami invocation,  Next: groups invocation,  Prev: logname invocation,  Up: User information

20.3 `whoami': 実効ユーザ ID を表示する
=================================================

`whoami' は、現在の実効ユーザ ID に対応するユーザ名を表示する。 `id
-un' コマンドと同じことである。

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: groups invocation,  Next: users invocation,  Prev: whoami invocation,  Up: User information

20.4 `groups': ユーザが所属しているグループ名を表示する
===========================================================================

`groups' は、USERNAME が指定されていれば、指定された各ユーザの基本
(primary) グループ名と補助 (supplementary) グループ名を表示し、
ユーザ名が指定されていなければ、現在のプロセスの基本グループ名と
補助グループ名を表示する。複数の名前が指定されている場合は、
各ユーザの名前がグループのリストの前に置かれ、両者の間はコロンで
区切られる。

   書式:

     groups [USERNAME]...

   グループのリストは、`id -Gn' コマンドの出力と同じである。

   プロセスの基本 (primary) グループや 補助 (supplementary) グループは、
通常その親プロセスから継承され、普通はログイン後ずっと変わらないものだ。
従って、ログイン後にグループ・データベースを変更しても、現在のログイン
セッションが続いている間は、`groups' コマンドはその変更を反映しない。
しかし、ユーザのリストを指定して `groups' を実行した場合は、ユーザ・
データベースやグループ・データベースの参照が、改めて行われるので、
変更した結果が表示されることになる。

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: users invocation,  Next: who invocation,  Prev: groups invocation,  Up: User information

20.5 `users': 現在ログインしている全ユーザのログイン名を表示する
=========================================================================================

`users' は、目下使用しているホストに現在ログインしている全ユーザの
ユーザ名のリストを、空白で区切って 1 行に表示する。ユーザ名はログイン
セッションごとに表示されるので、あるユーザが複数のログインセッションを
行っていれば、そのユーザの名前はログインセッションの数だけ出力に現れる
ことになる。

   書式:

     users [FILE]

   引数 FILE の指定がない場合、`users' はシステムが管理するファイル
(たいていは `/var/run/utmp' か `/etc/utmp') からログインしているユーザの
情報を引き出す。引数 FILE が指定されている場合は、代りにそのファイルを
使用する。`/var/log/wtmp' が使われることが多い。

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: who invocation,  Prev: users invocation,  Up: User information

20.6 `who': 現在誰がログインしているかを表示する
==================================================================

`who' は、現在ログインしているユーザについての情報を表示する。

   書式:

     `who' [OPTION] [FILE] [am i]

   オプション以外の引数が一つもない場合、`who' は現在ログインしている
各ユーザについて、次の情報を表示する。ログイン名、端末ライン、ログイン
日時、それにリモート・ホスト名か X ディスプレー名。

   オプション以外の引数を一つだけ指定すると、`who' はそれを、ログイン
したユーザを記録しているファイルの名前として、システムが管理している
デフォルトのファイル (たいていは `/var/run/utmp' か `/etc/utmp') の
代りに使用する。`who' に引数として `/var/log/wtmp' を渡して、これまでに
誰がログインしたかを調べるのはよくあることである。

   オプション以外の引数を二つ指定すると、`who' は、自分を実行している
ユーザのエントリのみを (自分が接続している標準入力からユーザの見当を
付けて)、ホスト名を前に付けて表示する。渡される二つの引数は、全体
として `who am i' になるように、`am i' とするのが慣例である。

   タイムスタンプは、タイムゾーンのルールに従って表示されるが、その
ルールを指定しているのは、環境変数 `TZ' である。`TZ' が設定されて
いない場合は、システムのデフォルトのルールに従って表示される。 *Note
Specifying the Time Zone with `TZ': (libc)TZ Variable.

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--all'
     `-b -d --login -p -r -t -T -u' と同じである。

`-b'
`--boot'
     システムをブートした直近の日時を表示する。

`-d'
`--dead'
     終了したプロセスに関する情報を表示する。

`-H'
`--heading'
     最初の行に各列の見出しを表示する。

`-l'
`--login'
     システムがユーザのログインを待ち受ける窓口になっているプロセスに
     関する情報のみを表示する。ユーザ名は常に `LOGIN' である。

`--lookup'
     utmp で見つかったホスト名について DNS を検索して正式名を取得しよう
     とする。これがデフォルトになっていないのは、インターネットに自動
     ダイアルアップで接続しているシステムでは、深刻な遅滞を招きかねない
     からである。

`-m'
     `who am i' と同じである。

`-p'
`--process'
     init によって生み出されたプロセスのうち、現在活動中のものをリスト
     する。

`-q'
`--count'
     ログインしているユーザのログイン名と人数のみを表示する。他のすべての
     オプションを無効にする。

`-r'
`--runlevel'
     init プロセスの現在のランレベルを表示する (たぶん、直前のラン
     レベルも)。

`-s'
     無視する。他の版の `who' との互換性のためにある。

`-t'
`--time'
     システムクロックを最後に変更した日時を表示する。

`-u'
     ログイン日時の後ろに、ユーザが何時間何分アイドル状態でいるかを
     表示する。`.' は、ユーザがここ 1 分間アクティブだったことを意味
     する。`old' は、ユーザが 24 時間以上アイドル状態だいうことである。

`-w'
`-T'
`--mesg'
`--message'
`--writable'
     ログイン名の後ろに、ユーザのメッセージ受け入れ状態を示す 1 文字を
     表示する。

          `+' `write' によるメッセージを受け入れる。
          `-' `write' によるメッセージを拒否する。
          `?' 端末デバイスが見つからない。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: System context,  Next: SELinux context,  Prev: User information,  Up: Top

21 システム情報
*********************

この章では、システム全体に関わる情報を表示したり、変更したりするコマンドを
説明する。

* Menu:

* date invocation::          システムの日付や時刻を表示、設定する。
* arch invocation::          マシンのハードウェア名を表示する。
* nproc invocation::         プロセッサの数を表示する。
* uname invocation::         システムについて情報を表示する。
* hostname invocation::      システム名を表示、設定する。
* hostid invocation::        数値によるホストの識別名を表示する。
* uptime invocation::        システムの連続稼働時間と負荷を表示する。


File: coreutils-ja.info,  Node: date invocation,  Next: arch invocation,  Up: System context

21.1 `date': システムの日付や時刻を表示、設定する
===================================================================

書式:

     date [OPTION]... [+FORMAT]
     date [-u|--utc|--universal] [ MMDDhhmm[[CC]YY][.ss] ]

   `date' を FORMAT 引数なしで起動すると、デフォルトの書式を指定して
起動するのと同じことになる。デフォルトの書式は、`LC_TIME' ロケール・
カテゴリによって様々である。デフォルトの C ロケールの場合、その書式は
`'+%a %b %e %H:%M:%S %Z %Y'' なので、出力は `Thu Mar  3 13:47:51 PST
2005' のような形になる。

   通常 `date' は、環境変数 `TZ' が指示しているタイムゾーンのルールを
使用し、`TZ' が設定されていないときは、システムのデフォルトのルールを
使用する。*Note Specifying the Time Zone with `TZ': (libc)TZ Variable.

   `+' で始まる引数を指定すると、`date' は現在の日付と時刻を (あるいは、
後述する `--date' オプションで指定した日付と時刻を)、その引数によって
定義された書式で表示する。書式を指定するこの引数は、`strftime' 関数の
それとほぼ同じである。なお、`%' で始まる変換指定子を除いて、書式文字列
中の文字は、変更されずにそのまま表示される。変換指定子については、次節
以降で説明する。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。

* Menu:

* Time conversion specifiers:: 時刻関係の変換指定子 %[HIklMNpPrRsSTXzZ]。
* Date conversion specifiers:: 日付関係の変換指定子 %[aAbBcCdDeFgGhjmuUVwWxyY]。
* Literal conversion specifiers::  文字変換指定子 %[%nt]。
* Padding and other flags::  0 や空白による空き埋め、その他。
* Setting the time::         システムクロックの変更。
* Options for date::         現在の日時以外の指定。
* Date input formats::       日付文字列の指定法。
* Examples of date::         用例。


File: coreutils-ja.info,  Node: Time conversion specifiers,  Next: Date conversion specifiers,  Up: date invocation

21.1.1 時刻関係の変換指定子
-------------------------------------

`date' の時刻関係の変換指定子

`%H'
     時 (`00'...`23')

`%I'
     時 (`01'...`12')

`%k'
     時。一桁のときは、0 ではなく、空白で埋める (` 0'...`23')。`%_H' と
     同じ。これは GNU の拡張である。

`%l'
     時。一桁のときは、0 ではなく、空白で埋める (` 1'...`12')。`%_I' と
     同じ。これは GNU の拡張である。

`%M'
     分 (`00'...`59')

`%N'
     ナノ秒 (`000000000'...`999999999')。これは GNU の拡張である。

`%p'
     現在のロケールで `AM' や `PM' に相当するもの。なしで済ますロケール
     も多い。正午は `PM' として、真夜中は `AM' として扱う。

`%P'
     `%p' と同様だが、小文字を使う。これは GNU の拡張である。

`%r'
     現在のロケールによる 12 時間表記の時刻 (例: `11:11:04 PM')

`%R'
     24 時間表記の時と分。`%H:%M' と同じ。

`%s'
     エポック (Unix 紀元)、すなわち 1970-01-01 00:00:00 UTC からの経過
     秒数。閏秒のサポートを利用できない場合、閏秒は計算に入れない。
     用例については、「`date' の用例」を見ること。*Note %s-examples::.
     これは GNU の拡張である。

`%S'
     秒 (`00'...`60')。閏秒がサポートされている場合、`60' になることが
     ある。

`%T'
     24 時間表記の時、分、秒。`%H:%M:%S' と同じ。

`%X'
     現在のロケールによる時刻表示 (例: `23:13:48')

`%z'
     RFC 2822/ISO 8601 形式の数値によるタイムゾーン (たとえば、`-0600'
     や `+0530')。タイムゾーンが特定できない場合は、空になる。この値は、
     環境変数 `TZ' によって指定されたタイムゾーンのルールを使用する
     ことで、現在の日時に対応した、数値によるタイムゾーンを正しく反映
     している (訳注: 要するに、夏時間、冬時間が存在する地帯では、それを
     反映するということ)。操作の対象となる日時は (もしそうしたければ、
     その日時におけるタイムゾーンのルールも)、`--date' オプションに
     よって変更することができる。

`%:z'
     RFC 3339/ISO 8601 形式の、`:' を使用する数値によるタイムゾーン
     (たとえば、`-06:00' や `+05:30')。タイムゾーンが特定できない
     場合は、空になる。これは GNU による拡張である。

`%::z'
     `:' を使用する数値によるタイムゾーンで、もっとも近い秒まで表示する
     (たとえば、`-06:00:00' や `+05:30:00')。タイムゾーンが特定できない
     場合は、空になる。これは GNU による拡張である。

`%:::z'
     `:' を使用する数値によるタイムゾーンで、時間の精度は必要最小限で
     済ます (たとえば、`-06', `+05:30', `-04:56:02')。タイムゾーンが
     特定できない場合は、空になる。これは GNU による拡張である。

`%Z'
     アルファベットによるタイムゾーンの略称 (たとえば、`EDT')。タイム
     ゾーンが特定できない場合は、空になる。タイムゾーンがどのようにして
     特定されるか (訳注: たとえば、アメリカ東部なら、EST (冬時間) と EDT
     (夏時間) のどちらが選ばれるか) については、`%z' を参照すること。


File: coreutils-ja.info,  Node: Date conversion specifiers,  Next: Literal conversion specifiers,  Prev: Time conversion specifiers,  Up: date invocation

21.1.2 日付関係の変換指定子
-------------------------------------

`date' の日付関係の変換指定子。

`%a'
     現在のロケールによる曜日の省略形 (例: `Sun')

`%A'
     現在のロケールによる曜日の省略しない表現。長さは不定 (例: `Sunday')

`%b'
     現在のロケールによる月名の省略形 (例: `Jan')

`%B'
     現在のロケールによる月名の省略しない表現。長さは不定 (例:
     `January')

`%c'
     現在のロケールによる日付と時刻 (例: `Thu Mar  3 23:05:25 2005')

`%C'
     世紀。`%Y' に似ているが、下二桁を省略している。たとえば、`%Y' が
     `2000' ならば、`%C' は `20'、`%Y' が `-001' ならば、`%C' は `-0'
     である。通例、少なくとも 2 個の文字からなるが、2 個以上のことも
     ありえる。

`%d'
     その月の何日目か (e.g., `01')

`%D'
     日付。`%m/%d/%y' と同じ

`%e'
     その月の何日目か。一桁のときは、0 ではなく、空白で埋める。`%_d'
     と同じ。

`%F'
     ISO 8601 形式の完全な日付。`%Y-%m-%d' と同じ。日付の形式にこれを
     選ぶのは、好判断である。標準的な形式だし、年度が 0000...9999 の
     範囲にある通常の場合に、ソートしやすい。

`%g'
     ISO 週番号に対応する年度表示だが、世紀の部分を省略している (その
     結果、`00' から `99' の範囲になる)。これは普通 `%y' と同じ形式、
     同じ値になるが、ISO 週番号 (`%V' 参照) が前年、または翌年に
     属する場合は、そちらの年度が代りに使用される点が異なる。

`%G'
     ISO 週番号に対応する年度表示。これは普通 `%Y' と同じ形式、同じ値
     になるが、ISO 週番号 (`%V' 参照) が前年、または翌年に属する場合は、
     そちらの年度が代りに使用される点が異なる。通常、これが役に立つのは、
     `%V' も一緒に使用するときだけである。たとえば、`%G-%m-%d' という
     書式は、ISO 週番号による年度と普段使用する月や日を組み合わせている
     ので、たぶん指定の仕方を間違えている。

`%h'
     `%b' と同じ。

`%j'
     その年の何日目か (`001'...`366')

`%m'
     月 (`01'...`12')

`%u'
     その週の何日目か (`1'...`7')。`1' は月曜日に当たる。

`%U'
     日曜日を週の最初の日とする、その年の週番号 (`00'...`53')。新しい
     年の最初の日曜日より前の日々は、第 0 週に属する。

`%V'
     ISO 週番号。すなわち、月曜日を週の最初の日とする、その年の週番号
     (`01'...`53')。1 月 1 日を含む週が、新しい年の日々を 4 日以上含む
     場合は、その週が第 1 週であると見なされる。そうでない場合は、
     その週は前年の第 53 週であり、翌週が第 1 週になる。(ISO 8601 の
     規格を参照。)

`%w'
     その週の何日目か (`0'...`6')。0 は日曜日に当たる。

`%W'
     月曜日を週の最初の日とする、その年の週番号 (`00'...`53')。最初の
     月曜日より前の新しい年の日々は、第 0 週に属する。

`%x'
     現在のロケールによる日付の表示 (例: `12/31/99')

`%y'
     年度の下二桁 (`00'...`99')

`%Y'
     年度。通例、少なくとも 4 文字だが、もっと多いこともある。`0000'
     年は `0001' の前年であり、`-001' 年は `0000' の前年である。


File: coreutils-ja.info,  Node: Literal conversion specifiers,  Next: Padding and other flags,  Prev: Date conversion specifiers,  Up: date invocation

21.1.3 文字変換指定子
----------------------------

日付や時刻以外の `date' の変換指定子。

`%%'
     1 個の % という文字

`%n'
     改行

`%t'
     水平タブ


File: coreutils-ja.info,  Node: Padding and other flags,  Next: Setting the time,  Prev: Literal conversion specifiers,  Up: date invocation

21.1.4 空き埋めなどのフラグ
-------------------------------------

特に指定がないかぎり、`date' は通常、数値の入るフィールドの空きを 0
で埋める。従って、たとえば、数値による月名は常に二桁の数字として
出力される。しかし、エポック (Unix 紀元) 以来の経過秒数では、空きを
埋めることはしない。この秒数には決まった長さがないからである。

   GNU の拡張として、以下に挙げるフラグの一つを `%' の後ろに置くことが
できる (指定するしないは自由)。

`-'
     (ハイフン) フィールドの空き埋めをしない。出力が人間に見せるための
     ものである場合に、役に立つ。

`_'
     (アンダースコア、下線) 空白で空き埋めをする。出力を一定の文字数に
     する必要があるが、0 で埋めたのでは見にくいという場合に、役に立つ。

`0'
     (ゼロ) 変換指定子が普通なら空白で埋める場合にも、ゼロで空き埋めを
     する。

`^'
     可能なら、大文字を使う。

`#'
     可能なら、反対の文字を使う。通常大文字のフィールドは小文字になり、
     小文字のフィールドは大文字になる。

空き埋めの例をいくつか挙げておく。

     date +%d/%m -d "Feb 1"
     => 01/02
     date +%-d/%-m -d "Feb 1"
     => 1/2
     date +%_d/%_m -d "Feb 1"
     =>  1/ 2

   これも GNU の拡張だが、フィールドの幅を 10 進数で指定することができ
る (数字は、上記のフラグがあれば、その後ろに置く)。加工する前のその
フィールドの出力の長さが、指定した文字数より短い場合は、右詰めにして、
指定サイズにまで空き埋めした結果が書き出される。たとえば、`%9B' は、
右詰めにした月の名前を 9 文字分のフィールドに表示する。

   上記のフラグやフィールド幅の指定の後ろに、修飾子 (modifier) を付ける
こともできる (指定するしないは自由)。修飾子には、次のものがある。

`E'
     現在のロケールが持つもう一つの日時表記を使用する。この修飾子は、
     `%c', `%C', `%x', `%X', `%y', `%Y' に対して使用できる。たとえば、
     日本語ロケールで `%Ex' とすれば、元号による日付を表示するだろう。

`O'
     現在のロケールが持つもう一つの数字表記を使用する。この修飾子は、
     数値を表す変換指定子にしか使用できない。

   書式が修飾子をサポートしていても、もう一つの表記が利用できない場合、
修飾子は無視される。


File: coreutils-ja.info,  Node: Setting the time,  Next: Options for date,  Prev: Padding and other flags,  Up: date invocation

21.1.5 システムクロックの設定
----------------------------------------

`+' で始まらない引数を指定すると、`date' は、(以下で述べるように) その
引数で指定した日時にシステムクロックを設定する。システムクロックを設定
するには、しかるべき権限が必要である。リブート後も変更を維持するには、
システムクロックに合わせてハードウェアクロックも更新する必要があるかも
しれないことに注意していただきたい。ご使用のシステムでは、ハードウェア
クロックの更新は、自動的に行われないかもしれないからだ。

   引き数の構成要素は、すべて数字でなければならない。それは以下の意味を
持っている。

   (訳注: 念のため、この章の冒頭にあるシステムクロック設定用の書式を
再掲しておく。date [-u|-utc|-universal] [ MMDDhhmm[[CC]YY][.ss] ])

`MM'
     何月

`DD'
     (何月の) 何日

`hh'
     何時

`mm'
     何分

`CC'
     年度の上二桁 (省略可)

`YY'
     年度の下二桁 (省略可)

`ss'
     何秒 (省略可)

   注意していただきたいが、`--date' や `--set' オプションは、ここで
述べている書式の引数と組み合わせて使うことができない。`--universal'
オプションは、ここで述べている書式の引数と一緒に使うことができるが、
その場合、指定されている日時が現在地のタイムゾーンではなく、協定世界時
(UTC) に準じているのを示すことになる。


File: coreutils-ja.info,  Node: Options for date,  Prev: Setting the time,  Up: date invocation

21.1.6 `date' のオプション
--------------------------------

このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-d DATESTR'
`--date=DATESTR'
     現在の日時の代りに、日付文字列 DATESTR で指定した日時を表示する。
     DATESTR には、よく使われる書式なら、ほとんどどんな書式でも使う
     ことができる。月の名前、タイムゾーン、`am' や `pm'、`yesterday'
     といった単語、などを含んでいてもよい。たとえば、`--date="2004-02-27
     14:19:13.489392193 +0530"' は、UTC よりも東 5 時間 30 分のタイム
     ゾーンで 2004 年 2 月 27 日 午後 2 時 19 分 13 秒から 489,392,193
     ナノ秒経過した瞬間を指定している。
     注意: 現在のところ、入力は、ロケールに依存しない書式でなければ
     ならない。たとえば、以下の例の LC_TIME=C は、多くのロケールで正しい
     日時を再表示させるために必要である。
          date -d "$(LC_TIME=C date)"
     参照: *Note Date input formats::.

`-f DATEFILE'
`--file=DATEFILE'
     DATEFILE の各行を `-d' の場合と同じように解析して、生成された日付
     と時刻を表示する。DATEFILE が `-' ならば、標準入力を使用する。処理
     する日付がたくさんある場合に、このオプションは重宝である。何故ならば、
     `date' コマンドを何度も起動するときのシステムのオーバーヘッドは、
     馬鹿にならないことがあるからだ。

`-I[TIMESPEC]'
`--iso-8601[=TIMESPEC]'
     ISO 8601 の書式、`%Y-%m-%d' を使って、日付を表示する。

     引数 TIMESPEC では、日付の後ろに時刻をどの単位まで追加するかを
     指定する。以下の一つを指定することができる。
    `date'
          日付のみを表示する。TIMESPEC を省略した場合のデフォルト。

    `hours'
          日付にその日の何時かを追加する。

    `minutes'
          何時何分まで追加する。

    `seconds'
          何時何分何秒まで追加する。

    `ns'
          何時何分何秒何ナノ秒まで追加する。

     時刻の部分まで表示するときは、`%z' の書式でタイムゾーンも付ける。

`-r FILE'
`--reference=FILE'
     現在の日付と時刻の代りに、FILE の内容を最後に更新した (the last
     modification) 日付と時刻を表示する。

`-R'
`--rfc-822'
`--rfc-2822'
     日付と時刻を `%a, %d %b %Y %H:%M:%S %z' という書式を使用し、C
     ロケールで評価して表示する。従って、月や曜日の省略形は常に英語に
     なる。一例を挙げると、こんな表示である。

          Fri, 09 Sep 2005 13:51:39 -0700

     この書式は、Internet RFC 2822
     (ftp://ftp.rfc-editor.org/in-notes/rfc2822.txt) と RFC 822
     (ftp://ftp.rfc-editor.org/in-notes/rfc822.txt) に従っている。
     インターネットの E メールに関する現在と以前の規格である。

`--rfc-3339=TIMESPEC'
     Internet RFC 3339 (ftp://ftp.rfc-editor.org/in-notes/rfc3339.txt)
     が規定している書式を使用して、日付を表示する。この書式は、ISO 8601
     の書式のサブセットだが、日付と時刻を区切るのに、`T' という文字では
     なく、空白を使うことをアプリケーションに許している、という相違点も
     ある。他の標準の書式とは違って、RFC 3339 の書式は、現在のロケール
     が何であろうとも、`--date' (`-d') や `--file' (`-f') オプションに
     対する入力として常に適切である。

     引数 TIMESPEC では、時刻をどこまで表示するかを指定する。以下の一つ
     を指定することができる。

    `date'
          年から始まる日付だけを表示する。たとえば、`2005-09-14'。これは、
          `%Y-%m-%d' という書式と等価ある。

    `seconds'
          年から始まる日付と秒までの時刻を表示し、両者の間は空白で区切る。
          一例を挙げると、`2005-09-14 00:56:06+05:30'。出力の末尾には、
          協定世界時からの時差が付く。例の場合、`+05:30' は、地方時が
          UTC より 5 時間 30 分進んでいることを意味している。これは、
          `%Y-%m-%d %H:%M:%S%:z' という書式と等価である。

    `ns'
          `seconds' と似ているが、ナノ秒まで表示する。一例を挙げると、
          `2005-09-14 00:56:06.998458565+05:30'。これは、`%Y-%m-%d
          %H:%M:%S.%N%:z' という書式と等価である。


`-s DATESTR'
`--set=DATESTR'
     日付と時刻を DATESTR に設定する。上記の `-d' を参照。 前節「21.1.5
     日時の設定」 も参照すること。*note Setting the time::.

`-u'
`--utc'
`--universal'
     環境変数 `TZ' が、文字列 `UTC0' に設定されているかのように、処理に
     協定世界時 (UTC, Coordinated Universal Time) を使用する。協定世界時
     は、歴史的な理由から「グリニッジ標準時 (GMT)」と呼ばれることもよく
     ある。一般にシステムは閏秒を無視するので、日時は正真の UTC では
     なく、UTC の近似値になる。


File: coreutils-ja.info,  Node: Examples of date,  Up: date invocation

21.1.7 `date' の使用例
--------------------------

用例をいくつか挙げてみる。前節の `-d' の説明も参照していただきたい。

   * 一昨日の日付を表示する。

          date --date='2 days ago'

   * 今から 3 ヶ月と 1 日後の日付けを表示する。

          date --date='3 months 1 day'

   * 今年のクリスマスは年の初めから何日目かを表示する。

          date --date='25 Dec' +%j

   * 今日が何月何日かを、省略しない月の名前で表示する。

          date '+%B %d'

     しかし、月の最初の 9 日間では、`%d' は空きを 0 で埋めた 2 桁の
     フィールドに展開されるので、この結果はご希望のものとは違うかも
     しれない。たとえば、`date -d 1may '+%B %d'' の出力は、`May 01' に
     なるのだ。

   * 月のうちの 1 桁の日々に対して、先頭に 0 を付けずに日付を表示したい
     のなら、(GNU の拡張である) `-' フラグを使用すれば、空き埋めを全く
     しないようにすることができる。

          date -d 1may '+%B %-d

   * 現在の日付と時刻を、non-GNU 版の `date' の多くがシステムクロックを
     設定するときに要求する書式で表示する。

          date +%m%d%H%M%Y.%S

   * システムクロックを 2 分進める。

          date --set='+2 minutes'

   * 日付を RFC 2822 の書式で表示するためには、`date --rfc-2822' を使用
     する。ここに示すのは、出力の一例である。

          Fri, 09 Sep 2005 13:51:39 -0700

   * 日付を表す文字列をエポック (Unix 紀元、すなわち 1970-01-01 00:00:00
     UTC) からの経過秒数に変換するには、`--date' オプションを `%s' 書式
     と組み合わせて使用する。これは、データを日付によってソートしたり、
     グラフ化したり、比較したりする際に、便利である。次のコマンドは、
     エポックから 2 分経ったときの、エポックからの経過秒数を出力する。

          date --date='1970-01-01 00:02:00 +0000' +%s
          120

     日付を表す文字列でタイムゾーン情報を指定しない場合、`date' は、
     コンピュータが認識しているタイムゾーンを使用して、その文字列を
     解釈する。たとえば、使用しているコンピュータのタイムゾーンが、
     マサチューセッツ州のケンブリッジのものならば、それは UTC より 5
     時間遅れているので、次のようになる。

          # 現在地のタイムゾーンを使用
          date --date='1970-01-01 00:02:00' +%s
          18120

   * 日付の付いたデータをソートしたり、グラフ化したりしているとしよう。
     その日付の加工前の値は、エポックからの経過秒数で表されているかも
     しれない。しかし、`946684800' といった日付を見て、「ああ、イギリス
     のグリニッジの 2000 年の最初の 0 秒だね」と、さりげなく言える人は、
     めったにいない。

          date --date='2000-01-01 UTC' +%s
          946684800

     なお、上と同じ結果は、`--utc' (`-u') オプションを使っても得られ、
     その場合は、日付を表す文字列で `UTC' を省略できる。もっとも、
     `--utc'を使う方法は、`%s' など多くの書式文字列では、日付文字列で
     `UTC' を使うのと同じ結果をもたらすものの、協定世界時からの時差が 0
     ではないタイムゾーンで `%z' などのタイムゾーンに依存する書式文字列
     を指定した場合は、違う結果を出力することになるだろう。

          date -u --date=2000-01-01 +%s
          946684800

     こうした秒数という扱いにくいデータをもっと読みやすい形に変換し直す
     には、次のようなコマンドを使う。

          # 現在地のタイムゾーンを使用
          date -d '1970-01-01 UTC 946684800 seconds' +"%Y-%m-%d %T %z"
          1999-12-31 19:00:00 -0500

     coreutils 5.3.0 以来使用できるようになった `@' という表記に頼っても
     構わないなら、上記のコマンドを短くすることができる。

          date -d @946684800 +"%F %T %z"
          1999-12-31 19:00:00 -0500

     UTC の日付や時刻を出力した方がよいことも多い。

          date -u -d '1970-01-01 946684800 seconds' +"%Y-%m-%d %T %z"
          2000-01-01 00:00:00 +0000

   * 閏秒は秒数計算に入れないのが一般的だが、例外的なシステムもある。
     閏秒は予測できないものなので、閏秒を計算に入れる例外的なシステム
     では、秒数による計算と未来の日時との対応は信頼性に欠ける。

     一般的なシステムと例外的なシステムの両者が、2012-06-30 23:59:60 UTC
     の閏秒をどのように処理しているかを以下に示す。

          # 一般的なシステムは閏秒を無視する:
          date --date='2012-06-30 23:59:59 +0000' +%s
          1341100799
          date --date='2012-06-30 23:59:60 +0000' +%s
          date: invalid date '2012-06-30 23:59:60 +0000'
          date --date='2012-07-01 00:00:00 +0000' +%s
          1341100800

          # 例外的なシステムは閏秒をカウントする:
          date --date='2012-06-30 23:59:59 +0000' +%s
          1341100823
          date --date='2012-06-30 23:59:60 +0000' +%s
          1341100824
          date --date='2012-07-01 00:00:00 +0000' +%s
          1341100825



File: coreutils-ja.info,  Node: arch invocation,  Next: nproc invocation,  Prev: date invocation,  Up: System context

21.2 `arch': マシンのハードウェア名を表示する
=============================================================

`arch' は、マシンのハードウェア名を表示する。`uname -m' と同じこと
である。

   書式:

     arch [OPTION]

   このプログラムでは、共通オプションしか使用できない。*note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: nproc invocation,  Next: uname invocation,  Prev: arch invocation,  Up: System context

21.3 `nproc': 利用できるプロセッサの個数を表示する
====================================================================

カレントプロセスが利用できるプロセシング・ユニットの個数を表示する。
それは、稼働しているプロセッサの数より少ないかもしれない。そうした
情報が取得できない場合は、搭載されているプロセッサの数を表示する。
環境変数 `OMP_NUM_THREADS' が設定されている場合は、その変数が、返さ
れる値を決めることになる。なお、結果は必ず 0 より大きくなる。

   書式:

     nproc [OPTION]

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`--all'
     システムに搭載されているプロセッサの数を表示する。それは、稼働して
     いるプロセッサや、カレントプロセスが利用できるプロセッサの数より
     多いかもしれない。このオプションを付けた場合、環境変数
     `OMP_NUM_THREADS' は考慮されない。

`--ignore=NUMBER'
     可能ならば、NUMBER 個のプロセシング・ユニットを除外する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: uname invocation,  Next: hostname invocation,  Prev: nproc invocation,  Up: System context

21.4 `uname': システムについて情報を表示する
===========================================================

`uname' は、自分がその上で実行されているマシンとオペレーティング・
システムについて情報を表示する。オプションが一つも指定されない場合は、
`-s' オプションが指定されたかのように振る舞う。

   書式:

     uname [OPTION]...

   複数のオプションや `-a' オプションが指定された場合、選択された情報は
次の順番で表示される。

     KERNEL-NAME NODENAME KERNEL-RELEASE KERNEL-VERSION
     MACHINE PROCESSOR HARDWARE-PLATFORM OPERATING-SYSTEM

   個々の情報が空白を含んでいることがある。そうした場合、出力のどこから
どこまでが、ある情報に当たるかを判断することは難しい。以下の例で RELEASE
に当たるのは、`2.2.18 #4 SMP Tue Jun 5 11:24:08 PDT 2001' の部分である。

   (訳注: RELEASE が KERNEL-RELEASE のことならば、それに相当するのは
`2.2.18' だけである。#4 から 2001 までは KERNEL-VERSION。原文は両者を
合わせて、RELEASE と言っているのかもしれない。なお、以下の例はちょっと
古い。最近の `uname -a' では、`-a' オプションの説明にあるように、unknown
の部分は表示されないはずである。)

     uname -a
     => Linux dumdum 2.2.18 #4 SMP Tue Jun 5 11:24:08 PDT 2001 i686 unknown unknown GNU/Linux

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-a'
`--all'
     以下の情報をすべて表示する。ただし、プロセッサ・タイプとハードウェア・
     プラットホームは、unknown ならば省略する。

`-i'
`--hardware-platform'
     ハードウェア・プラットホームの名前を表示する (ハードウェア実装と
     呼ばれることもある)。この情報がカーネルから簡単に取得できるように
     なっていない場合は、`unknown' と表示する。Linux のカーネルがその
     一例である。

`-m'
`--machine'
     マシンのハードウェア名を表示する (ハードウェア・クラスとかハード
     ウェア・タイプと呼ばれることもある)。

`-n'
`--nodename'
     ネットワークノードのホスト名を表示する。

`-p'
`--processor'
     プロセッサ・タイプを表示する (命令セット体系、the instruction set
     architecture、ISA などと呼ばれることもある)。この情報が
     カーネルから簡単に取得できるようになっていない場合は、`unknown' と
     表示する。Linux のカーネルがその一例である。

`-o'
`--operating-system'
     オペレーティング・システムの名前を表示する。

`-r'
`--kernel-release'
     カーネルのリリース名を表示する。

`-s'
`--kernel-name'
     カーネル名を表示する。POSIX 1003.1-2001 では (*note Standards
     conformance::)、これを「オペレーティング・システムの実装」と
     呼んでいる。POSIX の仕様には、カーネルという概念がないから
     である。カーネル名は、`-o' や  `--operating-system' オプション
     で表示されるオペレーティング・システム名と同じかもしれないし、
     違うかもしれない。オペレーティング・システムによって、基盤と
     なっているカーネルと名前が同じものもあれば (FreeBSD, HP-UX など)、
     違うものもある (GNU/Linux, Solaris など) からである。

`-v'
`--kernel-version'
     カーネルのバージョンを表示する。


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: hostname invocation,  Next: hostid invocation,  Prev: uname invocation,  Up: System context

21.5 `hostname': システムの名前を表示、または設定する
=======================================================================

`hostname' は、引数なしで実行すると、使用しているホストシステムの
名前を表示する。引数を一つ付けると、使用しているホストの名前を指定
された文字列に設定する。ホストの名前を設定するには、しかるべき権限が
必要である。

   書式:

     hostname [NAME]

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: hostid invocation,  Next: uptime invocation,  Prev: hostname invocation,  Up: System context

21.6 `hostid': 数値によるホストの識別名を表示する
==================================================================

`hostid' は、使用しているホストの数値による識別名を 16 進数で表示する。
このコマンドは引数を取らない。使用できるオプションは、`--help' と
`--version' だけである。*Note Common options::.

   たとえば、筆者が使っているシステムの一つでは、次のように表示される。

     $ hostid
     1bac013d

   たまたまこのシステムでは、識別名の 32 ビットの数値がシステムの
インターネット・アドレスと密接な関係を持っているが、いつでもそうとは
かぎらない。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: uptime invocation,  Prev: hostid invocation,  Up: System context

21.7 `uptime': システムの連続稼働時間と負荷を表示する
========================================================================

`uptime' は、現在の時刻、システムの連続稼働時間、ログインしているユーザ
の数、それに現在の平均負荷 (load average) を表示する。

   引数を指定すると、ユーザが何人ログインしているかを知るために読み込む
ファイルとして、その引数が使用される。引数を指定しない場合は、システムの
デフォルトが使用される (`uptime --help' を実行すれば、デフォルトの設定が
わかる)。

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

たとえば、以下の例は、筆者が使っているシステムの一つで、ちょうど今表示
されたものだ。

     $ uptime
      14:07  up   3:35,  3 users,  load average: 1.39, 1.15, 1.04

   細かいことを言うと、平均負荷の計算方法は、システムによっていくらか
異なっている。あるシステムでは、ここ 1 分間、5 分間、15 分間の、実行
可能状態のプロセスの平均数として計算されるが、別のシステムでは、割り込み
不可能なスリープ状態のプロセスも含めている (すなわち、ディスク I/O を
待っているプロセスだ)。Linux のカーネルは、割り込み不可能なプロセスを
含める方である。


File: coreutils-ja.info,  Node: SELinux context,  Next: Modified command invocation,  Prev: System context,  Up: Top

22 SELinux context
******************

This section describes commands for operations with SELinux contexts.

* Menu:

* chcon invocation::         Change SELinux context of file
* runcon invocation::        Run a command in specified SELinux context


File: coreutils-ja.info,  Node: chcon invocation,  Next: runcon invocation,  Up: SELinux context

22.1 `chcon': Change SELinux context of file
============================================

`chcon' changes the SELinux security context of the selected files.
Synopses:

     chcon [OPTION]... CONTEXT FILE...
     chcon [OPTION]... [-u USER] [-r ROLE] [-l RANGE] [-t TYPE] FILE...
     chcon [OPTION]... --reference=RFILE FILE...

   Change the SELinux security context of each FILE to CONTEXT.  With
`--reference', change the security context of each FILE to that of
RFILE.

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-h'
`--no-dereference'
     Affect symbolic links instead of any referenced file.

`--reference=RFILE'
     Use RFILE's security context rather than specifying a CONTEXT
     value.

`-R'
`--recursive'
     Operate on files and directories recursively.

`-H'
     `--recursive' (`-R') オプションが指定されている場合に、コマンド
     ラインで指定された引数がディレクトリへのシンボリックリンクならば、
     それをたどる。 *Note Traversing symlinks::.

`-L'
     ディレクトリ階層を再帰的にたどる際に、ディレクトリへのシンボリック
     リンクに出会ったら、必ずそれをたどる。 *Note Traversing symlinks::.

`-P'
     シンボリックリンクを一切たどらない。これが、`-H', `-L', `-P' の
     どれも指定されていないときの、デフォルトである。 *Note Traversing
     symlinks::.

`-v'
`--verbose'
     Output a diagnostic for every file processed.

`-u USER'
`--user=USER'
     Set user USER in the target security context.

`-r ROLE'
`--role=ROLE'
     Set role ROLE in the target security context.

`-t TYPE'
`--type=TYPE'
     Set type TYPE in the target security context.

`-l RANGE'
`--range=RANGE'
     Set range RANGE in the target security context.


   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: runcon invocation,  Prev: chcon invocation,  Up: SELinux context

22.2 `runcon': Run a command in specified SELinux context
=========================================================

`runcon' runs file in specified SELinux security context.

   書式:
     runcon CONTEXT COMMAND [ARGS]
     runcon [ -c ] [-u USER] [-r ROLE] [-t TYPE] [-l RANGE] COMMAND [ARGS]

   Run COMMAND with completely-specified CONTEXT, or with current or
transitioned security context modified by one or more of LEVEL, ROLE,
TYPE and USER.

   If none of `-c', `-t', `-u', `-r', or `-l' is specified, the first
argument is used as the complete context.  Any additional arguments
after COMMAND are interpreted as arguments to the command.

   With neither CONTEXT nor COMMAND, print the current security context.

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-c'
`--compute'
     Compute process transition context before modifying.

`-u USER'
`--user=USER'
     Set user USER in the target security context.

`-r ROLE'
`--role=ROLE'
     Set role ROLE in the target security context.

`-t TYPE'
`--type=TYPE'
     Set type TYPE in the target security context.

`-l RANGE'
`--range=RANGE'
     Set range RANGE in the target security context.


   終了ステータス:

     126 if COMMAND is found but cannot be invoked
     127 if `runcon' itself fails or if COMMAND cannot be found
     the exit status of COMMAND otherwise


File: coreutils-ja.info,  Node: Modified command invocation,  Next: Process control,  Prev: SELinux context,  Up: Top

23 コマンド実行条件の変更
************************************

この章で説明するコマンドは、他のコマンドを現在の条件とは違った条件で
実行する。たとえば、環境を変更して実行する、別のユーザとして実行する
といったことである。

* Menu:

* chroot invocation::        ルート・ディレクトリを変更する。
* env invocation::           環境変数を変更する。
* nice invocation::          niceness を変更する。
* nohup invocation::         ハングアップ・シグナルで終了しない。
* stdbuf invocation::        標準ストリームのバッファリングを変更する。
* timeout invocation::       タイムリミット付きで実行する。


File: coreutils-ja.info,  Node: chroot invocation,  Next: env invocation,  Up: Modified command invocation

23.1 `chroot': ルートディレクトリを変更して、コマンドを実行する
=======================================================================================

`chroot' は、指定されたディレクトリをルートディレクトリにして、コマンド
を実行する。多くのシステムでは、この操作を行うことができるのはスーパー
ユーザだけである。 (1)

   書式:

     chroot OPTION NEWROOT [COMMAND [ARGS]...]
     chroot OPTION

   通常、ファイル名の検索は、ディレクトリ構造の根 (ルート、root)、
すなわち `/' を起点として行われる。`chroot' はこのルートを NEWROOT
ディレクトリ (実在するディレクトリでなければならない) に変更し、
その上で COMMAND を、ARGS の指定があれば ARGS を付けて実行する。
COMMAND が指定されていない場合、デフォルトのコマンドは、環境変数
`SHELL' の値か、`SHELL' が設定されていなければ、`/bin/sh' であり、
それが `-i' オプションを付けて、呼び出される。COMMAND は シェルの
組み込みコマンドであってはならない (*note Special built-in
utilities::)。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`--userspec=USER[:GROUP]'
     デフォルトでは、COMMAND は、呼び出し側のプロセスと同じ資格情報を
     使って、実行される。このオプションを使えば、COMMAND を別の USER
     として実行することができる。別の基本 GROUP を指定することも可能だ。

`--groups=GROUPS'
     このオプションを使えば、新しいプロセスが使用する補助 GROUPS を指定
     することができる。グループのリスト (名前でも ID 番号でもよい) は、
     コンマで区切られていなければならない。


   chroot を使う上でよくある問題を避けることができるように、ちょっと
した情報をいくつか挙げておく。まず簡単なことから言うと、COMMAND は、
静的にリンクしたバイナリを指すようにした方がよい。もし、動的にリンク
した実行ファイルを使用するのならば、共有ライブラリが新しいルート
ディレクトリ以下の適切な場所に存在するように、前もって準備しておく
必要があるだろう。

   たとえば、静的にリンクした `ls' の実行ファイルを作成して、
`/tmp/empty' に置けば、root ユーザとして次のようなコマンドを実行する
ことができる。

     $ chroot /tmp/empty /ls -Rl /

   出力はこんなふうになるだろう。

     /:
     total 1023
     -rwxr-xr-x 1 0 0 1041745 Aug 16 11:17 ls

   もし、動的にリンクした実行ファイル、たとえば `bash' を使いたい
ならば、まず `ldd bash' を実行して、どんな共有オブジェクトファイルが
必要かを調べることだ。それから、`bash' 自体のバイナリをコピーするだけ
でなく、`ldd bash' でリストされたファイルも、新しいルートディレクトリ
になるディレクトリ以下のしかるべき場所にコピーしておく。さらに、
実行ファイルが何か他のファイルも必要としているなら (たとえば、データ
ファイル、ステータスファイル、デバイスファイルなど)、それも適切な
場所にコピーする。

   終了ステータス:

     125: `chroot' そのものの実行に失敗した。
     126: COMMAND は見つかったが、起動できない。
     127: COMMAND が見つからない。
     それ以外は、COMMAND の終了ステータス。

   ---------- Footnotes ----------

   (1) もっとも、システムによっては (たとえば、FreeBSD がそうだが)、
特定の一般ユーザが `chroot' システムコールを使用できるように設定
できるものもある。従って、そうしたユーザは `chroot' コマンドを実行
できるわけだ。また、Cygwin では、どんなユーザでも `chroot' コマンド
を実行できる。MS-Windows では chroot 関数をサポートしていないため、
内部で使用する関数が特権を要求しないからである。


File: coreutils-ja.info,  Node: env invocation,  Next: nice invocation,  Prev: chroot invocation,  Up: Modified command invocation

23.2 `env': 変更した環境でコマンドを実行する
============================================================

`env' は、環境を変更して、コマンドを実行する。

   書式:

     env [OPTION]... [NAME=VALUE]... [COMMAND [ARGS]...]
     env

   `VARIABLE=VALUE' という形のオペランドは、環境変数 VARIABLE の値を
VALUE に設定する。VALUE は空っぽでも構わない (`VARIABLE=')。変数の値を
空に設定 (set) するのは、変数を破棄 (unset) するのとは別のことである。
こうしたオペランドは、左から右へ評価されるので、二つのオペランドが同じ
変数を対象にしている場合、前のものは無視される。

   環境変数名は、空でもよいし、`=' と ASCII NUL 以外なら、どんな文字を
含んでいても構わない。とは言え、変数名は、アンダースコア、数字、ASCII
文字のみから構成し、数字以外の文字で始めるようにした方が、賢明である。
それ以外の名前だと、シェルなどのアプリケーションがうまく動作しないからだ。

   `=' という文字を含まない最初のオペランドが、起動するプログラムで
あり、環境変数 `PATH' に従って、どこにあるかが検索される。残っている
引数があれば、すべてそのプログラムに引数として渡される。起動するプロ
グラムは、シェルの組み込みコマンドであってはならない (*note Special
built-in utilities::)。

   `PATH' に対する変更は、COMMAND のありかを検索する前に有効になる。
そこで、`PATH' を短縮するときには、気をつけなければならない。`PATH' が
空だったり、`/bin' のような重要なディレクトリを欠いていると、`PATH' を
変更する前と同じ動作にならないからだ。

   めったにないことだが、プログラムの名前に `=' という文字が含まれて
いる場合、それを変数の指定と区別する唯一の方法は、COMMAND として仲介的
なコマンドを使用し、その ARGS として問題のあるプログラム名を渡すこと
である。たとえば、`./prog=' が現在の `PATH' 中に存在する実行ファイルだ
としよう。

     env prog= true
       # 環境変数 prog を空に設定して 'true' を実行する。
     env ./prog= true
       # 環境変数 ./prog を空に設定して 'true' を実行する。
     env -- prog= true
       # 環境変数 prog を空に設定して 'true' を実行する。
     env sh -c '\prog= true'
       # 'true' を引数にして 'prog=' を実行する。
     env sh -c 'exec "$@"' sh prog= true
       # これも 'prog=' を実行する。

   環境変数の設定の後にコマンド名が指定されていない場合は、生成された
環境が表示される。これは、COMMAND に `printenv' を指定するのと同じこと
である。

   以下に例をいくつか挙げる。`env' に渡される環境は、`LOGNAME=rms',
`EDITOR=emacs', `PATH=.:/gnubin:/hacks' からなっているものとする。

   * 現在の環境を出力する。
          $ env | LC_ALL=C sort
          EDITOR=emacs
          LOGNAME=rms
          PATH=.:/gnubin:/hacks

   * 環境を削減して、`foo' を実行する。`foo' が見つからないといけない
     ので、`PATH' だけは元のまま残している。
          env - PATH="$PATH" foo

   * `LOGNAME=rms', `EDITOR=emacs', `PATH=.:/gnubin:/hacks' からなる環境
     で `foo' を実行する。`foo' には、シェルの組み込みコマンドではなく、
     ファイルシステム中で見つかった実行ファイルが必ず使用される。
          env foo

   * `LOGNAME=foo', `EDITOR=emacs', `PATH=.:/gnubin:/hacks',
     `DISPLAY=gnu:0' からなる環境で、`nemacs' を実行する。
          env DISPLAY=gnu:0 LOGNAME=foo nemacs

   * プログラム `/energy/--' の実行を試みる (パスの検索でそれしか出て
     こないようにしている)。`--' というコマンドが存在する場合、環境
     は、`LOGNAME=rms' と `PATH=/energy' だけになり、引数には、`e=mc2',
     `bar', `baz' が使われる。
          env -u EDITOR PATH=/energy -- e=mc2 bar baz


   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`-0'
`--null'
     各行の末尾に改行ではなく、ゼロバイト (ASCII NUL) を出力する。この
     オプションを使用すると、`env' の出力するデータに、途中に改行を
     挟むものがあっても、他のプログラムがその出力を解析できるようになる。

`-u NAME'
`--unset=NAME'
     変数 NAME が環境中にあれば、それを環境から削除する。

`-'
`-i'
`--ignore-environment'
     継承した環境を無視し、空っぽの環境から始める。


   終了ステータス:

     0:   COMMAND が指定されず、環境を出力した。
     125: `env' そのものの実行に失敗した。
     126: COMMAND は見つかったが、起動できない。
     127: COMMAND が見つからない。
     それ以外は、COMMAND の終了ステータス。


File: coreutils-ja.info,  Node: nice invocation,  Next: nohup invocation,  Prev: env invocation,  Up: Modified command invocation

23.3 `nice': niceness を変更して、コマンドを実行する
===================================================================

"`nice' はプロセスの "niceness" を表示、または変更する。niceness は、
プロセスが優先的にスケジュールされるかどうかに影響するパラメータである。
(訳注: niceness を「スケジュール優先度」と訳さない理由については、
三つほど下のパラグラフをご覧ください。)

   書式:

     nice [OPTION]... [COMMAND [ARG]...]

   引数を指定しないと、`nice' は現在の niceness を表示する。引数に
COMMAND を指定した場合は、niceness を調整して、その COMMAND を実行する。
デフォルトでは、niceness が 10 増加する。

   niceness の値は、最小が -20 で、最大が 19 である (値が小さければ、
プロセスの優先度が高くなり、使えるリソースも多くなるが、その結果、他の
プロセスの動作が遅くなる。また、値が大きければ、プロセスの優先度が低く
なり、自分自身の動作は遅くなるが、実行中の他のプロセスの速度に与える
影響は小さくなる)。システムによっては、niceness の値の範囲がもっと広い
ものもあるし、反対に、上下限の制限がもっときついものもある。サポート
されている範囲を越えた niceness を指定すると、サポートされている値の
最小、または最大を使用しようとしているものとみなされる。

   niceness をスケジューリング優先度 (scheduling priority) と混同しては
ならない。後者は、様々なスレッドをどういう序列で実行するかの予定を組む
際に、その序列をアプリケーション側に決めさせるものである。優先度とは
違って、niceness はスケジューラに対する単なるアドバイスにすぎず、スケ
ジューラはそれを無視することができるのだ。また、用語について言うと、
POSIX は `nice' の動作を "nice value" という用語で定義している。 この
nice value は、ある niceness と 最小の niceness との間の負ではない
差である。`nice' コマンドは POSIX に準拠しているものの、この文書や
エラーメッセージでは、従来の習慣との親和性を考慮して、"niceness" という
言葉を使っている。

   COMMAND は、シェルの組み込みコマンドであってはならない (*note
Special built-in utilities::)。

   シェルの組み込み機能の `nice' やエイリアスのために、`nice' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `nice' を起動すればよい (すなわち、 `env
nice ...' のようにだ)。

   このプログラムでは、以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`-n ADJUSTMENT'
`--adjustment=ADJUSTMENT'
     コマンドの niceness を 10 ではなく、ADJUSTMENT 増加する。ADJUSTMENT
     が負の数の場合、ユーザがしかるべき特権を持っていなければ、`nice' は
     警告を発する。とは言え、警告を出すだけで、ADJUSTMENT として 0 が
     指定されたかのように振る舞う。

     互換性を考慮して、`nice' は `-ADJUSTMENT' というオプションの古い
     書式もサポートしている。だが、新しいスクリプトでは、`-n ADJUSTMENT'
     の方を使うべきである。


   終了ステータス:

     0:   COMMAND が指定されなかったので、niceness を出力した。
     125: `nice' そのものの実行に失敗した。
     126: COMMAND が見つかったが、起動できなかった。
     127: COMMAND が見つからなかった。
     それ以外は、COMMAND の終了ステータス。

   対話的ではないプログラムは、niceness を落として (訳注: すなわち、
niceness の値を増やして) 実行すると、都合のよいことがある。

     $ nice factor 4611686018427387903

   `nice' は、現在の niceness を表示するので、`nice' を通して `nice'
を起動すれば、それがどんな動作をするか、目の当たりに見ることができる。

   デフォルトの動作は、niceness を `10' 増加することである。

     $ nice
     0
     $ nice nice
     10
     $ nice -n 10 nice
     10

   ADJUSTMENT は、現在の niceness からいくら増減するかということである。
次の例では、最初の `nice' が、二番目の `nice' を niceness 10 で実行し、
二番目の `nice' は、niceness をさらに 3 増やして、三番目の `nice' を
実行している。

     $ nice nice -n 3 nice
     13

   サポートされている範囲より大きい niceness を指定するのは、サポート
されている最大値を指定するのと同じことである。

     $ nice -n 10000000000 nice
     19

   特権ユーザだけが niceness の値を下げて、プロセスを実行できる。

     $ nice -n -1 nice
     nice: cannot set niceness: Permission denied
     0
     $ sudo nice -n -1 nice
     -1


File: coreutils-ja.info,  Node: nohup invocation,  Next: stdbuf invocation,  Prev: nice invocation,  Up: Modified command invocation

23.4 `nohup': ハングアップ・シグナルで終了しないコマンドを実行する
============================================================================================

`nohup' を使って、COMMAND を実行すると、指定されたコマンドがハング
アップ・シグナルを無視するようになる。従って、そのコマンドは、ユーザが
ログアウトした後でも、バックグラウンドで実行を継続することができる。

   書式:

     nohup COMMAND [ARG]...

   標準入力が端末の場合、標準入力は `/dev/null' に付け換えられる。その
結果、端末セッションが、`nohup' によって実行されたコマンドが端末を使用
していると勘違いすることがなくなる。これは GNU の拡張である。GNU 以外
のホストでも使うことを考えているプログラムでは、GNU の拡張を当てにせず、
`nohup COMMAND [ARG]... </dev/null' を使った方がよい。

   標準出力が端末の場合、コマンドの標準出力は、`nohup.out' というファ
イルに追加されて行く。そのファイルに書き込めない場合は、`$HOME/nohup.out'
に追加書き込みされることになる。そのファイルにも書き込めない場合は、
コマンドの実行が行われない。`nohup' によって作成される `nohup.out' や
`$HOME/nohup.out' はすべて、ファイルの所有者にのみ読み書き可能なものに
なる。現在の umask の設定の影響は受けない。

   標準エラーが端末の場合、通常それは、標準出力 (リダイレクトされている
こともある) と同じファイル・デスクリプタにリダイレクトされる。しかし
ながら、標準出力がクローズされている場合には、標準エラーの端末への出力は、
行き先を変えて、`nohup.out' や `$HOME/nohup.out' というファイルに追加
される。どちらのファイルが使われるかは、上述のとおりである。

   コマンドの出力を `nohup.out' 以外のファイルに書き込みたければ、リダ
イレクトすればよい。たとえば、`make' の出力を `make.log' に書き込み
たかったら、次のようにする。

     nohup make > make.log

   `nohup' は、実行するコマンドを自動的にバックグラウンドに送ることを
しない。そこで、ユーザは、コマンドラインの末尾に `&' を付けることで、
明示的にそれを行わなければならない。また、`nohup' は、COMMAND の
niceness を変更しない。niceness を変更したかったら、`nice' を使って、
`nohup nice COMMAND' のように実行すればよい。

   COMMAND は、シェルの組み込みコマンドであってはならない (*note
Special built-in utilities::)。

   指定できるオプションは、`--help' と `--version' だけである。 *Note
Common options::.  オプションはオペランドの前に置かなければならない。

   終了ステータス:

     125: `POSIXLY_CORRECT' が設定されていないとき、`nohup' そのものの
           実行に失敗した。
     126: COMMAND は見つかったが、起動できない。
     127: COMMAND が見つからない。
     それ以外の場合は、COMMAND の終了ステータス。

   `POSIXLY_CORRECT' が設定されている場合は、`nohup' そのものが実行に
失敗したときの終了ステータスは、125 ではなく 127 になる。


File: coreutils-ja.info,  Node: stdbuf invocation,  Next: timeout invocation,  Prev: nohup invocation,  Up: Modified command invocation

23.5 `stdbuf': I/O ストリームのバッファリングを変更して、コマンドを実行する
=======================================================================================================

`stdbuf' を使用すると、プログラムと結びついている 3 種類の標準 I/O
ストリームに対して、そのバッファリング動作を変更することができる。

   書式:

     stdbuf OPTION... COMMAND

   COMMAND は、次の条件を満たすプログラムの名前で始まっていなければ
ならない。
  1. 入出力に ISO C `FILE' ストリームを使用している (注意: プログラム
     `dd' や `cat' は、これを使用していない)。

  2. 自分で標準ストリームのバッファリングを調整していない (注意: プログ
     ラム `tee' は、この部類に入らない)。

   後に続く引数があれば、COMMAND に引数として渡される。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.

`-i MODE'
`--input=MODE'
     標準入力ストリームのバッファリングを調整する。

`-o MODE'
`--output=MODE'
     標準出力ストリームのバッファリングを調整する。

`-e MODE'
`--error=MODE'
     標準エラーストリームのバッファリングを調整する。


   MODE には、以下のものを指定できる。

`L'
     ストリームを行単位のバッファ・モードにする。このモードでは、改行が
     出力されるか、あるいは、端末デバイスに結びついているストリームから
     入力が読み込まれるまで、データを溜めておく。このオプションは、標準
     入力に対しては無効である。

`0'
     選択したストリームのバッファリングを無効にする。このモードでは、
     データは即座に出力される。また、要求された量のデータしか入力から
     読み込まない。入力と出力で動作が違うことに気をつけていただきたい。
     なお、入力のバッファリングを無効にしても、ストリーム入力関数の
     応答性やブロッキング動作に影響することはない。たとえば、`fread'
     は、下層で動いている `read' が、要求した量より少ないデータを返して
     きても、`EOF' が来るか、エラーが起きるまで、やはりブロッキングを
     行うのである。

`SIZE'
     バッファ一杯モード (fully buffered mode) で使用するバッファのサイズ
     を指定する。 SIZE
     は整数であり、以下に挙げるような、何倍かを表す接尾辞を
     後ろに付けることもできる。
          `KB' =>           1000 (KiloBytes)
          `K'  =>           1024 (KibiBytes)
          `MB' =>      1000*1000 (MegaBytes)
          `M'  =>      1024*1024 (MebiBytes)
          `GB' => 1000*1000*1000 (GigaBytes)
          `G'  => 1024*1024*1024 (GibiBytes)
     `T', `P', `E', `Z', `Y' についても同様。


   終了ステータス:

     125: `stdbuf' そのものの実行に失敗した。
     126: COMMAND は見つかったが、起動できない。
     127: COMMAND が見つからなかった。
     それ以外は、COMMAND の終了ステータス。


File: coreutils-ja.info,  Node: timeout invocation,  Prev: stdbuf invocation,  Up: Modified command invocation

23.6 `timeout': タイムリミット付きでコマンドを実行する
=========================================================================

`timeout' は渡されたコマンドを実行し、指定された時間が経過しても
まだ実行が続いていたら、そのコマンドを終了させる。

   書式:

     timeout [OPTION] DURATION COMMAND [ARG]...

   COMMAND は、シェルの組み込みコマンドであってはならない (*note
Special built-in utilities::)。

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`--foreground'
     独立したバックグラウンドのプログラム・グループを作成しない。
     そうすることで、`timeout' に管理される COMMAND が、フォアグラウンド
     の TTY を通常どおり使用できるようにする。対話的シェルから直接実行
     されていない (訳注: たとえば、シェルスクリプト中で実行される)
     `timeout' コマンドをサポートするためにこの動作が必要になるのは、
     次の二つの場合である。
       1. COMMAND が対話的であり、たとえば端末からの読み込みが必要な
          場合。

       2. 端末から直接 COMMAND にシグナルを送ることができるようにしたい
          場合。(たとえば、Ctrl-C を送るとか)。

     この動作モードでは、COMMAND のいかなる子プロセスも、時間切れで
     終了することがないのに注意すること。

`-k DURATION'
`--kill-after=DURATION'
     ここで指定した DURATION の経過後に、今度は `KILL' シグナルを送り
     付けて、監視対象の COMMAND を確実に終了させる。このオプションを
     付けないと、選択したシグナルに COMMAND を終了させる力がなかった
     場合に、`timeout' は COMMAND を殺すことができない。

`-s SIGNAL'
`--signal=SIGNAL'
     制限時間が来たとき、デフォルトの `TERM' シグナルではなく、この
     SIGNAL を COMMAND に送る。SIGNAL は `HUP' のような名前でもよく、
     番号でもよい。*Note Signal specifications::.

   DURATION は浮動小数点数であり、後ろに単位を付けることもできる。
     `s' 何秒 (デフォルト)
     `m' 何分
     `h' 何時間
     `d' 何日
   DURATION が 0 だと、対象となるコマンドが時間切れなしになる。実際の
制限時間は、システムの状態に左右されることに注意していただきたい。
秒以下の制限時間を指定するときは、特にそれを考慮に入れるべきである。

   終了ステータス:

     124: COMMAND がタイムアウトした。
     125: `timeout' そのものの実行に失敗した。
     126: COMMAND は見つかったが、起動できなかった。
     127: COMMAND が見つからない。
     137: COMMAND に the KILL(9) シグナルを送った (128+9)
     それ以外は、COMMAND の終了ステータス。


File: coreutils-ja.info,  Node: Process control,  Next: Delaying,  Prev: Modified command invocation,  Up: Top

24 プロセス制御
*********************

* Menu:

* kill invocation::          プロセスにシグナルを送る。


File: coreutils-ja.info,  Node: kill invocation,  Up: Process control

24.1 `kill': プロセスにシグナルを送る
=================================================

`kill' コマンドは、プロセスにシグナルを送る。シグナルを送られた
プロセスは、終了するか、あるいは、シグナルを受け取った瞬間に他の
何らかの形で反応する。また、`kill' は、シグナルに関する情報を一覧
表示する。

   書式:

     kill [-s SIGNAL | --signal SIGNAL | -SIGNAL] PID...
     kill [-l | --list | -t | --table] [SIGNAL]...

   シェルの組み込み機能の `kill' やエイリアスのために、`kill' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `kill' を起動すればよい (すなわち、 `env
kill ...' のようにだ)。

   `kill' コマンドの最初の書式では、すべての PID 引数に対してシグナルが
送られる。シグナルが指定されていない場合に送られるデフォルトのシグナル
は、`TERM' である。 `0' という特別なシグナル番号は、有効なシグナルを
表していないが、引数 PID が指しているプロセスに対してシグナルを送る
ことが可能かどうかを、調べるために使うことができる。

   PID が正の数なら、シグナルはプロセス ID が PID のプロセスに送られる。
PID が 0 なら、シグナルはカレントプロセスのプロセスグループに属する
すべてのプロセスに送られる。PID が -1 の場合、シグナルが送られるのは、
ユーザがシグナルを送る権限を持っているすべてのプロセスである。PID が -1
より小さい場合は、PID の絶対値に等しいプロセスグループに属するすべての
プロセスにシグナルが送られる。

   PID が正の数ではない場合、システムプロセスに属するプロセス (システム
によって様々である) は、シグナルが送られるプロセスのリストから除外
される。

   最初の PID 引数として負の PID を使用したい場合は、その前に`--' オプ
ションを置くべきである。とは言え、`kill -SIGNAL -PID' という書式を使う
場合は、`--' は必要がない。これは、POSIX に対する一般的な拡張である。
そこで、次に挙げるコマンドは等価になる。

     kill -15 -1
     kill -TERM -1
     kill -s TERM -- -1
     kill -- -1

   最初の書式の `kill' コマンドは、すべての PID 引数が、シグナルが
送られたプロセスをそれぞれ少なくとも一つは指している場合に、成功の
ステータスで終了する。

   `kill' コマンドの二番目の書式では、シグナルに関する情報が表示される。
`-l' または `--list'、あるいは、`-t' または `--table' オプションの
指定は必須である。引数 SIGNAL を付けないと、サポートされているすべての
シグナルがリストされる。`-l' や `--list' の出力は、シグナル名のリスト
であり、1 行に一つづつ表示される。なお、引数 SIGNAL がすでにシグナル名
である場合は、名前ではなく、シグナル番号が表示される。`-t' や `--table'
の出力は、シグナル番号、シグナル名、その説明からなる表である。この書式の
`kill' コマンドは、すべての SIGNAL 引数が有効なものであり、出力エラーが
なかったとき、成功のステータスで終了する。

   `kill' コマンドでは、`--help' や `--version' オプションも使用できる。
*Note Common options::.

   SIGNAL の指定には、`HUP' のようなシグナル名や、`1'のようなシグナル
番号、それに、シグナルによって終了するときのプロセスの終了ステータスを
使うことができる (訳注: 最後のものは、GNU coreutils の `kill' コマンド
では使用できるが、他の系統の `kill' では使えないかもしれない)。シグナル
名は、標準的な形式でも、頭に `SIG' を付けた形式でも構わない。大文字
小文字はどちらを使ってもよいが、`-SIGNAL' という形式のオプションの場合
は例外で、大文字を使わなければならない。小文字を使うと、他のオプション
とまぎらわしいからである。サポートしているシグナル名とシグナル番号に
ついては、右の節を参照していただきたい。*Note Signal specifications::.


File: coreutils-ja.info,  Node: Delaying,  Next: Numeric operations,  Prev: Process control,  Up: Top

25 一時停止
***************

* Menu:

* sleep invocation::         指定された時間、停止する。


File: coreutils-ja.info,  Node: sleep invocation,  Up: Delaying

25.1 `sleep': 指定された時間、停止する
==================================================

`sleep' は、コマンドライン引数の値の合計によって指定された時間だけ
停止する。

   書式:

     sleep NUMBER[smhd]...

   各引数は数値であり、後ろに単位を付けてもよい。デフォルトの単位は
秒である。単位には、以下のものが指定できる。

`s'
     秒

`m'
     分

`h'
     時

`d'
     日

   `sleep' の従来の実装では、NUMBER は整数でなければならず、引数は
接尾辞なしのものが一つしか認められていなかった。それに対して GNU の
`sleep' では、任意の数の浮動小数点数が使用できる。*Note Floating
point::.

   オプションは、`--help' と `--version' だけである。*Note Common
options::.

   シェルの組み込み機能の `sleep' やエイリアスのために、`sleep' に何の
修飾も付けずに対話的に使ったり、スクリプトの中で使ったりすると、動作が
ここで述べているものとは違うことがあるかもしれない。シェルによる干渉を
避けるためには、`env' 経由で `sleep' を起動すればよい (すなわち、 `env
sleep ...' のようにだ)。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: Numeric operations,  Next: File permissions,  Prev: Delaying,  Up: Top

26 数値の操作
******************

以下のプログラムは、数に関係した作業をする。

* Menu:

* factor invocation::        素因数を表示する。
* seq invocation::           連続する数を表示する。


File: coreutils-ja.info,  Node: factor invocation,  Next: seq invocation,  Up: Numeric operations

26.1 `factor': 素因数を表示する
=======================================

`factor' は、素因数を表示する。

   書式:

     factor [NUMBER]...
     factor OPTION

   NUMBER がコマンドラインで指定されていない場合、`factor' は、標準入力
から数値を読み込む。このとき、改行、タブ、空白で区切って複数の数値を
入力できる。

   `factor' コマンドで使えるオプションは、いくつもない。

`--help'
     簡単なヘルプメッセージを標準出力に表示し、それ以上の処理をする
     ことなく終了する。

`--version'
     プログラムのバージョンを標準出力に表示し、それ以上の処理をする
     ことなく、終了する。

   メルセンヌ素数の 8 番目と 9 番目の積を素因数に分解するには、2.2 GHz
Athlon のシステムで、30 ミリセコンドの CPU 時間を要する。

     M8=$(echo 2^31-1|bc)
     M9=$(echo 2^61-1|bc)
     n=$(echo "$M8 * $M9" | bc)
     /usr/bin/time -f %U factor $n
     4951760154835678088235319297: 2147483647 2305843009213693951
     0.03

   同様に、8 番目のフェルマー数、2^256+1 では、同じマシンで約 20 秒
かかる。

   大きな数の素因数分解は、そもそも大変な作業である。`factor' が使用
している Pollard Rho アルゴリズムは、比較的小さな因数を持つ数値に
対してとりわけ効率がよい。もし、小さな因数を持たない大きな数値 (たと
えば、二つの大きな素数の積からなる数値) の素因数分解をなさりたいのなら、
他の手法の方がずっと適している。

   `factor' が GNU MP を使用せずにビルドされている場合は、単精度の
算術しか利用できない。従って、大きな数値 (一般には 2^64 以上)
には対応していない。単精度用のコードが使用しているアルゴリズムは、
比較的小さな数値を素因数に分解するためのものなのである。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: seq invocation,  Prev: factor invocation,  Up: Numeric operations

26.2 `seq': 数列を表示する
=================================

`seq' は、数列を標準出力に表示する。

   書式:

     seq [OPTION]... LAST
     seq [OPTION]... FIRST LAST
     seq [OPTION]... FIRST INCREMENT LAST

   `seq' は、FIRST から LAST までの数を INCREMENT おきに表示する。
デフォルトでは、それぞれの数は 1 行に 1 個づつ表示される。INCREMENT が
指定されていない場合は、FIRST が LAST より大きい場合でも、デフォルトの
`1' が INCREMENT として使用される。FIRST のデフォルトもまた `1' である。
従って、`seq 1' は `1' を表示するが、`seq 0' や `seq 10 5' は、何も出力
しない。数値には浮動小数点数を指定してもよい。*Note Floating point::.

   このプログラムでは以下のオプションが使用できる。参照: *note Common
options::.  オプションはオペランドの前に置かなければならない。

`-f FORMAT'
`--format=FORMAT'
     すべての数を FORMAT を使用して表示する。FORMAT は、 `printf' 形式の
     浮動小数点数の変換指定をただ一つ含むものでなければならない。すなわち、
     `%a', `%e', `%f', `%g', `%A', `%E', `%F', `%G' のいづれかである。
     `%' の後ろには 0 個以上のフラグを、`-+#0 '' のうちから選んで置く
     ことができる。また、それに続けて、1 個以上の数字からなるフィールド
     幅を指定することもできるし、さらにその後ろに、`.' とそれに続く 0 個
     以上の数字からなる精度を指定することもできる。FORMAT には、任意の
     数の `%%' 変換指定が含まれていてもよい。変換指定はすべて、`printf'
     の場合と同じ意味を持っている。

     デフォルトの表示形式は、FIRST, INCREMENT, LAST がどういう表記を使用
     しているかよって決まる。そのすべてが固定小数点の 10進数表記を使用
     しているならば、デフォルトの表示形式は `%.Pf' になる。ここで P は、
     出力する数値を過不足なく表現できる最小の精度である。それ以外の場合、
     デフォルトの表示形式は `%g' になる。

`-s STRING'
`--separator=STRING'
     数の区切りに STRING を使う。デフォルトは改行である。出力の最後
     には、必ず改行が付く。

`-w'
`--equal-width'
     すべての数を同じ桁数で表示する。先頭の空きは 0 で埋める。FIRST,
     INCREMENT, LAST は、すべて固定小数点の 10 進数表記でなければなら
     ない (他のやり方で先頭を埋めたければ、`--format' を使うこと)。


   `-f' オプションを使えば、出力をもっときめ細かく制御することができる。

     $ seq -f '(%9.2E)' -9e5 1.1e6 1.3e6
     (-9.00E+05)
     ( 2.00E+05)
     ( 1.30E+06)

   出力を 16 進数の整数にしたかったら、`printf' を使って変換すればよい。

     $ printf '%x\n' $(seq 1048575 1024 1050623)
     fffff
     1003ff
     1007ff

   数のリストが非常に長くなる場合は、`xargs' を使用すると、引数リストの
長さに対するシステムの制限を回避することができる。

     $ seq 1000000 | xargs printf '%x\n' | tail -n 3
     f423e
     f423f
     f4240

   8 進数の出力を生成するには、printf に対して `%x' の代わりに、`%o'
フォーマットを使用すればよい。

   ほとんどのシステムで `seq' は、少なくとも 2^53 までの数値に対して
整数の出力を生成することができる。それより大きい整数に対しては概算に
なる。細かい点は、ご使用のシステムの浮動小数点の実装によって異なって
いる。*Note Floating point::.  `seq' が 2^64 までの整数に対しては、
きちんと動作するが、それより大きな整数に対しては、数値が不正確になる
ことがあるというのは、よくある話である。

     $ seq 50000000000000000000 2 50000000000000000004
     50000000000000000000
     50000000000000000000
     50000000000000000004

   とは言え、負ではない整数を対象とし、インクリメントが 1 で、フォー
マット指定オプションはないという条件の元では、`seq' は任意の大きな
数値を表示できることも心に留めておいていただきたい。

   `seq' でとんでもなく大きな桁の値を扱うときは、気をつけた方がよい。
さもないと、`seq' は内部で浮動小数点を使用しているので、結果を見て
びっくりするかもしれない。たとえば、x86 のプラットフォームでは、
内部表現が 64 ビットの仮数部を使用しているが、そこで次のコマンドを
実行すると、

     seq 1 0.0000000000000000001 1.0000000000000000009

   `seq' は 1.0000000000000000007 を二度出力し、1.0000000000000000008
をスキップする (訳注: 訳者の amd64 環境では、1.0000000000000000008 では
なく、1.0000000000000000006 をスキップする)。

   終了ステータス 0 は成功を示し、0 以外の値は失敗を示す。


File: coreutils-ja.info,  Node: File permissions,  Next: Date input formats,  Prev: Numeric operations,  Up: Top

27 ファイルの許可属性
******************************

各ファイルには、一組のファイル・モードビット ("file mode bits") という
ものがあって、ユーザがそのファイルに対してどんなアクセスができるかを
制御している。モードビットは、シンボルによっても、8 進数によっても
表すことができる。

* Menu:

* Mode Structure::           ファイル・モードビットの構成。
* Symbolic Modes::           ファイル・モードビットの覚えやすい表現。
* Numeric Modes::            ファイル・モードビットの 8 進数による表現。
* Operator Numeric Modes::   8 進数によるモードの追加、削除、絶対指定。
* Directory Setuid and Setgid::  ディレクトリの set-user-ID と set-group-ID。


File: coreutils-ja.info,  Node: Mode Structure,  Next: Symbolic Modes,  Up: File permissions

27.1 ファイル・モードビットの構成
===============================================

ファイル・モードビットには、二つの構成部分がある。ファイルに対する
通常のアクセスを制御するファイル許可属性ビット ("file permission bits")
と、若干のファイルのみに働く特殊モードビット ("special mode bits")
である。

   ユーザがファイルに対して持つ許可 (訳注: アクセス権とも言う) には、 3
種類ある。

  1. ファイルを読み込む許可。ディレクトリに対しては、ディレクトリの
     中身をリストする許可になる。

  2. ファイルに書き出す (ファイルを変更する) 許可。ディレクトリに
     対しては、そのディレクトリ中でファイルを作成したり、削除したり
     する許可になる。

  3. ファイルを実行する (プログラムとしてそれを動かす) 許可。
     ディレクトリに対しては、ディレクトリ中のファイルにアクセスする
     許可になる。

   ユーザにも 3 種類あり、ファイルに対する上記の操作のいづれについても、
それぞれ違った許可を持つことができる。

  1. ファイルの所有者。

  2. ファイルの所有グループに属するファイルの所有者以外のユーザ。

  3. それ以外の全員。

   ファイルには、作成されるときに所有者とグループが割り当てられる。
たいていの場合、所有者はファイルを作成したユーザであり、グループは
ファイルが存在するディレクトリのグループだが、オペレーティング
システムやファイルが作成されるファイルシステム、ファイルの作成方法
などによって違うこともある。ファイルの所有者やグループは、`chown' や
`chgrp' コマンドを使って、変更することができる。

   上に挙げた 3 種類の許可属性 3 組のほかに、ファイルのモードビット
には三つの特殊モードビットが存在するが、そうしたものは、実行ファイル
(すなわち、プログラム) と -- ほとんどのシステムでは -- ディレクトリ
にしか効果を持たない。

  1. ファイルの実行時に、そのプロセスの実効ユーザ ID をファイルの
     所有者のものにする ("set-user-ID bit" とか "setuid bit" と
     呼ばれる)。若干のシステムでは、ディレクトリに set-user-ID ビット
     を付けると、ファイルの作成者が誰であれ、そのディレクトリ中で
     作成されるファイルの所有者が、ディレクトリの所有者と同じになる。
     また、新しく作られるサブディレクトリに set-user-ID ビットが付く。

  2. ファイルの実行時に、そのプロセスの実効グループ ID をファイルの
     グループのものにする ("set-group-ID bit" とか "setgid bit" と
     呼ばれる)。ほとんどのシステムでは、ディレクトリに set-group-ID
     を付けると、ファイルの作成者がどんなグループに属していようとも、
     そのディレクトリ中で作成されるファイルのグループが、ディレクトリ
     のグループと同じになる。また、新しく作成されるサブディレクトリに
     set-group-ID ビットが付く。

  3. 特権を持たないユーザ (訳注: 要するに、root 以外の一般ユーザ) に
     対して、自分が所有するファイルやディレクトリを除き、ディレクトリ
     中のファイルの削除や、名前の変更を禁じる。これは、ディレクトリの
     削除制限フラグ ("restricted deletion flag") と呼ばれ、`/tmp' の
     ような、誰でも書き込めるディレクトリでよく見かけられる。

     古いシステムの中には、通常ファイルにこのビットが付いていると、
     プログラムのテキスト・イメージをスワップ・デバイスにセーブする
     ものがある。そうすることで、実行時にロードが速くなるわけだ。
     こちらは、スティッキー・ビット ("sticky bit") と呼ばれる。

   上記のファイル・モードビットのほかに、ファイルシステムに固有の
ファイル属性が存在することがある。たとえば、アクセス・コントロール・
リスト (ACL) がそうだし、ファイルが圧縮されているか否か、ファイルが
変更可能か否か (変更不可属性)、ファイルがダンプ可能か否か、といった
属性が存在することもある。そうした属性は、通常、ファイルシステム固有の
プログラムを使って設定される。例を挙げよう。

ext2
     GNU 及び GNU/Linux では、ext2 ファイルシステムに固有なファイル
     属性は、`chattr' コマンドを使って設定される。

FFS
     FreeBSD では、FFS ファイルシステムに固有なファイルフラグは、
     `chflags' コマンドを使って設定される。

   ファイルのモードビットがそのファイルに対するある操作を許可していたと
しても、それでもその操作に失敗することがある。その理由としては、次の
ようなことが考えられる。

   * ファイルシステムに固有な属性やフラグが、その操作を許可していない。

   * ファイルシステムが読み込み専用でマウントされている。

   たとえば、ファイルに変更不可属性が設定されていると、`chmod a+w FILE'
を直前に実行したとしても、ファイルを変更することはできない。


File: coreutils-ja.info,  Node: Symbolic Modes,  Next: Numeric Modes,  Prev: Mode Structure,  Up: File permissions

27.2 シンボリックモード
================================

シンボリックモード ("Symbolic modes") では、ファイルのモードビットの
変更を、1 文字からなるシンボルに対する操作として表現している。
シンボリックモードを使えば、ファイルのモードビットのすべてを変更する
こともできるし、その一部を選択して変更することもできる。もしそうした
ければ、変更前のモードビットの値に基づいて変更することも可能だ。現在の
`umask' に基づいて変更することも、多分できるはずである (*note Umask and
Protection::)。

   シンボリックモードの書式は、次のとおりである。

     [ugoa...][+-=]PERMS...[,...]

ここで PERMS は `rwxXst' の内の 0 個以上の文字、または `ugo' の内の 1
個の文字である。

   以下のセクションでは、シンボリックモードについて、演算子 (operator)
を始め、様々なことを詳しく説明する。

* Menu:

* Setting Permissions::         許可属性の基本操作。
* Copying Permissions::         存在する許可属性をコピーする。
* Changing Special Mode Bits::  特殊モードビット。
* Conditional Executability::   条件付きで実行属性の変更をする。
* Multiple Changes::            複数の変更をする。
* Umask and Protection::        umask の効果。


File: coreutils-ja.info,  Node: Setting Permissions,  Next: Copying Permissions,  Up: Symbolic Modes

27.2.1 許可属性の設定
----------------------------

ファイルの許可属性に対するシンボルによる基本操作 (operation) は、
あるタイプのユーザに対して、ファイルの、読み、書き、実行または
検索を行うための許可属性を、追加したり、削除したり、設定したり
することである。そうした操作には、以下の書式を使用する。

     USERS OPERATION PERMISSIONS

上の書式では、三つの部分を空白で区切って示しているが、見やすくする
ためにすぎない。シンボリックモードの指定には空白があってはならない。

   USERS の部分は、どのタイプのユーザの、ファイルに対するアクセス権を
変更するかを示している。この部分には、1 個以上の下記の文字を指定する
(あるいは、何も指定しないでもよい。その場合どうなるかは、「Umask と
保険」セクションで説明している。 *note Umask and Protection::)。文字を
2 個以上指定した場合の順番に特別な意味はない。

`u'
     ファイルの所有者。

`g'
     ファイルの所有グループに属するファイルの所有者以外のユーザ。

`o'
     `u' や `g' 以外のすべてのユーザ。

`a'
     すべてのユーザ。`ugo' と同じ。

   OPERATION の部分は、対象となるユーザのファイルに対するアクセス権を
どんなふうに変更するかを指示しており、以下の記号の一つを使用する。

`+'
     USERS がそのファイルに対して、すでにどんな許可を持っているかに
     かかわりなく、それに PERMISSIONS を追加する。

`-'
     USERS がそのファイルに対して、すでにどんな許可を持っているかに
     かかわりなく、そこから PERMISSIONS を削除する。

`='
     PERMISSIONS を、そのファイルに対して USERS が持つ許可のすべてに
     する。

   PERMISSIONS の部分は、ファイルに対するどんなアクセス権を変更するか
を指示しており、通常は 0 個以上の下記の文字を指定する。USERS の部分と
同様、文字を 2 個以上指定した場合の順番に特別な意味はない。PERMISSIONS
の部分に何も指定しないことに意味があるのは、操作に `=' 演算子を使用する
場合だけである。その場合、指定されたユーザは、そのファイルに対して
いかなるアクセス権も持たないことになる。

`r'
     USERS の、そのファイルを読む権限。

`w'
     USERS の、そのファイルに書き込む権限。

`x'
     USERS の、そのファイルを実行する権限。ディレクトリの場合は、
     ディレクトリを検索する権限。

   たとえば、ある通常ファイルについて、すべてのユーザに読み書きを許可
するが、その実行は許可しないならば、次のように指定する。

     a=rw

   そのファイルの所有者以外のすべてのユーザから書き込み権限を取り上げる
には、次のようにする。

     go-w

上記の指定は、ファイルの所有者がファイルに対して持っているアクセス権には
影響を及ぼさない。また、所有者以外のユーザがそのファイルを読んだり、実行
したりできるかどうかにも、影響を及ぼさない。

   ファイルの所有者以外のすべてのユーザに対して、そのファイルに何をする
権限も一切与えないためには、以下のモードを使用すればよい。それでも、
所有者以外のユーザは、ファイルの存在するディレクトリに対する書き込み
権限を持っていれば、そのファイルを削除することができるだろうけれど。

     go=

同じことを指定する別のやり方もある。

     og-rwx


File: coreutils-ja.info,  Node: Copying Permissions,  Next: Changing Special Mode Bits,  Prev: Setting Permissions,  Up: Symbolic Modes

27.2.2 存在する許可属性のコピー
-------------------------------------------

ファイルの許可属性を、それが既に持っている許可属性を元にして指定する
こともできる。そうするには、演算子の後ろに `r', `w', `x' という文字を
続ける代わりに、`u', `g', `o' という文字を使用する。一例を挙げよう。

     o+g

上記のモード指定は、ファイルのグループに属するユーザのアクセス権を、
その他のユーザがそのファイルに対して持っているアクセス権に追加する。
従って、仮にファイルの最初のモードが 664 (`rw-rw-r--') ならば、上記の
モード指定は、それを 666 (`rw-rw-rw-') に変更することになる。ファイル
の最初のモードが 741 (`rwxr----x') だったら、745 (`rwxr--r-x') になる
だろう。`-' と `=' の演算子の働きも、同様である。


File: coreutils-ja.info,  Node: Changing Special Mode Bits,  Next: Conditional Executability,  Prev: Copying Permissions,  Up: Symbolic Modes

27.2.3 特殊モードビットの変更
----------------------------------------

読み込み、書き出し、実行/検索に関するファイルの許可属性を変更できるだけ
ではない。特殊モードビットも変更することができる。特殊モードビットに
ついては、「ファイルのモードビットの構成」の節で簡単に説明している。
*Note Mode Structure::.

   ファイルの実行時にユーザ ID をセットするように、ファイルのモード
ビットを変更するには、シンボリックモードの USERS の部分に `u' を使用し、
PERMISSIONS の部分に`s' を使用する。

   ファイルの実行時にグループ ID をセットするように、ファイルのモード
ビットを変更するには、シンボリックモードの USERS の部分に `g' を使用し、
PERMISSIONS の部分に `s' を使用する。

   ファイルの実行時にユーザ ID とグループ ID の両方をセットするように
するには、シンボリックモードの USERS の部分に何も指定せず (あるいは、
`a' を使用し)、 PERMISSIONS の部分に `s' を使用する。

   削除制限フラグやスティッキー・ビットが有効になるように、ファイルの
モードビットを変更するには、シンボリックモードの USERS の部分に何も
指定せず (あるいは、`a' を使用し)、PERMISSIONS の部分に `t' を使用する。

   たとえば、あるプログラムに set-user-ID モードビットを設定するには、
次のモードを指定すればよい。

     u+s

   そのプログラムから set-user-ID と set-group-ID の両方のモードビットを
削除するには、次のモードを指定する。

     a-s

   削除制限フラグやスティッキー・ビットを設定するには、次のモードを
指定する。

     +t

   `o+s' という組み合わせには、何の効果もない。GNU のシステムでは、
`u+t' や `g+t' という組み合わせにも、全く効果がなく、また `o+t' は、
単なる `+t' と同じ働きをする。

   特殊モードビットの設定や変更では、`=' はあまり役に立たない。
たとえば、こんな指定をしたとしよう。

     o=t

上記のモードは、確かに、削除制限フラグやスティッキー・ビットを設定
することはするが、同時に、ファイルのグループに属していないユーザが、
そのファイルに対して、読み、書き、実行/検索の権限を持っていたとしても、
そうした権限をすべて削除してしまう。

   set-user-ID や set-group-ID ビットがディレクトリに付いている場合の、
ほかの約束事については、「ディレクトリの Set-User-ID と Set-Group-ID
ビット」の節をご覧になっていただきたい。*Note Directory Setuid and
Setgid::.


File: coreutils-ja.info,  Node: Conditional Executability,  Next: Multiple Changes,  Prev: Changing Special Mode Bits,  Up: Symbolic Modes

27.2.4 条件付きの実行属性変更
----------------------------------------

シンボルによる許可属性の指定には、もう一つ特別なタイプがある。`x' の
代わりに、`X' を使用すると、実行/検索の許可属性に変更があるのは、
ファイルがディレクトリである場合か、あるいは、(どのユーザかに) すでに
実行許可が付いていた場合だけになる。

   一例を挙げよう。

     a+X

上記のモードは、すべてのユーザにディレクトリを検索する許可、または、
ファイルを実行する許可を与えるが、後者については、どのユーザかが、
すでにそのファイルを実行できたならば、という条件が付く。


File: coreutils-ja.info,  Node: Multiple Changes,  Next: Umask and Protection,  Prev: Conditional Executability,  Up: Symbolic Modes

27.2.5 複数の変更
----------------------

シンボリックモードの書式は、これまでに述べてきたよりも、実際にはもっと
複雑である (*note Setting Permissions::)。ファイルのモードビットに
対して、複数の変更を一度に行うには、二つの方法がある。

   一つ目の方法は、シンボリックモードの USERS の部分の後ろに、 複数の
OPERATION と PERMISSIONS を指定することである。

   たとえば、こんなふうにだ。

     og+rX-w

このモードは、ファイルの所有者以外のユーザに、読み込み許可を与え、さらに、
ファイルがディレクトリであるか、どのユーザかがすでに実行許可を持っていた
場合には、実行/検索許可も与えている。また、ファイルの所有者以外のユーザ
から、ファイルへの書き出し許可を取り上げている。なお、この指定は、ファイル
の所有者が持っている許可には影響を及ぼさない。このモードは、以下の二つの
モードと等価である。

     og+rX
     og-w

   複数の変更を行う二つ目の方法は、単純なシンボリックモードを 2 個以上、
コンマで区切って指定することである。たとえば、

     a+r,go-w

これは、すべてのユーザにそのファイルに対する読み込み許可を与え、
所有者以外のすべてのユーザから書き出し許可を削除している。もう一つ、
例を挙げる。

     u=rwx,g=rx,o=

こちらは、そのファイルに対するすべての許可ビットを明示的に設定して
いる。(ファイルのグループに属さないユーザには、ファイルに対する許可を
一切与えていない。)

   二つのモードを組み合わせて使うこともできる。

     a+r,g+x-w

この指定は、すべてのユーザにファイルの読み込み許可を与え、さらに、
ファイルのグループに属するユーザには、実行/検索許可も与えているが、
書き出し許可は与えていない。上記のモードを指定する方法は、ほかにも
いくつかあるだろう。その一つを挙げておく。

     u+r,g+rx,o+r,g-w


File: coreutils-ja.info,  Node: Umask and Protection,  Prev: Multiple Changes,  Up: Symbolic Modes

27.2.6 Umask と保険
----------------------

シンボリックモードの USERS の部分を省略すると、デフォルトの `a' が
使用される (すべてのユーザが対象になる)。が、この場合、システム変数
`umask' で設定されている許可属性は、全く影響を受けない (訳注: `umask'
で許可しないことになっている許可属性は、現在実際には許可になって
いようと、不許可であろうと、`-w' や `+w' といった USERS 部のない指定
では、変更されないということ。以下で例を挙げて説明している)。`umask'
の値は、`umask' コマンドで設定することができる。`umask' のデフォルト
の値は、システムによって様々である。

   シンボリックモードで USERS の部分を省略するのは、`+' 以外の操作では、
おおむね役に立たない。USERS の省略が `+' で役に立つのは、その場合、
意図した以上の許可をファイルに付けてしまわないための、簡単にカスタマイズ
できる保険として、`umask' が使用できるからである。

   一例を挙げると、`umask' の値が 2 ということは、ファイルの所有者でも
なく、ファイルのグループにも所属していない一般ユーザに、書き出し許可を
与えないということである。その場合、

     +w

というモードは、ファイルの所有者とファイルのグループに所属するユーザに、
書き出し許可を追加するが、それ以外のユーザには、書き出し許可を追加
しない。それに対して、

     a+w

というモードは、`umask' を無視して、ファイルへの書き出し許可を、文字通り
すべてのユーザに与えるのである。


File: coreutils-ja.info,  Node: Numeric Modes,  Next: Operator Numeric Modes,  Prev: Symbolic Modes,  Up: File permissions

27.3 数値モード
====================

シンボリックモードで指定する代わりに、モードを表す 1 個の 8 進数 (基数
8) を指定することもできる。この数値は常に 8 進数として解釈されるので、
C 言語の場合とは違って、先頭に `0' を付ける必要はない。`0055' という
モードは、`55' というモードと同じなのだ。(とは言え、`00055' のような、
5 桁以上のモードは、特別な扱いを受けることがある。*Note Directory
Setuid and Setgid::.)

   数値モードは、たいていの場合、対応するシンボリックモードより短くて
すむが、ファイルの変更前のモードビットを踏まえて指定することが、普通は
できないという制限がある。数値モードでは、絶対的な形で指定することしか
できないのだ。ディレクトリの set-user-ID ビットと set-group-ID ビット
は、この一般的な制限の対象外である。 *Note Directory Setuid and
Setgid::.  なお、演算子付き数値モードを使えば、ファイルの変更前のモード
ビットを踏まえた指定が可能である。 *Note Operator Numeric Modes::.

   ファイルの所有者、ファイルのグループに所属する他のユーザ、それ以外の
一般ユーザ、この 3 種のユーザに与える許可属性には、それぞれ 3 ビットを
要し、その 3 ビットは 1 個の 8 進数で表現される。三つの特殊モードビット
にも、おのおの 1 ビットが必要であり、こちらも一つにまとめて、もう一つの
8 進数として表現される。各ビットの並び方は、最下位のビットから上位の
ビットへ向かって、次のようになっている。

     モードの  対応する
     値        モードビット

               ファイルのグループに所属しない一般ユーザ:
        1      実行/検索
        2      書き出し
        4      読み込み

               ファイルのグループに所属する所有者以外のユーザ:
       10      実行/検索
       20      書き出し
       40      読み込み

               ファイルの所有者:
      100      実行/検索
      200      書き出し
      400      読み込み

               特殊モードビット:
     1000      削除制限フラグ、またはスティッキー・ビット
     2000      ファイルの実行時にグループ ID をセットする
     4000      ファイルの実行時にユーザ ID をセットする

   たとえば、数値モードの `4755' は、シンボリックモードの `u=rwxs,go=rx'
に当たり、数値モードの `664' は、シンボリックモードの `ug=rw,o=r' に相当
している。数値モードの `0' は、シンボリックモードの `a=' に相当する。


File: coreutils-ja.info,  Node: Operator Numeric Modes,  Next: Directory Setuid and Setgid,  Prev: Numeric Modes,  Up: File permissions

27.4 演算子付き数値モード
===================================

演算子付き数値モードは、`-', `+', `=' を前に付けた数値モードである。
そうした演算子が表している意味は、シンボリックモードの場合と同じだ。
たとえば、`+440' は、ファイルの所有者とグループに対する読み込み許可を
有効にし、`-1' は、その他の一般ユーザに対する実行許可を無効にする。
また、`=600' は、ファイルの所有者に対する読み込みと書き出しの許可を
有効にするが、それ以外のすべての許可を無効にする。演算子付き数値モード
は、数値モードと組み合わせて使うことができる。両者の間はコンマで区切れば
よい。一例を挙げると、`=0,u+r' は、ファイルの所有者の読み込み許可だけを
有効にし、それ以外のすべての許可を無効にする。

   コマンド  `chmod =755 DIR' と `chmod 755 DIR' の違いは、前者が
ディレクトリ DIR の setuid と setgid をクリアするのに対して、後者は
それをそのまま維持するという点にある。 *Note Directory Setuid and
Setgid::.

   演算子付き数値モードは、GNU による拡張である。


File: coreutils-ja.info,  Node: Directory Setuid and Setgid,  Prev: Operator Numeric Modes,  Up: File permissions

27.5 ディレクトリの Set-User-ID と Set-Group-ID ビット
=================================================================

ほとんどのシステムでは、ディレクトリに set-group-ID ビットが付いている
と、そのディレクトリ内で新しく作られるファイルは、ディレクトリと同じ
グループを継承し、新しく作られるサブディレクトリは、親ディレクトリの
set-group-ID ビットを継承する。また、若干のシステムでは、ディレクトリの
set-user-ID ビットが、ディレクトリ内の新規ファイルの所有者と、新規サブ
ディレクトリの set-user-ID ビットに対して、同様の効果を持っている。
こうした仕組みによって、新しいファイルを共有するために `chmod' や
`chown' を使う必要が軽減し、ユーザにとってファイルの共有がやりやすく
なっているのである。

   ユーザの便宜のためのこうした仕組みは、ディレクトリの set-user-ID
ビットや set-group-ID ビットを拠り所にしている。もし、`chmod' や
`mkdir' が、ディレクトリのそうしたビットを常時クリアする仕様になって
いたら、この仕組みはそれほど便利ではなく、ファイルの共有は面倒なこと
になるだろう。それ故、`chmod' などのコマンドは、原則としてディレクトリ
の set-user-ID ビットや set-group-ID ビットを変更しないのである。
set-user-ID ビットや set-group-ID ビットを変更するには、ユーザが
シンボリックモードで明示的にそう指定するか、`=755' のような演算子付き
数値モードを使用するか、数値モードでビットを立てるか、5 桁以上の 8 進数
からなる数値モードでビットをクリアするか、そのどれかをやる必要がある。
set-group-ID ビットの継承をサポートしているシステムでの例を挙げよう。

     # 以下のコマンドは、サブディレクトリの set-user-ID ビットと
     # set-group-ID ビットを変更しない。従って、デフォルトの値が
     # 保持される。
     mkdir A B C
     chmod 755 A
     chmod 0755 B
     chmod u=rwx,go=rx C
     mkdir -m 755 D
     mkdir -m 0755 E
     mkdir -m u=rwx,go=rx F

   サブディレクトリの set-user-ID ビットや set-group-ID ビットを設定
したかったら、シンボリックモードや数値モードで明示的に指定しなければ
ならない。たとえば、次のようにだ。

     # 以下のコマンドは、サブディレクトリに set-user-ID ビットと
     # set-group-ID bits を付けようとしている。
     mkdir G
     chmod 6755 G
     chmod +6000 G
     chmod u=rwx,go=rx,a+s G
     mkdir -m 6755 H
     mkdir -m +6000 I
     mkdir -m u=rwx,go=rx,a+s J

   サブディレクトリの set-user-ID ビットや set-group-ID ビットを
消去したかったら、シンボリックモードで明示的にそう指定するか、
演算子付き数値モードを使用するか、5 桁以上の 8 進数からなる数値
モードで指定するかしなければならない。

     # 以下のコマンドは、ディレクトリ D の set-user-ID ビットと
     # set-group-ID ビットをクリアしようとしている。
     chmod a-s D
     chmod -6000 D
     chmod =755 D
     chmod 00755 D

   こうした動作は、GNU による拡張である。移植を考慮したスクリプト
では、ディレクトリの set-user-ID ビットや set-group-ID ビットを
立てたり、クリアしたりするリクエストを当てにしない方がよい。POSIX
の規格で、そうしたリクエストを無視する実装が認められているからだ。
なお、GNU の許可属性指定における 4 桁以下の数値モードの動作は、
ディレクトリの set-user-ID ビットや set-group-ID ビットを維持する
システムで使うスクリプト向けであり、5 桁以上の数値モードの動作は、
そうしたビットを維持しないシステムでも使えるスクリプト向けである。

   (訳注: 4 桁以下と 5 桁以上の数値によるモード指定の違いについて
少し整理しておく。数値によるモード指定は、原則として絶対的な指定
である。たとえば、755 と指定すれば、755 に対応するモードビットだけ
が立てられ、それ以外のビットは 0 になる。ただし、ディレクトリの
set-user-ID ビットと set-group-ID ビットについてだけは、話がもう
少し複雑である。4 桁以下の数値による指定の場合、ディレクトリの
set-user-ID ビットや set-group-ID ビットを維持するシステムでは、
そうしたビットはデフォルトや現在の状態が引き継がれるのだから、
ディレクトリの set-user-ID ビットや set-group-ID ビットに対する
数値によるユーザの指定は、絶対的な指定にならない。デフォルト値や
現在値に対する追加にしかならないのである。当然のこととして、この
方法では消去もできない。それに対して、5 桁以上の数値による指定の
場合は、どんなシステムでも、すべてのモードビットについて、ユーザ
の指定は絶対指定になる。従って、こちらなら、ディレクトリの set-user-ID
ビットや set-group-ID ビットの選択的な設定や消去もできるのである。
もちろん、お使いの `chmod' のバージョンが、5 桁の数値指定をサポート
していればだが。)


File: coreutils-ja.info,  Node: Date input formats,  Next: Opening the software toolbox,  Prev: File permissions,  Up: Top

28 日付入力の書式
************************

まず、引用から始める。

     時間を計るための我々の単位は、秒から月にいたるまで、あまりにも
     複雑で、一貫性がなく、ばらばらなので、時間について間違わずに暗算
     をすることなど、ほとんど不可能なほどだ。まったくの話、どこかの
     横暴な神様が、人間の知能を時間の奴隷にしてやろうと企んだとしても
     -- 腐った決まりごとや不愉快な不意打ちに隷従せずに済ますことなど、
     人間にはほとんど不可能にしてやろうと企んだとしても -- 現在我々が
     使っているシステムをお下げ渡しになる以上のことは、できなかったに
     違いない。我々の時間計算のシステムは、垂直な面も水平な面もない
     台形の建築ブロックの集まりのようなものだ。あるいは、ほんの簡単な
     考えを述べるにも、凝りに凝った構成や、無駄な不変化詞や、長々しい
     婉曲表現が必要な言語のようなものだ。言語や科学のもっとうまく行って
     いる思考様式は、我々が経験に果敢に立ち向かうことを、少なくとも
     冷静に立ち向かうことを可能にしてくれる。ところが、そうしたものとは
     違って、我々の時間計算のシステムは、密かに、しかも執拗に時間に
     対する我々の恐怖をかきたてるのである。

     ... それは、建築家が長さをフィートで、幅をメートルで、高さをエルで
     測らなければならないようなものだ。あるいは、基本的な使用説明書を
     読むのに、五つの異なった言語の知識が必要なようなものだ。だから、
     我々が、自分にとってすぐ最近の過去や未来を表す、この前の火曜日
     (last Tuesday) とか、来週の日曜日 (a week from Sunday) とかいった
     表現について、それは一体いつを指しているのだろうと考え込んでは、
     どうしようもない混乱を覚えることがよくあるのも、無理からぬこと
     なのである。...

     -- Robert Grudin, `Time and the Art of Living'.

   この章では、GNU のプログラムが認識する日付表現文字列について説明
する。そうした文字列は、ユーザである読者が、様々なプログラムに引数
として渡すことのできるものだ。C のインターフェース (`parse_datetime'
関数で使用する) については、ここでは説明しない。

* Menu:

* General date syntax::      共通規則。
* Calendar date items::      暦日の項目 (19 Dec 1994)。
* Time of day items::        時刻の項目 (9:20pm)。
* Time zone items::          タイムゾーンの項目 (EST, PDT, GMT)。
* Combined date and time of day items::  暦日と時刻を組み合わせた項目
                                           (1972-09-24T20:02:00,000000-0500)。
* Day of week items::        曜日の項目 (Monday, Tuesday)。
* Relative items in date strings::  相対表現の項目
                                      (next tuesday, 2 years ago)。
* Pure numbers in date strings::    純粋な数値 (19931219, 1440)。
* Seconds since the Epoch::         紀元からの秒数 (@1078100502)。
* Specifying time zone rules::      タイムゾーン・ルールの指定
                                      (TZ="America/New_York", TZ="UTC0")。
* Authors of parse_datetime::       parse_datetime の作者 (Bellovin, Eggert,
                                      Salz, Berets, et al)。


File: coreutils-ja.info,  Node: General date syntax,  Next: Calendar date items,  Up: Date input formats

28.1 日付書式の全体
==========================

日付 ("date") は、空文字列のこともある文字列であり、空白 (whitespace)
で区切られた多くの項目を含んでいる。各項目の意味に曖昧さが生じないなら、
空白は省略できる。空の文字列は、今日の始まり (すなわち、真夜中) を意味
している。項目の順序は重要ではない。日付文字列では、様々な種類の項目を
指定することができる。

   * 暦日の項目

   * 時刻の項目

   * タイムゾーンの項目

   * 日付と時刻を組み合わせた項目

   * 曜日の項目

   * 相対表現の項目

   * 純粋な数値

個々の項目については、次節以下で順番に説明する。

   何番目かを示す序数の中には、現れる場所によっては、単語で表現できる
ものがいくつかある。これは、曜日や相対的表現の項目を指定するとき、
たいへん便利だ (下記参照)。使用頻度のきわめて高い序数を取り上げると、
`last' という単語は -1 を表し、`this' は 0 を、`first' と `next' は
両方とも 1 を表している。`second' という単語は時間の単位でもあるので、
序数の 2 を単語で表現する方法はない。だが、便宜を考えて、`third' は 3
を、`fourth' は 4 を、`fifth' は 5 を、`sixth' は 6 を、`seventh' は 7
を、`eighth' は 8 を、`ninth' は 9 を、`tenth' は 10 を、`eleventh' は
11 を、`twelfth' は 12 を表すことになっている。

   月がこの形で表現されたときも、やはり数値として (訳注: たとえば、今月
から何ヶ月後と) 指定されたと見なされるのであって、月の名前の省略なしの
表記と解釈されるわけではない (訳注: たとえば、third month を March の
別名の完全表記とは考えない)。そのため、March のような月名を使った場合
とは、指定できる文字列が違ってくる。

   現在の実装で使用できる単語は、英語の単語とその省略形のみである。
すなわち、`AM', `DST', `EST', `first', `January', `Sunday', `tomorrow',
`year' などだ。

   `date' コマンドの出力だからと言って、日付文字列としての条件を
必ずしも満たしているとはかぎらない。言語の問題のせいばかりではない。
`IST' のようなタイムゾーン項目には、標準的な意味が存在しないからでも
ある。`date' を使用して日付文字列を生成し、それに対して後で構文解析を
行うつもりなら、日付の書式には、言語が何であるかに依存せず、`UTC' と
`Z' 以外のタイムゾーン項目を使用しないものを指定するべきである。
それを行う方法をいくつか挙げておく。

     $ LC_ALL=C TZ=UTC0 date
     Mon Mar  1 00:21:42 UTC 2004
     $ TZ=UTC0 date +'%Y-%m-%d %H:%M:%SZ'
     2004-03-01 00:21:42Z
     $ date --rfc-3339=ns  # --rfc-3339 は GNU の拡張。
     2004-02-29 16:21:42.692722128-08:00
     $ date --rfc-2822  # GNU の拡張。
     Sun, 29 Feb 2004 16:21:42 -0800
     $ date +'%Y-%m-%d %H:%M:%S %z'  # %z は GNU の拡張。
     2004-02-29 16:21:42 -0800
     $ date +'@%s.%N'  # %s と %N も GNU の拡張。
     @1078100502.692722128

   日付を指定する際、アルファベットの大文字と小文字は全く区別されない。
丸カッコで囲めば、コメントを入れることができる。ただし、丸カッコを入れ子
にするときは、開きカッコと閉じカッコがきちんと対応していなければならない。
数字が後に続かないハイフンは、現在のところ無視される。また、数値の前に
付けた 0 も無視される。

   `2005-02-29' のような無効な日付や `24:00' のような無効な時刻は、
却下される。閏秒をサポートしていないホストでは、`23:59:60' のような
時刻は、たとえ閏秒に正しく対応する値であっても、却下されるのが普通である。


File: coreutils-ja.info,  Node: Calendar date items,  Next: Time of day items,  Prev: General date syntax,  Up: Date input formats

28.2 暦日の項目
====================

暦日の項目 ("calendar date item") では、ある年のある一日を指定する。
月を数字で指定するか、文字で指定するかにかによって、日付の指定法が変わって
くる。以下に挙げる文字列は、すべて暦の上の同じ日付を指定している。

     1972-09-24     # ISO 8601 形式。
     72-9-24        # 69 から 99 までは、19xx 年と見なし、
                    # 00 から 68 までは、20xx 年と見なす。
     72-09-24       # 先頭の 0 は無視される。
     9/24/72        # アメリカでよく使われる書き方。
     24 September 1972
     24 Sept 72     # September には、4 文字の省略形もある。
     24 Sep 72      # 3 文字の省略形は、何月に対しても使用できる。
     Sep 24, 1972
     24-sep-72
     24sep72

   年を省略することもできる。その場合は、日付文字列の後方で指定された
年が使用される (訳注: たとえば、`date -d "5/3 2:00 UTC 2015"' のような
場合だろう)。それもない場合は、今年が使われる。例を挙げると、次のような
形である。

     9/24
     sep 24

   要するに、ルールはこうだ。

   月を数字で表す場合、ISO 8601 の形式、すなわち `YEAR-MONTH-DAY' が
使用できる。ここで YEAR は任意の正の数であり、MONTH は 01 から 12
までの数、DAY は 01 から 31 までの数である。数が 10 未満のときは、 0
を前に付けることになる。YEAR が 68 以下の場合は、YEAR に2000 が加算
される。また、YEAR が 69 以上、100 未満ならば、1900 が加算される。
アメリカ合衆国で一般的な `MONTH/DAY/YEAR' という書式も使うことが
できる。年を省略した `MONTH/DAY' も有効である。

   月の名前を使用する場合は、フルスペルで書いてもよい。すなわち、
`January', `February', `March', `April', `May', `June', `July',
`August', `September', `October', `November', `December' である。月の
名前は、最初の 3 文字に省略することができる。省略の印のピリオドは、付け
ても付けなくてもよい。また、`September' の代わりに、`Sept' と書くことも
認められている。

   月名を使用する場合、暦の上の日付は、以下のどの形で指定してもよい。

     DAY MONTH YEAR
     DAY MONTH
     MONTH DAY YEAR
     DAY-MONTH-YEAR

   年を省略することもできる。

     MONTH DAY


File: coreutils-ja.info,  Node: Time of day items,  Next: Time zone items,  Prev: Calendar date items,  Up: Date input formats

28.3 時刻の項目
====================

日付文字列中の時刻の項目 ("time of day item") では、当日の時刻を指定
する。以下に挙げるいくつかの例は、すべて同じ時刻を表している。

     20:02:00.000000
     20:02
     8:02pm
     20:02-0500      # EST (U.S. Eastern Standard Time)

   もっと一般的に言うと、時刻は `HOUR:MINUTE:SECOND' の形で指定できる。
HOUR は 0 から 23 までの数であり、MINUTE は 0 から 59 までの数である。
SECOND は 0 から 59 までの数であり、`.' や `,' を後ろに付けて、一桁以上
の数字からなる小数を続けてもよい。なお、`:SECOND' は省略することもでき、
その場合は 0 を指定したことになる。閏秒をサポートするホストもまれには
あり、そうしたところでは SECOND に 60 を指定することができる。

   時刻に `am' や `pm' (または `a.m.' や `p.m.') が続く場合は、HOUR が
1 から 12 までになる。`:MINUTE' は省略してもよい (0 を指定したものと
見なされる)。`am' は一日の前半を示し、`pm' は一日の後半を示す。この
表記法では、1 の前が 12 になる。すなわち、真夜中は `12am' であり、正午
は `12pm' である。(これは `12am' や `12pm' の 12 を 0 のように見なす解釈
であり、正午を `12m'、深夜を `12pm' とするラテン文化から来た従来の習慣
とは逆になっている。)

   また、時刻にはタイムゾーン補正を続けてもよい。補正は `SHHMM' という
形で表現され、S は `+' または `-' 符号、HH は時間帯の時間差、MM は分差の
部分である。分差の部分 MM は指定しなくてもよく、その場合は、1 桁ないし
2 桁の補正は、時間差の指定と見なされる。なお、HH と MM の間をコロンで
区切ってもよい。タイムゾーン補正をこの方法で指定した場合、それが、それ
までに指定したいかなるタイムゾーンよりも、また、ローカル・タイムゾーン
よりも優先され、指定した時刻が、協定世界時 (UTC) よりも補正分進んでいる
(あるいは、遅れている) タイムゾーンの時刻として解釈されることになる。
一例を挙げると、`+0530' と `+05:30' は両方とも、UTC より 5.5 時間進んだ
タイムゾーンを表している (たとえば、インドである)。これは、タイムゾーン
補正を 1 時間以下の部分まで指定する最善の方法である。タイムゾーン補正の
最大値は、24 時間である。

   `am'/`pm' とタイムゾーン補正は、どちらか一方のみが指定できる。両方を
指定することはできない。


File: coreutils-ja.info,  Node: Time zone items,  Next: Combined date and time of day items,  Prev: Time of day items,  Up: Date input formats

28.4 タイムゾーンの項目
================================

タイムゾーン項目 ("time zone item") では、国際時間帯を指定する。これは
数個の文字によって表されるもので、たとえば、協定世界時 (Coordinated
Universal Time) なら `UTC' または `Z' である。省略の印のピリオドは、
すべて無視される。標準時のタイムゾーン (a non-daylight-saving time
zone) の後ろに、文字列 `DST' を独立した単語として (すなわち、空白、
タブなどを間に置いて) 続けると、対応する夏時間のタイムゾーンを指定
することができる。ちなみに、標準時のタイムゾーンの後ろに、タイムゾーン
補正を続けて、両方の値を加算することもできる。ただし、その指定法は、
通常 `UTC' に対してしか行われない。たとえば、`UTC+05:30' は `+05:30' と
同じことである。

   `UTC' と `Z' 以外のタイムゾーン項目は、時代遅れになりかかっている
ので、使用しない方がよい。理由は解釈が一定しないからであり、たとえば、
`EST' はオーストラリアとアメリカ合衆国で違った意味を持っている。タイム
ゾーン項目を使用するよりも、前節で述べた `-0500' のような、数値による
タイムゾーン補正を使った方が、曖昧さがないので、賢明である。

   タイムゾーン項目とタイムゾーン補正のどちらも指定されていない場合、
日付の解釈は、デフォルトのタイムゾーンのルールを用いて行われる (*note
Specifying time zone rules::)。


File: coreutils-ja.info,  Node: Combined date and time of day items,  Next: Day of week items,  Prev: Time zone items,  Up: Date input formats

28.5 暦日と時刻を組み合わせた項目
===============================================

日付と時刻を組み合わせた項目 ("combined date and time of day item")
では、ある年のある特定の一日の時刻を指定する。このタイプの項目が
必要になるのは、暦日の項目 (*note Calendar date items::) と 時刻の項目
(*note Time of day items::) をばらばらに指定したのでは、意味が曖昧に
なってしまう場合である。

     # ISO 8601 拡張日時書式
     1972-09-24T20:02:00,000000-0500

   ISO 8601 の拡張日時書式は、ISO 8601 形式の日付、`T' という区切り
文字、ISO 8601 形式の時刻という構成になっている。


File: coreutils-ja.info,  Node: Day of week items,  Next: Relative items in date strings,  Prev: Combined date and time of day items,  Up: Date input formats

28.6 曜日の項目
====================

曜日を明示的に指定すると、未来のその曜日にまで日付を前に進めることに
なる (これが行われるのは、その必要があるときだけである)。

   曜日は省略なしに書いてもよい。すなわち、`Sunday', `Monday',
`Tuesday', `Wednesday', `Thursday', `Friday', `Saturday' である。最初の
3 文字に短縮することもでき、その場合、省略の印のピリオドは付けても
付けなくてもよい。`Tuesday' には `Tues'、`Wednesday' には `Wednes'、
`Thursday' には `Thur' または `Thurs' という特殊な省略形もある。

   曜日項目の前に数値を付けてもよい。週がその分だけ前に進むことに
なる。これは、`third monday' のような表現で使うのが、一番よい。その
伝で、`last DAY' や `next DAY' という表現も許されている。それぞれ、
単独の DAY (曜日) が表すことになる日付より 1 週間前、または 1 週間後の
日付になる。

   (訳注: 上記のことが成り立つのは、DAY が今日の曜日のときだけである。
それ以外の場合は、DAY と `next DAY' は同じになる。)

   曜日項目の後ろにコンマがあっても、無視される。

   (訳注: 確かに `-d "Thu, 2013-03-07"' といった指定では、コンマが無視
されるが、`-d "next Thu,"' や `-d "3 Thu,"' といった指定では、"invalid
date" と言われ、エラーになる。)


File: coreutils-ja.info,  Node: Relative items in date strings,  Next: Pure numbers in date strings,  Prev: Day of week items,  Up: Date input formats

28.7 相対表現の項目
==========================

相対表現の項目 ("Relative items") は、日付を (指定しない場合は、現在の
日付を) 前後に移動させる。また、相対表現の項目の作用は、加算されていく。
相対表現の項目とは、次のようなものである。

     1 year
     1 year ago
     3 years
     2 days

   時間をどれくらい移動するかの単位は、文字列を使って選択する。まる
数年、あるいは、まる数ヶ月ずらすのなら、`year' や `month' という文字列
を使う。年も月も、曖昧な単位である。すべての年や月が、同じ長さをしている
わけではないからだ。もっと厳密な単位としては、`fortnight' (14 日間)、
`week' (7 日間)、`day' (24 時間)、`hour' (60 分間)、`minute' または
`min' (60 秒間)、`second' または `sec' (1 秒間) がある。こうした単位
には、複数語尾の `s' を付けてもよいが、付けても無視される。

   時間の単位の前に、何倍かを示す乗数を置くことができる。乗数には、 `+'
または `-' の符号を付けてもよい。符号なしの数値には、`+' の符号が
付いているものと見なされる。数値を指定しなければ、乗数に 1 を指定した
ことになる。相対表現の項目に `ago' を続けるのは、単位の前にマイナスの
乗数を置くのと同じことである。

   `tomorrow' という文字列は、1 日分未来ということである (`day' と
等しい)。`yesterday' は、1 日分過去ということだ (`day ago' と等しい)。

   `now' や `today' という文字列は、値 0 の時間移動に対応する相対表現の
項目である。値 0 の時間移動は、先行する項目によって別の日時に変更されて
いないかぎり、今現在の日時を表すということから、`now' (今) や `today'
(今日) という言い方ができるわけだ。こうしたものは、他の項目を強調する
ために、たとえば、`12:00 today' といった具合に使うこともできる。 `this'
という文字列にも、値 0 の時間移動という意味があるが、こちらは `this
thursday' のような日付文字列で使用される。

   相対表現の項目によって生成される日付が、標準時と夏時間の切り替えを
典型とするような、時刻調整の境界を越えたものになる場合、生成される日時
は適切に調整される。

   単位の曖昧さが、相対表現の項目では問題を起こすことがある。たとえば、
`2003-07-31 -1 month' は、2003-07-01 と評価されるかもしれない。
2003-06-31 が無効な日付だからだ。先月が何月かをもっと確実に引き出す
ためには、今月の 15 日よりも前に、先行する月を求めればよい。例を挙げる。

     $ date -R
     Thu, 31 Jul 2003 13:02:39 -0700
     $ date --date='-1 month' +'Last month was %B?'
     Last month was July?
     $ date --date="$(date +%Y-%m-15) -1 month" +'Last month was %B!'
     Last month was June!

   なお、標準時と夏時間の切り替えのような時刻変更があるときの前後で
日付の操作を行う場合には、注意した方がよい。24 時間も加算されたり、
減算されたりしてしまうことも、ないとは言えないからだ。そこで、
たいていの場合、日付の計算に取りかかる前に、環境変数 `TZ' を `UTC0'
に設定して、協定世界時を採用するのが賢明である。


File: coreutils-ja.info,  Node: Pure numbers in date strings,  Next: Seconds since the Epoch,  Prev: Relative items in date strings,  Up: Date input formats

28.8 日付文字列中の純粋な数値
=========================================

純粋な 10 進数をどう解釈するかは、日付文字列の文脈次第である。

   10 進数が YYYYMMDD の形をとり、日付文字列中のそれより前に他の暦日の
項目 (*note Calendar date items::) が存在しない場合は、YYYY は暦の上の
ある 1 日の年の部分と見なされる。MM は何番目の月かということ、DD は
その月の日にちである。

   10 進数が HHMM の形をとり、日付文字列中のそれより前に他の時刻の
項目が存在しない場合は、HH はある 1 日の時刻の何時の部分と、MM は
何分の部分と見なされる。MM を省略してもよい。

   日付文字列中で、ある数値の左側に暦の上の日にちとその日の時刻の両方が
存在し、相対表現の項目が存在しない場合は、その数値が今年の代わりに
使われる。

   (訳注: たとえば、`date -d "3/27 10:10 2012"' と指定すると、今年の
代わりに 2012 が使われるということらしい。`date -d "3/27/2001 10:10
2012"' は無効な日付になるし、`date -d "3/27 1010 2012"' は、1010 年 3
月 27 日 20:12:00 になる。)


File: coreutils-ja.info,  Node: Seconds since the Epoch,  Next: Specifying time zone rules,  Prev: Pure numbers in date strings,  Up: Date input formats

28.9 Unix 紀元 (the Epoch) からの秒数
============================================

`@' に数値を続けると、それは、秒数として、システム内部で使われるタイム
スタンプを表すことになる。数値には、小数点 (`.' または `,') が含まれて
いてもよい。内部表現がサポートしていない余分な精度は、マイナスの無限に
向けて切り詰められる。`@' で始まるこうした数値は、他の日付項目のいかなる
ものとも組み合わせて使うことができない。欠けるところのない完全なタイム
スタンプの指定だからである。

   コンピュータの内部では、時間は、ある紀元 (an epoch) -- きちんと定義
された時間中のある一点 -- からの秒数として表現されている。GNU や POSIX
のシステムでは、紀元は 1970-01-01 00:00:00 UTC である。従って、`@0' は
その時刻を表し、`@1' は 1970-01-01 00:00:01 UTC を表す、以下同様と
いうことになる。GNU を始め、POSIX に準拠したほとんどのシステムでは、
POSIX に対する拡張として、こうした時間表記をマイナスの秒数を使うことも
含めて、サポートしている。従って、`@-1' は 1969-12-31 23:59:59 UTC を
表すことになる。

   伝統的な Unix システムでは、秒を 32 ビットの 2 の補数である整数で
数えており、1901-12-13 20:45:52 から 2038-01-19 03:14:07 UTC まで
表すことができる。もっと新しいシステムでは、64 ビットの秒数計算を、
ナノセコンドのサブカウント付きで使用しており、宇宙の寿命として
知られている時間のうちのあらゆる時刻を 1 ナノセコンドの精密さで表す
ことができる。

   ほとんどのホストのこうした計算では、閏秒の存在が無視されている。
たとえば、ほとんどのホストで `@915148799' は 1998-12-31 23:59:59 UTC を
表し、`@915148800' は 1999-01-01 00:00:00 UTC を表している。従って、
間にある 1998-12-31 23:59:60 UTC という閏秒を表現する方法は存在しない。


File: coreutils-ja.info,  Node: Specifying time zone rules,  Next: Authors of parse_datetime,  Prev: Seconds since the Epoch,  Up: Date input formats

28.10 タイムゾーン・ルールの指定
=============================================

通常、日付の解釈は、現在のタイムゾーンのルールを使って行われる。そして、
その現在のタイムゾーンのルールを指定しているのは、環境変数 `TZ' か、
`TZ' が設定されていなければ、システムのデフォルト設定である。今、
ある一つの日付のみに別のタイムゾーンでデフォルトとして使われる一連の
ルールを適用したいとしよう。その場合は、日付を `TZ="RULE"' という文字列
で始めればよい。日付中では、対になった引用符 (`"') を必ず使わなければ
ならない。また、RULE 中に引用符やバックスラッシュがあるときは、それを
バックスラッシュでエスケープしなければならない。

   一例を挙げると、GNU の `date' コマンドを使って、「パリで 2004 年 10
月 31 日 午前 6 時 30 分のとき、ニューヨークでは何時か？」という質問に
答えることができる、以下で示すように、`TZ="Europe/Paris"'で始まる
日付を使うのである。

     $ export TZ="America/New_York"
     $ date --date='TZ="Europe/Paris" 2004-10-31 06:30'
     Sun Oct 31 01:30:00 EDT 2004

   この例では、`--date' のオペランドの最初の部分で、それ自身の `TZ' が
設定されている。そこで、このオペランドの残りの部分は、`Europe/Paris' の
ルールに従って処理され、`2004-10-31 06:30' という文字列が、パリの日時で
あるかのように扱われる。ところが、`date' コマンドの出力は、全体のタイム
ゾーンのルールに従って処理されるので、出力にはニューヨークの時刻が使用
されるのである。(2004 年には、パリは通常ニューヨークより 6 時間進んで
いた。しかし、この例は、時差が 5 時間だったハロウィーンの日のほんの短い
時間のことを言っている。)

   `TZ' の値はルールであり、ルールには通常、`tz' データベースの地域名が
付けられている (`http://www.twinsun.com/tz/tz-link.htm')。地域名の最新の
一覧は、TWiki Date and Time Gateway で見ることができる
(`http://twiki.org/cgi-bin/xtra/tzdate')。なお、GNU 以外のホストの中
には、`TZ' を設定するとき、`TZ=":America/New_York"' のように、地域名の
前にコロンを置く必要があるものもある。

   `tz' データベースには、`Arctic/Longyearbyen' から `Antarctica/South
_Pole' に至るまで、実にさまざまな地域が含まれている。それでも、目下
航海の最中でタイムゾーンが船特有のものである場合や、`tz' データベースに
対応していない non-GNU のホストを使用している場合は、`tz' データベース
の地域名で表されるルールの代わりに、POSIX 式のルールを使う必要がある
かもしれない。`UTC0' のような POSIX 式の単純なルールだと、夏時間なしの
タイムゾーン指定になるが、簡単な夏時間制度なら指定できる他のルールも
存在する。 *Note Specifying the Time Zone with `TZ': (libc)TZ Variable.


File: coreutils-ja.info,  Node: Authors of parse_datetime,  Prev: Specifying time zone rules,  Up: Date input formats

28.11 `parse_datetime' の作者
================================

`parse_datetime' は、`getdate' として誕生した。最初の実装を行ったのは、
Steven M. Bellovin (<smb@research.att.com>) であり、ノースカロライナ大学
チャペルヒル校に在学中のことだった。その後、Usenet 上で数人によって
機能が追加され、1990 年 8 月に Rich $alz (<rsalz@bbn.com>) と Jim Berets
(<jberets@bbn.com>) によって徹底的なオーバーホールがなされた。GNU シス
テムのための様々な改訂は、David MacKenzie, Jim Meyering, Paul Eggert
などによって行われた。ほぼ同様の機能を持つ Posix の `getdate' 関数との
衝突を避けるために `get_date' と名前を変えたのも、この改訂の一部であり、
さらに後に、`parse_datetime' と改名した。Posix の `getdate' 関数は、
`strptime' の使用によりロケール特有の日付の解析に優れているが、環境変数
や外部のファイルに依存しており、`parse_datetime' の持つスレッド安全性
(thread-safety) を欠いている。

   この章は、Franc,ois Pinard (<pinard@iro.umontreal.ca>) がソースコード
の `parse_datetime.y' を元にして最初に作成し、その後、K. Berry
(<kb@cs.umb.edu>) が増補改訂した。


File: coreutils-ja.info,  Node: Opening the software toolbox,  Next: About this translation,  Prev: Date input formats,  Up: Top

29 ソフトウェアの道具箱
*********************************

この章の初期のバージョンは、「GNU とは何か？ (`What's GNU?')」という
連載記事として `Linux Journal' 1994 年 6 月号に掲載された。執筆者は
Arnold Robbins である。
(`http://www.linuxjournal.com/article.php?sid=2762')

* Menu:

* Toolbox introduction::     はじめに
* I/O redirection::          I/O リダイレクション
* The who command::          `who' コマンド
* The cut command::          `cut' コマンド
* The sort command::         `sort' コマンド
* The uniq command::         `uniq' コマンド
* Putting the tools together::  工具を組み合わせる


File: coreutils-ja.info,  Node: Toolbox introduction,  Next: I/O redirection,  Up: Opening the software toolbox

はじめに
============

今月の記事と GNU プロジェクトの関係は、周辺的なものにすぎない。お手元の
GNU/Linux システムの GNU ツールをいくつか取り上げて、こんな使い方もあり
ますよ、と説明している点で、関係があるにすぎないのだ。今月の記事の真の
狙いは、プログラムを開発したり、使用したりする上での、「ソフトウェアは
工具だ」という考え方を説明することである。

   ソフトウェアは工具だという思想は、Unix が最初に設計され、開発された
ときの重要で不可欠な考え方だった (Linux も GNU も本質的には Unix の
クローンである)。残念なことに、最近ではインターネットや見栄えのよい GUI
の勢いに押されて、ソフトウェア工具論は流行らなくなっているようだ。
この思想は、様々な問題を解決するための強力な思考モデルを提供してくれる
のだから、まことに残念な話である。

   スイス・アーミーナイフをズボンのポケットに (または、小物入れに)
入れて、持ち歩いている人は多い。スイス・アーミーナイフは持っていると
重宝な道具だ。それには、何本かのナイフ、ねじ回し、ピンセット、つまようじ、
爪やすり、コルク抜き、他にもたぶん、いろいろ付いているだろう。日常の
ちょっとした雑用には、何にでも使える簡単な道具があれば済むのだから、
そうした用途にはまさにピッタリの道具である。

   しかしながら、熟練した大工は、スイス・アーミーナイフを使って家を建て
たりしない。彼は、その代わりに道具箱を持っていて、そこには用途別の工具
-- のこぎり、金槌、ねじ回し、鉋など -- がぎっしり詰まっている。しかも、
彼は一つ一つの工具について、いつどこで使えばよいかをきちんと心得ている。
ねじ回しの柄で釘を打ち込んだりすることは絶対にないのだ。

   ベル研究所にいた Unix の開発者たちは、プロのプログラマやコンピュー
タ・サイエンスの専門家ばかりだった。その彼らが、こういうことに気づいた
のだ。万能型のプログラムは、たった一つのプログラムを使えばよいので、
ユーザには受けがよいかもしれない。だが、いざ実際に作ってみると、そうした
プログラムは、

  a. 書くのが難しく、

  b. 保守やデバッグが難しく、

  c. 新しい状況に合わせて機能を拡張するのが難しい。

   むしろ彼らは、プログラムは用途別の工具であるべきだと痛感した。
要するに、個々のプログラムは、「一つの仕事をきちんとやってのければ
よい」。それ以上でもそれ以下でもない。そういったプログラムは、設計
するのも、コードを書くのも、修正するのも、ずっと簡単である --
たった一つのことしかしないからだ。

   それだけではない。適切な仕組みを使って、プログラムを組み合わせると、
全体が部分の総和以上になることにも、彼らは気づいた。ある用途専用の
プログラムをいくつか組み合わせると、どのプログラムもそのために作られた
のではない、ある特定の作業をやってのけることができる。それも、それ専用の
プログラムを書かなければならない場合よりも、はるかに迅速に、かつ簡単に
やってのけられるのだ。この記事の以下では、そうした使用法の (典型的な)
例をいくつか紹介する。(大事なことを一つ付記しておく。急がば回れだ。
必要になるかもしれないソフトウェア工具があれば、まずそれを作ること。
道具箱に適切な工具がまだない場合の話であるが。)


File: coreutils-ja.info,  Node: I/O redirection,  Next: The who command,  Prev: Toolbox introduction,  Up: Opening the software toolbox

I/O リダイレクション
============================

シェルの入出力リダイレクションについて、基本的なこと、とくに標準入力、
標準出力、標準エラーがどういうものかを、読者がよく御存じだとして、話を
進める。簡単に言うと、標準入力とは、データの入力元、すなわち、データが
そこからやって来る場所のことだ。データの入力元が、ディスク上のファイル
だろうと、キーボードだろうと、磁気テープだろうと、それどころかパンチ
カード・リーダーだろうと、プログラムはそれを知る必要もなければ、気に
かける必要もない。同様に、標準出力とは、データの溜まる場所、データが
そこに行く場所のことだ。プログラムとしては、それがどこになろうと、知ら
なくてもよく、気にかけなくてもよい。標準入力からデータを読み込み、それに
対して何らかの処理を行い、標準出力に送り出すだけのプログラムを、水道の
パイプラインのフィルターになぞらえて、「フィルター ("filter")」と呼ぶ。

   Unix のシェルでは、データのパイプラインを作るのはとてもやさしい。

     program_to_create_data | filter1 | ... | filterN > final.pretty.data

   ここでは、まず最初に生のデータを作成している。各フィルターがその
データに対して何らかの変形を次々に行い、最終的に、データが希望どおりの
形になって、パイプラインから抜け出してくる。

   標準入力と標準出力にとっては、それで充分だ。では、標準エラーはどこ
で登場し、どんな役割を果たすのだろうか？ 上記パイプラインの `filter1' に
ついて考えてほしい。データを読んでいるうちにエラーが起きたら、どうなる
だろうか？ `filter1' がエラーメッセージを標準出力に書き出したら、その
メッセージはパイプラインを下って `filter2' の入力に飲み込まれてしまう。
そうなると、ユーザはたぶんメッセージをまったく目にしないことになるだろう。
そこで、プログラムとしては、ユーザがエラーメッセージに気がついてくれる
ように、それを送ることのできる場所が必要になる。それが、標準エラー
なのであり、標準エラーは通常、現在使用しているコンソールやウィンドウ
に結びついている。プログラムの標準出力を使用中のスクリーン以外に
リダイレクトしている場合でも、それは変わらない。

   フィルター・プログラムが協力し合うためには、データのフォーマットに
ついて互いに合意している必要がある。最も素直で使いやすいフォーマットと
言えば、何と言っても、行分けされたテキストだ。そして、Unix のデータファ
イルは、たいていの場合、まさに、ASCII LF (Line Feed) 文字によって行分け
されたバイトの連続なのである。なお、この LF 文字は、Unix の文書では
「改行 (newline)」と呼ばれる習慣になっている (C のプログラマにとっては
`\n' だ)。これこそ、すべての伝統的なフィルター・プログラムによって使用
されて来たフォーマットである。(昔のオペレーティング・システムの多くは、
バイナリ・データを扱うための複雑な手段や専用のプログラムを備えていた。
だが、Unix は、ただ単にテキストエディタでデータを見たり編集できたり
する方がはるかに簡単だという考えから、そうした道具をずっと敬遠してきた
のである。)

   さて、前置きはこれくらいで充分だ。まず、道具のいくつかをざっと見て
みよう。その後で、そうした道具をおもしろいやり方で組み合わせる方法を
ご覧に入れる。以下の解説では、当面の問題に関係のあるコマンドライン・
オプションしか取り上げない。いつでもそうすべきことだが、コマンドについて
詳しいことを知りたかったら、ご使用のシステムの文書を参照なさるとよい。


File: coreutils-ja.info,  Node: The who command,  Next: The cut command,  Prev: I/O redirection,  Up: Opening the software toolbox

`who' コマンド
==================

最初に取り上げるプログラムは、`who' コマンドだ。これは単独で使うと、
現在ログインしているユーザのリストを生成する。筆者がこの原稿を書いて
いるのは、シングルユーザのシステムだが、数人のユーザがログインしている
ことにしよう。

     $ who
     -| arnold   console Jan 22 19:57
     -| miriam   ttyp0   Jan 23 14:19(:0.0)
     -| bill     ttyp1   Jan 21 09:32(:0.0)
     -| arnold   ttyp2   Jan 23 20:48(:0.0)

   ここで `$' はお馴染みのシェルプロンプトであり、筆者はそれに対して
`who' と打ち込んだわけだ。三人のユーザがログインしており、筆者は二度
ログインしている。伝統的な Unix のシステムでは、ユーザ名はアルファベット
8 文字までということになっている。このちょっとした豆知識が、後で役に
立つことになる。`who' の出力は悪くはない。だが、大しておもしろいデータ
でもない。


File: coreutils-ja.info,  Node: The cut command,  Next: The sort command,  Prev: The who command,  Up: Opening the software toolbox

`cut' コマンド
==================

次に注目するプログラムは `cut' コマンドだ。このコマンドは、入力された
データから縦の列 (columns) やフィールドを切り出す。そこで、`cut' に
命じて、`/etc/passwd' ファイルからログイン名とフルネームだけ表示させる
といったことができる。`/etc/passwd' には、七つのフィールドがあり、おの
おのコロンで区切られている。

     arnold:xyzzy:2076:10:Arnold D. Robbins:/home/arnold:/bin/bash

   1 番目と 5 番目のフィールドを取り出すには、次のように `cut' を使用
する。

     $ cut -d: -f1,5 /etc/passwd
     -| root:Operator
     ...
     -| arnold:Arnold D. Robbins
     -| miriam:Miriam A. Robbins
     ...

   `-c' オプションを付けると、 `cut' は入力行中の特定の文字 (すなわち、
特定の縦の列) を切り出す。これは、入力データが固定幅のフィールドを持ち、
フィールド・セパレータがないときに便利である。たとえば、今月の月曜日は、
何日と何日かをリストするには、次のようにする。

     $ cal | cut -c 3-5
     -| Mo
     -|
     -|  6
     -| 13
     -| 20
     -| 27


File: coreutils-ja.info,  Node: The sort command,  Next: The uniq command,  Prev: The cut command,  Up: Opening the software toolbox

`sort' コマンド
===================

次に `sort' コマンドを一瞥する。これは Unix 風のシステムにおける最も
強力なコマンドの一つであり、パイプを使って手の込んだデータ処理を行う
とき、気がつくと使っていることがよくあるものだ。

   `sort' コマンドは、コマンドラインで指名された各ファイルを読み込んで、
ソートする。その後で、ソートしたデータをマージし、それを標準出力に書き
出す。コマンドラインでファイルが指定されていない場合は、標準入力を読み
込む (こうして、フィルターになる)。ソートは、文字の照合順序、あるいは、
ユーザが順序について指定した基準に基づいて行われる。


File: coreutils-ja.info,  Node: The uniq command,  Next: Putting the tools together,  Prev: The sort command,  Up: Opening the software toolbox

`uniq' コマンド
===================

最後に目を向けるのは (少なくとも今のところはだが)、`uniq' プログラムだ。
データのソートをしていると、結果に重複行が現れることがよくある。内容が
全く同じ行だ。たいていの場合、各行は一つだけあればよい。そこで、`uniq'
の出番になる。`uniq' プログラムは、標準入力を読み込み、連続する同一行に
ついては、そのうちの一件だけを表示する。`uniq' には、オプションがいくつ
かある。後で `-c' オプションを使うことになるが、これはユニークな、つまり
重複しない各行を表示するとき、その行が入力中に現れた回数を前に付ける
ものである。


File: coreutils-ja.info,  Node: Putting the tools together,  Prev: The uniq command,  Up: Opening the software toolbox

工具 (tools) を組み合わせる
====================================

さて、大規模な ISP のサーバーシステムがあって、何十人ものユーザが
ログインしているとしよう。経営側がシステム管理者に、ログインしている
ユーザのソートしたリストを生成するプログラムを書くことを求めている。
しかも、あるユーザが多重ログインをしていても、その人の名前は出力に 1
回だけ現れればよいという条件がある。

   システム管理者は腰を据えてシステムのマニュアル類に取り組み、そうした
作業を実行する C のプログラムを書くこともできるだろう。そのためには、
たぶん数百行のコードが必要であり、プログラムを書いて、テストして、
デバッグするには、2 時間ぐらいかかるはずだ。それに対して、ソフトウェアの
道具箱に精通しているシステム管理者なら、C のプログラムを書く代わりに、
ログインしているユーザのリストを生成するところから始めることができる。

     $ who | cut -c1-8
     -| arnold
     -| miriam
     -| bill
     -| arnold

   次に、リストをソートする。

     $ who | cut -c1-8 | sort
     -| arnold
     -| arnold
     -| bill
     -| miriam

   最後に、ソートしたリストを `uniq' に渡して、重複を除く。

     $ who | cut -c1-8 | sort | uniq
     -| arnold
     -| bill
     -| miriam

   実を言うと、`sort' コマンドには `-u' というオプションがあって、`uniq'
がやることをやってくれる。しかし、`uniq' にはほかの働きもあり、そちらは
`sort -u' で代用することができない。

   システム管理者が、以下のように、このパイプラインをシェルスクリプトに
しておけば、システムのすべてのユーザが利用できるようになる (`#' は
システム管理者、すなわち `root' のプロンプトだ)。

     # cat > /usr/local/bin/listusers
     who | cut -c1-8 | sort | uniq
     ^D
     # chmod +x /usr/local/bin/listusers

   ここには、心に留めておくべき重要なことが四つある。まず第一に、1 行の
コマンドラインにたった四つのプログラムを書くことで、システム管理者は約
2 時間分の仕事をしないで済ますことができた。それだけではない。シェルの
パイプラインは、C のプログラムを使った場合と比べても、ほぼ同じくらい
効率がよく、プログラマの労働時間という点から見ると、ずっとずっと効率が
よい。人間の労働時間はコンピュータの時間よりはるかに高価であり、「何も
かもやるには、いつだって時間が足りない」現代社会では、プログラマの時間
を 2 時間も節約するのは、馬鹿にできない成果なのだ。

   二番目に、ツールを組み合わせることで、個々のプログラムの作者が想像も
しなかったような、ある特定の目的のための仕事をやってのけることができる。
これも、強調しておくべき重要なことである。

   第三に、ここでやって見せたように、段階を追ってパイプラインを構成する
のも有益な方法だ。そうすれば、パイプラインの段階ごとにデータを目で見る
ことができるので、ツール類を間違いなく適切に使っているという自信を得る
ことができる。

   最後に、実行したパイプラインをシェルスクリプトにまとめておけば、
他のユーザがそのコマンドを使うことができる。彼らのために作成した
手の込んだコマンドの配管工事を、彼らは憶える必要すらないのだ。どう
やって実行するかという点から見ると、シェルスクリプトもコンパイル
されたプログラムも見分けが付かないのである。

   ここまでは準備運動だ。続いて、もっと複雑なパイプラインをもう二つ
ご覧に入れよう。そのためには、工具をもう二つ紹介する必要がある。

   一つ目は `tr' コマンドだ。"transliterate (翻字する、字を置き換える)"
の意味である。 `tr' コマンドは、一字一字処理して行くというやり方で、
文字を置き換える。通常、このコマンドを使用するのは、大文字を小文字に
変換するといったことのためである。

     $ echo ThIs ExAmPlE HaS MIXED case! | tr '[:upper:]' '[:lower:]'
     -| this example has mixed case!

   役に立ちそうなオプションがいくつかある。

`-c'
     リストされた文字の補集合を動作対象にする。言い換えると、指定された
     集合に存在しない文字に対して操作が行われる。

`-d'
     一つ目の集合にある文字を出力から削除する。

`-s'
     出力中の連続する同一文字を、ただの 1 文字に圧縮する。

   すぐ後で、この三つのオプションをすべて使うことになる。

   紹介するもう一つのコマンドは、`comm' だ。`comm' コマンドは、二つの
ソートされた入力ファイルを入力データとして受け取り、両ファイルの各行を
三つの列に分けて表示する。出力される列は、一番目のファイルにのみ存在
する行、二番目のファイルにのみ存在する行、両方のファイルに存在する行の
順番である。`-1', `-2', `-3' というコマンドライン・オプションを
付けると、対応する列を表示しないようになる。 (これは直感的ではないので、
ちょっとした慣れが必要だ。) 例を挙げよう。

     $ cat f1
     -| 11111
     -| 22222
     -| 33333
     -| 44444
     $ cat f2
     -| 00000
     -| 22222
     -| 33333
     -| 55555
     $ comm f1 f2
     -|         00000
     -| 11111
     -|                 22222
     -|                 33333
     -| 44444
     -|         55555

   ファイル名を `-' にすると、`comm' は通常ファイルではなく、標準入力を
読み込む。

   これで、気の利いたパイプラインを組み立てる準備ができた。最初に作る
アプリケーションは、単語の出現頻度カウンターである。これは、ある特定の
単語を使いすぎていないかどうか、文書の作成者が判断するとき、役に立つ。

   最初のステップは、入力ファイル中のすべての文字を大文字か小文字の
どちらかに統一することである。"The" と "the" は、頻度計算にとって同じ
単語だ。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | ...

   次のステップは、句読点を除去することだ。引用符の付いている単語と
付いていない単語も同じものとして扱った方がよいだろう。それならば、
句読点類をすっぱり取り除いてしまうのが、一番簡単だ。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | tr -cd '[:alnum:]_ \n' | ...

   二番目の `tr' コマンドは、リストされた文字の補集合を操作対象にして
いる。すなわち、アルファベットのすべての文字、数字、アンダースコア、空白
以外を対象にするわけだ。`\n' は改行文字のことであり、これもそのまま残さ
なければならない。(市販のアプリで使うスクリプトなら、念のため ASCII タブ
文字も含めた方がよいだろう。)

   この時点で、空白 (訳注: 改行を含む) で区切られた単語からなるデータが
できていることになる。単語には、英数字 (それにアンダースコア) しか含まれ
ていない。次のステップは、データをバラして、1 行 1 単語になるようにする
ことだ。そうすれば、すぐ後で見るように、出現回数の計算がずっと楽になる。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | tr -cd '[:alnum:]_ \n' |
     > tr -s ' ' '\n' | ...

   このコマンドは、空白を改行に変える。`-s' オプションが付いているので、
出力中の連続する改行文字は、たった 1 個に圧縮される。これで、空行を
なくすことができるわけだ。(なお、2 行目行頭の `>' という記号は、シェル
の二次プロンプトである。シェルがユーザに、コマンドがまだ最後まで打ち
込まれていないと知らせるとき、これが表示される。)

   今や、1 行 1 単語からなるデータが手元にある。句読点は含まれず、すべて
小文字だ。これで、各単語の出現回数を数える準備が整った。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | tr -cd '[:alnum:]_ \n' |
     > tr -s ' ' '\n' | sort | uniq -c | ...

   この時点で、データはたぶんこんなふうになっているだろう。

          60 a
           2 able
           6 about
           1 above
           2 accomplish
           1 acquire
           1 actually
           2 additional

   なんと、出力が出現回数ではなく、単語によってソートされている！ こちら
としては、最も頻繁に使われる単語ほど先に表示したいのにだ。幸いなことに、
それは簡単に実現できる。`sort' のオプションをもう二つ使うだけでよい。

`-n'
     文字としてではなく、数値としてソートする。

`-r'
     逆順にソートする。

   最終的なパイプラインは次のようになる。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | tr -cd '[:alnum:]_ \n' |
     > tr -s ' ' '\n' | sort | uniq -c | sort -n -r
     -|    156 the
     -|     60 a
     -|     58 to
     -|     51 of
     -|     51 and
     ...

   ふう、憶えることがどっさり！ うん、でもね、同じ原則を応用してるだけ
なんだよ。たった 2 行、6 個のコマンドで (実際には、長い 1 行を便宜上 2
行に分割しているだけだが) 興味深く有用な作業をするプログラムが
出来上がった。それも、同じこことする C のプログラムを書くよりもずっと
短い時間でだ。

   上記のパイプラインをちょっといじるだけで、なんと、簡単なスペル
チェッカーが出来てしまう。ある単語の綴りが正しいかどうかを判断するには、
辞書で調べさえすればよい。その単語が辞書になければ、綴りを間違えている
可能性が高いわけだ。そこで、とりあえず、辞書が必要になる。辞書の在り処
は、慣例からすると `/usr/dict/words' だ。筆者の GNU/Linux システムでは
(1)、それはソートされた 45,402 語からなる辞書である。

   それでは、自分の作ったファイルをどうやって辞書と比べるのか？ 前の例と
同様、ソートした単語のリストを 1 行 1 語の形式で生成する。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | tr -cd '[:alnum:]_ \n' |
     > tr -s ' ' '\n' | sort -u | ...

   必要なのは、辞書にない単語のリストだけだ。そこで、`comm' の出番に
なる。

     $ tr '[:upper:]' '[:lower:]' < whats.gnu | tr -cd '[:alnum:]_ \n' |
     > tr -s ' ' '\n' | sort -u |
     > comm -23 - /usr/dict/words

   `-2' と `-3' のオプションを使うと、辞書 (2 番目のファイル) にしかない
行と、両方のファイルにある行が排除される。1 番目のファイル (標準入力、
すなわち、自分が使った単語のリストだ) にしかない行は、辞書に存在しない
単語だ。そうした単語は、綴りを間違えている可能性がかなり高いわけである。
ご覧に入れたこのパイプラインは、Unix における市販のスペルチェッカーに
対する最初の一太刀だったのである。

   他にも一言述べておくべきツールがいくつかある。

`grep'
     ファイルを調べて、正規表現にマッチするテキストを検索する。

`wc'
     行数、単語数、文字数を計算する。

`tee'
     データ・パイプのための T 字管。データをファイルと標準出力にコピー
     する。

`sed'
     ストリーム・エディタ。上級ツール。

`awk'
     データ処理用の言語。これも上級ツール。

   ソフトウェア工具論が取り入れたものに、次のちょっとしたアドバイスも
ある。「骨の折れる部分は、他の奴にやらせろ」。すなわち、ある道具を
選んで、必要なことの大部分をやらせ、それから、その結果に手を加えて、
こちらの望む形にする、ということである。

   要約しておこう。

  1. 個々のプログラムは、一つの仕事をきちんとやってのければよい。それ
     以上でもそれ以下でもない。

  2. プログラムを適切な配管工事で組み合わせると、全体が部分の総和以上に
     なる結果が生じる。作者が想像もしなかったようなプログラムの新しい
     使用法が見つかることもある。

  3. プログラムは決して余計なヘッダや追加情報を出力すべきではない。
     そうしたものもパイプラインの先へ送られてしまうかもしれないからだ。
     (これは、これまでに言及しなかったが、重要なことだ。)

  4. 骨の折れる部分は、他の奴にやらせろ。

  5. 自分の道具箱をよく知れ！ 個々のプログラムを適切に使え。適切なツール
     がなかったら、それを作れ。

   これを執筆している時点で、ここで取り上げたプログラムはすべてアノニ
マス `ftp' で次の場所から手に入れることができる (今では、もっと新しい
バージョンが利用できるかもしれない)。
`ftp://gnudist.gnu.org/textutils/textutils-1.22.tar.gz'
(訳注: 2014 年 3 月現在では、coreutils のサイトは次のものになっている。
`http://www.gnu.org/software/coreutils/')

   この記事で筆者が述べたことに、新しいことは何もない。ソフトウェアは
工具だという思想が最初に紹介されたのは、Brian Kernighan と P.J. Plauger
による `Software Tools' という本の中だった (Addison-Wesley, ISBN
0-201-03669-X)。ソフトウェア工具の書き方と使い方を教えるこの本は、1976
年に執筆され、`ratfor' (RATional FORtran) という名前の FORTRAN のプリ
プロセッサを使用している。その当時、C は今ほどありふれてはいず、FORTRAN
がそうだったのだ。最後の章では、`ratfor' を FORTRAN に変換するプロセッサ
を `ratfor' で書いて見せている。`ratfor' は C にとてもよく似ているので、
C を御存じの方なら、コードを追うのに何の苦労もないことだろう。

   1981 年に本は改訂され、`Software Tools in Pascal' という形でも手に
入るようになった (Addison-Wesley, ISBN 0-201-10342-7)。どちらの本も
現在でも入手可能であり、プログラマなら、一読の価値が十分にある。この 2
冊の本が筆者のプログラミングに対する見方を大きく変えてくれたことに、
疑いの余地はない。

   両方の本にあるプログラムは、Brian Kernighan のホームページから手に
入れることができる (`http://cm.bell-labs.com/who/bwk')。Software Tools
Users Group という活動的なグループが長年に渡って存在し、そのメンバーが
オリジナルの `ratfor' プログラムを、FORTRAN コンパイラを持っている
ほとんどすべてのコンピュータ・システムに移植していた。だが、1980 年代の
中頃に Unix が大学を越えて浸透し出すにつれて、グループの人気は衰えて
行った。

   現在では GNU のコードをはじめ、Unix クローンのプログラムがどんどん
作られており、上記のプログラムはほとんど関心を持たれていない。それに、
現代の C のバージョンの方がはるかに効率がよく、できることも上記の
プログラムよりずっと多くなっている。それでも、よいプログラミング・
スタイルのお手本として、また、今でも価値がある考え方を熱心に説いている
点において、この 2 冊の本は肩を並べるものがない。筆者としては、大いに
お薦めする次第だ。

   謝辞: ソフトウェア工具の最初の道具鍛冶である、Bell 研究所の Brian
Kernighan 氏に、この記事を読んでチェックしてくださったことについて、
心からお礼を申し上げる。

   ---------- Footnotes ----------

   (1) この記事を 2000 年 11 月に改訂したとき使用したのは、Redhat Linux
6.1 である


File: coreutils-ja.info,  Node: About this translation,  Next: GNU Free Documentation License,  Prev: Opening the software toolbox,  Up: Top

Appendix A 翻訳について
*****************************

この文書は、GNU core utilities version 8.20 の info マニュアルの
翻訳である。

   まず最初に、coreutils の日本語版 info マニュアルの呼び出し方を簡単に
説明する。coreutils の 日本語版 info が install-info コマンドを使って
きちんとシステムにインストールされているならば、コマンドラインから
`info coreutils-ja' で日本語マニュアル全体を、`info chmod-ja' などで
個々のプログラムの日本語マニュアルを呼び出すことができる。英語版を
読むときは、今までどおり `info coreutils' や `info chmod' とすればよい。
個々のコマンドについては、英語版なら `info coreutils 'cp invocation''、
日本語版なら `info coreutils-ja 'cp invocation'' といったマニュアルの
呼び出し方もある。

   また、`info' を引数なしで実行すると、info マニュアルのトップレベルの
メニューが開く。ここで、メニュー項目にカーソルを合わせて、リターンキーを
押せば、その項目に飛ぶわけだが、読みたい項目をキー操作で指定する場合は、
`m' を押した後 `chmod-ja' と打ち込んで、リターンキーを押せば、日本語版
マニュアルが、`chmod' だけなら英語版マニュアルが表示される。

   `coreutils-ja'、`chmod-ja' などと `-ja' を付けるのは、`info'
プログラムを起動するときと、info のトップレベル・メニューにいるとき
だけである。すでに日本語版 coreutils マニュアルのどれかを (それが
coreutils-ja であれ、dd-ja であれ) `info' コマンドで開いている場合は、
`-ja' を後ろに付ける必要がなくなる。と言うより、付けてはいけない。
coreutils-ja の先頭ページのようにコマンドのメニューが存在するページ
では (実際には、スクロールしないと、メニューが見えないが)、たとえば、
`m' に続けて `chmod' と打ち込み、リターンキーを押すだけで、chmod の
日本語の説明が開く。また、日本語 coreutils マニュアルの任意のページ
から coreutils-ja の他のノードへ直接飛ぶ場合も (ノードは、ほぼ章や節に
相当する)、`g' キーを押してから、`chmod invocation' などとノード名を
打ち込み、リターンキーを押せばよい。`m' の場合はタブやスペースで、 `g'
の場合はタブで、文字列の補完ができる。(たぶん coreutils-ja.info の
パッケージには、README.ja というファイルが含まれていると思う。その
「2.1 日本語 info マニュアルの呼び出し方」という節にもう少し詳しい
説明を書いておいたので、ご覧になっていただきたい。)

   ここで、日本語の info マニュアルを使用するときの問題点を挙げておく。

  1. `info' コマンドは、日本語の行末表示が上手ではない。そのため、
     行末に余計な文字が入ることがある。そうしたときは、`C-l' を押して
     (Ctrl と l (エル) キーを同時に押す)、画面の再描画を行っていただき
     たい。表示が正常になるはずである。Emacs の info リーダーでは、この
     問題はたぶん起きない。

  2. 現在のところ、`info' コマンドでは、`s' や `/' で日本語の単語を検索
     できないようだ。`C-s' による日本語の検索は、単語によっては成功する
     こともあるが、"Unknown command" で失敗することもあり、これもあまり
     頼りにならない。それに対して、Emacs の info リーダーでは、`s' でも
     `C-s' でも日本語の検索ができる。

  3. coreutils の info のこの翻訳では、インデックスの日本語化まで手が
     回らなかった。そのため、インデックスは英語のままである。

  4. 古めの Emacs でこの翻訳を読もうとすると、文字化けするかもしれない。
     回避法があるのかもしれないが、訳者にはわからなかった。

   このマニュアルは、coreutils-8.20 所収の texinfo マニュアルを元に、
Linux JM project のために訳者が新たに翻訳したものである。ptx, tsort,
chcon, runcon の 4 件は未訳である。間違いの指摘や改良の提案は Linux JM
project (<linuxjm-discuss@lists.sourceforge.jp>) 宛にメールでなさって
いただきたい。

   この info マニュアルの原文は、本文の「序」でも述べているように、
各プログラムの man ページを統合し、増補・改訂したものである。この info
マニュアルがまとめられるにともない、公式の man ページの方はコマンドの
`--help' オプションで見ることができるものとほぼ同文の、簡単な内容の
ものになった。

   従来どおりの詳しい man ページを希望する人たちも存在した。そのために
作られたのが、gnumaniak の man ページであり、従来の man ページを info
の情報で増補したものだったが、現在では保守されていないようだ。

   作成の経緯がそうしたものなので、この info マニュアルの原文には、
gnumaniak の man ページの原文とほとんど内容が同じものがある。今回の
翻訳作業に当たっては、すべての項目について gnumaniak の man ページの
翻訳を参考にした。あちらの訳文の方がよくできている項目もある。

   この翻訳は、gnumaniak の翻訳に多くを負っている。そこで、まず、
gnumaniak の翻訳者の方々 -- 中野武雄、佐藤裕一、白方健太郎、Kazuyuki
Tanisako、Omo Kazuki の諸氏にお礼を申し上げる。

   訳文を見直す際には、西尾太さんが以前翻訳なさった coreutils-5.2.1 の
info を参考にした。また、当然ながら、現在の man ページ (こちらの
翻訳者は、たぶん Yasuaki Taniguchi さんと Akihiro MOTOKI さん) とも、
できるだけ突き合わせた。西尾さん、Taniguchi さん、元木さんにもお礼を
申し上げる。

   gnumaniak や coreutils の man や info の翻訳をなさった方で、私が
お名前を挙げ忘れた方がいらっしゃるかもしれない。お知らせくだされば、
追加訂正する。

   訳文には間違った箇所も多々あると思う。そのへんは、ご寛恕いただき
たい。皆さんがこの訳文を叩き台にして、増補・改訂・改訳を続け、より
新しく、よりわかりやすい、そして、より正確な coreutils の翻訳を作って
くだされば、最初の翻訳者としてそれにまさる喜びはない。

   2014-03-15 訳者

   [翻訳履歴]

   * 2014-03-15
     coreutils-8.20 を翻訳 -- by 長南洋一
     ptx, tsort, chcon, runcon は未訳


File: coreutils-ja.info,  Node: GNU Free Documentation License,  Next: Concept index,  Prev: About this translation,  Up: Top

Appendix B GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     `http://fsf.org/'

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly
     and finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from
     you under this License.  If your rights have been terminated and
     not permanently reinstated, receipt of a copy of some or all of
     the same material does not give you any rights to use it.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.  If the Document specifies that a proxy
     can decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

 11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: coreutils-ja.info,  Node: Concept index,  Prev: GNU Free Documentation License,  Up: Top

Index
*****

 [index ]
* Menu:

* !:                                     Connectives for test.
                                                              (line   9)
* !=:                                    String tests.        (line  28)
* %:                                     Numeric expressions. (line  15)
* %b:                                    printf invocation.   (line  42)
* &:                                     Relations for expr.  (line  17)
* *:                                     Numeric expressions. (line  15)
* + <1>:                                 Numeric expressions. (line  11)
* +:                                     String expressions.  (line  52)
* +PAGE_RANGE:                           pr invocation.       (line  64)
* - <1>:                                 env invocation.      (line 101)
* -:                                     Numeric expressions. (line  11)
* - and Unix rm:                         rm invocation.       (line 123)
* -, removing files beginning with:      rm invocation.       (line 110)
* --:                                    Common options.      (line  46)
* --across:                              pr invocation.       (line  90)
* --additional-suffix:                   split invocation.    (line 137)
* --address-radix:                       od invocation.       (line  44)
* --adjustment:                          nice invocation.     (line  53)
* --all <1>:                             uname invocation.    (line  38)
* --all <2>:                             nproc invocation.    (line  20)
* --all <3>:                             who invocation.      (line  37)
* --all <4>:                             stty invocation.     (line  29)
* --all <5>:                             du invocation.       (line  28)
* --all <6>:                             df invocation.       (line  37)
* --all <7>:                             Which files are listed.
                                                              (line  14)
* --all:                                 unexpand invocation. (line  52)
* --all-repeated:                        uniq invocation.     (line  73)
* --almost-all:                          Which files are listed.
                                                              (line  19)
* --apparent-size:                       du invocation.       (line  31)
* --append:                              tee invocation.      (line  27)
* --archive:                             cp invocation.       (line  74)
* --attributes-only:                     cp invocation.       (line  83)
* --author:                              What information is listed.
                                                              (line  10)
* --backup <1>:                          ln invocation.       (line  96)
* --backup <2>:                          mv invocation.       (line  67)
* --backup <3>:                          install invocation.  (line  46)
* --backup <4>:                          cp invocation.       (line  90)
* --backup:                              Backup options.      (line  14)
* --batch-size:                          sort invocation.     (line 287)
* --before:                              tac invocation.      (line  23)
* --binary:                              md5sum invocation.   (line  43)
* --block-size <1>:                      du invocation.       (line  53)
* --block-size <2>:                      df invocation.       (line  44)
* --block-size:                          Block size.          (line 150)
* --block-size=SIZE:                     Block size.          (line  12)
* --body-numbering:                      nl invocation.       (line  49)
* --boot:                                who invocation.      (line  41)
* --bourne-shell:                        dircolors invocation.
                                                              (line  36)
* --buffer-size:                         sort invocation.     (line 349)
* --bytes <1>:                           du invocation.       (line  49)
* --bytes <2>:                           cut invocation.      (line  31)
* --bytes <3>:                           wc invocation.       (line  47)
* --bytes <4>:                           split invocation.    (line  47)
* --bytes <5>:                           tail invocation.     (line  35)
* --bytes <6>:                           head invocation.     (line  26)
* --bytes:                               fold invocation.     (line  26)
* --c-shell:                             dircolors invocation.
                                                              (line  43)
* --canonicalize:                        readlink invocation. (line  28)
* --canonicalize-existing <1>:           realpath invocation. (line  20)
* --canonicalize-existing:               readlink invocation. (line  35)
* --canonicalize-missing <1>:            realpath invocation. (line  28)
* --canonicalize-missing:                readlink invocation. (line  42)
* --changes <1>:                         chmod invocation.    (line  44)
* --changes <2>:                         chgrp invocation.    (line  23)
* --changes:                             chown invocation.    (line  74)
* --characters:                          cut invocation.      (line  39)
* --chars:                               wc invocation.       (line  51)
* --check:                               sort invocation.     (line  23)
* --check-chars:                         uniq invocation.     (line 112)
* --classify:                            General output formatting.
                                                              (line  55)
* --color:                               General output formatting.
                                                              (line  22)
* --columns:                             pr invocation.       (line  75)
* --compare:                             install invocation.  (line  51)
* --complement:                          cut invocation.      (line  89)
* --compute:                             runcon invocation.   (line  27)
* --context <1>:                         id invocation.       (line  49)
* --context <2>:                         mknod invocation.    (line  63)
* --context <3>:                         mkfifo invocation.   (line  32)
* --context <4>:                         mkdir invocation.    (line  58)
* --context <5>:                         install invocation.  (line 146)
* --context:                             What information is listed.
                                                              (line 281)
* --count <1>:                           who invocation.      (line  72)
* --count:                               uniq invocation.     (line  59)
* --count-links:                         du invocation.       (line 103)
* --crown-margin:                        fmt invocation.      (line  38)
* --csh:                                 dircolors invocation.
                                                              (line  43)
* --date <1>:                            Options for date.    (line  11)
* --date:                                touch invocation.    (line  97)
* --dead:                                who invocation.      (line  45)
* --decode:                              base64 invocation.   (line  33)
* --delimiter:                           cut invocation.      (line  69)
* --delimiters:                          paste invocation.    (line  44)
* --dereference <1>:                     stat invocation.     (line  26)
* --dereference <2>:                     du invocation.       (line 108)
* --dereference <3>:                     chgrp invocation.    (line  33)
* --dereference <4>:                     chown invocation.    (line 110)
* --dereference <5>:                     cp invocation.       (line 169)
* --dereference:                         Which files are listed.
                                                              (line  90)
* --dereference-args:                    du invocation.       (line  65)
* --dereference-command-line:            Which files are listed.
                                                              (line  39)
* --dereference-command-line-symlink-to-dir: Which files are listed.
                                                              (line  43)
* --dictionary-order:                    sort invocation.     (line 100)
* --digits:                              csplit invocation.   (line  85)
* --dir:                                 rm invocation.       (line  39)
* --directory <1>:                       mktemp invocation.   (line  95)
* --directory <2>:                       ln invocation.       (line 102)
* --directory <3>:                       install invocation.  (line  69)
* --directory:                           Which files are listed.
                                                              (line  30)
* --dired:                               What information is listed.
                                                              (line  17)
* --double-space:                        pr invocation.       (line 103)
* --dry-run:                             mktemp invocation.   (line 107)
* --echo:                                shuf invocation.     (line  21)
* --elide-empty-files <1>:               csplit invocation.   (line  94)
* --elide-empty-files:                   split invocation.    (line 142)
* --error:                               stdbuf invocation.   (line  36)
* --escape:                              Formatting the file names.
                                                              (line  11)
* --exact:                               shred invocation.    (line 149)
* --exclude-from=FILE:                   du invocation.       (line 226)
* --exclude-type:                        df invocation.       (line 162)
* --exclude=PATTERN:                     du invocation.       (line 220)
* --expand-tabs:                         pr invocation.       (line 127)
* --field-separator:                     sort invocation.     (line 366)
* --fields:                              cut invocation.      (line  48)
* --file <1>:                            Options for date.    (line  26)
* --file:                                stty invocation.     (line  34)
* --file-system:                         stat invocation.     (line  33)
* --file-type:                           General output formatting.
                                                              (line  67)
* --files0-from=FILE <1>:                du invocation.       (line  71)
* --files0-from=FILE <2>:                sort invocation.     (line 244)
* --files0-from=FILE:                    wc invocation.       (line  66)
* --filter:                              split invocation.    (line  67)
* --first-line-number:                   pr invocation.       (line 205)
* --follow:                              tail invocation.     (line  51)
* --footer-numbering:                    nl invocation.       (line  77)
* --force <1>:                           ln invocation.       (line 108)
* --force <2>:                           shred invocation.    (line 114)
* --force <3>:                           rm invocation.       (line  43)
* --force <4>:                           mv invocation.       (line  72)
* --force:                               cp invocation.       (line 132)
* --foreground:                          timeout invocation.  (line  20)
* --form-feed:                           pr invocation.       (line 135)
* --format <1>:                          General output formatting.
                                                              (line  10)
* --format <2>:                          What information is listed.
                                                              (line 138)
* --format:                              od invocation.       (line  93)
* --format=FORMAT <1>:                   seq invocation.      (line  26)
* --format=FORMAT:                       stat invocation.     (line  39)
* --from:                                chown invocation.    (line  84)
* --full-time:                           What information is listed.
                                                              (line 107)
* --general-numeric-sort:                sort invocation.     (line 123)
* --goal:                                fmt invocation.      (line  68)
* --group <1>:                           id invocation.       (line  27)
* --group:                               install invocation.  (line  76)
* --group-directories-first:             Which files are listed.
                                                              (line  53)
* --groups <1>:                          chroot invocation.   (line  34)
* --groups:                              id invocation.       (line  31)
* --hardware-platform:                   uname invocation.    (line  43)
* --head-count:                          shuf invocation.     (line  34)
* --header <1>:                          join invocation.     (line 101)
* --header:                              pr invocation.       (line 141)
* --header-numbering:                    nl invocation.       (line  81)
* --heading:                             who invocation.      (line  49)
* --help:                                Common options.      (line  40)
* --hide-control-chars:                  Formatting the file names.
                                                              (line  24)
* --hide=PATTERN:                        Which files are listed.
                                                              (line  61)
* --human-numeric-sort:                  sort invocation.     (line 146)
* --human-readable <1>:                  du invocation.       (line  87)
* --human-readable <2>:                  df invocation.       (line  56)
* --human-readable <3>:                  What information is listed.
                                                              (line 122)
* --human-readable:                      Block size.          (line 150)
* --ignore:                              nproc invocation.    (line  26)
* --ignore-backups:                      Which files are listed.
                                                              (line  25)
* --ignore-case <1>:                     join invocation.     (line 110)
* --ignore-case <2>:                     uniq invocation.     (line  63)
* --ignore-case:                         sort invocation.     (line 107)
* --ignore-environment:                  env invocation.      (line 101)
* --ignore-fail-on-non-empty:            rmdir invocation.    (line  19)
* --ignore-garbage:                      base64 invocation.   (line  40)
* --ignore-interrupts:                   tee invocation.      (line  32)
* --ignore-leading-blanks:               sort invocation.     (line  91)
* --ignore-nonprinting:                  sort invocation.     (line 162)
* --ignore=PATTERN:                      Which files are listed.
                                                              (line  75)
* --indent:                              pr invocation.       (line 210)
* --indicator-style:                     General output formatting.
                                                              (line  55)
* --initial:                             expand invocation.   (line  37)
* --inode:                               What information is listed.
                                                              (line 130)
* --inodes:                              df invocation.       (line  67)
* --input:                               stdbuf invocation.   (line  28)
* --input-range:                         shuf invocation.     (line  25)
* --interactive <1>:                     ln invocation.       (line 113)
* --interactive <2>:                     rm invocation.       (line  60)
* --interactive <3>:                     mv invocation.       (line  78)
* --interactive:                         cp invocation.       (line 157)
* --io-blocks:                           truncate invocation. (line  29)
* --iso-8601[=TIMESPEC]:                 Options for date.    (line  34)
* --iterations=NUMBER:                   shred invocation.    (line 119)
* --join-blank-lines:                    nl invocation.       (line  89)
* --join-lines:                          pr invocation.       (line 154)
* --keep-files:                          csplit invocation.   (line  90)
* --kernel-name:                         uname invocation.    (line  74)
* --kernel-release:                      uname invocation.    (line  70)
* --kernel-version:                      uname invocation.    (line  85)
* --key:                                 sort invocation.     (line 260)
* --kibibytes:                           General output formatting.
                                                              (line  93)
* --kill-after:                          timeout invocation.  (line  37)
* --length:                              pr invocation.       (line 164)
* --line-bytes:                          split invocation.    (line  61)
* --line-increment:                      nl invocation.       (line  85)
* --lines <1>:                           wc invocation.       (line  59)
* --lines <2>:                           split invocation.    (line  39)
* --lines <3>:                           tail invocation.     (line 170)
* --lines:                               head invocation.     (line  42)
* --link:                                cp invocation.       (line 164)
* --literal:                             Formatting the file names.
                                                              (line  18)
* --local:                               df invocation.       (line  79)
* --logical <1>:                         pwd invocation.      (line  17)
* --logical <2>:                         realpath invocation. (line  33)
* --logical:                             ln invocation.       (line 118)
* --login:                               who invocation.      (line  53)
* --lookup:                              who invocation.      (line  57)
* --machine:                             uname invocation.    (line  50)
* --max-depth=DEPTH:                     du invocation.       (line 124)
* --max-line-length:                     wc invocation.       (line  63)
* --max-unchanged-stats:                 tail invocation.     (line 158)
* --merge <1>:                           sort invocation.     (line  39)
* --merge:                               pr invocation.       (line 170)
* --mesg:                                who invocation.      (line  97)
* --message:                             who invocation.      (line  97)
* --mode <1>:                            mknod invocation.    (line  56)
* --mode <2>:                            mkfifo invocation.   (line  24)
* --mode <3>:                            mkdir invocation.    (line  22)
* --mode:                                install invocation.  (line  82)
* --month-sort:                          sort invocation.     (line 170)
* --multiple:                            basename invocation. (line  35)
* --name:                                id invocation.       (line  35)
* --no-clobber <1>:                      mv invocation.       (line  85)
* --no-clobber:                          cp invocation.       (line 177)
* --no-create <1>:                       truncate invocation. (line  25)
* --no-create:                           touch invocation.    (line  93)
* --no-dereference <1>:                  chcon invocation.    (line  22)
* --no-dereference <2>:                  du invocation.       (line 118)
* --no-dereference <3>:                  touch invocation.    (line 111)
* --no-dereference <4>:                  chgrp invocation.    (line  38)
* --no-dereference <5>:                  chown invocation.    (line 115)
* --no-dereference <6>:                  ln invocation.       (line 125)
* --no-dereference:                      cp invocation.       (line 183)
* --no-file-warnings:                    pr invocation.       (line 217)
* --no-group:                            What information is listed.
                                                              (line 116)
* --no-newline:                          readlink invocation. (line  48)
* --no-preserve-root <1>:                chmod invocation.    (line  59)
* --no-preserve-root <2>:                chgrp invocation.    (line  53)
* --no-preserve-root <3>:                chown invocation.    (line 130)
* --no-preserve-root:                    rm invocation.       (line  96)
* --no-renumber:                         nl invocation.       (line 109)
* --no-symlinks:                         realpath invocation. (line  57)
* --no-sync:                             df invocation.       (line  83)
* --no-target-directory <1>:             ln invocation.       (line 188)
* --no-target-directory <2>:             mv invocation.       (line 120)
* --no-target-directory <3>:             install invocation.  (line 137)
* --no-target-directory <4>:             cp invocation.       (line 389)
* --no-target-directory:                 Target directory.    (line  15)
* --nodename:                            uname invocation.    (line  55)
* --null <1>:                            env invocation.      (line  90)
* --null <2>:                            printenv invocation. (line  21)
* --null:                                du invocation.       (line 133)
* --number <1>:                          split invocation.    (line  85)
* --number:                              cat invocation.      (line  33)
* --number-format:                       nl invocation.       (line  96)
* --number-lines:                        pr invocation.       (line 185)
* --number-nonblank:                     cat invocation.      (line  22)
* --number-separator:                    nl invocation.       (line 113)
* --number-width:                        nl invocation.       (line 122)
* --numeric-sort:                        sort invocation.     (line 181)
* --numeric-suffixes:                    split invocation.    (line 129)
* --numeric-uid-gid:                     What information is listed.
                                                              (line 246)
* --omit-header:                         pr invocation.       (line 244)
* --omit-pagination:                     pr invocation.       (line 256)
* --one-file-system <1>:                 du invocation.       (line 216)
* --one-file-system <2>:                 rm invocation.       (line  73)
* --one-file-system:                     cp invocation.       (line 413)
* --only-delimited:                      cut invocation.      (line  77)
* --operating-system:                    uname invocation.    (line  66)
* --output <1>:                          stdbuf invocation.   (line  32)
* --output <2>:                          shuf invocation.     (line  39)
* --output:                              sort invocation.     (line 314)
* --output-delimiter:                    cut invocation.      (line  82)
* --output-duplicates:                   od invocation.       (line 162)
* --output-tabs:                         pr invocation.       (line 147)
* --owner:                               install invocation.  (line  95)
* --page_width:                          pr invocation.       (line 275)
* --pages=PAGE_RANGE:                    pr invocation.       (line  64)
* --parallel:                            sort invocation.     (line 395)
* --parents <1>:                         rmdir invocation.    (line  24)
* --parents <2>:                         mkdir invocation.    (line  36)
* --parents:                             cp invocation.       (line 270)
* --physical <1>:                        pwd invocation.      (line  24)
* --physical <2>:                        realpath invocation. (line  43)
* --physical:                            ln invocation.       (line 147)
* --pid:                                 tail invocation.     (line 135)
* --portability <1>:                     pathchk invocation.  (line  50)
* --portability:                         df invocation.       (line  91)
* --prefix:                              csplit invocation.   (line  66)
* --preserve:                            cp invocation.       (line 191)
* --preserve-context:                    install invocation.  (line 101)
* --preserve-root <1>:                   chmod invocation.    (line  54)
* --preserve-root <2>:                   chgrp invocation.    (line  48)
* --preserve-root <3>:                   chown invocation.    (line 125)
* --preserve-root:                       rm invocation.       (line  91)
* --preserve-timestamps:                 install invocation.  (line 108)
* --print-database:                      dircolors invocation.
                                                              (line  48)
* --print-type:                          df invocation.       (line 134)
* --printf=FORMAT:                       stat invocation.     (line  48)
* --process:                             who invocation.      (line  67)
* --processor:                           uname invocation.    (line  59)
* --quiet <1>:                           tty invocation.      (line  19)
* --quiet <2>:                           realpath invocation. (line  52)
* --quiet <3>:                           mktemp invocation.   (line 102)
* --quiet <4>:                           chmod invocation.    (line  50)
* --quiet <5>:                           chgrp invocation.    (line  29)
* --quiet <6>:                           chown invocation.    (line  80)
* --quiet <7>:                           readlink invocation. (line  54)
* --quiet <8>:                           md5sum invocation.   (line  79)
* --quiet <9>:                           csplit invocation.   (line 105)
* --quiet <10>:                          tail invocation.     (line 177)
* --quiet:                               head invocation.     (line  49)
* --quote-name:                          Formatting the file names.
                                                              (line  30)
* --quoting-style:                       Formatting the file names.
                                                              (line  11)
* --random-sort:                         sort invocation.     (line 211)
* --random-source <1>:                   shred invocation.    (line 125)
* --random-source <2>:                   shuf invocation.     (line  45)
* --random-source:                       sort invocation.     (line 330)
* --range <1>:                           runcon invocation.   (line  43)
* --range:                               chcon invocation.    (line  64)
* --read-bytes:                          od invocation.       (line  79)
* --real:                                id invocation.       (line  40)
* --recursive <1>:                       chcon invocation.    (line  30)
* --recursive <2>:                       chmod invocation.    (line  75)
* --recursive <3>:                       chgrp invocation.    (line  71)
* --recursive <4>:                       chown invocation.    (line 149)
* --recursive <5>:                       rm invocation.       (line 103)
* --recursive <6>:                       cp invocation.       (line 283)
* --recursive:                           Which files are listed.
                                                              (line  98)
* --reference <1>:                       chcon invocation.    (line  25)
* --reference <2>:                       Options for date.    (line  57)
* --reference <3>:                       truncate invocation. (line  34)
* --reference <4>:                       touch invocation.    (line 132)
* --reference <5>:                       chmod invocation.    (line  68)
* --reference <6>:                       chgrp invocation.    (line  57)
* --reference:                           chown invocation.    (line 134)
* --reflink[=WHEN]:                      cp invocation.       (line 298)
* --regex:                               tac invocation.      (line  28)
* --relative:                            ln invocation.       (line 159)
* --relative-base:                       realpath invocation. (line  72)
* --relative-to:                         realpath invocation. (line  67)
* --remove:                              shred invocation.    (line 138)
* --remove-destination:                  cp invocation.       (line 326)
* --repeated:                            uniq invocation.     (line  67)
* --retry:                               tail invocation.     (line 116)
* --reverse <1>:                         Sorting the output.  (line  28)
* --reverse:                             sort invocation.     (line 205)
* --rfc-2822:                            Options for date.    (line  63)
* --rfc-3339=TIMESPEC:                   Options for date.    (line  75)
* --rfc-822:                             Options for date.    (line  63)
* --role <1>:                            runcon invocation.   (line  35)
* --role:                                chcon invocation.    (line  56)
* --runlevel:                            who invocation.      (line  77)
* --save:                                stty invocation.     (line  46)
* --section-delimiter:                   nl invocation.       (line  70)
* --sep-string:                          pr invocation.       (line 232)
* --separate-dirs:                       du invocation.       (line 150)
* --separator <1>:                       pr invocation.       (line 222)
* --separator:                           tac invocation.      (line  35)
* --serial:                              paste invocation.    (line  34)
* --set:                                 Options for date.    (line 105)
* --sh:                                  dircolors invocation.
                                                              (line  36)
* --show-all:                            cat invocation.      (line  18)
* --show-control-chars <1>:              Formatting the file names.
                                                              (line  83)
* --show-control-chars:                  pr invocation.       (line  97)
* --show-ends:                           cat invocation.      (line  29)
* --show-nonprinting <1>:                pr invocation.       (line 261)
* --show-nonprinting:                    cat invocation.      (line  53)
* --show-tabs:                           cat invocation.      (line  46)
* --si <1>:                              du invocation.       (line 138)
* --si <2>:                              df invocation.       (line 111)
* --si <3>:                              What information is listed.
                                                              (line 273)
* --si:                                  Block size.          (line 150)
* --signal:                              timeout invocation.  (line  44)
* --silent <1>:                          tty invocation.      (line  19)
* --silent <2>:                          chmod invocation.    (line  50)
* --silent <3>:                          chgrp invocation.    (line  29)
* --silent <4>:                          chown invocation.    (line  80)
* --silent <5>:                          readlink invocation. (line  54)
* --silent <6>:                          csplit invocation.   (line 105)
* --silent <7>:                          tail invocation.     (line 177)
* --silent:                              head invocation.     (line  49)
* --size <1>:                            truncate invocation. (line  38)
* --size:                                What information is listed.
                                                              (line 256)
* --size=BYTES:                          shred invocation.    (line 131)
* --skip-bytes:                          od invocation.       (line  63)
* --skip-chars:                          uniq invocation.     (line  43)
* --skip-fields:                         uniq invocation.     (line  33)
* --sleep-interval:                      tail invocation.     (line 123)
* --sort <1>:                            Sorting the output.  (line  34)
* --sort:                                sort invocation.     (line 123)
* --spaces:                              fold invocation.     (line  32)
* --sparse=WHEN:                         cp invocation.       (line 330)
* --split-only:                          fmt invocation.      (line  51)
* --squeeze-blank:                       cat invocation.      (line  38)
* --stable:                              sort invocation.     (line 336)
* --starting-line-number:                nl invocation.       (line 118)
* --status:                              md5sum invocation.   (line  87)
* --strict:                              md5sum invocation.   (line 124)
* --strings:                             od invocation.       (line  84)
* --strip <1>:                           realpath invocation. (line  57)
* --strip:                               install invocation.  (line 118)
* --strip-program:                       install invocation.  (line 122)
* --strip-trailing-slashes <1>:          mv invocation.       (line 105)
* --strip-trailing-slashes:              cp invocation.       (line 366)
* --suffix <1>:                          mktemp invocation.   (line 126)
* --suffix <2>:                          basename invocation. (line  41)
* --suffix <3>:                          ln invocation.       (line 178)
* --suffix <4>:                          mv invocation.       (line 110)
* --suffix <5>:                          install invocation.  (line 127)
* --suffix <6>:                          cp invocation.       (line 379)
* --suffix <7>:                          csplit invocation.   (line  70)
* --suffix:                              Backup options.      (line  54)
* --suffix-length:                       split invocation.    (line 120)
* --summarize:                           du invocation.       (line 146)
* --symbolic:                            ln invocation.       (line 172)
* --symbolic-link:                       cp invocation.       (line 371)
* --sync:                                df invocation.       (line 118)
* --sysv:                                sum invocation.      (line  34)
* --tabs <1>:                            unexpand invocation. (line  28)
* --tabs:                                expand invocation.   (line  24)
* --tabsize:                             General output formatting.
                                                              (line 121)
* --tag:                                 md5sum invocation.   (line  98)
* --tagged-paragraph:                    fmt invocation.      (line  44)
* --target-directory <1>:                ln invocation.       (line 183)
* --target-directory <2>:                mv invocation.       (line 115)
* --target-directory <3>:                install invocation.  (line 132)
* --target-directory <4>:                cp invocation.       (line 384)
* --target-directory:                    Target directory.    (line  35)
* --temporary-directory:                 sort invocation.     (line 386)
* --terse:                               stat invocation.     (line  60)
* --text:                                md5sum invocation.   (line 109)
* --time <1>:                            who invocation.      (line  85)
* --time <2>:                            du invocation.       (line 158)
* --time <3>:                            touch invocation.    (line  89)
* --time:                                Sorting the output.  (line  13)
* --time-style <1>:                      du invocation.       (line 175)
* --time-style:                          Formatting file timestamps.
                                                              (line  27)
* --tmpdir:                              mktemp invocation.   (line 117)
* --total <1>:                           du invocation.       (line  59)
* --total:                               df invocation.       (line  49)
* --traditional:                         od invocation.       (line 213)
* --type <1>:                            runcon invocation.   (line  39)
* --type <2>:                            chcon invocation.    (line  60)
* --type:                                df invocation.       (line 127)
* --unbuffered:                          split invocation.    (line 151)
* --uniform-spacing:                     fmt invocation.      (line  57)
* --unique <1>:                          uniq invocation.     (line 106)
* --unique:                              sort invocation.     (line 403)
* --universal:                           Options for date.    (line 111)
* --unset:                               env invocation.      (line  96)
* --update <1>:                          mv invocation.       (line  91)
* --update:                              cp invocation.       (line 394)
* --user <1>:                            runcon invocation.   (line  31)
* --user <2>:                            chcon invocation.    (line  52)
* --user:                                id invocation.       (line  45)
* --userspec:                            chroot invocation.   (line  29)
* --utc:                                 Options for date.    (line 111)
* --verbose <1>:                         chcon invocation.    (line  48)
* --verbose <2>:                         chmod invocation.    (line  64)
* --verbose <3>:                         chgrp invocation.    (line  63)
* --verbose <4>:                         chown invocation.    (line 141)
* --verbose <5>:                         rmdir invocation.    (line  33)
* --verbose <6>:                         readlink invocation. (line  58)
* --verbose <7>:                         mkdir invocation.    (line  53)
* --verbose <8>:                         ln invocation.       (line 193)
* --verbose <9>:                         shred invocation.    (line 144)
* --verbose <10>:                        rm invocation.       (line 107)
* --verbose <11>:                        mv invocation.       (line 102)
* --verbose <12>:                        install invocation.  (line 142)
* --verbose <13>:                        cp invocation.       (line 409)
* --verbose <14>:                        split invocation.    (line 155)
* --verbose <15>:                        tail invocation.     (line 181)
* --verbose:                             head invocation.     (line  53)
* --version:                             Common options.      (line  43)
* --version-sort:                        sort invocation.     (line 198)
* --warn:                                md5sum invocation.   (line 119)
* --width <1>:                           General output formatting.
                                                              (line 134)
* --width <2>:                           fold invocation.     (line  38)
* --width <3>:                           pr invocation.       (line 265)
* --width <4>:                           fmt invocation.      (line  63)
* --width:                               od invocation.       (line 169)
* --words:                               wc invocation.       (line  55)
* --wrap:                                base64 invocation.   (line  25)
* --writable:                            who invocation.      (line  97)
* --zero <1>:                            realpath invocation. (line  64)
* --zero <2>:                            dirname invocation.  (line  34)
* --zero <3>:                            basename invocation. (line  46)
* --zero:                                shred invocation.    (line 160)
* --zero-terminated <1>:                 uniq invocation.     (line 118)
* --zero-terminated <2>:                 shuf invocation.     (line  51)
* --zero-terminated:                     sort invocation.     (line 419)
* -0 <1>:                                env invocation.      (line  89)
* -0 <2>:                                printenv invocation. (line  20)
* -0:                                    du invocation.       (line 132)
* -1 <1>:                                General output formatting.
                                                              (line  10)
* -1 <2>:                                join invocation.     (line 116)
* -1:                                    comm invocation.     (line  24)
* -2 <1>:                                join invocation.     (line 120)
* -2:                                    comm invocation.     (line  24)
* -3:                                    comm invocation.     (line  24)
* -a <1>:                                uname invocation.    (line  38)
* -a <2>:                                who invocation.      (line  37)
* -a <3>:                                stty invocation.     (line  29)
* -a <4>:                                basename invocation. (line  35)
* -a <5>:                                tee invocation.      (line  27)
* -a <6>:                                Connectives for test.
                                                              (line  12)
* -a <7>:                                du invocation.       (line  28)
* -a <8>:                                df invocation.       (line  37)
* -a <9>:                                touch invocation.    (line  89)
* -a:                                    cp invocation.       (line  74)
* -A:                                    Which files are listed.
                                                              (line  19)
* -a <1>:                                Which files are listed.
                                                              (line  14)
* -a <2>:                                unexpand invocation. (line  52)
* -a <3>:                                join invocation.     (line  84)
* -a <4>:                                split invocation.    (line 120)
* -a <5>:                                pr invocation.       (line  90)
* -a:                                    od invocation.       (line 182)
* -A <1>:                                od invocation.       (line  44)
* -A:                                    cat invocation.      (line  18)
* -b <1>:                                who invocation.      (line  41)
* -b:                                    File type tests.     (line  11)
* -B:                                    du invocation.       (line  53)
* -b:                                    du invocation.       (line  49)
* -B:                                    df invocation.       (line  44)
* -b <1>:                                ln invocation.       (line  96)
* -b <2>:                                mv invocation.       (line  67)
* -b <3>:                                install invocation.  (line  46)
* -b <4>:                                cp invocation.       (line  90)
* -b <5>:                                dircolors invocation.
                                                              (line  36)
* -b:                                    Formatting the file names.
                                                              (line  11)
* -B:                                    Which files are listed.
                                                              (line  25)
* -b <1>:                                cut invocation.      (line  31)
* -b <2>:                                sort invocation.     (line  91)
* -b <3>:                                md5sum invocation.   (line  43)
* -b <4>:                                csplit invocation.   (line  70)
* -b <5>:                                split invocation.    (line  47)
* -b <6>:                                fold invocation.     (line  26)
* -b <7>:                                od invocation.       (line 185)
* -b <8>:                                nl invocation.       (line  49)
* -b <9>:                                tac invocation.      (line  23)
* -b <10>:                               cat invocation.      (line  22)
* -b:                                    Backup options.      (line  14)
* -c <1>:                                runcon invocation.   (line  27)
* -c <2>:                                File type tests.     (line  14)
* -c <3>:                                truncate invocation. (line  25)
* -c <4>:                                stat invocation.     (line  39)
* -c <5>:                                du invocation.       (line  59)
* -c <6>:                                touch invocation.    (line  93)
* -c <7>:                                chmod invocation.    (line  44)
* -c <8>:                                chgrp invocation.    (line  23)
* -c <9>:                                chown invocation.    (line  74)
* -c:                                    install invocation.  (line  58)
* -C:                                    install invocation.  (line  51)
* -c:                                    dircolors invocation.
                                                              (line  43)
* -C:                                    General output formatting.
                                                              (line  15)
* -c <1>:                                Sorting the output.  (line  13)
* -c <2>:                                cut invocation.      (line  39)
* -c <3>:                                uniq invocation.     (line  59)
* -c <4>:                                shuf invocation.     (line  21)
* -c <5>:                                sort invocation.     (line  23)
* -c:                                    wc invocation.       (line  47)
* -C:                                    split invocation.    (line  61)
* -c <1>:                                tail invocation.     (line  35)
* -c <2>:                                head invocation.     (line  26)
* -c <3>:                                pr invocation.       (line  97)
* -c <4>:                                fmt invocation.      (line  38)
* -c:                                    od invocation.       (line 188)
* -COLUMN:                               pr invocation.       (line  75)
* -d <1>:                                Options for date.    (line  11)
* -d <2>:                                who invocation.      (line  45)
* -d <3>:                                mktemp invocation.   (line  95)
* -d:                                    File type tests.     (line  17)
* -D:                                    du invocation.       (line  65)
* -d <1>:                                touch invocation.    (line  97)
* -d <2>:                                ln invocation.       (line 102)
* -d <3>:                                rm invocation.       (line  39)
* -d:                                    install invocation.  (line  69)
* -D:                                    install invocation.  (line  62)
* -d:                                    cp invocation.       (line 124)
* -D:                                    What information is listed.
                                                              (line  17)
* -d <1>:                                Which files are listed.
                                                              (line  30)
* -d <2>:                                paste invocation.    (line  44)
* -d:                                    cut invocation.      (line  69)
* -D:                                    uniq invocation.     (line  73)
* -d <1>:                                uniq invocation.     (line  67)
* -d <2>:                                sort invocation.     (line 100)
* -d <3>:                                split invocation.    (line 129)
* -d <4>:                                pr invocation.       (line 103)
* -d <5>:                                base64 invocation.   (line  33)
* -d <6>:                                od invocation.       (line 192)
* -d:                                    nl invocation.       (line  70)
* -d DEPTH:                              du invocation.       (line 124)
* -e <1>:                                stdbuf invocation.   (line  36)
* -e <2>:                                realpath invocation. (line  20)
* -e:                                    File characteristic tests.
                                                              (line   9)
* -E:                                    echo invocation.     (line  76)
* -e <1>:                                echo invocation.     (line  28)
* -e <2>:                                readlink invocation. (line  35)
* -e <3>:                                join invocation.     (line  96)
* -e <4>:                                split invocation.    (line 142)
* -e:                                    pr invocation.       (line 127)
* -E:                                    cat invocation.      (line  29)
* -e:                                    cat invocation.      (line  25)
* -ef:                                   File characteristic tests.
                                                              (line  23)
* -eq:                                   Numeric tests.       (line  16)
* -f:                                    Options for date.    (line  26)
* -F:                                    stty invocation.     (line  34)
* -f <1>:                                File type tests.     (line  20)
* -f <2>:                                stat invocation.     (line  33)
* -f <3>:                                touch invocation.    (line 107)
* -f <4>:                                chmod invocation.    (line  50)
* -f <5>:                                chgrp invocation.    (line  29)
* -f <6>:                                chown invocation.    (line  80)
* -f <7>:                                readlink invocation. (line  28)
* -f:                                    ln invocation.       (line 108)
* -F:                                    ln invocation.       (line 102)
* -f <1>:                                shred invocation.    (line 114)
* -f <2>:                                rm invocation.       (line  43)
* -f <3>:                                mv invocation.       (line  72)
* -f:                                    cp invocation.       (line 132)
* -F:                                    General output formatting.
                                                              (line  55)
* -f <1>:                                Sorting the output.  (line  20)
* -f <2>:                                cut invocation.      (line  48)
* -f <3>:                                uniq invocation.     (line  33)
* -f <4>:                                sort invocation.     (line 107)
* -f:                                    csplit invocation.   (line  66)
* -F:                                    tail invocation.     (line 110)
* -f <1>:                                tail invocation.     (line  51)
* -f:                                    pr invocation.       (line 135)
* -F:                                    pr invocation.       (line 135)
* -f <1>:                                od invocation.       (line 195)
* -f:                                    nl invocation.       (line  77)
* -f FORMAT:                             seq invocation.      (line  26)
* -G:                                    id invocation.       (line  31)
* -g <1>:                                id invocation.       (line  27)
* -g:                                    stty invocation.     (line  46)
* -G:                                    Access permission tests.
                                                              (line  32)
* -g <1>:                                Access permission tests.
                                                              (line   9)
* -g:                                    install invocation.  (line  76)
* -G:                                    What information is listed.
                                                              (line 116)
* -g <1>:                                What information is listed.
                                                              (line 112)
* -g <2>:                                sort invocation.     (line 123)
* -g:                                    fmt invocation.      (line  68)
* -ge:                                   Numeric tests.       (line  16)
* -gt:                                   Numeric tests.       (line  16)
* -H:                                    chcon invocation.    (line  33)
* -h:                                    chcon invocation.    (line  22)
* -H:                                    who invocation.      (line  49)
* -h:                                    File type tests.     (line  24)
* -H:                                    du invocation.       (line  94)
* -h:                                    du invocation.       (line  87)
* -H:                                    df invocation.       (line  63)
* -h <1>:                                df invocation.       (line  56)
* -h:                                    touch invocation.    (line 111)
* -H:                                    chgrp invocation.    (line  74)
* -h:                                    chgrp invocation.    (line  38)
* -H:                                    chown invocation.    (line 152)
* -h:                                    chown invocation.    (line 115)
* -H:                                    cp invocation.       (line 149)
* -h:                                    What information is listed.
                                                              (line 122)
* -H:                                    Which files are listed.
                                                              (line  39)
* -h <1>:                                sort invocation.     (line 146)
* -h <2>:                                pr invocation.       (line 141)
* -h:                                    nl invocation.       (line  81)
* -H:                                    Traversing symlinks. (line  20)
* -h:                                    Block size.          (line 150)
* -i <1>:                                stdbuf invocation.   (line  28)
* -i <2>:                                env invocation.      (line 101)
* -i <3>:                                uname invocation.    (line  43)
* -i <4>:                                tee invocation.      (line  32)
* -i <5>:                                df invocation.       (line  67)
* -i:                                    ln invocation.       (line 113)
* -I:                                    rm invocation.       (line  54)
* -i <1>:                                rm invocation.       (line  49)
* -i <2>:                                mv invocation.       (line  78)
* -i <3>:                                cp invocation.       (line 157)
* -i:                                    What information is listed.
                                                              (line 130)
* -I:                                    Which files are listed.
                                                              (line  75)
* -i <1>:                                expand invocation.   (line  37)
* -i <2>:                                join invocation.     (line 110)
* -i <3>:                                uniq invocation.     (line  63)
* -i <4>:                                shuf invocation.     (line  25)
* -i <5>:                                sort invocation.     (line 162)
* -i <6>:                                pr invocation.       (line 147)
* -i <7>:                                base64 invocation.   (line  40)
* -i <8>:                                od invocation.       (line 198)
* -i:                                    nl invocation.       (line  85)
* -I[TIMESPEC]:                          Options for date.    (line  34)
* -J:                                    pr invocation.       (line 154)
* -j:                                    od invocation.       (line  63)
* -k <1>:                                timeout invocation.  (line  37)
* -k <2>:                                Access permission tests.
                                                              (line  12)
* -k <3>:                                du invocation.       (line  97)
* -k <4>:                                df invocation.       (line  73)
* -k <5>:                                General output formatting.
                                                              (line  93)
* -k <6>:                                sort invocation.     (line 260)
* -k <7>:                                csplit invocation.   (line  90)
* -k:                                    Block size.          (line 150)
* -l <1>:                                runcon invocation.   (line  43)
* -l:                                    chcon invocation.    (line  64)
* -L:                                    chcon invocation.    (line  38)
* -l:                                    who invocation.      (line  53)
* -L <1>:                                pwd invocation.      (line  17)
* -L <2>:                                realpath invocation. (line  33)
* -L <3>:                                File type tests.     (line  24)
* -L <4>:                                stat invocation.     (line  26)
* -L:                                    du invocation.       (line 108)
* -l <1>:                                du invocation.       (line 103)
* -l:                                    df invocation.       (line  79)
* -L <1>:                                chgrp invocation.    (line  79)
* -L <2>:                                chown invocation.    (line 157)
* -L <3>:                                ln invocation.       (line 118)
* -L:                                    cp invocation.       (line 169)
* -l <1>:                                cp invocation.       (line 164)
* -l:                                    What information is listed.
                                                              (line 138)
* -L <1>:                                Which files are listed.
                                                              (line  90)
* -L:                                    wc invocation.       (line  63)
* -l <1>:                                wc invocation.       (line  59)
* -l <2>:                                split invocation.    (line  39)
* -l <3>:                                pr invocation.       (line 164)
* -l <4>:                                od invocation.       (line 201)
* -l:                                    nl invocation.       (line  89)
* -L:                                    Traversing symlinks. (line  25)
* -le:                                   Numeric tests.       (line  16)
* -lt:                                   Numeric tests.       (line  16)
* -m <1>:                                uname invocation.    (line  50)
* -m <2>:                                who invocation.      (line  63)
* -m <3>:                                realpath invocation. (line  28)
* -m <4>:                                du invocation.       (line 112)
* -m <5>:                                touch invocation.    (line 128)
* -m <6>:                                readlink invocation. (line  42)
* -m <7>:                                mknod invocation.    (line  56)
* -m <8>:                                mkfifo invocation.   (line  24)
* -m <9>:                                mkdir invocation.    (line  22)
* -m <10>:                               install invocation.  (line  82)
* -m:                                    General output formatting.
                                                              (line 106)
* -M:                                    sort invocation.     (line 170)
* -m <1>:                                sort invocation.     (line  39)
* -m <2>:                                wc invocation.       (line  51)
* -m:                                    pr invocation.       (line 170)
* -n <1>:                                nice invocation.     (line  53)
* -n <2>:                                uname invocation.    (line  55)
* -n <3>:                                id invocation.       (line  35)
* -n <4>:                                String tests.        (line  19)
* -n <5>:                                echo invocation.     (line  25)
* -n <6>:                                readlink invocation. (line  48)
* -n <7>:                                ln invocation.       (line 125)
* -n <8>:                                mv invocation.       (line  85)
* -n:                                    cp invocation.       (line 177)
* -N:                                    Formatting the file names.
                                                              (line  18)
* -n <1>:                                What information is listed.
                                                              (line 246)
* -n <2>:                                cut invocation.      (line  73)
* -n <3>:                                shuf invocation.     (line  34)
* -n <4>:                                sort invocation.     (line 181)
* -n <5>:                                csplit invocation.   (line  85)
* -n <6>:                                split invocation.    (line  85)
* -n <7>:                                tail invocation.     (line 170)
* -n:                                    head invocation.     (line  42)
* -N:                                    pr invocation.       (line 205)
* -n:                                    pr invocation.       (line 185)
* -N:                                    od invocation.       (line  79)
* -n <1>:                                nl invocation.       (line  96)
* -n:                                    cat invocation.      (line  33)
* -n NUMBER:                             shred invocation.    (line 119)
* -ne:                                   Numeric tests.       (line  16)
* -nt:                                   File characteristic tests.
                                                              (line  15)
* -o <1>:                                stdbuf invocation.   (line  32)
* -o <2>:                                uname invocation.    (line  66)
* -o:                                    Connectives for test.
                                                              (line  15)
* -O:                                    Access permission tests.
                                                              (line  28)
* -o <1>:                                truncate invocation. (line  29)
* -o <2>:                                install invocation.  (line  95)
* -o <3>:                                What information is listed.
                                                              (line 250)
* -o <4>:                                shuf invocation.     (line  39)
* -o <5>:                                sort invocation.     (line 314)
* -o <6>:                                pr invocation.       (line 210)
* -o:                                    od invocation.       (line 204)
* -ot:                                   File characteristic tests.
                                                              (line  19)
* -P:                                    chcon invocation.    (line  42)
* -p <1>:                                uname invocation.    (line  59)
* -p:                                    who invocation.      (line  67)
* -P <1>:                                pwd invocation.      (line  24)
* -P:                                    realpath invocation. (line  43)
* -p:                                    mktemp invocation.   (line 117)
* -P:                                    pathchk invocation.  (line  46)
* -p <1>:                                pathchk invocation.  (line  31)
* -p:                                    File type tests.     (line  29)
* -P <1>:                                du invocation.       (line 118)
* -P <2>:                                df invocation.       (line  91)
* -P <3>:                                chgrp invocation.    (line  83)
* -P:                                    chown invocation.    (line 161)
* -p <1>:                                rmdir invocation.    (line  24)
* -p:                                    mkdir invocation.    (line  36)
* -P:                                    ln invocation.       (line 147)
* -p <1>:                                install invocation.  (line 108)
* -p:                                    cp invocation.       (line 191)
* -P:                                    cp invocation.       (line 183)
* -p <1>:                                dircolors invocation.
                                                              (line  48)
* -p <2>:                                General output formatting.
                                                              (line 111)
* -p:                                    nl invocation.       (line 109)
* -P:                                    Traversing symlinks. (line  29)
* -q <1>:                                who invocation.      (line  72)
* -q <2>:                                realpath invocation. (line  52)
* -q <3>:                                mktemp invocation.   (line 102)
* -q:                                    readlink invocation. (line  54)
* -Q:                                    Formatting the file names.
                                                              (line  30)
* -q <1>:                                Formatting the file names.
                                                              (line  24)
* -q <2>:                                csplit invocation.   (line 105)
* -q <3>:                                tail invocation.     (line 177)
* -q:                                    head invocation.     (line  49)
* -r <1>:                                runcon invocation.   (line  35)
* -r:                                    chcon invocation.    (line  56)
* -R:                                    chcon invocation.    (line  30)
* -r:                                    uname invocation.    (line  70)
* -R:                                    Options for date.    (line  63)
* -r <1>:                                Options for date.    (line  57)
* -r <2>:                                who invocation.      (line  77)
* -r <3>:                                id invocation.       (line  40)
* -r <4>:                                Access permission tests.
                                                              (line  15)
* -r <5>:                                truncate invocation. (line  34)
* -r:                                    touch invocation.    (line 132)
* -R <1>:                                chmod invocation.    (line  75)
* -R <2>:                                chgrp invocation.    (line  71)
* -R:                                    chown invocation.    (line 149)
* -r:                                    ln invocation.       (line 159)
* -R:                                    rm invocation.       (line 103)
* -r <1>:                                rm invocation.       (line 103)
* -r:                                    cp invocation.       (line 283)
* -R:                                    cp invocation.       (line 283)
* -r:                                    Sorting the output.  (line  28)
* -R <1>:                                Which files are listed.
                                                              (line  98)
* -R:                                    sort invocation.     (line 211)
* -r <1>:                                sort invocation.     (line 205)
* -r <2>:                                sum invocation.      (line  27)
* -r <3>:                                pr invocation.       (line 217)
* -r:                                    tac invocation.      (line  28)
* -s <1>:                                timeout invocation.  (line  44)
* -s <2>:                                uname invocation.    (line  74)
* -s <3>:                                Options for date.    (line 105)
* -s <4>:                                who invocation.      (line  81)
* -s <5>:                                tty invocation.      (line  19)
* -s <6>:                                realpath invocation. (line  57)
* -s <7>:                                basename invocation. (line  41)
* -s:                                    File characteristic tests.
                                                              (line  12)
* -S:                                    File type tests.     (line  32)
* -s:                                    truncate invocation. (line  38)
* -S:                                    du invocation.       (line 150)
* -s <1>:                                du invocation.       (line 146)
* -s:                                    readlink invocation. (line  54)
* -S:                                    ln invocation.       (line 178)
* -s:                                    ln invocation.       (line 172)
* -S <1>:                                mv invocation.       (line 110)
* -S:                                    install invocation.  (line 127)
* -s:                                    install invocation.  (line 118)
* -S:                                    cp invocation.       (line 379)
* -s:                                    cp invocation.       (line 371)
* -S:                                    Sorting the output.  (line  34)
* -s <1>:                                What information is listed.
                                                              (line 256)
* -s <2>:                                paste invocation.    (line  34)
* -s <3>:                                cut invocation.      (line  77)
* -s:                                    uniq invocation.     (line  43)
* -S:                                    sort invocation.     (line 349)
* -s <1>:                                sort invocation.     (line 336)
* -s <2>:                                sum invocation.      (line  34)
* -s <3>:                                csplit invocation.   (line 105)
* -s:                                    fold invocation.     (line  32)
* -S:                                    pr invocation.       (line 232)
* -s <1>:                                pr invocation.       (line 222)
* -s <2>:                                fmt invocation.      (line  51)
* -s:                                    od invocation.       (line 207)
* -S:                                    od invocation.       (line  84)
* -s <1>:                                nl invocation.       (line 113)
* -s <2>:                                tac invocation.      (line  35)
* -s:                                    cat invocation.      (line  38)
* -S:                                    Backup options.      (line  54)
* -s BYTES:                              shred invocation.    (line 131)
* -t <1>:                                runcon invocation.   (line  39)
* -t:                                    chcon invocation.    (line  60)
* -T:                                    who invocation.      (line  97)
* -t <1>:                                who invocation.      (line  85)
* -t <2>:                                mktemp invocation.   (line 135)
* -t <3>:                                File type tests.     (line  35)
* -t:                                    stat invocation.     (line  60)
* -T:                                    df invocation.       (line 134)
* -t:                                    df invocation.       (line 127)
* -T:                                    ln invocation.       (line 188)
* -t:                                    ln invocation.       (line 183)
* -T:                                    mv invocation.       (line 120)
* -t:                                    mv invocation.       (line 115)
* -T:                                    install invocation.  (line 137)
* -t:                                    install invocation.  (line 132)
* -T:                                    cp invocation.       (line 389)
* -t:                                    cp invocation.       (line 384)
* -T:                                    General output formatting.
                                                              (line 121)
* -t <1>:                                Sorting the output.  (line  38)
* -t <2>:                                unexpand invocation. (line  28)
* -t:                                    expand invocation.   (line  24)
* -T:                                    sort invocation.     (line 386)
* -t <1>:                                sort invocation.     (line 366)
* -t:                                    md5sum invocation.   (line 109)
* -T:                                    pr invocation.       (line 256)
* -t <1>:                                pr invocation.       (line 244)
* -t <2>:                                fmt invocation.      (line  44)
* -t:                                    od invocation.       (line  93)
* -T:                                    cat invocation.      (line  46)
* -t:                                    cat invocation.      (line  42)
* -u <1>:                                env invocation.      (line  96)
* -u <2>:                                runcon invocation.   (line  31)
* -u <3>:                                chcon invocation.    (line  52)
* -u <4>:                                Options for date.    (line 111)
* -u <5>:                                who invocation.      (line  88)
* -u <6>:                                id invocation.       (line  45)
* -u <7>:                                mktemp invocation.   (line 107)
* -u <8>:                                Access permission tests.
                                                              (line  18)
* -u <9>:                                shred invocation.    (line 138)
* -u <10>:                               mv invocation.       (line  91)
* -u:                                    cp invocation.       (line 394)
* -U:                                    Sorting the output.  (line  53)
* -u <1>:                                Sorting the output.  (line  45)
* -u <2>:                                uniq invocation.     (line 106)
* -u <3>:                                sort invocation.     (line 403)
* -u <4>:                                split invocation.    (line 151)
* -u <5>:                                fmt invocation.      (line  57)
* -u:                                    cat invocation.      (line  49)
* -v <1>:                                chcon invocation.    (line  48)
* -v <2>:                                uname invocation.    (line  85)
* -v <3>:                                chmod invocation.    (line  64)
* -v <4>:                                chgrp invocation.    (line  63)
* -v <5>:                                chown invocation.    (line 141)
* -v <6>:                                rmdir invocation.    (line  33)
* -v <7>:                                readlink invocation. (line  58)
* -v <8>:                                mkdir invocation.    (line  53)
* -v <9>:                                ln invocation.       (line 193)
* -v <10>:                               shred invocation.    (line 144)
* -v <11>:                               rm invocation.       (line 107)
* -v <12>:                               mv invocation.       (line 102)
* -v <13>:                               install invocation.  (line 142)
* -v <14>:                               cp invocation.       (line 409)
* -v:                                    Sorting the output.  (line  62)
* -V:                                    sort invocation.     (line 198)
* -v <1>:                                tail invocation.     (line 181)
* -v <2>:                                head invocation.     (line  53)
* -v <3>:                                pr invocation.       (line 261)
* -v <4>:                                od invocation.       (line 162)
* -v <5>:                                nl invocation.       (line 118)
* -v:                                    cat invocation.      (line  53)
* -w <1>:                                who invocation.      (line  97)
* -w <2>:                                Access permission tests.
                                                              (line  21)
* -w <3>:                                General output formatting.
                                                              (line 134)
* -w <4>:                                uniq invocation.     (line 112)
* -w <5>:                                md5sum invocation.   (line 119)
* -w <6>:                                wc invocation.       (line  55)
* -w:                                    fold invocation.     (line  38)
* -W:                                    pr invocation.       (line 275)
* -w <1>:                                pr invocation.       (line 265)
* -w <2>:                                fmt invocation.      (line  63)
* -w <3>:                                base64 invocation.   (line  25)
* -w <4>:                                od invocation.       (line 169)
* -w:                                    nl invocation.       (line 122)
* -WIDTH:                                fmt invocation.      (line  63)
* -x <1>:                                Access permission tests.
                                                              (line  24)
* -x <2>:                                du invocation.       (line 216)
* -x <3>:                                df invocation.       (line 162)
* -x <4>:                                shred invocation.    (line 149)
* -x <5>:                                cp invocation.       (line 413)
* -x:                                    General output formatting.
                                                              (line 116)
* -X:                                    Sorting the output.  (line  69)
* -x:                                    od invocation.       (line 210)
* -X FILE:                               du invocation.       (line 226)
* -Z:                                    id invocation.       (line  49)
* -z <1>:                                realpath invocation. (line  64)
* -z <2>:                                dirname invocation.  (line  34)
* -z <3>:                                basename invocation. (line  46)
* -z:                                    String tests.        (line  15)
* -Z <1>:                                mknod invocation.    (line  63)
* -Z <2>:                                mkfifo invocation.   (line  32)
* -Z:                                    mkdir invocation.    (line  58)
* -z:                                    shred invocation.    (line 160)
* -Z <1>:                                install invocation.  (line 146)
* -Z:                                    What information is listed.
                                                              (line 281)
* -z <1>:                                uniq invocation.     (line 118)
* -z <2>:                                shuf invocation.     (line  51)
* -z <3>:                                sort invocation.     (line 419)
* -z:                                    csplit invocation.   (line  94)
* /:                                     Numeric expressions. (line  15)
* 128-bit checksum:                      md5sum invocation.   (line   6)
* 16-bit checksum:                       sum invocation.      (line   6)
* 160-bit checksum:                      sha1sum invocation.  (line   6)
* 224-bit checksum:                      sha2 utilities.      (line   6)
* 256-bit checksum:                      sha2 utilities.      (line   6)
* 384-bit checksum:                      sha2 utilities.      (line   6)
* 4.2 file system type:                  df invocation.       (line 147)
* 512-bit checksum:                      sha2 utilities.      (line   6)
* <:                                     Relations for expr.  (line  21)
* <=:                                    Relations for expr.  (line  21)
* = <1>:                                 Relations for expr.  (line  21)
* =:                                     String tests.        (line  22)
* == <1>:                                Relations for expr.  (line  21)
* ==:                                    String tests.        (line  25)
* >:                                     Relations for expr.  (line  21)
* >=:                                    Relations for expr.  (line  21)
* \( regexp operator:                    String expressions.  (line  24)
* \+ regexp operator:                    String expressions.  (line  27)
* \? regexp operator:                    String expressions.  (line  27)
* \c:                                    printf invocation.   (line  33)
* \OOO:                                  printf invocation.   (line  71)
* \uhhhh:                                printf invocation.   (line  78)
* \Uhhhhhhhh:                            printf invocation.   (line  78)
* \xHH:                                  printf invocation.   (line  71)
* \| regexp operator:                    String expressions.  (line  27)
* _POSIX2_VERSION <1>:                   touch invocation.    (line 150)
* _POSIX2_VERSION <2>:                   uniq invocation.     (line  48)
* _POSIX2_VERSION <3>:                   sort invocation.     (line 456)
* _POSIX2_VERSION <4>:                   tail invocation.     (line 192)
* _POSIX2_VERSION:                       Standards conformance.
                                                              (line  20)
* abbreviations for months:              Calendar date items. (line  40)
* access permission tests:               Access permission tests.
                                                              (line   6)
* access permissions, changing:          chmod invocation.    (line   6)
* access time:                           dd invocation.       (line 252)
* access time, changing:                 touch invocation.    (line  89)
* access time, printing or sorting files by: Sorting the output.
                                                              (line  45)
* access time, show the most recent:     du invocation.       (line 170)
* across columns:                        pr invocation.       (line  90)
* across, listing files:                 General output formatting.
                                                              (line 116)
* adding permissions:                    Setting Permissions. (line  38)
* addition:                              Numeric expressions. (line  11)
* ago in date strings:                   Relative items in date strings.
                                                              (line  23)
* all repeated lines, outputting:        uniq invocation.     (line  73)
* alnum:                                 Character sets.      (line  93)
* alpha:                                 Character sets.      (line  96)
* alternate ebcdic, converting to:       dd invocation.       (line  91)
* always color option:                   General output formatting.
                                                              (line  28)
* always interactive option:             rm invocation.       (line  67)
* am i:                                  who invocation.      (line  22)
* am in date strings:                    Time of day items.   (line  21)
* and operator <1>:                      Relations for expr.  (line  17)
* and operator:                          Connectives for test.
                                                              (line  12)
* append:                                dd invocation.       (line 187)
* appending to the output file:          dd invocation.       (line 187)
* appropriate privileges <1>:            nice invocation.     (line   6)
* appropriate privileges <2>:            hostname invocation. (line   6)
* appropriate privileges <3>:            Setting the time.    (line   6)
* appropriate privileges:                install invocation.  (line  95)
* arbitrary date strings, parsing:       Options for date.    (line  11)
* arbitrary text, displaying:            echo invocation.     (line   6)
* arch:                                  arch invocation.     (line   6)
* arithmetic tests:                      Numeric tests.       (line   6)
* ASCII dump of files:                   od invocation.       (line   6)
* ascii, converting to:                  dd invocation.       (line  82)
* atime, changing:                       touch invocation.    (line  89)
* atime, printing or sorting files by:   Sorting the output.  (line  45)
* atime, show the most recent:           du invocation.       (line 170)
* attributes, file:                      Changing file attributes.
                                                              (line   6)
* authors of parse_datetime:             Authors of parse_datetime.
                                                              (line   6)
* auto color option:                     General output formatting.
                                                              (line  26)
* automounter file systems:              df invocation.       (line  37)
* b for block special file:              mknod invocation.    (line  39)
* background jobs, stopping at terminal write: Local.         (line  44)
* backslash escapes <1>:                 echo invocation.     (line  28)
* backslash escapes:                     Character sets.      (line  13)
* backslash sequences for file names:    Formatting the file names.
                                                              (line  11)
* backup files, ignoring:                Which files are listed.
                                                              (line  25)
* backup options:                        Backup options.      (line   6)
* backup suffix:                         Backup options.      (line  54)
* backups, making <1>:                   ln invocation.       (line  96)
* backups, making <2>:                   mv invocation.       (line  67)
* backups, making <3>:                   install invocation.  (line  46)
* backups, making <4>:                   cp invocation.       (line  90)
* backups, making:                       Backup options.      (line  14)
* backups, making only:                  cp invocation.       (line  60)
* base64:                                base64 invocation.   (line   6)
* Base64 decoding:                       base64 invocation.   (line  33)
* base64 encoding:                       base64 invocation.   (line   6)
* basename:                              basename invocation. (line   6)
* baud rate, setting:                    Special.             (line  43)
* beeping at input buffer full:          Input.               (line  61)
* beginning of time:                     Time conversion specifiers.
                                                              (line  42)
* beginning of time, for POSIX:          Seconds since the Epoch.
                                                              (line  13)
* Bellovin, Steven M.:                   Authors of parse_datetime.
                                                              (line   6)
* Berets, Jim:                           Authors of parse_datetime.
                                                              (line   6)
* Berry, K. <1>:                         Authors of parse_datetime.
                                                              (line  19)
* Berry, K.:                             Introduction.        (line  22)
* binary:                                dd invocation.       (line 270)
* binary I/O:                            dd invocation.       (line 270)
* binary input files:                    md5sum invocation.   (line  43)
* bind mount <1>:                        stat invocation.     (line 157)
* bind mount:                            rm invocation.       (line  77)
* blank:                                 Character sets.      (line  99)
* blank lines, numbering:                nl invocation.       (line  89)
* blanks, ignoring leading:              sort invocation.     (line  91)
* block (space-padding):                 dd invocation.       (line  99)
* block size <1>:                        dd invocation.       (line  35)
* block size:                            Block size.          (line   6)
* block size of conversion:              dd invocation.       (line  42)
* block size of input:                   dd invocation.       (line  27)
* block size of output:                  dd invocation.       (line  31)
* block special check:                   File type tests.     (line  11)
* block special files:                   mknod invocation.    (line  13)
* block special files, creating:         mknod invocation.    (line   6)
* BLOCK_SIZE:                            Block size.          (line  12)
* BLOCKSIZE:                             Block size.          (line  12)
* body, numbering:                       nl invocation.       (line  19)
* Bourne shell syntax for color setup:   dircolors invocation.
                                                              (line  36)
* breaks, cause interrupts:              Input.               (line  12)
* breaks, ignoring:                      Input.               (line   9)
* brkint:                                Input.               (line  12)
* bs:                                    dd invocation.       (line  35)
* BSD output:                            md5sum invocation.   (line  98)
* BSD sum:                               sum invocation.      (line  27)
* BSD tail:                              tail invocation.     (line  21)
* BSD touch compatibility:               touch invocation.    (line 107)
* bsN:                                   Output.              (line  56)
* bugs, reporting:                       Introduction.        (line  13)
* built-in shell commands, conflicts with <1>: sleep invocation.
                                                              (line  36)
* built-in shell commands, conflicts with <2>: kill invocation.
                                                              (line  16)
* built-in shell commands, conflicts with <3>: nice invocation.
                                                              (line  42)
* built-in shell commands, conflicts with <4>: pwd invocation.
                                                              (line  33)
* built-in shell commands, conflicts with <5>: test invocation.
                                                              (line  28)
* built-in shell commands, conflicts with <6>: printf invocation.
                                                              (line  18)
* built-in shell commands, conflicts with <7>: echo invocation.
                                                              (line  13)
* built-in shell commands, conflicts with <8>: stat invocation.
                                                              (line  18)
* built-in shell commands, conflicts with: mknod invocation.  (line  27)
* byte count:                            wc invocation.       (line   6)
* byte-swapping:                         dd invocation.       (line 133)
* c for character special file:          mknod invocation.    (line  42)
* C shell syntax for color setup:        dircolors invocation.
                                                              (line  43)
* C-s/C-q flow control:                  Input.               (line  41)
* calendar date item:                    Calendar date items. (line   6)
* canonical file name <1>:               realpath invocation. (line   6)
* canonical file name:                   readlink invocation. (line   6)
* canonicalize a file name <1>:          realpath invocation. (line   6)
* canonicalize a file name:              readlink invocation. (line   6)
* case folding:                          sort invocation.     (line 107)
* case translation:                      Local.               (line  37)
* case, ignored in dates:                General date syntax. (line  69)
* cat:                                   cat invocation.      (line   6)
* cbreak:                                Combination.         (line  51)
* cbs:                                   dd invocation.       (line  42)
* CD-ROM file system type:               df invocation.       (line 152)
* cdfs file system type:                 df invocation.       (line 152)
* change or print terminal settings:     stty invocation.     (line   6)
* change SELinux context:                chcon invocation.    (line   6)
* changed files, verbosely describing:   chgrp invocation.    (line  23)
* changed owners, verbosely describing:  chown invocation.    (line  74)
* changing access permissions:           chmod invocation.    (line   6)
* changing file attributes:              Changing file attributes.
                                                              (line   6)
* changing file ownership:               chown invocation.    (line   6)
* changing file timestamps:              touch invocation.    (line   6)
* changing group ownership <1>:          chgrp invocation.    (line   6)
* changing group ownership:              chown invocation.    (line   6)
* changing security context:             chcon invocation.    (line   6)
* changing special mode bits:            Changing Special Mode Bits.
                                                              (line   6)
* character classes:                     Character sets.      (line  80)
* character count:                       wc invocation.       (line   6)
* character size:                        Control.             (line  20)
* character special check:               File type tests.     (line  14)
* character special files:               mknod invocation.    (line  13)
* character special files, creating:     mknod invocation.    (line   6)
* characters, special:                   Characters.          (line   6)
* chcon:                                 chcon invocation.    (line   6)
* check file types:                      test invocation.     (line   6)
* checking for sortedness:               sort invocation.     (line  23)
* checksum, 128-bit:                     md5sum invocation.   (line   6)
* checksum, 16-bit:                      sum invocation.      (line   6)
* checksum, 160-bit:                     sha1sum invocation.  (line   6)
* checksum, 224-bit:                     sha2 utilities.      (line   6)
* checksum, 256-bit:                     sha2 utilities.      (line   6)
* checksum, 384-bit:                     sha2 utilities.      (line   6)
* checksum, 512-bit:                     sha2 utilities.      (line   6)
* chgrp:                                 chgrp invocation.    (line   6)
* chmod:                                 chmod invocation.    (line   6)
* chown:                                 chown invocation.    (line   6)
* chroot:                                chroot invocation.   (line   6)
* cio:                                   dd invocation.       (line 197)
* cksum:                                 cksum invocation.    (line   6)
* clocal:                                Control.             (line  35)
* clock skew <1>:                        touch invocation.    (line  20)
* clock skew:                            Formatting file timestamps.
                                                              (line  12)
* clone:                                 cp invocation.       (line 298)
* cntrl:                                 Character sets.      (line 102)
* color database, printing:              dircolors invocation.
                                                              (line  48)
* color setup:                           dircolors invocation.
                                                              (line   6)
* color, distinguishing file types with: General output formatting.
                                                              (line  22)
* cols:                                  Special.             (line  27)
* column to wrap data after:             base64 invocation.   (line  25)
* COLUMNS:                               Special.             (line  30)
* columns:                               Special.             (line  27)
* COLUMNS:                               General output formatting.
                                                              (line 134)
* combination settings:                  Combination.         (line   6)
* combined date and time of day item:    Combined date and time of day items.
                                                              (line   6)
* comm:                                  comm invocation.     (line   6)
* command-line operands to shuffle:      shuf invocation.     (line  21)
* commands for controlling processes:    Process control.     (line   6)
* commands for delaying:                 Delaying.            (line   6)
* commands for exit status:              Conditions.          (line   6)
* commands for file name manipulation:   File name manipulation.
                                                              (line   6)
* commands for invoking other commands:  Modified command invocation.
                                                              (line   6)
* commands for printing text:            Printing text.       (line   6)
* commands for printing the working context: Working context. (line   6)
* commands for printing user information: User information.   (line   6)
* commands for redirection:              Redirection.         (line   6)
* commands for SELinux context:          SELinux context.     (line   6)
* commands for system context:           System context.      (line   6)
* commas, outputting between files:      General output formatting.
                                                              (line 106)
* comments, in dates:                    General date syntax. (line  69)
* common field, joining on:              join invocation.     (line   6)
* common lines:                          comm invocation.     (line  19)
* common options:                        Common options.      (line   6)
* compare values:                        test invocation.     (line   6)
* comparing sorted files:                comm invocation.     (line   6)
* comparison operators:                  Relations for expr.  (line  21)
* concatenate and write files:           cat invocation.      (line   6)
* concurrent I/O:                        dd invocation.       (line 197)
* conditional executability:             Conditional Executability.
                                                              (line   6)
* conditions:                            Conditions.          (line   6)
* conflicts with shell built-ins <1>:    sleep invocation.    (line  36)
* conflicts with shell built-ins <2>:    kill invocation.     (line  16)
* conflicts with shell built-ins <3>:    nice invocation.     (line  42)
* conflicts with shell built-ins <4>:    pwd invocation.      (line  33)
* conflicts with shell built-ins <5>:    test invocation.     (line  28)
* conflicts with shell built-ins <6>:    printf invocation.   (line  18)
* conflicts with shell built-ins <7>:    echo invocation.     (line  13)
* conflicts with shell built-ins <8>:    stat invocation.     (line  18)
* conflicts with shell built-ins:        mknod invocation.    (line  27)
* connectives, logical <1>:              Relations for expr.  (line   6)
* connectives, logical:                  Connectives for test.
                                                              (line   6)
* context splitting:                     csplit invocation.   (line   6)
* context, system:                       System context.      (line   6)
* control characters, using ^C:          Local.               (line  54)
* control settings:                      Control.             (line   6)
* controlling terminal:                  dd invocation.       (line 258)
* conv:                                  dd invocation.       (line  76)
* conversion block size:                 dd invocation.       (line  42)
* conversion specifiers, date:           Date conversion specifiers.
                                                              (line   6)
* conversion specifiers, literal:        Literal conversion specifiers.
                                                              (line   6)
* conversion specifiers, time:           Time conversion specifiers.
                                                              (line   6)
* converting tabs to spaces:             expand invocation.   (line   6)
* converting while copying a file:       dd invocation.       (line   6)
* cooked:                                Combination.         (line  36)
* Coordinated Universal Time:            Options for date.    (line 111)
* copy on write:                         cp invocation.       (line 298)
* copying directories recursively:       cp invocation.       (line 109)
* copying existing permissions:          Copying Permissions. (line   6)
* copying files:                         cat invocation.      (line   6)
* copying files and directories:         cp invocation.       (line   6)
* copying files and setting attributes:  install invocation.  (line   6)
* core utilities:                        Top.                 (line  24)
* count:                                 dd invocation.       (line  57)
* count_bytes:                           dd invocation.       (line 286)
* COW:                                   cp invocation.       (line 298)
* cp:                                    cp invocation.       (line   6)
* crashes and corruption:                sync invocation.     (line  12)
* CRC checksum:                          cksum invocation.    (line   6)
* cread:                                 Control.             (line  32)
* creating directories:                  mkdir invocation.    (line   6)
* creating FIFOs (named pipes):          mkfifo invocation.   (line   6)
* creating links (hard only):            link invocation.     (line   6)
* creating links (hard or soft):         ln invocation.       (line   6)
* creating output file, avoiding:        dd invocation.       (line 153)
* creating output file, requiring:       dd invocation.       (line 148)
* crN:                                   Output.              (line  46)
* crown margin:                          fmt invocation.      (line  38)
* crt:                                   Combination.         (line  75)
* crterase:                              Local.               (line  22)
* crtkill:                               Local.               (line  59)
* crtscts:                               Control.             (line  38)
* csh syntax for color setup:            dircolors invocation.
                                                              (line  43)
* csN:                                   Control.             (line  20)
* csplit:                                csplit invocation.   (line   6)
* cstopb:                                Control.             (line  28)
* ctime, printing or sorting by:         Sorting the output.  (line  13)
* ctime, show the most recent:           du invocation.       (line 164)
* ctlecho:                               Local.               (line  54)
* current working directory, printing:   pwd invocation.      (line   6)
* cut:                                   cut invocation.      (line   6)
* cyclic redundancy check:               cksum invocation.    (line   6)
* data, erasing:                         shred invocation.    (line   6)
* database for color setup, printing:    dircolors invocation.
                                                              (line  48)
* date:                                  date invocation.     (line   6)
* date and time of day format, ISO 8601: Combined date and time of day items.
                                                              (line  15)
* date conversion specifiers:            Date conversion specifiers.
                                                              (line   6)
* date format, ISO 8601:                 Calendar date items. (line  32)
* date input formats:                    Date input formats.  (line   6)
* date options:                          Options for date.    (line   6)
* date strings, parsing:                 Options for date.    (line  11)
* day in date strings:                   Relative items in date strings.
                                                              (line  15)
* day of week item:                      Day of week items.   (line   6)
* dd:                                    dd invocation.       (line   6)
* dec:                                   Combination.         (line  78)
* decctlq:                               Combination.         (line  63)
* Decode base64 data:                    base64 invocation.   (line  33)
* delay for a specified time:            sleep invocation.    (line   6)
* delaying commands:                     Delaying.            (line   6)
* deleting characters:                   Squeezing.           (line   6)
* dereferencing symbolic links:          ln invocation.       (line  49)
* descriptor follow option:              tail invocation.     (line  51)
* destination directory <1>:             ln invocation.       (line 183)
* destination directory <2>:             mv invocation.       (line 115)
* destination directory <3>:             install invocation.  (line 132)
* destination directory <4>:             cp invocation.       (line 384)
* destination directory:                 Target directory.    (line  15)
* destinations, multiple output:         tee invocation.      (line   6)
* device file, disk:                     df invocation.       (line  23)
* df:                                    df invocation.       (line   6)
* DF_BLOCK_SIZE:                         Block size.          (line  12)
* diagnostic:                            chcon invocation.    (line  48)
* dictionary order:                      sort invocation.     (line 100)
* differing lines:                       comm invocation.     (line  19)
* digit:                                 Character sets.      (line 105)
* dir:                                   dir invocation.      (line   6)
* dircolors:                             dircolors invocation.
                                                              (line   6)
* direct:                                dd invocation.       (line 204)
* direct I/O:                            dd invocation.       (line 204)
* directories, copying:                  cp invocation.       (line   6)
* directories, copying recursively:      cp invocation.       (line 109)
* directories, creating:                 mkdir invocation.    (line   6)
* directories, creating with given attributes: install invocation.
                                                              (line  69)
* directories, removing:                 rm invocation.       (line  39)
* directories, removing (recursively):   rm invocation.       (line 103)
* directories, removing empty:           rmdir invocation.    (line   6)
* directory:                             dd invocation.       (line 212)
* directory check:                       File type tests.     (line  17)
* directory components, printing:        dirname invocation.  (line   6)
* directory deletion, ignoring failures: rmdir invocation.    (line  19)
* directory deletion, reporting:         rmdir invocation.    (line  33)
* directory I/O:                         dd invocation.       (line 212)
* directory listing:                     ls invocation.       (line   6)
* directory listing, brief:              dir invocation.      (line   6)
* directory listing, recursive:          Which files are listed.
                                                              (line  98)
* directory listing, verbose:            vdir invocation.     (line   6)
* directory order, listing by:           Sorting the output.  (line  20)
* directory, creating temporary:         mktemp invocation.   (line   6)
* directory, stripping from file names:  basename invocation. (line   6)
* dired Emacs mode support:              What information is listed.
                                                              (line  17)
* dirname:                               dirname invocation.  (line   6)
* disabling special characters:          Characters.          (line  13)
* disambiguating group names and IDs:    Disambiguating names and IDs.
                                                              (line   6)
* discarding file cache:                 dd invocation.       (line 229)
* disk allocation:                       What information is listed.
                                                              (line 256)
* disk device file:                      df invocation.       (line  23)
* disk usage:                            Disk usage.          (line   6)
* disk usage by file system:             df invocation.       (line   6)
* disk usage for files:                  du invocation.       (line   6)
* diskette file system:                  df invocation.       (line 157)
* displacement of dates:                 Relative items in date strings.
                                                              (line   6)
* displaying text:                       echo invocation.     (line   6)
* displaying value of a symbolic link:   readlink invocation. (line   6)
* division:                              Numeric expressions. (line  15)
* do nothing, successfully:              true invocation.     (line   6)
* do nothing, unsuccessfully:            false invocation.    (line   6)
* DOS file system:                       df invocation.       (line 157)
* double spacing:                        pr invocation.       (line 103)
* down columns:                          pr invocation.       (line  75)
* dsusp:                                 Characters.          (line  53)
* dsync:                                 dd invocation.       (line 217)
* du:                                    du invocation.       (line   6)
* DU_BLOCK_SIZE:                         Block size.          (line  12)
* ebcdic, converting to:                 dd invocation.       (line  87)
* echo <1>:                              Local.               (line  18)
* echo:                                  echo invocation.     (line   6)
* echoctl:                               Local.               (line  54)
* echoe:                                 Local.               (line  22)
* echok:                                 Local.               (line  26)
* echoke:                                Local.               (line  59)
* echonl:                                Local.               (line  29)
* echoprt:                               Local.               (line  49)
* effective user and group IDs, printing: id invocation.      (line   6)
* effective user ID, printing:           whoami invocation.   (line   6)
* efs file system type:                  df invocation.       (line 147)
* Eggert, Paul:                          Authors of parse_datetime.
                                                              (line   6)
* eight-bit characters <1>:              Combination.         (line  55)
* eight-bit characters:                  Control.             (line  20)
* eight-bit input:                       Input.               (line  25)
* ek:                                    Combination.         (line  22)
* empty files, creating:                 touch invocation.    (line  13)
* empty lines, numbering:                nl invocation.       (line  89)
* entire files, output of:               Output of entire files.
                                                              (line   6)
* env:                                   env invocation.      (line   6)
* environment variables, printing:       printenv invocation. (line   6)
* environment, printing:                 env invocation.      (line  52)
* environment, running a program in a modified: env invocation.
                                                              (line   6)
* eof:                                   Characters.          (line  32)
* eol:                                   Characters.          (line  35)
* eol2:                                  Characters.          (line  38)
* epoch, for POSIX:                      Seconds since the Epoch.
                                                              (line  13)
* epoch, seconds since:                  Time conversion specifiers.
                                                              (line  42)
* equal string check:                    String tests.        (line  22)
* equivalence classes:                   Character sets.      (line 131)
* erase:                                 Characters.          (line  26)
* erasing data:                          shred invocation.    (line   6)
* error messages, omitting <1>:          chmod invocation.    (line  50)
* error messages, omitting <2>:          chgrp invocation.    (line  29)
* error messages, omitting:              chown invocation.    (line  80)
* evaluation of expressions:             expr invocation.     (line   6)
* even parity:                           Control.             (line  13)
* evenp:                                 Combination.         (line   9)
* exabyte, definition of:                Block size.          (line 125)
* examples of date:                      Examples of date.    (line   6)
* examples of expr:                      Examples of expr.    (line   6)
* exbibyte, definition of:               Block size.          (line 129)
* excl:                                  dd invocation.       (line 148)
* excluding files from du:               du invocation.       (line 220)
* executable file check:                 Access permission tests.
                                                              (line  24)
* executables and file type, marking:    General output formatting.
                                                              (line  55)
* execute/search permission:             Mode Structure.      (line  21)
* execute/search permission, symbolic:   Setting Permissions. (line  63)
* existence-of-file check:               File characteristic tests.
                                                              (line   9)
* existing backup method:                Backup options.      (line  41)
* exit status commands:                  Conditions.          (line   6)
* exit status of chroot:                 chroot invocation.   (line  67)
* exit status of env:                    env invocation.      (line 104)
* exit status of expr:                   expr invocation.     (line  48)
* exit status of false:                  false invocation.    (line   6)
* exit status of ls:                     ls invocation.       (line  32)
* exit status of mktemp:                 mktemp invocation.   (line 145)
* exit status of nice:                   nice invocation.     (line  63)
* exit status of nohup:                  nohup invocation.    (line  51)
* exit status of pathchk:                pathchk invocation.  (line  55)
* exit status of printenv:               printenv invocation. (line  26)
* exit status of realpath:               realpath invocation. (line  92)
* exit status of runcon:                 runcon invocation.   (line  46)
* exit status of sort:                   sort invocation.     (line  67)
* exit status of stdbuf:                 stdbuf invocation.   (line  71)
* exit status of test:                   test invocation.     (line  43)
* exit status of timeout:                timeout invocation.  (line  57)
* exit status of true:                   true invocation.     (line   6)
* exit status of tty:                    tty invocation.      (line  22)
* expand:                                expand invocation.   (line   6)
* expr:                                  expr invocation.     (line   6)
* expression evaluation <1>:             expr invocation.     (line   6)
* expression evaluation:                 test invocation.     (line   6)
* expressions, numeric:                  Numeric expressions. (line   6)
* expressions, string:                   String expressions.  (line   6)
* extended attributes, xattr <1>:        mv invocation.       (line  39)
* extended attributes, xattr:            install invocation.  (line  39)
* extension, sorting files by:           Sorting the output.  (line  69)
* factor:                                factor invocation.   (line   6)
* failure exit status:                   false invocation.    (line   6)
* false:                                 false invocation.    (line   6)
* fdatasync:                             dd invocation.       (line 166)
* ffN:                                   Output.              (line  64)
* field separator character:             sort invocation.     (line 366)
* fields, padding numeric:               Padding and other flags.
                                                              (line   6)
* FIFOs, creating:                       mkfifo invocation.   (line   6)
* file attributes, changing:             Changing file attributes.
                                                              (line   6)
* file characteristic tests:             File characteristic tests.
                                                              (line   6)
* file contents, dumping unambiguously:  od invocation.       (line   6)
* file information, preserving:          cp invocation.       (line 266)
* file information, preserving, extended attributes, xattr: cp invocation.
                                                              (line 191)
* file mode bits, numeric:               Numeric Modes.       (line   6)
* file name manipulation:                File name manipulation.
                                                              (line   6)
* file names, canonicalization:          realpath invocation. (line   6)
* file names, checking validity and portability: pathchk invocation.
                                                              (line   6)
* file names, creating temporary:        mktemp invocation.   (line   6)
* file names, stripping directory and suffix: basename invocation.
                                                              (line   6)
* file offset radix:                     od invocation.       (line  44)
* file ownership, changing:              chown invocation.    (line   6)
* file sizes:                            du invocation.       (line  53)
* file space usage:                      du invocation.       (line   6)
* file status:                           stat invocation.     (line   6)
* file system disk usage:                df invocation.       (line   6)
* file system sizes:                     df invocation.       (line  44)
* file system space, retrieving current data more slowly: df invocation.
                                                              (line 118)
* file system space, retrieving old data more quickly: df invocation.
                                                              (line  83)
* file system status:                    stat invocation.     (line   6)
* file system types, limiting output to certain: df invocation.
                                                              (line  79)
* file system types, printing:           df invocation.       (line 134)
* file systems:                          stat invocation.     (line  33)
* file systems and hard links:           ln invocation.       (line   6)
* file systems, omitting copying to different: cp invocation. (line 413)
* file timestamp resolution:             touch invocation.    (line  31)
* file timestamps, changing:             touch invocation.    (line   6)
* file type and executables, marking:    General output formatting.
                                                              (line  55)
* file type tests:                       File type tests.     (line   6)
* file type, marking:                    General output formatting.
                                                              (line  67)
* file types:                            Special file types.  (line  10)
* file types, special:                   Special file types.  (line   6)
* file utilities:                        Top.                 (line  24)
* files beginning with -, removing:      rm invocation.       (line 110)
* files, copying:                        cp invocation.       (line   6)
* files, creating:                       truncate invocation. (line  13)
* fingerprint, 128-bit:                  md5sum invocation.   (line   6)
* fingerprint, 160-bit:                  sha1sum invocation.  (line   6)
* fingerprint, 224-bit:                  sha2 utilities.      (line   6)
* fingerprint, 256-bit:                  sha2 utilities.      (line   6)
* fingerprint, 384-bit:                  sha2 utilities.      (line   6)
* fingerprint, 512-bit:                  sha2 utilities.      (line   6)
* first in date strings:                 General date syntax. (line  28)
* first part of files, outputting:       head invocation.     (line   6)
* fixed-length records, converting to variable-length: dd invocation.
                                                              (line  42)
* floating point:                        Floating point.      (line   6)
* flow control, hardware:                Control.             (line  38)
* flow control, software:                Input.               (line  46)
* flushing, disabling:                   Local.               (line  33)
* fmt:                                   fmt invocation.      (line   6)
* fold:                                  fold invocation.     (line   6)
* folding long input lines:              fold invocation.     (line   6)
* footers, numbering:                    nl invocation.       (line  19)
* force deletion:                        shred invocation.    (line 114)
* formatting file contents:              Formatting file contents.
                                                              (line   6)
* formatting of numbers in seq:          seq invocation.      (line  26)
* formatting times <1>:                  date invocation.     (line  21)
* formatting times:                      pr invocation.       (line 107)
* fortnight in date strings:             Relative items in date strings.
                                                              (line  15)
* fsync:                                 dd invocation.       (line 170)
* fullblock:                             dd invocation.       (line 279)
* general date syntax:                   General date syntax. (line   6)
* general numeric sort:                  sort invocation.     (line 123)
* gibibyte, definition of:               Block size.          (line 108)
* gigabyte, definition of:               Block size.          (line 104)
* giving away permissions:               Umask and Protection.
                                                              (line  15)
* GMT:                                   Options for date.    (line 111)
* grand total of disk size, usage and available space: df invocation.
                                                              (line  49)
* grand total of disk space:             du invocation.       (line  59)
* graph:                                 Character sets.      (line 108)
* Greenwich Mean Time:                   Options for date.    (line 111)
* group IDs, disambiguating:             Disambiguating names and IDs.
                                                              (line   6)
* group names, disambiguating:           Disambiguating names and IDs.
                                                              (line   6)
* group owner, default:                  Mode Structure.      (line  34)
* group ownership of installed files, setting: install invocation.
                                                              (line  76)
* group ownership, changing <1>:         chgrp invocation.    (line   6)
* group ownership, changing:             chown invocation.    (line   6)
* group, permissions for:                Setting Permissions. (line  26)
* groups:                                groups invocation.   (line   6)
* growing files:                         tail invocation.     (line  51)
* hangups, immunity to:                  nohup invocation.    (line   6)
* hard link check:                       File characteristic tests.
                                                              (line  23)
* hard link, defined:                    ln invocation.       (line  37)
* hard links:                            dd invocation.       (line 267)
* hard links to directories:             ln invocation.       (line 102)
* hard links to symbolic links:          ln invocation.       (line 196)
* hard links, counting in du:            du invocation.       (line 103)
* hard links, creating <1>:              ln invocation.       (line   6)
* hard links, creating:                  link invocation.     (line   6)
* hard links, preserving:                cp invocation.       (line 124)
* hardware class:                        uname invocation.    (line  50)
* hardware flow control:                 Control.             (line  38)
* hardware platform:                     uname invocation.    (line  43)
* hardware type:                         uname invocation.    (line  50)
* hat notation for control characters:   Local.               (line  54)
* head:                                  head invocation.     (line   6)
* head of output:                        shuf invocation.     (line  34)
* headers, numbering:                    nl invocation.       (line  19)
* help, online:                          Common options.      (line  40)
* hex dump of files:                     od invocation.       (line   6)
* High Sierra file system:               df invocation.       (line 152)
* holes, copying files with:             cp invocation.       (line 330)
* holes, creating files with:            truncate invocation. (line  15)
* horizontal, listing files:             General output formatting.
                                                              (line 116)
* host processor type:                   uname invocation.    (line  59)
* hostid:                                hostid invocation.   (line   6)
* hostname <1>:                          hostname invocation. (line   6)
* hostname:                              uname invocation.    (line  55)
* hour in date strings:                  Relative items in date strings.
                                                              (line  15)
* hsfs file system type:                 df invocation.       (line 152)
* human numeric sort:                    sort invocation.     (line 146)
* human-readable output <1>:             du invocation.       (line  87)
* human-readable output <2>:             df invocation.       (line  56)
* human-readable output <3>:             What information is listed.
                                                              (line 122)
* human-readable output:                 Block size.          (line  44)
* hup[cl]:                               Control.             (line  24)
* hurd, author, printing:                What information is listed.
                                                              (line  10)
* ibs:                                   dd invocation.       (line  27)
* icanon:                                Local.               (line  11)
* icrnl:                                 Input.               (line  35)
* id:                                    id invocation.       (line   6)
* idle time:                             who invocation.      (line  88)
* IEEE floating point:                   Floating point.      (line   6)
* iexten:                                Local.               (line  15)
* if:                                    dd invocation.       (line  19)
* iflag:                                 dd invocation.       (line 176)
* ignbrk:                                Input.               (line   9)
* igncr:                                 Input.               (line  32)
* ignore file systems:                   df invocation.       (line  37)
* Ignore garbage in base64 stream:       base64 invocation.   (line  40)
* ignoring case:                         sort invocation.     (line 107)
* ignpar:                                Input.               (line  15)
* imaxbel:                               Input.               (line  61)
* immunity to hangups:                   nohup invocation.    (line   6)
* implementation, hardware:              uname invocation.    (line  43)
* indenting lines:                       pr invocation.       (line 210)
* index:                                 String expressions.  (line  45)
* information, about current users:      who invocation.      (line   6)
* initial part of files, outputting:     head invocation.     (line   6)
* initial tabs, converting:              expand invocation.   (line  37)
* inlcr:                                 Input.               (line  28)
* inode number, printing:                What information is listed.
                                                              (line 130)
* inode usage:                           df invocation.       (line  67)
* inode, and hard links:                 ln invocation.       (line  37)
* inodes, written buffered:              sync invocation.     (line   6)
* inpck:                                 Input.               (line  22)
* input block size:                      dd invocation.       (line  27)
* input encoding, UTF-8:                 Input.               (line  38)
* input range to shuffle:                shuf invocation.     (line  25)
* input settings:                        Input.               (line   6)
* input tabs:                            pr invocation.       (line 127)
* install:                               install invocation.  (line   6)
* intr:                                  Characters.          (line  20)
* invocation of commands, modified:      Modified command invocation.
                                                              (line   6)
* isig:                                  Local.               (line   7)
* ISO 8601 date and time of day format:  Combined date and time of day items.
                                                              (line  15)
* ISO 8601 date format:                  Calendar date items. (line  32)
* ISO/IEC 10646:                         printf invocation.   (line  78)
* ispeed:                                Special.             (line  17)
* istrip:                                Input.               (line  25)
* items in date strings:                 General date syntax. (line   6)
* iterations, selecting the number of:   shred invocation.    (line 119)
* iuclc:                                 Input.               (line  51)
* iutf8:                                 Input.               (line  38)
* ixany:                                 Input.               (line  57)
* ixoff:                                 Input.               (line  46)
* ixon:                                  Input.               (line  41)
* join:                                  join invocation.     (line   6)
* kernel name:                           uname invocation.    (line  74)
* kernel release:                        uname invocation.    (line  70)
* kernel version:                        uname invocation.    (line  85)
* kibibyte, definition of:               Block size.          (line  90)
* kibibytes for file sizes:              du invocation.       (line  97)
* kibibytes for file system sizes:       df invocation.       (line  73)
* kill <1>:                              kill invocation.     (line   6)
* kill:                                  Characters.          (line  29)
* kilobyte, definition of:               Block size.          (line  85)
* Knuth, Donald E.:                      fmt invocation.      (line  21)
* language, in dates:                    General date syntax. (line  44)
* last DAY <1>:                          Day of week items.   (line  15)
* last DAY:                              Options for date.    (line  11)
* last in date strings:                  General date syntax. (line  28)
* last modified dates, displaying in du: du invocation.       (line 158)
* last part of files, outputting:        tail invocation.     (line   6)
* LC_ALL <1>:                            ls invocation.       (line  18)
* LC_ALL:                                sort invocation.     (line  58)
* LC_COLLATE <1>:                        Relations for expr.  (line  21)
* LC_COLLATE <2>:                        join invocation.     (line  18)
* LC_COLLATE <3>:                        comm invocation.     (line  13)
* LC_COLLATE <4>:                        uniq invocation.     (line  23)
* LC_COLLATE:                            sort invocation.     (line  58)
* LC_CTYPE <1>:                          printf invocation.   (line  78)
* LC_CTYPE:                              sort invocation.     (line  91)
* LC_MESSAGES:                           pr invocation.       (line  16)
* LC_NUMERIC <1>:                        printf invocation.   (line  65)
* LC_NUMERIC <2>:                        sort invocation.     (line 123)
* LC_NUMERIC <3>:                        Floating point.      (line  17)
* LC_NUMERIC:                            Block size.          (line  63)
* LC_TIME <1>:                           date invocation.     (line  11)
* LC_TIME <2>:                           du invocation.       (line 180)
* LC_TIME <3>:                           Formatting file timestamps.
                                                              (line  31)
* LC_TIME <4>:                           sort invocation.     (line 170)
* LC_TIME:                               pr invocation.       (line 114)
* LCASE:                                 Combination.         (line  71)
* lcase:                                 Combination.         (line  71)
* lcase, converting to:                  dd invocation.       (line 110)
* lchown <1>:                            chgrp invocation.    (line  33)
* lchown:                                chown invocation.    (line 110)
* leading directories, creating missing: install invocation.  (line  69)
* leading directory components, stripping: basename invocation.
                                                              (line   6)
* leap seconds <1>:                      Seconds since the Epoch.
                                                              (line  29)
* leap seconds <2>:                      Time of day items.   (line  14)
* leap seconds <3>:                      General date syntax. (line  75)
* leap seconds <4>:                      Examples of date.    (line 105)
* leap seconds <5>:                      Options for date.    (line 111)
* leap seconds <6>:                      Time conversion specifiers.
                                                              (line  42)
* leap seconds:                          touch invocation.    (line 142)
* left margin:                           pr invocation.       (line 210)
* length:                                String expressions.  (line  49)
* limiting output of du:                 du invocation.       (line 124)
* line:                                  Special.             (line  37)
* line buffered:                         stdbuf invocation.   (line   6)
* line count:                            wc invocation.       (line   6)
* line numbering:                        nl invocation.       (line   6)
* line settings of terminal:             stty invocation.     (line   6)
* line-breaking:                         fmt invocation.      (line  21)
* line-by-line comparison:               comm invocation.     (line   6)
* LINES:                                 Special.             (line  30)
* link:                                  link invocation.     (line   6)
* links, creating <1>:                   ln invocation.       (line   6)
* links, creating:                       link invocation.     (line   6)
* Linux file system types:               df invocation.       (line 147)
* literal conversion specifiers:         Literal conversion specifiers.
                                                              (line   6)
* litout:                                Combination.         (line  59)
* ln:                                    ln invocation.       (line   6)
* ln format for nl:                      nl invocation.       (line  99)
* lnext:                                 Characters.          (line  62)
* local file system types:               df invocation.       (line 147)
* local settings:                        Local.               (line   6)
* logging out and continuing to run:     nohup invocation.    (line   6)
* logical and operator <1>:              Relations for expr.  (line  17)
* logical and operator:                  Connectives for test.
                                                              (line  12)
* logical connectives <1>:               Relations for expr.  (line   6)
* logical connectives:                   Connectives for test.
                                                              (line   6)
* logical or operator <1>:               Relations for expr.  (line  11)
* logical or operator:                   Connectives for test.
                                                              (line  15)
* logical pages, numbering on:           nl invocation.       (line  14)
* login name, printing:                  logname invocation.  (line   6)
* login sessions, printing users with:   users invocation.    (line   6)
* login time:                            who invocation.      (line  12)
* logname:                               logname invocation.  (line   6)
* long ls format:                        What information is listed.
                                                              (line 138)
* lower:                                 Character sets.      (line 112)
* lowercase, translating to output:      Output.              (line  13)
* ls:                                    ls invocation.       (line   6)
* LS_BLOCK_SIZE:                         Block size.          (line  12)
* LS_COLORS <1>:                         dircolors invocation.
                                                              (line  25)
* LS_COLORS:                             General output formatting.
                                                              (line  36)
* lutimes:                               touch invocation.    (line 111)
* machine type:                          uname invocation.    (line  50)
* machine-readable stty output:          stty invocation.     (line  46)
* MacKenzie, D.:                         Introduction.        (line  22)
* MacKenzie, David:                      Authors of parse_datetime.
                                                              (line   6)
* Makefiles, installing programs in:     install invocation.  (line  34)
* manipulating files:                    Basic operations.    (line   6)
* manipulation of file names:            File name manipulation.
                                                              (line   6)
* match:                                 String expressions.  (line  36)
* matching patterns:                     String expressions.  (line  11)
* MD5:                                   md5sum invocation.   (line   6)
* md5sum:                                md5sum invocation.   (line   6)
* mebibyte, definition of:               Block size.          (line 101)
* mebibytes for file sizes:              du invocation.       (line 112)
* megabyte, definition of:               Block size.          (line  97)
* merging files:                         paste invocation.    (line   6)
* merging files in parallel:             pr invocation.       (line   6)
* merging sorted files:                  sort invocation.     (line  39)
* message status:                        who invocation.      (line  97)
* message-digest, 128-bit:               md5sum invocation.   (line   6)
* message-digest, 160-bit:               sha1sum invocation.  (line   6)
* message-digest, 224-bit:               sha2 utilities.      (line   6)
* message-digest, 256-bit:               sha2 utilities.      (line   6)
* message-digest, 384-bit:               sha2 utilities.      (line   6)
* message-digest, 512-bit:               sha2 utilities.      (line   6)
* Meyering, J.:                          Introduction.        (line  22)
* Meyering, Jim:                         Authors of parse_datetime.
                                                              (line   6)
* midnight in date strings:              Time of day items.   (line  21)
* min:                                   Special.             (line   7)
* minute in date strings:                Relative items in date strings.
                                                              (line  15)
* minutes, time zone correction by:      Time of day items.   (line  29)
* mkdir:                                 mkdir invocation.    (line   6)
* mkfifo:                                mkfifo invocation.   (line   6)
* mknod:                                 mknod invocation.    (line   6)
* mktemp:                                mktemp invocation.   (line   6)
* modem control:                         Control.             (line  35)
* modes and umask:                       Umask and Protection.
                                                              (line   6)
* modes of created directories, setting: mkdir invocation.    (line  22)
* modes of created FIFOs, setting:       mkfifo invocation.   (line  24)
* modification time, sorting files by:   Sorting the output.  (line  38)
* modified command invocation:           Modified command invocation.
                                                              (line   6)
* modified environment, running a program in a: env invocation.
                                                              (line   6)
* modify time, changing:                 touch invocation.    (line 128)
* month in date strings:                 Relative items in date strings.
                                                              (line  15)
* month names in date strings:           Calendar date items. (line  40)
* months, sorting by:                    sort invocation.     (line 170)
* months, written-out:                   General date syntax. (line  38)
* MS-DOS file system:                    df invocation.       (line 157)
* mtime, changing:                       touch invocation.    (line 128)
* multicolumn output, generating:        pr invocation.       (line   6)
* multiple changes to permissions:       Multiple Changes.    (line   6)
* multiplication:                        Numeric expressions. (line  15)
* multipliers after numbers:             dd invocation.       (line 313)
* multithreaded sort:                    sort invocation.     (line 395)
* mv:                                    mv invocation.       (line   6)
* name follow option:                    tail invocation.     (line  51)
* name of kernel:                        uname invocation.    (line  74)
* named pipe check:                      File type tests.     (line  29)
* named pipes, creating:                 mkfifo invocation.   (line   6)
* network node name:                     uname invocation.    (line  55)
* never interactive option:              rm invocation.       (line  62)
* newer files, copying only:             cp invocation.       (line 394)
* newer files, moving only:              mv invocation.       (line  91)
* newer-than file check:                 File characteristic tests.
                                                              (line  15)
* newline echoing after kill:            Local.               (line  26)
* newline, echoing:                      Local.               (line  29)
* newline, translating to crlf:          Output.              (line  21)
* newline, translating to return:        Input.               (line  28)
* next DAY <1>:                          Day of week items.   (line  15)
* next DAY:                              Options for date.    (line  11)
* next in date strings:                  General date syntax. (line  28)
* NFS file system type:                  df invocation.       (line 142)
* NFS mounts from BSD to HP-UX <1>:      du invocation.       (line 231)
* NFS mounts from BSD to HP-UX:          What information is listed.
                                                              (line 264)
* nice:                                  nice invocation.     (line   6)
* niceness:                              nice invocation.     (line   6)
* nl <1>:                                Combination.         (line  18)
* nl:                                    nl invocation.       (line   6)
* nlN:                                   Output.              (line  40)
* no dereference:                        chcon invocation.    (line  22)
* no-op:                                 true invocation.     (line   6)
* noatime:                               dd invocation.       (line 252)
* nocache:                               dd invocation.       (line 229)
* nocreat:                               dd invocation.       (line 153)
* noctty:                                dd invocation.       (line 258)
* node name:                             uname invocation.    (line  55)
* noerror:                               dd invocation.       (line 163)
* noflsh:                                Local.               (line  33)
* nofollow:                              dd invocation.       (line 264)
* nohup:                                 nohup invocation.    (line   6)
* nolinks:                               dd invocation.       (line 267)
* non-directories, copying as special files: cp invocation.   (line 109)
* non-directory suffix, stripping:       dirname invocation.  (line   6)
* nonblock:                              dd invocation.       (line 249)
* nonblocking I/O:                       dd invocation.       (line 249)
* none backup method:                    Backup options.      (line  33)
* none color option:                     General output formatting.
                                                              (line  24)
* none dd status=:                       dd invocation.       (line  71)
* none, sorting option for ls:           Sorting the output.  (line  53)
* nonempty file check:                   File characteristic tests.
                                                              (line  12)
* nonprinting characters, ignoring:      sort invocation.     (line 162)
* nonzero-length string check:           String tests.        (line  19)
* noon in date strings:                  Time of day items.   (line  21)
* not-equal string check:                String tests.        (line  28)
* notrunc:                               dd invocation.       (line 159)
* now in date strings:                   Relative items in date strings.
                                                              (line  32)
* noxfer dd status=:                     dd invocation.       (line  67)
* nproc:                                 nproc invocation.    (line   6)
* number of inputs to merge, nmerge:     sort invocation.     (line 287)
* numbered backup method:                Backup options.      (line  37)
* numbering lines:                       nl invocation.       (line   6)
* numbers, written-out:                  General date syntax. (line  28)
* numeric expressions:                   Numeric expressions. (line   6)
* numeric field padding:                 Padding and other flags.
                                                              (line   6)
* numeric modes:                         Numeric Modes.       (line   6)
* numeric operations:                    Numeric operations.  (line   6)
* numeric sequences:                     seq invocation.      (line   6)
* numeric sort:                          sort invocation.     (line 181)
* numeric tests:                         Numeric tests.       (line   6)
* numeric uid and gid:                   What information is listed.
                                                              (line 246)
* numeric user and group IDs:            What information is listed.
                                                              (line 246)
* obs:                                   dd invocation.       (line  31)
* ocrnl:                                 Output.              (line  17)
* octal dump of files:                   od invocation.       (line   6)
* octal numbers for file modes:          Numeric Modes.       (line   6)
* od:                                    od invocation.       (line   6)
* odd parity:                            Control.             (line  13)
* oddp:                                  Combination.         (line  14)
* of:                                    dd invocation.       (line  22)
* ofdel:                                 Output.              (line  35)
* ofill:                                 Output.              (line  30)
* oflag:                                 dd invocation.       (line 180)
* olcuc:                                 Output.              (line  13)
* older-than file check:                 File characteristic tests.
                                                              (line  19)
* once interactive option:               rm invocation.       (line  64)
* one file system, restricting du to:    du invocation.       (line 216)
* one file system, restricting rm to:    rm invocation.       (line  73)
* one-line output format:                df invocation.       (line  91)
* onlcr:                                 Output.              (line  21)
* onlret:                                Output.              (line  27)
* onocr:                                 Output.              (line  24)
* operating on characters:               Operating on characters.
                                                              (line   6)
* operating on sorted files:             Operating on sorted files.
                                                              (line   6)
* operating system name:                 uname invocation.    (line  66)
* opost:                                 Output.              (line   9)
* option delimiter:                      Common options.      (line  46)
* options for date:                      Options for date.    (line   6)
* or operator <1>:                       Relations for expr.  (line  11)
* or operator:                           Connectives for test.
                                                              (line  15)
* ordinal numbers:                       General date syntax. (line  28)
* ospeed:                                Special.             (line  20)
* other permissions:                     Setting Permissions. (line  29)
* output block size:                     dd invocation.       (line  31)
* output file name prefix <1>:           csplit invocation.   (line  66)
* output file name prefix:               split invocation.    (line  19)
* output file name suffix:               csplit invocation.   (line  70)
* output format:                         stat invocation.     (line  39)
* output format, portable:               df invocation.       (line  91)
* output NUL-byte-terminated lines <1>:  env invocation.      (line  90)
* output NUL-byte-terminated lines <2>:  printenv invocation. (line  21)
* output NUL-byte-terminated lines:      du invocation.       (line 133)
* output of entire files:                Output of entire files.
                                                              (line   6)
* output of parts of files:              Output of parts of files.
                                                              (line   6)
* output settings:                       Output.              (line   6)
* output tabs:                           pr invocation.       (line 147)
* overwriting of input, allowed <1>:     shuf invocation.     (line  39)
* overwriting of input, allowed:         sort invocation.     (line 314)
* owned by effective group ID check:     Access permission tests.
                                                              (line  32)
* owned by effective user ID check:      Access permission tests.
                                                              (line  28)
* owner of file, permissions for:        Setting Permissions. (line  23)
* owner, default:                        Mode Structure.      (line  34)
* ownership of installed files, setting: install invocation.  (line  95)
* p for FIFO file:                       mknod invocation.    (line  36)
* pad character:                         Output.              (line  35)
* pad instead of timing for delaying:    Output.              (line  30)
* padding of numeric fields:             Padding and other flags.
                                                              (line   6)
* paragraphs, reformatting:              fmt invocation.      (line   6)
* parenb:                                Control.             (line   9)
* parent directories and cp:             cp invocation.       (line 270)
* parent directories, creating:          mkdir invocation.    (line  36)
* parent directories, creating missing:  install invocation.  (line  69)
* parent directories, removing:          rmdir invocation.    (line  24)
* parentheses for grouping:              expr invocation.     (line  36)
* parity:                                Combination.         (line  10)
* parity errors, marking:                Input.               (line  18)
* parity, ignoring:                      Input.               (line  15)
* parmrk:                                Input.               (line  18)
* parodd:                                Control.             (line  13)
* parse_datetime:                        Date input formats.  (line   6)
* parsing date strings:                  Options for date.    (line  11)
* parts of files, output of:             Output of parts of files.
                                                              (line   6)
* pass8:                                 Combination.         (line  55)
* paste:                                 paste invocation.    (line   6)
* Paterson, R.:                          Introduction.        (line  22)
* PATH:                                  env invocation.      (line  24)
* pathchk:                               pathchk invocation.  (line   6)
* pattern matching:                      String expressions.  (line  11)
* PC file system:                        df invocation.       (line 157)
* pcfs:                                  df invocation.       (line 157)
* pebibyte, definition of:               Block size.          (line 122)
* permission tests:                      Access permission tests.
                                                              (line   6)
* permissions of installed files, setting: install invocation.
                                                              (line  82)
* permissions, changing access:          chmod invocation.    (line   6)
* permissions, copying existing:         Copying Permissions. (line   6)
* permissions, for changing file timestamps: touch invocation.
                                                              (line  47)
* permissions, output by ls:             What information is listed.
                                                              (line 201)
* petabyte, definition of:               Block size.          (line 118)
* phone directory order:                 sort invocation.     (line 100)
* pieces, splitting a file into:         split invocation.    (line   6)
* Pinard, F. <1>:                        Authors of parse_datetime.
                                                              (line  19)
* Pinard, F.:                            Introduction.        (line  22)
* pipe fitting:                          tee invocation.      (line   6)
* Plass, Michael F.:                     fmt invocation.      (line  21)
* platform, hardware:                    uname invocation.    (line  43)
* pm in date strings:                    Time of day items.   (line  21)
* portable file names, checking for:     pathchk invocation.  (line   6)
* portable output format:                df invocation.       (line  91)
* POSIX:                                 Introduction.        (line  12)
* POSIX output format:                   df invocation.       (line  91)
* POSIXLY_CORRECT <1>:                   id invocation.       (line  13)
* POSIXLY_CORRECT <2>:                   printf invocation.   (line  55)
* POSIXLY_CORRECT <3>:                   echo invocation.     (line  81)
* POSIXLY_CORRECT <4>:                   dd invocation.       (line 358)
* POSIXLY_CORRECT <5>:                   sort invocation.     (line 324)
* POSIXLY_CORRECT <6>:                   pr invocation.       (line 114)
* POSIXLY_CORRECT <7>:                   Standards conformance.
                                                              (line   6)
* POSIXLY_CORRECT:                       Common options.      (line  11)
* POSIXLY_CORRECT, and block size:       Block size.          (line  12)
* pr:                                    pr invocation.       (line   6)
* prime factors:                         factor invocation.   (line   6)
* print:                                 Character sets.      (line 115)
* print machine hardware name:           arch invocation.     (line   6)
* print name of current directory:       pwd invocation.      (line   6)
* print system information:              uname invocation.    (line   6)
* print terminal file name:              tty invocation.      (line   6)
* Print the number of processors:        nproc invocation.    (line   6)
* printenv:                              printenv invocation. (line   6)
* printf:                                printf invocation.   (line   6)
* printing all or some environment variables: printenv invocation.
                                                              (line   6)
* printing color database:               dircolors invocation.
                                                              (line  48)
* printing current user information:     who invocation.      (line   6)
* printing current usernames:            users invocation.    (line   6)
* printing groups a user is in:          groups invocation.   (line   6)
* printing real and effective user and group IDs: id invocation.
                                                              (line   6)
* printing text:                         echo invocation.     (line   6)
* printing text, commands for:           Printing text.       (line   6)
* printing the current time:             date invocation.     (line   6)
* printing the effective user ID:        whoami invocation.   (line   6)
* printing the host identifier:          hostid invocation.   (line   6)
* printing the hostname:                 hostname invocation. (line   6)
* printing the system uptime and load:   uptime invocation.   (line   6)
* printing user's login name:            logname invocation.  (line   6)
* printing, preparing files for:         pr invocation.       (line   6)
* process zero-terminated items <1>:     uniq invocation.     (line 118)
* process zero-terminated items <2>:     shuf invocation.     (line  51)
* process zero-terminated items:         sort invocation.     (line 419)
* processes, commands for controlling:   Process control.     (line   6)
* prompting, and ln:                     ln invocation.       (line 113)
* prompting, and mv:                     mv invocation.       (line  44)
* prompting, and rm:                     rm invocation.       (line  13)
* prompts, forcing:                      mv invocation.       (line  78)
* prompts, omitting:                     mv invocation.       (line  72)
* prterase:                              Local.               (line  49)
* ptx:                                   ptx invocation.      (line   6)
* punct:                                 Character sets.      (line 119)
* pure numbers in date strings:          Pure numbers in date strings.
                                                              (line   6)
* pwd:                                   pwd invocation.      (line   6)
* quit:                                  Characters.          (line  23)
* quoting style:                         Formatting the file names.
                                                              (line  34)
* radix for file offsets:                od invocation.       (line  44)
* random sort:                           sort invocation.     (line 211)
* random source for shredding:           shred invocation.    (line 125)
* random source for shuffling:           shuf invocation.     (line  45)
* random source for sorting:             sort invocation.     (line 330)
* random sources:                        Random sources.      (line   6)
* ranges:                                Character sets.      (line  50)
* raw:                                   Combination.         (line  42)
* read errors, ignoring:                 dd invocation.       (line 163)
* read from stdin and write to stdout and files: tee invocation.
                                                              (line   6)
* read permission:                       Mode Structure.      (line  14)
* read permission, symbolic:             Setting Permissions. (line  57)
* read system call, and holes:           cp invocation.       (line 330)
* readable file check:                   Access permission tests.
                                                              (line  15)
* readlink:                              readlink invocation. (line   6)
* real user and group IDs, printing:     id invocation.       (line   6)
* realpath <1>:                          realpath invocation. (line   6)
* realpath:                              readlink invocation. (line   6)
* recursive directory listing:           Which files are listed.
                                                              (line  98)
* recursively changing access permissions: chmod invocation.  (line  75)
* recursively changing file ownership:   chown invocation.    (line 149)
* recursively changing group ownership:  chgrp invocation.    (line  71)
* recursively copying directories:       cp invocation.       (line 109)
* redirection:                           Redirection.         (line   6)
* reference file:                        chcon invocation.    (line  25)
* reformatting paragraph text:           fmt invocation.      (line   6)
* regular expression matching:           String expressions.  (line  11)
* regular file check:                    File type tests.     (line  20)
* relations, numeric or string:          Relations for expr.  (line   6)
* relative items in date strings:        Relative items in date strings.
                                                              (line   6)
* release of kernel:                     uname invocation.    (line  70)
* relpath:                               realpath invocation. (line  67)
* remainder:                             Numeric expressions. (line  15)
* remote hostname:                       who invocation.      (line  12)
* removing empty directories:            rmdir invocation.    (line   6)
* removing files after shredding:        shred invocation.    (line 138)
* removing files or directories:         rm invocation.       (line   6)
* removing files or directories (via the unlink syscall): unlink invocation.
                                                              (line   6)
* removing permissions:                  Setting Permissions. (line  42)
* repeated characters:                   Character sets.      (line  73)
* repeated lines, outputting:            uniq invocation.     (line  67)
* repeated output of a string:           yes invocation.      (line   6)
* restricted deletion flag:              Mode Structure.      (line  61)
* return, ignoring:                      Input.               (line  32)
* return, translating to newline <1>:    Output.              (line  17)
* return, translating to newline:        Input.               (line  35)
* reverse sorting <1>:                   Sorting the output.  (line  28)
* reverse sorting:                       sort invocation.     (line 205)
* reversing files:                       tac invocation.      (line   6)
* rm:                                    rm invocation.       (line   6)
* rmdir:                                 rmdir invocation.    (line   6)
* rn format for nl:                      nl invocation.       (line 102)
* root as default owner:                 install invocation.  (line  95)
* root directory, allow recursive destruction: rm invocation. (line  96)
* root directory, allow recursive modification <1>: chmod invocation.
                                                              (line  59)
* root directory, allow recursive modification <2>: chgrp invocation.
                                                              (line  53)
* root directory, allow recursive modification: chown invocation.
                                                              (line 130)
* root directory, disallow recursive destruction: rm invocation.
                                                              (line  91)
* root directory, disallow recursive modification <1>: chmod invocation.
                                                              (line  54)
* root directory, disallow recursive modification <2>: chgrp invocation.
                                                              (line  48)
* root directory, disallow recursive modification: chown invocation.
                                                              (line 125)
* root directory, running a program in a specified: chroot invocation.
                                                              (line   6)
* rows:                                  Special.             (line  23)
* rprnt:                                 Characters.          (line  56)
* RTS/CTS flow control:                  Control.             (line  38)
* run commands with bounded time:        timeout invocation.  (line   6)
* run with security context:             runcon invocation.   (line   6)
* runcon:                                runcon invocation.   (line   6)
* running a program in a modified environment: env invocation.
                                                              (line   6)
* running a program in a specified root directory: chroot invocation.
                                                              (line   6)
* rz format for nl:                      nl invocation.       (line 105)
* Salz, Rich:                            Authors of parse_datetime.
                                                              (line   6)
* same file check:                       File characteristic tests.
                                                              (line  23)
* sane:                                  Combination.         (line  25)
* scheduling, affecting:                 nice invocation.     (line   6)
* screen columns:                        fold invocation.     (line  17)
* seconds since the epoch:               Time conversion specifiers.
                                                              (line  42)
* section delimiters of pages:           nl invocation.       (line  70)
* security context <1>:                  id invocation.       (line  49)
* security context <2>:                  mknod invocation.    (line  63)
* security context <3>:                  mkfifo invocation.   (line  32)
* security context <4>:                  mkdir invocation.    (line  58)
* security context <5>:                  install invocation.  (line 101)
* security context:                      What information is listed.
                                                              (line 281)
* seek:                                  dd invocation.       (line  52)
* seek_bytes:                            dd invocation.       (line 298)
* self-backups:                          cp invocation.       (line  60)
* SELinux <1>:                           id invocation.       (line  49)
* SELinux <2>:                           mknod invocation.    (line  63)
* SELinux <3>:                           mkfifo invocation.   (line  32)
* SELinux <4>:                           mkdir invocation.    (line  58)
* SELinux <5>:                           install invocation.  (line 101)
* SELinux:                               What information is listed.
                                                              (line 281)
* SELinux context:                       SELinux context.     (line   6)
* SELinux, context:                      SELinux context.     (line   6)
* send a signal to processes:            kill invocation.     (line   6)
* sentences and line-breaking:           fmt invocation.      (line  21)
* separator for numbers in seq:          seq invocation.      (line  44)
* seq:                                   seq invocation.      (line   6)
* sequence of numbers:                   seq invocation.      (line   6)
* set-group-ID:                          Mode Structure.      (line  53)
* set-group-ID check:                    Access permission tests.
                                                              (line   9)
* set-user-ID:                           Mode Structure.      (line  46)
* set-user-ID check:                     Access permission tests.
                                                              (line  18)
* setgid:                                Mode Structure.      (line  53)
* setting permissions:                   Setting Permissions. (line  46)
* setting the hostname:                  hostname invocation. (line   6)
* setting the time:                      Setting the time.    (line   6)
* setuid:                                Mode Structure.      (line  46)
* setup for color:                       dircolors invocation.
                                                              (line   6)
* sh syntax for color setup:             dircolors invocation.
                                                              (line  36)
* SHA-1:                                 sha1sum invocation.  (line   6)
* SHA-2:                                 sha2 utilities.      (line   6)
* sha1sum:                               sha1sum invocation.  (line   6)
* sha224sum:                             sha2 utilities.      (line   6)
* sha256sum:                             sha2 utilities.      (line   6)
* sha384sum:                             sha2 utilities.      (line   6)
* sha512sum:                             sha2 utilities.      (line   6)
* SHELL environment variable, and color <1>: dircolors invocation.
                                                              (line  25)
* SHELL environment variable, and color: General output formatting.
                                                              (line  36)
* shell utilities:                       Top.                 (line  24)
* shred:                                 shred invocation.    (line   6)
* shuf:                                  shuf invocation.     (line   6)
* shuffling files:                       shuf invocation.     (line   6)
* SI output <1>:                         du invocation.       (line 138)
* SI output <2>:                         df invocation.       (line 111)
* SI output <3>:                         What information is listed.
                                                              (line 273)
* SI output:                             Block size.          (line  44)
* signals, specifying:                   Signal specifications.
                                                              (line   6)
* simple backup method:                  Backup options.      (line  48)
* SIMPLE_BACKUP_SUFFIX:                  Backup options.      (line  54)
* single-column output of files:         General output formatting.
                                                              (line  10)
* size:                                  Special.             (line  30)
* size for main memory sorting:          sort invocation.     (line 349)
* size of file to shred:                 shred invocation.    (line 131)
* size of files, reporting:              What information is listed.
                                                              (line 256)
* size of files, sorting files by:       Sorting the output.  (line  34)
* skip:                                  dd invocation.       (line  47)
* skip_bytes:                            dd invocation.       (line 292)
* sleep:                                 sleep invocation.    (line   6)
* socket check:                          File type tests.     (line  32)
* software flow control:                 Input.               (line  46)
* sort:                                  sort invocation.     (line   6)
* sort field:                            sort invocation.     (line 260)
* sort stability:                        sort invocation.     (line  46)
* sort's last-resort comparison:         sort invocation.     (line  46)
* sorted files, operations on:           Operating on sorted files.
                                                              (line   6)
* sorting files:                         sort invocation.     (line   6)
* sorting ls output:                     Sorting the output.  (line   6)
* space:                                 Character sets.      (line 122)
* sparse:                                dd invocation.       (line 118)
* sparse files, copying:                 cp invocation.       (line 330)
* sparse files, creating:                truncate invocation. (line  15)
* special characters:                    Characters.          (line   6)
* special file types:                    Special file types.  (line   6)
* special files:                         mknod invocation.    (line  13)
* special settings:                      Special.             (line   6)
* specifying sets of characters:         Character sets.      (line   6)
* speed:                                 Special.             (line  40)
* split:                                 split invocation.    (line   6)
* splitting a file into pieces:          split invocation.    (line   6)
* splitting a file into pieces by context: csplit invocation. (line   6)
* squeezing empty lines:                 cat invocation.      (line  38)
* squeezing repeat characters:           Squeezing.           (line   6)
* Stallman, R.:                          Introduction.        (line  22)
* standard input:                        Common options.      (line  51)
* standard output:                       Common options.      (line  51)
* standard streams, buffering:           stdbuf invocation.   (line   6)
* start:                                 Characters.          (line  44)
* stat:                                  stat invocation.     (line   6)
* status:                                dd invocation.       (line  62)
* status time, printing or sorting by:   Sorting the output.  (line  13)
* status time, show the most recent:     du invocation.       (line 164)
* stdbuf:                                stdbuf invocation.   (line   6)
* sticky:                                Mode Structure.      (line  61)
* sticky bit check:                      Access permission tests.
                                                              (line  12)
* stop:                                  Characters.          (line  47)
* stop bits:                             Control.             (line  28)
* strftime and date:                     date invocation.     (line  21)
* string constants, outputting:          od invocation.       (line  84)
* string expressions:                    String expressions.  (line   6)
* string tests:                          String tests.        (line   6)
* strip directory and suffix from file names: basename invocation.
                                                              (line   6)
* stripping non-directory suffix:        dirname invocation.  (line   6)
* stripping symbol table information:    install invocation.  (line 118)
* stripping trailing slashes <1>:        mv invocation.       (line 105)
* stripping trailing slashes:            cp invocation.       (line 366)
* stty:                                  stty invocation.     (line   6)
* substr:                                String expressions.  (line  40)
* subtracting permissions:               Setting Permissions. (line  42)
* subtraction:                           Numeric expressions. (line  11)
* successful exit:                       true invocation.     (line   6)
* suffix, stripping from file names:     basename invocation. (line   6)
* sum:                                   sum invocation.      (line   6)
* summarizing files:                     Summarizing files.   (line   6)
* superblock, writing:                   sync invocation.     (line   6)
* supplementary groups, printing:        groups invocation.   (line   6)
* susp:                                  Characters.          (line  50)
* swab (byte-swapping):                  dd invocation.       (line 133)
* swap space, saving text image in:      Mode Structure.      (line  61)
* swtch:                                 Characters.          (line  41)
* symbol table information, stripping:   install invocation.  (line 118)
* symbol table information, stripping, program: install invocation.
                                                              (line 122)
* symbolic (soft) links, creating:       ln invocation.       (line   6)
* symbolic link check:                   File type tests.     (line  24)
* symbolic link to directory, controlling traversal of: Traversing symlinks.
                                                              (line   6)
* symbolic link to directory, never traverse <1>: chcon invocation.
                                                              (line  42)
* symbolic link to directory, never traverse <2>: chgrp invocation.
                                                              (line  83)
* symbolic link to directory, never traverse <3>: chown invocation.
                                                              (line 161)
* symbolic link to directory, never traverse: Traversing symlinks.
                                                              (line  29)
* symbolic link to directory, traverse each that is encountered <1>: chcon invocation.
                                                              (line  38)
* symbolic link to directory, traverse each that is encountered <2>: chgrp invocation.
                                                              (line  79)
* symbolic link to directory, traverse each that is encountered <3>: chown invocation.
                                                              (line 157)
* symbolic link to directory, traverse each that is encountered: Traversing symlinks.
                                                              (line  25)
* symbolic link to directory, traverse if on the command line <1>: chcon invocation.
                                                              (line  33)
* symbolic link to directory, traverse if on the command line <2>: chgrp invocation.
                                                              (line  74)
* symbolic link to directory, traverse if on the command line <3>: chown invocation.
                                                              (line 152)
* symbolic link to directory, traverse if on the command line: Traversing symlinks.
                                                              (line  20)
* symbolic link, defined:                ln invocation.       (line  49)
* symbolic links and ln:                 ln invocation.       (line 196)
* symbolic links and pwd:                pwd invocation.      (line  28)
* symbolic links, changing group:        chgrp invocation.    (line  38)
* symbolic links, changing owner <1>:    chgrp invocation.    (line  33)
* symbolic links, changing owner:        chown invocation.    (line  84)
* symbolic links, changing time:         touch invocation.    (line 111)
* symbolic links, copying:               cp invocation.       (line 124)
* symbolic links, copying with:          cp invocation.       (line 371)
* symbolic links, dereferencing:         Which files are listed.
                                                              (line  39)
* symbolic links, dereferencing in du:   du invocation.       (line 108)
* symbolic links, dereferencing in stat: stat invocation.     (line  26)
* symbolic links, following:             dd invocation.       (line 264)
* symbolic links, permissions of:        chmod invocation.    (line  12)
* symbolic modes:                        Symbolic Modes.      (line   6)
* symlinks, resolution:                  realpath invocation. (line   6)
* sync <1>:                              sync invocation.     (line   6)
* sync:                                  dd invocation.       (line 226)
* sync (padding with ASCII NULs):        dd invocation.       (line 139)
* synchronize disk and memory:           sync invocation.     (line   6)
* synchronized data and metadata I/O:    dd invocation.       (line 226)
* synchronized data and metadata writes, before finishing: dd invocation.
                                                              (line 170)
* synchronized data reads:               dd invocation.       (line 217)
* synchronized data writes, before finishing: dd invocation.  (line 166)
* system context:                        System context.      (line   6)
* system information, printing <1>:      uname invocation.    (line   6)
* system information, printing <2>:      nproc invocation.    (line   6)
* system information, printing:          arch invocation.     (line   6)
* system name, printing:                 hostname invocation. (line   6)
* System V sum:                          sum invocation.      (line  34)
* tab stops, setting:                    expand invocation.   (line  24)
* tabN:                                  Output.              (line  52)
* tabs:                                  Combination.         (line  66)
* tabs to spaces, converting:            expand invocation.   (line   6)
* tac:                                   tac invocation.      (line   6)
* tagged paragraphs:                     fmt invocation.      (line  44)
* tail:                                  tail invocation.     (line   6)
* tandem:                                Input.               (line  46)
* target directory <1>:                  ln invocation.       (line 183)
* target directory <2>:                  mv invocation.       (line 115)
* target directory <3>:                  install invocation.  (line 132)
* target directory <4>:                  cp invocation.       (line 384)
* target directory:                      Target directory.    (line   6)
* tebibyte, definition of:               Block size.          (line 115)
* tee:                                   tee invocation.      (line   6)
* telephone directory order:             sort invocation.     (line 100)
* temporary directory:                   sort invocation.     (line 386)
* temporary files and directories:       mktemp invocation.   (line   6)
* terabyte, definition of:               Block size.          (line 111)
* terminal check:                        File type tests.     (line  35)
* terminal file name, printing:          tty invocation.      (line   6)
* terminal lines, currently used:        who invocation.      (line  12)
* terminal settings:                     stty invocation.     (line   6)
* terminal, using color iff:             General output formatting.
                                                              (line  26)
* terse output:                          stat invocation.     (line  60)
* test:                                  test invocation.     (line   6)
* text:                                  dd invocation.       (line 275)
* text I/O:                              dd invocation.       (line 275)
* text image, saving in swap space:      Mode Structure.      (line  61)
* text input files:                      md5sum invocation.   (line 109)
* text utilities:                        Top.                 (line  24)
* text, displaying:                      echo invocation.     (line   6)
* text, reformatting:                    fmt invocation.      (line   6)
* this in date strings:                  Relative items in date strings.
                                                              (line  32)
* time <1>:                              Special.             (line  12)
* time:                                  touch invocation.    (line  97)
* time conversion specifiers:            Time conversion specifiers.
                                                              (line   6)
* time formats <1>:                      date invocation.     (line  21)
* time formats:                          pr invocation.       (line 107)
* time limit:                            timeout invocation.  (line   6)
* time of day item:                      Time of day items.   (line   6)
* time setting:                          Setting the time.    (line   6)
* time style <1>:                        du invocation.       (line 175)
* time style:                            Formatting file timestamps.
                                                              (line  27)
* time units <1>:                        sleep invocation.    (line  13)
* time units:                            timeout invocation.  (line  48)
* time zone correction:                  Time of day items.   (line  29)
* time zone item <1>:                    Time zone items.     (line   6)
* time zone item:                        General date syntax. (line  48)
* time, printing or setting:             date invocation.     (line   6)
* TIME_STYLE <1>:                        du invocation.       (line 205)
* TIME_STYLE:                            Formatting file timestamps.
                                                              (line 111)
* timeout:                               timeout invocation.  (line   6)
* timestamps of installed files, preserving: install invocation.
                                                              (line 108)
* timestamps, changing file:             touch invocation.    (line   6)
* TMPDIR:                                sort invocation.     (line  73)
* today in date strings:                 Relative items in date strings.
                                                              (line  32)
* tomorrow:                              Options for date.    (line  11)
* tomorrow in date strings:              Relative items in date strings.
                                                              (line  29)
* topological sort:                      tsort invocation.    (line   6)
* tostop:                                Local.               (line  44)
* total counts:                          wc invocation.       (line  15)
* touch:                                 touch invocation.    (line   6)
* tr:                                    tr invocation.       (line   6)
* trailing slashes:                      Trailing slashes.    (line   6)
* translating characters:                Translating.         (line   6)
* true:                                  true invocation.     (line   6)
* truncate:                              truncate invocation. (line   6)
* truncating output file, avoiding:      dd invocation.       (line 159)
* truncating, file sizes:                truncate invocation. (line   6)
* tsort:                                 tsort invocation.    (line   6)
* tty:                                   tty invocation.      (line   6)
* two-way parity:                        Control.             (line   9)
* type size:                             od invocation.       (line 130)
* TZ <1>:                                Specifying time zone rules.
                                                              (line   6)
* TZ <2>:                                Options for date.    (line 111)
* TZ <3>:                                date invocation.     (line  17)
* TZ <4>:                                who invocation.      (line  27)
* TZ <5>:                                stat invocation.     (line 203)
* TZ <6>:                                touch invocation.    (line  76)
* TZ <7>:                                Formatting file timestamps.
                                                              (line  19)
* TZ:                                    pr invocation.       (line 120)
* u, and disabling special characters:   Characters.          (line  13)
* ucase, converting to:                  dd invocation.       (line 113)
* ufs file system type:                  df invocation.       (line 147)
* umask and modes:                       Umask and Protection.
                                                              (line   6)
* uname:                                 uname invocation.    (line   6)
* unblock:                               dd invocation.       (line 104)
* unexpand:                              unexpand invocation. (line   6)
* Unicode:                               printf invocation.   (line  78)
* uniq:                                  uniq invocation.     (line   6)
* unique lines, outputting:              uniq invocation.     (line 106)
* uniquify files:                        uniq invocation.     (line   6)
* uniquifying output:                    sort invocation.     (line 403)
* unlink:                                unlink invocation.   (line   6)
* unprintable characters, ignoring:      sort invocation.     (line 162)
* unsorted directory listing:            Sorting the output.  (line  20)
* upper:                                 Character sets.      (line 125)
* uppercase, translating to lowercase:   Input.               (line  51)
* uptime:                                uptime invocation.   (line   6)
* use time, changing:                    touch invocation.    (line  89)
* use time, printing or sorting files by: Sorting the output. (line  13)
* use time, show the most recent:        du invocation.       (line 164)
* user IDs, disambiguating:              Disambiguating names and IDs.
                                                              (line   6)
* user information, commands for:        User information.    (line   6)
* user name, printing:                   logname invocation.  (line   6)
* user names, disambiguating:            Disambiguating names and IDs.
                                                              (line   6)
* usernames, printing current:           users invocation.    (line   6)
* users:                                 users invocation.    (line   6)
* UTC:                                   Options for date.    (line 111)
* valid file names, checking for:        pathchk invocation.  (line   6)
* variable-length records, converting to fixed-length: dd invocation.
                                                              (line  42)
* vdir:                                  vdir invocation.     (line   6)
* verbose ls format:                     What information is listed.
                                                              (line 138)
* verifying MD5 checksums:               md5sum invocation.   (line  79)
* version number sort:                   sort invocation.     (line 198)
* version number, finding:               Common options.      (line  43)
* version of kernel:                     uname invocation.    (line  85)
* version, sorting option for ls:        Sorting the output.  (line  62)
* version-control Emacs variable:        Backup options.      (line  25)
* VERSION_CONTROL <1>:                   ln invocation.       (line  96)
* VERSION_CONTROL <2>:                   mv invocation.       (line  67)
* VERSION_CONTROL <3>:                   install invocation.  (line  46)
* VERSION_CONTROL <4>:                   cp invocation.       (line  90)
* VERSION_CONTROL:                       Backup options.      (line  14)
* vertical sorted files in columns:      General output formatting.
                                                              (line  15)
* vtN:                                   Output.              (line  60)
* wc:                                    wc invocation.       (line   6)
* week in date strings:                  Relative items in date strings.
                                                              (line  15)
* werase:                                Characters.          (line  59)
* who:                                   who invocation.      (line   6)
* who am i:                              who invocation.      (line  22)
* whoami:                                whoami invocation.   (line   6)
* word count:                            wc invocation.       (line   6)
* working context:                       Working context.     (line   6)
* working directory, printing:           pwd invocation.      (line   6)
* wrap data:                             base64 invocation.   (line  25)
* wrapping long input lines:             fold invocation.     (line   6)
* writable file check:                   Access permission tests.
                                                              (line  21)
* write permission:                      Mode Structure.      (line  17)
* write permission, symbolic:            Setting Permissions. (line  60)
* write, allowed:                        who invocation.      (line  97)
* xcase:                                 Local.               (line  37)
* xdigit:                                Character sets.      (line 128)
* XON/XOFF flow control:                 Input.               (line  41)
* year in date strings:                  Relative items in date strings.
                                                              (line  15)
* yes:                                   yes invocation.      (line   6)
* yesterday:                             Options for date.    (line  11)
* yesterday in date strings:             Relative items in date strings.
                                                              (line  29)
* yottabyte, definition of:              Block size.          (line 142)
* Youmans, B.:                           Introduction.        (line  22)
* zero-length string check:              String tests.        (line  15)
* zettabyte, definition of:              Block size.          (line 133)
* |:                                     Relations for expr.  (line  11)



Tag Table:
Node: Top9159
Node: Introduction26081
Node: Common options28584
Node: Exit status33516
Node: Backup options34644
Node: Block size37704
Node: Floating point45510
Node: Signal specifications47324
Node: Disambiguating names and IDs50698
Ref: Disambiguating names and IDs-Footnote-153233
Node: Random sources53335
Node: Target directory55688
Node: Trailing slashes60984
Node: Traversing symlinks62712
Node: Treating / specially64505
Node: Special built-in utilities67274
Node: Standards conformance69619
Node: Output of entire files71882
Node: cat invocation72666
Node: tac invocation75088
Node: nl invocation76912
Node: od invocation82166
Node: base64 invocation91600
Node: Formatting file contents93611
Node: fmt invocation94169
Node: pr invocation98393
Node: fold invocation117235
Node: Output of parts of files119205
Node: head invocation119758
Node: tail invocation122942
Node: split invocation137439
Node: csplit invocation148160
Node: Summarizing files154695
Node: wc invocation155596
Node: sum invocation160154
Node: cksum invocation162264
Node: md5sum invocation163812
Node: sha1sum invocation173280
Node: sha2 utilities174346
Node: Operating on sorted files175160
Node: sort invocation175898
Ref: sort invocation-Footnote-1215023
Node: shuf invocation215871
Node: uniq invocation219490
Node: comm invocation226446
Node: ptx invocation229974
Node: General options in ptx232767
Node: Charset selection in ptx233437
Node: Input processing in ptx234342
Node: Output formatting in ptx239761
Node: Compatibility in ptx246329
Node: tsort invocation249566
Node: tsort background252741
Node: Operating on fields254392
Node: cut invocation254828
Node: paste invocation260749
Node: join invocation262401
Node: Operating on characters272075
Node: tr invocation272526
Node: Character sets275064
Node: Translating281732
Node: Squeezing284745
Node: expand invocation289205
Node: unexpand invocation291410
Node: Directory listing294857
Node: ls invocation295469
Ref: ls invocation-Footnote-1299052
Node: Which files are listed299353
Node: What information is listed304957
Node: Sorting the output318640
Node: Details about version sort322254
Node: General output formatting324599
Node: Formatting file timestamps332219
Node: Formatting the file names340091
Node: dir invocation344386
Node: vdir invocation345008
Node: dircolors invocation345510
Node: Basic operations347996
Node: cp invocation348849
Node: dd invocation374967
Node: install invocation394453
Node: mv invocation402295
Node: rm invocation409390
Node: shred invocation416310
Node: Special file types429409
Node: link invocation431901
Node: ln invocation433672
Node: mkdir invocation447469
Node: mkfifo invocation450935
Node: mknod invocation452608
Node: readlink invocation456231
Node: rmdir invocation459078
Node: unlink invocation460763
Node: Changing file attributes462123
Node: chown invocation463353
Node: chgrp invocation472475
Node: chmod invocation476989
Node: touch invocation481119
Node: Disk usage492547
Node: df invocation493567
Node: du invocation503695
Node: stat invocation516580
Node: sync invocation526194
Node: truncate invocation527695
Node: Printing text529999
Node: echo invocation530465
Node: printf invocation534229
Node: yes invocation542658
Node: Conditions543515
Node: false invocation544261
Node: true invocation545935
Node: test invocation547886
Node: File type tests550971
Node: Access permission tests552255
Node: File characteristic tests553422
Node: String tests554413
Node: Numeric tests555355
Node: Connectives for test556401
Node: expr invocation556810
Node: String expressions560767
Node: Numeric expressions564300
Node: Relations for expr565061
Node: Examples of expr566544
Node: Redirection567561
Node: tee invocation568236
Node: File name manipulation575202
Node: basename invocation575905
Node: dirname invocation578679
Node: pathchk invocation580924
Node: mktemp invocation583611
Node: realpath invocation592892
Node: Working context597808
Node: pwd invocation598599
Node: stty invocation600577
Node: Control604612
Node: Input605808
Node: Output608179
Node: Local610045
Node: Combination612353
Node: Characters615102
Node: Special617446
Node: printenv invocation619631
Node: tty invocation620982
Node: User information621889
Node: id invocation622709
Node: logname invocation625490
Node: whoami invocation626306
Node: groups invocation626852
Node: users invocation628574
Node: who invocation629873
Node: System context634091
Node: date invocation634945
Node: Time conversion specifiers637139
Node: Date conversion specifiers640825
Node: Literal conversion specifiers644625
Node: Padding and other flags644973
Node: Setting the time647902
Node: Options for date649675
Node: Examples of date655264
Ref: %s-examples656970
Node: arch invocation661096
Node: nproc invocation661670
Node: uname invocation663103
Node: hostname invocation667094
Node: hostid invocation667893
Node: uptime invocation668845
Node: SELinux context670441
Node: chcon invocation670813
Node: runcon invocation672886
Node: Modified command invocation674390
Node: chroot invocation675281
Ref: chroot invocation-Footnote-1679304
Node: env invocation679844
Node: nice invocation685382
Node: nohup invocation691026
Node: stdbuf invocation694730
Node: timeout invocation698241
Node: Process control701536
Node: kill invocation701774
Node: Delaying706591
Node: sleep invocation706808
Node: Numeric operations708253
Node: factor invocation708596
Node: seq invocation710848
Node: File permissions716262
Node: Mode Structure717215
Node: Symbolic Modes723176
Node: Setting Permissions724755
Node: Copying Permissions728846
Node: Changing Special Mode Bits729934
Node: Conditional Executability733045
Node: Multiple Changes733954
Node: Umask and Protection736374
Node: Numeric Modes738312
Node: Operator Numeric Modes741348
Node: Directory Setuid and Setgid742784
Node: Date input formats748641
Node: General date syntax752520
Node: Calendar date items756781
Node: Time of day items759499
Node: Time zone items762445
Node: Combined date and time of day items764280
Node: Day of week items765152
Node: Relative items in date strings766841
Node: Pure numbers in date strings770636
Node: Seconds since the Epoch772062
Node: Specifying time zone rules774420
Node: Authors of parse_datetime777896
Ref: Authors of get_date778084
Node: Opening the software toolbox779356
Node: Toolbox introduction780185
Node: I/O redirection784402
Node: The who command788982
Node: The cut command790196
Node: The sort command791597
Node: The uniq command792549
Node: Putting the tools together793487
Ref: Putting the tools together-Footnote-1810766
Node: About this translation810874
Node: GNU Free Documentation License818139
Node: Concept index843329

End Tag Table

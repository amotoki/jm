# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-02-04 23:33+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/fanotify.7:25
#, no-wrap
msgid "FANOTIFY"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man7/inotify.7:27
#, no-wrap
msgid "2014-12-31"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24 build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:27 build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29 build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/fanotify.7:25 build/C/man2/fanotify_init.2:24 build/C/man2/fanotify_mark.2:24 build/C/man7/inotify.7:27 build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29 build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:26 build/C/man2/fanotify_init.2:25 build/C/man2/fanotify_mark.2:25 build/C/man7/inotify.7:28 build/C/man2/inotify_add_watch.2:29 build/C/man2/inotify_init.2:30 build/C/man2/inotify_rm_watch.2:28
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:28
msgid "fanotify - monitoring filesystem events"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:28 build/C/man2/fanotify_init.2:33 build/C/man2/fanotify_mark.2:36 build/C/man7/inotify.7:30 build/C/man2/inotify_add_watch.2:35 build/C/man2/inotify_init.2:39 build/C/man2/inotify_rm_watch.2:36
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:37
msgid ""
"The fanotify API provides notification and interception of filesystem "
"events.  Use cases include virus scanning and hierarchical storage "
"management.  Currently, only a limited set of events is supported.  In "
"particular, there is no support for create, delete, and move events.  (See "
"B<inotify>(7)  for details of an API that does notify those events.)"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:44
msgid ""
"Additional capabilities compared to the B<inotify>(7)  API include the "
"ability to monitor all of the objects in a mounted filesystem, the ability "
"to make access permission decisions, and the possibility to read or modify "
"files before access by other applications."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:52
msgid ""
"The following system calls are used with this API: B<fanotify_init>(2), "
"B<fanotify_mark>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:52
#, no-wrap
msgid "fanotify_init(), fanotify_mark(), and notification groups"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:57
msgid ""
"The B<fanotify_init>(2)  system call creates and initializes an fanotify "
"notification group and returns a file descriptor referring to it."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:61
msgid ""
"An fanotify notification group is a kernel-internal object that holds a list "
"of files, directories, and mount points for which events shall be created."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:72
msgid ""
"For each entry in an fanotify notification group, two bit masks exist: the "
"I<mark> mask and the I<ignore> mask.  The mark mask defines file activities "
"for which an event shall be created.  The ignore mask defines activities for "
"which no event shall be generated.  Having these two types of masks permits "
"a mount point or directory to be marked for receiving events, while at the "
"same time ignoring events for specific objects under that mount point or "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:78
msgid ""
"The B<fanotify_mark>(2)  system call adds a file, directory, or mount to a "
"notification group and specifies which events shall be reported (or "
"ignored), or removes or modifies such an entry."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:91
msgid ""
"A possible usage of the ignore mask is for a file cache.  Events of interest "
"for a file cache are modification of a file and closing of the same.  Hence, "
"the cached directory or mount point is to be marked to receive these "
"events.  After receiving the first event informing that a file has been "
"modified, the corresponding cache entry will be invalidated.  No further "
"modification events for this file are of interest until the file is closed.  "
"Hence, the modify event can be added to the ignore mask.  Upon receiving the "
"close event, the modify event can be removed from the ignore mask and the "
"file cache entry can be updated."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:98
msgid ""
"The entries in the fanotify notification groups refer to files and "
"directories via their inode number and to mounts via their mount ID.  If "
"files or directories are renamed or moved, the respective entries survive.  "
"If files or directories are deleted or mounts are unmounted, the "
"corresponding entries are deleted."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:98
#, no-wrap
msgid "The event queue"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:107
msgid ""
"As events occur on the filesystem objects monitored by a notification group, "
"the fanotify system generates events that are collected in a queue.  These "
"events can then be read (using B<read>(2)  or similar)  from the fanotify "
"file descriptor returned by B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:121
msgid ""
"Two types of events are generated: I<notification> events and I<permission> "
"events.  Notification events are merely informative and require no action to "
"be taken by the receiving application except for closing the file descriptor "
"passed in the event (see below).  Permission events are requests to the "
"receiving application to decide whether permission for a file access shall "
"be granted.  For these events, the recipient must write a response which "
"decides whether access is granted or not."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:128
msgid ""
"An event is removed from the event queue of the fanotify group when it has "
"been read.  Permission events that have been read are kept in an internal "
"list of the fanotify group until either a permission decision has been taken "
"by writing to the fanotify file descriptor or the fanotify file descriptor "
"is closed."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:128
#, no-wrap
msgid "Reading fanotify events"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:140
msgid ""
"Calling B<read>(2)  for the file descriptor returned by B<fanotify_init>(2)  "
"blocks (if the flag B<FAN_NONBLOCK> is not specified in the call to "
"B<fanotify_init>(2))  until either a file event occurs or the call is "
"interrupted by a signal (see B<signal>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:144
msgid ""
"After a successful B<read>(2), the read buffer contains one or more of the "
"following structures:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:156
#, no-wrap
msgid ""
"struct fanotify_event_metadata {\n"
"    __u32 event_len;\n"
"    __u8 vers;\n"
"    __u8 reserved;\n"
"    __u16 metadata_len;\n"
"    __aligned_u64 mask;\n"
"    __s32 fd;\n"
"    __s32 pid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:163
msgid ""
"For performance reasons, it is recommended to use a large buffer size (for "
"example, 4096 bytes), so that multiple events can be retrieved by a single "
"B<read>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:168
msgid ""
"The return value of B<read>(2)  is the number of bytes placed in the buffer, "
"or -1 in case of an error (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:172
msgid "The fields of the I<fanotify_event_metadata> structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:172
#, no-wrap
msgid "I<event_len>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:182
msgid ""
"This is the length of the data for the current event and the offset to the "
"next event in the buffer.  In the current implementation, the value of "
"I<event_len> is always B<FAN_EVENT_METADATA_LEN>.  However, the API is "
"designed to allow variable-length structures to be returned in the future."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:182
#, no-wrap
msgid "I<vers>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:191
msgid ""
"This field holds a version number for the structure.  It must be compared to "
"B<FANOTIFY_METADATA_VERSION> to verify that the structures returned at "
"runtime match the structures defined at compile time.  In case of a "
"mismatch, the application should abandon trying to use the fanotify file "
"descriptor."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:191
#, no-wrap
msgid "I<reserved>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:194
msgid "This field is not used."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:194
#, no-wrap
msgid "I<metadata_len>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:200
msgid ""
"This is the length of the structure.  The field was introduced to facilitate "
"the implementation of optional headers per event type.  No such optional "
"headers exist in the current implementation."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:200
#, no-wrap
msgid "I<mask>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:203
msgid "This is a bit mask describing the event (see below)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:203 build/C/man7/fanotify.7:360
#, no-wrap
msgid "I<fd>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:211
msgid ""
"This is an open file descriptor for the object being accessed, or "
"B<FAN_NOFD> if a queue overflow occurred.  The file descriptor can be used "
"to access the contents of the monitored file or directory.  The reading "
"application is responsible for closing this file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:224
msgid ""
"When calling B<fanotify_init>(2), the caller may specify (via the "
"I<event_f_flags> argument) various file status flags that are to be set on "
"the open file description that corresponds to this file descriptor.  In "
"addition, the (kernel-internal)  B<FMODE_NONOTIFY> file status flag is set "
"on the open file description.  This flag suppresses fanotify event "
"generation.  Hence, when the receiver of the fanotify event accesses the "
"notified file or directory using this file descriptor, no additional events "
"will be created."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:224
#, no-wrap
msgid "I<pid>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:232
msgid ""
"This is the ID of the process that caused the event.  A program listening to "
"fanotify events can compare this PID to the PID returned by B<getpid>(2), to "
"determine whether the event is caused by the listener itself, or is due to a "
"file access by another process."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:242
msgid ""
"The bit mask in I<mask> indicates which events have occurred for a single "
"filesystem object.  Multiple bits may be set in this mask, if more than one "
"event occurred for the monitored filesystem object.  In particular, "
"consecutive events for the same filesystem object and originating from the "
"same process may be merged into a single event, with the exception that two "
"permission events are never merged into one queue entry."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:246
msgid "The bits that may appear in I<mask> are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:246 build/C/man2/fanotify_mark.2:136
#, no-wrap
msgid "B<FAN_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:249
msgid "A file or a directory (but see BUGS) was accessed (read)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:249 build/C/man2/fanotify_mark.2:148
#, no-wrap
msgid "B<FAN_OPEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:252
msgid "A file or a directory was opened."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:252 build/C/man2/fanotify_mark.2:139
#, no-wrap
msgid "B<FAN_MODIFY>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:255
msgid "A file was modified."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:255 build/C/man2/fanotify_mark.2:142
#, no-wrap
msgid "B<FAN_CLOSE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:262
msgid "A file that was opened for writing (B<O_WRONLY> or B<O_RDWR>)  was closed."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:262 build/C/man2/fanotify_mark.2:145
#, no-wrap
msgid "B<FAN_CLOSE_NOWRITE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:267
msgid "A file or directory that was opened read-only (B<O_RDONLY>)  was closed."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:267
#, no-wrap
msgid "B<FAN_Q_OVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:274
msgid ""
"The event queue exceeded the limit of 16384 entries.  This limit can be "
"overridden by specifying the B<FAN_UNLIMITED_QUEUE> flag when calling "
"B<fanotify_init>(2)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:274 build/C/man2/fanotify_mark.2:159
#, no-wrap
msgid "B<FAN_ACCESS_PERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:283
msgid ""
"An application wants to read a file or directory, for example using "
"B<read>(2)  or B<readdir>(2).  The reader must write a response (as "
"described below)  that determines whether the permission to access the "
"filesystem object shall be granted."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:283 build/C/man2/fanotify_mark.2:151
#, no-wrap
msgid "B<FAN_OPEN_PERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:288
msgid ""
"An application wants to open a file or directory.  The reader must write a "
"response that determines whether the permission to open the filesystem "
"object shall be granted."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:290
msgid "To check for any close event, the following bit mask may be used:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:290 build/C/man2/fanotify_mark.2:186
#, no-wrap
msgid "B<FAN_CLOSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:294
msgid "A file was closed.  This is a synonym for:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:296
#, no-wrap
msgid "    FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:301
msgid ""
"The following macros are provided to iterate over a buffer containing "
"fanotify event metadata returned by a B<read>(2)  from an fanotify file "
"descriptor:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:301
#, no-wrap
msgid "B<FAN_EVENT_OK(meta, len)>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:310
msgid ""
"This macro checks the remaining length I<len> of the buffer I<meta> against "
"the length of the metadata structure and the I<event_len> field of the first "
"metadata structure in the buffer."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:310
#, no-wrap
msgid "B<FAN_EVENT_NEXT(meta, len)>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:329
msgid ""
"This macro uses the length indicated in the I<event_len> field of the "
"metadata structure pointed to by I<meta> to calculate the address of the "
"next metadata structure that follows I<meta>.  I<len> is the number of bytes "
"of metadata that currently remain in the buffer.  The macro returns a "
"pointer to the next metadata structure that follows I<meta>, and reduces "
"I<len> by the number of bytes in the the metadata structure that has been "
"skipped over (i.e., it subtracts I<meta-E<gt>event_len> from I<len>)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:331
msgid "In addition, there is:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:331
#, no-wrap
msgid "B<FAN_EVENT_METADATA_LEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:337
msgid ""
"This macro returns the size (in bytes) of the structure "
"I<fanotify_event_metadata>.  This is the minimum size (and currently the "
"only size) of any event metadata."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:337
#, no-wrap
msgid "Monitoring an fanotify file descriptor for events"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:344
msgid ""
"When an fanotify event occurs, the fanotify file descriptor indicates as "
"readable when passed to B<epoll>(7), B<poll>(2), or B<select>(2)."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:344
#, no-wrap
msgid "Dealing with permission events"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:349
msgid ""
"For permission events, the application must B<write>(2)  a structure of the "
"following form to the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:356
#, no-wrap
msgid ""
"struct fanotify_response {\n"
"    __s32 fd;\n"
"    __u32 response;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:360
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:364
msgid "This is the file descriptor from the structure I<fanotify_event_metadata>."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:364
#, no-wrap
msgid "I<response>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:372
msgid ""
"This field indicates whether or not the permission is to be granted.  Its "
"value must be either B<FAN_ALLOW> to allow the file operation or B<FAN_DENY> "
"to deny the file operation."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:376
msgid ""
"If access is denied, the requesting application call will receive an "
"B<EPERM> error."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:376
#, no-wrap
msgid "Closing the fanotify file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:384
msgid ""
"When all file descriptors referring to the fanotify notification group are "
"closed, the fanotify group is released and its resources are freed for reuse "
"by the kernel.  Upon B<close>(2), outstanding permission events will be set "
"to allowed."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:384
#, no-wrap
msgid "/proc/[pid]/fdinfo"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:394
msgid ""
"The file I</proc/[pid]/fdinfo/[fd]> contains information about fanotify "
"marks for file descriptor I<fd> of process I<pid>.  See the kernel source "
"file I<Documentation/filesystems/proc.txt> for details."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:394 build/C/man2/fanotify_init.2:206 build/C/man2/fanotify_mark.2:243 build/C/man2/inotify_add_watch.2:84 build/C/man2/inotify_init.2:79 build/C/man2/inotify_rm_watch.2:55
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:399
msgid ""
"In addition to the usual errors for B<read>(2), the following errors can "
"occur when reading from the fanotify file descriptor:"
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:399 build/C/man7/fanotify.7:433 build/C/man2/fanotify_init.2:207 build/C/man2/fanotify_mark.2:248 build/C/man2/fanotify_mark.2:257 build/C/man2/inotify_add_watch.2:95 build/C/man2/inotify_init.2:80 build/C/man2/inotify_rm_watch.2:60
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:402
msgid "The buffer is too small to hold the event."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:402 build/C/man2/fanotify_init.2:216 build/C/man2/inotify_init.2:85
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:409
msgid ""
"The per-process limit on the number of open files has been reached.  See the "
"description of B<RLIMIT_NOFILE> in B<getrlimit>(2)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:409 build/C/man2/inotify_init.2:88
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:416
msgid ""
"The system-wide limit on the number of open files has been reached.  See "
"I</proc/sys/fs/file-max> in B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:416
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:429
msgid ""
"This error is returned by B<read>(2)  if B<O_RDWR> or B<O_WRONLY> was "
"specified in the I<event_f_flags> argument when calling B<fanotify_init>(2)  "
"and an event occurred for a monitored file that is currently being executed."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:433
msgid ""
"In addition to the usual errors for B<write>(2), the following errors can "
"occur when writing to the fanotify file descriptor:"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:439
msgid ""
"Fanotify access permissions are not enabled in the kernel configuration or "
"the value of I<response> in the response structure is not valid."
msgstr ""

#. type: TP
#: build/C/man7/fanotify.7:439 build/C/man2/fanotify_mark.2:265 build/C/man2/inotify_add_watch.2:104
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:446
msgid ""
"The file descriptor I<fd> in the response structure is not valid.  This may "
"occur when a response for the permission event has already been written."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:446 build/C/man2/fanotify_init.2:233 build/C/man2/fanotify_mark.2:299 build/C/man7/inotify.7:553 build/C/man2/inotify_add_watch.2:116 build/C/man2/inotify_init.2:94 build/C/man2/inotify_rm_watch.2:67
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:450
msgid ""
"The fanotify API was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37.  Fdinfo support was added in version 3.8."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:450 build/C/man2/fanotify_init.2:237 build/C/man2/fanotify_mark.2:303 build/C/man7/inotify.7:561 build/C/man2/inotify_add_watch.2:118 build/C/man2/inotify_init.2:101 build/C/man2/inotify_rm_watch.2:69
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:452
msgid "The fanotify API is Linux-specific."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:452 build/C/man7/inotify.7:563
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:459
msgid ""
"The fanotify API is available only if the kernel was built with the "
"B<CONFIG_FANOTIFY> configuration option enabled.  In addition, fanotify "
"permission handling is available only if the "
"B<CONFIG_FANOTIFY_ACCESS_PERMISSIONS> configuration option is enabled."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:459 build/C/man7/inotify.7:624
#, no-wrap
msgid "Limitations and caveats"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:464
msgid ""
"Fanotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:471
msgid ""
"The fanotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:476
msgid ""
"Events for directories are created only if the directory itself is opened, "
"read, and closed.  Adding, removing, or changing children of a marked "
"directory does not create events for the monitored directory itself."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:484
msgid ""
"Fanotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional marks must be created.  (But "
"note that the fanotify API provides no way of detecting when a subdirectory "
"has been created under a marked directory, which makes recursive monitoring "
"difficult.)  Monitoring mounts offers the capability to monitor a whole "
"directory tree."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:487
msgid "The event queue can overflow.  In this case, events are lost."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:487 build/C/man2/fanotify_init.2:239 build/C/man2/fanotify_mark.2:305 build/C/man7/inotify.7:754
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:490
msgid "As of Linux 3.17, the following bugs exist:"
msgstr ""

#. type: IP
#: build/C/man7/fanotify.7:490 build/C/man7/fanotify.7:499 build/C/man7/fanotify.7:503 build/C/man7/fanotify.7:512 build/C/man2/fanotify_init.2:242 build/C/man2/fanotify_init.2:250 build/C/man2/fanotify_mark.2:195 build/C/man2/fanotify_mark.2:201 build/C/man2/fanotify_mark.2:209 build/C/man2/fanotify_mark.2:215 build/C/man2/fanotify_mark.2:226 build/C/man2/fanotify_mark.2:307 build/C/man2/fanotify_mark.2:317 build/C/man2/fanotify_mark.2:323 build/C/man7/inotify.7:40 build/C/man7/inotify.7:51 build/C/man7/inotify.7:64 build/C/man7/inotify.7:70 build/C/man7/inotify.7:73 build/C/man7/inotify.7:270 build/C/man7/inotify.7:273
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:499
msgid ""
"On Linux, a filesystem object may be accessible through multiple paths, for "
"example, a part of a filesystem may be remounted using the I<--bind> option "
"of B<mount>(8).  A listener that marked a mount will be notified only of "
"events that were triggered for a filesystem object using the same mount.  "
"Any other event will pass unnoticed."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:503
msgid "Calling B<fallocate>(2)  does not create any fanotify events."
msgstr ""

#.  FIXME . A patch was proposed.
#. type: Plain text
#: build/C/man7/fanotify.7:512
msgid ""
"When an event is generated, no check is made to see whether the user ID of "
"the receiving process has authorization to read or write the file before "
"passing a file descriptor for that file.  This poses a security risk, when "
"the B<CAP_SYS_ADMIN> capability is set for programs executed by unprivileged "
"users."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:522
msgid ""
"If a call to B<read>(2)  processes multiple events from the fanotify queue "
"and an error occurs, the return value will be the total length of the events "
"successfully copied to the user-space buffer before the error occurred.  The "
"return value will not be -1, and I<errno> will not be set.  Thus, the "
"reading application has no way to detect the error."
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:522 build/C/man7/inotify.7:815
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:532
msgid ""
"The following program demonstrates the usage of the fanotify API.  It marks "
"the mount point passed as a command-line argument and waits for events of "
"type B<FAN_PERM_OPEN> and B<FAN_CLOSE_WRITE>.  When a permission event "
"occurs, a B<FAN_ALLOW> response is given."
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:542
msgid ""
"The following output was recorded while editing the file "
"I</home/user/temp/notes>.  Before the file was opened, a B<FAN_OPEN_PERM> "
"event occurred.  After the file was closed, a B<FAN_CLOSE_WRITE> event "
"occurred.  Execution of the program ends when the user presses the ENTER "
"key."
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:542 build/C/man7/inotify.7:838
#, no-wrap
msgid "Example output"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:550
#, no-wrap
msgid ""
"# ./fanotify_example /home\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"FAN_OPEN_PERM: File /home/user/temp/notes\n"
"FAN_CLOSE_WRITE: File /home/user/temp/notes\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:552 build/C/man7/inotify.7:850
#, no-wrap
msgid "Listening for events stopped.\n"
msgstr ""

#. type: SS
#: build/C/man7/fanotify.7:554 build/C/man7/inotify.7:852
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:565
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/fanotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:567
#, no-wrap
msgid "/* Read all available fanotify events from the file descriptor 'fd' */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:578
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd)\n"
"{\n"
"    const struct fanotify_event_metadata *metadata;\n"
"    struct fanotify_event_metadata buf[200];\n"
"    ssize_t len;\n"
"    char path[PATH_MAX];\n"
"    ssize_t path_len;\n"
"    char procfd_path[PATH_MAX];\n"
"    struct fanotify_response response;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:580
#, no-wrap
msgid "    /* Loop while events can be read from fanotify file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:582
#, no-wrap
msgid "    for(;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:584
#, no-wrap
msgid "        /* Read some events */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:590
#, no-wrap
msgid ""
"        len = read(fd, (void *) &buf, sizeof(buf));\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:592
#, no-wrap
msgid "        /* Check if end of available data reached */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:595 build/C/man7/inotify.7:901
#, no-wrap
msgid ""
"        if (len E<lt>= 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:597
#, no-wrap
msgid "        /* Point to the first event in the buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:599
#, no-wrap
msgid "        metadata = buf;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:601 build/C/man7/inotify.7:903
#, no-wrap
msgid "        /* Loop over all events in the buffer */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:603
#, no-wrap
msgid "        while (FAN_EVENT_OK(metadata, len)) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:605
#, no-wrap
msgid "            /* Check that run-time and compile-time structures match */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:611
#, no-wrap
msgid ""
"            if (metadata-E<gt>vers != FANOTIFY_METADATA_VERSION) {\n"
"                fprintf(stderr,\n"
"                        \"Mismatch of fanotify metadata version.\\en\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:615
#, no-wrap
msgid ""
"            /* metadata-E<gt>fd contains either FAN_NOFD, indicating a\n"
"               queue overflow, or a file descriptor (a nonnegative\n"
"               integer). Here, we simply ignore queue overflow. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:617
#, no-wrap
msgid "            if (metadata-E<gt>fd E<gt>= 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:619
#, no-wrap
msgid "                /* Handle open permission event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:622
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_OPEN_PERM) {\n"
"                    printf(\"FAN_OPEN_PERM: \");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:624
#, no-wrap
msgid "                    /* Allow file to be opened */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:630
#, no-wrap
msgid ""
"                    response.fd = metadata-E<gt>fd;\n"
"                    response.response = FAN_ALLOW;\n"
"                    write(fd, &response,\n"
"                          sizeof(struct fanotify_response));\n"
"                }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:632
#, no-wrap
msgid "                /* Handle closing of writable file event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:635
#, no-wrap
msgid ""
"                if (metadata-E<gt>mask & FAN_CLOSE_WRITE)\n"
"                    printf(\"FAN_CLOSE_WRITE: \");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:637
#, no-wrap
msgid "                /* Retrieve and print pathname of the accessed file */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:646
#, no-wrap
msgid ""
"                snprintf(procfd_path, sizeof(procfd_path),\n"
"                         \"/proc/self/fd/%d\", metadata-E<gt>fd);\n"
"                path_len = readlink(procfd_path, path,\n"
"                                    sizeof(path) - 1);\n"
"                if (path_len == -1) {\n"
"                    perror(\"readlink\");\n"
"                    exit(EXIT_FAILURE);\n"
"                }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:649
#, no-wrap
msgid ""
"                path[path_len] = '\\e0';\n"
"                printf(\"File %s\\en\", path);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:651
#, no-wrap
msgid "                /* Close the file descriptor of the event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:654
#, no-wrap
msgid ""
"                close(metadata-E<gt>fd);\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:656
#, no-wrap
msgid "            /* Advance to next event */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:661
#, no-wrap
msgid ""
"            metadata = FAN_EVENT_NEXT(metadata, len);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:669
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, poll_num;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:671
#, no-wrap
msgid "    /* Check mount point is supplied */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:676
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s MOUNT\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:678
#, no-wrap
msgid "    printf(\"Press enter key to terminate.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:680
#, no-wrap
msgid "    /* Create the file descriptor for accessing the fanotify API */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:687
#, no-wrap
msgid ""
"    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,\n"
"                       O_RDONLY | O_LARGEFILE);\n"
"    if (fd == -1) {\n"
"        perror(\"fanotify_init\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:692
#, no-wrap
msgid ""
"    /* Mark the mount for:\n"
"       - permission events before opening files\n"
"       - notification events after closing a write-enabled\n"
"         file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:699
#, no-wrap
msgid ""
"    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,\n"
"                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,\n"
"                      argv[1]) == -1) {\n"
"        perror(\"fanotify_mark\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:701 build/C/man7/inotify.7:989
#, no-wrap
msgid "    /* Prepare for polling */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:703 build/C/man7/inotify.7:991
#, no-wrap
msgid "    nfds = 2;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:705 build/C/man7/inotify.7:993
#, no-wrap
msgid "    /* Console input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:708 build/C/man7/inotify.7:996
#, no-wrap
msgid ""
"    fds[0].fd = STDIN_FILENO;\n"
"    fds[0].events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:710
#, no-wrap
msgid "    /* Fanotify input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:713 build/C/man7/inotify.7:1001
#, no-wrap
msgid ""
"    fds[1].fd = fd;\n"
"    fds[1].events = POLLIN;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:715
#, no-wrap
msgid "    /* This is the loop to wait for incoming events */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:717
#, no-wrap
msgid "    printf(\"Listening for events.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:723
#, no-wrap
msgid ""
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)     /* Interrupted by a signal */\n"
"                continue;           /* Restart poll() */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:727
#, no-wrap
msgid ""
"            perror(\"poll\");         /* Unexpected error */\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:730
#, no-wrap
msgid ""
"        if (poll_num E<gt> 0) {\n"
"            if (fds[0].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:732
#, no-wrap
msgid "                /* Console input is available: empty stdin and quit */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:737 build/C/man7/inotify.7:1024
#, no-wrap
msgid ""
"                while (read(STDIN_FILENO, &buf, 1) E<gt> 0 && buf != "
"'\\en')\n"
"                    continue;\n"
"                break;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:739 build/C/man7/inotify.7:1026
#, no-wrap
msgid "            if (fds[1].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:741
#, no-wrap
msgid "                /* Fanotify events are available */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:746
#, no-wrap
msgid ""
"                handle_events(fd);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:750
#, no-wrap
msgid ""
"    printf(\"Listening for events stopped.\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:751 build/C/man2/fanotify_init.2:260 build/C/man2/fanotify_mark.2:331 build/C/man7/inotify.7:1044 build/C/man2/inotify_add_watch.2:120 build/C/man2/inotify_init.2:103 build/C/man2/inotify_rm_watch.2:71
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:756
msgid "B<fanotify_init>(2), B<fanotify_mark>(2), B<inotify>(7)"
msgstr ""

#. type: SH
#: build/C/man7/fanotify.7:756 build/C/man2/fanotify_init.2:263 build/C/man2/fanotify_mark.2:334 build/C/man7/inotify.7:1057 build/C/man2/inotify_add_watch.2:124 build/C/man2/inotify_init.2:107 build/C/man2/inotify_rm_watch.2:75
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/fanotify.7:764 build/C/man2/fanotify_init.2:271 build/C/man2/fanotify_mark.2:342 build/C/man7/inotify.7:1065 build/C/man2/inotify_add_watch.2:132 build/C/man2/inotify_init.2:115 build/C/man2/inotify_rm_watch.2:83
msgid ""
"This page is part of release 3.79 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/fanotify_init.2:24
#, no-wrap
msgid "FANOTIFY_INIT"
msgstr ""

#. type: TH
#: build/C/man2/fanotify_init.2:24 build/C/man2/fanotify_mark.2:24
#, no-wrap
msgid "2014-10-02"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:27
msgid "fanotify_init - create and initialize fanotify group"
msgstr ""

#. type: SH
#: build/C/man2/fanotify_init.2:27 build/C/man2/fanotify_mark.2:28 build/C/man2/inotify_add_watch.2:31 build/C/man2/inotify_init.2:32 build/C/man2/inotify_rm_watch.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:29
msgid "B<#include E<lt>fcntl.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:31
msgid "B<#include E<lt>sys/fanotify.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:33
msgid ""
"B<int fanotify_init(unsigned int >I<flags>B<, unsigned int "
">I<event_f_flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:36 build/C/man2/fanotify_mark.2:39
msgid "For an overview of the fanotify API, see B<fanotify>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:40
msgid ""
"B<fanotify_init>()  initializes a new fanotify group and returns a file "
"descriptor for the event queue associated with the group."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:51
msgid ""
"The file descriptor is used in calls to B<fanotify_mark>(2)  to specify the "
"files, directories, and mounts for which fanotify events shall be created.  "
"These events are received by reading from the file descriptor.  Some events "
"are only informative, indicating that a file has been accessed.  Other "
"events can be used to determine whether another application is permitted to "
"access a file or directory.  Permission to access filesystem objects is "
"granted by writing to the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:54
msgid ""
"Multiple programs may be using the fanotify interface at the same time to "
"monitor the same files."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:58
msgid ""
"In the current implementation, the number of fanotify groups per user is "
"limited to 128.  This limit cannot be overridden."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:67
msgid ""
"Calling B<fanotify_init>()  requires the B<CAP_SYS_ADMIN> capability.  This "
"constraint might be relaxed in future versions of the API.  Therefore, "
"certain additional capability checks have been implemented as indicated "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:73
msgid ""
"The I<flags> argument contains a multi-bit field defining the notification "
"class of the listening application and further single bit fields specifying "
"the behavior of the file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:77
msgid ""
"If multiple listeners for permission events exist, the notification class is "
"used to establish the sequence in which the listeners receive the events."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:80
msgid "Only one of the following notification classes may be specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:80
#, no-wrap
msgid "B<FAN_CLASS_PRE_CONTENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:88
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files before they "
"contain their final data.  This notification class might be used by "
"hierarchical storage managers, for example."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:88
#, no-wrap
msgid "B<FAN_CLASS_CONTENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:96
msgid ""
"This value allows the receipt of events notifying that a file has been "
"accessed and events for permission decisions if a file may be accessed.  It "
"is intended for event listeners that need to access files when they already "
"contain their final content.  This notification class might be used by "
"malware detection programs, for example."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:96
#, no-wrap
msgid "B<FAN_CLASS_NOTIF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:103
msgid ""
"This is the default value.  It does not need to be specified.  This value "
"only allows the receipt of events notifying that a file has been accessed.  "
"Permission decisions before the file is accessed are not possible."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:111
msgid ""
"Listeners with different notification classes will receive events in the "
"order B<FAN_CLASS_PRE_CONTENT>, B<FAN_CLASS_CONTENT>, B<FAN_CLASS_NOTIF>.  "
"The order of notification for listeners in the same notification class is "
"undefined."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:114
msgid "The following bits can additionally be set in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:114
#, no-wrap
msgid "B<FAN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:123
msgid ""
"Set the close-on-exec flag (B<FD_CLOEXEC>)  on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:123
#, no-wrap
msgid "B<FAN_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:133
msgid ""
"Enable the nonblocking flag (B<O_NONBLOCK>)  for the file descriptor.  "
"Reading from the file descriptor will not block.  Instead, if no data is "
"available, B<read>(2)  will fail with the error B<EAGAIN>."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:133
#, no-wrap
msgid "B<FAN_UNLIMITED_QUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:139
msgid ""
"Remove the limit of 16384 events for the event queue.  Use of this flag "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:139
#, no-wrap
msgid "B<FAN_UNLIMITED_MARKS>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:145
msgid ""
"Remove the limit of 8192 marks.  Use of this flag requires the "
"B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:158
msgid ""
"The I<event_f_flags> argument defines the file status flags that will be set "
"on the open file descriptions that are created for fanotify events.  For "
"details of these flags, see the description of the I<flags> values in "
"B<open>(2).  I<event_f_flags> includes a multi-bit field for the access "
"mode.  This field can take the following values:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:158
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:161
msgid "This value allows only read access."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:161
#, no-wrap
msgid "B<O_WRONLY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:164
msgid "This value allows only write access."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:164
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:167
msgid "This value allows read and write access."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:171
msgid "Additional bits can be set in I<event_f_flags>.  The most useful values are:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:171
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:178
msgid ""
"Enable support for files exceeding 2 GB.  Failing to set this flag will "
"result in an B<EOVERFLOW> error when trying to open a large file which is "
"monitored by an fanotify group on a 32-bit system."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:178
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:186
msgid ""
"Enable the close-on-exec flag for the file descriptor.  See the description "
"of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:199
msgid ""
"The following are also allowable: B<O_APPEND>, B<O_DSYNC>, B<O_NOATIME>, "
"B<O_NONBLOCK>, and B<O_SYNC>.  Specifying any other flag in I<event_f_flags> "
"yields the error B<EINVAL> (but see BUGS)."
msgstr ""

#. type: SH
#: build/C/man2/fanotify_init.2:199 build/C/man2/fanotify_mark.2:236 build/C/man2/inotify_add_watch.2:77 build/C/man2/inotify_init.2:74 build/C/man2/inotify_rm_watch.2:48
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:206
msgid ""
"On success, B<fanotify_init>()  returns a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:216
msgid ""
"An invalid value was passed in I<flags> or I<event_f_flags>.  "
"B<FAN_ALL_INIT_FLAGS> defines all allowable bits for I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:219
msgid "The number of fanotify groups for this user exceeds 128."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:219 build/C/man2/fanotify_mark.2:274 build/C/man2/inotify_add_watch.2:109 build/C/man2/inotify_init.2:91
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:222
msgid "The allocation of memory for the notification group failed."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:222 build/C/man2/fanotify_mark.2:283
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:228
msgid ""
"This kernel does not implement B<fanotify_init>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_init.2:228
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:233
msgid ""
"The operation is not permitted because the caller lacks the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:237
msgid ""
"B<fanotify_init>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:239 build/C/man2/fanotify_mark.2:305 build/C/man2/inotify_add_watch.2:120 build/C/man2/inotify_rm_watch.2:71
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:242
msgid "As of Linux 3.17, the following bug exists:"
msgstr ""

#.  FIXME . Patch proposed: https://lkml.org/lkml/2014/9/24/967
#. type: Plain text
#: build/C/man2/fanotify_init.2:248
msgid "The B<O_CLOEXEC> is ignored when passed in I<event_f_flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:250
msgid "The following bug was present in Linux kernels before version 3.14:"
msgstr ""

#.  Fixed by commit 48149e9d3a7e924010a0daab30a6197b7d7b6580
#. type: Plain text
#: build/C/man2/fanotify_init.2:260
msgid ""
"The I<event_f_flags> argument is not checked for invalid flags.  Flags that "
"are intended only for internal use, such as B<FMODE_EXEC>, can be set, and "
"will consequently be set for the file descriptors returned when reading from "
"the fanotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_init.2:263
msgid "B<fanotify_mark>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: build/C/man2/fanotify_mark.2:24
#, no-wrap
msgid "FANOTIFY_MARK"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:28
msgid ""
"fanotify_mark - add, remove, or modify an fanotify mark on a filesystem "
"object"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:31
#, no-wrap
msgid "B<#include E<lt>sys/fanotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:35
#, no-wrap
msgid ""
"B<int fanotify_mark(int >I<fanotify_fd>B<, unsigned int >I<flags>B<,>\n"
"B<                  uint64_t >I<mask>B<, int >I<dirfd>B<, const char "
"*>I<pathname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:44
msgid ""
"B<fanotify_mark>(2)  adds, removes, or modifies an fanotify mark on a "
"filesystem object.  The caller must have read permission on the filesystem "
"object that is to be marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:49
msgid ""
"The I<fanotify_fd> argument is a file descriptor returned by "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:53
msgid ""
"I<flags> is a bit mask describing the modification to perform.  It must "
"include exactly one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:53
#, no-wrap
msgid "B<FAN_MARK_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:62
msgid ""
"The events in I<mask> will be added to the mark mask (or to the ignore "
"mask).  I<mask> must be nonempty or the error B<EINVAL> will occur."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:62
#, no-wrap
msgid "B<FAN_MARK_REMOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:71
msgid ""
"The events in argument I<mask> will be removed from the mark mask (or from "
"the ignore mask).  I<mask> must be nonempty or the error B<EINVAL> will "
"occur."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:71
#, no-wrap
msgid "B<FAN_MARK_FLUSH>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:86
msgid ""
"Remove either all mount or all non-mount marks from the fanotify group.  If "
"I<flags> contains B<FAN_MARK_MOUNT>, all marks for mounts are removed from "
"the group.  Otherwise, all marks for directories and files are removed.  No "
"flag other than B<FAN_MARK_MOUNT> can be used in conjunction with "
"B<FAN_MARK_FLUSH>.  I<mask> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:90
msgid ""
"If none of the values above is specified, or more than one is specified, the "
"call fails with the error B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:94
msgid "In addition, zero or more of the following values may be ORed into I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:94
#, no-wrap
msgid "B<FAN_MARK_DONT_FOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:105
msgid ""
"If I<pathname> is a symbolic link, mark the link itself, rather than the "
"file to which it refers.  (By default, B<fanotify_mark>()  dereferences "
"I<pathname> if it is a symbolic link.)"
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:105
#, no-wrap
msgid "B<FAN_MARK_ONLYDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:110
msgid ""
"If the filesystem object to be marked is not a directory, the error "
"B<ENOTDIR> shall be raised."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:110
#, no-wrap
msgid "B<FAN_MARK_MOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:121
msgid ""
"Mark the mount point specified by I<pathname>.  If I<pathname> is not itself "
"a mount point, the mount point containing I<pathname> will be marked.  All "
"directories, subdirectories, and the contained files of the mount point will "
"be monitored."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:121
#, no-wrap
msgid "B<FAN_MARK_IGNORED_MASK>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:126
msgid "The events in I<mask> shall be added to or removed from the ignore mask."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:126
#, no-wrap
msgid "B<FAN_MARK_IGNORED_SURV_MODIFY>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:132
msgid ""
"The ignore mask shall survive modify events.  If this flag is not set, the "
"ignore mask is cleared when a modify event occurs for the ignored file or "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:136
msgid ""
"I<mask> defines which events shall be listened for (or which shall be "
"ignored).  It is a bit mask composed of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:139
msgid "Create an event when a file or directory (but see BUGS) is accessed (read)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:142
msgid "Create an event when a file is modified (write)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:145
msgid "Create an event when a writable file is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:148
msgid "Create an event when a read-only file or directory is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:151
msgid "Create an event when a file or directory is opened."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:159
msgid ""
"Create an event when a permission to open a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:167
msgid ""
"Create an event when a permission to read a file or directory is requested.  "
"An fanotify file descriptor created with B<FAN_CLASS_PRE_CONTENT> or "
"B<FAN_CLASS_CONTENT> is required."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:167
#, no-wrap
msgid "B<FAN_ONDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:176
msgid ""
"Create events for directories\\(emfor example, when B<opendir>(3), "
"B<readdir>(3)  (but see BUGS), and B<closedir>(3)  are called.  Without this "
"flag, only events for files are created."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:176
#, no-wrap
msgid "B<FAN_EVENT_ON_CHILD>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:184
msgid ""
"Events for the immediate children of marked directories shall be created.  "
"The flag has no effect when marking mounts.  Note that events are not "
"generated for children of the subdirectories of marked directories.  To "
"monitor complete directory trees it is necessary to mark the relevant mount."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:186
msgid "The following composed value is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:190
msgid "A file is closed (B<FAN_CLOSE_WRITE>|B<FAN_CLOSE_NOWRITE>)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:195
msgid ""
"The filesystem object to be marked is determined by the file descriptor "
"I<dirfd> and the pathname specified in I<pathname>:"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:201
msgid "If I<pathname> is NULL, I<dirfd> defines the filesystem object to be marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:209
msgid ""
"If I<pathname> is NULL, and I<dirfd> takes the special value B<AT_FDCWD>, "
"the current working directory is to be marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:215
msgid ""
"If I<pathname> is absolute, it defines the filesystem object to be marked, "
"and I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:226
msgid ""
"If I<pathname> is relative, and I<dirfd> does not have the value "
"B<AT_FDCWD>, then the filesystem object to be marked is determined by "
"interpreting I<pathname> relative the directory referred to by I<dirfd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:236
msgid ""
"If I<pathname> is relative, and I<dirfd> has the value B<AT_FDCWD>, then the "
"filesystem object to be marked is determined by interpreting I<pathname> "
"relative the current working directory."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:243
msgid ""
"On success, B<fanotify_mark>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:244 build/C/man2/inotify_add_watch.2:88 build/C/man2/inotify_rm_watch.2:56
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:248
msgid "An invalid file descriptor was passed in I<fanotify_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:257
msgid ""
"An invalid value was passed in I<flags> or I<mask>, or I<fanotify_fd> was "
"not an fanotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:265
msgid ""
"The fanotify file descriptor was opened with B<FAN_CLASS_NOTIF> and mask "
"contains a flag for permission events (B<FAN_OPEN_PERM> or "
"B<FAN_ACCESS_PERM>)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:274
msgid ""
"The filesystem object indicated by I<dirfd> and I<pathname> does not exist.  "
"This error also occurs when trying to remove a mark from an object which is "
"not marked."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:277
msgid "The necessary memory could not be allocated."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:277 build/C/man2/inotify_add_watch.2:112
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:283
msgid ""
"The number of marks exceeds the limit of 8192 and the B<FAN_UNLIMITED_MARKS> "
"flag was not specified when the fanotify file descriptor was created with "
"B<fanotify_init>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:289
msgid ""
"This kernel does not implement B<fanotify_mark>().  The fanotify API is "
"available only if the kernel was configured with B<CONFIG_FANOTIFY>."
msgstr ""

#. type: TP
#: build/C/man2/fanotify_mark.2:289
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:299
msgid ""
"I<flags> contains B<FAN_MARK_ONLYDIR>, and I<dirfd> and I<pathname> do not "
"specify a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:303
msgid ""
"B<fanotify_mark>()  was introduced in version 2.6.36 of the Linux kernel and "
"enabled in version 2.6.37."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:307
msgid "The following bugs were present in Linux kernels before version 3.16:"
msgstr ""

#.  Fixed by commit 0a8dd2db579f7a0ac7033d6b857c3d5dbaa77563
#. type: Plain text
#: build/C/man2/fanotify_mark.2:317
msgid ""
"If I<flags> contains B<FAN_MARK_FLUSH>, I<dirfd> and I<pathname> must "
"specify a valid filesystem object, even though this object is not used."
msgstr ""

#.  Fixed by commit d4c7cf6cffb1bc711a833b5e304ba5bcfe76398b
#. type: Plain text
#: build/C/man2/fanotify_mark.2:323
msgid "B<readdir>(2)  does not generate a B<FAN_ACCESS> event."
msgstr ""

#.  Fixed by commit cc299a98eb13a9853675a9cbb90b30b4011e1406
#. type: Plain text
#: build/C/man2/fanotify_mark.2:331
msgid ""
"If B<fanotify_mark>(2)  is called with B<FAN_MARK_FLUSH>, I<flags> is not "
"checked for invalid values."
msgstr ""

#. type: Plain text
#: build/C/man2/fanotify_mark.2:334
msgid "B<fanotify_init>(2), B<fanotify>(7)"
msgstr ""

#. type: TH
#: build/C/man7/inotify.7:27
#, no-wrap
msgid "INOTIFY"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:30
msgid "inotify - monitoring filesystem events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:38
msgid ""
"The I<inotify> API provides a mechanism for monitoring filesystem events.  "
"Inotify can be used to monitor individual files, or to monitor directories.  "
"When a directory is monitored, inotify will return events for the directory "
"itself, and for files inside the directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:40
msgid "The following system calls are used with this API:"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:51
msgid ""
"B<inotify_init>(2)  creates an inotify instance and returns a file "
"descriptor referring to the inotify instance.  The more recent "
"B<inotify_init1>(2)  is like B<inotify_init>(2), but has a I<flags> argument "
"that provides access to some extra functionality."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:64
msgid ""
"B<inotify_add_watch>(2)  manipulates the \"watch list\" associated with an "
"inotify instance.  Each item (\"watch\") in the watch list specifies the "
"pathname of a file or directory, along with some set of events that the "
"kernel should monitor for the file referred to by that pathname.  "
"B<inotify_add_watch>(2)  either creates a new watch item, or modifies an "
"existing watch.  Each watch has a unique \"watch descriptor\", an integer "
"returned by B<inotify_add_watch>(2)  when the watch is created."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:70
msgid ""
"When events occur for monitored files and directories, those events are made "
"available to the application as structured data that can be read from the "
"inotify file descriptor using B<read>(2)  (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:73
msgid "B<inotify_rm_watch>(2)  removes an item from an inotify watch list."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:80
msgid ""
"When all file descriptors referring to an inotify instance have been closed "
"(using B<close>(2)), the underlying object and its resources are freed for "
"reuse by the kernel; all associated watches are automatically freed."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:89
msgid ""
"With careful programming, an application can use inotify to efficiently "
"monitor and cache the state of a set of filesystem objects.  However, robust "
"applications should allow for the fact that bugs in the monitoring logic or "
"races of the kind described below may leave the cache inconsistent with the "
"filesystem state.  It is probably wise to to do some consistency checking, "
"and rebuild the cache when inconsistencies are detected."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:89
#, no-wrap
msgid "Reading events from an inotify file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:102
msgid ""
"To determine what events have occurred, an application B<read>(2)s from the "
"inotify file descriptor.  If no events have so far occurred, then, assuming "
"a blocking file descriptor, B<read>(2)  will block until at least one event "
"occurs (unless interrupted by a signal, in which case the call fails with "
"the error B<EINTR>; see B<signal>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:106
msgid ""
"Each successful B<read>(2)  returns a buffer containing one or more of the "
"following structures:"
msgstr ""

#.  FIXME . The type of the 'wd' field should probably be "int32_t".
#.  I submitted a patch to fix this.  See the LKML thread
#.  "[patch] Fix type errors in inotify interfaces", 18 Nov 2008
#.  Glibc bug filed: http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man7/inotify.7:121
#, no-wrap
msgid ""
"struct inotify_event {\n"
"    int      wd;       /* Watch descriptor */\n"
"    uint32_t mask;     /* Mask describing event */\n"
"    uint32_t cookie;   /* Unique cookie associating related\n"
"                          events (for rename(2)) */\n"
"    uint32_t len;      /* Size of I<name> field */\n"
"    char     name[];   /* Optional null-terminated name */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:128
msgid ""
"I<wd> identifies the watch for which this event occurs.  It is one of the "
"watch descriptors returned by a previous call to B<inotify_add_watch>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:131
msgid "I<mask> contains bits that describe the event that occurred (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:143
msgid ""
"I<cookie> is a unique integer that connects related events.  Currently this "
"is used only for rename events, and allows the resulting pair of "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events to be connected by the "
"application.  For all other event types, I<cookie> is set to 0."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:152
msgid ""
"The I<name> field is present only when an event is returned for a file "
"inside a watched directory; it identifies the file pathname relative to the "
"watched directory.  This pathname is null-terminated, and may include "
"further null bytes (\\(aq\\e0\\(aq) to align subsequent reads to a suitable "
"address boundary."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:162
msgid ""
"The I<len> field counts all of the bytes in I<name>, including the null "
"bytes; the length of each I<inotify_event> structure is thus I<sizeof(struct "
"inotify_event)+len>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:173
msgid ""
"The behavior when the buffer given to B<read>(2)  is too small to return "
"information about the next event depends on the kernel version: in kernels "
"before 2.6.21, B<read>(2)  returns 0; since kernel 2.6.21, B<read>(2)  fails "
"with the error B<EINVAL>.  Specifying a buffer of size"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:175
#, no-wrap
msgid "    sizeof(struct inotify_event) + NAME_MAX + 1\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:177
msgid "will be sufficient to read at least one event."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:177
#, no-wrap
msgid "inotify events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:197
msgid ""
"The B<inotify_add_watch>(2)  I<mask> argument and the I<mask> field of the "
"I<inotify_event> structure returned when B<read>(2)ing an inotify file "
"descriptor are both bit masks identifying inotify events.  The following "
"bits can be specified in I<mask> when calling B<inotify_add_watch>(2)  and "
"may be returned in the I<mask> field returned by B<read>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:198
#, no-wrap
msgid "B<IN_ACCESS> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:203
msgid "File was accessed (e.g., B<read>(2), B<execve>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:203
#, no-wrap
msgid "B<IN_ATTRIB> (*)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:218
msgid ""
"Metadata changed\\(emfor example, permissions (e.g., B<chmod>(2)), "
"timestamps (e.g., B<utimensat>(2)), extended attributes (B<setxattr>(2)), "
"link count (since Linux 2.6.25; e.g., for the target of B<link>(2)  and for "
"B<unlink>(2)), and user/group ID (e.g., B<chown>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:218
#, no-wrap
msgid "B<IN_CLOSE_WRITE> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:221
msgid "File opened for writing was closed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:221
#, no-wrap
msgid "B<IN_CLOSE_NOWRITE> (*)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:224
msgid "File or directory not opened for writing was closed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:224
#, no-wrap
msgid "B<IN_CREATE> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:234
msgid ""
"File/directory created in watched directory (e.g., B<open>(2)  B<O_CREAT>, "
"B<mkdir>(2), B<link>(2), B<symlink>(2), B<bind>(2)  on a UNIX domain "
"socket)."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:234
#, no-wrap
msgid "B<IN_DELETE> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:237
msgid "File/directory deleted from watched directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:237
#, no-wrap
msgid "B<IN_DELETE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:248
msgid ""
"Watched file/directory was itself deleted.  (This event also occurs if an "
"object is moved to another filesystem, since B<mv>(1)  in effect copies the "
"file to the other filesystem and then deletes it from the original "
"filesystem.)  In addition, an B<IN_IGNORED> event will subsequently be "
"generated for the watch descriptor."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:248
#, no-wrap
msgid "B<IN_MODIFY> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:253
msgid "File was modified (e.g., B<write>(2), B<truncate>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:253
#, no-wrap
msgid "B<IN_MOVE_SELF>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:256
msgid "Watched file/directory was itself moved."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:256
#, no-wrap
msgid "B<IN_MOVED_FROM> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:260
msgid ""
"Generated for the directory containing the old filename when a file is "
"renamed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:260
#, no-wrap
msgid "B<IN_MOVED_TO> (+)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:264
msgid ""
"Generated for the directory containing the new filename when a file is "
"renamed."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:264
#, no-wrap
msgid "B<IN_OPEN> (*)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:267
msgid "File or directory was opened."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:270
msgid "When monitoring a directory:"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:273
msgid ""
"the events marked above with an asterisk (*) can occur both for the "
"directory itself and for objects inside the directory; and"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:276
msgid ""
"the events marked with a plus sign (+) occur only for objects inside the "
"directory (not for the directory itself)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:282
msgid ""
"When events are generated for objects inside a watched directory, the "
"I<name> field in the returned I<inotify_event> structure identifies the name "
"of the file within the directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:290
msgid ""
"The B<IN_ALL_EVENTS> macro is defined as a bit mask of all of the above "
"events.  This macro can be used as the I<mask> argument when calling "
"B<inotify_add_watch>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:292
msgid "Two additional convenience macros are defined:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:293
#, no-wrap
msgid "B<IN_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:297
msgid "Equates to B<IN_MOVED_FROM | IN_MOVED_TO>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:297
#, no-wrap
msgid "B<IN_CLOSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:301
msgid "Equates to B<IN_CLOSE_WRITE | IN_CLOSE_NOWRITE>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:307
msgid ""
"The following further bits can be specified in I<mask> when calling "
"B<inotify_add_watch>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:308
#, no-wrap
msgid "B<IN_DONT_FOLLOW> (since Linux 2.6.15)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:313
msgid "Don't dereference I<pathname> if it is a symbolic link."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:313
#, no-wrap
msgid "B<IN_EXCL_UNLINK> (since Linux 2.6.36)"
msgstr ""

#.  commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
#. type: Plain text
#: build/C/man7/inotify.7:329
msgid ""
"By default, when watching events on the children of a directory, events are "
"generated for children even after they have been unlinked from the "
"directory.  This can result in large numbers of uninteresting events for "
"some applications (e.g., if watching I</tmp>, in which many applications "
"create temporary files whose names are immediately unlinked).  Specifying "
"B<IN_EXCL_UNLINK> changes the default behavior, so that events are not "
"generated for children after they have been unlinked from the watched "
"directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:329
#, no-wrap
msgid "B<IN_MASK_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:336
msgid ""
"If a watch instance already exists for the filesystem object corresponding "
"to I<pathname>, add (OR) the events in I<mask> to the watch mask (instead of "
"replacing the mask)."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:336
#, no-wrap
msgid "B<IN_ONESHOT>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:342
msgid ""
"Monitor the filesystem object corresponding to I<pathname> for one event, "
"then remove from watch list."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:342
#, no-wrap
msgid "B<IN_ONLYDIR> (since Linux 2.6.15)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:349
msgid ""
"Only watch I<pathname> if it is a directory.  Using this flag provides an "
"application with a race-free way of ensuring that the monitored object is a "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:355
msgid "The following bits may be set in the I<mask> field returned by B<read>(2):"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:356
#, no-wrap
msgid "B<IN_IGNORED>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:362
msgid ""
"Watch was removed explicitly (B<inotify_rm_watch>(2))  or automatically "
"(file was deleted, or filesystem was unmounted).  See also BUGS."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:362
#, no-wrap
msgid "B<IN_ISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:365
msgid "Subject of this event is a directory."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:365
#, no-wrap
msgid "B<IN_Q_OVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:370
msgid "Event queue overflowed (I<wd> is -1 for this event)."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:370
#, no-wrap
msgid "B<IN_UNMOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:376
msgid ""
"Filesystem containing watched object was unmounted.  In addition, an "
"B<IN_IGNORED> event will subsequently be generated for the watch descriptor."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:377
#, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:385
msgid ""
"Suppose an application is watching the directory I<dir> and the file "
"I<dir/myfile> for all events.  The examples below show some events that will "
"be generated for these two objects."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:386
#, no-wrap
msgid "fd = open(\"dir/myfile\", O_RDWR);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:394
msgid "Generates B<IN_OPEN> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:394
#, no-wrap
msgid "read(fd, buf, count);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:402
msgid "Generates B<IN_ACCESS> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:402
#, no-wrap
msgid "write(fd, buf, count);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:410
msgid "Generates B<IN_MODIFY> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:410
#, no-wrap
msgid "fchmod(fd, mode);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:418
msgid "Generates B<IN_ATTRIB> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:418
#, no-wrap
msgid "close(fd);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:426
msgid "Generates B<IN_CLOSE_WRITE> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:435
msgid ""
"Suppose an application is watching the directories I<dir1> and I<dir2>, and "
"the file I<dir1/myfile>.  The following examples show some events that may "
"be generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:436
#, no-wrap
msgid "link(\"dir1/myfile\", \"dir2/new\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:446
msgid ""
"Generates an B<IN_ATTRIB> event for I<myfile> and an B<IN_CREATE> event for "
"I<dir2>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:446
#, no-wrap
msgid "rename(\"dir1/myfile\", \"dir2/myfile\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:467
msgid ""
"Generates an B<IN_MOVED_FROM> event for I<dir1>, an B<IN_MOVED_TO> event for "
"I<dir2>, and an B<IN_MOVE_SELF> event for I<myfile>.  The B<IN_MOVED_FROM> "
"and B<IN_MOVED_TO> events will have the same I<cookie> value."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:481
msgid ""
"Suppose that I<dir1/xx> and I<dir2/yy> are (the only) links to the same "
"file, and an application is watching I<dir1>, I<dir2>, I<dir1/xx>, and "
"I<dir2/yy>.  Executing the following calls in the order given below will "
"generate the following events:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:482
#, no-wrap
msgid "unlink(\"dir2/yy\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:493
msgid ""
"Generates an B<IN_ATTRIB> event for I<xx> (because its link count changes)  "
"and an B<IN_DELETE> event for I<dir2>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:493
#, no-wrap
msgid "unlink(\"dir1/xx\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:506
msgid ""
"Generates B<IN_ATTRIB>, B<IN_DELETE_SELF>, and B<IN_IGNORED> events for "
"I<xx>, and an B<IN_DELETE> event for I<dir1>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:513
msgid ""
"Suppose an application is watching the directory I<dir> and (the empty) "
"directory I<dir/subdir>.  The following examples show some events that may "
"be generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:514
#, no-wrap
msgid "mkdir(\"dir/new\", mode);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:520
msgid "Generates an B<IN_CREATE | IN_ISDIR> event for I<dir>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:520
#, no-wrap
msgid "rmdir(\"dir/subdir\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:532
msgid ""
"Generates B<IN_DELETE_SELF> and B<IN_IGNORED> events for I<subdir>, and an "
"B<IN_DELETE | IN_ISDIR> event for I<dir>."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:533
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:536
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by inotify:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:536
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_queued_events>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:545
msgid ""
"The value in this file is used when an application calls B<inotify_init>(2)  "
"to set an upper limit on the number of events that can be queued to the "
"corresponding inotify instance.  Events in excess of this limit are dropped, "
"but an B<IN_Q_OVERFLOW> event is always generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:545
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_instances>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:549
msgid ""
"This specifies an upper limit on the number of inotify instances that can be "
"created per real user ID."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:549
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_watches>"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:553
msgid ""
"This specifies an upper limit on the number of watches that can be created "
"per real user ID."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:561
msgid ""
"Inotify was merged into the 2.6.13 Linux kernel.  The required library "
"interfaces were added to glibc in version 2.4.  (B<IN_DONT_FOLLOW>, "
"B<IN_MASK_ADD>, and B<IN_ONLYDIR> were added in glibc version 2.5.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:563
msgid "The inotify API is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:570
msgid ""
"Inotify file descriptors can be monitored using B<select>(2), B<poll>(2), "
"and B<epoll>(7).  When an event is available, the file descriptor indicates "
"as readable."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:599
msgid ""
"Since Linux 2.6.25, signal-driven I/O notification is available for inotify "
"file descriptors; see the discussion of B<F_SETFL> (for setting the "
"B<O_ASYNC> flag), B<F_SETOWN>, and B<F_SETSIG> in B<fcntl>(2).  The "
"I<siginfo_t> structure (described in B<sigaction>(2))  that is passed to the "
"signal handler has the following fields set: I<si_fd> is set to the inotify "
"file descriptor number; I<si_signo> is set to the signal number; I<si_code> "
"is set to B<POLL_IN>; and B<POLLIN> is set in I<si_band>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:612
msgid ""
"If successive output inotify events produced on the inotify file descriptor "
"are identical (same I<wd>, I<mask>, I<cookie>, and I<name>), then they are "
"coalesced into a single event if the older event has not yet been read (but "
"see BUGS).  This reduces the amount of kernel memory required for the event "
"queue, but also means that an application can't use inotify to reliably "
"count file events."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:618
msgid ""
"The events returned by reading from an inotify file descriptor form an "
"ordered queue.  Thus, for example, it is guaranteed that when renaming from "
"one directory to another, events will be produced in the correct order on "
"the inotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:624
msgid ""
"The B<FIONREAD> B<ioctl>(2)  returns the number of bytes available to read "
"from an inotify file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:631
msgid ""
"The inotify API provides no information about the user or process that "
"triggered the inotify event.  In particular, there is no easy way for a "
"process that is monitoring events via inotify to distinguish events that it "
"triggers itself from those that are triggered by other processes."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:644
msgid ""
"Inotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems.  (Applications must fall back to polling the filesystem "
"to catch such events.)  Furthermore, various pseudo-filesystems such as "
"I</proc>, I</sys>, and I</dev/pts> are not monitorable with inotify."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:651
msgid ""
"The inotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2), B<msync>(2), and B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:655
msgid ""
"The inotify API identifies affected files by filename.  However, by the time "
"an application processes an inotify event, the filename may already have "
"been deleted or renamed."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:660
msgid ""
"The inotify API identifies events via watch descriptors.  It is the "
"application's responsibility to cache a mapping (if one is needed) between "
"watch descriptors and pathnames.  Be aware that directory renamings may "
"affect multiple cached pathnames."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:665
msgid ""
"Inotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional watches must be created.  This "
"can take a significant amount time for large directory trees."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:674
msgid ""
"If monitoring an entire directory subtree, and a new subdirectory is created "
"in that tree or an existing directory is renamed into that tree, be aware "
"that by the time you create a watch for the new subdirectory, new files (and "
"subdirectories) may already exist inside the subdirectory.  Therefore, you "
"may want to scan the contents of the subdirectory immediately after adding "
"the watch (and, if desired, recursively add watches for any subdirectories "
"that it contains)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:686
msgid ""
"Note that the event queue can overflow.  In this case, events are lost.  "
"Robust applications should handle the possibility of lost events "
"gracefully.  For example, it may be necessary to rebuild part or all of the "
"application cache.  (One simple, but possibly expensive, approach is to "
"close the inotify file descriptor, empty the cache, create a new inotify "
"file descriptor, and then re-create watches and cache entries for the "
"objects to be monitored.)"
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:686
#, no-wrap
msgid "Dealing with rename() events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:695
msgid ""
"As noted above, the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair that is "
"generated by B<rename>(2)  can be matched up via their shared cookie value.  "
"However, the task of matching has some challenges."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:712
msgid ""
"These two events are usually consecutive in the event stream available when "
"reading from the inotify file descriptor.  However, this is not guaranteed.  "
"If multiple processes are triggering events for monitored objects, then (on "
"rare occasions) an arbitrary number of other events may appear between the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events.  Furthermore, it is not "
"guaranteed that the event pair is atomically inserted into the queue: there "
"may be a brief interval where the B<IN_MOVED_FROM> has appeared, but the "
"B<IN_MOVED_TO> has not."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:737
msgid ""
"Matching up the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair generated by "
"B<rename>(2)  is thus inherently racy.  (Don't forget that if an object is "
"renamed outside of a monitored directory, there may not even be an "
"B<IN_MOVED_TO> event.)  Heuristic approaches (e.g., assume the events are "
"always consecutive)  can be used to ensure a match in most cases, but will "
"inevitably miss some cases, causing the application to perceive the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events as being unrelated.  If watch "
"descriptors are destroyed and re-created as a result, then those watch "
"descriptors will be inconsistent with the watch descriptors in any pending "
"events.  (Re-creating the inotify file descriptor and rebuilding the cache "
"may be useful to deal with this scenario.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:754
msgid ""
"Applications should also allow for the possibility that the B<IN_MOVED_FROM> "
"event was the last event that could fit in the buffer returned by the "
"current call to B<read>(2), and the accompanying B<IN_MOVED_TO> event might "
"be fetched only on the next B<read>(2), which should be done with a (small) "
"timeout to allow for the fact that insertion of the "
"B<IN_MOVED_FROM>-B<IN_MOVED_TO> event pair is not atomic, and also the "
"possibility that there may not be any B<IN_MOVED_TO> event."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:758
msgid ""
"As of kernel 3.17, calling B<fallocate>(2)  does not create any inotify "
"events."
msgstr ""

#.  FIXME . kernel commit 611da04f7a31b2208e838be55a42c7a1310ae321
#.  implies that unmount events were buggy 2.6.11 to 2.6.36
#. type: Plain text
#: build/C/man7/inotify.7:766
msgid "In kernels before 2.6.16, the B<IN_ONESHOT> I<mask> flag does not work."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:776
msgid ""
"As originally designed and implemented, the B<IN_ONESHOT> flag did not cause "
"an B<IN_IGNORED> event to be generated when the watch was dropped after one "
"event.  However, as an unintended effect of other changes, since Linux "
"2.6.36, an B<IN_IGNORED> event is generated in this case."
msgstr ""

#.  commit 1c17d18e3775485bf1e0ce79575eb637a94494a2
#. type: Plain text
#: build/C/man7/inotify.7:785
msgid ""
"Before kernel 2.6.25, the kernel code that was intended to coalesce "
"successive identical events (i.e., the two most recent events could "
"potentially be coalesced if the older had not yet been read)  instead "
"checked if the most recent event could be coalesced with the I<oldest> "
"unread event."
msgstr ""

#.  FIXME . https://bugzilla.kernel.org/show_bug.cgi?id=77111
#. type: Plain text
#: build/C/man7/inotify.7:815
msgid ""
"When a watch descriptor is removed by calling B<inotify_rm_watch>(2)  (or "
"because a watch file is deleted or the filesystem that contains it is "
"unmounted), any pending unread events for that watch descriptor remain "
"available to read.  As watch descriptors are subsequently allocated with "
"B<inotify_add_watch>(2), the kernel cycles through the range of possible "
"watch descriptors (0 to B<INT_MAX>)  incrementally.  When allocating a free "
"watch descriptor, no check is made to see whether that watch descriptor "
"number has any pending unread events in the inotify queue.  Thus, it can "
"happen that a watch descriptor is reallocated even when pending unread "
"events exist for a previous incarnation of that watch descriptor number, "
"with the result that the application might then read those events and "
"interpret them as belonging to the file associated with the newly recycled "
"watch descriptor.  In practice, the likelihood of hitting this bug may be "
"extremely low, since it requires that an application cycle through "
"B<INT_MAX> watch descriptors, release a watch descriptor while leaving "
"unread events for that watch descriptor in the queue, and then recycle that "
"watch descriptor.  For this reason, and because there have been no reports "
"of the bug occurring in real-world applications, as of Linux 3.15, no kernel "
"changes have yet been made to eliminate this possible bug."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:823
msgid ""
"The following program demonstrates the usage of the inotify API.  It marks "
"the directories passed as a command-line arguments and waits for events of "
"type B<IN_OPEN>, B<IN_CLOSE_NOWRITE> and B<IN_CLOSE_WRITE>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:838
msgid ""
"The following output was recorded while editing the file "
"I</home/user/temp/foo> and listing directory I</tmp>.  Before the file and "
"the directory were opened, B<IN_OPEN> events occurred.  After the file was "
"closed, an B<IN_CLOSE_WRITE> event occurred.  After the directory was "
"closed, an B<IN_CLOSE_NOWRITE> event occurred.  Execution of the program "
"ended when the user pressed the ENTER key."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:848
#, no-wrap
msgid ""
"$ B<./a.out /tmp /home/user/temp>\n"
"Press enter key to terminate.\n"
"Listening for events.\n"
"IN_OPEN: /home/user/temp/foo [file]\n"
"IN_CLOSE_WRITE: /home/user/temp/foo [file]\n"
"IN_OPEN: /tmp/ [directory]\n"
"IN_CLOSE_NOWRITE: /tmp/ [directory]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:860
#, no-wrap
msgid ""
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>poll.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/inotify.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:866
#, no-wrap
msgid ""
"/* Read all available inotify events from the file descriptor 'fd'.\n"
"   wd is the table of watch descriptors for the directories in argv.\n"
"   argc is the length of wd and argv.\n"
"   argv is the list of watched directories.\n"
"   Entry 0 of wd and argv is unused. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:875
#, no-wrap
msgid ""
"static void\n"
"handle_events(int fd, int *wd, int argc, char* argv[])\n"
"{\n"
"    /* Some systems cannot read integer variables if they are not\n"
"       properly aligned. On other systems, incorrect alignment may\n"
"       decrease performance. Hence, the buffer used for reading from\n"
"       the inotify file descriptor should have the same alignment as\n"
"       struct inotify_event. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:882
#, no-wrap
msgid ""
"    char buf[4096]\n"
"        __attribute__ ((aligned(__alignof__(struct inotify_event))));\n"
"    const struct inotify_event *event;\n"
"    int i;\n"
"    ssize_t len;\n"
"    char *ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:884
#, no-wrap
msgid "    /* Loop while events can be read from inotify file descriptor. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:886
#, no-wrap
msgid "    for (;;) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:888
#, no-wrap
msgid "        /* Read some events. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:894
#, no-wrap
msgid ""
"        len = read(fd, buf, sizeof buf);\n"
"        if (len == -1 && errno != EAGAIN) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:898
#, no-wrap
msgid ""
"        /* If the nonblocking read() found no events to read, then\n"
"           it returns -1 with errno set to EAGAIN. In that case,\n"
"           we exit the loop. */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:906
#, no-wrap
msgid ""
"        for (ptr = buf; ptr E<lt> buf + len;\n"
"                ptr += sizeof(struct inotify_event) + event-E<gt>len) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:908
#, no-wrap
msgid "            event = (const struct inotify_event *) ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:910
#, no-wrap
msgid "            /* Print event type */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:917
#, no-wrap
msgid ""
"            if (event-E<gt>mask & IN_OPEN)\n"
"                printf(\"IN_OPEN: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_NOWRITE)\n"
"                printf(\"IN_CLOSE_NOWRITE: \");\n"
"            if (event-E<gt>mask & IN_CLOSE_WRITE)\n"
"                printf(\"IN_CLOSE_WRITE: \");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:919
#, no-wrap
msgid "            /* Print the name of the watched directory */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:926
#, no-wrap
msgid ""
"            for (i = 1; i E<lt> argc; ++i) {\n"
"                if (wd[i] == event-E<gt>wd) {\n"
"                    printf(\"%s/\", argv[i]);\n"
"                    break;\n"
"                }\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:928
#, no-wrap
msgid "            /* Print the name of the file */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:931
#, no-wrap
msgid ""
"            if (event-E<gt>len)\n"
"                printf(\"%s\", event-E<gt>name);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:933
#, no-wrap
msgid "            /* Print type of filesystem object */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:941
#, no-wrap
msgid ""
"            if (event-E<gt>mask & IN_ISDIR)\n"
"                printf(\" [directory]\\en\");\n"
"            else\n"
"                printf(\" [file]\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:950
#, no-wrap
msgid ""
"int\n"
"main(int argc, char* argv[])\n"
"{\n"
"    char buf;\n"
"    int fd, i, poll_num;\n"
"    int *wd;\n"
"    nfds_t nfds;\n"
"    struct pollfd fds[2];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:955
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s PATH [PATH ...]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:957
#, no-wrap
msgid "    printf(\"Press ENTER key to terminate.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:959
#, no-wrap
msgid "    /* Create the file descriptor for accessing the inotify API */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:965
#, no-wrap
msgid ""
"    fd = inotify_init1(IN_NONBLOCK);\n"
"    if (fd == -1) {\n"
"        perror(\"inotify_init1\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:967
#, no-wrap
msgid "    /* Allocate memory for watch descriptors */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:973
#, no-wrap
msgid ""
"    wd = calloc(argc, sizeof(int));\n"
"    if (wd == NULL) {\n"
"        perror(\"calloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:977
#, no-wrap
msgid ""
"    /* Mark directories for events\n"
"       - file was opened\n"
"       - file was closed */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:987
#, no-wrap
msgid ""
"    for (i = 1; i E<lt> argc; i++) {\n"
"        wd[i] = inotify_add_watch(fd, argv[i],\n"
"                                  IN_OPEN | IN_CLOSE);\n"
"        if (wd[i] == -1) {\n"
"            fprintf(stderr, \"Cannot watch '%s'\\en\", argv[i]);\n"
"            perror(\"inotify_add_watch\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:998
#, no-wrap
msgid "    /* Inotify input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1003
#, no-wrap
msgid "    /* Wait for events and/or terminal input */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1013
#, no-wrap
msgid ""
"    printf(\"Listening for events.\\en\");\n"
"    while (1) {\n"
"        poll_num = poll(fds, nfds, -1);\n"
"        if (poll_num == -1) {\n"
"            if (errno == EINTR)\n"
"                continue;\n"
"            perror(\"poll\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1015
#, no-wrap
msgid "        if (poll_num E<gt> 0) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1017
#, no-wrap
msgid "            if (fds[0].revents & POLLIN) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1019
#, no-wrap
msgid "                /* Console input is available. Empty stdin and quit */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1028
#, no-wrap
msgid "                /* Inotify events are available */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1033
#, no-wrap
msgid ""
"                handle_events(fd, wd, argc, argv);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1035
#, no-wrap
msgid "    printf(\"Listening for events stopped.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1037
#, no-wrap
msgid "    /* Close inotify file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1039
#, no-wrap
msgid "    close(fd);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1043
#, no-wrap
msgid ""
"    free(wd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1054
msgid ""
"B<inotifywait>(1), B<inotifywatch>(1), B<inotify_add_watch>(2), "
"B<inotify_init>(2), B<inotify_init1>(2), B<inotify_rm_watch>(2), B<read>(2), "
"B<stat>(2), B<fanotify>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:1057
msgid "I<Documentation/filesystems/inotify.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/inotify_add_watch.2:28
#, no-wrap
msgid "INOTIFY_ADD_WATCH"
msgstr ""

#. type: TH
#: build/C/man2/inotify_add_watch.2:28
#, no-wrap
msgid "2014-07-08"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:31
msgid "inotify_add_watch - add a watch to an initialized inotify instance"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:33 build/C/man2/inotify_rm_watch.2:32
msgid "B<#include E<lt>sys/inotify.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:35
msgid ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:54
msgid ""
"B<inotify_add_watch>()  adds a new watch, or modifies an existing watch, for "
"the file whose location is specified in I<pathname>; the caller must have "
"read permission for this file.  The I<fd> argument is a file descriptor "
"referring to the inotify instance whose watch list is to be modified.  The "
"events to be monitored for I<pathname> are specified in the I<mask> bit-mask "
"argument.  See B<inotify>(7)  for a description of the bits that can be set "
"in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:66
msgid ""
"A successful call to B<inotify_add_watch>()  returns a unique watch "
"descriptor for this inotify instance, for the filesystem object that "
"corresponds to I<pathname>.  If the filesystem object was not previously "
"being watched by this inotify instance, then the watch descriptor is newly "
"allocated.  If the filesystem object was already being watched (perhaps via "
"a different link to the same object), then the descriptor for the existing "
"watch is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:77
msgid ""
"The watch descriptor is returned by later B<read>(2)s from the inotify file "
"descriptor.  These reads fetch I<inotify_event> structures (see "
"B<inotify>(7))  indicating filesystem events; the watch descriptor inside "
"this structure identifies the object for which the event occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:84
msgid ""
"On success, B<inotify_add_watch>()  returns a nonnegative watch descriptor.  "
"On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:85
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:88
msgid "Read access to the given file is not permitted."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:91
msgid "The given file descriptor is not valid."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:91
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:95
msgid "I<pathname> points outside of the process's accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:100
msgid ""
"The given event mask contains no valid events; or I<fd> is not an inotify "
"file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:100
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:104
msgid "I<pathname> is too long."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:109
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:112
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:116
msgid ""
"The user limit on the total number of inotify watches was reached or the "
"kernel failed to allocate a needed resource."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:118 build/C/man2/inotify_rm_watch.2:69
msgid "Inotify was merged into the 2.6.13 Linux kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:124
msgid "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: build/C/man2/inotify_init.2:29
#, no-wrap
msgid "INOTIFY_INIT"
msgstr ""

#. type: TH
#: build/C/man2/inotify_init.2:29
#, no-wrap
msgid "2014-03-28"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:32
msgid "inotify_init, inotify_init1 - initialize an inotify instance"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:35
#, no-wrap
msgid "B<#include E<lt>sys/inotify.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:38
#, no-wrap
msgid ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:42
msgid "For an overview of the inotify API, see B<inotify>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:46
msgid ""
"B<inotify_init>()  initializes a new inotify instance and returns a file "
"descriptor associated with a new inotify event queue."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:56
msgid ""
"If I<flags> is 0, then B<inotify_init1>()  is the same as "
"B<inotify_init>().  The following values can be bitwise ORed in I<flags> to "
"obtain different behavior:"
msgstr ""

#. type: TP
#: build/C/man2/inotify_init.2:56
#, no-wrap
msgid "B<IN_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:64
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr ""

#. type: TP
#: build/C/man2/inotify_init.2:64
#, no-wrap
msgid "B<IN_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:74
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:79
msgid ""
"On success, these system calls return a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:85
msgid "(B<inotify_init1>())  An invalid value was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:88
msgid "The user limit on the total number of inotify instances has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:91
msgid "The system limit on the total number of file descriptors has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:94
msgid "Insufficient kernel memory is available."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:101
msgid ""
"B<inotify_init>()  first appeared in Linux 2.6.13; library support was added "
"to glibc in version 2.4.  B<inotify_init1>()  was added in Linux 2.6.27; "
"library support was added to glibc in version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:103
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:107
msgid "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr ""

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "INOTIFY_RM_WATCH"
msgstr ""

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "2010-10-15"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:30
msgid "inotify_rm_watch - remove an existing watch from an inotify instance"
msgstr ""

#.  Before glibc 2.10, the second argument was types as uint32_t.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:36
msgid "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:42
msgid ""
"B<inotify_rm_watch>()  removes the watch associated with the watch "
"descriptor I<wd> from the inotify instance associated with the file "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:48
msgid ""
"Removing a watch causes an B<IN_IGNORED> event to be generated for this "
"watch descriptor.  (See B<inotify>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:55
msgid ""
"On success, B<inotify_rm_watch>()  returns zero.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:60
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:67
msgid ""
"The watch descriptor I<wd> is not valid; or I<fd> is not an inotify file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:75
msgid "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"
msgstr ""

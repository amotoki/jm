#! /usr/bin/perl
#
# パッケージ原文が更新されたときに、
# translation_list を更新するために upd_tl.perl に与える
# 設定ファイルを作成するスクリプト
#
# original/ ディレクトリ以下にファイルを揃え、
# 変更/追加/削除されたファイルを git add で stage した上で
# git commit を実行する前に、original/ の一つ上のディレクトリで
# git status した結果を標準入力から与えてください。
# 結果は標準出力に出力するので、適当にリダイレクトして下さい。
#
# 結果にはささいな変更も含まれますので、実際にはそれらに
# 手動で対応した後、結果の該当部分を手動で削除してから
# upd_tl.perl を使うことになると思います。
#
# BUG:
# ゴミを出力することがあります。手動で削除してください。
#

sub cvfn()
{
	my($fn) = @_;
	if($fn =~ m@man./([-.\w]+)\.(\d)$@){
		return "$1:$2";
	} else {
		return '';
	}
}

sub getdate()
{
	my($fn) = @_;
	my($input,$date);
	open F, "<$fn";
	while ($input = <F>) {
		if ($input =~ /^\.TH [^ ]+ +[1-8] +\"?([0-9]+)\-([0-9]+)\-([0-9]+)\"? /) {
			$date = $1 . "/" . $2 . "/" . $3;
		}
	}
	close F;
	if ($date) {
		return $date;
	} else {
		return "0000/00/00";
	}
}

$state = "start";

while(<>){
	s/[\r\n]*$//;
	$state = "staged" if /^# Changes to be committed/;
	if(/^#$/){
		$state = ($state eq "staged") ? "target" : "done";
	}
	next if $state ne "target";

	s/^#[ \t]*//;
	#print "$_\n";
	my($mode, $fn) = split(/: +/);
	if($mode eq 'new file'){
		open F, "<$fn";
		$top = <F>;
		close F;
		if($top =~ /^.so ([-\w]+)/i){
			print 'L ' . &cvfn($fn) . ' ' . &cvfn($top) . "\n";
		} else {
			print 'A ' . &cvfn($fn) . " " . &getdate($fn) . "\n";
		}
	}
	if($mode eq 'modified'){
		open F, "<$fn";
		$top = <F>;
		close F;
		if($top =~ /^.so ([-\w]+)/i){
			print 'L ' . &cvfn($fn) . ' ' . &cvfn($top) . "\n";
		} else {
			print 'U ' . &cvfn($fn) . " " . &getdate($fn) . "\n";
		}
	}
	if($mode eq 'deleted'){
		print 'R ' . &cvfn($fn) . "\n";
	}
	if($mode eq 'renamed'){
		my ($fn_old, $fn_new) = split(' -> ', $fn);
		open F, "<$fn_new";
		$top = <F>;
		close F;
		if($top =~ /^.so ([-\w]+)/i){
			print 'L ' . &cvfn($fn_new) . ' ' . &cvfn($top) . "\n";
		} else {
			print 'A ' . &cvfn($fn_new) . " " . &getdate($fn_new) . "\n";
		}
		print 'R ' . &cvfn($fn_old) . "\n";
	}
}

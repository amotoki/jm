=head1 NAME

Zebedee --- シンプルでフリーでセキュアなトンネルプログラム

=begin License

Zebedee Manual

For license terms, see the "CREDITS AND LEGALITIES"
 at the bottom of this document.

Japanese Version Copyright (c) 2000 NAKAJIMA Taku
         all rights reserved.

Translated Thu Jul 13 10:29:22 JST 2000
  by NAKAJIMA Taku <tnaka@brain-tokyo.com>

=end License


=head1 書式

=over 4

=item Server:

B<zebedee> B<-s> [B<-dDtu>] [B<-f> I<file>] [B<-k> I<keybits>] [B<-n> I<name>]
[B<-o> I<logfile>] [B<-r> I<ports>] [B<-v> I<level>] [B<-x> I<config>]
[B<-z> I<level>] [I<targethost>]

=item Client:

B<zebedee> [B<-dDmtu>] [B<-e> I<command>] [B<-f> I<file>] [B<-k> I<keybits>]
[B<-n> I<name>] [B<-o> I<log>] [B<-v> I<level>] [B<-x> I<config>]
[B<-z> I<level>] [[I<clientports>:]I<serverhost>[:I<targetport>]]

=item Key generation:

B<zebedee> B<-p> [B<-f> I<file>]

B<zebedee> B<-P> [B<-p>] [B<-f> I<file>]

=item Hash generation:

B<zebedee> B<-h> [I<file ...>]

B<zebedee> B<-H> I<string> ...

=item Windows Service:

B<zebedee> [B<-n> I<name>] B<-S> [install[=I<file>] | remove | run]

=back

=head1 DESCRIPTION


B<Zebedee>は2つのシステム間で、
暗号化され、圧縮されたTCP/IPまたはUDPの"トンネル"を確立する単純なプログラムである。 
これは、低帯域のネットワーク上でのパフォーマンスを圧縮により向上するだけでなく、
B<telnet>, B<ftp> や B<X> などの TCP ベースの
トラフィックを盗聴から防御することも可能にする。
また、暗号化の有無にかかわらずデータ圧縮を使用することで、
遅いネットワークで良好なパフォーマンスを得ることも可能である。


B<Zebedee> の主な目的は:

=over 4

=item *


UNIX と Windows 95/98/NT の双方にてクライアントとサーバーの機能を提供する。

=item *


ほんの少しの設定か全くの設定無しで簡単にインストール、使用、保守ができる。

=item *


少しの付加データと、少ないプロトコルのオーバヘッドにて、
圧縮により多大なトラフィックの低減を行う。

=item *


特許化されていないか、または特許の有効期限が切れているアルゴリズムのみを用いる。

=item *


GNU 一般公有使用許諾書(GPL)のもとで商用、非商用を問わず
完全にフリーに使用・配布ができる (L<CREDITS AND LEGALITIES> を見よ)。

=back


もちろん、B<Zebedee> は初めてのあるいは唯一の利用可能な
セキュアなトンネルプログラムではない。 
高機能という面では B<ssh> や B<SSL> などとは比べ物にもならないが、
もし、素早く、単純で、B<完全にフリー>なものを求め
ているなら、これはピッタリのツールだろう。


この文書は B<Zebedee> リリース 2.0.0 の機能について記している.

=head2 名前の由来は?(What's in a name?)


あなたが疑問を持とうが持つまいが、B<Zebedee> は次の 3つの主要なコンポー
ネントから命名された。

=over 4


=item *

B<Z>lib による圧縮

=item *

B<B>lowfish による暗号化

=item *

B<D>iffie-Hellman による認証

=back

これでわかったよね?

=head2 基本的な使い方(Basic Usage)


ローカルマシンとリモートホストを安全に接続するには、
まずリモートホストの方で、B<Zebedee> をサーバーモードで起動する必要がある。
一番簡単な方法は、B<-s> オプションを使うことだ。

 zebedee -s


うまくいけば(いくはず！)B<Zebedee>は
端末(windowsではコンソールウインドウ)から切り離されてバックグラウンドで走る。
そして、クライアントからの接続を待つ。


次にクライアントマシンでB<Zebedee>をクライアントモードで起動する。
この場合は、リモートホストのホスト名とトンネルすべきサービス名かポート番号
(ここではこれをターゲットポートと呼ぶことにする)を指定する。
例えば、リモートホストの名前がC<remhost>で
安全なB<telnet>セッションを張りたいとしたら、こうなる。

 zebedee remhost:telnet


実際には、ポートのデフォルトがtelnetなので
このケースでは次のように省略してもよい。

 zebedee remhost


このコマンドを実行すると、
トンネルの入口になる(ローカル側の)ポートの番号が表示される。
B<Zebedee>は端末から切り離されてバックグラウンドで走り、
このローカル側のポートに接続されるのを待つ。
例えば、1234と表示されたら、

 telnet localhost 1234

とすれば、C<remhost>に安全なトンネル経由で接続される。


デフォルトでは、B<Zebedee>はプロセスを終了させるまで接続を待ち続けて、
必要があれば同時発生する複数のコネクションを処理する。

時には、B<Zebedee>を起動し、
その後すぐにそのポートに接続するコマンドを起動したいこともあるだろう。
これを一発でやるには次のようにする。

 zebedee -e "telnet localhost %d" remhost


文字列中の"C<%d>"がローカルポート番号と置き換えられる。従って、
B<Zebedee>はポート番号を表示しない(する必要がない)。
このようにコマンドを指定した場合には、そのコマンドが接続を終了すると同時に、
ローカル側のB<Zebedee>クライアントも終了する。


クライアントが使用するローカルポート番号を指定したい(する必要がある)こともあるだろう。
(保護したい通信を行なう)コマンドが、特定のポートに接続しようとする場合だ。
この場合は、B<Zebedee>を次のように起動することで、
ローカルポートを指定することもできる。

 zebedee clientport:hostname:targetport


例えば、次のコマンド:

 zebedee 8000:webhost:80


は、クライアントの8000番ポート経由で接続する、
B<webhost>への全てのHTTP接続を保護する。
詳細はL<EXAMPLES>参照のこと。

また、B<Zebedee> クライアントは 
同一ホスト内の複数のターゲットポートに対して、
複数のトンネルを(同時並行的に)扱うこともできる。
この場合は、ローカルとリモートのポートの指定はポート番号のリストになる。
例えば

 zebedee 9001,9002,9003:somehost:daytime,telnet,ftp


これは、9001番のクライアントポートへの通信を、
リモートのターゲットシステムのB<daytime>ポートへとトンネルする。
同様に、9002番はB<telnet>ポートへ、9003番はB<ftp>ポートへトンネルする。

詳細は
B<L<clientport|/item_clientport>>と
B<L<targetport|/item_targetport>>を参照のこと。

=head2 UDPトンネリング(UDP Tunnelling)


B<Zebedee>はもともとは TCP/IP のトラフィックだけを扱うように設計されたが、
バージョン2.0.0からはコネクションレスのUDPのデータも扱えるようになった。
この機能を有効にするにはB<Zebedee>を B<-u> オプション付きで起動する
(または、B<L<udpmode|/item_udpmode>> キーワードを使用する)。
例えばサーバ側で

 zebedee -s -u


クライアント側で

 zebedee -u 10000:somehost:echo


を実行する。なお、ひとつのクライアントとサーバは、TCPかUDPのどちらかを扱い、
両方同時に扱うことはできない。両方のタイプをトンネルするには、
2つの独立したインスタンスを起動する。
TCPモードとUDPモードのサーバは違うポートを使うので、
両者を同じシステムで起動することは安全である。


UDPモードでもB<Zebedee>のクライアントとサーバ間のトンネルはTCP/IPで接続する。
この接続は無通信が一定時間続くとタイムアウトする。
タイムアウトしてからさらにデータが来るとトンネルの再接続を行う必要があるので、
アプリケーションの特性によっては
UDPモードのパフォーマンスがよくないように見えることもある。
また、扱えるUDPダイアグラムのサイズにも制限があることにも注意すること。


詳細は、B<L<maxbufsize|/item_maxbufsize>>、
B<L<udpmode|/item_udpmode>>、 B<L<udptimeout|/item_udptimeout>>
を参照のこと。

=head2 言葉の定義(Some Terminology)


通常は、B<Zebedee>を使用する場合、関係するシステムは2つである。
片方でクライアントを起動して、ローカルポートでそれと通信する。
反対側ではサーバを起動して、そのシステムで動作しているサービスと会話する。
しかしながら、次のように最大4つのシステム(マシン)が関係するケースもありえる。


 [ソース] <===> [クライアント] <=====> [サーバ] <===> [ターゲット]
            |                     |               |
            +- 安全でない         |               + 安全でない
               接続               |                 接続
                                  +- 安全なトンネル


B<Zebedee>のクライアントは「クライアント」システムで、
サーバは「サーバ」システムでそれぞれ動作している。
トンネル設定の契機となる最初の接続は「ソース」マシンから発生する。
「ソース」と「クライアント」は違うシステムであってもかまわないが、
通常は同一のシステムである。
サーバは最後に「ターゲット」システムと通信する。
ターゲットも普通はソースと同じマシンになるが、違うマシンであっても全く問題はない。


ほとんどの場合、「ソース」と「クライアント」、
「サーバ」と「ターゲット」の違いを気にする必要はない。
しかし、この用語の区別が以下に述べるキーワードに多く反映している。
キーワードの説明を読む時には、このことを頭に入れておいたほうがいいだろう。


B<Zebedee>のトンネルに関係するこの4つシステムの問題と別に、
安全に接続するために、いくつかの全く違うタイプの「キー(key)」が使われる。
クライアントとサーバはB<private key>(秘密鍵)という値を必要とする
(自分で生成する場合もある)。
このキーからは、public values が計算され交換され、
それによりB<shared secret key> が導き出される
(この時にDiffie-Hellman key agreement mechanism が使用される)。
このキーからは、接続のたびにユニークなB<session key>が導き出され、
最終的にこのキーで暗号化が行なわれる。

=head2 設定ファイル(Configuration File)


B<Zebedee> の動作をコントロールするには、
設定ファイルを使うのがおそらく一番よい。設定ファイルを指定するには
コマンドラインオプションで B<-f>を使う。ファイルは(B<-f>)オプションの位
置で処理される。従って、それ以降のコマンドラインオプションでファイルの内
容を上書きすることができる。


行の形式は以下のとおり。

 key value # optional comment


I<key>はひとつの単語であり大文字小文字は無視される。I<value>は単語か文字
列かどちらかである。
文字列はダブルクォート(C<"こんな風に">)かシングルクォート
(C<'こんな風に'>)でくくられる。ダブルクォート " の中に
シングルクォート ' があってもよいし(C<"here's an example">)、その逆も言える。
value では大文字小文字の違いは区別される。


空白行と"C<#>"ではじまる行(その前に空白があっても同じ)は無視される。
長い文字列は "C<\>"で次の行に継続することもできる。
この文字は除去され、次の行がこの行に接続される。
1行の長さは継続行も含め 1024 文字に制限されていることに注意。
行の接続はコメントの認識を含めすべての処理に先だって行われる。
そのため以下の例

 server false
 # This comment continues on the next line \
 server true


では、B<server>の値は B<false>になる。


キーワードとその意味は以下に述べる。
ほとんどのキーワードは対応するコマンドラインオプションがあるが、
なかには対応するオプションがないものもある。
対応するコマンドラインオプションがあるものについてはそれも併記してある。
逆に、コマンドラインオプションの中には
設定ファイル内のキーワードに対応するものがないものもある。
それらはこのセクションの最後に述べる。


キーワードが真偽値(boolean)と書かれていたら、
その値は"B<true>" または "B<false>"でなければならない。


キーワードの中にはポートのリストを指定するものがある。
この場合は、ポート名(サービス名)、ポート番号、番号の範囲を
コンマか空白で区切ったものを指定する。
例えば、"C<telnet, ftp 5900-5903>"は 
"C<23,21,5900,5901,5902,5903>"と等しい。


また、クライアントだけに指定するキーワードもあるし、
サーバだけに指定するキーワードもある。
ひとつの B<Zebedee> プログラムはサーバかクライアントかどちらかひとつの機能を実行し、
その時の用途と違う用途向けのオプションは無視する。
エラーメッセージも表示しない。
サーバになるかクライアントになるかは、
B<L<server|/item_server>> キーワードで決まる。

=over 4

=item B<server> (コマンドラインでは B<-s>)


これは、クライアントになるかサーバになるかを決める真偽値のキーワードである。
これが指定されなかった場合は、クライアントとして動作する。
コマンドラインオプションの B<-s> オプションはこの値をB<true>にするのと等しい。

=back

=head3 クライアント専用キーワード(Client-Only Keywords)


以下のキーワードはクライアントだけに適用される。

=over 4

=item B<command> (コマンドラインでは B<-e>)


クライアントとして動作している時に意味を持つ。
これは、トンネルへ接続した後に起動されるコマンドを示す。
この値が "C<%d>" という文字列を含んでいたら、実行時にローカルポート番号と置き変えられる
(B<L<clientport|/item_clientport>> 参照)。
この処理はB<sprintf>関数を使用して行なうので、
"C<%>"によるエスケープ処理が適用される
(すなわち、"C<%>" を 1 文字生成するためには "C<%%>" を使う)。
さらに、"C<%d>" を二つ以上指定したり "C<%d>" 以外のフォーマット指定子
を指定すると、おそらくプログラムはクラッシュするだろう。


コマンドが接続を閉じたら、B<Zebedee>も終了する。
このキーワードおよびオプションを使用すると、暗黙のうちにマルチユースモードがOFFになる
(B<L<multiuse|/item_multiuse>>参照)。
B<Zebedee> クライアントが複数の接続を扱う場合
(B<L<multiuse|/item_multiuse>>)やポートのリストが 
B<L<clientport|/item_clientport>>で指定された場合は、コマンドの自動起動は
使用することができない。

=item B<clientport>


これはB<Zebedee> クライアントがローカル接続のためにlistenすべき、
ひとつのポート番号かポート番号のリストである。


もしクライアントがトンネルするのが単独のリモートポートならば、
これは省略できる。
その場合はポートは自動的に割り当てられて、
端末にポート番号を示すメッセージが表示される。


ポート番号のリストを指定する時は、リモートポートがコマンドラインで指定されたのであれ、
B<L<targetport|/item_targetport>> キーワードで指定されたのであれ、
ポートの数は正確にリモートポートの数と一致しなければならない。


2.0.0より前のバージョンでは、同じ意味でB<localport>というキーワードが使用されていた。
後方互換性のために、このキーワードは現バージョンでも認識される。

=item B<localsource>


この値がB<true>だと、クライアントはローカルマシンで発生した接続だけを受けつける。
別の言葉で言うと、「ソース」と「クライアント」が同一のシステムである必要がある。


この値はデフォルトはB<false>であり、どのマシンがソースとなっても接続を受けつける。

=item B<multiuse> (コマンドラインでは B<-m>)


この値がB<true>だと(デフォルトではそうなっているが)、
B<Zebedee>のクライアントは複数の接続要求(同時並行的に発生してもよい)を扱い、
要求ひとつひとつに対して、新しいトンネルを設置する。
値がB<false>だと、クライアントはシングルユースモードで動作し、
最初の接続が閉じられた直後に終了する。


コマンドラインのB<-m>オプションはこれをB<true>に設定するのと等しい。
現在のバージョンのB<Zebedee>はこれがデフォルトだが
(だから、このオプションを設定する必要はないが)、
後方互換性のために残されている。


クライアントが複数のポートを待ち受ける場合は、
たとえこれがB<false>に設定されていても、
自動的に マルチユースモードになる。
(B<L<clientport|/item_clientport>> 参照)

=item B<serverhost>


これはトンネルを接続すべきリモートホストの名前である。
ホストの名称にはデフォルトはないので、
設定ファイルかコマンドラインのどちらかで、
必ずこれを指定しなければならない。


2.0.0より前のバージョンでは、同じ意味でB<remotehost>というキーワードが使用されていた。
後方互換性のために、このキーワードは現バージョンでも認識される。

=item B<targetport>


ここに指定したポート番号(リストも可)でターゲットホストに接続するように、
B<Zebedee>クライアントがB<Zebedee>サーバに要求する。
これが指定されない時のデフォルトは"B<telnet>" (ポート番号 23)である。


ポート番号のリストを指定する時は、
ローカルポートがコマンドラインで指定されたのであれ、
B<L<clientport|/item_clientport>> キーワードで指定されたのであれ、
ポートの数は正確にローカルポートの数と一致しなければならない。


2.0.0より前のバージョンでは、同じ意味でB<remoteport>というキーワードが使用されていた。
後方互換性のために、このキーワードは現バージョンでも認識される。

=back

=head3 サーバ専用キーワード(Server-Only Keywords)


以下のキーワードはサーバとして動作する時に適用する。

=over 4

=item B<redirect> (コマンドラインでは B<-r>)


このキーワードはサーバがリダイレクトするポートのリストである。
(例 "C<telnet,ftp, 5900-5910>")
もし B<redirect> キーワードが指定されない場合は、
どのポートへのトンネル接続要求も受け付けられる。
この方法(B<redirect>を指定しないこと)はテスト中には便利だが、
セキュリティー面でのリスクがあるので、
もし可能ならば(このキーワードで)明示的に許可するポートを指定すべきである。


このキーワード(またはB<-r>オプション)は複数指定されてもよい。この場合は、
そのうちどれかのポートに指定されていればリダイレクトが許可される。

=item B<targethost>


デフォルトではB<Zebedee> サーバは
全てのトンネルをローカルマシンのポートにリダイレクトする。
もし、このキーワードが指定されると、
全ての接続はその名称のホストへとリダイレクトされる。
トンネルを安全なネットワークの中にまで延長するのは無駄であるが、
この機能を使用すると、そのオーバーヘッドを省くことができて便利である。
また B<ftp> のトラフィックをトンネルする時にも使える。
(詳細はL<EXAMPLES>参照)


B<Zebedee>がサーバモードで動作する時は、
通信をリダイレクトすべきホストの名称は、
コマンドラインの最後の付加的なパラメータとして指定することもできる。


2.0.0より前のバージョンでは、同じ意味でB<redirecthost>というキーワードが使用されていた。
後方互換性のために、このキーワードは現バージョンでも認識される。

=back

=head3 圧縮と暗号化関連のキーワード(Compression and Encryption Keywords)


以下のキーワードは、トンネル内を流れるデータの圧縮と暗号化を制御する。
これらは、クライアントとサーバどちらでも使用される。

=over 4

=item B<compression> (コマンドラインでは B<-z>)


B<Zebedee> は圧縮方式として B<zlib> をサポートする。
そして、もしコンパイル時に有効になっていればB<bzip2>もサポートする。
このキーワードで圧縮の方式と圧縮レベルを指定する。
この値の形式は I<type:level> である。I<type> は 
"C<zlib>" と "C<bzip2>"のどちらか、I<level> は0から9の整数である。
プレフィックスなしで整数だけの場合は、B<zlib>が選択される。


I<level> は使用可能な最大の圧縮レベルを設定する
(9が最大で0が圧縮なし)。
実際に使用される圧縮レベルは、クライアントの値とサーバの値の最小値である。
この目的では、(0以外の)B<bzip2>レベルはいかなるB<zlib>レベルの値より上であるとみなされる。
従って、サーバとクライアントのいずれかがB<bzip2>レベルをサポートしていなければ、
プロトコルはB<zlib>を選択する。
デフォルトの圧縮レベルは"C<zlib:6>"である。


B<bzip2>圧縮の動作方式とバッファーサイズのために、
B<bzip2>は連続的なデータのストリームが流れる場合にだけ使う意味がある。
通常のB<telnet>セッションのような、小さな転送ではB<zlib>の方が性能がよい。
どちらがあなたにとってよく働くかは、実験してみないとわからないだろう。
加えて、バッファーサイズが小さいので、B<bzip2>の1より上からは得るものがない。
B<Zebedee>はこれより上の値はこの値に変更する。


verbosity levelを2以上にすれば、
接続が終了した時に基本的な統計値がプリントアウトされるので、
どれだけ圧縮が有効だったか正確に知ることができる。
例えば、

 zebedee(232/210):   read 166 bytes (265 expanded) in 3 messages
 zebedee(232/210):   wrote 20969 bytes (30499 expanded) in 247 messages

=item B<generator>


これは、Diffie-Hellmanキー交換の"generator"で、16進数の文字列で指定する。
デフォルトは"2"である。
なんのことかわからなければ、
下手にいじらない方がいいだろう。

=item B<keygencommand>


このキーワードが指定されると、
この値(コマンド文字列)が秘密鍵を生成するために使用される。
そのコマンドは標準出力に1行の16進数を出力しなくてはならない。
この行は少くとも10桁の16進数であること。

=item B<keygenlevel>


これは0と2の間の整数で、B<Zebedee>で使用する秘密鍵生成の強度を決定する。
デフォルトは2(最強)である。接続時のパフォーマンスが耐えがたい場合以外には、
一般的にはこれを変更しないほうがよい。


簡単に言って、UNXI系のシステムではレベル2のキー生成のメカニズムは、
可能であれば C</dev/random> を使用する。
しかしながら、あまりにも多くの要求を連続的にこのデバイスに対して行うと、
カーネルが必要な"エントロピー"をかき集める間、
プロセスがブロックされる可能性がある(それが数秒になることもある)。
C</dev/random>が使用できない場合や
レベルが1にセットされた場合は、
C</proc>ファイルシステムの現在の内容が(もしあれば)使用される。
レベル0では現在のプロセスにある情報だけが使用される。


Windows上のシステムでは、現在のところ、
キー生成強度のレベルごとの違いはなく、
このキーワードは実際には無視される。

=item B<keylength> (コマンドラインでは B<-k>)


これは、Blowfish暗号化のキーのビット長の最大値の整数である。
この値は4から576の間の4の倍数でなければならない。
使用されるキー長はクライアントの値とサーバの値の最小値になる。
(B<L<minkeylength|/item_minkeylength>>参照)

デフォルトは128である。
特別なケースとして、この値が0に設定されると、
キーのネゴシエーションと暗号化は無効にされる。

=item B<keylifetime>


このパラメータの値が0以外に設定されると、これ以降の接続において、
クライアントはセッションキーの導出のために、以前設定されたshared secret keyを
再利用するように要求する。
つまりB<Zebedee>のクライアントとサーバは、
最初の接続においてのみキー交換の対話を全て行なう。
それ以降の接続では、キーの有効期限が切れるまでは、同じsecret keyが再利用され、
このキーからsession keyが導出される。
キーの有効期限が切れると、自動的に新しいキーの交換が行なわれる。


そして、このキーワードが、shared secret keyが有効な期間を指定する。
これは、既に接続された接続には影響しないで、新しい接続だけに影響する。


このキーワードの値の単位は秒であり、65535(約18時間)以下でなければならない。
デフォルトは3600秒(1時間)である。
このキーワードの値を0に設定すると、キーの再利用は行なわれなくなり、
接続の度に、完全なshared keyの交換手続きが行なわれる。
つまり、クライアントもサーバも毎回秘密鍵を新しく生成するとみなす。
ただし、この方法はパフォーマンスに多大な影響があるので、
偏執狂的に高度な安全性を必要とする場合以外には勧められない。

=item B<minkeylength>


これは、クライアントまたはサーバで許容される最小のキー長を指定する。
クライアントがサーバのレベルより小さい値を要求すると、
サーバはここで指定した最小値を返答する。
サーバがクライアントの最小値より下のレベルを返答すると、
クライアントは接続を終了する。

デフォルトは0である。

=item B<modulus>


このキーワードの値は、Diffie-Hellmanキー交換の剰余値を表す16進数の文字列である。
これが何かわかる人で数学オタクの人以外はいじっちゃだめ。


デフォルトの値は下記の1024ビットの素数である。

 f488fd584e49dbcd 20b49de49107366b 336c380d451d0f7c 88b31c7c5b2d8ef6
 f3c923c043f0a55b 188d8ebb558cb85d 38d334fd7c175743 a31d186cde33212c
 b52aff3ce1b12940 18118d7c84a70a72 d686c40319c80729 7aca950cd9969fab
 d00a509b0246d308 3d66a45d419f9c7c bd894b221926baab a25ec355e92f78c7


これは Peter Gutman の B<CryptLib> の中の F<testdh.h> というファイルから
とられた。
そこには、この値が "generated by Colin Plumb for SKIP"だとコメントがある。
それから "these values were chosen as representative
well-known public values to allay fears of possible trapdoors in
self-generated values.  The generation method and actual values can be
checked against the SKIP standards document." だとさ。

=item B<privatekey>


デフォルトでは、B<Zebedee>はセッションごとに新しい秘密鍵を生成する。
しかし、もしあなたが毎回同じキーを使いたい場合は、
16進数の文字列としてこれを指定すればいい。
もし公開鍵暗号による認証(L<identitychecking|Identity Checking>)を使用したい場合は、
必ずこれを設定しなくてはいけない。
キーが少くとも10桁は必要なことに注意すること。

=back

=head3 様々なキーワード(Miscellaneous Keywords)


以下のキーワードはクライアントにもサーバにも等しく適用される。

=over 4

=item B<checkidfile>


これは、接続を許可する前にチェックするアイデンティティを複数記述したファイルの名称である。
これについてはL<identity checking|Identity Checking>で詳しく述べる。
このファイルはひとつしか指定できない。もし複数出現したら、
最後の値が使用される。

もし、B<L<keylength|/item_keylength>>が0であることに
(クライアントとサーバが)同意した場合は、アイデンティティのチェックは行なわれない。

=item B<debug> (コマンドラインでは B<-D>)


これはB<Zebedee>が "debug" モードで動作するかを指定する真偽値である。
"debug" モードではサーバは
(B<L<multiuse|/item_multiuse>>モードのクライアント)は
一度に一つの接続しか受け付けない。
そして、別プロセスや別スレッドを生成することなく "inline" で動作する。
これはデバッガ上でプログラムを動かす時に便利である。
デフォルトはfalseである。コマンドラインオプションの B<-D> は
これを B<true> に設定するのと同じである。


注：この設定は、UDPモードでは正しく動作しないので、試さないほうがいい。

=item B<detached> (コマンドラインでは B<-d>)


これはプロセスが制御端末から自分自身を切離してバックグラウントで
(UNIX用語ではデーモンとして)動作するかどうか指定する真偽値である。
これはクライアントでもサーバでも有効であり、
デフォルトは B<true> である。コマンドラインオプションのB<-d>は
これを B<false> に設定するのと同じである。


注：Windowsのコマンドプロンプトではこれがうまく動作しないこともあるようだ。
その徴候は、コンソールウインドウへの出力が止まり割込みのsignalが無視されるが、
コンソールのプロンプトがB<Zebedee>が終了するまで表示されないことだ。
これを回避するには、以下のように "start" コマンドを使用すればよい。

 DOS> start zebedee -f server.zbd


これはB<Zebedee>を新しいコンソールセッションで起動し、そこから切り離す。
切り離す前に一瞬だけチラリとそのコンソールが見えるが、それが消えても
B<Zebedee>はバックグラウンドで動作している。

=item B<include>


これは別の設定ファイルの名前を指定する。
そのファイルはこのファイルの残りを処理する前、
この時点で処理される。
例えば、秘密鍵をもっときっちりガードしたファイルに分離して保存した場合に、
そのファイルを取り込むために使用される。
includeは5レベルの深さまでに限定される(最初のファイルをレベル1として)。
これはうっかり無限ループを作らないためである。

=item B<maxbufsize>


これは、
B<Zebedee> がアプリケーションからデータを読むために使用するバッファの長さ(バイト単位)を指定する。
実際に使用されるバッファの長さはサーバの値とクライアントの値の最小値になる。


デフォルトでは、B<Zebedee>はトンネルの両端で
サーバプログラム、クライアントプログラムから8192バイト単位で読み出す。
例えば、すごく対話的なアプリケーションがあって、
大きなデータ転送を待つためにひどいレスポンスだったりした時など、
これを小さくしたいこともあるだろう。
バッファサイズは1バイトまで縮めることができるが、
おかしな動きをデバッグしようとしているのか時間を無駄にしたいのでなければ、
これはお勧めできない。
逆に、大量のデータの転送があって、
圧縮をめいっぱい効かせたい場合は、16383バイトまで大きくしてもよい。
注：B<maxbufsize> は B<Zebedee> が使用するメモリ量には関係ない。
一度に読みこむデータのかたまりのサイズだけに影響する。


UDPモードでは、バッファサイズは扱えるデータグラムの最大長にも影響する。
現在のバッファサイズより大きなデータグラムは分断され、
それを受信するアプリケーションが落ちることになりがちだ。
16383バイト以上のデータグラムは扱うことができない。

=item B<message>


verbosity level が1ならば、設定ファイルのこの部分を処理した時に、
このメッセージがログに記録される。

=item B<name> (コマンドラインでは B<-n>)


これは、実行ファイルのファイル名の代わりに、
メッセージの中で使われるプログラム名称になる。
Windows環境では、インストールあるいは削除されるサービスの名前としても用いられる。

=item B<logfile> (command-line B<-o>)


これはメッセージが出力されるファイルの名前である。
もし省略されるとメッセージは標準エラーに出力される。


2つの特殊なファイル名も正しい名前として認識される。
もし、名称がB<NULL>だと、全てのメッセージ出力は止められる。
B<SYSLOG>だと、メッセージはホストのシステムログに出力される。
Windowsシステムでは、アプリケーションイベントログを意味する。
他のシステムでは、メッセージはB<syslog> サービスに出力される。

=item B<serverport>


これは、B<Zebedee> サーバが接続を待ち受けるポートである。
デフォルトはTCPモードでは11965 (0x2EBD)、UDPモードでは11230(0x2BDE)である。
サーバでこれを指定すると、サーバはこのポートでlistenする。
クライアントでこれを指定すると、クライアントは
サーバのこの番号のポートに接続することになる。

=item B<timestamplog> (コマンドラインでは B<-t>)


これは、ログメッセージにタイムスタンプを含めるかどうかを示す真偽値である。
コマンドラインオプションの B<-t> はこれをB<true>に設定するのと同じである。

=item B<udpmode> (コマンドラインでは B<-u>)


デフォルトではB<Zebedee>は、コネクションベースのTCP/IPの通信を扱う。
もし、このキーワードが指定されると、かわりにコネクションレスのUDP/IPの通信を扱う。


この場合でも、B<Zebedee>のクライアントとサーバ間のトンネルはTCP/IP接続を使用する。
UDPの宛先ごとに別々の接続が使用される。
UDPはコネクションレスなので、通信が完了したことを簡単に知ることはできない。
この理由で、B<Zebedee>の接続は一定の時間通信が無い場合にタイムアウトする必要がある。
この時間はB<L<udptimeout|/item_udptimeout>>の値で制御される。


すでにタイムアウトしてしまったトンネルに向けたデータが到着した場合、
接続を再確立する必要がある。
このために、アプリケーションの特性によっては、
UDPモードのパフォーマンスがよくないように見えることもある。
B<L<keylifetime|/item_keylifetime>>の値を変更して、
接続のセットアップの時間を最小にすれば、パフォーマンスを向上させることができる。
B<L<udptimeout|/item_udptimeout>> の値を変更することも同様に役に立つ。


コマンドラインオプションのB<-u>は、この値をB<true>に設定するのと同じである。

=item B<udptimeout>


デフォルトでは、UDPモードのトンネルは、300秒通信が無いと閉じられる。
このキーワードでその時間を変更できる(単位は秒)。
この値は65535より大きくなってはいけない。
これを0にすると一切通信が行なわれない(そういう設定もできるけど…)。

=item B<verbosity> (コマンドラインでは B<-v>)


これは、ログするメッセージのレベルを示す整数値である。
0だとエラーメッセージだけ、
5にするとメッセージトラフィックの非常に細かいディテールまで含める。
デフォルトは1であり、通常はそれが最も使いやすい。


メッセージは F<stderr> に出力される(コマンドラインオプションのB<-o>か
B<L<logfile|/item_logfile>> キーワードでリダイレクトされない限り)
一般的なメッセージはこんな感じである:

 zebedee(54/119):  Listening on local port 1172


カッコの中の数字はメッセージを出力したプロセスとスレッドのIDを表している。
全てのエラーメッセージはレベル0でもログが取られ、
以下の様に、先頭が C<ERROR> という単語から始まる。

 zebedee(54/119): ERROR: failed to connect to localhost:11965


メッセージはログが取られたレベルに従ってインデントされる。

=back

=head3 その他のオプション(Other Options)


設定ファイルに対応するものを持たないコマンドオプション
がいくつかあるので、それについてここで説明する。

=over 4

=item -p


このオプションで B<Zebedee> は秘密鍵の値を標準出力に出力する。
この出力は設定ファイルでそのまま使用できる形式である。
例えば、


 privatekey "c480bd48f707c69dec54c9e7b6e22dd04cac659e"

の様な形である。

=item -P


このオプションで B<Zebedee> はL<identity checking|Identity Checking> で
使用できるパブリックアイデンティティを生成する。結果は標準出力に書かれる。
例えば、

 ef8153a0e392df005f67321ca2f0ace5bb8c5a1f myhostname

の様な形である。


このオプションは秘密鍵を含む設定と共に指定するか、
B<-p> と共に用いて秘密鍵と公開鍵を両方同時に生成しなくてはいけない。

=item -h


このオプションは以降の引数をファイル名とみなす。
そして、それぞれのファイルは8192バイトのかたまりとして読みこまれ、
SHAハッシュが計算される。
引数がない場合や引数が"C<->"であった場合は標準入力のハッシュが計算される。
例えば、

 $ zebedee -h /etc/passwd
 bb1e734aeffd2111417761f5938dea3b53759598 /etc/passwd
 $ zebedee -h < /etc/passwd
 bb1e734aeffd2111417761f5938dea3b53759598 -

の様な形である。

=item -H


こちらはB<-h>と似ているが、引数が文字列として扱われ、
その文字列のSHAハッシュが計算され表示される。

 $ zebedee -H hello world
 ac62a630ca850b4ea07eda664eaecf9480843152 hello
 86bf25ecb8a40b40b885c097c683b6e236fc8085 world

=item -S (Windows only)


Windowsシステムでは B<Zebedee> を
サービス(ブート時に自動的に起動され独立して動くプロセス)として
インストールすることもできる。

B<Zebedee>はB<install>パラメータと設定ファイルの名前を指定することで
サービスとしてインストールされる。例えば、

 zebedee -Sinstall=c:\zebedee\service.zbd

の様な形である。


常に、設定ファイルのフルパスを指定しなければならない。
このファイルはスタートアップ時に読みこまれ、
サービスが動作するために必要なパラメータを全て含んでいなければならない。


デフォルトでは、
インストールされるサービスの名前はプログラムファイルの名前から取られる。
従って通常はB<Zebedee>になる。
しかし、B<-n>オプションを使用して変更することもできる。

 zebedee -n "Zebedee Client Service" -Sinstall=c:\zebedee\clientsvc.zbd


一旦、サービスがインストールされると、次のシステム再起動から自動的に起動される。
もしくは(Windows NTの場合)サービスコントロールパネルで手動起動することもできる。



サービスを削除するにはまずサービスを終了してから、B<-S>オプションと 
B<remove> パラメータを使う。
そして、もし必要ならばB<-n>オプションでサービスの名称を指定する。
例えば、

 zebedee -n "Zebedee Client Service" -Sremove

の様な形である。


B<-S>のパラメータは他に B<run> がある。これは内部で B<Zebedee> の
サービススタートアップコードを起動するために使うもので、
ユーザが直接使用してはならない。

=item -x


コマンドラインで指定できない設定ファイルのパラメータを
指定するために、このオプションを使用することもできる。
これに文字列の引数をつけると、
それがあたかも設定ファイルの1行であるかのように処理される。
コメントは認識されるが、"\"の継続行は使用できない。
例えば、

 zebedee -x " server true # It's a server!"


というまわりくどいやりかたでも次のコマンド

 zebedee -s

と同じ効果を得ることができる。

=back

=head2 Identity Checking


B<Zebedee> はデフォルトでは、2点間に暗号化チャネルを生成するに過ぎない。
ご承知の通り、データは "on the wire (通信線上)" での盗聴からは守られるが、
あなたが想定している相手に接続されているか否かは保証されない。
これは、"man-in-the-middle (第三者による横取り)" アタックに対しては無防備である。
もし、あなたがデータの圧縮と、盗聴から守ることを第一に心配しているなら、
あなたはこの条件に満足するだろう。
しかし、あなたの通信が第三者に横取りされていないことに対する保証を求めるなら、
B<Zebedee> はそれを行うための便宜を提供する。


もし、同一の素数と原始根と秘密鍵が用いられるなら、それらは 
Diffie-Hellman の鍵交換プロトコルのために、常に同じ公開鍵を生成するだろう。
もし、あなたが(設定ファイルのB<L<privatekey|/item_privatekey>>キーワードにて設定された)
固定された秘密鍵を用いるなら、
B<Zebedee> は素数と原始根と秘密鍵の値の全てをハッシュして "fingerprint (指紋)" を生成することができる。
これは、B<-P> オプションにより行われる。 
例えば、server.key ファイルが次の値

 privatekey "1e34d6769502bae1087c18d2e8c8776e4a17ddaf"

であるとき、


次のコマンド

 $ zebedee -P -f server.key > server.id

を実行すると、


このような出力

 135f04050961d37553731250d5c6f7495f088b32 myhostname

が得られる。


この最初の16進数が "fingerprint (指紋)" である。 
行中の他の文字列は、このアイデンティティの所有者を表すコメントである。
デフォルトでは、これはアイデンティティが生成されたマシンのホスト名である。


設定ファイルにおいて 
B<L<checkidfile|/item_checkidfile>> キーワードが設定された場合、その値は 
"fingerprint (指紋)" 行を記述したファイルのファイル名である。 もし、接続
先のアイデンティティがファイル中のいかなる値とも一致しない場合、
接続は切断される。

=head2 その他のセキュリティ関連の注記(Notes on Other Security Issues)

=over 4

=item Message Integrity


プロトコルのオーバーヘッドを可能な限り小さくするために、
B<Zebedee> は伝送されたデータの正しさに対する確認は何も行っていない。
そのため、アタッカーは途中でデータパケットを改変することができる。
しかし、暗号の使用はデータを任意に変換することを極めて困難にしているのではないか
(例えば、"C<ls -l>"を"C<rm -f>"に書き換えられるかい？) 。
しかし、B<Zebedee> はランダムなデータが送られたことによる影響から
アプリケーションを守ることは行わない。

=item Replay and Insertion Attacks


多くのネットワークシステムにおいて有り得る攻撃の一つは
データのキャプチャリングであり、良く知られた効果を及ぼす
(例えば、管理者の B<telnet> セッションにはある種の"危険な"操作が伴い、
その操作を後に繰り返されたらどうなるか)。
これを行うには、暗号化されたデータストリームを改変する必要は無いが、
サーバに送られた同じネットワークパケットは、同じレスポンスを引き出すだろう。


B<Zebedee> が "anonymous" モードで動作しているとき、
セッション毎に異なる鍵が生成されるため、
このようなアタックが成功する危険は非常に小さい。 
しかし、L<identity checking|Identity Checking>の機能が使われているときには
鍵は固定されているので、再生は実際に可能性がある。 
B<Zebedee>は、一つ一つの接続毎にユニークなセッションキーを生成することで、
この問題に対処している。
この方法では、接続のセットアップの最後に、チャレンジ-レスポンスの交換が行なわれ、
相手側のシステムがshared secret keyを保持しており、
以前に記録されたデータをオウム返ししているわけではないことが、
確認される。


加えて、B<Zebedee> は Blowfish 暗号法を "cipher feedback" モードで用いており、
データのあらゆる部分の複号は、
それ以前の全てのデータパケットの複号が成功しているかどうかに依存する。 
チャレンジ・レスポンスはデータストリームの "salts" を交換するので、
トンネル化されたプロトコルに "known plain-text" アタック(辞書攻撃)を加えるのは
より困難になる。

=item Key Generation


良くない鍵の使用は、最強の暗号化メカニズムをも汚すことができる。 
鍵を生成するとき、B<Zebedee> は可能な限り推測が困難なデータをかき集めて、
それを SHA ハッシュアルゴリズムにより "ステア (かき混ぜる)" する。


Windowsの場合、アタッカーが既にシステムにアクセスしていれば、
取得可能なあらゆるデータは予測することができる。 
しかし既に言及したように、
ほとんどの用途においてこれは許容できるだろう。
興味があるならば、プログラム中のコメントに詳細が説明されているので、
参照されたい。


もし、鍵の生成メカニズムに不満があるなら、
設定ファイル中のB<L<keygencommand|/item_keygencommand>> オプションを用いて、
外部の鍵生成プログラムを呼べば良い。 
組み込まれている性能を改善する提案は大歓迎だ!

=back

=head1 トラブルシューティング(TROUBLESHOOTING)


B<Zebedee> は「箱から出してすぐそのまま」動くべきだが、あなたはトラブル
にあうかもしれない。ほとんどのトラブルは接続の確立時に起こる
(接続さえうまくいけば、データ転送はスムーズにいくことが多い)。
(接続の)セットアップの手順に何が起こっているか簡単に見るにはB<-v>オプションを
使えばよい。B<-d> B<-D> もいっしょに使って、B<Zebedee>を端末から終了でき
るようにして、一度に一つの接続しか処理しないようにしたほうがい
いかもしれない。だから、こんな感じになるだろう。

 zebedee -dD -v 3 -s


ロギングレベルを3に設定することで、
接続のセットアップの主なやりとりを見ることができる。
問題がその後に起きてると確信が持てるならば、
レベルを4か5にすれば、
(接続時だけでなく)実際の通信で何がやりとりされているかも見ることができる。

=head1 EXAMPLES


B<Zebedee> のパッケージには、たくさんのサンプルの設定ファイルが含まれている。
ここでは、それらの使用法と B<Zebedee> を
特定のいくつかのプロトコルで使用する具体的な方法を述べる。

=head2 サーバ設定の例(Example Server Configuration)


B<Zebedee>のパッケージに含まれる F<server.zbd> という設定ファイルがある。
これにはよく使われるほとんどのオプションの設定例がある。

 #
 # Sample Zebedee server configuration file
 #
 # This shows the use of many, but not all, of the configuration file
 # options available for use by a server.
 #
 
 verbosity 2            # Slightly more than basic messages
 
 server true            # Yes, it's a server!
 detached true          # Run detached from terminal
 udpmode false          # Are we operating in UDP mode?
 
 # Uncomment the following line to log messages to a file
 #
 #  logfile './server.log'
 #
 # Or to log to the system logging facility uncomment this:
 #
 #  logfile SYSLOG
 
 # Uncomment the following line if you want to use a fixed private
 # key stored in a static file. The file should contain a line of
 # the form "privatekey hexadecimal-key-string"
 #
 #  include './server.key'
 
 keygenlevel 2          # Generate maximum strength private keys
 
 # To validate the identity of clients uncomment the following
 # line:
 #
 #  checkidfile './clients.id'
 
 # Set up allowed redirection ports.
 # These should be pretty safe -- but it's not a good idea
 # to open up all ports.
 
 redirect "telnet ftp"          # Basic services
 redirect 5900-5999             # VNC traffic
 redirect 6000-6010             # X Window System
 redirect "daytime chargen"     # Ports useful for testing
 
 targethost localhost           # Redirection is to the local machine
 
 compression zlib:9             # Allow maximum zlib compression
 keylength 256                  # Allow keys up to 256 bits
 keylifetime 36000              # Shared keys last 10 hours
 maxbufsize 16383               # Allow maximum possible buffer size


認証の機能をテストするためには、
B<L<checkidfile|/item_checkidfile>>の行をコメントアウトし、
パッケージに含まれるF<client1.key>かF<client2.key>というファイルをクライアント側で使用すればよい。

=head2 VNCの使用例(Use with VNC)


B<Zebedee>を作った理由の一つとして、ダイアルアップでVNCを使うということがある。
VNCは「リモートフレームバッファコンセプト」を使い、
リモートディスプレイを提供するフリーのシステムである。
Windowsのデスクトップを離れた所に表示することもできるし、
"Xvnc"サーバを使って X のデスクトップを
VNCクライアントマシンから操作することもできるし、
Javaを使えるブラウザーの中から操作することもできる。
詳しくはhttp://www.uk.research.att.com/vnc/を参照のこと。


提供されるサーバの設定例であるF<server.zbd> は 5900-5999 ポートを
リダイレクトしてVNCセッションをトンネリングする。
このファイルはUNIXでもWindowsでも使用できるが、
Windowsで使うためには、レジストリの"AllowLoopback"フラグを
セットする必要があるので注意。
以下の断片を(先頭のスペースを取り除いてから)ファイルに保存して 
B<regedit> に読ませれば、そのトリックを実行する。

 REGEDIT4
 
 [HKEY_LOCAL_MACHINE\SOFTWARE\ORL\WinVNC3]
 "AllowLoopback"=dword:00000001
 
 [HKEY_LOCAL_MACHINE\SOFTWARE\ORL\WinVNC3\Default]


この内容は B<Zebedee> パッケージの中の F<vncloopback.reg> にも含まれている。
このレジストリを設定すれば、コマンドラインで与えられたホストにトンネリングされたVNC ビューワを 
F<vncviewer.zbd> で起動することができる。
デフォルトでは、サーバの(WinVNCのデフォルトである)5900ポートにトンネルするが、
コマンドラインで指定して上書きすることもできる。
以下に F<vncviewer.zbd> の内容を示す。

 #
 # Zebedee configuration file to start up a tunnelled VNC session
 #
 # Usage: zebedee -f vncviewer.zbd remote-host[:vnc-port]
 #
 
 verbosity 1         # Basic messages only
 
 server false        # It's a client
 detached true       # Detach from terminal
 
 message "Starting VNC viewer on localhost:99"
 
 # On Windows systems you might use the following:
 
 command '"c:\Program Files\ORL\VNC\vncviewer.exe" localhost:99'
 
 # On UNIX systems you might use the following:
 
 # command 'vncviewer localhost:99'
 
 targetport 5900     # Remote VNC server on port 5900 unless overridden
                     # by a value specified on the command-line

 clientport 5999     # Local connection on 5999 -- i.e. localhost:99
 
 compression 6       # Request normal Zlib compression


以下のようにこのファイルを使用すると、

 zebedee -f vncviewer.zbd somehost:5901


I<somehost>の5901番ポートのVNCサーバにトンネルしたVNCビューワを起動する。
ビューワはローカルホストの5999番ポートに接続する。


VNCはJavaのビューワもサポートしている。
もしサーバがポート59xxで動作していたら、
ビューワを58xxからダウンロードすることができる。
しかしながら、
どうもJavaビューワはクライアントへのメインのVNCポート番号で通信しているようだ。
そのため、Javaビューワでこれをトンネルするには、
ローカルとリモートで同じポート番号を使う必要がある。
そのため、例えば、5901番のポートを使っているVNCサーバへのトラフィックを
トンネルするには、次のようにする。

 zebedee 5801,5901:remotehost:5801,5901


もしローカルマシンでも5901番ポートを使ったVNCサーバが動いていると、
これはうまくいかない。
しかし、ポートが衝突しないように両者を調整することは可能である。


もうひとつだけ言っておくことがある。
VNCをデータ圧縮とともに使おうとしているなら、
VNCのprotocol encodingに関して実験したほうがよい。
私は、"raw" encoding が圧縮の効果が高く、
遅い回線上ではよりよいパフォーマンスを示すことを発見した。
しかし、あなたの場合は違う結果となるかもしれない。

=head2 X Window Systemの使用例(Use with the X Window System)


X Window Systemは6000番以上のポートを使う。


B<xlocal> というローカルマシンのポート6000でX サーバが動作しているとする。
これは通常、B<xlocal:0> というディスプレイで使われているポートである。
そして、B<xremote>という(リモート)マシンから、
ローカルのディスプレイに安全な B<xterm> のセッションを送り返したいものとする。
これを行なうには、以下のコマンドを B<xlocal> で実行する。

 zebedee -r 6000 -s


そして、B<xremote> では

 zebedee 6001:xlocal:6000

を実行する。


このことは、B<xremote>上で、環境変数のB<DISPLAY>がC<localhost:1>に設定されていれば、
XのトラフィックはB<xlocal>に到着することを意味する。
そのため、例えばB<xterm>を安全にB<xremote>から送ろうとするなら、
B<xremote>上で次のコマンドを実行する必要がある。

 xterm -display localhost:1


これが正しく動作するためには、 
B<xremote>のXサーバのアクセスコントロールリストにB<localhost>のエントリーを
追加しなくてはならない。
これを行うには次のコマンドを実行する。

 xhost +localhost

=head2 HTTPの通信を安全にする(Securing HTTP traffic)


B<Zebedee>クライアントを"multi-use"モードで動作させることで、
全てのWebサーバへの通信を安全にすることができる。
もし、Webサーバが B<webhost> のポート80で動作しており、
そのサーバマシンで B<Zebedee> サーバも動作しているとしたら、
次のコマンドがローカルマシンの8000番ポート経由のトンネルを設定する。

 zebedee 8000:webhost:80

will set up a tunnel via port 8000 on the client host. Now any URLs that
previously were addressed via B<webhost>, for example:

 http://webhost/private/index.html


は、この状態では次のURLで安全にアクセスできる。

 http://localhost:8000/private/index.html


"C<localhost:8000>"をあなたのプロキシーとして設定することで、
全てのHTTPのトラフィックを安全なトンネル経由にすることもできる。
しかし、注意すべきことは、HTTPのプロキシー設定以外にこの設定をしてはいけない。
Secure HTTPを含む他のプロトコルは他の方法でリダイレクトする必要がある。
ほとんどのブラウザは違うドメインに違うプロキシーを割りあてる設定も可能である。
そのため、必要なものだけ選んでガードすることもできる。
これを行なう方法についてはブラウザのマニュアルを参照されたし。

=head2 FTPの通信を安全にする(Securing FTP traffic)



以下の手段で、
B<Zebedee>を使い多くのFTPサーバへのFTPコントロールコネクション
(ユーザ名とパスワードが送られるコネクション)を守ることができる。
さらに、B<Zebedee>パッケージに含まれる B<ftpgw.tcl> スクリプトによって、
パッシブモードのデータコネクションさえも守ることができる。


FTPサーバを扱う最も単純な方法は、以下のように B<Zebedee> を起動することだ。

 zebedee -s -r ftp ftpserverhost


FTPサーバと同じマシンで B<Zebedee> を動作させていても、コマンドラインで
明示的にホスト名を指定する必要がある(または
B<L<redirecthost|/item_redirecthost>>キーワードを使用)。それを
B<localhost>として参照してはいけない。クライアントシステムでは
B<Zebedee>を次のように起動して、ポート10000番経由のマルチユーストンネル
を構築する。

 zebedee 10000:ftpserverhost:ftp


FTPサーバに接続するには、次のようなコマンドを使用する。

 ftp clienthost 10000


くどいようだが、B<localhost> でなくローカルクライアントのホスト名を使うこと。
もし、windowsの標準FTPクライアントのように、
あなたのFTPクライアントがコマンドラインでポートを指定できない時は、
プログラムの中で(FTPセッションの中で) 
"C<open clienthost 10000>" というコマンドを使うことができる。
もし、クライアントマシンでFTPサーバが立ち上がっていなければ、 
B<Zebedee> をこのように起動してもよい。

 zebedee ftp:ftpserverhost:ftp


これだとFTPクライアントプログラムは次のように起動できる。


 ftp clienthost



FTPのコントロールコネクションとデータコネクションが同じ所から来ているか
どうかチェックするFTPサーバがあるが、そういうサーバに対しては上記の手法は
うまくいかない。B<wu-ftpd> のようなメジャーなFTPサーバはこの点に
ついて厳しくチェックを入れる(セキュリティ面からは望ましいことだが…)。
もし、サーバへの接続は明らかにうまくいくのに、
ファイルのリストや読み出しで失敗したりハングアップするなら、
そのサーバがここを厳しくチェックするタイプだった、ということだ。


この問題を克服するのを助けるために、B<ftpgw.tcl> というFTPゲートウェイの
スクリプトが B<Zebedee> パッケージには含まれている。
このプログラムはフリーに入手可能であるTclスクリプティング言語
(http://www.scriptics.com参照)で書かれていて、
FTPのリクエストを中継して再送信し、サーバからB<Zebedee> の存在を隠す。
これは B<Zebedee> サーバと同じマシンで走らせる必要がある。
FTPサーバも同じマシンで動いているなら、単にこう起動すればよい。

 tclsh ftpgw.tcl


これでゲートウェイはポート2121で待ち受ける。明らかに、実際の使用ではこれ
をバックグラウンドで起動したいだろう。それから、B<Zebedee>サーバを

 zebedee -s -r 2121

として起動する。


このケースではローカルホスト名を指定する必要はない
(したければしてもかまわないが)。
クライアント側ではこうする。

 zebedee 2121:ftpserverhost:2121


それからこうする。


 ftp clienthost 2121


こちらでは、この場合でもクライアントホスト名を使う。


この設定では、FTPのコントロールコネクションはトンネルされるが、
データコネクションには一切影響を与えない。
もし、あなたのFTPクライアントがパッシブモードをサポートしていれば、 
B<ftpgw.tcl> でデータチャンネルも安全にすることができる。
Netscape Navigator や Windows用のWS_FTPなどはそれをサポートしている。


パッシブモードのデータコネクションを安全にするためには、
まずデータコネクションに使うポート番号の範囲を選ばなくてはいけない。
この例では。30000から30100番を使うものとする。
まず、B<ftpgw.tcl> を 起動する時に、このポート範囲を指定するために、
B<-p>オプションを使用する。

 tclsh ftpgw.tcl -p 30000-30100



B<Zebedee>サーバはこのように起動する。

 zebedee -s -r 2121,30000-30100


クライアントはこうだ。

 zebedee 2121,30000-30100:ftpserverhost:2121,30000-30100


Netscapeを使ってコントロールコネクションとデータコネクションを
両方安全にアクセスするには、このようなURLを入力する。

 ftp://username@clienthost:2121/


ここでI<username>はFTPサーバでのユーザ名である。

=head1 CREDITS AND LEGALITIES

The following information can also be found in the file F<LICENCE.txt> in the
B<Zebedee> distribution.

 Copyright (c) 1999, 2000 by Neil Winton. All Rights Reserved.

 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,
 USA.

A copy of the GNU General Public License can be found in the file F<GPL2.txt>.

You may obtain the latest copy of B<Zebedee>, including full source code from
http://www.winton.org.uk/zebedee/ and other enquiries about B<Zebedee>
can be e-mailed to the author at zebedee@winton.org.uk

B<Zebedee> would not have been possible without the use of a large amount of
freely-available software to do all the really hard stuff. I gratefully
acknowledge the contributions made by the authors of the following software
packages.

B<Zebedee> uses the "Blowfish" encryption algorithm devised by Bruce Schneier.
For more information on Blowfish see http://www.counterpane.com/blowfish.html .
The implementation used is by Eric Young and is covered by the following
copyright:

 Copyright (C) 1995-1997 Eric Young (eay@mincom.oz.au)
 All rights reserved.
 
 This package is an Blowfish implementation written
 by Eric Young (eay@mincom.oz.au).
 
 This library is free for commercial and non-commercial use as long as
 the following conditions are aheared to.  The following conditions
 apply to all code found in this distribution.
 
 Copyright remains Eric Young's, and as such any Copyright notices in
 the code are not to be removed.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 3. All advertising materials mentioning features or use of this software
 must display the following acknowledgement:
 This product includes software developed by Eric Young (eay@mincom.oz.au)
 
 THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.
 
 The license and distribution terms for any publically available version or
 derivative of this code cannot be changed.  i.e. this code cannot simply be
 copied and put under another distrubution license
 [including the GNU Public License.]
 
 The reason behind this being stated in this direct manner is past
 experience in code simply being copied and the attribution removed
 from it and then being distributed as part of other packages. This
 implementation was a non-trivial and unpaid effort.

B<Zebedee> uses the B<zlib> compression library by Jean-loup Gailly and
Mark Adler. It is covered by the following copyright notice:

 (C) 1995-1998 Jean-loup Gailly and Mark Adler

 This software is provided 'as-is', without any express or implied
 warranty.  In no event will the authors be held liable for any damages
 arising from the use of this software.

 Permission is granted to anyone to use this software for any purpose,
 including commercial applications, and to alter it and redistribute it
 freely, subject to the following restrictions:

 1. The origin of this software must not be misrepresented; you must not
 claim that you wrote the original software. If you use this software
 in a product, an acknowledgment in the product documentation would be
 appreciated but is not required.
 2. Altered source versions must be plainly marked as such, and must not be
 misrepresented as being the original software.
 3. This notice may not be removed or altered from any source distribution.

 Jean-loup Gailly        Mark Adler
 jloup@gzip.org          madler@alumni.caltech.edu

B<Zebedee> may use the B<bzip2> compression library by Julian Seward which is
covered by the following licence:

 This program, "bzip2" and associated library "libbzip2", are
 copyright (C) 1996-1999 Julian R Seward.  All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 
 2. The origin of this software must not be misrepresented; you must 
    not claim that you wrote the original software.  If you use this 
    software in a product, an acknowledgment in the product 
    documentation would be appreciated but is not required.
 
 3. Altered source versions must be plainly marked as such, and must
    not be misrepresented as being the original software.
 
 4. The name of the author may not be used to endorse or promote 
    products derived from this software without specific prior written 
    permission.
 
 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 Julian Seward, Cambridge, UK.
 jseward@acm.org
 bzip2/libbzip2 version 0.9.5 of 24 May 1999

By default B<Zebedee> is built using an aribtrary precision integer arithmetic
library derived from the sources to C<mirrordir-0.10.49> which in turn derived
this from the B<Python> sources. The copyright is as follows:
 
 huge-number.c: arbitrary precision integer library from Python sources
 This has nothing to do with cryptography.
 Copyright (C) 1998 Paul Sheer
 
 This program is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program; if not, write to the Free Software
 Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 
 This file was taken from the Python source for `long' type
 integers. I have changed it to compile independently of the
 Python source, and added the optimisation that GNU C can
 use 31 bit digits instead of Python's 15 bit. You can download
 the original from www.python.org. This file bears little
 resemblance to the original though - paul
 
 Copyright 1991-1995 by Stichting Mathematisch Centrum, Amsterdam,
 The Netherlands.
 
                         All Rights Reserved
 
 Permission to use, copy, modify, and distribute this software and its
 documentation for any purpose and without fee is hereby granted,
 provided that the above copyright notice appear in all copies and that
 both that copyright notice and this permission notice appear in
 supporting documentation, and that the names of Stichting Mathematisch
 Centrum or CWI or Corporation for National Research Initiatives or
 CNRI not be used in advertising or publicity pertaining to
 distribution of the software without specific, written prior
 permission.
 
 While CWI is the initial source for this software, a modified version
 is made available by the Corporation for National Research Initiatives
 (CNRI) at the Internet address ftp://ftp.python.org.
 
 STICHTING MATHEMATISCH CENTRUM AND CNRI DISCLAIM ALL WARRANTIES WITH
 REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH
 CENTRUM OR CNRI BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
 DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 PERFORMANCE OF THIS SOFTWARE.

B<Zebedee> uses the Secure Hash Algorith (SHA) the code for which was derived
from Uwe Hollerbach's SHA module for B<perl>. The code contains the following
statement:

 NIST Secure Hash Algorithm
 heavily modified by Uwe Hollerbach <uh@alumni.caltech edu>
 from Peter C. Gutmann's implementation as found in
 Applied Cryptography by Bruce Schneier

 This code is in the public domain

Under Windows, B<Zebedee> uses an implementation of the F<getopt> function
covered by the following copyright:

 Copyright (c) 1987, 1993, 1994
 	The Regents of the University of California.  All rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
 notice, this list of conditions and the following disclaimer in the
 documentation and/or other materials provided with the distribution.
 3. All advertising materials mentioning features or use of this software
 must display the following acknowledgement:
 	This product includes software developed by the University of
 	California, Berkeley and its contributors.
 4. Neither the name of the University nor the names of its contributors
 may be used to endorse or promote products derived from this software
 without specific prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

=head2 Thanks

Special thanks go to those people who have taken the trouble to give me
feedback and suggestions for improvement!

 $Id: zebedee.pod,v 1.1 2000/07/18 02:05:04 tnaka Exp $

.\"    This file documents the GNU utilities for finding files that match
.\" certain criteria and performing various operations on them.
.\" 
.\"    Copyright (C) 1994 Free Software Foundation, Inc.
.\" 
.\"    Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\" 
.\"    Permission is granted to copy and distribute modified versions of
.\" this manual under the conditions for verbatim copying, provided that
.\" the entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\" 
.\"    Permission is granted to copy and distribute translations of this
.\" manual into another language, under the above conditions for modified
.\" versions, except that this permission notice may be stated in a
.\" translation approved by the Foundation.
.\"
.\" Japanese Version Copyright (c) 1997 NAKANO Takeo
.\"   and 2010 Chonan Yoichi 
.\"         all rights reserved.
.\" Translated Thu May 11 1997 by NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Modified Fri 14 Aug 1998 by NAKANO Takeo -- bug fixes.
.\" Updated and modified (findutils-4.4.2) Mon Dec 20 21:17:50 JST 2010
.\"         by Chonan Yoichi <cyoichi@maple.ocn.ne.jp>
.\" Modified Sun Jan 30 11:44:29 JST 2011 by Chonan Yoichi
.\"
.\" WORD    expression   式
.\" WORD    predicate    述語 (式を構成するオプション、判別式、アクションを
.\"                            一まとめにした言い方)
.\" WORD    test(s)      判別式
.\" WORD    directive    書式指定子
.\" WORD    access time           アクセス日時
.\" WORD    status change time    ステータス変更日時
.\" WORD    modification time     内容更新日時
.\" WORD    birth time            (ファイルの)作成日時
.\"
.TH FIND 1 \" -*- nroff -*-
.SH 名前
find \- ディレクトリ階層をたどって、条件を満たすファイルを検索する
.SH 書式
.B find 
[\-H] [\-L] [\-P] [\-D debugopts] [\-Olevel] [path...] [expression]
.SH 説明
このマニュアルページは GNU 版
.B find
の使用法を説明している。
GNU 版
.B find
は、指定されたファイル名 (訳注: 上記「書式」における path...、
普通はディレクトリを指定する) を始点とするディレクトリツリーを
一つづつ探索し、与えられた式 (expression) を、
優先規則に従いつつ (「演算子」セクションを参照)、左から右へ
評価することによって検索を行う。
結果が確定すると (たとえば、\fIand\fR 演算なら左辺が偽になった時点で、
\fIor\fR 演算なら左辺が真になった時点で)、
.B find
は検査の対象を次のファイル名に移す。
.PP
もし
.B find
を使用しているのが、セキュリティの問題をおろそかにできない環境なら
(たとえば、
.B find
を使って探索しているディレクトリが、自分以外のユーザにも
書き込み可能な場合など)、findutils 関連文書の
「Security Considerations」の章をお読みになるとよいだろう。
\fBFinding Files\fP という文書で、findutils に同梱されているはずだ
(訳注: \fBinfo "Finding Files"\fR や \fBinfo find\fR で読むことができる)。
その文書では、ほかの点についてもこのマニュアルページより
はるかに詳しい説明や考察が行われているので、この文書以上に情報源として
お役に立つかもしれない。
.SH オプション
.BR \-H ,
.BR \-L ,
.B \-P
というオプションは、シンボリックリンクをどう処理するかを決める。
こうしたオプションに続くコマンドライン引き数は、探索場所となる
ファイル名やディレクトリ名と見なされる。ただし、それは、`\-' で始まる
引き数や、`(' とか `!' という引き数が、続いて現れるまでだ。
そうした引き数、及びそれに続くいかなる引き数も、何を捜すべきかを
記述した式であると解釈される。パスが一つも指定されていない場合は、
カレントディレクトリ以下が探索の対象になる。
式が一つも指定されていない場合は、
.B \-print
が式として使用される (もっとも、
.B \-print
の代わりに、
.B \-print0
の使用を考えた方がよさそうだが)。
.PP
このマニュアルページで説明する「オプション」には、式の一部として
使われるものもある。そうしたオプションは、
.B find
の動作を制御するものであり、指定する位置は最後のパス名の直後になる。
これに対して、
.BR \-H ,
.BR \-L ,
.BR \-P ,
.BR \-D ,
.B  \-O
という五つの「本来」のオプションは、指定するなら、最初のパス名の前で
指定しなければならない。なお、ダッシュを二個重ねた
.B \-\-
を使用して、後に続く引き数がオプションではないことを明示することも
可能だ (それでも、探索の始点となるパス名のリストでワイルドカードを
使用するならば、始点のすべてが `./' か `/' で始まるように
しておいた方が、たいてい無難である)。
.IP \-P
シンボリックリンクをまったくたどらない。これがデフォルトの動作である。
.B find
がファイルの情報を調べたり表示したりする際に、そのファイルが
シンボリックリンクだったら、そのシンボリックリンクそのものの
プロパティから取得した情報が使用されることになる。

.IP \-L
シンボリックリンクをたどる。
.B find
がファイルの情報を調べたり表示したりする際に、
リンク先のファイルのプロパティから取得した情報が使用されることになり、
リンクそのものの情報は利用されない (ただし、
シンボリックリンクがリンク切れしていたり、
.B find
がリンク先のファイルを調べることができなかった場合は除く)。
このオプションを使用すると、自動的に
.B \-noleaf
が指定される。
後で
.B \-P
オプションを指定し直しても、
.B \-noleaf
は依然として有効なままである。
.B \-L
が有効になっているとき、
.B find
が探索中にサブディレクトリを指すシンボリックリンクに出会うと、
そのシンボリックリンクが参照しているサブディレクトリが探索される。
.IP
.B \-L
オプションが有効だと、述語
.B \-type
は (訳注: 「述語 (predicate)」とは、式を構成するオプション、判別式、
アクションなどの基本語彙を言う)、リンクそのものに対してではなく、
常にシンボリックリンクが指しているファイルのタイプに対してマッチを
行うようになる (シンボリックリンクがリンク切れしている場合を除く)。
.B \-L
を使用すると、述語
.B \-lname 
や
.B \-ilname
は常に偽を返す。

.IP \-H
コマンドライン上で指定された引き数を処理するとき以外、
シンボリックリンクをたどらない。すなわち、原則として、
.B find
がファイルの情報を調べたり表示したりする際に、シンボリックリンク
そのもののプロパティから取得した情報が、使用されることになる。
ただし、この動作には例外が一つあって、それは、コマンドラインで
指定されたファイルがシンボリックリンクであり、そのリンクが
解決できるときだ。その場合は、リンク先が何であれ、そこから
取得した情報が使用され (つまり、リンクがたどられるわけだ)、
シンボリックリンク自体の情報は、リンク先のファイルを調べることが
できなかったときの、控えの情報として使われる。
.B \-H
が有効な場合に、コマンドラインで指定されたパスの中にディレクトリへの
シンボリックリンクがあったら、そのディレクトリの中身が
調べられることになる (もっとも、\-maxdepth 0 を指定すれば、
当然ながら、この動作は抑制されることになるだろうが)。
.P
一つ以上の
.BR \-H ,
.BR \-L ,
.B \-P
を指定した場合は、後のものが前のものを上書きする。
従って、コマンドラインで最後に指定されたものが、効果を持つわけだ。
.B \-P 
はデフォルトなので、
.B \-H
や
.B \-L
を指定しないかぎり、
.B \-P
オプションが有効になっていると考えるべきである。

GNU
.B find
は実際の探索に取りかかる前にコマンドラインの処理を行うが、
その際 stat システムコールを使ってファイルの情報を調べることが
よくある。上述のオプションは、そのとき引き数がどう処理されるかにも
影響を与える。具体的に説明しよう。いくつのの判別式では、
コマンドラインで指定したファイルを目下検査の対象になっているファイルと
照合する。いづれの判別式でも、コマンドラインで指定したファイルは、
情報が調べられた後、そのプロパティのいくつかが保存されることになる。
名前を指定したファイルが実際にはシンボリックリンクであるとき、
.B \-P
オプションが有効な場合は (言い換えれば、
.B \-H
と
.B \-L
のどちらのオプションも指定されていない場合は)、
照合に使用される情報は、シンボリックリンクのプロパティから
取得したものである。それ以外の場合、使用されるのはリンク先のファイルの
プロパティから取得した情報だ。ただし、
.B find
が (たとえば、権限が不十分だとか、リンク先のファイルが
存在しないとかの理由で) リンクをたどれない場合は、
リンクそのもののプロパティが使われることになる。
.P
.B \-H
や
.B \-L
オプションが有効な場合は、
.B \-newer
の引き数として指定されたのがシンボリックリンクなら、その参照がたどられて、
リンク先のファイルからタイムスタンプが取得されることになる。
同じことが、
.BR \-newerXY ,
.BR \-anewer ,
.B \-cnewer
についても言える。

式の一部として使用される
.B \-follow
オプションには
.B \-L
と同様の効果があるが、それが現れた位置から有効になるという点が
異なる (すなわち、
.B \-L
が使われずに、
.B \-follow
が使われた場合、
.B \-follow
より後で指定されたいかなるシンボリックリンクも参照がたどられるが、
その前に指定されたシンボリックリンクは参照がたどられない)。

.IP "\-D debugoptions"
診断用の情報を出力する。
.B find
が期待どおりに動いてくれないとき、問題の原因追求に役立つことがある。
デバッグオプションを複数指定するときは、コンマで区切る。
findutils のバージョンの間で、デバッグオプションの互換性は保証されていない。
有効な全デバッグオプションのリストについては、
.B find \-D help
の出力を見るとよい。
有効なデバッグオプションの中には、以下のものがある。
.RS
.IP help
デバッグ用オプションを説明する。
.IP tree
式の構造 (expression tree) をオリジナルな形と最適化した形で示す。
.IP stat
.B stat
や
.B lstat
システムコールを使ってファイルが調べられたとき、
メッセージを表示する。
.B find
プログラムは、そうしたシステムコールの回数を最少にしようとする。
.IP opt
式の構造 (expression tree) の最適化に関する診断情報を表示する。
\-O オプションを参照。
.IP rates
各述語が何回成功し、何回失敗したかを示す情報を要約して表示する。
.RE
.IP \-Olevel
検査の最適化を有効にする。
.B find
プログラムは、実行速度を上げるために判別式の順序を並べ替えるとき、
全体的な効果を維持しようとする。すなわち、付加的な作用のある
述語同士については、相互の相対的な順序を変更しないということだ。
各最適化レベルで行われる最適化は、以下のとおりである。
.RS
.IP 0
最適化レベル 1 と同じである。
.IP 1
これはデフォルトの最適化レベルであり、伝統的な動作に当たる。
式を並べ替えるとき、ファイル名にのみ基づいた判別式 (たとえば、
.B \-name
や
.BR \-regex )
が先に実行されるようにする。
.IP 2
判別式
.B \-type
や
.B \-xtype
の実行は、ファイル名に基づいたいかなる判別式よりも後になるが、
inode から情報を取得する必要があるどんな判別式よりも先になる。
最近の Unix には
.B readdir()
関数でファイルタイプを取得できるものが多い。
それ故、こうした述語は、まず stat 関数でファイル情報を取得する
必要がある述語よりも、評価に時間がかからないのである。
.IP 3
この最適化レベルでは、コストに基づいた検査の最適化を徹底して行う機能が
有効になる。判別式の順序が必要なら変更され、コストのかからない
(すなわち、速い) 判別式が先に行われ、よりコストのかかる判別式が
後回しにされる。コストがほぼ同じ場合には、その述語が真を返しそうか、
偽を返しそうかによって、評価の順番が変わってくる。
.B or
演算では、真を返しそうな述語が先に評価され、
.B and
演算では、偽になりそうな述語が先に評価されるのである。
.RE
.IP
コストに基づいた最適化機能は、ある判別式が真を返す確率について
一定の考えを持っている。場合によっては、その確率について、
問題のテストの特性が考慮されることもある (たとえば、
.B \-type f
は、
.B \-type c
よりも、真になる可能性が高いと見なされる)。
コストに基づいた最適化機能は、現在のところその効果を評価中である。
もし、それによって
.B find
の性能が実際に向上することがなければ、捨てられることになるだろう。
反対に、信頼性があり、問題を起こしにくく、効果的であることが
はっきりした最適化は、そのうち下位の最適化レベルでも採用される
かもしれない。とは言え、リリース 4.3.x のシリーズでは、
デフォルトの動作 (すなわち、最適化レベル 1) を変更する予定はない。
なお、findutils のソースに付属するテスト集は、そのテストのすべてを
各最適化レベルの
.B find
で実行して、どの最適化レベルでも結果が同じになることを保証している。
.SH "式 (EXPRESSIONS)"
式は、オプション、判別式、アクションから構成されている
(訳注: オプション、判別式、アクションをまとめて、「述語 (predicate)」と呼ぶ)。
オプションは特定のファイルの処理よりもむしろ作業全体に影響し、
常に真を返す。判別式が返す値は、真のこともあれば、偽のこともある。
アクションには付加的な作用があり、真または偽を返す。
こうした式の要素は、みな演算子で区切られる。演算子が省略された場所には、
.B \-and
があるものと見なされる。

式の中に
.B \-prune
以外のアクションが存在しない場合は、
式の結果が真になったすべてのファイルに対して
.B \-print
が実行される。
.SS オプション
.P
すべてのオプションは常に真を返す。
.BR \-daystart ,
.BR \-follow ,
.B \-regextype
を除いて、そのほかのオプションは、そのオプションより前に
指定された判別式も含め、すべての判別式に影響を及ぼす。
これは、オプションの処理は、コマンドラインが解析されるときに
行われるのに対して、判別式の方は、ファイルが調べられるまで
何もしないからである。
.BR \-daystart ,
.BR \-follow ,
.B \-regextype
の各オプションはこの点で異なっている。この三つのオプションは、
コマンドラインで自分より後に指定された判別式にしか影響を
及ぼさないのだ。従って、混乱を避けるためには、
.BR \-daystart ,
.BR \-follow ,
.B \-regextype
以外のオプションは、
式の先頭部に置いた方がよい。そうしないと、警告が発せられる。

.IP \-d
\-depth と同じ。FreeBSD, NetBSD, MacOS X, OpenBSD との互換性のためにある。

.IP \-daystart
.BR \-amin , 
.BR \-atime , 
.BR \-cmin , 
.BR \-ctime , 
.BR \-mmin , 
.B \-mtime
において、今日 (すなわち 0 日前) の始まりを今現在から 24 時間前ではなく、
コマンド実行当日の 0 時にする。
このオプションが影響を及ぼすのは、コマンドラインで自分より後に
指定された判別式だけである。
.RS
.IP "[訳注]:" 8
.BR \-amin ,
.BR \-cmin ,
.B \-mmin
のことも考慮に入れると、次のように言えばよいのかもしれない。
デフォルトでは時間を計算するときの基準を
今現在に置くが、
.B \-daystart
を指定すると、時間計算の基準が今日の 24:00 になる。
.RE

.IP \-depth
ディレクトリそのものより先に、ディレクトリの中身を処理する。
アクション
.B \-delete
を使用すると、
.B \-depth
オプションも自動的に設定される。

.IP \-follow
非推奨である。
.B \-L
オプションを代わりに使う方がよい。シンボリックリンクをたどる。
.B \-noleaf
が自動的に設定される。
.B \-follow
オプションが影響を及ぼすのは、コマンドラインで自分より後に指定された
判別式だけである。
.B \-H
や
.B \-L
オプションが指定されていない場合、
.B \-follow
オプションの位置によって述語
.B \-newer
の動作が変わってくる。
.B \-newer
が
.B -follow
の後に来れば、
.B \-newer
の引き数として指定されたいかなるファイルも、それがシンボリックリンクなら、
リンクをたどられることになるわけだ。同じことが
.BR \-newerXY , 
.BR \-anewer , 
.B \-cnewer 
についても言える。
同様に、述語
.B \-type
も、シンボリックリンクそのものではなく、必ずシンボリックリンクが
参照しているファイルのタイプに対してマッチを行うようになる。
.B \-follow
を使用すると、述語
.B \-lname
と
.B \-ilname
は常に偽を返す。

.IP "\-help, \-\-help"
.B find
のコマンドラインの使用法をざっと説明して終了する。

.IP \-ignore_readdir_race
通常、\fBfind\fR は stat 関数でファイル情報を取得できなかったとき、
エラーメッセージを吐くことになっている。
ところが、このオプションを指定した場合は、\fBfind\fR が
ディレクトリからファイル名を読み込んでから、そのファイルに対して
stat 関数を実行しようとするまでの間に、ファイルが消去されても、
エラーは表示されない。この動作は、コマンドラインで名前を指定した
ファイルやディレクトリに対しても適用される。このオプションは
コマンドラインを読み込む際に有効になるので、ファイルシステムの
ある部分をこのオプションを有効にして探索し、別の部分はこのオプションを
無効にして探索するといったことはできない (そうしたことをやりたかったら、
\fBfind\fR コマンドを二回実行する必要があるだろう。一回は、
このオプションを付けて、もう一回はこのオプションなしで)。

.IP "\-maxdepth \fIlevels\fR"
コマンドライン引き数として指定したパスから最大 \fIlevels\fR 段階下の
ディレクトリまで探索する (\fIlevels\fR は非負の整数)。
.B \-maxdepth 0
は、判別式やアクションの対象にするのは、
コマンドライン引き数だけであることを意味する。

.IP "\-mindepth \fIlevels\fR"
 コマンドライン引き数として指定したパスから少なくとも \fIlevels\fR 段階
ディレクトリを下降するまで、どんな判別式やアクションも行わない
(\fIlevels\fR は非負の整数)。
.B \-mindepth 1
を指定すると、コマンドラインの引き数を除くすべてファイルを処理する。

.IP \-mount
ほかのファイルシステムにあるディレクトリを探索しない。これは
.B \-xdev
の別名であり、系統の違う
.B find
との互換性のためにある。

.IP \-noignore_readdir_race
.B \-ignore_readdir_race
の効果を無効にする。

.IP "\-noleaf"
「ディレクトリのハードリンク数から 2 を引いたものが、そのディレクトリに
含まれるサブディレクトリの数である」とする最適化動作を行わない。
このオプションが必要になるのは、ディレクトリとリンクの関係について
Unix の流儀に従わないファイルシステムを探索するときだ。
たとえば、CD-ROM や MS-DOS のファイルシステムとか、AFS ボリュームの
マウントポイントなどを探索するときである。
通常の Unix ファイルシステムでは、各ディレクトリは少なくとも
2 個のハードリンクを持っている。ディレクトリ名のエントリと、
そのディレクトリ中の `.' エントリである。さらに、そのディレクトリに
サブディレクトリがあれば、サブディレクトリそれぞれに、親ディレクトリに
ハードリンクした '..' エントリが存在する。
.B find
としては、ディレクトリを調べる際に、ディレクトリのリンク数より 2 少ない
数だけサブディレクトリを stat 関数で調べた時点で、ディレクトリ中の
残りのエントリはディレクトリではない (ディレクトリツリー中の
`leaf 葉っぱ' ファイルである) とわかるわけである。
もし、調べるのがファイル名だけで充分なら、ファイルに対して stat 関数を
実行する必要はない。そこで、この動作により、検索速度が
いちじるしく向上するわけだ。

.IP "\-regextype \fItype\fR"
判別式
.B \-regex
と
.B \-iregex
が理解する正規表現の文法を変更する。
このオプションよりコマンドラインの後方で指定する
.B \-regex
などに対して効果がある。
現在実装されている文法のタイプには、emacs (デフォルトである),  
posix-awk, posix-basic,  posix-egrep, posix-extended がある。

.IP "\-version, \-\-version"
\fBfind\fR のバージョンを表示して終了する。

.IP "\-warn, \-nowarn"
警告メッセージの表示、非表示を切り替える。こうしたメッセージは、
もっぱらコマンドラインの使用法に関するものであり、
.B find
がディレクトリを探索中に出会うかもしれない何らかの状況に
関するものではない。デフォルトの動作は、標準入力が tty であれば、
.B \-warn
であり、それ以外の場合は、
.B \-nowarn
である。

.IP \-xdev
ほかのファイルシステムにあるディレクトリを探索しない。

.SS 判別式 (TESTS)
判別式の中には、たとえば
.B \-newerXY
や
.B \-samefile
のように、現在検査の対象になっているファイルと、コマンドラインで指定した
リファレンスファイルとを比較することになっているものがある。
そうしたリファレンスファイルの実体が何になるかは、
.BR \-H ,
.BR \-L ,
.B \-P
といったオプションや、先行する
.B \-follow
の存在によって決まってくる。
ただし、リファレンスファイルが調べられるのは、一回だけであり、
それはコマンドラインの解析が行われるときである。
リファレンスファイルを調べることができない場合は (たとえば、
それに対する
.BR stat (2)
システムコールに失敗するなど)、エラーメッセージが表示され、
.B find
は 0 以外のステータスで終了する。
.P
数値の引き数は、以下の形で指定することができる。
.IP \fI+n\fP
.I n
を越える数であることを意味する。
.IP \fI\-n\fP
.I n
未満であることを意味する。
.IP \fIn\fP
ぴったり
.I n
であることを意味する。

.IP "\-amin \fIn\fR"
ファイルの最終アクセス日時が \fIn\fR 分前であれば真。

.IP "\-anewer \fIfile\fR"
ファイルの最終アクセス日時が、\fIfile\fR の内容更新日時よりも
新しければ、真を返す。引き数 \fIfile\fR がシンボリックリンクで、
しかも
.B \-H
や
.B \-L
オプションが有効になっている場合は、リンク先のファイルの内容更新日時が
比較に使用されることになる。
.\" (訳注: "If \fIfile\fR is a symbolic link" の \fIfile\fR は
.\" 直前にある "than \fIfile\fR was modified" の \fIfile\fR と
.\" 同じだろうから -- すなわち、-anewer の引き数だろうから --
.\" "the access time of the file it points" の access time を
.\" modification time に修正しないと、つじつまが合わなくなる。
.\" ほぼ同じことが、-cnewer や -newer の訳についても言える)

.IP "\-atime \fIn\fR"
ファイルの最終アクセス日時が \fIn\fR 日前ならば、真を返す。
ファイルの最終アクセス日時が何日前かを計算する際、現在時刻との時間差を
24 で割った余りは切り捨てられる。従って、
.B \-atime +1
にマッチするためには、
ファイルは少なくとも二日前にアクセスされていなければならない。

.IP "\-cmin \fIn\fR"
ファイルの最終ステータス変更日時が \fIn\fR 分前ならば真。

.IP "\-cnewer \fIfile\fR"
ファイルの最終ステータス変更日時が、\fIfile\fR の内容更新日時よりも
新しければ、真を返す。引き数 \fIfile\fR がシンボリックリンクで、
しかも
.B \-H
や
.B \-L
オプションが有効になっている場合は、リンク先のファイルの内容更新日時が
比較に使用されることになる。

.IP "\-ctime \fIn\fR"
ファイルの最終ステータス変更日時が \fIn\fR 日前ならば、真を返す。
何日前かを計算する際に、現在時刻との時間差を 24 で割った余りを
切り捨てることが、ファイルのステータス変更日時の解釈にどんな影響を
及ぼすかについては、
.B \-atime
の説明を見てほしい。

.IP \-empty
ファイルが空で、通常のファイルかディレクトリならば真。

.IP \-executable
実行可能なファイルや (ファイル名解決の際に) 検索可能なディレクトリに
マッチする。判別式
.B \-perm
が ACL (アクセス・コントロール・リスト) などのパーミッション制御の
仕組みを無視するのに対して、この判別式は ACL なども考慮に入れる。
この判別式は
.BR access (2)
システムコールを使用しているので、UID マッピング (または root-squashing) を
行っている NFS サーバがあると、正確な結果を得られないことがある。
なぜなら、たいていのシステムは
.BR access (2)
をクライアントのカーネルで実装しており、それ故、サーバ側に保持されている
UID マッピング情報を利用できないからだ。
この判別式はひとえに
.BR access (2)
システムコールの結果に基づいているので、この判別式が
真を返したからと言って、そのファイルが実際に実行できるとはかぎらない。

.IP \-false
常に偽を返す。

.IP "\-fstype \fItype\fR"
ファイルが置かれているファイルシステムが \fItype\fR ならば、真を返す。
使用できるファイルシステムは、Unix の系統によって様々である。
Unix の系統次第では指定可能なファイルシステムを不完全ながら挙げると、
ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K などがある。
アクション
.B \-printf
で書式指定子
%F を使えば、使用中のファイルシステムのタイプが何かを知ることができる。

.IP "\-gid \fIn\fR"
ファイルのグループ ID 番号が \fIn\fR ならば真。

.IP "\-group \fIgname\fR"
ファイルの属するグループが \fIgname\fR ならば真 (グループ ID 番号で
指定してもよい)。

.IP "\-ilname \fIpattern\fR"
.B \-lname
と同じだが、大文字小文字を区別しない。
.B \-L
か
.B \-follow
オプションが有効な場合は、シンボリックリンクがリンク切れしている場合を除き、
この判別式は偽を返す。

.IP "\-iname \fIpattern\fR"
.B \-name
と同じだが、大文字小文字を区別しない。
たとえば、パターン `fo*' や `F??' は、`Foo', `FOO', `foo', `fOo'
といったファイル名とマッチする。シェルのファイル名展開と違い、
こうしたパターンにおいて '*' は、ファイル名の先頭にある '.' とも
マッチする。すなわち、
.B find \-name *bar
は、ファイル `.foobar' ともマッチすることになるわけだ。
当然ながら、パターンは引用符で囲むべきだということに気をつけて
いただきたい。さもないと、パターン中にワイルドカード文字があれば、
シェルがそれを展開してしまうことになる。

.IP "\-inum \fIn\fR"
ファイルの inode 番号が \fIn\fR ならば真。たいていの場合、
この判別式より、
.B \-samefile
を使った方が簡単である。

.IP "\-ipath \fIpattern\fR"
.B \-iwholename
と同じように動作する。この判別式は非推奨である。使わないでいただきたい。

.IP "\-iregex \fIpattern\fR"
.B \-regex
と同じだが、大文字小文字を区別しない。

.IP "\-iwholename \fIpattern\fR"
.B \-wholename
と同じだが、大文字小文字を区別しない。

.IP "\-links \fIn\fR"
ファイルのリンク数が \fIn\fR ならば真。

.IP "\-lname \fIpattern\fR"
ファイルがシンボリックリンクであり、リンク先として指定されているパスが
シェルのパターン \fIpattern\fR にマッチすれば、真を返す。
メタ文字は、`/' や `.' を例外扱いしない。
.B \-L
や
.B \-follow
オプションが有効な場合は、シンボリックリンクがリンク切れしている場合を除き、
この判別式は偽を返す。

.IP "\-mmin \fIn\fR"
ファイルの最終内容更新日時が \fIn\fR 分前であれば真。

.IP "\-mtime \fIn\fR"
ファイルの最終内容更新日時が \fIn\fR 日前ならば、真を返す。
何日前かを計算する際に、現在時刻との時間差を 24 で割った余りを
切り捨てることが、ファイルの内容更新日時の解釈にどんな影響を
及ぼすかについては、
.B \-atime
の説明を見てほしい。

.IP "\-name \fIpattern\fR"
ファイルやディレクトリのベースネーム (パスから最後の要素だけを残して、
先行するディレクトリを取り去ったもの) が、シェルのパターン \fIpattern\fR に
マッチすれば、真を返す。メタ文字 (`*', `?', `[]) は、
ベースネームの先頭にある `.' とマッチする (findutils-4.2.2 から
このように変更になった。下記のセクション「標準への準拠」を参照)。
あるディレクトリとそれ以下にあるファイルをまとめて無視するには、
.B \-prune
を使うとよい。一例が
.B \-path
の説明中にある。
中カッコ ('{}') は特殊文字として認識されない。この点、bash を含む
一部のシェルで、シェル・パターン中の中カッコに特別な意味を付与しているのと
異なっている。ファイル名のマッチングは、
.BR fnmatch (3)
ライブラリ関数を用いて行われる。パターンを引用符で囲むのを
忘れないように。シェルによって展開されてしまわないようにするためである。

.IP "\-newer \fIfile\fR"
ファイルが \fIfile\fR よりも最近に内容を更新されていれば、真を返す。
引き数 \fIfile\fR がシンボリックリンクで、しかも
.B \-H
や
.B \-L
オプションが有効になっている場合は、
リンク先のファイルの内容更新日時が比較に使用されることになる。

.IP "\-newerXY \fIreference\fR"
目下検査の対象になっているファイルのタイムスタンプを \fIreference\fR と
比較する。引き数
.I reference
は、たいていの場合ファイル名であるが (そして、そのタイムスタンプの一つが
比較に使用されるが)、日時を直接表す文字列でも構わない。
.I X
と
.I Y
は仮の表現であって、実際には以下に述べるような別の文字が来る。
そうした文字が、検査の対象になっているファイルとリファレンスそれぞれの、
どの日時を比較に使用するかを決めるのである (訳注: 前者を
.I X
で、
後者を
.I Y
で指定する)。
.TS
ll
ll
ll
ll
llw(2i).
a	ファイルのアクセス日時
B	ファイルの作成日時
c	inode のステータスが変更された日時
m	ファイルの内容が更新された日時
t	\fIreference\fR が日時の直接表現として解釈される
.TE

組み合わせによっては、無効なものもある。たとえば、
.I X
に
.I t
を指定しても無効である。
組み合わせの中には、すべてのシステムで実装されているとはかぎらない
ものもある。たとえば、
.I B
はすべてのシステムでサポートされているわけではない。
.I XY
の無効な組み合わせやサポートされていない組み合わせを指定すると、
致命的エラーが起きる。日時を直接指定すると、それは GNU
.B date
の
.B \-d
オプションに対する引き数と同様に解釈される。
リファレンスファイルの作成日時を使用しようとして、作成日時が
特定できない場合は、致命的エラーのメッセージが表示される。
また、検査対象になるファイルの作成日時を参照する判別式を指定した場合、
作成日時がわからない環境では、そのテストはどのファイルに対しても
失敗することになる。

.IP \-nogroup
ファイルのグループ ID 番号に対応するグループが存在しなければ真。

.IP \-nouser
ファイルのユーザ ID 番号に対応するユーザが存在しなければ真。

.IP "\-path \fIpattern\fR"
ファイル名がシェルのパターン \fIpattern\fR にマッチすれば真。
メタ文字は `/' や `.' を例外扱いしない。従って、たとえば、
.br
.in +1i
find . \-path "./sr*sc"
.br
.in -1i
は、`./src/misc' と言うディレクトリを (存在していれば) 表示する。
あるディレクトリ以下をすべて無視するには、そこに存在するファイルを
一つ一つ抑止するよりも、
.B \-prune
を使用した方がよい。たとえば、 `src/emacs' と、その下にあるファイルや
ディレクトリのすべてをスキップし、それ以外のファイルがあったら、
その名前を表示するとしよう。そのためには、こんな風にする。
.br
.in +1i
find . \-path ./src/emacs \-prune \-o \-print
.br
.in -1i
パターンマッチのテストは、パスを含むファイル名の全体に対して行われるが、
そうしたパス付きのファイル名は、コマンドラインで指定した探索の始点の一つから
始まっていることに注意してほしい。だから、
.B \-path
の引き数に絶対パス名を使用することに意味があるのは、関連する探索の
始点がこちらも絶対パスであるときだけだろう。従って、次のコマンドは
何にもマッチしないことになる。
.br
.in +1i
find bar \-path /foo/bar/myfile \-print
.br
.in -1i
述語
.B \-path
は、HP-UX の
.B find
でもサポートされている。
POSIX 標準の次期バージョンでも採用されることになるだろう。

.IP "\-perm \fImode\fR"
ファイルの許可属性が \fImode\fR (8 進数表現でもシンボル表現でもよい)
とまったく同じなら、真を返す。
\fImode\fR 指定のこの形式では、許可属性がぴったり一致することを
要求しているので、シンボルによる表現でこの形式を使おうとすると、
かなり複雑なモード文字列を指定しなければならないかもしれない。たとえば
.B \-perm g=w
は、許可属性が 0020 のファイルにしかマッチしないことになる
(すなわち、許可属性のうち、グループの書き込み許可のみが立っている
ファイルだ)。そんなわけで、\fImode\fR の前に `/' や `-' を付ける形式を
使いたくなる場合の方が、ずっと多そうである。たとえば、
.BR "\-perm \-g=w"
なら、グループが書き込み許可を持っているいかなるファイルにも
マッチするわけだ。具体例については「用例」セクションを見てほしい。

.IP "\-perm \-\fImode\fR"
\fImode\fR で指定した許可属性ビットのすべてが、ファイルでも立っていれば、
真を返す。\fImode\fR 指定のこの形式でも、シンボルによる許可属性表現が
使用できる。と言うより、この形式ではたいていの場合、シンボルによる表現を
使いたくなるだろう。
シンボルによる表現を使用する場合は、`u' や `g' や `o' を
きちんと指定しなければならない。具体例については「用例」セクションを
見てほしい。

.IP "\-perm /\fImode\fR"
\fImode\fR で指定した許可属性ビットのどれかが、ファイルでも立っていれば、
真を返す。\fImode\fR 指定のこの形式でも、シンボルによる許可属性表現が
使用できる。シンボルによる表現を使用する場合は、`u' や `g' や `o' を
きちんと指定しなければならない。具体例については「用例」セクションを
見てほしい。
.I mode
で許可属性ビットが一つも立っていない場合、この判別式は
いかなるファイルにもマッチする (すなわち、
.B \-perm 
.B \-000
の動作と同じだということだ)。

.IP "\-perm +\fImode\fR"
非推奨な形式。\fImode\fR で指定した許可属性ビットのどれかが立っている
ファイルを捜す古い方法である。代わりに
.B \-perm \fI/mode\fR
を使用した方がよい。`+' を付けて \fImode\fR を指定するこの形式で
シンボルによる表現を使おうとすると、思いがけない結果を生むことがある。
たとえば、 `+u+x' はそれ自体有効なシンボル表現である ('+u,+x' と
同じであり、0111 を意味する)。そのため、
.B \-perm +u+x
は、
.B \-perm +\fImode\fR
として評価されず、ぴったり一致する許可属性を指定するときの
.B \-perm \fImode\fR
として評価されてしまうのだ。その結果、実行ビットが少なくともどれか一つ
立っているファイルではなく、許可属性がぴったり 0111 のファイルに
マッチすることになる。もし、この項の説明がわかりにくかったとしても、
あなた一人がわからないのではない。とりあえず、
.B \-perm /\fImode\fR
を使っておいていただきたい。判別式
.B \-perm
のこの形式が非推奨なのは、シンボルによる許可属性に先行する `+' は、
シンボル表現の一部として解釈するように POSIX の規定で要求されて
いるからであり、それ故、我々は '+' に代えて、'/' を使うようにしたのである。

.IP \-readable
読み込み可能なファイルにマッチする。判別式
.B \-perm
が ACL (アクセス・コントロール・リスト) などのパーミッション制御の
仕組みを無視するのに対して、この判別式は ACL なども考慮に入れる。
この判別式は
.BR access (2)
システムコールを使用しているので、UID マッピング (または
root-squashing) を行っている NFS サーバがあると、正確な結果を
得られないことがある。なぜなら、たいていのシステムは
.BR access (2)
をクライアントのカーネルで実装しており、それ故、サーバ側に保持されている
UID マッピング情報を利用できないからである。

.IP "\-regex \fIpattern\fR"
ファイル名が正規表現 \fIpattern\fR にマッチすれば、真を返す。
これはパスを含むファイル名全体に対するマッチであって、部分的な一致ではない。
だから、たとえば、`./fubar3' という名前のファイルにマッチさせるために、
正規表現  `.*bar.' や `.*b.*3' は使用できるが、`f.*r3' は使用できないわけだ。 
.B find
が理解する正規表現は、デフォルトでは Emacs の正規表現だが、これは
.B \-regextype
オプションで変更することができる。

.IP "\-samefile \fIname\fR"
ファイルが \fIname\fR と同じ inode を参照していれば、真を返す。
.B \-L
が有効な場合、シンボリックリンクも真を返す。

.IP "\-size \fIn\fR[cwbkMG]"
ファイルが \fIn\fP 単位分の領域を使用していれば、真を返す。
以下の接尾辞が使える。
.RS
.IP `b'
単位はブロック。1 ブロックは 512 バイト。(これが接尾辞を使わないときの
デフォルトである)
.IP `c'
単位はバイト。
.IP `w'
単位はワード。1 ワードは 2 バイト。
.IP `k
単位はキロバイト (1 キロバイトは 1024 バイト)。
.IP `M'
単位はメガバイト (1 メガバイトは 1048576 バイト)。
.IP `G'
単位はギガバイト (1 ギガバイトは 1073741824 バイト)。
.RE
.IP
サイズには間接ブロック (indirect block) の分は含まれないが、
穴空きファイル (sparse file) における、実際には割り当てられていない
ブロックの分は含まれる。アクション
.B \-printf
の
`%k' や `%b' 書式指定子とは穴空きファイルの扱い方が違うことを、
心にとめておいてほしい。接尾辞 `b' は常に 512 バイトのブロックを
意味し、1 キロバイトのブロックを指すことはない。その点が、アクション
.B \-ls
の動作と異なっている。

.IP \-true
常に真。

.IP "\-type \fIc\fR"
ファイルのタイプが \fIc\fR であれば真。\fIc\fR の位置には実際には
以下の文字が来る。
.RS
.IP b
ブロック・スペシャルファイル (バッファあり)
.IP c
キャラクタ・スペシャルファイル (バッファなし)
.IP d
ディレクトリ
.IP p
名前付きパイプ (FIFO)
.IP f
通常のファイル
.IP l
シンボリックリンク。オプション
.B \-L
や
.B \-follow
が有効な場合、シンボリックリンクがリンク切れの場合を除いて、
この判別式が真になることはない。
.B \-L
が有効なときにシンボリックリンクを検索したかったら、
.B \-xtype
を使うべきである。
.IP s
ソケット
.IP D
ドア (Solaris の場合)
.RE
.IP "\-uid \fIn\fR"
ファイル所有者のユーザ ID 番号が \fIn\fR ならば真。

.IP "\-used \fIn\fR"
ファイルが最後にアクセスされたのが、ファイルのステータスが最後に
変更されてから \fIn\fR 日後ならば、真を返す。

.IP "\-user \fIuname\fR"
ファイルの所有者が \fIuname\fR というユーザならば真
(ユーザ ID 番号で指定してもよい)。

.IP "\-wholename \fIpattern\fR"
.B \-path
と同じである。この別名は移植性で
.B \-path
に劣る。

.IP "\-writable"
書き込み可能なファイルにマッチする。判別式
.B \-perm
が ACL (アクセス・コントロール・リスト) などのパーミッション制御の
仕組みを無視するのに対して、この判別式は ACL なども考慮に入れる。
この判別式は
.BR access (2)
システムコールを使用しているので、UID マッピング (または
root-squashing) を行っている NFS サーバがあると、正確な結果を
得られないことがある。なぜなら、たいていのシステムは
.BR access (2)
をクライアントのカーネルで実装しており、それ故、サーバ側に保持されている
UID マッピング情報を利用できないからである。

.IP "\-xtype \fIc\fR"
検査の対象となるファイルがシンボリックリンクでないかぎり、
.B \-type
と同じである。ファイルがシンボリックリンクのときは、以下のように動作する。
.B \-H
や
.B \-P
オプションが指定された場合は、リンク先の
ファイルのタイプが \fIc\fR ならば、真を返す。他方、
.B \-L
オプションが指定されている場合は、\fIc\fR が `l' ならば、真を返す。
言い換えると、ファイルがシンボリックであるとき、
.B \-xtype
は、
.B \-type
が検査しない方のファイルのタイプを検査するわけだ。

.SS アクション
.IP "\-delete\fR"
ファイルを消去する。消去に成功すれば、真を返す。消去に失敗した場合は、
エラーメッセージを表示する。
.B \-delete
に失敗した場合の
.B find
の終了ステータスは、ゼロ以外である (最終的に終了したときの
終了ステータスのことである)。
.B \-delete
を使用すると、自動的に
.B \-depth
オプションが有効になる。

.BR 警告 :
忘れないでほしいが、find のコマンドラインは一つの式 (expression) として
評価されるので、一番最初に
.B \-delete
を指定すると、
.B find
は、指定された探索の開始点以下にあるものを、ことごとく消去しようとする。
後で
.B \-delete
を付けて使用するつもりで、
.B find
のコマンドラインをテスト実行するときは、
.B \-depth
を明示的に指定するとよい。そうすれば、後で「こんなはずではなかった」と
慌てないですむ。
.B \-delete
を指定すると自動的に
.B \-depth
が有効になるので、
.B \-prune
を
.B \-delete
と一緒に使っても役に立たない。

.IP "\-exec \fIcommand\fR ;"
\fIcommand\fR を実行する。\fIcommand\fR の返り値が 0 ならば、真を返す。
.B find
のコマンドラインで指定されたこれ以降の引き数は、`;' という引き数が現れるまで、
すべてコマンドに対する引き数と見なされる。文字列 `{}' は、
それがコマンドの引き数中に現れるすべての場所で、現在処理中のファイル名に
置き換えられる。
.B find
の一部の版とは違い、`{}' は引き数中の一ヶ所でしか使えないわけではない。
こうした構文の要素 (訳注: すなわち、`{}' と `;') は、シェルによって
展開されないように、どちらも `\e' でエスケープするなり、
引用符で囲むなりする必要があるかもしれない。アクション
.B \-exec
の使用例については「用例」セクションを見てほしい。
指定したコマンドは、マッチした各ファイルに対して一回づつ実行される。
また、コマンドは
.B find
を実行したディレクトリで実行される。そこで、
.B \-exec
アクションの使用に関しては、セキュリティの問題が避けられないわけだ。
.B \-exec
の代わりに、
.B \-execdir
アクションを使用することをお勧めする。
(訳注: `;' は引き数なので、直前の引き数との間に空白が必要だ
ということに注意してほしい。)

.IP "\-exec \fIcommand\fR {} +"
アクション
.B \-exec
のこの変形も、選択したファイルに対して指定したコマンドを実行するが、
コマンドラインを形成するとき、選択した各ファイル名をコマンドラインの末尾に
追加して行くという方法を取る (訳注: コマンドラインが長くなりすぎるときは、
処理するファイル名の数を適切に分割して、コマンドを複数回実行する)。
そのため、コマンドを呼び出す回数は、マッチしたファイルの数より
ずっと少なくてすむわけだ。コマンドラインの形成法は、
.B xargs
のコマンドライン形成法とほぼ同じである。`{}' はコマンドライン中の
一ヶ所でしか使えない。コマンドは
.B find
を実行したディレクトリで実行される。
(訳注: `+' は引き数なので、直前の引き数との間に空白が必要だ
ということに注意してほしい。)

.IP "\-execdir \fIcommand\fR ;"
.IP "\-execdir \fIcommand\fR {} +"
.B \-exec
と似ているが、指定したコマンドはマッチしたファイルが存在するサブディレクトリで
実行される。そのサブディレクトリは、
.B find
を実行したディレクトリとは違うのが普通だ。
これはコマンドを呼び出す方法としてずっと安全である。マッチしたファイルの
パスを解決する際に、競合状態が起きるのを避けられるからだ。
アクション
.B \-exec
の場合と同様、
.B \-execdir
の `+' を伴う形式でも、
マッチした複数のファイルを一度に処理するように、コマンドラインを
形成することになる。しかし、
.I command
のどの呼び出しにおいても、処理の対象としてリストされるファイルは、
同じサブディレクトリに存在するものだけである。このアクションを
使用するのなら、環境変数
.B $PATH
が `.' を参照しないようにしなければならない。
さもないと、悪意を持った攻撃者が、あなたが
.B \-execdir
を実行することになるディレクトリに適当な名前のファイルを
入れておくことによって、何でも好きなコマンドを実行できてしまうからである。
.B $PATH
の中に、空っぽのエントリや、絶対パスのディレクトリ名ではない
エントリがある場合にも、同じことが当てはまる。

.IP "\-fls \fIfile\fR"
真を返す。
.B \-ls
と似ているが、
.B \-fprint
同様、出力を \fIfile\fR に書き出す点が違う。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、
必ず作成される。
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションを参照してほしい。

.IP "\-fprint \fIfile\fR"
真を返す。パス付きのファイル名をファイル \fIfile\fR に出力する。
\fBfind\fR の実行時に \fIfile\fR が存在しなければ、
新たに作成される。すでに存在していれば、元の中身が捨てられる。
ファイル名 ``/dev/stdout'' と ``/dev/stderr'' の扱いは特別で、
それぞれ標準出力と標準エラー出力を指している。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、
必ず作成される。
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションを参照してほしい。

.IP "\-fprint0 \fIfile\fR"
真を返す。
.B \-print0
と似ているが、
.B \-fprint
同様、出力を \fIfile\fR に書き出す点が違う。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、
必ず作成される。
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションを参照してほしい。

.IP "\-fprintf \fIfile\fR \fIformat\fR"
真を返す。
.B \-printf
と似ているが、
.B \-fprint
同様、出力を \fIfile\fR に書き出す点が違う。
出力用のファイルは、この述語の対象になるものが一つもなかった場合でも、
必ず作成される。
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションを参照してほしい。

.IP \-ls
真を返す。処理対象のファイルを
.B ls \-dils
の書式で標準出力にリストする。ブロック数は、1 ブロック 1 キロバイトの
計算である。ただし、環境変数 POSIXLY_CORRECT が設定されている場合は、
1 ブロック 512 バイトが使用される。
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションを参照してほしい。

.IP "\-ok \fIcommand\fR ;"
.B \-exec
と似ているが、まずユーザに問い合わせを行う。ユーザーが同意すれば、
コマンドを実行する。同意しなければ、何もせずに偽を返す。
コマンドを実行する際、そのコマンドの標準入力は、
.B /dev/null
に付け換えられる。

.IP
プロンプトに対するユーザの応答は、肯定・否定を表す一組の正規表現と照合して、
同意か、不同意かが判断される。この正規表現は、環境変数 `POSIXLY_CORRECT' が
設定されていれば、システムから得られるが、設定されていなければ、
.B find
のメッセージ・カタログから取得される。なお、システムに適切な定義が
存在しない場合は、
.B find
の持つ定義が使用されることになる。どちらの場合でも、正規表現そのものの
解釈は、環境変数 'LC_CTYPE' (文字クラスにについて) や 'LC_COLLATE'
(文字の範囲や等価クラスについて) の影響を受ける。

.IP "\-okdir \fIcommand\fR ;"
.B \-execdir
と似ているが、
.B \-ok
と同じように、まずユーザに問い合わせを行う。
ユーザが同意しなければ、何もせずに偽を返す。
コマンドを実行する際、そのコマンドの標準入力は、
.B /dev/null
に付け換えられる。

.IP \-print
真を返す。パス付きのファイル名を標準出力に表示し、各ファイル名の後ろに
改行文字を付ける。
.B find
の出力をパイプを使って他のプログラムに渡している場合、検索対象の
ファイル名に改行文字が含まれている可能性が、わずかにでもあるならば、
アクション
.B \-print
ではなく、
.B \-print0
を使用することを真剣に考えるべきだ。
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションを参照してほしい。

.IP \-print0
真を返す。パス付きのファイル名を標準出力に表示し、各ファイル名の後ろに
.RB ( \-print
が改行文字を付けるのとは違って)
ヌル文字を付加する。
そうすることによって、\fBfind\fR の出力を処理するプログラムが、
改行文字などのホワイトスペースを含むファイル名を正しく解釈できる
ようになるわけだ。このアクションは、
.B xargs
の
.B \-0
オプションに呼応している。

.IP "\-printf \fIformat\fR"
真を返す。標準出力に \fIformat\fR を出力する。
そのとき \fIformat\fR 中の `\e' によるエスケープシーケンスと、`%' に
始まる書式指定子を認識して変換する。
フィールドの幅や精度は、C 言語の `printf' 関数と同じやり方で
指定できる。フィールドの多くは、(`printf' 関数流に言うと)
%d ではなく、%s として出力されることに注意していただきたい。
すなわち、フラグが期待通りに効かないかもしれないのだ。だが、
それはまた、`\-' フラグ (フィールドを強制的に左揃えにする) が
使えるということでもある。
.B \-print
とは違って、
.B \-printf
は文字列の末尾に改行文字を付加しない。
バックスラッシュ・エスケープシーケンスと書式指定子は以下のとおりである。
.RS
.IP \ea
警告ベル。
.IP \eb
バックスペース。
.IP \ec
このフォーマットによる出力をただちに停止し、出力バッファを
フラッシュする。
.IP \ef
フォームフィード文字。
.IP \en
改行文字。
.IP \er
復帰文字。
.IP \et
水平タブ。
.IP \ev
垂直タブ。
.IP \e0
ASCII NUL 文字。
.IP \e\e
バックスラッシュ文字そのもの (`\e')。
.IP \eNNN
ASCII コードが NNN (8 進数) の文字。
.PP
バックスラッシュ文字 `\e' に上記以外の文字が続く場合、`\e' は
普通の文字として扱われる。従って、二文字とも表示されるわけだ。
.IP %%
パーセント文字そのもの。
.IP %a
ファイルの最終アクセス日時を C 言語の `ctime' 関数が返す形式で表示する。
.IP %A\fIk\fP
ファイルの最終アクセス日時を \fIk\fR で指定した書式で表示する。
\fIk\fR には `@' か、あるいは C 言語の `strftime' 関数の書式指定子を用いる。
\fIk\fR に指定可能な値を以下に列挙する。
一部のものは使えないシステムがあるかもしれないが、それはシステム間での
`strftime' の非互換性による。
.RS
.IP @
Jan. 1, 1970, 00:00 GMT からの経過秒数。小数点以下も表示する。
.PP
時刻フィールド:
.IP H
時 (00..23)
.IP I
時 (01..12)
.IP k
時 ( 0..23)
.IP l
時 ( 1..12)
.IP M
分 (00..59)
.IP p
現在のロケールにおける AM/PM の相当語
.IP r
12 時間制の時刻 (hh:mm:ss [AP]M)
.IP S
秒 (00.00 .. 61.00)。小数点以下も表示。
.IP T
24 時間制の時刻 (hh:mm:ss)
.IP +
日付と時刻。両者の間は `2004\-04\-28+22:22:05.0' といった具合に '+' で
区切られる。これは GNU の拡張である。日時は現在のタイムゾーンのものが
使われる (それ故、環境変数 TZ の設定によって変わるかもしれない)。
秒には小数点以下も付く。
.IP X
現在のロケールによる時刻表示 (H:M:S)
.IP Z
タイムゾーン (JST など)。タイムゾーンを決定できない場合は、何も表示しない。
.PP
日付フィールド:
.IP a
現在のロケールによる曜日の短縮形 (Sun..Sat)
.IP A
現在のロケールによる曜日のフル表示。長さは可変 (Sunday..Saturday)
.IP b
現在のロケールによる月名の短縮形 (Jan..Dec)
.IP B
現 在 のロケールによる月名のフル表示。長さは可変 (January..December)
.IP c
現在のロケールによる日付と時刻の表示 (Sat Nov 04 12:02:33 EST 1989)。
この表示形式は
.BR ctime (3)
のものと同じであり、
.BR ctime (3)
の形式との互換性を維持するためにそうなっている。秒には小数点以下が付かない。
.IP d
その月の何日目かの表示 (01..31)
.IP D
日付 (mm/dd/yy)
.IP h
b と同じ
.IP j
その年の何日目かの表示 (001..366)
.IP m
月 (01..12)
.IP U
その年の何週目か (日曜日を週の始まりとする) (00..53)
.IP w
その週の何日目か (0..6)
.IP W
その年の何週目か (月曜日を週の始まりとする) (00..53)
.IP x
現在のロケールによる日付表示 (mm/dd/yy)
.IP y
年の後ろ二桁 (00..99)
.IP Y
年 (1970...)
.RE
.IP %b
ファイルのディスクスペース使用量を 1 ブロック 512 バイトのブロック数で
表示する。割り当てられたディスクスペースは、ファイルシステムの
ブロックサイズの倍数になるので、この表示はたいてい %s/512 より大きい。
だが、ファイルが穴空きファイル (sparse file) の場合は、%s/512 より
小さくなることもある。
.IP %c
ファイルの最終ステータス変更日時を C 言語の `ctime' 関数が返す
形式で表示する。
.IP %C\fIk\fP
ファイルの最終ステータス変更日時を \fIk\fR で指定した書式で表示する。
\fIk\fR は %A の場合と同じである。
.IP %d
ファイルがディレクトリツリー中でどの深さにあるかを示す。0 だったら、
そのファイルがコマンドライン引き数であるということだ。
.IP %D
ファイルがどのデバイス上にあるかを十進数のデバイス番号で示す
(stat 構造体の st_dev フィールドに当たる)。
.IP %f
先行するディレクトリをすべて取り去ったファイル名 (すなわち、
最後の要素のみ表示)。
.IP %F
ファイルが置かれているファイルシステムのタイプ。
ここで表示された値は -fstype の引き数に指定することができる。
.IP %g
ファイルのグループ名。グループ名が登録されていない場合は、
グループ ID 番号。
.IP %G
ファイルのグループ ID 番号。
.IP %h
ファイル名中の先行するディレクトリの部分 (すなわち、
最後の要素以外のすべて)。ファイル名にスラッシュが一つも含まれない場合は
(ファイルがカレントディレクトリにあるからだ)、
%h 書式指定子は "." に展開される。
.IP %H
探索の開始点を示すコマンドライン引き数で、その下に問題のファイルが
見つかったもの。
.IP %i
ファイルの inode 番号 (十進数表示)。
.IP %k
ファイルのディスクスペース使用量を 1 ブロック 1 キロバイトのブロック数で
表示する。割り当てられたディスクスペースは、ファイルシステムの
ブロックサイズの倍数になるので、この表示はたいてい %s/1024 より大きい。
だが、ファイルが穴空きファイル (sparse file) の場合は、%s/1024 より
小さくなることもある。
.IP %l
シンボリックリンクの参照先 (ファイルがシンボリックリンクでなかったら、
空文字列)。
.IP %m
ファイルの許可属性ビット (8 進数表示)。このオプションが使用している
数値は、Unix のたいていの実装が使用している「伝統的な」数値である。
しかし、ご使用のシステムの実装では、8 進数で表示する許可属性ビットの並び方が
独特かもしれない。その場合は、ファイルの許可属性の実際の値と
%m の出力とが、相違することになる。この数値の先頭に 0 を付けて
表示したいこともよくあるが、そのためには、
.B #
フラグを使用すればよい (たとえば、`%#m' といった具合に)。
.IP %M
ファイルの許可属性
.RB ( ls
と同様のシンボルによる表現)。この書式指定子は findutils 4.2.5 以来
サポートされている。
.IP %n
ファイルのハードリンク数。
.IP %p
ファイル名。
.IP %P
問題のファイルが、ある探索開始点の下にあった場合に、ファイル名から
探索開始点を示すコマンドライン引き数の部分を取り去ったもの。
.IP %s
バイトで表示したファイルサイズ。
.IP %S
ファイルの穴空き率 (sparseness)。この値は、(BLOCKSIZE*st_blocks / st_size) で
計算される。ある大きさの普通のファイルから得られる値は、
厳密に言うと、システム依存である。それでも、
穴空きファイルの穴空き率は、通常 1.0 未満になるし、間接ブロックを
使用しているファイルの穴空き率は、1.0 以上になることがある。
BLOCKSIZE に使われる値は、システム次第だが、普通は 512 バイトである。
ファイルサイズが 0 の場合、出力される値は不定である。
st_blocks をサポートしていないシステムでは、ファイルの穴空き率は、
1.0 と見なされる。
.IP %t
ファイルの最終内容更新日時を、C 言語の `ctime' 関数が返す形式で表示する。
.IP %T\fIk\fP
ファイルの最終内容更新日時を、\fIk\fR で指定した書式で表示する。
\fIk\fR は %A の場合と同じである。
.IP %u
ファイルの所有者名。所有者のユーザが登録されていない場合は、ユーザ ID 番号。
.IP %U
ファイルのユーザ ID 番号。
.IP %y
ファイルのタイプ
.RB ( "ls \-l"
の表現とほぼ同じ)。U=unknown type (これが表示されることはないはずだ）
.IP %Y
ファイルのタイプ (表示は %y と同じ)。ただし、シンボリックリンクをたどる。
その場合、L=loop, N=nonexistent である。
.PP
一個の `%' に上記以外の文字が続く場合、`%' 文字は捨てられるが、
それに続く文字は表示される (書式指定文字が新たに追加されるかもしれないので、
この動作を当てにしてはいけない)。書式指定の末尾に `%' があるときの動作は、
続く文字がないので不定である。ロケールによっては、お宅のドアの鍵が
見つからなくなるかもしれない。また、別のロケールでは、
お読みの小説の最後のページが消えてしまうかもしれない。

書式指定子 %m と %d はフラグ
.BR # ,
.BR 0 ,
.B +
をサポートするが、それ以外の書式指定子は、数値を表示する場合でも、
そうしたフラグをサポートしない。
.B #
などをサポートしない数値関係の書式指定子には、
.BR G , 
.BR U , 
.BR b , 
.BR D , 
.BR k , 
.B n
などがある。しかし、書式フラグ `\-' はサポートされており、フィールドを
(デフォルトの) 右揃えから左揃えに変更する。
.PP
ファイル名中の変わった文字がどのように扱われるかについては、
「変わり者のファイル名」セクションの説明を参照してほしい。


.RE
.IP \-prune
真を返す。ファイルがディレクトリの場合は、そのディレクトリ以下に
降りて行かない。
.B \-depth
が指定してあるときは、偽を返し、何もしない。
.B \-delete
を指定すると自動的に
.B \-depth
が有効になるので、
.B \-prune 
を
.B \-delete
と一緒に使っても役に立たない。
.RS
.IP "[訳注]:" 8
バージョン 4.4.0 以降の \fBfind\fR では、\fB\-prune\fR の動作が
上記の説明と少し異なっている。すなわち、「\fB\-depth\fR が指定して
あるときは、何もしない」のは、それまでのバージョンと同じだが、
返り値は真を返している。ご自分で、
.B find . \-depth \-path \(dq./foo\(dq \-prune \-print
などを実行して、確認していただきたい。\fB\-prune\fR が真を返していれば、
ディレクトリ \fB./foo\fR が表示されるはずだ。
.RE

.IP "\-quit"
直ちに終了する。動いている子プロセスを残したまま終了したりはしないが、
コマンドラインで指定したパスをこれ以上処理することはない。たとえば、
.B find /tmp/foo /tmp/bar \-print \-quit
は、
.B /tmp/foo
を表示するだけである。
.B \-execdir ... {} +
によってすでに作成されたコマンドラインがあれば、
.B find
が終了する前に、呼び出して実行する。終了ステータスは、
エラーがすでに起きているかどうかよって、0 のことも、0 でないこともある。

.SS 変わり者のファイル名
多くの場合、
.B find
のアクションはデータを端末に表示することになるわけだが、それは
ほかのユーザが自由にできるデータであることもある。そうしたデータとは、
たとえば、ファイルの名前、サイズ、内容更新日時などだ。
この内、ファイル名は `\e0' と `/' 以外のどんな文字でも使えることに
なっているので、時として問題の種となる。ファイル名の中に
風変わりな文字があると、使用している端末に思いがけない、
そしてしばしば望ましくない影響をもたらすことがあるのだ (たとえば、
端末によっては、ファンクション・キーの現在の設定が変更されてしまう)。
風変わりな文字をどう扱うかはアクションによって異なっている。
それを以下に示そう。

.IP "\-print0, \-fprint0\"
常にファイル名に手を加えず、そのまま出力する。出力先が端末であっても、
同じである。

.IP "\-ls, \-fls"
風変わりな文字は、常にエスケープされる。ホワイトスペース (空白、
改行、タブなど)、バックスラッシュ、ダブルクォートは C 言語式の
エスケープ表現で出力される (たとえば `\ef', `\e"')。
ほかの風変わりな文字には、エスケープした8 進数が使われる。
それ以外の表示可能な文字は
.RB ( \-ls
や
.B \-fls
とっては 8 進数の 041 から 0176 に当たる文字)、手を加えずに
そのまま出力される。

.IP "\-printf, \-fprintf"
出力先が端末でない場合は、そのまま出力される。端末の場合は、
使用される書式指定子によって、結果は様々である。
書式指定子 %D, %F, %g, %G, %H, %Y, %y が展開される値は、
ファイルの所有者の管轄外なので、そのまま出力される。
書式指定子 %a, %b, %c, %d, %i, %k, %m, %M, %n, %s, %t, %u, %U の
値は、ファイル所有者の管轄内であるが、それを使って端末に勝手なデータを
送ることはできない。従って、そのまま出力される。
書式指定子  %f, %h, %l, %p, %P はクォートされる。このクォート方法は、GNU
.B ls
と同じである。言い換えると、
.B \-ls 
や
.B \-fls
におけるクォート方法とは違うということだ。
もし、
.B find
の出力に使う形式を自由に決めることができるならば、たいていの場合、
終端文字に改行ではなく、`\e0' を使用した方がよい。
ファイル名には空白や改行が含まれていることがあるからだ。
どの文字がクォートを必要とするかを判断するには、環境変数 `LC_CTYPE' の設定が
使用される。

.IP "\-print, \-fprint"
クォートは
.B \-printf
や
.B \-fprintf
と同じやり方で行われる。
.B find
をスクリプト中で使っている場合や、マッチするファイルが行儀の悪い
ファイル名を持っている可能性がある場合は、
.B \-print
ではなく、
.B \-print0
の使用を考えた方がよいだろう。
.P
アクション
.B \-ok 
と
.B \-okdir
は、対象となるファイル名をそのまま手を加えずに出力する。この動作は、
将来のリリースで変わるかもしれない。

.SS 演算子
.P
演算子を優先順位の高いものから順に列挙する。

.IP "( \fIexpr\fR )"
カッコの内側を先に処理する。カッコはシェルにとって特別な意味を
持っているので、普通はクォートする必要があるだろう。
このマニュアルページで挙げている例の多くでは、そのためにバックスラッシュを
使っている。すなわち `(...)' ではなく、`\e(...\e)' と書いているわけだ。

.IP "! \fIexpr\fR"
\fIexpr\fR が偽の場合、真になる。通常この記号も、シェルによって
解釈されないようにする必要があるだろう。

.IP "\-not \fIexpr\fR"
! \fIexpr\fR と同じだが、POSIX 準拠の表現ではない。

.IP "\fIexpr1 expr2\fR"
連続する二つの式は、and 結合と解釈される (明示されていないが、
式の間に "-a" があると見なされるわけだ)。\fIexpr1\fR が偽の場合、
\fIexpr2\fR は評価されない。

.IP "\fIexpr1\fR \-a \fIexpr2\fR"
\fIexpr1 expr2\fR と同じ。

.IP "\fIexpr1\fR \-and \fIexpr2\fR"
\fIexpr1 expr2\fR と同じだが、POSIX 準拠の表現ではない。

.IP "\fIexpr1\fR \-o \fIexpr2\fR"
or 結合である。\fIexpr1\fR が真ならば、\fIexpr2\fR は評価されない。

.IP "\fIexpr1\fR \-or \fIexpr2\fR"
\fIexpr1\fR
.B \-o
\fIexpr2\fR
と同じだが、POSIX 準拠の表現ではない。

.IP "\fIexpr1\fR , \fIexpr2\fR"
リストである。常に \fIexpr1\fR と \fIexpr2\fR の両方が評価される。
\fIexpr1\fR の値は捨てられ、\fIexpr2\fR の値がリスト全体の値になる。
コンマ演算子はいくつかの異なったタイプの対象を捜すとき便利だが、
ファイルシステム階層の探索は一度しか行われない。
異なった形でマッチした対象の一覧をそれぞれ別のファイルに書き出すには、
.B \-fprintf
を利用すればよい。

.IP "[訳注]:" 8
.B find
にとって演算子も引き数である。だから `(', `)', `!', `,' といった演算子も、
前後の引き数との間に空白が必要だということに気をつけてほしい。

.SH "標準への準拠"
POSIX 標準にできるだけ準拠した動作を求めるのなら、環境変数
POSIXLY_CORRECT を設定するとよい。以下のオプションや述語は
POSIX standard (IEEE Std 1003.1, 2003 Edition) で規定されている。

.IP \fB\-H\fR
このオプションはサポートしている。

.IP \fB\-L\fR
このオプションもサポートしている。

.IP \fB\-name\fR
この述語はサポートしている。しかし、POSIX への準拠度は、システムの
.BR fnmatch (3)
ライブラリ関数がどの程度 POSIX に準拠しているかに依存している。
findutils-4.2.2 以来、シェルのメタ文字 (`*', `?', `[]' など) は、
ファイル名の先頭の `.' 文字にマッチするが、
これは IEEE PASC interpretation 126 がそう要求しているからである。
この動作は それ以前のバージョンの findutils と異なっている。 

.IP \fB\-type\fR
サポートしている。POSIX では `b', `c', `d', `l', `p', `f', `s' を
規定している。GNU find は、そのほか「ドア」を表す `D' もサポートしているが、
使えるのは OS がそうしたファイル・タイプを用意している場合のみである。

.IP \fB\-ok\fR
サポートしている。プロンプトに対する応答は、"yes"、"no" を表すパターンに
照らして解釈されるが、そのパターンは環境変数 `LC_MESSAGES' の設定によって
選択されたものである。 環境変数 `POSIXLY_CORRECT' が設定されている場合は、
何が肯定的応答 (yes) で、何が否定的応答 (no) かを決めているシステムの
定義が、このパターンに使用される。\fBnl_langinfo\fP(3) に関する
システムの文書、特に YESEXPR と NOEXPR の部分を参照してほしい。
`POSIXLY_CORRECT' が設定されていない場合は、パターンは、システムではなく、
.B find
自身のメッセージ・カタログから取得される。

.IP \fB\-newer\fR
サポートしている。指定されたファイルがシンボリックリンクの場合は、
必ずリンク先が参照される (訳注: 訳者としては、\fB\-P\fR、\fB\-L\fR、
\fB\-H\fR オプションの説明から言って、「\fB\-L\fR や \fB\-H\fR オプションが
有効な場合は」という条件が必要ではないかと思う)。以前のバージョンでは、
シンボリックリンクそのものから比較に使う日時を取得していたのだが、
動作がこのように変更になった。後述の「履歴」セクションも参照してほしい。

.IP \fB\-perm\fR
サポートしている。環境変数 POSIXLY_CORRECT が設定されていない場合は、
POSIX では無効な +a+x といったモード指定の引き数も、
後方互換のために使用できるようになっている。

.IP "その他の述語"
.BR \-atime ,
.BR \-ctime ,
.BR \-depth ,
.BR \-group ,
.BR \-links ,
.BR \-mtime ,
.BR \-nogroup ,
.BR \-nouser ,
.BR \-print ,
.BR \-prune ,
.BR \-size ,
.BR \-user  
.B \-xdev
といった述語は、すべてサポートしている。

.P
POSIX 標準は、カッコ `(', `)'、否定 `!'、それに and と or 演算子
.RB ( \-a ,
.BR \-o )
を規定している。
.P
上記以外のすべてのオプション、述語、式などは、POSIX 標準にない拡張である。
とは言え、そうした拡張の多くは、GNU find に特有なものではない。
.P
POSIX 標準によれば、
.B find
はループを検出することになっている。
.IP
.B find
ユーティリティは無限ループを検出しなければならない。無限ループとは、
探索中に入ったディレクトリが、すでに探索済みで、最後に処理の対象にした
ファイルの上位ディレクトリに当たることである。無限ループを検出した場合、
find は何が起きたかを告げる診断メッセージを標準エラーに表示し、
探索位置をディレクトリ階層上の元の位置に戻すか、終了すべきである。
.P
GNU
.B find
はこうした要求に従っている。ディレクトリがその中に
上位ディレクトリへのハードリンクであるエントリを含んでいる場合は、
ディレクトリのリンク数が、本来ならそうなるはずの数よりも
たいてい少なくなるものだ。その結果、
GNU find が時として、実際には上位ディレクトリへのハードリンクである
サブディレクトリを、最適化の副作用で探索しないですますことが起こりえる。
その場合、
.B find
は確かにそうしたディレクトリに足を踏み入れないわけだから、
「ループ検出」の診断メッセージを出さないでもよいことになっている。
これはかなり紛らわしい動作かもしれないが、
.B find
のこの動作を本気で当てにしている人もいないことだろう。
.B \-noleaf
オプションを指定して、ディレクトリ・ツリー上の葉っぱを簡易判別する
最適化を無効にしている場合は (訳注: \fB\-noleaf\fR 参照) 、
こうしたディレクトリ・エントリに対する検査も省略されずに行われ、
必要ならば、診断メッセージが表示されることになる。
シンボリックリンクを使うと、そういったファイルシステム上の循環は
起きないが、
.B \-L
や
.B \-follow
を使用している場合は、探索中に
シンボリックリンクのループに出会えば、診断メッセージが表示される。
ハードリンクを含むループの場合と同様、葉っぱを簡易判別する最適化を
使用していると、たいていの場合、シンボリックリンクに対して
.I stat()
や
.I chdir()
を呼び出すまでもないと、
.B find
が承知していることになるので、
ループの診断は不要になることが多い。
.IP "[訳注]:" 8
Linux や BSD 系 Unix のようにディレクトリへのハードリンクを
作成できない Unix もある。その場合は、上記のハードリンクに関する
解説は当てはまらない。
.P
.B \-d
オプションは BSD システム各種との互換性のためにサポートされている。
だが、POSIX に準拠している
.B \-depth
オプションの方を使った方がよい。
.P
環境変数 POSIXLY_CORRECT は、判別式
.B \-regex
や
.B \-iregex
の動作に影響を与えない。そうした判別式は、POSIX 標準で規定されていない
からである。
.SH "環境変数"

.IP LANG
国際化関係の環境変数のうち、値が設定されていなかったり、null だったりする
変数に対して、LANG の値がデフォルトの値になる。

.IP LC_ALL
これが空文字列以外の値に設定されていると、その値が国際化関係の
他のすべての環境変数の値よりも優先される。

.IP LC_COLLATE
POSIX の規定によれば、この環境変数は判別式
.B \-name
で使われるパターンマッチングに影響する。
GNU find は
.BR fnmatch (3)
ライブラリ関数を使用しているので、LC_COLLATE への対応は
システムのライブラリ次第である。また、この変数はアクション
.B \-ok
に対する応答の解釈にも影響を及ぼす。
.B \-ok
に対する応答の解釈に使用される実際のパターンは LC_MESSAGES 変数によって
選択されるのだが、パターン中に角カッコ式が現れた場合の解釈は、LC_COLLATE の
影響を受けるのである。

.IP LC_CTYPE
この環境変数は、正規表現で使用される文字クラスの扱いに影響する。
システムの
.BR fnmatch (3)
ライブラリ関数がこの変数に対応している場合は、判別式
.B \-name
の使用にともなう文字クラスの扱いにも影響を及ぼす。また、この変数は、
アクション
.B \-ok
が出すプロンプトに対してユーザが応答する際、諾否の判断に使用される
正規表現の文字クラスの解釈にも関係する。さらにまた、環境変数 LC_CTYPE は、
ファイル名が表示されるとき、どの文字を表示不可能 (unprintable) と見なすかにも
かかわることになる。「変わり者のファイル名」セクションを参照してほしい。

.IP LC_MESSAGES
国際化されたメッセージのために使用されるロケールを決める。
また、環境変数 POSIXLY_CORRECT が設定されている場合は、アクション
.B \-ok
が出したプロンプトに対する応答を、どう解釈するかもこの変数が決定する。

.IP NLSPATH
国際化メッセージ・カタログを置く場所を決める。

.IP PATH
.BR \-exec ,
.BR \-execdir ,
.BR \-ok ,
.B \-okdir
によって呼び出される実行ファイルを捜すために検索するディレクトリに影響する。

.IP POSIXLY_CORRECT
.B \-ls
や
.B \-fls
が使用するブロックサイズを決める。
.B POSIXLY_CORRECT
が設定されているときは、1 ブロック 512 バイト、
設定されていないときは、1 ブロック 1024 バイトである。
.IP
また、この変数を設定すると、警告メッセージを出さないのがデフォルトになる
(すなわち、
.B \-nowarn
になるわけだ)。なぜならば、POSIX の規定では、
.B \-ok
の出すプロンプトを除いて、標準エラーに出力されるメッセージはすべて
問題が起きたことを知らせるものであり、そのときの終了ステータスは
0 以外でなければならないからである。
.IP
POSIXLY_CORRECT が設定されていない場合、
+zzz が許可属性を表すシンボルとしてそれ自体有効な表現であるときを除き、
.B \-perm
+zzz は
.B \-perm
/zzz とまったく同じように扱われる。
POSIXLY_CORRECT が設定されている場合は、許可属性の前に '+' や '/' を取る
こうした形式は、エラーとして処理される (訳注: もちろん、+zzz がそれ自体
有効なシンボル表現であるときを除く。判別式
.B \-perm +\fImode\fR
の説明を参照)。
.IP
POSIXLY_CORRECT が設定されていると、アクション
.B \-ok
が出すプロンプトに対するユーザの応答を解釈する際に、
.B find
の持つメッセージ・カタログではなく、システムのメッセージ・カタログが
参照される。
.IP TZ
タイムゾーンに影響する。タイムゾーンは、
.B \-printf
や
.B \-fprintf
の日時に関係する一部の書式指定子で使用される。
.SH "用例"
.nf
.B find /tmp \-name core \-type f \-print | xargs /bin/rm \-f

.fi
.B /tmp
ディレクトリ以下に
.B core
という名前のファイルを捜して、それを消去する。名前の中に改行、
シングルクォート、ダブルクォート、スペースなどを含むファイルがあるときは、
正しく動作しないことに注意すること。
.P
.B find /tmp \-name core \-type f \-print0 | xargs \-0 /bin/rm \-f

.fi
.B /tmp
ディレクトリ以下に
.B core
という名前のファイルを捜して、それを消去する。ファイル名の処理に当たっては、
ファイルやディレクトリの名前にシングルクォート、ダブルクォート、空白、
改行などが含まれていても、適切に扱われるようにする。判別式
.B \-name
を
.B \-type
の前に置いているのは、すべてのファイルに対して
.B stat(2)
システムコールを行う無駄を省くためである。

.P
.nf
.B find . \-type f \-exec file \(aq{}\(aq \e\;
 
.fi
カレントディレクトリ以下のあらゆるファイルに対して file コマンドを
実行する。中カッコをシングルクォートで囲んでいることに注目してほしい。
シェルスクリプトのブロック区切り記号として解釈されないようにするためである。
同様に、セミコロンもバックスラッシュを使って保護している。こちらにも
シングルクォートを使用してもよい。

.P
.nf
.B find /  \e
.B \e( \-perm \-4000 \-fprintf /root/suid.txt \(dq%#m %u %p\en\(dq \e) , \e
.B \e( \-size +100M \-fprintf /root/big.txt  \(dq%\-10s %p\en\(dq \e)

.fi
全ファイルシステムを一回だけ探索して、setuid ビットの立っている
ファイルやディレクトリのリストを
.B /root/suid.txt
に、サイズの大きいファイルのリストを
.B /root/big.txt
に出力する。

.P
.nf
.B find $HOME  \-mtime 0

.fi
ここ 24 時間の内に内容が更新されたファイルをホームディレクトリ以下で
検索する。このコマンドがそういう動作になるのは、それぞれのファイルが
最後に更新されてから現在までの経過時間が、24 で割り算され、余りは
切り捨てられるからである。そこで、ファイルが
.B \-mtime 0
にマッチするためには、過去 24 時間未満の期間内に内容が更新されて
いなければならないことになる。

.P
.nf
.B find /sbin /usr/sbin -executable \e! -readable \-print

.fi
実行可能でありながら、読み出し不可能なファイルを捜す。

.P
.nf
.B find . \-perm 664

.fi
ファイルの所有者とグループは読むことも書くことも可能だが、
他のユーザは読み出しのみ可能で書き込みはできないファイルを捜す。
そうした条件を満たすものの、他の許可属性ビットも立っているような
(たとえば、そのファイルを実行できる人がいるような) ファイルは、
この式にマッチしない。

.P
.nf
.B find . \-perm \-664

.fi
ファイルの所有者とグループは読むことも書くことも可能であり、
他のユーザも読むことは可能であるようなファイルを捜す。
それ以外の許可属性ビットについては (たとえば、実行許可ビット)、
立っていてもいなくてもかまわない。この条件は、たとえば、
0777 のモードを持つファイルにもマッチすることになる。

.P
.nf
.B find . \-perm /222

.fi
誰かが書き込めるようなファイルを捜す (書き込めるのは、ファイルの所有者でも、
グループでも、他の一般ユーザでもよい)。

.P
.nf
.B find . \-perm /220
.B find . \-perm /u+w,g+w
.B find . \-perm /u=w,g=w

.fi
上記のコマンドは三つとも同じ動作をする。最初のものは、ファイルの許可属性を
8 進数で表し、後の二つは、シンボルによる表現形式を使っている。
こうしたコマンドはどれも、ファイルの所有者かグループが
書き込み可能であるようなファイルを捜す。所有者とグループの両方が
書き込み可能な場合しか、マッチしないわけではない。どちらか片方だけでも
十分である。

.P
.nf
.B find . \-perm \-220
.B find . \-perm \-g+w,u+w

.fi
この二つのコマンドは同じ動作をする。すなわち、ファイルの所有者と
グループの両方が書き込み可能であるようなファイルを捜す。

.P
.nf
.B find . \-perm \-444 \-perm /222 ! \-perm /111
.B find . \-perm \-a+r \-perm /a+w ! \-perm /a+x

.fi
この二つのコマンドは両方とも次のような条件のファイルを捜す。
その条件とは、誰にでも読み出すことが可能で
.RB ( "\-perm \-444"
や
.B "\-perm \-a+r"
がそれにに当たる)、
書き込み許可ビットが少なくとも一つは立っているが
.RB ( "\-perm /222"
や 
.BR "\-perm /a+w" )、
誰にも実行することはできない
.RB ( "! \-perm /111"
や
.BR "! \-perm /a+x" )
というものである。

.P
.nf
.B cd /source-dir
.B find . \-name .snapshot \-prune \-o \e( \e! \-name "*~" \-print0 \e)|
.B cpio \-pmd0   /dest-dir

.fi
このコマンドは
.B /source-dir
の中身を
.B /dest-dir
にコピーするが、その際
.B .snapshot
という名前のファイルやディレクトリ (及び、そのディレクトリ内のすべて) を
除外する。さらにこのコマンドは、名前の末尾に
.B ~
が付くファイルやディレクトリも除外するが、そうしたディレクトリの
中身については除外の対象にしない。
.B \-prune \-o \e( ... \-print0 \e)
という表現はかなりよく利用される。ここで肝腎なのは、
.B \-prune
の前にある式がマッチする項目は、
.B find
の探索の対象から
.B \-prune
によって取り除かれる (訳注: pruned、枝刈りされる) ということである。
しかし、アクション
.B \-prune
自体は返り値として真を返すので、直後に続く
.B \-o
によって、
探索の対象から取り除かれなかったディレクトリに対してだけ
.B \-o
の右辺の評価が行われることになる (探索の対象から取り除かれた
ディレクトリの中身は処理の対象にすらならないので、そうしたものは
もう関係がない)。
.B \-o
の右辺の式がカッコで囲まれているのは、見やすくするためにすぎない。
アクション
.B \-print0
が行われるのは、
.B \-prune
が適用されなかった項目のみであることを強調しているわけだ。
述語間のデフォルトの結合は and であり、and 条件の結合は
.BR \-o
よりも強いから、カッコがあってもデフォルトの動作と同じなのだが、
カッコを使うと、何をやっているかがわかりやすくなる。

.P
.nf
.B find repo/ -exec test -d {}/.svn -o -d {}/.git -o -d {}/CVS \e\; \e
.B -print -prune
.fi

以下のようなプロジェクトのディレクトリとそれに関連する
SCM (ソースコード管理システム) の管理用ディレクトリがある場合に、
プロジェクトのルートを効率的に検索する。

.nf
.B repo/project1/CVS
.B repo/gnu/project2/.svn
.B repo/gnu/project3/.svn
.B repo/gnu/project3/src/.svn
.B repo/project4/.git

.fi
この例では、
.B \-prune
を使うことによって、すでにプロジェクトのルートであることがわかった
ディレクトリ以下で不必要な探索をしないですませている (たとえば、
project3/src は探索しないが、それは project3/.svn がすでに見つかって
いるからである)。それでいて、同格のディレクトリ (たとえば、
project2 と project3) はきちんと見つかるようにしている。

.SH "終了ステータス"
.PP
.B find
は、すべてのファイルを問題なく処理できれば、ステータス 0 で終了する。
エラーが起きた場合の終了ステータスは、1 以上である。ここではあえて
ごく大雑把な言い方をしているが、返り値が 0 以外だった場合は、
.B find
が出した結果を正しいと思い込まない方がよいだろう。

.SH "関連項目"
\fBlocate\fP(1), \fBlocatedb\fP(5), \fBupdatedb\fP(1), \fBxargs\fP(1),
\fBchmod\fP(1), \fBfnmatch\fP(3), \fBregex\fP(7), \fBstat\fP(2),
\fBlstat\fP(2), \fBls\fP(1), \fBprintf\fP(3), \fBstrftime\fP(3),
\fBctime\fP(3), \fBFinding Files\fP (on-line in Info, or printed).
.SH "履歴"
findutils-4.2.2 以来、ファイル名のパターンに使われたシェルのメタ文字
(`*', `?', `[]' など) は、先頭の  `.' にマッチする。これは、
IEEE POSIX interpretation 126 がそう要求しているからである。
.P
.B \-perm +MODE
という書き方は findutils-4.2.21 で非推奨になった。
.B \-perm /MODE
を使用する方をお勧めする。
findutils-4.3.3 以来、
.B \-perm /000
はどんなファイルにもマッチしないではなく、すべてのファイルにマッチする
になっている。
.P
ナノ秒まで表現するタイムスタンプは findutils-4.3.3 で実装された。
.P
findutils-4.3.11 以来、アクション
.B \-delete
は、実行に失敗すると、
.B find
の終了ステータスを 0 以外の値に設定する。とは言え、
.B \-delete
に失敗したとき、
.B find
が即座に終了してしまうわけではない。以前のバージョンでは、
.B \-delete
が実行に失敗しても、
.B find
の終了ステータスは影響を受けなかった。
.TS
l l l .
Feature	Added in	Also occurs in 
\-newerXY	4.3.3	BSD
\-D	4.3.1
\-O	4.3.1
\-readable	4.3.0
\-writable	4.3.0
\-executable	4.3.0
\-regextype	4.2.24
\-exec ... +	4.2.12	POSIX
\-execdir	4.2.12	BSD
\-okdir	4.2.12
\-samefile	4.2.11
\-H	4.2.5	POSIX
\-L	4.2.5	POSIX
\-P	4.2.5	BSD
\-delete	4.2.3	
\-quit	4.2.3
\-d	4.2.3	BSD
\-wholename	4.2.0
\-iwholename	4.2.0
\-ignore_readdir_race	4.2.0
\-fls	4.0
\-ilname	3.8
\-iname	3.8
\-ipath	3.8
\-iregex	3.8
.TE
.SH "バグにあらず"
.nf
.B $ find . \-name *.c \-print
find: paths must precede expression
Usage: find [\-H] [\-L] [\-P] [\-Olevel] [\-D help|tree|search|stat|rates|opt|exec] [path...] [expression]
.fi
.P
こうしたエラーが起きる原因は、
.I *.c
がシェルによって展開されて、
.B find
が実際に受け取るコマンドラインが、たとえば次のようなものに
なってしまうからである。
.nf

.B find . \-name bigram.c code.c frcode.c locate.c \-print

.fi
当然ながら、こんなコマンドがうまく動くわけがない。書き方を改めて、
パターンを引用符で囲むか、ワイルドカードをエスケープするべきだ。
.nf

.B $ find . \-name \e*.c \-print
.fi

.SH "バグ"
.P
POSIX 標準が
.B find
について規定している動作にはセキュリティ上の問題があるが、
それはその動作自体に内在する問題なので、修正することができない。
一例を挙げると、アクション
.B \-exec
は本質的に安全ではない。だから、
.B \-execdir
の方を使うべきなのだ。
より詳しい情報については、\fBFinding Files\fP を参照していただきたい。
.P
環境変数
.B  LC_COLLATE
はアクション
.B \-ok
にまったく影響を及ぼさない (訳注: 環境変数 \fBLC_COLLATE\fR の説明では
「この変数はアクション \fB\-ok\fR に対する応答の解釈にも影響を及ぼす」
と述べている)。
.P
バグ報告の最善の方法は、
http://savannah.gnu.org/bugs/?group=findutils
にある書式を使用することだ。そうすれば、問題解決の進行状態を
追うことができるからである。\fBfind\fP(1) や
findutils パッケージ全般についてのその他のご意見は、
.I bug\-findutils
メーリングリストにお出しになればよい。メーリングリストに参加するには、
.IR bug\-findutils\-request@gnu.org
宛に E メールを送っていただきたい。

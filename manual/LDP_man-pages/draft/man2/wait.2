.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1993 by Thomas Koenig <ig25@rz.uni-karlsruhe.de>
.\" and Copyright (c) 2004 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\"
.\" Modified Sat Jul 24 13:30:06 1993 by Rik Faith <faith@cs.unc.edu>
.\" Modified Sun Aug 21 17:42:42 1994 by Rik Faith <faith@cs.unc.edu>
.\"          (Thanks to Koen Holtman <koen@win.tue.nl>)
.\" Modified Wed May 17 15:54:12 1995 by Rik Faith <faith@cs.unc.edu>
.\"           To remove *'s from status in macros (Thanks to Michael Shields).
.\" Modified as suggested by Nick Duffek <nsd@bbc.com>, aeb, 960426
.\" Modified Mon Jun 23 14:09:52 1997 by aeb - add EINTR.
.\" Modified Thu Nov 26 02:12:45 1998 by aeb - add SIGCHLD stuff.
.\" Modified Mon Jul 24 21:37:38 2000 by David A. Wheeler
.\"          <dwheeler@dwheeler.com> - noted thread issues.
.\" Modified 26 Jun 01 by Michael Kerrisk
.\"          Added __WCLONE, __WALL, and __WNOTHREAD descriptions
.\" Modified 2001-09-25, aeb
.\" Modified 26 Jun 01 by Michael Kerrisk, <mtk.manpages@gmail.com>
.\"	Updated notes on setting disposition of SIGCHLD to SIG_IGN
.\" 2004-11-11, mtk
.\"	Added waitid(2); added WCONTINUED and WIFCONTINUED()
.\"	Added text on SA_NOCLDSTOP
.\"	Updated discussion of SA_NOCLDWAIT to reflect 2.6 behavior
.\"	Much other text rewritten
.\" 2005-05-10, mtk, __W* flags can't be used with waitid()
.\" 2008-07-04, mtk, removed erroneous text about SA_NOCLDSTOP
.\"
.\" Japanese Version Copyright (c) 1997 HANATAKA Shinya all rights reserved.
.\" Japanese Version Copyright (c) 2005 Akihiro MOTOKI all rights reserved.
.\" Translated 1997-03-04, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 2000-09-23, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 2001-06-25, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2001-10-15, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2001-12-13, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2002-10-21, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2003-01-27, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2003-09-12, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-03-19, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-12-26, Akihiro MOTOKI
.\" Updated 2008-07-31, Akihiro MOTOKI, LDP v3.05
.\"
.\"WORD:	signal handling		シグナル処理
.\"WORD:	suspend			停止(suspend)
.\"WORD:	zombie			ゾンビ(zombie)
.\"WORD:	child process		子プロセス
.\"WORD:	process group		プロセス・グループ
.\"WORD:	process group ID	プロセス・グループID
.\"WORD:	stop			停止(stop)
.\"WORD:	effective user ID	実効ユーザーID
.\"WORD:	block			禁止(block)
.\"
.TH WAIT 2 2010-09-26 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O wait, waitpid, waitid \- wait for process to change state
wait, waitpid, waitid \- プロセスの状態変化を待つ
.\"O .SH SYNOPSIS
.SH 書式
.B #include <sys/types.h>
.br
.B #include <sys/wait.h>
.sp
.BI "pid_t wait(int *" "status" );

.BI "pid_t waitpid(pid_t " pid ", int *" status ", int " options );

.BI "int waitid(idtype_t " idtype ", id_t " id \
", siginfo_t *" infop ", int " options );
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.ad l
.PD 0
.BR waitid ():
.RS 4
_SVID_SOURCE ||
_XOPEN_SOURCE\ >=\ 500 ||
_XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
.br
.\"O || /* Since glibc 2.12: */ _POSIX_C_SOURCE\ >=\ 200809L
|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\ >=\ 200809L
.RE
.PD
.ad
.\"O .SH DESCRIPTION
.SH 説明
.\"O All of these system calls are used to wait for state changes
.\"O in a child of the calling process, and obtain information
.\"O about the child whose state has changed.
.\"O A state change is considered to be: the child terminated;
.\"O the child was stopped by a signal; or the child was resumed by a signal.
.\"O In the case of a terminated child, performing a wait allows
.\"O the system to release the resources associated with the child;
.\"O if a wait is not performed, then the terminated child remains in
.\"O a "zombie" state (see NOTES below).
これらのシステムコールはいずれも、呼び出し元プロセスの子プロセスの
状態変化を待ち、状態が変化したその子プロセスの情報を取得するのに
使用される。
状態変化とは以下のいずれかである:
子プロセスの終了、シグナルによる子プロセスの停止、
シグナルによる子プロセスの再開。
子プロセスが終了した場合は、wait を実行することで、
システムがその子プロセスに関連するリソースを解放できるようになる。
wait が実行されなかった場合には、終了した子プロセスは
「ゾンビ」状態で残り続ける (下記の注意の章を参照のこと)。

.\"O If a child has already changed state, then these calls return immediately.
.\"O Otherwise they block until either a child changes state or
.\"O a signal handler interrupts the call (assuming that system calls
.\"O are not automatically restarted using the
.\"O .B SA_RESTART
.\"O flag of
.\"O .BR sigaction (2)).
.\"O In the remainder of this page, a child whose state has changed
.\"O and which has not yet been waited upon by one of these system
.\"O calls is termed
.\"O .IR waitable .
子プロセスの状態変化がすでに発生していた場合、これらのコールは
すぐに復帰する。それ以外の場合は、子プロセスの状態変化が起こるか、
シグナルハンドラによりシステムコールが中断されるまで、
停止 (block) する (後者は、
.BR sigaction (2)
の
.B SA_RESTART
フラグによりシステムコールが自動的に再スタートするようになっていない
場合の動作である)。
以下の説明では、状態変化が起こったがこれらのシステムコールのいずれかに
よって待たれていない子プロセスを
.I waitable
(待ち可能) と呼ぶ。
.\"O .SS "wait() and waitpid()"
.SS "wait() と waitpid()"
.\"O The
.\"O .BR wait ()
.\"O system call suspends execution of the calling process until one of its
.\"O children terminates.
.\"O The call
.\"O .I wait(&status)
.\"O is equivalent to:
.\"O .nf
.\"O
.\"O     watpid(\-1, &status, 0);
.\"O .fi
.BR wait ()
システムコールは、子プロセスのいずれかが終了するまで
呼び出し元のプロセスの実行を一時停止する。
以下の二つの呼び出しは等価である:
.nf

    wait(&status);

    waitpid(\-1, &status, 0);
.fi

.\"O The
.\"O .BR waitpid ()
.\"O system call suspends execution of the calling process until a
.\"O child specified by
.\"O .I pid
.\"O argument has changed state.
.\"O By default,
.\"O .BR waitpid ()
.\"O waits only for terminated children, but this behavior is modifiable
.\"O via the
.\"O .I options
.\"O argument, as described below.
.BR waitpid ()
システムコールは、
.I pid
引き数で指定した子プロセスの状態変化が起こるまで、
呼び出し元のプロセスの実行を一時停止する。デフォルトでは、
.BR waitpid ()
は子プロセスの終了だけを待つが、この動作は
.I options
引き数により変更可能である。

.\"O The value of
.\"O .I pid
.\"O can be:
.I pid
に指定できる値は以下の通り:
.IP "< \-1"
.\"O meaning wait for any child process whose process group ID is
.\"O equal to the absolute value of
.\"O .IR pid .
プロセスグループID が
.I pid
の絶対値に等しい子プロセスのいずれかが終了するまでを待つ。
.IP \-1
.\"O meaning wait for any child process.
子プロセスのどれかが終了するまで待つ。
.IP 0
.\"O meaning wait for any child process whose process group ID is
.\"O equal to that of the calling process.
プロセスグループID が呼び出したプロセスのものと等しい
子プロセスを待つ。
.IP "> 0"
.\"O meaning wait for the child whose process ID is equal to the
.\"O value of
.\"O .IR pid .
プロセスID が
.I pid
に等しい子プロセスを待つ。
.PP
.\"O The value of
.\"O .I options
.\"O is an OR of zero or more of the following constants:
.I options
の値は次の定数の 0 個以上の論理和である:
.TP 12
.B WNOHANG
.\"O return immediately if no child has exited.
状態変化が起こった子プロセスがない場合にすぐに復帰する。
.TP
.B WUNTRACED
.\"O also return if a child has stopped
.\"O (but not traced via
.\"O .BR ptrace (2)).
.\"O Status for
.\"O .I traced
.\"O children which have stopped is provided
.\"O even if this option is not specified.
子プロセスが停止した場合にも復帰する (子プロセスが
.BR ptrace (2)
でトレースされている場合は除く)。
このオプションが指定されていない場合でも、停止したプロセスが
「トレース (traced)」されていれば、子プロセスの状態が報告される。
.TP
.\"O .BR WCONTINUED " (Since Linux 2.6.10)"
.BR WCONTINUED " (Linux 2.6.10 以降)"
.\"O also return if a stopped child has been resumed by delivery of
.\"O .BR SIGCONT .
停止した子プロセスが
.B SIGCONT
の配送により再開した場合にも復帰する。
.PP
.\"O (For Linux-only options, see below.)
(Linux 専用オプションについては後述する)
.PP
.\"O If
.\"O .I status
.\"O is not NULL,
.\"O .BR wait ()
.\"O and
.\"O .BR waitpid ()
.\"O store status information in the \fIint\fP to which it points.
.I status
が NULL でなければ、
.BR wait ()
や
.BR waitpid ()
は
.I status
で指す \fIint\fP に状態情報を格納する。
.\"O This integer can be inspected with the following macros (which
.\"O take the integer itself as an argument, not a pointer to it,
.\"O as is done in
.\"O .BR wait ()
.\"O and
.\"O .BR waitpid ()!):
この整数は以下のマクロを使って検査できる。
(これらのマクロの引き数には、
.BR wait ()
や
.BR waitpid ()
が書き込んだ整数そのものを指定する。ポインタではない!)
.TP
.BI WIFEXITED( status )
.\"O returns true if the child terminated normally, that is,
.\"O by calling
.\"O .BR exit (3)
.\"O or
.\"O .BR _exit (2),
.\"O or by returning from main().
子プロセスが正常に終了した場合に真を返す。
「正常に」とは、
.BR exit (3)
か
.BR _exit (2)
が呼び出された場合、もしくは
main() から復帰した場合である。
.TP
.BI WEXITSTATUS( status )
.\"O returns the exit status of the child.
.\"O This consists of the least significant 8 bits of the
.\"O .I status
.\"O argument that the child specified in a call to
.\"O .BR exit (3)
.\"O or
.\"O .BR _exit (2)
.\"O or as the argument for a return statement in main().
.\"O This macro should only be employed if
.\"O .B WIFEXITED
.\"O returned true.
子プロセスの終了ステータスを返す。
終了ステータスは
.I status
引き数の下位 8ビットで構成されており、
.BR exit (3)
や
.BR _exit (2)
の呼び出し時に渡された値、もしくは main() の return 文の
引き数として指定された値である。
このマクロを使用するのは
.B WIFEXITED
が真を返した場合だけにすべきである。
.TP
.BI WIFSIGNALED( status )
.\"O returns true if the child process was terminated by a signal.
子プロセスがシグナルにより終了した場合に真を返す。
.TP
.BI WTERMSIG( status )
.\"O returns the number of the signal that caused the child process to
.\"O terminate.
.\"O This macro should only be employed if
.\"O .B WIFSIGNALED
.\"O returned true.
子プロセス終了の原因となったシグナルの番号を返す。
このマクロを使用するのは
.B WIFSIGNALED
が真を返した場合だけにすべきである。
.TP
.BI WCOREDUMP( status )
.\"O returns true if the child produced a core dump.
.\"O This macro should only be employed if
.\"O .B WIFSIGNALED
.\"O returned true.
.\"O This macro is not specified in POSIX.1-2001 and is not available on
.\"O some UNIX implementations (e.g., AIX, SunOS).
.\"O Only use this enclosed in #ifdef WCOREDUMP ... #endif.
子プロセスがコアダンプを生成した場合に真を返す。
このマクロを使用するのは
.B WIFSIGNALED
が真を返した場合だけにすべきである。
このマクロは POSIX.1-2001 では規定されておらず、
(AIX, SunOS などの) いくつかの UNIX の実装では利用できない。
必ず #ifdef WCOREDUMP ... #endif で括って使用すること。
.TP
.BI WIFSTOPPED( status )
.\"O returns true if the child process was stopped by delivery of a signal;
.\"O this is only possible if the call was done using
.\"O .B WUNTRACED
.\"O or when the child is being traced (see
.\"O .BR ptrace (2)).
子プロセスがシグナルの配送により停止した場合に真を返す。
これが真になるのは、システムコールが
.B WUNTRACED
を指定して呼び出された場合か、子プロセスがトレースされている場合
.RB ( ptrace (2)
参照) だけである。
.TP
.BI WSTOPSIG( status )
.\"O returns the number of the signal which caused the child to stop.
.\"O This macro should only be employed if
.\"O .B WIFSTOPPED
.\"O returned true.
子プロセスを停止させたシグナルの番号を返す。
このマクロを使用するのは
.B WIFSTOPPED
が 0 以外を返した場合だけにすべきである。
.TP
.BI WIFCONTINUED( status )
.\"O (since Linux 2.6.10)
(Linux 2.6.10 以降)
.\"O returns true if the child process was resumed by delivery of
.\"O .BR SIGCONT .
子プロセスが
.B SIGCONT
の配送により再開した場合に真を返す。
.SS "waitid()"
.\"O The
.\"O .BR waitid ()
.\"O system call (available since Linux 2.6.9) provides more precise
.\"O control over which child state changes to wait for.
.BR waitid ()
システムコール (Linux 2.6.9 以降で利用可能) を使うと、
子プロセスのどの状態変化を待つかについてより細かな制御ができる。

.\"O The
.\"O .I idtype
.\"O and
.\"O .I id
.\"O arguments select the child(ren) to wait for, as follows:
引き数
.I idtype
と
.I id
でどの子プロセスを待つかを選択する:
.IP "\fIidtype\fP == \fBP_PID\fP"
.\"O Wait for the child whose process ID matches
.\"O .IR id .
プロセスID が
.I id
と一致する子プロセスを待つ。
.IP "\fIidtype\fP == \fBP_PGID\fP"
.\"O Wait for any child whose process group ID matches
.\"O .IR id .
プロセスグループID が
.I id
と一致する子プロセスを待つ。
.IP "\fIidtype\fP == \fBP_ALL\fP"
.\"O Wait for any child;
.\"O .I id
.\"O is ignored.
子プロセス全部を対象に待つ。
.I id
は無視される。
.PP
.\"O The child state changes to wait for are specified by ORing
.\"O one or more of the following flags in
.\"O .IR options :
子プロセスのどの状態変化を待つかは以下のフラグで指定する
.RI ( options
には 1個以上のフラグの論理和をとって指定する):
.TP 12
.B WEXITED
.\"O Wait for children that have terminated.
子プロセスの終了を待つ。
.TP
.B WSTOPPED
.\"O Wait for children that have been stopped by delivery of a signal.
子プロセスがシグナルの配送により停止するのを待つ。
.TP
.B WCONTINUED
.\"O Wait for (previously stopped) children that have been
.\"O resumed by delivery of
.\"O .BR SIGCONT .
(停止していた) 子プロセスが
.B SIGCONT
が配送されて再開するのを待つ。
.PP
.\"O The following flags may additionally be ORed in
.\"O .IR options :
さらに以下のフラグを論理和の形で
.I options
に指定できる:
.TP 12
.B WNOHANG
.\"O As for
.\"O .BR waitpid ().
.BR waitpid ()
と同様。
.TP
.B WNOWAIT
.\"O Leave the child in a waitable state; a later wait call
.\"O can be used to again retrieve the child status information.
waitable 状態のプロセスをそのままにする。この後で wait コールを
使って、同じ子プロセスの状態情報をもう一度取得することができる。
.PP
.\"O Upon successful return,
.\"O .BR waitid ()
.\"O fills in the following fields of the
.\"O .I siginfo_t
.\"O structure pointed to by
.\"O .IR infop :
成功した場合には、
.BR waitid ()
は
.I infop
が指す
.I siginfo_t
構造体の以下のフィールドを設定する:
.TP 12
\fIsi_pid\fP
.\"O The process ID of the child.
子プロセスのプロセスID。
.TP
\fIsi_uid\fP
.\"O The real user ID of the child.
.\"O (This field is not set on most other implementations.)
子プロセスの実ユーザID
(このフィールドは他のほとんどの実装では設定されない)。
.TP
\fIsi_signo\fP
.\"O Always set to
.\"O .BR SIGCHLD .
常に
.B SIGCHLD
が設定される。
.TP
\fIsi_status\fP
.\"O Either the exit status of the child, as given to
.\"O .BR _exit (2)
.\"O (or
.\"O .BR exit (3)),
.\"O or the signal that caused the child to terminate, stop, or continue.
.\"O The
.\"O .I si_code
.\"O field can be used to determine how to interpret this field.
.BR _exit (2)
(か
.BR exit (3))
に指定された子プロセスの終了ステータス、もしくは
子プロセスの終了、停止、再開の原因となったシグナルが設定される。
このフィールドをどう解釈するかは、
.I si_code
フィールドを参照して決めることができる。
.TP
\fIsi_code\fP
.\"O Set to one of:
.\"O .B CLD_EXITED
.\"O (child called
.\"O .BR _exit (2));
.\"O .B CLD_KILLED
.\"O (child killed by signal);
.\"O .B CLD_DUMPED
.\"O (child killed by signal, and dumped core);
.\"O .B CLD_STOPPED
.\"O (child stopped by signal);
.\"O .B CLD_TRAPPED
.\"O (traced child has trapped); or
.\"O .B CLD_CONTINUED
.\"O (child continued by
.\"O .BR SIGCONT ).
以下のいずれかが設定される:
.B CLD_EXITED
(子プロセスが
.BR _exit (2)
を呼び出した);
.B CLD_KILLED
(シグナルにより子プロセスが kill された);
.B CLD_DUMPED
(シグナルにより子プロセスが kill され、コア・ダンプが行われた);
.B CLD_STOPPED
(シグナルにより子プロセスが停止した);
.BR CLD_TRAPPED
(トレースされていた子プロセスがトラップを受信した);
.B CLD_CONTINUED
.RB ( SIGCONT
により子プロセスが再開された)。
.PP
.\"O If
.\"O .B WNOHANG
.\"O was specified in
.\"O .I options
.\"O and there were no children in a waitable state, then
.\"O .BR waitid ()
.\"O returns 0 immediately and
.\"O the state of the
.\"O .I siginfo_t
.\"O structure pointed to by
.\"O .I infop
.\"O is unspecified.
.B WNOHANG
が
.I options
に指定されていて、
waitable 状態の子プロセスがなかった場合には、
.BR waitid ()
はすぐに 0 を返す。このとき、
.I infop
が指す
.I siginfo_t
構造体の内容は不定である。
.\"O .\" POSIX.1-2001 leaves this possibility unspecified; most
.\"O .\" implementations (including Linux) zero out the structure
.\"O .\" in this case, but at at least one implementation (AIX 5.1)
.\"O .\" does not -- MTK Nov 04
.\" POSIX.1-2001 では、不定の可能性を残している。
.\" (Linux を含む) ほとんどの実装では、この場合に構造体を 0 で埋めるが、
.\" 少なくとも一つの実装 (AIX 5.1) ではそうならない。 -- MTK Nov 04
.\"O To distinguish this case from that where a child was in a
.\"O waitable state, zero out the
.\"O .I si_pid
.\"O field before the call and check for a nonzero value in this field
.\"O after the call returns.
この場合を waitable 状態の子プロセスがあった場合と区別するには、
.BR waitid ()
を呼び出す前に
.I si_pid
を 0 にしておき、コールが復帰した後でこのフィールドが 0 以外の値かどうか
をチェックすればよい。
.\"O .SH "RETURN VALUE"
.SH 返り値
.BR wait ():
.\"O on success, returns the process ID of the terminated child;
.\"O on error, \-1 is returned.
成功すると、終了した子プロセスのプロセスID を返す。
エラーの場合 \-1 を返す。

.BR waitpid ():
.\"O on success, returns the process ID of the child whose state has changed;
.\"O if
.\"O .B WNOHANG
.\"O was specified and one or more child(ren) specified by
.\"O.I pid
.\"O exist, but have not yet changed state, then 0 is returned.
.\"O On error, \-1 is returned.
成功すると、状態が変化した子プロセスのプロセスID を返す。
.B WNOHANG
が指定されていて、
.I pid
で指示された子プロセスが一つ以上存在するが、どの子プロセスでも
状態変化が起こっていなかった場合は、 0 を返す。
エラーの場合 \-1 を返す。

.BR waitid ():
.\"O returns 0 on success or
.\"O if
.\"O .B WNOHANG
.\"O was specified and no child(ren) specified by
.\"O .I id
.\"O has yet changed state;
.\"O on error, \-1 is returned.
成功すると 0 を返す。
.B WNOHANG
が指定されていて、
.I pid
で指示された子プロセスで状態変化が起こっていなかった場合にも
0 を返す。
エラーの場合 \-1 を返す。
.\" FIXME: As reported by Vegard Nossum, if infop is NULL, then waitid()
.\" returns the PID of the child.  Either this is a bug, or it is intended
.\" behavior that needs to be documented.  See my Jan 2009 LKML mail
.\" "waitid() return value strangeness when infop is NULL".
.\"O Each of these calls sets
.\"O .I errno
.\"O to an appropriate value in the case of an error.
エラーの場合、これらのシステムコールはいずれも
.I errno
に適切な値を設定する。
.\"O .SH ERRORS
.SH エラー
.TP
.\"O .B ECHILD
.\"O (for
.\"O .BR wait ())
.B ECHILD
.RB ( wait ()
の場合)
.\"O The calling process does not have any unwaited-for children.
呼び出し元プロセスには、wait を行っていない子プロセスはない。
.TP
.\"O .B ECHILD
.\"O (for
.\"O .BR waitpid ()
.\"O or
.\"O .BR waitid ())
.B ECHILD
.RB ( waitpid ()
か
.BR waitid ()
の場合)
.\"O The process specified by
.\"O .I pid
.\"O .RB ( waitpid ())
.\"O or
.\"O .I idtype
.\"O and
.\"O .I id
.\"O .RB ( waitid ())
.\"O does not exist or is not a child of the calling process.
.\"O (This can happen for one's own child if the action for
.\"O .B SIGCHLD
.\"O is set to
.\"O .BR SIG_IGN .
.\"O See also the \fILinux Notes\fP section about threads.)
.I pid
.RB ( waitpid ())
か
.I idtype
と
.I id
.RB ( waitid ())
で指定したプロセスが存在しないか、呼び出し元プロセスの子プロセスでない
.RB ( SIGCHLD
の動作に
.B SIG_IGN
を設定した場合には、自分自身の子プロセスでも起こりうる。
スレッドに関しては「Linux での注意」の節も参照すること)。
.TP
.B EINTR
.\"O .B WNOHANG
.\"O was not set and an unblocked signal or a
.\"O .B SIGCHLD
.\"O was caught; see.
.\"O .BR signal (7).
.B WNOHANG
が設定されておらず、禁止 (block) されていないシグナルや
.B SIGCHLD
を受信した。
.BR signal (7)
参照。
.TP
.B EINVAL
.\"O The
.\"O .I options
.\"O argument was invalid.
.I options
引き数が不正である。
.\"O .SH "CONFORMING TO"
.SH 準拠
SVr4, 4.3BSD, POSIX.1-2001.
.\"O .SH NOTES
.SH 注意
.\"O A child that terminates, but has not been waited for becomes a "zombie".
.\"O The kernel maintains a minimal set of information about the zombie
.\"O process (PID, termination status, resource usage information)
.\"O in order to allow the parent to later perform a wait to obtain
.\"O information about the child.
.\"O As long as a zombie is not removed from the system via a wait,
.\"O it will consume a slot in the kernel process table, and if
.\"O this table fills, it will not be possible to create further processes.
.\"O If a parent process terminates, then its "zombie" children (if any)
.\"O are adopted by
.\"O .BR init (8),
.\"O which automatically performs a wait to remove the zombies.
終了したが、wait されていない子プロセスは「ゾンビ」になる。
後で親プロセスが wait を実行して子プロセスについての情報を取得できるように、
カーネルはゾンビプロセスについて最小限の情報 (PID、終了ステータス、
リソース使用状況) を保持する。
ゾンビプロセスは、 wait によってシステムから削除されない限り、
カーネルのプロセステーブルの 1 エントリを消費する。このプロセステーブルが
一杯になると、新たにプロセスを作ることができなくなる。
親プロセスが終了すると、その親プロセスの「ゾンビ」の
子プロセスは (もしあれば)
.BR init (8)
の養子となる。
.BR init (8)
は wait を自動的に実行し、ゾンビを削除する。

.\"O POSIX.1-2001 specifies that if the disposition of
.\"O .B SIGCHLD
.\"O is set to
.\"O .B SIG_IGN
.\"O or the
.\"O .B SA_NOCLDWAIT
.\"O flag is set for
.\"O .B SIGCHLD
.\"O (see
.\"O .BR sigaction (2)),
.\"O then children that terminate do not become zombies and a call to
.\"O .BR wait ()
.\"O or
.\"O .BR waitpid ()
.\"O will block until all children have terminated, and then fail with
.\"O .I errno
.\"O set to
.\"O .BR ECHILD .
POSIX.1-2001 では以下のように規定されている。
.B SIGCHLD
の動作が
.B SIG_IGN
に設定されたか、
.B SIGCHLD
に対して
.B SA_NOCLDWAIT
フラグが設定された場合
.RB ( sigaction (2)
参照)、終了した子プロセスはゾンビにはならず、
.BR wait ()
や
.BR waitpid ()
の呼び出しは全ての子プロセスが終了するまで停止し、
子プロセスが全部終了した後
.I errno
に
.B ECHILD
を設定して失敗する。
.\"O (The original POSIX standard left the behavior of setting
.\"O .B SIGCHLD
.\"O to
.\"O .B SIG_IGN
.\"O unspecified.
.\"O Note that even though the default disposition of
.\"O .B SIGCHLD
.\"O is "ignore", explicitly setting the disposition to
.\"O .B SIG_IGN
.\"O results in different treatment of zombie process children.)
(もともとの POSIX 標準は
.B SIGCHLD
に
.B SIG_IGN
を設定した場合の振る舞いを未規定のままにしている。
.B SIGCHLD
のデフォルトの動作が「無視」であるにもかかわらず、
.B SIGCHLD
の動作として
.B SIG_IGN
を明示的に設定した場合にはゾンビプロセスの子プロセスの扱いが
異なる点に注意すること。)
.\"O Linux 2.6 conforms to this specification.
.\"O However, Linux 2.4 (and earlier) does not:
Linux 2.6 はこの仕様に準拠している。
しかし、Linux 2.4 (とそれ以前のバージョン) はそうではない:
.\"O if a
.\"O .BR wait ()
.\"O or
.\"O .BR waitpid ()
.\"O call is made while
.\"O .B SIGCHLD
.\"O is being ignored, the call behaves just as though
.\"O .B SIGCHLD
.\"O were not being ignored, that is, the call blocks until the next child
.\"O terminates and then returns the process ID and status of that child.
.B SIGCHLD
が無視される状態で
.BR wait ()
または
.BR waitpid ()
が呼び出された場合、
.B SIGCHLD
が無視されていないかのように振る舞う。
つまり、呼び出しによって次の子プロセスの終了までブロックされ、
終了した子プロセスの PID と状態が返される。
.\"O .SS Linux Notes
.SS Linux での注意
.\"O In the Linux kernel, a kernel-scheduled thread is not a distinct
.\"O construct from a process.
.\"O Instead, a thread is simply a process
.\"O that is created using the Linux-unique
.\"O .BR clone (2)
.\"O system call; other routines such as the portable
.\"O .BR pthread_create (3)
.\"O call are implemented using
.\"O .BR clone (2);
.\"O they cannot be used with
.\"O .BR waitid ():
Linux カーネルでは、カーネルによってスケジュールされるスレッドは
プロセスと明確に区別できる構成要素ではない。スレッドは Linux 固有の
.BR clone (2)
システムコールを使用して生成されるプロセスに過ぎない。
移植性のある
.BR pthread_create (3)
コールのような他のルーチンは
.BR clone (2)
を使用して実装されている;
これらでは
.BR waitid ()
を使うことはできない。
.\"O Before Linux 2.4, a thread was just a special case of a process,
.\"O and as a consequence one thread could not wait on the children
.\"O of another thread, even when the latter belongs to the same thread group.
Linux 2.4 より前では、スレッドは単に特殊なプロセスであったので、
例え同じスレッドグループであっても、
あるスレッドが別のスレッドの子プロセスが終了するのを待つことは出来なかった。
.\"O However, POSIX prescribes such functionality, and since Linux 2.4
.\"O a thread can, and by default will, wait on children of other threads
.\"O in the same thread group.
しかし、POSIX ではこのような機能を規定しており、
Linux 2.4 以降では、あるスレッドが同じスレッドグループの他のスレッドの
子プロセスが終了するのを待つことができるようになった。
そして将来はこれがデフォルトの動作になるであろう。
.LP
.\"O The following Linux-specific
.\"O .I options
.\"O are for use with children created using
.\"O .BR clone (2).
.BR clone (2)
を用いて作られた子プロセスには、以下の Linux 固有の
.I options
が使用できる。
.TP
.B __WCLONE
.\" since 0.99pl10
.\"O Wait for "clone" children only.
.\"O If omitted then wait
.\"O for "non-clone" children only.
.\"O (A "clone" child is one
.\"O which delivers no signal, or a signal other than
.\"O .B SIGCHLD
.\"O to its parent upon termination.)
"clone" な子プロセスだけを待つ。
指定されなかった場合は非 "clone" な子プロセスだけを待つ
("clone" な子プロセスは、終了時に親プロセスへ全くシグナルを送らないか、
.B SIGCHLD
以外のシグナルを送る)。
.\"O This option is ignored if
.\"O .B __WALL
.\"O is also specified.
このオプションは
.B __WALL
も指定された場合は無視される。
.TP
.\"O .BR __WALL " (since Linux 2.4)"
.BR __WALL " (Linux 2.4 以降)"
.\" since patch-2.3.48
.\"O Wait for all children, regardless of
.\"O type ("clone" or "non-clone").
"clone" であるかないかに関わらず、
全ての子プロセスを待つ。
.TP
.\"O .BR __WNOTHREAD " (since Linux 2.4)"
.BR __WNOTHREAD " (Linux 2.4 以降)"
.\" since patch-2.4.0-test8
.\"O Do not wait for children of other threads in
.\"O the same thread group.
.\"O This was the default before Linux 2.4.
同じスレッドグループの他のスレッドの子プロセスは待たない。
Linux 2.4 より前ではデフォルトであった。
.\"O .SH EXAMPLE
.SH 例
.\"O .\" fork.2 refers to this example program.
.\" fork.2 もこのサンプルプログラムを参照している。
.\"O The following program demonstrates the use of
.\"O .BR fork (2)
.\"O and
.\"O .BR waitpid ().
.\"O The program creates a child process.
.\"O If no command-line argument is supplied to the program,
.\"O then the child suspends its execution using
.\"O .BR pause (2),
.\"O to allow the user to send signals to the child.
.\"O Otherwise, if a command-line argument is supplied,
.\"O then the child exits immediately,
.\"O using the integer supplied on the command line as the exit status.
.\"O The parent process executes a loop that monitors the child using
.\"O .BR waitpid (),
.\"O and uses the W*() macros described above to analyze the wait status value.
以下のプログラムは、
.BR fork (2)
と
.BR waitpid ()
の使用方法の例を示している。
このプログラムでは子プロセスを生成する。
コマンドライン引き数が指定されなかったときは、
子プロセスは
.BR pause (2)
を使ってその実行を一時停止し、ユーザがその子プロセスに
シグナルを送信できるようにする。
コマンドライン引き数が指定された場合は、
子プロセスは直ちに終了し、
コマンドラインで指定された整数を終了ステータスとして使用する。
親プロセスは、
.BR waitpid ()
を使って子プロセスを監視し、
wait のステータス値を上記の W*() マクロを使って解析するという
ループを実行する。

.\"O The following shell session demonstrates the use of the program:
下記ののシェル・セッションはプログラムの実行例である:
.in +4n
.nf

.RB "$" " ./a.out &"
Child PID is 32360
[1] 32359
.RB "$" " kill \-STOP 32360"
stopped by signal 19
.RB "$" " kill \-CONT 32360"
continued
.RB "$" " kill \-TERM 32360"
killed by signal 15
[1]+  Done                    ./a.out
$
.fi
.in
.\"O .SS Program source
.SS プログラムのソース
\&
.nf
#include <sys/wait.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>

int
main(int argc, char *argv[])
{
    pid_t cpid, w;
    int status;

    cpid = fork();
    if (cpid == \-1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }

    if (cpid == 0) {            /* Code executed by child */
        printf("Child PID is %ld\\n", (long) getpid());
        if (argc == 1)
            pause();                    /* Wait for signals */
        _exit(atoi(argv[1]));

    } else {                    /* Code executed by parent */
        do {
            w = waitpid(cpid, &status, WUNTRACED | WCONTINUED);
            if (w == \-1) {
                perror("waitpid");
                exit(EXIT_FAILURE);
            }

            if (WIFEXITED(status)) {
                printf("exited, status=%d\\n", WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("killed by signal %d\\n", WTERMSIG(status));
            } else if (WIFSTOPPED(status)) {
                printf("stopped by signal %d\\n", WSTOPSIG(status));
            } else if (WIFCONTINUED(status)) {
                printf("continued\\n");
            }
        } while (!WIFEXITED(status) && !WIFSIGNALED(status));
        exit(EXIT_SUCCESS);
    }
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR _exit (2),
.BR clone (2),
.BR fork (2),
.BR kill (2),
.BR ptrace (2),
.BR sigaction (2),
.BR signal (2),
.BR wait4 (2),
.BR pthread_create (3),
.BR credentials (7),
.BR signal (7)

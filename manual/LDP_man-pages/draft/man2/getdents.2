.\" Copyright (C) 1995 Andries Brouwer (aeb@cwi.nl)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Written 11 June 1995 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 22 July 1995 by Michael Chastain <mec@duracef.shout.net>:
.\"   Derived from 'readdir.2'.
.\" Modified Tue Oct 22 08:11:14 EDT 1996 by Eric S. Raymond <esr@thyrsus.com>
.\"
.\" Japanese Version Copyright (c) 1997 HANATAKA Shinya
.\"         all rights reserved.
.\" Translated Sat Feb 22 20:15:56 JST 1997
.\"         by HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated Sun Oct 12 JST 2003 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated Wed Jul 30 JST 2008 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2009-02-12 by Kentaro Shirakata <argrath@ub32.org>
.\"
.\"WORD:	directory		ディレクトリ
.\"WORD:	entry			エントリ
.\"WORD:	memory area		メモリ領域
.\"WORD:	parameter		パラメーター
.\"WORD:	inode number		inode 番号
.\"WORD:	null			ヌル文字
.\"
.TH GETDENTS 2  2009-07-04 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O getdents \- get directory entries
getdents \- ディレクトリ・エントリを取得する
.\"O .SH SYNOPSIS
.SH 書式
.nf
.BI "int getdents(unsigned int " fd ", struct linux_dirent *" dirp ,
.BI "             unsigned int " count );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O This is not the function you are interested in.
.\"O Look at
.\"O .BR readdir (3)
.\"O for the POSIX conforming C library interface.
.\"O This page documents the bare kernel system call interface.
これはあなたの関心を引くような関数ではない。
POSIX 準拠の C ライブラリインターフェースについては
.BR readdir (3)
を見ること。
このページは、カーネルシステムコールの生のインターフェースについて
記載したものである。
.PP
.\"O The system call
.\"O .BR getdents ()
.\"O reads several
.\"O .I linux_dirent
.\"O structures from the directory
.\"O referred to by the open file descriptor
.\"O .I fd
.\"O into the buffer pointed to by
.\"O .IR dirp .
.\"O The argument
.\"O .I count
.\"O specifies the size of that buffer.
.BR getdents ()
システムコールは、オープン済みのファイル記述子
.I fd
で参照されるディレクトリから
.I linux_dirent
構造体をいくつか読み出し、
.I dirp
が指しているバッファに格納する。
.I count
引き数はそのバッファのサイズを示す。
.PP
.\"O The
.\"O .I linux_dirent
.\"O structure is declared as follows:
.I linux_dirent
構造体は以下のように宣言されている:
.PP
.in +4n
.nf
struct linux_dirent {
    unsigned long  d_ino;     /* Inode number */
    unsigned long  d_off;     /* Offset to next \fIlinux_dirent\fP */
    unsigned short d_reclen;  /* Length of this \fIlinux_dirent\fP */
    char           d_name[];  /* Filename (null-terminated) */
                        /* length is actually (d_reclen \- 2 \-
                           offsetof(struct linux_dirent, d_name) */
    /*
    char           pad;       // Zero padding byte
    char           d_type;    // File type (only since Linux 2.6.4;
                              // offset is (d_reclen \- 1))
    */

}
.fi
.in
.PP
.\"O .I d_ino
.\"O is an inode number.
.\"O .I d_off
.\"O is the distance from the start of the directory to the start of the next
.\"O .IR linux_dirent .
.\"O .I d_reclen
.\"O is the size of this entire
.\"O .IR linux_dirent .
.\"O .I d_name
.\"O is a null-terminated filename.
.I d_ino
は inode 番号である。
.I d_off
はディレクトリの先頭から次の
.I linux_dirent
の先頭までの距離である。
.I d_reclen
はこの
.I linux_dirent
全体のサイズである。
.I d_name
はヌル(null)文字で終わるファイル名である。

.\"O .I d_type
.\"O is a byte at the end of the structure that indicates the file type.
.\"O It contains one of the following values (defined in
.\"O .IR <dirent.h> ):
.I d_type
は、構造体の最後のバイトであり、ファイルタイプを示す。
.I d_type
は以下の値の一つを取る
.RI ( <dirent.h>
で定義されている)。
.TP 12
.B DT_BLK
.\"O This is a block device.
ブロックデバイスである。
.TP
.B DT_CHR
.\"O This is a character device.
キャラクタデバイスである。
.TP
.B DT_DIR
.\"O This is a directory.
ディレクトリである。
.TP
.B DT_FIFO
.\"O This is a named pipe (FIFO).
名前つきパイプ (FIFO) である。
.TP
.B DT_LNK
.\"O This is a symbolic link.
シンボリックリンクである。
.TP
.B DT_REG
.\"O This is a regular file.
通常のファイルである。
.TP
.B DT_SOCK
.\"O This is a UNIX domain socket.
UNIX ドメインソケットである。
.TP
.B DT_UNKNOWN
.\"O The file type is unknown.
ファイルタイプは不明である。
.PP
.\"O The
.\"O .I d_type
.\"O field is implemented since Linux 2.6.4.
.\"O It occupies a space that was previously a zero-filled padding byte in the
.\"O .IR linux_dirent
.\"O structure.
.\"O Thus, on kernels before 2.6.3,
.\"O attempting to access this field always provides the value 0
.\"O .RB ( DT_UNKNOWN ).
.I d_type
フィールドは Linux 2.6.4 から実装されている。
これは
.I linux_dirent
構造体のうち、以前はゼロで埋められていた空間に配置されている。
従って、2.6.3 以前のカーネルでは、このフィールドにアクセスしようとすると
常に値 0
.RB ( DT_UNKNOWN )
が返される。
.PP
.\"O Currently,
.\"O .\" kernel 2.6.27
.\"O .\" The same sentence is in readdir.2
.\"O only some file systems (among them: Btrfs, ext2, etx3, and ext4)
.\"O have full support for returning the file type in
.\"O .IR d_type .
.\"O All applications must properly handle a return of
.\"O .BR DT_UNKNOWN .
現在のところ、
.\" カーネル 2.6.27
.\" 同じ説明文が readdir.2 にもある。
.I d_type
でファイルタイプを返す機能が完全にサポートされているのは、
いくつかのファイルシステムにおいてのみである
(Btrfs, ext2, ext3, ext4 はサポートしている)。
どのアプリケーションも、
.B DT_UNKNOWN
が返された際に適切に処理できなければならない。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success, the number of bytes read is returned.
.\"O On end of directory, 0 is returned.
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
成功した場合は、読み込んだバイト数が返される。
ディレクトリの終わりならば 0 が返される。
エラーの場合は \-1 を返され、
.I errno
に適切な値が設定される。
.\"O .SH ERRORS
.SH エラー
.TP
.B EBADF
.\"O Invalid file descriptor
.\"O .IR fd .
ファイル記述子
.I fd
は無効である。
.TP
.B EFAULT
.\"O Argument points outside the calling process's address space.
引き数が、呼び出したプロセスのアドレス空間外を指している。
.TP
.B EINVAL
.\"O Result buffer is too small.
結果用のバッファーが小さすぎる。
.TP
.B ENOENT
.\"O No such directory.
そのようなディレクトリは存在しない。
.TP
.B ENOTDIR
.\"O File descriptor does not refer to a directory.
ファイル記述子がディレクトリを参照していない。
.\"O .SH "CONFORMING TO"
.SH 準拠
SVr4.
.\"O .\" SVr4 documents additional ENOLINK, EIO error conditions.
.\" SVr4 では、他に ENOLINK, EIO エラー状態についても記述されている。
.\"O .SH NOTES
.SH 注意
.\"O Glibc does not provide a wrapper for this system call; call it using
.\"O .BR syscall (2).
.\"O You will need to define the
.\"O .I linux_dirent
.\"O structure yourself.
glibc はこのシステムコールに対するラッパー関数を提供していないので、
.BR syscall (2)
を使って呼び出すこと。
.I linux_dirent
構造体は自分で定義する必要がある。

.\"O This call supersedes
.\"O .BR readdir (2).
このシステムコールは
.BR readdir (2)
を置き換えるものである。
.\"O .SH EXAMPLE
.SH 例
.\"O The program below demonstrates the use of
.\"O .BR getdents ().
.\"O The following output shows an example of what we see when running this
.\"O program on an ext2 directory:
下記のプログラムは
.BR getdents ()
の使用例を示したものである。
以下は、このプログラムを ext2 ディレクトリで実行した際に得られる
出力の例である。

.in +4n
.nf
.RB "$" " ./a.out /testfs/"
--------------- nread=120 ---------------
i-node#  file type  d_reclen  d_off   d_name
       2  directory    16         12  .
       2  directory    16         24  ..
      11  directory    24         44  lost+found
      12  regular      16         56  a
  228929  directory    16         68  sub
   16353  directory    16         80  sub2
  130817  directory    16       4096  sub3
.fi
.in
.\"O .SS Program source
.SS プログラムのソース
\&
.nf
#define _GNU_SOURCE
#include <dirent.h>     /* Defines DT_* constants */
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/syscall.h>

#define handle_error(msg) \\
        do { perror(msg); exit(EXIT_FAILURE); } while (0)

struct linux_dirent {
    long           d_ino;
    off_t          d_off;
    unsigned short d_reclen;
    char           d_name[];
};

#define BUF_SIZE 1024

int
main(int argc, char *argv[])
{
    int fd, nread;
    char buf[BUF_SIZE];
    struct linux_dirent *d;
    int bpos;
    char d_type;

    fd = open(argc > 1 ? argv[1] : ".", O_RDONLY | O_DIRECTORY);
    if (fd == \-1)
        handle_error("open");

    for ( ; ; ) {
        nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);
        if (nread == \-1)
            handle_error("getdents");

        if (nread == 0)
            break;

        printf("\--------------- nread=%d ---------------\\n", nread);
        printf("i\-node#  file type  d_reclen  d_off   d_name\\n");
        for (bpos = 0; bpos < nread;) {
            d = (struct linux_dirent *) (buf + bpos);
            printf("%8ld  ", d\->d_ino);
            d_type = *(buf + bpos + d\->d_reclen - 1);
            printf("%\-10s ", (d_type == DT_REG) ?  "regular" :
                             (d_type == DT_DIR) ?  "directory" :
                             (d_type == DT_FIFO) ? "FIFO" :
                             (d_type == DT_SOCK) ? "socket" :
                             (d_type == DT_LNK) ?  "symlink" :
                             (d_type == DT_BLK) ?  "block dev" :
                             (d_type == DT_CHR) ?  "char dev" : "???");
            printf("%4d %10lld  %s\\n", d\->d_reclen,
                    (long long) d\->d_off, (char *) d->d_name);
            bpos += d\->d_reclen;
        }
    }

    exit(EXIT_SUCCESS);
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR readdir (2),
.BR readdir (3)

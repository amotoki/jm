.\" Copyright (c) 1983, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" Modified 1993-07-24 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1996-10-22 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified Oct 1998 by Andi Kleen
.\" Modified Oct 2003 by aeb
.\" Modified 2004-07-01 by mtk
.\"
.\" Japanese Version Copyright (c) 1996 HANATAKA Shinya all rights reserved.
.\" Translated 1997-02-23, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 1999-08-15, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 2000-01-13, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2001-01-30, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-03-14, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-12-26, Akihiro MOTOKI
.\" Updated 2006-04-15, Akihiro MOTOKI, LDP v2.29
.\" Updated 2008-04-13, Akihiro MOTOKI, LDP v3.20
.\"
.\"WORD:	socket			ソケット
.\"WORD:	message			メッセージ
.\"WORD:	protocol		プロトコル
.\"WORD:	nonblocking I/O		非停止 I/O
.\"WORD:	block			停止(block)
.\"WORD:	out-of-band		帯域外
.\"WORD:	descriptor		ディスクリプタ
.\"WORD:	parameter		パラメータ
.\"WORD:	queue			キュー
.\"WORD:	buffer			バッファ
.\"WORD:	routing			ルーティング
.\"WORD:	congestion		輻輳
.\"
.TH SEND 2 2011-10-01 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O send, sendto, sendmsg \- send a message on a socket
send, sendto, sendmsg \- ソケットへメッセージを送る
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/types.h>
.B #include <sys/socket.h>
.sp
.BI "ssize_t send(int " sockfd ", const void *" buf ", size_t " len \
", int " flags );

.BI "ssize_t sendto(int " sockfd ", const void *" buf ", size_t " len \
", int " flags ,
.BI "               const struct sockaddr *" dest_addr ", socklen_t " addrlen );

.BI "ssize_t sendmsg(int " sockfd ", const struct msghdr *" msg \
", int " flags );
.fi
.SH 説明
.\"O The system calls
.\"O .BR send (),
.\"O .BR sendto (),
.\"O and
.\"O .BR sendmsg ()
.\"O are used to transmit a message to another socket.
システムコール
.BR send (),
.BR sendto (),
.BR sendmsg ()
は、もう一方のソケットへメッセージを転送するのに使用される。
.PP
.\"O The
.\"O .BR send ()
.\"O call may be used only when the socket is in a
.\"O .I connected
.\"O state (so that the intended recipient is known).
.\"O The only difference between
.\"O .BR send ()
.\"O and
.\"O .BR write (2)
.\"O is the presence of
.\"O .IR flags .
.BR send ()
は、ソケットが
.I "接続された (connected)"
状態にある場合にのみ使用できる
(つまり、どの相手に送信するかは既知である)。
.BR send ()
と
.BR write (2)
の違いは、引き数に
.I flags
があるかどうかだけである。
.\"O With a zero
.\"O .I flags
.\"O argument,
.\"O .BR send ()
.\"O is equivalent to
.\"O .BR write (2).
.\"O Also, the following call
.\"O 
.\"O     send(sockfd, buf, len, flags);
.\"O 
.\"O is equivalent to
.\"O 
.\"O     sendto(sockfd, buf, len, flags, NULL, 0);
引き数
.I flags
にフラグが指定されない場合、
.BR send ()
は
.BR write (2)
と等価である。
また、

    send(sockfd, buf, len, flags);

は

    sendto(sockfd, buf, len, flags, NULL, 0);

と等価である。
.PP
.\"O The argument
.\"O .I sockfd
.\"O is the file descriptor of the sending socket.
引き数
.I sockfd
は、データを送信するパケットのファイル・ディスクリプタである。
.PP
.\"O If
.\"O .BR sendto ()
.\"O is used on a connection-mode
.\"O .RB ( SOCK_STREAM ,
.\"O .BR SOCK_SEQPACKET )
.\"O socket, the arguments
.\"O .I dest_addr
.\"O and
.\"O .I addrlen
.\"O are ignored (and the error
.\"O .B EISCONN
.\"O may be returned when they are
.\"O not NULL and 0), and the error
.\"O .B ENOTCONN
.\"O is returned when the socket was not actually connected.
.\"O Otherwise, the address of the target is given by
.\"O .I dest_addr
.\"O with
.\"O .I addrlen
.\"O specifying its size.
.BR sendto ()
は、接続型 (connection-mode) のソケット
.RB ( SOCK_STREAM ,
.BR SOCK_SEQPACKET )
で
使用された場合、引き数
.I dest_addr
と
.I addrlen
は無視される (各々の引き数が NULL と 0 でない場合は
.B EISCONN
エラーも返される)。
また、ソケットが実際には接続されていなかった時には
.B ENOTCONN
エラーが返される。
接続型のソケット以外で使用された場合は、接続先のアドレスは
.I dest_addr
で与えられ、そのサイズは
.I addrlen
で指定される。
.\"O For
.\"O .BR sendmsg (),
.\"O the address of the target is given by
.\"O .IR msg.msg_name ,
.\"O with
.\"O .I msg.msg_namelen
.\"O specifying its size.
.BR sendmsg ()
では、接続先のアドレスは
.I msg.msg_name
で与えられ、そのサイズは
.I msg.msg_namelen
で指定される。
.PP
.\"O For
.\"O .BR send ()
.\"O and
.\"O .BR sendto (),
.\"O the message is found in
.\"O .I buf
.\"O and has length
.\"O .IR len .
.\"O For
.\"O .BR sendmsg (),
.\"O the message is pointed to by the elements of the array
.\"O .IR msg.msg_iov .
.\"O The
.\"O .BR sendmsg ()
.\"O call also allows sending ancillary data (also known as control information).
.BR send ()
と
.BR sendto ()
では、メッセージは
.I buf
に格納されており、その長さは
.I len
であると解釈される。
.BR sendmsg ()
では、メッセージは
配列
.I msg.msg_iov
の各要素が指す位置に格納されている。
.BR sendmsg ()
では、補助データ (制御情報とも呼ばれる) を送信することもできる。
.PP
.\"O If the message is too long to pass atomically through the
.\"O underlying protocol, the error
.\"O .B EMSGSIZE
.\"O is returned, and the message is not transmitted.
メッセージ長が長過ぎるために、そのソケットが使用するプロトコルでは、
メッセージをソケットに渡されたままの形で送信することができない場合、
.B EMSGSIZE
エラーが返され、そのメッセージは転送されない。
.PP
.\"O No indication of failure to deliver is implicit in a
.\"O .BR send ().
.\"O Locally detected errors are indicated by a return value of \-1.
.BR send ()
では、配送の失敗の通知は明示的に行われる。
ローカル側でエラーが検出された場合は、返り値 \-1 として通知される。
.PP
.\"O When the message does not fit into the send buffer of the socket,
.\"O .BR send ()
.\"O normally blocks, unless the socket has been placed in nonblocking I/O
.\"O mode.
.\"O In nonblocking mode it would fail with the error
.\"O .B EAGAIN
.\"O or
.\"O .B EWOULDBLOCK
.\"O in this case.
.\"O The
.\"O .BR select (2)
.\"O call may be used to determine when it is possible to send more data.
メッセージがソケットの送信バッファに入れることができない場合、
.BR send ()
は通常は停止 (block) する (ソケットが非停止 (nonblocking) I/O モード
でない場合)。非停止モードの場合にはエラー
.B EAGAIN
か
.B EWOULDBLOCK
で失敗する。
いつデータをさらに送信できるようになるかを知るために、
.BR select (2)
コールを使用することができる。
.PP
.\"O .I flags
.\"O argument is the bitwise OR
.\"O of zero or more of the following flags.
.I flags
引き数は、以下のフラグの (0 個以上の) ビット単位の論理和を
とったものを指定する。
.\"O .\" FIXME ? document MSG_PROXY (which went away in 2.3.15)
.\" FIXME ? MSG_PROXY について記載すること
.\" (MSG_PROXY は 2.3.15 でなくなった)
.TP
.\"O .BR MSG_CONFIRM " (Since Linux 2.3.15)"
.\"O Tell the link layer that forward progress happened: you got a successful
.\"O reply from the other side.
.\"O If the link layer doesn't get this
.\"O it will regularly reprobe the neighbor (e.g., via a unicast ARP).
.BR MSG_CONFIRM " (Linux 2.3.15 以降)"
転送処理に進展があった、つまり相手側から成功の応答を受けたことをリンク層に
知らせる。リンク層がこの通知を受け取らなかった場合には、通常どおり
(ユニキャスト ARP を使うなどの方法で) 近傍 (neighbor) の再検索を行う。
.\"O Only valid on
.\"O .B SOCK_DGRAM
.\"O and
.\"O .B SOCK_RAW
.\"O sockets and currently only implemented for IPv4 and IPv6.
.\"O See
.\"O .BR arp (7)
.\"O for details.
.B SOCK_DGRAM
と
.B SOCK_RAW
のソケットに対してのみ有効で、現在のところ IPv4 と IPv6 のみ実装されている。
詳しくは
.BR arp (7)
参照のこと。
.TP
.B MSG_DONTROUTE
.\"O Don't use a gateway to send out the packet, only send to hosts on
.\"O directly connected networks.
.\"O This is usually used only
.\"O by diagnostic or routing programs.
.\"O This is only defined for protocol
.\"O families that route; packet sockets don't.
パケットを送り出すのにゲートウェイを使用せず、
直接接続されているネットワーク上のホストだけに送る。
通常、このフラグは診断 (diagnostic) やルーティング・プログラムに
よってのみ使用される。このフラグは、経路制御が行われるプロトコルファミリー
に対してのみ定義されている。パケットソケットには定義されていない。
.TP
.B MSG_DONTWAIT
.\"O Enables nonblocking operation; if the operation would block,
.\"O .B EAGAIN
.\"O or
.\"O .B EWOULDBLOCK
.\"O is returned (this can also be enabled using the
.\"O .B O_NONBLOCK
.\"O flag with the
.\"O .B F_SETFL
.\"O .BR fcntl (2)).
非停止 (nonblocking) 操作を有効にする。操作が停止されるような場合には
.B EAGAIN
か
.B EWOULDBLOCK
を返すようにする
.RB ( fcntl (2)
の
.B F_SETFL
で
.B O_NONBLOCK
フラグを指定することによっても有効にできる)。
.TP
.\"O .BR MSG_EOR " (since Linux 2.2)"
.BR MSG_EOR " (Linux 2.2 以降)"
.\"O Terminates a record (when this notion is supported, as for sockets of type
.\"O .BR SOCK_SEQPACKET ).
レコードの終了を指示する
.RB ( SOCK_SEQPACKET
のようにこの概念に対応しているソケット種別のときに有効)。
.TP
.\"O .BR MSG_MORE " (Since Linux 2.4.4)"
.BR MSG_MORE " (Linux 2.4.4 以降)"
.\"O The caller has more data to send.
.\"O This flag is used with TCP sockets to obtain the same effect
.\"O as the
.\"O .B TCP_CORK
.\"O socket option (see
.\"O .BR tcp (7)),
.\"O with the difference that this flag can be set on a per-call basis.
呼び出し元にさらに送るデータがあることを示す。
このフラグは TCP ソケットとともに使用され、
.B TCP_CORK
ソケットオプションと同じ効果が得られる
.RB ( tcp (7)
を参照)。
.B TCP_CORK
との違いは、このフラグを使うと呼び出し単位で
この機能を有効にできる点である。

.\"O Since Linux 2.6, this flag is also supported for UDP sockets, and informs
.\"O the kernel to package all of the data sent in calls with this flag set
.\"O into a single datagram which is only transmitted when a call is performed
.\"O that does not specify this flag.
.\"O (See also the
.\"O .B UDP_CORK
.\"O socket option described in
.\"O .BR udp (7).)
Linux 2.6 以降では、このフラグは UDP ソケットでもサポートされており、
このフラグ付きで送信された全てのデータを一つのデータグラムにまとめて
送信することを、カーネルに知らせる。まとめられたデータグラムは、
このフラグを指定せずにこのシステムコールが実行された際に初めて送信される
.RB ( udp (7)
に記載されているソケットオプション
.B UDP_CORK
も参照)。
.TP
.\"O .BR MSG_NOSIGNAL " (since Linux 2.2)"
.BR MSG_NOSIGNAL " (Linux 2.2 以降)"
.\"O Requests not to send
.\"O .B SIGPIPE
.\"O on errors on stream oriented sockets when the other end breaks the
.\"O connection.
.\"O The
.\"O .B EPIPE
.\"O error is still returned.
ストリーム指向のソケットで相手側が接続を切断した時に、エラーとして
.B SIGPIPE
を送信しないように要求する。この場合でも
.B EPIPE
は返される。
.TP
.B MSG_OOB
.\"O Sends
.\"O .I out-of-band
.\"O data on sockets that support this notion (e.g., of type
.\"O .BR SOCK_STREAM );
.\"O the underlying protocol must also support
.\"O .I out-of-band
.\"O data.
.I "帯域外 (out-of-band)"
データをサポートするソケット (例えば
.BR SOCK_STREAM )
で
.I 帯域外
データを送る。下位プロトコルも
.I 帯域外
データをサポートしている必要がある。
.PP
.\"O The definition of the
.\"O .I msghdr
.\"O structure follows.
.\"O See
.\"O .BR recv (2)
.\"O and below for an exact description of its fields.
.I msghdr
構造体の内容は以下の通り。
各フィールドの正確な記述については
.BR recv (2)
と以下の説明を参照すること。
.in +4n
.nf

struct msghdr {
.\"O     void         *msg_name;       /* optional address */
.\"O     socklen_t     msg_namelen;    /* size of address */
.\"O     struct iovec *msg_iov;        /* scatter/gather array */
.\"O     size_t        msg_iovlen;     /* # elements in msg_iov */
.\"O     void         *msg_control;    /* ancillary data, see below */
.\"O     size_t        msg_controllen; /* ancillary data buffer len */
.\"O     int           msg_flags;      /* flags on received message */
    void         *msg_name;       /* 追加のアドレス */
    socklen_t     msg_namelen;    /* アドレスのサイズ */
    struct iovec *msg_iov;        /* scatter/gather 配列 */
    size_t        msg_iovlen;     /* msg_iov の要素数 */
    void         *msg_control;    /* 補助データ(後述) */
    size_t        msg_controllen; /* 補助データバッファ長 */
    int           msg_flags;      /* 受信メッセージのフラグ */
};
.fi
.in
.PP
.\"O You may send control information using the
.\"O .I msg_control
.\"O and
.\"O .I msg_controllen
.\"O members.
.\"O The maximum control buffer length the kernel can process is limited
.\"O per socket by the value in
.\"O .IR /proc/sys/net/core/optmem_max ;
.\"O see
.\"O .BR socket (7).
.I msg_control
と
.I msg_controllen
メンバーを使用して制御情報を送信することができる。
カーネルが処理できる制御バッファのソケットあたりの最大長は、
.I /proc/sys/net/core/optmem_max
の値に制限されている。
.BR socket (7)
を参照。
.\" Still to be documented:
.\"  Send file descriptors and user credentials using the
.\"  msg_control* fields.
.\"  The flags returned in msg_flags.
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success, these calls return the number of characters sent.
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
成功した場合、これらのシステムコールは送信されたバイト数を返す。
エラーの場合、 \-1 を返し、
.I errno
を適切に設定にする。
.\"O .SH ERRORS
.SH エラー
.\"O These are some standard errors generated by the socket layer.
.\"O Additional errors
.\"O may be generated and returned from the underlying protocol modules;
.\"O see their respective manual pages.
これらはソケット層で発生する一般的なエラーである。これ以外に、下層の
プロトコル・モジュールで生成されたエラーが返されるかもしれない。
これらについては、それぞれのマニュアルを参照すること。
.TP
.B EACCES
.\"O (For UNIX domain sockets, which are identified by pathname)
.\"O Write permission is denied on the destination socket file,
.\"O or search permission is denied for one of the directories
.\"O the path prefix.
.\"O (See
.\"O .BR path_resolution (7).)
(UNIX ドメインソケットはパス名で識別される。)
ソケット・ファイルへの書き込み許可がなかったか、パス名へ
到達するまでのディレクトリのいずれかに対する検索許可がなかった。
.RB ( path_resolution (7)
も参照のこと)
.TP
.\"O .BR EAGAIN " or " EWOULDBLOCK
.BR EAGAIN " または " EWOULDBLOCK
.\" Actually EAGAIN on Linux
.\"O The socket is marked nonblocking and the requested operation
.\"O would block.
.\"O POSIX.1-2001 allows either error to be returned for this case,
.\"O and does not require these constants to have the same value,
.\"O so a portable application should check for both possibilities.
ソケットが非停止に設定されており、
要求された操作が停止した。
POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めており、
これら 2 つの定数が同じ値を持つことも求めていない。
したがって、移植性が必要なアプリケーションでは、両方の可能性を
確認すべきである。
.TP
.B EBADF
.\"O An invalid descriptor was specified.
無効なディスクリプターが指定された。
.TP
.B ECONNRESET
.\"O Connection reset by peer.
接続が接続相手によりリセットされた。
.TP
.B EDESTADDRREQ
.\"O The socket is not connection-mode, and no peer address is set.
ソケットが接続型 (connection-mode) ではなく、
かつ送信先のアドレスが設定されていない。
.TP
.B EFAULT
.\"O An invalid user space address was specified for an argument.
ユーザー空間として不正なアドレスがパラメーターとして指定された。
.TP
.B EINTR
.\"O A signal occurred before any data was transmitted; see
.\"O .BR signal (7).
データが送信される前に、シグナルが発生した。
.BR signal (7)
参照。
.TP
.B EINVAL
.\"O Invalid argument passed.
不正な引き数が渡された。
.TP
.B EISCONN
.\"O The connection-mode socket was connected already but a
.\"O recipient was specified.
.\"O (Now either this error is returned, or the recipient specification
.\"O is ignored.)
接続型ソケットの接続がすでに確立していたが、受信者が指定されていた。
(現在のところ、この状況では、このエラーが返されるか、
受信者の指定が無視されるか、のいずれかとなる)
.TP
.B EMSGSIZE
.\"O The socket type
.\"O .\" (e.g., SOCK_DGRAM )
.\"O requires that message be sent atomically, and the size
.\"O of the message to be sent made this impossible.
そのソケット種別
.\" (例えば SOCK_DGRAM)
ではソケットに渡されたままの形でメッセージを送信する必要があるが、
メッセージが大き過ぎるため送信することができない。
.TP
.B ENOBUFS
.\"O The output queue for a network interface was full.
.\"O This generally indicates that the interface has stopped sending,
.\"O but may be caused by transient congestion.
ネットワーク・インターフェースの出力キューが一杯である。
一般的には、一時的な輻輳 (congestion) のためにインターフェースが
送信を止めていることを意味する。
.\"O (Normally, this cannot occur in Linux.
.\"O Packets are just silently dropped
.\"O when a device queue overflows.)
(通常、Linux ではこのようなことは起こらない。デバイスのキューが
オーバーフローした場合にはパケットは黙って捨てられる)
.TP
.B ENOMEM
.\"O No memory available.
メモリが足りない。
.TP
.B ENOTCONN
.\"O The socket is not connected, and no target has been given.
ソケットが接続されておらず、接続先も指定されていない。
.TP
.B ENOTSOCK
.\"O The argument
.\"O .I sockfd
.\"O is not a socket.
引き数
.I sockfd
がソケットでない。
.TP
.B EOPNOTSUPP
.\"O Some bit in the
.\"O .I flags
.\"O argument is inappropriate for the socket type.
引き数
.I flags
のいくつかのビットが、そのソケット種別では不適切なものである。
.TP
.B EPIPE
.\"O The local end has been shut down on a connection oriented socket.
.\"O In this case the process
.\"O will also receive a
.\"O .B SIGPIPE
.\"O unless
.\"O .B MSG_NOSIGNAL
.\"O is set.
接続指向のソケットでローカル側が閉じられている。
この場合、
.B MSG_NOSIGNAL
が設定されていなければ、プロセスには
.B SIGPIPE
も同時に送られる。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O 4.4BSD, SVr4, POSIX.1-2001.
.\"O These function calls appeared in 4.2BSD.
4.4BSD, SVr4, POSIX.1-2001.
(これらの関数コールは 4.2BSD で最初に登場した)。

.\"O POSIX.1-2001 only describes the
.\"O .B MSG_OOB
.\"O and
.\"O .B MSG_EOR
.\"O flags.
.\"O+ POSIX.1-2008 adds a specification of
.\"O+ .BR MSG_NOSIGNAL .
.\"O The
.\"O .B MSG_CONFIRM
.\"O flag is a Linux extension.
POSIX.1-2001 には、
.B MSG_OOB
と
.B MSG_EOR
フラグだけが記載されている。
POSIX.1-2008 では
.B MSG_NOSIGNAL
が規格に追加されている。
.B MSG_CONFIRM
フラグは Linux での拡張である。
.\"O .SH NOTES
.SH 注意
.\"O The prototypes given above follow the Single UNIX Specification,
.\"O as glibc2 also does; the
.\"O .I flags
.\"O argument was \fIint\fP in 4.x BSD, but \fIunsigned int\fP in libc4 and libc5;
.\"O the
.\"O .I len
.\"O argument was \fIint\fP in 4.x BSD and libc4, but \fIsize_t\fP in libc5;
.\"O the
.\"O .I addrlen
.\"O argument was \fIint\fP in 4.x BSD and libc4 and libc5.
.\"O See also
.\"O .BR accept (2).
上記のプロトタイプは Single UNIX Specification に従っている。
glibc2 も同様である。
.I flags
引き数は 4.x BSD では \fIint\fP であり、
libc4 と libc5 では \fIunsigned int\fP である。
.I len
引き数は 4.x BSD と libc4 では \fIint\fP であり、
libc5 では \fIsize_t\fP である。
.I addrlen
引き数は 4.x BSD と libc4 と libc5 では \fIint\fP である。
.BR accept (2)
も参照すること。

.\"O According to POSIX.1-2001, the
.\"O .I msg_controllen
.\"O field of the
.\"O .I msghdr
.\"O structure should be typed as
.\"O .IR socklen_t ,
.\"O but glibc currently types it as
.\"O .IR size_t .
POSIX.1-2001 では、構造体
.I msghdr
のフィールド
.I msg_controllen
は
.I socklen_t
型であるべきだとされているが、
現在の glibc では
.I size_t
型である。
.\" glibc bug raised 12 Mar 2006
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=2448
.\" The problem is an underlying kernel issue: the size of the
.\" __kernel_size_t type used to type this field varies
.\" across architectures, but socklen_t is always 32 bits.
.\"O .SH BUGS
.SH バグ
.\"O Linux may return
.\"O .B EPIPE
.\"O instead of
.\"O .BR ENOTCONN .
Linux は
.B ENOTCONN
を返す状況で
.B EPIPE
を返すことがある。
.\"O .SH EXAMPLE
.SH 例
.\"O An example of the use of
.\"O .BR sendto ()
.\"O is shown in
.\"O .BR getaddrinfo (3).
.BR sendto ()
の利用例が
.BR getaddrinfo (3)
に記載されている。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR fcntl (2),
.BR getsockopt (2),
.BR recv (2),
.BR select (2),
.BR sendfile (2),
.BR shutdown (2),
.BR socket (2),
.BR write (2),
.BR cmsg (3),
.BR ip (7),
.BR socket (7),
.BR tcp (7),
.BR udp (7)

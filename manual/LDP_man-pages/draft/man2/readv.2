.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" License.
.\" Modified Sat Jul 24 18:34:44 1993 by Rik Faith (faith@cs.unc.edu)
.\" Merged readv.[23], 2002-10-17, aeb
.\" 2007-04-30 mtk, A fairly major rewrite to fix errors and
.\"     add more details.
.\"
.\" 1996-04-12 Tom Bjorkholm <tomb@mydata.se>
.\"            First version written
.\" Modified Tue Oct 22 17:41:07 1996 by Eric S. Raymond <esr@thyrsus.com>
.\"
.\" Japanese Version Copyright (c) 1997-1999 HANATAKA Shinya
.\"         all rights reserved.
.\" Translated 1997-02-23, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 1999-04-03, HANATAKA Shinya
.\" Updated 2003-01-14, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-10-07, Akihiro MOTOKI
.\" Updated 2007-06-01, Akihiro MOTOKI, LDP v2.50
.\"
.\"WORD:	vector			ベクタ (vector)
.\"WORD:	file descriptor		ファイルディスクリプタ
.\"WORD:	buffer			バッファ
.\"
.TH READV 2  2002-10-17 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O readv, writev \- read or write data into multiple buffers
.SH 名前
readv, writev \- 複数のバッファへの読み書きを行なう
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/uio.h>
.sp
.BI "ssize_t readv(int " fd ", const struct iovec *" iov ", int " iovcnt );
.sp
.BI "ssize_t writev(int " fd ", const struct iovec *" iov ", int " iovcnt );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR readv ()
.\"O function reads
.\"O .I iovcnt
.\"O buffers from the file associated with the file descriptor
.\"O .I fd
.\"O into the buffers described by
.\"O .I iov
.\"O ("scatter input").
.BR readv ()
関数は、ファイルディスクリプタ
.I fd
に関連付けられたファイルから、
.I iovcnt
個のバッファ分のデータを読み込み、
.I iov
で指定されたバッファに格納する
("scatter input";「ばらまき入力」)。
.PP
.\"O The
.\"O .BR writev ()
.\"O function writes at most
.\"O .I iovcnt
.\"O buffers described by
.\"O .I iov
.\"O to the file associated with the file descriptor
.\"O .I fd
.\"O ("gather output").
.BR writev ()
関数は、
.I iov
で指定されたバッファから最大
.I iovcnt
個のバッファ分のデータを取り出し、
ファイルディスクリプタ
.I fd
に関連付けられたファイルに書き込む
("gather output";「かき集め出力」)。
.PP
.\"O The pointer
.\"O .I iov
.\"O points to an array of
.\"O .I iovec
.\"O structures,
.\"O defined in
.\"O .I <sys/uio.h>
.\"O as:
ポインタ
.I iov
は
.I iovec
構造体の配列へのポインタである。
.I iovec
構造体は
.I <sys/uio.h>
で以下のように定義されている:
.PP
.br
.in +4n
.nf
struct iovec {
    void  *iov_base;    /* Starting address */
    size_t iov_len;     /* Number of bytes to transfer */
};
.fi
.in
.PP
.\"O The
.\"O .BR readv ()
.\"O function works just like
.\"O .BR read (2)
.\"O except that multiple buffers are filled.
.BR readv ()
関数は、複数のバッファにデータを読み込む点を除いて
.BR read (2)
と全く同様の動作を行う。
.PP
.\"O The
.\"O .BR writev ()
.\"O function works just like
.\"O .BR write (2)
.\"O except that multiple buffers are written out.
.BR writev ()
関数は、複数のバッファのデータを書き出す点以外は
.BR write (2)
と全く同様の動作を行う。
.PP
.\"O Buffers are processed in array order.
.\"O This means that
.\"O .BR readv ()
.\"O completely fills
.\"O .IR iov [0]
.\"O before proceeding to
.\"O .IR iov [1],
.\"O and so on.
.\"O (If there is insufficient data, then not all buffers pointed to by
.\"O .I iov
.\"O may be filled.)
.\"O Similarly,
.\"O .BR writev ()
.\"O writes out the entire contents of
.\"O .IR iov [0]
.\"O before proceeding to
.\"O .IR iov [1],
.\"O and so on.
バッファは配列の順序で処理される。これは、
.BR readv ()
が
.IR iov [0]
が完全に一杯になるまでデータを詰めてから、
.IR iov [1]
などに進むことを意味する
(データが十分ない場合は、
.I iov
が指すバッファのいずれも一杯にならない)。
同様に、
.BR writev ()
は
.IR iov [0]
の内容を全部書き出してから
.IR iov [1]
などに進む。
.PP
.\"O The data transfers performed by
.\"O .BR readv ()
.\"O and
.\"O .BR writev ()
.\"O are atomic: the data written by
.\"O .BR writev ()
.\"O is written as a single block that is not intermingled with output
.\"O from writes in other processes (but see
.\"O .BR pipe (7)
.\"O for an exception);
.\"O analogously,
.\"O .BR readv ()
.\"O is guaranteed to read a contiguous block of data from the file,
.\"O regardless of read operations performed in other threads or processes
.\"O that have file descriptors referring to the same open file description
.\"O (see
.\"O .BR open (2)).
.BR readv ()
と
.BR writev ()
によるデータ転送は atomic に行われる。つまり、
.BR writev ()
によるデータ書き込みは一つのブロックとして行われ、他のプロセスの
write による書き込みと混ざり合うことはない
(例外に関しては
.BR pipe (7)
を参照のこと)。同様に、
.BR readv ()
はファイルから連続するデータブロックが読み出すことが保証され、
同じファイル記述 (file description;
.BR open (2)
参照) を参照するファイルディスクリプタを持つ他のスレッドやプロセスが
実行した read 操作の影響を受けることはない。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success, the
.\"O .BR readv ()
.\"O function returns the number of bytes read; the
.\"O .BR writev ()
.\"O function returns the number of bytes written.
.\"O On error, \-1 is returned, and \fIerrno\fP is set appropriately.
成功した場合、
.BR readv ()
関数は読み込んだバイト数を返し、
.BR writev ()
関数は書き込んだバイト数を返す。
エラーの場合 \-1 を返し、\fIerrno\fP を適切に設定する。
.\"O .SH ERRORS
.SH エラー
.\"O The errors are as given for
.\"O .BR read (2)
.\"O and
.\"O .BR write (2).
.BR read (2)
や
.BR write (2)
と同じエラーが定義されている。
.\"O Additionally the following error is defined:
さらに以下のエラーが定義されている:
.TP
.B EINVAL
.\"O The sum of the
.\"O .I iov_len
.\"O values overflows an
.\"O .I ssize_t
.\"O value.
.\"O Or, the vector count \fIiovcnt\fP is less than zero or greater than the
.\"O permitted maximum.
.I iov_len
の合計が
.I ssize_t
の範囲をオーバーフローした。もしくは、
ベクタ数 \fIiovcnt\fP が 0 より小さいか許可された最大値よりも大きかった。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O 4.4BSD (the
.\"O .BR readv ()
.\"O and
.\"O .BR writev ()
.\"O functions first appeared in 4.2BSD), POSIX.1-2001.
.\"O Linux libc5 used \fIsize_t\fP as the type of the \fIiovcnt\fP argument,
.\"O and \fIint\fP as return type for these functions.
.\"O .\" The readv/writev system calls were buggy before Linux 1.3.40.
.\"O .\" (Says release.libc.)
4.4BSD
.RB ( readv ()
と
.BR writev ()
関数は 4.2BSD で最初に現われた)、POSIX.1-2001。
Linux libc5 では \fIiovcnt\fP 引き数の型として \fIsize_t\fP を、
これらの関数の返り値として \fIint\fP を使用していた。
.\" readv/writev システムコールは Linux 1.3.40 以前はバグだらけであった
.\" (と release.libc に書かれている)。
.\"O .SH NOTES
.\"O .SS Linux Notes
.SH 注意
.SS "Linux での注意"
.\"O POSIX.1-2001 allows an implementation to place a limit on
.\"O the number of items that can be passed in
.\"O .IR iov .
.\"O An implementation can advertise its limit by defining
.\"O .B IOV_MAX
.\"O in
.\"O .IR <limits.h>
.\"O or at run time via the return value from
.\"O .IR sysconf(_SC_IOV_MAX) .
.\"O On Linux, the limit advertised by these mechanisms is 1024,
.\"O which is the true kernel limit.
POSIX.1-2001 では、
.I iov
で渡すことができる要素数に上限を設ける実装が認められている。
実装は、
.I <limits.h>
の
.B IOV_MAX
を定義することや、実行時に
.I sysconf(_SC_IOV_MAX)
の返り値経由で、この上限を広告することができる。
Linux では、この仕組みにより広告される上限は 1024 であり、
この値はカーネルでの上限そのものである。
.\"O However, the glibc wrapper functions do some extra work if
.\"O they detect that the underlying kernel system call failed because this
.\"O limit was exceeded.
.\"O In the case of
.\"O .BR readv ()
.\"O the wrapper function allocates a temporary buffer large enough
.\"O for all of the items specified by
.\"O .IR iov ,
.\"O passes that buffer in a call to
.\"O .BR read (2),
.\"O copies data from the buffer to the locations specified by the
.\"O .I iov_base
.\"O fields of the elements of
.\"O .IR iov ,
.\"O and then frees the buffer.
.\"O The wrapper function for
.\"O .BR writev ()
.\"O performs the analogous task using a temporary buffer and a call to
.\"O .BR write (2).
一方で、glibc のラッパー関数は、その関数の内部で呼ばれるカーネル・
システムコールがこの上限を超過して失敗したことを検出すると、
追加の動作をする。
.BR readv ()
の場合、ラッパー関数は
.I iov
で指定された全ての要素を格納できる大きさの一時バッファを割り当て、
.BR read (2)
を呼び出す際にそのバッファを渡し、
そのバッファのデータを
.I iov
の各要素の
.I iov_base
フィールドが指定する場所にコピーしてから、
そのバッファを解放する。
.BR writev ()
のラッパー関数も、同じように一時バッファを使って
.BR write (2)
を呼び出す。
.\"O .SH BUGS
.SH バグ
.\"O It is not advisable to mix calls to functions like
.\"O .BR readv ()
.\"O or
.\"O .BR writev (),
.\"O which operate on file descriptors, with the functions from the stdio
.\"O library; the results will be undefined and probably not what you want.
.BR readv ()
や
.BR writev ()
のようなファイルディスクリプタに対する操作を行う関数と、
標準入出力ライブラリの関数をごちゃまぜにして呼ぶのはお薦めしない。
どんな結果になるかは定義されておらず、
おそらく欲しい結果は得られないだろう。
.\"O .SH EXAMPLE
.SH 例
.\"O The following code sample demonstrates the use of
.\"O .BR writev ():
以下のサンプルコードは
.BR writev ()
の使用方法を示すものである。

.in +4n
.nf
char *str0 = "hello ";
char *str1 = "world\\n";
struct iovec iov[2];
ssize_t nwritten;

iov[0].iov_base = str0;
iov[0].iov_len = strlen(str0);
iov[1].iov_base = str1;
iov[1].iov_len = strlen(str1);

nwritten = writev(STDOUT_FILENO, iov, 2);
.fi
.in
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR read (2),
.BR write (2)

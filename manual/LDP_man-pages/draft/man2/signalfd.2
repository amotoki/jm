.\" Copyright (C) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
.\" starting from a version by Davide Libenzi <davidel@xmailserver.org>
.\"
.\" This program is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License, or
.\" (at your option) any later version.
.\"
.\" This program is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program; if not, write to the Free Software
.\" Foundation, Inc., 59 Temple Place, Suite 330, Boston,
.\" MA  02111-1307  USA
.\"
.\" Japanese Version Copyright (c) 2008  Akihiro MOTOKI
.\"         all rights reserved.
.\" Translated 2008-04-06, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.79
.\" Updated 2008-11-10, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.13
.\" Updated 2009-02-23, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.18
.\" 
.TH SIGNALFD 2 2009-01-13 Linux "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O signalfd \- create a file descriptor for accepting signals
signalfd \- シグナル受け付け用のファイルディスクリプタを生成する
.\"O .SH SYNOPSIS
.SH 書式
.B #include <sys/signalfd.h>
.sp
.BI "int signalfd(int " fd ", const sigset_t *" mask ", int " flags );
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR signalfd ()
.\"O creates a file descriptor that can be used to accept signals
.\"O targeted at the caller.
.\"O This provides an alternative to the use of a signal handler or
.\"O .BR sigwaitinfo (2),
.\"O and has the advantage that the file descriptor may be monitored by
.\"O .BR select (2),
.\"O .BR poll (2),
.\"O and
.\"O .BR epoll (7).
.BR signalfd ()
は、呼び出し元宛てのシグナルを受け付けるために使用されるファイル
ディスクリプタを生成する。
この方法はシグナルハンドラや
.BR sigwaitinfo (2)
を用いる方法の代わりとなるものであり、このファイルディスクリプタを
.BR select (2),
.BR poll (2),
.BR epoll (7)
で監視できるという利点がある。

.\"O The
.\"O .I mask
.\"O argument specifies the set of signals that the caller
.\"O wishes to accept via the file descriptor.
.\"O This argument is a signal set whose contents can be initialized
.\"O using the macros described in
.\"O .BR sigsetops (3).
.I mask
引き数には、呼び出し元がこのファイルディスクリプタ経由で受け付けたい
シグナル集合を指定する。この引き数で指定するシグナル集合の内容は、
.BR sigsetops (3)
で説明されているマクロを使って初期化することができる。
.\"O Normally, the set of signals to be received via the
.\"O file descriptor should be blocked using
.\"O .BR sigprocmask (2),
.\"O to prevent the signals being handled according to their default
.\"O dispositions.
通常、ファイルディスクリプタ経由で受信するシグナル集合は、
そのシグナルがデフォルトの配送方法に基いて処理されるのを防ぐために、
.BR sigprocmask (2)
を使ってブロックしておくべきである。
.\"O It is not possible to receive
.\"O .B SIGKILL
.\"O or
.\"O .B SIGSTOP
.\"O signals via a signalfd file descriptor;
.\"O these signals are silently ignored if specified in
.\"O .IR mask .
シグナル
.B SIGKILL
と
.B SIGSTOP
を signalfd ファイルディスクリプタ経由で受信することはできない。
これらのシグナルが
.I mask
で指定された場合には黙って無視される。

.\"O If the
.\"O .I fd
.\"O argument is \-1,
.\"O then the call creates a new file descriptor and associates the
.\"O signal set specified in
.\"O .I mask
.\"O with that descriptor.
.\"O If
.\"O .I fd
.\"O is not \-1,
.\"O then it must specify a valid existing signalfd file descriptor, and
.\"O .I mask
.\"O is used to replace the signal set associated with that descriptor.
.I fd
引き数が \-1 の場合、
.BR signalfd ()
は新しいファイルディスクリプタを生成し、
.I mask
で指定されたシグナル集合をそのファイルディスクリプタに関連付ける。
.I fd
引き数が \-1 以外の場合、
.I fd
には有効な既存の signalfd ファイルディスクリプタを指定しなければならず、
そのディスクリプタに関連付けられているシグナル集合は
.I mask
を使って置き換えられる。

.\"O Starting with Linux 2.6.27, the following values may be bitwise ORed in
.\"O .IR flags
.\"O to change the behaviour of
.\"O .BR signalfd ():
Linux 2.6.27 以降では、
以下の値のいくつかをビット単位の論理和 (OR) で指定することで、
.BR signalfd ()
の振舞いを変更することができる。
.TP 14
.B SFD_NONBLOCK
.\"O Set the
.\"O .BR O_NONBLOCK
.\"O file status flag on the new open file description.
.\"O Using this flag saves extra calls to
.\"O .BR fcntl (2)
.\"O to achieve the same result.
新しく生成されるオープンファイル記述 (open file description) の
.B O_NONBLOCK
ファイルステータスフラグをセットする。
このフラグを使うことで、
.B O_NONBLOCK
をセットするために
.BR fcntl (2)
を追加で呼び出す必要がなくなる。
.TP
.B SFD_CLOEXEC
.\"O Set the close-on-exec
.\"O .RB ( FD_CLOEXEC )
.\"O flag on the new file descriptor.
.\"O See the description of the
.\"O .B O_CLOEXEC
.\"O flag in
.\"O .BR open (2)
.\"O for reasons why this may be useful.
新しいファイルディスクリプタに対して
close-on-exec
.RB ( FD_CLOEXEC )
フラグをセットする。
このフラグが役に立つ理由については、
.BR open (2)
の
.B O_CLOEXEC
フラグの説明を参照のこと。
.PP
.\"O In Linux up to version 2.6.26, the
.\"O .I flags
.\"O argument is unused, and must be specified as zero.
バージョン 2.6.26 以前の Linux では、
.I flags
引き数は未使用であり、0 を指定しなければならない。

.\"O .BR signalfd ()
.\"O returns a file descriptor that supports the following operations:
.BR signalfd ()
が返すファイルディスクリプタは以下の操作をサポートしている。
.TP
.BR read (2)
.\"O If one or more of the signals specified in
.\"O .I mask
.\"O is pending for the process, then the buffer supplied to
.\"O .BR read (2)
.\"O is used to return one or more
.\"O .I signalfd_siginfo
.\"O structures (see below) that describe the signals.
.\"O The
.\"O .BR read (2)
.\"O returns information for as many signals as are pending and will
.\"O fit in the supplied buffer.
.\"O The buffer must be at least
.\"O .I "sizeof(struct signalfd_siginfo)"
.\"O bytes.
.\"O The return value of the
.\"O .BR read (2)
.\"O is the total number of bytes read.
.I mask
に指定されているシグナルのうち一つ以上がそのプロセスに対して
処理待ち (pending) であれば、それらのシグナルの情報が
.BR read (2)
に渡されたバッファを使って、
.I signalfd_siginfo
構造体に格納されて返される。
.BR read (2)
は、バッファに格納可能な範囲でできるだけ多くの処理待ちのシグナルに
ついての情報を返す。
バッファは最低でも
.I "sizeof(struct signalfd_siginfo)"
バイトの大きさがなければならない。
.BR read (2)
の返り値は読み出されたトータルのバイト数である。
.IP
.\"O As a consequence of the
.\"O .BR read (2),
.\"O the signals are consumed,
.\"O so that they are no longer pending for the process
.\"O (i.e., will not be caught by signal handlers,
.\"O and cannot be accepted using
.\"O .BR sigwaitinfo (2)).
.BR read (2)
が行われた結果、シグナルは消費され、
これらのシグナルはそのプロセスに対しては処理待ちではなくなる
(つまり、シグナルハンドラで捕捉されることもなく、
.BR sigwaitinfo (2)
を使って受け取ることもできなくなる)。
.IP
.\"O If none of the signals in
.\"O .I mask
.\"O is pending for the process, then the
.\"O .BR read (2)
.\"O either blocks until one of the signals in
.\"O .I mask
.\"O is generated for the process,
.\"O or fails with the error
.\"O .B EAGAIN
.\"O if the file descriptor has been made nonblocking.
.I mask
に指定されているシグナルがそのプロセスに対して一つも処理待ちでなければ、
.BR read (2)
は、
.I mask
で指定されたシグナルのうちいずれか一つがそのプロセスに対して発生するまで
停止 (block) する、もしくはファイルディスクリプタが非停止 (nonblocking)
に設定されている場合はエラー
.B EAGAIN
で失敗する。
.TP
.\"O .BR poll "(2), " select "(2) (and similar)"
.BR poll "(2), " select "(2) (と同様の操作)"
.\"O The file descriptor is readable
.\"O (the
.\"O .BR select (2)
.\"O .I readfds
.\"O argument; the
.\"O .BR poll (2)
.\"O .B POLLIN
.\"O flag)
.\"O if one or more of the signals in
.\"O .I mask
.\"O is pending for the process.
.I mask
に指定されたシグナルのうち一つ以上がそのプロセスに対して処理待ちであれば、
ファイルディスクリプタは読み出し可能となる
.RB ( select (2)
の
.I readfds
引き数や
.BR poll (2)
の
.B POLLIN
フラグ)。
.IP
.\"O The signalfd file descriptor also supports the other file-descriptor
.\"O multiplexing APIs:
.\"O .BR pselect (2),
.\"O .BR ppoll (2),
.\"O and
.\"O .BR epoll (7).
signalfd ファイルディスクリプタは、これ以外のファイルディスクリプタ
多重 API である
.BR pselect (2),
.BR ppoll (2),
.BR epoll (7)
もサポートしている。
.TP
.BR close (2)
.\"O When the file descriptor is no longer required it should be closed.
.\"O When all file descriptors associated with the same signalfd object
.\"O have been closed, the resources for object are freed by the kernel.
ファイルディスクリプタがそれ以降は必要なくなった際には、クローズすべきである。
同じ signalfd オブジェクトに関連付けられたファイルディスクリプタが全て
クローズされると、そのオブジェクト用の資源がカーネルにより解放される。
.\"O .SS The signalfd_siginfo structure
.SS signalfd_siginfo 構造体
.\"O The format of the
.\"O .I signalfd_siginfo
.\"O structure(s) returned by
.\"O .BR read (2)s
.\"O from a signalfd file descriptor is as follows:
signalfd ファイルディスクリプタからの
.BR read (2)
で返される
.I signalfd_siginfo
構造体のフォーマットは以下の通りである。
.in +4n
.nf

struct signalfd_siginfo {
.\"O     uint32_t ssi_signo;   /* Signal number */
.\"O     int32_t  ssi_errno;   /* Error number (unused) */
.\"O     int32_t  ssi_code;    /* Signal code */
.\"O     uint32_t ssi_pid;     /* PID of sender */
.\"O     uint32_t ssi_uid;     /* Real UID of sender */
.\"O     int32_t  ssi_fd;      /* File descriptor (SIGIO) */
.\"O     uint32_t ssi_tid;     /* Kernel timer ID (POSIX timers)
.\"O     uint32_t ssi_band;    /* Band event (SIGIO) */
.\"O     uint32_t ssi_overrun; /* POSIX timer overrun count */
.\"O     uint32_t ssi_trapno;  /* Trap number that caused signal */
.\"O .\" ssi_trapno is unused on most arches
.\"O     int32_t  ssi_status;  /* Exit status or signal (SIGCHLD) */
.\"O     int32_t  ssi_int;     /* Integer sent by sigqueue(3) */
.\"O     uint64_t ssi_ptr;     /* Pointer sent by sigqueue(3) */
.\"O     uint64_t ssi_utime;   /* User CPU time consumed (SIGCHLD) */
.\"O     uint64_t ssi_stime;   /* System CPU time consumed (SIGCHLD) */
.\"O     uint64_t ssi_addr;    /* Address that generated signal
.\"O                              (for hardware-generated signals) */
.\"O     uint8_t  pad[\fIX\fP];      /* Pad size to 128 bytes (allow for
.\"O                               additional fields in the future) */
struct signalfd_siginfo {
    uint32_t ssi_signo;   /* シグナル番号 */
    int32_t  ssi_errno;   /* エラー番号 (未使用) */
    int32_t  ssi_code;    /* シグナルコード */
    uint32_t ssi_pid;     /* 送信元の PID */
    uint32_t ssi_uid;     /* 送信元の実 UID */
    int32_t  ssi_fd;      /* ファイルディスクリプタ (SIGIO) */
    uint32_t ssi_tid;     /* カーネルタイマ ID (POSIX タイマ)
    uint32_t ssi_band;    /* Band イベント (SIGIO) */
    uint32_t ssi_overrun; /* POSIX タイマのオーバーラン回数 */
    uint32_t ssi_trapno;  /* シグナルの原因となったトラップ番号 */
.\" ほとんどのアーキテクチャで ssi_trapno は未使用
    int32_t  ssi_status;  /* 終了ステータスかシグナル (SIGCHLD) */
    int32_t  ssi_int;     /* sigqueue(3) から送られた整数 */
    uint64_t ssi_ptr;     /* sigqueue(3) から送られたポインタ */
    uint64_t ssi_utime;   /* 消費したユーザ CPU 時間 (SIGCHLD) */
    uint64_t ssi_stime;   /* 消費したシステム CPU 時間 (SIGCHLD) */
    uint64_t ssi_addr;    /* シグナルを生成したアドレス
                             (ハードウェアが生成したシグナルの場合) */
    uint8_t  pad[\fIX\fP];      /* pad の大きさは 128 バイト
                             (将来のフィールド追加用の場所の確保) */
};

.fi
.in
.\"O Each of the fields in this structure
.\"O is analogous to the similarly named field in the
.\"O .I siginfo_t
.\"O structure.
.\"O The
.\"O .I siginfo_t
.\"O structure is described in
.\"O .BR sigaction (2).
.I signalfd_siginfo
構造体の各フィールドは、
.I siginfo_t
構造体の同じような名前のフィールドと同様である。
.I siginfo_t
構造体については
.BR sigaction (2)
に説明がある。
.\"O Not all fields in the returned
.\"O .I signalfd_siginfo
.\"O structure will be valid for a specific signal;
.\"O the set of valid fields can be determined from the value returned in the
.\"O .I ssi_code
.\"O field.
.\"O This field is the analog of the
.\"O .I siginfo_t
.\"O .I si_code
.\"O field; see
.\"O .BR sigaction (2)
.\"O for details.
返された
.I signalfd_siginfo
構造体の全てのフィールドがあるシグナルに対して有効なわけではない。
どのフィールドが有効かは、
.I ssi_code
フィールドで返される値から判定することができる。
このフィールドは
.I siginfo_t
の
.I si_code
フィールドと同様である。詳細は
.BR sigaction (2)
を参照。
.\"O .SS fork(2) semantics
.SS fork(2) での扱い
.\"O After a
.\"O .BR fork (2),
.\"O the child inherits a copy of the signalfd file descriptor.
.\"O A
.\"O .BR read (2)
.\"O from the file descriptor in the child will return information
.\"O about signals queued to the child.
.BR fork (2)
が行われると、子プロセスは signalfd ファイルディスクリプタのコピーを
継承する。
子プロセスでこのファイルディスクリプタから
.BR read (2)
を行うと、子プロセスに対するキューに入っているシグナルに関する
情報が返される。
.\"O .SS execve(2) semantics
.SS execve(2) での扱い
.\"O Just like any other file descriptor,
.\"O a signalfd file descriptor remains open across an
.\"O .BR execve (2),
.\"O unless it has been marked for close-on-exec (see
.\"O .BR fcntl (2)).
.\"O Any signals that were available for reading before the
.\"O .BR execve (2)
.\"O remain available to the newly loaded program.
.\"O (This is analogous to traditional signal semantics,
.\"O where a blocked signal that is pending remains pending across an
.\"O .BR execve (2).)
他のファイルディスクリプタと全く同様に、
signalfd ファイルディスクリプタも
.BR execve (2)
の前後でオープンされたままとなる。但し、そのファイルディスクリプタに
close-on-exec のマーク
.RB ( fcntl (2)
参照) が付いている場合はクローズされる。
.BR execve (2)
の前に読み出し可能となっていた全てのシグナルは新しく起動されたプログラム
でも引き続き読み出し可能である
(これは伝統的なシグナルの扱いと同じであり、
処理待ちのブロックされたシグナルは
.BR execve (2)
の前後で処理待ちのままとなる)。
.\"O .SS Thread semantics
.SS スレッドでの扱い
.\"O The semantics of signalfd file descriptors in a multithreaded program
.\"O mirror the standard semantics for signals.
.\"O In other words,
.\"O when a thread reads from a signalfd file descriptor,
.\"O it will read the signals that are directed to the thread
.\"O itself and the signals that are directed to the process
.\"O (i.e., the entire thread group).
.\"O (A thread will not be able to read signals that are directed
.\"O to other threads in the process.)
マルチスレッドプログラムにおける signalfd ファイルディスクリプタの扱いは
シグナルの標準的な扱いと全く同じである。
言い換えると、あるスレッドが signalfd ファイルディスクリプタから
読み出しを行うと、そのスレッド自身宛てのシグナルとプロセス (すなわち
スレッドグループ全体) 宛てのシグナルが読み出される。
(スレッドは同じプロセスの他のスレッド宛てのシグナルを読み出すことはできない。)
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success,
.\"O .BR signalfd ()
.\"O returns a signalfd file descriptor;
.\"O this is either a new file descriptor (if
.\"O .I fd
.\"O was \-1), or
.\"O .I fd
.\"O if
.\"O .I fd
.\"O was a valid signalfd file descriptor.
.\"O On error, \-1 is returned and
.\"O .I errno
.\"O is set to indicate the error.
成功すると、
.BR signalfd ()
は signalfd ファイルディスクリプタを返す。
返されるファイルディスクリプタは、
.IR fd
が \-1 の場合は新規のファイルディスクリプタであり、
.I fd
が有効な signalfd ファイルディスクリプタだった場合は
.I fd
自身である。
エラーの場合、\-1 を返し、
.I errno
にエラーを示す値を設定する。
.\"O .SH ERRORS
.SH エラー
.TP
.B EBADF
.\"O The
.\"O .I fd
.\"O file descriptor is not a valid file descriptor.
ファイルディスクリプタ
.I fd
が有効なファイルディスクリプタでない。
.TP
.B EINVAL
.\"O .I fd
.\"O is not a valid signalfd file descriptor.
.I fd
が有効な signalfd ファイルディスクリプタではない。
.\" or, the
.\" .I sizemask
.\" argument is not equal to
.\" .IR sizeof(sigset_t) ;
.TP
.B EINVAL
.\"O .I flags
.\"O is invalid;
.\"O or, in Linux 2.6.26 or earlier,
.\"O .I flags
.\"O is nonzero.
.I flags
が無効。
Linux 2.6.26 以前では、
.I flags
が 0 以外の値。
.TP
.B EMFILE
.\"O The per-process limit of open file descriptors has been reached.
オープン済みのファイルディスクリプタの数がプロセスあたりの上限に
達していた。
.TP
.B ENFILE
.\"O The system-wide limit on the total number of open files has been
.\"O reached.
オープン済みのファイル総数がシステム全体の上限に達していた。
.TP
.B ENODEV
.\"O Could not mount (internal) anonymous inode device.
(カーネル内の) 無名 inode デバイスをマウントできなかった。
.TP
.B ENOMEM
.\"O There was insufficient memory to create a new signalfd file descriptor.
新しい signalfd ファイルディスクリプタを生成するのに十分なメモリがなかった。
.\"O .SH VERSIONS
.SH バージョン
.\"O .BR signalfd ()
.\"O is available on Linux since kernel 2.6.22.
.\"O Working support is provided in glibc since version 2.8.
.BR signalfd ()
はカーネル 2.6.22 以降の Linux で利用可能である。
正しく動作する glibc 側のサポートはバージョン 2.8 以降で提供されている。
.\" signalfd() is in glibc 2.7, but reportedly does not build
.\"O The
.\"O .BR signalfd4 ()
.\"O system call (see NOTES) is available on Linux since kernel 2.6.27.
.BR signalfd4 ()
システムコール (「注意」参照) は
カーネル 2.6.27 以降の Linux で利用可能である。
.\"O .SH CONFORMING TO
.SH 準拠
.\"O .BR signalfd ()
.\"O and
.\"O .BR signalfd4 ()
.\"O are Linux-specific.
.BR signalfd ()
と
.BR signalfd4 ()
は Linux 固有である。
.\"O .SH NOTES
.SH 注意
.\"O The underlying Linux system call requires an additional argument,
.\"O .IR "size_t sizemask" ,
.\"O which specifies the size of the
.\"O .I mask
.\"O argument.
.\"O The glibc
.\"O .BR signalfd ()
.\"O wrapper function does not include this argument,
.\"O since it provides the required value for the underlying system call.
実際の Linux のシステムコールでは
.I "size_t sizemask"
という引き数が追加で必要である。この引き数で
.I mask
のサイズを指定する。
glibc の
.BR signalfd ()
ラッパー関数にはこの引き数は含まれず、
ラッパー関数が必要な値を計算して内部で呼び出すシステムコールに提供する。

.\"O A process can create multiple signalfd file descriptors.
.\"O This makes it possible to accept different signals
.\"O on different file descriptors.
.\"O (This may be useful if monitoring the file descriptors using
.\"O .BR select (2),
.\"O .BR poll (2),
.\"O or
.\"O .BR epoll (7):
.\"O the arrival of different signals will make different descriptors ready.)
.\"O If a signal appears in the
.\"O .I mask
.\"O of more than one of the file descriptors, then occurrences
.\"O of that signal can be read (once) from any one of the descriptors.
一つのプロセスは複数の signalfd ファイルディスクリプタを生成することができる。
これにより、異なるファイルディスクリプタで異なるシグナルを受け取ることが
できる (この機能は
.BR select (2),
.BR poll (2),
.BR epoll (7)
を使ってファイルディスクリプタを監視する場合に有用かもしれない。
異なるシグナルが到着すると、異なるファイルディスクリプタが利用可能に
なるからだ)。
一つのシグナルが二つ以上のファイルディスクリプタの
.I mask
に含まれている場合、そのシグナルの発生はそのシグナルを
.I mask
に含むファイルディスクリプタのうちいずれか一つから読み出すことができる。
.\"O .SS Underlying Linux system calls
.SH 下層にある Linux のシステムコール
.\"O There are two underlying Linux system calls:
.\"O .BR signalfd ()
.\"O and the more recent
.\"O .BR signalfd4 ().
.\"O The former system call does not implement a
.\"O .I flags
.\"O argument.
.\"O The latter system call implements the
.\"O .I flags
.\"O values described above.
下層にある Linux システムコールは二種類あり、
.BR signalfd ()
と、もっと新しい
.BR signalfd4 ()
である。
.BR signalfd ()
は
.I flags
引き数を実装していない。
.BR signalfd4 ()
では上記の値の
.I flags
が実装されている。
.\"O Starting with glibc 2.9, the
.\"O .BR signalfd ()
.\"O wrapper function will use
.\"O .BR signalfd4 ()
.\"O where it is available.
glibc 2.9 以降では、
.BR signalfd ()
のラッパー関数は、
.BR signalfd4 ()
が利用可能であれば、これを使用する。
.\"O .SH BUGS
.SH バグ
.\"O In kernels before 2.6.25, the
.\"O .I ssi_ptr
.\"O and
.\"O .I ssi_int
.\"O fields are not filled in with the data accompanying a signal sent by
.\"O .BR sigqueue (3).
カーネル 2.6.25 より前では、
.BR sigqueue (3)
により送信されたシグナルと一緒に渡されるデータでは、フィールド
.I ssi_ptr
と
.I ssi_int
は設定されない。
.\" The fix also was put into 2.6.24.5
.\"O .SH EXAMPLE
.SH 例
.\"O The program below accepts the signals
.\"O .B SIGINT
.\"O and
.\"O .B SIGQUIT
.\"O via a signalfd file descriptor.
.\"O The program terminates after accepting a
.\"O .B SIGQUIT
.\"O signal.
.\"O The following shell session demonstrates the use of the program:
下記のプログラムは、シグナル
.B SIGINT
と
.B SIGQUIT
を signalfd ファイルディスクリプタ経由で受信する。
シグナル
.B SIGQUIT
受信後にプログラムは終了する。
以下に示すシェルセッションにこのプログラムの使い方を示す。
.in +4n
.nf

.RB "$" " ./signalfd_demo"
.BR "^C" "                   # Control\-C generates SIGINT"
Got SIGINT
.B ^C
Got SIGINT
\fB^\\\fP                    # Control\-\\ generates SIGQUIT
Got SIGQUIT
$
.fi
.in
.\"O .SS Program source
.SS プログラムのソース
\&
.nf
#include <sys/signalfd.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

#define handle_error(msg) \\
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    sigset_t mask;
    int sfd;
    struct signalfd_siginfo fdsi;
    ssize_t s;

    sigemptyset(&mask);
    sigaddset(&mask, SIGINT);
    sigaddset(&mask, SIGQUIT);

    /* Block signals so that they aren\(aqt handled
       according to their default dispositions */

    if (sigprocmask(SIG_BLOCK, &mask, NULL) == \-1)
        handle_error("sigprocmask");

    sfd = signalfd(\-1, &mask, 0);
    if (sfd == \-1)
        handle_error("signalfd");

    for (;;) {
        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));
        if (s != sizeof(struct signalfd_siginfo))
            handle_error("read");

        if (fdsi.ssi_signo == SIGINT) {
            printf("Got SIGINT\\n");
        } else if (fdsi.ssi_signo == SIGQUIT) {
            printf("Got SIGQUIT\\n");
            exit(EXIT_SUCCESS);
        } else {
            printf("Read unexpected signal\\n");
        }
    }
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR eventfd (2),
.BR poll (2),
.BR read (2),
.BR select (2),
.BR sigaction (2),
.BR sigprocmask (2),
.BR sigwaitinfo (2),
.BR timerfd_create (2),
.BR sigsetops (3),
.BR sigwait (3),
.BR epoll (7),
.BR signal (7)

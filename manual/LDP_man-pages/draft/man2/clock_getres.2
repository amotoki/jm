.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 2003 Nick Clifford (zaf@nrc.co.nz), Jan 25, 2003
.\" Copyright (c) 2003 Andries Brouwer (aeb@cwi.nl), Aug 24, 2003
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" 2003-08-23 Martin Schulze <joey@infodrom.org> improvements
.\" 2003-08-24 aeb, large parts rewritten
.\" 2004-08-06 Christoph Lameter <clameter@sgi.com>, SMP note
.\"
.\" FIXME: Linux 2.6.39 adds CLOCK_BOOTTIME
.\"
.\" Japanese Version Copyright (c) 2004-2005 Yuichi SATO
.\"         all rights reserved.
.\" Translated 2004-07-19, Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated & Modified 2005-01-10, Yuichi SATO
.\" Updated 2010-04-11, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.TH CLOCK_GETRES 2 2010-02-03 "" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O clock_getres, clock_gettime, clock_settime \- clock and time functions
clock_getres, clock_gettime, clock_settime \- クロックと時間の関数
.\"O .SH SYNOPSIS
.SH 書式
.B #include <time.h>
.sp
.BI "int clock_getres(clockid_t " clk_id ", struct timespec *" res );

.BI "int clock_gettime(clockid_t " clk_id ", struct timespec *" tp );

.BI "int clock_settime(clockid_t " clk_id ", const struct timespec *" tp );
.sp
.\"O Link with \fI\-lrt\fP.
\fI\-lrt\fP とリンクする。
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.ad l
.BR clock_getres (),
.BR clock_gettime (),
.BR clock_settime ():
.RS
_POSIX_C_SOURCE\ >=\ 199309L
.RE
.ad b
.\"O .SH DESCRIPTION
.SH 説明
.\"O The function
.\"O .BR clock_getres ()
.\"O finds the resolution (precision) of the specified clock
.\"O .IR clk_id ,
.\"O and, if
.\"O .I res
.\"O is non-NULL, stores it in the \fIstruct timespec\fP pointed to by
.\"O .IR res .
関数
.BR clock_getres ()
は
指定されたクロック
.I clk_id
の分解能 (精度) を探し出す。
.I res
が NULL でない場合、その分解能を
.I res
で指される \fIstruct timespec\fP に格納する。
.\"O The resolution of clocks depends on the implementation and cannot be
.\"O configured by a particular process.
クロックの分解能は実装に依存し、
特定のプロセスによって設定することはできない。
.\"O If the time value pointed to by the argument
.\"O .I tp
.\"O of
.\"O .BR clock_settime ()
.\"O is not a multiple of
.\"O .IR res ,
.\"O then it is truncated to a multiple of
.\"O .IR res .
.BR clock_settime ()
の引き数
.I tp
で指される時間の値が
.I res
の倍数でない場合、
.I res
の倍数に切り詰められる。
.PP
.\"O The functions
.\"O .BR clock_gettime ()
.\"O and
.\"O .BR clock_settime ()
.\"O retrieve and set the time of the specified clock
.\"O .IR clk_id .
関数
.BR clock_gettime ()
と
.BR clock_settime ()
は、指定されたクロック
.I clk_id
の時間を取得または設定する。
.PP
.\"O The
.\"O .I res
.\"O and
.\"O .I tp
.\"O arguments are
.\"O .I timespec
.\"O structures, as specified in
.\"O .IR <time.h> :
.I res
と
.I tp
引き数は
.I timespec
構造体であり、
.I <time.h>
で以下のように規定されている:
.sp
.in +4n
.nf
struct timespec {
    time_t   tv_sec;        /* seconds */
    long     tv_nsec;       /* nanoseconds */
};
.fi
.in
.PP
.\"O The
.\"O .I clk_id
.\"O argument is the identifier of the particular clock on which to act.
.I clk_id
引き数は特定のクロックの識別子であり、そのクロックで動作する。
.\"O A clock may be system-wide and hence visible for all processes, or
.\"O per-process if it measures time only within a single process.
クロックはシステム全体に適用することもでき、
その場合は全てのプロセスから見ることができる。
また 1 つのプロセス内でのみ時間を計測する場合は、
プロセス毎に適用することもできる。
.LP
.\"O All implementations support the system-wide real-time clock,
.\"O which is identified by
.\"O .BR CLOCK_REALTIME .
全ての実装においてシステム全体のリアルタイムクロックがサポートされ、
.B CLOCK_REALTIME
で識別される。
.\"O Its time represents seconds and nanoseconds since the Epoch.
時間は紀元 (the Epoch) からの秒とナノ秒で表される。
.\"O When its time is changed, timers for a relative interval are
.\"O unaffected, but timers for an absolute point in time are affected.
時間が変更された場合、相対的な時間間隔のタイマは影響を受けないが、
絶対的な時点のタイマは影響を受ける。
.LP
.\"O More clocks may be implemented.
.\"O The interpretation of the
.\"O corresponding time values and the effect on timers is unspecified.
さらにいくつかのクロックが実装されているかもしれない。
対応する時間の値を解釈する方法とタイマへの影響は、定められていない。
.LP
.\"O Sufficiently recent versions of glibc and the Linux kernel
.\"O support the following clocks:
glibc と Linux カーネルの最新のバージョンでは、
以下のような十分なクロックがサポートされている。
.TP
.B CLOCK_REALTIME
.\"O System-wide real-time clock.
システム全体のリアルタイムクロック。
.\"O Setting this clock requires appropriate privileges.
このクロックを設定するには適切な特権が必要である。
.TP
.B CLOCK_MONOTONIC
.\"O Clock that cannot be set and represents monotonic time since
.\"O some unspecified starting point.
いくつかの開始点が指定されていないため、
クロックがモノトニックタイムを設定したり表現したりできない。
.TP
.\"O .BR CLOCK_MONOTONIC_RAW " (since Linux 2.6.28; Linux-specific)"
.BR CLOCK_MONOTONIC_RAW " (Linux 2.6.28 以降; Linux 特有)"
.\" Added in commit 2d42244ae71d6c7b0884b5664cf2eda30fb2ae68, John Stultz
.\"O Similar to
.\"O .BR CLOCK_MONOTONIC ,
.\"O but provides access to a raw hardware-based time
.\"O that is not subject to NTP adjustments.
.B CLOCK_MONOTONIC
と同様だが、NTP による調整の影響を受けない、ハードウェアによる
生の時刻へのアクセスができる。
.TP
.B CLOCK_PROCESS_CPUTIME_ID
.\"O High-resolution per-process timer from the CPU.
CPU による高分解能のプロセス毎のタイマ。
.TP
.B CLOCK_THREAD_CPUTIME_ID
.\"O Thread-specific CPU-time clock.
スレッド固有の CPU タイムクロック。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O .BR clock_gettime (),
.\"O .BR clock_settime ()
.\"O and
.\"O .BR clock_getres ()
.\"O return 0 for success, or \-1 for failure (in which case
.\"O .I errno
.\"O is set appropriately).
.BR clock_gettime (),
.BR clock_settime (),
.BR clock_getres ()
は成功した場合に 0 を返し、失敗した場合に \-1 を返す
(失敗した場合、
.I errno
が適切に設定される)。
.\"O .SH ERRORS
.SH エラー
.TP
.B EFAULT
.\"O .I tp
.\"O points outside the accessible address space.
.I tp
がアクセス可能なアドレス空間の外を指した。
.TP
.B EINVAL
.\"O The
.\"O .I clk_id
.\"O specified is not supported on this system.
.\" Linux also gives this error on attempts to set CLOCK_PROCESS_CPUTIME_ID
.\" and CLOCK_THREAD_CPUTIME_ID, when probably the proper error should be
.\" EPERM.
指定された
.I clk_id
がこのシステムでサポートされていない。
.TP
.B EPERM
.\"O .BR clock_settime ()
.\"O does not have permission to set the clock indicated.
指示されたクロックを設定する権限が
.BR clock_settime ()
にない。
.\"O .SH "CONFORMING TO"
.SH 準拠
SUSv2, POSIX.1-2001.
.\"O .SH AVAILABILITY
.SH 可用性
.\"O On POSIX systems on which these functions are available, the symbol
.\"O .B _POSIX_TIMERS
.\"O is defined in \fI<unistd.h>\fP to a value greater than 0.
これらの関数が利用可能な POSIX システムでは、\fI<unistd.h>\fP においてシンボル
.B _POSIX_TIMERS
が 0 より大きい値に定義されている。
.\"O The symbols
.\"O .BR _POSIX_MONOTONIC_CLOCK ,
.\"O .BR _POSIX_CPUTIME ,
.\"O .B _POSIX_THREAD_CPUTIME
.\"O indicate that
.\"O .BR CLOCK_MONOTONIC ,
.\"O .BR CLOCK_PROCESS_CPUTIME_ID ,
.\"O .B CLOCK_THREAD_CPUTIME_ID
.\"O are available.
シンボル
.BR _POSIX_MONOTONIC_CLOCK ,
.BR _POSIX_CPUTIME ,
.B _POSIX_THREAD_CPUTIME
は
.BR CLOCK_MONOTONIC ,
.BR CLOCK_PROCESS_CPUTIME_ID ,
.B CLOCK_THREAD_CPUTIME_ID
が利用可能なことを示す。
.\"O (See also
.\"O .BR sysconf (3).)
.RB ( sysconf (3)
も参照すること。)
.\"O .SH NOTES
.SH 注意
.\"O .SS Note for SMP systems
.SS "SMP システムについての注意"
.\"O The
.\"O .B CLOCK_PROCESS_CPUTIME_ID
.\"O and
.\"O .B CLOCK_THREAD_CPUTIME_ID
.\"O clocks are realized on many platforms using timers from the CPUs
.\"O (TSC on i386, AR.ITC on Itanium).
.B CLOCK_PROCESS_CPUTIME_ID
と
.B CLOCK_THREAD_CPUTIME_ID
クロックは、CPU からのタイマ
(i386 上の TSC、Itanium 上の AR.ITC) を用いて実現されている。
.\"O These registers may differ between CPUs and as a consequence
.\"O these clocks may return
.\"O .B bogus results
.\"O if a process is migrated to another CPU.
これらのレジスタは CPU 間で異なる可能性があり、
プロセスが他の CPU に移動させられた場合、
結果としてこれらのクロックが\fB偽の結果\fR
(bogus results) を返すかもしれない。
.PP
.\"O If the CPUs in an SMP system have different clock sources then
.\"O there is no way to maintain a correlation between the timer registers since
.\"O each CPU will run at a slightly different frequency.
.\"O If that is the case then
.\"O .I clock_getcpuclockid(0)
.\"O will return
.\"O .B ENOENT
.\"O to signify this condition.
.\"O The two clocks will then only be useful if it
.\"O can be ensured that a process stays on a certain CPU.
SMP システムの各 CPU が別々のクロック源を持つ場合、
タイマレジスタ間の相互関係を管理する方法はない。
これは各 CPU が微妙に異なる周波数で動作するためである。
これが真実の場合 (訳註: 各 CPU が別々のクロック源を持つ場合)、
.I clock_getcpuclockid(0)
は
.B ENOENT
を返して、その状況を表す。
2 つのクロックは、プロセスが特定の CPU 上に留まっていることが
保証できる場合にのみ有効である。
.PP
.\"O The processors in an SMP system do not start all at exactly the same
.\"O time and therefore the timer registers are typically running at an offset.
SMP システムの各プロセッサは全く同じ時刻に起動する訳ではないので、
各タイマレジスタは通常はあるオフセットで動作している。
.\"O Some architectures include code that attempts to limit these offsets on bootup.
オフセットをブート時に制限するコードが含まれるアーキテクチャもある。
.\"O However, the code cannot guarantee to accurately tune the offsets.
しかし、このコードがオフセットを正確に調整することは保証できない。
.\"O Glibc contains no provisions to deal with these offsets (unlike the Linux
.\"O Kernel).
.\"O Typically these offsets are small and therefore the effects may be
.\"O negligible in most cases.
glibc は (Linux カーネルとは異なり) オフセットを扱うためのコードを提供しない。
通常はこれらのオフセットが小さいので、多くの場合でその影響は無視できる。
.\"O .SH BUGS
.SH バグ
.\"O According to POSIX.1-2001, a process with "appropriate privileges" may set the
.\"O .B CLOCK_PROCESS_CPUTIME_ID
.\"O and
.\"O .B CLOCK_THREAD_CPUTIME_ID
.\"O clocks using
.\"O .BR clock_settime ().
.\"O On Linux, these clocks are not settable
.\"O (i.e., no process has "appropriate privileges").
POSIX.1-2001 では、
「適切な特権 (appropriate privileges)」を持ったプロセスは、
.BR clock_settime ()
を使って、クロック
.B CLOCK_PROCESS_CPUTIME_ID
と
.B CLOCK_THREAD_CPUTIME_ID
を設定することができるとされている。
Linux では、これらのクロックは設定可能ではない
(すなわち、どのプロセスも「適切な特権」を持たない)。
.\" See http://bugzilla.kernel.org/show_bug.cgi?id=11972
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR date (1),
.BR adjtimex (2),
.BR gettimeofday (2),
.BR settimeofday (2),
.BR time (2),
.BR clock_getcpuclockid (3),
.BR ctime (3),
.BR ftime (3),
.BR pthread_getcpuclockid (3),
.BR sysconf (3),
.BR time (7)

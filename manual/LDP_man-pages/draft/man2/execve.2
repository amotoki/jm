.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt (drew@cs.colorado.edu), March 28, 1992
.\" and Copyright (c) 2006 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 1993-07-21 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1994-08-21 by Michael Chastain <mec@shell.portal.com>:
.\" Modified 1997-01-31 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 1999-11-12 by Urs Thuermann <urs@isnogud.escape.de>
.\" Modified 2004-06-23 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" 2006-09-04 Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added list of process attributes that are not preserved on exec().
.\" 2007-09-14 Ollie Wild <aaw@google.com>, mtk
.\"     Add text describing limits on command-line arguments + environment
.\"
.\" Japanese Version Copyright (c) 1996 TABATA Tomohira
.\"         all rights reserved.
.\" Translated 1996-07-04, TABATA Tomohira <loba@k2.t.u-tokyo.ac.jp>
.\" Updated 1997-12-14, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 2001-08-17, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 2005-02-05, Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated 2005-09-06, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-11-19, Akihiro MOTOKI
.\" Updated 2006-08-13, Akihiro MOTOKI, LDP v2.39
.\" Updated 2007-01-09, Akihiro MOTOKI, LDP v2.43
.\" Updated 2007-06-03, Akihiro MOTOKI, LDP v2.51
.\" Updated 2007-10-12, Akihiro MOTOKI, LDP v2.66
.\" Updated 2008-04-04, Akihiro MOTOKI, LDP v2.79
.\" Updated 2008-11-05, Akihiro MOTOKI, LDP v3.12
.\"
.TH EXECVE 2 2010-01-06 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O execve \- execute program
execve \- プログラムを実行する
.\"O .SH SYNOPSIS
.SH 書式
.B #include <unistd.h>
.sp
.BI "int execve(const char *" filename ", char *const " argv "[], "
.br
.BI "           char *const " envp []);
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR execve ()
.\"O executes the program pointed to by \fIfilename\fP.
.\"O \fIfilename\fP must be either a binary executable, or a script
.\"O starting with a line of the form:
.BR execve ()
は、\fIfilename\fP によって指定されたプログラムを実行する。
\fIfilename\fP は、バイナリ実行形式か、
以下の形式の行で始まるスクリプトでなければならない。

.in +4n
.nf
\fB#!\fP \fIinterpreter \fP[optional-arg]
.fi
.in

.\"O For details of the latter case, see "Interpreter scripts" below.
後者の詳細は、後ろの「インタプリタ・スクリプト」の節を参照のこと。

.\"O \fIargv\fP is an array of argument strings passed to the new program.
.\"O \fIenvp\fP is an array of strings, conventionally of the form
.\"O \fBkey=value\fP, which are passed as environment to the new program.
.\"O Both \fIargv\fP and \fIenvp\fP must be terminated by a null pointer.
.\"O The argument vector and environment can be accessed by the
.\"O called program's main function, when it is defined as:
\fIargv\fP は新しいプログラムに渡される引き数文字列の配列である。
\fIenvp\fP は文字列の配列であり、伝統的に \fBkey=value\fP の形式を
しており、新しいプログラムの環境変数として渡される。
\fIargv\fP と \fIenvp\fP はいずれもの NULL ポインタで終わっている
必要がある。引き数配列と環境変数は、呼び出されたプログラムの main 関数を
以下のように定義することによってアクセス可能になる。

.in +4n
.nf
int main(int argc, char *argv[], char *envp[])
.fi
.in

.\"O .BR execve ()
.\"O does not return on success, and the text, data, bss, and
.\"O stack of the calling process are overwritten by that of the program
.\"O loaded.
成功した場合、
.BR execve ()
は返らない。
そして、呼び出し元のプロセスの text, data, bss, スタックは、
読み込まれたプログラムによって上書きされる。

.\"O If the current program is being ptraced, a \fBSIGTRAP\fP is sent to it
.\"O after a successful
.\"O .BR execve ().
元のプログラムが ptrace されている場合、
.BR execve ()
が成功した後に
そのプログラムに \fBSIGTRAP\fP が送られる。

.\"O If the set-user-ID bit is set on the program file pointed to by
.\"O \fIfilename\fP,
.\"O and the underlying file system is not mounted
.\"O .I nosuid
.\"O (the
.\"O .B MS_NOSUID
.\"O flag for
.\"O .BR mount (2)),
.\"O and the calling process is not being ptraced,
.\"O then the effective user ID of the calling process is changed
.\"O to that of the owner of the program file.
.\"O Similarly, when the set-group-ID
.\"O bit of the program file is set the effective group ID of the calling
.\"O process is set to the group of the program file.
.I filename
で指定されたプログラムファイルに set-user-ID ビットが設定されており、
ファイルが存在するファイルシステムが
.I nosuid
.RB ( mount (2)
の
.B MS_NOSUID
フラグ) でマウントされておらず、
呼び出したプロセスが ptrace されていない場合、
呼び出したプロセスの実効 (effective) ユーザ ID は
プログラムファイルの所有者 (owner) に変更される。
同様に、プログラムファイルに set-group-ID ビットが設定されていた場合、
呼び出したプロセスの有効グループ ID は
プログラムファイルのグループに変更される。

.\"O The effective user ID of the process is copied to the saved set-user-ID;
.\"O similarly, the effective group ID is copied to the saved set-group-ID.
.\"O This copying takes place after any effective ID changes that occur
.\"O because of the set-user-ID and set-group-ID permission bits.
プロセスの実効ユーザ ID は保存 (saved) set-user-ID にコピーされる。
同様に、実効グループ ID は保存 set-group-ID にコピーされる。
このコピーは、set-user-ID / set-group-ID 許可ビットにより発生する
実効 ID の変更後に行われる。

.\"O If the executable is an a.out dynamically linked
.\"O binary executable containing
.\"O shared-library stubs, the Linux dynamic linker
.\"O .BR ld.so (8)
.\"O is called at the start of execution to bring
.\"O needed shared libraries into memory
.\"O and link the executable with them.
実行ファイルが動的リンクされた a.out 実行形式で、共有ライブラリの
スタブを含むものだった場合、実行の開始時に Linux の
ダイナミック・リンカ
.BR ld.so (8)
が呼び出され、必要な共有ライブラリをメモリに読み込んでリンクを行う。

.\"O If the executable is a dynamically linked ELF executable, the
.\"O interpreter named in the PT_INTERP segment is used to load the needed
.\"O shared libraries.
.\"O This interpreter is typically
.\"O \fI/lib/ld-linux.so.1\fP for binaries linked with the
.\"O Linux libc 5, or \fI/lib/ld-linux.so.2\fP for binaries linked with the
.\"O glibc 2.
実行ファイルがダイナミック・リンクされた ELF 実行形式だった場合、
PT_INTERP セグメントに指定されたインタプリタが必要な
共有ライブラリ (shared library) を読み込むのに使用される。
通常、インタプリタとしては、
Linux libc 5 をリンクしたバイナリの場合には
\fI/lib/ld-linux.so.1\fP が、
glibc 2 をリンクしたバイナリの場合には
\fI/lib/ld-linux.so.2\fP が使用される。

.\"O All process attributes are preserved during an
.\"O .BR execve (),
.\"O except the following:
以下に示す以外のすべてのプロセス属性は
.BR execve ()
の前後で保持される。
.IP *
.\"O The dispositions of any signals that are being caught are
.\"O reset to the default
.\"O .RB ( signal (7)).
捕捉されたシグナルの処理方法 (disposition) は
デフォルト動作にリセットされる
.RB ( signal (7))。
.IP *
.\"O Any alternate signal stack is not preserved
.\"O .RB ( sigaltstack (2)).
代替シグナルスタックはどれも保持されない
.RB ( sigaltstack (2))。
.IP *
.\"O Memory mappings are not preserved
.\"O .RB ( mmap (2)).
メモリマッピングは保持されない
.RB ( mmap (2))。
.IP *
.\"O Attached System V shared memory segments are detached
.\"O .RB ( shmat (2)).
付加された (attached) System V 共有メモリセグメントは分離される
.RB ( shmat (2))。
.IP *
.\"O POSIX shared memory regions are unmapped
.\"O .RB ( shm_open (3)).
POSIX 共有メモリ領域はマッピングを解除される
.RB ( shm_open (3))。
.IP *
.\"O Open POSIX message queue descriptors are closed
.\"O .RB ( mq_overview (7)).
オープンされた POSIX メッセージキューディスクリプタはクローズされる
.RB ( mq_overview (7))。
.IP *
.\"O Any open POSIX named semaphores are closed
.\"O .RB ( sem_overview (7)).
オープンされた POSIX 名前付きセマフォはいずれもクローズされる
.RB ( sem_overview (7))。
.IP *
.\"O POSIX timers are not preserved
.\"O .RB ( timer_create (2)).
POSIX タイマは保持されない
.RB ( timer_create (2))。
.IP *
.\"O Any open directory streams are closed
.\"O .RB ( opendir (3)).
オープンされたディレクトリストリームはいずれもクローズされる
.RB ( opendir (3))。
.IP *
.\"O Memory locks are not preserved
.\"O .RB ( mlock (2),
.\"O .BR mlockall (2)).
メモリロックは保持されない
.RB ( mlock (2),
.BR mlockall (2))。
.IP *
.\"O Exit handlers are not preserved
.\"O .RB ( atexit (3),
.\"O .BR on_exit (3)).
終了 (exit) ハンドラは保持されない
.RB ( atexit (3),
.BR on_exit (3))。
.IP *
.\"O The floating-point environment is reset to the default (see
.\"O .BR fenv (3)).
浮動小数点関連の環境はデフォルトにリセットされる
.RB ( fenv (3)
参照)。
.PP
.\"O The process attributes in the preceding list are all specified
.\"O in POSIX.1-2001.
.\"O The following Linux-specific process attributes are also
.\"O not preserved during an
.\"O .BR execve ():
上記のリストのプロセス属性はいずれも POSIX.1-2001 で規定されている。
以下に示す Linux 固有のプロセス属性も
.BR execve ()
の前後で保持されない。
.IP * 3
.\"O The
.\"O .BR prctl (2)
.\"O .B PR_SET_DUMPABLE
.\"O flag is set,
.\"O unless a set-user-ID or set-group ID program is being executed,
.\"O in which case it is cleared.
set-user-ID か set-group-ID されたプログラムが実行されている場合、
.BR prctl (2)
の
.B PR_SET_DUMPABLE
フラグはクリアされる。それ以外の場合、このフラグはセットされる。
.IP *
.\"O The
.\"O .BR prctl (2)
.\"O .B PR_SET_KEEPCAPS
.\"O flag is cleared.
.BR prctl (2)
の
.B PR_SET_KEEPCAPS
フラグはクリアされる。
.IP *
.\"O The process name, as set by
.\"O .BR prctl (2)
.\"O .B PR_SET_NAME
.\"O (and displayed by
.\"O .IR "ps\ \-o comm" ),
.\"O is reset to the name of the new executable file.
プロセス名は新しい実行ファイルの名前にリセットされる。
プロセス名は
.BR prctl (2)
の
.B PR_SET_NAME
で設定でき、
.I "ps\ \-o comm"
で表示できる。
.IP *
.\"O The termination signal is reset to
.\"O .B SIGCHLD
.\"O (see
.\"O .BR clone (2)).
終了シグナル (termination signal) は
.B SIGCHLD
にリセットされる
.RB ( clone (2)
参照)。
.PP
.\"O Note the following further points:
以下の点についても注意すること:
.IP * 3
.\"O All threads other than the calling thread are destroyed during an
.\"O .BR execve ().
.\"O Mutexes, condition variables, and other pthreads objects are not preserved.
呼び出し元スレッド以外の全てのスレッドは
.BR execve ()
中に破棄される。
mutex、条件変数、その他の pthread オブジェクトは保持されない。
.IP *
.\"O The equivalent of \fIsetlocale(LC_ALL, "C")\fP
.\"O is executed at program start-up.
\fIsetlocale(LC_ALL, "C")\fP 相当の処理がプログラム開始時に実行される。
.IP *
.\"O POSIX.1-2001 specifies that the dispositions of any signals that
.\"O are ignored or set to the default are left unchanged.
.\"O POSIX.1-2001 specifies one exception: if
.\"O .B SIGCHLD
.\"O is being ignored,
.\"O then an implementation may leave the disposition unchanged or
.\"O reset it to the default; Linux does the former.
POSIX.1-2001 は、動作が無視かデフォルトに設定されている全てのシグナル
の処理方法は変更せずそのままにする、と規定している。
但し、POSIX.1-2001 には一つ例外があり、
.B SIGCHLD
が無視になっている場合、
その処理方法を変更せずにそのままにするか、デフォルト動作にリセットするかは
実装依存となっている。
Linux では前者 (変更しない) となっている。
.IP *
.\"O Any outstanding asynchronous I/O operations are canceled
.\"O .RB ( aio_read (3),
.\"O .BR aio_write (3)).
完了していない非同期 I/O 操作はキャンセルされる
.RB ( aio_read (3),
.BR aio_write (3))。
.IP *
.\"O For the handling of capabilities during
.\"O .BR execve (),
.\"O see
.\"O .BR capabilities (7).
.BR execve (2)
時のケーパビリティの扱いについては、
.BR capabilities (7)
を参照。
.IP *
.\"O By default, file descriptors remain open across an
.\"O .BR execve ().
.\"O File descriptors that are marked close-on-exec are closed;
.\"O see the description of
.\"O .B FD_CLOEXEC
.\"O in
.\"O .BR fcntl (2).
.\"O (If a file descriptor is closed, this will cause the release
.\"O of all record locks obtained on the underlying file by this process.
.\"O See
.\"O .BR fcntl (2)
.\"O for details.)
デフォルトでは、ファイルディスクリプタは
.BR execve ()
を行った後でもオープンされたままである。
close-on-exec の印が付いているファイルディスクリプタはクローズされる。
.BR fcntl (2)
の
.B FD_CLOEXEC
の説明を参照。
(ファイルディスクリプタがクローズされると、このプロセスが
ファイルディスクリプタに対応するファイルに対して獲得していた
レコードのロックが全て解放されることになる。)
.\"O POSIX.1-2001 says that if file descriptors 0, 1, and 2 would
.\"O otherwise be closed after a successful
.\"O .BR execve (),
.\"O and the process would gain privilege because the set-user_ID or
.\"O set-group_ID permission bit was set on the executed file,
.\"O then the system may open an unspecified file for each of these
.\"O file descriptors.
.\"O As a general principle, no portable program, whether privileged or not,
.\"O can assume that these three file descriptors will remain
.\"O closed across an
.\"O .BR execve ().
POSIX.1-2001 では、
ファイルディスクリプタ 0, 1, 2 が
.BR execve ()
成功後にどこかでクローズされ、かつ
実行されるファイルに set-user_ID か set-group_ID の許可ビットが
セットされていてプロセスが特権を獲得した場合、
システムは何らかのファイルをオープンする際に
これらの番号のディスクリプタのどれかを使うことがある、
とされている。
原則として、移植性が必要なプログラムでは、
特権の有無に関わらず、
.BR execve ()
の前後でこれら 3つのファイルディスクリプタがクローズされたままで
あることを前提にすることはできない。
.\" On Linux it appears that these file descriptors are
.\" always open after an execve(), and it looks like
.\" Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
.\"O .SS Interpreter scripts
.SS インタプリタ・スクリプト
.\"O An interpreter script is a text file that has execute
.\"O permission enabled and whose first line is of the form:
インタプリタ・スクリプトとは、実行許可が有効になっていて、
最初の行が以下の形になっているテキストファイルのことである。

.in +4n
.nf
\fB#!\fP \fIinterpreter \fP[optional-arg]
.fi
.in

.\"O The
.\"O .I interpreter
.\"O must be a valid pathname for an
.\"O executable which is not itself a script.
.I interpreter
は有効な実行ファイルのパス名でなければならず、
それ自身がスクリプトであってはならない。
.\"O If the
.\"O .I filename
.\"O argument of
.\"O .BR execve ()
.\"O specifies an interpreter script, then
.\"O .I interpreter
.\"O will be invoked with the following arguments:
.BR execve ()
の
.I filename
引き数がインタプリタスクリプトを指定している場合、
.I interpreter
は以下の引き数で起動される。

.in +4n
.nf
\fIinterpreter\fP [optional-arg] \fIfilename\fP arg...
.fi
.in

.\"O where
.\"O .I arg...
.\"O is the series of words pointed to by the
.\"O .I argv
.\"O argument of
.\"O .BR execve ().
.I arg...
は
.BR execve ()
の
.I argv
引き数が指すワード列である。

.\"O For portable use,
.\"O .I optional-arg
.\"O should either be absent, or be specified as a single word (i.e., it
.\"O should not contain white space); see NOTES below.
移植性を持たすには、
.I optional-arg
は空か 1ワードだけにすべきである
(つまり、ホワイト・スペースを含めるべきではない)。
下記の「注意」の節を参照。
.\"O .SS "Limits on size of arguments and environment"
.SS "引き数と環境変数の合計サイズの上限"
.\"O Most UNIX implementations impose some limit on the total size
.\"O of the command-line argument
.\"O .RI ( argv )
.\"O and environment
.\"O .RI ( envp )
.\"O strings that may be passed to a new program.
.\"O POSIX.1 allows an implementation to advertise this limit using the
.\"O .B ARG_MAX
.\"O constant (either defined in
.\"O .I <limits.h>
.\"O or available at run time using the call
.\"O .IR "sysconf(_SC_ARG_MAX)" ).
ほとんどの UNIX の実装は、新しいプログラムに渡すことができる
コマンドライン引き数
.RI ( argv )
と環境変数
.RI ( envp )
の文字列群の合計サイズに何らかの上限を設けている。
POSIX.1 は、
.B ARG_MAX
定数を使ってこの上限を決める実装を認めている
.RB ( ARG_MAX
は
.I <limits.h>
で定義されるか、実行時に
.I "sysconf(_SC_ARG_MAX)"
の呼び出しで入手できるかのいずれかである)。

.\"O On Linux prior to kernel 2.6.23, the memory used to store the
.\"O environment and argument strings was limited to 32 pages
.\"O (defined by the kernel constant
.\"O .BR MAX_ARG_PAGES ).
.\"O On architectures with a 4-kB page size,
.\"O this yields a maximum size of 128 kB.
カーネル 2.6.23 より前の Linux では、環境変数と引き数の文字列群を
格納するのに使用されるメモリは 32 ページに制限されていた
(32 ページというのはカーネル定数
.B MAX_ARG_PAGES
で定義される)。したがって、
ページサイズが 4 kB のアーキテクチャでは、
最大サイズは 128 kB ということになる。

.\"O On kernel 2.6.23 and later, most architectures support a size limit
.\"O derived from the soft
.\"O .B RLIMIT_STACK
.\"O resource limit (see
.\"O .BR getrlimit (2))
.\"O that is in force at the time of the
.\"O .BR execve ()
.\"O call.
カーネル 2.6.23 以降では、ほとんどのアーキテクチャにおいて、
.BR execve ()
が呼び出された時点で適用されているリソースのソフト上限
.B RLIMIT_STACK
に基づいたサイズ上限が使われる
.\"O (Architectures with no memory management unit are excepted:
.\"O they maintain the limit that was in effect before kernel 2.6.23.)
.\"O This change allows programs to have a much larger
.\"O argument and/or environment list.
(メモリ管理ユニット (MMU) を持たないアーキテクチャは上記の変更の
例外であり、これらのアーキテクチャではカーネル 2.6.23 より前と
同じ上限がそのまま使用される)。
.\" For some background on the changes to ARG_MAX in kernels 2.6.23 and
.\" 2.6.25, see:
.\"     http://sourceware.org/bugzilla/show_bug.cgi?id=5786
.\"     http://bugzilla.kernel.org/show_bug.cgi?id=10095
.\"     http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
.\"     checked into 2.6.25 as commit a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
.\"O For these architectures, the total size is limited to 1/4 of the allowed
.\"O stack size.
.\"O (Imposing the 1/4-limit
.\"O ensures that the new program always has some stack space.)
これらのアーキテクチャでは、合計サイズは許可されたスタックサイズの
1/4 に制限されている
(1/4 の上限を設けているのは、新しいプログラムが必ずある程度の
スタック空間を持てることを保証するためである)。
.\" Ollie: That doesn't include the lists of pointers, though,
.\" so the actual usage is a bit higher (1 pointer per argument).
.\"O Since Linux 2.6.25,
.\"O the kernel places a floor of 32 pages on this size limit,
.\"O so that, even when
.\"O .BR RLIMIT_STACK
.\"O is set very low,
.\"O applications are guaranteed to have at least as much argument and
.\"O environment space as was provided by Linux 2.6.23 and earlier.
.\"O (This guarantee was not provided in Linux 2.6.23 and 2.6.24.)
Linux 2.6.25 以降では、カーネルはこのサイズ上限に 32 ページの下限を
設けている。これにより、
.B RLIMIT_STACK
が非常に小さく設定された場合でも、アプリケーションが少なくとも
Linux 2.6.23 以前で提供されていたのと同じ大きさの引き数と環境変数の空間
と同じだけは確保できることが保証されている
(この最低限の保証は Linux 2.6.23 と 2.6.24 では提供されていない)。
.\"O Additionally, the limit per string is 32 pages (the kernel constant
.\"O .BR MAX_ARG_STRLEN ),
.\"O and the maximum number of strings is 0x7FFFFFFF.
また、各文字列の上限は 32 ページ (カーネル定数
.BR MAX_ARG_STRLEN )
で、文字列数の最大値は 0x7FFFFFFF である。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success,
.\"O .BR execve ()
.\"O does not return, on error \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
成功すると
.BR execve ()
は返らない。エラーの場合は \-1 を返し、
.I errno
を適切に設定する。
.\"O .SH ERRORS
.SH エラー
.TP
.B E2BIG
.\"O The total number of bytes in the environment
.\"O .RI ( envp )
.\"O and argument list
.\"O .RI ( argv )
.\"O is too large.
環境変数
.RI ( envp )
と引き数リスト
.RI ( argv )
の合計バイト数が大き過ぎる。
.TP
.B EACCES
.\"O Search permission is denied on a component of the path prefix of
.\"O .I filename
.\"O or the name of a script interpreter.
.\"O (See also
.\"O .BR path_resolution (7).)
.I filename
やスクリプトインタプリタ名の構成要素に検索許可 (search permission)
が与えられていない
.RB ( path_resolution (7)
も参照すること)。
.TP
.B EACCES
.\"O The file or a script interpreter is not a regular file.
ファイルもしくはスクリプトのインタプリタが通常ファイル (regular file)
でない。
.TP
.B EACCES
.\"O Execute permission is denied for the file or a script or ELF interpreter.
ファイルやスクリプトや ELF インタプリタに
実行許可 (execute permission) が与えられていない。
.TP
.B EACCES
.\"O The file system is mounted
.\"O .IR noexec .
ファイル・システムが
.I noexec
でマウントされている。
.TP
.B EFAULT
.\"O .I filename
.\"O points outside your accessible address space.
.I filename
がアクセス可能なアドレス空間の外を指している。
.TP
.B EINVAL
.\"O An ELF executable had more than one PT_INTERP segment (i.e., tried to
.\"O name more than one interpreter).
ELF 実行形式で複数の PT_INTERP セグメントが存在する。
(すなわち複数のインタプリタを指定した。)
.TP
.B EIO
.\"O An I/O error occurred.
I/O エラーが発生した。
.TP
.B EISDIR
.\"O An ELF interpreter was a directory.
ELF インタプリタがディレクトリだった。
.TP
.B ELIBBAD
.\"O An ELF interpreter was not in a recognized format.
ELF インタプリタが理解できるフォーマットでなかった。
.TP
.B ELOOP
.\"O Too many symbolic links were encountered in resolving
.\"O .I filename
.\"O or the name of a script or ELF interpreter.
.I filename
やスクリプトや ELF のインタプリタを解決する際に遭遇した
シンボリック・リンクが多過ぎる。
.TP
.B EMFILE
.\"O The process has the maximum number of files open.
そのプロセスがオープンできるファイル数の上限まで既にオープンしている。
.TP
.B ENAMETOOLONG
.\"O .I filename
.\"O is too long.
.I filename
が長過ぎる。
.TP
.B ENFILE
.\"O The system limit on the total number of open files has been reached.
そのシステムでオープンできるファイル数の制限に達した。
.TP
.B ENOENT
.\"O The file
.\"O .I filename
.\"O or a script or ELF interpreter does not exist, or a shared library
.\"O needed for file or interpreter cannot be found.
ファイル
.I filename
かスクリプトや ELF のインタプリタが存在しない。
.TP
.B ENOEXEC
.\"O An executable is not in a recognized format, is for the wrong
.\"O architecture, or has some other format error that means it cannot be
.\"O executed.
実行ファイルが理解できない形式であるか、違うアーキテクチャのものか、
その他のフォーマット・エラーにより実行ができなかった。
.TP
.B ENOMEM
.\"O Insufficient kernel memory was available.
カーネルに十分なメモリがない。
.TP
.B ENOTDIR
.\"O A component of the path prefix of
.\"O .I filename
.\"O or a script or ELF interpreter is not a directory.
.I filename
やスクリプトや ELF のインタプリタの構成要素がディレクトリでない。
.TP
.B EPERM
.\"O The file system is mounted
.\"O .IR nosuid ,
.\"O the user is not the superuser,
.\"O and the file has the set-user-ID or set-group-ID bit set.
ファイル・システムが
.I nosuid
でマウントされ、ユーザがスーパーユーザでなく、
ファイルに set-user-ID あるいは set-group-ID ビットが設定されている。
.TP
.B EPERM
.\"O The process is being traced, the user is not the superuser and the
.\"O file has the set-user-ID or set-group-ID bit set.
プロセスがトレースされ、ユーザがスーパーユーザでなく、
ファイルに set-user-ID あるいは set-group-ID ビットが設定されている。
.TP
.B ETXTBSY
.\"O Executable was open for writing by one or more processes.
実行ファイルを書き込み用にオープンしているプロセスがある。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O SVr4, 4.3BSD, POSIX.1-2001.
.\"O POSIX.1-2001 does not document the #!  behavior
.\"O but is otherwise compatible.
.\"O .\" SVr4 documents additional error
.\"O .\" conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
.\"O .\" document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
.\"O .\" EISDIR or ELIBBAD error conditions.
SVr4, 4.3BSD, POSIX.1-2001.
POSIX.1-2001 には #! 動作についての記述はないが、
他は互換性がある。
.\" SVr4 には他に EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP
.\" についての記述がある。
.\" POSIX には ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE,
.\" EINVAL, EISDIR, ELIBBAD エラー状態についての記述はない。
.\"O .SH NOTES
.SH 注意
.\"O Set-user-ID and set-group-ID processes can not be
.\"O .BR ptrace (2)d.
set-user-id プロセスと set-group-ID プロセスは
.BR ptrace (2)
できない。

.\"O Linux ignores the set-user-ID and set-group-ID bits on scripts.
Linux はスクリプトの set-user-ID と set-group-ID ビットを無視する。

.\"O The result of mounting a file system
.\"O .I nosuid
.\"O varies across Linux kernel versions:
.\"O some will refuse execution of set-user-ID and set-group-ID
.\"O executables when this would
.\"O give the user powers she did not have already (and return
.\"O .BR EPERM ),
.\"O some will just ignore the set-user-ID and set-group-ID bits and
.\"O .BR exec ()
.\"O successfully.
ファイルシステムを
.I nosuid
でマウントした場合に set-user-ID/set-group-ID の実行ファイルを
どの様に扱うかは、Linux カーネルのバージョンによって異なる:
あるバージョンでは、すでに必要な権限を持っている場合を除いて、
その実行を拒否する (そして
.B EPERM
を返す)。別のあるバージョンでは
set-user-ID/set-group-ID ビットのみを無視し
.BR exec ()
は成功する。

.\"O A maximum line length of 127 characters is allowed for the first line in
.\"O a #! executable shell script.
#! 実行形式のシェル・スクリプトの 1行目に許されている文字数は、
最大 127 文字である。

.\"O The semantics of the
.\"O .I optional-arg
.\"O argument of an interpreter script vary across implementations.
.\"O On Linux, the entire string following the
.\"O .I interpreter
.\"O name is passed as a single argument to the interpreter,
.\"O and this string can include white space.
.\"O However, behavior differs on some other systems.
.\"O Some systems
.\"O .\" e.g., Solaris 8
.\"O use the first white space to terminate
.\"O .IR optional-arg .
.\"O On some systems,
.\"O .\" e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
.\"O an interpreter script can have multiple arguments,
.\"O and white spaces in
.\"O .I optional-arg
.\"O are used to delimit the arguments.
インタプリタ・スクリプトの
.I optional-arg
引き数の解釈方法は実装により異なる。
Linux では、インタプリタ名
.I interpreter
に続く文字列全体がインタプリタに 1個の引き数として渡される。
しかし、動作が異なるシステムもある。
あるシステムでは、
.\" 例えば、Solaris 8
.I optional-arg
のうち最初のホワイト・スペースまでが
引き数として渡される。
また、別のシステムでは
.\" 例えば、6.0 より前の FreeBSD (FreeBSD 6.0 以降は違う)
インタプリタ・スクリプトは複数の引き数を持つことができ、
.I optional-arg
内のホワイト・スペースが引き数の区切りとなる。

.\"O On Linux,
.\"O .I argv
.\"O can be specified as NULL,
.\"O which has the same effect as specifying this argument
.\"O as a pointer to a list containing a single NULL pointer.
.\"O .B "Do not take advantage of this misfeature!"
.\"O It is nonstandard and nonportable:
.\"O on most other UNIX systems doing this will result in an error
.\"O .RB ( EFAULT ).
Linux では、
.I argv
に NULL を指定することができる。これは、この引き数に NULL ポインタ
1個だけを含むリストへのポインタを指定したのと同じ効果を持つ。
.BR 「この間違った機能を利用しないこと」 。
これは非標準で、移植性もない。
他のほとんどの UNIX システムでは、これを行うとエラー
.RB ( EFAULT )
になる。
.\" e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
.\" HP-UX 11 is like Linux -- mtk, Apr 2007
.\" Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
.\" Bug rejected (because fix would constitute an ABI change).
.\"

.\"O POSIX.1-2001 says that values returned by
.\"O .BR sysconf (3)
.\"O should be invariant over the lifetime of a process.
.\"O However, since Linux 2.6.23, if the
.\"O .BR RLIMIT_STACK
.\"O resource limit changes, then the value reported by
.\"O .B _SC_ARG_MAX
.\"O will also change,
.\"O to reflect the fact that the limit on space for holding
.\"O command-line arguments and environment variables has changed.
POSIX.1-2001 は、
.BR sysconf (3)
が返す値はプロセスの生存中は変化しないべきだとしている。
しかしながら、Linux 2.6.23 以降では、リソース上限
.B RLIMIT_STACK
が変化した場合、
コマンドライン引き数と環境変数を保持するための空間に対する上限が
変化したことを反映して、
.B _SC_ARG_MAX
が返す値も変化する。
.\"
.\"O .\" .SH BUGS
.\"O .\" Some Linux versions have failed to check permissions on ELF
.\"O .\" interpreters.  This is a security hole, because it allows users to
.\"O .\" open any file, such as a rewinding tape device, for reading.  Some
.\"O .\" Linux versions have also had other security holes in
.\"O .\" .BR execve ()
.\"O .\" that could be exploited for denial of service by a suitably crafted
.\"O .\" ELF binary. There are no known problems with 2.0.34 or 2.2.15.
.\" .SH バグ
.\" Linux 版の中には、ELF インタプリタにおける
.\" 権限のチェックに失敗するものがある。
.\" これはセキュリティホールである。
.\" なぜなら、ユーザに任意のファイルをオープンを許可したり、
.\" 読み込みのためにテープデバイスを巻き戻しを許可したりする。
.\" Linux 版の中には
.\" .BR execve ()
.\" に他のセキュリティホールが
.\" 存在するものもあり、巧妙に細工された ELF バイナリによって
.\" サービス拒否 (denial of service) に利用されてしまう。
.\" 2.0.34 また 2.2.15 には、知られている問題はない。
.\"O .SS Historical
.SS 歴史
.\"O With UNIX V6 the argument list of an
.\"O .BR exec ()
.\"O call was ended by 0,
.\"O while the argument list of
.\"O .I main
.\"O was ended by \-1.
.\"O Thus, this argument list was not directly usable in a further
.\"O .BR exec ()
.\"O call.
.\"O Since UNIX V7 both are NULL.
UNIX V6 では
.BR exec ()
コールの引き数リストは 0 で終端され、
.I main
の引き数リストは \-1 で終端されていた。
そのため、
.I main
の引き数リストは、その後の
.BR exec ()
コールには直接使用できなかった。
UNIX V7 以降では、ともに NULL で終端される。
.\"O .SH EXAMPLE
.SH 例
.\"O The following program is designed to be execed by the second program below.
.\"O It just echoes its command-line one per line.
このプログラムは、以下の二つ目のプログラムから実行するためのものである。
コマンドラインを 1行に 1個ずつ表示するだけのプログラムである。

.in +4n
.nf
/* myecho.c */

#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[])
{
    int j;

    for (j = 0; j < argc; j++)
        printf("argv[%d]: %s\\n", j, argv[j]);

    exit(EXIT_SUCCESS);
}
.fi
.in

.\"O This program can be used to exec the program named in its command-line
.\"O argument:
以下のプログラムは、コマンドライン引き数で指定した名前のプログラムを
実行するのに使う。
.in +4n
.nf

/* execve.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int
main(int argc, char *argv[])
{
    char *newargv[] = { NULL, "hello", "world", NULL };
    char *newenviron[] = { NULL };

    if (argc != 2) {
	fprintf(stderr, "Usage: %s <file-to-exec>\\n", argv[0]);
	exit(EXIT_FAILURE);
    }

    newargv[0] = argv[1];

    execve(argv[1], newargv, newenviron);
    perror("execve");   /* execve() only returns on error */
    exit(EXIT_FAILURE);
}
.fi
.in

.\"O We can use the second program to exec the first as follows:
二つ目のプログラムを使って一つ目のプログラムを実行するには
以下のようにする。

.in +4n
.nf
.RB "$" " cc myecho.c \-o myecho"
.RB "$" " cc execve.c \-o execve"
.RB "$" " ./execve ./myecho"
argv[0]: ./myecho
argv[1]: hello
argv[2]: world
.fi
.in

.\"O We can also use these programs to demonstrate the use of a script
.\"O interpreter.
.\"O To do this we create a script whose "interpreter" is our
.\"O .I myecho
.\"O program:
さらに、これらのプログラムを使って、スクリプト・インタプリタの例を示す。
このために、「インタプリタ」として先ほど作成したプログラム
.I myecho
を使うスクリプトを作成する。

.in +4n
.nf
.RB "$" " cat > script.sh"
.B #! ./myecho script-arg
.B ^D
.RB "$" " chmod +x script.sh"
.fi
.in

.\"O We can then use our program to exec the script:
作成しておいたプログラムを使ってスクリプトを実行する。

.in +4n
.nf
.RB "$" " ./execve ./script.sh"
argv[0]: ./myecho
argv[1]: script-arg
argv[2]: ./script.sh
argv[3]: hello
argv[4]: world
.fi
.in
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR chmod (2),
.BR fork (2),
.BR ptrace (2),
.BR execl (3),
.BR fexecve (3),
.BR getopt (3),
.BR credentials (7),
.BR environ (7),
.BR path_resolution (7),
.BR ld.so (8)

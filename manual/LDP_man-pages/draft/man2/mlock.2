.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) Michael Kerrisk, 2004
.\"	using some material drawn from earlier man pages
.\"	written by Thomas Kuhn, Copyright 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330,
.\" Boston, MA 02111, USA.
.\"
.\" Japanese Version Copyright (c) 1997 HANATAKA Shinya
.\"         all rights reserved.
.\" Translated 1997-02-23, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated 2003-10-12, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2004-05-23, kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-03-29, kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-11-04, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2006-02-14, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2008-11-10, Akihiro MOTOKI, LDP v3.13
.\"
.\"WORD:	unlock			ロック解除
.\"WORD:	previlege		特権
.\"
.TH MLOCK 2 2008-09-25 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O mlock, munlock, mlockall, munlockall \- lock and unlock memory
.SH 名前
mlock \- メモリのロックとロック解除を行う
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/mman.h>
.sp
.BI "int mlock(const void *" addr ", size_t " len );
.BI "int munlock(const void *" addr ", size_t " len );
.sp
.BI "int mlockall(int " flags );
.B int munlockall(void);
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR mlock ()
.\"O and
.\"O .BR mlockall ()
.\"O respectively lock part or all of the calling process's virtual address
.\"O space into RAM, preventing that memory from being paged to the
.\"O swap area.
.\"O .BR munlock ()
.\"O and
.\"O .BR munlockall ()
.\"O perform the converse operation,
.\"O respectively unlocking part or all of the calling process's virtual
.\"O address space, so that pages in the specified virtual address range may
.\"O once more to be swapped out if required by the kernel memory manager.
.\"O Memory locking and unlocking are performed in units of whole pages.
.BR mlock ()
と
.BR mlockall ()
はそれぞれ、呼び出し元プロセスの仮想アドレス空間の一部または全部を
RAM 上にロックし、メモリがスワップエリアにページングされるのを防ぐ。
.BR munlock ()
と
.BR munlockall ()
は逆の操作で、それぞれ呼び出し元プロセスの仮想アドレス空間の一部または全部を
ロック解除する。つまり、指定された仮想アドレス範囲のページは
カーネルメモリマネージャーから要求されればスワップアウトするようになる。
メモリのロックとロック解除はページ単位で行われる。
.\"O .SS "mlock() and munlock()"
.SS "mlock() と munlock()"
.\"O .BR mlock ()
.\"O locks pages in the address range starting at
.\"O .I addr
.\"O and continuing for
.\"O .I len
.\"O bytes.
.\"O All pages that contain a part of the specified address range are
.\"O guaranteed to be resident in RAM when the call returns successfully;
.\"O the pages are guaranteed to stay in RAM until later unlocked.
.BR mlock ()
は
.I addr
から始まる長さ
.I len
バイトのアドレス範囲のページをロックする。
呼び出しが成功した場合には、
指定されたアドレス範囲を含む全てのページは
RAM に残り続けることが保証される。
これらのページは後でロック解除されるまで RAM に残り続けることが保証される。

.\"O .BR munlock ()
.\"O unlocks pages in the address range starting at
.\"O .I addr
.\"O and continuing for
.\"O .I len
.\"O bytes.
.\"O After this call, all pages that contain a part of the specified
.\"O memory range can be moved to external swap space again by the kernel.
.BR munlock ()
は、
.I addr
から始まる長さ
.I len
バイトのアドレス範囲のページのロックを解除する。
この呼び出しを行った後は、カーネルが、指定されたメモリ範囲を含む
全てのページを外部のスワップ空間に移動できるようになる。
.\"O .SS "mlockall() and munlockall()"
.SS "mlockall() と munlockall()"
.\"O .BR mlockall ()
.\"O locks all pages mapped into the address space of the
.\"O calling process.
.\"O This includes the pages of the code, data and stack
.\"O segment, as well as shared libraries, user space kernel data, shared
.\"O memory, and memory-mapped files.
.\"O All mapped pages are guaranteed
.\"O to be resident in RAM when the call returns successfully;
.\"O the pages are guaranteed to stay in RAM until later unlocked.
.BR mlockall ()
は呼び出し元プロセスのアドレス空間にマップされている全てのページを
ロックする。これにはコード、データ、スタックの
各セグメント、共有ライブラリ、カーネルのユーザー空間データ、
共有メモリ、メモリ・マップされたファイルが含まれる。
システム・コールが成功した場合には全てのマップされたページは RAM に
残ることを保証される。
これらのページは後でロック解除されるまで RAM に残り続けることが保証される。

.\"O The
.\"O .I flags
.\"O argument is constructed as the bitwise OR of one or more of the
.\"O following constants:
.I flags
引数は以下の内容の一つまたは複数のビット OR から構成される:
.TP 1.2i
.B MCL_CURRENT
.\"O Lock all pages which are currently mapped into the address space of
.\"O the process.
現在、プロセスのアドレス空間にマップされている全てのページをロックする。
.TP
.B MCL_FUTURE
.\"O Lock all pages which will become mapped into the address space of the
.\"O process in the future.
.\"O These could be for instance new pages required
.\"O by a growing heap and stack as well as new memory mapped files or
.\"O shared memory regions.
将来、プロセスのアドレス空間にマップされる全てのページをロックする。
例えば、ヒープ (heap) やスタックの成長により新しく必要になったページだけで
なく、新しくメモリマップされたファイルや共有メモリ領域もロックされる。
.PP
.\"O If
.\"O .B MCL_FUTURE
.\"O has been specified, then a later system call (e.g.,
.\"O .BR mmap (2),
.\"O .BR sbrk (2),
.\"O .BR malloc (3)),
.\"O may fail if it would cause the number of locked bytes to exceed
.\"O the permitted maximum (see below).
.B MCL_FUTURE
が指定されていると、以後のシステムコール (例えば、
.BR mmap (2),
.BR sbrk (2),
.BR malloc (3))
は、ロックするバイト数が許可された最大値 (下記参照) を超えた場合に
失敗する可能性がある。
.\"O In the same circumstances, stack growth may likewise fail:
.\"O the kernel will deny stack expansion and deliver a
.\"O .B SIGSEGV
.\"O signal to the process.
同様に、スタックの成長も失敗する可能性がある。
その場合、カーネルはスタックの拡張を拒否し、
.B SIGSEGV
をプロセスに送る。

.\"O .BR munlockall ()
.\"O unlocks all pages mapped into the address space of the
.\"O calling process.
.BR munlockall ()
は、呼び出し元プロセスのアドレス空間にマッピングされている
全てのページをロック解除する。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success these system calls return 0.
.\"O On error, \-1 is returned,
.\"O .I errno
.\"O is set appropriately, and no changes are made to any locks in the
.\"O address space of the process.
成功した場合は、これらのシステムコールはゼロを返す。
エラーの場合は \-1 が返され、
.I errno
が適切に設定され、プロセスのアドレス空間におけるロックは変更されない。
.\"O .SH ERRORS
.SH エラー
.TP
.B ENOMEM
.\"O (Linux 2.6.9 and later) the caller had a nonzero
.\"O .B RLIMIT_MEMLOCK
.\"O soft resource limit, but tried to lock more memory than the limit
.\"O permitted.
(Linux 2.6.9 以降) 呼び出し元は非ゼロの
ソフト資源制限
.B RLIMIT_MEMLOCK
を持つが、制限が許可している以上のメモリをロックしようとした。
.\"O This limit is not enforced if the process is privileged
.\"O .RB ( CAP_IPC_LOCK ).
この制限は、プロセスが特権
.RB ( CAP_IPC_LOCK )
を持っている場合は適用されない。
.TP
.B ENOMEM
.\"O (Linux 2.4 and earlier) the calling process tried to lock more than
.\"O half of RAM.
(Linux 2.4 以前) 呼び出し元プロセスが RAM の半分以上をロックしようとした。
.\"O .\" In the case of mlock(), this check is somewhat buggy: it doesn't
.\"O .\" take into account whether the to-be-locked range overlaps with
.\"O .\" already locked pages.  Thus, suppose we allocate
.\"O .\" (num_physpages / 4 + 1) of memory, and lock those pages once using
.\"O .\" mlock(), and then lock the *same* page range a second time.
.\"O .\" In the case, the second mlock() call will fail, since the check
.\"O .\" calculates that the process is trying to lock (num_physpages / 2 + 2)
.\"O .\" pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
.TP
.B EPERM
.\"O (Linux 2.6.9 and later) the caller was not privileged
.\"O .RB ( CAP_IPC_LOCK )
.\"O and its
.\"O .B RLIMIT_MEMLOCK
.\"O soft resource limit was 0.
(Linux 2.6.9 以降) 呼び出し元は特権
.RB ( CAP_IPC_LOCK )
を持たず、ソフト資源制限
.B RLIMIT_MEMLOCK
が 0 である。
.TP
.B EPERM
.\"O (Linux 2.6.8 and earlier)
.\"O The calling process has insufficient privilege to call
.\"O .BR munlockall ().
(Linux 2.6.8 以前)
呼び出し元プロセスが
.BR munlockall ()
を呼び出すのに必要な特権を所有していなかった。
.\"O Under Linux the
.\"O .B CAP_IPC_LOCK
.\"O capability is required.
Linux では、
.B CAP_IPC_LOCK
ケーパビリティが必要である。
.\"O .\"SVr4 documents an additional EAGAIN error code.
.\"SVr4 のドキュメントには、これ以外にエラーコード EAGAIN の記載がある。
.LP
.\"O For
.\"O .BR mlock ()
.\"O and
.\"O .BR munlock ():
.BR mlock ()
と
.BR munlock ()
用として:
.TP
.B EAGAIN
.\"O Some or all of the specified address range could not be locked.
指定されたアドレス範囲の一部または全てをロックすることができなかった。
.TP
.B EINVAL
.\"O .I len
.\"O was negative.
.I len
が負の数である。
.TP
.B EINVAL
.\"O (Not on Linux)
.\"O .I addr
.\"O was not a multiple of the page size.
(Linux ではこの意味で使われない)
.I addr
がページサイズの倍数ではない。
.TP
.B ENOMEM
.\"O Some of the specified address range does not correspond to mapped
.\"O pages in the address space of the process.
指定されたアドレス範囲がプロセスのアドレス空間にマップされたページと
一致しない。
.LP
.\"O For
.\"O .BR mlockall ():
.BR mlockall ()
用として:
.TP
.B EINVAL
.\"O Unknown \fIflags\fP were specified.
未知の \fIflags\fP が指定された。
.LP
.\"O For
.\"O .BR munlockall ():
.BR munlockall ()
用として:
.TP
.B EPERM
.\"O (Linux 2.6.8 and earlier) The caller was not privileged
.\"O .RB ( CAP_IPC_LOCK ).
(Linux 2.6.8 以前) 呼び出し元が権限
.RB ( CAP_IPC_LOCK )
を持っていない。
.\"O .SH "CONFORMING TO"
.SH 準拠
POSIX.1-2001, SVr4.
.\"O .SH AVAILABILITY
.SH 可用性
.\"O On POSIX systems on which
.\"O .BR mlock ()
.\"O and
.\"O .BR munlock ()
.\"O are available,
.\"O .B _POSIX_MEMLOCK_RANGE
.\"O is defined in \fI<unistd.h>\fP and the number of bytes in a page
.\"O can be determined from the constant
.\"O .B PAGESIZE
.\"O (if defined) in \fI<limits.h>\fP or by calling
.\"O .IR sysconf(_SC_PAGESIZE) .
.BR mlock ()
と
.BR munlock ()
が使用可能な POSIX システムでは
.B _POSIX_MEMLOCK_RANGE
が \fI<unistd.h>\fP で定義されている。
また、ページあたりのバイト数は、
\fI<limits.h>\fP で定義される定数
.B PAGESIZE
から (定義されている場合)、もしくは
.I sysconf(_SC_PAGESIZE)
を呼び出すことで決定できる。

.\"O On POSIX systems on which
.\"O .BR mlockall ()
.\"O and
.\"O .BR munlockall ()
.\"O are available,
.\"O .B _POSIX_MEMLOCK
.\"O is defined in \fI<unistd.h>\fP to a value greater than 0.
.\"O (See also
.\"O .BR sysconf (3).)
.BR mlockall ()
と
.BR munlockall ()
が利用可能な POSIX システムでは、
.B _POSIX_MEMLOCK
は \fI<unistd.h>\fP で 0 より大きい値に定義されている
.RB ( sysconf (3)
も参照のこと)。
.\"O .\" POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
.\"O .\" -1: unavailable, 0: ask using sysconf().
.\"O .\" glibc defines it to 1.
.\" POSIX.1-2001: この変数は -1 か 0 か 200112l のいずれかに
.\" 定義すべきとなっている。
.\" -1: 利用できない、0: sysconf() に問い合わせる
.\" glibc では 1 に定義している。
.\"O .SH "NOTES"
.SH 注意
.\"O Memory locking has two main applications: real-time algorithms and
.\"O high-security data processing.
.\"O Real-time applications require
.\"O deterministic timing, and, like scheduling, paging is one major cause
.\"O of unexpected program execution delays.
.\"O Real-time applications will
.\"O usually also switch to a real-time scheduler with
.\"O .BR sched_setscheduler (2).
メモリのロックの用途としては主に二つある: リアルタイム
アルゴリズムと高いセキュリティの必要なデータ処理である。リアルタイムの
アプリケーションは決定的なタイミングやスケジューリングを必要とするが、
ページングは予期しないプログラムの実行遅延をもたらす主要な要因となる。
リアルタイムのアプリケーションはたいていは
.BR sched_setscheduler (2)
でリアルタイムスケジューラに変更される。
.\"O Cryptographic security software often handles critical bytes like
.\"O passwords or secret keys as data structures.
.\"O As a result of paging,
.\"O these secrets could be transferred onto a persistent swap store medium,
.\"O where they might be accessible to the enemy long after the security
.\"O software has erased the secrets in RAM and terminated.
.\"O (But be aware that the suspend mode on laptops and some desktop
.\"O computers will save a copy of the system's RAM to disk, regardless
.\"O of memory locks.)
暗号やセキュリティのソフトウェアはしばしばパスワードや秘密鍵のデータの
ような重要なバイト列を扱う。ページングの結果、これらの秘密が
スワップ用の固定媒体に転送されるかもしれない。そして、セキュリティ・
ソフトウェアが RAM 上の秘密を削除して終了したずっと後になっても、
このスワップされたデータには敵がアクセスできる可能性がある
(しかし、ラップトップといくつかのデスクトップコンピュータの
サスペンドモードはシステムの RAM の内容をメモリのロックに関わらず
ディスクに保存することに注意)。

.\"O Real-time processes that are using
.\"O .BR mlockall ()
.\"O to prevent delays on page faults should reserve enough
.\"O locked stack pages before entering the time-critical section,
.\"O so that no page fault can be caused by function calls.
.\"O This can be achieved by calling a function that allocates a
.\"O sufficiently large automatic variable (an array) and writes to the
.\"O memory occupied by this array in order to touch these stack pages.
.\"O This way, enough pages will be mapped for the stack and can be
.\"O locked into RAM.
.\"O The dummy writes ensure that not even copy-on-write
.\"O page faults can occur in the critical section.
リアルタイムプロセスが
.BR mlockall ()
を使ってページフォールトによる遅延を防ごうとする場合、
関数呼び出しによってページフォールトが発生しないように、
時間制限の厳しい部分 (time-critical section) に入る前に
十分な量のロックされたスタックを確保しておく必要がある。
これを実現するには、十分な大きさの自動変数 (の配列) を確保し、
これらのスタック用のページがメモリ上に確保されるようにこの配列に
書き込みを行う関数を用意し、これを呼び出せばよい。こうすることで、
十分な量のページがスタックにマッピングされ、RAM にロックされる。
ダミーの書き込みを行うことによって、
時間制限の厳しい部分 (critical section) 内では書き込み時コピーによる
ページフォールトさえも発生しないことが保証される。

.\"O Memory locks are not inherited by a child created via
.\"O .BR fork (2)
.\"O and are automatically removed (unlocked) during an
.\"O .BR execve (2)
.\"O or when the process terminates.
メモリロックは
.BR fork (2)
で作成された子プロセスには継承されず、
.BR execve (2)
が呼ばれたり、プロセスが終了した場合は
自動的に削除される (ロック解除される)。

.\"O The memory lock on an address range is automatically removed
.\"O if the address range is unmapped via
.\"O .BR munmap (2).
あるアドレス範囲に対するメモリロックは、そのアドレス範囲が
.BR munmap (2)
によってアンマップされた場合は削除される。

.\"O Memory locks do not stack, that is, pages which have been locked several times
.\"O by calls to
.\"O .BR mlock ()
.\"O or
.\"O .BR mlockall ()
.\"O will be unlocked by a single call to
.\"O .BR munlock ()
.\"O for the corresponding range or by
.\"O .BR munlockall ().
.\"O Pages which are mapped to several locations or by several processes stay
.\"O locked into RAM as long as they are locked at least at one location or by
.\"O at least one process.
メモリのロックは累積しない。
すなわち複数回
.BR mlock ()
や
.BR mlockall ()
を呼び出してロックされたページでも、
対応する範囲に対して
.BR munlock ()
を 1 回呼び出したり
.BR munlockall ()
を呼び出したりするだけでロック解除される。
複数の場所や複数のプロセスにマップされているページは、少なくとも一つの場所、
一つのプロセスでロックされている限りは RAM に残り続ける。
.\"O .SS "Linux Notes"
.SS Linux での注意
.\"O Under Linux,
.\"O .BR mlock ()
.\"O and
.\"O .BR munlock ()
.\"O automatically round
.\"O .I addr
.\"O down to the nearest page boundary.
Linux では、
.BR mlock ()
と
.BR munlock ()
は自動的に
.I addr
を端数切り捨てにより一番近いページ境界へと丸める。
.\"O However, POSIX.1-2001 allows an implementation to require that
.\"O .I addr
.\"O is page aligned, so portable applications should ensure this.
しかし POSIX.1-2001 は
.I addr
がページ境界に合っていることを要求する実装も許している。
そのため移植性を意図したアプリケーションではきちんと境界に合わせた方が良い。
.\"O .SS "Limits and permissions"
.SS 制限と権限
.\"O In Linux 2.6.8 and earlier,
.\"O a process must be privileged
.\"O .RB ( CAP_IPC_LOCK )
.\"O in order to lock memory and the
.\"O .B RLIMIT_MEMLOCK
.\"O soft resource limit defines a limit on how much memory the process may lock.
Linux 2.6.8 以前では、メモリをロックするためには特権
.RB ( CAP_IPC_LOCK )
が必要で、
ソフト資源制限
.B RLIMIT_MEMLOCK
はプロセスがどれだけのメモリをロックできるかの制限を定義する。

.\"O Since Linux 2.6.9, no limits are placed on the amount of memory
.\"O that a privileged process can lock and the
.\"O .B RLIMIT_MEMLOCK
.\"O soft resource limit instead defines a limit on how much memory an
.\"O unprivileged process may lock.
Linux 2.6.9 以降では、特権を持つプロセスがロックできるメモリ量は無制限となり、
代わりにソフト資源制限
.B RLIMIT_MEMLOCK
は特権を持たないプロセスがロックできるメモリ量の制限を定義する。
.\"O .SH "BUGS"
.SH バグ
.\"O In the 2.4 series Linux kernels up to and including 2.4.17,
.\"O a bug caused the
.\"O .BR mlockall ()
.\"O .B MCL_FUTURE
.\"O flag to be inherited across a
.\"O .BR fork (2).
2.4.17 までの 2.4 シリーズの Linux カーネルには、
.BR mlockall ()
.B MCL_FUTURE
フラグが
.BR fork (2)
で継承されると言うバグがある。
.\"O This was rectified in kernel 2.4.18.
これはカーネル 2.4.18 で修正された。

.\"O Since kernel 2.6.9, if a privileged process calls
.\"O .I mlockall(MCL_FUTURE)
.\"O and later drops privileges (loses the
.\"O .B CAP_IPC_LOCK
.\"O capability by, for example,
.\"O setting its effective UID to a nonzero value),
.\"O then subsequent memory allocations (e.g.,
.\"O .BR mmap (2),
.\"O .BR brk (2))
.\"O will fail if the
.\"O .B RLIMIT_MEMLOCK
.\"O resource limit is encountered.
カーネル 2.6.9 以降では、特権を持ったプロセスが
.I mlockall(MCL_FUTURE)
を呼び出した後で、特権をなくした場合 (例えば、
実効 UID を 0 以外の値に変更するなどにより、
.B CAP_IPC_LOCK
ケーパビリティを失った場合)、リソース上限
.B RLIMIT_MEMLOCK
に達すると、それ以降のメモリ割り当て (例えば
.BR mmap (2),
.BR brk (2))
は失敗する。
.\"O .\" See the following LKML thread:
.\"O .\" http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
.\"O .\" "Rationale for RLIMIT_MEMLOCK"
.\"O .\" 23 Jan 2006
.\" LKML の以下のスレッドを参照:
.\" http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
.\" "Rationale for RLIMIT_MEMLOCK"
.\" 23 Jan 2006
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR mmap (2),
.BR setrlimit (2),
.BR shmctl (2),
.BR sysconf (3),
.BR capabilities (7)

.\" Copyright (c) 2000 Andries Brouwer <aeb@cwi.nl>
.\" and Copyright (c) 2008, Linux Foundation, written by Michael Kerrisk
.\"      <mtk.manpages@gmail.com>
.\" and Copyright (c) 2008, Linux Foundation, written by Michael Kerrisk
.\"      <mtk.manpages@gmail.com>
.\" based on work by Rik Faith <faith@cs.unc.edu>
.\" and Mike Battersby <mike@starbug.apana.org.au>.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 2004-11-19, mtk:
.\" added pointer to sigaction.2 for details of ignoring SIGCHLD
.\" 2007-06-03, mtk: strengthened portability warning, and rewrote
.\"     various sections.
.\" 2008-07-11, mtk: rewrote and expanded portability discussion.
.\"
.\" Japanese Version Copyright (c) 1997 HANATAKA Shinya
.\"         all rights reserved.
.\" Translated 1997-03-03, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 2000-09-24, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated & Modified 2002-01-14, Yuichi SATO <ysato@h4.dion.ne.jp>
.\" Updated & Modified 2004-01-17, Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated & Modified 2005-01-07, Yuichi SATO
.\" Updated 2007-06-01, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.50
.\" Updated 2007-06-13, Akihiro MOTOKI, LDP v2.55
.\" Updated 2008-08-08, Akihiro MOTOKI, LDP v3.05
.\"
.\"WORD:	signal			シグナル
.\"WORD:	signal handler		シグナル・ハンドラ
.\"WORD:	library			ライブラリ
.\"WORD:	semantics		方式
.\"WORD:	prototype		型宣言
.\"WORD:	architecture		アーキテクチャー
.\"WORD:	endless loop		無限ループ
.\"WORD:	feature test macro	機能検査マクロ
.\"WORD:	disposition		処理方法
.\"
.TH SIGNAL 2 2008-07-11 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O signal \- ANSI C signal handling
signal \- ANSI C シグナル操作
.\"O .SH SYNOPSIS
.SH 書式
.B #include <signal.h>
.sp
.B typedef void (*sighandler_t)(int);
.sp
.\"O .BI "sighandler_t signal(int " signum ", sighandler_t " handler );
.BI "sighandler_t signal(int " signum ", sighandler_t " sighandler );
.\"O .SH DESCRIPTION
.SH 説明
.\"O The behavior of
.\"O .BR signal ()
.\"O varies across UNIX versions,
.\"O and has also varied historically across different versions of Linux.
.\"O \fBAvoid its use\fP: use
.\"O .BR sigaction (2)
.\"O instead.
.\"O See \fIPortability\fP below.
.BR signal ()
の動作は UNIX のバージョンにより異なる。
また、歴史的に見て Linux のバージョンによっても異なっている。
\fBこのシステムコールの使用は避け、\fP
代わりに
.BR sigaction (2)
を使用すること。
下記の「移植性」を参照。

.\"O .BR signal ()
.\"O sets the disposition of the signal
.\"O .I signum
.\"O to
.\"O .IR handler ,
.\"O which is either
.\"O .BR SIG_IGN ,
.\"O .BR SIG_DFL ,
.\"O or the address of a programmer-defined function (a "signal handler").
.BR signal ()
はシグナル
.I signum
の処理方法を
.I handler
に設定する。
.I handler
には、
.BR SIG_IGN "、"
.BR SIG_DFL "、"
プログラマが定義した関数 (「シグナル・ハンドラ」) のアドレスの
いずれかを指定する。

.\"O If the signal
.\"O .I signum
.\"O is delivered to the process, then one of the following happens:
シグナル
.I signum
がプロセスに配送されると、以下のいずれかが発生する。
.TP 3
*
.\"O If the disposition is set to
.\"O .BR SIG_IGN ,
.\"O then the signal is ignored.
処理方法が
.B SIG_IGN
に設定されている場合、そのシグナルは無視される。
.TP
*
.\"O If the disposition is set to
.\"O .BR SIG_DFL ,
.\"O then the default action associated with the signal (see
.\"O .BR signal (7))
.\"O occurs.
処理方法が
.B SIG_DFL
に設定されている場合、シグナルに関連づけられた
デフォルトの動作が行われる
.RB ( signal (7)
参照)。
.TP
*
.\"O If the disposition is set to a function,
.\"O then first either the disposition is reset to
.\"O .BR SIG_DFL ,
.\"O or the signal is blocked (see \fIPortability\fP below), and then
.\"O .I handler
.\"O is called with argument
.\"O .IR signum .
処理方法として関数が設定されている場合、
まず最初に処理方法が
.B SIG_DFL
にリセットされるかそのシグナルのブロックが実行された後、
.I signum
を引き数として
.I handler
が呼び出される。
.\"O If invocation of the handler caused the signal to be blocked,
.\"O then the signal is unblocked upon return from the handler.
ハンドラが起動される際にシグナルがブロックされた場合、
ハンドラが返る際にそのシグナルのブロックが解除される。
.PP
.\"O The signals
.\"O .B SIGKILL
.\"O and
.\"O .B SIGSTOP
.\"O cannot be caught or ignored.
シグナル
.B SIGKILL
と
.B SIGSTOP
は捕捉できず、無視することもできない。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O .BR signal ()
.\"O returns the previous value of the signal handler, or
.\"O .B SIG_ERR
.\"O on error.
.BR signal ()
は、今までのシグナル・ハンドラの値を返す。エラーの場合は
.B SIG_ERR
を返す。
.\"O .SH ERRORS
.SH エラー
.TP
.B EINVAL
.\"O .I signum
.\"O is invalid.
.I signum
が不正である。
.\"O .SH "CONFORMING TO"
.SH 準拠
C89, C99, POSIX.1-2001.
.\"O .SH NOTES
.SH 注意
.\"O The effects of
.\"O .BR signal ()
.\"O in a multithreaded process are unspecified.
マルチスレッドプロセスにおける
.BR signal ()
の結果は、指定されていない。
.PP
.\"O According to POSIX, the behavior of a process is undefined after it
.\"O ignores a
.\"O .BR SIGFPE ,
.\"O .BR SIGILL ,
.\"O or
.\"O .B SIGSEGV
.\"O signal that was not generated by
.\"O .BR kill (2)
.\"O or
.\"O .BR raise (3).
POSIX によると、
.BR kill (2)
や
.BR raise (3)
で生成できない
.BR SIGFPE ,
.BR SIGILL ,
.B SIGSEGV
シグナルを無視した後の動作は未定義である。
.\"O Integer division by zero has undefined result.
.\"O On some architectures it will generate a
.\"O .B SIGFPE
.\"O signal.
.\"O (Also dividing the most negative integer by \-1 may generate
.\"O .BR SIGFPE .)
.\"O Ignoring this signal might lead to an endless loop.
0 による整数割り算の結果は未定義となる。
ある種のアーキテクチャでは、これは
.B SIGFPE
シグナルを生成する。
(同様に負の最大整数を \-1 で割ると
.B SIGFPE
が生成されるかもしれない。)
このシグナルを無視すると無限ループに陥るかもしれない。
.PP
.\"O See
.\"O .BR sigaction (2)
.\"O for details on what happens when
.\"O .B SIGCHLD
.\"O is set to
.\"O .BR SIG_IGN .
.B SIGCHLD
の動作として
.B SIG_IGN
を設定した場合の詳細な動作については、
.BR sigaction (2)
を参照すること。
.PP
.\"O See
.\"O .BR signal (7)
.\"O for a list of the async-signal-safe functions that can be
.\"O safely called from inside a signal handler.
シグナル・ハンドラ内から安全に呼び出すことができる、
async-signal-safe functions (非同期シングルで安全な関数) の
リストについては
.BR signal (7)
を参照。
.PP
.\"O The use of
.\"O .I sighandler_t
.\"O is a GNU extension.
.I sighandler_t
の使用は GNU 拡張である。
.\"O Various versions of libc predefine this type; libc4 and libc5 define
.\"O .IR SignalHandler ;
.\"O glibc defines
.\"O .I sig_t
.\"O and, when
.\"O .B _GNU_SOURCE
.\"O is defined, also
.\"O .IR sighandler_t .
各種バージョンの libc でこの型は定義済みである;
libc4 と libc5 では
.I SignalHandler
を定義している。
glibc では
.I sig_t
を定義しており、
.B _GNU_SOURCE
が定義されている場合には
.I sighandler_t
も定義されている。
.\"O Without use of such a type, the declaration of
.\"O .BR signal ()
.\"O is the somewhat harder to read:
このような型を使用しないと、
.BR signal ()
の宣言は読みにくいものとなる。
.in +4n
.nf

.BI "void ( *" signal "(int " signum ", void (*" handler ")(int)) ) (int);"
.fi
.in
.\"O .SS PORTABILITY
.SS 移植性
.\"O The only portable use of
.\"O .BR signal ()
.\"O is to set a signal's disposition to
.\"O .BR SIG_DFL
.\"O or
.\"O .BR SIG_IGN .
.\"O The semantics when using
.\"O .BR signal ()
.\"O to establish a signal handler vary across systems
.\"O (and POSIX.1 explicitly permits this variation);
.\"O .B do not use it for this purpose.
移植性のある
.BR signal ()
の使い方は、シグナルの処理方法を
.BR SIG_DFL
か
.BR SIG_IGN
に設定する方法だけである。
シグナル・ハンドラを設定するのに
.BR signal ()
を使ったときの動作はシステムにより異なる
(POSIX.1 は明示的にこの違いを認めている)。
.B "移植性が必要なときはこのシステムコールを使用しないこと。"

.\"O POSIX.1 solved the portability mess by specifying
.\"O .BR sigaction (2),
.\"O which provides explicit control of the semantics when a
.\"O signal handler is invoked; use that interface instead of
.\"O .BR signal ().
POSIX.1 は、
.BR sigaction (2)
を規定することで移植性に関する混乱を解決した。
.BR sigaction (2)
はシグナル・ハンドラが起動される際の挙動を明示的に制御できる。
.BR signal ()
の代わりにこのインターフェイスを使うこと。

.\"O In the original UNIX systems, when a handler that was established using
.\"O .BR signal ()
.\"O was invoked by the delivery of a signal,
.\"O the disposition of the signal would be reset to
.\"O .BR SIG_DFL ,
.\"O and the system did not block delivery of further instances of the signal.
.\"O System V also provides these semantics for
.\"O .BR signal ().
.\"O This was bad because the signal might be delivered again
.\"O before the handler had a chance to reestablish itself.
.\"O Furthermore, rapid deliveries of the same signal could
.\"O result in recursive invocations of the handler.
オリジナルの UNIX システムでは、
.BR signal ()
を使って設定されたハンドラがシグナルの配送により起動されると、
そのシグナルの処理方法は
.B SIG_DFL
にリセットされ、システムは同じシグナルがさらに生成されても
シグナルの配送をブロックしなかった。
System V でも、
.BR signal ()
に対してこれらの挙動を規定している。
こうした挙動はまずく、ハンドラがハンドラ自身を再設定する機会が
来るより前に、同じシグナルがまた配送される可能性がある。
さらに、同じシグナルが立て続けに配送されると、同じシグナルが
ハンドラを繰り返し起動されることになる。

.\"O BSD improved on this situation by changing the semantics of
.\"O signal handling
.\"O (but, unfortunately, silently changed the semantics
.\"O when establishing a handler with
.\"O .BR signal ()).
.\"O On BSD, when a signal handler is invoked,
.\"O the signal disposition is not reset,
.\"O and further instances of the signal are blocked from
.\"O being delivered while the handler is executing.
BSD では、シグナル処理の挙動を変更することで、この状況を改善した
(しかし、残念なことに、
.BR signal ()
を使ってハンドラを設定する際に挙動が黙って変更される)。
BSD では、シグナルハンドラが起動された際、
シグナルの処理方法はリセットされず、
ハンドラの実行中は、同じシグナルのさらなる生成は配送がブロックされる。

.\"O The situation on Linux is as follows:
Linux での状況は以下の通りである。
.IP * 2
.\"O The kernel's
.\"O .BR signal ()
.\"O system call provides System V semantics.
カーネルの
.BR signal ()
システムコールは System V 方式を提供している。
.IP *
.\"O By default, in glibc 2 and later, the
.\"O .BR signal ()
.\"O wrapper function does not invoke the kernel system call.
.\"O Instead, it calls
.\"O .BR sigaction (2)
.\"O using flags that supply BSD semantics.
デフォルトでは、glibc 2 以降では、
.BR signal ()
ラッパー関数はカーネルのシステムコールを起動しない。
代わりに、ラッパー関数は BSD 方式を示すフラグを使って
.BR sigaction (2)
を呼び出す。
.\"O This default behavior is provided as long as the
.\"O .B _BSD_SOURCE
.\"O feature test macro is defined.
.\"O By default,
.\"O .B _BSD_SOURCE
.\"O is defined;
.\"O it is also implicitly defined if one defines
.\"O .BR _GNU_SOURCE ,
.\"O and can of course be explicitly defined.
機能検査マクロ
.B _BSD_SOURCE
を定義していれば、このデフォルトの動作となる。
デフォルトでは、
.B _BSD_SOURCE
が定義される。
.B _BSD_SOURCE
は
.B _GNU_SOURCE
が定義された場合には暗黙のうちに定義され、
もちろん明示的に定義することもできる。
.sp
.\"O On glibc 2 and later, if the
.\"O .B _BSD_SOURCE
.\"O feature test macro is not defined, then
.\"O .BR signal ()
.\"O provides System V semantics.
glibc 2 以降では、機能検査マクロ
.B _BSD_SOURCE
が定義されていなければ、
.BR signal ()
は System V 方式となる。
.\"O (The default implicit definition of
.\"O .B _BSD_SOURCE
.\"O is not provided if one invokes
.\"O .BR gcc (1)
.\"O in one of its standard modes
.\"O .RI ( -std=xxx " or " -ansi )
.\"O or defines various other feature test macros such as
.\"O .BR _POSIX_SOURCE ,
.\"O .BR _XOPEN_SOURCE ,
.\"O or
.\"O .BR _SVID_SOURCE ;
.\"O see
.\"O .BR feature_test_macros (7).)
.RB ( gcc (1)
が標準指定モード
.RI ( -std=xxx " or " -ansi )
で起動された場合、もしくは
.BR _POSIX_SOURCE ,
.BR _XOPEN_SOURCE ,
.B _SVID_SOURCE
といった他の様々な機能検査マクロが定義された場合、
デフォルトの
.B _BSD_SOURCE
の暗黙の定義は行われない。
.BR feature_test_macros (7)
を参照のこと。)
.\"
.\" System V semantics are also provided if one uses the separate
.\" .BR sysv_signal (3)
.\" function.
.IP *
.\"O The
.\"O .BR signal ()
.\"O function in Linux libc4 and libc5 provide System V semantics.
.\"O If one on a libc5 system includes
.\"O .I <bsd/signal.h>
.\"O instead of
.\"O .IR <signal.h> ,
.\"O then
.\"O .BR signal ()
.\"O provides BSD semantics.
Linux の libc4 と libc5 の
.BR signal ()
関数は System V 方式である。
libc5 システムにおいて
.I <signal.h>
のかわりに
.I <bsd/signal.h>
をインクルードすると、
.BR signal ()
は
.BR __bsd_signal ()
に再定義され、
.BR signal ()
は BSD 方式となる。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR kill (1),
.BR alarm (2),
.BR kill (2),
.BR killpg (2),
.BR pause (2),
.BR sigaction (2),
.BR signalfd (2),
.BR sigpending (2),
.BR sigprocmask (2),
.BR sigsuspend (2),
.BR bsd_signal (3),
.BR raise (3),
.BR siginterrupt (3),
.BR sigqueue (3),
.BR sigsetops (3),
.BR sigvec (3),
.BR sysv_signal (3),
.BR signal (7)

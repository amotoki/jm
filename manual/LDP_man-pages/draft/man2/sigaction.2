'\" t
.\" Copyright (c) 1994,1995 Mike Battersby <mib@deakin.edu.au>
.\" and Copyright 2004, 2005 Michael Kerrisk <mtk.manpages@gmail.com>
.\" based on work by faith@cs.unc.edu
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified, aeb, 960424
.\" Modified Fri Jan 31 17:31:20 1997 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified Thu Nov 26 02:12:45 1998 by aeb - add SIGCHLD stuff.
.\" Modified Sat May  8 17:40:19 1999 by Matthew Wilcox
.\"	add POSIX.1b signals
.\" Modified Sat Dec 29 01:44:52 2001 by Evan Jones <ejones@uwaterloo.ca>
.\"	SA_ONSTACK
.\" Modified 2004-11-11 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added mention of SIGCONT under SA_NOCLDSTOP
.\"	Added SA_NOCLDWAIT
.\" Modified 2004-11-17 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Updated discussion for POSIX.1-2001 and SIGCHLD and sa_flags.
.\"	Formatting fixes
.\" 2004-12-09, mtk, added SI_TKILL + other minor changes
.\" 2005-09-15, mtk, split sigpending(), sigprocmask(), sigsuspend()
.\"	out of this page into separate pages.
.\"
.\" Japanese Version Copyright (c) 1997 HANATAKA Shinya all rights reserved.
.\" Translated 1997-03-03, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 2000-10-02, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 2001-10-18, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-03-15, Akihiro MOTOKI
.\" Updated 2005-10-05, Akihiro MOTOKI
.\" Updated 2007-09-08, Akihiro MOTOKI, LDP v2.64
.\" Updated 2008-08-08, Akihiro MOTOKI, LDP v3.05
.\" Updated 2010-04-18, Akihiro MOTOKI, LDP v3.24
.\"
.\"WORD:	signal			シグナル
.\"WORD:	process			プロセス
.\"WORD:	signal handler		シグナルハンドラ
.\"WORD:	pointer			ポインター
.\"WORD:	mask			マスク
.\"WORD:	block			禁止(block)
.\"WORD:	suspend			停止(suspend)
.\"WORD:	stop			停止(stop)
.\"WORD:	catch			捕獲(catch)
.\"WORD:	architecture		アーキテクチャー
.\"WORD:	compatible		互換性
.\"WORD:	pottable		移植性
.\"
.TH SIGACTION 2 2009-07-25 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O sigaction \- examine and change a signal action
sigaction \- シグナルの動作の確認と変更
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <signal.h>
.sp
.BI "int sigaction(int " signum ", const struct sigaction *" act ,
.BI "              struct sigaction *" oldact );
.fi
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.ad l
.BR sigaction ():
_POSIX_C_SOURCE\ >=\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE
.ad b
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR sigaction ()
.\"O system call is used to change the action taken by a process on
.\"O receipt of a specific signal.
.\"O (See
.\"O .BR signal (7)
.\"O for an overview of signals.)
.BR sigaction ()
システムコールは、特定のシグナルを受信した際の
プロセスの動作を変更するのに使用される
(シグナルの概要については
.BR signal (7)
を参照)。
.PP
.\"O .I signum
.\"O specifies the signal and can be any valid signal except
.\"O .B SIGKILL
.\"O and
.\"O .BR SIGSTOP .
.I signum
には、
.B SIGKILL
と
.B SIGSTOP
以外の有効なシグナルをどれでも指定できる。
.PP
.\"O If
.\"O .I act
.\"O is non-NULL, the new action for signal
.\"O .I signum
.\"O is installed from
.\"O .IR act .
.I act
が NULL 以外であれば、シグナル
.I signum
の新しい動作 (action) として
.I act
が設定される。
.\"O If
.\"O .I oldact
.\"O is non-NULL, the previous action is saved in
.\"O .IR oldact .
.I oldact
が NULL でなければ、今までの動作が
.I oldact
に格納される。
.PP
.\"O The
.\"O .I sigaction
.\"O structure is defined as something like:
.I sigaction
構造体は以下のような感じに定義される。
.sp
.in +4n
.nf
struct sigaction {
    void     (*sa_handler)(int);
    void     (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t   sa_mask;
    int        sa_flags;
    void     (*sa_restorer)(void);
};
.fi
.in
.PP
.\"O On some architectures a union is involved: do not assign to both
.\"O .I sa_handler
.\"O and
.\"O .IR sa_sigaction .
アーキテクチャによっては共用体 (union) が用いられており、その場合には
.I sa_handler
と
.I sa_sigaction
の両方を同時に割り当てることはできない。
.PP
.\"O The
.\"O .I sa_restorer
.\"O element is obsolete and should not be used.
.I sa_restorer
要素は廃止予定であり使用すべきではない。
.\"O POSIX does not specify a
.\"O .I sa_restorer
.\"O element.
POSIX には
.I sa_restorer
要素に関する規定はない。
.PP
.\"O .I sa_handler
.\"O specifies the action to be associated with
.\"O .I signum
.\"O and may be
.\"O .B SIG_DFL
.\"O for the default action,
.\"O .B SIG_IGN
.\"O to ignore this signal, or a pointer to a signal handling function.
.\"O This function receives the signal number as its only argument.
.I sa_handler
は
.I signum
に対応する動作を指定するもので、
デフォルトの動作を行う
.BR SIG_DFL 、
そのシグナルを無視する
.BR SIG_IGN 、
シグナルハンドラ関数へのポインタが設定できる。
シグナルハンドラ関数の引き数は一つであり、シグナル番号が引き数として
渡される。
.PP
.\"O If
.\"O .B SA_SIGINFO
.\"O is specified in
.\"O .IR sa_flags ,
.\"O then
.\"O .I sa_sigaction
.\"O (instead of
.\"O .IR sa_handler )
.\"O specifies the signal-handling function for
.\"O .IR signum .
.\"O This function receives the signal number as its first argument, a
.\"O pointer to a
.\"O .I siginfo_t
.\"O as its second argument and a pointer to a
.\"O .I ucontext_t
.\"O (cast to \fIvoid\ *\fP) as its third argument.
.I sa_flags
に
.B SA_SIGINFO
が指定された場合、
.RI ( sa_handler
ではなく)
.I sa_sigaction
により
.I signum
に対応するシグナルハンドル関数が指定される。
指定される関数は、最初の引き数としてシグナル番号を、
二番目の引き数として
.I siginfo_t
へのポインタを、三番目の引き数として (\fIvoid\ *\fP にキャストした)
.I ucontext_t
へのポインタを受けとる。
.PP
.\"O .I sa_mask
.\"O specifies a mask of signals which should be blocked
.\"O (i.e., added to the signal mask of the thread in which
.\"O the signal handler is invoked)
.\"O during execution of the signal handler.
.\"O In addition, the signal which triggered the handler
.\"O will be blocked, unless the
.\"O .B SA_NODEFER
.\"O flag is used.
.I sa_mask
は、シグナル・ハンドラ実行中に禁止 (block) すべきシグナルのマスクを指定する
(ハンドラ実行中のシグナルの禁止は、シグナル・ハンドラが起動されたスレッド
のシグナルのマスクに追加することで行われる)。
さらに、
.B SA_NODEFER
フラグが指定されていない場合は、ハンドラを起動するきっかけとなる
シグナルにも
.I sa_mask
が適用される。
.PP
.\"O .I sa_flags
.\"O specifies a set of flags which modify the behavior of the signal.
.\"O It is formed by the bitwise OR of zero or more of the following:
.I sa_flags
はシグナル・ハンドラの動作を変更するためのフラグの集合を指定する。
.I sa_flags
には、以下に示すフラグの (0 個以上の) 論理和をとったものを指定する。
.RS 4
.TP
.B SA_NOCLDSTOP
.\"O If
.\"O .I signum
.\"O is
.\"O .BR SIGCHLD ,
.\"O do not receive notification when child processes stop (i.e., when they
.\"O receive one of
.\"O .BR SIGSTOP ", " SIGTSTP ", " SIGTTIN
.\"O or
.\"O .BR SIGTTOU )
.\"O or resume (i.e., they receive
.\"O .BR SIGCONT )
.\"O (see
.\"O .BR wait (2)).
.\"O This flag is only meaningful when establishing a handler for
.\"O .BR SIGCHLD .
.I signum
が
.B SIGCHLD
の場合、
子プロセスが停止したり
(子プロセスが
.BR SIGSTOP ", " SIGTSTP ", " SIGTTIN ", " SIGTTOU
を受けたとき) 再開したり (子プロセスが
.B SIGCONT
を受けたとき) したときに
.B SIGCHLD
の通知を受けない。
このフラグは、
.B SIGCHLD
に対してハンドラを設定する際にのみ意味を持つ。
.TP
.\"O .BR SA_NOCLDWAIT " (Since Linux 2.6)"
.BR SA_NOCLDWAIT " (Linux 2.6 以降)"
.\"O .\" To be precise: Linux 2.5.60 -- MTK
(Linux 2.6 以降)
.\" 正確には Linux 2.5.60 以降 -- MTK
.\"O If
.\"O .I signum
.\"O is
.\"O .BR SIGCHLD ,
.\"O do not transform children into zombies when they terminate.
.\"O See also
.\"O .BR waitpid (2).
.I signum
が
.B SIGCHLD
の場合、子プロセスが終了したときに
子プロセスをゾンビプロセスに変化させない
.RB ( waitpid (2)
も参照)。
.\"O This flag is only meaningful when establishing a handler for
.\"O .BR SIGCHLD ,
.\"O or when setting that signal's disposition to
.\"O .BR SIG_DFL .
このフラグは、
.B SIGCHLD
に対してハンドラを設定する際、もしくはそのシグナルの処理方法を
.B SIG_DFL
に設定する際にのみ意味を持つ。

.\"O If the
.\"O .B SA_NOCLDWAIT
.\"O flag is set when establishing a handler for
.\"O .BR SIGCHLD ,
.\"O POSIX.1 leaves it unspecified whether a
.\"O .B SIGCHLD
.\"O signal is generated when a child process terminates.
.\"O On Linux, a
.\"O .B SIGCHLD
.\"O signal is generated in this case;
.\"O on some other implementations, it is not.
.BR SIGCHLD
に対してハンドラを設定する際に
.B SA_NOCLDWAIT
フラグをセットした場合、
子プロセスが終了した際に
.B SIGCHLD
シグナルが生成されるかどうかは、
POSIX.1 では規定されていない。
Linux では、この状況で
.B SIGCHLD
シグナルは生成される。
いくつかの他の実装では生成されない。
.TP
.B SA_NODEFER
.\"O Do not prevent the signal from being received from within its own signal
.\"O handler.
.\"O This flag is only meaningful when establishing a signal handler.
.\"O .B SA_NOMASK
.\"O is an obsolete, nonstandard synonym for this flag.
それ自身のシグナル・ハンドラーの内部にいる時でも
そのシグナルをマスクしないようにする。
このフラグはシグナルハンドラを設定する際にのみ意味を持つ。
.B SA_NOMASK
はこのフラグと同じ意味だが、廃止されており、非標準である。
.TP
.B SA_ONSTACK
.\"O Call the signal handler on an alternate signal stack provided by
.\"O .BR sigaltstack (2).
.\"O If an alternate stack is not available, the default stack will be used.
.\"O This flag is only meaningful when establishing a signal handler.
.BR sigaltstack (2)
で提供される別のシグナル・スタックでシグナルハンドラを呼び出す。
別のシグナル・スタックが利用可能でなければ、デフォルトのスタックが
使用される。
このフラグはシグナルハンドラを設定する際にのみ意味を持つ。
.TP
.BR SA_RESETHAND
.\"O Restore the signal action to the default state once the signal handler
.\"O has been called.
.\"O This flag is only meaningful when establishing a signal handler.
.\"O .B SA_ONESHOT
.\"O is an obsolete, nonstandard synonym for this flag.
シグナルハンドラが呼ばれる度に、シグナルの動作をデフォルトに戻す。
このフラグはシグナルハンドラを設定する際にのみ意味を持つ。
.B SA_ONESHOT
はこのフラグと同じ意味だが、廃止されており、非標準である。
.TP
.B SA_RESTART
.\"O Provide behavior compatible with BSD signal semantics by making certain
.\"O system calls restartable across signals.
.\"O This flag is only meaningful when establishing a signal handler.
.\"O See
.\"O .BR signal (7)
.\"O for a discussion of system call restarting.
いくつかのシステムコールをシグナルの通知の前後で再開できるようにして、
BSD シグナル方式 (semantics) と互換性のある動作を提供する。
このフラグはシグナルハンドラを設定する際にのみ意味を持つ。
.BR signal (7)
に書かれているシステムコールの再開に関する議論を参照のこと。
.TP
.\"O .BR SA_SIGINFO " (since Linux 2.2)"
.BR SA_SIGINFO " (Linux 2.2 以降)"
.\"O The signal handler takes 3 arguments, not one.
.\"O In this case,
.\"O .I sa_sigaction
.\"O should be set instead of
.\"O .IR sa_handler .
.\"O This flag is only meaningful when establishing a signal handler.
.\"O .\" (The
.\"O .\" .I sa_sigaction
.\"O .\" field was added in Linux 2.1.86.)
シグナルハンドラは一つではなく、三つの引き数を持つ。この場合は
.I sa_handler
のかわりに
.I sa_sigaction
を設定しなければならない
このフラグはシグナルハンドラを設定する際にのみ意味を持つ。
.\" .RI ( sa_sigaction
.\" フィールドは Linux 2.1.86 で追加された)。
.RE
.PP
.\"O The
.\"O .I siginfo_t
.\"O argument to
.\"O .I sa_sigaction
.\"O is a struct with the following elements:
.I sa_sigaction
のパラメータ
.I siginfo_t
は以下の要素を持つ構造体である:
.sp
.in +4n
.nf
siginfo_t {
    int      si_signo;    /* Signal number */
    int      si_errno;    /* An errno value */
    int      si_code;     /* Signal code */
    int      si_trapno;   /* Trap number that caused
                             hardware-generated signal
                             (unused on most architectures) */
.\" FIXME
.\" si_trapno seems to be only used on SPARC and Alpha;
.\" this page could use a little more detail on its purpose there.
    pid_t    si_pid;      /* Sending process ID */
    uid_t    si_uid;      /* Real user ID of sending process */
    int      si_status;   /* Exit value or signal */
    clock_t  si_utime;    /* User time consumed */
    clock_t  si_stime;    /* System time consumed */
    sigval_t si_value;    /* Signal value */
    int      si_int;      /* POSIX.1b signal */
    void    *si_ptr;      /* POSIX.1b signal */
    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */
    int      si_timerid;  /* Timer ID; POSIX.1b timers */
.\" In the kernel: si_tid
    void    *si_addr;     /* Memory location which caused fault */
    int      si_band;     /* Band event */
    int      si_fd;       /* File descriptor */
}
.fi
.in

.\"O .IR si_signo ", " si_errno " and " si_code
.\"O are defined for all signals.
.\"O .RI ( si_errno
.\"O is generally unused on Linux.)
.IR si_signo ", " si_errno ", " si_code
は全てのシグナルに対して定義されている
.RI ( si_errno
は Linux では一般的には使用されない)。
.\"O The rest of the struct may be a union, so that one should only
.\"O read the fields that are meaningful for the given signal:
構造体の残りの部分は、共用体 (union) になっているかもしれない。
その場合は該当するシグナルにおいて意味のあるフィールドのみを読み込む
ことができる。
.IP * 2
.\"O POSIX.1b signals and
.\"O .B SIGCHLD
.\"O fill in
.\"O .IR si_pid " and " si_uid .
POSIX.1b シグナルと
.B SIGCHLD
は
.IR si_pid " と " si_uid
を設定する。
.IP *
.\"O POSIX.1b timers (since Linux 2.6) fill in
.\"O .I si_overrun
.\"O and
.\"O .IR si_timerid .
.\"O The
.\"O .I si_timerid
.\"O field is an internal ID used by the kernel to identify
.\"O the timer; it is not the same as the timer ID returned by
.\"O .BR timer_create (2).
POSIX.1b タイマ (Linux 2.6 以降) は
.I si_overrun
と
.I si_timerid
を設定する。
.I si_timerid
フィールドはカーネルがタイマを特定するのに使用する内部 ID であり、
.BR timer_create (2)
が返すタイマ ID と同じではない。
.IP *
.\"O .B SIGCHLD
.\"O fills in
.\"O .IR si_status ", " si_utime " and " si_stime .
.B SIGCHLD
は
.IR si_status ", " si_utime ", " si_stime
を設定する。
.\"O The
.\"O .I si_utime
.\"O and
.\"O .I si_stime
.\"O fields do not include the times used by waited-for children (unlike
.\"O .BR getrusage (2)
.\"O and
.\"O .BR time (2)).
.\"O In kernels up to 2.6, and since 2.6.27, these fields report
.\"O CPU time in units of
.\"O .IR sysconf(_SC_CLK_TCK) .
.\"O In 2.6 kernels before 2.6.27,
.\"O a bug meant that these fields reported time in units
.\"O of the (configurable) system jiffy (see
.\"O .BR time (7)).
.RB ( getrusage (2)
や
.BR time (2)
と異なり) フィールド
.I si_utime
と
.I si_stime
には wait 待ちの子プロセスにより使用された時間は含まれない。
2.6 より前と 2.6.27 以降のカーネルでは、
これらのフィールドに格納される CPU 時間の単位は
.I sysconf(_SC_CLK_TCK)
である。
2.6.27 より前の 2.6 系のカーネルでは、バグがあり、
これらのフィールドの CPU 時間の単位が
(カーネルのコンフィグで指定される) システムの jiffy であった
.RB ( time (7)
参照)。
.\" FIXME .
.\" When si_utime and si_stime where originally implemented, the
.\" measurement unit was HZ, which was the same as clock ticks
.\" (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
.\" was *still* used as the unit to return the info these fields,
.\" with the result that the field values depended on the the
.\" configured HZ.  Of course, the should have been measured in
.\" USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
.\" convert to seconds.  I have a queued patch to fix this:
.\" http://thread.gmane.org/gmane.linux.kernel/698061/ .
.\" This patch made it into 2.6.27.
.\" But note that these fields still don't return the times of
.\" waited-for children (as is done by getrusage() and times()
.\" and wait4()).  Solaris 8 does include child times.
.IP *
.\"O .IR si_int " and " si_ptr
.\"O are specified by the sender of the POSIX.1b signal.
.IR si_int " と " si_ptr
は POSIX.1b シグナルの送信者によって指定される。
.\"O See
.\"O .BR sigqueue (2)
.\"O for more details.
詳細は
.BR sigqueue (2)
を参照のこと。
.IP *
.\"O .BR SIGILL ,
.\"O .BR SIGFPE ,
.\"O .BR SIGSEGV ,
.\"O and
.\"O .B SIGBUS
.\"O fill in
.\"O .I si_addr
.\"O with the address of the fault.
.BR SIGILL ,
.BR SIGFPE ,
.BR SIGSEGV ,
.B SIGBUS
は
.I si_addr
にエラーが発生したアドレスを設定する。
.\"O .B SIGPOLL
.\"O fills in
.\"O .IR si_band " and " si_fd .
SIGPOLL は
.IR si_band " と " si_fd
を設定する。
.PP
.\"O .I si_code
.\"O is a value (not a bit mask)
.\"O indicating why this signal was sent.
.I si_code
は、そのシグナルが送信された理由を示す値である (ビットマスクではない)。
.\"O The following list shows the values which can be placed in
.\"O .I si_code
.\"O for any signal, along with reason that the signal was generated.
以下のリストに、どのシグナルの場合でも
.I si_code
に入りうる値を、シグナルが生成された理由とともに記載する。
.RS 4
.TP 15
.B SI_USER
.\"O .BR kill (2)
.\"O or
.\"O .BR raise (3)
.BR kill (2)
または
.BR raise (3)
.TP
.B SI_KERNEL
.\"O Sent by the kernel.
カーネルにより送信された
.TP
.B SI_QUEUE
.BR sigqueue (2)
.TP
.B SI_TIMER
.\"O POSIX timer expired
POSIX タイマが満了した
.TP
.B SI_MESGQ
.\"O POSIX message queue state changed (since Linux 2.6.6); see
.\"O .BR mq_notify (3)
POSIX メッセージキューの状態が変化した (Linux 2.6.6 以降)。
.BR mq_notify (3) 参照。
.TP
.B SI_ASYNCIO
.\"O AIO completed
非同期 IO (AIO) が完了した
.TP
.B SI_SIGIO
.\"O queued SIGIO
キューイングされた SIGIO
.TP
.B SI_TKILL
.\"O .BR tkill (2)
.\"O or
.\"O .BR tgkill (2)
.\"O (since Linux 2.4.19)
.BR tkill (2)
または
.BR tgkill (2)
(Linux 2.4.19 以降)
.\" SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
.\" It appears to have been an idea that was tried during 2.5.6
.\" through to 2.5.24 and then was backed out.
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGILL
.\"O signal:
.B SIGILL
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B ILL_ILLOPC
.\"O illegal opcode
不正な命令コード (opcode)
.TP
.B ILL_ILLOPN
.\"O illegal operand
不正なオペランド
.TP
.B ILL_ILLADR
.\"O illegal addressing mode
不正なアドレッシングモード
.TP
.B ILL_ILLTRP
.\"O illegal trap
不正なトラップ
.TP
.B ILL_PRVOPC
.\"O privileged opcode
特権が必要な命令コード (opcode)
.TP
.B ILL_PRVREG
.\"O privileged register
特権が必要なレジスタ
.TP
.B ILL_COPROC
.\"O coprocessor error
コプロセッサのエラー
.TP
.B ILL_BADSTK
.\"O internal stack error
内部スタックエラー
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGFPE
.\"O signal:
.B SIGFPE
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B FPE_INTDIV
.\"O integer divide by zero
整数の 0 による除算
.TP
.B FPE_INTOVF
.\"O integer overflow
整数のオーバーフロー
.TP
.B FPE_FLTDIV
.\"O floating-point divide by zero
浮動小数点の 0 による除算
.TP
.B FPE_FLTOVF
.\"O floating-point overflow
浮動小数点のオーバーフロー
.TP
.B FPE_FLTUND
.\"O floating-point underflow
浮動小数点のアンダーフロー
.TP
.B FPE_FLTRES
.\"O floating-point inexact result
浮動小数点の不正確な演算結果 (inexact result)
.TP
.B FPE_FLTINV
.\"O floating-point invalid operation
浮動小数点の不正な操作
.TP
.B FPE_FLTSUB
.\"O subscript out of range
範囲外の添字 (subscript)
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGSEGV
.\"O signal:
.B SIGSEGV
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B SEGV_MAPERR
.\"O address not mapped to object
オブジェクトにマッピングされていないアドレス
.TP
.B SEGV_ACCERR
.\"O invalid permissions for mapped object
マッピングされたオブジェクトに対するアクセス許可がない
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGBUS
.\"O signal:
.B SIGBUS
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B BUS_ADRALN
.\"O invalid address alignment
不正なアドレス・アライメント (alignment)
.TP
.B BUS_ADRERR
.\"O nonexistent physical address
存在しない物理アドレス
.TP
.B BUS_OBJERR
.\"O object-specific hardware error
オブジェクト固有のハードウェアエラー
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGTRAP
.\"O signal:
.B SIGTRAP
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B TRAP_BRKPT
.\"O process breakpoint
プロセスのブレークポイント
.TP
.B TRAP_TRACE
.\"O process trace trap
プロセスのトレース・トラップ
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGCHLD
.\"O signal:
.B SIGCHLD
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B CLD_EXITED
.\"O child has exited
子プロセスが終了した (exited)
.TP
.B CLD_KILLED
.\"O child was killed
子プロセスが kill された
.TP
.B CLD_DUMPED
.\"O child terminated abnormally
子プロセスが異常終了した
.TP
.B CLD_TRAPPED
.\"O traced child has trapped
トレース対象の子プロセスがトラップを上げた
.TP
.B CLD_STOPPED
.\"O child has stopped
子プロセスが停止 (stop) した
.TP
.B CLD_CONTINUED
.\"O stopped child has continued (since Linux 2.6.9)
停止していた子プロセスが再開した (Linux 2.6.9 以降)
.RE
.PP
.\"O The following values can be placed in
.\"O .I si_code
.\"O for a
.\"O .B SIGPOLL
.\"O signal:
.B SIGPOLL
シグナルの場合、
.I si_code
には以下の値を指定できる:
.RS 4
.TP 15
.B POLL_IN
.\"O data input available
入力データが利用可能
.TP
.B POLL_OUT
.\"O output buffers available
出力バッファが利用可能
.TP
.B POLL_MSG
.\"O input message available
入力メッセージが利用可能
.TP
.B POLL_ERR
.\"O i/o error
I/O エラー
.TP
.B POLL_PRI
.\"O high priority input available
高優先の入力が利用可能
.TP
.B POLL_HUP
.\"O device disconnected
デバイスが接続されていない
.RE
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O .BR sigaction ()
.\"O returns 0 on success and \-1 on error.
.BR sigaction ()
は成功すれば 0 を返し、エラーならば \-1 を返す。
.\"O .SH ERRORS
.SH エラー
.TP
.B EFAULT
.\"O .IR act " or " oldact
.\"O points to memory which is not a valid part of the process address space.
.IR act " か " oldact
が指しているメモリが正しいプロセスのアドレス空間にない。
.TP
.B EINVAL
.\"O An invalid signal was specified.
.\"O This will also be generated if an attempt
.\"O is made to change the action for
.\"O .BR SIGKILL " or " SIGSTOP ", "
.\"O which cannot be caught or ignored.
無効なシグナルが指定された。補足 (catch) したり無視したりできない
シグナルである
.BR SIGKILL " や " SIGSTOP
に対する動作を変更しようとした場合にも発生する。
.\"O .SH "CONFORMING TO"
.SH 準拠
POSIX.1-2001, SVr4.
.\"O .\" SVr4 does not document the EINTR condition.
.\" SVr4 には EINTR についての記述はない。
.\"O .SH NOTES
.SH 注意
.\"O A child created via
.\"O .BR fork (2)
.\"O inherits a copy of its parent's signal dispositions.
.\"O During an
.\"O .BR execve (2),
.\"O the dispositions of handled signals are reset to the default;
.\"O the dispositions of ignored signals are left unchanged.
.BR fork (2)
経由で作成された子プロセスは、親プロセスのシグナルの処理方法の
コピーを継承する。
.BR execve (2)
の前後で、ハンドラが設定されているシグナルの処理方法はデフォルトにリセットされ、
無視が設定されているシグナルの処理方法は変更されずそのままとなる。

.\"O According to POSIX, the behavior of a process is undefined after it
.\"O ignores a
.\"O .BR SIGFPE ,
.\"O .BR SIGILL ,
.\"O or
.\"O .B SIGSEGV
.\"O signal that was not generated by
.\"O .BR kill (2)
.\"O or
.\"O .BR raise (3).
.\"O Integer division by zero has undefined result.
.\"O On some architectures it will generate a
.\"O .B SIGFPE
.\"O signal.
.\"O (Also dividing the most negative integer by \-1 may generate
.\"O .BR SIGFPE .)
.\"O Ignoring this signal might lead to an endless loop.
POSIX では、
.BR kill (2)
や
.BR raise (3)
関数で生成できないシグナル
.BR SIGFPE ,
.BR SIGILL ,
.B SIGSEGV
を無視 (ignore) した場合、その後の動作は未定義である。
ゼロによる整数割り算の結果は未定義となる。
アーキテクチャーによっては、このとき
.B SIGFPE
シグナルが生成される。
(同様に負の最大整数を \-1 で割ると
.B SIGFPE
が生成されるかもしれない)
このシグナルを無視すると無限ループに陥るかもしれない。
.PP
.\"O POSIX.1-1990 disallowed setting the action for
.\"O .B SIGCHLD
.\"O to
.\"O .BR SIG_IGN .
.\"O POSIX.1-2001 allows this possibility, so that ignoring
.\"O .B SIGCHLD
.\"O can be used to prevent the creation of zombies (see
.\"O .BR wait (2)).
.\"O Nevertheless, the historical BSD and System V behaviors for ignoring
.\"O .B SIGCHLD
.\"O differ, so that the only completely portable method of ensuring that
.\"O terminated children do not become zombies is to catch the
.\"O .B SIGCHLD
.\"O signal and perform a
.\"O .BR wait (2)
.\"O or similar.
POSIX.1-1990 では
.B SIGCHLD
に
.B SIG_IGN
を設定することを認めていない。
POSIX.1-2001 では認められており、
.B SIGCHLD
を無視することでゾンビプロセスの生成を防止することができる
.RB ( wait (2)
を参照)。
さらに、BSD と SystemV では
.B SIGCHLD
を無視した際の動作が異なっている。
そのため、完全に移植性がある方法で、終了した子プロセスがゾンビにならないこと
を保証するには、
.B SIGCHLD
シグナルを補足し、
.BR wait (2)
などを実行するしかない。
.PP
.\"O POSIX.1-1990 only specified
.\"O .BR SA_NOCLDSTOP .
.\"O POSIX.1-2001 added
.\"O .BR SA_NOCLDWAIT ,
.\"O .BR SA_RESETHAND ,
.\"O .BR SA_NODEFER ,
.\"O and
.\"O .BR SA_SIGINFO .
.\"O Use of these latter values in
.\"O .I sa_flags
.\"O may be less portable in applications intended for older
.\"O Unix implementations.
POSIX.1-1990 の仕様では
.B SA_NOCLDSTOP
のみが定義されている。
POSIX.1-2001 では
.BR SA_NOCLDWAIT ,
.BR SA_RESETHAND ,
.BR SA_NODEFER ,
.B SA_SIGINFO
が追加された。
Unix の古い実装で動かすアプリケーションで、
他の
.I sa_flags
フラグを使用すると移植性が下がる。
.PP
.\"O The
.\"O .B SA_RESETHAND
.\"O flag is compatible with the SVr4 flag of the same name.
.B SA_RESETHAND
フラグは SVr4 の同じ名前のフラグと互換性がある。
.PP
.\"O The
.\"O .B SA_NODEFER
.\"O flag is compatible with the SVr4 flag of the same name under kernels
.\"O 1.3.9 and newer.
.\"O On older kernels the Linux implementation
.\"O allowed the receipt of any signal, not just the one we are installing
.\"O (effectively overriding any
.\"O .I sa_mask
.\"O settings).
.B SA_NODEFER
フラグは 1.3.9 以降のカーネルでは同じ名前の SVr4 のフラグと互換性がある。
ぞれ以前の Linux カーネルの実装では、このフラグを設定しているシグナル
だけでなく、どのシグナルでも受けることを許していた (実際には
.I sa_mask
の設定により無効にできる)。
.PP
.\"O .BR sigaction ()
.\"O can be called with a null second argument to query the current signal
.\"O handler.
.\"O It can also be used to check whether a given signal is valid for
.\"O the current machine by calling it with null second and third arguments.
.BR sigaction ()
の二番目の引き数に NULL を指定して呼び出すと、現在のシグナルハンドラを確認する
ことができる。また、二番目と三番目の引き数を NULL にて呼び出すことで、
指定されたシグナルが現在のマシンで使えるかどうかチェックできる。
.PP
.\"O It is not possible to block
.\"O .BR SIGKILL " or " SIGSTOP
.\"O (by specifying them in
.\"O .IR sa_mask ).
.\"O Attempts to do so are silently ignored.
.B SIGKILL
や
.B SIGSTOP
を
.RI ( sa_mask
に指定して) 禁止することはできない。
禁止しようとしても黙って無視される。
.PP
.\"O See
.\"O .BR sigsetops (3)
.\"O for details on manipulating signal sets.
シグナル集合の操作に関する詳細は
.BR sigsetops (3)
を参照すること。
.PP
.\"O See
.\"O .BR signal (7)
.\"O for a list of the async-signal-safe functions that can be
.\"O safely called inside from inside a signal handler.
シグナルハンドラ内から安全に呼び出すことができる、
async-signal-safe functions (非同期シングルで安全な関数) の
リストについては
.BR signal (7)
を参照。
.\"O .SS Undocumented
.SS 非公式
.\"O Before the introduction of
.\"O .B SA_SIGINFO
.\"O it was also possible to get some additional information,
.\"O namely by using a
.\"O .I sa_handler
.\"O with second argument of type
.\"O .IR "struct sigcontext".
.\"O See the relevant kernel sources for details.
.\"O This use is obsolete now.
.B SA_SIGINFO
が導入される前は、
.I "struct sigcontext"
型の二番目の引き数と一緒に
.I sa_handler
を使用することで、
いくつかの追加の情報を入手することができた。
詳細についてはカーネルソースの関連部分を見てほしい。
現在はこの使用法は廃止されている。
.\"O .SH BUGS
.SH バグ
.\"O In kernels up to and including 2.6.13, specifying
.\"O .B SA_NODEFER
.\"O in
.\"O .I sa_flags
.\"O prevents not only the delivered signal from being masked during
.\"O execution of the handler, but also the signals specified in
.\"O .IR sa_mask .
.\"O This bug was fixed in kernel 2.6.14.
2.6.13 以前のカーネルでは、
.I sa_flags
に
.B SA_NODEFER
を指定した場合、
ハンドラが実行中に配送されたシグナル自身がマスクされなくなるだけでなく、
.I sa_mask
に指定されたシグナルもマスクされなくなる。
このバグは、カーネル 2.6.14 で修正された。
.\"O .SH EXAMPLE
.SH 例
.\"O See
.\"O .BR mprotect (2).
.BR mprotect (2)
参照。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR kill (1),
.BR kill (2),
.BR killpg (2),
.BR pause (2),
.BR sigaltstack (2),
.BR signal (2),
.BR signalfd (2),
.BR sigpending (2),
.BR sigprocmask (2),
.BR sigqueue (2),
.BR sigsuspend (2),
.BR wait (2),
.BR raise (3),
.BR siginterrupt (3),
.BR sigsetops (3),
.BR sigvec (3),
.BR core (5),
.BR signal (7)

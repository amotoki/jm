'\" t
.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" This manpage is Copyright (C) 1992 Drew Eckhardt;
.\"                 and Copyright (C) 1993 Michael Haardt, Ian Jackson;
.\"                 and Copyright (C) 1998 Jamie Lokier;
.\"                 and Copyright (C) 2002 Michael Kerrisk.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 1993-07-24 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1995-09-26 by Andries Brouwer <aeb@cwi.nl>
.\" and again on 960413 and 980804 and 981223.
.\" Modified 1998-12-11 by Jamie Lokier <jamie@imbolc.ucc.ie>
.\" Applied correction by Christian Ehrhardt - aeb, 990712
.\" Modified 2002-04-23 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added note on F_SETFL and O_DIRECT
.\"	Complete rewrite + expansion of material on file locking
.\"	Incorporated description of F_NOTIFY, drawing on
.\"		Stephen Rothwell's notes in Documentation/dnotify.txt.
.\"	Added description of F_SETLEASE and F_GETLEASE
.\" Corrected and polished, aeb, 020527.
.\" Modified 2004-03-03 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Modified description of file leases: fixed some errors of detail
.\"     Replaced the term "lease contestant" by "lease breaker"
.\" Modified, 27 May 2004, Michael Kerrisk <mtk.manpages@gmail.com>
.\"     Added notes on capability requirements
.\" Modified 2004-12-08, added O_NOATIME after note from Martin Pool
.\" 2004-12-10, mtk, noted F_GETOWN bug after suggestion from aeb.
.\" 2005-04-08 Jamie Lokier <jamie@shareable.org>, mtk
.\"	Described behavior of F_SETOWN/F_SETSIG in
.\"	multithreaded processes, and generally cleaned
.\"	up the discussion of F_SETOWN.
.\" 2005-05-20, Johannes Nicolai <johannes.nicolai@hpi.uni-potsdam.de>,
.\"	mtk: Noted F_SETOWN bug for socket file descriptor in Linux 2.4
.\"	and earlier.  Added text on permissions required to send signal.
.\" 2009-09-30, Michael Kerrisk
.\"     Note obsolete F_SETOWN behavior with threads.
.\"     Document F_SETOWN_EX and F_GETOWN_EX
.\"
.\" Japanese Version Copyright (c) 1996 Takeshi Ueno
.\" and Copyright (c) 2005, 2006, 2008 Akihiro MOTOKI
.\"
.\" Translated 1996-07-03, Takeshi Ueno <tueno@vio.co.jp>
.\" Modified 1998-09-10, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 1999-08-14, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated & Modified 2001-04-03, Yuichi SATO <ysato@h4.dion.ne.jp>
.\" Updated & Modified 2005-03-15, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated & Modified 2005-04-22, Akihiro MOTOKI
.\" Updated & Modified 2005-10-14, Akihiro MOTOKI
.\" Updated & Modified 2005-11-19, Akihiro MOTOKI, LDP v2.14
.\" Updated 2006-04-16, Akihiro MOTOKI, LDP v2.29
.\" Updated 2008-02-11, Akihiro MOTOKI, LDP v2.77
.\" Updated 2008-09-19, Akihiro MOTOKI, LDP v3.09
.\" Updated 2010-04-23, Akihiro MOTOKI, LDP v3.24
.\"
.\"WORD:	asynchronous I/O	非同期 I/O
.\"WORD:	descriptor		ディスクリプタ
.\"WORD:	open file description	オープンファイル記述
.\"WORD:	feature test macro	機能検査マクロ
.\"WORD:	I/O availability signal	I/O が利用可能になったことを示すシグナル
.\"
.TH FCNTL 2 2009-10-17 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O fcntl \- manipulate file descriptor
fcntl \- ファイルディスクリプタの操作を行う
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <unistd.h>
.B #include <fcntl.h>
.sp
.BI "int fcntl(int " fd ", int " cmd ", ... /* " arg " */ );"
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR fcntl ()
.\"O performs one of the operations described below on the open file descriptor
.\"O .IR fd .
.\"O The operation is determined by
.\"O .IR cmd .
.BR fcntl ()
は、オープンされたファイルディスクリプタ
.I fd
に関して下記の操作を行う。操作は
.I cmd
によって決まる:

.\"O .BR fcntl ()
.\"O can take an optional third argument.
.\"O Whether or not this argument is required is determined by
.\"O .IR cmd .
.\"O The required argument type is indicated in parentheses after each
.\"O .I cmd
.\"O name (in most cases, the required type is
.\"O .IR long ,
.\"O and we identify the argument using the name
.\"O .IR arg ),
.\"O or
.\"O .I void
.\"O is specified if the argument is not required.
.BR fcntl ()
はオプションとして第三引き数をとることができる。
第三引き数が必要かどうかは
.I cmd
により決まる。
必要な引き数の型は
.I cmd
名の後ろの括弧内で指定されている
(ほとんどの場合、必要な型は
.I long
であり、この引き数を表すのに
.I arg
という名前を使っている)。
引き数が必要ない場合には
.I void
が指定されている。
.\"O .SS "Duplicating a file descriptor"
.SS "ファイルディスクリプタの複製"
.TP
.BR F_DUPFD " (\fIlong\fP)"
.\"O Find the lowest numbered available file descriptor
.\"O greater than or equal to
.\"O .I arg
.\"O and make it be a copy of
.\"O .IR fd .
.\"O This is different from
.\"O .BR dup2 (2),
.\"O which uses exactly the descriptor specified.
利用可能なファイルディスクリプタのうち、
.I arg
以上で最小のものを探し、
.I fd
のコピーとする。これは別の形の
.BR dup2 (2)
である。
.BR dup2 (2)
では指定されたディスクリプタが使われる点が違う。
.IP
.\"O On success, the new descriptor is returned.
成功すると、新しいディスクリプタが返される。
.IP
.\"O See
.\"O .BR dup (2)
.\"O for further details.
詳細は
.BR dup (2)
を参照のこと。
.TP
.\"O .BR F_DUPFD_CLOEXEC " (\fIlong\fP; since Linux 2.6.24)"
.BR F_DUPFD_CLOEXEC " (\fIlong\fP; Linux 2.6.24 以降)"
.\"O As for
.\"O .BR F_DUPFD ,
.\"O but additionally set the
.\"O close-on-exec flag for the duplicate descriptor.
.B F_DUPFD
と同様だが、それに加えて複製されたディスクリプタに対して
close-on-exec フラグをセットする。
.\"O Specifying this flag permits a program to avoid an additional
.\"O .BR fcntl ()
.\"O .B F_SETFD
.\"O operation to set the
.\"O .B FD_CLOEXEC
.\"O flag.
このフラグを指定することで、プログラムは
.B FD_CLOEXEC
フラグをセットするために
.BR fcntl ()
の
.B F_SETFD
操作を追加で行う必要がなくなる。
.\"O For an explanation of why this flag is useful,
.\"O see the description of
.\"O .B O_CLOEXEC
.\"O in
.\"O .BR open (2).
このフラグがなぜ有用かについては、
.BR open (2)
の
.B O_CLOEXEC
の説明を参照のこと。
.\"O .SS "File descriptor flags"
.SS "ファイルディスクリプタ・フラグ"
.\"O The following commands manipulate the flags associated with
.\"O a file descriptor.
.\"O Currently, only one such flag is defined:
.\"O .BR FD_CLOEXEC ,
.\"O the close-on-exec flag.
.\"O If the
.\"O .B FD_CLOEXEC
.\"O bit is 0, the file descriptor will remain open across an
.\"O .BR execve (2),
.\"O otherwise it will be closed.
以下のコマンドを使って、ファイルディスクリプタに関連するフラグ
を操作することができる。
現在のところ、定義されているフラグは一つだけである:
.B FD_CLOEXEC
(close-on-exec フラグ)。
.B FD_CLOEXEC
ビットが 0 なら、ファイルディスクリプタは
.BR execve (2)
を行ってもオープンされたままだが、そうでない場合はクローズされる。
.TP
.BR F_GETFD " (\fIvoid\fP)"
.\"O Read the file descriptor flags;
.\"O .I arg
.\"O is ignored.
ファイルディスクリプタ・フラグを読み出す。
.I arg
は無視される。
.TP
.BR F_SETFD " (\fIlong\fP)"
.\"O Set the file descriptor flags to the value specified by
.\"O .IR arg .
ファイルディスクリプタ・フラグに
.I arg
で指定した値を設定する。
.\"O .SS "File status flags"
.SS "ファイル状態フラグ"
.\"O Each open file description has certain associated status flags,
.\"O initialized by
.\"O .BR open (2)
.\"O .\" or
.\"O .\" .BR creat (2),
.\"O and possibly modified by
.\"O .BR fcntl ().
.\"O Duplicated file descriptors
.\"O (made with
.\"O .BR dup (2),
.\"O .BR fcntl (F_DUPFD),
.\"O .BR fork (2),
.\"O etc.) refer to the same open file description, and thus
.\"O share the same file status flags.
オープンファイル記述 (open file description) には、
ファイル記述毎に設定される状態フラグがいくつかある。これらのフラグは
.BR open (2)
.\" や
.\" .BR creat (2)
によって初期化され、
.BR fcntl (2)
により変更することもできる。これらは、
.RB ( dup (2),
.BR fcntl (F_DUPFD),
.BR fork (2)
などで) 複製されたファイルディスクリプタ同士は
同じオープンファイル記述を参照する。
そのため、
同じファイル状態フラグが共有される。

.\"O The file status flags and their semantics are described in
.\"O .BR open (2).
ファイル状態フラグとその意味は
.BR open (2)
で説明されている。
.TP
.BR F_GETFL " (\fIvoid\fP)"
.\"O Read the file status flags;
.\"O .I arg
.\"O is ignored.
ファイル状態フラグを読み出す。
.I arg
は無視される。
.TP
.BR F_SETFL " (\fIlong\fP)"
.\"O Set the file status flags to the value specified by
.\"O .IR arg .
.\"O File access mode
.\"O .RB ( O_RDONLY ", " O_WRONLY ", " O_RDWR )
.\"O and file creation flags
.\"O (i.e.,
.\"O .BR O_CREAT ", " O_EXCL ", " O_NOCTTY ", " O_TRUNC )
.\"O in
.\"O .I arg
.\"O are ignored.
ファイル状態フラグに
.I arg
で指定された値を設定する。
.I arg
のうち、ファイルのアクセスモード
.RB ( O_RDONLY ", " O_WRONLY ", " O_RDWR )
とファイル作成フラグ (すなわち
.BR O_CREAT ", " O_EXCL ", " O_NOCTTY ", " O_TRUNC )
に関するビットは無視される。
.\"O On Linux this command can only change the
.\"O .BR O_APPEND ,
.\"O .BR O_ASYNC ,
.\"O .BR O_DIRECT ,
.\"O .BR O_NOATIME ,
.\"O and
.\"O .B O_NONBLOCK
.\"O flags.
Linux では、このコマンドで変更できるのは
.BR O_APPEND ,
.BR O_ASYNC ,
.BR O_DIRECT ,
.BR O_NOATIME ,
.B O_NONBLOCK
フラグだけである。
.\"O .\" FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
.\"O .\" via fcntl(2), but currently Linux does not permit this
.\"O .\" See http://bugzilla.kernel.org/show_bug.cgi?id=5994
.\" FIXME . POSIX.1-2001 によると、 O_SYNC も fcntl(2) で変更できるべきだが、
.\" 現在のところ Linux では許可されていない。
.\" http://bugzilla.kernel.org/show_bug.cgi?id=5994 参照
.\"O .SS "Advisory locking"
.SS "アドバイザリ・ロック"
.\"O .BR F_GETLK ", " F_SETLK " and " F_SETLKW
.\"O are used to acquire, release, and test for the existence of record
.\"O locks (also known as file-segment or file-region locks).
.\"O The third argument,
.\"O .IR lock ,
.\"O is a pointer to a structure that has at least the following fields
.\"O (in unspecified order).
.BR F_GETLK ", " F_SETLK ", " F_SETLKW
は、レコード・ロックの獲得／解放／テストのために使用する
(レコード・ロックはファイルセグメント・ロックや
ファイル領域ロックとも呼ばれる)。
三番目の引き数
.I lock
は、以下に示すフィールドを含む構造体へのポインタである
(フィールドの順序は関係なく、構造体に他のフィールドがあってもよい)。
.in +4n
.nf
.sp
struct flock {
    ...
    short l_type;    /* Type of lock: F_RDLCK,
                        F_WRLCK, F_UNLCK */
    short l_whence;  /* How to interpret l_start:
                        SEEK_SET, SEEK_CUR, SEEK_END */
    off_t l_start;   /* Starting offset for lock */
    off_t l_len;     /* Number of bytes to lock */
    pid_t l_pid;     /* PID of process blocking our lock
                        (F_GETLK only) */
    ...
};
.fi
.in
.P
.\"O The
.\"O .IR l_whence ", " l_start ", and " l_len
.\"O fields of this structure specify the range of bytes we wish to lock.
.\"O Bytes past the end of the file may be locked,
.\"O but not bytes before the start of the file.
この構造体の
.IR l_whence ", " l_start ", " l_len
フィールドで、ロックを行いたいバイト範囲を指定する。
ファイルの末尾より後ろのバイトをロックすることはできるが、
ファイルの先頭より前のバイトをロックすることはできない。

.\"O .I l_start
.\"O is the starting offset for the lock, and is interpreted
.\"O relative to either:
.\"O the start of the file (if
.\"O .I l_whence
.\"O is
.\"O .BR SEEK_SET );
.\"O the current file offset (if
.\"O .I l_whence
.\"O is
.\"O .BR SEEK_CUR );
.\"O or the end of the file (if
.\"O .I l_whence
.\"O is
.\"O .BR SEEK_END ).
.\"O In the final two cases,
.\"O .I l_start
.\"O can be a negative number provided the
.\"O offset does not lie before the start of the file.
.I l_start
はロックを行う領域の開始オフセットである。
その意味は
.I l_whence
により異なる:
.I l_whence
が
.B SEEK_SET
の場合はファイルの先頭からのオフセット、
.I l_whence
が
.B SEEK_CUR
の場合は現在のファイルオフセットからのオフセット、
.I l_whence
が
.B SEEK_END
の場合はファイルの末尾からのオフセットと解釈される。
後ろの２つの場合には、
ファイルの先頭より前にならない範囲で、
.I l_start
に負の値を指定することができる。

.\"O .I l_len
.\"O specifies the number of bytes to be locked.
.\"O If
.\"O .I l_len
.\"O is positive, then the range to be locked covers bytes
.\"O .I l_start
.\"O up to and including
.\"O .IR l_start + l_len \- 1 .
.\"O Specifying 0 for
.\"O .I l_len
.\"O has the special meaning: lock all bytes starting at the
.\"O location specified by
.\"O .IR l_whence " and " l_start
.\"O through to the end of file, no matter how large the file grows.
.I l_len
はロックしたいバイト数を示す。
.I l_len
が正の場合、ロックされるバイト範囲は
.I l_start
以上
.IR l_start + l_len \- 1
以下となる。
.I l_len
に 0 を指定した場合は特別な意味を持つ:
.IR l_whence " and " l_start
で指定される位置からファイルの末尾までの全てのバイトをロックする
(ファイルがどんなに大きくなったとしてもファイルの末尾までロックする)。

.\"O POSIX.1-2001 allows (but does not require)
.\"O an implementation to support a negative
.\"O .I l_len
.\"O value; if
.\"O .I l_len
.\"O is negative, the interval described by
.\"O .I lock
.\"O covers bytes
.\"O .IR l_start + l_len
.\"O up to and including
.\"O .IR l_start \-1.
.\"O This is supported by Linux since kernel versions 2.4.21 and 2.5.49.
POSIX.1-2001 では、負の値の
.I l_len
をサポートする実装を認めている (必須ではない)。
.I l_len
が負の場合、ロックされるバイト範囲は
.IR l_start + l_len
以上
.IR l_start \-1
以下となる。
この動作はカーネル 2.4.21 以降および 2.5.49 以降の Linux で
サポートされている。

.\"O The
.\"O .I l_type
.\"O field can be used to place a read
.\"O .RB ( F_RDLCK )
.\"O or a write
.\"O .RB ( F_WRLCK )
.\"O lock on a file.
.\"O Any number of processes may hold a read lock (shared lock)
.\"O on a file region, but only one process may hold a write lock
.\"O (exclusive lock).
.\"O An exclusive lock excludes all other locks,
.\"O both shared and exclusive.
.I l_type
フィールドは、ファイルに対して読み出しロック
.RB ( F_RDLCK )
と書き込みロック
.RB ( F_WRLCK )
のどちらを
設定するかを指定する。
ファイルのある領域に対して、読み出しロック (共有ロック) を保持できる
プロセス数に制限はないが、書き込みロック (排他ロック) を保持できる
のは一つのプロセスだけである。排他ロックを設定すると、(共有ロックか
排他ロックにかかわらず) 他のロックは何も設定できない。
.\"O A single process can hold only one type of lock on a file region;
.\"O if a new lock is applied to an already-locked region,
.\"O then the existing lock is converted to the new lock type.
.\"O (Such conversions may involve splitting, shrinking, or coalescing with
.\"O an existing lock if the byte range specified by the new lock does not
.\"O precisely coincide with the range of the existing lock.)
一つのプロセスは、ファイルのある領域に対して一種類のロックしか保持できない。
新規のロックがロックが設定されている領域に対して適用されると、既存のロック
は新規のロックの種別に変換される
(新規のロックで指定されたバイト範囲が既存ロックの範囲と一致する場合以外では、
変換の過程で既存のロックの分割、縮小、結合が行われることがある)。
.TP
.BR F_SETLK " (\fIstruct flock *\fP)"
.\"O Acquire a lock (when
.\"O .I l_type
.\"O is
.\"O .B F_RDLCK
.\"O or
.\"O .BR F_WRLCK )
.\"O or release a lock (when
.\"O .I l_type
.\"O is
.\"O .BR F_UNLCK )
.\"O on the bytes specified by the
.\"O .IR l_whence ", " l_start ", and " l_len
.\"O fields of
.\"O .IR lock .
.RI ( l_type
が
.B F_RDLCK
か
.B F_WRLCK
の場合は) ロックの獲得を、
.RB ( F_UNLCK
の場合は) ロックの解放を、
.I flock
構造体のフィールド
.IR l_whence ", " l_start ", " l_len
で指定された範囲のバイトに対して行う。
.\"O If a conflicting lock is held by another process,
.\"O this call returns \-1 and sets
.\"O .I errno
.\"O to
.\"O .B EACCES
.\"O or
.\"O .BR EAGAIN .
指定されたロックが他のプロセスが設定しているロックと衝突する場合は、
\-1 を返し、
.I errno
に
.B EACCES
か
.B EAGAIN
を設定する。
.TP
.BR F_SETLKW " (\fIstruct flock *\fP)"
.\"O As for
.\"O .BR F_SETLK ,
.\"O but if a conflicting lock is held on the file, then wait for that
.\"O lock to be released.
.B F_SETLK
と同様だが、こちらではそのファイルに対して衝突するロックが
適用されていた場合に、そのロックが解放されるのを待つ点が異なる。
.\"O If a signal is caught while waiting, then the call is interrupted
.\"O and (after the signal handler has returned)
.\"O returns immediately (with return value \-1 and
.\"O .I errno
.\"O set to
.\"O .BR EINTR ;
.\"O see
.\"O .BR signal (7)).
待っている間にシグナルを受けた場合は、システムコールは中断され、
(シグナルハンドラが戻った直後に) 返り値 \-1 を返す (また
.I errno
に
.B EINTR
が設定される;
.BR signal (7)
参照)。
.TP
.BR F_GETLK " (\fIstruct flock *\fP)"
.\"O On input to this call,
.\"O .I lock
.\"O describes a lock we would like to place on the file.
このコールの呼び出し時には、
.I lock
にはそのファイルに適用しようとするロックに関する情報が入っている。
.\"O If the lock could be placed,
.\"O .BR fcntl ()
.\"O does not actually place it, but returns
.\"O .B F_UNLCK
.\"O in the
.\"O .I l_type
.\"O field of
.\"O .I lock
.\"O and leaves the other fields of the structure unchanged.
ロックを適用できる場合には、
.BR fcntl ()
は実際にはロックを行わず、構造体
.I lock
の
.I l_type
フィールドに
.B F_UNLCK
を設定し、他のフィールドは変更せずに、復帰する。
.\"O If one or more incompatible locks would prevent
.\"O this lock being placed, then
.\"O .BR fcntl ()
.\"O returns details about one of these locks in the
.\"O .IR l_type ", " l_whence ", " l_start ", and " l_len
.\"O fields of
.\"O .I lock
.\"O and sets
.\"O .I l_pid
.\"O to be the PID of the process holding that lock.
違う種別のロックが (一つもしくは複数) 適用されていて
ロックを適用できないような場合には、
.BR fcntl ()
は、原因となったロックの一つについての詳細情報を構造体
.I lock
のフィールド
.IR l_type ", " l_whence ", " l_start ", " l_len
に格納し、また
.I l_pid
にロックを保持しているプロセスの PID を設定して、復帰する。
.P
.\"O In order to place a read lock,
.\"O .I fd
.\"O must be open for reading.
.\"O In order to place a write lock,
.\"O .I fd
.\"O must be open for writing.
.\"O To place both types of lock, open a file read-write.
読み出しロックを適用するには、
.I fd
は読み出し用にオープンされていなければならない。
書き込みロックを適用するには、
.I fd
は書き込み用にオープンされていなければならない。
読み書き両方のロックを適用するには、読み書き両用で
ファイルをオープンしなければならない。
.P
.\"O As well as being removed by an explicit
.\"O .BR F_UNLCK ,
.\"O record locks are automatically released when the process
.\"O terminates or if it closes
.\"O .I any
.\"O file descriptor referring to a file on which locks are held.
レコードのロックは、
.B F_UNLCK
により明示的に削除されるだけでなく、
プロセスが終了したときや、ロックが適用されているファイルを参照している
ファイルディスクリプタのいずれかがクローズされた場合にも解放される。
このロックの解放は自動的に行われる。
.\"O .\" (Additional file descriptors referring to the same file
.\"O .\" may have been obtained by calls to
.\"O .\" .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
.\" .RB ( open "(2), " dup "(2), " dup2 "(2), " fcntl ()
.\" の呼び出しによって同じファイルを参照するファイルディスクリプタが
.\" 他にもできているかもしれない)
.\"O This is bad: it means that a process can lose the locks on
.\"O a file like
.\"O .I /etc/passwd
.\"O or
.\"O .I /etc/mtab
.\"O when for some reason a library function decides to open, read
.\"O and close it.
この動作はまずい: あるプロセスが
.I /etc/passwd
や
.I /etc/mtab
といったファイルにロックを適用しているときに、
あるライブラリ関数が何かの理由で同じファイルを open, read, close
すると、そのファイルへのロックが失われることになる。
.P
.\"O Record locks are not inherited by a child created via
.\"O .BR fork (2),
.\"O but are preserved across an
.\"O .BR execve (2).
レコードのロックは
.BR fork (2)
で作成された子プロセスには継承されないが、
.BR execve (2)
の前後では保存される。
.P
.\"O Because of the buffering performed by the
.\"O .BR stdio (3)
.\"O library, the use of record locking with routines in that package
.\"O should be avoided; use
.\"O .BR read (2)
.\"O and
.\"O .BR write (2)
.\"O instead.
.BR stdio (3)
ではバッファリングが行われるので、
stdio 関連の関数ではレコードのロックの使用は回避される;
代わりに
.BR read (2)
や
.BR write (2)
を使用すること。
.\"O .SS "Mandatory locking"
.SS "強制ロック (mandatory locking)"
.\"O (Non-POSIX.)
.\"O The above record locks may be either advisory or mandatory,
.\"O and are advisory by default.
上述のロックにはアドバイザリ・ロック (advisory lock) と強制ロック (mandatory
lock) の二種類があるが、デフォルトではアドバイザリ・ロックとなる。

.\"O Advisory locks are not enforced and are useful only between
.\"O cooperating processes.
アドバイザリ・ロックに強制力はなく、協調して動作するプロセス間でのみ
有効である。

.\"O Mandatory locks are enforced for all processes.
強制ロックは全てのプロセスに対して効果がある。
.\"O If a process tries to perform an incompatible access (e.g.,
.\"O .BR read (2)
.\"O or
.\"O .BR write (2))
.\"O on a file region that has an incompatible mandatory lock,
.\"O then the result depends upon whether the
.\"O .B O_NONBLOCK
.\"O flag is enabled for its open file description.
.\"O If the
.\"O .B O_NONBLOCK
.\"O flag is not enabled, then
.\"O system call is blocked until the lock is removed
.\"O or converted to a mode that is compatible with the access.
.\"O If the
.\"O .B O_NONBLOCK
.\"O flag is enabled, then the system call fails with the error
.\"O .BR EAGAIN .
あるプロセスが互換性のない強制ロックが適用されたファイル領域に対して
.RB ( read (2)
や
.BR write (2)
により) 互換性のないアクセスを実行しようとした場合、
アクセスの結果は
そのファイルのオープンファイル記述で
.B O_NONBLOCK
フラグが有効になっているかにより決まる。
.B O_NONBLOCK
フラグが有効になっていないときは、ロックが削除されるか、
ロックがアクセスと互換性のあるモードに変換されるまで、
システムコールは停止 (block) される。
.B O_NONBLOCK
フラグが有効になっているときは、システムコールはエラー
.B EAGAIN
で失敗する。

.\"O To make use of mandatory locks, mandatory locking must be enabled
.\"O both on the file system that contains the file to be locked,
.\"O and on the file itself.
.\"O Mandatory locking is enabled on a file system
.\"O using the "\-o mand" option to
.\"O .BR mount (8),
.\"O or the
.\"O .B MS_MANDLOCK
.\"O flag for
.\"O .BR mount (2).
.\"O Mandatory locking is enabled on a file by disabling
.\"O group execute permission on the file and enabling the set-group-ID
.\"O permission bit (see
.\"O .BR chmod (1)
.\"O and
.\"O .BR chmod (2)).
強制ロックを使用するためには、ロック対象のファイルが含まれるファイルシステム
と、ロック対象のファイル自身の両方について、強制ロックが有効になっていなけれ
ばならない。ファイルシステムについて強制ロックを有効にするには、
.BR mount (8)
に "\-o mand" オプションを渡すか、
.BR mount (2)
に
.B MS_MANDLOCK
フラグを指定する。ファイルについて強制ロックを有効にするには、
そのファイルのグループ実行許可 (group execute permission) を無効とし、
かつ set-group-ID 許可ビットを有効にする
.RB ( chmod (1)
と
.BR chmod (2)
を参照)。

.\"O The Linux implementation of mandatory locking is unreliable.
.\"O See BUGS below.
Linux の強制ロックの実装は信頼性に欠けるものである。
下記の「バグ」の節を参照のこと。
.\"O .SS "Managing signals"
.SS "シグナルの管理"
.\"O .BR F_GETOWN ,
.\"O .BR F_SETOWN ,
.\"O .BR F_GETOWN_EX ,
.\"O .BR F_SETOWN_EX ,
.\"O .BR F_GETSIG
.\"O and
.\"O .B F_SETSIG
.\"O are used to manage I/O availability signals:
.BR F_GETOWN ,
.BR F_SETOWN ,
.BR F_GETOWN_EX ,
.BR F_SETOWN_EX ,
.BR F_GETSIG ,
.B F_SETSIG
は、I/O が利用可能になったことを示すシグナルを管理するために使用される。
.TP
.BR F_GETOWN " (\fIvoid\fP)"
.\"O Return (as the function result)
.\"O the process ID or process group currently receiving
.\"O .B SIGIO
.\"O and
.\"O .B SIGURG
.\"O signals for events on file descriptor
.\"O .IR fd .
.\"O Process IDs are returned as positive values;
.\"O process group IDs are returned as negative values (but see BUGS below).
.\"O .I arg
.\"O is ignored.
ファイルディスクリプタ
.I fd
のイベントに対するシグナル
.B SIGIO
および
.B SIGURG
を受けているプロセスのプロセスID かプロセスグループを
(関数の結果として) 返す。
プロセスID は正の値として返される。
プロセスグループID は負の値として返される (下記のバグの章を参照)。
.I arg
は無視される。
.TP
.BR F_SETOWN " (\fIlong\fP)"
.\"O Set the process ID or process group ID that will receive
.\"O .B SIGIO
.\"O and
.\"O .B SIGURG
.\"O signals for events on file descriptor
.\"O .IR fd
.\"O to the ID given in
.\"O .IR arg .
.\"O A process ID is specified as a positive value;
.\"O a process group ID is specified as a negative value.
ファイルディスクリプタ
.I fd
のイベント発生を知らせるシグナル
.B SIGIO
や
.B SIGURG
を受けるプロセスの
プロセス ID またはプロセスグループID を
.I arg
で指定された ID に設定する。
プロセスID は正の値として指定し、
プロセスグループID は負の値として指定する。
.\"O Most commonly, the calling process specifies itself as the owner
.\"O (that is,
.\"O .I arg
.\"O is specified as
.\"O .BR getpid (2)).
ほとんどの場合、呼び出し元プロセスは所有者として自分自身を指定する
(つまり
.I arg
に
.BR getpid (2)
を指定する)。

.\"O .\" From glibc.info:
.\" glibc.info より:
.\"O If you set the
.\"O .B O_ASYNC
.\"O status flag on a file descriptor by using the
.\"O .B F_SETFL
.\"O command of
.\"O .BR fcntl (),
.\"O a
.\"O .B SIGIO
.\"O signal is sent whenever input or output becomes possible
.\"O on that file descriptor.
.\"O .B F_SETSIG
.\"O can be used to obtain delivery of a signal other than
.\"O .BR SIGIO .
.BR fcntl ()
の
.B F_SETFL
コマンドを使用してファイルディスクリプタに
.B O_ASYNC
状態フラグを設定した場合には、そのファイルディスクリプタへの
入出力が可能になる度に
.B SIGIO
シグナルが送られる。
.B F_SETSIG
は
.B SIGIO
以外の別のシグナルの配送を受けられるように
するのにも使うことができる。
.\"O If this permission check fails, then the signal is
.\"O silently discarded.
許可 (permission) のチェックで失敗した場合には、
シグナルは黙って捨てられる。

.\"O Sending a signal to the owner process (group) specified by
.\"O .B F_SETOWN
.\"O is subject to the same permissions checks as are described for
.\"O .BR kill (2),
.\"O where the sending process is the one that employs
.\"O .B F_SETOWN
.\"O (but see BUGS below).
.B F_SETOWN
により指定された所有者のプロセス (またはプロセスグループ) に
シグナルを送る際には、
.BR kill (2)
に書かれているのと同じ許可のチェックが行われる。
このとき、シグナルを送信するプロセスは
.B F_SETOWN
を使ったプロセスである
(但し、下記の「バグ」の章を参照のこと)。

.\"O If the file descriptor
.\"O .I fd
.\"O refers to a socket,
.\"O .B F_SETOWN
.\"O also selects
.\"O the recipient of
.\"O .B SIGURG
.\"O signals that are delivered when out-of-band
.\"O data arrives on that socket.
.\"O .RB ( SIGURG
.\"O is sent in any situation where
.\"O .BR select (2)
.\"O would report the socket as having an "exceptional condition".)
ファイルディスクリプタがソケットを参照している場合は、
.B F_SETOWN
を使用して、ソケットに帯域外 (out-of-band) データが届いた時に
.B SIGURG
シグナルを配送する相手を選択することもできる
.RB ( SIGURG
が送られた場合には
.BR select (2)
がソケットが「特別な状態」にあると報告することだろう)。
.\"O .\" The following appears to be rubbish.  It doesn't seem to
.\"O .\" be true according to the kernel source, and I can write
.\"O .\" a program that gets a terminal-generated SIGIO even though
.\"O .\" it is not the foreground process group of the terminal.
.\"O .\" -- MTK, 8 Apr 05
.\"O .\"
.\"O .\" If the file descriptor
.\"O .\" .I fd
.\"O .\" refers to a terminal device, then SIGIO
.\"O .\" signals are sent to the foreground process group of the terminal.
.\" 以下の記述はゴミだろう。
.\" カーネルソースを見るとこの記述は間違っているようだし、
.\" プログラムを書いてみたところ、端末のフォアグランド・プロセスグループで
.\" なくても、端末が生成した SIGIO シグナルを受けとる。
.\" -- MTK, 8 Apr 05
.\"
.\" ファイルディスクリプタが端末デバイスを参照している場合には、
.\" SIGIO シグナルはその端末のフォアグランド・プロセスグループへと送られる。

.\"O The following was true in 2.6.x kernels up to and including
.\"O kernel 2.6.11:
バージョン 2.6.11 以前の 2.6.x カーネルでは、以下に示す動作であった。
.RS
.IP
.\"O If a nonzero value is given to
.\"O .B F_SETSIG
.\"O in a multithreaded process running with a threading library
.\"O that supports thread groups (e.g., NPTL),
.\"O then a positive value given to
.\"O .B F_SETOWN
.\"O has a different meaning:
.\"O .\" The relevant place in the (2.6) kernel source is the
.\"O .\" 'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
.\"O instead of being a process ID identifying a whole process,
.\"O it is a thread ID identifying a specific thread within a process.
スレッドグループをサポートしているスレッドライブラリ (例えば NPTL) を
使って動作しているマルチスレッド・プロセスで
.B F_SETSIG
に 0 以外の値を指定した場合、
.B F_SETOWN
に正の値を渡すと、その意味が違ってくる:
.\" The relevant place in the (2.6) kernel source is the
.\" 'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
プロセス全体を示すプロセスID ではなく、プロセス内の特定の
スレッドを示すスレッドID と解釈される。
.\"O Consequently, it may be necessary to pass
.\"O .B F_SETOWN
.\"O the result of
.\"O .BR gettid (2)
.\"O instead of
.\"O .BR getpid (2)
.\"O to get sensible results when
.\"O .B F_SETSIG
.\"O is used.
したがって、
.B F_SETSIG
を使う場合には、きちんと結果を受け取るには、
.B F_SETOWN
に渡す値を
.BR getpid (2)
ではなく
.BR gettid (2)
の返り値にする必要があるだろう。
.\"O (In current Linux threading implementations,
.\"O a main thread's thread ID is the same as its process ID.
.\"O This means that a single-threaded program can equally use
.\"O .BR gettid (2)
.\"O or
.\"O .BR getpid (2)
.\"O in this scenario.)
(現状の Linux スレッド実装では、メイン・スレッドのスレッドID は
そのスレッドのプロセスID と同じである。つまり、
シグナル・スレッドのプログラムではこの場合
.BR gettid (2)
と
.BR getpid (2)
は全く同じように使うことができる。)
.\"O Note, however, that the statements in this paragraph do not apply
.\"O to the
.\"O .B SIGURG
.\"O signal generated for out-of-band data on a socket:
.\"O this signal is always sent to either a process or a process group,
.\"O depending on the value given to
.\"O .BR F_SETOWN .
.\"O .\" send_sigurg()/send_sigurg_to_task() bypasses
.\"O .\" kill_fasync()/send_sigio()/send_sigio_to_task()
.\"O .\" to directly call send_group_sig_info()
.\"O .\"	-- MTK, Apr 2005 (kernel 2.6.11)
ただし、注意すべき点として、この段落で述べたことは、
ソケットの帯域外データが届いたときに生成される
.B SIGURG
シグナルにはあてはまらない。
このシグナルは常にプロセスかプロセスグループに送られ、
送信先は
.B F_SETOWN
に渡された値にしたがって決められる。
.\" send_sigurg()/send_sigurg_to_task() bypasses
.\" kill_fasync()/send_sigio()/send_sigio_to_task()
.\" to directly call send_group_sig_info()
.\"	-- MTK, Apr 2005 (kernel 2.6.11)
.RE
.IP
.\"O The above behavior was accidentally dropped in Linux 2.6.12,
.\"O and won't be restored.
.\"O From Linux 2.6.32 onwards, use
.\"O .BR F_SETOWN_EX
.\"O to target
.\"O .B SIGIO
.\"O and
.\"O .B SIGURG
.\"O signals at a particular thread.
上記の動作は、Linux 2.6.12 で図らずも削除され、
元に戻されない予定である。
Linux 2.6.32 以降で、特定のスレッド宛にシグナル
.B SIGIO
と
.B SIGURG
を送るには
.B F_SETOWN_EX
を使うこと。
.TP
.\"O .BR F_GETOWN_EX " (struct f_owner_ex *) (since Linux 2.6.32)"
.BR F_GETOWN_EX " (struct f_owner_ex *) (Linux 2.6.32 以降)"
.\"O Return the current file descriptor owner settings
.\"O as defined by a previous
.\"O .BR F_SETOWN_EX
.\"O operation.
.\"O The information is returned in the structure pointed to by
.\"O .IR arg ,
.\"O which has the following form:
直前の
.B F_SETOWN_EX
操作で定義された現在のファイルディスクリプタの所有者設定
を返す。情報は
.I arg
が指す構造体に格納されて返される。構造体は以下の通りである。
.nf
.in +4n

struct f_owner_ex {
    int   type;
    pid_t pid;
};

.in
.fi
.\"O The
.\"O .I type
.\"O field will have one of the values
.\"O .BR F_OWNER_TID ,
.\"O .BR F_OWNER_PID ,
.\"O or
.\"O .BR F_OWNER_PGRP .
.I type
フィールドは、
.B F_OWNER_TID ,
.B F_OWNER_PID ,
.B F_OWNER_PGRP
のいずれか一つの値となる。
.\"O The
.\"O .I pid
.\"O field is a positive integer representing a thread ID, process ID,
.\"O or process group ID.
.\"O See
.\"O .B F_SETOWN_EX
.\"O for more details.
.I pid
フィールドは、スレッド ID、プロセス ID、プロセスグループ ID を
表す正の整数である。詳細は
.B F_SETOWN_EX
を参照。
.TP
.\"O .BR F_SETOWN_EX " (struct f_owner_ex *) (since Linux 2.6.32)"
.BR F_SETOWN_EX " (struct f_owner_ex *) (Linux 2.6.32 以降)"
.\"O This operation performs a similar task to
.\"O .BR F_SETOWN .
.\"O It allows the caller to direct I/O availability signals
.\"O to a specific thread, process, or process group.
この操作は
.B F_SETOWN
と同様の処理を行う。
この操作を使うと、I/O が利用可能になったことを示すシグナルを、
特定のスレッド、プロセス、プロセスグループに送ることができる
ようになる。
.\"O The caller specifies the target of signals via
.\"O .IR arg ,
.\"O which is a pointer to a
.\"O .IR f_owner_ex
.\"O structure.
.\"O The
.\"O .I type
.\"O field has one of the following values, which define how
.\"O .I pid
.\"O is interpreted:
呼び出し元は、
.I arg
経由でシグナルの配送先を指定する。
.I arg
は
.I f_owner_ex
構造体へのポインタである。
.I type
フィールドは以下のいずれかの値を取り、
この値により
.I pid
がどのように解釈されるかが規定される。
.RS
.TP
.BR F_OWNER_TID
.\"O Send the signal to the thread whose thread ID
.\"O (the value returned by a call to
.\"O .BR clone (2)
.\"O or
.\"O .BR gettid (2))
.\"O is specified in
.\"O .IR pid .
スレッド ID が
.I pid
で指定された値のスレッドにそのシグナルを送る
(スレッド ID は
.BR clone (2)
や
.BR gettid (2)
の呼び出しで返される値である)。
.TP
.BR F_OWNER_PID
.\"O Send the signal to the process whose ID
.\"O is specified in
.\"O .IR pid .
ID が
.I pid
で指定された値のプロセスにそのシグナルを送る。
.TP
.BR F_OWNER_PGRP
.\"O Send the signal to the process group whose ID
.\"O is specified in
.\"O .IR pid .
.\"O (Note that, unlike with
.\"O .BR F_SETOWN ,
.\"O a process group ID is specified as a positive value here.)
ID が
.I pid
で指定された値のプロセスグループにそのシグナルを送る。
.RB ( F_SETOWN
と異なり、プロセスグループ ID には正の値を指定する点に注意すること。)
.RE
.TP
.BR F_GETSIG " (\fIvoid\fP)"
.\"O Return (as the function result)
.\"O the signal sent when input or output becomes possible.
.\"O A value of zero means
.\"O .B SIGIO
.\"O is sent.
.\"O Any other value (including
.\"O .BR SIGIO )
.\"O is the
.\"O signal sent instead, and in this case additional info is available to
.\"O the signal handler if installed with
.\"O .BR SA_SIGINFO .
.\"O .I arg
.\"O is ignored.
入力や出力が可能になった場合に送るシグナルを
(関数の結果として) 返す。
値ゼロは
.B SIGIO
を送ることを意味する。
.RB ( SIGIO
を含む) 他の値はいずれも、
.B SIGIO
の代わりに送るシグナル番号を表す。
後者の場合、シグナルハンドラを
.B SA_SIGINFO
フラグ付きで設定すれば、ハンドラで追加の情報を得ることができる。
.I arg
は無視される。
.TP
.BR F_SETSIG " (\fIlong\fP)"
.\"O Set the signal sent when input or output becomes possible
.\"O to the value given in
.\"O .IR arg .
.\"O A value of zero means to send the default
.\"O .B SIGIO
.\"O signal.
.\"O Any other value (including
.\"O .BR SIGIO )
.\"O is the signal to send instead, and in this case additional info
.\"O is available to the signal handler if installed with
.\"O .BR SA_SIGINFO .
入力や出力が可能になった場合に送るシグナルを
.I arg
に指定された値に設定する。
値ゼロは
.B SIGIO
を送ることを意味する。
.RB ( SIGIO
を含む) 他の値はいずれも、
.B SIGIO
の代わりに送るシグナル番号を表す。
後者の場合、シグナルハンドラを
.B SA_SIGINFO
フラグ付きで設定すれば、
ハンドラで追加の情報を得ることができる。
.\"
.\" The following was true only up until 2.6.11:
.\"
.\"O .\" Additionally, passing a nonzero value to
.\"O .\" .B F_SETSIG
.\"O .\" changes the signal recipient from a whole process to a specific thread
.\"O .\" within a process.
.\"O .\" See the description of
.\"O .\" .B F_SETOWN
.\"O .\" for more details.
.\" また、
.\" .B F_SETSIG
.\" に 0 以外の値を渡すと、シグナルの受信者をプロセス全体から
.\" プロセス内の特定のスレッドに変更される。詳細は
.\" .B F_SETOWN
.\" の説明を参照のこと。

.\"O By using
.\"O .B F_SETSIG
.\"O with a nonzero value, and setting
.\"O .B SA_SIGINFO
.\"O for the
.\"O signal handler (see
.\"O .BR sigaction (2)),
.\"O extra information about I/O events is passed to
.\"O the handler in a
.\"O .I siginfo_t
.\"O structure.
.B F_SETSIG
にゼロ以外の値を設定し、シグナルハンドラに
.B SA_SIGINFO
フラグを設定すると、
.RB ( sigaction (2)
を参照) I/O イベントに関する追加の情報が
.I siginfo_t
構造体でシグナルハンドラへ渡される。
.\"O If the
.\"O .I si_code
.\"O field indicates the source is
.\"O .BR SI_SIGIO ,
.\"O the
.\"O .I si_fd
.\"O field gives the file descriptor associated with the event.
.\"O Otherwise,
.\"O there is no indication which file descriptors are pending, and you
.\"O should use the usual mechanisms
.\"O .RB ( select (2),
.\"O .BR poll (2),
.\"O .BR read (2)
.\"O with
.\"O .B O_NONBLOCK
.\"O set etc.) to determine which file descriptors are available for I/O.
.I si_code
フィールドが示すシグナルの原因が
.B SI_SIGIO
である場合、
.I si_fd
フィールドにはイベントに対応するファイルディスクリプタが入っている。
それ以外の場合は、どのファイルディスクリプタが利用可能かを示す情報は
ないので、どのファイルディスクリプタで I/O が可能かを判断するためには
通常の機構
.RB ( select (2),
.BR poll (2),
.B O_NONBLOCK
を設定した
.BR read (2)
など) を使用しなければならない。

.\"O By selecting a real time signal (value >=
.\"O .BR SIGRTMIN ),
.\"O multiple I/O events may be queued using the same signal numbers.
.\"O (Queuing is dependent on available memory).
.\"O Extra information is available
.\"O if
.\"O .B SA_SIGINFO
.\"O is set for the signal handler, as above.
リアルタイムシグナル (値が
.B SIGRTMIN
以上) を選択している場合は、
同じシグナル番号を持つ複数の I/O イベントがキューに入ることがある
(キューに入れるかどうかは利用可能なメモリに依存している)。
上記と同様、 
.B SA_SIGINFO
が設定されている場合、シグナルハンドラのための追加の情報が得られる。

.\"O Note that Linux imposes a limit on the
.\"O number of real-time signals that may be queued to a
.\"O process (see
.\"O .BR getrlimit (2)
.\"O and
.\"O .BR signal (7))
.\"O and if this limit is reached, then the kernel reverts to
.\"O delivering
.\"O .BR SIGIO ,
.\"O and this signal is delivered to the entire
.\"O process rather than to a specific thread.
.\" See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
以下の点に注意すること。
Linux では一つのプロセスに対してキューに入れられるリアルタイム
シグナルの数に上限が設けられており
.RB ( getrlimit (2)
と
.BR signal (7)
を参照)、この上限に達するとカーネルは
.B SIGIO
シグナルを配送する。この
.B SIGIO
シグナルは、指定されたスレッドではなくプロセス全体に送られる。
.PP
.\"O Using these mechanisms, a program can implement fully asynchronous I/O
.\"O without using
.\"O .BR select (2)
.\"O or
.\"O .BR poll (2)
.\"O most of the time.
これらの機構を使用することで、ほとんどの場合で
.BR select (2)
や
.BR poll (2)
を使用せずに完全な非同期 I/O を実装することができる。
.PP
.\"O The use of
.\"O .BR O_ASYNC ,
.\"O .BR F_GETOWN ,
.\"O .B F_SETOWN
.\"O is specific to BSD and Linux.
.BR O_ASYNC ,
.BR F_GETOWN ,
.B F_SETOWN
の使用は BSD と Linux に特有である。
.\"O .BR F_GETOWN_EX ,
.\"O .BR F_SETOWN_EX ,
.\"O .BR F_GETSIG ,
.\"O and
.\"O .B F_SETSIG
.\"O are Linux-specific.
.\"O POSIX has asynchronous I/O and the
.\"O .I aio_sigevent
.\"O structure to achieve similar things; these are also available
.\"O in Linux as part of the GNU C Library (Glibc).
.BR F_GETOWN_EX ,
.BR F_SETOWN_EX ,
.BR F_GETSIG ,
.B F_SETSIG
は Linux 固有である。POSIX には、同様のことを行うために、非同期 I/O と
.I aio_sigevent
構造体がある。Linux では、GNU C ライブラリ (Glibc) の一部として
これらも利用可能である。
.\"O .SS Leases
.SS "リース (leases)"
.\"O .B F_SETLEASE
.\"O and
.\"O .B F_GETLEASE
.\"O (Linux 2.4 onwards) are used (respectively) to establish a new lease,
.\"O and retrieve the current lease, on the open file description
.\"O referred to by the file descriptor
.\"O .IR fd .
(Linix 2.4 以降で利用可能)
.B F_SETLEASE
は、
.I fd
が参照するオープンファイル記述に対して新しいリースを設定するのに使用される。
.B F_GETLEASE
は、
.I fd
が参照するオープンファイル記述に対して設定されている
現在のリースを取得するのに使用される。
.\"O A file lease provides a mechanism whereby the process holding
.\"O the lease (the "lease holder") is notified (via delivery of a signal)
.\"O when a process (the "lease breaker") tries to
.\"O .BR open (2)
.\"O or
.\"O .BR truncate (2)
.\"O the file referred to by that file descriptor.
ファイルのリースにより、
あるプロセス ("lease breaker") がそのファイルディスクリプタが参照
しているファイルに対して
.BR open (2)
や
.BR truncate (2)
を行おうとした際に、リースを保持しているプロセス ("lease holder") へ
(シグナルの配送による) 通知が行われるという機構が提供される。
.TP
.BR F_SETLEASE " (\fIlong\fP)"
.\"O Set or remove a file lease according to which of the following
.\"O values is specified in the integer
.\"O .IR arg :
.I arg
の内容に基いてファイルのリースの設定、削除を行う。整数
.I arg
には以下の値が指定できる:

.RS
.TP
.B F_RDLCK
.\"O Take out a read lease.
.\"O This will cause the calling process to be notified when
.\"O the file is opened for writing or is truncated.
.\"O .\" The following became true in kernel 2.6.10:
.\"O .\" See the man-pages-2.09 Changelog for further info.
.\"O A read lease can only be placed on a file descriptor that
.\"O is opened read-only.
読み出しリースを取得する。これにより、
そのファイルが書き込み用にオープンされたり、ファイルが切り詰められた場合に、
呼び出し元のプロセスに通知が行われるようになる。
.\" 以下の内容はカーネル 2.6.10 で実装された。
.\" より詳しい情報は man-pages-2.09 の Changelog を参照。
読み出しリースを設定できるのは、読み出し専用でオープンされている
ファイルディスクリプタに対してのみである。
.TP
.B F_WRLCK
.\"O Take out a write lease.
.\"O This will cause the caller to be notified when
.\"O the file is opened for reading or writing or is truncated.
.\"O A write lease may be placed on a file only if there are no
.\"O other open file descriptors for the file.
書き込みリースを取得する。これにより、
(読み出し用か書き込み用にかかわらず) そのファイルがオープンされたり、
ファイルが切り詰められた場合に、呼び出し元のプロセスに通知が行われるようになる。
書き込みリースは、そのファイルに対するオープンされたファイルディスクリプタが
他にない場合にのみ設定できる。
.TP
.B F_UNLCK
.\"O Remove our lease from the file.
そのファイルからリースを削除する。
.RE
.P
.\"O Leases are associated with an open file description (see
.\"O .BR open (2)).
.\"O This means that duplicate file descriptors (created by, for example,
.\"O .BR fork (2)
.\"O or
.\"O .BR dup (2))
.\"O refer to the same lease, and this lease may be modified
.\"O or released using any of these descriptors.
.\"O Furthermore, the lease is released by either an explicit
.\"O .B F_UNLCK
.\"O operation on any of these duplicate descriptors, or when all
.\"O such descriptors have been closed.
リースはオープンファイル記述に対して関連付けられる
.RB ( open (2)
参照)。
つまり、
.RB ( fork (2)
や
.BR dup (2)
などにより作成された) ファイルディスクリプタの複製は同じリースを参照し、
複製も含めたどのファイルディスクリプタを使ってもこのリースを変更したり
解放したりできる。
また、これらのファイルディスクリプタのいずれかに対して
.B F_UNLCK
操作が明示的に実行された場合や、すべてのファイルディスクリプタが
閉じられた場合にも、リースは解放される。
.P
.\"O Leases may only be taken out on regular files.
.\"O An unprivileged process may only take out a lease on a file whose
.\"O UID (owner) matches the file system UID of the process.
.\"O A process with the
.\"O .B CAP_LEASE
.\"O capability may take out leases on arbitrary files.
リースの取得は通常のファイル (regular file) に対してのみ可能である。
非特権プロセスがリースを取得できるのは、UID (所有者) がプロセスの
ファイルシステム UID と一致するファイルに対してだけである。
.B CAP_LEASE
ケーパビリティを持つプロセスは任意のファイルに対してリースを取得できる。
.TP
.BR F_GETLEASE " (\fIvoid\fP)"
.\"O Indicates what type of lease is associated with the file descriptor
.\"O .I fd
.\"O by returning either
.\"O .BR F_RDLCK ", " F_WRLCK ", or " F_UNLCK ,
.\"O indicating, respectively, a read lease , a write lease, or no lease.
.\"O .I arg
.\"O is ignored.
ファイルディスクリプタ
.I fd
に対して設定されているリースの種別を取得する。
.BR F_RDLCK ", " F_WRLCK ", " F_UNLCK
のいずれかが返される。
.BR F_RDLCK ", " F_WRLCK
はそれぞれ、読み出しリース、書き込みリースが設定されていることを示し、
.B F_UNLCK
はリースが何も設定されていないことを示す。
.I arg
は無視される。
.PP
.\"O When a process (the "lease breaker") performs an
.\"O .BR open (2)
.\"O or
.\"O .BR truncate (2)
.\"O that conflicts with a lease established via
.\"O .BR F_SETLEASE ,
.\"O the system call is blocked by the kernel and
.\"O the kernel notifies the lease holder by sending it a signal
.\"O .RB ( SIGIO
.\"O by default).
あるプロセス ("lease folder") が
.B F_SETLEASE
で設定されたリースと矛盾するような
.BR open (2)
や
.BR truncate (2)
を実行した場合、
そのシステムコールはカーネルによって停止され、
カーネルは lease holder にシグナル (デフォルトでは
.BR SIGIO )
を送って通知を行う。
.\"O The lease holder should respond to receipt of this signal by doing
.\"O whatever cleanup is required in preparation for the file to be
.\"O accessed by another process (e.g., flushing cached buffers) and
.\"O then either remove or downgrade its lease.
lease holder はこのシグナルを受信したときにはきちんと対応すべきである。
具体的には、別のプロセスがそのファイルにアクセスするための準備として
必要な後片付け (例えば、キャッシュされたバッファのフラッシュ) を
すべて行ってから、そのファイルのリースの削除または格下げを行う。
.\"O A lease is removed by performing an
.\"O .B F_SETLEASE
.\"O command specifying
.\"O .I arg
.\"O as
.\"O .BR F_UNLCK .
リースを削除をするには、
.I arg
に
.B F_UNLCK
を指定して
.B F_SETLEASE
を実行する。
.\"O If the lease holder currently holds a write lease on the file,
.\"O and the lease breaker is opening the file for reading,
.\"O then it is sufficient for the lease holder to downgrade
.\"O the lease to a read lease.
.\"O This is done by performing an
.\"O .B F_SETLEASE
.\"O command specifying
.\"O .I arg
.\"O as
.\"O .BR F_RDLCK .
lease holder がファイルに書き込みリースを保持していて、
lease breaker が読み出し用にそのファイルをオープンしている場合、
lease holder が保持しているリースを読み出しリースに格下げすれば
十分である。これをするには、
.I arg
に
.B F_RDLCK
を指定して
.B F_SETLEASE
を実行する。

.\"O If the lease holder fails to downgrade or remove the lease within
.\"O the number of seconds specified in
.\"O .I /proc/sys/fs/lease-break-time
.\"O then the kernel forcibly removes or downgrades the lease holder's lease.
lease holder が
.I /proc/sys/fs/lease-break-time
で指定された秒数以内にリースの格下げか削除を行えなかった場合、
カーネルは強制的にその lease holder のリースを削除もしくは格下げを行う。

.\"O Once the lease has been voluntarily or forcibly removed or downgraded,
.\"O and assuming the lease breaker has not unblocked its system call,
.\"O the kernel permits the lease breaker's system call to proceed.
一度リースの削除か格下げが自発的もしくは強制的に行われると、
lease breaker がまだシステムコールを再開していない場合には、
カーネルが lease breaker のシステムコールの続行を許可する。

.\"O If the lease breaker's blocked
.\"O .BR open (2)
.\"O or
.\"O .BR truncate (2)
.\"O is interrupted by a signal handler,
.\"O then the system call fails with the error
.\"O .BR EINTR ,
.\"O but the other steps still occur as described above.
lease breaker が実行した
.BR open (2)
や
.BR truncate (2)
が停止中にシグナルハンドラにより中断された場合、
そのシステムコールは
.B EINTR
エラーで失敗するが、上で述べた他の処理は
そのまま行われる。
.\"O If the lease breaker is killed by a signal while blocked in
.\"O .BR open (2)
.\"O or
.\"O .BR truncate (2),
.\"O then the other steps still occur as described above.
.BR open (2)
や
.BR truncate (2)
が停止中に lease breaker がシグナルにより kill された場合、
上で述べた他の処理はそのまま行われる。
.\"O If the lease breaker specifies the
.\"O .B O_NONBLOCK
.\"O flag when calling
.\"O .BR open (2),
.\"O then the call immediately fails with the error
.\"O .BR EWOULDBLOCK ,
.\"O but the other steps still occur as described above.
lease breaker が
.BR open (2)
を呼ぶ際に
.B O_NONBLOCK
フラグを指定した場合、そのシステムコールは
.B EWOULDBLOCK
エラーで直ちに失敗するが、上で述べた他の処理はそのまま行われる。

.\"O The default signal used to notify the lease holder is
.\"O .BR SIGIO ,
.\"O but this can be changed using the
.\"O .B F_SETSIG
.\"O command to
.\"O .BR fcntl ().
.\"O If a
.\"O .B F_SETSIG
.\"O command is performed (even one specifying
.\"O .BR SIGIO ),
.\"O and the signal
.\"O handler is established using
.\"O .BR SA_SIGINFO ,
.\"O then the handler will receive a
.\"O .I siginfo_t
.\"O structure as its second argument, and the
.\"O .I si_fd
.\"O field of this argument will hold the descriptor of the leased file
.\"O that has been accessed by another process.
.\"O (This is useful if the caller holds leases against multiple files).
lease holder への通知に使われるデフォルトのシグナルは
.B SIGIO
だが、
.BR fcntl ()
の
.B F_SETSIG
コマンドで変更することができる。
.B F_SETSIG
コマンドが実行され
.RB ( SIGIO
を指定された場合も含む)、
.B SA_SIGINFO
フラグ付きでシグナルハンドラが設定されている場合には、
ハンドラの第二引き数として
.I siginfo_t
構造体が渡され、この引き数の
.I si_fd
フィールドには別のプロセスがアクセスしたリース設定済みファイルの
ディスクリプタが入っている
(この機能は複数のファイルに対してリースを設定する場合に有用である)。
.\"O .SS "File and directory change notification (dnotify)"
.SS "ファイルやディレクトリの変更の通知 (dnotify)"
.TP
.BR F_NOTIFY " (\fIlong\fP)"
.\"O (Linux 2.4 onwards)
(Linux 2.4 以降)
.\"O Provide notification when the directory referred to by
.\"O .I fd
.\"O or any of the files that it contains is changed.
.\"O The events to be notified are specified in
.\"O .IR arg ,
.\"O which is a bit mask specified by ORing together zero or more of
.\"O the following bits:
.I fd
で参照されるディレクトリか、その中にあるファイルに変更があった場合に
通知を行う。どのイベントを通知するかは
.I arg
で指定する。
.I arg
はビットマスクで、以下のビットの 0個以上の論理和をとったものを指定する。
.RS
.sp
.PD 0
.TP 12
.B DN_ACCESS
.\"O A file was accessed (read, pread, readv)
ファイルへのアクセスがあった (read, pread, readv)
.TP
.B DN_MODIFY
.\"O A file was modified (write, pwrite, writev, truncate, ftruncate).
ファイルの内容が変更された (write, pwrite, writev, truncate, ftruncate).
.TP
.B DN_CREATE
.\"O A file was created (open, creat, mknod, mkdir, link, symlink, rename).
ファイルが作成された (open, creat, mknod, mkdir, link, symlink, rename).
.TP
.B DN_DELETE
.\"O A file was unlinked (unlink, rename to another directory, rmdir).
ファイルが削除 (unlink) された (unlink, 別のディレクトリへの rename, rmdir)
.TP
.B DN_RENAME
.\"O A file was renamed within this directory (rename).
ディレクトリ内でのファイル名の変更があった (rename)
.TP
.B DN_ATTRIB
.\"O The attributes of a file were changed (chown, chmod, utime[s]).
ファイル属性が変更された (chown, chmod, utime[s])
.PD
.RE
.IP
.\"O (In order to obtain these definitions, the
.\"O .B _GNU_SOURCE
.\"O feature test macro must be defined.)
(上記の定義を利用するには
.B _GNU_SOURCE
機能検査マクロを定義しなければならない。)

.\"O Directory notifications are normally "one-shot", and the application
.\"O must reregister to receive further notifications.
ディレクトリの変更通知は通常「一回限り (one-shot)」であり、
アプリケーション側でその後さらに通知を受信したい場合は
再登録しなければならない。
.\"O Alternatively, if
.\"O .B DN_MULTISHOT
.\"O is included in
.\"O .IR arg ,
.\"O then notification will remain in effect until explicitly removed.
.I arg
に
.B DN_MULTISHOT
が含まれていた場合には、
変更通知は明示的に解除されるまで有効状態が継続する。

.\"O .\" The following does seem a poor API-design choice...
.\" 以下は API の設計がまずいと思うのだが...
.\"O A series of
.\"O .B F_NOTIFY
.\"O requests is cumulative, with the events in
.\"O .I arg
.\"O being added to the set already monitored.
.B F_NOTIFY
要求は積算されていく。つまり、
.I arg
で指定されたイベントがすでにモニタされている
イベント集合に加算される形になる。
.\"O To disable notification of all events, make an
.\"O .B F_NOTIFY
.\"O call specifying
.\"O .I arg
.\"O as 0.
すべてのイベントの通知を無効にするには、
.I arg
に 0 を指定して
.B F_NOTIFY
を呼び出す必要がある。

.\"O Notification occurs via delivery of a signal.
通知はシグナルの配送で行われる。
.\"O The default signal is
.\"O .BR SIGIO ,
.\"O but this can be changed using the
.\"O .B F_SETSIG
.\"O command to
.\"O .BR fcntl ().
デフォルトのシグナルは
.B SIGIO
だが、
.BR fcntl ()
の
.B F_SETSIG
コマンドで変更することができる。
.\"O In the latter case, the signal handler receives a
.\"O .I siginfo_t
.\"O structure as its second argument (if the handler was
.\"O established using
.\"O .BR SA_SIGINFO )
.\"O and the
.\"O .I si_fd
.\"O field of this structure contains the file descriptor which
.\"O generated the notification (useful when establishing notification
.\"O on multiple directories).
後者の場合には、
.RB ( SA_SIGINFO
フラグ付きでシグナルハンドラが設定されている場合には)
ハンドラの第二引き数として
.I siginfo_t
構造体が渡され、この構造体の
.I si_fd
フィールドには通知の行われたファイルディスクリプタが入っている
(この機能は複数のディレクトリに対して通知を設定する場合に有用である)。

.\"O Especially when using
.\"O .BR DN_MULTISHOT ,
.\"O a real time signal should be used for notification,
.\"O so that multiple notifications can be queued.
特に
.B DN_MULTISHOT
を使う場合は、通知にはリアルタイムシグナルを使うべきである。
それは、リアルタイムシグナルを使うことで、複数の通知をキューに入れる
ことができるからである。

.\"O .B NOTE:
.\"O New applications should use the
.\"O .I inotify
.\"O interface (available since kernel 2.6.13),
.\"O which provides a much superior interface for obtaining notifications of
.\"O file system events.
.\"O See
.\"O .BR inotify (7).
.B 注意:
新しくアプリケーションを書く際には、(カーネル 2.6.13 以降で利用可能となった)
.I inotify
インタフェースを使用すべきである。
.I inotify
はファイルシステムイベントの通知を取得するための
ずっと優れたインタフェースである。
.BR inotify (7)
を参照。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O For a successful call, the return value depends on the operation:
成功した場合の返り値は操作の種類により違う:
.TP 0.9i
.B F_DUPFD
.\"O The new descriptor.
新しいディスクリプタを返す。
.TP
.B F_GETFD
.\"O Value of flags.
フラグの値を返す。
.TP
.B F_GETFL
.\"O Value of flags.
フラグの値を返す。
.TP
.B F_GETLEASE
.\"O Type of lease held on file descriptor.
ファイルディスクリプタに対して保持されているリースの種別を返す。
.TP
.B F_GETOWN
.\"O Value of descriptor owner.
ディスクリプタの所有者を返す。
.TP
.B F_GETSIG
.\"O Value of signal sent when read or write becomes possible, or zero
.\"O for traditional
.\"O .B SIGIO
.\"O behavior.
読み込みや書き出しが可能になった時に送られるシグナルの値、もしくは
伝統的な
.B SIGIO
動作の場合にはゼロを返す。
.TP
.\"O All other commands
.\"O Zero.
他の全てのコマンドは 0 を返す。
.PP
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
エラーの時は \-1 が返され、
.I errno
に適切な値が設定される。
.\"O .SH ERRORS
.SH エラー
.TP
.\"O .BR EACCES " or " EAGAIN
.BR EACCES " か " EAGAIN
.\"O Operation is prohibited by locks held by other processes.
他のプロセスが保持しているロックによって操作が禁止されている。
.TP
.B EAGAIN
.\"O The operation is prohibited because the file has been memory-mapped by
.\"O another process.
そのファイルは他のプロセスによってメモリ・マップされているため、
操作が禁止されている。
.TP
.B EBADF
.\"O .I fd
.\"O is not an open file descriptor, or the command was
.\"O .B F_SETLK
.\"O or
.\"O .B F_SETLKW
.\"O and the file descriptor open mode doesn't match with the
.\"O type of lock requested.
.I fd
がオープンされたファイルディスクリプタでない。
あるいはコマンドが
.B F_SETLK
または
.B F_SETLKW
だったが、対象のファイルディスクリプタのオープンモードが
必要となるロックの型にマッチしていない。
.TP
.\"O .B EDEADLK
.\"O It was detected that the specified
.\"O .B F_SETLKW
.\"O command would cause a deadlock.
.B EDEADLK
指定された
.B F_SETLKW
コマンドを実行した場合にはデッドロックになることが検出された。
.TP
.B EFAULT
.\"O .I lock
.\"O is outside your accessible address space.
.I lock
が利用可能なアドレス空間の外部にある。
.TP
.B EINTR
.\"O For
.\"O .BR F_SETLKW ,
.\"O the command was interrupted by a signal; see
.\"O .BR signal (7).
.\"O For
.\"O .BR F_GETLK " and " F_SETLK ,
.\"O the command was interrupted by a signal before the lock was checked or
.\"O acquired.
.\"O Most likely when locking a remote file (e.g., locking over
.\"O NFS), but can sometimes happen locally.
.B F_SETLKW
コマンドがシグナルにより割り込まれた
.RB ( signal (7)
参照)。
.BR F_GETLK " と " F_SETLK
の場合、ロックを確認したり取得したりする前にシグナルによって割り込まれた。
これはたいていリモートのファイルをロックする場合
(例えば NFS 上でロックする場合) に起こる。
しかしローカルでも起こる場合がある。
.TP
.B EINVAL
.\"O For
.\"O .BR F_DUPFD ,
.\"O .I arg
.\"O is negative or is greater than the maximum allowable value.
.\"O For
.\"O .BR F_SETSIG ,
.\"O .I arg
.\"O is not an allowable signal number.
.BR F_DUPFD で、
.I arg
が負か、もしくは許される最大値よりも大きい。
.B F_SETSIG
の場合、
.I arg
が利用可能なシグナル番号ではない。
.TP
.B EMFILE
.\"O For
.\"O .BR F_DUPFD ,
.\"O the process already has the maximum number of file descriptors open.
.BR F_DUPFD で、
プロセスがすでに最大数までファイルディスクリプタをオープンしている。
.TP
.B ENOLCK
.\"O Too many segment locks open, lock table is full, or a remote locking
.\"O protocol failed (e.g., locking over NFS).
オープンされているロックの数が多過ぎて、ロック・テーブルがいっぱいである。
または remote locking protocol (例えば NFS 上のロック) が失敗した。
.TP
.B EPERM
.\"O Attempted to clear the
.\"O .B O_APPEND
.\"O flag on a file that has the append-only attribute set.
追加専用属性が設定されたファイルの
.B O_APPEND
フラグをクリアしようと試みた。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O SVr4, 4.3BSD, POSIX.1-2001.
SVr4, 4.3BSD, POSIX.1-2001.
.\"O Only the operations
.\"O .BR F_DUPFD ,
.\"O .BR F_GETFD ,
.\"O .BR F_SETFD ,
.\"O .BR F_GETFL ,
.\"O .BR F_SETFL ,
.\"O .BR F_GETLK ,
.\"O .BR F_SETLK ,
.\"O .BR F_SETLKW ,
.\"O .BR F_GETOWN ,
.\"O and
.\"O .B F_SETOWN
.\"O are specified in POSIX.1-2001.
POSIX.1-2001 で規定されている操作は、
.BR F_DUPFD ,
.BR F_GETFD ,
.BR F_SETFD ,
.BR F_GETFL ,
.BR F_SETFL ,
.BR F_GETLK ,
.BR F_SETLK ,
.BR F_SETLKW ,
.BR F_GETOWN ,
.B F_SETOWN
だけである。

.\"O .B F_DUPFD_CLOEXEC
.\"O is specified in POSIX.1-2008.
.B F_DUPFD_CLOEXEC
は POSIX.1-2008 で規定されている。

.\"O .BR F_GETOWN_EX ,
.\"O .BR F_SETOWN_EX ,
.\"O .BR F_GETSIG ,
.\"O .BR F_SETSIG ,
.\"O .BR F_NOTIFY ,
.\"O .BR F_GETLEASE ,
.\"O and
.\"O .B F_SETLEASE
.\"O are Linux-specific.
.\"O (Define the
.\"O .B _GNU_SOURCE
.\"O macro to obtain these definitions.)
.BR F_GETOWN_EX ,
.BR F_SETOWN_EX ,
.BR F_GETSIG ,
.BR F_SETSIG ,
.BR F_NOTIFY ,
.BR F_GETLEASE ,
.B F_SETLEASE
は Linux 固有である (これらの定義を有効にするには
.B _GNU_SOURCE
マクロを定義すること)。
.\" .PP
.\"O .\" SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
.\" SVr4 には他に EFAULT, EINTR, EIO, ENOLINK, EOVERFLOW エラー状態についての
.\" 記述がある。
.\"O .SH NOTES
.SH 注意
.\"O The errors returned by
.\"O .BR dup2 (2)
.\"O are different from those returned by
.\"O .BR F_DUPFD .
エラーの際の返り値が
.BR dup2 (2)
と
.B F_DUPFD
では異なっている。

.\"O Since kernel 2.0, there is no interaction between the types of lock
.\"O placed by
.\"O .BR flock (2)
.\"O and
.\"O .BR fcntl ().
カーネル 2.0 以降では、
.BR flock (2)
と
.BR fcntl ()
が設定するロック種別の間に相互作用はない。

.\"O Several systems have more fields in
.\"O .I "struct flock"
.\"O such as, for example,
.\"O .IR l_sysid .
.\"O .\" e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
.\"O .\" documents it in fcntl(5).  mtk, May 2007
.\"O Clearly,
.\"O .I l_pid
.\"O alone is not going to be very useful if the process holding the lock
.\"O may live on a different machine.
システムによっては、
.I "struct flock"
に上記以外のフィールドがあるものもある (例えば
.IR l_sysid )。
.\" e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
.\" documents it in fcntl(5).  mtk, May 2007
はっきりと言えることは、ロックを保持しているプロセスが別のマシンに存在
する場合には、
.I l_pid
だけはあまり役にたたないだろうということである。
.\"O .SH BUGS
.SH バグ
.\"O A limitation of the Linux system call conventions on some
.\"O architectures (notably i386) means that if a (negative)
.\"O process group ID to be returned by
.\"O .B F_GETOWN
.\"O falls in the range \-1 to \-4095, then the return value is wrongly
.\"O interpreted by glibc as an error in the system call;
.\"O .\" glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
.\"O that is, the return value of
.\"O .BR fcntl ()
.\"O will be \-1, and
.\"O .I errno
.\"O will contain the (positive) process group ID.
いくつかのアーキテクチャ (特に i386) における Linux システムコールの慣習
のため以下の制限が存在する。
.B F_GETOWN
が返す (負の) プロセスグループID が \-1 から \-4095 の範囲に入った場合、
glibc はこの返り値をシステムコールでエラーが起こったと
間違って解釈してしまう。つまり、
.BR fcntl ()
の返り値は \-1 となり、
.I errno
には (正の) プロセスグループID が設定されることになる。
.\"O The Linux-specific
.\"O .BR F_SETOWN_EX
.\"O and
.\"O .BR F_GETOWN_EX
.\"O operations avoid this problem.
Linux 固有の
.B F_SETOWN_EX
と
.B F_GETOWN_EX
ではこの問題を回避できる。
.\"O .\" mtk, Dec 04: some limited testing on alpha and ia64 seems to
.\"O .\" indicate that ANY negative PGID value will cause F_GETOWN
.\"O .\" to misinterpret the return as an error. Some other architectures
.\"O .\" seem to have the same range check as i386.
.\" mtk, Dec 04: alpha と ia64 では、少しテストしてみた限り、
.\" 「どんな」負の PGID でも F_GETOWN でエラーが起こったと間違って
.\" 解釈されてしまうようだ。他のいくつかのアーキテクチャでは、
.\" i386 と同様の範囲のチェックが行われているようだ。

.\"O In Linux 2.4 and earlier, there is bug that can occur
.\"O when an unprivileged process uses
.\"O .B F_SETOWN
.\"O to specify the owner
.\"O of a socket file descriptor
.\"O as a process (group) other than the caller.
.\"O In this case,
.\"O .BR fcntl ()
.\"O can return \-1 with
.\"O .I errno
.\"O set to
.\"O .BR EPERM ,
.\"O even when the owner process (group) is one that the caller
.\"O has permission to send signals to.
.\"O Despite this error return, the file descriptor owner is set,
.\"O and signals will be sent to the owner.
Linux 2.4 以前では、非特権プロセスが
.B F_SETOWN
を使って、ソケットのファイルディスクリプタの所有者に
呼び出し元以外のプロセス (やプロセスグループ) を指定すると
発生するバグがある。この場合、
呼び出し元が所有者として指定したプロセス (やプロセスグループ) に
シグナルを送る許可を持っていたとしても、
.BR fcntl ()
が \-1 を返し
.I errno
に
.B EPERM
を設定することがある。
このエラーが返ったにもかかわらず、ファイルディスクリプタの所有者
は設定され、シグナルはその所有者に送られる。

.\"O The implementation of mandatory locking in all known versions of Linux
.\"O is subject to race conditions which render it unreliable:
.\"O .\" http://marc.info/?l=linux-kernel&m=119013491707153&w=2
.\"O a
.\"O .BR write (2)
.\"O call that overlaps with a lock may modify data after the mandatory lock is
.\"O acquired;
.\"O a
.\"O .BR read (2)
.\"O call that overlaps with a lock may detect changes to data that were made
.\"O only after a write lock was acquired.
.\"O Similar races exist between mandatory locks and
.\"O .BR mmap (2).
.\"O It is therefore inadvisable to rely on mandatory locking.
これまでの Linux の全てのバージョンにおける強制ロックの実装は、
競合条件下で強制ロックが不完全になるような場合がある。
.\" http://marc.info/?l=linux-kernel&m=119013491707153&w=2
ロックと重なって実行された
.BR write (2)
の呼び出しは強制ロックが獲得された後にもデータを変更することができる。
ロックと重なって実行された
.BR read (2)
の呼び出しは強制ロックが獲得された後になって行われたデータの変更を
検出することができる。
同様の競合条件が強制ロックと
.BR mmap (2)
の間にも存在する。それゆえ、強制ロックに頼るのはお薦めできない。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR dup2 (2),
.BR flock (2),
.BR open (2),
.BR socket (2),
.BR lockf (3),
.BR capabilities (7),
.BR feature_test_macros (7)
.P
.\"O See also
.\"O .IR locks.txt ,
.\"O .IR mandatory-locking.txt ,
.\"O and
.\"O .I dnotify.txt
.\"O in the kernel source directory
.\"O .IR Documentation/filesystems/ .
.\"O (On older kernels, these files are directly under the
.\"O .I Documentation/
.\"O directory, and
.\"O .I mandatory-locking.txt
.\"O is called
.\"O .IR mandatory.txt .)
カーネルソースの
.IR Documentation/filesystems/
ディレクトリ内の
.IR locks.txt ,
.IR mandatory-locking.txt ,
.I dnotify.txt
も参照のこと。
(以前のカーネルでは、これらのファイルは
.I Documentation/
ディレクトリ直下にあり、
.I mandatory-locking.txt
は
.I mandatory.txt
という名前であった。)

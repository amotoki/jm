.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 1996 Andries Brouwer <aeb@cwi.nl>
.\" and Copyright (C) 2006, 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified 1997-01-31 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 2000-03-25 by Jim Van Zandt <jrv@vanzandt.mv.com>
.\" Modified 2001-10-04 by John Levon <moz@compsoc.man.ac.uk>
.\" Modified 2003-02-02 by Andi Kleen <ak@muc.de>
.\" Modified 2003-05-21 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	MAP_LOCKED works from 2.5.37
.\" Modified 2004-06-17 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified 2004-09-11 by aeb
.\" Modified 2004-12-08, from Eric Estievenart <eric.estievenart@free.fr>
.\" Modified 2004-12-08, mtk, formatting tidy-ups
.\" Modified 2006-12-04, mtk, various parts rewritten
.\" 2007-07-10, mtk, Added an example program.
.\" 2008-11-18, mtk, document MAP_STACK
.\"
.\" Japanese Version Copyright (c) 1997-2000 SUTO, Mitsuaki and NAKANO Takeo
.\"         all rights reserved.
.\" Translated 1997-06-26, SUTO, Mitsuaki <suto@av.crl.sony.co.jp>
.\" Updated & Modified 1999-03-01, NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Updated 2000-10-12, Nakano Takeo
.\" Updated 2001-08-16, Nakano Takeo
.\" Updated 2001-11-11, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2002-08-13, Akihiro MOTOKI
.\" Updated 2003-07- 2, Akihiro MOTOKI
.\" Updated 2003-09-14, Akihiro MOTOKI
.\" Updated & Modified 2004-12-28, Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated 2005-09-06, Akihiro MOTOKI
.\" Updated 2005-10-05, Akihiro MOTOKI
.\" Updated 2006-07-23, Akihiro MOTOKI, LDP v2.36
.\" Updated 2007-01-07, Akihiro MOTOKI, LDP v2.43
.\" Updated 2007-05-04, Akihiro MOTOKI, LDP v2.46
.\" Updated 2007-09-03, Akihiro MOTOKI, LDP v2.64
.\" Updated 2008-08-05, Akihiro MOTOKI, LDP v3.05
.\" Updated 2008-09-02, Akihiro MOTOKI, LDP v3.08
.\" Updated 2008-12-24, Akihiro MOTOKI, LDP v3.15
.\" Updated 2010-04-18, Akihiro MOTOKI, LDP v3.24
.\"
.\"WORD		file descriptor		ファイル記述子
.\"
.TH MMAP 2 2009-09-26 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O mmap, munmap \- map or unmap files or devices into memory
.SH 名前
mmap, munmap \- ファイルやデバイスをメモリにマップ/アンマップする
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/mman.h>
.sp
.BI "void *mmap(void *" addr ", size_t " length \
", int " prot ", int " flags ,
.BI "           int " fd ", off_t " offset );
.BI "int munmap(void *" addr ", size_t " length );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR mmap ()
.\"O creates a new mapping in the virtual address space of
.\"O the calling process.
.\"O The starting address for the new mapping is specified in
.\"O .IR addr .
.\"O The
.\"O .I length
.\"O argument specifies the length of the mapping.
.BR mmap ()
は、新しいマッピングを呼び出し元プロセスの仮想アドレス空間に作成する。
新しいマッピングの開始アドレスは
.I addr
で指定される。マッピングの長さは
.I length
引き数で指定される。

.\"O If
.\"O .I addr
.\"O is NULL,
.\"O then the kernel chooses the address at which to create the mapping;
.\"O this is the most portable method of creating a new mapping.
.\"O If
.\"O .I addr
.\"O is not NULL,
.\"O then the kernel takes it as a hint about where to place the mapping;
.\"O on Linux, the mapping will be created at a nearby page boundary.
.\"O .\" Before Linux 2.6.24, the address was rounded up to the next page
.\"O .\" boundary; since 2.6.24, it is rounded down!
.\"O The address of the new mapping is returned as the result of the call.
.I addr
が NULL の場合、カーネルがマッピングを作成するアドレスを選択する。
この方法は最も移植性のある新しいマッピングの作成方法である。
.I addr
が NULL でない場合、カーネルはマッピングをどこに配置するかのヒントとして
.I addr
を使用する。Linux では、マッピングはすぐ近くのページ境界に作成される。
.\" Linux 2.6.24 より前では、アドレスは (アドレスが大きくなる方向で)
.\" すぐ次のページ境界に切り上げられていた。
.\" Linux 2.6.24 以降では、切り下げられる!
新しいマッピングのアドレスは、呼び出しの返り値として返される。

.\"O The contents of a file mapping (as opposed to an anonymous mapping; see
.\"O .B MAP_ANONYMOUS
.\"O below), are initialized using
.\"O .I length
.\"O bytes starting at offset
.\"O .I offset
.\"O in the file (or other object) referred to by the file descriptor
.\"O .IR fd .
.\"O .I offset
.\"O must be a multiple of the page size as returned by
.\"O .IR sysconf(_SC_PAGE_SIZE) .
ファイルマッピングの内容は、
ファイルディスクリプタ
.I fd
で参照されるファイル (もしくは他のオブジェクト) のオフセット
.I offset
から開始される
.I length
バイトのデータで初期化される
(ファイルマッピングは無名マッピングの反対語である。
.B MAP_ANONYMOUS
を参照)。
.I offset
は
.I sysconf(_SC_PAGE_SIZE)
が返すページサイズの倍数でなければならない。
.LP
.\"O The
.\"O .I prot
.\"O argument describes the desired memory protection of the mapping
.\"O (and must not conflict with the open mode of the file).
.\"O It is either
.\"O .B PROT_NONE
.\"O or the bitwise OR of one or more of the following flags:
引き数
.I prot
には、マッピングのメモリ保護をどのように行なうかを指定する
(ファイルのオープンモードと矛盾してはいけない)。
.I prot
には、
.B PROT_NONE
か、以下のフラグをひとつ以上ビット毎の論理和 (OR) をとったものを
指定できる。
.TP 1.1i
.B PROT_EXEC
.\"O Pages may be executed.
ページは実行可能である。
.TP
.B PROT_READ
.\"O Pages may be read.
ページは読み込み可能である。
.TP
.B PROT_WRITE
.\"O Pages may be written.
ページに書き込み可能である。
.TP
.B PROT_NONE
.\"O Pages may not be accessed.
ページにはアクセスできない。
.LP
.\"O The
.\"O .I flags
.\"O argument determines whether updates to the mapping
.\"O are visible to other processes mapping the same region,
.\"O and whether updates are carried through to the underlying file.
.\"O This behavior is determined by including exactly one
.\"O of the following values in
.\"O .IR flags :
.I flags
引き数により、マッピングに対する更新が同じ領域をマッピングしている
他のプロセスに見えるか、更新がマッピング元のファイルを通じて
伝えられるか、が決定される。この動作は、以下の値のいずれか一つだけ
(複数は指定できない) を
.I flags
に含めることで指定する。
.TP 1.1i
.B MAP_SHARED
.\"O Share this mapping.
.\"O Updates to the mapping are visible to other processes that map this file,
.\"O and are carried through to the underlying file.
.\"O The file may not actually be updated until
.\"O .BR msync (2)
.\"O or
.\"O .BR munmap ()
.\"O is called.
このマッピングを共有する。
マッピングに対する更新はこのファイルをマッピングしている他のプロセス
から見える。更新はマッピング元のファイルを通じて伝えられる。
ただし、ファイルの実際の更新は
.BR msync (2)
または
.BR munmap ()
が呼ばれるまで行われないこともある。
.TP
.B MAP_PRIVATE
.\"O Create a private copy-on-write mapping.
.\"O Updates to the mapping are not visible to other processes
.\"O mapping the same file, and are not carried through to
.\"O the underlying file.
.\"O It is unspecified whether changes made to the file after the
.\"O .BR mmap ()
.\"O call are visible in the mapped region.
プライベートな copy-on-write (書き込み時コピー) マップを生成する。
マッピングに対する更新は同じファイルをマッピングしている他のプロセス
には見えず、更新がマッピング元のファイルを通じて伝えられることもない。
.BR mmap ()
の呼び出し後にマッピング元のファイルに対して行われた変更が、
マップ領域に反映されるかどうかは規定されていない。
.LP
.\"O Both of these flags are described in POSIX.1-2001.
上記の二つのフラグは POSIX.1-2001 で規定されている。

.\"O In addition, zero or more of the following values can be ORed in
.\"O .IR flags :
さらに、以下の値のうち 0 個以上をビット毎の論理和 (OR) で
.I flags
に指定することができる。
.TP
.\"O .BR MAP_32BIT " (since Linux 2.4.20, 2.6)"
.BR MAP_32BIT " (Linux 2.4.20, 2.6 以降)"
.\"O Put the mapping into the first 2 Gigabytes of the process address space.
.\"O This flag is only supported on x86-64, for 64-bit programs.
.\"O It was added to allow thread stacks to be allocated somewhere
.\"O in the first 2GB of memory,
.\"O so as to improve context-switch performance on some early
.\"O 64-bit processors.
.\"O .\" See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
.\"O Modern x86-64 processors no longer have this performance problem,
.\"O so use of this flag is not required on those systems.
.\"O The
.\"O .B MAP_32BIT
.\"O flag is ignored when
.\"O .B MAP_FIXED
.\"O is set.
マッピングをプロセスのアドレス空間の先頭 2 ギガバイト以内に配置する。
このフラグがサポートされているのは x86-64 アーキテクチャ上の
64 ビットプログラムのみである。
このフラグが追加されたのは、スレッドのスタックをメモリの先頭 2GB 以内の
どこかに割り当てることで、初期のいくつかの 64 ビットプロセッサにおける
コンテキストスイッチの性能問題を改善するためである。
.\" See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
最近の x86-64 プロセッサではこの性能問題はもはや存在せず、
そのようなシステムではこのフラグを使用する必要はない。
.B MAP_FIXED
がセットされている場合は、
.B MAP_32BIT
フラグは無視される。
.TP
.B MAP_ANON
.\"O Synonym for
.\"O .BR MAP_ANONYMOUS .
.\"O Deprecated.
.B MAP_ANONYMOUS
の同義語。非推奨。
.TP
.B MAP_ANONYMOUS
.\"O The mapping is not backed by any file;
.\"O its contents are initialized to zero.
.\"O The
.\"O .I fd
.\"O and
.\"O .I offset
.\"O arguments are ignored;
.\"O however, some implementations require
.\"O .I fd
.\"O to be \-1 if
.\"O .B MAP_ANONYMOUS
.\"O (or
.\"O .BR MAP_ANON )
.\"O is specified,
.\"O and portable applications should ensure this.
.\"O The use of
.\"O .B MAP_ANONYMOUS
.\"O in conjunction with
.\"O .B MAP_SHARED
.\"O is only supported on Linux since kernel 2.4.
マッピングはどのファイルとも関連付けされない。
マッピングの内容は 0 で初期化される。
引き数
.I fd
と
.I offset
は無視される。
ただし、実装によっては
.B MAP_ANONYMOUS
(もしくは
.BR MAP_ANON )
が指定された場合、
.I fd
を \-1 にする必要があり、
移植性が必要なアプリケーションでは必ず
.I fd
を \-1 にすべきである。
.B MAP_ANONYMOUS
と
.B MAP_SHARED
を組み合わせての利用は
カーネル 2.4 以降の Linux でのみサポートされている。
.TP
.B MAP_DENYWRITE
.\"O This flag is ignored.
.\"O .\" Introduced in 1.1.36, removed in 1.3.24.
.\"O (Long ago, it signaled that attempts to write to the underlying file
.\"O should fail with
.\"O .B ETXTBUSY .
.\"O But this was a source of denial-of-service attacks.)
このフラグは無視される
.\" 1.1.36 で導入され、1.3.24 で削除された。
(ずっと前は、マップ元のファイルへの書き込みを行おうとすると、エラー
.B ETXTBUSY
で失敗するようにシグナルが設定されていたが、これは denial-of-service
(サービス拒否) 攻撃の原因となった)。
.TP
.B MAP_EXECUTABLE
.\"O This flag is ignored.
このフラグは無視される。
.\"O .\" Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
.\"O .\" (Long ago, it signaled that the underlying file is an executable.
.\"O .\" However, that information was not really used anywhere.)
.\"O .\" Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
.\"O .\" MAP_DENYWRITE?
.\" 1.1.38 で導入され、1.3.24 で削除された。
.\" proc_follow_link でテストされるフラグである。(ずっと前は、
.\" マップ元のファイルが実行可能であることを知らせるようになっていた。
.\" しかし、その情報は実際にはどこでも使われなかった。)
.\" Linus は MAP_EXECUTABLE に関連して DoS の話をしたが、
.\" MAP_DENYWRITE のことを考えていたのかな？
.TP
.B MAP_FILE
.\"O Compatibility flag.
.\"O Ignored.
互換性のためのフラグ。無視される。
.\" On some systems, this was required as the opposite of
.\" MAP_ANONYMOUS -- mtk, 1 May 2007
.TP
.B MAP_FIXED
.\"O Don't interpret
.\"O .I addr
.\"O as a hint: place the mapping at exactly that address.
.\"O .I addr
.\"O must be a multiple of the page size.
.I addr
をアドレスのヒントとして使用するのではなく、
.I addr
で指定されたアドレスをそのまま使用してマッピングを配置する。
.I addr
はページサイズの倍数でなければならない。
.\"O If the memory region specified by
.\"O .I addr
.\"O and
.\"O .I len
.\"O overlaps pages of any existing mapping(s), then the overlapped
.\"O part of the existing mapping(s) will be discarded.
.I addr
と
.I len
で指定されたメモリ領域が既存のマッピングのページと重なる場合、
既存のマッピングの重なった部分は捨てられる。
.\"O If the specified address cannot be used,
.\"O .BR mmap ()
.\"O will fail.
もし指定されたアドレスが使用できない場合、
.BR mmap ()
は失敗する。
.\"O Because requiring a fixed address for a mapping is less portable,
.\"O the use of this option is discouraged.
マッピングに対して固定アドレスを要求するのは移植性の面で劣るので、
このオプションは使用しないことを推奨する。
.TP
.B MAP_GROWSDOWN
.\"O Used for stacks.
.\"O Indicates to the kernel virtual memory system that the mapping
.\"O should extend downwards in memory.
スタック用に使用される。マッピングをメモリ内で逆向きに行うことを
カーネル仮想メモリシステムに指示する。
(訳注：マッピングは通常はメモリ・アドレスが増加する向きに行うが、
このオプションを指定すると逆向きにマッピングを行う)
.TP
.\"O .BR MAP_HUGETLB " (since Linux 2.6.32)"
.BR MAP_HUGETLB " (Linux 2.6.32 以降)"
.\"O Allocate the mapping using "huge pages."
.\"O See the kernel source file
.\"O .I Documentation/vm/hugetlbpage.txt
.\"O for further information.
"huge page" を使ってマッピングを割り当てる。
詳しい情報は、カーネル・ソースの
.I Documentation/vm/hugetlbpage.txt
を参照。
.TP
.\"O .BR MAP_LOCKED " (since Linux 2.5.37)"
.BR MAP_LOCKED " (Linux 2.5.37 以降)"
.\"O Lock the pages of the mapped region into memory in the manner of
.\"O .BR mlock (2).
.\"O This flag is ignored in older kernels.
.\"O .\" If set, the mapped pages will not be swapped out.
マップされた領域のページを
.BR mlock (2)
の方法でメモリ内にロックする。
それ以前のカーネルでは、このフラグは無視される。
.\" このフラグがセットされていると、マッピングされたページはスワップアウト
.\" されない。
.TP
.\"O .BR MAP_NONBLOCK " (since Linux 2.5.46)"
.BR MAP_NONBLOCK " (Linux 2.5.46 以降)"
.\"O Only meaningful in conjunction with
.\"O .BR MAP_POPULATE .
.\"O Don't perform read-ahead:
.\"O only create page tables entries for pages
.\"O that are already present in RAM.
.B MAP_POPULATE
と組み合わせた場合のみ意味を持つ。
read-ahead (前もって読み込むこと) を実行しない。
単に、すでに RAM 上に存在するページに対して
ページテーブルエントリを作成するだけである。
.\"O Since Linux 2.6.23, this flag causes
.\"O .BR MAP_POPULATE
.\"O to do nothing.
.\"O One day the combination of
.\"O .BR MAP_POPULATE
.\"O and
.\"O .BR MAP_NONBLOCK
.\"O may be reimplemented.
Linux 2.6.23 以降では、このフラグは
.B MAP_POPULATE
に何の影響も与えない。
いつか
.B MAP_POPULATE
と
.B MAP_NONBLOCK
を組み合わせた場合の動作は実装し直されるかもしれない。
.TP
.B MAP_NORESERVE
.\"O Do not reserve swap space for this mapping.
.\"O When swap space is reserved, one has the guarantee
.\"O that it is possible to modify the mapping.
.\"O When swap space is not reserved one might get
.\"O .B SIGSEGV
.\"O upon a write
.\"O if no physical memory is available.
このマッピングに対するスワップ空間の予約を行わない。
スワップ空間を予約した場合は、このマッピングの変更が必ず可能なことが
保証される。予約を行わなかった場合、物理メモリに空きがないと
書き込み時に
.B SIGSEGV
エラーを受け取ることがある。
.\"O See also the discussion of the file
.\"O .I /proc/sys/vm/overcommit_memory
.\"O in
.\"O .BR proc (5).
.\"O In kernels before 2.6, this flag only had effect for
.\"O private writable mappings.
.BR proc (5)
の
.I /proc/sys/vm/overcommit_memory
ファイルについての議論も参照。
バージョン 2.6 より前のカーネルでは、このフラグは書き込み可能な
プライベート・マッピングについてのみ効果があった。
.TP
.\"O .BR MAP_POPULATE " (since Linux 2.5.46)"
.BR MAP_POPULATE " (Linux 2.5.46 以降)"
.\"O Populate (prefault) page tables for a mapping.
.\"O For a file mapping, this causes read-ahead on the file.
.\"O Later accesses to the mapping will not be blocked by page faults.
.\"O .BR MAP_POPULATE
.\"O is only supported for private mappings since Linux 2.6.23.
マッピング用のページテーブルを配置 (populate) する
ファイルマッピングの場合には、これによりファイルが先読み (read-ahead)
が行われる。この以後は、マッピングに対するアクセスがページフォールトで
ブロックされることがなくなる。
.BR MAP_POPULATE
は Linux 2.6.23 以降でプライベート・マッピングについてのみ
サポートされている。
.LP
.\"O Of the above flags, only
.\"O .B MAP_FIXED
.\"O is specified in POSIX.1-2001.
.\"O However, most systems also support
.\"O .B MAP_ANONYMOUS
.\"O (or its synonym
.\"O .BR MAP_ANON ).
上記のフラグの中では、
.B MAP_FIXED
だけが POSIX.1-2001 で規定されている。
しかしながら、ほとんどのシステムで
.B MAP_ANONYMOUS
(またはその同義語である
.BR MAP_ANON )
もサポートされている。
.TP
.\"O .BR MAP_STACK " (since Linux 2.6.27)"
.BR MAP_STACK " (Linux 2.6.27 以降)"
.\"O Allocate the mapping at an address suitable for a process
.\"O or thread stack.
.\"O This flag is currently a no-op,
.\"O but is used in the glibc threading implementation so that
.\"O if some architectures require special treatment for stack allocations,
.\"O support can later be transparently implemented for glibc.
プロセスやスレッドのスタックに適したアドレスにマッピングを割り当てる。
現在のところ、このフラグは何もしないが、
glibc のスレッド実装では使用されている。
これは、いくつかのアーキテクチャではスタックの割り当てに関して特別な扱い
が必要な場合に、glibc にそのサポートを後で透過的に実装できるようにする
ためである。
.\" See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
.\" commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
.\" http://thread.gmane.org/gmane.linux.kernel/720412
.\" "pthread_create() slow for many threads; also time to revisit 64b
.\"  context switch optimization?"
.LP
.\"O Some systems document the additional flags
.\"O .BR MAP_AUTOGROW ,
.\"O .BR MAP_AUTORESRV ,
.\"O .BR MAP_COPY ,
.\"O and
.\"O .BR MAP_LOCAL .
いくつかのシステムでは、上記以外にフラグとして
.BR MAP_AUTOGROW ,
.BR MAP_AUTORESRV ,
.BR MAP_COPY ,
.B MAP_LOCAL
が規定されている。
.LP
.\"O Memory mapped by
.\"O .BR mmap ()
.\"O is preserved across
.\"O .BR fork (2),
.\"O with the same attributes.
.BR mmap ()
によってマップされたメモリの属性は
.BR fork (2)
の際に継承される。
.LP
.\"O A file is mapped in multiples of the page size.
.\"O For a file that is not
.\"O a multiple of the page size, the remaining memory is zeroed when mapped,
.\"O and writes to that region are not written out to the file.
.\"O The effect of
.\"O changing the size of the underlying file of a mapping on the pages that
.\"O correspond to added or removed regions of the file is unspecified.
ファイルはページサイズの整数倍の領域にマップされる。サイズがページサイズの
整数倍でないファイルの場合、マップ時に残りの領域は 0 で埋められ、この領域へ
書きこみを行ってもファイルに書き出されることはない。マッピングを行った元
ファイルのサイズを変更した場合、元ファイルの追加されたり削除された領域に対応
するマップされたページに対してどのような影響があるかは規定されていない。
.SS munmap()
.\"O The
.\"O .BR munmap ()
.\"O system call deletes the mappings for the specified address range, and
.\"O causes further references to addresses within the range to generate
.\"O invalid memory references.
.\"O The region is also automatically unmapped
.\"O when the process is terminated.
.\"O On the other hand, closing the file
.\"O descriptor does not unmap the region.
システムコール
.BR munmap ()
は指定されたアドレス範囲のマップを消去し、
これ以降のその範囲内へのメモリ参照は不正となる。
この領域は、プロセスが終了したときにも自動的にアンマップされる。
一方、ファイル記述子をクローズしても、この領域はアンマップされない。
.LP
.\"O The address
.\"O .I addr
.\"O must be a multiple of the page size.
.\"O All pages containing a part
.\"O of the indicated range are unmapped, and subsequent references
.\"O to these pages will generate
.\"O .BR SIGSEGV .
.\"O It is not an error if the
.\"O indicated range does not contain any mapped pages.
.I addr
アドレスはページサイズの整数倍でなければならない。指定された範囲の一部分を
含む全てのページはアンマップされ、これ以降にこれらのページへの参照があると
.B SIGSEGV
が発生する。
指定した範囲内にマップされたページが一つも含まれていない場合でも
エラーにならない。
.\"O .SS Timestamps changes for file-backed mappings
.SS ファイルと関連付けられたマッピングに対するタイムスタンプの更新
.\"O For file-backed mappings, the
.\"O .I st_atime
.\"O field for the mapped file may be updated at any time between the
.\"O .BR mmap ()
.\"O and the corresponding unmapping; the first reference to a mapped
.\"O page will update the field if it has not been already.
ファイルと関連付けられたマッピングの場合、マッピングされたファイルの
.I st_atime
フィールドは、
.BR mmap ()
されてからアンマップ (unmap) されるまでの間に更新されることがある。
それまでに更新が行われていなければ、マップされたページへの最初の参照があった
際に更新される。
.LP
.\"O The
.\"O .I st_ctime
.\"O and
.\"O .I st_mtime
.\"O field for a file mapped with
.\"O .B PROT_WRITE
.\"O and
.\"O .B MAP_SHARED
.\"O will be updated after
.\"O a write to the mapped region, and before a subsequent
.\"O .BR msync (2)
.\"O with the
.\"O .B MS_SYNC
.\"O or
.\"O .B MS_ASYNC
.\"O flag, if one occurs.
.B PROT_WRITE
と
.B MAP_SHARED
の両方を指定してマップされたファイルの場合、書き込みがあると、
.I st_ctime
と
.I st_mtime
の両フィールドは、マップされた領域への書き込みより後で、
.B MS_SYNC
または
.B MS_ASYNC
フラグを指定して
.BR msync (2)
が呼ばれる前までに更新される。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success,
.\"O .BR mmap ()
.\"O returns a pointer to the mapped area.
.\"O On error, the value
.\"O .B MAP_FAILED
.\"O (that is,
.\"O .IR "(void\ *)\ \-1" )
.\"O is returned, and
.\"O .I errno
.\"O is set appropriately.
.BR mmap ()
は成功するとマップされた領域へのポインタを返す。
失敗すると値
.B MAP_FAILED
(つまり
.IR "(void\ *)\ \-1" )
を返し、
.I errno
がエラーの内容にしたがってセットされる。
.\"O On success,
.\"O .BR munmap ()
.\"O returns 0, on failure \-1, and
.\"O .I errno
.\"O is set (probably to
.\"O .BR EINVAL ).
.BR munmap ()
は成功すると 0 を返す。失敗すると \-1 を返し、
.I errno
がセットされる (多くの場合
.B EINVAL
になるだろう)。
.\"O .SH ERRORS
.SH エラー
.TP
.B EACCES
.\"O A file descriptor refers to a non-regular file.
.\"O Or
.\"O .B MAP_PRIVATE
.\"O was requested, but
.\"O .I fd
.\"O is not open for reading.
.\"O Or
.\"O .B MAP_SHARED
.\"O was requested and
.\"O .B PROT_WRITE
.\"O is set, but
.\"O .I fd
.\"O is not open in read/write
.\"O .RB ( O_RDWR )
.\"O mode.
.\"O \"O Or
.\"O .B PROT_WRITE
.\"O is set, but the file is append-only.
以下のいずれかの場合。
ファイル記述子の参照先が通常のファイルではない (non-regular file) 。
.B MAP_PRIVATE
を要求したが
.I fd
は読み込み用にオープンされていない。
.B MAP_SHARED
を要求して
.B PROT_WRITE
をセットしたが
.I fd
は読み書きモード
.RB ( O_RDWR )
でオープンされていない、
.B PROT_WRITE
をセットしたが、ファイルは追加 (append) 専用である。
.TP
.B EAGAIN
.\"O The file has been locked, or too much memory has been locked (see
.\"O .BR setrlimit (2)).
ファイルがロックされている。またはロックされているメモリが多すぎる
.RB ( setrlimit (2)
を参照)。
.TP
.B EBADF
.\"O .I fd
.\"O is not a valid file descriptor (and
.\"O .B MAP_ANONYMOUS
.\"O was not set).
.I fd
が有効なファイル記述子 (file descriptor) ではない
(かつ
.B MAP_ANONYMOUS
がセットされていない)。
.TP
.B EINVAL
.\"O We don't like
.\"O .IR addr ,
.\"O .IR length ,
.\"O or
.\"O .I offset
.\"O (e.g., they are too large, or not aligned on a page boundary).
.I addr
か
.I length
か
.I offset
が適切でない
(例えば、大きすぎるとか、ページ境界にアラインメントされていない)。
.TP
.B EINVAL
.\"O (since Linux 2.6.12)
.\"O .I length
.\"O was 0.
(Linux 2.6.12 以降)
.I length
が 0 であった。
.TP
.B EINVAL
.\"O .I flags
.\"O contained neither
.\"O .B MAP_PRIVATE
.\"O or
.\"O .BR MAP_SHARED ,
.\"O or contained both of these values.
.I flags
に
.B MAP_PRIVATE
と
.B MAP_SHARED
のどちらも含まれていなかった、もしくは
その両方が含まれていた。
.TP
.B ENFILE
.\"O .\" This is for shared anonymous segments
.\" これは共有匿名 (anonymous) セグメントのためのものである。
.\" [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
.\"O The system limit on the total number of open files has been reached.
オープンされたファイルの総数がシステムの制限に達した。
.\" .TP
.\" .B ENOEXEC
.\"O .\" A file could not be mapped for reading.
.\" ファイルを読み込み用にマップできなかった。
.TP
.B ENODEV
.\"O The underlying file system of the specified file does not support
.\"O memory mapping.
指定されたファイルが置かれているファイルシステムがメモリマッピングをサポート
していない。
.TP
.B ENOMEM
.\"O No memory is available, or the process's maximum number of mappings would
.\"O have been exceeded.
メモリに空きがない、または処理中のプロセスのマッピング数が最大数を超過した。
.TP
.B EPERM
.\"O The
.\"O .I prot
.\"O argument asks for
.\"O .B PROT_EXEC
.\"O but the mapped area belongs to a file on a file system that
.\"O was mounted no-exec.
.\"O .\" (Since 2.4.25 / 2.6.0.)
.I prot
引き数は
.B PROT_EXEC
を行うように指定されているが、
no-exec でマウントされたファイルシステム上のファイルに
マップ領域が対応している。
.\" (2.4.25 / 2.6.0 以降)
.TP
.B ETXTBSY
.\"O .B MAP_DENYWRITE
.\"O was set but the object specified by
.\"O .I fd
.\"O is open for writing.
.B MAP_DENYWRITE
がセットされているが
.I fd
で指定されているオブジェクトは書き込み用に開かれている。
.LP
.\"O Use of a mapped region can result in these signals:
マップ領域を利用する際に、以下のシグナルが発生することがある:
.TP
.B SIGSEGV
.\"O Attempted write into a region mmaped as read-only.
読み込み専用で mmap された領域へ書き込みを行おうとした。
.TP
.B SIGBUS
.\"O Attempted access to a portion of the buffer that does not correspond
.\"O to the file (for example, beyond the end of the file, including the
.\"O case where another process has truncated the file).
バッファのうち、ファイルに関連づけられていない部分
(例えばファイル末尾を越えた部分など。これには
他のプロセスがファイルを切り詰めた場合なども含まれる)
にアクセスしようとした。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O SVr4, 4.4BSD, POSIX.1-2001.
.\"O .\" SVr4 documents additional error codes ENXIO and ENODEV.
.\"O .\" SUSv2 documents additional error codes EMFILE and EOVERFLOW.
SVr4, 4.4BSD, POSIX.1-2001.
.\" SVr4 にはさらに ENXIO と ENODEV のエラーコードについての記述がある。
.\" SUSv2 にはさらに EMFILE と EOVERFLOW のエラーコードについての記述がある。
.\"O .SH AVAILABILITY
.SH 可用性
.\"O On POSIX systems on which
.\"O .BR mmap (),
.\"O .BR msync (2)
.\"O and
.\"O .BR munmap ()
.\"O are available,
.\"O .B _POSIX_MAPPED_FILES
.\"O is defined in \fI<unistd.h>\fP to a value greater than 0.
.\"O (See also
.\"O .BR sysconf (3).)
.\"O .\" POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
.\"O .\" -1: unavailable, 0: ask using sysconf().
.\"O .\" glibc defines it to 1.
.BR mmap (),
.BR msync (2)
.BR munmap ()
が利用可能な POSIX システムでは、
.B _POSIX_MAPPED_FILES
は <unistd.h> で 0 より大きな値に定義される
.RB ( sysconf (3)
も参照のこと)。
.\" POSIX.1-2001: _POSIX_MAPPED_FILES は -1 か 0 か 200112L の
.\" いずれかに定義されることになっている。
.\" -1: 利用不可、0: sysconf() に問いあわせる
.\" glibc では POSIX_MAPPED_FILES は 1 に定義されている。
.\"O .SH NOTES
.SH 注意
.\"O Since kernel 2.4, this system call has been superseded by
.\"O .BR mmap2 (2).
.\"O Nowadays,
.\"O .\" Since around glibc 2.1/2.2, depending on the platform.
.\"O the glibc
.\"O .BR mmap ()
.\"O wrapper function invokes
.\"O .BR mmap2 (2)
.\"O with a suitably adjusted value for
.\"O .IR offset .
カーネル 2.4 以降、このシステムコールは
.BR mmap2 (2)
に取って代わられた。
現在では、
.\" プラットフォームにより異なるが、 glibc 2.1/2.2 あたりから。
glibc の
.BR mmap ()
のラッパー関数は
.I offset
を適切に調整してから
.BR mmap2 (2)
を起動する。

.\"O On some hardware architectures (e.g., i386),
.\"O .B PROT_WRITE
.\"O implies
.\"O .BR PROT_READ .
.\"O It is architecture dependent whether
.\"O .B PROT_READ
.\"O implies
.\"O .B PROT_EXEC
.\"O or not.
.\"O Portable programs should always set
.\"O .B PROT_EXEC
.\"O if they intend to execute code in the new mapping.
(i386 などの) いくつかのアーキテクチャでは、
.B PROT_WRITE
をセットすると、暗黙のうちに
.B PROT_READ
がセットされる。
.B PROT_READ
をセットした際に暗黙のうちに
.B PROT_EXEC
がセットされるかどうかは、アーキテクチャ依存である。
移植性を考慮したプログラムでは、
新規にマップした領域でコードを実行したい場合は、常に
.B PROT_EXEC
をセットすべきである。

.\"O The portable way to create a mapping is to specify
.\"O .I addr
.\"O as 0 (NULL), and omit
.\"O .B MAP_FIXED
.\"O from
.\"O .IR flags .
.\"O In this case, the system chooses the address for the mapping;
.\"O the address is chosen so as not to conflict with any existing mapping,
.\"O and will not be 0.
.\"O If the
.\"O .B MAP_FIXED
.\"O flag is specified, and
.\"O .I addr
.\"O is 0 (NULL), then the mapped address will be 0 (NULL).
マッピングを作成する移植性のある方法は、
.I addr
に 0 (NULL) を指定し、
.I flags
から
.B MAP_FIXED
を外すことである。
この場合、システムがマッピング用のアドレスの選択を行う。
アドレスは既存のマッピングと衝突しないように、
かつ 0 にならないように選択される。
.B MAP_FIXED
フラグが指定され、かつ
.I addr
が 0 (NULL)
の場合には、マップされるアドレスが 0 (NULL) になる。
.\"O .SH BUGS
.SH バグ
.\"O On Linux there are no guarantees like those suggested above under
.\"O .BR MAP_NORESERVE .
.\"O By default, any process can be killed
.\"O at any moment when the system runs out of memory.
Linux においては、上記の
.B MAP_NORESERVE
で述べられているような保証はない。
デフォルトでは、システムがメモリを使い切った場合には、
どのプロセスがいつ強制終了されるか分からないからである。

.\"O In kernels before 2.6.7, the
.\"O .B MAP_POPULATE
.\"O flag only has effect if
.\"O .I prot
.\"O is specified as
.\"O .BR PROT_NONE .
2.6.7 より前のカーネルでは、
.I prot
に
.B PROT_NONE
が指定された場合にのみ、
.B MAP_POPULATE
フラグが効力を持つ。

.\"O SUSv3 specifies that
.\"O .BR mmap ()
.\"O should fail if
.\"O .I length
.\"O is 0.
.\"O However, in kernels before 2.6.12,
.\"O .BR mmap ()
.\"O succeeded in this case: no mapping was created and the call returned
.\"O .IR addr .
.\"O Since kernel 2.6.12,
.\"O .BR mmap ()
.\"O fails with the error
.\"O .B EINVAL
.\"O for this case.
SUSv3 では、
.I length
が 0 の場合、
.BR mmap ()
は失敗すると規定されている。しかしながら、2.6.12 より前のカーネルでは、
この場合に
.BR mmap ()
は成功していた (マッピングは作成されず、
.I addr
が返されていた)。
カーネル 2.6.12 以降では、
.BR mmap ()
はエラー
.B EINVAL
で失敗する。
.\"O .SH EXAMPLE
.SH 例
.\" FIXME . Add an example here that uses an anonymous shared region for
.\" IPC between parent and child.
.PP
.\"O The following program prints part of the file specified in
.\"O its first command-line argument to standard output.
.\"O The range of bytes to be printed is specified via offset and length
.\"O values in the second and third command-line arguments.
.\"O The program creates a memory mapping of the required
.\"O pages of the file and then uses
.\"O .BR write (2)
.\"O to output the desired bytes.
以下のプログラムは、一番目のコマンドライン引き数で指定された
ファイルの一部を標準出力に表示する。
表示する範囲は、二番目、三番目のコマンドライン引き数で渡される
オフセットと長さで指定される。
このプログラムは、指定されたファイルの必要なページのメモリ・
マッピングを作成し、
.BR write (2)
を使って所望のバイトを出力する。
.nf

#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define handle_error(msg) \\
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
    char *addr;
    int fd;
    struct stat sb;
    off_t offset, pa_offset;
    size_t length;
    ssize_t s;

    if (argc < 3 || argc > 4) {
        fprintf(stderr, "%s file offset [length]\\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    fd = open(argv[1], O_RDONLY);
    if (fd == \-1)
        handle_error("open");

    if (fstat(fd, &sb) == \-1)           /* To obtain file size */
        handle_error("fstat");

    offset = atoi(argv[2]);
    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) \- 1);
        /* offset for mmap() must be page aligned */

    if (offset >= sb.st_size) {
        fprintf(stderr, "offset is past end of file\\n");
        exit(EXIT_FAILURE);
    }

    if (argc == 4) {
        length = atoi(argv[3]);
        if (offset + length > sb.st_size)
            length = sb.st_size \- offset;
                /* Can\(aqt display bytes past end of file */

    } else {    /* No length arg ==> display to end of file */
        length = sb.st_size \- offset;
    }

    addr = mmap(NULL, length + offset \- pa_offset, PROT_READ,
                MAP_PRIVATE, fd, pa_offset);
    if (addr == MAP_FAILED)
        handle_error("mmap");

    s = write(STDOUT_FILENO, addr + offset \- pa_offset, length);
    if (s != length) {
        if (s == \-1)
            handle_error("write");

        fprintf(stderr, "partial write");
        exit(EXIT_FAILURE);
    }

    exit(EXIT_SUCCESS);
} /* main */
.fi
\"O .SH "SEE ALSO"
.SH 関連項目
.BR getpagesize (2),
.BR mincore (2),
.BR mlock (2),
.BR mmap2 (2),
.BR mprotect (2),
.BR mremap (2),
.BR msync (2),
.BR remap_file_pages (2),
.BR setrlimit (2),
.BR shmat (2),
.BR shm_open (3),
.BR shm_overview (7)
.br
B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391.
.\"
.\"O .\" Repeat after me: private read-only mappings are 100% equivalent to
.\"O .\" shared read-only mappings. No ifs, buts, or maybes. -- Linus
.\" 私の後について言ってみて: プライベートな読み込み専用のマッピングは
.\" 共有された読み込み専用のマッピングと 100% 等しい。
.\" 「もし」も「しかし」も「たぶん」もない。-- Linus

.\" Copyright (c) 1983, 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\" Modified 1993-07-24 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1996-10-21 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 1998-2000 by Andi Kleen to match Linux 2.2 reality
.\" Modified 2002-04-23 by Roger Luethi <rl@hellgate.ch>
.\" Modified 2004-06-17 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" 2008-12-04, mtk, Add documentation of accept4()
.\"
.\" Japanese Version Copyright (c) 1998-2000 Shinya HANATAKA,
.\"   Takeshi Hakamada and NAKANO Takeo
.\"         all rights reserved.
.\" Translated 1998-04-06, Shinya HANATAKA <shinya@abyss.rim.or.jp>
.\"                        Takeshi Hakamada <hakamada@nsg.sgi.com>
.\" Updated & Modified 2000-10-12, NAKANO Takeo <nakano@apm.seikei.ac.jp
.\" Updated & Modified 2002-09-24, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated & Modified 2005-02-23, Akihiro MOTOKI
.\" Updated & Modified 2006-04-14, Akihiro MOTOKI, LDP v2.29
.\" Updated & Modified 2008-12-24, Akihiro MOTOKI, LDP v3.15
.\" Updated 2008-04-13, Akihiro MOTOKI, LDP v3.20
.\"
.\"WORD:	pending			保留中の
.\"WORD:	queue			キュー
.\"WORD:	file descriptor		ファイル・ディスクリプタ
.\"WORD:	nonblocking		非停止
.\"WORD:	async			非同期
.\"WORD:	communication layer	通信層
.\"WORD:	value-result argument	入出力両用の引き数
.\"WORD:	confirmation		接続確認
.\"WORD:	dequeue			キューから取り出す
.\"WORD:	rejection		接続拒否
.\"
.TH ACCEPT 2 2009-02-23 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O accept \- accept a connection on a socket
.SH 名前
accept \- ソケットへの接続を受ける
.\"O .SH SYNOPSIS
.SH 書式
.nf
.\"O .BR "#include <sys/types.h>" "          /* See NOTES */"
.BR "#include <sys/types.h>" "          /* 「注意」参照 */"
.B #include <sys/socket.h>

.BI "int accept(int " sockfd ", struct sockaddr *" addr ", socklen_t *" addrlen );

.B #define _GNU_SOURCE
.B #include <sys/socket.h>

.BI "int accept4(int " sockfd ", struct sockaddr *" addr ,
.BI "            socklen_t *" addrlen ", int " flags );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR accept ()
.\"O system call is used with connection-based socket types
.\"O .RB ( SOCK_STREAM ,
.\"O .BR SOCK_SEQPACKET ).
.BR accept ()
システムコールは、接続指向のソケット型
.RB ( SOCK_STREAM ", " SOCK_SEQPACKET )
で用いられる。
.\"O It extracts the first connection request on the queue of pending
.\"O connections for the listening socket,
.\"O .IR sockfd ,
.\"O creates a new connected socket, and returns a new file
.\"O descriptor referring to that socket.
この関数は、接続待ちソケット
.I socket
宛ての保留状態の接続要求が入っているキューから
先頭の接続要求を取り出し、接続済みソケットを新規に生成し、
そのソケットを参照する新しいファイル・ディスクリプタを返す。
.\"O The newly created socket is not in the listening state.
新規に生成されたソケットは、接続待ち (listen) 状態ではない。
.\"O The original socket
.\"O .I sockfd
.\"O is unaffected by this call.
もともとのソケット
.I sockfd
はこの呼び出しによって影響を受けない。
.PP
.\"O The argument
.\"O .I sockfd
.\"O is a socket that has been created with
.\"O .BR socket (2),
.\"O bound to a local address with
.\"O .BR bind (2),
.\"O and is listening for connections after a
.\"O .BR listen (2).
引き数
.I sockfd
は、
.BR socket (2)
によって生成され、
.BR bind (2)
によってローカルアドレスにバインドされ、
.BR listen (2)
を経て接続を待っているソケットである。

.\"O The argument
.\"O .I addr
.\"O is a pointer to a
.\"O .I sockaddr
.\"O structure.
.\"O This structure is filled in with the address of the peer socket,
.\"O as known to the communications layer.
.\"O The exact format of the address returned
.\"O .I addr
.\"O is determined by the socket's address family (see
.\"O .BR socket (2)
.\"O and the respective protocol man pages).
.I addr
引き数は
.I sockaddr
構造体へのポインタである。
この構造体には接続相手のソケットのアドレスが入っている。
.I addr
引き数で返されるアドレスの正確なフォーマットは、
ソケットのアドレス種別によって変わる
.RB ( socket (2)
およびそれぞれのプロトコルの man ページを参照)。
.\"O When
.\"O .I addr
.\"O is NULL, nothing is filled in; in this case,
.\"O .I addrlen
.\"O is not used, and should also be NULL.
.I addr
が NULL の場合、
.I addr
には何も入らない。この場合、
.I addrlen
は使用されず、この引き数は NULL にしておくべきである。

.\"O The
.\"O .I addrlen
.\"O argument is a value-result argument:
.\"O the caller must initialize it to contain the
.\"O size (in bytes) of the structure pointed to by
.\"O .IR addr ;
.\"O on return it will contain the actual size of the peer address.
.I addrlen
引き数は入出力両用の引き数である。呼び出し時には、呼び出し元が
.I addr
が指す構造体のサイズ (バイト単位) で初期化しておかなければならない。
返ってくる時には、接続相手のアドレスの実際の大きさが格納される。

.\"O The returned address is truncated if the buffer provided is too small;
.\"O in this case,
.\"O .I addrlen
.\"O will return a value greater than was supplied to the call.
渡されたバッファが小さ過ぎる場合には、返されるアドレスの末尾は
切り詰められる。この場合には、
.I addrlen
では、呼び出し時に渡された値よりも大きな値が返される。
.PP
.\"O If no pending
.\"O connections are present on the queue, and the socket is not marked as
.\"O nonblocking,
.\"O .BR accept ()
.\"O blocks the caller until a connection is present.
.\"O If the socket is marked
.\"O nonblocking and no pending connections are present on the queue,
.\"O .BR accept ()
.\"O fails with the error
.\"O .BR EAGAIN
.\"O or
.\"O .BR EWOULDBLOCK .
キューに保留となっている接続要求がなく、
かつソケットが非停止になっていないときは、
.BR accept ()
は接続が発生するまで呼び出し元を停止 (block) する。
ソケットが非停止になっていて、
待ち状態の接続要求がキューに無いときは、
.BR accept ()
はエラー
.B EAGAIN
か
.B EWOULDBLOCK
で失敗する。
.PP
.\"O In order to be notified of incoming connections on a socket, you can use
.\"O .BR select (2)
.\"O or
.\"O .BR poll (2).
.\"O A readable event will be delivered when a new connection is attempted and you
.\"O may then call
.\"O .BR accept ()
.\"O to get a socket for that connection.
.\"O Alternatively, you can set the socket to deliver
.\"O .B SIGIO
.\"O when activity occurs on a socket; see
.\"O .BR socket (7)
.\"O for details.
ソケットへの接続到着を知るには、
.BR select (2)
または
.BR poll (2)
を用いればよい。
新しい接続要求が来るとソケットは読み込み可能になるので、
そうしたら
.BR accept ()
を呼んでその接続に対するソケットを取得すればよい。
あるいはソケットに設定を行い、何らかのアクションがあったときに
.B SIGIO
を配送 (deliver) させるようにすることもできる。詳細は
.BR socket (7)
を参照のこと。
.PP
.\"O For certain protocols which require an explicit confirmation,
.\"O such as
.\"O DECNet,
.\"O .BR accept ()
.\"O can be thought of as merely dequeuing the next connection request and not
.\"O implying confirmation.
.\"O Confirmation can be implied by
.\"O a normal read or write on the new file descriptor, and rejection can be
.\"O implied by closing the new socket.
.\"O Currently only
.\"O DECNet
.\"O has these semantics on Linux.
明示的な接続確認 (confirmation) を必要とするようなプロトコル
(DECNet など) では、
.BR accept ()
は単に次の接続要求をキューから取り出すだけであり、
接続確認は行わないことに注意せよ。接続確認は、
新しいファイル・ディスクリプタに対する
通常の読み取り/書き込みによってなされ、接続拒否 (rejection)
は新しいソケットをクローズすることによってなされる。
現在のところ、
Linux 上でこれらのセマンティクスを持つのは DECNet だけである。

.\"O If
.\"O .IR flags
.\"O is 0, then
.\"O .BR accept4 ()
.\"O is the same as
.\"O .BR accept ().
.\"O The following values can be bitwise ORed in
.\"O .IR flags
.\"O to obtain different behavior:
.I flags
が 0 の場合、
.BR accept4 ()
は
.BR accept ()
と同じである。
.I flags
に以下の値をビット毎の論理和 (OR) で指定することで、
異なる動作をさせることができる。
.TP 16
.B SOCK_NONBLOCK
.\"O Set the
.\"O .BR O_NONBLOCK
.\"O file status flag on the new open file description.
.\"O Using this flag saves extra calls to
.\"O .BR fcntl (2)
.\"O to achieve the same result.
新しく生成されるオープンファイル記述 (open file description) の
.B O_NONBLOCK
ファイルステータスフラグをセットする。
このフラグを使うことで、
.B O_NONBLOCK
をセットするために
.BR fcntl (2)
を追加で呼び出す必要がなくなる。
.TP
.B SOCK_CLOEXEC
.\"O Set the close-on-exec
.\"O .RB ( FD_CLOEXEC )
.\"O flag on the new file descriptor.
.\"O See the description of the
.\"O .B O_CLOEXEC
.\"O flag in
.\"O .BR open (2)
.\"O for reasons why this may be useful.
新しいファイルディスクリプタに対して
close-on-exec
.RB ( FD_CLOEXEC )
フラグをセットする。
このフラグが役に立つ理由については、
.BR open (2)
の
.B O_CLOEXEC
フラグの説明を参照のこと。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success,
.\"O these system calls return a nonnegative integer that is a descriptor
.\"O for the accepted socket.
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
成功した場合、これらのシステムコールは
受け付けたソケットのディスクリプタである非負の整数値を返す。
エラーが発生した場合は \-1 を返し、
.I errno
を適切に設定する。
.\"O .SS "Error Handling"
.SS エラー処理
.\"O Linux
.\"O .BR accept ()
.\"O (and
.\"O .BR accept4 ())
.\"O passes already-pending network errors on the new socket
.\"O as an error code from
.\"O .BR accept ().
Linux の
.BR accept ()
(と
.BR accept4 ())
は、新しいソケットにおける、発生済みのネットワークエラーを
.BR accept ()
からのエラーコードとして渡す。
.\"O This behavior differs from other BSD socket
.\"O implementations.
.\"O For reliable operation the application should detect
.\"O the network errors defined for the protocol after
.\"O .BR accept ()
.\"O and treat
.\"O them like
.\"O .B EAGAIN
.\"O by retrying.
.\"O In case of TCP/IP these are
この振舞いは BSD ソケットの実装とは異なる。
信頼性の高い動作を行うためには、
アプリケーションはプロトコルで定義されているネットワークエラーの検知を
.BR accept ()
のあとに行い、それらのエラーを
.B EAGAIN
と同じように扱い、再試行 (retry) を行うべきである。
.\"O .BR ENETDOWN ,
.\"O .BR EPROTO ,
.\"O .BR ENOPROTOOPT ,
.\"O .BR EHOSTDOWN ,
.\"O .BR ENONET ,
.\"O .BR EHOSTUNREACH ,
.\"O .BR EOPNOTSUPP ,
.\"O and
.\"O .BR ENETUNREACH .
TCP/IP では、以下のエラーが該当する:
.BR ENETDOWN ,
.BR EPROTO ,
.BR ENOPROTOOPT ,
.BR EHOSTDOWN ,
.BR ENONET ,
.BR EHOSTUNREACH ,
.BR EOPNOTSUPP ,
.B ENETUNREACH
.\"O .SH ERRORS
.SH エラー
.TP
.\"O .BR EAGAIN " or " EWOULDBLOCK
.BR EAGAIN " または " EWOULDBLOCK
.\" Actually EAGAIN on Linux
.\"O The socket is marked nonblocking and no connections are
.\"O present to be accepted.
.\"O POSIX.1-2001 allows either error to be returned for this case,
.\"O and does not require these constants to have the same value,
.\"O so a portable application should check for both possibilities.
ソケットが非停止になっていて、
かつ受付け対象の接続が存在しない。
POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めており、
これら 2 つの定数が同じ値を持つことも求めていない。
したがって、移植性が必要なアプリケーションでは、両方の可能性を
確認すべきである。
.TP
.B EBADF
.\"O The descriptor is invalid.
ディスクリプタが不正。
.TP
.B ECONNABORTED
.\"O A connection has been aborted.
接続が中止された。
.TP
.B EFAULT
.\"O The
.\"O .I addr
.\"O argument is not in a writable part of the user address space.
.I addr
引き数がユーザアドレス空間の書き込み可能領域にない。
.TP
.B EINTR
.\"O The system call was interrupted by a signal that was caught
.\"O before a valid connection arrived; see
.\"O .BR signal (7).
有効な接続が到着する前に捕捉されたシグナルによって
システムコールが中断された。
.BR signal (7)
参照。
.TP
.B EINVAL
.\"O Socket is not listening for connections, or
.\"O .I addrlen
.\"O is invalid (e.g., is negative).
ソケットが接続待ち状態ではない。もしくは、
.I addrlen
が不正である (例えば、負の場合など)。
.TP
.B EINVAL
.\"O .RB ( accept4 ())
.\"O invalid value in
.\"O .IR flags .
.RB ( accept4 ())
.I flags
に不正な値が指定されている。
.TP
.B EMFILE
.\"O The per-process limit of open file descriptors has been reached.
1プロセスがオープンできるファイル・ディスクリプタ数の上限に達した。
.TP
.B ENFILE
.\"O The system limit on the total number of open files has been reached.
オープンされたファイルの総数がシステム全体の上限に達した。
.TP
.BR ENOBUFS ", " ENOMEM
.\"O Not enough free memory.
.\"O This often means that the memory allocation is limited by the socket buffer
.\"O limits, not by the system memory.
メモリが足りない。
多くの場合は、システムメモリが足りないわけではなく、
ソケットバッファの大きさによるメモリ割り当ての制限である。
.TP
.B ENOTSOCK
.\"O The descriptor references a file, not a socket.
ディスクリプタはソケットではなくファイルを参照している。
.TP
.B EOPNOTSUPP
.\"O The referenced socket is not of type
.\"O .BR SOCK_STREAM .
参照しているソケットの型が
.B SOCK_STREAM
でない。
.TP
.B EPROTO
.\"O Protocol error.
プロトコル・エラー。
.PP
.\"O In addition, Linux
.\"O .BR accept ()
.\"O may fail if:
上記に加えて、Linux の
.BR accept ()
は以下のエラーで失敗する:
.TP
.B EPERM
.\"O Firewall rules forbid connection.
ファイアウォールのルールにより接続が禁止された。
.PP
.\"O In addition, network errors for the new socket and as defined
.\"O for the protocol may be returned.
.\"O Various Linux kernels can
.\"O return other errors such as
この他に、新しいソケットに対するネットワークエラーが返されることもある。
これらはそれぞれのプロトコルで定義されている。
いろいろな Linux カーネルでは、
以下に示すようなエラーを返すこともある。
.BR ENOSR ,
.BR ESOCKTNOSUPPORT ,
.BR EPROTONOSUPPORT ,
.BR ETIMEDOUT .
.\"O The value
.\"O .B ERESTARTSYS
.\"O may be seen during a trace.
.B ERESTARTSYS
がトレースの最中に現れることもある。
.\"O .SH VERSIONS
.SH バージョン
.\"O The
.\"O .BR accept4 ()
.\"O system call is available starting with Linux 2.6.28;
.\"O support in glibc is available starting with version 2.10.
.BR accept4 ()
システムコールは Linux 2.6.28 以降で利用可能である。
glibc でのサポートはバージョン 2.10 以降で利用可能である。
.\"O .SH CONFORMING TO
.SH 準拠
.\"O .BR accept ():
.\"O POSIX.1-2001,
.\"O SVr4, 4.4BSD,
.\"O .RB ( accept ()
.\"O first appeared in 4.2BSD).
.\"O .\" The BSD man page documents five possible error returns
.\"O .\" (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
.\"O .\" POSIX.1-2001 documents errors
.\"O .\" EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
.\"O .\" ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
.\"O .\" In addition, SUSv2 documents EFAULT and ENOSR.
.BR accept ():
POSIX.1-2001,
SVr4, 4.4BSD,
.RB ( accept ()
は 4.2BSD で初めて実装された).
.\" BSD の man ページには、 5 つのエラーが返されうると書かれている
.\" (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT)。
.\" POSIX.1-2001 では、
.\" EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
.\" ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK
.\" がエラーとして記述されている。
.\" さらに、SUSv2 には EFAULT, ENOSR も記述されている。

.\"O .BR accept4 ()
.\"O is a nonstandard Linux extension.
.BR accept4 ()
は非標準の Linux による拡張である。
.LP
.\"O On Linux, the new socket returned by
.\"O .BR accept ()
.\"O does \fInot\fP inherit file status flags such as
.\"O .B O_NONBLOCK
.\"O and
.\"O .B O_ASYNC
.\"O from the listening socket.
.\"O This behavior differs from the canonical BSD sockets implementation.
.\"O .\" Some testing seems to show that Tru64 5.1 and HP-UX 11 also
.\"O .\" do not inherit file status flags -- MTK Jun 05
.\"O Portable programs should not rely on inheritance or noninheritance
.\"O of file status flags and always explicitly set all required flags on
.\"O the socket returned from
.\"O .BR accept ().
Linux では、
.BR accept ()
が返す新しいソケットは listen を行っているソケットの
ファイル状態フラグ
.RB ( O_NONBLOCK
や
.B O_ASYNC
など) を継承「しない」。
この動作は標準的な BSD ソケットの実装とは異なっている。
.\" いくつか実験したところでは Tru64 5.1 と HP-UX 11 も
.\" ファイル状態フラグを継承しないようである。 -- MTK Jun 05
移植性を考慮したプログラムではファイル状態フラグが継承されるかどうかは
前提にせず、常に
.BR accept ()
が返したソケットに対して全ての必要なフラグを明示的に設定するように
すべきである。

.\"O .SH NOTES
.SH 注意
.\"O POSIX.1-2001 does not require the inclusion of
.\"O .IR <sys/types.h> ,
.\"O and this header file is not required on Linux.
.\"O However, some historical (BSD) implementations required this header
.\"O file, and portable applications are probably wise to include it.
POSIX.1-2001 では
.I <sys/types.h>
のインクルードは必須とされておらず、
Linux ではこのヘッダファイルは必要ではない。
しかし、歴史的には、いくつかの実装 (BSD 系) でこのヘッダファイルが
必要であり、移植性が必要なアプリケーションではこのファイルを
インクルードするのが賢明であろう。

.\"O There may not always be a connection waiting after a
.\"O .B SIGIO
.\"O is delivered or
.\"O .BR select (2)
.\"O or
.\"O .BR poll (2)
.\"O return a readability event because the connection might have been
.\"O removed by an asynchronous network error or another thread before
.\"O .BR accept ()
.\"O is called.
.B SIGIO
が届けられた後や、
.BR select (2)
または
.BR poll (2)
が読み込み可能イベントを返した後に、
必ずしも待機中の接続があるとは限らない。
なぜならその接続は、
.BR accept ()
が呼ばれる前に、非同期的なネットワークエラーや
他のスレッドから呼ばれた (別の) accept によって
削除されているかもしれないからである。
.\"O If this happens then the call will block waiting for the next
.\"O connection to arrive.
.\"O To ensure that
.\"O .BR accept ()
.\"O never blocks, the passed socket
.\"O .I sockfd
.\"O needs to have the
.\"O .B O_NONBLOCK
.\"O flag set (see
.\"O .BR socket (7)).
この場合、その
.BR accept ()
呼び出しは停止 (block) し、次の接続の到着を待ちつづける。
.BR accept ()
に停止を行わせないようにするには、引き数に渡すソケット
.I sockfd
に
.B O_NONBLOCK
フラグをセットしておく必要がある
.RB ( socket (7)
を見よ)。
.\"O .SS The socklen_t type
.SS socklen_t 型
.\"O The third argument of
.\"O .BR accept ()
.\"O was originally declared as an \fIint *\fP (and is that under libc4 and libc5
.\"O and on many other systems like 4.x BSD, SunOS 4, SGI); a POSIX.1g draft
.\"O standard wanted to change it into a \fIsize_t *\fP, and that is what it is
.\"O for SunOS 5.
.BR accept ()
の第 3 引き数は、もともと \fIint *\fP と宣言されていた
(libc4 や libc5, 4.x BSD, SunOS 4, SGI など多くのシステムではそうなっている)。
POSIX.1g draft 標準は、
これを \fIsize_t *\fP に変更しようとし、SunOS 5 ではそう宣言されている。
.\"O Later POSIX drafts have \fIsocklen_t *\fP,
.\"O and so do the Single Unix Specification and glibc2.
後に POSIX drafts には \fIsocklen_t *\fP が含まれるようになり、
Single Unix Specification や glibc2 ではこのように宣言されるようになった。
.\"O Quoting Linus Torvalds:
Linus Torvald の発言を引用する:

.\" .I fails: only italicizes a single line
.\"O "_Any_ sane library _must_ have "socklen_t" be the same size
.\"O as int.
.\"O Anything else breaks any BSD socket layer stuff.
.\"O POSIX initially \fIdid\fP make it a size_t, and I (and hopefully others, but
.\"O obviously not too many) complained to them very loudly indeed.
.\"O Making it a size_t is completely broken, exactly because size_t very
.\"O seldom is the same size as "int" on 64-bit architectures, for example.
.\"O And it
.\"O \fIhas\fP to be the same size as "int" because that's what the BSD socket
.\"O interface is.
.\"O Anyway, the POSIX people eventually got a clue, and created "socklen_t".
.\"O They shouldn't have touched it in the first place, but once they did
.\"O they felt it had to have a named type for some unfathomable reason
.\"O (probably somebody didn't like losing face over having done the original
.\"O stupid thing, so they silently just renamed their blunder)."
「まともなライブラリを作りたければ、 "socklen_t"
のサイズは int と同じにしなきゃならない。
さもないと BSD ソケット層を破壊することになっちゃう。
POSIX は最初こいつを size_t にしたんで、
ぼくは彼らに文句をがなりたてた
(多分そういう人は他にもいたと思う。多くはなかったようだけど)。
こいつを size_t にするのは完全にいかれてる。
例えば 64 ビットアーキテクチャでは、
size_t が "int" と同じサイズだなんてことはほとんどないからね。
このサイズは "int" と 同じでなきゃ『ダメ』なんだ。
BSD ソケットインターフェースっていうのはそういうものなんだから。
まあともかく POSIX の人たちも、
"socklen_t" を作るという解決策をなんとかひねり出した。
そもそも最初から放っておけば良かったんだが、
いじっちゃった以上、
名前付きの型を持たせなきゃならない、と思ったみたいだね。
なんでかはわかんないけど
(きっと最初にやっちまった馬鹿な間違いで顔をつぶしたくなかったから、
こっそり名前を付け替えて自分たちの大失敗をごまかそうとしたんだろう)。」
.\"O .SH EXAMPLE
.SH 例
.\"O See
.\"O .BR bind (2).
.BR bind (2)
参照。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR bind (2),
.BR connect (2),
.BR listen (2),
.BR select (2),
.BR socket (2),
.BR socket (7)

'\" t
.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (c) 1992 Drew Eckhardt (drew@cs.colorado.edu), March 28, 1992
.\" Parts Copyright (c) 1995 Nicolai Langfeldt (janl@ifi.uio.no), 1/1/95
.\" and Copyright (c) 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified by Michael Haardt <michael@moria.de>
.\" Modified 1993-07-24 by Rik Faith <faith@cs.unc.edu>
.\" Modified 1995-05-18 by Todd Larason <jtl@molehill.org>
.\" Modified 1997-01-31 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 1995-01-09 by Richard Kettlewell <richard@greenend.org.uk>
.\" Modified 1998-05-13 by Michael Haardt <michael@cantor.informatik.rwth-aachen.de>
.\" Modified 1999-07-06 by aeb & Albert Cahalan
.\" Modified 2000-01-07 by aeb
.\" Modified 2004-06-23 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" 2007-06-08 mtk: Added example program
.\" 2007-07-05 mtk: Added details on underlying system call interfaces
.\"
.\" Japanese Version Copyright (c) 1998-1999 HANATAKA Shinya
.\" and Copyright (c) 2005-2008 Akihiro MOTOKI
.\"
.\" Translated 1998-06-21, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Modified 1999-04-16, HANATAKA Shinya
.\" Updated 2000-01-03, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2000-10-06, Kentaro Shirakata
.\" Updated 2001-04-09, Kentaro Shirakata
.\" Updated 2001-06-25, Kentaro Shirakata
.\" Updated 2005-02-28, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-09-06, Akihiro MOTOKI
.\" Updated 2005-11-19, Akihiro MOTOKI, catch up to LDP v2.14
.\" Updated 2006-07-21, Akihiro MOTOKI, LDP v2.36
.\" Updated 2007-06-13, Akihiro MOTOKI, LDP v2.55
.\" Updated 2008-09-19, Akihiro MOTOKI, LDP v3.08
.\"
.\"WORD:	status			状態
.\"WORD:	directory		ディレクトリ
.\"WORD:	open			オープン
.\"WORD:	implement		実装
.\"WORD:	owner			所有者
.\"WORD:	group			グループ
.\"WORD:	user			ユーザー
.\"WORD:	other			他人
.\"WORD:	hard link count		ハード・リンク数
.\"WORD:	symbolic link		シンボリック・リンク
.\"WORD:	socket			ソケット
.\"WORD:	device			デバイス
.\"WORD:	sticky bit		スティッキー・ビット
.\"WORD:	mandatory locking	強制ロック
.\"
.TH STAT 2 2010-12-03 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O stat, fstat, lstat \- get file status
stat, fstat, lstat \- ファイルの状態を取得する
.\"O .SH SYNOPSIS
.SH 書式
.B #include <sys/types.h>
.br
.B #include <sys/stat.h>
.br
.B #include <unistd.h>
.sp
.BI "int stat(const char *" path ", struct stat *" buf );
.br
.BI "int fstat(int " fd ", struct stat *" buf );
.br
.BI "int lstat(const char *" path ", struct stat *" buf );
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.BR lstat ():
_BSD_SOURCE || _XOPEN_SOURCE\ >=\ 500
.\"O .SH DESCRIPTION
.SH 説明
.PP
.\"O These functions return information about a file.
.\"O No permissions are required on the file itself, but \(em in the case of
.\"O .BR stat ()
.\"O and
.\"O .BR lstat ()
.\"O \(em
.\"O execute (search) permission is required on all of the directories in
.\"O .I path
.\"O that lead to the file.
これらの関数はファイルについての情報を返す。
ファイルそのものに対するアクセス許可は必要としないが、
\(em
.BR stat ()
と
.BR lstat ()
の場合には
\(em
そのファイルへ至る
.I path
を構成する全てのディレクトリに対する実行 (検索) 許可が必要である。
.PP
.\"O .BR stat ()
.\"O stats the file pointed to by
.\"O .I path
.\"O and fills in
.\"O .IR buf .
.BR stat ()
は
.I path
で指定されたファイルの状態を取得して
.I buf
へ格納する。

.\"O .BR lstat ()
.\"O is identical to
.\"O .BR stat (),
.\"O except that if
.\"O .I path
.\"O is a symbolic link, then the link itself is stat-ed,
.\"O not the file that it refers to.
.BR lstat ()
は
.BR stat ()
と同じであるが、
.I path
がシンボリックリンクの場合、リンクが参照しているファイルではなく、
リンク自身の状態を取得する点が異なる。

.\"O .BR fstat ()
.\"O is identical to
.\"O .BR stat (),
.\"O except that the file to be stat-ed is specified by the file descriptor
.\"O .IR fd .
.BR fstat ()
は
.BR stat ()
と同じだが、
状態を取得するファイルをファイル・ディスクリプタ
.I fd
で指定する。
.PP
.\"O All of these system calls return a
.\"O .I stat
.\"O structure, which contains the following fields:
これらのシステムコールはいずれも、結果を
.I stat
構造体に入れて返す。
.I stat
構造体には以下のフィールドが含まれている:
.PP
.in +4n
.nf
struct stat {
.\"O     dev_t     st_dev;     /* ID of device containing file */
.\"O     ino_t     st_ino;     /* inode number */
.\"O     mode_t    st_mode;    /* protection */
.\"O     nlink_t   st_nlink;   /* number of hard links */
.\"O     uid_t     st_uid;     /* user ID of owner */
.\"O     gid_t     st_gid;     /* group ID of owner */
.\"O     dev_t     st_rdev;    /* device ID (if special file) */
.\"O     off_t     st_size;    /* total size, in bytes */
.\"O     blksize_t st_blksize; /* blocksize for file system I/O */
.\"O     blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
.\"O     time_t    st_atime;   /* time of last access */
.\"O     time_t    st_mtime;   /* time of last modification */
.\"O     time_t    st_ctime;   /* time of last status change */
    dev_t     st_dev;     /* ファイルがあるデバイスの ID */
    ino_t     st_ino;     /* inode 番号 */
    mode_t    st_mode;    /* アクセス保護 */
    nlink_t   st_nlink;   /* ハードリンクの数 */
    uid_t     st_uid;     /* 所有者のユーザ ID */
    gid_t     st_gid;     /* 所有者のグループ ID */
    dev_t     st_rdev;    /* デバイス ID (特殊ファイルの場合) */
    off_t     st_size;    /* 全体のサイズ (バイト単位) */
    blksize_t st_blksize; /* ファイルシステム I/O での
                             ブロックサイズ */
    blkcnt_t  st_blocks;  /* 割り当てられた 512B のブロック数 */
    time_t    st_atime;   /* 最終アクセス時刻 */
    time_t    st_mtime;   /* 最終修正時刻 */
    time_t    st_ctime;   /* 最終状態変更時刻 */
};
.fi
.in
.PP
.\"O The
.\"O .I st_dev
.\"O field describes the device on which this file resides.
.\"O (The
.\"O .BR major (3)
.\"O and
.\"O .BR minor (3)
.\"O macros may be useful to decompose the device ID in this field.)
.I st_dev
フィールドは、このファイルが存在するデバイスを示す
(マクロ
.BR major (3),
.BR minor (3)
は、このフィールドのデバイス ID を分解するのに役立つだろう)。

.\"O The
.\"O .I st_rdev
.\"O field describes the device that this file (inode) represents.
.I st_rdev
フィールドは、このファイル (inode) が表すデバイスを示す。

.\"O The
.\"O .I st_size
.\"O field gives the size of the file (if it is a regular
.\"O file or a symbolic link) in bytes.
.\"O The size of a symlink is the length of the pathname
.\"O it contains, without a trailing null byte.
.I st_size
フィールドは、(通常のファイルかシンボリックリンクの場合に)
ファイルの大きさをバイト単位で示す。
シンボリックリンクの大きさは、シンボリックリンクに含まれている
パス名の長さ (最後の NULL バイトは含まない) である。

.\"O The
.\"O .I st_blocks
.\"O field indicates the number of blocks allocated to the file, 512-byte units.
.\"O (This may be smaller than
.\"O .IR st_size /512
.\"O when the file has holes.)
.I st_blocks
フィールドは、ファイルの大きさを 512 バイトのブロックサイズ単位で示す
フィールドは、ファイルに割り当てされたブロック数を 512 バイト単位で示す。
(ファイルに穴があるような場合、この値は
.IR st_size /512
より小さくなることもある)。

.\"O The
.\"O .I st_blksize
.\"O field gives the "preferred" blocksize for efficient file system I/O.
.\"O (Writing to a file in smaller chunks may cause
.\"O an inefficient read-modify-rewrite.)
.I st_blksize
フィールドは、効率的にファイル・システム I/O ができる「好ましい」
ブロックサイズを示す (もっと小さい単位でファイルに書き込みを行うと、
読み出し--修正--再書き込みといった非効率な動作になってしまうかもしれない)。
.PP
.\"O Not all of the Linux file systems implement all of the time fields.
.\"O Some file system types allow mounting in such a way that file
.\"O and/or directory accesses do not cause an update of the
.\"O .I st_atime
.\"O field.
.\"O (See
.\"O .IR noatime ,
.\"O .IR nodiratime ,
.\"O and
.\"O .I relatime
.\"O in
.\"O .BR mount (8),
.\"O and related information in
.\"O .BR mount (2).)
全ての Linux のファイル・システムが全ての時間フィールドを
実装しているわけではない。
ファイルやディレクトリのアクセスが
.I st_atime
フィールドを更新しないようなかたちでマウントできるファイルシステムもある。
.RB ( mount (8)
の
.IR noatime ,
.IR nodiratime ,
.I relatime
や
.BR mount (2)
の関連する情報を参照)。
.\"O In addition,
.\"O .I st_atime
.\"O is not updated if a file is opened with the
.\"O .BR O_NOATIME ;
.\"O see
.\"O .BR open (2).
また、ファイルが
.B O_NOATIME
付きでオープンされている場合には
.I st_atime
は更新されない。
.BR open (2)
参照。

.\"O The field
.\"O .I st_atime
.\"O is changed by file accesses, for example, by
.\"O .BR execve (2),
.\"O .BR mknod (2),
.\"O .BR pipe (2),
.\"O .BR utime (2)
.\"O and
.\"O .BR read (2)
.\"O (of more than zero bytes).
.\"O Other routines, like
.\"O .BR mmap (2),
.\"O may or may not update
.\"O .IR st_atime .
.I st_atime
フィールドはファイルアクセスがあった場合に変更される
(例えば、
.BR execve (2),
.BR mknod (2),
.BR pipe (2),
.BR utime (2)
を使用した場合や
.BR read (2)
で 1 バイト以上読み込んだ場合など)。
.BR mmap (2)
などの他のルーチンでは、
.I st_atime
は更新されることもあれば、そうでない場合もある。

.\"O The field
.\"O .I st_mtime
.\"O is changed by file modifications, for example, by
.\"O .BR mknod (2),
.\"O .BR truncate (2),
.\"O .BR utime (2)
.\"O and
.\"O .BR write (2)
.\"O (of more than zero bytes).
.I st_mtime
フィールドは、ファイルが修正された場合に変更される
(例えば、
.BR mknod (2),
.BR truncate (2),
.BR utime (2)
を使用した場合や
.BR write (2)
で 1 バイト以上書き込みをした場合など)。
.\"O Moreover,
.\"O .I st_mtime
.\"O of a directory is changed by the creation or deletion of files
.\"O in that directory.
さらに、ディレクトリの
.I st_mtime
は、そのディレクトリで
ファイルが作成されたり削除されたりすると変更される。
.\"O The
.\"O .I st_mtime
.\"O field is
.\"O .I not
.\"O changed for changes in owner, group, hard link count, or mode.
.I st_mtime
フィールドは
所有者やグループやハード・リンク数やモードの変更では変更
.I されない。

.\"O The field
.\"O .I st_ctime
.\"O is changed by writing or by setting inode information
.\"O (i.e., owner, group, link count, mode, etc.).
.I st_ctime
フィールドは書き込みや inode 情報
(所有者、グループ、リンク数、モードなど) の
設定によって変更される。
.PP
.\"O The following POSIX macros are defined to check the file type using the
.\"O .I st_mode
.\"O field:
以下の POSIX マクロは、
.I st_mode
フィールド
で使用されるファイル種別のチェックのために定義されている :
.RS 4
.TP 1.2i
.BR S_ISREG (m)
.\"O is it a regular file?
通常のファイルか?
.TP
.BR S_ISDIR (m)
.\"O directory?
ディレクトリか?
.TP
.BR S_ISCHR (m)
.\"O character device?
キャラクター・デバイスか?
.TP
.BR S_ISBLK (m)
.\"O block device?
ブロック・デバイスか?
.TP
.BR S_ISFIFO (m)
.\"O FIFO (named pipe)?
FIFO (名前付きパイプ) か?
.TP
.BR S_ISLNK (m)
.\"O symbolic link? (Not in POSIX.1-1996.)
シンボリック・リンクか? (POSIX.1-1996 にはない)
.TP
.BR S_ISSOCK (m)
.\"O socket? (Not in POSIX.1-1996.)
ソケットか? (POSIX.1-1996 にはない)
.RE
.PP
.\"O The following flags are defined for the
.\"O .I st_mode
.\"O field:
以下のフラグが
.I st_mode
フィールド用に定義されている:
.in +4n
.TS
lB l l.
.\"O S_IFMT	0170000	bit mask for the file type bit fields
.\"O S_IFSOCK	0140000	socket
.\"O S_IFLNK	0120000	symbolic link
.\"O S_IFREG	0100000	regular file
.\"O S_IFBLK	0060000	block device
.\"O S_IFDIR	0040000	directory
.\"O S_IFCHR	0020000	character device
.\"O S_IFIFO	0010000	FIFO
S_IFMT	0170000	ファイル種別を示すビット領域を表すビットマスク
S_IFSOCK	0140000	ソケット
S_IFLNK	0120000	シンボリック・リンク
S_IFREG	0100000	通常のファイル
S_IFBLK	0060000	ブロック・デバイス
S_IFDIR	0040000	ディレクトリ
S_IFCHR	0020000	キャラクター・デバイス
S_IFIFO	0010000	FIFO
.\"O S_ISUID	0004000	set-user-ID bit
.\"O S_ISGID	0002000	set-group-ID bit (see below)
.\"O S_ISVTX	0001000	sticky bit (see below)
S_ISUID	0004000	set-user-ID bit
S_ISGID	0002000	set-group-ID bit (下記参照)
S_ISVTX	0001000	スティッキー・ビット (下記参照)
.\"O S_IRWXU	00700	mask for file owner permissions
.\"O S_IRUSR	00400	owner has read permission
.\"O S_IWUSR	00200	owner has write permission
.\"O S_IXUSR	00100	owner has execute permission
S_IRWXU	00700	ファイル所有者のアクセス許可用のビットマスク
S_IRUSR	00400	所有者の読み込み許可
S_IWUSR	00200	所有者の書き込み許可
S_IXUSR	00100	所有者の実行許可
.\"O S_IRWXG	00070	mask for group permissions
.\"O S_IRGRP	00040	group has read permission
.\"O S_IWGRP	00020	group has write permission
.\"O S_IXGRP	00010	group has execute permission
S_IRWXG	00070	グループのアクセス許可用のビットマスク
S_IRGRP	00040	グループの読み込み許可
S_IWGRP	00020	グループの書き込み許可
S_IXGRP	00010	グループの実行許可
.\"O S_IRWXO	00007	mask for permissions for others (not in group)
.\"O S_IROTH	00004	others have read permission
.\"O S_IWOTH	00002	others have write permission
.\"O S_IXOTH	00001	others have execute permission
S_IRWXO	00007	他人 (others) のアクセス許可用のビットマスク
S_IROTH	00004	他人の読み込み許可
S_IWOTH	00002	他人の書き込み許可
S_IXOTH	00001	他人の実行許可
.TE
.in
.P
.\"O The set-group-ID bit
.\"O .RB ( S_ISGID )
.\"O has several special uses.
.\"O For a directory it indicates that BSD semantics is to be used
.\"O for that directory: files created there inherit their group ID from
.\"O the directory, not from the effective group ID of the creating process,
.\"O and directories created there will also get the
.\"O .B S_ISGID
.\"O bit set.
.\"O For a file that does not have the group execution bit
.\"O .RB ( S_IXGRP )
.\"O set,
.\"O the set-group-ID bit indicates mandatory file/record locking.
set-group-ID bit
.RB ( S_ISGID )
にはいくつかの特殊な使用法がある:
ディレクトリに設定した場合には、そのディレクトリが BSD 方式で使用される
ことを示す。つまり、そのディレクトリに作成されたファイルのグループID は
作成したプロセスの実効 (effective) グループID ではなく、ディレクトリの
グループID を継承する。また、そのディレクトリに作成されたディレクトリにも
.B S_ISGID
ビットが設定される。グループ実行ビット
.RB ( S_IXGRP )
が設定されていないファイルに設定された場合は、
set-group-ID ビットはファイル/レコードの
強制的な (mandatory) ロックを表す。
.P
.\"O The sticky bit (S_ISVTX) on a directory means that a file
.\"O in that directory can be renamed or deleted only by the owner
.\"O of the file, by the owner of the directory, and by a privileged
.\"O process.
ディレクトリにスティッキービット (S_ISVTX) が設定された場合は、
そのディレクトリのファイルの名前を変更したり、削除したりできるのは、
そのファイルの所有者か、そのディレクトリの所有者か、特権プロセス
だけとなる。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success, zero is returned.
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
成功した場合は 0 を返す。エラーの場合は \-1 を返し、
.I errno
に適切な値が設定される。
.\"O .SH ERRORS
.SH エラー
.TP
.B EACCES
.\"O Search permission is denied for one of the directories
.\"O in the path prefix of
.\"O .IR path .
.\"O (See also
.\"O .BR path_resolution (7).)
.I path
が所属するディレクトリとその上位のディレクトリのいずれかに
対する検索許可がなかった
.RB ( path_resolution (7)
も参照のこと)。
.TP
.B EBADF
.\"O .I fd
.\"O is bad.
.I fd
が不正である。
.TP
.B EFAULT
.\"O Bad address.
アドレスが間違っている。
.TP
.B ELOOP
.\"O Too many symbolic links encountered while traversing the path.
パスを辿る際に解決すべきシンボリック・リンクが多過ぎた。
.TP
.B ENAMETOOLONG
.\"O .I path
.\"O is too long.
.I path
が長過ぎる。
.TP
.B ENOENT
.\"O A component of
.\"O .I path
.\"O does not exist, or
.\"O .I path
.\"O is an empty string.
.I path
の構成要素が存在しないか、
.I path
が空文字列である。
.TP
.B ENOMEM
.\"O Out of memory (i.e., kernel memory).
カーネルのメモリが足りない。
.TP
.B ENOTDIR
.\"O A component of the path prefix of
.\"O .I path
.\"O is not a directory.
.I path
の前半部分 (prefix) の構成要素がディレクトリではない。
.TP
.B EOVERFLOW
.\"O .RB ( stat ())
.\"O .I path
.\"O refers to a file whose size cannot be represented in the type
.\"O .IR off_t .
.\"O This can occur when an application compiled on a 32-bit platform without
.\"O .I -D_FILE_OFFSET_BITS=64
.\"O calls
.\"O .BR stat ()
.\"O on a file whose size exceeds
.\"O .I (1<<31)-1
.\"O bits.
.RB ( stat ())
.I path
が、ファイルサイズを
.I off_t
型で表現できないファイルを参照している。
このエラーが起こるのは、32 ビットプラットフォーム上で
.I -D_FILE_OFFSET_BITS=64
を指定せずにコンパイルされたアプリケーションが、ファイルサイズが
.I (1<31)-1
ビットを超えるファイルに対して
.BR stat ()
を呼び出した場合である。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O These system calls conform to SVr4, 4.3BSD, POSIX.1-2001.
これらのシステムコールは SVr4, 4.3BSD, POSIX.1-2001 に準拠している。
.\"O .\" SVr4 documents additional
.\"O .\" .BR fstat ()
.\"O .\" error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
.\"O .\" documents additional
.\"O .\" .BR stat ()
.\"O .\" and
.\"O .\" .BR lstat ()
.\"O .\" error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
.BR stat ()
と
.BR fstat ()
コールは SVr4, SVID, POSIX, X/OPEN, 4.3BSD に準拠している。
.BR lstat ()
コールは 4.3BSD と SVr4 に準拠している。
.\" SVr4 には他に
.\" .BR fstat ()
.\" のエラーとして EINTR, ENOLINK, EOVERFLOW が記載されている。
.\" SVr4 には他に
.\" .BR stat ()
.\" と
.\" .BR lstat ()
.\" のエラーとして EINTR, EMULTIHOP, ENOLINK, EOVERFLOW が記載されている。

.\"O Use of the
.\"O .I st_blocks
.\"O and
.\"O .I st_blksize
.\"O fields may be less portable.
.\"O (They were introduced in BSD.
.\"O The interpretation differs between systems,
.\"O and possibly on a single system when NFS mounts are involved.)
.I st_blocks
と
.I st_blksize
フィールドの使用はあまり移植性がない。
(これらのフィールドは BSD によって導入された。
システムごとに解釈が異なっており、
NFS マウントの場合には同じシステムでも異なる可能性がある)
.LP
.\"O POSIX does not describe the
.\"O .BR S_IFMT ,
.\"O .BR S_IFSOCK ,
.\"O .BR S_IFLNK ,
.\"O .BR S_IFREG ,
.\"O .BR S_IFBLK ,
.\"O .BR S_IFDIR ,
.\"O .BR S_IFCHR ,
.\"O .BR S_IFIFO ,
.\"O .B S_ISVTX
.\"O bits, but instead demands the use of
.\"O the macros
.\"O .BR S_ISDIR (),
.\"O etc.
.\"O The
.\"O .BR S_ISLNK ()
.\"O and
.\"O .BR S_ISSOCK ()
.\"O macros are not in
.\"O POSIX.1-1996, but both are present in POSIX.1-2001;
.\"O the former is from SVID 4, the latter from SUSv2.
POSIX には
.BR S_IFMT ,
.BR S_IFSOCK ,
.BR S_IFLNK ,
.BR S_IFREG ,
.BR S_IFBLK ,
.BR S_IFDIR ,
.BR S_IFCHR ,
.BR S_IFIFO ,
.B S_ISVTX
ビットについての記述はない。かわりに
.BR S_ISDIR ()
のようなマクロを使用するように要求している。
マクロ
.BR S_ISLNK ()
と
.BR S_ISSOCK ()
は POSIX.1-1996 にはないが、
POSIX.1-2001 には両方とも存在する。
前者は SVID 4 に、後者は SUSv2 に由来している。
.LP
.\"O Unix V7 (and later systems) had S_IREAD, S_IWRITE, S_IEXEC, where POSIX
.\"O prescribes the synonyms S_IRUSR, S_IWUSR, S_IXUSR.
.\"O Unix V7 (and later systems) had
.\"O .BR S_IREAD ,
.\"O .BR S_IWRITE ,
.\"O .BR S_IEXEC ,
.\"O where POSIX
.\"O prescribes the synonyms
.\"O .BR S_IRUSR ,
.\"O .BR S_IWUSR ,
.\"O .BR S_IXUSR .
Unix V7 (とその後のシステム) は
.BR S_IREAD ,
.BR S_IWRITE ,
.B S_IEXEC
を持っており、
POSIX はその同義語として
.BR S_IRUSR ,
.BR S_IWUSR ,
.B S_IXUSR
を規定している。
.\"O .SS "Other Systems"
.SS 他のシステム
.\"O Values that have been (or are) in use on various systems:
各種システムで使用されていた(いる)値:
.TS
l l l l l.
.\"O hex	name	ls	octal	description
16進	名前	ls	8進数	説明
.\"O f000	S_IFMT		170000	mask for file type
.\"O 0000			000000	SCO out-of-service inode, BSD unknown
.\"O 				type; SVID-v2 and XPG2 have both
.\"O 				0 and 0100000 for ordinary file
f000	S_IFMT		170000	ファイル種別フィールドのビットマスク
0000			000000	SCO では 使用不能 inode;
				BSD では未知のファイル種別;
				SVID-v2 と XPG2 では 0 と 0100000 の
				両方が普通のファイル
.\"O 1000	S_IFIFO	p|	010000	FIFO (named pipe)
.\"O 2000	S_IFCHR	c	020000	character special (V7)
.\"O 3000	S_IFMPC		030000	multiplexed character special (V7)
.\"O 4000	S_IFDIR	d/	040000	directory (V7)
.\"O 5000	S_IFNAM		050000	XENIX named special file
.\"O 				with two subtypes, distinguished by
.\"O 				\fIst_rdev\fP values 1, 2
.\"O 0001	S_INSEM	s	000001	XENIX semaphore subtype of IFNAM
.\"O 0002	S_INSHD	m	000002	XENIX shared data subtype of IFNAM
1000	S_IFIFO	p|	010000	FIFO (名前付きパイプ)
2000	S_IFCHR	c	020000	キャラクタ特殊ファイル (V7)
3000	S_IFMPC		030000	多重化されたキャラクタ特殊ファイル (V7)
4000	S_IFDIR	d/	040000	ディレクトリ (V7)
5000	S_IFNAM		050000	XENIX 二つの副型を持つ名前付きの
				特殊ファイル
				副型は \fIst_rdev\fP の値 1,2 で区別される:
0001	S_INSEM	s	000001	XENIX IFNAMのセマフォー副型
0002	S_INSHD	m	000002	XENIX IFNAMの共有データ副型
.\"O 6000	S_IFBLK	b	060000	block special (V7)
.\"O 7000	S_IFMPB		070000	multiplexed block special (V7)
.\"O 8000	S_IFREG	-	100000	regular (V7)
.\"O 9000	S_IFCMP		110000	VxFS compressed
.\"O 9000	S_IFNWK	n	110000	network special (HP-UX)
.\"O a000	S_IFLNK	l@	120000	symbolic link (BSD)
6000	S_IFBLK	b	060000	ブロック特殊ファイル (V7)
7000	S_IFMPB		070000	多重化されたブロック特殊ファイル (V7)
8000	S_IFREG	-	100000	通常ファイル (V7)
9000	S_IFCMP		110000	VxFS 圧縮ファイル
9000	S_IFNWK	n	110000	ネットワーク特殊ファイル (HP-UX)
a000	S_IFLNK	l@	120000	シンボリック・リンク (BSD)
.\"O b000	S_IFSHAD		130000	Solaris shadow inode for ACL
.\"O 				(not seen by userspace)
.\"O c000	S_IFSOCK	s=	140000	socket (BSD; also "S_IFSOC" on VxFS)
.\"O d000	S_IFDOOR	D>	150000	Solaris door
.\"O e000	S_IFWHT	w%	160000	BSD whiteout (not used for inode)
b000	S_IFSHAD		130000	Solaris ACL のための隠された inode
				(ユーザ空間からは見えない)
c000	S_IFSOCK	s=	140000	ソケット (BSD; VxFS の "S_IFSOC")
d000	S_IFDOOR	D>	150000	Solaris ドア・ファイル
e000	S_IFWHT	w%	160000	BSD 空白ファイル (inode を使用しない)
.\"O 0200	S_ISVTX		001000	sticky bit: save swapped text even
.\"O 				after use (V7)
.\"O 				reserved (SVID-v2)
.\"O 				On nondirectories: don't cache this
.\"O 				file (SunOS)
.\"O 				On directories: restricted deletion
.\"O 				flag (SVID-v4.2)
.\"O 0400	S_ISGID		002000	set-group-ID on execution (V7)
.\"O 				for directories: use BSD semantics for
.\"O 				propagation of GID
.\"O 0400	S_ENFMT		002000	System V file locking enforcement (shared
.\"O 				with S_ISGID)
.\"O 0800	S_ISUID		004000	set-user-ID on execution (V7)
.\"O 0800	S_CDF		004000	directory is a context dependent
.\"O 				file (HP-UX)
0200	S_ISVTX		001000	`スティッキー・ビット':使用後も
				スワップに残す (V7)
				予約 (SVID-v2)
				ディレクトリ以外: ファイルをキャッシュ
				しない (SunOS)
				ディレクトリ: 削除制限フラグ (SVID-v4.2)
0400	S_ISGID		002000	実行時の set-group-ID (V7)
				ディレクトリに対しては GID の伝達に
				BSD 方式を使用する
0400	S_ENFMT		002000	System V ファイル・ロックを強制する
				(S_ISGID と共有)
0800	S_ISUID		004000	実行時の set-user-ID (V7)
0800	S_CDF		004000	ディレクトリが状況依存ファイル (HP-UX)
.TE

.\"O A sticky command appeared in Version 32V AT&T UNIX.
スティッキー コマンドは Version 32V AT&T UNIX で登場した。
.\"O .SH NOTES
.SH 注意
.\"O Since kernel 2.5.48, the
.\"O .I stat
.\"O structure supports nanosecond resolution for the three
.\"O file timestamp fields.
.\"O Glibc exposes the nanosecond component of each field using names either
.\"O of the form
.\"O .IR st_atim.tv_nsec ,
.\"O if the
.\"O .B _BSD_SOURCE
.\"O or
.\"O .B _SVID_SOURCE
.\"O feature test macro is defined,
.\"O or of the form
.\"O .IR st_atimensec ,
.\"O if neither of these macros is defined.
.\"O On file systems that do not support subsecond timestamps,
.\"O these nanosecond fields are returned with the value 0.
カーネル 2.5.48 以降では、
.I stat
構造体は 3つのファイルのタイムスタンプ関連のフィールドで
ナノ秒単位の精度に対応している。
glibc では、各フィールドのナノ秒の情報を
.I st_atim.tv_nsec
や
.I st_atimensec
といった形で参照できる。
機能検査マクロ
.B _BSD_SOURCE
か
.B _SVID_SOURCE
が定義されている場合には
.I st_atim.tv_nsec
の形式で、それ以外の場合には
.I st_atimensec
の形式となる。
秒より細かいタイムスタンプをサポートしていないファイルシステムでは、
これらのナノ秒のフィールドは 0 に設定される。
.\" As at kernel 2.6.25, XFS and JFS support nanosecond timestamps,
.\" but ext2, ext3, and Reiserfs do not.
.\" FIXME . SUSv4 specifies nanosecond timestamps.

.\"O On Linux,
.\"O .BR lstat ()
.\"O will generally not trigger automounter action, whereas
.\"O .BR stat ()
.\"O will.
Linux では、
.BR lstat ()
は一般には自動マウント動作 (automounter action) のきっかけとならないが、
.BR stat ()
はきっかけとなる。

.\"O For most files under the
.\"O .I /proc
.\"O directory,
.\"O .BR stat ()
.\"O does not return the file size in the
.\"O .I st_size
.\"O field; instead the field is returned with the value 0.
.I /proc
ディレクトリ以下にあるファイルのほとんどでは、
.BR stat ()
を呼び出した際に、
.I st_size
フィールドにファイルサイズが返されない。
代わりに
.I st_size
フィールドには 0 が返される。
.\"O .SS Underlying kernel interface
.SS 背後のカーネル・インタフェース
.\"O Over time, increases in the size of the
.\"O .I stat
.\"O structure have led to three successive versions of
.\"O .BR stat ():
時間の経過とともに、
.I stat
構造体のサイズが大きくなり、この影響で
.BR stat ()
には 3つのバージョンが存在する:
.\"O .IR sys_stat ()
.\"O (slot
.\"O .IR __NR_oldstat ),
.\"O .IR sys_newstat ()
.\"O (slot
.\"O .IR __NR_stat ),
.\"O and
.\"O .I sys_stat64()
.\"O (new in kernel 2.4; slot
.\"O .IR __NR_stat64 ).
.IR sys_stat ()
(スロットは
.IR __NR_oldstat )、
.IR sys_newstat ()
(スロットは
.IR __NR_stat )、
.IR sys_stat64 ()
(カーネル 2.4 で導入; スロットは
.IR __NR_stat64 ).
.\"O The glibc
.\"O .BR stat ()
.\"O wrapper function hides these details from applications,
.\"O invoking the most recent version of the system call provided by the kernel,
.\"O and repacking the returned information if required for old binaries.
glibc の
.BR stat ()
ラッパー関数はこれらの詳細をアプリケーションから隠蔽してくれる。
具体的には、カーネルが提供しているシステムコールのうち最新のバージョンを
起動し、古いバイナリの場合には必要に応じて返された情報を再構成 (repack) する。
.\"O Similar remarks apply for
.\"O .BR fstat ()
.\"O and
.\"O .BR lstat ().
.BR fstat ()
と
.BR lstat ()
についても同様である。
.\"
.\" A note from Andries Brouwer, July 2007
.\"
.\" > Is the story not rather more complicated for some calls like
.\" > stat(2)?
.\"
.\" Yes and no, mostly no. See /usr/include/sys/stat.h .
.\"
.\" The idea is here not so much that syscalls change, but that
.\" the definitions of struct stat and of the types dev_t and mode_t change.
.\" This means that libc (even if it does not call the kernel
.\" but only calls some internal function) must know what the
.\" format of dev_t or of struct stat is.
.\" The communication between the application and libc goes via
.\" the include file <sys/stat.h> that defines a _STAT_VER and
.\" _MKNOD_VER describing the layout of the data that user space
.\" uses. Each (almost each) occurrence of stat() is replaced by
.\" an occurrence of xstat() where the first parameter of xstat()
.\" is this version number _STAT_VER.
.\"
.\" Now, also the definitions used by the kernel change.
.\" But glibc copes with this in the standard way, and the
.\" struct stat as returned by the kernel is repacked into
.\" the struct stat as expected by the application.
.\" Thus, _STAT_VER and this setup cater for the application-libc
.\" interface, rather than the libc-kernel interface.
.\"
.\" (Note that the details depend on gcc being used as c compiler.)
.\"O .SH EXAMPLE
.SH 例
.\"O The following program calls
.\"O .BR stat ()
.\"O and displays selected fields in the returned
.\"O .I stat
.\"O structure.
以下のプログラムは
.BR stat ()
を呼び出し、返ってきた
.I stat
構造体のフィールドのいくつかを表示する。
.nf

#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[])
{
    struct stat sb;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <pathname>\\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if (stat(argv[1], &sb) == \-1) {
        perror("stat");
        exit(EXIT_FAILURE);
    }

    printf("File type:                ");

    switch (sb.st_mode & S_IFMT) {
    case S_IFBLK:  printf("block device\\n");            break;
    case S_IFCHR:  printf("character device\\n");        break;
    case S_IFDIR:  printf("directory\\n");               break;
    case S_IFIFO:  printf("FIFO/pipe\\n");               break;
    case S_IFLNK:  printf("symlink\\n");                 break;
    case S_IFREG:  printf("regular file\\n");            break;
    case S_IFSOCK: printf("socket\\n");                  break;
    default:       printf("unknown?\\n");                break;
    }

    printf("I\-node number:            %ld\\n", (long) sb.st_ino);

    printf("Mode:                     %lo (octal)\\n",
            (unsigned long) sb.st_mode);

    printf("Link count:               %ld\\n", (long) sb.st_nlink);
    printf("Ownership:                UID=%ld   GID=%ld\\n",
            (long) sb.st_uid, (long) sb.st_gid);

    printf("Preferred I/O block size: %ld bytes\\n",
            (long) sb.st_blksize);
    printf("File size:                %lld bytes\\n",
            (long long) sb.st_size);
    printf("Blocks allocated:         %lld\\n",
            (long long) sb.st_blocks);

    printf("Last status change:       %s", ctime(&sb.st_ctime));
    printf("Last file access:         %s", ctime(&sb.st_atime));
    printf("Last file modification:   %s", ctime(&sb.st_mtime));

    exit(EXIT_SUCCESS);
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR access (2),
.BR chmod (2),
.BR chown (2),
.BR fstatat (2),
.BR readlink (2),
.BR utime (2),
.BR capabilities (7),
.BR symlink (7)

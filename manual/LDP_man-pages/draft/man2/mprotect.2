.\" -*- nroff -*-
.\" Copyright (C) 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (C) 1995 Michael Shields <shields@tembel.org>.
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and author of this work.
.\"
.\" Modified 1996-10-22 by Eric S. Raymond <esr@thyrsus.com>
.\" Modified 1997-05-31 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 2003-08-24 by Andries Brouwer <aeb@cwi.nl>
.\" Modified 2004-08-16 by Andi Kleen <ak@muc.de>
.\" 2007-06-02, mtk: Fairly substantial rewrites and additions, and
.\" a much improved example program.
.\"
.\" Japanese Version Copyright (c) 1997 HANATAKA Shinya
.\"         all rights reserved.
.\" Translated 1997-06-01, HANATAKA Shinya <hanataka@abyss.rim.or.jp>
.\" Updated and revised 2003-10-24, Suzuki Takashi.
.\" Updated & Modified 2005-02-08, Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated & Modified 2005-10-15, Yuichi SATO
.\" Updated 2007-06-11, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.54
.\"
.\"WORD: bitwise-or             ビットごとの論理和
.\"WORD: protection             アクセス保護
.\"WORD: read-only              読み取り専用
.\"
.TH MPROTECT 2 2011-09-08 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O mprotect \- set protection on a region of memory
mprotect \- メモリ領域の保護を設定する
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/mman.h>
.sp
.BI "int mprotect(const void *" addr ", size_t " len ", int " prot );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR mprotect ()
.\"O changes protection for the calling process's memory page(s)
.\"O containing any part of the address range in the
.\"O interval [\fIaddr\fP,\ \fIaddr\fP+\fIlen\fP\-1].
.\"O .I addr
.\"O must be aligned to a page boundary.
.BR mprotect ()
は、区間 [\fIaddr\fP,\ \fIaddr\fP+\fIlen\fP\-1] のアドレス範囲を含む
呼び出し元のプロセスのメモリページのアクセス保護を変更する。
.I addr
はページ境界に一致していなければならない。

.\"O If the calling process tries to access memory in a manner
.\"O that violates the protection, then the kernel generates a
.\"O .B SIGSEGV
.\"O signal for the process.
呼び出し元のプロセスがアクセス保護に違反するようなメモリアクセスを
行おうとすると、カーネルはシグナル
.B SIGSEGV
をそのプロセスに対して生成する。
.PP
.\"O .I prot
.\"O is either
.\"O .B PROT_NONE
.\"O or a bitwise-or of the other values in the following list:
.I prot
には、
.B PROT_NONE
か、以下のリストの
.B PROT_NONE
以外の値をビット毎の論理和 (bitwize-or) で指定する:
.TP 1.1i
.B PROT_NONE
.\"O The memory cannot be accessed at all.
そのメモリには全くアクセスできない。
.TP
.B PROT_READ
.\"O The memory can be read.
そのメモリを読み取ることができる。
.TP
.B PROT_WRITE
.\"O The memory can be modified.
そのメモリを変更できる。
.TP
.B PROT_EXEC
.\"O The memory can be executed.
そのメモリは実行可能である。
.\" FIXME
.\" Document PROT_GROWSUP and PROT_GROWSDOWN
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O On success,
.\"O .BR mprotect ()
.\"O returns zero.
.\"O On error, \-1 is returned, and
.\"O .I errno
.\"O is set appropriately.
成功した場合、
.BR mprotect ()
は 0 を返す。エラーの場合は \-1 が返り、
.I errno
が適切に設定される。
.\"O .SH ERRORS
.SH エラー
.TP
.B EACCES
.\"O The memory cannot be given the specified access.
.\"O This can happen, for example, if you
.\"O .BR mmap (2)
.\"O a file to which you have read-only access, then ask
.\"O .BR mprotect ()
.\"O to mark it
.\"O .BR PROT_WRITE .
指定されたアクセスをメモリに設定することができない。
これは、例えば
ファイルを読み取り専用で
.BR mmap (2)
しており、その領域に対して
.BR mprotect ()
を呼び出して
.B PROT_WRITE
に設定しようとした場合に発生する。
.TP
.B EINVAL
.\"O \fIaddr\fP is not a valid pointer,
.\"O or not a multiple of the system page size.
\fIaddr\fP が有効なポインタでないか、
システムのページサイズの倍数でない。
.\" Or: both PROT_GROWSUP and PROT_GROWSDOWN were specified in 'prot'.
.TP
.B ENOMEM
.\"O Internal kernel structures could not be allocated.
カーネル内部の構造体を割り当てることができなかった。
.TP
.B ENOMEM
.\"O Addresses in the range
.\"O .RI [ addr ,
.\"O .IR addr + len \-1]
.\"O are invalid for the address space of the process,
.\"O or specify one or more pages that are not mapped.
.\"O (Before kernel 2.4.19, the error
.\"O .BR EFAULT
.\"O was incorrectly produced for these cases.)
.RI [ addr ,
.IR addr + len \-1]
という範囲のアドレスがプロセスのアドレス空間として不正であるか、
その範囲のアドレスがマップされていない 1 つ以上のページを指している
(カーネル 2.4.19 より前では、この状況でエラー
.B EFAULT
が間違って生成されていた)。
.\"O .SH "CONFORMING TO"
.SH 準拠
SVr4, POSIX.1-2001.
.\"O .\" SVr4 defines an additional error
.\"O .\" code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
.\"O POSIX says that the behavior of
.\"O .BR mprotect ()
.\"O is unspecified if it is applied to a region of memory that
.\"O was not obtained via
.\"O .BR mmap (2).
.\" SVr4 では他にエラーコード EAGAIN が定義されている。
.\" SVr4 のエラー条件は Linux のものにきちんと対応しない。
POSIX では、
.BR mmap (2)
経由で獲得していないメモリ領域に対して
.BR mprotect ()
を行った場合の
.BR mprotect ()
の動作は未定義であるとされている。
.\"O .SH NOTES
.SH 注意
.\"O On Linux it is always permissible to call
.\"O .BR mprotect ()
.\"O on any address in a process's address space (except for the
.\"O kernel vsyscall area).
.\"O In particular it can be used
.\"O to change existing code mappings to be writable.
Linux では、(カーネル vsyscall 領域以外の)
任意のプロセスアドレス空間に対して
.BR mprotect ()
を呼び出すことが、常に許されている。
これは特に既存のコードマッピングを書き込み可能にするために使われる。

.\"O Whether
.\"O .B PROT_EXEC
.\"O has any effect different from
.\"O .B PROT_READ
.\"O is architecture- and kernel version-dependent.
.\"O On some hardware architectures (e.g., i386),
.\"O .B PROT_WRITE
.\"O implies
.\"O .BR PROT_READ .
.B PROT_EXEC
が
.B PROT_READ
と異なる影響を持つか否かは、アーキテクチャとカーネルのバージョンに依存する。
(i386 などの) いくつかのアーキテクチャでは、
.B PROT_WRITE
をセットすると、暗黙のうちに
.B PROT_READ
がセットされる。

.\"O POSIX.1-2001 says that an implementation may permit access
.\"O other than that specified in
.\"O .IR prot ,
.\"O but at a minimum can only allow write access if
.\"O .B PROT_WRITE
.\"O has been set, and must not allow any access if
.\"O .B PROT_NONE
.\"O has been set.
POSIX.1-2001 では、
.I prot
で指定されていないアクセスを許可する実装を認めている。
ただし、最低限、
.B PROT_WRITE
がセットされている場合にのみ書き込みアクセスが許可され、
.B PROT_NONE
がセットされている場合にはアクセスは許可されない点だけは
満たす必要がある。
.\"O .SH EXAMPLE
.SH 例
.\" sigaction.2 refers to this example
.PP
.\"O The program below allocates four pages of memory, makes the third
.\"O of these pages read-only, and then executes a loop that walks upward
.\"O through the allocated region modifying bytes.
以下のプログラムは、メモリページを 4つ確保し、そのうち 3番目のページを
読み込み専用に設定する。その後で、確保した領域のアドレスの小さい方から
大きな方に向かって順番にバイト値を変更するループを実行する。

.\"O An example of what we might see when running the program is the
.\"O following:
プログラムを実行した場合の一例を以下に示す。

.in +4n
.nf
.RB "$" " ./a.out"
Start of region:        0x804c000
Got SIGSEGV at address: 0x804e000
.fi
.\"O .SS Program source
.SS プログラムのソース
\&
.in
.nf
#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/mman.h>

#define handle_error(msg) \\
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

char *buffer;

static void
handler(int sig, siginfo_t *si, void *unused)
{
    printf("Got SIGSEGV at address: 0x%lx\\n",
            (long) si\->si_addr);
    exit(EXIT_FAILURE);
}

int
main(void)
{
    char *p;
    int pagesize;
    struct sigaction sa;

    sa.sa_flags = SA_SIGINFO;
    sigemptyset(&sa.sa_mask);
    sa.sa_sigaction = handler;
    if (sigaction(SIGSEGV, &sa, NULL) == \-1)
        handle_error("sigaction");

    pagesize = sysconf(_SC_PAGE_SIZE);
    if (pagesize == \-1)
        handle_error("sysconf");

    /* Allocate a buffer aligned on a page boundary;
       initial protection is PROT_READ | PROT_WRITE */

    buffer = memalign(pagesize, 4 * pagesize);
    if (buffer == NULL)
        handle_error("memalign");

    printf("Start of region:        0x%lx\\n", (long) buffer);

    if (mprotect(buffer + pagesize * 2, pagesize,
                PROT_READ) == \-1)
        handle_error("mprotect");

    for (p = buffer ; ; )
        *(p++) = \(aqa\(aq;

    printf("Loop completed\\n");     /* Should never happen */
    exit(EXIT_SUCCESS);
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR mmap (2),
.BR sysconf (3)

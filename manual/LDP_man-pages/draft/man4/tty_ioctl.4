.\" Copyright 2002 Walter Harms <walter.harms@informatik.uni-oldenburg.de>
.\" and Andries Brouwer <aeb@cwi.nl>.
.\" Distributed under GPL.
.\"
.\" Japanese Version Copyright (c) 2004 Yuichi SATO
.\"         all rights reserved.
.\" Translated Sat Oct 16 06:08:24 JST 2004
.\"         by Yuichi SATO <ysato444@yahoo.co.jp>
.\"
.TH TTY_IOCTL 4 2008-10-29 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O tty_ioctl \- ioctls for terminals and serial lines
tty_ioctl \- 端末とシリアルラインの ioctl (入出力制御)
.\"O .SH SYNOPSIS
.SH 書式
.B "#include <termios.h>"
.sp
.BI "int ioctl(int " fd ", int " cmd ", ...);"
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR ioctl (2)
.\"O call for terminals and serial ports accepts many possible command arguments.
端末とシリアルポートについての
.BR ioctl (2)
コールは、多くのコマンド引き数を受け付ける。
.\"O Most require a third argument, of varying type, here called \fIargp\fP
.\"O or \fIarg\fP.
多くがいろいろな型の 3 番目の引き数を必要とする。
ここでは \fIargp\fP または \fIarg\fP と呼ぶ。
.LP
.\"O Use of
.\"O .I ioctl
.\"O makes for nonportable programs.
.\"O Use the POSIX interface described in
.\"O .BR termios (3)
.\"O whenever possible.
.I ioctl
を使用すると移植性のないプログラムになる。
可能な場合は、
.BR termios (3)
に記述されている POSIX インタフェースを使うこと。
.\"O .SS "Get and Set Terminal Attributes"
.SS 端末属性の取得と設定
.TP
.BI "TCGETS	struct termios *" argp
.\"O Equivalent to
.\"O .IR "tcgetattr(fd, argp)" .
.I "tcgetattr(fd, argp)"
と同じ。
.br
.\"O Get the current serial port settings.
現在のシリアルポートの設定を取得する。
.TP
.BI "TCSETS	const struct termios *" argp
.\"O Equivalent to
.\"O .IR "tcsetattr(fd, TCSANOW, argp)" .
.I "tcsetattr(fd, TCSANOW, argp)"
と同じ。
.br
.\"O Set the current serial port settings.
現在のシリアルポートの設定を変更する。
.TP
.BI "TCSETSW	const struct termios *" argp
.\"O Equivalent to
.\"O .IR "tcsetattr(fd, TCSADRAIN, argp)" .
.I "tcsetattr(fd, TCSADRAIN, argp)"
と同じ。
.br
.\"O Allow the output buffer to drain, and
.\"O set the current serial port settings.
排出 (drain) を行うための出力バッファの使用を許可し、
現在のシリアルポートの設定を変更する。
.TP
.BI "TCSETSF	const struct termios *" argp
.\"O Equivalent to
.\"O .IR "tcsetattr(fd, TCSAFLUSH, argp)" .
.I "tcsetattr(fd, TCSAFLUSH, argp)"
と同じ。
.br
.\"O Allow the output buffer to drain, discard pending input, and
.\"O set the current serial port settings.
排出 (drain) を行うための出力バッファの使用を許可し、
処理していない入力を破棄して、
現在のシリアルポートの設定を変更する。
.LP
.\"O The following four ioctls are just like
.\"O .BR TCGETS ,
.\"O .BR TCSETS ,
.\"O .BR TCSETSW ,
.\"O .BR TCSETSF ,
.\"O except that they take a
.\"O .I "struct termio *"
.\"O instead of a
.\"O .IR "struct termios *" .
以下の 4 つの ioctl は
.BR TCGETS ,
.BR TCSETS ,
.BR TCSETSW ,
.B TCSETSF
と似ている。
ただし、
.I "struct termios *"
の代わりに
.I "struct termio *"
を取る。
.TP
.BI "TCGETA	struct termio *" argp
.TP
.BI "TCSETA	const struct termio *" argp
.TP
.BI "TCSETAW	const struct termio *" argp
.TP
.BI "TCSETAF	const struct termio *" argp
.\"O .SS "Locking the termios structure"
.SS "termios 構造体のロック"
.\"O The
.\"O .I termios
.\"O structure of a terminal can be locked.
.\"O The lock is itself a
.\"O .I termios
.\"O structure, with nonzero bits or fields indicating a
.\"O locked value.
端末の
.I termios
構造体はロックすることが可能である。
このロック自体は
.I termios
構造体であり、
0 でないビットまたはフィールドはロックされた値を示す。
.TP
.BI "TIOCGLCKTRMIOS	struct termios *" argp
.\"O Gets the locking status of the
.\"O .I termios
.\"O structure of the terminal.
端末の
.I termios
構造体のロック状態を取得する。
.TP
.BI "TIOCSLCKTRMIOS	const struct termios *" argp
.\"O Sets the locking status of the
.\"O .I termios
.\"O structure of the terminal.
.\"O Only root (more precisely: a process with the
.\"O .BR CAP_SYS_ADMIN
.\"O capability) can do this.
端末の
.I termios
構造体のロック状態を設定する。
root のみ (より正確には、
.B CAP_SYS_ADMIN
ケーパビリティを持つプロセス) がこれを実行できる。
.\"O .SS "Get and Set Window Size"
.SS ウィンドウサイズの取得と設定
.\"O Window sizes are kept in the kernel, but not used by the kernel
.\"O (except in the case of virtual consoles, where the kernel will
.\"O update the window size when the size of the virtual console changes,
.\"O for example, by loading a new font).
ウィンドウサイズはカーネル内に保持されるが、
カーネルによって使用されない
(仮想コンソールの場合は例外であり、新しいフォントを読み込んだ場合など、
仮想端末のサイズが変更された場合、カーネルはウィンドウサイズを更新する)。

.\"O The following constants and structure are defined in
.\"O .IR <sys/ioctl.h> .
以下の定数と構造体は
.I <sys/ioctl.h>
で定義されている。
.TP
.BI "TIOCGWINSZ	struct winsize *" argp
.\"O Get window size.
ウィンドウサイズを取得する。
.TP
.BI "TIOCSWINSZ	const struct winsize *" argp
.\"O Set window size.
ウィンドウサイズを設定する。
.LP
.\"O The struct used by these ioctls is defined as
これらの ioctl で使用される構造体は、以下のように定義される。

.in +4n
.nf
struct winsize {
    unsigned short ws_row;
    unsigned short ws_col;
.\"O     unsigned short ws_xpixel;   /* unused */
.\"O     unsigned short ws_ypixel;   /* unused */
    unsigned short ws_xpixel;   /* 未使用 */
    unsigned short ws_ypixel;   /* 未使用 */
};
.fi
.in

.\"O When the window size changes, a
.\"O .B SIGWINCH
.\"O signal is sent to the
.\"O foreground process group.
ウィンドウサイズが変更された場合、
フォアグラウンドプロセスグループに
.B SIGWINCH
シグナルが送られる。
.\"O .SS "Sending a Break"
.SS "break の送信"
.TP
.BI "TCSBRK	int " arg
.\"O Equivalent to
.\"O .IR "tcsendbreak(fd, arg)" .
.I "tcsendbreak(fd, arg)"
と同じ。
.br
.\"O If the terminal is using asynchronous serial data transmission, and
.\"O .I arg
.\"O is zero, then send a break (a stream of zero bits) for between
.\"O 0.25 and 0.5 seconds.
.\"O If the terminal is not using asynchronous
.\"O serial data transmission, then either a break is sent, or the function
.\"O returns without doing anything.
端末が非同期シリアルデータ転送を使用しており、
.I arg
が 0 の場合、0.25 から 0.5 秒の間に
break (0 のビット列のストリーム) が送信される。
端末が非同期シリアルデータ転送を使用している場合、
break が送信されるか、この関数は何もせずに返る。
.\"O When
.\"O .I arg
.\"O is nonzero, nobody knows what will happen.
.I arg
が 0 以外の場合、何が起こるか分からない。

.\"O (SVr4, UnixWare, Solaris, Linux treat
.\"O .I "tcsendbreak(fd,arg)"
.\"O with nonzero
.\"O .I arg
.\"O like
.\"O .IR "tcdrain(fd)" .
(SVr4, UnixWare, Solaris, Linux は、
.I "tcsendbreak(fd,arg)"
の
.I arg
が 0 以外の場合、
.I "tcdrain(fd)"
のように扱う。
.\"O SunOS treats
.\"O .I arg
.\"O as a multiplier, and sends a stream of bits
.\"O .I arg
.\"O times as long as done for zero
.\"O .IR arg .
SunOS は
.I arg
を倍数として扱い、ビットのストリームを
.I arg
回送信する。
.I arg
が 0 の場合も同じ。
.\"O DG/UX and AIX treat
.\"O .I arg
.\"O (when nonzero) as a time interval measured in milliseconds.
DG/UX と AIX は、(0 以外の場合)
.I arg
をミリ秒単位の時間間隔として扱う。
.\"O HP-UX ignores
.\"O .IR arg .)
HP-UX は
.I arg
を無視する。)
.TP
.BI "TCSBRKP	int " arg
.\"O So-called "POSIX version" of
.\"O .BR TCSBRK .
.\"O It treats nonzero
.\"O .I arg
.\"O as a timeinterval measured in deciseconds, and does nothing
.\"O when the driver does not support breaks.
いわゆる「POSIX 版」の
.B TCSBRK
である。
これは 0 以外の
.I arg
を 1/10 秒単位の時間間隔として扱う。
またドライバが break をサポートしていない場合は、何もしない。
.TP
.B "TIOCSBRK	void"
.\"O Turn break on, that is, start sending zero bits.
break をオンにする。
つまり 0 のビット列の送信を開始する。
.TP
.B "TIOCCBRK	void"
.\"O Turn break off, that is, stop sending zero bits.
break をオフにする。
つまり 0 のビット列の送信を停止する。
.\"O .SS "Software flow control"
.SS ソフトウェアフロー制御
.TP
.BI "TCXONC	int " arg
.\"O Equivalent to
.\"O .IR "tcflow(fd, arg)" .
.I "tcflow(fd, arg)"
と同じ。
.br
.\"O See
.\"O .BR tcflow (3)
.\"O for the argument values
.\"O .BR TCOOFF ,
.\"O .BR TCOON ,
.\"O .BR TCIOFF ,
.\"O .BR TCION .
.BR tcflow (3)
の引き数
.BR TCOOFF ,
.BR TCOON ,
.BR TCIOFF ,
.B TCION
を参照すること。
.\"O .SS "Buffer count and flushing"
.SS "バッファのカウントと書き出し (flush)"
.TP
.BI "FIONREAD	int *" argp
.\"O Get the number of bytes in the input buffer.
入力バッファにあるバイト数を取得する。
.TP
.BI "TIOCINQ	int *" argp
.\"O Same as
.\"O .BR FIONREAD .
.B FIONREAD
と同じ。
.TP
.BI "TIOCOUTQ	int *" argp
.\"O Get the number of bytes in the output buffer.
出力バッファにあるバイト数を取得する。
.TP
.BI "TCFLSH	int " arg
.\"O Equivalent to
.\"O .IR "tcflush(fd, arg)" .
.I "tcflush(fd, arg)"
と同じ。
.br
.\"O See
.\"O .BR tcflush (3)
.\"O for the argument values
.\"O .BR TCIFLUSH ,
.\"O .BR TCOFLUSH ,
.\"O .BR TCIOFLUSH .
.BR tcflush (3)
の引き数
.BR TCIFLUSH ,
.BR TCOFLUSH ,
.B TCIOFLUSH
を参照すること。
.\"O .SS "Faking input"
.SS 入力の偽装
.TP
.BI "TIOCSTI	const char *" argp
.\"O Insert the given byte in the input queue.
指定されたバイトを入力キューに挿入する。
.\"O .SS "Redirecting console output"
.SS コンソール出力のリダイレクト
.TP
.B "TIOCCONS	void"
.\"O Redirect output that would have gone to
.\"O .I /dev/console
.\"O or
.\"O .I /dev/tty0
.\"O to the given terminal.
.\"O If that was a pseudoterminal master, send it to the slave.
.I /dev/console
または
.I /dev/tty0
に送られる出力を、指定された端末リダイレクトする。
指定された端末が疑似端末 (pseudoterminal) のマスタの場合、
出力はスレーブに送られる。
.\"O In Linux before version 2.6.10,
.\"O anybody can do this as long as the output was not redirected yet;
.\"O since version 2.6.10, only root (a process with the
.\"O .BR CAP_SYS_ADMIN
.\"O capability) may do this.
バージョン 2.6.10 より前の Linux では、出力がまだリダイレクトされて
いなければ、誰でもリダイレクトを行うことができる。
バージョン 2.6.10 以降では、root
.RB ( CAP_SYS_ADMIN
ケーパビリティを持つプロセス) だけがリダイレクトを行うことができる。
.\"O If output was redirected already
.\"O .B EBUSY
.\"O is returned,
.\"O but redirection can be stopped by using this ioctl with
.\"O .I fd
.\"O pointing at
.\"O .I /dev/console
.\"O or
.\"O .IR /dev/tty0 .
出力がすでにリダイレクトされている場合は
.B EBUSY
が返されるが、
.I /dev/console
か
.I /dev/tty0
を指している
.I fd
に対してこの ioctl を使用することで、リダイレクトを止めることができる。
.\"O .SS "Controlling terminal"
.SS "端末の制御"
.TP
.BI "TIOCSCTTY	int " arg
.\"O Make the given terminal the controlling terminal of the calling process.
指定された端末を呼び出し元のプロセスの制御端末にする。
.\"O The calling process must be a session leader and not have a
.\"O controlling terminal already.
.\"O If this terminal is already the controlling terminal
.\"O of a different session group then the ioctl fails with
.\"O .BR EPERM ,
.\"O unless the caller is root (more precisely: has the
.\"O .BR CAP_SYS_ADMIN
.\"O capability) and
.\"O .I arg
.\"O equals 1, in which case the terminal is stolen, and all processes that had
.\"O it as controlling terminal lose it.
呼び出し元のプロセスはセッションリーダでなければならず、
かつ既に制御端末を持っていてはならない。
この端末が既に他のセッショングループの制御端末である場合、
ioctl は
.B EPERM
で失敗する。ただし呼び出したユーザが root で
(より正確には
.B CAP_SYS_ADMIN
ケーパビリティを持っていて)、かつ
.I arg
が 1 である場合を除く。
この場合、端末は盗まれ (stolen)、
この端末を制御端末としていた全てのプロセスは端末を失う。
.TP
.B TIOCNOTTY	void
.\"O If the given terminal was the controlling terminal of the calling process,
.\"O give up this controlling terminal.
.\"O If the process was session leader,
.\"O then send
.\"O .B SIGHUP
.\"O and
.\"O .B SIGCONT
.\"O to the foreground process group
.\"O and all processes in the current session lose their controlling terminal.
指定された端末が呼び出し元のプロセスの制御端末である場合、
この制御端末を放棄する。
プロセスがセッションリーダの場合、
フォアグラウンドプロセスグループに
.B SIGHUP
と
.B SIGCONT
を送り、カレントセッションの全てのプロセスは制御端末を失う。
.\"O .SS "Process group and session ID"
.SS "グループ ID とセッション ID の処理"
.TP
.BI "TIOCGPGRP	pid_t *" argp
.\"O When successful, equivalent to
.\"O .IR "*argp = tcgetpgrp(fd)" .
成功した場合、
.I "*argp = tcgetpgrp(fd)"
と同じ。
.br
.\"O Get the process group ID of the foreground process group on this terminal.
この端末上のフォアグラウンドプロセスのプロセスグループ ID を取得する。
.TP
.BI "TIOCSPGRP	const pid_t *" argp
.\"O Equivalent to
.\"O .IR "tcsetpgrp(fd, *argp)" .
.I "tcsetpgrp(fd, *argp)"
と同じ。
.br
.\"O Set the foreground process group ID of this terminal.
この端末のフォアグラウンドプロセスのグループ ID を設定する。
.TP
.BI "TIOCGSID	pid_t *" argp
.\"O Get the session ID of the given terminal.
.\"O This will fail with
.\"O .B ENOTTY
.\"O in case the terminal is not a master pseudoterminal
.\"O and not our controlling terminal.
.\"O Strange.
指定された端末のセッション ID を取得する。
端末がマスタ疑似端末または制御端末でない場合は、
.B ENOTTY
で失敗する。
奇妙だ。
.\"O .SS "Exclusive mode"
.SS 排他モード
.TP
.B "TIOCEXCL	void"
.\"O Put the terminal into exclusive mode.
.\"O No further
.\"O .BR open (2)
.\"O operations on the terminal are permitted.
.\"O (They will fail with
.\"O .BR EBUSY ,
.\"O except for root, that is, a process with the
.\"O .BR CAP_SYS_ADMIN
.\"O capability.)
端末を排他モードにする。
端末に対して、これ以降の
.BR open (2)
操作を禁止する。
(root 以外の場合、つまり
.B CAP_SYS_ADMIN
ケーパビリティを持たないプロセスの場合、これ以降の
.BR open (2)
は
.B EBUSY
で失敗する。)
.TP
.B "TIOCNXCL	void"
.\"O Disable exclusive mode.
排他モードを無効にする。
.\"O .SS "Line discipline"
.SS "ライン制御 (line discipline)"
.TP
.BI "TIOCGETD	int *" argp
.\"O Get the line discipline of the terminal.
端末のライン制御の情報を取得する。
.TP
.BI "TIOCSETD	const int *" argp
.\"O Set the line discipline of the terminal.
端末のライン制御の情報を設定する。
.\"O .SS "Pseudoterminal ioctls"
.SS "疑似端末の ioctl"
.TP
.BI "TIOCPKT	const int *" argp
.\"O Enable (when
.\"O .RI * argp
.\"O is nonzero) or disable packet mode.
パケットモードを有効
.RI (* argp
が 0 以外の場合) または無効にする。
.\"O Can be applied to the master side of a pseudoterminal only (and will return
.\"O .B ENOTTY
.\"O otherwise).
.\"O In packet mode, each subsequent
.\"O .BR read (2)
.\"O will return a packet that either contains a single nonzero control byte,
.\"O or has a single byte containing zero (\(aq\0\(aq) followed by data
.\"O written on the slave side of the pseudoterminal.
.\"O If the first byte is not
.\"O .B TIOCPKT_DATA
.\"O (0), it is an OR of one
.\"O or more of the following bits:
疑似端末のマスタ側にのみ適用できる (それ以外の場合は
.B ENOTTY
を返す)。
パケットモードでは、その後に実行される
.BR read (2)
は、値が 0 以外の 1 つの制御バイトを含むパケットか、
値が 0 の 1 バイト (\(aq\\0\(aq) に疑似端末のスレーブ側で書き込まれた
データが続くパケットを返す。
最初のバイトが
.B TIOCPKT_DATA
(0) でない場合、以下のビットの 1 つ以上を OR したものである:

.nf
.\"O TIOCPKT_FLUSHREAD   The read queue for the terminal is flushed.
TIOCPKT_FLUSHREAD   端末の読み込みキューがフラッシュ (flush) される。
.\"O TIOCPKT_FLUSHWRITE  The write queue for the terminal is flushed.
TIOCPKT_FLUSHWRITE  端末の書き出しキューがフラッシュされる。
.\"O TIOCPKT_STOP        Output to the terminal is stopped.
TIOCPKT_STOP        端末への出力が停止される。
.\"O TIOCPKT_START       Output to the terminal is restarted.
TIOCPKT_START       端末への出力が再開される。
.\"O TIOCPKT_DOSTOP      The start and stop characters are \fB^S\fP/\fB^Q\fP.
.\"O TIOCPKT_NOSTOP      The start and stop characters are not \fB^S\fP/\fB^Q\fP.
TIOCPKT_DOSTOP      開始文字と終了文字が \fB^S\fP/\fB^Q\fP である。
TIOCPKT_NOSTOP      開始文字と終了文字が \fB^S\fP/\fB^Q\fP でない。
.fi

.\"O While this mode is in use, the presence
.\"O of control status information to be read
.\"O from the master side may be detected by a
.\"O .BR select (2)
.\"O for exceptional conditions.
このモードが使われている場合、
制御状態情報の存在がマスタ側から読み込めるかは、
例外的な条件で
.BR select (2)
を使うことにより知ることができる。

.\"O This mode is used by
.\"O .BR rlogin (1)
.\"O and
.\"O .BR rlogind (8)
.\"O to implement a remote-echoed,
.\"O locally \fB^S\fP/\fB^Q\fP flow-controlled remote login.
このモードは
.BR rlogin (1)
と
.BR rlogind (8)
で使われ、リモートエコーのリモートログインと
ローカルでの \fB^S\fP/\fB^Q\fP フロー制御のリモートログインを実装している。

.\"O The BSD ioctls
.\"O .BR TIOCSTOP ,
.\"O .BR TIOCSTART ,
.\"O .BR TIOCUCNTL ,
.\"O .B TIOCREMOTE
.\"O have not been implemented under Linux.
BSD の ioctl である
.BR TIOCSTOP ,
.BR TIOCSTART ,
.BR TIOCUCNTL ,
.B TIOCREMOTE
は、Linux では実装されていない。
.\"O .SS "Modem control"
.SS モデム制御
.TP
.BI "TIOCMGET	int *" argp
.\"O get the status of modem bits.
モデムビット列の状態を取得する。
.TP
.BI "TIOCMSET	const int *" argp
.\"O set the status of modem bits.
モデムビット列の状態を設定する。
.TP
.BI "TIOCMBIC	const int *" argp
.\"O clear the indicated modem bits.
指定されたモデムビット列をクリアする。
.TP
.BI "TIOCMBIS	const int *" argp
.\"O set the indicated modem bits.
指定されたモデムビット列を設定する。
.LP
.\"O Bits used by these four ioctls:
これらの 4 つの ioctl で使われるビットは以下の通り:

.nf
TIOCM_LE        DSR (data set ready/line enable)
TIOCM_DTR       DTR (data terminal ready)
TIOCM_RTS       RTS (request to send)
TIOCM_ST        Secondary TXD (transmit)
TIOCM_SR        Secondary RXD (receive)
TIOCM_CTS       CTS (clear to send)
TIOCM_CAR       DCD (data carrier detect)
.\"O TIOCM_CD         see TIOCM_CAR
TIOCM_CD         TIOCM_CAR を参照。
TIOCM_RNG       RNG (ring)
.\"O TIOCM_RI         see TIOCM_RNG
TIOCM_RI         TIOCM_RNG を参照。
TIOCM_DSR       DSR (data set ready)
.fi
.\"O .SS "Marking a line as local"
.SS "回線をローカルとしてマークする"
.TP
.BI "TIOCGSOFTCAR	int *" argp
.\"O ("Get software carrier flag")
.\"O Get the status of the CLOCAL flag in the c_cflag field of the
.\"O .I termios
.\"O structure.
("ソフトウェアキャリアフラグの取得")
.I termios
構造体の c_cflag フィールドの
.B CLOCAL
フラグの状態を取得する。
.TP
.BI "TIOCSSOFTCAR	const int *" argp
.\"O ("Set software carrier flag")
.\"O Set the CLOCAL flag in the
.\"O .I termios
.\"O structure when
.\"O .RI * argp
.\"O is nonzero, and clear it otherwise.
("ソフトウェアキャリアフラグの設定")
.RI * argp
が 0 以外の場合、
.I termios
構造体の
.B CLOCAL
フラグを設定する。
0 の場合はクリアする。
.LP
.\"O If the
.\"O .B CLOCAL
.\"O flag for a line is off, the hardware carrier detect (DCD)
.\"O signal is significant, and an
.\"O .BR open (2)
.\"O of the corresponding terminal will block until DCD is asserted,
.\"O unless the
.\"O .B O_NONBLOCK
.\"O flag is given.
ラインの
.B CLOCAL
フラグがオフの場合、
ハードウェアキャリア検出 (hardware carrier detect, DCD) シグナルが重要であり、
.B O_NONBLOCK
フラグが指定されない限り、対応する端末の
.BR open (2)
は DCD が示されるまでブロックされる。
.\"O If
.\"O .B CLOCAL
.\"O is set, the line behaves as if DCD is always asserted.
.B CLOCAL
が設定されている場合、
ラインは常に DCD が示されているかのように動作する。
.\"O The software carrier flag is usually turned on for local devices,
.\"O and is off for lines with modems.
ソフトウェアキャリアフラグは、ローカルデバイスでは通常はオンになっており、
モデムのラインではオフになっている。
.\"O .SS "Linux-specific"
.SS "Linux 固有の ioctl"
.\"O For the
.\"O .B TIOCLINUX
.\"O ioctl, see
.\"O .BR console_ioctl (4).
.B TIOCLINUX
ioctl については、
.BR console_ioctl (4)
を参照すること。
.\"O .SS "Kernel debugging"
.SS カーネルデバッギング
.B "#include <linux/tty.h>"
.TP
.BI "TIOCTTYGSTRUCT	struct tty_struct *" argp
.\"O Get the
.\"O .I tty_struct
.\"O corresponding to
.\"O .IR fd .
.I fd
に対応する
.I tty_struct
を取得する。
.\"O .\" .SS "Serial info"
.\" .SS "シリアル情報"
.\" .BR "#include <linux/serial.h>"
.\" .sp
.\" .TP
.\" .BI "TIOCGSERIAL	struct serial_struct *" argp
.\"O .\" Get serial info.
.\" シリアル情報を取得する。
.\" .TP
.\" .BI "TIOCSSERIAL	const struct serial_struct *" argp
.\"O .\" Set serial info.
.\" シリアル情報を設定する。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O The
.\"O .BR ioctl (2)
.\"O system call returns 0 on success.
.\"O On error it returns \-1 and sets
.\"O .I errno
.\"O appropriately.
.BR ioctl (2)
システムコールは、成功した場合は 0 を返す。
エラーの場合は \-1 を返し、
.I errno
を適切に設定する。
.\"O .SH ERRORS
.SH エラー
.TP
.B EINVAL
.\"O Invalid command parameter.
不正なコマンド引き数である。
.TP
.B ENOIOCTLCMD
.\"O Unknown command.
不明なコマンドである。
.TP
.B ENOTTY
.\"O Inappropriate
.\"O .IR fd .
.I fd
が不適切である。
.TP
.B EPERM
.\"O Insufficient permission.
権限が不足している。
.\"O .SH EXAMPLE
.SH 例
.\"O Check the condition of DTR on the serial port.
シリアルポートの DTR の状態をチェックする。

.nf
#include <termios.h>
#include <fcntl.h>
#include <sys/ioctl.h>

int
main(void)
{
    int fd, serial;

    fd = open("/dev/ttyS0", O_RDONLY);
    ioctl(fd, TIOCMGET, &serial);
    if (serial & TIOCM_DTR)
.\"O         puts("TIOCM_DTR is not set");
        puts("TIOCM_DTR が設定されていない。");
    else
.\"O         puts("TIOCM_DTR is set");
        puts("TIOCM_DTR が設定されている。");
    close(fd);
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR ioctl (2),
.BR termios (3),
.BR console_ioctl (4),
.BR pty (7)
.\"
.\" FIONBIO			const int *
.\" FIONCLEX			void
.\" FIOCLEX			void
.\" FIOASYNC			const int *
.\"O .\" from serial.c:
.\" serial.c より:
.\" TIOCSERCONFIG		void
.\" TIOCSERGWILD		int *
.\" TIOCSERSWILD		const int *
.\" TIOCSERGSTRUCT		struct async_struct *
.\" TIOCSERGETLSR		int *
.\" TIOCSERGETMULTI		struct serial_multiport_struct *
.\" TIOCSERSETMULTI		const struct serial_multiport_struct *
.\"O .\" TIOCGSERIAL, TIOCSSERIAL (see above)
.\" TIOCGSERIAL, TIOCSSERIAL (上記を参照)

'\" t
.\" Copyright (c) 1996 Andries Brouwer <aeb@cwi.nl>, Mon Oct 31 22:13:04 1996
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" This is combined from many sources.
.\" For Linux, the definitive source is of course console.c.
.\" About vt100-like escape sequences in general there are
.\" the ISO 6429 and ISO 2022 norms, the descriptions of
.\" an actual vt100, and the xterm docs (ctlseqs.ms).
.\" Substantial portions of this text are derived from a write-up
.\" by Eric S. Raymond <esr@thyrsus.com>.
.\"
.\" Tiny correction, aeb, 961107.
.\"
.\" 2006-05-27, Several corrections - Thomas E. Dickey
.\"
.\" Japanese Version Copyright (c) 1996,1997,1998
.\"         ISHIKAWA Mutsumi, TAKAHASHI Mutsuji
.\"                                    all rights reserved.
.\" Translated Mon Jul 21 03:12:45 JST 1997
.\"         by ISHIKAWA Mutsumi <ishikawa@linux.or.jp>
.\"		and TAKAHASHI Mutsuji <muz@ilp.iijnet.or.jp>
.\"
.\" Japanese Version Modified Mon Jan 12 03:29:14 JST 1998
.\"	by ISHIKAWA Mutsumi <ishikawa@linux.or.jp>
.\" Updated Wed Jan  9 JST 2001 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated Sun Jul 23 JST 2006 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated Tue Jul 22 JST 2008 by Kentaro Shirakata <argrath@ub32.org>
.\"
.\" WORD:	private mode	プライベートモード
.\"
.TH CONSOLE_CODES 4 2008-01-01 "Linux" "Linux Programmer's Manual"
.SH 名前
console_codes \- Linux コンソールのエスケープシーケンスとコントロール
シーケンス
.SH 説明
Linux コンソールは VT102 と ECMA-48/ISO6429/ANSI X3.64 端末コンソールの
サブセットに、カラーパレットや文字集合のマッピングなどを変更する
プライベートモードシーケンスを加えて実装されている。
以下の表では、機能の ECMA-48 または DEC のニーモニクス(DECで始まれば後者)を
2 番目の桁に記す。
ニーモニクスのないものは ECMA-48 でも VT102 でもないものである。
.LP
すべての出力作業が終って、実際に印字するために文字のストリームが
コンソールドライバーに届いた時、最初に行なわれるのが、処理用コードから
印字用のコードへの変換である。
.LP
もし、コンソールが UTF-8 モードなら、入って来たバイト(byte)は
16 ビットの Unicode に組み立てられる。そうでなければ、それぞれの
バイトは現在の(各バイトを Unicode の値に変換する)マッピングテーブルに
従って変換される。これに関しては下のキャラクターセット(Charcter Sets)
節を参照のこと。
.LP
通常、Unicode の値はフォントインデックス(font index) に変換され、
ビデオメモリに蓄えられる。そして(ビデオ ROM 中に見付けられる)
対応するグリフ(glyph)が画面に現れる。
Unicode を用いると、(PC 互換機の設計では) 512 の異なった
グリフを同時に利用できるようになる。
.LP
現在の Unicode の値がコントロール文字であるかエスケープシーケンスを
処理している時には、その値は特別に扱われる。
フォントのインデックスに変換されてグリフとして表示される代わりに、カーソルの
移動やその他のコントロール機能を実行させる。
詳しいことは、後述の「LINUX コンソールコントロール」のセクションを参照のこと。
.LP
一般に端末コントロールコードをプログラム中に直接記述するのは
良いことではない。
Linuxでは、端末において実現可能な操作のデータベースである
.BR terminfo (5)
をサポートしている。
コンソールエスケープシーケンスをわざわざ入力するよりも、ほとんどの場合
terminfo の情報を参照する
.BR ncurses (3),
.BR tput (1),
や
.BR reset (1)
などのスクリーンライブラリやユーティリティーを使いたいと思うであろう。
.SS "Linux コンソールコントロール"
この章では Linux コンソールにおいて特殊な機能(つまり、現在のカーソル位置に
文字のイメージを印字する以外のこと)を起こさせる全てのコントロール文字と
エスケープシーケンスについて述べる。
.PP
.B "コントロール文字"
.sp
コントロール文字とは、(マッピングテーブルによる変換前のコードが)
00 (NUL), 07 (BEL), 08 (BS), 09 (HT), 0a (LF), 0b (VT),
0c (FF), 0d (CR), 0e (SO), 0f (SI), 18 (CAN), 1a (SUB),
1b (ESC), 7f (DEL) の 14 のコードのうちのどれかである文字である。
"コントロール文字表示(display control characters)"モード(後述)を
設定すると、07, 09, 0b, 18, 1a, 7f をグリフとして表示することができる。
一方、 UTF-8 モードでは、00-1f の全てのコードは、コントロール文字表示
モードが指定された場合でもコントロール文字として扱われる。
.PP
コントロール文字がある時には、それはすぐに(たとえエスケープシーケンスの
途中でも)実行され、破棄される。エスケープシーケンスは次の文字から続けられる
(しかし、ESC は新しいエスケープシーケンスを始めるので、
前の終了していないエスケープシーケンスが中止される可能性がある。
さらに、CAN と SUB はどんなエスケープシーケンスも中止する)。
認められているコントロール文字は、BEL, BS, HT, LF, VT, FF, CR, SO, SI,
CAN, SUB, ESC, DEL, CSI である。これらは期待どおりの動作をする:
.HP
.\"O BEL (0x07, \fB^G\fP) beeps;
BEL (0x07, \fB^G\fP) はビープ音を鳴らす;
.HP
.\"O BS (0x08, \fB^H\fP) backspaces one column
.\"O (but not past the beginning of the line);
BS (0x08, \fB^H\fP) はバックスペース
(ただし、行頭は越えない);
.HP
.\"O HT (0x09, \fB^I\fP) goes to the next tab stop or to the end of the line
.\"O if there is no earlier tab stop;
HT (0x09, \fB^I\fP) は次のタブストップ(tab stop)へ移動する、そこから行末までに
タブストップが無い場合は行の終りに移動する;
.HP
.\"O LF (0x0A, \fB^J\fP), VT (0x0B, \fB^K\fP) and
.\"O FF (0x0C, \fB^L\fP) all give a linefeed,
.\"O and if LF/NL (new-line mode) is set also a carriage return;
LF (0x0A, \fB^J\fP), VT (0x0B, \fB^K\fP), FF (0x0C, \fB^L\fP) これらは全て
ラインフィード(linefeed)を与える;
LF/NL (ニューラインモード(new line mode))がセットされていれば
キャリッジリターンもアクティブにする;
.HP
.\"O CR (0x0D, \fB^M\fP) gives a carriage return;
CR (0x0D, \fB^M\fP) はキャリッジリターンを与える;
.HP
.\"O SO (0x0E, \fB^N\fP) activates the G1 character set;
SO (0x0E, \fB^N\fP) は G1 文字集合をアクティブにする。
.HP
.\"O SI (0x0F, \fB^O\fP) activates the G0 character set;
SI (0x0F, \fB^O\fP) は G0 文字集合をアクティブにする;
.HP
.\"O CAN (0x18, \fB^X\fP) and SUB (0x1A, \fB^Z\fP) interrupt escape sequences;
CAN (0x18, \fB^X\fP) と SUB (0x1A, \fB^Z\fP) はエスケープシーケンスを中断する;
.HP
.\"O ESC (0x1B, \fB^[\fP) starts an escape sequence;
ESC (0x1B, \fB^[\fP) はエスケープシーケンスを始める。
.HP
DEL (0x7F) は無視される;
.HP
CSI (0x9B) は ESC [ と等価。
.PP
.B "エスケープシーケンスであるが CSI シーケンスでないもの"
.sp
.TS
l l l.
ESC c	RIS	リセット。
ESC D	IND	ラインフィード。
ESC E	NEL	ニューライン。
ESC H	HTS	現在の桁の位置にタブストップを設定する。
ESC M	RI	逆ラインフィード
.\"O ESC Z	DECID	T{
.\"O DEC private identification. The kernel
.\"O returns the string  ESC [ ? 6 c, claiming
.\"O that it is a VT102.
.\"O T}
ESC Z	DECID	T{
DEC固有の識別用。カーネルは文字列 ESC [ ? 6 c を返す。
これは端末がVT102であることを意味する。
T}
.\"O ESC 7	DECSC	T{
.\"O Save current state (cursor coordinates,
.\"O attributes, character sets pointed at by G0, G1).
.\"O T}
ESC 7	DECSC	T{
現在の状態(カーソルの座標、属性、G0, G1 で示している
文字集合)をセーブする。
T}
.\"O ESC 8	DECRC	Restore state most recently saved by ESC 7.
ESC 8	DECRC	最後に ESC 7 でセーブした状態を復帰させる。
ESC [	CSI	コントロールシーケンスを導入する。
ESC %		キャラクターセットを選択するシーケンスを開始する。
ESC % @		\0\0\0 デフォルト(ISO 646 / ISO 8859-1)を選択する。
ESC % G		\0\0\0 UTF-8 を選択する。
ESC % 8		\0\0\0 UTF-8 を選択する(旧式)。
ESC # 8	DECALN	DEC のスクリーン調整テスト \- スクリーンを E で
		うめる。
ESC (		G0 文字集合を定義するシーケンスを開始する。
ESC ( B		\0\0\0 デフォルト(ISO 8859-1 マッピング)を選択する。
.\"O ESC ( 0		\0\0\0Select VT100 graphics mapping
ESC ( 0		\0\0\0 VT100 グラフィクスマッピングを選択する。
ESC ( U		\0\0\0 ヌルマッピングを選択する \- キャラクタ ROM から
		\0\0\0 直接マッピングする。
ESC ( K		\0\0\0 ユーザー定義のマッピングを選択する \- そのマップ
		\0\0\0 は \fBmapscrn\fP(8) ユーティリティーによってロー
		\0\0\0 ドされる。
ESC )		G1 を定義するシーケンスを開始する。
		(すでに述べたように B, 0, U, K のどれかが次に続く)
ESC >	DECPNM	数値キーパッドモード(numeric keypad mode)を
		セットする。
ESC =	DECPAM	アプリケーションキーパッドモード(application keypad
		mode) をセットする。
.\"O ESC ]	OSC	T{
.\"O (Should be: Operating system command)
.\"O ESC ] P \fInrrggbb\fP: set palette, with parameter
.\"O given in 7 hexadecimal digits after the final P :-(.
.\"O Here \fIn\fP is the color (0-15), and \fIrrggbb\fP indicates
.\"O the red/green/blue values (0-255).
.\"O ESC ] R: reset palette
.\"O T}
ESC ]	OSC	T{
("Operating system command"のことだろう)
ESC ] P \fInrrggbb\fP: 最後の P のあとの 7 つの 16 進数を
パラメータとして :-( パレットをセットする。
ここで、\fIn\fPは色 (0-15)、\fIrrggbb\fPは赤/緑/青の値
(0-255)を意味する。
ESC ] R: パレットをリセットする。
T}
.TE
.PP
.B "ECMA-48 CSI シーケンス"
.sp
CSI (または ESC [ ) のあとに、最大で NPAR (16) 個のセミコロンで区切られた
10 進数のパラメータシーケンスが続く。
空であるかそこにないパラメータは 0 とされる。
パラメータシーケンスの前にはひとつのクエスチョンマークがつくことがある。
.PP
しかし、CSI [ (または ESC [ [ ) の後では、一文字が読まれ、このすべての
パラメータシーケンスが無視される(要するにファンクションキーのエコーは
無視されるということである)。
.PP
CSI シーケンスの動作は、その最後の文字によって決まる。
.TS
l l l.
@	ICH	指示された数の空白文字を挿入する。
A	CUU	指示された数だけカーソルを上方向に移動する。
B	CUD	カーソルを指示された数の行だけ下方向に移動する。
C	CUF	カーソルを指示された数の桁だけ右に移動する。
D	CUB	カーソルを指示された数の桁だけ左に移動する。
E	CNL	カーソルを指示された数の行だけ下の第 1 桁に移動する。
F	CPL	カーソルを指示された数の行だけ上の第 1 桁に移動する。
G	CHA	カーソルを現在の行の指示された桁に移動する。
H	CUP	カーソルを指示された行、桁(1,1を原点とする)に
		移動する。
J	ED	ディスプレイの消去(デフォルト: カーソルからディスプレイの
		最後まで)。
		ESC [ 1 J: 最初からカーソルまでの消去。
		ESC [ 2 J: ディスプレイ全体の消去。
K	EL	行の消去(デフォルト: カーソルから行末まで)。
		ESC [ 1 K: 行頭からカーソルまでの消去。
		ESC [ 2 K: 行全体の消去。
L	IL	指示された数の空行を挿入する。
M	DL	指示された数の行を削除する。
P	DCH	現在の行から指示された数の文字を削除する。
X	ECH	現在の行から指示された数の文字を消去する。
a	HPR	カーソルを指示された数の桁だけ右に移動する。
c	DA	ESC [ ? 6 c を返す: "私はVT102です"(ということ)。
d	VPA	カーソルを指示された行の現在の桁に移動する。
e	VPR	カーソルを指示された行数だけ下に移動する。
f	HVP	カーソルを指示された行、桁に移動する。
g	TBC	パラメータなしの時: 現在位置のタブストップを削除する。
		ESC [ 3 g: すべてのタブストップを削除する。
h	SM	モードのセット(後述)。
l	RM	モードのリセット(後述)。
m	SGR	属性のセット(後述)。
n	DSR	状態の報告(後述)。
q	DECLL	キーボードの LED をセットする。
		ESC [ 0 q: すべての LED を消す。
		ESC [ 1 q: スクロールロック LED を点灯。
		ESC [ 2 q: ナンバーロック LED を点灯。
		ESC [ 3 q: キャピタルロック LED を点灯。
r	DECSTBM	スクロールの範囲のセット; パラメータは一番上の行と
		一番下の行。
s	?	カーソル位置の保存。
u	?	カーソル位置の復帰。
\`	HPA	カーソルを現在の行の指示された桁に移動する。
.TE
.PP
.B "ECMA-48 グラフィクスレンディション(Graphics Rendition)の設定"
.sp
.\"O The ECMA-48 SGR sequence ESC [ \fIparameters\fP m sets display
.\"O attributes.
.\"O Several attributes can be set in the same sequence, separated by
.\"O semicolons.
.\"O An empty parameter (between semicolons or string initiator or
.\"O terminator) is interpreted as a zero.
ECMA-48 SGR シーケンス ESC [ <パラメータ> m は表示属性を設定する。
セミコロンで区切ることで、同じシーケンスでいくつかの属性を設定できる。
空パラメータ(セミコロンか文字列開始文字か文字列終端文字の間)はゼロと解釈される。
.TS
l l.
パラメータ	結果
0	すべての属性をデフォルトにリセットする。
1	ボールド(bold)をセット。
2	ハーフブライト(half-bright)(カラーディスプレイでは色で代用)を
	セット。
.\"O 4	T{
.\"O set underscore (simulated with color on a color display)
.\"O (the colors used to simulate dim or underline are set
.\"O using ESC ] ...)
.\"O T}
4	T{
下線(underscore)をセット(カラーディスプレイでは色で代用)。
(ディムや下線を代用するのに使われる色は ESC ] ... によりセット)
T}
5	点滅(blink)をセット。
7	反転表示(reverce video)をセット。
.\"O 10	T{
.\"O reset selected mapping, display control flag,
.\"O and toggle meta flag (ECMA-48 says "primary font").
.\"O T}
10	T{
選択したマッピング、ディスプレイコントロールフラグ(display
control flag)、トグルメタフラグ(toggle meta flag)をリセットする
(ECMA-48では"primary font"と呼んでいる)。
T}
.\"O 11	T{
.\"O select null mapping, set display control flag,
.\"O reset toggle meta flag (ECMA-48 says "first alternate font").
.\"O T}
11	T{
ヌルマッピングを選択、ディスプレイコントロールフラグをセット、
トグルメタフラグをリセットする
(ECMA-48 では"first alternate font"と呼んでいる)。
T}
.\"O 12	T{
.\"O select null mapping, set display control flag,
.\"O set toggle meta flag (ECMA-48 says "second alternate font").
.\"O The toggle meta flag
.\"O causes the high bit of a byte to be toggled
.\"O before the mapping table translation is done.
.\"O T}
12	T{
ヌルマッピングを選択、ディスプレイコントロールフラグ、
トグルメタフラグをセットする
(ECMA-48 では "second alternate font" と呼んでいる)。
トグルメタフラグがたっていると、
マッピングテーブルによる変換をする前に、バイトの上位の1ビットが
トグルされる。
T}
.\"O 21	set normal intensity (ECMA-48 says "doubly underlined")
21	通常の輝度にセット(ECMA-48 では "doubly underlined" と呼んでいる)。
22	通常の輝度にセット。
24	下線オフ。
25	点滅オフ。
27	反転表示オフ。
30	フォアグラウンド(foreground)を黒にセット。
31	フォアグラウンドを赤にセット。
32	フォアグラウンドを緑にセット。
33	フォアグラウンドを茶にセット。
34	フォアグラウンドを青にセット。
35	フォアグラウンドをマゼンダにセット。
36	フォアグラウンドをシアンにセット。
37	フォアグラウンドを白にセット。
38	下線表示に設定し、フォアグラウンドをデフォルトにセット。
39	下線表示を解除し、フォアグラウンドをデフォルトにセット。
40	バックグラウンド(background)を黒にセット。
41	バックグラウンドを赤にセット。
42	バックグラウンドを緑にセット。
43	バックグラウンドを茶にセット。
44	バックグラウンドを青にセット。
45	バックグラウンドをマゼンダにセット。
46	バックグラウンドをシアンにセット。
47	バックグラウンドを白にセット。
49	バックグラウンドをデフォルトにセット。
.TE
.PP
.B "ECMA-48 モードスイッチ(Mode Switches)"
.TP
ESC [ 3 h
DECCRM (デフォルトではオフ): コントロール文字を表示する。
.TP
ESC [ 4 h
DECIM (デフォルトではオフ): 挿入モードにする。
.TP
ESC [ 20 h
LF/NL (デフォルトではオフ): LF, VT, FFをエコーしたあと自動的 CR をつける。
.\"
.PP
.B "ECMA-48 状態リポートコマンド(Status Report Commands)"
.\"
.TP
ESC [ 5 n
デバイス状態のリポート(DSR): 返事は ESC [ 0 n (端末 OK).
.TP
ESC [ 6 n
カーソル位置のリポート(CPR): 返事は ESC [ \fIy\fP ; \fIx\fP R、
\fIx,y\fP はカーソルの位置をあらわす。
.\"
.PP
.B "DEC プライベートモード (DECSET/DECRST) シーケンス"
.sp
.\"
これらは ECMA-48 では記述されていない。ここでは、セットモード
シーケンス (Set Mode sequences)を記載する; 最後の \(aqh\(aq を \(aql\(aq に
置き換えるとリセットモードシーケンス(Reset Mode sequences)になる。
.TP
ESC [ ? 1 h
DECCKM (デフォルトはオフ): セットされた時にはカーソルキーは ESC [ ではなく
ESC O を前につけて送る。
.TP
ESC [ ? 3 h
DECCOLM (デフォルトはオフ = 80 桁): 80/132 の桁モード切替え。
ドライバーのソースの注釈には、これだけでは十分でなく
.BR resizecons (8)
のようなユーザーモードのユーティリティーで、コンソールビデオカードの
ハードウェアレジスタを変える必要があると書かれている。
.TP
ESC [ ? 5 h
DECSCNM (デフォルトはオフ): 反転表示モードのセット。
.TP
ESC [ ? 6 h
DECOM(デフォルトはオフ): セットされた時には、カーソルのアドレッシングが、
スクロール範囲の左上隅からの相対位置になる。
.TP
ESC [ ? 7 h
DECAWM(デフォルトはオン): オートラップを設定。このモードの時は、80 桁
(DECCOLM がオンのときは 132 桁)を超えたグラフィックキャラクタは、
強制的に次の行の先頭に折り返されて表示される。
.TP
ESC [ ? 8 h
DECARM(デフォルトはオン): キーボードのオートリピートをオンにセット。
.TP
ESC [ ? 9 h
X10 マウスリポート(デフォルトはオフ): リポートモードを 1 にセット(または、
0 にリセット) \(em 後述
.TP
ESC [ ? 25 h
.\"O DECTECM (default on): Make cursor visible.
DECTECM (デフォルトはオン): カーソルを可視(visible)にする。
.TP
ESC [ ? 1000 h
X11 マウスリポート(デフォルトはオフ): リポートモードを 2 にセット(または、
0にリセット) \(em 後述
.\"
.PP
.B "Linux コンソールプライベート CSI シーケンス"
.sp
.\"
以下のシーケンスは ECMA-48 のものでも本来の VT102 のものでもでもなく、
Linuxコンソールドライバーに固有なシーケンスである。色は SGR パラメータで
表現される: 0 = 黒, 1= 赤, 2 = 緑, 3 = 茶, 4 = 青, 5 = マゼンタ,
6 = シアン, 7 = 白
.TS
l l.
ESC [ 1 ; \fIn\fP ]	下線の色を\fIn\fP にセットする。
ESC [ 2 ; \fIn\fP ]	ディムの色を\fIn\fP にセットする。
ESC [ 8 ]       	現在の色のペアをデフォルト属性にする。
ESC [ 9 ; \fIn\fP ]	スクリーンブランク(screen blank)のタイムアウト
	を \fIn\fP 分にセットする。
ESC [ 10 ; \fIn\fP ]	ベルの周波数(Hz)をセットする。
ESC [ 11 ; \fIn\fP ]	ベルの鳴っている時間(msec)をセットする。
ESC [ 12 ; \fIn\fP ]	指定のコンソールを前面に持ってくる。
ESC [ 13 ]      	スクリーンをアンブランク(Unblank)する。
ESC [ 14 ]      	VESA電源停止インターバル(VESA powerdown
	interval)をセットする。
.TE
.SS 文字集合
.\"O The kernel knows about 4 translations of bytes into console-screen
.\"O symbols.
.\"O The four tables are: a) Latin1 \-> PC,
.\"O b) VT100 graphics \-> PC, c) PC \-> PC, d) user-defined.
カーネルは、バイト列からコンソールスクリーン符号の変換を 4 つ
知っている。
4 つの変換テーブルとは、a) Latin1 \-> PC,  b) VT100 graphics \-> PC,
c) PC \-> PC, d) ユーザー定義, である。
.PP
.\"O There are two character sets, called G0 and G1, and one of them
.\"O is the current character set.
.\"O (Initially G0.)
.\"O Typing \fB^N\fP causes G1 to become current,
.\"O \fB^O\fP causes G0 to become current.
G0 と G1 と呼ばれる二つの文字集合があり、そのうち一つが現在の
文字集合である(初期値は G0 )。
\fB^N\fP をタイプすると G1 が \fB^O\fP を入力すると G0 が現在の文字集合になる。
.PP
.\"O These variables G0 and G1 point at a translation table, and can be
.\"O changed by the user.
.\"O Initially they point at tables a) and b), respectively.
.\"O The sequences ESC ( B and ESC ( 0 and ESC ( U and ESC ( K cause G0 to
.\"O point at translation table a), b), c) and d), respectively.
.\"O The sequences ESC ) B and ESC ) 0 and ESC ) U and ESC ) K cause G1 to
.\"O point at translation table a), b), c) and d), respectively.
変数 G0 と G1 は変換テーブルを指しており、ユーザーにより変更できる。
最初はそれぞれテーブル a) と テーブル b) を指している。
ESC ( B 、 ESC ( 0 、 ESC ( U 、 ESC ( K のそれぞれのシーケンスにより、
G0 が変換テーブル a)、 b)、 c)、 d) を指すようになる。
また、ESC ) B 、 ESC ) 0 、 ESC ) U 、 ESC ) K のそれぞれのシーケンス
により、G1 が変換テーブル  a)、 b)、 c)、 d) を指すようになる。
.PP
ESC c のシーケンスは端末をリセットする。スクリーンがめちゃくちゃになった
時にそうすることが必要である。よくアドバイスされる "echo ^V^O" は G0
を現在の文字集合にするだけであり、G0 がテーブル a) を指しているという
保証はない。
いくつかのディストリビューションには、
.BR reset (1)
というプログラムが含まれるが、これはただ "echo ^[c" を実行するものである。
.\"O If your terminfo entry for the console is correct
.\"O (and has an entry rs1=\\Ec), then "tput reset" will also work.
もし、コンソールの terminfo エントリーが正しい(かつ rs1=\\Ec のエントリーが
ある)ならば、"tput reset"でも同じ効果がある。
.PP
ユーザー定義のマッピングテーブルは
.BR mapscrn (8)
を使って定義できる。
マッピングの結果、シンボル c が印字されるとシンボル s = map[c] が
ビデオメモリに送られる。s に対応するビットマップはキャラクター ROM にあり、
.BR setfont (8)
により変更可能である。
.SS マウストラッキング
.\"O The mouse tracking facility is intended to return
.\"O .BR xterm (1)-compatible
.\"O mouse status reports.
.\"O Because the console driver has no way to know
.\"O the device or type of the mouse, these reports are returned in the
.\"O console input stream only when the virtual terminal driver receives
.\"O a mouse update ioctl.
.\"O These ioctls must be generated by a mouse-aware
.\"O user-mode application such as the
.\"O .BR gpm (8)
.\"O daemon.
マウストラッキング機能は、
.BR xterm (1)-互換の
マウスステータスリポート(mouse
status reports)を返させるためのものである。
コンソールドライバーはマウスのデバイスや種類について知る方法が
ないので、仮想ターミナルドライバーがマウス更新の ioctl を受け取った時だけ、
マウスステータスリポートがコンソールの入力ストリームに送られる。
この ioctl は、
.BR gpm (8)
デーモンのようなマウス対応のユーザーモード
アプリケーションが発生しなければならない。
.PP
.\"O The mouse tracking escape sequences generated by
.\"O \fBxterm\fP(1) encode numeric parameters in a single character as
.\"O \fIvalue\fP+040.
.\"O For example, \(aq!\(aq is 1.
.\"O The screen coordinate system is 1-based.
\fBxterm\fP(1) によって生成される全てのマウス追跡エスケープシーケンスのための
パラメータは、数値を \fIvalue\fP+040 のように符号化し、一つの文字として
あらわす。
例えば、\(aq!\(aq は 1 になる。スクリーン座標は 1 をベースにする。
.PP
X10 互換モードでは、ボタンが押された時にマウスの位置と押されたマウスの
ボタンとをエンコードしたエスケープシーケンスを送る。
この機能は ESC [ ? 9 h を送ると有効になり ESC [ ? 9 l により無効になる。
ボタンが押されると \fBxterm\fP(1) は ESC [ M \fIbxy\fP (の 6 文字)を送る。
ここで \fIb\fP は button\-1, \fIx\fP と \fIy\fP は マウスがボタンが押された
時の x と y 座標である。
このコードはカーネルが発生するのと同じコードである。
.PP
ノーマルトラッキングモード(Normal tracking mode)(Linux 2.0.24 では
実装されていない)では、両方のボタンが押されたか離された時に
エスケープシーケンスが送られる。
モディファイアの情報も一緒に送られる。
この機能は、ESC [ ? 1000 h を送ると有効になり ESC [ ? 1000 l で無効になる。
ボタンが押されるか離されるかした時には、\fBxterm\fP(1) は ESC [ M
\fIbxy\fP を送る。
\fIb\fP の低位の2ビットにはボタン情報がエンコードされる:
0=MB1 が押された, 1=MB2 が押された, 2=MB3 が押された, 3=離された。
高位のビットには、ボタンが押された時にどのモディファイアがダウンしていたかが
エンコードされる: 4=Shift, 8=Meta, 16=Control。
そして、上位と下位ビットが加算される。
ここでも \fIx\fP と \fIy\fP は、マウスイベントが起こった時の
x と y 座標であり、左上の隅が(1,1)である。
.SS 他のターミナルとの比較
.\"O Many different terminal types are described, like the Linux console,
.\"O as being "VT100-compatible".
.\"O Here we discuss differences between the
.\"O Linux console and the two most important others, the DEC VT102 and
.\"O .BR xterm (1).
多くの異なるターミナルタイプが、Linux コンソールのように、"VT100互換"を
名乗っている。
ここでは、Linux コンソールと 2 つの最も重要なターミナルである
DEC VT102 と
.BR xterm (1)
との違いについて述べる。
.\"
.PP
.B コントロール文字の取り扱い
.sp
VT102 は以下のコントロール文字も認識する:
.HP
NUL (0x00) は無視される;
.HP
ENQ (0x05) はアンサーバックメッセージ(answerback message)を発生する;
.HP
.\"O DC1 (0x11, \fB^Q\fP, XON) resumed transmission;
DC1 (0x11, \fB^Q\fP, XON) は送信を再開する;
.HP
.\"O DC3 (0x13, \fB^S\fP, XOFF) caused VT100 to ignore (and stop transmitting)
.\"O all codes except XOFF and XON.
DC3 (0x13, \fB^S\fP, XOFF) は VT100 に XOFF と XON 以外のコードを無視(そして
送信の停止)を起こさせる。
.LP
tty ドライバーにより VT100 に似た DC1/DC3 処理をできる。
.LP
.BR xterm (1)
(VT100 モード)は BEL, BS, HT, LF, VT, FF, CR, SO, SI, ESC の
コントロール文字を認識する。
.\"
.PP
.B エスケープシーケンス
.sp
Linux コンソールで実装されていない VT100 コンソールシーケンスは以下の通り:
.TS
l l l.
ESC N	SS2	シングルシフト 2
		(次の文字だけ G2 文字集合を選択する)。
ESC O	SS3	シングルシフト 3
		(次の文字だけ G3 文字集合を選択する)。
ESC P	DCS	デバイス制御文字列 (ESC \\ で終わる)
ESC X	SOS	文字列の始まり。
ESC ^	PM	プライバシーメッセージ(ESC \\ で終わる)。
ESC \\	ST	文字列の終端文字。
ESC * ...		G2 文字集合を指定する。
ESC + ...		G3 文字集合を指定する。
.TE
.PP
.BR xterm (1)
(VT100 モード)は ESC c, ESC # 8, ESC >, ESC =,
ESC D, ESC E, ESC H, ESC M, ESC N, ESC O, ESC P ... ESC \\,
ESC Z を認識する("わたしは高等ビデオオプション付きの VT100 です"という
意味で ESC [ ? 1 ; 2 c と返答する)、ESC ^ ... ESC \\ は上述と同じ意味を
あらわす。ESC (, ESC ), ESC *, ESC + に続く 0, A, B を DEC 特殊文字と
して受け、それぞれラインドローイング(line drawing) のセット、UK、
US-ASCII をあらわす。
.PP
.\"O The user can configure \fBxterm\fP(1) to respond to VT220-specific
.\"O control sequences, and it will identify itself as a VT52, VT100, and
.\"O up depending on the way it is configured and initialized.
ユーザーは \fBxterm\fP(1) が VT220 特有のコントロールシーケンスに
反応するように設定でき、また設定と初期化のされかたによって
自分自身を VT52, VT100 などと認識する。
.PP
.\"O It accepts ESC ] (OSC) for the setting of certain resources.
.\"O In addition to the ECMA-48 string terminator (ST),
.\"O \fBxterm\fP(1) accepts a BEL to terminate an OSC string.
.\"O These are a few of the OSC control sequences recognized by \fBxterm\fP(1):
xterm は、特定のリソースの設定のために ESC ] (OSC) を受け付ける。
ECMA-48 の文字列終端文字 (ST) に加えて、
\fBxterm\fP(1) は BEL を OSC 文字列を終端するものとして受け付ける。
以下は \fBxterm\fP(1) が認識する OSC コントロールシーケンスの一部である。
.TS
l l.
.\"O ESC ] 0 ; \fItxt\fP ST	Set icon name and window title to \fItxt\fP.
.\"O ESC ] 1 ; \fItxt\fP ST	Set icon name to \fItxt\fP.
.\"O ESC ] 2 ; \fItxt\fP ST	Set window title to \fItxt\fP.
.\"O ESC ] 4 ; \fInum\fP; \fItxt\fP ST	Set ANSI color \fInum\fP to \fItxt\fP.
.\"O ESC ] 10 ; \fItxt\fP ST	Set dynamic text color to \fItxt\fP.
.\"O ESC ] 4 6 ; \fIname\fP ST	Change log file to \fIname\fP (normally disabled
.\"O 	by a compile-time option)
.\"O ESC ] 5 0 ; \fIfn\fP ST	Set font to \fIfn\fP.
ESC ] 0 ; \fItxt\fP ST	アイコン名とウインドウタイトルを \fItxt\fP に
	セットする。
ESC ] 1 ; \fItxt\fP ST	アイコン名を \fItxt\fP にセットする。
ESC ] 2 ; \fItxt\fP ST	ウインドウタイトルを \fItxt\fP にセットする。
ESC ] 4 ; \fInum\fP; \fItxt\fP ST	ANSI 色 \fInum\fP を \fItxt\fP にセットする。
ESC ] 10 ; \fI\fItxt\fP\fP ST	動的テキスト色を \fItxt\fP にセットする。
ESC ] 4 6 ; \fIname\fP ST	チェンジログファイルを \fIname\fP に変更する(通常は
	コンパイル時オプションにより無効になっている)。
ESC ] 5 0 ; \fIfn\fP ST	フォントを \fIfn\fP にセットする。
.TE
.PP
.\"O It recognizes the following with slightly modified meaning
.\"O (saving more state, behaving closer to VT100/VT220):
以下のものは、少し違った意味にとられる
(より多くの状態を保存し、より VT100/VT220 に近いふるまいをする):
.LP
.TS
l l l.
ESC 7  DECSC	カーソルの保存。
ESC 8  DECRC	カーソルの復元。
.TE
.PP
また、次のものも認識する:
.TS
l l l.
ESC F		カーソルをスクリーンの左下に移動する。
		(\fBxterm\fP(1) の \fBhpLowerleftBugCompat\fPリソースにより有効な時)
ESC l		(HP ターミナル毎に)メモリロック。
		カーソルより上のメモリをロックする。
ESC m		(HP ターミナル毎に)メモリロックを解除する。
ESC n	LS2	G2 文字集合の呼び出し。
ESC o	LS3	G3 文字集合の呼び出し。
ESC |	LS3R	G3 文字集合を GR として呼び出す。
ESC }	LS2R	G2 文字集合を GR として呼び出す。
ESC ~	LS1R	G1 文字集合を GR として呼び出す。
.TE
.PP
.\"O It also recognizes ESC % and provides a more complete UTF-8
.\"O implementation than Linux console.
また ESC % を認識し、Linux コンソールより更に完全な UTF-8 実装を提供する。
.\"
.PP
.B "CSI シーケンス"
.sp
.\"O Old versions of \fBxterm\fP(1), for example, from X11R5,
.\"O interpret the blink SGR as a bold SGR.
X11R5 由来のような、古いバージョンの \fBxterm\fP(1) はブリンク SGR を
ボールド SGR として解釈する。
.\"O Later versions which implemented ANSI colors, for example,
.\"O XFree86 3.1.2A in 1995, improved this by allowing
.\"O the blink attribute to be displayed as a color.
1995 年の XFree86 3.1.2A のような、ANSI カラーが実装された、より新しい
バージョンでは、ブリンク属性を色として表示することによってこれを
改善している。
.\"O Modern versions of xterm implement blink SGR as blinking text
.\"O and still allow colored text as an alternate rendering of SGRs.
.\"O Stock X11R6 versions did not recognize the color-setting SGRs until
.\"O the X11R6.8 release, which incorporated XFree86 xterm.
最近のバージョンの xterm はブリンク SGR をテキストをブリンクさせることで
実装し、さらにまた、SGR 表示の代替案として色付きのテキストも利用できる。
Stock X11R6 版では、XFree86 xterm が組み入れられた X11R6.8 リリースまで
色設定 SGR を認識しなかった。
.\"O All ECMA-48 CSI sequences recognized by Linux are also recognized by
.\"O .IR xterm ,
.\"O however \fBxterm\fP(1) implements several ECMA-48 and DEC control sequences
.\"O not recognized by Linux.
Linux が認識する他のすべての ECMA-48 CSI シーケンスは
.I xterm
でも認識されるが、\fBxterm\fP(1) は Linux が認識しない
いくつかの ECMA-48 と DEC のコントロールシーケンスも実装している。
.PP
.\"O The \fBxterm\fP(1)
.\"O program recognizes all of the DEC Private Mode sequences listed
.\"O above, but none of the Linux private-mode sequences.
\fBxterm\fP(1) は上述のすべての DEC プライベートモードのシーケンスを認識するが、
Linux プライベートモードのシーケンスはどれも認識しない。
.\"O For discussion of \fBxterm\fP(1)'s
.\"O own private-mode sequences, refer to the
.\"O \fIXterm Control Sequences\fP
.\"O document by
.\"O Edward Moy,
.\"O Stephen Gildea,
.\"O and Thomas E. Dickey
.\"O available with the X distribution.
\fBxterm\fP(1) 自身のプライベートモードシーケンスに関しての議論は、
X 配布とともに入手可能な Edward Moy, Stephen Gildea,Thomas E. Dickey による
\fIXterm Control Sequences\fP
ドキュメントを参照されたい。
.\"O That document, though terse, is much longer than this manual page.
.\"O For a chronological overview,
このドキュメントは、簡潔なものであるが、このマニュアルページより
遥かに長いものである。
年代順の概観としては、
.PP
.in +4n
http://invisible-island.net/xterm/xterm.log.html
.in
.PP
.\"O details changes to xterm.
には xterm の変更の詳細がある。
.PP
.\"O The \fIvttest\fP program
\fIvttest\fP は
.PP
.in +4n
http://invisible-island.net/vttest/
.in
.PP
.\"O demonstrates many of these control sequences.
で入手でき、これらのコントロールシーケンスの多くに関するデモを行う。
.\"O The \fBxterm\fP(1) source distribution also contains sample
.\"O scripts which exercise other features.
\fBxterm\fP(1) ソース配布パッケージには
その他の機能を学ぶことが出来るサンプルスクリプトが入っている。
.\"O .SH NOTES
.SH 注意
.\"O ESC 8 (DECRC) is not able to restore the character set changed with
.\"O ESC %.
ESC 8 (DECRC) は ESC % で変更された文字集合を復元することはできない。
.SH バグ
.\"O In 2.0.23, CSI is broken, and NUL is not ignored inside
.\"O escape sequences.
2.0.23 では CSI が壊れていて、エスケープシーケンス中の NUL が
無視されない。
.PP
.\"O Some older kernel versions (after 2.0) interpret 8-bit control
.\"O sequences.
.\"O These "C1 controls" use codes between 128 and 159 to replace
.\"O ESC [, ESC ] and similar two-byte control sequence initiators.
.\"O There are fragments of that in modern kernels (either overlooked or
.\"O broken by changes to support UTF-8),
.\"O but the implementation is incomplete and should be regarded
.\"O as unreliable.
古いバージョン(2.0 以降)のカーネルには、8 ビット制御シーケンスを解釈する。
これらの "C1 コントロール" は ESC [, ESC ] および同様な制御シーケンス
起動子を置き換えるために 128 から 159 のコードを使う。
新しいカーネルでは (UTF-8 対応の変更時に見落とされたか壊れたために)
寸断しているが、実装は不完全で信頼できないものと評価されている。
.PP
.\"O Linux "private mode" sequences do not follow the rules in ECMA-48
.\"O for private mode control sequences.
.\"O In particular, those ending with ] do not use a standard terminating
.\"O character.
Linux "プライベートモード" シーケンスは ECMA-48 のプライベートモード
コントロールシーケンスのルールに従っていない。
特に、 ] で終わるものは標準終端文字を使えない。
.\"O The OSC (set palette) sequence is a greater problem,
.\"O since \fBxterm\fP(1) may interpret this as a control sequence
.\"O which requires a string terminator (ST).
OSC(パレット設定)シーケンスは大きな問題がある。
\fBxterm\fP(1) はこれを文字列終端文字 (ST) が必要なコントロールシーケンスと
解釈するかもしれないからである。
.\"O Unlike the \fBsetterm\fP(1) sequences which will be ignored (since
.\"O they are invalid control sequences), the palette sequence will make
.\"O \fBxterm\fP(1) appear to hang (though pressing the return-key
.\"O will fix that).
(不正なコントロールシーケンスなので)無視される \fBsetterm\fP(1) シーケンスと
違い、パレットシーケンスは \fBxterm\fP(1) をハングさせるかもしれない
(しかしリターンキーを押すことで回復できる)。
.\"O To accommodate applications which have been hardcoded to use Linux
.\"O control sequences,
.\"O set the \fBxterm\fP(1) resource \fBbrokenLinuxOSC\fP to true.
Linux コントロールシーケンスをハードコードしているアプリケーションに
適応させるには、\fBxterm\fP(1) リソースの \fBbrokenLinuxOSC\fP を
真 (true) に設定する。
.PP
.\"O An older version of this document implied that Linux recognizes the
.\"O ECMA-48 control sequence for invisible text.
.\"O It is ignored.
このドキュメントの古いバージョンでは、Linux が ECMA-48 の不可視テキストの
コントロールシーケンスを認識するかのように書かれていた。
これは無視される。
.SH 関連項目
.BR console (4),
.BR console_ioctl (4),
.BR charsets (7)

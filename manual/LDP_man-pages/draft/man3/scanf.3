.\" Copyright (c) 1990, 1991 The Regents of the University of California.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"	This product includes software developed by the University of
.\"	California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)scanf.3	6.14 (Berkeley) 1/8/93
.\"
.\" Converted for Linux, Mon Nov 29 15:22:01 1993, faith@cs.unc.edu
.\" modified to resemble the GNU libio setup used in the Linux libc
.\" used in versions 4.x (x>4) and 5   Helmut.Geyer@iwr.uni-heidelberg.de
.\" Modified, aeb, 970121
.\" 2005-07-14, mtk, added description of %n$ form; various text
.\"	incorporated from the GNU C library documentation ((C) The
.\"	Free Software Foundation); other parts substantially rewritten.
.\"
.\" 2008-06-23, mtk
.\"     Add ERRORS section.
.\"     Document the 'a' and 'm' modifiers for dynamic string allocation.
.\"
.\" Japanese Version Copyright (c) 1997 YOSHINO Takashi
.\"       all rights reserved.
.\" Translated 1998-02-17, YOSHINO Takashi <yoshino@civil.jcn.nihon-u.ac.jp>
.\" Updated 2003-02-23, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-09-18, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2008-08-11, Akihiro MOTOKI, LDP v3.05
.\"
.\"WORD:	conversion specifications	変換指定
.\"WORD:	type modifier			型修飾子
.\"
.TH SCANF 3  2011-09-28 "GNU" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf \- input format conversion
scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf \- 書式付き入力変換
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <stdio.h>

.BI "int scanf(const char *" format ", ...);"
.BI "int fscanf(FILE *" stream ", const char *" format ", ...);"
.BI "int sscanf(const char *" str ", const char *" format ", ...);"
.sp
.B #include <stdarg.h>

.BI "int vscanf(const char *" format ", va_list " ap );
.BI "int vsscanf(const char *" str ", const char *" format ", va_list " ap );
.BI "int vfscanf(FILE *" stream ", const char *" format ", va_list " ap );
.fi
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.ad l
.sp
.BR vscanf (),
.BR vsscanf (),
.BR vfscanf ():
.RS 4
_XOPEN_SOURCE\ >=\ 600 || _ISOC99_SOURCE ||
_POSIX_C_SOURCE\ >=\ 200112L;
.br
or
.I "cc -std=c99"
.ad
.RE
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR scanf ()
.\"O family of functions scans input according to
.\"O .I format
.\"O as described below.
.\"O This format may contain
.\"O .IR "conversion specifications" ;
.\"O the results from such conversions, if any,
.\"O are stored in the locations pointed to by the
.\"O .I pointer
.\"O arguments that follow
.\"O .IR format .
.\"O Each
.\"O .I pointer
.\"O argument must be of a type that is appropriate for the value returned
.\"O by the corresponding conversion specification.
.BR scanf ()
関数グループは、以下に述べるように、
.I format
に従って入力を読み込むものである。
この書式には
.I "「変換指定」 (conversion specifications)"
を含めることができ、変換指定があれば、その変換の結果は
.I format
に続く
.I pointer
引き数が指す場所に格納される。
それぞれの
.I pointer
引き数の型は、対応する変換指定が返す値に
適合していなければならない。

.\"O If the number of conversion specifications in
.\"O .I format
.\"O exceeds the number of
.\"O .I pointer
.\"O arguments, the results are undefined.
.\"O If the number of
.\"O .I pointer
.\"O arguments exceeds the number of conversion specifications, then the excess
.\"O .I pointer
.\"O arguments are evaluated, but are otherwise ignored.
.I format
中の変換指定の個数が
.I pointer
引き数の数より多かった場合の結果は未定義である。
.I pointer
引き数の数が変換指定の個数よりも多かった場合、
余分な
.I pointer
引き数の評価は行われるが、それ以外は行われず無視される。

.\"O The
.\"O .BR scanf ()
.\"O function reads input from the standard input stream
.\"O .IR stdin ,
.\"O .BR fscanf ()
.\"O reads input from the stream pointer
.\"O .IR stream ,
.\"O and
.\"O .BR sscanf ()
.\"O reads its input from the character string pointed to by
.\"O .IR str .
.BR scanf ()
関数は標準入力ストリーム
.I stdin
からの入力を読み込む。
.BR fscanf ()
はストリームポインタ
.I stream
からの入力を読み込む。
.BR sscanf ()
は文字列ポインタ
.I str
で示された文字列からの入力を読み込む。
.PP
.\"O The
.\"O .BR vfscanf ()
.\"O function is analogous to
.\"O .BR vfprintf (3)
.\"O and reads input from the stream pointer
.\"O .I stream
.\"O using a variable argument list of pointers (see
.\"O .BR stdarg (3).
.BR vfscanf ()
関数は
.BR vfprintf (3)
と同様に、ストリームポインタ
.I stream
からの入力をポインタの可変長引き数リストを用いて読み込む
.RB ( stdarg (3)
を参照)。
.\"O The
.\"O .BR vscanf ()
.\"O function scans a variable argument list from the standard input and the
.\"O .BR vsscanf ()
.\"O function scans it from a string; these are analogous to the
.\"O .BR vprintf (3)
.\"O and
.\"O .BR vsprintf (3)
.\"O functions respectively.
.BR vscanf ()
関数は、可変長引き数のリストに基づき標準入力からの読み取りを行う。
.BR vsscanf ()
関数はそのリストに基づき文字列から読み取る。
これらの関係は
.BR vprintf (3)
と
.BR vsprintf (3)
関数の関係と同様である。
.PP
.\"O The
.\"O .I format
.\"O string consists of a sequence of
.\"O .I directives
.\"O which describe how to process the sequence of input characters.
.\"O If processing of a directive fails, no further input is read, and
.\"O .BR scanf ()
.\"O returns.
.\"O A "failure" can be either of the following:
.\"O .IR "input failure" ,
.\"O meaning that input characters were unavailable, or
.\"O .IR "matching failure" ,
.\"O meaning that the input was inappropriate (see below).
.I format
文字列は
.I "「命令」 (directive)"
の列で構成される。命令は入力文字の系列をどのように処理するかを指示する
ものである。ある命令の処理が失敗すると、入力はそれ以上読み込まれず、
.BR scanf ()
は返る。「失敗」は
.I "「入力の失敗」 (input failure)"
と
.I "「一致の失敗」 (matching failure)"
のいずれかである。
入力の失敗は入力文字が使用できなかったことを意味し、
一致の失敗は入力が不適切であったこと (下記参照) を意味する。

.\"O A directive is one of the following:
命令は以下のいずれかである:
.TP
\(bu
.\"O A sequence of white-space characters (space, tab, newline, etc.; see
.\"O .BR isspace (3)).
.\"O This directive matches any amount of white space,
.\"O including none, in the input.
ホワイトスペース (スペース、タブ、改行など;
.BR isspace (3)
参照) の列。
この命令は、入力中の任意の個数のホワイトスペースに一致する。
(「何もなし」にも一致する)。
.TP
\(bu
.\"O An ordinary character (i.e., one other than white space or \(aq%\(aq).
.\"O This character must exactly match the next character of input.
通常文字 (つまり、ホワイトスペースと \(aq%\(aq 以外の文字)。
この文字は入力の次の文字に正確に一致しなければならない。
.TP
\(bu
.\"O A conversion specification,
.\"O which commences with a \(aq%\(aq (percent) character.
.\"O A sequence of characters from the input is converted according to
.\"O this specification, and the result is placed in the corresponding
.\"O .I pointer
.\"O argument.
.\"O If the next item of input does not match the conversion specification,
.\"O the conversion fails\(emthis is a
.\"O .IR "matching failure" .
変換指定。変換指定は \(aq%\(aq (パーセント) 文字で始まる。
入力された文字の系列はこの指定にもとづいて変換され、
変換結果は対応する
.I pointer
引き数が指す場所に格納される。
入力の次の文字が変換指定と一致しない場合は、変換は失敗する
\(emこれが
.I "「一致の失敗」 (matching failure)"
である。
.PP
.\"O Each
.\"O .I conversion specification
.\"O in
.\"O .I format
.\"O begins with either the character \(aq%\(aq or the character sequence
.\"O "\fB%\fP\fIn\fP\fB$\fP"
.\"O (see below for the distinction) followed by:
.I format
中の各々の
.I "「変換指定」"
は文字 \(aq%\(aq か文字系列 "\fB%\fP\fIn\fP\fB$\fP"
(違いについては後述) で始まり、以下の要素が続く。
.TP
\(bu
.\"O An optional \(aq*\(aq assignment-suppression character:
.\"O .BR scanf ()
.\"O reads input as directed by the conversion specification,
.\"O but discards the input.
.\"O No corresponding
.\"O .I pointer
.\"O argument is required, and this specification is not
.\"O included in the count of successful assignments returned by
.\"O .BR scanf ().
代入抑制文字 \(aq*\(aq (省略可能)。
.BR scanf ()
は変換指定に指示された通り入力を読み込むが、その入力は捨てられる。
対応する
.I pointer
引き数は必要なく、
.BR scanf ()
が返す代入が成功した数にこの指定は含まれない。
.TP
\(bu
.\"O An optional \(aqa\(aq character.
.\"O This is used with string conversions, and relieves the caller of the
.\"O need to allocate a corresponding buffer to hold the input: instead,
.\"O .BR scanf ()
.\"O allocates a buffer of sufficient size,
.\"O and assigns the address of this buffer to the corresponding
.\"O .I pointer
.\"O argument, which should be a pointer to a
.\"O .I "char *"
.\"O variable (this variable does not need to be initialized before the call).
.\"O The caller should subsequently
.\"O .BR free (3)
.\"O this buffer when it is no longer required.
.\"O This is a GNU extension;
.\"O C99 employs the \(aqa\(aq character as a conversion specifier (and
.\"O it can also be used as such in the GNU implementation).
文字 \(aqa\(aq (省略可能)。これは文字列変換とともに使用され、これを使うと
呼び出し元が入力を保持する対応するバッファを確保する必要がなくなる。
代わりに
.BR scanf ()
が必要な大きさのバッファを確保し、このバッファのアドレスを
対応する
.I pointer
引き数に代入する。
.I pointer
引き数は
.I "char *"
型の変数へのポインタでなければならない
(変数自体は呼び出し前に初期化されている必要はない)。
呼び出し元は、不要になった時点で、このバッファを
.BR free (3)
すべきである。この機能は GNU による拡張である。
C99 は \(aqa\(aq 文字を変換指定として使用している
(こちらも GNU の実装と同じように使用することができる)。
.TP
\(bu
.\"O An optional decimal integer which specifies the
.\"O .IR "maximum field width" .
.\"O Reading of characters stops either when this maximum is reached or
.\"O when a nonmatching character is found, whichever happens first.
.\"O Most conversions discard initial white space characters (the exceptions
.\"O are noted below),
.\"O and these discarded characters don't count toward the maximum field width.
.\"O String input conversions store a terminating null byte (\(aq\\0\(aq)
.\"O to mark the end of the input;
.\"O the maximum field width does not include this terminator.
.I "「最大フィールド幅」"
を指定する 10進数 (省略可能)。
この最大値に達するか、一致しない文字が見つかるか、のどちらかに
なると、文字の読み込みを停止する。
ほとんどの変換では、先頭のホワイトスペース文字は捨てられ
(例外については後述する)、
捨てられたこれらの文字は最大フィールド幅の計算には含まれない。
文字列の入力変換では、入力の末尾を示す終端の NULL バイト (\(aq\\0\(aq)
も格納されるが、最大フィールド幅にはこの終端バイトは含まれない。
.TP
\(bu
.\"O An optional
.\"O .IR "type modifier character" .
.\"O For example, the
.\"O .B l
.\"O type modifier is used with integer conversions such as
.\"O .B %d
.\"O to specify that the corresponding
.\"O .I pointer
.\"O argument refers to a
.\"O .I "long int"
.\"O rather than a pointer to an
.\"O .IR int .
.I "「型修飾子」 (type modifier characters)"
(省略可能)。
例えば、型修飾子
.B l
を
.B %d
などの整数変換と一緒に使うと、対応する
.I pointer
引き数が
.I int
ではなく
.I "long int"
を参照していることを指定できる。
.TP
\(bu
.\"O A
.\"O .I "conversion specifier"
.\"O that specifies the type of input conversion to be performed.
.I "「変換指定」"
: 実行すべき入力変換の種類を指定する。
.PP
.\"O The conversion specifications in
.\"O .I format
.\"O are of two forms, either beginning with \(aq%\(aq or beginning with
.\"O "\fB%\fP\fIn\fP\fB$\fP".
.\"O The two forms should not be mixed in the same
.\"O .I format
.\"O string, except that a string containing
.\"O "\fB%\fP\fIn\fP\fB$\fP"
.\"O specifications can include
.\"O .B %%
.\"O and
.\"O .BR %* .
.I format
中の変換指定は、\(aq%\(aq で始まるか、
"\fB%\fP\fIn\fP\fB$\fP" で始まるかの、いずれかの形式である。
これら 2つの形式を同じ
.I format
文字列に混ぜることはできない。但し、"\fB%\fP\fIn\fP\fB$\fP" を
含む文字列に
.B %%
と
.B %*
を含めることはできる。
.\"O If
.\"O .I format
.\"O contains \(aq%\(aq
.\"O specifications then these correspond in order with successive
.\"O .I pointer
.\"O arguments.
.I format
に \(aq%\(aq 指定が含まれている場合、各々の \(aq%\(aq 指定と
後続の
.I pointer
引き数はその順番通りに対応する。
.\"O In the
.\"O "\fB%\fP\fIn\fP\fB$\fP"
.\"O form (which is specified in POSIX.1-2001, but not C99),
.\"O .I n
.\"O is a decimal integer that specifies that the converted input should
.\"O be placed in the location referred to by the
.\"O .IR n -th
.\"O .I pointer
.\"O argument following
.\"O .IR format .
"\fB%\fP\fIn\fP\fB$\fP" 形式
(POSIX.1-2001 では規定されているが、C99 にはない)
では、
.I n
は 10進数であり、変換後の入力を
.I format
の後ろの
.I n
番目の
.I pointer
引き数が参照する場所に格納することを指定する。
.\"O .SS Conversions
.SS 変換
.\"O The following
.\"O .I "type modifier characters"
.\"O can appear in a conversion specification:
変換指定には、以下の
.I "「型修飾子」"
を入れることができる。
.TP
.B h
.\"O Indicates that the conversion will be one of
.\"O \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP, or \fBn\fP
.\"O and the next pointer is a pointer to a
.\"O .I short int
.\"O or
.\"O .I unsigned short int
.\"O (rather than
.\"O .IR int ).
変換が
\fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP, \fBn\fP
のいずれかであり、次のポインタが
.RI ( int
ではなく)
.I short int
か
.I unsigned short int
へのポインタであることを示す。
.TP
.B hh
.\"O As for
.\"O .BR h ,
.\"O but the next pointer is a pointer to a
.\"O .I signed char
.\"O or
.\"O .IR "unsigned char" .
.B h
と同じだが、次のポインタが
.I signed char
か
.I unsigned char
へのポインタであることを示す。
.TP
.B j
.\"O As for
.\"O .BR h ,
.\"O but the next pointer is a pointer to an
.\"O .I intmax_t
.\"O or a
.\"O .IR uintmax_t .
.\"O This modifier was introduced in C99.
.B h
と同じだが、次のポインタが
.I intmax_t
か
.I uintmax_t
へのポインタであることを示す。
この修飾子は C99 で導入された。
.TP
.B l
.\"O Indicates either that the conversion will be one of
.\"O \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP, or \fBn\fP
.\"O and the next pointer is a pointer to a
.\"O .I long int
.\"O or
.\"O .I unsigned long int
.\"O (rather than
.\"O .IR int ),
.\"O or that the conversion will be one of
.\"O \fBe\fP, \fBf\fP, or \fBg\fP
.\"O and the next pointer is a pointer to
.\"O .I double
.\"O (rather than
.\"O .IR float ).
変換が
\fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP, \fBn\fP
か
.B n
のいずれかであり次のポインタが
.RI ( int
ではなく)
.I long int
か
.I unsigned long int
へのポインタであること、または、変換が
\fBe\fP, \fBf\fP, \fBg\fP
のうちのひとつであり次のポインタが
.RI ( float
ではなく)
.I double
へのポインタであることのいずれかであることを示す。
.\"O Specifying two
.\"O .B l
.\"O characters is equivalent to
.\"O .BR L .
.\"O If used with
.\"O .B %c
.\"O or
.\"O .B %s
.\"O the corresponding parameter is considered
.\"O as a pointer to a wide character or wide-character string respectively.
.\"O .\" This use of l was introduced in Amendment 1 to ISO C90.
.B l
文字を二つ指定すると、
.B L
と同じ意味となる。
.B %c
や
.B %s
とともに使用すると、
パラメータはそれぞれワイド文字やワイド文字列へのポインタであると
みなされる。
.\" l のこの使用法は ISO C90 の Amendment 1 で導入された。
.TP
.B L
.\"O Indicates that the conversion will be either
.\"O \fBe\fP, \fBf\fP, or \fBg\fP
.\"O and the next pointer is a pointer to
.\"O .I "long double"
.\"O or the conversion will be
.\"O \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, or \fBx\fP
.\"O and the next pointer is a pointer to
.\"O .IR "long long" .
\fBe\fP, \fBf\fP, \fBg\fP
変換で、次のポインタが
.I "long double"
へのポインタであることを示す。もしくは、
\fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP
変換で、次のポインタが
.I "long long"
へのポインタであることのいずれかであることを示す。
.\"O .\" MTK, Jul 05: The following is no longer true for modern
.\"O .\" ANSI C (i.e., C99):
.\"O .\" (Note that long long is not an
.\"O .\" ANSI C
.\"O .\" type. Any program using this will not be portable to all
.\"O .\" architectures).
.\" MTK, Jul 05: 以下の内容は新しい ANSI C (つまり C99) では
.\" もはや正しくない。
.\" (long long は
.\" .I ANSI C
.\" で規定された型ではないことに注意しよう。
.\" これを用いたプログラムは全てのアーキテクチャに対して
.\" 移植可能ではない。)
.TP
.B q
.\"O equivalent to
.\"O .BR L .
.\"O This specifier does not exist in ANSI C.
.B L
と同一である。
この修飾子は ANSI C には存在しない。
.TP
.B t
.\"O As for
.\"O .BR h ,
.\"O but the next pointer is a pointer to a
.\"O .IR ptrdiff_t .
.\"O This modifier was introduced in C99.
.B h
と同様だが、次のポインタが
.I ptrdiff_t
へのポインタであることを示す。
この修飾子は C99 で導入された。
.TP
.B z
.\"O As for
.\"O .BR h ,
.\"O but the next pointer is a pointer to a
.\"O .IR size_t .
.\"O This modifier was introduced in C99.
.B h
と同様だが、次のポインタが
.I size_t
へのポインタであることを示す。
この修飾子は C99 で導入された。
.PP
.\"O The following
.\"O .I "conversion specifiers"
.\"O are available:
以下の
.I 「変換指定子」
が利用可能である。
.TP
.B %
.\"O Matches a literal \(aq%\(aq.
.\"O That is,
.\"O .B %\&%
.\"O in the format string matches a
.\"O single input \(aq%\(aq character.
.\"O No conversion is done (but initial white space characters are discarded),
.\"O and assignment does not occur.
文字 \(aq%\(aq に対応する。
書式文字列の中の
.B %\&%
は単一の文字 \(aq%\(aq に対応する。
変換は行われず (但し、先頭のホワイトスペース文字は捨てられる)、
変数への代入は生じない。
.TP
.B d
.\"O Matches an optionally signed decimal integer;
.\"O the next pointer must be a pointer to
.\"O .IR int .
符号つきの 10進の整数に対応する。
次のポインタは
.I int
へのポインタでなければならない。
.TP
.B D
.\"O Equivalent to
.\"O .IR ld ;
.\"O this exists only for backward compatibility.
.\"O (Note: thus only in libc4.
.\"O In libc5 and glibc the
.\"O .B %D
.\"O is silently ignored, causing old programs to fail mysteriously.)
.I ld
と同一である。これは以前の仕様との互換性だけのためにある。
(注意: これは libc4 の場合だけである。 libc5 や glibc では
.B %D
は暗黙のうちに無視され、古いプログラムにおいて謎に満ちた失敗の原因となる。)
.TP
.B i
.\"O Matches an optionally signed integer; the next pointer must be a pointer to
.\"O .IR int .
.\"O The integer is read in base 16 if it begins with
.\"O .I 0x
.\"O or
.\"O .IR 0X ,
.\"O in base 8 if it begins with
.\"O .IR 0 ,
.\"O and in base 10 otherwise.
.\"O Only characters that correspond to the base are used.
符号つき整数に対応する。
次のポインタは
.I int
へのポインタでなければならない。
この整数は
.I 0x
または
.I 0X
で開始する場合には 16 進数、
.I 0
で開始する場合には 8 進数、その他の場合には 10進数として読み込まれる。
この変換で使用される文字は、これらの基数に対応しているものだけである。
.TP
.B o
.\"O Matches an unsigned octal integer; the next pointer must be a pointer to
.\"O .IR "unsigned int" .
符号なしの 8 進の整数に対応する。
次のポインタは
.I "unsigned int"
でなければならない。
.TP
.B u
.\"O Matches an unsigned decimal integer; the next pointer must be a
.\"O pointer to
.\"O .IR "unsigned int" .
符号なしの 10進の整数に対応する。
次のポインタは
.I "unsigned int"
へのポインタでなければならない。
.TP
.B x
.\"O Matches an unsigned hexadecimal integer; the next pointer must
.\"O be a pointer to
.\"O .IR "unsigned int" .
符号なしの 16 進の整数に対応する。
次のポインタは
.I "unsigned int"
へのポインタでなければならない。
.TP
.B X
.\"O Equivalent to
.\"O .BR x .
.B x
と同一である。
.TP
.B f
.\"O Matches an optionally signed floating-point number; the next pointer must
.\"O be a pointer to
.\"O .IR float .
符号つき浮動小数点実数に対応する。
次のポインタは
.I float
へのポインタでなければならない。
.TP
.B e
.\"O Equivalent to
.\"O .BR f .
.B f
と同一である。
.TP
.B g
.\"O Equivalent to
.\"O .BR f .
.B f
と同一である。
.TP
.B E
.\"O Equivalent to
.\"O .BR f .
.B f
と同一である。
.TP
.B a
.\"O (C99) Equivalent to
.\"O .BR f .
(C99)
.B f
と同一である。
.TP
.B s
.\"O Matches a sequence of non-white-space characters;
.\"O the next pointer must be a pointer to character array that is
.\"O long enough to hold the input sequence and
.\"O the terminating null byte (\(aq\\0\(aq), which is added automatically.
.\"O The input string stops at white space or at the maximum field
.\"O width, whichever occurs first.
ホワイトスペースではない文字で構成された文字列に対応する。
次のポインタは文字の配列へのポインタでなければならず、
その文字配列は、入力された文字列と (自動的に追加される) 終端の NULL
バイト (\(aq\\0\(aq) を格納するのに十分な大きさでなければならない。
文字列の入力は、ホワイトスペースが入力されるか、最大フィールド幅に
達するか、のどちらかが起こると停止される。
.TP
.B c
.\"O Matches a sequence of characters whose length is specified by the
.\"O .I maximum field width
.\"O (default 1); the next pointer must be a pointer to
.\"O .IR char ,
.\"O and there must be enough room for all the characters (no terminating
.\"O null byte
.\"O is added).
.\"O The usual skip of leading white space is suppressed.
.\"O To skip white space first, use an explicit space in the format.
.I "「最大フィールド幅」"
(デフォルトは 1) で指定された幅の文字の列に対応する。
次のポインタは
.I char
へのポインタで、すべての文字を格納するのに十分な領域が
なければならない (終端の NULL バイトは追加されない)。
通常行われる先頭のホワイトスペースの読み飛ばしは行われない。
先頭のホワイトスペースを読み飛ばすためには、
フォーマット文の中で明示的にスペースを使用すれば良い。
.TP
.B \&[
.\"O Matches a nonempty sequence of characters from the specified set of
.\"O accepted characters; the next pointer must be a pointer to
.\"O .IR char ,
.\"O and there must be enough room for all the characters in the string, plus a
.\"O terminating null byte.
.\"O The usual skip of leading white space is suppressed.
格納された文字列のうちから取り出された、
指定された文字の集合で構成される空ではない文字の列に対応する。
次のポインタは
.I char
へのポインタでなければならず、
そこには文字列中のすべての文字と終端の NULL バイト
を格納するための十分な領域がなければならない。
通常行われる先頭のホワイトスペースの読み飛ばしは行われない。
.\"O The string is to be made up of characters in (or not in) a particular set;
.\"O the set is defined by the characters between the open bracket
.\"O .B [
.\"O character and a close bracket
.\"O .B ]
.\"O character.
.\"O The set
.\"O .I excludes
.\"O those characters if the first character after the open bracket is a
.\"O circumflex
.\"O .RB ( ^ ).
この文字列は特別な集合の中の文字で構成されている。
この集合は
開き括弧
.B [
と閉じ括弧
.B ]
の間の文字で定義される。
開き括弧のあとの最初の文字が曲アクセント記号
.RB ( ^ )
の場合、集合はこれらの文字を含まないものとなる。
.\"O To include a close bracket in the set, make it the first character after
.\"O the open bracket or the circumflex; any other position will end the set.
.\"O The hyphen character
.\"O .B \-
.\"O is also special; when placed between two other characters, it adds all
.\"O intervening characters to the set.
.\"O To include a hyphen, make it the last
.\"O character before the final close bracket.
閉じ括弧を集合に含ませるためには、この文字を開き括弧または
曲アクセント記号のあとの最初の文字にすればよい。
つまり、他の位置に閉じ括弧を置くと文字の集合が終る。
ハイフン
.B \-
もまた特殊文字である。
二つの異なる文字の間に置かれた時、この文字は、
その間にある全ての文字を集合に加える。
ハイフン自体を含ませるためには、
括弧が閉じる前の最後の一文字をハイフンにすればよい。
.\"O For instance,
.\"O .B [^]0\-9\-]
.\"O means
.\"O the set "everything except close bracket, zero through nine, and hyphen".
.\"O The string ends with the appearance of a character not in the (or, with a
.\"O circumflex, in) set or when the field width runs out.
例えば、
.B [^]0\-9\-]
は「閉じ括弧、0 〜 9、ハイフンの 3 種類を除く全ての文字」の集合を意味する。
この文字列は
集合に含まれていない (曲アクセントの場合には含まれる) 文字の
出現または確保された領域が使い切られた時に終了する。
.TP
.B p
.\"O Matches a pointer value (as printed by
.\"O .B %p
.\"O in
.\"O .BR printf (3);
.\"O the next pointer must be a pointer to a pointer to
.\"O .IR void .
.RB ( printf (3)
の
.B %p
で印字されるような) ポインタ値に対応する。
次のポインタは
.I void
へのポインタへのポインタでなければならない。
.TP
.B n
.\"O Nothing is expected; instead, the number of characters consumed thus far
.\"O from the input is stored through the next pointer, which must be a pointer
.\"O to
.\"O .IR int .
どんな入力も必要としない。
そのかわりに、
入力からここまで消費された文字数が次のポインタで指定された場所に
格納される。
このポインタは
.I int
へのポインタでなければならない。
.\"O This is
.\"O .I not
.\"O a conversion, although it can be suppressed with the
.\"O .B *
.\"O assignment-suppression character.
変換を抑制するのであれば
.B *
代入抑制文字を使って抑制することができるのだが、
この変換指定子は変換では「ない」。
.\"O The C standard says: "Execution of a
.\"O .B %n
.\"O directive does not increment
.\"O the assignment count returned at the completion of execution"
.\"O but the Corrigendum seems to contradict this.
.\"O Probably it is wise
.\"O not to make any assumptions on the effect of
.\"O .B %n
.\"O conversions on the return value.
C 言語の標準規格では「実行の完了時に返される代入の回数は
.B %n
命令の実行では増加しない」となっているが、
正誤表の内容はこれと矛盾するようである。おそらく、
.B %n
変換が返り値に与える影響についてはどのような仮定もしないのが
賢明であろう。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O These functions return the number of input items
.\"O successfully matched and assigned,
.\"O which can be fewer than provided for,
.\"O or even zero in the event of an early matching failure.
これらの関数は、一致と代入が成功した入力要素の個数を返す。
返される値は渡された変換の個数よりも少ないこともあり、
最初に一致の失敗があった場合には 0 になることもある。

.\"O The value
.\"O .B EOF
.\"O is returned if the end of input is reached before either the first
.\"O successful conversion or a matching failure occurs.
.\"O .B EOF
.\"O is also returned if a read error occurs,
.\"O in which case the error indicator for the stream (see
.\"O .BR ferror (3))
.\"O is set, and
.\"O .I errno
.\"O is set indicate the error.
最初の変換が成功する前に入力の最後に達して、一致の失敗が起こった場合には、
.B EOF
が返される。また、
読み込みエラーが発生した場合にも
.B EOF
が返される。読み込みエラーの場合には、そのストリームの
エラー指示子がセットされ
.RB ( ferror (3)
参照)、
.I errno
にエラーを示す値がセットされる。
.\"O .SH ERRORS
.SH エラー
.TP
.B EAGAIN
.\"O The file descriptor underlying
.\"O .I stream
.\"O is marked nonblocking, and the read operation would block.
.I stream
に対応するファイルディスクリプタが nonblocking となっており、
読み込み操作は停止 (block) することになる。
.TP
.B EBADF
.\"O The file descriptor underlying
.\"O .I stream
.\"O is invalid, or not open for reading.
.I stream
に対応するファイルディスクリプタが無効であるが、
読み込み用にオープンされていない。
.TP
.B EILSEQ
.\"O Input byte sequence does not form a valid character.
入力されたバイト列が有効な文字を構成していない。
.TP
.B EINTR
.\"O The read operation was interrupted by a signal; see
.\"O .BR signal (7).
読み込み操作がシグナルにより割り込まれた。
.BR signal (7)
参照。
.TP
.B EINVAL
.\"O Not enough arguments; or
.\"O .I format
.\"O is NULL.
引き数が十分でない。または
.I format
が NULL である。
.TP
.B ENOMEM
.\"O Out of memory.
メモリ不足。
.TP
.B ERANGE
.\"O The result of an integer conversion would exceed the size
.\"O that can be stored in the corresponding integer type.
整数変換の結果が、対応する整数型に格納できるサイズを越えてしまう。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O The functions
.\"O .BR fscanf (),
.\"O .BR scanf (),
.\"O and
.\"O .BR sscanf ()
.\"O conform to C89 and C99 and POSIX.1-2001.
.\"O These standards do not specify the
.\"O .B ERANGE
.\"O error.
.BR fscanf (),
.BR scanf (),
.BR sscanf ()
関数は C89, C99, POSIX.1-2001 に準拠している。
これらの標準では、エラー
.B ERANGE
は規定されていない。
.PP
.\"O The
.\"O .B q
.\"O specifier is the 4.4BSD notation for
.\"O .IR "long long" ,
.B q
指定子は
.I "long long"
の 4.4BSD での記述方法である。
.\"O while
.\"O .B ll
.\"O or the usage of
.\"O .B L
.\"O in integer conversions is the GNU notation.
一方、整数変換での
.B ll
または
.B L
の使用は GNU での拡張である。
.PP
.\"O The Linux version of these functions is based on the
.\"O .I GNU
.\"O .I libio
.\"O library.
.\"O Take a look at the
.\"O .I info
.\"O documentation of
.\"O .I GNU
.\"O .I libc (glibc-1.08)
.\"O for a more concise description.
これらの関数の Linux 版は
.I GNU
.I libio
ライブラリーを元にしている。
より簡潔な説明には
.I GNU
.I libc (glibc-1.08)
の
.I info
文書に目を通すこと。
.\"O .SH NOTES
.SH 注意
.\"O The GNU C library supports a nonstandard extension that causes
.\"O the library to dynamically allocate a string of sufficient size
.\"O for input strings for the
.\"O .B %s
.\"O and
.\"O \fB%a[\fP\fIrange\fP\fB]\fP
.\"O conversion specifiers.
GNU C ライブラリ (glibc) では非標準のオプションをサポートしており、
このオプションを使うと変換指定子
.B %s
や
\fB%a[\fP\fIrange\fP\fB]\fP
への入力文字列に対して十分な大きさの文字列をライブラリが動的に確保する
ようになる。
.\"O .\" This feature seems to be present at least as far back as glibc 2.0.
.\" この機能は少なくとも glibc 2.0 時点から存在しているようだ。
.\"O To make use of this feature, specify
.\"O .B a
.\"O as a length modifier (thus
.\"O .B %as
.\"O or
.\"O \fB%a[\fP\fIrange\fP\fB]\fP).
.\"O The caller must
.\"O .BR free (3)
.\"O the returned string, as in the following example:
この機能を使用するには、長さ修飾子として
.B a
を指定する (したがって、全体としては
.B %as
や
\fB%a[\fP\fIrange\fP\fB]\fP となる)。
以下の例にあるように、呼び出し側は返された文字列を
.BR free (3)
しなければならない。
.in +4n
.nf

char *p;
int n;

errno = 0;
n = scanf("%a[a-z]", &p);
if (n == 1) {
    printf("read: %s\\n", p);
    free(p);
} else if (errno != 0) {
    perror("scanf");
} else {
    fprintf(stderr, "No matching characters\\n"):
}
.fi
.in
.PP
.\"O As shown in the above example, it is only necessary to call
.\"O .BR free (3)
.\"O if the
.\"O .BR scanf ()
.\"O call successfully read a string.
上記の例にあるように、
.BR scanf ()
が文字列の読み込みに成功した場合にだけ、
.BR free (3)
を呼び出す必要がある。
.PP
.\"O The
.\"O .B a
.\"O modifier is not available if the program is compiled with
.\"O .I "gcc -std=c99"
.\"O or
.\"O .IR "gcc -D_ISOC99_SOURCE"
.\"O (unless
.\"O .B _GNU_SOURCE
.\"O is also specified), in which case the
.\"O .B a
.\"O is interpreted as a specifier for floating-point numbers (see above).
.I "gcc -std=c99"
や
.I "gcc -D_ISOC99_SOURCE"
でコンパイルしたプログラムでは
.RB ( _GNU_SOURCE
も同時に指定していない場合)、
.B a
修飾子は利用できない。
上記の場合、
.B a
は (上述の通り) 浮動小数点数を示す変換指定子と解釈される。

.\"O Since version 2.7, glibc also provides the
.\"O .B m
.\"O modifier for the same purpose as the
.\"O .BR a
.\"O modifier.
.\"O The
.\"O .B m
.\"O modifier has the following advantages:
バージョン 2.7 以降では、glibc は
.B a
修飾子と同じ目的で
.B m
修飾子も提供している。
.B m
修飾子は以下の利点がある。
.IP * 2
.\"O It may also be applied to
.\"O .B %c
.\"O conversion specifiers (e.g.,
.\"O .BR %3mc ).
.B %c
変換指定子にも適用できる (例えば
.BR %3mc )。
.IP *
.\"O It avoids ambiguity with respect to the
.\"O .B %a
.\"O floating-point conversion specifier (and is unaffected by
.\"O .IR "gcc -std=c99"
.\"O etc.)
浮動小数点変換指定子としての
.B %a
との紛らわしさが避けられる (また
.I "gcc -std=c99"
などの影響も避けられる)。
.IP *
.\"O It is specified in the upcoming revision of the POSIX.1 standard.
POSIX.1 標準の次の改訂版で規定される。
.\"O .SH BUGS
.SH バグ
.\"O All functions are fully C89 conformant, but provide the
.\"O additional specifiers
.\"O .B q
.\"O and
.\"O .B a
.\"O as well as an additional behavior of the
.\"O .B L
.\"O and
.\"O .B l
.\"O specifiers.
.\"O The latter may be considered to be a bug, as it changes the
.\"O behavior of specifiers defined in C89.
全ての関数は、完全に C89 に準拠している。しかし
追加で
.B q
と
.B a
指定子が提供されており、同様に
.B L
と
.B l
指定子の付加的な振る舞いもある。後者は、
C89 で定義された指定子の振る舞いを変更するものなので、
バグとみなされるかもしれない。
.PP
.\"O Some combinations of the type modifiers and conversion
.\"O specifiers defined by ANSI C do not make sense
.\"O (e.g.
.\"O .BR "%Ld" ).
ANSI C で定義された型修飾子と変換指定子の組み合わせの中には
意味をなさないものがある
(例えば、
.BR "%Ld" )。
.\"O While they may have a well-defined behavior on Linux, this need not
.\"O to be so on other architectures.
.\"O Therefore it usually is better to use
.\"O modifiers that are not defined by ANSI C at all, that is, use
.\"O .B q
.\"O instead of
.\"O .B L
.\"O in combination with
.\"O \fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, and \fBX\fP
.\"O conversions or
.\"O .BR ll .
これらが指定された場合、
Linux 上でははっきりと定義された振る舞いをするかもしれないが、
他のアーキテクチャでも同様になっているとは限らない。
それゆえに、ほとんどの場合、
ANSI C で定義されていない修飾子を使用した方が良い。
すなわち、
\fBd\fP, \fBi\fP, \fBo\fP, \fBu\fP, \fBx\fP, \fBX\fP
変換や
.B ll
と組み合わせる場合には、
.B L
の代わりに
.B q
を使用した方が良い。
.PP
.\"O The usage of
.\"O .B q
.\"O is not the same as on 4.4BSD,
.\"O as it may be used in float conversions equivalently to
.\"O .BR L .
.B q
の使用方法は 4.4BSD と同じではない。
4.4BSD では
.B q
は
.B L
と同等に浮動小数の変換に使用される。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR getc (3),
.BR printf (3)
.BR setlocale (3),
.BR strtod (3),
.BR strtol (3),
.BR strtoul (3),

.\" Copyright (C) 1996 Andries Brouwer (aeb@cwi.nl)
.\" and Copyright (C) 2005 Michael Kerrisk (mtk.manpages@gmail.com)
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Rewritten old page, 960210, aeb@cwi.nl
.\" Updated, added strtok_r. 2000-02-13 Nicolas Lichtmaier <nick@debian.org>
.\" 2005-11-17, mtk: Substantial parts rewritten
.\"
.\" Japanese Version Copyright (c) 1998 Ishii Tatsuo all rights reserved.
.\" Translated 1998-03-27, Ishii Tatsuo <rfun@azusa.shinshu-u.ac.jp>
.\" Updated 2000-04-05, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2000-09-21, Kentaro Shirakata
.\" Updated 2002-03-28, Kentaro Shirakata
.\" Updated 2005-11-19, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.TH STRTOK 3  2008-10-29 "GNU" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O strtok, strtok_r \- extract tokens from strings
.SH 名前
strtok, strtok_r \- 文字列からトークンを取り出す
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <string.h>
.sp
.BI "char *strtok(char *" str ", const char *" delim );
.sp
.BI "char *strtok_r(char *" str ", const char *" delim ", char **" saveptr );
.fi
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.ad l
.BR strtok_r ():
_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\ >=\ 1 ||
_XOPEN_SOURCE || _POSIX_SOURCE
.ad b
.\"O .SH DESCRIPTION
.SH 説明
.\"O The
.\"O .BR strtok ()
.\"O function parses a string into a sequence of tokens.
.\"O On the first call to
.\"O .BR strtok ()
.\"O the string to be parsed should be
.\"O specified in \fIstr\fP.
.\"O In each subsequent call that should parse the same string,
.\"O \fIstr\fP should be NULL.
.BR strtok ()
関数は文字列を解析してトークンに分割する。
.BR strtok ()
を最初に呼び出す際には、解析対象の文字列を \fIstr\fP に
指定する。同じ文字列の解析を行うその後の呼び出しでは、
\fIstr\fP には NULL を指定する。

.\"O The \fIdelim\fP argument specifies a set of characters that
.\"O delimit the tokens in the parsed string.
.\"O The caller may specify different strings in \fIdelim\fP in successive
.\"O calls that parse the same string.
\fIdelim\fP 引き数には、解析する文字列をトークンに区切る文字集合を
指定する。同じ文字列を解析する一連の呼び出しにおいて、
\fIdelim\fP に違う文字列を指定してもよい。

.\"O Each call to
.\"O .BR strtok ()
.\"O returns a pointer to a
.\"O null-terminated string containing the next token.
.\"O This string does not include the delimiting character.
.\"O If no more tokens are found,
.\"O .BR strtok ()
.\"O returns NULL.
.BR strtok ()
のそれぞれの呼び出しでは、次のトークンを
格納した NULL 終端された文字列へのポインタが返される。
この文字列には区切り文字は含まれない。
これ以上トークンが見つからなかった場合には、NULL が返される。

.\"O A sequence of two or more contiguous delimiter characters in
.\"O the parsed string is considered to be a single delimiter.
.\"O Delimiter characters at the start or end of the string are ignored.
.\"O Put another way: the tokens returned by
.\"O .BR strtok ()
.\"O are always nonempty strings.
解析対象の文字列に2つ以上の区切り文字が連続している場合には、
一つの区切り文字とみなされる。
文字列の先頭や末尾にある区切り文字は無視される。言い換えると、
.BR strtok ()
が返すトークンは常に空でない文字列となる。

.\"O The
.\"O .BR strtok_r ()
.\"O function is a reentrant version
.\"O .BR strtok ().
.\"O The \fIsaveptr\fP argument is a pointer to a
.\"O \fIchar *\fP variable that is used internally by
.\"O .BR strtok_r ()
.\"O in order to maintain context between successive calls that parse the
.\"O same string.
.BR strtok_r ()
関数は
.BR strtok ()
のリエントラント版である。
\fIsaveptr\fP 引き数は \fIchar *\fP 変数へのポインタであり、
同じ文字列の解析を行う
.BR strtok_r ()
の呼び出し間で処理状況を保存するために
.BR strtok_r ()
内部で使用される。

.\"O On the first call to
.\"O .BR strtok_r (),
.\"O .I str
.\"O should point to the string to be parsed, and the value of
.\"O .I saveptr
.\"O is ignored.
.\"O In subsequent calls, \fIstr\fP should be NULL, and
.\"O \fIsaveptr\fP should be unchanged since the previous call.
.BR strtok_r ()
を最初に呼び出す際には、
.I str
は解析対象の文字列を指していなければならず、
.I saveptr
の値は無視される。それ以降の呼び出しでは、
.I str
は NULL とし、
.I saveptr
は前回の呼び出し以降変更しないようにしなければならない。

.\"O Different strings may be parsed concurrently using sequences of calls to
.\"O .BR strtok_r ()
.\"O that specify different \fIsaveptr\fP arguments.
.BR strtok_r ()
の呼び出し時に異なる \fIsaveptr\fP 引き数を指定することで、
異なる文字列の解析を同時に行うことができる。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O The
.\"O .BR strtok ()
.\"O and
.\"O .BR strtok_r ()
.\"O functions return a pointer to
.\"O the next token, or NULL if there are no more tokens.
.BR strtok ()
と
.BR strtok_r ()
は次のトークンへのポインタか、
トークンがなければ NULL を返す。
.\"O .SH "CONFORMING TO"
.SH 準拠
.TP
.BR strtok ()
SVr4, POSIX.1-2001, 4.3BSD, C89, C99.
.TP
.BR strtok_r ()
POSIX.1-2001.
.\"O .SH "BUGS"
.SH バグ
.\"O Be cautious when using these functions.
.\"O If you do use them, note that:
これらの関数を使うのは慎重に吟味すること。
使用する場合は、以下の点に注意が必要である。
.IP * 2
.\"O These functions modify their first argument.
これらの関数はその最初の引数を変更する。
.IP *
.\"O These functions cannot be used on constant strings.
これらの関数は const な文字列では使えない。
.IP *
.\"O The identity of the delimiting character is lost.
区切り文字自体は失われてしまう。
.IP *
.\"O The
.\"O .BR strtok ()
.\"O function uses a static buffer while parsing, so it's not thread safe.
.\"O Use
.\"O .BR strtok_r ()
.\"O if this matters to you.
.BR strtok ()
関数は文字列の解析に静的バッファを用いるので、スレッドセーフでない。
これが問題になる場合は
.BR strtok_r ()
を用いること。
.\"O .SH EXAMPLE
.SH 例
.\"O The program below uses nested loops that employ
.\"O .BR strtok_r ()
.\"O to break a string into a two-level hierarchy of tokens.
.\"O The first command-line argument specifies the string to be parsed.
.\"O The second argument specifies the delimiter character(s)
.\"O to be used to separate that string into "major" tokens.
.\"O The third argument specifies the delimiter character(s)
.\"O to be used to separate the "major" tokens into subtokens.
以下のプログラムは、
.BR strtok_r ()
を利用するループを入れ子にして使用し、
文字列を2階層のトークンに分割するものである。
1番目のコマンドライン引き数には、解析対象の文字列を指定する。
2番目の引き数には、文字列を「大きな」トークンに分割するために
使用する区切り文字を指定する。
3番目の引き数には、「大きな」トークンを細かく分割するために
使用する区切り文字を指定する。
.PP
.PP
.\"O An example of the output produced by this program is the following:
このプログラムの出力例を以下に示す。
.PP
.in +4n
.nf
.RB "$" " ./a.out \(aqa/bbb///cc;xxx:yyy:\(aq \(aq:;\(aq \(aq/\(aq"
1: a/bbb///cc
         \-\-> a
         \-\-> bbb
         \-\-> cc
2: xxx
         \-\-> xxx
3: yyy
         \-\-> yyy
.fi
.in
.\"O .SS Program source
.SS プログラムのソース
\&
.nf
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int
main(int argc, char *argv[])
{
    char *str1, *str2, *token, *subtoken;
    char *saveptr1, *saveptr2;
    int j;

    if (argc != 4) {
        fprintf(stderr, "Usage: %s string delim subdelim\\n",
                argv[0]);
        exit(EXIT_FAILURE);
    }

    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {
        token = strtok_r(str1, argv[2], &saveptr1);
        if (token == NULL)
            break;
        printf("%d: %s\\n", j, token);

        for (str2 = token; ; str2 = NULL) {
            subtoken = strtok_r(str2, argv[3], &saveptr2);
            if (subtoken == NULL)
                break;
            printf("\t \-\-> %s\\n", subtoken);
        }
    }

    exit(EXIT_SUCCESS);
} /* main */
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR index (3),
.BR memchr (3),
.BR rindex (3),
.BR strchr (3),
.BR strpbrk (3),
.BR strsep (3),
.BR strspn (3),
.BR strstr (3),
.BR wcstok (3)

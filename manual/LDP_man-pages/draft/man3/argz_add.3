.\" Copyright 2002 walter harms (walter.harms@informatik.uni-oldenburg.de)
.\"
.\" %%%LICENSE_START(GPL_NOVERSION_ONELINE)
.\" Distributed under GPL
.\" %%%LICENSE_END
.\"
.\" based on the description in glibc source and infopages
.\"
.\" Corrections and additions, aeb
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH ARGZ_ADD 3 2007\-05\-18 "" "Linux Programmer's Manual"
.SH 名前
argz_add, argz_add_sep, argz_append, argz_count, argz_create,
argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next,
argz_replace, argz_stringify \- argz リストを操作するための関数群
.SH 書式
.nf
\fB#include <argz.h>\fP
.sp
\fBerror_t argz_add(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, const char *\fP\fIstr\fP\fB);\fP
.sp
\fBerror_t argz_add_sep(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB,\fP
\fB                     const char *\fP\fIstr\fP\fB, int \fP\fIdelim\fP\fB);\fP
.sp
\fBerror_t argz_append(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB,\fP
\fB                     const char *\fP\fIbuf\fP\fB, size_t \fP\fIbuf_len\fP\fB);\fP
.sp
\fBsize_t argz_count(const char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_create(char * const \fP\fIargv\fP\fB[], char **\fP\fIargz\fP\fB,\fP
\fB                     size_t *\fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_create_sep(const char *\fP\fIstr\fP\fB, int \fP\fIsep\fP\fB, char **\fP\fIargz\fP\fB,\fP
\fB                     size_t *\fP\fIargz_len\fP\fB);\fP
.sp
\fBerror_t argz_delete(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, char *\fP\fIentry\fP\fB);\fP
.sp
\fBvoid argz_extract(char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB, char  **\fP\fIargv\fP\fB);\fP
.sp
\fBerror_t argz_insert(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, char *\fP\fIbefore\fP\fB,\fP
\fB                     const char *\fP\fIentry\fP\fB);\fP
.sp
\fBchar *argz_next(char *\fP\fIargz\fP\fB, size_t \fP\fIargz_len\fP\fB, const char *\fP\fIentry\fP\fB);\fP
.sp
\fBerror_t argz_replace(char **\fP\fIargz\fP\fB, size_t *\fP\fIargz_len\fP\fB, const char *\fP\fIstr\fP\fB,\fP
\fB                     const char *\fP\fIwith\fP\fB, unsigned int *\fP\fIreplace_count\fP\fB);\fP
.sp
\fBvoid argz_stringify(char *\fP\fIargz\fP\fB, size_t \fP\fIlen\fP\fB, int \fP\fIsep\fP\fB);\fP
.fi
.SH 説明
これらの関数は glibc 固有である。
.LP
argz vector は長さ情報付きの文字バッファへのポインタである。 文字バッファでは、複数の文字列が NULL バイト (\(aq\e0\(aq)
で区切られており、 文字列の配列として解釈されるようになっている。 長さが 0 でない場合、バッファの最後のバイトは NULL
バイトでなければならない。
.LP
これらの関数は argz vector を操作するためのものである。 ペア (NULL,0) は argz vector であり、逆に言えば 長さ 0
の argz vectorは NULL ポインタを持たなければならない。 空でない argz vector の割り当ては \fBmalloc\fP(3)
を使って行われる。したがって、argz vector を解放するのに \fBfree\fP(3)  を使うことができる。
.LP
\fBargz_add\fP()  は、文字列 \fIstr\fP を配列 \fI*argz\fP の末尾に追加し、 \fI*argz\fP と \fI*argz_len\fP
を更新する。
.LP
\fBargz_add_sep\fP()  も同様の動作をするが、区切り文字 \fIdelim\fP にしたがって文字列 \fIstr\fP
を複数の文字列に分割する点が異なる。 例えば、区切り文字 \(aq:\(aq を指定して、UNIX サーチ・パスに対して
この関数を使うことができるだろう。
.LP
\fBargz_append\fP()  appends the argz vector (\fIbuf\fP,\ buf_len\fI)\fP after
(\fI*argz\fP,\ *argz_len\fI)\fP and updates \fI*argz\fP and \fI*argz_len\fP.  (Thus,
\fI*argz_len\fP will be increased by \fIbuf_len\fP.)
.LP
\fBargz_count\fP()  counts the number of strings, that is, the number of null
bytes (\(aq\e0\(aq), in (\fIargz\fP,\ argz_len\fI).\fP
.LP
\fBargz_create\fP()  converts a UNIX\-style argument vector \fIargv\fP, terminated
by \fI(char\ *)\ 0\fP, into an argz vector (\fI*argz\fP,\ *argz_len\fI).\fP
.LP
\fBargz_create_sep\fP()  converts the null\-terminated string \fIstr\fP into an
argz vector (\fI*argz\fP,\ *argz_len\fI)\fP by breaking it up at every occurrence
of the separator \fIsep\fP.
.LP
\fBargz_delete\fP()  removes the substring pointed to by \fIentry\fP from the argz
vector (\fI*argz\fP,\ *argz_len\fI)\fP and updates \fI*argz\fP and \fI*argz_len\fP.
.LP
\fBargz_extract\fP()  is the opposite of \fBargz_create\fP().  It takes the argz
vector (\fIargz\fP,\ argz_len\fI)\fP and fills the array starting at \fIargv\fP with
pointers to the substrings, and a final NULL, making a UNIX\-style argv
vector.  The array \fIargv\fP must have room for
\fIargz_count\fP(\fIargz\fP,\fIargz_len\fP) + 1 pointers.
.LP
\fBargz_insert\fP()  is the opposite of \fBargz_delete\fP().  It inserts the
argument \fIentry\fP at position \fIbefore\fP into the argz vector (\fI*argz\fP,\ *argz_len\fI)\fP and updates \fI*argz\fP and \fI*argz_len\fP.  If \fIbefore\fP is NULL,
then \fIentry\fP will inserted at the end.
.LP
\fBargz_next\fP()  は argz vector を順番に調べるための関数である。 \fIentry\fP が NULL
の場合、最初のエントリを返す。 そうでない場合、次のエントリを返す。 次のエントリがない場合、NULL を返す。
.LP
\fBargz_replace\fP()  は、 \fIstr\fP をすべて \fIwith\fP で置き換える (必要に応じて argz の再割り当てを行う)。
\fIreplace_count\fP が NULL でない場合、 \fI*replace_count\fP を置き換えを行った数だけ増やす。
.LP
\fBargz_stringify\fP()  は \fBargz_create_sep\fP()  の反対の操作を行う。 末尾の NULL バイト以外の全ての
NULL バイト (\(aq\e0\(aq) を \fIsep\fP で置き換えて、 argz vector を通常の文字列に変換する。
.SH 返り値
メモリ割り当てを行う argz 関数群はすべて \fIerror_t\fP 型の返り値を持つ。 成功した場合は 0 を返し、割り当てエラーが発生した場合は
\fBENOMEM\fP を返す。
.SH 準拠
これらの関数は GNU による拡張である。注意して使用すること。
.SH バグ
NULL バイトで終端されていない argz vector を使用した場合、 segmentation fault を起こすかもしれない。
.SH 関連項目
\fBenvz_add\fP(3)
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.52 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。

.\" Copyright 2002 walter harms (walter.harms@informatik.uni-oldenburg.de)
.\" Distributed under GPL
.\" based on the description in glibc source and infopages
.\"
.\" Corrections and additions, aeb
.\"
.\" Japanese Version Copyright (c) 2002 Akihiro MOTOKI, all rights reserved.
.\" Translated Mon Feb  2 2003 by Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.TH ARGZ_ADD 3 2007-05-18  "" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O argz_add, argz_add_sep, argz_append, argz_count, argz_create,
.\"O argz_create_sep, argz_delete, argz_extract, argz_insert,
.\"O argz_next, argz_replace, argz_stringify \- functions to handle an argz list
argz_add, argz_add_sep, argz_append, argz_count, argz_create,
argz_create_sep, argz_delete, argz_extract, argz_insert,
argz_next, argz_replace, argz_stringify \- argz リストを操作するための関数群
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B "#include <argz.h>"
.sp
.BI "error_t argz_add(char **" argz ", size_t *" argz_len \
", const char *" str );
.sp
.BI "error_t argz_add_sep(char **" argz ", size_t *" argz_len ,
.ti 20n
.BI "const char *" str ", int " delim );
.sp
.BI "error_t argz_append(char **" argz ", size_t *" argz_len ,
.ti 20n
.BI "const char *" buf ", size_t " buf_len );
.sp
.BI "size_t argz_count(const char *" argz ", size_t " argz_len );
.sp
.BI "error_t argz_create(char * const " argv "[], char **" argz ,
.ti 20n
.BI "size_t *" argz_len );
.sp
.BI "error_t argz_create_sep(const char *" str ", int " sep ", char **" argz ,
.ti 20n
.BI "size_t *" argz_len );
.sp
.BI "error_t argz_delete(char **" argz ", size_t *" argz_len ", char *" entry );
.sp
.BI "void argz_extract(char *" argz ", size_t " argz_len ", char  **" argv );
.sp
.BI "error_t argz_insert(char **" argz ", size_t *" argz_len ", char *" before ,
.ti 20n
.BI "const char *" entry );
.sp
.BI "char *argz_next(char *" argz ", size_t " argz_len ", const char *" entry );
.sp
.BI "error_t argz_replace(char **" argz ", size_t *" argz_len \
", const char *" str ,
.ti 20n
.BI "const char *" with ", unsigned int *" replace_count );
.sp
.BI "void argz_stringify(char *" argz ", size_t " len ", int " sep );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O These functions are glibc-specific.
これらの関数は glibc 固有である。
.LP
.\"O An argz vector is a pointer to a character buffer together with a length.
.\"O The intended interpretation of the character buffer is an array
.\"O of strings, where the strings are separated by null bytes (\\(aq\\0\\(aq).
.\"O If the length is nonzero, the last byte of the buffer must be a null byte.
argz vector は長さ情報付きの文字バッファへのポインタである。
文字バッファでは、複数の文字列が NULL バイト (\\(aq\\0\\(aq) で区切られており、
文字列の配列として解釈されるようになっている。
長さが 0 でない場合、バッファの最後のバイトは NULL バイトでなければならない。
.LP
.\"O These functions are for handling argz vectors.
.\"O The pair (NULL,0) is an argz vector, and, conversely,
.\"O argz vectors of length 0 must have NULL pointer.
.\"O Allocation of nonempty argz vectors is done using
.\"O .BR malloc (3),
.\"O so that
.\"O .BR free (3)
.\"O can be used to dispose of them again.
これらの関数は argz vector を操作するためのものである。
ペア (NULL,0) は argz vector であり、逆に言えば
長さ 0 の argz vectorは NULL ポインタを持たなければならない。
空でない argz vector の割り当ては
.BR malloc (3)
を使って行われる。したがって、argz vector を解放するのに
.BR free (3)
を使うことができる。
.LP
.\"O .BR argz_add ()
.\"O adds the string
.\"O .I str
.\"O at the end of the array
.\"O .IR *argz ,
.\"O and updates
.\"O .IR *argz
.\"O and
.\"O .IR *argz_len .
.BR argz_add ()
は、文字列
.I str
を配列
.IR *argz
の末尾に追加し、
.IR *argz
と
.IR *argz_len
を更新する。
.LP
.\"O .BR argz_add_sep ()
.\"O is similar, but splits the string
.\"O .I str
.\"O into substrings separated by the delimiter
.\"O .IR delim .
.\"O For example, one might use this on a UNIX search path with
.\"O delimiter \\(aq:\\(aq.
.BR argz_add_sep ()
も同様の動作をするが、区切り文字
.I delim
にしたがって文字列
.I str
を複数の文字列に分割する点が異なる。
例えば、区切り文字 \\(aq:\\(aq を指定して、UNIX サーチ・パスに対して
この関数を使うことができるだろう。
.LP
.\"O .BR argz_append ()
.\"O appends the argz vector
.\"O .RI ( buf ,\  buf_len )
.\"O after
.\"O .RI (* argz ,\  *argz_len )
.\"O and updates
.\"O .IR *argz
.\"O and
.\"O .IR *argz_len .
.\"O (Thus,
.\"O .I *argz_len
.\"O will be increased by
.\"O .IR buf_len .)
.BR argz_append ()
は argz vector
.RI ( buf ,\  buf_len )
の後ろに
.RI (* argz ,\  *argz_len )
を付け加え、
.I *argz
と
.I *argz_len
を更新する。
(したがって、
.I *argz_len
は
.I buf_len
だけ増加する。)
.LP
.\"O .BR argz_count ()
.\"O counts the number of strings, that is,
.\"O the number of null bytes (\\(aq\\0\\(aq), in
.\"O .RI ( argz ,\  argz_len ).
.BR argz_count ()
は
.RI ( argz ,\  argz_len )
内の文字列の数を数える。実際には NULL バイト (\\(aq\\0\\(aq) の数を数えている。
.LP
.\"O .BR argz_create ()
.\"O converts a UNIX-style argument vector
.\"O .IR argv ,
.\"O terminated by
.\"O .IR "(char *) 0" ,
.\"O into an argz vector
.\"O .RI ( *argz ,\  *argz_len ).
.BR argz_create ()
は、UNIX 流の引き数ベクトルである
.RI ( "(char *) 0"
で終端される)
.I argv
を、argz vector
.RI ( *argz ,\  *argz_len )
に変換する。
.LP
.\"O .BR argz_create_sep ()
.\"O converts the null-terminated string
.\"O .I str
.\"O into an argz vector
.\"O .RI (* argz ,\  *argz_len )
.\"O by breaking it up at every occurrence of the separator
.\"O .IR sep .
.BR argz_create_sep ()
は、NULL 終端された文字列
.I str
を区切り文字
.I sep
が現れる毎に分割しながら、argz vector
.RI (* argz ,\  *argz_len )
に変換する。
.LP
.\"O .BR argz_delete ()
.\"O removes the substring pointed to by
.\"O .I entry
.\"O from the argz vector
.\"O .RI ( *argz ,\  *argz_len )
.\"O and updates
.\"O .I *argz
.\"O and
.\"O .IR *argz_len .
.BR argz_delete ()
は、
.I entry
で指し示された文字列を argz vector
.RI ( *argz ,\  *argz_len )
から削除し、
.I *argz
と
.I *argz_len
を更新する。
.LP
.\"O .BR argz_extract ()
.\"O is the opposite of
.\"O .BR argz_create ().
.\"O It takes the argz vector
.\"O .RI ( argz ,\  argz_len )
.\"O and fills the array starting at
.\"O .I argv
.\"O with pointers to the substrings, and a final NULL,
.\"O making a UNIX-style argv vector.
.\"O The array
.\"O .I argv
.\"O must have room for
.\"O .IR argz_count ( argz , argz_len ") + 1"
.\"O pointers.
.BR argz_extract ()
は
.BR argz_create ()
の反対の操作を行う。argz vector
.RI ( argz ,\  argz_len )
を調べ、
.I argv
から始まる配列をサブ文字列へのポインタで埋めていき、
一番最後に NULL を入れて、UNIX 流の argv ベクトルを作成する。
配列
.I argv
は
.IR argz_count ( argz , argz_len ") + 1"
個のポインタを収容できる空間を持っていなければならない。
.LP
.\"O .BR argz_insert ()
.\"O is the opposite of
.\"O .BR argz_delete ().
.\"O It inserts the argument
.\"O .I entry
.\"O at position
.\"O .I before
.\"O into the argz vector
.\"O .RI ( *argz ,\  *argz_len )
.\"O and updates
.\"O .I *argz
.\"O and
.\"O .I *argz_len .
.\"O If
.\"O .I before
.\"O is NULL, then
.\"O .I entry
.\"O will inserted at the end.
.BR argz_insert ()
は
.BR argz_delete ()
の反対の操作を行う。argz vector
.RI ( *argz ,\  *argz_len )
の位置
.I before
に引き数
.I entry
を挿入し、
.I *argz
と
.I *argz_len
を更新する。
.I before
が NULL の場合、
.I entry
は末尾に挿入される。
.LP
.\"O .BR argz_next ()
.\"O is a function to step trough the argz vector.
.\"O If
.\"O .I entry
.\"O is NULL, the first entry is returned.
.\"O Otherwise, the entry
.\"O following is returned.
.\"O It returns NULL if there is no following entry.
.BR argz_next ()
は argz vector を順番に調べるための関数である。
.I entry
が NULL の場合、最初のエントリを返す。
そうでない場合、次のエントリを返す。
次のエントリがない場合、NULL を返す。
.LP
.\"O .BR argz_replace ()
.\"O replaces each occurrence of
.\"O .I str
.\"O with
.\"O .IR with ,
.\"O reallocating argz as necessary.
.\"O If
.\"O .I replace_count
.\"O is non-NULL,
.\"O .I *replace_count
.\"O will be incremented by the number of replacements.
.BR argz_replace ()
は、
.I str
をすべて
.I with
で置き換える (必要に応じて argz の再割り当てを行う)。
.I replace_count
が NULL でない場合、
.I *replace_count
を置き換えを行った数だけ増やす。
.LP
.\"O .BR argz_stringify ()
.\"O is the opposite of
.\"O .BR argz_create_sep ().
.\"O It transforms the argz vector into a normal string by replacing
.\"O all null bytes (\\(aq\\0\\(aq) except the last by
.\"O .IR sep .
.BR argz_stringify ()
は
.BR argz_create_sep ()
の反対の操作を行う。
末尾の NULL バイト以外の全ての NULL バイト (\\(aq\\0\\(aq) を
.I sep
で置き換えて、
argz vector を通常の文字列に変換する。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O All argz functions that do memory allocation have a return type of
.\"O \fIerror_t\fP, and return 0 for success, and \fBENOMEM\fP
.\"O if an allocation error occurs.
メモリ割り当てを行う argz 関数群はすべて \fIerror_t\fP 型の返り値を持つ。
成功した場合は 0 を返し、割り当てエラーが発生した場合は
\fBENOMEM\fP を返す。
.\"O .SH CONFORMING TO
.SH 準拠
.\"O These functions are a GNU extension.
.\"O Handle with care.
これらの関数は GNU による拡張である。注意して使用すること。
.\"O .SH BUGS
.SH バグ
.\"O Argz vectors without a terminating null byte may lead to
.\"O Segmentation Faults.
NULL バイトで終端されていない argz vector を使用した場合、
segmentation fault を起こすかもしれない。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR envz_add (3)

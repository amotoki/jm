.\" Copyright 2000 Nicolas Lichtmaier <nick@debian.org>
.\" Created 2000-07-22 00:52-0300
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" Modified 2002-07-23 19:21:35 CEST 2002 Walter Harms
.\" <walter.harms@informatik.uni-oldenburg.de>
.\"
.\" Modified 2003-04-04, aeb
.\"
.\" Japanese Version Copyright (c) 2000-2004 Yuichi SATO
.\"         all rights reserved.
.\" Translated Sun Sep 24 06:18:14 JST 2000
.\"         by Yuichi SATO <sato@complex.eng.hokudai.ac.jp>
.\" Updated & Modified Sun Sep  7 13:20:43 JST 2003
.\"         by Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated & Modified Sat Jan 17 01:27:31 JST 2004 by Yuichi SATO
.\"
.\"WORD:	encrypt		暗号化
.\"WORD:	decrypt		復号化
.\"
.TH ENCRYPT 3 2003-04-04 "" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O encrypt, setkey, encrypt_r, setkey_r \- encrypt 64-bit messages
encrypt, setkey, encrypt_r, setkey_r \- 64 ビットのメッセージを暗号化する
.\"O .SH SYNOPSIS
.SH 書式
.\"O .BR "#define _XOPEN_SOURCE" "       /* See feature_test_macros(7) */"
.BR "#define _XOPEN_SOURCE" "       /* feature_test_macros(7) 参照 */"
.br
.B #include <unistd.h>
.sp
.BI "void encrypt(char " block "[64], int " edflag );
.sp
.\"O .BR "#define _XOPEN_SOURCE" "       /* See feature_test_macros(7) */"
.BR "#define _XOPEN_SOURCE" "       /* feature_test_macros(7) 参照 */"
.br
.B #include <stdlib.h>
.sp
.BI "void setkey(const char *" key );
.sp
.\"O .BR "#define _GNU_SOURCE" "         /* See feature_test_macros(7) */"
.BR "#define _GNU_SOURCE" "         /* feature_test_macros(7) 参照 */"
.br
.B #include <crypt.h>
.sp
.BI "void setkey_r(const char *" key ", struct crypt_data *" data );
.br
.BI "void encrypt_r(char *" block ", int " edflag \
", struct crypt_data *" data );
.sp
.\"O Each of these requires linking with \fI\-lcrypt\fP.
これらの関数は \fI\-lcrypt\fP でリンクする必要がある。
.\"O .SH DESCRIPTION
.SH 説明
.\"O These functions encrypt and decrypt 64-bit messages.
.\"O The
.\"O .BR setkey ()
.\"O function sets the key used by
.\"O .BR encrypt ().
これらの関数は、64 ビットのメッセージの暗号化と復号化を行う。
.BR setkey ()
関数は
.BR encrypt ()
によって使われる暗号鍵を設定する。
.\"O The
.\"O .I key
.\"O argument used here is an array of 64 bytes, each of which has
.\"O numerical value 1 or 0.
.\"O The bytes key[n] where n=8*i-1 are ignored,
.\"O so that the effective key length is 56 bits.
ここで使われる引き数
.I key
は 64 バイトの配列であり、各バイトは数値 1 または 0 である。
n=8*i-1 に対するバイト key[n] は無視されるので、
有効な暗号鍵の長さは 56 ビットになる。
.PP
.\"O The
.\"O .BR encrypt ()
.\"O function modifies the passed buffer, encoding if
.\"O .I edflag
.\"O is 0, and decoding if 1 is being passed.
.\"O Like the
.\"O .I key
.\"O argument, also
.\"O .I block
.\"O is a bit vector representation of the actual value that is encoded.
.\"O The result is returned in that same vector.
.BR encrypt ()
関数は、
.I edflag
が 0 の場合は暗号化し、1 が渡された場合は復号化するというように、
渡されたバッファを変更する。
引き数
.I key
と同様に、
.I block
はエンコードされた実際の値を表現するビットの配列である。
結果はこの同じ配列を使って返される。
.PP
.\"O These two functions are not reentrant, that is, the key data is
.\"O kept in static storage.
.\"O The functions
.\"O .BR setkey_r ()
.\"O and
.\"O .BR encrypt_r ()
.\"O are the reentrant versions.
.\"O They use the following
.\"O structure to hold the key data:
これら 2 つの関数はリエントラント (reentrant) ではない。
つまり暗号鍵データは静的な領域に保存される。
関数
.BR setkey_r ()
と
.BR encrypt_r ()
はリエントラントなバージョンである。
これらの関数は暗号鍵データを保持するために以下のような構造体を使う。
.in +4n
.nf

struct crypt_data {
    char     keysched[16 * 8];
    char     sb0[32768];
    char     sb1[32768];
    char     sb2[32768];
    char     sb3[32768];
    char     crypt_3_buf[14];
    char     current_salt[2];
    long int current_saltbits;
    int      direction;
    int      initialized;
};
.fi
.in
.PP
.\"O Before calling
.\"O .BR setkey_r ()
.\"O set
.\"O .I data\->initialized
.\"O to zero.
.BR setkey_r ()
を呼び出す前には、
.I data\->initialized
を 0 に設定すること。
.\"O .SH "RETURN VALUES"
.SH 返り値
.\"O These functions do not return any value.
これらの関数は、なにも値を返さない。
.\"O .SH ERRORS
.SH エラー
.\"O Set
.\"O .I errno
.\"O to zero before calling the above functions.
上記の関数を呼び出す前に
.I errno
を 0 に設定すること。
.\"O On success, it is unchanged.
成功した場合、この値は変更されない。
.TP
.B ENOSYS
.\"O The function is not provided.
.\"O (For example because of former USA export restrictions.)
(例えば以前のアメリカ合衆国輸出規制などにより)
この関数が提供されていない。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O The functions
.\"O .BR encrypt ()
.\"O and
.\"O .BR setkey ()
.\"O conform to SVr4, SUSv2, and POSIX.1-2001.
関数
.BR encrypt ()
と
.BR setkey ()
は SVr4, SUSv2, and POSIX.1-2001 に準拠する。
.\"O The functions
.\"O .BR encrypt_r ()
.\"O and
.\"O .BR setkey_r ()
.\"O are GNU extensions.
関数
.BR encrypt_r ()
と
.BR setkey_r ()
は GNU 拡張である。
.\"O .SH NOTES
.SH 注意
.\"O In glibc 2.2 these functions use the DES algorithm.
glibc 2.2 では、これらの関数は DES アルゴリズムを使う。
.\"O .SH EXAMPLE
.SH 例
.\"O You need to link with libcrypt to compile this example with glibc.
.\"O To do useful work the
.\"O .I key[]
.\"O and
.\"O .I txt[]
.\"O arrays must be filled with a useful bit pattern.
この例を glibc でコンパイルするには libcrypt とリンクする必要がある。
実際に動作させるためには、配列
.I key[]
と
.I txt[]
に有効なビットパターンを指定しなければならない。
.sp
.nf
#define _XOPEN_SOURCE
#include <unistd.h>
#include <stdlib.h>

int
main(void)
{
    char key[64];      /* bit pattern for key */
    char txt[64];      /* bit pattern for messages */

    setkey(key);
    encrypt(txt, 0);   /* encode */
    encrypt(txt, 1);   /* decode */
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR cbc_crypt (3),
.BR crypt (3),
.BR ecb_crypt (3)
.\" .BR fcrypt (3)

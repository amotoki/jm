.\" Copyright (c) 1999 Andries Brouwer (aeb@cwi.nl)
.\"
.\" This is free documentation; you can redistribute it and/or
.\" modify it under the terms of the GNU General Public License as
.\" published by the Free Software Foundation; either version 2 of
.\" the License, or (at your option) any later version.
.\"
.\" The GNU General Public License's references to "object code"
.\" and "executables" are to be interpreted as the output of any
.\" document formatting or typesetting system, including
.\" intermediate and printed output.
.\"
.\" This manual is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public
.\" License along with this manual; if not, write to the Free
.\" Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111,
.\" USA.
.\"
.\"
.\" Earlier versions of this page influenced the present text.
.\" It was derived from a Berkeley page with version
.\"       @(#)printf.3    6.14 (Berkeley) 7/30/91
.\" converted for Linux by faith@cs.unc.edu, updated by
.\" Helmut.Geyer@iwr.uni-heidelberg.de, agulbra@troll.no and Bruno Haible.
.\"
.\" 1999-11-25 aeb - Rewritten, using SUSv2 and C99.
.\" 2000-07-26 jsm28@hermes.cam.ac.uk - three small fixes
.\" 2000-10-16 jsm28@hermes.cam.ac.uk - more fixes
.\"
.\" Japanese Version Copyright (c) 1997 YOSHINO Takashi all rights reserved.
.\" Translated 1998-02-17, YOSHINO Takashi <yoshino@civil.jcn.nihon-u.ac.jp>
.\" Updated 2000-10-02, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2001-01-29, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2002-01-03, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2002-10-17, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-03-15, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2006-07-20, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2008-02-10, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.77
.\" Updated 2009-03-03, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.19
.\"
.\" WORD: conversion specifier	変換指定子
.\" WORD: length modifier	長さ修飾子
.\"
.TH PRINTF 3  2011-09-28 "GNU" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf,
.\"O vsnprintf \- formatted output conversion
printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf,
vsnprintf \- 指定された書式に変換して出力を行う
.\"O .SH SYNOPSIS
.SH 書式
.B #include <stdio.h>
.sp
.BI "int printf(const char *" format ", ...);"
.br
.BI "int fprintf(FILE *" stream ", const char *" format ", ...);"
.br
.BI "int sprintf(char *" str ", const char *" format ", ...);"
.br
.BI "int snprintf(char *" str ", size_t " size ", const char *" format ", ...);"
.sp
.B #include <stdarg.h>
.sp
.BI "int vprintf(const char *" format ", va_list " ap );
.br
.BI "int vfprintf(FILE *" stream ", const char *" format ", va_list " ap );
.br
.BI "int vsprintf(char *" str ", const char *" format ", va_list " ap );
.br
.BI "int vsnprintf(char *" str ", size_t " size ", const char *" format \
", va_list " ap );
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.ad l
.BR snprintf (),
.BR vsnprintf ():
.RS 4
_BSD_SOURCE || _XOPEN_SOURCE\ >=\ 500 || _ISOC99_SOURCE ||
_POSIX_C_SOURCE\ >=\ 200112L;
.br
or
.I "cc -std=c99"
.RE
.ad
.\"O .SH DESCRIPTION
.SH 説明
.\"O The functions in the
.\"O .BR printf ()
.\"O family produce output according to a
.\"O .I format
.\"O as described below.
.BR printf ()
関数グループは、以下で述べるように、
.I format
に従って出力を生成するものである。
.\"O The functions
.\"O .BR printf ()
.\"O and
.\"O .BR vprintf ()
.\"O write output to
.\"O .IR stdout ,
.\"O the standard output stream;
.\"O .BR fprintf ()
.\"O and
.\"O .BR vfprintf ()
.\"O write output to the given output
.\"O .IR stream ;
.\"O .BR sprintf (),
.\"O .BR snprintf (),
.\"O .BR vsprintf ()
.\"O and
.\"O .BR vsnprintf ()
.\"O write to the character string
.\"O .IR str .
.BR printf ()
と
.BR vprintf ()
は出力を
.I stdout
(標準出力ストリーム) に書き出す。
.BR fprintf ()
と
.BR vfprintf ()
は出力を指定された出力
.I stream
に書き出す。
.BR sprintf (),
.BR snprintf (),
.BR vsprintf (),
.BR vsnprintf ()
は出力を文字列
.IR str
に書き込む。
.PP
.\"O The functions
.\"O .BR snprintf ()
.\"O and
.\"O .BR vsnprintf ()
.\"O write at most
.\"O .I size
.\"O bytes (including the terminating null byte (\(aq\e0\(aq)) to
.\"O .IR str .
.BR snprintf ()
と
.BR vsnprintf ()
は最大で
.I size
バイトを
.I str
に書き込む
.RI ( size
には文字列を終端する NULL バイト (\(aq\e0\(aq) もを含まれる)。
.PP
.\"O The functions
.\"O .BR vprintf (),
.\"O .BR vfprintf (),
.\"O .BR vsprintf (),
.\"O .BR vsnprintf ()
.\"O are equivalent to the functions
.\"O .BR printf (),
.\"O .BR fprintf (),
.\"O .BR sprintf (),
.\"O .BR snprintf (),
.\"O respectively, except that they are called with a
.\"O .I va_list
.\"O instead of a variable number of arguments.
.\"O These functions do not call the
.\"O .I va_end
.\"O macro.
.\"O Because they invoke the
.\"O .I va_arg
.\"O macro, the value of
.\"O .I ap
.\"O is undefined after the call.
.\"O See
.\"O .BR stdarg (3).
.BR vprintf (),
.BR vfprintf (),
.BR vsprintf (),
.BR vsnprintf ()
の各関数はそれぞれ
.BR printf (),
.BR fprintf (),
.BR sprintf (),
.BR snprintf (),
の各関数と等価であり、可変数引き数の代わりに
.I va_list
を引き数として呼び出される点だけが異なる。
これらの関数では
.I va_end
マクロは呼び出されない。
これらの関数は
.I va_arg
を呼び出すので、呼び出し後の
.I ap
の値は未定義である。
.BR stdarg (3)
を参照のこと。
.PP
.\"O These eight functions write the output under the control of a
.\"O .I format
.\"O string that specifies how subsequent arguments (or arguments accessed via
.\"O the variable-length argument facilities of
.\"O .BR stdarg (3))
.\"O are converted for output.
これらの 8 つの関数は
.I format
文字列の制御に従って出力を書き出す。
.I format
文字列は、これに続く引き数 (または
.BR stdarg (3)
の可変長引き数機構を使ってアクセスできる引き数)
をどのように変換して出力するかを指定する。

.\"O C99 and POSIX.1-2001 specify that the results are undefined if a call to
.\"O .BR sprintf (),
.\"O .BR snprintf (),
.\"O .BR vsprintf (),
.\"O or
.\"O .BR vsnprintf ()
.\"O would cause copying to take place between objects that overlap
.\"O (e.g., if the target string array and one of the supplied input arguments
.\"O refer to the same buffer).
.\"O See NOTES.
C99 と POSIX.1-2001 では、
.BR sprintf (),
.BR snprintf (),
.BR vsprintf (),
.BR vsnprintf ()
の呼び出しで、範囲が重複するオブジェクト間でコピーが発生する場合の
結果は不定であると規定されている (例えば、出力先の文字列と入力された
引き数の一つが同じバッファを参照している場合などである)。
「注意」の節を参照。
.\"O .SS "Return value"
.SS 返り値
.\"O Upon successful return, these functions return the number of characters
.\"O printed (excluding the null byte used to end output to strings).
成功時には、上記の関数は書き込まれた文字数を返す
(文字列の最後を示すために使用する NULL バイトは数に含まれない)。

.\"O The functions
.\"O .BR snprintf ()
.\"O and
.\"O .BR vsnprintf ()
.\"O do not write more than
.\"O .I size
.\"O bytes (including the terminating null byte (\(aq\e0\(aq)).
.\"O If the output was truncated due to this limit then the return value
.\"O is the number of characters (excluding the terminating null byte)
.\"O which would have been written to the final string if enough space
.\"O had been available.
.\"O Thus, a return value of
.\"O .I size
.\"O or more means that the output was truncated.
.\"O (See also below under NOTES.)
.BR snprintf ()
と
.BR vsnprintf ()
は、
.I size
バイトを越える文字数を書き込まない
.RI ( size
には文字列を終端する NULL バイト (\(aq\e0\(aq) も含まれる)。
この制限によって出力が切り詰められた場合には、
もし十分なスペースがあれば書き込まれたであろう文字の個数
(文字列を終端する NULL バイトを除く) を返す。
従って、返り値が
.I size
以上だった場合、出力が切り詰められたことを意味する
(後述の注意も参照のこと)。

.\"O If an output error is encountered, a negative value is returned.
エラーが発生した場合は、負の数を返す。
.\"O .SS "Format of the format string"
.SS フォーマット文字列のフォーマット
.\"O The format string is a character string, beginning and ending
.\"O in its initial shift state, if any.
フォーマット文字列は文字の列で、
(もしあるなら) 初期シフト状態で始まり、初期シフト状態で終わる。
.\"O The format string is composed of zero or more directives: ordinary
.\"O characters (not
.\"O .BR % ),
.\"O which are copied unchanged to the output stream;
.\"O and conversion specifications, each of which results in fetching zero or
.\"O more subsequent arguments.
フォーマット用の文字列は 0 個以上の命令 (directives) によって構成される。
命令には、通常文字と変換指定 (conversion specifications) がある。
通常文字は
.B %
以外の文字で、出力ストリームにそのままコピーされる。
変換指定は、それぞれが 0 個以上の引き数を取る。
.\"O Each conversion specification is introduced by
.\"O the character
.\"O .BR % ,
.\"O and ends with a
.\"O .IR "conversion specifier" .
各変換指定は文字
.B %
で始まり、
.I "変換指定子 (conversion specifier)"
で終わる。
.\"O In between there may be (in this order) zero or more
.\"O .IR flags ,
.\"O an optional minimum
.\"O .IR "field width" ,
.\"O an optional
.\"O .I precision
.\"O and an optional
.\"O .IR "length modifier" .
.B %
と変換指定子の間には、0 個以上の
.I フラグ 、
最小
.I フィールド幅 、
.I 精度 、
.I 長さ修飾子
を (この順序で) 置くことができる。

.\"O The arguments must correspond properly (after type promotion) with the
.\"O conversion specifier.
.\"O By default, the arguments are used in the order
.\"O given, where each \(aq*\(aq and each conversion specifier asks for the next
.\"O argument (and it is an error if insufficiently many arguments are given).
引き数は (型の格上げの後は) 変換指定子が表す型と正確に対応しなければならない。
デフォルトでは、\(aq*\(aq や変換指定子が出てくる毎に次の引き数を要求され、
引き数は指定された順序で使用されていく
(指定された引き数の個数が不十分ならエラーとなる)。
.\"O One can also specify explicitly which argument is taken,
.\"O at each place where an argument is required, by writing "%m$" instead
.\"O of \(aq%\(aq and "*m$" instead of \(aq*\(aq,
.\"O where the decimal integer m denotes
.\"O the position in the argument list of the desired argument, indexed starting
.\"O from 1.
.\"O Thus,
.\"O .in +4n
.\"O .nf
.\"O
.\"O printf("%*d", width, num);
.\"O
.\"O .fi
.\"O .in
.\"O and
.\"O .in +4n
.\"O .nf
.\"O
.\"O printf("%2$*1$d", width, num);
.\"O
.\"O .fi
.\"O .in
また、引き数が必要な箇所で \(aq%\(aq の代わりに "%m$"、
\(aq*\(aqの代わりに "*m$" と書くことで、
明示的にどの引き数を使用するかを指定することもできる。
ここで 10進の整数 m は希望の引き数の引き数リストでの位置を示す
(最初の引き数の番号が 1 である)。
従って、以下の二つは等価である。
.in +4n
.nf

printf("%*d", width, num);

printf("%2$*1$d", width, num);

.fi
.in
は等価である。
.\"O are equivalent.
.\"O The second style allows repeated references to the
.\"O same argument.
.\"O The C99 standard does not include the style using \(aq$\(aq,
.\"O which comes from the Single UNIX Specification.
.\"O If the style using
.\"O \(aq$\(aq is used, it must be used throughout for all conversions taking an
.\"O argument and all width and precision arguments, but it may be mixed
.\"O with "%%" formats which do not consume an argument.
.\"O There may be no
.\"O gaps in the numbers of arguments specified using \(aq$\(aq; for example, if
.\"O arguments 1 and 3 are specified, argument 2 must also be specified
.\"O somewhere in the format string.
二番目の書き方では同じ引き数を繰り返し参照することができる。
C99 標準には、 Single UNIX Specification 由来の \(aq$\(aq を使った書き方は含まれていない。
\(aq$\(aq を使ったスタイルを使うと、引き数を取る変換及び幅と精度の引き数を
全てこのスタイルで指定しなければならないが、
引き数を消費しない "%%" フォーマットと混ざっているかもしれない。
\(aq$\(aq で指定される引き数の番号に空きがあってはならない。
例えば、もし引き数 1 と 3 が指定されると、引き数 2 もフォーマット文字列のどこかで
指定されなければならない。

.\"O For some numeric conversion a radix character ("decimal point") or
.\"O thousands' grouping character is used.
.\"O The actual character used
.\"O depends on the
.\"O .B LC_NUMERIC
.\"O part of the locale.
.\"O The POSIX locale
.\"O uses \(aq.\(aq as radix character, and does not have a grouping character.
数値変換には小数点や 1000 単位の区切り文字を使うものもある。
実際にどの文字を使うかはロケールの
.B LC_NUMERIC
による。
POSIX ロケールでは小数点に \(aq.\(aq を用い、
区切り文字は使わない。
.\"O Thus,
従って、
.in +4n
.nf

printf("%\(aq.2f", 1234567.89);

.fi
.in
.\"O results in "1234567.89" in the POSIX locale, in "1234567,89" in the
.\"O nl_NL locale, and in "1.234.567,89" in the da_DK locale.
は、 POSIX ロケールでは "1234567.89" 、 nl_NL ロケールでは "1234567,89"、
da_DK ロケールでは "1.234.567,89" となる。
.\"O .SS "The flag characters"
.SS フラグ文字
.\"O The character % is followed by zero or more of the following flags:
% 文字の後ろには 0 個以上のフラグ文字が続く。
.TP
.\"O .B #
.\"O The value should be converted to an "alternate form".
.B #
値は「別の形式」に変換される。
.\"O For
.\"O .B o
.\"O conversions, the first character of the output string is made zero
.\"O (by prefixing a 0 if it was not zero already).
.B o
変換の場合、(先頭文字が 0 になっていない場合に先頭に 0 を追加することで)
出力文字列の最初の文字を 0 にする。
.\"O For
.\"O .B x
.\"O and
.\"O .B X
.\"O conversions, a nonzero result has the string "0x" (or "0X" for
.\"O .B X
.\"O conversions) prepended to it.
.B x
と
.B X
変換の場合、数値が 0 でないときには文字列 "0x"
.RB ( X
変換の場合には "0X") が前に付与される。
.\"O For
.\"O .BR a ,
.\"O .BR A ,
.\"O .BR e ,
.\"O .BR E ,
.\"O .BR f ,
.\"O .BR F ,
.\"O .BR g ,
.\"O and
.\"O .B G
.\"O conversions, the result will always contain a decimal point, even if no
.\"O digits follow it (normally, a decimal point appears in the results of those
.\"O conversions only if a digit follows).
.\"O For
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.BR F ,
.BR g ,
.B G
変換では、 小数点に続く数字がなくても、
出力には常に小数点が含まれる
(通常は、小数点の後に数字が続く場合にのみ、
小数点が表示される)。
.\"O .B g
.\"O and
.\"O .B G
.\"O conversions, trailing zeros are not removed from the result as they would
.\"O otherwise be.
.B g
と
.B G
変換の場合、他の変換とは異なり、末尾のゼロが変換結果から削除されない。
.\"O For other conversions, the result is undefined.
その他の変換では、結果は未定義である。
.TP
.B \&0
.\"O The value should be zero padded.
.\"O For
.\"O .BR d ,
.\"O .BR i ,
.\"O .BR o ,
.\"O .BR u ,
.\"O .BR x ,
.\"O .BR X ,
.\"O .BR a ,
.\"O .BR A ,
.\"O .BR e ,
.\"O .BR E ,
.\"O .BR f ,
.\"O .BR F ,
.\"O .BR g ,
.\"O and
.\"O .B G
.\"O conversions, the converted value is padded on the left with zeros rather
.\"O than blanks.
値をゼロで埋める。
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
.BR X ,
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.BR F ,
.BR g ,
.B G
変換では、変換した値の左側を空白文字の代わりにゼロで埋める。
.\"O If the
.\"O .B \&0
.\"O and
.\"O .B \-
.\"O flags both appear, the
.\"O .B \&0
.\"O flag is ignored.
.B \&0
と
.B \-
が両方とも指定された場合は、
.B \&0
フラグは無視される。
.\"O If a precision is given with a numeric conversion
.\"O .RB ( d ,
.\"O .BR i ,
.\"O .BR o ,
.\"O .BR u ,
.\"O .BR x ,
.\"O and
.\"O .BR X ),
.\"O the
.\"O .B \&0
.\"O flag is ignored.
精度が数値変換
.RB ( d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
.BR X )
と同時に指定された場合には、
.B \&0
フラグは無視される。
.\"O For other conversions, the behavior is undefined.
その他の変換では、動作は未定義である。
.TP
.B \-
.\"O The converted value is to be left adjusted on the field boundary.
.\"O (The default is right justification.)
.\"O Except for
.\"O .B n
.\"O conversions, the converted value is padded on the right with blanks, rather
.\"O than on the left with blanks or zeros.
.\"O A
変換値をフィールド境界で左揃えにする
(デフォルトは右揃えである)。
.B n
変換以外では、変換された値は
左側ではなく右側を空白文字やゼロで埋められる。
.\"O .B \-
.\"O overrides a
.\"O .B \&0
.\"O if both are given.
.B \-
と
.B \&0
の両方が指定された場合には、
.B \-
が優先される。
.TP
.\"O .B \(aq \(aq
.B ' '
.\"O (a space) A blank should be left before a positive number
.\"O (or empty string) produced by a signed conversion.
(1個の半角スペース)
符号付き変換で生成された正の数字の前に空白 (または空文字列) が置かれる。
.TP
.\"O .B +
.\"O A sign (+ or \-) should always be placed before a number produced by a signed
.\"O conversion.
.\"O By default a sign is used only for negative numbers.
.\"O A
.\"O .B +
.\"O overrides a space if both are used.
.B +
符号付き変換によって出力される数字の前に、常に符号 (+ か \-) が置かれる。
デフォルトでは、符号は負の数字の場合のみ付与される。
.B +
と半角スペースの
両方が使われている場合には、
.B +
が優先される。
.PP
.\"O The five flag characters above are defined in the C standard.
.\"O The SUSv2 specifies one further flag character.
上記の 5 つのフラグは C 標準で定義されている。
SUSv2 では、さらにもう一つフラグ文字が規定されている。
.TP
.B \(aq
.\"O For decimal conversion
.\"O .RB ( i ,
.\"O .BR d ,
.\"O .BR u ,
.\"O .BR f ,
.\"O .BR F ,
.\"O .BR g ,
.\"O .BR G )
.\"O the output is to be grouped with thousands' grouping characters
.\"O if the locale information indicates any.
.\"O Note that many versions of
.\"O .BR gcc (1)
.\"O cannot parse this option and will issue a warning.
.\"O SUSv2 does not
.\"O include %\(aqF.
10進数変換
.RB ( i ,
.BR d ,
.BR u ,
.BR f ,
.BR F ,
.BR g ,
.BR G )
において、ロケール情報に指定があれば 1000 単位の区切り文字を出力する。
.BR gcc (1)
の多くのバージョンは、このオプションを解釈することができず、
警告を出力することに注意せよ。
%\(aqF は SUSv2 には含まれていない。
.PP
.\"O glibc 2.2 adds one further flag character.
glibc 2.2 では、さらに一つフラグ文字が追加されている。
.TP
.B I
.\"O For decimal integer conversion
.\"O .RB ( i ,
.\"O .BR d ,
.\"O .BR u )
.\"O the output uses the locale's alternative output digits, if any.
.\"O For example, since glibc 2.2.3 this will give Arabic-Indic digits
.\"O in the Persian ("fa_IR") locale.
.\"O .\" outdigits keyword in locale file
10進整数変換
.RB ( i ,
.BR d ,
.BR u )
において、ロケールの代替出力数字があれば、それを用いて出力する。
例えば、 glibc 2.2.3 以降では、ペルシア ("fa_IR") ロケールで
アラビア数字 (Arabic-Indic digits) を出力できる。
.\" ロケールファイルには outdigits というキーワードがある。
.\"O .SS "The field width"
.SS フィールド幅
.\"O An optional decimal digit string (with nonzero first digit) specifying
.\"O a minimum field width.
.\"O If the converted value has fewer characters
.\"O than the field width, it will be padded with spaces on the left
.\"O (or right, if the left-adjustment flag has been given).
最小のフィールド幅を指定する 10進数の数値文字列 (文字列の最初の文字は
ゼロ以外)。本項目はオプションである。
変換された値の文字数がフィールド長よりも少ない場合、
フィールドの左側をスペースで埋める
(左揃えのフラグがある場合は右側を埋める)。
.\"O Instead of a decimal digit string one may write "*" or "*m$"
.\"O (for some decimal integer \fIm\fP) to specify that the field width
.\"O is given in the next argument, or in the \fIm\fP-th argument, respectively,
.\"O which must be of type
.\"O .IR int .
10進数の文字列の代わりに "*" や "*m$" (\fIm\fP は 10進整数) を書くこともできる。
"*" と "*m$" はそれぞれ、次の引き数と \fIm\fP 番目の引き数をフィールド幅として
使うことを指定する (これらの引き数は
.I int
型でなければならない)。
.\"O A negative field width is taken as a \(aq\-\(aq flag followed by a
.\"O positive field width.
フィールド幅に負の数が指定された場合は、
\(aq\-\(aq フラグと正の数のフィールド幅として扱われる。
.\"O In no case does a nonexistent or small field width cause truncation of a
.\"O field; if the result of a conversion is wider than the field width, the
.\"O field is expanded to contain the conversion result.
フィールド幅が小さかったり指定がなかったりしても、フィールドが切り詰められる
ことはない。もし変換結果がフィールド幅よりも広かった場合、
フィールドは変換結果が入る幅に広げられる。
.\"O .SS "The precision"
.SS 精度
.\"O An optional precision, in the form of a period (\(aq.\(aq)  followed by an
.\"O optional decimal digit string.
オプションである精度は、ピリオド (\(aq.\(aq) とそれに続く10進数という
形式で指定する (10進数はオプション) 。
.\"O Instead of a decimal digit string one may write "*" or "*m$"
.\"O (for some decimal integer m) to specify that the precision
.\"O is given in the next argument, or in the m-th argument, respectively,
.\"O which must be of type
.\"O .IR int .
10進数の文字列の代わりに "*" や "*m$" (m は 10 進整数)を書くこともできる。
"*" と "*m$" はそれぞれ、次の引き数と m 番目の引き数を精度として
使うことを指定する (これらの引き数は
.I int
型でなければならない)。
.\"O If the precision is given as just \(aq.\(aq, or the precision is negative,
.\"O the precision is taken to be zero.
精度として \(aq.\(aq だけが指定されたり、精度が負の数だった場合、
精度はゼロとみなされる。
.\"O This gives the minimum number of digits to appear for
.\"O .BR d ,
.\"O .BR i ,
.\"O .BR o ,
.\"O .BR u ,
.\"O .BR x ,
.\"O and
.\"O .B X
.\"O conversions, the number of digits to appear after the radix character for
.\"O .BR a ,
.\"O .BR A ,
.\"O .BR e ,
.\"O .BR E ,
.\"O .BR f ,
.\"O and
.\"O .B F
.\"O conversions, the maximum number of significant digits for
.\"O .B g
.\"O and
.\"O .B G
.\"O conversions, or the maximum number of characters to be printed from a
.\"O string for
.\"O .B s
.\"O and
.\"O .B S
.\"O conversions.
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
.B X
変換では、表示される最小の桁数を指定する。
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.B F
変換では、小数点以下に表示される数字の桁数を指定する。
.B g
と
.B G
変換では、有効数字の最大桁数を指定する。
.B s
と
.B S
変換では、文字列から出力される最大文字数を指定する。
.\"O .SS "The length modifier"
.SS 長さ修飾子
.\"O Here, "integer conversion" stands for
.\"O .BR d ,
.\"O .BR i ,
.\"O .BR o ,
.\"O .BR u ,
.\"O .BR x ,
.\"O or
.\"O .B X
.\"O conversion.
「整数変換」とは、
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
.B X
変換のことである。
.TP
.B hh
.\"O A following integer conversion corresponds to a
.\"O .I signed char
.\"O or
.\"O .I unsigned char
.\"O argument, or a following
.\"O .B n
.\"O conversion corresponds to a pointer to a
.\"O .I signed char
.\"O argument.
整数変換に対応する引き数が
.I signed char
か
.I unsigned char
で、
.B n
変換に対応する引き数が
.I signed char
へのポインタであることを示す。
.TP
.B h
.\"O A following integer conversion corresponds to a
.\"O .I short int
.\"O or
.\"O .I unsigned short int
.\"O argument, or a following
.\"O .B n
.\"O conversion corresponds to a pointer to a
.\"O .I short int
.\"O argument.
整数変換に対応する引き数が
.I short int
か
.I unsigned short int
で、
.B n
変換に対応する引き数が
.I short int
へのポインタであることを示す。
.TP
.\"O .B l
.\"O (ell) A following integer conversion corresponds to a
.\"O .I long int
.\"O or
.\"O .I unsigned long int
.\"O argument, or a following
.\"O .B n
.\"O conversion corresponds to a pointer to a
.\"O .I long long int
.\"O argument, or a following
.\"O .B c
.\"O conversion corresponds to a
.\"O .I wint_t
.\"O argument, or a following
.\"O .B s
.\"O conversion corresponds to a pointer to
.\"O .I wchar_t
.\"O argument.
.BR l " (エル)"
各変換に対応する引き数が、
整数変換では
.IR "long int" か
.IR "unsigned long int" 、
.B n
変換では
.I long long int
へのポインタ、
.B c
変換では
.IR wint_t 、
.B s
変換では
.I wchar_t
へのポインタであることを示す。

.TP
.\"O .B ll
.\"O (ell-ell).
.\"O A following integer conversion corresponds to a
.\"O .I long long int
.\"O or
.\"O .I unsigned long long int
.\"O argument, or a following
.\"O .B n
.\"O conversion corresponds to a pointer to a
.\"O .I long int
.\"O argument.
.BR ll " (エルエル)"
整数変換に対応する引き数が
.I long long int
か
.I unsigned long long int
で、
.B n
変換に対応する引き数が
.I long int
へのポインタであることを示す。
.TP
.B L
.\"O A following
.\"O .BR a ,
.\"O .BR A ,
.\"O .BR e ,
.\"O .BR E ,
.\"O .BR f ,
.\"O .BR F ,
.\"O .BR g ,
.\"O or
.\"O .B G
.\"O conversion corresponds to a
.\"O .I long double
.\"O argument.
.BR a ,
.BR A ,
.BR e ,
.BR E ,
.BR f ,
.BR F ,
.BR g ,
.B G
変換に対応する引き数が
.I long double
であることを示す。
.\"O (C99 allows %LF, but SUSv2 does not.)
(C99 では %LF を使うことを認めているが、SUSv2 では認められていない。)
.TP
.B q
.\"O ("quad". 4.4BSD and Linux libc5 only.
.\"O Don't use.)
.\"O This is a synonym for
.\"O .BR ll .
("quad"。 4.4BSD と Linux libc5 のみ有効。使ってはならない。)
.B ll
と同じ意味である。
.TP
.B j
.\"O A following integer conversion corresponds to an
.\"O .I intmax_t
.\"O or
.\"O .I uintmax_t
.\"O argument.
整数変換に対応する引き数が
.I intmax_t
か
.I uintmax_t
であることを示す。
.TP
.B z
.\"O A following integer conversion corresponds to a
.\"O .I size_t
.\"O or
.\"O .I ssize_t
.\"O argument.
.\"O (Linux libc5 has
.\"O .B Z
.\"O with this meaning.
.\"O Don't use it.)
整数変換に対応する引き数が
.I size_t
か
.I ssize_t
であることを示す。
(Linux libc5 では、これを指定するのに
.B Z
を用いる。使ってはならない。)
.TP
.B t
.\"O A following integer conversion corresponds to a
.\"O .I ptrdiff_t
.\"O argument.
整数変換に対応する引き数が
.I ptrdiff_t
であることを示す。
.PP
.\"O The SUSv2 only knows about the length modifiers
.\"O .B h
.\"O (in
.\"O .BR hd ,
.\"O .BR hi ,
.\"O .BR ho ,
.\"O .BR hx ,
.\"O .BR hX ,
.\"O .BR hn )
.\"O and
.\"O .B l
.\"O (in
.\"O .BR ld ,
.\"O .BR li ,
.\"O .BR lo ,
.\"O .BR lx ,
.\"O .BR lX ,
.\"O .BR ln ,
.\"O .BR lc ,
.\"O .BR ls )
.\"O and
.\"O .B L
.\"O (in
.\"O .BR Le ,
.\"O .BR LE ,
.\"O .BR Lf ,
.\"O .BR Lg ,
.\"O .BR LG ).
SUSv2 で長さ修飾子として使用できるのは、
.B h
.RB ( hd ,
.BR hi ,
.BR ho ,
.BR hx ,
.BR hX ,
.BR hn ),
.B l
.RB ( ld ,
.BR li ,
.BR lo ,
.BR lx ,
.BR lX ,
.BR ln ,
.BR lc ,
.BR ls ),
.B L
.RB ( Le ,
.BR LE ,
.BR Lf ,
.BR Lg ,
.BR LG )
だけである。
.\"O .SS "The conversion specifier"
.SS 変換指定子
.\"O A character that specifies the type of conversion to be applied.
適用される変換の型を指定する文字。
.PP
.\"O The conversion specifiers and their meanings are:
変換指定子とその意味は以下の通りである。
.TP
.BR d ", " i
.\"O The
.\"O .I int
.\"O argument is converted to signed decimal notation.
.I int
引き数を符号付き 10 進表記に変換する。
.\"O The precision, if any, gives the minimum number of digits
.\"O that must appear; if the converted value requires fewer digits, it is
.\"O padded on the left with zeros.
.\"O The default precision is 1.
精度指定があれば、精度で指定した桁数は必ず出力される。変換後の値が
指定された桁数に足りない場合は、左側が 0 で埋められる。
デフォルトの精度は 1 である。
.\"O When 0 is printed with an explicit precision 0, the output is empty.
0 を表示しようとした時に、明示的に精度として 0 が指定されていると、
出力は空文字列となる。
.TP
.BR o ", " u ", " x ", " X
.\"O The
.\"O .I "unsigned int"
.\"O argument is converted to unsigned octal
.\"O .RB ( o ),
.\"O unsigned decimal
.\"O .RB ( u ),
.\"O or unsigned hexadecimal
.\"O .RB ( x
.\"O and
.\"O .BR X )
.\"O notation.
.I "unsigned int"
引き数を、
符号なし8進数
.RB ( o ),
符号なし10進数
.RB ( u ),
符号なし16進数
.RB ( x
と
.BR X )
に変換する。
.\"O The letters
.\"O .B abcdef
.\"O are used for
.\"O .B x
.\"O conversions; the letters
.\"O .B ABCDEF
.\"O are used for
.\"O .B X
.\"O conversions.
.B x
変換では
.B abcdef
が使用され、
.B X
変換では
.B ABCDEF
が使用される。
.\"O The precision, if any, gives the minimum number of digits
.\"O that must appear; if the converted value requires fewer digits, it is
.\"O padded on the left with zeros.
精度指定があれば、精度で指定した桁数は必ず出力される。変換後の値が
指定された桁数に足りない場合は、左側が 0 で埋められる。
.TP
.BR e ", " E
.\"O The
.\"O .I double
.\"O argument is rounded and converted in the style
.\"O .if \w'\*(Pm'=0 .ds Pm \(+-
.\"O .RB [\-]d \&. ddd e \\*(Pmdd
.\"O where there is one digit before the decimal-point character and the number
.\"O of digits after it is equal to the precision; if the precision is missing,
.\"O it is taken as 6; if the precision is zero, no decimal-point character
.\"O appears.
.\"O An
.I double
引き数を丸めて
.if \w'\*(Pm'=0 .ds Pm \(+-
.RB [\-]d \&. ddd e \\*(Pmdd
の形に変換する。
小数点の前には一桁の数字があり、小数点以下の桁数は精度で指定された
桁数になる。精度は指定されなかった場合 6 とみなされる。
精度が 0 の場合には、小数点以下は表示されない。
.\"O .B E
.\"O conversion uses the letter
.\"O .B E
.\"O (rather than
.\"O .BR e )
.\"O to introduce the exponent.
.B E
変換では、指数を表現するときに
.RB ( e
ではなく)
.B E
が使われる。
.\"O The exponent always contains at least two
.\"O digits; if the value is zero, the exponent is 00.
指数部分は少なくとも 2桁表示される。
つまり、指数の値が 0 の場合には、00 と表示される。
.TP
.BR f ", " F
.\"O The
.\"O .I double
.\"O argument is rounded and converted to decimal notation in the style
.\"O .RB [\-]ddd \&. ddd,
.\"O where the number of digits after the decimal-point character is equal to
.\"O the precision specification.
.I double
引き数を丸めて
.RB [\-]ddd \&. ddd
の形の10進表現に変換する。
小数点の後の桁数は、精度で指定された値となる。
.\"O If the precision is missing, it is taken as
.\"O 6; if the precision is explicitly zero, no decimal-point character appears.
精度が指定されていない場合には 6 として扱われる。
精度として明示的に 0 が指定されたときには、小数点以下は表示されない。
.\"O If a decimal point appears, at least one digit appears before it.
小数点を表示する際には、小数点の前に少なくとも一桁は数字が表示される。

.\"O (The SUSv2 does not know about
.\"O .B F
.\"O and says that character string representations for infinity and NaN
.\"O may be made available.
.\"O The C99 standard specifies "[\-]inf" or "[\-]infinity"
.\"O for infinity, and a string starting with "nan" for NaN, in the case of
.\"O .B f
.\"O conversion, and "[\-]INF" or "[\-]INFINITY" or "NAN*" in the case of
.\"O .B F
.\"O conversion.)
(SUSv2 では、
.B F
は規定されておらず、無限や NaN に関する文字列表現を
行ってもよいことになっている。
 C99 標準では、
.B f
変換では、無限は "[\-]inf" か "[\-]infinity" と表示し、
NaN は文字列の先頭に `nan' をつけて表示するように規定されている。
.B F
変換の場合は "[\-]INF", "[\-]INFINITY", "NAN*" と表示される。)
.TP
.BR g ", " G
.\"O The
.\"O .I double
.\"O argument is converted in style
.\"O .B f
.\"O or
.\"O .B e
.\"O (or
.\"O .B F
.\"O or
.\"O .B E
.\"O for
.\"O .B G
.\"O conversions).
.I double
引き数を
.B f
か
.B e
.RB ( G
変換の場合は
.B F
か
.BR E )
の形式に変換する。
.\"O The precision specifies the number of significant digits.
精度は表示する桁数を指定する。
.\"O If the precision is missing, 6 digits are given; if the precision is zero,
.\"O it is treated as 1.
精度が指定されない場合は、6桁とみなされる。
精度が 0 の場合は、1桁とみなされる。
.\"O Style
.\"O .B e
.\"O is used if the exponent from its conversion is less than \-4 or greater
.\"O than or equal to the precision.
変換される値の指数が、 \-4 より小さいか、精度以上の場合に、
.B e
形式が使用される。
.\"O Trailing zeros are removed from the
.\"O fractional part of the result; a decimal point appears only if it is
.\"O followed by at least one digit.
変換された結果の小数部分の末尾の 0 は削除される。小数点が表示されるのは、
小数点以下に数字が少なくとも一つある場合にだけである。
.TP
.BR a ", " A
.\"O (C99; not in SUSv2) For
.\"O .B a
.\"O conversion, the
.\"O .I double
.\"O argument is converted to hexadecimal notation (using the letters abcdef)
.\"O in the style
.\"O .RB [\-] 0x h \&. hhhh p \\*(Pmd;
.\"O for
.\"O .B A
.\"O conversion the prefix
.\"O .BR 0X ,
.\"O the letters ABCDEF, and the exponent separator
.\"O .B P
.\"O is used.
(C99 にはあるが SUSv2 にはない)
.B a
変換では、
.I double
引き数を (abcdef の文字を使って)
.RB [\-] 0x h \&. hhhh p \\*(Pmd;
形式の 16 進表記に変換する。
.B A
変換では、前置文字列
.BR 0X ,
文字 ABCDEF, 指数文字
.B P
を用いる。
.\"O There is one hexadecimal digit before the decimal point,
.\"O and the number of digits after it is equal to the precision.
小数点の前には 1桁の16進数が置かれ、小数点の後ろの桁数は
精度で指定された値となる。
.\"O The default precision suffices for an exact representation of the value
.\"O if an exact representation in base 2 exists
.\"O and otherwise is sufficiently large to distinguish values of type
.\"O .IR double .
デフォルトの精度は、その値が 2進数で正確に表現できる場合には、
その値を正確に表現できる桁数となる。それ以外の場合は、
.I double
型の値を区別するのに十分な大きさとなる。
.\"O The digit before the decimal point is unspecified for nonnormalized
.\"O numbers, and nonzero but otherwise unspecified for normalized numbers.
.\" motoki 2005/03/19: 合っているかな？
小数点の前の数字は、正規化されていない数の場合はいくつになるか分からない。
正規化された数の場合は、 0 以外の値になるが、いくつになるかは分からない。
.TP
.B c
.\"O If no
.\"O .B l
.\"O modifier is present, the
.\"O .I int
.\"O argument is converted to an
.\"O .IR "unsigned char" ,
.\"O and the resulting character is written.
.B l
修飾子がなければ、
.I int
引き数を
.IR "unsigned char"
に変換して、その結果に対応する文字を出力する。
.\"O If an
.\"O .B l
.\"O modifier is present, the
.\"O .I wint_t
.\"O (wide character) argument is converted to a multibyte sequence by a call
.\"O to the
.\"O .BR wcrtomb (3)
.\"O function, with a conversion state starting in the initial state, and the
.\"O resulting multibyte string is written.
.B l
修飾子があれば、
.I wint_t
(ワイド文字) 引き数を、
.BR wcrtomb (3)
関数を初期シフト状態で呼び出してマルチバイト文字列に変換し、
変換されたマルチバイト文字列を出力する。
.TP
.B s
.\"O If no
.\"O .B l
.\"O modifier is present: The
.\"O .I "const char *"
.\"O argument is expected to be a pointer to an array of character type (pointer
.\"O to a string).
.\"O Characters from the array are written up to (but not
.\"O including) a terminating null byte (\(aq\\0\(aq);
.\"O if a precision is specified, no more than the number specified
.\"O are written.
.\"O If a precision is given, no null byte need be present;
.\"O if the precision is not specified, or is greater than the size of the
.\"O array, the array must contain a terminating null byte.
.B l
修飾子がない場合、
引き数は
.I "const char *"
型で文字型の配列へのポインタ (文字列へのポインタ) であることが
期待されている。配列中の文字は、終端の NULL バイト (\(aq\\0\(aq)
が出てくるまで出力される (終端文字は出力されない)。
精度が指定されていると、指定された字数以上は出力されない。
精度が指定された場合には、終端バイトが存在する必要はない。
精度が指定されていなかったり、精度の値が配列の大きさより大きい場合には、
配列は終端の NULL バイトを含んでいなければならない。

.\"O If an
.\"O .B l
.\"O modifier is present: The
.\"O .I "const wchar_t *"
.\"O argument is expected to be a pointer to an array of wide characters.
.B l
修飾子が指定されている場合、
引き数は
.I "const wchar_t *"
型でワイド文字の配列へのポインタであることが期待されている。
.\"O Wide characters from the array are converted to multibyte characters
.\"O (each by a call to the
.\"O .BR wcrtomb (3)
.\"O function, with a conversion state starting in the initial state before
.\"O the first wide character), up to and including a terminating null
.\"O wide character.
.\"O The resulting multibyte characters are written up to
.\"O (but not including) the terminating null byte.
.\"O If a precision is
.\"O specified, no more bytes than the number specified are written, but
.\"O no partial multibyte characters are written.
.\"O Note that the precision
.\"O determines the number of
.\"O .I bytes
.\"O written, not the number of
.\"O .I wide characters
.\"O or
.\"O .IR "screen positions" .
配列中のワイド文字は (1文字毎に
.BR wcrtomb (3)
を呼び出して) マルチバイト文字に変換される
(最初のワイド文字の変換の前に
.BR wcrtomb ()
のシフト状態を初期状態に戻してから変換は行われる)。
マルチバイト文字への変換は、文字列を終端する NULL ワイド文字が
出てくるまで行われ、終端 NULL ワイド文字も含めて変換される。
結果のマルチバイト文字列は、終端の NULL バイトが出てくるまで
出力される (終端の NULL バイトは出力されない)。
精度が指定された場合、指定されたバイト数以上には出力されない。
但し、マルチバイト文字の一部分だけが出力されることはない。
精度は「バイト」数を指定するものであり、「ワイド文字」数や
「画面での位置」を指定するものではないことに注意。
.\"O The array must contain a terminating null wide character, unless a
.\"O precision is given and it is so small that the number of bytes written
.\"O exceeds it before the end of the array is reached.
精度が指定されていて、さらに出力が配列の末尾に達する前に出力バイト数が
精度の値を超える場合だけは、配列は NULL ワイド文字で終端されていなくてもよい。
それ以外の場合は、必ず配列は NULL ワイド文字で終端されていなければならない。
.TP
.B C
.\"O (Not in C99, but in SUSv2.)
.\"O Synonym for
.\"O .BR lc .
.\"O Don't use.
(C99 にはないが SUSv2 にはある)
.B lc
と同じ。使ってはならない。
.TP
.B S
.\"O (Not in C99, but in SUSv2.)
.\"O Synonym for
.\"O .BR ls .
.\"O Don't use.
(C99 にはないが SUSv2 にはある)
.B ls
と同じ。使ってはならない。
.TP
.B p
.\"O The
.\"O .I "void *"
.\"O pointer argument is printed in hexadecimal (as if by
.\"O .B %#x
.\"O or
.\"O .BR  %#lx ).
.I "void *"
ポインタ引き数を
.RB ( %#x
や
.BR  %#lx
のような) 16 進数で出力する。
.TP
.B n
.\"O The number of characters written so far is stored into the integer
.\"O indicated by the
.\"O .I "int *"
.\"O (or variant) pointer argument.
.\"O No argument is converted.
これまでに出力された文字数を
.I "int *"
(または類似の型) のポインタ引き数が指す整数に保存する。
引き数の変換は行われない。
.TP
.B m
.\"O (Glibc extension.)
.\"O Print output of
.\"O .IR strerror(errno) .
.\"O No argument is required.
(glibc での拡張)
.I strerror(errno)
の出力を表示する。引き数は必要ない。
.TP
.B %
.\"O A \(aq%\(aq is written.
.\"O No argument is converted.
.\"O The complete conversion
.\"O specification is \(aq%%\(aq.
\(aq%\(aq 文字を出力する。変換される引き数は無い。
変換指定全体を書くと "%%" となる。
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O The
.\"O .BR fprintf (),
.\"O .BR printf (),
.\"O .BR sprintf (),
.\"O .BR vprintf (),
.\"O .BR vfprintf (),
.\"O and
.\"O .BR vsprintf ()
.\"O functions conform to C89 and C99.
.BR fprintf (),
.BR printf (),
.BR sprintf (),
.BR vprintf (),
.BR vfprintf (),
.BR vsprintf ()
関数は、C89 と C99 に準拠している。
.\"O The
.\"O .BR snprintf ()
.\"O and
.\"O .BR vsnprintf ()
.\"O functions conform to C99.
.BR snprintf ()
と
.BR vsnprintf ()
は C99 に準拠している。
.PP
.\"O Concerning the return value of
.\"O .BR snprintf (),
.\"O SUSv2 and C99 standard contradict each other: when
.\"O .BR snprintf ()
.\"O is called with
.\"O .IR size =0
.\"O then SUSv2 stipulates an unspecified return value less than 1,
.\"O while C99 allows
.\"O .I str
.\"O to be NULL in this case, and gives the return value (as always)
.\"O as the number of characters that would have been written in case
.\"O the output string has been large enough.
.BR snprintf ()
の返り値を見ると、
SUSv2 と C99 標準は互いに矛盾している。
SUSv2 では、
.BR snprintf ()
が
.IR size =0
で呼び出された場合、 1 未満の値を何か返り値とするように規定している。
一方 C99 では、このような場合
.I str
を NULL とし、返り値として (通常通り) 出力バッファが十分な大きさが
あった場合に出力されるであろう文字数を返す。
.PP
.\"O Linux libc4 knows about the five C standard flags.
.\"O It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
.\"O and the conversions
.\"O \fBc\fP, \fBd\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP,
.\"O \fBg\fP, \fBG\fP, \fBi\fP, \fBn\fP, \fBo\fP, \fBp\fP,
.\"O \fBs\fP, \fBu\fP, \fBx\fP, and \fBX\fP,
.\"O where \fBF\fP is a synonym for \fBf\fP.
Linux libc4 では、 5 つの C 標準のフラグ、
長さ修飾子 \fBh\fP, \fBl\fP, \fBL\fP、変換
\fBc\fP, \fBd\fP, \fBe\fP, \fBE\fP, \fBf\fP, \fBF\fP,
\fBg\fP, \fBG\fP, \fBi\fP, \fBn\fP, \fBo\fP, \fBp\fP,
\fBs\fP, \fBu\fP, \fBx\fP, \fBX\fP
が使える。
但し \fBF\fP は \fBf\fP と同義である。
.\"O Additionally, it accepts \fBD\fP, \fBO\fP, and \fBU\fP as synonyms
.\"O for \fBld\fP, \fBlo\fP, and \fBlu\fP.
.\"O (This is bad, and caused serious bugs later, when
.\"O support for \fB%D\fP disappeared.)
.\"O No locale-dependent radix character,
.\"O no thousands' separator, no NaN or infinity, no "%m$" and "*m$".
また、 \fBD\fP, \fBO\fP, and \fBU\fP を \fBld\fP, \fBlo\fP, and \fBlu\fP
と同じものとして使える
(これはまずい仕様で、 後に \fB%D\fP の対応が打ち切られた時に深刻なバグを
引き起こした)。ロケール依存の小数点、1000 区切り、 NaN と無限、
"%m$" と "*m$" は使えない。
.PP
.\"O Linux libc5 knows about the five C standard flags and the \(aq flag,
.\"O locale, "%m$" and "*m$".
.\"O It knows about the length modifiers \fBh\fP, \fBl\fP, \fBL\fP,
.\"O \fBZ\fP, and \fBq\fP, but accepts \fBL\fP and \fBq\fP
.\"O both for \fIlong double\fP and for \fIlong long int\fP (this is a bug).
Linux libc5 では、 5 つの C 標準のフラグと \(aq フラグ、ロケール、
"%m$" と "*m$" が使える。
また、長さ修飾子 \fBh\fP, \fBl\fP, \fBL\fP, \fBZ\fP, iand \fBq\fP が使えるが、
\fBL\fP と \fBq\fP は両方とも
\fIlong double\fP と \fIlong long int\fP に対応している (これはバグである)。
.\"O It no longer recognizes \fBF\fP, \fBD\fP, \fBO\fP, and \fBU\fP,
.\"O but adds the conversion character
.\"O .BR m ,
.\"O which outputs
.\"O .IR strerror(errno) .
現在では変換 \fBF\fP, \fBD\fP, \fBO\fP, \fBU\fP は認識されないが、変換文字
.B m
が追加された。これは
.I strerror(errno)
を出力するものである。
.PP
.\"O glibc 2.0 adds conversion characters \fBC\fP and \fBS\fP.
glibc 2.0 では、変換文字 \fBC\fP と \fBS\fP が追加された。
.PP
.\"O glibc 2.1 adds length modifiers \fBhh\fP, \fBj\fP, \fBt\fP, and \fBz\fP
.\"O and conversion characters \fBa\fP and \fBA\fP.
glibc 2.1 では、長さ修飾子 \fBhh\fP, \fBj\fP, \fBt\fP, \fBz\fP
と変換文字 \fBa\fP, \fBA\fP が追加された。
.PP
.\"O glibc 2.2 adds the conversion character \fBF\fP with C99 semantics,
.\"O and the flag character \fBI\fP.
glibc 2.2 では、 C99 で規定された意味での変換文字 \fBF\fP と
フラグ文字 \fBI\fP が追加された。
.\"O .SH NOTES
.SH 注意
.\"O Some programs imprudently rely on code such as the following
.\"O 
.\"O     sprintf(buf, "%s some further text", buf);
.\"O 
.\"O to append text to
.\"O .IR buf .
テキストを
.I buf
に追加するのに、軽率にも次のようなコードを使っているプログラムがある。

    sprintf(buf, "%s some further text", buf);

.\"O However, the standards explicitly note that the results are undefined
.\"O if source and destination buffers overlap when calling
.\"O .BR sprintf (),
.\"O .BR snprintf (),
.\"O .BR vsprintf (),
.\"O and
.\"O .BR vsnprintf ().
しかしながら、標準規格では、
.BR sprintf (),
.BR snprintf (),
.BR vsprintf (),
.BR vsnprintf ()
の呼び出しにおいて、コピー元とコピー先のバッファが重なっていた場合の
結果は不定である、と明記されている。
.\" http://sourceware.org/bugzilla/show_bug.cgi?id=7075
.\"O Depending on the version of
.\"O .BR gcc (1)
.\"O used, and the compiler options employed, calls such as the above will
.\"O .B not
.\"O produce the expected results.
使用する
.BR gcc (1)
のバージョンや指定したコンパイラのオプション次第では、
上記のような呼び出しで、期待した結果が得られ「ない」ことがある。

.\"O The glibc implementation of the functions
.\"O .BR snprintf ()
.\"O and
.\"O .BR vsnprintf ()
.\"O conforms to the C99 standard, that is, behaves as described above,
.\"O since glibc version 2.1.
.\"O Until glibc 2.0.6 they would return \-1
.\"O when the output was truncated.
glibc の
.BR snprintf ()
と
.BR vsnprintf ()
の実装は、バージョン 2.1 以降は C99 標準に準拠しており、
上記の通りの動作をする。
glibc 2.0.6 までは、出力が切り詰められた場合は \-1 を返す。
.\"O .\" .SH HISTORY
.\" .SH 歴史
.\"O .\" UNIX V7 defines the three routines
.\"O .\" .BR printf (),
.\"O .\" .BR fprintf (),
.\"O .\" .BR sprintf (),
.\"O .\" and has the flag \-, the width or precision *, the length modifier l,
.\"O .\" and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
.\" UNIX V7 では
.\" .BR printf (),
.\" .BR fprintf (),
.\" .BR sprintf ()
.\" の 3 つの関数と、フラグ \-、幅と精度での *、長さ修飾子 l、
.\" 変換 doxfegcsu、そして ld,ld,lu,lx の同義語として D,O,U,X が定義されている。
.\"O .\" This is still true for 2.9.1BSD, but 2.10BSD has the flags
.\"O .\" #, + and <space> and no longer mentions D,O,U,X.
.\" 2.9.1BSD でもこれは同じだったが、 2.10BSD では
.\" フラグ #, +, 空白が追加され、 D,O,U,X については記載されなくなった。
.\"O .\" 2.11BSD has
.\"O .\" .BR vprintf (),
.\"O .\" .BR vfprintf (),
.\"O .\" .BR vsprintf (),
.\"O .\" and warns not to use D,O,U,X.
.\" 2.11BSD では
.\" .BR vprintf (),
.\" .BR vfprintf (),
.\" .BR vsprintf ()
.\" が追加され、 D,O,U,X を使わないように警告された。
.\"O .\" 4.3BSD Reno has the flag 0, the length modifiers h and L,
.\"O .\" and the conversions n, p, E, G, X (with current meaning)
.\"O .\" and deprecates D,O,U.
.\" 4.3BSD Reno ではフラグ 0、長さ修飾子 h と L、
.\" 変換 n, p, E, G, (現在の意味での) X が追加され、
.\" D,O,U は非推奨扱いとなった。
.\"O .\" 4.4BSD introduces the functions
.\"O .\" .BR snprintf ()
.\"O .\" and
.\"O .\" .BR vsnprintf (),
.\"O .\" and the length modifier q.
.\" 4.4BSD では、関数
.\" .BR snprintf ()と
.\" .BR vsnprintf ()、
.\" 長さ修飾子 q が導入された。
.\"O .\" FreeBSD also has functions
.\"O .\" .BR asprintf ()
.\"O .\" and
.\"O .\" .BR vasprintf (),
.\"O .\" that allocate a buffer large enough for
.\"O .\" .BR sprintf ().
.\" FreeBSD では、
.\" .BR sprintf ()
.\" のために十分なバッファを確保する
.\" .BR asprintf ()
.\" と
.\" .BR vasprintf ()
.\" が追加されている。
.\"O .\" In glibc there are functions
.\"O .\" .BR dprintf ()
.\"O .\" and
.\"O .\" .BR vdprintf ()
.\"O .\" that print to a file descriptor instead of a stream.
.\" glibc には、関数
.\" .BR dprintf (),
.\" .BR vdprintf ()
.\" があり、これらはストリームではなくファイルディスクリプタに出力する。
.\"O .SH BUGS
.SH バグ
.\"O Because
.\"O .BR sprintf ()
.\"O and
.\"O .BR vsprintf ()
.\"O assume an arbitrarily long string, callers must be careful not to overflow
.\"O the actual space; this is often impossible to assure.
.\"O Note that the length
.\"O of the strings produced is locale-dependent and difficult to predict.
.BR sprintf ()
と
.BR vsprintf ()
は勝手に十分に長い文字列領域があると仮定するので、呼び出し側は
実際の領域からあふれないように注意しなければならない。
しかし、これを保証することが不可能な場合が多い。
生成される文字列の長さはロケール依存であり、予測が難しいことに注意。
.\"O Use
.\"O .BR snprintf ()
.\"O and
.\"O .BR vsnprintf ()
.\"O instead (or
.\"O .BR asprintf (3)
.\"O and
.\"O .BR vasprintf (3)).
代わりに
.BR snprintf ()
と
.BR vsnprintf ()
(または
.BR asprintf (3)
と
.BR vasprintf (3))
を使うこと。
.PP
.\"O Linux libc4.[45] does not have a
.\"O .BR snprintf (),
.\"O but provides a libbsd that contains an
.\"O .BR snprintf ()
.\"O equivalent to
.\"O .BR sprintf (),
.\"O that is, one that ignores the
.\"O .I size
.\"O argument.
Linux libc4.[45] には
.BR snprintf ()
はないが、 libbsd が提供されており、
その中には
.BR sprintf ()
と等価な (つまり
.I size
引き数を無視する)
.BR snprintf ()
がある。
.\"O Thus, the use of
.\"O .BR snprintf ()
.\"O with early libc4 leads to serious security problems.
したがって、初期の libc4 で
.BR snprintf ()
を使うと、深刻なセキュリティ問題を引き起こすことがある。
.PP
.\"O Code such as
.\"O .BI printf( foo );
.\"O often indicates a bug, since
.\"O .I foo
.\"O may contain a % character.
.\"O If
.\"O .I foo
.\"O comes from untrusted user input, it may contain \fB%n\fP, causing the
.\"O .BR printf ()
.\"O call to write to memory and creating a security hole.
.BI printf( foo );
のようなコードはしばしばバグを引き起こす。
なぜなら
.I foo
に % 文字が含まれてるかもしれないからである。
.I foo
が信頼できないユーザー入力から作られている場合には、
その中に \fB%n\fP が含まれていることがあり、
.BR printf ()
呼び出し時にメモリへの書き込みが起こり、
セキュリティーホールを作ることになるかもしれない。
.\".PP
.\".\"O Some floating-point conversions under early libc4
.\".\"O caused memory leaks.
.\"初期の libc4 での実数変換にはメモリリークを引き起こすことがある。
.\"O .SH EXAMPLE
.SH 例
.if \w'\*(Pi'=0 .ds Pi pi
.\"O To print \*(Pi to five decimal places:
\*(Pi を 5 桁で出力する。
.in +4n
.nf

#include <math.h>
#include <stdio.h>
fprintf(stdout, "pi = %.5f\en", 4 * atan(1.0));
.fi
.in
.PP
.\"O To print a date and time in the form "Sunday, July 3, 10:02",
.\"O where
.\"O .I weekday
.\"O and
.\"O .I month
.\"O are pointers to strings:
日付と時間を "Sunday, July 3, 10:02" の形式で出力する。
.RI ( weekday
と
.I month
は文字列へのポインタである)
.in +4n
.nf

#include <stdio.h>
fprintf(stdout, "%s, %s %d, %.2d:%.2d\en",
	weekday, month, day, hour, min);
.fi
.in
.PP
.\"O Many countries use the day-month-year order.
.\"O Hence, an internationalized version must be able to print
.\"O the arguments in an order specified by the format:
日 - 月 - 年 の順序で表示を行う国も多い。
従って、国際版では書式で指定された順番で
引き数を表示できなければならない。
.in +4n
.nf

#include <stdio.h>
fprintf(stdout, format,
	weekday, month, day, hour, min);

.fi
.in
.\"O where
.\"O .I format
.\"O depends on locale, and may permute the arguments.
.\"O With the value:
.I format
はロケールに依存しており、引き数の順番を変えることもできる。
.I format
が
.in +4n
.nf

"%1$s, %3$d. %2$s, %4$d:%5$.2d\en"

.fi
.in
.\"O one might obtain "Sonntag, 3. Juli, 10:02".
であれば、 "Sonntag, 3. Juli, 10:02" という結果になる。
.PP
.\"O To allocate a sufficiently large string and print into it
.\"O (code correct for both glibc 2.0 and glibc 2.1):
十分に大きな文字列領域を確保して、そこにメッセージを格納するには
(glibc 2.0 と glibc 2.1 の両方で正しく動作するコード):
.nf

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
char *
make_message(const char *fmt, ...)
{
    int n;
    int size = 100;     /* Guess we need no more than 100 bytes. */
    char *p, *np;
    va_list ap;

    if ((p = malloc(size)) == NULL)
        return NULL;

    while (1) {

        /* Try to print in the allocated space. */

        va_start(ap, fmt);
        n = vsnprintf(p, size, fmt, ap);
        va_end(ap);

        /* If that worked, return the string. */

        if (n > \-1 && n < size)
            return p;

        /* Else try again with more space. */

        if (n > \-1)    /* glibc 2.1 */
            size = n+1; /* precisely what is needed */
        else           /* glibc 2.0 */
            size *= 2;  /* twice the old size */

        if ((np = realloc (p, size)) == NULL) {
            free(p);
            return NULL;
        } else {
            p = np;
        }
    }
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR printf (1),
.BR asprintf (3),
.BR dprintf (3),
.BR scanf (3),
.BR setlocale (3),
.BR wcrtomb (3),
.BR wprintf (3),
.BR locale (5)

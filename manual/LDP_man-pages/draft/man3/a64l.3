.\" Copyright 2002 walter harms (walter.harms@informatik.uni-oldenburg.de)
.\" Distributed under GPL
.\"
.\" Corrected, aeb, 2002-05-30
.\"
.\" Japanese Version Copyright (c) 2002-2003 Yuichi SATO
.\"         all rights reserved.
.\" Translated Tue Aug  6 04:34:20 JST 2002
.\"         by Yuichi SATO <ysato@h4.dion.ne.jp>
.\" Updated & Modified Thu Nov 27 01:02:55 JST 2003
.\"         by Yuichi SATO <ysato444@yahoo.co.jp>
.\"
.\"WORD:	sign-extend	符号拡張
.\"
.TH A64L 3 2010-09-20 "" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O a64l, l64a \- convert between long and base-64
a64l, l64a \- long と base-64 を変換する
.\"O .SH SYNOPSIS
.SH 書式
.B #include <stdlib.h>
.sp
.BI "long a64l(char *" str64 );
.sp
.BI "char *l64a(long " value );
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.BR a64l (),
.BR l64a ():
.br
.RS 4
.ad l
_SVID_SOURCE || _XOPEN_SOURCE\ >=\ 500 ||
_XOPEN_SOURCE\ &&\ _XOPEN_SOURCE_EXTENDED
.RE
.ad
.\"O .SH DESCRIPTION
.SH 説明
.\"O These functions provide a conversion between 32-bit long integers
.\"O and little-endian base-64 ASCII strings (of length zero to six).
これらの関数は 32 ビット long 整数と
リトルエンディアン base-64 ASCII 文字列 (長さ 0 〜 6) の間の変換を行う。
.\"O If the string used as argument for
.\"O .BR a64l ()
.\"O has length greater than six, only the first six bytes are used.
.BR a64l ()
の引き数の文字列が 7 文字以上の場合、
最初の 6 バイトが使われる。
.\"O If the type
.\"O .I long
.\"O has more than 32 bits, then
.\"O .BR l64a ()
.\"O uses only the low order 32 bits of
.\"O .IR value ,
.\"O and
.\"O .BR a64l ()
.\"O sign-extends its 32-bit result.
.I long
型が 32 ビットより大きい場合、
.BR l64a ()
は
.I value
の下位 32 ビットのみを使い、
.BR a64l ()
は 32 ビットの結果を符号拡張 (sign-extend) する。
.LP
.\"O The 64 digits in the base-64 system are:
base-64 システムで使われる 64 個の文字は以下の通りである:
.RS
.nf

.\"O \&\(aq.\(aq	represents a 0
\&\(aq.\(aq	は 0 を表す。
.\"O \&\(aq/\(aq\&	represents a 1
\&\(aq/\(aq	は 1 を表す。
.\"O 0-9	represent  2-11
0-9	は 2-11 を表す。
.\"O A-Z	represent 12-37
A-Z	は 12-37 を表す。
.\"O a-z	represent 38-63
a-z	は 38-63 を表す。

.fi
.RE
.\"O So 123 = 59*64^0 + 1*64^1 = "v/".
よって 123 = 59*64^0 + 1*64^1 = "v/" である。
.\"O .SH "CONFORMING TO"
.SH 準拠
POSIX.1-2001.
.\"O .SH NOTES
.SH 注意
.\"O The value returned by
.\"O .BR l64a ()
.\"O may be a pointer to a static buffer, possibly overwritten
.\"O by later calls.
.BR l64a ()
で返される値は静的バッファへのポインタかもしれないので、
以降の呼び出しで上書きされる可能性がある。
.LP
.\"O The behavior of
.\"O .BR l64a ()
.\"O is undefined when
.\"O .I value
.\"O is negative.
.\"O If
.\"O .I value
.\"O is zero, it returns an empty string.
.I value
が負の場合、
.BR l64a ()
の動作は定義されていない。
.I value
が 0 の場合は空文字列を返す。
.LP
.\"O These functions are broken in glibc before 2.2.5
.\"O (puts most significant digit first).
これらの関数は glibc 2.2.5 以前では間違っている
(最上位デジットを最初にしている)。
.LP
.\"O This is not the encoding used by
.\"O .BR uuencode (1).
これは
.BR uuencode (1)
で使われるエンコーディングではない。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR uuencode (1),
.\" .BR itoa (3),
.BR strtoul (3)

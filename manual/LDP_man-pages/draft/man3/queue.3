.\" Copyright (c) 1993
.\"     The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. All advertising materials mentioning features or use of this software
.\"    must display the following acknowledgement:
.\"     This product includes software developed by the University of
.\"     California, Berkeley and its contributors.
.\" 4. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"     @(#)queue.3     8.2 (Berkeley) 1/24/94
.\"
.\" hch, 2002-03-25
.\" 2007-12-08, mtk, Converted from mdoc to man macros
.\"
.\" Japanese Version Copyright (c) 2004 Yuichi SATO
.\"         all rights reserved.
.\" Translated Thu Sep  2 04:41:11 JST 2004
.\"         by Yuichi SATO <ysato444@yahoo.co.jp>
.\"
.\"WORD:	circular queue	循環キュー
.\"
.TH QUEUE 3 2007-12-28 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, \
.\"O LIST_INSERT_HEAD, LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, \
.\"O TAILQ_INIT, TAILQ_INSERT_AFTER, TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, \
.\"O TAILQ_REMOVE, CIRCLEQ_ENTRY, CIRCLEQ_HEAD, CIRCLEQ_INIT, \
.\"O CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, \
.\"O CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, \
.\"O CIRCLEQ_REMOVE \- implementations of lists, tail queues, and circular queues
LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, \
LIST_INSERT_HEAD, LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, \
TAILQ_INIT, TAILQ_INSERT_AFTER, TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, \
TAILQ_REMOVE, CIRCLEQ_ENTRY, CIRCLEQ_HEAD, CIRCLEQ_INIT, \
CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, \
CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, \
CIRCLEQ_REMOVE \- リスト・テール (tail) キュー・循環キューの実装
.\"Osato: 
.\"Osato: tail queue の良い訳語が分からないので、とりあえずカタカナにする。
.\"Osato: 
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/queue.h>

.BI "LIST_ENTRY(" TYPE );
.BI "LIST_HEAD(" HEADNAME ", " TYPE );
.BI "LIST_INIT(LIST_HEAD *" head );
.BI "LIST_INSERT_AFTER(LIST_ENTRY *" listelm ", "
.BI "                TYPE *" elm ", LIST_ENTRY " NAME );
.BI "LIST_INSERT_HEAD(LIST_HEAD *" head ", "
.BI "                TYPE *" elm ", LIST_ENTRY " NAME );
.BI "LIST_REMOVE(TYPE *" elm ", LIST_ENTRY " NAME );

.BI "TAILQ_ENTRY(" TYPE );
.BI "TAILQ_HEAD("HEADNAME ", " TYPE );
.BI "TAILQ_INIT(TAILQ_HEAD *" head );
.BI "TAILQ_INSERT_AFTER(TAILQ_HEAD *" head ", TYPE *" listelm ", "
.BI "                TYPE *" elm ", TAILQ_ENTRY " NAME );
.BI "TAILQ_INSERT_HEAD(TAILQ_HEAD *" head ", "
.BI "                TYPE *" elm ", TAILQ_ENTRY " NAME );
.BI "TAILQ_INSERT_TAIL(TAILQ_HEAD *" head ", "
.BI "                TYPE *" elm ", TAILQ_ENTRY " NAME );
.BI "TAILQ_REMOVE(TAILQ_HEAD *" head ", TYPE *" elm ", TAILQ_ENTRY " NAME );

.BI CIRCLEQ_ENTRY( TYPE );
.BI "CIRCLEQ_HEAD(" HEADNAME ", " TYPE );
.BI "CIRCLEQ_INIT(CIRCLEQ_HEAD *" head );
.BI "CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *" head ", TYPE *" listelm ", "
.BI "                TYPE *" elm ", CIRCLEQ_ENTRY " NAME );
.BI "CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *" head ", TYPE *" listelm ", "
.BI "                TYPE *" elm ", CIRCLEQ_ENTRY " NAME );
.BI "CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *" head ", "
.BI "                TYPE *" elm ", CIRCLEQ_ENTRY " NAME );
.BI "CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *" head ", "
.BI "                TYPE *" elm ", CIRCLEQ_ENTRY " NAME );
.BI "CIRCLEQ_REMOVE(CIRCLEQ_HEAD *" head ", "
.BI "                TYPE *" elm ", CIRCLEQ_ENTRY " NAME );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O These macros define and operate on three types of data structures:
.\"O lists, tail queues, and circular queues.
.\"O All three structures support the following functionality:
これらのマクロは、次の 3 つのデータ構造を定義して操作する:
リスト・テールキュー・循環キュー。
3 つのデータ構造すべてにおいて以下の機能がサポートされている:
.sp
.RS 4
.PD 0
.IP * 4
.\"O Insertion of a new entry at the head of the list.
新たなエントリをリストの先頭に挿入する。
.IP *
.\"O Insertion of a new entry after any element in the list.
新たなエントリをリストのどの要素よりも後に挿入する。
.IP *
.\"O Removal of any entry in the list.
リストの任意のエントリを削除する。
.IP *
.\"O Forward traversal through the list.
リストを順方向に辿る。
.PD
.RE
.PP
.\"O Lists are the simplest of the three data structures and support
.\"O only the above functionality.
リストは 3 つのデータ構造の中で最も単純であり、
上記の機能のみをサポートする。

.\"O Tail queues add the following functionality:
テールキューは以下の機能を追加する:
.RS 4
.IP * 4
.\"O Entries can be added at the end of a list.
エントリをリストの最後に追加できる。
.RE
.PP
.\"O However:
ただし:
.sp
.RS 4
.PD 0
.IP 1. 4
.\"O All list insertions and removals must specify the head of the list.
全てのリスト挿入と削除において、リストの先頭を指定しなければならない。
.IP 2.
.\"O Each head entry requires two pointers rather than one.
各先頭エントリは 1 つではなく 2 つのポインタを必要とする。
.IP 3.
.\"O Code size is about 15% greater and operations run about 20% slower
.\"O than lists.
リストと比べて、コードサイズは 15% 大きくなり、操作は 20% 遅くなる。
.PD
.RE
.PP
.\"O Circular queues add the following functionality:
循環キューは以下の機能を追加する:
.sp
.RS 4
.PD 0
.IP * 4
.\"O Entries can be added at the end of a list.
エントリをリストの最後に追加できる。
.IP *
.\"O Entries can be added before another entry.
エントリを他のエントリの前に追加できる。
.IP *
.\"O They may be traversed backwards, from tail to head.
逆方向に末尾から先頭へ辿ることができる。
.PD
.RE
.PP
.\"O However:
ただし:
.sp
.RS 4
.PD 0
.IP 1. 4
.\"O All list insertions and removals must specify the head of the list.
全てのリスト挿入と削除において、リストの先頭を指定しなければならない。
.IP 2.
.\"O Each head entry requires two pointers rather than one.
各先頭エントリは 1 つではなく 2 つのポインタを必要とする。
.IP 3.
.\"O The termination condition for traversal is more complex.
辿る際の終了条件がより複雑である。
.IP 4.
.\"O Code size is about 40% greater and operations run about 45% slower
.\"O than lists.
リストと比べて、コードサイズは 40% 大きくなり、操作は 45% 遅くなる。
.PD
.RE
.PP
.\"O In the macro definitions,
.\"O .I TYPE
.\"O is the name of a user-defined structure,
.\"O that must contain a field of type
.\"O .BR LIST_ENTRY ,
.\"O .BR TAILQ_ENTRY ,
.\"O or
.\"O .BR CIRCLEQ_ENTRY ,
.\"O named
.\"O .IR NAME .
マクロ定義において
.I TYPE
はユーザ定義構造体の名前であり、
.BR LIST_ENTRY ,
.BR TAILQ_ENTRY ,
.BR CIRCLEQ_ENTRY
の何れか型のフィールドと
指定された
.I NAME
を含まなければならない。
.\"O The argument
.\"O .I HEADNAME
.\"O is the name of a user-defined structure that must be declared
.\"O using the macros
.\"O .BR LIST_HEAD ,
.\"O .BR TAILQ_HEAD ,
.\"O or
.\"O .BR CIRCLEQ_HEAD .
引き数
.I HEADNAME
はユーザ定義構造体の名前であり、
マクロ
.BR LIST_HEAD ,
.BR TAILQ_HEAD ,
.BR CIRCLEQ_HEAD
を用いて宣言されなければならない。
.\"O See the examples below for further explanation of how these
.\"O macros are used.
これらのマクロがどのように使われるかについての更なる説明は、
以下の例を参照すること。
.\"O .SS LISTS
.SS リスト
.\"O A list is headed by a structure defined by the
.\"O .B LIST_HEAD
.\"O macro.
リストの先頭には、
.B LIST_HEAD
マクロで定義される構造体が置かれる。
.\"O This structure contains a single pointer to the first element
.\"O on the list.
この構造体はリストの最初の要素へのポインタを 1 つ含む。
.\"O The elements are doubly linked so that an arbitrary element can be
.\"O removed without traversing the list.
要素は 2 重にリンクされており、
任意の要素はリストを辿らずに削除できる。
.\"O New elements can be added to the list after an existing element or
.\"O at the head of the list.
新しい要素は既存の要素の後またはリストの先頭に追加できる。
.\"O A
.\"O .B LIST_HEAD
.\"O structure is declared as follows:
.B LIST_HEAD
構造体は以下のように宣言されている:
.in +4n
.nf

LIST_HEAD(HEADNAME, TYPE) head;
.fi
.in
.PP
.\"O where
.\"O .I HEADNAME
.\"O is the name of the structure to be defined, and
.\"O .I TYPE
.\"O is the type of the elements to be linked into the list.
ここで
.I HEADNAME
は定義される構造体の名前であり、
.I TYPE
はリンク内でリンクされる要素の型である。
.\"O A pointer to the head of the list can later be declared as:
リストの先頭へのポインタは、その後で次のように宣言される:
.in +4n
.nf

struct HEADNAME *headp;
.fi
.in
.PP
.\"O (The names
.\"O .IR "head"
.\"O and
.\"O .IR "headp"
.\"O are user selectable.)
(名前
.IR "head"
と
.IR "headp"
はユーザが選択できる。)
.PP
.\"O The macro
.\"O .B LIST_ENTRY
.\"O declares a structure that connects the elements in
.\"O the list.
マクロ
.B LIST_ENTRY
はリストの要素を接続する構造体を宣言する。
.PP
.\"O The macro
.\"O .B LIST_INIT
.\"O initializes the list referenced by
.\"O .IR head .
マクロ
.B LIST_INIT
は
.I head
で参照されるリストを初期化する。
.PP
.\"O The macro
.\"O .B LIST_INSERT_HEAD
.\"O inserts the new element
.\"O .I elm
.\"O at the head of the list.
マクロ
.B LIST_INSERT_HEAD
は新たな要素
.I elm
をリストの先頭に挿入する。
.PP
.\"O The macro
.\"O .B LIST_INSERT_AFTER
.\"O inserts the new element
.\"O .I elm
.\"O after the element
.\"O .I listelm .
マクロ
.B LIST_INSERT_AFTER
は新たな要素
.I elm
を要素
.I listelm
の後に挿入する。
.PP
.\"O The macro
.\"O .B LIST_REMOVE
.\"O removes the element
.\"O .I elm
.\"O from the list.
マクロ
.B LIST_REMOVE
は要素
.I elm
をリストから削除する。
.\"O .SS LIST EXAMPLE
.SS リストの例
.nf

LIST_HEAD(listhead, entry) head;
.\"O struct listhead *headp;                 /* List head. */
struct listhead *headp;                 /* リストの先頭。*/
struct entry {
.\"O     ...
.\"O     LIST_ENTRY(entry) entries;          /* List. */
.\"O     ...
    ...
    LIST_ENTRY(entry) entries;          /* リスト。 */
    ...
} *n1, *n2, *np;

.\"O LIST_INIT(&head);                       /* Initialize the list. */
LIST_INIT(&head);                       /* リストを初期化する。*/

.\"O n1 = malloc(sizeof(struct entry));     /* Insert at the head. */
n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/
LIST_INSERT_HEAD(&head, n1, entries);

.\"O n2 = malloc(sizeof(struct entry));     /* Insert after. */
n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/
LIST_INSERT_AFTER(n1, n2, entries);
.\"O                                         /* Forward traversal. */
                                        /* 順方向に辿る。*/
for (np = head.lh_first; np != NULL; np = np\->entries.le_next)
    np\-> ...

.\"O while (head.lh_first != NULL)           /* Delete. */
while (head.lh_first != NULL)           /* 削除する。*/
    LIST_REMOVE(head.lh_first, entries);
.fi
.\"O .SS Tail Queues
.SS テールキュー
.\"O A tail queue is headed by a structure defined by the
.\"O .B TAILQ_HEAD
.\"O macro.
テールキューの先頭には
.B TAILQ_HEAD
マクロで定義される構造体が置かれる。
.\"O This structure contains a pair of pointers,
.\"O one to the first element in the tail queue and the other to
.\"O the last element in the tail queue.
この構造体は 1 組のポインタを含んでいる。
1 つはテールキューの最初の要素へのポインタであり、
もう 1 つはテールキューの最後の要素へのポインタである。
.\"O The elements are doubly linked so that an arbitrary element can be
.\"O removed without traversing the tail queue.
要素は 2 重にリンクされており、
任意の要素はテールキューを辿らずに削除できる。
.\"O New elements can be added to the tail queue after an existing element,
.\"O at the head of the tail queue, or at the end of the tail queue.
新しい要素は既存の要素の後またはテールキューの先頭または末尾に追加できる。
.\"O A
.\"O .B TAILQ_HEAD
.\"O structure is declared as follows:
.B TAILQ_HEAD
構造体は以下のように定義されている:
.in +4n
.nf

TAILQ_HEAD(HEADNAME, TYPE) head;
.fi
.in
.PP
.\"O where
.\"O .IR "HEADNAME"
.\"O is the name of the structure to be defined, and
.\"O .IR "TYPE"
.\"O is the type of the elements to be linked into the tail queue.
ここで
.Li HEADNAME
は定義される構造体の名前であり、
.Li TYPE
はテールキュー内でリンクされる要素の型である。
.\"O A pointer to the head of the tail queue can later be declared as:
テールキューの先頭へのポインタは、その後で次のように宣言される:
.in +4n
.nf

struct HEADNAME *headp;
.fi
.in
.PP
.\"O (The names
.\"O .IR "head"
.\"O and
.\"O .IR "headp"
.\"O are user selectable.)
(名前
.IR "head"
と
.IR "headp"
はユーザが選択できる。)
.PP
.\"O The macro
.\"O .B TAILQ_ENTRY
.\"O declares a structure that connects the elements in
.\"O the tail queue.
マクロ
.B TAILQ_ENTRY
はテールキューの要素を接続する構造体を宣言する。
.PP
.\"O The macro
.\"O .B TAILQ_INIT
.\"O initializes the tail queue referenced by
.\"O .IR head .
マクロ
.B TAILQ_INIT
は
.I head
で参照されるテールキューを初期化する。
.PP
.\"O The macro
.\"O .B TAILQ_INSERT_HEAD
.\"O inserts the new element
.\"O .I elm
.\"O at the head of the tail queue.
マクロ
.B TAILQ_INSERT_HEAD
は新たな要素
.I elm
をテールキューの先頭に挿入する。
.PP
.\"O The macro
.\"O .B TAILQ_INSERT_TAIL
.\"O inserts the new element
.\"O .I elm
.\"O at the end of the tail queue.
マクロ
.B TAILQ_INSERT_TAIL
は新たな要素
.I elm
をテールキューの末尾に挿入する。
.PP
.\"O The macro
.\"O .B TAILQ_INSERT_AFTER
.\"O inserts the new element
.\"O .I elm
.\"O after the element
.\"O .I listelm .
マクロ
.B TAILQ_INSERT_AFTER
は新たな要素
.I elm
を要素
.Fa listelm
の後に挿入する。
.PP
.\"O The macro
.\"O .B TAILQ_REMOVE
.\"O removes the element
.\"O .I elm
.\"O from the tail queue.
マクロ
.B TAILQ_REMOVE
は要素
.I elm
をテールキューから削除する。
.\"O .SS Tail Queue Example
.SS テールキューの例
.nf

TAILQ_HEAD(tailhead, entry) head;
.\"O struct tailhead *headp;                 /* Tail queue head. */
struct tailhead *headp;                 /* テールキューの先頭。*/
struct entry {
    ...
.\"O    TAILQ_ENTRY(entry) entries;          /* Tail queue. */
    TAILQ_ENTRY(entry) entries;         /* テールキュー。*/
    ...
} *n1, *n2, *np;

.\"O TAILQ_INIT(&head);                      /* Initialize the queue. */
TAILQ_INIT(&head);                      /* キューを初期化する。*/

.\"O n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/
TAILQ_INSERT_HEAD(&head, n1, entries);

.\"O n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/
TAILQ_INSERT_TAIL(&head, n1, entries);

.\"O n2 = malloc(sizeof(struct entry));      /* Insert after. */
n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/
TAILQ_INSERT_AFTER(&head, n1, n2, entries);
.\"O                                         /* Forward traversal. */
                                        /* 順方向に辿る。*/
for (np = head.tqh_first; np != NULL; np = np\->entries.tqe_next)
    np\-> ...
.\"O                                         /* Delete. */
                                        /* 削除する。*/
while (head.tqh_first != NULL)
    TAILQ_REMOVE(&head, head.tqh_first, entries);
.fi
.\"O .SS Circular Queues
.SS 循環キュー
.\"O A circular queue is headed by a structure defined by the
.\"O .B CIRCLEQ_HEAD
.\"O macro.
循環キューの先頭には
.B CIRCLEQ_HEAD
マクロで定義される構造体が置かれる。
.\"O This structure contains a pair of pointers,
.\"O one to the first element in the circular queue and the other to the
.\"O last element in the circular queue.
この構造体は 1 組のポインタを含んでいる。
1 つは循環キューの最初の要素へのポインタであり、
もう 1 つは循環キューの最後の要素へのポインタである。
.\"O The elements are doubly linked so that an arbitrary element can be
.\"O removed without traversing the queue.
要素は 2 重にリンクされており、
任意の要素はキューを辿らずに削除できる。
.\"O New elements can be added to the queue after an existing element,
.\"O before an existing element, at the head of the queue, or at the end
.\"O of the queue.
新しい要素は、既存の要素の後または前、またはキューの先頭または末尾に追加できる。
A
.\"O .B CIRCLEQ_HEAD
.\"O structure is declared as follows:
.B CIRCLEQ_HEAD
構造体は以下のように定義されている:
.in +4n
.nf

CIRCLEQ_HEAD(HEADNAME, TYPE) head;
.fi
.in
.PP
.\"O where
.\"O .IR "HEADNAME"
.\"O is the name of the structure to be defined, and
.\"O .IR "TYPE"
.\"O is the type of the elements to be linked into the circular queue.
ここで
.IR "HEADNAME"
は定義される構造体の名前であり、
.IR "TYPE"
は循環キュー内でリンクされる要素の型である。
.\"O A pointer to the head of the circular queue can later be declared as:
循環キューの先頭へのポインタは、その後で次のように宣言される:
.in +4n
.nf

struct HEADNAME *headp;
.fi
.in
.PP
.\"O (The names
.\"O .IR "head"
.\"O and
.\"O .IR "headp"
.\"O are user selectable.)
(名前
.I head
と
.I headp
はユーザが選択できる。)
.PP
.\"O The macro
.\"O .B CIRCLEQ_ENTRY
.\"O declares a structure that connects the elements in
.\"O the circular queue.
マクロ
.B CIRCLEQ_ENTRY
は循環キューの要素を接続する構造体を宣言する。
.PP
.\"O The macro
.\"O .B CIRCLEQ_INIT
.\"O initializes the circular queue referenced by
.\"O .IR head .
マクロ
.B CIRCLEQ_INIT
は
.I head
で参照される循環キューを初期化する。
.PP
.\"O The macro
.\"O .B CIRCLEQ_INSERT_HEAD
.\"O inserts the new element
.\"O .I elm
.\"O at the head of the circular queue.
マクロ
.B CIRCLEQ_INSERT_HEAD
は新たな要素
.I elm
を循環キューの先頭に挿入する。
.PP
.\"O The macro
.\"O .B CIRCLEQ_INSERT_TAIL
.\"O inserts the new element
.\"O .I elm
.\"O at the end of the circular queue.
マクロ
.B CIRCLEQ_INSERT_TAIL
は新たな要素
.I elm
を循環キューの末尾に挿入する。
.PP
.\"O The macro
.\"O .B CIRCLEQ_INSERT_AFTER
.\"O inserts the new element
.\"O .I elm
.\"O after the element
.\"O .IR listelm .
マクロ
.B CIRCLEQ_INSERT_AFTER
は新たな要素
.I elm
を要素
.I listelm
の後に挿入する。
.PP
.\"O The macro
.\"O .B CIRCLEQ_INSERT_BEFORE
.\"O inserts the new element
.\"O .I elm
.\"O before the element
.\"O .IR listelm .
マクロ
.B CIRCLEQ_INSERT_AFTER
は新たな要素
.I elm
を要素
.I listelm
の前に挿入する。
.PP
.\"O The macro
.\"O .B CIRCLEQ_REMOVE
.\"O removes the element
.\"O .I elm
.\"O from the circular queue.
マクロ
.B CIRCLEQ_REMOVE
は要素
.I elm
を循環キューから削除する。
.\"O .SS Circular Queue Example
.SS 循環キューの例
.nf

CIRCLEQ_HEAD(circleq, entry) head;
.\"O struct circleq *headp;                  /* Circular queue head. */
struct circleq *headp;                  /* 循環キューの先頭。*/
struct entry {
    ...
.\"O    CIRCLEQ_ENTRY(entry) entries;        /* Circular queue. */
    CIRCLEQ_ENTRY(entry) entries;       /* 循環キュー。*/
    ...
} *n1, *n2, *np;

.\"O CIRCLEQ_INIT(&head);                    /* Initialize the circular queue. */
CIRCLEQ_INIT(&head);                    /* 循環キューを初期化する。*/

.\"O n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/
CIRCLEQ_INSERT_HEAD(&head, n1, entries);

.\"O n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/
CIRCLEQ_INSERT_TAIL(&head, n1, entries);

.\"O n2 = malloc(sizeof(struct entry));      /* Insert after. */
n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/
CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);

.\"O n2 = malloc(sizeof(struct entry));      /* Insert before. */
n2 = malloc(sizeof(struct entry));      /* 前に挿入する。*/
CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);
.\"O                                         /* Forward traversal. */
                                        /* 順方向に辿る。*/
for (np = head.cqh_first; np != (void *)&head; np = np\->entries.cqe_next)
    np\-> ...
.\"O                                         /* Reverse traversal. */
                                        /* 逆方向に辿る。*/
for (np = head.cqh_last; np != (void *)&head; np = np\->entries.cqe_prev)
    np\-> ...
.\"O                                         /* Delete. */
                                        /* 削除する。*/
while (head.cqh_first != (void *)&head)
    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);
.fi
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O Not in POSIX.1-2001.
.\"O Present on the BSDs.
.\"O The
.\"O queue functions first appeared in
.\"O 4.4BSD.
POSIX.1-2001 にはない。
BSD 系に存在する。
queue 関数は 4.4BSD で初めて登場した。

.\" Copyright (C) 2007 Michael Kerrisk <mtk.manpages@gmail.com>
.\" drawing on material by Justin Pryzby <pryzbyj@justinpryzby.com>
.\"
.\" Permission is hereby granted, free of charge, to any person obtaining
.\" a copy of this software and associated documentation files (the
.\" "Software"), to deal in the Software without restriction, including
.\" without limitation the rights to use, copy, modify, merge, publish,
.\" distribute, sublicense, and/or sell copies of the Software, and to
.\" permit persons to whom the Software is furnished to do so, subject to
.\" the following conditions:
.\"
.\" The above copyright notice and this permission notice shall be
.\" included in all copies or substantial portions of the Software.
.\"
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
.\" EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
.\" IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
.\" CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
.\" TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
.\" SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
.\"
.\" References:
.\"   glibc manual and source
.\"
.\" Japanese Version Copyright (c) 2007  Akihiro MOTOKI
.\"         all rights reserved.
.\" Translated 2007-10-16, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.66
.\"
.TH BACKTRACE 3 2008-06-14 GNU "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O backtrace, backtrace_symbols, backtrace_symbols_fd \- support
.\"O for application self-debugging
backtrace, backtrace_symbols, backtrace_symbols_fd \- 
アプリケーション自身でのデバッグのサポート
.\"O .SH SYNOPSIS
.SH 書式
.B #include <execinfo.h>

.B int backtrace(void
.BI ** buffer ,
.B int
.IB size );

.B char **backtrace_symbols(void *const
.BI * buffer ,
.B int
.IB size );

.B void backtrace_symbols_fd(void *const
.BI * buffer ,
.B int
.IB size ,
.B int
.IB fd );
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR backtrace ()
.\"O returns a backtrace for the calling program,
.\"O in the array pointed to by
.\"O .IR buffer .
.\"O A backtrace is the series of currently active function calls for
.\"O the program.
.\"O Each item in the array pointed to by
.\"O .I buffer
.\"O is of type \fIvoid *\fP, and is the return address from
.\"O the corresponding stack frame.
.BR backtrace ()
は、呼び出したプログラムのバックトレースを
.I buffer
が指す配列に入れて返す。バックトレースは、プログラムで
現在動作中の関数呼び出しの並びである。
.I buffer
が指す配列の個々の要素は \fIvoid *\fP 型で、
対応するスタックフレームからのリターンアドレスである。
.\"O The
.\"O .I size
.\"O argument specifies the maximum number of addresses
.\"O that can be stored in
.\"O .IR buffer .
.\"O If the backtrace is larger than
.\"O .IR size ,
.\"O then the addresses corresponding to the
.\"O .I size
.\"O most recent function calls are returned;
.\"O to obtain the complete backtrace, make sure that
.\"O .I buffer
.\"O and
.\"O .I size
.\"O are large enough.
.I size
引き数は
.I buffer
に格納できるアドレスの最大個数を指定する。
バックトレースが
.I size
より大きい場合、
.I size
個の直近の関数呼び出しに対応するアドレスが返される。
完全なバックトレースを取得するためには、確実に
.I buffer
と
.I size
が十分大きくなるようにすること。

.\"O Given the set of addresses returned by
.\"O .BR backtrace ()
.\"O in
.\"O .IR buffer ,
.\"O .BR backtrace_symbols ()
.\"O translates the addresses into an array of strings that describe
.\"O the addresses symbolically.
.BR backtrace ()
によって
.I buffer
にアドレスの集合が得られたら、
.BR backtrace_symbols ()
によって、アドレス集合を、そのアドレスをシンボルで表した文字列の配列
に翻訳できる。
.\"O The
.\"O .I size
.\"O argument specifies the number of addresses in
.\"O .IR buffer .
.I size
引き数は
.I buffer
に格納されたアドレスの数を指定する。
.\"O The symbolic representation of each address consists of the function name
.\"O (if this can be determined), a hexadecimal offset into the function,
.\"O and the actual return address (in hexadecimal).
個々のアドレスのシンボル表現は、関数名 (特定できた場合)、
関数へのオフセット (16進表記)、実際のリターンアドレス (16進表記)
から構成される。
.\"O The address of the array of string pointers is returned
.\"O as the function result of
.\"O .BR backtrace_symbols ().
.\"O This array is
.\"O .BR malloc (3)ed
.\"O by
.\"O .BR backtrace_symbols (),
.\"O and must be freed by the caller.
.\"O (The strings pointed to by the array of pointers
.\"O need not and should not be freed.)
.BR backtrace_symbols ()
の実行結果としては、
文字列ポインタの配列のアドレスが返される。
この配列は
.BR backtrace_symbols ()
によって
.BR malloc (3)
され、呼び出し側で free しなければならない
(ポインタの配列が指す個々の文字列は free する必要はないし、
free すべきでもない)。

.\"O .BR backtrace_symbols_fd ()
.\"O takes the same
.\"O .I buffer
.\"O and
.\"O .I size
.\"O arguments as
.\"O .BR backtrace_symbols (),
.\"O but instead of returning an array of strings to the caller,
.\"O it writes the strings, one per line, to the file descriptor
.\"O .IR fd .
.\"O .BR backtrace_symbols_fd ()
.\"O does not call
.\"O .BR malloc (3),
.\"O and so can be employed in situations where the latter function might fail.
.BR backtrace_symbols_fd ()
は、
.BR backtrace_symbols ()
と同じ引き数
.I buffer
と
.I size
をとるが、呼び出し側に文字列の配列を返す代わりに、
文字列をファイルディスクリプタ
.I fd
に 1 行に 1 エントリの形で書き込む。
.BR backtrace_symbols_fd ()
は
.BR malloc (3)
を呼び出さない。
そのため、これに続く関数が失敗する可能性がある状況でも利用できる。
.\"O .SH "RETURN VALUE"
.SH 返り値
.\"O .BR backtrace ()
.\"O returns the number of addresses returned in
.\"O .IR buffer ,
.\"O which is not greater than
.\"O .IR size .
.\"O If the return value is less than
.\"O .IR size ,
.\"O then the full backtrace was stored; if it is equal to
.\"O .IR size ,
.\"O then it may have been truncated, in which case the addresses of the
.\"O oldest stack frames are not returned.
.BR backtrace ()
は
.I buffer
に格納したアドレスの個数を返す。その個数は
.I size
より大きくなることはない。
返り値が
.I size
より小さい場合、バックトレース全体が格納されている。返り値が
.I size
と等しい場合、バックトレースは切り詰められているかもしれない。
切り詰められた場合、最も古いスタックフレームのアドレスは
返されないことになる。

.\"O On success,
.\"O .BR backtrace_symbols ()
.\"O returns a pointer to the array
.\"O .BR malloc (3)ed
.\"O by the call;
.\"O on error, NULL is returned.
.BR backtrace_symbols ()
は、成功すると、この呼び出しで
.BR malloc (3)
された配列へのポインタを返す。
エラーの場合、 NULL を返す。
.\"O .SH VERSIONS
.SH バージョン
.\"O .BR backtrace (),
.\"O .BR backtrace_symbols (),
.\"O and
.\"O .BR backtrace_symbols_fd ()
.\"O are provided in glibc since version 2.1.
.BR backtrace (),
.BR backtrace_symbols (),
.BR backtrace_symbols_fd ()
はバージョン 2.1 以降の glibc で提供されている。
.\"O .SH CONFORMING TO
.SH 準拠
.\"O These functions are GNU extensions.
これらの関数は GNU による拡張である。
.\"O .SH NOTES
.SH 注意
.\"O These functions make some assumptions about how a function's return
.\"O address is stored on the stack.
.\"O Note the following:
これらの関数は、関数のリターンアドレスがスタック上でどのように格納されるか
に関してある仮定を置いている。
以下の点に注意。
.IP * 3
.\"O Omission of the frame pointers (as
.\"O implied by any of
.\"O .BR gcc (1)'s
.\"O nonzero optimization levels) may cause these assumptions to be
.\"O violated.
.RB ( gcc (1)
の 0 以外の最適化レベルで暗黙のうちに行われる)
フレームポインタの省略を行うと、これらの前提が崩れる可能性がある。
.IP *
.\"O Inlined functions do not have stack frames.
インライン関数はスタックフレームを持たない。
.IP *
.\"O Tail-call optimization causes one stack frame to replace another.
末尾呼び出しの最適化 (tail-call optimization) を行うと、
あるスタックフレームが別のスタックフレームを置き換える可能性がある。
.PP
.\"O The symbol names may be unavailable without the use of special linker
.\"O options.
.\"O For systems using the GNU linker, it is necessary to use the
.\"O .I \-rdynamic
.\"O linker option.
.\"O Note that names of "static" functions are not exposed,
.\"O and won't be available in the backtrace.
シンボル名は特別なリンカ・オプションを使用しないと利用できない場合がある。
GNU リンカを使用するシステムでは、
.I \-rdynamic
リンカ・オプションを使う必要がある。
"static" な関数のシンボル名は公開されず、
バックトレースでは利用できない点に注意すること。
.\"O .SH EXAMPLE
.SH 例
.\"O The program below demonstrates the use of
.\"O .BR backtrace ()
.\"O and
.\"O .BR backtrace_symbols ().
.\"O The following shell session shows what we might see when running the
.\"O program:
以下のプログラムは、
.BR backtrace ()
と
.BR backtrace_symbols ()
の使用例を示したものである。
以下に示すシェルのセッションは、
このプログラムを動かした際の実行例である。
.nf
.in +4n

.RB "$" " cc \-rdynamic prog.c \-o prog"
.RB "$" " ./prog 3"
backtrace() returned 8 addresses
\&./prog(myfunc3+0x5c) [0x80487f0]
\&./prog [0x8048871]
\&./prog(myfunc+0x21) [0x8048894]
\&./prog(myfunc+0x1a) [0x804888d]
\&./prog(myfunc+0x1a) [0x804888d]
\&./prog(main+0x65) [0x80488fb]
\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]
\&./prog [0x8048711]
.in
.fi
.\"O .SS Program source
.SS プログラムのソース
\&
.nf
#include <execinfo.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void
myfunc3(void)
{
    int j, nptrs;
#define SIZE 100
    void *buffer[100];
    char **strings;

    nptrs = backtrace(buffer, SIZE);
    printf("backtrace() returned %d addresses\\n", nptrs);

.\"O     /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)
.\"O        would produce similar output to the following: */
    /* backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO) を
       呼び出しても、以下と同様の出力が得られる。 */

    strings = backtrace_symbols(buffer, nptrs);
    if (strings == NULL) {
        perror("backtrace_symbols");
        exit(EXIT_FAILURE);
    }

    for (j = 0; j < nptrs; j++)
        printf("%s\\n", strings[j]);

    free(strings);
}

.\"O static void   /* "static" means don\(aqt export the symbol... */
static void   /* "static" はシンボルを公開しないことを意味する */
myfunc2(void)
{
    myfunc3();
}

void
myfunc(int ncalls)
{
    if (ncalls > 1)
        myfunc(ncalls \- 1);
    else
        myfunc2();
}

int
main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "%s num\-calls\\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    myfunc(atoi(argv[1]));
    exit(EXIT_SUCCESS);
}
.fi
.\"O .SH SEE ALSO
.SH 関連項目
.BR gcc (1),
.BR ld (1),
.BR dlopen (3),
.BR malloc (3)

'\" t
.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 2006 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Japanese Version Copyright (c) 2006 Akihiro MOTOKI all rights reserved.
.\" Translated 2006-04-18, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.TH SEM_WAIT 3 2010-02-25 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O sem_wait, sem_timedwait, sem_trywait \- lock a semaphore
sem_wait, sem_timedwait, sem_trywait \- セマフォをロックする
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <semaphore.h>
.sp
.BI "int sem_wait(sem_t *" sem );
.sp
.BI "int sem_trywait(sem_t *" sem );
.sp
.BI "int sem_timedwait(sem_t *" sem ", const struct timespec *" abs_timeout );
.fi
.sp
.sp
.\"O Link with \fI\-lrt\fP or \fI\-pthread\fP.
\fI\-lrt\fP または \fI\-pthread\fP でリンクする。
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.in
.sp
.BR sem_timedwait ():
_POSIX_C_SOURCE\ >=\ 200112L || _XOPEN_SOURCE\ >=\ 600
.\"O .SH DESCRIPTION
.SH 説明
.\"O .BR sem_wait ()
.\"O decrements (locks) the semaphore pointed to by
.\"O .IR sem .
.\"O If the semaphore's value is greater than zero,
.\"O then the decrement proceeds, and the function returns, immediately.
.\"O If the semaphore currently has the value zero,
.\"O then the call blocks until either it becomes possible to perform
.\"O the decrement (i.e., the semaphore value rises above zero),
.\"O or a signal handler interrupts the call.
.BR sem_wait ()
は
.I sem
が指すセマフォの値を 1 減らす (ロックする)。
セマフォの値が 0 より大きい場合、減算が実行され、関数は直ちに復帰する。
セマフォの現在値が 0 の場合には、減算を実行できるようになる
(つまり、セマフォの値が 0 より大きな値になる) まで、もしくは
シグナルハンドラによって呼び出しが中断されるまで、
関数呼び出しは停止 (block) する。

.\"O .BR sem_trywait ()
.\"O is the same as
.\"O .BR sem_wait (),
.\"O except that if the decrement cannot be immediately performed,
.\"O then call returns an error
.\"O .RI ( errno
.\"O set to
.\"O .BR EAGAIN )
.\"O instead of blocking.
.BR sem_trywait ()
は
.BR sem_wait ()
と同じだが、セマフォ値の減算をすぐに実行できなかった場合に、
停止 (block) するのではなくエラーで復帰する
.RI ( errno
に
.B EAGAIN
がセットされる) 点が異なる。

.\"O .BR sem_timedwait ()
.\"O is the same as
.\"O .BR sem_wait (),
.\"O except that
.\"O .I abs_timeout
.\"O specifies a limit on the amount of time that the call
.\"O should block if the decrement cannot be immediately performed.
.\"O The
.\"O .I abs_timeout
.\"O argument points to a structure that specifies an absolute timeout
.\"O in seconds and nanoseconds since the Epoch, 1970-01-01 00:00:00 +0000 (UTC).
.\"O This structure is defined as follows:
.BR sem_timedwait ()
は
.BR sem_wait ()
と同じだが、セマフォ値の減算をすぐに実行できなかった場合に
関数呼び出しが停止する時間の上限を
.I abs_timeout
で指定する点が異なる。
.I abs_timeout
引き数は、タイムアウト時刻を指定する構造体へのポインタである。
この構造体には、タイムアウト時刻を時刻紀元 (Epoch;
1970-01-01 00:00:00 +0000 (UTC)) からの
経過時間 (秒＋ナノ秒) で指定する。
構造体は以下のように定義されている:

.nf
.in +4n
struct timespec {
    time_t tv_sec;      /* Seconds */
    long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */
};
.in
.fi
.PP
.\"O If the timeout has already expired by the time of the call,
.\"O and the semaphore could not be locked immediately,
.\"O then
.\"O .BR sem_timedwait ()
.\"O fails with a timeout error
.\"O .RI ( errno
.\"O set to
.\"O .BR ETIMEDOUT ).
関数呼び出し時点ですでにタイムアウトに指定した時刻が過ぎており、
かつセマフォをすぐにロックできなかった場合は、
.BR sem_timedwait ()
はタイムアウトエラー
.RI ( errno
に
.B ETIMEDOUT
がセットされる) で失敗する。

.\"O If the operation can be performed immediately, then
.\"O .BR sem_timedwait ()
.\"O never fails with a timeout error, regardless of the value of
.\"O .IR abs_timeout .
.\"O Furthermore, the validity of
.\"O .I abs_timeout
.\"O is not checked in this case.
セマフォ操作がすぐに実行できるときは、
.I abs_timeout
がどんな値であっても
.BR sem_timedwait ()
が失敗することは決してない。さらにいうと、この場合には
.I abs_timeout
の正当性の検査は行われない。
.\"O .SH RETURN VALUE
.SH 返り値
.\"O All of these functions return 0 on success;
.\"O on error, the value of the semaphore is left unchanged,
.\"O \-1 is returned, and
.\"O .I errno
.\"O is set to indicate the error.
成功すると、これらの関数は 0 を返す。
エラーの場合、セマフォの値を変更せずに、\-1 を返し、
.I errno
にエラーを示す値をセットする。
.\"O .SH ERRORS
.SH エラー
.TP
.B EINTR
.\"O The call was interrupted by a signal handler; see
.\"O .BR signal (7).
呼び出しはシグナルハンドラにより中断された。
.BR signal (7)
参照。
.TP
.B EINVAL
.\"O .I sem
.\"O is not a valid semaphore.
.I sem
は有効なセマフォでない。
.PP
.\"O The following additional error can occur for
.\"O .BR sem_trywait ():
.BR sem_trywait ()
の場合には、上記に加えて以下のエラーも起こる。
.TP
.B EAGAIN
.\"O The operation could not be performed without blocking (i.e., the
.\"O semaphore currently has the value zero).
停止 (block) せずにロック操作を完了できなかった (つまり、
セマフォの現在の値が 0 であった)。
.PP
.\"O The following additional errors can occur for
.\"O .BR sem_timedwait ():
.BR sem_timedwait ()
の場合、以下のエラーも起こる。
.TP
.B EINVAL
.\"O The value of
.\"O .I abs_timeout.tv_nsecs
.\"O is less than 0, or greater than or equal to 1000 million.
.I abs_timeout.tv_nsecs
の値が 0 未満、もしくは 1,000,000,000 以上である。
.TP
.B ETIMEDOUT
.\"O The call timed out before the semaphore could be locked.
セマフォのロックに成功する前に時間切れとなった。
.\"O .\" POSIX.1-2001 also allows EDEADLK -- "A deadlock condition
.\"O .\" was detected", but this does not occur on Linux(?).
.\" POSIX.1-2001 ではエラーとして EDEADLK も用意している。
.\" これはデッドロック条件を検出したことを示すものだが、
.\" Linux で発生することはない(?)
.\"O .SH CONFORMING TO
POSIX.1-2001.
.\"O .SH NOTES
.SH 注意
.\"O A signal handler always interrupts a blocked call to
.\"O one of these functions, regardless of the use of the
.\"O .BR sigaction (2)
.\"O .B SA_RESTART
.\"O flag.
シグナルハンドラは、
.BR sigaction (2)
の
.B SA_RESTART
フラグを使用しているかどうかに関わらず、これらの関数の呼び出しが
停止している場合、シグナルハンドラにより常に中断される。
.\"O .\" sem_wait() is always interrupted on most other implementations,
.\"O .\" but on FreeBSD 5.4 SA_RESTART does cause restarting.
.\" sem_wait() は他のほとんどの実装では常に中断されるが、
.\" FreeBSD 5.4 では SA_RESTART を指定しておくと実行が再開される。
.\"O .SH EXAMPLE
.SH 例
.PP
.\"O The (somewhat trivial) program shown below operates on an
.\"O unnamed semaphore.
.\"O The program expects two command-line arguments.
.\"O The first argument specifies a seconds value that is used to
.\"O set an alarm timer to generate a
.\"O .B SIGALRM
.\"O signal.
.\"O This handler performs a
.\"O .BR sem_post (3)
.\"O to increment the semaphore that is being waited on in
.\"O .I main()
.\"O using
.\"O .BR sem_timedwait ().
.\"O The second command-line argument specifies the length
.\"O of the timeout, in seconds, for
.\"O .BR sem_timedwait ().
.\"O The following shows what happens on two different runs of the program:
以下に示す (ちょっとした) プログラムは名前なしセマフォの操作を行う。
プログラムはコマンドライン引き数を 2 つ取る。
最初の引き数には、
.B SIGALRM
シグナルを生成するためのアラームタイマーの設定に使われる値を
秒単位で指定する。このシグナルハンドラは、
.I main()
内で
.BR sem_timedwait ()
を使って待っているセマフォを、
.BR sem_post (3)
を使って加算する。
2番目の引き数には、
.BR sem_timedwait ()
に渡すタイムアウトまでの時間を秒単位で指定する。

.in +4n
.nf
.RB "$" " ./a.out 2 3"
About to call sem_timedwait()
sem_post() from handler
sem_getvalue() from handler; value = 1
sem_timedwait() succeeded
.RB "$" " ./a.out 2 1"
About to call sem_timedwait()
sem_timedwait() timed out
.fi
.in
.\"O .SS Program source
.SS プログラムのソース
\&
.nf
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <time.h>
#include <assert.h>
#include <errno.h>
#include <signal.h>

sem_t sem;

#define handle_error(msg) \\
    do { perror(msg); exit(EXIT_FAILURE); } while (0)

static void
handler(int sig)
{
    write(STDOUT_FILENO, "sem_post() from handler\\n", 24);
    if (sem_post(&sem) == \-1) {
        write(STDERR_FILENO, "sem_post() failed\\n", 18);
        _exit(EXIT_FAILURE);
    }
}

int
main(int argc, char *argv[])
{
    struct sigaction sa;
    struct timespec ts;
    int s;

    if (argc != 3) {
        fprintf(stderr, "Usage: %s <alarm\-secs> <wait\-secs>\\n",
                argv[0]);
        exit(EXIT_FAILURE);
    }

    if (sem_init(&sem, 0, 0) == \-1)
        handle_error("sem_init");

    /* Establish SIGALRM handler; set alarm timer using argv[1] */

    sa.sa_handler = handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    if (sigaction(SIGALRM, &sa, NULL) == \-1)
        handle_error("sigaction");

    alarm(atoi(argv[1]));

    /* Calculate relative interval as current time plus
       number of seconds given argv[2] */

    if (clock_gettime(CLOCK_REALTIME, &ts) == \-1)
        handle_error("clock_gettime");

    ts.tv_sec += atoi(argv[2]);

    printf("main() about to call sem_timedwait()\\n");
    while ((s = sem_timedwait(&sem, &ts)) == \-1 && errno == EINTR)
        continue;       /* Restart if interrupted by handler */

    /* Check what happened */

    if (s == \-1) {
        if (errno == ETIMEDOUT)
            printf("sem_timedwait() timed out\\n");
        else
            perror("sem_timedwait");
    } else
        printf("sem_timedwait() succeeded\\n");

    exit((s == 0) ? EXIT_SUCCESS : EXIT_FAILURE);
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR clock_gettime (2),
.BR sem_getvalue (3),
.BR sem_post (3),
.BR sem_overview (7),
.BR time (7)

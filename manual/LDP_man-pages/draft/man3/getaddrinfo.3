.\" Copyright (c) 2007, 2008 Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (c) 2006 Ulrich Drepper <drepper@redhat.com>
.\" A few pieces of an earlier version remain:
.\" Copyright 2000, Sam Varshavchik <mrsam@courier-mta.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" References: RFC 2553
.\"
.\" 2005-08-09, mtk, added AI_ALL, AI_ADDRCONFIG, AI_V4MAPPED,
.\"			and AI_NUMERICSERV.
.\" 2006-11-25, Ulrich Drepper <drepper@redhat.com>
.\"     Add text describing Internationalized Domain Name extensions.
.\" 2007-06-08, mtk: added example programs
.\" 2008-02-26, mtk; clarify discussion of NULL 'hints' argument; other
.\"     minor rewrites.
.\" 2008-06-18, mtk: many parts rewritten
.\" 2008-12-04, Petr Baudis <pasky@suse.cz>
.\"	Describe results ordering and reference /etc/gai.conf.
.\" FIXME . glibc's 2.9 NEWS file documents DCCP and UDP-lite support
.\"           and is SCTP support now also there?
.\"
.\" Japanese Version Copyright (c) 2001 NAKANO Takeo all rights reserved.
.\" Translated Sun Jan 14 2001 by NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Updated 2005-10-09 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2007-01-01 by Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2007-06-13, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.55
.\" Updated 2008-04-04, Akihiro MOTOKI, LDP v2.79
.\" Updated 2008-08-11, Akihiro MOTOKI, LDP v3.05
.\" Updated 2008-11-09, Akihiro MOTOKI, LDP v3.13
.\" Updated 2008-12-26, Akihiro MOTOKI, LDP v3.15
.\" Updated 2010-04-18, Akihiro MOTOKI, LDP v3.24
.\"
.\"WORD:	null pointer	ヌル・ポインタ
.\"
.TH GETADDRINFO 3 2010-09-27 "GNU" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O getaddrinfo, freeaddrinfo, gai_strerror \- network address and
.\"O service translation
.SH 名前
getaddrinfo, freeaddrinfo, gai_strerror \-
ネットワークのアドレスとサービスを変換する
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/types.h>
.B #include <sys/socket.h>
.B #include <netdb.h>
.sp
.BI "int getaddrinfo(const char *" "node" ", const char *" "service" ,
.BI "                const struct addrinfo *" "hints" ,
.BI "                struct addrinfo **" "res" );
.sp
.BI "void freeaddrinfo(struct addrinfo *" "res" );
.sp
.BI "const char *gai_strerror(int " "errcode" );
.fi
.sp
.in -4n
.\"O Feature Test Macro Requirements for glibc (see
.\"O .BR feature_test_macros (7)):
glibc 向けの機能検査マクロの要件
.RB ( feature_test_macros (7)
参照):
.ad l
.in
.sp
.BR getaddrinfo (),
.BR freeaddrinfo (),
.BR gai_strerror ():
.RS 4
_POSIX_C_SOURCE\ >=\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE
.RE
.ad b
.\"O .SH DESCRIPTION
.SH 説明
.\"O Given
.\"O .I node
.\"O and
.\"O .IR service ,
.\"O which identify an Internet host and a service,
.\"O .BR getaddrinfo ()
.\"O returns one or more
.\"O .I addrinfo
.\"O structures, each of which contains an Internet address
.\"O that can be specified in a call to
.\"O .BR bind (2)
.\"O or
.\"O .BR connect (2).
.BR getaddrinfo ()
は、(インターネットのホストとサービスを識別する)
.I node
と
.I service
を渡すと、一つ以上の
.I addrinfo
構造体を返す。それぞれの
.I addrinfo
構造体には、
.BR bind (2)
や
.BR connect (2)
を呼び出す際に指定できるインターネットアドレスが格納されている。
.\"O The
.\"O .BR getaddrinfo ()
.\"O function combines the functionality provided by the
.\"O .\" .BR getipnodebyname (3),
.\"O .\" .BR getipnodebyaddr (3),
.\"O .BR getservbyname (3)
.\"O and
.\"O .BR getservbyport (3)
.\"O functions into a single interface, but unlike the latter functions,
.\"O .BR getaddrinfo ()
.\"O is reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies.
.BR getaddrinfo ()
関数は、
.\" .BR getipnodebyname (3),
.\" .BR getipnodebyaddr (3),
.BR getservbyname (3)
と
.BR getservbyport (3)
の機能をまとめて一つのインターフェースにしたものであるが、
これらの関数と違い、
.BR getaddrinfo ()
はリエントラントであり、
.BR getaddrinfo ()
を使うことでプログラムは IPv4 と IPv6 の違いに関する依存関係を
なくすことができる。
.PP
.\"O The
.\"O .I addrinfo
.\"O structure used by
.\"O .BR getaddrinfo ()
.\"O contains the following fields:
.BR getaddrinfo ()
が用いる
.I addrinfo
構造体は以下のフィールドを含む。
.sp
.in +4n
.nf
struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    size_t           ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
};
.fi
.in
.PP
.\"O The
.\"O .I hints
.\"O argument points to an
.\"O .I addrinfo
.\"O structure that specifies criteria for selecting the socket address
.\"O structures returned in the list pointed to by
.\"O .IR res .
.\"O If
.\"O .I hints
.\"O is not NULL it points to an
.\"O .I addrinfo
.\"O structure whose
.\"O .IR ai_family ,
.\"O .IR ai_socktype ,
.\"O and
.\"O .I ai_protocol
.\"O specify criteria that limit the set of socket addresses returned by
.\"O .BR getaddrinfo (),
.\"O as follows:
.I hints
引き数は
.I addrinfo
構造体を指し示し、この構造体を用いて
.I res
が指すリストに入れて返すソケットアドレス構造体を選択するための基準を指定する。
.I hints
が NULL でない場合、
.I hints
は
.I addrinfo
構造体を指し示し、その構造体のフィールド
.IR ai_family ,
.IR ai_socktype ,
.I ai_protocol
で
.BR getaddrinfo ()
が返すソケットアドレス集合に対する基準を指定する。
.TP 12
.I ai_family
.\"O This field specifies the desired address family for the returned addresses.
.\"O Valid values for this field include
.\"O .BR AF_INET
.\"O and
.\"O .BR AF_INET6 .
.\"O The value
.\"O .B AF_UNSPEC
.\"O indicates that
.\"O .BR getaddrinfo ()
.\"O should return socket addresses for any address family
.\"O (either IPv4 or IPv6, for example) that can be used with
.\"O .I node
.\"O and
.\"O .IR service .
このフィールドは返されるアドレスの希望のアドレスファミリーを指定する。
このフィールドに指定できる有効な値としては
.B AF_INET
と
.B AF_INET6
がある。
また、値
.B AF_UNSPEC
を指定すると、
.BR getaddrinfo ()
は
.I node
と
.I service
で使用できるいずれかのアドレスファミリー (例えば IPv4 か IPv6) の
ソケットアドレスを返すことを求められる。
.TP
.I ai_socktype
.\"O This field specifies the preferred socket type, for example
.\"O .BR SOCK_STREAM
.\"O or
.\"O .BR SOCK_DGRAM .
.\"O Specifying 0 in this field indicates that socket addresses of any type
.\"O can be returned by
.\"O .BR getaddrinfo ().
このフィールドは推奨のソケット型 (例えば
.B SOCK_STREAM
や
.BR SOCK_DGRAM )
を指定する。
このフィールドに 0 を指定すると、任意のソケット型のソケットアドレスを
.BR getaddrinfo ()
が返してよいことを意味する。
.TP
.I ai_protocol
.\"O This field specifies the protocol for the returned socket addresses.
.\"O Specifying 0 in this field indicates that socket addresses with
.\"O any protocol can be returned by
.\"O .BR getaddrinfo ().
このフィールドは返されるソケットアドレスのプロトコルを指定する。
このフィールドに 0 を指定すると、任意のプロトコルののソケットアドレスを
.BR getaddrinfo ()
が返してよいことを意味する。
.TP
.I ai_flags
.\"O This field specifies additional options, described below.
.\"O Multiple flags are specified by bitwise OR-ing them together.
このフィールドは、追加のオプション (下記) を指定する。
複数のフラグを指定する際には、それらのビット単位の OR をとって指定する。
.PP
.\"O All the other fields in the structure pointed to by
.\"O .I hints
.\"O must contain either 0 or a NULL pointer, as appropriate.
.I hints
が指し示す構造体の他のすべてのフィールドには
0 か NULL ポインタを適切に入れなければならない。
.\"O Specifying
.\"O .I hints
.\"O as NULL is equivalent to setting
.\"O .I ai_socktype
.\"O and
.\"O .I ai_protocol
.\"O to 0;
.\"O .I ai_family
.\"O to
.\"O .BR AF_UNSPEC ;
.\"O and
.\"O .I ai_flags
.\"O to
.\"O .BR "(AI_V4MAPPED\ |\ AI_ADDRCONFIG)" .
.I hints
に NULL を指定するのは、
.I ai_socktype
と
.I ai_protocol
に 0 を、
.I ai_family
に
.B AF_UNSPEC
を、
.I ai_flags
に
.B "(AI_V4MAPPED\ |\ AI_ADDRCONFIG)"
を設定するのと等価である。

.\"O .I node
.\"O specifies either a numerical network address
.\"O (for IPv4, numbers-and-dots notation as supported by
.\"O .BR inet_aton (3);
.\"O for IPv6, hexadecimal string format as supported by
.\"O .BR inet_pton (3)),
.\"O or a network hostname, whose network addresses are looked up and resolved.
.\"O If
.\"O .I hints.ai_flags
.\"O contains the
.\"O .B AI_NUMERICHOST
.\"O flag then
.\"O .I node
.\"O must be a numerical network address.
.\"O The
.\"O .B AI_NUMERICHOST
.\"O flag suppresses any potentially lengthy network host address lookups.
.I node
には、数値形式のネットワークアドレス
(IPv4 の場合は
.BR inet_aton (3)
でサポートされているドット区切りの数字による表記、
IPv6 の場合は
.BR inet_pton (3)
でサポートされている 16 進数の文字列形式) もしくは
ネットワークホスト名を指定する。
ネットワークホスト名を指定した場合には、そのネットワークアドレスが検索され、
名前解決が行なわれる。
.I hints.ai_flags
に
.B AI_NUMERICHOST
フラグが含まれている場合は、
.I node
は数値形式のネットワークアドレスでなければならない。
.B AI_NUMERICHOST
フラグを使うと、時間の掛かる可能性のあるネットワークホストアドレスの検索は
すべて抑制される。
.PP
.\"O If the
.\"O .B AI_PASSIVE
.\"O flag is specified in
.\"O .IR hints.ai_flags ,
.\"O and
.\"O .I node
.\"O is NULL,
.\"O then the returned socket addresses will be suitable for
.\"O .BR bind (2)ing
.\"O a socket that will
.\"O .BR accept (2)
.\"O connections.
.\"O The returned socket address will contain the "wildcard address"
.\"O .RB ( INADDR_ANY
.\"O for IPv4 addresses,
.\"O .BR IN6ADDR_ANY_INIT
.\"O for IPv6 address).
.\"O The wildcard address is used by applications (typically servers)
.\"O that intend to accept connections on any of the hosts's network addresses.
.\"O If
.\"O .I node
.\"O is not NULL, then the
.\"O .B AI_PASSIVE
.\"O flag is ignored.
.IR hints.ai_flags
に
.B AI_PASSIVE
フラグが指定され、かつ
.I node
が NULL の場合、
返されるソケットアドレスは
コネクションを
.BR accept (2)
するためのソケットを
.BR bind (2)
するのに適したものとなる。
返されるソケットアドレスには「ワイルドカード・アドレス」
(IPv4 アドレスの場合は
.BR INADDR_ANY 、
IPv6 アドレスの場合は
.BR IN6ADDR_ANY_INIT )
が入る。
ワイルドカード・アドレスは、任意のホストのネットワークアドレスで接続を
受け付けようとするアプリケーション (通常はサーバー) で用いられる。
.I node
が NULL でない場合、
.B AI_PASSIVE
フラグは無視される。
.PP
.\"O If the
.\"O .B AI_PASSIVE
.\"O flag is not set in
.\"O .IR hints.ai_flags ,
.\"O then the returned socket addresses will be suitable for use with
.\"O .BR connect (2),
.\"O .BR sendto (2),
.\"O or
.\"O .BR sendmsg (2).
.\"O If
.\"O .I node
.\"O is NULL,
.\"O then the network address will be set to the loopback interface address
.\"O .RB ( INADDR_LOOPBACK
.\"O for IPv4 addresses,
.\"O .BR IN6ADDR_LOOPBACK_INIT
.\"O for IPv6 address);
.\"O this is used by applications that intend to communicate
.\"O with peers running on the same host.
.I hints.ai_flags
に
.B AI_PASSIVE
フラグがセットされていない場合、
返されるソケットアドレスは
.BR connect (2),
.BR sendto (2),
.BR sendmsg (2)
での使用に適したものとなる。
.I node
が NULL の場合、ネットワークアドレスにはループバック・インターフェイスの
アドレス (IPv4 アドレスの場合は
.BR INADDR_LOOPBACK
IPv6 アドレスの場合は
.BR IN6ADDR_LOOPBACK_INIT ) が設定される。
これは同じホスト上で動作している接続相手と通信するような
アプリケーションで用いられる。
.PP
.\"O .I service
.\"O sets the port in each returned address structure.
.\"O If this argument is a service name (see
.\"O .BR services (5)),
.\"O it is translated to the corresponding port number.
.\"O This argument can also be specified as a decimal number,
.\"O which is simply converted to binary.
.I service
により、返される各アドレス構造体のポート番号が決まる。
この引き数がサービス名
.RB ( services (5)
参照) の場合、対応するポート番号に翻訳される。
この引き数には 10 進数も指定することができ、
この場合にはバイナリへの変換だけが行われる。
.\"O If
.\"O .I service
.\"O is NULL, then the port number of the returned socket addresses
.\"O will be left uninitialized.
.I service
が NULL の場合、返されるソケットアドレスのポート番号は
初期化されないままとなる。
.\"O If
.\"O .B AI_NUMERICSERV
.\"O is specified in
.\"O .I hints.ai_flags
.\"O and
.\"O .I service
.\"O is not NULL, then
.\"O .I service
.\"O must point to a string containing a numeric port number.
.I hints.ai_flags
に
.B AI_NUMERICSERV
が指定され、かつ
.I service
が NULL でない場合、
.I service
は数値のポート番号を含む文字列を指し示さなければならない。
.\"O This flag is used to inhibit the invocation of a name resolution service
.\"O in cases where it is known not to be required.
このフラグは、名前解決サービスが不要であることが分かっている場合に、
サービスの起動を抑制するために用いられる。
.PP
.\"O Either
.\"O .I node
.\"O or
.\"O .IR service ,
.\"O but not both, may be NULL.
.I node
と
.I service
のどちらかは NULL にしてよいが、両方同時に NULL にしてはならない。
.PP
.\"O The
.\"O .BR getaddrinfo ()
.\"O function allocates and initializes a linked list of
.\"O .I addrinfo
.\"O structures, one for each network address that matches
.\"O .I node
.\"O and
.\"O .IR service ,
.\"O subject to any restrictions imposed by
.\"O .IR hints ,
.\"O and returns a pointer to the start of the list in
.\"O .IR res .
.\"O The items in the linked list are linked by the
.\"O .I ai_next
.\"O field.
.BR getaddrinfo ()
関数は、
.I addrinfo
構造体のメモリ確保を行い、
.I addrinfo
構造体のリンクリストを初期化し、
.I res
にリストの先頭へのポインタを入れて返す。
このとき、各構造体のネットワークアドレスは
.I node
と
.I service
に一致し、
.I hints
で課されたすべての制限を満たすものとなる。
リンクリストの要素は
.I ai_next
フィールドにより連結される。

.\"O There are several reasons why
.\"O the linked list may have more than one
.\"O .I addrinfo
.\"O structure, including: the network host is multihomed, accessible
.\"O over multiple protocols (e.g. both
.\"O .BR AF_INET
.\"O and
.\"O .BR AF_INET6 );
.\"O or the same service is available from multiple socket types (one
.\"O .B SOCK_STREAM
.\"O address and another
.\"O .B SOCK_DGRAM
.\"O address, for example).
リンクリストの
.I addrinfo
構造体は複数個になることもあり、その理由はいくつかある。
ネットワークホストがマルチホームである、
複数のプロトコルでアクセスできる (例えば
.B AF_INET
と
.B AF_INET6
の両方) 、
複数のソケット種別で同じサービスが利用できる
(例えば、ひとつが
.B SOCK_STREM
アドレスで、もうひとつが
.B SOCK_DGRAM
アドレスである)、がある。
.\"O Normally, the application should try
.\"O using the addresses in the order in which they are returned.
.\"O The sorting function used within
.\"O .BR getaddrinfo ()
.\"O is defined in RFC\ 3484; the order can be tweaked for a particular
.\"O system by editing
.\"O .IR /etc/gai.conf
.\"O (available since glibc 2.5).
通常は、アプリケーションは返された順序でアドレスを試すべきである。
.BR getaddrinfo ()
の中で使用される並べ替え関数は RFC\ 3484 で定義されている。
特殊なシステムでは、
.I /etc/gai.conf
を編集することで、この順序を微調整することができる
.RI ( /etc/gai.conf
は glibc 2.5 以降で利用できる)。
.PP
.\"O If
.\"O .I hints.ai_flags
.\"O includes the
.\"O .B AI_CANONNAME
.\"O flag, then the
.\"O .I ai_canonname
.\"O field of the first of the
.\"O .I addrinfo
.\"O structures in the returned list is set to point to the
.\"O official name of the host.
.I hints.ai_flags
に
.B AI_CANONNAME
フラグが含まれている場合、返されるリストの最初の
.I addrinfo
構造体の
.I ai_canonname
フィールドはホストの公式な名前を指すように設定される。
.\" In glibc prior to 2.3.4, the ai_canonname of each addrinfo
.\" structure was set pointing to the canonical name; that was
.\" more than POSIX.1-2001 specified, or other implementations provided.
.\" MTK, Aug 05

.\"O The remaining fields of each returned
.\"O .I addrinfo
.\"O structure are initialized as follows:
返される各々の
.I addrinfo
構造体の残りのフィールドは以下のように初期化される。
.IP * 2
.\"O The
.\"O .IR ai_family ,
.\"O .IR ai_socktype ,
.\"O and
.\"O .I ai_protocol
.\"O fields return the socket creation parameters (i.e., these fields have
.\"O the same meaning as the corresponding arguments of
.\"O .BR socket (2)).
.IR ai_family ,
.IR ai_socktype ,
.I ai_protocol
フィールドはソケット生成パラメータを返す
(これらのフィールドの意味は
.BR socket (2)
の同じ名前の引き数と同じである)。
.\"O For example,
.\"O .I ai_family
.\"O might return
.\"O .B AF_INET
.\"O or
.\"O .BR AF_INET6 ;
.\"O .I ai_socktype
.\"O might return
.\"O .B SOCK_DGRAM
.\"O or
.\"O .BR SOCK_STREAM ;
.\"O and
.\"O .I ai_protocol
.\"O returns the protocol for the socket.
例えば、
.I ai_family
は
.B AF_INET
や
.B AF_INET6
を返し、
.I ai_socktype
は
.B SOCK_DGRAM
や
.BR SOCK_STREAM
を返し、
.I ai_protocol
はそのソケットのプロトコルを返す。
.IP *
.\"O A pointer to the socket address is placed in the
.\"O .I ai_addr
.\"O field, and the length of the socket address, in bytes,
.\"O is placed in the
.\"O .I ai_addrlen
.\"O field.
.I ai_addr
フィールドにはソケットアドレスへのポインタが書き込まれ、
.I ai_addrlen
フィールドにはソケットアドレスの長さがバイト単位で書き込まれる。
.PP
.\"O If
.\"O .I hints.ai_flags
.\"O includes the
.\"O .B AI_ADDRCONFIG
.\"O flag, then IPv4 addresses are returned in the list pointed to by
.\"O .I res
.\"O only if the local system has at least one
.\"O IPv4 address configured, and IPv6 addresses are only returned
.\"O if the local system has at least one IPv6 address configured.
.I hints.ai_flags
が
.B AI_ADDRCONFIG
を含む場合、
.I res
が指すリストには、
ローカルシステムに最低一つの IPv4 アドレスが設定されている場合は
IPv4 アドレスが返され、
ローカルシステムに最低一つの IPv6 アドレスが設定されている場合は
IPv6 アドレスが返される。
.PP
.\"O If
.\"O .I hint.ai_flags
.\"O specifies the
.\"O .B AI_V4MAPPED
.\"O flag, and
.\"O .I hints.ai_family
.\"O was specified as
.\"O .BR AF_INET6 ,
.\"O and no matching IPv6 addresses could be found,
.\"O then return IPv4-mapped IPv6 addresses in the list pointed to by
.\"O .IR res .
.I hint.ai_flags
に
.B AI_V4MAPPED
が指定されていて、
.I hints.ai_family
に
.B AF_INET6
が指定され、
マッチする IPv6 アドレスが見つからなかった場合、
.I res
が指すリストには IPv4-mapped IPv6 アドレスが返される。
.\"O If both
.\"O .B AI_V4MAPPED
.\"O and
.\"O .B AI_ALL
.\"O are specified in
.\"O .IR hints.ai_flags ,
.\"O then return both IPv6 and IPv4-mapped IPv6 addresses
.\"O in the list pointed to by
.\"O .IR res .
.I hints.ai_flags
に
.B AI_V4MAPPED
と
.B AI_ALL
の両方が指定されている場合、
.I res
が指すリストには IPv6 アドレスと IPv4-mapped IPv6 アドレスの
両方が返される。
.\"O .B AI_ALL
.\"O is ignored if
.\"O .B AI_V4MAPPED
.\"O is not also specified.
.B AI_V4MAPPED
が指定されていない場合、
.B AI_ALL
は無視される。
.PP
.\"O The
.\"O .BR freeaddrinfo ()
.\"O function frees the memory that was allocated
.\"O for the dynamically allocated linked list
.\"O .IR res .
.BR freeaddrinfo ()
関数は、
リンクリスト
.I res
に対して動的に割り当てられたメモリを解放する。
.\"O .SS "Extensions to getaddrinfo() for Internationalized Domain Names"
.SS "国際化ドメイン名のための getaddrinfo() の拡張"
.PP
.\"O Starting with glibc 2.3.4,
.\"O .BR getaddrinfo ()
.\"O has been extended to selectively allow the incoming and outgoing
.\"O hostnames to be transparently converted to and from the
.\"O Internationalized Domain Name (IDN) format (see RFC 3490,
.\"O .IR "Internationalizing Domain Names in Applications (IDNA)" ).
.\"O Four new flags are defined:
glibc 2.3.4 から、
.BR getaddrinfo ()
は入出力するホスト名を透過的に国際化ドメイン名 (IDN) 形式 (RFC 3490 の
.I "Internationalizing Domain Names in Applications (IDNA)"
を参照のこと) と変換することを選択的に認めるように拡張されている。
4 つの新しいフラグが定義されている:
.TP
.B AI_IDN
.\"O If this flag is specified, then the node name given in
.\"O .I node
.\"O is converted to IDN format if necessary.
.\"O The source encoding is that of the current locale.
このフラグが指定されると、
.I node
で与えられたノード名は必要があれば IDN 形式に変換される。
ソース符号化形式は現在のロケールのものである。

.\"O If the input name contains non-ASCII characters, then the IDN encoding
.\"O is used.
.\"O Those parts of the node name (delimited by dots) that contain
.\"O non-ASCII characters are encoded using ASCII Compatible Encoding (ACE)
.\"O before being passed to the name resolution functions.
入力名に非 ASCII 文字が含まれている場合、
IDN 符号化形式が使われる。
非 ASCII 文字が含まれている(ピリオドで区切られる)部分ノード名は、
名前解決機能に渡される前に ASCII 互換符号化形式 (ACE) を使って
符号化される。
.\" Implementation Detail:
.\" To minimize effects on system performance the implementation might
.\" want to check whether the input string contains any non-ASCII
.\" characters.  If there are none the IDN step can be skipped completely.
.\" On systems which allow not-ASCII safe encodings for a locale this
.\" might be a problem.
.TP
.B AI_CANONIDN
.\"O After a successful name lookup, and if the
.\"O .B AI_CANONNAME
.\"O flag was specified,
.\"O .BR getaddrinfo ()
.\"O will return the canonical name of the
.\"O node corresponding to the
.\"O .I addrinfo
.\"O structure value passed back.
.\"O The return value is an exact copy of the value returned by the name
.\"O resolution function.
.B AI_CANONNAME
が指定されている場合、
.BR getaddrinfo ()
は名前の検索に成功した後、
返された
.I addrinfo
構造体に対応するノードの正規名を返す。
返り値は名前解決機能から返された値の正確なコピーである。

.\"O If the name is encoded using ACE, then it will contain the
.\"O .I xn\-\-
.\"O prefix for one or more components of the name.
.\"O To convert these components into a readable form the
.B AI_CANONIDN
.\"O flag can be passed in addition to
.\"O .BR AI_CANONNAME .
.\"O The resulting string is encoded using the current locale's encoding.
名前が ACE で符号化されている場合、一つまたは複数の名前の構成要素の先頭に
.I xn\-\-
を含んでいる。
これらの構成要素を読み込み可能な形に変換するために、
.B AI_CANONNAME
と共に
.B AI_CANONIDN
フラグを渡すことも出来る。
返される文字列は現在のロケールの符号化形式で符号化されている。
.\"
.\"Implementation Detail:
.\"If no component of the returned name starts with xn\-\- the IDN
.\"step can be skipped, therefore avoiding unnecessary slowdowns.
.TP
.BR AI_IDN_ALLOW_UNASSIGNED ", " AI_IDN_USE_STD3_ASCII_RULES
.\"O Setting these flags will enable the
.\"O IDNA_ALLOW_UNASSIGNED (allow unassigned Unicode code points) and
.\"O IDNA_USE_STD3_ASCII_RULES (check output to make sure it is a STD3
.\"O conforming hostname)
.\"O flags respectively to be used in the IDNA handling.
これらのフラグが設定されると、
IDNA ハンドリングを使うときにそれぞれ
IDNA_ALLOW_UNASSIGNED (非割り当て Unicode コードポイントを許可する) と
IDNA_USE_STD3_ASCII_RULES (出力が STD3 準拠ホスト名であることを確認する)
フラグが有効になる。

.\"O .SH "RETURN VALUE"
.SH 返り値
.\" FIXME glibc defines the following additional errors, some which
.\" can probably be returned by getaddrinfo(); they need to
.\" be documented.
.\" #ifdef __USE_GNU
.\" #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
.\" #define EAI_CANCELED    -101  /* Request canceled.  */
.\" #define EAI_NOTCANCELED -102  /* Request not canceled.  */
.\" #define EAI_ALLDONE     -103  /* All requests done.  */
.\" #define EAI_INTR        -104  /* Interrupted by a signal.  */
.\" #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
.\" #endif
.\"O .BR getaddrinfo ()
.\"O returns 0 if it succeeds, or one of the following nonzero error codes:
.BR getaddrinfo ()
は成功すると 0 を返し、失敗すると以下の非 0 のエラーコードのいずれかを返す。
.TP
.B EAI_ADDRFAMILY
.\" Not in SUSv3
.\"O The specified network host does not have any network addresses in the
.\"O requested address family.
指定されたネットワークホストには、
要求されたアドレスファミリーのネットワークアドレスがない。
.TP
.B EAI_AGAIN
.\"O The name server returned a temporary failure indication.
.\"O Try again later.
ネームサーバーから一時的な失敗 (temporary failure)
を意味する返事が返された。後でもう一度試してみよ。
.TP
.B EAI_BADFLAGS
.\"O .I hints.ai_flags
.\"O contains invalid flags; or,
.\"O .I hints.ai_flags
.\"O included
.\"O .B AI_CANONNAME
.\"O and
.\"O .I name
.\"O was NULL.
.I hints.ai_flags
のフラグに不正なフラグが含まれている。または、
.I hints.ai_flags
に
.B AI_CANONNAME
が含まれていて、かつ
.I name
が NULL であった。
.TP
.B EAI_FAIL
.\"O The name server returned a permanent failure indication.
ネームサーバーから恒久的な失敗 (permanent failure)
を意味する返事が返された。
.TP
.B EAI_FAMILY
.\"O The requested address family is not supported.
要求されたアドレスファミリーがサポートされていない。
.TP
.B EAI_MEMORY
.\"O Out of memory.
メモリが足りない。
.TP
.B EAI_NODATA
.\" Not in SUSv3
.\"O The specified network host exists, but does not have any
.\"O network addresses defined.
指定されたネットワークホストは存在するが、
ネットワークアドレスがひとつも定義されていない。
.TP
.B EAI_NONAME
.\"O The
.\"O .I node
.\"O or
.\"O .I service
.\"O is not known; or both
.\"O .I node
.\"O and
.\"O .I service
.\"O are NULL; or
.\"O .B AI_NUMERICSERV
.\"O was specified in
.\"O .I hints.ai_flags
.\"O and
.\"O .I service
.\"O was not a numeric port-number string.
.I node
と
.I service
のどちらかが不明、または
.I node
と
.I service
の両方が NULL だった場合、または
.B AI_NUMERICSERV
が
.I hints.ai_flags
に指定されていて、
.I hints.ai_flags
と
.I service
が数値のポート番号の文字列でない。
.TP
.B EAI_SERVICE
.\"O The requested service is not available for the requested socket type.
.\"O It may be available through another socket type.
要求されたサービスは、要求されたソケットタイプでは利用できない。
他のソケットタイプでなら利用可能かもしれない。
.\"O For example, this error could occur if
.\"O .I service
.\"O was "shell" (a service only available on stream sockets), and either
.\"O .I hints.ai_protocol
.\"O was
.\"O .BR IPPROTO_UDP ,
.\"O or
.\"O .I hints.ai_socktype
.\"O was
.\"O .BR SOCK_DGRAM ;
.\"O or the error could occur if
.\"O .I service
.\"O was not NULL, and
.\"O .I hints.ai_socktype
.\"O was
.\"O .BR SOCK_RAW
.\"O (a socket type that does not support the concept of services).
このエラーが発生する例としては、
.I service
が "shell" (ストリーム・ソケットでのみ利用できるサービス) で、
.I hints.ai_protocol
に
.B IPPROTO_UDP
が指定されたり、
.I hints.ai_socktype
に
.B SOCK_DGRAM
が指定されたりした場合がある。
また、
.I service
が NULL 以外で、
.I hints.ai_socktype
に
.B SOCK_RAW
(サービスの考え方をサポートしていないソケット種別)
が指定された場合にも、このエラーが発生する。
.TP
.B EAI_SOCKTYPE
.\"O The requested socket type is not supported.
要求されたソケットタイプがサポートされていない。
.\"O This could occur, for example, if
.\"O .I hints.ai_socktype
.\"O and
.\"O .I hints.ai_protocol
.\"O are inconsistent (e.g.,
.\"O .BR SOCK_DGRAM
.\"O and
.\"O .BR IPPROTO_TCP ,
.\"O respectively).
このエラーが発生する例としては、
.I hints.ai_socktype
と
.I hints.ai_protocol
が矛盾している場合 (例えば
.I hints.ai_socktype
が
.B SOCK_DGRAM
で
.I hints.ai_protocol
が
.BR IPPROTO_TCP )
がある。
.TP
.B EAI_SYSTEM
.\"O Other system error, check
.\"O .I errno
.\"O for details.
その他のシステムエラー。詳しくは
.I errno
を調べること。
.PP
.\"O The
.\"O .BR gai_strerror ()
.\"O function translates these error codes to a human readable string,
.\"O suitable for error reporting.
.BR gai_strerror ()
関数を用いると、これらのエラーコードを人間に可読な文字列に変換できるので、
エラー報告に適するだろう。
.\"O .SH "FILES"
.SH ファイル
.I /etc/gai.conf
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O POSIX.1-2001.
.\"O The
.\"O .BR getaddrinfo ()
.\"O function is documented in RFC\ 2553.
POSIX.1-2001.
.BR getaddrinfo ()
関数は RFC 2553 に記載されている。
.\"O .SH "NOTES"
.SH 注意
.\"O .BR getaddrinfo ()
.\"O supports the
.\"O .IB address % scope-id
.\"O notation for specifying the IPv6 scope-ID.
.BR getaddrinfo ()
は、IPv6 scope-ID を指定するために
.IB address % scope-id
記法をサポートしている。

.\"O .BR AI_ADDRCONFIG ,
.\"O .BR AI_ALL ,
.\"O and
.\"O .B AI_V4MAPPED
.\"O are available since glibc 2.3.3.
.\"O .B AI_NUMERICSERV
.\"O is available since glibc 2.3.4.
.BR AI_ADDRCONFIG ,
.BR AI_ALL ,
.B AI_V4MAPPED
は glibc 2.3.3 以降で利用可能である。
.B AI_NUMERICSERV
は glibc 2.3.4 以降で利用可能である。

.\"O According to POSIX.1-2001, specifying
.\"O .I hints
.\"O as NULL should cause
.\"O .I ai_flags
.\"O to be assumed as 0.
.\"O The GNU C library instead assumes a value of
.\"O .BR "(AI_V4MAPPED\ |\ AI_ADDRCONFIG)"
.\"O for this case,
.\"O since this value is considered an improvement on the specification.
POSIX.1-2001 によると、
.I hints
に NULL が指定された場合、
.I ai_flags
を 0 とみなすべきとされている。
GNU C ライブラリでは、この場合に、代わりに
.I ai_flags
を
.BR "(AI_V4MAPPED\ |\ AI_ADDRCONFIG)"
とみなすようになっている。
この値の方が標準規格の改善になると考えられているからである。
.\"O .SH EXAMPLE
.SH 例
.\" getnameinfo.3 refers to this example
.\" socket.2 refers to this example
.\" bind.2 refers to this example
.\" connect.2 refers to this example
.\" recvfrom.2 refers to this example
.\" sendto.2 refers to this example
.\"O The following programs demonstrate the use of
.\"O .BR getaddrinfo (),
.\"O .BR gai_strerror (),
.\"O .BR freeaddrinfo (),
.\"O and
.\"O .BR getnameinfo (3).
.\"O The programs are an echo server and client for UDP datagrams.
以下のプログラムは、
.BR getaddrinfo (),
.BR gai_strerror (),
.BR freeaddrinfo (),
.BR getnameinfo (3)
の使い方を示したものである。
プログラムは UDP データグラムの echo サーバとクライアントである。
.\"O .SS Server program
.SS サーバのプログラム
\&
.nf
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>  
#include <unistd.h>
#include <string.h>
#include <sys/socket.h>
#include <netdb.h>

#define BUF_SIZE 500

int
main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, s;
    struct sockaddr_storage peer_addr;
    socklen_t peer_addr_len;
    ssize_t nread;
    char buf[BUF_SIZE];

    if (argc != 2) {
        fprintf(stderr, "Usage: %s port\\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    s = getaddrinfo(NULL, argv[1], &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    /* getaddrinfo() returns a list of address structures.
       Try each address until we successfully bind(2).
       If socket(2) (or bind(2)) fails, we (close the socket
       and) try the next address. */

    for (rp = result; rp != NULL; rp = rp\->ai_next) {
        sfd = socket(rp\->ai_family, rp\->ai_socktype, 
                rp\->ai_protocol);
        if (sfd == \-1)
            continue;

        if (bind(sfd, rp\->ai_addr, rp\->ai_addrlen) == 0)
            break;                  /* Success */

        close(sfd);
    }

    if (rp == NULL) {               /* No address succeeded */
        fprintf(stderr, "Could not bind\\n");
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(result);           /* No longer needed */

    /* Read datagrams and echo them back to sender */

    for (;;) {
        peer_addr_len = sizeof(struct sockaddr_storage);
        nread = recvfrom(sfd, buf, BUF_SIZE, 0,
                (struct sockaddr *) &peer_addr, &peer_addr_len);
        if (nread == \-1)
            continue;               /* Ignore failed request */

        char host[NI_MAXHOST], service[NI_MAXSERV];

        s = getnameinfo((struct sockaddr *) &peer_addr,
                        peer_addr_len, host, NI_MAXHOST,
                        service, NI_MAXSERV, NI_NUMERICSERV);
       if (s == 0)
            printf("Received %ld bytes from %s:%s\\n",
                    (long) nread, host, service);
        else
            fprintf(stderr, "getnameinfo: %s\\n", gai_strerror(s));

        if (sendto(sfd, buf, nread, 0,
                    (struct sockaddr *) &peer_addr,
                    peer_addr_len) != nread)
            fprintf(stderr, "Error sending response\\n");
    }
}
.fi
.\"O .SS Client program
.SS クライアントのプログラム
\&
.nf
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#define BUF_SIZE 500

int
main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, s, j;
    size_t len;
    ssize_t nread;
    char buf[BUF_SIZE];

    if (argc < 3) {
        fprintf(stderr, "Usage: %s host port msg...\\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /* Obtain address(es) matching host/port */

    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = 0;
    hints.ai_protocol = 0;          /* Any protocol */

    s = getaddrinfo(argv[1], argv[2], &hints, &result);
    if (s != 0) {
        fprintf(stderr, "getaddrinfo: %s\\n", gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    /* getaddrinfo() returns a list of address structures.
       Try each address until we successfully connect(2).
       If socket(2) (or connect(2)) fails, we (close the socket
       and) try the next address. */

    for (rp = result; rp != NULL; rp = rp\->ai_next) {
        sfd = socket(rp\->ai_family, rp\->ai_socktype,
                     rp\->ai_protocol);
        if (sfd == \-1)
            continue;

        if (connect(sfd, rp\->ai_addr, rp\->ai_addrlen) != \-1)
            break;                  /* Success */

        close(sfd);
    }

    if (rp == NULL) {               /* No address succeeded */
        fprintf(stderr, "Could not connect\\n");
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(result);           /* No longer needed */

    /* Send remaining command\-line arguments as separate 
       datagrams, and read responses from server */

    for (j = 3; j < argc; j++) {
        len = strlen(argv[j]) + 1;
                /* +1 for terminating null byte */

        if (len + 1 > BUF_SIZE) {
            fprintf(stderr,
                    "Ignoring long message in argument %d\\n", j);
            continue;
        }

        if (write(sfd, argv[j], len) != len) {
            fprintf(stderr, "partial/failed write\\n");
            exit(EXIT_FAILURE);
        }

        nread = read(sfd, buf, BUF_SIZE);
        if (nread == \-1) {
            perror("read");
            exit(EXIT_FAILURE);
        }

        printf("Received %ld bytes: %s\\n", (long) nread, buf);
    }

    exit(EXIT_SUCCESS);
}
.fi
.\"O .SH "SEE ALSO"
.SH 関連項目
.\" .BR getipnodebyaddr (3),
.\" .BR getipnodebyname (3)
.BR getaddrinfo_a (3),
.BR gethostbyname (3),
.BR getnameinfo (3),
.BR inet (3),
.BR hostname (7),
.BR ip (7)

'\" t
.\" Don't change the line above. it tells man that tbl is needed.
.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: ip.7,v 1.19 2000/12/20 18:10:31 ak Exp $
.\"
.\" Japanese Version Copyright (c) 1999 NAKANO Takeo all rights reserved.
.\" Translated 1999-12-06, NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Updated 2001-02-14, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2001-04-04, Yuichi SATO <ysato@h4.dion.ne.jp>
.\" Updated & Modified 2003-10-16, Yuichi SATO <ysato444@yahoo.co.jp>
.\" Updated & Modified 2005-01-22, Yuichi SATO
.\" Updated & Modified 2005-09-10, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated & Modified 2005-10-06, Akihiro MOTOKI
.\" Updated 2007-01-05, Akihiro MOTOKI, Catch up to LDP man-pages 2.43
.\" Updated 2007-05-28, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.48
.\" Updated 2008-12-26, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.14
.\"
.\"WORD		ancillary message	補助メッセージ
.\"WORD		... oriented		〜指向の
.\"WORD		capability		権限
.\"WORD		payload			ペイロード
.\"WORD		drop(ped)	(パケットを) 落とす、(受動の場合) 到着しない
.\"WORD		tap			タップ(する)
.\"
.TH IP  7 2009-02-28 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O ip \- Linux IPv4 protocol implementation
ip \- Linux IPv4 プロトコルの実装
.\"O .SH SYNOPSIS
.SH 書式
.B #include <sys/socket.h>
.br
.\" .B #include <net/netinet.h> -- does not exist anymore
.\" .B #include <linux/errqueue.h> -- never include <linux/foo.h>
.B #include <netinet/in.h>
.br
.\"O .B #include <netinet/ip.h>        \fR/* superset of previous */
.B #include <netinet/ip.h>        \fR/* 上記のスーパーセット */
.sp
.IB tcp_socket " = socket(AF_INET, SOCK_STREAM, 0);"
.br
.IB udp_socket " = socket(AF_INET, SOCK_DGRAM, 0);"
.br
.IB raw_socket " = socket(AF_INET, SOCK_RAW, " protocol ");"
.\"O .SH DESCRIPTION
.SH 説明
.\"O Linux implements the Internet Protocol, version 4,
.\"O described in RFC\ 791 and RFC\ 1122.
.\"O .B ip
.\"O contains a level 2 multicasting implementation conforming to RFC\ 1112.
.\"O It also contains an IP router including a packet filter.
Linux は RFC\ 791 と RFC\ 1122 で記述されている
Internet Protocol, version 4 を実装している。
.B ip
には RFC\ 1112 に準拠した level 2 マルチキャストの実装が含まれている。
またパケットフィルタ機能を含む IP ルーターも実装されている。
.\" FIXME has someone verified that 2.1 is really 1812 compliant?
.PP
.\"O The programming interface is BSD-sockets compatible.
.\"O For more information on sockets, see
.\"O .BR socket (7).
プログラミング・インターフェースは BSD ソケットと互換である。
ソケットに関するより詳細な情報は
.BR socket (7)
を参照のこと。
.PP
.\"O An IP socket is created by calling the
.\"O .BR socket (2)
.\"O function as
.\"O .BR "socket(AF_INET, socket_type, protocol)" .
IP ソケットは、
.BR socket (2)
関数を
.B "socket(AF_INET, socket_type, protocol)"
のように呼び出すことで生成される。
.\"O Valid socket types are
.\"O .B SOCK_STREAM
.\"O to open a
.\"O .BR tcp (7)
.\"O socket,
.\"O .B SOCK_DGRAM
.\"O to open a
.\"O .BR udp (7)
.\"O socket, or
.\"O .B SOCK_RAW
.\"O to open a
.\"O .BR raw (7)
.\"O socket to access the IP protocol directly.
指定できるソケットタイプは 3 つあり、
.BR tcp (7)
ソケットをオープンする場合
.BR SOCK_STREAM 、
.BR udp (7)
ソケットをオープンする場合
.BR SOCK_DGRAM 、
IP プロトコルに直接アクセスするために
.BR raw (7)
ソケットをオープンする場合には
.B SOCK_RAW
である。
.\"O .I protocol
.\"O is the IP protocol in the IP header to be received or sent.
.\"O The only valid values for
.\"O .I protocol
.\"O are 0 and
.\"O .B IPPROTO_TCP
.\"O for TCP sockets, and 0 and
.\"O .B IPPROTO_UDP
.\"O for UDP sockets.
.\"O For
.\"O .B SOCK_RAW
.\"O you may specify a valid IANA IP protocol defined in
.\"O RFC\ 1700 assigned numbers.
.I protocol
は送受信される IP ヘッダに書かれる IP プロトコルである。
指定できる値は、
TCP ソケットには 0 か
.BR IPPROTO_TCP 、
UDP ソケットには 0 か
.B IPPROTO_UDP
に限られる。
.B SOCK_RAW
に対しては、 RFC\ 1700 で定義されている有効な IANA IP プロトコルを、
割り当てられている番号で指定することができる。
.PP
.\" FIXME ip current does an autobind in listen, but I'm not sure
.\" if that should be documented.
.\"O When a process wants to receive new incoming packets or connections, it
.\"O should bind a socket to a local interface address using
.\"O .BR bind (2).
.\"O Only one IP socket may be bound to any given local (address, port) pair.
.\"O When
.\"O .B INADDR_ANY
.\"O is specified in the bind call, the socket will be bound to
.\"O .I all
.\"O local interfaces.
.\"O When
.\"O .BR listen (2)
.\"O or
.\"O .BR connect (2)
.\"O are called on an unbound socket, it is automatically bound to a
.\"O random free port with the local address set to
.\"O .BR INADDR_ANY .
あるプロセスで、やってくるパケットを受信したり
接続要求を受けたりしたい場合には、
そのプロセスはローカルなインターフェースアドレスに、
.BR bind (2)
を用いてソケットをバインドしなければならない。
あるローカルな「アドレスとポート」のペアに対してバインドできる
IP ソケットは一つに限られる。
.BR bind (2)
の呼び出しで
.B INADDR_ANY
が指定されていた場合は、ソケットはローカルなインターフェースの
\fIすべて\fPにバインドされる。
.BR listen (2)
または
.BR connect (2)
がバインドされていないソケットでコールされると、
そのソケットは自動的にローカルなアドレスを
.B INADDR_ANY
にセットし、空いているポートをランダムに選んでバインドする。

.\"O A TCP local socket address that has been bound is unavailable for
.\"O some time after closing, unless the
.\"O .B SO_REUSEADDR
.\"O flag has been set.
.\"O Care should be taken when using this flag as it makes TCP less reliable.
.B SO_REUSEADDR
フラグがセットされていない場合には、
バインドされていた TCP ローカルソケットアドレスは
クローズされた後しばらくの間使えなくなる。
.B SO_REUSEADDR
フラグを使うと TCP の信頼性を低下させるので、
使うときには注意が必要である。
.\"O .SS Address Format
.SS アドレスのフォーマット
.\"O An IP socket address is defined as a combination of an IP interface
.\"O address and a 16-bit port number.
.\"O The basic IP protocol does not supply port numbers, they
.\"O are implemented by higher level protocols like
.\"O .BR udp (7)
.\"O and
.\"O .BR tcp (7).
.\"O On raw sockets
.\"O .I sin_port
.\"O is set to the IP protocol.
IP ソケットアドレスは、 IP インターフェースアドレスと
16ビットのポート番号の組み合わせで定義される。
IP プロトコルそのものはポート番号を扱わない。
ポート番号は、
.BR udp (7)
や
.BR tcp (7)
といった、上位のプロトコルで実装される。
raw ソケットでは、
.I sin_port
が IP プロトコルにセットされる。
.PP
.in +4n
.nf
struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
.fi
.in
.PP
.\"O .I sin_family
.\"O is always set to
.\"O .BR AF_INET .
.\"O This is required; in Linux 2.2 most networking functions return
.\"O .B EINVAL
.\"O when this setting is missing.
.\"O .I sin_port
.\"O contains the port in network byte order.
.\"O The port numbers below 1024 are called
.\"O .IR "privileged ports"
.\"O (or sometimes:
.\"O .IR "reserved ports" ).
.\"O Only privileged processes (i.e., those having the
.\"O .B CAP_NET_BIND_SERVICE
.\"O capability) may
.\"O .BR bind (2)
.\"O to these sockets.
.\"O Note that the raw IPv4 protocol as such has no concept of a
.\"O port, they are only implemented by higher protocols like
.\"O .BR tcp (7)
.\"O and
.\"O .BR udp (7).
.I sin_familiy
には常に
.B AF_INET
をセットする。これは必須である。 Linux 2.2 では、このセットを忘れると
ほとんどのネットワーク関数は
.B EINVAL
を返すようになっている。
.I sin_port
にはポート番号をネットワークバイトオーダーで指定する。
1024 未満のポート番号は
.I "特権ポート (privileged ports)"
と呼ばれる
.RI ( "予約ポート (reserved ports)"
とも時々呼ばれる)。
特権プロセス
.RB ( CAP_NET_BIND_SERVICE
ケーパビリティを持つプロセス) 以外のプロセスは、これらのポートには
.BR bind (2)
できない。 IPv4 プロトコルそのものにはポートに関する概念がない。
ポートは、
.BR tcp (7)
や
.BR udp (7)
といった、上位のプロトコルにおいて実装される。
.PP
.\"O .I sin_addr
.\"O is the IP host address.
.\"O The
.\"O .I s_addr
.\"O member of
.\"O .I struct in_addr
.\"O contains the host interface address in network byte order.
.I sin_addr
は IP ホストアドレスである。
.I struct in_addr
の
.I s_addr
メンバには、ホストのインターフェースアドレスを
ネットワークバイトオーダーで指定する。
.\"O .I in_addr
.\"O should be assigned one of the INADDR_* values (e.g.,
.\"O .BR INADDR_ANY )
.\"O or set using the
.\"O .BR inet_aton (3),
.\"O .BR inet_addr (3),
.\"O .BR inet_makeaddr (3)
.\"O library functions or directly with the name resolver (see
.\"O .BR gethostbyname (3)).
.I in_addr
は、INADDR_* の一つ (例えば
.BR INADDR_ANY )
を代入する、
ライブラリ関数
.BR inet_aton (3),
.BR inet_addr (3),
.BR inet_makeaddr (3)
を用いる、あるいは名前解決機構 (name resolver)
を直接用いる、のどれかで設定すべきである。
.RB ( gethostbyname (3)
を見よ)。

.\"O IPv4 addresses are divided into unicast, broadcast
.\"O and multicast addresses.
.\"O Unicast addresses specify a single interface of a host,
.\"O broadcast addresses specify all hosts on a network and multicast
.\"O addresses address all hosts in a multicast group.
.\"O Datagrams to broadcast addresses can be only sent or received when the
.\"O .B SO_BROADCAST
.\"O socket flag is set.
IPv4 アドレスには、ユニキャストアドレス、
ブロードキャストアドレス、マルチキャストアドレスがある。
ユニキャストアドレスは、あるホストの一つのアドレスを指定する。
ブロードキャストアドレスは、あるネットワーク上の全てのホストを指定する。
マルチキャストアドレスは、マルチキャストグループに所属する
全てのホストを指定する。ブロードキャストアドレスへのデータグラムは、
.B SO_BROADCAST
ソケットフラグがセットされていないと送信・受信できない。
.\"O In the current implementation, connection oriented sockets are only allowed
.\"O to use unicast addresses.
現在の実装では、接続指向のソケットにはユニキャストアドレスしか使えない。
.\" Leave a loophole for XTP @)

.\"O Note that the address and the port are always stored in
.\"O network byte order.
.\"O In particular, this means that you need to call
.\"O .BR htons (3)
.\"O on the number that is assigned to a port.
.\"O All address/port manipulation
.\"O functions in the standard library work in network byte order.
アドレスとポートは常にネットワークバイトオーダーで格納されることに注意せよ。
具体的には、ポートを指定する数値には
.BR htons (3)
を呼び出す必要がある。
標準ライブラリにあるアドレス/ポート操作関数は
すべてネットワークバイトオーダーで動作する。

.\"O There are several special addresses:
.\"O .B INADDR_LOOPBACK
.\"O (127.0.0.1)
.\"O always refers to the local host via the loopback device;
.\"O .B INADDR_ANY
.\"O (0.0.0.0)
.\"O means any address for binding;
.\"O .B INADDR_BROADCAST
.\"O (255.255.255.255)
.\"O means any host and has the same effect on bind as
.\"O .B INADDR_ANY
.\"O for historical reasons.
特別なアドレスがいくつか存在する:
.TP
.BR INADDR_LOOPBACK (127.0.0.1)
loopback デバイスを通して常にローカルなホストを参照する。
.TP
.BR INADDR_ANY (0.0.0.0)
バインドに用いる任意のアドレス。
.TP
.BR INADDR_BROADCAST (255.255.255.255)
任意のホスト。歴史的理由から、バインドの際には
.B INADDR_ANY
と同じ効果になる。
.\"O .SS Socket Options
.SS ソケットオプション
.\"O IP supports some protocol-specific socket options that can be set with
.\"O .BR setsockopt (2)
.\"O and read with
.\"O .BR getsockopt (2).
.\"O The socket option level for IP is
.\"O .BR IPPROTO_IP .
.\"O .\" or SOL_IP on Linux
.\"O A boolean integer flag is zero when it is false, otherwise true.
IP にはプロトコル固有のソケットオプションがいくつか存在し、
.BR setsockopt (2)
で設定が、
.BR getsockopt (2)
で取得ができる。 IP のソケットオプションレベルは
.B IPPROTO_IP
.\" Linux では SOL_IP も可
である。
ブール整数値のフラグでは、 0 は偽、それ以外は真を意味する。
.\"
.\" FIXME Document IP_FREEBIND
.\" Boolean
.\" Since Linux 2.4.0-test10
.\"
.TP
.\"O .BR IP_ADD_MEMBERSHIP " (since Linux 1.2)"
.BR IP_ADD_MEMBERSHIP " (Linux 1.2 以降)"
.\"O Join a multicast group.
.\"O Argument is an
.\"O .I ip_mreqn
.\"O structure.
マルチキャストグループに参加する。
引き数は
.I ip_mreqn
構造体である。
.sp
.in +4n
.nf
struct ip_mreqn {
    struct in_addr imr_multiaddr; /* IP multicast group
                                     address */
    struct in_addr imr_address;   /* IP address of local
                                     interface */
    int            imr_ifindex;   /* interface index */
};
.fi
.in
.sp
.\"O .I imr_multiaddr
.\"O contains the address of the multicast group the application
.\"O wants to join or leave.
.\"O It must be a valid multicast address
.\"O .\" (i.e., within the 224.0.0.0-239.255.255.255 range)
.\"O (or
.\"O .BR setsockopt (2)
.\"O fails with the error
.\"O .BR EINVAL ).
.\"O .I imr_address
.\"O is the address of the local interface with which the system
.\"O should join the multicast group; if it is equal to
.\"O .B INADDR_ANY
.\"O an appropriate interface is chosen by the system.
.\"O .I imr_ifindex
.\"O is the interface index of the interface that should join/leave the
.\"O .I imr_multiaddr
.\"O group, or 0 to indicate any interface.
.I imr_multiaddr
には、アプリケーションが参加または撤退したい
マルチキャストグループのアドレスが入る。
指定するアドレスは有効なマルチキャストアドレスでなければならない
.\" (つまり、224.0.0.0-239.255.255.255 の範囲内)
(さもなければ
.BR setsockopt (2)
がエラー
.B EINVAL
で失敗する)。
.I imr_address
はシステムがマルチキャストグループに参加する際に用いる
ローカルなインターフェースのアドレスである。
これが
.B INADDR_ANY
であった場合には、適切なインターフェースがシステムによって選択される。
.I imr_ifindex
は
.I imr_multiaddr
グループに参加/撤退するインターフェースの interface index である。
どのインターフェースでもよい場合は 0 にする。
.IP
.\"O The
.\"O .I ip_mreqn
.\"O is available only since Linux 2.2.
.\"O For compatibility, the old
.\"O .I ip_mreq
.\"O structure (present since Linux 1.2) is still supported.
.\"O It differs from
.\"O .I ip_mreqn
.\"O only by not including the
.\"O .I imr_ifindex
.\"O field.
.\"O Only valid as a
.\"O .BR setsockopt (2).
.I ip_mreqn
は Linux 2.2 以降でのみ利用可能である。
互換性のため、古い
.I ip_mreq
構造体 (Linux 1.2 以降で存在する) もまだサポートされている。
.I ip_mreqn
との違いは、
.I imr_ifindex
フィールドを含まないことだけである。
.BR setsockopt (2)
でのみ使える。
.\"
.TP
.\"O .BR IP_DROP_MEMBERSHIP " (since Linux 1.2)"
.BR IP_DROP_MEMBERSHIP " (Linux 1.2 以降)"
.\"O Leave a multicast group.
.\"O Argument is an
.\"O .I ip_mreqn
.\"O or
.\"O .I ip_mreq
.\"O structure similar to
.\"O .BR IP_ADD_MEMBERSHIP .
マルチキャストグループから抜ける。引き数は
.B IP_ADD_MEMBERSHIP
と同様に
.I ip_mreqn
または
.I ip_mreq
構造体である。
.TP
.\"O .BR IP_HDRINCL " (since Linux 2.0)"
.BR IP_HDRINCL " (Linux 2.0 以降)"
.\"O If enabled,
.\"O the user supplies an IP header in front of the user data.
.\"O Only valid for
.\"O .B SOCK_RAW
.\"O sockets.
.\"O See
.\"O .BR raw (7)
.\"O for more information.
.\"O When this flag is enabled the values set by
.\"O .BR IP_OPTIONS ,
.\"O .B IP_TTL
.\"O and
.\"O .B IP_TOS
.\"O are ignored.
有効になっていると、ユーザは IP ヘッダをユーザーデータの前に与える。
.B SOCK_RAW
ソケットでのみ有効である。詳細は
.BR raw (7)
を見よ。このフラグが有効になっていると、
.BR IP_OPTIONS ,
.BR IP_TTL ,
.B IP_TOS
は無視される。
.\" FIXME Document IP_IPSEC_POLICY
.\" Since Linux 2.5.47
.\" Needs CAP_NET_ADMIN
.TP
.\"O .BR IP_MTU " (since Linux 2.2)"
.BR IP_MTU " (Linux 2.2 以降)"
.\" Precisely: 2.1.124
.\"O Retrieve the current known path MTU of the current socket.
.\"O Only valid when the socket has been connected.
.\"O Returns an integer.
.\"O Only valid as a
.\"O .BR getsockopt (2).
ソケットの、既知の path MTU を取得する。
ソケットが接続している場合のみ有効である。
.BR getsockopt (2)
でのみ使える。
.TP
.\"O .BR IP_MTU_DISCOVER " (since Linux 2.2)"
.BR IP_MTU_DISCOVER " (Linux 2.2 以降)"
.\" Precisely: 2.1.124
.\"O Set or receive the Path MTU Discovery setting for a socket.
.\"O When enabled, Linux will perform Path MTU Discovery
.\"O as defined in RFC\ 1191
.\"O on this socket.
.\"O The don't-fragment flag is set on all outgoing datagrams.
.\"O The system-wide default is controlled by the
.\"O .I /proc/sys/net/ipv4/ip_no_pmtu_disc
.\"O file for
.\"O .B SOCK_STREAM
.\"O sockets, and disabled on all others.
.\"O For
.\"O .RB non- SOCK_STREAM
.\"O sockets, it is the user's responsibility to packetize the data
.\"O in MTU sized chunks and to do the retransmits if necessary.
.\"O The kernel will reject packets that are bigger than the known
.\"O path MTU if this flag is set (with
.\"O .B EMSGSIZE
.\"O ).
ソケットの Path MTU Discovery の設定をセット・取得する。
有効になっていると、 Linux はこのソケットに対して
RFC\ 1191 で定義されている Path MTU Discovery を行う。
発信データグラムには、全て「フラグメント不許可」フラグがセットされる。
システム全体に対するデフォルトは、
.B SOCK_STREAM
ソケットに対しては
.I /proc/sys/net/ipv4/ip_no_pmtu_disc
ファイルにより制御できる。
その他については無効となっている。
.B SOCK_STREAM
でないソケットに対しては、
ユーザーがデータを MTU のサイズの塊にパケット化したり、
必要な場合には再送したりしなければならない。
このフラグがセットされていると、
カーネルは既知の path MTU より大きなパケットを拒否する
.RB ( EMSGSIZE
となる)。
.TS
tab(:);
c l
l l.
.\"O Path MTU discovery flags:Meaning
.\"O IP_PMTUDISC_WANT:Use per-route settings.
.\"O IP_PMTUDISC_DONT:Never do Path MTU Discovery.
.\"O IP_PMTUDISC_DO:Always do Path MTU Discovery.
.\"O IP_PMTUDISC_PROBE:Set DF but ignore Path MTU.
Path MTU discovery フラグ:意味
IP_PMTUDISC_WANT:ルートごとの設定を用いる。
IP_PMTUDISC_DONT:Path MTU Discovery を行わない。
IP_PMTUDISC_DO:常に Path MTU Discovery を行う。
IP_PMTUDISC_PROBE:DFビットをセットするが、Path MTU を無視する。
.TE

.\"O When PMTU discovery is enabled, the kernel automatically keeps track of
.\"O the path MTU per destination host.
.\"O When it is connected to a specific peer with
.\"O .BR connect (2),
.\"O the currently known path MTU can be retrieved conveniently using the
.\"O .B IP_MTU
.\"O socket option (e.g., after a
.\"O .B EMSGSIZE
.\"O error occurred).
.\"O It may change over time.
.\"O For connectionless sockets with many destinations,
.\"O the new MTU for a given destination can also be accessed using the
.\"O error queue (see
.\"O .BR IP_RECVERR ).
.\"O A new error will be queued for every incoming MTU update.
path MTU discovery が有効になっていると、カーネルは宛先ホストごとに
自動的に path MTU を処理する。特定の相手に
.BR connect (2)
で接続した場合には、
.B IP_MTU
ソケットオプションを用いれば、既知の path MTU の取得に便利である
(たとえば
.B EMSGSIZE
エラーが起きた後など)。これは時間とともに変化するかもしれない。
宛先がたくさんあるコネクションレスなソケットでは、
与えられた宛先に対する新しい MTU にも、
エラーキューを用いてアクセスすることができる
.RB ( IP_RECVERR
を見よ)。
MTU 更新が到着するごとに、新たなエラーがキューイングされる。

.\"O While MTU discovery is in progress, initial packets from datagram sockets
.\"O may be dropped.
.\"O Applications using UDP should be aware of this and not
.\"O take it into account for their packet retransmit strategy.
MTU discovery の進行中には、データグラムソケットからの初期パケットは
到着しないかもしれない。 UDP を用いるアプリケーションでは、
このことを気にかけておき、
パケットの再送アルゴリズムにこの分を除外させるべきである。

.\"O To bootstrap the path MTU discovery process on unconnected sockets, it
.\"O is possible to start with a big datagram size
.\"O (up to 64K-headers bytes long) and let it shrink by updates of the path MTU.
接続していないソケットに対して
path MTU discovery プロセスを立ち上げるには、
大きなデータグラムサイズ (最大 64K ヘッダバイト長) からはじめて、
path MTU が更新されるまでサイズを縮めていくことも可能である。
.\" FIXME this is an ugly hack

.\"O To get an initial estimate of the
.\"O path MTU, connect a datagram socket to the destination address using
.\"O .BR connect (2)
.\"O and retrieve the MTU by calling
.\"O .BR getsockopt (2)
.\"O with the
.\"O .B IP_MTU
.\"O option.
path MTU の値をまず見積もってみるには、宛先アドレスに
.BR connect (2)
を使ってデータグラムソケットを接続し、
.BR getsockopt (2)
を
.B IP_MTU
オプションとともに呼び、 MTU を取得することである。

.\"O It is possible to implement RFC 4821 MTU probing with
.\"O .B SOCK_DGRAM
.\"O or
.\"O .B SOCK_RAW
.\"O sockets by setting a value of
.\"O .BR IP_PMTUDISC_PROBE
.\"O (available since Linux 2.6.22).
.\"O This is also particularly useful for diagnostic tools such as
.\"O .BR tracepath (8)
.\"O that wish to deliberately send probe packets larger than
.\"O the observed Path MTU.
.B IP_PMTUDISC_PROBE
(Linux 2.6.22 以降で利用可能) を設定することで、
.B SOCK_DGRAM
や
.B SOCK_RAW
のソケットで RFC 4821 の MTU 探索を実装することが可能である。
また、この機能は、
.BR tracepath (8)
のような診断ツールで特に有用である。これらのツールでは、
観測された Path MTU よりも大きな探索パケットを意図的に
送信しようとする。
.TP
.\"O .BR IP_MULTICAST_IF " (since Linux 1.2)"
.BR IP_MULTICAST_IF " (Linux 1.2 以降)"
.\"O Set the local device for a multicast socket.
.\"O Argument is an
.\"O .I ip_mreqn
.\"O or
.\"O .I ip_mreq
.\"O structure similar to
.\"O .BR IP_ADD_MEMBERSHIP .
ローカルデバイスをマルチキャストソケットとして設定する。引き数は
.B IP_ADD_MEMBERSHIP
と同様に
.I ip_mreqn
または
.I ip_mreq
構造体である。
.IP
.\"O When an invalid socket option is passed,
.\"O .B ENOPROTOOPT
.\"O is returned.
不正なソケットオプションが渡されると、
.B ENOPROTOOPT
が返される。
.TP
.\"O .BR IP_MULTICAST_LOOP " (since Linux 1.2)"
.BR IP_MULTICAST_LOOP " (Linux 1.2 以降)"
.\"O Set or read a boolean integer argument that determines whether
.\"O sent multicast packets should be looped back to the local sockets.
マルチキャストパケットをローカルなソケットにループバックするかどうかを
定めるブール値の整数引き数を設定・取得する。
.TP
.\"O .BR IP_MULTICAST_TTL " (since Linux 1.2)"
.BR IP_MULTICAST_TTL " (Linux 1.2 以降)"
.\"O Set or read the time-to-live value of outgoing multicast packets for this
.\"O socket.
.\"O It is very important for multicast packets to set the smallest TTL possible.
.\"O The default is 1 which means that multicast packets don't leave the local
.\"O network unless the user program explicitly requests it.
.\"O Argument is an integer.
このソケットから発信されるマルチキャストパケットの
time-to-live 値を設定・取得する。
マルチキャストパケットに対しては、できるだけ小さな
TTL に設定することがとても重要である。デフォルトは 1 で、
ユーザープログラムが明示的に要求しない限り
マルチキャストパケットはローカルなネットワークから出ないことになる。
引き数に整数を取る。
.TP
.\"O .BR IP_OPTIONS " (since Linux 2.0)"
.BR IP_OPTIONS " (Linux 2.0 以降)"
.\" Precisely: 1.3.30
.\"O Set or get the IP options to be sent with every packet from this socket.
.\"O The arguments are a pointer to a memory buffer containing the options
.\"O and the option length.
このソケットから送られるパケット全てに付随する IP オプションを
設定・取得する。オプションを保存しているメモリバッファへのポインタと
オプションの長さとを引き数に取る。
.\"O The
.\"O .BR setsockopt (2)
.\"O call sets the IP options associated with a socket.
.\"O The maximum option size for IPv4 is 40 bytes.
.\"O See RFC\ 791 for the allowed options.
.\"O When the initial connection request packet for a
.\"O .B SOCK_STREAM
.\"O socket contains IP options, the IP options will be set automatically
.\"O to the options from the initial packet with routing headers reversed.
.\"O Incoming packets are not allowed to change options after the connection
.\"O is established.
.BR setsockopt (2)
を呼び出すと、ソケットに関連づけられる IP オプションを設定できる。
IPv4 におけるオプションのサイズの最大値は 40 バイトである。
用いることのできるオプションについては RFC\ 791 を見よ。
.B SOCK_STREAM
ソケットに対する初期接続要求パケットに IP オプションが含まれていると、
ルーティングヘッダを付けて戻されてくる初期パケットの
IP オプションに同じオプションがセットされる。接続が確立された後、
やってきたパケットのオプションを変更することはできない。
.\"O The processing of all incoming source routing options
.\"O is disabled by default and can be enabled by using the
.\"O .I accept_source_route
.\"O .I /proc
.\"O interface.
.\"O Other options like timestamps are still handled.
.\"O For datagram sockets, IP options can be only set by the local user.
.\"O Calling
.\"O .BR getsockopt (2)
.\"O with
.\"O .B IP_OPTIONS
.\"O puts the current IP options used for sending into the supplied buffer.
デフォルトでは。外部から受信したパケットの全ての source routing オプション
の処理は無効となっており、
.I /proc
インタフェースの
.I accept_source_route
を使うとこれを有効にできる。これを無効にしていても timestamps など
の他のオプションの処理は行われる。データグラムソケットでは、
IP オプションはローカルユーザーしか設定できない。
.BR getsockopt (2)
を
.B IP_OPTIONS
をつけて呼ぶと、現在送信に用いられている IP オプションを
引き数に与えたバッファに取得できる。
.\" FIXME Document IP_PASSSEC
.\" Boolean
.\" Since Linux 2.6.17
.\" commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
.\" Author: Catherine Zhang <cxzhang@watson.ibm.com>
.TP
.\"O .BR IP_PKTINFO " (since Linux 2.2)"
.BR IP_PKTINFO " (Linux 2.2 以降)"
.\" Precisely: 2.1.68
.\"O Pass an
.\"O .B IP_PKTINFO
.\"O ancillary message that contains a
.\"O .I pktinfo
.\"O structure that supplies some information about the incoming packet.
.\"O This only works for datagram oriented sockets.
.B IP_PKTINFO
補助メッセージを渡す。これには到着パケットに関する情報を提供する
.I pktinfo
構造体が含まれている。
データグラム指向のソケットでしか動作しない。
.\"O The argument is a flag that tells the socket whether the
.\"O .B IP_PKTINFO
.\"O message should be passed or not.
.\"O The message itself can only be sent/retrieved
.\"O as control message with a packet using
.\"O .BR recvmsg (2)
.\"O or
.\"O .BR sendmsg (2).
引き数は
.B IP_PKTINFO
メッセージを通過させるかどうかをソケットに知らせるフラグである。
メッセージ自身は
.BR recvmsg (2)
または
.BR sendmsg (2)
を用いたパケットの制御メッセージとしてのみ送受信できる。

.IP
.in +4n
.nf
struct in_pktinfo {
    unsigned int   ipi_ifindex;  /* Interface index */
    struct in_addr ipi_spec_dst; /* Local address */
    struct in_addr ipi_addr;     /* Header Destination
                                    address */
};
.fi
.in
.IP
.\" FIXME elaborate on that.
.\"O .I ipi_ifindex
.\"O is the unique index of the interface the packet was received on.
.I ipi_ifindex
はパケットが受信されたインターフェースの、他と重ならないインデックスである。
.\"O .I ipi_spec_dst
.\"O is the local address of the packet and
.\"O .I ipi_addr
.\"O is the destination address in the packet header.
.I ipi_spec_dst
はパケットのローカルアドレスである。
.I ipi_addr
はパケットヘッダにある宛先アドレスである。
.\"O If
.\"O .B IP_PKTINFO
.\"O is passed to
.\"O .BR sendmsg (2)
.\"O and
.\"O .\" This field is grossly misnamed
.\"O .I ipi_spec_dst
.\"O is not zero, then it is used as the local source address for the routing
.\"O table lookup and for setting up IP source route options.
.B IP_PKTINFO
が
.BR sendmsg (2)
に渡されて、かつ
.\" このフィールドは、名前の付け方が明らかに間違っているのだが
.I ipi_spec_dst
が 0 以外の場合、
.I ipi_spec_dst
はルーティングテーブルを検索する際にローカルな送信元アドレスとして使用され、
IP source route オプションを設定するのにも使用される。
.\"O When
.\"O .I ipi_ifindex
.\"O is not zero, the primary local address of the interface specified by the
.\"O index overwrites
.\"O .I ipi_spec_dst
.\"O for the routing table lookup.
.I ipi_ifindex
が 0 以外の場合、このインデックスによって指定されるインターフェースの
プライマリローカルアドレスで
.I ipi_spec_dst
を上書きし、ルーティングテーブルを検索する。
.TP
.\"O .BR IP_RECVERR " (since Linux 2.2)"
.BR IP_RECVERR " (Linux 2.2 以降)"
.\" Precisely: 2.1.15
.\"O Enable extended reliable error message passing.
.\"O When enabled on a datagram socket, all
.\"O generated errors will be queued in a per-socket error queue.
.\"O When the user receives an error from a socket operation,
.\"O the errors can be received by calling
.\"O .BR recvmsg (2)
.\"O with the
.\"O .B MSG_ERRQUEUE
.\"O flag set.
.\"O The
.\"O .I sock_extended_err
.\"O structure describing the error will be passed in an ancillary message with
.\"O the type
.\"O .B IP_RECVERR
.\"O and the level
.\"O .BR IPPROTO_IP .
.\"O .\" or SOL_IP on Linux
.\"O This is useful for reliable error handling on unconnected sockets.
.\"O The received data portion of the error queue contains the error packet.
エラーメッセージの受け渡しに、信頼性の高い拡張された方法を有効にする。
データグラムソケットに対して有効になっていると、
発生したエラーは全てソケットごとのエラーキューに保存される。
ユーザーはソケット操作からエラーを受け取ったとき、
.BR recvmsg (2)
を
.B MSG_ERRQUEUE
フラグとともに呼べばそのエラーを取得できる。
そのエラーを記述する
.I sock_extended_err
構造体が、タイプ
.BR IP_RECVERR ・
レベル
.B IPPROTO_IP
.\" Linux では SOL_IP も可
の補助メッセージとして渡される。
これは接続志向でないソケットで信頼性の高いエラー処理を行いたい場合に
有用である。エラーキューの受信データフラグメントには
エラーパケットが含まれる。
.\"NAKANO portion をフラグメントって言っちゃっていいのか？
.IP
.\"O The
.\"O .B IP_RECVERR
.\"O control message contains a
.\"O .I sock_extended_err
.\"O structure:
.B IP_RECVERR
制御メッセージには
.I sock_extended_err
構造体が含まれる:
.IP
.in +4n
.ne 18
.nf
#define SO_EE_ORIGIN_NONE    0
#define SO_EE_ORIGIN_LOCAL   1
#define SO_EE_ORIGIN_ICMP    2
#define SO_EE_ORIGIN_ICMP6   3

struct sock_extended_err {
    uint32_t ee_errno;   /* error number */
    uint8_t  ee_origin;  /* where the error originated */
    uint8_t  ee_type;    /* type */
    uint8_t  ee_code;    /* code */
    uint8_t  ee_pad;
    uint32_t ee_info;    /* additional information */
    uint32_t ee_data;    /* other data */
    /* More data may follow */
};

struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);
.fi
.in
.IP
.\"O .I ee_errno
.\"O contains the
.\"O .I errno
.\"O number of the queued error.
.\"O .I ee_origin
.\"O is the origin code of where the error originated.
.I ee_errno
にはキューに入っているエラーの
.I errno
番号が入る。
.I ee_origin
にはエラーが発生した場所を示すコードが入る。
.\"O The other fields are protocol-specific.
.\"O The macro
.\"O .B SO_EE_OFFENDER
.\"O returns a pointer to the address of the network object
.\"O where the error originated from given a pointer to the ancillary message.
その他のフィールドはプロトコル依存である。
.B SO_EE_OFFENDER
マクロは与えられた補助メッセージへのポインタから
エラーの発生したネットワークオブジェクトのアドレスへのポインタを返す。
.\"O If this address is not known, the
.\"O .I sa_family
.\"O member of the
.\"O .I sockaddr
.\"O contains
.\"O .B AF_UNSPEC
.\"O and the other fields of the
.\"O .I sockaddr
.\"O are undefined.
アドレスが不明な場合、
.I sockaddr
構造体の
.I sa_family
フィールドは
.B AF_UNSPEC
となり、その他のフィールド値は不定である。
.IP
.\"O IP uses the
.\"O .I sock_extended_err
.\"O structure as follows:
IP は以下のような
.I sock_extended_err
構造体を用いる:
.\"O .I ee_origin
.\"O is set to
.\"O .B SO_EE_ORIGIN_ICMP
.\"O for errors received as an ICMP packet, or
.\"O .B SO_EE_ORIGIN_LOCAL
.\"O for locally generated errors.
.\"O Unknown values should be ignored.
.I ee_origin
は、
エラーが ICMP パケットとして受信された場合には
.B SO_EE_ORIGIN_ICMP
にセットされ、ローカルで起こった場合には
.B SO_EE_ORIGIN_LOCAL
にセットされる。
不明な値は無視される。
.\"O .I ee_type
.\"O and
.\"O .I ee_code
.\"O are set from the type and code fields of the ICMP header.
.I ee_type
と
.I ee_code
は ICMP ヘッダの type フィールドと code フィールドの値にセットされる。
.\"O .I ee_info
.\"O contains the discovered MTU for
.\"O .B EMSGSIZE
.\"O errors.
.\"O The message also contains the
.\"O .I sockaddr_in of the node
.\"O caused the error, which can be accessed with the
.\"O .B SO_EE_OFFENDER
.\"O macro.
.\"O The
.\"O .I sin_family
.\"O field of the SO_EE_OFFENDER address is
.\"O .B AF_UNSPEC
.\"O when the source was unknown.
.I ee_info
には
.B EMSGSIZE
エラーに対する discover された MTU が入る。
メッセージにはエラーを引き起こしたノードの
.I sockaddr_in
構造体も含まれる。
これには
.B SO_EE_OFFENDER
マクロを使ってアクセスできる。
ソースが不明の場合、
SO_EE_OFFENDER アドレスの
.I sin_family
フィールドは
.B AF_UNSPEC
となる。
.\"O When the error originated from the network, all IP options
.\"O .RI ( IP_OPTIONS ", " IP_TTL ", "
.\"O etc.) enabled on the socket and contained in the
.\"O error packet are passed as control messages.
.\"O The payload of the packet causing the error is returned as normal payload.
エラーがネットワークで起きた場合には、
ソケットで有効になっていたすべての IP オプション
.RB ( IP_OPTIONS ", " IP_TTL
など) とエラーパケットに含まれていたすべての IP オプションとが、
制御メッセージとして渡される。
エラーを起こしたパケットのペイロード (payload) は
普通のペイロードとして返される。
.\" FIXME . is it a good idea to document that? It is a dubious feature.
.\"O .\" On
.\"O .\" .B SOCK_STREAM
.\"O .\" sockets,
.\"O .\" .B IP_RECVERR
.\"O .\" has slightly different semantics. Instead of
.\"O .\" saving the errors for the next timeout, it passes all incoming
.\"O .\" errors immediately to the user.
.\"O .\" This might be useful for very short-lived TCP connections which
.\"O .\" need fast error handling. Use this option with care:
.\"O .\" it makes TCP unreliable
.\"O .\" by not allowing it to recover properly from routing
.\"O .\" shifts and other normal
.\"O .\" conditions and breaks the protocol specification.
.\" .B SOCK_STREAM
.\" ソケットでは、
.\" .B IP_RECVERR
.\" はやや異なる意味を持つ。次のタイムアウトまでデータを保持するのでなく、
.\" やってきたエラーは全てただちにユーザーに渡される。これは、
.\" 高速なエラー処理が必要となるような、極端に寿命の短い
.\" TCP 接続に対して有用である。このオプションは注意して用いること。
.\" 経路が変わったり、その他通常の状況に対して、適切な回復が不可能となり、
.\" TCP の信頼性を低くしてしまう。またプロトコルの仕様に反してしまう。
.\"O Note that TCP has no error queue;
.\"O .B MSG_ERRQUEUE
.\"O is not permitted on
.\"O .B SOCK_STREAM
.\"O sockets.
.\"O .B IP_RECVERR
.\"O is valid for TCP, but all errors are returned by socket function return or
.\"O .B SO_ERROR
.\"O only.
TCP にはエラーキューがないことに注意してほしい。
.B MSG_ERRQUEUE
は
.B SOCK_STREAM
ソケットに対しては使えない。
TCP では
.B IP_RECVERR
だけが有効だが、ソケット関数から返されるエラーは
.B SO_ERROR
だけになる。
.IP
.\"O For raw sockets,
.\"O .B IP_RECVERR
.\"O enables passing of all received ICMP errors to the
.\"O application, otherwise errors are only reported on connected sockets
raw ソケットに対して
.B IP_RECVERR
を指定すると、受信したすべての ICMP エラーをアプリケーションに
渡すようになる。指定しないと、
接続済みのソケットに対するエラーだけを報告する。
.IP
.\"O It sets or retrieves an integer boolean flag.
.\"O .B IP_RECVERR
.\"O defaults to off.
このオプションはブール値のフラグを設定・取得する。
.B IP_RECVERR
はデフォルトではオフになっている。
.TP
.\"O .BR IP_RECVOPTS " (since Linux 2.2)"
.BR IP_RECVOPTS " (Linux 2.2 以降)"
.\" Precisely: 2.1.15
.\"O Pass all incoming IP options to the user in a
.\"O .B IP_OPTIONS
.\"O control message.
.\"O The routing header and other options are already filled in
.\"O for the local host.
.\"O Not supported for
.\"O .B SOCK_STREAM
.\"O sockets.
到着した全ての IP オプションを
.B IP_OPTION
コントロールメッセージに入れてユーザーに渡す。
ルーティングヘッダとその他のオプションとは、
ローカルホストに対してはあらかじめ記入されている。
.B SOCK_STREAM
ソケットではサポートされていない。
.TP
.\"O .BR IP_RECVTOS " (since Linux 2.2)"
.BR IP_RECVTOS " (Linux 2.2 以降)"
.\" Precisely: 2.1.68
.\"O If enabled the
.\"O .B IP_TOS
.\"O ancillary message is passed with incoming packets.
.\"O It contains a byte which specifies the Type of Service/Precedence
.\"O field of the packet header.
.\"O Expects a boolean integer flag.
有効になっていると、
.B IP_TOS
補助メッセージが到着パケットとともに渡される。
これにはパケットヘッダの Service/Precedence
フィールドのタイプを指定するバイトデータが含まれている。
ブール整数値のフラグをとる。
.TP
.\"O .BR IP_RECVTTL " (since Linux 2.2)"
.BR IP_RECVTTL " (Linux 2.2 以降)"
.\" Precisely: 2.1.68
.\"O When this flag is set, pass a
.\"O .B IP_TTL
.\"O control message with the time to live
.\"O field of the received packet as a byte.
.\"O Not supported for
.\"O .B SOCK_STREAM
.\"O sockets.
このフラグがセットされていると、
.B IP_TTL
コントロールメッセージが受信パケットの
time-to-live フィールドのバイトデータとともに渡される。
.B SOCK_STREAM
ソケットではサポートされていない。
.TP
.B IP_RETOPTS
.\"O .BR IP_RETOPTS " (since Linux 2.2)"
.BR IP_RETOPTS " (Linux 2.2 以降)"
.\" Precisely: 2.1.15
.\"O Identical to
.\"O .BR IP_RECVOPTS ,
.\"O but returns raw unprocessed options with timestamp and route record
.\"O options not filled in for this hop.
.B IP_RECVOPTS
と等価だが、未処理の生のオプションを、
この hop では記入されない timestamp レコードと route レコードとともに返す。
.\"NAKANO 意味不明...(^^;
.TP
.\"O .BR IP_ROUTER_ALERT " (since Linux 2.2)"
.BR IP_ROUTER_ALERT " (Linux 2.2 以降)"
.\" Precisely: 2.1.68
.\"O Pass all to-be forwarded packets with the
.\"O IP Router Alert option set to this socket.
.\"O Only valid for raw sockets.
.\"O This is useful, for instance, for user-space RSVP daemons.
.\"O The tapped packets are not forwarded by the kernel; it is
.\"O the user's responsibility to send them out again.
.\"O Socket binding is ignored,
.\"O such packets are only filtered by protocol.
.\"O Expects an integer flag.
フォワードすべきパケットを IP Router Alert オプションをつけて
このソケットに渡す。
raw ソケットに対してのみ有効である。これはたとえばユーザー空間の
RSVP デーモンに対して便利である。タップされたパケットは
カーネルによってはフォワードされないので、これらを再送するのは
ユーザーの責任となる。ソケットのバインドは無視され、
このようなパケットはプロトコルによってのみフィルタリングされる。
整数値のフラグを取る。
.\"NAKANO Socket binding... の文、意味わからん。
.TP
.\"O .BR IP_TOS " (since Linux 1.0)"
.BR IP_TOS " (Linux 1.0 以降)"
.\"O Set or receive the Type-Of-Service (TOS) field that is sent
.\"O with every IP packet originating from this socket.
.\"O It is used to prioritize packets on the network.
.\"O TOS is a byte.
.\"O There are some standard TOS flags defined:
.\"O .B IPTOS_LOWDELAY
.\"O to minimize delays for interactive traffic,
.\"O .B IPTOS_THROUGHPUT
.\"O to optimize throughput,
.\"O .B IPTOS_RELIABILITY
.\"O to optimize for reliability,
.\"O .B IPTOS_MINCOST
.\"O should be used for "filler data" where slow transmission doesn't matter.
このソケットから送信されるすべての IP パケットに適用される
Type-Of-Service (TOS) フィールドを設定・取得する。
これはネットワーク上でのパケットの優先度を決めるために用いられる。
TOS はバイトデータである。標準の TOS フラグがいくつか定義されている。
.B IPTOS_LOWDELAY
はインタラクティブなトラフィックの遅延を最小にする。
.B IPTOS_THROUGHPUT
はスループットを最大にする。
.B IPTOS_RELIABILITY
は信頼性を最高にする。
.B IPTOS_MINCOST
は転送速度が遅くてもかまわないとき、「データを詰め込む」のに用いられる。
.\"O At most one of these TOS values can be specified.
.\"O Other bits are invalid and shall be cleared.
これらのうち、 1 つまでだけを設定できる。
他のビットは無効で、クリアされる。
.\"NAKANO ↑訳あってる？
.\"O Linux sends
.\"O .B IPTOS_LOWDELAY
.\"O datagrams first by default,
.\"O but the exact behavior depends on the configured queueing discipline.
Linux はデフォルトでは
.B IPTOS_LOWDELAY
データグラムを最初に送信する。
しかし、正確な振る舞いはキュー処理の設定に依存する。
.\" FIXME elaborate on this
.\"O Some high priority levels may require superuser privileges (the
.\"O .B CAP_NET_ADMIN
.\"O capability).
.\"O The priority can also be set in a protocol independent way by the
.\"O .RB ( SOL_SOCKET ", " SO_PRIORITY )
.\"O socket option (see
.\"O .BR socket (7)).
高い優先度にするにはスーパーユーザー権限
.RB ( CAP_NET_ADMIN
ケーパビリティ) が必要となるかもしれない。
優先度は
.RB ( SOL_SOCKET ", " SO_PRIORITY )
ソケットオプションを用いれば、
プロトコルに依存しない形でも設定できる
.RB ( socket (7)
を見よ)。
.\" FIXME Document IP_TRANSPARENT
.\" Needs CAP_NET_ADMIN
.\" Boolean
.\" Since Linux 2.6.27
.\" commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
.\" Author: KOVACS Krisztian <hidden@sch.bme.hu>
.TP
.\"O .BR IP_TTL " (since Linux 1.0)"
.BR IP_TTL " (Linux 1.0 以降)"
.\"O Set or retrieve the current time-to-live field that is used in every packet
.\"O sent from this socket.
time-to-live フィールドの値を設定または取得する。
この値はこのソケットから送信されるすべてのパケットに用いられる。
.\" FIXME Document IP_XFRM_POLICY
.\" Since Linux 2.5.48
.\" Needs CAP_NET_ADMIN
.\"O .SS /proc interfaces
.SS /proc インタフェース
.\"O The IP protocol
.\"O supports a set of
.\"O .I /proc
.\"O interfaces to configure some global parameters.
.\"O The parameters can be accessed by reading or writing files in the directory
.\"O .IR /proc/sys/net/ipv4/ .
IP プロトコルでは、いくつかのグローバルパラメータを設定するための
.I /proc
ファイル群が用意されている。
これらのパラメータには、
.I /proc/sys/net/ipv4/
ディレクトリ内のファイルの読み書きでアクセスできる。
.\" FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
.\"	ip_queue_maxlen
.\"	ip_conntrack_max
.\"O Interfaces described as
.\"O .I Boolean
.\"O take an integer value, with a nonzero value ("true") meaning that
.\"O the corresponding option is enabled, and a zero value ("false")
.\"O meaning that the option is disabled.
.I Boolean
と書かれたインタフェースは整数値をとり、
0 以外の値 ("true") は対応するオプションが有効、
0 値 ("false") は無効、であることを意味する。
.\"
.TP
.\"O .IR ip_always_defrag " (Boolean; since Linux 2.2.13)"
.IR ip_always_defrag " (Boolean; Linux 2.2.13 以降)"
.\"O [New with kernel 2.2.13; in earlier kernel versions this feature
.\"O was controlled at compile time by the
.\"O .B CONFIG_IP_ALWAYS_DEFRAG
.\"O option; this option is not present in 2.4.x and later]
[2.2.13 で新規登場。以前のバージョンのカーネルでは、この機能は
コンパイル時に
.B CONFIG_IP_ALWAYS_DEFRAG
オプションによって制御されていた;
このファイルは 2.4.x 以降では存在しない]

.\"O When this boolean flag is enabled (not equal 0), incoming fragments
.\"O (parts of IP packets
.\"O that arose when some host between origin and destination decided
.\"O that the packets were too large and cut them into pieces) will be
.\"O reassembled (defragmented) before being processed, even if they are
.\"O about to be forwarded.
このブール値のフラグが有効になっている (0 以外になっている) と、
到着したフラグメント (IP パケットの一部で、
発信元と発信先の間のどこかのホストで、そのパケットが
大きすぎると判断され、分割された場合に生じる)
は、たとえフォワードされる場合であっても
処理前に再構築 (デフラグメント) される。

.\"O Only enable if running either a firewall that is the sole link
.\"O to your network or a transparent proxy; never ever use it for a
.\"O normal router or host.
.\"O Otherwise fragmented communication can be disturbed
.\"O if the fragments travel over different links.
.\"O Defragmentation also has a large memory and CPU time cost.
ファイアウォールがローカル側のネットワークに唯一のリンクを持っている
場合や、透過プロクシの場合に限って有効にすべきである。
通常のルーターやホストでは決して使用することのないように。
さもないとフラグメントが別のリンクを経由して伝わる場合に、
通信のフラグメント化ができなくなってしまう。
またフラグメント再構築処理はメモリと CPU 時間のコストが非常に大きい。

.\"O This is automagically turned on when masquerading or transparent
.\"O proxying are configured.
これはマスカレードや透過プロクシが設定されると、
不思議な仕組みによって自動的に有効になる。
.\"
.TP
.\"O .IR ip_autoconfig " (since Linux 2.2 to 2.6.17)"
.IR ip_autoconfig " (Linux 2.2 以降 2.6.17 まで)"
.\" Precisely: since 2.1.68
.\" FIXME document ip_autoconfig
.\"O Not documented.
まだ記述していない。
.\"
.TP
.\"O .IR ip_default_ttl " (integer; default: 64; since Linux 2.2)"
.IR ip_default_ttl " (integer; default: 64; Linux 2.2 以降)"
.\" Precisely: 2.1.15
.\"O Set the default time-to-live value of outgoing packets.
.\"O This can be changed per socket with the
.\"O .B IP_TTL
.\"O option.
送出されるパケットの time-to-live 値のデフォルトをセットする。
これは
.B IP_TTL
オプションを用いれば、パケットごとに変えることもできる。
.\"
.TP
.\"O .IR ip_dynaddr " (Boolean; default: disabled; since Linux 2.0.31)"
.IR ip_dynaddr " (Boolean; default: disabled; Linux 2.0.31 以降)"
.\"O Enable dynamic socket address and masquerading entry rewriting on interface
.\"O address change.
.\"O This is useful for dialup interface with changing IP addresses.
.\"O 0 means no rewriting, 1 turns it on and 2 enables verbose mode.
動的ソケットアドレスと、インターフェースアドレスが変更された際の
マスカレードエントリの再書き込みを有効にする。
ダイアルアップインターフェースで、
IP アドレスが変更される場合に便利である。
.\"
.TP
.\"O .IR ip_forward " (Boolean; default: disabled; since Linux 1.2)"
.IR ip_forward " (Boolean; default: disabled; Linux 1.2 以降)"
.\"O Enable IP forwarding with a boolean flag.
.\"O IP forwarding can be also set on a per-interface basis.
IP forwarding を有効にするかどうかのブール値フラグ。
IP forwarding するかどうかはインターフェースごとにも設定できる。
.\"
.TP
.\"O .IR ip_local_port_range " (since Linux 2.2)"
.IR ip_local_port_range " (Linux 2.2 以降)"
.\" Precisely: since 2.1.68
.\"O Contains two integers that define the default local port range
.\"O allocated to sockets.
.\"O Allocation starts with the first number and ends with the second number.
.\"O Note that these should not conflict with the ports used by masquerading
.\"O (although the case is handled).
.\"O Also arbitrary choices may cause problems with some firewall packet
.\"O filters that make assumptions about the local ports in use.
.\"O First number should be at least greater than 1024,
.\"O or better greater than 4096, to avoid clashes
.\"O with well known ports and to minimize firewall problems.
ソケットに割り当てられているデフォルトのローカルポートの範囲を定める
二つの整数を与える。割り当ては 1 番目の番号から始まり、 2 番目の番号で終わる。
これらはマスカレードで用いられているポートと重なってはならない
(その場合も取り扱われるが)。
ファイアウォールのパケットフィルターが「利用中のローカルポート」
について何らかの仮定をしている場合には、
番号を勝手に決めてしまうと問題が起きるかもしれない。
1 番目の番号は少なくとも 1024 より大きくすべきである。
良く使われるポートとの衝突を避けたり、ファイアウォールの問題を
回避したければ、 4096 よりも大きくするほうが良いだろう。
.\"
.TP
.\"O .IR ip_no_pmtu_disc " (Boolean; default: disabled; since Linux 2.2)"
.IR ip_no_pmtu_disc " (Boolean; default: disabled; Linux 2.2 以降)"
.\" Precisely: 2.1.15
.\"O If enabled, don't do Path MTU Discovery for TCP sockets by default.
.\"O Path MTU discovery may fail if misconfigured firewalls (that drop
.\"O all ICMP packets) or misconfigured interfaces (e.g., a point-to-point
.\"O link where the both ends don't agree on the MTU) are on the path.
.\"O It is better to fix the broken routers on the path than to turn off
.\"O Path MTU Discovery globally, because not doing it incurs a high cost
.\"O to the network.
有効になっていると、デフォルトで TCP ソケットに対する
Path MTU Discoverty を行わない。
Path MTU Discovery は、
正しく設定されていない (ICMP パケットを全てドロップする) ファイアウォールや、
(point-to-point リンクで双方の MTU が一致していない場合など)
正しく設定されていないインターフェースが経路上に存在すると失敗してしまう。
Path MTU Discovery をグローバルに無効にするよりは、
壊れているルータを直すほうが良い。
Path MTU Discovery を無効にするとネットワークのコストが
大きくなってしまうからである。
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
.TP
.\"O .IR ip_nonlocal_bind " (Boolean; default: disabled; since Linux 2.4)"
.IR ip_nonlocal_bind " (Boolean; default: disabled; Linux 2.4 以降)"
.\" Precisely: patch-2.4.0-test10
.\"O If set, allows processes to
.\"O .BR bind (2)
.\"O to nonlocal IP addresses,
.\"O which can be quite useful, but may break some applications.
セットされていれば、プロセスが自分以外の IP アドレスを
.BR bind (2)
できるようになる。これはかなり便利だが、うまく動かないアプリケーションもある。
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
.TP
.IR ip6frag_time " (integer; default 30)"
.\"O Time in seconds to keep an IPv6 fragment in memory.
IPv6 フラグメントをメモリに保持しておく時間 (秒単位)。
.\"
.\" The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
.TP
.IR ip6frag_secret_interval " (integer; default 600)"
.\"O Regeneration interval (in seconds) of the hash secret (or lifetime
.\"O for the hash secret) for IPv6 fragments.
IPv6 フラグメントの hash secret の生成間隔 (hash secret の寿命)
(秒単位)。
.TP
.IR ipfrag_high_thresh " (integer), " ipfrag_low_thresh " (integer)"
.\"O If the amount of queued IP fragments reaches
.\"O .IR ipfrag_high_thresh ,
.\"O the queue is pruned down to
.\"O .IR ipfrag_low_thresh .
.\"O Contains an integer with the number of bytes.
キューイングされている IP フラグメントの量が
.I ipfrag_high_thresh
に達すると、キューの内容は
.I ipfrag_low_thresh
にまで切り捨てられる。それぞれの大きさを
バイト単位で表す整数値が入っている。
.TP
.I neigh/*
.\"O See
.\"O .BR arp (7).
.BR arp (7)
を見よ。
.\" FIXME Document the conf/*/* interfaces
.\" FIXME Document the route/* interfaces
.\" FIXME document them all
.\"O .SS Ioctls
.SS ioctl
.\"O All ioctls described in
.\"O .BR socket (7)
.\"O apply to
.\"O .BR ip .
.BR socket (7)
に記述されている ioctl は、すべて
.B ip
にも適用される。
.\" 2006-04-02, mtk
.\" commented out the following because ipchains is obsolete
.\" .PP
.\"O .\" The ioctls to configure firewalling are documented in
.\"O .\" .BR ipfw (4)
.\"O .\" from the
.\"O .\" .B ipchains
.\"O .\" package.
.\" ファイアウォール関係の設定に関する ioctl については
.\" .B ipchains
.\" パッケージの
.\" .BR ipfw (4)
.\" に記述されている。
.PP
.\"O Ioctls to configure generic device parameters are described in
.\"O .BR netdevice (7).
ジェネリックデバイスのパラメータを設定する ioctl については
.BR netdevice (7)
に記述されている。
.\" FIXME Add a discussion of multicasting
.\"O .SH ERRORS
.SH エラー
.\" FIXME document all errors.
.\"     We should really fix the kernels to give more uniform
.\"     error returns (ENOMEM vs ENOBUFS, EPERM vs EACCES etc.)
.TP
.B EACCES
.\"O The user tried to execute an operation without the necessary permissions.
.\"O These include:
.\"O sending a packet to a broadcast address without having the
.\"O .B SO_BROADCAST
.\"O flag set;
.\"O sending a packet via a
.\"O .I prohibit
.\"O route;
.\"O modifying firewall settings without superuser privileges (the
.\"O .B CAP_NET_ADMIN
.\"O capability);
.\"O binding to a privileged port without superuser privileges (the
.\"O .B CAP_NET_BIND_SERVICE
.\"O capability).
必要な権限のないユーザーが操作を実行しようとした。
以下のような場合が考えられる:
.B SO_BROADCAST
フラグを設定していない状態でブロードキャストアドレスに
パケットを送ろうとした。
.I prohibit
なルートを通してパケットを送ろうとした。
スーパーユーザー権限
.RB ( CAP_NET_ADMIN
ケーパビリティ) なしでファイアウォールの設定を変更しようとした。
スーパーユーザー権限
.RB ( CAP_NET_BIND_SERVICE
ケーパビリティ) なしで特権ポートにバインドしようとした。
.TP
.B EADDRINUSE
.\"O Tried to bind to an address already in use.
既に使われているアドレスにバインドしようとした。
.TP
.B EADDRNOTAVAIL
.\"O A nonexistent interface was requested or the requested source
.\"O address was not local.
存在しないソケットが要求された。または要求された
ソースアドレスがローカルでない。
.TP
.B EAGAIN
.\"O Operation on a nonblocking socket would block.
非ブロッキングソケットに対してブロックする操作を行った。
.TP
.B EALREADY
.\"O An connection operation on a nonblocking socket is already in progress.
非ブロッキングソケットに対する接続操作が既に実行中である。
.TP
.B ECONNABORTED
.\"O A connection was closed during an
.\"O .BR accept (2).
.BR accept (2)
の最中に接続がクローズされた。
.TP
.B EHOSTUNREACH
.\"O No valid routing table entry matches the destination address.
.\"O This error can be caused by a ICMP message from a remote router or
.\"O for the local routing table.
宛先アドレスにマッチする有効なエントリがルーティングテーブルに
存在しない。このエラーはリモートルータからの、
あるいはローカルルーティングテーブルへの
ICMP メッセージによって引き起こされることがある。
.TP
.B EINVAL
.\"O Invalid argument passed.
.\"O For send operations this can be caused by sending to a
.\"O .I blackhole
.\"O route.
不正な引き数が渡された。送信操作において、
.I blackhole
ルートに送信しようとするとこのエラーが起こることがある。
.TP
.B EISCONN
.\"O .BR connect (2)
.\"O was called on an already connected socket.
.BR connect (2)
が、既に接続済みのソケットに対して呼ばれた。
.TP
.B EMSGSIZE
.\"O Datagram is bigger than an MTU on the path and it cannot be fragmented.
データグラムが path MTU よりも大きく、フラグメント化もできない。
.TP
.BR ENOBUFS ", " ENOMEM
.\"O Not enough free memory.
.\"O This often means that the memory allocation is limited by the socket
.\"O buffer limits, not by the system memory, but this is not 100% consistent.
空きメモリが足りない。
このエラーは、メモリアロケーションがソケットバッファの
大きさによって制限されていることを意味しているのが通常であるが、
100% そうだというわけではない。
.TP
.B ENOENT
.\"O .B SIOCGSTAMP
.\"O was called on a socket where no packet arrived.
パケットが全く到着していないソケットに対して
.B SIOCGSTAMP
が呼ばれた。
.TP
.B ENOPKG
.\"O A kernel subsystem was not configured.
カーネルサブシステムが設定されていない。
.TP
.\"O .BR ENOPROTOOPT " and " EOPNOTSUPP
.BR ENOPROTOOPT " と " EOPNOTSUPP
.\"O Invalid socket option passed.
不正なソケットオプションが渡された。
.TP
.B ENOTCONN
.\"O The operation is only defined on a connected socket, but the socket wasn't
.\"O connected.
接続されていないソケットに対して、
接続状態でしか定義されていない操作を行おうとした。
.TP
.B EPERM
.\"O User doesn't have permission to set high priority, change configuration,
.\"O or send signals to the requested process or group.
高い優先度を設定したり、設定を変更したり、要求されたプロセスや
プロセスグループにシグナルを送ったりするのに必要な権限を、
ユーザーが持っていない。
.TP
.B EPIPE
.\"O The connection was unexpectedly closed or shut down by the other end.
接続が先方から期待していなかったやり方で
クローズあるいはシャットダウンされた。
.TP
.B ESOCKTNOSUPPORT
.\"O The socket is not configured or an unknown socket type was requested.
ソケットが未設定であるか、知らないソケットタイプが要求された。
.PP
.\"O Other errors may be generated by the overlaying protocols; see
他のエラーが上層のプロトコルによって生じるかもしれない。
.\"O .BR tcp (7),
.\"O .BR raw (7),
.\"O .BR udp (7)
.\"O and
.\"O .BR socket (7).
.BR tcp (7),
.BR raw (7),
.BR udp (7),
.BR socket (7)
などを参照のこと。
.\"O .SH NOTES
.SH 注意
.\"O .BR IP_MTU ,
.\"O .BR IP_MTU_DISCOVER ,
.\"O .BR IP_PKTINFO ,
.\"O .B IP_RECVERR
.\"O and
.\"O .B IP_ROUTER_ALERT
.BR IP_MTU ,
.BR IP_MTU_DISCOVER ,
.BR IP_PKTINFO ,
.BR IP_RECVERR ,
.B IP_ROUTER_ALERT
.\"O are Linux-specific and should not be used in
.\"O programs intended to be portable.
は Linux 固有であり、移植性を考慮したプログラムでは
用いるべきではない。
.\" IP_PASSSEC is Linux-specific
.\" IP_TRANSPARENT is Linux-specific
.\" IP_FREEBIND is Linux-specific
.\" IP_XFRM_POLICY is Linux-specific
.\" IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
.\"O Be very careful with the
.\"O .B SO_BROADCAST
.\"O option \- it is not privileged in Linux.
.\"O It is easy to overload the network
.\"O with careless broadcasts.
.\"O For new application protocols
.\"O it is better to use a multicast group instead of broadcasting.
.\"O Broadcasting is discouraged.
.B SO_BROADCAST
オプションの利用には、くれぐれも注意すること。
これは Linux では特権操作ではない。
不注意なブロードキャストを行うと、ネットワークは簡単に過負荷状態になる。
新しいアプリケーションプロトコルには、ブロードキャストではなく
マルチキャストグループを用いるほうがよい。
ブロードキャストは推奨されない。
.PP
.\"O Some other BSD sockets implementations provide
.\"O .B IP_RCVDSTADDR
.\"O and
.\"O .B IP_RECVIF
.\"O socket options to get the destination address and the interface of
.\"O received datagrams.
.\"O Linux has the more general
.\"O .B IP_PKTINFO
.\"O for the same task.
他の BSD のソケット実装では、
.B IP_RCVDSTADDR
と
.B IP_RECVIF
といったソケットオプションがサポートされており、
宛先アドレスや受信データグラムのインターフェースが取得できるように
なっていることもある。
Linux で同じことをやらせるには、より一般的な
.B IP_PKTINFO
が使える。
.PP
.\"O Some BSD sockets implementations also provide an
.\"O .B IP_RECVTTL
.\"O option, but an ancillary message with type
.\"O .B IP_RECVTTL
.\"O is passed with the incoming packet.
.\"O This is different from the
.\"O .B IP_TTL
.\"O option used in Linux.
いくつかの BSD のソケット実装では
.B IP_RECVTTL
オプションも提供されているが、タイプ
.B IP_RECVTTL
の補助メッセージは受信パケットとともに渡される。
これは Linux で使われている
.B IP_TTL
オプションとは異なる動作である。
.PP
.\"O Using
.\"O .B SOL_IP
.\"O socket options level isn't portable, BSD-based stacks use
.\"O .B IPPROTO_IP
.\"O level.
.B SOL_IP
ソケットオプションレベルは移植性がない。
BSD ベースのプロトコルスタックでは
.B IPPROTO_IP
レベルが使用されている。
.\"O .SS Compatibility
.SS 移植性
.\"O For compatibility with Linux 2.0, the obsolete
.\"O .BI "socket(AF_INET, SOCK_PACKET, " protocol )
.\"O syntax is still supported to open a
.\"O .BR packet (7)
.\"O socket.
.\"O This is deprecated and should be replaced by
.\"O .BI "socket(AF_PACKET, SOCK_RAW, " protocol )
.\"O instead.
.\"O The main difference is the
.\"O new
.\"O .I sockaddr_ll
.\"O address structure for generic link layer information instead of the old
.\"O .BR sockaddr_pkt .
Linux 2.0 との互換性のために、 obsolete な
.BI "socket(AF_INET, SOCK_PACKET, " protocol )
という書式でも
.BR packet (7)
をオープンできるようになっているが、これはお勧めできない。今後は
.BI "socket(AF_PACKET, SOCK_RAW, " protocol )
を代わりに用いるべきである。主な違いは、ジェネリックなリンク層用の
.I sockaddr_ll
アドレス構造体が、古い
.B sockaddr_pkt
に変わって用いられるようになったことである。
.\"O .SH BUGS
.SH バグ
.\"O There are too many inconsistent error values.
エラーの値が全く首尾一貫していない。
.PP
.\"O The ioctls to configure IP-specific interface options and ARP tables are
.\"O not described.
IP 固有のインターフェースオプションを指定するための ioctl と
ARP テーブルのことが記述されていない。
.PP
.\"O Some versions of glibc forget to declare
.\"O .IR in_pktinfo .
.\"O Workaround currently is to copy it into your program from this man page.
glibc のバージョンによっては
.I in_pktinfo
の定義を忘れているものがある。
現時点でのとりあえずの対策としては、この man ページにある定義をプログラム中に
コピーすることである。
.PP
.\"O Receiving the original destination address with
.\"O .B MSG_ERRQUEUE
.\"O in
.\"O .I msg_name
.\"O by
.\"O .BR recvmsg (2)
.\"O does not work in some 2.2 kernels.
.BR recvmsg (2)
で
.I msg_name
に
.B MSG_ERRQUEUE
を指定して、受信パケットに入っていた宛先アドレスを取得する方法は
2.2 カーネルの一部でうまく動かない。
.\"O .\" .SH AUTHORS
.\" .SH 著者
.\"O .\" This man page was written by Andi Kleen.
.\" この man ページは Andi Kleen が書いた。
.\"O .SH SEE ALSO
.SH 関連項目
.BR recvmsg (2),
.BR sendmsg (2),
.BR byteorder (3),
.BR ipfw (4),
.BR capabilities (7),
.BR netlink (7),
.BR raw (7),
.BR socket (7),
.BR tcp (7),
.BR udp (7)
.PP
.\"O RFC\ 791 for the original IP specification.
.BR RFC\ 791 :
オリジナルの IP の仕様
.br
.\"O RFC\ 1122 for the IPv4 host requirements.
.BR RFC\ 1122 :
IPv4 ホストの必要条件
.br
.\"O RFC\ 1812 for the IPv4 router requirements.
.BR RFC\ 1812 :
IPv4 ルータの必要条件
.\" FIXME autobind INADDR REUSEADDR

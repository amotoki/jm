.\" Copyright (c) 2002 by Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" 6 Aug 2002 - Initial Creation
.\" Modified 2003-05-23, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" Modified 2004-05-27, Michael Kerrisk, <mtk.manpages@gmail.com>
.\" 2004-12-08, mtk Added O_NOATIME for CAP_FOWNER
.\" 2005-08-16, mtk, Added CAP_AUDIT_CONTROL and CAP_AUDIT_WRITE
.\" 2008-07-15, Serge Hallyn <serue@us.bbm.com>
.\"     Document file capabilities, per-process capability
.\"     bounding set, changed semantics for CAP_SETPCAP,
.\"     and other changes in 2.6.2[45].
.\"     Add CAP_MAC_ADMIN, CAP_MAC_OVERRIDE, CAP_SETFCAP.
.\" 2008-07-15, mtk
.\"     Add text describing circumstances in which CAP_SETPCAP
.\"     (theoretically) permits a thread to change the
.\"     capability sets of another thread.
.\"     Add section describing rules for programmatically
.\"     adjusting thread capability sets.
.\"     Describe rationale for capability bounding set.
.\"     Document "securebits" flags.
.\"     Add text noting that if we set the effective flag for one file
.\"     capability, then we must also set the effective flag for all
.\"     other capabilities where the permitted or inheritable bit is set.
.\"
.\" Japanese Version Copyright (c) 2005 Akihiro MOTOKI all rights reserved.
.\" Translated 2005-03-09, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2005-11-04, Akihiro MOTOKI
.\" Updated 2006-04-16, Akihiro MOTOKI, LDP v2.29
.\" Updated 2006-07-20, Akihiro MOTOKI, LDP v2.34
.\" Updated 2007-01-05, Akihiro MOTOKI, LDP v2.43
.\" Updated 2008-12-24, Akihiro MOTOKI, LDP v3.15
.\" Updated 2009-02-27, Akihiro MOTOKI, LDP v3.19
.\" Updated 2010-04-11, Akihiro MOTOKI, LDP v3.24
.\"
.TH CAPABILITIES 7 2010-01-31 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O capabilities \- overview of Linux capabilities
capabilities \- Linux のケーパビリティ (capability) の概要
.\"O .SH DESCRIPTION
.SH 説明
.\"O For the purpose of performing permission checks,
.\"O traditional Unix implementations distinguish two categories of processes:
.\"O .I privileged
.\"O processes (whose effective user ID is 0, referred to as superuser or root),
.\"O and
.\"O .I unprivileged
.\"O processes (whose effective UID is nonzero).
権限のチェックを行う観点から見ると、伝統的な Unix の実装では
プロセスは二つのカテゴリに分類できる:
.I 特権
プロセス (実効ユーザID が 0 のプロセス。ユーザID 0 は
スーパーユーザや root と呼ばれる) と
.I 非特権
プロセス (実効ユーザID が 0 以外のプロセス) である。
.\"O Privileged processes bypass all kernel permission checks,
.\"O while unprivileged processes are subject to full permission
.\"O checking based on the process's credentials
.\"O (usually: effective UID, effective GID, and supplementary group list).
非特権プロセスでは、プロセスの資格情報 (通常は、実効UID 、実効GID
と追加のグループリスト) に基づく権限チェックが行われるのに対し、
特権プロセスでは全てのカーネルの権限チェックがバイパスされる。

.\"O Starting with kernel 2.2, Linux divides the privileges traditionally
.\"O associated with superuser into distinct units, known as
.\"O .IR capabilities ,
.\"O which can be independently enabled and disabled.
.\"O Capabilities are a per-thread attribute.
バージョン 2.2 以降の Linux では、
これまでスーパーユーザに結び付けられてきた権限を、
いくつかのグループに分割している。これらのグループは
.IR ケーパビリティ (capability)
と呼ばれ、グループ毎に独立に有効、無効を設定できる。
ケーパビリティはスレッド単位の属性である。
.\"
.\"O .SS Capabilities List
.SS ケーパビリティのリスト
.\"O The following list shows the capabilities implemented on Linux,
.\"O and the operations or behaviors that each capability permits:
以下のリストは、
Linux で実装されているケーパビリティと
各ケーパビリティが許可する操作と動作をまとめたものである。
.TP
.\"O .BR CAP_AUDIT_CONTROL " (since Linux 2.6.11)"
.\"O Enable and disable kernel auditing; change auditing filter rules;
.\"O retrieve auditing status and filtering rules.
.BR CAP_AUDIT_CONTROL " (Linux 2.6.11 以降)"
カーネル監査 (audit) の有効無効の切り替え、
監査のフィルタ・ルールの変更、
監査の状況やフィルタ・ルールの取得ができる。
.TP
.\"O .BR CAP_AUDIT_WRITE " (since Linux 2.6.11)"
.BR CAP_AUDIT_WRITE " (Linux 2.6.11 以降)"
.\"O Write records to kernel auditing log.
カーネル監査のログにレコードを書き込む。
.TP
.B CAP_CHOWN
.\"O Make arbitrary changes to file UIDs and GIDs (see
.\"O .BR chown (2)).
ファイルの UID とGID を任意に変更する
.RB ( chown (2)
参照)。
.TP
.B CAP_DAC_OVERRIDE
.\"O Bypass file read, write, and execute permission checks.
.\"O (DAC is an abbreviation of "discretionary access control".)
ファイルの読み出し、書き込み、実行の権限チェックをバイパスする
(DAC は "discretionary access control (任意のアクセス制御)" の略である)。
.TP
.B CAP_DAC_READ_SEARCH
.\"O Bypass file read permission checks and
.\"O directory read and execute permission checks.
ファイルの読み出し権限のチェックとディレクトリの読み出しと実行
の権限チェックをバイパスする。
.TP
.B CAP_FOWNER
.PD 0
.RS
.IP * 2
.\"O Bypass permission checks on operations that normally
.\"O require the file system UID of the process to match the UID of
.\"O the file (e.g.,
.\"O .BR chmod (2),
.\"O .BR utime (2)),
.\"O excluding those operations covered by
.\"O .B CAP_DAC_OVERRIDE
.\"O and
.\"O .BR CAP_DAC_READ_SEARCH ;
通常、プロセスのファイルシステム UID がファイルの UID に一致することが
要求される操作 (例えば
.BR chmod (2),
.BR utime (2))
における権限チェックをバイパスする。
但し、
.B CAP_DAC_OVERRIDE
か
.B CAP_DAC_READ_SEARCH
によりチェックが行われる操作は除く。
.IP *
.\"O set extended file attributes (see
.\"O .BR chattr (1))
.\"O on arbitrary files;
任意のファイルに対して拡張ファイル属性を設定する
.RB ( chattr (1)
参照)。
.IP *
.\"O set Access Control Lists (ACLs) on arbitrary files;
任意のファイルに対してアクセス制御リスト (ACL) を設定する。
.IP *
.\"O ignore directory sticky bit on file deletion;
ファイルの削除の際にディレクトリのスティッキービットを無視する。
.IP *
.\"O specify
.\"O .B O_NOATIME
.\"O for arbitrary files in
.\"O .BR open (2)
.\"O and
.\"O .BR fcntl (2).
.BR open (2)
や
.BR fcntl (2)
で任意のファイルに対して
.B O_NOATIME
を指定する。
.RE
.PD
.TP
.B CAP_FSETID
.\"O Don't clear set-user-ID and set-group-ID permission
.\"O bits when a file is modified;
.\"O set the set-group-ID bit for a file whose GID does not match
.\"O the file system or any of the supplementary GIDs of the calling process.
ファイルが変更されたときに set-user-ID とset-group-ID の許可ビットをクリア
しない。呼び出し元プロセスのファイルシステム GID と追加の GID のいずれとも
GID が一致しないファイルに対して set-group-ID ビットを設定する。
.TP
.B CAP_IPC_LOCK
.\"O Lock memory
.\"O .RB ( mlock (2),
.\"O .BR mlockall (2),
.\"O .BR mmap (2),
.\"O .BR shmctl (2)).
メモリーのロック
.RB ( mlock (2),
.BR mlockall (2),
.BR mmap (2),
.BR shmctl (2))
を行う。
.TP
.B CAP_IPC_OWNER
.\"O Bypass permission checks for operations on System V IPC objects.
System V IPC オブジェクトに対する操作に関して権限チェックをバイパスする。
.TP
.B CAP_KILL
.\"O Bypass permission checks for sending signals (see
.\"O .BR kill (2)).
.\"O This includes use of the
.\"O .BR ioctl (2)
.\"O .B KDSIGACCEPT
.\"O operation.
シグナルを送信する際に権限チェックをバイパスする
.RB ( kill (2)
参照)。これには
.BR ioctl (2)
の
.B KDSIGACCEPT
操作の使用も含まれる。
.\" FIXME CAP_KILL also has an effect for threads + setting child
.\"       termination signal to other than SIGCHLD: without this
.\"       capability, the termination signal reverts to SIGCHLD
.\"       if the child does an exec().  What is the rationale
.\"       for this?
.TP
.\"O .BR CAP_LEASE " (since Linux 2.4)"
.BR CAP_LEASE " (Linux 2.4 以降)"
.\"O Establish leases on arbitrary files (see
.\"O .BR fcntl (2)).
任意のファイルに対して
ファイルリースを設定する
.RB ( fcntl (2)
参照)。
.TP
.B CAP_LINUX_IMMUTABLE
.\"O Set the
.\"O .B FS_APPEND_FL
.\"O and
.\"O .B FS_IMMUTABLE_FL
.\"O .\" These attributes are now available on ext2, ext3, Reiserfs, XFS, JFS
.\"O i-node flags (see
.\"O .BR chattr (1)).
拡張ファイル属性
.B FS_APPEND_FL
と
.B FS_IMMUTABLE_FL
を設定する
.RB ( chattr (1)
参照)。
.\" これらの属性は ext2, ext3, Reiserfs, XFS, JFS で利用可能である。
.TP
.\"O .BR CAP_MAC_ADMIN " (since Linux 2.6.25)"
.BR CAP_MAC_ADMIN " (Linux 2.6.25 以降)"
.\"O Override Mandatory Access Control (MAC).
.\"O Implemented for the Smack Linux Security Module (LSM).
強制アクセス制御 (MAC) を上書きする。
Smack Linux Security Module (LSM) 用に実装されている。
.TP
.\"O .BR CAP_MAC_OVERRIDE " (since Linux 2.6.25)"
.BR CAP_MAC_OVERRIDE " (Linux 2.6.25 以降)"
.\"O Allow MAC configuration or state changes.
.\"O Implemented for the Smack LSM.
MAC の設定や状態を変更する。
Smack LSM 用に実装されている。
.TP
.\"O .BR CAP_MKNOD " (since Linux 2.4)"
.BR CAP_MKNOD " (Linux 2.4 以降)"
.\"O Create special files using
.\"O .BR mknod (2).
(Linux 2.4 以降)
.BR mknod (2)
を使用してスペシャル・ファイルを作成する。
.TP
.B CAP_NET_ADMIN
.\"O Perform various network-related operations
.\"O (e.g., setting privileged socket options,
.\"O enabling multicasting, interface configuration,
.\"O modifying routing tables).
各種のネットワーク関連の操作を実行する。
(例えば、特権が必要なソケットオプションを設定する、マルチキャストを有効にする、
インターフェースを設定する、ルーティングテーブルを変更するなど)
.TP
.B CAP_NET_BIND_SERVICE
.\"O Bind a socket to Internet domain privileged ports
.\"O (port numbers less than 1024).
インターネットドメインの特権ポート (ポート番号が 1024 番未満)
をバインドできる。
.TP
.B CAP_NET_BROADCAST
.\"O (Unused)  Make socket broadcasts, and listen to multicasts.
(未使用) ソケットのブロードキャストと、マルチキャストの待ち受けを行う。
.TP
.B CAP_NET_RAW
.\"O Use RAW and PACKET sockets.
.\"O .\" Also various IP options and setsockopt(SO_BINDTODEVICE)
RAW ソケットと PACKET ソケットを使用する。
.\" また、各種の IP オプションと SO_BINDTODEVICE ソケットオプションを使用できる。
.TP
.B CAP_SETGID
.\"O Make arbitrary manipulations of process GIDs and supplementary GID list;
.\"O forge GID when passing socket credentials via Unix domain sockets.
プロセスの GID と追加の GID リストに対する任意の操作を行う。
Unix ドメインソケット経由でソケットの資格情報 (credential) を渡す際に
偽の GID を渡すことができる。
.TP
.\"O .BR CAP_SETFCAP " (since Linux 2.6.24)"
.BR CAP_SETFCAP " (Linux 2.6.24 以降)"
.\"O Set file capabilities.
ファイルケーパビリティを設定する。
.TP
.B CAP_SETPCAP
.\"O If file capabilities are not supported:
.\"O grant or remove any capability in the
.\"O caller's permitted capability set to or from any other process.
.\"O (This property of
.\"O .B CAP_SETPCAP
.\"O is not available when the kernel is configured to support
.\"O file capabilities, since
.\"O .B CAP_SETPCAP
.\"O has entirely different semantics for such kernels.)
ファイルケーパビリティがサポートされていない場合:
呼び出し元が許可されているケーパビリティセットに含まれる任意のケーパビリティを、
他のプロセスに付与したり、削除したりできる。
(カーネルがファイルケーパビリティをサポートしている場合、
.B CAP_SETPCAP
はこの役割を持たない。
なぜなら、ファイルケーパビリティをサポートしているカーネルでは
.B CAP_SETPCAP
は全く別の意味を持つからである。)

.\"O If file capabilities are supported:
.\"O add any capability from the calling thread's bounding set
.\"O to its inheritable set;
.\"O drop capabilities from the bounding set (via
.\"O .BR prctl (2)
.\"O .BR PR_CAPBSET_DROP );
.\"O make changes to the
.\"O .I securebits
.\"O flags.
ファイルケーパビリティがサポートされている場合:
呼び出し元スレッドのバウンディングセットの任意のケーパビリティを
自身の継承可能ケーパビリティセットに追加できる。
.RB ( prctl (2)
.BR PR_CAPBSET_DROP
を使って)
バウンディングセットからケーパビリティを削除できる。
.I securebits
フラグを変更できる。
.TP
.B CAP_SETUID
.\"O Make arbitrary manipulations of process UIDs
.\"O .RB ( setuid (2),
.\"O .BR setreuid (2),
.\"O .BR setresuid (2),
.\"O .BR setfsuid (2));
.\"O make forged UID when passing socket credentials via Unix domain sockets.
プロセスの UID に対する任意の操作
.RB ( setuid (2),
.BR setreuid (2),
.BR setresuid (2),
.BR setfsuid (2))
を行う。
Unix ドメインソケット経由でソケットの資格情報 (credential) を渡す際に
偽の UID を渡すことができる。
.\" FIXME CAP_SETUID also an effect in exec(); document this.
.TP
.B CAP_SYS_ADMIN
.PD 0
.RS
.IP * 2
.\"O Perform a range of system administration operations including:
.\"O .BR quotactl (2),
.\"O .BR mount (2),
.\"O .BR umount (2),
.\"O .BR swapon (2),
.\"O .BR swapoff (2),
.\"O .BR sethostname (2),
.\"O and
.\"O .BR setdomainname (2);
以下のシステム管理用の操作を実行する:
.BR quotactl (2),
.BR mount (2),
.BR umount (2),
.BR swapon (2),
.BR swapoff (2),
.BR sethostname (2),
.BR setdomainname (2).
.IP *
.\"O perform
.\"O .B IPC_SET
.\"O and
.\"O .B IPC_RMID
.\"O operations on arbitrary System V IPC objects;
任意の System V IPC オブジェクトに対する
.B IPC_SET
と
.B IPC_RMID
操作を実行する。
.IP *
.\"O perform operations on
.\"O .I trusted
.\"O and
.\"O .I security
.\"O Extended Attributes (see
.\"O .BR attr (5));
拡張属性
.I trusted
と
.I security
に対する操作を実行する
.RB ( attr (5)
参照)。
.IP *
.\"O use
.\"O .BR lookup_dcookie (2);
.BR lookup_dcookie (2)
を呼び出す。
.IP *
.\"O use
.\"O .BR ioprio_set (2)
.\"O to assign
.\"O .B IOPRIO_CLASS_RT
.\"O and (before Linux 2.6.25)
.\"O .B IOPRIO_CLASS_IDLE
.\"O I/O scheduling classes;
.BR ioprio_set (2)
を使って I/O スケジューリングクラス
.BR IOPRIO_CLASS_RT ,
.B IOPRIO_CLASS_IDLE
を割り当てる
.RB ( IOPRIO_CLASS_IDLE
は Linux 2.6.25 より前のバージョンのみ)。
.IP *
.\"O forge UID when passing socket credentials;
ソケットの資格情報 (credential) を渡す際に偽の UID を渡す。
.IP *
.\"O exceed
.\"O .IR /proc/sys/fs/file-max ,
.\"O the system-wide limit on the number of open files,
.\"O in system calls that open files (e.g.,
.\"O .BR accept (2),
.\"O .BR execve (2),
.\"O .BR open (2),
.\"O .BR pipe (2));
ファイルをオープンするシステムコール (例えば
.BR accept (2),
.BR execve (2),
.BR open (2),
.BR pipe (2))
でシステム全体でオープンできるファイル数の上限
.I /proc/sys/fs/file-max
を超過する。
.IP *
.\"O employ
.\"O .B CLONE_NEWNS
.\"O flag with
.\"O .BR clone (2)
.\"O and
.\"O .BR unshare (2);
.BR clone (2)
と
.BR unshare (2)
で
.B CLONE_NEWNS
フラグを利用する。
.IP *
.\"O perform
.\"O .B KEYCTL_CHOWN
.\"O and
.\"O .B KEYCTL_SETPERM
.\"O .BR keyctl (2)
.\"O operations.
.BR keyctl (2)
の
.B KEYCTL_CHOWN
と
.B KEYCTL_SETPERM
操作を実行する。
.RE
.PD
.TP
.B CAP_SYS_BOOT
.\"O Use
.\"O .BR reboot (2)
.\"O and
.\"O .BR kexec_load (2).
.BR reboot (2)
と
.BR kexec_load (2)
を呼び出す。
.TP
.B CAP_SYS_CHROOT
.\"O Use
.\"O .BR chroot (2).
.BR chroot (2).
を呼び出す。
.TP
.B CAP_SYS_MODULE
.\"O Load and unload kernel modules
.\"O (see
.\"O .BR init_module (2)
.\"O and
.\"O .BR delete_module (2));
.\"O in kernels before 2.6.25:
.\"O drop capabilities from the system-wide capability bounding set.
カーネルモジュールのロード、アンロードを行う
.RB ( init_module (2)
と
.BR delete_module (2)
を参照のこと)。
バージョン 2.6.25 より前のカーネルで、
システム全体のケーパビリティバウンディングセット (capability bounding set)
からケーパビリティを外す。
.TP
.B CAP_SYS_NICE
.PD 0
.RS
.IP * 2
.\"O Raise process nice value
.\"O .RB ( nice (2),
.\"O .BR setpriority (2))
.\"O and change the nice value for arbitrary processes;
プロセスの nice 値の引き上げ
.RB ( nice (2),
.BR setpriority (2))
や、任意のプロセスの nice 値の変更を行う。
.IP *
.\"O set real-time scheduling policies for calling process,
.\"O and set scheduling policies and priorities for arbitrary processes
.\"O .RB ( sched_setscheduler (2),
.\"O .BR sched_setparam (2));
呼び出し元プロセスに対するリアルタイム・スケジューリングポリシーと、
任意のプロセスに対するスケジューリングポリシーと優先度を設定する
.RB ( sched_setscheduler (2),
.BR sched_setparam (2))。
.IP *
.\"O set CPU affinity for arbitrary processes
.\"O .RB ( sched_setaffinity (2));
任意のプロセスに対する CPU affinity を設定できる
.RB ( sched_setaffinity (2))。
.IP *
.\"O set I/O scheduling class and priority for arbitrary processes
.\"O .RB ( ioprio_set (2));
任意のプロセスに対して I/O スケジューリングクラスと優先度を設定できる
.RB ( ioprio_set (2))。
.IP *
.\"O apply
.\"O .BR migrate_pages (2)
.\"O to arbitrary processes and allow processes
.\"O to be migrated to arbitrary nodes;
.BR migrate_pages (2)
を任意のプロセスに適用し、プロセスを任意のノードに移動する。
.\" FIXME CAP_SYS_NICE also has the following effect for
.\" migrate_pages(2):
.\"     do_migrate_pages(mm, &old, &new,
.\"         capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
.IP *
.\"O apply
.\"O .BR move_pages (2)
.\"O to arbitrary processes;
.BR move_pages (2)
を任意のプロセスに対して行う。
.IP *
.\"O use the
.\"O .B MPOL_MF_MOVE_ALL
.\"O flag with
.\"O .BR mbind (2)
.\"O and
.\"O .BR move_pages (2).
.BR mbind (2)
と
.BR move_pages (2)
で
.B MPOL_MF_MOVE_ALL
フラグを使用する。
.RE
.PD
.TP
.B CAP_SYS_PACCT
.\"O Use
.\"O .BR acct (2).
.BR acct (2)
を呼び出す。
.TP
.B CAP_SYS_PTRACE
.\"O Trace arbitrary processes using
.\"O .BR ptrace (2)
.BR ptrace (2)
を使って任意のプロセスをトレースする。
.TP
.B CAP_SYS_RAWIO
.\"O Perform I/O port operations
.\"O .RB ( iopl (2)
.\"O and
.\"O .BR ioperm (2));
.\"O access
.\"O .IR /proc/kcore .
I/O ポート操作を実行する
.RB ( iopl (2)
、
.BR ioperm (2))。
.I /proc/kcore
にアクセスできる。
.TP
.B CAP_SYS_RESOURCE
.PD 0
.RS
.IP * 2
.\"O Use reserved space on ext2 file systems;
ext2 ファイルシステム上の予約されている領域を使用する。
.IP *
.\"O make
.\"O .BR ioctl (2)
.\"O calls controlling ext3 journaling;
ext3 のジャーナル機能を制御する
.BR ioctl (2)
を使用する。
.IP *
.\"O override disk quota limits;
ディスク quota の上限を上書きする。
.IP *
.\"O increase resource limits (see
.\"O .BR setrlimit (2));
リソース上限を増やす
.RB ( setrlimit (2))。
.IP *
.\"O override
.\"O .B RLIMIT_NPROC
.\"O resource limit;
.B RLIMIT_NPROC
リソース制限を上書きする。
.IP *
.\"O raise
.\"O .I msg_qbytes
.\"O limit for a System V message queue above the limit in
.\"O .I /proc/sys/kernel/msgmnb
.\"O (see
.\"O .BR msgop (2)
.\"O and
.\"O .BR msgctl (2)).
メッセージキューに関する上限
.I msg_qbytes
を
.I /proc/sys/kernel/msgmnb
に指定されている上限よりも大きく設定する
.RB ( msgop (2)
と
.BR msgctl (2)
参照)。
.RE
.PD
.TP
.B CAP_SYS_TIME
.\"O Set system clock
.\"O .RB ( settimeofday (2),
.\"O .BR stime (2),
.\"O .BR adjtimex (2));
.\"O set real-time (hardware) clock.
システムクロックを変更する
.RB ( settimeofday (2),
.BR stime (2),
.BR adjtimex (2))。
リアルタイム (ハードウェア) クロックを変更する。
.TP
.B CAP_SYS_TTY_CONFIG
.\"O Use
.\"O .BR vhangup (2).
.BR vhangup (2)
を呼び出す。
.\"
.\"O .SS Past and Current Implementation
.SS 過去と現在の実装
.\"O A full implementation of capabilities requires that:
完全な形のケーパビリティを実装するには、以下の要件を満たす必要がある：
.IP 1. 3
.\"O For all privileged operations,
.\"O the kernel must check whether the thread has the required
.\"O capability in its effective set.
全ての特権操作について、カーネルはそのスレッドの実効ケーパビリティセットに
必要なケーパビリティがあるかを確認する。
.IP 2.
.\"O The kernel must provide system calls allowing a thread's capability sets to
.\"O be changed and retrieved.
カーネルで、あるスレッドのケーパビリティセットを変更したり、
取得したりできるシステムコールが提供される。
.IP 3.
.\"O The file system must support attaching capabilities to an executable file,
.\"O so that a process gains those capabilities when the file is executed.
ファイルシステムが、実行可能ファイルにケーパビリティを付与でき、ファイル
実行時にそのケーパビリティをプロセスが取得できるような機能をサポートする。
.PP
.\"O Before kernel 2.6.24, only the first two of these requirements are met;
.\"O since kernel 2.6.24, all three requirements are met.
カーネル 2.6.24 より前では、最初の 2つの要件のみが満たされている。
カーネル 2.6.24 以降では、3つの要件すべてが満たされている。
.\"
.\"O .SS Thread Capability Sets
.SS スレッドケーパビリティセット
.\"O Each thread has three capability sets containing zero or more
.\"O of the above capabilities:
各スレッドは以下の 3種類のケーパビリティセットを持つ。各々のケーパビリティセットは
上記のケーパビリティの組み合わせである (全てのケーパビリティが無効でもよい)。
.TP
.\"O .IR Permitted :
.\"O This is a limiting superset for the effective
.\"O capabilities that the thread may assume.
.\"O It is also a limiting superset for the capabilities that
.\"O may be added to the inheritable set by a thread that does not have the
.\"O .B CAP_SETPCAP
.\"O capability in its effective set.
.IR "許可 (permitted)" :
そのスレッドが持つことになっている実効ケーパビリティの
限定的なスーパーセットである。
これは、実効ケーパビリティセットに
.B CAP_SETPCAP
ケーパビリティを持っていないスレッドが継承可能ケーパビリティセットに
追加可能なケーパビリティの限定的なスーパーセットでもある。

.\"O If a thread drops a capability from its permitted set,
.\"O it can never reacquire that capability (unless it
.\"O .BR execve (2)s
.\"O either a set-user-ID-root program, or
.\"O a program whose associated file capabilities grant that capability).
許可ケーパビリティセットから削除してしまったケーパビリティは、
(set-user-ID-root プログラムか、
そのケーパビリティをファイルケーパビリティで許可しているプログラムを
.BR execve (2)
しない限りは) もう一度獲得することはできない。
.TP
.\"O .IR Inheritable :
.\"O This is a set of capabilities preserved across an
.\"O .BR execve (2).
.\"O It provides a mechanism for a process to assign capabilities
.\"O to the permitted set of the new program during an
.\"O .BR execve (2).
.IR "継承可能 (inheritable)" :
.BR execve (2)
を前後で保持されるケーパビリティセットである。
この仕組みを使うことで、あるプロセスが
.BR execve (2)
を行う際に新しいプログラムの許可ケーパビリティセットとして
割り当てるケーパビリティを指定することができる。
.TP
.\"O .IR Effective :
.\"O This is the set of capabilities used by the kernel to
.\"O perform permission checks for the thread.
.IR "実効 (effective)" :
カーネルがスレッドの権限 (permission) をチェックするときに
使用するケーパビリティセットである。
.PP
.\"O A child created via
.\"O .BR fork (2)
.\"O inherits copies of its parent's capability sets.
.\"O See below for a discussion of the treatment of capabilities during
.\"O .BR execve (2).
.BR fork (2)
で作成される子プロセスは、親のケーパビリティセットのコピーを継承する。
.BR execve (2)
中のケーパビリティの扱いについては下記を参照のこと。
.PP
.\"O Using
.\"O .BR capset (2),
.\"O a thread may manipulate its own capability sets (see below).
.BR capset (2)
を使うと、プロセスは自分自身のケーパビリティセット
を操作することができる (下記参照)。
.\"
.\"O .SS File Capabilities
.SS ファイルケーパビリティ
.\"O Since kernel 2.6.24, the kernel supports
.\"O associating capability sets with an executable file using
.\"O .BR setcap (8).
.\"O The file capability sets are stored in an extended attribute (see
.\"O .BR setxattr (2))
.\"O named
.\"O .IR "security.capability" .
.\"O Writing to this extended attribute requires the
.\"O .BR CAP_SETFCAP
.\"O capability.
カーネル 2.6.24 以降では、
.BR setcap (8)
を使って実行ファイルにケーパビリティセットを対応付けることができる。
ファイルケーパビリティセットは
.I "security.capability"
という名前の拡張属性に保存される
.RB ( setxattr (2)
参照)。この拡張属性への書き込みには
.B CAP_SETFCAP
ケーパビリティが必要である。
.\"O The file capability sets,
.\"O in conjunction with the capability sets of the thread,
.\"O determine the capabilities of a thread after an
.\"O .BR execve (2).
ファイルケーパビリティセットとスレッドのケーパビリティセットの両方が
考慮され、
.BR execve (2)
後のスレッドのケーパビリティセットが決定される。

.\"O The three file capability sets are:
3 つのファイルケーパビリティセットが定義されている。
.TP
.\"O .IR Permitted " (formerly known as " forced ):
.\"O These capabilities are automatically permitted to the thread,
.\"O regardless of the thread's inheritable capabilities.
.IR "許可 (Permitted)" " (以前の" "強制 (Forced)" "):"
スレッドの継承可能ケーパビリティに関わらず、そのスレッドに自動的に
認められるケーパビリティ。
.TP
.\"O .IR Inheritable " (formerly known as " allowed ):
.\"O This set is ANDed with the thread's inheritable set to determine which
.\"O inheritable capabilities are enabled in the permitted set of
.\"O the thread after the
.\"O .BR execve (2).
.IR "継承可能 (Inheritable)" " (以前の " "許容 (Allowed)" "):"
このセットと、スレッドの継承可能ケーパビリティセットとの
論理積 (AND) がとられ、
.BR execve (2)
の後にそのスレッドの許可ケーパビリティセットで有効となる
継承可能ケーパビリティが決定される。
.TP
.\"O .IR Effective :
.IR "実効 (Effective)" :
.\"O This is not a set, but rather just a single bit.
.\"O If this bit is set, then during an
.\"O .BR execve (2)
.\"O all of the new permitted capabilities for the thread are
.\"O also raised in the effective set.
.\"O If this bit is not set, then after an
.\"O .BR execve (2),
.\"O none of the new permitted capabilities is in the new effective set.
これは集合ではなく、1 ビットの情報である。
このビットがセットされていると、
.BR execve (2)
実行中に、そのスレッドの新しい許可ケーパビリティが全て
実効ケーパビリティ集合においてもセットされる。
このビットがセットされていない場合、
.BR execve (2)
後には新しい許可ケーパビリティのどれも新しい実効ケーパビリティ集合
にセットされない。

.\"O Enabling the file effective capability bit implies
.\"O that any file permitted or inheritable capability that causes a
.\"O thread to acquire the corresponding permitted capability during an
.\"O .BR execve (2)
.\"O (see the transformation rules described below) will also acquire that
.\"O capability in its effective set.
ファイルの実効ケーパビリティビットを有効にするというのは、
.BR execve (2)
実行時に、ファイルの許可ケーパビリティと継承ケーパビリティに対応するものが
スレッドの許可ケーパビリティセットとしてセットされるが、
これが実効ケーパビリティセットにもセットされるということである
(ケーパビリティの変換ルールは下記参照)。
.\"O Therefore, when assigning capabilities to a file
.\"O .RB ( setcap (8),
.\"O .BR cap_set_file (3),
.\"O .BR cap_set_fd (3)),
.\"O if we specify the effective flag as being enabled for any capability,
.\"O then the effective flag must also be specified as enabled
.\"O for all other capabilities for which the corresponding permitted or
.\"O inheritable flags is enabled.
したがって、ファイルにケーパビリティを割り当てる際
.RB ( setcap (8),
.BR cap_set_file (3),
.BR cap_set_fd (3))、
いずれかのケーパビリティに対して実効フラグを有効と指定する場合、
許可フラグや継承可能フラグを有効にした他の全てのケーパビリティ
についても実効フラグを有効と指定しなければならない。
.\"
.\"O .SS Transformation of Capabilities During execve()
.SS "execve() 中のケーパビリティの変換"
.PP
.\"O During an
.\"O .BR execve (2),
.\"O the kernel calculates the new capabilities of
.\"O the process using the following algorithm:
.BR execve (2)
実行時に、カーネルはプロセスの新しいケーパビリティを次の
アルゴリズムを用いて計算する：
.in +4n
.nf

P'(permitted) = (P(inheritable) & F(inheritable)) |
                (F(permitted) & cap_bset)

P'(effective) = F(effective) ? P'(permitted) : 0

.\"O P'(inheritable) = P(inheritable)    [i.e., unchanged]
P'(inheritable) = P(inheritable)    [つまり、変更されない]

.fi
.in
.\"O where:
各変数の意味は以下の通り:
.RS 4
.IP P 10
.\"O denotes the value of a thread capability set before the
.\"O .BR execve (2)
.BR execve (2)
前のスレッドのケーパビリティセットの値
.IP P'
.\"O denotes the value of a capability set after the
.\"O .BR execve (2)
.BR execve (2)
後のスレッドのケーパビリティセットの値
.IP F
.\"O denotes a file capability set
ファイルケーパビリティセットの値
.IP cap_bset
.\"O is the value of the capability bounding set (described below).
ケーパビリティバウンディングセットの値 (下記参照)
.RE
.\"
.\"O .SS Capabilities and execution of programs by root
.SS ケーパビリティと、ルートによるプログラムの実行
.\"O In order to provide an all-powerful
.\"O .I root
.\"O using capability sets, during an
.\"O .BR execve (2):
.BR execve (2)
時に、ケーパビリティセットを使って、全ての権限を持った
.I root
を実現するには、以下のようにする。
.IP 1. 3
.\"O If a set-user-ID-root program is being executed,
.\"O or the real user ID of the process is 0 (root)
.\"O then the file inheritable and permitted sets are defined to be all ones
.\"O (i.e., all capabilities enabled).
set-user-ID-root プログラムが実行される場合、
またはプロセスの実ユーザ ID が 0 (root) の場合、
ファイルの継承可能セットと許可セットを全て 1
(全てのケーパビリティが有効) に定義する。
.IP 2.
.\"O If a set-user-ID-root program is being executed,
.\"O then the file effective bit is defined to be one (enabled).
set-user-ID-root プログラムが実行される場合、
ファイルの実効ケーパビリティビットを 1 (enabled) に定義する。
.PP
.\"O The upshot of the above rules,
.\"O combined with the capabilities transformations described above,
.\"O is that when a process
.\"O .BR execve (2)s
.\"O a set-user-ID-root program, or when a process with an effective UID of 0
.\"O .BR execve (2)s
.\"O a program,
.\"O it gains all capabilities in its permitted and effective capability sets,
.\"O except those masked out by the capability bounding set.
.\"O .\" If a process with real UID 0, and nonzero effective UID does an
.\"O .\" exec(), then it gets all capabilities in its
.\"O .\" permitted set, and no effective capabilities
.\"O This provides semantics that are the same as those provided by
.\"O traditional Unix systems.
上記のルールにケーパビリティ変換を適用した結果をまとめると、
プロセスが set-user-ID-root プログラムを
.BR execve (2)
する場合、または実効 UID が 0 のプロセスがプログラムを
.BR execve (2)
する場合、許可と実効のケーパビリティセットの全ケーパビリティ
(正確には、ケーパビリティバウンディングセットによるマスクで除外されるもの
以外の全てのケーパビリティ) を取得するということである。
.\" 実 UID が 0 で実効 UID が 0 以外のプロセスが exec () を行うと、
.\" 許可ケーパビリティセットに含まれる全てのケーパビリティ
.\" が取得され、実効ケーパビリティは取得されない。
これにより、伝統的な Unix システムと同じ振る舞いができるようになっている。
.\"O .SS Capability bounding set
.SS ケーパビリティ・バウンディングセット
.\"O The capability bounding set is a security mechanism that can be used
.\"O to limit the capabilities that can be gained during an
.\"O .BR execve (2).
ケーパビリティ・バウンディングセット (capability bounding set) は、
.BR execve (2)
時に獲得できるケーパビリティを制限するために使われる
セキュリティ機構である。
.\"O The bounding set is used in the following ways:
バウンディングセットは以下のように使用される。
.IP * 2
.\"O During an
.\"O .BR execve (2),
.\"O the capability bounding set is ANDed with the file permitted
.\"O capability set, and the result of this operation is assigned to the
.\"O thread's permitted capability set.
.\"O The capability bounding set thus places a limit on the permitted
.\"O capabilities that may be granted by an executable file.
.BR execve (2)
実行時に、ケーパビリティ・バウンディングセットと
ファイルの許可ケーパビリティセットの論理和 (AND) を取ったものが、
そのスレッドの許可ケーパビリティセットに割り当てられる。
つまり、ケーパビリティ・バウンディングセットは、
実行ファイルが認めている許可ケーパビリティに対して
制限を課す働きをする。
.IP *
.\"O (Since Linux 2.6.25)
.\"O The capability bounding set acts as a limiting superset for
.\"O the capabilities that a thread can add to its inheritable set using
.\"O .BR capset (2).
.\"O This means that if a capability is not in the bounding set,
.\"O then a thread can't add this capability to its
.\"O inheritable set, even if it was in its permitted capabilities,
.\"O and thereby cannot have this capability preserved in its
.\"O permitted set when it
.\"O .BR execve (2)s
.\"O a file that has the capability in its inheritable set.
(Linux 2.6.25 以降)
ケーパビリティ・バウンディングセットは、スレッドが
.BR capset (2)
により自身の継承可能セットに追加可能なケーパビリティの母集団を
制限する役割を持つ。
スレッドに許可されたケーパビリティであっても、バウンディングセットに
含まれていなければ、スレッドはそのケーパビリティは自身の継承可能セットに
追加できず、その結果、継承可能セットにそのケーパビリティを含むファイルを
.BR execve (2)
する場合、そのケーパビリティを許可セットに持ち続けることができない、
ということである。
.PP
.\"O Note that the bounding set masks the file permitted capabilities,
.\"O but not the inherited capabilities.
.\"O If a thread maintains a capability in its inherited set
.\"O that is not in its bounding set,
.\"O then it can still gain that capability in its permitted set
.\"O by executing a file that has the capability in its inherited set.
バウンディングセットがマスクを行うのは、継承可能ケーパビリティではなく、
ファイルの許可ケーパビリティのマスクを行う点に注意すること。
あるスレッドの継承可能セットにそのスレッドのバウンディングセットに
存在しないケーパビリティが含まれている場合、そのスレッドは、
継承可能セットに含まれるケーパビリティを持つファイルを実行することにより、
許可セットに含まれるケーパビリティも獲得できるということである。
.PP
.\"O Depending on the kernel version, the capability bounding set is either
.\"O a system-wide attribute, or a per-process attribute.
カーネルのバージョンにより、ケーパビリティ・バウンディングセットは
システム共通の属性の場合と、プロセス単位の属性の場合がある。
.PP
.\"O .B "Capability bounding set prior to Linux 2.6.25"
.B "Linux 2.6.25 より前のケーパビリティ・バウンディングセット"
.PP
.\"O In kernels before 2.6.25, the capability bounding set is a system-wide
.\"O attribute that affects all threads on the system.
2.6.25 より前のカーネルでは、ケーパビリティ・バウンディングセットは
システム共通の属性で、システム上の全てのスレッドに適用される。
.\"O The bounding set is accessible via the file
.\"O .IR /proc/sys/kernel/cap-bound .
.\"O motoki: accessible = 「参照可能」でよいか、文脈を要確認
バウンディングセットは
.I /proc/sys/kernel/cap-bound
ファイル経由で参照できる。
.\"O (Confusingly, this bit mask parameter is expressed as a
.\"O signed decimal number in
.\"O .IR /proc/sys/kernel/cap-bound .)
(間違えやすいが、このビットマスク形式のパラメータは、
.I /proc/sys/kernel/cap-bound
では符号付きの十進数で表現される。)

.\"O Only the
.\"O .B init
.\"O process may set capabilities in the capability bounding set;
.\"O other than that, the superuser (more precisely: programs with the
.\"O .B CAP_SYS_MODULE
.\"O capability) may only clear capabilities from this set.
.B init
プロセスだけがケーパビリティ・バウンディングセットで
ケーパビリティをセットすることができる。
それ以外では、スーパーユーザ (より正確には、
.B CAP_SYS_MODULE
ケーパビリティを持ったプログラム) が、
ケーパビリティ・バウンディングセットのケーパビリティのクリアが
できるだけである。

.\"O On a standard system the capability bounding set always masks out the
.\"O .B CAP_SETPCAP
.\"O capability.
.\"O To remove this restriction (dangerous!), modify the definition of
.\"O .B CAP_INIT_EFF_SET
.\"O in
.\"O .I include/linux/capability.h
.\"O and rebuild the kernel.
通常のシステムでは、ケーパビリティ・バウンディングセットは、
.B CAP_SETPCAP
が無効になっている。
この制限を取り去るには (取り去るのは危険!)、
.I include/linux/capability.h
内の
.B CAP_INIT_EFF_SET
の定義を修正し、カーネルを再構築する必要がある。

.\"O The system-wide capability bounding set feature was added
.\"O to Linux starting with kernel version 2.2.11.
システム共通のケーパビリティ・バウンディングセット機能は、
カーネル 2.2.11 以降で Linux に追加された。
.\"
.PP
.\"O .B "Capability bounding set from Linux 2.6.25 onwards"
.B "Linux 2.6.25 以降のケーパビリティ・バウンディングセット"
.PP
.\"O From Linux 2.6.25, the
.\"O .I "capability bounding set"
.\"O is a per-thread attribute.
.\"O (There is no longer a system-wide capability bounding set.)
Linux 2.6.25 以降では、
「ケーパビリティ・バウンディングセット」はスレッド単位の属性である
(システム共通のケーパビリティ・バウンディングセットはもはや存在しない)。

.\"O The bounding set is inherited at
.\"O .BR fork (2)
.\"O from the thread's parent, and is preserved across an
.\"O .BR execve (2).
バウンディングセットは
.BR fork (2)
時にはスレッドの親プロセスから継承され、
.BR execve (2)
の前後では保持される。

.\"O A thread may remove capabilities from its capability bounding set using the
.\"O .BR prctl (2)
.\"O .B PR_CAPBSET_DROP
.\"O operation, provided it has the
.\"O .B CAP_SETPCAP
.\"O capability.
.\"O Once a capability has been dropped from the bounding set,
.\"O it cannot be restored to that set.
.\"O A thread can determine if a capability is in its bounding set using the
.\"O .BR prctl (2)
.\"O .B PR_CAPBSET_READ
.\"O operation.
スレッドが
.B CAP_SETPCAP
ケーパビリティを持っている場合、そのスレッドは
.BR prctl (2)
の
.BR PR_CAPBSET_DROP
操作を使って自身のケーパビリティ・バウンディングセットから
ケーパビリティを削除することができる。
いったんケーパビリティをバウンディングセットから削除してしまうと、
スレッドはそのケーパビリティを再度セットすることはできない。
.BR prctl (2)
の
.B PR_CAPBSET_READ
操作を使うことで、スレッドがあるケーパビリティが自身のバウンディングセット
に含まれているかを知ることができる。

.\"O Removing capabilities from the bounding set is only supported if file
.\"O capabilities are compiled into the kernel
.\"O (CONFIG_SECURITY_FILE_CAPABILITIES).
.\"O In that case, the
.\"O .B init
.\"O process (the ancestor of all processes) begins with a full bounding set.
.\"O If file capabilities are not compiled into the kernel, then
.\"O .B init
.\"O begins with a full bounding set minus
.\"O .BR CAP_SETPCAP ,
.\"O because this capability has a different meaning when there are
.\"O no file capabilities.
バウンディングセットからのケーパビリティの削除がサポートされるのは、
カーネルのコンパイル時にファイルケーパビリティが有効になっている場合
(CONFIG_SECURITY_FILE_CAPABILITIES) だけである。
この場合には、 (全てのプロセスの先祖である) 
.I init
プロセスはバウンディングセットで全てのケーパビリティが
セットされた状態で開始する。
ファイルケーパビリティが有効になっていない場合には、
.I init
はバウンディングセットで
.B CAP_SETPCAP
以外の全てのケーパビリティがセットされた状態で開始する。
このようになっているのは、
.B CAP_SETPCAP
ケーパビリティがファイルケーパビリティがサポートされていない場合には
違った意味を持つからである。

.\"O Removing a capability from the bounding set does not remove it
.\"O from the thread's inherited set.
.\"O However it does prevent the capability from being added
.\"O back into the thread's inherited set in the future.
バウンディングセットからケーパビリティを削除しても、
スレッドの継承可能セットからはそのケーパビリティは削除されない。
しかしながら、バウンディングセットからの削除により、
この先そのケーパビリティをスレッドの継承可能セットに追加すること
はできなくなる。
.\"
.\"
.\"O .SS Effect of User ID Changes on Capabilities
.SS "ユーザ ID 変更のケーパビリティへの影響"
.\"O To preserve the traditional semantics for transitions between
.\"O 0 and nonzero user IDs,
.\"O the kernel makes the following changes to a thread's capability
.\"O sets on changes to the thread's real, effective, saved set,
.\"O and file system user IDs (using
.\"O .BR setuid (2),
.\"O .BR setresuid (2),
.\"O or similar):
ユーザ ID が 0 と 0 以外の間で変化する際の振る舞いを従来と同じにするため、
スレッドの実 UID、実効 UID、保存 set-user-ID、ファイルシステム UID が
.RB ( setuid (2),
.BR setresuid (2)
などを使って) 変更された際に、カーネルはそのスレッドのケーパビリティセットに
以下の変更を行う:
.IP 1. 3
.\"O If one or more of the real, effective or saved set user IDs
.\"O was previously 0, and as a result of the UID changes all of these IDs
.\"O have a nonzero value,
.\"O then all capabilities are cleared from the permitted and effective
.\"O capability sets.
UID の変更前には実 UID、実効 UID、保存 set-user-ID のうち
少なくとも一つが 0 で、変更後に実 UID、実効 UID、保存 set-user-ID が
すべて 0 以外の値になった場合、許可と実効のケーパビリティセットの
全ケーパビリティをクリアする。
.IP 2.
.\"O If the effective user ID is changed from 0 to nonzero,
.\"O then all capabilities are cleared from the effective set.
実効 UID が 0 から 0 以外に変更された場合、
実効ケーパビリティセットの全ケーパビリティをクリアする。
.IP 3.
.\"O If the effective user ID is changed from nonzero to 0,
.\"O then the permitted set is copied to the effective set.
実効 UID が 0 以外から 0 に変更された場合、
許可ケーパビリティセットの内容を実効ケーパビリティセットにコピーする。
.IP 4.
.\"O If the file system user ID is changed from 0 to nonzero (see
.\"O .BR setfsuid (2))
.\"O then the following capabilities are cleared from the effective set:
.\"O .BR CAP_CHOWN ,
.\"O .BR CAP_DAC_OVERRIDE ,
.\"O .BR CAP_DAC_READ_SEARCH ,
.\"O .BR CAP_FOWNER ,
.\"O .BR CAP_FSETID ,
.\"O .B CAP_LINUX_IMMUTABLE
.\"O (since Linux 2.2.30),
.\"O .BR CAP_MAC_OVERRIDE ,
.\"O and
.\"O .B CAP_MKNOD
.\"O (since Linux 2.2.30).
ファイルシステム UID が 0 から 0 以外に変更された場合
.RB ( setfsuid (2)
参照)、実効ケーパビリティセットの以下のケーパビリティがクリアされる:
.BR CAP_CHOWN ,
.BR CAP_DAC_OVERRIDE ,
.BR CAP_DAC_READ_SEARCH ,
.BR CAP_FOWNER ,
.BR CAP_FSETID ,
.B CAP_LINUX_IMMUTABLE
(Linux 2.2.30 以降),
.BR CAP_MAC_OVERRIDE ,
.B CAP_MKNOD
(Linux 2.2.30 以降)。
.\"O If the file system UID is changed from nonzero to 0,
.\"O then any of these capabilities that are enabled in the permitted set
.\"O are enabled in the effective set.
ファイルシステム UID が 0 以外から 0 に変更された場合、
上記のケーパビリティのうち許可ケーパビリティセットで有効になっているものが
実効ケーパビリティセットで有効にされる。
.PP
.\"O If a thread that has a 0 value for one or more of its user IDs wants
.\"O to prevent its permitted capability set being cleared when it resets
.\"O all of its user IDs to nonzero values, it can do so using the
.\"O .BR prctl (2)
.\"O .B PR_SET_KEEPCAPS
.\"O operation.
各種 UID のうち少なくとも一つが 0 であるスレッドが、
その UID の全てが 0 以外になったときに許可ケーパビリティセットが
クリアされないようにしたい場合には、
.BR prctl (2)
の
.B PR_SET_KEEPCAPS
操作を使えばよい。
.\"
.\"O .SS Programmatically adjusting capability sets
.SS プログラムでケーパビリティセットを調整する
.\"O A thread can retrieve and change its capability sets using the
.\"O .BR capget (2)
.\"O and
.\"O .BR capset (2)
.\"O system calls.
.\"O However, the use of
.\"O .BR cap_get_proc (3)
.\"O and
.\"O .BR cap_set_proc (3),
.\"O both provided in the
.\"O .I libcap
.\"O package,
.\"O is preferred for this purpose.
各スレッドは、
.BR capget (2)
や
.BR capset (2)
を使って、自身のケーパビリティセットを取得したり変更したりできる。
ただし、これを行うには、
.I libcap
パッケージで提供されている
.BR cap_get_proc (3)
や
.BR cap_set_proc (3)
を使うのが望ましい。
.\"O The following rules govern changes to the thread capability sets:
スレッドのケーパビリティセットの変更には以下のルールが適用される。
.IP 1. 3
.\"O If the caller does not have the
.\"O .B CAP_SETPCAP
.\"O capability,
.\"O the new inheritable set must be a subset of the combination
.\"O of the existing inheritable and permitted sets.
.\"O [XXX] motoki: combination って AND ? OR ?
呼び出し側が
.B CAP_SETPCAP
ケーパビリティを持っていない場合、新しい継承可能セットは、
既存の継承可能セットと許可セットの積集合 (AND) の部分集合で
なければならない。
.IP 2.
.\"O (Since kernel 2.6.25)
.\"O The new inheritable set must be a subset of the combination of the
.\"O existing inheritable set and the capability bounding set.
.\"O [XXX] motoki: combination って AND ? OR ?
(カーネル 2.6.25 以降)
新しい継承可能セットは、既存の継承可能セットとケーパビリティ・
バウンディングセットの積集合 (AND) の部分集合でなければならない。
.IP 3.
.\"O The new permitted set must be a subset of the existing permitted set
.\"O (i.e., it is not possible to acquire permitted capabilities
.\"O that the thread does not currently have).
新しい許可セットは、既存の許可セットの部分集合でなければならない
(つまり、そのスレッドが現在持っていない許可ケーパビリティを
獲得することはできない)。
.IP 4.
.\"O The new effective set must be a subset of the new permitted set.
新しい実効ケーパビリティセットは新しい許可ケーパビリティセットの
部分集合になっていなければならない。
.\"O .SS The """securebits"" flags: establishing a capabilities-only environment
.SS securebits フラグ: ケーパビリティだけの環境を構築する
.\" For some background:
.\"       see http://lwn.net/Articles/280279/ and
.\"       http://article.gmane.org/gmane.linux.kernel.lsm/5476/
.\"O Starting with kernel 2.6.26,
.\"O and with a kernel in which file capabilities are enabled,
.\"O Linux implements a set of per-thread
.\"O .I securebits
.\"O flags that can be used to disable special handling of capabilities for UID 0
.\"O .RI ( root ).
カーネル 2.6.26 以降で、
ファイルケーパビリティが有効になったカーネルでは、
スレッド単位の
.I securebits
フラグが実装されており、このフラグを使うと UID 0
.RI ( root )
に対するケーパビリティの特別扱いを無効することができる。
.\"O These flags are as follows:
以下のようなフラグがある。
.TP
.B SECBIT_KEEP_CAPS
.\"O Setting this flag allows a thread that has one or more 0 UIDs to retain
.\"O its capabilities when it switches all of its UIDs to a nonzero value.
.\"O If this flag is not set,
.\"O then such a UID switch causes the thread to lose all capabilities.
.\"O This flag is always cleared on an
.\"O .BR execve (2).
.\"O (This flag provides the same functionality as the older
.\"O .BR prctl (2)
.\"O .B PR_SET_KEEPCAPS
.\"O operation.)
このフラグをセットされている場合、UID が 0 のスレッドの UID が 0 以外の値に
切り替わる際に、そのスレッドはケーパビリティを維持することができる。
このフラグがセットされていない場合には、UID が 0 から 0 以外の値に
切り替わると、そのスレッドは全てのケーパビリティを失う。
このフラグは
.BR execve (2)
時には全てクリアされる
(このフラグは、以前の
.BR prctl (2)
の
.B PR_SET_KEEPCAPS
操作と同じ機能を提供するものである)。
.TP
.B SECBIT_NO_SETUID_FIXUP
.\"O Setting this flag stops the kernel from adjusting  capability sets when
.\"O the threads's effective and file system UIDs are switched between
.\"O zero and nonzero values.
.\"O (See the subsection
.\"O .IR "Effect of User ID Changes on Capabilities" .)
このフラグをセットすると、スレッドの実効 UID とファイルシステム UID が
0 と 0 以外の間で切り替わった場合に、
カーネルはケーパビリティセットの調整を行わなくなる
(「ユーザ ID 変更のケーパビリティへの影響」の節を参照)。
.TP
.B SECBIT_NOROOT
.\"O If this bit is set, then the kernel does not grant capabilities
.\"O when a set-user-ID-root program is executed, or when a process with
.\"O an effective or real UID of 0 calls
.\"O .BR execve (2).
.\"O (See the subsection
.\"O .IR "Capabilities and execution of programs by root" .)
このビットがセットされている場合、
set-user-ID-root プログラムの実行時や、
実効 UID か 実 UID が 0 のプロセスが
.BR execve (2)
を呼び出した時に、カーネルはケーパビリティを許可しない
(「ケーパビリティと、ルートによるプログラムの実行」の節を参照)。
.PP
.\"O Each of the above "base" flags has a companion "locked" flag.
.\"O Setting any of the "locked" flags is irreversible,
.\"O and has the effect of preventing further changes to the
.\"O corresponding "base" flag.
.\"O The locked flags are:
.\"O .BR SECBIT_KEEP_CAPS_LOCKED ,
.\"O .BR SECBIT_NO_SETUID_FIXUP_LOCKED ,
.\"O and
.\"O .BR SECBIT_NOROOT_LOCKED .
上記の "base" フラグの各々には対応する "locked" フラグが存在する。
いずれの "locked" フラグも一度セットされると戻すことはできず、
それ以降は対応する "base" フラグを変更することができなくなる。
"locked" フラグは
.BR SECBIT_KEEP_CAPS_LOCKED ,
.BR SECBIT_NO_SETUID_FIXUP_LOCKED ,
.BR SECBIT_NOROOT_LOCKED
という名前である。
.PP
.\"O The
.\"O .I securebits
.\"O flags can be modified and retrieved using the
.\"O .BR prctl (2)
.\"O .B PR_SET_SECUREBITS
.\"O and
.\"O .B PR_GET_SECUREBITS
.\"O operations.
.\"O The
.\"O .B CAP_SETPCAP
.\"O capability is required to modify the flags.
.I securebits
フラグは、
.BR prctl (2)
の操作
.B PR_SET_SECUREBITS
や
.B PR_GET_SECUREBITS
を使うことで変更したり取得したりできる。
フラグを変更するには
.B CAP_SETPCAP
ケーパビリティが必要である。

.\"O The
.\"O .I securebits
.\"O flags are inherited by child processes.
.\"O During an
.\"O .BR execve (2),
.\"O all of the flags are preserved, except
.\"O .B SECURE_KEEP_CAPS
.\"O which is always cleared.
.I securebits
フラグは子プロセスに継承される。
.BR execve (2)
においては、
.B SECURE_KEEP_CAPS
が常にクリアされる以外は、全てのフラグが保持される。

.\"O An application can use the following call to lock itself,
.\"O and all of its descendants,
.\"O into an environment where the only way of gaining capabilities
.\"O is by executing a program with associated file capabilities:
アプリケーションは、以下の呼び出しを行うことにより、
自分自身および子孫となるプロセス全てに対して、
必要なファイルケーパビリティを持ったプログラムを実行しない限り、
対応するケーパビリティを獲得できないような状況に閉じこめることができる。
.in +4n
.nf

prctl(PR_SET_SECUREBITS,
        SECBIT_KEEP_CAPS_LOCKED |
        SECBIT_NO_SETUID_FIXUP |
        SECBIT_NO_SETUID_FIXUP_LOCKED |
        SECBIT_NOROOT |
        SECBIT_NOROOT_LOCKED);
.fi
.in
.\"O .SH "CONFORMING TO"
.SH 準拠
.PP
.\"O No standards govern capabilities, but the Linux capability implementation
.\"O is based on the withdrawn POSIX.1e draft standard; see
.\"O .IR http://wt.xpilot.org/publications/posix.1e/ .
ケーパビリティに関する標準はないが、 Linux のケーパビリティは廃案になった
POSIX.1e 草案に基づいて実装されている。
.I http://wt.xpilot.org/publications/posix.1e/
を参照。
.\"O .SH NOTES
.SH 注意
.\"O Since kernel 2.5.27, capabilities are an optional kernel component,
.\"O and can be enabled/disabled via the CONFIG_SECURITY_CAPABILITIES
.\"O kernel configuration option.
カーネル 2.5.27 以降、ケーパビリティは選択式のカーネルコンポーネント
となっており、カーネル設定オプション CONFIG_SECURITY_CAPABILITIES
により有効/無効を切り替えることができる。

.\"O The
.\"O .I /proc/PID/task/TID/status
.\"O file can be used to view the capability sets of a thread.
.\"O The
.\"O .I /proc/PID/status
.\"O file shows the capability sets of a process's main thread.
.I /proc/PID/task/TID/status
ファイルを使うと、スレッドのケーパビリティセットを見ることができる。
.I /proc/PID/status
ファイルには、プロセスのメインスレッドのケーパビリティセットが表示される。

.\"O The
.\"O .I libcap
.\"O package provides a suite of routines for setting and
.\"O getting capabilities that is more comfortable and less likely
.\"O to change than the interface provided by
.\"O .BR capset (2)
.\"O and
.\"O .BR capget (2).
.I libcap
パッケージは、ケーパビリティを設定・取得するための
ルーチン群を提供している。これらのインタフェースは、
.BR capset (2)
と
.BR capget (2)
が提供するインターフェースと比べて、より使いやすく、変更される可能性が少ない。
.\"O This package also provides the
.\"O .BR setcap (8)
.\"O and
.\"O .BR getcap (8)
.\"O programs.
.\"O It can be found at
.\"O .br
.\"O .IR http://www.kernel.org/pub/linux/libs/security/linux-privs .
このパッケージでは、
.BR setcap (8),
.BR getcap (8)
というプログラムも提供されている。
パッケージは
.I http://www.kernel.org/pub/linux/libs/security/linux-privs
で入手できる。

.\"O Before kernel 2.6.24, and since kernel 2.6.24 if
.\"O file capabilities are not enabled, a thread with the
.\"O .B CAP_SETPCAP
.\"O capability can manipulate the capabilities of threads other than itself.
.\"O However, this is only theoretically possible,
.\"O since no thread ever has
.\"O .BR CAP_SETPCAP
.\"O in either of these cases:
バージョン 2.6.24 より前、およびファイルケーパビリティが
有効になっていない2.6.24 以降のカーネルでは、
.B CAP_SETPCAP
ケーパビリティを持ったスレッドは自分以外のスレッドの
ケーパビリティを操作できる。
しかしながら、これは理論的に可能というだけである。
以下のいずれかの場合においても、どのスレッドも
.BR CAP_SETPCAP
ケーパビリティを持つことはないからである。
.IP * 2
.\"O In the pre-2.6.25 implementation the system-wide capability bounding set,
.\"O .IR /proc/sys/kernel/cap-bound ,
.\"O always masks out this capability, and this can not be changed
.\"O without modifying the kernel source and rebuilding.
2.6.25 より前の実装では、システム共通のケーパビリティ・バウンディングセット
.I /proc/sys/kernel/cap-bound
ではこのケーパビリティは常に無効になっており、
ソースを変更してカーネルを再コンパイルしない限り、
これを変更することはできない。
.IP *
.\"O If file capabilities are disabled in the current implementation, then
.\"O .B init
.\"O starts out with this capability removed from its per-process bounding
.\"O set, and that bounding set is inherited by all other processes
.\"O created on the system.
現在の実装ではファイルケーパビリティが無効になっている場合、
プロセス毎のバウンディングセットからこのケーパビリティを抜いて
.B init
は開始され、
システム上で生成される他の全てのプロセスでこのバウンディングセットが
継承される。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR capget (2),
.BR prctl (2),
.BR setfsuid (2),
.BR cap_clear (3),
.BR cap_copy_ext (3),
.BR cap_from_text (3),
.BR cap_get_file (3),
.BR cap_get_proc (3),
.BR cap_init (3),
.BR capgetp (3),
.BR capsetp (3),
.BR credentials (7),
.BR pthreads (7),
.BR getcap (8),
.BR setcap (8)
.PP
.\"O .I include/linux/capability.h
.\"O in the kernel source
カーネルソース内の
.I include/linux/capability.h

.\" Hey Emacs! This file is -*- nroff -*- source.
.\"
.\" Copyright (C) 2005 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Japanese Version Copyright (c) 2005 Akihiro MOTOKI all rights reserved.
.\" Translated 2005-12-26, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.TH PIPE 7 2005-12-08 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O pipe \- overview of pipes and FIFOs
pipe \- パイプと FIFO の概要
.\"O .SH DESCRIPTION
.SH 説明
.\"O Pipes and FIFOs (also known as named pipes)
.\"O provide a unidirectional interprocess communication channel.
.\"O A pipe has a
.\"O .I read end
.\"O and a
.\"O .IR "write end" .
.\"O Data written to the write end of a pipe can be read
.\"O from the read end of the pipe.
パイプと FIFO (名前付きパイプともいう) は、
単方向のプロセス間通信チャネルを提供する。
パイプには「読み出し側」と「書き込み側」がある。
パイプの書き込み側で書き込まれたデータは、
パイプの読み出し側から読み出すことができる。

.\"O A pipe is created using
.\"O .BR pipe (2),
.\"O which creates a new pipe and returns two file descriptors,
.\"O one referring to the read end of the pipe,
.\"O the other referring to the write end.
.\"O Pipes can be used to create a communication channel between related
.\"O processes; see
.\"O .BR pipe (2)
.\"O for an example.
パイプを作成するには
.BR pipe (2)
を使用する。
.BR pipe (2)
は新しいパイプを作成し、ファイル・ディスクリプタを二つ返す。
ディスクリプタのうち、一方はパイプの読み出し側を、もう一方は
書き込み側を参照している。
パイプは関連するプロセス間の通信を作成するのに使用できる。
例は
.BR pipe (2)
を参照。

.\"O A FIFO (short for First In First Out) has a name within the file
.\"O system (created using
.\"O .BR mkfifo (3)),
.\"O and is opened using
.\"O .BR open (2).
.\"O Any process may open a FIFO, assuming the file permissions allow it.
FIFO (First In First Out の省略) はファイルシステムでの名前を持ち、
.BR open (2)
を使ってオープンできる
.RB ( mkfifo (3)
を使って作成される)。
どんなプロセスでも、ファイルのアクセス許可があれば FIFO をオープンする
ことができる。
.\"O The read end is opened using the
.\"O .B O_RDONLY
.\"O flag; the write end is opened using the
.\"O .B O_WRONLY
.\"O flag.
.\"O See
.\"O .BR fifo (7)
.\"O for further details.
読み出し側をオープンするには
.B O_RDONLY
フラグを使用し、書き込み側をオープンするには
.B O_WRONLY
フラグを使用する。詳細は
.BR fifo (7)
を参照。
.\"O .IR Note :
.\"O although FIFOs have a pathname in the file system,
.\"O I/O on FIFOs does not involve operations on the underlying device
.\"O (if there is one).
【注意】
FIFO はファイルシステム内のパス名を持つが、
FIFO に対して入出力を行っても、(ファイルシステムが存在するデバイスが
あったとしても) そのデバイスに対する操作は発生しない。
.\"O .SS "I/O on Pipes and FIFOs"
.SS "パイプや FIFO に対する入出力"
.\"O The only difference between pipes and FIFOs is the manner in which
.\"O they are created and opened.
.\"O Once these tasks have been accomplished,
.\"O I/O on pipes and FIFOs has exactly the same semantics.
パイプと FIFO の違いは作成やオープンの方法だけである。
これらの操作が完了した後は、パイプと FIFO に対する入出力は
全く同じ仕組みで行われる。

.\"O If a process attempts to read from an empty pipe, then
.\"O .BR read (2)
.\"O will block until data is available.
.\"O If a process attempts to write to a full pipe (see below), then
.\"O .BR write (2)
.\"O blocks until sufficient data has been read from the pipe
.\"O to allow the write to complete.
.\"O Nonblocking I/O is possible by using the
.\"O .BR fcntl (2)
.\"O .B F_SETFL
.\"O operation to enable the
.\"O .B O_NONBLOCK
.\"O open file status flag.
プロセスが空のパイプから読み出しを行おうとした場合、
.BR read (2)
はデータが読み出し可能になるまで停止する。
プロセスがフル状態のパイプに書き込みを行おうとした場合、
.BR write (2)
は書き込みを完了するのに十分な量のパイプからの読み出しが
行われるまで停止する。
非停止 (nonblocking) I/O を使うこともできる。
非停止 I/O を使うには、
.BR fcntl (2)
.B F_SETFL
操作を使って、
.B O_NONBLOCK
オープンファイル状態フラグを有効にする。

.\"O The communication channel provided by a pipe is a
.\"O .IR "byte stream" :
.\"O there is no concept of message boundaries.
パイプにより提供される通信チャネルは「バイトストリーム」であり、
メッセージ境界の概念はない。

.\"O If all file descriptors referring to the write end of a pipe
.\"O have been closed, then an attempt to
.\"O .BR read (2)
.\"O from the pipe will see end-of-file
.\"O .RB ( read (2)
.\"O will return 0).
パイプの書き込み側を参照しているファイル・ディスクリプタが
すべてクローズされた後で、そのパイプから
.BR read (2)
を行おうとした場合、
end-of-file (ファイル末尾) が見える
.RB ( read (2)
は 0 を返す)。
.\"O If all file descriptors referring to the read end of a pipe
.\"O have been closed, then a
.\"O .BR write (2)
.\"O will cause a
.\"O .B SIGPIPE
.\"O signal to be generated for the calling process.
パイプの読み出し側を参照しているファイル・ディスクリプタが
すべてクローズされた後で、
.BR write (2)
を行うと、呼び出し元プロセスに
.B SIGPIPE
シグナルが送られる。
.\"O If the calling process is ignoring this signal, then
.\"O .BR write (2)
.\"O fails with the error
.\"O .BR EPIPE .
呼び出し元プロセスがこのシグナルを無視しているときには、
.BR write (2)
はエラー
.B EPIPE
で失敗する。
.\"O An application that uses
.\"O .BR pipe (2)
.\"O and
.\"O .BR fork (2)
.\"O should use suitable
.\"O .BR close (2)
.\"O calls to close unnecessary duplicate file descriptors;
.\"O this ensures that end-of-file and
.\"O .BR SIGPIPE / EPIPE
.\"O are delivered when appropriate.
.BR pipe (2)
と
.BR fork (2)
を使用するアプリケーションでは、
.BR close (2)
を適切に使って不必要なファイル・ディスクリプタの複製を
クローズすべきである。こうすることで、必要な時に確実に
end-of-file や
.BR SIGPIPE / EPIPE
が配送されるようになる。

.\"O It is not possible to apply
.\"O .BR lseek (2)
.\"O to a pipe.
パイプには
.BR lseek (2)
を行うことはできない。
.\"O .SS "Pipe Capacity"
.SS パイプの容量
.\"O A pipe has a limited capacity.
.\"O If the pipe is full, then a
.\"O .BR write (2)
.\"O will block or fail, depending on whether the
.\"O .B O_NONBLOCK
.\"O flag is set (see below).
.\"O Different implementations have different limits for the pipe capacity.
.\"O Applications should not rely on a particular capacity:
.\"O an application should be designed so that a reading process consumes data
.\"O as soon as it is available,
.\"O so that a writing process does not remain blocked.
パイプの容量には上限がある。
パイプがフルの場合、
.BR write (2)
は停止したり失敗したりする。どちらになるかは
.B O_NONBLOCK
フラグがセットされているかどうかに依存する (下記参照)。
実装により、パイプの容量の上限は異なる。
アプリケーションは特定の容量を前提にすべきではない。
書き込み側のプロセスが停止したままにならないよう、
読み出し側のプロセスはデータが利用可能になったらできるだけすぐに
読み出しを行うように、アプリケーションを設計すべきである。

.\"O In Linux versions before 2.6.11, the capacity of a pipe was the same as
.\"O the system page size (e.g., 4096 bytes on i386).
.\"O Since Linux 2.6.11, the pipe capacity is 65536 bytes.
バージョン 2.6.11 より前の Linux ではパイプの容量はシステムのページサイズ
と同じであった (例えば i386 では 4096 バイト)。
Linux 2.6.11 以降では、パイプの容量は 65536 バイトである。
.\"O .SS PIPE_BUF
.SS PIPE_BUF
.\"O POSIX.1-2001 says that
.\"O .BR write (2)s
.\"O of less than
.\"O .B PIPE_BUF
.\"O bytes must be atomic: the output data is written to the pipe as a
.\"O contiguous sequence.
.\"O Writes of more than
.\"O .B PIPE_BUF
.\"O bytes may be nonatomic: the kernel may interleave the data
.\"O with data written by other processes.
.\"O POSIX.1-2001 requires
.\"O .B PIPE_BUF
.\"O to be at least 512 bytes.
.\"O (On Linux,
.\"O .B PIPE_BUF
.\"O is 4096 bytes.)
POSIX.1-2001 では、
.B PIPE_BUF
バイト以下の
.BR write (2)
は atomic に行われること、つまりパイプへの出力データの書き込みは
連続したシーケンスとして行われることを必須としている (MUST)。
.B PIPE_BUF
バイトより多くのデータを書き込み場合は atomic とはならない、
つまりパイプへの他のプロセスによるデータの書き込みが間に入る
可能性がある。
POSIX.1-2001 の仕様では、
.B PIPE_BUF
は最小でも 512 バイトであることが要求されている
(Linux では
.B PIPE_BUF
は 4096 バイトである)。
.\"O The precise semantics depend on whether the file descriptor is nonblocking
.\"O .RB ( O_NONBLOCK ),
.\"O whether there are multiple writers to the pipe, and on
.\"O .IR n ,
.\"O the number of bytes to be written:
正確な動作は、ファイル・ディスクリプタが nonblocking
.RB ( O_NONBLOCK )
かどうか、パイプへの書き込みが複数から行われるかどうか、および
書き込みを行うバイト数
.I n
により決定される。
.TP
.\"O \fBO_NONBLOCK\fP disabled, \fIn\fP <= \fBPIPE_BUF\fP
\fBO_NONBLOCK\fP 無効, \fIn\fP <= \fBPIPE_BUF\fP
.\"O All
.\"O .I n
.\"O bytes are written atomically;
.\"O .BR write (2)
.\"O may block if there is not room for
.\"O .I n
.\"O bytes to be written immediately
.I n
バイト全部の書き込みが atomic に行われる。
.I n
バイト分をすぐに書き込む余地がない場合は
.BR write (2)
は停止 (block) することがある。
.TP
.\"O \fBO_NONBLOCK\fP enabled, \fIn\fP <= \fBPIPE_BUF\fP
\fBO_NONBLOCK\fP 有効, \fIn\fP <= \fBPIPE_BUF\fP
.\"O If there is room to write
.\"O .I n
.\"O bytes to the pipe, then
.\"O .BR write (2)
.\"O succeeds immediately, writing all
.\"O .I n
.\"O bytes; otherwise
.\"O .BR write (2)
.\"O fails, with
.\"O .I errno
.\"O set to
.\"O .BR EAGAIN .
パイプに
.I n
バイトを書き込む余地がある場合は、
.I n
バイト全部がすぐに書き込まれる。
余地がない場合は、
.BR write (2)
は失敗し、
.I errno
に
.B EAGAIN
がセットされる。
.TP
.\"O \fBO_NONBLOCK\fP disabled, \fIn\fP > \fBPIPE_BUF\fP
\fBO_NONBLOCK\fP 無効, \fIn\fP > \fBPIPE_BUF\fP
.\"O The write is nonatomic: the data given to
.\"O .BR write (2)
.\"O may be interleaved with
.\"O .BR write (2)s
.\"O by other process;
.\"O the
.\"O .BR write (2)
.\"O blocks until
.\"O .I n
.\"O bytes have been written.
書き込みは atomic とはならない。
.BR write (2)
に渡されたデータの間に、他のプロセスにより
.BR write (2)
されたデータが入ることがある。
.BR write (2)
は
.I n
バイトの書き込みが完了するまで停止する。
.TP
.\"O \fBO_NONBLOCK\fP enabled, \fIn\fP > \fBPIPE_BUF\fP
\fBO_NONBLOCK\fP 有効, \fIn\fP > \fBPIPE_BUF\fP
.\"O If the pipe is full, then
.\"O .BR write (2)
.\"O fails, with
.\"O .I errno
.\"O set to
.\"O .BR EAGAIN .
.\"O Otherwise, from 1 to
.\"O .I n
.\"O bytes may be written (i.e., a "partial write" may occur;
.\"O the caller should check the return value from
.\"O .BR write (2)
.\"O to see how many bytes were actually written),
.\"O and these bytes may be interleaved with writes by other processes.
パイプがフルの場合、
.BR write (2)
は失敗し、
.I errno
に
.B EAGAIN
がセットされる。
それ以外の場合、1 バイト以上
.I n
バイト以下のデータが書き込まれる
(つまり「一部分だけ書き込まれる」場合もあり得る)。
呼び出し元は
.BR write (2)
の返り値を参照し、実際に何バイト書き込まれたのかを確認すべきである。
また、書き込みに成功したデータも、他のプロセスが書き込んだデータが
間に入ることがある。
.\"O .SS "Open File Status Flags"
.SS オープンファイル状態フラグ
.\"O The only open file status flags that can be meaningfully applied to
.\"O a pipe or FIFO are
.\"O .B O_NONBLOCK
.\"O and
.\"O .BR O_ASYNC .
オープンファイル状態フラグのうち、パイプや FIFO に対して意味を持つのは
.B O_NONBLOCK
と
.B O_ASYNC
だけである。

.\"O Setting the
.\"O .B O_ASYNC
.\"O flag for the read end of a pipe causes a signal
.\"O .RB ( SIGIO
.\"O by default) to be generated when new input becomes available on the pipe
.\"O (see
.\"O .BR fcntl (2)
.\"O for details).
.\"O On Linux,
.\"O .B O_ASYNC
.\"O is supported for pipes and FIFOs only since kernel 2.6.
パイプの読み出し側に
.B O_ASYNC
フラグをセットすると、パイプに新たな入力があるとシグナル (デフォルトでは
.BR SIGIO )
が生成される (詳細は
.BR fcntl (2)
を参照)。
Linux では、
パイプと FIFO に対する
.B O_ASYNC
はカーネル 2.6 以降でのみサポートされている。
.\"O .SS "Portability notes"
.SS 移植に関する注意
.\"O On some systems (but not Linux), pipes are bidirectional:
.\"O data can be transmitted in both directions between the pipe ends.
.\"O According to POSIX.1-2001, pipes only need to be unidirectional.
.\"O Portable applications should avoid reliance on
.\"O bidirectional pipe semantics.
いくつかのシステム (Linux ではない) では、パイプは双方向である、
つまりパイプの両端間でデータを両方向に送信することができる。
POSIX.1-2001 では、パイプは一方向の通信だけに対応していればよい。
移植を考慮したアプリケーションでは、双方向パイプの仕組みを
前提にすべきではない。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR dup (2),
.BR fcntl (2),
.BR open (2),
.BR pipe (2),
.BR poll (2),
.BR select (2),
.BR socketpair (2),
.BR stat (2),
.BR mkfifo (3),
.BR epoll (7),
.BR fifo (7)

.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" $Id: packet.7,v 1.12 2001/06/19 07:07:38 argrath Exp $
.\"
.\" Japanese Version Copyright (c) 1999 NAKANO Takeo all rights reserved.
.\" Translated 1999-12-06, NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Updated 2001-02-13, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-02-21, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.\"WORD		physical layer		物理層
.\"WORD		link level header(s)	リンクレベルヘッダ
.\"WORD		phyxical header(s)	物理ヘッダ
.\"WORD		effective user id	実効ユーザー ID
.\"WORD		capability		ケーパビリティ
.\"WORD		pending error		遅延エラー
.\"WORD		promiscuous mode	無差別モード
.\"
.TH PACKET  7 2008-08-08 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.SH 名前
.\"O packet, AF_PACKET \- packet interface on device level.
packet, AF_PACKET \- デバイスレベルのパケットインターフェース
.\"O .SH SYNOPSIS
.SH 書式
.nf
.B #include <sys/socket.h>
.br
.B #include <netpacket/packet.h>
.br
.B #include <net/ethernet.h>     /* the L2 protocols */
.sp
.BI "packet_socket = socket(AF_PACKET, int " socket_type ", int "protocol );
.fi
.\"O .SH DESCRIPTION
.SH 説明
.\"O Packet sockets are used to receive or send raw packets at the device driver
.\"O (OSI Layer 2) level.
.\"O They allow the user to implement protocol modules in user space
.\"O on top of the physical layer.
packet ソケットは、デバイスドライバ (OSI レイヤ 2) レベルで
生のパケット (raw packet) を送受信するために用いられる。
packet ソケットを使うと、ユーザー空間で物理層の上に
プロトコルモジュールを実装することができる。

.\"O The
.\"O .I socket_type
.\"O is either
.\"O .B SOCK_RAW
.\"O for raw packets including the link level header or
.\"O .B SOCK_DGRAM
.\"O for cooked packets with the link level header removed.
.\"O The link level
.\"O header information is available in a common format in a
.\"O .IR sockaddr_ll .
.\"O .I protocol
.\"O is the IEEE 802.3 protocol number in network order.
.\"O See the
.\"O .I <linux/if_ether.h>
.\"O include file for a list of allowed protocols.
.\"O When protocol
.\"O is set to
.\"O .B htons(ETH_P_ALL)
.\"O then all protocols are received.
.\"O All incoming packets of that protocol type will be passed to the packet
.\"O socket before they are passed to the protocols implemented in the kernel.
.I socket_type
には
.B SOCK_RAW
と
.B SOCK_DGRAM
のいずれかを指定する。
.B SOCK_RAW
はリンクレベルヘッダを含む raw パケットを、
.B SOCK_DGRAM
はリンクレベルヘッダが削除された加工済みパケットを示す。
リンクレベルヘッダ情報は
.I sockaddr_ll
で共通のフォーマットで入手できる。
.I protocol
には IEEE 802.3 プロトコル番号を
ネットワークバイトオーダーで指定する。
指定できるプロトコルのリストは、インクルードファイル
.I <linux/if_ether.h>
を参照。プロトコルを
.B htons(ETH_P_ALL)
にすると、全てのプロトコルが受信される。
外部から来たパケットのうち指定したプロトコルのものは、
カーネルに実装されているプロトコルに渡される前の段階で、
packet ソケットに渡される。

.\"O Only processes with effective UID 0 or the
.\"O .B CAP_NET_RAW
.\"O capability may open packet sockets.
packet ソケットをオープンできるのは、
実効ユーザーID が 0 のプロセスか、
.B CAP_NET_RAW
ケーパビリティを持つプロセスだけである。

.\"O .B SOCK_RAW
.\"O packets are passed to and from the device driver without any changes in
.\"O the packet data.
.\"O When receiving a packet, the address is still parsed and
.\"O passed in a standard
.\"O .I sockaddr_ll
.\"O address structure.
.\"O When transmitting a packet, the user supplied buffer
.\"O should contain the physical layer header.
.\"O That packet is then
.\"O queued unmodified to the network driver of the interface defined by the
.\"O destination address.
.\"O Some device drivers always add other headers.
.\"O .B SOCK_RAW
.\"O is similar to but not compatible with the obsolete
.\"O .B AF_INET/SOCK_PACKET
.\"O of Linux 2.0.
.B SOCK_RAW
パケットでは、パケットをデバイスドライバと受け渡しする際、
パケットデータに変更が行われることはない。
パケットの受信時には、アドレスの解析だけは行われ、
標準的な
.I sockaddr_ll
アドレス構造体に渡される。パケットの送信時には、ユーザが指定する
バッファに物理層のヘッダが含まれている必要がある。
パケットはそのまま修正を受けずに、行き先アドレスから決定される
インターフェースのネットワークドライバにキューイングされる。
デバイスドライバによっては、他のヘッダを常に追加するものもある。
.B SOCK_RAW
は Linux 2.0 の obosolete な
.B AF_INET/SOCK_PACKET
と似ているが、互換性があるわけではない。

.\"O .B SOCK_DGRAM
.\"O operates on a slightly higher level.
.\"O The physical header is removed before the packet is passed to the user.
.\"O Packets sent through a
.\"O .B SOCK_DGRAM
.\"O packet socket get a suitable physical layer header based on the
.\"O information in the
.\"O .I sockaddr_ll
.\"O destination address before they are queued.
.B SOCK_DGRAM
はやや高位のレベルで動作する。物理ヘッダは、パケットがユーザーに
渡される前に削除される。
.B SOCK_DGRAM
の packet ソケットを通して送られるパケットは、
.I sockaddr_ll
の行き先アドレスの情報に基づき、適切な物理層のヘッダが付加されてから、
キューに送られる。

.\"O By default all packets of the specified protocol type
.\"O are passed to a packet socket.
.\"O To only get packets from a specific interface use
.\"O .BR bind (2)
.\"O specifying an address in a
.\"O .I struct sockaddr_ll
.\"O to bind the packet socket to an interface.
.\"O Only the
.\"O .I sll_protocol
.\"O and the
.\"O .I sll_ifindex
.\"O address fields are used for purposes of binding.
デフォルトでは、指定したプロトコル型のパケットはすべて packet
ソケットに送られる。特定のインターフェースからのパケットだけを
取得したい場合には、
.I struct sockaddr_ll
にアドレスを指定して
.BR bind (2)
を呼び、 packet ソケットをそのインターフェースに結び付ける (バインドする)。
バインドの際には、アドレスフィールドのうち
.I sll_protocol
と
.I sll_ifindex
だけが用いられる。

.\"O The
.\"O .BR connect (2)
.\"O operation is not supported on packet sockets.
.BR connect (2)
操作は packet ソケットではサポートされていない。

.\"O When the
.\"O .B MSG_TRUNC
.\"O flag is passed to
.\"O .BR recvmsg (2),
.\"O .BR recv (2),
.\"O .BR recvfrom (2)
.\"O the real length of the packet on the wire is always returned,
.\"O even when it is longer than the buffer.
.B MSG_TRUNC
フラグが
.BR recvmsg (2),
.BR recv (2),
.BR recvfrom (2)
に渡されると、 (バッファサイズより大きかったとしても) 常に実際に通信された
パケットの長さが返される。
.\"O .SS Address Types
.SS アドレスのタイプ
.\"O The sockaddr_ll is a device independent physical layer address.
sockaddr_ll はデバイスに依存しない物理層のアドレスである。

.in +4n
.nf
.\"O struct sockaddr_ll {
.\"O     unsigned short sll_family;   /* Always AF_PACKET */
.\"O     unsigned short sll_protocol; /* Physical layer protocol */
.\"O     int            sll_ifindex;  /* Interface number */
.\"O     unsigned short sll_hatype;   /* Header type */
.\"O     unsigned char  sll_pkttype;  /* Packet type */
.\"O     unsigned char  sll_halen;    /* Length of address */
.\"O     unsigned char  sll_addr[8];  /* Physical layer address */
.\"O };
struct sockaddr_ll {
    unsigned short sll_family;   /* 常に AF_PACKET */
    unsigned short sll_protocol; /* 物理層のプロトコル */
    int            sll_ifindex;  /* インターフェース番号 */
    unsigned short sll_hatype;   /* ヘッダ種別 */
    unsigned char  sll_pkttype;  /* パケット種別 */
    unsigned char  sll_halen;    /* アドレスの長さ */
    unsigned char  sll_addr[8];  /* 物理層のアドレス */
};
.fi
.in

.\"O .I sll_protocol
.\"O is the standard ethernet protocol type in network order as defined
.\"O in the
.\"O .I <linux/if_ether.h>
.\"O include file.
.\"O It defaults to the socket's protocol.
.I sll_protocol
は標準的なイーサネットプロトコルのタイプで、
ネットワークバイトオーダーで記述する。
インクルードファイル
.I <linux/if_ether.h>
で定義されている。
これがこのソケットのプロトコルのデフォルトとなる。

.\"O .I sll_ifindex
.\"O is the interface index of the interface
.\"O (see
.\"O .BR netdevice (7));
.\"O 0 matches any interface (only permitted for binding).
.I sll_ifindex
はそのインターフェースの interface index である
.RB ( netdevice (7)
を参照)。
0 は (バインドが許可されている)  任意のインターフェースにマッチする。

.\"O .I sll_hatype
.\"O is a ARP type as defined in the
.\"O .I <linux/if_arp.h>
.\"O include file.
.I sll_hatype
は、インクルードファイル
.I <linux/if_arp.h>
で定義されている ARP 種別である。

.\"O .I sll_pkttype
.\"O contains the packet type.
.\"O Valid types are
.\"O .B PACKET_HOST
.\"O for a packet addressed to the local host,
.\"O .B PACKET_BROADCAST
.\"O for a physical layer broadcast packet,
.\"O .B PACKET_MULTICAST
.\"O for a packet sent to a physical layer multicast address,
.\"O .B PACKET_OTHERHOST
.\"O for a packet to some other host that has been caught by a device driver
.\"O in promiscuous mode, and
.\"O .B PACKET_OUTGOING
.\"O for a packet originated from the local host that is looped back to a packet
.\"O socket.
.\"O These types make only sense for receiving.
.I sll_pkttype
はパケット種別である。指定できる種別は以下のいずれかである:
.B PACKET_HOST
(ローカルホスト向けのパケット)、
.B PACKET_BORADCAST
(物理層のブロードキャストパケット)、
.B PACKET_MULTICAST
(物理層のマルチキャストアドレスに送るパケット)、
.B PACKET_OTHERHOST
(他のホストに向けられたパケットのうち、
無差別モード (promiscuous mode: 後述) のデバイスドライバにより補足されたもの)、
.B PACKET_OUTGOING
(ローカルホストから発信され、
packet ソケットにループバックしてきたパケット)。
これらの種別が意味を持つのは受信時のみである。

.\"O .I sll_addr
.\"O and
.\"O .I sll_halen
.\"O contain the physical layer (e.g., IEEE 802.3) address and its length.
.\"O The exact interpretation depends on the device.
.I sll_addr
と
.I sll_halen
は、物理層の (つまり IEEE 802.3 の) アドレスとその長さである。
厳密な解釈はデバイスに依存する。

.\"O When you send packets it is enough to specify
.\"O .IR sll_family ,
.\"O .IR sll_addr ,
.\"O .IR sll_halen ,
.\"O .IR sll_ifindex .
パケットを送る場合は、
.IR sll_family ,
.IR sll_addr ,
.IR sll_halen ,
.I sll_ifindex
を指定すれば十分である。
.\"O The other fields should be 0.
その他のフィールドは 0 にしておくべきである。
.\"O .I sll_hatype
.\"O and
.\"O .I sll_pkttype
.\"O are set on received packets for your information.
.I sll_hatype
と
.I sll_pkttype
には受信したパケットの情報が設定される。
.\"O For bind only
.\"O .I sll_protocol
.\"O and
.\"O .I sll_ifindex
.\"O are used.
バインドの際には、
.I sll_protocol
と
.I sll_ifindex
だけが使用される。
.\"O .SS Socket Options
.SS ソケットオプション
.\"O Packet sockets can be used to configure physical layer multicasting
.\"O and promiscuous mode.
.\"O It works by calling
.\"O .BR setsockopt (2)
.\"O on a packet socket for
.\"O .B SOL_PACKET
.\"O and one of the options
.\"O .B PACKET_ADD_MEMBERSHIP
.\"O to add a binding or
.\"O .B PACKET_DROP_MEMBERSHIP
.\"O to drop it.
.\"O They both expect a
.\"O .B packet_mreq
.\"O structure as argument:
packet ソケットは、物理層のマルチキャストや
無差別モード (promiscuous mode) を設定して使うことができる。
これには
.B SOL_PACKET
と以下のオプションのいずれかを指定して
.BR setsockopt (2)
を呼べばよい。
バインドを追加する場合は
.B PACKET_ADD_MEMBERSHIP
であり、取り去る場合は
.B PACKET_DROP_MEMBERSHIP
である。これらはいずれも
.B packet_mreq
構造体を引き数に取る。

.in +4n
.nf
.\"O struct packet_mreq {
.\"O     int            mr_ifindex;    /* interface index */
.\"O     unsigned short mr_type;       /* action */
.\"O     unsigned short mr_alen;       /* address length */
.\"O     unsigned char  mr_address[8]; /* physical layer address */
.\"O };
struct packet_mreq {
    int            mr_ifindex;    /* インターフェース番号 */
    unsigned short mr_type;       /* 動作 */
    unsigned short mr_alen;       /* アドレスの長さ */
    unsigned char  mr_address[8]; /* 物理層のアドレス */
};
.fi
.in

.\"O .B mr_ifindex
.\"O contains the interface index for the interface whose status
.\"O should be changed.
.\"O The
.\"O .B mr_type
.\"O parameter specifies which action to perform.
.\"O .B PACKET_MR_PROMISC
.\"O enables receiving all packets on a shared medium (often known as
.\"O "promiscuous mode"),
.\"O .B PACKET_MR_MULTICAST
.\"O binds the socket to the physical layer multicast group specified in
.\"O .B mr_address
.\"O and
.\"O .BR mr_alen ,
.\"O and
.\"O .B PACKET_MR_ALLMULTI
.\"O sets the socket up to receive all multicast packets arriving at
.\"O the interface.
.I mr_ifindex
は、ステータスを変更したいインターフェースの
インターフェース番号である。
.I mr_type
パラメータは実行する動作を指定する:
.B PACKET_MR_PROMISC
は、共有している媒体からの全てのパケットを受信できるようにする
(しばしば "無差別モード (promiscuous mode)" と呼ばれる)。
.B PACKET_MR_MULTICAST
は、そのソケットを、
.I mr_address
と
.I mr_alen
で指定される物理層のマルチキャストブループにバインドする。
.B PACKET_MR_ALLMULTI
は socket を up にして、そのインターフェースに到達したすべての
マルチキャストパケットを受信できるようにする。

.\"O In addition the traditional ioctls
.\"O .BR SIOCSIFFLAGS ,
.\"O .BR SIOCADDMULTI ,
.\"O .B SIOCDELMULTI
.\"O can be used for the same purpose.
昔からある ioctl だけでなく、
.BR SIOCSIFFLAGS ,
.BR SIOCADDMULTI ,
.B SIOCDELMULTI
を同じ目的に用いることができる。
.\"O .SS Ioctls
.SS ioctl
.\"O .B SIOCGSTAMP
.\"O can be used to receive the timestamp of the last received packet.
.\"O Argument is a
.\"O .IR "struct timeval" .
.B SIOCGSTAMP
を用いると、最後に受信したパケットのタイムスタンプを得ることができる。
引き数は
.I struct timeval
である。
.\" FIXME Document SIOCGSTAMPNS

.\"O In addition all standard ioctls defined in
.\"O .BR netdevice (7)
.\"O and
.\"O .BR socket (7)
.\"O are valid on packet sockets.
さらに、
.BR netdevice (7)
および
.BR socket (7)
で定義されている標準の ioctl はいずれも
packet ソケットに指定可能である。
.\"O .SS Error Handling
.SS エラー処理
.\"O Packet sockets do no error handling other than errors occurred
.\"O while passing the packet to the device driver.
.\"O They don't have the concept of a pending error.
packet ソケットは、パケットをデバイスドライバに渡すときに
起きたエラーしか処理しない。遅延エラー (pending error)
に関する概念は持っていない。
.\"O .SH ERRORS
.SH エラー
.TP
.B EADDRNOTAVAIL
.\"O Unknown multicast group address passed.
不明なマルチキャストグループアドレスが渡された。
.TP
.B EFAULT
.\"O User passed invalid memory address.
ユーザが渡したメモリアドレスが不正。
.TP
.B EINVAL
.\"O Invalid argument.
引き数が不正。
.TP
.B EMSGSIZE
.\"O Packet is bigger than interface MTU.
パケットがインターフェースの MTU より大きい。
.TP
.B ENETDOWN
.\"O Interface is not up.
インターフェースが up でない。
.TP
.B ENOBUFS
.\"O Not enough memory to allocate the packet.
パケットに割り当てるメモリが足りない。
.TP
.B ENODEV
.\"O Unknown device name or interface index specified in interface address.
デバイス名が不明。あるいはインターフェースアドレスで指定された
インターフェースインデックスが不明。
.TP
.B ENOENT
.\"O No packet received.
パケットを一つも受信していない。
.TP
.B ENOTCONN
.\"O No interface address passed.
インターフェースアドレスが渡されなかった。
.TP
.B ENXIO
.\"O Interface address contained an invalid interface index.
インターフェースアドレスに不正なインターフェースインデックスが含まれている。
.TP
.B EPERM
.\"O User has insufficient privileges to carry out this operation.
この操作を行うのに必要な権限をユーザが持っていない。

.\"O In addition other errors may be generated by the low-level driver.
上記以外のエラーが、低レベルのドライバで生成されることがある。
.\"O .SH VERSIONS
.SH バージョン
.\"O .B AF_PACKET
.\"O is a new feature in Linux 2.2.
.\"O Earlier Linux versions supported only
.\"O .BR SOCK_PACKET .
.B AF_PACKET
は Linux 2.2 の新機能である。これより古いバージョンの Linux では
.B SOCK_PACKET
のみをサポートしていた。
.PP
.\"O The include file
.\"O .I <netpacket/packet.h>
.\"O is present since glibc 2.1.
.\"O Older systems need:
インクルードファイル
.I <netpacket/packet.h>
が存在するのは glibc 2.1 以降である。
それ以前のシステムでは以下のようにする必要がある:
.sp
.in +4n
.nf
#include <asm/types.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>  /* The L2 protocols */
.fi
.in
.\"O .SH NOTES
.SH 注意
.\"O For portable programs it is suggested to use
.\"O .B AF_PACKET
.\"O via
.\"O .BR pcap (3);
.\"O although this only covers a subset of the
.\"O .B AF_PACKET
.\"O features.
移植性の必要なプログラムでは、
.BR pcap (3)
経由で
.B AF_PACKET
を用いることをお薦めする。ただし、この方法では
.B AF_PACKET
の機能すべてを利用することはできない。

.\"O The
.\"O .B SOCK_DGRAM
.\"O packet sockets make no attempt to create or parse the IEEE 802.2 LLC
.\"O header for a IEEE 802.3 frame.
.\"O When
.\"O .B ETH_P_802_3
.\"O is specified as protocol for sending the kernel creates the
.\"O 802.3 frame and fills out the length field; the user has to supply the LLC
.\"O header to get a fully conforming packet.
.\"O Incoming 802.3 packets are not multiplexed on the DSAP/SSAP protocol
.\"O fields; instead they are supplied to the user as protocol
.\"O .B ETH_P_802_2
.\"O with the LLC header prepended.
.\"O It is thus not possible to bind to
.\"O .BR ETH_P_802_3 ;
.\"O bind to
.\"O .B ETH_P_802_2
.\"O instead and do the protocol multiplex yourself.
.\"O The default for sending is the standard Ethernet DIX
.\"O encapsulation with the protocol filled in.
.B SOCK_DGRAM
packet ソケットは、IEEE 802.3 フレームの IEEE 802.2 LLC ヘッダの
生成や解析を行おうとしない。
.B ETH_P_802_3
が送信プロトコルに指定されると、カーネルは 802.3 フレームを
生成して length フィールドに書き込む。
完全に準拠したパケットを得るためにはユーザーが LLC ヘッダを
与える必要がある。到着した 802.3 パケットでは、
DSAP/SSAP protocol の各フィールドは多重化 (multiplex) されていない。
代わりにこれらは LLC ヘッダが前置された
.B ETH_P_802_2
プロトコルとして与えられる。したがって、
.B ETH_P_802_3
にバインドすることはできない。かわりに
.B ETH_P_802_2
にバインドし、自分自身でプロトコルの多重化を行うこと。
送信のデフォルトは、プロトコルフィールドを持つ
標準の Ethernet DIX encapsulation である。

.\"O Packet sockets are not subject to the input or output firewall chains.
packet ソケットは入出力の firewall chain に影響をうけない。
.\"O .SS Compatibility
.SS 移植性
.\"O In Linux 2.0, the only way to get a packet socket was by calling
.\"O .BI "socket(AF_INET, SOCK_PACKET, " protocol )\fR.
.\"O This is still supported but strongly deprecated.
.\"O The main difference between the two methods is that
.\"O .B SOCK_PACKET
.\"O uses the old
.\"O .I struct sockaddr_pkt
.\"O to specify an interface, which doesn't provide physical layer
.\"O independence.
Linux 2.0 では、 packet ソケットを得る方法は
.BI "socket(AF_INET, SOCK_PACKET, " protocol )\fR
を呼ぶやり方しかなかった。この方法はまだサポートされているが、
用いないことを強く推奨する。現在の方法との主な違いは、
.B SOCK_PACKET
ではインターフェースの指定に古い
.I struct sockaddr_pkt
を用いる点である。これには物理層からの独立性がない。

.in +4n
.nf
struct sockaddr_pkt {
    unsigned short spkt_family;
    unsigned char  spkt_device[14];
    unsigned short spkt_protocol;
};
.fi
.in

.\"O .I spkt_family
.\"O contains
.\"O the device type,
.\"O .I spkt_protocol
.\"O is the IEEE 802.3 protocol type as defined in
.\"O .I <sys/if_ether.h>
.\"O and
.\"O .I spkt_device
.\"O is the device name as a null-terminated string, for example, eth0.
.I spkt_family
はデバイスのタイプ、
.I spkt_protocol
は
.I <sys/if_ether.h>
で定義されている IEEE 802.3 プロトコルタイプ、
.I spkt_device
はデバイスの名前を NULL 終端された文字列で与えたもの (例: eth0) である。

.\"O This structure is obsolete and should not be used in new code.
この構造体は obsolete であり、
新しくコードを書く時には用いるべきでない。
.\"O .SH BUGS
.SH バグ
.\"O glibc 2.1 does not have a define for
.\"O .BR SOL_PACKET .
.\"O The suggested workaround is to use:
glibc 2.1 には
.B SOL_PACKET
の定義がない。回避策としては、以下のようにするとよい。
.in +4n
.nf

#ifndef SOL_PACKET
#define SOL_PACKET 263
#endif

.fi
.in
.\"O This is fixed in later glibc versions and also does not occur on
.\"O libc5 systems.
この問題は新しいバージョンの glibc では修正されている。
libc5 のシステムにはこの問題はない。

.\"O The IEEE 802.2/803.3 LLC handling could be considered as a bug.
IEEE 802.2/803.3 の LLC の扱い方は、バグと考えても良いだろう。

.\"O Socket filters are not documented.
ソケットフィルターについて記載されていない。

.\"O The
.\"O .B MSG_TRUNC
.\"O .BR recvmsg (2)
.\"O extension is an ugly hack and should be replaced by a control message.
.\"O There is currently no way to get the original destination address of
.\"O packets via
.\"O .BR SOCK_DGRAM .
.B MSG_TRUNC
.BR recvmsg (2)
拡張は非常にまずい対処であり、制御メッセージで置き換えるべきである。
今のところ
.B SOCK_DGRAM
経由でパケットについていた宛先アドレスを得る方法がない。
.\"O .\" .SH CREDITS
.\" .SH 著者
.\"O .\" This man page was written by Andi Kleen with help from Matthew Wilcox.
.\"O .\" AF_PACKET in Linux 2.2 was implemented
.\"O .\" by Alexey Kuznetsov, based on code by Alan Cox and others.
.\" この man ページは Matthew Wilcox の助力のもとに Andi Kleen が書いた。
.\" Linux 2.2 の AF_PACKET は、
.\" Alan Cox たちのコードをもとにして Alexey Kuznetsov が実装した。
.\"O .SH SEE ALSO
.SH 関連項目
.BR socket (2),
.BR pcap (3),
.BR capabilities (7),
.BR ip (7),
.BR raw (7),
.BR socket (7)

.\"O RFC\ 894 for the standard IP Ethernet encapsulation.
標準 IP Ethernet encapsulation に関する情報は RFC\ 894 にある。

.\"O RFC\ 1700 for the IEEE 802.3 IP encapsulation.
IEEE 802.3 IP encapsulation に関する情報は RFC\ 1700 にある。

.\"O The
.\"O .I <linux/if_ether.h>
.\"O include file for physical layer protocols.
物理層のプロトコルに関する記述は
.I <linux/if_ether.h>
インクルードファイルにある。

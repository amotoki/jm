.\" This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
.\"
.\" %%%LICENSE_START(VERBATIM_ONE_PARA)
.\" Permission is granted to distribute possibly modified copies
.\" of this page provided the header is included verbatim,
.\" and in case of nontrivial modification author and date
.\" of the modification is added to the header.
.\" %%%LICENSE_END
.\"
.\" $Id: packet.7,v 1.13 2000/08/14 08:03:45 ak Exp $
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" Japanese Version Copyright (c) 1999 NAKANO Takeo all rights reserved.
.\" Translated 1999-12-06, NAKANO Takeo <nakano@apm.seikei.ac.jp>
.\" Updated 2001-02-13, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-02-21, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\"
.TH PACKET 7 2014\-02\-26 Linux "Linux Programmer's Manual"
.SH 名前
packet \- デバイスレベルのパケットインターフェース
.SH 書式
.nf
\fB#include <sys/socket.h>\fP
.br
\fB#include <netpacket/packet.h>\fP
.br
\fB#include <net/ethernet.h> /* the L2 protocols */\fP
.sp
\fBpacket_socket = socket(AF_PACKET, int \fP\fIsocket_type\fP\fB, int \fP\fIprotocol\fP\fB);\fP
.fi
.SH 説明
packet ソケットは、デバイスドライバ (OSI レイヤ 2) レベルで 生のパケット (raw packet) を送受信するために用いられる。
packet ソケットを使うと、ユーザー空間で物理層の上に プロトコルモジュールを実装することができる。

\fIsocket_type\fP には \fBSOCK_RAW\fP と \fBSOCK_DGRAM\fP のいずれかを指定する。 \fBSOCK_RAW\fP
はリンクレベルヘッダを含む raw パケットを、 \fBSOCK_DGRAM\fP はリンクレベルヘッダが削除された加工済みパケットを示す。
リンクレベルヘッダ情報は \fIsockaddr_ll\fP で共通のフォーマットで入手できる。 \fIprotocol\fP には IEEE 802.3
プロトコル番号を ネットワークバイトオーダーで指定する。 指定できるプロトコルのリストは、インクルードファイル
\fI<linux/if_ether.h>\fP を参照。プロトコルを \fBhtons(ETH_P_ALL)\fP
にすると、全てのプロトコルが受信される。 外部から来たパケットのうち指定したプロトコルのものは、
カーネルに実装されているプロトコルに渡される前の段階で、 packet ソケットに渡される。

packet ソケットをオープンできるのは、 実効ユーザーID が 0 のプロセスか、 \fBCAP_NET_RAW\fP
ケーパビリティを持つプロセスだけである。

\fBSOCK_RAW\fP パケットでは、パケットをデバイスドライバと受け渡しする際、 パケットデータに変更が行われることはない。
パケットの受信時には、アドレスの解析だけは行われ、 標準的な \fIsockaddr_ll\fP
アドレス構造体に渡される。パケットの送信時には、ユーザが指定する バッファに物理層のヘッダが含まれている必要がある。
パケットはそのまま修正を受けずに、行き先アドレスから決定される インターフェースのネットワークドライバにキューイングされる。
デバイスドライバによっては、他のヘッダを常に追加するものもある。 \fBSOCK_RAW\fP は Linux 2.0 の obosolete な
\fBAF_INET/SOCK_PACKET\fP と似ているが、互換性があるわけではない。

\fBSOCK_DGRAM\fP はやや高位のレベルで動作する。物理ヘッダは、パケットがユーザーに 渡される前に削除される。 \fBSOCK_DGRAM\fP の
packet ソケットを通して送られるパケットは、 \fIsockaddr_ll\fP の行き先アドレスの情報に基づき、適切な物理層のヘッダが付加されてから、
キューに送られる。

デフォルトでは、指定したプロトコル型のパケットはすべて packet ソケットに送られる。特定のインターフェースからのパケットだけを
取得したい場合には、 \fIstruct sockaddr_ll\fP にアドレスを指定して \fBbind\fP(2)  を呼び、 packet
ソケットをそのインターフェースに結び付ける (バインドする)。 バインドの際には、アドレスフィールドのうち \fIsll_protocol\fP と
\fIsll_ifindex\fP だけが用いられる。

\fBconnect\fP(2)  操作は packet ソケットではサポートされていない。

\fBMSG_TRUNC\fP フラグが \fBrecvmsg\fP(2), \fBrecv\fP(2), \fBrecvfrom\fP(2)  に渡されると、
(バッファサイズより大きかったとしても) 常に実際に通信された パケットの長さが返される。
.SS アドレスのタイプ
\fIsockaddr_ll\fP はデバイスに依存しない物理層のアドレスである。

.in +4n
.nf
struct sockaddr_ll {
    unsigned short sll_family;   /* 常に AF_PACKET */
    unsigned short sll_protocol; /* 物理層のプロトコル */
    int            sll_ifindex;  /* インターフェース番号 */
    unsigned short sll_hatype;   /* ARP ハードウェア種別 */
    unsigned char  sll_pkttype;  /* パケット種別 */
    unsigned char  sll_halen;    /* アドレスの長さ */
    unsigned char  sll_addr[8];  /* 物理層のアドレス */
};
.fi
.in

\fIsll_protocol\fP は標準的なイーサネットプロトコルのタイプで、 ネットワーク
バイトオーダーで記述する。 インクルードファイル
\fI<linux/if_ether.h>\fP で定義されている。 これがこのソケットのプロト
コルのデフォルトとなる。 \fIsll_ifindex\fP はそのインターフェースの interface
index である (\fBnetdevice\fP(7) を参照)。 0 は (バインドが許可されている) 任
意のインターフェースにマッチする。 \fIsll_hatype\fP は、インクルードファイル
\fI<linux/if_arp.h>\fP で定義されている ARP 種別である。
\fIsll_pkttype\fP はパケット種別である。指定できる種別は以下のいずれかである:
\fBPACKET_HOST\fP (ローカルホスト向けのパケット)、 \fBPACKET_BORADCAST\fP (物理層
のブロードキャストパケット)、 \fBPACKET_MULTICAST\fP (物理層のマルチキャストア
ドレスに送るパケット)、 \fBPACKET_OTHERHOST\fP (他のホストに向けられたパケット
のうち、 無差別モード (promiscuous mode: 後述) のデバイスドライバにより補足
されたもの)、 \fBPACKET_OUTGOING\fP (ローカルホストから発信され、 packet ソケッ
トにループバックしてきたパケット)。 これらの種別が意味を持つのは受信時のみ
である。 \fIsll_addr\fP と \fIsll_halen\fP は、物理層の (つまり IEEE 802.3 の)
アドレスとその長さである。 厳密な解釈はデバイスに依存する。

パケットを送る場合は、 \fIsll_family\fP, \fIsll_addr\fP, \fIsll_halen\fP, \fIsll_ifindex\fP
を指定すれば十分である。 その他のフィールドは 0 にしておくべきである。 \fIsll_hatype\fP と \fIsll_pkttype\fP
には受信したパケットの情報が設定される。 バインドの際には、 \fIsll_protocol\fP と \fIsll_ifindex\fP だけが使用される。
.SS ソケットオプション
パケットソケットのオプションは、レベル \fBSOL_PACKET\fP を指定して \fBsetsockopt\fP(2) を呼び出すことで設定できる。
.TP 
\fBPACKET_ADD_MEMBERSHIP\fP
.PD 0
.TP 
\fBPACKET_DROP_MEMBERSHIP\fP
.PD
packet ソケットは、物理層のマルチキャストや 無差別モード (promiscuous mode) を設定して使うことができる。
\fBPACKET_ADD_MEMBERSHIP\fP はバインドを追加し、 \fBPACKET_DROP_MEMBERSHIP\fP
はバインドを削除する。これらはいずれも \fIpacket_mreq\fP 構造体を引き数に取る。

.in +4n
.nf
struct packet_mreq {
    int            mr_ifindex;    /* インターフェース番号 */
    unsigned short mr_type;       /* 動作 */
    unsigned short mr_alen;       /* アドレスの長さ */
    unsigned char  mr_address[8]; /* 物理層のアドレス */
};
.fi
.in

\fImr_ifindex\fP は、ステータスを変更したいインターフェースの インターフェース番号である。 \fImr_type\fP
パラメータは実行する動作を指定する: \fBPACKET_MR_PROMISC\fP は、共有している媒体からの全てのパケットを受信できるようにする
(しばしば "無差別モード (promiscuous mode)" と呼ばれる)。 \fBPACKET_MR_MULTICAST\fP は、そのソケットを、
\fImr_address\fP と \fImr_alen\fP で指定される物理層のマルチキャストブループにバインドする。
\fBPACKET_MR_ALLMULTI\fP は socket を up にして、そのインターフェースに到達したすべての
マルチキャストパケットを受信できるようにする。

昔からある ioctl だけでなく、 \fBSIOCSIFFLAGS\fP, \fBSIOCADDMULTI\fP, \fBSIOCDELMULTI\fP
を同じ目的に用いることができる。
.TP 
\fBPACKET_AUXDATA\fP (Linux 2.6.21 以降)
.\" commit 8dc4194474159660d7f37c495e3fc3f10d0db8cc
If this binary option is enabled, the packet socket passes a metadata
structure along with each packet in the \fBrecvmsg\fP(2)  control field.  The
structure can be read with \fBcmsg\fP(3).  It is defined as

.in +4n
.nf
struct tpacket_auxdata {
    __u32 tp_status;
    __u32 tp_len;      /* packet length */
    __u32 tp_snaplen;  /* captured length */
    __u16 tp_mac;
    __u16 tp_net;
    __u16 tp_vlan_tci;
    __u16 tp_padding;
};
.fi
.in
.TP 
\fBPACKET_FANOUT\fP (Linux 3.1 以降)
.\" commit dc99f600698dcac69b8f56dda9a8a00d645c5ffc
To scale processing across threads, packet sockets can form a fanout group.
In this mode, each matching packet is enqueued onto only one socket in the
group.  A socket joins a fanout group by calling \fBsetsockopt\fP(2)  with
level \fBSOL_PACKET\fP and option \fBPACKET_FANOUT\fP.  Each network namespace can
have up to 65536 independent groups.  A socket selects a group by encoding
the ID in the first 16 bits of the integer option value.  The first packet
socket to join a group implicitly creates it.  To successfully join an
existing group, subsequent packet sockets must have the same protocol,
device settings, fanout mode and flags (see below).  Packet sockets can
leave a fanout group only by closing the socket.  The group is deleted when
the last socket is closed.

.\" commit 2d36097d26b5991d71a2cf4a20c1a158f0f1bfcd
Fanout supports multiple algorithms to spread traffic between sockets.  The
default mode, \fBPACKET_FANOUT_HASH\fP, sends packets from the same flow to the
same socket to maintain per\-flow ordering.  For each packet, it chooses a
socket by taking the packet flow hash modulo the number of sockets in the
group, where a flow hash is a hash over network\-layer address and optional
transport\-layer port fields.  The load\-balance mode \fBPACKET_FANOUT_LB\fP
implements a round\-robin algorithm.  \fBPACKET_FANOUT_CPU\fP selects the socket
based on the CPU that the packet arrived on.  \fBPACKET_FANOUT_ROLLOVER\fP
processes all data on a single socket, moves to the next when one becomes
backlogged.  \fBPACKET_FANOUT_RND\fP selects the socket using a pseudo\-random
number generator.  \fBPACKET_FANOUT_QM\fP (available since Linux 3.14)  selects
the socket using the recorded queue_mapping of the received skb.

Fanout modes can take additional options.  IP fragmentation causes packets
from the same flow to have different flow hashes.  The flag
\fBPACKET_FANOUT_FLAG_DEFRAG\fP, if set, causes packet to be defragmented
before fanout is applied, to preserve order even in this case.  Fanout mode
and options are communicated in the second 16 bits of the integer option
value.  The flag \fBPACKET_FANOUT_FLAG_ROLLOVER\fP enables the roll over
mechanism as a backup strategy: if the original fanout algorithm selects a
backlogged socket, the packet rolls over to the next available one.
.TP 
\fBPACKET_LOSS\fP (with \fBPACKET_TX_RING\fP)
If set, do not silently drop a packet on transmission error, but return it
with status set to \fBTP_STATUS_WRONG_FORMAT\fP.
.TP 
\fBPACKET_RESERVE\fP (with \fBPACKET_RX_RING\fP)
By default, a packet receive ring writes packets immediately following the
metadata structure and alignment padding.  This integer option reserves
additional headroom.
.TP 
\fBPACKET_RX_RING\fP
Create a memory\-mapped ring buffer for asynchronous packet reception.  The
packet socket reserves a contiguous region of application address space,
lays it out into an array of packet slots and copies packets (up to
\fItp_snaplen\fP)  into subsequent slots.  Each packet is preceded by a
metadata structure similar to \fItpacket_auxdata\fP.  The protocol fields
encode the offset to the data from the start of the metadata header.
\fItp_net\fP stores the offset to the network layer.  If the packet socket is
of type \fBSOCK_DGRAM\fP, then \fItp_mac\fP is the same.  If it is of type
\fBSOCK_RAW\fP, then that field stores the offset to the link\-layer frame.
Packet socket and application communicate the head and tail of the ring
through the \fItp_status\fP field.  The packet socket owns all slots with
status \fBTP_STATUS_KERNEL\fP.  After filling a slot, it changes the status of
the slot to transfer ownership to the application.  During normal operation,
the new status is \fBTP_STATUS_USER\fP, to signal that a correctly received
packet has been stored.  When the application has finished processing a
packet, it transfers ownership of the slot back to the socket by setting the
status to \fBTP_STATUS_KERNEL\fP.  Packet sockets implement multiple variants
of the packet ring.  The implementation details are described in
\fIDocumentation/networking/packet_mmap.txt\fP in the Linux kernel source tree.
.TP 
\fBPACKET_STATISTICS\fP
Retrieve packet socket statistics in the form of a structure

.in +4n
.nf
struct tpacket_stats {
    unsigned int tp_packets;  /* Total packet count */
    unsigned int tp_drops;    /* Dropped packet count */
};
.fi
.in

Receiving statistics resets the internal counters.  The statistics structure
differs when using a ring of variant \fBTPACKET_V3\fP.
.TP 
\fBPACKET_TIMESTAMP\fP (with \fBPACKET_RX_RING\fP; since Linux 2.6.36)
.\" commit 614f60fa9d73a9e8fdff3df83381907fea7c5649
The packet receive ring always stores a timestamp in the metadata header.
By default, this is a software generated timestamp generated when the packet
is copied into the ring.  This integer option selects the type of
timestamp.  Besides the default, it support the two hardware formats
described in \fIDocumentation/networking/timestamping.txt\fP in the Linux
kernel source tree.
.TP 
\fBPACKET_TX_RING\fP (Linux 2.6.31 以降)
.\" commit 69e3c75f4d541a6eb151b3ef91f34033cb3ad6e1
Create a memory\-mapped ring buffer for packet transmission.  This option is
similar to \fBPACKET_RX_RING\fP and takes the same arguments.  The application
writes packets into slots with status \fBTP_STATUS_AVAILABLE\fP and schedules
them for transmission by changing the status to \fBTP_STATUS_SEND_REQUEST\fP.
When packets are ready to be transmitted, the application calls \fBsend\fP(2)
or a variant thereof.  The \fIbuf\fP and \fIlen\fP fields of this call are
ignored.  If an address is passed using \fBsendto\fP(2)  or \fBsendmsg\fP(2), then
that overrides the socket default.  On successful transmission, the socket
resets the slot to \fBTP_STATUS_AVAILABLE\fP.  It discards packets silently on
error unless \fBPACKET_LOSS\fP is set.
.TP 
\fBPACKET_VERSION\fP (with \fBPACKET_RX_RING\fP; since Linux 2.6.27)
.\" commit bbd6ef87c544d88c30e4b762b1b61ef267a7d279
By default, \fBPACKET_RX_RING\fP creates a packet receive ring of variant
\fBTPACKET_V1\fP.  To create another variant, configure the desired variant by
setting this integer option before creating the ring.
.TP 
\fBPACKET_QDISC_BYPASS\fP (Linux 3.14 以降)
.\" commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
By default, packets sent through packet sockets pass through the kernel's
qdisc (traffic control) layer, which is fine for the vast majority of use
cases.  For traffic generator appliances using packet sockets that intend to
brute\-force flood the network\(emfor example, to test devices under load in
a similar fashion to pktgen\(emthis layer can be bypassed by setting this
integer option to 1.  A side effect is that packet buffering in the qdisc
layer is avoided, which will lead to increased drops when network device
transmit queues are busy; therefore, use at your own risk.
.SS ioctl
.\" FIXME Document SIOCGSTAMPNS
\fBSIOCGSTAMP\fP を用いると、最後に受信したパケットのタイムスタンプを得ることができる。 引き数は \fIstruct timeval\fP
型の変数である。

さらに、 \fBnetdevice\fP(7)  および \fBsocket\fP(7)  で定義されている標準の ioctl はいずれも packet
ソケットに指定可能である。
.SS エラー処理
packet ソケットは、パケットをデバイスドライバに渡すときに 起きたエラーしか処理しない。遅延エラー (pending error)
に関する概念は持っていない。
.SH エラー
.TP 
\fBEADDRNOTAVAIL\fP
不明なマルチキャストグループアドレスが渡された。
.TP 
\fBEFAULT\fP
ユーザが渡したメモリアドレスが不正。
.TP 
\fBEINVAL\fP
引き数が不正。
.TP 
\fBEMSGSIZE\fP
パケットがインターフェースの MTU より大きい。
.TP 
\fBENETDOWN\fP
インターフェースが up でない。
.TP 
\fBENOBUFS\fP
パケットに割り当てるメモリが足りない。
.TP 
\fBENODEV\fP
デバイス名が不明。あるいはインターフェースアドレスで指定された インターフェースインデックスが不明。
.TP 
\fBENOENT\fP
パケットを一つも受信していない。
.TP 
\fBENOTCONN\fP
インターフェースアドレスが渡されなかった。
.TP 
\fBENXIO\fP
インターフェースアドレスに不正なインターフェースインデックスが含まれている。
.TP 
\fBEPERM\fP
この操作を行うのに必要な権限をユーザが持っていない。

上記以外のエラーが、低レベルのドライバで生成されることがある。
.SH バージョン
\fBAF_PACKET\fP は Linux 2.2 の新機能である。これより古いバージョンの Linux では \fBSOCK_PACKET\fP
のみをサポートしていた。
.PP
インクルードファイル \fI<netpacket/packet.h>\fP が存在するのは glibc 2.1 以降である。
それ以前のシステムでは以下のようにする必要がある:
.sp
.in +4n
.nf
#include <asm/types.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>  /* The L2 protocols */
.fi
.in
.SH 注意
移植性の必要なプログラムでは、 \fBpcap\fP(3)  経由で \fBAF_PACKET\fP を用いることをお薦めする。ただし、この方法では
\fBAF_PACKET\fP の機能すべてを利用することはできない。

\fBSOCK_DGRAM\fP packet ソケットは、IEEE 802.3 フレームの IEEE 802.2 LLC ヘッダの
生成や解析を行おうとしない。 \fBETH_P_802_3\fP が送信プロトコルに指定されると、カーネルは 802.3 フレームを 生成して length
フィールドに書き込む。 完全に準拠したパケットを得るためにはユーザーが LLC ヘッダを 与える必要がある。到着した 802.3 パケットでは、
DSAP/SSAP protocol の各フィールドは多重化 (multiplex) されていない。 代わりにこれらは LLC ヘッダが前置された
\fBETH_P_802_2\fP プロトコルとして与えられる。したがって、 \fBETH_P_802_3\fP にバインドすることはできない。かわりに
\fBETH_P_802_2\fP にバインドし、自分自身でプロトコルの多重化を行うこと。 送信のデフォルトは、プロトコルフィールドを持つ 標準の
Ethernet DIX encapsulation である。

packet ソケットは入出力の firewall chain に影響をうけない。
.SS 移植性
Linux 2.0 では、 packet ソケットを得る方法は \fBsocket(AF_INET, SOCK_PACKET,
\fP\fIprotocol\fP\fB)\fP を呼ぶやり方しかなかった。この方法はまだサポートされているが、 用いないことを強く推奨する。現在の方法との主な違いは、
\fBSOCK_PACKET\fP ではインターフェースの指定に古い \fIstruct sockaddr_pkt\fP
を用いる点である。これには物理層からの独立性がない。

.in +4n
.nf
struct sockaddr_pkt {
    unsigned short spkt_family;
    unsigned char  spkt_device[14];
    unsigned short spkt_protocol;
};
.fi
.in

\fIspkt_family\fP はデバイスのタイプ、 \fIspkt_protocol\fP は \fI<sys/if_ether.h>\fP
で定義されている IEEE 802.3 プロトコルタイプ、 \fIspkt_device\fP はデバイスの名前を NULL 終端された文字列で与えたもの
(例: eth0) である。

この構造体は obsolete であり、 新しくコードを書く時には用いるべきでない。
.SH バグ
glibc 2.1 には \fBSOL_PACKET\fP の定義がない。回避策としては、以下のようにするとよい。
.in +4n
.nf

#ifndef SOL_PACKET
#define SOL_PACKET 263
#endif

.fi
.in
この問題は新しいバージョンの glibc では修正されている。 libc5 のシステムにはこの問題はない。

IEEE 802.2/803.3 の LLC の扱い方は、バグと考えても良いだろう。

ソケットフィルターについて記載されていない。

.\" .SH CREDITS
.\" This man page was written by Andi Kleen with help from Matthew Wilcox.
.\" AF_PACKET in Linux 2.2 was implemented
.\" by Alexey Kuznetsov, based on code by Alan Cox and others.
\fBMSG_TRUNC\fP \fBrecvmsg\fP(2)  拡張は非常にまずい対処であり、制御メッセージで置き換えるべきである。 今のところ
\fBSOCK_DGRAM\fP 経由でパケットについていた宛先アドレスを得る方法がない。
.SH 関連項目
\fBsocket\fP(2), \fBpcap\fP(3), \fBcapabilities\fP(7), \fBip\fP(7), \fBraw\fP(7),
\fBsocket\fP(7)

標準 IP Ethernet encapsulation に関しては RFC\ 894 を、 IEEE 802.3 IP encapsulation
に関しては RFC\ 1700 を参照。

物理層のプロトコルに関する記述は \fI<linux/if_ether.h>\fP インクルードファイルにある。
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.65 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。

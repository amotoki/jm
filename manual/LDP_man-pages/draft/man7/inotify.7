.\" t
.\" Copyright (C) 2006, 2014 Michael Kerrisk <mtk.manpages@gmail.com>
.\"
.\" %%%LICENSE_START(VERBATIM)
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\" %%%LICENSE_END
.\"
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.\"
.\" Japanese Version Copyright (c) 2006 Yuichi SATO
.\"     and Copyright (c) 2007-2008 Akihiro MOTOKI
.\" Translated 2006-07-05 by Yuichi SATO <ysato444@yahoo.co.jp>, LDP v2.29
.\" Updated 2006-07-20 by Yuichi SATO, LDP v2.36
.\" Updated 2007-06-13, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.55
.\" Updated 2008-08-10, Akihiro MOTOKI, LDP v3.05
.\" Updated 2008-09-19, Akihiro MOTOKI, LDP v3.08
.\" Updated 2012-04-30, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2012-05-01, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2013-03-26, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2013-07-22, Akihiro MOTOKI <amotoki@gmail.com>
.\" Updated 2013-08-21, Akihiro MOTOKI <amotoki@gmail.com>, LDP v3.53
.\"
.TH INOTIFY 7 2014\-04\-01 Linux "Linux Programmer's Manual"
.SH 名前
inotify \- ファイルシステムイベントを監視する
.SH 説明
\fIinotify\fP API はファイルシステムイベントを監視するための機構を提供する。 inotify
は個々のファイルやディレクトリを監視するのに使える。 ディレクトリを監視する場合、inotify はディレクトリ自身と
ディレクトリ内のファイルのイベントを返す。

この API では以下のシステムコールが使用される。
.IP * 3
\fBinotify_init\fP(2)  は inotify インスタンスを作成し、inotify インスタンスを参照する ファイルディスクリプタを返す。
もっと新しい \fBinotify_init1\fP(2)  も \fBinotify_init\fP(2)  と同様だが、いくつかの追加の機能を利用するための
\fIflags\fP 引き数を持っている。
.IP *
\fBinotify_add_watch\fP(2)  は inotify インスタンスに関連づけられた「監視対象 (watch) リスト」を操作する。
監視対象リストの各アイテム ("watch") は、 ファイルまたはディレクトリのパス名と、 そのパス名で参照されるファイルに対して
カーネルが監視する複数のイベントの集合を指定する。 \fBinotify_add_watch\fP(2)
は新しい監視アイテムの作成や既存の監視対象の変更ができる。 各監視対象は一意の「監視対象ディスクリプタ」を持つ。 これは監視対象を作成したときに
\fBinotify_add_watch\fP(2)  から返される整数である。
.IP *
When events occur for monitored files and directories, those events are made
available to the application as structured data that can be read from the
inotify file descriptor using \fBread\fP(2)  (see below).
.IP *
\fBinotify_rm_watch\fP(2)  は inotify の監視対象リストからアイテムを削除する。
.IP *
inotify インスタンスを指している 全てのファイルディスクリプタが (\fBclose\fP(2) を使って) クローズされた場合、
その下層にあるオブジェクトとそのリソースは、 カーネルで再利用するために解放される。 関連が切られた監視対象は自動的に解放される。

With careful programming, an application can use inotify to efficiently
monitor and cache the state of a set of filesystem objects.  However, robust
applications should allow for the fact that bugs in the monitoring logic or
races of the kind described below may leave the cache inconsistent with the
filesystem state.  It is probably wise to to do some consistency checking,
and rebuild the cache when inconsistencies are detected.
.SS "inotify ファイルディスクリプタからのイベントの読み出し"
どのようなイベントが起こっていたかを知るには、 アプリケーションで inotify ファイルディスクリプタを \fBread\fP(2)  すればよい。
これまでに何もイベントが起こっていない場合、 停止 (blocking) モードのファイルディスクリプタであれば、 少なくとも 1
つのイベントが起こるまで \fBread\fP(2)  は停止する (シグナルにより割り込まれなかった場合。
シグナルによる割り込みがあった場合、呼び出しはエラー \fBEINTR\fP で失敗する。 \fBsignal\fP(7)  参照)。

\fBread\fP(2)  が成功すると、以下の構造体を 1 つ以上含むバッファが返される:
.in +4n
.nf

.\" FIXME . The type of the 'wd' field should probably be "int32_t".
.\" I submitted a patch to fix this.  See the LKML thread
.\" "[patch] Fix type errors in inotify interfaces", 18 Nov 2008
.\" Glibc bug filed: http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
struct inotify_event {
    int      wd;       /* 監視対象ディスクリプタ */
    uint32_t mask;     /* イベントのマスク */
    uint32_t cookie;   /* 関連するイベント群を関連づける
                          一意なクッキー (rename(2) 用) */
    uint32_t len;      /* \(aqname\(aq フィールドのサイズ */
    char     name[];   /* ヌルで終端された任意の名前 */
};
.fi
.in

\fIwd\fP はイベント発生の監視対象を指定する。 これは、前もって行われた \fBinotify_add_watch\fP(2)
呼び出しで返された監視対象ディスクリプタのうちの 1 つである。

\fImask\fP には発生したイベント (下記参照) を記述するためのビットが含まれる。

\fIcookie\fP は関連するイベントを関連づけるための一意な整数である。
現在のところ、この値は rename イベントに対してのみ使われており、
結果のペアである \fBIN_MOVED_FROM\fP と \fBIN_MOVED_TO\fP イベントを
アプリケーションで関連づけることができる。
他のイベント種別の場合には、 \fIcookie\fP は 0 に設定する。

\fIname\fP フィールドは監視しているディレクトリ内のファイルに対して イベントが返される場合のためにだけ存在する。
監視するディレクトリからのファイルの相対パス名を表す。 このパス名はヌルで終端され、 その後の読み込みで適切なアドレス境界に調整するために、
さらにヌルバイト (\(aq\e0\(aq) が含まれる場合もある。

\fIlen\fP フィールドはヌルバイトを含む \fIname\fP の全てのバイト数を表す。
よって、 \fIinotify_event\fP 構造体のサイズは
\fIsizeof(struct inotify_event)+len\fP である。

\fBread\fP(2) に渡されたバッファが小さすぎて次のイベントに関する情報を返せ
ない場合の動作はカーネルのバージョンにより異なる。 2.6.21 より前のカー
ネルでは、 \fBread\fP(2) は 0 を返す。 2.6.21 以降のカーネルでは、
\fBread\fP(2) はエラー \fBEINVAL\fP で失敗する。
バッファサイズとして

    sizeof(struct inotify_event) + NAME_MAX + 1

を指定すれば、少なくとも 1 イベントで読み出しを行うには十分である。
.SS "inotify イベント"
\fBinotify_add_watch\fP(2)  の \fImask\fP 引き数と、inotify ファイル構造体を \fBread\fP(2)
したときに返される \fIinotify_event\fP 構造体の \fImask\fP フィールドは、ともに inotify イベントを識別するための
ビットマスクである。 以下のビットが \fBinotify_add_watch\fP(2)  を呼ぶときの \fImask\fP に指定可能であり、
\fBread\fP(2)  で返される \fImask\fP フィールドで返される:
.RS 4
.TP 
\fBIN_ACCESS\fP (*)
(\fBread\fP(2), \fBexecve\fP(2) などで) ファイルがアクセスされた。
.TP 
\fBIN_ATTRIB\fP (*)
メタデータが変更された。 メタデータとは、例えば、アクセス許可 (\fBchmod\fP(2))、タイムスタンプ (\fButimensat\fP(2)
など)、拡張属性 (\fBsetxattr\fP(2))、 リンクカウント (Linux 2.6.25 以降; \fBlink\fP(2) のリンク先や
\fBunlink\fP(2) など)、ユーザー/グループ ID (\fBchown\fP(2) など) などである。
.TP 
\fBIN_CLOSE_WRITE\fP (*)
書き込みのためにオープンされたファイルがクローズされた。
.TP 
\fBIN_CLOSE_NOWRITE\fP (*)
書き込み以外のためにオープンされたファイルがクローズされた。
.TP 
\fBIN_CREATE\fP (*)
監視対象ディレクトリ内でファイルやディレクトリが作成された (\fBopen\fP(2)  \fBO_CREAT\fP, \fBmkdir\fP(2),
\fBlink\fP(2), \fBsymlink\fP(2), UNIX ドメインソケットに対する \fBbind\fP(2) など)。
.TP 
\fBIN_DELETE\fP (*)
監視対象ディレクトリ内でファイルやディレクトリが削除された。
.TP 
\fBIN_DELETE_SELF\fP
Watched file/directory was itself deleted.  (This event also occurs if an
object is moved to another filesystem, since \fBmv\fP(1)  in effect copies the
file to the other filesystem and then deletes it from the original
filesystem.)  In addition, an \fBIN_IGNORED\fP event will subsequently be
generated for the watch descriptor.
.TP 
\fBIN_MODIFY\fP (*)
ファイルが変更された (\fBwrite\fP(2), \fBtruncate\fP(2) など)。
.TP 
\fBIN_MOVE_SELF\fP
監視対象のディレクトリまたはファイル自身が移動された。
.TP 
\fBIN_MOVED_FROM\fP (*)
ファイル名の変更を行った際に変更前のファイル名が含まれるディレクトリに対して生成される。
.TP 
\fBIN_MOVED_TO\fP (*)
ファイル名の変更を行った際に新しいファイル名が含まれるディレクトリに対して生成される。
.TP 
\fBIN_OPEN\fP (*)
ファイルがオープンされた。
.RE
.PP
ディレクトリを監視する場合、 上記でアスタリスク (*) を付けたイベントは、 そのディレクトリ内のファイルに対して発生する。 このとき
\fIinotify_event\fP 構造体で返される \fIname\fP フィールドは、ディレクトリ内のファイル名を表す。
.PP
\fBIN_ALL_EVENTS\fP マクロは上記のイベント全てのマスクとして定義される。 このマクロは \fBinotify_add_watch\fP(2)
を呼び出すときの \fImask\fP 引き数として使える。

以下の 2 つの便利なマクロが定義されている。
.RS 4
.TP 
\fBIN_MOVE\fP
\fBIN_MOVED_FROM | IN_MOVED_TO\fP と等価。
.TP 
\fBIN_CLOSE\fP
\fBIN_CLOSE_WRITE | IN_CLOSE_NOWRITE\fP と等価。
.RE
.PP
その他にも以下のビットを \fBinotify_add_watch\fP(2)  を呼ぶときの \fImask\fP に指定できる:
.RS 4
.TP 
\fBIN_DONT_FOLLOW\fP (Linux 2.6.15 以降)
\fIpathname\fP がシンボリックリンクである場合に辿らない。 (Linux 2.6.15 以降)
.TP 
\fBIN_EXCL_UNLINK\fP (Linux 2.6.36 以降)
.\" commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
デフォルトでは、あるディレクトリの子ファイルに関するイベントを監視 (watch) した際、ディレクトリからその子ファイルが削除 (unlink)
された場合であってもその子ファイルに対してイベントが生成される。このことは、アプリケーションによってはあまり興味のないイベントが大量に発生することにつながる
(例えば、\fI/tmp\fP を監視している場合、たくさんのアプリケーションが、すぐにその名前が削除される一時ファイルをそのディレクトリに作成する)。
\fBIN_EXCL_UNLINK\fP
を指定するとこのデフォルトの動作を変更でき、監視対象のディレクトリから子ファイルが削除された後に子ファイルに関するイベントが生成されなくなる。
.TP 
\fBIN_MASK_ADD\fP
\fIpathname\fP に対する監視マスクが既に存在する場合、 (マスクの置き換えではなく) イベントを追加 (OR) する。
.TP 
\fBIN_ONESHOT\fP
1 つのイベントについて \fIpathname\fP を監視し、 イベントが発生したら監視対象リストから削除する。
.TP 
\fBIN_ONLYDIR\fP (Linux 2.6.15 以降)
\fIpathname\fP がディレクトリの場合にのみ監視する。
.RE
.PP
以下のビットが \fBread\fP(2)  で返される \fImask\fP フィールドに設定される:
.RS 4
.TP 
\fBIN_IGNORED\fP
監視対象が (\fBinotify_rm_watch\fP(2) により) 明示的に 削除された。もしくは (ファイルの削除、またはファイル
システムのアンマウントにより) 自動的に削除された。「バグ」も参照のこと。
.TP 
\fBIN_ISDIR\fP
このイベントの対象がディレクトリである。
.TP 
\fBIN_Q_OVERFLOW\fP
イベントキューが溢れた (このイベントの場合、\fIwd\fP は \-1 である)。
.TP 
\fBIN_UNMOUNT\fP
監視対象オブジェクトを含むファイルシステムがアンマウントされた。さらに、この監視対象ディスクリプタに対して \fBIN_IGNORED\fP
イベントが生成される。
.RE
.SS 例
Suppose an application is watching the directory \fIdir\fP and the file
\fIdir/myfile\fP for all events.  The examples below show some events that will
be generated for these two objects.
.RS 4
.TP 
fd = open("dir/myfile", O_RDWR);
\fIdir\fP と \fIdir/myfile\fP の両方に対して \fBIN_OPEN\fP イベントが生成される。
.TP 
read(fd, buf, count);
\fIdir\fP と \fIdir/myfile\fP の両方に対して \fBIN_ACCESS\fP イベントが生成される
.TP 
write(fd, buf, count);
\fIdir\fP と \fIdir/myfile\fP の両方に対して \fBIN_MODIFY\fP イベントが生成される
.TP 
fchmod(fd, mode);
\fIdir\fP と \fIdir/myfile\fP の両方に対して \fBIN_ATTRIB\fP イベントが生成される
.TP 
close(fd);
\fIdir\fP と \fIdir/myfile\fP の両方に対して \fBIN_CLOSE_WRITE\fP イベントが生成される
.RE
.PP
Suppose an application is watching the directories \fIdir1\fP and \fIdir2\fP, and
the file \fIdir1/myfile\fP.  The following examples show some events that may
be generated.
.RS 4
.TP 
link("dir1/myfile", "dir2/new");
\fImyfile\fP に対して \fBIN_ATTRIB\fP イベントが生成され、 \fIdir2\fP に対して \fBIN_CREATE\fP イベントが生成される。
.TP 
rename("dir1/myfile", "dir2/myfile");
\fIdir1\fP に対してイベント \fBIN_MOVED_FROM\fP が、 \fIdir2\fP に対してイベント \fBIN_MOVED_TO\fP が、
\fImyfile\fP に対してイベント \fBIN_MOVE_SELF\fP が生成される。この際 イベント \fBIN_MOVED_FROM\fP と
\fBIN_MOVED_TO\fP は同じ \fIcookie\fP 値を持つ。
.RE
.PP
Suppose that \fIdir1/xx\fP and \fIdir2/yy\fP are (the only) links to the same
file, and an application is watching \fIdir1\fP, \fIdir2\fP, \fIdir1/xx\fP, and
\fIdir2/yy\fP.  Executing the following calls in the order given below will
generate the following events:
.RS 4
.TP 
unlink("dir2/yy");
Generates an \fBIN_ATTRIB\fP event for \fIxx\fP (because its link count changes)
and an \fBIN_DELETE\fP event for \fIdir2\fP.
.TP 
unlink("dir1/xx");
Generates \fBIN_ATTRIB\fP, \fBIN_DELETE_SELF\fP, and \fBIN_IGNORED\fP events for
\fIxx\fP, and an \fBIN_DELETE\fP event for \fIdir1\fP.
.RE
.PP
Suppose an application is watching the directory \fIdir\fP and (the empty)
directory \fIdir/subdir\fP.  The following examples show some events that may
be generated.
.RS 4
.TP 
mkdir("dir/new", mode);
Generates an \fBIN_CREATE | IN_ISDIR\fP event for \fIdir\fP.
.TP 
rmdir("dir/subdir");
Generates \fBIN_DELETE_SELF\fP and \fBIN_IGNORED\fP events for \fIsubdir\fP, and an
\fBIN_DELETE | IN_ISDIR\fP event for \fIdir\fP.
.RE
.SS "/proc インターフェース"
以下のインターフェースは、inotify で消費される カーネルメモリの総量を制限するのに使用できる:
.TP 
\fI/proc/sys/fs/inotify/max_queued_events\fP
このファイルの値は、アプリケーションが \fBinotify_init\fP(2)  を呼び出すときに使用され、対応する inotify インスタンスについて
キューに入れられるイベントの数の上限を設定する。 この制限を超えたイベントは破棄されるが、 \fBIN_Q_OVERFLOW\fP イベントが常に生成される。
.TP 
\fI/proc/sys/fs/inotify/max_user_instances\fP
1 つの実ユーザ ID に対して生成できる inotify インスタンスの数の上限を指定する。
.TP 
\fI/proc/sys/fs/inotify/max_user_watches\fP
作成可能な監視対象の数の実 UID 単位の上限を指定する。
.SH バージョン
inotify は 2.6.13 の Linux カーネルに組込まれた。 これに必要なライブラリのインターフェースは、 glibc のバージョン 2.4
に追加された (\fBIN_DONT_FOLLOW\fP, \fBIN_MASK_ADD\fP, \fBIN_ONLYDIR\fP は glibc バージョン 2.5
で追加された)。
.SH 準拠
inotify API は Linux 独自のものである。
.SH 注意
inotify ファイルディスクリプタは \fBselect\fP(2), \fBpoll\fP(2), \fBepoll\fP(7)  を使って監視できる。
イベントがある場合、ファイルディスクリプタは読み込み可能と通知する。

Linux 2.6.25 以降では、シグナル駆動 (signal\-driven) I/O の通知が inotify
ファイルディスクリプタについて利用可能である。 \fBfcntl\fP(2)  に書かれている (\fBO_ASYNC\fP フラグを設定するための)
\fBF_SETFL\fP, \fBF_SETOWN\fP, \fBF_SETSIG\fP の議論を参照のこと。 シグナルハンドラに渡される \fIsiginfo_t\fP
構造体は、以下のフィールドが設定される (\fIsiginfo_t\fP は \fBsigaction\fP(2)  で説明されている)。 \fIsi_fd\fP には
inotify ファイルディスクリプタ番号が、 \fIsi_signo\fP にはシグナル番号が、 \fIsi_code\fP には \fBPOLL_IN\fP が、
\fIsi_band\fP には \fBPOLLIN\fP が設定される。

inotify ファイルディスクリプタに対して 連続して生成される出力 inotify イベントが同一の場合 (\fIwd\fP, \fImask\fP,
\fIcookie\fP, \fIname\fP が等しい場合)、 前のイベントがまだ読み込まれていなければ、 連続するイベントが 1 つのイベントにまとめられる
(ただし「バグ」の節も参照のこと)。 これによりイベントキューに必要なカーネルメモリ量が減るが、
これはまたアプリケーションがファイルイベント数を信頼性を持って数えるのに inotify を使用できないということでもある。

inotify ファイルディスクリプタの読み込みで返されるイベントは、 順序付けられたキューになる。
従って、たとえば、あるディレクトリの名前を別の名前に変更した場合、 inotify ファイルディスクリプタについての正しい順番で
イベントが生成されることが保証される。

\fBFIONREAD\fP \fBioctl\fP(2)  は inotify ファイルディスクリプタから何バイト読み込めるかを返す。
.SS 制限と警告
inotify API では、inotify イベントが発生するきっかけとなったユーザやプロセスに関する情報は提供されない。とりわけ、inotify
経由でイベントを監視しているプロセスが、自分自身がきっかけとなったイベントと他のプロセスがきっかけとなったイベントを区別する簡単な手段はない。

Inotify reports only events that a user\-space program triggers through the
filesystem API.  As a result, it does not catch remote events that occur on
network filesystems.  (Applications must fall back to polling the filesystem
to catch such events.)  Furthermore, various pseudo\-filesystems such as
\fI/proc\fP, \fI/sys\fP, and \fI/dev/pts\fP are not monitorable with inotify.

The inotify API does not report file accesses and modifications that may
occur because of \fBmmap\fP(2)  and \fBmsync\fP(2).

inotify API では影響が受けるファイルをファイル名で特定する。
しかしながら、アプリケーションが inotify イベントを処理する時点では、
そのファイル名がすでに削除されたり変更されたりしている可能性がある。

The inotify API identifies events via watch descriptors.  It is the
application's responsibility to cache a mapping (if one is needed) between
watch descriptors and pathnames.  Be aware that directory renamings may
affect multiple cached pathnames.

inotify によるディレクトリの監視は再帰的に行われない: あるディレクトリ以下の
サブディレクトリを監視する場合、 監視対象を追加で作成しなければならない。
大きなディレクトリツリーの場合には、この作業にかなり時間がかかることがある。

ディレクトリツリー全体を監視していて、 そのツリー内に新しいサブディレクトリが作成されるか、
既存のディレクトリが名前が変更されそのツリー内に移動した場合、 新しいサブディレクトリに対する watch を作成するまでに、 新しいファイル
(やサブディレクトリ) がそのサブディレクトリ内にすでに作成されている場合がある点に注意すること。 したがって、watch
を追加した直後にサブディレクトリの内容をスキャンしたいと思う場合もあるだろう (必要ならそのサブディレクトリ内のサブディレクトリに対する watch
も再帰的に追加することもあるだろう)。

Note that the event queue can overflow.  In this case, events are lost.
Robust applications should handle the possibility of lost events
gracefully.  For example, it may be necessary to rebuild part or all of the
application cache.  (One simple, but possibly expensive, approach is to
close the inotify file descriptor, empty the cache, create a new inotify
file descriptor, and then re\-create watches and cache entries for the
objects to be monitored.)
.SS "rename() イベントの取り扱い"
As noted above, the \fBIN_MOVED_FROM\fP and \fBIN_MOVED_TO\fP event pair that is
generated by \fBrename\fP(2)  can be matched up via their shared cookie value.
However, the task of matching has some challenges.

These two events are usually consecutive in the event stream available when
reading from the inotify file descriptor.  However, this is not guaranteed.
If multiple processes are triggering events for monitored objects, then (on
rare occasions) an arbitrary number of other events may appear between the
\fBIN_MOVED_FROM\fP and \fBIN_MOVED_TO\fP events.

Matching up the \fBIN_MOVED_FROM\fP and \fBIN_MOVED_TO\fP event pair generated by
\fBrename\fP(2)  is thus inherently racy.  (Don't forget that if an object is
renamed outside of a monitored directory, there may not even be an
\fBIN_MOVED_TO\fP event.)  Heuristic approaches (e.g., assume the events are
always consecutive)  can be used to ensure a match in most cases, but will
inevitably miss some cases, causing the application to perceive the
\fBIN_MOVED_FROM\fP and \fBIN_MOVED_TO\fP events as being unrelated.  If watch
descriptors are destroyed and re\-created as a result, then those watch
descriptors will be inconsistent with the watch descriptors in any pending
events.  (Re\-creating the inotify file descriptor and rebuilding the cache
may be useful to deal with this scenario.)

Applications should also allow for the possibility that the \fBIN_MOVED_FROM\fP
event was the last event that could fit in the buffer returned by the
current call to \fBread\fP(2), and the accompanying \fBIN_MOVED_TO\fP event might
be fetched only on the next \fBread\fP(2).
.SH バグ
.\" FIXME kernel commit 611da04f7a31b2208e838be55a42c7a1310ae321
.\" implies that unmount events were buggy 2.6.11 to 2.6.36
.\"
2.6.16 以前のカーネルでは \fBIN_ONESHOT\fP \fImask\fP フラグが働かない。

As originally designed and implemented, the \fBIN_ONESHOT\fP flag did not cause
an \fBIN_IGNORED\fP event to be generated when the watch was dropped after one
event.  However, as an unintended effect of other changes, since Linux
2.6.36, an \fBIN_IGNORED\fP event is generated in this case.

.\" commit 1c17d18e3775485bf1e0ce79575eb637a94494a2
カーネル 2.6.25 より前では、 連続する同一のイベントを一つにまとめることを意図したコード (古い方のイベントがまだ読み込まれていない場合に、
最新の 2 つのイベントを一つにまとめられる可能性がある) が、 最新のイベントが「最も古い」読み込まれていないイベントとまとめられるか
をチェックするようになっていた。
.SH 関連項目
\fBinotifywait\fP(1), \fBinotifywatch\fP(1), \fBinotify_add_watch\fP(2),
\fBinotify_init\fP(2), \fBinotify_init1\fP(2), \fBinotify_rm_watch\fP(2), \fBread\fP(2),
\fBstat\fP(2)

Linux カーネルソース内の \fIDocumentation/filesystems/inotify.txt\fP
.SH この文書について
この man ページは Linux \fIman\-pages\fP プロジェクトのリリース 3.65 の一部
である。プロジェクトの説明とバグ報告に関する情報は
http://www.kernel.org/doc/man\-pages/ に書かれている。

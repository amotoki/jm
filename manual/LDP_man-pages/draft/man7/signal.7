'\" t
.\" Copyright (c) 1993 by Thomas Koenig (ig25@rz.uni-karlsruhe.de)
.\" and Copyright (c) 2002, 2006 by Michael Kerrisk <mtk.manpages@gmail.com>
.\" and Copyright (c) 2008 Linux Foundation, written by Michael Kerrisk
.\"     <mtk.manpages@gmail.com>
.\"
.\" Permission is granted to make and distribute verbatim copies of this
.\" manual provided the copyright notice and this permission notice are
.\" preserved on all copies.
.\"
.\" Permission is granted to copy and distribute modified versions of this
.\" manual under the conditions for verbatim copying, provided that the
.\" entire resulting derived work is distributed under the terms of a
.\" permission notice identical to this one.
.\"
.\" Since the Linux kernel and libraries are constantly changing, this
.\" manual page may be incorrect or out-of-date.  The author(s) assume no
.\" responsibility for errors or omissions, or for damages resulting from
.\" the use of the information contained herein.  The author(s) may not
.\" have taken the same level of care in the production of this manual,
.\" which is licensed free of charge, as they might when working
.\" professionally.
.\"
.\" Formatted or processed versions of this manual, if unaccompanied by
.\" the source, must acknowledge the copyright and authors of this work.
.\"
.\" Modified Sat Jul 24 17:34:08 1993 by Rik Faith (faith@cs.unc.edu)
.\" Modified Sun Jan  7 01:41:27 1996 by Andries Brouwer (aeb@cwi.nl)
.\" Modified Sun Apr 14 12:02:29 1996 by Andries Brouwer (aeb@cwi.nl)
.\" Modified Sat Nov 13 16:28:23 1999 by Andries Brouwer (aeb@cwi.nl)
.\" Modified 10 Apr 2002, by Michael Kerrisk <mtk.manpages@gmail.com>
.\" Modified  7 Jun 2002, by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Added information on real-time signals
.\" Modified 13 Jun 2002, by Michael Kerrisk <mtk.manpages@gmail.com>
.\"	Noted that SIGSTKFLT is in fact unused
.\" 2004-12-03, Modified mtk, added notes on RLIMIT_SIGPENDING
.\" 2006-04-24, mtk, Added text on changing signal dispositions,
.\"		signal mask, and pending signals.
.\" 2008-07-04, mtk:
.\"     Added section on system call restarting (SA_RESTART)
.\"     Added section on stop/cont signals interrupting syscalls.
.\" 2008-10-05, mtk: various additions
.\"
.\" Japanese Version Copyright (c) 1997 Takafumi Naka
.\"     and 2005-2008 Akihiro MOTOKI
.\"         all rights reserved.
.\" Translated 1997-02-13, Takafumi Naka <takafumi@yk.rim.or.jp>
.\" Modified 1999-06-22, Tatsuo SEKINE <tsekine@isoternet.org>
.\" Modified 1999-07-18, Takafumi Naka <takafumi@yk.rim.or.jp>
.\" Modified 1999-12-06, NAKANO Takeo <nakano@apm.seikei.ac.jp>, LDP v1.28
.\" Updated 2003-07-24, Kentaro Shirakata <argrath@ub32.org>
.\" Updated 2005-02-23, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>
.\" Updated 2006-07-28, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.36
.\" Updated 2007-05-28, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.50
.\" Updated 2007-09-08, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v2.64
.\" Updated 2008-08-11, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.05
.\" Updated 2008-11-21, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.13
.\" Updated 2010-04-10, Akihiro MOTOKI <amotoki@dd.iij4u.or.jp>, LDP v3.24
.\"
.\"WORD:	disposition	処理方法
.\"WORD:	pending		処理待ち
.\"WORD:	signal handler	シグナルハンドラ
.\"
.TH SIGNAL 7  2011-09-18 "Linux" "Linux Programmer's Manual"
.\"O .SH NAME
.\"O signal \- overview of signals
.SH 名前
signal \- シグナルの概要
.\"O .SH DESCRIPTION
.SH 説明
.\"O Linux supports both POSIX reliable signals (hereinafter
.\"O "standard signals") and POSIX real-time signals.
Linux は POSIX 信頼シグナル (reliable signal; 以後 "標準シグナル"と表記)
と POSIX リアルタイムシグナルの両方に対応している。
.\"O .SS "Signal Dispositions"
.SS シグナル処理方法
.\"O Each signal has a current
.\"O .IR disposition ,
.\"O which determines how the process behaves when it is delivered
.\"O the signal.
シグナルはそれぞれ現在の「処理方法 (disposition)」を保持しており、
この処理方法によりシグナルが配送された際にプロセスが
どのような振舞いをするかが決まる。

.\"O The entries in the "Action" column of the tables below specify
.\"O the default disposition for each signal, as follows:
後述の表の "動作" の欄のエントリは各シグナルのデフォルトの
処理方法を示しており、以下のような意味を持つ。
.IP Term
.\"O Default action is to terminate the process.
デフォルトの動作はプロセス終了。
.IP Ign
.\"O Default action is to ignore the signal.
デフォルトの動作はこのシグナルの無視。
.IP Core
.\"O Default action is to terminate the process and dump core (see
.\"O .BR core (5)).
デフォルトの動作はプロセス終了とコアダンプ出力
.RB ( core (5)
参照)。
.IP Stop
.\"O Default action is to stop the process.
デフォルトの動作はプロセスの一時停止。
.IP Cont
.\"O Default action is to continue the process if it is currently stopped.
デフォルトの動作は、プロセスが停止中の場合にその実行の再開。
.PP
.\"O A process can change the disposition of a signal using
.\"O .BR sigaction (2)
.\"O or
.\"O .BR signal (2).
.\"O (The latter is less portable when establishing a signal handler;
.\"O see
.\"O .BR signal (2)
.\"O for details.)
プロセスは、
.BR sigaction (2)
や
.BR signal (2)
を使って、シグナルの処理方法を変更することができる
.RB ( signal (2)
の方がシグナルハンドラを設定する際の移植性が低い;
詳細は
.BR signal (2)
を参照)。
.\"O Using these system calls, a process can elect one of the
.\"O following behaviors to occur on delivery of the signal:
.\"O perform the default action; ignore the signal;
.\"O or catch the signal with a
.\"O .IR "signal handler" ,
.\"O a programmer-defined function that is automatically invoked
.\"O when the signal is delivered.
.\"O (By default, the signal handler is invoked on the
.\"O normal process stack.
.\"O It is possible to arrange that the signal handler
.\"O uses an alternate stack; see
.\"O .BR sigaltstack (2)
.\"O for a discussion of how to do this and when it might be useful.)
シグナルの配送時に起こる動作として
プロセスが選択できるのは、次のいずれか一つである。
デフォルトの動作を実行する、シグナルを無視する、
.I "シグナルハンドラ (signal handler)"
でシグナルを捕捉する。シグナルハンドラとは、シグナル配送時に
自動的に起動されるプログラマ定義の関数である。
(デフォルトでは、シグナルハンドラは通常のプロセスのスタック上で起動される。
シグナルハンドラが代替スタック (alternate stack) を使用するように設定する
こともできる。代替スタックを使用するように設定する方法と、どのような際に
代替スタックが役に立つかについての議論については
.BR sigaltstack (2)
を参照のこと。

.\"O The signal disposition is a per-process attribute:
.\"O in a multithreaded application, the disposition of a
.\"O particular signal is the same for all threads.
シグナルの処理方法はプロセス単位の属性である。
マルチスレッドのアプリケーションでは、あるシグナルの処理方法は
全てのスレッドで同じである。

.\"O A child created via
.\"O .BR fork (2)
.\"O inherits a copy of its parent's signal dispositions.
.\"O During an
.\"O .BR execve (2),
.\"O the dispositions of handled signals are reset to the default;
.\"O the dispositions of ignored signals are left unchanged.
.BR fork (2)
で作成された子プロセスは親プロセスのシグナルの処理方法のコピーを継承する。
.BR execve (2)
の間、ハンドラが登録されているシグナルの処理方法はデフォルトにリセット
され、無視となっているシグナルの処理方法は変更されずそのままとなる。
.\"O .SS Sending a Signal
.SS シグナルの送信
.\"O The following system calls and library functions allow
.\"O the caller to send a signal:
以下のシステムコールとライブラリ関数を使って、
呼び出し者はシグナルを送信することができる。
.TP 16
.BR raise (3)
.\"O Sends a signal to the calling thread.
呼び出したスレッドにシグナルを送る。
.TP
.BR kill (2)
.\"O Sends a signal to a specified process,
.\"O to all members of a specified process group,
.\"O or to all processes on the system.
指定されたプロセスや、指定されたプロセスグループの全メンバー、
システムの全プロセスにシグナルを送る。
.TP
.BR killpg (2)
.\"O Sends a signal to all of the members of a specified process group.
指定されたプロセスグループの全メンバーにシグナルを送る。
.TP
.BR pthread_kill (3)
.\"O Sends a signal to a specified POSIX thread in the same process as
.\"O the caller.
呼び出し者と同じプロセス内の指定された POSIX スレッドにシグナルを送る。
.TP
.BR tgkill (2)
.\"O Sends a signal to a specified thread within a specific process.
.\"O (This is the system call used to implement
.\"O .BR pthread_kill (3).)
指定されたプロセス内の指定されたスレッドにシグナルを送る
(このシステムコールを使って
.BR pthread_kill (3)
は実装されている)。
.TP
.BR sigqueue (3)
.\"O Sends a real-time signal with accompanying data to a specified process.
指定されたプロセスに付属データとともにリアルタイムシグナルを送る。
.\"O .SS Waiting for a Signal to be Caught
.SS シグナルが捕捉されるのを待つ
.\"O The following system calls suspend execution of the calling process
.\"O or thread until a signal is caught
.\"O (or an unhandled signal terminates the process):
以下のシステムコールを使って、シグナルが捕捉されるまで
呼び出したプロセスやスレッドの実行を中断 (suspend) することができる
(ハンドラが設定されていないシグナルによりそのプロセスが終了した
場合にも実行の停止は終了する)。
.TP 16
.BR pause (2)
.\"O Suspends execution until any signal is caught.
何かシグナルが捕捉されるまで実行を停止する。
.TP
.BR sigsuspend (2)
.\"O Temporarily changes the signal mask (see below) and suspends
.\"O execution until one of the unmasked signals is caught.
一時的にシグナルマスク (下記参照) を変更し、
マスクされていないシグナルのいずれかが捕捉されるまで
実行を中断する。
.\"O .SS Synchronously Accepting a Signal
.SS シグナルの同期受信
.\"O Rather than asynchronously catching a signal via a signal handler,
.\"O it is possible to synchronously accept the signal, that is,
.\"O to block execution until the signal is delivered,
.\"O at which point the kernel returns information about the
.\"O signal to the caller.
.\"O There are two general ways to do this:
シグナルハンドラ経由でシグナルを非同期 (asynchronously) で捕捉する以外にも、
シグナルを同期 (synchronously) して受け付けることもできる。
同期して受け付けるとは、シグナルが配送されるまで実行を停止 (block)
するということである。シグナルを受け付けた際に、カーネルは
そのシグナルに関する情報を呼び出し者に返す。
これを行う一般的な方法が二つある。
.IP * 2
.\"O .BR sigwaitinfo (2),
.\"O .BR sigtimedwait (2),
.\"O and
.\"O .BR sigwait (3)
.\"O suspend execution until one of the signals in a specified
.\"O set is delivered.
.\"O Each of these calls returns information about the delivered signal.
.BR sigwaitinfo (2),
.BR sigtimedwait (2),
.BR sigwait (3)
は、指定されたシグナル集合のシグナルの一つが配送されるまで実行を中断する。
どのシステムコールや関数でも、配送されたシグナルに関する情報が返される。
.IP *
.\"O .BR signalfd (2)
.\"O returns a file descriptor that can be used to read information
.\"O about signals that are delivered to the caller.
.\"O Each
.\"O .BR read (2)
.\"O from this file descriptor blocks until one of the signals
.\"O in the set specified in the
.\"O .BR signalfd (2)
.\"O call is delivered to the caller.
.\"O The buffer returned by
.\"O .BR read (2)
.\"O contains a structure describing the signal.
.BR signalfd (2)
が返すファイルディスクリプタを使うと、呼び出し元に配送された
シグナルに関する情報を読み出すことができる。
このファイルディスクリプタからの
.BR read (2)
は、
.BR signalfd (2)
の呼び出し時に指定されたシグナル集合のシグナルの一つが呼び出し元に
配送されるまで停止 (block) する。
.BR read (2)
が返すバッファにはシグナルに関する情報を格納した構造体が入っている。
.\"O .SS "Signal Mask and Pending Signals"
.SS シグナルマスクと処理待ちシグナル
.\"O A signal may be
.\"O .IR blocked ,
.\"O which means that it will not be delivered until it is later unblocked.
.\"O Between the time when it is generated and when it is delivered
.\"O a signal is said to be
.\"O .IR pending .
シグナルは
.I "ブロック (block)"
されることがある。ブロックされると、そのシグナルは
その後ブロックを解除されるまで配送されなくなる。
シグナルが生成されてから配送されるまでの間、そのシグナルは
.I "処理待ち (pending)"
であると呼ばれる。

.\"O Each thread in a process has an independent
.\"O .IR "signal mask" ,
.\"O which indicates the set of signals that the thread is currently blocking.
.\"O A thread can manipulate its signal mask using
.\"O .BR pthread_sigmask (3).
.\"O In a traditional single-threaded application,
.\"O .BR sigprocmask (2)
.\"O can be used to manipulate the signal mask.
プロセス内の各スレッドは、それぞれ独立な
.I "シグナルマスク (signal mask)"
を持つ。シグナルマスクはそのスレッドが現在ブロックしている
シグナル集合を示すものである。
スレッドは、
.BR pthread_sigmask (3)
を使って自分のシグナルマスクを操作できる。
伝統的なシングルスレッドのアプリケーションでは、
.BR sigprocmask (2)
を使って、シグナルマスクを操作できる。

.\"O A child created via
.\"O .BR fork (2)
.\"O inherits a copy of its parent's signal mask;
.\"O the signal mask is preserved across
.\"O .BR execve (2).
.BR fork (2)
経由で作成された子プロセスは、
親プロセスのシグナルマスクのコピーを継承する。
.BR execve (2)
の前後でシグナルマスクは保持される。

.\"O A signal may be generated (and thus pending)
.\"O for a process as a whole (e.g., when sent using
.\"O .BR kill (2))
.\"O or for a specific thread (e.g., certain signals,
.\"O such as
.\"O .B SIGSEGV
.\"O and
.\"O .BR SIGFPE ,
.\"O generated as a
.\"O consequence of executing a specific machine-language instruction
.\"O are thread directed, as are signals targeted at a specific thread using
.\"O .BR pthread_kill (3)).
.\"O A process-directed signal may be delivered to any one of the
.\"O threads that does not currently have the signal blocked.
.\"O If more than one of the threads has the signal unblocked, then the
.\"O kernel chooses an arbitrary thread to which to deliver the signal.
生成されるシグナル (したがって処理待ちとなるシグナル) には、
プロセス全体宛てと特定のスレッド宛てがある。
例えば、プロセス全体宛てのシグナルは
.BR kill (2)
を使って送信される。
特定のマシン語の命令の実行の結果として生成される、
.B SIGSEGV
や
.B SIGFPE
などのシグナルは、スレッド宛てとなる。
また、
.BR pthread_kill (3)
を使って特定のスレッド宛てに生成されたシグナルも
スレッド宛てとなる。
プロセス宛てのシグナルは、そのシグナルをブロックしていないスレッドのうち
いずれかの一つに配送することができる。そのシグナルをブロックしていない
スレッドが複数ある場合、シグナルを配送するスレッドはカーネルが
無作為に選択する。

.\"O A thread can obtain the set of signals that it currently has pending
.\"O using
.\"O .BR sigpending (2).
.\"O This set will consist of the union of the set of pending
.\"O process-directed signals and the set of signals pending for
.\"O the calling thread.
スレッドは、
.BR sigpending (2)
を使って、現在処理待ちのシグナル集合を取得することができる。
この集合は、プロセス宛ての処理待ちシグナルと
呼び出したスレッド宛てのシグナルの両方から構成される。

.\"O A child created via
.\"O .BR fork (2)
.\"O initially has an empty pending signal set;
.\"O the pending signal set is preserved across an
.\"O .BR execve (2).
.BR fork (2)
経由で作成された子プロセスでは、処理待ちのシグナル集合は
空の集合で初期化される。
.BR execve (2)
の前後で、処理待ちのシグナル集合は保持される。
.\"O .SS "Standard Signals"
.SS 標準シグナル
.\"O Linux supports the standard signals listed below.
.\"O Several signal numbers
.\"O are architecture-dependent, as indicated in the "Value" column.
.\"O (Where three values are given, the first one is usually valid for
.\"O alpha and sparc,
.\"O the middle one for ix86, ia64, ppc, s390, arm and sh,
.\"O and the last one for mips.
Linux は以下に示す標準シグナルに対応している。
シグナル番号の一部はアーキテクチャ依存であり、"値" 欄に示す通りである。
(3つの値が書かれているものは、 1つ目が alpha と sparc で通常有効な値、
真ん中が ix86, ia64, ppc, s390, arm, sh での値、最後が mips での値である。
.\" parisc is a law unto itself
.\"O A \- denotes that a signal is absent on the corresponding architecture.)
\- はそのアーキテクチャにおいて対応するシグナルがないことを示す。)

.\"O First the signals described in the original POSIX.1-1990 standard.
最初に、POSIX.1-1990 に定義されているシグナルを示す。
.TS
l c c l
____
lB c c l.
.\"O Signal	Value	Action	Comment
シグナル	値	動作	コメント
.\"O SIGHUP	\01	Term	Hangup detected on controlling terminal
.\"O 			or death of controlling process
SIGHUP	\01	Term	T{
制御端末(controlling terminal)のハングアップ検出、
または制御しているプロセスの死
T}
.\"O SIGINT	\02	Term	Interrupt from keyboard
.\"O SIGQUIT	\03	Core	Quit from keyboard
.\"O SIGILL	\04	Core	Illegal Instruction
.\"O SIGABRT	\06	Core	Abort signal from \fBabort\fP(3)
.\"O SIGFPE	\08	Core	Floating point exception
.\"O SIGKILL	\09	Term	Kill signal
SIGINT	\02	Term	キーボードからの割り込み (Interrupt)
SIGQUIT	\03	Core	キーボードによる中止 (Quit)
SIGILL	\04	Core	不正な命令
SIGABRT	\06	Core	\fBabort\fP(3) からの中断 (Abort) シグナル
SIGFPE	\08	Core	浮動小数点例外
SIGKILL	\09	Term	Kill シグナル
.\"O SIGSEGV	11	Core	Invalid memory reference
.\"O SIGPIPE	13	Term	Broken pipe: write to pipe with no
.\"O 			readers
.\"O SIGALRM	14	Term	Timer signal from \fBalarm\fP(2)
.\"O SIGTERM	15	Term	Termination signal
SIGSEGV	11	Core	不正なメモリ参照
SIGPIPE	13	Term	パイプ破壊: 読み手の無いパイプへの書き出し
SIGALRM	14	Term	\fBalarm\fP(2) からのタイマーシグナル
SIGTERM	15	Term	終了 (termination) シグナル
.\"O SIGUSR1	30,10,16	Term	User-defined signal 1
.\"O SIGUSR2	31,12,17	Term	User-defined signal 2
.\"O SIGCHLD	20,17,18	Ign	Child stopped or terminated
.\"O SIGCONT	19,18,25	Cont	Continue if stopped
SIGUSR1	30,10,16	Term	ユーザ定義シグナル 1
SIGUSR2	31,12,17	Term	ユーザ定義シグナル 2
SIGCHLD	20,17,18	Ign	子プロセスの一時停止 (stop) または終了
SIGCONT	19,18,25	Cont	一時停止 (stop) からの再開
.\"O SIGSTOP	17,19,23	Stop	Stop process
.\"O SIGTSTP	18,20,24	Stop	Stop typed at tty
.\"O SIGTTIN	21,21,26	Stop	tty input for background process
.\"O SIGTTOU	22,22,27	Stop	tty output for background process
SIGSTOP	17,19,23	Stop	プロセスの一時停止 (stop)
SIGTSTP	18,20,24	Stop	端末 (tty) より入力された一時停止 (stop)
SIGTTIN	21,21,26	Stop	バックグランドプロセスの tty 入力
SIGTTOU	22,22,27	Stop	バックグランドプロセスの tty 出力
.TE

.\"O The signals
.\"O .B SIGKILL
.\"O and
.\"O .B SIGSTOP
.\"O cannot be caught, blocked, or ignored.
シグナル
.B SIGKILL
と
.B SIGSTOP
はキャッチ、ブロック、無視できない。

.\"O Next the signals not in the POSIX.1-1990 standard but described in
.\"O SUSv2 and POSIX.1-2001.
次に、 POSIX.1-1990 標準にはないが、 SUSv2 と
POSIX.1-2001 に記述されているシグナルを示す。
.TS
l c c l
____
lB c c l.
.\"O Signal	Value	Action	Comment
シグナル	値	動作	コメント
.\"O SIGBUS	10,7,10	Core	Bus error (bad memory access)
.\"O SIGPOLL		Term	Pollable event (Sys V).
.\"O 			Synonym for \fBSIGIO\fP
.\"O SIGPROF	27,27,29	Term	Profiling timer expired
SIGBUS	10,7,10	Core	バスエラー (不正なメモリアクセス)
SIGPOLL		Term	ポーリング可能なイベント (Sys V)。
			\fBSIGIO\fP と同義
SIGPROF	27,27,29	Term	profiling タイマの時間切れ
.\"O SIGSYS	12,31,12	Core	Bad argument to routine (SVr4)
.\"O SIGTRAP	5	Core	Trace/breakpoint trap
.\"O SIGURG	16,23,21	Ign	Urgent condition on socket (4.2BSD)
SIGSYS	12,31,12	Core	ルーチンへの引き数が不正 (SVr4)
SIGTRAP	5	Core	トレース/ブレークポイント トラップ
SIGURG	16,23,21	Ign	T{
ソケットの緊急事態 (urgent condition) (4.2BSD)
T}
.\"O SIGVTALRM	26,26,28	Term	Virtual alarm clock (4.2BSD)
.\"O SIGXCPU	24,24,30	Core	CPU time limit exceeded (4.2BSD)
.\"O SIGXFSZ	25,25,31	Core	File size limit exceeded (4.2BSD)
SIGVTALRM	26,26,28	Term	仮想アラームクロック (4.2BSD)
SIGXCPU	24,24,30	Core	CPU時間制限超過 (4.2BSD)
SIGXFSZ	25,25,31	Core	ファイルサイズ制限の超過 (4.2BSD)
.TE

.\"O Up to and including Linux 2.2, the default behavior for
.\"O .BR SIGSYS ", " SIGXCPU ", " SIGXFSZ ", "
.\"O and (on architectures other than SPARC and MIPS)
.\"O .B SIGBUS
.\"O was to terminate the process (without a core dump).
.\"O (On some other UNIX systems the default action for
.\"O .BR SIGXCPU " and " SIGXFSZ
.\"O is to terminate the process without a core dump.)
.\"O Linux 2.4 conforms to the POSIX.1-2001 requirements for these signals,
.\"O terminating the process with a core dump.
Linux 2.2 以前では、
.BR SIGSYS ", " SIGXCPU ", " SIGXFSZ
および SPARC と MIPS 以外のアーキテクチャでの
.B SIGBUS
のデフォルトの振る舞いは (コアダンプ出力なしの) プロセス終了であった。
(他の UNIX システムにも
.BR SIGXCPU " と " SIGXFSZ
のデフォルトの動作がコアダンプなしのプロセス終了のものがある。)
Linux 2.4 では、POSIX.1-2001 での要求仕様に準拠して、
これらのシグナルで、プロセスを終了させ、コアダンプを出力する
ようになっている。

.\"O Next various other signals.
次にその他の各種シグナルを示す。
.TS
l c c l
____
lB c c l.
.\"O Signal	Value	Action	Comment
シグナル	値	動作	コメント
.\"O SIGIOT	6	Core	IOT trap. A synonym for \fBSIGABRT\fP
.\"O SIGEMT	7,\-,7	Term
.\"O SIGSTKFLT	\-,16,\-	Term	Stack fault on coprocessor (unused)
.\"O SIGIO	23,29,22	Term	I/O now possible (4.2BSD)
.\"O SIGCLD	\-,\-,18	Ign	A synonym for \fBSIGCHLD\fP
SIGIOT	6	Core	IOT トラップ。\fBSIGABRT\fP と同義
SIGEMT	7,\-,7	Term
SIGSTKFLT	\-,16,\-	A	T{
数値演算プロセッサにおけるスタックフォルト (未使用)
T}
SIGIO	23,29,22	Term	入出力が可能になった (4.2BSD)
SIGCLD	\-,\-,18	Ign	\fBSIGCHLD\fP と同義
.\"O SIGPWR	29,30,19	Term	Power failure (System V)
.\"O SIGINFO	29,\-,\-		A synonym for \fBSIGPWR\fP
.\"O SIGLOST	\-,\-,\-	Term	File lock lost
.\"O SIGWINCH	28,28,20	Ign	Window resize signal (4.3BSD, Sun)
.\"O SIGUNUSED	\-,31,\-	Core	Synonymous with \fBSIGSYS\fP
SIGPWR	29,30,19	Term	電源喪失 (Power failure) (System V)
SIGINFO	29,\-,\-	 	\fBSIGPWR\fP と同義
SIGLOST	\-,\-,\-	Term	ファイルロックが失われた
SIGWINCH	28,28,20	Ign	T{
ウィンドウ リサイズ シグナル (4.3BSD, Sun)
T}
SIGUNUSED	\-,31,\-	Core	\fBSIGSYS\fP と同義
.TE

.\"O (Signal 29 is
.\"O .B SIGINFO
.\"O /
.\"O .B SIGPWR
.\"O on an alpha but
.\"O .B SIGLOST
.\"O on a sparc.)
(シグナル 29 は alpha では
.B SIGINFO
/
.B SIGPWR
だが、sparc では
.B SIGLOST
である。)

.\"O .B SIGEMT
.\"O is not specified in POSIX.1-2001, but nevertheless appears
.\"O on most other UNIX systems,
.\"O where its default action is typically to terminate
.\"O the process with a core dump.
.B SIGEMT
は POSIX.1-2001 に規定されていないが、
その他の多くの UNIX システムに存在する。
デフォルトの動作は多くの場合、コアダンプ出力を伴うプロセスの終了である。

.\"O .B SIGPWR
.\"O (which is not specified in POSIX.1-2001) is typically ignored
.\"O by default on those other UNIX systems where it appears.
.B SIGPWR
は (POSIX.1-2001 に規定されていないが) このシグナルが存在する
他の UNIX システムでは多くの場合、デフォルト動作は無視である。

.\"O .B SIGIO
.\"O (which is not specified in POSIX.1-2001) is ignored by default
.\"O on several other UNIX systems.
.B SIGIO
は (POSIX.1-2001 に規定されていないが) いくつかの他の UNIX システムでは
デフォルト動作は無視である。

.\"O Where defined,
.\"O .B SIGUNUSED
.\"O is synonymous with
.\"O .\" parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
.\"O .B SIGSYS
.\"O on most architectures.
.B SIGUNUSED
が定義されている場合には、ほとんどのアーキテクチャで
.B SIGSYS
の同義語となっている。
.\" parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
.\"O .SS "Real-time Signals"
.SS リアルタイムシグナル
.\"O Linux supports real-time signals as originally defined in the POSIX.1b
.\"O real-time extensions (and now included in POSIX.1-2001).
Linux はリアルタイムシグナルをサポートしている。
リアルタイムシグナルは元々 POSIX.1b のリアルタイム拡張で定義されて
いるものであり、現在では POSIX.1-2001 に含まれている。
.\"O The range of supported real-time signals is defined by the macros
.\"O .B SIGRTMIN
.\"O and
.\"O .BR SIGRTMAX .
.\"O POSIX.1-2001 requires that an implementation support at least
.\"O .B _POSIX_RTSIG_MAX
.\"O (8) real-time signals.
対応しているリアルタイムシグナルの範囲は、マクロ
.B SIGRTMIN
と
.B SIGRTMAX
で定義される。
POSIX.1-2001 では、少なくとも
.B _POSIX_RTSIG_MAX
(8) 個のリアルタイムシグナルに対応した実装が要求されている。
.PP
.\"O The Linux kernel supports a range of 32 different real-time
.\"O signals, numbered 33 to 64.
.\"O However, the glibc POSIX threads implementation internally uses
.\"O two (for NPTL) or three (for LinuxThreads) real-time signals
.\"O (see
.\"O .BR pthreads (7)),
.\"O and adjusts the value of
.\"O .B SIGRTMIN
.\"O suitably (to 34 or 35).
Linux は、32 個の異なるリアルタイムシグナルに対応しており、
その番号は 33 から 64 である。
しかしながら、glibc の POSIX スレッド実装は、
内部で 2個 (NPTL の場合) か 3個 (LinuxThreads の場合) の
リアルタイムシグナルを使用しており
.RB ( pthreads (7)
参照)、
.B SIGRTMIN
の値を適切に (34 か 35 に) 調整する。
.\"O Because the range of available real-time signals varies according
.\"O to the glibc threading implementation (and this variation can occur
.\"O at run time according to the available kernel and glibc),
.\"O and indeed the range of real-time signals varies across UNIX systems,
.\"O programs should
.\"O .IR "never refer to real-time signals using hard-coded numbers" ,
.\"O but instead should always refer to real-time signals using the notation
.\"O .BR SIGRTMIN +n,
.\"O and include suitable (run-time) checks that
.\"O .BR SIGRTMIN +n
.\"O does not exceed
.\"O .BR SIGRTMAX .
利用可能なリアルタイムシグナルの範囲は glibc のスレッド実装により
異なるし (使用するカーネルと glibc により実行時にも変化する)、
UNIX システムの種類によっても異なる。したがって、
プログラムでは「ハードコーディングした数字を使ってのリアルタイムシグナルの
参照は決してすべきではなく」、代わりに
.BR SIGRTMIN +n
の形で参照すべきである。また、
.BR SIGRTMIN +n
が
.B SIGRTMAX
を超えていないかのチェックを (実行時に) 適切に行うべきである。
.PP
.\"O Unlike standard signals, real-time signals have no predefined meanings:
.\"O the entire set of real-time signals can be used for application-defined
.\"O purposes.
標準シグナルと異なり、リアルタイムシグナルには
事前に定義された意味はない。
リアルタイムシグナルの全部をアプリケーションで定義した用途に使える。
.PP
.\"O The default action for an unhandled real-time signal is to terminate the
.\"O receiving process.
ハンドリングしないリアルタイムシグナルのデフォルトの動作は
受信したプロセスの終了である。
.PP
.\"O Real-time signals are distinguished by the following:
リアルタイムシグナルは以下の特徴がある:
.IP 1. 4
.\"O Multiple instances of real-time signals can be queued.
.\"O By contrast, if multiple instances of a standard signal are delivered
.\"O while that signal is currently blocked, then only one instance is queued.
リアルタイムシグナルは複数の実体をキューに入れることができる。
一方、標準シグナルの場合、そのシグナルがブロックされている間に
同じシグナルの複数のインスタンスが配送されても、
1 つだけがキューに入れられる。
.IP 2. 4
.\"O If the signal is sent using
.\"O .BR sigqueue (3),
.\"O an accompanying value (either an integer or a pointer) can be sent
.\"O with the signal.
シグナルが
.BR sigqueue (3)
を用いて送信された場合、
付属データ (整数かポインタ) をシグナルと共に送信できる。
.\"O If the receiving process establishes a handler for this signal using the
.\"O .B SA_SIGINFO
.\"O flag to
.\"O .BR sigaction (2)
.\"O then it can obtain this data via the
.\"O .I si_value
.\"O field of the
.\"O .I siginfo_t
.\"O structure passed as the second argument to the handler.
受信側プロセスが
.BR sigaction (2)
に
.B SA_SIGINFO
フラグを指定してシグナルハンドラを設定した場合、
このデータは
.I siginfo_t
構造体の
.I si_value
フィールド経由でハンドラの第 2 引き数として渡され、
利用することができる。
.\"O Furthermore, the
.\"O .I si_pid
.\"O and
.\"O .I si_uid
.\"O fields of this structure can be used to obtain the PID
.\"O and real user ID of the process sending the signal.
さらに、この構造体の
.I si_pid
と
.I si_uid
フィールドでシグナルを送信したプロセスの PID と実ユーザ ID を
得ることができる。
.IP 3. 4
.\"O Real-time signals are delivered in a guaranteed order.
.\"O Multiple real-time signals of the same type are delivered in the order
.\"O they were sent.
.\"O If different real-time signals are sent to a process, they are delivered
.\"O starting with the lowest-numbered signal.
.\"O (I.e., low-numbered signals have highest priority.)
.\"O By contrast, if multiple standard signals are pending for a process,
.\"O the order in which they are delivered is unspecified.
リアルタイムシグナルでは配送される順序が保証される。
同じタイプのリアルタイムシグナルは送信された順番に到着する。
異なるリアルタイムシグナルが一つのプロセスに送信された場合、
番号の小さいシグナルから先に到着する。
(つまり小さい番号のシグナルが高い優先順位を持つ。)
対照的に、一つのプロセスに対して複数の標準シグナルが処理待ちとなった場合、
これらのシグナルが配送される順序は不定である。
.PP
.\"O If both standard and real-time signals are pending for a process,
.\"O POSIX leaves it unspecified which is delivered first.
.\"O Linux, like many other implementations, gives priority
.\"O to standard signals in this case.
一つのプロセスに対して標準シグナルとリアルタイムシグナルの両方が
処理待ちの場合、POSIX はどちらが先に配送されるかを規定していない。
Linux では、他の多くの実装と同様、このような場合には
標準シグナルが優先される。
.PP
.\"O According to POSIX, an implementation should permit at least
.\"O .B _POSIX_SIGQUEUE_MAX
.\"O (32) real-time signals to be queued to
.\"O a process.
POSIX によれば、1 プロセス毎に最低
.B _POSIX_SIGQUEUE_MAX
(32) 個のリアルタイムシグナルをキューに入れられるべきとしている。
.\"O However, Linux does things differently.
.\"O In kernels up to and including 2.6.7, Linux imposes
.\"O a system-wide limit on the number of queued real-time signals
.\"O for all processes.
しかし、 Linux では違った実装になっている。カーネル 2.6.7 までは
(2.6.7 を含む)、全プロセスでキューに入っているリアルタイムシグナル
の数の合計についてシステム全体での制限がある。
.\"O This limit can be viewed and (with privilege) changed via the
.\"O .I /proc/sys/kernel/rtsig-max
.\"O file.
.\"O A related file,
.\"O .IR /proc/sys/kernel/rtsig-nr ,
.\"O can be used to find out how many real-time signals are currently queued.
この制限は
.I /proc/sys/kernel/rtsig-max
ファイルで見ることができ、 (権限があれば) 変更もできる。
関係するファイルとして、
.I /proc/sys/kernel/rtsig-nr
を見ることで、いくつのリアルタイムシグナルが現在キューに入っているかを
知ることができる。
.\"O In Linux 2.6.8, these
.\"O .I /proc
.\"O interfaces were replaced by the
.\"O .B RLIMIT_SIGPENDING
.\"O resource limit, which specifies a per-user limit for queued
.\"O signals; see
.\"O .BR setrlimit (2)
.\"O for further details.
Linux 2.6.8 で、これらの
.I /proc
経由のインターフェースは、
.B RLIMIT_SIGPENDING
リソース制限に置き換えられた。
これは、キューに入るシグナル数に関してユーザ単位に
上限を指定するものである。
詳しくは
.BR setrlimit (2)
を参照。
.\"O .SS "Async-signal-safe functions"
.SS "非同期シグナルで安全な関数 (async-signal-safe functions)"
.PP
.\"O A signal handler function must be very careful,
.\"O since processing elsewhere may be interrupted
.\"O at some arbitrary point in the execution of the program.
.\"O POSIX has the concept of "safe function".
.\"O If a signal interrupts the execution of an unsafe function, and
.\"O .I handler
.\"O calls an unsafe function, then the behavior of the program is undefined.
シグナルハンドラ関数には非常に注意しなければならない。
他の場所の処理はプログラム実行の任意の箇所で中断される可能性があるためである。
POSIX には「安全な関数 (safe function)」という概念がある。
シグナルが安全でない関数の実行を中断し、かつ
.I handler
が安全でない関数を呼び出した場合、プログラムの挙動は未定義である。

.\"O POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)
.\"O requires an implementation to guarantee that the following
.\"O functions can be safely called inside a signal handler:
POSIX.1-2004 (POSIX.1-2001 Technical Corrigendum (正誤表) 2 とも言う) では、
シグナルハンドラ内での安全な呼び出しを保証することが必須の関数として
以下が規定されている。

.in +4
.nf
_Exit()
_exit()
abort()
accept()
access()
aio_error()
aio_return()
aio_suspend()
alarm()
bind()
cfgetispeed()
cfgetospeed()
cfsetispeed()
cfsetospeed()
chdir()
chmod()
chown()
clock_gettime()
close()
connect()
creat()
dup()
dup2()
execle()
execve()
fchmod()
fchown()
fcntl()
fdatasync()
fork()
fpathconf()
fstat()
fsync()
ftruncate()
getegid()
geteuid()
getgid()
getgroups()
getpeername()
getpgrp()
getpid()
getppid()
getsockname()
getsockopt()
getuid()
kill()
link()
listen()
lseek()
lstat()
mkdir()
mkfifo()
open()
pathconf()
pause()
pipe()
poll()
posix_trace_event()
pselect()
raise()
read()
readlink()
recv()
recvfrom()
recvmsg()
rename()
rmdir()
select()
sem_post()
send()
sendmsg()
sendto()
setgid()
setpgid()
setsid()
setsockopt()
setuid()
shutdown()
sigaction()
sigaddset()
sigdelset()
sigemptyset()
sigfillset()
sigismember()
signal()
sigpause()
sigpending()
sigprocmask()
sigqueue()
sigset()
sigsuspend()
sleep()
sockatmark()
socket()
socketpair()
stat()
symlink()
sysconf()
tcdrain()
tcflow()
tcflush()
tcgetattr()
tcgetpgrp()
tcsendbreak()
tcsetattr()
tcsetpgrp()
time()
timer_getoverrun()
timer_gettime()
timer_settime()
times()
umask()
uname()
unlink()
utime()
wait()
waitpid()
write()
.fi
.in
.PP
.\"O POSIX.1-2008 removes fpathconf(), pathconf(), and sysconf()
.\"O from the above list, and adds the following functions:
POSIX.1-2008 では、上記のリストのうち fpathconf(), pathconf(), sysconf()
が削除され、以下の関数が追加された。
.PP
.in +4n
.nf
execl()
execv()
faccessat()
fchmodat()
fchownat()
fexecve()
fstatat()
futimens()
linkat()
mkdirat()
mkfifoat()
mknod()
mknodat()
openat()
readlinkat()
renameat()
symlinkat()
unlinkat()
utimensat()
utimes()
.fi
.in
.\"O .SS Interruption of System Calls and Library Functions by Signal Handlers
.SS シグナルハンドラによるシステムコールやライブラリ関数への割り込み
.\"O If a signal handler is invoked while a system call or library
.\"O function call is blocked, then either:
システムコールやライブラリが停止 (block) している間にシグナルハンドラが
起動されると、以下のどちらかとなる。
.IP * 2
.\"O the call is automatically restarted after the signal handler returns; or
シグナルが返った後、呼び出しは自動的に再スタートされる。
.IP *
.\"O the call fails with the error
.\"O .BR EINTR .
呼び出しはエラー
.B EINTR
で失敗する。
.PP
.\"O Which of these two behaviors occurs depends on the interface and
.\"O whether or not the signal handler was established using the
.\"O .BR SA_RESTART
.\"O flag (see
.\"O .BR sigaction (2)).
.\"O The details vary across UNIX systems;
.\"O below, the details for Linux.
これらの二つの挙動のうちどちらが起こるかは、インターフェイスにより依存し、
シグナルハンドラが
.B SA_RESTART
フラグ
.RB ( sigaction (2)
参照) を使って設定されていたかにも依存する。
詳細は UNIX システムによって異なる。
Linux における詳細を以下で説明する。

.\"O If a blocked call to one of the following interfaces is interrupted
.\"O by a signal handler, then the call will be automatically restarted
.\"O after the signal handler returns if the
.\"O .BR SA_RESTART
.\"O flag was used; otherwise the call will fail with the error
.\"O .BR EINTR :
.\"O .\" The following system calls use ERESTARTSYS,
.\"O .\" so that they are restartable
以下のインターフェイスのいずれかの呼び出しが停止している間に
シグナルハンドラにより割り込まれた場合、
.B SA_RESTART
フラグが使用されていれば、シグナルハンドラが返った後に
その呼び出しは自動的に再スタートされることになる。
それ以外の場合は、その呼び出しはエラー
.B EINTR
で失敗することになる。
.\" 以下のシステムコールは ERESTARTSYS を使っている。
.\" そのため、これらは再スタートが可能である。
.RS 4
.IP * 2
.\"O .BR read (2),
.\"O .BR readv (2),
.\"O .BR write (2),
.\"O .BR writev (2),
.\"O and
.\"O .BR ioctl (2)
.\"O calls on "slow" devices.
.\"O A "slow" device is one where the I/O call may block for an
.\"O indefinite time, for example, a terminal, pipe, or socket.
.\"O (A disk is not a slow device according to this definition.)
.\"O If an I/O call on a slow device has already transferred some
.\"O data by the time it is interrupted by a signal handler,
.\"O then the call will return a success status
.\"O (normally, the number of bytes transferred).
.BR read (2),
.BR readv (2),
.BR write (2),
.BR writev (2),
.BR ioctl (2)
の「遅い (slow)」デバイスに対する呼び出し。
ここでいう「遅い」デバイスとは、I/O 呼び出しが無期限に停止 (block) する
可能性のあるデバイスのことで、例としては端末、パイプ、ソケットがある
(この定義では、ディスクは遅いデバイスではない)。
遅いデバイスに対する I/O 呼び出しが、
シグナルハンドラにより割り込まれた時点までに何らかのデータを
すでに転送していれば、呼び出しは成功ステータス
(通常は、転送されたバイト数) を返すことだろう。
.IP *
.\"O .BR open (2),
.\"O if it can block (e.g., when opening a FIFO; see
.\"O .BR fifo (7)).
停止 (block) する可能性のある
.BR open (2)
(例えば、FIFO のオープン時;
.BR fifo (7)
参照)。
.IP *
.\"O .BR wait (2),
.\"O .BR wait3 (2),
.\"O .BR wait4 (2),
.\"O .BR waitid (2),
.\"O and
.\"O .BR waitpid (2).
.BR wait (2),
.BR wait3 (2),
.BR wait4 (2),
.BR waitid (2),
.BR waitpid (2).
.IP *
.\"O Socket interfaces:
ソケットインターフェイス:
.\" If a timeout (setsockopt()) is in effect on the socket, then these
.\" system calls switch to using EINTR.  Consequently, they and are not
.\" automatically restarted, and they show the stop/cont behavior
.\" described below.  (Verified from 2.6.26 source, and by experiment; mtk)
.\"O .BR accept (2),
.\"O .BR connect (2),
.\"O .BR recv (2),
.\"O .BR recvfrom (2),
.\"O .BR recvmsg (2),
.\"O .BR send (2),
.\"O .BR sendto (2),
.\"O and
.\"O .BR sendmsg (2),
.\"O unless a timeout has been set on the socket (see below).
.BR accept (2),
.BR connect (2),
.BR recv (2),
.BR recvfrom (2),
.BR recvmsg (2),
.BR send (2),
.BR sendto (2),
.BR sendmsg (2).
但し、ソケットにタイムアウトが設定されていない場合 (下記参照)。
.IP *
.\"O File locking interfaces:
ファイルロック用インターフェイス:
.\"O .BR flock (2)
.\"O and
.\"O .BR fcntl (2)
.\"O .BR F_SETLKW .
.BR flock (2),
.BR fcntl (2)
.BR F_SETLKW .
.IP *
.\"O POSIX message queue interfaces:
POSIX メッセージキューインターフェイス:
.BR mq_receive (3),
.BR mq_timedreceive (3),
.BR mq_send (3),
.\"O and
.BR mq_timedsend (3).
.IP *
.BR futex (2)
.B FUTEX_WAIT
.\"O (since Linux 2.6.22; beforehand, always failed with
.\"O .BR EINTR ).
(Linux 2.6.22 以降; それ以前は常に
.B EINTR
で失敗していた)。
.IP *
.\"O POSIX semaphore interfaces:
POSIX セマフォインターフェイス:
.\"O .BR sem_wait (3)
.\"O and
.\"O .BR sem_timedwait (3)
.\"O (since Linux 2.6.22; beforehand, always failed with
.\"O .BR EINTR ).
.BR sem_wait (3),
.BR sem_timedwait (3)
(Linux 2.6.22 以降; それ以前は常に
.B EINTR
で失敗していた)。
.RE
.PP
.\"O The following interfaces are never restarted after
.\"O being interrupted by a signal handler,
.\"O regardless of the use of
.\"O .BR SA_RESTART ;
.\"O they always fail with the error
.\"O .B EINTR
.\"O when interrupted by a signal handler:
.\"O .\" These are the system calls that give EINTR or ERESTARTNOHAND
.\"O .\" on interruption by a signal handler.
以下のインターフェイスは、
.B SA_RESTART
を使っているどうかに関わらず、シグナルハンドラにより割り込まれた後、
再スタートすることは決してない。
これらは、シグナルハンドラにより割り込まれると、常にエラー
.B EINTR
で失敗する。
.\" これらは、シグナルハンドラによる割り込みの際に
.\" EINTR か ERESTARTNOHAND を返すシステムコールである。
.RS 4
.IP * 2
.\"O Socket interfaces, when a timeout has been set on the socket using
.\"O .BR setsockopt (2):
.\"O .BR accept (2),
.\"O .BR recv (2),
.\"O .BR recvfrom (2),
.\"O and
.\"O .BR recvmsg (2),
.\"O if a receive timeout
.\"O .RB ( SO_RCVTIMEO )
.\"O has been set;
.\"O .BR connect (2),
.\"O .BR send (2),
.\"O .BR sendto (2),
.\"O and
.\"O .BR sendmsg (2),
.\"O if a send timeout
.\"O .RB ( SO_SNDTIMEO )
.\"O has been set.
.BR setsockopt (2)
を使ってタイムアウトが設定されているソケットインターフェース:
.BR accept (2),
.BR recv (2),
.BR recvfrom (2),
.BR recvmsg (2)
で受信タイムアウト
.RB ( SO_RCVTIMEO )
が設定されている場合と、
.BR connect (2),
.BR send (2),
.BR sendto (2),
.BR sendmsg (2)
で送信タイムアウト
.RB ( SO_SNDTIMEO )
が設定されている場合。
.IP *
.\"O Interfaces used to wait for signals:
シグナル待ちに使われるインターフェイス:
.BR pause (2),
.BR sigsuspend (2),
.BR sigtimedwait (2),
.\"O and
.BR sigwaitinfo (2).
.IP *
.\"O File descriptor multiplexing interfaces:
ファイルディスクリプタ多重インターフェイス:
.BR epoll_wait (2),
.BR epoll_pwait (2),
.BR poll (2),
.BR ppoll (2),
.BR select (2),
.\"O and
.BR pselect (2).
.IP *
.\"O System V IPC interfaces:
System V IPC インターフェイス:
.\" On some other systems, SA_RESTART does restart these system calls
.BR msgrcv (2),
.BR msgsnd (2),
.BR semop (2),
.\"O and
.BR semtimedop (2).
.IP *
.\"O Sleep interfaces:
スリープ用のインターフェイス:
.BR clock_nanosleep (2),
.BR nanosleep (2),
.\"O and
.BR usleep (3).
.IP *
.\"O .BR read (2)
.\"O from an
.\"O .BR inotify (7)
.\"O file descriptor.
.BR inotify (7)
ファイルディスクリプタからの
.BR read (2).
.IP *
.BR io_getevents (2).
.RE
.PP
.\"O The
.\"O .BR sleep (3)
.\"O function is also never restarted if interrupted by a handler,
.\"O but gives a success return: the number of seconds remaining to sleep.
.BR sleep (3)
関数も、ハンドラにより割り込まれた場合、決して再スタートされることはない。
しかし、成功となり、残っている停止時間を返す。
.\"O .SS Interruption of System Calls and Library Functions by Stop Signals
.SS 一時停止シグナルによるシステムコールやライブラリ関数への割り込み
.\"O On Linux, even in the absence of signal handlers,
.\"O certain blocking interfaces can fail with the error
.\"O .BR EINTR
.\"O after the process is stopped by one of the stop signals
.\"O and then resumed via
.\"O .BR SIGCONT .
.\"O This behavior is not sanctioned by POSIX.1, and doesn't occur
.\"O on other systems.
Linux では、シグナルハンドラが設定されていない場合でも、
いくつかのブロッキング型のインターフェイスは、
プロセスが一時停止 (stop) シグナルの一つにより停止され、
.B SIGCONT
により再開された後に、エラー
.B EINTR
で失敗する可能性がある。
この挙動は POSIX.1 で認められておらず、他のシステムでは起こらない。

.\"O The Linux interfaces that display this behavior are:
この挙動を示す Linux のインターフェイスは以下の通りである。
.RS 4
.IP * 2
.\"O Socket interfaces, when a timeout has been set on the socket using
.\"O .BR setsockopt (2):
.\"O .BR accept (2),
.\"O .BR recv (2),
.\"O .BR recvfrom (2),
.\"O and
.\"O .BR recvmsg (2),
.\"O if a receive timeout
.\"O .RB ( SO_RCVTIMEO )
.\"O has been set;
.\"O .BR connect (2),
.\"O .BR send (2),
.\"O .BR sendto (2),
.\"O and
.\"O .BR sendmsg (2),
.\"O if a send timeout
.\"O .RB ( SO_SNDTIMEO )
.\"O has been set.
.BR setsockopt (2)
を使ってタイムアウトが設定されているソケットインターフェース:
.BR accept (2),
.BR recv (2),
.BR recvfrom (2),
.BR recvmsg (2)
で受信タイムアウト
.RB ( SO_RCVTIMEO )
が設定されている場合と、
.BR connect (2),
.BR send (2),
.BR sendto (2),
.BR sendmsg (2)
で送信タイムアウト
.RB ( SO_SNDTIMEO )
が設定されている場合。
.IP * 2
.BR epoll_wait (2),
.BR epoll_pwait (2).
.IP *
.BR semop (2),
.BR semtimedop (2).
.IP *
.BR sigtimedwait (2),
.BR sigwaitinfo (2).
.IP *
.\"O .BR read (2)
.\"O from an
.\"O .BR inotify (7)
.\"O file descriptor.
.BR inotify (7)
ファイルディスクリプタからの
.BR read (2).
.IP *
.\"O Linux 2.6.21 and earlier:
Linux 2.6.21 以前:
.BR futex (2)
.BR FUTEX_WAIT ,
.BR sem_timedwait (3),
.BR sem_wait (3).
.IP *
.\"O Linux 2.6.8 and earlier:
Linux 2.6.8 以前:
.BR msgrcv (2),
.BR msgsnd (2).
.IP *
.\"O Linux 2.4 and earlier:
Linux 2.4 以前:
.BR nanosleep (2).
.RE
.\"O .SH "CONFORMING TO"
.SH 準拠
.\"O POSIX.1, except as noted.
POSIX.1 (注記した内容以外)。
.\"O .SH BUGS
.SH バグ
.\"O .B SIGIO
.\"O and
.\"O .B SIGLOST
.\"O have the same value.
.\"O The latter is commented out in the kernel source, but
.\"O the build process of some software still thinks that
.\"O signal 29 is
.\"O .BR SIGLOST .
.B SIGIO
と
.B SIGLOST
は同じ値を持っている。
.B SIGLOST
はカーネルのソースではコメントアウトされている。
しかし、ソフトウェアによってはビルドの過程でシグナル 29 を
.B SIGLOST
とみなしてしまうものがある。
.\"O .SH "SEE ALSO"
.SH 関連項目
.BR kill (1),
.BR getrlimit (2),
.BR kill (2),
.BR killpg (2),
.BR rt_sigqueueinfo (2),
.BR setitimer (2),
.BR setrlimit (2),
.BR sgetmask (2),
.BR sigaction (2),
.BR sigaltstack (2),
.BR signal (2),
.BR signalfd (2),
.BR sigpending (2),
.BR sigprocmask (2),
.BR sigsuspend (2),
.BR sigwaitinfo (2),
.BR abort (3),
.BR bsd_signal (3),
.BR longjmp (3),
.BR raise (3),
.BR pthread_sigqueue (3),
.BR sigqueue (3),
.BR sigset (3),
.BR sigsetops (3),
.BR sigvec (3),
.BR sigwait (3),
.BR strsignal (3),
.BR sysv_signal (3),
.BR core (5),
.BR proc (5),
.BR pthreads (7),
.BR sigevent (7)

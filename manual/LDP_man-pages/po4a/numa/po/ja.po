# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-19 23:50+0900\n"
"PO-Revision-Date: 2012-03-22 00:35+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/get_mempolicy.2:25
#, no-wrap
msgid "GET_MEMPOLICY"
msgstr "GET_MEMPOLICY"

#. type: TH
#: build/C/man2/get_mempolicy.2:25 build/C/man2/mbind.2:25
#: build/C/man7/numa.7:27 build/C/man2/set_mempolicy.2:25
#, no-wrap
msgid "2008-08-15"
msgstr "2008-08-15"

#. type: TH
#: build/C/man2/get_mempolicy.2:25 build/C/man2/getcpu.2:7
#: build/C/man2/mbind.2:25 build/C/man2/migrate_pages.2:17
#: build/C/man2/move_pages.2:18 build/C/man7/numa.7:27
#: build/C/man2/set_mempolicy.2:25
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/get_mempolicy.2:25 build/C/man2/getcpu.2:7
#: build/C/man2/mbind.2:25 build/C/man2/migrate_pages.2:17
#: build/C/man2/move_pages.2:18 build/C/man7/numa.7:27
#: build/C/man2/set_mempolicy.2:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/get_mempolicy.2:26 build/C/man2/getcpu.2:8
#: build/C/man2/mbind.2:26 build/C/man2/migrate_pages.2:18
#: build/C/man2/move_pages.2:19 build/C/man7/numa.7:28
#: build/C/man2/set_mempolicy.2:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:28
msgid "get_mempolicy - Retrieve NUMA memory policy for a process"
msgstr "get_mempolicy - プロセスの NUMA メモリのポリシーを取得する"

#. type: SH
#: build/C/man2/get_mempolicy.2:28 build/C/man2/getcpu.2:10
#: build/C/man2/mbind.2:28 build/C/man2/migrate_pages.2:20
#: build/C/man2/move_pages.2:21 build/C/man2/set_mempolicy.2:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:30
msgid "B<#include E<lt>numaif.hE<gt>>"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:35
#, no-wrap
msgid ""
"B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, unsigned long >I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"
msgstr ""
"B<int get_mempolicy(int *>I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<, unsigned long >I<addr>B<,>\n"
"B<                  unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:37 build/C/man2/mbind.2:37
#: build/C/man2/set_mempolicy.2:36
#, no-wrap
msgid "Link with I<-lnuma>.\n"
msgstr "I<-lnuma> でリンクする。\n"

#. type: SH
#: build/C/man2/get_mempolicy.2:38 build/C/man2/getcpu.2:17
#: build/C/man2/mbind.2:38 build/C/man2/migrate_pages.2:30
#: build/C/man2/move_pages.2:30 build/C/man7/numa.7:30
#: build/C/man2/set_mempolicy.2:37
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:43
msgid ""
"B<get_mempolicy>()  retrieves the NUMA policy of the calling process or of a "
"memory address, depending on the setting of I<flags>."
msgstr ""
"B<get_mempolicy>()  は、呼び出し元プロセスもしくは指定されたメモリアドレスの "
"NUMA ポリシーを I<flags> の設定に従って取得する。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:48 build/C/man2/set_mempolicy.2:52
msgid ""
"A NUMA machine has different memory controllers with different distances to "
"specific CPUs.  The memory policy defines from which node memory is "
"allocated for the process."
msgstr ""
"NUMA (非対称メモリアクセス) マシンでは、CPU により メモリコントローラが異な"
"り、距離も異なっている。 メモリポリシーは、どのノードからメモリをそのプロセス"
"に 割り当てるかを定めるものである。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:65
msgid ""
"If I<flags> is specified as 0, then information about the calling process's "
"default policy (as set by B<set_mempolicy>(2))  is returned.  The policy "
"returned [I<mode> and I<nodemask>] may be used to restore the process's "
"policy to its state at the time of the call to B<get_mempolicy>()  using "
"B<set_mempolicy>(2)."
msgstr ""
"I<flags> に 0 が指定された場合、 (B<set_mempolicy>(2)  で設定された)  呼び出"
"し元プロセスのデフォルトポリシーに関する情報を返す。 返されたポリシー "
"[I<mode> と I<nodemask>] を B<set_mempolicy>(2)  に渡すことで、そのプロセスの"
"ポリシーを B<get_mempolicy>()  を呼び出した時点の状態に戻すことができる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:87
msgid ""
"If I<flags> specifies B<MPOL_F_MEMS_ALLOWED> (available since Linux 2.6.24), "
"the I<mode> argument is ignored and the set of nodes [memories] that the "
"process is allowed to specify in subsequent calls to B<mbind>(2)  or "
"B<set_mempolicy>(2)  [in the absence of any I<mode flags>] is returned in "
"I<nodemask>.  It is not permitted to combine B<MPOL_F_MEMS_ALLOWED> with "
"either B<MPOL_F_ADDR> or B<MPOL_F_NODE>."
msgstr ""
"I<flags> に B<MPOL_F_MEMS_ALLOWED> (Linux 2.6.24 以降で利用可能) を指定する"
"と、 I<mode> 引き数は無視され、 そのプロセスがその後の B<mbind>(2)  や "
"B<set_mempolicy>(2)  で [I<モードフラグ> が指定されていない場合に ] 指定でき"
"るノード (メモリ) の集合が I<nodemask> に返される。 B<MPOL_F_MEMS_ALLOWED> "
"を、 B<MPOL_F_ADDR> や B<MPOL_F_NODE> と同時に指定することはできない。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:101
msgid ""
"If I<flags> specifies B<MPOL_F_ADDR>, then information is returned about the "
"policy governing the memory address given in I<addr>.  This policy may be "
"different from the process's default policy if B<mbind>(2)  or one of the "
"helper functions described in B<numa>(3)  has been used to establish a "
"policy for the memory range containing I<addr>."
msgstr ""
"I<flags> に B<MPOL_F_ADDR> が指定された場合、 I<addr> で指定されたメモリアド"
"レスに適用されているポリシーに関する情報を返す。 B<mbind>(2)  や B<numa>(3)  "
"で説明されているヘルパー関数を使って、 I<addr> を含むメモリ領域に対するポリ"
"シーが設定されていた場合には、 返されるポリシーはプロセスのデフォルトポリシー"
"と違うことがある。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:122
msgid ""
"If the I<mode> argument is not NULL, then B<get_mempolicy>()  will store the "
"policy mode and any optional I<mode flags> of the requested NUMA policy in "
"the location pointed to by this argument.  If I<nodemask> is not NULL, then "
"the nodemask associated with the policy will be stored in the location "
"pointed to by this argument.  I<maxnode> specifies the number of node IDs "
"that can be stored into I<nodemask>\\(emthat is, the maximum node ID plus "
"one.  The value specified by I<maxnode> is always rounded to a multiple of "
"I<sizeof(unsigned long)>."
msgstr ""
"I<mode> 引き数が NULL でない場合、 B<get_mempolicy>()  は要求された NUMA ポリ"
"シーのモードと追加の I<モードフラグ> を I<mode> が指す場所に格納する。 "
"I<nodemask> が NULL 以外の場合、そのポリシーに対応するノードマスクを この引き"
"数が指す場所に格納する。 I<maxnode> には I<nodemask> に格納できるノード ID の"
"数、つまり最大ノード ID に 1 を足した値を指定する。 I<maxnode> で指定された値"
"は常に I<sizeof(unsigned long)> の倍数に切り上げられる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:139
msgid ""
"If I<flags> specifies both B<MPOL_F_NODE> and B<MPOL_F_ADDR>, "
"B<get_mempolicy>()  will return the node ID of the node on which the address "
"I<addr> is allocated into the location pointed to by I<mode>.  If no page "
"has yet been allocated for the specified address, B<get_mempolicy>()  will "
"allocate a page as if the process had performed a read [load] access to that "
"address, and return the ID of the node where that page was allocated."
msgstr ""
"I<flags> で B<MPOL_F_NODE> と B<MPOL_F_ADDR> の両方が指定された場合、 "
"B<get_mempolicy>()  はアドレス I<addr> が割り当てられているノードのノード ID "
"を I<mode> が指す場所に入れて返す。 指定されたアドレスにどのページもまだ割り"
"当てられていない場合、 B<get_mempolicy>()  は、あたかもそのプロセスがそのアド"
"レスに対して読み込みアクセスを 実行したかのようにページの割り当てを行い、ペー"
"ジが割り当てられた ノードの ID を返す。"

#.  Note:  code returns next interleave node via 'mode' argument -Lee Schermerhorn
#. type: Plain text
#: build/C/man2/get_mempolicy.2:164
msgid ""
"If I<flags> specifies B<MPOL_F_NODE>, but not B<MPOL_F_ADDR>, and the "
"process's current policy is B<MPOL_INTERLEAVE>, then B<get_mempolicy>()  "
"will return in the location pointed to by a non-NULL I<mode> argument, the "
"node ID of the next node that will be used for interleaving of internal "
"kernel pages allocated on behalf of the process.  These allocations include "
"pages for memory mapped files in process memory ranges mapped using the "
"B<mmap>(2)  call with the B<MAP_PRIVATE> flag for read accesses, and in "
"memory ranges mapped with the B<MAP_SHARED> flag for all accesses."
msgstr ""
"I<flags> で B<MPOL_F_NODE> は指定されたが、 B<MPOL_F_ADDR> は指定されていない"
"場合で、かつ そのプロセスの現在のポリシーが B<MPOL_INTERLEAVE> の場合、 "
"B<get_mempolicy>()  は、そのプロセスに対して割り当てられたカーネルの内部ペー"
"ジで 次にインターリーブ用に使用されるノードのノード ID を、 NULL でない "
"I<mode> 引き数が指す場所に入れて返す。 読み込みアクセス用として "
"B<MAP_PRIVATE> フラグ付きで B<mmap>(2)  したプロセスメモリ領域や、 任意のアク"
"セス用として B<MAP_SHARED> フラグ付きで B<mmap>(2)  したメモリ領域の、メモリ"
"マップされたファイルに対するページも 上記のプロセスに対して割り当てられたペー"
"ジに含まれる。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:166
msgid "Other flag values are reserved."
msgstr "他のフラグは予約されている。"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:169
msgid "For an overview of the possible policies see B<set_mempolicy>(2)."
msgstr "設定可能なポリシーの概要については B<set_mempolicy>(2)  を参照。"

#. type: SH
#: build/C/man2/get_mempolicy.2:169 build/C/man2/mbind.2:289
#: build/C/man2/migrate_pages.2:87 build/C/man2/move_pages.2:141
#: build/C/man2/set_mempolicy.2:218
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:176
msgid ""
"On success, B<get_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<get_mempolicy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: SH
#: build/C/man2/get_mempolicy.2:176 build/C/man2/mbind.2:297
#: build/C/man2/migrate_pages.2:94 build/C/man2/move_pages.2:150
#: build/C/man2/set_mempolicy.2:225
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/get_mempolicy.2:177 build/C/man2/mbind.2:299
#: build/C/man2/move_pages.2:159 build/C/man2/set_mempolicy.2:226
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:184 build/C/man2/set_mempolicy.2:233
msgid ""
"Part of all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space."
msgstr ""
"I<nodemask> と I<maxnode> で指定されたメモリ領域の一部または全部が、 呼び出し"
"元がアクセス可能なアドレス空間外を指している。"

#. type: TP
#: build/C/man2/get_mempolicy.2:184 build/C/man2/mbind.2:307
#: build/C/man2/move_pages.2:162 build/C/man2/set_mempolicy.2:233
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:228
msgid ""
"The value specified by I<maxnode> is less than the number of node IDs "
"supported by the system.  Or I<flags> specified values other than "
"B<MPOL_F_NODE> or B<MPOL_F_ADDR>; or I<flags> specified B<MPOL_F_ADDR> and "
"I<addr> is NULL, or I<flags> did not specify B<MPOL_F_ADDR> and I<addr> is "
"not NULL.  Or, I<flags> specified B<MPOL_F_NODE> but not B<MPOL_F_ADDR> and "
"the current process policy is not B<MPOL_INTERLEAVE>.  Or, I<flags> "
"specified B<MPOL_F_MEMS_ALLOWED> with either B<MPOL_F_ADDR> or "
"B<MPOL_F_NODE>.  (And there are other B<EINVAL> cases.)"
msgstr ""
"I<maxnode> で指定された値がシステムがサポートするノード ID の数よりも少な"
"い。 または、 I<flags> に B<MPOL_F_NODE> でも B<MPOL_F_ADDR> でもない値が指定"
"された。 または、 I<flags> に B<MPOL_F_ADDR> が指定されており、 I<addr> が "
"NULL である。 または、 I<flags> に B<MPOL_F_ADDR> がされておらず、 I<addr> "
"が NULL でない。 または、 I<flags> に B<MPOL_F_NODE> が指定されており、 "
"B<MPOL_F_ADDR> が指定されておらず、 プロセスの現在のポリシーが "
"B<MPOL_INTERLEAVE> でない。 または、 I<flags> に B<MPOL_F_MEMS_ALLOWED> が指"
"定されており、さらに B<MPOL_F_ADDR> か B<MPOL_F_NODE> のいずれかが指定されて"
"いる。 (他にも B<EINVAL> となる場合がある。)"

#. type: SH
#: build/C/man2/get_mempolicy.2:228 build/C/man2/getcpu.2:51
#: build/C/man2/mbind.2:379 build/C/man2/migrate_pages.2:110
#: build/C/man2/move_pages.2:190 build/C/man2/set_mempolicy.2:273
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:232
msgid ""
"The B<get_mempolicy>()  system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""
"B<get_mempolicy>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加"
"された。"

#. type: SH
#: build/C/man2/get_mempolicy.2:232 build/C/man2/getcpu.2:54
#: build/C/man2/mbind.2:383 build/C/man2/migrate_pages.2:114
#: build/C/man2/move_pages.2:193 build/C/man7/numa.7:178
#: build/C/man2/set_mempolicy.2:277
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:234 build/C/man2/mbind.2:385
#: build/C/man2/migrate_pages.2:116 build/C/man2/move_pages.2:195
#: build/C/man2/set_mempolicy.2:279
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#. type: SH
#: build/C/man2/get_mempolicy.2:234 build/C/man2/getcpu.2:57
#: build/C/man2/mbind.2:385 build/C/man2/migrate_pages.2:116
#: build/C/man2/move_pages.2:195 build/C/man7/numa.7:146
#: build/C/man2/set_mempolicy.2:279
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:237 build/C/man2/mbind.2:388
#: build/C/man2/migrate_pages.2:119 build/C/man2/move_pages.2:198
#: build/C/man2/set_mempolicy.2:287
msgid "For information on library support, see B<numa>(7)."
msgstr "ライブラリによるサポートについては B<numa>(7)  を参照。"

#. type: SH
#: build/C/man2/get_mempolicy.2:237 build/C/man2/getcpu.2:120
#: build/C/man2/mbind.2:437 build/C/man2/migrate_pages.2:146
#: build/C/man2/move_pages.2:225 build/C/man7/numa.7:180
#: build/C/man2/set_mempolicy.2:287
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/get_mempolicy.2:245
msgid ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"
msgstr ""
"B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa>(7), B<numactl>(8)"

#. type: SH
#: build/C/man2/get_mempolicy.2:245 build/C/man2/getcpu.2:126
#: build/C/man2/mbind.2:448 build/C/man2/migrate_pages.2:159
#: build/C/man2/move_pages.2:235 build/C/man7/numa.7:188
#: build/C/man2/set_mempolicy.2:296
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/get_mempolicy.2:252 build/C/man2/getcpu.2:133
#: build/C/man2/mbind.2:455 build/C/man2/migrate_pages.2:166
#: build/C/man2/move_pages.2:242 build/C/man7/numa.7:195
#: build/C/man2/set_mempolicy.2:303
msgid ""
"This page is part of release 3.35 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://man7.org/linux/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/getcpu.2:7
#, no-wrap
msgid "GETCPU"
msgstr "GETCPU"

#. type: TH
#: build/C/man2/getcpu.2:7
#, no-wrap
msgid "2008-06-03"
msgstr "2008-06-03"

#. type: Plain text
#: build/C/man2/getcpu.2:10
msgid ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"
msgstr ""
"getcpu - determine CPU and NUMA node on which the calling thread is running"

#. type: Plain text
#: build/C/man2/getcpu.2:13
#, no-wrap
msgid "B<#include E<lt>linux/getcpu.hE<gt>>\n"
msgstr "B<#include E<lt>linux/getcpu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getcpu.2:16
#, no-wrap
msgid "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"
msgstr "B<int getcpu(unsigned *>I<cpu>B<, unsigned *>I<node>B<, struct getcpu_cache *>I<tcache>B<);>\n"

#. type: Plain text
#: build/C/man2/getcpu.2:34
msgid ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."
msgstr ""
"The B<getcpu>()  system call identifies the processor and node on which the "
"calling thread or process is currently running and writes them into the "
"integers pointed to by the I<cpu> and I<node> arguments.  The processor is a "
"unique small integer identifying a CPU.  The node is a unique small "
"identifier identifying a NUMA node.  When either I<cpu> or I<node> is NULL "
"nothing is written to the respective pointer."

#. type: Plain text
#: build/C/man2/getcpu.2:36
msgid "The third argument to this system call is nowadays unused."
msgstr "The third argument to this system call is nowadays unused."

#. type: Plain text
#: build/C/man2/getcpu.2:51
msgid ""
"The information placed in I<cpu> is only guaranteed to be current at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must be prepared to handle the situation when I<cpu> and I<node> are no "
"longer the current CPU and node."
msgstr ""
"The information placed in I<cpu> is only guaranteed to be current at the "
"time of the call: unless the CPU affinity has been fixed using "
"B<sched_setaffinity>(2), the kernel might change the CPU at any time.  "
"(Normally this does not happen because the scheduler tries to minimize "
"movements between CPUs to keep caches hot, but it is possible.)  The caller "
"must be prepared to handle the situation when I<cpu> and I<node> are no "
"longer the current CPU and node."

#. type: Plain text
#: build/C/man2/getcpu.2:54
msgid "B<getcpu>()  was added in kernel 2.6.19 for x86_64 and i386."
msgstr "B<getcpu>()  was added in kernel 2.6.19 for x86_64 and i386."

#. type: Plain text
#: build/C/man2/getcpu.2:57
msgid "B<getcpu>()  is Linux specific."
msgstr "B<getcpu>()  is Linux specific."

#. type: Plain text
#: build/C/man2/getcpu.2:63
msgid ""
"Linux makes a best effort to make this call as fast possible.  The intention "
"of B<getcpu>()  is to allow programs to make optimizations with per-CPU data "
"or for NUMA optimization."
msgstr ""
"Linux makes a best effort to make this call as fast possible.  The intention "
"of B<getcpu>()  is to allow programs to make optimizations with per-CPU data "
"or for NUMA optimization."

#. type: Plain text
#: build/C/man2/getcpu.2:69
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2); or use B<sched_getcpu>(3)  instead."
msgstr ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2); or use B<sched_getcpu>(3)  instead."

#.  commit 4307d1e5ada595c87f9a4d16db16ba5edb70dcb1
#.  Author: Ingo Molnar <mingo@elte.hu>
#.  Date:   Wed Nov 7 18:37:48 2007 +0100
#.  x86: ignore the sys_getcpu() tcache parameter
#.  ===== Before kernel 2.6.24: =====
#.  .I tcache
#.  is a pointer to a
#.  .IR "struct getcpu_cache"
#.  that is used as a cache by
#.  .BR getcpu ().
#.  The caller should put the cache into a thread-local variable
#.  if the process is multithreaded,
#.  because the cache cannot be shared between different threads.
#.  .I tcache
#.  can be NULL.
#.  If it is not NULL
#.  .BR getcpu ()
#.  will use it to speed up operation.
#.  The information inside the cache is private to the system call
#.  and should not be accessed by the user program.
#.  The information placed in the cache can change between kernel releases.
#.  When no cache is specified
#.  .BR getcpu ()
#.  will be slower,
#.  but always retrieve the current CPU and node information.
#.  With a cache
#.  .BR getcpu ()
#.  is faster.
#.  However, the cached information is only updated once per jiffy (see
#.  .BR time (7)).
#.  This means that the information could theoretically be out of date,
#.  although in practice the scheduler's attempt to maintain
#.  soft CPU affinity means that the information is unlikely to change
#.  over the course of the caching interval.
#. type: Plain text
#: build/C/man2/getcpu.2:120
msgid ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls, "
"at the cost that there was a very small chance that the returned information "
"would be out of date.  The caching mechanism was considered to cause "
"problems when migrating threads between CPUs, and so the argument is now "
"ignored."
msgstr ""
"The I<tcache> argument is unused since Linux 2.6.24.  In earlier kernels, if "
"this argument was non-NULL, then it specified a pointer to a caller-"
"allocated buffer in thread-local storage that was used to provide a caching "
"mechanism for B<getcpu>().  Use of the cache could speed B<getcpu>()  calls, "
"at the cost that there was a very small chance that the returned information "
"would be out of date.  The caching mechanism was considered to cause "
"problems when migrating threads between CPUs, and so the argument is now "
"ignored."

#. type: Plain text
#: build/C/man2/getcpu.2:126
msgid ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), B<sched_getcpu>"
"(3), B<cpuset>(7)"
msgstr ""
"B<mbind>(2), B<sched_setaffinity>(2), B<set_mempolicy>(2), B<sched_getcpu>"
"(3), B<cpuset>(7)"

#. type: TH
#: build/C/man2/mbind.2:25
#, no-wrap
msgid "MBIND"
msgstr "MBIND"

#. type: Plain text
#: build/C/man2/mbind.2:28
msgid "mbind - Set memory policy for a memory range"
msgstr "mbind - メモリ領域に対してメモリポリシーを設定する"

#. type: Plain text
#: build/C/man2/mbind.2:31 build/C/man2/migrate_pages.2:23
#: build/C/man2/move_pages.2:24 build/C/man2/set_mempolicy.2:31
#, no-wrap
msgid "B<#include E<lt>numaif.hE<gt>>\n"
msgstr "B<#include E<lt>numaif.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mbind.2:35
#, no-wrap
msgid ""
"B<int mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<          unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<          unsigned >I<flags>B<);>\n"
msgstr ""
"B<int mbind(void *>I<addr>B<, unsigned long >I<len>B<, int >I<mode>B<,>\n"
"B<          unsigned long *>I<nodemask>B<, unsigned long >I<maxnode>B<,>\n"
"B<          unsigned >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/mbind.2:48
msgid ""
"B<mbind>()  sets the NUMA memory policy, which consists of a policy mode and "
"zero or more nodes, for the memory range starting with I<addr> and "
"continuing for I<len> bytes.  The memory policy defines from which node "
"memory is allocated."
msgstr ""
"B<mbind>()  は、 I<addr> から始まる長さ I<len> バイトの範囲のメモリに NUMA メ"
"モリポリシーを設定する。 NUMA ポリシーはポリシーモードと 0 個以上のノードから"
"構成される。 メモリポリシーはどのノードからメモリを割り当てるかを決定する。"

#. type: Plain text
#: build/C/man2/mbind.2:70
msgid ""
"If the memory range specified by the I<addr> and I<len> arguments includes "
"an \"anonymous\" region of memory\\(emthat is a region of memory created "
"using the B<mmap>(2)  system call with the B<MAP_ANONYMOUS>\\(emor a memory "
"mapped file, mapped using the B<mmap>(2)  system call with the "
"B<MAP_PRIVATE> flag, pages will only be allocated according to the specified "
"policy when the application writes [stores] to the page.  For anonymous "
"regions, an initial read access will use a shared page in the kernel "
"containing all zeros.  For a file mapped with B<MAP_PRIVATE>, an initial "
"read access will allocate pages according to the process policy of the "
"process that causes the page to be allocated.  This may not be the process "
"that called B<mbind>()."
msgstr ""
"I<addr> と I<len> で指定されたメモリ範囲に、 メモリの「無名」領域 \\(em "
"B<MAP_ANONYMOUS> 付きの B<mmap>(2)  システムコールを使って作成されたメモリ領"
"域 \\(em や B<MAP_PRIVATE> 付きの B<mmap>(2)  を使ってマップされたメモリマッ"
"プ・ファイルが含まれている場合、 ページが指定されたポリシーに基づいて割り当て"
"られるのは、アプリケーション がそのページへの書き込み (データの格納) を行った"
"時だけである。 無名領域の場合、最初の読み出しアクセスの際には カーネル内の全"
"データが 0 である共有ページが使用される。 B<MAP_PRIVATE> でマップされたファイ"
"ルの場合、最初の読み出しアクセスがあると、 ページ割り当てが発生するきっかけと"
"なったプロセスのデフォルトポリシー にしたがってページの割り当てが行われる。 "
"ページ割り当てのきっかけとなったプロセスは、 B<mbind>()  を呼び出したプロセス"
"と同じとは限らない。"

#. type: Plain text
#: build/C/man2/mbind.2:78
msgid ""
"The specified policy will be ignored for any B<MAP_SHARED> mappings in the "
"specified memory range.  Rather the pages will be allocated according to the "
"process policy of the process that caused the page to be allocated.  Again, "
"this may not be the process that called B<mbind>()."
msgstr ""
"指定されたメモリ範囲内にある B<MAP_SHARED> のマッピングでは指定されたポリシー"
"は無視され、 ページ割り当てが発生するきっかけとなったプロセスのデフォルトポリ"
"シーに したがってページの割り当てが行われることになる。 繰り返しになるが、"
"ページ割り当てのきっかけとなったプロセスは、 B<mbind>()  を呼び出したプロセス"
"と同じとは限らない。"

#. type: Plain text
#: build/C/man2/mbind.2:95
msgid ""
"If the specified memory range includes a shared memory region created using "
"the B<shmget>(2)  system call and attached using the B<shmat>(2)  system "
"call, pages allocated for the anonymous or shared memory region will be "
"allocated according to the policy specified, regardless which process "
"attached to the shared memory segment causes the allocation.  If, however, "
"the shared memory region was created with the B<SHM_HUGETLB> flag, the huge "
"pages will be allocated according to the policy specified only if the page "
"allocation is caused by the process that calls B<mbind>()  for that region."
msgstr ""
"指定されたメモリ範囲に、 B<shmget>(2)  システムコールを使って作成されたり、 "
"B<shmat>(2)  システムコールを使って付加 (attach) されたりした共有メモリ領域"
"が 含まれる場合、無名メモリ領域や共有メモリ領域に対するページ割り当ては、 共"
"有メモリセグメントへポリシーの設定を行ったプロセスがページ割り当て のきっかけ"
"となったかに関わらず、指定されたポリシーにしたがって割り当て が行われる。 し"
"かしながら、共有メモリ領域が B<SHM_HUGETLB> フラグを指定して作成された場合に"
"は、ヒュージページ (huge page) の割り当てが 指定されたポリシーにしたがって行"
"われるのは、その領域に対して B<mbind>()  を呼び出したプロセスがページ割り当て"
"のきっかけとなった場合のみである。"

#. type: Plain text
#: build/C/man2/mbind.2:106
msgid ""
"By default, B<mbind>()  only has an effect for new allocations; if the pages "
"inside the range have been already touched before setting the policy, then "
"the policy has no effect.  This default behavior may be overridden by the "
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> flags described below."
msgstr ""
"デフォルトでは、 B<mbind>()  は新規のメモリ割り当てに対してのみ効果を持つ。 "
"ポリシーが設定される前にすでに使用されている範囲内のページに対しては、 ポリ"
"シーは影響しない。 このデフォルトの動作は、以下で説明するフラグ "
"B<MPOL_MF_MOVE> や B<MPOL_MF_MOVE_ALL> により上書きされる可能性がある。"

#. type: Plain text
#: build/C/man2/mbind.2:121
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE> or B<MPOL_PREFERRED>.  All policy modes except "
"B<MPOL_DEFAULT> require the caller to specify via the I<nodemask> argument, "
"the node or nodes to which the mode applies."
msgstr ""
"I<mode> 引き数には、 B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, "
"B<MPOL_PREFERRED> のいずれか一つを指定しなければならない。 B<MPOL_DEFAULT> 以"
"外のポリシーモードの場合、呼び出し元は I<nodemask> 引き数でそのポリシーモード"
"を適用するノードを指定する必要がある。"

#. type: Plain text
#: build/C/man2/mbind.2:129
msgid ""
"The I<mode> argument may also include an optional I<mode flag >.  The "
"supported I<mode flags> are:"
msgstr ""
"I<mode> 引き数には、追加で I<モードフラグ> を含めることもできる。 サポートさ"
"れている I<モードフラグ> は以下の通りである。"

#. type: TP
#: build/C/man2/mbind.2:129
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (Linux-2.6.26 以降)"

#. type: Plain text
#: build/C/man2/mbind.2:139
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux does not remap "
"the I<nodemask> when the process moves to a different cpuset context, nor "
"when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""
"空でない I<nodemask> は、物理ノード ID である。 Linux では、そのプロセスが異"
"なる CPU 集合コンテキスト (cpuset context)  に移動した場合でも、そのプロセス"
"の現在の CPU 集合コンテキストで 許可されているノード集合が変化した場合でも、 "
"I<nodemask> をマッピングし直すことはない。"

#. type: TP
#: build/C/man2/mbind.2:139
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux-2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (Linux-2.6.26 以降)"

#. type: Plain text
#: build/C/man2/mbind.2:145 build/C/man2/set_mempolicy.2:111
msgid ""
"A nonempty I<nodemask> specifies node ids that are relative to the set of "
"node ids allowed by the process's current cpuset."
msgstr ""
"空でない I<nodemask> は、そのプロセスの現在の CPU 集合で許可されているノード "
"ID 集合 における相対的なノード ID である。"

#. type: Plain text
#: build/C/man2/mbind.2:173
msgid ""
"I<nodemask> points to a bitmask of nodes containing up to I<maxnode> bits.  "
"The bit mask size is rounded to the next multiple of I<sizeof(unsigned long)"
">, but the kernel will only use bits up to I<maxnode>.  A NULL value of "
"I<nodemask> or a I<maxnode> value of zero specifies the empty set of nodes.  "
"If the value of I<maxnode> is zero, the I<nodemask> argument is ignored.  "
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory."
msgstr ""
"I<nodemask> は、最大で I<maxnode> ビットから構成されるノードのビットマスクを"
"指す。 ビットマスクの大きさは、直近の I<sizeof(unsigned long)> の倍数に切り上"
"げられるが、カーネルが使用するのは I<maxnode> 個までのビットだけである。 "
"NULL 値の I<nodemask> もしくは値が 0 の I<maxnode> はノードの空集合を表す。 "
"I<maxnode> の値が 0 の場合、 I<nodemask> 引き数は無視される。 I<nodemask> が"
"必須の場面では、 I<nodemask> に、オンラインで、そのプロセスの現在の CPU 集合"
"コンテキストで 許可されており (B<MPOL_F_STATIC_NODES> モードフラグが指定され"
"ていない場合)、メモリがあるノードが 少なくとも一つ入っていなければならない。"

#. type: Plain text
#: build/C/man2/mbind.2:195
msgid ""
"The B<MPOL_DEFAULT> mode requests that any nondefault policy be removed, "
"restoring default behavior.  When applied to a range of memory via B<mbind>"
"(), this means to use the process policy, which may have been set with "
"B<set_mempolicy>(2).  If the mode of the process policy is also "
"B<MPOL_DEFAULT>, the system-wide default policy will be used.  The system-"
"wide default policy allocates pages on the node of the CPU that triggers the "
"allocation.  For B<MPOL_DEFAULT>, the I<nodemask> and I<maxnode> arguments "
"must be specify the empty set of nodes."
msgstr ""
"モード B<MPOL_DEFAULT> はデフォルトではないプロセスのメモリポリシーを削除"
"し、 デフォルトの動作に戻すことを指定するものである。 B<mbind>()  経由で、あ"
"るメモリ領域に対して B<MPOL_DEFAULT> が適用された場合、プロセスのデフォルトポ"
"リシーを使用することを意味する。 プロセスのデフォルトポリシーは、 "
"B<set_mempolicy>(2)  で変更されているかもしれない。 プロセスのポリシーのモー"
"ドも B<MPOL_DEFAULT> の場合、システム全体のデフォルトポリシーが使用される。 "
"システム全体のデフォルトポリシーでは、割り当てのきっかけとなった CPU のノード"
"からページの割り当てを行う。 B<MPOL_DEFAULT> では、引き数 I<nodemask> と "
"I<maxnode> にノードの空集合を指定しなければならない。"

#. type: Plain text
#: build/C/man2/mbind.2:212
msgid ""
"The B<MPOL_BIND> mode specifies a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest "
"numeric node ID first, until that node contains no free memory.  Allocations "
"will then come from the node with the next highest node ID specified in "
"I<nodemask> and so forth, until none of the specified nodes contain free "
"memory.  Pages will not be allocated from any node not specified in the "
"I<nodemask>."
msgstr ""
"B<MPOL_BIND> は厳しいポリシーで、メモリ割り当ては I<nodemask> に指定された"
"ノードに限定される。 他のノードへの割り当ては行われない。 I<nodemask> に 2 個"
"以上のノードが指定された場合、ページの割り当ては ノード ID が数字として最小の"
"ノードから開始され、 そのノードに空きメモリがなくなるまでそのノードから ペー"
"ジ割り当てが行われる。そのノードに空きメモリがなくなったら、 次に小さなノー"
"ド ID を持つノードからページ割り当てが行われる。 これを、 I<nodemask> で指定"
"された全てのノードで空きメモリがなくなるまで繰り返す。 I<nodemask> で指定され"
"た以外のノードからはページの割り当ては行われない。"

#. type: Plain text
#: build/C/man2/mbind.2:225
msgid ""
"The B<MPOL_INTERLEAVE> mode specifies that page allocations be interleaved "
"across the set of nodes specified in I<nodemask>.  This optimizes for "
"bandwidth instead of latency by spreading out pages and memory accesses to "
"those pages across multiple nodes.  To be effective the memory area should "
"be fairly large, at least 1MB or bigger with a fairly uniform access "
"pattern.  Accesses to a single page of the area will still be limited to the "
"memory bandwidth of a single node."
msgstr ""
"B<MPOL_INTERLEAVE> は、メモリ割り当てが I<nodemask> に指定されたノード間で交"
"互に行われることを指定するものである。 このポリシーでは、複数のノードにページ"
"を広げて配置し、これらのページへの メモリアクセスを分散することで、遅延ではな"
"く、帯域を最適化する。 効果を得るには、メモリ領域をある程度大きくすべきであ"
"り、 メモリアクセスのパターンがかなり均一な場合でも 少なくとも 1MB 以上にすべ"
"きである。 このモードでも、一つのページへのアクセスに関しては 一つのノードの"
"メモリ帯域が上限となることは変わりない。"

#. type: Plain text
#: build/C/man2/mbind.2:244
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to other nodes if "
"the preferred nodes is low on free memory.  If I<nodemask> specifies more "
"than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the memory is allocated on the node of the CPU that "
"triggered the allocation.  This is the only way to specify \"local allocation"
"\" for a range of memory via B<mbind>()."
msgstr ""
"B<MPOL_PREFERRED> は、割り当て時に優先されるノードを設定する。 カーネルはまず"
"優先ノードにページ割り当てを行おうとし、 優先ノードに空きメモリが少ない場合に"
"他のノードに割り当てを行う。 I<nodemask> に複数のノード ID が指定された場合"
"は、 I<nodemask> 内の最初のノードが優先ノードとして選択される。 引き数 "
"I<nodemask>, I<maxnode> で空集合が指定された場合は、割り当てのきっかけとなっ"
"た CPU のノードに メモリ割り当てが行われる。 B<mbind>(2)  で、あるメモリ領域"
"に対して「ローカルからの割り当て (local allocation)」を 指定する方法はこれし"
"かない。"

#.  According to the kernel code, the following is not true
#.  --Lee Schermerhorn
#.  In 2.6.16 or later the kernel will also try to move pages
#.  to the requested node with this flag.
#. type: Plain text
#: build/C/man2/mbind.2:260
msgid ""
"If B<MPOL_MF_STRICT> is passed in I<flags> and I<mode> is not "
"B<MPOL_DEFAULT>, then the call will fail with the error B<EIO> if the "
"existing pages in the memory range don't follow the policy."
msgstr ""
"I<flags> に B<MPOL_MF_STRICT> が 指定され、 I<mode> が B<MPOL_DEFAULT> でない"
"場合、 指定されたポリシーに従っていないメモリ領域にページが存在すると、 "
"B<mbind>()  はエラー B<EIO> で失敗する。"

#. type: Plain text
#: build/C/man2/mbind.2:273
msgid ""
"If B<MPOL_MF_MOVE> is specified in I<flags>, then the kernel will attempt to "
"move all the existing pages in the memory range so that they follow the "
"policy.  Pages that are shared with other processes will not be moved.  If "
"B<MPOL_MF_STRICT> is also specified, then the call will fail with the error "
"B<EIO> if some pages could not be moved."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE> が指定されると、カーネルはそのメモリ領域内の既存"
"の全てのページを移動し、 指定されたポリシーに従うようにしようとする。 他のプ"
"ロセスと共有されているページは移動されない。 B<MPOL_MF_STRICT> も指定された場"
"合、移動できなかったページがあると、 B<mbind>()  はエラー B<EIO> で失敗する。"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:289
msgid ""
"If B<MPOL_MF_MOVE_ALL> is passed in I<flags>, then the kernel will attempt "
"to move all existing pages in the memory range regardless of whether other "
"processes use the pages.  The calling process must be privileged "
"(B<CAP_SYS_NICE>)  to use this flag.  If B<MPOL_MF_STRICT> is also "
"specified, then the call will fail with the error B<EIO> if some pages could "
"not be moved."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE_ALL> が指定されると、カーネルはそのメモリ領域内の"
"既存の全てのページを、 他のプロセスがページを使用しているかどうかに関わらず移"
"動する。 このフラグを使用するには、呼び出し元のプロセスは特権 "
"(B<CAP_SYS_NICE>)  を持っていなければならない。 B<MPOL_MF_STRICT> も指定され"
"た場合、移動できなかったページがあると、 B<mbind>()  はエラー B<EIO> で失敗す"
"る。"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:297
msgid ""
"On success, B<mbind>()  returns 0; on error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<mbind>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> にエ"
"ラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/mbind.2:307
msgid ""
"Part or all of the memory range specified by I<nodemask> and I<maxnode> "
"points outside your accessible address space.  Or, there was an unmapped "
"hole in the specified memory range."
msgstr ""
"I<nodemask> と I<maxnode> で指定されたメモリ領域の一部または全部が、 呼び出し"
"元がアクセス可能なアドレス空間外を指している。 もしくは指定されたメモリ領域に"
"マップされていない部分 (unmapped hole)  があった、"

#.  As at 2.6.23, this limit is "a page worth of bits", e.g.,
#.  8 * 4096 bits, assuming a 4kB page size.
#. type: Plain text
#: build/C/man2/mbind.2:355
msgid ""
"An invalid value was specified for I<flags> or I<mode>; or I<addr + len> was "
"less than I<addr>; or I<addr> is not a multiple of the system page size.  "
"Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> specified a nonempty set; or "
"I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> is empty.  Or, "
"I<maxnode> exceeds a kernel-imposed limit.  Or, I<nodemask> specifies one or "
"more node IDs that are greater than the maximum supported node ID.  Or, none "
"of the node IDs specified by I<nodemask> are on-line and allowed by the "
"process's current cpuset context, or none of the specified nodes contain "
"memory.  Or, the I<mode> argument specified both B<MPOL_F_STATIC_NODES> and "
"B<MPOL_F_RELATIVE_NODES>."
msgstr ""
"I<flags> や I<mode> に不正な値が指定された。 I<addr + len> が I<addr> より小"
"さい。 I<addr> がシステムのページサイズの倍数になっていない。 または I<mode> "
"が B<MPOL_DEFAULT> で I<nodemask> に空でない集合が指定された。 I<mode> が "
"B<MPOL_BIND> か B<MPOL_INTERLEAVE> で I<nodemask> が空であった。 I<maxnode> "
"がカーネルに適用された上限を超えている。 I<nodemask> に、サポートされている最"
"大ノード ID より大きいノードが指定された。 I<nodemask> に、オンラインで、かつ"
"そのプロセスの現在の CPU 集合コンテキストで 許可されているノードが一つも含ま"
"れていないか、 メモリを含むノードが一つも指定されていない。 I<mode> 引き数に "
"B<MPOL_F_STATIC_NODES> と B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: TP
#: build/C/man2/mbind.2:355
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/mbind.2:366
msgid ""
"B<MPOL_MF_STRICT> was specified and an existing page was already on a node "
"that does not follow the policy; or B<MPOL_MF_MOVE> or B<MPOL_MF_MOVE_ALL> "
"was specified and the kernel was unable to move all existing pages in the "
"range."
msgstr ""
"B<MPOL_MF_STRICT> が指定されたが、このポリシーに従っていないノードに すでに"
"ページが存在していた。 もしくは B<MPOL_MF_MOVE> か B<MPOL_MF_MOVE_ALL> が指定"
"されたが、カーネルが指定された領域内の既存の全てのページを 移動することができ"
"なかった。"

#. type: TP
#: build/C/man2/mbind.2:366 build/C/man2/set_mempolicy.2:270
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/mbind.2:369 build/C/man2/set_mempolicy.2:273
msgid "Insufficient kernel memory was available."
msgstr "利用可能なカーネルメモリが十分でなかった。"

#. type: TP
#: build/C/man2/mbind.2:369 build/C/man2/migrate_pages.2:95
#: build/C/man2/move_pages.2:178
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  ---------------------------------------------------------------
#. type: Plain text
#: build/C/man2/mbind.2:379
msgid ""
"The I<flags> argument included the B<MPOL_MF_MOVE_ALL> flag and the caller "
"does not have the B<CAP_SYS_NICE> privilege."
msgstr ""
"I<flags> 引き数に B<MPOL_MF_MOVE_ALL> フラグが含まれているが、呼び出し元が "
"B<CAP_SYS_NICE> 特権を持たない。"

#. type: Plain text
#: build/C/man2/mbind.2:383
msgid ""
"The B<mbind>()  system call was added to the Linux kernel in version 2.6.7."
msgstr ""
"B<mbind>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加された。"

#. type: Plain text
#: build/C/man2/mbind.2:393
msgid ""
"NUMA policy is not supported on a memory mapped file range that was mapped "
"with the B<MAP_SHARED> flag."
msgstr ""
"NUMA ポリシーは、 B<MAP_SHARED> フラグが指定されてマップされたメモリマップ・"
"ファイルの領域では サポートされていない。"

#. type: Plain text
#: build/C/man2/mbind.2:425
msgid ""
"The B<MPOL_DEFAULT> mode can have different effects for B<mbind>()  and "
"B<set_mempolicy>(2).  When B<MPOL_DEFAULT> is specified for B<set_mempolicy>"
"(2), the process's policy reverts to system default policy or local "
"allocation.  When B<MPOL_DEFAULT> is specified for a range of memory using "
"B<mbind>(), any pages subsequently allocated for that range will use the "
"process's policy, as set by B<set_mempolicy>(2).  This effectively removes "
"the explicit policy from the specified range, \"falling back\" to a possibly "
"nondefault policy.  To select explicit \"local allocation\" for a memory "
"range, specify a I<mode> of B<MPOL_PREFERRED> with an empty set of nodes.  "
"This method will work for B<set_mempolicy>(2), as well."
msgstr ""
"B<MPOL_DEFAULT> モードは、 B<mbind>()  と B<set_mempolicy>(2)  で異なる効果を"
"持つことができる。 B<set_mempolicy>(2)  で B<MPOL_DEFAULT> が指定された場合、"
"そのプロセスのポリシーはシステムの デフォルトポリシー、すなわちローカルからの"
"割り当て、に戻る。 B<mbind>()  を使ってメモリのある領域に B<MPOL_DEFAULT> が"
"指定された場合、その範囲に対してそれ以降に行われるページの割り当てでは、 "
"B<set_mempolicy>(2)  で設定したのと同じように、そのプロセスのポリシーが適用さ"
"れる。 これにより、特定のメモリ領域についてだけ明示的なポリシーを削除し、 デ"
"フォルトのポリシーに「戻す」ことができる。 あるメモリ領域に対して「ローカルか"
"らの割り当て」を明示的に設定するには、 I<mode> に B<MPOL_PREFERRED> を指定"
"し、 I<nodemask> に空集合のノードを指定すればよい。 この方法は "
"B<set_mempolicy>(2)  でも通用する。"

#. type: Plain text
#: build/C/man2/mbind.2:429
msgid ""
"Support for huge page policy was added with 2.6.16.  For interleave policy "
"to be effective on huge page mappings the policied memory needs to be tens "
"of megabytes or larger."
msgstr ""
"2.6.16 でヒュージページ・ポリシーへの対応が追加された。 インターリーブ・ポリ"
"シーがヒュージページのマッピングで効果を持つには、 ポリシーが適用されるメモリ"
"が数十メガバイト以上である必要がある。"

#. type: Plain text
#: build/C/man2/mbind.2:432
msgid "B<MPOL_MF_STRICT> is ignored on huge page mappings."
msgstr "B<MPOL_MF_STRICT> はヒュージページのマッピングでは無視される。"

#. type: Plain text
#: build/C/man2/mbind.2:437
msgid ""
"B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> are only available on Linux 2.6.16 "
"and later."
msgstr ""
"B<MPOL_MF_MOVE> と B<MPOL_MF_MOVE_ALL> は Linux 2.6.16 以降でのみ利用可能であ"
"る。"

#. type: Plain text
#: build/C/man2/mbind.2:448
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), B<shmat>"
"(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mmap>(2), B<set_mempolicy>(2), B<shmat>"
"(2), B<shmget>(2), B<numa>(3), B<cpuset>(7), B<numa>(7), B<numactl>(8)"

#. type: TH
#: build/C/man2/migrate_pages.2:17
#, no-wrap
msgid "MIGRATE_PAGES"
msgstr "MIGRATE_PAGES"

#. type: TH
#: build/C/man2/migrate_pages.2:17
#, no-wrap
msgid "2010-11-01"
msgstr "2010-11-01"

#. type: Plain text
#: build/C/man2/migrate_pages.2:20
msgid "migrate_pages - move all pages in a process to another set of nodes"
msgstr "migrate_pages - move all pages in a process to another set of nodes"

#. type: Plain text
#: build/C/man2/migrate_pages.2:27
#, no-wrap
msgid ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes);>\n"
msgstr ""
"B<long migrate_pages(int >I<pid>B<, unsigned long >I<maxnode,>\n"
"B<                   const unsigned long *>I<old_nodes,>\n"
"B<                   const unsigned long *>I<new_nodes);>\n"

#. type: Plain text
#: build/C/man2/migrate_pages.2:30 build/C/man2/move_pages.2:30
msgid "Link with I<-lnuma>."
msgstr "I<-lnuma> とリンクする。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:46
msgid ""
"B<migrate_pages>()  moves all pages of the process I<pid> that are in memory "
"nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages not located "
"in any node in I<old_nodes> will not be migrated.  As far as possible, the "
"kernel maintains the relative topology relationship inside I<old_nodes> "
"during the migration to I<new_nodes>."
msgstr ""
"B<migrate_pages>()  moves all pages of the process I<pid> that are in memory "
"nodes I<old_nodes> to the memory nodes in I<new_nodes>.  Pages not located "
"in any node in I<old_nodes> will not be migrated.  As far as possible, the "
"kernel maintains the relative topology relationship inside I<old_nodes> "
"during the migration to I<new_nodes>."

#. type: Plain text
#: build/C/man2/migrate_pages.2:68
msgid ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."
msgstr ""
"The I<old_nodes> and I<new_nodes> arguments are pointers to bit masks of "
"node numbers, with up to I<maxnode> bits in each mask.  These masks are "
"maintained as arrays of unsigned I<long> integers (in the last I<long> "
"integer, the bits beyond those specified by I<maxnode> are ignored).  The "
"I<maxnode> argument is the maximum node number in the bit mask plus one "
"(this is the same as in B<mbind>(2), but different from B<select>(2))."

#. type: Plain text
#: build/C/man2/migrate_pages.2:82
msgid ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."
msgstr ""
"The I<pid> argument is the ID of the process whose pages are to be moved.  "
"To move pages in another process, the caller must be privileged "
"(B<CAP_SYS_NICE>)  or the real or effective user ID of the calling process "
"must match the real or saved-set user ID of the target process.  If I<pid> "
"is 0, then B<migrate_pages>()  moves pages of the calling process."

#. type: Plain text
#: build/C/man2/migrate_pages.2:87
msgid ""
"Pages shared with another process will only be moved if the initiating "
"process has the B<CAP_SYS_NICE> privilege."
msgstr ""
"Pages shared with another process will only be moved if the initiating "
"process has the B<CAP_SYS_NICE> privilege."

#. type: Plain text
#: build/C/man2/migrate_pages.2:94
msgid ""
"On success B<migrate_pages>()  returns zero.  On error, it returns -1, and "
"sets I<errno> to indicate the error."
msgstr ""
"On success B<migrate_pages>()  returns zero.  On error, it returns -1, and "
"sets I<errno> to indicate the error."

#. type: Plain text
#: build/C/man2/migrate_pages.2:104
msgid ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."
msgstr ""
"Insufficient privilege (B<CAP_SYS_NICE>)  to move pages of the process "
"specified by I<pid>, or insufficient privilege (B<CAP_SYS_NICE>)  to access "
"the specified target nodes."

#. type: TP
#: build/C/man2/migrate_pages.2:104 build/C/man2/move_pages.2:187
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#.  FIXME There are other errors
#. type: Plain text
#: build/C/man2/migrate_pages.2:110
msgid "No process matching I<pid> could be found."
msgstr "No process matching I<pid> could be found."

#. type: Plain text
#: build/C/man2/migrate_pages.2:114
msgid ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."
msgstr ""
"The B<migrate_pages>()  system call first appeared on Linux in version "
"2.6.16."

#. type: Plain text
#: build/C/man2/migrate_pages.2:128
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the calling process's cpuset.  Note that "
"this information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."

#. type: Plain text
#: build/C/man2/migrate_pages.2:140
msgid ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."
msgstr ""
"Use of B<migrate_pages>()  may result in pages whose location (node) "
"violates the memory policy established for the specified addresses (see "
"B<mbind>(2))  and/or the specified process (see B<set_mempolicy>(2)).  That "
"is, memory policy does not constrain the destination nodes used by "
"B<migrate_pages>()."

#. type: Plain text
#: build/C/man2/migrate_pages.2:146 build/C/man2/move_pages.2:225
msgid ""
"The I<E<lt>numaif.hE<gt>> header is not included with glibc, but requires "
"installing I<libnuma-devel> or a similar package."
msgstr ""
"ヘッダファイル I<E<lt>numaif.hE<gt>> は glibc には含まれておらず、 I<libnuma-"
"devel> か同様のパッケージをインストールする必要がある。"

#. type: Plain text
#: build/C/man2/migrate_pages.2:156
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numa_stat>"
"(8);"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numa_stat>"
"(8);"

#. type: Plain text
#: build/C/man2/migrate_pages.2:159
msgid "the kernel source file I<Documentation/vm/page_migration>."
msgstr "the kernel source file I<Documentation/vm/page_migration>."

#. type: TH
#: build/C/man2/move_pages.2:18
#, no-wrap
msgid "MOVE_PAGES"
msgstr "MOVE_PAGES"

#. type: TH
#: build/C/man2/move_pages.2:18
#, no-wrap
msgid "2010-06-11"
msgstr "2010-06-11"

#. type: Plain text
#: build/C/man2/move_pages.2:21
msgid "move_pages - move individual pages of a process to another node"
msgstr "move_pages - あるプロセスの個々のページを別のノードに移動する"

#. type: Plain text
#: build/C/man2/move_pages.2:27
#, no-wrap
msgid ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"
msgstr ""
"B<long move_pages(int >I<pid>B<, unsigned long count, void **>I<pages>B<,>\n"
"B<                const int *>I<nodes>B<, int *>I<status>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/move_pages.2:43
msgid ""
"B<move_pages>()  moves the specified I<pages> of the process I<pid> to the "
"memory nodes specified by I<nodes>.  The result of the move is reflected in "
"I<status>.  The I<flags> indicate constraints on the pages to be moved."
msgstr ""
"B<move_pages>()  は、プロセス I<pid> の指定されたページ I<pages> を I<nodes> "
"で指定されたメモリノードに移動する。 移動の結果は I<status> に反映される。 "
"I<flags> では移動されるページに関する制約を指定する。"

#. type: Plain text
#: build/C/man2/move_pages.2:56
msgid ""
"I<pid> is the ID of the process in which pages are to be moved.  To move "
"pages in another process, the caller must be privileged (B<CAP_SYS_NICE>)  "
"or the real or effective user ID of the calling process must match the real "
"or saved-set user ID of the target process.  If I<pid> is 0, then "
"B<move_pages>()  moves pages of the calling process."
msgstr ""
"I<pid> は、移動されるページが属するプロセスの ID である。 別のプロセスのペー"
"ジを移動するためには、呼び出し元が特権 (B<CAP_SYS_NICE>)  を持っているか、呼"
"び出したプロセスの実ユーザ ID か実効ユーザ ID が ページ移動対象のプロセスの実"
"ユーザ ID か保存 set-user-ID のどちらかと 一致しなければならない。 I<pid> が "
"0 の場合、 B<move_pages>()  は呼び出したプロセスのページを移動する。"

#. type: Plain text
#: build/C/man2/move_pages.2:64
msgid ""
"I<count> is the number of pages to move.  It defines the size of the three "
"arrays I<pages>, I<nodes>, and I<status>."
msgstr ""
"I<count> は移動するページ数である。 I<count> により I<pages>, I<nodes>, "
"I<status> の 3 つの配列の大きさが定義される。"

#.  FIXME what if they are not aligned?
#. type: Plain text
#: build/C/man2/move_pages.2:71
msgid ""
"I<pages> is an array of pointers to the pages that should be moved.  These "
"are pointers that should be aligned to page boundaries.  Addresses are "
"specified as seen by the process specified by I<pid>."
msgstr ""
"I<pages> は、移動すべきページへのポインタの配列であり、 各ポインタはページ境"
"界に揃えた値を指定すべきである。 I<pid> で指定されたプロセスで見えるアドレス"
"を指定する。"

#. type: Plain text
#: build/C/man2/move_pages.2:84
msgid ""
"I<nodes> is an array of integers that specify the desired location for each "
"page.  Each element in the array is a node number.  I<nodes> can also be "
"NULL, in which case B<move_pages>()  does not move any pages but instead "
"will return the node where each page currently resides, in the I<status> "
"array.  Obtaining the status of each page may be necessary to determine "
"pages that need to be moved."
msgstr ""
"I<nodes> は、各ページの希望の移動場所を示す整数値の配列であり、 配列の各要素"
"はノード番号である。 I<nodes> には NULL を指定することもでき、この場合には "
"B<move_pages>()  はどのページも移動しないが、各ページが現在配置されているノー"
"ドを配列 I<status> に格納して返す。どのページを移動する必要があるかを判断する"
"ために、 各ページの状態の取得が必要な場合もある。"

#. type: Plain text
#: build/C/man2/move_pages.2:90
msgid ""
"I<status> is an array of integers that return the status of each page.  The "
"array only contains valid values if B<move_pages>()  did not return an error."
msgstr ""
"I<status> は、各ページの状態を表す整数値の配列である。 この配列に有効な値が格"
"納されるのは、 B<move_pages>()  がエラーを返さなかった場合だけである。"

#. type: Plain text
#: build/C/man2/move_pages.2:102
msgid ""
"I<flags> specify what types of pages to move.  B<MPOL_MF_MOVE> means that "
"only pages that are in exclusive use by the process are to be moved.  "
"B<MPOL_MF_MOVE_ALL> means that pages shared between multiple processes can "
"also be moved.  The process must be privileged (B<CAP_SYS_NICE>)  to use "
"B<MPOL_MF_MOVE_ALL>."
msgstr ""
"I<flags> には、どの種類のページを移動するかを指定する。 B<MPOL_MF_MOVE> は、"
"そのプロセスが排他的に使用しているページだけを移動することを意味する。 "
"B<MPOL_MF_MOVE_ALL> は、複数のプロセス間で共有されているページも移動できるこ"
"とを意味する。 B<MPOL_MF_MOVE_ALL> を使用するためには、そのプロセスが特権 "
"(B<CAP_SYS_NICE>)  を持っていなければならない。"

#. type: SH
#: build/C/man2/move_pages.2:102
#, no-wrap
msgid "Page states in the status array"
msgstr "status 配列に格納されるページ状態"

#. type: Plain text
#: build/C/man2/move_pages.2:106
msgid ""
"The following values can be returned in each element of the I<status> array."
msgstr "I<status> 配列の各要素として、以下の値が返される。"

#. type: TP
#: build/C/man2/move_pages.2:106
#, no-wrap
msgid "B<0..MAX_NUMNODES>"
msgstr "B<0..MAX_NUMNODES>"

#. type: Plain text
#: build/C/man2/move_pages.2:109
msgid "Identifies the node on which the page resides."
msgstr "そのページが配置されているノードを示す。"

#. type: TP
#: build/C/man2/move_pages.2:109
#, no-wrap
msgid "B<-EACCES>"
msgstr "B<-EACCES>"

#. type: Plain text
#: build/C/man2/move_pages.2:114
msgid ""
"The page is mapped by multiple processes and can only be moved if "
"B<MPOL_MF_MOVE_ALL> is specified."
msgstr ""
"そのページは複数のプロセスによりマップされており、 B<MPOL_MF_MOVE_ALL> が指定"
"された場合にのみ移動できる。"

#. type: TP
#: build/C/man2/move_pages.2:114
#, no-wrap
msgid "B<-EBUSY>"
msgstr "B<-EBUSY>"

#. type: Plain text
#: build/C/man2/move_pages.2:120
msgid ""
"The page is currently busy and cannot be moved.  Try again later.  This "
"occurs if a page is undergoing I/O or another kernel subsystem is holding a "
"reference to the page."
msgstr ""
"そのページが現在ビジーであり、移動できない。後でもう一度試すこと。 この状況"
"は、ページが I/O の実行中であったり、カーネルの他のサブシステム がそのページ"
"への参照を保持している場合に発生する。"

#. type: TP
#: build/C/man2/move_pages.2:120
#, no-wrap
msgid "B<-EFAULT>"
msgstr "B<-EFAULT>"

#. type: Plain text
#: build/C/man2/move_pages.2:123
msgid "This is a zero page or the memory area is not mapped by the process."
msgstr ""
"そのページが zero page であるか、そのメモリ領域はそのプロセスにより マップさ"
"れていない。"

#. type: TP
#: build/C/man2/move_pages.2:123
#, no-wrap
msgid "B<-EIO>"
msgstr "B<-EIO>"

#. type: Plain text
#: build/C/man2/move_pages.2:130
msgid ""
"Unable to write back a page.  The page has to be written back in order to "
"move it since the page is dirty and the file system does not provide a "
"migration function that would allow the move of dirty pages."
msgstr ""
"ページを書き戻す (write back) ことができない。 ページが dirty で、ファイルシ"
"ステムが dirty なページを移動できるような 移動機能を提供していないため、その"
"ページを移動するためにはページを 書き戻さなければならない。"

#. type: TP
#: build/C/man2/move_pages.2:130
#, no-wrap
msgid "B<-EINVAL>"
msgstr "B<-EINVAL>"

#. type: Plain text
#: build/C/man2/move_pages.2:135
msgid ""
"A dirty page cannot be moved.  The file system does not provide a migration "
"function and has no ability to write back pages."
msgstr ""
"dirty なページを移動できない。 ファイルシステムが dirty なページを移動するた"
"めの機能を提供しておらず、 ページを書き戻す能力もない。"

#. type: TP
#: build/C/man2/move_pages.2:135
#, no-wrap
msgid "B<-ENOENT>"
msgstr "B<-ENOENT>"

#. type: Plain text
#: build/C/man2/move_pages.2:138
msgid "The page is not present."
msgstr "ページが存在しない。"

#. type: TP
#: build/C/man2/move_pages.2:138
#, no-wrap
msgid "B<-ENOMEM>"
msgstr "B<-ENOMEM>"

#. type: Plain text
#: build/C/man2/move_pages.2:141
msgid "Unable to allocate memory on target node."
msgstr "移動先のノードでメモリを確保することができない。"

#.  FIXME Is the following quite true: does the wrapper in numactl
#.  do the right thing?
#. type: Plain text
#: build/C/man2/move_pages.2:150
msgid ""
"On success B<move_pages>()  returns zero.  On error, it returns -1, and sets "
"I<errno> to indicate the error."
msgstr ""
"成功すると、 B<move_pages>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/move_pages.2:151
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/move_pages.2:154
msgid "Too many pages to move."
msgstr "移動すべきページが多過ぎる。"

#. type: TP
#: build/C/man2/move_pages.2:154
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:159
msgid "One of the target nodes is not allowed by the current cpuset."
msgstr "移動先のノードのいずれかが現在の CPU 集合では許可されていない。"

#. type: Plain text
#: build/C/man2/move_pages.2:162
msgid "Parameter array could not be accessed."
msgstr "パラメータ配列にアクセスできなかった。"

#. type: Plain text
#: build/C/man2/move_pages.2:169
msgid ""
"Flags other than B<MPOL_MF_MOVE> and B<MPOL_MF_MOVE_ALL> was specified or an "
"attempt was made to migrate pages of a kernel thread."
msgstr ""
"I<flags> に B<MPOL_MF_MOVE> でも B<MPOL_MF_MOVE_ALL> でもない値が指定された"
"か、カーネルスレッドのページを移動させようとした。"

#. type: TP
#: build/C/man2/move_pages.2:169
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/move_pages.2:172
msgid "One of the target nodes is not online."
msgstr "移動先のノードのいずれかがオンラインでない。"

#. type: TP
#: build/C/man2/move_pages.2:172
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/move_pages.2:178
msgid ""
"No pages were found that require moving.  All pages are either already on "
"the target node, not present, had an invalid address or could not be moved "
"because they were mapped by multiple processes."
msgstr ""
"移動が必要なページが全く見つからなかった。 指定された全てのページが、すでに移"
"動先のノードに存在するか、存在しないか、 無効なアドレスであったか、複数のプロ"
"セスによってマップされていて移動でき なかったか、のいずれかであった。"

#. type: Plain text
#: build/C/man2/move_pages.2:187
msgid ""
"The caller specified B<MPOL_MF_MOVE_ALL> without sufficient privileges "
"(B<CAP_SYS_NICE>).  Or, the caller attempted to move pages of a process "
"belonging to another user but did not have privilege to do so "
"(B<CAP_SYS_NICE>)."
msgstr ""
"呼び出し元は B<MPOL_MF_MOVE_ALL> を指定したが、十分な特権 (B<CAP_SYS_NICE>)  "
"を持っていない。 または、呼び出し元が他のユーザに属するプロセスのページを移動"
"しようとしたが、 それを行えるだけの特権 (B<CAP_SYS_NICE>)  を持っていなかっ"
"た。"

#. type: Plain text
#: build/C/man2/move_pages.2:190
msgid "Process does not exist."
msgstr "プロセスが存在しない。"

#. type: Plain text
#: build/C/man2/move_pages.2:193
msgid "B<move_pages>()  first appeared on Linux in version 2.6.18."
msgstr "B<move_pages>()  は、バージョン 2.6.18 で初めて Linux に登場した。"

#.  FIXME Clarify "current cpuset".  Is that the cpuset of the caller
#.  or the target?
#. type: Plain text
#: build/C/man2/move_pages.2:209
msgid ""
"Use B<get_mempolicy>(2)  with the B<MPOL_F_MEMS_ALLOWED> flag to obtain the "
"set of nodes that are allowed by the current cpuset.  Note that this "
"information is subject to change at any time by manual or automatic "
"reconfiguration of the cpuset."
msgstr ""
"現在の CPU 集合で許可されているノードの集合を取得するには、フラグ "
"B<MPOL_F_MEMS_ALLOWED> を指定して B<get_mempolicy>(2)  を使用すればよい。 取"
"得した情報は、CPU 集合の手動または自動での再構成により いつ何時変化してしまう"
"か分からない。"

#. type: Plain text
#: build/C/man2/move_pages.2:219
msgid ""
"Use of this function may result in pages whose location (node) violates the "
"memory policy established for the specified addresses (See B<mbind>(2))  and/"
"or the specified process (See B<set_mempolicy>(2)).  That is, memory policy "
"does not constrain the destination nodes used by B<move_pages>()."
msgstr ""
"この関数を使用すると、ページの位置 (ノード) が 指定されたアドレスに対して設定"
"されたメモリポリシー (B<mbind>(2)  参照) や指定されたプロセスに対して設定され"
"たメモリポリシー (B<set_mempolicy>(2)  参照) に違反してしまう可能性がある。 "
"つまり、メモリポリシーは B<move_pages>()  で使われる移動先ノードを制限しない"
"ということである。"

#. type: Plain text
#: build/C/man2/move_pages.2:235
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numa_stat>"
"(8)"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<set_mempolicy>(2), B<numa>(3), "
"B<numa_maps>(5), B<cpuset>(7), B<numa>(7), B<migratepages>(8), B<numa_stat>"
"(8)"

#. type: TH
#: build/C/man7/numa.7:27
#, no-wrap
msgid "NUMA"
msgstr "NUMA"

#. type: Plain text
#: build/C/man7/numa.7:30
msgid "numa - overview of Non-Uniform Memory Architecture"
msgstr "numa - overview of Non-Uniform Memory Architecture"

#. type: Plain text
#: build/C/man7/numa.7:41
msgid ""
"Non-Uniform Memory Access (NUMA) refers to multiprocessor systems whose "
"memory is divided into multiple memory nodes.  The access time of a memory "
"node depends on the relative locations of the accessing CPU and the accessed "
"node.  (This contrasts with a symmetric multiprocessor system, where the "
"access time for all of the memory is the same for all CPUs.)  Normally, each "
"CPU on a NUMA system has a local memory node whose contents can be accessed "
"faster than the memory in the node local to another CPU or the memory on a "
"bus shared by all CPUs."
msgstr ""
"Non-Uniform Memory Access (NUMA) refers to multiprocessor systems whose "
"memory is divided into multiple memory nodes.  The access time of a memory "
"node depends on the relative locations of the accessing CPU and the accessed "
"node.  (This contrasts with a symmetric multiprocessor system, where the "
"access time for all of the memory is the same for all CPUs.)  Normally, each "
"CPU on a NUMA system has a local memory node whose contents can be accessed "
"faster than the memory in the node local to another CPU or the memory on a "
"bus shared by all CPUs."

#. type: SS
#: build/C/man7/numa.7:41
#, no-wrap
msgid "NUMA system calls"
msgstr "NUMA system calls"

#. type: Plain text
#: build/C/man7/numa.7:52
msgid ""
"The Linux kernel implements the following NUMA-related system calls: "
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2), B<move_pages>(2), and "
"B<set_mempolicy>(2).  However, applications should normally use the "
"interface provided by I<libnuma>; see \"Library Support\" below."
msgstr ""
"The Linux kernel implements the following NUMA-related system calls: "
"B<get_mempolicy>(2), B<mbind>(2), B<migrate_pages>(2), B<move_pages>(2), and "
"B<set_mempolicy>(2).  However, applications should normally use the "
"interface provided by I<libnuma>; see \"Library Support\" below."

#. type: SS
#: build/C/man7/numa.7:52
#, no-wrap
msgid "/proc/[number]/numa_maps  (since Linux 2.6.14)"
msgstr "/proc/[number]/numa_maps  (since Linux 2.6.14)"

#.  See also Changelog-2.6.14
#. type: Plain text
#: build/C/man7/numa.7:56
msgid ""
"This file displays information about a process's NUMA memory policy and "
"allocation."
msgstr ""
"This file displays information about a process's NUMA memory policy and "
"allocation."

#. type: Plain text
#: build/C/man7/numa.7:60
msgid ""
"Each line contains information about a memory range used by the process, "
"displaying\\(emamong other information\\(emthe effective memory policy for "
"that memory range and on which nodes the pages have been allocated."
msgstr ""
"Each line contains information about a memory range used by the process, "
"displaying\\(emamong other information\\(emthe effective memory policy for "
"that memory range and on which nodes the pages have been allocated."

#. type: Plain text
#: build/C/man7/numa.7:68
msgid ""
"I<numa_maps> is a read-only file.  When I</proc/E<lt>pidE<gt>/numa_maps> is "
"read, the kernel will scan the virtual address space of the process and "
"report how memory is used.  One line is displayed for each unique memory "
"range of the process."
msgstr ""
"I<numa_maps> is a read-only file.  When I</proc/E<lt>pidE<gt>/numa_maps> is "
"read, the kernel will scan the virtual address space of the process and "
"report how memory is used.  One line is displayed for each unique memory "
"range of the process."

#. type: Plain text
#: build/C/man7/numa.7:75
msgid ""
"The first field of each line shows the starting address of the memory "
"range.  This field allows a correlation with the contents of the I</proc/"
"E<lt>pidE<gt>/maps> file, which contains the end address of the range and "
"other information, such as the access permissions and sharing."
msgstr ""
"The first field of each line shows the starting address of the memory "
"range.  This field allows a correlation with the contents of the I</proc/"
"E<lt>pidE<gt>/maps> file, which contains the end address of the range and "
"other information, such as the access permissions and sharing."

#. type: Plain text
#: build/C/man7/numa.7:83
msgid ""
"The second field shows the memory policy currently in effect for the memory "
"range.  Note that the effective policy is not necessarily the policy "
"installed by the process for that memory range.  Specifically, if the "
"process installed a \"default\" policy for that range, the effective policy "
"for that range will be the process policy, which may or may not be \"default"
"\"."
msgstr ""
"The second field shows the memory policy currently in effect for the memory "
"range.  Note that the effective policy is not necessarily the policy "
"installed by the process for that memory range.  Specifically, if the "
"process installed a \"default\" policy for that range, the effective policy "
"for that range will be the process policy, which may or may not be \"default"
"\"."

#. type: Plain text
#: build/C/man7/numa.7:86
msgid ""
"The rest of the line contains information about the pages allocated in the "
"memory range, as follows:"
msgstr ""
"The rest of the line contains information about the pages allocated in the "
"memory range, as follows:"

#. type: TP
#: build/C/man7/numa.7:86
#, no-wrap
msgid "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"
msgstr "I<NE<lt>nodeE<gt>=E<lt>nr_pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:99
msgid ""
"The number of pages allocated on I<E<lt>nodeE<gt>>.  I<E<lt>nr_pagesE<gt>> "
"includes only pages currently mapped by the process.  Page migration and "
"memory reclaim may have temporarily unmapped pages associated with this "
"memory range.  These pages may only show up again after the process has "
"attempted to reference them.  If the memory range represents a shared memory "
"area or file mapping, other processes may currently have additional pages "
"mapped in a corresponding memory range."
msgstr ""
"The number of pages allocated on I<E<lt>nodeE<gt>>.  I<E<lt>nr_pagesE<gt>> "
"includes only pages currently mapped by the process.  Page migration and "
"memory reclaim may have temporarily unmapped pages associated with this "
"memory range.  These pages may only show up again after the process has "
"attempted to reference them.  If the memory range represents a shared memory "
"area or file mapping, other processes may currently have additional pages "
"mapped in a corresponding memory range."

#. type: TP
#: build/C/man7/numa.7:99
#, no-wrap
msgid "I<file=E<lt>filenameE<gt>>"
msgstr "I<file=E<lt>filenameE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:105
msgid ""
"The file backing the memory range.  If the file is mapped as private, write "
"accesses may have generated COW (Copy-On-Write) pages in this memory range.  "
"These pages are displayed as anonymous pages."
msgstr ""
"The file backing the memory range.  If the file is mapped as private, write "
"accesses may have generated COW (Copy-On-Write) pages in this memory range.  "
"These pages are displayed as anonymous pages."

#. type: TP
#: build/C/man7/numa.7:105
#, no-wrap
msgid "I<heap>"
msgstr "I<heap>"

#. type: Plain text
#: build/C/man7/numa.7:108
msgid "Memory range is used for the heap."
msgstr "Memory range is used for the heap."

#. type: TP
#: build/C/man7/numa.7:108
#, no-wrap
msgid "I<stack>"
msgstr "I<stack>"

#. type: Plain text
#: build/C/man7/numa.7:111
msgid "Memory range is used for the stack."
msgstr "Memory range is used for the stack."

#. type: TP
#: build/C/man7/numa.7:111
#, no-wrap
msgid "I<huge>"
msgstr "I<huge>"

#. type: Plain text
#: build/C/man7/numa.7:115
msgid ""
"Huge memory range.  The page counts shown are huge pages and not regular "
"sized pages."
msgstr ""
"Huge memory range.  The page counts shown are huge pages and not regular "
"sized pages."

#. type: TP
#: build/C/man7/numa.7:115
#, no-wrap
msgid "I<anon=E<lt>pagesE<gt>>"
msgstr "I<anon=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:118
msgid "The number of anonymous page in the range."
msgstr "The number of anonymous page in the range."

#. type: TP
#: build/C/man7/numa.7:118
#, no-wrap
msgid "I<dirty=E<lt>pagesE<gt>>"
msgstr "I<dirty=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:121
msgid "Number of dirty pages."
msgstr "Number of dirty pages."

#. type: TP
#: build/C/man7/numa.7:121
#, no-wrap
msgid "I<mapped=E<lt>pagesE<gt>>"
msgstr "I<mapped=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:128
msgid ""
"Total number of mapped pages, if different from I<dirty> and I<anon> pages."
msgstr ""
"Total number of mapped pages, if different from I<dirty> and I<anon> pages."

#. type: TP
#: build/C/man7/numa.7:128
#, no-wrap
msgid "I<mapmax=E<lt>countE<gt>>"
msgstr "I<mapmax=E<lt>countE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:134
msgid ""
"Maximum mapcount (number of processes mapping a single page) encountered "
"during the scan.  This may be used as an indicator of the degree of sharing "
"occurring in a given memory range."
msgstr ""
"Maximum mapcount (number of processes mapping a single page) encountered "
"during the scan.  This may be used as an indicator of the degree of sharing "
"occurring in a given memory range."

#. type: TP
#: build/C/man7/numa.7:134
#, no-wrap
msgid "I<swapcache=E<lt>countE<gt>>"
msgstr "I<swapcache=E<lt>countE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:137
msgid "Number of pages that have an associated entry on a swap device."
msgstr "Number of pages that have an associated entry on a swap device."

#. type: TP
#: build/C/man7/numa.7:137
#, no-wrap
msgid "I<active=E<lt>pagesE<gt>>"
msgstr "I<active=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:143
msgid ""
"The number of pages on the active list.  This field is only shown if "
"different from the number of pages in this range.  This means that some "
"inactive pages exist in the memory range that may be removed from memory by "
"the swapper soon."
msgstr ""
"The number of pages on the active list.  This field is only shown if "
"different from the number of pages in this range.  This means that some "
"inactive pages exist in the memory range that may be removed from memory by "
"the swapper soon."

#. type: TP
#: build/C/man7/numa.7:143
#, no-wrap
msgid "I<writeback=E<lt>pagesE<gt>>"
msgstr "I<writeback=E<lt>pagesE<gt>>"

#. type: Plain text
#: build/C/man7/numa.7:146
msgid "Number of pages that are currently being written out to disk."
msgstr "Number of pages that are currently being written out to disk."

#. type: Plain text
#: build/C/man7/numa.7:153
msgid ""
"The Linux NUMA system calls and I</proc> interface are only available if the "
"kernel was configured and built with the B<CONFIG_NUMA> option."
msgstr ""
"The Linux NUMA system calls and I</proc> interface are only available if the "
"kernel was configured and built with the B<CONFIG_NUMA> option."

#. type: SS
#: build/C/man7/numa.7:153
#, no-wrap
msgid "Library Support"
msgstr "Library Support"

#. type: Plain text
#: build/C/man7/numa.7:162
msgid ""
"Link with I<-lnuma> to get the system call definitions.  I<libnuma> and the "
"required I<E<lt>numaif.hE<gt>> header are available in the I<numactl> "
"package."
msgstr ""
"Link with I<-lnuma> to get the system call definitions.  I<libnuma> and the "
"required I<E<lt>numaif.hE<gt>> header are available in the I<numactl> "
"package."

#. type: Plain text
#: build/C/man7/numa.7:178
msgid ""
"However, applications should not use these system calls directly.  Instead, "
"the higher level interface provided by the B<numa>(3)  functions in the "
"I<numactl> package is recommended.  The I<numactl> package is available at "
"I<ftp://oss.sgi.com/www/projects/libnuma/download/>.  The package is also "
"included in some Linux distributions.  Some distributions include the "
"development library and header in the separate I<numactl-devel> package."
msgstr ""
"However, applications should not use these system calls directly.  Instead, "
"the higher level interface provided by the B<numa>(3)  functions in the "
"I<numactl> package is recommended.  The I<numactl> package is available at "
"I<ftp://oss.sgi.com/www/projects/libnuma/download/>.  The package is also "
"included in some Linux distributions.  Some distributions include the "
"development library and header in the separate I<numactl-devel> package."

#. type: Plain text
#: build/C/man7/numa.7:180
msgid "No standards govern NUMA interfaces."
msgstr "No standards govern NUMA interfaces."

#. type: Plain text
#: build/C/man7/numa.7:188
msgid ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<mbind>(2), B<move_pages>(2), B<set_mempolicy>(2), "
"B<numa>(3), B<cpuset>(7), B<numactl>(8)"

#. type: TH
#: build/C/man2/set_mempolicy.2:25
#, no-wrap
msgid "SET_MEMPOLICY"
msgstr "SET_MEMPOLICY"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:28
msgid ""
"set_mempolicy - set default NUMA memory policy for a process and its children"
msgstr ""
"set_mempolicy - プロセスとその子プロセスの NUMA メモリの デフォルトポリシーを"
"設定する"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:34
#, no-wrap
msgid ""
"B<int set_mempolicy(int >I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<);>\n"
msgstr ""
"B<int set_mempolicy(int >I<mode>B<, unsigned long *>I<nodemask>B<,>\n"
"B<                  unsigned long >I<maxnode>B<);>\n"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:47
msgid ""
"B<set_mempolicy>()  sets the NUMA memory policy of the calling process, "
"which consists of a policy mode and zero or more nodes, to the values "
"specified by the I<mode>, I<nodemask> and I<maxnode> arguments."
msgstr ""
"B<set_mempolicy>()  は、呼び出し元プロセスの NUMA ポリシーを I<policy> に設定"
"する。 NUMA ポリシーはポリシーモードと 0 個以上のノードから構成され、 設定内"
"容は引き数 I<mode>, I<nodemask>, I<maxnode> により指定される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:73
msgid ""
"This system call defines the default policy for the process.  The process "
"policy governs allocation of pages in the process's address space outside of "
"memory ranges controlled by a more specific policy set by B<mbind>(2).  The "
"process default policy also controls allocation of any pages for memory "
"mapped files mapped using the B<mmap>(2)  call with the B<MAP_PRIVATE> flag "
"and that are only read [loaded] from by the process and of memory mapped "
"files mapped using the B<mmap>(2)  call with the B<MAP_SHARED> flag, "
"regardless of the access type.  The policy is only applied when a new page "
"is allocated for the process.  For anonymous memory this is when the page is "
"first touched by the application."
msgstr ""
"B<set_mempolicy>()  は、プロセスのデフォルトポリシーを定める。 プロセスのポリ"
"シーは、 B<mbind>(2)  で設定される特定のポリシーにより制御されるメモリ領域以"
"外の プロセスのアドレス空間におけるページの割り当てに適用される。 プロセスの"
"デフォルトポリシーは、 B<MAP_PRIVATE> フラグを指定した B<mmap>(2)  を使って"
"マップされたメモリマップ・ファイルに対する読み出し専用 (ロードされるだけ) の"
"ページの割り当てにも適用される。 また、 B<MAP_SHARED> フラグを指定した "
"B<mmap>(2)  を使ってマップされたメモリマップ・ファイルに対するページの割り当"
"てにも 適用される (この場合はページのアクセス種別に関わらず適用される) 。 設"
"定したポリシーは、プロセスに新規のページが割り当てられるときにのみ 適用され"
"る。無名メモリ (anonymous memory) の場合、新規ページの割り当ては アプリケー"
"ションが初めてページにアクセスした際に行われる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:87
msgid ""
"The I<mode> argument must specify one of B<MPOL_DEFAULT>, B<MPOL_BIND>, "
"B<MPOL_INTERLEAVE> or B<MPOL_PREFERRED>.  All modes except B<MPOL_DEFAULT> "
"require the caller to specify via the I<nodemask> argument one or more nodes."
msgstr ""
"I<mode> 引き数には B<MPOL_DEFAULT>, B<MPOL_BIND>, B<MPOL_INTERLEAVE>, "
"B<MPOL_PREFERRED> のいずれか一つを指定してしなければならない。 "
"B<MPOL_DEFAULT> 以外のポリシーの場合、呼び出し元は I<nodemask> 引き数で一つ以"
"上のノードを指定する必要がある。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:95
msgid ""
"The I<mode> argument may also include an optional I<mode flag>.  The "
"supported I<mode flags> are:"
msgstr ""
"I<mode> 引き数には、追加で I<モードフラグ> を含めることもできる。 サポートさ"
"れている I<モードフラグ> は以下の通りである。"

#. type: TP
#: build/C/man2/set_mempolicy.2:95
#, no-wrap
msgid "B<MPOL_F_STATIC_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_STATIC_NODES> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:105
msgid ""
"A nonempty I<nodemask> specifies physical node ids.  Linux does will not "
"remap the I<nodemask> when the process moves to a different cpuset context, "
"nor when the set of nodes allowed by the process's current cpuset context "
"changes."
msgstr ""
"空でない I<nodemask> は、物理ノード ID である。 Linux では、そのプロセスが異"
"なる CPU 集合コンテキスト (cpuset context)  に移動した場合でも、そのプロセス"
"の現在の CPU 集合コンテキストで 許可されているノード集合が変化した場合でも、 "
"I<nodemask> をマッピングし直すことはない。"

#. type: TP
#: build/C/man2/set_mempolicy.2:105
#, no-wrap
msgid "B<MPOL_F_RELATIVE_NODES> (since Linux 2.6.26)"
msgstr "B<MPOL_F_RELATIVE_NODES> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:131
msgid ""
"I<nodemask> points to a bit mask of node IDs that contains up to I<maxnode> "
"bits.  The bit mask size is rounded to the next multiple of I<sizeof"
"(unsigned long)>, but the kernel will only use bits up to I<maxnode>.  A "
"NULL value of I<nodemask> or a I<maxnode> value of zero specifies the empty "
"set of nodes.  If the value of I<maxnode> is zero, the I<nodemask> argument "
"is ignored."
msgstr ""
"I<nodemask> は、最大で I<maxnode> ビットから構成されるノード ID のビットマス"
"クを指す。 ビットマスクの大きさは、直近の I<sizeof(unsigned long)> の倍数に切"
"り上げられるが、カーネルが使用するのは I<maxnode> 個までのビットだけである。 "
"NULL 値の I<nodemask> もしくは値が 0 の I<maxnode> はノードの空集合を表す。 "
"I<maxnode> の値が 0 の場合、 I<nodemask> 引き数は無視される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:152
msgid ""
"Where a I<nodemask> is required, it must contain at least one node that is "
"on-line, allowed by the process's current cpuset context, [unless the "
"B<MPOL_F_STATIC_NODES> mode flag is specified], and contains memory.  If the "
"B<MPOL_F_STATIC_NODES> is set in I<mode> and a required I<nodemask> contains "
"no nodes that are allowed by the process's current cpuset context, the "
"memory policy reverts to I<local allocation>.  This effectively overrides "
"the specified policy until the process's cpuset context includes one or more "
"of the nodes specified by I<nodemask>."
msgstr ""
"I<nodemask> が必須の場面では、 I<nodemask> に、オンラインで、そのプロセスの現"
"在の CPU 集合コンテキストで 許可されており (B<MPOL_F_STATIC_NODES> モードフラ"
"グが指定されていない場合)、メモリがあるノードが 少なくとも一つ入っていなけれ"
"ばならない。 I<mode> に B<MPOL_F_STATIC_NODES> がセットされ、 I<nodemask> が"
"必須の場面で、 I<nodemask> に、そのプロセスの現在の CPU 集合コンテキストで許"
"可されたノードが 一つも含まれていない場合には、メモリのポリシーとしてデフォル"
"トの 「ローカルから割り当て (local allocation)」が適用される。 そのプロセス"
"の CPU 集合コンテキストが I<nodemask> で指定されたノードを少なくとも一つ含む"
"ようになるまでは、 結果的に指定された動作が上書きされることになる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:163
msgid ""
"The B<MPOL_DEFAULT> mode specifies that any nondefault process memory policy "
"be removed, so that the memory policy \"falls back\" to the system default "
"policy.  The system default policy is \"local allocation\"-- i.e., allocate "
"memory on the node of the CPU that triggered the allocation.  I<nodemask> "
"must be specified as NULL.  If the \"local node\" contains no free memory, "
"the system will attempt to allocate memory from a \"near by\" node."
msgstr ""
"B<MPOL_DEFAULT> モードは、デフォルトではないプロセスのメモリポリシーを削除す"
"ることを 指定するものである。これにより、メモリポリシーはシステムの デフォル"
"トポリシーに「戻る」ことになる。 システムのデフォルトポリシーは「ローカルから"
"の割り当て (local allocation)」、 つまりメモリ割り当てのきっかけとなった CPU "
"のノードのメモリが割り当てられる。 I<nodemask> には NULL を指定しなければなら"
"ない。 「自ノード (local node)」に空きメモリが全くない場合、システムは 「近く"
"の (near by) ノード」からメモリを割り当てようと試みる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:180
msgid ""
"The B<MPOL_BIND> mode defines a strict policy that restricts memory "
"allocation to the nodes specified in I<nodemask>.  If I<nodemask> specifies "
"more than one node, page allocations will come from the node with the lowest "
"numeric node ID first, until that node contains no free memory.  Allocations "
"will then come from the node with the next highest node ID specified in "
"I<nodemask> and so forth, until none of the specified nodes contain free "
"memory.  Pages will not be allocated from any node not specified in the "
"I<nodemask>."
msgstr ""
"B<MPOL_BIND> モードは厳密なポリシーで、メモリ割り当ては I<nodemask> に指定さ"
"れたノードに限定される。 I<nodemask> に 2 個以上のノードが指定された場合、"
"ページの割り当ては ノード ID が数字として最小のノードから開始され、 そのノー"
"ドに空きメモリがなくなるまでそのノードから ページ割り当てが行われる。そのノー"
"ドに空きメモリがなくなったら、 次に小さなノード ID を持つノードからページ割り"
"当てが行われる。 これを、 I<nodemask> で指定された全てのノードで空きメモリが"
"なくなるまで繰り返す。 I<nodemask> で指定された以外のノードからはページの割り"
"当ては行われない。"

#.  NOTE:  the following sentence doesn't make sense in the context
#.  of set_mempolicy() -- no memory area specified.
#.  To be effective the memory area should be fairly large,
#.  at least 1MB or bigger.
#. type: Plain text
#: build/C/man2/set_mempolicy.2:194
msgid ""
"B<MPOL_INTERLEAVE> interleaves page allocations across the nodes specified "
"in I<nodemask> in numeric node ID order.  This optimizes for bandwidth "
"instead of latency by spreading out pages and memory accesses to those pages "
"across multiple nodes.  However, accesses to a single page will still be "
"limited to the memory bandwidth of a single node."
msgstr ""
"B<MPOL_INTERLEAVE> では、ページ割り当てを I<nodemask> に指定されたノードの間"
"でノード ID の数字順で交互に行う。 このポリシーでは、複数のノードにページを広"
"げて配置し、これらのページへのメモリ アクセスを分散することで、遅延ではなく、"
"帯域を最適化する。 ただし、一つのページへのアクセスに関しては依然として一つの"
"ノードのメモリ帯域 が上限となる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:211
msgid ""
"B<MPOL_PREFERRED> sets the preferred node for allocation.  The kernel will "
"try to allocate pages from this node first and fall back to \"near by\" "
"nodes if the preferred node is low on free memory.  If I<nodemask> specifies "
"more than one node ID, the first node in the mask will be selected as the "
"preferred node.  If the I<nodemask> and I<maxnode> arguments specify the "
"empty set, then the policy specifies \"local allocation\" (like the system "
"default policy discussed above)."
msgstr ""
"B<MPOL_PREFERRED> は、割り当て時に優先されるノード (preferred node) を設定す"
"る。 カーネルはまず優先ノードからページ割り当てを行おうとし、 優先ノードに空"
"きメモリが少ない場合に「近くの (near by)」ノードから 割り当てを行う。 "
"I<nodemask> に複数のノード ID が指定された場合は、 I<nodemask> 内の最初のノー"
"ドが優先ノードとして選択される。 引き数 I<nodemask>, I<maxnode> で空集合が指"
"定された場合は、ポリシーは (上述のシステムの デフォルトポリシーと同様に) "
"「ローカルからの割り当て」となる。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:218
msgid ""
"The process memory policy is preserved across an B<execve>(2), and is "
"inherited by child processes created using B<fork>(2)  or B<clone>(2)."
msgstr ""
"プロセスのメモリポリシーは B<execve>(2)  の前後で保持され、 B<fork>(2)  や "
"B<clone>(2)  を使って作成された子プロセスに継承される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:225
msgid ""
"On success, B<set_mempolicy>()  returns 0; on error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<set_mempolicy>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:270
msgid ""
"I<mode> is invalid.  Or, I<mode> is B<MPOL_DEFAULT> and I<nodemask> is "
"nonempty, or I<mode> is B<MPOL_BIND> or B<MPOL_INTERLEAVE> and I<nodemask> "
"is empty.  Or, I<maxnode> specifies more than a page worth of bits.  Or, "
"I<nodemask> specifies one or more node IDs that are greater than the maximum "
"supported node ID.  Or, none of the node IDs specified by I<nodemask> are on-"
"line and allowed by the process's current cpuset context, or none of the "
"specified nodes contain memory.  Or, the I<mode> argument specified both "
"B<MPOL_F_STATIC_NODES> and B<MPOL_F_RELATIVE_NODES>."
msgstr ""
"I<mode> が不正である。 I<mode> が B<MPOL_DEFAULT> で、 I<nodemask> が空ではな"
"い。 I<mode> が B<MPOL_BIND> か B<MPOL_INTERLEAVE> で、 I<nodemask> が空であ"
"る。 I<maxnode> で実際に意味があるビット数より多くのビット数が指定された。 "
"I<nodemask> に、サポートされている最大ノード ID より大きいノードが指定され"
"た。 I<nodemask> に、オンラインで、かつそのプロセスの現在の CPU 集合コンテキ"
"ストで 許可されているノードが一つも含まれていないか、 メモリを含むノードが一"
"つも指定されていない。 I<mode> 引き数に B<MPOL_F_STATIC_NODES> と "
"B<MPOL_F_RELATIVE_NODES> の両方が指定された。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:277
msgid ""
"The B<set_mempolicy>(), system call was added to the Linux kernel in version "
"2.6.7."
msgstr ""
"B<set_mempolicy>()  システムコールはバージョン 2.6.7 で Linux カーネルに追加"
"された。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:284
msgid ""
"Process policy is not remembered if the page is swapped out.  When such a "
"page is paged back in, it will use the policy of the process or memory range "
"that is in effect at the time the page is allocated."
msgstr ""
"ページがスワップ・アウトされる場合には、 プロセスポリシーの設定は推奨されな"
"い。 スワップ・アウトされたページがページ・インする際にも、 ページ割り当て時"
"に適用されるプロセスポリシーやメモリ領域ポリシーが 使用される。"

#. type: Plain text
#: build/C/man2/set_mempolicy.2:296
msgid ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"
msgstr ""
"B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), B<mmap>(2), B<numa>(3), "
"B<cpuset>(7), B<numa>(7), B<numactl>(8)"

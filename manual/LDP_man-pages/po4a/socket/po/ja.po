# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:17+0900\n"
"PO-Revision-Date: 2012-05-04 03:38+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/accept.2:39
#, no-wrap
msgid "ACCEPT"
msgstr "ACCEPT"

#. type: TH
#: build/C/man2/accept.2:39
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: TH
#: build/C/man2/accept.2:39 build/C/man2/bind.2:66 build/C/man2/connect.2:65
#: build/C/man2/getsockname.2:38 build/C/man2/getsockopt.2:42
#: build/C/man2/listen.2:43 build/C/man2/recv.2:39 build/C/man2/recvmmsg.2:26
#: build/C/man2/select.2:38 build/C/man2/select_tut.2:30
#: build/C/man2/send.2:38 build/C/man2/sendmmsg.2:28
#: build/C/man3/sockatmark.3:23 build/C/man2/socket.2:41
#: build/C/man7/socket.7:26 build/C/man2/socketcall.2:26
#: build/C/man2/socketpair.2:40
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/accept.2:39 build/C/man2/bind.2:66
#: build/C/man3/bindresvport.3:27 build/C/man2/connect.2:65
#: build/C/man3/getifaddrs.3:33 build/C/man2/getsockname.2:38
#: build/C/man2/getsockopt.2:42 build/C/man2/listen.2:43
#: build/C/man2/recv.2:39 build/C/man2/recvmmsg.2:26 build/C/man2/select.2:38
#: build/C/man2/select_tut.2:30 build/C/man2/send.2:38
#: build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:23
#: build/C/man2/socket.2:41 build/C/man7/socket.7:26
#: build/C/man2/socketcall.2:26 build/C/man2/socketpair.2:40
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/accept.2:40 build/C/man2/bind.2:67
#: build/C/man3/bindresvport.3:28 build/C/man2/connect.2:66
#: build/C/man3/getifaddrs.3:34 build/C/man2/getsockname.2:39
#: build/C/man2/getsockopt.2:43 build/C/man2/listen.2:44
#: build/C/man2/recv.2:40 build/C/man2/recvmmsg.2:27 build/C/man2/select.2:39
#: build/C/man2/select_tut.2:31 build/C/man2/send.2:39
#: build/C/man2/sendmmsg.2:29 build/C/man3/sockatmark.3:24
#: build/C/man2/socket.2:42 build/C/man7/socket.7:27
#: build/C/man2/socketcall.2:27 build/C/man2/socketpair.2:41
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/accept.2:42
msgid "accept - accept a connection on a socket"
msgstr "accept - ソケットへの接続を受ける"

#. type: SH
#: build/C/man2/accept.2:42 build/C/man2/bind.2:69
#: build/C/man3/bindresvport.3:30 build/C/man2/connect.2:68
#: build/C/man3/getifaddrs.3:36 build/C/man2/getsockname.2:41
#: build/C/man2/getsockopt.2:45 build/C/man2/listen.2:46
#: build/C/man2/recv.2:42 build/C/man2/recvmmsg.2:29 build/C/man2/select.2:42
#: build/C/man2/select_tut.2:34 build/C/man2/send.2:41
#: build/C/man2/sendmmsg.2:31 build/C/man3/sockatmark.3:26
#: build/C/man2/socket.2:44 build/C/man7/socket.7:29
#: build/C/man2/socketcall.2:29 build/C/man2/socketpair.2:43
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/accept.2:46 build/C/man2/bind.2:73
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>          /* 「注意」参照 */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/accept.2:48
#, no-wrap
msgid "B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr "B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/accept.2:51
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/accept.2:54
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"

#. type: SH
#: build/C/man2/accept.2:55 build/C/man2/bind.2:77
#: build/C/man3/bindresvport.3:37 build/C/man2/connect.2:77
#: build/C/man3/getifaddrs.3:45 build/C/man2/getsockname.2:48
#: build/C/man2/getsockopt.2:56 build/C/man2/listen.2:54
#: build/C/man2/recv.2:57 build/C/man2/recvmmsg.2:39 build/C/man2/select.2:81
#: build/C/man2/select_tut.2:73 build/C/man2/send.2:56
#: build/C/man2/sendmmsg.2:40 build/C/man3/sockatmark.3:40
#: build/C/man2/socket.2:50 build/C/man7/socket.7:33
#: build/C/man2/socketcall.2:31 build/C/man2/socketpair.2:50
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/accept.2:70
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""
"B<accept>()  システムコールは、接続指向のソケット型 (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  で用いられる。 この関数は、接続待ちソケット I<socket> 宛"
"ての保留状態の接続要求が入っているキューから 先頭の接続要求を取り出し、接続済"
"みソケットを新規に生成し、 そのソケットを参照する新しいファイル・ディスクリプ"
"タを返す。 新規に生成されたソケットは、接続待ち (listen) 状態ではない。 もと"
"もとのソケット I<sockfd> はこの呼び出しによって影響を受けない。"

#. type: Plain text
#: build/C/man2/accept.2:79
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""
"引き数 I<sockfd> は、 B<socket>(2)  によって生成され、 B<bind>(2)  によって"
"ローカルアドレスにバインドされ、 B<listen>(2)  を経て接続を待っているソケット"
"である。"

#. type: Plain text
#: build/C/man2/accept.2:97
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""
"I<addr> 引き数は I<sockaddr> 構造体へのポインタである。 この構造体には接続相"
"手のソケットのアドレスが入っている。 I<addr> 引き数で返されるアドレスの正確な"
"フォーマットは、 ソケットのアドレス種別によって変わる (B<socket>(2)  およびそ"
"れぞれのプロトコルの man ページを参照)。 I<addr> が NULL の場合、 I<addr> に"
"は何も入らない。この場合、 I<addrlen> は使用されず、この引き数は NULL にして"
"おくべきである。"

#. type: Plain text
#: build/C/man2/accept.2:105
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""
"I<addrlen> 引き数は入出力両用の引き数である。呼び出し時には、呼び出し元が "
"I<addr> が指す構造体のサイズ (バイト単位) で初期化しておかなければならない。 "
"返ってくる時には、接続相手のアドレスの実際の大きさが格納される。"

#. type: Plain text
#: build/C/man2/accept.2:110 build/C/man2/getsockname.2:65
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""
"渡されたバッファが小さ過ぎた場合は、返されるアドレスの末尾が切り詰められ"
"る。\n"
"この場合には、 I<addrlen> には、呼び出し時に指定された値よりも大きな値が格納"
"される。"

#. type: Plain text
#: build/C/man2/accept.2:123
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""
"キューに保留となっている接続要求がなく、 かつソケットが非停止になっていないと"
"きは、 B<accept>()  は接続が発生するまで呼び出し元を停止 (block) する。 ソ"
"ケットが非停止になっていて、 待ち状態の接続要求がキューに無いときは、 "
"B<accept>()  はエラー B<EAGAIN> か B<EWOULDBLOCK> で失敗する。"

#. type: Plain text
#: build/C/man2/accept.2:137
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2)  or B<poll>(2).  A readable event will be delivered when a new "
"connection is attempted and you may then call B<accept>()  to get a socket "
"for that connection.  Alternatively, you can set the socket to deliver "
"B<SIGIO> when activity occurs on a socket; see B<socket>(7)  for details."
msgstr ""
"ソケットへの接続到着を知るには、 B<select>(2)  または B<poll>(2)  を用いれば"
"よい。 新しい接続要求が来るとソケットは読み込み可能になるので、 そうしたら "
"B<accept>()  を呼んでその接続に対するソケットを取得すればよい。 あるいはソ"
"ケットに設定を行い、何らかのアクションがあったときに B<SIGIO> を配送 "
"(deliver) させるようにすることもできる。詳細は B<socket>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/accept.2:150
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECNet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently only DECNet has these "
"semantics on Linux."
msgstr ""
"明示的な接続確認 (confirmation) を必要とするようなプロトコル (DECNet など) で"
"は、 B<accept>()  は単に次の接続要求をキューから取り出すだけであり、 接続確認"
"は行わないことに注意せよ。接続確認は、 新しいファイル・ディスクリプタに対す"
"る 通常の読み取り/書き込みによってなされ、接続拒否 (rejection)  は新しいソ"
"ケットをクローズすることによってなされる。 現在のところ、 Linux 上でこれらの"
"セマンティクスを持つのは DECNet だけである。"

#. type: Plain text
#: build/C/man2/accept.2:160
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""
"I<flags> が 0 の場合、 B<accept4>()  は B<accept>()  と同じである。 I<flags> "
"に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさせることが"
"できる。"

#. type: TP
#: build/C/man2/accept.2:160 build/C/man2/socket.2:162
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr "B<SOCK_NONBLOCK>"

#. type: Plain text
#: build/C/man2/accept.2:168 build/C/man2/socket.2:170
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成されるオープンファイル記述 (open file description) の "
"B<O_NONBLOCK> ファイルステータスフラグをセットする。 このフラグを使うこと"
"で、 B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなく"
"なる。"

#. type: TP
#: build/C/man2/accept.2:168 build/C/man2/socket.2:170
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr "B<SOCK_CLOEXEC>"

#. type: Plain text
#: build/C/man2/accept.2:178 build/C/man2/socket.2:180
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプタに対して close-on-exec (B<FD_CLOEXEC>)  フラグを"
"セットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: SH
#: build/C/man2/accept.2:178 build/C/man2/bind.2:150
#: build/C/man3/bindresvport.3:64 build/C/man2/connect.2:125
#: build/C/man3/getifaddrs.3:137 build/C/man2/getsockname.2:65
#: build/C/man2/getsockopt.2:129 build/C/man2/listen.2:80
#: build/C/man2/recv.2:386 build/C/man2/recvmmsg.2:144
#: build/C/man2/select.2:289 build/C/man2/select_tut.2:483
#: build/C/man2/send.2:273 build/C/man2/sendmmsg.2:119
#: build/C/man3/sockatmark.3:49 build/C/man2/socket.2:312
#: build/C/man2/socketpair.2:67
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/accept.2:185
msgid ""
"On success, these system calls return a nonnegative integer that is a "
"descriptor for the accepted socket.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールは 受け付けたソケットのディスクリプタであ"
"る非負の整数値を返す。 エラーが発生した場合は -1 を返し、 I<errno> を適切に設"
"定する。"

#. type: SS
#: build/C/man2/accept.2:185
#, no-wrap
msgid "Error Handling"
msgstr "エラー処理"

#. type: Plain text
#: build/C/man2/accept.2:212
#, fuzzy
#| msgid ""
#| "Linux B<accept>()  (and B<accept4>())  passes already-pending network "
#| "errors on the new socket as an error code from B<accept>().  This "
#| "behavior differs from other BSD socket implementations.  For reliable "
#| "operation the application should detect the network errors defined for "
#| "the protocol after B<accept>()  and treat them like B<EAGAIN> by "
#| "retrying.  In case of TCP/IP these are B<ENETDOWN>, B<EPROTO>, "
#| "B<ENOPROTOOPT>, B<EHOSTDOWN>, B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, "
#| "and B<ENETUNREACH>."
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of TCP/"
"IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""
"Linux の B<accept>()  (と B<accept4>())  は、新しいソケットにおける、発生済み"
"のネットワークエラーを B<accept>()  からのエラーコードとして渡す。 この振舞い"
"は BSD ソケットの実装とは異なる。 信頼性の高い動作を行うためには、 アプリケー"
"ションはプロトコルで定義されているネットワークエラーの検知を B<accept>()  の"
"あとに行い、それらのエラーを B<EAGAIN> と同じように扱い、再試行 (retry) を行"
"うべきである。 TCP/IP では、以下のエラーが該当する: B<ENETDOWN>, B<EPROTO>, "
"B<ENOPROTOOPT>, B<EHOSTDOWN>, B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, "
"B<ENETUNREACH>"

#. type: SH
#: build/C/man2/accept.2:212 build/C/man2/bind.2:155
#: build/C/man3/bindresvport.3:69 build/C/man2/connect.2:130
#: build/C/man3/getifaddrs.3:144 build/C/man2/getsockname.2:70
#: build/C/man2/getsockopt.2:134 build/C/man2/listen.2:85
#: build/C/man2/recv.2:391 build/C/man2/recvmmsg.2:152
#: build/C/man2/select.2:306 build/C/man2/send.2:278
#: build/C/man2/sendmmsg.2:133 build/C/man3/sockatmark.3:54
#: build/C/man2/socket.2:317 build/C/man2/socketpair.2:72
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/accept.2:213 build/C/man2/recv.2:396 build/C/man2/send.2:294
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> または B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/accept.2:221
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""
"ソケットが非停止になっていて、 かつ受付け対象の接続が存在しない。 "
"POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めており、 これら 2 つ"
"の定数が同じ値を持つことも求めていない。 したがって、移植性が必要なアプリケー"
"ションでは、両方の可能性を 確認すべきである。"

#. type: TP
#: build/C/man2/accept.2:221 build/C/man2/bind.2:163
#: build/C/man2/connect.2:167 build/C/man2/getsockname.2:71
#: build/C/man2/getsockopt.2:135 build/C/man2/listen.2:89
#: build/C/man2/recv.2:405 build/C/man2/select.2:307 build/C/man2/send.2:302
#: build/C/man3/sockatmark.3:55
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/accept.2:224
msgid "The descriptor is invalid."
msgstr "ディスクリプタが不正。"

#. type: TP
#: build/C/man2/accept.2:224
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr "B<ECONNABORTED>"

#. type: Plain text
#: build/C/man2/accept.2:227
msgid "A connection has been aborted."
msgstr "接続が中止された。"

#. type: TP
#: build/C/man2/accept.2:227 build/C/man2/bind.2:189
#: build/C/man2/connect.2:173 build/C/man2/getsockname.2:76
#: build/C/man2/getsockopt.2:140 build/C/man2/recv.2:414
#: build/C/man2/send.2:311 build/C/man2/socketpair.2:76
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/accept.2:232
msgid ""
"The I<addr> argument is not in a writable part of the user address space."
msgstr "I<addr> 引き数がユーザアドレス空間の書き込み可能領域にない。"

#. type: TP
#: build/C/man2/accept.2:232 build/C/man2/connect.2:201
#: build/C/man2/recv.2:418 build/C/man2/select.2:312 build/C/man2/send.2:314
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/accept.2:237
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""
"有効な接続が到着する前に捕捉されたシグナルによって システムコールが中断され"
"た。 B<signal>(7)  参照。"

#. type: TP
#: build/C/man2/accept.2:237 build/C/man2/accept.2:242 build/C/man2/bind.2:167
#: build/C/man2/bind.2:193 build/C/man2/getsockname.2:82
#: build/C/man2/getsockopt.2:150 build/C/man2/recv.2:423
#: build/C/man2/recvmmsg.2:156 build/C/man2/select.2:316
#: build/C/man2/send.2:318 build/C/man3/sockatmark.3:59
#: build/C/man2/socket.2:325 build/C/man2/socket.2:328
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/accept.2:242
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""
"ソケットが接続待ち状態ではない。もしくは、 I<addrlen> が不正である (例えば、"
"負の場合など)。"

#. type: Plain text
#: build/C/man2/accept.2:247
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr "(B<accept4>())  I<flags> に不正な値が指定されている。"

#. type: TP
#: build/C/man2/accept.2:247 build/C/man2/socket.2:333
#: build/C/man2/socketpair.2:81
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/accept.2:250
msgid "The per-process limit of open file descriptors has been reached."
msgstr "1プロセスがオープンできるファイル・ディスクリプタ数の上限に達した。"

#. type: TP
#: build/C/man2/accept.2:250 build/C/man2/socket.2:336
#: build/C/man2/socketpair.2:84
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/accept.2:253 build/C/man2/socket.2:339
#: build/C/man2/socketpair.2:87
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム全体の上限に達していた。"

#. type: TP
#: build/C/man2/accept.2:253
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr "B<ENOBUFS>, B<ENOMEM>"

#. type: Plain text
#: build/C/man2/accept.2:258
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""
"メモリが足りない。 多くの場合は、システムメモリが足りないわけではなく、 ソ"
"ケットバッファの大きさによるメモリ割り当ての制限である。"

#. type: TP
#: build/C/man2/accept.2:258 build/C/man2/bind.2:172
#: build/C/man2/connect.2:213 build/C/man2/getsockname.2:90
#: build/C/man2/getsockopt.2:164 build/C/man2/listen.2:94
#: build/C/man2/recv.2:438 build/C/man2/send.2:347
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr "B<ENOTSOCK>"

#. type: Plain text
#: build/C/man2/accept.2:261
msgid "The descriptor references a file, not a socket."
msgstr "ディスクリプタはソケットではなくファイルを参照している。"

#. type: TP
#: build/C/man2/accept.2:261 build/C/man2/listen.2:99 build/C/man2/send.2:352
#: build/C/man2/socketpair.2:87
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/accept.2:265
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr "参照しているソケットの型が B<SOCK_STREAM> でない。"

#. type: TP
#: build/C/man2/accept.2:265
#, no-wrap
msgid "B<EPROTO>"
msgstr "B<EPROTO>"

#. type: Plain text
#: build/C/man2/accept.2:268
msgid "Protocol error."
msgstr "プロトコル・エラー。"

#. type: Plain text
#: build/C/man2/accept.2:272
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr "上記に加えて、Linux の B<accept>()  は以下のエラーで失敗する:"

#. type: TP
#: build/C/man2/accept.2:272
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/accept.2:275
msgid "Firewall rules forbid connection."
msgstr "ファイアウォールのルールにより接続が禁止された。"

#. type: Plain text
#: build/C/man2/accept.2:287
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""
"この他に、新しいソケットに対するネットワークエラーが返されることもある。 これ"
"らはそれぞれのプロトコルで定義されている。 いろいろな Linux カーネルでは、 以"
"下に示すようなエラーを返すこともある。 B<ENOSR>, B<ESOCKTNOSUPPORT>, "
"B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  B<ERESTARTSYS> がトレースの最中に現れるこ"
"ともある。"

#. type: SH
#: build/C/man2/accept.2:287 build/C/man3/getifaddrs.3:157
#: build/C/man2/recvmmsg.2:160 build/C/man2/select.2:325
#: build/C/man2/sendmmsg.2:145 build/C/man3/sockatmark.3:66
#: build/C/man7/socket.7:696
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/accept.2:292
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""
"B<accept4>()  システムコールは Linux 2.6.28 以降で利用可能である。 glibc での"
"サポートはバージョン 2.10 以降で利用可能である。"

#. type: SH
#: build/C/man2/accept.2:292 build/C/man2/bind.2:220
#: build/C/man3/bindresvport.3:89 build/C/man2/connect.2:223
#: build/C/man3/getifaddrs.3:165 build/C/man2/getsockname.2:95
#: build/C/man2/getsockopt.2:169 build/C/man2/listen.2:104
#: build/C/man2/recv.2:443 build/C/man2/recvmmsg.2:165
#: build/C/man2/select.2:331 build/C/man2/send.2:366
#: build/C/man2/sendmmsg.2:150 build/C/man3/sockatmark.3:69
#: build/C/man2/socket.2:350 build/C/man2/socketcall.2:43
#: build/C/man2/socketpair.2:93
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: build/C/man2/accept.2:304
msgid ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>()  first appeared in "
"4.2BSD)."
msgstr ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>()  は 4.2BSD で初めて実装"
"された)."

#. type: Plain text
#: build/C/man2/accept.2:307
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr "B<accept4>()  は非標準の Linux による拡張である。"

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: build/C/man2/accept.2:322
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""
"Linux では、 B<accept>()  が返す新しいソケットは listen を行っているソケット"
"の ファイル状態フラグ (B<O_NONBLOCK> や B<O_ASYNC> など) を継承「しない」。 "
"この動作は標準的な BSD ソケットの実装とは異なっている。 移植性を考慮したプロ"
"グラムではファイル状態フラグが継承されるかどうかは 前提にせず、常に B<accept>"
"()  が返したソケットに対して全ての必要なフラグを明示的に設定するように すべき"
"である。"

#. type: SH
#: build/C/man2/accept.2:322 build/C/man2/bind.2:232
#: build/C/man3/bindresvport.3:92 build/C/man2/connect.2:239
#: build/C/man3/getifaddrs.3:185 build/C/man2/getsockname.2:101
#: build/C/man2/getsockopt.2:176 build/C/man2/listen.2:109
#: build/C/man2/recv.2:453 build/C/man2/select.2:346
#: build/C/man2/select_tut.2:501 build/C/man2/send.2:380
#: build/C/man2/sendmmsg.2:153 build/C/man3/sockatmark.3:71
#: build/C/man2/socket.2:364 build/C/man7/socket.7:710
#: build/C/man2/socketcall.2:46 build/C/man2/socketpair.2:101
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/accept.2:328 build/C/man2/bind.2:238
#: build/C/man2/connect.2:245 build/C/man2/getsockopt.2:182
#: build/C/man2/listen.2:135 build/C/man2/socket.2:370
#: build/C/man2/socketpair.2:122
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""
"POSIX.1-2001 では I<E<lt>sys/types.hE<gt>> のインクルードは必須とされておら"
"ず、 Linux ではこのヘッダファイルは必要ではない。 しかし、歴史的には、いくつ"
"かの実装 (BSD 系) でこのヘッダファイルが 必要であり、移植性が必要なアプリケー"
"ションではこのファイルを インクルードするのが賢明であろう。"

#. type: Plain text
#: build/C/man2/accept.2:349
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2)  or B<poll>(2)  return a readability event because the "
"connection might have been removed by an asynchronous network error or "
"another thread before B<accept>()  is called.  If this happens then the call "
"will block waiting for the next connection to arrive.  To ensure that "
"B<accept>()  never blocks, the passed socket I<sockfd> needs to have the "
"B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""
"B<SIGIO> が届けられた後や、 B<select>(2)  または B<poll>(2)  が読み込み可能イ"
"ベントを返した後に、 必ずしも待機中の接続があるとは限らない。 なぜならその接"
"続は、 B<accept>()  が呼ばれる前に、非同期的なネットワークエラーや 他のスレッ"
"ドから呼ばれた (別の) accept によって 削除されているかもしれないからである。 "
"この場合、その B<accept>()  呼び出しは停止 (block) し、次の接続の到着を待ちつ"
"づける。 B<accept>()  に停止を行わせないようにするには、引き数に渡すソケット "
"I<sockfd> に B<O_NONBLOCK> フラグをセットしておく必要がある (B<socket>(7)  を"
"見よ)。"

#. type: SS
#: build/C/man2/accept.2:349
#, no-wrap
msgid "The socklen_t type"
msgstr "socklen_t 型"

#. type: Plain text
#: build/C/man2/accept.2:359
msgid ""
"The third argument of B<accept>()  was originally declared as an I<int *> "
"(and is that under libc4 and libc5 and on many other systems like 4.x BSD, "
"SunOS 4, SGI); a POSIX.1g draft standard wanted to change it into a I<size_t "
"*>, and that is what it is for SunOS 5.  Later POSIX drafts have I<socklen_t "
"*>, and so do the Single UNIX Specification and glibc2.  Quoting Linus "
"Torvalds:"
msgstr ""
"B<accept>()  の第 3 引き数は、もともと I<int *> と宣言されていた (libc4 や "
"libc5, 4.x BSD, SunOS 4, SGI など多くのシステムではそうなっている)。 "
"POSIX.1g draft 標準は、 これを I<size_t *> に変更しようとし、SunOS 5 ではそう"
"宣言されている。 後に POSIX drafts には I<socklen_t *> が含まれるようにな"
"り、 Single UNIX Specification や glibc2 ではこのように宣言されるようになっ"
"た。 Linus Torvald の発言を引用する:"

#.  .I fails: only italicizes a single line
#. type: Plain text
#: build/C/man2/accept.2:376
msgid ""
"\"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.  "
"Anything else breaks any BSD socket layer stuff.  POSIX initially I<did> "
"make it a size_t, and I (and hopefully others, but obviously not too many) "
"complained to them very loudly indeed.  Making it a size_t is completely "
"broken, exactly because size_t very seldom is the same size as \"int\" on 64-"
"bit architectures, for example.  And it I<has> to be the same size as \"int"
"\" because that's what the BSD socket interface is.  Anyway, the POSIX "
"people eventually got a clue, and created \"socklen_t\".  They shouldn't "
"have touched it in the first place, but once they did they felt it had to "
"have a named type for some unfathomable reason (probably somebody didn't "
"like losing face over having done the original stupid thing, so they "
"silently just renamed their blunder).\""
msgstr ""
"「まともなライブラリを作りたければ、 \"socklen_t\" のサイズは int と同じにし"
"なきゃならない。 さもないと BSD ソケット層を破壊することになっちゃう。 POSIX "
"は最初こいつを size_t にしたんで、 ぼくは彼らに文句をがなりたてた (多分そうい"
"う人は他にもいたと思う。多くはなかったようだけど)。 こいつを size_t にするの"
"は完全にいかれてる。 例えば 64 ビットアーキテクチャでは、 size_t が \"int\" "
"と同じサイズだなんてことはほとんどないからね。 このサイズは \"int\" と 同じで"
"なきゃ『ダメ』なんだ。 BSD ソケットインターフェースっていうのはそういうものな"
"んだから。 まあともかく POSIX の人たちも、 \"socklen_t\" を作るという解決策を"
"なんとかひねり出した。 そもそも最初から放っておけば良かったんだが、 いじっ"
"ちゃった以上、 名前付きの型を持たせなきゃならない、と思ったみたいだね。 なん"
"でかはわかんないけど (きっと最初にやっちまった馬鹿な間違いで顔をつぶしたくな"
"かったから、 こっそり名前を付け替えて自分たちの大失敗をごまかそうとしたんだろ"
"う)。」"

#. type: SH
#: build/C/man2/accept.2:376 build/C/man2/bind.2:252
#: build/C/man2/connect.2:256 build/C/man3/getifaddrs.3:198
#: build/C/man2/listen.2:164 build/C/man2/recv.2:488 build/C/man2/select.2:521
#: build/C/man2/select_tut.2:527 build/C/man2/send.2:417
#: build/C/man3/sockatmark.3:95 build/C/man2/socket.2:383
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man2/accept.2:379 build/C/man2/listen.2:167
msgid "See B<bind>(2)."
msgstr "B<bind>(2)  参照。"

#. type: SH
#: build/C/man2/accept.2:379 build/C/man2/bind.2:317
#: build/C/man3/bindresvport.3:98 build/C/man2/connect.2:261
#: build/C/man3/getifaddrs.3:281 build/C/man2/getsockname.2:110
#: build/C/man2/getsockopt.2:200 build/C/man2/listen.2:167
#: build/C/man2/recv.2:493 build/C/man2/recvmmsg.2:168
#: build/C/man2/select.2:558 build/C/man2/select_tut.2:817
#: build/C/man2/send.2:422 build/C/man2/sendmmsg.2:168
#: build/C/man3/sockatmark.3:130 build/C/man2/socket.2:388
#: build/C/man7/socket.7:741 build/C/man2/socketcall.2:54
#: build/C/man2/socketpair.2:122
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/accept.2:386
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"

#. type: SH
#: build/C/man2/accept.2:386 build/C/man2/bind.2:330
#: build/C/man3/bindresvport.3:101 build/C/man2/connect.2:268
#: build/C/man3/getifaddrs.3:287 build/C/man2/getsockname.2:117
#: build/C/man2/getsockopt.2:208 build/C/man2/listen.2:173
#: build/C/man2/recv.2:504 build/C/man2/recvmmsg.2:175
#: build/C/man2/select.2:573 build/C/man2/select_tut.2:836
#: build/C/man2/send.2:437 build/C/man2/sendmmsg.2:173
#: build/C/man3/sockatmark.3:135 build/C/man2/socket.2:419
#: build/C/man7/socket.7:752 build/C/man2/socketcall.2:72
#: build/C/man2/socketpair.2:129
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/accept.2:393 build/C/man2/bind.2:337
#: build/C/man3/bindresvport.3:108 build/C/man2/connect.2:275
#: build/C/man3/getifaddrs.3:294 build/C/man2/getsockname.2:124
#: build/C/man2/getsockopt.2:215 build/C/man2/listen.2:180
#: build/C/man2/recv.2:511 build/C/man2/recvmmsg.2:182
#: build/C/man2/select.2:580 build/C/man2/select_tut.2:843
#: build/C/man2/send.2:444 build/C/man2/sendmmsg.2:180
#: build/C/man3/sockatmark.3:142 build/C/man2/socket.2:426
#: build/C/man7/socket.7:759 build/C/man2/socketcall.2:79
#: build/C/man2/socketpair.2:136
#, fuzzy
#| msgid ""
#| "This page is part of release 3.40 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.40 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/bind.2:66
#, no-wrap
msgid "BIND"
msgstr "BIND"

#. type: TH
#: build/C/man2/bind.2:66
#, no-wrap
msgid "2007-12-28"
msgstr "2007-12-28"

#. type: Plain text
#: build/C/man2/bind.2:69
msgid "bind - bind a name to a socket"
msgstr "bind - ソケットに名前をつける"

#. type: Plain text
#: build/C/man2/bind.2:76
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/bind.2:90
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""
"B<socket>(2)  でソケットが作成されたとき、そのソケットは名前空間 (アドレス・"
"ファミリー) に 存在するが、アドレスは割り当てられていない。 B<bind>()  は、"
"ファイルディスクリプタ I<sockfd> で参照されるソケットに I<addr> で指定された"
"アドレスを割り当てる。 I<addrlen> には I<addr> が指すアドレス構造体のサイズを"
"バイト単位で指定する。 伝統的にこの操作は 「ソケットに名前をつける」 と呼ばれ"
"る。"

#. type: Plain text
#: build/C/man2/bind.2:97
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""
"B<SOCK_STREAM> ソケットが接続を受け付けられるようにするには (B<accept>(2)  を"
"参照)、通常その前に B<bind>()  を使用してローカルアドレスを割り当てる必要があ"
"る。"

#. type: Plain text
#: build/C/man2/bind.2:128
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET> see "
"B<ip>(7), for B<AF_INET6> see B<ipv6>(7), for B<AF_UNIX> see B<unix>(7), for "
"B<AF_APPLETALK> see B<ddp>(7), for B<AF_PACKET> see B<packet>(7), for "
"B<AF_X25> see B<x25>(7)  and for B<AF_NETLINK> see B<netlink>(7)."
msgstr ""
"名前付けのルールはアドレス・ファミリーごとに異なっている。詳細な情報は 第 7 "
"章の各マニュアルを参照すること。 B<AF_INET> は B<ip>(7)  を、 B<AF_INET6> は "
"B<ipv6>(7)  を、 B<AF_UNIX> は B<unix>(7)  を、 B<AF_APPLETALK> は B<ddp>"
"(7)  を、 B<AF_PACKET> は B<packet>(7)  を、 B<AF_X25> は B<x25>(7)  を、 "
"B<AF_NETLINK> は B<netlink>(7)  を参照。"

#. type: Plain text
#: build/C/man2/bind.2:135
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""
"I<addr> 引き数に実際にどのような構造体が渡されるかは、 アドレス・ファミリーに"
"依存する。 I<sockaddr> 構造体は以下のような感じで定義されている:"

#. type: Plain text
#: build/C/man2/bind.2:142
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"

#. type: Plain text
#: build/C/man2/bind.2:150
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLE below."
msgstr ""
"この構造体は、 I<addr> に渡される構造体へのポインタをキャストし、 コンパイラ"
"の警告メッセージを抑えるためだけに存在する。 下記の「例」を参照。"

#. type: Plain text
#: build/C/man2/bind.2:155 build/C/man2/getsockname.2:70
#: build/C/man2/getsockopt.2:134 build/C/man2/listen.2:85
#: build/C/man2/socketpair.2:72
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合にはゼロが返される。エラー時には -1 が返され、 I<errno> が適切に"
"設定される。"

#. type: TP
#: build/C/man2/bind.2:156 build/C/man2/bind.2:180
#: build/C/man3/bindresvport.3:74 build/C/man2/connect.2:133
#: build/C/man2/send.2:283 build/C/man2/socket.2:318
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: build/C/man2/bind.2:160
msgid "The address is protected, and the user is not the superuser."
msgstr "そのアドレスは保護されていて、かつユーザがスーパーユーザではない。"

#. type: TP
#: build/C/man2/bind.2:160 build/C/man3/bindresvport.3:79
#: build/C/man2/connect.2:146 build/C/man2/listen.2:86
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr "B<EADDRINUSE>"

#. type: Plain text
#: build/C/man2/bind.2:163
msgid "The given address is already in use."
msgstr "指定されたアドレスが既に使用中である。"

#. type: Plain text
#: build/C/man2/bind.2:167
msgid "I<sockfd> is not a valid descriptor."
msgstr "I<sockfd> が不正なディスクリプタである。"

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: build/C/man2/bind.2:172
msgid "The socket is already bound to an address."
msgstr "ソケットがすでにアドレスに結びつけ (bind) られている。"

#. type: Plain text
#: build/C/man2/bind.2:176
msgid "I<sockfd> is a descriptor for a file, not a socket."
msgstr ""
"I<sockfd> がファイルに対するディスクリプタで、ソケットに対するものではない。"

#. type: Plain text
#: build/C/man2/bind.2:180
msgid "The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr "以下のエラーは UNIXドメイン (B<AF_UNIX>)  のソケット特有である:"

#. type: Plain text
#: build/C/man2/bind.2:185
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"パス名の構成要素に検索許可 (search permission) がない (B<path_resolution>"
"(7)  も参照すること)。"

#. type: TP
#: build/C/man2/bind.2:185
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr "B<EADDRNOTAVAIL>"

#. type: Plain text
#: build/C/man2/bind.2:189
msgid ""
"A nonexistent interface was requested or the requested address was not local."
msgstr ""
"存在しないインタフェースが要求されたか、要求されたアドレスが ローカルではな"
"かった。"

#. type: Plain text
#: build/C/man2/bind.2:193
msgid "I<addr> points outside the user's accessible address space."
msgstr "I<addr> がユーザのアクセス可能なアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/bind.2:200
msgid ""
"The I<addrlen> is wrong, or the socket was not in the B<AF_UNIX> family."
msgstr "I<addrlen> が不正であるか、ソケットが B<AF_UNIX> ファミリーではない。"

#. type: TP
#: build/C/man2/bind.2:200
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/bind.2:204
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr "I<addr> を解決する際に遭遇したシンボリック・リンクが多過ぎる。"

#. type: TP
#: build/C/man2/bind.2:204
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/bind.2:208
msgid "I<addr> is too long."
msgstr "I<addr> が長過ぎる。"

#. type: TP
#: build/C/man2/bind.2:208
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/bind.2:211
msgid "The file does not exist."
msgstr "ファイルが存在しない。"

#. type: TP
#: build/C/man2/bind.2:211 build/C/man2/recv.2:427 build/C/man2/select.2:322
#: build/C/man2/send.2:341
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/bind.2:214
msgid "Insufficient kernel memory was available."
msgstr "カーネルに、利用可能なメモリーが十分にない。"

#. type: TP
#: build/C/man2/bind.2:214
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/bind.2:217
msgid "A component of the path prefix is not a directory."
msgstr "パス名の構成要素がディレクトリではない。"

#. type: TP
#: build/C/man2/bind.2:217
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/bind.2:220
msgid "The socket inode would reside on a read-only file system."
msgstr "ソケット inode が読み込み専用のファイルシステム上にある。"

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: build/C/man2/bind.2:232
msgid "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  first appeared in 4.2BSD)."
msgstr "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  は 4.2BSD で最初に現われた)。"

#. type: Plain text
#: build/C/man2/bind.2:249
msgid ""
"The third argument of B<bind>()  is in reality an I<int> (and this is what 4."
"x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in the "
"present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""
"B<bind>()  の三番目の引き数は (4.x BSD や libc4, libc5 と同様に) 実際には "
"I<int> である。glibc でも使われている現在の I<socklen_t> に関して、POSIX には"
"少し混乱がある。 詳しくは B<accept>(2)  を参照のこと。"

#. type: SH
#: build/C/man2/bind.2:249 build/C/man2/getsockopt.2:197
#: build/C/man2/select.2:458 build/C/man2/send.2:412
#: build/C/man3/sockatmark.3:91 build/C/man7/socket.7:728
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  FIXME What *are* transparent proxy options?
#. type: Plain text
#: build/C/man2/bind.2:252
msgid "The transparent proxy options are not described."
msgstr "透過的プロキシ (transparent proxy) オプションについて記述していない。"

#. type: Plain text
#: build/C/man2/bind.2:257
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""
"インターネット・ドメイン・ソケットでの B<bind>()  の利用例が B<getaddrinfo>"
"(3)  に記載されている。"

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: build/C/man2/bind.2:264
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""
"以下の例は、UNIX ドメイン (B<AF_UNIX>)  でストリームソケットを bind する方法"
"を示したものである。"

#. type: Plain text
#: build/C/man2/bind.2:271
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/bind.2:274
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"

#. type: Plain text
#: build/C/man2/bind.2:277
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/bind.2:284
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"

#. type: Plain text
#: build/C/man2/bind.2:288
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"

#. type: Plain text
#: build/C/man2/bind.2:294
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"

#. type: Plain text
#: build/C/man2/bind.2:298
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"

#. type: Plain text
#: build/C/man2/bind.2:301
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"

#. type: Plain text
#: build/C/man2/bind.2:304
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"

#. type: Plain text
#: build/C/man2/bind.2:310
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size)\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"

#. type: Plain text
#: build/C/man2/bind.2:312
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr "    /* Code to deal with incoming connection(s)... */\n"

#. type: Plain text
#: build/C/man2/bind.2:316
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"

#. type: Plain text
#: build/C/man2/bind.2:330
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), B<path_resolution>"
"(7), B<socket>(7), B<unix>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), B<path_resolution>"
"(7), B<socket>(7), B<unix>(7)"

#. type: TH
#: build/C/man3/bindresvport.3:27
#, no-wrap
msgid "BINDRESVPORT"
msgstr "BINDRESVPORT"

#. type: TH
#: build/C/man3/bindresvport.3:27 build/C/man2/connect.2:65
#: build/C/man2/getsockname.2:38 build/C/man2/getsockopt.2:42
#: build/C/man3/sockatmark.3:23
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: build/C/man3/bindresvport.3:30
msgid "bindresvport - bind a socket to a privileged IP port"
msgstr "bindresvport - ソケットを特権 IP ポートにバインドする"

#. type: Plain text
#: build/C/man3/bindresvport.3:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bindresvport.3:36
#, no-wrap
msgid "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"
msgstr "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"

#.  Glibc actually starts searching with a port # in the range 600 to 1023
#. type: Plain text
#: build/C/man3/bindresvport.3:43
msgid ""
"B<bindresvport>()  is used to bind a socket descriptor to a privileged "
"anonymous IP port, that is, a port number arbitrarily selected from the "
"range 512 to 1023."
msgstr ""
"B<bindresvport>()  は、ソケット・ディスクリプタを特権無名 (privileged "
"anonymous) IP ポートに バインドするのに使う。特権無名 IP ポートとは、 ポート"
"番号が 512 から 1023 の範囲から任意に選択されるポートである。"

#. type: Plain text
#: build/C/man3/bindresvport.3:53
msgid ""
"If the B<bind>(2)  performed by B<bindresvport>()  is successful, and I<sin> "
"is not NULL, then I<sin-E<gt>sin_port> returns the port number actually "
"allocated."
msgstr ""
"B<bindresvport>()  によって実行された B<bind>(2)  が成功し、 I<sin> が NULL "
"以外の場合、実際に割り当てられたポート番号が I<sin-E<gt>sin_port> に入れて返"
"される。"

#. type: Plain text
#: build/C/man3/bindresvport.3:64
msgid ""
"I<sin> can be NULL, in which case I<sin-E<gt>sin_family> is implicitly taken "
"to be B<AF_INET>.  However, in this case, B<bindresvport>()  has no way to "
"return the port number actually allocated.  (This information can later be "
"obtained using B<getsockname>(2).)"
msgstr ""
"I<sin> には NULL を指定することもでき、その場合には I<sin-E<gt>sin_family> は"
"暗黙のうちに B<AF_INET> とみなされる。 しかし、この場合には、 B<bindresvport>"
"()  は実際に割り当てられたポート番号を返す手段を持たない (割り当てられたポー"
"ト番号は、後で B<getsockname>(2)  を使って取得できる)。"

#. type: Plain text
#: build/C/man3/bindresvport.3:69
msgid ""
"B<bindresvport>()  returns 0 on success; otherwise -1 is returned and "
"I<errno> set to indicate the cause of the error."
msgstr ""
"B<bindresvport>()  は成功すると 0 を返す。それ以外の場合、-1 を返し、 "
"I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/bindresvport.3:74
msgid ""
"B<bindresvport>()  can fail for any of the same reasons as B<bind>(2).  In "
"addition, the following errors may occur:"
msgstr ""
"B<bindresvport>()  は B<bind>(2)  と同じ原因で失敗する可能性がある。 さらに、"
"以下のエラーが発生することがある:"

#. type: Plain text
#: build/C/man3/bindresvport.3:79
msgid ""
"The caller did not have superuser privilege (to be precise: the "
"B<CAP_NET_BIND_SERVICE> capability is required)."
msgstr ""
"呼び出し元がスーパーユーザの特権を持っていなかった (より正確に言うと、 "
"B<CAP_NET_BIND_SERVICE> ケーパビリティが必要である)。"

#. type: Plain text
#: build/C/man3/bindresvport.3:82
msgid "All privileged ports are in use."
msgstr "全ての特権ポートが使用中である。"

#. type: TP
#: build/C/man3/bindresvport.3:82
#, no-wrap
msgid "B<EAFNOSUPPORT> (B<EPFNOSUPPORT> in glibc 2.7 and earlier)"
msgstr "B<EAFNOSUPPORT> (glibc 2.7 以前では B<EPFNOSUPPORT>)"

#. type: Plain text
#: build/C/man3/bindresvport.3:89
msgid "I<sin> is not NULL and I<sin-E<gt>sin_family> is not B<AF_INET>."
msgstr ""
"I<sin> が NULL 以外で、かつ I<sin-E<gt>sin_family> が B<AF_INET> でなかった。"

#. type: Plain text
#: build/C/man3/bindresvport.3:92
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems."
msgstr ""
"POSIX.1-2001 にはない。 BSD, Solaris およびその他の多くのシステムに存在する。"

#. type: Plain text
#: build/C/man3/bindresvport.3:98
msgid ""
"Unlike some B<bindresvport>()  implementations, the glibc implementation "
"ignores any value that the caller supplies in I<sin-E<gt>sin_port>."
msgstr ""
"B<bindresvport>()  のいくつかの実装と異なり、glibc の実装では呼び出し元が "
"I<sin-E<gt>sin_port> で渡した値はどんな値であっても無視される。"

#. type: Plain text
#: build/C/man3/bindresvport.3:101
msgid "B<bind>(2), B<getsockname>(2)"
msgstr "B<bind>(2), B<getsockname>(2)"

#. type: TH
#: build/C/man2/connect.2:65
#, no-wrap
msgid "CONNECT"
msgstr "CONNECT"

#. type: Plain text
#: build/C/man2/connect.2:68
msgid "connect - initiate a connection on a socket"
msgstr "connect - ソケットの接続を行う"

#. type: Plain text
#: build/C/man2/connect.2:71 build/C/man2/getsockopt.2:48
#: build/C/man2/listen.2:49
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>          /* 「注意」参照 */\n"

#. type: Plain text
#: build/C/man2/connect.2:73 build/C/man2/getsockname.2:44
#: build/C/man2/getsockopt.2:50 build/C/man2/listen.2:51
#: build/C/man2/recv.2:49
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr "B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/connect.2:76
#, no-wrap
msgid ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/connect.2:95
msgid ""
"The B<connect>()  system call connects the socket referred to by the file "
"descriptor I<sockfd> to the address specified by I<addr>.  The I<addrlen> "
"argument specifies the size of I<addr>.  The format of the address in "
"I<addr> is determined by the address space of the socket I<sockfd>; see "
"B<socket>(2)  for further details."
msgstr ""
"B<connect>()  システムコールは、ファイルディスクリプタ I<sockfd> が参照してい"
"るソケットを I<addr> で指定されたアドレスに接続する。 I<addrlen> 引き数は "
"I<addr> の大きさを示す。 I<addr> のアドレスのフォーマットはソケット "
"I<sockfd> のアドレス空間により異なる。 さらなる詳細は B<socket>(2)  を参照の"
"こと。"

#. type: Plain text
#: build/C/man2/connect.2:111
msgid ""
"If the socket I<sockfd> is of type B<SOCK_DGRAM> then I<addr> is the address "
"to which datagrams are sent by default, and the only address from which "
"datagrams are received.  If the socket is of type B<SOCK_STREAM> or "
"B<SOCK_SEQPACKET>, this call attempts to make a connection to the socket "
"that is bound to the address specified by I<addr>."
msgstr ""
"ソケット I<sockfd> が B<SOCK_DGRAM> 型であれば、 I<addr> は、デフォルトのデー"
"タグラムの送信先のアドレスであり、 データグラムを受信する唯一のアドレスを示す"
"に過ぎない。 ソケットが B<SOCK_STREAM> 型もしくは B<SOCK_SEQPACKET> 型であれ"
"ば、このシステムコールは I<addr> で指定されたアドレスに結び付けられたソケット"
"に対する接続の 作成を試みる。"

#. type: Plain text
#: build/C/man2/connect.2:125
msgid ""
"Generally, connection-based protocol sockets may successfully B<connect>()  "
"only once; connectionless protocol sockets may use B<connect>()  multiple "
"times to change their association.  Connectionless sockets may dissolve the "
"association by connecting to an address with the I<sa_family> member of "
"I<sockaddr> set to B<AF_UNSPEC> (supported on Linux since kernel 2.2)."
msgstr ""
"一般的に、接続指向 (connection-oriented) プロトコルでは一度だけ B<connect>"
"()  が成功する。 非接続 (connectionless) プロトコルでは対応を変更するために何"
"度も B<connect>()  を使用できる。 非接続ソケットは I<sockaddr> の "
"I<sa_family> メンバに B<AF_UNSPEC> を設定することで、接続アドレスの対応を解消"
"することができる (B<AF_UNSPEC> はカーネル 2.2 以降の Linux でサポート)。"

#. type: Plain text
#: build/C/man2/connect.2:130
msgid ""
"If the connection or binding succeeds, zero is returned.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"接続または対応づけに成功するとゼロを返す。 失敗すると -1 を返し、 I<errno> に"
"適切な値を設定する。"

#. type: Plain text
#: build/C/man2/connect.2:133
msgid ""
"The following are general socket errors only.  There may be other domain-"
"specific error codes."
msgstr ""
"以下は一般的なソケットについてのエラーである。他にドメイン特有のエラー が発生"
"する可能性がある。"

#. type: Plain text
#: build/C/man2/connect.2:141
msgid ""
"For UNIX domain sockets, which are identified by pathname: Write permission "
"is denied on the socket file, or search permission is denied for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""
"UNIX ドメインソケットはパス名で識別される。 ソケット・ファイルへの書き込み許"
"可がなかったか、パス名へ 到達するまでのディレクトリのいずれかに対する検索許可"
"がなかった。 (B<path_resolution>(7)  も参照のこと)"

#. type: TP
#: build/C/man2/connect.2:141
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr "B<EACCES>, B<EPERM>"

#. type: Plain text
#: build/C/man2/connect.2:146
msgid ""
"The user tried to connect to a broadcast address without having the socket "
"broadcast flag enabled or the connection request failed because of a local "
"firewall rule."
msgstr ""
"ソケットのブロードキャスト・フラグが有効になっていないのに ユーザがブロード"
"キャストへ接続を試みた。または、ローカルのファイアウォールの 規則により接続の"
"要求が失敗した。"

#. type: Plain text
#: build/C/man2/connect.2:149
msgid "Local address is already in use."
msgstr "ローカルアドレスが既に使用されている。"

#. type: TP
#: build/C/man2/connect.2:149 build/C/man2/socket.2:322
#: build/C/man2/socketpair.2:73
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr "B<EAFNOSUPPORT>"

#. type: Plain text
#: build/C/man2/connect.2:154
msgid ""
"The passed address didn't have the correct address family in its "
"I<sa_family> field."
msgstr ""
"渡されたアドレスの I<sa_family> フィールドが正しいアドレス・ファミリーではな"
"い。"

#. type: TP
#: build/C/man2/connect.2:154
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/connect.2:163
msgid ""
"No more free local ports or insufficient entries in the routing cache.  For "
"B<AF_INET> see the description of I</proc/sys/net/ipv4/ip_local_port_range> "
"B<ip>(7)  for information on how to increase the number of local ports."
msgstr ""
"使用可能なローカルのポートがないか、 ルーティングキャッシュに十分なエントリが"
"ない。 B<AF_INET> の場合に、ローカルポートの数を増やす方法については、 B<ip>"
"(7)  の I</proc/sys/net/ipv4/ip_local_port_range> の説明を参照のこと。"

#. type: TP
#: build/C/man2/connect.2:163
#, no-wrap
msgid "B<EALREADY>"
msgstr "B<EALREADY>"

#. type: Plain text
#: build/C/man2/connect.2:167
msgid ""
"The socket is nonblocking and a previous connection attempt has not yet been "
"completed."
msgstr ""
"ソケットが非停止 (nonblocking) に設定されており、 前の接続が完了していない。"

#. type: Plain text
#: build/C/man2/connect.2:170
msgid "The file descriptor is not a valid index in the descriptor table."
msgstr ""
"ファイルディスクリプターがディスクリプターテーブルの 有効なインデックスではな"
"い。"

#. type: TP
#: build/C/man2/connect.2:170 build/C/man2/recv.2:410
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr "B<ECONNREFUSED>"

#. type: Plain text
#: build/C/man2/connect.2:173
msgid "No-one listening on the remote address."
msgstr "リモートアドレスで接続を待っているプログラムがない。"

#. type: Plain text
#: build/C/man2/connect.2:176
msgid "The socket structure address is outside the user's address space."
msgstr "ソケット構造体のアドレスがユーザーのアドレス空間外にある。"

#. type: TP
#: build/C/man2/connect.2:176
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr "B<EINPROGRESS>"

#. type: Plain text
#: build/C/man2/connect.2:201
msgid ""
"The socket is nonblocking and the connection cannot be completed "
"immediately.  It is possible to B<select>(2)  or B<poll>(2)  for completion "
"by selecting the socket for writing.  After B<select>(2)  indicates "
"writability, use B<getsockopt>(2)  to read the B<SO_ERROR> option at level "
"B<SOL_SOCKET> to determine whether B<connect>()  completed successfully "
"(B<SO_ERROR> is zero) or unsuccessfully (B<SO_ERROR> is one of the usual "
"error codes listed here, explaining the reason for the failure)."
msgstr ""
"ソケットが非停止 (nonblocking) に設定されていて、接続をすぐに 完了することが"
"できない。その場合、 B<select>(2)  や B<poll>(2)  を使ってそのソケットが書き"
"込み可能になるのを待つことで、 接続の完了を知ることができる。 B<select>(2)  "
"で書き込み可能になった後に、 B<getsockopt>(2)  を使って B<SOL_SOCKET> レベル"
"で B<SO_ERROR> オプションを読み出すこ とにより、 B<connect>()  が成功したか、"
"失敗したかを判断できる。 成功の場合 B<SO_ERROR> が 0 であり、 失敗の場合 "
"B<SO_ERROR> がここのリストにあるいずれかのエラーコードであり、 それにより失敗"
"の原因が分かる。"

#.  For TCP, the connection will complete asynchronously.
#.  See http://lkml.org/lkml/2005/7/12/254
#. type: Plain text
#: build/C/man2/connect.2:207
msgid ""
"The system call was interrupted by a signal that was caught; see B<signal>"
"(7)."
msgstr ""
"捕捉されたシグナルによりシステムコールが中断された。 B<signal>(7)  参照。"

#. type: TP
#: build/C/man2/connect.2:207 build/C/man2/send.2:321
#, no-wrap
msgid "B<EISCONN>"
msgstr "B<EISCONN>"

#. type: Plain text
#: build/C/man2/connect.2:210
msgid "The socket is already connected."
msgstr "ソケットは既に接続 (connect) されている。"

#. type: TP
#: build/C/man2/connect.2:210
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr "B<ENETUNREACH>"

#. type: Plain text
#: build/C/man2/connect.2:213
msgid "Network is unreachable."
msgstr "到達できないネットワークである。"

#. type: Plain text
#: build/C/man2/connect.2:216
msgid "The file descriptor is not associated with a socket."
msgstr "ファイルディスクリプターがソケットと関連付けられていない。"

#. type: TP
#: build/C/man2/connect.2:216
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man2/connect.2:223
msgid ""
"Timeout while attempting connection.  The server may be too busy to accept "
"new connections.  Note that for IP sockets the timeout may be very long when "
"syncookies are enabled on the server."
msgstr ""
"接続を試みている途中で時間切れ (timeout) になった。サーバーが混雑していて 新"
"たな接続を受け入れられないのかもしれない。 IP ソケットでは、 syncookie がサー"
"バーで有効になっている場合、 タイムアウトが非常に長くなる場合があるので注意す"
"ること。"

#.  SVr4 documents the additional
#.  general error codes
#.  .BR EADDRNOTAVAIL ,
#.  .BR EINVAL ,
#.  .BR EAFNOSUPPORT ,
#.  .BR EALREADY ,
#.  .BR EINTR ,
#.  .BR EPROTOTYPE ,
#.  and
#.  .BR ENOSR .
#.  It also
#.  documents many additional error conditions not described here.
#. type: Plain text
#: build/C/man2/connect.2:239
msgid ""
"SVr4, 4.4BSD, (the B<connect>()  function first appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""
"SVr4, 4.4BSD, (B<connect>()  関数は 4.2BSD で最初に登場した), POSIX.1-2001."

#. type: Plain text
#: build/C/man2/connect.2:256
msgid ""
"The third argument of B<connect>()  is in reality an I<int> (and this is "
"what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
"the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""
"B<connect>()  の三番目の引き数は 4.x BSD や libc4, libc5 と同様に実際には "
"I<int> である。 POSIX では紆余曲折を経て現在の I<socklen_t> になっており、 "
"glibc でも I<socklen_t> を使っている。 B<accept>(2)  も参照のこと。"

#. type: Plain text
#: build/C/man2/connect.2:261
msgid "An example of the use of B<connect>()  is shown in B<getaddrinfo>(3)."
msgstr "B<connect>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/connect.2:268
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7)"

#. type: TH
#: build/C/man3/getifaddrs.3:33
#, no-wrap
msgid "GETIFADDRS"
msgstr "GETIFADDRS"

#. type: TH
#: build/C/man3/getifaddrs.3:33
#, no-wrap
msgid "2010-10-06"
msgstr "2010-10-06"

#. type: TH
#: build/C/man3/getifaddrs.3:33
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/getifaddrs.3:36
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:40
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:42
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:44
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:55
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing "
"the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:74
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:81
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: build/C/man3/getifaddrs.3:88
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:97
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:105
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:111
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:126
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:131
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:137
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be "
"freed using B<freeifaddrs>()  when no longer needed."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:144
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:157
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), B<sendto>"
"(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:165
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation only supported IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is only "
"available on kernels that support netlink."
msgstr ""

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: build/C/man3/getifaddrs.3:185
msgid ""
"Not in POSIX.1-2001.  This function first appeared in BSDi and is present on "
"the BSD systems, but with slightly different semantics documented"
"\\(emreturning one entry per interface, not per address.  This means "
"I<ifa_addr> and other fields can actually be NULL if the interface has no "
"address, and no link-level address is returned if the interface has an IP "
"address assigned.  Also, the way of choosing either I<ifa_broadaddr> or "
"I<ifa_dstaddr> differs on various systems."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:198
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"net_device_stats>, defined in I<E<lt>linux/netdevice.hE<gt>>, which contains "
"various interface attributes and statistics."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:205
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(), "
"and B<getnameinfo>(3).  Here is what we see when running this program on one "
"system:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:219
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo      address family: 17 (AF_PACKET)\n"
"eth0    address family: 17 (AF_PACKET)\n"
"lo      address family: 2 (AF_INET)\n"
"        address: E<lt>127.0.0.1E<gt>\n"
"eth0    address family: 2 (AF_INET)\n"
"        address: E<lt>10.1.1.4E<gt>\n"
"lo      address family: 10 (AF_INET6)\n"
"        address: E<lt>::1E<gt>\n"
"eth0    address family: 10 (AF_INET6)\n"
"        address: E<lt>fe80::2d0:59ff:feda:eb51%eth0E<gt>\n"
msgstr ""
"$ B<./a.out>\n"
"lo      address family: 17 (AF_PACKET)\n"
"eth0    address family: 17 (AF_PACKET)\n"
"lo      address family: 2 (AF_INET)\n"
"        address: E<lt>127.0.0.1E<gt>\n"
"eth0    address family: 2 (AF_INET)\n"
"        address: E<lt>10.1.1.4E<gt>\n"
"lo      address family: 10 (AF_INET6)\n"
"        address: E<lt>::1E<gt>\n"
"eth0    address family: 10 (AF_INET6)\n"
"        address: E<lt>fe80::2d0:59ff:feda:eb51%eth0E<gt>\n"

#. type: SS
#: build/C/man3/getifaddrs.3:221
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:231
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:238
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:243
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:246
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:250
#, no-wrap
msgid ""
"    for (ifa = ifaddr; ifa != NULL; ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""
"    for (ifa = ifaddr; ifa != NULL; ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:252
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:255
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:261
#, no-wrap
msgid ""
"        printf(\"%s\\t  address family: %d%s\\en\",\n"
"                ifa-E<gt>ifa_name, family,\n"
"                (family == AF_PACKET) ? \" (AF_PACKET)\" :\n"
"                (family == AF_INET) ?   \" (AF_INET)\" :\n"
"                (family == AF_INET6) ?  \" (AF_INET6)\" : \"\");\n"
msgstr ""
"        printf(\"%s\\t  address family: %d%s\\en\",\n"
"                ifa-E<gt>ifa_name, family,\n"
"                (family == AF_PACKET) ? \" (AF_PACKET)\" :\n"
"                (family == AF_INET) ?   \" (AF_INET)\" :\n"
"                (family == AF_INET6) ?  \" (AF_INET6)\" : \"\");\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:263
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr "        /* For an AF_INET* interface address, display the address */\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:276
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
"        }\n"
"    }\n"
msgstr ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:280
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/getifaddrs.3:287
msgid ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr ""
"B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"

#. type: TH
#: build/C/man2/getsockname.2:38
#, no-wrap
msgid "GETSOCKNAME"
msgstr "GETSOCKNAME"

#. type: Plain text
#: build/C/man2/getsockname.2:41
msgid "getsockname - get socket name"
msgstr "getsockname - ソケットの名前を取得する"

#. type: Plain text
#: build/C/man2/getsockname.2:47
#, no-wrap
msgid "B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr "B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/getsockname.2:60
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""
"B<getsockname>()  は、ソケット I<sockfd> に結び付けられている現在のアドレス"
"を、 I<addr> が指すバッファに格納して返す。 I<addrlen> 引き数は、 I<addr> が"
"指している領域のサイズ (バイト単位) に初期化しておかなければならない。 関数が"
"返る時には、 I<addrlen> にはソケットアドレスの実際のサイズ (バイト単位) が格"
"納される。"

#. type: Plain text
#: build/C/man2/getsockname.2:76 build/C/man2/getsockopt.2:140
#: build/C/man2/listen.2:94
msgid "The argument I<sockfd> is not a valid descriptor."
msgstr "引き数 I<sockfd> は有効なディスクリプターでない。"

#. type: Plain text
#: build/C/man2/getsockname.2:82
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""
"引き数 I<addr> の指しているメモリがプロセスのアドレス空間の有効な部分ではな"
"い。"

#. type: Plain text
#: build/C/man2/getsockname.2:86
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr "I<addrlen> が不正である (例えば、負で場合など)。"

#. type: TP
#: build/C/man2/getsockname.2:86 build/C/man2/send.2:333
#, no-wrap
msgid "B<ENOBUFS>"
msgstr "B<ENOBUFS>"

#. type: Plain text
#: build/C/man2/getsockname.2:90
msgid ""
"Insufficient resources were available in the system to perform the operation."
msgstr "処理をするだけの十分なリソースがシステムに無い。"

#. type: Plain text
#: build/C/man2/getsockname.2:95 build/C/man2/getsockopt.2:169
msgid "The argument I<sockfd> is a file, not a socket."
msgstr "引き数 I<sockfd> がソケットではなくファイルである。"

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: build/C/man2/getsockname.2:101
msgid ""
"SVr4, 4.4BSD (the B<getsockname>()  function call appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""
"SVr4, 4.4BSD (B<getsockname>()  関数は 4.2BSD で追加された), POSIX.1-2001."

#. type: Plain text
#: build/C/man2/getsockname.2:110
msgid ""
"The third argument of B<getsockname>()  is in reality an I<int *> (and this "
"is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
"the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""
"B<getsockname>()  の三番目の引き数は (4.x BSD や libc4, libc5 と同様に) 実際"
"には I<int *> である。 glibc でも使われている現在の I<socklen_t> に関して、 "
"POSIX には少し混乱がある。 詳しくは B<accept>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/getsockname.2:117
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), B<unix>"
"(7)"
msgstr ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), B<unix>"
"(7)"

#. type: TH
#: build/C/man2/getsockopt.2:42
#, no-wrap
msgid "GETSOCKOPT"
msgstr "GETSOCKOPT"

#. type: Plain text
#: build/C/man2/getsockopt.2:45
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr "getsockopt, setsockopt - ソケットのオプションの設定と取得を行なう"

#. type: Plain text
#: build/C/man2/getsockopt.2:55
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"

#. type: Plain text
#: build/C/man2/getsockopt.2:65
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple "
"protocol levels; they are always present at the uppermost socket level."
msgstr ""
"B<getsockopt>()  と B<setsockopt>()  は、ファイルディスクリプタ I<socket> で"
"参照されるソケットに関連するオプションの操作を行う。 オプションは複数のプロト"
"コル層(level)に存在するかもしれないが、 これらは常に最上位のソケット層へと設"
"定される。"

#. type: Plain text
#: build/C/man2/getsockopt.2:84
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option "
"is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""
"ソケット・オプションを操作する際には、オプションの層 (level) と オプションの"
"名前を指定しなければならない。 ソケット API 層でオプションを操作する為には、 "
"I<level> を B<SOL_SOCKET> に指定する。 他の全ての層でオプションを操作する為に"
"は、与えられたオプションの 制御主体となるプロトコルのプロトコル番号を指定す"
"る。例えば、 オプションが B<TCP> プロトコルで解釈されるべきことを指示するに"
"は、 I<level> に B<TCP> のプロトコル番号を指定しなければならない。 "
"B<getprotoent>(3)  を参照すること。"

#. type: Plain text
#: build/C/man2/getsockopt.2:106
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""
"I<optval> と I<optlen> 引き数は B<setsockopt>()  のオプションの値にアクセスす"
"るために用いられる。 B<getsockopt>()  では要求したオプションの値を返すための"
"バッファーを指定する。 B<getsockopt>()  では I<optlen> は値と結果両用の引き数"
"で、最初に I<optval> の指しているバッファーのサイズを与え、実際に返される値の"
"サイズに 書き換えられる。もしオプション値を与えず、返されもしない場合には "
"I<optval> は NULL でも良い。"

#. type: Plain text
#: build/C/man2/getsockopt.2:116
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file I<E<lt>sys/"
"socket.hE<gt>> contains definitions for socket level options, described "
"below.  Options at other protocol levels vary in format and name; consult "
"the appropriate entries in section 4 of the manual."
msgstr ""
"I<optname> および指定されたオプションは解釈されずに、適切なプロトコル・モ"
"ジュールに 渡されて解釈される。インクルード・ファイル I<E<lt>sys/socket."
"hE<gt>> には後述のソケット層のオプションの定義が含まれている。 他のプロトコル"
"層では名前や形式は異なる。 マニュアルのセクション 4 の適切なエントリを参照す"
"ること。"

#. type: Plain text
#: build/C/man2/getsockopt.2:125
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""
"ほとんどのソケット層のオプションは I<optval> に I<int> 引き数を利用する。 "
"B<setsockopt>()  で、二値(boolean)オプションを有効(enable)にするにはゼロ以外"
"を指定し、 無効(disable)にするにはゼロを指定する。"

#. type: Plain text
#: build/C/man2/getsockopt.2:129
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""
"利用可能なソケットオプションの説明に関しては、 B<socket>(7)  と適切なプロトコ"
"ルの man ページを参照のこと。"

#. type: Plain text
#: build/C/man2/getsockopt.2:150
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""
"I<optval> で指定されたアドレスがプロセスのアドレス空間の有効な部分ではない。 "
"B<getsockopt>()  の場合、 I<optlen> がプロセスのアドレス空間の有効な部分でな"
"い場合にもこのエラーが返される。"

#. type: Plain text
#: build/C/man2/getsockopt.2:161
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""
"B<setsockopt>()  で I<option> が不正である。 I<optval> に無効な値が指定された"
"場合にも、このエラーが発生する可能性がある (例えば、 B<ip>(7)  に説明がある "
"B<IP_ADD_MEMBERSHIP> オプションなど)。"

#. type: TP
#: build/C/man2/getsockopt.2:161
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr "B<ENOPROTOOPT>"

#. type: Plain text
#: build/C/man2/getsockopt.2:164
msgid "The option is unknown at the level indicated."
msgstr "指定された層(level)にはこのオプションは存在しない。"

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: build/C/man2/getsockopt.2:176
msgid ""
"SVr4, 4.4BSD (these system calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""
"SVr4, 4.4BSD (これらのシステム・コールは 4.2BSD で最初に現れた), "
"POSIX.1-2001."

#. type: Plain text
#: build/C/man2/getsockopt.2:197
msgid ""
"The I<optlen> argument of B<getsockopt>()  and B<setsockopt>()  is in "
"reality an I<int [*]> (and this is what 4.x BSD and libc4 and libc5 have).  "
"Some POSIX confusion resulted in the present I<socklen_t>, also used by "
"glibc.  See also B<accept>(2)."
msgstr ""
"B<getsockopt>()  と B<setsockopt>()  の I<optlen> 引き数は実際は I<int [*]> "
"である (そして 4.x BSD と libc4 と libc5 はそうなっている)。 POSIX では紆余曲"
"折を経て現在の I<socklen_t> になっており、 glibc でも I<socklen_t> を使ってい"
"る。 B<accept>(2)  も参照のこと。"

#. type: Plain text
#: build/C/man2/getsockopt.2:200
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""
"ソケットのオプションのいくつかはシステムのより低い層で 処理されるべきである。"

#. type: Plain text
#: build/C/man2/getsockopt.2:208
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<socket>(7), "
"B<tcp>(7), B<unix>(7)"
msgstr ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<socket>(7), "
"B<tcp>(7), B<unix>(7)"

#. type: TH
#: build/C/man2/listen.2:43
#, no-wrap
msgid "LISTEN"
msgstr "LISTEN"

#. type: TH
#: build/C/man2/listen.2:43
#, no-wrap
msgid "2008-11-20"
msgstr "2008-11-20"

#. type: Plain text
#: build/C/man2/listen.2:46
msgid "listen - listen for connections on a socket"
msgstr "listen - ソケット(socket)上の接続を待つ"

#. type: Plain text
#: build/C/man2/listen.2:53
#, no-wrap
msgid "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"
msgstr "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"

#. type: Plain text
#: build/C/man2/listen.2:61
msgid ""
"B<listen>()  marks the socket referred to by I<sockfd> as a passive socket, "
"that is, as a socket that will be used to accept incoming connection "
"requests using B<accept>(2)."
msgstr ""
"B<listen>()  は I<sockfd> が参照するソケットを接続待ちソケット (passive "
"socket) として印をつける。 接続待ちソケットとは、 B<accept>(2)  を使って到着"
"した接続要求を受け付けるのに使用されるソケットである。"

#. type: Plain text
#: build/C/man2/listen.2:68
msgid ""
"The I<sockfd> argument is a file descriptor that refers to a socket of type "
"B<SOCK_STREAM> or B<SOCK_SEQPACKET>."
msgstr ""
"I<sockfd> 引き数は、 B<SOCK_STREAM> 型か B<SOCK_SEQPACKET> 型のソケットを参照"
"するファイルディスクリプタである。"

#. type: Plain text
#: build/C/man2/listen.2:80
msgid ""
"The I<backlog> argument defines the maximum length to which the queue of "
"pending connections for I<sockfd> may grow.  If a connection request arrives "
"when the queue is full, the client may receive an error with an indication "
"of B<ECONNREFUSED> or, if the underlying protocol supports retransmission, "
"the request may be ignored so that a later reattempt at connection succeeds."
msgstr ""
"I<backlog> 引き数は、 I<sockfd> についての保留中の接続のキューの最大長を指定"
"する。 キューがいっぱいの状態で接続要求が到着すると、クライアントは "
"B<ECONNREFUSED> というエラーを受け取る。下位層のプロトコルが再送信をサポート "
"していれば、要求は無視され、これ以降の接続要求の再送信が成功するかもしれな"
"い。"

#. type: Plain text
#: build/C/man2/listen.2:89
msgid "Another socket is already listening on the same port."
msgstr "別のソケットが既に同じポートを listen している。"

#. type: Plain text
#: build/C/man2/listen.2:99 build/C/man2/send.2:352
msgid "The argument I<sockfd> is not a socket."
msgstr "引き数 I<sockfd> はソケットではない。"

#. type: Plain text
#: build/C/man2/listen.2:104
msgid "The socket is not of a type that supports the B<listen>()  operation."
msgstr "ソケットは B<listen>()  がサポートしている型ではない。"

#. type: Plain text
#: build/C/man2/listen.2:109
msgid ""
"4.4BSD, POSIX.1-2001.  The B<listen>()  function call first appeared in "
"4.2BSD."
msgstr "4.4BSD, POSIX.1-2001.  B<listen>()  関数は 4.2BSDで初めて実装された。"

#. type: Plain text
#: build/C/man2/listen.2:111
msgid "To accept connections, the following steps are performed:"
msgstr "接続を受け付けるには、以下の処理が実行される。"

#. type: TP
#: build/C/man2/listen.2:112 build/C/man2/select_tut.2:345
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/listen.2:115
msgid "A socket is created with B<socket>(2)."
msgstr "B<socket>(2)  でソケットを作成する。"

#. type: TP
#: build/C/man2/listen.2:115 build/C/man2/select_tut.2:354
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/listen.2:121
msgid ""
"The socket is bound to a local address using B<bind>(2), so that other "
"sockets may be B<connect>(2)ed to it."
msgstr ""
"B<bind>(2)  を使ってソケットにローカルアドレスを割り当てて、 他のソケットがこ"
"のソケットに B<connect>(2)  できるようにする。"

#. type: TP
#: build/C/man2/listen.2:121 build/C/man2/select_tut.2:358
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man2/listen.2:125
msgid ""
"A willingness to accept incoming connections and a queue limit for incoming "
"connections are specified with B<listen>()."
msgstr ""
"B<listen>()  を使って、接続要求を受け付ける意志と接続要求を入れるキュー長を指"
"定する。"

#. type: TP
#: build/C/man2/listen.2:125 build/C/man2/select_tut.2:365
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man2/listen.2:128
msgid "Connections are accepted with B<accept>(2)."
msgstr "B<accept>(2)  を使って接続を受け付ける。"

#. type: Plain text
#: build/C/man2/listen.2:151
msgid ""
"The behavior of the I<backlog> argument on TCP sockets changed with Linux "
"2.2.  Now it specifies the queue length for I<completely> established "
"sockets waiting to be accepted, instead of the number of incomplete "
"connection requests.  The maximum length of the queue for incomplete sockets "
"can be set using I</proc/sys/net/ipv4/tcp_max_syn_backlog>.  When syncookies "
"are enabled there is no logical maximum length and this setting is ignored.  "
"See B<tcp>(7)  for more information."
msgstr ""
"TCP ソケットでの I<backlog> 引き数の振る舞いは Linux 2.2 で変更された。 現在"
"ではこの引き数は、 受け付けられるのを待っている、 I<完全に> 確立されたソケッ"
"トのキューの長さを指定する。 以前は不完全な接続要求の数であったが、これを置き"
"換えた。 不完全なソケットのキューの最大長は I</proc/sys/net/ipv4/"
"tcp_max_syn_backlog> を用いて設定できる。 syncookie が有効になっている場合、 "
"論理的な最大長は存在せず、この設定は無視される。"

#.  The following is now rather historic information (MTK, Jun 05)
#.  Don't rely on this value in portable applications since BSD
#.  (and some BSD-derived systems) limit the backlog to 5.
#. type: Plain text
#: build/C/man2/listen.2:164
msgid ""
"If the I<backlog> argument is greater than the value in I</proc/sys/net/core/"
"somaxconn>, then it is silently truncated to that value; the default value "
"in this file is 128.  In kernels before 2.4.25, this limit was a hard coded "
"value, B<SOMAXCONN>, with the value 128."
msgstr ""
"I<backlog> 引き数が I</proc/sys/net/core/somaxconn> の値よりも大きければ、 "
"I<backlog> の値は暗黙のうちにこの値に切り詰められる。 このファイルのデフォル"
"ト値は 128 である。 バージョン 2.4.5 以前のカーネルでは、この上限値は コード"
"埋め込みの固定値 B<SOMAXCONN> であり、その値は 128 であった。"

#. type: Plain text
#: build/C/man2/listen.2:173
msgid "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man2/recv.2:39
#, no-wrap
msgid "RECV"
msgstr "RECV"

#. type: TH
#: build/C/man2/recv.2:39
#, no-wrap
msgid "2011-09-16"
msgstr "2011-09-16"

#. type: Plain text
#: build/C/man2/recv.2:42
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr "recv, recvfrom, recvmsg - ソケットからメッセージを受け取る"

#. type: Plain text
#: build/C/man2/recv.2:47 build/C/man2/select.2:53
#: build/C/man2/select_tut.2:45
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/recv.2:51
#, no-wrap
msgid "B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/recv.2:54
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"
msgstr ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t *>I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/recv.2:56
#, no-wrap
msgid "B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/recv.2:64
msgid ""
"The B<recvfrom>()  and B<recvmsg>()  calls are used to receive messages from "
"a socket, and may be used to receive data on a socket whether or not it is "
"connection-oriented."
msgstr ""
"B<recvfrom>()  と B<recvmsg>()  コールは、ソケットからメッセージを受け取るの"
"に使用する。 またソケットのデータ受信にも使うことができ、 このときソケットは"
"接続指向 (connection-oriened) であってもなくてもよい。"

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: build/C/man2/recv.2:93
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address, this source address is filled in.  When I<src_addr> is NULL, "
"nothing is filled in; in this case, I<addrlen> is not used, and should also "
"be NULL.  The argument I<addrlen> is a value-result argument, which the "
"caller should initialize before the call to the size of the buffer "
"associated with I<src_addr>, and modified on return to indicate the actual "
"size of the source address.  The returned address is truncated if the buffer "
"provided is too small; in this case, I<addrlen> will return a value greater "
"than was supplied to the call."
msgstr ""
"I<src_addr> が NULL 以外で、下層のプロトコルから送信元アドレスが分かる場合、 "
"I<src_addr> にはこの送信元アドレスが入れられる。 I<src_addr> が NULL の場"
"合、 I<src_addr> には何も入らない。この場合、 I<addrlen> は使用されず、この引"
"き数は NULL にしておくべきである。 引き数 I<addrlen> は入出力両用の引き数であ"
"る。呼び出し時には、呼び出し元が I<src_addr> に割り当てたバッファの大きさで初"
"期化しておくべきである。 返ってくる時には、送信元アドレスの実際の大きさに変更"
"される。 渡されたバッファが小さ過ぎる場合には、返されるアドレスの末尾は 切り"
"詰められる。この場合には、 I<addrlen> では、呼び出し時に渡された値よりも大き"
"な値が返される。"

#. type: Plain text
#: build/C/man2/recv.2:105
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2))  and is identical to B<recvfrom>()  with a NULL I<src_addr> "
"argument."
msgstr ""
"B<recv>()  コールは通常 I<接続済みの (connected)> ソケット (B<connect>(2)  を"
"参照) についてのみ使用され、 I<src_addr> 引き数に NULL を指定した B<recvfrom>"
"()  と等価である。"

#. type: Plain text
#: build/C/man2/recv.2:111
msgid ""
"All three routines return the length of the message on successful "
"completion.  If a message is too long to fit in the supplied buffer, excess "
"bytes may be discarded depending on the type of socket the message is "
"received from."
msgstr ""
"これらの三つのルーチンはいずれも、成功した場合にはメッセージの長さを返す。 "
"メッセージが長過ぎて指定されたバッファに入り切らなかった場合には、 メッセージ"
"を受信したソケットの種類によっては余分のバイトが捨てられる かもしれない。"

#. type: Plain text
#: build/C/man2/recv.2:121
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""
"ソケットに受け取るメッセージが存在しなかった場合、 受信用のコールはメッセージ"
"が到着するまで待つ。 ただし、ソケットが非停止 (nonblocking)  に設定されていた"
"場合 (B<fcntl>(2)  を参照) は -1 を返し、外部変数 I<errno> に B<EAGAIN> か "
"B<EWOULDBLOCK> を設定する。 これらの受信用のコールは、受信したデータのサイズ"
"が要求したサイズに 達するまで待つのではなく、何らかのデータを受信すると復帰す"
"る (受信されるデータの最大サイズは要求したサイズである)。"

#. type: Plain text
#: build/C/man2/recv.2:127
msgid ""
"The B<select>(2)  or B<poll>(2)  call may be used to determine when more "
"data arrives."
msgstr ""
"B<select>(2)  や B<poll>(2)  コールを使って、次のデータがいつ届くかを判断でき"
"る。"

#. type: Plain text
#: build/C/man2/recv.2:133
msgid ""
"The I<flags> argument to a B<recv>()  call is formed by ORing one or more of "
"the following values:"
msgstr ""
"B<recv>()  コールの I<flags> 引き数には、以下の値を 1つ以上、ビット単位の論理"
"和 を取ったものを指定する:"

#. type: TP
#: build/C/man2/recv.2:133
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() のみ; Linux 2.6.23)"

#. type: Plain text
#: build/C/man2/recv.2:144
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""
"(B<unix>(7)  で説明されている)  B<SCM_RIGHTS> 操作を使って UNIX ドメインの"
"ファイルディスクリプタ経由で受信した ファイルディスクリプタについて close-on-"
"exec フラグをセットする。 このフラグは、 B<open>(2)  の B<O_CLOEXEC> フラグと"
"同じ理由で有用である。"

#. type: TP
#: build/C/man2/recv.2:144 build/C/man2/send.2:186
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr "B<MSG_DONTWAIT> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:154
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK> (this can also be enabled using "
"the B<O_NONBLOCK> flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""
"非停止 (nonblocking) 操作を有効にする。 操作が停止するような場合にエラー "
"B<EAGAIN> か B<EWOULDBLOCK> で呼び出しが失敗する (B<fcntl>(2)  の B<F_SETFL> "
"で B<O_NONBLOCK> フラグを指定することによっても有効にできる)。"

#. type: TP
#: build/C/man2/recv.2:154
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr "B<MSG_ERRQUEUE> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:173
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""
"このフラグを指定すると、 キューに入れられたエラーをソケットのエラーキューから"
"取りだせるようになる。 このエラーは補助メッセージに組み込まれて渡され、 この"
"補助メッセージの種別はプロトコルに依存する (IPv4 の場合は B<IP_RECVERR>)。 "
"ユーザは十分なサイズのバッファを用意しなければならない。 補助メッセージに関す"
"るより詳細な情報は B<cmsg>(3)  および B<ip>(7)  を参照のこと。 エラーの原因と"
"なったオリジナルパケットのペイロードは、 I<msg_iovec> 経由で通常のデータとし"
"て渡される。 エラーを起こしたデータグラムのオリジナルの宛先アドレスは、 "
"I<msg_name> 経由で参照できる。"

#. type: Plain text
#: build/C/man2/recv.2:185 build/C/man2/recv.2:248
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> is set in the I<msghdr>.  After an error has been passed, "
"the pending socket error is regenerated based on the next queued error and "
"will be passed on the next socket operation."
msgstr ""
"ローカルなエラーの場合はアドレスは渡されない\n"
"(これは I<cmsghdr> の I<cmsg_len> メンバーでチェックできる)。\n"
"受信エラーの場合は B<MSG_ERRQUIE> が I<msghdr> にセットされる。\n"
"エラーが渡された後には、キューに入っている次のエラーに基いて、\n"
"処理待ちのソケット・エラーが再生成され、次のソケット操作の際に渡される。"

#. type: Plain text
#: build/C/man2/recv.2:189
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr "このエラーは I<sock_extended_err> 構造体で提供される:"

#. type: Plain text
#: build/C/man2/recv.2:196
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"

#. type: Plain text
#: build/C/man2/recv.2:208
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;     /* padding */\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;     /* padding */\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:210
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"

#. type: Plain text
#: build/C/man2/recv.2:234
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""
"I<ee_errno> にはキューに入れられたエラーの I<errno> が入っている。 "
"I<ee_origin> にはエラーが発生した場所のオリジン・コード (origin code) が入っ"
"ている。 他のフィールドはプロトコル依存である。 B<SO_EE_OFFENDER> マクロは、"
"この補助的なメッセージを引き数に取って、 エラーの発生したネットワークオブジェ"
"クトのアドレスへのポインタを返す。 アドレスが不明の場合には、 I<sockaddr> の "
"I<sa_family> メンバーが B<AF_UNSPEC> になっている。 I<sockaddr> の他のフィー"
"ルドは不定である。 エラーの発生したパケットのペイロードは通常のデータとして渡"
"される。"

#. type: TP
#: build/C/man2/recv.2:248 build/C/man2/recv.2:379 build/C/man2/send.2:228
#, no-wrap
msgid "B<MSG_OOB>"
msgstr "B<MSG_OOB>"

#. type: Plain text
#: build/C/man2/recv.2:255
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such protocols."
msgstr ""
"このフラグは、通常のデータ・ストリームでは受信できない 帯域外 (out-of-band) "
"データの受信を要求する。 プロトコルによっては、 通常のデータ・キューの先頭に"
"速達データを置くものがあるが、 そのようなプロトコルではこのフラグは使用できな"
"い。"

#. type: TP
#: build/C/man2/recv.2:255
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr "B<MSG_PEEK>"

#. type: Plain text
#: build/C/man2/recv.2:262
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""
"このフラグを指定すると、 受信キューの最初のデータを返すとき、キューからデータ"
"を削除しない。 したがって、この後でもう一度受信コールを呼び出すと、同じデータ"
"が返ることになる。"

#. type: TP
#: build/C/man2/recv.2:262
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr "B<MSG_TRUNC> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:273
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), and "
"netlink (since Linux 2.6.22) sockets: return the real length of the packet "
"or datagram, even when it was longer than the passed buffer.  Not "
"implemented for UNIX domain (B<unix>(7))  sockets."
msgstr ""
"raw ソケット (B<AF_PACKET>)、 Internet datagram ソケット (Linux 2.4.27/2.6.8 "
"以降)、 netlink (Linux 2.6.22 以降) ソケットの場合、 パケットやデータグラムの"
"長さが渡したバッファよりも長かった場合にも、 パケットやデータグラムの実際の長"
"さを返す。 UNIX ドメインソケット (B<unix>(7))  ソケットについては実装されてい"
"ない。"

#. type: Plain text
#: build/C/man2/recv.2:276
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr "Internet ストリームソケットでの利用については B<tcp>(7)  を参照。"

#. type: TP
#: build/C/man2/recv.2:276
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr "B<MSG_WAITALL> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/recv.2:283
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned."
msgstr ""
"このフラグは、要求した量いっぱいのデータが到着するまで、 操作を停止 (block) "
"するよう要求する。 但し、シグナルを受信したり、エラーや切断 (disconnect) が発"
"生したり、 次に受信されるデータが異なる型だったりした場合には、 要求した量よ"
"りデータが少なくても返ることがある。"

#. type: Plain text
#: build/C/man2/recv.2:291
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""
"B<recvmsg>()  コールは、直接渡す引き数の数を減らすために I<msghdr> 構造体を使"
"用する。この構造体は I<E<lt>sys/socket.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/recv.2:298
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:308 build/C/man2/send.2:256
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* optional address */\n"
"    socklen_t     msg_namelen;    /* size of address */\n"
"    struct iovec *msg_iov;        /* scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* ancillary data, see below */\n"
"    size_t        msg_controllen; /* ancillary data buffer len */\n"
"    int           msg_flags;      /* flags on received message */\n"
"};\n"
msgstr ""
"struct msghdr {\n"
"    void         *msg_name;       /* 追加のアドレス */\n"
"    socklen_t     msg_namelen;    /* アドレスのサイズ */\n"
"    struct iovec *msg_iov;        /* scatter/gather 配列 */\n"
"    size_t        msg_iovlen;     /* msg_iov の要素数 */\n"
"    void         *msg_control;    /* 補助データ (後述) */\n"
"    size_t        msg_controllen; /* 補助データバッファ長 */\n"
"    int           msg_flags;      /* 受信メッセージのフラグ */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:338
msgid ""
"Here I<msg_name> and I<msg_namelen> specify the source address if the socket "
"is unconnected; I<msg_name> may be given as a NULL pointer if no names are "
"desired or required.  The fields I<msg_iov> and I<msg_iovlen> describe "
"scatter-gather locations, as discussed in B<readv>(2).  The field "
"I<msg_control>, which has length I<msg_controllen>, points to a buffer for "
"other protocol control-related messages or miscellaneous ancillary data.  "
"When B<recvmsg>()  is called, I<msg_controllen> should contain the length of "
"the available buffer in I<msg_control>; upon return from a successful call "
"it will contain the length of the control message sequence."
msgstr ""
"I<msg_name> と I<msg_namelen> は、ソケットが接続されていない場合に送信元のア"
"ドレスを指定する。 名前が必要ない場合には I<msg_name> に NULL ポインタを指定"
"する。 I<msg_iov> と I<msg_iovlen> フィールドは B<readv>(2)  に記述されている"
"ような分解/結合用のベクトル (scatter-gather locations)  を指定する。 "
"I<msg_control> フィールドは I<msg_controllen> の長さを持ち、他のプロトコル制"
"御メッセージや 種々の補助データのためのバッファへのポインタである。 "
"B<recvmsg>()  を呼ぶ際には、 I<msg_controllen> に I<msg_control> のバッファの"
"長さを入れておく必要がある。 コールが成功して返った場合、制御メッセージ列の長"
"さが入っている。"

#. type: Plain text
#: build/C/man2/recv.2:340
msgid "The messages are of the form:"
msgstr "メッセージの形式は以下の通り:"

#. type: Plain text
#: build/C/man2/recv.2:350
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    socklen_t     cmsg_len;     /* data byte count, including hdr */\n"
"    int           cmsg_level;   /* originating protocol */\n"
"    int           cmsg_type;    /* protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""
"struct cmsghdr {\n"
"    socklen_t     cmsg_len;     /* data byte count, including hdr */\n"
"    int           cmsg_level;   /* originating protocol */\n"
"    int           cmsg_type;    /* protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recv.2:355
msgid ""
"Ancillary data should only be accessed by the macros defined in B<cmsg>(3)."
msgstr ""
"補助データは、 B<cmsg>(3)  に定義されたマクロ経由でのみアクセスすべきである。"

#. type: Plain text
#: build/C/man2/recv.2:358
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""
"例をあげると、 Linux はこの補助データのメカニズムを、 UNIX ドメインソケット上"
"での拡張エラーや IP オプション、 ファイル・ディスクリプタの受け渡しに利用して"
"いる。"

#. type: Plain text
#: build/C/man2/recv.2:366
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""
"I<msghdr> の I<msg_flags> フィールドは B<recvmsg>()  からのリターン時に設定さ"
"れる。ここにはいくつかのフラグが入る。"

#. type: TP
#: build/C/man2/recv.2:366
#, no-wrap
msgid "B<MSG_EOR>"
msgstr "B<MSG_EOR>"

#. type: Plain text
#: build/C/man2/recv.2:371
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""
"これはレコードの終り (end-of-record) を示し、 返されたデータが完全なレコード"
"であることを示す (一般的には B<SOCK_SEQPACKET> 型のソケットで使用される)。"

#. type: TP
#: build/C/man2/recv.2:371
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr "B<MSG_TRUNC>"

#. type: Plain text
#: build/C/man2/recv.2:375
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""
"データグラムが与えられたバッファより大きかったために、 データグラムのはみ出し"
"た部分が捨てられたことを示す。"

#. type: TP
#: build/C/man2/recv.2:375
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr "B<MSG_CTRUNC>"

#. type: Plain text
#: build/C/man2/recv.2:379
msgid ""
"indicates that some control data were discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""
"補助データのためのバッファが不足したために、 制御データの一部が捨てられたこと"
"を示す。"

#. type: Plain text
#: build/C/man2/recv.2:382
msgid ""
"is returned to indicate that expedited or out-of-band data were received."
msgstr "速達データや帯域外データを受信したことを示す。"

#. type: TP
#: build/C/man2/recv.2:382
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr "B<MSG_ERRQUEUE>"

#. type: Plain text
#: build/C/man2/recv.2:386
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""
"データは受信しなかったが ソケットのエラー・キューから拡張エラーを受信したこと"
"を示す。"

#. type: Plain text
#: build/C/man2/recv.2:391
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  The return value will be 0 when the peer has performed an orderly "
"shutdown."
msgstr ""
"これらのコールは受信したバイト数を返す。 エラーの場合は -1 を返す。 接続先が"
"正しくシャットダウンを実行した場合は、返り値は 0 となる。"

#. type: Plain text
#: build/C/man2/recv.2:396
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""
"これらはソケット層で発生する一般的なエラーである。 他のエラーが下層のプロトコ"
"ル・モジュールで生成され、 返されるかもしれない。 それらのマニュアルを参照す"
"ること。"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/recv.2:405
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""
"ソケットが非停止 (nonblocking) に設定されていて 受信操作が停止するような状況"
"になったか、 受信に時間切れ (timeout) が設定されていて データを受信する前に時"
"間切れになった。 POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めて"
"おり、 これら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性"
"が必要なアプリケーションでは、両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/recv.2:410
msgid "The argument I<sockfd> is an invalid descriptor."
msgstr "引き数 I<sockfd> が不正なディスクリプタである。"

#. type: Plain text
#: build/C/man2/recv.2:414
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""
"リモートのホストでネットワーク接続が拒否された (よくある理由としては、要求し"
"たサービスが起動されていないなどがある)。"

#. type: Plain text
#: build/C/man2/recv.2:418
msgid ""
"The receive buffer pointer(s) point outside the process's address space."
msgstr "受信バッファへのポインタがプロセスのアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/recv.2:423
msgid ""
"The receive was interrupted by delivery of a signal before any data were "
"available; see B<signal>(7)."
msgstr ""
"データを受信する前に、シグナルが配送されて割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/recv.2:427 build/C/man2/send.2:321
msgid "Invalid argument passed."
msgstr "不正な引き数が渡された。"

#. type: Plain text
#: build/C/man2/recv.2:431
msgid "Could not allocate memory for B<recvmsg>()."
msgstr "B<recvmsg>()  のためのメモリが確保できなかった。"

#. type: TP
#: build/C/man2/recv.2:431 build/C/man2/send.2:344
#, no-wrap
msgid "B<ENOTCONN>"
msgstr "B<ENOTCONN>"

#. type: Plain text
#: build/C/man2/recv.2:438
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""
"ソケットに接続指向プロトコルが割り当てられており、 まだ接続されていない "
"(B<connect>(2)  と B<accept>(2)  を参照のこと)。"

#. type: Plain text
#: build/C/man2/recv.2:443
msgid "The argument I<sockfd> does not refer to a socket."
msgstr "引き数 I<sockfd> がソケットを参照していない。"

#. type: Plain text
#: build/C/man2/recv.2:446
msgid "4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr "4.4BSD (これらの関数は 4.2BSD で現われた), POSIX.1-2001。"

#. type: Plain text
#: build/C/man2/recv.2:453
msgid ""
"POSIX.1-2001 only describes the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""
"POSIX.1-2001 では、 B<MSG_OOB>, B<MSG_PEEK>, B<MSG_WAITALL> フラグだけが記載"
"されている。"

#. type: Plain text
#: build/C/man2/recv.2:469
msgid ""
"The prototypes given above follow glibc2.  The Single UNIX Specification "
"agrees, except that it has return values of type I<ssize_t> (while 4.x BSD "
"and libc4 and libc5 all have I<int>).  The I<flags> argument is I<int> in 4."
"x BSD, but I<unsigned int> in libc4 and libc5.  The I<len> argument is "
"I<int> in 4.x BSD, but I<size_t> in libc4 and libc5.  The I<addrlen> "
"argument is I<int\\ *> in 4.x BSD, libc4 and libc5.  The present I<socklen_t"
"\\ *> was invented by POSIX.  See also B<accept>(2)."
msgstr ""
"上記のプロトタイプは glibc2 にしたがっている。 Single UNIX Specification でも"
"同様だが、 返り値の型が I<ssize_t> となっている (一方で 4.x BSD や libc4 や "
"libc5 は全て I<int> を使用している)。 I<flags> 引き数は 4.x BSD では I<int> "
"だが、libc4 と libc5 では I<unsigned int> である。 I<len> 引き数は 4.x BSD で"
"は I<int> だが、 libc4 と libc5 では I<size_t> である。 I<addrlen> 引き数は "
"4.x BSD, libc4, libc5 では I<int\\ *> である。 現在の I<socklen_t\\ *> は "
"POSIX で発案された。 B<accept>(2)  も参照すること。"

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: build/C/man2/recv.2:483 build/C/man2/send.2:407
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr ""
"POSIX.1-2001 では、構造体 I<msghdr> のフィールド I<msg_controllen> は "
"I<socklen_t> 型であるべきだとされているが、 現在の glibc では I<size_t> 型で"
"ある。"

#. type: Plain text
#: build/C/man2/recv.2:488
msgid ""
"See B<recvmmsg(2)> for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""
"B<recvmmsg>(2)  には、一度の呼び出しでの複数のデータグラムに使用できる Linux "
"固有の システムコールに関する情報が書かれている。"

#. type: Plain text
#: build/C/man2/recv.2:493
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr "B<recvfrom>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/recv.2:504
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<socket>(7)"
msgstr ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<socket>(7)"

#. type: TH
#: build/C/man2/recvmmsg.2:26
#, no-wrap
msgid "RECVMMSG"
msgstr "RECVMMSG"

#. type: TH
#: build/C/man2/recvmmsg.2:26 build/C/man2/select.2:38
#, fuzzy, no-wrap
#| msgid "2012-04-23"
msgid "2012-05-02"
msgstr "2012-04-23"

#. type: Plain text
#: build/C/man2/recvmmsg.2:29
msgid "recvmmsg - receive multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:33 build/C/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:36
#, no-wrap
msgid "B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
msgstr "B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:38
#, no-wrap
msgid "B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr "B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:50
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:62 build/C/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:68 build/C/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"

#. type: Plain text
#: build/C/man2/recvmmsg.2:90
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in B<recvmsg>"
"(2).  The I<msg_len> field is the number of bytes returned for the message "
"in the entry.  This field has the same value as the return value of a single "
"B<recvmsg>(2)  on the header."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""

#. type: TP
#: build/C/man2/recvmmsg.2:97
#, no-wrap
msgid "B<MSG_WAITFORONE>"
msgstr "B<MSG_WAITFORONE>"

#. type: Plain text
#: build/C/man2/recvmmsg.2:102
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:118
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see B<clock_gettime>"
"(2))  defining a timeout (seconds plus nanoseconds) for the receive "
"operation.  (This interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.)  If I<timeout> is I<NULL> then the operation "
"blocks indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:129
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:144
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:152
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:156
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can occur:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:160
msgid "I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:165
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.32.  Support in glibc "
"was added in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:168
msgid "B<recvmmsg>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:175
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), B<socket>"
"(2), B<socket>(7)"
msgstr ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), B<socket>"
"(2), B<socket>(7)"

#. type: TH
#: build/C/man2/select.2:38
#, no-wrap
msgid "SELECT"
msgstr "SELECT"

#. type: Plain text
#: build/C/man2/select.2:42 build/C/man2/select_tut.2:34
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr "select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - 同期 I/O の多重化"

#. type: Plain text
#: build/C/man2/select.2:45 build/C/man2/select_tut.2:37
#, no-wrap
msgid "/* According to POSIX.1-2001 */\n"
msgstr "/* POSIX.1-2001 に従う場合 */\n"

#. type: Plain text
#: build/C/man2/select.2:47 build/C/man2/select.2:68
#: build/C/man2/select_tut.2:39 build/C/man2/select_tut.2:60
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr "B<#include E<lt>sys/select.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/select.2:49 build/C/man2/select_tut.2:41
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr "/* 以前の規格に従う場合 */\n"

#. type: Plain text
#: build/C/man2/select.2:51 build/C/man2/select_tut.2:43
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/select.2:55 build/C/man2/select_tut.2:47
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/select.2:58
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:60 build/C/man2/select_tut.2:52
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:62 build/C/man2/select_tut.2:54
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:64 build/C/man2/select_tut.2:56
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:66 build/C/man2/select_tut.2:58
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr "B<void FD_ZERO(fd_set *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:72
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/select.2:77 build/C/man2/select_tut.2:69
#: build/C/man3/sockatmark.3:34
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/select.2:81 build/C/man2/select_tut.2:73
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"
msgstr ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"

#. type: Plain text
#: build/C/man2/select.2:92
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become \"ready"
"\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform the "
"corresponding I/O operation (e.g., B<read>(2))  without blocking."
msgstr ""
"B<select>()  や B<pselect>()  を使うと、プログラムで複数のファイルディスクリ"
"プタを監視し、 一つ以上のファイルディスクリプタがある種の I/O 操作の 「ready "
"(準備ができた)」状態 (例えば、読み込み可能になった状態)  になるまで待つことが"
"できる。 ファイルディスクリプタが ready (準備ができた) とは、 対応する I/O 操"
"作 (例えば B<read>(2)  など) が停止 (block) なしに実行可能な状態にあることを"
"意味する。"

#. type: Plain text
#: build/C/man2/select.2:98
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, with three "
"differences:"
msgstr ""
"B<select>()  と B<pselect>()  の動作は同じであるが、以下の 3 点が異なる:"

#. type: TP
#: build/C/man2/select.2:98
#, no-wrap
msgid "(i)"
msgstr "(i)"

#. type: Plain text
#: build/C/man2/select.2:108
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""
"B<select>()  では、タイムアウト時間の指定に構造体 I<struct timeval> (秒・マイ"
"クロ秒単位) を用いる。 一方、 B<pselect>()  関数では、構造体 I<struct "
"timespec> (秒・ナノ秒単位) を用いる。"

#. type: TP
#: build/C/man2/select.2:108
#, no-wrap
msgid "(ii)"
msgstr "(ii)"

#. type: Plain text
#: build/C/man2/select.2:116
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""
"B<select>()  は残り時間を示す I<timeout> 引き数を更新することがある。 "
"B<pselect>()  はこの引き数を変更しない。"

#. type: TP
#: build/C/man2/select.2:116
#, no-wrap
msgid "(iii)"
msgstr "(iii)"

#. type: Plain text
#: build/C/man2/select.2:125
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""
"B<select>()  は I<sigmask> 引き数を持たない。その動作は I<sigmask> に NULL を"
"指定した場合の B<pselect>()  と同じである。"

#. type: Plain text
#: build/C/man2/select.2:143
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading "
"(more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if a write will not block, and those in I<exceptfds> will be "
"watched for exceptions.  On exit, the sets are modified in place to indicate "
"which file descriptors actually changed status.  Each of the three file "
"descriptor sets may be specified as NULL if no file descriptors are to be "
"watched for the corresponding class of events."
msgstr ""
"3 つの独立したファイルディスクリプタ集合の監視を行う。 I<readfds> に入れられ"
"たディスクリプタについては、読み込みが可能かどうかを 監視する (より正確にいう"
"と、停止 (block) なしで読むことができるかを 調べる。ファイルの終端 (end-of-"
"file) の場合も、 ファイルディスクリプタは読み込み可能として扱われる)。 "
"I<writefds> に入れられたディスクリプタについては、停止せずに書き込みが 可能か"
"どうかを監視する。 I<exceptfds> にあるものについては、例外の監視を行なう。シ"
"ステムコール終了時に、 どのファイルディスクリプタの状態が実際に変化したか示す"
"ために、 集合の内容が変更される。 ある種別のイベントを監視したいファイルディ"
"スクリプタが一つもない場合には、 対応するファイルディスクリプタ集合に NULL を"
"指定することができる。"

#. type: Plain text
#: build/C/man2/select.2:156
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file "
"descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is "
"part of the set; this is useful after B<select>()  returns."
msgstr ""
"集合を操作するために 4 つのマクロが提供されている。 B<FD_ZERO>()  は集合を消"
"去する。 B<FD_SET>()  と B<FD_CLR>()  はそれぞれ指定したファイルディスクリプ"
"タの集合への追加、削除を行う。 B<FD_ISSET>()  は集合にファイルディスクリプタ"
"があるかどうか調べる; このマクロは B<select>()  が終了した後に使うと便利であ"
"る。"

#. type: Plain text
#: build/C/man2/select.2:159
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr ""
"I<nfds> は 3 つの集合に含まれるファイルディスクリプタの最大値に 1 を足したも"
"のである。"

#. type: Plain text
#: build/C/man2/select.2:179
#, fuzzy
#| msgid ""
#| "I<timeout> is an upper bound on the amount of time elapsed before "
#| "B<select>()  returns.  If both fields of the I<timeval> structure are "
#| "zero, then B<select>()  returns immediately.  (This is useful for "
#| "polling.)  If I<timeout> is NULL (no timeout), B<select>()  can block "
#| "indefinitely."
msgid ""
"The I<timeout> argument specifies the minimum interval that B<select>()  "
"should block waiting for a file descriptor to become ready.  (This interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the blocking interval may overrun by a small amount.)  If "
"both fields of the I<timeval> structure are zero, then B<select>()  returns "
"immediately.  (This is useful for polling.)  If I<timeout> is NULL (no "
"timeout), B<select>()  can block indefinitely."
msgstr ""
"I<timeout> は B<select>()  が復帰するまでの経過時間の上限である。 I<timeval> "
"構造体の両方のフィールドが 0 の場合、 B<select>()  はすぐに復帰する (この機能"
"はポーリング (polling) を行うのに便利である)。 I<timeout> に NULL (タイムアウ"
"トなし)  が指定されると、 B<select>()  は無期限に停止 (block) する。"

#. type: Plain text
#: build/C/man2/select.2:189
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""
"I<sigmask> は、シグナルマスク (B<sigprocmask>(2)  を参照) へのポインタであ"
"る。 I<sigmask> が NULL でない場合、 B<pselect>()  は I<sigmask> が指している"
"シグナルマスクで現在のシグナルマスクを置き換えてから、 \"select\" 関数を実行"
"し、 終了後にシグナルマスクを元のシグナルマスクに戻す。"

#. type: Plain text
#: build/C/man2/select.2:195
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""
"I<timeout> 引き数の精度の違いを除くと、以下の B<pselect>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/select.2:199
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"

#. type: Plain text
#: build/C/man2/select.2:204
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "次のコールを I<atomic> に実行するのと等価である。"

#. type: Plain text
#: build/C/man2/select.2:207
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#: build/C/man2/select.2:211
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/select.2:232
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""
"B<pselect>()  が必要になる理由は、シグナルやファイルディスクリプタの状態変化"
"を 待ちたいときには、競合状態を避けるために atomic なテストが必要になる から"
"である。 (シグナルハンドラが大域フラグを設定して戻る場合を考えてみよう。 この"
"大域フラグのテストに続けて B<select>()  を呼び出すと、 シグナルがテストの直後"
"かつ呼び出しの直前に届いた時には B<select>()  は永久にハングしてしまうかもし"
"れない。 一方、 B<pselect>()  を使うと、まずシグナルを禁止 (block) して、入っ"
"てくるシグナルを操作し、 望みの I<sigmask> で B<pselect>()  を呼び出すこと"
"で、前記の競合を避けることができる。)"

#. type: SS
#: build/C/man2/select.2:232
#, no-wrap
msgid "The timeout"
msgstr "タイムアウト"

#. type: Plain text
#: build/C/man2/select.2:236
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr ""
"これらの関数で使用される時間関連の構造体は、 I<E<lt>sys/time.hE<gt>> で"

#. type: Plain text
#: build/C/man2/select.2:243
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long    tv_sec;         /* 秒 */\n"
"    long    tv_usec;        /* マイクロ秒 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/select.2:247
msgid "and"
msgstr "や"

#. type: Plain text
#: build/C/man2/select.2:254
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* 秒 */\n"
"    long    tv_nsec;        /* ナノ秒 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/select.2:258
msgid "(However, see below on the POSIX.1-2001 versions.)"
msgstr ""
"のように定義されている。 (POSIX.1-2001 での定義については下記の「注意」を参"
"照)"

#. type: Plain text
#: build/C/man2/select.2:266
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""
"秒単位以下の精度でスリープを実現する 移植性の高い方法として、 3 つの集合全て"
"を空、 I<nfds> を 0 、 I<timeout> を NULL でない値に設定して B<select>()  を"
"呼び出すという方法を使っているコードもある。"

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: build/C/man2/select.2:289
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1-2001 permits "
"either behavior.)  This causes problems both when Linux code which reads "
"I<timeout> is ported to other operating systems, and when code is ported to "
"Linux that reuses a I<struct timeval> for multiple B<select>()s in a loop "
"without reinitializing it.  Consider I<timeout> to be undefined after "
"B<select>()  returns."
msgstr ""
"Linux では、 B<select>()  は I<timeout> を変更し、残りの停止時間を反映するよ"
"うになっているが、 他のほとんどの実装ではこのようになっていない "
"(POSIX.1-2001 はどちらの動作も認めている)。 このため、 I<timeout> を参照して"
"いる Linux のコードを他のオペレーティング・システムへ 移植する場合、問題が起"
"こる。 また、ループの中で I<timeval> 構造体を初期化せずにそのまま再利用して "
"B<select>()  を複数回行なっているコードを Linux へ移植する場合にも、問題が起"
"こる。 B<select>()  から復帰した後は I<timeout> は未定義であると考えるべきで"
"ある。"

#. type: Plain text
#: build/C/man2/select.2:306
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set appropriately; the "
"sets and I<timeout> become undefined, so do not rely on their contents after "
"an error."
msgstr ""
"成功した場合、 B<select>()  と B<pselect>()  は更新された 3 つのディスクリプ"
"タ集合に含まれている ファイルディスクリプタの数 (つまり、 I<readfds>, "
"I<writefds>, I<exceptfds> 中の 1 になっているビットの総数) を返す。 何も起こ"
"らずに時間切れになった場合、 ディスクリプタの数は 0 になることもある。 エラー"
"ならば -1 を返し、 I<errno> に適切な値が設定される; 集合と I<timeout> は未定"
"義となるので、エラーが起こった後はそれらの内容を信頼してはならない。"

#. type: Plain text
#: build/C/man2/select.2:312
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr ""
"いずれかの集合に無効なファイルディスクリプタが指定された (おそらくは、すでに"
"クローズされたファイルディスクリプタか、 エラーが発生したファイルディスクリプ"
"タが指定された)。"

#. type: Plain text
#: build/C/man2/select.2:316
msgid "A signal was caught; see B<signal>(7)."
msgstr "シグナルを受信した。"

#. type: Plain text
#: build/C/man2/select.2:322
msgid ""
"I<nfds> is negative or the value contained within I<timeout> is invalid."
msgstr "I<n> が負、または I<timeout> に入っている値が不正である。"

#. type: Plain text
#: build/C/man2/select.2:325
msgid "unable to allocate memory for internal tables."
msgstr "内部テーブルにメモリを割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/select.2:331
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, B<pselect>"
"()  was emulated in glibc (but see BUGS)."
msgstr ""
"B<pselect>()  はカーネル 2.6.16 で Linux に追加された。 それ以前は、 "
"B<pselect>()  は glibc でエミュレートされていた (「バグ」の章を参照)。"

#. type: Plain text
#: build/C/man2/select.2:342
msgid ""
"B<select>()  conforms to POSIX.1-2001 and 4.4BSD (B<select>()  first "
"appeared in 4.2BSD).  Generally portable to/from non-BSD systems supporting "
"clones of the BSD socket layer (including System V variants).  However, note "
"that the System V variant typically sets the timeout variable before exit, "
"but the BSD variant does not."
msgstr ""
"B<select>()  は POSIX.1-2001 と 4.4BSD (B<select>()  は 4.2BSD で最初に登場し"
"た) に準拠する。 BSD ソケット層のクローンをサポートしている非 BSD システム "
"(System V 系も含む) との間でだいたい移植性がある。しかし System V 系では たい"
"がい timeout 変数を exit の前にセットするが、 BSD 系ではそうでないので注意す"
"ること。"

#. type: Plain text
#: build/C/man2/select.2:346
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001."
msgstr "B<pselect>()  は POSIX.1g と POSIX.1-2001 で定義されている。"

#. type: Plain text
#: build/C/man2/select.2:363
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""
"I<fd_set> は固定サイズのバッファである。 負や B<FD_SETSIZE> 以上の値を持つ "
"I<fd> に対して B<FD_CLR>()  や B<FD_SET>()  を実行した場合、 どのような動作を"
"するかは定義されていない。 また、 POSIX では I<fd> は有効なファイルディスクリ"
"プタでなければならないと規定されている。"

#. type: Plain text
#: build/C/man2/select.2:372
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1-2001 "
"situation is"
msgstr ""
"型宣言に関しては、昔ながらの状況では I<timeval> 構造体の 2 つのフィールドは "
"(上記のように) 両方とも I<long> 型であり、構造体は I<E<lt>sys/time.hE<gt>> で"
"定義されている。 POSIX.1-2001 の下では、以下のようになっている。"

#. type: Plain text
#: build/C/man2/select.2:379
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"\t time_t         tv_sec;     /* 秒 */\n"
"\t suseconds_t    tv_usec;    /* マイクロ秒 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/select.2:390
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""
"この構造体は I<E<lt>sys/select.hE<gt>> で定義されており、データ型 I<time_t> "
"と I<suseconds_t> は I<E<lt>sys/types.hE<gt>> で定義されている。"

#. type: Plain text
#: build/C/man2/select.2:402
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""
"プロトタイプに関しては、昔ながらの状況で B<select>()  を使いたい場合は、 "
"I<E<lt>time.hE<gt>> をインクルードすればよい。 POSIX.1-2001 の環境で "
"B<select>()  と B<pselect>()  を使いたい場合は、 I<E<lt>sys/select.hE<gt>> を"
"インクルードすればよい。"

#. type: Plain text
#: build/C/man2/select.2:414
msgid ""
"Libc4 and libc5 do not have a I<E<lt>sys/select.hE<gt>> header; under glibc "
"2.0 and later this header exists.  Under glibc 2.0 it unconditionally gives "
"the wrong prototype for B<pselect>().  Under glibc 2.1 to 2.2.1 it gives "
"B<pselect>()  when B<_GNU_SOURCE> is defined.  Since glibc 2.2.2 the "
"requirements are as shown in the SYNOPSIS."
msgstr ""
"ヘッダファイル I<E<lt>sys/select.hE<gt>> は libc4 と libc5 にはなく、glibc "
"2.0 以降に存在する。 悪いことに glibc 2.0 以前では B<pselect>()  のプロトタイ"
"プが間違っている。 glibc 2.1 から 2.2.1 では B<_GNU_SOURCE> が定義されている"
"場合に、 B<pselect>()  が提供される。 glibc 2.2.2 以降では、 B<pselect>()  を"
"使用するには、「書式」に記載された要件を満たす必要がある。"

#. type: SS
#: build/C/man2/select.2:414
#, no-wrap
msgid "Linux Notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/select.2:422
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the gibc wrapper function."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:437
#, fuzzy
#| msgid ""
#| "The Linux B<pselect>()  system call modifies its I<timeout> argument.  "
#| "However, the glibc wrapper function hides this behavior by using a local "
#| "variable for the timeout argument that is passed to the system call.  "
#| "Thus, the glibc B<pselect>()  function does not modify its I<timeout> "
#| "argument; this is the behavior required by POSIX.1-2001."
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""
"Linux の B<pselect>() システムコールは I<timeout> 引き数を変更する。 しか"
"し、\n"
"glibc のラッパー関数は、システムコールに渡す timeout 引き数 としてローカル変"
"数\n"
"を使うことでこの動作を隠蔽している。 このため、glibc の B<pselect>() 関数は\n"
"I<timeout> 引き数を変更しない。 これが POSIX.1-2001 が要求している動作であ"
"る。"

#. type: Plain text
#: build/C/man2/select.2:443
msgid ""
"The final argument of the B<pselect6()> system call is not a I<sigset_t\\ *> "
"pointer, but is instead a structure of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:451
#, no-wrap
msgid ""
"struct {\n"
"    const sigset_t *ss;     /* Pointer to signal set */\n"
"    size_t          ss_len; /* Size (in bytes) of object pointed\n"
"                               to by 'ss' */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:458
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:464
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""
"glibc 2.0 では、 I<sigmask> 引き数を取らないバージョンの B<pselect>()  が提供"
"されていた。"

#. type: Plain text
#: build/C/man2/select.2:477
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that B<pselect>"
"()  was designed to prevent.  Modern versions of glibc use the (race-free)  "
"B<pselect>()  system call on kernels where it is provided."
msgstr ""
"バージョン 2.1 以降の glibc では、 B<pselect>()  は B<sigprocmask>(2)  と "
"B<select>()  を使ってエミュレートされていた。 この実装にはきわどい競合条件に"
"おいて脆弱性が残っていた。 この競合条件における問題を防止するために "
"B<pselect>()  は設計されたのである。 最近のバージョンの glibc では、カーネル"
"がサポートしている場合には、 (競合が起こらない)  B<pselect>()  システムコール"
"が使用される。"

#. type: Plain text
#: build/C/man2/select.2:490
#, fuzzy
#| msgid ""
#| "On systems that lack B<pselect>(), reliable (and more portable) signal "
#| "trapping can be achieved using the self-pipe trick (where a signal "
#| "handler writes a byte to a pipe whose other end is monitored by B<select>"
#| "()  in the main program.)"
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""
"B<pselect>()  がないシステムにおいて、 シグナルの捕捉を信頼性があり (移植性も"
"高い) 方法で行うには、 自己パイプ (self-pipe) という技を使うとよい (シグナル"
"ハンドラはパイプへ 1 バイトのデータを書き込み、同じパイプのもう一端をメインプ"
"ログラムの B<select>()  で監視するという方法である)。"

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: build/C/man2/select.2:506
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""
"Linux では、 B<select>()  がソケットファイルディスクリプタで \"読み込みの準備"
"ができた\" と報告した場合でも、 この後で read を行うと停止 (block) することが"
"ある。このような状況は、 例えば、データが到着したが、検査でチェックサム異常が"
"見つかり廃棄された時 などに起こりえる。他にもファイルディスクリプタが準備でき"
"たと間違って 報告される状況が起こるかもしれない。 したがって、停止すべきでは"
"ないソケットに対しては B<O_NONBLOCK> を使うとより安全であろう。"

#. type: Plain text
#: build/C/man2/select.2:521
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1-2001.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""
"Linux では、 B<select>()  がシグナルハンドラにより割り込まれた場合 (つまり "
"B<EINTR> エラーが返る場合)、 I<timeout> も変更する。 これは POSIX.1-2001 では"
"認められていない挙動である。 Linux の B<pselect>()  システムコールも同じ挙動"
"をするが、 glibc のラッパー関数がこの挙動を隠蔽している。 具体的には、glibc "
"のラッパー関数の内部で、 I<timeout> をローカル変数にコピーし、 このローカル変"
"数をシステムコールに渡している。"

#. type: Plain text
#: build/C/man2/select.2:528
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/select.2:535
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"

#. type: Plain text
#: build/C/man2/select.2:539
#, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""
"    /* stdin (fd 0) を監視し、入力があった場合に表示する。*/\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"

#. type: Plain text
#: build/C/man2/select.2:543
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""
"    /* 5 秒間監視する。*/\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"

#. type: Plain text
#: build/C/man2/select.2:546
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* この時点での tv の値を信頼してはならない。*/\n"

#. type: Plain text
#: build/C/man2/select.2:554
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""
"    if (retval == -1)\n"
"\tperror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"今、データが取得できました。\\en\");\n"
"        /* FD_ISSET(0, &rfds) が true になる。*/\n"
"    else\n"
"        printf(\"5 秒以内にデータが入力されませんでした。\\en\");\n"

#. type: Plain text
#: build/C/man2/select.2:557
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/select.2:561
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""
"考察と使用例の書かれたチュートリアルとして、 B<select_tut>(2)  がある。"

#. type: Plain text
#: build/C/man2/select.2:573
msgid ""
"For vaguely related stuff, see B<accept>(2), B<connect>(2), B<poll>(2), "
"B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>"
"(7), B<time>(7)"
msgstr ""
"関係がありそうなものを挙げておく: B<accept>(2), B<connect>(2), B<poll>(2), "
"B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<epoll>"
"(7), B<time>(7)"

#. type: TH
#: build/C/man2/select_tut.2:30
#, no-wrap
msgid "SELECT_TUT"
msgstr "SELECT_TUT"

#. type: TH
#: build/C/man2/select_tut.2:30
#, no-wrap
msgid "2010-06-10"
msgstr "2010-06-10"

#. type: Plain text
#: build/C/man2/select_tut.2:50
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"

#. type: Plain text
#: build/C/man2/select_tut.2:64
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set *>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec *>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/select_tut.2:81
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file "
"descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the descriptors."
msgstr ""
"B<select>()  (や B<pselect>())  を使うと、効率的に複数のファイルディスクリプ"
"タを監視し、 そのファイルディスクリプタのいずれかが 「ready (準備ができた)」"
"状態、つまり I/O (入出力) が可能になっているかや、 ファイルディスクリプタのい"
"ずれかが 「例外状態 (exceptional condition)」が発生したか、を調べることができ"
"る。"

#. type: Plain text
#: build/C/man2/select_tut.2:106
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared "
"using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr ""
"この関数の主要な引き数は、3種類のファイルディスクリプタの「集合」 "
"I<readfds>, I<writefds>, I<exceptfds> である。 各々の集合は B<fd_set> として"
"宣言され、その内容は B<FD_CLR>(), B<FD_ISSET>(), B<FD_SET>(), B<FD_ZERO>()  "
"といったマクロによって操作できる。 新しく宣言された集合は、まず最初に "
"B<FD_ZERO>()  を使ってクリアすべきである。 B<select>()  はこれらの集合の内容"
"を、以降に述べる規則に従って修正する。 B<select>()  を呼んだ後、ファイルディ"
"スクリプタがまだ集合に存在しているかどうかは、 B<FD_ISSET>()  マクロによって"
"調べることができる。 B<FD_ISSET>()  は指定されたディスクリプタが集合に存在し"
"ていれば 0 以外の値を返し、 存在しなければ 0 を返す。 B<FD_CLR>()  は集合から"
"のファイルディスクリプタの削除を行う。"

#. type: SS
#: build/C/man2/select_tut.2:106
#, no-wrap
msgid "Arguments"
msgstr "引き数"

#. type: TP
#: build/C/man2/select_tut.2:107
#, no-wrap
msgid "I<readfds>"
msgstr "I<readfds>"

#. type: Plain text
#: build/C/man2/select_tut.2:116
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr ""
"この集合に含まれるいずれかのファイルディスクリプタで、 データの読み込みが可能"
"になったかどうかを監視する。 B<select>()  から戻る時に、I<readfds> のうち、 "
"直ちに読み込み可能なファイルディスクリプタ以外は 集合から削除される。"

#. type: TP
#: build/C/man2/select_tut.2:116
#, no-wrap
msgid "I<writefds>"
msgstr "I<writefds>"

#. type: Plain text
#: build/C/man2/select_tut.2:125
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr ""
"この集合に含まれるいずれかのファイルディスクリプタで、 データを書き込むスペー"
"スがあるかどうかを監視する。 B<select>()  から戻る時に、I<writefds> のうち、 "
"直ちに書き込み可能なファイルディスクリプタ以外は 集合から削除される。"

#. type: TP
#: build/C/man2/select_tut.2:125
#, no-wrap
msgid "I<exceptfds>"
msgstr "I<exceptfds>"

#. type: Plain text
#: build/C/man2/select_tut.2:147
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<tty_ioctl>(4).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr ""
"この集合に含まれるいずれかのファイルディスクリプタで、 「例外状態 "
"(exceptional condition)」が発生したかどうかを監視する。 実際の動作では、普通"
"に起こり得る例外状態は一つだけであり、 それは TCP ソケットで I<帯域外 (out-"
"of-band; OOB)> データが 読み込み可能な場合である。 OOB データの詳細について"
"は、 B<recv>(2), B<send>(2), B<tcp>(7)  を参照のこと。 (これ以外では、まれな"
"ことだが、 パケットモードの擬似端末 (pseudoterminals) で B<select>()  が例外"
"状態を示すことがある。)  B<select>()  が返る時に、I<exceptfds> のうち、 例外"
"状態が発生したディスクリプタ以外は集合から削除される。"

#. type: TP
#: build/C/man2/select_tut.2:147
#, no-wrap
msgid "I<nfds>"
msgstr "I<nfds>"

#. type: Plain text
#: build/C/man2/select_tut.2:154
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr ""
"全ての集合に含まれるファイルディスクリプタのうち、 値が最大のものに 1 を足し"
"た整数である。 すなわち、ファイルディスクリプタを各集合に加える作業の途中"
"で、 全てのファイルディスクリプタを見て最大値を求め、 それに 1 を加えて "
"I<nfds> として渡さないといけない、ということだ。"

#. type: TP
#: build/C/man2/select_tut.2:154
#, no-wrap
msgid "I<utimeout>"
msgstr "I<utimeout>"

#. type: Plain text
#: build/C/man2/select_tut.2:167
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to "
"return immediately, with information about the readiness of file descriptors "
"at the time of the call.  The structure I<struct timeval> is defined as:"
msgstr ""
"(何も起こらなかった場合に)  B<select>()  が戻る前に待つ最大時間である。 この"
"値に NULL を渡すと、 B<select>()  はファイルディスクリプタのいずれかが ready "
"(準備ができた) 状態に なるまで待ち続けてずっと停止する。 I<utimeout> は 0 秒"
"にすることもでき、 この場合 B<select>()  は直ちに返り、呼び出し時点のファイル"
"ディスクリプタの状態に 関する情報が返される。 構造体 I<struct timeval> は次の"
"ように定義されている:"

#. type: Plain text
#: build/C/man2/select_tut.2:174
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"

#. type: TP
#: build/C/man2/select_tut.2:176
#, no-wrap
msgid "I<ntimeout>"
msgstr "I<ntimeout>"

#. type: Plain text
#: build/C/man2/select_tut.2:185
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr ""
"B<pselect>()  のこの引き数は I<utimeout> と同じ意味を持つが、 I<struct "
"timespec> は次に示すようにナノ秒の精度を持つ。"

#. type: Plain text
#: build/C/man2/select_tut.2:192
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"

#. type: TP
#: build/C/man2/select_tut.2:194
#, no-wrap
msgid "I<sigmask>"
msgstr "I<sigmask>"

#. type: Plain text
#: build/C/man2/select_tut.2:211
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, B<pselect>"
"()  will then behave just like B<select>()."
msgstr ""
"この引き数は、呼び出し側が B<pselect>()  内部で停止している間に、カーネルが通"
"知を許可すべきシグナル集合 (すなわち、呼び出したスレッドのシグナルマスクから"
"削除すべきシグナル集合)  を保持する (B<sigaddset>(3)  と B<sigprocmask>(2)  "
"を参照)。 この引き数は NULL にすることもでき、その場合はこの関数へ 入るとき・"
"出るときにシグナルマスクを変更しない。 この場合、 B<pselect>()  は B<select>"
"()  と全く同じ動作となる。"

#. type: SS
#: build/C/man2/select_tut.2:211
#, no-wrap
msgid "Combining Signal and Data Events"
msgstr "シグナルとデータイベントを組み合わせる"

#. type: Plain text
#: build/C/man2/select_tut.2:255
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise B<select>"
"()  would block indefinitely.  Now, somewhere in the main loop will be a "
"conditional to check the global flag.  So we must ask: what if a signal "
"arrives after the conditional, but before the B<select>()  call? The answer "
"is that B<select>()  would block indefinitely, even though an event is "
"actually pending.  This race condition is solved by the B<pselect>()  call.  "
"This call can be used to set the signal mask to a set of signals that are "
"only to be received within the B<pselect>()  call.  For instance, let us say "
"that the event in question was the exit of a child process.  Before the "
"start of the main loop, we would block B<SIGCHLD> using B<sigprocmask>(2).  "
"Our B<pselect>()  call would enable B<SIGCHLD> by using an empty signal "
"mask.  Our program would look like:"
msgstr ""
"ファイルディスクリプタが I/O 可能な状態になるのと同時に シグナルも待ちたい場"
"合には、 B<pselect>()  が便利である。 シグナルを受信するプログラムは、通常"
"は、 シグナルハンドラをグローバルなフラグを立てるためだけに使う。 このグロー"
"バルなフラグは、 そのイベントをプログラムのメインループで 処理しなければなら"
"ないことを示す。 シグナルを受けると B<select>()  (や B<pselect>())  は "
"I<errno> に B<EINTR> をセットして戻ることになる。 シグナルがプログラムのメイ"
"ンループで処理されるためにはこの動作が不可欠で、 これがないと B<select>()  は"
"永遠に停止し続けることになる。 さて、メインループのどこかにこのグローバルフラ"
"グをチェックする 条件文があるとしよう。ここで少し考えてみないといけない。 "
"「シグナルが条件文の後、しかし B<select>()  コールの前に到着したら どうなるの"
"か？」 答えは「その B<select>()  は、たとえ解決待ちのイベントがあったとして"
"も、 永遠に停止する」である。 この競合状態は B<pselect>()  コールによって解決"
"できる。 このコールを使うと、 B<pselect>()  で受信したいシグナルの集合だけを"
"シグナルマスクに設定することができる。 例えば、問題となっているイベントが子プ"
"ロセスの終了の場合を考えよう。 メインループが始まる前に、 B<SIGCHLD> を "
"B<sigprocmask>(2)  でブロックする。 B<pselect>()  コールでは B<SIGCHLD> を、"
"もともとのシグナルマスクを使って有効にするのだ。 このプログラムは次のようにな"
"る。"

#. type: Plain text
#: build/C/man2/select_tut.2:258
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr "static volatile sig_atomic_t got_SIGCHLD = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:264
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:272
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:279
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:287
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:289
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr "    sigemptyset(&empty_mask);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:293
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:299
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:302
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:306
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:310
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""
"        /* main body of program */\n"
"    }\n"
"}\n"

#. type: SS
#: build/C/man2/select_tut.2:311
#, no-wrap
msgid "Practical"
msgstr "実例"

#. type: Plain text
#: build/C/man2/select_tut.2:332
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""
"実際のところ B<select>()  の大事な点は何なのか？ ディスクリプタは好きなときに"
"読み書きできるんじゃないの？ B<select>()  の重要なところは、複数のディスクリ"
"プタを同時に監視でき、 なんの動きもなければプロセスを適切にスリープ状態に移行"
"するところにあるのだ。 UNIX プログラマは、 複数のファイルディスクリプタの入出"
"力を同時に扱わねばならず、 しかもデータの流れは間欠的である、という状況によく"
"出会う。 単に B<read>(2)  や B<write>(2)  コールのシーケンスを作るだけでは、"
"それらのコールのどれかが ファイルディスクリプタからのデータを待ってブロックし"
"ており、 別のファイルディスクリプタには I/O が可能なのに使えない、 ということ"
"になってしまうだろう。 B<select>()  を使うとこの状況に効果的に対処できる。"

#. type: SS
#: build/C/man2/select_tut.2:332
#, no-wrap
msgid "Select Law"
msgstr "SELECT の掟"

#. type: Plain text
#: build/C/man2/select_tut.2:345
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""
"B<select>()  を使おうとした多くの人は、理解しにくい挙動に出くわし、結果的に "
"できたものは移植性がないか、よくてもギリギリのものになってしまう。 例えば、上"
"記のプログラムは、 集合に含まれるファイルディスクリプタを非停止 "
"(nonblocking) モード にしなくても、どこにもブロックが生じないよう注意して書か"
"れている。 微妙な間違いによって、 B<select>()  を使う利点は簡単に失われてしま"
"う。 そこで、 B<select>()  コールを使うときに注意すべき重要事項を列挙しておく"
"ことにする。"

#. type: Plain text
#: build/C/man2/select_tut.2:354
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""
"B<select>()  を使うときは、タイムアウトは設定すべきでない。 処理するデータが"
"無いときには、 あなたのプログラムには何もすることは無いはずである。 タイムア"
"ウトに依存したコードは通常移植性がなく、 デバッグも難しくなる。"

#. type: Plain text
#: build/C/man2/select_tut.2:358
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""
"上述したように、 効率的なプログラムを書くには I<nfds> の値を適切に計算して与"
"えなければならない。"

#. type: Plain text
#: build/C/man2/select_tut.2:365
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""
"B<select>()  コールの終了後に結果をチェックして、 適切に対応するつもりのない"
"ファイルディスクリプタは、 どの集合にも加えてはならない。 次のルールも参照。"

#. type: Plain text
#: build/C/man2/select_tut.2:371
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""
"B<select>()  から返った後には、全ての集合の全てのファイルディスクリプタについ"
"て 読み書き可能な状態になっているかをチェックすべきである。"

#. type: TP
#: build/C/man2/select_tut.2:371
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man2/select_tut.2:386
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions only managing to send or receive a "
"single byte."
msgstr ""
"B<read>(2), B<recv>(2), B<write>(2), B<send>(2)  といった関数は、こちらが要求"
"した全データを読み書きする必要はI<ない>。 もし全データを読み書きするなら、そ"
"れはトラフィックの負荷が小さく、 ストリームが速い場合だろう。この条件は常に満"
"たされるとは限らない。 これらの関数が頑張っても 1 バイトしか送受信できないよ"
"うな場合も 考慮に入れてやらなければならない。"

#. type: TP
#: build/C/man2/select_tut.2:386
#, no-wrap
msgid "6."
msgstr "6."

#. type: Plain text
#: build/C/man2/select_tut.2:394
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""
"処理するデータ量が小さいことがはっきりとわかっている場合を除いて、 一度に 1 "
"バイトずつ読み書きするようなことはしてはならない。 バッファの許すかぎりのデー"
"タをまとめて読み書きしないと、 非常に効率が悪い。下記の例ではバッファは 1024 "
"バイトにしているが、 このサイズを大きくするのは簡単だろう。"

#. type: TP
#: build/C/man2/select_tut.2:394
#, no-wrap
msgid "7."
msgstr "7."

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: build/C/man2/select_tut.2:416
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  as well "
"as the B<select>()  call can return -1 with I<errno> set to B<EINTR>, or "
"with I<errno> set to B<EAGAIN> (B<EWOULDBLOCK>).  These results must be "
"properly managed (not done properly above).  If your program is not going to "
"receive any signals, then it is unlikely you will get B<EINTR>.  If your "
"program does not set nonblocking I/O, you will not get B<EAGAIN>."
msgstr ""
"B<read>(2), B<recv>(2), B<write>(2), B<send>(2)  などの関数や B<select>()  "
"コールは、 I<errno> を B<EINTR や EAGAIN> (B<EWOULDBLOCK>)  にして -1 を返す"
"ことがある。 このような結果に対して適切に対応してやらなければならない (上記の"
"例ではしていない)。 書いているプログラムがシグナルを受ける予定がなければ、 "
"B<EINTR> が返されることはあまり考えられない。 書いているプログラムで非ブロッ"
"ク I/O をセットしていない場合は、 B<EAGAIN> が返されることはないだろう。"

#. type: TP
#: build/C/man2/select_tut.2:416
#, no-wrap
msgid "8."
msgstr "8."

#. type: Plain text
#: build/C/man2/select_tut.2:425
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""
"決して、引き数に長さ 0 のバッファを指定して B<read>(2), B<recv>(2), B<write>"
"(2), B<send>(2)  を呼び出してはならない。"

#. type: TP
#: build/C/man2/select_tut.2:425
#, no-wrap
msgid "9."
msgstr "9."

#. type: Plain text
#: build/C/man2/select_tut.2:441
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that "
"descriptor to B<select>()  again.  In the example below, I close the "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""
"B<read>(2), B<recv>(2), B<write>(2), B<send>(2)  が B<7.> に示した以外のエ"
"ラーで失敗した場合や、 入力系の関数の一つがファイル末尾を表す 0 を返した場合"
"は、 そのディスクリプタをもう一度 select に渡してはI<ならない>。 下記の例で"
"は、そのディスクリプタをただちにクローズし、 そこには -1 をセットして、 それ"
"が集合に含まれ続けるのを許さないようにしている。"

#. type: TP
#: build/C/man2/select_tut.2:441
#, no-wrap
msgid "10."
msgstr "10."

#. type: Plain text
#: build/C/man2/select_tut.2:448
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""
"タイムアウトの値は B<select>()  を呼ぶたびに初期化すべきである。 OS によって"
"は timeout 構造体が変更される場合があるからである。 但し、 B<pselect>()  は自"
"分の timeout 構造体を変更することはない。"

#. type: TP
#: build/C/man2/select_tut.2:448
#, no-wrap
msgid "11."
msgstr "11."

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: build/C/man2/select_tut.2:467
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""
"B<select>()  はファイルディスクリプタ集合を変更するので、 B<select>()  がルー"
"プの中で使用されている場合には、呼び出しを行う前に毎回 ディスクリプタ集合を初"
"期化し直さなければならない。"

#. type: SS
#: build/C/man2/select_tut.2:467
#, no-wrap
msgid "Usleep Emulation"
msgstr "usleep エミュレーション"

#. type: Plain text
#: build/C/man2/select_tut.2:474
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call B<select>"
"()  with a finite timeout and no file descriptors as follows:"
msgstr ""
"B<usleep>(3)  関数を持たないシステムでは、 有限のタイムアウトを指定し、ファイ"
"ルディスクリプタを全くセットせずに B<select>()  を呼び出すことで、これを代用"
"できる。 以下のようにする。"

#. type: Plain text
#: build/C/man2/select_tut.2:480
#, no-wrap
msgid ""
"    struct timeval tv;\n"
"    tv.tv_sec = 0;\n"
"    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"    select(0, NULL, NULL, NULL, &tv);\n"
msgstr ""
"    struct timeval tv;\n"
"    tv.tv_sec = 0;\n"
"    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"    select(0, NULL, NULL, NULL, &tv);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:483
msgid "This is only guaranteed to work on UNIX systems, however."
msgstr "但し、これが動くと保証されているのは UNIX システムに限られる。"

#. type: Plain text
#: build/C/man2/select_tut.2:488
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr ""
"成功すると、 B<select>()  はファイルディスクリプタ集合に残っている ファイル"
"ディスクリプタの総数を返す。"

#. type: Plain text
#: build/C/man2/select_tut.2:494
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr ""
"B<select>()  がタイムアウトすると、返り値は 0 になる。 その時、ファイルディス"
"クリプタ集合はすべて空である (しかしそうならないシステムもある)。"

#. type: Plain text
#: build/C/man2/select_tut.2:501
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr ""
"返り値が -1 の場合はエラーを意味し、 I<errno> が適切にセットされる。エラーが"
"起こった場合、 返された集合の内容や構造体 I<struct timeout> の内容は 未定義と"
"なっており、使用すべきではない。 しかし B<pselect>()  は決して I<ntimeout> を"
"変更しない。"

#. type: Plain text
#: build/C/man2/select_tut.2:510
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""
"一般的に言って、ソケットをサポートする全てのオペレーティングシステムは "
"B<select>()  もサポートしている。 B<select>()  を使うと、プログラマがスレッ"
"ド、フォーク、IPC、シグナル、メモリ共有、 等々を使ってもっと複雑な方法で解決"
"しようとする多くの問題が、 移植性がありかつ効率的な方法で解決できる。"

#. type: Plain text
#: build/C/man2/select_tut.2:519
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""
"B<poll>(2)  システムコールは B<select>()  と同じ機能を持っており、 まばらな"
"ファイルディスクリプタ集合を監視する場合に いくらか効率がよい。 現在では広く"
"利用可能であるが、以前は B<select>()  より移植性の面で劣っていた。"

#. type: Plain text
#: build/C/man2/select_tut.2:527
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""
"Linux 独自の B<epoll>(7)  API は、多数のファイルディスクリプタを監視する場合"
"に B<select>(2)  や B<poll>(2)  よりも効率的なインタフェースを提供している。"

#. type: Plain text
#: build/C/man2/select_tut.2:532
msgid ""
"Here is an example that better demonstrates the true utility of B<select>"
"().  The listing below is a TCP forwarding program that forwards from one "
"TCP port to another."
msgstr ""
"B<select>()  の本当に便利な点を示す、よい例を紹介する。 以下のリストは、ある "
"TCP ポートから別のポートへ転送を行う TCP フォワードプログラムである。"

#. type: Plain text
#: build/C/man2/select_tut.2:545
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man2/select_tut.2:547
#, no-wrap
msgid "static int forward_port;\n"
msgstr "static int forward_port;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:550
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"

#. type: Plain text
#: build/C/man2/select_tut.2:557
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
"    int yes;\n"
msgstr ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
"    int yes;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:581
#, no-wrap
msgid ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
"    yes = 1;\n"
"    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
"            (char *) &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(listen_port);\n"
"    a.sin_family = AF_INET;\n"
"    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(s, 10);\n"
"    return s;\n"
"}\n"
msgstr ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
"    yes = 1;\n"
"    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
"            (char *) &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(listen_port);\n"
"    a.sin_family = AF_INET;\n"
"    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(s, 10);\n"
"    return s;\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:587
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
msgstr ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:593
#, no-wrap
msgid ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:597
#, no-wrap
msgid ""
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(connect_port);\n"
"    a.sin_family = AF_INET;\n"
msgstr ""
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(connect_port);\n"
"    a.sin_family = AF_INET;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:603
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &a.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr ""
"    if (!inet_aton(address, (struct in_addr *) &a.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:612
#, no-wrap
msgid ""
"    if (connect(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(s, SHUT_RDWR);\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    return s;\n"
"}\n"
msgstr ""
"    if (connect(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(s, SHUT_RDWR);\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    return s;\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:620
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: build/C/man2/select_tut.2:628
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"

#. type: Plain text
#: build/C/man2/select_tut.2:630
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr "#define BUF_SIZE 1024\n"

#. type: Plain text
#: build/C/man2/select_tut.2:639
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail, buf1_written;\n"
"    int buf2_avail, buf2_written;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail, buf1_written;\n"
"    int buf2_avail, buf2_written;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:645
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:647
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr "    signal(SIGPIPE, SIG_IGN);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:649
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr "    forward_port = atoi(argv[2]);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:653
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:657
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int r, nfds = 0;\n"
"        fd_set rd, wr, er;\n"
msgstr ""
"    for (;;) {\n"
"        int r, nfds = 0;\n"
"        fd_set rd, wr, er;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:687
#, no-wrap
msgid ""
"        FD_ZERO(&rd);\n"
"        FD_ZERO(&wr);\n"
"        FD_ZERO(&er);\n"
"        FD_SET(h, &rd);\n"
"        nfds = max(nfds, h);\n"
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd1, &rd);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd2, &rd);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
"            FD_SET(fd1, &wr);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
"            FD_SET(fd2, &wr);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &er);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &er);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""
"        FD_ZERO(&rd);\n"
"        FD_ZERO(&wr);\n"
"        FD_ZERO(&er);\n"
"        FD_SET(h, &rd);\n"
"        nfds = max(nfds, h);\n"
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd1, &rd);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd2, &rd);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
"            FD_SET(fd1, &wr);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
"            FD_SET(fd2, &wr);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &er);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &er);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:689
#, no-wrap
msgid "        r = select(nfds + 1, &rd, &wr, &er, NULL);\n"
msgstr "        r = select(nfds + 1, &rd, &wr, &er, NULL);\n"

#. type: Plain text
#: build/C/man2/select_tut.2:692
#, no-wrap
msgid ""
"        if (r == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""
"        if (r == -1 && errno == EINTR)\n"
"            continue;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:697
#, no-wrap
msgid ""
"        if (r == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"        if (r == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:701
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &rd)) {\n"
"            unsigned int l;\n"
"            struct sockaddr_in client_address;\n"
msgstr ""
"        if (FD_ISSET(h, &rd)) {\n"
"            unsigned int l;\n"
"            struct sockaddr_in client_address;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:720
#, no-wrap
msgid ""
"            memset(&client_address, 0, l = sizeof(client_address));\n"
"            r = accept(h, (struct sockaddr *) &client_address, &l);\n"
"            if (r == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = r;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_address.sin_addr));\n"
"            }\n"
"        }\n"
msgstr ""
"            memset(&client_address, 0, l = sizeof(client_address));\n"
"            r = accept(h, (struct sockaddr *) &client_address, &l);\n"
"            if (r == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = r;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_address.sin_addr));\n"
"            }\n"
"        }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:722
#, no-wrap
msgid "        /* NB: read oob data before normal reads */\n"
msgstr "        /* NB: read oob data before normal reads */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:726
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &er)) {\n"
"                char c;\n"
msgstr ""
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &er)) {\n"
"                char c;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:736
#, no-wrap
msgid ""
"                r = recv(fd1, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    send(fd2, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &er)) {\n"
"                char c;\n"
msgstr ""
"                r = recv(fd1, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    send(fd2, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &er)) {\n"
"                char c;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:779
#, no-wrap
msgid ""
"                r = recv(fd2, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    send(fd1, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &rd)) {\n"
"                r = read(fd1, buf1 + buf1_avail,\n"
"                          BUF_SIZE - buf1_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf1_avail += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &rd)) {\n"
"                r = read(fd2, buf2 + buf2_avail,\n"
"                          BUF_SIZE - buf2_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf2_avail += r;\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &wr)) {\n"
"                r = write(fd1, buf2 + buf2_written,\n"
"                           buf2_avail - buf2_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf2_written += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &wr)) {\n"
"                r = write(fd2, buf1 + buf1_written,\n"
"                           buf1_avail - buf1_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf1_written += r;\n"
"            }\n"
msgstr ""
"                r = recv(fd2, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    send(fd1, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &rd)) {\n"
"                r = read(fd1, buf1 + buf1_avail,\n"
"                          BUF_SIZE - buf1_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf1_avail += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &rd)) {\n"
"                r = read(fd2, buf2 + buf2_avail,\n"
"                          BUF_SIZE - buf2_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf2_avail += r;\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &wr)) {\n"
"                r = write(fd1, buf2 + buf2_written,\n"
"                           buf2_avail - buf2_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf2_written += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &wr)) {\n"
"                r = write(fd2, buf1 + buf1_written,\n"
"                           buf1_avail - buf1_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf1_written += r;\n"
"            }\n"

#. type: Plain text
#: build/C/man2/select_tut.2:781
#, no-wrap
msgid "        /* check if write data has caught read data */\n"
msgstr "        /* check if write data has caught read data */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:786
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"

#. type: Plain text
#: build/C/man2/select_tut.2:789
#, no-wrap
msgid ""
"        /* one side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""
"        /* one side has closed the connection, keep\n"
"           writing to the other side until empty */\n"

#. type: Plain text
#: build/C/man2/select_tut.2:797
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/select_tut.2:811
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""
"上記のプログラムは、ほとんどの種類の TCP 接続をフォワードする。 B<telnet> "
"サーバによって中継される OOB シグナルデータも扱える。 このプログラムは、デー"
"タフローを双方向に同時に送るという、 ややこしい問題も処理できる。 B<fork>"
"(2)  コールを使って、各ストリームごとに専用のスレッドを用いるほうが効率的"
"だ、 という人もいるかもしれない。しかし、これは考えているよりずっとややこし"
"い。 あるいは、 B<fcntl>(2)  を使って非ブロック I/O をセットすれば良い、とい"
"うアイデアもあるだろう。 これにも実際には問題があり、タイムアウトが非効率的に"
"起こってしまう。"

#. type: Plain text
#: build/C/man2/select_tut.2:817
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of buffers"
"\\(emone for each connection.  At the moment, new connections cause the "
"current connection to be dropped."
msgstr ""
"このプログラムは一度にひとつ以上の同時接続を扱うことはできないが、 その様に拡"
"張するのは簡単で、バッファのリンクリストを (接続ごとにひとつずつ) 使えばよ"
"い。 現時点のものでは、新しい接続がくると古い接続は落ちてしまう。"

#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#: build/C/man2/select_tut.2:836
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), B<recv>"
"(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<sigaddset>"
"(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), B<sigismember>"
"(3), B<epoll>(7)"
msgstr ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), B<recv>"
"(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), B<sigaddset>"
"(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), B<sigismember>"
"(3), B<epoll>(7)"

#. type: TH
#: build/C/man2/send.2:38
#, no-wrap
msgid "SEND"
msgstr "SEND"

#. type: TH
#: build/C/man2/send.2:38 build/C/man7/socket.7:26
#, no-wrap
msgid "2012-04-23"
msgstr "2012-04-23"

#. type: Plain text
#: build/C/man2/send.2:41
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr "send, sendto, sendmsg - ソケットへメッセージを送る"

#. type: Plain text
#: build/C/man2/send.2:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/send.2:48
#, no-wrap
msgid "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/send.2:52
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"
msgstr ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t >I<addrlen>B<);>\n"

#. type: Plain text
#: build/C/man2/send.2:55
#, no-wrap
msgid "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"
msgstr "B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/send.2:63
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""
"システムコール B<send>(), B<sendto>(), B<sendmsg>()  は、もう一方のソケットへ"
"メッセージを転送するのに使用される。"

#. type: Plain text
#: build/C/man2/send.2:82
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""
"B<send>()  は、ソケットが I<接続された (connected)> 状態にある場合にのみ使用"
"できる (つまり、どの相手に送信するかは既知である)。 B<send>()  と B<write>"
"(2)  の違いは、引き数に I<flags> があるかどうかだけである。 引き数 I<flags> "
"にフラグが指定されない場合、 B<send>()  は B<write>(2)  と等価である。 また、"

#. type: Plain text
#: build/C/man2/send.2:84
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr "    send(sockfd, buf, len, flags);\n"

#. type: Plain text
#: build/C/man2/send.2:86
msgid "is equivalent to"
msgstr "は以下と等価である。"

#. type: Plain text
#: build/C/man2/send.2:88
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr "    sendto(sockfd, buf, len, flags, NULL, 0);\n"

#. type: Plain text
#: build/C/man2/send.2:92
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""
"引き数 I<sockfd> は、データを送信するパケットのファイル・ディスクリプタであ"
"る。"

#. type: Plain text
#: build/C/man2/send.2:120
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""
"B<sendto>()  は、接続型 (connection-mode) のソケット (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  で 使用された場合、引き数 I<dest_addr> と I<addrlen> は無"
"視される (各々の引き数が NULL と 0 でない場合は B<EISCONN> エラーも返され"
"る)。 また、ソケットが実際には接続されていなかった時には B<ENOTCONN> エラーが"
"返される。 接続型のソケット以外で使用された場合は、接続先のアドレスは "
"I<dest_addr> で与えられ、そのサイズは I<addrlen> で指定される。 B<sendmsg>"
"()  では、接続先のアドレスは I<msg.msg_name> で与えられ、そのサイズは I<msg."
"msg_namelen> で指定される。"

#. type: Plain text
#: build/C/man2/send.2:136
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""
"B<send>()  と B<sendto>()  では、メッセージは I<buf> に格納されており、その長"
"さは I<len> であると解釈される。 B<sendmsg>()  では、メッセージは 配列 I<msg."
"msg_iov> の各要素が指す位置に格納されている。 B<sendmsg>()  では、補助データ "
"(制御情報とも呼ばれる) を送信することもできる。"

#. type: Plain text
#: build/C/man2/send.2:141
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""
"メッセージ長が長過ぎるために、そのソケットが使用するプロトコルでは、 メッセー"
"ジをソケットに渡されたままの形で送信することができない場合、 B<EMSGSIZE> エ"
"ラーが返され、そのメッセージは転送されない。"

#. type: Plain text
#: build/C/man2/send.2:145
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""
"B<send>()  では、配送の失敗の通知は明示的に行われる。 ローカル側でエラーが検"
"出された場合は、返り値 -1 として通知される。"

#. type: Plain text
#: build/C/man2/send.2:158
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""
"メッセージがソケットの送信バッファに入れることができない場合、 B<send>()  は"
"通常は停止 (block) する (ソケットが非停止 (nonblocking) I/O モード でない場"
"合)。非停止モードの場合にはエラー B<EAGAIN> か B<EWOULDBLOCK> で失敗する。 い"
"つデータをさらに送信できるようになるかを知るために、 B<select>(2)  コールを使"
"用することができる。"

#.  FIXME ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: build/C/man2/send.2:164
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""
"I<flags> 引き数は、以下のフラグの (0 個以上の) ビット単位の論理和を とったも"
"のを指定する。"

#. type: TP
#: build/C/man2/send.2:164
#, no-wrap
msgid "B<MSG_CONFIRM> (Since Linux 2.3.15)"
msgstr "B<MSG_CONFIRM> (Linux 2.3.15 以降)"

#. type: Plain text
#: build/C/man2/send.2:178
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Only valid on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently only implemented for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""
"転送処理に進展があった、つまり相手側から成功の応答を受けたことをリンク層に 知"
"らせる。リンク層がこの通知を受け取らなかった場合には、通常どおり (ユニキャス"
"ト ARP を使うなどの方法で) 近傍 (neighbor) の再検索を行う。 B<SOCK_DGRAM> と "
"B<SOCK_RAW> のソケットに対してのみ有効で、現在のところ IPv4 と IPv6 のみ実装"
"されている。 詳しくは B<arp>(7)  参照のこと。"

#. type: TP
#: build/C/man2/send.2:178
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr "B<MSG_DONTROUTE>"

#. type: Plain text
#: build/C/man2/send.2:186
msgid ""
"Don't use a gateway to send out the packet, only send to hosts on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is only defined for protocol families that route; packet "
"sockets don't."
msgstr ""
"パケットを送り出すのにゲートウェイを使用せず、 直接接続されているネットワーク"
"上のホストだけに送る。 通常、このフラグは診断 (diagnostic) やルーティング・プ"
"ログラムに よってのみ使用される。このフラグは、経路制御が行われるプロトコル"
"ファミリー に対してのみ定義されている。パケットソケットには定義されていない。"

#. type: Plain text
#: build/C/man2/send.2:197
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned (this can also be enabled using the B<O_NONBLOCK> "
"flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""
"非停止 (nonblocking) 操作を有効にする。操作が停止されるような場合には "
"B<EAGAIN> か B<EWOULDBLOCK> を返すようにする (B<fcntl>(2)  の B<F_SETFL> で "
"B<O_NONBLOCK> フラグを指定することによっても有効にできる)。"

#. type: TP
#: build/C/man2/send.2:197
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr "B<MSG_EOR> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/send.2:201
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""
"レコードの終了を指示する (B<SOCK_SEQPACKET> のようにこの概念に対応しているソ"
"ケット種別のときに有効)。"

#. type: TP
#: build/C/man2/send.2:201
#, no-wrap
msgid "B<MSG_MORE> (Since Linux 2.4.4)"
msgstr "B<MSG_MORE> (Linux 2.4.4 以降)"

#. type: Plain text
#: build/C/man2/send.2:210
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""
"呼び出し元にさらに送るデータがあることを示す。 このフラグは TCP ソケットとと"
"もに使用され、 B<TCP_CORK> ソケットオプションと同じ効果が得られる (B<tcp>"
"(7)  を参照)。 B<TCP_CORK> との違いは、このフラグを使うと呼び出し単位で この"
"機能を有効にできる点である。"

#. type: Plain text
#: build/C/man2/send.2:219
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is only transmitted when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""
"Linux 2.6 以降では、このフラグは UDP ソケットでもサポートされており、 このフ"
"ラグ付きで送信された全てのデータを一つのデータグラムにまとめて 送信すること"
"を、カーネルに知らせる。まとめられたデータグラムは、 このフラグを指定せずにこ"
"のシステムコールが実行された際に初めて送信される (B<udp>(7)  に記載されている"
"ソケットオプション B<UDP_CORK> も参照)。"

#. type: TP
#: build/C/man2/send.2:219
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr "B<MSG_NOSIGNAL> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/send.2:228
msgid ""
"Requests not to send B<SIGPIPE> on errors on stream oriented sockets when "
"the other end breaks the connection.  The B<EPIPE> error is still returned."
msgstr ""
"ストリーム指向のソケットで相手側が接続を切断した時に、エラーとして "
"B<SIGPIPE> を送信しないように要求する。この場合でも B<EPIPE> は返される。"

#. type: Plain text
#: build/C/man2/send.2:237
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""
"I<帯域外 (out-of-band)> データをサポートするソケット (例えば "
"B<SOCK_STREAM>)  で I<帯域外> データを送る。下位プロトコルも I<帯域外> データ"
"をサポートしている必要がある。"

#. type: Plain text
#: build/C/man2/send.2:244
msgid ""
"The definition of the I<msghdr> structure follows.  See B<recv>(2)  and "
"below for an exact description of its fields."
msgstr ""
"I<msghdr> 構造体の内容は以下の通り。 各フィールドの正確な記述については "
"B<recv>(2)  と以下の説明を参照すること。"

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#.   The flags returned in msg_flags.
#. type: Plain text
#: build/C/man2/send.2:273
msgid ""
"You may send control information using the I<msg_control> and "
"I<msg_controllen> members.  The maximum control buffer length the kernel can "
"process is limited per socket by the value in I</proc/sys/net/core/"
"optmem_max>; see B<socket>(7)."
msgstr ""
"I<msg_control> と I<msg_controllen> メンバーを使用して制御情報を送信すること"
"ができる。 カーネルが処理できる制御バッファのソケットあたりの最大長は、 I</"
"proc/sys/net/core/optmem_max> の値に制限されている。 B<socket>(7)  を参照。"

#. type: Plain text
#: build/C/man2/send.2:278
msgid ""
"On success, these calls return the number of characters sent.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールは送信されたバイト数を返す。 エラーの場"
"合、 -1 を返し、 I<errno> を適切に設定にする。"

#. type: Plain text
#: build/C/man2/send.2:283
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""
"これらはソケット層で発生する一般的なエラーである。これ以外に、下層の プロトコ"
"ル・モジュールで生成されたエラーが返されるかもしれない。 これらについては、そ"
"れぞれのマニュアルを参照すること。"

#. type: Plain text
#: build/C/man2/send.2:291
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See B<path_resolution>"
"(7).)"
msgstr ""
"(UNIX ドメインソケットの場合; パス名で識別される。)\n"
"\n"
"ソケット・ファイルへの書き込み許可がなかったか、パス名へ到達するまでの\n"
"ディレクトリのいずれかに対する検索許可がなかった。\n"
"(B<path_resolution>(7) も参照のこと)"

#. type: Plain text
#: build/C/man2/send.2:294
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""
"(UDP ソケットの場合) ユニキャストアドレスであるかのように、\n"
"ネットワークアドレスやブロードキャストアドレスへの送信が試みられた。"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/send.2:302
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""
"ソケットが非停止に設定されており、 要求された操作が停止した。 POSIX.1-2001 "
"は、この場合にどちらのエラーを返すことも認めており、 これら 2 つの定数が同じ"
"値を持つことも求めていない。 したがって、移植性が必要なアプリケーションでは、"
"両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/send.2:305
msgid "An invalid descriptor was specified."
msgstr "無効なディスクリプターが指定された。"

#. type: TP
#: build/C/man2/send.2:305
#, no-wrap
msgid "B<ECONNRESET>"
msgstr "B<ECONNRESET>"

#. type: Plain text
#: build/C/man2/send.2:308
msgid "Connection reset by peer."
msgstr "接続が接続相手によりリセットされた。"

#. type: TP
#: build/C/man2/send.2:308
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: build/C/man2/send.2:311
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""
"ソケットが接続型 (connection-mode) ではなく、 かつ送信先のアドレスが設定され"
"ていない。"

#. type: Plain text
#: build/C/man2/send.2:314
msgid "An invalid user space address was specified for an argument."
msgstr "ユーザー空間として不正なアドレスがパラメーターとして指定された。"

#. type: Plain text
#: build/C/man2/send.2:318
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr "データが送信される前に、シグナルが発生した。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/send.2:327
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""
"接続型ソケットの接続がすでに確立していたが、受信者が指定されていた。 (現在の"
"ところ、この状況では、このエラーが返されるか、 受信者の指定が無視されるか、の"
"いずれかとなる)"

#. type: TP
#: build/C/man2/send.2:327
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: build/C/man2/send.2:333
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""
"そのソケット種別 ではソケットに渡されたままの形でメッセージを送信する必要があ"
"るが、 メッセージが大き過ぎるため送信することができない。"

#. type: Plain text
#: build/C/man2/send.2:341
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""
"ネットワーク・インターフェースの出力キューが一杯である。 一般的には、一時的な"
"輻輳 (congestion) のためにインターフェースが 送信を止めていることを意味す"
"る。 (通常、Linux ではこのようなことは起こらない。デバイスのキューが オーバー"
"フローした場合にはパケットは黙って捨てられる)"

#. type: Plain text
#: build/C/man2/send.2:344
msgid "No memory available."
msgstr "メモリが足りない。"

#. type: Plain text
#: build/C/man2/send.2:347
msgid "The socket is not connected, and no target has been given."
msgstr "ソケットが接続されておらず、接続先も指定されていない。"

#. type: Plain text
#: build/C/man2/send.2:357
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""
"引き数 I<flags> のいくつかのビットが、そのソケット種別では不適切なものであ"
"る。"

#. type: TP
#: build/C/man2/send.2:357
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: build/C/man2/send.2:366
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""
"接続指向のソケットでローカル側が閉じられている。 この場合、 B<MSG_NOSIGNAL> "
"が設定されていなければ、プロセスには B<SIGPIPE> も同時に送られる。"

#. type: Plain text
#: build/C/man2/send.2:369
msgid "4.4BSD, SVr4, POSIX.1-2001.  These function calls appeared in 4.2BSD."
msgstr ""
"4.4BSD, SVr4, POSIX.1-2001.  (これらの関数コールは 4.2BSD で最初に登場した)。"

#. type: Plain text
#: build/C/man2/send.2:380
msgid ""
"POSIX.1-2001 only describes the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""
"POSIX.1-2001 には、 B<MSG_OOB> と B<MSG_EOR> フラグだけが記載されている。 "
"POSIX.1-2008 では B<MSG_NOSIGNAL> が規格に追加されている。 B<MSG_CONFIRM> フ"
"ラグは Linux での拡張である。"

#. type: Plain text
#: build/C/man2/send.2:393
msgid ""
"The prototypes given above follow the Single UNIX Specification, as glibc2 "
"also does; the I<flags> argument was I<int> in 4.x BSD, but I<unsigned int> "
"in libc4 and libc5; the I<len> argument was I<int> in 4.x BSD and libc4, but "
"I<size_t> in libc5; the I<addrlen> argument was I<int> in 4.x BSD and libc4 "
"and libc5.  See also B<accept>(2)."
msgstr ""
"上記のプロトタイプは Single UNIX Specification に従っている。 glibc2 も同様で"
"ある。 I<flags> 引き数は 4.x BSD では I<int> であり、 libc4 と libc5 では "
"I<unsigned int> である。 I<len> 引き数は 4.x BSD と libc4 では I<int> であ"
"り、 libc5 では I<size_t> である。 I<addrlen> 引き数は 4.x BSD と libc4 と "
"libc5 では I<int> である。 B<accept>(2)  も参照すること。"

#. type: Plain text
#: build/C/man2/send.2:412
msgid ""
"See B<sendmmsg(2)> for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""
"B<sendmmsg>(2)  には、一度の呼び出しでの複数のデータグラムの送信に使用でき"
"る\n"
"Linux 固有の システムコールに関する情報が書かれている。"

#. type: Plain text
#: build/C/man2/send.2:417
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr "Linux は B<ENOTCONN> を返す状況で B<EPIPE> を返すことがある。"

#. type: Plain text
#: build/C/man2/send.2:422
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr "B<sendto>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/send.2:437
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), B<ip>"
"(7), B<socket>(7), B<tcp>(7), B<udp>(7)"
msgstr ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), B<ip>"
"(7), B<socket>(7), B<tcp>(7), B<udp>(7)"

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr "SENDMMSG"

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "2012-02-27"
msgstr "2012-02-27"

#. type: Plain text
#: build/C/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int >I<vlen>B<,>\n"
"B<             unsigned int >I<flags>B<);>\n"

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: build/C/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in B<sendmsg>"
"(2).  The I<msg_len> field is used to return the number of bytes sent from "
"the message in I<msg_hdr> (i.e., the same as the return value from a single "
"B<sendmsg>(2)  call)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#
#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#.      This matches the behaviour of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: build/C/man2/sendmmsg.2:145
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:150
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:153
msgid "B<sendmmsg>()  is Linux-specific."
msgstr ""

#
#
#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: build/C/man2/sendmmsg.2:168
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:173
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"

#. type: TH
#: build/C/man3/sockatmark.3:23
#, no-wrap
msgid "SOCKATMARK"
msgstr "SOCKATMARK"

#. type: Plain text
#: build/C/man3/sockatmark.3:26
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr ""
"sockatmark - どのソケットに帯域外 (out-of-band) マークが付けられているかを調"
"べる"

#. type: Plain text
#: build/C/man3/sockatmark.3:28 build/C/man2/socket.2:48
#: build/C/man7/socket.7:31 build/C/man2/socketpair.2:47
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr "B<#include E<lt>sys/socket.hE<gt>>"

#. type: Plain text
#: build/C/man3/sockatmark.3:30
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr "B<int sockatmark(int >I<sockfd>B<);>"

#. type: Plain text
#: build/C/man3/sockatmark.3:39
msgid ""
"B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>="
"\\ 600"
msgstr ""
"B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>="
"\\ 600"

#. type: Plain text
#: build/C/man3/sockatmark.3:49
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If "
"the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""
"B<sockatmark>()  はファイルディスクリプタ I<sockfd> で参照されるソケットに帯"
"域外マークが付けられているか否かを返す。 ソケットにマークが付けられている場合"
"は、1 が返される。 ソケットにマークが付けられていない場合は、0 が返される。 "
"この関数は帯域外マークを削除しない。"

#. type: Plain text
#: build/C/man3/sockatmark.3:54
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the out-"
"of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"B<sockatmark>()  の呼び出しが成功した場合、ソケットに帯域外マークが 付けられ"
"ていれば 1 を返し、付けられていなければ 0 を返す。 エラーの場合は -1 が返さ"
"れ、エラーを表す I<errno> が設定される。"

#. type: Plain text
#: build/C/man3/sockatmark.3:59
msgid "I<sockfd> is not a valid file descriptor."
msgstr "I<sockfd> が有効なファイルディスクリプタでない。"

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: build/C/man3/sockatmark.3:66
msgid ""
"I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""
"I<sockfd> は B<sockatmark>()  が適用できないファイルディスクリプタである。"

#. type: Plain text
#: build/C/man3/sockatmark.3:69
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr "B<sockatmark>()  は glibc バージョン 2.2.4 で追加された。"

#. type: Plain text
#: build/C/man3/sockatmark.3:71
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/sockatmark.3:78
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""
"B<sockatmark>()  が 1 を返す場合、帯域外データは B<MSG_OOB> を指定した "
"B<recv>(2)  で読み込むことができる。"

#. type: Plain text
#: build/C/man3/sockatmark.3:80
msgid "Out-of-band data is only supported on some stream socket protocols."
msgstr ""
"帯域外データは、いくつかのストリームソケットプロトコルでしか サポートされてい"
"ない。"

#. type: Plain text
#: build/C/man3/sockatmark.3:85
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""
"B<sockatmark>()  は B<SIGURG> シグナルのハンドラから安全に呼び出すことができ"
"る。"

#. type: Plain text
#: build/C/man3/sockatmark.3:91
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""
"B<sockatmark>()  は B<SIOCATMARK> B<ioctl>(2)  操作を使って実装されている。"

#. type: Plain text
#: build/C/man3/sockatmark.3:95
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr "glibc 2.4 より前のバージョンでは、 B<sockatmark>()  は動作しない。"

#. type: Plain text
#: build/C/man3/sockatmark.3:100
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the "
"mark:"
msgstr ""
"以下のコードは、 B<SIGURG> シグナルを受け取った後にマークまでの全てのデータを"
"読み込んで (破棄し)、 マークされたデータのバイトを読み込むのに使用できる。"

#. type: Plain text
#: build/C/man3/sockatmark.3:105
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:112
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:115
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr ""
"        if (atmark)\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:122
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN) E<lt>= 0);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr ""
"        s = read(sockfd, buf, BUF_LEN) E<lt>= 0);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:129
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/sockatmark.3:135
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"

#. type: TH
#: build/C/man2/socket.2:41 build/C/man7/socket.7:26
#, no-wrap
msgid "SOCKET"
msgstr "SOCKET"

#. type: TH
#: build/C/man2/socket.2:41
#, no-wrap
msgid "2009-01-19"
msgstr "2009-01-19"

#. type: Plain text
#: build/C/man2/socket.2:44
msgid "socket - create an endpoint for communication"
msgstr "socket - 通信のための端点(endpoint)を作成する"

#. type: Plain text
#: build/C/man2/socket.2:46 build/C/man2/socketpair.2:45
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr "B<#include E<lt>sys/types.hE<gt>> /* 「注意」参照 */"

#. type: Plain text
#: build/C/man2/socket.2:50
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"

#. type: Plain text
#: build/C/man2/socket.2:53
msgid ""
"B<socket>()  creates an endpoint for communication and returns a descriptor."
msgstr ""
"B<socket>()  は通信のための端点(endpoint)を作成し、ディスクリプター"
"(descriptor)を返す。"

#. type: Plain text
#: build/C/man2/socket.2:61
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The currently understood formats "
"include:"
msgstr ""
"I<domain> 引数は通信を行なうドメインを指定する; これはどの プロトコル・ファミ"
"リ(protocol family)を通信に使用するかを指定する。 これらのファミリは "
"I<E<lt>sys/socket.hE<gt>> に定義されている。 現在、理解できるフォーマットは以"
"下の通り。"

#. type: tbl table
#: build/C/man2/socket.2:64
#, no-wrap
msgid "Name:Purpose:Man page\n"
msgstr "名前:目的:マニュアル\n"

#. type: tbl table
#: build/C/man2/socket.2:65 build/C/man2/socket.2:72 build/C/man2/socket.2:77
#: build/C/man2/socket.2:82 build/C/man2/socket.2:85 build/C/man2/socket.2:92
#: build/C/man2/socket.2:97 build/C/man2/socket.2:102
#: build/C/man2/socket.2:105 build/C/man2/socket.2:110
#, no-wrap
msgid "T{\n"
msgstr "T{\n"

#. type: tbl table
#: build/C/man2/socket.2:66
#, no-wrap
msgid "B<AF_UNIX>, B<AF_LOCAL>\n"
msgstr "B<AF_UNIX>, B<AF_LOCAL>\n"

#. type: tbl table
#: build/C/man2/socket.2:67 build/C/man2/socket.2:69 build/C/man2/socket.2:87
#: build/C/man2/socket.2:89 build/C/man2/socket.2:99 build/C/man2/socket.2:112
#: build/C/man2/socket.2:114 build/C/man7/socket.7:162
#, no-wrap
msgid "T}:T{\n"
msgstr "T}:T{\n"

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "Local communication\n"
msgstr "ローカル通信\n"

#. type: tbl table
#: build/C/man2/socket.2:70
#, no-wrap
msgid "B<unix>(7)\n"
msgstr "B<unix>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:71 build/C/man2/socket.2:76 build/C/man2/socket.2:81
#: build/C/man2/socket.2:91 build/C/man2/socket.2:96 build/C/man2/socket.2:109
#: build/C/man2/socket.2:116 build/C/man7/socket.7:141
#: build/C/man7/socket.7:145 build/C/man7/socket.7:148
#: build/C/man7/socket.7:154 build/C/man7/socket.7:157
#: build/C/man7/socket.7:166 build/C/man7/socket.7:173
#, no-wrap
msgid "T}\n"
msgstr "T}\n"

#. type: tbl table
#: build/C/man2/socket.2:73
#, no-wrap
msgid "B<AF_INET>\n"
msgstr "B<AF_INET>\n"

#. type: tbl table
#: build/C/man2/socket.2:74
#, no-wrap
msgid "T}:IPv4 Internet protocols:T{\n"
msgstr "T}:IPv4 インターネット・プロトコル:T{\n"

#. type: tbl table
#: build/C/man2/socket.2:75
#, no-wrap
msgid "B<ip>(7)\n"
msgstr "B<ip>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:78
#, no-wrap
msgid "B<AF_INET6>\n"
msgstr "B<AF_INET6>\n"

#. type: tbl table
#: build/C/man2/socket.2:79
#, no-wrap
msgid "T}:IPv6 Internet protocols:T{\n"
msgstr "T}:IPv6 インターネット・プロトコル:T{\n"

#. type: tbl table
#: build/C/man2/socket.2:80
#, no-wrap
msgid "B<ipv6>(7)\n"
msgstr "B<ipv6>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:83
#, no-wrap
msgid "B<AF_IPX>\n"
msgstr "B<AF_IPX>\n"

#. type: tbl table
#: build/C/man2/socket.2:84
#, no-wrap
msgid "T}:IPX - Novell protocols:\n"
msgstr "T}:IPX - Novell プロトコル:\n"

#. type: tbl table
#: build/C/man2/socket.2:86
#, no-wrap
msgid "B<AF_NETLINK>\n"
msgstr "B<AF_NETLINK>\n"

#. type: tbl table
#: build/C/man2/socket.2:88
#, no-wrap
msgid "Kernel user interface device\n"
msgstr "カーネル・ユーザ・デバイス\n"

#. type: tbl table
#: build/C/man2/socket.2:90
#, no-wrap
msgid "B<netlink>(7)\n"
msgstr "B<netlink>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:93
#, no-wrap
msgid "B<AF_X25>\n"
msgstr "B<AF_X25>\n"

#. type: tbl table
#: build/C/man2/socket.2:94
#, no-wrap
msgid "T}:ITU-T X.25 / ISO-8208 protocol:T{\n"
msgstr "T}:ITU-T X.25 / ISO-8208 プロトコル:T{\n"

#. type: tbl table
#: build/C/man2/socket.2:95
#, no-wrap
msgid "B<x25>(7)\n"
msgstr "B<x25>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:98
#, no-wrap
msgid "B<AF_AX25>\n"
msgstr "B<AF_AX25>\n"

#. type: tbl table
#: build/C/man2/socket.2:100
#, no-wrap
msgid "Amateur radio AX.25 protocol\n"
msgstr "アマチュア無線 AX.25 プロトコル\n"

#. type: tbl table
#: build/C/man2/socket.2:101
#, no-wrap
msgid "T}:\n"
msgstr "T}:\n"

#. type: tbl table
#: build/C/man2/socket.2:103
#, no-wrap
msgid "B<AF_ATMPVC>\n"
msgstr "B<AF_ATMPVC>\n"

#. type: tbl table
#: build/C/man2/socket.2:104
#, no-wrap
msgid "T}:Access to raw ATM PVCs:\n"
msgstr "T}:生の ATM PVC にアクセスする:\n"

#. type: tbl table
#: build/C/man2/socket.2:106
#, no-wrap
msgid "B<AF_APPLETALK>\n"
msgstr "B<AF_APPLETALK>\n"

#. type: tbl table
#: build/C/man2/socket.2:107
#, no-wrap
msgid "T}:Appletalk:T{\n"
msgstr "T}:アップルトーク:T{\n"

#. type: tbl table
#: build/C/man2/socket.2:108
#, no-wrap
msgid "B<ddp>(7)\n"
msgstr "B<ddp>(7)\n"

#. type: tbl table
#: build/C/man2/socket.2:111
#, no-wrap
msgid "B<AF_PACKET>\n"
msgstr "B<AF_PACKET>\n"

#. type: tbl table
#: build/C/man2/socket.2:113
#, no-wrap
msgid "Low level packet interface\n"
msgstr "低レベルのパケットインターフェース\n"

#. type: tbl table
#: build/C/man2/socket.2:115
#, no-wrap
msgid "B<packet>(7)\n"
msgstr "B<packet>(7)\n"

#. type: Plain text
#: build/C/man2/socket.2:124
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""
"ソケットは I<type> で指定される型を持ち、それは通信方式(semantics)を指定す"
"る。 定義されている型は現在以下の通り。"

#. type: TP
#: build/C/man2/socket.2:124
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr "B<SOCK_STREAM>"

#. type: Plain text
#: build/C/man2/socket.2:128
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""
"順序性と信頼性があり、双方向の、接続された バイト・ストリーム(byte stream)を"
"提供する。 帯域外(out-of-band)データ転送メカニズムもサポートされる。"

#. type: TP
#: build/C/man2/socket.2:128
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr "B<SOCK_DGRAM>"

#. type: Plain text
#: build/C/man2/socket.2:132
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr "データグラム(接続、信頼性無し、固定最大長メッセージ)  をサポートする。"

#. type: TP
#: build/C/man2/socket.2:132
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr "B<SOCK_SEQPACKET>"

#. type: Plain text
#: build/C/man2/socket.2:137
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""
"固定最大長のデータグラム転送パスに基づいた順序性、信頼性のある 双方向の接続に"
"基づいた通信を提供する。受け取り側ではそれぞれの入力 システム・コールでパケッ"
"ト全体を読み取ることが要求される。"

#. type: TP
#: build/C/man2/socket.2:137
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr "B<SOCK_RAW>"

#. type: Plain text
#: build/C/man2/socket.2:140
msgid "Provides raw network protocol access."
msgstr "生のネットワーク・プロトコルへのアクセスを提供する。"

#. type: TP
#: build/C/man2/socket.2:140
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr "B<SOCK_RDM>"

#. type: Plain text
#: build/C/man2/socket.2:143
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr "信頼性はあるが、順序は保証しないデータグラム層を提供する。"

#. type: TP
#: build/C/man2/socket.2:143
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr "B<SOCK_PACKET>"

#. type: Plain text
#: build/C/man2/socket.2:148
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""
"廃止されており新しいプログラムで使用してはいけない。 B<packet>(7)  を参照する"
"こと"

#. type: Plain text
#: build/C/man2/socket.2:154
msgid ""
"Some socket types may not be implemented by all protocol families; for "
"example, B<SOCK_SEQPACKET> is not implemented for B<AF_INET>."
msgstr ""
"ある種のソケット型が全てのプロトコル・ファミリで実装されているわけではない。 "
"例えば B<SOCK_SEQPACKET> は B<AF_INET> には実装されていない。"

#. type: Plain text
#: build/C/man2/socket.2:162
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""
"Linux 2.6.27 以降では、 I<type> 引数は二つ目の目的にも使用される。 ソケットの"
"型を指定するのに加えて、 以下の値のいくつかをビット単位の論理和 (OR) で指定す"
"ることで、 B<socket>()  の振舞いを変更することができる。"

#. type: Plain text
#: build/C/man2/socket.2:196
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""
"I<protocol> はソケットによって使用される固有のプロトコルを指定する。通常それ"
"ぞれの ソケットは、与えられたプロトコル・ファミリの種類ごとに一つのプロトコル"
"のみを サポートする。 その場合は I<protocol> に 0 を指定できる。 しかし、多く"
"のプロトコルが存在してもかまわない。 この場合にはこの方法により固有のプロトコ"
"ルを指定する必要がある。 使用されるプロトコル番号は通信の行なわれる``通信ドメ"
"イン''に 固有である; B<protocols>(5)  を参照すること。 プロトコル名をどうやっ"
"てプロトコル番号に対応させるかについては B<getprotoent>(3)  を参照すること。"

#. type: Plain text
#: build/C/man2/socket.2:226
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams, similar to "
"pipes.  They do not preserve record boundaries.  A stream socket must be in "
"a I<connected> state before any data may be sent or received on it.  A "
"connection to another socket is created with a B<connect>(2)  call.  Once "
"connected, data may be transferred using B<read>(2)  and B<write>(2)  calls "
"or some variant of the B<send>(2)  and B<recv>(2)  calls.  When a session "
"has been completed a B<close>(2)  may be performed.  Out-of-band data may "
"also be transmitted as described in B<send>(2)  and received as described in "
"B<recv>(2)."
msgstr ""
"B<SOCK_STREAM> 型のソケットはパイプのような全二重バイト・ストリームである。 "
"これらはレコード境界を保存しない。 ストリームは、ソケットがデータを送ったり受"
"けたりする前に I<接続された> 状態になってなければならない。他のソケットへの接"
"続は B<connect>(2)  コールによって行なわれる。一度接続したらデータは B<read>"
"(2)  と B<write>(2)  コールや B<send>(2)  と B<recv>(2)  コールの変種を使用し"
"て転送できる。 セッションが完了したら B<close>(2)  が行なわれる。帯域外データ"
"の転送も B<send>(2)  に記述されており、 受信も B<recv>(2)  に記述されている。"

#. type: Plain text
#: build/C/man2/socket.2:252
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""
"B<SOCK_STREAM> を実装した通信プロトコルはデータに損失や重複がないことを保証す"
"る。 もし相手のプロトコルがバッファー空間を持つ データの断片を適当な時間のう"
"ちに転送できなければ、 接続は断たれたとみなす。そのソケット B<SO_KEEPALIVE> "
"が有効になっている場合、プロトコル独自の方法で接続の相手側がまだ 有効であるか"
"をチェックする。 もしプロセスが、壊れたストリームでデータを送受信しようとした"
"場合には B<SIGPIPE> シグナルが送られる; これは通常のそのシグナルを扱っていな"
"いプロセスを 終了させる。 B<SOCK_SEQPACKET> ソケットは B<SOCK_STREAM> ソケッ"
"トと同じシステム・コールを使用する。 唯一の違いは B<read>(2)  コールが要求さ"
"れた量のデータのみを返し、到着したパケットの残りの部分を 捨ててしまうことであ"
"る。同様に入ってくるデータグラムの全てのメッセージ境界は 保存される。"

#. type: Plain text
#: build/C/man2/socket.2:262
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""
"B<SOCK_DGRAM> と B<SOCK_RAW> ソケットは B<sendto>(2)  コールで指定された相手"
"へデータグラムを送ることが許されている。 データグラムは一般に B<recvfrom>"
"(2)  で受けとり、 このコールは次のデータグラムを送信者のアドレスと一緒に返"
"す。"

#. type: Plain text
#: build/C/man2/socket.2:269
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""
"B<SOCK_PACKET> は古いソケット型で、生(raw)のパケットをデバイスドライバから 直"
"接受信するためのものである。 今は代わりに B<packet>(7)  を用いること。"

#. type: Plain text
#: build/C/man2/socket.2:292
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""
"B<fcntl>(2)  の B<F_SETOWN> 操作を使って、シグナル B<SIGURG> や B<SIGPIPE> を"
"受けとるプロセス・グループを指定できる。 B<SIGURG> シグナルは帯域外データが到"
"着した時に、 B<SIGPIPE> シグナルは B<SOCK_STREAM> 接続が予期せず切断された時"
"に送られる。 また、 B<F_SETOWN> 操作は、I/O や I/O イベントの非同期 "
"(asynchronous) 通知を B<SIGIO> を経由で受け取るプロセスやプロセス・グループを"
"設定するのにも使用できる。 B<F_SETOWN> を使用することは B<FIOSETOWN> または "
"B<SIOCSPGRP> の引数で B<ioctl>(2)  を使用することと等価である。"

#. type: Plain text
#: build/C/man2/socket.2:302
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using a ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in B<ip>"
"(7)."
msgstr ""
"ネットワークがプロトコル・モジュールにエラー状態を伝えた場合 (例えば、IP の "
"ICMP メッセージを使用して)には、ソケットの ペンディング・エラー・フラグが設定"
"される。次にこのソケットを操作した 時にペンディングされていたエラー・コードが"
"返される。プロトコルによっては エラーについてのより詳しい情報を受け取るために"
"ソケットごとのエラー・キューを 受け取ることが可能である。 B<ip>(7)  の "
"B<IP_RECVERR> を参照すること。"

#. type: Plain text
#: build/C/man2/socket.2:312
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options, "
"respectively."
msgstr ""
"ソケットの操作はソケット・レベル I<options> によって制御される。 これらのオプ"
"ションは I<E<lt>sys/socket.hE<gt>> に定義されている。 B<setsockopt>(2)  と "
"B<getsockopt>(2)  関数はそれぞれオプションの設定と取得を行なう。"

#. type: Plain text
#: build/C/man2/socket.2:317
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、新しいソケットのファイル・ディスクリプターを返す。 エラーが発生"
"した場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/socket.2:322
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr ""
"指定されたタイプまたはプロトコルのソケットを作成する許可が与えられていない。"

#. type: Plain text
#: build/C/man2/socket.2:325
msgid "The implementation does not support the specified address family."
msgstr "指定されたアドレスファミリーがサポートされていない。"

#. type: Plain text
#: build/C/man2/socket.2:328
msgid "Unknown protocol, or protocol family not available."
msgstr "知らないプロトコル、または利用できないプロトコル・ファミリである。"

#.  Since Linux 2.6.27
#. type: Plain text
#: build/C/man2/socket.2:333
msgid "Invalid flags in I<type>."
msgstr "I<type> に無効なフラグが指定されている。"

#. type: Plain text
#: build/C/man2/socket.2:336
msgid "Process file table overflow."
msgstr "プロセスのファイルテーブルが溢れている。"

#. type: TP
#: build/C/man2/socket.2:339
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr "B<ENOBUFS> または B<ENOMEM>"

#. type: Plain text
#: build/C/man2/socket.2:344
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""
"十分なメモリがない。十分な資源が解放されるまではソケットを 作成することはでき"
"ない。"

#. type: TP
#: build/C/man2/socket.2:344 build/C/man2/socketpair.2:90
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr "B<EPROTONOSUPPORT>"

#. type: Plain text
#: build/C/man2/socket.2:348
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr ""
"このドメインでは指定されたプロトコルまたはプロトコル・タイプが サポートされて"
"いない。"

#. type: Plain text
#: build/C/man2/socket.2:350
msgid "Other errors may be generated by the underlying protocol modules."
msgstr "下位のプロトコル・モジュールから他のエラーが生成されるかもしれない。"

#. type: Plain text
#: build/C/man2/socket.2:352
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/socket.2:358
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr "フラグ B<SOCK_NONBLOCK>, B<SOCK_CLOEXEC> は Linux 固有である。"

#. type: Plain text
#: build/C/man2/socket.2:364
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System V "
"variants)."
msgstr ""
"B<socket>()  は 4.2BSD で登場した。一般に、(System V の変種を含めて)  BSD の"
"ソケット層の互換性をサポートしている BSD 以外のシステムへの、 または、BSD 以"
"外のシステムからの移植ができる。"

#. type: Plain text
#: build/C/man2/socket.2:383
#, fuzzy
#| msgid ""
#| "The manifest constants used under 4.x BSD for protocol families are "
#| "B<PF_UNIX>, B<PF_INET>, etc., while B<AF_UNIX> etc. are used for address "
#| "families.  However, already the BSD man page promises: \"The protocol "
#| "family generally is the same as the address family\", and subsequent "
#| "standards use AF_* everywhere."
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<PF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""
"4.x BSD において定数を使用する場合、プロトコル・ファミリーには B<PF_UNIX>, "
"B<PF_INET> 等を使用している。一方でアドレス・ファミリーには B<AF_UNIX> 等が使"
"用されている。しかしながら BSD のマニュアルでは 「一般にプロトコル・ファミ"
"リーはアドレス・ファミリーと同じものである。」 と保証している。それでそれ以外"
"の規格では全ての場所で AF_* が使用されている。"

#. type: Plain text
#: build/C/man2/socket.2:388
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr "B<socket>()  の利用例が B<getaddrinfo>(3)  に記載されている。"

#. type: Plain text
#: build/C/man2/socket.2:411
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), "
"B<write>(2), B<getprotoent>(3), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>"
"(7), B<unix>(7)"
msgstr ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), "
"B<write>(2), B<getprotoent>(3), B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>"
"(7), B<unix>(7)"

#. type: Plain text
#: build/C/man2/socket.2:415
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq is "
"reprinted in I<UNIX Programmer's Supplementary Documents Volume 1.>"
msgstr ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq は "
"I<UNIX Programmer's Supplementary Documents Volume 1> として再版された。"

#. type: Plain text
#: build/C/man2/socket.2:419
msgid ""
"\\(lqBSD Interprocess Communication Tutorial\\(rq is reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""
"\\(lqBSD Interprocess Communication Tutorial\\(rq は I<UNIX Programmer's "
"Supplementary Documents Volume 1> として再版された。"

#. type: Plain text
#: build/C/man7/socket.7:29
msgid "socket - Linux socket interface"
msgstr "socket - Linux のソケットインターフェース"

#. type: Plain text
#: build/C/man7/socket.7:33
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"

#. type: Plain text
#: build/C/man7/socket.7:52
msgid ""
"This manual page describes the Linux networking socket layer user "
"interface.  The BSD compatible sockets are the uniform interface between the "
"user process and the network protocol stacks in the kernel.  The protocol "
"modules are grouped into I<protocol families> like B<AF_INET>, B<AF_IPX>, "
"B<AF_PACKET> and I<socket types> like B<SOCK_STREAM> or B<SOCK_DGRAM>.  See "
"B<socket>(2)  for more information on families and types."
msgstr ""
"このマニュアルページは Linux ネットワークのソケット層に対する ユーザインター"
"フェースを記述するものである。 BSD 互換ソケットは、ユーザプロセスとカーネル内"
"部の ネットワークプロトコルスタック群との間に、 統一的なインターフェースを提"
"供するものである。 プロトコルモジュールは I<プロトコルファミリー (protocol "
"familiy)> (例： B<AF_INET>, B<AF_IPX>, B<AF_PACKET>)  と I<ソケットタイプ "
"(socket types)> (例： B<SOCK_STREAM>, B<SOCK_DGRAM>)  に分類できる。 これらに"
"関するより詳しい情報は B<socket>(2)  を参照のこと。"

#. type: SS
#: build/C/man7/socket.7:52
#, no-wrap
msgid "Socket Layer Functions"
msgstr "ソケット層の関数群"

#. type: Plain text
#: build/C/man7/socket.7:56
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr ""
"これらの関数はユーザプロセスがパケットを送受信したり、その他のソケット操作を "
"行ったりするために用いられる。詳細はそれぞれのマニュアルページを 見てほしい。"

#. type: Plain text
#: build/C/man7/socket.7:72
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote "
"socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets (only "
"implemented for a few local families like B<AF_UNIX>)"
msgstr ""
"B<socket>(2)  はソケットを生成する。 B<connect>(2)  はソケットをリモートのソ"
"ケットアドレスに接続する。 B<bind>(2)  はソケットをローカルのソケットアドレス"
"にバインドする。 B<listen>(2)  はソケットに新しい接続が来たら受信するように伝"
"え、 B<accept>(2)  は外部からやってきた接続に対して新しいソケットを得るために"
"用いられる。 B<socketpair>(2)  は互いに接続された二つの名前無しソケット "
"(anonymous socket) を返す (B<AF_UNIX> のような、いくつかのローカルなファミ"
"リーでしか実装されていない)。"

#. type: Plain text
#: build/C/man7/socket.7:94
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), B<writev>"
"(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to read and "
"write data."
msgstr ""
"B<send>(2), B<sendto>(2), B<sendmsg>(2)  はソケットを通してデータを送信し、 "
"B<recv>(2)  B<recvfrom>(2), B<recvmsg>(2)  はソケットからデータを受信する。 "
"B<poll>(2)  と B<select>(2)  はデータの到着を待ったり、データ送信の準備ができ"
"るまで待ったりする。 さらに、 B<write>(2), B<writev>(2), B<sendfile>(2), "
"B<read>(2), B<readv>(2)  のような標準的な I/O 操作もデータの読み書きに用いる"
"ことができる。"

#. type: Plain text
#: build/C/man7/socket.7:105
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr ""
"B<getsockbyname>(2)  はローカルのソケットアドレスを返し、 B<getpeername>(2)  "
"はリモートのソケットアドレスを返す。 B<getsockopt>(2)  と B<setsockopt>(2)  "
"はソケット層のオプションやプロトコルオプションの取得・設定に用いられる。 他の"
"いくつかのオプションの取得・設定には B<ioctl>(2)  を使うことができる。"

#. type: Plain text
#: build/C/man7/socket.7:110
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr ""
"B<close>(2)  はソケットをクローズする。 B<shutdown>(2)  は全二重なソケット接"
"続を部分的にクローズする。"

#. type: Plain text
#: build/C/man7/socket.7:116
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is "
"not supported on sockets."
msgstr ""
"シーク動作や、 0 以外の位置に対する B<pread>(2)  や B<pwrite>(2)  はソケット"
"ではサポートされていない。"

#. type: Plain text
#: build/C/man7/socket.7:133
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK> "
"flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr ""
"非ブロッキングな I/O をソケットで行うことは可能で、 B<fcntl>(2)  を使ってソ"
"ケットのファイルディスクリプタに B<O_NONBLOCK> フラグをセットすれば良い。 こ"
"うするとブロックされる操作は、 (通常)  B<EAGAIN> エラーで戻ることになる (後で"
"処理が再試行されることが期待されている)。 B<connect>(2)  では B<EINPROGRESS> "
"エラーが返される。 この場合、ユーザはさまざまなイベントを B<poll>(2)  や "
"B<select>(2)  を使って待つことができる。"

#. type: tbl table
#: build/C/man7/socket.7:137
#, no-wrap
msgid "I/O events\n"
msgstr "I/O イベント\n"

#. type: tbl table
#: build/C/man7/socket.7:138
#, no-wrap
msgid "Event:Poll flag:Occurrence\n"
msgstr "イベント:poll フラグ:内容\n"

#. type: tbl table
#: build/C/man7/socket.7:139 build/C/man7/socket.7:142
#, no-wrap
msgid "Read:POLLIN:T{\n"
msgstr "Read:POLLIN:T{\n"

#. type: tbl table
#: build/C/man7/socket.7:140
#, no-wrap
msgid "New data arrived.\n"
msgstr "新しいデータが到着した。\n"

#. type: tbl table
#: build/C/man7/socket.7:143
#, no-wrap
msgid "A connection setup has been completed\n"
msgstr "(接続志向のソケットで)\n"

#. type: tbl table
#: build/C/man7/socket.7:144
#, no-wrap
msgid "(for connection-oriented sockets)\n"
msgstr "接続の設定が終了した。\n"

#. type: tbl table
#: build/C/man7/socket.7:146 build/C/man7/socket.7:149
#, no-wrap
msgid "Read:POLLHUP:T{\n"
msgstr "Read:POLLHUP:T{\n"

#. type: tbl table
#: build/C/man7/socket.7:147
#, no-wrap
msgid "A disconnection request has been initiated by the other end.\n"
msgstr "接続先で切断要求が生成された。\n"

#. type: tbl table
#: build/C/man7/socket.7:150
#, no-wrap
msgid "A connection is broken (only for connection-oriented protocols).\n"
msgstr "接続が壊れた (接続志向のプロトコルのみ)。\n"

#. type: tbl table
#: build/C/man7/socket.7:151
#, no-wrap
msgid "When the socket is written\n"
msgstr "この場合、ソケットに書き込みが行われると\n"

#. type: tbl table
#: build/C/man7/socket.7:152
#, no-wrap
msgid "B<SIGPIPE>\n"
msgstr "B<SIGPIPE>\n"

#. type: tbl table
#: build/C/man7/socket.7:153
#, no-wrap
msgid "is also sent.\n"
msgstr "も送信される。\n"

#. type: tbl table
#: build/C/man7/socket.7:155
#, no-wrap
msgid "Write:POLLOUT:T{\n"
msgstr "Write:POLLOUT:T{\n"

#. type: tbl table
#: build/C/man7/socket.7:156
#, no-wrap
msgid "Socket has enough send buffer space for writing new data.\n"
msgstr "ソケットには新しいデータを書き込むのに充分なバッファ領域がある。\n"

#. type: tbl table
#: build/C/man7/socket.7:158
#, no-wrap
msgid "Read/Write:T{\n"
msgstr "Read/Write:T{\n"

#. type: tbl table
#: build/C/man7/socket.7:159
#, no-wrap
msgid "POLLIN|\n"
msgstr "POLLIN|\n"

#. type: tbl table
#: build/C/man7/socket.7:160
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man7/socket.7:161
#, no-wrap
msgid "POLLOUT\n"
msgstr "POLLOUT\n"

#. type: tbl table
#: build/C/man7/socket.7:163
#, no-wrap
msgid "An outgoing\n"
msgstr "外部向けの\n"

#. type: tbl table
#: build/C/man7/socket.7:164
#, no-wrap
msgid "B<connect>(2)\n"
msgstr "B<connect>(2)\n"

#. type: tbl table
#: build/C/man7/socket.7:165
#, no-wrap
msgid "finished.\n"
msgstr "が終了した。\n"

#. type: tbl table
#: build/C/man7/socket.7:167
#, no-wrap
msgid "Read/Write:POLLERR:An asynchronous error occurred.\n"
msgstr "Read/Write:POLLERR:非同期的 (asynchronous) なエラーが起こった。\n"

#. type: tbl table
#: build/C/man7/socket.7:168
#, no-wrap
msgid "Read/Write:POLLHUP:The other end has shut down one direction.\n"
msgstr "Read/Write:POLLHUP:接続先が片方向を切断した。\n"

#. type: tbl table
#: build/C/man7/socket.7:169
#, no-wrap
msgid "Exception:POLLPRI:T{\n"
msgstr "Exception:POLLPRI:T{\n"

#. type: tbl table
#: build/C/man7/socket.7:170
#, no-wrap
msgid "Urgent data arrived.\n"
msgstr "緊急データ (urgent data) が到着した。この場合は\n"

#. type: tbl table
#: build/C/man7/socket.7:171
#, no-wrap
msgid "B<SIGURG>\n"
msgstr "B<SIGURG>\n"

#. type: tbl table
#: build/C/man7/socket.7:172
#, no-wrap
msgid "is sent then.\n"
msgstr "が送信される。\n"

#. type: Plain text
#: build/C/man7/socket.7:202
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC> "
"flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr ""
"B<poll>(2)  や B<select>(2)  を使う代わりに、カーネルからアプリケーションに "
"イベントを通知させるのに B<SIGIO> シグナルを使う方法もある。 この方法を使うに"
"は、 B<fcntl>(2)  を用いてソケットのファイルディスクリプタに B<O_ASYNC> フラ"
"グをセットし、 B<SIGIO> に対する有効なシグナルハンドラを B<sigaction>(2)  に"
"よって設定しておく必要がある。 後述の I<シグナル> に関する議論も参考にするこ"
"と。"

#. type: SS
#: build/C/man7/socket.7:202
#, no-wrap
msgid "Socket Options"
msgstr "ソケットオプション"

#.  FIXME
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: build/C/man7/socket.7:216
msgid ""
"These socket options can be set by using B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for all sockets:"
msgstr ""
"これらのソケットオプションは、 B<setsockopt>(2)  を用いれば設定でき、 "
"B<getsockopt>(2)  を用いれば取得できる。 但し、どのソケットの場合も ソケット"
"レベルには B<SOL_SOCKET> を指定すること。"

#. type: TP
#: build/C/man7/socket.7:216
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr "B<SO_ACCEPTCONN>"

#. type: Plain text
#: build/C/man7/socket.7:224
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr ""
"このソケットが B<listen>(2)  によって接続待ち受け状態に設定されているかどうか"
"を示す値を返す。 値 0 は listen 状態のソケットでないことを、 値 1 は listen "
"状態のソケットであることを示す。このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:224
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr "B<SO_BINDTODEVICE>"

#. type: Plain text
#: build/C/man7/socket.7:243
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in "
"the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this only works for some socket types, particularly B<AF_INET> "
"sockets.  It is not supported for packet sockets (use normal B<bind>(2)  "
"there)."
msgstr ""
"このソケットを、引き数で渡したインターフェース名で指定される\n"
"(\\(lqeth0\\(rq のような) 特定のデバイスにバインドする。\n"
"名前が空文字列だったり、オプションの長さ (optlen) が 0 の場合には、\n"
"ソケットのバインドが削除される。渡すオプションは、インターフェース名が\n"
"入ったヌル文字で終端された可変長の文字列である。\n"
"文字列の最大のサイズは B<IFNAMSIX> である。\n"
"ソケットがインターフェースにバインドされると、その特定のインターフェース\n"
"から受信されたパケットだけを処理する。\n"
"このオプションはいくつかのソケットタイプ、\n"
"特に B<AF_INET> に対してのみ動作する点に注意すること。\n"
"パケットソケットではサポートされていない (通常の B<bind>(2) を使うこと)。"

#. type: TP
#: build/C/man7/socket.7:243
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr "B<SO_BROADCAST>"

#. type: Plain text
#: build/C/man7/socket.7:249
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on stream-"
"oriented sockets."
msgstr ""
"ブロードキャストフラグを設定・取得する。有効になっていると、データグラ\n"
"ムソケットはブロードキャストアドレスにパケットを送信できるようになる。\n"
"ストリーム指向のソケットには何の効果もない。"

#. type: TP
#: build/C/man7/socket.7:249
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr "B<SO_BSDCOMPAT>"

#. type: Plain text
#: build/C/man7/socket.7:261
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random "
"header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr ""
"BSD のバグに対して互換性を取るための機能を有効にする。 この機能は Linux 2.0 "
"と 2.2 の UDP プロトコルモジュールで使用されている。 有効になっていると、 "
"UDP ソケットで受信された ICMP エラーは ユーザプログラムに渡されない。 これ以"
"降のバージョンのカーネルでは、このオプションのサポートは 段階的に廃止されてき"
"た。 Linux 2.4 ではこのオプションは黙って無視され、 Linux 2.6 ではプログラム"
"がこのオプションを使用すると (printk() を使って)  カーネルの警告メッセージが"
"出力される。 Linux 2.0 では、このオプションを指定すると、 raw ソケットにおい"
"ても BSD のバグ (ランダムヘッダ変更、 ブロードキャストフラグのスキップ)  に対"
"する互換機能が有効になっていた。 しかし、こちらは Linux 2.2 で削除された。"

#. type: TP
#: build/C/man7/socket.7:261
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr "B<SO_DEBUG>"

#. type: Plain text
#: build/C/man7/socket.7:267
msgid ""
"Enable socket debugging.  Only allowed for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr ""
"ソケットのデバッグ機能を有効にする。 B<CAP_NET_ADMIN> 権限を持つプロセスか、"
"実効ユーザ ID が 0 のプロセスでしか 利用できない。"

#. type: TP
#: build/C/man7/socket.7:267
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr "B<SO_DOMAIN> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man7/socket.7:275
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr ""
"ソケットドメインを整数で取得する。 B<AF_INET6> のような値が返される。\n"
"詳細は B<socket>(2) を参照。このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:275
#, no-wrap
msgid "B<SO_ERROR>"
msgstr "B<SO_ERROR>"

#. type: Plain text
#: build/C/man7/socket.7:280
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr ""
"保留になっていたソケットエラーを取得してクリアする。\n"
"このソケットオプションは読み込み専用である。整数値をとる。"

#. type: TP
#: build/C/man7/socket.7:280
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr "B<SO_DONTROUTE>"

#. type: Plain text
#: build/C/man7/socket.7:289
msgid ""
"Don't send via a gateway, only send to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr ""
"ゲートウェイを経由せず、直接接続されているホストに送信する。 B<send>(2)  操作"
"で B<MSG_DONTROUTE> フラグをセットした場合も同じ効果が得られる。 ブール整数の"
"フラグを取る。"

#. type: TP
#: build/C/man7/socket.7:289
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr "B<SO_KEEPALIVE>"

#. type: Plain text
#: build/C/man7/socket.7:293
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr ""
"接続志向のソケットに対する keep-alive メッセージの送信を有効にする。 ブール値"
"の整数フラグをとる。"

#. type: TP
#: build/C/man7/socket.7:293
#, no-wrap
msgid "B<SO_LINGER>"
msgstr "B<SO_LINGER>"

#. type: Plain text
#: build/C/man7/socket.7:301
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> structure."
msgstr ""
"B<SO_LINGER> オプションを取得・設定する。引き数には I<linger> 構造体を取る。"

#. type: Plain text
#: build/C/man7/socket.7:308
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"

#. type: Plain text
#: build/C/man7/socket.7:322
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr ""
"有効になっていると、 B<close>(2)  や B<shutdown>(2)  は、そのソケットにキュー"
"イングされたメッセージがすべて送信完了するか、 linger (居残り) タイムアウトに"
"なるまで返らない。無効になっていると、 これらのコールはただちに戻り、クローズ"
"動作はバックグラウンドで行われる。 ソケットのクローズを B<exit>(2)  の一部と"
"して行った場合には、残っているソケットの クローズ動作は必ずバックグラウンドに"
"送られる。"

#. type: TP
#: build/C/man7/socket.7:322
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr "B<SO_OOBINLINE>"

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#. type: Plain text
#: build/C/man7/socket.7:331
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise out-of-band data is only passed when the "
"B<MSG_OOB> flag is set during receiving."
msgstr ""
"このオプションを有効にすると、帯域外データ (out-of-band data) は 受信データス"
"トリーム中に置かれる。有効にしなければ、 帯域外データは受信時に B<MSG_OOB> フ"
"ラグがセットされている場合に限って渡される。"

#. type: TP
#: build/C/man7/socket.7:331
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr "B<SO_PASSCRED>"

#.  FIXME Document SO_PASSSEC, added in 2.6.18; there is some info
#.  in the 2.6.18 ChangeLog
#. type: Plain text
#: build/C/man7/socket.7:340
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr ""
"B<SCM_CREDENTIALS> 制御メッセージの受信を有効/無効にする。詳細は B<unix>(7)  "
"を参照のこと。"

#. type: TP
#: build/C/man7/socket.7:340
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr "B<SO_PEERCRED>"

#. type: Plain text
#: build/C/man7/socket.7:360
msgid ""
"Return the credentials of the foreign process connected to this socket.  "
"This is only possible for connected B<AF_UNIX> stream sockets and B<AF_UNIX> "
"stream and datagram socket pairs created using B<socketpair>(2); see B<unix>"
"(7).  The returned credentials are those that were in effect at the time of "
"the call to B<connect>(2)  or B<socketpair>(2).  Argument is a I<ucred> "
"structure.  This socket option is read-only."
msgstr ""
"このソケットに接続してきた外部プロセスの信任状 (credential) を返す。\n"
"このソケットオプションが利用できるのは、接続された B<AF_UNIX> ストリームソ"
"ケット間、\n"
"および B<socketpair>(2) を使って作成された B<AF_UNIX> のストリームソケット"
"と\n"
"データグラムソケットのペアだけである。\n"
"B<unix>(7)  を参照のこと。\n"
"B<connect>(2) や B<socketpair>(2) が呼ばれた時に有効であった信任状が返され"
"る。\n"
"引き数は I<ucred> 構造体である。\n"
"このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:360
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr "B<SO_PRIORITY>"

#. type: Plain text
#: build/C/man7/socket.7:373
msgid ""
"Set the protocol-defined priority for all packets to be sent on this "
"socket.  Linux uses this value to order the networking queues: packets with "
"a higher priority may be processed first depending on the selected device "
"queueing discipline.  For B<ip>(7), this also sets the IP type-of-service "
"(TOS) field for outgoing packets.  Setting a priority outside the range 0 to "
"6 requires the B<CAP_NET_ADMIN> capability."
msgstr ""
"プロトコルで定義された優先度を、このソケットから 送信される全てのパケットに"
"セットする。 Linux はネットワークキュー内部の 整列にこの値を用いる。高い優先"
"度を持っているパケットは先に処理される。 ただしそのデバイスのキュー処理のやり"
"方に依存する。 B<ip>(7)  では、外向けパケットの IP type-of-service (TOS) "
"フィールドにもこの値が設定される。 0 から 6 以外の優先度をセットするには "
"B<CAP_NET_ADMIN> ケーパビリティが必要である。"

#. type: TP
#: build/C/man7/socket.7:373
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr "B<SO_PROTOCOL> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man7/socket.7:381
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is read-"
"only."
msgstr ""
"ソケットのプロトコルを整数で取得する。 B<IPPROTO_SCTP> のような値が返され"
"る。\n"
"詳細は B<socket>(2) を参照。このソケットオプションは読み込み専用である。"

#. type: TP
#: build/C/man7/socket.7:381
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr "B<SO_RCVBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#. type: Plain text
#: build/C/man7/socket.7:396
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and "
"the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr ""
"ソケットの受信バッファの最大サイズを設定・取得する (バイト単位)。 "
"B<setsockopt>(2)  を使って値が設定されたときに (管理オーバヘッド用の領域を確"
"保するために)  カーネルはこの値を 2倍し、 B<getsockopt>(2)  はこの 2倍された"
"値を返す。 デフォルトの値は I</proc/sys/net/core/rmem_default> ファイルで設定"
"され、許容される最大の値は I</proc/sys/net/core/rmem_max> ファイルで設定され"
"る。 このオプションの最小値は (2倍した値で) 256 である。"

#. type: TP
#: build/C/man7/socket.7:396
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_RCVBUFFORCE> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man7/socket.7:405
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr ""
"このソケットオプションを使うと、特権プロセス (B<CAP_NET_ADMIN> を持つプロセ"
"ス) は B<SO_RCVBUF> と同じことを実行できる。 ただし、上限 I<rmem_max> を上書"
"きすることができる。"

#. type: TP
#: build/C/man7/socket.7:405
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr "B<SO_RCVLOWAT> と B<SO_SNDLOWAT>"

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=111049368106984&w=2
#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#. type: Plain text
#: build/C/man7/socket.7:434
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4.  "
"The B<select>(2)  and B<poll>(2)  system calls currently do not respect the "
"B<SO_RCVLOWAT> setting on Linux, and mark a socket readable when even a "
"single byte of data is available.  A subsequent read from the socket will "
"block until B<SO_RCVLOWAT> bytes are available."
msgstr ""
"バッファ中に溜めることのできるデータの最小値を指定する。 このサイズを越える"
"と、ソケット層はそのデータをプロトコルに渡し (B<SO_SNDLOWAT>)、 受信時には"
"ユーザに渡す (B<SO_RCVLOWAT>)。 これら二つの値は 1 に初期化される。 "
"B<SO_SNDLOWAT> は Linux では変更できない (B<setsockopt>(2)  は "
"B<ENOPROTOOPT> エラーで失敗する)。 B<SO_RCVLOWAT> は Linux 2.4 以降でのみ変更"
"可能である。 現状、Linux ではシステムコール B<select>(2)  と B<poll>(2)  は "
"B<SO_RCVLOWAT> の設定を考慮に入れずに動作し、 データが1バイト利用可能になった"
"だけでも、 ソケットは読み出し可能とのマークをつける。 一方、それに続けて行う"
"ソケットからの read は B<SO_RCVLOWAT> バイトのデータが利用可能になるまで停止"
"してしまう。"

#. type: TP
#: build/C/man7/socket.7:434
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr "B<SO_RCVTIMEO> と B<SO_SNDTIMEO>"

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: build/C/man7/socket.7:465
#, fuzzy
#| msgid ""
#| "Specify the receiving or sending timeouts until reporting an error.  The "
#| "argument is a I<struct timeval>.  If an input or output function blocks "
#| "for this period of time, and data has been sent or received, the return "
#| "value of that function will be the amount of data transferred; if no data "
#| "has been transferred and the timeout has been reached then -1 is returned "
#| "with I<errno> set to B<EAGAIN> or B<EWOULDBLOCK> just as if the socket "
#| "was specified to be nonblocking.  If the timeout is set to zero (the "
#| "default)  then the operation will never timeout.  Timeouts only have "
#| "effect for system calls that perform socket I/O (e.g., B<read>(2), "
#| "B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); timeouts have no effect for "
#| "B<select>(2), B<poll>(2), B<epoll_wait>(2), etc."
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of "
"that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK> just as if the socket was "
"specified to be nonblocking.  If the timeout is set to zero (the default)  "
"then the operation will never timeout.  Timeouts only have effect for system "
"calls that perform socket I/O (e.g., B<read>(2), B<recvmsg>(2), B<send>(2), "
"B<sendmsg>(2)); timeouts have no effect for B<select>(2), B<poll>(2), "
"B<epoll_wait>(2), and so on."
msgstr ""
"送信・受信のタイムアウトを指定する。これを越えるとエラーを報告する。 引き数"
"は I<struct timeval> である。 入出力関数がタイムアウト時間の間ブロックされ、"
"かつデータの送信または 受信が行われていた場合は、転送されたデータ量が関数の返"
"り値となる。 何もデータが転送されずにタイムアウトに達した場合は、 -1 を返"
"し、 I<errno> に B<EAGAIN> か B<EWOULDBLOCK> を設定され、 あたかもソケットに"
"非ブロッキングが指定されたように見える。 タイムアウト値に (デフォルト値であ"
"る) 0 に設定すると、 操作は決してタイムアウトしなくなる。 タイムアウトが影響"
"を及ぼすのは、 ソケット I/O を実行するシステムコールだけ (例えば B<read>(2), "
"B<recvmsg>(2), B<send>(2), B<sendmsg>(2))  である。 B<select>(2), B<poll>"
"(2), B<epoll_wait>(2)  などにはタイムアウトは影響を及ぼさない。"

#. type: TP
#: build/C/man7/socket.7:465
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr "B<SO_REUSEADDR>"

#. type: Plain text
#: build/C/man7/socket.7:480
msgid ""
"Indicates that the rules used in validating addresses supplied in a B<bind>"
"(2)  call should allow reuse of local addresses.  For B<AF_INET> sockets "
"this means that a socket may bind, except when there is an active listening "
"socket bound to the address.  When the listening socket is bound to "
"B<INADDR_ANY> with a specific port then it is not possible to bind to this "
"port for any local address.  Argument is an integer boolean flag."
msgstr ""
"B<bind>(2)  コールに与えられたアドレスが正しいかを判断するルールで、 ローカル"
"アドレスの再利用を可能にする。 つまり B<AF_INET> ソケットなら、そのアドレスに"
"バインドされたアクティブな listen 状態のソケットが存在しない限り、バインドが"
"行える。 listen 状態のソケットがアドレス B<INADDR_ANY> で特定のポートにバイン"
"ドされている場合には、 このポートに対しては、どんなローカルアドレスでもバイン"
"ドできない。 引き数はブール整数のフラグである。"

#. type: TP
#: build/C/man7/socket.7:480
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr "B<SO_SNDBUF>"

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#. type: Plain text
#: build/C/man7/socket.7:495
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> "
"file.  The minimum (doubled) value for this option is 2048."
msgstr ""
"ソケットの送信バッファの最大サイズを設定・取得する (バイト単位)。 "
"B<setsockopt>(2)  を使って値が設定されたときに (管理オーバヘッド用の領域を確"
"保するために)  カーネルはこの値を 2倍し、 B<getsockopt>(2)  はこの 2倍された"
"値を返す。 デフォルトの値は I</proc/sys/net/core/wmem_default> ファイルで設定"
"され、許容される最大の値は I</proc/sys/net/core/wmem_max> ファイルで設定され"
"る。 このオプションの最小値は (2倍した値で) 2048 である。"

#. type: TP
#: build/C/man7/socket.7:495
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr "B<SO_SNDBUFFORCE> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man7/socket.7:504
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr ""
"このソケットオプションを使うと、特権プロセス (B<CAP_NET_ADMIN> を持つプロセ"
"ス) は B<SO_SNDBUF> と同じことを実行できる。 ただし、上限 I<wmem_max> を上書"
"きすることができる。"

#. type: TP
#: build/C/man7/socket.7:504
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr "B<SO_TIMESTAMP>"

#. type: Plain text
#: build/C/man7/socket.7:520
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The "
"timestamp control message is sent with level B<SOL_SOCKET> and the "
"I<cmsg_data> field is a I<struct timeval> indicating the reception time of "
"the last packet passed to the user in this call.  See B<cmsg>(3)  for "
"details on control messages."
msgstr ""
"B<SO_TIMESTAMP> 制御メッセージの受信を有効/無効にする。 タイムスタンプ制御"
"メッセージはレベル B<SOL_SOCKET> で送信され、 I<cmsg_data> フィールドはこのシ"
"ステムコールでユーザに渡した 最後のパケットの受信時刻を示す I<struct "
"timeval> である。 制御メッセージの詳細については B<cmsg>(3)  を参照。"

#. type: TP
#: build/C/man7/socket.7:520
#, no-wrap
msgid "B<SO_TYPE>"
msgstr "B<SO_TYPE>"

#. type: Plain text
#: build/C/man7/socket.7:525
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr ""
"ソケットのタイプを整数で取得する (例: B<SOCK_STREAM>)。\n"
"このソケットオプションは読み出し専用である。"

#. type: SS
#: build/C/man7/socket.7:525
#, no-wrap
msgid "Signals"
msgstr "シグナル"

#. type: Plain text
#: build/C/man7/socket.7:536
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr ""
"(ローカルもしくはリモート側で) 切断された 接続指向 (connection-oriented) のソ"
"ケットに対して 書き込みを行うと、その書き込みを行ったプロセスに B<SIGPIPE> が"
"送られ、 B<EPIPE> が返される。 write 呼び出しに B<MSG_NOSIGNAL> フラグを指定"
"していた場合はシグナルは送られない。"

#. type: Plain text
#: build/C/man7/socket.7:561
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> B<ioctl>"
"(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to use "
"B<poll>(2)  or B<select>(2)  in the signal handler to find out which socket "
"the event occurred on.  An alternative (in Linux 2.2) is to set a real-time "
"signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real time "
"signal will be called with the file descriptor in the I<si_fd> field of its "
"I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr ""
"B<FIOSETOWN> B<fcntl>(2)  や B<SIOCSPGRP> B<ioctl>(2)  をプロセスまたはプロセ"
"スグループに指定しておくと、 I/O イベントが起きたときに B<SIGIO> が送られ"
"る。 B<poll>(2)  や B<select>(2)  をシグナルハンドラ内で用いれば、どのソケッ"
"トでイベントが起こったかを 知ることができる。 (Linux 2.2 における) 別の方法と"
"しては、 B<F_SETSIG> B<fcntl>(2)  を用いてリアルタイムシグナルを設定するやり"
"方もある。 リアルタイムシグナルのハンドラは、 I<siginfo_t> の I<si_fd> フィー"
"ルドにファイルディスクリプタが入った状態で呼び出される。 詳細は B<fcntl>(2)  "
"を参照のこと。"

#.  .SS Ancillary Messages
#. type: Plain text
#: build/C/man7/socket.7:569
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared "
"when the process reacts to the signal.  If this happens, the process should "
"wait again because Linux will resend the signal later."
msgstr ""
"状況によっては (例えば複数のプロセスが一つのソケットにアクセスしているな"
"ど)、 B<SIGIO> の原因となった状態は、プロセスがそのシグナルへの対応を行ったと"
"きには 消えてしまっているかもしれない。 この場合は、プロセスは再び待つように"
"すべきである。 Linux は同じシグナルを後で再送するからである。"

#. type: SS
#: build/C/man7/socket.7:569
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インタフェース"

#. type: Plain text
#: build/C/man7/socket.7:573
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr ""
"core のソケットのネットワーキングパラメータには、 I</proc/sys/net/core/> ディ"
"レクトリ内のファイルを通してアクセスできる。"

#. type: TP
#: build/C/man7/socket.7:573
#, no-wrap
msgid "I<rmem_default>"
msgstr "I<rmem_default>"

#. type: Plain text
#: build/C/man7/socket.7:576
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr "ソケットの受信バッファサイズのデフォルト値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:576
#, no-wrap
msgid "I<rmem_max>"
msgstr "I<rmem_max>"

#. type: Plain text
#: build/C/man7/socket.7:582
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr ""
"B<SO_RCVBUF> ソケットオプションを用いてユーザが設定できる ソケットの受信バッ"
"ファサイズの最大値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:582
#, no-wrap
msgid "I<wmem_default>"
msgstr "I<wmem_default>"

#. type: Plain text
#: build/C/man7/socket.7:585
msgid "contains the default setting in bytes of the socket send buffer."
msgstr "ソケットの送信バッファサイズのデフォルト値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:585
#, no-wrap
msgid "I<wmem_max>"
msgstr "I<wmem_max>"

#. type: Plain text
#: build/C/man7/socket.7:591
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr ""
"B<SO_SNDBUF> ソケットオプションを用いてユーザが設定できる ソケットの送信バッ"
"ファサイズの最大値 (バイト単位)。"

#. type: TP
#: build/C/man7/socket.7:591
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr "I<message_cost> と I<message_burst>"

#. type: Plain text
#: build/C/man7/socket.7:595
msgid ""
"configure the token bucket filter used to load limit warning messages caused "
"by external network events."
msgstr ""
"トークン・バケット・フィルターを設定する。 これは外部のネットワークイベントに"
"よって引き起こされた 負荷限界の警告メッセージに用いられる。"

#. type: TP
#: build/C/man7/socket.7:595
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr "I<netdev_max_backlog>"

#. type: Plain text
#: build/C/man7/socket.7:598
msgid "Maximum number of packets in the global input queue."
msgstr "グローバルな入力キューにおける最大のパケット数。"

#. type: TP
#: build/C/man7/socket.7:598
#, no-wrap
msgid "I<optmem_max>"
msgstr "I<optmem_max>"

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: build/C/man7/socket.7:603
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr ""
"ソケットあたりの、補助データ (ancillary data) とユーザ制御データ (iovecs のよ"
"うなもの) との和の最大長。"

#. type: SS
#: build/C/man7/socket.7:603
#, no-wrap
msgid "Ioctls"
msgstr "ioctl"

#. type: Plain text
#: build/C/man7/socket.7:606
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr "以下に示す操作には B<ioctl>(2)  を用いてアクセスできる。"

#. type: Plain text
#: build/C/man7/socket.7:610
#, no-wrap
msgid "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"
msgstr "I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, >I<&value_result>B<);>\n"

#. type: TP
#: build/C/man7/socket.7:612
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr "B<SIOCGSTAMP>"

#. type: Plain text
#: build/C/man7/socket.7:636
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>.  "
"This ioctl should only be used if the socket option B<SO_TIMESTAMP> is not "
"set on the socket.  Otherwise, it returns the timestamp of the last packet "
"that was received while B<SO_TIMESTAMP> was not set, or it fails if no such "
"packet has been received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set "
"to B<ENOENT>)."
msgstr ""
"最後にユーザに渡されたパケットの受信タイムスタンプを I<struct timeval> に入れ"
"て返す。 これは round trip 時間を正確に測りたいときに便利である。 I<struct "
"timeval> の説明は B<setitimer>(2)  を見てほしい。 この ioctl は、ソケットオプ"
"ション B<SO_TIMESTAMP> がソケットにセットされていない場合にのみ使用すべきであ"
"る。 さもなければ、この ioctl は B<SO_TIMESTAMP> がセットされていなかった間に"
"受信した最後のパケットの時刻を返すか、 そのようなパケットを受信していない場合"
"には失敗する (つまり、 B<ioctl>(2)  は -1 を返し、 I<errno> に B<ENOENT> を"
"セットする)。"

#. type: TP
#: build/C/man7/socket.7:636
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr "B<SIOCSPGRP>"

#. type: Plain text
#: build/C/man7/socket.7:655
msgid ""
"Set the process or process group to send B<SIGIO> or B<SIGURG> signals to "
"when an asynchronous I/O operation has finished or urgent data is "
"available.  The argument is a pointer to a I<pid_t>.  If the argument is "
"positive, send the signals to that process.  If the argument is negative, "
"send the signals to the process group with the ID of the absolute value of "
"the argument.  The process may only choose itself or its own process group "
"to receive signals unless it has the B<CAP_KILL> capability or an effective "
"UID of 0."
msgstr ""
"非同期 I/O 操作の終了時や緊急データの受信時に B<SIGIO> や B<SIGURG> シグナル"
"群を送るプロセスやプロセスグループを設定する。 引き数は I<pid_t> へのポインタ"
"である。 引き数が正だと、そのプロセスにシグナルが送られる。負だと、 引き数の"
"絶対値を ID に持つプロセスグループにシグナルが送られる。 シグナル受信先には、"
"自分自身のプロセス / 自分の所属するプロセスグループ しか指定できない。但し、 "
"B<CAP_KILL> ケーパビリティを持っている場合、及び実効ユーザ ID が 0 のプロセス"
"の場合は この限りではない。"

#. type: TP
#: build/C/man7/socket.7:655
#, no-wrap
msgid "B<FIOASYNC>"
msgstr "B<FIOASYNC>"

#. type: Plain text
#: build/C/man7/socket.7:665
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the "
"socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal "
"set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr ""
"B<O_ASYNC> フラグを変更し、ソケットの非同期 (asynchronous) I/O モードを 有効/"
"無効にする。非同期 I/O モードでは、 新しい I/O イベントが起きたときに、 "
"B<SIGIO> シグナルや B<F_SETSIG> で設定されたシグナル・セットが発行される。"

#. type: Plain text
#: build/C/man7/socket.7:673
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the "
"use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr ""
"引き数はブール整数のフラグである。 (この操作は B<fcntl>(2)  を使って "
"B<O_ASYNC> フラグをセットするのと同じ意味である。)"

#. type: TP
#: build/C/man7/socket.7:673
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr "B<SIOCGPGRP>"

#. type: Plain text
#: build/C/man7/socket.7:682
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG> "
"signals, or 0 when none is set."
msgstr ""
"B<SIGIO> や B<SIGURG> を受信したカレントプロセス・プロセスグループを取得す"
"る。 ない場合は 0 が返る。"

#. type: Plain text
#: build/C/man7/socket.7:686
msgid "Valid B<fcntl>(2)  operations:"
msgstr "有効な B<fcntl>(2)  操作:"

#. type: TP
#: build/C/man7/socket.7:686
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr "B<FIOGETOWN>"

#. type: Plain text
#: build/C/man7/socket.7:691
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr "B<SIOCGPGRP> B<ioctl>(2)  と同じ。"

#. type: TP
#: build/C/man7/socket.7:691
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr "B<FIOSETOWN>"

#. type: Plain text
#: build/C/man7/socket.7:696
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr "B<SIOCSPGRP> B<ioctl>(2)  と同じ。"

#. type: Plain text
#: build/C/man7/socket.7:710
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in "
"Linux 2.2.  The I</proc> interfaces was introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr ""
"B<SO_BINDTODEVICE> は Linux 2.0.30 で導入された。 B<SO_PASSCRED> は Linux "
"2.2 で登場した。 I</proc> インタフェースは Linux 2.2 で導入された。 "
"B<SO_RCVTIMEO> と B<SO_SNDTIMEO> は Linux 2.3.41 以降でサポートされている。 "
"それ以前は、タイムアウトはプロトコル固有の固定の設定値で、 読み書きをすること"
"はできなかった。"

#. type: Plain text
#: build/C/man7/socket.7:715
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr ""
"Linux は、送受信バッファの半分を内部のカーネル構造体で用いると仮定している。 "
"したがって、対応する I</proc> ファイルはネットワーク回線上での大きさの 2 倍に"
"なる。"

#. type: Plain text
#: build/C/man7/socket.7:728
msgid ""
"Linux will only allow port reuse with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from "
"some implementations (e.g., FreeBSD)  where only the later program needs to "
"set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr ""
"Linux では、 B<SO_REUSEADDR> オプションでポートの再利用が許可されるのは、 そ"
"のポートに対して B<bind>(2)  を前に実行したプログラムとそのポートを再利用 し"
"ようとするプログラムの両方で B<SO_REUSEADDR> がセットされた場合のみである。 "
"この動作は (FreeBSD などの) いくつかの実装とは異なる。これらでは、 後でポート"
"を再利用しようとするプログラムで B<SO_REUSEADDR> オプションをセットするだけで"
"よい。 たいていはこの違いは見えない。なぜなら、例えばサーバプログラムは 常に"
"このオプションをセットするように設計されるからである。"

#.  FIXME Document SO_ATTACH_FILTER and SO_DETACH_FILTER
#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/socket.7:741
msgid ""
"The B<CONFIG_FILTER> socket options B<SO_ATTACH_FILTER> and "
"B<SO_DETACH_FILTER> are not documented.  The suggested interface to use them "
"is via the libpcap library."
msgstr ""
"B<CONFIG_FILTER> ソケットオプションである B<SO_ATTACH_FILTER> と "
"B<SO_DETACH_FILTER> について記載されていない。これらは libpcap ライブラリを通"
"して 用いる方が良い。"

#. type: Plain text
#: build/C/man7/socket.7:752
msgid ""
"B<getsockopt>(2), B<setsockopt>(2), B<socket>(2), B<capabilities>(7), B<ddp>"
"(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""
"B<getsockopt>(2), B<setsockopt>(2), B<socket>(2), B<capabilities>(7), B<ddp>"
"(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"

#. type: TH
#: build/C/man2/socketcall.2:26
#, no-wrap
msgid "SOCKETCALL"
msgstr "SOCKETCALL"

#. type: TH
#: build/C/man2/socketcall.2:26
#, no-wrap
msgid "2007-06-28"
msgstr "2007-06-28"

#. type: Plain text
#: build/C/man2/socketcall.2:29
msgid "socketcall - socket system calls"
msgstr "socketcall - ソケット・システムコール"

#. type: Plain text
#: build/C/man2/socketcall.2:31
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"

#. type: Plain text
#: build/C/man2/socketcall.2:39
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""
"B<socketcall>()  はソケット・システムコールのための共通のカーネル・エント"
"リ・ ポイント(kernel entry point)である。 I<call> はどのソケット関数を呼び出"
"すかを指定する。 I<args> は適切なコールに渡すための実際の引き数を含んでいるブ"
"ロックを指す。"

#. type: Plain text
#: build/C/man2/socketcall.2:43
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""
"ユーザー・プログラムは通常の名前を使用して適切な関数を呼び出すべきである。 標"
"準ライブラリの実装者やカーネル・ハッカーのみが B<socketcall>()  について知る"
"必要がある。"

#. type: Plain text
#: build/C/man2/socketcall.2:46
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/socketcall.2:54
msgid ""
"On a few architectures, for example ia64, there is no B<socketcall>()  "
"system call; instead B<socket>(2), B<accept>(2), B<bind>(2), and so on "
"really are implemented as separate system calls."
msgstr ""
"ia64 などのいくつかのアーキテクチャでは、システムコール B<socketcall>()  が存"
"在しない。実際には、その代わりに B<socket>(2), B<accept>(2), B<bind>(2)  など"
"が独立したシステムコールとして実装されている。"

#. type: Plain text
#: build/C/man2/socketcall.2:72
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), B<getsockname>"
"(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), B<recvfrom>(2), B<recvmsg>"
"(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), B<setsockopt>(2), B<shutdown>"
"(2), B<socket>(2), B<socketpair>(2)"
msgstr ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), B<getsockname>"
"(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), B<recvfrom>(2), B<recvmsg>"
"(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), B<setsockopt>(2), B<shutdown>"
"(2), B<socket>(2), B<socketpair>(2)"

#. type: TH
#: build/C/man2/socketpair.2:40
#, no-wrap
msgid "SOCKETPAIR"
msgstr "SOCKETPAIR"

#. type: TH
#: build/C/man2/socketpair.2:40
#, no-wrap
msgid "2008-10-11"
msgstr "2008-10-11"

#. type: Plain text
#: build/C/man2/socketpair.2:43
msgid "socketpair - create a pair of connected sockets"
msgstr "socketpair - 接続されたソケットのペアを作成する"

#. type: Plain text
#: build/C/man2/socketpair.2:50
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"

#. type: Plain text
#: build/C/man2/socketpair.2:61
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see B<socket>"
"(2)."
msgstr ""
"B<socketpair>()  は、指定されたドメイン I<domain> に指定された種類 I<type> で"
"名前のないソケットの接続されたペアを作成する。 I<protocol> が指定されると、こ"
"のプロトコルを用いる。 これらの引き数の詳細は B<socket>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/socketpair.2:67
msgid ""
"The descriptors used in referencing the new sockets are returned in I<sv>[0] "
"and I<sv>[1].  The two sockets are indistinguishable."
msgstr ""
"新しいソケットの参照に使用するディスクリプタ (descriptor) が I<sv>[0] と "
"I<sv>[1] に返される。 二つのソケットは全く同じである。"

#. type: Plain text
#: build/C/man2/socketpair.2:76
msgid "The specified address family is not supported on this machine."
msgstr "このマシンでは指定されたアドレス・ファミリがサポートされていない。"

#. type: Plain text
#: build/C/man2/socketpair.2:81
msgid ""
"The address I<sv> does not specify a valid part of the process address space."
msgstr "アドレス I<sv> がこのプロセスで使えるアドレス空間を指定していない。"

#. type: Plain text
#: build/C/man2/socketpair.2:84
msgid "Too many descriptors are in use by this process."
msgstr "このプロセスが使用しているディスクリプタの数が多すぎる。"

#. type: Plain text
#: build/C/man2/socketpair.2:90
msgid "The specified protocol does not support creation of socket pairs."
msgstr "指定されたプロトコルではソケットのペアの作成がサポートされていない。"

#. type: Plain text
#: build/C/man2/socketpair.2:93
msgid "The specified protocol is not supported on this machine."
msgstr "このマシンでは指定されたプロトコルがサポートされていない。"

#. type: Plain text
#: build/C/man2/socketpair.2:101
msgid ""
"4.4BSD, POSIX.1-2001.  The B<socketpair>()  function call appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System V variants)."
msgstr ""
"4.4BSD, POSIX.1-2001.  B<socketpair>()  関数コールは 4.2BSD で現われた。一般"
"に (System V の変種を含めて)  BSD のソケット層のクローンをサポートしている、"
"BSD 以外のシステムと、 互いに移植性がある。"

#. type: Plain text
#: build/C/man2/socketpair.2:107
msgid ""
"On Linux, the only supported domain for this call is B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>).  (Most implementations have the same "
"restriction.)"
msgstr ""
"Linux では、この関数でサポートされているドメインは B<AF_UNIX> (または同義語で"
"ある B<AF_LOCAL>)  だけである。 (ほとんどの実装で同じ制限がある)"

#. type: Plain text
#: build/C/man2/socketpair.2:116
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags described in B<socket>(2)."
msgstr ""
"Linux 2.6.27 以降では、 B<socketpair>()  は、フラグ B<SOCK_NONBLOCK> と "
"B<SOCK_CLOEXEC> に対応している。フラグの説明は B<socket>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/socketpair.2:129
msgid ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""
"B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"

#~ msgid "2011-10-04"
#~ msgstr "2011-10-04"

#~ msgid "2010-08-31"
#~ msgstr "2010-08-31"

#~ msgid "2010-06-13"
#~ msgstr "2010-06-13"

#~ msgid "RETURN VALUES"
#~ msgstr "RETURN VALUES"

#~ msgid "2011-10-01"
#~ msgstr "2011-10-01"

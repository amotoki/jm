# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:17+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/accept.2:39
#, no-wrap
msgid "ACCEPT"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:39
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:39 build/C/man2/bind.2:66 build/C/man2/connect.2:65 build/C/man2/getsockname.2:38 build/C/man2/getsockopt.2:42 build/C/man2/listen.2:43 build/C/man2/recv.2:39 build/C/man2/recvmmsg.2:26 build/C/man2/select.2:38 build/C/man2/select_tut.2:30 build/C/man2/send.2:38 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:23 build/C/man2/socket.2:41 build/C/man7/socket.7:26 build/C/man2/socketcall.2:26 build/C/man2/socketpair.2:40
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:39 build/C/man2/bind.2:66 build/C/man3/bindresvport.3:27 build/C/man2/connect.2:65 build/C/man3/getifaddrs.3:33 build/C/man2/getsockname.2:38 build/C/man2/getsockopt.2:42 build/C/man2/listen.2:43 build/C/man2/recv.2:39 build/C/man2/recvmmsg.2:26 build/C/man2/select.2:38 build/C/man2/select_tut.2:30 build/C/man2/send.2:38 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:23 build/C/man2/socket.2:41 build/C/man7/socket.7:26 build/C/man2/socketcall.2:26 build/C/man2/socketpair.2:40
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:40 build/C/man2/bind.2:67 build/C/man3/bindresvport.3:28 build/C/man2/connect.2:66 build/C/man3/getifaddrs.3:34 build/C/man2/getsockname.2:39 build/C/man2/getsockopt.2:43 build/C/man2/listen.2:44 build/C/man2/recv.2:40 build/C/man2/recvmmsg.2:27 build/C/man2/select.2:39 build/C/man2/select_tut.2:31 build/C/man2/send.2:39 build/C/man2/sendmmsg.2:29 build/C/man3/sockatmark.3:24 build/C/man2/socket.2:42 build/C/man7/socket.7:27 build/C/man2/socketcall.2:27 build/C/man2/socketpair.2:41
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:42
msgid "accept - accept a connection on a socket"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:42 build/C/man2/bind.2:69 build/C/man3/bindresvport.3:30 build/C/man2/connect.2:68 build/C/man3/getifaddrs.3:36 build/C/man2/getsockname.2:41 build/C/man2/getsockopt.2:45 build/C/man2/listen.2:46 build/C/man2/recv.2:42 build/C/man2/recvmmsg.2:29 build/C/man2/select.2:42 build/C/man2/select_tut.2:34 build/C/man2/send.2:41 build/C/man2/sendmmsg.2:31 build/C/man3/sockatmark.3:26 build/C/man2/socket.2:44 build/C/man7/socket.7:29 build/C/man2/socketcall.2:29 build/C/man2/socketpair.2:43
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:46 build/C/man2/bind.2:73
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:48
#, no-wrap
msgid ""
"B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:51
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:54
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:55 build/C/man2/bind.2:77 build/C/man3/bindresvport.3:37 build/C/man2/connect.2:77 build/C/man3/getifaddrs.3:45 build/C/man2/getsockname.2:48 build/C/man2/getsockopt.2:56 build/C/man2/listen.2:54 build/C/man2/recv.2:57 build/C/man2/recvmmsg.2:39 build/C/man2/select.2:81 build/C/man2/select_tut.2:73 build/C/man2/send.2:56 build/C/man2/sendmmsg.2:40 build/C/man3/sockatmark.3:40 build/C/man2/socket.2:50 build/C/man7/socket.7:33 build/C/man2/socketcall.2:31 build/C/man2/socketpair.2:50
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:70
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:79
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:97
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:105
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:110 build/C/man2/getsockname.2:65
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:123
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:137
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2)  or B<poll>(2).  A readable event will be delivered when a new "
"connection is attempted and you may then call B<accept>()  to get a socket "
"for that connection.  Alternatively, you can set the socket to deliver "
"B<SIGIO> when activity occurs on a socket; see B<socket>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:150
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECNet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently only DECNet has these "
"semantics on Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:160
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:160 build/C/man2/socket.2:162
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:168 build/C/man2/socket.2:170
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:168 build/C/man2/socket.2:170
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:178 build/C/man2/socket.2:180
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:178 build/C/man2/bind.2:150 build/C/man3/bindresvport.3:64 build/C/man2/connect.2:125 build/C/man3/getifaddrs.3:137 build/C/man2/getsockname.2:65 build/C/man2/getsockopt.2:129 build/C/man2/listen.2:80 build/C/man2/recv.2:386 build/C/man2/recvmmsg.2:144 build/C/man2/select.2:289 build/C/man2/select_tut.2:483 build/C/man2/send.2:273 build/C/man2/sendmmsg.2:119 build/C/man3/sockatmark.3:49 build/C/man2/socket.2:312 build/C/man2/socketpair.2:67
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:185
msgid ""
"On success, these system calls return a nonnegative integer that is a "
"descriptor for the accepted socket.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: SS
#: build/C/man2/accept.2:185
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:212
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of "
"TCP/IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:212 build/C/man2/bind.2:155 build/C/man3/bindresvport.3:69 build/C/man2/connect.2:130 build/C/man3/getifaddrs.3:144 build/C/man2/getsockname.2:70 build/C/man2/getsockopt.2:134 build/C/man2/listen.2:85 build/C/man2/recv.2:391 build/C/man2/recvmmsg.2:152 build/C/man2/select.2:306 build/C/man2/send.2:278 build/C/man2/sendmmsg.2:133 build/C/man3/sockatmark.3:54 build/C/man2/socket.2:317 build/C/man2/socketpair.2:72
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:213 build/C/man2/recv.2:396 build/C/man2/send.2:294
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/accept.2:221
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:221 build/C/man2/bind.2:163 build/C/man2/connect.2:167 build/C/man2/getsockname.2:71 build/C/man2/getsockopt.2:135 build/C/man2/listen.2:89 build/C/man2/recv.2:405 build/C/man2/select.2:307 build/C/man2/send.2:302 build/C/man3/sockatmark.3:55
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:224
msgid "The descriptor is invalid."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:224
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:227
msgid "A connection has been aborted."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:227 build/C/man2/bind.2:189 build/C/man2/connect.2:173 build/C/man2/getsockname.2:76 build/C/man2/getsockopt.2:140 build/C/man2/recv.2:414 build/C/man2/send.2:311 build/C/man2/socketpair.2:76
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:232
msgid "The I<addr> argument is not in a writable part of the user address space."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:232 build/C/man2/connect.2:201 build/C/man2/recv.2:418 build/C/man2/select.2:312 build/C/man2/send.2:314
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:237
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:237 build/C/man2/accept.2:242 build/C/man2/bind.2:167 build/C/man2/bind.2:193 build/C/man2/getsockname.2:82 build/C/man2/getsockopt.2:150 build/C/man2/recv.2:423 build/C/man2/recvmmsg.2:156 build/C/man2/select.2:316 build/C/man2/send.2:318 build/C/man3/sockatmark.3:59 build/C/man2/socket.2:325 build/C/man2/socket.2:328
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:242
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:247
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:247 build/C/man2/socket.2:333 build/C/man2/socketpair.2:81
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:250
msgid "The per-process limit of open file descriptors has been reached."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:250 build/C/man2/socket.2:336 build/C/man2/socketpair.2:84
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:253 build/C/man2/socket.2:339 build/C/man2/socketpair.2:87
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:253
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:258
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:258 build/C/man2/bind.2:172 build/C/man2/connect.2:213 build/C/man2/getsockname.2:90 build/C/man2/getsockopt.2:164 build/C/man2/listen.2:94 build/C/man2/recv.2:438 build/C/man2/send.2:347
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:261
msgid "The descriptor references a file, not a socket."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:261 build/C/man2/listen.2:99 build/C/man2/send.2:352 build/C/man2/socketpair.2:87
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:265
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:265
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:268
msgid "Protocol error."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:272
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:272
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:275
msgid "Firewall rules forbid connection."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:287
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:287 build/C/man3/getifaddrs.3:157 build/C/man2/recvmmsg.2:160 build/C/man2/select.2:325 build/C/man2/sendmmsg.2:145 build/C/man3/sockatmark.3:66 build/C/man7/socket.7:696
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:292
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:292 build/C/man2/bind.2:220 build/C/man3/bindresvport.3:89 build/C/man2/connect.2:223 build/C/man3/getifaddrs.3:165 build/C/man2/getsockname.2:95 build/C/man2/getsockopt.2:169 build/C/man2/listen.2:104 build/C/man2/recv.2:443 build/C/man2/recvmmsg.2:165 build/C/man2/select.2:331 build/C/man2/send.2:366 build/C/man2/sendmmsg.2:150 build/C/man3/sockatmark.3:69 build/C/man2/socket.2:350 build/C/man2/socketcall.2:43 build/C/man2/socketpair.2:93
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: build/C/man2/accept.2:304
msgid ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:307
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr ""

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: build/C/man2/accept.2:322
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:322 build/C/man2/bind.2:232 build/C/man3/bindresvport.3:92 build/C/man2/connect.2:239 build/C/man3/getifaddrs.3:185 build/C/man2/getsockname.2:101 build/C/man2/getsockopt.2:176 build/C/man2/listen.2:109 build/C/man2/recv.2:453 build/C/man2/select.2:346 build/C/man2/select_tut.2:501 build/C/man2/send.2:380 build/C/man2/sendmmsg.2:153 build/C/man3/sockatmark.3:71 build/C/man2/socket.2:364 build/C/man7/socket.7:710 build/C/man2/socketcall.2:46 build/C/man2/socketpair.2:101
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:328 build/C/man2/bind.2:238 build/C/man2/connect.2:245 build/C/man2/getsockopt.2:182 build/C/man2/listen.2:135 build/C/man2/socket.2:370 build/C/man2/socketpair.2:122
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:349
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2)  or B<poll>(2)  return a readability event because the "
"connection might have been removed by an asynchronous network error or "
"another thread before B<accept>()  is called.  If this happens then the call "
"will block waiting for the next connection to arrive.  To ensure that "
"B<accept>()  never blocks, the passed socket I<sockfd> needs to have the "
"B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""

#. type: SS
#: build/C/man2/accept.2:349
#, no-wrap
msgid "The socklen_t type"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:359
msgid ""
"The third argument of B<accept>()  was originally declared as an I<int *> "
"(and is that under libc4 and libc5 and on many other systems like 4.x BSD, "
"SunOS 4, SGI); a POSIX.1g draft standard wanted to change it into a I<size_t "
"*>, and that is what it is for SunOS 5.  Later POSIX drafts have I<socklen_t "
"*>, and so do the Single UNIX Specification and glibc2.  Quoting Linus "
"Torvalds:"
msgstr ""

#.  .I fails: only italicizes a single line
#. type: Plain text
#: build/C/man2/accept.2:376
msgid ""
"\"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.  "
"Anything else breaks any BSD socket layer stuff.  POSIX initially I<did> "
"make it a size_t, and I (and hopefully others, but obviously not too many) "
"complained to them very loudly indeed.  Making it a size_t is completely "
"broken, exactly because size_t very seldom is the same size as \"int\" on "
"64-bit architectures, for example.  And it I<has> to be the same size as "
"\"int\" because that's what the BSD socket interface is.  Anyway, the POSIX "
"people eventually got a clue, and created \"socklen_t\".  They shouldn't "
"have touched it in the first place, but once they did they felt it had to "
"have a named type for some unfathomable reason (probably somebody didn't "
"like losing face over having done the original stupid thing, so they "
"silently just renamed their blunder).\""
msgstr ""

#. type: SH
#: build/C/man2/accept.2:376 build/C/man2/bind.2:252 build/C/man2/connect.2:256 build/C/man3/getifaddrs.3:198 build/C/man2/listen.2:164 build/C/man2/recv.2:488 build/C/man2/select.2:521 build/C/man2/select_tut.2:527 build/C/man2/send.2:417 build/C/man3/sockatmark.3:95 build/C/man2/socket.2:383
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:379 build/C/man2/listen.2:167
msgid "See B<bind>(2)."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:379 build/C/man2/bind.2:317 build/C/man3/bindresvport.3:98 build/C/man2/connect.2:261 build/C/man3/getifaddrs.3:281 build/C/man2/getsockname.2:110 build/C/man2/getsockopt.2:200 build/C/man2/listen.2:167 build/C/man2/recv.2:493 build/C/man2/recvmmsg.2:168 build/C/man2/select.2:558 build/C/man2/select_tut.2:817 build/C/man2/send.2:422 build/C/man2/sendmmsg.2:168 build/C/man3/sockatmark.3:130 build/C/man2/socket.2:388 build/C/man7/socket.7:741 build/C/man2/socketcall.2:54 build/C/man2/socketpair.2:122
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:386
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:386 build/C/man2/bind.2:330 build/C/man3/bindresvport.3:101 build/C/man2/connect.2:268 build/C/man3/getifaddrs.3:287 build/C/man2/getsockname.2:117 build/C/man2/getsockopt.2:208 build/C/man2/listen.2:173 build/C/man2/recv.2:504 build/C/man2/recvmmsg.2:175 build/C/man2/select.2:573 build/C/man2/select_tut.2:836 build/C/man2/send.2:437 build/C/man2/sendmmsg.2:173 build/C/man3/sockatmark.3:135 build/C/man2/socket.2:419 build/C/man7/socket.7:752 build/C/man2/socketcall.2:72 build/C/man2/socketpair.2:129
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:393 build/C/man2/bind.2:337 build/C/man3/bindresvport.3:108 build/C/man2/connect.2:275 build/C/man3/getifaddrs.3:294 build/C/man2/getsockname.2:124 build/C/man2/getsockopt.2:215 build/C/man2/listen.2:180 build/C/man2/recv.2:511 build/C/man2/recvmmsg.2:182 build/C/man2/select.2:580 build/C/man2/select_tut.2:843 build/C/man2/send.2:444 build/C/man2/sendmmsg.2:180 build/C/man3/sockatmark.3:142 build/C/man2/socket.2:426 build/C/man7/socket.7:759 build/C/man2/socketcall.2:79 build/C/man2/socketpair.2:136
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/bind.2:66
#, no-wrap
msgid "BIND"
msgstr ""

#. type: TH
#: build/C/man2/bind.2:66
#, no-wrap
msgid "2007-12-28"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:69
msgid "bind - bind a name to a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:76
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:90
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:97
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:128
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET> see "
"B<ip>(7), for B<AF_INET6> see B<ipv6>(7), for B<AF_UNIX> see B<unix>(7), for "
"B<AF_APPLETALK> see B<ddp>(7), for B<AF_PACKET> see B<packet>(7), for "
"B<AF_X25> see B<x25>(7)  and for B<AF_NETLINK> see B<netlink>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:135
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:142
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:150
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLE below."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:155 build/C/man2/getsockname.2:70 build/C/man2/getsockopt.2:134 build/C/man2/listen.2:85 build/C/man2/socketpair.2:72
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:156 build/C/man2/bind.2:180 build/C/man3/bindresvport.3:74 build/C/man2/connect.2:133 build/C/man2/send.2:283 build/C/man2/socket.2:318
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: build/C/man2/bind.2:160
msgid "The address is protected, and the user is not the superuser."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:160 build/C/man3/bindresvport.3:79 build/C/man2/connect.2:146 build/C/man2/listen.2:86
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:163
msgid "The given address is already in use."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:167
msgid "I<sockfd> is not a valid descriptor."
msgstr ""

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: build/C/man2/bind.2:172
msgid "The socket is already bound to an address."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:176
msgid "I<sockfd> is a descriptor for a file, not a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:180
msgid "The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:185
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/bind.2:185
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:189
msgid ""
"A nonexistent interface was requested or the requested address was not "
"local."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:193
msgid "I<addr> points outside the user's accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:200
msgid "The I<addrlen> is wrong, or the socket was not in the B<AF_UNIX> family."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:200
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:204
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:204
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:208
msgid "I<addr> is too long."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:208
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:211
msgid "The file does not exist."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:211 build/C/man2/recv.2:427 build/C/man2/select.2:322 build/C/man2/send.2:341
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:214
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:214
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:217
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:217
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:220
msgid "The socket inode would reside on a read-only file system."
msgstr ""

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: build/C/man2/bind.2:232
msgid "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:249
msgid ""
"The third argument of B<bind>()  is in reality an I<int> (and this is what "
"4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in the "
"present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: SH
#: build/C/man2/bind.2:249 build/C/man2/getsockopt.2:197 build/C/man2/select.2:458 build/C/man2/send.2:412 build/C/man3/sockatmark.3:91 build/C/man7/socket.7:728
#, no-wrap
msgid "BUGS"
msgstr ""

#.  FIXME What *are* transparent proxy options?
#. type: Plain text
#: build/C/man2/bind.2:252
msgid "The transparent proxy options are not described."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:257
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: build/C/man2/bind.2:264
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:271
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:274
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:277
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:284
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:288
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:294
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:298
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:301
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:304
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:310
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:312
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:316
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:330
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/bindresvport.3:27
#, no-wrap
msgid "BINDRESVPORT"
msgstr ""

#. type: TH
#: build/C/man3/bindresvport.3:27 build/C/man2/connect.2:65 build/C/man2/getsockname.2:38 build/C/man2/getsockopt.2:42 build/C/man3/sockatmark.3:23
#, no-wrap
msgid "2008-12-03"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:30
msgid "bindresvport - bind a socket to a privileged IP port"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:36
#, no-wrap
msgid "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"
msgstr ""

#.  Glibc actually starts searching with a port # in the range 600 to 1023
#. type: Plain text
#: build/C/man3/bindresvport.3:43
msgid ""
"B<bindresvport>()  is used to bind a socket descriptor to a privileged "
"anonymous IP port, that is, a port number arbitrarily selected from the "
"range 512 to 1023."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:53
msgid ""
"If the B<bind>(2)  performed by B<bindresvport>()  is successful, and I<sin> "
"is not NULL, then I<sin-E<gt>sin_port> returns the port number actually "
"allocated."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:64
msgid ""
"I<sin> can be NULL, in which case I<sin-E<gt>sin_family> is implicitly taken "
"to be B<AF_INET>.  However, in this case, B<bindresvport>()  has no way to "
"return the port number actually allocated.  (This information can later be "
"obtained using B<getsockname>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:69
msgid ""
"B<bindresvport>()  returns 0 on success; otherwise -1 is returned and "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:74
msgid ""
"B<bindresvport>()  can fail for any of the same reasons as B<bind>(2).  In "
"addition, the following errors may occur:"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:79
msgid ""
"The caller did not have superuser privilege (to be precise: the "
"B<CAP_NET_BIND_SERVICE> capability is required)."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:82
msgid "All privileged ports are in use."
msgstr ""

#. type: TP
#: build/C/man3/bindresvport.3:82
#, no-wrap
msgid "B<EAFNOSUPPORT> (B<EPFNOSUPPORT> in glibc 2.7 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:89
msgid "I<sin> is not NULL and I<sin-E<gt>sin_family> is not B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:92
msgid "Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:98
msgid ""
"Unlike some B<bindresvport>()  implementations, the glibc implementation "
"ignores any value that the caller supplies in I<sin-E<gt>sin_port>."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:101
msgid "B<bind>(2), B<getsockname>(2)"
msgstr ""

#. type: TH
#: build/C/man2/connect.2:65
#, no-wrap
msgid "CONNECT"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:68
msgid "connect - initiate a connection on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:71 build/C/man2/getsockopt.2:48 build/C/man2/listen.2:49
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:73 build/C/man2/getsockname.2:44 build/C/man2/getsockopt.2:50 build/C/man2/listen.2:51 build/C/man2/recv.2:49
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:76
#, no-wrap
msgid ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:95
msgid ""
"The B<connect>()  system call connects the socket referred to by the file "
"descriptor I<sockfd> to the address specified by I<addr>.  The I<addrlen> "
"argument specifies the size of I<addr>.  The format of the address in "
"I<addr> is determined by the address space of the socket I<sockfd>; see "
"B<socket>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:111
msgid ""
"If the socket I<sockfd> is of type B<SOCK_DGRAM> then I<addr> is the address "
"to which datagrams are sent by default, and the only address from which "
"datagrams are received.  If the socket is of type B<SOCK_STREAM> or "
"B<SOCK_SEQPACKET>, this call attempts to make a connection to the socket "
"that is bound to the address specified by I<addr>."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:125
msgid ""
"Generally, connection-based protocol sockets may successfully B<connect>()  "
"only once; connectionless protocol sockets may use B<connect>()  multiple "
"times to change their association.  Connectionless sockets may dissolve the "
"association by connecting to an address with the I<sa_family> member of "
"I<sockaddr> set to B<AF_UNSPEC> (supported on Linux since kernel 2.2)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:130
msgid ""
"If the connection or binding succeeds, zero is returned.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:133
msgid ""
"The following are general socket errors only.  There may be other "
"domain-specific error codes."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:141
msgid ""
"For UNIX domain sockets, which are identified by pathname: Write permission "
"is denied on the socket file, or search permission is denied for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/connect.2:141
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:146
msgid ""
"The user tried to connect to a broadcast address without having the socket "
"broadcast flag enabled or the connection request failed because of a local "
"firewall rule."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:149
msgid "Local address is already in use."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:149 build/C/man2/socket.2:322 build/C/man2/socketpair.2:73
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:154
msgid ""
"The passed address didn't have the correct address family in its "
"I<sa_family> field."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:154
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:163
msgid ""
"No more free local ports or insufficient entries in the routing cache.  For "
"B<AF_INET> see the description of I</proc/sys/net/ipv4/ip_local_port_range> "
"B<ip>(7)  for information on how to increase the number of local ports."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:163
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:167
msgid ""
"The socket is nonblocking and a previous connection attempt has not yet been "
"completed."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:170
msgid "The file descriptor is not a valid index in the descriptor table."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:170 build/C/man2/recv.2:410
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:173
msgid "No-one listening on the remote address."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:176
msgid "The socket structure address is outside the user's address space."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:176
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:201
msgid ""
"The socket is nonblocking and the connection cannot be completed "
"immediately.  It is possible to B<select>(2)  or B<poll>(2)  for completion "
"by selecting the socket for writing.  After B<select>(2)  indicates "
"writability, use B<getsockopt>(2)  to read the B<SO_ERROR> option at level "
"B<SOL_SOCKET> to determine whether B<connect>()  completed successfully "
"(B<SO_ERROR> is zero) or unsuccessfully (B<SO_ERROR> is one of the usual "
"error codes listed here, explaining the reason for the failure)."
msgstr ""

#.  For TCP, the connection will complete asynchronously.
#.  See http://lkml.org/lkml/2005/7/12/254
#. type: Plain text
#: build/C/man2/connect.2:207
msgid ""
"The system call was interrupted by a signal that was caught; see "
"B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:207 build/C/man2/send.2:321
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:210
msgid "The socket is already connected."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:210
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:213
msgid "Network is unreachable."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:216
msgid "The file descriptor is not associated with a socket."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:216
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:223
msgid ""
"Timeout while attempting connection.  The server may be too busy to accept "
"new connections.  Note that for IP sockets the timeout may be very long when "
"syncookies are enabled on the server."
msgstr ""

#.  SVr4 documents the additional
#.  general error codes
#.  .BR EADDRNOTAVAIL ,
#.  .BR EINVAL ,
#.  .BR EAFNOSUPPORT ,
#.  .BR EALREADY ,
#.  .BR EINTR ,
#.  .BR EPROTOTYPE ,
#.  and
#.  .BR ENOSR .
#.  It also
#.  documents many additional error conditions not described here.
#. type: Plain text
#: build/C/man2/connect.2:239
msgid ""
"SVr4, 4.4BSD, (the B<connect>()  function first appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:256
msgid ""
"The third argument of B<connect>()  is in reality an I<int> (and this is "
"what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
"the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:261
msgid "An example of the use of B<connect>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:268
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:33
#, no-wrap
msgid "GETIFADDRS"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:33
#, no-wrap
msgid "2010-10-06"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:33
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:36
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:40
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:42
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:44
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:55
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing "
"the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:74
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:81
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: build/C/man3/getifaddrs.3:88
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:97
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:105
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:111
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:126
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:131
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:137
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be "
"freed using B<freeifaddrs>()  when no longer needed."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:144
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:157
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:165
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation only supported IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is only "
"available on kernels that support netlink."
msgstr ""

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: build/C/man3/getifaddrs.3:185
msgid ""
"Not in POSIX.1-2001.  This function first appeared in BSDi and is present on "
"the BSD systems, but with slightly different semantics "
"documented\\(emreturning one entry per interface, not per address.  This "
"means I<ifa_addr> and other fields can actually be NULL if the interface has "
"no address, and no link-level address is returned if the interface has an IP "
"address assigned.  Also, the way of choosing either I<ifa_broadaddr> or "
"I<ifa_dstaddr> differs on various systems."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:198
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"net_device_stats>, defined in I<E<lt>linux/netdevice.hE<gt>>, which contains "
"various interface attributes and statistics."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:205
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(), "
"and B<getnameinfo>(3).  Here is what we see when running this program on one "
"system:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:219
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo      address family: 17 (AF_PACKET)\n"
"eth0    address family: 17 (AF_PACKET)\n"
"lo      address family: 2 (AF_INET)\n"
"        address: E<lt>127.0.0.1E<gt>\n"
"eth0    address family: 2 (AF_INET)\n"
"        address: E<lt>10.1.1.4E<gt>\n"
"lo      address family: 10 (AF_INET6)\n"
"        address: E<lt>::1E<gt>\n"
"eth0    address family: 10 (AF_INET6)\n"
"        address: E<lt>fe80::2d0:59ff:feda:eb51%eth0E<gt>\n"
msgstr ""

#. type: SS
#: build/C/man3/getifaddrs.3:221
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:231
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:238
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:243
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:246
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:250
#, no-wrap
msgid ""
"    for (ifa = ifaddr; ifa != NULL; ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:252
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:255
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:261
#, no-wrap
msgid ""
"        printf(\"%s\\t  address family: %d%s\\en\",\n"
"                ifa-E<gt>ifa_name, family,\n"
"                (family == AF_PACKET) ? \" (AF_PACKET)\" :\n"
"                (family == AF_INET) ?   \" (AF_INET)\" :\n"
"                (family == AF_INET6) ?  \" (AF_INET6)\" : \"\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:263
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:276
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:280
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:287
msgid "B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man2/getsockname.2:38
#, no-wrap
msgid "GETSOCKNAME"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:41
msgid "getsockname - get socket name"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:47
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:60
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:76 build/C/man2/getsockopt.2:140 build/C/man2/listen.2:94
msgid "The argument I<sockfd> is not a valid descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:82
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:86
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: build/C/man2/getsockname.2:86 build/C/man2/send.2:333
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:90
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:95 build/C/man2/getsockopt.2:169
msgid "The argument I<sockfd> is a file, not a socket."
msgstr ""

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: build/C/man2/getsockname.2:101
msgid ""
"SVr4, 4.4BSD (the B<getsockname>()  function call appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:110
msgid ""
"The third argument of B<getsockname>()  is in reality an I<int *> (and this "
"is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
"the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:117
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getsockopt.2:42
#, no-wrap
msgid "GETSOCKOPT"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:45
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:55
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:65
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple "
"protocol levels; they are always present at the uppermost socket level."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:84
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option "
"is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:106
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:116
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:125
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:129
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:150
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:161
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""

#. type: TP
#: build/C/man2/getsockopt.2:161
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:164
msgid "The option is unknown at the level indicated."
msgstr ""

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: build/C/man2/getsockopt.2:176
msgid "SVr4, 4.4BSD (these system calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:197
msgid ""
"The I<optlen> argument of B<getsockopt>()  and B<setsockopt>()  is in "
"reality an I<int [*]> (and this is what 4.x BSD and libc4 and libc5 have).  "
"Some POSIX confusion resulted in the present I<socklen_t>, also used by "
"glibc.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:200
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:208
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<socket>(7), "
"B<tcp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/listen.2:43
#, no-wrap
msgid "LISTEN"
msgstr ""

#. type: TH
#: build/C/man2/listen.2:43
#, no-wrap
msgid "2008-11-20"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:46
msgid "listen - listen for connections on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:53
#, no-wrap
msgid "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:61
msgid ""
"B<listen>()  marks the socket referred to by I<sockfd> as a passive socket, "
"that is, as a socket that will be used to accept incoming connection "
"requests using B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:68
msgid ""
"The I<sockfd> argument is a file descriptor that refers to a socket of type "
"B<SOCK_STREAM> or B<SOCK_SEQPACKET>."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:80
msgid ""
"The I<backlog> argument defines the maximum length to which the queue of "
"pending connections for I<sockfd> may grow.  If a connection request arrives "
"when the queue is full, the client may receive an error with an indication "
"of B<ECONNREFUSED> or, if the underlying protocol supports retransmission, "
"the request may be ignored so that a later reattempt at connection succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:89
msgid "Another socket is already listening on the same port."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:99 build/C/man2/send.2:352
msgid "The argument I<sockfd> is not a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:104
msgid "The socket is not of a type that supports the B<listen>()  operation."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:109
msgid ""
"4.4BSD, POSIX.1-2001.  The B<listen>()  function call first appeared in "
"4.2BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:111
msgid "To accept connections, the following steps are performed:"
msgstr ""

#. type: TP
#: build/C/man2/listen.2:112 build/C/man2/select_tut.2:345
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:115
msgid "A socket is created with B<socket>(2)."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:115 build/C/man2/select_tut.2:354
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:121
msgid ""
"The socket is bound to a local address using B<bind>(2), so that other "
"sockets may be B<connect>(2)ed to it."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:121 build/C/man2/select_tut.2:358
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:125
msgid ""
"A willingness to accept incoming connections and a queue limit for incoming "
"connections are specified with B<listen>()."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:125 build/C/man2/select_tut.2:365
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:128
msgid "Connections are accepted with B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:151
msgid ""
"The behavior of the I<backlog> argument on TCP sockets changed with Linux "
"2.2.  Now it specifies the queue length for I<completely> established "
"sockets waiting to be accepted, instead of the number of incomplete "
"connection requests.  The maximum length of the queue for incomplete sockets "
"can be set using I</proc/sys/net/ipv4/tcp_max_syn_backlog>.  When syncookies "
"are enabled there is no logical maximum length and this setting is ignored.  "
"See B<tcp>(7)  for more information."
msgstr ""

#.  The following is now rather historic information (MTK, Jun 05)
#.  Don't rely on this value in portable applications since BSD
#.  (and some BSD-derived systems) limit the backlog to 5.
#. type: Plain text
#: build/C/man2/listen.2:164
msgid ""
"If the I<backlog> argument is greater than the value in "
"I</proc/sys/net/core/somaxconn>, then it is silently truncated to that "
"value; the default value in this file is 128.  In kernels before 2.4.25, "
"this limit was a hard coded value, B<SOMAXCONN>, with the value 128."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:173
msgid "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/recv.2:39
#, no-wrap
msgid "RECV"
msgstr ""

#. type: TH
#: build/C/man2/recv.2:39
#, no-wrap
msgid "2011-09-16"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:42
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:47 build/C/man2/select.2:53 build/C/man2/select_tut.2:45
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:51
#, no-wrap
msgid ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:54
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:56
#, no-wrap
msgid ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:64
msgid ""
"The B<recvfrom>()  and B<recvmsg>()  calls are used to receive messages from "
"a socket, and may be used to receive data on a socket whether or not it is "
"connection-oriented."
msgstr ""

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: build/C/man2/recv.2:93
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address, this source address is filled in.  When I<src_addr> is NULL, "
"nothing is filled in; in this case, I<addrlen> is not used, and should also "
"be NULL.  The argument I<addrlen> is a value-result argument, which the "
"caller should initialize before the call to the size of the buffer "
"associated with I<src_addr>, and modified on return to indicate the actual "
"size of the source address.  The returned address is truncated if the buffer "
"provided is too small; in this case, I<addrlen> will return a value greater "
"than was supplied to the call."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:105
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2))  and is identical to B<recvfrom>()  with a NULL I<src_addr> "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:111
msgid ""
"All three routines return the length of the message on successful "
"completion.  If a message is too long to fit in the supplied buffer, excess "
"bytes may be discarded depending on the type of socket the message is "
"received from."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:121
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:127
msgid ""
"The B<select>(2)  or B<poll>(2)  call may be used to determine when more "
"data arrives."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:133
msgid ""
"The I<flags> argument to a B<recv>()  call is formed by ORing one or more of "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man2/recv.2:133
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:144
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:144 build/C/man2/send.2:186
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:154
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK> (this can also be enabled using "
"the B<O_NONBLOCK> flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:154
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:173
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:185 build/C/man2/recv.2:248
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> is set in the I<msghdr>.  After an error has been passed, "
"the pending socket error is regenerated based on the next queued error and "
"will be passed on the next socket operation."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:189
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:196
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:208
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;     /* padding */\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:210
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:234
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:248 build/C/man2/recv.2:379 build/C/man2/send.2:228
#, no-wrap
msgid "B<MSG_OOB>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:255
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such "
"protocols."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:255
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:262
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:262
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:273
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), and "
"netlink (since Linux 2.6.22) sockets: return the real length of the packet "
"or datagram, even when it was longer than the passed buffer.  Not "
"implemented for UNIX domain (B<unix>(7))  sockets."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:276
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:276
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:283
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:291
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:298
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:308 build/C/man2/send.2:256
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* optional address */\n"
"    socklen_t     msg_namelen;    /* size of address */\n"
"    struct iovec *msg_iov;        /* scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* ancillary data, see below */\n"
"    size_t        msg_controllen; /* ancillary data buffer len */\n"
"    int           msg_flags;      /* flags on received message */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:338
msgid ""
"Here I<msg_name> and I<msg_namelen> specify the source address if the socket "
"is unconnected; I<msg_name> may be given as a NULL pointer if no names are "
"desired or required.  The fields I<msg_iov> and I<msg_iovlen> describe "
"scatter-gather locations, as discussed in B<readv>(2).  The field "
"I<msg_control>, which has length I<msg_controllen>, points to a buffer for "
"other protocol control-related messages or miscellaneous ancillary data.  "
"When B<recvmsg>()  is called, I<msg_controllen> should contain the length of "
"the available buffer in I<msg_control>; upon return from a successful call "
"it will contain the length of the control message sequence."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:340
msgid "The messages are of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:350
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    socklen_t     cmsg_len;     /* data byte count, including hdr */\n"
"    int           cmsg_level;   /* originating protocol */\n"
"    int           cmsg_type;    /* protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:355
msgid "Ancillary data should only be accessed by the macros defined in B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:358
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:366
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""

#. type: TP
#: build/C/man2/recv.2:366
#, no-wrap
msgid "B<MSG_EOR>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:371
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:371
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:375
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:375
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:379
msgid ""
"indicates that some control data were discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:382
msgid "is returned to indicate that expedited or out-of-band data were received."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:382
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:386
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:391
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  The return value will be 0 when the peer has performed an orderly "
"shutdown."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:396
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/recv.2:405
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:410
msgid "The argument I<sockfd> is an invalid descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:414
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:418
msgid "The receive buffer pointer(s) point outside the process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:423
msgid ""
"The receive was interrupted by delivery of a signal before any data were "
"available; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:427 build/C/man2/send.2:321
msgid "Invalid argument passed."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:431
msgid "Could not allocate memory for B<recvmsg>()."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:431 build/C/man2/send.2:344
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:438
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:443
msgid "The argument I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:446
msgid "4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:453
msgid ""
"POSIX.1-2001 only describes the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:469
msgid ""
"The prototypes given above follow glibc2.  The Single UNIX Specification "
"agrees, except that it has return values of type I<ssize_t> (while 4.x BSD "
"and libc4 and libc5 all have I<int>).  The I<flags> argument is I<int> in "
"4.x BSD, but I<unsigned int> in libc4 and libc5.  The I<len> argument is "
"I<int> in 4.x BSD, but I<size_t> in libc4 and libc5.  The I<addrlen> "
"argument is I<int\\ *> in 4.x BSD, libc4 and libc5.  The present "
"I<socklen_t\\ *> was invented by POSIX.  See also B<accept>(2)."
msgstr ""

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: build/C/man2/recv.2:483 build/C/man2/send.2:407
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:488
msgid ""
"See B<recvmmsg(2)> for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:493
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:504
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/recvmmsg.2:26
#, no-wrap
msgid "RECVMMSG"
msgstr ""

#. type: TH
#: build/C/man2/recvmmsg.2:26 build/C/man2/select.2:38
#, no-wrap
msgid "2012-05-02"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:29
msgid "recvmmsg - receive multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:33 build/C/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:36
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:38
#, no-wrap
msgid "B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:50
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:62 build/C/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:68 build/C/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:90
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the "
"message in the entry.  This field has the same value as the return value of "
"a single B<recvmsg>(2)  on the header."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""

#. type: TP
#: build/C/man2/recvmmsg.2:97
#, no-wrap
msgid "B<MSG_WAITFORONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:102
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:118
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation.  (This interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.)  If I<timeout> is I<NULL> then the operation "
"blocks indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:129
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:144
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:152
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:156
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can "
"occur:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:160
msgid "I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:165
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.32.  Support in glibc "
"was added in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:168
msgid "B<recvmmsg>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:175
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/select.2:38
#, no-wrap
msgid "SELECT"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:42 build/C/man2/select_tut.2:34
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:45 build/C/man2/select_tut.2:37
#, no-wrap
msgid "/* According to POSIX.1-2001 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:47 build/C/man2/select.2:68 build/C/man2/select_tut.2:39 build/C/man2/select_tut.2:60
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:49 build/C/man2/select_tut.2:41
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:51 build/C/man2/select_tut.2:43
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:55 build/C/man2/select_tut.2:47
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:58
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:60 build/C/man2/select_tut.2:52
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:62 build/C/man2/select_tut.2:54
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:64 build/C/man2/select_tut.2:56
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:66 build/C/man2/select_tut.2:58
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:72
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:77 build/C/man2/select_tut.2:69 build/C/man3/sockatmark.3:34
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:81 build/C/man2/select_tut.2:73
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:92
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become "
"\"ready\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform the "
"corresponding I/O operation (e.g., B<read>(2))  without blocking."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:98
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, with three "
"differences:"
msgstr ""

#. type: TP
#: build/C/man2/select.2:98
#, no-wrap
msgid "(i)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:108
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""

#. type: TP
#: build/C/man2/select.2:108
#, no-wrap
msgid "(ii)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:116
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""

#. type: TP
#: build/C/man2/select.2:116
#, no-wrap
msgid "(iii)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:125
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:143
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading "
"(more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if a write will not block, and those in I<exceptfds> will be "
"watched for exceptions.  On exit, the sets are modified in place to indicate "
"which file descriptors actually changed status.  Each of the three file "
"descriptor sets may be specified as NULL if no file descriptors are to be "
"watched for the corresponding class of events."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:156
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file "
"descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is "
"part of the set; this is useful after B<select>()  returns."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:159
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:179
msgid ""
"The I<timeout> argument specifies the minimum interval that B<select>()  "
"should block waiting for a file descriptor to become ready.  (This interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the blocking interval may overrun by a small amount.)  If "
"both fields of the I<timeval> structure are zero, then B<select>()  returns "
"immediately.  (This is useful for polling.)  If I<timeout> is NULL (no "
"timeout), B<select>()  can block indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:189
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:195
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:199
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:204
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:207
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:211
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:232
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""

#. type: SS
#: build/C/man2/select.2:232
#, no-wrap
msgid "The timeout"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:236
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:243
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:247
msgid "and"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:254
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:258
msgid "(However, see below on the POSIX.1-2001 versions.)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:266
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: build/C/man2/select.2:289
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1-2001 permits "
"either behavior.)  This causes problems both when Linux code which reads "
"I<timeout> is ported to other operating systems, and when code is ported to "
"Linux that reuses a I<struct timeval> for multiple B<select>()s in a loop "
"without reinitializing it.  Consider I<timeout> to be undefined after "
"B<select>()  returns."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:306
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set appropriately; the "
"sets and I<timeout> become undefined, so do not rely on their contents after "
"an error."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:312
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:316
msgid "A signal was caught; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:322
msgid "I<nfds> is negative or the value contained within I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:325
msgid "unable to allocate memory for internal tables."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:331
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:342
msgid ""
"B<select>()  conforms to POSIX.1-2001 and 4.4BSD (B<select>()  first "
"appeared in 4.2BSD).  Generally portable to/from non-BSD systems supporting "
"clones of the BSD socket layer (including System V variants).  However, note "
"that the System V variant typically sets the timeout variable before exit, "
"but the BSD variant does not."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:346
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:363
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:372
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1-2001 "
"situation is"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:379
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:390
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:402
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:414
msgid ""
"Libc4 and libc5 do not have a I<E<lt>sys/select.hE<gt>> header; under glibc "
"2.0 and later this header exists.  Under glibc 2.0 it unconditionally gives "
"the wrong prototype for B<pselect>().  Under glibc 2.1 to 2.2.1 it gives "
"B<pselect>()  when B<_GNU_SOURCE> is defined.  Since glibc 2.2.2 the "
"requirements are as shown in the SYNOPSIS."
msgstr ""

#. type: SS
#: build/C/man2/select.2:414
#, no-wrap
msgid "Linux Notes"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:422
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the gibc wrapper function."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:437
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:443
msgid ""
"The final argument of the B<pselect6()> system call is not a I<sigset_t\\ *> "
"pointer, but is instead a structure of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:451
#, no-wrap
msgid ""
"struct {\n"
"    const sigset_t *ss;     /* Pointer to signal set */\n"
"    size_t          ss_len; /* Size (in bytes) of object pointed\n"
"                               to by 'ss' */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:458
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:464
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:477
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:490
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: build/C/man2/select.2:506
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:521
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1-2001.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:528
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:535
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:539
#, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:543
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:546
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:554
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:557
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:561
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:573
msgid ""
"For vaguely related stuff, see B<accept>(2), B<connect>(2), B<poll>(2), "
"B<read>(2), B<recv>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<epoll>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/select_tut.2:30
#, no-wrap
msgid "SELECT_TUT"
msgstr ""

#. type: TH
#: build/C/man2/select_tut.2:30
#, no-wrap
msgid "2010-06-10"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:50
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:64
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:81
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file "
"descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:106
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared "
"using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:106
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:107
#, no-wrap
msgid "I<readfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:116
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:116
#, no-wrap
msgid "I<writefds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:125
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:125
#, no-wrap
msgid "I<exceptfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:147
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<tty_ioctl>(4).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:147
#, no-wrap
msgid "I<nfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:154
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:154
#, no-wrap
msgid "I<utimeout>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:167
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to "
"return immediately, with information about the readiness of file descriptors "
"at the time of the call.  The structure I<struct timeval> is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:174
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:176
#, no-wrap
msgid "I<ntimeout>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:185
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:192
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:194
#, no-wrap
msgid "I<sigmask>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:211
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, "
"B<pselect>()  will then behave just like B<select>()."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:211
#, no-wrap
msgid "Combining Signal and Data Events"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:255
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely.  Now, somewhere in the main loop will "
"be a conditional to check the global flag.  So we must ask: what if a signal "
"arrives after the conditional, but before the B<select>()  call? The answer "
"is that B<select>()  would block indefinitely, even though an event is "
"actually pending.  This race condition is solved by the B<pselect>()  call.  "
"This call can be used to set the signal mask to a set of signals that are "
"only to be received within the B<pselect>()  call.  For instance, let us say "
"that the event in question was the exit of a child process.  Before the "
"start of the main loop, we would block B<SIGCHLD> using B<sigprocmask>(2).  "
"Our B<pselect>()  call would enable B<SIGCHLD> by using an empty signal "
"mask.  Our program would look like:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:258
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:264
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:272
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:279
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:287
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:289
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:293
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:299
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:302
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:306
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:310
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:311
#, no-wrap
msgid "Practical"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:332
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:332
#, no-wrap
msgid "Select Law"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:345
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:354
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:358
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:365
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:371
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:371
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:386
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions only managing to send or receive a "
"single byte."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:386
#, no-wrap
msgid "6."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:394
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:394
#, no-wrap
msgid "7."
msgstr ""

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: build/C/man2/select_tut.2:416
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  as well "
"as the B<select>()  call can return -1 with I<errno> set to B<EINTR>, or "
"with I<errno> set to B<EAGAIN> (B<EWOULDBLOCK>).  These results must be "
"properly managed (not done properly above).  If your program is not going to "
"receive any signals, then it is unlikely you will get B<EINTR>.  If your "
"program does not set nonblocking I/O, you will not get B<EAGAIN>."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:416
#, no-wrap
msgid "8."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:425
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:425
#, no-wrap
msgid "9."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:441
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that "
"descriptor to B<select>()  again.  In the example below, I close the "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:441
#, no-wrap
msgid "10."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:448
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:448
#, no-wrap
msgid "11."
msgstr ""

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: build/C/man2/select_tut.2:467
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:467
#, no-wrap
msgid "Usleep Emulation"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:474
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call "
"B<select>()  with a finite timeout and no file descriptors as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:480
#, no-wrap
msgid ""
"    struct timeval tv;\n"
"    tv.tv_sec = 0;\n"
"    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"    select(0, NULL, NULL, NULL, &tv);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:483
msgid "This is only guaranteed to work on UNIX systems, however."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:488
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:494
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:501
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:510
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:519
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:527
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:532
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:545
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:547
#, no-wrap
msgid "static int forward_port;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:550
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:557
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
"    int yes;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:581
#, no-wrap
msgid ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
"    yes = 1;\n"
"    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
"            (char *) &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(listen_port);\n"
"    a.sin_family = AF_INET;\n"
"    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(s, 10);\n"
"    return s;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:587
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:593
#, no-wrap
msgid ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:597
#, no-wrap
msgid ""
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(connect_port);\n"
"    a.sin_family = AF_INET;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:603
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &a.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:612
#, no-wrap
msgid ""
"    if (connect(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(s, SHUT_RDWR);\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    return s;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:620
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:628
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:630
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:639
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail, buf1_written;\n"
"    int buf2_avail, buf2_written;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:645
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> "
"E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:647
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:649
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:653
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:657
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int r, nfds = 0;\n"
"        fd_set rd, wr, er;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:687
#, no-wrap
msgid ""
"        FD_ZERO(&rd);\n"
"        FD_ZERO(&wr);\n"
"        FD_ZERO(&er);\n"
"        FD_SET(h, &rd);\n"
"        nfds = max(nfds, h);\n"
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd1, &rd);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd2, &rd);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
"            FD_SET(fd1, &wr);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
"            FD_SET(fd2, &wr);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &er);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &er);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:689
#, no-wrap
msgid "        r = select(nfds + 1, &rd, &wr, &er, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:692
#, no-wrap
msgid ""
"        if (r == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:697
#, no-wrap
msgid ""
"        if (r == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:701
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &rd)) {\n"
"            unsigned int l;\n"
"            struct sockaddr_in client_address;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:720
#, no-wrap
msgid ""
"            memset(&client_address, 0, l = sizeof(client_address));\n"
"            r = accept(h, (struct sockaddr *) &client_address, &l);\n"
"            if (r == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = r;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_address.sin_addr));\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:722
#, no-wrap
msgid "        /* NB: read oob data before normal reads */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:726
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &er)) {\n"
"                char c;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:736
#, no-wrap
msgid ""
"                r = recv(fd1, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    send(fd2, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &er)) {\n"
"                char c;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:779
#, no-wrap
msgid ""
"                r = recv(fd2, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    send(fd1, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &rd)) {\n"
"                r = read(fd1, buf1 + buf1_avail,\n"
"                          BUF_SIZE - buf1_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf1_avail += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &rd)) {\n"
"                r = read(fd2, buf2 + buf2_avail,\n"
"                          BUF_SIZE - buf2_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf2_avail += r;\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &wr)) {\n"
"                r = write(fd1, buf2 + buf2_written,\n"
"                           buf2_avail - buf2_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf2_written += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &wr)) {\n"
"                r = write(fd2, buf1 + buf1_written,\n"
"                           buf1_avail - buf1_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf1_written += r;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:781
#, no-wrap
msgid "        /* check if write data has caught read data */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:786
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:789
#, no-wrap
msgid ""
"        /* one side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:797
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:811
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:817
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of "
"buffers\\(emone for each connection.  At the moment, new connections cause "
"the current connection to be dropped."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#: build/C/man2/select_tut.2:836
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/send.2:38
#, no-wrap
msgid "SEND"
msgstr ""

#. type: TH
#: build/C/man2/send.2:38 build/C/man7/socket.7:26
#, no-wrap
msgid "2012-04-23"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:41
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:45
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:48
#, no-wrap
msgid ""
"B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:52
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t "
">I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:55
#, no-wrap
msgid ""
"B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:63
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:82
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:84
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:86
msgid "is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:88
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:92
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:120
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:136
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:141
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:145
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:158
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""

#.  FIXME ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: build/C/man2/send.2:164
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""

#. type: TP
#: build/C/man2/send.2:164
#, no-wrap
msgid "B<MSG_CONFIRM> (Since Linux 2.3.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:178
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Only valid on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently only implemented for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man2/send.2:178
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:186
msgid ""
"Don't use a gateway to send out the packet, only send to hosts on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is only defined for protocol families that route; packet "
"sockets don't."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:197
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned (this can also be enabled using the B<O_NONBLOCK> "
"flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man2/send.2:197
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:201
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: build/C/man2/send.2:201
#, no-wrap
msgid "B<MSG_MORE> (Since Linux 2.4.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:210
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:219
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is only transmitted when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/send.2:219
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:228
msgid ""
"Requests not to send B<SIGPIPE> on errors on stream oriented sockets when "
"the other end breaks the connection.  The B<EPIPE> error is still returned."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:237
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:244
msgid ""
"The definition of the I<msghdr> structure follows.  See B<recv>(2)  and "
"below for an exact description of its fields."
msgstr ""

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#.   The flags returned in msg_flags.
#. type: Plain text
#: build/C/man2/send.2:273
msgid ""
"You may send control information using the I<msg_control> and "
"I<msg_controllen> members.  The maximum control buffer length the kernel can "
"process is limited per socket by the value in "
"I</proc/sys/net/core/optmem_max>; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:278
msgid ""
"On success, these calls return the number of characters sent.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:283
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:291
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:294
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/send.2:302
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:305
msgid "An invalid descriptor was specified."
msgstr ""

#. type: TP
#: build/C/man2/send.2:305
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:308
msgid "Connection reset by peer."
msgstr ""

#. type: TP
#: build/C/man2/send.2:308
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:311
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:314
msgid "An invalid user space address was specified for an argument."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:318
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:327
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/send.2:327
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: build/C/man2/send.2:333
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:341
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:344
msgid "No memory available."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:347
msgid "The socket is not connected, and no target has been given."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:357
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""

#. type: TP
#: build/C/man2/send.2:357
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:366
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:369
msgid "4.4BSD, SVr4, POSIX.1-2001.  These function calls appeared in 4.2BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:380
msgid ""
"POSIX.1-2001 only describes the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:393
msgid ""
"The prototypes given above follow the Single UNIX Specification, as glibc2 "
"also does; the I<flags> argument was I<int> in 4.x BSD, but I<unsigned int> "
"in libc4 and libc5; the I<len> argument was I<int> in 4.x BSD and libc4, but "
"I<size_t> in libc5; the I<addrlen> argument was I<int> in 4.x BSD and libc4 "
"and libc5.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:412
msgid ""
"See B<sendmmsg(2)> for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:417
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:422
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:437
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr ""

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "2012-02-27"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
"B<             unsigned int >I<flags>B<);>\n"
msgstr ""

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: build/C/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from "
"a single B<sendmsg>(2)  call)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#
#.      This matches the behaviour of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: build/C/man2/sendmmsg.2:145
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:150
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:153
msgid "B<sendmmsg>()  is Linux-specific."
msgstr ""

#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: build/C/man2/sendmmsg.2:168
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:173
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sockatmark.3:23
#, no-wrap
msgid "SOCKATMARK"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:26
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:28 build/C/man2/socket.2:48 build/C/man7/socket.7:31 build/C/man2/socketpair.2:47
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:30
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:39
msgid ""
"B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:49
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If "
"the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:54
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the "
"out-of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:59
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: build/C/man3/sockatmark.3:66
msgid "I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:69
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:71
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:78
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:80
msgid "Out-of-band data is only supported on some stream socket protocols."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:85
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:91
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:95
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:100
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the "
"mark:"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:105
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:112
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:115
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:122
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN) E<lt>= 0);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:129
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:135
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr ""

#. type: TH
#: build/C/man2/socket.2:41 build/C/man7/socket.7:26
#, no-wrap
msgid "SOCKET"
msgstr ""

#. type: TH
#: build/C/man2/socket.2:41
#, no-wrap
msgid "2009-01-19"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:44
msgid "socket - create an endpoint for communication"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:46 build/C/man2/socketpair.2:45
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:50
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:53
msgid "B<socket>()  creates an endpoint for communication and returns a descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:61
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The currently understood formats "
"include:"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:64
#, no-wrap
msgid "Name:Purpose:Man page\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:65 build/C/man2/socket.2:72 build/C/man2/socket.2:77 build/C/man2/socket.2:82 build/C/man2/socket.2:85 build/C/man2/socket.2:92 build/C/man2/socket.2:97 build/C/man2/socket.2:102 build/C/man2/socket.2:105 build/C/man2/socket.2:110
#, no-wrap
msgid "T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:66
#, no-wrap
msgid "B<AF_UNIX>, B<AF_LOCAL>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:67 build/C/man2/socket.2:69 build/C/man2/socket.2:87 build/C/man2/socket.2:89 build/C/man2/socket.2:99 build/C/man2/socket.2:112 build/C/man2/socket.2:114 build/C/man7/socket.7:162
#, no-wrap
msgid "T}:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "Local communication\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:70
#, no-wrap
msgid "B<unix>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:71 build/C/man2/socket.2:76 build/C/man2/socket.2:81 build/C/man2/socket.2:91 build/C/man2/socket.2:96 build/C/man2/socket.2:109 build/C/man2/socket.2:116 build/C/man7/socket.7:141 build/C/man7/socket.7:145 build/C/man7/socket.7:148 build/C/man7/socket.7:154 build/C/man7/socket.7:157 build/C/man7/socket.7:166 build/C/man7/socket.7:173
#, no-wrap
msgid "T}\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:73
#, no-wrap
msgid "B<AF_INET>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:74
#, no-wrap
msgid "T}:IPv4 Internet protocols:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:75
#, no-wrap
msgid "B<ip>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:78
#, no-wrap
msgid "B<AF_INET6>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:79
#, no-wrap
msgid "T}:IPv6 Internet protocols:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:80
#, no-wrap
msgid "B<ipv6>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:83
#, no-wrap
msgid "B<AF_IPX>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:84
#, no-wrap
msgid "T}:IPX - Novell protocols:\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:86
#, no-wrap
msgid "B<AF_NETLINK>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:88
#, no-wrap
msgid "Kernel user interface device\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:90
#, no-wrap
msgid "B<netlink>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:93
#, no-wrap
msgid "B<AF_X25>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:94
#, no-wrap
msgid "T}:ITU-T X.25 / ISO-8208 protocol:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:95
#, no-wrap
msgid "B<x25>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:98
#, no-wrap
msgid "B<AF_AX25>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:100
#, no-wrap
msgid "Amateur radio AX.25 protocol\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:101
#, no-wrap
msgid "T}:\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:103
#, no-wrap
msgid "B<AF_ATMPVC>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:104
#, no-wrap
msgid "T}:Access to raw ATM PVCs:\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:106
#, no-wrap
msgid "B<AF_APPLETALK>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:107
#, no-wrap
msgid "T}:Appletalk:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:108
#, no-wrap
msgid "B<ddp>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:111
#, no-wrap
msgid "B<AF_PACKET>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:113
#, no-wrap
msgid "Low level packet interface\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:115
#, no-wrap
msgid "B<packet>(7)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:124
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:124
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:128
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:128
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:132
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:132
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:137
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:137
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:140
msgid "Provides raw network protocol access."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:140
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:143
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:143
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:148
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:154
msgid ""
"Some socket types may not be implemented by all protocol families; for "
"example, B<SOCK_SEQPACKET> is not implemented for B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:162
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:196
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:226
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams, similar to "
"pipes.  They do not preserve record boundaries.  A stream socket must be in "
"a I<connected> state before any data may be sent or received on it.  A "
"connection to another socket is created with a B<connect>(2)  call.  Once "
"connected, data may be transferred using B<read>(2)  and B<write>(2)  calls "
"or some variant of the B<send>(2)  and B<recv>(2)  calls.  When a session "
"has been completed a B<close>(2)  may be performed.  Out-of-band data may "
"also be transmitted as described in B<send>(2)  and received as described in "
"B<recv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:252
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:262
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:269
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:292
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:302
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using a ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:312
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:317
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:322
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:325
msgid "The implementation does not support the specified address family."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:328
msgid "Unknown protocol, or protocol family not available."
msgstr ""

#.  Since Linux 2.6.27
#. type: Plain text
#: build/C/man2/socket.2:333
msgid "Invalid flags in I<type>."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:336
msgid "Process file table overflow."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:339
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:344
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:344 build/C/man2/socketpair.2:90
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:348
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:350
msgid "Other errors may be generated by the underlying protocol modules."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:352
msgid "4.4BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:358
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:364
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System V "
"variants)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:383
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<PF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:388
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:411
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), "
"B<write>(2), B<getprotoent>(3), B<ip>(7), B<socket>(7), B<tcp>(7), "
"B<udp>(7), B<unix>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:415
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq is "
"reprinted in I<UNIX Programmer's Supplementary Documents Volume 1.>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:419
msgid ""
"\\(lqBSD Interprocess Communication Tutorial\\(rq is reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:29
msgid "socket - Linux socket interface"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:33
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:52
msgid ""
"This manual page describes the Linux networking socket layer user "
"interface.  The BSD compatible sockets are the uniform interface between the "
"user process and the network protocol stacks in the kernel.  The protocol "
"modules are grouped into I<protocol families> like B<AF_INET>, B<AF_IPX>, "
"B<AF_PACKET> and I<socket types> like B<SOCK_STREAM> or B<SOCK_DGRAM>.  See "
"B<socket>(2)  for more information on families and types."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:52
#, no-wrap
msgid "Socket Layer Functions"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:56
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:72
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote "
"socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets (only "
"implemented for a few local families like B<AF_UNIX>)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:94
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), "
"B<writev>(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to "
"read and write data."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:105
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:110
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:116
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is "
"not supported on sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:133
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK> "
"flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:137
#, no-wrap
msgid "I/O events\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:138
#, no-wrap
msgid "Event:Poll flag:Occurrence\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:139 build/C/man7/socket.7:142
#, no-wrap
msgid "Read:POLLIN:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:140
#, no-wrap
msgid "New data arrived.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:143
#, no-wrap
msgid "A connection setup has been completed\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:144
#, no-wrap
msgid "(for connection-oriented sockets)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:146 build/C/man7/socket.7:149
#, no-wrap
msgid "Read:POLLHUP:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:147
#, no-wrap
msgid "A disconnection request has been initiated by the other end.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:150
#, no-wrap
msgid "A connection is broken (only for connection-oriented protocols).\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:151
#, no-wrap
msgid "When the socket is written\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:152
#, no-wrap
msgid "B<SIGPIPE>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:153
#, no-wrap
msgid "is also sent.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:155
#, no-wrap
msgid "Write:POLLOUT:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:156
#, no-wrap
msgid "Socket has enough send buffer space for writing new data.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:158
#, no-wrap
msgid "Read/Write:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:159
#, no-wrap
msgid "POLLIN|\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:160
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:161
#, no-wrap
msgid "POLLOUT\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:163
#, no-wrap
msgid "An outgoing\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:164
#, no-wrap
msgid "B<connect>(2)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:165
#, no-wrap
msgid "finished.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:167
#, no-wrap
msgid "Read/Write:POLLERR:An asynchronous error occurred.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:168
#, no-wrap
msgid "Read/Write:POLLHUP:The other end has shut down one direction.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:169
#, no-wrap
msgid "Exception:POLLPRI:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:170
#, no-wrap
msgid "Urgent data arrived.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:171
#, no-wrap
msgid "B<SIGURG>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:172
#, no-wrap
msgid "is sent then.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:202
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC> "
"flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:202
#, no-wrap
msgid "Socket Options"
msgstr ""

#.  FIXME
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: build/C/man7/socket.7:216
msgid ""
"These socket options can be set by using B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for all "
"sockets:"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:216
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:224
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:224
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:243
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in "
"the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this only works for some socket types, particularly B<AF_INET> "
"sockets.  It is not supported for packet sockets (use normal B<bind>(2)  "
"there)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:243
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:249
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on "
"stream-oriented sockets."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:249
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:261
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random "
"header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:261
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:267
msgid ""
"Enable socket debugging.  Only allowed for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:267
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:275
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:275
#, no-wrap
msgid "B<SO_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:280
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:280
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:289
msgid ""
"Don't send via a gateway, only send to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:289
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:293
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:293
#, no-wrap
msgid "B<SO_LINGER>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:301
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:308
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:322
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:322
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr ""

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#. type: Plain text
#: build/C/man7/socket.7:331
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise out-of-band data is only passed when the "
"B<MSG_OOB> flag is set during receiving."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:331
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr ""

#.  FIXME Document SO_PASSSEC, added in 2.6.18; there is some info
#.  in the 2.6.18 ChangeLog
#. type: Plain text
#: build/C/man7/socket.7:340
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:340
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:360
msgid ""
"Return the credentials of the foreign process connected to this socket.  "
"This is only possible for connected B<AF_UNIX> stream sockets and B<AF_UNIX> "
"stream and datagram socket pairs created using B<socketpair>(2); see "
"B<unix>(7).  The returned credentials are those that were in effect at the "
"time of the call to B<connect>(2)  or B<socketpair>(2).  Argument is a "
"I<ucred> structure.  This socket option is read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:360
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:373
msgid ""
"Set the protocol-defined priority for all packets to be sent on this "
"socket.  Linux uses this value to order the networking queues: packets with "
"a higher priority may be processed first depending on the selected device "
"queueing discipline.  For B<ip>(7), this also sets the IP type-of-service "
"(TOS) field for outgoing packets.  Setting a priority outside the range 0 to "
"6 requires the B<CAP_NET_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:373
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:381
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:381
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr ""

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#. type: Plain text
#: build/C/man7/socket.7:396
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and "
"the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:396
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:405
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:405
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr ""

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=111049368106984&w=2
#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#. type: Plain text
#: build/C/man7/socket.7:434
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4.  "
"The B<select>(2)  and B<poll>(2)  system calls currently do not respect the "
"B<SO_RCVLOWAT> setting on Linux, and mark a socket readable when even a "
"single byte of data is available.  A subsequent read from the socket will "
"block until B<SO_RCVLOWAT> bytes are available."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:434
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr ""

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: build/C/man7/socket.7:465
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of "
"that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK> just as if the socket was "
"specified to be nonblocking.  If the timeout is set to zero (the default)  "
"then the operation will never timeout.  Timeouts only have effect for system "
"calls that perform socket I/O (e.g., B<read>(2), B<recvmsg>(2), B<send>(2), "
"B<sendmsg>(2)); timeouts have no effect for B<select>(2), B<poll>(2), "
"B<epoll_wait>(2), and so on."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:465
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:480
msgid ""
"Indicates that the rules used in validating addresses supplied in a "
"B<bind>(2)  call should allow reuse of local addresses.  For B<AF_INET> "
"sockets this means that a socket may bind, except when there is an active "
"listening socket bound to the address.  When the listening socket is bound "
"to B<INADDR_ANY> with a specific port then it is not possible to bind to "
"this port for any local address.  Argument is an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:480
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr ""

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#. type: Plain text
#: build/C/man7/socket.7:495
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> "
"file.  The minimum (doubled) value for this option is 2048."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:495
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:504
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:504
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:520
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The "
"timestamp control message is sent with level B<SOL_SOCKET> and the "
"I<cmsg_data> field is a I<struct timeval> indicating the reception time of "
"the last packet passed to the user in this call.  See B<cmsg>(3)  for "
"details on control messages."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:520
#, no-wrap
msgid "B<SO_TYPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:525
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:525
#, no-wrap
msgid "Signals"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:536
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:561
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> "
"B<ioctl>(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to "
"use B<poll>(2)  or B<select>(2)  in the signal handler to find out which "
"socket the event occurred on.  An alternative (in Linux 2.2) is to set a "
"real-time signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real "
"time signal will be called with the file descriptor in the I<si_fd> field of "
"its I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr ""

#.  .SS Ancillary Messages
#. type: Plain text
#: build/C/man7/socket.7:569
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared "
"when the process reacts to the signal.  If this happens, the process should "
"wait again because Linux will resend the signal later."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:569
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:573
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:573
#, no-wrap
msgid "I<rmem_default>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:576
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:576
#, no-wrap
msgid "I<rmem_max>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:582
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:582
#, no-wrap
msgid "I<wmem_default>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:585
msgid "contains the default setting in bytes of the socket send buffer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:585
#, no-wrap
msgid "I<wmem_max>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:591
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:591
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:595
msgid ""
"configure the token bucket filter used to load limit warning messages caused "
"by external network events."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:595
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:598
msgid "Maximum number of packets in the global input queue."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:598
#, no-wrap
msgid "I<optmem_max>"
msgstr ""

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: build/C/man7/socket.7:603
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:603
#, no-wrap
msgid "Ioctls"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:606
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:610
#, no-wrap
msgid ""
"I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, "
">I<&value_result>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:612
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:636
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>.  "
"This ioctl should only be used if the socket option B<SO_TIMESTAMP> is not "
"set on the socket.  Otherwise, it returns the timestamp of the last packet "
"that was received while B<SO_TIMESTAMP> was not set, or it fails if no such "
"packet has been received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set "
"to B<ENOENT>)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:636
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:655
msgid ""
"Set the process or process group to send B<SIGIO> or B<SIGURG> signals to "
"when an asynchronous I/O operation has finished or urgent data is "
"available.  The argument is a pointer to a I<pid_t>.  If the argument is "
"positive, send the signals to that process.  If the argument is negative, "
"send the signals to the process group with the ID of the absolute value of "
"the argument.  The process may only choose itself or its own process group "
"to receive signals unless it has the B<CAP_KILL> capability or an effective "
"UID of 0."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:655
#, no-wrap
msgid "B<FIOASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:665
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the "
"socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal "
"set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:673
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the "
"use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:673
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:682
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG> "
"signals, or 0 when none is set."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:686
msgid "Valid B<fcntl>(2)  operations:"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:686
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:691
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:691
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:696
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:710
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in "
"Linux 2.2.  The I</proc> interfaces was introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:715
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:728
msgid ""
"Linux will only allow port reuse with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from "
"some implementations (e.g., FreeBSD)  where only the later program needs to "
"set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr ""

#.  FIXME Document SO_ATTACH_FILTER and SO_DETACH_FILTER
#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/socket.7:741
msgid ""
"The B<CONFIG_FILTER> socket options B<SO_ATTACH_FILTER> and "
"B<SO_DETACH_FILTER> are not documented.  The suggested interface to use them "
"is via the libpcap library."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:752
msgid ""
"B<getsockopt>(2), B<setsockopt>(2), B<socket>(2), B<capabilities>(7), "
"B<ddp>(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/socketcall.2:26
#, no-wrap
msgid "SOCKETCALL"
msgstr ""

#. type: TH
#: build/C/man2/socketcall.2:26
#, no-wrap
msgid "2007-06-28"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:29
msgid "socketcall - socket system calls"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:31
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:39
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:43
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:46
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:54
msgid ""
"On a few architectures, for example ia64, there is no B<socketcall>()  "
"system call; instead B<socket>(2), B<accept>(2), B<bind>(2), and so on "
"really are implemented as separate system calls."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:72
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr ""

#. type: TH
#: build/C/man2/socketpair.2:40
#, no-wrap
msgid "SOCKETPAIR"
msgstr ""

#. type: TH
#: build/C/man2/socketpair.2:40
#, no-wrap
msgid "2008-10-11"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:43
msgid "socketpair - create a pair of connected sockets"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:50
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:61
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:67
msgid ""
"The descriptors used in referencing the new sockets are returned in I<sv>[0] "
"and I<sv>[1].  The two sockets are indistinguishable."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:76
msgid "The specified address family is not supported on this machine."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:81
msgid ""
"The address I<sv> does not specify a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:84
msgid "Too many descriptors are in use by this process."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:90
msgid "The specified protocol does not support creation of socket pairs."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:93
msgid "The specified protocol is not supported on this machine."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:101
msgid ""
"4.4BSD, POSIX.1-2001.  The B<socketpair>()  function call appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System V variants)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:107
msgid ""
"On Linux, the only supported domain for this call is B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>).  (Most implementations have the same "
"restriction.)"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:116
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags described in B<socket>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:129
msgid "B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""

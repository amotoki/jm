# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-07-15 16:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/accept.2:41
#, no-wrap
msgid "ACCEPT"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:41
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/bind.2:68 build/C/man2/connect.2:67 build/C/man2/getsockname.2:40 build/C/man2/getsockopt.2:44 build/C/man2/listen.2:45 build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31 build/C/man2/select.2:38 build/C/man2/select_tut.2:32 build/C/man2/send.2:40 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25 build/C/man2/socket.2:43 build/C/man7/socket.7:45 build/C/man2/socketcall.2:25 build/C/man2/socketpair.2:42
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/accept.2:41 build/C/man2/bind.2:68 build/C/man3/bindresvport.3:30 build/C/man2/connect.2:67 build/C/man3/getifaddrs.3:36 build/C/man2/getsockname.2:40 build/C/man2/getsockopt.2:44 build/C/man3/if_nameindex.3:26 build/C/man3/if_nametoindex.3:25 build/C/man2/listen.2:45 build/C/man2/recv.2:41 build/C/man2/recvmmsg.2:31 build/C/man2/select.2:38 build/C/man2/select_tut.2:32 build/C/man2/send.2:40 build/C/man2/sendmmsg.2:28 build/C/man3/sockatmark.3:25 build/C/man2/socket.2:43 build/C/man7/socket.7:45 build/C/man2/socketcall.2:25 build/C/man2/socketpair.2:42
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:42 build/C/man2/bind.2:69 build/C/man3/bindresvport.3:31 build/C/man2/connect.2:68 build/C/man3/getifaddrs.3:37 build/C/man2/getsockname.2:41 build/C/man2/getsockopt.2:45 build/C/man3/if_nameindex.3:27 build/C/man3/if_nametoindex.3:26 build/C/man2/listen.2:46 build/C/man2/recv.2:42 build/C/man2/recvmmsg.2:32 build/C/man2/select.2:39 build/C/man2/select_tut.2:33 build/C/man2/send.2:41 build/C/man2/sendmmsg.2:29 build/C/man3/sockatmark.3:26 build/C/man2/socket.2:44 build/C/man7/socket.7:46 build/C/man2/socketcall.2:26 build/C/man2/socketpair.2:43
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:44
msgid "accept, accept4 - accept a connection on a socket"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:44 build/C/man2/bind.2:71 build/C/man3/bindresvport.3:33 build/C/man2/connect.2:70 build/C/man3/getifaddrs.3:39 build/C/man2/getsockname.2:43 build/C/man2/getsockopt.2:47 build/C/man3/if_nameindex.3:29 build/C/man3/if_nametoindex.3:29 build/C/man2/listen.2:48 build/C/man2/recv.2:44 build/C/man2/recvmmsg.2:34 build/C/man2/select.2:42 build/C/man2/select_tut.2:36 build/C/man2/send.2:43 build/C/man2/sendmmsg.2:31 build/C/man3/sockatmark.3:28 build/C/man2/socket.2:46 build/C/man7/socket.7:48 build/C/man2/socketcall.2:28 build/C/man2/socketpair.2:45
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:48 build/C/man2/bind.2:75
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:50
#, no-wrap
msgid ""
"B<int accept(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:53
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:56
#, no-wrap
msgid ""
"B<int accept4(int >I<sockfd>B<, struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t *>I<addrlen>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:57 build/C/man2/bind.2:79 build/C/man3/bindresvport.3:40 build/C/man2/connect.2:79 build/C/man3/getifaddrs.3:48 build/C/man2/getsockname.2:50 build/C/man2/getsockopt.2:58 build/C/man3/if_nameindex.3:36 build/C/man3/if_nametoindex.3:37 build/C/man2/listen.2:56 build/C/man2/recv.2:59 build/C/man2/recvmmsg.2:44 build/C/man2/select.2:81 build/C/man2/select_tut.2:75 build/C/man2/send.2:58 build/C/man2/sendmmsg.2:40 build/C/man3/sockatmark.3:42 build/C/man2/socket.2:52 build/C/man7/socket.7:52 build/C/man2/socketcall.2:30 build/C/man2/socketpair.2:52
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:72
msgid ""
"The B<accept>()  system call is used with connection-based socket types "
"(B<SOCK_STREAM>, B<SOCK_SEQPACKET>).  It extracts the first connection "
"request on the queue of pending connections for the listening socket, "
"I<sockfd>, creates a new connected socket, and returns a new file descriptor "
"referring to that socket.  The newly created socket is not in the listening "
"state.  The original socket I<sockfd> is unaffected by this call."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:81
msgid ""
"The argument I<sockfd> is a socket that has been created with B<socket>(2), "
"bound to a local address with B<bind>(2), and is listening for connections "
"after a B<listen>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:99
msgid ""
"The argument I<addr> is a pointer to a I<sockaddr> structure.  This "
"structure is filled in with the address of the peer socket, as known to the "
"communications layer.  The exact format of the address returned I<addr> is "
"determined by the socket's address family (see B<socket>(2)  and the "
"respective protocol man pages).  When I<addr> is NULL, nothing is filled in; "
"in this case, I<addrlen> is not used, and should also be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:107
msgid ""
"The I<addrlen> argument is a value-result argument: the caller must "
"initialize it to contain the size (in bytes) of the structure pointed to by "
"I<addr>; on return it will contain the actual size of the peer address."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:112 build/C/man2/getsockname.2:67
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:125
msgid ""
"If no pending connections are present on the queue, and the socket is not "
"marked as nonblocking, B<accept>()  blocks the caller until a connection is "
"present.  If the socket is marked nonblocking and no pending connections are "
"present on the queue, B<accept>()  fails with the error B<EAGAIN> or "
"B<EWOULDBLOCK>."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:139
msgid ""
"In order to be notified of incoming connections on a socket, you can use "
"B<select>(2)  or B<poll>(2).  A readable event will be delivered when a new "
"connection is attempted and you may then call B<accept>()  to get a socket "
"for that connection.  Alternatively, you can set the socket to deliver "
"B<SIGIO> when activity occurs on a socket; see B<socket>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:152
msgid ""
"For certain protocols which require an explicit confirmation, such as "
"DECNet, B<accept>()  can be thought of as merely dequeuing the next "
"connection request and not implying confirmation.  Confirmation can be "
"implied by a normal read or write on the new file descriptor, and rejection "
"can be implied by closing the new socket.  Currently only DECNet has these "
"semantics on Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:162
msgid ""
"If I<flags> is 0, then B<accept4>()  is the same as B<accept>().  The "
"following values can be bitwise ORed in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:162 build/C/man2/socket.2:164
#, no-wrap
msgid "B<SOCK_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:170 build/C/man2/socket.2:172
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same "
"result."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:170 build/C/man2/socket.2:172
#, no-wrap
msgid "B<SOCK_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:180 build/C/man2/socket.2:182
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:180 build/C/man2/bind.2:152 build/C/man3/bindresvport.3:67 build/C/man2/connect.2:127 build/C/man3/getifaddrs.3:142 build/C/man2/getsockname.2:67 build/C/man2/getsockopt.2:131 build/C/man3/if_nameindex.3:71 build/C/man3/if_nametoindex.3:54 build/C/man2/listen.2:82 build/C/man2/recv.2:388 build/C/man2/recvmmsg.2:149 build/C/man2/select.2:289 build/C/man2/select_tut.2:485 build/C/man2/send.2:275 build/C/man2/sendmmsg.2:119 build/C/man3/sockatmark.3:51 build/C/man2/socket.2:314 build/C/man2/socketpair.2:69
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:187
msgid ""
"On success, these system calls return a nonnegative integer that is a "
"descriptor for the accepted socket.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: SS
#: build/C/man2/accept.2:187
#, no-wrap
msgid "Error handling"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:214
msgid ""
"Linux B<accept>()  (and B<accept4>())  passes already-pending network errors "
"on the new socket as an error code from B<accept>().  This behavior differs "
"from other BSD socket implementations.  For reliable operation the "
"application should detect the network errors defined for the protocol after "
"B<accept>()  and treat them like B<EAGAIN> by retrying.  In the case of "
"TCP/IP, these are B<ENETDOWN>, B<EPROTO>, B<ENOPROTOOPT>, B<EHOSTDOWN>, "
"B<ENONET>, B<EHOSTUNREACH>, B<EOPNOTSUPP>, and B<ENETUNREACH>."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:214 build/C/man2/bind.2:157 build/C/man3/bindresvport.3:72 build/C/man2/connect.2:132 build/C/man3/getifaddrs.3:149 build/C/man2/getsockname.2:72 build/C/man2/getsockopt.2:136 build/C/man3/if_nameindex.3:78 build/C/man3/if_nametoindex.3:69 build/C/man2/listen.2:87 build/C/man2/recv.2:396 build/C/man2/recvmmsg.2:157 build/C/man2/select.2:306 build/C/man2/send.2:280 build/C/man2/sendmmsg.2:133 build/C/man3/sockatmark.3:58 build/C/man2/socket.2:319 build/C/man2/socketpair.2:74
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:215 build/C/man2/recv.2:401 build/C/man2/send.2:296
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/accept.2:223
msgid ""
"The socket is marked nonblocking and no connections are present to be "
"accepted.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:223 build/C/man2/bind.2:165 build/C/man2/connect.2:169 build/C/man2/getsockname.2:73 build/C/man2/getsockopt.2:137 build/C/man2/listen.2:91 build/C/man2/recv.2:410 build/C/man2/select.2:307 build/C/man2/send.2:304 build/C/man3/sockatmark.3:59
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:226
msgid "The descriptor is invalid."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:226
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:229
msgid "A connection has been aborted."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:229 build/C/man2/bind.2:191 build/C/man2/connect.2:175 build/C/man2/getsockname.2:78 build/C/man2/getsockopt.2:142 build/C/man2/recv.2:419 build/C/man2/send.2:313 build/C/man2/socketpair.2:78
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:234
msgid "The I<addr> argument is not in a writable part of the user address space."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:234 build/C/man2/connect.2:203 build/C/man2/recv.2:423 build/C/man2/select.2:312 build/C/man2/send.2:316
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:239
msgid ""
"The system call was interrupted by a signal that was caught before a valid "
"connection arrived; see B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:239 build/C/man2/accept.2:244 build/C/man2/bind.2:169 build/C/man2/bind.2:195 build/C/man2/getsockname.2:84 build/C/man2/getsockopt.2:152 build/C/man2/recv.2:428 build/C/man2/recvmmsg.2:161 build/C/man2/select.2:316 build/C/man2/send.2:320 build/C/man3/sockatmark.3:63 build/C/man2/socket.2:327 build/C/man2/socket.2:330
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:244
msgid ""
"Socket is not listening for connections, or I<addrlen> is invalid (e.g., is "
"negative)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:249
msgid "(B<accept4>())  invalid value in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:249 build/C/man2/socket.2:335 build/C/man2/socketpair.2:83
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:252
msgid "The per-process limit of open file descriptors has been reached."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:252 build/C/man2/socket.2:338 build/C/man2/socketpair.2:86
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:255 build/C/man2/socket.2:341 build/C/man2/socketpair.2:89
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:255
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:260
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:260 build/C/man2/bind.2:174 build/C/man2/connect.2:215 build/C/man2/getsockname.2:92 build/C/man2/getsockopt.2:166 build/C/man2/listen.2:96 build/C/man2/recv.2:443 build/C/man2/send.2:349
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:263
msgid "The descriptor references a file, not a socket."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:263 build/C/man2/listen.2:101 build/C/man2/send.2:354 build/C/man2/socketpair.2:89
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:267
msgid "The referenced socket is not of type B<SOCK_STREAM>."
msgstr ""

#. type: TP
#: build/C/man2/accept.2:267
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:270
msgid "Protocol error."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:274
msgid "In addition, Linux B<accept>()  may fail if:"
msgstr ""

#. type: TP
#: build/C/man2/accept.2:274
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:277
msgid "Firewall rules forbid connection."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:289
msgid ""
"In addition, network errors for the new socket and as defined for the "
"protocol may be returned.  Various Linux kernels can return other errors "
"such as B<ENOSR>, B<ESOCKTNOSUPPORT>, B<EPROTONOSUPPORT>, B<ETIMEDOUT>.  The "
"value B<ERESTARTSYS> may be seen during a trace."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:289 build/C/man3/getifaddrs.3:162 build/C/man3/if_nameindex.3:97 build/C/man2/recvmmsg.2:165 build/C/man2/select.2:325 build/C/man2/sendmmsg.2:145 build/C/man3/sockatmark.3:70 build/C/man7/socket.7:868
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:294
msgid ""
"The B<accept4>()  system call is available starting with Linux 2.6.28; "
"support in glibc is available starting with version 2.10."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:294 build/C/man2/bind.2:222 build/C/man3/bindresvport.3:104 build/C/man2/connect.2:225 build/C/man3/getifaddrs.3:170 build/C/man2/getsockname.2:97 build/C/man2/getsockopt.2:171 build/C/man3/if_nameindex.3:104 build/C/man3/if_nametoindex.3:85 build/C/man2/listen.2:106 build/C/man2/recv.2:448 build/C/man2/recvmmsg.2:170 build/C/man2/select.2:331 build/C/man2/send.2:368 build/C/man2/sendmmsg.2:150 build/C/man3/sockatmark.3:73 build/C/man2/socket.2:352 build/C/man2/socketcall.2:42 build/C/man2/socketpair.2:95
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#.  The BSD man page documents five possible error returns
#.  (EBADF, ENOTSOCK, EOPNOTSUPP, EWOULDBLOCK, EFAULT).
#.  POSIX.1-2001 documents errors
#.  EAGAIN, EBADF, ECONNABORTED, EINTR, EINVAL, EMFILE,
#.  ENFILE, ENOBUFS, ENOMEM, ENOTSOCK, EOPNOTSUPP, EPROTO, EWOULDBLOCK.
#.  In addition, SUSv2 documents EFAULT and ENOSR.
#. type: Plain text
#: build/C/man2/accept.2:306
msgid ""
"B<accept>(): POSIX.1-2001, SVr4, 4.4BSD, (B<accept>()  first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:309
msgid "B<accept4>()  is a nonstandard Linux extension."
msgstr ""

#.  Some testing seems to show that Tru64 5.1 and HP-UX 11 also
#.  do not inherit file status flags -- MTK Jun 05
#. type: Plain text
#: build/C/man2/accept.2:324
msgid ""
"On Linux, the new socket returned by B<accept>()  does I<not> inherit file "
"status flags such as B<O_NONBLOCK> and B<O_ASYNC> from the listening "
"socket.  This behavior differs from the canonical BSD sockets "
"implementation.  Portable programs should not rely on inheritance or "
"noninheritance of file status flags and always explicitly set all required "
"flags on the socket returned from B<accept>()."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:324 build/C/man2/bind.2:234 build/C/man3/bindresvport.3:107 build/C/man2/connect.2:241 build/C/man3/getifaddrs.3:190 build/C/man2/getsockname.2:103 build/C/man2/getsockopt.2:178 build/C/man2/listen.2:111 build/C/man2/recv.2:458 build/C/man2/select.2:346 build/C/man2/select_tut.2:503 build/C/man2/send.2:382 build/C/man2/sendmmsg.2:153 build/C/man3/sockatmark.3:75 build/C/man2/socket.2:366 build/C/man7/socket.7:882 build/C/man2/socketcall.2:45 build/C/man2/socketpair.2:103
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:330 build/C/man2/bind.2:240 build/C/man2/connect.2:247 build/C/man2/getsockopt.2:184 build/C/man2/listen.2:137 build/C/man2/socket.2:372 build/C/man2/socketpair.2:124
msgid ""
"POSIX.1-2001 does not require the inclusion of I<E<lt>sys/types.hE<gt>>, and "
"this header file is not required on Linux.  However, some historical (BSD) "
"implementations required this header file, and portable applications are "
"probably wise to include it."
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:351
msgid ""
"There may not always be a connection waiting after a B<SIGIO> is delivered "
"or B<select>(2)  or B<poll>(2)  return a readability event because the "
"connection might have been removed by an asynchronous network error or "
"another thread before B<accept>()  is called.  If this happens then the call "
"will block waiting for the next connection to arrive.  To ensure that "
"B<accept>()  never blocks, the passed socket I<sockfd> needs to have the "
"B<O_NONBLOCK> flag set (see B<socket>(7))."
msgstr ""

#. type: SS
#: build/C/man2/accept.2:351
#, no-wrap
msgid "The socklen_t type"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:361
msgid ""
"The third argument of B<accept>()  was originally declared as an I<int *> "
"(and is that under libc4 and libc5 and on many other systems like 4.x BSD, "
"SunOS 4, SGI); a POSIX.1g draft standard wanted to change it into a I<size_t "
"*>, and that is what it is for SunOS 5.  Later POSIX drafts have I<socklen_t "
"*>, and so do the Single UNIX Specification and glibc2.  Quoting Linus "
"Torvalds:"
msgstr ""

#.  .I fails: only italicizes a single line
#. type: Plain text
#: build/C/man2/accept.2:378
msgid ""
"\"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.  "
"Anything else breaks any BSD socket layer stuff.  POSIX initially I<did> "
"make it a size_t, and I (and hopefully others, but obviously not too many) "
"complained to them very loudly indeed.  Making it a size_t is completely "
"broken, exactly because size_t very seldom is the same size as \"int\" on "
"64-bit architectures, for example.  And it I<has> to be the same size as "
"\"int\" because that's what the BSD socket interface is.  Anyway, the POSIX "
"people eventually got a clue, and created \"socklen_t\".  They shouldn't "
"have touched it in the first place, but once they did they felt it had to "
"have a named type for some unfathomable reason (probably somebody didn't "
"like losing face over having done the original stupid thing, so they "
"silently just renamed their blunder).\""
msgstr ""

#. type: SH
#: build/C/man2/accept.2:378 build/C/man2/bind.2:254 build/C/man2/connect.2:258 build/C/man3/getifaddrs.3:207 build/C/man3/if_nameindex.3:108 build/C/man2/listen.2:166 build/C/man2/recv.2:493 build/C/man2/recvmmsg.2:173 build/C/man2/select.2:537 build/C/man2/select_tut.2:529 build/C/man2/send.2:419 build/C/man2/sendmmsg.2:168 build/C/man3/sockatmark.3:99 build/C/man2/socket.2:385
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:381 build/C/man2/listen.2:169
msgid "See B<bind>(2)."
msgstr ""

#. type: SH
#: build/C/man2/accept.2:381 build/C/man2/bind.2:319 build/C/man3/bindresvport.3:113 build/C/man2/connect.2:263 build/C/man3/getifaddrs.3:290 build/C/man2/getsockname.2:114 build/C/man2/getsockopt.2:202 build/C/man3/if_nameindex.3:146 build/C/man3/if_nametoindex.3:89 build/C/man2/listen.2:169 build/C/man2/recv.2:498 build/C/man2/recvmmsg.2:268 build/C/man2/select.2:574 build/C/man2/select_tut.2:819 build/C/man2/send.2:424 build/C/man2/sendmmsg.2:236 build/C/man3/sockatmark.3:134 build/C/man2/socket.2:390 build/C/man7/socket.7:913 build/C/man2/socketcall.2:53 build/C/man2/socketpair.2:124
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:388
msgid ""
"B<bind>(2), B<connect>(2), B<listen>(2), B<select>(2), B<socket>(2), "
"B<socket>(7)"
msgstr ""

#. type: SH
#: build/C/man2/accept.2:388 build/C/man2/bind.2:332 build/C/man3/bindresvport.3:116 build/C/man2/connect.2:270 build/C/man3/getifaddrs.3:296 build/C/man2/getsockname.2:121 build/C/man2/getsockopt.2:210 build/C/man3/if_nameindex.3:153 build/C/man3/if_nametoindex.3:93 build/C/man2/listen.2:175 build/C/man2/recv.2:509 build/C/man2/recvmmsg.2:275 build/C/man2/select.2:588 build/C/man2/select_tut.2:838 build/C/man2/send.2:439 build/C/man2/sendmmsg.2:241 build/C/man3/sockatmark.3:139 build/C/man2/socket.2:419 build/C/man7/socket.7:925 build/C/man2/socketcall.2:71 build/C/man2/socketpair.2:131
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/accept.2:395 build/C/man2/bind.2:339 build/C/man3/bindresvport.3:123 build/C/man2/connect.2:277 build/C/man3/getifaddrs.3:303 build/C/man2/getsockname.2:128 build/C/man2/getsockopt.2:217 build/C/man3/if_nameindex.3:160 build/C/man3/if_nametoindex.3:100 build/C/man2/listen.2:182 build/C/man2/recv.2:516 build/C/man2/recvmmsg.2:282 build/C/man2/select.2:595 build/C/man2/select_tut.2:845 build/C/man2/send.2:446 build/C/man2/sendmmsg.2:248 build/C/man3/sockatmark.3:146 build/C/man2/socket.2:426 build/C/man7/socket.7:932 build/C/man2/socketcall.2:78 build/C/man2/socketpair.2:138
msgid ""
"This page is part of release 3.52 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/bind.2:68
#, no-wrap
msgid "BIND"
msgstr ""

#. type: TH
#: build/C/man2/bind.2:68
#, no-wrap
msgid "2007-12-28"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:71
msgid "bind - bind a name to a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:78
#, no-wrap
msgid ""
"B<int bind(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<         socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:92
msgid ""
"When a socket is created with B<socket>(2), it exists in a name space "
"(address family) but has no address assigned to it.  B<bind>()  assigns the "
"address specified by I<addr> to the socket referred to by the file "
"descriptor I<sockfd>.  I<addrlen> specifies the size, in bytes, of the "
"address structure pointed to by I<addr>.  Traditionally, this operation is "
"called \\(lqassigning a name to a socket\\(rq."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:99
msgid ""
"It is normally necessary to assign a local address using B<bind>()  before a "
"B<SOCK_STREAM> socket may receive connections (see B<accept>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:130
msgid ""
"The rules used in name binding vary between address families.  Consult the "
"manual entries in Section 7 for detailed information.  For B<AF_INET> see "
"B<ip>(7), for B<AF_INET6> see B<ipv6>(7), for B<AF_UNIX> see B<unix>(7), for "
"B<AF_APPLETALK> see B<ddp>(7), for B<AF_PACKET> see B<packet>(7), for "
"B<AF_X25> see B<x25>(7)  and for B<AF_NETLINK> see B<netlink>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:137
msgid ""
"The actual structure passed for the I<addr> argument will depend on the "
"address family.  The I<sockaddr> structure is defined as something like:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:144
#, no-wrap
msgid ""
"struct sockaddr {\n"
"    sa_family_t sa_family;\n"
"    char        sa_data[14];\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:152
msgid ""
"The only purpose of this structure is to cast the structure pointer passed "
"in I<addr> in order to avoid compiler warnings.  See EXAMPLE below."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:157 build/C/man2/getsockname.2:72 build/C/man2/getsockopt.2:136 build/C/man2/listen.2:87 build/C/man2/socketpair.2:74
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:158 build/C/man2/bind.2:182 build/C/man3/bindresvport.3:77 build/C/man2/connect.2:135 build/C/man2/send.2:285 build/C/man2/socket.2:320
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  e.g., privileged port in AF_INET domain
#. type: Plain text
#: build/C/man2/bind.2:162
msgid "The address is protected, and the user is not the superuser."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:162 build/C/man3/bindresvport.3:82 build/C/man2/connect.2:148 build/C/man2/listen.2:88
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:165
msgid "The given address is already in use."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:169
msgid "I<sockfd> is not a valid descriptor."
msgstr ""

#.  This may change in the future: see
#.  .I linux/unix/sock.c for details.
#. type: Plain text
#: build/C/man2/bind.2:174
msgid "The socket is already bound to an address."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:178
msgid "I<sockfd> is a descriptor for a file, not a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:182
msgid "The following errors are specific to UNIX domain (B<AF_UNIX>)  sockets:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:187
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/bind.2:187
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:191
msgid ""
"A nonexistent interface was requested or the requested address was not "
"local."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:195
msgid "I<addr> points outside the user's accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:202
msgid "The I<addrlen> is wrong, or the socket was not in the B<AF_UNIX> family."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:202
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:206
msgid "Too many symbolic links were encountered in resolving I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:206
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:210
msgid "I<addr> is too long."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:210
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:213
msgid "The file does not exist."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:213 build/C/man2/recv.2:432 build/C/man2/select.2:322 build/C/man2/send.2:343
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:216
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:216
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:219
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/bind.2:219
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:222
msgid "The socket inode would reside on a read-only file system."
msgstr ""

#.  SVr4 documents an additional
#.  .B ENOSR
#.  general error condition, and
#.  additional
#.  .B EIO
#.  and
#.  .B EISDIR
#.  UNIX-domain error conditions.
#. type: Plain text
#: build/C/man2/bind.2:234
msgid "SVr4, 4.4BSD, POSIX.1-2001 (B<bind>()  first appeared in 4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:251
msgid ""
"The third argument of B<bind>()  is in reality an I<int> (and this is what "
"4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in the "
"present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: SH
#: build/C/man2/bind.2:251 build/C/man2/getsockopt.2:199 build/C/man2/select.2:474 build/C/man2/send.2:414 build/C/man3/sockatmark.3:95 build/C/man7/socket.7:900
#, no-wrap
msgid "BUGS"
msgstr ""

#.  FIXME What *are* transparent proxy options?
#. type: Plain text
#: build/C/man2/bind.2:254
msgid "The transparent proxy options are not described."
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:259
msgid ""
"An example of the use of B<bind>()  with Internet domain sockets can be "
"found in B<getaddrinfo>(3)."
msgstr ""

#.  listen.7 refers to this example.
#.  accept.7 refers to this example.
#.  unix.7 refers to this example.
#. type: Plain text
#: build/C/man2/bind.2:266
msgid ""
"The following example shows how to bind a stream socket in the UNIX "
"(B<AF_UNIX>)  domain, and accept connections:"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:273
#, no-wrap
msgid ""
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>sys/un.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:276
#, no-wrap
msgid ""
"#define MY_SOCK_PATH \"/somepath\"\n"
"#define LISTEN_BACKLOG 50\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:279
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:286
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int sfd, cfd;\n"
"    struct sockaddr_un my_addr, peer_addr;\n"
"    socklen_t peer_addr_size;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:290
#, no-wrap
msgid ""
"    sfd = socket(AF_UNIX, SOCK_STREAM, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"socket\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:296
#, no-wrap
msgid ""
"    memset(&my_addr, 0, sizeof(struct sockaddr_un));\n"
"                        /* Clear structure */\n"
"    my_addr.sun_family = AF_UNIX;\n"
"    strncpy(my_addr.sun_path, MY_SOCK_PATH,\n"
"            sizeof(my_addr.sun_path) - 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:300
#, no-wrap
msgid ""
"    if (bind(sfd, (struct sockaddr *) &my_addr,\n"
"            sizeof(struct sockaddr_un)) == -1)\n"
"        handle_error(\"bind\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:303
#, no-wrap
msgid ""
"    if (listen(sfd, LISTEN_BACKLOG) == -1)\n"
"        handle_error(\"listen\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:306
#, no-wrap
msgid ""
"    /* Now we can accept incoming connections one\n"
"       at a time using accept(2) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:312
#, no-wrap
msgid ""
"    peer_addr_size = sizeof(struct sockaddr_un);\n"
"    cfd = accept(sfd, (struct sockaddr *) &peer_addr,\n"
"                 &peer_addr_size);\n"
"    if (cfd == -1)\n"
"        handle_error(\"accept\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:314
#, no-wrap
msgid "    /* Code to deal with incoming connection(s)... */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:318
#, no-wrap
msgid ""
"    /* When no longer required, the socket pathname, MY_SOCK_PATH\n"
"       should be deleted using unlink(2) or remove(3) */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/bind.2:332
msgid ""
"B<accept>(2), B<connect>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<getaddrinfo>(3), B<getifaddrs>(3), B<ip>(7), B<ipv6>(7), "
"B<path_resolution>(7), B<socket>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/bindresvport.3:30
#, no-wrap
msgid "BINDRESVPORT"
msgstr ""

#. type: TH
#: build/C/man3/bindresvport.3:30 build/C/man7/socket.7:45
#, no-wrap
msgid "2013-06-21"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:33
msgid "bindresvport - bind a socket to a privileged IP port"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:39
#, no-wrap
msgid "B<int bindresvport(int >I<sockfd>B<, struct sockaddr_in *>I<sin>B<);>\n"
msgstr ""

#.  Glibc actually starts searching with a port # in the range 600 to 1023
#. type: Plain text
#: build/C/man3/bindresvport.3:46
msgid ""
"B<bindresvport>()  is used to bind a socket descriptor to a privileged "
"anonymous IP port, that is, a port number arbitrarily selected from the "
"range 512 to 1023."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:56
msgid ""
"If the B<bind>(2)  performed by B<bindresvport>()  is successful, and I<sin> "
"is not NULL, then I<sin-E<gt>sin_port> returns the port number actually "
"allocated."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:67
msgid ""
"I<sin> can be NULL, in which case I<sin-E<gt>sin_family> is implicitly taken "
"to be B<AF_INET>.  However, in this case, B<bindresvport>()  has no way to "
"return the port number actually allocated.  (This information can later be "
"obtained using B<getsockname>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:72
msgid ""
"B<bindresvport>()  returns 0 on success; otherwise -1 is returned and "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:77
msgid ""
"B<bindresvport>()  can fail for any of the same reasons as B<bind>(2).  In "
"addition, the following errors may occur:"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:82
msgid ""
"The caller did not have superuser privilege (to be precise: the "
"B<CAP_NET_BIND_SERVICE> capability is required)."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:85
msgid "All privileged ports are in use."
msgstr ""

#. type: TP
#: build/C/man3/bindresvport.3:85
#, no-wrap
msgid "B<EAFNOSUPPORT> (B<EPFNOSUPPORT> in glibc 2.7 and earlier)"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:92
msgid "I<sin> is not NULL and I<sin-E<gt>sin_family> is not B<AF_INET>."
msgstr ""

#. type: SH
#: build/C/man3/bindresvport.3:92
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: SS
#: build/C/man3/bindresvport.3:93
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:98
msgid ""
"Before glibc 2.17, the B<bindresvport>()  function uses a static variable "
"that is not protected, so it is not thread-safe."
msgstr ""

#.  commit f6da27e53695ad1cc0e2a9490358decbbfdff5e5
#. type: Plain text
#: build/C/man3/bindresvport.3:104
msgid ""
"Since glibc 2.17, the B<bindresvport>()  function uses a lock to protect "
"static variable, so it is thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:107
msgid "Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:113
msgid ""
"Unlike some B<bindresvport>()  implementations, the glibc implementation "
"ignores any value that the caller supplies in I<sin-E<gt>sin_port>."
msgstr ""

#. type: Plain text
#: build/C/man3/bindresvport.3:116
msgid "B<bind>(2), B<getsockname>(2)"
msgstr ""

#. type: TH
#: build/C/man2/connect.2:67
#, no-wrap
msgid "CONNECT"
msgstr ""

#. type: TH
#: build/C/man2/connect.2:67 build/C/man2/getsockname.2:40 build/C/man2/getsockopt.2:44 build/C/man3/sockatmark.3:25
#, no-wrap
msgid "2008-12-03"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:70
msgid "connect - initiate a connection on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:73 build/C/man2/getsockopt.2:50 build/C/man2/listen.2:51
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>          /* See NOTES */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:75 build/C/man2/getsockname.2:46 build/C/man2/getsockopt.2:52 build/C/man2/listen.2:53 build/C/man2/recv.2:51
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:78
#, no-wrap
msgid ""
"B<int connect(int >I<sockfd>B<, const struct sockaddr *>I<addr>B<,>\n"
"B<            socklen_t >I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:97
msgid ""
"The B<connect>()  system call connects the socket referred to by the file "
"descriptor I<sockfd> to the address specified by I<addr>.  The I<addrlen> "
"argument specifies the size of I<addr>.  The format of the address in "
"I<addr> is determined by the address space of the socket I<sockfd>; see "
"B<socket>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:113
msgid ""
"If the socket I<sockfd> is of type B<SOCK_DGRAM> then I<addr> is the address "
"to which datagrams are sent by default, and the only address from which "
"datagrams are received.  If the socket is of type B<SOCK_STREAM> or "
"B<SOCK_SEQPACKET>, this call attempts to make a connection to the socket "
"that is bound to the address specified by I<addr>."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:127
msgid ""
"Generally, connection-based protocol sockets may successfully B<connect>()  "
"only once; connectionless protocol sockets may use B<connect>()  multiple "
"times to change their association.  Connectionless sockets may dissolve the "
"association by connecting to an address with the I<sa_family> member of "
"I<sockaddr> set to B<AF_UNSPEC> (supported on Linux since kernel 2.2)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:132
msgid ""
"If the connection or binding succeeds, zero is returned.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:135
msgid ""
"The following are general socket errors only.  There may be other "
"domain-specific error codes."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:143
msgid ""
"For UNIX domain sockets, which are identified by pathname: Write permission "
"is denied on the socket file, or search permission is denied for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/connect.2:143
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:148
msgid ""
"The user tried to connect to a broadcast address without having the socket "
"broadcast flag enabled or the connection request failed because of a local "
"firewall rule."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:151
msgid "Local address is already in use."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:151 build/C/man2/socket.2:324 build/C/man2/socketpair.2:75
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:156
msgid ""
"The passed address didn't have the correct address family in its "
"I<sa_family> field."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:156
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:165
msgid ""
"No more free local ports or insufficient entries in the routing cache.  For "
"B<AF_INET> see the description of I</proc/sys/net/ipv4/ip_local_port_range> "
"B<ip>(7)  for information on how to increase the number of local ports."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:165
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:169
msgid ""
"The socket is nonblocking and a previous connection attempt has not yet been "
"completed."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:172
msgid "The file descriptor is not a valid index in the descriptor table."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:172 build/C/man2/recv.2:415
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:175
msgid "No-one listening on the remote address."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:178
msgid "The socket structure address is outside the user's address space."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:178
#, no-wrap
msgid "B<EINPROGRESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:203
msgid ""
"The socket is nonblocking and the connection cannot be completed "
"immediately.  It is possible to B<select>(2)  or B<poll>(2)  for completion "
"by selecting the socket for writing.  After B<select>(2)  indicates "
"writability, use B<getsockopt>(2)  to read the B<SO_ERROR> option at level "
"B<SOL_SOCKET> to determine whether B<connect>()  completed successfully "
"(B<SO_ERROR> is zero) or unsuccessfully (B<SO_ERROR> is one of the usual "
"error codes listed here, explaining the reason for the failure)."
msgstr ""

#.  For TCP, the connection will complete asynchronously.
#.  See http://lkml.org/lkml/2005/7/12/254
#. type: Plain text
#: build/C/man2/connect.2:209
msgid ""
"The system call was interrupted by a signal that was caught; see "
"B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:209 build/C/man2/send.2:323
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:212
msgid "The socket is already connected."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:212
#, no-wrap
msgid "B<ENETUNREACH>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:215
msgid "Network is unreachable."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:218
msgid "The file descriptor is not associated with a socket."
msgstr ""

#. type: TP
#: build/C/man2/connect.2:218
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:225
msgid ""
"Timeout while attempting connection.  The server may be too busy to accept "
"new connections.  Note that for IP sockets the timeout may be very long when "
"syncookies are enabled on the server."
msgstr ""

#.  SVr4 documents the additional
#.  general error codes
#.  .BR EADDRNOTAVAIL ,
#.  .BR EINVAL ,
#.  .BR EAFNOSUPPORT ,
#.  .BR EALREADY ,
#.  .BR EINTR ,
#.  .BR EPROTOTYPE ,
#.  and
#.  .BR ENOSR .
#.  It also
#.  documents many additional error conditions not described here.
#. type: Plain text
#: build/C/man2/connect.2:241
msgid ""
"SVr4, 4.4BSD, (the B<connect>()  function first appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:258
msgid ""
"The third argument of B<connect>()  is in reality an I<int> (and this is "
"what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
"the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:263
msgid "An example of the use of B<connect>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/connect.2:270
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<listen>(2), B<socket>(2), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:36
#, no-wrap
msgid "GETIFADDRS"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:36
#, no-wrap
msgid "2012-11-11"
msgstr ""

#. type: TH
#: build/C/man3/getifaddrs.3:36 build/C/man3/if_nameindex.3:26 build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:39
msgid "getifaddrs, freeifaddrs - get interface addresses"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>ifaddrs.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:45
#, no-wrap
msgid "B<int getifaddrs(struct ifaddrs **>I<ifap>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:47
#, no-wrap
msgid "B<void freeifaddrs(struct ifaddrs *>I<ifa>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:58
msgid ""
"The B<getifaddrs>()  function creates a linked list of structures describing "
"the network interfaces of the local system, and stores the address of the "
"first item of the list in I<*ifap>.  The list consists of I<ifaddrs> "
"structures, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:77
#, no-wrap
msgid ""
"struct ifaddrs {\n"
"    struct ifaddrs  *ifa_next;    /* Next item in list */\n"
"    char            *ifa_name;    /* Name of interface */\n"
"    unsigned int     ifa_flags;   /* Flags from SIOCGIFFLAGS */\n"
"    struct sockaddr *ifa_addr;    /* Address of interface */\n"
"    struct sockaddr *ifa_netmask; /* Netmask of interface */\n"
"    union {\n"
"        struct sockaddr *ifu_broadaddr;\n"
"                         /* Broadcast address of interface */\n"
"        struct sockaddr *ifu_dstaddr;\n"
"                         /* Point-to-point destination address */\n"
"    } ifa_ifu;\n"
"#define              ifa_broadaddr ifa_ifu.ifu_broadaddr\n"
"#define              ifa_dstaddr   ifa_ifu.ifu_dstaddr\n"
"    void            *ifa_data;    /* Address-specific data */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:84
msgid ""
"The I<ifa_next> field contains a pointer to the next structure on the list, "
"or NULL if this is the last item of the list."
msgstr ""

#.  The constant
#.  .B IF NAMESIZE
#.  indicates the maximum length of this field.
#. type: Plain text
#: build/C/man3/getifaddrs.3:91
msgid "The I<ifa_name> points to the null-terminated interface name."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:100
msgid ""
"The I<ifa_flags> field contains the interface flags, as returned by the "
"B<SIOCGIFFLAGS> B<ioctl>(2)  operation (see B<netdevice>(7)  for a list of "
"these flags)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:109
msgid ""
"The I<ifa_addr> field points to a structure containing the interface "
"address.  (The I<sa_family> subfield should be consulted to determine the "
"format of the address structure.)  This field may contain a NULL pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:116
msgid ""
"The I<ifa_netmask> field points to a structure containing the netmask "
"associated with I<ifa_addr>, if applicable for the address family.  This "
"field may contain a NULL pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:131
msgid ""
"Depending on whether the bit B<IFF_BROADCAST> or B<IFF_POINTOPOINT> is set "
"in I<ifa_flags> (only one can be set at a time), either I<ifa_broadaddr> "
"will contain the broadcast address associated with I<ifa_addr> (if "
"applicable for the address family) or I<ifa_dstaddr> will contain the "
"destination address of the point-to-point interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:136
msgid ""
"The I<ifa_data> field points to a buffer containing address-family-specific "
"data; this field may be NULL if there is no such data for this interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:142
msgid ""
"The data returned by B<getifaddrs>()  is dynamically allocated and should be "
"freed using B<freeifaddrs>()  when no longer needed."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:149
msgid ""
"On success, B<getifaddrs>()  returns zero; on error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:162
msgid ""
"B<getifaddrs>()  may fail and set I<errno> for any of the errors specified "
"for B<socket>(2), B<bind>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), B<malloc>(3), or B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:170
msgid ""
"The B<getifaddrs>()  function first appeared in glibc 2.3, but before glibc "
"2.3.3, the implementation supported only IPv4 addresses; IPv6 support was "
"added in glibc 2.3.3.  Support of address families other than IPv4 is "
"available only on kernels that support netlink."
msgstr ""

#.  , but the BSD-derived documentation generally
#.  appears to be confused and obsolete on this point.
#.  i.e., commonly it still says one of them will be NULL, even if
#.  the ifa_ifu union is already present
#. type: Plain text
#: build/C/man3/getifaddrs.3:190
msgid ""
"Not in POSIX.1-2001.  This function first appeared in BSDi and is present on "
"the BSD systems, but with slightly different semantics "
"documented\\(emreturning one entry per interface, not per address.  This "
"means I<ifa_addr> and other fields can actually be NULL if the interface has "
"no address, and no link-level address is returned if the interface has an IP "
"address assigned.  Also, the way of choosing either I<ifa_broadaddr> or "
"I<ifa_dstaddr> differs on various systems."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:207
msgid ""
"The addresses returned on Linux will usually be the IPv4 and IPv6 addresses "
"assigned to the interface, but also one B<AF_PACKET> address per interface "
"containing lower-level details about the interface and its physical layer.  "
"In this case, the I<ifa_data> field may contain a pointer to a I<struct "
"rtnl_link_stats>, defined in I<E<lt>linux/if_link.hE<gt>> (in Linux 2.4 and "
"earlier, I<struct net_device_stats>, defined in "
"I<E<lt>linux/netdevice.hE<gt>>), which contains various interface attributes "
"and statistics."
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:214
msgid ""
"The program below demonstrates the use of B<getifaddrs>(), B<freeifaddrs>(), "
"and B<getnameinfo>(3).  Here is what we see when running this program on one "
"system:"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:228
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"lo      address family: 17 (AF_PACKET)\n"
"eth0    address family: 17 (AF_PACKET)\n"
"lo      address family: 2 (AF_INET)\n"
"        address: E<lt>127.0.0.1E<gt>\n"
"eth0    address family: 2 (AF_INET)\n"
"        address: E<lt>10.1.1.4E<gt>\n"
"lo      address family: 10 (AF_INET6)\n"
"        address: E<lt>::1E<gt>\n"
"eth0    address family: 10 (AF_INET6)\n"
"        address: E<lt>fe80::2d0:59ff:feda:eb51%eth0E<gt>\n"
msgstr ""

#. type: SS
#: build/C/man3/getifaddrs.3:230 build/C/man3/if_nameindex.3:120 build/C/man2/recvmmsg.2:206
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:240
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>ifaddrs.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:247
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ifaddrs *ifaddr, *ifa;\n"
"    int family, s;\n"
"    char host[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:252
#, no-wrap
msgid ""
"    if (getifaddrs(&ifaddr) == -1) {\n"
"        perror(\"getifaddrs\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:255
#, no-wrap
msgid ""
"    /* Walk through linked list, maintaining head pointer so we\n"
"       can free list later */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:259
#, no-wrap
msgid ""
"    for (ifa = ifaddr; ifa != NULL; ifa = ifa-E<gt>ifa_next) {\n"
"        if (ifa-E<gt>ifa_addr == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:261
#, no-wrap
msgid "        family = ifa-E<gt>ifa_addr-E<gt>sa_family;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:264
#, no-wrap
msgid ""
"        /* Display interface name and family (including symbolic\n"
"           form of the latter for the common families) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:270
#, no-wrap
msgid ""
"        printf(\"%s\\t  address family: %d%s\\en\",\n"
"                ifa-E<gt>ifa_name, family,\n"
"                (family == AF_PACKET) ? \" (AF_PACKET)\" :\n"
"                (family == AF_INET) ?   \" (AF_INET)\" :\n"
"                (family == AF_INET6) ?  \" (AF_INET6)\" : \"\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:272
#, no-wrap
msgid "        /* For an AF_INET* interface address, display the address */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:285
#, no-wrap
msgid ""
"        if (family == AF_INET || family == AF_INET6) {\n"
"            s = getnameinfo(ifa-E<gt>ifa_addr,\n"
"                    (family == AF_INET) ? sizeof(struct sockaddr_in) :\n"
"                                          sizeof(struct sockaddr_in6),\n"
"                    host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);\n"
"            if (s != 0) {\n"
"                printf(\"getnameinfo() failed: %s\\en\", gai_strerror(s));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            printf(\"\\etaddress: E<lt>%sE<gt>\\en\", host);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:289
#, no-wrap
msgid ""
"    freeifaddrs(ifaddr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getifaddrs.3:296
msgid "B<bind>(2), B<getsockname>(2), B<socket>(2), B<packet>(7), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man2/getsockname.2:40
#, no-wrap
msgid "GETSOCKNAME"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:43
msgid "getsockname - get socket name"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:49
#, no-wrap
msgid ""
"B<int getsockname(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:62
msgid ""
"B<getsockname>()  returns the current address to which the socket I<sockfd> "
"is bound, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space (in bytes) pointed to "
"by I<addr>.  On return it contains the actual size of the socket address."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:78 build/C/man2/getsockopt.2:142 build/C/man2/listen.2:96
msgid "The argument I<sockfd> is not a valid descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:84
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:88
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: build/C/man2/getsockname.2:88 build/C/man3/if_nameindex.3:83 build/C/man2/send.2:335
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:92
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:97 build/C/man2/getsockopt.2:171
msgid "The argument I<sockfd> is a file, not a socket."
msgstr ""

#.  SVr4 documents additional ENOMEM
#.  and ENOSR error codes.
#. type: Plain text
#: build/C/man2/getsockname.2:103
msgid ""
"SVr4, 4.4BSD (the B<getsockname>()  function call appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:114
msgid ""
"The third argument of B<getsockname>()  is in reality an I<int\\ *> (and "
"this is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion "
"resulted in the present I<socklen_t>, also used by glibc.  See also "
"B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockname.2:121
msgid ""
"B<bind>(2), B<socket>(2), B<getifaddrs>(3), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/getsockopt.2:44
#, no-wrap
msgid "GETSOCKOPT"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:47
msgid "getsockopt, setsockopt - get and set options on sockets"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:57
#, no-wrap
msgid ""
"B<int getsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               void *>I<optval>B<, socklen_t *>I<optlen>B<);>\n"
"B<int setsockopt(int >I<sockfd>B<, int >I<level>B<, int >I<optname>B<,>\n"
"B<               const void *>I<optval>B<, socklen_t >I<optlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:67
msgid ""
"B<getsockopt>()  and B<setsockopt>()  manipulate options for the socket "
"referred to by the file descriptor I<sockfd>.  Options may exist at multiple "
"protocol levels; they are always present at the uppermost socket level."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:86
msgid ""
"When manipulating socket options, the level at which the option resides and "
"the name of the option must be specified.  To manipulate options at the "
"sockets API level, I<level> is specified as B<SOL_SOCKET>.  To manipulate "
"options at any other level the protocol number of the appropriate protocol "
"controlling the option is supplied.  For example, to indicate that an option "
"is to be interpreted by the B<TCP> protocol, I<level> should be set to the "
"protocol number of B<TCP>; see B<getprotoent>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:108
msgid ""
"The arguments I<optval> and I<optlen> are used to access option values for "
"B<setsockopt>().  For B<getsockopt>()  they identify a buffer in which the "
"value for the requested option(s) are to be returned.  For B<getsockopt>(), "
"I<optlen> is a value-result argument, initially containing the size of the "
"buffer pointed to by I<optval>, and modified on return to indicate the "
"actual size of the value returned.  If no option value is to be supplied or "
"returned, I<optval> may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:118
msgid ""
"I<Optname> and any specified options are passed uninterpreted to the "
"appropriate protocol module for interpretation.  The include file "
"I<E<lt>sys/socket.hE<gt>> contains definitions for socket level options, "
"described below.  Options at other protocol levels vary in format and name; "
"consult the appropriate entries in section 4 of the manual."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:127
msgid ""
"Most socket-level options utilize an I<int> argument for I<optval>.  For "
"B<setsockopt>(), the argument should be nonzero to enable a boolean option, "
"or zero if the option is to be disabled."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:131
msgid ""
"For a description of the available socket options see B<socket>(7)  and the "
"appropriate protocol man pages."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:152
msgid ""
"The address pointed to by I<optval> is not in a valid part of the process "
"address space.  For B<getsockopt>(), this error may also be returned if "
"I<optlen> is not in a valid part of the process address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:163
msgid ""
"I<optlen> invalid in B<setsockopt>().  In some cases this error can also "
"occur for an invalid value in I<optval> (e.g., for the B<IP_ADD_MEMBERSHIP> "
"option described in B<ip>(7))."
msgstr ""

#. type: TP
#: build/C/man2/getsockopt.2:163
#, no-wrap
msgid "B<ENOPROTOOPT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:166
msgid "The option is unknown at the level indicated."
msgstr ""

#.  SVr4 documents additional ENOMEM and ENOSR error codes, but does
#.  not document the
#.  .BR SO_SNDLOWAT ", " SO_RCVLOWAT ", " SO_SNDTIMEO ", " SO_RCVTIMEO
#.  options
#. type: Plain text
#: build/C/man2/getsockopt.2:178
msgid "SVr4, 4.4BSD (these system calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:199
msgid ""
"The I<optlen> argument of B<getsockopt>()  and B<setsockopt>()  is in "
"reality an I<int [*]> (and this is what 4.x BSD and libc4 and libc5 have).  "
"Some POSIX confusion resulted in the present I<socklen_t>, also used by "
"glibc.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:202
msgid ""
"Several of the socket options should be handled at lower levels of the "
"system."
msgstr ""

#. type: Plain text
#: build/C/man2/getsockopt.2:210
msgid ""
"B<ioctl>(2), B<socket>(2), B<getprotoent>(3), B<protocols>(5), B<socket>(7), "
"B<tcp>(7), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/if_nameindex.3:26
#, no-wrap
msgid "IF_NAMEINDEX"
msgstr ""

#. type: TH
#: build/C/man3/if_nameindex.3:26
#, no-wrap
msgid "2012-11-21"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:29
msgid "if_nameindex, if_freenameindex - get network interface names and indexes"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:32 build/C/man3/if_nametoindex.3:32
#, no-wrap
msgid "B<#include E<lt>net/if.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:35
#, no-wrap
msgid ""
"B<struct if_nameindex *if_nameindex(void);>\n"
"B<void if_freenameindex(struct if_nameindex *>I<ptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:46
msgid ""
"The B<if_nameindex>()  function returns an array of I<if_nameindex> "
"structures, each containing information about one of the network interfaces "
"on the local system.  The I<if_nameindex> structure contains at least the "
"following entries:"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:51
#, no-wrap
msgid ""
"    unsigned int if_index; /* Index of interface (1, 2, ...) */\n"
"    char        *if_name;  /* Null-terminated name (\"eth0\", etc.) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:65
msgid ""
"The I<if_index> field contains the interface index.  The I<ifa_name> field "
"points to the null-terminated interface name.  The end of the array is "
"indicated by entry with I<if_index> set to zero and I<ifa_name> set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:71
msgid ""
"The data structure returned by B<if_nameindex>()  is dynamically allocated "
"and should be freed using B<if_freenameindex>()  when no longer needed."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:78
msgid ""
"On success, B<if_nameindex>()  returns pointer to the array; on error, a "
"NULL pointer is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:83
msgid "B<if_nameindex>()  may fail and set I<errno> if:"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:86
msgid "Insufficient resources available."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:97
msgid ""
"B<if_nameindex>()  may also fail for any of the errors specified for "
"B<socket>(2), B<bind>(2), B<ioctl>(2), B<getsockname>(2), B<recvmsg>(2), "
"B<sendto>(2), or B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:104
msgid ""
"The B<if_nameindex>()  function first appeared in glibc 2.1, but before "
"glibc 2.3.4, the implementation supported only interfaces with IPv4 "
"addresses.  Support of interfaces that don't have IPv4 addresses is "
"available only on kernels that support netlink."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:106 build/C/man3/if_nametoindex.3:87
msgid "RFC\\ 3493, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:108 build/C/man3/if_nametoindex.3:89
msgid "This function first appeared in BSDi."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:112
msgid ""
"The program below demonstrates the use of the functions described on this "
"page.  An example of the output this program might produce is the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:118
#, no-wrap
msgid ""
"$ B<./a.out>I<\n"
"1: lo\n"
"2: wlan0\n"
"3: em1>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:126
#, no-wrap
msgid ""
"#include E<lt>net/if.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:131
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct if_nameindex *if_ni, *i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:137
#, no-wrap
msgid ""
"    if_ni = if_nameindex();\n"
"    if (if_ni == NULL) {\n"
"        perror(\"if_nameindex\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:140
#, no-wrap
msgid ""
"    for (i = if_ni; ! (i-E<gt>if_index == 0 && i-E<gt>if_name == NULL); "
"i++)\n"
"        printf(\"%u: %s\\en\", i-E<gt>if_index, i-E<gt>if_name);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:142
#, no-wrap
msgid "    if_freenameindex(if_ni);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:145 build/C/man2/select.2:573
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nameindex.3:153
msgid ""
"B<getsockopt>(2), B<setsockopt>(2), B<getifaddrs>(3), B<if_indextoname>(3), "
"B<if_nametoindex>(3), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "IF_NAMETOINDEX"
msgstr ""

#. type: TH
#: build/C/man3/if_nametoindex.3:25
#, no-wrap
msgid "2012-12-14"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:29
msgid ""
"if_nametoindex, if_indextoname - mappings between network interface names "
"and indexes"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:34
#, no-wrap
msgid "B<unsigned int if_nametoindex(const char *>I<ifname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:36
#, no-wrap
msgid "B<char *if_indextoname(unsigned int ifindex, char *>I<ifname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:43
msgid ""
"The B<if_nametoindex>()  function returns the index of the network interface "
"corresponding to the name I<ifname>."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:54
msgid ""
"The B<if_indextoname>()  function returns the name of the network interface "
"corresponding to the interface index I<ifindex>.  The name is placed in the "
"buffer pointed to by I<ifname>.  The buffer must allow for the storage of at "
"least B<IF_NAMESIZE> bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:61
msgid ""
"On success, B<if_nametoindex>()  returns the index number of the network "
"interface; on error, 0 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:69
msgid ""
"On success, B<if_indextoname>()  returns I<ifname>; on error, NULL is "
"returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:74
msgid "B<if_indextoname>()  may fail and set I<errno> if:"
msgstr ""

#. type: TP
#: build/C/man3/if_nametoindex.3:74
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:77
msgid "No interface found for the index."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:85
msgid ""
"B<if_nametoindex>()  and B<if_indextoname>()  may also fail for any of the "
"errors specified for B<socket>(2)  or B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/if_nametoindex.3:93
msgid "B<getifaddrs>(3), B<if_nameindex>(3), B<ifconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man2/listen.2:45
#, no-wrap
msgid "LISTEN"
msgstr ""

#. type: TH
#: build/C/man2/listen.2:45
#, no-wrap
msgid "2008-11-20"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:48
msgid "listen - listen for connections on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:55
#, no-wrap
msgid "B<int listen(int >I<sockfd>B<, int >I<backlog>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:63
msgid ""
"B<listen>()  marks the socket referred to by I<sockfd> as a passive socket, "
"that is, as a socket that will be used to accept incoming connection "
"requests using B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:70
msgid ""
"The I<sockfd> argument is a file descriptor that refers to a socket of type "
"B<SOCK_STREAM> or B<SOCK_SEQPACKET>."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:82
msgid ""
"The I<backlog> argument defines the maximum length to which the queue of "
"pending connections for I<sockfd> may grow.  If a connection request arrives "
"when the queue is full, the client may receive an error with an indication "
"of B<ECONNREFUSED> or, if the underlying protocol supports retransmission, "
"the request may be ignored so that a later reattempt at connection succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:91
msgid "Another socket is already listening on the same port."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:101 build/C/man2/send.2:354
msgid "The argument I<sockfd> is not a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:106
msgid "The socket is not of a type that supports the B<listen>()  operation."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:111
msgid ""
"4.4BSD, POSIX.1-2001.  The B<listen>()  function call first appeared in "
"4.2BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:113
msgid "To accept connections, the following steps are performed:"
msgstr ""

#. type: TP
#: build/C/man2/listen.2:114 build/C/man2/select_tut.2:347
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:117
msgid "A socket is created with B<socket>(2)."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:117 build/C/man2/select_tut.2:356
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:123
msgid ""
"The socket is bound to a local address using B<bind>(2), so that other "
"sockets may be B<connect>(2)ed to it."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:123 build/C/man2/select_tut.2:360
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:127
msgid ""
"A willingness to accept incoming connections and a queue limit for incoming "
"connections are specified with B<listen>()."
msgstr ""

#. type: TP
#: build/C/man2/listen.2:127 build/C/man2/select_tut.2:367
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:130
msgid "Connections are accepted with B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:153
msgid ""
"The behavior of the I<backlog> argument on TCP sockets changed with Linux "
"2.2.  Now it specifies the queue length for I<completely> established "
"sockets waiting to be accepted, instead of the number of incomplete "
"connection requests.  The maximum length of the queue for incomplete sockets "
"can be set using I</proc/sys/net/ipv4/tcp_max_syn_backlog>.  When syncookies "
"are enabled there is no logical maximum length and this setting is ignored.  "
"See B<tcp>(7)  for more information."
msgstr ""

#.  The following is now rather historic information (MTK, Jun 05)
#.  Don't rely on this value in portable applications since BSD
#.  (and some BSD-derived systems) limit the backlog to 5.
#. type: Plain text
#: build/C/man2/listen.2:166
msgid ""
"If the I<backlog> argument is greater than the value in "
"I</proc/sys/net/core/somaxconn>, then it is silently truncated to that "
"value; the default value in this file is 128.  In kernels before 2.4.25, "
"this limit was a hard coded value, B<SOMAXCONN>, with the value 128."
msgstr ""

#. type: Plain text
#: build/C/man2/listen.2:175
msgid "B<accept>(2), B<bind>(2), B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/recv.2:41
#, no-wrap
msgid "RECV"
msgstr ""

#. type: TH
#: build/C/man2/recv.2:41
#, no-wrap
msgid "2013-04-19"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:44
msgid "recv, recvfrom, recvmsg - receive a message from a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:49 build/C/man2/select.2:53 build/C/man2/select_tut.2:47
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:53
#, no-wrap
msgid ""
"B<ssize_t recv(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:56
#, no-wrap
msgid ""
"B<ssize_t recvfrom(int >I<sockfd>B<, void *>I<buf>B<, size_t >I<len>B<, int "
">I<flags>B<,>\n"
"B<                 struct sockaddr *>I<src_addr>B<, socklen_t "
"*>I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:58
#, no-wrap
msgid ""
"B<ssize_t recvmsg(int >I<sockfd>B<, struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:66
msgid ""
"The B<recvfrom>()  and B<recvmsg>()  calls are used to receive messages from "
"a socket, and may be used to receive data on a socket whether or not it is "
"connection-oriented."
msgstr ""

#.  (Note: for datagram sockets in both the UNIX and Internet domains,
#.  .I src_addr
#.  is filled in.
#.  .I src_addr
#.  is also filled in for stream sockets in the UNIX domain, but is not
#.  filled in for stream sockets in the Internet domain.)
#.  [The above notes on AF_UNIX and AF_INET sockets apply as at
#.  Kernel 2.4.18. (MTK, 22 Jul 02)]
#. type: Plain text
#: build/C/man2/recv.2:95
msgid ""
"If I<src_addr> is not NULL, and the underlying protocol provides the source "
"address, this source address is filled in.  When I<src_addr> is NULL, "
"nothing is filled in; in this case, I<addrlen> is not used, and should also "
"be NULL.  The argument I<addrlen> is a value-result argument, which the "
"caller should initialize before the call to the size of the buffer "
"associated with I<src_addr>, and modified on return to indicate the actual "
"size of the source address.  The returned address is truncated if the buffer "
"provided is too small; in this case, I<addrlen> will return a value greater "
"than was supplied to the call."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:107
msgid ""
"The B<recv>()  call is normally used only on a I<connected> socket (see "
"B<connect>(2))  and is identical to B<recvfrom>()  with a NULL I<src_addr> "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:113
msgid ""
"All three routines return the length of the message on successful "
"completion.  If a message is too long to fit in the supplied buffer, excess "
"bytes may be discarded depending on the type of socket the message is "
"received from."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:123
msgid ""
"If no messages are available at the socket, the receive calls wait for a "
"message to arrive, unless the socket is nonblocking (see B<fcntl>(2)), in "
"which case the value -1 is returned and the external variable I<errno> is "
"set to B<EAGAIN> or B<EWOULDBLOCK>.  The receive calls normally return any "
"data available, up to the requested amount, rather than waiting for receipt "
"of the full amount requested."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:129
msgid ""
"The B<select>(2)  or B<poll>(2)  call may be used to determine when more "
"data arrives."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:135
msgid ""
"The I<flags> argument to a B<recv>()  call is formed by ORing one or more of "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man2/recv.2:135
#, no-wrap
msgid "B<MSG_CMSG_CLOEXEC> (B<recvmsg>() only; since Linux 2.6.23)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:146
msgid ""
"Set the close-on-exec flag for the file descriptor received via a UNIX "
"domain file descriptor using the B<SCM_RIGHTS> operation (described in "
"B<unix>(7)).  This flag is useful for the same reasons as the B<O_CLOEXEC> "
"flag of B<open>(2)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:146 build/C/man2/send.2:188
#, no-wrap
msgid "B<MSG_DONTWAIT> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:156
msgid ""
"Enables nonblocking operation; if the operation would block, the call fails "
"with the error B<EAGAIN> or B<EWOULDBLOCK> (this can also be enabled using "
"the B<O_NONBLOCK> flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:156
#, no-wrap
msgid "B<MSG_ERRQUEUE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:175
msgid ""
"This flag specifies that queued errors should be received from the socket "
"error queue.  The error is passed in an ancillary message with a type "
"dependent on the protocol (for IPv4 B<IP_RECVERR>).  The user should supply "
"a buffer of sufficient size.  See B<cmsg>(3)  and B<ip>(7)  for more "
"information.  The payload of the original packet that caused the error is "
"passed as normal data via I<msg_iovec>.  The original destination address of "
"the datagram that caused the error is supplied via I<msg_name>."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:187 build/C/man2/recv.2:250
msgid ""
"For local errors, no address is passed (this can be checked with the "
"I<cmsg_len> member of the I<cmsghdr>).  For error receives, the "
"B<MSG_ERRQUEUE> is set in the I<msghdr>.  After an error has been passed, "
"the pending socket error is regenerated based on the next queued error and "
"will be passed on the next socket operation."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:191
msgid "The error is supplied in a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:198
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:210
#, no-wrap
msgid ""
"struct sock_extended_err\n"
"{\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;     /* padding */\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:212
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:236
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SOCK_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined.  The payload of the packet that "
"caused the error is passed as normal data."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:250 build/C/man2/recv.2:381 build/C/man2/send.2:230
#, no-wrap
msgid "B<MSG_OOB>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:257
msgid ""
"This flag requests receipt of out-of-band data that would not be received in "
"the normal data stream.  Some protocols place expedited data at the head of "
"the normal data queue, and thus this flag cannot be used with such "
"protocols."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:257
#, no-wrap
msgid "B<MSG_PEEK>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:264
msgid ""
"This flag causes the receive operation to return data from the beginning of "
"the receive queue without removing that data from the queue.  Thus, a "
"subsequent receive call will return the same data."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:264
#, no-wrap
msgid "B<MSG_TRUNC> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:275
msgid ""
"For raw (B<AF_PACKET>), Internet datagram (since Linux 2.4.27/2.6.8), "
"netlink (since Linux 2.6.22) and UNIX datagram (since Linux 3.4) sockets: "
"return the real length of the packet or datagram, even when it was longer "
"than the passed buffer.  Not implemented for UNIX domain (B<unix>(7))  "
"sockets."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:278
msgid "For use with Internet stream sockets, see B<tcp>(7)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:278
#, no-wrap
msgid "B<MSG_WAITALL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:285
msgid ""
"This flag requests that the operation block until the full request is "
"satisfied.  However, the call may still return less data than requested if a "
"signal is caught, an error or disconnect occurs, or the next data to be "
"received is of a different type than that returned."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:293
msgid ""
"The B<recvmsg>()  call uses a I<msghdr> structure to minimize the number of "
"directly supplied arguments.  This structure is defined as follows in "
"I<E<lt>sys/socket.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:300
#, no-wrap
msgid ""
"struct iovec {                    /* Scatter/gather array items */\n"
"    void  *iov_base;              /* Starting address */\n"
"    size_t iov_len;               /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:310 build/C/man2/send.2:258
#, no-wrap
msgid ""
"struct msghdr {\n"
"    void         *msg_name;       /* optional address */\n"
"    socklen_t     msg_namelen;    /* size of address */\n"
"    struct iovec *msg_iov;        /* scatter/gather array */\n"
"    size_t        msg_iovlen;     /* # elements in msg_iov */\n"
"    void         *msg_control;    /* ancillary data, see below */\n"
"    size_t        msg_controllen; /* ancillary data buffer len */\n"
"    int           msg_flags;      /* flags on received message */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:340
msgid ""
"Here I<msg_name> and I<msg_namelen> specify the source address if the socket "
"is unconnected; I<msg_name> may be given as a NULL pointer if no names are "
"desired or required.  The fields I<msg_iov> and I<msg_iovlen> describe "
"scatter-gather locations, as discussed in B<readv>(2).  The field "
"I<msg_control>, which has length I<msg_controllen>, points to a buffer for "
"other protocol control-related messages or miscellaneous ancillary data.  "
"When B<recvmsg>()  is called, I<msg_controllen> should contain the length of "
"the available buffer in I<msg_control>; upon return from a successful call "
"it will contain the length of the control message sequence."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:342
msgid "The messages are of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:352
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    socklen_t     cmsg_len;     /* data byte count, including hdr */\n"
"    int           cmsg_level;   /* originating protocol */\n"
"    int           cmsg_type;    /* protocol-specific type */\n"
"/* followed by\n"
"    unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:357
msgid "Ancillary data should be accessed only by the macros defined in B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:360
msgid ""
"As an example, Linux uses this ancillary data mechanism to pass extended "
"errors, IP options, or file descriptors over UNIX domain sockets."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:368
msgid ""
"The I<msg_flags> field in the I<msghdr> is set on return of B<recvmsg>().  "
"It can contain several flags:"
msgstr ""

#. type: TP
#: build/C/man2/recv.2:368
#, no-wrap
msgid "B<MSG_EOR>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:373
msgid ""
"indicates end-of-record; the data returned completed a record (generally "
"used with sockets of type B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:373
#, no-wrap
msgid "B<MSG_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:377
msgid ""
"indicates that the trailing portion of a datagram was discarded because the "
"datagram was larger than the buffer supplied."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:377
#, no-wrap
msgid "B<MSG_CTRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:381
msgid ""
"indicates that some control data were discarded due to lack of space in the "
"buffer for ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:384
msgid "is returned to indicate that expedited or out-of-band data were received."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:384
#, no-wrap
msgid "B<MSG_ERRQUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:388
msgid ""
"indicates that no data was received but an extended error from the socket "
"error queue."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:396
msgid ""
"These calls return the number of bytes received, or -1 if an error "
"occurred.  In the event of an error, I<errno> is set to indicate the error.  "
"The return value will be 0 when the peer has performed an orderly shutdown."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:401
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their manual pages."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/recv.2:410
msgid ""
"The socket is marked nonblocking and the receive operation would block, or a "
"receive timeout had been set and the timeout expired before data was "
"received.  POSIX.1-2001 allows either error to be returned for this case, "
"and does not require these constants to have the same value, so a portable "
"application should check for both possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:415
msgid "The argument I<sockfd> is an invalid descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:419
msgid ""
"A remote host refused to allow the network connection (typically because it "
"is not running the requested service)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:423
msgid "The receive buffer pointer(s) point outside the process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:428
msgid ""
"The receive was interrupted by delivery of a signal before any data were "
"available; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:432 build/C/man2/send.2:323
msgid "Invalid argument passed."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:436
msgid "Could not allocate memory for B<recvmsg>()."
msgstr ""

#. type: TP
#: build/C/man2/recv.2:436 build/C/man2/send.2:346
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:443
msgid ""
"The socket is associated with a connection-oriented protocol and has not "
"been connected (see B<connect>(2)  and B<accept>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:448
msgid "The argument I<sockfd> does not refer to a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:451
msgid "4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:458
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB>, B<MSG_PEEK>, and B<MSG_WAITALL> "
"flags."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:474
msgid ""
"The prototypes given above follow glibc2.  The Single UNIX Specification "
"agrees, except that it has return values of type I<ssize_t> (while 4.x BSD "
"and libc4 and libc5 all have I<int>).  The I<flags> argument is I<int> in "
"4.x BSD, but I<unsigned int> in libc4 and libc5.  The I<len> argument is "
"I<int> in 4.x BSD, but I<size_t> in libc4 and libc5.  The I<addrlen> "
"argument is I<int\\ *> in 4.x BSD, libc4 and libc5.  The present "
"I<socklen_t\\ *> was invented by POSIX.  See also B<accept>(2)."
msgstr ""

#.  glibc bug raised 12 Mar 2006
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=2448
#.  The problem is an underlying kernel issue: the size of the
#.  __kernel_size_t type used to type this field varies
#.  across architectures, but socklen_t is always 32 bits.
#. type: Plain text
#: build/C/man2/recv.2:488 build/C/man2/send.2:409
msgid ""
"According to POSIX.1-2001, the I<msg_controllen> field of the I<msghdr> "
"structure should be typed as I<socklen_t>, but glibc currently types it as "
"I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:493
msgid ""
"See B<recvmmsg>(2)  for information about a Linux-specific system call that "
"can be used to receive multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:498
msgid "An example of the use of B<recvfrom>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/recv.2:509
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<read>(2), B<recvmmsg>(2), B<select>(2), "
"B<shutdown>(2), B<socket>(2), B<cmsg>(3), B<sockatmark>(3), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/recvmmsg.2:31
#, no-wrap
msgid "RECVMMSG"
msgstr ""

#. type: TH
#: build/C/man2/recvmmsg.2:31
#, no-wrap
msgid "2012-12-24"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:34
msgid "recvmmsg - receive multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:38 build/C/man2/sendmmsg.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:41
#, no-wrap
msgid ""
"B<int recvmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:43
#, no-wrap
msgid "B<             unsigned int >I<flags>B<, struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:55
msgid ""
"The B<recvmmsg>()  system call is an extension of B<recvmsg>(2)  that allows "
"the caller to receive multiple messages from a socket using a single system "
"call.  (This has performance benefits for some applications.)  A further "
"extension over B<recvmsg>(2)  is support for a timeout on the receive "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:59
msgid ""
"The I<sockfd> argument is the file descriptor of the socket to receive data "
"from."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:67 build/C/man2/sendmmsg.2:62
msgid ""
"The I<msgvec> argument is a pointer to an array of I<mmsghdr> structures.  "
"The size of this array is specified in I<vlen>."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:73 build/C/man2/sendmmsg.2:68
msgid "The I<mmsghdr> structure is defined in I<E<lt>sys/socket.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:80
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of received bytes for header */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:95
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<recvmsg>(2).  The I<msg_len> field is the number of bytes returned for the "
"message in the entry.  This field has the same value as the return value of "
"a single B<recvmsg>(2)  on the header."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:102
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as documented for B<recvmsg>(2), with the following addition:"
msgstr ""

#. type: TP
#: build/C/man2/recvmmsg.2:102
#, no-wrap
msgid "B<MSG_WAITFORONE> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:107
msgid "Turns on B<MSG_DONTWAIT> after the first message has been received."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:123
msgid ""
"The I<timeout> argument points to a I<struct timespec> (see "
"B<clock_gettime>(2))  defining a timeout (seconds plus nanoseconds) for the "
"receive operation.  (This interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.)  If I<timeout> is I<NULL> then the operation "
"blocks indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:134
msgid ""
"A blocking B<recvmmsg>()  call blocks until I<vlen> messages have been "
"received or until the timeout expires.  A nonblocking call reads as many "
"messages as are available (up to the limit specified by I<vlen>)  and "
"returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:149
msgid ""
"On return from B<recvmmsg>(), successive elements of I<msgvec> are updated "
"to contain information about each received message: I<msg_len> contains the "
"size of the received message; the subfields of I<msg_hdr> are updated as "
"described in B<recvmsg>(2).  The return value of the call indicates the "
"number of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:157
msgid ""
"On success, B<recvmmsg>()  returns the number of messages received in "
"I<msgvec>; on error, -1 is returned, and I<errno> is set to indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:161
msgid ""
"Errors are as for B<recvmsg>(2).  In addition, the following error can "
"occur:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:165
msgid "I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:170
msgid ""
"The B<recvmmsg>()  system call was added in Linux 2.6.33.  Support in glibc "
"was added in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:173
msgid "B<recvmmsg>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:181
msgid ""
"The following program uses B<recvmmsg>()  to receive multiple messages on a "
"socket and stores them in multiple buffers.  The call returns if all buffers "
"are filled or if the timeout specified has expired."
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:184
msgid ""
"The following snippet periodically generates UDP datagrams containing a "
"random number:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:189
#, no-wrap
msgid ""
"$B< while true; do echo $RANDOM E<gt> /dev/udp/127.0.0.1/1234; >\n"
"B<sleep 0.25; done>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:194
msgid ""
"These datagrams are read by the example application, which can give the "
"following output:"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:204
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"5 messages received\n"
"1 11782\n"
"2 11345\n"
"3 304\n"
"4 13514\n"
"5 28421\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:215
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:228
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"#define VLEN 10\n"
"#define BUFSIZE 200\n"
"#define TIMEOUT 1\n"
"    int sockfd, retval, i;\n"
"    struct sockaddr_in sa;\n"
"    struct mmsghdr msgs[VLEN];\n"
"    struct iovec iovecs[VLEN];\n"
"    char bufs[VLEN][BUFSIZE+1];\n"
"    struct timespec timeout;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:234 build/C/man2/sendmmsg.2:201
#, no-wrap
msgid ""
"    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n"
"    if (sockfd == -1) {\n"
"        perror(\"socket()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:242
#, no-wrap
msgid ""
"    sa.sin_family = AF_INET;\n"
"    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    sa.sin_port = htons(1234);\n"
"    if (bind(sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {\n"
"        perror(\"bind()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:250
#, no-wrap
msgid ""
"    memset(msgs, 0, sizeof(msgs));\n"
"    for (i = 0; i E<lt> VLEN; i++) {\n"
"        iovecs[i].iov_base         = bufs[i];\n"
"        iovecs[i].iov_len          = BUFSIZE;\n"
"        msgs[i].msg_hdr.msg_iov    = &iovecs[i];\n"
"        msgs[i].msg_hdr.msg_iovlen = 1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:253
#, no-wrap
msgid ""
"    timeout.tv_sec = TIMEOUT;\n"
"    timeout.tv_nsec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:259
#, no-wrap
msgid ""
"    retval = recvmmsg(sockfd, msgs, VLEN, 0, &timeout);\n"
"    if (retval == -1) {\n"
"        perror(\"recvmmsg()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:267
#, no-wrap
msgid ""
"    printf(\"%d messages received\\en\", retval);\n"
"    for (i = 0; i E<lt> retval; i++) {\n"
"        bufs[i][msgs[i].msg_len] = 0;\n"
"        printf(\"%d %s\", i+1, bufs[i]);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/recvmmsg.2:275
msgid ""
"B<clock_gettime>(2), B<recvmsg>(2), B<sendmmsg>(2), B<sendmsg>(2), "
"B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man2/select.2:38
#, no-wrap
msgid "SELECT"
msgstr ""

#. type: TH
#: build/C/man2/select.2:38
#, no-wrap
msgid "2012-08-17"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:42 build/C/man2/select_tut.2:36
msgid ""
"select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O "
"multiplexing"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:45 build/C/man2/select_tut.2:39
#, no-wrap
msgid "/* According to POSIX.1-2001 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:47 build/C/man2/select.2:68 build/C/man2/select_tut.2:41 build/C/man2/select_tut.2:62
#, no-wrap
msgid "B<#include E<lt>sys/select.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:49 build/C/man2/select_tut.2:43
#, no-wrap
msgid "/* According to earlier standards */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:51 build/C/man2/select_tut.2:45
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:55 build/C/man2/select_tut.2:49
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:58
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:60 build/C/man2/select_tut.2:54
#, no-wrap
msgid "B<void FD_CLR(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:62 build/C/man2/select_tut.2:56
#, no-wrap
msgid "B<int  FD_ISSET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:64 build/C/man2/select_tut.2:58
#, no-wrap
msgid "B<void FD_SET(int >I<fd>B<, fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:66 build/C/man2/select_tut.2:60
#, no-wrap
msgid "B<void FD_ZERO(fd_set *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:72
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<timeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:77 build/C/man2/select_tut.2:71 build/C/man3/sockatmark.3:36
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:81 build/C/man2/select_tut.2:75
msgid ""
"B<pselect>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ "
"600"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:92
msgid ""
"B<select>()  and B<pselect>()  allow a program to monitor multiple file "
"descriptors, waiting until one or more of the file descriptors become "
"\"ready\" for some class of I/O operation (e.g., input possible).  A file "
"descriptor is considered ready if it is possible to perform the "
"corresponding I/O operation (e.g., B<read>(2))  without blocking."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:98
msgid ""
"The operation of B<select>()  and B<pselect>()  is identical, other than "
"these three differences:"
msgstr ""

#. type: TP
#: build/C/man2/select.2:98
#, no-wrap
msgid "(i)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:108
msgid ""
"B<select>()  uses a timeout that is a I<struct timeval> (with seconds and "
"microseconds), while B<pselect>()  uses a I<struct timespec> (with seconds "
"and nanoseconds)."
msgstr ""

#. type: TP
#: build/C/man2/select.2:108
#, no-wrap
msgid "(ii)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:116
msgid ""
"B<select>()  may update the I<timeout> argument to indicate how much time "
"was left.  B<pselect>()  does not change this argument."
msgstr ""

#. type: TP
#: build/C/man2/select.2:116
#, no-wrap
msgid "(iii)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:125
msgid ""
"B<select>()  has no I<sigmask> argument, and behaves as B<pselect>()  called "
"with NULL I<sigmask>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:143
msgid ""
"Three independent sets of file descriptors are watched.  Those listed in "
"I<readfds> will be watched to see if characters become available for reading "
"(more precisely, to see if a read will not block; in particular, a file "
"descriptor is also ready on end-of-file), those in I<writefds> will be "
"watched to see if a write will not block, and those in I<exceptfds> will be "
"watched for exceptions.  On exit, the sets are modified in place to indicate "
"which file descriptors actually changed status.  Each of the three file "
"descriptor sets may be specified as NULL if no file descriptors are to be "
"watched for the corresponding class of events."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:156
msgid ""
"Four macros are provided to manipulate the sets.  B<FD_ZERO>()  clears a "
"set.  B<FD_SET>()  and B<FD_CLR>()  respectively add and remove a given file "
"descriptor from a set.  B<FD_ISSET>()  tests to see if a file descriptor is "
"part of the set; this is useful after B<select>()  returns."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:159
msgid ""
"I<nfds> is the highest-numbered file descriptor in any of the three sets, "
"plus 1."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:179
msgid ""
"The I<timeout> argument specifies the minimum interval that B<select>()  "
"should block waiting for a file descriptor to become ready.  (This interval "
"will be rounded up to the system clock granularity, and kernel scheduling "
"delays mean that the blocking interval may overrun by a small amount.)  If "
"both fields of the I<timeval> structure are zero, then B<select>()  returns "
"immediately.  (This is useful for polling.)  If I<timeout> is NULL (no "
"timeout), B<select>()  can block indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:189
msgid ""
"I<sigmask> is a pointer to a signal mask (see B<sigprocmask>(2)); if it is "
"not NULL, then B<pselect>()  first replaces the current signal mask by the "
"one pointed to by I<sigmask>, then does the \"select\" function, and then "
"restores the original signal mask."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:195
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<pselect>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:199
#, no-wrap
msgid ""
"    ready = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:204
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:207
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:211
#, no-wrap
msgid ""
"    pthread_sigmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = select(nfds, &readfds, &writefds, &exceptfds, timeout);\n"
"    pthread_sigmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:232
msgid ""
"The reason that B<pselect>()  is needed is that if one wants to wait for "
"either a signal or for a file descriptor to become ready, then an atomic "
"test is needed to prevent race conditions.  (Suppose the signal handler sets "
"a global flag and returns.  Then a test of this global flag followed by a "
"call of B<select>()  could hang indefinitely if the signal arrived just "
"after the test but just before the call.  By contrast, B<pselect>()  allows "
"one to first block signals, handle the signals that have come in, then call "
"B<pselect>()  with the desired I<sigmask>, avoiding the race.)"
msgstr ""

#. type: SS
#: build/C/man2/select.2:232
#, no-wrap
msgid "The timeout"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:236
msgid ""
"The time structures involved are defined in I<E<lt>sys/time.hE<gt>> and look "
"like"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:243
#, no-wrap
msgid ""
"struct timeval {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_usec;        /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:247
msgid "and"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:254
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:258
msgid "(However, see below on the POSIX.1-2001 versions.)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:266
msgid ""
"Some code calls B<select>()  with all three sets empty, I<nfds> zero, and a "
"non-NULL I<timeout> as a fairly portable way to sleep with subsecond "
"precision."
msgstr ""

#.  .PP - it is rumored that:
#.  On BSD, when a timeout occurs, the file descriptor bits are not changed.
#.  - it is certainly true that:
#.  Linux follows SUSv2 and sets the bit masks to zero upon a timeout.
#. type: Plain text
#: build/C/man2/select.2:289
msgid ""
"On Linux, B<select>()  modifies I<timeout> to reflect the amount of time not "
"slept; most other implementations do not do this.  (POSIX.1-2001 permits "
"either behavior.)  This causes problems both when Linux code which reads "
"I<timeout> is ported to other operating systems, and when code is ported to "
"Linux that reuses a I<struct timeval> for multiple B<select>()s in a loop "
"without reinitializing it.  Consider I<timeout> to be undefined after "
"B<select>()  returns."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:306
msgid ""
"On success, B<select>()  and B<pselect>()  return the number of file "
"descriptors contained in the three returned descriptor sets (that is, the "
"total number of bits that are set in I<readfds>, I<writefds>, I<exceptfds>)  "
"which may be zero if the timeout expires before anything interesting "
"happens.  On error, -1 is returned, and I<errno> is set appropriately; the "
"sets and I<timeout> become undefined, so do not rely on their contents after "
"an error."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:312
msgid ""
"An invalid file descriptor was given in one of the sets.  (Perhaps a file "
"descriptor that was already closed, or one on which an error has occurred.)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:316
msgid "A signal was caught; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:322
msgid "I<nfds> is negative or the value contained within I<timeout> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:325
msgid "unable to allocate memory for internal tables."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:331
msgid ""
"B<pselect>()  was added to Linux in kernel 2.6.16.  Prior to this, "
"B<pselect>()  was emulated in glibc (but see BUGS)."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:342
msgid ""
"B<select>()  conforms to POSIX.1-2001 and 4.4BSD (B<select>()  first "
"appeared in 4.2BSD).  Generally portable to/from non-BSD systems supporting "
"clones of the BSD socket layer (including System V variants).  However, note "
"that the System V variant typically sets the timeout variable before exit, "
"but the BSD variant does not."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:346
msgid "B<pselect>()  is defined in POSIX.1g, and in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:363
msgid ""
"An I<fd_set> is a fixed size buffer.  Executing B<FD_CLR>()  or B<FD_SET>()  "
"with a value of I<fd> that is negative or is equal to or larger than "
"B<FD_SETSIZE> will result in undefined behavior.  Moreover, POSIX requires "
"I<fd> to be a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:372
msgid ""
"Concerning the types involved, the classical situation is that the two "
"fields of a I<timeval> structure are typed as I<long> (as shown above), and "
"the structure is defined in I<E<lt>sys/time.hE<gt>>.  The POSIX.1-2001 "
"situation is"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:379
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t         tv_sec;     /* seconds */\n"
"    suseconds_t    tv_usec;    /* microseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:390
msgid ""
"where the structure is defined in I<E<lt>sys/select.hE<gt>> and the data "
"types I<time_t> and I<suseconds_t> are defined in I<E<lt>sys/types.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:402
msgid ""
"Concerning prototypes, the classical situation is that one should include "
"I<E<lt>time.hE<gt>> for B<select>().  The POSIX.1-2001 situation is that one "
"should include I<E<lt>sys/select.hE<gt>> for B<select>()  and B<pselect>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:414
msgid ""
"Libc4 and libc5 do not have a I<E<lt>sys/select.hE<gt>> header; under glibc "
"2.0 and later this header exists.  Under glibc 2.0 it unconditionally gives "
"the wrong prototype for B<pselect>().  Under glibc 2.1 to 2.2.1 it gives "
"B<pselect>()  when B<_GNU_SOURCE> is defined.  Since glibc 2.2.2 the "
"requirements are as shown in the SYNOPSIS."
msgstr ""

#. type: SS
#: build/C/man2/select.2:414
#, no-wrap
msgid "Multithreaded applications"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:430
msgid ""
"If a file descriptor being monitored by B<select>()  is closed in another "
"thread, the result is unspecified.  On some UNIX systems, B<select>()  "
"unblocks and returns, with an indication that the file descriptor is ready "
"(a subsequent I/O operation will likely fail with an error, unless another "
"the file descriptor reopened between the time B<select>()  returned and the "
"I/O operations was performed).  On Linux (and some other systems), closing "
"the file descriptor in another thread has no effect on B<select>().  In "
"summary, any application that relies on a particular behavior in this "
"scenario must be considered buggy."
msgstr ""

#. type: SS
#: build/C/man2/select.2:430
#, no-wrap
msgid "Linux notes"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:438
msgid ""
"The B<pselect>()  interface described in this page is implemented by glibc.  "
"The underlying Linux system call is named B<pselect6>().  This system call "
"has somewhat different behavior from the glibc wrapper function."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:453
msgid ""
"The Linux B<pselect6>()  system call modifies its I<timeout> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<pselect>()  function does not modify its I<timeout> argument; "
"this is the behavior required by POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:459
msgid ""
"The final argument of the B<pselect6>()  system call is not a I<sigset_t\\ "
"*> pointer, but is instead a structure of the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:467
#, no-wrap
msgid ""
"struct {\n"
"    const sigset_t *ss;     /* Pointer to signal set */\n"
"    size_t          ss_len; /* Size (in bytes) of object pointed\n"
"                               to by 'ss' */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:474
msgid ""
"This allows the system call to obtain both a pointer to the signal set and "
"its size, while allowing for the fact that most architectures support a "
"maximum of 6 arguments to a system call."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:480
msgid ""
"Glibc 2.0 provided a version of B<pselect>()  that did not take a I<sigmask> "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:493
msgid ""
"Starting with version 2.1, glibc provided an emulation of B<pselect>()  that "
"was implemented using B<sigprocmask>(2)  and B<select>().  This "
"implementation remained vulnerable to the very race condition that "
"B<pselect>()  was designed to prevent.  Modern versions of glibc use the "
"(race-free)  B<pselect>()  system call on kernels where it is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:506
msgid ""
"On systems that lack B<pselect>(), reliable (and more portable) signal "
"trapping can be achieved using the self-pipe trick.  In this technique, a "
"signal handler writes a byte to a pipe whose other end is monitored by "
"B<select>()  in the main program.  (To avoid possibly blocking when writing "
"to a pipe that may be full or reading from a pipe that may be empty, "
"nonblocking I/O is used when reading from and writing to the pipe.)"
msgstr ""

#.  Stevens discusses a case where accept can block after select
#.  returns successfully because of an intervening RST from the client.
#.  Maybe the kernel should have returned EIO in such a situation?
#. type: Plain text
#: build/C/man2/select.2:522
msgid ""
"Under Linux, B<select>()  may report a socket file descriptor as \"ready for "
"reading\", while nevertheless a subsequent read blocks.  This could for "
"example happen when data has arrived but upon examination has wrong checksum "
"and is discarded.  There may be other circumstances in which a file "
"descriptor is spuriously reported as ready.  Thus it may be safer to use "
"B<O_NONBLOCK> on sockets that should not block."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:537
msgid ""
"On Linux, B<select>()  also modifies I<timeout> if the call is interrupted "
"by a signal handler (i.e., the B<EINTR> error return).  This is not "
"permitted by POSIX.1-2001.  The Linux B<pselect>()  system call has the same "
"behavior, but the glibc wrapper hides this behavior by internally copying "
"the I<timeout> to a local variable and passing that variable to the system "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:544
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:551
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    fd_set rfds;\n"
"    struct timeval tv;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:555
#, no-wrap
msgid ""
"    /* Watch stdin (fd 0) to see when it has input. */\n"
"    FD_ZERO(&rfds);\n"
"    FD_SET(0, &rfds);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:559
#, no-wrap
msgid ""
"    /* Wait up to five seconds. */\n"
"    tv.tv_sec = 5;\n"
"    tv.tv_usec = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:562
#, no-wrap
msgid ""
"    retval = select(1, &rfds, NULL, NULL, &tv);\n"
"    /* Don't rely on the value of tv now! */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:570
#, no-wrap
msgid ""
"    if (retval == -1)\n"
"        perror(\"select()\");\n"
"    else if (retval)\n"
"        printf(\"Data is available now.\\en\");\n"
"        /* FD_ISSET(0, &rfds) will be true. */\n"
"    else\n"
"        printf(\"No data within five seconds.\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:585
msgid ""
"B<accept>(2), B<connect>(2), B<poll>(2), B<read>(2), B<recv>(2), B<send>(2), "
"B<sigprocmask>(2), B<write>(2), B<epoll>(7), B<time>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/select.2:588
msgid "For a tutorial with discussion and examples, see B<select_tut>(2)."
msgstr ""

#. type: TH
#: build/C/man2/select_tut.2:32
#, no-wrap
msgid "SELECT_TUT"
msgstr ""

#. type: TH
#: build/C/man2/select_tut.2:32
#, no-wrap
msgid "2012-08-03"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:52
#, no-wrap
msgid ""
"B<int select(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<           fd_set *>I<exceptfds>B<, struct timeval *>I<utimeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:66
#, no-wrap
msgid ""
"B<int pselect(int >I<nfds>B<, fd_set *>I<readfds>B<, fd_set "
"*>I<writefds>B<,>\n"
"B<            fd_set *>I<exceptfds>B<, const struct timespec "
"*>I<ntimeout>B<,>\n"
"B<            const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:83
msgid ""
"B<select>()  (or B<pselect>())  is used to efficiently monitor multiple file "
"descriptors, to see if any of them is, or becomes, \"ready\"; that is, to "
"see whether I/O becomes possible, or an \"exceptional condition\" has "
"occurred on any of the descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:108
msgid ""
"Its principal arguments are three \"sets\" of file descriptors: I<readfds>, "
"I<writefds>, and I<exceptfds>.  Each set is declared as type I<fd_set>, and "
"its contents can be manipulated with the macros B<FD_CLR>(), B<FD_ISSET>(), "
"B<FD_SET>(), and B<FD_ZERO>().  A newly declared set should first be cleared "
"using B<FD_ZERO>().  B<select>()  modifies the contents of the sets "
"according to the rules described below; after calling B<select>()  you can "
"test if a file descriptor is still present in a set with the B<FD_ISSET>()  "
"macro.  B<FD_ISSET>()  returns nonzero if a specified file descriptor is "
"present in a set and zero if it is not.  B<FD_CLR>()  removes a file "
"descriptor from a set."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:108
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:109
#, no-wrap
msgid "I<readfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:118
msgid ""
"This set is watched to see if data is available for reading from any of its "
"file descriptors.  After B<select>()  has returned, I<readfds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for reading."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:118
#, no-wrap
msgid "I<writefds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:127
msgid ""
"This set is watched to see if there is space to write data to any of its "
"file descriptors.  After B<select>()  has returned, I<writefds> will be "
"cleared of all file descriptors except for those that are immediately "
"available for writing."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:127
#, no-wrap
msgid "I<exceptfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:149
msgid ""
"This set is watched for \"exceptional conditions\".  In practice, only one "
"such exceptional condition is common: the availability of I<out-of-band> "
"(OOB) data for reading from a TCP socket.  See B<recv>(2), B<send>(2), and "
"B<tcp>(7)  for more details about OOB data.  (One other less common case "
"where B<select>(2)  indicates an exceptional condition occurs with "
"pseudoterminals in packet mode; see B<tty_ioctl>(4).)  After B<select>()  "
"has returned, I<exceptfds> will be cleared of all file descriptors except "
"for those for which an exceptional condition has occurred."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:149
#, no-wrap
msgid "I<nfds>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:156
msgid ""
"This is an integer one more than the maximum of any file descriptor in any "
"of the sets.  In other words, while adding file descriptors to each of the "
"sets, you must calculate the maximum integer value of all of them, then "
"increment this value by one, and then pass this as I<nfds>."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:156
#, no-wrap
msgid "I<utimeout>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:169
msgid ""
"This is the longest time B<select>()  may wait before returning, even if "
"nothing interesting happened.  If this value is passed as NULL, then "
"B<select>()  blocks indefinitely waiting for a file descriptor to become "
"ready.  I<utimeout> can be set to zero seconds, which causes B<select>()  to "
"return immediately, with information about the readiness of file descriptors "
"at the time of the call.  The structure I<struct timeval> is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:176
#, no-wrap
msgid ""
"struct timeval {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long tv_usec;     /* microseconds */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:178
#, no-wrap
msgid "I<ntimeout>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:187
msgid ""
"This argument for B<pselect>()  has the same meaning as I<utimeout>, but "
"I<struct timespec> has nanosecond precision as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:194
#, no-wrap
msgid ""
"struct timespec {\n"
"    long tv_sec;    /* seconds */\n"
"    long tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:196
#, no-wrap
msgid "I<sigmask>"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:213
msgid ""
"This argument holds a set of signals that the kernel should unblock (i.e., "
"remove from the signal mask of the calling thread), while the caller is "
"blocked inside the B<pselect>()  call (see B<sigaddset>(3)  and "
"B<sigprocmask>(2)).  It may be NULL, in which case the call does not modify "
"the signal mask on entry and exit to the function.  In this case, "
"B<pselect>()  will then behave just like B<select>()."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:213
#, no-wrap
msgid "Combining signal and data events"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:257
msgid ""
"B<pselect>()  is useful if you are waiting for a signal as well as for file "
"descriptor(s) to become ready for I/O.  Programs that receive signals "
"normally use the signal handler only to raise a global flag.  The global "
"flag will indicate that the event must be processed in the main loop of the "
"program.  A signal will cause the B<select>()  (or B<pselect>())  call to "
"return with I<errno> set to B<EINTR>.  This behavior is essential so that "
"signals can be processed in the main loop of the program, otherwise "
"B<select>()  would block indefinitely.  Now, somewhere in the main loop will "
"be a conditional to check the global flag.  So we must ask: what if a signal "
"arrives after the conditional, but before the B<select>()  call? The answer "
"is that B<select>()  would block indefinitely, even though an event is "
"actually pending.  This race condition is solved by the B<pselect>()  call.  "
"This call can be used to set the signal mask to a set of signals that are "
"only to be received within the B<pselect>()  call.  For instance, let us say "
"that the event in question was the exit of a child process.  Before the "
"start of the main loop, we would block B<SIGCHLD> using B<sigprocmask>(2).  "
"Our B<pselect>()  call would enable B<SIGCHLD> by using an empty signal "
"mask.  Our program would look like:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:260
#, no-wrap
msgid "static volatile sig_atomic_t got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:266
#, no-wrap
msgid ""
"static void\n"
"child_sig_handler(int sig)\n"
"{\n"
"    got_SIGCHLD = 1;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:274
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t sigmask, empty_mask;\n"
"    struct sigaction sa;\n"
"    fd_set readfds, writefds, exceptfds;\n"
"    int r;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:281
#, no-wrap
msgid ""
"    sigemptyset(&sigmask);\n"
"    sigaddset(&sigmask, SIGCHLD);\n"
"    if (sigprocmask(SIG_BLOCK, &sigmask, NULL) == -1) {\n"
"        perror(\"sigprocmask\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:289
#, no-wrap
msgid ""
"    sa.sa_flags = 0;\n"
"    sa.sa_handler = child_sig_handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIGCHLD, &sa, NULL) == -1) {\n"
"        perror(\"sigaction\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:291
#, no-wrap
msgid "    sigemptyset(&empty_mask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:295
#, no-wrap
msgid ""
"    for (;;) {          /* main loop */\n"
"        /* Initialize readfds, writefds, and exceptfds\n"
"           before the pselect() call. (Code omitted.) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:301
#, no-wrap
msgid ""
"        r = pselect(nfds, &readfds, &writefds, &exceptfds,\n"
"                    NULL, &empty_mask);\n"
"        if (r == -1 && errno != EINTR) {\n"
"            /* Handle error */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:304
#, no-wrap
msgid ""
"        if (got_SIGCHLD) {\n"
"            got_SIGCHLD = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:308
#, no-wrap
msgid ""
"            /* Handle signalled event here; e.g., wait() for all\n"
"               terminated children. (Code omitted.) */\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:312
#, no-wrap
msgid ""
"        /* main body of program */\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:313
#, no-wrap
msgid "Practical"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:334
msgid ""
"So what is the point of B<select>()? Can't I just read and write to my "
"descriptors whenever I want? The point of B<select>()  is that it watches "
"multiple descriptors at the same time and properly puts the process to sleep "
"if there is no activity.  UNIX programmers often find themselves in a "
"position where they have to handle I/O from more than one file descriptor "
"where the data flow may be intermittent.  If you were to merely create a "
"sequence of B<read>(2)  and B<write>(2)  calls, you would find that one of "
"your calls may block waiting for data from/to a file descriptor, while "
"another file descriptor is unused though ready for I/O.  B<select>()  "
"efficiently copes with this situation."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:334
#, no-wrap
msgid "Select law"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:347
msgid ""
"Many people who try to use B<select>()  come across behavior that is "
"difficult to understand and produces nonportable or borderline results.  For "
"instance, the above program is carefully written not to block at any point, "
"even though it does not set its file descriptors to nonblocking mode.  It is "
"easy to introduce subtle errors that will remove the advantage of using "
"B<select>(), so here is a list of essentials to watch for when using "
"B<select>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:356
msgid ""
"You should always try to use B<select>()  without a timeout.  Your program "
"should have nothing to do if there is no data available.  Code that depends "
"on timeouts is not usually portable and is difficult to debug."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:360
msgid ""
"The value I<nfds> must be properly calculated for efficiency as explained "
"above."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:367
msgid ""
"No file descriptor must be added to any set if you do not intend to check "
"its result after the B<select>()  call, and respond appropriately.  See next "
"rule."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:373
msgid ""
"After B<select>()  returns, all file descriptors in all sets should be "
"checked to see if they are ready."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:373
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:388
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  do I<not> "
"necessarily read/write the full amount of data that you have requested.  If "
"they do read/write the full amount, it's because you have a low traffic load "
"and a fast stream.  This is not always going to be the case.  You should "
"cope with the case of your functions managing to send or receive only a "
"single byte."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:388
#, no-wrap
msgid "6."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:396
msgid ""
"Never read/write only in single bytes at a time unless you are really sure "
"that you have a small amount of data to process.  It is extremely "
"inefficient not to read/write as much data as you can buffer each time.  The "
"buffers in the example below are 1024 bytes although they could easily be "
"made larger."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:396
#, no-wrap
msgid "7."
msgstr ""

#.  Nonetheless, you should still cope with these errors for completeness.
#. type: Plain text
#: build/C/man2/select_tut.2:418
msgid ""
"The functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  as well "
"as the B<select>()  call can return -1 with I<errno> set to B<EINTR>, or "
"with I<errno> set to B<EAGAIN> (B<EWOULDBLOCK>).  These results must be "
"properly managed (not done properly above).  If your program is not going to "
"receive any signals, then it is unlikely you will get B<EINTR>.  If your "
"program does not set nonblocking I/O, you will not get B<EAGAIN>."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:418
#, no-wrap
msgid "8."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:427
msgid ""
"Never call B<read>(2), B<recv>(2), B<write>(2), or B<send>(2)  with a buffer "
"length of zero."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:427
#, no-wrap
msgid "9."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:443
msgid ""
"If the functions B<read>(2), B<recv>(2), B<write>(2), and B<send>(2)  fail "
"with errors other than those listed in B<7.>, or one of the input functions "
"returns 0, indicating end of file, then you should I<not> pass that "
"descriptor to B<select>()  again.  In the example below, I close the "
"descriptor immediately, and then set it to -1 to prevent it being included "
"in a set."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:443
#, no-wrap
msgid "10."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:450
msgid ""
"The timeout value must be initialized with each new call to B<select>(), "
"since some operating systems modify the structure.  B<pselect>()  however "
"does not modify its timeout structure."
msgstr ""

#. type: TP
#: build/C/man2/select_tut.2:450
#, no-wrap
msgid "11."
msgstr ""

#.  "I have heard" does not fill me with confidence, and doesn't
#.  belong in a man page, so I've commented this point out.
#.  .TP
#.  11.
#.  I have heard that the Windows socket layer does not cope with OOB data
#.  properly.
#.  It also does not cope with
#.  .BR select ()
#.  calls when no file descriptors are set at all.
#.  Having no file descriptors set is a useful
#.  way to sleep the process with subsecond precision by using the timeout.
#.  (See further on.)
#. type: Plain text
#: build/C/man2/select_tut.2:469
msgid ""
"Since B<select>()  modifies its file descriptor sets, if the call is being "
"used in a loop, then the sets must be reinitialized before each call."
msgstr ""

#. type: SS
#: build/C/man2/select_tut.2:469
#, no-wrap
msgid "Usleep emulation"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:476
msgid ""
"On systems that do not have a B<usleep>(3)  function, you can call "
"B<select>()  with a finite timeout and no file descriptors as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:482
#, no-wrap
msgid ""
"    struct timeval tv;\n"
"    tv.tv_sec = 0;\n"
"    tv.tv_usec = 200000;  /* 0.2 seconds */\n"
"    select(0, NULL, NULL, NULL, &tv);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:485
msgid "This is guaranteed to work only on UNIX systems, however."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:490
msgid ""
"On success, B<select>()  returns the total number of file descriptors still "
"present in the file descriptor sets."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:496
msgid ""
"If B<select>()  timed out, then the return value will be zero.  The file "
"descriptors set should be all empty (but may not be on some systems)."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:503
msgid ""
"A return value of -1 indicates an error, with I<errno> being set "
"appropriately.  In the case of an error, the contents of the returned sets "
"and the I<struct timeout> contents are undefined and should not be used.  "
"B<pselect>()  however never modifies I<ntimeout>."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:512
msgid ""
"Generally speaking, all operating systems that support sockets also support "
"B<select>().  B<select>()  can be used to solve many problems in a portable "
"and efficient way that naive programmers try to solve in a more complicated "
"manner using threads, forking, IPCs, signals, memory sharing, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:521
msgid ""
"The B<poll>(2)  system call has the same functionality as B<select>(), and "
"is somewhat more efficient when monitoring sparse file descriptor sets.  It "
"is nowadays widely available, but historically was less portable than "
"B<select>()."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:529
msgid ""
"The Linux-specific B<epoll>(7)  API provides an interface that is more "
"efficient than B<select>(2)  and B<poll>(2)  when monitoring large numbers "
"of file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:534
msgid ""
"Here is an example that better demonstrates the true utility of "
"B<select>().  The listing below is a TCP forwarding program that forwards "
"from one TCP port to another."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:547
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/time.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netinet/in.hE<gt>\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:549
#, no-wrap
msgid "static int forward_port;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:552
#, no-wrap
msgid ""
"#undef max\n"
"#define max(x,y) ((x) E<gt> (y) ? (x) : (y))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:559
#, no-wrap
msgid ""
"static int\n"
"listen_socket(int listen_port)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
"    int yes;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:583
#, no-wrap
msgid ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        return -1;\n"
"    }\n"
"    yes = 1;\n"
"    if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR,\n"
"            &yes, sizeof(yes)) == -1) {\n"
"        perror(\"setsockopt\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(listen_port);\n"
"    a.sin_family = AF_INET;\n"
"    if (bind(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"bind\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    printf(\"accepting connections on port %d\\en\", listen_port);\n"
"    listen(s, 10);\n"
"    return s;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:589
#, no-wrap
msgid ""
"static int\n"
"connect_socket(int connect_port, char *address)\n"
"{\n"
"    struct sockaddr_in a;\n"
"    int s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:595
#, no-wrap
msgid ""
"    if ((s = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\n"
"        perror(\"socket\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:599
#, no-wrap
msgid ""
"    memset(&a, 0, sizeof(a));\n"
"    a.sin_port = htons(connect_port);\n"
"    a.sin_family = AF_INET;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:605
#, no-wrap
msgid ""
"    if (!inet_aton(address, (struct in_addr *) &a.sin_addr.s_addr)) {\n"
"        perror(\"bad IP address format\");\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:614
#, no-wrap
msgid ""
"    if (connect(s, (struct sockaddr *) &a, sizeof(a)) == -1) {\n"
"        perror(\"connect()\");\n"
"        shutdown(s, SHUT_RDWR);\n"
"        close(s);\n"
"        return -1;\n"
"    }\n"
"    return s;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:622
#, no-wrap
msgid ""
"#define SHUT_FD1 do {                                \\e\n"
"                     if (fd1 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd1, SHUT_RDWR);   \\e\n"
"                         close(fd1);                 \\e\n"
"                         fd1 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:630
#, no-wrap
msgid ""
"#define SHUT_FD2 do {                                \\e\n"
"                     if (fd2 E<gt>= 0) {                 \\e\n"
"                         shutdown(fd2, SHUT_RDWR);   \\e\n"
"                         close(fd2);                 \\e\n"
"                         fd2 = -1;                   \\e\n"
"                     }                               \\e\n"
"                 } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:632
#, no-wrap
msgid "#define BUF_SIZE 1024\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:641
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int h;\n"
"    int fd1 = -1, fd2 = -1;\n"
"    char buf1[BUF_SIZE], buf2[BUF_SIZE];\n"
"    int buf1_avail, buf1_written;\n"
"    int buf2_avail, buf2_written;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:647
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage\\en\\etfwd E<lt>listen-portE<gt> \"\n"
"                 \"E<lt>forward-to-portE<gt> "
"E<lt>forward-to-ip-addressE<gt>\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:649
#, no-wrap
msgid "    signal(SIGPIPE, SIG_IGN);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:651
#, no-wrap
msgid "    forward_port = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:655
#, no-wrap
msgid ""
"    h = listen_socket(atoi(argv[1]));\n"
"    if (h == -1)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:659
#, no-wrap
msgid ""
"    for (;;) {\n"
"        int r, nfds = 0;\n"
"        fd_set rd, wr, er;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:689
#, no-wrap
msgid ""
"        FD_ZERO(&rd);\n"
"        FD_ZERO(&wr);\n"
"        FD_ZERO(&er);\n"
"        FD_SET(h, &rd);\n"
"        nfds = max(nfds, h);\n"
"        if (fd1 E<gt> 0 && buf1_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd1, &rd);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf2_avail E<lt> BUF_SIZE) {\n"
"            FD_SET(fd2, &rd);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0 && buf2_avail - buf2_written E<gt> 0) {\n"
"            FD_SET(fd1, &wr);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0 && buf1_avail - buf1_written E<gt> 0) {\n"
"            FD_SET(fd2, &wr);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
"        if (fd1 E<gt> 0) {\n"
"            FD_SET(fd1, &er);\n"
"            nfds = max(nfds, fd1);\n"
"        }\n"
"        if (fd2 E<gt> 0) {\n"
"            FD_SET(fd2, &er);\n"
"            nfds = max(nfds, fd2);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:691
#, no-wrap
msgid "        r = select(nfds + 1, &rd, &wr, &er, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:694
#, no-wrap
msgid ""
"        if (r == -1 && errno == EINTR)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:699
#, no-wrap
msgid ""
"        if (r == -1) {\n"
"            perror(\"select()\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:703
#, no-wrap
msgid ""
"        if (FD_ISSET(h, &rd)) {\n"
"            unsigned int l;\n"
"            struct sockaddr_in client_address;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:722
#, no-wrap
msgid ""
"            memset(&client_address, 0, l = sizeof(client_address));\n"
"            r = accept(h, (struct sockaddr *) &client_address, &l);\n"
"            if (r == -1) {\n"
"                perror(\"accept()\");\n"
"            } else {\n"
"                SHUT_FD1;\n"
"                SHUT_FD2;\n"
"                buf1_avail = buf1_written = 0;\n"
"                buf2_avail = buf2_written = 0;\n"
"                fd1 = r;\n"
"                fd2 = connect_socket(forward_port, argv[3]);\n"
"                if (fd2 == -1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    printf(\"connect from %s\\en\",\n"
"                            inet_ntoa(client_address.sin_addr));\n"
"            }\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:724
#, no-wrap
msgid "        /* NB: read oob data before normal reads */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:728
#, no-wrap
msgid ""
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &er)) {\n"
"                char c;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:738
#, no-wrap
msgid ""
"                r = recv(fd1, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    send(fd2, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &er)) {\n"
"                char c;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:781
#, no-wrap
msgid ""
"                r = recv(fd2, &c, 1, MSG_OOB);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    send(fd1, &c, 1, MSG_OOB);\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &rd)) {\n"
"                r = read(fd1, buf1 + buf1_avail,\n"
"                          BUF_SIZE - buf1_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf1_avail += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &rd)) {\n"
"                r = read(fd2, buf2 + buf2_avail,\n"
"                          BUF_SIZE - buf2_avail);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf2_avail += r;\n"
"            }\n"
"        if (fd1 E<gt> 0)\n"
"            if (FD_ISSET(fd1, &wr)) {\n"
"                r = write(fd1, buf2 + buf2_written,\n"
"                           buf2_avail - buf2_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD1;\n"
"                else\n"
"                    buf2_written += r;\n"
"            }\n"
"        if (fd2 E<gt> 0)\n"
"            if (FD_ISSET(fd2, &wr)) {\n"
"                r = write(fd2, buf1 + buf1_written,\n"
"                           buf1_avail - buf1_written);\n"
"                if (r E<lt> 1)\n"
"                    SHUT_FD2;\n"
"                else\n"
"                    buf1_written += r;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:783
#, no-wrap
msgid "        /* check if write data has caught read data */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:788
#, no-wrap
msgid ""
"        if (buf1_written == buf1_avail)\n"
"            buf1_written = buf1_avail = 0;\n"
"        if (buf2_written == buf2_avail)\n"
"            buf2_written = buf2_avail = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:791
#, no-wrap
msgid ""
"        /* one side has closed the connection, keep\n"
"           writing to the other side until empty */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:799
#, no-wrap
msgid ""
"        if (fd1 E<lt> 0 && buf1_avail - buf1_written == 0)\n"
"            SHUT_FD2;\n"
"        if (fd2 E<lt> 0 && buf2_avail - buf2_written == 0)\n"
"            SHUT_FD1;\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:813
msgid ""
"The above program properly forwards most kinds of TCP connections including "
"OOB signal data transmitted by B<telnet> servers.  It handles the tricky "
"problem of having data flow in both directions simultaneously.  You might "
"think it more efficient to use a B<fork>(2)  call and devote a thread to "
"each stream.  This becomes more tricky than you might suspect.  Another idea "
"is to set nonblocking I/O using B<fcntl>(2).  This also has its problems "
"because you end up using inefficient timeouts."
msgstr ""

#. type: Plain text
#: build/C/man2/select_tut.2:819
msgid ""
"The program does not handle more than one simultaneous connection at a time, "
"although it could easily be extended to do this with a linked list of "
"buffers\\(emone for each connection.  At the moment, new connections cause "
"the current connection to be dropped."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Paul Sheer.
#. type: Plain text
#: build/C/man2/select_tut.2:838
msgid ""
"B<accept>(2), B<connect>(2), B<ioctl>(2), B<poll>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<sigprocmask>(2), B<write>(2), "
"B<sigaddset>(3), B<sigdelset>(3), B<sigemptyset>(3), B<sigfillset>(3), "
"B<sigismember>(3), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/send.2:40
#, no-wrap
msgid "SEND"
msgstr ""

#. type: TH
#: build/C/man2/send.2:40
#, no-wrap
msgid "2012-04-23"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:43
msgid "send, sendto, sendmsg - send a message on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:47
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:50
#, no-wrap
msgid ""
"B<ssize_t send(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:54
#, no-wrap
msgid ""
"B<ssize_t sendto(int >I<sockfd>B<, const void *>I<buf>B<, size_t >I<len>B<, "
"int >I<flags>B<,>\n"
"B<               const struct sockaddr *>I<dest_addr>B<, socklen_t "
">I<addrlen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:57
#, no-wrap
msgid ""
"B<ssize_t sendmsg(int >I<sockfd>B<, const struct msghdr *>I<msg>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:65
msgid ""
"The system calls B<send>(), B<sendto>(), and B<sendmsg>()  are used to "
"transmit a message to another socket."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:84
msgid ""
"The B<send>()  call may be used only when the socket is in a I<connected> "
"state (so that the intended recipient is known).  The only difference "
"between B<send>()  and B<write>(2)  is the presence of I<flags>.  With a "
"zero I<flags> argument, B<send>()  is equivalent to B<write>(2).  Also, the "
"following call"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:86
#, no-wrap
msgid "    send(sockfd, buf, len, flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:88
msgid "is equivalent to"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:90
#, no-wrap
msgid "    sendto(sockfd, buf, len, flags, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:94
msgid "The argument I<sockfd> is the file descriptor of the sending socket."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:122
msgid ""
"If B<sendto>()  is used on a connection-mode (B<SOCK_STREAM>, "
"B<SOCK_SEQPACKET>)  socket, the arguments I<dest_addr> and I<addrlen> are "
"ignored (and the error B<EISCONN> may be returned when they are not NULL and "
"0), and the error B<ENOTCONN> is returned when the socket was not actually "
"connected.  Otherwise, the address of the target is given by I<dest_addr> "
"with I<addrlen> specifying its size.  For B<sendmsg>(), the address of the "
"target is given by I<msg.msg_name>, with I<msg.msg_namelen> specifying its "
"size."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:138
msgid ""
"For B<send>()  and B<sendto>(), the message is found in I<buf> and has "
"length I<len>.  For B<sendmsg>(), the message is pointed to by the elements "
"of the array I<msg.msg_iov>.  The B<sendmsg>()  call also allows sending "
"ancillary data (also known as control information)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:143
msgid ""
"If the message is too long to pass atomically through the underlying "
"protocol, the error B<EMSGSIZE> is returned, and the message is not "
"transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:147
msgid ""
"No indication of failure to deliver is implicit in a B<send>().  Locally "
"detected errors are indicated by a return value of -1."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:160
msgid ""
"When the message does not fit into the send buffer of the socket, B<send>()  "
"normally blocks, unless the socket has been placed in nonblocking I/O mode.  "
"In nonblocking mode it would fail with the error B<EAGAIN> or B<EWOULDBLOCK> "
"in this case.  The B<select>(2)  call may be used to determine when it is "
"possible to send more data."
msgstr ""

#.  FIXME ? document MSG_PROXY (which went away in 2.3.15)
#. type: Plain text
#: build/C/man2/send.2:166
msgid ""
"The I<flags> argument is the bitwise OR of zero or more of the following "
"flags."
msgstr ""

#. type: TP
#: build/C/man2/send.2:166
#, no-wrap
msgid "B<MSG_CONFIRM> (Since Linux 2.3.15)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:180
msgid ""
"Tell the link layer that forward progress happened: you got a successful "
"reply from the other side.  If the link layer doesn't get this it will "
"regularly reprobe the neighbor (e.g., via a unicast ARP).  Only valid on "
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets and currently implemented only for "
"IPv4 and IPv6.  See B<arp>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man2/send.2:180
#, no-wrap
msgid "B<MSG_DONTROUTE>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:188
msgid ""
"Don't use a gateway to send out the packet, send to hosts only on directly "
"connected networks.  This is usually used only by diagnostic or routing "
"programs.  This is defined only for protocol families that route; packet "
"sockets don't."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:199
msgid ""
"Enables nonblocking operation; if the operation would block, B<EAGAIN> or "
"B<EWOULDBLOCK> is returned (this can also be enabled using the B<O_NONBLOCK> "
"flag with the B<F_SETFL> B<fcntl>(2))."
msgstr ""

#. type: TP
#: build/C/man2/send.2:199
#, no-wrap
msgid "B<MSG_EOR> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:203
msgid ""
"Terminates a record (when this notion is supported, as for sockets of type "
"B<SOCK_SEQPACKET>)."
msgstr ""

#. type: TP
#: build/C/man2/send.2:203
#, no-wrap
msgid "B<MSG_MORE> (Since Linux 2.4.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:212
msgid ""
"The caller has more data to send.  This flag is used with TCP sockets to "
"obtain the same effect as the B<TCP_CORK> socket option (see B<tcp>(7)), "
"with the difference that this flag can be set on a per-call basis."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:221
msgid ""
"Since Linux 2.6, this flag is also supported for UDP sockets, and informs "
"the kernel to package all of the data sent in calls with this flag set into "
"a single datagram which is transmitted only when a call is performed that "
"does not specify this flag.  (See also the B<UDP_CORK> socket option "
"described in B<udp>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/send.2:221
#, no-wrap
msgid "B<MSG_NOSIGNAL> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:230
msgid ""
"Requests not to send B<SIGPIPE> on errors on stream oriented sockets when "
"the other end breaks the connection.  The B<EPIPE> error is still returned."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:239
msgid ""
"Sends I<out-of-band> data on sockets that support this notion (e.g., of type "
"B<SOCK_STREAM>); the underlying protocol must also support I<out-of-band> "
"data."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:246
msgid ""
"The definition of the I<msghdr> structure follows.  See B<recv>(2)  and "
"below for an exact description of its fields."
msgstr ""

#.  Still to be documented:
#.   Send file descriptors and user credentials using the
#.   msg_control* fields.
#.   The flags returned in msg_flags.
#. type: Plain text
#: build/C/man2/send.2:275
msgid ""
"You may send control information using the I<msg_control> and "
"I<msg_controllen> members.  The maximum control buffer length the kernel can "
"process is limited per socket by the value in "
"I</proc/sys/net/core/optmem_max>; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:280
msgid ""
"On success, these calls return the number of characters sent.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:285
msgid ""
"These are some standard errors generated by the socket layer.  Additional "
"errors may be generated and returned from the underlying protocol modules; "
"see their respective manual pages."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:293
msgid ""
"(For UNIX domain sockets, which are identified by pathname)  Write "
"permission is denied on the destination socket file, or search permission is "
"denied for one of the directories the path prefix.  (See "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:296
msgid ""
"(For UDP sockets) An attempt was made to send to a network/broadcast address "
"as though it was a unicast address."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/send.2:304
msgid ""
"The socket is marked nonblocking and the requested operation would block.  "
"POSIX.1-2001 allows either error to be returned for this case, and does not "
"require these constants to have the same value, so a portable application "
"should check for both possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:307
msgid "An invalid descriptor was specified."
msgstr ""

#. type: TP
#: build/C/man2/send.2:307
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:310
msgid "Connection reset by peer."
msgstr ""

#. type: TP
#: build/C/man2/send.2:310
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:313
msgid "The socket is not connection-mode, and no peer address is set."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:316
msgid "An invalid user space address was specified for an argument."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:320
msgid "A signal occurred before any data was transmitted; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:329
msgid ""
"The connection-mode socket was connected already but a recipient was "
"specified.  (Now either this error is returned, or the recipient "
"specification is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/send.2:329
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#.  (e.g., SOCK_DGRAM )
#. type: Plain text
#: build/C/man2/send.2:335
msgid ""
"The socket type requires that message be sent atomically, and the size of "
"the message to be sent made this impossible."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:343
msgid ""
"The output queue for a network interface was full.  This generally indicates "
"that the interface has stopped sending, but may be caused by transient "
"congestion.  (Normally, this does not occur in Linux.  Packets are just "
"silently dropped when a device queue overflows.)"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:346
msgid "No memory available."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:349
msgid "The socket is not connected, and no target has been given."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:359
msgid "Some bit in the I<flags> argument is inappropriate for the socket type."
msgstr ""

#. type: TP
#: build/C/man2/send.2:359
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:368
msgid ""
"The local end has been shut down on a connection oriented socket.  In this "
"case the process will also receive a B<SIGPIPE> unless B<MSG_NOSIGNAL> is "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:371
msgid "4.4BSD, SVr4, POSIX.1-2001.  These function calls appeared in 4.2BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:382
msgid ""
"POSIX.1-2001 describes only the B<MSG_OOB> and B<MSG_EOR> flags.  "
"POSIX.1-2008 adds a specification of B<MSG_NOSIGNAL>.  The B<MSG_CONFIRM> "
"flag is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:395
msgid ""
"The prototypes given above follow the Single UNIX Specification, as glibc2 "
"also does; the I<flags> argument was I<int> in 4.x BSD, but I<unsigned int> "
"in libc4 and libc5; the I<len> argument was I<int> in 4.x BSD and libc4, but "
"I<size_t> in libc5; the I<addrlen> argument was I<int> in 4.x BSD and libc4 "
"and libc5.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:414
msgid ""
"See B<sendmmsg>(2)  for information about a Linux-specific system call that "
"can be used to transmit multiple datagrams in a single call."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:419
msgid "Linux may return B<EPIPE> instead of B<ENOTCONN>."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:424
msgid "An example of the use of B<sendto>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/send.2:439
msgid ""
"B<fcntl>(2), B<getsockopt>(2), B<recv>(2), B<select>(2), B<sendfile>(2), "
"B<sendmmsg>(2), B<shutdown>(2), B<socket>(2), B<write>(2), B<cmsg>(3), "
"B<ip>(7), B<socket>(7), B<tcp>(7), B<udp>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "SENDMMSG"
msgstr ""

#. type: TH
#: build/C/man2/sendmmsg.2:28
#, no-wrap
msgid "2012-12-16"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:31
msgid "sendmmsg - send multiple messages on a socket"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:39
#, no-wrap
msgid ""
"B<int sendmmsg(int >I<sockfd>B<, struct mmsghdr *>I<msgvec>B<, unsigned int "
">I<vlen>B<,>\n"
"B<             unsigned int >I<flags>B<);>\n"
msgstr ""

#.  See commit 228e548e602061b08ee8e8966f567c12aa079682
#. type: Plain text
#: build/C/man2/sendmmsg.2:49
msgid ""
"The B<sendmmsg>()  system call is an extension of B<sendmsg>(2)  that allows "
"the caller to transmit multiple messages on a socket using a single system "
"call.  (This has performance benefits for some applications.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:54
msgid ""
"The I<sockfd> argument is the file descriptor of the socket on which data is "
"to be transmitted."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:75
#, no-wrap
msgid ""
"struct mmsghdr {\n"
"    struct msghdr msg_hdr;  /* Message header */\n"
"    unsigned int  msg_len;  /* Number of bytes transmitted */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:91
msgid ""
"The I<msg_hdr> field is a I<msghdr> structure, as described in "
"B<sendmsg>(2).  The I<msg_len> field is used to return the number of bytes "
"sent from the message in I<msg_hdr> (i.e., the same as the return value from "
"a single B<sendmsg>(2)  call)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:97
msgid ""
"The I<flags> argument contains flags ORed together.  The flags are the same "
"as for B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:107
msgid ""
"A blocking B<sendmmsg>()  call blocks until I<vlen> messages have been "
"sent.  A nonblocking call sends as many messages as possible (up to the "
"limit specified by I<vlen>)  and returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:119
msgid ""
"On return from B<sendmmsg>(), the I<msg_len> fields of successive elements "
"of I<msgvec> are updated to contain the number of bytes transmitted from the "
"corresponding I<msg_hdr>.  The return value of the call indicates the number "
"of elements of I<msgvec> that have been updated."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:129
msgid ""
"On success, B<sendmmsg>()  returns the number of messages sent from "
"I<msgvec>; if this is less than I<vlen>, the caller can retry with a further "
"B<sendmmsg>()  call to send the remaining messages."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:133
msgid "On error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#.  commit 728ffb86f10873aaf4abd26dde691ee40ae731fe
#.      ... only return an error if no datagrams could be sent.
#.      If less than the requested number of messages were sent, the application
#.      must retry starting at the first failed one and if the problem is
#.      persistent the error will be returned.
#
#.      This matches the behaviour of other syscalls like read/write - it
#.      is not an error if less than the requested number of elements are sent.
#. type: Plain text
#: build/C/man2/sendmmsg.2:145
msgid ""
"Errors are as for B<sendmsg>(2).  An error is returned only if no datagrams "
"could be sent."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:150
msgid ""
"The B<sendmmsg>()  system call was added in Linux 3.0.  Support in glibc was "
"added in version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:153
msgid "B<sendmmsg>()  is Linux-specific."
msgstr ""

#.  commit 98382f419f32d2c12d021943b87dea555677144b
#.      net: Cap number of elements for sendmmsg
#
#.      To limit the amount of time we can spend in sendmmsg, cap the
#.      number of elements to UIO_MAXIOV (currently 1024).
#
#.      For error handling an application using sendmmsg needs to retry at
#.      the first unsent message, so capping is simpler and requires less
#.      application logic than returning EINVAL.
#. type: Plain text
#: build/C/man2/sendmmsg.2:168
msgid "The value specified in I<vlen> is capped to B<UIO_MAXIOV> (1024)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:177
msgid ""
"The example below uses B<sendmmsg>()  to send I<onetwo> and I<three> in two "
"distinct UDP datagrams using one system call.  The contents of the first "
"datagram originates from a pair of buffers."
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:186
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netinet/ip.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:195
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int sockfd;\n"
"    struct sockaddr_in sa;\n"
"    struct mmsghdr msg[2];\n"
"    struct iovec msg1[2], msg2;\n"
"    int retval;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:209
#, no-wrap
msgid ""
"    sa.sin_family = AF_INET;\n"
"    sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n"
"    sa.sin_port = htons(1234);\n"
"    if (connect(sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1) {\n"
"        perror(\"connect()\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:215
#, no-wrap
msgid ""
"    memset(msg1, 0, sizeof(msg1));\n"
"    msg1[0].iov_base = \"one\";\n"
"    msg1[0].iov_len = 3;\n"
"    msg1[1].iov_base = \"two\";\n"
"    msg1[1].iov_len = 3;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:219
#, no-wrap
msgid ""
"    memset(&msg2, 0, sizeof(msg2));\n"
"    msg2.iov_base = \"three\";\n"
"    msg2.iov_len = 5;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:223
#, no-wrap
msgid ""
"    memset(msg, 0, sizeof(msg));\n"
"    msg[0].msg_hdr.msg_iov = msg1;\n"
"    msg[0].msg_hdr.msg_iovlen = 2;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:226
#, no-wrap
msgid ""
"    msg[1].msg_hdr.msg_iov = &msg2;\n"
"    msg[1].msg_hdr.msg_iovlen = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:232
#, no-wrap
msgid ""
"    retval = sendmmsg(sockfd, msg, 2, 0);\n"
"    if (retval == -1)\n"
"        perror(\"sendmmsg()\");\n"
"    else\n"
"        printf(\"%d messages sent\\en\", retval);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:235
#, no-wrap
msgid ""
"    exit(0);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sendmmsg.2:241
msgid "B<recvmmsg>(2), B<sendmsg>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man3/sockatmark.3:25
#, no-wrap
msgid "SOCKATMARK"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:28
msgid "sockatmark - determine whether socket is at out-of-band mark"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:30 build/C/man2/socket.2:50 build/C/man7/socket.7:50 build/C/man2/socketpair.2:49
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:32
msgid "B<int sockatmark(int >I<sockfd>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:41
msgid ""
"B<sockatmark>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:51
msgid ""
"B<sockatmark>()  returns a value indicating whether or not the socket "
"referred to by the file descriptor I<sockfd> is at the out-of-band mark.  If "
"the socket is at the mark, then 1 is returned; if the socket is not at the "
"mark, 0 is returned.  This function does not remove the out-of-band mark."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:58
msgid ""
"A successful call to B<sockatmark>()  returns 1 if the socket is at the "
"out-of-band mark, or 0 if it is not.  On error, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:63
msgid "I<sockfd> is not a valid file descriptor."
msgstr ""

#.  POSIX.1 says ENOTTY for this case
#. type: Plain text
#: build/C/man3/sockatmark.3:70
msgid "I<sockfd> is not a file descriptor to which B<sockatmark>()  can be applied."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:73
msgid "B<sockatmark>()  was added to glibc in version 2.2.4."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:75
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:82
msgid ""
"If B<sockatmark>()  returns 1, then the out-of-band data can be read using "
"the B<MSG_OOB> flag of B<recv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:84
msgid "Out-of-band data is supported only on some stream socket protocols."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:89
msgid ""
"B<sockatmark>()  can safely be called from a handler for the B<SIGURG> "
"signal."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:95
msgid ""
"B<sockatmark>()  is implemented using the B<SIOCATMARK> B<ioctl>(2)  "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:99
msgid "Prior to glibc 2.4, B<sockatmark>()  did not work."
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:104
msgid ""
"The following code can be used after receipt of a B<SIGURG> signal to read "
"(and discard) all data up to the mark, and then read the byte of data at the "
"mark:"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:109
#, no-wrap
msgid ""
"    char buf[BUF_LEN];\n"
"    char oobdata;\n"
"    int atmark, s;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:116
#, no-wrap
msgid ""
"    for (;;) {\n"
"        atmark = sockatmark(sockfd);\n"
"        if (atmark == -1) {\n"
"            perror(\"sockatmark\");\n"
"            break;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:119
#, no-wrap
msgid ""
"        if (atmark)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:126
#, no-wrap
msgid ""
"        s = read(sockfd, buf, BUF_LEN) E<lt>= 0);\n"
"        if (s == -1)\n"
"            perror(\"read\");\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:133
#, no-wrap
msgid ""
"    if (atmark == 1) {\n"
"        if (recv(sockfd, &oobdata, 1, MSG_OOB) == -1) {\n"
"            perror(\"recv\");\n"
"            ...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sockatmark.3:139
msgid "B<fcntl>(2), B<recv>(2), B<send>(2), B<tcp>(7)"
msgstr ""

#. type: TH
#: build/C/man2/socket.2:43 build/C/man7/socket.7:45
#, no-wrap
msgid "SOCKET"
msgstr ""

#. type: TH
#: build/C/man2/socket.2:43
#, no-wrap
msgid "2009-01-19"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:46
msgid "socket - create an endpoint for communication"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:48 build/C/man2/socketpair.2:47
msgid "B<#include E<lt>sys/types.hE<gt>> /* See NOTES */"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:52
msgid "B<int socket(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:55
msgid "B<socket>()  creates an endpoint for communication and returns a descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:63
msgid ""
"The I<domain> argument specifies a communication domain; this selects the "
"protocol family which will be used for communication.  These families are "
"defined in I<E<lt>sys/socket.hE<gt>>.  The currently understood formats "
"include:"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:66
#, no-wrap
msgid "Name:Purpose:Man page\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:67 build/C/man2/socket.2:74 build/C/man2/socket.2:79 build/C/man2/socket.2:84 build/C/man2/socket.2:87 build/C/man2/socket.2:94 build/C/man2/socket.2:99 build/C/man2/socket.2:104 build/C/man2/socket.2:107 build/C/man2/socket.2:112
#, no-wrap
msgid "T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:68
#, no-wrap
msgid "B<AF_UNIX>, B<AF_LOCAL>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:69 build/C/man2/socket.2:71 build/C/man2/socket.2:89 build/C/man2/socket.2:91 build/C/man2/socket.2:101 build/C/man2/socket.2:114 build/C/man2/socket.2:116 build/C/man7/socket.7:181
#, no-wrap
msgid "T}:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:70
#, no-wrap
msgid "Local communication\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:72
#, no-wrap
msgid "B<unix>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:73 build/C/man2/socket.2:78 build/C/man2/socket.2:83 build/C/man2/socket.2:93 build/C/man2/socket.2:98 build/C/man2/socket.2:111 build/C/man2/socket.2:118 build/C/man7/socket.7:160 build/C/man7/socket.7:164 build/C/man7/socket.7:167 build/C/man7/socket.7:173 build/C/man7/socket.7:176 build/C/man7/socket.7:185 build/C/man7/socket.7:192
#, no-wrap
msgid "T}\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:75
#, no-wrap
msgid "B<AF_INET>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:76
#, no-wrap
msgid "T}:IPv4 Internet protocols:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:77
#, no-wrap
msgid "B<ip>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:80
#, no-wrap
msgid "B<AF_INET6>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:81
#, no-wrap
msgid "T}:IPv6 Internet protocols:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:82
#, no-wrap
msgid "B<ipv6>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:85
#, no-wrap
msgid "B<AF_IPX>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:86
#, no-wrap
msgid "T}:IPX - Novell protocols:\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:88
#, no-wrap
msgid "B<AF_NETLINK>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:90
#, no-wrap
msgid "Kernel user interface device\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:92
#, no-wrap
msgid "B<netlink>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:95
#, no-wrap
msgid "B<AF_X25>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:96
#, no-wrap
msgid "T}:ITU-T X.25 / ISO-8208 protocol:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:97
#, no-wrap
msgid "B<x25>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:100
#, no-wrap
msgid "B<AF_AX25>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:102
#, no-wrap
msgid "Amateur radio AX.25 protocol\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:103
#, no-wrap
msgid "T}:\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:105
#, no-wrap
msgid "B<AF_ATMPVC>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:106
#, no-wrap
msgid "T}:Access to raw ATM PVCs:\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:108
#, no-wrap
msgid "B<AF_APPLETALK>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:109
#, no-wrap
msgid "T}:Appletalk:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:110
#, no-wrap
msgid "B<ddp>(7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:113
#, no-wrap
msgid "B<AF_PACKET>\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:115
#, no-wrap
msgid "Low level packet interface\n"
msgstr ""

#. type: tbl table
#: build/C/man2/socket.2:117
#, no-wrap
msgid "B<packet>(7)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:126
msgid ""
"The socket has the indicated I<type>, which specifies the communication "
"semantics.  Currently defined types are:"
msgstr ""

#. type: TP
#: build/C/man2/socket.2:126
#, no-wrap
msgid "B<SOCK_STREAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:130
msgid ""
"Provides sequenced, reliable, two-way, connection-based byte streams.  An "
"out-of-band data transmission mechanism may be supported."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:130
#, no-wrap
msgid "B<SOCK_DGRAM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:134
msgid ""
"Supports datagrams (connectionless, unreliable messages of a fixed maximum "
"length)."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:134
#, no-wrap
msgid "B<SOCK_SEQPACKET>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:139
msgid ""
"Provides a sequenced, reliable, two-way connection-based data transmission "
"path for datagrams of fixed maximum length; a consumer is required to read "
"an entire packet with each input system call."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:139
#, no-wrap
msgid "B<SOCK_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:142
msgid "Provides raw network protocol access."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:142
#, no-wrap
msgid "B<SOCK_RDM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:145
msgid "Provides a reliable datagram layer that does not guarantee ordering."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:145
#, no-wrap
msgid "B<SOCK_PACKET>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:150
msgid "Obsolete and should not be used in new programs; see B<packet>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:156
msgid ""
"Some socket types may not be implemented by all protocol families; for "
"example, B<SOCK_SEQPACKET> is not implemented for B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:164
msgid ""
"Since Linux 2.6.27, the I<type> argument serves a second purpose: in "
"addition to specifying a socket type, it may include the bitwise OR of any "
"of the following values, to modify the behavior of B<socket>():"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:198
msgid ""
"The I<protocol> specifies a particular protocol to be used with the socket.  "
"Normally only a single protocol exists to support a particular socket type "
"within a given protocol family, in which case I<protocol> can be specified "
"as 0.  However, it is possible that many protocols may exist, in which case "
"a particular protocol must be specified in this manner.  The protocol number "
"to use is specific to the ``communication domain'' in which communication is "
"to take place; see B<protocols>(5).  See B<getprotoent>(3)  on how to map "
"protocol name strings to protocol numbers."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:228
msgid ""
"Sockets of type B<SOCK_STREAM> are full-duplex byte streams, similar to "
"pipes.  They do not preserve record boundaries.  A stream socket must be in "
"a I<connected> state before any data may be sent or received on it.  A "
"connection to another socket is created with a B<connect>(2)  call.  Once "
"connected, data may be transferred using B<read>(2)  and B<write>(2)  calls "
"or some variant of the B<send>(2)  and B<recv>(2)  calls.  When a session "
"has been completed a B<close>(2)  may be performed.  Out-of-band data may "
"also be transmitted as described in B<send>(2)  and received as described in "
"B<recv>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:254
msgid ""
"The communications protocols which implement a B<SOCK_STREAM> ensure that "
"data is not lost or duplicated.  If a piece of data for which the peer "
"protocol has buffer space cannot be successfully transmitted within a "
"reasonable length of time, then the connection is considered to be dead.  "
"When B<SO_KEEPALIVE> is enabled on the socket the protocol checks in a "
"protocol-specific manner if the other end is still alive.  A B<SIGPIPE> "
"signal is raised if a process sends or receives on a broken stream; this "
"causes naive processes, which do not handle the signal, to exit.  "
"B<SOCK_SEQPACKET> sockets employ the same system calls as B<SOCK_STREAM> "
"sockets.  The only difference is that B<read>(2)  calls will return only the "
"amount of data requested, and any data remaining in the arriving packet will "
"be discarded.  Also all message boundaries in incoming datagrams are "
"preserved."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:264
msgid ""
"B<SOCK_DGRAM> and B<SOCK_RAW> sockets allow sending of datagrams to "
"correspondents named in B<sendto>(2)  calls.  Datagrams are generally "
"received with B<recvfrom>(2), which returns the next datagram along with the "
"address of its sender."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:271
msgid ""
"B<SOCK_PACKET> is an obsolete socket type to receive raw packets directly "
"from the device driver.  Use B<packet>(7)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:294
msgid ""
"An B<fcntl>(2)  B<F_SETOWN> operation can be used to specify a process or "
"process group to receive a B<SIGURG> signal when the out-of-band data "
"arrives or B<SIGPIPE> signal when a B<SOCK_STREAM> connection breaks "
"unexpectedly.  This operation may also be used to set the process or process "
"group that receives the I/O and asynchronous notification of I/O events via "
"B<SIGIO>.  Using B<F_SETOWN> is equivalent to an B<ioctl>(2)  call with the "
"B<FIOSETOWN> or B<SIOCSPGRP> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:304
msgid ""
"When the network signals an error condition to the protocol module (e.g., "
"using a ICMP message for IP) the pending error flag is set for the socket.  "
"The next operation on this socket will return the error code of the pending "
"error.  For some protocols it is possible to enable a per-socket error queue "
"to retrieve detailed information about the error; see B<IP_RECVERR> in "
"B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:314
msgid ""
"The operation of sockets is controlled by socket level I<options>.  These "
"options are defined in I<E<lt>sys/socket.hE<gt>>.  The functions "
"B<setsockopt>(2)  and B<getsockopt>(2)  are used to set and get options, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:319
msgid ""
"On success, a file descriptor for the new socket is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:324
msgid ""
"Permission to create a socket of the specified type and/or protocol is "
"denied."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:327
msgid "The implementation does not support the specified address family."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:330
msgid "Unknown protocol, or protocol family not available."
msgstr ""

#.  Since Linux 2.6.27
#. type: Plain text
#: build/C/man2/socket.2:335
msgid "Invalid flags in I<type>."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:338
msgid "Process file table overflow."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:341
#, no-wrap
msgid "B<ENOBUFS> or B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:346
msgid ""
"Insufficient memory is available.  The socket cannot be created until "
"sufficient resources are freed."
msgstr ""

#. type: TP
#: build/C/man2/socket.2:346 build/C/man2/socketpair.2:92
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:350
msgid ""
"The protocol type or the specified protocol is not supported within this "
"domain."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:352
msgid "Other errors may be generated by the underlying protocol modules."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:354
msgid "4.4BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:360
msgid "The B<SOCK_NONBLOCK> and B<SOCK_CLOEXEC> flags are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:366
msgid ""
"B<socket>()  appeared in 4.2BSD.  It is generally portable to/from non-BSD "
"systems supporting clones of the BSD socket layer (including System V "
"variants)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:385
msgid ""
"The manifest constants used under 4.x BSD for protocol families are "
"B<PF_UNIX>, B<PF_INET>, and so on, while B<AF_UNIX>, B<AF_INET>, and so on "
"are used for address families.  However, already the BSD man page promises: "
"\"The protocol family generally is the same as the address family\", and "
"subsequent standards use AF_* everywhere."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:390
msgid "An example of the use of B<socket>()  is shown in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:413
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<fcntl>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<ioctl>(2), B<listen>(2), B<read>(2), "
"B<recv>(2), B<select>(2), B<send>(2), B<shutdown>(2), B<socketpair>(2), "
"B<write>(2), B<getprotoent>(3), B<ip>(7), B<socket>(7), B<tcp>(7), "
"B<udp>(7), B<unix>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/socket.2:419
msgid ""
"\\(lqAn Introductory 4.3BSD Interprocess Communication Tutorial\\(rq and "
"\\(lqBSD Interprocess Communication Tutorial\\(rq, reprinted in I<UNIX "
"Programmer's Supplementary Documents Volume 1.>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:48
msgid "socket - Linux socket interface"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:52
msgid ""
"I<sockfd>B< = socket(int >I<socket_family>B<, int >I<socket_type>B<, int "
">I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:71
msgid ""
"This manual page describes the Linux networking socket layer user "
"interface.  The BSD compatible sockets are the uniform interface between the "
"user process and the network protocol stacks in the kernel.  The protocol "
"modules are grouped into I<protocol families> like B<AF_INET>, B<AF_IPX>, "
"B<AF_PACKET> and I<socket types> like B<SOCK_STREAM> or B<SOCK_DGRAM>.  See "
"B<socket>(2)  for more information on families and types."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:71
#, no-wrap
msgid "Socket-layer functions"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:75
msgid ""
"These functions are used by the user process to send or receive packets and "
"to do other socket operations.  For more information see their respective "
"manual pages."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:91
msgid ""
"B<socket>(2)  creates a socket, B<connect>(2)  connects a socket to a remote "
"socket address, the B<bind>(2)  function binds a socket to a local socket "
"address, B<listen>(2)  tells the socket that new connections shall be "
"accepted, and B<accept>(2)  is used to get a new socket with a new incoming "
"connection.  B<socketpair>(2)  returns two connected anonymous sockets "
"(implemented only for a few local families like B<AF_UNIX>)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:113
msgid ""
"B<send>(2), B<sendto>(2), and B<sendmsg>(2)  send data over a socket, and "
"B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  receive data from a socket.  "
"B<poll>(2)  and B<select>(2)  wait for arriving data or a readiness to send "
"data.  In addition, the standard I/O operations like B<write>(2), "
"B<writev>(2), B<sendfile>(2), B<read>(2), and B<readv>(2)  can be used to "
"read and write data."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:124
msgid ""
"B<getsockname>(2)  returns the local socket address and B<getpeername>(2)  "
"returns the remote socket address.  B<getsockopt>(2)  and B<setsockopt>(2)  "
"are used to set or get socket layer or protocol options.  B<ioctl>(2)  can "
"be used to set or read some other options."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:129
msgid ""
"B<close>(2)  is used to close a socket.  B<shutdown>(2)  closes parts of a "
"full-duplex socket connection."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:135
msgid ""
"Seeking, or calling B<pread>(2)  or B<pwrite>(2)  with a nonzero position is "
"not supported on sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:152
msgid ""
"It is possible to do nonblocking I/O on sockets by setting the B<O_NONBLOCK> "
"flag on a socket file descriptor using B<fcntl>(2).  Then all operations "
"that would block will (usually)  return with B<EAGAIN> (operation should be "
"retried later); B<connect>(2)  will return B<EINPROGRESS> error.  The user "
"can then wait for various events via B<poll>(2)  or B<select>(2)."
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:156
#, no-wrap
msgid "I/O events\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:157
#, no-wrap
msgid "Event:Poll flag:Occurrence\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:158 build/C/man7/socket.7:161
#, no-wrap
msgid "Read:POLLIN:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:159
#, no-wrap
msgid "New data arrived.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:162
#, no-wrap
msgid "A connection setup has been completed\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:163
#, no-wrap
msgid "(for connection-oriented sockets)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:165 build/C/man7/socket.7:168
#, no-wrap
msgid "Read:POLLHUP:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:166
#, no-wrap
msgid "A disconnection request has been initiated by the other end.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:169
#, no-wrap
msgid "A connection is broken (only for connection-oriented protocols).\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:170
#, no-wrap
msgid "When the socket is written\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:171
#, no-wrap
msgid "B<SIGPIPE>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:172
#, no-wrap
msgid "is also sent.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:174
#, no-wrap
msgid "Write:POLLOUT:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:175
#, no-wrap
msgid "Socket has enough send buffer space for writing new data.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:177
#, no-wrap
msgid "Read/Write:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:178
#, no-wrap
msgid "POLLIN|\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:179
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:180
#, no-wrap
msgid "POLLOUT\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:182
#, no-wrap
msgid "An outgoing\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:183
#, no-wrap
msgid "B<connect>(2)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:184
#, no-wrap
msgid "finished.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:186
#, no-wrap
msgid "Read/Write:POLLERR:An asynchronous error occurred.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:187
#, no-wrap
msgid "Read/Write:POLLHUP:The other end has shut down one direction.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:188
#, no-wrap
msgid "Exception:POLLPRI:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:189
#, no-wrap
msgid "Urgent data arrived.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:190
#, no-wrap
msgid "B<SIGURG>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/socket.7:191
#, no-wrap
msgid "is sent then.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:220
msgid ""
"An alternative to B<poll>(2)  and B<select>(2)  is to let the kernel inform "
"the application about events via a B<SIGIO> signal.  For that the B<O_ASYNC> "
"flag must be set on a socket file descriptor via B<fcntl>(2)  and a valid "
"signal handler for B<SIGIO> must be installed via B<sigaction>(2).  See the "
"I<Signals> discussion below."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:220
#, no-wrap
msgid "Socket address structures"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:236
msgid ""
"Each socket domain has its own format for socket addresses, with a "
"domain-specific address structure.  Each of these structures begins with an "
"integer \"family\" field (typed as I<sa_family_t>)  that indicates the type "
"of the address structure.  This allows the various system calls (e.g., "
"B<connect>(2), B<bind>(2), B<accept>(2), B<getsockname>(2), "
"B<getpeername>(2)), which are generic to all socket domains, to determine "
"the domain of a particular socket address."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:246
msgid ""
"To allow any type of socket address to be passed to interfaces in the "
"sockets API, the type I<struct sockaddr> is defined.  The purpose of this "
"type is purely to allow casting of domain-specific socket address types to a "
"\"generic\" type, so as to avoid compiler warnings about type mismatches in "
"calls to the sockets API."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:256
msgid ""
"In addition, the sockets API provides the data type I<struct "
"sockaddr_storage>.  This type is suitable to accommodate all supported "
"domain-specific socket address structures; it is large enough and is aligned "
"properly.  (In particular, it is large enough to hold IPv6 socket "
"addresses.)  The structure includes the following field, which can be used "
"to identify the type of socket address actually stored in the structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:260
#, no-wrap
msgid "    sa_family_t ss_family;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:268
msgid ""
"The I<sockaddr_storage> structure is useful in programs that must handle "
"socket addresses in a generic way (e.g., programs that must deal with both "
"IPv4 and IPv6 socket addresses)."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:268
#, no-wrap
msgid "Socket options"
msgstr ""

#.  FIXME
#.  In the list below, the text used to describe argument types
#.  for each socket option should be more consistent
#
#.  SO_ACCEPTCONN is in POSIX.1-2001, and its origin is explained in
#.  W R Stevens, UNPv1
#. type: Plain text
#: build/C/man7/socket.7:286
msgid ""
"The socket options listed below can be set by using B<setsockopt>(2)  and "
"read with B<getsockopt>(2)  with the socket level set to B<SOL_SOCKET> for "
"all sockets.  Unless otherwise noted, I<optval> is a pointer to an I<int>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:286
#, no-wrap
msgid "B<SO_ACCEPTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:294
msgid ""
"Returns a value indicating whether or not this socket has been marked to "
"accept connections with B<listen>(2).  The value 0 indicates that this is "
"not a listening socket, the value 1 indicates that this is a listening "
"socket.  This socket option is read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:294
#, no-wrap
msgid "B<SO_BINDTODEVICE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:313
msgid ""
"Bind this socket to a particular device like \\(lqeth0\\(rq, as specified in "
"the passed interface name.  If the name is an empty string or the option "
"length is zero, the socket device binding is removed.  The passed option is "
"a variable-length null-terminated interface name string with the maximum "
"size of B<IFNAMSIZ>.  If a socket is bound to an interface, only packets "
"received from that particular interface are processed by the socket.  Note "
"that this works only for some socket types, particularly B<AF_INET> "
"sockets.  It is not supported for packet sockets (use normal B<bind>(2)  "
"there)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:327
msgid ""
"Before Linux 3.8, this socket option could be set, but could not retrieved "
"with B<getsockopt>(2).  Since Linux 3.8, it is readable.  The I<optlen> "
"argument should contain the buffer size available to receive the device name "
"and is recommended to be B<IFNAMSZ> bytes.  The real device name length is "
"reported back in the I<optlen> argument."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:327
#, no-wrap
msgid "B<SO_BROADCAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:333
msgid ""
"Set or get the broadcast flag.  When enabled, datagram sockets are allowed "
"to send packets to a broadcast address.  This option has no effect on "
"stream-oriented sockets."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:333
#, no-wrap
msgid "B<SO_BSDCOMPAT>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:345
msgid ""
"Enable BSD bug-to-bug compatibility.  This is used by the UDP protocol "
"module in Linux 2.0 and 2.2.  If enabled ICMP errors received for a UDP "
"socket will not be passed to the user program.  In later kernel versions, "
"support for this option has been phased out: Linux 2.4 silently ignores it, "
"and Linux 2.6 generates a kernel warning (printk()) if a program uses this "
"option.  Linux 2.0 also enabled BSD bug-to-bug compatibility options (random "
"header changing, skipping of the broadcast flag) for raw sockets with this "
"option, but that was removed in Linux 2.2."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:345
#, no-wrap
msgid "B<SO_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:351
msgid ""
"Enable socket debugging.  Only allowed for processes with the "
"B<CAP_NET_ADMIN> capability or an effective user ID of 0."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:351
#, no-wrap
msgid "B<SO_DOMAIN> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:359
msgid ""
"Retrieves the socket domain as an integer, returning a value such as "
"B<AF_INET6>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:359
#, no-wrap
msgid "B<SO_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:364
msgid ""
"Get and clear the pending socket error.  This socket option is read-only.  "
"Expects an integer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:364
#, no-wrap
msgid "B<SO_DONTROUTE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:373
msgid ""
"Don't send via a gateway, send only to directly connected hosts.  The same "
"effect can be achieved by setting the B<MSG_DONTROUTE> flag on a socket "
"B<send>(2)  operation.  Expects an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:373
#, no-wrap
msgid "B<SO_KEEPALIVE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:377
msgid ""
"Enable sending of keep-alive messages on connection-oriented sockets.  "
"Expects an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:377
#, no-wrap
msgid "B<SO_LINGER>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:385
msgid ""
"Sets or gets the B<SO_LINGER> option.  The argument is a I<linger> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:392
#, no-wrap
msgid ""
"struct linger {\n"
"    int l_onoff;    /* linger active */\n"
"    int l_linger;   /* how many seconds to linger for */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:406
msgid ""
"When enabled, a B<close>(2)  or B<shutdown>(2)  will not return until all "
"queued messages for the socket have been successfully sent or the linger "
"timeout has been reached.  Otherwise, the call returns immediately and the "
"closing is done in the background.  When the socket is closed as part of "
"B<exit>(2), it always lingers in the background."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:406
#, no-wrap
msgid "B<SO_MARK> (since Linux 2.6.25)"
msgstr ""

#.  commit 4a19ec5800fc3bb64e2d87c4d9fdd9e636086fe0
#.  and    914a9ab386a288d0f22252fc268ecbc048cdcbd5
#. type: Plain text
#: build/C/man7/socket.7:417
msgid ""
"Set the mark for each packet sent through this socket (similar to the "
"netfilter MARK target but socket-based).  Changing the mark can be used for "
"mark-based routing without netfilter or for packet filtering.  Setting this "
"option requires the B<CAP_NET_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:417
#, no-wrap
msgid "B<SO_OOBINLINE>"
msgstr ""

#.  don't document it because it can do too much harm.
#. .B SO_NO_CHECK
#. type: Plain text
#: build/C/man7/socket.7:426
msgid ""
"If this option is enabled, out-of-band data is directly placed into the "
"receive data stream.  Otherwise out-of-band data is passed only when the "
"B<MSG_OOB> flag is set during receiving."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:426
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr ""

#.  FIXME Document SO_PASSSEC, added in 2.6.18; there is some info
#.  in the 2.6.18 ChangeLog
#. type: Plain text
#: build/C/man7/socket.7:435
msgid ""
"Enable or disable the receiving of the B<SCM_CREDENTIALS> control message.  "
"For more information see B<unix>(7)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:435
#, no-wrap
msgid "B<SO_PEEK_OFF> (since Linux 3.4)"
msgstr ""

#.  commit ef64a54f6e558155b4f149bb10666b9e914b6c54
#. type: Plain text
#: build/C/man7/socket.7:445
msgid ""
"This option, which is currently supported only for B<unix>(7)  sockets, sets "
"the value of the \"peek offset\" for the B<recv(2)> system call when used "
"with B<MSG_PEEK> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:453
msgid ""
"When this option is set to a negative value (it is set to -1 for all new "
"sockets), traditional behavior is provided: B<recv(2)> with the B<MSG_PEEK> "
"flag will peek data from the front of the queue."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:460
msgid ""
"When the option is set to a value greater than or equal to zero, then the "
"next peek at data queued in the socket will occur at the byte offset "
"specified by the option value.  At the same time, the \"peek offset\" will "
"be incremented by the number of bytes that were peeked from the queue, so "
"that a subsequent peek will return the next data in the queue.i"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:472
msgid ""
"If data is removed from the front of the queue via a call to B<recv>(2)  (or "
"similar) without the B<MSG_PEEK> flag, the \"peek offset\" will be decreased "
"by the number of bytes removed.  In other words, receiving data without the "
"B<MSG_PEEK> flag will cause the \"peek offset\" to be adjusted to maintain "
"the correct relative position in the queued data, so that a subsequent peek "
"will retrieve the data that would have been retrieved had the data not been "
"removed."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:477
msgid ""
"For datagram sockets, if the \"peek offset\" points to the middle of a "
"packet, the data returned will be marked with the B<MSG_TRUNC> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:481
msgid ""
"The following example serves to illustrate the use of B<SO_PEEK_OFF>.  "
"Suppose a stream socket has the following queued input data:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:483
#, no-wrap
msgid "    aabbccddeeff\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:488
msgid ""
"The following sequence of B<recv>(2)  calls would have the effect noted in "
"the comments:"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:493
#, no-wrap
msgid ""
"int ov = 4;                  // Set peek offset to 4\n"
"setsockopt(fd, SOL_SOCKET, SO_PEEK_OFF, &ov, sizeof(ov));\n"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:498
#, no-wrap
msgid ""
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"cc\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"dd\"; offset set to 8\n"
"recv(fd, buf, 2, 0);         // Reads \"aa\"; offset set to 6\n"
"recv(fd, buf, 2, MSG_PEEK);  // Peeks \"ee\"; offset set to 8\n"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:500
#, no-wrap
msgid "B<SO_PEERCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:523
msgid ""
"Return the credentials of the foreign process connected to this socket.  "
"This is possible only for connected B<AF_UNIX> stream sockets and B<AF_UNIX> "
"stream and datagram socket pairs created using B<socketpair>(2); see "
"B<unix>(7).  The returned credentials are those that were in effect at the "
"time of the call to B<connect>(2)  or B<socketpair>(2).  The argument is a "
"I<ucred> structure; define the B<GNU_SOURCE> feature test macro to obtain "
"the definition of that structure from I<E<lt>sys/socket.hE<gt>>.  This "
"socket option is read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:523
#, no-wrap
msgid "B<SO_PRIORITY>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:536
msgid ""
"Set the protocol-defined priority for all packets to be sent on this "
"socket.  Linux uses this value to order the networking queues: packets with "
"a higher priority may be processed first depending on the selected device "
"queueing discipline.  For B<ip>(7), this also sets the IP type-of-service "
"(TOS) field for outgoing packets.  Setting a priority outside the range 0 to "
"6 requires the B<CAP_NET_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:536
#, no-wrap
msgid "B<SO_PROTOCOL> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:544
msgid ""
"Retrieves the socket protocol as an integer, returning a value such as "
"B<IPPROTO_SCTP>.  See B<socket>(2)  for details.  This socket option is "
"read-only."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:544
#, no-wrap
msgid "B<SO_RCVBUF>"
msgstr ""

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  The following thread on LMKL is quite informative:
#.  getsockopt/setsockopt with SO_RCVBUF and SO_SNDBUF "non-standard" behaviour
#.  17 July 2012
#.  http://thread.gmane.org/gmane.linux.kernel/1328935
#. type: Plain text
#: build/C/man7/socket.7:563
msgid ""
"Sets or gets the maximum socket receive buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/rmem_default> file, and "
"the maximum allowed value is set by the I</proc/sys/net/core/rmem_max> "
"file.  The minimum (doubled) value for this option is 256."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:563
#, no-wrap
msgid "B<SO_RCVBUFFORCE> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:572
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_RCVBUF>, but the I<rmem_max> limit can be "
"overridden."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:572
#, no-wrap
msgid "B<SO_RCVLOWAT> and B<SO_SNDLOWAT>"
msgstr ""

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=111049368106984&w=2
#.  Tested on kernel 2.6.14 -- mtk, 30 Nov 05
#. type: Plain text
#: build/C/man7/socket.7:601
msgid ""
"Specify the minimum number of bytes in the buffer until the socket layer "
"will pass the data to the protocol (B<SO_SNDLOWAT>)  or the user on "
"receiving (B<SO_RCVLOWAT>).  These two values are initialized to 1.  "
"B<SO_SNDLOWAT> is not changeable on Linux (B<setsockopt>(2)  fails with the "
"error B<ENOPROTOOPT>).  B<SO_RCVLOWAT> is changeable only since Linux 2.4.  "
"The B<select>(2)  and B<poll>(2)  system calls currently do not respect the "
"B<SO_RCVLOWAT> setting on Linux, and mark a socket readable when even a "
"single byte of data is available.  A subsequent read from the socket will "
"block until B<SO_RCVLOWAT> bytes are available."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:601
#, no-wrap
msgid "B<SO_RCVTIMEO> and B<SO_SNDTIMEO>"
msgstr ""

#.  Not implemented in 2.0.
#.  Implemented in 2.1.11 for getsockopt: always return a zero struct.
#.  Implemented in 2.3.41 for setsockopt, and actually used.
#.  in fact to EAGAIN
#. type: Plain text
#: build/C/man7/socket.7:636
msgid ""
"Specify the receiving or sending timeouts until reporting an error.  The "
"argument is a I<struct timeval>.  If an input or output function blocks for "
"this period of time, and data has been sent or received, the return value of "
"that function will be the amount of data transferred; if no data has been "
"transferred and the timeout has been reached then -1 is returned with "
"I<errno> set to B<EAGAIN> or B<EWOULDBLOCK>, or B<EINPROGRESS> (for "
"B<connect>(2))  just as if the socket was specified to be nonblocking.  If "
"the timeout is set to zero (the default)  then the operation will never "
"timeout.  Timeouts only have effect for system calls that perform socket I/O "
"(e.g., B<read>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2)); timeouts have "
"no effect for B<select>(2), B<poll>(2), B<epoll_wait>(2), and so on."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:636
#, no-wrap
msgid "B<SO_REUSEADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:651
msgid ""
"Indicates that the rules used in validating addresses supplied in a "
"B<bind>(2)  call should allow reuse of local addresses.  For B<AF_INET> "
"sockets this means that a socket may bind, except when there is an active "
"listening socket bound to the address.  When the listening socket is bound "
"to B<INADDR_ANY> with a specific port then it is not possible to bind to "
"this port for any local address.  Argument is an integer boolean flag."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:651
#, no-wrap
msgid "B<SO_SNDBUF>"
msgstr ""

#.  Most (all?) other implementations do not do this -- MTK, Dec 05
#.  See also the comment to SO_RCVBUF (17 Jul 2012 LKML mail)
#. type: Plain text
#: build/C/man7/socket.7:667
msgid ""
"Sets or gets the maximum socket send buffer in bytes.  The kernel doubles "
"this value (to allow space for bookkeeping overhead)  when it is set using "
"B<setsockopt>(2), and this doubled value is returned by B<getsockopt>(2).  "
"The default value is set by the I</proc/sys/net/core/wmem_default> file and "
"the maximum allowed value is set by the I</proc/sys/net/core/wmem_max> "
"file.  The minimum (doubled) value for this option is 2048."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:667
#, no-wrap
msgid "B<SO_SNDBUFFORCE> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:676
msgid ""
"Using this socket option, a privileged (B<CAP_NET_ADMIN>)  process can "
"perform the same task as B<SO_SNDBUF>, but the I<wmem_max> limit can be "
"overridden."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:676
#, no-wrap
msgid "B<SO_TIMESTAMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:692
msgid ""
"Enable or disable the receiving of the B<SO_TIMESTAMP> control message.  The "
"timestamp control message is sent with level B<SOL_SOCKET> and the "
"I<cmsg_data> field is a I<struct timeval> indicating the reception time of "
"the last packet passed to the user in this call.  See B<cmsg>(3)  for "
"details on control messages."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:692
#, no-wrap
msgid "B<SO_TYPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:697
msgid ""
"Gets the socket type as an integer (e.g., B<SOCK_STREAM>).  This socket "
"option is read-only."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:697
#, no-wrap
msgid "Signals"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:708
msgid ""
"When writing onto a connection-oriented socket that has been shut down (by "
"the local or the remote end)  B<SIGPIPE> is sent to the writing process and "
"B<EPIPE> is returned.  The signal is not sent when the write call specified "
"the B<MSG_NOSIGNAL> flag."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:733
msgid ""
"When requested with the B<FIOSETOWN> B<fcntl>(2)  or B<SIOCSPGRP> "
"B<ioctl>(2), B<SIGIO> is sent when an I/O event occurs.  It is possible to "
"use B<poll>(2)  or B<select>(2)  in the signal handler to find out which "
"socket the event occurred on.  An alternative (in Linux 2.2) is to set a "
"real-time signal using the B<F_SETSIG> B<fcntl>(2); the handler of the real "
"time signal will be called with the file descriptor in the I<si_fd> field of "
"its I<siginfo_t>.  See B<fcntl>(2)  for more information."
msgstr ""

#.  .SS Ancillary messages
#. type: Plain text
#: build/C/man7/socket.7:741
msgid ""
"Under some circumstances (e.g., multiple processes accessing a single "
"socket), the condition that caused the B<SIGIO> may have already disappeared "
"when the process reacts to the signal.  If this happens, the process should "
"wait again because Linux will resend the signal later."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:741
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:745
msgid ""
"The core socket networking parameters can be accessed via files in the "
"directory I</proc/sys/net/core/>."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:745
#, no-wrap
msgid "I<rmem_default>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:748
msgid "contains the default setting in bytes of the socket receive buffer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:748
#, no-wrap
msgid "I<rmem_max>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:754
msgid ""
"contains the maximum socket receive buffer size in bytes which a user may "
"set by using the B<SO_RCVBUF> socket option."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:754
#, no-wrap
msgid "I<wmem_default>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:757
msgid "contains the default setting in bytes of the socket send buffer."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:757
#, no-wrap
msgid "I<wmem_max>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:763
msgid ""
"contains the maximum socket send buffer size in bytes which a user may set "
"by using the B<SO_SNDBUF> socket option."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:763
#, no-wrap
msgid "I<message_cost> and I<message_burst>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:767
msgid ""
"configure the token bucket filter used to load limit warning messages caused "
"by external network events."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:767
#, no-wrap
msgid "I<netdev_max_backlog>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:770
msgid "Maximum number of packets in the global input queue."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:770
#, no-wrap
msgid "I<optmem_max>"
msgstr ""

#.  netdev_fastroute is not documented because it is experimental
#. type: Plain text
#: build/C/man7/socket.7:775
msgid ""
"Maximum length of ancillary data and user control data like the iovecs per "
"socket."
msgstr ""

#. type: SS
#: build/C/man7/socket.7:775
#, no-wrap
msgid "Ioctls"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:778
msgid "These operations can be accessed using B<ioctl>(2):"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:782
#, no-wrap
msgid ""
"I<error>B< = ioctl(>I<ip_socket>B<, >I<ioctl_type>B<, "
">I<&value_result>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:784
#, no-wrap
msgid "B<SIOCGSTAMP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:808
msgid ""
"Return a I<struct timeval> with the receive timestamp of the last packet "
"passed to the user.  This is useful for accurate round trip time "
"measurements.  See B<setitimer>(2)  for a description of I<struct timeval>.  "
"This ioctl should be used only if the socket option B<SO_TIMESTAMP> is not "
"set on the socket.  Otherwise, it returns the timestamp of the last packet "
"that was received while B<SO_TIMESTAMP> was not set, or it fails if no such "
"packet has been received, (i.e., B<ioctl>(2)  returns -1 with I<errno> set "
"to B<ENOENT>)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:808
#, no-wrap
msgid "B<SIOCSPGRP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:827
msgid ""
"Set the process or process group to send B<SIGIO> or B<SIGURG> signals to "
"when an asynchronous I/O operation has finished or urgent data is "
"available.  The argument is a pointer to a I<pid_t>.  If the argument is "
"positive, send the signals to that process.  If the argument is negative, "
"send the signals to the process group with the ID of the absolute value of "
"the argument.  The process may only choose itself or its own process group "
"to receive signals unless it has the B<CAP_KILL> capability or an effective "
"UID of 0."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:827
#, no-wrap
msgid "B<FIOASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:837
msgid ""
"Change the B<O_ASYNC> flag to enable or disable asynchronous I/O mode of the "
"socket.  Asynchronous I/O mode means that the B<SIGIO> signal or the signal "
"set with B<F_SETSIG> is raised when a new I/O event occurs."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:845
msgid ""
"Argument is an integer boolean flag.  (This operation is synonymous with the "
"use of B<fcntl>(2)  to set the B<O_ASYNC> flag.)"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:845
#, no-wrap
msgid "B<SIOCGPGRP>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:854
msgid ""
"Get the current process or process group that receives B<SIGIO> or B<SIGURG> "
"signals, or 0 when none is set."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:858
msgid "Valid B<fcntl>(2)  operations:"
msgstr ""

#. type: TP
#: build/C/man7/socket.7:858
#, no-wrap
msgid "B<FIOGETOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:863
msgid "The same as the B<SIOCGPGRP> B<ioctl>(2)."
msgstr ""

#. type: TP
#: build/C/man7/socket.7:863
#, no-wrap
msgid "B<FIOSETOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:868
msgid "The same as the B<SIOCSPGRP> B<ioctl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:882
msgid ""
"B<SO_BINDTODEVICE> was introduced in Linux 2.0.30.  B<SO_PASSCRED> is new in "
"Linux 2.2.  The I</proc> interfaces was introduced in Linux 2.2.  "
"B<SO_RCVTIMEO> and B<SO_SNDTIMEO> are supported since Linux 2.3.41.  "
"Earlier, timeouts were fixed to a protocol-specific setting, and could not "
"be read or written."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:887
msgid ""
"Linux assumes that half of the send/receive buffer is used for internal "
"kernel structures; thus the values in the corresponding I</proc> files are "
"twice what can be observed on the wire."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:900
msgid ""
"Linux will only allow port reuse with the B<SO_REUSEADDR> option when this "
"option was set both in the previous program that performed a B<bind>(2)  to "
"the port and in the program that wants to reuse the port.  This differs from "
"some implementations (e.g., FreeBSD)  where only the later program needs to "
"set the B<SO_REUSEADDR> option.  Typically this difference is invisible, "
"since, for example, a server program is designed to always set this option."
msgstr ""

#.  FIXME Document SO_ATTACH_FILTER and SO_DETACH_FILTER
#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/socket.7:913
msgid ""
"The B<CONFIG_FILTER> socket options B<SO_ATTACH_FILTER> and "
"B<SO_DETACH_FILTER> are not documented.  The suggested interface to use them "
"is via the libpcap library."
msgstr ""

#. type: Plain text
#: build/C/man7/socket.7:925
msgid ""
"B<getsockopt>(2), B<connect>(2), B<setsockopt>(2), B<socket>(2), "
"B<capabilities>(7), B<ddp>(7), B<ip>(7), B<packet>(7), B<tcp>(7), B<udp>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/socketcall.2:25
#, no-wrap
msgid "SOCKETCALL"
msgstr ""

#. type: TH
#: build/C/man2/socketcall.2:25
#, no-wrap
msgid "2012-10-16"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:28
msgid "socketcall - socket system calls"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:30
msgid "B<int socketcall(int >I<call>B<, unsigned long *>I<args>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:38
msgid ""
"B<socketcall>()  is a common kernel entry point for the socket system "
"calls.  I<call> determines which socket function to invoke.  I<args> points "
"to a block containing the actual arguments, which are passed through to the "
"appropriate call."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:42
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<socketcall>()."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:45
msgid ""
"This call is specific to Linux, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:53
msgid ""
"On a some architectures\\(emfor example, x86-64 and ARM\\(emthere is no "
"B<socketcall>()  system call; instead B<socket>(2), B<accept>(2), "
"B<bind>(2), and so on really are implemented as separate system calls."
msgstr ""

#. type: Plain text
#: build/C/man2/socketcall.2:71
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getpeername>(2), "
"B<getsockname>(2), B<getsockopt>(2), B<listen>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendmsg>(2), B<sendto>(2), "
"B<setsockopt>(2), B<shutdown>(2), B<socket>(2), B<socketpair>(2)"
msgstr ""

#. type: TH
#: build/C/man2/socketpair.2:42
#, no-wrap
msgid "SOCKETPAIR"
msgstr ""

#. type: TH
#: build/C/man2/socketpair.2:42
#, no-wrap
msgid "2008-10-11"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:45
msgid "socketpair - create a pair of connected sockets"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:52
msgid ""
"B<int socketpair(int >I<domain>B<, int >I<type>B<, int >I<protocol>B<, int "
">I<sv>B<[2]);>"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:63
msgid ""
"The B<socketpair>()  call creates an unnamed pair of connected sockets in "
"the specified I<domain>, of the specified I<type>, and using the optionally "
"specified I<protocol>.  For further details of these arguments, see "
"B<socket>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:69
msgid ""
"The descriptors used in referencing the new sockets are returned in I<sv>[0] "
"and I<sv>[1].  The two sockets are indistinguishable."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:78
msgid "The specified address family is not supported on this machine."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:83
msgid ""
"The address I<sv> does not specify a valid part of the process address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:86
msgid "Too many descriptors are in use by this process."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:92
msgid "The specified protocol does not support creation of socket pairs."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:95
msgid "The specified protocol is not supported on this machine."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:103
msgid ""
"4.4BSD, POSIX.1-2001.  The B<socketpair>()  function call appeared in "
"4.2BSD.  It is generally portable to/from non-BSD systems supporting clones "
"of the BSD socket layer (including System V variants)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:109
msgid ""
"On Linux, the only supported domain for this call is B<AF_UNIX> (or "
"synonymously, B<AF_LOCAL>).  (Most implementations have the same "
"restriction.)"
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:118
msgid ""
"Since Linux 2.6.27, B<socketpair>()  supports the B<SOCK_NONBLOCK> and "
"B<SOCK_CLOEXEC> flags described in B<socket>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/socketpair.2:131
msgid "B<pipe>(2), B<read>(2), B<socket>(2), B<write>(2), B<socket>(7), B<unix>(7)"
msgstr ""

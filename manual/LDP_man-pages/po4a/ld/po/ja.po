# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-22 04:25+0900\n"
"PO-Revision-Date: 2012-03-22 01:45+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24
#, no-wrap
msgid "DL_ITERATE_PHDR"
msgstr "DL_ITERATE_PHDR"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24
#, no-wrap
msgid "2007-05-18"
msgstr "2007-05-18"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24 build/C/man3/end.3:25
#: build/C/man8/ld.so.8:2 build/C/man8/ldconfig.8:22
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24 build/C/man3/dlopen.3:35
#: build/C/man5/elf.5:33 build/C/man3/end.3:25 build/C/man8/ld.so.8:2
#: build/C/man8/ldconfig.8:22 build/C/man1/ldd.1:10
#: build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/dlopen.3:36
#: build/C/man5/elf.5:34 build/C/man3/end.3:26 build/C/man8/ld.so.8:3
#: build/C/man8/ldconfig.8:23 build/C/man1/ldd.1:11
#: build/C/man7/rtld-audit.7:27
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:27
msgid "dl_iterate_phdr - walk through list of shared objects"
msgstr "dl_iterate_phdr - 共有オブジェクトのリストを辿る"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:27 build/C/man3/dlopen.3:39
#: build/C/man5/elf.5:36 build/C/man3/end.3:28 build/C/man8/ld.so.8:5
#: build/C/man8/ldconfig.8:25 build/C/man1/ldd.1:13
#: build/C/man7/rtld-audit.7:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:31
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>link.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:37
#, no-wrap
msgid ""
"B<int dl_iterate_phdr(>\n"
"          B<int (*>callbackB<) (struct dl_phdr_info *>infoB<,>\n"
"                           B<size_t> sizeB<, void *>dataB<),>\n"
"          B<void *>dataB<);>\n"
msgstr ""
"B<int dl_iterate_phdr(>\n"
"          B<int (*>callbackB<) (struct dl_phdr_info *>infoB<,>\n"
"                           B<size_t> sizeB<, void *>dataB<),>\n"
"          B<void *>dataB<);>\n"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:38 build/C/man3/dlopen.3:51
#: build/C/man5/elf.5:41 build/C/man3/end.3:34 build/C/man8/ld.so.8:15
#: build/C/man8/ldconfig.8:54 build/C/man1/ldd.1:15
#: build/C/man7/rtld-audit.7:33
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:43
msgid ""
"The B<dl_iterate_phdr>()  function allows an application to inquire at run "
"time to find out which shared objects it has loaded."
msgstr ""
"B<dl_iterate_phdr>()  関数を使うと、アプリケーションは実行時に どの共有オブ"
"ジェクトをロードしたかを見つけることができる。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:53
msgid ""
"The B<dl_iterate_phdr>()  function walks through the list of an "
"application's shared objects and calls the function I<callback> once for "
"each object, until either all shared objects have been processed or "
"I<callback> returns a nonzero value."
msgstr ""
"B<dl_iterate_phdr>()  関数はアプリケーションの共有オブジェクトのリストを辿"
"り、 各オブジェクトに対して関数 I<callback> を 1 回ずつ呼び出す。 これは全て"
"の共有オブジェクトが処理されるか、 I<callback> が 0 以外の値を返すまで行われ"
"る。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:70
msgid ""
"Each call to I<callback> receives three arguments: I<info>, which is a "
"pointer to a structure containing information about the shared object; "
"I<size>, which is the size of the structure pointed to by I<info>; and "
"I<data>, which is a copy of whatever value was passed by the calling program "
"as the second argument (also named I<data>)  in the call to "
"B<dl_iterate_phdr>()."
msgstr ""
"各々の I<callback> 呼び出しは 3 つの引き数を受け取る: I<info> は共有オブジェ"
"クトの情報を保持する構造体へのポインタである。 I<size> は I<info> で指される"
"構造体のサイズである。 I<data> は呼び出し元プログラムから B<dl_iterate_phdr>"
"()  の呼び出しの (同じく I<data> という名前の) 第 2 引き数として渡される値の"
"コピーである。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:74
msgid "The I<info> argument is a structure of the following type:"
msgstr "I<info> 引き数は、以下のような型の構造体である。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:86
#, no-wrap
msgid ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* Base address of object */\n"
"    const char       *dlpi_name;  /* (Null-terminated) name of\n"
"                                     object */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* Pointer to array of\n"
"                                     ELF program headers\n"
"                                     for this object */\n"
"    ElfW(Half)        dlpi_phnum; /* # of items in I<dlpi_phdr> */\n"
"};\n"
msgstr ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* オブジェクトのベースアドレス */\n"
"    const char       *dlpi_name;  /* (null 文字で終端された)\n"
"                                     オブジェクト名 */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* このオブジェクトの\n"
"                                     ELF プログラムヘッダの\n"
"                                     配列へのポインタ */\n"
"    ElfW(Half)        dlpi_phnum; /* I<dlpi_phdr> のアイテム数 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:98
msgid ""
"(The I<ElfW>()  macro definition turns its argument into the name of an ELF "
"data type suitable for the hardware architecture.  For example, on a 32-bit "
"platform, ElfW(Addr) yields the data type name Elf32_Addr.  Further "
"information on these types can be found in the I<E<lt>elf.hE<gt>> and "
"I<E<lt>link.hE<gt>> header files.)"
msgstr ""
"(I<ElfW>()  マクロ定義は引き数をハードウェアアーキテクチャに適した ELF データ"
"型の名前に変換する。 たとえば、32 ビットプラットフォームでは ElfW(Addr) は"
"データ型名 Elf32_Addr を生成する。 これらの型についての更に詳細な情報は、ヘッ"
"ダファイル I<E<lt>elf.hE<gt>> と I<E<lt>link.hE<gt>> にある。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:109
msgid ""
"The I<dlpi_addr> field indicates the base address of the shared object (i."
"e., the difference between the virtual memory address of the shared object "
"and the offset of that object in the file from which it was loaded).  The "
"I<dlpi_name> field is a null-terminated string giving the pathname from "
"which the shared object was loaded."
msgstr ""
"I<dlpi_addr> フィールドは共有オブジェクトのベースアドレス (つまり、共有オブ"
"ジェクトの仮想メモリアドレスと、 ファイル (このファイルから共有オブジェクトが"
"ロードされる) における 共有オブジェクトのオフセットとの差分) を表す。 "
"I<dlpi_name> は null 文字で終端された文字列であり、 このパス名のファイルから"
"共有オブジェクトがロードされる。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:124
msgid ""
"To understand the meaning of the I<dlpi_phdr> and I<dlpi_phnum> fields, we "
"need to be aware that an ELF shared object consists of a number of segments, "
"each of which has a corresponding program header describing the segment.  "
"The I<dlpi_phdr> field is a pointer to an array of the program headers for "
"this shared object.  The I<dlpi_phnum> field indicates the size of this "
"array."
msgstr ""
"I<dlpi_phdr> と I<dlpi_phnum> フィールドの意味を理解するには、 ELF 共有オブ"
"ジェクトが幾つかのセグメントから構成されていることと、 各セグメントがそれに対"
"応するプログラムヘッダ (そのセグメントを説明する) を持っていることを知ってい"
"る必要がある。 I<dlpi_phdr> フィールドは、この共有オブジェクトのプログラム"
"ヘッダの配列へのポインタである。 I<dlpi_phnum> は、この配列のサイズを表す。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:126
msgid "These program headers are structures of the following form:"
msgstr "これらのプログラムヘッダは以下のような形式の構造体である:"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:139
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word  p_type;    /* Segment type */\n"
"    Elf32_Off   p_offset;  /* Segment file offset */\n"
"    Elf32_Addr  p_vaddr;   /* Segment virtual address */\n"
"    Elf32_Addr  p_paddr;   /* Segment physical address */\n"
"    Elf32_Word  p_filesz;  /* Segment size in file */\n"
"    Elf32_Word  p_memsz;   /* Segment size in memory */\n"
"    Elf32_Word  p_flags;   /* Segment flags */\n"
"    Elf32_Word  p_align;   /* Segment alignment */\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct\n"
"{\n"
"    Elf32_Word  p_type;    /* セグメントの型 */\n"
"    Elf32_Off   p_offset;  /* セグメントのファイルオフセット */\n"
"    Elf32_Addr  p_vaddr;   /* セグメントの仮想アドレス */\n"
"    Elf32_Addr  p_paddr;   /* セグメントの物理アドレス */\n"
"    Elf32_Word  p_filesz;  /* ファイルにおけるセグメントサイズ */\n"
"    Elf32_Word  p_memsz;   /* メモリにおけるセグメントサイズ */\n"
"    Elf32_Word  p_flags;   /* セグメントフラグ */\n"
"    Elf32_Word  p_align;   /* セグメントの配置 (alignment) */\n"
"} Elf32_Phdr;\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:145
msgid ""
"Note that we can calculate the location of a particular program header, "
"I<x>, in virtual memory using the formula:"
msgstr ""
"特定のプログラムヘッダ I<x> の仮想メモリにおける位置は、以下の式で計算できる"
"点に注意すること:"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:148
#, no-wrap
msgid "  addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"
msgstr "  addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:149
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:154
msgid ""
"The B<dl_iterate_phdr>()  function returns whatever value was returned by "
"the last call to I<callback>."
msgstr ""
"B<dl_iterate_phdr>()  関数は最後の I<callback> の呼び出しで返された値を返す。"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:154
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:157
msgid "B<dl_iterate_phdr>()  has been supported in glibc since version 2.2.4."
msgstr ""
"B<dl_iterate_phdr>()  は glibc のバージョン 2.2.4 以降でサポートされている。"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:157 build/C/man3/dlopen.3:381
#: build/C/man3/end.3:49 build/C/man7/rtld-audit.7:459
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:161
msgid ""
"The B<dl_iterate_phdr>()  function is Linux-specific and should be avoided "
"in portable applications."
msgstr ""
"B<dl_iterate_phdr>()  関数は Linux 固有であり、移植を考えたアプリケーションで"
"は避けるべきである。"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:161 build/C/man3/dlopen.3:446
#: build/C/man3/end.3:75 build/C/man7/rtld-audit.7:490
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:166
msgid ""
"The following program displays a list of pathnames of the shared objects it "
"has loaded.  For each shared object, the program lists the virtual addresses "
"at which the object's ELF segments are loaded."
msgstr ""
"以下のプログラムは、共有オブジェクトがロードされた パス名の一覧を表示する。 "
"各共有オブジェクトについて、このプログラムは オブジェクトの ELF セグメントが"
"ロードされた 仮想アドレスの一覧を表示する。"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:172
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:177
#, no-wrap
msgid ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    int j;\n"
msgstr ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:180
#, no-wrap
msgid ""
"    printf(\"name=%s (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"        info-E<gt>dlpi_phnum);\n"
msgstr ""
"    printf(\"name=%s (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"        info-E<gt>dlpi_phnum);\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:186
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> info-E<gt>dlpi_phnum; j++)\n"
"         printf(\"\\et\\et header %2d: address=%10p\\en\", j,\n"
"             (void *) (info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[j].p_vaddr));\n"
"    return 0;\n"
"}\n"
msgstr ""
"    for (j = 0; j E<lt> info-E<gt>dlpi_phnum; j++)\n"
"         printf(\"\\et\\et header %2d: address=%10p\\en\", j,\n"
"             (void *) (info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[j].p_vaddr));\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:191
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:194 build/C/man3/end.3:106
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:195 build/C/man3/dlopen.3:507
#: build/C/man5/elf.5:1934 build/C/man3/end.3:107 build/C/man8/ld.so.8:373
#: build/C/man8/ldconfig.8:175 build/C/man1/ldd.1:75
#: build/C/man7/rtld-audit.7:600
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:205
msgid ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dlopen>(3), B<elf>(5), B<ld.so>"
"(8), and the I<Executable and Linking Format Specification> available at "
"various locations online."
msgstr ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dlopen>(3), B<elf>(5), B<ld.so>"
"(8), オンラインのいろいろな場所で入手できる I<Executable and Linking Format "
"Specification>"

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:205 build/C/man3/dlopen.3:515
#: build/C/man5/elf.5:1958 build/C/man3/end.3:112 build/C/man8/ld.so.8:383
#: build/C/man8/ldconfig.8:178 build/C/man1/ldd.1:78
#: build/C/man7/rtld-audit.7:605
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:212 build/C/man3/dlopen.3:522
#: build/C/man5/elf.5:1965 build/C/man3/end.3:119 build/C/man8/ld.so.8:390
#: build/C/man8/ldconfig.8:185 build/C/man1/ldd.1:85
#: build/C/man7/rtld-audit.7:612
msgid ""
"This page is part of release 3.37 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.37 の一部である。\n"
"プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/dlopen.3:35
#, no-wrap
msgid "DLOPEN"
msgstr "DLOPEN"

#. type: TH
#: build/C/man3/dlopen.3:35
#, no-wrap
msgid "2008-12-06"
msgstr "2008-12-06"

#. type: TH
#: build/C/man3/dlopen.3:35 build/C/man5/elf.5:33 build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/dlopen.3:39
msgid ""
"dladdr, dlclose, dlerror, dlopen, dlsym, dlvsym - programming interface to "
"dynamic linking loader"
msgstr ""
"dlclose, dlerror, dlopen, dlsym - 動的リンクを行うローダへの プログラミングイ"
"ンターフェース"

#. type: Plain text
#: build/C/man3/dlopen.3:41
msgid "B<#include E<lt>dlfcn.hE<gt>>"
msgstr "B<#include E<lt>dlfcn.hE<gt>>"

#. type: Plain text
#: build/C/man3/dlopen.3:43
msgid "B<void *dlopen(const char *>I<filename>B<, int >I<flag>B<);>"
msgstr "B<void *dlopen(const char *>I<filename>B<, int >I<flag>B<);>"

#. type: Plain text
#: build/C/man3/dlopen.3:45
msgid "B<char *dlerror(void);>"
msgstr "B<char *dlerror(void);>"

#. type: Plain text
#: build/C/man3/dlopen.3:47
msgid "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"
msgstr "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"

#. type: Plain text
#: build/C/man3/dlopen.3:49
msgid "B<int dlclose(void *>I<handle>B<);>"
msgstr "B<int dlclose(void *>I<handle>B<);>"

#. type: Plain text
#: build/C/man3/dlopen.3:51
msgid "Link with I<-ldl>."
msgstr "I<-ldl> でリンクする。"

#. type: Plain text
#: build/C/man3/dlopen.3:58
msgid ""
"The four functions B<dlopen>(), B<dlsym>(), B<dlclose>(), B<dlerror>()  "
"implement the interface to the dynamic linking loader."
msgstr ""
"B<dlopen>(), B<dlsym>(), B<dlclose>(), B<dlerror>()  の 4つの関数は、動的リン"
"ク (dynamic linking) を行うローダへの インタフェースを実装したものである。"

#. type: SS
#: build/C/man3/dlopen.3:58
#, no-wrap
msgid "dlerror()"
msgstr "dlerror()"

#. type: Plain text
#: build/C/man3/dlopen.3:71
msgid ""
"The function B<dlerror>()  returns a human readable string describing the "
"most recent error that occurred from B<dlopen>(), B<dlsym>()  or B<dlclose>"
"()  since the last call to B<dlerror>().  It returns NULL if no errors have "
"occurred since initialization or since it was last called."
msgstr ""
"関数 B<dlerror>()  は、前回 B<dlerror>()  が呼び出された後に、 B<dlopen>(), "
"B<dlsym>(), B<dlclose>()  のいずれかで最後に発生したエラーについての説明メッ"
"セージを返す。 初期化後または前回呼び出された後で、エラーが発生していなけれ"
"ば NULL を返す。"

#. type: SS
#: build/C/man3/dlopen.3:71
#, no-wrap
msgid "dlopen()"
msgstr "dlopen()"

#. type: Plain text
#: build/C/man3/dlopen.3:89
msgid ""
"The function B<dlopen>()  loads the dynamic library file named by the null-"
"terminated string I<filename> and returns an opaque \"handle\" for the "
"dynamic library.  If I<filename> is NULL, then the returned handle is for "
"the main program.  If I<filename> contains a slash (\"/\"), then it is "
"interpreted as a (relative or absolute) pathname.  Otherwise, the dynamic "
"linker searches for the library as follows (see B<ld.so>(8)  for further "
"details):"
msgstr ""
"関数 B<dlopen>()  は、NULL 終端された文字列 I<filename> で指定されたファイル"
"名の動的ライブラリ (dynamic library) をロードし、 その動的ライブラリへの内部"
"「ハンドル」を返す。 I<filename> が NULL の場合、メイン・プログラムへのハンド"
"ルが返される。 I<filename> がスラッシュ (\"/\") を含む場合、(相対か絶対かの)"
"パス名として解釈される。 それ以外の場合、動的リンカは以下の手順でライブラリを"
"検索する (詳細は B<ld.so>(8)  を参照):"

#. type: IP
#: build/C/man3/dlopen.3:89 build/C/man3/dlopen.3:93 build/C/man3/dlopen.3:100
#: build/C/man3/dlopen.3:104 build/C/man3/dlopen.3:111 build/C/man8/ld.so.8:45
#: build/C/man8/ld.so.8:50 build/C/man8/ld.so.8:55 build/C/man8/ld.so.8:59
#: build/C/man8/ld.so.8:67
#, no-wrap
msgid "o"
msgstr "o"

#. type: Plain text
#: build/C/man3/dlopen.3:93
msgid ""
"(ELF only) If the executable file for the calling program contains a "
"DT_RPATH tag, and does not contain a DT_RUNPATH tag, then the directories "
"listed in the DT_RPATH tag are searched."
msgstr ""
"(ELF のみ) 呼び出し元プログラムの実行ファイルに DT_RPATH タグが含まれてお"
"り、 DT_RUNPATH タグが含まれていない場合、DT_RPATH タグに書かれている ディレ"
"クトリ・リストを検索する。"

#. type: Plain text
#: build/C/man3/dlopen.3:100
msgid ""
"If, at the time that the program was started, the environment variable "
"B<LD_LIBRARY_PATH> was defined to contain a colon-separated list of "
"directories, then these are searched.  (As a security measure this variable "
"is ignored for set-user-ID and set-group-ID programs.)"
msgstr ""
"プログラムの開始時に環境変数 B<LD_LIBRARY_PATH> にコロン区切りのディレクトリ"
"のリストが定義されていれば、 この環境変数に定義されたディレクトリが検索され"
"る (セキュリティ上の理由で、この変数は set-UID や set-GID された プログラムの"
"場合は無視される)。"

#. type: Plain text
#: build/C/man3/dlopen.3:104
msgid ""
"(ELF only) If the executable file for the calling program contains a "
"DT_RUNPATH tag, then the directories listed in that tag are searched."
msgstr ""
"(ELF のみ) 呼び出し元プログラムの実行ファイルに DT_RUNPATH タグが含まれて い"
"る場合、そのタグに書かれているディレクトリ・リストを検索する。"

#. type: Plain text
#: build/C/man3/dlopen.3:111
msgid ""
"The cache file I</etc/ld.so.cache> (maintained by B<ldconfig>(8))  is "
"checked to see whether it contains an entry for I<filename>."
msgstr ""
"キャッシュファイル I</etc/ld.so.cache> の中に I<filename> のエントリが入って"
"いるかをチェックする (B</etc/ld.so.cache> は B<ldconfig>(8)  によって管理され"
"ている)。"

#. type: Plain text
#: build/C/man3/dlopen.3:117
msgid "The directories I</lib> and I</usr/lib> are searched (in that order)."
msgstr "ディレクトリ I</lib> と I</usr/lib> をこの順番で検索する。"

#. type: Plain text
#: build/C/man3/dlopen.3:123
msgid ""
"If the library has dependencies on other shared libraries, then these are "
"also automatically loaded by the dynamic linker using the same rules.  (This "
"process may occur recursively, if those libraries in turn have dependencies, "
"and so on.)"
msgstr ""
"そのライブラリが他の共有ライブラリに依存している場合は、 依存しているライブラ"
"リも動的リンカが同じ検索ルールに基づいて 自動的にロードする (それらのライブラ"
"リにさらに依存関係がある場合などは この処理は再帰的に行われる)。"

#. type: Plain text
#: build/C/man3/dlopen.3:126
msgid "One of the following two values must be included in I<flag>:"
msgstr "I<flag> には以下の 2 つの値のいずれかを含めなければならない:"

#. type: TP
#: build/C/man3/dlopen.3:126
#, no-wrap
msgid "B<RTLD_LAZY>"
msgstr "B<RTLD_LAZY>"

#. type: Plain text
#: build/C/man3/dlopen.3:134
msgid ""
"Perform lazy binding.  Only resolve symbols as the code that references them "
"is executed.  If the symbol is never referenced, then it is never resolved.  "
"(Lazy binding is only performed for function references; references to "
"variables are always immediately bound when the library is loaded.)"
msgstr ""
"lazy binding (手抜きなシンボルの結び付け) が行う。 シンボルの解決はそのシンボ"
"ルを参照するコードが実行されるときにのみ 行われる。シンボルが一度も参照されな"
"かった場合には、そのシンボルは 解決されないままとなる。 (lazy binding は関数"
"参照についてのみ実施される; 変数への参照は常に ライブラリがロードされた時点で"
"直ちに解決される。)"

#. type: TP
#: build/C/man3/dlopen.3:134
#, no-wrap
msgid "B<RTLD_NOW>"
msgstr "B<RTLD_NOW>"

#. type: Plain text
#: build/C/man3/dlopen.3:143
msgid ""
"If this value is specified, or the environment variable B<LD_BIND_NOW> is "
"set to a nonempty string, all undefined symbols in the library are resolved "
"before B<dlopen>()  returns.  If this cannot be done, an error is returned."
msgstr ""
"この値が指定されるか、環境変数 B<LD_BIND_NOW> に空でない文字列が設定された場"
"合、 ライブラリ中の未定義のシンボルを全て解決してから B<dlopen>()  は復帰す"
"る。解決できなかったときにはエラーが返される。"

#. type: Plain text
#: build/C/man3/dlopen.3:146
msgid "Zero or more of the following values may also be ORed in I<flag>:"
msgstr ""
"以下の値のうち 0 個以上を論理和 (OR) の形で I<flag> に追加することもできる:"

#. type: TP
#: build/C/man3/dlopen.3:146
#, no-wrap
msgid "B<RTLD_GLOBAL>"
msgstr "B<RTLD_GLOBAL>"

#. type: Plain text
#: build/C/man3/dlopen.3:150
msgid ""
"The symbols defined by this library will be made available for symbol "
"resolution of subsequently loaded libraries."
msgstr ""
"このライブラリで定義されているシンボルが、これより後でロードされる ライブラリ"
"のシンボル解決で利用できるようになる。"

#. type: TP
#: build/C/man3/dlopen.3:150
#, no-wrap
msgid "B<RTLD_LOCAL>"
msgstr "B<RTLD_LOCAL>"

#. type: Plain text
#: build/C/man3/dlopen.3:157
msgid ""
"This is the converse of B<RTLD_GLOBAL>, and the default if neither flag is "
"specified.  Symbols defined in this library are not made available to "
"resolve references in subsequently loaded libraries."
msgstr ""
"このフラグは B<RTLD_GLOBAL> の反対の意味であり、どちらのフラグも指定されな"
"かった場合は こちらがデフォルトとなる。 このライブラリで定義されているシンボ"
"ルは、これより後でロードされる ライブラリでのシンボル参照で利用できない。"

#. type: TP
#: build/C/man3/dlopen.3:157
#, no-wrap
msgid "B<RTLD_NODELETE> (since glibc 2.2)"
msgstr "B<RTLD_NODELETE> (glibc 2.2 以降)"

#.  (But it is present on Solaris.)
#. type: Plain text
#: build/C/man3/dlopen.3:167
msgid ""
"Do not unload the library during B<dlclose>().  Consequently, the library's "
"static variables are not reinitialized if the library is reloaded with "
"B<dlopen>()  at a later time.  This flag is not specified in POSIX.1-2001."
msgstr ""
"B<dlclose>()  中にそのライブラリをアンロードしない。 そのため、同じライブラリ"
"をこれ以降に B<dlopen>()  で再度ロードした場合に、ライブラリ内の静的変数は再"
"初期化されない。 このフラグは POSIX.1-2001 では規定されていない。"

#. type: TP
#: build/C/man3/dlopen.3:167
#, no-wrap
msgid "B<RTLD_NOLOAD> (since glibc 2.2)"
msgstr "B<RTLD_NOLOAD> (glibc 2.2 以降)"

#.  (But it is present on Solaris.)
#. type: Plain text
#: build/C/man3/dlopen.3:182
msgid ""
"Don't load the library.  This can be used to test if the library is already "
"resident (B<dlopen>()  returns NULL if it is not, or the library's handle if "
"it is resident).  This flag can also be used to promote the flags on a "
"library that is already loaded.  For example, a library that was previously "
"loaded with B<RTLD_LOCAL> can be reopened with B<RTLD_NOLOAD\\ |\\ "
"RTLD_GLOBAL>.  This flag is not specified in POSIX.1-2001."
msgstr ""
"そのライブラリをロードしない。 このフラグはそのライブラリがすでに組み込まれて"
"いるかを検査するのに 利用できる (B<dlopen>()  は、ライブラリが組み込まれてい"
"なければ NULL を返し、 すでに組み込まれていればそのライブラリのハンドルを返"
"す)。 また、すでにロードされているライブラリのフラグを昇格させるのにも 利用で"
"きる。例えば、過去に B<RTLD_LOCAL> でロードしたライブラリを B<RTLD_NOLOAD\\ |"
"\\ RTLD_GLOBAL> で再オープンすることができる。 このフラグは POSIX.1-2001 では"
"規定されていない。"

#. type: TP
#: build/C/man3/dlopen.3:182
#, no-wrap
msgid "B<RTLD_DEEPBIND> (since glibc 2.3.4)"
msgstr "B<RTLD_DEEPBIND> (glibc 2.3.4 以降)"

#.  Inimitably described by UD in
#.  http://sources.redhat.com/ml/libc-hacker/2004-09/msg00083.html.
#. type: Plain text
#: build/C/man3/dlopen.3:192
msgid ""
"Place the lookup scope of the symbols in this library ahead of the global "
"scope.  This means that a self-contained library will use its own symbols in "
"preference to global symbols with the same name contained in libraries that "
"have already been loaded.  This flag is not specified in POSIX.1-2001."
msgstr ""
"このライブラリ内のシンボルの参照領域をグローバル領域よりも前に配置する。 つま"
"り、内蔵型のライブラリでは、すでにロードされたライブラリに含まれる 同じ名前の"
"グローバルなシンボルよりも自ライブラリ内のシンボルが優先して 使われる。 この"
"フラグは POSIX.1-2001 では規定されていない。"

#. type: Plain text
#: build/C/man3/dlopen.3:204
msgid ""
"If I<filename> is a NULL pointer, then the returned handle is for the main "
"program.  When given to B<dlsym>(), this handle causes a search for a symbol "
"in the main program, followed by all shared libraries loaded at program "
"startup, and then all shared libraries loaded by B<dlopen>()  with the flag "
"B<RTLD_GLOBAL>."
msgstr ""
"I<filename> が NULL ポインタである場合は、 返されるハンドルはメイン・プログラ"
"ムのものになる。 このハンドルが B<dlsym>()  に渡されると、シンボルの検索は、"
"メイン・プログラム内、 プログラムの起動時にロードされる全ての共有ライブラ"
"リ、 B<dlopen>()  によって B<RTLD_GLOBAL> フラグ付きでロードされた全ての共有"
"ライブラリ、の順序で行われる。"

#. type: Plain text
#: build/C/man3/dlopen.3:214
msgid ""
"External references in the library are resolved using the libraries in that "
"library's dependency list and any other libraries previously opened with the "
"B<RTLD_GLOBAL> flag.  If the executable was linked with the flag \"-rdynamic"
"\" (or, synonymously, \"--export-dynamic\"), then the global symbols in the "
"executable will also be used to resolve references in a dynamically loaded "
"library."
msgstr ""
"オープンされたライブラリ中での外部参照は、 そのライブラリの依存リストにあるラ"
"イブラリか、 B<RTLD_GLOBAL> フラグ付きで既にオープンされているライブラリを"
"使って解決される。 実行ファイルが \"-rdynamic\" フラグ (\"--export-dynamic\" "
"も同義)  付きでリンクされている場合は、実行ファイル中のグローバルシンボル"
"も、 動的にロードされるライブラリ内の参照解決に用いられる。"

#. type: Plain text
#: build/C/man3/dlopen.3:232
msgid ""
"If the same library is loaded again with B<dlopen>(), the same file handle "
"is returned.  The dl library maintains reference counts for library handles, "
"so a dynamic library is not deallocated until B<dlclose>()  has been called "
"on it as many times as B<dlopen>()  has succeeded on it.  The B<_init>()  "
"routine, if present, is only called once.  But a subsequent call with "
"B<RTLD_NOW> may force symbol resolution for a library earlier loaded with "
"B<RTLD_LAZY>."
msgstr ""
"同じライブラリが B<dlopen>()  によって再度ロードされた場合には、同じファイル"
"ハンドルが返される。 dl ライブラリはライブラリハンドルのリンク数を管理してい"
"る。 したがって動的ライブラリは B<dlclose>()  が B<dlopen>()  と同じ回数だけ"
"呼び出されない限りアンロードされない。 B<_init>()  ルーチンは一度だけ呼び出さ"
"れる (B<_init>()  が存在する場合のみ)。 B<RTLD_NOW> が指定されて B<dlopen>"
"()  が呼び出された場合、 B<RTLD_LAZY> で以前にロードされたライブラリのシンボ"
"ル解決が実行されることがある。"

#. type: Plain text
#: build/C/man3/dlopen.3:236
msgid "If B<dlopen>()  fails for any reason, it returns NULL."
msgstr "B<dlopen>()  は、何らかの理由で失敗すると NULL を返す。"

#. type: SS
#: build/C/man3/dlopen.3:236
#, no-wrap
msgid "dlsym()"
msgstr "dlsym()"

#. type: Plain text
#: build/C/man3/dlopen.3:265
msgid ""
"The function B<dlsym>()  takes a \"handle\" of a dynamic library returned by "
"B<dlopen>()  and the null-terminated symbol name, returning the address "
"where that symbol is loaded into memory.  If the symbol is not found, in the "
"specified library or any of the libraries that were automatically loaded by "
"B<dlopen>()  when that library was loaded, B<dlsym>()  returns NULL.  (The "
"search performed by B<dlsym>()  is breadth first through the dependency tree "
"of these libraries.)  Since the value of the symbol could actually be NULL "
"(so that a NULL return from B<dlsym>()  need not indicate an error), the "
"correct way to test for an error is to call B<dlerror>()  to clear any old "
"error conditions, then call B<dlsym>(), and then call B<dlerror>()  again, "
"saving its return value into a variable, and check whether this saved value "
"is not NULL."
msgstr ""
"関数 B<dlsym>()  は、 B<dlopen>()  が返した動的ライブラリの「ハンドル」と、 "
"NULL 終端されたシンボル名の文字列を引き数に取り、 そのシンボルがロードされた"
"メモリのアドレスを返す。 シンボルが、指定されたライブラリと、指定されたライブ"
"ラリがロードされる際に B<dlopen>()  が自動的にロードしてライブラリのいずれに"
"も見つからない場合には、 B<dlsym>()  は NULL を返す (B<dlsym>()  による検索"
"は、これらのライブラリの依存関係のツリーを先頭から 辿って行われる)。 実際には"
"シンボルの値自体が NULL になることもある (そのため、 B<dlsym>()  の返り値が "
"NULL であったとしても必ずしもエラーという訳ではない)。 エラーかどうかを確認す"
"る正しい方法は以下の通りである: B<dlerror>()  を呼び出して以前のエラー状態を"
"クリアしてから、 B<dlsym>()  を呼び出す。その後でもう一度 B<dlerror>()  を呼"
"び出して、 B<dlerror>()  の返り値を変数に保存し、保存した値が NULL であるか判"
"定する。"

#. type: Plain text
#: build/C/man3/dlopen.3:277
msgid ""
"There are two special pseudo-handles, B<RTLD_DEFAULT> and B<RTLD_NEXT>.  The "
"former will find the first occurrence of the desired symbol using the "
"default library search order.  The latter will find the next occurrence of a "
"function in the search order after the current library.  This allows one to "
"provide a wrapper around a function in another shared library."
msgstr ""
"B<RTLD_DEFAULT> と B<RTLD_NEXT> という二つの特別な擬似ハンドルがある。 "
"B<RTLD_DEFAULT> は、デフォルトのライブラリ検索順序にしたがって、 検索対象のシ"
"ンボルが最初に現れるところを探す。 B<RTLD_NEXT> は、ライブラリ検索順序の中で"
"現在のライブラリ以降で最初に 関数が現れるところを探す。この機能を使うことで、"
"別の共有ライブラリの 関数へのラッパーを提供することができる。"

#. type: SS
#: build/C/man3/dlopen.3:277
#, no-wrap
msgid "dlclose()"
msgstr "dlclose()"

#. type: Plain text
#: build/C/man3/dlopen.3:284
msgid ""
"The function B<dlclose>()  decrements the reference count on the dynamic "
"library handle I<handle>.  If the reference count drops to zero and no other "
"loaded libraries use symbols in it, then the dynamic library is unloaded."
msgstr ""
"関数 B<dlclose>()  は動的ライブラリのハンドル I<handle> の参照カウントを 1 減"
"らす。参照カウントが 0 になり、ロードされている 他のライブラリからそのライブ"
"ラリ内のシンボルが使われていなければ、 その動的ライブラリをアンロードする。"

#. type: Plain text
#: build/C/man3/dlopen.3:288
msgid "The function B<dlclose>()  returns 0 on success, and nonzero on error."
msgstr ""
"関数 B<dlclose>()  は、成功した場合は 0 を返し、エラーの場合 0 以外を返す。"

#. type: SS
#: build/C/man3/dlopen.3:288
#, no-wrap
msgid "The obsolete symbols _init() and _fini()"
msgstr "廃止されたシンボル _init() と _fini()"

#. type: Plain text
#: build/C/man3/dlopen.3:306
msgid ""
"The linker recognizes special symbols B<_init> and B<_fini>.  If a dynamic "
"library exports a routine named B<_init>(), then that code is executed after "
"the loading, before B<dlopen>()  returns.  If the dynamic library exports a "
"routine named B<_fini>(), then that routine is called just before the "
"library is unloaded.  In case you need to avoid linking against the system "
"startup files, this can be done by using the B<gcc>(1)  I<-nostartfiles> "
"command-line option."
msgstr ""
"リンカは B<_init> と B<_fini> を特別なシンボルと解釈する。 ある動的ライブラリ"
"で B<_init>()  という名前のルーチンがエクスポートされていれば、 そのコード"
"は、ライブラリのロード後、かつ B<dlopen>()  が復帰する前に実行される。 その動"
"的ライブラリで B<_fini>()  という名前のルーチンがエクスポートされていれば、 "
"ライブラリがアンロードされる直前にそのルーチンが呼び出される。 システムの起動"
"ファイルに対するリンクを避ける必要がある場合、 B<gcc>(1)  のコマンドラインに "
"I<-nostartfiles> オプションを指定すればよい。"

#.  void _init(void) __attribute__((constructor));
#.  void _fini(void) __attribute__((destructor));
#. type: Plain text
#: build/C/man3/dlopen.3:317
msgid ""
"Using these routines, or the gcc B<-nostartfiles> or B<-nostdlib> options, "
"is not recommended.  Their use may result in undesired behavior, since the "
"constructor/destructor routines will not be executed (unless special "
"measures are taken)."
msgstr ""
"このルーチンや、gcc のオプション B<-nostartfiles> や B<-nostdlib> は使用しな"
"いことを推奨する。 これらを使うと、望ましくない動作をすることがある。 なぜな"
"ら、(特別な措置が行われない限り) これらの constructor/destructor ルーチンは実"
"行されないからである。"

#. type: Plain text
#: build/C/man3/dlopen.3:329
msgid ""
"Instead, libraries should export routines using the B<__attribute__"
"((constructor))> and B<__attribute__((destructor))> function attributes.  "
"See the gcc info pages for information on these.  Constructor routines are "
"executed before B<dlopen>()  returns, and destructor routines are executed "
"before B<dlclose>()  returns."
msgstr ""
"代わりに、ライブラリは B<__attribute__((constructor))> や B<__attribute__"
"((destructor))> の関数属性を使って必要なルーチンをエクスポートするのがよい。 "
"これらについては gcc の info ページを参照のこと。 constructor ルーチンは "
"B<dlopen>()  が復帰する前に実行され、 destructor ルーチンは B<dlclose>()  が"
"復帰する前に実行される。"

#. type: SS
#: build/C/man3/dlopen.3:329
#, no-wrap
msgid "Glibc extensions: dladdr() and dlvsym()"
msgstr "GNU での拡張: dladdr() と dlvsym()"

#. type: Plain text
#: build/C/man3/dlopen.3:331
msgid "Glibc adds two functions not described by POSIX, with prototypes"
msgstr ""
"glibc では POSIX には記載されていない関数が 2つ追加されている。 プロトタイプ"
"は以下の通りである。"

#. type: Plain text
#: build/C/man3/dlopen.3:335
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/dlopen.3:337
#, no-wrap
msgid "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"
msgstr "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man3/dlopen.3:339
#, no-wrap
msgid "B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char *>I<version>B<);>\n"
msgstr "B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char *>I<version>B<);>\n"

#. type: Plain text
#: build/C/man3/dlopen.3:348
msgid ""
"The function B<dladdr>()  takes a function pointer and tries to resolve name "
"and file where it is located.  Information is stored in the I<Dl_info> "
"structure:"
msgstr ""
"関数 B<dladdr>()  は、関数のポインタを引き数にとり、関数の名前と関数が定義さ"
"れている ファイルの解決を試みる。情報は I<Dl_info> 構造体に格納される。"

#. type: Plain text
#: build/C/man3/dlopen.3:361
#, no-wrap
msgid ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Address at which shared object\n"
"                               is loaded */\n"
"    const char *dli_sname;  /* Name of nearest symbol with address\n"
"                               lower than I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"
msgstr ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Address at which shared object\n"
"                               is loaded */\n"
"    const char *dli_sname;  /* Name of nearest symbol with address\n"
"                               lower than I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"

#. type: Plain text
#: build/C/man3/dlopen.3:371
msgid ""
"If no symbol matching I<addr> could be found, then I<dli_sname> and "
"I<dli_saddr> are set to NULL."
msgstr ""
"I<addr> にマッチするシンボルが見つからなかった場合、 I<dli_sname> と "
"I<dli_saddr> は NULL にセットされる。"

#. type: Plain text
#: build/C/man3/dlopen.3:374
msgid "B<dladdr>()  returns 0 on error, and nonzero on success."
msgstr "B<dladdr>()  は、エラー時には 0 を返し、成功した場合は 0 以外を返す。"

#. type: Plain text
#: build/C/man3/dlopen.3:381
msgid ""
"The function B<dlvsym>(), provided by glibc since version 2.1, does the same "
"as B<dlsym>()  but takes a version string as an additional argument."
msgstr ""
"関数 B<dlvsym>()  は B<dlsym>()  と同じ動作をするが、バージョンの文字列を渡す"
"引き数が 追加されている点が異なる (B<dlvsym>()  はバージョン 2.1 以降の "
"glibc で提供されている)。"

#. type: Plain text
#: build/C/man3/dlopen.3:388
msgid ""
"POSIX.1-2001 describes B<dlclose>(), B<dlerror>(), B<dlopen>(), and B<dlsym>"
"()."
msgstr ""
"POSIX.1-2003 には B<dlclose>(), B<dlerror>(), B<dlopen>(), B<dlsym>().  の記"
"載がある。"

#. type: SH
#: build/C/man3/dlopen.3:388 build/C/man5/elf.5:1907 build/C/man3/end.3:52
#: build/C/man8/ld.so.8:367 build/C/man1/ldd.1:42
#: build/C/man7/rtld-audit.7:465
#, no-wrap
msgid "NOTES"
msgstr "注意"

#.  .LP
#.  The string returned by
#.  .BR dlerror ()
#.  should not be modified.
#.  Some systems give the prototype as
#.  .sp
#.  .in +5
#.  .B "const char *dlerror(void);"
#.  .in
#. type: Plain text
#: build/C/man3/dlopen.3:407
msgid ""
"The symbols B<RTLD_DEFAULT> and B<RTLD_NEXT> are defined by I<E<lt>dlfcn."
"hE<gt>> only when B<_GNU_SOURCE> was defined before including it."
msgstr ""
"シンボル B<RTLD_DEFAULT> と B<RTLD_NEXT> は I<E<lt>dlfcn.hE<gt>> で定義されて"
"おり、 I<E<lt>dlfcn.hE<gt>> のインクルード前に B<_GNU_SOURCE> が定義されてい"
"る場合のみ有効となる。"

#. type: Plain text
#: build/C/man3/dlopen.3:412
msgid ""
"Since glibc 2.2.3, B<atexit>(3)  can be used to register an exit handler "
"that is automatically called when a library is unloaded."
msgstr ""
"glibc 2.2.3 以降では、 B<atexit>(3)  を使って、ライブラリがアンロードされる際"
"に自動的に呼び出される 終了ハンドラ (exit handler) を登録することができる。"

#. type: SS
#: build/C/man3/dlopen.3:412
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man3/dlopen.3:418
msgid ""
"The dlopen interface standard comes from SunOS.  That system also has "
"B<dladdr>(), but not B<dlvsym>()."
msgstr ""
"dlopen インターフェースの標準は SunOS をもとにしている。 SunOS には B<dladdr>"
"()  もあったが、 B<dlvsym>()  はなかった。"

#. type: SH
#: build/C/man3/dlopen.3:418 build/C/man1/ldd.1:59
#: build/C/man7/rtld-audit.7:590
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/dlopen.3:430
msgid ""
"Sometimes, the function pointers you pass to B<dladdr>()  may surprise you.  "
"On some architectures (notably i386 and x86_64), I<dli_fname> and "
"I<dli_fbase> may end up pointing back at the object from which you called "
"B<dladdr>(), even if the function used as an argument should come from a "
"dynamically linked library."
msgstr ""
"時として、 B<dladdr>()  に渡した関数ポインタは驚くような値になることがある。 "
"いくつかのアーキテクチャ (特に i386 と x86_64) では、 引き数として使用した関"
"数が動的リンクライブラリで定義されるもので あったとしても、 I<dli_fname> と "
"I<dli_fbase> が B<dladdr>()  を呼び出したオブジェクトを参照した状態で終わって"
"いることがある。"

#. type: Plain text
#: build/C/man3/dlopen.3:446
msgid ""
"The problem is that the function pointer will still be resolved at compile "
"time, but merely point to the I<plt> (Procedure Linkage Table)  section of "
"the original object (which dispatches the call after asking the dynamic "
"linker to resolve the symbol).  To work around this, you can try to compile "
"the code to be position-independent: then, the compiler cannot prepare the "
"pointer at compile time anymore and today's B<gcc>(1)  will generate code "
"that just loads the final symbol address from the I<got> (Global Offset "
"Table) at run time before passing it to B<dladdr>()."
msgstr ""
"問題は、関数ポインタの解決は今なおコンパイル時に行われるが、 そのポインタは元"
"のオブジェクトの I<plt> (Procedure Linkage Table) セクションを指しているだけ"
"だという点にある (オブジェクト自体は、ダイナミックリンカによってシンボルの解"
"決が行われた後に、 関数の呼び出しを行う)。 これに対処する方法としては、 コー"
"ドを position-independent でコンパイルするという方法がある。 そうすると、コン"
"パイラはコンパイル時にポインタを用意することができず、 今日の B<gcc>(1)  で"
"は、実行時に B<dladdr>()  に関数ポインタを渡す前に、 I<got> (Global Offset "
"Table) から最終的なシンボルのアドレスをロードするだけの コードが生成される。"

#. type: Plain text
#: build/C/man3/dlopen.3:448
msgid "Load the math library, and print the cosine of 2.0:"
msgstr "math ライブラリをロードし、2.0 の余弦を表示する"

#. type: Plain text
#: build/C/man3/dlopen.3:453
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"

#. type: Plain text
#: build/C/man3/dlopen.3:460
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"

#. type: Plain text
#: build/C/man3/dlopen.3:466
#, no-wrap
msgid ""
"    handle = dlopen(\"libm.so\", RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    handle = dlopen(\"libm.so\", RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlopen.3:468
#, no-wrap
msgid "    dlerror();    /* Clear any existing error */\n"
msgstr "    dlerror();    /* Clear any existing error */\n"

#. type: Plain text
#: build/C/man3/dlopen.3:475
#, no-wrap
msgid ""
"    /* Writing: cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"
"       would seem more natural, but the C99 standard leaves\n"
"       casting from \"void *\" to a function pointer undefined.\n"
"       The assignment used below is the POSIX.1-2003 (Technical\n"
"       Corrigendum 1) workaround; see the Rationale for the\n"
"       POSIX specification of dlsym(). */\n"
msgstr ""
"    /* Writing: cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"
"       would seem more natural, but the C99 standard leaves\n"
"       casting from \"void *\" to a function pointer undefined.\n"
"       The assignment used below is the POSIX.1-2003 (Technical\n"
"       Corrigendum 1) workaround; see the Rationale for the\n"
"       POSIX specification of dlsym(). */\n"

#.  But in fact "gcc -O2 -Wall" will complain about the preceding cast.
#. type: Plain text
#: build/C/man3/dlopen.3:478
#, no-wrap
msgid "    *(void **) (&cosine) = dlsym(handle, \"cos\");\n"
msgstr "    *(void **) (&cosine) = dlsym(handle, \"cos\");\n"

#. type: Plain text
#: build/C/man3/dlopen.3:483
#, no-wrap
msgid ""
"    if ((error = dlerror()) != NULL)  {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if ((error = dlerror()) != NULL)  {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/dlopen.3:488
#, no-wrap
msgid ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/dlopen.3:492
msgid ""
"If this program were in a file named \"foo.c\", you would build the program "
"with the following command:"
msgstr ""
"このプログラムを \"foo.c\" に書いたとすると、以下のコマンドでプログラムを ビ"
"ルドできる。"

#. type: Plain text
#: build/C/man3/dlopen.3:495
#, no-wrap
msgid "    gcc -rdynamic -o foo foo.c -ldl\n"
msgstr "    gcc -rdynamic -o foo foo.c -ldl\n"

#. type: Plain text
#: build/C/man3/dlopen.3:503
msgid ""
"Libraries exporting B<_init>()  and B<_fini>()  will want to be compiled as "
"follows, using I<bar.c> as the example name:"
msgstr ""
"B<_init>()  と B<_fini>()  をエクスポートするライブラリの場合は 以下のように"
"してコンパイルする必要がある。 例として I<bar.c> をコンパイルする場合:"

#. type: Plain text
#: build/C/man3/dlopen.3:506
#, no-wrap
msgid "    gcc -shared -nostartfiles -o bar bar.c\n"
msgstr "    gcc -shared -nostartfiles -o bar bar.c\n"

#. type: Plain text
#: build/C/man3/dlopen.3:515
msgid ""
"B<ld>(1), B<ldd>(1), B<dl_iterate_phdr>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8), ld.so info pages, gcc info pages, ld info pages"
msgstr ""
"B<ld>(1), B<ldd>(1), B<dl_iterate_phdr>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8), ld.so info pages, gcc info pages, ld info pages"

#. type: TH
#: build/C/man5/elf.5:33
#, no-wrap
msgid "ELF"
msgstr "ELF"

#. type: TH
#: build/C/man5/elf.5:33
#, fuzzy, no-wrap
#| msgid "2010-09-10"
msgid "2010-06-19"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man5/elf.5:36
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr "elf - 実行可能リンクフォーマット (ELF) ファイルのフォーマット"

#.  .B #include <elf_abi.h>
#. type: Plain text
#: build/C/man5/elf.5:40
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr "B<#include E<lt>elf.hE<gt>>\n"

#. type: Plain text
#: build/C/man5/elf.5:48
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files and shared libraries."
msgstr ""
"ヘッダファイル I<E<lt>elf.hE<gt>> は ELF 実行可能バイナリファイルのフォーマッ"
"トを定義する。 これらのファイルとしては、通常の実行可能ファイル・ 再配置可能"
"オブジェクトファイル・コアファイル・共有ライブラリがある。"

#. type: Plain text
#: build/C/man5/elf.5:57
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the file."
msgstr ""
"ELF ファイルフォーマットを使う実行可能ファイルは、 ELF ヘッダの後にプログラム"
"ヘッダテーブルまたは セクションヘッダテーブル (またはその両方) が続く構成であ"
"る。 ELF ヘッダは常にファイルのオフセット 0 にある。 プログラムヘッダテーブル"
"とセクションヘッダテーブルの ファイル内でのオフセットは、ELF ヘッダに定義され"
"ている。 この 2 つのテーブルはファイルの残りの部分の詳細を記述する。"

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: build/C/man5/elf.5:84
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""
"このヘッダファイルは上記のヘッダを C 言語の構造体で記述し、 また動的セクショ"
"ン・再配置可能セクション・シンボルテーブルの構造体も 含んでいる。"

#. type: Plain text
#: build/C/man5/elf.5:96
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""
"以下の型は N ビットアーキテクチャで使われる (N=32,64 であり I<ElfN> は "
"I<Elf32> または I<Elf64> を表し、 I<uintN_t> は I<uint32_t> または "
"I<uint64_t> を表す):"

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: build/C/man5/elf.5:110
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""
"ElfN_Addr       符号なしのプログラムアドレス, uintN_t\n"
"ElfN_Off        符号なしのファイルオフセット, uintN_t\n"
"ElfN_Section    符号なしのセクションインデックス, uint16_t\n"
"ElfN_Versym     符号なしのバージョンシンボル情報, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"

#. type: Plain text
#: build/C/man5/elf.5:125
msgid ""
"(Note: The *BSD terminology is a bit different.  There I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""
"(注意: *BSD での用語は少し異なる。 I<Elf64_Half> は I<Elf32_Half> の 2 倍であ"
"り、 I<Elf64Quarter> が I<uint16_t> に用いられる。 混乱を避けるため、以下で"
"は、これらの型はサイズが自明な型に置き換えてある。)"

#. type: Plain text
#: build/C/man5/elf.5:132
msgid ""
"All data structures that the file format defines follow the \"natural\" size "
"and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, etc."
msgstr ""
"このファイルフォーマットが定義する全てのデータ構造体は、 関連するクラスの "
"\"自然な\" サイズと配置の指針に従う。 必要な場合、データ構造体では明示的なパ"
"ディング (padding, 詰め込み)  が行なわれる。これは 4 バイトオブジェクトに対す"
"る 4 バイト配置を保証するためや、 構造体のサイズを 4 の倍数にするためなどであ"
"る。"

#. type: Plain text
#: build/C/man5/elf.5:137
msgid "The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr "ELF ヘッダは型 I<Elf32_Ehdr> または I<Elf64_Ehdr> で記述される:"

#. type: Plain text
#: build/C/man5/elf.5:141
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr "#define EI_NIDENT 16\n"

#. type: Plain text
#: build/C/man5/elf.5:158
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"

#.  .Bl -tag -width "e_phentsize"
#. type: Plain text
#: build/C/man5/elf.5:163
msgid "The fields have the following meanings:"
msgstr "フィールドは以下の意味を持つ:"

#. type: TP
#: build/C/man5/elf.5:163
#, no-wrap
msgid "I<e_ident>"
msgstr "I<e_ident>"

#. type: Plain text
#: build/C/man5/elf.5:173
msgid ""
"This array of bytes specifies to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is "
"named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr ""
"このバイト配列は、プロセッサやファイルの他の部分には依存せずに、 ファイルを解"
"釈 (interpret) するために指定される。 この配列内のすべてのものは、接頭辞 "
"B<EI_> で始まるマクロの名前が付き、接頭辞 B<ELF> で始まる値を持つ。 以下のマ"
"クロが定義されている:"

#. type: TP
#: build/C/man5/elf.5:175
#, no-wrap
msgid "B<EI_MAG0>"
msgstr "B<EI_MAG0>"

#. type: Plain text
#: build/C/man5/elf.5:181
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0: "
"0x7f)"
msgstr ""
"マジックナンバーの第 1 バイト。 B<ELFMAG0> で埋めなければならない。 (0: 0x7f)"

#. type: TP
#: build/C/man5/elf.5:181
#, no-wrap
msgid "B<EI_MAG1>"
msgstr "B<EI_MAG1>"

#. type: Plain text
#: build/C/man5/elf.5:187
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""
"マジックナンバーの第 2 バイト。 B<ELFMAG1> で埋めなければならない。 (1: "
"\\(aqE\\(aq)"

#. type: TP
#: build/C/man5/elf.5:187
#, no-wrap
msgid "B<EI_MAG2>"
msgstr "B<EI_MAG2>"

#. type: Plain text
#: build/C/man5/elf.5:193
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2: "
"\\(aqL\\(aq)"
msgstr ""
"マジックナンバーの第 3 バイト。 B<ELFMAG2> で埋めなければならない。 (2: "
"\\(aqL\\(aq)"

#. type: TP
#: build/C/man5/elf.5:193
#, no-wrap
msgid "B<EI_MAG3>"
msgstr "B<EI_MAG3>"

#. type: Plain text
#: build/C/man5/elf.5:199
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""
"マジックナンバーの第 4 バイト。 B<ELFMAG3> で埋めなければならない。 (3: "
"\\(aqF\\(aq)"

#. type: TP
#: build/C/man5/elf.5:199
#, no-wrap
msgid "B<EI_CLASS>"
msgstr "B<EI_CLASS>"

#. type: Plain text
#: build/C/man5/elf.5:202
msgid "The fifth byte identifies the architecture for this binary:"
msgstr "第 5 バイトは、このバイナリのアーキテクチャを示す:"

#. type: TP
#: build/C/man5/elf.5:204
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr "B<ELFCLASSNONE>"

#. type: Plain text
#: build/C/man5/elf.5:208
msgid "This class is invalid."
msgstr "このクラスは不正である。"

#. type: TP
#: build/C/man5/elf.5:208
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr "B<ELFCLASS32>"

#. type: Plain text
#: build/C/man5/elf.5:213
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""
"32 ビットアーキテクチャを定義する。 ファイルと仮想アドレス空間が 4 ギガバイト"
"までのマシンをサポートする。"

#. type: TP
#: build/C/man5/elf.5:213
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr "B<ELFCLASS64>"

#. type: Plain text
#: build/C/man5/elf.5:216
msgid "This defines the 64-bit architecture."
msgstr "64 ビットアーキテクチャを定義する。"

#. type: TP
#: build/C/man5/elf.5:219
#, no-wrap
msgid "B<EI_DATA>"
msgstr "B<EI_DATA>"

#.  .Bl -tag -width "ELFDATA2LSB" -compact
#. type: Plain text
#: build/C/man5/elf.5:225
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in "
"the file.  Currently these encodings are supported:"
msgstr ""
"第 6 バイトはファイル内のプロセッサ固有データの データエンコーディングを指定"
"する。 現在のところ以下のエンコーディングがサポートされている:"

#. type: TP
#: build/C/man5/elf.5:226
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr "B<ELFDATANONE>"

#. type: Plain text
#: build/C/man5/elf.5:230
msgid "Unknown data format."
msgstr "不明なデータフォーマット。"

#. type: TP
#: build/C/man5/elf.5:230
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr "B<ELFDATA2LSB>"

#. type: Plain text
#: build/C/man5/elf.5:233
msgid "Two's complement, little-endian."
msgstr "2 の補数、リトルエンディアン。"

#. type: TP
#: build/C/man5/elf.5:233
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr "B<ELFDATA2MSB>"

#. type: Plain text
#: build/C/man5/elf.5:236
msgid "Two's complement, big-endian."
msgstr "2 の補数、ビッグエンディアン。"

#. type: TP
#: build/C/man5/elf.5:239
#, no-wrap
msgid "B<EI_VERSION>"
msgstr "B<EI_VERSION>"

#.  .Bl -tag -width "EV_CURRENT" -compact
#. type: Plain text
#: build/C/man5/elf.5:244
msgid "The version number of the ELF specification:"
msgstr "ELF 仕様のバージョン番号:"

#. type: TP
#: build/C/man5/elf.5:245 build/C/man5/elf.5:498
#, no-wrap
msgid "B<EV_NONE>"
msgstr "B<EV_NONE>"

#. type: Plain text
#: build/C/man5/elf.5:248 build/C/man5/elf.5:502
msgid "Invalid version."
msgstr "不正なバージョン。"

#. type: TP
#: build/C/man5/elf.5:248 build/C/man5/elf.5:502
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr "B<EV_CURRENT>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:251 build/C/man5/elf.5:506
msgid "Current version."
msgstr "現在のバージョン。"

#. type: TP
#: build/C/man5/elf.5:254
#, no-wrap
msgid "B<EI_OSABI>"
msgstr "B<EI_OSABI>"

#.  .Bl -tag -width "ELFOSABI_STANDALONE" -compact
#. type: Plain text
#: build/C/man5/elf.5:263
msgid ""
"This byte identifies the operating system and ABI to which the object is "
"targeted.  Some fields in other ELF structures have flags and values that "
"have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  E.g.:"
msgstr ""
"このバイトはオブジェクトのターゲットとなる オペレーティングシステムと ABI を"
"示す。 他の ELF 構造体のフィールドには、 プラットフォーム固有の意味を持つフラ"
"グや値を持つものもある; これらのフィールドの解釈は、このバイトの値によって決"
"定される。 例えば:"

#. type: TP
#: build/C/man5/elf.5:264
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr "B<ELFOSABI_NONE>"

#.  0
#. type: Plain text
#: build/C/man5/elf.5:269
msgid "Same as ELFOSABI_SYSV"
msgstr "ELFOSABI_SYSV と同じ。"

#. type: TP
#: build/C/man5/elf.5:269
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr "B<ELFOSABI_SYSV>"

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: build/C/man5/elf.5:274
msgid "UNIX System V ABI."
msgstr "UNIX System V ABI."

#. type: TP
#: build/C/man5/elf.5:274
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr "B<ELFOSABI_HPUX>"

#.  1
#. type: Plain text
#: build/C/man5/elf.5:278
msgid "HP-UX ABI."
msgstr "HP-UX ABI."

#. type: TP
#: build/C/man5/elf.5:278
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr "B<ELFOSABI_NETBSD>"

#.  2
#. type: Plain text
#: build/C/man5/elf.5:282
msgid "NetBSD ABI."
msgstr "NetBSD ABI."

#. type: TP
#: build/C/man5/elf.5:282
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr "B<ELFOSABI_LINUX>"

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI.
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI.
#.  5
#. type: Plain text
#: build/C/man5/elf.5:294
msgid "Linux ABI."
msgstr "Linux ABI."

#. type: TP
#: build/C/man5/elf.5:294
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr "B<ELFOSABI_SOLARIS>"

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI. Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: build/C/man5/elf.5:303
msgid "Solaris ABI."
msgstr "Solaris ABI."

#. type: TP
#: build/C/man5/elf.5:303
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr "B<ELFOSABI_IRIX>"

#.  8
#. type: Plain text
#: build/C/man5/elf.5:307
msgid "IRIX ABI."
msgstr "IRIX ABI."

#. type: TP
#: build/C/man5/elf.5:307
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr "B<ELFOSABI_FREEBSD>"

#.  9
#. type: Plain text
#: build/C/man5/elf.5:311
msgid "FreeBSD ABI."
msgstr "FreeBSD ABI."

#. type: TP
#: build/C/man5/elf.5:311
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr "B<ELFOSABI_TRU64>"

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: build/C/man5/elf.5:319
msgid "TRU64 UNIX ABI."
msgstr "TRU64 UNIX ABI."

#. type: TP
#: build/C/man5/elf.5:319
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr "B<ELFOSABI_ARM>"

#.  97
#. type: Plain text
#: build/C/man5/elf.5:323
msgid "ARM architecture ABI."
msgstr "ARM アーキテクチャ ABI."

#. type: TP
#: build/C/man5/elf.5:323
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr "B<ELFOSABI_STANDALONE>"

#.  255
#.  .El
#. type: Plain text
#: build/C/man5/elf.5:328
msgid "Stand-alone (embedded) ABI."
msgstr "スタンドアロン (組み込み) ABI."

#. type: TP
#: build/C/man5/elf.5:330
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr "B<EI_ABIVERSION>"

#. type: Plain text
#: build/C/man5/elf.5:340
msgid ""
"This byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""
"このバイトはオブジェクトがターゲットとしている ABI のバージョンを示す。 この"
"フィールドは互換性のない ABI のバージョンを区別するために使われる。 このバー"
"ジョン番号の解釈は、 B<EI_OSABI> フィールドで識別される ABI に依存する。 この"
"仕様に準拠するアプリケーションは、値 0 を使う。"

#. type: TP
#: build/C/man5/elf.5:340
#, no-wrap
msgid "B<EI_PAD>"
msgstr "B<EI_PAD>"

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: build/C/man5/elf.5:356
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which "
"read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""
"パディングの開始。 これらのバイトは予約されており、0 に設定されている。 これ"
"らを読み込むプログラムは、これらのバイトを無視すべきである。 現在使われていな"
"いバイトに意味が与えられる場合、 B<EI_PAD> の値は将来変更されるかもしれない。"

#. type: TP
#: build/C/man5/elf.5:356
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr "B<EI_NIDENT>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:362
msgid "The size of the I<e_ident> array."
msgstr "I<e_ident> 配列のサイズ。"

#. type: TP
#: build/C/man5/elf.5:363
#, no-wrap
msgid "I<e_type>"
msgstr "I<e_type>"

#. type: Plain text
#: build/C/man5/elf.5:366
msgid "This member of the structure identifies the object file type:"
msgstr "この構造体のメンバはオブジェクトファイルタイプを示す:"

#. type: TP
#: build/C/man5/elf.5:368
#, no-wrap
msgid "B<ET_NONE>"
msgstr "B<ET_NONE>"

#. type: Plain text
#: build/C/man5/elf.5:372
msgid "An unknown type."
msgstr "不明なタイプ。"

#. type: TP
#: build/C/man5/elf.5:372
#, no-wrap
msgid "B<ET_REL>"
msgstr "B<ET_REL>"

#. type: Plain text
#: build/C/man5/elf.5:375
msgid "A relocatable file."
msgstr "再配置可能ファイル。"

#. type: TP
#: build/C/man5/elf.5:375
#, no-wrap
msgid "B<ET_EXEC>"
msgstr "B<ET_EXEC>"

#. type: Plain text
#: build/C/man5/elf.5:378
msgid "An executable file."
msgstr "実行可能ファイル。"

#. type: TP
#: build/C/man5/elf.5:378
#, no-wrap
msgid "B<ET_DYN>"
msgstr "B<ET_DYN>"

#. type: Plain text
#: build/C/man5/elf.5:381
msgid "A shared object."
msgstr "共有オブジェクト。"

#. type: TP
#: build/C/man5/elf.5:381
#, no-wrap
msgid "B<ET_CORE>"
msgstr "B<ET_CORE>"

#. type: Plain text
#: build/C/man5/elf.5:384
msgid "A core file."
msgstr "コアファイル。"

#. type: TP
#: build/C/man5/elf.5:387
#, no-wrap
msgid "I<e_machine>"
msgstr "I<e_machine>"

#. type: Plain text
#: build/C/man5/elf.5:391
msgid ""
"This member specifies the required architecture for an individual file.  E."
"g.:"
msgstr "このメンバは個々のファイルに必要とされるアーキテクチャを指定する。 例:"

#. type: TP
#: build/C/man5/elf.5:393
#, no-wrap
msgid "B<EM_NONE>"
msgstr "B<EM_NONE>"

#.  0
#. type: Plain text
#: build/C/man5/elf.5:398
msgid "An unknown machine."
msgstr "不明なマシン。"

#. type: TP
#: build/C/man5/elf.5:398
#, no-wrap
msgid "B<EM_M32>"
msgstr "B<EM_M32>"

#.  1
#. type: Plain text
#: build/C/man5/elf.5:402
msgid "AT&T WE 32100."
msgstr "AT&T WE 32100."

#. type: TP
#: build/C/man5/elf.5:402
#, no-wrap
msgid "B<EM_SPARC>"
msgstr "B<EM_SPARC>"

#.  2
#. type: Plain text
#: build/C/man5/elf.5:406
msgid "Sun Microsystems SPARC."
msgstr "Sun Microsystems SPARC."

#. type: TP
#: build/C/man5/elf.5:406
#, no-wrap
msgid "B<EM_386>"
msgstr "B<EM_386>"

#.  3
#. type: Plain text
#: build/C/man5/elf.5:410
msgid "Intel 80386."
msgstr "Intel 80386."

#. type: TP
#: build/C/man5/elf.5:410
#, no-wrap
msgid "B<EM_68K>"
msgstr "B<EM_68K>"

#.  4
#. type: Plain text
#: build/C/man5/elf.5:414
msgid "Motorola 68000."
msgstr "Motorola 68000."

#. type: TP
#: build/C/man5/elf.5:414
#, no-wrap
msgid "B<EM_88K>"
msgstr "B<EM_88K>"

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486.
#.  6
#. type: Plain text
#: build/C/man5/elf.5:422
msgid "Motorola 88000."
msgstr "Motorola 88000."

#. type: TP
#: build/C/man5/elf.5:422
#, no-wrap
msgid "B<EM_860>"
msgstr "B<EM_860>"

#.  7
#. type: Plain text
#: build/C/man5/elf.5:426
msgid "Intel 80860."
msgstr "Intel 80860."

#. type: TP
#: build/C/man5/elf.5:426
#, no-wrap
msgid "B<EM_MIPS>"
msgstr "B<EM_MIPS>"

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated.
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: build/C/man5/elf.5:438
msgid "MIPS RS3000 (big-endian only)."
msgstr "MIPS RS3000 (ビッグエンディアンのみ)。"

#. type: TP
#: build/C/man5/elf.5:438
#, no-wrap
msgid "B<EM_PARISC>"
msgstr "B<EM_PARISC>"

#.  15
#. type: Plain text
#: build/C/man5/elf.5:442
msgid "HP/PA."
msgstr "HP/PA."

#. type: TP
#: build/C/man5/elf.5:442
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr "B<EM_SPARC32PLUS>"

#.  18
#. type: Plain text
#: build/C/man5/elf.5:446
msgid "SPARC with enhanced instruction set."
msgstr "拡張命令セット付き SPARC。"

#. type: TP
#: build/C/man5/elf.5:446
#, no-wrap
msgid "B<EM_PPC>"
msgstr "B<EM_PPC>"

#.  20
#. type: Plain text
#: build/C/man5/elf.5:450
msgid "PowerPC."
msgstr "PowerPC."

#. type: TP
#: build/C/man5/elf.5:450
#, no-wrap
msgid "B<EM_PPC64>"
msgstr "B<EM_PPC64>"

#.  21
#. type: Plain text
#: build/C/man5/elf.5:454
msgid "PowerPC 64-bit."
msgstr "PowerPC 64-bit."

#. type: TP
#: build/C/man5/elf.5:454
#, no-wrap
msgid "B<EM_S390>"
msgstr "B<EM_S390>"

#.  22
#. type: Plain text
#: build/C/man5/elf.5:458
msgid "IBM S/390"
msgstr "IBM S/390"

#. type: TP
#: build/C/man5/elf.5:458
#, no-wrap
msgid "B<EM_ARM>"
msgstr "B<EM_ARM>"

#.  40
#. type: Plain text
#: build/C/man5/elf.5:462
msgid "Advanced RISC Machines"
msgstr "Advanced RISC Machines"

#. type: TP
#: build/C/man5/elf.5:462
#, no-wrap
msgid "B<EM_SH>"
msgstr "B<EM_SH>"

#.  42
#. type: Plain text
#: build/C/man5/elf.5:466
msgid "Renesas SuperH"
msgstr "Renesas SuperH"

#. type: TP
#: build/C/man5/elf.5:466
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr "B<EM_SPARCV9>"

#.  43
#. type: Plain text
#: build/C/man5/elf.5:470
msgid "SPARC v9 64-bit."
msgstr "SPARC v9 64-bit."

#. type: TP
#: build/C/man5/elf.5:470
#, no-wrap
msgid "B<EM_IA_64>"
msgstr "B<EM_IA_64>"

#.  50
#. type: Plain text
#: build/C/man5/elf.5:474
msgid "Intel Itanium"
msgstr "Intel Itanium"

#. type: TP
#: build/C/man5/elf.5:474
#, no-wrap
msgid "B<EM_X86_64>"
msgstr "B<EM_X86_64>"

#.  62
#. type: Plain text
#: build/C/man5/elf.5:478
msgid "AMD x86-64"
msgstr "AMD x86-64"

#. type: TP
#: build/C/man5/elf.5:478
#, no-wrap
msgid "B<EM_VAX>"
msgstr "B<EM_VAX>"

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha.
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set.
#. type: Plain text
#: build/C/man5/elf.5:490
msgid "DEC Vax."
msgstr "DEC Vax."

#. type: TP
#: build/C/man5/elf.5:493
#, no-wrap
msgid "I<e_version>"
msgstr "I<e_version>"

#.  .Bl -tag -width "EV_CURRENT" -compact
#. type: Plain text
#: build/C/man5/elf.5:497
msgid "This member identifies the file version:"
msgstr "このメンバはファイルバージョンを示す:"

#. type: TP
#: build/C/man5/elf.5:508
#, no-wrap
msgid "I<e_entry>"
msgstr "I<e_entry>"

#. type: Plain text
#: build/C/man5/elf.5:514
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""
"このメンバは、システムが最初に制御を渡す、 つまりプロセスを開始する仮想アドレ"
"スを指定する。 ファイルにエントリポイントが関連付けられていない場合、 このメ"
"ンバには 0 が入る。"

#. type: TP
#: build/C/man5/elf.5:514
#, no-wrap
msgid "I<e_phoff>"
msgstr "I<e_phoff>"

#. type: Plain text
#: build/C/man5/elf.5:519
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""
"このメンバはプログラムヘッダテーブルの ファイルオフセット (バイト単位) を保持"
"する。 ファイルにプログラムヘッダテーブルがない場合、 このメンバには 0 が入"
"る。"

#. type: TP
#: build/C/man5/elf.5:519
#, no-wrap
msgid "I<e_shoff>"
msgstr "I<e_shoff>"

#. type: Plain text
#: build/C/man5/elf.5:524
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table this member holds zero."
msgstr ""
"このメンバはセクションヘッダテーブルの ファイルオフセット (バイト単位) を保持"
"する。 ファイルにセクションヘッダテーブルがない場合、 このメンバには 0 が入"
"る。"

#. type: TP
#: build/C/man5/elf.5:524
#, no-wrap
msgid "I<e_flags>"
msgstr "I<e_flags>"

#. type: Plain text
#: build/C/man5/elf.5:529
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently no flags have been defined."
msgstr ""
"このメンバはファイルに関連付けられたプロセッサ固有のフラグを保持する。 フラグ"
"の名前は EF_`machine_flag' という形式である。 現在のところフラグは定義されて"
"いない。"

#. type: TP
#: build/C/man5/elf.5:529
#, no-wrap
msgid "I<e_ehsize>"
msgstr "I<e_ehsize>"

#. type: Plain text
#: build/C/man5/elf.5:532
msgid "This member holds the ELF header's size in bytes."
msgstr "このメンバは ELF ヘッダサイズ (バイト単位) を保持する。"

#. type: TP
#: build/C/man5/elf.5:532
#, no-wrap
msgid "I<e_phentsize>"
msgstr "I<e_phentsize>"

#. type: Plain text
#: build/C/man5/elf.5:536
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""
"このメンバはこのファイルのプログラムヘッダテーブルの 1 エントリあたりのサイ"
"ズ (バイト単位) を保持する; 全てのエントリは同じサイズである。"

#. type: TP
#: build/C/man5/elf.5:536
#, no-wrap
msgid "I<e_phnum>"
msgstr "I<e_phnum>"

#. type: Plain text
#: build/C/man5/elf.5:549
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""
"このメンバはプログラムヘッダテーブルにあるエントリの数を保持する。 よって "
"I<e_phentsize> と I<e_phnum> の積がテーブルサイズ (バイト単位) になる。 ファ"
"イルにプログラムヘッダがない場合、 I<e_phnum> は値 0 を保持する。"

#.  This is a Linux extension, added in Linux 2.6.34.
#.  .Bl -tag -width "PN_XNUM"
#. type: Plain text
#: build/C/man5/elf.5:563
msgid ""
"If the number of entries in the program header table is larger than or equal "
"to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:564
#, no-wrap
msgid "B<PN_XNUM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:569
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:573
#, no-wrap
msgid "I<e_shentsize>"
msgstr "I<e_shentsize>"

#. type: Plain text
#: build/C/man5/elf.5:578
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""
"このメンバはセクションヘッダのサイズ (バイト単位) を保持する。 セクションヘッ"
"ダはセクションヘッダテーブルの 1 つのエントリである; 全てのエントリは同じサイ"
"ズである。"

#. type: TP
#: build/C/man5/elf.5:578
#, no-wrap
msgid "I<e_shnum>"
msgstr "I<e_shnum>"

#. type: Plain text
#: build/C/man5/elf.5:591
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""
"このメンバはセクションヘッダテーブルにあるエントリの数を保持する。 よって "
"I<e_shentsize> と I<e_shnum> の積はセクションヘッダテーブルのサイズ (バイト単"
"位) になる。 ファイルにセクションヘッダテーブルがない場合、 I<e_shnum> は値 "
"0 を保持する。"

#. type: Plain text
#: build/C/man5/elf.5:603
msgid ""
"If the number of entries in the section header table is larger than or equal "
"to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the "
"value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:603
#, no-wrap
msgid "I<e_shstrndx>"
msgstr "I<e_shstrndx>"

#. type: Plain text
#: build/C/man5/elf.5:610
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""
"このメンバはセクション名文字列テーブルに関連付けられたエントリの セクション"
"ヘッダテーブルインデックスを保持する。 ファイルにセクション名文字列テーブルが"
"ない場合、 このメンバは値 B<SHN_UNDEF> を保持する。 B<SHN_UNDEF>."

#. type: Plain text
#: build/C/man5/elf.5:621
msgid ""
"If the index of section name string table section is larger than or equal to "
"B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the "
"real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table. Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:623 build/C/man5/elf.5:909
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr "B<SHN_UNDEF>"

#. type: Plain text
#: build/C/man5/elf.5:632
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless "
"section reference.  For example, a symbol \"defined\" relative to section "
"number B<SHN_UNDEF> is an undefined symbol."
msgstr ""
"この値は未定義・存在しない・無関係その他、 意味のないセクションの参照であるこ"
"とを表す。 例えば、セクション番号 B<SHN_UNDEF> に関連づけて「定義」されたシン"
"ボルは、「未定義」なシンボルである。"

#. type: TP
#: build/C/man5/elf.5:632 build/C/man5/elf.5:913
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr "B<SHN_LORESERVE>"

#. type: Plain text
#: build/C/man5/elf.5:635 build/C/man5/elf.5:916
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr "この値は予約済みのインデックス領域の下限を指定する。"

#. type: TP
#: build/C/man5/elf.5:635 build/C/man5/elf.5:916
#, no-wrap
msgid "B<SHN_LOPROC>"
msgstr "B<SHN_LOPROC>"

#. type: Plain text
#: build/C/man5/elf.5:640 build/C/man5/elf.5:921
msgid ""
"Values greater than or equal to B<SHN_HIPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"この値以上で B<SHN_HIPROC> 以下の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:640 build/C/man5/elf.5:921
#, no-wrap
msgid "B<SHN_HIPROC>"
msgstr "B<SHN_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:645 build/C/man5/elf.5:926
msgid ""
"Values less than or equal to B<SHN_LOPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"この値以下で B<SHN_HIPROC> 以上の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:645 build/C/man5/elf.5:926
#, no-wrap
msgid "B<SHN_ABS>"
msgstr "B<SHN_ABS>"

#. type: Plain text
#: build/C/man5/elf.5:652
msgid ""
"This value specifies absolute values for the corresponding reference.  For "
"example, symbols defined relative to section number B<SHN_ABS> have absolute "
"values and are not affected by relocation."
msgstr ""
"この値は対応する参照の絶対値を指定する。 例えば、セクション番号 B<SHN_ABS> に"
"関連づけられたシンボルは絶対値を保持し、再配置に影響されない。"

#. type: TP
#: build/C/man5/elf.5:652 build/C/man5/elf.5:933
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr "B<SHN_COMMON>"

#. type: Plain text
#: build/C/man5/elf.5:656
msgid ""
"Symbols defined relative to this section are common symbols, such as Fortran "
"COMMON or unallocated C external variables."
msgstr ""
"このセクションに関連して定義されたシンボルは、 Fortran の COMMON や C の未割"
"り当て external 変数のような、 共通シンボルである。"

#. type: TP
#: build/C/man5/elf.5:656 build/C/man5/elf.5:937
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr "B<SHN_HIRESERVE>"

#. type: Plain text
#: build/C/man5/elf.5:669
msgid ""
"This value specifies the upper bound of the range of reserved indices "
"between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, inclusive; the values do not "
"reference the section header table.  That is, the section header table does "
"I<not> contain entries for the reserved indices."
msgstr ""
"この値は予約されたインデックスの範囲の上限を指定する。 B<SHN_LORESERVE> と "
"B<SHN_HIRESERVE> は含まれる。 この値はセクションヘッダテーブルを参照しない。 "
"つまり、セクションヘッダテーブルは 予約されたインデックスのエントリを I<含ま"
"ない 。>"

#. type: Plain text
#: build/C/man5/elf.5:691
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable "
"and shared object files.  A file specifies its own program header size with "
"the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""
"実行可能ファイルまたは共有オブジェクトファイルのプログラムヘッダテーブルは、 "
"システムによるプログラム実行準備に必要な、 セグメント等の情報を記述する構造体"
"の配列である。 オブジェクトファイルの I<セグメント> には 1 つ以上の I<セク"
"ション> が含まれる。 プログラムヘッダは実行可能ファイルと共有オブジェクトファ"
"イルでのみ意味を持つ。 ファイルは自身のプログラムヘッダサイズを ELF ヘッダの "
"I<e_phentsize> メンバと I<e_phnum> メンバで指定する。 ELF プログラムヘッダは "
"I<Elf32_Phdr> 型または I<Elf64_Phdr> 型で記述される (どちらになるかはアーキテ"
"クチャ依存):"

#. type: Plain text
#: build/C/man5/elf.5:704
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:719
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"

#.  .Bl -tag -width "p_offset"
#. type: Plain text
#: build/C/man5/elf.5:727
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in "
"the location of the I<p_flags> member in the total struct."
msgstr ""
"32 ビットと 64 ビットのプログラムヘッダの主な違いは、構造体における "
"I<p_flags> メンバの位置にある。"

#. type: TP
#: build/C/man5/elf.5:727
#, no-wrap
msgid "I<p_type>"
msgstr "I<p_type>"

#.  .Bl -tag -width "PT_DYNAMIC"
#. type: Plain text
#: build/C/man5/elf.5:732
msgid ""
"This member of the Phdr struct tells what kind of segment this array element "
"describes or how to interpret the array element's information."
msgstr ""
"Phdr 構造体のこのメンバは、 この配列要素がどのような種類のセグメントを記述し"
"ているか、 またはこの配列要素の情報をどのように解釈するか、を表す。"

#. type: TP
#: build/C/man5/elf.5:733
#, no-wrap
msgid "B<PT_NULL>"
msgstr "B<PT_NULL>"

#. type: Plain text
#: build/C/man5/elf.5:737
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""
"この配列要素は使用されておらず、その他のメンバの値は未定義である。 これによ"
"り、このプログラムヘッダのエントリは無視される。"

#. type: TP
#: build/C/man5/elf.5:737
#, no-wrap
msgid "B<PT_LOAD>"
msgstr "B<PT_LOAD>"

#. type: Plain text
#: build/C/man5/elf.5:758
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and "
"I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header "
"table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""
"この配列要素は I<p_filesz> と I<p_memsz> で記述されるロード可能セグメントを指"
"定する。 このファイルからのバイトデータが、このメモリセグメントの先頭からマッ"
"プされる。 セグメントのメモリサイズ I<Sy>p_memsz がファイルサイズ "
"I<Sy>p_filesz より大きい場合、 「余った」バイトは値 0 となり、 そのセグメント"
"初期化データの後ろに置かれると定められている。 ファイルサイズはメモリサイズよ"
"り大きくてはいけない。 プログラムヘッダテーブルのロード可能セグメントエントリ"
"は、 I<p_vaddr> メンバの昇順にソートされて出現する。"

#. type: TP
#: build/C/man5/elf.5:758
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr "B<PT_DYNAMIC>"

#. type: Plain text
#: build/C/man5/elf.5:761
msgid "The array element specifies dynamic linking information."
msgstr "この配列要素は動的リンク情報を指定する。"

#. type: TP
#: build/C/man5/elf.5:761
#, no-wrap
msgid "B<PT_INTERP>"
msgstr "B<PT_INTERP>"

#. type: Plain text
#: build/C/man5/elf.5:769
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""
"この配列要素は、インタプリタとして起動されるパス名 (NULL 文字終端)  の位置と"
"サイズを指定する。 このセグメント型は (共有オブジェクトにもあるかも知れない"
"が)  実行可能ファイルでのみ意味を持つ。 ただし、このセグメント型は 1 つのファ"
"イルに 2 回以上出現してはならない。 もし存在する場合、このセグメント型は 全て"
"のロード可能セグメントエントリより前になければならない。"

#. type: TP
#: build/C/man5/elf.5:769
#, no-wrap
msgid "B<PT_NOTE>"
msgstr "B<PT_NOTE>"

#. type: Plain text
#: build/C/man5/elf.5:772
msgid ""
"The array element specifies the location and size for auxiliary information."
msgstr ""
"この配列要素は補足情報 (auxiliary information) の位置とサイズを指定する。"

#. type: TP
#: build/C/man5/elf.5:772
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr "B<PT_SHLIB>"

#. type: Plain text
#: build/C/man5/elf.5:777
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""
"このセグメント型は予約されているが、意味は指定されていない。 この型の配列要素"
"を保持するプログラムは ABI に準拠しない。"

#. type: TP
#: build/C/man5/elf.5:777
#, no-wrap
msgid "B<PT_PHDR>"
msgstr "B<PT_PHDR>"

#. type: Plain text
#: build/C/man5/elf.5:786
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the "
"program.  This segment type may not occur more than once in a file.  "
"Moreover, it may only occur if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable "
"segment entry."
msgstr ""
"この配列要素は、もし存在しているならば、 ファイルおよびプログラムのメモリイ"
"メージ双方における プログラムヘッダテーブル自身の位置とサイズを指定する。 こ"
"のセグメント型は 1 つのファイルに 2 回以上出現してはならない。 さらに、このセ"
"グメント型が存在してもよいのは、プログラムヘッダテーブルが プログラムのメモリ"
"イメージの一部である場合のみである。 もし存在する場合、これは全てのロード可能"
"セグメントエントリより 前になければならない。"

#. type: TP
#: build/C/man5/elf.5:786
#, no-wrap
msgid "B<PT_LOPROC>"
msgstr "B<PT_LOPROC>"

#. type: Plain text
#: build/C/man5/elf.5:791
msgid ""
"Values greater than or equal to B<PT_HIPROC> are reserved for processor-"
"specific semantics."
msgstr ""
"この値以上で B<PT_HIPROC> 以下の値はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:791
#, no-wrap
msgid "B<PT_HIPROC>"
msgstr "B<PT_HIPROC>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:802
#, fuzzy
#| msgid ""
#| "GNU extension which is used by the Linux kernel to control the state of "
#| "the stack via the flags set in the I<p_flags> member."
msgid ""
"Values less than or equal to B<PT_LOPROC> are reserved for processor-"
"specific semantics.  B<PT_GNU_STACK> GNU extension which is used by the "
"Linux kernel to control the state of the stack via the flags set in the "
"I<p_flags> member."
msgstr ""
"GNU 拡張であり、Linux カーネルが I<p_flags> のメンバーにセットされたフラグ経"
"由でスタックの状態を制御するために使用する。"

#. type: TP
#: build/C/man5/elf.5:803
#, no-wrap
msgid "I<p_offset>"
msgstr "I<p_offset>"

#. type: Plain text
#: build/C/man5/elf.5:807
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""
"このメンバは、セグメントの先頭バイトがある (ファイル先頭からの) オフセットを"
"保持する。"

#. type: TP
#: build/C/man5/elf.5:807
#, no-wrap
msgid "I<p_vaddr>"
msgstr "I<p_vaddr>"

#. type: Plain text
#: build/C/man5/elf.5:811
msgid ""
"This member holds the virtual address at which the first byte of the segment "
"resides in memory."
msgstr ""
"このメンバは、セグメントの先頭バイトがある メモリの仮想アドレスを保持する。"

#. type: TP
#: build/C/man5/elf.5:811
#, no-wrap
msgid "I<p_paddr>"
msgstr "I<p_paddr>"

#. type: Plain text
#: build/C/man5/elf.5:819
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""
"物理アドレスが意味をもつシステムでは、 このメンバはセグメントの物理アドレスと"
"して予約されている。 BSD ではこのメンバは使用されない。0 でなければならない。"

#. type: TP
#: build/C/man5/elf.5:819
#, no-wrap
msgid "I<p_filesz>"
msgstr "I<p_filesz>"

#. type: Plain text
#: build/C/man5/elf.5:823
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""
"このメンバはセグメントのファイルイメージのバイト数を保持する。 これは 0 でも"
"よい。"

#. type: TP
#: build/C/man5/elf.5:823
#, no-wrap
msgid "I<p_memsz>"
msgstr "I<p_memsz>"

#. type: Plain text
#: build/C/man5/elf.5:827
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""
"このメンバはセグメントのメモリイメージのバイト数を保持する。 これは 0 でもよ"
"い。"

#. type: TP
#: build/C/man5/elf.5:827
#, no-wrap
msgid "I<p_flags>"
msgstr "I<p_flags>"

#.  .Bl -tag -width "PF_X" -compact
#. type: Plain text
#: build/C/man5/elf.5:831
msgid "This member holds a bitmask of flags relevant to the segment:"
msgstr "このメンバはセグメントに関連するフラグのビットマップを保持する:"

#. type: TP
#: build/C/man5/elf.5:832
#, no-wrap
msgid "B<PF_X>"
msgstr "B<PF_X>"

#. type: Plain text
#: build/C/man5/elf.5:836
msgid "An executable segment."
msgstr "実行可能セグメント。"

#. type: TP
#: build/C/man5/elf.5:836
#, no-wrap
msgid "B<PF_W>"
msgstr "B<PF_W>"

#. type: Plain text
#: build/C/man5/elf.5:839
msgid "A writable segment."
msgstr "書き込み可能セグメント."

#. type: TP
#: build/C/man5/elf.5:839
#, no-wrap
msgid "B<PF_R>"
msgstr "B<PF_R>"

#. type: Plain text
#: build/C/man5/elf.5:842
msgid "A readable segment."
msgstr "読み込み可能セグメント。"

#. type: Plain text
#: build/C/man5/elf.5:855
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_X>, B<PF_W> and B<PF_R>."
msgstr ""
"テキストセグメントは一般にフラグ B<PF_X> と B<PF_R> を持つ。 データセグメント"
"は一般に B<PF_X>, B<PF_W>, B<PF_R> を持つ。"

#. type: TP
#: build/C/man5/elf.5:855
#, no-wrap
msgid "I<p_align>"
msgstr "I<p_align>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:874
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""
"このメンバは、セグメントがメモリおよびファイルにおいて配置 (align)  される値"
"を保持する。 ロード可能プロセスセグメントは、ページサイズを法として "
"I<p_vaddr> と I<p_offset> と合同でなければならない (訳注:「p_vaddr mod ページ"
"サイズ = p_offset mod ページサイズ」 でなければならない)。。 0 と 1 という値"
"は配置が必要ないことを意味する。 それ以外の場合、 I<p_align> は正で 2 の整数"
"乗でなければならず、 I<p_vaddr> は I<p_align> を法として I<p_offset> と合同で"
"なければならない (訳注:「p_vaddr mod p_align = p_offset mod p_align」でなけれ"
"ばならない)。"

#. type: Plain text
#: build/C/man5/elf.5:891
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the "
"number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""
"ファイルのセクションヘッダテーブルには、 全てのファイルセクションの場所が記述"
"されている。 セクションヘッダテーブルは I<Elf32_Shdr> 構造体または "
"I<Elf64_Shdr> 構造体の配列である。 ELF ヘッダの I<e_shoff> メンバはファイルの"
"先頭から セクションヘッダテーブルへのバイトオフセットである。 I<e_shnum> はセ"
"クションヘッダテーブルに含まれるエントリの数を保持する。 I<e_shentsize> は各"
"エントリのサイズ (バイト単位) を保持する。"

#.  .Bl -tag -width "SHN_LORESERVE"
#. type: Plain text
#: build/C/man5/elf.5:908
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between "
"B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum> and I<e_strndx>; in other cases, each "
"field in the initial entry is set to zero.  An object file does not have "
"sections for these special indices:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:913
msgid ""
"This value marks an undefined, missing, irrelevant or otherwise meaningless "
"section reference."
msgstr "この値は未定義・不明・無関係・無意味なセクション参照の印となる。"

#. type: Plain text
#: build/C/man5/elf.5:933
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""
"この値は対応する参照の絶対値を指定する。 例えば、セクション番号 B<SHN_ABS> に"
"関連して定義されているシンボルは、 絶対値を保持しているので、再配置に影響され"
"ない。"

#. type: Plain text
#: build/C/man5/elf.5:937
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN "
"COMMON or unallocated C external variables."
msgstr ""
"このセクションに関連して定義されているシンボルは、 FORTRAN の COMMON や C の"
"未割り当て外部変数のような共通シンボルである。"

#. type: Plain text
#: build/C/man5/elf.5:948
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""
"この値は予約済みのインデックス領域の上限を指定する。 システムは "
"B<SHN_LORESERVE> と B<SHN_HIRESERVE> を含む範囲を予約する。 セクションヘッダ"
"テーブルは予約されたインデックスに対応するエントリを持たない。"

#. type: Plain text
#: build/C/man5/elf.5:952
msgid "The section header has the following structure:"
msgstr "セクションヘッダは以下の構造体を持つ:"

#. type: Plain text
#: build/C/man5/elf.5:967
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"

#. type: Plain text
#: build/C/man5/elf.5:984
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"

#.  .Bl -tag -width "sh_addralign"
#. type: Plain text
#: build/C/man5/elf.5:989
msgid ""
"No real differences exist between the 32-bit and 64-bit section headers."
msgstr "32 ビットと 64 ビットのセクションヘッダには実際の違いはない。"

#. type: TP
#: build/C/man5/elf.5:989
#, no-wrap
msgid "I<sh_name>"
msgstr "I<sh_name>"

#. type: Plain text
#: build/C/man5/elf.5:995
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a null-"
"terminated string."
msgstr ""
"このメンバはセクション名を定める。 この値はセクションヘッダ文字列テーブルセク"
"ションのインデックスであり、 NULL 文字で終端された文字列の場所を示す。"

#. type: TP
#: build/C/man5/elf.5:995
#, no-wrap
msgid "I<sh_type>"
msgstr "I<sh_type>"

#.  .Bl -tag -width "SHT_PROGBITS"
#. type: Plain text
#: build/C/man5/elf.5:999
msgid "This member categorizes the section's contents and semantics."
msgstr "このメンバはセクションの内容と意味が含まれるカテゴリを示す。"

#. type: TP
#: build/C/man5/elf.5:1000
#, no-wrap
msgid "B<SHT_NULL>"
msgstr "B<SHT_NULL>"

#. type: Plain text
#: build/C/man5/elf.5:1007
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""
"この値はセクションヘッダが不活性であることを示す。 これは関連するセクションを"
"持たない。 このセクションヘッダの他のメンバは、未定義の値を持つ。"

#. type: TP
#: build/C/man5/elf.5:1007
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr "B<SHT_PROGBITS>"

#. type: Plain text
#: build/C/man5/elf.5:1011
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""
"このセクションはプログラムにより定義される情報を保持する。 この情報の形式と意"
"味は、ひとえにプログラムによって決定される。"

#. type: TP
#: build/C/man5/elf.5:1011
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr "B<SHT_SYMTAB>"

#. type: Plain text
#: build/C/man5/elf.5:1024
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""
"このセクションはシンボルテーブルを保持する。 一般には B<SHT_SYMTAB> はリンク"
"編集のためのシンボルを提供するが、 動的リンクにも使われる。 完全なシンボル"
"テーブルとして、動的リンクには不要な 多くのシンボルを保持できる。 オブジェク"
"トファイルも B<SHT_DYNSYM> セクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:1024
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr "B<SHT_STRTAB>"

#. type: Plain text
#: build/C/man5/elf.5:1029
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""
"このセクションは文字列テーブルを保持する。 オブジェクトファイルは複数の文字列"
"テーブルセクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:1029
#, no-wrap
msgid "B<SHT_RELA>"
msgstr "B<SHT_RELA>"

#. type: Plain text
#: build/C/man5/elf.5:1037
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""
"このセクションは明示的な加数 (addend) を持つ再配置エントリを保持する。 再配置"
"エントリの型は、オブジェクトファイルの 32 ビットクラスでは I<Elf32_Rela> であ"
"る。 オブジェクトファイルは複数の再配置セクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:1037
#, no-wrap
msgid "B<SHT_HASH>"
msgstr "B<SHT_HASH>"

#. type: Plain text
#: build/C/man5/elf.5:1044
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""
"このセクションはシンボルハッシュテーブルを保持する。 動的リンクされるオブジェ"
"クトは、 シンボルハッシュテーブルを含んでいなければならない。 オブジェクト"
"ファイルは 1 つのハッシュテーブルのみを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:1044
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr "B<SHT_DYNAMIC>"

#. type: Plain text
#: build/C/man5/elf.5:1049
msgid ""
"This section holds information for dynamic linking.  An object file may have "
"only one dynamic section."
msgstr ""
"このセクションは動的リンクの情報を保持する。 オブジェクトファイルは 1 つの動"
"的セクションのみを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:1049
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr "B<SHT_NOTE>"

#. type: Plain text
#: build/C/man5/elf.5:1052
msgid "This section holds information that marks the file in some way."
msgstr "このセクションはファイルに何らかの印を付ける情報を保持する。"

#. type: TP
#: build/C/man5/elf.5:1052
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr "B<SHT_NOBITS>"

#. type: Plain text
#: build/C/man5/elf.5:1060
msgid ""
"A section of this type occupies no space in the file but otherwise resembles "
"B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset> "
"member contains the conceptual file offset."
msgstr ""
"このタイプのセクションはファイルの領域を使わないという以外は、 "
"B<SHT_PROGBITS> と似ている。 このセクションは 1 バイトも含まないが、 "
"I<sh_offset> メンバは概念的なファイルオフセットを持つ。"

#. type: TP
#: build/C/man5/elf.5:1060
#, no-wrap
msgid "B<SHT_REL>"
msgstr "B<SHT_REL>"

#. type: Plain text
#: build/C/man5/elf.5:1068
msgid ""
"This section holds relocation offsets without explicit addends, such as type "
"I<Elf32_Rel> for the 32-bit class of object files.  An object file may have "
"multiple relocation sections."
msgstr ""
"このセクションは明示的な加数を持たない再配置オフセットを保持する。 再配置オフ"
"セットの型は、オブジェクトファイルの 32 ビットクラスでは I<Elf32_Rel> であ"
"る。 オブジェクトファイルは複数の再配置セクションを持つことができる。"

#. type: TP
#: build/C/man5/elf.5:1068
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr "B<SHT_SHLIB>"

#. type: Plain text
#: build/C/man5/elf.5:1071
msgid "This section is reserved but has unspecified semantics."
msgstr "このセクションは予約されているが、意味は指定されていない。"

#. type: TP
#: build/C/man5/elf.5:1071
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr "B<SHT_DYNSYM>"

#. type: Plain text
#: build/C/man5/elf.5:1078
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file "
"can also contain a B<SHT_SYMTAB> section."
msgstr ""
"このセクションは動的リンクシンボルの最小セットを保持する。 オブジェクトファイ"
"ルは B<SHT_SYMTAB> セクションも含むことができる。"

#. type: TP
#: build/C/man5/elf.5:1078
#, no-wrap
msgid "B<SHT_LOPROC>"
msgstr "B<SHT_LOPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1083
msgid ""
"This value up to and including B<SHT_HIPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"この値以上で B<SHT_HIPROC> 以下の範囲はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1083
#, no-wrap
msgid "B<SHT_HIPROC>"
msgstr "B<SHT_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1088
msgid ""
"This value down to and including B<SHT_LOPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"この値以下で B<SHT_LOPROC> 以上の範囲はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1088
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr "B<SHT_LOUSER>"

#. type: Plain text
#: build/C/man5/elf.5:1092
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""
"この値はアプリケーションプログラムのために予約される インデックス範囲の下限を"
"指定する。"

#. type: TP
#: build/C/man5/elf.5:1092
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr "B<SHT_HIUSER>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1103
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER> "
"may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""
"この値はアプリケーションプログラムのために予約される インデックス範囲の上限を"
"指定する。 B<SHT_LOUSER> から B<SHT_HIUSER> の間のセクションタイプは、 現在ま"
"たは将来のシステム定義セクションタイプと衝突することなく、 アプリケーションで"
"使用することができる。"

#. type: TP
#: build/C/man5/elf.5:1104
#, no-wrap
msgid "I<sh_flags>"
msgstr "I<sh_flags>"

#.  .Bl -tag -width "SHF_EXECINSTR" -compact
#. type: Plain text
#: build/C/man5/elf.5:1117
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a "
"flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes "
"are set to zero."
msgstr ""
"様々な属性を記述するための 1 ビットのフラグをサポートするセクション。 フラグ"
"ビットが I<sh_flags> に設定された場合、そのセクションについての属性は \"オン"
"\" になる。 それ以外の場合、属性が \"オフ\" であるか属性が適用されない。 未定"
"義の属性は 0 に設定される。"

#. type: TP
#: build/C/man5/elf.5:1118
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr "B<SHF_WRITE>"

#. type: Plain text
#: build/C/man5/elf.5:1122
msgid ""
"This section contains data that should be writable during process execution."
msgstr "このセクションはプロセス実行中に書き込み可能なデータを含む。"

#. type: TP
#: build/C/man5/elf.5:1122
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr "B<SHF_ALLOC>"

#. type: Plain text
#: build/C/man5/elf.5:1129
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""
"このセクションはプロセス実行中にメモリを使用する。 制御セクションの中には、オ"
"ブジェクトファイルのメモリイメージには 存在しないものもある。 そうしたセク"
"ションの場合、この属性はオフである。"

#. type: TP
#: build/C/man5/elf.5:1129
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr "B<SHF_EXECINSTR>"

#. type: Plain text
#: build/C/man5/elf.5:1132
msgid "This section contains executable machine instructions."
msgstr "このセクションは実行可能なマシン命令を含む。"

#. type: TP
#: build/C/man5/elf.5:1132
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr "B<SHF_MASKPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1136
msgid ""
"All bits included in this mask are reserved for processor-specific semantics."
msgstr ""
"このマスクに含まれる全てのビットはプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1138
#, no-wrap
msgid "I<sh_addr>"
msgstr "I<sh_addr>"

#. type: Plain text
#: build/C/man5/elf.5:1143
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the "
"member contains zero."
msgstr ""
"このセクションがプロセスのメモリイメージにある場合、 このメンバはセクションの"
"最初のバイトが存在するアドレスを保持する。 それ以外の場合、このメンバは 0 で"
"ある。"

#. type: TP
#: build/C/man5/elf.5:1143
#, no-wrap
msgid "I<sh_offset>"
msgstr "I<sh_offset>"

#. type: Plain text
#: build/C/man5/elf.5:1152
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no "
"space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""
"このメンバの値は、ファイルの先頭からセクションの最初のバイトへの バイトオフ"
"セットを保持する。 セクションタイプ B<SHT_NOBITS> はファイルの領域を全く使用"
"せず、このタイプの I<sh_offset> メンバはファイルの概念的な位置を示す。"

#. type: TP
#: build/C/man5/elf.5:1152
#, no-wrap
msgid "I<sh_size>"
msgstr "I<sh_size>"

#. type: Plain text
#: build/C/man5/elf.5:1164
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section "
"of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""
"このメンバはセクションのサイズ (バイト単位) を保持する。 セクションタイプが "
"B<SHT_NOBITS> でない限り、そのセクションはファイル中の I<sh_size> バイトを使"
"用する。 タイプが B<SHT_NOBITS> のセクションはサイズが 0 でないが、ファイルの"
"領域を使用しない。"

#. type: TP
#: build/C/man5/elf.5:1164
#, no-wrap
msgid "I<sh_link>"
msgstr "I<sh_link>"

#. type: Plain text
#: build/C/man5/elf.5:1168
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""
"このメンバは、セクションヘッダテーブルインデックスリンクを保持する。 この解釈"
"はセクションタイプに依存する。"

#. type: TP
#: build/C/man5/elf.5:1168
#, no-wrap
msgid "I<sh_info>"
msgstr "I<sh_info>"

#. type: Plain text
#: build/C/man5/elf.5:1172
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""
"このメンバは追加情報を保持する。 この解釈はセクションタイプに依存する。"

#. type: TP
#: build/C/man5/elf.5:1172
#, no-wrap
msgid "I<sh_addralign>"
msgstr "I<sh_addralign>"

#. type: Plain text
#: build/C/man5/elf.5:1185
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo "
"the value of I<sh_addralign>.  Only zero and positive integral powers of two "
"are allowed.  Values of zero or one mean the section has no alignment "
"constraints."
msgstr ""
"アドレス配置に制約があるセクションもある。 セクションが倍長語 (doubleword) を"
"保持する場合、 システムは全てのセクションについて倍長語の配置を保証しなければ"
"ならない。 つまり、 I<sh_addr> の値は I<sh_addralign> の値を法として 0 と合同"
"でなければならない (訳注:「sh_addr mod sh_addralign = 0 でなければならな"
"い)。 2 の 0 乗と正の整数乗のみが許可される。 0 または 1 はセクションの配置に"
"制約がないことを意味する。"

#. type: TP
#: build/C/man5/elf.5:1185
#, no-wrap
msgid "I<sh_entsize>"
msgstr "I<sh_entsize>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1192
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size "
"entries."
msgstr ""
"シンボルテーブルのような固定サイズエントリのテーブルを保持する セクションもあ"
"る。 このようなセクションでは、 このメンバは各エントリのサイズ (バイト単位) "
"を表す。 このメンバが 0 の場合、 そのセクションは固定サイズエントリのテーブル"
"を保持しない。"

#.  .Bl -tag -width ".shstrtab"
#. type: Plain text
#: build/C/man5/elf.5:1195
msgid "Various sections hold program and control information:"
msgstr "さまざまなセクションにプログラム情報・制御情報が保持される:"

#. type: TP
#: build/C/man5/elf.5:1195
#, no-wrap
msgid "I<.bss>"
msgstr "I<.bss>"

#. type: Plain text
#: build/C/man5/elf.5:1207
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The "
"attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションはプログラムのメモリイメージに配置される 非初期化データを保持す"
"る。 定義上、システムはプログラムの実行開始時に、データを 0 で初期化する。 こ"
"のセクションのタイプは B<SHT_NOBITS> である。 属性タイプは B<SHF_ALLOC> と "
"B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1207
#, no-wrap
msgid "I<.comment>"
msgstr "I<.comment>"

#. type: Plain text
#: build/C/man5/elf.5:1213
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"このセクションはバージョン制御情報を保持する。 このセクションのタイプは "
"B<SHT_PROGBITS> である。 属性タイプは使用されない。"

#. type: TP
#: build/C/man5/elf.5:1213
#, no-wrap
msgid "I<.ctors>"
msgstr "I<.ctors>"

#. type: Plain text
#: build/C/man5/elf.5:1222
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションは C++ コンストラクタ関数への初期化されたポインタを保持する。 "
"このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは B<SHF_ALLOC> "
"と B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1222
#, no-wrap
msgid "I<.data>"
msgstr "I<.data>"

#. type: Plain text
#: build/C/man5/elf.5:1232 build/C/man5/elf.5:1242
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションはプログラムのメモリイメージに配置される 初期化済みデータを保持"
"する。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは "
"B<SHF_ALLOC> と B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1232
#, no-wrap
msgid "I<.data1>"
msgstr "I<.data1>"

#. type: TP
#: build/C/man5/elf.5:1242
#, no-wrap
msgid "I<.debug>"
msgstr "I<.debug>"

#. type: Plain text
#: build/C/man5/elf.5:1250
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""
"このセクションはシンボリックデバッグ用の情報を保持する。 その内容は指定されて"
"いない。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは使用さ"
"れない。"

#. type: TP
#: build/C/man5/elf.5:1250
#, no-wrap
msgid "I<.dtors>"
msgstr "I<.dtors>"

#. type: Plain text
#: build/C/man5/elf.5:1259
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""
"このセクションは C++ デストラクタ関数への初期化されたポインタを保持する。 こ"
"のセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは B<SHF_ALLOC> と "
"B<SHF_WRITE> である。"

#. type: TP
#: build/C/man5/elf.5:1259
#, no-wrap
msgid "I<.dynamic>"
msgstr "I<.dynamic>"

#. type: Plain text
#: build/C/man5/elf.5:1272
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""
"このセクションは動的リンク情報を保持する。 このセクションの属性は "
"B<SHF_ALLOC> ビットを含む。 B<SHF_WRITE> ビットが設定されるか否かはプロセッサ"
"による。 このセクションのタイプは B<SHT_DYNAMIC> である。 上記の属性を参照す"
"ること。"

#. type: TP
#: build/C/man5/elf.5:1272
#, no-wrap
msgid "I<.dynstr>"
msgstr "I<.dynstr>"

#. type: Plain text
#: build/C/man5/elf.5:1280
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This "
"section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""
"このセクションは動的リンクに必要な文字列を保持する。 最も一般的には、この文字"
"列はシンボルテーブルエントリと 関連づけられた名前を表す。 このセクションのタ"
"イプは B<SHT_STRTAB> である。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1280
#, no-wrap
msgid "I<.dynsym>"
msgstr "I<.dynsym>"

#. type: Plain text
#: build/C/man5/elf.5:1287
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションは動的リンクシンボルテーブルを保持する。 このセクションのタイプ"
"は B<SHT_DYNSYM> である。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1287
#, no-wrap
msgid "I<.fini>"
msgstr "I<.fini>"

#. type: Plain text
#: build/C/man5/elf.5:1299
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>.  "
"The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"このセクションはプロセス終了コードに置かれる実行可能命令を保持する。 プロセス"
"が正常に終了した場合、システムはこのセクションにある コードを配置して実行す"
"る。 このセクションのタイプは B<SHT_PROGBITS> である。 使用される属性タイプ"
"は B<SHF_ALLOC> と B<SHF_EXECINSTR> である。"

#. type: TP
#: build/C/man5/elf.5:1299
#, no-wrap
msgid "I<.gnu.version>"
msgstr "I<.gnu.version>"

#. type: Plain text
#: build/C/man5/elf.5:1308
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"このセクションはバージョン・シンボル・テーブルを保持する。 その内容は "
"I<ElfN_Half> 要素の配列である。 このセクションのタイプは B<SHT_GNU_versym> で"
"ある。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1308
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr "I<.gnu.version_d>"

#. type: Plain text
#: build/C/man5/elf.5:1317
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef> "
"structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""
"このセクションはバージョンシンボルの定義を保持する。 その内容は "
"I<ElfN_Verdef> 構造体のテーブルである。 このセクションのタイプは "
"B<SHT_GNU_verdef> である。 使用される属性タイプは B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1317
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr "I<.gnu.version_r>"

#. type: Plain text
#: build/C/man5/elf.5:1327
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The "
"attribute type used is B<SHF_ALLOC>."
msgstr ""
"このセクションはバージョンシンボルが必要とする要素を保持する。 その内容は "
"I<ElfN_Verneed> 構造体のテーブルである。 このセクションのタイプは "
"B<SHT_GNU_versym> である。 使用される属性タイプは B<shf_alloc> である。"

#. type: TP
#: build/C/man5/elf.5:1327
#, no-wrap
msgid "I<.got>"
msgstr "I<.got>"

#. type: Plain text
#: build/C/man5/elf.5:1333
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor specific."
msgstr ""
"このセクションはグローバルオフセットテーブルを保持する。 このセクションのタイ"
"プは B<SHT_PROGBITS> である。 属性はプロセッサ毎に異なる。"

#. type: TP
#: build/C/man5/elf.5:1333
#, no-wrap
msgid "I<.hash>"
msgstr "I<.hash>"

#. type: Plain text
#: build/C/man5/elf.5:1340
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションはシンボルハッシュテーブルを保持する。 セクションのタイプは "
"B<SHT_HASH> である。 使用される属性は B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1340
#, no-wrap
msgid "I<.init>"
msgstr "I<.init>"

#. type: Plain text
#: build/C/man5/elf.5:1352
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"このセクションはプロセス初期化コードに配置される実行可能命令を保持する。 プロ"
"グラムが実行を開始すると、 システムはメインプログラムエントリポイントを呼び出"
"す前に、 このセクションにあるコードを配置して実行する。 このセクションはのタ"
"イプは B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> と "
"B<SHF_EXECINSTR> である。"

#. type: TP
#: build/C/man5/elf.5:1352
#, no-wrap
msgid "I<.interp>"
msgstr "I<.interp>"

#. type: Plain text
#: build/C/man5/elf.5:1363
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a "
"loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""
"このセクションはプログラムインタプリタのパス名を保持する。 ファイルにこのセク"
"ションを含むロード可能セグメントがある場合、 そのセクションの属性には "
"B<SHF_ALLOC> ビットが含まれる。 それ以外の場合このビットはオフになる。 このセ"
"クションのタイプは B<SHT_PROGBITS> である。"

#. type: TP
#: build/C/man5/elf.5:1363
#, no-wrap
msgid "I<.line>"
msgstr "I<.line>"

#. type: Plain text
#: build/C/man5/elf.5:1371
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""
"このセクションはシンボリックデバッグのための行番号情報を保持する。 ここにはプ"
"ログラムソースコードとマシンコードの対応関係が記述される。 内容は指定されてい"
"ない。 このセクションのタイプは B<SHT_PROGBITS> である。 属性タイプは使用され"
"ない。"

#. type: TP
#: build/C/man5/elf.5:1371
#, no-wrap
msgid "I<.note>"
msgstr "I<.note>"

#. type: Plain text
#: build/C/man5/elf.5:1384
#, fuzzy
#| msgid ""
#| "This section holds information in the \"Note Section\" format described "
#| "below.  This section is of type B<SHT_NOTE>.  No attribute types are "
#| "used.  OpenBSD native executables usually contain a I<.note.openbsd."
#| "ident> section to identify themselves, for the kernel to bypass any "
#| "compatibility ELF binary emulation tests when loading the file."
msgid ""
"This section holds information in the \"Note Section\" format.  This section "
"is of type B<SHT_NOTE>.  No attribute types are used.  OpenBSD native "
"executables usually contain a I<.note.openbsd.ident> section to identify "
"themselves, for the kernel to bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""
"このセクションは以下に記述されている \"Note Section\" 形式で情報を保持する。 "
"このセクションのタイプは B<SHT_NOTE> である。 属性タイプは使用されない。 通"
"常 OpenBSD ネイティブ実行可能ファイルは自身を識別するために I<.note.openbsd."
"ident> セクションを持つ。 これによりカーネルは、ファイルをロードする際に 互"
"換 ELF バイナリエミュレーションテストを回避できる。"

#. type: TP
#: build/C/man5/elf.5:1384
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr "I<.note.GNU-stack>"

#. type: Plain text
#: build/C/man5/elf.5:1393
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""
"このセクションは Linux のオブジェクトファイルで スタック属性を宣言するのに使"
"用される。 セクションのタイプは B<SHT_PROGBITS> である。使用される属性は "
"B<SHF_EXECINSTR> だけである。この属性は GNU リンカに対して オブジェクトファイ"
"ルが実行可能なスタック (executable stack) を必要とする 示すものである。"

#. type: TP
#: build/C/man5/elf.5:1393
#, no-wrap
msgid "I<.plt>"
msgstr "I<.plt>"

#. type: Plain text
#: build/C/man5/elf.5:1399
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor specific."
msgstr ""
"このセクションは手続き (procedure) リンクテーブルを保持する。 このセクション"
"のタイプは B<SHT_PROGBITS> である。 属性はプロセッサ毎に異なる。"

#. type: TP
#: build/C/man5/elf.5:1399
#, no-wrap
msgid "I<.relNAME>"
msgstr "I<.relNAME>"

#. type: Plain text
#: build/C/man5/elf.5:1418
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""
"このセクションは以下に記述される再配置情報を保持する。 ファイルが再配置を含む"
"ロード可能セグメントを持っている場合、 このセクションの属性は B<SHF_ALLOC> "
"ビットを含む。 それ以外の場合、そのビットはオフである。 慣例として、 \"NAME"
"\" は再配置が適用されるセクションが指定される。 よって B<.text> についての再"
"配置セクションは、通常は B<.rel.text> という名前を持つ。 このセクションのタイ"
"プは B<SHT_REL> である。"

#. type: TP
#: build/C/man5/elf.5:1418
#, no-wrap
msgid "I<.relaNAME>"
msgstr "I<.relaNAME>"

#. type: Plain text
#: build/C/man5/elf.5:1437
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""
"このセクションは以下に記述される再配置情報を保持する。 ファイルが再配置を含む"
"ロード可能セグメントを持っている場合、 このセクションの属性は B<SHF_ALLOC> "
"ビットを含む。 それ以外の場合、そのビットはオフである。 慣例として、 \"NAME"
"\" は再配置が適用されるセクションが指定される。 よって B<.text> についての再"
"配置セクションは、通常は B<.rela.text> という名前を持つ。 このセクションのタ"
"イプは B<SHT_RELA> である。"

#. type: TP
#: build/C/man5/elf.5:1437
#, no-wrap
msgid "I<.rodata>"
msgstr "I<.rodata>"

#. type: Plain text
#: build/C/man5/elf.5:1445 build/C/man5/elf.5:1453
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""
"このセクションはリードオンリーのデータを保持する。 このデータはプロセスイメー"
"ジにおける書き込み不可能なセグメントに置かれる。 このセクションのタイプは "
"B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> である。"

#. type: TP
#: build/C/man5/elf.5:1445
#, no-wrap
msgid "I<.rodata1>"
msgstr "I<.rodata1>"

#. type: TP
#: build/C/man5/elf.5:1453
#, no-wrap
msgid "I<.shstrtab>"
msgstr "I<.shstrtab>"

#. type: Plain text
#: build/C/man5/elf.5:1459
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""
"このセクションはセクション名を保持する。 このセクションのタイプは "
"B<SHT_STRTAB> である。 属性タイプは使用されない。"

#. type: TP
#: build/C/man5/elf.5:1459
#, no-wrap
msgid "I<.strtab>"
msgstr "I<.strtab>"

#. type: Plain text
#: build/C/man5/elf.5:1471
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise the bit will be off.  This section "
"is of type B<SHT_STRTAB>."
msgstr ""
"このセクションは文字列を保持する。 最も一般的なのは、シンボルテーブルエントリ"
"に関連づけられた 名前を表す文字列である。 ファイルがシンボル文字列テーブルを"
"含むロード可能セグメントを持つ場合、 セクションの属性は B<SHF_ALLOC> ビットを"
"含む。 それ以外の場合、そのビットはオフである。 このセクションのタイプは "
"B<SHT_STRTAB> である。"

#. type: TP
#: build/C/man5/elf.5:1471
#, no-wrap
msgid "I<.symtab>"
msgstr "I<.symtab>"

#. type: Plain text
#: build/C/man5/elf.5:1482
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""
"このセクションはシンボルテーブルを保持する。 ファイルがシンボルテーブルを含む"
"ロード可能セグメントを持つ場合、 セクションの属性は B<SHF_ALLOC> ビットを含"
"む。 それ以外の場合、ビットはオフである。 このセクションのタイプは "
"B<SHT_SYMTAB> である。"

#. type: TP
#: build/C/man5/elf.5:1482
#, no-wrap
msgid "I<.text>"
msgstr "I<.text>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1494
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""
"このセクションはプログラムの \"テキスト\" または実行可能命令を保持する。 セク"
"ションのタイプは B<SHT_PROGBITS> である。 使用される属性は B<SHF_ALLOC> と "
"B<SHF_EXECINSTR> である。"

#. type: Plain text
#: build/C/man5/elf.5:1505
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""
"文字列テーブルセクションは NULL 文字で終端されたキャラクタ配列 (通常文字列と"
"呼ばれるもの) を保持する。 オブジェクトファイルはこれらの文字列を シンボル名"
"とセクション名を表すために使う。 文字列は、文字列テーブルセクションへのイン"
"デックスとして参照される。 インデックス 0 の最初のバイトは、NULL バイト "
"(\\(aq\\e0\\(aq) を 保持すると定義されている。 同様に文字列テーブルの最後のバ"
"イトも NULL 文字を保持すると定義されている。 これは全ての文字列が NULL バイト"
"で終端されていることを保証するためである。"

#. type: Plain text
#: build/C/man5/elf.5:1510
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""
"オブジェクトファイルのシンボルテーブルは、 プログラムのシンボル定義と参照を配"
"置または再配置するのに 必要な情報を保持する。"

#. type: Plain text
#: build/C/man5/elf.5:1521
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"

#. type: Plain text
#: build/C/man5/elf.5:1534
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"

#.  .Bl -tag -width "st_value"
#. type: Plain text
#: build/C/man5/elf.5:1540
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""
"32 ビット版と 64 ビット版は同じメンバを持ち、単に順番が異なるだけである。"

#. type: TP
#: build/C/man5/elf.5:1540
#, no-wrap
msgid "I<st_name>"
msgstr "I<st_name>"

#. type: Plain text
#: build/C/man5/elf.5:1548
msgid ""
"This member holds an index into the object file's symbol string table, which "
"holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol table has no name."
msgstr ""
"このメンバはオブジェクトファイルのシンボル文字列テーブルの インデックスを保持"
"する。 シンボル文字列テーブルはシンボル名の文字表現を保持する。 この値が 0 で"
"ない場合、シンボル名を得るための文字テーブルインデックスを表す。 それ以外の場"
"合、シンボルテーブルは名前を持たない。"

#. type: TP
#: build/C/man5/elf.5:1548
#, no-wrap
msgid "I<st_value>"
msgstr "I<st_value>"

#. type: Plain text
#: build/C/man5/elf.5:1551
msgid "This member gives the value of the associated symbol."
msgstr "このメンバは関連づけられたシンボルの値を表す。"

#. type: TP
#: build/C/man5/elf.5:1551
#, no-wrap
msgid "I<st_size>"
msgstr "I<st_size>"

#. type: Plain text
#: build/C/man5/elf.5:1556
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""
"多くのシンボルにはそれに関連づけられたサイズがある。 シンボルがサイズを持たな"
"い場合、またはサイズが不明な場合、 このメンバは 0 である。"

#. type: TP
#: build/C/man5/elf.5:1556
#, no-wrap
msgid "I<st_info>"
msgstr "I<st_info>"

#.  .Bl -tag -width "STT_SECTION"
#. type: Plain text
#: build/C/man5/elf.5:1560
msgid "This member specifies the symbol's type and binding attributes:"
msgstr "このメンバはシンボルのタイプとバインディング (binding) 属性を指定する:"

#. type: TP
#: build/C/man5/elf.5:1561
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr "B<STT_NOTYPE>"

#. type: Plain text
#: build/C/man5/elf.5:1564
msgid "The symbol's type is not defined."
msgstr "シンボルのタイプが定義されていない。"

#. type: TP
#: build/C/man5/elf.5:1564
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr "B<STT_OBJECT>"

#. type: Plain text
#: build/C/man5/elf.5:1567
msgid "The symbol is associated with a data object."
msgstr "シンボルはデータオブジェクトに関連づけられている。"

#. type: TP
#: build/C/man5/elf.5:1567
#, no-wrap
msgid "B<STT_FUNC>"
msgstr "B<STT_FUNC>"

#. type: Plain text
#: build/C/man5/elf.5:1570
msgid "The symbol is associated with a function or other executable code."
msgstr "シンボルは関数またはその他の実行コードに関連づけられている。"

#. type: TP
#: build/C/man5/elf.5:1570
#, no-wrap
msgid "B<STT_SECTION>"
msgstr "B<STT_SECTION>"

#. type: Plain text
#: build/C/man5/elf.5:1577
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""
"シンボルはセクションに関連づけられている。 このタイプのシンボルテーブルエント"
"リは、 主として再配置のために存在し、通常は B<STB_LOCAL> バインディングを持"
"つ。"

#. type: TP
#: build/C/man5/elf.5:1577
#, no-wrap
msgid "B<STT_FILE>"
msgstr "B<STT_FILE>"

#. type: Plain text
#: build/C/man5/elf.5:1588
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""
"慣例として、シンボルの名前は オブジェクトファイルに関連づけられたソースファイ"
"ルの名前を指定する。 ファイルシンボルは B<STB_LOCAL> バインディングを持ち、そ"
"のセクションインデックスは B<SHN_ABS> である。 ファイルシンボルは、ファイルに"
"他の B<STB_LOCAL> シンボルがある場合は、それよりも先に来る。"

#. type: TP
#: build/C/man5/elf.5:1588
#, no-wrap
msgid "B<STT_LOPROC>"
msgstr "B<STT_LOPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1593
msgid ""
"This value up to and including B<STT_HIPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"この値以上で B<STT_HIPROC> 以下の範囲はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1593
#, no-wrap
msgid "B<STT_HIPROC>"
msgstr "B<STT_HIPROC>"

#.  .El
#.  .Bl -tag -width "STB_GLOBAL"
#. type: Plain text
#: build/C/man5/elf.5:1600
msgid ""
"This value down to and including B<STT_LOPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"この値以下で B<STT_LOPROC> 以上の範囲はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1600
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr "B<STB_LOCAL>"

#. type: Plain text
#: build/C/man5/elf.5:1606
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""
"局所的シンボルはその定義を含むオブジェクトファイルの外からは見えない。 同じ名"
"前の局所的シンボルは、お互いに影響を受けることなく、 複数のファイルに存在でき"
"る。"

#. type: TP
#: build/C/man5/elf.5:1606
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr "B<STB_GLOBAL>"

#. type: Plain text
#: build/C/man5/elf.5:1612
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""
"大域的シンボルは結びつけられている全てのオブジェクトファイルから見える。 1 つ"
"のファイルで大域的シンボルが定義されていたら、 他のファイルでは同じシンボルへ"
"の参照は未定義でなければならない。"

#. type: TP
#: build/C/man5/elf.5:1612
#, no-wrap
msgid "B<STB_WEAK>"
msgstr "B<STB_WEAK>"

#. type: Plain text
#: build/C/man5/elf.5:1616
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr "弱シンボルは大域的シンボルに似ているが、その定義は優先度が低い。"

#. type: TP
#: build/C/man5/elf.5:1616
#, no-wrap
msgid "B<STB_LOPROC>"
msgstr "B<STB_LOPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1621
msgid ""
"This value up to and including B<STB_HIPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"この値以上で B<STB_HIPROC> 以下の範囲はプロセッサ固有の意味に予約されている。"

#. type: TP
#: build/C/man5/elf.5:1621
#, no-wrap
msgid "B<STB_HIPROC>"
msgstr "B<STB_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1626
msgid ""
"This value down to and including B<STB_LOPROC> is reserved for processor-"
"specific semantics."
msgstr ""
"この値以下で B<STB_LOPROC> 以上の範囲はプロセッサ固有の意味に予約されている。"

#. type: Plain text
#: build/C/man5/elf.5:1628
msgid "There are macros for packing and unpacking the binding and type fields:"
msgstr ""
"バインディングとタイプフィールドを パックしたりアンパックしたりするマクロがあ"
"る:"

#. type: Plain text
#: build/C/man5/elf.5:1635
msgid ""
"B<ELF32_ST_BIND>(info)  or B<ELF64_ST_BIND>(info)  extract a binding from an "
"I<st_info> value."
msgstr ""
"B<ELF32_ST_BIND>(info)  または B<ELF64_ST_BIND>(info)  I<st_info> の値からバ"
"インディングを取り出す。"

#. type: Plain text
#: build/C/man5/elf.5:1639
msgid "B<ELF32_ST_TYPE>(info)  or B<ELF64_ST_TYPE>(info)"
msgstr "B<ELF32_ST_TYPE>(info)  または B<ELF64_ST_TYPE>(info)"

#. type: Plain text
#: build/C/man5/elf.5:1643
msgid "extract a type from an I<st_info> value."
msgstr "I<st_info> の値からタイプを取り出す。"

#. type: Plain text
#: build/C/man5/elf.5:1647
msgid "B<ELF32_ST_INFO>(bind, type)  or B<ELF64_ST_INFO>(bind, type)"
msgstr "B<ELF32_ST_INFO>(bind, type)  または B<ELF64_ST_INFO>(bind, type)"

#. type: Plain text
#: build/C/man5/elf.5:1651
msgid "convert a binding and a type into an I<st_info> value."
msgstr "バインディングとタイプを I<st_info> の値に変換する。"

#. type: TP
#: build/C/man5/elf.5:1653
#, no-wrap
msgid "I<st_other>"
msgstr "I<st_other>"

#.  .Bl -tag -width "STV_PROTECTED"
#. type: Plain text
#: build/C/man5/elf.5:1657
msgid "This member defines the symbol visibility."
msgstr "このメンバはシンボルの visibility (見える範囲) を規定する。"

#. type: TP
#: build/C/man5/elf.5:1658
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr "B<STV_DEFAULT>"

#. type: Plain text
#: build/C/man5/elf.5:1662
msgid "Default symbol visibility rules."
msgstr "デフォルトのシンボル visibility ルール。"

#. type: TP
#: build/C/man5/elf.5:1662
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr "B<STV_INTERNAL>"

#. type: Plain text
#: build/C/man5/elf.5:1665
msgid "Processor-specific hidden class."
msgstr "プロセッサ固有の隠しクラス。"

#. type: TP
#: build/C/man5/elf.5:1665
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr "B<STV_HIDDEN>"

#. type: Plain text
#: build/C/man5/elf.5:1668
msgid "Symbol is unavailable in other modules."
msgstr "シンボルは他のモジュールからは利用できない。"

#. type: TP
#: build/C/man5/elf.5:1668
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr "B<STV_PROTECTED>"

#. type: Plain text
#: build/C/man5/elf.5:1671
msgid "Not preemptible, not exported."
msgstr "横取りできず (not preemptible)、公開されない。"

#. type: Plain text
#: build/C/man5/elf.5:1674
msgid "There are macros for extracting the visibility type:"
msgstr "visibility 種別を抽出するためのマクロがある。"

#. type: Plain text
#: build/C/man5/elf.5:1678
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr "B<ELF32_ST_VISIBILITY>(other)  または B<ELF64_ST_VISIBILITY>(other)"

#. type: TP
#: build/C/man5/elf.5:1680
#, no-wrap
msgid "I<st_shndx>"
msgstr "I<st_shndx>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1688
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""
"各シンボルテーブルエントリは、いくつかのセクションに関連して \"定義されている"
"\"。 このメンバは関連するセクションヘッダテーブルインデックスを保持する。"

#. type: Plain text
#: build/C/man5/elf.5:1696
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""
"再配置はシンボル参照とシンボル定義を結合するプロセスである。 再配置可能ファイ"
"ルはセクションの内容をどのように修正するかに関する 情報を持たなければならな"
"い。 これにより、実行可能ファイルと共有オブジェクトファイルは プロセスのプロ"
"グラムイメージについての正しい情報を持つことができる。 再配置エントリは以下の"
"ようなデータである。"

#. type: Plain text
#: build/C/man5/elf.5:1698
msgid "Relocation structures that do not need an addend:"
msgstr "加数を必要としない再配置構造体。"

#. type: Plain text
#: build/C/man5/elf.5:1705
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"

#. type: Plain text
#: build/C/man5/elf.5:1714
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"

#. type: Plain text
#: build/C/man5/elf.5:1718
msgid "Relocation structures that need an addend:"
msgstr "加数を必要とする再配置構造体。"

#. type: Plain text
#: build/C/man5/elf.5:1726
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"

#. type: Plain text
#: build/C/man5/elf.5:1736
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"

#. type: TP
#: build/C/man5/elf.5:1739
#, no-wrap
msgid "I<r_offset>"
msgstr "I<r_offset>"

#. type: Plain text
#: build/C/man5/elf.5:1747
msgid ""
"This member gives the location at which to apply the relocation action.  For "
"a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""
"このメンバは再配置動作が適用される位置を与える。 再配置可能ファイルの場合、こ"
"の値はセクションの先頭から 再配置で影響を受ける格納単位 (storage unit) までの"
"バイトオフセットである。 実行可能ファイルまたは共有オブジェクトの場合、 この"
"値は再配置で影響を受ける格納単位の仮想アドレスである。"

#. type: TP
#: build/C/man5/elf.5:1747
#, no-wrap
msgid "I<r_info>"
msgstr "I<r_info>"

#. type: Plain text
#: build/C/man5/elf.5:1762
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying B<ELF_"
"[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""
"このメンバは、再配置が行われなければならないシンボルテーブルインデックスと、 "
"適用される再配置のタイプの両方を与える。 再配置タイプはプロセッサ毎に異な"
"る。 テキストが再配置エントリの再配置タイプ またはシンボルテーブルインデック"
"スを参照している場合、 それぞれエントリの I<r_info> メンバに対して、それぞれ "
"B<ELF_[32|64]_R_TYPE> と B<ELF[32|64]_R_SYM> を適用した結果を意味する。"

#. type: TP
#: build/C/man5/elf.5:1762
#, no-wrap
msgid "I<r_addend>"
msgstr "I<r_addend>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1767
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""
"このメンバは定数の加数を指定する。 この加数は再配置可能フィールドに格納される"
"値を計算するために使われる。"

#. type: Plain text
#: build/C/man5/elf.5:1772
msgid ""
"The .dynamic section contains a series of structures that hold relevant "
"dynamic linking information.  The d_tag member controls the interpretation "
"of d_un."
msgstr ""
"\\&.dynamic セクションは、関連する動的リンク情報を保持している 一連の構造体を"
"保持する。 d_tag メンバは d_un の解釈を制御する。"

#. type: Plain text
#: build/C/man5/elf.5:1783
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"

#. type: Plain text
#: build/C/man5/elf.5:1796
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"

#. type: TP
#: build/C/man5/elf.5:1799
#, no-wrap
msgid "I<d_tag>"
msgstr "I<d_tag>"

#.  .Bl -tag -width "DT_SYMBOLIC"
#. type: Plain text
#: build/C/man5/elf.5:1803
msgid "This member may have any of the following values:"
msgstr "このメンバは以下の値を持つことができる:"

#. type: TP
#: build/C/man5/elf.5:1804
#, no-wrap
msgid "B<DT_NULL>"
msgstr "B<DT_NULL>"

#. type: Plain text
#: build/C/man5/elf.5:1807
msgid "Marks end of dynamic section"
msgstr "動的セクションの終りのマーク"

#. type: TP
#: build/C/man5/elf.5:1807
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr "B<DT_NEEDED>"

#. type: Plain text
#: build/C/man5/elf.5:1810
msgid "String table offset to name of a needed library"
msgstr "必要なライブラリの名前への文字列テーブルオフセット"

#. type: TP
#: build/C/man5/elf.5:1810
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr "B<DT_PLTRELSZ>"

#. type: Plain text
#: build/C/man5/elf.5:1813
msgid "Size in bytes of PLT relocs"
msgstr "PLT 再配置 (reloc) テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1813
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr "B<DT_PLTGOT>"

#. type: Plain text
#: build/C/man5/elf.5:1816
msgid "Address of PLT and/or GOT"
msgstr "PLT と GOT (または何れか一方) のアドレス"

#. type: TP
#: build/C/man5/elf.5:1816
#, no-wrap
msgid "B<DT_HASH>"
msgstr "B<DT_HASH>"

#. type: Plain text
#: build/C/man5/elf.5:1819
msgid "Address of symbol hash table"
msgstr "シンボルハッシュテーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1819
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr "B<DT_STRTAB>"

#. type: Plain text
#: build/C/man5/elf.5:1822
msgid "Address of string table"
msgstr "文字列テーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1822
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr "B<DT_SYMTAB>"

#. type: Plain text
#: build/C/man5/elf.5:1825
msgid "Address of symbol table"
msgstr "シンボルテーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1825
#, no-wrap
msgid "B<DT_RELA>"
msgstr "B<DT_RELA>"

#. type: Plain text
#: build/C/man5/elf.5:1828
msgid "Address of Rela relocs table"
msgstr "Rela 再配置テーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1828
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr "B<DT_RELASZ>"

#. type: Plain text
#: build/C/man5/elf.5:1831
msgid "Size in bytes of Rela table"
msgstr "Rela テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1831
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr "B<DT_RELAENT>"

#. type: Plain text
#: build/C/man5/elf.5:1834
msgid "Size in bytes of a Rela table entry"
msgstr "Rela テーブルエントリのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1834
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr "B<DT_STRSZ>"

#. type: Plain text
#: build/C/man5/elf.5:1837
msgid "Size in bytes of string table"
msgstr "文字列テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1837
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr "B<DT_SYMENT>"

#. type: Plain text
#: build/C/man5/elf.5:1840
msgid "Size in bytes of a symbol table entry"
msgstr "シンボルテーブルエントリのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1840
#, no-wrap
msgid "B<DT_INIT>"
msgstr "B<DT_INIT>"

#. type: Plain text
#: build/C/man5/elf.5:1843
msgid "Address of the initialization function"
msgstr "初期化関数のアドレス"

#. type: TP
#: build/C/man5/elf.5:1843
#, no-wrap
msgid "B<DT_FINI>"
msgstr "B<DT_FINI>"

#. type: Plain text
#: build/C/man5/elf.5:1846
msgid "Address of the termination function"
msgstr "終了関数のアドレス"

#. type: TP
#: build/C/man5/elf.5:1846
#, no-wrap
msgid "B<DT_SONAME>"
msgstr "B<DT_SONAME>"

#. type: Plain text
#: build/C/man5/elf.5:1849
msgid "String table offset to name of shared object"
msgstr "共有オブジェクトの名前への文字列テーブルオフセット"

#. type: TP
#: build/C/man5/elf.5:1849
#, no-wrap
msgid "B<DT_RPATH>"
msgstr "B<DT_RPATH>"

#. type: Plain text
#: build/C/man5/elf.5:1852
msgid "String table offset to library search path (deprecated)"
msgstr "ライブラリ検索パスへの文字列テーブルオフセット (推奨されない)"

#. type: TP
#: build/C/man5/elf.5:1852
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr "B<DT_SYMBOLIC>"

#. type: Plain text
#: build/C/man5/elf.5:1855
msgid ""
"Alert linker to search this shared object before the executable for symbols"
msgstr ""
"リンカがシンボルの実行可能ファイルより前に この共有オブジェクトを検索した場合"
"は、警告を出す。"

#. type: TP
#: build/C/man5/elf.5:1855
#, no-wrap
msgid "B<DT_REL>"
msgstr "B<DT_REL>"

#. type: Plain text
#: build/C/man5/elf.5:1858
msgid "Address of Rel relocs table"
msgstr "Rel 再配置テーブルのアドレス"

#. type: TP
#: build/C/man5/elf.5:1858
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr "B<DT_RELSZ>"

#. type: Plain text
#: build/C/man5/elf.5:1861
msgid "Size in bytes of Rel table"
msgstr "Rel テーブルのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1861
#, no-wrap
msgid "B<DT_RELENT>"
msgstr "B<DT_RELENT>"

#. type: Plain text
#: build/C/man5/elf.5:1864
msgid "Size in bytes of a Rel table entry"
msgstr "Rel テーブルエントリのサイズ (バイト単位)"

#. type: TP
#: build/C/man5/elf.5:1864
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr "B<DT_PLTREL>"

#. type: Plain text
#: build/C/man5/elf.5:1867
msgid "Type of reloc the PLT refers (Rela or Rel)"
msgstr "PLT が参照する再配置テーブルのタイプ (Rela または Rel)"

#. type: TP
#: build/C/man5/elf.5:1867
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr "B<DT_DEBUG>"

#. type: Plain text
#: build/C/man5/elf.5:1870
msgid "Undefined use for debugging"
msgstr "デバッグのために使用されている。内容は定義されていない。"

#. type: TP
#: build/C/man5/elf.5:1870
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr "B<DT_TEXTREL>"

#. type: Plain text
#: build/C/man5/elf.5:1873
msgid ""
"Absence of this indicates no relocs should apply to a nonwritable segment"
msgstr ""
"これが指定されていない場合、 書き込み不可のセグメントには再配置は適用されな"
"い。"

#. type: TP
#: build/C/man5/elf.5:1873
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr "B<DT_JMPREL>"

#. type: Plain text
#: build/C/man5/elf.5:1876
msgid "Address of reloc entries solely for the PLT"
msgstr "PLT 専用の再配置エントリのアドレス"

#. type: TP
#: build/C/man5/elf.5:1876
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr "B<DT_BIND_NOW>"

#. type: Plain text
#: build/C/man5/elf.5:1880
msgid ""
"Instruct dynamic linker to process all relocs before transferring control to "
"the executable"
msgstr ""
"実行可能ファイルに制御を譲る前に、 全ての再配置を処理するように動的リンカに指"
"示する。"

#. type: TP
#: build/C/man5/elf.5:1880
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr "B<DT_RUNPATH>"

#. type: Plain text
#: build/C/man5/elf.5:1883
msgid "String table offset to library search path"
msgstr "ライブラリ検索パスへの文字列テーブルオフセット"

#. type: TP
#: build/C/man5/elf.5:1883
#, no-wrap
msgid "B<DT_LOPROC>"
msgstr "B<DT_LOPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1886
msgid "Start of processor-specific semantics"
msgstr "プロセッサ固有の意味の開始"

#. type: TP
#: build/C/man5/elf.5:1886
#, no-wrap
msgid "B<DT_HIPROC>"
msgstr "B<DT_HIPROC>"

#. type: Plain text
#: build/C/man5/elf.5:1889
msgid "End of processor-specific semantics"
msgstr "プロセッサ固有の意味の終了"

#. type: TP
#: build/C/man5/elf.5:1891
#, no-wrap
msgid "I<d_val>"
msgstr "I<d_val>"

#. type: Plain text
#: build/C/man5/elf.5:1894
msgid "This member represents integer values with various interpretations."
msgstr "このメンバは様々な意味に解釈される整数値である。"

#. type: TP
#: build/C/man5/elf.5:1894
#, no-wrap
msgid "I<d_ptr>"
msgstr "I<d_ptr>"

#. type: Plain text
#: build/C/man5/elf.5:1902
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""
"このメンバはプログラムの仮想アドレスを表す。 これらのアドレスを解釈する際"
"に、 実際のアドレスは元々のファイルの値と メモリの基底アドレスから計算され"
"る。 ファイルにはこれらのアドレスを修正するための 再配置エントリを含めてはな"
"らない。"

#. type: TP
#: build/C/man5/elf.5:1902
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr "I<_DYNAMIC>"

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1907
msgid ""
"Array containing all the dynamic structures in the .dynamic section.  This "
"is automatically populated by the linker."
msgstr ""
"\\&.dynamic セクションにある全ての動的構造体を含む配列。 これは自動的にリンカ"
"に渡される。"

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: build/C/man5/elf.5:1916
msgid "ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""
"ELF は System V で初めて登場した。 ELF 自体は System V で初めて登場した。 "
"ELF フォーマットは採択された標準である。"

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: build/C/man5/elf.5:1934
msgid ""
"The extensions for I<e_phnum>, I<e_shnum> and I<e_strndx> respectively are "
"Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1941
msgid "B<as>(1), B<gdb>(1), B<ld>(1), B<objdump>(1), B<execve>(2), B<core>(5)"
msgstr "B<as>(1), B<gdb>(1), B<ld>(1), B<objdump>(1), B<execve>(2), B<core>(5)"

#. type: Plain text
#: build/C/man5/elf.5:1944
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr "Hewlett-Packard, I<Elf-64 Object File Format>."

#. type: Plain text
#: build/C/man5/elf.5:1947
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr "Santa Cruz Operation, I<System V Application Binary Interface>."

#. type: Plain text
#: build/C/man5/elf.5:1951
#, fuzzy
#| msgid ""
#| "Unix System Laboratories, \"Object Files\", I<Executable and Linking "
#| "Format (ELF)>."
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""
"Unix System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."

#. type: Plain text
#: build/C/man5/elf.5:1954
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1957
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""

#. type: TH
#: build/C/man3/end.3:25
#, no-wrap
msgid "END"
msgstr "END"

#. type: TH
#: build/C/man3/end.3:25
#, no-wrap
msgid "2008-07-17"
msgstr "2008-07-17"

#. type: Plain text
#: build/C/man3/end.3:28
msgid "etext, edata, end - end of program segments"
msgstr "etext, edata, end - プログラムセグメントの終わり"

#. type: Plain text
#: build/C/man3/end.3:33
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"

#. type: Plain text
#: build/C/man3/end.3:37
msgid ""
"The addresses of these symbols indicate the end of various program segments:"
msgstr "これらのシンボルのアドレスは各種のプログラムセグメントの終わりを示す。"

#. type: TP
#: build/C/man3/end.3:37
#, no-wrap
msgid "I<etext>"
msgstr "I<etext>"

#. type: Plain text
#: build/C/man3/end.3:41
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr "テキストセグメント (プログラムのコード) の末尾の次のアドレス。"

#. type: TP
#: build/C/man3/end.3:41
#, no-wrap
msgid "I<edata>"
msgstr "I<edata>"

#. type: Plain text
#: build/C/man3/end.3:45
msgid "This is the first address past the end of the initialized data segment."
msgstr "初期化されたデータのセグメントの末尾の次のアドレス。"

#. type: TP
#: build/C/man3/end.3:45
#, no-wrap
msgid "I<end>"
msgstr "I<end>"

#. type: Plain text
#: build/C/man3/end.3:49
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""
"初期化されていないデータのセグメント (BSS セグメントとも言われる)  の末尾の次"
"のアドレス。"

#. type: Plain text
#: build/C/man3/end.3:52
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""
"これらのシンボルは長年ほとんどの UNIX システムで提供されているが、 標準化され"
"てはいない。注意して使うこと。"

#. type: Plain text
#: build/C/man3/end.3:55
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""
"プログラムではこれらのシンボルは明示的に宣言しなければならない。 これらはどの"
"ヘッダファイルでも定義されていない。"

#. type: Plain text
#: build/C/man3/end.3:63
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for "
"programs compiled on Linux."
msgstr ""
"いくつかのシステムでは、これらのシンボルの名前は前にアンダースコアが 付いてい"
"て、 I<_etext>, I<_edata>, I<_end> となっている。 Linux でコンパイルされたプ"
"ログラムでは、 これらのシンボルでも定義される。"

#. type: Plain text
#: build/C/man3/end.3:75
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""
"プログラムの実行開始時に、プログラム・ブレークは I<&end> の近くのどこか (おそ"
"らく次のページの先頭) になる。 しかしながら、 B<brk>(2)  や B<malloc>(3)  で"
"メモリが割り当てられるに連れて、プログラム・ブレークは変化していく。 引き数"
"に 0 を指定して B<sbrk>(2)  を呼び出すことで、プログラム・ブレークの現在値を"
"知ることができる。"

#. type: Plain text
#: build/C/man3/end.3:77
msgid "When run, the program below produces output such as the following:"
msgstr "下記のプログラムを実行すると、次のような出力が得られる。"

#. type: Plain text
#: build/C/man3/end.3:85
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"

#. type: SS
#: build/C/man3/end.3:87
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/end.3:92
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/end.3:95
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"

#. type: Plain text
#: build/C/man3/end.3:103
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"

#. type: Plain text
#: build/C/man3/end.3:112
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"

#. type: TH
#: build/C/man8/ld.so.8:2
#, no-wrap
msgid "LD.SO"
msgstr "LD.SO"

#. type: TH
#: build/C/man8/ld.so.8:2
#, fuzzy, no-wrap
#| msgid "2008-12-06"
msgid "2012-03-06"
msgstr "2008-12-06"

#. type: Plain text
#: build/C/man8/ld.so.8:5
msgid "ld.so, ld-linux.so* - dynamic linker/loader"
msgstr "ld.so, ld-linux.so* - 動的なリンカ/ローダ"

#. type: Plain text
#: build/C/man8/ld.so.8:12
msgid ""
"The dynamic linker can be run either indirectly by running some dynamically "
"linked program or library (in which case no command-line options to the "
"dynamic linker can be passed and, in the ELF case, the dynamic linker which "
"is stored in the B<.interp> section of the program is executed) or directly "
"by running:"
msgstr ""
"動的リンカは、動的にリンクされたプログラムやライブラリの実行によって 間接的に"
"実行することができる (ELF の場合、動的リンカにコマンドラインオプションを渡す"
"ことはできず、 プログラムの B<.interp> セクションに入っている動的リンカが実行"
"される)。 また以下のように直接実行することもできる"

#. type: Plain text
#: build/C/man8/ld.so.8:15
msgid "I</lib/ld-linux.so.*> [OPTIONS] [PROGRAM [ARGUMENTS]]"
msgstr "I</lib/ld-linux.so.*> [OPTIONS] [PROGRAM [ARGUMENTS]]"

#. type: Plain text
#: build/C/man8/ld.so.8:22
msgid ""
"The programs B<ld.so> and B<ld-linux.so*> find and load the shared libraries "
"needed by a program, prepare the program to run, and then run it."
msgstr ""
"プログラム B<ld.so> と B<ld-linux.so*> はプログラムに必要な共有ライブラリを見"
"つけてロードし、 プログラムの実行を準備してから起動させる。"

#. type: Plain text
#: build/C/man8/ld.so.8:29
msgid ""
"Linux binaries require dynamic linking (linking at run time)  unless the B<-"
"static> option was given to B<ld>(1)  during compilation."
msgstr ""
"Linux のバイナリは、コンパイルの時に B<ld>(1)  に対して B<-static> オプション"
"が指定されていない限り、動的リンク (実行時リンク) が必要となる。"

#. type: Plain text
#: build/C/man8/ld.so.8:42
msgid ""
"The program B<ld.so> handles a.out binaries, a format used long ago; B<ld-"
"linux.so*> handles ELF (I</lib/ld-linux.so.1> for libc5, I</lib/ld-linux."
"so.2> for glibc2), which everybody has been using for years now.  Otherwise "
"both have the same behavior, and use the same support files and programs "
"B<ldd>(1), B<ldconfig>(8)  and I</etc/ld.so.conf>."
msgstr ""
"プログラム B<ld.so> は a.out バイナリを扱う。 これはずっと昔に使われていた"
"フォーマットである。 B<ld-linux.so*> (libc5 では I</lib/ld-linux.so.1>, "
"glibc2 では I</lib/ld-linux.so.2>)  は ELF バイナリを扱う。 このフォーマット"
"は多くの人が最近何年も使っている。 それ以外の点では両方とも同じように動作"
"し、 同じサポートファイルとプログラム B<ldd>(1), B<ldconfig>(8), I</etc/ld."
"so.conf> を使用する。"

#. type: Plain text
#: build/C/man8/ld.so.8:45
msgid ""
"The shared libraries needed by the program are searched for in the following "
"order:"
msgstr "プログラムで必要とされる共有ライブラリは、 以下の順序で検索される。"

#. type: Plain text
#: build/C/man8/ld.so.8:50
msgid ""
"(ELF only) Using the directories specified in the DT_RPATH dynamic section "
"attribute of the binary if present and DT_RUNPATH attribute does not exist.  "
"Use of DT_RPATH is deprecated."
msgstr ""
"(ELF のみ)  バイナリの動的セクション属性 DT_RPATH が存在し、 DT_RUNPATH 属性"
"が存在しない場合は、 DT_RPATH で指定されたディレクトリを使用する。 DT_RPATH "
"の使用は推奨されない。"

#. type: Plain text
#: build/C/man8/ld.so.8:55
msgid ""
"Using the environment variable B<LD_LIBRARY_PATH>.  Except if the executable "
"is a set-user-ID/set-group-ID binary, in which case it is ignored."
msgstr ""
"環境変数 B<LD_LIBRARY_PATH> を用いる。 ただし実行ファイルが set-user-ID/set-"
"group-ID バイナリの場合、 これは無視される。"

#. type: Plain text
#: build/C/man8/ld.so.8:59
msgid ""
"(ELF only) Using the directories specified in the DT_RUNPATH dynamic section "
"attribute of the binary if present."
msgstr ""
"(ELF のみ)  バイナリの動的セクション属性 DT_RUNPATH が存在すれば、 "
"DT_RUNPATH で指定されたディレクトリを使用する。"

#. type: Plain text
#: build/C/man8/ld.so.8:67
msgid ""
"From the cache file I</etc/ld.so.cache> which contains a compiled list of "
"candidate libraries previously found in the augmented library path.  If, "
"however, the binary was linked with the B<-z nodeflib> linker option, "
"libraries in the default library paths are skipped."
msgstr ""
"キャッシュファイル I</etc/ld.so.cache> を探す。このファイルは、 (ld.so.conf "
"で追加指定されたものも含めた) ライブラリ検索パスから 見つかったライブラリファ"
"イルの情報を集めたものである。 ただしバイナリがリンカオプション B<-z "
"nodeflib> でリンクされている場合は、デフォルトのライブラリパスにある ライブラ"
"リはスキップされる。"

#. type: Plain text
#: build/C/man8/ld.so.8:75
msgid ""
"In the default path I</lib>, and then I</usr/lib>.  If the binary was linked "
"with the B<-z nodeflib> linker option, this step is skipped."
msgstr ""
"デフォルトパスである I</lib>、 次いで I</usr/lib> を用いる。 バイナリがリンカ"
"オプション B<-z nodeflib> でリンクされている場合、このステップはスキップされ"
"る。"

#. type: SS
#: build/C/man8/ld.so.8:75
#, no-wrap
msgid "$ORIGIN and rpath"
msgstr "$ORIGIN と rpath"

#.  ld.so also understands $LIB, with the same meaning as $ORIGIN/lib,
#.  it appears.
#.  There is also $PLATFORM.  This is a kind of wildcard
#.  of directories related at AT_HWCAP.  To get an idea of the
#.  places that $PLATFORM would match, look at the output of the
#.  following:
#.  mkdir /tmp/d
#.  LD_LIBRARY_PATH=/tmp/d strace -e open /bin/date 2>&1 | grep /tmp/d
#.  ld.so lets names be abbreviated, so $O will work for $ORIGIN;
#.  Don't do this!!
#. type: Plain text
#: build/C/man8/ld.so.8:110
msgid ""
"B<ld.so> understands the string I<$ORIGIN> (or equivalently I<${ORIGIN}>)  "
"in an rpath specification (DT_RPATH or DT_RUNPATH) to mean the directory "
"containing the application executable.  Thus, an application located in "
"I<somedir/app> could be compiled with I<gcc -Wl,-rpath,\\(aq$ORIGIN/../lib"
"\\(aq> so that it finds an associated shared library in I<somedir/lib> no "
"matter where I<somedir> is located in the directory hierarchy.  This "
"facilitates the creation of \"turn-key\" applications that do not need to be "
"installed into special directories, but can instead be unpacked into any "
"directory and still find their own shared libraries."
msgstr ""
"B<ld.so> では、rpath 指定 (DT_RPATH や DT_RUNPATH) 中に I<$ORIGIN> という文字"
"列 (I<${ORIGIN}> も等価) を使うことができる。 I<$ORIGIN> はアプリケーションの"
"実行ファイルが入っているディレクトリを表す。 これを使って I<somedir/app> に置"
"かれたアプリケーションを I<gcc -Wl,-rpath,'$ORIGIN/../lib'> でコンパイルする"
"と、 I<somedir> がディレクトリ階層のどこにあっても、アプリケーションは "
"I<somedir/lib> にある対応する共有ライブラリを見つけることができる。 この機能"
"を使うと、 特別なディレクトリではなく任意のディレクトリにインストールしても "
"\"ややこしい設定なしで\" 独自の共有ライブラリを使えるアプリケーションを作成す"
"ることができる。"

#. type: SH
#: build/C/man8/ld.so.8:110 build/C/man8/ldconfig.8:100 build/C/man1/ldd.1:19
#, no-wrap
msgid "OPTIONS"
msgstr "オプション"

#. type: TP
#: build/C/man8/ld.so.8:111
#, no-wrap
msgid "B<--list>"
msgstr "B<--list>"

#. type: Plain text
#: build/C/man8/ld.so.8:114
msgid "List all dependencies and how they are resolved."
msgstr "全ての依存関係とその解決法をリストする。"

#. type: TP
#: build/C/man8/ld.so.8:114
#, no-wrap
msgid "B<--verify>"
msgstr "B<--verify>"

#. type: Plain text
#: build/C/man8/ld.so.8:118
msgid ""
"Verify that program is dynamically linked and this dynamic linker can handle "
"it."
msgstr ""
"プログラムが動的にリンクされているかと、 動的リンカがそのプログラムを扱えるか"
"を検証する。"

#. type: TP
#: build/C/man8/ld.so.8:118
#, no-wrap
msgid "B<--library-path PATH>"
msgstr "B<--library-path PATH>"

#. type: Plain text
#: build/C/man8/ld.so.8:123
#, fuzzy
#| msgid ""
#| "Override B<LD_LIBRARY_PATH> environment variable setting (see below)."
msgid ""
"Use PATH instead of B<LD_LIBRARY_PATH> environment variable setting (see "
"below)."
msgstr "B<LD_LIBRARY_PATH> 環境変数の設定を上書きする (下記参照)。"

#. type: TP
#: build/C/man8/ld.so.8:123
#, no-wrap
msgid "B<--inhibit-rpath LIST>"
msgstr "B<--inhibit-rpath LIST>"

#. type: Plain text
#: build/C/man8/ld.so.8:129
msgid ""
"Ignore RPATH and RUNPATH information in object names in LIST.  This option "
"is ignored if B<ld.so> is set-user-ID or set-group-ID."
msgstr ""
"LIST にあるオブジェクト名の RPATH と RUNPATH の情報を無視する。 B<ld.so> が "
"set-user-ID か set-group-ID されている場合、 このオプションは無視される。"

#. type: TP
#: build/C/man8/ld.so.8:129
#, fuzzy, no-wrap
#| msgid "B<--inhibit-rpath LIST>"
msgid "B<--audit LIST>"
msgstr "B<--inhibit-rpath LIST>"

#. type: Plain text
#: build/C/man8/ld.so.8:132
msgid "Use objects named in LIST as auditors."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:132
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境変数"

#. type: Plain text
#: build/C/man8/ld.so.8:134
msgid "There are four important environment variables."
msgstr "4 つの重要な環境変数がある。"

#. type: TP
#: build/C/man8/ld.so.8:134
#, no-wrap
msgid "B<LD_BIND_NOW>"
msgstr "B<LD_BIND_NOW>"

#. type: Plain text
#: build/C/man8/ld.so.8:142
msgid ""
"(libc5; glibc since 2.1.1)  If set to a nonempty string, causes the dynamic "
"linker to resolve all symbols at program startup instead of deferring "
"function call resolution to the point when they are first referenced.  This "
"is useful when using a debugger."
msgstr ""
"(libc5; glibc 2.1.1 以降)  空文字列でない場合、 動的リンカはプログラムの開始"
"時に全てのシンボルを解決する。 空文字列の場合、解決しなければならない関数呼び"
"出しが 最初に参照された時点で解決する。 デバッガを使っているときに役立つ。"

#. type: TP
#: build/C/man8/ld.so.8:142
#, no-wrap
msgid "B<LD_LIBRARY_PATH>"
msgstr "B<LD_LIBRARY_PATH>"

#. type: Plain text
#: build/C/man8/ld.so.8:149
msgid ""
"A colon-separated list of directories in which to search for ELF libraries "
"at execution-time.  Similar to the B<PATH> environment variable."
msgstr ""
"コロン区切りのディレクトリリスト。 実行時に ELF ライブラリを検索するディレク"
"トリを指定する。 B<PATH> 環境変数と同じように指定する。"

#. type: TP
#: build/C/man8/ld.so.8:149
#, no-wrap
msgid "B<LD_PRELOAD>"
msgstr "B<LD_PRELOAD>"

#. type: Plain text
#: build/C/man8/ld.so.8:157
msgid ""
"A whitespace-separated list of additional, user-specified, ELF shared "
"libraries to be loaded before all others.  This can be used to selectively "
"override functions in other shared libraries.  For set-user-ID/set-group-ID "
"ELF binaries, only libraries in the standard search directories that are "
"also set-user-ID will be loaded."
msgstr ""
"スペース区切りで ELF 共有ライブラリを指定する。 これはユーザーが指定でき、す"
"べてのライブラリに先立ってロードされる。 他の共有ライブラリにある関数を選択的"
"に置き換えるために用いることができる。 set-user-ID/set-group-ID された ELF バ"
"イナリに対して、 標準的な検索パスにあるライブラリのうち set-user-ID されてい"
"るものはロードしない。"

#. type: TP
#: build/C/man8/ld.so.8:157
#, no-wrap
msgid "B<LD_TRACE_LOADED_OBJECTS>"
msgstr "B<LD_TRACE_LOADED_OBJECTS>"

#. type: Plain text
#: build/C/man8/ld.so.8:164
msgid ""
"(ELF only)  If set to a nonempty string, causes the program to list its "
"dynamic library dependencies, as if run by B<ldd>(1), instead of running "
"normally."
msgstr ""
"(ELF のみ)  空文字列でない場合、 プログラムを普通に実行するのではなく、 "
"B<ldd>(1)  を実行したときのように動的ライブラリの依存関係をリスト表示させる。"

#. type: Plain text
#: build/C/man8/ld.so.8:167
msgid ""
"Then there are lots of more or less obscure variables, many obsolete or only "
"for internal use."
msgstr ""
"そして、それほど知られていない環境変数もある。 多くは廃れてしまったものか内部"
"でのみ使用される環境変数である。"

#. type: TP
#: build/C/man8/ld.so.8:167
#, no-wrap
msgid "B<LD_AOUT_LIBRARY_PATH>"
msgstr "B<LD_AOUT_LIBRARY_PATH>"

#. type: Plain text
#: build/C/man8/ld.so.8:175
msgid ""
"(libc5)  Version of B<LD_LIBRARY_PATH> for a.out binaries only.  Old "
"versions of ld-linux.so.1 also supported B<LD_ELF_LIBRARY_PATH>."
msgstr ""
"(libc5)  a.out バイナリにのみ使われる環境変数で、 B<LD_LIBRARY_PATH> と同じ役"
"割をする。 ld-linux.so.1 の古いバージョンでは B<LD_ELF_LIBRARY_PATH> もサポー"
"トしていた。"

#. type: TP
#: build/C/man8/ld.so.8:175
#, no-wrap
msgid "B<LD_AOUT_PRELOAD>"
msgstr "B<LD_AOUT_PRELOAD>"

#. type: Plain text
#: build/C/man8/ld.so.8:183
msgid ""
"(libc5)  Version of B<LD_PRELOAD> for a.out binaries only.  Old versions of "
"ld-linux.so.1 also supported B<LD_ELF_PRELOAD>."
msgstr ""
"(libc5)  a.out バイナリにのみ使われる環境変数で、 B<LD_PRELOAD> と同じ役割を"
"する。 ld-linux.so.1 の古いバージョンでは B<LD_ELF_PRELOAD> もサポートしてい"
"た。"

#. type: TP
#: build/C/man8/ld.so.8:183
#, no-wrap
msgid "B<LD_AUDIT>"
msgstr "B<LD_AUDIT>"

#. type: Plain text
#: build/C/man8/ld.so.8:193
msgid ""
"(glibc since 2.4)  A colon-separated list of user-specified, ELF shared "
"objects to be loaded before all others in a separate linker namespace (i.e., "
"one that does not intrude upon the normal symbol bindings that would occur "
"in the process).  These libraries can be used to audit the operation of the "
"dynamic linker.  B<LD_AUDIT> is ignored for set-user-ID/set-group-ID "
"binaries."
msgstr ""
"(glibc 2.4 以降)  他のオブジェクトよりも前に、別のリンカ名前空間 (そのプロセ"
"スで行われる 通常のシンボル結合 (symbol bindigns) には関与しない名前空間) で "
"ロードされる、ユーザ指定の ELF 共有オブジェクトのコロン区切りのリスト。 これ"
"らのライブラリを使って、動的リンカの動作を監査することができる。 set-user-ID/"
"set-group-ID されたバイナリでは、 B<LD_AUDIT> は無視される。"

#. type: Plain text
#: build/C/man8/ld.so.8:206
msgid ""
"The dynamic linker will notify the audit libraries at so-called auditing "
"checkpoints\\(emfor example, loading a new library, resolving a symbol, or "
"calling a symbol from another shared object\\(emby calling an appropriate "
"function within the audit library.  For details, see B<rtld-audit>(7).  The "
"auditing interface is largely compatible with that provided on Solaris, as "
"described in its I<Linker and Libraries Guide>, in the chapter I<Runtime "
"Linker Auditing Interface>."
msgstr ""
"動的リンカは、いわゆる監査チェックポイント (auditing checkpoints)  において、"
"監査 (audit) ライブラリの適切な関数を呼び出すことで、 監査ライブラリへの通知"
"を行う。監査チェックポイントの例としては、 新たなライブラリのロード、シンボル"
"の解決、別の共有オブジェクト からのシンボルの呼び出し、などがある。 詳細は "
"B<rtld-audit>(7)  を参照してほしい。 audit インタフェースは、Solaris で提供さ"
"れているものと 大部分は互換性がある。Solaris の audit インタフェースについて"
"は、 I<Linker and Libraries Guide> の I<Runtime Linker Auditing Interface> の"
"章に説明がある。"

#. type: TP
#: build/C/man8/ld.so.8:206
#, no-wrap
msgid "B<LD_BIND_NOT>"
msgstr "B<LD_BIND_NOT>"

#. type: Plain text
#: build/C/man8/ld.so.8:211
msgid ""
"(glibc since 2.1.95)  Do not update the GOT (global offset table) and PLT "
"(procedure linkage table)  after resolving a symbol."
msgstr ""
"(glibc 2.1.95 以降)  シンボルを解決した後、GOT (global offset table) と PLT "
"(procedure linkage table) を更新しない。"

#. type: TP
#: build/C/man8/ld.so.8:211
#, no-wrap
msgid "B<LD_DEBUG>"
msgstr "B<LD_DEBUG>"

#. type: Plain text
#: build/C/man8/ld.so.8:224
msgid ""
"(glibc since 2.1)  Output verbose debugging information about the dynamic "
"linker.  If set to B<all> prints all debugging information it has, if set to "
"B<help> prints a help message about which categories can be specified in "
"this environment variable.  Since glibc 2.3.4, B<LD_DEBUG> is ignored for "
"set-user-ID/set-group-ID binaries."
msgstr ""
"(glibc 2.1 以降)  動的リンカの詳細なデバッグ情報を出力する。 B<all> に設定し"
"た場合、全ての動的リンカが持つデバッグ情報を表示する。 B<help> に設定した場"
"合、この環境変数で指定されるカテゴリのヘルプ情報を表示する。 glibc 2.3.4 以"
"降、 set-user-ID/set-group-ID されたバイナリでは B<LD_DEBUG> は無視される。"

#. type: TP
#: build/C/man8/ld.so.8:224
#, no-wrap
msgid "B<LD_DEBUG_OUTPUT>"
msgstr "B<LD_DEBUG_OUTPUT>"

#. type: Plain text
#: build/C/man8/ld.so.8:232
msgid ""
"(glibc since 2.1)  File where B<LD_DEBUG> output should be fed into, default "
"is standard output.  B<LD_DEBUG_OUTPUT> is ignored for set-user-ID/set-group-"
"ID binaries."
msgstr ""
"(glibc 2.1 以降)  B<LD_DEBUG> の出力を書き込むファイル。 デフォルトは標準出力"
"である。 set-user-ID/set-group-ID されたバイナリでは、 B<LD_DEBUG_OUTPUT> は"
"無視される。"

#. type: TP
#: build/C/man8/ld.so.8:232
#, no-wrap
msgid "B<LD_DYNAMIC_WEAK>"
msgstr "B<LD_DYNAMIC_WEAK>"

#. type: Plain text
#: build/C/man8/ld.so.8:239
msgid ""
"(glibc since 2.1.91)  Allow weak symbols to be overridden (reverting to old "
"glibc behavior).  For security reasons, since glibc 2.3.4, "
"B<LD_DYNAMIC_WEAK> is ignored for set-user-ID/set-group-ID binaries."
msgstr ""
"(glibc 2.1.19 以降)  上書きされる弱いシンボル (昔の glibc の挙動を逆にす"
"る)。 セキュリティ上の理由から、glibc 2.3.4 以降、 set-user-ID/set-group-ID "
"されたバイナリでは B<LD_DYNAMIC_WEAK> は無視される。"

#. type: TP
#: build/C/man8/ld.so.8:239
#, no-wrap
msgid "B<LD_HWCAP_MASK>"
msgstr "B<LD_HWCAP_MASK>"

#. type: Plain text
#: build/C/man8/ld.so.8:243
msgid "(glibc since 2.1)  Mask for hardware capabilities."
msgstr "(glibc 2.1 以降)  ハードウェア機能のマスク。"

#. type: TP
#: build/C/man8/ld.so.8:243
#, no-wrap
msgid "B<LD_KEEPDIR>"
msgstr "B<LD_KEEPDIR>"

#. type: Plain text
#: build/C/man8/ld.so.8:248
msgid ""
"(a.out only)(libc5)  Don't ignore the directory in the names of a.out "
"libraries to be loaded.  Use of this option is strongly discouraged."
msgstr ""
"(a.out のみ)(libc5)  ロードする a.out ライブラリの名前において、ディレクトリ"
"を無視しない。 このオプションは用いるべきではない。"

#. type: TP
#: build/C/man8/ld.so.8:248
#, no-wrap
msgid "B<LD_NOWARN>"
msgstr "B<LD_NOWARN>"

#. type: Plain text
#: build/C/man8/ld.so.8:253
msgid ""
"(a.out only)(libc5)  Suppress warnings about a.out libraries with "
"incompatible minor version numbers."
msgstr ""
"(a.out のみ)(libc5)  a.out ライブラリにおけるマイナーバージョン番号の非互換"
"に 対する警告メッセージを抑制する。"

#. type: TP
#: build/C/man8/ld.so.8:253
#, no-wrap
msgid "B<LD_ORIGIN_PATH>"
msgstr "B<LD_ORIGIN_PATH>"

#.  Only used if $ORIGIN can't be determined by normal means
#.  (from the origin path saved at load time, or from /proc/self/exe)?
#. type: Plain text
#: build/C/man8/ld.so.8:262
msgid ""
"(glibc since 2.1)  Path where the binary is found (for non-set-user-ID "
"programs).  For security reasons, since glibc 2.4, B<LD_ORIGIN_PATH> is "
"ignored for set-user-ID/set-group-ID binaries."
msgstr ""
"(glibc 2.1 以降)  バイナリへのパス (set-user-ID されていないプログラムについ"
"て)。 セキュリティ上の理由から、glibc 2.3.4 以降、 set-user-ID/set-group-ID "
"されたバイナリでは B<LD_ORIGIN_PATH> は無視される。"

#. type: TP
#: build/C/man8/ld.so.8:262
#, no-wrap
msgid "B<LD_POINTER_GUARD>"
msgstr "B<LD_POINTER_GUARD>"

#. type: Plain text
#: build/C/man8/ld.so.8:274
msgid ""
"(glibc since 2.4)  Set to 0 to disable pointer guarding.  Any other value "
"enables pointer guarding, which is also the default.  Pointer guarding is a "
"security mechanism whereby some pointers to code stored in writable program "
"memory (return addresses saved by B<setjmp>(3)  or function pointers used by "
"various glibc internals) are mangled semi-randomly to make it more difficult "
"for an attacker to hijack the pointers for use in the event of a buffer "
"overrun or stack-smashing attack."
msgstr ""
"(glibc 2.4 以降)  0 に設定すると、ポインタ保護 (pointer guarding) が無効にな"
"る。 それ以外の値の場合はポインタ保護が有効になる。 デフォルトはポインタ保護"
"有効である。 ポインタ保護はセキュリティ機構の一つで、書き込み可能なプログラム"
"メモリ に格納されたコードへのポインタをほぼランダム化することで、 攻撃者が"
"バッファオーバーランやスタック破壊 (stack-smashing) 攻撃の際に ポインタを乗っ"
"取ることを困難にするものである。"

#. type: TP
#: build/C/man8/ld.so.8:274
#, no-wrap
msgid "B<LD_PROFILE>"
msgstr "B<LD_PROFILE>"

#. type: Plain text
#: build/C/man8/ld.so.8:281
msgid ""
"(glibc since 2.1)  Shared object to be profiled, specified either as a "
"pathname or a soname.  Profiling output is written to the file whose name "
"is: \"I<$LD_PROFILE_OUTPUT>/I<$LD_PROFILE>.profile\"."
msgstr ""
"(glibc 2.1 以降)  プロファイルを行う共有オブジェクト。 パス名か共有オブジェク"
"ト名 (soname) で指定される。 プロフィールの出力は \"I<$LD_PROFILE_OUTPUT>/I<"
"$LD_PROFILE>.profile\" という名前の ファイルに書き込まれる。"

#. type: TP
#: build/C/man8/ld.so.8:281
#, no-wrap
msgid "B<LD_PROFILE_OUTPUT>"
msgstr "B<LD_PROFILE_OUTPUT>"

#. type: Plain text
#: build/C/man8/ld.so.8:294
msgid ""
"(glibc since 2.1)  Directory where B<LD_PROFILE> output should be written.  "
"If this variable is not defined, or is defined as an empty string, then the "
"default is I</var/tmp>.  B<LD_PROFILE_OUTPUT> is ignored for set-user-ID and "
"set-group-ID programs, which always use I</var/profile>."
msgstr ""
"(glibc 2.1 以降)  B<LD_PROFILE> の出力が書き込まれるディレクトリ。 この変数が"
"定義されていないか、空の文字列が定義されている場合、 デフォルト値は I</var/"
"tmp> となる。 set-user-ID/set-group-ID されたプログラムでは、 "
"LD_PROFILE_OUTPUT は無視される。 出力ファイルは常に I</var/profile> が使用さ"
"れる。"

#. type: TP
#: build/C/man8/ld.so.8:294
#, no-wrap
msgid "B<LD_SHOW_AUXV>"
msgstr "B<LD_SHOW_AUXV>"

#.  FIXME
#.  Document LD_TRACE_PRELINKING (e.g.: LD_TRACE_PRELINKING=libx1.so ./prog)
#.  Since glibc 2.3
#.  Also enables DL_DEBUG_PRELINK
#. type: Plain text
#: build/C/man8/ld.so.8:305
msgid ""
"(glibc since 2.1)  Show auxiliary array passed up from the kernel.  For "
"security reasons, since glibc 2.3.5, B<LD_SHOW_AUXV> is ignored for set-user-"
"ID/set-group-ID binaries."
msgstr ""
"(glibc 2.1 以降)  カーネルから渡される補助的な (パラメータの) 配列を表示す"
"る。 セキュリティ上の理由から、glibc 2.3.4 以降、 set-user-ID/set-group-ID さ"
"れたバイナリでは B<LD_SHOW_AUXV> は無視される。"

#. type: TP
#: build/C/man8/ld.so.8:305
#, no-wrap
msgid "B<LD_USE_LOAD_BIAS>"
msgstr "B<LD_USE_LOAD_BIAS>"

#.  http://sources.redhat.com/ml/libc-hacker/2003-11/msg00127.html
#.  Subject: [PATCH] Support LD_USE_LOAD_BIAS
#.  Jakub Jelinek
#. type: Plain text
#: build/C/man8/ld.so.8:324
msgid ""
"By default (i.e., if this variable is not defined)  executables and "
"prelinked shared objects will honor base addresses of their dependent "
"libraries and (nonprelinked) position-independent executables (PIEs)  and "
"other shared objects will not honor them.  If B<LD_USE_LOAD_BIAS> is defined "
"wit the value, both executables and PIEs will honor the base addresses.  If "
"B<LD_USE_LOAD_BIAS> is defined with the value 0, neither executables nor "
"PIEs will honor the base addresses.  This variable is ignored by set-user-ID "
"and set-group-ID programs."
msgstr ""
"デフォルトでは (つまり、この変数が定義されていない場合)、 実行ファイルと "
"prelink された共有オブジェクトでは、それらが依存する ライブラリのベースアドレ"
"スが尊重される一方、 (prelink されていない) position-independent executables "
"(PIEs) と 他の共有オブジェクトでは依存するライブラリのベースアドレスは 尊重さ"
"れない。 B<LD_USE_LOAD_BIAS> に値が定義された場合、実行ファイルと PIE のどち"
"らでも ベースアドレスが尊重される。 B<LD_USE_LOAD_BIAS> が値 0 で定義された場"
"合、実行ファイルと PIE のどちらでも ベースアドレスは尊重されない。 set-user-"
"ID や set-group-ID されたプログラムでは、 この変数は無視される。"

#. type: TP
#: build/C/man8/ld.so.8:324
#, no-wrap
msgid "B<LD_VERBOSE>"
msgstr "B<LD_VERBOSE>"

#. type: Plain text
#: build/C/man8/ld.so.8:336
msgid ""
"(glibc since 2.1)  If set to a nonempty string, output symbol versioning "
"information about the program if querying information about the program (i."
"e., either B<LD_TRACE_LOADED_OBJECTS> has been set, or B<--list> or B<--"
"verify> options have been given to the dynamic linker)."
msgstr ""
"(glibc 2.1 以降)  空文字列でない場合に、 (B<LD_TRACE_LOADED_OBJECTS> を設定す"
"るか、 B<--list> または B<--verify> オプションを動的リンカに指定することによ"
"り)  プログラムについての情報を問い合わせると、 プログラムのシンボルバージョ"
"ン情報を表示する。"

#. type: TP
#: build/C/man8/ld.so.8:336
#, no-wrap
msgid "B<LD_WARN>"
msgstr "B<LD_WARN>"

#. type: Plain text
#: build/C/man8/ld.so.8:340
msgid ""
"(ELF only)(glibc since 2.1.3)  If set to a nonempty string, warn about "
"unresolved symbols."
msgstr ""
"(ELF のみ)(glibc 2.1.3 以降)  空文字列でない場合、解決されていないシンボルが"
"あれば警告を出す。"

#. type: TP
#: build/C/man8/ld.so.8:340
#, no-wrap
msgid "B<LDD_ARGV0>"
msgstr "B<LDD_ARGV0>"

#. type: Plain text
#: build/C/man8/ld.so.8:347
msgid "(libc5)  I<argv>[0] to be used by B<ldd>(1)  when none is present."
msgstr ""
"(libc5)  B<ldd>(1)  の引き数がない場合に、 I<argv>[0] として使われる値。"

#. type: SH
#: build/C/man8/ld.so.8:347 build/C/man8/ldconfig.8:156
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: TP
#: build/C/man8/ld.so.8:349 build/C/man8/ldconfig.8:158
#, no-wrap
msgid "I</lib/ld.so>"
msgstr "I</lib/ld.so>"

#. type: Plain text
#: build/C/man8/ld.so.8:352
msgid "a.out dynamic linker/loader"
msgstr "a.out の動的リンカ/ローダ"

#. type: TP
#: build/C/man8/ld.so.8:352
#, no-wrap
msgid "I</lib/ld-linux.so.>{I<1>,I<2>}"
msgstr "I</lib/ld-linux.so.>{I<1>,I<2>}"

#. type: Plain text
#: build/C/man8/ld.so.8:355
msgid "ELF dynamic linker/loader"
msgstr "ELF の動的リンカ/ローダ"

#. type: TP
#: build/C/man8/ld.so.8:355 build/C/man8/ldconfig.8:165
#, no-wrap
msgid "I</etc/ld.so.cache>"
msgstr "I</etc/ld.so.cache>"

#. type: Plain text
#: build/C/man8/ld.so.8:359
msgid ""
"File containing a compiled list of directories in which to search for "
"libraries and an ordered list of candidate libraries."
msgstr ""
"ライブラリを検索するディレクトリを集めたリストと、 共有ライブラリの候補の整列"
"リストを含むファイル。"

#. type: TP
#: build/C/man8/ld.so.8:359
#, no-wrap
msgid "I</etc/ld.so.preload>"
msgstr "I</etc/ld.so.preload>"

#. type: Plain text
#: build/C/man8/ld.so.8:363
msgid ""
"File containing a whitespace separated list of ELF shared libraries to be "
"loaded before the program."
msgstr ""
"プログラムの前にロードすべき ELF 共有ライブラリを スペースで区切ったリストが"
"書かれているファイル。"

#. type: TP
#: build/C/man8/ld.so.8:363
#, no-wrap
msgid "B<lib*.so*>"
msgstr "B<lib*.so*>"

#. type: Plain text
#: build/C/man8/ld.so.8:366
msgid "shared libraries"
msgstr "共有ライブラリ"

#. type: Plain text
#: build/C/man8/ld.so.8:373
msgid ""
"The B<ld.so> functionality is available for executables compiled using libc "
"version 4.4.3 or greater.  ELF functionality is available since Linux 1.1.52 "
"and libc5."
msgstr ""
"B<ld.so> の機能は libc のバージョン 4.4.3 以上を用いてコンパイルされた 実行"
"ファイルで使用可能である。 ELF の機能は Linux 1.1.52 以降と libc5 以降で使用"
"可能である。"

#.  .SH AUTHORS
#.  ld.so: David Engel, Eric Youngdale, Peter MacDonald, Hongjiu Lu, Linus
#.   Torvalds, Lars Wirzenius and Mitch D'Souza
#.  ld-linux.so: Roland McGrath, Ulrich Drepper and others.
#.  In the above, (libc5) stands for David Engel's ld.so/ld-linux.so.
#. type: Plain text
#: build/C/man8/ld.so.8:383
msgid "B<ldd>(1), B<rtld-audit>(7), B<ldconfig>(8)"
msgstr "B<ldd>(1), B<rtld-audit>(7), B<ldconfig>(8)"

#. type: TH
#: build/C/man8/ldconfig.8:22
#, no-wrap
msgid "LDCONFIG"
msgstr "LDCONFIG"

#. type: TH
#: build/C/man8/ldconfig.8:22
#, no-wrap
msgid "2009-04-15"
msgstr "2009-04-15"

#. type: Plain text
#: build/C/man8/ldconfig.8:25
msgid "/sbin/ldconfig - configure dynamic linker run-time bindings"
msgstr "/sbin/ldconfig - 動的リンカによる実行時の結合関係を設定する"

#. type: Plain text
#: build/C/man8/ldconfig.8:40
msgid ""
"B</sbin/ldconfig> [ B<-nNvXV> ] [ B<-f\\ conf> ] [ B<-C\\ cache> ] [ B<-r\\ "
"root> ] I<directory>\\ ..."
msgstr ""
"B</sbin/ldconfig> [ B<-nNvXV> ] [ B<-f\\ conf> ] [ B<-C\\ cache> ] [ B<-r\\ "
"root> ] I<directory>\\ ..."

#. type: Plain text
#: build/C/man8/ldconfig.8:49
msgid "B</sbin/ldconfig> B<-l> [ B<-v> ] I<library>\\ ..."
msgstr "B</sbin/ldconfig> B<-l> [ B<-v> ] I<library>\\ ..."

#. type: Plain text
#: build/C/man8/ldconfig.8:54
msgid "B</sbin/ldconfig> B<-p>"
msgstr "B</sbin/ldconfig> B<-p>"

#. type: Plain text
#: build/C/man8/ldconfig.8:71
msgid ""
"B<ldconfig> creates the necessary links and cache to the most recent shared "
"libraries found in the directories specified on the command line, in the "
"file I</etc/ld.so.conf>, and in the trusted directories (I</lib> and I</usr/"
"lib>).  The cache is used by the run-time linker, I<ld.so> or I<ld-linux."
"so>.  B<ldconfig> checks the header and filenames of the libraries it "
"encounters when determining which versions should have their links updated."
msgstr ""
"B<ldcofig> は最新の共有ライブラリに対して必要なリンクを作成したり、 ライブラ"
"リをキャッシュしたりする。 ライブラリは、コマンドラインや I</etc/ld.so.conf> "
"ファイルで指定されたディレクトリや、共有ライブラリが 通常置かれるディレクト"
"リ (I</lib> と I</usr/lib>)  から検索される。 キャッシュは実行時リンカ I<ld."
"so> または I<ld-linux.so> によって使われる。 B<ldconfig> は処理するライブラリ"
"のヘッダ部分とファイル名をチェックし、 どのバージョンに対してリンクを更新すべ"
"きかを判断する。"

#.  The following sentence looks suspect
#.  (perhaps historical cruft) -- MTK, Jul 2005
#.  Therefore, when making dynamic libraries,
#.  it is wise to explicitly link against libc (use \-lc).
#. type: Plain text
#: build/C/man8/ldconfig.8:79
msgid ""
"B<ldconfig> will attempt to deduce the type of ELF libs (i.e., libc5 or "
"libc6/glibc)  based on what C libs, if any, the library was linked against."
msgstr ""
"B<ldconfig> は ELF ライブラリの種類 (libc5 か libc6/glibc か) を判断すると"
"き、 そのライブラリがリンクしている C ライブラリを参考にする。"

#. type: Plain text
#: build/C/man8/ldconfig.8:100
msgid ""
"Some existing libs do not contain enough information to allow the deduction "
"of their type.  Therefore, the I</etc/ld.so.conf> file format allows the "
"specification of an expected type.  This is I<only> used for those ELF libs "
"which we can not work out.  The format is \"dirname=TYPE\", where TYPE can "
"be libc4, libc5, or libc6.  (This syntax also works on the command line.)  "
"Spaces are I<not> allowed.  Also see the B<-p> option.  B<ldconfig> should "
"normally be run by the superuser as it may require write permission on some "
"root owned directories and files."
msgstr ""
"すでに存在しているライブラリの中には、種類を区別するために充分な 情報が含まれ"
"ていないものもある。 このため I</etc/ld.so.conf> ファイルでライブラリの形式を"
"指定することができるようになっている。 これは区別不能な ELF ライブラリ「だ"
"け」に用いるものである。 フォーマットは \"dirname=TYPE\" とする。 ここで "
"TYPE は libc4, libc5, libc6 のいずれかである (この書式はコマンドラインでも使"
"える)。 「スペースを入れてはならない」。 B<-p> オプションも見ておくこと。 "
"B<ldconfig> は通常スーパーユーザー権限で実行しなければならない。 root が所有"
"しているディレクトリやファイルへの書き込み権限が 必要になるからである。"

#. type: TP
#: build/C/man8/ldconfig.8:101
#, no-wrap
msgid "B<-v>"
msgstr "B<-v>"

#. type: Plain text
#: build/C/man8/ldconfig.8:107
msgid ""
"Verbose mode.  Print current version number, the name of each directory as "
"it is scanned, and any links that are created.  Overrides quiet mode."
msgstr ""
"詳細表示モード。 現在のバージョン番号を表示する。 またそれぞれのディレクトリ"
"をスキャンし、 新しいリンクを生成するたびに、その内容を表示する。 メッセージ"
"抑制モードを上書きする。"

#. type: TP
#: build/C/man8/ldconfig.8:107
#, no-wrap
msgid "B<-n>"
msgstr "B<-n>"

#. type: Plain text
#: build/C/man8/ldconfig.8:118
msgid ""
"Only process directories specified on the command line.  Don't process the "
"trusted directories (I</lib> and I</usr/lib>)  nor those specified in I</etc/"
"ld.so.conf>.  Implies B<-N>."
msgstr ""
"コマンドラインで指定されたディレクトリのみを処理する。 通常共有ライブラリが置"
"かれるディレクトリ (I</lib> と I</usr/lib>)  や I</etc/ld.so.conf> で指定され"
"たディレクトリは処理しない。 暗黙のうちに B<-N> が指定される。"

#. type: TP
#: build/C/man8/ldconfig.8:118
#, no-wrap
msgid "B<-N>"
msgstr "B<-N>"

#. type: Plain text
#: build/C/man8/ldconfig.8:124
msgid ""
"Don't rebuild the cache.  Unless B<-X> is also specified, links are still "
"updated."
msgstr ""
"キャッシュを再構成しない。 同時に B<-X> が同時に指定されなければ、リンクのほ"
"うは更新される。"

#. type: TP
#: build/C/man8/ldconfig.8:124
#, no-wrap
msgid "B<-X>"
msgstr "B<-X>"

#. type: Plain text
#: build/C/man8/ldconfig.8:130
msgid ""
"Don't update links.  Unless B<-N> is also specified, the cache is still "
"rebuilt."
msgstr ""
"リンクを更新しない。 B<-N> が同時に指定されなければ、キャッシュのほうは再構成"
"される。"

#. type: TP
#: build/C/man8/ldconfig.8:130
#, no-wrap
msgid "B<-f conf>"
msgstr "B<-f conf>"

#. type: Plain text
#: build/C/man8/ldconfig.8:136
msgid "Use B<conf> instead of I</etc/ld.so.conf>."
msgstr "B<conf> を I</etc/ld.so.conf> の代わりに用いる。"

#. type: TP
#: build/C/man8/ldconfig.8:136
#, no-wrap
msgid "B<-C cache>"
msgstr "B<-C cache>"

#. type: Plain text
#: build/C/man8/ldconfig.8:142
msgid "Use B<cache> instead of I</etc/ld.so.cache>."
msgstr "B<cache> を I</etc/ld.so.cache> の代わりに用いる。"

#. type: TP
#: build/C/man8/ldconfig.8:142
#, no-wrap
msgid "B<-r root>"
msgstr "B<-r root>"

#. type: Plain text
#: build/C/man8/ldconfig.8:147
msgid "Change to and use I<root> as the root directory."
msgstr ""
"I<root> にカレントディレクトリを変更し、ここをルートディレクトリとして用い"
"る。"

#. type: TP
#: build/C/man8/ldconfig.8:147
#, no-wrap
msgid "B<-l>"
msgstr "B<-l>"

#. type: Plain text
#: build/C/man8/ldconfig.8:152
msgid ""
"Library mode.  Manually link individual libraries.  Intended for use by "
"experts only."
msgstr ""
"ライブラリモード。それぞれのライブラリを手動でリンクする。 熟練者のみが用いる"
"べきである。"

#. type: TP
#: build/C/man8/ldconfig.8:152
#, no-wrap
msgid "B<-p>"
msgstr "B<-p>"

#. type: Plain text
#: build/C/man8/ldconfig.8:156
msgid ""
"Print the lists of directories and candidate libraries stored in the current "
"cache."
msgstr ""
"現在のキャッシュに保存されているディレクトリのリストと、 ライブラリの候補を表"
"示する。"

#. type: Plain text
#: build/C/man8/ldconfig.8:161
msgid "run-time linker/loader"
msgstr "実行時リンカ/ローダー。"

#. type: TP
#: build/C/man8/ldconfig.8:161
#, no-wrap
msgid "I</etc/ld.so.conf>"
msgstr "I</etc/ld.so.conf>"

#. type: Plain text
#: build/C/man8/ldconfig.8:165
msgid ""
"File containing a list of colon, space, tab, newline, or comma-separated "
"directories in which to search for libraries."
msgstr ""
"コロン・スペース・タブ・改行・コンマで区切られたディレクトリのリスト。 それぞ"
"れのディレクトリでライブラリが検索される。"

#. type: Plain text
#: build/C/man8/ldconfig.8:174
msgid ""
"File containing an ordered list of libraries found in the directories "
"specified in I</etc/ld.so.conf>, as well as those found in I</lib> and I</"
"usr/lib>."
msgstr ""
"I</etc/ld.so.conf> で指定されたディレクトリにあるライブラリ、および I</lib> "
"と I</usr/lib> にあるライブラリの順序付きリスト。"

#. type: Plain text
#: build/C/man8/ldconfig.8:178
msgid "B<ldd>(1), B<ld.so>(8)"
msgstr "B<ldd>(1), B<ld.so>(8)"

#. type: TH
#: build/C/man1/ldd.1:10
#, no-wrap
msgid "LDD"
msgstr "LDD"

#. type: TH
#: build/C/man1/ldd.1:10
#, no-wrap
msgid "2000-10-30"
msgstr "2000-10-30"

#. type: Plain text
#: build/C/man1/ldd.1:13
msgid "ldd - print shared library dependencies"
msgstr "ldd - 共有ライブラリへの依存関係を表示する"

#. type: Plain text
#: build/C/man1/ldd.1:15
msgid "B<ldd> [OPTION]... FILE..."
msgstr "B<ldd> [OPTION]... FILE..."

#. type: Plain text
#: build/C/man1/ldd.1:19
msgid ""
"B<ldd> prints the shared libraries required by each program or shared "
"library specified on the command line."
msgstr ""
"B<ldd> はコマンドラインで指定したプログラムや共有ライブラリについて、 それぞ"
"れで必要とされる共有ライブラリを表示する。"

#. type: TP
#: build/C/man1/ldd.1:20
#, no-wrap
msgid "B<--version>"
msgstr "B<--version>"

#. type: Plain text
#: build/C/man1/ldd.1:24
msgid "Print the version number of B<ldd>."
msgstr "B<ldd> のバージョン番号を表示する。"

#. type: TP
#: build/C/man1/ldd.1:24
#, no-wrap
msgid "B<-v\\ --verbose>"
msgstr "B<-v\\ --verbose>"

#. type: Plain text
#: build/C/man1/ldd.1:28
msgid ""
"Print all information, including, for example, symbol versioning information."
msgstr "シンボルのバージョン情報などを含めた全ての情報を表示する。"

#. type: TP
#: build/C/man1/ldd.1:28
#, no-wrap
msgid "B<-u\\ --unused>"
msgstr "B<-u\\ --unused>"

#. type: Plain text
#: build/C/man1/ldd.1:32
msgid "Print unused direct dependencies.  (Since glibc 2.3.4.)"
msgstr "使用されていない直接の依存関係を表示する (glibc 2.3.4 以降)。"

#. type: TP
#: build/C/man1/ldd.1:32
#, no-wrap
msgid "B<-d\\ --data-relocs>"
msgstr "B<-d\\ --data-relocs>"

#. type: Plain text
#: build/C/man1/ldd.1:35
msgid "Perform relocations and report any missing objects (ELF only)."
msgstr ""
"リロケーションを実行し、足りないオブジェクトについてレポートする (ELF のみ)。"

#. type: TP
#: build/C/man1/ldd.1:35
#, no-wrap
msgid "B<-r\\ --function-relocs>"
msgstr "B<-r\\ --function-relocs>"

#. type: Plain text
#: build/C/man1/ldd.1:39
msgid ""
"Perform relocations for both data objects and functions, and report any "
"missing objects or functions (ELF only)."
msgstr "足りないオブジェクトや関数についてレポートする (ELF のみ)。"

#. type: TP
#: build/C/man1/ldd.1:39
#, no-wrap
msgid "B<--help>"
msgstr "B<--help>"

#. type: Plain text
#: build/C/man1/ldd.1:42
msgid "Usage information."
msgstr "使用法を表示する。"

#. type: Plain text
#: build/C/man1/ldd.1:53
msgid ""
"The standard version of B<ldd> comes with glibc2.  Libc5 came with an older "
"version, still present on some systems.  The long options are not supported "
"by the libc5 version.  On the other hand, the glibc2 version does not "
"support B<-V> and only has the equivalent B<--version>."
msgstr ""
"標準的なバージョンの B<ldd> は glibc2 に付属している。 libc5 には古いバージョ"
"ンのものが付属しており、 これが入っているシステムもまだ存在する。 libc5 バー"
"ジョンではロングオプションがサポートされていない。 一方、glibc2 バージョンで"
"は B<-V> をサポートしておらず、これと同じ意味の B<--version> しかサポートして"
"いない。"

#. type: Plain text
#: build/C/man1/ldd.1:59
msgid ""
"The libc5 version of this program will use the name of a library given on "
"the command line as-is when it contains a \\(aq/\\(aq; otherwise it searches "
"for the library in the standard locations.  To run it on a shared library in "
"the current directory, prefix the name with \"./\"."
msgstr ""
"libc5 バージョンのプログラムでは、 コマンドラインで与えられたライブラリ名に "
"\\(aq/\\(aq が含まれている場合は、ライブラリ名をそのまま用いる。 \\(aq/\\(aq "
"が含まれていない場合は、標準的なパスからライブラリを検索する。 カレントディレ"
"クトリにある共有ライブラリに対して実行するには、 名前にプレフィックス \"./\" "
"を付けること。"

#. type: Plain text
#: build/C/man1/ldd.1:62
msgid "B<ldd> does not work on a.out shared libraries."
msgstr "B<ldd> は a.out 共有ライブラリでは動作しない。"

#.  .SH AUTHOR
#.  David Engel.
#.  Roland McGrath and Ulrich Drepper.
#. type: Plain text
#: build/C/man1/ldd.1:75
msgid ""
"B<ldd> does not work with some extremely old a.out programs which were built "
"before B<ldd> support was added to the compiler releases.  If you use B<ldd> "
"on one of these programs, the program will attempt to run with I<argc> = 0 "
"and the results will be unpredictable."
msgstr ""
"B<ldd> は非常に古い a.out プログラム (B<ldd> のサポートがコンパイラに追加され"
"る以前にビルドされたようなプログラム)  では動作しない。 このようなプログラム"
"に対して B<ldd> を用いると、プログラムは I<argc> = 0 で実行される。結果は予想"
"不可能である。"

#. type: Plain text
#: build/C/man1/ldd.1:78
msgid "B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ld.so>(8), B<ldconfig>(8)"

#. type: TH
#: build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "RTLD-AUDIT"
msgstr "RTLD-AUDIT"

#. type: TH
#: build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man7/rtld-audit.7:29
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:31
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:33
msgid "B<#include E<lt>link.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:41
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined "
"by including I<E<lt>link.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:48
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:56
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:56
#, no-wrap
msgid "la_version()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:60
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:72
msgid ""
"This is the only function that I<must> be defined by an auditing library: it "
"performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports.  If necessary, the auditing library can check that this version is "
"sufficient for its requirements."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:81
msgid ""
"As its function result, this function should return the version of the "
"auditing interface that this auditing library expects to use (returning "
"I<version> is acceptable).  If the returned value is 0, or a version that is "
"greater than that supported by the dynamic linker, then the audit library is "
"ignored."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:81
#, no-wrap
msgid "la_objsearch()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:86
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:97
msgid ""
"The dynamic linker invokes this function to inform the auditing library that "
"it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:97
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:106
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:106
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:111
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:111
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:119
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:119
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:126
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:126
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:130
msgid "I<name> was found via a search of one of the default directories."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:130
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:134
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:143
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then "
"this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:143
#, no-wrap
msgid "la_activity()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:147
#, no-wrap
msgid "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:156
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head "
"of the link map.  When the dynamic linker invokes this function, I<flag> is "
"set to one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:156
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:159
msgid "New objects are being added to the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:159
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:162
msgid "Objects are being removed from the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:162
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:165
msgid "Link-map activity has been completed: the map is once again consistent."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:165
#, no-wrap
msgid "la_objopen()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:170
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:179
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:179
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:182
msgid "Link map is part of the initial namespace."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:182
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:186
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:194
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:201
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to "
"select the objects to be monitored by B<la_symbind*>():"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:201
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:204
msgid "Audit symbol bindings to this object."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:204
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:207
msgid "Audit symbol bindings from this object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:211
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:211
#, no-wrap
msgid "la_objclose()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:215
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:224
msgid ""
"The dynamic linker invokes this function after any finalization code for the "
"object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:228
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:228
#, no-wrap
msgid "la_preinit()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:232
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:242
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:242
#, no-wrap
msgid "la_symbind*()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:251
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char *>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:263
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on "
"64-bit platforms."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:273
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:278
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the "
"bound shared object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:293
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:297
msgid ""
"The I<symname> argument points a string containing the name of the symbol."
msgstr ""

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: build/C/man7/rtld-audit.7:305
msgid ""
"The I<flags> argument is a bit mask that both provides information about the "
"symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:305
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:309
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:309
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:314
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: build/C/man7/rtld-audit.7:328
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced.  "
"The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:328
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:333
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:333
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:338
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:349
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address "
"to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return "
"I<sym-E<gt>st_name>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:349
#, no-wrap
msgid "la_pltenter()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:355 build/C/man7/rtld-audit.7:415
msgid ""
"The precise name and argument types for this function depend on the hardware "
"platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)  "
"Here is the definition for x86-32:"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:361
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long int *>I<framesizep>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:365
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:375 build/C/man7/rtld-audit.7:438
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:382
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)  "
"containing the values of registers to be used for the call to this PLT entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:388
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""

#.  FIXME is the following correct?
#. type: Plain text
#: build/C/man7/rtld-audit.7:404
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used "
"to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltenter>()  "
"function is only called if this buffer is explicitly set to a suitable value."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:409
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:409
#, no-wrap
msgid "la_pltexit()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:421
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval *>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:428
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:451
msgid ""
"The I<inregs> argument points to a structure (defined in I<E<lt>link."
"hE<gt>>)  containing the values of registers used for the call to this PLT "
"entry.  The I<outregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: build/C/man7/rtld-audit.7:459
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:465
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:468
msgid ""
"Note the following differences from the Solaris dynamic linker auditing API:"
msgstr ""

#. type: IP
#: build/C/man7/rtld-audit.7:468 build/C/man7/rtld-audit.7:472
#: build/C/man7/rtld-audit.7:480
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:472
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:480
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide "
"a I<symname> argument."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:490
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:494
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:499
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): %d\\en\", version);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:502
#, no-wrap
msgid ""
"    return version;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:515
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %x\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:518
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:528
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %x; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:538
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; cookie=%x\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:541
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:546
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %x\\en\", cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:549
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:555
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %x\\en\", cookie);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:564
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %x; defcook = %x\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:567 build/C/man7/rtld-audit.7:579
#: build/C/man7/rtld-audit.7:589
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:576
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %x; defcook = %x\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:586
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long int *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, sym-E<gt>st_value);\n"
msgstr ""

#.  FIXME Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: build/C/man7/rtld-audit.7:600
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:605
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"

#~ msgid "2009-01-12"
#~ msgstr "2009-01-12"

#~ msgid "2007-12-28"
#~ msgstr "2007-12-28"

#~ msgid "B<EI_BRAND>"
#~ msgstr "B<EI_BRAND>"

#~ msgid "Start of architecture identification."
#~ msgstr "アーキテクチャ ID の開始。"

#~ msgid ""
#~ "Values less than or equal to B<PT_LOPROC> are reserved for processor-"
#~ "specific semantics."
#~ msgstr ""
#~ "この値以下で B<PT_LOPROC> 以上の値はプロセッサ固有の意味に予約されている。"

#~ msgid "B<PT_GNU_STACK>"
#~ msgstr "B<PT_GNU_STACK>"

#~ msgid ""
#~ "A section header table index is a subscript into this array.  Some "
#~ "section header table indices are reserved.  An object file does not have "
#~ "sections for these special indices:"
#~ msgstr ""
#~ "セクションヘッダテーブルインデックスは、この配列の要素を指定する。 いくつ"
#~ "かのセクションヘッダテーブルインデックスは予約されている。 オブジェクト"
#~ "ファイルは、これらの特別なインデックスに対応する セクションを持たない:"

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-01 04:38+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24
#, no-wrap
msgid "DL_ITERATE_PHDR"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24
#, no-wrap
msgid "2007-05-18"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24 build/C/man3/end.3:25 build/C/man8/ld.so.8:2 build/C/man8/ldconfig.8:22
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/dl_iterate_phdr.3:24 build/C/man3/dlopen.3:35 build/C/man5/elf.5:33 build/C/man3/end.3:25 build/C/man8/ld.so.8:2 build/C/man8/ldconfig.8:22 build/C/man1/ldd.1:10 build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:25 build/C/man3/dlopen.3:36 build/C/man5/elf.5:34 build/C/man3/end.3:26 build/C/man8/ld.so.8:3 build/C/man8/ldconfig.8:23 build/C/man1/ldd.1:11 build/C/man7/rtld-audit.7:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:27
msgid "dl_iterate_phdr - walk through list of shared objects"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:27 build/C/man3/dlopen.3:39 build/C/man5/elf.5:36 build/C/man3/end.3:28 build/C/man8/ld.so.8:5 build/C/man8/ldconfig.8:25 build/C/man1/ldd.1:13 build/C/man7/rtld-audit.7:29
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:31
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>link.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:37
#, no-wrap
msgid ""
"B<int dl_iterate_phdr(>\n"
"          B<int (*>callbackB<) (struct dl_phdr_info *>infoB<,>\n"
"                           B<size_t> sizeB<, void *>dataB<),>\n"
"          B<void *>dataB<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:38 build/C/man3/dlopen.3:51 build/C/man5/elf.5:41 build/C/man3/end.3:34 build/C/man8/ld.so.8:15 build/C/man8/ldconfig.8:54 build/C/man1/ldd.1:15 build/C/man7/rtld-audit.7:33
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:43
msgid ""
"The B<dl_iterate_phdr>()  function allows an application to inquire at run "
"time to find out which shared objects it has loaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:53
msgid ""
"The B<dl_iterate_phdr>()  function walks through the list of an "
"application's shared objects and calls the function I<callback> once for "
"each object, until either all shared objects have been processed or "
"I<callback> returns a nonzero value."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:70
msgid ""
"Each call to I<callback> receives three arguments: I<info>, which is a "
"pointer to a structure containing information about the shared object; "
"I<size>, which is the size of the structure pointed to by I<info>; and "
"I<data>, which is a copy of whatever value was passed by the calling program "
"as the second argument (also named I<data>)  in the call to "
"B<dl_iterate_phdr>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:74
msgid "The I<info> argument is a structure of the following type:"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:86
#, no-wrap
msgid ""
"struct dl_phdr_info {\n"
"    ElfW(Addr)        dlpi_addr;  /* Base address of object */\n"
"    const char       *dlpi_name;  /* (Null-terminated) name of\n"
"                                     object */\n"
"    const ElfW(Phdr) *dlpi_phdr;  /* Pointer to array of\n"
"                                     ELF program headers\n"
"                                     for this object */\n"
"    ElfW(Half)        dlpi_phnum; /* # of items in I<dlpi_phdr> */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:98
msgid ""
"(The I<ElfW>()  macro definition turns its argument into the name of an ELF "
"data type suitable for the hardware architecture.  For example, on a 32-bit "
"platform, ElfW(Addr) yields the data type name Elf32_Addr.  Further "
"information on these types can be found in the I<E<lt>elf.hE<gt>> and "
"I<E<lt>link.hE<gt>> header files.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:109
msgid ""
"The I<dlpi_addr> field indicates the base address of the shared object "
"(i.e., the difference between the virtual memory address of the shared "
"object and the offset of that object in the file from which it was loaded).  "
"The I<dlpi_name> field is a null-terminated string giving the pathname from "
"which the shared object was loaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:124
msgid ""
"To understand the meaning of the I<dlpi_phdr> and I<dlpi_phnum> fields, we "
"need to be aware that an ELF shared object consists of a number of segments, "
"each of which has a corresponding program header describing the segment.  "
"The I<dlpi_phdr> field is a pointer to an array of the program headers for "
"this shared object.  The I<dlpi_phnum> field indicates the size of this "
"array."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:126
msgid "These program headers are structures of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:139
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Word  p_type;    /* Segment type */\n"
"    Elf32_Off   p_offset;  /* Segment file offset */\n"
"    Elf32_Addr  p_vaddr;   /* Segment virtual address */\n"
"    Elf32_Addr  p_paddr;   /* Segment physical address */\n"
"    Elf32_Word  p_filesz;  /* Segment size in file */\n"
"    Elf32_Word  p_memsz;   /* Segment size in memory */\n"
"    Elf32_Word  p_flags;   /* Segment flags */\n"
"    Elf32_Word  p_align;   /* Segment alignment */\n"
"} Elf32_Phdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:145
msgid ""
"Note that we can calculate the location of a particular program header, "
"I<x>, in virtual memory using the formula:"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:148
#, no-wrap
msgid "  addr == info-E<gt>dlpi_addr + info-E<gt>dlpi_phdr[x].p_vaddr;\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:149
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:154
msgid ""
"The B<dl_iterate_phdr>()  function returns whatever value was returned by "
"the last call to I<callback>."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:154
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:157
msgid "B<dl_iterate_phdr>()  has been supported in glibc since version 2.2.4."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:157 build/C/man3/dlopen.3:381 build/C/man3/end.3:49 build/C/man7/rtld-audit.7:459
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:161
msgid ""
"The B<dl_iterate_phdr>()  function is Linux-specific and should be avoided "
"in portable applications."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:161 build/C/man3/dlopen.3:446 build/C/man3/end.3:75 build/C/man7/rtld-audit.7:490
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:166
msgid ""
"The following program displays a list of pathnames of the shared objects it "
"has loaded.  For each shared object, the program lists the virtual addresses "
"at which the object's ELF segments are loaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:172
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:177
#, no-wrap
msgid ""
"static int\n"
"callback(struct dl_phdr_info *info, size_t size, void *data)\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:180
#, no-wrap
msgid ""
"    printf(\"name=%s (%d segments)\\en\", info-E<gt>dlpi_name,\n"
"        info-E<gt>dlpi_phnum);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:186
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> info-E<gt>dlpi_phnum; j++)\n"
"         printf(\"\\et\\et header %2d: address=%10p\\en\", j,\n"
"             (void *) (info-E<gt>dlpi_addr + "
"info-E<gt>dlpi_phdr[j].p_vaddr));\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:191
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    dl_iterate_phdr(callback, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:194 build/C/man3/end.3:106
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:195 build/C/man3/dlopen.3:507 build/C/man5/elf.5:1935 build/C/man3/end.3:107 build/C/man8/ld.so.8:409 build/C/man8/ldconfig.8:175 build/C/man1/ldd.1:75 build/C/man7/rtld-audit.7:600
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:205
msgid ""
"B<ldd>(1), B<objdump>(1), B<readelf>(1), B<dlopen>(3), B<elf>(5), "
"B<ld.so>(8), and the I<Executable and Linking Format Specification> "
"available at various locations online."
msgstr ""

#. type: SH
#: build/C/man3/dl_iterate_phdr.3:205 build/C/man3/dlopen.3:515 build/C/man5/elf.5:1959 build/C/man3/end.3:112 build/C/man8/ld.so.8:419 build/C/man8/ldconfig.8:178 build/C/man1/ldd.1:78 build/C/man7/rtld-audit.7:605
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/dl_iterate_phdr.3:212 build/C/man3/dlopen.3:522 build/C/man5/elf.5:1966 build/C/man3/end.3:119 build/C/man8/ld.so.8:426 build/C/man8/ldconfig.8:185 build/C/man1/ldd.1:85 build/C/man7/rtld-audit.7:612
msgid ""
"This page is part of release 3.40 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/dlopen.3:35
#, no-wrap
msgid "DLOPEN"
msgstr ""

#. type: TH
#: build/C/man3/dlopen.3:35
#, no-wrap
msgid "2008-12-06"
msgstr ""

#. type: TH
#: build/C/man3/dlopen.3:35 build/C/man5/elf.5:33 build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:39
msgid ""
"dladdr, dlclose, dlerror, dlopen, dlsym, dlvsym - programming interface to "
"dynamic linking loader"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:41
msgid "B<#include E<lt>dlfcn.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:43
msgid "B<void *dlopen(const char *>I<filename>B<, int >I<flag>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:45
msgid "B<char *dlerror(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:47
msgid "B<void *dlsym(void *>I<handle>B<, const char *>I<symbol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:49
msgid "B<int dlclose(void *>I<handle>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:51
msgid "Link with I<-ldl>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:58
msgid ""
"The four functions B<dlopen>(), B<dlsym>(), B<dlclose>(), B<dlerror>()  "
"implement the interface to the dynamic linking loader."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:58
#, no-wrap
msgid "dlerror()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:71
msgid ""
"The function B<dlerror>()  returns a human readable string describing the "
"most recent error that occurred from B<dlopen>(), B<dlsym>()  or "
"B<dlclose>()  since the last call to B<dlerror>().  It returns NULL if no "
"errors have occurred since initialization or since it was last called."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:71
#, no-wrap
msgid "dlopen()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:89
msgid ""
"The function B<dlopen>()  loads the dynamic library file named by the "
"null-terminated string I<filename> and returns an opaque \"handle\" for the "
"dynamic library.  If I<filename> is NULL, then the returned handle is for "
"the main program.  If I<filename> contains a slash (\"/\"), then it is "
"interpreted as a (relative or absolute) pathname.  Otherwise, the dynamic "
"linker searches for the library as follows (see B<ld.so>(8)  for further "
"details):"
msgstr ""

#. type: IP
#: build/C/man3/dlopen.3:89 build/C/man3/dlopen.3:93 build/C/man3/dlopen.3:100 build/C/man3/dlopen.3:104 build/C/man3/dlopen.3:111 build/C/man8/ld.so.8:45 build/C/man8/ld.so.8:50 build/C/man8/ld.so.8:55 build/C/man8/ld.so.8:59 build/C/man8/ld.so.8:69
#, no-wrap
msgid "o"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:93
msgid ""
"(ELF only) If the executable file for the calling program contains a "
"DT_RPATH tag, and does not contain a DT_RUNPATH tag, then the directories "
"listed in the DT_RPATH tag are searched."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:100
msgid ""
"If, at the time that the program was started, the environment variable "
"B<LD_LIBRARY_PATH> was defined to contain a colon-separated list of "
"directories, then these are searched.  (As a security measure this variable "
"is ignored for set-user-ID and set-group-ID programs.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:104
msgid ""
"(ELF only) If the executable file for the calling program contains a "
"DT_RUNPATH tag, then the directories listed in that tag are searched."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:111
msgid ""
"The cache file I</etc/ld.so.cache> (maintained by B<ldconfig>(8))  is "
"checked to see whether it contains an entry for I<filename>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:117
msgid "The directories I</lib> and I</usr/lib> are searched (in that order)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:123
msgid ""
"If the library has dependencies on other shared libraries, then these are "
"also automatically loaded by the dynamic linker using the same rules.  (This "
"process may occur recursively, if those libraries in turn have dependencies, "
"and so on.)"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:126
msgid "One of the following two values must be included in I<flag>:"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:126
#, no-wrap
msgid "B<RTLD_LAZY>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:134
msgid ""
"Perform lazy binding.  Only resolve symbols as the code that references them "
"is executed.  If the symbol is never referenced, then it is never resolved.  "
"(Lazy binding is only performed for function references; references to "
"variables are always immediately bound when the library is loaded.)"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:134
#, no-wrap
msgid "B<RTLD_NOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:143
msgid ""
"If this value is specified, or the environment variable B<LD_BIND_NOW> is "
"set to a nonempty string, all undefined symbols in the library are resolved "
"before B<dlopen>()  returns.  If this cannot be done, an error is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:146
msgid "Zero or more of the following values may also be ORed in I<flag>:"
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:146
#, no-wrap
msgid "B<RTLD_GLOBAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:150
msgid ""
"The symbols defined by this library will be made available for symbol "
"resolution of subsequently loaded libraries."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:150
#, no-wrap
msgid "B<RTLD_LOCAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:157
msgid ""
"This is the converse of B<RTLD_GLOBAL>, and the default if neither flag is "
"specified.  Symbols defined in this library are not made available to "
"resolve references in subsequently loaded libraries."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:157
#, no-wrap
msgid "B<RTLD_NODELETE> (since glibc 2.2)"
msgstr ""

#.  (But it is present on Solaris.)
#. type: Plain text
#: build/C/man3/dlopen.3:167
msgid ""
"Do not unload the library during B<dlclose>().  Consequently, the library's "
"static variables are not reinitialized if the library is reloaded with "
"B<dlopen>()  at a later time.  This flag is not specified in POSIX.1-2001."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:167
#, no-wrap
msgid "B<RTLD_NOLOAD> (since glibc 2.2)"
msgstr ""

#.  (But it is present on Solaris.)
#. type: Plain text
#: build/C/man3/dlopen.3:182
msgid ""
"Don't load the library.  This can be used to test if the library is already "
"resident (B<dlopen>()  returns NULL if it is not, or the library's handle if "
"it is resident).  This flag can also be used to promote the flags on a "
"library that is already loaded.  For example, a library that was previously "
"loaded with B<RTLD_LOCAL> can be reopened with B<RTLD_NOLOAD\\ |\\ "
"RTLD_GLOBAL>.  This flag is not specified in POSIX.1-2001."
msgstr ""

#. type: TP
#: build/C/man3/dlopen.3:182
#, no-wrap
msgid "B<RTLD_DEEPBIND> (since glibc 2.3.4)"
msgstr ""

#.  Inimitably described by UD in
#.  http://sources.redhat.com/ml/libc-hacker/2004-09/msg00083.html.
#. type: Plain text
#: build/C/man3/dlopen.3:192
msgid ""
"Place the lookup scope of the symbols in this library ahead of the global "
"scope.  This means that a self-contained library will use its own symbols in "
"preference to global symbols with the same name contained in libraries that "
"have already been loaded.  This flag is not specified in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:204
msgid ""
"If I<filename> is a NULL pointer, then the returned handle is for the main "
"program.  When given to B<dlsym>(), this handle causes a search for a symbol "
"in the main program, followed by all shared libraries loaded at program "
"startup, and then all shared libraries loaded by B<dlopen>()  with the flag "
"B<RTLD_GLOBAL>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:214
msgid ""
"External references in the library are resolved using the libraries in that "
"library's dependency list and any other libraries previously opened with the "
"B<RTLD_GLOBAL> flag.  If the executable was linked with the flag "
"\"-rdynamic\" (or, synonymously, \"--export-dynamic\"), then the global "
"symbols in the executable will also be used to resolve references in a "
"dynamically loaded library."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:232
msgid ""
"If the same library is loaded again with B<dlopen>(), the same file handle "
"is returned.  The dl library maintains reference counts for library handles, "
"so a dynamic library is not deallocated until B<dlclose>()  has been called "
"on it as many times as B<dlopen>()  has succeeded on it.  The B<_init>()  "
"routine, if present, is only called once.  But a subsequent call with "
"B<RTLD_NOW> may force symbol resolution for a library earlier loaded with "
"B<RTLD_LAZY>."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:236
msgid "If B<dlopen>()  fails for any reason, it returns NULL."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:236
#, no-wrap
msgid "dlsym()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:265
msgid ""
"The function B<dlsym>()  takes a \"handle\" of a dynamic library returned by "
"B<dlopen>()  and the null-terminated symbol name, returning the address "
"where that symbol is loaded into memory.  If the symbol is not found, in the "
"specified library or any of the libraries that were automatically loaded by "
"B<dlopen>()  when that library was loaded, B<dlsym>()  returns NULL.  (The "
"search performed by B<dlsym>()  is breadth first through the dependency tree "
"of these libraries.)  Since the value of the symbol could actually be NULL "
"(so that a NULL return from B<dlsym>()  need not indicate an error), the "
"correct way to test for an error is to call B<dlerror>()  to clear any old "
"error conditions, then call B<dlsym>(), and then call B<dlerror>()  again, "
"saving its return value into a variable, and check whether this saved value "
"is not NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:277
msgid ""
"There are two special pseudo-handles, B<RTLD_DEFAULT> and B<RTLD_NEXT>.  The "
"former will find the first occurrence of the desired symbol using the "
"default library search order.  The latter will find the next occurrence of a "
"function in the search order after the current library.  This allows one to "
"provide a wrapper around a function in another shared library."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:277
#, no-wrap
msgid "dlclose()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:284
msgid ""
"The function B<dlclose>()  decrements the reference count on the dynamic "
"library handle I<handle>.  If the reference count drops to zero and no other "
"loaded libraries use symbols in it, then the dynamic library is unloaded."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:288
msgid "The function B<dlclose>()  returns 0 on success, and nonzero on error."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:288
#, no-wrap
msgid "The obsolete symbols _init() and _fini()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:306
msgid ""
"The linker recognizes special symbols B<_init> and B<_fini>.  If a dynamic "
"library exports a routine named B<_init>(), then that code is executed after "
"the loading, before B<dlopen>()  returns.  If the dynamic library exports a "
"routine named B<_fini>(), then that routine is called just before the "
"library is unloaded.  In case you need to avoid linking against the system "
"startup files, this can be done by using the B<gcc>(1)  I<-nostartfiles> "
"command-line option."
msgstr ""

#.  void _init(void) __attribute__((constructor));
#.  void _fini(void) __attribute__((destructor));
#. type: Plain text
#: build/C/man3/dlopen.3:317
msgid ""
"Using these routines, or the gcc B<-nostartfiles> or B<-nostdlib> options, "
"is not recommended.  Their use may result in undesired behavior, since the "
"constructor/destructor routines will not be executed (unless special "
"measures are taken)."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:329
msgid ""
"Instead, libraries should export routines using the "
"B<__attribute__((constructor))> and B<__attribute__((destructor))> function "
"attributes.  See the gcc info pages for information on these.  Constructor "
"routines are executed before B<dlopen>()  returns, and destructor routines "
"are executed before B<dlclose>()  returns."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:329
#, no-wrap
msgid "Glibc extensions: dladdr() and dlvsym()"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:331
msgid "Glibc adds two functions not described by POSIX, with prototypes"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:335
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>dlfcn.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:337
#, no-wrap
msgid "B<int dladdr(void *>I<addr>B<, Dl_info *>I<info>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:339
#, no-wrap
msgid ""
"B<void *dlvsym(void *>I<handle>B<, char *>I<symbol>B<, char "
"*>I<version>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:348
msgid ""
"The function B<dladdr>()  takes a function pointer and tries to resolve name "
"and file where it is located.  Information is stored in the I<Dl_info> "
"structure:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:361
#, no-wrap
msgid ""
"typedef struct {\n"
"    const char *dli_fname;  /* Pathname of shared object that\n"
"                               contains address */\n"
"    void       *dli_fbase;  /* Address at which shared object\n"
"                               is loaded */\n"
"    const char *dli_sname;  /* Name of nearest symbol with address\n"
"                               lower than I<addr> */\n"
"    void       *dli_saddr;  /* Exact address of symbol named\n"
"                               in I<dli_sname> */\n"
"} Dl_info;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:371
msgid ""
"If no symbol matching I<addr> could be found, then I<dli_sname> and "
"I<dli_saddr> are set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:374
msgid "B<dladdr>()  returns 0 on error, and nonzero on success."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:381
msgid ""
"The function B<dlvsym>(), provided by glibc since version 2.1, does the same "
"as B<dlsym>()  but takes a version string as an additional argument."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:388
msgid ""
"POSIX.1-2001 describes B<dlclose>(), B<dlerror>(), B<dlopen>(), and "
"B<dlsym>()."
msgstr ""

#. type: SH
#: build/C/man3/dlopen.3:388 build/C/man5/elf.5:1908 build/C/man3/end.3:52 build/C/man8/ld.so.8:403 build/C/man1/ldd.1:42 build/C/man7/rtld-audit.7:465
#, no-wrap
msgid "NOTES"
msgstr ""

#.  .LP
#.  The string returned by
#.  .BR dlerror ()
#.  should not be modified.
#.  Some systems give the prototype as
#.  .sp
#.  .in +5
#.  .B "const char *dlerror(void);"
#.  .in
#. type: Plain text
#: build/C/man3/dlopen.3:407
msgid ""
"The symbols B<RTLD_DEFAULT> and B<RTLD_NEXT> are defined by "
"I<E<lt>dlfcn.hE<gt>> only when B<_GNU_SOURCE> was defined before including "
"it."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:412
msgid ""
"Since glibc 2.2.3, B<atexit>(3)  can be used to register an exit handler "
"that is automatically called when a library is unloaded."
msgstr ""

#. type: SS
#: build/C/man3/dlopen.3:412
#, no-wrap
msgid "History"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:418
msgid ""
"The dlopen interface standard comes from SunOS.  That system also has "
"B<dladdr>(), but not B<dlvsym>()."
msgstr ""

#. type: SH
#: build/C/man3/dlopen.3:418 build/C/man1/ldd.1:59 build/C/man7/rtld-audit.7:590
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:430
msgid ""
"Sometimes, the function pointers you pass to B<dladdr>()  may surprise you.  "
"On some architectures (notably i386 and x86_64), I<dli_fname> and "
"I<dli_fbase> may end up pointing back at the object from which you called "
"B<dladdr>(), even if the function used as an argument should come from a "
"dynamically linked library."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:446
msgid ""
"The problem is that the function pointer will still be resolved at compile "
"time, but merely point to the I<plt> (Procedure Linkage Table)  section of "
"the original object (which dispatches the call after asking the dynamic "
"linker to resolve the symbol).  To work around this, you can try to compile "
"the code to be position-independent: then, the compiler cannot prepare the "
"pointer at compile time anymore and today's B<gcc>(1)  will generate code "
"that just loads the final symbol address from the I<got> (Global Offset "
"Table) at run time before passing it to B<dladdr>()."
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:448
msgid "Load the math library, and print the cosine of 2.0:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:453
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>dlfcn.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:460
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    void *handle;\n"
"    double (*cosine)(double);\n"
"    char *error;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:466
#, no-wrap
msgid ""
"    handle = dlopen(\"libm.so\", RTLD_LAZY);\n"
"    if (!handle) {\n"
"        fprintf(stderr, \"%s\\en\", dlerror());\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:468
#, no-wrap
msgid "    dlerror();    /* Clear any existing error */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:475
#, no-wrap
msgid ""
"    /* Writing: cosine = (double (*)(double)) dlsym(handle, \"cos\");\n"
"       would seem more natural, but the C99 standard leaves\n"
"       casting from \"void *\" to a function pointer undefined.\n"
"       The assignment used below is the POSIX.1-2003 (Technical\n"
"       Corrigendum 1) workaround; see the Rationale for the\n"
"       POSIX specification of dlsym(). */\n"
msgstr ""

#.  But in fact "gcc -O2 -Wall" will complain about the preceding cast.
#. type: Plain text
#: build/C/man3/dlopen.3:478
#, no-wrap
msgid "    *(void **) (&cosine) = dlsym(handle, \"cos\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:483
#, no-wrap
msgid ""
"    if ((error = dlerror()) != NULL)  {\n"
"        fprintf(stderr, \"%s\\en\", error);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:488
#, no-wrap
msgid ""
"    printf(\"%f\\en\", (*cosine)(2.0));\n"
"    dlclose(handle);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:492
msgid ""
"If this program were in a file named \"foo.c\", you would build the program "
"with the following command:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:495
#, no-wrap
msgid "    gcc -rdynamic -o foo foo.c -ldl\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:503
msgid ""
"Libraries exporting B<_init>()  and B<_fini>()  will want to be compiled as "
"follows, using I<bar.c> as the example name:"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:506
#, no-wrap
msgid "    gcc -shared -nostartfiles -o bar bar.c\n"
msgstr ""

#. type: Plain text
#: build/C/man3/dlopen.3:515
msgid ""
"B<ld>(1), B<ldd>(1), B<dl_iterate_phdr>(3), B<rtld-audit>(7), B<ld.so>(8), "
"B<ldconfig>(8), ld.so info pages, gcc info pages, ld info pages"
msgstr ""

#. type: TH
#: build/C/man5/elf.5:33
#, no-wrap
msgid "ELF"
msgstr ""

#. type: TH
#: build/C/man5/elf.5:33
#, no-wrap
msgid "2010-06-19"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:36
msgid "elf - format of Executable and Linking Format (ELF) files"
msgstr ""

#.  .B #include <elf_abi.h>
#. type: Plain text
#: build/C/man5/elf.5:40
#, no-wrap
msgid "B<#include E<lt>elf.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:48
msgid ""
"The header file I<E<lt>elf.hE<gt>> defines the format of ELF executable "
"binary files.  Amongst these files are normal executable files, relocatable "
"object files, core files and shared libraries."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:57
msgid ""
"An executable file using the ELF file format consists of an ELF header, "
"followed by a program header table or a section header table, or both.  The "
"ELF header is always at offset zero of the file.  The program header table "
"and the section header table's offset in the file are defined in the ELF "
"header.  The two tables describe the rest of the particularities of the "
"file."
msgstr ""

#.  Applications which wish to process ELF binary files for their native
#.  architecture only should include
#.  .I <elf_abi.h>
#.  in their source code.
#.  These applications should need to refer to
#.  all the types and structures by their generic names
#.  "Elf_xxx"
#.  and to the macros by
#.  ELF_xxx".
#.  Applications written this way can be compiled on any architecture,
#.  regardless of whether the host is 32-bit or 64-bit.
#.  .PP
#.  Should an application need to process ELF files of an unknown
#.  architecture, then the application needs to explicitly use either
#.  "Elf32_xxx"
#.  or
#.  "Elf64_xxx"
#.  type and structure names.
#.  Likewise, the macros need to be identified by
#.  "ELF32_xxx"
#.  or
#.  "ELF64_xxx".
#.  .PP
#. type: Plain text
#: build/C/man5/elf.5:84
msgid ""
"This header file describes the above mentioned headers as C structures and "
"also includes structures for dynamic sections, relocation sections and "
"symbol tables."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:96
msgid ""
"The following types are used for N-bit architectures (N=32,64, I<ElfN> "
"stands for I<Elf32> or I<Elf64>, I<uintN_t> stands for I<uint32_t> or "
"I<uint64_t>):"
msgstr ""

#.  Elf32_Size  Unsigned object size
#. type: Plain text
#: build/C/man5/elf.5:110
#, no-wrap
msgid ""
"ElfN_Addr       Unsigned program address, uintN_t\n"
"ElfN_Off        Unsigned file offset, uintN_t\n"
"ElfN_Section    Unsigned section index, uint16_t\n"
"ElfN_Versym     Unsigned version symbol information, uint16_t\n"
"Elf_Byte        unsigned char\n"
"ElfN_Half       uint16_t\n"
"ElfN_Sword      int32_t\n"
"ElfN_Word       uint32_t\n"
"ElfN_Sxword     int64_t\n"
"ElfN_Xword      uint64_t\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:125
msgid ""
"(Note: The *BSD terminology is a bit different.  There I<Elf64_Half> is "
"twice as large as I<Elf32_Half>, and I<Elf64Quarter> is used for "
"I<uint16_t>.  In order to avoid confusion these types are replaced by "
"explicit ones in the below.)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:132
msgid ""
"All data structures that the file format defines follow the \"natural\" size "
"and alignment guidelines for the relevant class.  If necessary, data "
"structures contain explicit padding to ensure 4-byte alignment for 4-byte "
"objects, to force structure sizes to a multiple of 4, etc."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:137
msgid "The ELF header is described by the type I<Elf32_Ehdr> or I<Elf64_Ehdr>:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:141
#, no-wrap
msgid "#define EI_NIDENT 16\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:158
#, no-wrap
msgid ""
"typedef struct {\n"
"    unsigned char e_ident[EI_NIDENT];\n"
"    uint16_t      e_type;\n"
"    uint16_t      e_machine;\n"
"    uint32_t      e_version;\n"
"    ElfN_Addr     e_entry;\n"
"    ElfN_Off      e_phoff;\n"
"    ElfN_Off      e_shoff;\n"
"    uint32_t      e_flags;\n"
"    uint16_t      e_ehsize;\n"
"    uint16_t      e_phentsize;\n"
"    uint16_t      e_phnum;\n"
"    uint16_t      e_shentsize;\n"
"    uint16_t      e_shnum;\n"
"    uint16_t      e_shstrndx;\n"
"} ElfN_Ehdr;\n"
msgstr ""

#.  .Bl -tag -width "e_phentsize"
#. type: Plain text
#: build/C/man5/elf.5:163
msgid "The fields have the following meanings:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:163
#, no-wrap
msgid "I<e_ident>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:173
msgid ""
"This array of bytes specifies to interpret the file, independent of the "
"processor or the file's remaining contents.  Within this array everything is "
"named by macros, which start with the prefix B<EI_> and may contain values "
"which start with the prefix B<ELF>.  The following macros are defined:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:175
#, no-wrap
msgid "B<EI_MAG0>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:181
msgid ""
"The first byte of the magic number.  It must be filled with B<ELFMAG0>.  (0: "
"0x7f)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:181
#, no-wrap
msgid "B<EI_MAG1>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:187
msgid ""
"The second byte of the magic number.  It must be filled with B<ELFMAG1>.  "
"(1: \\(aqE\\(aq)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:187
#, no-wrap
msgid "B<EI_MAG2>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:193
msgid ""
"The third byte of the magic number.  It must be filled with B<ELFMAG2>.  (2: "
"\\(aqL\\(aq)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:193
#, no-wrap
msgid "B<EI_MAG3>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:199
msgid ""
"The fourth byte of the magic number.  It must be filled with B<ELFMAG3>.  "
"(3: \\(aqF\\(aq)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:199
#, no-wrap
msgid "B<EI_CLASS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:202
msgid "The fifth byte identifies the architecture for this binary:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:204
#, no-wrap
msgid "B<ELFCLASSNONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:208
msgid "This class is invalid."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:208
#, no-wrap
msgid "B<ELFCLASS32>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:213
msgid ""
"This defines the 32-bit architecture.  It supports machines with files and "
"virtual address spaces up to 4 Gigabytes."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:213
#, no-wrap
msgid "B<ELFCLASS64>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:216
msgid "This defines the 64-bit architecture."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:219
#, no-wrap
msgid "B<EI_DATA>"
msgstr ""

#.  .Bl -tag -width "ELFDATA2LSB" -compact
#. type: Plain text
#: build/C/man5/elf.5:225
msgid ""
"The sixth byte specifies the data encoding of the processor-specific data in "
"the file.  Currently these encodings are supported:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:226
#, no-wrap
msgid "B<ELFDATANONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:230
msgid "Unknown data format."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:230
#, no-wrap
msgid "B<ELFDATA2LSB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:233
msgid "Two's complement, little-endian."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:233
#, no-wrap
msgid "B<ELFDATA2MSB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:236
msgid "Two's complement, big-endian."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:239
#, no-wrap
msgid "B<EI_VERSION>"
msgstr ""

#.  .Bl -tag -width "EV_CURRENT" -compact
#. type: Plain text
#: build/C/man5/elf.5:244
msgid "The version number of the ELF specification:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:245 build/C/man5/elf.5:498
#, no-wrap
msgid "B<EV_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:248 build/C/man5/elf.5:502
msgid "Invalid version."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:248 build/C/man5/elf.5:502
#, no-wrap
msgid "B<EV_CURRENT>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:251 build/C/man5/elf.5:506
msgid "Current version."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:254
#, no-wrap
msgid "B<EI_OSABI>"
msgstr ""

#.  .Bl -tag -width "ELFOSABI_STANDALONE" -compact
#. type: Plain text
#: build/C/man5/elf.5:263
msgid ""
"This byte identifies the operating system and ABI to which the object is "
"targeted.  Some fields in other ELF structures have flags and values that "
"have platform-specific meanings; the interpretation of those fields is "
"determined by the value of this byte.  E.g.:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:264
#, no-wrap
msgid "B<ELFOSABI_NONE>"
msgstr ""

#.  0
#. type: Plain text
#: build/C/man5/elf.5:269
msgid "Same as ELFOSABI_SYSV"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:269
#, no-wrap
msgid "B<ELFOSABI_SYSV>"
msgstr ""

#.  0
#.  synonym: ELFOSABI_NONE
#. type: Plain text
#: build/C/man5/elf.5:274
msgid "UNIX System V ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:274
#, no-wrap
msgid "B<ELFOSABI_HPUX>"
msgstr ""

#.  1
#. type: Plain text
#: build/C/man5/elf.5:278
msgid "HP-UX ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:278
#, no-wrap
msgid "B<ELFOSABI_NETBSD>"
msgstr ""

#.  2
#. type: Plain text
#: build/C/man5/elf.5:282
msgid "NetBSD ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:282
#, no-wrap
msgid "B<ELFOSABI_LINUX>"
msgstr ""

#.  3
#.  .TP
#.  .BR ELFOSABI_HURD
#.  Hurd ABI.
#.  4
#.  .TP
#.  .BR ELFOSABI_86OPEN
#.  86Open Common IA32 ABI.
#.  5
#. type: Plain text
#: build/C/man5/elf.5:294
msgid "Linux ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:294
#, no-wrap
msgid "B<ELFOSABI_SOLARIS>"
msgstr ""

#.  6
#.  .TP
#.  .BR ELFOSABI_MONTEREY
#.  Monterey project ABI. Now replaced by
#.  ELFOSABI_AIX
#.  7
#. type: Plain text
#: build/C/man5/elf.5:303
msgid "Solaris ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:303
#, no-wrap
msgid "B<ELFOSABI_IRIX>"
msgstr ""

#.  8
#. type: Plain text
#: build/C/man5/elf.5:307
msgid "IRIX ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:307
#, no-wrap
msgid "B<ELFOSABI_FREEBSD>"
msgstr ""

#.  9
#. type: Plain text
#: build/C/man5/elf.5:311
msgid "FreeBSD ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:311
#, no-wrap
msgid "B<ELFOSABI_TRU64>"
msgstr ""

#.  10
#.  ELFOSABI_MODESTO
#.  11
#.  ELFOSABI_OPENBSD
#.  12
#. type: Plain text
#: build/C/man5/elf.5:319
msgid "TRU64 UNIX ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:319
#, no-wrap
msgid "B<ELFOSABI_ARM>"
msgstr ""

#.  97
#. type: Plain text
#: build/C/man5/elf.5:323
msgid "ARM architecture ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:323
#, no-wrap
msgid "B<ELFOSABI_STANDALONE>"
msgstr ""

#.  255
#.  .El
#. type: Plain text
#: build/C/man5/elf.5:328
msgid "Stand-alone (embedded) ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:330
#, no-wrap
msgid "B<EI_ABIVERSION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:340
msgid ""
"This byte identifies the version of the ABI to which the object is "
"targeted.  This field is used to distinguish among incompatible versions of "
"an ABI.  The interpretation of this version number is dependent on the ABI "
"identified by the B<EI_OSABI> field.  Applications conforming to this "
"specification use the value 0."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:340
#, no-wrap
msgid "B<EI_PAD>"
msgstr ""

#.  As reported by Yuri Kozlov and confirmed by Mike Frysinger, EI_BRAND is
#.  not in GABI (http://www.sco.com/developers/gabi/latest/ch4.eheader.html)
#.  It looks to be a BSDism
#.  .TP
#.  .BR EI_BRAND
#.  Start of architecture identification.
#. type: Plain text
#: build/C/man5/elf.5:356
msgid ""
"Start of padding.  These bytes are reserved and set to zero.  Programs which "
"read them should ignore them.  The value for B<EI_PAD> will change in the "
"future if currently unused bytes are given meanings."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:356
#, no-wrap
msgid "B<EI_NIDENT>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:362
msgid "The size of the I<e_ident> array."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:363
#, no-wrap
msgid "I<e_type>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:366
msgid "This member of the structure identifies the object file type:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:368
#, no-wrap
msgid "B<ET_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:372
msgid "An unknown type."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:372
#, no-wrap
msgid "B<ET_REL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:375
msgid "A relocatable file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:375
#, no-wrap
msgid "B<ET_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:378
msgid "An executable file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:378
#, no-wrap
msgid "B<ET_DYN>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:381
msgid "A shared object."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:381
#, no-wrap
msgid "B<ET_CORE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:384
msgid "A core file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:387
#, no-wrap
msgid "I<e_machine>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:391
msgid ""
"This member specifies the required architecture for an individual file.  "
"E.g.:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:393
#, no-wrap
msgid "B<EM_NONE>"
msgstr ""

#.  0
#. type: Plain text
#: build/C/man5/elf.5:398
msgid "An unknown machine."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:398
#, no-wrap
msgid "B<EM_M32>"
msgstr ""

#.  1
#. type: Plain text
#: build/C/man5/elf.5:402
msgid "AT&T WE 32100."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:402
#, no-wrap
msgid "B<EM_SPARC>"
msgstr ""

#.  2
#. type: Plain text
#: build/C/man5/elf.5:406
msgid "Sun Microsystems SPARC."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:406
#, no-wrap
msgid "B<EM_386>"
msgstr ""

#.  3
#. type: Plain text
#: build/C/man5/elf.5:410
msgid "Intel 80386."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:410
#, no-wrap
msgid "B<EM_68K>"
msgstr ""

#.  4
#. type: Plain text
#: build/C/man5/elf.5:414
msgid "Motorola 68000."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:414
#, no-wrap
msgid "B<EM_88K>"
msgstr ""

#.  5
#.  .TP
#.  .BR EM_486
#.  Intel 80486.
#.  6
#. type: Plain text
#: build/C/man5/elf.5:422
msgid "Motorola 88000."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:422
#, no-wrap
msgid "B<EM_860>"
msgstr ""

#.  7
#. type: Plain text
#: build/C/man5/elf.5:426
msgid "Intel 80860."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:426
#, no-wrap
msgid "B<EM_MIPS>"
msgstr ""

#.  8
#.  EM_S370
#.  9
#.  .TP
#.  .BR EM_MIPS_RS4_BE
#.  MIPS RS4000 (big-endian only). Deprecated.
#.  10
#.  EM_MIPS_RS3_LE (MIPS R3000 little-endian)
#.  10
#. type: Plain text
#: build/C/man5/elf.5:438
msgid "MIPS RS3000 (big-endian only)."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:438
#, no-wrap
msgid "B<EM_PARISC>"
msgstr ""

#.  15
#. type: Plain text
#: build/C/man5/elf.5:442
msgid "HP/PA."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:442
#, no-wrap
msgid "B<EM_SPARC32PLUS>"
msgstr ""

#.  18
#. type: Plain text
#: build/C/man5/elf.5:446
msgid "SPARC with enhanced instruction set."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:446
#, no-wrap
msgid "B<EM_PPC>"
msgstr ""

#.  20
#. type: Plain text
#: build/C/man5/elf.5:450
msgid "PowerPC."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:450
#, no-wrap
msgid "B<EM_PPC64>"
msgstr ""

#.  21
#. type: Plain text
#: build/C/man5/elf.5:454
msgid "PowerPC 64-bit."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:454
#, no-wrap
msgid "B<EM_S390>"
msgstr ""

#.  22
#. type: Plain text
#: build/C/man5/elf.5:458
msgid "IBM S/390"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:458
#, no-wrap
msgid "B<EM_ARM>"
msgstr ""

#.  40
#. type: Plain text
#: build/C/man5/elf.5:462
msgid "Advanced RISC Machines"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:462
#, no-wrap
msgid "B<EM_SH>"
msgstr ""

#.  42
#. type: Plain text
#: build/C/man5/elf.5:466
msgid "Renesas SuperH"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:466
#, no-wrap
msgid "B<EM_SPARCV9>"
msgstr ""

#.  43
#. type: Plain text
#: build/C/man5/elf.5:470
msgid "SPARC v9 64-bit."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:470
#, no-wrap
msgid "B<EM_IA_64>"
msgstr ""

#.  50
#. type: Plain text
#: build/C/man5/elf.5:474
msgid "Intel Itanium"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:474
#, no-wrap
msgid "B<EM_X86_64>"
msgstr ""

#.  62
#. type: Plain text
#: build/C/man5/elf.5:478
msgid "AMD x86-64"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:478
#, no-wrap
msgid "B<EM_VAX>"
msgstr ""

#.  75
#.  EM_CRIS
#.  76
#.  .TP
#.  .BR EM_ALPHA
#.  Compaq [DEC] Alpha.
#.  .TP
#.  .BR EM_ALPHA_EXP
#.  Compaq [DEC] Alpha with enhanced instruction set.
#. type: Plain text
#: build/C/man5/elf.5:490
msgid "DEC Vax."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:493
#, no-wrap
msgid "I<e_version>"
msgstr ""

#.  .Bl -tag -width "EV_CURRENT" -compact
#. type: Plain text
#: build/C/man5/elf.5:497
msgid "This member identifies the file version:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:508
#, no-wrap
msgid "I<e_entry>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:514
msgid ""
"This member gives the virtual address to which the system first transfers "
"control, thus starting the process.  If the file has no associated entry "
"point, this member holds zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:514
#, no-wrap
msgid "I<e_phoff>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:519
msgid ""
"This member holds the program header table's file offset in bytes.  If the "
"file has no program header table, this member holds zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:519
#, no-wrap
msgid "I<e_shoff>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:524
msgid ""
"This member holds the section header table's file offset in bytes.  If the "
"file has no section header table this member holds zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:524
#, no-wrap
msgid "I<e_flags>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:529
msgid ""
"This member holds processor-specific flags associated with the file.  Flag "
"names take the form EF_`machine_flag'.  Currently no flags have been "
"defined."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:529
#, no-wrap
msgid "I<e_ehsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:532
msgid "This member holds the ELF header's size in bytes."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:532
#, no-wrap
msgid "I<e_phentsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:536
msgid ""
"This member holds the size in bytes of one entry in the file's program "
"header table; all entries are the same size."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:536
#, no-wrap
msgid "I<e_phnum>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:549
msgid ""
"This member holds the number of entries in the program header table.  Thus "
"the product of I<e_phentsize> and I<e_phnum> gives the table's size in "
"bytes.  If a file has no program header, I<e_phnum> holds the value zero."
msgstr ""

#.  This is a Linux extension, added in Linux 2.6.34.
#.  .Bl -tag -width "PN_XNUM"
#. type: Plain text
#: build/C/man5/elf.5:563
msgid ""
"If the number of entries in the program header table is larger than or equal "
"to B<PN_XNUM> (0xffff), this member holds B<PN_XNUM> (0xffff) and the real "
"number of entries in the program header table is held in the I<sh_info> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_info> member of the initial entry contains the value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:564
#, no-wrap
msgid "B<PN_XNUM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:569
msgid ""
"This is defined as 0xffff, the largest number I<e_phnum> can have, "
"specifying where the actual number of program headers is assigned."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:573
#, no-wrap
msgid "I<e_shentsize>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:578
msgid ""
"This member holds a sections header's size in bytes.  A section header is "
"one entry in the section header table; all entries are the same size."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:578
#, no-wrap
msgid "I<e_shnum>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:591
msgid ""
"This member holds the number of entries in the section header table.  Thus "
"the product of I<e_shentsize> and I<e_shnum> gives the section header "
"table's size in bytes.  If a file has no section header table, I<e_shnum> "
"holds the value of zero."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:603
msgid ""
"If the number of entries in the section header table is larger than or equal "
"to B<SHN_LORESERVE> (0xff00), I<e_shnum> holds the value zero and the real "
"number of entries in the section header table is held in the I<sh_size> "
"member of the initial entry in section header table.  Otherwise, the "
"I<sh_size> member of the initial entry in the section header table holds the "
"value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:603
#, no-wrap
msgid "I<e_shstrndx>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:610
msgid ""
"This member holds the section header table index of the entry associated "
"with the section name string table.  If the file has no section name string "
"table, this member holds the value B<SHN_UNDEF>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:621
msgid ""
"If the index of section name string table section is larger than or equal to "
"B<SHN_LORESERVE> (0xff00), this member holds B<SHN_XINDEX> (0xffff) and the "
"real index of the section name string table section is held in the "
"I<sh_link> member of the initial entry in section header table. Otherwise, "
"the I<sh_link> member of the initial entry in section header table contains "
"the value zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:623 build/C/man5/elf.5:910
#, no-wrap
msgid "B<SHN_UNDEF>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:632
msgid ""
"This value marks an undefined, missing, irrelevant, or otherwise meaningless "
"section reference.  For example, a symbol \"defined\" relative to section "
"number B<SHN_UNDEF> is an undefined symbol."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:632 build/C/man5/elf.5:914
#, no-wrap
msgid "B<SHN_LORESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:635 build/C/man5/elf.5:917
msgid "This value specifies the lower bound of the range of reserved indices."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:635 build/C/man5/elf.5:917
#, no-wrap
msgid "B<SHN_LOPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:640 build/C/man5/elf.5:922
msgid ""
"Values greater than or equal to B<SHN_HIPROC> are reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:640 build/C/man5/elf.5:922
#, no-wrap
msgid "B<SHN_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:645 build/C/man5/elf.5:927
msgid ""
"Values less than or equal to B<SHN_LOPROC> are reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:645 build/C/man5/elf.5:927
#, no-wrap
msgid "B<SHN_ABS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:652
msgid ""
"This value specifies absolute values for the corresponding reference.  For "
"example, symbols defined relative to section number B<SHN_ABS> have absolute "
"values and are not affected by relocation."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:652 build/C/man5/elf.5:934
#, no-wrap
msgid "B<SHN_COMMON>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:656
msgid ""
"Symbols defined relative to this section are common symbols, such as Fortran "
"COMMON or unallocated C external variables."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:656 build/C/man5/elf.5:938
#, no-wrap
msgid "B<SHN_HIRESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:669
msgid ""
"This value specifies the upper bound of the range of reserved indices "
"between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, inclusive; the values do not "
"reference the section header table.  That is, the section header table does "
"I<not> contain entries for the reserved indices."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:691
msgid ""
"An executable or shared object file's program header table is an array of "
"structures, each describing a segment or other information the system needs "
"to prepare the program for execution.  An object file I<segment> contains "
"one or more I<sections>.  Program headers are meaningful only for executable "
"and shared object files.  A file specifies its own program header size with "
"the ELF header's I<e_phentsize> and I<e_phnum> members.  The ELF program "
"header is described by the type I<Elf32_Phdr> or I<Elf64_Phdr> depending on "
"the architecture:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:704
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    Elf32_Off  p_offset;\n"
"    Elf32_Addr p_vaddr;\n"
"    Elf32_Addr p_paddr;\n"
"    uint32_t   p_filesz;\n"
"    uint32_t   p_memsz;\n"
"    uint32_t   p_flags;\n"
"    uint32_t   p_align;\n"
"} Elf32_Phdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:719
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   p_type;\n"
"    uint32_t   p_flags;\n"
"    Elf64_Off  p_offset;\n"
"    Elf64_Addr p_vaddr;\n"
"    Elf64_Addr p_paddr;\n"
"    uint64_t   p_filesz;\n"
"    uint64_t   p_memsz;\n"
"    uint64_t   p_align;\n"
"} Elf64_Phdr;\n"
msgstr ""

#.  .Bl -tag -width "p_offset"
#. type: Plain text
#: build/C/man5/elf.5:727
msgid ""
"The main difference between the 32-bit and the 64-bit program header lies in "
"the location of the I<p_flags> member in the total struct."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:727
#, no-wrap
msgid "I<p_type>"
msgstr ""

#.  .Bl -tag -width "PT_DYNAMIC"
#. type: Plain text
#: build/C/man5/elf.5:732
msgid ""
"This member of the Phdr struct tells what kind of segment this array element "
"describes or how to interpret the array element's information."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:733
#, no-wrap
msgid "B<PT_NULL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:737
msgid ""
"The array element is unused and the other members' values are undefined.  "
"This lets the program header have ignored entries."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:737
#, no-wrap
msgid "B<PT_LOAD>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:758
msgid ""
"The array element specifies a loadable segment, described by I<p_filesz> and "
"I<p_memsz>.  The bytes from the file are mapped to the beginning of the "
"memory segment.  If the segment's memory size I<p_memsz> is larger than the "
"file size I<p_filesz>, the \"extra\" bytes are defined to hold the value 0 "
"and to follow the segment's initialized area.  The file size may not be "
"larger than the memory size.  Loadable segment entries in the program header "
"table appear in ascending order, sorted on the I<p_vaddr> member."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:758
#, no-wrap
msgid "B<PT_DYNAMIC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:761
msgid "The array element specifies dynamic linking information."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:761
#, no-wrap
msgid "B<PT_INTERP>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:769
msgid ""
"The array element specifies the location and size of a null-terminated "
"pathname to invoke as an interpreter.  This segment type is meaningful only "
"for executable files (though it may occur for shared objects).  However it "
"may not occur more than once in a file.  If it is present, it must precede "
"any loadable segment entry."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:769
#, no-wrap
msgid "B<PT_NOTE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:772
msgid "The array element specifies the location and size for auxiliary information."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:772
#, no-wrap
msgid "B<PT_SHLIB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:777
msgid ""
"This segment type is reserved but has unspecified semantics.  Programs that "
"contain an array element of this type do not conform to the ABI."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:777
#, no-wrap
msgid "B<PT_PHDR>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:786
msgid ""
"The array element, if present, specifies the location and size of the "
"program header table itself, both in the file and in the memory image of the "
"program.  This segment type may not occur more than once in a file.  "
"Moreover, it may only occur if the program header table is part of the "
"memory image of the program.  If it is present, it must precede any loadable "
"segment entry."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:786
#, no-wrap
msgid "B<PT_LOPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:791
msgid ""
"Values greater than or equal to B<PT_HIPROC> are reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:791
#, no-wrap
msgid "B<PT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:796
msgid ""
"Values less than or equal to B<PT_LOPROC> are reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:796
#, no-wrap
msgid "B<PT_GNU_STACK>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:803
msgid ""
"GNU extension which is used by the Linux kernel to control the state of the "
"stack via the flags set in the I<p_flags> member."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:804
#, no-wrap
msgid "I<p_offset>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:808
msgid ""
"This member holds the offset from the beginning of the file at which the "
"first byte of the segment resides."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:808
#, no-wrap
msgid "I<p_vaddr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:812
msgid ""
"This member holds the virtual address at which the first byte of the segment "
"resides in memory."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:812
#, no-wrap
msgid "I<p_paddr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:820
msgid ""
"On systems for which physical addressing is relevant, this member is "
"reserved for the segment's physical address.  Under BSD this member is not "
"used and must be zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:820
#, no-wrap
msgid "I<p_filesz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:824
msgid ""
"This member holds the number of bytes in the file image of the segment.  It "
"may be zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:824
#, no-wrap
msgid "I<p_memsz>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:828
msgid ""
"This member holds the number of bytes in the memory image of the segment.  "
"It may be zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:828
#, no-wrap
msgid "I<p_flags>"
msgstr ""

#.  .Bl -tag -width "PF_X" -compact
#. type: Plain text
#: build/C/man5/elf.5:832
msgid "This member holds a bitmask of flags relevant to the segment:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:833
#, no-wrap
msgid "B<PF_X>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:837
msgid "An executable segment."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:837
#, no-wrap
msgid "B<PF_W>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:840
msgid "A writable segment."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:840
#, no-wrap
msgid "B<PF_R>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:843
msgid "A readable segment."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:856
msgid ""
"A text segment commonly has the flags B<PF_X> and B<PF_R>.  A data segment "
"commonly has B<PF_X>, B<PF_W> and B<PF_R>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:856
#, no-wrap
msgid "I<p_align>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:875
msgid ""
"This member holds the value to which the segments are aligned in memory and "
"in the file.  Loadable process segments must have congruent values for "
"I<p_vaddr> and I<p_offset>, modulo the page size.  Values of zero and one "
"mean no alignment is required.  Otherwise, I<p_align> should be a positive, "
"integral power of two, and I<p_vaddr> should equal I<p_offset>, modulo "
"I<p_align>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:892
msgid ""
"A file's section header table lets one locate all the file's sections.  The "
"section header table is an array of I<Elf32_Shdr> or I<Elf64_Shdr> "
"structures.  The ELF header's I<e_shoff> member gives the byte offset from "
"the beginning of the file to the section header table.  I<e_shnum> holds the "
"number of entries the section header table contains.  I<e_shentsize> holds "
"the size in bytes of each entry."
msgstr ""

#.  .Bl -tag -width "SHN_LORESERVE"
#. type: Plain text
#: build/C/man5/elf.5:909
msgid ""
"A section header table index is a subscript into this array.  Some section "
"header table indices are reserved: the initial entry and the indices between "
"B<SHN_LORESERVE> and B<SHN_HIRESERVE>.  The initial entry is used in ELF "
"extensions for I<e_phnum>, I<e_shnum> and I<e_strndx>; in other cases, each "
"field in the initial entry is set to zero.  An object file does not have "
"sections for these special indices:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:914
msgid ""
"This value marks an undefined, missing, irrelevant or otherwise meaningless "
"section reference."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:934
msgid ""
"This value specifies the absolute value for the corresponding reference.  "
"For example, a symbol defined relative to section number B<SHN_ABS> has an "
"absolute value and is not affected by relocation."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:938
msgid ""
"Symbols defined relative to this section are common symbols, such as FORTRAN "
"COMMON or unallocated C external variables."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:949
msgid ""
"This value specifies the upper bound of the range of reserved indices.  The "
"system reserves indices between B<SHN_LORESERVE> and B<SHN_HIRESERVE>, "
"inclusive.  The section header table does not contain entries for the "
"reserved indices."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:953
msgid "The section header has the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:968
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint32_t   sh_flags;\n"
"    Elf32_Addr sh_addr;\n"
"    Elf32_Off  sh_offset;\n"
"    uint32_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint32_t   sh_addralign;\n"
"    uint32_t   sh_entsize;\n"
"} Elf32_Shdr;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:985
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t   sh_name;\n"
"    uint32_t   sh_type;\n"
"    uint64_t   sh_flags;\n"
"    Elf64_Addr sh_addr;\n"
"    Elf64_Off  sh_offset;\n"
"    uint64_t   sh_size;\n"
"    uint32_t   sh_link;\n"
"    uint32_t   sh_info;\n"
"    uint64_t   sh_addralign;\n"
"    uint64_t   sh_entsize;\n"
"} Elf64_Shdr;\n"
msgstr ""

#.  .Bl -tag -width "sh_addralign"
#. type: Plain text
#: build/C/man5/elf.5:990
msgid "No real differences exist between the 32-bit and 64-bit section headers."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:990
#, no-wrap
msgid "I<sh_name>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:996
msgid ""
"This member specifies the name of the section.  Its value is an index into "
"the section header string table section, giving the location of a "
"null-terminated string."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:996
#, no-wrap
msgid "I<sh_type>"
msgstr ""

#.  .Bl -tag -width "SHT_PROGBITS"
#. type: Plain text
#: build/C/man5/elf.5:1000
msgid "This member categorizes the section's contents and semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1001
#, no-wrap
msgid "B<SHT_NULL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1008
msgid ""
"This value marks the section header as inactive.  It does not have an "
"associated section.  Other members of the section header have undefined "
"values."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1008
#, no-wrap
msgid "B<SHT_PROGBITS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1012
msgid ""
"This section holds information defined by the program, whose format and "
"meaning are determined solely by the program."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1012
#, no-wrap
msgid "B<SHT_SYMTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1025
msgid ""
"This section holds a symbol table.  Typically, B<SHT_SYMTAB> provides "
"symbols for link editing, though it may also be used for dynamic linking.  "
"As a complete symbol table, it may contain many symbols unnecessary for "
"dynamic linking.  An object file can also contain a B<SHT_DYNSYM> section."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1025
#, no-wrap
msgid "B<SHT_STRTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1030
msgid ""
"This section holds a string table.  An object file may have multiple string "
"table sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1030
#, no-wrap
msgid "B<SHT_RELA>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1038
msgid ""
"This section holds relocation entries with explicit addends, such as type "
"I<Elf32_Rela> for the 32-bit class of object files.  An object may have "
"multiple relocation sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1038
#, no-wrap
msgid "B<SHT_HASH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1045
msgid ""
"This section holds a symbol hash table.  An object participating in dynamic "
"linking must contain a symbol hash table.  An object file may have only one "
"hash table."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1045
#, no-wrap
msgid "B<SHT_DYNAMIC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1050
msgid ""
"This section holds information for dynamic linking.  An object file may have "
"only one dynamic section."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1050
#, no-wrap
msgid "B<SHT_NOTE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1053
msgid "This section holds information that marks the file in some way."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1053
#, no-wrap
msgid "B<SHT_NOBITS>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1061
msgid ""
"A section of this type occupies no space in the file but otherwise resembles "
"B<SHT_PROGBITS>.  Although this section contains no bytes, the I<sh_offset> "
"member contains the conceptual file offset."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1061
#, no-wrap
msgid "B<SHT_REL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1069
msgid ""
"This section holds relocation offsets without explicit addends, such as type "
"I<Elf32_Rel> for the 32-bit class of object files.  An object file may have "
"multiple relocation sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1069
#, no-wrap
msgid "B<SHT_SHLIB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1072
msgid "This section is reserved but has unspecified semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1072
#, no-wrap
msgid "B<SHT_DYNSYM>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1079
msgid ""
"This section holds a minimal set of dynamic linking symbols.  An object file "
"can also contain a B<SHT_SYMTAB> section."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1079
#, no-wrap
msgid "B<SHT_LOPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1084
msgid ""
"This value up to and including B<SHT_HIPROC> is reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1084
#, no-wrap
msgid "B<SHT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1089
msgid ""
"This value down to and including B<SHT_LOPROC> is reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1089
#, no-wrap
msgid "B<SHT_LOUSER>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1093
msgid ""
"This value specifies the lower bound of the range of indices reserved for "
"application programs."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1093
#, no-wrap
msgid "B<SHT_HIUSER>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1104
msgid ""
"This value specifies the upper bound of the range of indices reserved for "
"application programs.  Section types between B<SHT_LOUSER> and B<SHT_HIUSER> "
"may be used by the application, without conflicting with current or future "
"system-defined section types."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1105
#, no-wrap
msgid "I<sh_flags>"
msgstr ""

#.  .Bl -tag -width "SHF_EXECINSTR" -compact
#. type: Plain text
#: build/C/man5/elf.5:1118
msgid ""
"Sections support one-bit flags that describe miscellaneous attributes.  If a "
"flag bit is set in I<sh_flags>, the attribute is \"on\" for the section.  "
"Otherwise, the attribute is \"off\" or does not apply.  Undefined attributes "
"are set to zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1119
#, no-wrap
msgid "B<SHF_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1123
msgid "This section contains data that should be writable during process execution."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1123
#, no-wrap
msgid "B<SHF_ALLOC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1130
msgid ""
"This section occupies memory during process execution.  Some control "
"sections do not reside in the memory image of an object file.  This "
"attribute is off for those sections."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1130
#, no-wrap
msgid "B<SHF_EXECINSTR>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1133
msgid "This section contains executable machine instructions."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1133
#, no-wrap
msgid "B<SHF_MASKPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1137
msgid ""
"All bits included in this mask are reserved for processor-specific "
"semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1139
#, no-wrap
msgid "I<sh_addr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1144
msgid ""
"If this section appears in the memory image of a process, this member holds "
"the address at which the section's first byte should reside.  Otherwise, the "
"member contains zero."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1144
#, no-wrap
msgid "I<sh_offset>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1153
msgid ""
"This member's value holds the byte offset from the beginning of the file to "
"the first byte in the section.  One section type, B<SHT_NOBITS>, occupies no "
"space in the file, and its I<sh_offset> member locates the conceptual "
"placement in the file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1153
#, no-wrap
msgid "I<sh_size>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1165
msgid ""
"This member holds the section's size in bytes.  Unless the section type is "
"B<SHT_NOBITS>, the section occupies I<sh_size> bytes in the file.  A section "
"of type B<SHT_NOBITS> may have a nonzero size, but it occupies no space in "
"the file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1165
#, no-wrap
msgid "I<sh_link>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1169
msgid ""
"This member holds a section header table index link, whose interpretation "
"depends on the section type."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1169
#, no-wrap
msgid "I<sh_info>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1173
msgid ""
"This member holds extra information, whose interpretation depends on the "
"section type."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1173
#, no-wrap
msgid "I<sh_addralign>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1186
msgid ""
"Some sections have address alignment constraints.  If a section holds a "
"doubleword, the system must ensure doubleword alignment for the entire "
"section.  That is, the value of I<sh_addr> must be congruent to zero, modulo "
"the value of I<sh_addralign>.  Only zero and positive integral powers of two "
"are allowed.  Values of zero or one mean the section has no alignment "
"constraints."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1186
#, no-wrap
msgid "I<sh_entsize>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1193
msgid ""
"Some sections hold a table of fixed-sized entries, such as a symbol table.  "
"For such a section, this member gives the size in bytes for each entry.  "
"This member contains zero if the section does not hold a table of fixed-size "
"entries."
msgstr ""

#.  .Bl -tag -width ".shstrtab"
#. type: Plain text
#: build/C/man5/elf.5:1196
msgid "Various sections hold program and control information:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1196
#, no-wrap
msgid "I<.bss>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1208
msgid ""
"This section holds uninitialized data that contributes to the program's "
"memory image.  By definition, the system initializes the data with zeros "
"when the program begins to run.  This section is of type B<SHT_NOBITS>.  The "
"attribute types are B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1208
#, no-wrap
msgid "I<.comment>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1214
msgid ""
"This section holds version control information.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1214
#, no-wrap
msgid "I<.ctors>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1223
msgid ""
"This section holds initialized pointers to the C++ constructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1223
#, no-wrap
msgid "I<.data>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1233 build/C/man5/elf.5:1243
msgid ""
"This section holds initialized data that contribute to the program's memory "
"image.  This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1233
#, no-wrap
msgid "I<.data1>"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1243
#, no-wrap
msgid "I<.debug>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1251
msgid ""
"This section holds information for symbolic debugging.  The contents are "
"unspecified.  This section is of type B<SHT_PROGBITS>.  No attribute types "
"are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1251
#, no-wrap
msgid "I<.dtors>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1260
msgid ""
"This section holds initialized pointers to the C++ destructor functions.  "
"This section is of type B<SHT_PROGBITS>.  The attribute types are "
"B<SHF_ALLOC> and B<SHF_WRITE>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1260
#, no-wrap
msgid "I<.dynamic>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1273
msgid ""
"This section holds dynamic linking information.  The section's attributes "
"will include the B<SHF_ALLOC> bit.  Whether the B<SHF_WRITE> bit is set is "
"processor-specific.  This section is of type B<SHT_DYNAMIC>.  See the "
"attributes above."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1273
#, no-wrap
msgid "I<.dynstr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1281
msgid ""
"This section holds strings needed for dynamic linking, most commonly the "
"strings that represent the names associated with symbol table entries.  This "
"section is of type B<SHT_STRTAB>.  The attribute type used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1281
#, no-wrap
msgid "I<.dynsym>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1288
msgid ""
"This section holds the dynamic linking symbol table.  This section is of "
"type B<SHT_DYNSYM>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1288
#, no-wrap
msgid "I<.fini>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1300
msgid ""
"This section holds executable instructions that contribute to the process "
"termination code.  When a program exits normally the system arranges to "
"execute the code in this section.  This section is of type B<SHT_PROGBITS>.  "
"The attributes used are B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1300
#, no-wrap
msgid "I<.gnu.version>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1309
msgid ""
"This section holds the version symbol table, an array of I<ElfN_Half> "
"elements.  This section is of type B<SHT_GNU_versym>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1309
#, no-wrap
msgid "I<.gnu.version_d>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1318
msgid ""
"This section holds the version symbol definitions, a table of I<ElfN_Verdef> "
"structures.  This section is of type B<SHT_GNU_verdef>.  The attribute type "
"used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1318
#, no-wrap
msgid "I<.gnu.version_r>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1328
msgid ""
"This section holds the version symbol needed elements, a table of "
"I<ElfN_Verneed> structures.  This section is of type B<SHT_GNU_versym>.  The "
"attribute type used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1328
#, no-wrap
msgid "I<.got>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1334
msgid ""
"This section holds the global offset table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor specific."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1334
#, no-wrap
msgid "I<.hash>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1341
msgid ""
"This section holds a symbol hash table.  This section is of type "
"B<SHT_HASH>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1341
#, no-wrap
msgid "I<.init>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1353
msgid ""
"This section holds executable instructions that contribute to the process "
"initialization code.  When a program starts to run the system arranges to "
"execute the code in this section before calling the main program entry "
"point.  This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1353
#, no-wrap
msgid "I<.interp>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1364
msgid ""
"This section holds the pathname of a program interpreter.  If the file has a "
"loadable segment that includes the section, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise, that bit will be off.  This "
"section is of type B<SHT_PROGBITS>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1364
#, no-wrap
msgid "I<.line>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1372
msgid ""
"This section holds line number information for symbolic debugging, which "
"describes the correspondence between the program source and the machine "
"code.  The contents are unspecified.  This section is of type "
"B<SHT_PROGBITS>.  No attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1372
#, no-wrap
msgid "I<.note>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1385
msgid ""
"This section holds information in the \"Note Section\" format.  This section "
"is of type B<SHT_NOTE>.  No attribute types are used.  OpenBSD native "
"executables usually contain a I<.note.openbsd.ident> section to identify "
"themselves, for the kernel to bypass any compatibility ELF binary emulation "
"tests when loading the file."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1385
#, no-wrap
msgid "I<.note.GNU-stack>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1394
msgid ""
"This section is used in Linux object files for declaring stack attributes.  "
"This section is of type B<SHT_PROGBITS>.  The only attribute used is "
"B<SHF_EXECINSTR>.  This indicates to the GNU linker that the object file "
"requires an executable stack."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1394
#, no-wrap
msgid "I<.plt>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1400
msgid ""
"This section holds the procedure linkage table.  This section is of type "
"B<SHT_PROGBITS>.  The attributes are processor specific."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1400
#, no-wrap
msgid "I<.relNAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1419
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rel.text>.  This section is of type B<SHT_REL>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1419
#, no-wrap
msgid "I<.relaNAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1438
msgid ""
"This section holds relocation information as described below.  If the file "
"has a loadable segment that includes relocation, the section's attributes "
"will include the B<SHF_ALLOC> bit.  Otherwise the bit will be off.  By "
"convention, \"NAME\" is supplied by the section to which the relocations "
"apply.  Thus a relocation section for B<.text> normally would have the name "
"B<.rela.text>.  This section is of type B<SHT_RELA>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1438
#, no-wrap
msgid "I<.rodata>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1446 build/C/man5/elf.5:1454
msgid ""
"This section holds read-only data that typically contributes to a "
"nonwritable segment in the process image.  This section is of type "
"B<SHT_PROGBITS>.  The attribute used is B<SHF_ALLOC>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1446
#, no-wrap
msgid "I<.rodata1>"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1454
#, no-wrap
msgid "I<.shstrtab>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1460
msgid ""
"This section holds section names.  This section is of type B<SHT_STRTAB>.  "
"No attribute types are used."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1460
#, no-wrap
msgid "I<.strtab>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1472
msgid ""
"This section holds strings, most commonly the strings that represent the "
"names associated with symbol table entries.  If the file has a loadable "
"segment that includes the symbol string table, the section's attributes will "
"include the B<SHF_ALLOC> bit.  Otherwise the bit will be off.  This section "
"is of type B<SHT_STRTAB>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1472
#, no-wrap
msgid "I<.symtab>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1483
msgid ""
"This section holds a symbol table.  If the file has a loadable segment that "
"includes the symbol table, the section's attributes will include the "
"B<SHF_ALLOC> bit.  Otherwise the bit will be off.  This section is of type "
"B<SHT_SYMTAB>."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1483
#, no-wrap
msgid "I<.text>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1495
msgid ""
"This section holds the \"text\", or executable instructions, of a program.  "
"This section is of type B<SHT_PROGBITS>.  The attributes used are "
"B<SHF_ALLOC> and B<SHF_EXECINSTR>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1506
msgid ""
"String table sections hold null-terminated character sequences, commonly "
"called strings.  The object file uses these strings to represent symbol and "
"section names.  One references a string as an index into the string table "
"section.  The first byte, which is index zero, is defined to hold a null "
"byte (\\(aq\\e0\\(aq).  Similarly, a string table's last byte is defined to "
"hold a null byte, ensuring null termination for all strings."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1511
msgid ""
"An object file's symbol table holds information needed to locate and "
"relocate a program's symbolic definitions and references.  A symbol table "
"index is a subscript into this array."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1522
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    Elf32_Addr    st_value;\n"
"    uint32_t      st_size;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"} Elf32_Sym;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1535
#, no-wrap
msgid ""
"typedef struct {\n"
"    uint32_t      st_name;\n"
"    unsigned char st_info;\n"
"    unsigned char st_other;\n"
"    uint16_t      st_shndx;\n"
"    Elf64_Addr    st_value;\n"
"    uint64_t      st_size;\n"
"} Elf64_Sym;\n"
msgstr ""

#.  .Bl -tag -width "st_value"
#. type: Plain text
#: build/C/man5/elf.5:1541
msgid ""
"The 32-bit and 64-bit versions have the same members, just in a different "
"order."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1541
#, no-wrap
msgid "I<st_name>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1549
msgid ""
"This member holds an index into the object file's symbol string table, which "
"holds character representations of the symbol names.  If the value is "
"nonzero, it represents a string table index that gives the symbol name.  "
"Otherwise, the symbol table has no name."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1549
#, no-wrap
msgid "I<st_value>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1552
msgid "This member gives the value of the associated symbol."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1552
#, no-wrap
msgid "I<st_size>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1557
msgid ""
"Many symbols have associated sizes.  This member holds zero if the symbol "
"has no size or an unknown size."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1557
#, no-wrap
msgid "I<st_info>"
msgstr ""

#.  .Bl -tag -width "STT_SECTION"
#. type: Plain text
#: build/C/man5/elf.5:1561
msgid "This member specifies the symbol's type and binding attributes:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1562
#, no-wrap
msgid "B<STT_NOTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1565
msgid "The symbol's type is not defined."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1565
#, no-wrap
msgid "B<STT_OBJECT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1568
msgid "The symbol is associated with a data object."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1568
#, no-wrap
msgid "B<STT_FUNC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1571
msgid "The symbol is associated with a function or other executable code."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1571
#, no-wrap
msgid "B<STT_SECTION>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1578
msgid ""
"The symbol is associated with a section.  Symbol table entries of this type "
"exist primarily for relocation and normally have B<STB_LOCAL> bindings."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1578
#, no-wrap
msgid "B<STT_FILE>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1589
msgid ""
"By convention, the symbol's name gives the name of the source file "
"associated with the object file.  A file symbol has B<STB_LOCAL> bindings, "
"its section index is B<SHN_ABS>, and it precedes the other B<STB_LOCAL> "
"symbols of the file, if it is present."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1589
#, no-wrap
msgid "B<STT_LOPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1594
msgid ""
"This value up to and including B<STT_HIPROC> is reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1594
#, no-wrap
msgid "B<STT_HIPROC>"
msgstr ""

#.  .El
#.  .Bl -tag -width "STB_GLOBAL"
#. type: Plain text
#: build/C/man5/elf.5:1601
msgid ""
"This value down to and including B<STT_LOPROC> is reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1601
#, no-wrap
msgid "B<STB_LOCAL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1607
msgid ""
"Local symbols are not visible outside the object file containing their "
"definition.  Local symbols of the same name may exist in multiple files "
"without interfering with each other."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1607
#, no-wrap
msgid "B<STB_GLOBAL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1613
msgid ""
"Global symbols are visible to all object files being combined.  One file's "
"definition of a global symbol will satisfy another file's undefined "
"reference to the same symbol."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1613
#, no-wrap
msgid "B<STB_WEAK>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1617
msgid ""
"Weak symbols resemble global symbols, but their definitions have lower "
"precedence."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1617
#, no-wrap
msgid "B<STB_LOPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1622
msgid ""
"This value up to and including B<STB_HIPROC> is reserved for "
"processor-specific semantics."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1622
#, no-wrap
msgid "B<STB_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1627
msgid ""
"This value down to and including B<STB_LOPROC> is reserved for "
"processor-specific semantics."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1629
msgid "There are macros for packing and unpacking the binding and type fields:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1636
msgid ""
"B<ELF32_ST_BIND>(info)  or B<ELF64_ST_BIND>(info)  extract a binding from an "
"I<st_info> value."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1640
msgid "B<ELF32_ST_TYPE>(info)  or B<ELF64_ST_TYPE>(info)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1644
msgid "extract a type from an I<st_info> value."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1648
msgid "B<ELF32_ST_INFO>(bind, type)  or B<ELF64_ST_INFO>(bind, type)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1652
msgid "convert a binding and a type into an I<st_info> value."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1654
#, no-wrap
msgid "I<st_other>"
msgstr ""

#.  .Bl -tag -width "STV_PROTECTED"
#. type: Plain text
#: build/C/man5/elf.5:1658
msgid "This member defines the symbol visibility."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1659
#, no-wrap
msgid "B<STV_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1663
msgid "Default symbol visibility rules."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1663
#, no-wrap
msgid "B<STV_INTERNAL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1666
msgid "Processor-specific hidden class."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1666
#, no-wrap
msgid "B<STV_HIDDEN>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1669
msgid "Symbol is unavailable in other modules."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1669
#, no-wrap
msgid "B<STV_PROTECTED>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1672
msgid "Not preemptible, not exported."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1675
msgid "There are macros for extracting the visibility type:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1679
msgid "B<ELF32_ST_VISIBILITY>(other)  or B<ELF64_ST_VISIBILITY>(other)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1681
#, no-wrap
msgid "I<st_shndx>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1689
msgid ""
"Every symbol table entry is \"defined\" in relation to some section.  This "
"member holds the relevant section header table index."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1697
msgid ""
"Relocation is the process of connecting symbolic references with symbolic "
"definitions.  Relocatable files must have information that describes how to "
"modify their section contents, thus allowing executable and shared object "
"files to hold the right information for a process's program image.  "
"Relocation entries are these data."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1699
msgid "Relocation structures that do not need an addend:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1706
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"} Elf32_Rel;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1715
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"} Elf64_Rel;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1719
msgid "Relocation structures that need an addend:"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1727
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Addr r_offset;\n"
"    uint32_t   r_info;\n"
"    int32_t    r_addend;\n"
"} Elf32_Rela;\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1737
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Addr r_offset;\n"
"    uint64_t   r_info;\n"
"    int64_t    r_addend;\n"
"} Elf64_Rela;\n"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1740
#, no-wrap
msgid "I<r_offset>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1748
msgid ""
"This member gives the location at which to apply the relocation action.  For "
"a relocatable file, the value is the byte offset from the beginning of the "
"section to the storage unit affected by the relocation.  For an executable "
"file or shared object, the value is the virtual address of the storage unit "
"affected by the relocation."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1748
#, no-wrap
msgid "I<r_info>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1763
msgid ""
"This member gives both the symbol table index with respect to which the "
"relocation must be made and the type of relocation to apply.  Relocation "
"types are processor specific.  When the text refers to a relocation entry's "
"relocation type or symbol table index, it means the result of applying "
"B<ELF_[32|64]_R_TYPE> or B<ELF[32|64]_R_SYM>, respectively, to the entry's "
"I<r_info> member."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1763
#, no-wrap
msgid "I<r_addend>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1768
msgid ""
"This member specifies a constant addend used to compute the value to be "
"stored into the relocatable field."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1773
msgid ""
"The .dynamic section contains a series of structures that hold relevant "
"dynamic linking information.  The d_tag member controls the interpretation "
"of d_un."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1784
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf32_Sword    d_tag;\n"
"    union {\n"
"        Elf32_Word d_val;\n"
"        Elf32_Addr d_ptr;\n"
"    } d_un;\n"
"} Elf32_Dyn;\n"
"extern Elf32_Dyn _DYNAMIC[];\n"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1797
#, no-wrap
msgid ""
"typedef struct {\n"
"    Elf64_Sxword    d_tag;\n"
"    union {\n"
"        Elf64_Xword d_val;\n"
"        Elf64_Addr  d_ptr;\n"
"    } d_un;\n"
"} Elf64_Dyn;\n"
"extern Elf64_Dyn _DYNAMIC[];\n"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1800
#, no-wrap
msgid "I<d_tag>"
msgstr ""

#.  .Bl -tag -width "DT_SYMBOLIC"
#. type: Plain text
#: build/C/man5/elf.5:1804
msgid "This member may have any of the following values:"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1805
#, no-wrap
msgid "B<DT_NULL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1808
msgid "Marks end of dynamic section"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1808
#, no-wrap
msgid "B<DT_NEEDED>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1811
msgid "String table offset to name of a needed library"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1811
#, no-wrap
msgid "B<DT_PLTRELSZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1814
msgid "Size in bytes of PLT relocs"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1814
#, no-wrap
msgid "B<DT_PLTGOT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1817
msgid "Address of PLT and/or GOT"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1817
#, no-wrap
msgid "B<DT_HASH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1820
msgid "Address of symbol hash table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1820
#, no-wrap
msgid "B<DT_STRTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1823
msgid "Address of string table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1823
#, no-wrap
msgid "B<DT_SYMTAB>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1826
msgid "Address of symbol table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1826
#, no-wrap
msgid "B<DT_RELA>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1829
msgid "Address of Rela relocs table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1829
#, no-wrap
msgid "B<DT_RELASZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1832
msgid "Size in bytes of Rela table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1832
#, no-wrap
msgid "B<DT_RELAENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1835
msgid "Size in bytes of a Rela table entry"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1835
#, no-wrap
msgid "B<DT_STRSZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1838
msgid "Size in bytes of string table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1838
#, no-wrap
msgid "B<DT_SYMENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1841
msgid "Size in bytes of a symbol table entry"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1841
#, no-wrap
msgid "B<DT_INIT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1844
msgid "Address of the initialization function"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1844
#, no-wrap
msgid "B<DT_FINI>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1847
msgid "Address of the termination function"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1847
#, no-wrap
msgid "B<DT_SONAME>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1850
msgid "String table offset to name of shared object"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1850
#, no-wrap
msgid "B<DT_RPATH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1853
msgid "String table offset to library search path (deprecated)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1853
#, no-wrap
msgid "B<DT_SYMBOLIC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1856
msgid "Alert linker to search this shared object before the executable for symbols"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1856
#, no-wrap
msgid "B<DT_REL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1859
msgid "Address of Rel relocs table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1859
#, no-wrap
msgid "B<DT_RELSZ>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1862
msgid "Size in bytes of Rel table"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1862
#, no-wrap
msgid "B<DT_RELENT>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1865
msgid "Size in bytes of a Rel table entry"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1865
#, no-wrap
msgid "B<DT_PLTREL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1868
msgid "Type of reloc the PLT refers (Rela or Rel)"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1868
#, no-wrap
msgid "B<DT_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1871
msgid "Undefined use for debugging"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1871
#, no-wrap
msgid "B<DT_TEXTREL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1874
msgid "Absence of this indicates no relocs should apply to a nonwritable segment"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1874
#, no-wrap
msgid "B<DT_JMPREL>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1877
msgid "Address of reloc entries solely for the PLT"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1877
#, no-wrap
msgid "B<DT_BIND_NOW>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1881
msgid ""
"Instruct dynamic linker to process all relocs before transferring control to "
"the executable"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1881
#, no-wrap
msgid "B<DT_RUNPATH>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1884
msgid "String table offset to library search path"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1884
#, no-wrap
msgid "B<DT_LOPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1887
msgid "Start of processor-specific semantics"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1887
#, no-wrap
msgid "B<DT_HIPROC>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1890
msgid "End of processor-specific semantics"
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1892
#, no-wrap
msgid "I<d_val>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1895
msgid "This member represents integer values with various interpretations."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1895
#, no-wrap
msgid "I<d_ptr>"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1903
msgid ""
"This member represents program virtual addresses.  When interpreting these "
"addresses, the actual address should be computed based on the original file "
"value and memory base address.  Files do not contain relocation entries to "
"fixup these addresses."
msgstr ""

#. type: TP
#: build/C/man5/elf.5:1903
#, no-wrap
msgid "I<_DYNAMIC>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man5/elf.5:1908
msgid ""
"Array containing all the dynamic structures in the .dynamic section.  This "
"is automatically populated by the linker."
msgstr ""

#.  OpenBSD
#.  ELF support first appeared in
#.  OpenBSD 1.2,
#.  although not all supported platforms use it as the native
#.  binary file format.
#. type: Plain text
#: build/C/man5/elf.5:1917
msgid "ELF first appeared in System V.  The ELF format is an adopted standard."
msgstr ""

#.  .SH AUTHORS
#.  The original version of this manual page was written by
#.  .An Jeroen Ruigrok van der Werven
#.  .Aq asmodai@FreeBSD.org
#.  with inspiration from BSDi's
#.  .Bsx
#.  .Nm elf
#.  man page.
#. type: Plain text
#: build/C/man5/elf.5:1935
msgid ""
"The extensions for I<e_phnum>, I<e_shnum> and I<e_strndx> respectively are "
"Linux extensions.  Sun, BSD and AMD64 also support them; for further "
"information, look under SEE ALSO."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1942
msgid "B<as>(1), B<gdb>(1), B<ld>(1), B<objdump>(1), B<execve>(2), B<core>(5)"
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1945
msgid "Hewlett-Packard, I<Elf-64 Object File Format>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1948
msgid "Santa Cruz Operation, I<System V Application Binary Interface>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1952
msgid ""
"UNIX System Laboratories, \"Object Files\", I<Executable and Linking Format "
"(ELF)>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1955
msgid "Sun Microsystems, I<Linker and Libraries Guide>."
msgstr ""

#. type: Plain text
#: build/C/man5/elf.5:1958
msgid ""
"AMD64 ABI Draft, I<System V Application Binary Interface AMD64 Architecture "
"Processor Supplement>."
msgstr ""

#. type: TH
#: build/C/man3/end.3:25
#, no-wrap
msgid "END"
msgstr ""

#. type: TH
#: build/C/man3/end.3:25
#, no-wrap
msgid "2008-07-17"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:28
msgid "etext, edata, end - end of program segments"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:33
#, no-wrap
msgid ""
"B<extern>I< etext>B<;>\n"
"B<extern>I< edata>B<;>\n"
"B<extern>I< end>B<;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:37
msgid "The addresses of these symbols indicate the end of various program segments:"
msgstr ""

#. type: TP
#: build/C/man3/end.3:37
#, no-wrap
msgid "I<etext>"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:41
msgid ""
"This is the first address past the end of the text segment (the program "
"code)."
msgstr ""

#. type: TP
#: build/C/man3/end.3:41
#, no-wrap
msgid "I<edata>"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:45
msgid "This is the first address past the end of the initialized data segment."
msgstr ""

#. type: TP
#: build/C/man3/end.3:45
#, no-wrap
msgid "I<end>"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:49
msgid ""
"This is the first address past the end of the uninitialized data segment "
"(also known as the BSS segment)."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:52
msgid ""
"Although these symbols have long been provided on most UNIX systems, they "
"are not standardized; use with caution."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:55
msgid ""
"The program must explicitly declare these symbols; they are not defined in "
"any header file."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:63
msgid ""
"On some systems the names of these symbols are preceded by underscores, "
"thus: I<_etext>, I<_edata>, and I<_end>.  These symbols are also defined for "
"programs compiled on Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:75
msgid ""
"At the start of program execution, the program break will be somewhere near "
"I<&end> (perhaps at the start of the following page).  However, the break "
"will change as memory is allocated via B<brk>(2)  or B<malloc>(3).  Use "
"B<sbrk>(2)  with an argument of zero to find the current value of the "
"program break."
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:77
msgid "When run, the program below produces output such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:85
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"First address past:\n"
"    program text (etext)       0x8048568\n"
"    initialized data (edata)   0x804a01c\n"
"    uninitialized data (end)   0x804a024\n"
msgstr ""

#. type: SS
#: build/C/man3/end.3:87
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:92
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:95
#, no-wrap
msgid ""
"extern char etext, edata, end; /* The symbols must have some type,\n"
"                                   or \"gcc -Wall\" complains */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:103
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"First address past:\\en\");\n"
"    printf(\"    program text (etext)      %10p\\en\", &etext);\n"
"    printf(\"    initialized data (edata)  %10p\\en\", &edata);\n"
"    printf(\"    uninitialized data (end)  %10p\\en\", &end);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/end.3:112
msgid "B<objdump>(1), B<readelf>(1), B<sbrk>(2), B<elf>(5)"
msgstr ""

#. type: TH
#: build/C/man8/ld.so.8:2
#, no-wrap
msgid "LD.SO"
msgstr ""

#. type: TH
#: build/C/man8/ld.so.8:2
#, no-wrap
msgid "2012-04-17"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:5
msgid "ld.so, ld-linux.so* - dynamic linker/loader"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:12
msgid ""
"The dynamic linker can be run either indirectly by running some dynamically "
"linked program or library (in which case no command-line options to the "
"dynamic linker can be passed and, in the ELF case, the dynamic linker which "
"is stored in the B<.interp> section of the program is executed) or directly "
"by running:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:15
msgid "I</lib/ld-linux.so.*> [OPTIONS] [PROGRAM [ARGUMENTS]]"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:22
msgid ""
"The programs B<ld.so> and B<ld-linux.so*> find and load the shared libraries "
"needed by a program, prepare the program to run, and then run it."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:29
msgid ""
"Linux binaries require dynamic linking (linking at run time)  unless the "
"B<-static> option was given to B<ld>(1)  during compilation."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:42
msgid ""
"The program B<ld.so> handles a.out binaries, a format used long ago; "
"B<ld-linux.so*> handles ELF (I</lib/ld-linux.so.1> for libc5, "
"I</lib/ld-linux.so.2> for glibc2), which everybody has been using for years "
"now.  Otherwise both have the same behavior, and use the same support files "
"and programs B<ldd>(1), B<ldconfig>(8)  and I</etc/ld.so.conf>."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:45
msgid ""
"The shared libraries needed by the program are searched for in the following "
"order:"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:50
msgid ""
"(ELF only) Using the directories specified in the DT_RPATH dynamic section "
"attribute of the binary if present and DT_RUNPATH attribute does not exist.  "
"Use of DT_RPATH is deprecated."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:55
msgid ""
"Using the environment variable B<LD_LIBRARY_PATH>.  Except if the executable "
"is a set-user-ID/set-group-ID binary, in which case it is ignored."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:59
msgid ""
"(ELF only) Using the directories specified in the DT_RUNPATH dynamic section "
"attribute of the binary if present."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:69
msgid ""
"From the cache file I</etc/ld.so.cache> which contains a compiled list of "
"candidate libraries previously found in the augmented library path.  If, "
"however, the binary was linked with the B<-z nodeflib> linker option, "
"libraries in the default library paths are skipped.  Libraries installed in "
"hardware capability directories (see below)  are preferred to other "
"libraries."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:77
msgid ""
"In the default path I</lib>, and then I</usr/lib>.  If the binary was linked "
"with the B<-z nodeflib> linker option, this step is skipped."
msgstr ""

#. type: SS
#: build/C/man8/ld.so.8:77
#, no-wrap
msgid "$ORIGIN and rpath"
msgstr ""

#.  ld.so also understands $LIB, with the same meaning as $ORIGIN/lib,
#.  it appears.
#
#.  There is also $PLATFORM.  This is a kind of wildcard
#.  of directories related at AT_HWCAP.  To get an idea of the
#.  places that $PLATFORM would match, look at the output of the
#.  following:
#
#.  mkdir /tmp/d
#.  LD_LIBRARY_PATH=/tmp/d strace -e open /bin/date 2>&1 | grep /tmp/d
#
#.  ld.so lets names be abbreviated, so $O will work for $ORIGIN;
#.  Don't do this!!
#. type: Plain text
#: build/C/man8/ld.so.8:112
msgid ""
"B<ld.so> understands the string I<$ORIGIN> (or equivalently I<${ORIGIN}>)  "
"in an rpath specification (DT_RPATH or DT_RUNPATH) to mean the directory "
"containing the application executable.  Thus, an application located in "
"I<somedir/app> could be compiled with I<gcc "
"-Wl,-rpath,\\(aq$ORIGIN/../lib\\(aq> so that it finds an associated shared "
"library in I<somedir/lib> no matter where I<somedir> is located in the "
"directory hierarchy.  This facilitates the creation of \"turn-key\" "
"applications that do not need to be installed into special directories, but "
"can instead be unpacked into any directory and still find their own shared "
"libraries."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:112 build/C/man8/ldconfig.8:100 build/C/man1/ldd.1:19
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:113
#, no-wrap
msgid "B<--list>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:116
msgid "List all dependencies and how they are resolved."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:116
#, no-wrap
msgid "B<--verify>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:120
msgid ""
"Verify that program is dynamically linked and this dynamic linker can handle "
"it."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:120
#, no-wrap
msgid "B<--library-path PATH>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:125
msgid ""
"Use PATH instead of B<LD_LIBRARY_PATH> environment variable setting (see "
"below)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:125
#, no-wrap
msgid "B<--inhibit-rpath LIST>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:131
msgid ""
"Ignore RPATH and RUNPATH information in object names in LIST.  This option "
"is ignored if B<ld.so> is set-user-ID or set-group-ID."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:131
#, no-wrap
msgid "B<--audit LIST>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:134
msgid "Use objects named in LIST as auditors."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:134
#, no-wrap
msgid "HARDWARE CAPABILITIES"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:145
msgid ""
"Some libraries are compiled using hardware-specific instructions which do "
"not exist on every CPU.  Such libraries should be installed in directories "
"whose names define the required hardware capabilities, such as "
"I</usr/lib/sse2/>.  The dynamic linker checks these directories against the "
"hardware of the machine and selects the most suitable version of a given "
"library.  Hardware capability directories can be cascaded to combine CPU "
"features.  The list of supported hardware capability names depends on the "
"CPU.  The following names are currently recognized:"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:145
#, no-wrap
msgid "B<Alpha>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:148
msgid "ev4, ev5, ev56, ev6, ev67"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:148
#, no-wrap
msgid "B<MIPS>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:151
msgid "loongson2e, loongson2f, octeon, octeon2"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:151
#, no-wrap
msgid "B<PowerPC>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:156
msgid ""
"4xxmac, altivec, arch_2_05, arch_2_06, booke, cellbe, dfp, efpdouble, "
"efpsingle, fpu, ic_snoop, mmu, notb, pa6t, power4, power5, power5+, power6x, "
"ppc32, ppc601, ppc64, smt, spe, ucache, vsx"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:156
#, no-wrap
msgid "B<SPARC>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:159
msgid "flush, muldiv, stbar, swap, ultra3, v9, v9v, v9v2"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:159
#, no-wrap
msgid "B<s390>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:163
msgid ""
"dfp, eimm, esan3, etf3enh, g5, highgprs, hpage, ldisp, msa, stfle, z900, "
"z990, z9-109, z10, zarch"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:164
#, no-wrap
msgid "B<x86 (32-bit only)>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:168
msgid ""
"acpi, apic, clflush, cmov, cx8, dts, fxsr, ht, i386, i486, i586, i686, mca, "
"mmx, mtrr, pat, pbe, pge, pn, pse36, sep, ss, sse, sse2, tm"
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:168
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:170
msgid "There are four important environment variables."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:170
#, no-wrap
msgid "B<LD_BIND_NOW>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:178
msgid ""
"(libc5; glibc since 2.1.1)  If set to a nonempty string, causes the dynamic "
"linker to resolve all symbols at program startup instead of deferring "
"function call resolution to the point when they are first referenced.  This "
"is useful when using a debugger."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:178
#, no-wrap
msgid "B<LD_LIBRARY_PATH>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:185
msgid ""
"A colon-separated list of directories in which to search for ELF libraries "
"at execution-time.  Similar to the B<PATH> environment variable."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:185
#, no-wrap
msgid "B<LD_PRELOAD>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:193
msgid ""
"A whitespace-separated list of additional, user-specified, ELF shared "
"libraries to be loaded before all others.  This can be used to selectively "
"override functions in other shared libraries.  For set-user-ID/set-group-ID "
"ELF binaries, only libraries in the standard search directories that are "
"also set-user-ID will be loaded."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:193
#, no-wrap
msgid "B<LD_TRACE_LOADED_OBJECTS>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:200
msgid ""
"(ELF only)  If set to a nonempty string, causes the program to list its "
"dynamic library dependencies, as if run by B<ldd>(1), instead of running "
"normally."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:203
msgid ""
"Then there are lots of more or less obscure variables, many obsolete or only "
"for internal use."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:203
#, no-wrap
msgid "B<LD_AOUT_LIBRARY_PATH>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:211
msgid ""
"(libc5)  Version of B<LD_LIBRARY_PATH> for a.out binaries only.  Old "
"versions of ld-linux.so.1 also supported B<LD_ELF_LIBRARY_PATH>."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:211
#, no-wrap
msgid "B<LD_AOUT_PRELOAD>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:219
msgid ""
"(libc5)  Version of B<LD_PRELOAD> for a.out binaries only.  Old versions of "
"ld-linux.so.1 also supported B<LD_ELF_PRELOAD>."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:219
#, no-wrap
msgid "B<LD_AUDIT>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:229
msgid ""
"(glibc since 2.4)  A colon-separated list of user-specified, ELF shared "
"objects to be loaded before all others in a separate linker namespace (i.e., "
"one that does not intrude upon the normal symbol bindings that would occur "
"in the process).  These libraries can be used to audit the operation of the "
"dynamic linker.  B<LD_AUDIT> is ignored for set-user-ID/set-group-ID "
"binaries."
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:242
msgid ""
"The dynamic linker will notify the audit libraries at so-called auditing "
"checkpoints\\(emfor example, loading a new library, resolving a symbol, or "
"calling a symbol from another shared object\\(emby calling an appropriate "
"function within the audit library.  For details, see B<rtld-audit>(7).  The "
"auditing interface is largely compatible with that provided on Solaris, as "
"described in its I<Linker and Libraries Guide>, in the chapter I<Runtime "
"Linker Auditing Interface>."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:242
#, no-wrap
msgid "B<LD_BIND_NOT>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:247
msgid ""
"(glibc since 2.1.95)  Do not update the GOT (global offset table) and PLT "
"(procedure linkage table)  after resolving a symbol."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:247
#, no-wrap
msgid "B<LD_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:260
msgid ""
"(glibc since 2.1)  Output verbose debugging information about the dynamic "
"linker.  If set to B<all> prints all debugging information it has, if set to "
"B<help> prints a help message about which categories can be specified in "
"this environment variable.  Since glibc 2.3.4, B<LD_DEBUG> is ignored for "
"set-user-ID/set-group-ID binaries."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:260
#, no-wrap
msgid "B<LD_DEBUG_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:268
msgid ""
"(glibc since 2.1)  File where B<LD_DEBUG> output should be fed into, default "
"is standard output.  B<LD_DEBUG_OUTPUT> is ignored for "
"set-user-ID/set-group-ID binaries."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:268
#, no-wrap
msgid "B<LD_DYNAMIC_WEAK>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:275
msgid ""
"(glibc since 2.1.91)  Allow weak symbols to be overridden (reverting to old "
"glibc behavior).  For security reasons, since glibc 2.3.4, "
"B<LD_DYNAMIC_WEAK> is ignored for set-user-ID/set-group-ID binaries."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:275
#, no-wrap
msgid "B<LD_HWCAP_MASK>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:279
msgid "(glibc since 2.1)  Mask for hardware capabilities."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:279
#, no-wrap
msgid "B<LD_KEEPDIR>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:284
msgid ""
"(a.out only)(libc5)  Don't ignore the directory in the names of a.out "
"libraries to be loaded.  Use of this option is strongly discouraged."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:284
#, no-wrap
msgid "B<LD_NOWARN>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:289
msgid ""
"(a.out only)(libc5)  Suppress warnings about a.out libraries with "
"incompatible minor version numbers."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:289
#, no-wrap
msgid "B<LD_ORIGIN_PATH>"
msgstr ""

#.  Only used if $ORIGIN can't be determined by normal means
#.  (from the origin path saved at load time, or from /proc/self/exe)?
#. type: Plain text
#: build/C/man8/ld.so.8:298
msgid ""
"(glibc since 2.1)  Path where the binary is found (for non-set-user-ID "
"programs).  For security reasons, since glibc 2.4, B<LD_ORIGIN_PATH> is "
"ignored for set-user-ID/set-group-ID binaries."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:298
#, no-wrap
msgid "B<LD_POINTER_GUARD>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:310
msgid ""
"(glibc since 2.4)  Set to 0 to disable pointer guarding.  Any other value "
"enables pointer guarding, which is also the default.  Pointer guarding is a "
"security mechanism whereby some pointers to code stored in writable program "
"memory (return addresses saved by B<setjmp>(3)  or function pointers used by "
"various glibc internals) are mangled semi-randomly to make it more difficult "
"for an attacker to hijack the pointers for use in the event of a buffer "
"overrun or stack-smashing attack."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:310
#, no-wrap
msgid "B<LD_PROFILE>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:317
msgid ""
"(glibc since 2.1)  Shared object to be profiled, specified either as a "
"pathname or a soname.  Profiling output is written to the file whose name "
"is: \"I<$LD_PROFILE_OUTPUT>/I<$LD_PROFILE>.profile\"."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:317
#, no-wrap
msgid "B<LD_PROFILE_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:330
msgid ""
"(glibc since 2.1)  Directory where B<LD_PROFILE> output should be written.  "
"If this variable is not defined, or is defined as an empty string, then the "
"default is I</var/tmp>.  B<LD_PROFILE_OUTPUT> is ignored for set-user-ID and "
"set-group-ID programs, which always use I</var/profile>."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:330
#, no-wrap
msgid "B<LD_SHOW_AUXV>"
msgstr ""

#.  FIXME
#.  Document LD_TRACE_PRELINKING (e.g.: LD_TRACE_PRELINKING=libx1.so ./prog)
#.  Since glibc 2.3
#.  Also enables DL_DEBUG_PRELINK
#. type: Plain text
#: build/C/man8/ld.so.8:341
msgid ""
"(glibc since 2.1)  Show auxiliary array passed up from the kernel.  For "
"security reasons, since glibc 2.3.5, B<LD_SHOW_AUXV> is ignored for "
"set-user-ID/set-group-ID binaries."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:341
#, no-wrap
msgid "B<LD_USE_LOAD_BIAS>"
msgstr ""

#.  http://sources.redhat.com/ml/libc-hacker/2003-11/msg00127.html
#.  Subject: [PATCH] Support LD_USE_LOAD_BIAS
#.  Jakub Jelinek
#. type: Plain text
#: build/C/man8/ld.so.8:360
msgid ""
"By default (i.e., if this variable is not defined)  executables and "
"prelinked shared objects will honor base addresses of their dependent "
"libraries and (nonprelinked) position-independent executables (PIEs)  and "
"other shared objects will not honor them.  If B<LD_USE_LOAD_BIAS> is defined "
"wit the value, both executables and PIEs will honor the base addresses.  If "
"B<LD_USE_LOAD_BIAS> is defined with the value 0, neither executables nor "
"PIEs will honor the base addresses.  This variable is ignored by set-user-ID "
"and set-group-ID programs."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:360
#, no-wrap
msgid "B<LD_VERBOSE>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:372
msgid ""
"(glibc since 2.1)  If set to a nonempty string, output symbol versioning "
"information about the program if querying information about the program "
"(i.e., either B<LD_TRACE_LOADED_OBJECTS> has been set, or B<--list> or "
"B<--verify> options have been given to the dynamic linker)."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:372
#, no-wrap
msgid "B<LD_WARN>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:376
msgid ""
"(ELF only)(glibc since 2.1.3)  If set to a nonempty string, warn about "
"unresolved symbols."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:376
#, no-wrap
msgid "B<LDD_ARGV0>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:383
msgid "(libc5)  I<argv>[0] to be used by B<ldd>(1)  when none is present."
msgstr ""

#. type: SH
#: build/C/man8/ld.so.8:383 build/C/man8/ldconfig.8:156
#, no-wrap
msgid "FILES"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:385 build/C/man8/ldconfig.8:158
#, no-wrap
msgid "I</lib/ld.so>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:388
msgid "a.out dynamic linker/loader"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:388
#, no-wrap
msgid "I</lib/ld-linux.so.>{I<1>,I<2>}"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:391
msgid "ELF dynamic linker/loader"
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:391 build/C/man8/ldconfig.8:165
#, no-wrap
msgid "I</etc/ld.so.cache>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:395
msgid ""
"File containing a compiled list of directories in which to search for "
"libraries and an ordered list of candidate libraries."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:395
#, no-wrap
msgid "I</etc/ld.so.preload>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:399
msgid ""
"File containing a whitespace separated list of ELF shared libraries to be "
"loaded before the program."
msgstr ""

#. type: TP
#: build/C/man8/ld.so.8:399
#, no-wrap
msgid "B<lib*.so*>"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:402
msgid "shared libraries"
msgstr ""

#. type: Plain text
#: build/C/man8/ld.so.8:409
msgid ""
"The B<ld.so> functionality is available for executables compiled using libc "
"version 4.4.3 or greater.  ELF functionality is available since Linux 1.1.52 "
"and libc5."
msgstr ""

#.  .SH AUTHORS
#.  ld.so: David Engel, Eric Youngdale, Peter MacDonald, Hongjiu Lu, Linus
#.   Torvalds, Lars Wirzenius and Mitch D'Souza
#.  ld-linux.so: Roland McGrath, Ulrich Drepper and others.
#
#.  In the above, (libc5) stands for David Engel's ld.so/ld-linux.so.
#. type: Plain text
#: build/C/man8/ld.so.8:419
msgid "B<ldd>(1), B<rtld-audit>(7), B<ldconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man8/ldconfig.8:22
#, no-wrap
msgid "LDCONFIG"
msgstr ""

#. type: TH
#: build/C/man8/ldconfig.8:22
#, no-wrap
msgid "2009-04-15"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:25
msgid "/sbin/ldconfig - configure dynamic linker run-time bindings"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:40
msgid ""
"B</sbin/ldconfig> [ B<-nNvXV> ] [ B<-f\\ conf> ] [ B<-C\\ cache> ] [ B<-r\\ "
"root> ] I<directory>\\ ..."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:49
msgid "B</sbin/ldconfig> B<-l> [ B<-v> ] I<library>\\ ..."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:54
msgid "B</sbin/ldconfig> B<-p>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:71
msgid ""
"B<ldconfig> creates the necessary links and cache to the most recent shared "
"libraries found in the directories specified on the command line, in the "
"file I</etc/ld.so.conf>, and in the trusted directories (I</lib> and "
"I</usr/lib>).  The cache is used by the run-time linker, I<ld.so> or "
"I<ld-linux.so>.  B<ldconfig> checks the header and filenames of the "
"libraries it encounters when determining which versions should have their "
"links updated."
msgstr ""

#.  The following sentence looks suspect
#.  (perhaps historical cruft) -- MTK, Jul 2005
#.  Therefore, when making dynamic libraries,
#.  it is wise to explicitly link against libc (use \-lc).
#. type: Plain text
#: build/C/man8/ldconfig.8:79
msgid ""
"B<ldconfig> will attempt to deduce the type of ELF libs (i.e., libc5 or "
"libc6/glibc)  based on what C libs, if any, the library was linked against."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:100
msgid ""
"Some existing libs do not contain enough information to allow the deduction "
"of their type.  Therefore, the I</etc/ld.so.conf> file format allows the "
"specification of an expected type.  This is I<only> used for those ELF libs "
"which we can not work out.  The format is \"dirname=TYPE\", where TYPE can "
"be libc4, libc5, or libc6.  (This syntax also works on the command line.)  "
"Spaces are I<not> allowed.  Also see the B<-p> option.  B<ldconfig> should "
"normally be run by the superuser as it may require write permission on some "
"root owned directories and files."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:101
#, no-wrap
msgid "B<-v>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:107
msgid ""
"Verbose mode.  Print current version number, the name of each directory as "
"it is scanned, and any links that are created.  Overrides quiet mode."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:107
#, no-wrap
msgid "B<-n>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:118
msgid ""
"Only process directories specified on the command line.  Don't process the "
"trusted directories (I</lib> and I</usr/lib>)  nor those specified in "
"I</etc/ld.so.conf>.  Implies B<-N>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:118
#, no-wrap
msgid "B<-N>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:124
msgid ""
"Don't rebuild the cache.  Unless B<-X> is also specified, links are still "
"updated."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:124
#, no-wrap
msgid "B<-X>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:130
msgid ""
"Don't update links.  Unless B<-N> is also specified, the cache is still "
"rebuilt."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:130
#, no-wrap
msgid "B<-f conf>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:136
msgid "Use B<conf> instead of I</etc/ld.so.conf>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:136
#, no-wrap
msgid "B<-C cache>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:142
msgid "Use B<cache> instead of I</etc/ld.so.cache>."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:142
#, no-wrap
msgid "B<-r root>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:147
msgid "Change to and use I<root> as the root directory."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:147
#, no-wrap
msgid "B<-l>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:152
msgid ""
"Library mode.  Manually link individual libraries.  Intended for use by "
"experts only."
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:152
#, no-wrap
msgid "B<-p>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:156
msgid ""
"Print the lists of directories and candidate libraries stored in the current "
"cache."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:161
msgid "run-time linker/loader"
msgstr ""

#. type: TP
#: build/C/man8/ldconfig.8:161
#, no-wrap
msgid "I</etc/ld.so.conf>"
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:165
msgid ""
"File containing a list of colon, space, tab, newline, or comma-separated "
"directories in which to search for libraries."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:174
msgid ""
"File containing an ordered list of libraries found in the directories "
"specified in I</etc/ld.so.conf>, as well as those found in I</lib> and "
"I</usr/lib>."
msgstr ""

#. type: Plain text
#: build/C/man8/ldconfig.8:178
msgid "B<ldd>(1), B<ld.so>(8)"
msgstr ""

#. type: TH
#: build/C/man1/ldd.1:10
#, no-wrap
msgid "LDD"
msgstr ""

#. type: TH
#: build/C/man1/ldd.1:10
#, no-wrap
msgid "2000-10-30"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:13
msgid "ldd - print shared library dependencies"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:15
msgid "B<ldd> [OPTION]... FILE..."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:19
msgid ""
"B<ldd> prints the shared libraries required by each program or shared "
"library specified on the command line."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:20
#, no-wrap
msgid "B<--version>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:24
msgid "Print the version number of B<ldd>."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:24
#, no-wrap
msgid "B<-v\\ --verbose>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:28
msgid ""
"Print all information, including, for example, symbol versioning "
"information."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:28
#, no-wrap
msgid "B<-u\\ --unused>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:32
msgid "Print unused direct dependencies.  (Since glibc 2.3.4.)"
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:32
#, no-wrap
msgid "B<-d\\ --data-relocs>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:35
msgid "Perform relocations and report any missing objects (ELF only)."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:35
#, no-wrap
msgid "B<-r\\ --function-relocs>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:39
msgid ""
"Perform relocations for both data objects and functions, and report any "
"missing objects or functions (ELF only)."
msgstr ""

#. type: TP
#: build/C/man1/ldd.1:39
#, no-wrap
msgid "B<--help>"
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:42
msgid "Usage information."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:53
msgid ""
"The standard version of B<ldd> comes with glibc2.  Libc5 came with an older "
"version, still present on some systems.  The long options are not supported "
"by the libc5 version.  On the other hand, the glibc2 version does not "
"support B<-V> and only has the equivalent B<--version>."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:59
msgid ""
"The libc5 version of this program will use the name of a library given on "
"the command line as-is when it contains a \\(aq/\\(aq; otherwise it searches "
"for the library in the standard locations.  To run it on a shared library in "
"the current directory, prefix the name with \"./\"."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:62
msgid "B<ldd> does not work on a.out shared libraries."
msgstr ""

#.  .SH AUTHOR
#.  David Engel.
#.  Roland McGrath and Ulrich Drepper.
#. type: Plain text
#: build/C/man1/ldd.1:75
msgid ""
"B<ldd> does not work with some extremely old a.out programs which were built "
"before B<ldd> support was added to the compiler releases.  If you use B<ldd> "
"on one of these programs, the program will attempt to run with I<argc> = 0 "
"and the results will be unpredictable."
msgstr ""

#. type: Plain text
#: build/C/man1/ldd.1:78
msgid "B<ld.so>(8), B<ldconfig>(8)"
msgstr ""

#. type: TH
#: build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "RTLD-AUDIT"
msgstr ""

#. type: TH
#: build/C/man7/rtld-audit.7:26
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:29
msgid "rtld-audit - auditing API for the dynamic linker"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:31
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:33
msgid "B<#include E<lt>link.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:41
msgid ""
"The GNU dynamic linker (run-time linker)  provides an auditing API that "
"allows an application to be notified when various dynamic linking events "
"occur.  This API is very similar to the auditing interface provided by the "
"Solaris run-time linker.  The necessary constants and prototypes are defined "
"by including I<E<lt>link.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:48
msgid ""
"To use this interface, the programmer creates a shared library that "
"implements a standard set of function names.  Not all of the functions need "
"to be implemented: in most cases, if the programmer is not interested in a "
"particular class of auditing event, then no implementation needs to be "
"provided for the corresponding auditing function."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:56
msgid ""
"To employ the auditing interface, the environment variable B<LD_AUDIT> must "
"be defined to contain a colon-separated list of shared libraries, each of "
"which can implement (parts of) the auditing API.  When an auditable event "
"occurs, the corresponding function is invoked in each library, in the order "
"that the libraries are listed."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:56
#, no-wrap
msgid "la_version()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:60
#, no-wrap
msgid "B<unsigned int la_version(unsigned int >I<version>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:72
msgid ""
"This is the only function that I<must> be defined by an auditing library: it "
"performs the initial handshake between the dynamic linker and the auditing "
"library.  When invoking this function, the dynamic linker passes, in "
"I<version>, the highest version of the auditing interface that the linker "
"supports.  If necessary, the auditing library can check that this version is "
"sufficient for its requirements."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:81
msgid ""
"As its function result, this function should return the version of the "
"auditing interface that this auditing library expects to use (returning "
"I<version> is acceptable).  If the returned value is 0, or a version that is "
"greater than that supported by the dynamic linker, then the audit library is "
"ignored."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:81
#, no-wrap
msgid "la_objsearch()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:86
#, no-wrap
msgid ""
"B<char *la_objsearch(const char *>I<name>B<, uintptr_t *>I<cookie>B<,>\n"
"B<                   unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:97
msgid ""
"The dynamic linker invokes this function to inform the auditing library that "
"it is about to search for a shared object.  The I<name> argument is the "
"filename or pathname that is to be searched for.  I<cookie> identifies the "
"shared object that initiated the search.  I<flag> is set to one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:97
#, no-wrap
msgid "B<LA_SER_ORIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:106
msgid ""
"This is the original name that is being searched for.  Typically, this name "
"comes from an ELF B<DT_NEEDED> entry, or is the I<filename> argument given "
"to B<dlopen>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:106
#, no-wrap
msgid "B<LA_SER_LIBPATH>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:111
msgid "I<name> was created using a directory specified in B<LD_LIBRARY_PATH>."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:111
#, no-wrap
msgid "B<LA_SER_RUNPATH>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:119
msgid ""
"I<name> was created using a directory specified in an ELF B<DT_RPATH> or "
"B<DT_RUNPATH> list."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:119
#, no-wrap
msgid "B<LA_SER_CONFIG>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:126
msgid "I<name> was found via the B<ldconfig>(8)  cache (I</etc/ld.so.cache>)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:126
#, no-wrap
msgid "B<LA_SER_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:130
msgid "I<name> was found via a search of one of the default directories."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:130
#, no-wrap
msgid "B<LA_SER_SECURE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:134
msgid "I<name> is specific to a secure object (unused on Linux)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:143
msgid ""
"As its function result, B<la_objsearch>()  returns the pathname that the "
"dynamic linker should use for further processing.  If NULL is returned, then "
"this pathname is ignored for further processing.  If this audit library "
"simply intends to monitor search paths, then I<name> should be returned."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:143
#, no-wrap
msgid "la_activity()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:147
#, no-wrap
msgid "B<void la_activity( uintptr_t *>I<cookie>B<, unsigned int >I<flag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:156
msgid ""
"The dynamic linker calls this function to inform the auditing library that "
"link-map activity is occurring.  I<cookie> identifies the object at the head "
"of the link map.  When the dynamic linker invokes this function, I<flag> is "
"set to one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:156
#, no-wrap
msgid "B<LA_ACT_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:159
msgid "New objects are being added to the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:159
#, no-wrap
msgid "B<LA_ACT_DELETE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:162
msgid "Objects are being removed from the link map."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:162
#, no-wrap
msgid "B<LA_ACT_CONSISTENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:165
msgid "Link-map activity has been completed: the map is once again consistent."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:165
#, no-wrap
msgid "la_objopen()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:170
#, no-wrap
msgid ""
"B<unsigned int la_objopen(struct link_map *>I<map>B<, Lmid_t >I<lmid>B<,>\n"
"B<                        uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:179
msgid ""
"The dynamic linker calls this function when a new shared object is loaded.  "
"The I<map> argument is a pointer to a link-map structure that describes the "
"object.  The I<lmid> field has one of the following values"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:179
#, no-wrap
msgid "B<LM_ID_BASE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:182
msgid "Link map is part of the initial namespace."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:182
#, no-wrap
msgid "B<LM_ID_NEWLM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:186
msgid "Link map is part of a new namespace requested via B<dlmopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:194
msgid ""
"I<cookie> is a pointer to an identifier for this object.  The identifier is "
"provided to later calls to functions in the auditing library in order to "
"identify this object.  This identifier is initialized to point to object's "
"link map, but the audit library can change the identifier to some other "
"value that it may prefer to use to identify the object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:201
msgid ""
"As its return value, B<la_objopen>()  returns a bit mask created by ORing "
"zero or more of the following constants, which allow the auditing library to "
"select the objects to be monitored by B<la_symbind*>():"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:201
#, no-wrap
msgid "B<LA_FLG_BINDTO>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:204
msgid "Audit symbol bindings to this object."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:204
#, no-wrap
msgid "B<LA_FLG_BINDFROM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:207
msgid "Audit symbol bindings from this object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:211
msgid ""
"A return value of 0 from B<la_objopen>()  indicates that no symbol bindings "
"should be audited for this object."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:211
#, no-wrap
msgid "la_objclose()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:215
#, no-wrap
msgid "B<unsigned int la_objclose(uintptr_t *>I<cookie);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:224
msgid ""
"The dynamic linker invokes this function after any finalization code for the "
"object has been executed, before the object is unloaded.  The I<cookie> "
"argument is the identifier obtained from a previous invocation of "
"B<la_objopen>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:228
msgid ""
"In the current implementation, the value returned by B<la_objclose>()  is "
"ignored."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:228
#, no-wrap
msgid "la_preinit()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:232
#, no-wrap
msgid "B<void la_preinit(uintptr_t *>I<cookie>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:242
msgid ""
"The dynamic linker invokes this function after all shared objects have been "
"loaded, before control is passed to the application (i.e., before calling "
"I<main>()).  Note that I<main>()  may still later dynamically load objects "
"using B<dlopen>(3)."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:242
#, no-wrap
msgid "la_symbind*()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:251
#, no-wrap
msgid ""
"B<uintptr_t la_symbind32(Elf32_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t "
"*>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char "
"*>I<symname>B<);>\n"
"B<uintptr_t la_symbind64(Elf64_Sym *>I<sym>B<, unsigned int >I<ndx>B<,>\n"
"B<                       uintptr_t *>I<refcook>B<, uintptr_t "
"*>I<defcook>B<,>\n"
"B<                       unsigned int *>I<flags>B<, const char "
"*>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:263
msgid ""
"The dynamic linker invokes one of these functions when a symbol binding "
"occurs between two shared objects that have been marked for auditing "
"notification by B<la_objopen>().  The B<la_symbind32>()  function is "
"employed on 32-bit platforms; the B<la_symbind64>()  function is employed on "
"64-bit platforms."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:273
msgid ""
"The I<sym> argument is a pointer to a structure that provides information "
"about the symbol being bound.  The structure definition is shown in "
"I<E<lt>elf.hE<gt>>.  Among the fields of this structure, I<st_value> "
"indicates the address to which the symbol is bound."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:278
msgid ""
"The I<ndx> argument gives the index of the symbol in the symbol table of the "
"bound shared object."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:293
msgid ""
"The I<refcook> argument identifies the shared object that is making the "
"symbol reference; this is the same identifier that is provided to the "
"B<la_objopen>()  function that returned B<LA_FLG_BINDFROM>.  The I<defcook> "
"argument identifies the shared object that defines the referenced symbol; "
"this is the same identifier that is provided to the B<la_objopen>()  "
"function that returned B<LA_FLG_BINDTO>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:297
msgid "The I<symname> argument points a string containing the name of the symbol."
msgstr ""

#.  LA_SYMB_STRUCTCALL appears to be unused
#. type: Plain text
#: build/C/man7/rtld-audit.7:305
msgid ""
"The I<flags> argument is a bit mask that both provides information about the "
"symbol and can be used to modify further auditing of this PLT (Procedure "
"Linkage Table) entry.  The dynamic linker may supply the following bit "
"values in this argument:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:305
#, no-wrap
msgid "B<LA_SYMB_DLSYM>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:309
msgid "The binding resulted from a call to B<dlsym>(3)."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:309
#, no-wrap
msgid "B<LA_SYMB_ALTVALUE>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:314
msgid ""
"A previous B<la_symbind*>()  call returned an alternate value for this "
"symbol."
msgstr ""

#.  pltenter/pltexit are called for non-dynamically loaded libraries,
#.  but don't seem to be called for dynamically loaded libs?
#.  Is this the same on Solaris?
#. type: Plain text
#: build/C/man7/rtld-audit.7:328
msgid ""
"By default, if the auditing library implements B<la_pltenter>()  and "
"B<la_pltexit>()  functions (see below), then these functions are invoked, "
"after B<la_symbind>(), for PLT entries, each time the symbol is referenced.  "
"The following flags can be ORed into I<*flags> to change this default "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:328
#, no-wrap
msgid "B<LA_SYMB_NOPLTENTER>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:333
msgid "Don't call B<la_pltenter>()  for this symbol."
msgstr ""

#. type: TP
#: build/C/man7/rtld-audit.7:333
#, no-wrap
msgid "B<LA_SYMB_NOPLTEXIT>"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:338
msgid "Don't call B<la_pltexit>()  for this symbol."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:349
msgid ""
"The return value of B<la_symbind32>()  and B<la_symbind64>()  is the address "
"to which control should be passed after the function returns.  If the "
"auditing library is simply monitoring symbol bindings, then it should return "
"I<sym-E<gt>st_name>.  A different value may be returned if the library "
"wishes to direct control to an alternate location."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:349
#, no-wrap
msgid "la_pltenter()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:355 build/C/man7/rtld-audit.7:415
msgid ""
"The precise name and argument types for this function depend on the hardware "
"platform.  (The appropriate definition is supplied by I<E<lt>link.hE<gt>>.)  "
"Here is the definition for x86-32:"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:361
#, no-wrap
msgid ""
"B<Elf32_Addr la_i86_gnu_pltenter(Elf32_Sym *>I<sym>B<, unsigned int "
">I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 La_i86_regs *>I<regs>B<, unsigned int *>I<flags>B<,>\n"
"B<                 const char *>I<symname>B<, long int "
"*>I<framesizep>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:365
msgid ""
"This function is invoked just before a PLT entry is called, between two "
"shared objects that have been marked for binding notification."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:375 build/C/man7/rtld-audit.7:438
msgid ""
"The I<sym>, I<ndx>, I<refcook>, I<defcook>, and I<symname> are as for "
"B<la_symbind*>()."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:382
msgid ""
"The I<regs> argument points to a structure (defined in I<E<lt>link.hE<gt>>)  "
"containing the values of registers to be used for the call to this PLT "
"entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:388
msgid ""
"The I<flags> argument points to a bit mask that conveys information about, "
"and can be used to modify subsequent auditing of, this PLT entry, as for "
"B<la_symbind*>()."
msgstr ""

#.  FIXME is the following correct?
#. type: Plain text
#: build/C/man7/rtld-audit.7:404
msgid ""
"The I<framesizep> argument points to a I<long\\ int> buffer that can be used "
"to explicitly set the frame size used for the call to this PLT entry.  If "
"different B<la_pltenter>()  invocations for this symbol return different "
"values, then the maximum returned value is used.  The B<la_pltenter>()  "
"function is only called if this buffer is explicitly set to a suitable "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:409
msgid "The return value of B<la_pltenter>()  is as for B<la_symbind*>()."
msgstr ""

#. type: SS
#: build/C/man7/rtld-audit.7:409
#, no-wrap
msgid "la_pltexit()"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:421
#, no-wrap
msgid ""
"B<unsigned int la_i86_gnu_pltexit(Elf32_Sym *>I<sym>B<, unsigned int "
">I<ndx>B<,>\n"
"B<                 uintptr_t *>I<refcook>B<, uintptr_t *>I<defcook>B<,>\n"
"B<                 const La_i86_regs *>I<inregs>B<, La_i86_retval "
"*>I<outregs>B<,>\n"
"B<                 const char *>I<symname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:428
msgid ""
"This function is called when a PLT entry, made between two shared objects "
"that have been marked for binding notification, returns.  The function is "
"called just before control returns to the caller of the PLT entry."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:451
msgid ""
"The I<inregs> argument points to a structure (defined in "
"I<E<lt>link.hE<gt>>)  containing the values of registers used for the call "
"to this PLT entry.  The I<outregs> argument points to a structure (defined "
"in I<E<lt>link.hE<gt>>)  containing return values for the call to this PLT "
"entry.  These values can be modified by the caller, and the changes will be "
"visible to the caller of the PLT entry."
msgstr ""

#.  This differs from Solaris, where an audit library that monitors
#.  symbol binding should return the value of the 'retval' argument
#.  (not provided by GNU, but equivalent to returning outregs->lrv_eax
#.  on (say) x86-32).
#. type: Plain text
#: build/C/man7/rtld-audit.7:459
msgid ""
"In the current GNU implementation, the return value of B<la_pltexit>()  is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:465
msgid ""
"This API is nonstandard, but very similar to the Solaris API, described in "
"the Solaris I<Linker and Libraries Guide>, in the chapter I<Runtime Linker "
"Auditing Interface>."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:468
msgid "Note the following differences from the Solaris dynamic linker auditing API:"
msgstr ""

#. type: IP
#: build/C/man7/rtld-audit.7:468 build/C/man7/rtld-audit.7:472 build/C/man7/rtld-audit.7:480
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:472
msgid ""
"The Solaris B<la_objfilter>()  interface is not supported by the GNU "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:480
msgid ""
"The Solaris B<la_symbind32>()  and B<la_pltexit>()  functions do not provide "
"a I<symname> argument."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:490
msgid ""
"The Solaris B<la_pltexit>()  function does not provide I<inregs> and "
"I<outregs> arguments (but does provide a I<retval> argument with the "
"function return value)."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:494
#, no-wrap
msgid ""
"#include E<lt>link.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:499
#, no-wrap
msgid ""
"unsigned int\n"
"la_version(unsigned int version)\n"
"{\n"
"    printf(\"la_version(): %d\\en\", version);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:502
#, no-wrap
msgid ""
"    return version;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:515
#, no-wrap
msgid ""
"char *\n"
"la_objsearch(const char *name, uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_objsearch(): name = %s; cookie = %x\", name, cookie);\n"
"    printf(\"; flag = %s\\en\",\n"
"            (flag == LA_SER_ORIG) ?    \"LA_SER_ORIG\" :\n"
"            (flag == LA_SER_LIBPATH) ? \"LA_SER_LIBPATH\" :\n"
"            (flag == LA_SER_RUNPATH) ? \"LA_SER_RUNPATH\" :\n"
"            (flag == LA_SER_DEFAULT) ? \"LA_SER_DEFAULT\" :\n"
"            (flag == LA_SER_CONFIG) ?  \"LA_SER_CONFIG\" :\n"
"            (flag == LA_SER_SECURE) ?  \"LA_SER_SECURE\" :\n"
"            \"???\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:518
#, no-wrap
msgid ""
"    return name;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:528
#, no-wrap
msgid ""
"void\n"
"la_activity (uintptr_t *cookie, unsigned int flag)\n"
"{\n"
"    printf(\"la_activity(): cookie = %x; flag = %s\\en\", cookie,\n"
"            (flag == LA_ACT_CONSISTENT) ? \"LA_ACT_CONSISTENT\" :\n"
"            (flag == LA_ACT_ADD) ?        \"LA_ACT_ADD\" :\n"
"            (flag == LA_ACT_DELETE) ?     \"LA_ACT_DELETE\" :\n"
"            \"???\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:538
#, no-wrap
msgid ""
"unsigned int\n"
"la_objopen(struct link_map *map, Lmid_t lmid, uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objopen(): loading \\e\"%s\\e\"; lmid = %s; "
"cookie=%x\\en\",\n"
"            map-E<gt>l_name,\n"
"            (lmid == LM_ID_BASE) ?  \"LM_ID_BASE\" :\n"
"            (lmid == LM_ID_NEWLM) ? \"LM_ID_NEWLM\" :\n"
"            \"???\",\n"
"            cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:541
#, no-wrap
msgid ""
"    return LA_FLG_BINDTO | LA_FLG_BINDFROM;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:546
#, no-wrap
msgid ""
"unsigned int\n"
"la_objclose (uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_objclose(): %x\\en\", cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:549
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:555
#, no-wrap
msgid ""
"void\n"
"la_preinit(uintptr_t *cookie)\n"
"{\n"
"    printf(\"la_preinit(): %x\\en\", cookie);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:564
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind32(Elf32_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind32(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %x; defcook = %x\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:567 build/C/man7/rtld-audit.7:579 build/C/man7/rtld-audit.7:589
#, no-wrap
msgid ""
"    return sym-E<gt>st_value;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:576
#, no-wrap
msgid ""
"uintptr_t\n"
"la_symbind64(Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,\n"
"        uintptr_t *defcook, unsigned int *flags, const char *symname)\n"
"{\n"
"    printf(\"la_symbind64(): symname = %s; sym-E<gt>st_value = %p\\en\",\n"
"            symname, sym-E<gt>st_value);\n"
"    printf(\"        ndx = %d; flags = 0x%x\", ndx, *flags);\n"
"    printf(\"; refcook = %x; defcook = %x\\en\", refcook, defcook);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:586
#, no-wrap
msgid ""
"Elf32_Addr\n"
"la_i86_gnu_pltenter(Elf32_Sym *sym, unsigned int ndx,\n"
"        uintptr_t *refcook, uintptr_t *defcook, La_i86_regs *regs,\n"
"        unsigned int *flags, const char *symname, long int *framesizep)\n"
"{\n"
"    printf(\"la_i86_gnu_pltenter(): %s (%p)\\en\", symname, "
"sym-E<gt>st_value);\n"
msgstr ""

#.  FIXME Specifying multiple audit libraries doesn't work on GNU.
#.  My simple tests on Solaris work okay, but not on Linux -- mtk, Jan 2009
#.  glibc bug filed: http://sourceware.org/bugzilla/show_bug.cgi?id=9733
#.  Reportedly, this is fixed on 16 Mar 2009 (i.e., for glibc 2.10)
#. type: Plain text
#: build/C/man7/rtld-audit.7:600
msgid ""
"In glibc versions up to and include 2.9, specifying more than one audit "
"library in B<LD_AUDIT> results in a run-time crash.  This is reportedly "
"fixed in glibc 2.10."
msgstr ""

#. type: Plain text
#: build/C/man7/rtld-audit.7:605
msgid "B<ldd>(1), B<dlopen>(3), B<ld.so>(8), B<ldconfig>(8)"
msgstr ""

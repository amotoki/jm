# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-24 00:51+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsearch.3:31
#, no-wrap
msgid "BSEARCH"
msgstr ""

#. type: TH
#: build/C/man3/bsearch.3:31
#, no-wrap
msgid "2003-11-01"
msgstr ""

#. type: TH
#: build/C/man3/bsearch.3:31 build/C/man3/hsearch.3:35 build/C/man3/insque.3:36 build/C/man3/lsearch.3:26 build/C/man3/qsort.3:37 build/C/man3/tsearch.3:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:32 build/C/man3/hsearch.3:36 build/C/man3/insque.3:37 build/C/man3/lsearch.3:27 build/C/man3/qsort.3:38 build/C/man3/tsearch.3:26
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:34
msgid "bsearch - binary search of a sorted array"
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:34 build/C/man3/hsearch.3:39 build/C/man3/insque.3:39 build/C/man3/lsearch.3:29 build/C/man3/qsort.3:40 build/C/man3/tsearch.3:28
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:37 build/C/man3/qsort.3:43
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:41
#, no-wrap
msgid ""
"B<void *bsearch(const void *>I<key>B<, const void *>I<base>B<,>\n"
"B<              size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<              int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:42 build/C/man3/hsearch.3:60 build/C/man3/insque.3:61 build/C/man3/lsearch.3:39 build/C/man3/qsort.3:61 build/C/man3/tsearch.3:51
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:56
msgid ""
"The B<bsearch>()  function searches an array of I<nmemb> objects, the "
"initial member of which is pointed to by I<base>, for a member that matches "
"the object pointed to by I<key>.  The size of each member of the array is "
"specified by I<size>."
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:70
msgid ""
"The contents of the array should be in ascending sorted order according to "
"the comparison function referenced by I<compar>.  The I<compar> routine is "
"expected to have two arguments which point to the I<key> object and to an "
"array member, in that order, and should return an integer less than, equal "
"to, or greater than zero if the I<key> object is found, respectively, to be "
"less than, to match, or be greater than the array member."
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:70 build/C/man3/hsearch.3:174 build/C/man3/lsearch.3:72 build/C/man3/qsort.3:91 build/C/man3/tsearch.3:167
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:77
msgid ""
"The B<bsearch>()  function returns a pointer to a matching member of the "
"array, or NULL if no match is found.  If there are multiple elements that "
"match the key, the element returned is unspecified."
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:77 build/C/man3/hsearch.3:246 build/C/man3/insque.3:99 build/C/man3/lsearch.3:80 build/C/man3/qsort.3:100 build/C/man3/tsearch.3:190
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:79
msgid "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:79 build/C/man3/hsearch.3:293 build/C/man3/insque.3:134 build/C/man3/qsort.3:116 build/C/man3/tsearch.3:212
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:84
msgid ""
"The example below first sorts an array of structures using B<qsort>(3), then "
"retrieves desired elements using B<bsearch>()."
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:89 build/C/man3/qsort.3:127
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:98
#, no-wrap
msgid ""
"struct mi {\n"
"    int nr;\n"
"    char *name;\n"
"} months[] = {\n"
"    { 1, \"jan\" }, { 2, \"feb\" }, { 3, \"mar\" }, { 4, \"apr\" },\n"
"    { 5, \"may\" }, { 6, \"jun\" }, { 7, \"jul\" }, { 8, \"aug\" },\n"
"    { 9, \"sep\" }, {10, \"oct\" }, {11, \"nov\" }, {12, \"dec\" }\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:100
#, no-wrap
msgid "#define nr_of_months (sizeof(months)/sizeof(months[0]))\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:108
#, no-wrap
msgid ""
"static int\n"
"compmi(const void *m1, const void *m2)\n"
"{\n"
"    struct mi *mi1 = (struct mi *) m1;\n"
"    struct mi *mi2 = (struct mi *) m2;\n"
"    return strcmp(mi1-E<gt>name, mi2-E<gt>name);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:113
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:127
#, no-wrap
msgid ""
"    qsort(months, nr_of_months, sizeof(struct mi), compmi);\n"
"    for (i = 1; i E<lt> argc; i++) {\n"
"        struct mi key, *res;\n"
"        key.name = argv[i];\n"
"        res = bsearch(&key, months, nr_of_months,\n"
"                      sizeof(struct mi), compmi);\n"
"        if (res == NULL)\n"
"            printf(\"\\(aq%s\\(aq: unknown month\\en\", argv[i]);\n"
"        else\n"
"            printf(\"%s: month #%d\\en\", res-E<gt>name, res-E<gt>nr);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:129 build/C/man3/hsearch.3:343 build/C/man3/lsearch.3:85 build/C/man3/qsort.3:155 build/C/man3/tsearch.3:289
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:134
msgid "B<hsearch>(3), B<lsearch>(3), B<qsort>(3), B<tsearch>(3)"
msgstr ""

#. type: SH
#: build/C/man3/bsearch.3:134 build/C/man3/hsearch.3:348 build/C/man3/insque.3:244 build/C/man3/lsearch.3:89 build/C/man3/qsort.3:160 build/C/man3/tsearch.3:294
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/bsearch.3:141 build/C/man3/hsearch.3:355 build/C/man3/insque.3:251 build/C/man3/lsearch.3:96 build/C/man3/qsort.3:167 build/C/man3/tsearch.3:301
msgid ""
"This page is part of release 3.65 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/hsearch.3:35
#, no-wrap
msgid "HSEARCH"
msgstr ""

#. type: TH
#: build/C/man3/hsearch.3:35 build/C/man3/tsearch.3:25
#, no-wrap
msgid "2014-01-05"
msgstr ""

#. type: TH
#: build/C/man3/hsearch.3:35 build/C/man3/lsearch.3:26 build/C/man3/tsearch.3:25
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:39
msgid ""
"hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r, hsearch_r - hash table "
"management"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:42 build/C/man3/hsearch.3:52 build/C/man3/insque.3:42 build/C/man3/lsearch.3:32 build/C/man3/tsearch.3:31 build/C/man3/tsearch.3:48
#, no-wrap
msgid "B<#include E<lt>search.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:44
#, no-wrap
msgid "B<int hcreate(size_t >I<nel>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:46
#, no-wrap
msgid "B<ENTRY *hsearch(ENTRY >I<item>B<, ACTION >I<action>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:48
#, no-wrap
msgid "B<void hdestroy(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:50 build/C/man3/tsearch.3:46
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:54
#, no-wrap
msgid "B<int hcreate_r(size_t >I<nel>B<, struct hsearch_data *>I<htab>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:57
#, no-wrap
msgid ""
"B<int hsearch_r(ENTRY >I<item>B<, ACTION >I<action>B<, ENTRY "
"**>I<retval>B<,>\n"
"B<              struct hsearch_data *>I<htab>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:59
#, no-wrap
msgid "B<void hdestroy_r(struct hsearch_data *>I<htab>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:69
msgid ""
"The three functions B<hcreate>(), B<hsearch>(), and B<hdestroy>()  allow the "
"caller to create and manage a hash search table containing entries "
"consisting of a key (a string) and associated data.  Using these functions, "
"only one hash table can be used at a time."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:83
msgid ""
"The three functions B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>()  are "
"reentrant versions that allow a program to use more than one hash search "
"table at the same time.  The last argument, I<htab>, points to a structure "
"that describes the table on which the function is to operate.  The "
"programmer should treat this structure as opaque (i.e., do not attempt to "
"directly access or modify the fields in this structure)."
msgstr ""

#.  e.g., in glibc it is raised to the next higher prime number
#. type: Plain text
#: build/C/man3/hsearch.3:92
msgid ""
"First a hash table must be created using B<hcreate>().  The argument I<nel> "
"specifies the maximum number of entries in the table.  (This maximum cannot "
"be changed later, so choose it wisely.)  The implementation may adjust this "
"value upward to improve the performance of the resulting hash table."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:103
msgid ""
"The B<hcreate_r>()  function performs the same task as B<hcreate>(), but for "
"the table described by the structure I<*htab>.  The structure pointed to by "
"I<htab> must be zeroed before the first call to B<hcreate_r>()."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:118
msgid ""
"The function B<hdestroy>()  frees the memory occupied by the hash table that "
"was created by B<hcreate>().  After calling B<hdestroy>()  a new hash table "
"can be created using B<hcreate>().  The B<hdestroy_r>()  function performs "
"the analogous task for a hash table described by I<*htab>, which was "
"previously created using B<hcreate_r>()."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:125
msgid ""
"The B<hsearch>()  function searches the hash table for an item with the same "
"key as I<item> (where \"the same\" is determined using B<strcmp>(3)), and if "
"successful returns a pointer to it."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:128
msgid ""
"The argument I<item> is of type I<ENTRY>, which is defined in "
"I<E<lt>search.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:135
#, no-wrap
msgid ""
"typedef struct entry {\n"
"    char *key;\n"
"    void *data;\n"
"} ENTRY;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:141
msgid ""
"The field I<key> points to a null-terminated string which is the search "
"key.  The field I<data> points to data that is associated with that key."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:160
msgid ""
"The argument I<action> determines what B<hsearch>()  does after an "
"unsuccessful search.  This argument must either have the value B<ENTER>, "
"meaning insert a copy of I<item> (and return a pointer to the new hash table "
"entry as the function result), or the value B<FIND>, meaning that NULL "
"should be returned.  (If I<action> is B<FIND>, then I<data> is ignored.)"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:174
msgid ""
"The B<hsearch_r>()  function is like B<hsearch>()  but operates on the hash "
"table described by I<*htab>.  The B<hsearch_r>()  function differs from "
"B<hsearch>()  in that a pointer to the found item is returned in I<*retval>, "
"rather than as the function result."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:182
msgid ""
"B<hcreate>()  and B<hcreate_r>()  return nonzero on success.  They return 0 "
"on error, with I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:196
msgid ""
"On success, B<hsearch>()  returns a pointer to an entry in the hash table.  "
"B<hsearch>()  returns NULL on error, that is, if I<action> is B<ENTER> and "
"the hash table is full, or I<action> is B<FIND> and I<item> cannot be found "
"in the hash table.  B<hsearch_r>()  returns nonzero on success, and 0 on "
"error.  In the event of an error, these two functions set I<errno> to "
"indicate the cause of the error."
msgstr ""

#. type: SH
#: build/C/man3/hsearch.3:196
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:202
msgid "B<hcreate_r>()  and B<hdestroy_r>()  can fail for the following reasons:"
msgstr ""

#. type: TP
#: build/C/man3/hsearch.3:202
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:206
msgid "I<htab> is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:211
msgid "B<hsearch>()  and B<hsearch_r>()  can fail for the following reasons:"
msgstr ""

#. type: TP
#: build/C/man3/hsearch.3:211
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:219
msgid ""
"I<action> was B<ENTER>, I<key> was not found in the table, and there was no "
"room in the table to add a new entry."
msgstr ""

#. type: TP
#: build/C/man3/hsearch.3:219
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:227
msgid "I<action> was B<FIND>, and I<key> was not found in the table."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:231
msgid "POSIX.1-2001 specifies only the B<ENOMEM> error."
msgstr ""

#. type: SH
#: build/C/man3/hsearch.3:231
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: SS
#: build/C/man3/hsearch.3:232
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:239
msgid ""
"The B<hcreate>(), B<hsearch>(), and B<hdestroy>()  functions use a global "
"space for storing the table, so they are not thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:246
msgid ""
"The B<hcreate_r>(), B<hsearch_r>(), and B<hdestroy_r>()  functions are "
"thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:259
msgid ""
"The functions B<hcreate>(), B<hsearch>(), and B<hdestroy>()  are from SVr4, "
"and are described in POSIX.1-2001.  The functions B<hcreate_r>(), "
"B<hsearch_r>(), and B<hdestroy_r>()  are GNU extensions."
msgstr ""

#. type: SH
#: build/C/man3/hsearch.3:259 build/C/man3/insque.3:101 build/C/man3/qsort.3:104 build/C/man3/tsearch.3:195
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:266
msgid ""
"Hash table implementations are usually more efficient when the table "
"contains enough free space to minimize collisions.  Typically, this means "
"that I<nel> should be at least 25% larger than the maximum number of "
"elements that the caller expects to store in the table."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:284
msgid ""
"The B<hdestroy>()  and B<hdestroy_r>()  functions do not free the buffers "
"pointed to by the I<key> and I<data> elements of the hash table entries.  "
"(It can't do this because it doesn't know whether these buffers were "
"allocated dynamically.)  If these buffers need to be freed (perhaps because "
"the program is repeatedly creating and destroying hash tables, rather than "
"creating a single table whose lifetime matches that of the program), then "
"the program must maintain bookkeeping data structures that allow it to free "
"them."
msgstr ""

#. type: SH
#: build/C/man3/hsearch.3:284 build/C/man3/insque.3:127 build/C/man3/lsearch.3:83
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:291
msgid ""
"SVr4 and POSIX.1-2001 specify that I<action> is significant only for "
"unsuccessful searches, so that an B<ENTER> should not do anything for a "
"successful search.  In libc and glibc (before version 2.3), the "
"implementation violates the specification, updating the I<data> for the "
"given I<key> in this case."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:293
msgid "Individual hash table entries can be added, but not deleted."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:297
msgid ""
"The following program inserts 24 items into a hash table, then prints some "
"of them."
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:302
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:309
#, no-wrap
msgid ""
"static char *data[] = { \"alpha\", \"bravo\", \"charlie\", \"delta\",\n"
"     \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n"
"     \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\",\n"
"     \"quebec\", \"romeo\", \"sierra\", \"tango\", \"uniform\",\n"
"     \"victor\", \"whisky\", \"x-ray\", \"yankee\", \"zulu\"\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:315
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    ENTRY e, *ep;\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:317
#, no-wrap
msgid "    hcreate(30);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:330
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> 24; i++) {\n"
"        e.key = data[i];\n"
"        /* data is just an integer, instead of a\n"
"           pointer to something */\n"
"        e.data = (void *) i;\n"
"        ep = hsearch(e, ENTER);\n"
"        /* there should be no failures */\n"
"        if (ep == NULL) {\n"
"            fprintf(stderr, \"entry failed\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:342
#, no-wrap
msgid ""
"    for (i = 22; i E<lt> 26; i++) {\n"
"        /* print two entries from the table, and\n"
"           show that two are not in the table */\n"
"        e.key = data[i];\n"
"        ep = hsearch(e, FIND);\n"
"        printf(\"%9.9s -E<gt> %9.9s:%d\\en\", e.key,\n"
"               ep ? ep-E<gt>key : \"NULL\", ep ? (int)(ep-E<gt>data) : 0);\n"
"    }\n"
"    hdestroy();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/hsearch.3:348
msgid "B<bsearch>(3), B<lsearch>(3), B<malloc>(3), B<tsearch>(3)"
msgstr ""

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "INSQUE"
msgstr ""

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "2010-09-09"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:39
msgid "insque, remque - insert/remove an item from a queue"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:44
#, no-wrap
msgid "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:46
#, no-wrap
msgid "B<void remque(void *>I<elem>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:51 build/C/man3/qsort.3:55
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:56
msgid "B<insque>(), B<remque>():"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:59
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:73
msgid ""
"The B<insque>()  and B<remque>()  functions manipulate doubly-linked lists.  "
"Each element in the list is a structure of which the first two elements are "
"a forward and a backward pointer.  The linked list may be linear (i.e., NULL "
"forward pointer at the end of the list and NULL backward pointer at the "
"start of the list)  or circular."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:78
msgid ""
"The B<insque>()  function inserts the element pointed to by I<elem> "
"immediately after the element pointed to by I<prev>."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:85
msgid ""
"If the list is linear, then the call I<insque(elem, NULL)> can be used to "
"insert the initial list element, and the call sets the forward and backward "
"pointers of I<elem> to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:94
msgid ""
"If the list is circular, the caller should ensure that the forward and "
"backward pointers of the first element are initialized to point to that "
"element, and the I<prev> argument of the B<insque>()  call should also point "
"to the element."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:99
msgid ""
"The B<remque>()  function removes the element pointed to by I<elem> from the "
"doubly-linked list."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:101
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:105
msgid ""
"Traditionally (e.g., SunOS, Linux libc 4 and libc 5), the arguments of these "
"functions were of type I<struct qelem *>, defined as:"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:113
#, no-wrap
msgid ""
"struct qelem {\n"
"    struct qelem *q_forw;\n"
"    struct qelem *q_back;\n"
"    char          q_data[1];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:120
msgid ""
"This is still what you will get if B<_GNU_SOURCE> is defined before "
"including I<E<lt>search.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:127
msgid ""
"The location of the prototypes for these functions differs among several "
"versions of UNIX.  The above is the POSIX version.  Some systems place them "
"in I<E<lt>string.hE<gt>>.  Linux libc4 and libc 5 placed them in "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:134
msgid ""
"In glibc 2.4 and earlier, it was not possible to specify I<prev> as NULL.  "
"Consequently, to build a linear list, the caller had to build a list using "
"an initial call that contained the first two elements of the list, with the "
"forward and backward pointers in each element suitably initialized."
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:138
msgid ""
"The program below demonstrates the use of B<insque>().  Here is an example "
"run of the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:147
#, no-wrap
msgid ""
"$ B<./a.out -c a b c>\n"
"Traversing completed list:\n"
"    a\n"
"    b\n"
"    c\n"
"That was a circular list\n"
msgstr ""

#. type: SS
#: build/C/man3/insque.3:149
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:156
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:162
#, no-wrap
msgid ""
"struct element {\n"
"    struct element *forward;\n"
"    struct element *backward;\n"
"    char *name;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:167
#, no-wrap
msgid ""
"static struct element *\n"
"new_element(void)\n"
"{\n"
"    struct element *e;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:173
#, no-wrap
msgid ""
"    e = malloc(sizeof(struct element));\n"
"    if (e == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:176
#, no-wrap
msgid ""
"    return e;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct element *first, *elem, *prev;\n"
"    int circular, opt, errfnd;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:185
#, no-wrap
msgid ""
"    /* The \"-c\" command-line option can be used to specify that the\n"
"       list is circular */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:198
#, no-wrap
msgid ""
"    errfnd = 0;\n"
"    circular = 0;\n"
"    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
"        switch (opt) {\n"
"        case 'c':\n"
"            circular = 1;\n"
"            break;\n"
"        default:\n"
"            errfnd = 1;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:203
#, no-wrap
msgid ""
"    if (errfnd || optind E<gt>= argc) {\n"
"        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:205
#, no-wrap
msgid "    /* Create first element and place it in the linked list */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:208
#, no-wrap
msgid ""
"    elem = new_element();\n"
"    first = elem;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:210
#, no-wrap
msgid "    elem-E<gt>name = argv[optind];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:218
#, no-wrap
msgid ""
"    if (circular) {\n"
"        elem-E<gt>forward = elem;\n"
"        elem-E<gt>backward = elem;\n"
"        insque(elem, elem);\n"
"    } else {\n"
"        insque(elem, NULL);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:220
#, no-wrap
msgid "    /* Add remaining command-line arguments as list elements */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:223
#, no-wrap
msgid ""
"    while (++optind E<lt> argc) {\n"
"        prev = elem;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:228
#, no-wrap
msgid ""
"        elem = new_element();\n"
"        elem-E<gt>name = argv[optind];\n"
"        insque(elem, prev);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:230
#, no-wrap
msgid "    /* Traverse the list from the start, printing element names */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:237
#, no-wrap
msgid ""
"    printf(\"Traversing completed list:\\en\");\n"
"    elem = first;\n"
"    do {\n"
"        printf(\"    %s\\en\", elem-E<gt>name);\n"
"        elem = elem-E<gt>forward;\n"
"    } while (elem != NULL && elem != first);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:240
#, no-wrap
msgid ""
"    if (elem == first)\n"
"        printf(\"That was a circular list\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/insque.3:243
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: TH
#: build/C/man3/lsearch.3:26
#, no-wrap
msgid "LSEARCH"
msgstr ""

#. type: TH
#: build/C/man3/lsearch.3:26
#, no-wrap
msgid "1999-09-27"
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:29
msgid "lfind, lsearch - linear search of an array"
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:35
#, no-wrap
msgid ""
"B<void *lfind(const void *>I<key>B<, const void *>I<base>B<, size_t "
"*>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void "
"*));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:38
#, no-wrap
msgid ""
"B<void *lsearch(const void *>I<key>B<, void *>I<base>B<, size_t "
"*>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void "
"*));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:61
msgid ""
"B<lfind>()  and B<lsearch>()  perform a linear search for I<key> in the "
"array I<base> which has I<*nmemb> elements of I<size> bytes each.  The "
"comparison function referenced by I<compar> is expected to have two "
"arguments which point to the I<key> object and to an array member, in that "
"order, and which returns zero if the I<key> object matches the array member, "
"and nonzero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:72
msgid ""
"If B<lsearch>()  does not find a matching element, then the I<key> object is "
"inserted at the end of the table, and I<*nmemb> is incremented.  In "
"particular, one should know that a matching element exists, or that more "
"room is available."
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:80
msgid ""
"B<lfind>()  returns a pointer to a matching member of the array, or NULL if "
"no match is found.  B<lsearch>()  returns a pointer to a matching member of "
"the array, or to the newly added member if no match is found."
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:83
msgid "SVr4, 4.3BSD, POSIX.1-2001.  Present in libc since libc-4.6.27."
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:85
msgid "The naming is unfortunate."
msgstr ""

#. type: Plain text
#: build/C/man3/lsearch.3:89
msgid "B<bsearch>(3), B<hsearch>(3), B<tsearch>(3)"
msgstr ""

#. type: TH
#: build/C/man3/qsort.3:37
#, no-wrap
msgid "QSORT"
msgstr ""

#. type: TH
#: build/C/man3/qsort.3:37
#, no-wrap
msgid "2012-03-08"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:40
msgid "qsort, qsort_r - sort an array"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:46
#, no-wrap
msgid ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:50
#, no-wrap
msgid ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *, void *),>\n"
"B<           void *>I<arg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:60
msgid "B<qsort_r>(): _GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:68
msgid ""
"The B<qsort>()  function sorts an array with I<nmemb> elements of size "
"I<size>.  The I<base> argument points to the start of the array."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:72
msgid ""
"The contents of the array are sorted in ascending order according to a "
"comparison function pointed to by I<compar>, which is called with two "
"arguments that point to the objects being compared."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:78
msgid ""
"The comparison function must return an integer less than, equal to, or "
"greater than zero if the first argument is considered to be respectively "
"less than, equal to, or greater than the second.  If two members compare as "
"equal, their order in the sorted array is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:91
msgid ""
"The B<qsort_r>()  function is identical to B<qsort>()  except that the "
"comparison function I<compar> takes a third argument.  A pointer is passed "
"to the comparison function via I<arg>.  In this way, the comparison function "
"does not need to use global variables to pass through arbitrary arguments, "
"and is therefore reentrant and safe to use in threads."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:97
msgid "The B<qsort>()  and B<qsort_r>()  functions return no value."
msgstr ""

#. type: SH
#: build/C/man3/qsort.3:97
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:100
msgid "B<qsort_r>()  was added to glibc in version 2.8."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:104
msgid "The B<qsort>()  function conforms to SVr4, 4.3BSD, C89, C99."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:116
msgid ""
"Library routines suitable for use as the I<compar> argument to B<qsort>()  "
"include B<alphasort>(3)  and B<versionsort>(3).  To compare C strings, the "
"comparison function can call B<strcmp>(3), as shown in the example below."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:119
msgid "For one example of use, see the example under B<bsearch>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:122
msgid ""
"Another example is the following program, which sorts the strings given in "
"its command-line arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:134
#, no-wrap
msgid ""
"static int\n"
"cmpstringp(const void *p1, const void *p2)\n"
"{\n"
"    /* The actual arguments to this function are \"pointers to\n"
"       pointers to char\", but strcmp(3) arguments are \"pointers\n"
"       to char\", hence the following cast plus dereference */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:137
#, no-wrap
msgid ""
"    return strcmp(* (char * const *) p1, * (char * const *) p2);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:142
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:147
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:149
#, no-wrap
msgid "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:154
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        puts(argv[j]);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/qsort.3:160
msgid "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"
msgstr ""

#. type: TH
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "TSEARCH"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:28
msgid "tsearch, tfind, tdelete, twalk, tdestroy - manage a binary tree"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:34
#, no-wrap
msgid ""
"B<void *tsearch(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:37
#, no-wrap
msgid ""
"B<void *tfind(const void *>I<key>B<, const void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:40
#, no-wrap
msgid ""
"B<void *tdelete(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:44
#, no-wrap
msgid ""
"B<void twalk(const void *>I<root>B<, void (*>I<action>B<)(const void "
"*>I<nodep>B<,>\n"
"B<                                   const VISIT >I<which>B<,>\n"
"B<                                   const int >I<depth>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:50
#, no-wrap
msgid ""
"B<void tdestroy(void *>I<root>B<, void (*>I<free_node>B<)(void "
"*>I<nodep>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:69
msgid ""
"B<tsearch>(), B<tfind>(), B<twalk>(), and B<tdelete>()  manage a binary "
"tree.  They are generalized from Knuth (6.2.2) Algorithm T.  The first field "
"in each node of the tree is a pointer to the corresponding data item.  (The "
"calling program must store the actual data.)  I<compar> points to a "
"comparison routine, which takes pointers to two items.  It should return an "
"integer which is negative, zero, or positive, depending on whether the first "
"item is less than, equal to, or greater than the second."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:88
msgid ""
"B<tsearch>()  searches the tree for an item.  I<key> points to the item to "
"be searched for.  I<rootp> points to a variable which points to the root of "
"the tree.  If the tree is empty, then the variable that I<rootp> points to "
"should be set to NULL.  If the item is found in the tree, then B<tsearch>()  "
"returns a pointer to it.  If it is not found, then B<tsearch>()  adds it, "
"and returns a pointer to the newly added item."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:96
msgid ""
"B<tfind>()  is like B<tsearch>(), except that if the item is not found, then "
"B<tfind>()  returns NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:101
msgid ""
"B<tdelete>()  deletes an item from the tree.  Its arguments are the same as "
"for B<tsearch>()."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:136
msgid ""
"B<twalk>()  performs depth-first, left-to-right traversal of a binary tree.  "
"I<root> points to the starting node for the traversal.  If that node is not "
"the root, then only part of the tree will be visited.  B<twalk>()  calls the "
"user function I<action> each time a node is visited (that is, three times "
"for an internal node, and once for a leaf).  I<action>, in turn, takes three "
"arguments.  The first argument is a pointer to the node being visited.  The "
"structure of the node is unspecified, but it is possible to cast the pointer "
"to a pointer-to-pointer-to-element in order to access the element stored "
"within the node.  The application must not modify the structure pointed to "
"by this argument.  The second argument is an integer which takes one of the "
"values B<preorder>, B<postorder>, or B<endorder> depending on whether this "
"is the first, second, or third visit to the internal node, or the value "
"B<leaf> if this is the single visit to a leaf node.  (These symbols are "
"defined in I<E<lt>search.hE<gt>>.)  The third argument is the depth of the "
"node; the root node has depth zero."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:152
msgid ""
"(More commonly, B<preorder>, B<postorder>, and B<endorder> are known as "
"B<preorder>, B<inorder>, and B<postorder>: before visiting the children, "
"after the first and before the second, and after visiting the children.  "
"Thus, the choice of name B<post\\%order> is rather confusing.)"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:167
msgid ""
"B<tdestroy>()  removes the whole tree pointed to by I<root>, freeing all "
"resources allocated by the B<tsearch>()  function.  For the data in each "
"tree node the function I<free_node> is called.  The pointer to the data is "
"passed as the argument to the function.  If no such work is necessary, "
"I<free_node> must point to a function doing nothing."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:177
msgid ""
"B<tsearch>()  returns a pointer to a matching item in the tree, or to the "
"newly added item, or NULL if there was insufficient memory to add the item.  "
"B<tfind>()  returns a pointer to the item, or NULL if no match is found.  If "
"there are multiple elements that match the key, the element returned is "
"unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:181
msgid ""
"B<tdelete>()  returns a pointer to the parent of the item deleted, or NULL "
"if the item was not found."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:190
msgid ""
"B<tsearch>(), B<tfind>(), and B<tdelete>()  also return NULL if I<rootp> was "
"NULL on entry."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:195
msgid "SVr4, POSIX.1-2001.  The function B<tdestroy>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:199
msgid ""
"B<twalk>()  takes a pointer to the root, while the other functions take a "
"pointer to a variable which points to the root."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:204
msgid ""
"B<tdelete>()  frees the memory required for the node in the tree.  The user "
"is responsible for freeing the memory for the corresponding data."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:212
msgid ""
"The example program depends on the fact that B<twalk>()  makes no further "
"reference to a node after calling the user function with argument "
"\"endorder\" or \"leaf\".  This works with the GNU library implementation, "
"but is not in the System V documentation."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:216
msgid ""
"The following program inserts twelve random numbers into a binary tree, "
"where duplicate numbers are collapsed, then prints the numbers in order."
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:223
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Expose declaration of tdestroy() */\n"
"#include E<lt>search.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:225
#, no-wrap
msgid "static void *root = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:236
#, no-wrap
msgid ""
"static void *\n"
"xmalloc(unsigned n)\n"
"{\n"
"    void *p;\n"
"    p = malloc(n);\n"
"    if (p)\n"
"        return p;\n"
"    fprintf(stderr, \"insufficient memory\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:246
#, no-wrap
msgid ""
"static int\n"
"compare(const void *pa, const void *pb)\n"
"{\n"
"    if (*(int *) pa E<lt> *(int *) pb)\n"
"        return -1;\n"
"    if (*(int *) pa E<gt> *(int *) pb)\n"
"        return 1;\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:251
#, no-wrap
msgid ""
"static void\n"
"action(const void *nodep, const VISIT which, const int depth)\n"
"{\n"
"    int *datap;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:267
#, no-wrap
msgid ""
"    switch (which) {\n"
"    case preorder:\n"
"        break;\n"
"    case postorder:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    case endorder:\n"
"        break;\n"
"    case leaf:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:273
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int i, *ptr;\n"
"    void *val;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:288
#, no-wrap
msgid ""
"    srand(time(NULL));\n"
"    for (i = 0; i E<lt> 12; i++) {\n"
"        ptr = xmalloc(sizeof(int));\n"
"        *ptr = rand() & 0xff;\n"
"        val = tsearch((void *) ptr, &root, compare);\n"
"        if (val == NULL)\n"
"            exit(EXIT_FAILURE);\n"
"        else if ((*(int **) val) != ptr)\n"
"            free(ptr);\n"
"    }\n"
"    twalk(root, action);\n"
"    tdestroy(root, free);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tsearch.3:294
msgid "B<bsearch>(3), B<hsearch>(3), B<lsearch>(3), B<qsort>(3)"
msgstr ""

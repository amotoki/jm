# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-13 10:27+0900\n"
"PO-Revision-Date: 2014-04-13 10:39+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsearch.3:31
#, no-wrap
msgid "BSEARCH"
msgstr "BSEARCH"

#. type: TH
#: build/C/man3/bsearch.3:31
#, no-wrap
msgid "2003-11-01"
msgstr "2003-11-01"

#. type: TH
#: build/C/man3/bsearch.3:31 build/C/man3/hsearch.3:35
#: build/C/man3/insque.3:36 build/C/man3/lsearch.3:26 build/C/man3/qsort.3:37
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/bsearch.3:32 build/C/man3/hsearch.3:36
#: build/C/man3/insque.3:37 build/C/man3/lsearch.3:27 build/C/man3/qsort.3:38
#: build/C/man3/tsearch.3:26
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/bsearch.3:34
msgid "bsearch - binary search of a sorted array"
msgstr "bsearch - ソートされた配列を二分木検索 (binary search) する"

#. type: SH
#: build/C/man3/bsearch.3:34 build/C/man3/hsearch.3:39
#: build/C/man3/insque.3:39 build/C/man3/lsearch.3:29 build/C/man3/qsort.3:40
#: build/C/man3/tsearch.3:28
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bsearch.3:37 build/C/man3/qsort.3:43
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bsearch.3:41
#, no-wrap
msgid ""
"B<void *bsearch(const void *>I<key>B<, const void *>I<base>B<,>\n"
"B<              size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<              int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *bsearch(const void *>I<key>B<, const void *>I<base>B<,>\n"
"B<              size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<              int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: SH
#: build/C/man3/bsearch.3:42 build/C/man3/hsearch.3:60
#: build/C/man3/insque.3:61 build/C/man3/lsearch.3:39 build/C/man3/qsort.3:61
#: build/C/man3/tsearch.3:51
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/bsearch.3:56
msgid ""
"The B<bsearch>()  function searches an array of I<nmemb> objects, the "
"initial member of which is pointed to by I<base>, for a member that matches "
"the object pointed to by I<key>.  The size of each member of the array is "
"specified by I<size>."
msgstr ""
"B<bsearch>()  関数は I<nmemb> 個のオブジェクトからなる配列を検索 する。配列の"
"最初のメンバーへのポインタは I<base> によって与える。 ポインタ I<key> で参照"
"されるオブジェクトと一致するメンバーが返される。 配列中の各々のメンバーのサイ"
"ズは I<size> によって指定する。"

#. type: Plain text
#: build/C/man3/bsearch.3:70
msgid ""
"The contents of the array should be in ascending sorted order according to "
"the comparison function referenced by I<compar>.  The I<compar> routine is "
"expected to have two arguments which point to the I<key> object and to an "
"array member, in that order, and should return an integer less than, equal "
"to, or greater than zero if the I<key> object is found, respectively, to be "
"less than, to match, or be greater than the array member."
msgstr ""
"配列の内容は比較関数 I<compar> に基づき、昇順にソートされていなけれ ばならな"
"い。 I<compar> ルーチンは二つの引き数を取る関数で、一つ 目に I<key> へのポイ"
"ンタ、次に配列のメンバーへのポインタを取る。 この順に指定したとき、 I<key> が"
"配列メンバーより小さいときには 負の整数を、大きいときには正の整数を、一致した"
"ときには 0 を、それぞれ I<compar> は返さなければならない。"

#. type: SH
#: build/C/man3/bsearch.3:70 build/C/man3/hsearch.3:174
#: build/C/man3/lsearch.3:72 build/C/man3/qsort.3:91
#: build/C/man3/tsearch.3:167
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bsearch.3:77
msgid ""
"The B<bsearch>()  function returns a pointer to a matching member of the "
"array, or NULL if no match is found.  If there are multiple elements that "
"match the key, the element returned is unspecified."
msgstr ""
"B<bsearch>()  関数は、配列のメンバーのうち、一致したものへのポインタを 返す。"
"見つからなかったときは NULL を返す。 I<key> と一致したメンバーが 複数あると"
"き、そのうちのどのメンバーが返されるかはわからない。"

#. type: SH
#: build/C/man3/bsearch.3:77 build/C/man3/hsearch.3:246
#: build/C/man3/insque.3:99 build/C/man3/lsearch.3:80 build/C/man3/qsort.3:100
#: build/C/man3/tsearch.3:190
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bsearch.3:79
msgid "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."
msgstr "SVr4, 4.3BSD, POSIX.1-2001, C89, C99."

#. type: SH
#: build/C/man3/bsearch.3:79 build/C/man3/hsearch.3:293
#: build/C/man3/insque.3:134 build/C/man3/qsort.3:116
#: build/C/man3/tsearch.3:212
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/bsearch.3:84
msgid ""
"The example below first sorts an array of structures using B<qsort>(3), then "
"retrieves desired elements using B<bsearch>()."
msgstr ""
"以下の例は、 B<qsort>(3)  を使って構造体の配列の並び換えを行った後、 所望の要"
"素を B<bsearch>()  を使って取得するものである。"

#. type: Plain text
#: build/C/man3/bsearch.3:89 build/C/man3/qsort.3:127
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/bsearch.3:98
#, no-wrap
msgid ""
"struct mi {\n"
"    int nr;\n"
"    char *name;\n"
"} months[] = {\n"
"    { 1, \"jan\" }, { 2, \"feb\" }, { 3, \"mar\" }, { 4, \"apr\" },\n"
"    { 5, \"may\" }, { 6, \"jun\" }, { 7, \"jul\" }, { 8, \"aug\" },\n"
"    { 9, \"sep\" }, {10, \"oct\" }, {11, \"nov\" }, {12, \"dec\" }\n"
"};\n"
msgstr ""
"struct mi {\n"
"    int nr;\n"
"    char *name;\n"
"} months[] = {\n"
"    { 1, \"jan\" }, { 2, \"feb\" }, { 3, \"mar\" }, { 4, \"apr\" },\n"
"    { 5, \"may\" }, { 6, \"jun\" }, { 7, \"jul\" }, { 8, \"aug\" },\n"
"    { 9, \"sep\" }, {10, \"oct\" }, {11, \"nov\" }, {12, \"dec\" }\n"
"};\n"

#. type: Plain text
#: build/C/man3/bsearch.3:100
#, no-wrap
msgid "#define nr_of_months (sizeof(months)/sizeof(months[0]))\n"
msgstr "#define nr_of_months (sizeof(months)/sizeof(months[0]))\n"

#. type: Plain text
#: build/C/man3/bsearch.3:108
#, no-wrap
msgid ""
"static int\n"
"compmi(const void *m1, const void *m2)\n"
"{\n"
"    struct mi *mi1 = (struct mi *) m1;\n"
"    struct mi *mi2 = (struct mi *) m2;\n"
"    return strcmp(mi1-E<gt>name, mi2-E<gt>name);\n"
"}\n"
msgstr ""
"static int\n"
"compmi(const void *m1, const void *m2)\n"
"{\n"
"    struct mi *mi1 = (struct mi *) m1;\n"
"    struct mi *mi2 = (struct mi *) m2;\n"
"    return strcmp(mi1-E<gt>name, mi2-E<gt>name);\n"
"}\n"

#. type: Plain text
#: build/C/man3/bsearch.3:113
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int i;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int i;\n"

#. type: Plain text
#: build/C/man3/bsearch.3:127
#, no-wrap
msgid ""
"    qsort(months, nr_of_months, sizeof(struct mi), compmi);\n"
"    for (i = 1; i E<lt> argc; i++) {\n"
"        struct mi key, *res;\n"
"        key.name = argv[i];\n"
"        res = bsearch(&key, months, nr_of_months,\n"
"                      sizeof(struct mi), compmi);\n"
"        if (res == NULL)\n"
"            printf(\"\\(aq%s\\(aq: unknown month\\en\", argv[i]);\n"
"        else\n"
"            printf(\"%s: month #%d\\en\", res-E<gt>name, res-E<gt>nr);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    qsort(months, nr_of_months, sizeof(struct mi), compmi);\n"
"    for (i = 1; i E<lt> argc; i++) {\n"
"        struct mi key, *res;\n"
"        key.name = argv[i];\n"
"        res = bsearch(&key, months, nr_of_months,\n"
"                      sizeof(struct mi), compmi);\n"
"        if (res == NULL)\n"
"            printf(\"\\(aq%s\\(aq: unknown month\\en\", argv[i]);\n"
"        else\n"
"            printf(\"%s: month #%d\\en\", res-E<gt>name, res-E<gt>nr);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/bsearch.3:129 build/C/man3/hsearch.3:343
#: build/C/man3/lsearch.3:85 build/C/man3/qsort.3:155
#: build/C/man3/tsearch.3:289
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/bsearch.3:134
msgid "B<hsearch>(3), B<lsearch>(3), B<qsort>(3), B<tsearch>(3)"
msgstr "B<hsearch>(3), B<lsearch>(3), B<qsort>(3), B<tsearch>(3)"

#. type: SH
#: build/C/man3/bsearch.3:134 build/C/man3/hsearch.3:348
#: build/C/man3/insque.3:244 build/C/man3/lsearch.3:89
#: build/C/man3/qsort.3:160 build/C/man3/tsearch.3:294
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/bsearch.3:141 build/C/man3/hsearch.3:355
#: build/C/man3/insque.3:251 build/C/man3/lsearch.3:96
#: build/C/man3/qsort.3:167 build/C/man3/tsearch.3:301
msgid ""
"This page is part of release 3.63 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.63 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/hsearch.3:35
#, no-wrap
msgid "HSEARCH"
msgstr "HSEARCH"

#. type: TH
#: build/C/man3/hsearch.3:35 build/C/man3/tsearch.3:25
#, no-wrap
msgid "2014-01-05"
msgstr ""

#. type: TH
#: build/C/man3/hsearch.3:35 build/C/man3/lsearch.3:26
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/hsearch.3:39
msgid ""
"hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r, hsearch_r - hash table "
"management"
msgstr ""
"hcreate, hdestroy, hsearch, hcreate_r, hdestroy_r, hsearch_r - ハッシュテーブ"
"ルの管理"

#. type: Plain text
#: build/C/man3/hsearch.3:42 build/C/man3/hsearch.3:52
#: build/C/man3/insque.3:42 build/C/man3/lsearch.3:32
#: build/C/man3/tsearch.3:31 build/C/man3/tsearch.3:48
#, no-wrap
msgid "B<#include E<lt>search.hE<gt>>\n"
msgstr "B<#include E<lt>search.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:44
#, no-wrap
msgid "B<int hcreate(size_t >I<nel>B<);>\n"
msgstr "B<int hcreate(size_t >I<nel>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:46
#, no-wrap
msgid "B<ENTRY *hsearch(ENTRY >I<item>B<, ACTION >I<action>B<);>\n"
msgstr "B<ENTRY *hsearch(ENTRY >I<item>B<, ACTION >I<action>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:48
#, no-wrap
msgid "B<void hdestroy(void);>\n"
msgstr "B<void hdestroy(void);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:50 build/C/man3/tsearch.3:46
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/hsearch.3:54
#, no-wrap
msgid "B<int hcreate_r(size_t >I<nel>B<, struct hsearch_data *>I<htab>B<);>\n"
msgstr "B<int hcreate_r(size_t >I<nel>B<, struct hsearch_data *>I<htab>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:57
#, no-wrap
msgid ""
"B<int hsearch_r(ENTRY >I<item>B<, ACTION >I<action>B<, ENTRY **>I<retval>B<,>\n"
"B<              struct hsearch_data *>I<htab>B<);>\n"
msgstr ""
"B<int hsearch_r(ENTRY >I<item>B<, ACTION >I<action>B<, ENTRY **>I<retval>B<,>\n"
"B<              struct hsearch_data *>I<htab>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:59
#, no-wrap
msgid "B<void hdestroy_r(struct hsearch_data *>I<htab>B<);>\n"
msgstr "B<void hdestroy_r(struct hsearch_data *>I<htab>B<);>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:69
msgid ""
"The three functions B<hcreate>(), B<hsearch>(), and B<hdestroy>()  allow the "
"caller to create and manage a hash search table containing entries "
"consisting of a key (a string) and associated data.  Using these functions, "
"only one hash table can be used at a time."
msgstr ""
"B<hcreate>(), B<hsearch>(), B<hdestroy>()  の 3 つの関数を利用すると、キー "
"(文字列) と対応するデータから構成される エントリを格納できるハッシュ検索テー"
"ブルを作成、管理することができる。 これらの関数を使って、一度に使用できるのは"
"一つのハッシュテーブルだけである。"

#. type: Plain text
#: build/C/man3/hsearch.3:83
msgid ""
"The three functions B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>()  are "
"reentrant versions that allow a program to use more than one hash search "
"table at the same time.  The last argument, I<htab>, points to a structure "
"that describes the table on which the function is to operate.  The "
"programmer should treat this structure as opaque (i.e., do not attempt to "
"directly access or modify the fields in this structure)."
msgstr ""
"B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>()  の 3 つの関数はリエントラン"
"ト版で、これらを利用すると、 一つのプログラムで同時に複数のハッシュテーブルを"
"使うことができる。 最後の引き数 I<htab> は関数の操作対象となるテーブルを示す"
"構造体へのポインタである。 プログラマはこの構造体をブラックボックスとして扱う"
"べきである (つまり、この構造体のフィールドに直接アクセスしたり変更したり しな"
"いこと)。"

#.  e.g., in glibc it is raised to the next higher prime number
#. type: Plain text
#: build/C/man3/hsearch.3:92
msgid ""
"First a hash table must be created using B<hcreate>().  The argument I<nel> "
"specifies the maximum number of entries in the table.  (This maximum cannot "
"be changed later, so choose it wisely.)  The implementation may adjust this "
"value upward to improve the performance of the resulting hash table."
msgstr ""
"最初に、 B<hcreate>()  関数によってハッシュテーブルを作成しなければならな"
"い。 引き数 I<nel> でテーブルの最大エントリ数を指定する (この最大値は後で変更"
"することはできないので、よく考えて選択すること)。 作成されるハッシュテーブル"
"の性能を向上させるために、 関数内部の実装によりこの値は増やされる場合もある。"

#. type: Plain text
#: build/C/man3/hsearch.3:103
msgid ""
"The B<hcreate_r>()  function performs the same task as B<hcreate>(), but for "
"the table described by the structure I<*htab>.  The structure pointed to by "
"I<htab> must be zeroed before the first call to B<hcreate_r>()."
msgstr ""
"B<hcreate_r>()  関数は B<hcreate>()  と同じ動作をするが、構造体 I<*htab> で示"
"されるテーブルを対象として動作する。 I<htab> が指し示す構造体は、 "
"B<hcreate_r>()  を初めて呼び出す前に 0 で埋めておかなければならない。"

#. type: Plain text
#: build/C/man3/hsearch.3:118
msgid ""
"The function B<hdestroy>()  frees the memory occupied by the hash table that "
"was created by B<hcreate>().  After calling B<hdestroy>()  a new hash table "
"can be created using B<hcreate>().  The B<hdestroy_r>()  function performs "
"the analogous task for a hash table described by I<*htab>, which was "
"previously created using B<hcreate_r>()."
msgstr ""
"B<hdestroy>()  関数は、 B<hcreate>()  で作成されたハッシュテーブルが占有して"
"いたメモリを解放する。 ハッシュテーブルによって占有されていたメモリを解放"
"し、 新しいテーブルを作成できるようにする。 B<hdestroy>()  を呼び出すと、その"
"後は B<hcreate>()  を使って新しいハッシュテーブルを作成することができる。 "
"B<hdestroy_r>()  関数は、同様の処理を、それ以前に B<hcreate_r>()  を使って作"
"成した I<*htab> で示されるハッシュテーブルに対して実行する。"

#. type: Plain text
#: build/C/man3/hsearch.3:125
msgid ""
"The B<hsearch>()  function searches the hash table for an item with the same "
"key as I<item> (where \"the same\" is determined using B<strcmp>(3)), and if "
"successful returns a pointer to it."
msgstr ""
"B<hsearch>()  関数は、I<item> と同じキーを持つ項目をハッシュテーブルから 検索"
"し、項目が見つかった場合にはその項目へのポインタを返す (「同じ」かどうかは "
"B<strcmp>(3)  を使って判定する)。"

#. type: Plain text
#: build/C/man3/hsearch.3:128
msgid ""
"The argument I<item> is of type I<ENTRY>, which is defined in I<E<lt>search."
"hE<gt>> as follows:"
msgstr ""
"引き数 I<item> は B<ENTRY> 型であり、I<E<lt>search.hE<gt>> の中で 以下のよう"
"に定義されている。"

#. type: Plain text
#: build/C/man3/hsearch.3:135
#, no-wrap
msgid ""
"typedef struct entry {\n"
"    char *key;\n"
"    void *data;\n"
"} ENTRY;\n"
msgstr ""
"typedef struct entry {\n"
"    char *key;\n"
"    void *data;\n"
"} ENTRY;\n"

#. type: Plain text
#: build/C/man3/hsearch.3:141
msgid ""
"The field I<key> points to a null-terminated string which is the search "
"key.  The field I<data> points to data that is associated with that key."
msgstr ""
"フィールド I<key> は検索キーとなる NULL 終端された文字列を指す。 フィールド "
"I<data> は、このキーに対応するデータを指す。"

#. type: Plain text
#: build/C/man3/hsearch.3:160
msgid ""
"The argument I<action> determines what B<hsearch>()  does after an "
"unsuccessful search.  This argument must either have the value B<ENTER>, "
"meaning insert a copy of I<item> (and return a pointer to the new hash table "
"entry as the function result), or the value B<FIND>, meaning that NULL "
"should be returned.  (If I<action> is B<FIND>, then I<data> is ignored.)"
msgstr ""
"検索が失敗した後の動作は、引き数 I<action> により決まる。 この引き数には "
"B<ENTER> か B<FIND> のいずれかの値を指定しなければならない。 B<ENTER> は "
"I<item> のコピーを挿入することを (関数の結果として新しいハッシュテーブルエン"
"トリへのポインタを返す)、 B<FIND> は NULL を返すことを意味する (I<action> が "
"B<FIND> の場合、 I<data> は無視される)。"

#. type: Plain text
#: build/C/man3/hsearch.3:174
msgid ""
"The B<hsearch_r>()  function is like B<hsearch>()  but operates on the hash "
"table described by I<*htab>.  The B<hsearch_r>()  function differs from "
"B<hsearch>()  in that a pointer to the found item is returned in I<*retval>, "
"rather than as the function result."
msgstr ""
"B<hsearch_r>()  関数は B<hsearch>()  と同様だが、 I<*htab> で示されるハッシュ"
"テーブルに対して処理を行う。 B<hsearch_r>()  関数が B<hsearch>()  と異なるの"
"は、見つかった項目へのポインタを、 関数の結果としてではなく、 I<*retval> に格"
"納して返す点である。"

#. type: Plain text
#: build/C/man3/hsearch.3:182
msgid ""
"B<hcreate>()  and B<hcreate_r>()  return nonzero on success.  They return 0 "
"on error, with I<errno> set to indicate the cause of the error."
msgstr ""
"B<hcreate>()  と B<hcreate_r>()  は、成功した場合 0 以外の値を返す。 エラーの"
"場合 0 を返し、 I<errno> にエラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man3/hsearch.3:196
msgid ""
"On success, B<hsearch>()  returns a pointer to an entry in the hash table.  "
"B<hsearch>()  returns NULL on error, that is, if I<action> is B<ENTER> and "
"the hash table is full, or I<action> is B<FIND> and I<item> cannot be found "
"in the hash table.  B<hsearch_r>()  returns nonzero on success, and 0 on "
"error.  In the event of an error, these two functions set I<errno> to "
"indicate the cause of the error."
msgstr ""
"成功すると、 B<hsearch>()  は、ハッシュテーブル内のエントリへのポインタを返"
"す。 エラーの場合、 B<hsearch>()  は NULL を返す。 エラーとなるのは、 "
"I<action> が B<ENTER> でハッシュテーブルがいっぱいの場合か、 I<action> が "
"B<FIND> で I<item> がハッシュテーブル内に 見つからない場合である。 "
"B<hsearch_r>()  は、成功すると 0 以外を返し、エラーの場合 0 を返す。 エラーの"
"場合、 これら二つの関数は I<errno> にエラーの原因を示す値を設定する。"

#. type: SH
#: build/C/man3/hsearch.3:196
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/hsearch.3:202
msgid ""
"B<hcreate_r>()  and B<hdestroy_r>()  can fail for the following reasons:"
msgstr ""
"B<hcreate_r>()  と B<hdestroy_r>()  は以下の理由で失敗する可能性がある。"

#. type: TP
#: build/C/man3/hsearch.3:202
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/hsearch.3:206
msgid "I<htab> is NULL."
msgstr "I<htab> が NULL である。"

#. type: Plain text
#: build/C/man3/hsearch.3:211
msgid "B<hsearch>()  and B<hsearch_r>()  can fail for the following reasons:"
msgstr "B<hsearch>()  と B<hsearch_r>()  は以下の理由で失敗する可能性がある。"

#. type: TP
#: build/C/man3/hsearch.3:211
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/hsearch.3:219
msgid ""
"I<action> was B<ENTER>, I<key> was not found in the table, and there was no "
"room in the table to add a new entry."
msgstr ""
"I<action> が B<ENTER> で、 I<key> がテーブル内に見つからず、 テーブルに新しい"
"エントリを追加する余地がなかった。"

#. type: TP
#: build/C/man3/hsearch.3:219
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man3/hsearch.3:227
msgid "I<action> was B<FIND>, and I<key> was not found in the table."
msgstr "I<action> が B<FIND> で、 I<key> がテーブル内に見つからなかった。"

#. type: Plain text
#: build/C/man3/hsearch.3:231
msgid "POSIX.1-2001 specifies only the B<ENOMEM> error."
msgstr "POSIX.1-2001 が規定しているのは、エラー B<ENOMEM> だけである。"

#. type: SH
#: build/C/man3/hsearch.3:231
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: SS
#: build/C/man3/hsearch.3:232
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "マルチスレッディング (pthreads(7) 参照)"

#. type: Plain text
#: build/C/man3/hsearch.3:239
msgid ""
"The B<hcreate>(), B<hsearch>(), and B<hdestroy>()  functions use a global "
"space for storing the table, so they are not thread-safe."
msgstr ""
"関数 B<hcreate>(), B<hsearch>(), B<hdestroy>() はテーブルを格納するのにグロー"
"バル空間を使用する。そのため、これらの関数はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/hsearch.3:246
msgid ""
"The B<hcreate_r>(), B<hsearch_r>(), and B<hdestroy_r>()  functions are "
"thread-safe."
msgstr ""
"関数 B<hcreate_r>(), B<hsearch_r>(), B<hdestroy_r>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/hsearch.3:259
msgid ""
"The functions B<hcreate>(), B<hsearch>(), and B<hdestroy>()  are from SVr4, "
"and are described in POSIX.1-2001.  The functions B<hcreate_r>(), "
"B<hsearch_r>(), and B<hdestroy_r>()  are GNU extensions."
msgstr ""
"関数 B<hcreate>(), B<hsearch>(), B<hdestroy>()  は SVr4 から導入されたもの"
"で、POSIX.1-2001 に記述されている。 関数 B<hcreate_r>, B<hsearch_r>, "
"B<hdestroy_r> は GNU の拡張である。"

#. type: SH
#: build/C/man3/hsearch.3:259 build/C/man3/insque.3:101
#: build/C/man3/qsort.3:104 build/C/man3/tsearch.3:195
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/hsearch.3:266
msgid ""
"Hash table implementations are usually more efficient when the table "
"contains enough free space to minimize collisions.  Typically, this means "
"that I<nel> should be at least 25% larger than the maximum number of "
"elements that the caller expects to store in the table."
msgstr ""
"通常、ハッシュテーブルの実装は、衝突を最小限にするために テーブルに十分な空き"
"領域がある場合に効率がよくなる。 このため、普通は、 I<nel> を、呼び出し側が"
"テーブルに格納しようと思っている エントリの最大数より少なくとも 25% は大きな"
"値にすべきである。"

#. type: Plain text
#: build/C/man3/hsearch.3:284
msgid ""
"The B<hdestroy>()  and B<hdestroy_r>()  functions do not free the buffers "
"pointed to by the I<key> and I<data> elements of the hash table entries.  "
"(It can't do this because it doesn't know whether these buffers were "
"allocated dynamically.)  If these buffers need to be freed (perhaps because "
"the program is repeatedly creating and destroying hash tables, rather than "
"creating a single table whose lifetime matches that of the program), then "
"the program must maintain bookkeeping data structures that allow it to free "
"them."
msgstr ""
"B<hdestroy>()  と B<hdestroy_r>()  は、ハッシュテーブルのエントリの要素であ"
"る I<key> と I<data> が指すバッファを解放しない (これができないのは、これらの"
"バッファが動的に割り当てられたのかを 知ることができないからである)。 これらの"
"バッファを解放する必要がある場合、 プログラムでは、これらのバッファを解放でき"
"るように管理用のデータ構造を 設けて、これを管理しなければならない (解放が必要"
"となる理由は、たいていは、プログラム自身と生存期間が同じ ハッシュテーブルを一"
"つだけ作成するのではなく、そのプログラムでは複数の ハッシュテーブルを繰り返し"
"て作成したり破棄したりするからであろう)。"

#. type: SH
#: build/C/man3/hsearch.3:284 build/C/man3/insque.3:127
#: build/C/man3/lsearch.3:83
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/hsearch.3:291
msgid ""
"SVr4 and POSIX.1-2001 specify that I<action> is significant only for "
"unsuccessful searches, so that an B<ENTER> should not do anything for a "
"successful search.  In libc and glibc (before version 2.3), the "
"implementation violates the specification, updating the I<data> for the "
"given I<key> in this case."
msgstr ""
"SVr4 と POSIX.1-2001 の規定では、 I<action> は検索が失敗したときにだけ意味を"
"持つとなっている。 よって、検索が成功した場合、I<action> の値が B<ENTER> で"
"も 何もすべきではない。 (バージョン 2.3 より前の) libc と glibc の実装はこの"
"規格に違反しており、 この状況で、指定された I<key> に対応する I<data> が更新"
"される。"

#. type: Plain text
#: build/C/man3/hsearch.3:293
msgid "Individual hash table entries can be added, but not deleted."
msgstr "ハッシュテーブルエントリーの追加はできるが、削除ができない。"

#. type: Plain text
#: build/C/man3/hsearch.3:297
msgid ""
"The following program inserts 24 items into a hash table, then prints some "
"of them."
msgstr ""
"次のプログラムは、ハッシュテーブルに 24 個の項目を挿入し、 それからそのうちの"
"いくつかを表示する。"

#. type: Plain text
#: build/C/man3/hsearch.3:302
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"

#. type: Plain text
#: build/C/man3/hsearch.3:309
#, fuzzy, no-wrap
#| msgid ""
#| "char *data[] = { \"alpha\", \"bravo\", \"charlie\", \"delta\",\n"
#| "     \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n"
#| "     \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\",\n"
#| "     \"quebec\", \"romeo\", \"sierra\", \"tango\", \"uniform\",\n"
#| "     \"victor\", \"whisky\", \"x-ray\", \"yankee\", \"zulu\"\n"
#| "};\n"
msgid ""
"static char *data[] = { \"alpha\", \"bravo\", \"charlie\", \"delta\",\n"
"     \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n"
"     \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\",\n"
"     \"quebec\", \"romeo\", \"sierra\", \"tango\", \"uniform\",\n"
"     \"victor\", \"whisky\", \"x-ray\", \"yankee\", \"zulu\"\n"
"};\n"
msgstr ""
"char *data[] = { \"alpha\", \"bravo\", \"charlie\", \"delta\",\n"
"     \"echo\", \"foxtrot\", \"golf\", \"hotel\", \"india\", \"juliet\",\n"
"     \"kilo\", \"lima\", \"mike\", \"november\", \"oscar\", \"papa\",\n"
"     \"quebec\", \"romeo\", \"sierra\", \"tango\", \"uniform\",\n"
"     \"victor\", \"whisky\", \"x-ray\", \"yankee\", \"zulu\"\n"
"};\n"

#. type: Plain text
#: build/C/man3/hsearch.3:315
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    ENTRY e, *ep;\n"
"    int i;\n"
msgstr ""
"int main()\n"
"{\n"
"    ENTRY e, *ep;\n"
"    int i;\n"

#. type: Plain text
#: build/C/man3/hsearch.3:317
#, no-wrap
msgid "    hcreate(30);\n"
msgstr "    hcreate(30);\n"

#. type: Plain text
#: build/C/man3/hsearch.3:330
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> 24; i++) {\n"
"        e.key = data[i];\n"
"        /* data is just an integer, instead of a\n"
"           pointer to something */\n"
"        e.data = (void *) i;\n"
"        ep = hsearch(e, ENTER);\n"
"        /* there should be no failures */\n"
"        if (ep == NULL) {\n"
"            fprintf(stderr, \"entry failed\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    for (i = 0; i E<lt> 24; i++) {\n"
"        e.key = data[i];\n"
"        /* データは、ポインタではなく、単なる整数値である。 */\n"
"        e.data = (void *) i;\n"
"        ep = hsearch(e, ENTER);\n"
"        /* エラーは起こらないはずである。 */\n"
"        if (ep == NULL) {\n"
"            fprintf(stderr, \"entry failed\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/hsearch.3:342
#, no-wrap
msgid ""
"    for (i = 22; i E<lt> 26; i++) {\n"
"        /* print two entries from the table, and\n"
"           show that two are not in the table */\n"
"        e.key = data[i];\n"
"        ep = hsearch(e, FIND);\n"
"        printf(\"%9.9s -E<gt> %9.9s:%d\\en\", e.key,\n"
"               ep ? ep-E<gt>key : \"NULL\", ep ? (int)(ep-E<gt>data) : 0);\n"
"    }\n"
"    hdestroy();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    for (i = 22; i E<lt> 26; i++) {\n"
"        /* テーブルにある 2 つのエントリを表示し、\n"
"           あとの 2 つがテーブルにないことを示す。 */\n"
"        e.key = data[i];\n"
"        ep = hsearch(e, FIND);\n"
"        printf(\"%9.9s -E<gt> %9.9s:%d\\en\", e.key,\n"
"               ep ? ep-E<gt>key : \"NULL\", ep ? (int)(ep-E<gt>data) : 0);\n"
"    }\n"
"    hdestroy();\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/hsearch.3:348
msgid "B<bsearch>(3), B<lsearch>(3), B<malloc>(3), B<tsearch>(3)"
msgstr "B<bsearch>(3), B<lsearch>(3), B<malloc>(3), B<tsearch>(3)"

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "INSQUE"
msgstr "INSQUE"

#. type: TH
#: build/C/man3/insque.3:36
#, no-wrap
msgid "2010-09-09"
msgstr "2010-09-09"

#. type: Plain text
#: build/C/man3/insque.3:39
msgid "insque, remque - insert/remove an item from a queue"
msgstr "insque, remque - キューにアイテムを挿入/削除する"

#. type: Plain text
#: build/C/man3/insque.3:44
#, no-wrap
msgid "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"
msgstr "B<void insque(void *>I<elem>B<, void *>I<prev>B<);>\n"

#. type: Plain text
#: build/C/man3/insque.3:46
#, no-wrap
msgid "B<void remque(void *>I<elem>B<);>\n"
msgstr "B<void remque(void *>I<elem>B<);>\n"

#. type: Plain text
#: build/C/man3/insque.3:51 build/C/man3/qsort.3:55
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/insque.3:56
msgid "B<insque>(), B<remque>():"
msgstr "B<insque>(), B<remque>():"

#. type: Plain text
#: build/C/man3/insque.3:59
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/insque.3:73
msgid ""
"The B<insque>()  and B<remque>()  functions manipulate doubly-linked lists.  "
"Each element in the list is a structure of which the first two elements are "
"a forward and a backward pointer.  The linked list may be linear (i.e., NULL "
"forward pointer at the end of the list and NULL backward pointer at the "
"start of the list)  or circular."
msgstr ""
"関数 B<insque>() と B<remque>() は双方向連結リスト (doubly-linked list) を\n"
"操作する。リスト中のそれぞれの要素は、最初の二つの要素がそれぞれ次と前への\n"
"ポインタであるような構造体である。\n"
"リンクリストは、線形 (linear) か環状 (circular) のどちらかになる\n"
"(線形の場合には、リストの末尾では次へのポインタが NULL になり、\n"
"リストの先頭では前へのポインタが NULL になる)。"

#. type: Plain text
#: build/C/man3/insque.3:78
msgid ""
"The B<insque>()  function inserts the element pointed to by I<elem> "
"immediately after the element pointed to by I<prev>."
msgstr ""
"B<insque>() 関数は I<elem> で示される要素を I<prev> で示される\n"
"要素の直後に挿入する。"

#. type: Plain text
#: build/C/man3/insque.3:85
msgid ""
"If the list is linear, then the call I<insque(elem, NULL)> can be used to "
"insert the initial list element, and the call sets the forward and backward "
"pointers of I<elem> to NULL."
msgstr ""
"リストが線形の場合、I<insque(elem, NULL)> を呼び出すと、\n"
"リストの最初の要素を挿入することができる。\n"
"この呼び出しを行うと I<elem> の次へのポインタと前へのポインタに\n"
"共に NULL が設定される。"

#. type: Plain text
#: build/C/man3/insque.3:94
msgid ""
"If the list is circular, the caller should ensure that the forward and "
"backward pointers of the first element are initialized to point to that "
"element, and the I<prev> argument of the B<insque>()  call should also point "
"to the element."
msgstr ""
"リストが環状の場合、呼び出す側が、最初の要素の次へのポインタと前へのポイン"
"タ\n"
"が自分自身を指し、また  B<insque>() の呼び出しで I<prev> 引き数が最初の要素\n"
"を指すように保証しなければならない。"

#. type: Plain text
#: build/C/man3/insque.3:99
msgid ""
"The B<remque>()  function removes the element pointed to by I<elem> from the "
"doubly-linked list."
msgstr ""
"B<remque>() 関数は I<elem> で示される要素を双方向連結リストから取り除く。"

#. type: Plain text
#: build/C/man3/insque.3:101
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/insque.3:105
msgid ""
"Traditionally (e.g., SunOS, Linux libc 4 and libc 5), the arguments of these "
"functions were of type I<struct qelem *>, defined as:"
msgstr ""
"伝統的に (SunOS, Linux libc 4,5 では) これらの関数の引き数は I<struct qelem "
"*>型であり、これは以下のように定義されている。"

#. type: Plain text
#: build/C/man3/insque.3:113
#, no-wrap
msgid ""
"struct qelem {\n"
"    struct qelem *q_forw;\n"
"    struct qelem *q_back;\n"
"    char          q_data[1];\n"
"};\n"
msgstr ""
"struct qelem {\n"
"    struct qelem *q_forw;\n"
"    struct qelem *q_back;\n"
"    char          q_data[1];\n"
"};\n"

#. type: Plain text
#: build/C/man3/insque.3:120
msgid ""
"This is still what you will get if B<_GNU_SOURCE> is defined before "
"including I<E<lt>search.hE<gt>>."
msgstr ""
"この定義は I<E<lt>search.hE<gt>> をインクルードする前に B<_GNU_SOURCE> を定義"
"することで得られる。"

#. type: Plain text
#: build/C/man3/insque.3:127
msgid ""
"The location of the prototypes for these functions differs among several "
"versions of UNIX.  The above is the POSIX version.  Some systems place them "
"in I<E<lt>string.hE<gt>>.  Linux libc4 and libc 5 placed them in "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""
"これらの関数のプロトタイプの置かれる場所は、UNIX の種類により異なる。\n"
"上記は POSIX 版である。 I<E<lt>string.hE<gt>> にあるシステムもある。\n"
"Linux libc4 と libc5 ではプロトタイプは I<E<lt>stdlib.hE<gt>> に置かれてい"
"る。"

#. type: Plain text
#: build/C/man3/insque.3:134
msgid ""
"In glibc 2.4 and earlier, it was not possible to specify I<prev> as NULL.  "
"Consequently, to build a linear list, the caller had to build a list using "
"an initial call that contained the first two elements of the list, with the "
"forward and backward pointers in each element suitably initialized."
msgstr ""
"glibc 2.4 以前では I<prev> に NULL を指定することができなかった。\n"
"その結果、線形のリストを作成するためには、\n"
"呼び出し側は、最初の呼び出しで、リストの最初の 2 つの要素を持ち、\n"
"各要素の次へのポインタと前へのポインタを適切に初期化したリストを\n"
"作成しなければならなかった。"

#. type: Plain text
#: build/C/man3/insque.3:138
msgid ""
"The program below demonstrates the use of B<insque>().  Here is an example "
"run of the program:"
msgstr ""
"次のプログラムは B<insque>() の使用法を示したものである。\n"
"下記はプログラムの実行例である。"

#. type: Plain text
#: build/C/man3/insque.3:147
#, no-wrap
msgid ""
"$ B<./a.out -c a b c>\n"
"Traversing completed list:\n"
"    a\n"
"    b\n"
"    c\n"
"That was a circular list\n"
msgstr ""
"$ B<./a.out -c a b c>\n"
"Traversing completed list:\n"
"    a\n"
"    b\n"
"    c\n"
"That was a circular list\n"

#. type: SS
#: build/C/man3/insque.3:149
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/insque.3:156
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>search.hE<gt>\n"

#. type: Plain text
#: build/C/man3/insque.3:162
#, no-wrap
msgid ""
"struct element {\n"
"    struct element *forward;\n"
"    struct element *backward;\n"
"    char *name;\n"
"};\n"
msgstr ""
"struct element {\n"
"    struct element *forward;\n"
"    struct element *backward;\n"
"    char *name;\n"
"};\n"

#. type: Plain text
#: build/C/man3/insque.3:167
#, no-wrap
msgid ""
"static struct element *\n"
"new_element(void)\n"
"{\n"
"    struct element *e;\n"
msgstr ""
"static struct element *\n"
"new_element(void)\n"
"{\n"
"    struct element *e;\n"

#. type: Plain text
#: build/C/man3/insque.3:173
#, no-wrap
msgid ""
"    e = malloc(sizeof(struct element));\n"
"    if (e == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    e = malloc(sizeof(struct element));\n"
"    if (e == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:176
#, no-wrap
msgid ""
"    return e;\n"
"}\n"
msgstr ""
"    return e;\n"
"}\n"

#. type: Plain text
#: build/C/man3/insque.3:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct element *first, *elem, *prev;\n"
"    int circular, opt, errfnd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct element *first, *elem, *prev;\n"
"    int circular, opt, errfnd;\n"

#. type: Plain text
#: build/C/man3/insque.3:185
#, no-wrap
msgid ""
"    /* The \"-c\" command-line option can be used to specify that the\n"
"       list is circular */\n"
msgstr ""
"    /* The \"-c\" command-line option can be used to specify that the\n"
"       list is circular */\n"

#. type: Plain text
#: build/C/man3/insque.3:198
#, no-wrap
msgid ""
"    errfnd = 0;\n"
"    circular = 0;\n"
"    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
"        switch (opt) {\n"
"        case 'c':\n"
"            circular = 1;\n"
"            break;\n"
"        default:\n"
"            errfnd = 1;\n"
"            break;\n"
"        }\n"
"    }\n"
msgstr ""
"    errfnd = 0;\n"
"    circular = 0;\n"
"    while ((opt = getopt(argc, argv, \"c\")) != -1) {\n"
"        switch (opt) {\n"
"        case 'c':\n"
"            circular = 1;\n"
"            break;\n"
"        default:\n"
"            errfnd = 1;\n"
"            break;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:203
#, no-wrap
msgid ""
"    if (errfnd || optind E<gt>= argc) {\n"
"        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (errfnd || optind E<gt>= argc) {\n"
"        fprintf(stderr,  \"Usage: %s [-c] string...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:205
#, no-wrap
msgid "    /* Create first element and place it in the linked list */\n"
msgstr "    /* Create first element and place it in the linked list */\n"

#. type: Plain text
#: build/C/man3/insque.3:208
#, no-wrap
msgid ""
"    elem = new_element();\n"
"    first = elem;\n"
msgstr ""
"    elem = new_element();\n"
"    first = elem;\n"

#. type: Plain text
#: build/C/man3/insque.3:210
#, no-wrap
msgid "    elem-E<gt>name = argv[optind];\n"
msgstr "    elem-E<gt>name = argv[optind];\n"

#. type: Plain text
#: build/C/man3/insque.3:218
#, no-wrap
msgid ""
"    if (circular) {\n"
"        elem-E<gt>forward = elem;\n"
"        elem-E<gt>backward = elem;\n"
"        insque(elem, elem);\n"
"    } else {\n"
"        insque(elem, NULL);\n"
"    }\n"
msgstr ""
"    if (circular) {\n"
"        elem-E<gt>forward = elem;\n"
"        elem-E<gt>backward = elem;\n"
"        insque(elem, elem);\n"
"    } else {\n"
"        insque(elem, NULL);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:220
#, no-wrap
msgid "    /* Add remaining command-line arguments as list elements */\n"
msgstr "    /* Add remaining command-line arguments as list elements */\n"

#. type: Plain text
#: build/C/man3/insque.3:223
#, no-wrap
msgid ""
"    while (++optind E<lt> argc) {\n"
"        prev = elem;\n"
msgstr ""
"    while (++optind E<lt> argc) {\n"
"        prev = elem;\n"

#. type: Plain text
#: build/C/man3/insque.3:228
#, no-wrap
msgid ""
"        elem = new_element();\n"
"        elem-E<gt>name = argv[optind];\n"
"        insque(elem, prev);\n"
"    }\n"
msgstr ""
"        elem = new_element();\n"
"        elem-E<gt>name = argv[optind];\n"
"        insque(elem, prev);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/insque.3:230
#, no-wrap
msgid "    /* Traverse the list from the start, printing element names */\n"
msgstr "    /* Traverse the list from the start, printing element names */\n"

#. type: Plain text
#: build/C/man3/insque.3:237
#, no-wrap
msgid ""
"    printf(\"Traversing completed list:\\en\");\n"
"    elem = first;\n"
"    do {\n"
"        printf(\"    %s\\en\", elem-E<gt>name);\n"
"        elem = elem-E<gt>forward;\n"
"    } while (elem != NULL && elem != first);\n"
msgstr ""
"    printf(\"Traversing completed list:\\en\");\n"
"    elem = first;\n"
"    do {\n"
"        printf(\"    %s\\en\", elem-E<gt>name);\n"
"        elem = elem-E<gt>forward;\n"
"    } while (elem != NULL && elem != first);\n"

#. type: Plain text
#: build/C/man3/insque.3:240
#, no-wrap
msgid ""
"    if (elem == first)\n"
"        printf(\"That was a circular list\\en\");\n"
msgstr ""
"    if (elem == first)\n"
"        printf(\"That was a circular list\\en\");\n"

#. type: Plain text
#: build/C/man3/insque.3:243
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: TH
#: build/C/man3/lsearch.3:26
#, no-wrap
msgid "LSEARCH"
msgstr "LSEARCH"

#. type: TH
#: build/C/man3/lsearch.3:26
#, no-wrap
msgid "1999-09-27"
msgstr "1999-09-27"

#. type: Plain text
#: build/C/man3/lsearch.3:29
msgid "lfind, lsearch - linear search of an array"
msgstr "lfind, lsearch - 配列を線形検索する"

#. type: Plain text
#: build/C/man3/lsearch.3:35
#, no-wrap
msgid ""
"B<void *lfind(const void *>I<key>B<, const void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *lfind(const void *>I<key>B<, const void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/lsearch.3:38
#, no-wrap
msgid ""
"B<void *lsearch(const void *>I<key>B<, void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *lsearch(const void *>I<key>B<, void *>I<base>B<, size_t *>I<nmemb>B<,>\n"
"B<         size_t >I<size>B<, int(*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/lsearch.3:61
msgid ""
"B<lfind>()  and B<lsearch>()  perform a linear search for I<key> in the "
"array I<base> which has I<*nmemb> elements of I<size> bytes each.  The "
"comparison function referenced by I<compar> is expected to have two "
"arguments which point to the I<key> object and to an array member, in that "
"order, and which returns zero if the I<key> object matches the array member, "
"and nonzero otherwise."
msgstr ""
"B<lfind>()  と B<lsearch>()  は、 I<size> バイトの要素 I<*nmemb> 個からなる配"
"列 I<base> から、 I<key> を線形検索する。比較を行うのは I<compar> が参照して"
"いる関数で、 これは 2つの引き数を持ち、1つめの引き数が I<key> を、2つめの引き"
"数は配列メンバーを指す。また I<compar> は、 I<key> が配列のメンバーとマッチし"
"たなら 0、そうでなければ 0 以外を返すことが期待されている。"

#. type: Plain text
#: build/C/man3/lsearch.3:72
msgid ""
"If B<lsearch>()  does not find a matching element, then the I<key> object is "
"inserted at the end of the table, and I<*nmemb> is incremented.  In "
"particular, one should know that a matching element exists, or that more "
"room is available."
msgstr ""
"B<lsearch>()  は、マッチする要素を見つけられなかったとき、 配列の最後に "
"I<key> をつけ加える。そして I<*nmemb> を 1 ふやす。 したがって、この関数を使"
"用する際には、マッチする要素が存在するか、 もしくは配列に要素を追加するための"
"領域があるか、を把握しておく必要がある。"

#. type: Plain text
#: build/C/man3/lsearch.3:80
msgid ""
"B<lfind>()  returns a pointer to a matching member of the array, or NULL if "
"no match is found.  B<lsearch>()  returns a pointer to a matching member of "
"the array, or to the newly added member if no match is found."
msgstr ""
"B<lfind>()  の返り値は、配列のマッチしたメンバーへのポインタである。 もしマッ"
"チするメンバーが見つからないと NULL を返す。 B<lsearch>()  の返り値も、配列の"
"マッチしたメンバーへのポインタである。 マッチするメンバーが見つからなかったと"
"きは、 新たにつけ加えたメンバーへのポインタを返す。"

#. type: Plain text
#: build/C/man3/lsearch.3:83
msgid "SVr4, 4.3BSD, POSIX.1-2001.  Present in libc since libc-4.6.27."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  libc には libc-4.6.27 以降で実装されている。"

#. type: Plain text
#: build/C/man3/lsearch.3:85
msgid "The naming is unfortunate."
msgstr "関数の名前の選び方がよくない。"

#. type: Plain text
#: build/C/man3/lsearch.3:89
msgid "B<bsearch>(3), B<hsearch>(3), B<tsearch>(3)"
msgstr "B<bsearch>(3), B<hsearch>(3), B<tsearch>(3)"

#. type: TH
#: build/C/man3/qsort.3:37
#, no-wrap
msgid "QSORT"
msgstr "QSORT"

#. type: TH
#: build/C/man3/qsort.3:37
#, no-wrap
msgid "2012-03-08"
msgstr "2012-03-08"

#. type: Plain text
#: build/C/man3/qsort.3:40
msgid "qsort, qsort_r - sort an array"
msgstr "qsort, qsort_r - 配列を並べ変える"

#. type: Plain text
#: build/C/man3/qsort.3:46
#, no-wrap
msgid ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void qsort(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/qsort.3:50
#, no-wrap
msgid ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *, void *),>\n"
"B<           void *>I<arg>B<);>\n"
msgstr ""
"B<void qsort_r(void *>I<base>B<, size_t >I<nmemb>B<, size_t >I<size>B<,>\n"
"B<           int (*>I<compar>B<)(const void *, const void *, void *),>\n"
"B<           void *>I<arg>B<);>\n"

#. type: Plain text
#: build/C/man3/qsort.3:60
msgid "B<qsort_r>(): _GNU_SOURCE"
msgstr "B<qsort_r>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/qsort.3:68
msgid ""
"The B<qsort>()  function sorts an array with I<nmemb> elements of size "
"I<size>.  The I<base> argument points to the start of the array."
msgstr ""
"B<qsort>()  関数は、 I<nmemb> 個の大きさ I<size> の要素をもつ配列を並べ変え"
"る。 I<base> 引き数は配列の先頭へのポインタである。"

#. type: Plain text
#: build/C/man3/qsort.3:72
msgid ""
"The contents of the array are sorted in ascending order according to a "
"comparison function pointed to by I<compar>, which is called with two "
"arguments that point to the objects being compared."
msgstr ""
"I<compar> をポインタとする比較関数によって、 配列の中身は昇順 (値の大きいもの"
"ほど後に並ぶ順番) に並べられる。 比較関数の引き数は比較されるふたつのオブジェ"
"クトのポインタである。"

#. type: Plain text
#: build/C/man3/qsort.3:78
msgid ""
"The comparison function must return an integer less than, equal to, or "
"greater than zero if the first argument is considered to be respectively "
"less than, equal to, or greater than the second.  If two members compare as "
"equal, their order in the sorted array is undefined."
msgstr ""
"比較関数は、第一引き数が第二引き数に対して、 1) 小さい、2) 等しい、3) 大きい"
"のそれぞれに応じて、 1) ゼロより小さい整数、2) ゼロ、3) ゼロより大きい整数の "
"いずれかを返さなければならない。 二つの要素の比較結果が等しいとき、 並べ変え"
"た後の配列では、これら二つの順序は規定されていない。"

#. type: Plain text
#: build/C/man3/qsort.3:91
msgid ""
"The B<qsort_r>()  function is identical to B<qsort>()  except that the "
"comparison function I<compar> takes a third argument.  A pointer is passed "
"to the comparison function via I<arg>.  In this way, the comparison function "
"does not need to use global variables to pass through arbitrary arguments, "
"and is therefore reentrant and safe to use in threads."
msgstr ""
"B<qsort_r>() 関数は B<qsort>() と同じだが、比較関数 I<compar> が第 3 引き数"
"を\n"
"取る点が異なる。ポインタが I<arg> 経由で比較関数に渡される。\n"
"これにより、比較関数は任意の引き数を渡すためにグローバル変数を使う必要がなく"
"なり、\n"
"そのため、リエントラント (再入可能) で安全にスレッドで使用できるようになる。"

#. type: Plain text
#: build/C/man3/qsort.3:97
msgid "The B<qsort>()  and B<qsort_r>()  functions return no value."
msgstr "関数 B<qsort>() と B<qsort_r>() は値を返さない。"

#. type: SH
#: build/C/man3/qsort.3:97
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/qsort.3:100
msgid "B<qsort_r>()  was added to glibc in version 2.8."
msgstr "B<qsort_r>() は glibc バージョン 2.8 で追加された。"

#. type: Plain text
#: build/C/man3/qsort.3:104
msgid "The B<qsort>()  function conforms to SVr4, 4.3BSD, C89, C99."
msgstr "B<qsort>() 関数は SVr4, 4.3BSD, C89, C99 に準拠している。"

#. type: Plain text
#: build/C/man3/qsort.3:116
msgid ""
"Library routines suitable for use as the I<compar> argument to B<qsort>()  "
"include B<alphasort>(3)  and B<versionsort>(3).  To compare C strings, the "
"comparison function can call B<strcmp>(3), as shown in the example below."
msgstr ""
"B<qsort>() の I<compar> 引き数に使用するのに適しているライブラリルーチンと\n"
"しては B<alphasort>(3), B<versionsort>(3) がある。 C の文字列を比較する場"
"合、\n"
"以下の例にあるように比較関数で B<strcmp>(3) を呼び出すこともできる。"

#. type: Plain text
#: build/C/man3/qsort.3:119
msgid "For one example of use, see the example under B<bsearch>(3)."
msgstr "使用例については、 B<bsearch>(3)  にある例を参照すること。"

#. type: Plain text
#: build/C/man3/qsort.3:122
msgid ""
"Another example is the following program, which sorts the strings given in "
"its command-line arguments:"
msgstr ""
"以下のプログラムに別の使用例を示す。このプログラムは、 コマンドライン引き数で"
"指定された文字列の並び換えを行う。"

#. type: Plain text
#: build/C/man3/qsort.3:134
#, no-wrap
msgid ""
"static int\n"
"cmpstringp(const void *p1, const void *p2)\n"
"{\n"
"    /* The actual arguments to this function are \"pointers to\n"
"       pointers to char\", but strcmp(3) arguments are \"pointers\n"
"       to char\", hence the following cast plus dereference */\n"
msgstr ""
"static int\n"
"cmpstringp(const void *p1, const void *p2)\n"
"{\n"
"    /* この関数の実際の引き数は \"char 型へのポインタのポインタ\" だが、\n"
"       strcmp(3) の引き数は \"char 型へのポインタ\" である。\n"
"       そこで、以下のようにキャストをしてからポインタの逆参照を行う。*/\n"

#. type: Plain text
#: build/C/man3/qsort.3:137
#, no-wrap
msgid ""
"    return strcmp(* (char * const *) p1, * (char * const *) p2);\n"
"}\n"
msgstr ""
"    return strcmp(* (char * const *) p1, * (char * const *) p2);\n"
"}\n"

#. type: Plain text
#: build/C/man3/qsort.3:142
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: build/C/man3/qsort.3:147
#, fuzzy, no-wrap
#| msgid ""
#| "    if (argc E<lt> 2) {\n"
#| "\tfprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
#| "\texit(EXIT_FAILURE);\n"
#| "    }\n"
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>stringE<gt>...\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/qsort.3:149
#, no-wrap
msgid "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"
msgstr "    qsort(&argv[1], argc - 1, sizeof(char *), cmpstringp);\n"

#. type: Plain text
#: build/C/man3/qsort.3:154
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        puts(argv[j]);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        puts(argv[j]);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/qsort.3:160
msgid "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"
msgstr "B<sort>(1), B<alphasort>(3), B<strcmp>(3), B<versionsort>(3)"

#. type: TH
#: build/C/man3/tsearch.3:25
#, no-wrap
msgid "TSEARCH"
msgstr "TSEARCH"

#. type: Plain text
#: build/C/man3/tsearch.3:28
msgid "tsearch, tfind, tdelete, twalk, tdestroy - manage a binary tree"
msgstr "tsearch, tfind, tdelete, twalk, tdestroy - 二分木 (binary tree) の操作"

#. type: Plain text
#: build/C/man3/tsearch.3:34
#, no-wrap
msgid ""
"B<void *tsearch(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *tsearch(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:37
#, no-wrap
msgid ""
"B<void *tfind(const void *>I<key>B<, const void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *tfind(const void *>I<key>B<, const void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:40
#, no-wrap
msgid ""
"B<void *tdelete(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"
msgstr ""
"B<void *tdelete(const void *>I<key>B<, void **>I<rootp>B<,>\n"
"B<                int (*>I<compar>B<)(const void *, const void *));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:44
#, no-wrap
msgid ""
"B<void twalk(const void *>I<root>B<, void (*>I<action>B<)(const void *>I<nodep>B<,>\n"
"B<                                   const VISIT >I<which>B<,>\n"
"B<                                   const int >I<depth>B<));>\n"
msgstr ""
"B<void twalk(const void *>I<root>B<, void (*>I<action>B<)(const void *>I<nodep>B<,>\n"
"B<                                   const VISIT >I<which>B<,>\n"
"B<                                   const int >I<depth>B<));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:50
#, no-wrap
msgid "B<void tdestroy(void *>I<root>B<, void (*>I<free_node>B<)(void *>I<nodep>B<));>\n"
msgstr "B<void tdestroy(void *>I<root>B<, void (*>I<free_node>B<)(void *>I<nodep>B<));>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:69
msgid ""
"B<tsearch>(), B<tfind>(), B<twalk>(), and B<tdelete>()  manage a binary "
"tree.  They are generalized from Knuth (6.2.2) Algorithm T.  The first field "
"in each node of the tree is a pointer to the corresponding data item.  (The "
"calling program must store the actual data.)  I<compar> points to a "
"comparison routine, which takes pointers to two items.  It should return an "
"integer which is negative, zero, or positive, depending on whether the first "
"item is less than, equal to, or greater than the second."
msgstr ""
"B<tsearch>(), B<tfind>(), B<twalk>(), B<tdelete>()  は 二分木を操作する関数で"
"ある。 これらの関数は Knuth (6.2.2) Algorithm T に基づいている。 木構造におけ"
"る各ノードの最初のフィールドは、対応するデータ・ アイテムへのポインタであ"
"る。 (参照先のデータは、呼び出しプログラムで用意する。)  I<compar> は比較ルー"
"チンへのポインタである。 比較ルーチンは、アイテムへのポインタ 2 つを引き数に"
"持つ。 比較ルーチンの返り値は、1 つ目のアイテムが 2 つ目のアイテムよりも 「小"
"さい、等しい、大きい」によって、 「負、0、正」の整数値でなければならない。"

#. type: Plain text
#: build/C/man3/tsearch.3:88
msgid ""
"B<tsearch>()  searches the tree for an item.  I<key> points to the item to "
"be searched for.  I<rootp> points to a variable which points to the root of "
"the tree.  If the tree is empty, then the variable that I<rootp> points to "
"should be set to NULL.  If the item is found in the tree, then B<tsearch>()  "
"returns a pointer to it.  If it is not found, then B<tsearch>()  adds it, "
"and returns a pointer to the newly added item."
msgstr ""
"B<tsearch>()  は、木構造からアイテムを検索する関数である。 I<key> は、検索す"
"るアイテムへのポインタである。 I<rootp> は木構造の根へのポインタへのポインタ"
"である。 木構造がノードを含まない場合、I<rootp> の参照している変数は NULL に"
"設定されていなければならない。 木構造にアイテムが見つかった場合、 B<tsearch>"
"()  はそのアイテムへのポインタを返す。 見つからなかった場合は、アイテムを木構"
"造に追加し、 追加したアイテムへのポインタを返す。"

#. type: Plain text
#: build/C/man3/tsearch.3:96
msgid ""
"B<tfind>()  is like B<tsearch>(), except that if the item is not found, then "
"B<tfind>()  returns NULL."
msgstr ""
"B<tfind>()  は、 B<tsearch>()  に似ているが、 アイテムが見つからなかった場合 "
"NULL を返す点が異なる。"

#. type: Plain text
#: build/C/man3/tsearch.3:101
msgid ""
"B<tdelete>()  deletes an item from the tree.  Its arguments are the same as "
"for B<tsearch>()."
msgstr ""
"B<tdelete>()  は木構造からアイテムを削除する。 引き数は B<tsearch>()  と同じ"
"である。"

#. type: Plain text
#: build/C/man3/tsearch.3:136
msgid ""
"B<twalk>()  performs depth-first, left-to-right traversal of a binary tree.  "
"I<root> points to the starting node for the traversal.  If that node is not "
"the root, then only part of the tree will be visited.  B<twalk>()  calls the "
"user function I<action> each time a node is visited (that is, three times "
"for an internal node, and once for a leaf).  I<action>, in turn, takes three "
"arguments.  The first argument is a pointer to the node being visited.  The "
"structure of the node is unspecified, but it is possible to cast the pointer "
"to a pointer-to-pointer-to-element in order to access the element stored "
"within the node.  The application must not modify the structure pointed to "
"by this argument.  The second argument is an integer which takes one of the "
"values B<preorder>, B<postorder>, or B<endorder> depending on whether this "
"is the first, second, or third visit to the internal node, or the value "
"B<leaf> if this is the single visit to a leaf node.  (These symbols are "
"defined in I<E<lt>search.hE<gt>>.)  The third argument is the depth of the "
"node; the root node has depth zero."
msgstr ""
"B<twalk>()  は、二分木を深さ優先 (depth-first) で、 左から右にたどっていく関"
"数である。 I<root> は起点となるノードへのポインタである。 I<root> に根以外の"
"ノードを指定すると、部分木が対象となる。 B<twalk>()  は、ノードを訪れる度に"
"ユーザ関数 I<action> を呼び出す (内部ノードに対しては 3 回、葉に対しては 1 回"
"呼び出しが行われる)。 I<action> には以下の順に 3 つの引き数が与えられる。 最"
"初の引き数は訪れたノードへのポインタである。 ノードの構造体は規定されていない"
"が、 ポインタを要素へのポインタのポインタにキャストし、 ノードに格納された要"
"素にアクセスすることができる。 アプリケーションは、この引き数が指す構造体を変"
"更してはならない。 2 番目の引き数には、内部ノードの場合は訪問回数に応じて "
"B<preorder>, B<postorder>, B<endorder> のいずれかの整数が、 葉を最初に訪れた"
"場合は B<leaf> の値が渡される (これらのシンボルは I<E<lt>search.hE<gt>> で定"
"義されている)。  3 番目の引き数はノードの深さで、根の場合は深さ 0 である。"

#. type: Plain text
#: build/C/man3/tsearch.3:152
msgid ""
"(More commonly, B<preorder>, B<postorder>, and B<endorder> are known as "
"B<preorder>, B<inorder>, and B<postorder>: before visiting the children, "
"after the first and before the second, and after visiting the children.  "
"Thus, the choice of name B<post\\%order> is rather confusing.)"
msgstr ""
"(より一般的には、B<preorder>, B<postorder>, B<endorder> は B<preorder>, "
"B<inorder>, B<postorder> として知られている: それぞれ、子要素を辿る前・最初の"
"子要素を辿った後かつ 2 番目の子要素を辿る前・ 子要素を辿った後ということを表"
"している。 よって B<post\\%order> という名前を選ぶのは少し紛らわしい。)"

#. type: Plain text
#: build/C/man3/tsearch.3:167
msgid ""
"B<tdestroy>()  removes the whole tree pointed to by I<root>, freeing all "
"resources allocated by the B<tsearch>()  function.  For the data in each "
"tree node the function I<free_node> is called.  The pointer to the data is "
"passed as the argument to the function.  If no such work is necessary, "
"I<free_node> must point to a function doing nothing."
msgstr ""
"B<tdestroy>()  は I<root> が指す木構造全体を削除し、 B<tsearch>()  関数で確保"
"されたリソースを全て解放する。 木構造の各ノードについて、関数 I<free_node> が"
"呼び出される。 データへのポインタがこの関数の引き数として渡される。 そのよう"
"な動作が必要でなければ、 I<free_node> は何もしない関数へのポインタでなければ"
"ならない。"

#. type: Plain text
#: build/C/man3/tsearch.3:177
msgid ""
"B<tsearch>()  returns a pointer to a matching item in the tree, or to the "
"newly added item, or NULL if there was insufficient memory to add the item.  "
"B<tfind>()  returns a pointer to the item, or NULL if no match is found.  If "
"there are multiple elements that match the key, the element returned is "
"unspecified."
msgstr ""
"B<tsearch>()  は、木構造に見つかったアイテムか、 新しく追加したアイテムへのポ"
"インタを返す。 メモリの不足のためアイテムを追加できなかった場合は NULL を返"
"す。 B<tfind>()  は、アイテムへのポインタを返す。 一致するアイテムが見つから"
"ない場合は NULL を返す。 検索条件に一致する要素が複数ある場合、返される値は不"
"定である。"

#. type: Plain text
#: build/C/man3/tsearch.3:181
msgid ""
"B<tdelete>()  returns a pointer to the parent of the item deleted, or NULL "
"if the item was not found."
msgstr ""
"B<tdelete>()  は削除したアイテムの親へのポインタを返す。 アイテムが見つからな"
"かった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/tsearch.3:190
msgid ""
"B<tsearch>(), B<tfind>(), and B<tdelete>()  also return NULL if I<rootp> was "
"NULL on entry."
msgstr ""
"I<rootp> が NULL の場合、 B<tsearch>(), B<tfind>(), B<tdelete>()  は NULL を"
"返す。"

#. type: Plain text
#: build/C/man3/tsearch.3:195
msgid "SVr4, POSIX.1-2001.  The function B<tdestroy>()  is a GNU extension."
msgstr "SVr4, POSIX.1-2001.  関数 B<tdestroy>()  は GNU の拡張である。"

#. type: Plain text
#: build/C/man3/tsearch.3:199
msgid ""
"B<twalk>()  takes a pointer to the root, while the other functions take a "
"pointer to a variable which points to the root."
msgstr ""
"B<twalk>()  は根へのポインタを引き数にとるが、 ほかの関数は根へのポインタへの"
"ポインタである。"

#. type: Plain text
#: build/C/man3/tsearch.3:204
msgid ""
"B<tdelete>()  frees the memory required for the node in the tree.  The user "
"is responsible for freeing the memory for the corresponding data."
msgstr ""
"B<tdelete>()  は、削除したノードの使用していたメモリを解放するが、 ノードに対"
"応するデータのメモリは、ユーザが解放しなければならない。"

#. type: Plain text
#: build/C/man3/tsearch.3:212
msgid ""
"The example program depends on the fact that B<twalk>()  makes no further "
"reference to a node after calling the user function with argument \"endorder"
"\" or \"leaf\".  This works with the GNU library implementation, but is not "
"in the System V documentation."
msgstr ""
"下のプログラム例は、ユーザ関数が \"endorder\" か \"leaf\" を引き数にして 呼び"
"出されて以降は、 B<twalk>()  がそのノードを参照しないことを前提としている。 "
"これは GNU ライブラリの実装では機能するが、System V のマニュアルには存在しな"
"い。"

#. type: Plain text
#: build/C/man3/tsearch.3:216
msgid ""
"The following program inserts twelve random numbers into a binary tree, "
"where duplicate numbers are collapsed, then prints the numbers in order."
msgstr ""
"以下のプログラムは 12 個の乱数を二分木に挿入した後、 挿入した数を順番に出力す"
"る (挿入の際、重複した乱数は 1 つにまとめられる)。"

#. type: Plain text
#: build/C/man3/tsearch.3:223
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* Expose declaration of tdestroy() */\n"
"#include E<lt>search.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* Expose declaration of tdestroy() */\n"
"#include E<lt>search.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"

#. type: Plain text
#: build/C/man3/tsearch.3:225
#, fuzzy, no-wrap
#| msgid "void *root = NULL;\n"
msgid "static void *root = NULL;\n"
msgstr "void *root = NULL;\n"

#. type: Plain text
#: build/C/man3/tsearch.3:236
#, fuzzy, no-wrap
#| msgid ""
#| "void *\n"
#| "xmalloc(unsigned n)\n"
#| "{\n"
#| "    void *p;\n"
#| "    p = malloc(n);\n"
#| "    if (p)\n"
#| "        return p;\n"
#| "    fprintf(stderr, \"insufficient memory\\en\");\n"
#| "    exit(EXIT_FAILURE);\n"
#| "}\n"
msgid ""
"static void *\n"
"xmalloc(unsigned n)\n"
"{\n"
"    void *p;\n"
"    p = malloc(n);\n"
"    if (p)\n"
"        return p;\n"
"    fprintf(stderr, \"insufficient memory\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"void *\n"
"xmalloc(unsigned n)\n"
"{\n"
"    void *p;\n"
"    p = malloc(n);\n"
"    if (p)\n"
"        return p;\n"
"    fprintf(stderr, \"insufficient memory\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:246
#, fuzzy, no-wrap
#| msgid ""
#| "int\n"
#| "compare(const void *pa, const void *pb)\n"
#| "{\n"
#| "    if (*(int *) pa E<lt> *(int *) pb)\n"
#| "        return -1;\n"
#| "    if (*(int *) pa E<gt> *(int *) pb)\n"
#| "        return 1;\n"
#| "    return 0;\n"
#| "}\n"
msgid ""
"static int\n"
"compare(const void *pa, const void *pb)\n"
"{\n"
"    if (*(int *) pa E<lt> *(int *) pb)\n"
"        return -1;\n"
"    if (*(int *) pa E<gt> *(int *) pb)\n"
"        return 1;\n"
"    return 0;\n"
"}\n"
msgstr ""
"int\n"
"compare(const void *pa, const void *pb)\n"
"{\n"
"    if (*(int *) pa E<lt> *(int *) pb)\n"
"        return -1;\n"
"    if (*(int *) pa E<gt> *(int *) pb)\n"
"        return 1;\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:251
#, fuzzy, no-wrap
#| msgid ""
#| "void\n"
#| "action(const void *nodep, const VISIT which, const int depth)\n"
#| "{\n"
#| "    int *datap;\n"
msgid ""
"static void\n"
"action(const void *nodep, const VISIT which, const int depth)\n"
"{\n"
"    int *datap;\n"
msgstr ""
"void\n"
"action(const void *nodep, const VISIT which, const int depth)\n"
"{\n"
"    int *datap;\n"

#. type: Plain text
#: build/C/man3/tsearch.3:267
#, no-wrap
msgid ""
"    switch (which) {\n"
"    case preorder:\n"
"        break;\n"
"    case postorder:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    case endorder:\n"
"        break;\n"
"    case leaf:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    }\n"
"}\n"
msgstr ""
"    switch (which) {\n"
"    case preorder:\n"
"        break;\n"
"    case postorder:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    case endorder:\n"
"        break;\n"
"    case leaf:\n"
"        datap = *(int **) nodep;\n"
"        printf(\"%6d\\en\", *datap);\n"
"        break;\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:273
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    int i, *ptr;\n"
"    void *val;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    int i, *ptr;\n"
"    void *val;\n"

#. type: Plain text
#: build/C/man3/tsearch.3:288
#, no-wrap
msgid ""
"    srand(time(NULL));\n"
"    for (i = 0; i E<lt> 12; i++) {\n"
"        ptr = xmalloc(sizeof(int));\n"
"        *ptr = rand() & 0xff;\n"
"        val = tsearch((void *) ptr, &root, compare);\n"
"        if (val == NULL)\n"
"            exit(EXIT_FAILURE);\n"
"        else if ((*(int **) val) != ptr)\n"
"            free(ptr);\n"
"    }\n"
"    twalk(root, action);\n"
"    tdestroy(root, free);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    srand(time(NULL));\n"
"    for (i = 0; i E<lt> 12; i++) {\n"
"        ptr = xmalloc(sizeof(int));\n"
"        *ptr = rand() & 0xff;\n"
"        val = tsearch((void *) ptr, &root, compare);\n"
"        if (val == NULL)\n"
"            exit(EXIT_FAILURE);\n"
"        else if ((*(int **) val) != ptr)\n"
"            free(ptr);\n"
"    }\n"
"    twalk(root, action);\n"
"    tdestroy(root, free);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/tsearch.3:294
msgid "B<bsearch>(3), B<hsearch>(3), B<lsearch>(3), B<qsort>(3)"
msgstr "B<bsearch>(3), B<hsearch>(3), B<lsearch>(3)  B<qsort>(3)"

#~ msgid "2013-07-22"
#~ msgstr "2013-07-22"

#~ msgid "2012-08-03"
#~ msgstr "2012-08-03"

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-04-25 05:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/aio.7:24
#, no-wrap
msgid "AIO"
msgstr ""

#. type: TH
#: build/C/man7/aio.7:24 build/C/man3/aio_fsync.3:23 build/C/man3/aio_suspend.3:24 build/C/man3/aio_write.3:23
#, no-wrap
msgid "2010-10-02"
msgstr ""

#. type: TH
#: build/C/man7/aio.7:24 build/C/man3/aio_init.3:24 build/C/man2/io_cancel.2:23 build/C/man2/io_destroy.2:23 build/C/man2/io_getevents.2:23 build/C/man2/io_setup.2:23 build/C/man2/io_submit.2:23
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/aio.7:24 build/C/man3/aio_cancel.3:23 build/C/man3/aio_error.3:23 build/C/man3/aio_fsync.3:23 build/C/man3/aio_init.3:24 build/C/man3/aio_read.3:23 build/C/man3/aio_return.3:23 build/C/man3/aio_suspend.3:24 build/C/man3/aio_write.3:23 build/C/man2/io_cancel.2:23 build/C/man2/io_destroy.2:23 build/C/man2/io_getevents.2:23 build/C/man2/io_setup.2:23 build/C/man2/io_submit.2:23 build/C/man3/lio_listio.3:23
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/aio.7:25 build/C/man3/aio_cancel.3:24 build/C/man3/aio_error.3:24 build/C/man3/aio_fsync.3:24 build/C/man3/aio_init.3:25 build/C/man3/aio_read.3:24 build/C/man3/aio_return.3:24 build/C/man3/aio_suspend.3:25 build/C/man3/aio_write.3:24 build/C/man2/io_cancel.2:24 build/C/man2/io_destroy.2:24 build/C/man2/io_getevents.2:24 build/C/man2/io_setup.2:24 build/C/man2/io_submit.2:24 build/C/man3/lio_listio.3:24
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:27
msgid "aio - POSIX asynchronous I/O overview"
msgstr ""

#. type: SH
#: build/C/man7/aio.7:27 build/C/man3/aio_cancel.3:32 build/C/man3/aio_error.3:32 build/C/man3/aio_fsync.3:32 build/C/man3/aio_init.3:36 build/C/man3/aio_read.3:32 build/C/man3/aio_return.3:32 build/C/man3/aio_suspend.3:38 build/C/man3/aio_write.3:32 build/C/man2/io_cancel.2:42 build/C/man2/io_destroy.2:40 build/C/man2/io_getevents.2:43 build/C/man2/io_setup.2:40 build/C/man2/io_submit.2:41 build/C/man3/lio_listio.3:35
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:35
msgid ""
"The POSIX asynchronous I/O (AIO) interface allows applications to initiate "
"one or more I/O operations that are performed asynchronously (i.e., in the "
"background).  The application can elect to be notified of completion of the "
"I/O operation in a variety of ways: by delivery of a signal, by "
"instantiation of a thread, or no notification at all."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:37
msgid "The POSIX AIO interface consists of the following functions:"
msgstr ""

#. type: TP
#: build/C/man7/aio.7:37
#, no-wrap
msgid "B<aio_read>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:42
msgid "Enqueue a read request.  This is the asynchronous analog of B<read>(2)."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:42
#, no-wrap
msgid "B<aio_write>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:47
msgid "Enqueue a write request.  This is the asynchronous analog of B<write>(2)."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:47
#, no-wrap
msgid "B<aio_fsync>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:54
msgid ""
"Enqueue a sync request for the I/O operations on a file descriptor.  This is "
"the asynchronous analog of B<fsync>(2)  and B<fdatasync>(2)."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:54
#, no-wrap
msgid "B<aio_error>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:57
msgid "Obtain the error status of an enqueued I/O request."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:57
#, no-wrap
msgid "B<aio_return>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:60
msgid "Obtain the return status of a completed I/O request."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:60
#, no-wrap
msgid "B<aio_suspend>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:64
msgid ""
"Suspend the caller until one or more of a specified set of I/O requests "
"completes."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:64
#, no-wrap
msgid "B<aio_cancel>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:68
msgid "Attempt to cancel outstanding I/O requests on a specified file descriptor."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:68
#, no-wrap
msgid "B<lio_listio>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:71
msgid "Enqueue multiple I/O requests using a single function call."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:78
msgid ""
"The I<aiocb> (\"asynchronous I/O control block\") structure defines "
"parameters that control an I/O operation.  An argument of this type is "
"employed with all of the functions listed above.  This structure has the "
"following form:"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:82
#, no-wrap
msgid "#include E<lt>aiocb.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:85
#, no-wrap
msgid ""
"struct aiocb {\n"
"    /* The order of these fields is implementation-dependent */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:94
#, no-wrap
msgid ""
"    int             aio_fildes;     /* File descriptor */\n"
"    off_t           aio_offset;     /* File offset */\n"
"    volatile void  *aio_buf;        /* Location of buffer */\n"
"    size_t          aio_nbytes;     /* Length of transfer */\n"
"    int             aio_reqprio;    /* Request priority */\n"
"    struct sigevent aio_sigevent;   /* Notification method */\n"
"    int             aio_lio_opcode; /* Operation to be performed;\n"
"                                       lio_listio() only */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:97
#, no-wrap
msgid ""
"    /* Various implementation-internal fields not shown */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:99
#, no-wrap
msgid "/* Operation codes for \\(aqaio_lio_opcode\\(aq: */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:101
#, no-wrap
msgid "enum { LIO_READ, LIO_WRITE, LIO_NOP };\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:105
msgid "The fields of this structure are as follows:"
msgstr ""

#. type: TP
#: build/C/man7/aio.7:105
#, no-wrap
msgid "I<aio_filedes>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:108
msgid "The file descriptor on which the I/O operation is to be performed."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:108
#, no-wrap
msgid "I<aio_offset>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:111
msgid "This is the file offset at which the I/O operation is to be performed."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:111
#, no-wrap
msgid "I<aio_buf>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:114
msgid "This is the buffer used to transfer data for a read or write operation."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:114
#, no-wrap
msgid "I<aio_nbytes>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:118
msgid "This is the size of the buffer pointed to by I<aio_buf>."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:118
#, no-wrap
msgid "I<aio_reqprio>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:127
msgid ""
"This field specifies a value that is subtracted from the calling thread's "
"real-time priority in order to determine the priority for execution of this "
"I/O request (see B<pthread_setschedparam>(3)).  The specified value must be "
"between 0 and the value returned by I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>.  "
"This field is ignored for file synchronization operations."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:127
#, no-wrap
msgid "I<aio_sigevent>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:141
msgid ""
"This field is a structure that specifies how the caller is to be notified "
"when the asynchronous I/O operation completes.  Possible values for "
"I<aio_sigevent.sigev_notify> are B<SIGEV_NONE>, B<SIGEV_SIGNAL>, and "
"B<SIGEV_THREAD>.  See B<sigevent>(7)  for further details."
msgstr ""

#. type: TP
#: build/C/man7/aio.7:141
#, no-wrap
msgid "I<aio_lio_opcode>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:145
msgid "The type of operation to be performed; used only for B<lio_listio>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:148
msgid ""
"In addition to the standard functions listed above, the GNU C library "
"provides the following extension to the POSIX AIO API:"
msgstr ""

#. type: TP
#: build/C/man7/aio.7:148
#, no-wrap
msgid "B<aio_init>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:151
msgid ""
"Set parameters for tuning the behavior of the glibc POSIX AIO "
"implementation."
msgstr ""

#. type: SH
#: build/C/man7/aio.7:151 build/C/man3/aio_read.3:132 build/C/man3/aio_suspend.3:104 build/C/man3/aio_write.3:137 build/C/man2/io_cancel.2:78 build/C/man2/io_destroy.2:72 build/C/man2/io_getevents.2:85 build/C/man2/io_setup.2:81 build/C/man2/io_submit.2:83 build/C/man3/lio_listio.3:206
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:158
msgid ""
"It is a good idea to zero out the control block buffer before use (see "
"B<memset>(3)).  The control block buffer and the buffer pointed to by "
"I<aio_buf> must not be changed while the I/O operation is in progress.  "
"These buffers must remain valid until the I/O operation completes."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:162
msgid ""
"Simultaneous asynchronous read or write operations using the same I<aiocb> "
"structure yield undefined results."
msgstr ""

#.  http://lse.sourceforge.net/io/aio.html
#.  http://lse.sourceforge.net/io/aionotes.txt
#.  http://lwn.net/Articles/148755/
#. type: Plain text
#: build/C/man7/aio.7:180
msgid ""
"The current Linux POSIX AIO implementation is provided in userspace by "
"glibc.  This has a number of limitations, most notably that maintaining "
"multiple threads to perform I/O operations is expensive and scales poorly.  "
"Work has been in progress for some time on a kernel state-machine-based "
"implementation of asynchronous I/O (see B<io_submit>(2), B<io_setup>(2), "
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2)), but this "
"implementation hasn't yet matured to the point where the POSIX AIO "
"implementation can be completely reimplemented using the kernel system "
"calls."
msgstr ""

#. type: SH
#: build/C/man7/aio.7:180 build/C/man3/aio_cancel.3:87 build/C/man3/aio_error.3:65 build/C/man3/aio_fsync.3:78 build/C/man3/aio_read.3:102 build/C/man3/aio_return.3:62 build/C/man3/aio_suspend.3:87 build/C/man3/aio_write.3:109 build/C/man2/io_cancel.2:56 build/C/man2/io_destroy.2:53 build/C/man2/io_getevents.2:60 build/C/man2/io_setup.2:54 build/C/man2/io_submit.2:54 build/C/man3/lio_listio.3:145
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man7/aio.7:181 build/C/man3/aio_error.3:66 build/C/man3/aio_fsync.3:86 build/C/man3/aio_read.3:110 build/C/man3/aio_return.3:63 build/C/man3/aio_write.3:121 build/C/man2/io_cancel.2:63 build/C/man2/io_destroy.2:57 build/C/man2/io_getevents.2:64 build/C/man2/io_setup.2:61 build/C/man2/io_submit.2:64 build/C/man3/lio_listio.3:160
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:190
msgid ""
"The I<aio_reqprio> field of the I<aiocb> structure was less than 0, or was "
"greater than the limit returned by the call "
"I<sysconf(_SC_AIO_PRIO_DELTA_MAX)>."
msgstr ""

#. type: SH
#: build/C/man7/aio.7:190 build/C/man3/aio_cancel.3:92 build/C/man3/aio_error.3:73 build/C/man3/aio_fsync.3:94 build/C/man3/aio_init.3:91 build/C/man3/aio_read.3:126 build/C/man3/aio_return.3:68 build/C/man3/aio_suspend.3:98 build/C/man3/aio_write.3:131 build/C/man2/io_cancel.2:70 build/C/man2/io_destroy.2:64 build/C/man2/io_getevents.2:77 build/C/man2/io_setup.2:73 build/C/man2/io_submit.2:75 build/C/man3/lio_listio.3:200
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:192
msgid "The POSIX AIO interfaces are provided by glibc since version 2.1."
msgstr ""

#. type: SH
#: build/C/man7/aio.7:192 build/C/man3/aio_cancel.3:96 build/C/man3/aio_error.3:77 build/C/man3/aio_fsync.3:98 build/C/man3/aio_init.3:95 build/C/man3/aio_read.3:130 build/C/man3/aio_return.3:72 build/C/man3/aio_suspend.3:102 build/C/man3/aio_write.3:135 build/C/man2/io_cancel.2:73 build/C/man2/io_destroy.2:67 build/C/man2/io_getevents.2:80 build/C/man2/io_setup.2:76 build/C/man2/io_submit.2:78 build/C/man3/lio_listio.3:204
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:194 build/C/man3/aio_cancel.3:98 build/C/man3/aio_error.3:79 build/C/man3/aio_fsync.3:100 build/C/man3/aio_read.3:132 build/C/man3/aio_return.3:74 build/C/man3/aio_suspend.3:104 build/C/man3/aio_write.3:137 build/C/man3/lio_listio.3:206
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr ""

#. type: SH
#: build/C/man7/aio.7:194 build/C/man3/aio_cancel.3:98 build/C/man3/aio_error.3:79 build/C/man3/aio_read.3:144 build/C/man3/aio_return.3:74
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:207
msgid ""
"The program below opens each of the files named in its command-line "
"arguments and queues a request on the resulting file descriptor using "
"B<aio_read>(3).  The program then loops, periodically monitoring each of the "
"I/O operations that is still in progress using B<aio_error>(3).  Each of the "
"I/O requests is set up to provide notification by delivery of a signal.  "
"After all I/O requests have completed, the program retrieves their status "
"using B<aio_return>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:213
msgid ""
"The B<SIGQUIT> signal (generated by typing control-\\e) causes the program "
"to request cancellation of each of the outstanding requests using "
"B<aio_cancel>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:218
msgid ""
"Here is an example of what we might see when running this program.  In this "
"example, the program queues two requests to standard input, and these are "
"satisfied by two lines of input containing \"abc\" and \"x\"."
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:242
#, no-wrap
msgid ""
"$ B<./a.out /dev/stdin /dev/stdin>\n"
"opened /dev/stdin on descriptor 3\n"
"opened /dev/stdin on descriptor 4\n"
"aio_error():\n"
"    for request 0 (descriptor 3): In progress\n"
"    for request 1 (descriptor 4): In progress\n"
"B<abc>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 0 (descriptor 3): I/O succeeded\n"
"    for request 1 (descriptor 4): In progress\n"
"aio_error():\n"
"    for request 1 (descriptor 4): In progress\n"
"B<x>\n"
"I/O completion signal received\n"
"aio_error():\n"
"    for request 1 (descriptor 4): I/O succeeded\n"
"All I/O requests completed\n"
"aio_return():\n"
"    for request 0 (descriptor 3): 4\n"
"    for request 1 (descriptor 4): 2\n"
msgstr ""

#. type: SS
#: build/C/man7/aio.7:244
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:253
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>aio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:255
#, no-wrap
msgid "#define BUF_SIZE 20     /* Size of buffers for read operations */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:257
#, no-wrap
msgid "#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:259
#, no-wrap
msgid "#define errMsg(msg)  do { perror(msg); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:266
#, no-wrap
msgid ""
"struct ioRequest {      /* Application-defined structure for tracking\n"
"                           I/O requests */\n"
"    int           reqNum;\n"
"    int           status;\n"
"    struct aiocb *aiocbp;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:270
#, no-wrap
msgid ""
"static volatile sig_atomic_t gotSIGQUIT = 0;\n"
"                        /* On delivery of SIGQUIT, we attempt to\n"
"                           cancel all outstanding I/O requests */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:276
#, no-wrap
msgid ""
"static void             /* Handler for SIGQUIT */\n"
"quitHandler(int sig)\n"
"{\n"
"    gotSIGQUIT = 1;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:278
#, no-wrap
msgid "#define IO_SIGNAL SIGUSR1   /* Signal used to notify I/O completion */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:283
#, no-wrap
msgid ""
"static void                 /* Handler for I/O completion signal */\n"
"aioSigHandler(int sig, siginfo_t *si, void *ucontext)\n"
"{\n"
"    write(STDOUT_FILENO, \"I/O completion signal received\\en\", 31);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:289
#, no-wrap
msgid ""
"    /* The corresponding ioRequest structure would be available as\n"
"           struct ioRequest *ioReq = si-E<gt>si_value.sival_ptr;\n"
"       and the file descriptor would then be available via\n"
"           ioReq-E<gt>aiocbp-E<gt>aio_fildes */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:299
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct ioRequest *ioList;\n"
"    struct aiocb *aiocbList;\n"
"    struct sigaction sa;\n"
"    int s, j;\n"
"    int numReqs;        /* Total number of queued I/O requests */\n"
"    int openReqs;       /* Number of I/O requests still in progress */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:305
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt> "
"E<lt>pathnameE<gt>...\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:307
#, no-wrap
msgid "    numReqs = argc - 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:309
#, no-wrap
msgid "    /* Allocate our arrays */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:313
#, no-wrap
msgid ""
"    ioList = calloc(numReqs, sizeof(struct ioRequest));\n"
"    if (ioList == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:317
#, no-wrap
msgid ""
"    aiocbList = calloc(numReqs, sizeof(struct aiocb));\n"
"    if (aiocbList == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:319
#, no-wrap
msgid "    /* Establish handlers for SIGQUIT and the I/O completion signal */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:322
#, no-wrap
msgid ""
"    sa.sa_flags = SA_RESTART;\n"
"    sigemptyset(&sa.sa_mask);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:326
#, no-wrap
msgid ""
"    sa.sa_handler = quitHandler;\n"
"    if (sigaction(SIGQUIT, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:331
#, no-wrap
msgid ""
"    sa.sa_flags = SA_RESTART | SA_SIGINFO;\n"
"    sa.sa_sigaction = aioSigHandler;\n"
"    if (sigaction(IO_SIGNAL, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:334
#, no-wrap
msgid ""
"    /* Open each file specified on the command line, and queue\n"
"       a read request on the resulting file descriptor */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:339
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numReqs; j++) {\n"
"        ioList[j].reqNum = j;\n"
"        ioList[j].status = EINPROGRESS;\n"
"        ioList[j].aiocbp = &aiocbList[j];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:345
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_fildes = open(argv[j + 1], O_RDONLY);\n"
"        if (ioList[j].aiocbp-E<gt>aio_fildes == -1)\n"
"            errExit(\"open\");\n"
"        printf(\"opened %s on descriptor %d\\en\", argv[j + 1],\n"
"                ioList[j].aiocbp-E<gt>aio_fildes);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:349
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_buf = malloc(BUF_SIZE);\n"
"        if (ioList[j].aiocbp-E<gt>aio_buf == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:357
#, no-wrap
msgid ""
"        ioList[j].aiocbp-E<gt>aio_nbytes = BUF_SIZE;\n"
"        ioList[j].aiocbp-E<gt>aio_reqprio = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_offset = 0;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_notify = SIGEV_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_signo = IO_SIGNAL;\n"
"        ioList[j].aiocbp-E<gt>aio_sigevent.sigev_value.sival_ptr =\n"
"                                &ioList[j];\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:362
#, no-wrap
msgid ""
"        s = aio_read(ioList[j].aiocbp);\n"
"        if (s == -1)\n"
"            errExit(\"aio_read\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:364
#, no-wrap
msgid "    openReqs = numReqs;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:366
#, no-wrap
msgid "    /* Loop, monitoring status of I/O requests */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:369
#, no-wrap
msgid ""
"    while (openReqs E<gt> 0) {\n"
"        sleep(3);       /* Delay between each monitoring step */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:371
#, no-wrap
msgid "        if (gotSIGQUIT) {\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:375
#, no-wrap
msgid ""
"            /* On receipt of SIGQUIT, attempt to cancel each of the\n"
"               outstanding I/O requests, and display status returned\n"
"               from the cancellation requests */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:377
#, no-wrap
msgid "            printf(\"got SIGQUIT; canceling I/O requests: \\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:394
#, no-wrap
msgid ""
"            for (j = 0; j E<lt> numReqs; j++) {\n"
"                if (ioList[j].status == EINPROGRESS) {\n"
"                    printf(\"    Request %d on descriptor %d:\", j,\n"
"                            ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                    s = aio_cancel(ioList[j].aiocbp-E<gt>aio_fildes,\n"
"                            ioList[j].aiocbp);\n"
"                    if (s == AIO_CANCELED)\n"
"                        printf(\"I/O canceled\\en\");\n"
"                    else if (s == AIO_NOTCANCELED)\n"
"                            printf(\"I/O not canceled\\en\");\n"
"                    else if (s == AIO_ALLDONE)\n"
"                        printf(\"I/O all done\\en\");\n"
"                    else\n"
"                        errMsg(\"aio_cancel\");\n"
"                }\n"
"            }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:397
#, no-wrap
msgid ""
"            gotSIGQUIT = 0;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:400
#, no-wrap
msgid ""
"        /* Check the status of each I/O request that is still\n"
"           in progress */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:407
#, no-wrap
msgid ""
"        printf(\"aio_error():\\en\");\n"
"        for (j = 0; j E<lt> numReqs; j++) {\n"
"            if (ioList[j].status == EINPROGRESS) {\n"
"                printf(\"    for request %d (descriptor %d): \",\n"
"                        j, ioList[j].aiocbp-E<gt>aio_fildes);\n"
"                ioList[j].status = aio_error(ioList[j].aiocbp);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:422
#, no-wrap
msgid ""
"                switch (ioList[j].status) {\n"
"                case 0:\n"
"                    printf(\"I/O succeeded\\en\");\n"
"                    break;\n"
"                case EINPROGRESS:\n"
"                    printf(\"In progress\\en\");\n"
"                    break;\n"
"                case ECANCELED:\n"
"                    printf(\"Canceled\\en\");\n"
"                    break;\n"
"                default:\n"
"                    errMsg(\"aio_error\");\n"
"                    break;\n"
"                }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:428
#, no-wrap
msgid ""
"                if (ioList[j].status != EINPROGRESS)\n"
"                    openReqs--;\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:430
#, no-wrap
msgid "    printf(\"All I/O requests completed\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:432
#, no-wrap
msgid "    /* Check status return of all I/O requests */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:436
#, no-wrap
msgid ""
"    printf(\"aio_return():\\en\");\n"
"    for (j = 0; j E<lt> numReqs; j++) {\n"
"        ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:441
#, no-wrap
msgid ""
"        s = aio_return(ioList[j].aiocbp);\n"
"        printf(\"    for request %d (descriptor %d): %ld\\en\",\n"
"                j, ioList[j].aiocbp-E<gt>aio_fildes, (long) s);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:444
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man7/aio.7:445 build/C/man3/aio_cancel.3:101 build/C/man3/aio_error.3:82 build/C/man3/aio_fsync.3:100 build/C/man3/aio_init.3:97 build/C/man3/aio_read.3:147 build/C/man3/aio_return.3:77 build/C/man3/aio_suspend.3:124 build/C/man3/aio_write.3:149 build/C/man2/io_cancel.2:94 build/C/man2/io_destroy.2:88 build/C/man2/io_getevents.2:101 build/C/man2/io_setup.2:97 build/C/man2/io_submit.2:99 build/C/man3/lio_listio.3:218
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/aio.7:459
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<io_submit>(2), B<aio_cancel>(3), B<aio_error>(3), B<aio_init>(3), "
"B<aio_read>(3), B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3), "
"http://www.squid-cache.org/~adrian/Reprint-Pulavarty-OLS2003.pdf"
msgstr ""

#. type: TH
#: build/C/man3/aio_cancel.3:23
#, no-wrap
msgid "AIO_CANCEL"
msgstr ""

#. type: TH
#: build/C/man3/aio_cancel.3:23
#, no-wrap
msgid "2011-10-04"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:26
msgid "aio_cancel - cancel an outstanding asynchronous I/O request"
msgstr ""

#. type: SH
#: build/C/man3/aio_cancel.3:26 build/C/man3/aio_error.3:26 build/C/man3/aio_fsync.3:26 build/C/man3/aio_init.3:27 build/C/man3/aio_read.3:26 build/C/man3/aio_return.3:26 build/C/man3/aio_suspend.3:27 build/C/man3/aio_write.3:26 build/C/man2/io_cancel.2:26 build/C/man2/io_destroy.2:26 build/C/man2/io_getevents.2:26 build/C/man2/io_setup.2:26 build/C/man2/io_submit.2:26 build/C/man3/lio_listio.3:26
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:28 build/C/man3/aio_error.3:28 build/C/man3/aio_fsync.3:28 build/C/man3/aio_read.3:28 build/C/man3/aio_return.3:28 build/C/man3/aio_write.3:28
msgid "B<#include E<lt>aio.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:30
msgid "B<int aio_cancel(int >I<fd>B<, struct aiocb *>I<aiocbp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:32 build/C/man3/aio_error.3:32 build/C/man3/aio_fsync.3:32 build/C/man3/aio_init.3:36 build/C/man3/aio_read.3:32 build/C/man3/aio_return.3:32 build/C/man3/aio_write.3:32
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:50
msgid ""
"The B<aio_cancel>()  function attempts to cancel outstanding asynchronous "
"I/O requests for the file descriptor I<fd>.  If I<aiocbp> is NULL, all such "
"requests are canceled.  Otherwise, only the request described by the control "
"block pointed to by I<aiocbp> is canceled.  (See B<aio>(7)  for a "
"description of the I<aiocb> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:59
msgid ""
"Normal asynchronous notification occurs for canceled requests.  The request "
"return status (B<aio_return>(3))  is set to -1, and the request error status "
"(B<aio_error>(3))  is set to B<ECANCELED>.  The control block of requests "
"that cannot be canceled is not changed."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:66
msgid ""
"If I<aiocbp> is not NULL, and I<fd> differs from the file descriptor with "
"which the asynchronous operation was initiated, unspecified results occur."
msgstr ""

#.  FreeBSD: not those on raw disk devices.
#. type: Plain text
#: build/C/man3/aio_cancel.3:69
msgid "Which operations are cancelable is implementation-defined."
msgstr ""

#. type: SH
#: build/C/man3/aio_cancel.3:69 build/C/man3/aio_error.3:43 build/C/man3/aio_fsync.3:72 build/C/man3/aio_read.3:87 build/C/man3/aio_return.3:48 build/C/man3/aio_suspend.3:79 build/C/man3/aio_write.3:94 build/C/man2/io_cancel.2:51 build/C/man2/io_destroy.2:48 build/C/man2/io_getevents.2:54 build/C/man2/io_setup.2:49 build/C/man2/io_submit.2:48 build/C/man3/lio_listio.3:107
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:87
msgid ""
"This function returns B<AIO_CANCELED> if all requests were successfully "
"canceled.  It returns B<AIO_NOTCANCELED> when at least one of the requests "
"specified was not canceled because it was in progress.  In this case one may "
"check the status of individual requests using B<aio_error>(3).  This "
"function returns B<AIO_ALLDONE> if all requests had already been completed "
"before this call.  When some error occurs, -1 is returned, and I<errno> is "
"set appropriately."
msgstr ""

#. type: TP
#: build/C/man3/aio_cancel.3:88 build/C/man3/aio_fsync.3:82 build/C/man3/aio_read.3:106 build/C/man3/aio_write.3:113 build/C/man2/io_submit.2:58
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:92
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:96
msgid "The B<aio_cancel>()  function is available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:101 build/C/man3/aio_error.3:82 build/C/man3/aio_read.3:147 build/C/man3/aio_return.3:77
msgid "See B<aio>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_cancel.3:109
msgid ""
"B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_error.3:23
#, no-wrap
msgid "AIO_ERROR"
msgstr ""

#. type: TH
#: build/C/man3/aio_error.3:23 build/C/man3/aio_read.3:23 build/C/man3/aio_return.3:23
#, no-wrap
msgid "2010-10-03"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:26
msgid "aio_error - get error status of asynchronous I/O operation"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:30
msgid "B<int aio_error(const struct aiocb *>I<aiocbp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:43
msgid ""
"The B<aio_error>()  function returns the error status for the asynchronous "
"I/O request with control block pointed to by I<aiocbp>.  (See B<aio>(7)  for "
"a description of the I<aiocb> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:45
msgid "This function returns one of the following:"
msgstr ""

#. type: IP
#: build/C/man3/aio_error.3:45 build/C/man3/aio_error.3:49 build/C/man3/aio_error.3:52 build/C/man3/aio_error.3:54 build/C/man3/aio_suspend.3:42 build/C/man3/aio_suspend.3:46 build/C/man3/aio_suspend.3:48
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:49
msgid "B<EINPROGRESS>, if the request has not been completed yet."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:52
msgid "B<ECANCELED>, if the request was canceled."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:54
msgid "0, if the request completed successfully."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:65
msgid ""
"A positive error, if the asynchronous I/O operation failed.  This is the "
"same value that would have been stored in the I<errno> variable in the case "
"of a synchronous B<read>(2), B<write>(2), B<fsync>(2), or B<fdatasync>(2)  "
"call."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:73
msgid ""
"I<aiocbp> does not point at a control block for an asynchronous I/O request "
"of which the return status (see B<aio_return>(3))  has not been retrieved "
"yet."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:77
msgid "The B<aio_error>()  function is available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_error.3:90
msgid ""
"B<aio_cancel>(3), B<aio_fsync>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_fsync.3:23
#, no-wrap
msgid "AIO_FSYNC"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:26
msgid "aio_fsync - asynchronous file synchronization"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:30
msgid "B<int aio_fsync(int >I<op>B<, struct aiocb *>I<aiocbp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:43
msgid ""
"The B<aio_fsync>()  function does a sync on all outstanding asynchronous I/O "
"operations associated with I<aiocbp-E<gt>aio_fildes>.  (See B<aio>(7)  for a "
"description of the I<aiocb> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:57
msgid ""
"More precisely, if I<op> is B<O_SYNC>, then all currently queued I/O "
"operations shall be completed as if by a call of B<fsync>(2), and if I<op> "
"is B<O_DSYNC>, this call is the asynchronous analog of B<fdatasync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:59
msgid "Note that this is a request only; it does not wait for I/O completion."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:72
msgid ""
"Apart from I<aio_fildes>, the only field in the structure pointed to by "
"I<aiocbp> that is used by this call is the I<aio_sigevent> field (a "
"I<sigevent> structure, described in B<sigevent>(7)), which indicates the "
"desired type of asynchronous notification at completion.  All other fields "
"are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:78
msgid ""
"On success (the sync request was successfully queued)  this function returns "
"0.  On error -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man3/aio_fsync.3:79 build/C/man3/aio_read.3:103 build/C/man3/aio_suspend.3:88 build/C/man3/aio_write.3:110 build/C/man2/io_cancel.2:57 build/C/man2/io_setup.2:55 build/C/man2/io_submit.2:55 build/C/man3/lio_listio.3:149 build/C/man3/lio_listio.3:152
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:82 build/C/man3/aio_read.3:106 build/C/man3/aio_write.3:113 build/C/man3/lio_listio.3:152
msgid "Out of resources."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:86 build/C/man3/aio_write.3:117
msgid "I<aio_fildes> is not a valid file descriptor open for writing."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:94
msgid ""
"Synchronized I/O is not supported for this file, or I<op> is not B<O_SYNC> "
"or B<O_DSYNC>."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:98
msgid "The B<aio_fsync>()  function is available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_fsync.3:109
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_read>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), "
"B<sigevent>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_init.3:24
#, no-wrap
msgid "AIO_INIT"
msgstr ""

#. type: TH
#: build/C/man3/aio_init.3:24
#, no-wrap
msgid "2010-10-06"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:27
msgid "aio_init - POSIX asynchronous I/O initialization"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:31
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>aio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:33
#, no-wrap
msgid "B<void aio_init(const struct aioinit *>I<init>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:43
msgid ""
"The GNU-specific B<aio_init>()  function allows the caller to provide tuning "
"hints to the glibc POSIX AIO implementation.  Use of this function is "
"optional, but to be effective, it must be called before employing any other "
"functions in the POSIX AIO API."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:47
msgid ""
"The tuning information is provided in the buffer pointed to by the argument "
"I<init>.  This buffer is a structure of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:62
#, no-wrap
msgid ""
"struct aioinit {\n"
"    int aio_threads;    /* Maximum number of threads */\n"
"    int aio_num;        /* Number of expected simultaneous\n"
"                           requests */\n"
"    int aio_locks;      /* Not used */\n"
"    int aio_usedba;     /* Not used */\n"
"    int aio_debug;      /* Not used */\n"
"    int aio_numusers;   /* Not used */\n"
"    int aio_idle_time;  /* Number of seconds before idle thread\n"
"                           terminates (since glibc 2.2) */\n"
"    int aio_reserved;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:68
msgid "The following fields are used in the I<aioinit> structure:"
msgstr ""

#. type: TP
#: build/C/man3/aio_init.3:68
#, no-wrap
msgid "I<aio_threads>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:76
msgid ""
"This field specifies the maximum number of worker threads that may be used "
"by the implementation.  If the number of outstanding I/O operations exceeds "
"this limit, then excess operations will be queued until a worker thread "
"becomes free.  If this field is specified with a value less than 1, the "
"value 1 is used.  The default value is 20."
msgstr ""

#. type: TP
#: build/C/man3/aio_init.3:76
#, no-wrap
msgid "I<aio_num>"
msgstr ""

#.  FIXME But, if aio_num > 32, the behavior looks strange. See
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12083
#. type: Plain text
#: build/C/man3/aio_init.3:85
msgid ""
"This field should specify the maximum number of simultaneous I/O requests "
"that the caller expects to enqueue.  If a value less than 32 is specified "
"for this field, it is rounded up to 32.  The default value is 64."
msgstr ""

#. type: TP
#: build/C/man3/aio_init.3:85
#, no-wrap
msgid "I<aio_idle_time>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:91
msgid ""
"This field specifies the amount of time in seconds that a worker thread "
"should wait for further requests before terminating, after having completed "
"a previous request.  The default value is 1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:95
msgid "The B<aio_init>()  function is available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:97
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_init.3:98
msgid "B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_read.3:23
#, no-wrap
msgid "AIO_READ"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:26
msgid "aio_read - asynchronous read"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:30
msgid "B<int aio_read(struct aiocb *>I<aiocbp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:40
msgid ""
"The B<aio_read>()  function queues the I/O request described by the buffer "
"pointed to by I<aiocbp>.  This function is the asynchronous analog of "
"B<read>(2).  The arguments of the call"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:42
#, no-wrap
msgid "    read(fd, buf, count)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:55 build/C/man3/aio_write.3:55
msgid ""
"correspond (in order) to the fields I<aio_fildes>, I<aio_buf>, and "
"I<aio_nbytes> of the structure pointed to by I<aiocbp>.  (See B<aio>(7)  for "
"a description of the I<aiocb> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:61
msgid ""
"The data is read starting at the absolute file offset "
"I<aiocbp-E<gt>aio_offset>, regardless of the current file offset.  After the "
"call, the value of the current file offset is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:74
msgid ""
"The \"asynchronous\" means that this call returns as soon as the request has "
"been enqueued; the read may or may not have completed when the call "
"returns.  One tests for completion using B<aio_error>(3).  The return status "
"of a completed I/O operation can be obtained by B<aio_return>(3).  "
"Asynchronous notification of I/O completion can be obtained by setting "
"I<aiocbp-E<gt>aio_sigevent> appropriately; see B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:81 build/C/man3/aio_write.3:88
msgid ""
"If B<_POSIX_PRIORITIZED_IO> is defined, and this file supports it, then the "
"asynchronous operation is submitted at a priority equal to that of the "
"calling process minus I<aiocbp-E<gt>aio_reqprio>."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:85 build/C/man3/aio_write.3:92
msgid "The field I<aiocbp-E<gt>aio_lio_opcode> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:87
msgid "No data is read from a regular file beyond its maximum offset."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:102 build/C/man3/aio_write.3:109
msgid ""
"On success, 0 is returned.  On error the request is not enqueued, -1 is "
"returned, and I<errno> is set appropriately.  If an error is only detected "
"later, it will be reported via B<aio_return>(3)  (returns status -1) and "
"B<aio_error>(3)  (error status\\(emwhatever one would have gotten in "
"I<errno>, such as B<EBADF>)."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:110
msgid "I<aio_fildes> is not a valid file descriptor open for reading."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:118
msgid "One or more of I<aio_offset>, I<aio_reqprio>, or I<aio_nbytes> are invalid."
msgstr ""

#. type: TP
#: build/C/man3/aio_read.3:118 build/C/man3/aio_write.3:128 build/C/man2/io_cancel.2:66 build/C/man2/io_destroy.2:60 build/C/man2/io_getevents.2:73 build/C/man2/io_setup.2:69 build/C/man2/io_submit.2:71
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:121 build/C/man3/aio_write.3:131
msgid "This function is not supported."
msgstr ""

#. type: TP
#: build/C/man3/aio_read.3:121
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:126
msgid ""
"The file is a regular file, we start reading before end-of-file and want at "
"least one byte, but the starting position is past the maximum offset for "
"this file."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:130
msgid "The B<aio_read>()  function is available since glibc 2.1."
msgstr ""

#.  or the control block of the operation
#. type: Plain text
#: build/C/man3/aio_read.3:140
msgid ""
"It is a good idea to zero out the control block before use.  The control "
"block must not be changed while the read operation is in progress.  The "
"buffer area being read into must not be accessed during the operation or "
"undefined results may occur.  The memory areas involved must remain valid."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:144 build/C/man3/aio_write.3:149 build/C/man3/lio_listio.3:218
msgid ""
"Simultaneous I/O operations specifying the same I<aiocb> structure produce "
"undefined results."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_read.3:155
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_return.3:23
#, no-wrap
msgid "AIO_RETURN"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:26
msgid "aio_return - get return status of asynchronous I/O operation"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:30
msgid "B<ssize_t aio_return(struct aiocb *>I<aiocbp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:43
msgid ""
"The B<aio_return>()  function returns the final return status for the "
"asynchronous I/O request with control block pointed to by I<aiocbp>.  (See "
"B<aio>(7)  for a description of the I<aiocb> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:48
msgid ""
"This function should be called only once for any given request, after "
"B<aio_error>(3)  returns something other than B<EINPROGRESS>."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:57
msgid ""
"If the asynchronous I/O operation has completed, this function returns the "
"value that would have been returned in case of a synchronous B<read>(2), "
"B<write>(2), B<fsync>(2)  or B<fdatasync>(2), call."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:62
msgid ""
"If the asynchronous I/O operation has not yet completed, the return value "
"and effect of B<aio_return>()  are undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:68
msgid ""
"I<aiocbp> does not point at a control block for an asynchronous I/O request "
"of which the return status has not been retrieved yet."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:72
msgid "The B<aio_return>()  function is available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_return.3:85
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_suspend.3:24
#, no-wrap
msgid "AIO_SUSPEND"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:27
msgid "aio_suspend - wait for asynchronous I/O operation or timeout"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:31 build/C/man3/lio_listio.3:29
#, no-wrap
msgid "B<#include E<lt>aio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:33
#, no-wrap
msgid "B<int aio_suspend(const struct aiocb * const >I<aiocb_list>B<[],>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:35
#, no-wrap
msgid ""
"B<                int >I<nitems>B<, const struct timespec "
"*>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:37 build/C/man3/lio_listio.3:34
#, no-wrap
msgid "Link with I<-lrt>.\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:42
msgid ""
"The B<aio_suspend>()  function suspends the calling thread until one of the "
"following occurs:"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:46
msgid ""
"One or more of the asynchronous I/O requests in the list I<aiocb_list> has "
"completed."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:48
msgid "A signal is delivered."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:55
msgid ""
"I<timeout> is not NULL and the specified time interval has passed.  (For "
"details of the I<timespec> structure, see B<nanosleep>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:73
msgid ""
"The I<nitems> argument specifies the number of items in I<aiocb_list>.  Each "
"item in the list pointed to by I<aiocb_list> must be either NULL (and then "
"is ignored), or a pointer to a control block on which I/O was initiated "
"using B<aio_read>(3), B<aio_write>(3), or B<lio_listio>(3).  (See B<aio>(7)  "
"for a description of the I<aiocb> structure.)"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:79
msgid ""
"If B<CLOCK_MONOTONIC> is supported, this clock is used to measure the "
"timeout interval (see B<clock_gettime>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:87
msgid ""
"If this function returns after completion of one of the I/O requests "
"specified in I<aiocb_list>, 0 is returned.  Otherwise, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:92
msgid "The call timed out before any of the indicated operations had completed."
msgstr ""

#. type: TP
#: build/C/man3/aio_suspend.3:92 build/C/man2/io_getevents.2:69 build/C/man3/lio_listio.3:168
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:98
msgid ""
"The call was ended by signal (possibly the completion signal of one of the "
"operations we were waiting for); see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:102
msgid "The B<aio_suspend>()  function is available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:108
msgid ""
"One can achieve polling by using a non-NULL I<timeout> that specifies a zero "
"time interval."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:114
msgid ""
"If one or more of the asynchronous I/O operations specified in I<aiocb_list> "
"has already completed at the time of the call to B<aio_suspend>(), then the "
"call returns immediately."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:124
msgid ""
"To determine which I/O operations have completed after a successful return "
"from B<aio_suspend>(), use B<aio_error>(3)  to scan the list of I<aiocb> "
"structures pointed to by I<aiocb_list>."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_suspend.3:133
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_write>(3), B<lio_listio>(3), B<aio>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man3/aio_write.3:23
#, no-wrap
msgid "AIO_WRITE"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:26
msgid "aio_write - asynchronous write"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:30
msgid "B<int aio_write(struct aiocb *>I<aiocbp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:40
msgid ""
"The B<aio_write>()  function queues the I/O request described by the buffer "
"pointed to by I<aiocb>.  This function is the asynchronous analog of "
"B<write>(2).  The arguments of the call"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:42
#, no-wrap
msgid "    write(fd, buf, count)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:68
msgid ""
"If B<O_APPEND> is not set, the data is written starting at the absolute file "
"offset I<aiocbp-E<gt>aio_offset>, regardless of the current file offset.  If "
"B<O_APPEND> is set, data is written at the end of the file in the same order "
"as B<aio_write>()  calls are made.  After the call, the value of the current "
"file offset is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:81
msgid ""
"The \"asynchronous\" means that this call returns as soon as the request has "
"been enqueued; the write may or may not have completed when the call "
"returns.  One tests for completion using B<aio_error>(3).  The return status "
"of a completed I/O operation can be obtained B<aio_return>(3).  Asynchronous "
"notification of I/O completion can be obtained by setting "
"I<aiocbp-E<gt>aio_sigevent> appropriately; see B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:94
msgid "No data is written to a regular file beyond its maximum offset."
msgstr ""

#. type: TP
#: build/C/man3/aio_write.3:117
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:121
msgid ""
"The file is a regular file, we want to write at least one byte, but the "
"starting position is at or beyond the maximum offset for this file."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:128
msgid "One or more of I<aio_offset>, I<aio_reqprio>, I<aio_nbytes> are invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:135
msgid "The B<aio_write>()  function is available since glibc 2.1."
msgstr ""

#.  or the control block of the operation
#. type: Plain text
#: build/C/man3/aio_write.3:145
msgid ""
"It is a good idea to zero out the control block before use.  The control "
"block must not be changed while the write operation is in progress.  The "
"buffer area being written out must not be accessed during the operation or "
"undefined results may occur.  The memory areas involved must remain valid."
msgstr ""

#. type: Plain text
#: build/C/man3/aio_write.3:157
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_read>(3), "
"B<aio_return>(3), B<aio_suspend>(3), B<lio_listio>(3), B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man2/io_cancel.2:23
#, no-wrap
msgid "IO_CANCEL"
msgstr ""

#. type: TH
#: build/C/man2/io_cancel.2:23 build/C/man2/io_destroy.2:23 build/C/man2/io_setup.2:23 build/C/man2/io_submit.2:23
#, no-wrap
msgid "2008-06-18"
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:26
msgid "io_cancel - cancel an outstanding asynchronous I/O operation"
msgstr ""

#.  .ad l
#.  .hy 0
#.  #include <linux/aio.h>
#. type: Plain text
#: build/C/man2/io_cancel.2:33 build/C/man2/io_destroy.2:32 build/C/man2/io_setup.2:32 build/C/man2/io_submit.2:32
#, no-wrap
msgid "B<#include E<lt>libaio.hE<gt>>\n"
msgstr ""

#.  .HP 16
#.  .ad
#.  .hy
#. type: Plain text
#: build/C/man2/io_cancel.2:39
#, no-wrap
msgid ""
"B<int io_cancel(aio_context_t >I<ctx_id>B<, struct iocb *>I<iocb>B<,>\n"
"B<              struct io_event *>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:41 build/C/man2/io_destroy.2:39 build/C/man2/io_getevents.2:42 build/C/man2/io_setup.2:39 build/C/man2/io_submit.2:40
#, no-wrap
msgid "Link with I<-laio>.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:51
msgid ""
"B<io_cancel>()  attempts to cancel an asynchronous I/O operation previously "
"submitted with B<io_submit>(2).  I<ctx_id> is the AIO context ID of the "
"operation to be canceled.  If the AIO context is found, the event will be "
"canceled and then copied into the memory pointed to by I<result> without "
"being placed into the completion queue."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:56
msgid "On success, B<io_cancel>()  returns 0.  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:60
msgid "The I<iocb> specified was not canceled."
msgstr ""

#. type: TP
#: build/C/man2/io_cancel.2:60 build/C/man2/io_destroy.2:54 build/C/man2/io_getevents.2:61 build/C/man2/io_setup.2:58 build/C/man2/io_submit.2:61
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:63 build/C/man2/io_submit.2:64
msgid "One of the data structures points to invalid data."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:66
msgid "The AIO context specified by I<ctx_id> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:70
msgid "B<io_cancel>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:73 build/C/man2/io_destroy.2:67 build/C/man2/io_getevents.2:80 build/C/man2/io_setup.2:76 build/C/man2/io_submit.2:78
msgid "The asynchronous I/O system calls first appeared in Linux 2.5, August 2002."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:78
msgid ""
"B<io_cancel>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:80 build/C/man2/io_destroy.2:74 build/C/man2/io_getevents.2:87 build/C/man2/io_setup.2:83 build/C/man2/io_submit.2:85
msgid "Glibc does not provide a wrapper function for this system call."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:94
msgid ""
"The wrapper provided in I<libaio> for B<io_cancel>()  does not follow the "
"usual C library conventions for indicating error: on error it returns a "
"negated error number (the negative of one of the values listed in ERRORS).  "
"If the system call is invoked via B<syscall>(2), then the return value "
"follows the usual conventions for indicating an error: -1, with I<errno> set "
"to a (positive) value that indicates the error."
msgstr ""

#. type: Plain text
#: build/C/man2/io_cancel.2:99
msgid ""
"B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man2/io_destroy.2:23
#, no-wrap
msgid "IO_DESTROY"
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:26
msgid "io_destroy - destroy an asynchronous I/O context"
msgstr ""

#.  .HP 17
#.  .ad
#.  .hy
#. type: Plain text
#: build/C/man2/io_destroy.2:37
#, no-wrap
msgid "B<int io_destroy(aio_context_t >I<ctx>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:48
msgid ""
"B<io_destroy>()  removes the asynchronous I/O context from the list of I/O "
"contexts and then destroys it.  B<io_destroy>()  can also cancel any "
"outstanding asynchronous I/O actions on I<ctx> and block on completion."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:53
msgid "On success, B<io_destroy>()  returns 0.  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:57
msgid "The context pointed to is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:60
msgid "The AIO context specified by I<ctx> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:64
msgid "B<io_destroy>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:72
msgid ""
"B<io_destroy>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:88
msgid ""
"The wrapper provided in I<libaio> for B<io_destroy>()  does not follow the "
"usual C library conventions for indicating error: on error it returns a "
"negated error number (the negative of one of the values listed in ERRORS).  "
"If the system call is invoked via B<syscall>(2), then the return value "
"follows the usual conventions for indicating an error: -1, with I<errno> set "
"to a (positive) value that indicates the error."
msgstr ""

#. type: Plain text
#: build/C/man2/io_destroy.2:93
msgid ""
"B<io_cancel>(2), B<io_getevents>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man2/io_getevents.2:23
#, no-wrap
msgid "IO_GETEVENTS"
msgstr ""

#. type: TH
#: build/C/man2/io_getevents.2:23
#, no-wrap
msgid "2008-07-04"
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:26
msgid "io_getevents - read asynchronous I/O events from the completion queue"
msgstr ""

#.  .ad l
#.  .hy 0
#.  #include <linux/aio.h>
#. type: Plain text
#: build/C/man2/io_getevents.2:33
#, no-wrap
msgid ""
"B<#include E<lt>linux/time.hE<gt>>\n"
"B<#include E<lt>libaio.hE<gt>>\n"
msgstr ""

#.  .HP 19
#.  .ad
#.  .hy
#. type: Plain text
#: build/C/man2/io_getevents.2:40
#, no-wrap
msgid ""
"B<int io_getevents(aio_context_t >I<ctx_id>B<, long >I<min_nr>B<, long "
">I<nr>B<,>\n"
"B<                 struct io_event *>I<events>B<, struct timespec "
"*>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:54
msgid ""
"B<io_getevents>()  attempts to read at least I<min_nr> events and up to "
"I<nr> events from the completion queue of the AIO context specified by "
"I<ctx_id>.  I<timeout> specifies the amount of time to wait for events, "
"where a NULL timeout waits until at least I<min_nr> events have been seen.  "
"Note that I<timeout> is relative and will be updated if not NULL and the "
"operation blocks."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:60
msgid ""
"On success, B<io_getevents>()  returns the number of events read: 0 if no "
"events are available, or less than I<min_nr> if the I<timeout> has elapsed.  "
"For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:64
msgid "Either I<events> or I<timeout> is an invalid pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:69
msgid "I<ctx_id> is invalid.  I<min_nr> is out of range or I<nr> is out of range."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:73
msgid "Interrupted by a signal handler; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:77
msgid "B<io_getevents>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:85
msgid ""
"B<io_getevents>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:101
msgid ""
"The wrapper provided in I<libaio> for B<io_getevents>()  does not follow the "
"usual C library conventions for indicating error: on error it returns a "
"negated error number (the negative of one of the values listed in ERRORS).  "
"If the system call is invoked via B<syscall>(2), then the return value "
"follows the usual conventions for indicating an error: -1, with I<errno> set "
"to a (positive) value that indicates the error."
msgstr ""

#. type: Plain text
#: build/C/man2/io_getevents.2:108
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_setup>(2), B<io_submit>(2), "
"B<aio>(7), B<time>(7)"
msgstr ""

#. type: TH
#: build/C/man2/io_setup.2:23
#, no-wrap
msgid "IO_SETUP"
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:26
msgid "io_setup - create an asynchronous I/O context"
msgstr ""

#.  .HP 15
#.  .ad
#.  .hy
#. type: Plain text
#: build/C/man2/io_setup.2:37
#, no-wrap
msgid "B<int io_setup(unsigned >I<nr_events>B<, aio_context_t *>I<ctxp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:49
msgid ""
"B<io_setup>()  creates an asynchronous I/O context capable of receiving at "
"least I<nr_events>.  I<ctxp> must not point to an AIO context that already "
"exists, and must be initialized to 0 prior to the call.  On successful "
"creation of the AIO context, I<*ctxp> is filled in with the resulting "
"handle."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:54
msgid "On success, B<io_setup>()  returns 0.  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:58
msgid "The specified I<nr_events> exceeds the user's limit of available events."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:61
msgid "An invalid pointer is passed for I<ctxp>."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:66
msgid ""
"I<ctxp> is not initialized, or the specified I<nr_events> exceeds internal "
"limits.  I<nr_events> should be greater than 0."
msgstr ""

#. type: TP
#: build/C/man2/io_setup.2:66
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:69
msgid "Insufficient kernel resources are available."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:73
msgid "B<io_setup>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:81
msgid ""
"B<io_setup>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:97
msgid ""
"The wrapper provided in I<libaio> for B<io_setup>()  does not follow the "
"usual C library conventions for indicating error: on error it returns a "
"negated error number (the negative of one of the values listed in ERRORS).  "
"If the system call is invoked via B<syscall>(2), then the return value "
"follows the usual conventions for indicating an error: -1, with I<errno> set "
"to a (positive) value that indicates the error."
msgstr ""

#. type: Plain text
#: build/C/man2/io_setup.2:102
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_submit>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man2/io_submit.2:23
#, no-wrap
msgid "IO_SUBMIT"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:26
msgid "io_submit - submit asynchronous I/O blocks for processing"
msgstr ""

#.  .HP 16
#.  .ad
#.  .hy
#. type: Plain text
#: build/C/man2/io_submit.2:38
#, no-wrap
msgid ""
"B<int io_submit(aio_context_t >I<ctx_id>B<, long >I<nr>B<, struct iocb "
"**>I<iocbpp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:48
msgid ""
"B<io_submit>()  queues I<nr> I/O request blocks for processing in the AIO "
"context I<ctx_id>.  I<iocbpp> should be an array of I<nr> AIO control "
"blocks, which will be submitted to context I<ctx_id>."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:54
msgid ""
"On success, B<io_submit>()  returns the number of I<iocb>s submitted (which "
"may be 0 if I<nr> is zero).  For the failure return, see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:58
msgid "Insufficient resources are available to queue any I<iocb>s."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:61
msgid "The file descriptor specified in the first I<iocb> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:71
msgid ""
"The I<aio_context> specified by I<ctx_id> is invalid.  I<nr> is less than "
"0.  The I<iocb> at *iocbpp[0] is not properly initialized, or the operation "
"specified is invalid for the file descriptor in the I<iocb>."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:75
msgid "B<io_submit>()  is not implemented on this architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:83
msgid ""
"B<io_submit>()  is Linux-specific and should not be used in programs that "
"are intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:99
msgid ""
"The wrapper provided in I<libaio> for B<io_submit>()  does not follow the "
"usual C library conventions for indicating error: on error it returns a "
"negated error number (the negative of one of the values listed in ERRORS).  "
"If the system call is invoked via B<syscall>(2), then the return value "
"follows the usual conventions for indicating an error: -1, with I<errno> set "
"to a (positive) value that indicates the error."
msgstr ""

#. type: Plain text
#: build/C/man2/io_submit.2:104
msgid ""
"B<io_cancel>(2), B<io_destroy>(2), B<io_getevents>(2), B<io_setup>(2), "
"B<aio>(7)"
msgstr ""

#. type: TH
#: build/C/man3/lio_listio.3:23
#, no-wrap
msgid "LIO_LISTIO"
msgstr ""

#. type: TH
#: build/C/man3/lio_listio.3:23
#, no-wrap
msgid "2010-10-20"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:26
msgid "lio_listio - initiate a list of I/O requests"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:32
#, no-wrap
msgid ""
"B<int lio_listio(int >I<mode>B<, struct aiocb *const >I<aiocb_list>B<[],>\n"
"B<               int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:40
msgid ""
"The B<lio_listio>()  function initiates the list of I/O operations described "
"by the array I<aiocb_list>."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:44
msgid "The I<mode> operation has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/lio_listio.3:44
#, no-wrap
msgid "B<LIO_WAIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:50
msgid ""
"The call blocks until all operations are complete.  The I<sevp> argument is "
"ignored."
msgstr ""

#. type: TP
#: build/C/man3/lio_listio.3:50
#, no-wrap
msgid "B<LIO_NOWAIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:62
msgid ""
"The I/O operations are queued for processing and the call returns "
"immediately.  When the I/O operations complete, asynchronous notification "
"occurs, as specified by the I<sevp> argument; see B<sigevent>(7)  for "
"details.  If I<sevp> is NULL, no asynchronous notification occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:76
msgid ""
"The I<aiocb_list> argument is an array of pointers to I<aiocb> structures "
"that describe I/O operations.  These operations are executed in an "
"unspecified order.  The I<nitems> argument specifies the size of the array "
"I<aiocb_list>.  NULL pointers in I<aiocb_list> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:82
msgid ""
"In each control block in I<aiocb_list>, the I<aio_lio_opcode> field "
"specifies the I/O operation to be initiated, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/lio_listio.3:82
#, no-wrap
msgid "B<LIO_READ>"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:88
msgid ""
"Initiate a read operation.  The operation is queued as for a call to "
"B<aio_read>(3)  specifying this control block."
msgstr ""

#. type: TP
#: build/C/man3/lio_listio.3:88
#, no-wrap
msgid "B<LIO_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:94
msgid ""
"Initiate a write operation.  The operation is queued as for a call to "
"B<aio_write>(3)  specifying this control block."
msgstr ""

#. type: TP
#: build/C/man3/lio_listio.3:94
#, no-wrap
msgid "B<LIO_NOP>"
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:97
msgid "Ignore this control block."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:107
msgid ""
"The remaining fields in each control block have the same meanings as for "
"B<aio_read>(3)  and B<aio_write>(3).  The I<aio_sigevent> fields of each "
"control block can be used to specify notifications for the individual I/O "
"operations (see B<sigevent>(7))."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:117
msgid ""
"If I<mode> is B<LIO_NOWAIT>, B<lio_listio>()  returns 0 if all I/O "
"operations are successfully queued.  Otherwise, -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:127
msgid ""
"If I<mode> is B<LIO_WAIT>, B<lio_listio>()  returns 0 when all of the I/O "
"operations have completed successfully.  Otherwise, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:145
msgid ""
"The return status from B<lio_listio>()  provides information only about the "
"call itself, not about the individual I/O operations.  One or more of the "
"I/O operations may fail, but this does not prevent other operations "
"completing.  The status of individual I/O operations in I<aiocb_list> can be "
"determined using B<aio_error>(3).  When an operation has completed, its "
"return status can be obtained using B<aio_return>(3).  Individual I/O "
"operations can fail for the reasons described in B<aio_read>(3)  and "
"B<aio_write>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:149
msgid "The B<lio_listio>()  function may fail for the following reasons:"
msgstr ""

#.  Doesn't happen in glibc(?)
#. type: Plain text
#: build/C/man3/lio_listio.3:160
msgid ""
"The number of I/O operations specified by I<nitems> would cause the limit "
"B<AIO_MAX> to be exceeded."
msgstr ""

#.  Doesn't happen in glibc(?)
#. type: Plain text
#: build/C/man3/lio_listio.3:168
msgid "I<mode> is invalid, or I<nitems> exceeds the limit B<AIO_LISTIO_MAX>."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:177
msgid ""
"I<mode> was B<LIO_WAIT> and a signal was caught before all I/O operations "
"completed.  (This may even be one of the signals used for asynchronous I/O "
"completion notification.)"
msgstr ""

#. type: TP
#: build/C/man3/lio_listio.3:177
#, no-wrap
msgid "B<EIO>"
msgstr ""

#.  e.g., ioa_reqprio or aio_lio_opcode was invalid
#. type: Plain text
#: build/C/man3/lio_listio.3:185
msgid ""
"One of more of the operations specified by I<aiocb_list> failed.  The "
"application can check the status of each operation using B<aio_return>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:200
msgid ""
"If B<lio_listio>()  fails with the error B<EAGAIN>, B<EINTR>, or B<EIO>, "
"then some of the operations in I<aiocb_list> may have been initiated.  If "
"B<lio_listio>()  fails for any other reason, then none of the I/O operations "
"has been initiated."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:204
msgid "The B<lio_listio>()  function is available since glibc 2.1."
msgstr ""

#.  or the control block of the operation
#. type: Plain text
#: build/C/man3/lio_listio.3:214
msgid ""
"It is a good idea to zero out the control blocks before use.  The control "
"blocks must not be changed while the I/O operations are in progress.  The "
"buffer areas being read into or written from must not be accessed during the "
"operations or undefined results may occur.  The memory areas involved must "
"remain valid."
msgstr ""

#. type: Plain text
#: build/C/man3/lio_listio.3:225
msgid ""
"B<aio_cancel>(3), B<aio_error>(3), B<aio_fsync>(3), B<aio_return>(3), "
"B<aio_suspend>(3), B<aio_write>(3), B<aio>(7)"
msgstr ""

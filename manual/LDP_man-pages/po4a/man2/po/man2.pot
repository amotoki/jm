# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:16+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/arch_prctl.2:24
#, no-wrap
msgid "ARCH_PRCTL"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:24
#, no-wrap
msgid "2007-12-26"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:24 build/C/man2/futex.2:17 build/C/man2/get_robust_list.2:27 build/C/man2/kexec_load.2:25 build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:8 build/C/man2/outb.2:28 build/C/man2/pciconfig_read.2:5 build/C/man2/personality.2:30 build/C/man2/pivot_root.2:7 build/C/man2/process_vm_readv.2:27 build/C/man2/ptrace.2:49 build/C/man2/quotactl.2:25 build/C/man2/sendfile.2:15 build/C/man2/set_tid_address.2:23 build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:24 build/C/man2/futex.2:17 build/C/man2/kexec_load.2:25 build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:8 build/C/man2/outb.2:28 build/C/man2/pciconfig_read.2:5 build/C/man2/personality.2:30 build/C/man2/pivot_root.2:7 build/C/man2/process_vm_readv.2:27 build/C/man2/ptrace.2:49 build/C/man2/quotactl.2:25 build/C/man2/sendfile.2:15 build/C/man2/set_tid_address.2:23 build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:25 build/C/man2/futex.2:18 build/C/man2/get_robust_list.2:28 build/C/man2/kexec_load.2:26 build/C/man2/lookup_dcookie.2:28 build/C/man2/modify_ldt.2:26 build/C/man2/nfsservctl.2:9 build/C/man2/outb.2:29 build/C/man2/pciconfig_read.2:6 build/C/man2/personality.2:31 build/C/man2/pivot_root.2:8 build/C/man2/process_vm_readv.2:28 build/C/man2/ptrace.2:50 build/C/man2/quotactl.2:26 build/C/man2/sendfile.2:16 build/C/man2/set_tid_address.2:24 build/C/man2/splice.2:27 build/C/man2/tee.2:27 build/C/man2/vm86.2:27 build/C/man2/vmsplice.2:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:27
msgid "arch_prctl - set architecture-specific thread state"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:27 build/C/man2/futex.2:20 build/C/man2/get_robust_list.2:30 build/C/man2/kexec_load.2:28 build/C/man2/lookup_dcookie.2:30 build/C/man2/modify_ldt.2:28 build/C/man2/nfsservctl.2:11 build/C/man2/pciconfig_read.2:8 build/C/man2/personality.2:33 build/C/man2/pivot_root.2:10 build/C/man2/process_vm_readv.2:30 build/C/man2/ptrace.2:52 build/C/man2/quotactl.2:28 build/C/man2/sendfile.2:18 build/C/man2/set_tid_address.2:26 build/C/man2/splice.2:29 build/C/man2/tee.2:29 build/C/man2/vm86.2:29 build/C/man2/vmsplice.2:29
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:30
#, no-wrap
msgid "B<#include E<lt>asm/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:32
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:35
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr ""

#.  Return type was long before glibc 2.7
#. type: SH
#: build/C/man2/arch_prctl.2:36 build/C/man2/futex.2:32 build/C/man2/get_robust_list.2:39 build/C/man2/kexec_load.2:35 build/C/man2/lookup_dcookie.2:32 build/C/man2/modify_ldt.2:34 build/C/man2/nfsservctl.2:18 build/C/man2/outb.2:33 build/C/man2/pciconfig_read.2:19 build/C/man2/personality.2:37 build/C/man2/pivot_root.2:12 build/C/man2/process_vm_readv.2:48 build/C/man2/ptrace.2:59 build/C/man2/quotactl.2:36 build/C/man2/sendfile.2:43 build/C/man2/set_tid_address.2:32 build/C/man2/splice.2:39 build/C/man2/tee.2:38 build/C/man2/vm86.2:35 build/C/man2/vmsplice.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:51
msgid ""
"The B<arch_prctl>()  function sets architecture-specific process or thread "
"state.  I<code> selects a subfunction and passes argument I<addr> to it; "
"I<addr> is interpreted as either an I<unsigned long> for the \"set\" "
"operations, or as an I<unsigned long *>, for the \"get\" operations."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:53
msgid "Sub functions for x86-64 are:"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:53
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:59
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:59
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:67
msgid ""
"Return the 64-bit base value for the I<FS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:67
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:73
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:73
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:81
msgid ""
"Return the 64-bit base value for the I<GS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:81 build/C/man2/futex.2:173 build/C/man2/get_robust_list.2:72 build/C/man2/kexec_load.2:110 build/C/man2/lookup_dcookie.2:43 build/C/man2/modify_ldt.2:96 build/C/man2/nfsservctl.2:51 build/C/man2/pciconfig_read.2:47 build/C/man2/personality.2:55 build/C/man2/pivot_root.2:95 build/C/man2/process_vm_readv.2:207 build/C/man2/ptrace.2:1580 build/C/man2/sendfile.2:104 build/C/man2/set_tid_address.2:80 build/C/man2/splice.2:127 build/C/man2/tee.2:85 build/C/man2/vm86.2:52 build/C/man2/vmsplice.2:113
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:87
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:87 build/C/man2/futex.2:210 build/C/man2/get_robust_list.2:79 build/C/man2/kexec_load.2:117 build/C/man2/lookup_dcookie.2:50 build/C/man2/modify_ldt.2:106 build/C/man2/pciconfig_read.2:74 build/C/man2/personality.2:62 build/C/man2/pivot_root.2:99 build/C/man2/process_vm_readv.2:227 build/C/man2/ptrace.2:1594 build/C/man2/quotactl.2:425 build/C/man2/sendfile.2:111 build/C/man2/set_tid_address.2:83 build/C/man2/splice.2:142 build/C/man2/tee.2:100 build/C/man2/vm86.2:57 build/C/man2/vmsplice.2:122
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:88 build/C/man2/futex.2:222 build/C/man2/get_robust_list.2:106 build/C/man2/lookup_dcookie.2:51 build/C/man2/modify_ldt.2:107 build/C/man2/process_vm_readv.2:249 build/C/man2/process_vm_readv.2:254 build/C/man2/ptrace.2:1598 build/C/man2/quotactl.2:426 build/C/man2/sendfile.2:121 build/C/man2/vm86.2:58
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:92
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:92 build/C/man2/futex.2:227 build/C/man2/get_robust_list.2:83 build/C/man2/kexec_load.2:122 build/C/man2/lookup_dcookie.2:54 build/C/man2/modify_ldt.2:111 build/C/man2/pciconfig_read.2:75 build/C/man2/personality.2:63 build/C/man2/pivot_root.2:108 build/C/man2/process_vm_readv.2:228 build/C/man2/process_vm_readv.2:239 build/C/man2/process_vm_readv.2:243 build/C/man2/ptrace.2:1609 build/C/man2/quotactl.2:432 build/C/man2/quotactl.2:499 build/C/man2/sendfile.2:124 build/C/man2/splice.2:147 build/C/man2/tee.2:101 build/C/man2/vmsplice.2:127
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:96
msgid "I<code> is not a valid subcommand."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:96 build/C/man2/get_robust_list.2:93 build/C/man2/kexec_load.2:129 build/C/man2/lookup_dcookie.2:65 build/C/man2/pciconfig_read.2:102 build/C/man2/pivot_root.2:114 build/C/man2/process_vm_readv.2:265 build/C/man2/ptrace.2:1619 build/C/man2/quotactl.2:454 build/C/man2/vm86.2:66
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: build/C/man2/arch_prctl.2:102
msgid "I<addr> is outside the process address space."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:102 build/C/man2/futex.2:247 build/C/man2/kexec_load.2:138 build/C/man2/lookup_dcookie.2:78 build/C/man2/modify_ldt.2:128 build/C/man2/nfsservctl.2:56 build/C/man2/outb.2:58 build/C/man2/pciconfig_read.2:107 build/C/man2/personality.2:66 build/C/man2/pivot_root.2:122 build/C/man2/process_vm_readv.2:277 build/C/man2/ptrace.2:1637 build/C/man2/sendfile.2:144 build/C/man2/set_tid_address.2:89 build/C/man2/splice.2:170 build/C/man2/tee.2:119 build/C/man2/vm86.2:71 build/C/man2/vmsplice.2:143
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:106
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:106 build/C/man2/futex.2:249 build/C/man2/get_robust_list.2:114 build/C/man2/kexec_load.2:140 build/C/man2/lookup_dcookie.2:81 build/C/man2/modify_ldt.2:131 build/C/man2/pivot_root.2:125 build/C/man2/process_vm_readv.2:279 build/C/man2/ptrace.2:1639 build/C/man2/sendfile.2:151 build/C/man2/splice.2:172 build/C/man2/tee.2:121 build/C/man2/vmsplice.2:145
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:109
msgid ""
"B<arch_prctl>()  is only supported on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:111
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:114
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:129
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  It may be a "
"faster alternative to set a 32-bit base using a segment selector by setting "
"up an LDT with B<modify_ldt>(2)  or using the B<set_thread_area>(2)  system "
"call in kernel 2.5 or later.  B<arch_prctl>()  is only needed when you want "
"to set bases that are larger than 4GB.  Memory in the first 2GB of address "
"space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:134
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:137
msgid "I<FS> may be already used by the threading library."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:137 build/C/man2/futex.2:263 build/C/man2/get_robust_list.2:121 build/C/man2/kexec_load.2:155 build/C/man2/modify_ldt.2:134 build/C/man2/outb.2:67 build/C/man2/pciconfig_read.2:109 build/C/man2/pivot_root.2:137 build/C/man2/process_vm_readv.2:329 build/C/man2/ptrace.2:1746 build/C/man2/quotactl.2:505 build/C/man2/sendfile.2:193 build/C/man2/set_tid_address.2:91 build/C/man2/splice.2:226 build/C/man2/tee.2:197 build/C/man2/vmsplice.2:154
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:142
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:144
msgid "AMD X86-64 Programmer's manual"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:144 build/C/man2/futex.2:274 build/C/man2/get_robust_list.2:130 build/C/man2/kexec_load.2:158 build/C/man2/lookup_dcookie.2:88 build/C/man2/modify_ldt.2:136 build/C/man2/nfsservctl.2:58 build/C/man2/outb.2:70 build/C/man2/pciconfig_read.2:111 build/C/man2/personality.2:70 build/C/man2/pivot_root.2:143 build/C/man2/process_vm_readv.2:332 build/C/man2/ptrace.2:1760 build/C/man2/quotactl.2:510 build/C/man2/sendfile.2:199 build/C/man2/set_tid_address.2:94 build/C/man2/splice.2:230 build/C/man2/tee.2:200 build/C/man2/vm86.2:74 build/C/man2/vmsplice.2:157
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:151 build/C/man2/futex.2:281 build/C/man2/get_robust_list.2:137 build/C/man2/kexec_load.2:165 build/C/man2/lookup_dcookie.2:95 build/C/man2/modify_ldt.2:143 build/C/man2/nfsservctl.2:65 build/C/man2/outb.2:77 build/C/man2/pciconfig_read.2:118 build/C/man2/personality.2:77 build/C/man2/pivot_root.2:150 build/C/man2/process_vm_readv.2:339 build/C/man2/ptrace.2:1767 build/C/man2/quotactl.2:517 build/C/man2/sendfile.2:206 build/C/man2/set_tid_address.2:101 build/C/man2/splice.2:237 build/C/man2/tee.2:207 build/C/man2/vm86.2:81 build/C/man2/vmsplice.2:164
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/futex.2:17
#, no-wrap
msgid "FUTEX"
msgstr ""

#. type: TH
#: build/C/man2/futex.2:17
#, no-wrap
msgid "2010-08-29"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:20
msgid "futex - Fast Userspace Locking system call"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:25
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:28
#, no-wrap
msgid ""
"B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct "
"timespec *>I<timeout>B<,>\n"
msgstr ""

#.  int *? void *? u32 *?
#. type: Plain text
#: build/C/man2/futex.2:31
#, no-wrap
msgid "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:48
msgid ""
"The B<futex>()  system call provides a method for a program to wait for a "
"value at a given address to change, and a method to wake up anyone waiting "
"on a particular address (while the addresses for the same memory in separate "
"processes may not be equal, the kernel maps them internally so the same "
"memory mapped in different locations will correspond for B<futex>()  "
"calls).  This system call is typically used to implement the contended case "
"of a lock in shared memory, as described in B<futex>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:55
msgid ""
"When a B<futex>(7)  operation did not finish uncontended in userspace, a "
"call needs to be made to the kernel to arbitrate.  Arbitration can either "
"mean putting the calling process to sleep or, conversely, waking a waiting "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:62
msgid ""
"Callers of this function are expected to adhere to the semantics as set out "
"in B<futex>(7).  As these semantics involve writing nonportable assembly "
"instructions, this in turn probably means that most users will in fact be "
"library authors and not general application developers."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:70
msgid ""
"The I<uaddr> argument needs to point to an aligned integer which stores the "
"counter.  The operation to execute is passed via the I<op> argument, along "
"with a value I<val>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:72
msgid "Five operations are currently defined:"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:72 build/C/man2/futex.2:177
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:90
msgid ""
"This operation atomically verifies that the futex address I<uaddr> still "
"contains the value I<val>, and sleeps awaiting B<FUTEX_WAKE> on this futex "
"address.  If the I<timeout> argument is non-NULL, its contents describe the "
"maximum duration of the wait, which is infinite otherwise.  The arguments "
"I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:98
msgid ""
"For B<futex>(7), this call is executed if decrementing the count gave a "
"negative value (indicating contention), and will sleep until another process "
"releases the futex and executes the B<FUTEX_WAKE> operation."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:98 build/C/man2/futex.2:194
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:109
msgid ""
"This operation wakes at most I<val> processes waiting on this futex address "
"(i.e., inside B<FUTEX_WAIT>).  The arguments I<timeout>, I<uaddr2> and "
"I<val3> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:115
msgid ""
"For B<futex>(7), this is executed if incrementing the count showed that "
"there were waiters, once the futex value has been set to 1 (indicating that "
"it is available)."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:115
#, no-wrap
msgid "B<FUTEX_FD> (present up to and including Linux 2.6.25)"
msgstr ""

#.  , suitable for .BR poll (2).
#. type: Plain text
#: build/C/man2/futex.2:131
msgid ""
"To support asynchronous wakeups, this operation associates a file descriptor "
"with a futex.  If another process executes a B<FUTEX_WAKE>, the process will "
"receive the signal number that was passed in I<val>.  The calling process "
"must close the returned file descriptor after use.  The arguments "
"I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:136
msgid ""
"To prevent race conditions, the caller should test if the futex has been "
"upped after B<FUTEX_FD> returns."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:140
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:140
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.5.70)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:155
msgid ""
"This operation was introduced in order to avoid a \"thundering herd\" effect "
"when B<FUTEX_WAKE> is used and all processes woken up need to acquire "
"another futex.  This call wakes up I<val> processes, and requeues all other "
"waiters on the futex at address I<uaddr2>.  The arguments I<timeout> and "
"I<val3> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:155
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:173
msgid ""
"There was a race in the intended use of B<FUTEX_REQUEUE>, so "
"B<FUTEX_CMP_REQUEUE> was introduced.  This is similar to B<FUTEX_REQUEUE>, "
"but first checks whether the location I<uaddr> still contains the value "
"I<val3>.  If not, the operation fails with the error B<EAGAIN>.  The "
"argument I<timeout> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:177
msgid ""
"Depending on which operation was executed, the returned value for a "
"successful call can have differing meanings."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:194
msgid ""
"Returns 0 if the process was woken by a B<FUTEX_WAKE> call.  In case of "
"timeout, the operation fails with the error B<ETIMEDOUT>.  If the futex was "
"not equal to the expected value, the operation fails with the error "
"B<EWOULDBLOCK>.  Signals (see B<signal>(7))  or other spurious wakeups cause "
"B<FUTEX_WAIT> to fail with the error B<EINTR>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:197 build/C/man2/futex.2:203 build/C/man2/futex.2:206
msgid "Returns the number of processes woken up."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:197
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:200
msgid "Returns the new file descriptor associated with the futex."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:200
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:203
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:210
msgid ""
"In the event of an error, all operations return -1, and set I<errno> to "
"indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:211 build/C/man2/quotactl.2:484
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:214
msgid "No read access to futex memory."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:214 build/C/man2/sendfile.2:112
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:222
msgid ""
"B<FUTEX_CMP_REQUEUE> found an unexpected futex value.  (This probably "
"indicates a race; use the safe B<FUTEX_WAKE> now.)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:227
msgid "Error in getting I<timeout> information from userspace."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:230
msgid "An operation was not defined or error in page alignment."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:230
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:233
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:233 build/C/man2/modify_ldt.2:124 build/C/man2/pciconfig_read.2:90 build/C/man2/quotactl.2:445 build/C/man2/vm86.2:62
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:237
msgid "Invalid operation specified in I<op>."
msgstr ""

#. type: SH
#: build/C/man2/futex.2:237 build/C/man2/get_robust_list.2:110 build/C/man2/kexec_load.2:134 build/C/man2/lookup_dcookie.2:73 build/C/man2/pivot_root.2:119 build/C/man2/process_vm_readv.2:274 build/C/man2/sendfile.2:138 build/C/man2/set_tid_address.2:86 build/C/man2/splice.2:165 build/C/man2/tee.2:114 build/C/man2/vmsplice.2:138
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:247
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A 4-argument system call with the semantics "
"described in this page was introduced in Linux 2.5.40.  In Linux 2.5.70 one "
"argument was added.  In Linux 2.6.7 a sixth argument was added\\(emmessy, "
"especially on the s390 architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:249 build/C/man2/kexec_load.2:140 build/C/man2/set_tid_address.2:91 build/C/man2/splice.2:172 build/C/man2/tee.2:121 build/C/man2/vmsplice.2:145
msgid "This system call is Linux-specific."
msgstr ""

#.  .SH "AUTHORS"
#.  .PP
#.  Futexes were designed and worked on by
#.  Hubertus Franke (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat)
#.  and Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: build/C/man2/futex.2:263
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end-users.  (There is no wrapper function for this system call in "
"glibc.)  Implementors are expected to be assembly literate and to have read "
"the sources of the futex userspace library referenced below."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:265
msgid "B<futex>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:268
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:270
msgid "http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:272
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:274
msgid "ftp://ftp.nl.kernel.org/pub/linux/kernel/people/rusty/."
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:27
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:27
#, no-wrap
msgid "2012-05-03"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:27
#, no-wrap
msgid "Linux System Calls"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:30
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:38
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head "
"**>I<head_ptr>B<,>\n"
"B<\t\t\t  size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:44
msgid ""
"The robust futex implementation needs to maintain per-thread lists of robust "
"futexes which are unlocked when the thread exits.  These lists are managed "
"in user space; the kernel is only notified about the location of the head of "
"the list."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:60
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:72
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head "
"of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:79
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero "
"when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:83
msgid "The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:89
msgid ""
"I<len> does not match the size of structure B<struct robust_list_head> "
"expected by kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:93
msgid "The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:101
msgid ""
"The calling process does not have permission to see the robust futex list of "
"the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: TP
#: build/C/man2/get_robust_list.2:101 build/C/man2/process_vm_readv.2:269 build/C/man2/ptrace.2:1632 build/C/man2/quotactl.2:459 build/C/man2/quotactl.2:502
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:106
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:110
msgid "The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:114
msgid ""
"These system calls were added in Linux 2.6.17.  No library support is "
"provided; use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:117
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:121
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  .BR pthread_mutexattr_setrobust_np (3)
#. type: Plain text
#: build/C/man2/get_robust_list.2:124
msgid "B<futex>(2)"
msgstr ""

#.  http://lwn.net/Articles/172149/
#. type: Plain text
#: build/C/man2/get_robust_list.2:130
msgid ""
"The kernel source files I<Documentation/robust-futexes.txt> and "
"I<Documentation/robust-futex-ABI.txt>."
msgstr ""

#. type: TH
#: build/C/man2/kexec_load.2:25
#, no-wrap
msgid "KEXEC_LOAD"
msgstr ""

#. type: TH
#: build/C/man2/kexec_load.2:25
#, no-wrap
msgid "2010-11-04"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:28
msgid "kexec_load - load a new kernel for later execution"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:30
msgid "B<#include E<lt>linux/kexec.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:32
msgid ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long "
">I<nr_segments>B<,>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:35
msgid "B< struct kexec_segment *>I<segments>B<, unsigned long >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:40
msgid ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:46
msgid ""
"The I<flags> argument is a mask whose high-order bits control the operation "
"of the call.  The following values can be specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:46
#, no-wrap
msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgstr ""

#.  FIXME figure out how this is really used
#. type: Plain text
#: build/C/man2/kexec_load.2:50
msgid "Execute the new kernel automatically on a system crash."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:50
#, no-wrap
msgid "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.7.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:60
msgid ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is only available "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is only "
"effective if I<nr_segments> is greater than 0."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:80
msgid ""
"The low-order bits of I<flags> contain the architecture of the "
"to-be-executed kernel.  Specify (OR) the constant B<KEXEC_ARCH_DEFAULT> to "
"use the current architecture, or one of the following architecture constants "
"B<KEXEC_ARCH_386>, B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, "
"B<KEXEC_ARCH_PPC64>, B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, "
"B<KEXEC_ARCH_S390>, B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and "
"B<KEXEC_ARCH_MIPS_LE>.  The architecture must be executable on the CPU of "
"the system."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:94
msgid ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:103
#, no-wrap
msgid ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"
msgstr ""

#.  FIXME elaborate on the following:
#. type: Plain text
#: build/C/man2/kexec_load.2:110
msgid ""
"The kernel image defined by I<segments> is copied from the calling process "
"into previously reserved memory."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:117
msgid ""
"On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:118 build/C/man2/pivot_root.2:104 build/C/man2/ptrace.2:1595 build/C/man2/quotactl.2:493
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:122
msgid ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."
msgstr ""

#.  KEXEC_SEGMENT_MAX == 16
#. type: Plain text
#: build/C/man2/kexec_load.2:129
msgid "I<flags> is invalid; or I<nr_segments> is too large"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:134
msgid "The caller does not have the B<CAP_SYS_BOOT> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:138
msgid "The B<kexec_load>()  system call first appeared in Linux 2.6.13."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:145
msgid ""
"Currently, there is no glibc support for B<kexec_load>().  Call it using "
"B<syscall>(2)."
msgstr ""

#.  FIXME Andi submitted a patch for this.
#.  Check if it got accepted later.
#. type: Plain text
#: build/C/man2/kexec_load.2:152
msgid ""
"The required constants are in the kernel source file I<linux/kexec.h>, which "
"is not currently exported to glibc.  Therefore, these constants must be "
"defined manually."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:155
msgid ""
"This system call is only available if the kernel was configured with "
"B<CONFIG_KEXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:158
msgid "B<reboot>(2), B<syscall>(2)"
msgstr ""

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "LOOKUP_DCOOKIE"
msgstr ""

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "2004-06-17"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:30
msgid "lookup_dcookie - return a directory entry's path"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:32
msgid ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t "
">I<len>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:38
msgid ""
"Look up the full path of the directory entry specified by the value "
"I<cookie>.  The cookie is an opaque identifier uniquely identifying a "
"particular directory entry.  The buffer given is filled in with the full "
"path of the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:43
msgid ""
"For B<lookup_dcookie>()  to return successfully, the kernel must still hold "
"a cookie reference to the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:50
msgid ""
"On success, B<lookup_dcookie>()  returns the length of the path string "
"copied into the buffer.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:54
msgid "The buffer was not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:58
msgid ""
"The kernel has no registered cookie/directory entry mappings at the time of "
"lookup, or the cookie does not refer to a valid directory entry."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:58
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:61
msgid "The name could not fit in the buffer."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:61 build/C/man2/process_vm_readv.2:260 build/C/man2/sendfile.2:134 build/C/man2/splice.2:155 build/C/man2/tee.2:111 build/C/man2/vmsplice.2:135
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:65
msgid ""
"The kernel could not allocate memory for the temporary buffer holding the "
"path."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:70
msgid ""
"The process does not have the capability B<CAP_SYS_ADMIN> required to look "
"up cookie values."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:70 build/C/man2/quotactl.2:472
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:73
msgid "The buffer was not large enough to hold the path of the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:78
msgid ""
"Available since Linux 2.5.43.  The B<ENAMETOOLONG> error return was added in "
"2.5.70."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:81
msgid "B<lookup_dcookie>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:85
msgid ""
"B<lookup_dcookie>()  is a special-purpose system call, currently used only "
"by the oprofile profiler.  It relies on a kernel driver to register cookies "
"for directory entries."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:88
msgid ""
"The path returned may be suffixed by the string \" (deleted)\" if the "
"directory entry has been removed."
msgstr ""

#. type: TH
#: build/C/man2/modify_ldt.2:25
#, no-wrap
msgid "MODIFY_LDT"
msgstr ""

#. type: TH
#: build/C/man2/modify_ldt.2:25 build/C/man2/pivot_root.2:7
#, no-wrap
msgid "2007-06-01"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:28
msgid "modify_ldt - get or set ldt"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:33
#, no-wrap
msgid ""
"B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long "
">I<bytecount>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:39
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (ldt) for a "
"process.  The ldt is a per-process memory management table used by the i386 "
"processor.  For more information on this table, see an Intel 386 processor "
"handbook."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:49
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the ldt into the memory pointed to "
"by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the "
"actual size of the ldt."
msgstr ""

#
#.  FIXME ? say something about func == 2 and func == 0x11?
#.  In Linux 2.4, func == 2 returned "the default ldt"
#.  In Linux 2.6, func == 2 is a nop, returning a zeroed out structure.
#.  Linux 2.4 and 2.6 implement an operation for func == 0x11
#. type: Plain text
#: build/C/man2/modify_ldt.2:67
msgid ""
"When I<func> is 1, B<modify_ldt>()  modifies one ldt entry.  I<ptr> points "
"to a I<user_desc> structure and I<bytecount> must equal the size of this "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:71
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:85
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""

#.  .PP
#.  The ldt is specific for the calling process. Any attempts to change
#.  the ldt to include the address space of another process or the kernel
#.  will result in a segmentation violation when trying to access the memory
#.  outside of the process address space. The memory protection is enforced
#.  at the paging layer.
#. type: Plain text
#: build/C/man2/modify_ldt.2:96
msgid "In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:106
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:111
msgid "I<ptr> points outside the address space."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:124
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<modify_ldt_ldt_s>, or I<func> is 1 and the new ldt entry has "
"invalid values."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:128
msgid "I<func> is neither 0 nor 1."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:131
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:134 build/C/man2/pivot_root.2:128
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:136
msgid "B<vm86>(2)"
msgstr ""

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "NFSSERVCTL"
msgstr ""

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "2012-03-05"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:11
msgid "nfsservctl - syscall interface to kernel nfs daemon"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:14
#, no-wrap
msgid "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:17
#, no-wrap
msgid ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:21
msgid "I<Note>: Since Linux 3.1, this system call no longer exists."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:33
#, no-wrap
msgid ""
"/*\n"
" * These are the commands understood by nfsctl().\n"
" */\n"
"#define NFSCTL_SVC          0    /* This is a server process. */\n"
"#define NFSCTL_ADDCLIENT    1    /* Add an NFS client. */\n"
"#define NFSCTL_DELCLIENT    2    /* Remove an NFS client. */\n"
"#define NFSCTL_EXPORT       3    /* export a file system. */\n"
"#define NFSCTL_UNEXPORT     4    /* unexport a file system. */\n"
"#define NFSCTL_UGIDUPDATE   5    /* update a client's UID/GID map. */\n"
"#define NFSCTL_GETFH        6    /* get an fh (used by mountd) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:45
#, no-wrap
msgid ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:50
#, no-wrap
msgid ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:56 build/C/man2/pivot_root.2:99 build/C/man2/vm86.2:57
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:58
msgid "This call is Linux-specific."
msgstr ""

#. type: TH
#: build/C/man2/outb.2:28
#, no-wrap
msgid "OUTB"
msgstr ""

#. type: TH
#: build/C/man2/outb.2:28
#, no-wrap
msgid "1995-11-29"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:33
msgid ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - port I/O"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:38
msgid ""
"This family of functions is used to do low-level port input and output.  The "
"out* functions do port output, the in* functions do port input; the b-suffix "
"functions are byte-width and the w-suffix functions word-width; the "
"_p-suffix functions pause until the I/O completes."
msgstr ""

#.  , given the following information
#.  in addition to that given in
#.  .BR outb (9).
#. type: Plain text
#: build/C/man2/outb.2:44
msgid ""
"They are primarily designed for internal kernel use, but can be used from "
"user space."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:49
msgid ""
"You compile with B<-O> or B<-O2> or similar.  The functions are defined as "
"inline macros, and will not be substituted in without optimization enabled, "
"causing unresolved references at link time."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:58
msgid ""
"You use B<ioperm>(2)  or alternatively B<iopl>(2)  to tell the kernel to "
"allow the user space application to access the I/O ports in question.  "
"Failure to do this will cause the application to receive a segmentation "
"fault."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:67
msgid ""
"B<outb>()  and friends are hardware-specific.  The I<value> argument is "
"passed first and the I<port> argument is passed second, which is the "
"opposite order from most DOS implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:70
msgid "B<ioperm>(2), B<iopl>(2)"
msgstr ""

#. type: TH
#: build/C/man2/pciconfig_read.2:5
#, no-wrap
msgid "PCICONFIG_READ"
msgstr ""

#. type: TH
#: build/C/man2/pciconfig_read.2:5
#, no-wrap
msgid "2003-07-14"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:8
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:11
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:18
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:24
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"userspace."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:24 build/C/man2/pciconfig_read.2:48
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:33
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:33 build/C/man2/pciconfig_read.2:54
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:42
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:42 build/C/man2/pciconfig_read.2:60
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:47
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:54 build/C/man2/pciconfig_read.2:60
msgid ""
"On success zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:74
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:81
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:81 build/C/man2/ptrace.2:1612 build/C/man2/sendfile.2:130
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:84
msgid "I/O error."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:84
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:90
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:95
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:95
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:102
msgid ""
"This return value is only valid for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:107
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:109
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:111
msgid "B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/personality.2:30
#, no-wrap
msgid "PERSONALITY"
msgstr ""

#. type: TH
#: build/C/man2/personality.2:30
#, no-wrap
msgid "2003-01-01"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:33
msgid "personality - set the process execution domain"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:35
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:37
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:45
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:55
msgid ""
"This function will return the current B<personality>()  when I<persona> "
"equals 0xffffffff.  Otherwise, it will make the execution domain referenced "
"by I<persona> the new execution domain of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:62
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:66
msgid "The kernel was unable to change the personality."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:70
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: TH
#: build/C/man2/pivot_root.2:7
#, no-wrap
msgid "PIVOT_ROOT"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:10
msgid "pivot_root - change the root file system"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:12
msgid "B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""

#
#.  The
#.  .B CAP_SYS_ADMIN
#.  capability is required.
#. type: Plain text
#: build/C/man2/pivot_root.2:21
msgid ""
"B<pivot_root>()  moves the root file system of the calling process to the "
"directory I<put_old> and makes I<new_root> the new root file system of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:28
msgid ""
"The typical use of B<pivot_root>()  is during system startup, when the "
"system mounts a temporary root file system (e.g., an B<initrd>), then mounts "
"the real root file system, and eventually turns the latter into the current "
"root of all relevant processes or threads."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:40
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:58
msgid ""
"The paragraph above is intentionally vague because the implementation of "
"B<pivot_root>()  may change in the future.  At the time of writing, "
"B<pivot_root>()  changes root and current working directory of each process "
"or thread to I<new_root> if they point to the old root directory.  This is "
"necessary in order to prevent kernel threads from keeping the old root "
"directory busy with their root and current working directory, even if they "
"never access the file system in any way.  In the future, there may be a "
"mechanism for kernel threads to explicitly relinquish any access to the file "
"system, such that this fairly intrusive mechanism can be removed from "
"B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:66
msgid ""
"Note that this also applies to the calling process: B<pivot_root>()  may or "
"may not affect its current working directory.  It is therefore recommended "
"to call B<chdir(\"/\")> immediately after B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:68
msgid "The following restrictions apply to I<new_root> and I<put_old>:"
msgstr ""

#. type: IP
#: build/C/man2/pivot_root.2:68 build/C/man2/pivot_root.2:70 build/C/man2/pivot_root.2:73 build/C/man2/pivot_root.2:77
#, no-wrap
msgid "-"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:70
msgid "They must be directories."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:73
msgid ""
"I<new_root> and I<put_old> must not be on the same file system as the "
"current root."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:77
msgid ""
"I<put_old> must be underneath I<new_root>, that is, adding a nonzero number "
"of I</..> to the string pointed to by I<put_old> must yield the same "
"directory as I<new_root>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:79
msgid "No other file system may be mounted on I<put_old>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:83
msgid "See also B<pivot_root>(8)  for additional usage examples."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:90
msgid ""
"If the current root is not a mount point (e.g., after B<chroot>(2)  or "
"B<pivot_root>(), see also below), not the old root directory, but the mount "
"point of that file system is mounted on I<put_old>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:95
msgid ""
"I<new_root> does not have to be a mount point.  In this case, "
"I</proc/mounts> will show the mount point of the file system containing "
"I<new_root> as root (I</>)."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:104
msgid ""
"B<pivot_root>()  may return (in I<errno>) any of the errors returned by "
"B<stat>(2).  Additionally, it may return:"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:108
msgid ""
"I<new_root> or I<put_old> are on the current root file system, or a file "
"system is already mounted on I<put_old>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:111
msgid "I<put_old> is not underneath I<new_root>."
msgstr ""

#. type: TP
#: build/C/man2/pivot_root.2:111
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:114
msgid "I<new_root> or I<put_old> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:119
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:122
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:125
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr ""

#. type: SH
#: build/C/man2/pivot_root.2:128 build/C/man2/ptrace.2:1675
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:132
msgid ""
"B<pivot_root>()  should not have to change root and current working "
"directory of all other processes in the system."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:137
msgid ""
"Some of the more obscure uses of B<pivot_root>()  may quickly lead to "
"insanity."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:143
msgid "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"
msgstr ""

#. type: TH
#: build/C/man2/process_vm_readv.2:27
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr ""

#. type: TH
#: build/C/man2/process_vm_readv.2:27
#, no-wrap
msgid "2012-04-25"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:30
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:33
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:40
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:47
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:55
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:80
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:94
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:104
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:111
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:127
msgid ""
"Buffers are processed in array order.  This means that B<process_vm_readv>()  "
"completely fills I<local_iov[0]> before proceeding to I<local_iov[1]>, and "
"so on.  Likewise, I<remote_iov[0]> is completely read before proceeding to "
"I<remote_iov[1]>, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:138
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:146
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:150
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr ""

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: build/C/man2/process_vm_readv.2:163
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less "
"than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible "
"via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:173
msgid ""
"The count arguments and I<local_iov> are checked before doing any "
"transfers.  If the counts are too big, or I<local_iov> is invalid, or the "
"addresses refer to regions that are inaccessible to the local process, none "
"of the vectors will be processed and an error will be returned immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:193
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep "
"this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4KiB) in a single remote I<iovec> element.  "
"(Instead, split the remote read into two I<remote_iov> elements and have "
"them merge back into a single write I<local_iov> entry.  The first read "
"entry goes up to the page boundary, while the second starts on the next page "
"boundary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:207
msgid ""
"In order to read from or write to another process, either the caller must "
"have the capability B<CAP_SYS_PTRACE>, or the real user ID, effective user "
"ID, and saved set-user-ID of the remote process must match the real user ID "
"of the caller I<and> the real group ID, effective group ID, and saved "
"set-group-ID of the remote process must match the real group ID of the "
"caller.  (The permission required is exactly the same as that required to "
"perform a B<ptrace>(2)  B<PTRACE_ATTACH> on the remote process.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:223
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that "
"splits a single I<iovec> element.)  The caller should check the return value "
"to determine whether a partial read/write occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:227
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:239
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:243
msgid "I<flags> is not 0."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:249
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:254
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:260
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:265
msgid "Could not allocate memory for internal copies of the I<iovec> structures."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:269
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:274
msgid "No process with ID I<pid> exists."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:277
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:279
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:285
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: build/C/man2/process_vm_readv.2:293
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or "
"pipes)."
msgstr ""

#. type: SH
#: build/C/man2/process_vm_readv.2:293 build/C/man2/splice.2:223 build/C/man2/tee.2:130
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:301
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It "
"reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:304
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:314
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:321
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[1].iov_len = 20;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:328
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:332
msgid "B<readv>(2), B<writev>(2)"
msgstr ""

#. type: TH
#: build/C/man2/ptrace.2:49
#, no-wrap
msgid "PTRACE"
msgstr ""

#. type: TH
#: build/C/man2/ptrace.2:49
#, no-wrap
msgid "2012-04-26"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:52
msgid "ptrace - process trace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:55
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:58
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:67
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:78
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:80
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:84
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:90
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:99
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an "
"B<execve>(2).  Alternatively, one process may commence tracing another "
"process using B<PTRACE_ATTACH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:116
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:126
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:130
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:134
msgid "The value of I<request> determines the action to be performed:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:134
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:144
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:157
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH> and B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:157
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:168
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:168
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr ""

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: build/C/man2/ptrace.2:186
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see "
"I<E<lt>sys/user.hE<gt>>).  The word is returned as the result of the "
"B<ptrace>()  call.  Typically, the offset must be word-aligned, though this "
"might vary by architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:186
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:198
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:198
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr ""

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does userspace discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:214
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:214
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:233
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:233
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:245
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:245
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr ""

#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does userspace discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:266
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"from the address I<data> in the tracer.  As for B<PTRACE_POKEUSER>, some "
"general-purpose register modifications may be disallowed.  (I<addr> is "
"ignored.)  Note that SPARC systems have the meaning of I<data> and I<addr> "
"reversed; that is, I<data> is ignored and the registers are copied from the "
"address I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:266
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:282
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:282
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:291
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:292
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:301
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call.  (B<PTRACE_O_TRACESYSGOOD> "
"may not work on all architectures.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:301
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:313
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:316
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:320 build/C/man2/ptrace.2:339 build/C/man2/ptrace.2:358
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:320
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:332
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:335
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:339
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:351
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:354
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:379
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:379
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:388
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:391
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:397
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:397
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:406
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:409
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:413
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:413
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:421
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:424
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:428
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:436
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:437
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:457
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  (I<addr> is "
"ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:457
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:469
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:469
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:493
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:493
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:511
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
"but also singlestep if not a system call.  This call is used by programs "
"like User Mode Linux that want to emulate all the tracee's system calls.  "
"The I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; "
"not supported on all architectures.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:511
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:520
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: build/C/man2/ptrace.2:539
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:539
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr ""

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: build/C/man2/ptrace.2:567
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:567
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:576
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:576
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:585
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:594
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term "
"\"signal-delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:608
msgid ""
"B<SIGKILL> operates similarly, with exceptions.  No signal-delivery-stop is "
"generated for B<SIGKILL> and therefore the tracer can't suppress it.  "
"B<SIGKILL> kills even within system calls (syscall-exit-stop is not "
"generated prior to death by B<SIGKILL>).  The net effect is that B<SIGKILL> "
"always kills the process (all its threads), even if some threads of the "
"process are ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:613
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:617
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:631
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), "
"B<exit_group>(2), and signal deaths (except B<SIGKILL>), and when threads "
"are torn down on B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:656
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  "
"I<waitpid(WNOHANG)> may return 0 instead.  In other words, the tracee may be "
"\"not yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:670
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:670
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:672
msgid "A tracee can be in two states: running or stopped."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:676
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:687
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  "
"Ptrace-stops can be further subdivided into I<signal-delivery-stop>, "
"I<group-stop>, I<syscall-stop>, and so on.  These stopped states are "
"described in detail below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:692
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:694
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr ""

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: build/C/man2/ptrace.2:706
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:714
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:721
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:729
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:733
#, no-wrap
msgid ""
"    kill(tracee, SIGKILL);\n"
"    waitpid(tracee, &status, __WALL | WNOHANG);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:756
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, "
"group-stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the "
"I<WSTOPSIG(status)> macro can't be used to perform this examination, because "
"it returns the value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:756
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:776
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:790
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by "
"I<WSTOPSIG(status)>.  If the signal is B<SIGTRAP>, this may be a different "
"kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below "
"for details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be "
"a group-stop; see below."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:790
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:793
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:795
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:808
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:814
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:830
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few syscalls which use a different "
"mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  Even system "
"calls (such as B<poll>(2))  which are not restartable after signal are "
"restarted after signal is suppressed; however, kernel bugs exist which cause "
"some syscalls to fail with B<EINTR> even though no observable signal is "
"injected to the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:841
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than "
"signal-delivery-stop are not guaranteed to inject a signal, even if I<sig> "
"is nonzero.  No error is reported; a nonzero I<sig> may simply be ignored.  "
"Ptrace users should not try to \"create a new signal\" this way: use "
"B<tgkill>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:848
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:850
#, no-wrap
msgid "    ptrace(PTRACE_rest, pid, 0, stopsig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:856
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:876
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before "
"signal-delivery-stop.  The tracer can't suppress this side effect (it can "
"only suppress signal injection, which only causes the B<SIGCONT> handler to "
"not be executed in the tracee, if such a handler is installed).  In fact, "
"waking up from group-stop may be followed by signal-delivery-stop for "
"signal(s)  I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> "
"was delivered.  In other words, B<SIGCONT> may be not the first signal "
"observed by the tracee after it was sent."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:880
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: build/C/man2/ptrace.2:890
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:907
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:907
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:919
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:928
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via "
"I<WSTOPSIG(status)>.  The same result is returned by some other classes of "
"ptrace-stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:930
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:951
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:960
msgid ""
"As of kernel 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:974
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:974
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:980
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter "
"ptrace-stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:994
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:996
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:998
msgid "The following events exist:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:998
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1011
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1011
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1019
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1019
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1023
msgid "Stop before return from B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1023
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1033
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1039
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1039
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1046
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1046
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1062
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1074
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1074
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1087
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL>, the tracee enters "
"syscall-enter-stop just prior to entering any system call.  If the tracer "
"restarts the tracee with B<PTRACE_SYSCALL>, the tracee enters "
"syscall-exit-stop when the system call is finished, or if it is interrupted "
"by a signal.  (That is, signal-delivery-stop never happens between "
"syscall-enter-stop and syscall-exit-stop; it happens I<after> "
"syscall-exit-stop.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1101
msgid ""
"Other possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop, "
"exit (if it entered B<_exit>(2)  or B<exit_group>(2)), be killed by "
"B<SIGKILL>, or die silently (if it is a thread group leader, the "
"B<execve>(2)  happened in another thread, and that thread is not traced by "
"the same tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1116
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and "
"I<WSTOPSIG(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> "
"option was set by the tracer, then I<WSTOPSIG(status)> will give the value "
"I<(SIGTRAP\\ |\\ 0x80)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1122
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1122
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1134
msgid ""
"B<SIGTRAP> was delivered as a result of a userspace action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1134
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1138
msgid "B<SIGTRAP> was sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1138
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1141
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1146
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1169
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in "
"syscall-enter-stop.  Since B<SIGTRAP> (like any other signal) always happens "
"I<after> syscall-exit-stop, and at this point I<rax> almost never contains "
"-B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not "
"syscall-enter-stop\"; in other words, it looks like a \"stray "
"syscall-exit-stop\" and can be detected this way.  But such detection is "
"fragile and is best avoided."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1175
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1186
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as "
"syscall-exit-stop or vice versa.  The rule is that syscall-enter-stop is "
"always followed by syscall-exit-stop, B<PTRACE_EVENT> stop or the tracee's "
"death; no other kinds of ptrace-stop can occur in between."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1191
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1203
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1203
#, no-wrap
msgid "PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops"
msgstr ""

#
#.  FIXME
#.  document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
#.  PTRACE_SYSEMU_SINGLESTEP
#. type: Plain text
#: build/C/man2/ptrace.2:1209
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1209
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1217
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_TRACEME>, and "
"B<PTRACE_KILL>)  require the tracee to be in a ptrace-stop, otherwise they "
"fail with B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1222
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1232
#, no-wrap
msgid ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1244
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1246
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1248
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1257
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1260
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1262
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1282
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_DETACH>, B<PTRACE_SYSCALL>, "
"B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or B<PTRACE_SYSEMU_SINGLESTEP>.  If "
"the tracee is in signal-delivery-stop, I<sig> is the signal to be injected "
"(if it is nonzero).  Otherwise, I<sig> may be ignored.  (When restarting a "
"tracee from a ptrace-stop other than signal-delivery-stop, recommended "
"practice is to always pass 0 in I<sig>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1282
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1284
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1286
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr ""

#
#.  FIXME: Describe how to attach to a thread which is already
#.         group-stopped.
#. type: Plain text
#: build/C/man2/ptrace.2:1310
msgid ""
"This also sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1317
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1319
msgid "The request"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1321
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1327
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1329
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1332
msgid ""
"and allow the parent (which is our tracer now) to observe our "
"signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1356
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1358
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1360
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1368
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME: Describe how to detach from a group-stopped tracee so that it
#.         doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: build/C/man2/ptrace.2:1392
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1400
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from "
"signal-delivery-stop, the pending signal is injected."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1400
#, no-wrap
msgid "execve(2) under ptrace"
msgstr ""

#.  clone(2) THREAD_CLONE says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: build/C/man2/ptrace.2:1419
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:1419 build/C/man2/ptrace.2:1429 build/C/man2/ptrace.2:1437 build/C/man2/ptrace.2:1443 build/C/man2/ptrace.2:1572
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1429
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1437
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1443
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1464
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1467
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1487
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0).  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1493
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1501
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1503
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1507
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1518
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1541
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, the kernel delivers an extra B<SIGTRAP> to the tracee after "
"B<execve>(2)  returns.  This is an ordinary signal (similar to one which can "
"be generated by I<kill -TRAP>), not a special kind of ptrace-stop.  "
"Employing B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set to 0 "
"(I<SI_USER>).  This signal may be blocked by signal mask, and thus may be "
"delivered (much) later."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1560
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option and thus suppressing this extra "
"B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1560
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1567
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1570
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1572
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1580
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1594
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must clear I<errno> before the call, and then "
"check it afterward to determine whether or not an error occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1598
msgid "(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1609
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1612
msgid "An attempt was made to set an invalid option."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1619
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a "
"word-alignment violation, or an invalid signal was specified during a "
"restart request."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1632
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(8)  (PID 1)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1637
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1639
msgid "SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1652
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  This means that unneeded "
"trailing arguments may be omitted, though doing so makes use of undocumented "
"B<gcc>(1)  behavior."
msgstr ""

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: build/C/man2/ptrace.2:1657
msgid ""
"In Linux kernels before 2.6.26, B<init>(8), the process with PID 1, may not "
"be traced."
msgstr ""

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: build/C/man2/ptrace.2:1664
msgid ""
"The layout of the contents of memory and the USER area are quite "
"operating-system- and architecture-specific.  The offset supplied, and the "
"data returned, might not entirely match with the definition of I<struct "
"user>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1667
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1675
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of UNIX.  In any case, use "
"of B<ptrace>()  is highly specific to the operating system and architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1686
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1689
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME: ^^^ need to test/verify this scenario
#. type: Plain text
#: build/C/man2/ptrace.2:1720
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls "
"B<execve>(2), the death of the thread group leader will I<never> be "
"reported.  If the execed thread is not traced by this tracer, the tracer "
"will never know that B<execve>(2)  happened.  One possible workaround is to "
"B<PTRACE_DETACH> the thread group leader instead of restarting it in this "
"case.  Last confirmed on 2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1730
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on "
"2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1746
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1760
msgid ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), "
"B<gettid>(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), "
"B<exec>(3), B<capabilities>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/quotactl.2:25
#, no-wrap
msgid "QUOTACTL"
msgstr ""

#. type: TH
#: build/C/man2/quotactl.2:25
#, no-wrap
msgid "2010-06-16"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:28
msgid "quotactl - manipulate disk quotas"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:35
#, no-wrap
msgid ""
"B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, "
"caddr_t >I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:47
msgid ""
"The quota system can be used to set per-user and per-group limits on the "
"amount of disk space used on a file system.  For each user and/or group, a "
"soft limit and a hard limit can be set for each file system.  The hard limit "
"can't be exceeded.  The soft limit can be exceeded, but warnings will "
"ensue.  Moreover, the user can't exceed the soft limit for more than one "
"week (by default) at a time; after this time, the soft limit counts as a "
"hard limit."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:72
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, or "
"B<GRPQUOTA>, for group quotas.  The I<subcmd> value is described below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:77
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the file system being "
"manipulated."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:85
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each command below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:89
msgid "The I<subcmd> value is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:89
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:96
msgid ""
"Turn on quotas for a file system.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported "
"quota formats:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:97
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:100
msgid "The original quota format."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:100
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:104
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:104
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:108
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64 "
"bytes and 2^64 inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:119
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the file system.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:119
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:129
msgid ""
"Turn off quotas for a file system.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:129
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:140
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:145 build/C/man2/quotactl.2:232
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:165
#, no-wrap
msgid ""
"struct dqblk {          /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;   /* absolute limit on disk\n"
"                                  quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;   /* preferred limit on\n"
"                                  disk quota blocks */\n"
"    uint64_t dqb_curspace;     /* current quota block\n"
"                                  count */\n"
"    uint64_t dqb_ihardlimit;   /* maximum number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_isoftlimit;   /* preferred inode limit */\n"
"    uint64_t dqb_curinodes;    /* current number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_btime;        /* time limit for excessive\n"
"                                  disk use */\n"
"    uint64_t dqb_itime;        /* time limit for excessive\n"
"                                  files */\n"
"    uint32_t dqb_valid;        /* bit mask of QIF_*\n"
"                                  constants */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:168
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:179
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:196
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:196
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:216
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and "
"B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:216
#, no-wrap
msgid "B<Q_GETINFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:227
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:236
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;    /* Time before block soft limit\n"
"                               becomes hard limit */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:243
#, no-wrap
msgid ""
"    uint64_t dqi_igrace;    /* Time before inode soft limit\n"
"                               becomes hard limit */\n"
"    uint32_t dqi_flags;     /* Flags for quotafile\n"
"                               (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:245
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:247
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:249
#, no-wrap
msgid "#define V1_DQF_RSQUASH\t1   /* Root squash enabled */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:251
#, no-wrap
msgid "/* Other quota formats have no dqi_flags bits defined */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:254
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:259
#, no-wrap
msgid ""
"# define IIF_BGRACE\t1\n"
"# define IIF_IGRACE\t2\n"
"# define IIF_FLAGS\t4\n"
"# define IIF_ALL\t(IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:275
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of "
"the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:275
#, no-wrap
msgid "B<Q_SETINFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:299
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure "
"indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:299
#, no-wrap
msgid "B<Q_GETFMT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:306
msgid ""
"Get quota format used on the specified file system.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:306
#, no-wrap
msgid "B<Q_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:317
msgid ""
"Update the on-disk copy of quota usages for a file system.  If I<special> is "
"NULL, then all file systems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:317
#, no-wrap
msgid "B<Q_GETSTATS>"
msgstr ""

#.  Q_GETSTATS was removed in kernel 2.4.22.
#. type: Plain text
#: build/C/man2/quotactl.2:337
msgid ""
"Get statistics and other generic information about the quota subsystem.  The "
"I<addr> argument should be a pointer to a I<dqstats> structure in which data "
"should be stored.  This structure is defined in I<E<lt>sys/quota.hE<gt>.> "
"The I<special> and I<id> arguments are ignored.  This operation is obsolete "
"and not supported by recent kernels.  Files in I</proc/sys/fs/quota/> carry "
"the information instead."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:340
msgid ""
"For XFS file systems making use of the XFS Quota Manager (XQM), the above "
"commands are bypassed and the following commands are used:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:340
#, no-wrap
msgid "B<Q_XQUOTAON>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:361
msgid ""
"Turn on quotas for an XFS file system.  XFS provides the ability to turn "
"on/off quota limit enforcement with quota accounting.  Therefore, XFS "
"expects I<addr> to be a pointer to an I<unsigned int> that contains either "
"the flags B<XFS_QUOTA_UDQ_ACCT> and/or B<XFS_QUOTA_UDQ_ENFD> (for user "
"quota), or B<XFS_QUOTA_GDQ_ACCT> and/or B<XFS_QUOTA_GDQ_ENFD> (for group "
"quota), as defined in I<E<lt>xfs/xqm.hE<gt>>.  This operation requires "
"privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:361
#, no-wrap
msgid "B<Q_XQUOTAOFF>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:372
msgid ""
"Turn off quotas for an XFS file system.  As with B<Q_QUOTAON>, XFS file "
"systems expect a pointer to an I<unsigned int> that specifies whether quota "
"accounting and/or limit enforcement need to be turned off.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:372
#, no-wrap
msgid "B<Q_XGETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:386
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure (defined in "
"I<E<lt>xfs/xqm.hE<gt>>).  Unprivileged users may retrieve only their own "
"quotas; a privileged user (B<CAP_SYS_ADMIN>)  may retrieve the quotas of any "
"user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:386
#, no-wrap
msgid "B<Q_XSETQLIM>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:398
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure (defined in I<E<lt>xfs/xqm.hE<gt>>).  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:398
#, no-wrap
msgid "B<Q_XGETQSTAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:406
msgid ""
"Returns an I<fs_quota_stat> structure containing XFS file system specific "
"quota information.  This is useful for finding out how much space is used to "
"store quota information, and also to get quotaon/off status of a given local "
"XFS file system."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:406
#, no-wrap
msgid "B<Q_XQUOTARM>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:410
msgid ""
"Free the disk space taken by disk quotas.  Quotas must have already been "
"turned off."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:417
msgid ""
"There is no command equivalent to B<Q_SYNC> for XFS since B<sync>(1)  writes "
"quota information to disk (in addition to the other file system metadata "
"that it writes out)."
msgstr ""

#. type: SH
#: build/C/man2/quotactl.2:417
#, no-wrap
msgid "RETURN VALUES"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:425
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:432
msgid "I<addr> or I<special> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:438
msgid "I<cmd> or I<type> is invalid."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:438
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:445
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:450
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:450
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:454
msgid "I<special> is not a block device."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:459
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:463
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this file system."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:472
msgid "If I<cmd> is B<Q_SETQUOTA>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:475
msgid "Specified limits are out of range allowed by quota format."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:484
msgid "If I<cmd> is B<Q_QUOTAON>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:493
msgid ""
"The quota file pointed to by I<addr> exists, but is not a regular file; or, "
"the quota file pointed to by I<addr> exists, but is not on the file system "
"pointed to by I<special>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:499
msgid "B<Q_QUOTAON> attempted, but another B<Q_QUOTAON> had already been performed."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:502
msgid "The quota file is corrupted."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:505
msgid "Specified quota format was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:510
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr ""

#. type: TH
#: build/C/man2/sendfile.2:15
#, no-wrap
msgid "SENDFILE"
msgstr ""

#. type: TH
#: build/C/man2/sendfile.2:15
#, no-wrap
msgid "2011-09-14"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:18
msgid "sendfile - transfer data between file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:20
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr ""

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" \
#.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: build/C/man2/sendfile.2:43
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:53
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:58
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:79
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the current file offset of I<in_fd>; "
"otherwise the current file offset is adjusted to reflect the number of bytes "
"read from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:86
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"current file offset, and the file offset will be updated by the call."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:89
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:96
msgid ""
"The I<in_fd> argument must correspond to a file which supports "
"B<mmap>(2)-like operations (i.e., it cannot be a socket)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:104
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then "
"B<sendfile>()  changes the file offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:111
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:117
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""

#. type: TP
#: build/C/man2/sendfile.2:117 build/C/man2/splice.2:143 build/C/man2/vmsplice.2:123
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:121
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:124
msgid "Bad address."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:130
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:134
msgid "Unspecified error while reading from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:138
msgid "Insufficient memory to read from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:144
msgid ""
"B<sendfile>()  is a new feature in Linux 2.2.  The include file "
"I<E<lt>sys/sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:146
msgid "Not specified in POSIX.1-2001, or other standards."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:151
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:161
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:167
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file, and "
"B<sendfile>()  changed the current offset of that file."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:179
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:188
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:193
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary files (e.g., a pair of sockets)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:198
msgid "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/set_tid_address.2:23
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr ""

#. type: TH
#: build/C/man2/set_tid_address.2:23
#, no-wrap
msgid "2004-09-10"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:26
msgid "set_tid_address - set pointer to thread ID"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:29
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:31
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:38
msgid ""
"The kernel keeps for each process two values called I<set_child_tid> and "
"I<clear_child_tid> that are NULL by default."
msgstr ""

#. type: SS
#: build/C/man2/set_tid_address.2:38
#, no-wrap
msgid "set_child_tid"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:48
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to I<child_tidptr>, the fifth argument of that "
"system call."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:53
msgid ""
"When I<set_child_tid> is set, the very first thing the new process does is "
"writing its PID at this address."
msgstr ""

#. type: SS
#: build/C/man2/set_tid_address.2:53
#, no-wrap
msgid "clear_child_tid"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:63
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to I<child_tidptr>, the fifth argument of "
"that system call."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:70
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling process to I<tidptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:80
msgid ""
"When I<clear_child_tid> is set, and the process exits, and the process was "
"sharing memory with other processes or threads, then 0 is written at this "
"address, and a I<futex(child_tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);> call is "
"done.  (That is, wake a single process waiting on this futex.)  Errors are "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:83
msgid "B<set_tid_address>()  always returns the PID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:86
msgid "B<set_tid_address>()  always succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:89
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:94
msgid "B<clone>(2), B<futex>(2)"
msgstr ""

#. type: TH
#: build/C/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr ""

#. type: TH
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "2012-05-04"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:33 build/C/man2/tee.2:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#.  Return type was long before glibc 2.7
#. type: Plain text
#: build/C/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the descriptors must refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:80
msgid ""
"If I<fd_in> refers to a pipe, then I<off_in> must be NULL.  If I<fd_in> does "
"not refer to a pipe and I<off_in> is NULL, then bytes are read from I<fd_in> "
"starting from the current file offset, and the current file offset is "
"adjusted appropriately.  If I<fd_in> does not refer to a pipe and I<off_in> "
"is not NULL, then I<off_in> must point to a buffer which specifies the "
"starting offset from which bytes will be read from I<fd_in>; in this case, "
"the current file offset of I<fd_in> is not changed.  Analogous statements "
"apply for I<fd_out> and I<off_out>."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:85 build/C/man2/vmsplice.2:78
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:85 build/C/man2/tee.2:62 build/C/man2/vmsplice.2:78
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:98
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:98 build/C/man2/tee.2:68 build/C/man2/vmsplice.2:84
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:107
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:107 build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:121
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:121 build/C/man2/tee.2:79 build/C/man2/vmsplice.2:97
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:127
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:136
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe.  A return value of 0 means that there was no data to "
"transfer, and it would not make sense to block, because there are no writers "
"connected to the write end of the pipe referred to by I<fd_in>."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:142
msgid "On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:147
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: build/C/man2/splice.2:155
msgid ""
"Target file system doesn't support splicing; target file is opened in append "
"mode; neither of the descriptors refers to a pipe; or offset given for "
"nonseekable device."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:158 build/C/man2/tee.2:114 build/C/man2/vmsplice.2:138
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:158
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:165
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:170
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:182
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"userspace programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:182
#, no-wrap
msgid "B<splice>()"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:186
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:186
#, no-wrap
msgid "B<tee>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:189
msgid "\"copies\" the data from one buffer to another."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:189
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:192
msgid "\"copies\" data from user space into the buffer."
msgstr ""

#
#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: build/C/man2/splice.2:223
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:226
msgid "See B<tee>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:230
msgid "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/tee.2:26
#, no-wrap
msgid "TEE"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:29
msgid "tee - duplicating pipe content"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:36
#, no-wrap
msgid ""
"B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned "
"int >I<flags>B<);>\n"
msgstr ""

#.  Example programs http://brick.kernel.dk/snaps
#
#
#.  add a "tee(in, out1, out2)" system call that duplicates the pages
#.  (again, incrementing their reference count, not copying the data) from
#.  one pipe to two other pipes.
#. type: Plain text
#: build/C/man2/tee.2:56
msgid ""
"B<tee>()  duplicates up to I<len> bytes of data from the pipe referred to by "
"the file descriptor I<fd_in> to the pipe referred to by the file descriptor "
"I<fd_out>.  It does not consume the data that is duplicated from I<fd_in>; "
"therefore, that data can be copied by a subsequent B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:62
msgid ""
"I<flags> is a series of modifier flags, which share the name space with "
"B<splice>(2)  and B<vmsplice>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:68
msgid "Currently has no effect for B<tee>(); see B<splice>(2)."
msgstr ""

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:79
msgid ""
"Currently has no effect for B<tee>(), but may be implemented in the future; "
"see B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:85
msgid "Unused for B<tee>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:94
msgid ""
"Upon successful completion, B<tee>()  returns the number of bytes that were "
"duplicated between the input and output.  A return value of 0 means that "
"there was no data to transfer, and it would not make sense to block, because "
"there are no writers connected to the write end of the pipe referred to by "
"I<fd_in>."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:100
msgid "On error, B<tee>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:111
msgid ""
"I<fd_in> or I<fd_out> does not refer to a pipe; or I<fd_in> and I<fd_out> "
"refer to the same pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:119
msgid ""
"The B<tee>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:130
msgid ""
"Conceptually, B<tee>()  copies the data between the two pipes.  In reality "
"no real data copying takes place though: under the covers, B<tee>()  assigns "
"data in the output by merely grabbing a reference to the input."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:136
msgid ""
"The following example implements a basic B<tee>(1)  program using the "
"B<tee>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:145
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:151
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:156
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:162
#, no-wrap
msgid ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:169
#, no-wrap
msgid ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:178
#, no-wrap
msgid ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:192
#, no-wrap
msgid ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:196
#, no-wrap
msgid ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:200
msgid "B<splice>(2), B<vmsplice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr ""

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:46
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28 it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:50
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:52
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:62
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"userspace data."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:66
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:71
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should only exist within vm86 mode itself.)"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:74
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: TH
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:29
msgid "vmsplice - splice user pages into a pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#. type: Plain text
#: build/C/man2/vmsplice.2:57
msgid ""
"The B<vmsplice>()  system call maps I<nr_segs> ranges of user memory "
"described by I<iov> into a pipe.  The file descriptor I<fd> must refer to a "
"pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:64
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:71
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;            /* Starting address */\n"
"    size_t iov_len;             /* Number of bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:84
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:97
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""

#.  FIXME Explain the following line in a little more detail:
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: build/C/man2/vmsplice.2:113
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, or page cache and on-disk data may differ.  Gifting pages "
"to the kernel means that a subsequent B<splice>(2)  B<SPLICE_F_MOVE> can "
"successfully move the pages; if this flag is not specified, then a "
"subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the pages.  Data must "
"also be properly page aligned, both in memory and length."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:122
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:127
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:135
msgid ""
"I<nr_segs> is 0 or greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:143
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:154
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on number of segments being passed in.  This limit "
"is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  At the time of this "
"writing, that limit is 1024."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:157
msgid "B<splice>(2), B<tee>(2)"
msgstr ""

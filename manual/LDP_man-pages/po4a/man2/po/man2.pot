# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-03-26 16:48+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/arch_prctl.2:25
#, no-wrap
msgid "ARCH_PRCTL"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:25
#, no-wrap
msgid "2007-12-26"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/futex.2:53 build/C/man2/get_robust_list.2:29 build/C/man2/getunwind.2:27 build/C/man2/kexec_load.2:26 build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:24 build/C/man2/nfsservctl.2:8 build/C/man2/outb.2:26 build/C/man2/pciconfig_read.2:8 build/C/man2/perf_event_open.2:27 build/C/man2/perfmonctl.2:27 build/C/man2/personality.2:32 build/C/man2/pivot_root.2:10 build/C/man2/process_vm_readv.2:29 build/C/man2/ptrace.2:44 build/C/man2/quotactl.2:27 build/C/man2/sendfile.2:19 build/C/man2/set_tid_address.2:25 build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/futex.2:53 build/C/man2/getunwind.2:27 build/C/man2/kexec_load.2:26 build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:24 build/C/man2/nfsservctl.2:8 build/C/man2/outb.2:26 build/C/man2/pciconfig_read.2:8 build/C/man2/perf_event_open.2:27 build/C/man2/perfmonctl.2:27 build/C/man2/personality.2:32 build/C/man2/pivot_root.2:10 build/C/man2/process_vm_readv.2:29 build/C/man2/ptrace.2:44 build/C/man2/quotactl.2:27 build/C/man2/sendfile.2:19 build/C/man2/set_tid_address.2:25 build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:26 build/C/man2/futex.2:54 build/C/man2/get_robust_list.2:30 build/C/man2/getunwind.2:28 build/C/man2/kexec_load.2:27 build/C/man2/lookup_dcookie.2:28 build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:9 build/C/man2/outb.2:27 build/C/man2/pciconfig_read.2:9 build/C/man2/perf_event_open.2:28 build/C/man2/perfmonctl.2:28 build/C/man2/personality.2:33 build/C/man2/pivot_root.2:11 build/C/man2/process_vm_readv.2:30 build/C/man2/ptrace.2:45 build/C/man2/quotactl.2:28 build/C/man2/sendfile.2:20 build/C/man2/set_tid_address.2:26 build/C/man2/splice.2:27 build/C/man2/tee.2:27 build/C/man2/vm86.2:27 build/C/man2/vmsplice.2:27
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:28
msgid "arch_prctl - set architecture-specific thread state"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:28 build/C/man2/futex.2:56 build/C/man2/get_robust_list.2:32 build/C/man2/getunwind.2:30 build/C/man2/kexec_load.2:29 build/C/man2/lookup_dcookie.2:30 build/C/man2/modify_ldt.2:27 build/C/man2/nfsservctl.2:11 build/C/man2/outb.2:31 build/C/man2/pciconfig_read.2:11 build/C/man2/perf_event_open.2:30 build/C/man2/perfmonctl.2:30 build/C/man2/personality.2:35 build/C/man2/pivot_root.2:13 build/C/man2/process_vm_readv.2:32 build/C/man2/ptrace.2:47 build/C/man2/quotactl.2:30 build/C/man2/sendfile.2:22 build/C/man2/set_tid_address.2:28 build/C/man2/splice.2:29 build/C/man2/tee.2:29 build/C/man2/vm86.2:29 build/C/man2/vmsplice.2:29
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:31
#, no-wrap
msgid "B<#include E<lt>asm/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:33
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:36
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr ""

#.  Return type was long before glibc 2.7
#. type: SH
#: build/C/man2/arch_prctl.2:37 build/C/man2/futex.2:68 build/C/man2/get_robust_list.2:44 build/C/man2/getunwind.2:40 build/C/man2/kexec_load.2:39 build/C/man2/lookup_dcookie.2:32 build/C/man2/modify_ldt.2:36 build/C/man2/nfsservctl.2:18 build/C/man2/outb.2:62 build/C/man2/pciconfig_read.2:22 build/C/man2/perf_event_open.2:42 build/C/man2/perfmonctl.2:39 build/C/man2/personality.2:39 build/C/man2/pivot_root.2:18 build/C/man2/process_vm_readv.2:50 build/C/man2/ptrace.2:54 build/C/man2/quotactl.2:38 build/C/man2/sendfile.2:47 build/C/man2/set_tid_address.2:34 build/C/man2/splice.2:39 build/C/man2/tee.2:38 build/C/man2/vm86.2:35 build/C/man2/vmsplice.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:52
msgid ""
"The B<arch_prctl>()  function sets architecture-specific process or thread "
"state.  I<code> selects a subfunction and passes argument I<addr> to it; "
"I<addr> is interpreted as either an I<unsigned long> for the \"set\" "
"operations, or as an I<unsigned long *>, for the \"get\" operations."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:54
msgid "Sub functions for x86-64 are:"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:54
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:60
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:60
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:68
msgid ""
"Return the 64-bit base value for the I<FS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:68
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:74
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:74
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:82
msgid ""
"Return the 64-bit base value for the I<GS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:82 build/C/man2/futex.2:209 build/C/man2/get_robust_list.2:77 build/C/man2/getunwind.2:81 build/C/man2/kexec_load.2:114 build/C/man2/lookup_dcookie.2:43 build/C/man2/modify_ldt.2:98 build/C/man2/nfsservctl.2:51 build/C/man2/pciconfig_read.2:50 build/C/man2/perf_event_open.2:1804 build/C/man2/perfmonctl.2:190 build/C/man2/personality.2:57 build/C/man2/pivot_root.2:101 build/C/man2/process_vm_readv.2:209 build/C/man2/ptrace.2:1713 build/C/man2/sendfile.2:108 build/C/man2/set_tid_address.2:88 build/C/man2/splice.2:127 build/C/man2/tee.2:85 build/C/man2/vm86.2:52 build/C/man2/vmsplice.2:113
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:88
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:88 build/C/man2/futex.2:234 build/C/man2/get_robust_list.2:84 build/C/man2/getunwind.2:88 build/C/man2/kexec_load.2:121 build/C/man2/lookup_dcookie.2:50 build/C/man2/modify_ldt.2:108 build/C/man2/pciconfig_read.2:77 build/C/man2/perf_event_open.2:1810 build/C/man2/personality.2:64 build/C/man2/pivot_root.2:105 build/C/man2/process_vm_readv.2:229 build/C/man2/ptrace.2:1727 build/C/man2/quotactl.2:427 build/C/man2/sendfile.2:115 build/C/man2/set_tid_address.2:91 build/C/man2/splice.2:142 build/C/man2/tee.2:100 build/C/man2/vm86.2:57 build/C/man2/vmsplice.2:122
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:89 build/C/man2/futex.2:249 build/C/man2/get_robust_list.2:111 build/C/man2/lookup_dcookie.2:51 build/C/man2/modify_ldt.2:109 build/C/man2/process_vm_readv.2:251 build/C/man2/process_vm_readv.2:256 build/C/man2/ptrace.2:1731 build/C/man2/quotactl.2:428 build/C/man2/sendfile.2:125 build/C/man2/vm86.2:58
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:93
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:93 build/C/man2/futex.2:261 build/C/man2/get_robust_list.2:88 build/C/man2/kexec_load.2:126 build/C/man2/lookup_dcookie.2:54 build/C/man2/modify_ldt.2:113 build/C/man2/pciconfig_read.2:78 build/C/man2/perf_event_open.2:1811 build/C/man2/personality.2:65 build/C/man2/pivot_root.2:114 build/C/man2/process_vm_readv.2:230 build/C/man2/process_vm_readv.2:241 build/C/man2/process_vm_readv.2:245 build/C/man2/ptrace.2:1742 build/C/man2/quotactl.2:434 build/C/man2/quotactl.2:501 build/C/man2/sendfile.2:128 build/C/man2/splice.2:147 build/C/man2/tee.2:101 build/C/man2/vmsplice.2:127
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:97
msgid "I<code> is not a valid subcommand."
msgstr ""

#. type: TP
#: build/C/man2/arch_prctl.2:97 build/C/man2/get_robust_list.2:98 build/C/man2/kexec_load.2:133 build/C/man2/lookup_dcookie.2:65 build/C/man2/pciconfig_read.2:105 build/C/man2/pivot_root.2:120 build/C/man2/process_vm_readv.2:267 build/C/man2/ptrace.2:1752 build/C/man2/quotactl.2:456 build/C/man2/vm86.2:66
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: build/C/man2/arch_prctl.2:103
msgid "I<addr> is outside the process address space."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:103 build/C/man2/futex.2:296 build/C/man2/getunwind.2:96 build/C/man2/kexec_load.2:142 build/C/man2/lookup_dcookie.2:78 build/C/man2/modify_ldt.2:130 build/C/man2/nfsservctl.2:56 build/C/man2/outb.2:87 build/C/man2/pciconfig_read.2:110 build/C/man2/perf_event_open.2:1829 build/C/man2/perfmonctl.2:199 build/C/man2/personality.2:68 build/C/man2/pivot_root.2:128 build/C/man2/process_vm_readv.2:279 build/C/man2/ptrace.2:1770 build/C/man2/sendfile.2:148 build/C/man2/set_tid_address.2:97 build/C/man2/splice.2:170 build/C/man2/tee.2:119 build/C/man2/vm86.2:71 build/C/man2/vmsplice.2:143
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:107
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:107 build/C/man2/futex.2:298 build/C/man2/get_robust_list.2:119 build/C/man2/getunwind.2:99 build/C/man2/kexec_load.2:144 build/C/man2/lookup_dcookie.2:81 build/C/man2/modify_ldt.2:133 build/C/man2/perf_event_open.2:1834 build/C/man2/perfmonctl.2:202 build/C/man2/pivot_root.2:131 build/C/man2/process_vm_readv.2:281 build/C/man2/ptrace.2:1772 build/C/man2/sendfile.2:155 build/C/man2/splice.2:172 build/C/man2/tee.2:121 build/C/man2/vmsplice.2:145
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:110
msgid ""
"B<arch_prctl>()  is only supported on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:112
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:115
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:130
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  It may be a "
"faster alternative to set a 32-bit base using a segment selector by setting "
"up an LDT with B<modify_ldt>(2)  or using the B<set_thread_area>(2)  system "
"call in kernel 2.5 or later.  B<arch_prctl>()  is only needed when you want "
"to set bases that are larger than 4GB.  Memory in the first 2GB of address "
"space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:135
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:138
msgid "I<FS> may be already used by the threading library."
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:138 build/C/man2/futex.2:312 build/C/man2/get_robust_list.2:128 build/C/man2/getunwind.2:111 build/C/man2/kexec_load.2:159 build/C/man2/modify_ldt.2:136 build/C/man2/outb.2:96 build/C/man2/pciconfig_read.2:112 build/C/man2/perf_event_open.2:1948 build/C/man2/perfmonctl.2:205 build/C/man2/pivot_root.2:143 build/C/man2/process_vm_readv.2:331 build/C/man2/ptrace.2:1926 build/C/man2/quotactl.2:507 build/C/man2/sendfile.2:197 build/C/man2/set_tid_address.2:99 build/C/man2/splice.2:226 build/C/man2/tee.2:197 build/C/man2/vmsplice.2:154
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:143
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:145
msgid "AMD X86-64 Programmer's manual"
msgstr ""

#. type: SH
#: build/C/man2/arch_prctl.2:145 build/C/man2/futex.2:325 build/C/man2/get_robust_list.2:137 build/C/man2/getunwind.2:113 build/C/man2/kexec_load.2:162 build/C/man2/lookup_dcookie.2:88 build/C/man2/modify_ldt.2:138 build/C/man2/nfsservctl.2:58 build/C/man2/outb.2:99 build/C/man2/pciconfig_read.2:114 build/C/man2/perf_event_open.2:1954 build/C/man2/perfmonctl.2:209 build/C/man2/personality.2:72 build/C/man2/pivot_root.2:149 build/C/man2/process_vm_readv.2:334 build/C/man2/ptrace.2:1940 build/C/man2/quotactl.2:512 build/C/man2/sendfile.2:203 build/C/man2/set_tid_address.2:102 build/C/man2/splice.2:230 build/C/man2/tee.2:200 build/C/man2/vm86.2:74 build/C/man2/vmsplice.2:157
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:152 build/C/man2/futex.2:332 build/C/man2/get_robust_list.2:144 build/C/man2/getunwind.2:120 build/C/man2/kexec_load.2:169 build/C/man2/lookup_dcookie.2:95 build/C/man2/modify_ldt.2:145 build/C/man2/nfsservctl.2:65 build/C/man2/outb.2:106 build/C/man2/pciconfig_read.2:121 build/C/man2/perf_event_open.2:1961 build/C/man2/perfmonctl.2:216 build/C/man2/personality.2:79 build/C/man2/pivot_root.2:156 build/C/man2/process_vm_readv.2:341 build/C/man2/ptrace.2:1947 build/C/man2/quotactl.2:519 build/C/man2/sendfile.2:210 build/C/man2/set_tid_address.2:109 build/C/man2/splice.2:237 build/C/man2/tee.2:207 build/C/man2/vm86.2:81 build/C/man2/vmsplice.2:164
msgid ""
"This page is part of release 3.50 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/futex.2:53
#, no-wrap
msgid "FUTEX"
msgstr ""

#. type: TH
#: build/C/man2/futex.2:53
#, no-wrap
msgid "2013-03-15"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:56
msgid "futex - fast user-space locking"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:61
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:64
#, no-wrap
msgid ""
"B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct "
"timespec *>I<timeout>B<,>\n"
msgstr ""

#.  int *? void *? u32 *?
#. type: Plain text
#: build/C/man2/futex.2:67
#, no-wrap
msgid "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:84
msgid ""
"The B<futex>()  system call provides a method for a program to wait for a "
"value at a given address to change, and a method to wake up anyone waiting "
"on a particular address (while the addresses for the same memory in separate "
"processes may not be equal, the kernel maps them internally so the same "
"memory mapped in different locations will correspond for B<futex>()  "
"calls).  This system call is typically used to implement the contended case "
"of a lock in shared memory, as described in B<futex>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:91
msgid ""
"When a B<futex>(7)  operation did not finish uncontended in user space, a "
"call needs to be made to the kernel to arbitrate.  Arbitration can either "
"mean putting the calling process to sleep or, conversely, waking a waiting "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:98
msgid ""
"Callers of this function are expected to adhere to the semantics as set out "
"in B<futex>(7).  As these semantics involve writing nonportable assembly "
"instructions, this in turn probably means that most users will in fact be "
"library authors and not general application developers."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:106
msgid ""
"The I<uaddr> argument needs to point to an aligned integer which stores the "
"counter.  The operation to execute is passed via the I<op> argument, along "
"with a value I<val>."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:108
msgid "Five operations are currently defined:"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:108 build/C/man2/futex.2:216
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:126
msgid ""
"This operation atomically verifies that the futex address I<uaddr> still "
"contains the value I<val>, and sleeps awaiting B<FUTEX_WAKE> on this futex "
"address.  If the I<timeout> argument is non-NULL, its contents describe the "
"minimum duration of the wait, which is infinite otherwise.  The arguments "
"I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:134
msgid ""
"For B<futex>(7), this call is executed if decrementing the count gave a "
"negative value (indicating contention), and will sleep until another process "
"releases the futex and executes the B<FUTEX_WAKE> operation."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:134 build/C/man2/futex.2:222
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:145
msgid ""
"This operation wakes at most I<val> processes waiting on this futex address "
"(i.e., inside B<FUTEX_WAIT>).  The arguments I<timeout>, I<uaddr2> and "
"I<val3> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:151
msgid ""
"For B<futex>(7), this is executed if incrementing the count showed that "
"there were waiters, once the futex value has been set to 1 (indicating that "
"it is available)."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:151
#, no-wrap
msgid "B<FUTEX_FD> (present up to and including Linux 2.6.25)"
msgstr ""

#.  , suitable for .BR poll (2).
#. type: Plain text
#: build/C/man2/futex.2:167
msgid ""
"To support asynchronous wakeups, this operation associates a file descriptor "
"with a futex.  If another process executes a B<FUTEX_WAKE>, the process will "
"receive the signal number that was passed in I<val>.  The calling process "
"must close the returned file descriptor after use.  The arguments "
"I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:172
msgid ""
"To prevent race conditions, the caller should test if the futex has been "
"upped after B<FUTEX_FD> returns."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:176
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:176
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.5.70)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:191
msgid ""
"This operation was introduced in order to avoid a \"thundering herd\" effect "
"when B<FUTEX_WAKE> is used and all processes woken up need to acquire "
"another futex.  This call wakes up I<val> processes, and requeues all other "
"waiters on the futex at address I<uaddr2>.  The arguments I<timeout> and "
"I<val3> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:191
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:209
msgid ""
"There was a race in the intended use of B<FUTEX_REQUEUE>, so "
"B<FUTEX_CMP_REQUEUE> was introduced.  This is similar to B<FUTEX_REQUEUE>, "
"but first checks whether the location I<uaddr> still contains the value "
"I<val3>.  If not, the operation fails with the error B<EAGAIN>.  The "
"argument I<timeout> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:216
msgid ""
"In the event of an error, all operations return -1, and set I<errno> to "
"indicate the error.  The return value on success depends on the operation, "
"as described in the following list:"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:222
msgid ""
"Returns 0 if the process was woken by a B<FUTEX_WAKE> call.  See ERRORS for "
"the various possible error returns."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:225 build/C/man2/futex.2:231 build/C/man2/futex.2:234
msgid "Returns the number of processes woken up."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:225
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:228
msgid "Returns the new file descriptor associated with the futex."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:228
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:231
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr ""

#. type: TP
#: build/C/man2/futex.2:235 build/C/man2/quotactl.2:486
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:238
msgid "No read access to futex memory."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:238 build/C/man2/sendfile.2:116
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:249
msgid ""
"B<FUTEX_CMP_REQUEUE> detected that the value pointed to by I<uaddr> is not "
"equal to the expected value I<val3>.  (This probably indicates a race; use "
"the safe B<FUTEX_WAKE> now.)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:254
msgid "Error retrieving I<timeout> information from user space."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:254
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:261
msgid ""
"A B<FUTEX_WAIT> operation was interrupted by a signal (see B<signal>(7))  or "
"a spurious wakeup."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:264
msgid "Invalid argument."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:264
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:267
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:267 build/C/man2/modify_ldt.2:126 build/C/man2/pciconfig_read.2:93 build/C/man2/quotactl.2:447 build/C/man2/vm86.2:62
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:271
msgid "Invalid operation specified in I<op>."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:271
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:276
msgid "Timeout during the B<FUTEX_WAIT> operation."
msgstr ""

#. type: TP
#: build/C/man2/futex.2:276
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:286
msgid ""
"I<op> was B<FUTEX_WAIT> and the value pointed to by I<uaddr> was not equal "
"to the expected value I<val> at the time of the call."
msgstr ""

#. type: SH
#: build/C/man2/futex.2:286 build/C/man2/get_robust_list.2:115 build/C/man2/getunwind.2:94 build/C/man2/kexec_load.2:138 build/C/man2/lookup_dcookie.2:73 build/C/man2/perfmonctl.2:196 build/C/man2/pivot_root.2:125 build/C/man2/process_vm_readv.2:276 build/C/man2/sendfile.2:142 build/C/man2/set_tid_address.2:94 build/C/man2/splice.2:165 build/C/man2/tee.2:114 build/C/man2/vmsplice.2:138
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:296
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A 4-argument system call with the semantics "
"described in this page was introduced in Linux 2.5.40.  In Linux 2.5.70 one "
"argument was added.  In Linux 2.6.7 a sixth argument was added\\(emmessy, "
"especially on the s390 architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:298 build/C/man2/kexec_load.2:144 build/C/man2/set_tid_address.2:99 build/C/man2/splice.2:172 build/C/man2/tee.2:121 build/C/man2/vmsplice.2:145
msgid "This system call is Linux-specific."
msgstr ""

#.  .SH "AUTHORS"
#.  .PP
#.  Futexes were designed and worked on by
#.  Hubertus Franke (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat)
#.  and Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: build/C/man2/futex.2:312
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end-users.  (There is no wrapper function for this system call in "
"glibc.)  Implementors are expected to be assembly literate and to have read "
"the sources of the futex user-space library referenced below."
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:314
msgid "B<futex>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:317
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:320
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:322
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr ""

#. type: Plain text
#: build/C/man2/futex.2:325
msgid ""
"E<.UR ftp://ftp.nl.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE>"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:29
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:29 build/C/man2/kexec_load.2:26 build/C/man2/modify_ldt.2:24 build/C/man2/pivot_root.2:10
#, no-wrap
msgid "2012-07-13"
msgstr ""

#. type: TH
#: build/C/man2/get_robust_list.2:29
#, no-wrap
msgid "Linux System Calls"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:32
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:36
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:40
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head "
"**>I<head_ptr>B<,>\n"
"B<\t\t\t  size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:44
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:49
msgid ""
"The robust futex implementation needs to maintain per-thread lists of robust "
"futexes which are unlocked when the thread exits.  These lists are managed "
"in user space; the kernel is only notified about the location of the head of "
"the list."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:65
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:77
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head "
"of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be "
"I<sizeof(*head)>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:84
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero "
"when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:88
msgid "The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:94
msgid ""
"I<len> does not match the size of structure B<struct robust_list_head> "
"expected by kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:98
msgid "The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:106
msgid ""
"The calling process does not have permission to see the robust futex list of "
"the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: TP
#: build/C/man2/get_robust_list.2:106 build/C/man2/process_vm_readv.2:271 build/C/man2/ptrace.2:1765 build/C/man2/quotactl.2:461 build/C/man2/quotactl.2:504
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:111
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:115
msgid "The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:119
msgid ""
"These system calls were added in Linux 2.6.17.  No library support is "
"provided; use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:124
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them "
"directly, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:128
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  .BR pthread_mutexattr_setrobust_np (3)
#. type: Plain text
#: build/C/man2/get_robust_list.2:131
msgid "B<futex>(2)"
msgstr ""

#.  http://lwn.net/Articles/172149/
#. type: Plain text
#: build/C/man2/get_robust_list.2:137
msgid ""
"I<Documentation/robust-futexes.txt> and "
"I<Documentation/robust-futex-ABI.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr ""

#. type: TH
#: build/C/man2/getunwind.2:27 build/C/man2/perfmonctl.2:27
#, no-wrap
msgid "2013-02-13"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:40 build/C/man2/kexec_load.2:39 build/C/man2/modify_ldt.2:36 build/C/man2/perf_event_open.2:42 build/C/man2/perfmonctl.2:39 build/C/man2/pivot_root.2:18
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:73
#, no-wrap
msgid ""
"\tu64 start;      (64-bit address of start of function)\n"
"\tu64 end;        (64-bit address of end of function)\n"
"\tu64 info;       (BUF-relative offset to unwind info)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:81
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:88
msgid ""
"On success, B<getunwind>()  returns the size of unwind table.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:94
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:96
msgid "This system call is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:99
msgid ""
"This system call is Linux specific, and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:107
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's "
"unwind data is via the gate DSO.  The address of the ELF header for this DSO "
"is passed to user level via B<AT_SYSINFO_EHDR> (see B<getauxval>(3))."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:111
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event "
"that you want to call it, use B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:113
msgid "B<getauxval>(3)"
msgstr ""

#. type: TH
#: build/C/man2/kexec_load.2:26
#, no-wrap
msgid "KEXEC_LOAD"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:29
msgid "kexec_load - load a new kernel for later execution"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:31
msgid "B<#include E<lt>linux/kexec.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:33
msgid ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long "
">I<nr_segments>B<,>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:36
msgid "B< struct kexec_segment *>I<segments>B<, unsigned long >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:44
msgid ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:50
msgid ""
"The I<flags> argument is a mask whose high-order bits control the operation "
"of the call.  The following values can be specified in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:50
#, no-wrap
msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgstr ""

#.  FIXME figure out how this is really used
#. type: Plain text
#: build/C/man2/kexec_load.2:54
msgid "Execute the new kernel automatically on a system crash."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:54
#, no-wrap
msgid "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.6.27)"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:64
msgid ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is only available "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is only "
"effective if I<nr_segments> is greater than 0."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:84
msgid ""
"The low-order bits of I<flags> contain the architecture of the "
"to-be-executed kernel.  Specify (OR) the constant B<KEXEC_ARCH_DEFAULT> to "
"use the current architecture, or one of the following architecture constants "
"B<KEXEC_ARCH_386>, B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, "
"B<KEXEC_ARCH_PPC64>, B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, "
"B<KEXEC_ARCH_S390>, B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and "
"B<KEXEC_ARCH_MIPS_LE>.  The architecture must be executable on the CPU of "
"the system."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:98
msgid ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:107
#, no-wrap
msgid ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"
msgstr ""

#.  FIXME elaborate on the following:
#. type: Plain text
#: build/C/man2/kexec_load.2:114
msgid ""
"The kernel image defined by I<segments> is copied from the calling process "
"into previously reserved memory."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:121
msgid ""
"On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/kexec_load.2:122 build/C/man2/pivot_root.2:110 build/C/man2/ptrace.2:1728 build/C/man2/quotactl.2:495
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:126
msgid ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."
msgstr ""

#.  KEXEC_SEGMENT_MAX == 16
#. type: Plain text
#: build/C/man2/kexec_load.2:133
msgid "I<flags> is invalid; or I<nr_segments> is too large"
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:138
msgid "The caller does not have the B<CAP_SYS_BOOT> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:142
msgid "The B<kexec_load>()  system call first appeared in Linux 2.6.13."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:149
msgid ""
"Currently, there is no glibc support for B<kexec_load>().  Call it using "
"B<syscall>(2)."
msgstr ""

#.  FIXME Andi submitted a patch for this.
#.  Check if it got accepted later.
#. type: Plain text
#: build/C/man2/kexec_load.2:156
msgid ""
"The required constants are in the Linux kernel source file I<linux/kexec.h>, "
"which is not currently exported to glibc.  Therefore, these constants must "
"be defined manually."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:159
msgid ""
"This system call is only available if the kernel was configured with "
"B<CONFIG_KEXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/kexec_load.2:162
msgid "B<reboot>(2), B<syscall>(2)"
msgstr ""

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "LOOKUP_DCOOKIE"
msgstr ""

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "2004-06-17"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:30
msgid "lookup_dcookie - return a directory entry's path"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:32
msgid ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t "
">I<len>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:38
msgid ""
"Look up the full path of the directory entry specified by the value "
"I<cookie>.  The cookie is an opaque identifier uniquely identifying a "
"particular directory entry.  The buffer given is filled in with the full "
"path of the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:43
msgid ""
"For B<lookup_dcookie>()  to return successfully, the kernel must still hold "
"a cookie reference to the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:50
msgid ""
"On success, B<lookup_dcookie>()  returns the length of the path string "
"copied into the buffer.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:54
msgid "The buffer was not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:58
msgid ""
"The kernel has no registered cookie/directory entry mappings at the time of "
"lookup, or the cookie does not refer to a valid directory entry."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:58
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:61
msgid "The name could not fit in the buffer."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:61 build/C/man2/process_vm_readv.2:262 build/C/man2/sendfile.2:138 build/C/man2/splice.2:155 build/C/man2/tee.2:111 build/C/man2/vmsplice.2:135
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:65
msgid ""
"The kernel could not allocate memory for the temporary buffer holding the "
"path."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:70
msgid ""
"The process does not have the capability B<CAP_SYS_ADMIN> required to look "
"up cookie values."
msgstr ""

#. type: TP
#: build/C/man2/lookup_dcookie.2:70 build/C/man2/quotactl.2:474
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:73
msgid "The buffer was not large enough to hold the path of the directory entry."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:78
msgid ""
"Available since Linux 2.5.43.  The B<ENAMETOOLONG> error return was added in "
"2.5.70."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:81
msgid "B<lookup_dcookie>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:85
msgid ""
"B<lookup_dcookie>()  is a special-purpose system call, currently used only "
"by the oprofile profiler.  It relies on a kernel driver to register cookies "
"for directory entries."
msgstr ""

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:88
msgid ""
"The path returned may be suffixed by the string \" (deleted)\" if the "
"directory entry has been removed."
msgstr ""

#. type: TH
#: build/C/man2/modify_ldt.2:24
#, no-wrap
msgid "MODIFY_LDT"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:27
msgid "modify_ldt - get or set ldt"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:30
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:32
#, no-wrap
msgid ""
"B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long "
">I<bytecount>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:41
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (ldt) for a "
"process.  The ldt is a per-process memory management table used by the i386 "
"processor.  For more information on this table, see an Intel 386 processor "
"handbook."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:51
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the ldt into the memory pointed to "
"by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the "
"actual size of the ldt."
msgstr ""

#
#.  FIXME ? say something about func == 2 and func == 0x11?
#.  In Linux 2.4, func == 2 returned "the default ldt"
#.  In Linux 2.6, func == 2 is a nop, returning a zeroed out structure.
#.  Linux 2.4 and 2.6 implement an operation for func == 0x11
#. type: Plain text
#: build/C/man2/modify_ldt.2:69
msgid ""
"When I<func> is 1, B<modify_ldt>()  modifies one ldt entry.  I<ptr> points "
"to a I<user_desc> structure and I<bytecount> must equal the size of this "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:73
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:87
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""

#.  .PP
#.  The ldt is specific for the calling process. Any attempts to change
#.  the ldt to include the address space of another process or the kernel
#.  will result in a segmentation violation when trying to access the memory
#.  outside of the process address space. The memory protection is enforced
#.  at the paging layer.
#. type: Plain text
#: build/C/man2/modify_ldt.2:98
msgid "In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:108
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:113
msgid "I<ptr> points outside the address space."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:126
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<modify_ldt_ldt_s>, or I<func> is 1 and the new ldt entry has "
"invalid values."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:130
msgid "I<func> is neither 0 nor 1."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:133
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:136 build/C/man2/perfmonctl.2:205 build/C/man2/pivot_root.2:134
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/modify_ldt.2:138
msgid "B<vm86>(2)"
msgstr ""

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "NFSSERVCTL"
msgstr ""

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "2012-03-05"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:11
msgid "nfsservctl - syscall interface to kernel nfs daemon"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:14
#, no-wrap
msgid "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:17
#, no-wrap
msgid ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:21
msgid "I<Note>: Since Linux 3.1, this system call no longer exists."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:33
#, no-wrap
msgid ""
"/*\n"
" * These are the commands understood by nfsctl().\n"
" */\n"
"#define NFSCTL_SVC          0    /* This is a server process. */\n"
"#define NFSCTL_ADDCLIENT    1    /* Add an NFS client. */\n"
"#define NFSCTL_DELCLIENT    2    /* Remove an NFS client. */\n"
"#define NFSCTL_EXPORT       3    /* export a file system. */\n"
"#define NFSCTL_UNEXPORT     4    /* unexport a file system. */\n"
"#define NFSCTL_UGIDUPDATE   5    /* update a client's UID/GID map. */\n"
"#define NFSCTL_GETFH        6    /* get an fh (used by mountd) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:45
#, no-wrap
msgid ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:50
#, no-wrap
msgid ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:56 build/C/man2/pivot_root.2:105 build/C/man2/vm86.2:57
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:58
msgid "This call is Linux-specific."
msgstr ""

#. type: TH
#: build/C/man2/outb.2:26
#, no-wrap
msgid "OUTB"
msgstr ""

#. type: TH
#: build/C/man2/outb.2:26
#, no-wrap
msgid "2012-12-31"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:31
msgid ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - port I/O"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:34
#, no-wrap
msgid "B<#include E<lt>sys/io.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:41
#, no-wrap
msgid ""
"B<unsigned char inb(unsigned short int >I<port>B<);>\n"
"B<unsigned char inb_p(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw_p(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl_p(unsigned short int >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:48
#, no-wrap
msgid ""
"B<void outb(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outb_p(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outw(unsigned short int >I<value>B<, unsigned short int "
">I<port>B<);>\n"
"B<void outw_p(unsigned short int >I<value>B<, unsigned short int "
">I<port>B<);>\n"
"B<void outl(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outl_p(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:61
#, no-wrap
msgid ""
"B<void insb(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insw(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insl(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsb(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsw(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsl(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:67
msgid ""
"This family of functions is used to do low-level port input and output.  The "
"out* functions do port output, the in* functions do port input; the b-suffix "
"functions are byte-width and the w-suffix functions word-width; the "
"_p-suffix functions pause until the I/O completes."
msgstr ""

#.  , given the following information
#.  in addition to that given in
#.  .BR outb (9).
#. type: Plain text
#: build/C/man2/outb.2:73
msgid ""
"They are primarily designed for internal kernel use, but can be used from "
"user space."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:78
msgid ""
"You must compile with B<-O> or B<-O2> or similar.  The functions are defined "
"as inline macros, and will not be substituted in without optimization "
"enabled, causing unresolved references at link time."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:87
msgid ""
"You use B<ioperm>(2)  or alternatively B<iopl>(2)  to tell the kernel to "
"allow the user space application to access the I/O ports in question.  "
"Failure to do this will cause the application to receive a segmentation "
"fault."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:96
msgid ""
"B<outb>()  and friends are hardware-specific.  The I<value> argument is "
"passed first and the I<port> argument is passed second, which is the "
"opposite order from most DOS implementations."
msgstr ""

#. type: Plain text
#: build/C/man2/outb.2:99
msgid "B<ioperm>(2), B<iopl>(2)"
msgstr ""

#. type: TH
#: build/C/man2/pciconfig_read.2:8
#, no-wrap
msgid "PCICONFIG_READ"
msgstr ""

#. type: TH
#: build/C/man2/pciconfig_read.2:8
#, no-wrap
msgid "2003-07-14"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:11
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:14
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:21
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void "
"*>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:27
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"user space."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:27 build/C/man2/pciconfig_read.2:51
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:36
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:36 build/C/man2/pciconfig_read.2:57
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:45
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:45 build/C/man2/pciconfig_read.2:63
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:50
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:57 build/C/man2/pciconfig_read.2:63
msgid ""
"On success zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:77
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:84
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:84 build/C/man2/ptrace.2:1745 build/C/man2/sendfile.2:134
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:87
msgid "I/O error."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:87
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:93
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:98
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""

#. type: TP
#: build/C/man2/pciconfig_read.2:98
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:105
msgid ""
"This return value is only valid for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:110
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:112
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""

#. type: Plain text
#: build/C/man2/pciconfig_read.2:114
msgid "B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/perf_event_open.2:27
#, no-wrap
msgid "PERF_EVENT_OPEN"
msgstr ""

#. type: TH
#: build/C/man2/perf_event_open.2:27
#, no-wrap
msgid "2013-02-04"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:30
msgid "perf_event_open - set up performance monitoring"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:38
#, no-wrap
msgid ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:47
msgid ""
"Given a list of parameters, B<perf_event_open>()  returns a file descriptor, "
"for use in subsequent system calls (B<read>(2), B<mmap>(2), B<prctl>(2), "
"B<fcntl>(2), etc.)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:55
msgid ""
"A call to B<perf_event_open>()  creates a file descriptor that allows "
"measuring performance information.  Each file descriptor corresponds to one "
"event that is measured; these can be grouped together to measure multiple "
"events simultaneously."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:62
msgid ""
"Events can be enabled and disabled in two ways: via B<ioctl>(2)  and via "
"B<prctl>(2)B<.> When an event is disabled it does not count or generate "
"overflows but does continue to exist and maintain its count value."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:76
msgid ""
"Events come in two flavors: counting and sampled.  A I<counting> event is "
"one that is used for counting the aggregate number of events that occur.  In "
"general, counting event results are gathered with a B<read>(2)  call.  A "
"I<sampling> event periodically writes measurements to a buffer that can then "
"be accessed via B<mmap>(2)B<.>"
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:76
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:90
msgid ""
"The argument I<pid> allows events to be attached to processes in various "
"ways.  If I<pid> is 0, measurements happen on the current thread, if I<pid> "
"is greater than 0, the process indicated by I<pid> is measured, and if "
"I<pid> is -1, all processes are counted."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:101
msgid ""
"The I<cpu> argument allows measurements to be specific to a CPU.  If I<cpu> "
"is greater than or equal to 0, measurements are restricted to the specified "
"CPU; if I<cpu> is -1, the events are measured on all CPUs."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:107
msgid "Note that the combination of I<pid> == -1 and I<cpu> == -1 is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:115
msgid ""
"A I<pid> E<gt> 0 and I<cpu> == -1 setting measures per-process and follows "
"that process to whatever CPU the process gets scheduled to.  Per-process "
"events can be created by any user."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:126
msgid ""
"A I<pid> == -1 and I<cpu> E<gt>= 0 setting is per-CPU and measures all "
"processes on the specified CPU.  Per-CPU events need the B<CAP_SYS_ADMIN> "
"capability or a I</proc/sys/kernel/perf_event_paranoid> value of less than "
"1."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:148
msgid ""
"The I<group_fd> argument allows event groups to be created.  An event group "
"has one event which is the group leader.  The leader is created first, with "
"I<group_fd> = -1.  The rest of the group members are created with subsequent "
"B<perf_event_open>()  calls with I<group_fd> being set to the fd of the "
"group leader.  (A single event on its own is created with I<group_fd> = -1 "
"and is considered to be a group with only 1 member.)  An event group is "
"scheduled onto the CPU as a unit: it will only be put onto the CPU if all of "
"the events in the group can be put onto the CPU.  This means that the values "
"of the member events can be meaningfully compared, added, divided (to get "
"ratios), etc., with each other, since they have counted events for the same "
"set of executed instructions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:152
msgid "The I<flags> argument takes one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:152
#, no-wrap
msgid "B<PERF_FLAG_FD_NO_GROUP>"
msgstr ""

#.  FIXME The following sentence is unclear
#.  FIXME So, why is it useful?
#. type: Plain text
#: build/C/man2/perf_event_open.2:159
msgid ""
"This flag allows creating an event as part of an event group but having no "
"group leader.  It is unclear why this is useful."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:159
#, no-wrap
msgid "B<PERF_FLAG_FD_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:162
msgid "This flag re-routes the output from an event to the group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:162
#, no-wrap
msgid "B<PERF_FLAG_PID_CGROUP> (Since Linux 2.6.39)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:185
msgid ""
"This flag activates per-container system-wide monitoring.  A container is an "
"abstraction that isolates a set of resources for finer grain control (CPUs, "
"memory, etc...).  In this mode, the event is measured only if the thread "
"running on the monitored CPU belongs to the designated container (cgroup).  "
"The cgroup is identified by passing a file descriptor opened on its "
"directory in the cgroupfs filesystem.  For instance, if the cgroup to "
"monitor is called I<test>, then a file descriptor opened on "
"I</dev/cgroup/test> (assuming cgroupfs is mounted on I</dev/cgroup>)  must "
"be passed as the I<pid> parameter.  cgroup monitoring is only available for "
"system-wide events and may therefore require extra permissions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:190
msgid ""
"The I<perf_event_attr> structure provides detailed configuration information "
"for the event being created."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:197
#, no-wrap
msgid ""
"struct perf_event_attr {\n"
"    __u32     type;         /* Type of event */\n"
"    __u32     size;         /* Size of attribute structure */\n"
"    __u64     config;       /* Type-specific configuration */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:202
#, no-wrap
msgid ""
"    union {\n"
"        __u64 sample_period;    /* Period of sampling */\n"
"        __u64 sample_freq;      /* Frequency of sampling */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:205
#, no-wrap
msgid ""
"    __u64     sample_type;  /* Specifies values included in sample */\n"
"    __u64     read_format;  /* Specifies values returned in read */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:231
#, no-wrap
msgid ""
"    __u64     disabled       : 1,   /* off by default */\n"
"              inherit        : 1,   /* children inherit it */\n"
"              pinned         : 1,   /* must always be on PMU */\n"
"              exclusive      : 1,   /* only group on PMU */\n"
"              exclude_user   : 1,   /* don't count user */\n"
"              exclude_kernel : 1,   /* don't count kernel */\n"
"              exclude_hv     : 1,   /* don't count hypervisor */\n"
"              exclude_idle   : 1,   /* don't count when idle */\n"
"              mmap           : 1,   /* include mmap data */\n"
"              comm           : 1,   /* include comm data */\n"
"              freq           : 1,   /* use freq, not period */\n"
"              inherit_stat   : 1,   /* per task counts */\n"
"              enable_on_exec : 1,   /* next exec enables */\n"
"              task           : 1,   /* trace fork/exit */\n"
"              watermark      : 1,   /* wakeup_watermark */\n"
"              precise_ip     : 2,   /* skid constraint */\n"
"              mmap_data      : 1,   /* non-exec mmap data */\n"
"              sample_id_all  : 1,   /* sample_type all events */\n"
"              exclude_host   : 1,   /* don't count in host */\n"
"              exclude_guest  : 1,   /* don't count in guest */\n"
"              exclude_callchain_kernel : 1,\n"
"                                    /* exclude kernel callchains */\n"
"              exclude_callchain_user   : 1,\n"
"\t                            /* exclude user callchains */\n"
"              __reserved_1   : 41;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:236
#, no-wrap
msgid ""
"    union {\n"
"        __u32 wakeup_events;    /* wakeup every n events */\n"
"        __u32 wakeup_watermark; /* bytes before wakeup */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:238
#, no-wrap
msgid "    __u32     bp_type;          /* breakpoint type */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:243
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_addr;          /* breakpoint address */\n"
"        __u64 config1;          /* extension of config */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:253
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_len;           /* breakpoint length */\n"
"        __u64 config2;          /* extension of config1 */\n"
"    };\n"
"    __u64   branch_sample_type; /* enum perf_branch_sample_type */\n"
"    __u64   sample_regs_user;   /* user regs to dump on samples */\n"
"    __u32   sample_stack_user;  /* size of stack to dump on\n"
"                                   samples */\n"
"    __u32   __reserved_2;       /* Align to u64 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:255
#, no-wrap
msgid "};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:261
msgid ""
"The fields of the I<perf_event_attr> structure are described in more detail "
"below:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:261 build/C/man2/perf_event_open.2:1272
#, no-wrap
msgid "I<type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:265
msgid ""
"This field specifies the overall event type.  It has one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:266
#, no-wrap
msgid "B<PERF_TYPE_HARDWARE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:273
msgid ""
"This indicates one of the \"generalized\" hardware events provided by the "
"kernel.  See the I<config> field definition for more details."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:273
#, no-wrap
msgid "B<PERF_TYPE_SOFTWARE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:277
msgid ""
"This indicates one of the software-defined events provided by the kernel "
"(even if no hardware support is available)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:277
#, no-wrap
msgid "B<PERF_TYPE_TRACEPOINT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:281
msgid ""
"This indicates a tracepoint provided by the kernel tracepoint "
"infrastructure."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:281
#, no-wrap
msgid "B<PERF_TYPE_HW_CACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:287
msgid ""
"This indicates a hardware cache event.  This has a special encoding, "
"described in the I<config> field definition."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:287
#, no-wrap
msgid "B<PERF_TYPE_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:291
msgid ""
"This indicates a \"raw\" implementation-specific event in the I<config> "
"field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:291
#, no-wrap
msgid "B<PERF_TYPE_BREAKPOINT> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:296
msgid ""
"This indicates a hardware breakpoint as provided by the CPU.  Breakpoints "
"can be read/write accesses to an address as well as execution of an "
"instruction address."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:296
#, no-wrap
msgid "dynamic PMU"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:315
msgid ""
"Since Linux 2.6.39, B<perf_event_open>()  can support multiple PMUs.  To "
"enable this, a value exported by the kernel can be used in the I<type> field "
"to indicate which PMU to use.  The value to use can be found in the sysfs "
"filesystem: there is a subdirectory per PMU instance under "
"I</sys/bus/event_source/devices>.  In each sub-directory there is a I<type> "
"file whose content is an integer that can be used in the I<type> field.  For "
"instance, I</sys/bus/event_source/devices/cpu/type> contains the value for "
"the core CPU PMU, which is usually 4."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:316 build/C/man2/perf_event_open.2:1588
#, no-wrap
msgid "I<size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:325
msgid ""
"The size of the I<perf_event_attr> structure for forward/backward "
"compatibility.  Set this using I<sizeof(struct perf_event_attr)> to allow "
"the kernel to see the struct size at the time of compilation."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:340
msgid ""
"The related define B<PERF_ATTR_SIZE_VER0> is set to 64; this was the size of "
"the first published struct.  B<PERF_ATTR_SIZE_VER1> is 72, corresponding to "
"the addition of breakpoints in Linux 2.6.33.  B<PERF_ATTR_SIZE_VER2> is 80 "
"corresponding to the addition of branch sampling in Linux 3.4.  "
"B<PERF_ATR_SIZE_VER3> is 96 corresponding to the addition of "
"I<sample_regs_user> and I<sample_stack_user> in Linux 3.7."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:340
#, no-wrap
msgid "I<config>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:351
msgid ""
"This specifies which event you want, in conjunction with the I<type> field.  "
"The I<config1> and I<config2> fields are also taken into account in cases "
"where 64 bits is not enough to fully specify the event.  The encoding of "
"these fields are event dependent."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:357
msgid ""
"The most significant bit (bit 63) of I<config> signifies CPU-specific (raw) "
"counter configuration data; if the most significant bit is unset, the next 7 "
"bits are an event type and the rest of the bits are the event identifier."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:368
msgid ""
"There are various ways to set the I<config> field that are dependent on the "
"value of the previously described I<type> field.  What follows are various "
"possible settings for I<config> separated out by I<type>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:378
msgid ""
"If I<type> is B<PERF_TYPE_HARDWARE>, we are measuring one of the generalized "
"hardware CPU events.  Not all of these are available on all platforms.  Set "
"I<config> to one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:379
#, no-wrap
msgid "B<PERF_COUNT_HW_CPU_CYCLES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:383
msgid "Total cycles.  Be wary of what happens during CPU frequency scaling"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:383
#, no-wrap
msgid "B<PERF_COUNT_HW_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:388
msgid ""
"Retired instructions.  Be careful, these can be affected by various issues, "
"most notably hardware interrupt counts"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:388
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_REFERENCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:395
msgid ""
"Cache accesses.  Usually this indicates Last Level Cache accesses but this "
"may vary depending on your CPU.  This may include prefetches and coherency "
"messages; again this depends on the design of your CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:395
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_MISSES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:402
msgid ""
"Cache misses.  Usually this indicates Last Level Cache misses; this is "
"intended to be used in conjunction with the "
"B<PERF_COUNT_HW_CACHE_REFERENCES> event to calculate cache miss rates."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:402
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:407
msgid ""
"Retired branch instructions.  Prior to Linux 2.6.34, this used the wrong "
"event on AMD processors."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:407
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_MISSES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:410
msgid "Mispredicted branch instructions."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:410
#, no-wrap
msgid "B<PERF_COUNT_HW_BUS_CYCLES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:413
msgid "Bus cycles, which can be different from total cycles."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:413
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (Since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:416
msgid "Stalled cycles during issue."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:416
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (Since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:419
msgid "Stalled cycles during retirement."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:419
#, no-wrap
msgid "B<PERF_COUNT_HW_REF_CPU_CYCLES> (Since Linux 3.3)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:422
msgid "Total cycles; not affected by CPU frequency scaling."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:432
msgid ""
"If I<type> is B<PERF_TYPE_SOFTWARE>, we are measuring software events "
"provided by the kernel.  Set I<config> to one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:433
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_CLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:436
msgid "This reports the CPU clock, a high-resolution per-CPU timer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:436
#, no-wrap
msgid "B<PERF_COUNT_SW_TASK_CLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:439
msgid "This reports a clock count specific to the task that is running."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:439
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:442
msgid "This reports the number of page faults."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:442
#, no-wrap
msgid "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:447
msgid ""
"This counts context switches.  Until Linux 2.6.34, these were all reported "
"as user-space events, after that they are reported as happening in the "
"kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:447
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_MIGRATIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:451
msgid "This reports the number of times the process has migrated to a new CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:451
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:455
msgid ""
"This counts the number of minor page faults.  These did not require disk I/O "
"to handle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:455
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:459
msgid ""
"This counts the number of major page faults.  These required disk I/O to "
"handle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:459
#, no-wrap
msgid "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:465
msgid ""
"This counts the number of alignment faults.  These happen when unaligned "
"memory accesses happen; the kernel can handle these but it reduces "
"performance.  This only happens on some architectures (never on x86)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:465
#, no-wrap
msgid "B<PERF_COUNT_SW_EMULATION_FAULTS> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:471
msgid ""
"This counts the number of emulation faults.  The kernel sometimes traps on "
"unimplemented instructions and emulates them for user space.  This can "
"negatively impact performance."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:484
msgid ""
"If I<type> is B<PERF_TYPE_TRACEPOINT>, then we are measuring kernel "
"tracepoints.  The value to use in I<config> can be obtained from under "
"debugfs I<tracing/events/*/*/id> if ftrace is enabled in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:495
msgid ""
"If I<type> is B<PERF_TYPE_HW_CACHE>, then we are measuring a hardware CPU "
"cache event.  To calculate the appropriate I<config> value use the following "
"equation:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:500
#, no-wrap
msgid ""
"    (perf_hw_cache_id) | (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"    (perf_hw_cache_op_result_id E<lt>E<lt> 16)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:505
msgid "where I<perf_hw_cache_id> is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:506
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1D>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:509
msgid "for measuring Level 1 Data Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:509
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1I>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:512
msgid "for measuring Level 1 Instruction Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:512
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_LL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:515
msgid "for measuring Last-Level Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:515
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_DTLB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:518
msgid "for measuring the Data TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:518
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_ITLB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:521
msgid "for measuring the Instruction TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:521
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_BPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:524
msgid "for measuring the branch prediction unit"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:524
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_NODE> (Since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:527
msgid "for measuring local memory accesses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:532
msgid "and I<perf_hw_cache_op_id> is one of"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:533
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:536
msgid "for read accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:536
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:539
msgid "for write accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:539
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:542
msgid "for prefetch accesses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:547
msgid "and I<perf_hw_cache_op_result_id> is one of"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:548
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:551
msgid "to measure accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:551
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:554
msgid "to measure misses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:572
msgid ""
"If I<type> is B<PERF_TYPE_RAW>, then a custom \"raw\" I<config> value is "
"needed.  Most CPUs support events that are not covered by the "
"\"generalized\" events.  These are implementation defined; see your CPU "
"manual (for example the Intel Volume 3B documentation or the AMD BIOS and "
"Kernel Developer Guide).  The libpfm4 library can be used to translate from "
"the name in the architectural manuals to the raw hex value "
"B<perf_event_open>()  expects in this field."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:581
msgid ""
"If I<type> is B<PERF_TYPE_BREAKPOINT>, then leave I<config> set to zero.  "
"Its parameters are set in other places."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:582
#, no-wrap
msgid "I<sample_period>, I<sample_freq>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:594
msgid ""
"A \"sampling\" counter is one that generates an interrupt every N events, "
"where N is given by I<sample_period>.  A sampling counter has "
"I<sample_period> E<gt> 0.  When an overflow interrupt occurs, requested data "
"is recorded in the mmap buffer.  The I<sample_type> field controls what data "
"is recorded on each interrupt."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:604
msgid ""
"I<sample_freq> can be used if you wish to use frequency rather than period.  "
"In this case you set the I<freq> flag.  The kernel will adjust the sampling "
"period to try and achieve the desired rate.  The rate of adjustment is a "
"timer tick."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:604
#, no-wrap
msgid "I<sample_type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:616
msgid ""
"The various bits in this field specify which values to include in the "
"sample.  They will be recorded in a ring-buffer, which is available to user "
"space using B<mmap>(2).  The order in which the values are saved in the "
"sample are documented in the MMAP Layout subsection below; it is not the "
"I<enum perf_event_sample_format> order."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:617
#, no-wrap
msgid "B<PERF_SAMPLE_IP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:620
msgid "Records instruction pointer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:620
#, no-wrap
msgid "B<PERF_SAMPLE_TID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:623
msgid "Records the process and thread IDs."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:623
#, no-wrap
msgid "B<PERF_SAMPLE_TIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:626
msgid "Records a timestamp."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:626
#, no-wrap
msgid "B<PERF_SAMPLE_ADDR>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:629
msgid "Records an address, if applicable."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:629
#, no-wrap
msgid "B<PERF_SAMPLE_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:632
msgid "Record counter values for all events in a group, not just the group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:632
#, no-wrap
msgid "B<PERF_SAMPLE_CALLCHAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:635
msgid "Records the callchain (stack backtrace)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:635
#, no-wrap
msgid "B<PERF_SAMPLE_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:638
msgid "Records a unique ID for the opened event's group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:638
#, no-wrap
msgid "B<PERF_SAMPLE_CPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:641
msgid "Records CPU number."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:641
#, no-wrap
msgid "B<PERF_SAMPLE_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:644
msgid "Records the current sampling period."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:644
#, no-wrap
msgid "B<PERF_SAMPLE_STREAM_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:651
msgid ""
"Records a unique ID for the opened event.  Unlike B<PERF_SAMPLE_ID> the "
"actual ID is returned, not the group leader.  This ID is the same as the one "
"returned by PERF_FORMAT_ID."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:651
#, no-wrap
msgid "B<PERF_SAMPLE_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:655
msgid ""
"Records additional data, if applicable.  Usually returned by tracepoint "
"events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:655
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_STACK> (Since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:659
msgid "Records the branch stack.  See branch_sample_type."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:659
#, no-wrap
msgid "B<PERF_SAMPLE_REGS_USER> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:662
msgid "Records the current register state."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:662
#, no-wrap
msgid "B<PERF_SAMPLE_STACK_USER> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:665 build/C/man2/perf_event_open.2:1786 build/C/man2/perf_event_open.2:1803
msgid "[To be documented]"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:666
#, no-wrap
msgid "I<read_format>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:673
msgid ""
"This field specifies the format of the data returned by B<read>(2)  on a "
"B<perf_event_open>()  file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:674
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:681
msgid ""
"Adds the 64-bit I<time_enabled> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:681
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:688
msgid ""
"Adds the 64-bit I<time_running> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:688
#, no-wrap
msgid "B<PERF_FORMAT_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:691
msgid "Adds a 64-bit unique value that corresponds to the event group."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:691
#, no-wrap
msgid "B<PERF_FORMAT_GROUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:694
msgid "Allows all counter values in an event group to be read with one read."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:695
#, no-wrap
msgid "I<disabled>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:705
msgid ""
"The I<disabled> bit specifies whether the counter starts out disabled or "
"enabled.  If disabled, the event can later be enabled by B<ioctl>(2), "
"B<prctl>(2), or I<enable_on_exec>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:705
#, no-wrap
msgid "I<inherit>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:714
msgid ""
"The I<inherit> bit specifies that this counter should count events of child "
"tasks as well as the task specified.  This only applies to new children, not "
"to any existing children at the time the counter is created (nor to any new "
"children of existing children)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:719
msgid ""
"Inherit does not work for some combinations of I<read_format>s, such as "
"B<PERF_FORMAT_GROUP>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:719
#, no-wrap
msgid "I<pinned>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:732
msgid ""
"The I<pinned> bit specifies that the counter should always be on the CPU if "
"at all possible.  It only applies to hardware counters and only to group "
"leaders.  If a pinned counter cannot be put onto the CPU (e.g., because "
"there are not enough hardware counters or because of a conflict with some "
"other event), then the counter goes into an 'error' state, where reads "
"return end-of-file (i.e., B<read>(2)  returns 0) until the counter is "
"subsequently enabled or disabled."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:732
#, no-wrap
msgid "I<exclusive>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:741
msgid ""
"The I<exclusive> bit specifies that when this counter's group is on the CPU, "
"it should be the only group using the CPU's counters.  In the future this "
"may allow monitoring programs to support PMU features that need to run alone "
"so that they do not disrupt other hardware counters."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:741
#, no-wrap
msgid "I<exclude_user>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:744
msgid "If this bit is set, the count excludes events that happen in user space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:744
#, no-wrap
msgid "I<exclude_kernel>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:747
msgid "If this bit is set, the count excludes events that happen in kernel-space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:747
#, no-wrap
msgid "I<exclude_hv>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:755
msgid ""
"If this bit is set, the count excludes events that happen in the "
"hypervisor.  This is mainly for PMUs that have built-in support for handling "
"this (such as POWER).  Extra support is needed for handling hypervisor "
"measurements on most machines."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:755
#, no-wrap
msgid "I<exclude_idle>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:758
msgid "If set, don't count when the CPU is idle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:758
#, no-wrap
msgid "I<mmap>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:763
msgid "The I<mmap> bit enables recording of exec mmap events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:763
#, no-wrap
msgid "I<comm>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:774
msgid ""
"The I<comm> bit enables tracking of process command name as modified by the "
"I<exec>(2)  and I<prctl>(PR_SET_NAME)  system calls.  Unfortunately for "
"tools, there is no way to distinguish one system call versus the other."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:774
#, no-wrap
msgid "I<freq>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:781
msgid ""
"If this bit is set, then I<sample_frequency> not I<sample_period> is used "
"when setting up the sampling interval."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:781
#, no-wrap
msgid "I<inherit_stat>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:788
msgid ""
"This bit enables saving of event counts on context switch for inherited "
"tasks.  This is only meaningful if the I<inherit> field is set."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:788
#, no-wrap
msgid "I<enable_on_exec>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:793
msgid ""
"If this bit is set, a counter is automatically enabled after a call to "
"B<exec>(2)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:793
#, no-wrap
msgid "I<task>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:797
msgid ""
"If this bit is set, then fork/exit notifications are included in the ring "
"buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:797
#, no-wrap
msgid "I<watermark>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:805
msgid ""
"If set, have a sampling interrupt happen when we cross the "
"I<wakeup_watermark> boundary.  Otherwise interrupts happen after "
"I<wakeup_events> samples."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:805
#, no-wrap
msgid "I<precise_ip> (Since Linux 2.6.35)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:815
msgid ""
"This controls the amount of skid.  Skid is how many instructions execute "
"between an event of interest happening and the kernel being able to stop and "
"record the event.  Smaller skid is better and allows more accurate reporting "
"of which events correspond to which instructions, but hardware is often "
"limited with how small this can be."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:817
msgid "The values of this are the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:818
#, no-wrap
msgid "0 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:822
msgid "B<SAMPLE_IP> can have arbitrary skid"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:822
#, no-wrap
msgid "1 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:826
msgid "B<SAMPLE_IP> must have constant skid"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:826
#, no-wrap
msgid "2 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:830
msgid "B<SAMPLE_IP> requested to have 0 skid"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:830
#, no-wrap
msgid "3 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:836
msgid "B<SAMPLE_IP> must have 0 skid.  See also B<PERF_RECORD_MISC_EXACT_IP>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:837
#, no-wrap
msgid "I<mmap_data> (Since Linux 2.6.36)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:843
msgid ""
"The counterpart of the I<mmap> field, but enables including data mmap events "
"in the ring-buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:843
#, no-wrap
msgid "I<sample_id_all> (Since Linux 2.6.38)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:851
msgid ""
"If set, then TID, TIME, ID, CPU, and STREAM_ID can additionally be included "
"in non-B<PERF_RECORD_SAMPLE>s if the corresponding I<sample_type> is "
"selected."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:851
#, no-wrap
msgid "I<exclude_host> (Since Linux 3.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:854
msgid "Do not measure time spent in VM host"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:854
#, no-wrap
msgid "I<exclude_guest> (Since Linux 3.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:857
msgid "Do not measure time spent in VM guest"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:857
#, no-wrap
msgid "I<exclude_callchain_kernel> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:860
msgid "Do not include kernel callchains."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:860
#, no-wrap
msgid "I<exclude_callchain_user> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:863
msgid "Do not include user callchains."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:863
#, no-wrap
msgid "I<wakeup_events>, I<wakeup_watermark>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:873
msgid ""
"This union sets how many samples (I<wakeup_events>)  or bytes "
"(I<wakeup_watermark>)  happen before an overflow signal happens.  Which one "
"is used is selected by the I<watermark> bitflag."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:873
#, no-wrap
msgid "I<bp_type> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:877
msgid "This chooses the breakpoint type.  It is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:878
#, no-wrap
msgid "B<HW_BREAKPOINT_EMPTY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:881
msgid "no breakpoint"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:881
#, no-wrap
msgid "B<HW_BREAKPOINT_R>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:884
msgid "count when we read the memory location"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:884
#, no-wrap
msgid "B<HW_BREAKPOINT_W>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:887
msgid "count when we write the memory location"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:887
#, no-wrap
msgid "B<HW_BREAKPOINT_RW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:890
msgid "count when we read or write the memory location"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:890
#, no-wrap
msgid "B<HW_BREAKPOINT_X>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:893
msgid "count when we execute code at the memory location"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:902
msgid ""
"The values can be combined via a bitwise or, but the combination of "
"B<HW_BREAKPOINT_R> or B<HW_BREAKPOINT_W> with B<HW_BREAKPOINT_X> is not "
"allowed."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:903
#, no-wrap
msgid "I<bp_addr> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:910
msgid ""
"I<bp_addr> address of the breakpoint.  For execution breakpoints this is the "
"memory address of the instruction of interest; for read and write "
"breakpoints it is the memory address of the memory location of interest."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:910
#, no-wrap
msgid "I<config1> (Since Linux 2.6.39)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:917
msgid ""
"I<config1> is used for setting events that need an extra register or "
"otherwise do not fit in the regular config field.  Raw OFFCORE_EVENTS on "
"Nehalem/Westmere/SandyBridge use this field on 3.3 and later kernels."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:917
#, no-wrap
msgid "I<bp_len> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:931
msgid ""
"I<bp_len> is the length of the breakpoint being measured if I<type> is "
"B<PERF_TYPE_BREAKPOINT>.  Options are B<HW_BREAKPOINT_LEN_1>, "
"B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4>, B<HW_BREAKPOINT_LEN_8>.  For "
"an execution breakpoint, set this to I<sizeof(long)>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:931
#, no-wrap
msgid "I<config2> (Since Linux 2.6.39)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:938
msgid "I<config2> is a further extension of the I<config1> field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:938
#, no-wrap
msgid "I<branch_sample_type> (Since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:942
msgid ""
"This is used with the CPUs hardware branch sampling, if available.  It can "
"have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:943
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:946
msgid "Branch target is in user space"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:946
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:949
msgid "Branch target is in kernel space"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:949
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_HV>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:952
msgid "Branch target is in hypervisor"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:952
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:955
msgid "Any branch type."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:955
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:958
msgid "Any call branch"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:958
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:961
msgid "Any return branch"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:961
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:964
msgid "Indirect calls"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:964
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_PLM_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:967
msgid "User, kernel, and hv"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:968
#, no-wrap
msgid "I<sample_regs_user> (Since Linux 3.7)"
msgstr ""

#.  FIXME: The following reference seems to be not quite right:
#. type: Plain text
#: build/C/man2/perf_event_open.2:974
msgid ""
"This defines the set of user registers to dump on samples.  See "
"I<asm/perf_regs.h>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:974
#, no-wrap
msgid "I<sample_stack_user> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:977
msgid "This defines the size of the user stack to dump on samples."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:977
#, no-wrap
msgid "Reading results"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:987
msgid ""
"Once a B<perf_event_open>()  file descriptor has been opened, the values of "
"the events can be read from the file descriptor.  The values that are there "
"are specified by the I<read_format> field in the I<attr> structure at open "
"time."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:992
msgid ""
"If you attempt to read into a buffer that is not big enough to hold the data "
"B<ENOSPC> is returned"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:994
msgid "Here is the layout of the data returned by a read:"
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:994 build/C/man2/perf_event_open.2:1012 build/C/man2/ptrace.2:1552 build/C/man2/ptrace.2:1562 build/C/man2/ptrace.2:1570 build/C/man2/ptrace.2:1576 build/C/man2/ptrace.2:1705
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:998
msgid ""
"If B<PERF_FORMAT_GROUP> was specified to allow reading all events in a group "
"at once:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1010
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 nr;            /* The number of events */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct\n"
"        u64 value;     /* The value of the event */\n"
"        u64 id;        /* if PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1018
msgid "If B<PERF_FORMAT_GROUP> was I<not> specified:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1027
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 value;         /* The value of the event */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* if PERF_FORMAT_ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1031
msgid "The values read are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1031
#, no-wrap
msgid "I<nr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1037
msgid ""
"The number of events in this file descriptor.  Only available if "
"B<PERF_FORMAT_GROUP> was specified."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1037
#, no-wrap
msgid "I<time_enabled>, I<time_running>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1049
msgid ""
"Total time the event was enabled and running.  Normally these are the same.  "
"If more events are started than available counter slots on the PMU, then "
"multiplexing happens and events only run part of the time.  In that case the "
"I<time_enabled> and I<time running> values can be used to scale an estimated "
"value for the count."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1049
#, no-wrap
msgid "I<value>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1052
msgid "An unsigned 64-bit value containing the counter result."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1052 build/C/man2/perf_event_open.2:1316 build/C/man2/perf_event_open.2:1451
#, no-wrap
msgid "I<id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1058
msgid ""
"A globally unique value for this particular event, only there if "
"B<PERF_FORMAT_ID> was specified in I<read_format>."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1058
#, no-wrap
msgid "MMAP layout"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1068
msgid ""
"When using B<perf_event_open>()  in sampled mode, asynchronous events (like "
"counter overflow or B<PROT_EXEC> mmap tracking)  are logged into a "
"ring-buffer.  This ring-buffer is created and accessed through B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1074
msgid ""
"The mmap size should be 1+2^n pages, where the first page is a metadata page "
"(I<struct perf_event_mmap_page>)  that contains various bits of information "
"such as where the ring-buffer head is."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1077
msgid ""
"Before kernel 2.6.39, there is a bug that means you must allocate a mmap "
"ring buffer when sampling even if you do not plan to access it."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1079
msgid "The structure of the first metadata mmap page is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1103
#, no-wrap
msgid ""
"struct perf_event_mmap_page {\n"
"    __u32 version;          /* version number of this structure */\n"
"    __u32 compat_version;   /* lowest version this is compat with */\n"
"    __u32 lock;             /* seqlock for synchronization */\n"
"    __u32 index;            /* hardware counter identifier */\n"
"    __s64 offset;           /* add to hardware counter value */\n"
"    __u64 time_enabled;     /* time event active */\n"
"    __u64 time_running;     /* time event on CPU */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        __u64   cap_usr_time  : 1,\n"
"                cap_usr_rdpmc : 1,\n"
"    };\n"
"    __u16   pmc_width;\n"
"    __u16   time_shift;\n"
"    __u32   time_mult;\n"
"    __u64   time_offset;\n"
"    __u64   __reserved[120];   /* Pad to 1k */\n"
"    __u64   data_head;         /* head in the data section */\n"
"    __u64   data_tail;         /* user-space written tail */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1109
msgid ""
"The following looks at the fields in the I<perf_event_mmap_page> structure "
"in more detail:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1109
#, no-wrap
msgid "I<version>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1112
msgid "Version number of this structure."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1112
#, no-wrap
msgid "I<compat_version>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1115
msgid "The lowest version this is compatible with."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1115
#, no-wrap
msgid "I<lock>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1118
msgid "A seqlock for synchronization."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1118
#, no-wrap
msgid "I<index>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1121
msgid "A unique hardware counter identifier."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1121
#, no-wrap
msgid "I<offset>"
msgstr ""

#.  FIXME clarify
#. type: Plain text
#: build/C/man2/perf_event_open.2:1125
msgid "Add this to hardware counter value??"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1125
#, no-wrap
msgid "I<time_enabled>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1128
msgid "Time the event was active."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1128
#, no-wrap
msgid "I<time_running>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1131
msgid "Time the event was running."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1131
#, no-wrap
msgid "I<cap_usr_time>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1134
msgid "User time capability"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1134
#, no-wrap
msgid "I<cap_usr_rdpmc>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1139
msgid ""
"If the hardware supports user-space read of performance counters without "
"syscall (this is the \"rdpmc\" instruction on x86), then the following code "
"can be used to do a read:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1146
#, no-wrap
msgid ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"
"s64 pmc = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1152
#, no-wrap
msgid ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1159
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1162
#, no-wrap
msgid ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1167
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        pmc = rdpmc(idx - 1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1170
#, no-wrap
msgid ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1172
#, no-wrap
msgid "I<pmc_width>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1179
msgid ""
"If I<cap_usr_rdpmc>, this field provides the bit-width of the value read "
"using the rdpmc or equivalent instruction.  This can be used to sign extend "
"the result like:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1185
#, no-wrap
msgid ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // signed shift right\n"
"count += pmc;\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1187
#, no-wrap
msgid "I<time_shift>, I<time_mult>, I<time_offset>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1194
msgid ""
"If I<cap_usr_time>, these fields can be used to compute the time delta since "
"time_enabled (in nanoseconds) using rdtsc or similar."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1202
#, no-wrap
msgid ""
"    u64 quot, rem;\n"
"    u64 delta;\n"
"    quot = (cyc E<gt>E<gt> time_shift);\n"
"    rem = cyc & ((1 E<lt>E<lt> time_shift) - 1);\n"
"    delta = time_offset + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1214
msgid ""
"Where I<time_offset>, I<time_mult>, I<time_shift>, and I<cyc> are read in "
"the seqcount loop described above.  This delta can then be added to enabled "
"and possible running (if idx), improving the scaling:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1222
#, no-wrap
msgid ""
"    enabled += delta;\n"
"    if (idx)\n"
"        running += delta;\n"
"    quot = count / running;\n"
"    rem  = count % running;\n"
"    count = quot * enabled + (rem * enabled) / running;\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1223
#, no-wrap
msgid "I<data_head>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1229
msgid ""
"This points to the head of the data section.  The value continuously "
"increases, it does not wrap.  The value needs to be manually wrapped by the "
"size of the mmap buffer before accessing the samples."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1232
msgid ""
"On SMP-capable platforms, after reading the data_head value, user space "
"should issue an rmb()."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1232
#, no-wrap
msgid "I<data_tail;>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1240
msgid ""
"When the mapping is B<PROT_WRITE>, the I<data_tail> value should be written "
"by user space to reflect the last read data.  In this case the kernel will "
"not over-write unread data."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1242
msgid "The following 2^n ring-buffer pages have the layout described below."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1256
msgid ""
"If I<perf_event_attr.sample_id_all> is set, then all event types will have "
"the sample_type selected fields related to where/when (identity)  an event "
"took place (TID, TIME, ID, CPU, STREAM_ID) described in "
"B<PERF_RECORD_SAMPLE> below, it will be stashed just after the "
"I<perf_event_header> and the fields already present for the existing fields, "
"i.e., at the end of the payload.  That way a newer perf.data file will be "
"supported by older perf tools, with these new optional fields being ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1258
msgid "The mmap values start with a header:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1266
#, no-wrap
msgid ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1272
msgid "Below, we describe the I<perf_event_header> fields in more detail."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1281
msgid ""
"The I<type> value is one of the below.  The values in the corresponding "
"record (that follows the header)  depend on the I<type> selected as shown."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1282
#, no-wrap
msgid "B<PERF_RECORD_MMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1289
msgid ""
"The MMAP events record the B<PROT_EXEC> mappings so that we can correlate "
"user-space IPs to code.  They have the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1300
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1302
#, no-wrap
msgid "B<PERF_RECORD_LOST>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1305
msgid "This record indicates when events are lost."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1313
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64 id;\n"
"    u64 lost;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1319
msgid "is the unique event ID for the samples that were lost."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1319
#, no-wrap
msgid "I<lost>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1322
msgid "is the number of events that were lost."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1323
#, no-wrap
msgid "B<PERF_RECORD_COMM>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1326
msgid "This record indicates a change in the process name."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1334
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, tid;\n"
"    char comm[];\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1336
#, no-wrap
msgid "B<PERF_RECORD_EXIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1339
msgid "This record indicates a process exit event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1348 build/C/man2/perf_event_open.2:1376
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, ppid;\n"
"    u32 tid, ptid;\n"
"    u64 time;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1350
#, no-wrap
msgid "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1353
msgid "This record indicates a throttle/unthrottle event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1362
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64 time;\n"
"    u64 id;\n"
"    u64 stream_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1364
#, no-wrap
msgid "B<PERF_RECORD_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1367
msgid "This record indicates a fork event."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1378
#, no-wrap
msgid "B<PERF_RECORD_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1381
msgid "This record indicates a read event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1389
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, tid;\n"
"    struct read_format values;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1391
#, no-wrap
msgid "B<PERF_RECORD_SAMPLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1394
msgid "This record indicates a sample."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1422
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64   ip;         /* if PERF_SAMPLE_IP */\n"
"    u32   pid, tid;   /* if PERF_SAMPLE_TID */\n"
"    u64   time;       /* if PERF_SAMPLE_TIME */\n"
"    u64   addr;       /* if PERF_SAMPLE_ADDR */\n"
"    u64   id;         /* if PERF_SAMPLE_ID */\n"
"    u64   stream_id;  /* if PERF_SAMPLE_STREAM_ID */\n"
"    u32   cpu, res;   /* if PERF_SAMPLE_CPU */\n"
"    u64   period;     /* if PERF_SAMPLE_PERIOD */\n"
"    struct read_format v; /* if PERF_SAMPLE_READ */\n"
"    u64   nr;         /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u64   ips[nr];    /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u32   size;       /* if PERF_SAMPLE_RAW */\n"
"    char  data[size]; /* if PERF_SAMPLE_RAW */\n"
"    u64   bnr;        /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                      /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    u64   abi;        /* if PERF_SAMPLE_REGS_USER */\n"
"    u64   regs[weight(mask)];\n"
"                      /* if PERF_SAMPLE_REGS_USER */\n"
"    u64   size;       /* if PERF_SAMPLE_STACK_USER */\n"
"    char  data[size]; /* if PERF_SAMPLE_STACK_USER */\n"
"    u64   dyn_size;   /* if PERF_SAMPLE_STACK_USER */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1424
#, no-wrap
msgid "I<ip>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1430
msgid ""
"If B<PERF_SAMPLE_IP> is enabled, then a 64-bit instruction pointer value is "
"included."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1430
#, no-wrap
msgid "I<pid>, I<tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1436
msgid ""
"If B<PERF_SAMPLE_TID> is enabled, then a 32-bit process ID and 32-bit thread "
"ID are included."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1436
#, no-wrap
msgid "I<time>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1444
msgid ""
"If B<PERF_SAMPLE_TIME> is enabled, then a 64-bit timestamp is included.  "
"This is obtained via local_clock() which is a hardware timestamp if "
"available and the jiffies value if not."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1444
#, no-wrap
msgid "I<addr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1451
msgid ""
"If B<PERF_SAMPLE_ADDR> is enabled, then a 64-bit address is included.  This "
"is usually the address of a tracepoint, breakpoint, or software event; "
"otherwise the value is 0."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1459
msgid ""
"If B<PERF_SAMPLE_ID> is enabled, a 64-bit unique ID is included.  If the "
"event is a member of an event group, the group leader ID is returned.  This "
"ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1459
#, no-wrap
msgid "I<stream_id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1469
msgid ""
"If B<PERF_SAMPLE_STREAM_ID> is enabled, a 64-bit unique ID is included.  "
"Unlike B<PERF_SAMPLE_ID> the actual ID is returned, not the group leader.  "
"This ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1469
#, no-wrap
msgid "I<cpu>, I<res>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1476
msgid ""
"If B<PERF_SAMPLE_CPU> is enabled, this is a 32-bit value indicating which "
"CPU was being used, in addition to a reserved (unused)  32-bit value."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1476
#, no-wrap
msgid "I<period>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1482
msgid ""
"If B<PERF_SAMPLE_PERIOD> is enabled, a 64-bit value indicating the current "
"sampling period is written."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1482
#, no-wrap
msgid "I<v>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1493
msgid ""
"If B<PERF_SAMPLE_READ> is enabled, a structure of type read_format is "
"included which has values for all events in the event group.  The values "
"included depend on the I<read_format> value used at B<perf_event_open>()  "
"time."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1493
#, no-wrap
msgid "I<nr>, I<ips[nr]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1501
msgid ""
"If B<PERF_SAMPLE_CALLCHAIN> is enabled, then a 64-bit number is included "
"which indicates how many following 64-bit instruction pointers will follow.  "
"This is the current callchain."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1501
#, no-wrap
msgid "I<size>, I<data[size]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1508
msgid ""
"If B<PERF_SAMPLE_RAW> is enabled, then a 32-bit value indicating size is "
"included followed by an array of 8-bit values of length size.  The values "
"are padded with 0 to have 64-bit alignment."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1513
msgid ""
"This RAW record data is opaque with respect to the ABI.  The ABI doesn't "
"make any promises with respect to the stability of its content, it may vary "
"depending on event, hardware, and kernel version."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1513
#, no-wrap
msgid "I<bnr>, I<lbr[bnr]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1524
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then a 64-bit value indicating "
"the number of records is included, followed by I<bnr> I<perf_branch_entry> "
"structures.  These structures have from, to, and flags values indicating the "
"from and to addresses from the branches on the callstack."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1524
#, no-wrap
msgid "I<abi>, I<regs[weight(mask)]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1530
msgid "If B<PERF_SAMPLE_REGS_USER> is enabled, then [to be documented]."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1536
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1536
#, no-wrap
msgid "I<size>, I<data[size]>, I<dyn_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1542
msgid "If B<PERF_SAMPLE_STACK_USER> is enabled, then [to be documented]."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1544
#, no-wrap
msgid "I<misc>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1549
msgid "The I<misc> field contains additional information about the sample."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1554
msgid ""
"The CPU mode can be determined from this value by masking with "
"B<PERF_RECORD_MISC_CPUMODE_MASK> and looking for one of the following (note "
"these are not bit masks, only one can be set at a time):"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1555
#, no-wrap
msgid "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1558
msgid "Unknown CPU mode."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1558
#, no-wrap
msgid "B<PERF_RECORD_MISC_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1561
msgid "Sample happened in the kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1561
#, no-wrap
msgid "B<PERF_RECORD_MISC_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1564
msgid "Sample happened in user code."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1564
#, no-wrap
msgid "B<PERF_RECORD_MISC_HYPERVISOR>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1567
msgid "Sample happened in the hypervisor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1567
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1570
msgid "Sample happened in the guest kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1570
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1573
msgid "Sample happened in guest user code."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1576
msgid "In addition, one of the following bits can be set:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1577
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXACT_IP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1585
msgid ""
"This indicates that the content of B<PERF_SAMPLE_IP> points to the actual "
"instruction that triggered the event.  See also "
"I<perf_event_attr.precise_ip>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1585
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXT_RESERVED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1588
msgid "This indicates there is extended data available (currently not used)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1591
msgid "This indicates the size of the record."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1592
#, no-wrap
msgid "Signal overflow"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1601
msgid ""
"Events can be set to deliver a signal when a threshold is crossed.  The "
"signal handler is set up using the B<poll>(2), B<select>(2), B<epoll>(2)  "
"and B<fcntl>(2), system calls."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1605
msgid ""
"To generate signals, sampling must be enabled (I<sample_period> must have a "
"non-zero value)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1607
msgid "There are two ways to generate signals."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1617
msgid ""
"The first is to set a I<wakeup_events> or I<wakeup_watermark> value that "
"will generate a signal if a certain number of samples or bytes have been "
"written to the mmap ring buffer.  In this case a signal of type B<POLL_IN> "
"is sent."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1629
msgid ""
"The other way is by use of the B<PERF_EVENT_IOC_REFRESH> ioctl.  This ioctl "
"adds to a counter that decrements each time the event overflows.  When "
"non-zero, a B<POLL_IN> signal is sent on overflow, but once the value "
"reaches 0, a signal is sent of type B<POLL_HUP> and the underlying event is "
"disabled."
msgstr ""

#.  FIXME(Vince) : Find out when this was introduced
#. type: Plain text
#: build/C/man2/perf_event_open.2:1635
msgid ""
"Note: on newer kernels (definitely noticed with 3.2)  a signal is provided "
"for every overflow, even if I<wakeup_events> is not set."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1635
#, no-wrap
msgid "rdpmc instruction"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1642
msgid ""
"Starting with Linux 3.4 on x86, you can use the I<rdpmc> instruction to get "
"low-latency reads without having to enter the kernel.  Note that using "
"I<rdpmc> is not necessarily faster than other methods for reading event "
"values."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1647
msgid ""
"Support for this can be detected with the I<cap_usr_rdpmc> field in the mmap "
"page; documentation on how to calculate event values can be found in that "
"section."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1647
#, no-wrap
msgid "perf_event ioctl calls"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1652
msgid "Various ioctls act on B<perf_event_open>()  file descriptors"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1652
#, no-wrap
msgid "B<PERF_EVENT_IOC_ENABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1656
msgid ""
"Enables the individual event or event group specified by the file descriptor "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1658 build/C/man2/perf_event_open.2:1671 build/C/man2/perf_event_open.2:1699
msgid "The ioctl argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1658
#, no-wrap
msgid "B<PERF_EVENT_IOC_DISABLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1662
msgid ""
"Disables the individual counter or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1669
msgid ""
"Enabling or disabling the leader of a group enables or disables the entire "
"group; that is, while the group leader is disabled, none of the counters in "
"the group will count.  Enabling or disabling a member of a group other than "
"the leader only affects that counter; disabling a non-leader stops that "
"counter from counting but doesn't affect any other counter."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1671
#, no-wrap
msgid "B<PERF_EVENT_IOC_REFRESH>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1685
msgid ""
"Non-inherited overflow counters can use this to enable a counter for a "
"number of overflows specified by the argument, after which it is disabled.  "
"Subsequent calls of this ioctl add the argument value to the current count.  "
"A signal with B<POLL_IN> set will happen on each overflow until the count "
"reaches 0; when that happens a signal with POLL_HUP set is sent and the "
"event is disabled.  Using an argument of 0 is considered undefined behavior."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1685
#, no-wrap
msgid "B<PERF_EVENT_IOC_RESET>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1697
msgid ""
"Reset the event count specified by the file descriptor argumentto zero.  "
"This only resets the counts; there is no way to reset the multiplexing "
"I<time_enabled> or I<time_running> values.  When sent to a group leader, "
"only the leader is reset (child events are not)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1699
#, no-wrap
msgid "B<PERF_EVENT_IOC_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1703
msgid ""
"IOC_PERIOD is the command to update the period; it does not update the "
"current period but instead defers until next."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1706
msgid ""
"The argument is a pointer to a 64-bit value containing the desired new "
"period."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1706
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1711
msgid ""
"This tells the kernel to report event notifications to the specified file "
"descriptor rather than the default one.  The file descriptors must all be on "
"the same CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1714
msgid ""
"The argument specifies the desired file descriptor, or -1 if output should "
"be ignored."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1714
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_FILTER> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1717
msgid "This adds an ftrace filter to this event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1719
msgid "The argument is a pointer to the desired ftrace filter."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1719
#, no-wrap
msgid "Using prctl"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1732
msgid ""
"A process can enable or disable all the event groups that are attached to it "
"using the B<prctl>(2)  B<PR_TASK_PERF_EVENTS_ENABLE> and "
"B<PR_TASK_PERF_EVENTS_DISABLE> operations.  This applies to all counters on "
"the current process, whether created by this process or by another, and does "
"not affect any counters that this process has created on other processes.  "
"It only enables or disables the group leaders, not any other members in the "
"groups."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1732
#, no-wrap
msgid "perf_event related configuration files"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1735
msgid "Files in I</proc/sys/kernel/>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1736
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_paranoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1742
msgid ""
"The I<perf_event_paranoid> file can be set to restrict access to the "
"performance counters."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1744
msgid "2 - only allow user-space measurements"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1746
msgid "1 - (default) allow both kernel and user measurements"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1748
msgid "0 - allow access to CPU-specific data but not raw tracepoint samples"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1750
msgid "-1 - no restrictions"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1755
msgid ""
"The existence of the I<perf_event_paranoid> file is the official method for "
"determining if a kernel supports B<perf_event_open>()."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1755
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_sample_rate>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1764
msgid ""
"This sets the maximum sample rate.  Setting this too high can allow users to "
"sample at a rate that impacts overall machine performance and potentially "
"lock up the machine.  The default value is 100000 (samples per second)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1764
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_mlock_kb>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1769
msgid ""
"Maximum number of pages an unprivileged user can mlock (2) .  The default is "
"516 (kB)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1772
msgid "Files in I</sys/bus/event_source/devices/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1778
msgid ""
"Since Linux 2.6.34 the kernel supports having multiple PMUs available for "
"monitoring.  Information on how to program these PMUs can be found under "
"I</sys/bus/event_source/devices/>.  Each subdirectory corresponds to a "
"different PMU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1778
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1783
msgid ""
"This contains an integer that can be used in the I<type> field of "
"perf_event_attr to indicate you wish to use this PMU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1783
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/rdpmc>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1786
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/format/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1791
msgid ""
"This sub-directory contains information on what bits in the I<config> field "
"of perf_event_attr correspond to."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1791
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/events/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1800
msgid ""
"This sub-directory contains files with pre-defined events.  The contents are "
"strings describing the event settings expressed in terms of the fields found "
"in the I<./format/> directory.  These are not necessarily complete lists of "
"all events supported by a PMU, but usually a subset of events deemed useful "
"or interesting."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1800
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/uevent>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1810
msgid ""
"B<perf_event_open>()  returns the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1814
msgid "Returned if the specified event is not available."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1814
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1824
msgid ""
"Prior to Linux 3.3, if there was not enough room for the event, B<ENOSPC> "
"was returned.  Linus did not like this, and this was changed to B<EINVAL>.  "
"B<ENOSPC> is still returned if you try to read results into too small of a "
"buffer."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:1824
#, no-wrap
msgid "VERSION"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1829
msgid ""
"B<perf_event_open>()  was introduced in Linux 2.6.31 but was called "
"B<perf_counter_open>()B<.> It was renamed in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1834
msgid ""
"This B<perf_event_open>()  system call Linux- specific and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1838
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  See the example below."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1844
msgid ""
"The official way of knowing if B<perf_event_open>()  support is enabled is "
"checking for the existence of the file "
"I</proc/sys/kernel/perf_event_paranoid>."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:1844 build/C/man2/pivot_root.2:134 build/C/man2/ptrace.2:1810
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1851
msgid ""
"The B<F_SETOWN_EX> option to B<fcntl>(2)  is needed to properly get overflow "
"signals in threads.  This was introduced in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1859
msgid ""
"Prior to Linux 2.6.33 (at least for x86) the kernel did not check if events "
"could be scheduled together until read time.  The same happens on all known "
"kernels if the NMI watchdog is enabled.  This means to see if a given set of "
"events works you have to B<perf_event_open>(), start, then read before you "
"know for sure you can get valid measurements."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1863
msgid ""
"Prior to Linux 2.6.34 event constraints were not enforced by the kernel.  In "
"that case, some events would silently return \"0\" if the kernel scheduled "
"them in an improper counter slot."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1866
msgid ""
"Prior to Linux 2.6.34 there was a bug when multiplexing where the wrong "
"results could be returned."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1869
msgid ""
"Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "
"\"inherit\" is enabled and many threads are started."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1873
msgid ""
"Prior to Linux 2.6.35, B<PERF_FORMAT_GROUP> did not work with attached "
"processes."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1878
msgid ""
"In older Linux 2.6 versions, refreshing an event group leader refreshed all "
"siblings, and refreshing with a parameter of 0 enabled infinite refresh.  "
"This behavior is unsupported and should not be relied on."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1884
msgid ""
"There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that "
"ignores the \"watermark\" field and acts as if a wakeup_event was chosen if "
"the union has a non-zero value in it."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1889
msgid ""
"Always double-check your results! Various generalized events have had wrong "
"values.  For example, retired branches measured the wrong thing on AMD "
"machines until Linux 2.6.35."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:1889 build/C/man2/process_vm_readv.2:295 build/C/man2/splice.2:223 build/C/man2/tee.2:130
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1893
msgid ""
"The following is a short example that measures the total instruction count "
"of a call to B<printf>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1902
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1908
#, no-wrap
msgid ""
"long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1913
#, no-wrap
msgid ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1920
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1928
#, no-wrap
msgid ""
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1934
#, no-wrap
msgid ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1937
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1939
#, no-wrap
msgid "    printf(\"Measuring instruction count for this printf\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1942
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(long long));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1944
#, no-wrap
msgid "    printf(\"Used %lld instructions\\en\", count);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1947
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1954
msgid "B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"
msgstr ""

#. type: TH
#: build/C/man2/perfmonctl.2:27
#, no-wrap
msgid "PERFMONCTL"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:30
msgid "perfmonctl - interface to IA-64 performance monitoring unit"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:36
#, no-wrap
msgid ""
"B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int "
">I<narg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:47
msgid ""
"The IA-64-specific B<perfmonctl>()  system call provides an interface to the "
"PMU (performance monitoring unit).  The PMU consists of PMD (performance "
"monitoring data) registers and PMC (performance monitoring control) "
"registers, which gather hardware statistics."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:57
msgid ""
"B<perfmonctl>()  applies the operation I<cmd> to the input arguments "
"specified by I<arg>.  The number of arguments is defined by I<narg>.  The "
"I<fd> argument specifies the perfmon context to operate on."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:61
msgid "Supported values for I<cmd> are:"
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:61
#, no-wrap
msgid "B<PFM_CREATE_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:65
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:67
msgid "Set up a context."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:74
msgid ""
"The I<fd> parameter is ignored.  A new perfmon context is created as "
"specified in I<ctxt> and its file descriptor is returned in "
"I<ctxt-E<gt>ctx_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:86
msgid ""
"The file descriptor can be used in subsequent calls to B<perfmonctl>()  and "
"can be used to read event notifications (type I<pfm_msg_t>)  using "
"B<read>(2).  The file descriptor is pollable using B<select>(2), B<poll>(2), "
"and B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:90
msgid "The context can be destroyed by calling B<close>(2)  on the file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:90
#, no-wrap
msgid "B<PFM_WRITE_PMCS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:95
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:97
msgid "Set PMC registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:97
#, no-wrap
msgid "B<PFM_WRITE_PMDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:101
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#.  pfm_write_pmds()
#. type: Plain text
#: build/C/man2/perfmonctl.2:104
msgid "Set PMD registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:104
#, no-wrap
msgid "B<PFM_READ_PMDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:109
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:111
msgid "Read PMD registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:111
#, no-wrap
msgid "B<PFM_START>"
msgstr ""

#.  .BI  "perfmonctl(int " fd ", PFM_START, arg, 1);
#. type: Plain text
#: build/C/man2/perfmonctl.2:117
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:119
msgid "Start monitoring."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:119
#, no-wrap
msgid "B<PFM_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:124
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:126
msgid "Stop monitoring."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:126
#, no-wrap
msgid "B<PFM_LOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:131
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, "
"1);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:133
msgid "Attach the context to a thread."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:133
#, no-wrap
msgid "B<PFM_UNLOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:138
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:140
msgid "Detach the context from a thread."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:140
#, no-wrap
msgid "B<PFM_RESTART>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:145
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:147
msgid "Restart monitoring after receiving an overflow notification."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:147
#, no-wrap
msgid "B<PFM_GET_FEATURES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:152
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_FEARURES, pfarg_features_t *>I<arg>B<, "
"1);>\n"
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:153
#, no-wrap
msgid "B<PFM_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:158
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:162
msgid "If I<val> is nonzero, enable debugging mode, otherwise disable."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:162
#, no-wrap
msgid "B<PFM_GET_PMC_RESET_VAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:167
#, no-wrap
msgid ""
"B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t * >I<req>B<, "
"n);>\n"
msgstr ""

#
#
#.  .TP
#.  .B PFM_CREATE_EVTSETS
#
#.  create or modify event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_CREATE_EVTSETS, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_DELETE_EVTSETS
#.  delete event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_DELETE_EVTSET, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_GETINFO_EVTSETS
#.  get information about event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_GETINFO_EVTSETS, pfarg_setinfo_t *info, n);
#.  .fi
#. type: Plain text
#: build/C/man2/perfmonctl.2:190
msgid "Reset PMC registers to default values."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:196
msgid ""
"B<performctl>()  returns zero when the operation is successful.  On error, "
"-1 is returned and I<errno> is set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:199
msgid "B<perfmonctl>()  is available since Linux 2.4."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:202
msgid ""
"B<perfmonctl>()  is Linux specific and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:207
msgid "B<gprof>(1)"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:209
msgid "The perfmon2 interface specification"
msgstr ""

#. type: TH
#: build/C/man2/personality.2:32
#, no-wrap
msgid "PERSONALITY"
msgstr ""

#. type: TH
#: build/C/man2/personality.2:32
#, no-wrap
msgid "2003-01-01"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:35
msgid "personality - set the process execution domain"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:37
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:39
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:47
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:57
msgid ""
"This function will return the current B<personality>()  when I<persona> "
"equals 0xffffffff.  Otherwise, it will make the execution domain referenced "
"by I<persona> the new execution domain of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:64
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:68
msgid "The kernel was unable to change the personality."
msgstr ""

#. type: Plain text
#: build/C/man2/personality.2:72
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: TH
#: build/C/man2/pivot_root.2:10
#, no-wrap
msgid "PIVOT_ROOT"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:13
msgid "pivot_root - change the root file system"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:15
msgid "B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""

#
#.  The
#.  .B CAP_SYS_ADMIN
#.  capability is required.
#. type: Plain text
#: build/C/man2/pivot_root.2:27
msgid ""
"B<pivot_root>()  moves the root file system of the calling process to the "
"directory I<put_old> and makes I<new_root> the new root file system of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:34
msgid ""
"The typical use of B<pivot_root>()  is during system startup, when the "
"system mounts a temporary root file system (e.g., an B<initrd>), then mounts "
"the real root file system, and eventually turns the latter into the current "
"root of all relevant processes or threads."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:46
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:64
msgid ""
"The paragraph above is intentionally vague because the implementation of "
"B<pivot_root>()  may change in the future.  At the time of writing, "
"B<pivot_root>()  changes root and current working directory of each process "
"or thread to I<new_root> if they point to the old root directory.  This is "
"necessary in order to prevent kernel threads from keeping the old root "
"directory busy with their root and current working directory, even if they "
"never access the file system in any way.  In the future, there may be a "
"mechanism for kernel threads to explicitly relinquish any access to the file "
"system, such that this fairly intrusive mechanism can be removed from "
"B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:72
msgid ""
"Note that this also applies to the calling process: B<pivot_root>()  may or "
"may not affect its current working directory.  It is therefore recommended "
"to call B<chdir(\"/\")> immediately after B<pivot_root>()."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:74
msgid "The following restrictions apply to I<new_root> and I<put_old>:"
msgstr ""

#. type: IP
#: build/C/man2/pivot_root.2:74 build/C/man2/pivot_root.2:76 build/C/man2/pivot_root.2:79 build/C/man2/pivot_root.2:83
#, no-wrap
msgid "-"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:76
msgid "They must be directories."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:79
msgid ""
"I<new_root> and I<put_old> must not be on the same file system as the "
"current root."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:83
msgid ""
"I<put_old> must be underneath I<new_root>, that is, adding a nonzero number "
"of I</..> to the string pointed to by I<put_old> must yield the same "
"directory as I<new_root>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:85
msgid "No other file system may be mounted on I<put_old>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:89
msgid "See also B<pivot_root>(8)  for additional usage examples."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:96
msgid ""
"If the current root is not a mount point (e.g., after B<chroot>(2)  or "
"B<pivot_root>(), see also below), not the old root directory, but the mount "
"point of that file system is mounted on I<put_old>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:101
msgid ""
"I<new_root> does not have to be a mount point.  In this case, "
"I</proc/mounts> will show the mount point of the file system containing "
"I<new_root> as root (I</>)."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:110
msgid ""
"B<pivot_root>()  may return (in I<errno>) any of the errors returned by "
"B<stat>(2).  Additionally, it may return:"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:114
msgid ""
"I<new_root> or I<put_old> are on the current root file system, or a file "
"system is already mounted on I<put_old>."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:117
msgid "I<put_old> is not underneath I<new_root>."
msgstr ""

#. type: TP
#: build/C/man2/pivot_root.2:117
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:120
msgid "I<new_root> or I<put_old> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:125
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:128
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:131
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:138
msgid ""
"B<pivot_root>()  should not have to change root and current working "
"directory of all other processes in the system."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:143
msgid ""
"Some of the more obscure uses of B<pivot_root>()  may quickly lead to "
"insanity."
msgstr ""

#. type: Plain text
#: build/C/man2/pivot_root.2:149
msgid "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"
msgstr ""

#. type: TH
#: build/C/man2/process_vm_readv.2:29
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr ""

#. type: TH
#: build/C/man2/process_vm_readv.2:29
#, no-wrap
msgid "2012-04-25"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:32
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:35
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:42
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:49
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:57
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:82
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:96
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:106
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:113
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:129
msgid ""
"Buffers are processed in array order.  This means that B<process_vm_readv>()  "
"completely fills I<local_iov[0]> before proceeding to I<local_iov[1]>, and "
"so on.  Likewise, I<remote_iov[0]> is completely read before proceeding to "
"I<remote_iov[1]>, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:140
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:148
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:152
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr ""

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: build/C/man2/process_vm_readv.2:165
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less "
"than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible "
"via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:175
msgid ""
"The count arguments and I<local_iov> are checked before doing any "
"transfers.  If the counts are too big, or I<local_iov> is invalid, or the "
"addresses refer to regions that are inaccessible to the local process, none "
"of the vectors will be processed and an error will be returned immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:195
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep "
"this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4KiB) in a single remote I<iovec> element.  "
"(Instead, split the remote read into two I<remote_iov> elements and have "
"them merge back into a single write I<local_iov> entry.  The first read "
"entry goes up to the page boundary, while the second starts on the next page "
"boundary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:209
msgid ""
"In order to read from or write to another process, either the caller must "
"have the capability B<CAP_SYS_PTRACE>, or the real user ID, effective user "
"ID, and saved set-user-ID of the remote process must match the real user ID "
"of the caller I<and> the real group ID, effective group ID, and saved "
"set-group-ID of the remote process must match the real group ID of the "
"caller.  (The permission required is exactly the same as that required to "
"perform a B<ptrace>(2)  B<PTRACE_ATTACH> on the remote process.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:225
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that "
"splits a single I<iovec> element.)  The caller should check the return value "
"to determine whether a partial read/write occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:229
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:241
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:245
msgid "I<flags> is not 0."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:251
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:256
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:262
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:267
msgid "Could not allocate memory for internal copies of the I<iovec> structures."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:271
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:276
msgid "No process with ID I<pid> exists."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:279
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:281
msgid "These system calls are nonstandard Linux extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:287
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: build/C/man2/process_vm_readv.2:295
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or "
"pipes)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:303
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It "
"reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:306
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:316
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:323
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[1].iov_len = 20;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:330
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:334
msgid "B<readv>(2), B<writev>(2)"
msgstr ""

#. type: TH
#: build/C/man2/ptrace.2:44
#, no-wrap
msgid "PTRACE"
msgstr ""

#. type: TH
#: build/C/man2/ptrace.2:44
#, no-wrap
msgid "2013-02-16"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:47
msgid "ptrace - process trace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:50
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:53
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:62
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:73
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:75
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:79
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:85
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:96
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an "
"B<execve>(2).  Alternatively, one process may commence tracing another "
"process using B<PTRACE_ATTACH> or B<PTRACE_SEIZE>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:113
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:123
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:127
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:131
msgid "The value of I<request> determines the action to be performed:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:131
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:141
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:156
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT> and "
"B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:156
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:167
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:167
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr ""

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: build/C/man2/ptrace.2:185
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see "
"I<E<lt>sys/user.hE<gt>>).  The word is returned as the result of the "
"B<ptrace>()  call.  Typically, the offset must be word-aligned, though this "
"might vary by architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:185
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:197
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:197
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr ""

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:213
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:213
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:236
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>.  "
"B<PTRACE_GETREGS> and B<PTRACE_GETFPREGS> are not present on all "
"architectures."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:236
#, no-wrap
msgid "B<PTRACE_GETREGSET> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:257
msgid ""
"Read the tracee's registers.  I<addr> specifies, in an "
"architecture-dependent way, the type of registers to be read.  "
"B<NT_PRSTATUS> (with numerical value 1)  usually results in reading of "
"general-purpose registers.  If the CPU has, for example, floating-point "
"and/or vector registers, they can be retrieved by setting I<addr> to the "
"corresponding B<NT_foo> constant.  I<data> points to a B<struct iovec>, "
"which describes the destination buffer's location and length.  On return, "
"the kernel modifies B<iov.len> to indicate the actual number of bytes "
"returned."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:257
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:269
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:269
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr ""

#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:294
msgid ""
"Modify the tracee's general-purpose or floating-point registers, "
"respectively, from the address I<data> in the tracer.  As for "
"B<PTRACE_POKEUSER>, some general-purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)  Note that SPARC systems have the meaning "
"of I<data> and I<addr> reversed; that is, I<data> is ignored and the "
"registers are copied from the address I<addr>.  B<PTRACE_SETREGS> and "
"B<PTRACE_SETFPREGS> are not present on all architectures."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:294
#, no-wrap
msgid "B<PTRACE_SETREGSET> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:303
msgid ""
"Modify the tracee's registers.  The meaning of I<addr> and I<data> is "
"analogous to B<PTRACE_GETREGSET>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:303
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:319
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:319
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:328
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:329
#, no-wrap
msgid "B<PTRACE_O_EXITKILL> (since Linux 3.8)"
msgstr ""

#.  commit 992fb6e170639b0849bace8e49bf31bd37c4123
#. type: Plain text
#: build/C/man2/ptrace.2:337
msgid ""
"If a tracer sets this flag, a B<SIGKILL> signal will be sent to every tracee "
"if the tracer exits.  This option is useful for ptrace jailers that want to "
"ensure that tracees can never escape the tracer's control."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:337
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:349
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:352
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:356 build/C/man2/ptrace.2:437 build/C/man2/ptrace.2:465
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:377
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:377
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:386
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:389
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:395
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:395
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:403
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:406
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:410
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:418
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:418
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:430
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:433
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:437
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:446
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call.  (B<PTRACE_O_TRACESYSGOOD> "
"may not work on all architectures.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:446
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:458
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:461
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:465
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:474
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:477
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:481
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:482
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:502
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  (I<addr> is "
"ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:502
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:514
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:514
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:538
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:538
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr ""

#.  As at 3.7
#. type: Plain text
#: build/C/man2/ptrace.2:559
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
"but also singlestep if not a system call.  This call is used by programs "
"like User Mode Linux that want to emulate all the tracee's system calls.  "
"The I<data> argument is treated as for B<PTRACE_CONT>.  The I<addr> argument "
"is ignored.  These requests are currently supported only on x86."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:559
#, no-wrap
msgid "B<PTRACE_LISTEN> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:570
msgid ""
"Restart the stopped tracee, but prevent it from executing.  The resulting "
"state of the tracee is similar to a process which has been stopped by a "
"B<SIGSTOP> (or other stopping signal).  See the \"group-stop\" subsection "
"for additional information.  B<PTRACE_LISTEN> only works on tracees attached "
"by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:570
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:579
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: build/C/man2/ptrace.2:598
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:598
#, no-wrap
msgid "B<PTRACE_INTERRUPT> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:612
msgid ""
"Stop a tracee.  If the tracee is running, it will stop with "
"B<PTRACE_EVENT_STOP>.  If the tracee is already stopped by a signal, or "
"receives a signal in parallel with B<PTRACE_INTERRUPT>, it may report a "
"group-stop or a signal-delivery-stop instead of B<PTRACE_EVENT_STOP>.  "
"B<PTRACE_INTERRUPT> only works on tracees attached by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:612
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr ""

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: build/C/man2/ptrace.2:640
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:640
#, no-wrap
msgid "B<PTRACE_SEIZE> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:660
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  Unlike B<PTRACE_ATTACH>, B<PTRACE_SEIZE> does not stop the "
"process.  Only a B<PTRACE_SEIZE>d process can accept B<PTRACE_INTERRUPT> and "
"B<PTRACE_LISTEN> commands.  I<addr> must be zero.  I<data> contains a bit "
"mask of ptrace options to activate immediately."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:660
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:669
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:669
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:678
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:687
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term "
"\"signal-delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:699
msgid ""
"B<SIGKILL> does not generate signal-delivery-stop and therefore the tracer "
"can't suppress it.  B<SIGKILL> kills even within system calls "
"(syscall-exit-stop is not generated prior to death by B<SIGKILL>).  The net "
"effect is that B<SIGKILL> always kills the process (all its threads), even "
"if some threads of the process are ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:704
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:708
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:722
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), "
"B<exit_group>(2), and signal deaths (except B<SIGKILL>), and when threads "
"are torn down on B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:747
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  "
"I<waitpid(WNOHANG)> may return 0 instead.  In other words, the tracee may be "
"\"not yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:761
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:761
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:763
msgid "A tracee can be in two states: running or stopped."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:767
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:778
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  "
"Ptrace-stops can be further subdivided into I<signal-delivery-stop>, "
"I<group-stop>, I<syscall-stop>, and so on.  These stopped states are "
"described in detail below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:783
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:785
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr ""

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: build/C/man2/ptrace.2:797
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:805
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:812
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:820
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:829
#, no-wrap
msgid ""
"    errno = 0;\n"
"    ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"    if (errno == ESRCH) {\n"
"        /* tracee is dead */\n"
"        r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"        /* r can still be 0 here! */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:852
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, "
"group-stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the "
"I<WSTOPSIG(status)> macro can't be used to perform this examination, because "
"it returns the value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:852
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:872
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:886
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by "
"I<WSTOPSIG(status)>.  If the signal is B<SIGTRAP>, this may be a different "
"kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below "
"for details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be "
"a group-stop; see below."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:886
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:889
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:891
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:904
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:910
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:926
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few syscalls which use a different "
"mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  Even system "
"calls (such as B<poll>(2))  which are not restartable after signal are "
"restarted after signal is suppressed; however, kernel bugs exist which cause "
"some syscalls to fail with B<EINTR> even though no observable signal is "
"injected to the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:937
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than "
"signal-delivery-stop are not guaranteed to inject a signal, even if I<sig> "
"is nonzero.  No error is reported; a nonzero I<sig> may simply be ignored.  "
"Ptrace users should not try to \"create a new signal\" this way: use "
"B<tgkill>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:944
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:946
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:952
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:972
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before "
"signal-delivery-stop.  The tracer can't suppress this side effect (it can "
"only suppress signal injection, which only causes the B<SIGCONT> handler to "
"not be executed in the tracee, if such a handler is installed).  In fact, "
"waking up from group-stop may be followed by signal-delivery-stop for "
"signal(s)  I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> "
"was delivered.  In other words, B<SIGCONT> may be not the first signal "
"observed by the tracee after it was sent."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:976
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: build/C/man2/ptrace.2:986
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1003
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1003
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1015
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1024
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via "
"I<WSTOPSIG(status)>.  The same result is returned by some other classes of "
"ptrace-stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1026
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1047
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1056
msgid ""
"As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1070
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1081
msgid ""
"Since Linux 3.4, there is a method to overcome this problem: instead of "
"B<PTRACE_CONT>, a B<PTRACE_LISTEN> command can be used to restart a tracee "
"in a way where it does not execute, but waits for a new event which it can "
"report via B<waitpid>(2)  (such as when it is restarted by a B<SIGCONT>)."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1081
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1087
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter "
"ptrace-stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1101
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1103
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1105
msgid "The following events exist:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1105
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1118
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1118
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1126
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1126
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1130
msgid "Stop before return from B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1130
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1140
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1146
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1146
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1153
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1153
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1169
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1169
#, no-wrap
msgid "B<PTRACE_EVENT_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1174
msgid "Stop induced by B<PTRACE_INTERRUPT> command."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1186
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1186
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1199
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL>, the tracee enters "
"syscall-enter-stop just prior to entering any system call.  If the tracer "
"restarts the tracee with B<PTRACE_SYSCALL>, the tracee enters "
"syscall-exit-stop when the system call is finished, or if it is interrupted "
"by a signal.  (That is, signal-delivery-stop never happens between "
"syscall-enter-stop and syscall-exit-stop; it happens I<after> "
"syscall-exit-stop.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1213
msgid ""
"Other possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop, "
"exit (if it entered B<_exit>(2)  or B<exit_group>(2)), be killed by "
"B<SIGKILL>, or die silently (if it is a thread group leader, the "
"B<execve>(2)  happened in another thread, and that thread is not traced by "
"the same tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1228
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and "
"I<WSTOPSIG(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> "
"option was set by the tracer, then I<WSTOPSIG(status)> will give the value "
"I<(SIGTRAP\\ |\\ 0x80)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1234
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1234
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1246
msgid ""
"B<SIGTRAP> was delivered as a result of a user-space action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1246
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1250
msgid "B<SIGTRAP> was sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1250
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1253
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1258
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1281
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in "
"syscall-enter-stop.  Since B<SIGTRAP> (like any other signal) always happens "
"I<after> syscall-exit-stop, and at this point I<rax> almost never contains "
"-B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not "
"syscall-enter-stop\"; in other words, it looks like a \"stray "
"syscall-exit-stop\" and can be detected this way.  But such detection is "
"fragile and is best avoided."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1287
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1298
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as "
"syscall-exit-stop or vice versa.  The rule is that syscall-enter-stop is "
"always followed by syscall-exit-stop, B<PTRACE_EVENT> stop or the tracee's "
"death; no other kinds of ptrace-stop can occur in between."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1303
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1315
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1315
#, no-wrap
msgid "PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops"
msgstr ""

#
#.  FIXME
#.  document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
#.  PTRACE_SYSEMU_SINGLESTEP
#. type: Plain text
#: build/C/man2/ptrace.2:1321
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1321
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1331
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, "
"B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT>, and B<PTRACE_KILL>)  require the "
"tracee to be in a ptrace-stop, otherwise they fail with B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1336
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1348
#, no-wrap
msgid ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"    ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1360
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1362
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1364
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1373
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1376
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1378
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1399
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, "
"B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or "
"B<PTRACE_SYSEMU_SINGLESTEP>.  If the tracee is in signal-delivery-stop, "
"I<sig> is the signal to be injected (if it is nonzero).  Otherwise, I<sig> "
"may be ignored.  (When restarting a tracee from a ptrace-stop other than "
"signal-delivery-stop, recommended practice is to always pass 0 in I<sig>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1399
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1401
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1403
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1405 build/C/man2/ptrace.2:1894
msgid "or"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1407
#, no-wrap
msgid "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#
#.  FIXME: Describe how to attach to a thread which is already
#.         group-stopped.
#. type: Plain text
#: build/C/man2/ptrace.2:1432
msgid ""
"B<PTRACE_ATTACH> sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1439
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1450
msgid ""
"Since Linux 3.4, B<PTRACE_SEIZE> can be used instead of B<PTRACE_ATTACH>.  "
"B<PTRACE_SEIZE> does not stop the attached process. If you need to stop it "
"after attach (or at any other time) without sending it any signals, use "
"B<PTRACE_INTERRUPT> command."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1452
msgid "The request"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1454
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1460
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1462
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1465
msgid ""
"and allow the parent (which is our tracer now) to observe our "
"signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1489
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1491
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1493
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1501
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME: Describe how to detach from a group-stopped tracee so that it
#.         doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: build/C/man2/ptrace.2:1525
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1533
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from "
"signal-delivery-stop, the pending signal is injected."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1533
#, no-wrap
msgid "execve(2) under ptrace"
msgstr ""

#.  clone(2) CLONE_THREAD says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: build/C/man2/ptrace.2:1552
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1562
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1570
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1576
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1597
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1600
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1620
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0).  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1626
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1634
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1636
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1640
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1651
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1674
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, the kernel delivers an extra B<SIGTRAP> to the tracee after "
"B<execve>(2)  returns.  This is an ordinary signal (similar to one which can "
"be generated by I<kill -TRAP>), not a special kind of ptrace-stop.  "
"Employing B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set to 0 "
"(I<SI_USER>).  This signal may be blocked by signal mask, and thus may be "
"delivered (much) later."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1693
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option and thus suppressing this extra "
"B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1693
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1700
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1703
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1705
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1713
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1727
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must clear I<errno> before the call, and then "
"check it afterward to determine whether or not an error occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1731
msgid "(i386 only) There was an error with allocating or freeing a debug register."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1742
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1745
msgid "An attempt was made to set an invalid option."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1752
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a "
"word-alignment violation, or an invalid signal was specified during a "
"restart request."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1765
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(8)  (PID 1)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1770
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1772
msgid "SVr4, 4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1787
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  It is recommended to "
"always supply four arguments, even if the requested operation does not use "
"them, setting unused/ignored arguments to I<0L> or I<(void\\ *)\\ 0>."
msgstr ""

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: build/C/man2/ptrace.2:1792
msgid ""
"In Linux kernels before 2.6.26, B<init>(8), the process with PID 1, may not "
"be traced."
msgstr ""

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: build/C/man2/ptrace.2:1799
msgid ""
"The layout of the contents of memory and the USER area are quite "
"operating-system- and architecture-specific.  The offset supplied, and the "
"data returned, might not entirely match with the definition of I<struct "
"user>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1802
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1810
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of UNIX.  In any case, use "
"of B<ptrace>()  is highly specific to the operating system and architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1821
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1824
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME: ^^^ need to test/verify this scenario
#. type: Plain text
#: build/C/man2/ptrace.2:1855
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls "
"B<execve>(2), the death of the thread group leader will I<never> be "
"reported.  If the execed thread is not traced by this tracer, the tracer "
"will never know that B<execve>(2)  happened.  One possible workaround is to "
"B<PTRACE_DETACH> the thread group leader instead of restarting it in this "
"case.  Last confirmed on 2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1865
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on "
"2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1883
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor.  The usual symptom of this bug is "
"that when you attach to a quiescent process with the command"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1885
#, no-wrap
msgid "    strace -p E<lt>process-IDE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1888
msgid "then, instead of the usual and expected one-line output such as"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1891
#, no-wrap
msgid "    restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1897
#, no-wrap
msgid "    select(6, [5], NULL, [5], NULL_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1901
msgid ""
"('_' denotes the cursor position), you observe more than one line.  For "
"example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1905
#, no-wrap
msgid ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1926
msgid ""
"What is not visible here is that the process was blocked in B<epoll_wait>(2)  "
"before B<strace>(1)  has attached to it.  Attaching caused B<epoll_wait>(2)  "
"to return to user space with the error B<EINTR>.  In this particular case, "
"the program reacted to B<EINTR> by checking the current time, and then "
"executing B<epoll_wait>(2)  again.  (Programs which do not expect such "
"\"stray\" B<EINTR> errors may behave in an unintended way upon an "
"B<strace>(1)  attach.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1940
msgid ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), "
"B<gettid>(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), "
"B<exec>(3), B<capabilities>(7), B<signal>(7)"
msgstr ""

#. type: TH
#: build/C/man2/quotactl.2:27
#, no-wrap
msgid "QUOTACTL"
msgstr ""

#. type: TH
#: build/C/man2/quotactl.2:27
#, no-wrap
msgid "2010-06-16"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:30
msgid "quotactl - manipulate disk quotas"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:37
#, no-wrap
msgid ""
"B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, "
"caddr_t >I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:49
msgid ""
"The quota system can be used to set per-user and per-group limits on the "
"amount of disk space used on a file system.  For each user and/or group, a "
"soft limit and a hard limit can be set for each file system.  The hard limit "
"can't be exceeded.  The soft limit can be exceeded, but warnings will "
"ensue.  Moreover, the user can't exceed the soft limit for more than one "
"week (by default) at a time; after this time, the soft limit counts as a "
"hard limit."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:74
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, or "
"B<GRPQUOTA>, for group quotas.  The I<subcmd> value is described below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:79
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the file system being "
"manipulated."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:87
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each command below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:91
msgid "The I<subcmd> value is one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:91
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:98
msgid ""
"Turn on quotas for a file system.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported "
"quota formats:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:99
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:102
msgid "The original quota format."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:102
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:106
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:106
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:110
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64 "
"bytes and 2^64 inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:121
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the file system.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:121
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:131
msgid ""
"Turn off quotas for a file system.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:131
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:142
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:147 build/C/man2/quotactl.2:234
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:167
#, no-wrap
msgid ""
"struct dqblk {          /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;   /* absolute limit on disk\n"
"                                  quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;   /* preferred limit on\n"
"                                  disk quota blocks */\n"
"    uint64_t dqb_curspace;     /* current quota block\n"
"                                  count */\n"
"    uint64_t dqb_ihardlimit;   /* maximum number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_isoftlimit;   /* preferred inode limit */\n"
"    uint64_t dqb_curinodes;    /* current number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_btime;        /* time limit for excessive\n"
"                                  disk use */\n"
"    uint64_t dqb_itime;        /* time limit for excessive\n"
"                                  files */\n"
"    uint32_t dqb_valid;        /* bit mask of QIF_*\n"
"                                  constants */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:170
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:181
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:198
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:198
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:218
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and "
"B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:218
#, no-wrap
msgid "B<Q_GETINFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:229
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:238
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;    /* Time before block soft limit\n"
"                               becomes hard limit */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:245
#, no-wrap
msgid ""
"    uint64_t dqi_igrace;    /* Time before inode soft limit\n"
"                               becomes hard limit */\n"
"    uint32_t dqi_flags;     /* Flags for quotafile\n"
"                               (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:247
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:249
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:251
#, no-wrap
msgid "#define V1_DQF_RSQUASH\t1   /* Root squash enabled */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:253
#, no-wrap
msgid "/* Other quota formats have no dqi_flags bits defined */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:256
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:261
#, no-wrap
msgid ""
"# define IIF_BGRACE\t1\n"
"# define IIF_IGRACE\t2\n"
"# define IIF_FLAGS\t4\n"
"# define IIF_ALL\t(IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:277
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of "
"the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:277
#, no-wrap
msgid "B<Q_SETINFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:301
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure "
"indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:301
#, no-wrap
msgid "B<Q_GETFMT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:308
msgid ""
"Get quota format used on the specified file system.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:308
#, no-wrap
msgid "B<Q_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:319
msgid ""
"Update the on-disk copy of quota usages for a file system.  If I<special> is "
"NULL, then all file systems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:319
#, no-wrap
msgid "B<Q_GETSTATS>"
msgstr ""

#.  Q_GETSTATS was removed in kernel 2.4.22.
#. type: Plain text
#: build/C/man2/quotactl.2:339
msgid ""
"Get statistics and other generic information about the quota subsystem.  The "
"I<addr> argument should be a pointer to a I<dqstats> structure in which data "
"should be stored.  This structure is defined in I<E<lt>sys/quota.hE<gt>.> "
"The I<special> and I<id> arguments are ignored.  This operation is obsolete "
"and not supported by recent kernels.  Files in I</proc/sys/fs/quota/> carry "
"the information instead."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:342
msgid ""
"For XFS file systems making use of the XFS Quota Manager (XQM), the above "
"commands are bypassed and the following commands are used:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:342
#, no-wrap
msgid "B<Q_XQUOTAON>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:363
msgid ""
"Turn on quotas for an XFS file system.  XFS provides the ability to turn "
"on/off quota limit enforcement with quota accounting.  Therefore, XFS "
"expects I<addr> to be a pointer to an I<unsigned int> that contains either "
"the flags B<XFS_QUOTA_UDQ_ACCT> and/or B<XFS_QUOTA_UDQ_ENFD> (for user "
"quota), or B<XFS_QUOTA_GDQ_ACCT> and/or B<XFS_QUOTA_GDQ_ENFD> (for group "
"quota), as defined in I<E<lt>xfs/xqm.hE<gt>>.  This operation requires "
"privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:363
#, no-wrap
msgid "B<Q_XQUOTAOFF>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:374
msgid ""
"Turn off quotas for an XFS file system.  As with B<Q_QUOTAON>, XFS file "
"systems expect a pointer to an I<unsigned int> that specifies whether quota "
"accounting and/or limit enforcement need to be turned off.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:374
#, no-wrap
msgid "B<Q_XGETQUOTA>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:388
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure (defined in "
"I<E<lt>xfs/xqm.hE<gt>>).  Unprivileged users may retrieve only their own "
"quotas; a privileged user (B<CAP_SYS_ADMIN>)  may retrieve the quotas of any "
"user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:388
#, no-wrap
msgid "B<Q_XSETQLIM>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:400
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure (defined in I<E<lt>xfs/xqm.hE<gt>>).  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:400
#, no-wrap
msgid "B<Q_XGETQSTAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:408
msgid ""
"Returns an I<fs_quota_stat> structure containing XFS file system specific "
"quota information.  This is useful for finding out how much space is used to "
"store quota information, and also to get quotaon/off status of a given local "
"XFS file system."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:408
#, no-wrap
msgid "B<Q_XQUOTARM>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:412
msgid ""
"Free the disk space taken by disk quotas.  Quotas must have already been "
"turned off."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:419
msgid ""
"There is no command equivalent to B<Q_SYNC> for XFS since B<sync>(1)  writes "
"quota information to disk (in addition to the other file system metadata "
"that it writes out)."
msgstr ""

#. type: SH
#: build/C/man2/quotactl.2:419
#, no-wrap
msgid "RETURN VALUES"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:427
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:434
msgid "I<addr> or I<special> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:440
msgid "I<cmd> or I<type> is invalid."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:440
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:447
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:452
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:452
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:456
msgid "I<special> is not a block device."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:461
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:465
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this file system."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:474
msgid "If I<cmd> is B<Q_SETQUOTA>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:477
msgid "Specified limits are out of range allowed by quota format."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:486
msgid "If I<cmd> is B<Q_QUOTAON>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:495
msgid ""
"The quota file pointed to by I<addr> exists, but is not a regular file; or, "
"the quota file pointed to by I<addr> exists, but is not on the file system "
"pointed to by I<special>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:501
msgid "B<Q_QUOTAON> attempted, but another B<Q_QUOTAON> had already been performed."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:504
msgid "The quota file is corrupted."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:507
msgid "Specified quota format was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:512
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr ""

#. type: TH
#: build/C/man2/sendfile.2:19
#, no-wrap
msgid "SENDFILE"
msgstr ""

#. type: TH
#: build/C/man2/sendfile.2:19
#, no-wrap
msgid "2011-09-14"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:22
msgid "sendfile - transfer data between file descriptors"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:24
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr ""

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" \
#.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: build/C/man2/sendfile.2:47
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:57
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:62
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:83
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the current file offset of I<in_fd>; "
"otherwise the current file offset is adjusted to reflect the number of bytes "
"read from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:90
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"current file offset, and the file offset will be updated by the call."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:93
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:100
msgid ""
"The I<in_fd> argument must correspond to a file which supports "
"B<mmap>(2)-like operations (i.e., it cannot be a socket)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:108
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then "
"B<sendfile>()  changes the file offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:115
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:121
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""

#. type: TP
#: build/C/man2/sendfile.2:121 build/C/man2/splice.2:143 build/C/man2/vmsplice.2:123
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:125
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:128
msgid "Bad address."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:134
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:138
msgid "Unspecified error while reading from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:142
msgid "Insufficient memory to read from I<in_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:148
msgid ""
"B<sendfile>()  is a new feature in Linux 2.2.  The include file "
"I<E<lt>sys/sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:150
msgid "Not specified in POSIX.1-2001, or other standards."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:155
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:165
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:171
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file, and "
"B<sendfile>()  changed the current offset of that file."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:183
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:192
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:197
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary files (e.g., a pair of sockets)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:202
msgid "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/set_tid_address.2:25
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr ""

#. type: TH
#: build/C/man2/set_tid_address.2:25
#, no-wrap
msgid "2012-07-19"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:28
msgid "set_tid_address - set pointer to thread ID"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:33
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:40
msgid ""
"For each process, the kernel maintains two attributes (addresses) called "
"I<set_child_tid> and I<clear_child_tid>.  These two attributes contain the "
"value NULL by default."
msgstr ""

#. type: TP
#: build/C/man2/set_tid_address.2:40
#, no-wrap
msgid "I<set_child_tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:51
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to the value passed in the I<ctid> argument of "
"that system call."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:56
msgid ""
"When I<set_child_tid> is set, the very first thing the new process does is "
"writing its PID at this address."
msgstr ""

#. type: TP
#: build/C/man2/set_tid_address.2:56
#, no-wrap
msgid "I<clear_child_tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:67
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to the value passed in the I<ctid> argument "
"of that system call."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:74
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling process to I<tidptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:82
msgid ""
"When a process whose I<clear_child_tid> is not NULL terminates, then, if the "
"process is sharing memory with other processes or threads, then 0 is written "
"at the address specified in I<clear_child_tid> and the kernel performs the "
"following operation:"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:84
#, no-wrap
msgid "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:88
msgid ""
"The effect of this operation is to wake a single process that is performing "
"a futex wait on the memory location.  Errors from the futex wake operation "
"are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:91
msgid "B<set_tid_address>()  always returns the PID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:94
msgid "B<set_tid_address>()  always succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:97
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""

#. type: Plain text
#: build/C/man2/set_tid_address.2:102
msgid "B<clone>(2), B<futex>(2)"
msgstr ""

#. type: TH
#: build/C/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr ""

#. type: TH
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "2012-05-04"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:33 build/C/man2/tee.2:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#.  Return type was long before glibc 2.7
#. type: Plain text
#: build/C/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the descriptors must refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:80
msgid ""
"If I<fd_in> refers to a pipe, then I<off_in> must be NULL.  If I<fd_in> does "
"not refer to a pipe and I<off_in> is NULL, then bytes are read from I<fd_in> "
"starting from the current file offset, and the current file offset is "
"adjusted appropriately.  If I<fd_in> does not refer to a pipe and I<off_in> "
"is not NULL, then I<off_in> must point to a buffer which specifies the "
"starting offset from which bytes will be read from I<fd_in>; in this case, "
"the current file offset of I<fd_in> is not changed.  Analogous statements "
"apply for I<fd_out> and I<off_out>."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:85 build/C/man2/vmsplice.2:78
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:85 build/C/man2/tee.2:62 build/C/man2/vmsplice.2:78
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:98
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:98 build/C/man2/tee.2:68 build/C/man2/vmsplice.2:84
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:107
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:107 build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:121
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:121 build/C/man2/tee.2:79 build/C/man2/vmsplice.2:97
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:127
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:136
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe.  A return value of 0 means that there was no data to "
"transfer, and it would not make sense to block, because there are no writers "
"connected to the write end of the pipe referred to by I<fd_in>."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:142
msgid "On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:147
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: build/C/man2/splice.2:155
msgid ""
"Target file system doesn't support splicing; target file is opened in append "
"mode; neither of the descriptors refers to a pipe; or offset given for "
"nonseekable device."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:158 build/C/man2/tee.2:114 build/C/man2/vmsplice.2:138
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:158
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:165
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:170
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:182
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"user-space programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""

#. type: TP
#: build/C/man2/splice.2:182
#, no-wrap
msgid "B<splice>()"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:186
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:186
#, no-wrap
msgid "B<tee>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:189
msgid "\"copies\" the data from one buffer to another."
msgstr ""

#. type: TP
#: build/C/man2/splice.2:189
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:192
msgid "\"copies\" data from user space into the buffer."
msgstr ""

#
#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: build/C/man2/splice.2:223
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:226
msgid "See B<tee>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/splice.2:230
msgid "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/tee.2:26
#, no-wrap
msgid "TEE"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:29
msgid "tee - duplicating pipe content"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:36
#, no-wrap
msgid ""
"B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned "
"int >I<flags>B<);>\n"
msgstr ""

#.  Example programs http://brick.kernel.dk/snaps
#
#
#.  add a "tee(in, out1, out2)" system call that duplicates the pages
#.  (again, incrementing their reference count, not copying the data) from
#.  one pipe to two other pipes.
#. type: Plain text
#: build/C/man2/tee.2:56
msgid ""
"B<tee>()  duplicates up to I<len> bytes of data from the pipe referred to by "
"the file descriptor I<fd_in> to the pipe referred to by the file descriptor "
"I<fd_out>.  It does not consume the data that is duplicated from I<fd_in>; "
"therefore, that data can be copied by a subsequent B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:62
msgid ""
"I<flags> is a series of modifier flags, which share the name space with "
"B<splice>(2)  and B<vmsplice>(2):"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:68
msgid "Currently has no effect for B<tee>(); see B<splice>(2)."
msgstr ""

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:79
msgid ""
"Currently has no effect for B<tee>(), but may be implemented in the future; "
"see B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:85
msgid "Unused for B<tee>(); see B<vmsplice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:94
msgid ""
"Upon successful completion, B<tee>()  returns the number of bytes that were "
"duplicated between the input and output.  A return value of 0 means that "
"there was no data to transfer, and it would not make sense to block, because "
"there are no writers connected to the write end of the pipe referred to by "
"I<fd_in>."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:100
msgid "On error, B<tee>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:111
msgid ""
"I<fd_in> or I<fd_out> does not refer to a pipe; or I<fd_in> and I<fd_out> "
"refer to the same pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:119
msgid ""
"The B<tee>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:130
msgid ""
"Conceptually, B<tee>()  copies the data between the two pipes.  In reality "
"no real data copying takes place though: under the covers, B<tee>()  assigns "
"data in the output by merely grabbing a reference to the input."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:136
msgid ""
"The following example implements a basic B<tee>(1)  program using the "
"B<tee>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:145
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:151
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:156
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:162
#, no-wrap
msgid ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:169
#, no-wrap
msgid ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:178
#, no-wrap
msgid ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:192
#, no-wrap
msgid ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:196
#, no-wrap
msgid ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/tee.2:200
msgid "B<splice>(2), B<vmsplice>(2)"
msgstr ""

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr ""

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:46
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28 it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:50
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:52
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:62
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"user-space data."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:66
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:71
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should only exist within vm86 mode itself.)"
msgstr ""

#. type: Plain text
#: build/C/man2/vm86.2:74
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: TH
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:29
msgid "vmsplice - splice user pages into a pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int "
">I<flags>B<);>\n"
msgstr ""

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#. type: Plain text
#: build/C/man2/vmsplice.2:57
msgid ""
"The B<vmsplice>()  system call maps I<nr_segs> ranges of user memory "
"described by I<iov> into a pipe.  The file descriptor I<fd> must refer to a "
"pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:64
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:71
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;            /* Starting address */\n"
"    size_t iov_len;             /* Number of bytes */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:84
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:97
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""

#.  FIXME Explain the following line in a little more detail:
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: build/C/man2/vmsplice.2:113
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, or page cache and on-disk data may differ.  Gifting pages "
"to the kernel means that a subsequent B<splice>(2)  B<SPLICE_F_MOVE> can "
"successfully move the pages; if this flag is not specified, then a "
"subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the pages.  Data must "
"also be properly page aligned, both in memory and length."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:122
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:127
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:135
msgid ""
"I<nr_segs> is 0 or greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:143
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:154
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on number of segments being passed in.  This limit "
"is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  At the time of this "
"writing, that limit is 1024."
msgstr ""

#. type: Plain text
#: build/C/man2/vmsplice.2:157
msgid "B<splice>(2), B<tee>(2)"
msgstr ""

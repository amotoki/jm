# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-22 04:25+0900\n"
"PO-Revision-Date: 2012-03-21 23:57+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/arch_prctl.2:24
#, no-wrap
msgid "ARCH_PRCTL"
msgstr "ARCH_PRCTL"

#. type: TH
#: build/C/man2/arch_prctl.2:24
#, no-wrap
msgid "2007-12-26"
msgstr "2007-12-26"

#. type: TH
#: build/C/man2/arch_prctl.2:24 build/C/man2/futex.2:17
#: build/C/man2/kexec_load.2:25 build/C/man2/lookup_dcookie.2:27
#: build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:8
#: build/C/man2/outb.2:28 build/C/man2/pciconfig_read.2:5
#: build/C/man2/personality.2:30 build/C/man2/pivot_root.2:7
#: build/C/man2/ptrace.2:48 build/C/man2/quotactl.2:25
#: build/C/man2/sendfile.2:15 build/C/man2/set_tid_address.2:23
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/arch_prctl.2:24 build/C/man2/futex.2:17
#: build/C/man2/kexec_load.2:25 build/C/man2/lookup_dcookie.2:27
#: build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:8
#: build/C/man2/outb.2:28 build/C/man2/pciconfig_read.2:5
#: build/C/man2/personality.2:30 build/C/man2/pivot_root.2:7
#: build/C/man2/ptrace.2:48 build/C/man2/quotactl.2:25
#: build/C/man2/sendfile.2:15 build/C/man2/set_tid_address.2:23
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/arch_prctl.2:25 build/C/man2/futex.2:18
#: build/C/man2/kexec_load.2:26 build/C/man2/lookup_dcookie.2:28
#: build/C/man2/modify_ldt.2:26 build/C/man2/nfsservctl.2:9
#: build/C/man2/outb.2:29 build/C/man2/pciconfig_read.2:6
#: build/C/man2/personality.2:31 build/C/man2/pivot_root.2:8
#: build/C/man2/ptrace.2:49 build/C/man2/quotactl.2:26
#: build/C/man2/sendfile.2:16 build/C/man2/set_tid_address.2:24
#: build/C/man2/splice.2:27 build/C/man2/tee.2:27 build/C/man2/vm86.2:27
#: build/C/man2/vmsplice.2:27
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/arch_prctl.2:27
msgid "arch_prctl - set architecture-specific thread state"
msgstr "arch_prctl - アーキテクチャ固有のスレッド状態を設定する"

#. type: SH
#: build/C/man2/arch_prctl.2:27 build/C/man2/futex.2:20
#: build/C/man2/kexec_load.2:28 build/C/man2/lookup_dcookie.2:30
#: build/C/man2/modify_ldt.2:28 build/C/man2/nfsservctl.2:11
#: build/C/man2/pciconfig_read.2:8 build/C/man2/personality.2:33
#: build/C/man2/pivot_root.2:10 build/C/man2/ptrace.2:51
#: build/C/man2/quotactl.2:28 build/C/man2/sendfile.2:18
#: build/C/man2/set_tid_address.2:26 build/C/man2/splice.2:29
#: build/C/man2/tee.2:29 build/C/man2/vm86.2:29 build/C/man2/vmsplice.2:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/arch_prctl.2:30
#, no-wrap
msgid "B<#include E<lt>asm/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>asm/prctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/arch_prctl.2:32
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/arch_prctl.2:35
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr "B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"

#.  Return type was long before glibc 2.7
#. type: SH
#: build/C/man2/arch_prctl.2:36 build/C/man2/futex.2:32
#: build/C/man2/kexec_load.2:35 build/C/man2/lookup_dcookie.2:32
#: build/C/man2/modify_ldt.2:34 build/C/man2/nfsservctl.2:18
#: build/C/man2/outb.2:33 build/C/man2/pciconfig_read.2:19
#: build/C/man2/personality.2:37 build/C/man2/pivot_root.2:12
#: build/C/man2/ptrace.2:58 build/C/man2/quotactl.2:36
#: build/C/man2/sendfile.2:43 build/C/man2/set_tid_address.2:32
#: build/C/man2/splice.2:39 build/C/man2/tee.2:38 build/C/man2/vm86.2:35
#: build/C/man2/vmsplice.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/arch_prctl.2:51
msgid ""
"The B<arch_prctl>()  function sets architecture-specific process or thread "
"state.  I<code> selects a subfunction and passes argument I<addr> to it; "
"I<addr> is interpreted as either an I<unsigned long> for the \"set\" "
"operations, or as an I<unsigned long *>, for the \"get\" operations."
msgstr ""
"B<arch_prctl>()  関数はアーキテクチャ固有のプロセス状態またはスレッド状態を設"
"定する。 I<code> は副機能を選択し、引き数 I<addr> を副機能に渡す。 I<addr> "
"は、\"set\" 操作では I<unsigned long> として、\"get\" 操作では I<unsigned "
"long *> として解釈される。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:53
msgid "Sub functions for x86-64 are:"
msgstr "x86-64 の副機能は以下の通り:"

#. type: TP
#: build/C/man2/arch_prctl.2:53
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr "B<ARCH_SET_FS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:59
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr "I<FS> レジスタの 64 ビットベースを I<addr> に設定する。"

#. type: TP
#: build/C/man2/arch_prctl.2:59
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr "B<ARCH_GET_FS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:67
msgid ""
"Return the 64-bit base value for the I<FS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""
"現在のスレッドの I<FS> レジスタの 64 ビットベース値を、 I<addr> が指す "
"I<unsigned long> の領域に格納する。"

#. type: TP
#: build/C/man2/arch_prctl.2:67
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr "B<ARCH_SET_GS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:73
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr "I<GS> レジスタの 64 ビットベースを I<addr> に設定する。"

#. type: TP
#: build/C/man2/arch_prctl.2:73
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr "B<ARCH_GET_GS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:81
msgid ""
"Return the 64-bit base value for the I<GS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""
"現在のスレッドの I<GS> レジスタの 64 ビットベース値を、 I<addr> が指す "
"I<unsigned long> の領域に格納する。"

#. type: SH
#: build/C/man2/arch_prctl.2:81 build/C/man2/futex.2:173
#: build/C/man2/kexec_load.2:110 build/C/man2/lookup_dcookie.2:43
#: build/C/man2/modify_ldt.2:96 build/C/man2/nfsservctl.2:51
#: build/C/man2/pciconfig_read.2:47 build/C/man2/personality.2:55
#: build/C/man2/pivot_root.2:95 build/C/man2/ptrace.2:1566
#: build/C/man2/sendfile.2:104 build/C/man2/set_tid_address.2:80
#: build/C/man2/splice.2:127 build/C/man2/tee.2:85 build/C/man2/vm86.2:52
#: build/C/man2/vmsplice.2:113
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/arch_prctl.2:87
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<arch_prctl>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> をエラーを示す値に設定する。"

#. type: SH
#: build/C/man2/arch_prctl.2:87 build/C/man2/futex.2:210
#: build/C/man2/kexec_load.2:117 build/C/man2/lookup_dcookie.2:50
#: build/C/man2/modify_ldt.2:106 build/C/man2/pciconfig_read.2:74
#: build/C/man2/personality.2:62 build/C/man2/pivot_root.2:99
#: build/C/man2/ptrace.2:1580 build/C/man2/quotactl.2:425
#: build/C/man2/sendfile.2:111 build/C/man2/set_tid_address.2:83
#: build/C/man2/splice.2:142 build/C/man2/tee.2:100 build/C/man2/vm86.2:57
#: build/C/man2/vmsplice.2:122
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/arch_prctl.2:88 build/C/man2/futex.2:222
#: build/C/man2/lookup_dcookie.2:51 build/C/man2/modify_ldt.2:107
#: build/C/man2/ptrace.2:1584 build/C/man2/quotactl.2:426
#: build/C/man2/sendfile.2:121 build/C/man2/vm86.2:58
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:92
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""
"I<addr> がアンマップされたアドレスを指しているか、プロセスのアドレス空間の外"
"にある。"

#. type: TP
#: build/C/man2/arch_prctl.2:92 build/C/man2/futex.2:227
#: build/C/man2/kexec_load.2:122 build/C/man2/lookup_dcookie.2:54
#: build/C/man2/modify_ldt.2:111 build/C/man2/pciconfig_read.2:75
#: build/C/man2/personality.2:63 build/C/man2/pivot_root.2:108
#: build/C/man2/ptrace.2:1595 build/C/man2/quotactl.2:432
#: build/C/man2/quotactl.2:499 build/C/man2/sendfile.2:124
#: build/C/man2/splice.2:147 build/C/man2/tee.2:101
#: build/C/man2/vmsplice.2:127
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:96
msgid "I<code> is not a valid subcommand."
msgstr "I<code> が有効なサブコマンドでない。"

#. type: TP
#: build/C/man2/arch_prctl.2:96 build/C/man2/kexec_load.2:129
#: build/C/man2/lookup_dcookie.2:65 build/C/man2/pciconfig_read.2:102
#: build/C/man2/pivot_root.2:114 build/C/man2/ptrace.2:1605
#: build/C/man2/quotactl.2:454 build/C/man2/vm86.2:66
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: build/C/man2/arch_prctl.2:102
msgid "I<addr> is outside the process address space."
msgstr "I<addr> がプロセスのアドレス空間の外にある。"

#. type: SH
#: build/C/man2/arch_prctl.2:102 build/C/man2/futex.2:247
#: build/C/man2/kexec_load.2:138 build/C/man2/lookup_dcookie.2:78
#: build/C/man2/modify_ldt.2:128 build/C/man2/nfsservctl.2:56
#: build/C/man2/outb.2:58 build/C/man2/pciconfig_read.2:107
#: build/C/man2/personality.2:66 build/C/man2/pivot_root.2:122
#: build/C/man2/ptrace.2:1623 build/C/man2/sendfile.2:144
#: build/C/man2/set_tid_address.2:89 build/C/man2/splice.2:169
#: build/C/man2/tee.2:118 build/C/man2/vm86.2:71 build/C/man2/vmsplice.2:142
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/arch_prctl.2:106
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""
"B<arch_prctl>()  は Linux/x86-64 拡張であり、移植性を意図したプログラムでは使"
"うべきでない。"

#. type: SH
#: build/C/man2/arch_prctl.2:106 build/C/man2/futex.2:249
#: build/C/man2/kexec_load.2:140 build/C/man2/lookup_dcookie.2:81
#: build/C/man2/modify_ldt.2:131 build/C/man2/pivot_root.2:125
#: build/C/man2/ptrace.2:1625 build/C/man2/sendfile.2:151
#: build/C/man2/splice.2:171 build/C/man2/tee.2:120
#: build/C/man2/vmsplice.2:144
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/arch_prctl.2:109
msgid ""
"B<arch_prctl>()  is only supported on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""
"B<arch_prctl>()  は現在のところ Linux/x86-64 上の 64 ビットプログラムでのみサ"
"ポートされている。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:111
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""
"新しい 32 ビットセグメントセレクタがロードされた場合、 64 ビットベースは変更"
"される。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:114
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr "B<ARCH_SET_GS> が無効にされているカーネルもある。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:129
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  It may be a "
"faster alternative to set a 32-bit base using a segment selector by setting "
"up an LDT with B<modify_ldt>(2)  or using the B<set_thread_area>(2)  system "
"call in kernel 2.5 or later.  B<arch_prctl>()  is only needed when you want "
"to set bases that are larger than 4GB.  Memory in the first 2GB of address "
"space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> flag."
msgstr ""
"64 ビットセグメントベースのコンテキストスイッチは、やや高価である。 LDT を "
"B<modify_ldt>(2)  で設定してセグメントセレクタを使うか、 (カーネル 2.5 以降"
"の)  B<set_thread_area>(2)  システムコールを使うことにより、 32 ビットベース"
"を設定するという高速な代替手段もある。 4GB より大きなベースを設定したい場合に"
"のみ、 B<arch_prctl>()  が必要である。 アドレス空間の最初の 2GB にあるメモリ"
"は、 B<mmap>(2)  に B<MAP_32BIT> フラグを指定して割り当てることができる。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:134
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""
"バージョン 2.7 時点では、glibc には B<arch_prctl>()  のプロトタイプがない。 "
"今のところユーザは自分自身で宣言する必要がある。 これは将来の glibc のバー"
"ジョンで修正されるかもしれない。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:137
msgid "I<FS> may be already used by the threading library."
msgstr "I<FS> はスレッドライブラリで既に使われているかもしれない。"

#. type: SH
#: build/C/man2/arch_prctl.2:137 build/C/man2/futex.2:263
#: build/C/man2/kexec_load.2:155 build/C/man2/modify_ldt.2:134
#: build/C/man2/outb.2:67 build/C/man2/pciconfig_read.2:109
#: build/C/man2/pivot_root.2:137 build/C/man2/ptrace.2:1716
#: build/C/man2/quotactl.2:505 build/C/man2/sendfile.2:193
#: build/C/man2/set_tid_address.2:91 build/C/man2/splice.2:225
#: build/C/man2/tee.2:196 build/C/man2/vmsplice.2:153
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/arch_prctl.2:142
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"

#. type: Plain text
#: build/C/man2/arch_prctl.2:144
msgid "AMD X86-64 Programmer's manual"
msgstr "AMD X86-64 Programmer's manual"

#. type: SH
#: build/C/man2/arch_prctl.2:144 build/C/man2/futex.2:274
#: build/C/man2/kexec_load.2:158 build/C/man2/lookup_dcookie.2:88
#: build/C/man2/modify_ldt.2:136 build/C/man2/nfsservctl.2:58
#: build/C/man2/outb.2:70 build/C/man2/pciconfig_read.2:111
#: build/C/man2/personality.2:70 build/C/man2/pivot_root.2:143
#: build/C/man2/ptrace.2:1730 build/C/man2/quotactl.2:510
#: build/C/man2/sendfile.2:199 build/C/man2/set_tid_address.2:94
#: build/C/man2/splice.2:229 build/C/man2/tee.2:199 build/C/man2/vm86.2:74
#: build/C/man2/vmsplice.2:156
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/arch_prctl.2:151 build/C/man2/futex.2:281
#: build/C/man2/kexec_load.2:165 build/C/man2/lookup_dcookie.2:95
#: build/C/man2/modify_ldt.2:143 build/C/man2/nfsservctl.2:65
#: build/C/man2/outb.2:77 build/C/man2/pciconfig_read.2:118
#: build/C/man2/personality.2:77 build/C/man2/pivot_root.2:150
#: build/C/man2/ptrace.2:1737 build/C/man2/quotactl.2:517
#: build/C/man2/sendfile.2:206 build/C/man2/set_tid_address.2:101
#: build/C/man2/splice.2:236 build/C/man2/tee.2:206 build/C/man2/vm86.2:81
#: build/C/man2/vmsplice.2:163
msgid ""
"This page is part of release 3.37 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/futex.2:17
#, no-wrap
msgid "FUTEX"
msgstr "FUTEX"

#. type: TH
#: build/C/man2/futex.2:17
#, no-wrap
msgid "2010-08-29"
msgstr "2010-08-29"

#. type: Plain text
#: build/C/man2/futex.2:20
msgid "futex - Fast Userspace Locking system call"
msgstr "futex - 高速ユーザ空間ロック機構のシステムコール"

#. type: Plain text
#: build/C/man2/futex.2:25
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/futex.2:28
#, no-wrap
msgid "B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct timespec *>I<timeout>B<,>\n"
msgstr "B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct timespec *>I<timeout>B<,>\n"

#.  int *? void *? u32 *?
#. type: Plain text
#: build/C/man2/futex.2:31
#, no-wrap
msgid "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"

#. type: Plain text
#: build/C/man2/futex.2:48
msgid ""
"The B<futex>()  system call provides a method for a program to wait for a "
"value at a given address to change, and a method to wake up anyone waiting "
"on a particular address (while the addresses for the same memory in separate "
"processes may not be equal, the kernel maps them internally so the same "
"memory mapped in different locations will correspond for B<futex>()  "
"calls).  This system call is typically used to implement the contended case "
"of a lock in shared memory, as described in B<futex>(7)."
msgstr ""
"B<futex>()  システムコールは、 指定したアドレスの値が変更されるのをプログラム"
"が待つ手段や 特定のアドレスに対して待機中のプロセスを wake (起床) させる手段"
"を提供する (プロセスが異なれば同じメモリに対するアドレスも同じではないかもし"
"れないが、 カーネルは異なる位置にマップされた同じメモリを B<futex>()  で使え"
"るよう内部でマップする)。 通常は、このシステムコールは B<futex>(7)  に書かれ"
"ているように、 共有メモリ中のロックが競合する場合の処理を実装するのに用いられ"
"る。"

#. type: Plain text
#: build/C/man2/futex.2:55
msgid ""
"When a B<futex>(7)  operation did not finish uncontended in userspace, a "
"call needs to be made to the kernel to arbitrate.  Arbitration can either "
"mean putting the calling process to sleep or, conversely, waking a waiting "
"process."
msgstr ""
"B<futex>(7)  の操作がユーザ空間で競合なく完了しなかった場合、 カーネルに仲裁"
"させるためにシステムコールを呼ぶ必要がある。 仲裁というのは、呼び出しプロセス"
"を sleep (起床待ち) させたり、反対に 待ちプロセスを wake させたりすることを意"
"味する。"

#. type: Plain text
#: build/C/man2/futex.2:62
msgid ""
"Callers of this function are expected to adhere to the semantics as set out "
"in B<futex>(7).  As these semantics involve writing nonportable assembly "
"instructions, this in turn probably means that most users will in fact be "
"library authors and not general application developers."
msgstr ""
"この関数を呼び出すプロセスは B<futex>(7)  に記述されているセマンティクスに忠"
"実であることが要求される。 このセマンティクスには移植不可能なアセンブリ命令を"
"書くことが含まれる。 このことは言い換えると futex のユーザのほとんどは実際は"
"ライブラリの作者であり、 一般アプリケーションの開発者ではないということであ"
"る。"

#. type: Plain text
#: build/C/man2/futex.2:70
msgid ""
"The I<uaddr> argument needs to point to an aligned integer which stores the "
"counter.  The operation to execute is passed via the I<op> argument, along "
"with a value I<val>."
msgstr ""
"I<uaddr> 引き数は、カウンタを格納する、 アラインメントの揃った int 型変数を指"
"している必要がある。 実行する操作は I<op> 引き数を介して、値 I<val> とともに"
"渡される。"

#. type: Plain text
#: build/C/man2/futex.2:72
msgid "Five operations are currently defined:"
msgstr "現在のところ 5 つの操作が定義されている:"

#. type: TP
#: build/C/man2/futex.2:72 build/C/man2/futex.2:177
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr "B<FUTEX_WAIT>"

#. type: Plain text
#: build/C/man2/futex.2:90
msgid ""
"This operation atomically verifies that the futex address I<uaddr> still "
"contains the value I<val>, and sleeps awaiting B<FUTEX_WAKE> on this futex "
"address.  If the I<timeout> argument is non-NULL, its contents describe the "
"maximum duration of the wait, which is infinite otherwise.  The arguments "
"I<uaddr2> and I<val3> are ignored."
msgstr ""
"この操作は futex アドレス I<uaddr> に指定された値 I<val> がまだ格納されている"
"かどうかを不可分操作で検証し、 sleep 状態で この futex アドレスに対して "
"B<FUTEX_WAKE> が実行されるのを待つ。 I<timeout> 引き数が NULL でない場合、そ"
"の内容は 待ち時間の最大値を表す。NULL の場合は無限大を表す。 引き数 "
"I<uaddr2> と I<val3> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:98
msgid ""
"For B<futex>(7), this call is executed if decrementing the count gave a "
"negative value (indicating contention), and will sleep until another process "
"releases the futex and executes the B<FUTEX_WAKE> operation."
msgstr ""
"B<futex>(7)  に照らし合わせると、この呼び出しは カウントのデクリメントで負の"
"値 (競合を表す) になった場合に実行され、 別のプロセスがその futex を解放し "
"B<FUTEX_WAKE> の操作を実行するまで sleep する。"

#. type: TP
#: build/C/man2/futex.2:98 build/C/man2/futex.2:194
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr "B<FUTEX_WAKE>"

#. type: Plain text
#: build/C/man2/futex.2:109
msgid ""
"This operation wakes at most I<val> processes waiting on this futex address "
"(i.e., inside B<FUTEX_WAIT>).  The arguments I<timeout>, I<uaddr2> and "
"I<val3> are ignored."
msgstr ""
"この操作では指定した futex アドレスに対して待ち状態の (すなわち "
"B<FUTEX_WAIT> 中の) 最大 I<val> 個のプロセスを wake させる。 引き数 "
"I<timeout>, I<uaddr2>, I<val3> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:115
msgid ""
"For B<futex>(7), this is executed if incrementing the count showed that "
"there were waiters, once the futex value has been set to 1 (indicating that "
"it is available)."
msgstr ""
"B<futex>(4) に照らし合わせると、 この操作は カウントのインクリメントで待ちプ"
"ロセスがあると判明し、 futex 値が 1 に設定された (利用可能であることを表す) "
"場合に実行される。"

#. type: TP
#: build/C/man2/futex.2:115
#, no-wrap
msgid "B<FUTEX_FD> (present up to and including Linux 2.6.25)"
msgstr "B<FUTEX_FD> (Linux 2.6.25 以前)"

#.  , suitable for .BR poll (2).
#. type: Plain text
#: build/C/man2/futex.2:131
msgid ""
"To support asynchronous wakeups, this operation associates a file descriptor "
"with a futex.  If another process executes a B<FUTEX_WAKE>, the process will "
"receive the signal number that was passed in I<val>.  The calling process "
"must close the returned file descriptor after use.  The arguments "
"I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""
"非同期の wake に対応するため、この操作はファイルディスクリプタを futex に 関"
"連づける。 別のプロセスが B<FUTEX_WAKE> を実行すると、プロセスは I<val> で渡"
"されたシグナル番号のシグナルを受信する。 呼び出しプロセスは使用後、返された"
"ファイルディスクリプタを クローズしなければならない。 引き数 I<timeout>, "
"I<uaddr2>, I<val3> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:136
msgid ""
"To prevent race conditions, the caller should test if the futex has been "
"upped after B<FUTEX_FD> returns."
msgstr ""
"競合状態を防止するため、呼び出しプロセスは B<FUTEX_FD> が返ったあと futex が "
"up されたかどうかを確認しなければならない。"

#. type: Plain text
#: build/C/man2/futex.2:140
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""
"B<FUTEX_FD> はもともと競合が起きやすかったため、 Linux 2.6.26 以降で削除され"
"ている。"

#. type: TP
#: build/C/man2/futex.2:140
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.5.70)"
msgstr "B<FUTEX_REQUEUE> (Linux 2.5.70 以降)"

#. type: Plain text
#: build/C/man2/futex.2:155
msgid ""
"This operation was introduced in order to avoid a \"thundering herd\" effect "
"when B<FUTEX_WAKE> is used and all processes woken up need to acquire "
"another futex.  This call wakes up I<val> processes, and requeues all other "
"waiters on the futex at address I<uaddr2>.  The arguments I<timeout> and "
"I<val3> are ignored."
msgstr ""
"この操作は、 B<FUTEX_WAKE> が使われていて、かつ wake されている全てのプロセス"
"が 他の futex を取得する必要がある場合に、 「獣の群れの暴走 (thundering "
"herd)」効果を避けるために導入された。 この呼び出しは I<val> 個のプロセスを "
"wake し、アドレス I<uaddr2> で futex を待っている他の全てのプロセスを再度"
"キューにいれる。 引き数 I<timeout> と I<val3> は無視される。"

#. type: TP
#: build/C/man2/futex.2:155
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr "B<FUTEX_CMP_REQUEUE> (Linux 2.6.7 以降)"

#. type: Plain text
#: build/C/man2/futex.2:173
msgid ""
"There was a race in the intended use of B<FUTEX_REQUEUE>, so "
"B<FUTEX_CMP_REQUEUE> was introduced.  This is similar to B<FUTEX_REQUEUE>, "
"but first checks whether the location I<uaddr> still contains the value "
"I<val3>.  If not, the operation fails with the error B<EAGAIN>.  The "
"argument I<timeout> is ignored."
msgstr ""
"故意に B<FUTEX_REQUEUE> を使う場合に競合が起こるため、 B<FUTEX_CMP_REQUEUE> "
"が導入された。これは B<FUTEX_REQUEUE> と似ているが、場所 I<uaddr> に値 "
"I<val3> がまだ保持されているかを最初にチェックする。 保持されていない場合、操"
"作はエラー B<EAGAIN> で失敗する。引き数 I<timeout> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:177
msgid ""
"Depending on which operation was executed, the returned value for a "
"successful call can have differing meanings."
msgstr "どの操作が実行されたかによって、 成功時の返り値の意味が変わる。"

#. type: Plain text
#: build/C/man2/futex.2:194
msgid ""
"Returns 0 if the process was woken by a B<FUTEX_WAKE> call.  In case of "
"timeout, the operation fails with the error B<ETIMEDOUT>.  If the futex was "
"not equal to the expected value, the operation fails with the error "
"B<EWOULDBLOCK>.  Signals (see B<signal>(7))  or other spurious wakeups cause "
"B<FUTEX_WAIT> to fail with the error B<EINTR>."
msgstr ""
"プロセスが B<FUTEX_WAKE> の呼び出しで wake すると 0 を返す。 タイムアウトの場"
"合、操作はエラー B<ETIMEOUT> で失敗する。 futex が指定された値と等しくない場"
"合、 エラー B<EWOULDBLOCK> で失敗する。 シグナルを受信するか (B<signal>(7)  "
"参照) 他の偽の wake があった場合には、エラー B<EINTR> で失敗する。"

#. type: Plain text
#: build/C/man2/futex.2:197 build/C/man2/futex.2:203 build/C/man2/futex.2:206
msgid "Returns the number of processes woken up."
msgstr "wake したプロセスの数を返す。"

#. type: TP
#: build/C/man2/futex.2:197
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr "B<FUTEX_FD>"

#. type: Plain text
#: build/C/man2/futex.2:200
msgid "Returns the new file descriptor associated with the futex."
msgstr "futex に関連づけられた新たなファイルディスクリプタを返す。"

#. type: TP
#: build/C/man2/futex.2:200
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr "B<FUTEX_REQUEUE>"

#. type: TP
#: build/C/man2/futex.2:203
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr "B<FUTEX_CMP_REQUEUE>"

#. type: Plain text
#: build/C/man2/futex.2:210
msgid ""
"In the event of an error, all operations return -1, and set I<errno> to "
"indicate the error."
msgstr ""
"エラーの場合、全ての操作で -1 が返り、 I<errno> がエラーの内容を示す値に設定"
"される。"

#. type: TP
#: build/C/man2/futex.2:211 build/C/man2/quotactl.2:484
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/futex.2:214
msgid "No read access to futex memory."
msgstr "futex メモリに読み込みアクセス権がなかった。"

#. type: TP
#: build/C/man2/futex.2:214 build/C/man2/sendfile.2:112
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/futex.2:222
msgid ""
"B<FUTEX_CMP_REQUEUE> found an unexpected futex value.  (This probably "
"indicates a race; use the safe B<FUTEX_WAKE> now.)"
msgstr ""
"B<FUTEX_CMP_REQUEUE> で予期しない futex 値が見つかった (これは競合を示してい"
"るかもしれない。 この場合は安全な B<FUTEX_WAKE> を使うこと)。"

#. type: Plain text
#: build/C/man2/futex.2:227
msgid "Error in getting I<timeout> information from userspace."
msgstr "ユーザ空間から I<timeout> の情報を取得する際にエラーが発生した。"

#. type: Plain text
#: build/C/man2/futex.2:230
msgid "An operation was not defined or error in page alignment."
msgstr ""
"操作が定義されていない。またはページ・アラインメントでエラーが発生した。"

#. type: TP
#: build/C/man2/futex.2:230
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/futex.2:233
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされているファイルの総数がシステムの制限に達した。"

#. type: TP
#: build/C/man2/futex.2:233 build/C/man2/modify_ldt.2:124
#: build/C/man2/pciconfig_read.2:90 build/C/man2/quotactl.2:445
#: build/C/man2/vm86.2:62
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/futex.2:237
msgid "Invalid operation specified in I<op>."
msgstr "I<op> に無効な操作が指定された。"

#. type: SH
#: build/C/man2/futex.2:237 build/C/man2/kexec_load.2:134
#: build/C/man2/lookup_dcookie.2:73 build/C/man2/pivot_root.2:119
#: build/C/man2/sendfile.2:138 build/C/man2/set_tid_address.2:86
#: build/C/man2/splice.2:165 build/C/man2/tee.2:114
#: build/C/man2/vmsplice.2:138
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/futex.2:247
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A 4-argument system call with the semantics "
"described in this page was introduced in Linux 2.5.40.  In Linux 2.5.70 one "
"argument was added.  In Linux 2.6.7 a sixth argument was added\\(emmessy, "
"especially on the s390 architecture."
msgstr ""
"最初の futex 対応は Linux 2.5.7 で組み込まれたが、 上記のセマンティクスとは異"
"なる。 4 つの引き数のここに書かれているセマンティクスを持つ システムコール"
"は、Linux 2.5.40 で導入された。 Linux 2.5.70 では 1 つの引き数が追加された。 "
"Linux 2.6.7 では 6 番目の引き数が追加された。 これは汚く、s390 アーキテクチャ"
"上の特別のものである。"

#. type: Plain text
#: build/C/man2/futex.2:249 build/C/man2/kexec_load.2:140
#: build/C/man2/set_tid_address.2:91 build/C/man2/splice.2:171
#: build/C/man2/tee.2:120 build/C/man2/vmsplice.2:144
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#.  .SH "AUTHORS"
#.  .PP
#.  Futexes were designed and worked on by
#.  Hubertus Franke (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat)
#.  and Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: build/C/man2/futex.2:263
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end-users.  (There is no wrapper function for this system call in "
"glibc.)  Implementors are expected to be assembly literate and to have read "
"the sources of the futex userspace library referenced below."
msgstr ""
"繰り返すが、裸の futex はエンドユーザが容易に使うことのできる概念として 意図"
"されたものではない (glibc にはこのシステムコールに対するラッパー関数はな"
"い)。 実装者は、アセンブリ言語に慣れており、以下に挙げる futex ユーザ空間ライ"
"ブラリの ソースを読み終えていることが要求される。"

#. type: Plain text
#: build/C/man2/futex.2:265
msgid "B<futex>(7)"
msgstr "B<futex>(7)"

#. type: Plain text
#: build/C/man2/futex.2:268
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"
msgstr ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"

#. type: Plain text
#: build/C/man2/futex.2:270
msgid "http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf"
msgstr "http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf"

#. type: Plain text
#: build/C/man2/futex.2:272
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr "futex の使用例ライブラリ, futex-*.tar.bz2"

#. type: Plain text
#: build/C/man2/futex.2:274
msgid "ftp://ftp.nl.kernel.org/pub/linux/kernel/people/rusty/."
msgstr "ftp://ftp.nl.kernel.org/pub/linux/kernel/people/rusty/."

#. type: TH
#: build/C/man2/kexec_load.2:25
#, no-wrap
msgid "KEXEC_LOAD"
msgstr "KEXEC_LOAD"

#. type: TH
#: build/C/man2/kexec_load.2:25
#, no-wrap
msgid "2010-11-04"
msgstr "2010-11-04"

#. type: Plain text
#: build/C/man2/kexec_load.2:28
msgid "kexec_load - load a new kernel for later execution"
msgstr "kexec_load - load a new kernel for later execution"

#. type: Plain text
#: build/C/man2/kexec_load.2:30
msgid "B<#include E<lt>linux/kexec.hE<gt>>"
msgstr "B<#include E<lt>linux/kexec.hE<gt>>"

#. type: Plain text
#: build/C/man2/kexec_load.2:32
msgid ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long >I<nr_segments>B<,"
">"
msgstr ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long >I<nr_segments>B<,"
">"

#. type: Plain text
#: build/C/man2/kexec_load.2:35
msgid "B< struct kexec_segment *>I<segments>B<, unsigned long >I<flags>B<);>"
msgstr "B< struct kexec_segment *>I<segments>B<, unsigned long >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/kexec_load.2:40
msgid ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."
msgstr ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."

#. type: Plain text
#: build/C/man2/kexec_load.2:46
msgid ""
"The I<flags> argument is a mask whose high-order bits control the operation "
"of the call.  The following values can be specified in I<flags>:"
msgstr ""
"The I<flags> argument is a mask whose high-order bits control the operation "
"of the call.  The following values can be specified in I<flags>:"

#. type: TP
#: build/C/man2/kexec_load.2:46
#, no-wrap
msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgstr "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"

#.  FIXME figure out how this is really used
#. type: Plain text
#: build/C/man2/kexec_load.2:50
msgid "Execute the new kernel automatically on a system crash."
msgstr "Execute the new kernel automatically on a system crash."

#. type: TP
#: build/C/man2/kexec_load.2:50
#, no-wrap
msgid "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.7.27)"
msgstr "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.7.27)"

#. type: Plain text
#: build/C/man2/kexec_load.2:60
msgid ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is only available "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is only "
"effective if I<nr_segments> is greater than 0."
msgstr ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is only available "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is only "
"effective if I<nr_segments> is greater than 0."

#. type: Plain text
#: build/C/man2/kexec_load.2:80
msgid ""
"The low-order bits of I<flags> contain the architecture of the to-be-"
"executed kernel.  Specify (OR) the constant B<KEXEC_ARCH_DEFAULT> to use the "
"current architecture, or one of the following architecture constants "
"B<KEXEC_ARCH_386>, B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, "
"B<KEXEC_ARCH_PPC64>, B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, "
"B<KEXEC_ARCH_S390>, B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and "
"B<KEXEC_ARCH_MIPS_LE>.  The architecture must be executable on the CPU of "
"the system."
msgstr ""
"The low-order bits of I<flags> contain the architecture of the to-be-"
"executed kernel.  Specify (OR) the constant B<KEXEC_ARCH_DEFAULT> to use the "
"current architecture, or one of the following architecture constants "
"B<KEXEC_ARCH_386>, B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, "
"B<KEXEC_ARCH_PPC64>, B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, "
"B<KEXEC_ARCH_S390>, B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and "
"B<KEXEC_ARCH_MIPS_LE>.  The architecture must be executable on the CPU of "
"the system."

#. type: Plain text
#: build/C/man2/kexec_load.2:94
msgid ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"
msgstr ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"

#. type: Plain text
#: build/C/man2/kexec_load.2:103
#, no-wrap
msgid ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"
msgstr ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"

#.  FIXME elaborate on the following:
#. type: Plain text
#: build/C/man2/kexec_load.2:110
msgid ""
"The kernel image defined by I<segments> is copied from the calling process "
"into previously reserved memory."
msgstr ""
"The kernel image defined by I<segments> is copied from the calling process "
"into previously reserved memory."

#. type: Plain text
#: build/C/man2/kexec_load.2:117
msgid ""
"On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."

#. type: TP
#: build/C/man2/kexec_load.2:118 build/C/man2/pivot_root.2:104
#: build/C/man2/ptrace.2:1581 build/C/man2/quotactl.2:493
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/kexec_load.2:122
msgid ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."
msgstr ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."

#.  KEXEC_SEGMENT_MAX == 16
#. type: Plain text
#: build/C/man2/kexec_load.2:129
msgid "I<flags> is invalid; or I<nr_segments> is too large"
msgstr "I<flags> is invalid; or I<nr_segments> is too large"

#. type: Plain text
#: build/C/man2/kexec_load.2:134
msgid "The caller does not have the B<CAP_SYS_BOOT> capability."
msgstr "The caller does not have the B<CAP_SYS_BOOT> capability."

#. type: Plain text
#: build/C/man2/kexec_load.2:138
msgid "The B<kexec_load>()  system call first appeared in Linux 2.6.13."
msgstr "The B<kexec_load>()  system call first appeared in Linux 2.6.13."

#. type: Plain text
#: build/C/man2/kexec_load.2:145
msgid ""
"Currently, there is no glibc support for B<kexec_load>().  Call it using "
"B<syscall>(2)."
msgstr ""
"Currently, there is no glibc support for B<kexec_load>().  Call it using "
"B<syscall>(2)."

#.  FIXME Andi submitted a patch for this.
#.  Check if it got accepted later.
#. type: Plain text
#: build/C/man2/kexec_load.2:152
msgid ""
"The required constants are in the kernel source file I<linux/kexec.h>, which "
"is not currently exported to glibc.  Therefore, these constants must be "
"defined manually."
msgstr ""
"The required constants are in the kernel source file I<linux/kexec.h>, which "
"is not currently exported to glibc.  Therefore, these constants must be "
"defined manually."

#. type: Plain text
#: build/C/man2/kexec_load.2:155
msgid ""
"This system call is only available if the kernel was configured with "
"B<CONFIG_KEXEC>."
msgstr ""
"This system call is only available if the kernel was configured with "
"B<CONFIG_KEXEC>."

#. type: Plain text
#: build/C/man2/kexec_load.2:158
msgid "B<reboot>(2), B<syscall>(2)"
msgstr "B<reboot>(2), B<syscall>(2)"

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "LOOKUP_DCOOKIE"
msgstr "LOOKUP_DCOOKIE"

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "2004-06-17"
msgstr "2004-06-17"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:30
msgid "lookup_dcookie - return a directory entry's path"
msgstr "lookup_dcookie - ディレクトリ・エントリのパス名を返す"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:32
msgid ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t >I<len>B<);"
">"
msgstr ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t >I<len>B<);"
">"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:38
msgid ""
"Look up the full path of the directory entry specified by the value "
"I<cookie>.  The cookie is an opaque identifier uniquely identifying a "
"particular directory entry.  The buffer given is filled in with the full "
"path of the directory entry."
msgstr ""
"I<cookie> 値で指定されたディレクトリ・エントリのフルパス名を検索する。 "
"cookie は、個々のディレクトリ・エントリを区別する内部識別子 (opaque "
"identifier) である。引き数で指定されたバッファに、ディレクトリ・エントリの フ"
"ルパス名が格納される。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:43
msgid ""
"For B<lookup_dcookie>()  to return successfully, the kernel must still hold "
"a cookie reference to the directory entry."
msgstr ""
"B<lookup_dcookie>()  が正常に値を返すためには、カーネルがディレクトリ・エント"
"リへの cookie 参照を 保持していなければならない。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:50
msgid ""
"On success, B<lookup_dcookie>()  returns the length of the path string "
"copied into the buffer.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、 B<lookup_dcookie>()  はバッファにコピーしたパス文字列の長さを"
"返す。 エラーの場合は -1 を返し、 I<errno> に適切な値を設定する。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:54
msgid "The buffer was not valid."
msgstr "バッファが有効でなかった。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:58
msgid ""
"The kernel has no registered cookie/directory entry mappings at the time of "
"lookup, or the cookie does not refer to a valid directory entry."
msgstr ""
"検索が行われた時、cookie とディレクトリ・エントリのマッピングがカーネルに 登"
"録されていなかったか、または cookie が有効なディレクトリ・エントリを 参照して"
"いない。"

#. type: TP
#: build/C/man2/lookup_dcookie.2:58
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:61
msgid "The name could not fit in the buffer."
msgstr "名前がバッファに入り切らなかった。"

#. type: TP
#: build/C/man2/lookup_dcookie.2:61 build/C/man2/sendfile.2:134
#: build/C/man2/splice.2:155 build/C/man2/tee.2:111
#: build/C/man2/vmsplice.2:135
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:65
msgid ""
"The kernel could not allocate memory for the temporary buffer holding the "
"path."
msgstr ""
"カーネルが、パス名を保持する一時バッファ用のメモリを割り当てることが できな"
"かった。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:70
msgid ""
"The process does not have the capability B<CAP_SYS_ADMIN> required to look "
"up cookie values."
msgstr ""
"プロセスが cookie 値を検索するのに必要なケーパビリティ B<CAP_SYS_ADMIN> を"
"持っていない。"

#. type: TP
#: build/C/man2/lookup_dcookie.2:70 build/C/man2/quotactl.2:472
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:73
msgid ""
"The buffer was not large enough to hold the path of the directory entry."
msgstr ""
"バッファが、ディレクトリ・エントリのパス名を収容するのに 十分な大きさではな"
"かった。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:78
msgid ""
"Available since Linux 2.5.43.  The B<ENAMETOOLONG> error return was added in "
"2.5.70."
msgstr ""
"Linux 2.5.43 以降で利用できる。 エラー B<ENAMETOOLONG> を返す仕様は 2.5.70 で"
"追加された。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:81
msgid "B<lookup_dcookie>()  is Linux-specific."
msgstr "B<lookup_dcookie>()  は Linux 独自の関数である。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:85
msgid ""
"B<lookup_dcookie>()  is a special-purpose system call, currently used only "
"by the oprofile profiler.  It relies on a kernel driver to register cookies "
"for directory entries."
msgstr ""
"B<lookup_dcookie>()  は特殊な用途に使われるシステムコールで、現在のところ "
"oprofile profiler で 使われているだけである。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:88
msgid ""
"The path returned may be suffixed by the string \" (deleted)\" if the "
"directory entry has been removed."
msgstr ""
"指定されたディレクトリ・エントリが削除されていた場合、返されるパス名の最後に "
"\" (deleted)\" という文字列が付加されることがある。"

#. type: TH
#: build/C/man2/modify_ldt.2:25
#, no-wrap
msgid "MODIFY_LDT"
msgstr "MODIFY_LDT"

#. type: TH
#: build/C/man2/modify_ldt.2:25 build/C/man2/pivot_root.2:7
#, no-wrap
msgid "2007-06-01"
msgstr "2007-06-01"

#. type: Plain text
#: build/C/man2/modify_ldt.2:28
msgid "modify_ldt - get or set ldt"
msgstr "modify_ldt - ldt を設定または取得する"

#. type: Plain text
#: build/C/man2/modify_ldt.2:31
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/modify_ldt.2:33
#, no-wrap
msgid "B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long >I<bytecount>B<);>\n"
msgstr "B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long >I<bytecount>B<);>\n"

#. type: Plain text
#: build/C/man2/modify_ldt.2:39
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (ldt) for a "
"process.  The ldt is a per-process memory management table used by the i386 "
"processor.  For more information on this table, see an Intel 386 processor "
"handbook."
msgstr ""
"B<modify_ldt>()  はプロセスのローカル・ディスクリプタ・テーブル (local "
"descriptor table; ldt)  を読み書きする。 ldt は i386 プロセッサで使用されるプ"
"ロセスごとのメモリ管理テーブルである。 このテーブルに関してのより詳しい情報"
"は Intel 386 processor handbook を 参照すること。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:49
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the ldt into the memory pointed to "
"by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the "
"actual size of the ldt."
msgstr ""
"I<func> が 0 ならば、 B<modify_ldt>()  は ldt を I<ptr> が指しているメモリに"
"読み込む。 読み込むバイト数は実際の ldt のサイズか I<bytecount> より小さい方"
"である。"

#.  FIXME ? say something about func == 2 and func == 0x11?
#.  In Linux 2.4, func == 2 returned "the default ldt"
#.  In Linux 2.6, func == 2 is a nop, returning a zeroed out structure.
#.  Linux 2.4 and 2.6 implement an operation for func == 0x11
#. type: Plain text
#: build/C/man2/modify_ldt.2:67
msgid ""
"When I<func> is 1, B<modify_ldt>()  modifies one ldt entry.  I<ptr> points "
"to a I<user_desc> structure and I<bytecount> must equal the size of this "
"structure."
msgstr ""
"I<func> が 1 ならば、 B<modify_ldt>()  は ldt エントリの一つを変更する。 "
"I<ptr> は I<user_desc> 構造体を指し、 I<bytecount> はこの構造体の大きさに等し"
"くなければならない。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:71
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""
"I<user_desc> 構造体は I<E<lt>asm/ldt.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/modify_ldt.2:85
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"

#.  .PP
#.  The ldt is specific for the calling process. Any attempts to change
#.  the ldt to include the address space of another process or the kernel
#.  will result in a segmentation violation when trying to access the memory
#.  outside of the process address space. The memory protection is enforced
#.  at the paging layer.
#. type: Plain text
#: build/C/man2/modify_ldt.2:96
msgid "In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""
"Linux 2.4 以前では、この構造体は I<modify_ldt_ldt_s> という名前であった。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:106
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""
"成功した場合は、 B<modify_ldt>()  は (読み込みの場合は) 実際に読み込んだバイ"
"ト数、 または (書き込みの場合は) 0 を返す。 失敗した場合は B<modify_ldt>()  "
"は -1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:111
msgid "I<ptr> points outside the address space."
msgstr "I<ptr> がアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:124
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<modify_ldt_ldt_s>, or I<func> is 1 and the new ldt entry has "
"invalid values."
msgstr ""
"I<ptr> が 0 である、 または I<func> が 1 で I<bytecount> が "
"I<modify_ldt_ldt_s> 構造体のサイズと等しくないか、 I<func> が 1 で新しい ldt "
"エントリが無効な値である。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:128
msgid "I<func> is neither 0 nor 1."
msgstr "I<func> が 0 でも 1 でもない。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:131
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムでは 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:134 build/C/man2/pivot_root.2:128
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:136
msgid "B<vm86>(2)"
msgstr "B<vm86>(2)"

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "NFSSERVCTL"
msgstr "NFSSERVCTL"

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, fuzzy, no-wrap
#| msgid "2009-03-30"
msgid "2012-03-05"
msgstr "2009-03-30"

#. type: Plain text
#: build/C/man2/nfsservctl.2:11
msgid "nfsservctl - syscall interface to kernel nfs daemon"
msgstr "nfsservctl - カーネル nfs デーモンのためのインターフェース"

#. type: Plain text
#: build/C/man2/nfsservctl.2:14
#, no-wrap
msgid "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"
msgstr "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:17
#, no-wrap
msgid ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"
msgstr ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:21
msgid "I<Note>: Since Linux 3.1, this system call no longer exists."
msgstr ""

#. type: Plain text
#: build/C/man2/nfsservctl.2:33
#, no-wrap
msgid ""
"/*\n"
" * These are the commands understood by nfsctl().\n"
" */\n"
"#define NFSCTL_SVC          0    /* This is a server process. */\n"
"#define NFSCTL_ADDCLIENT    1    /* Add an NFS client. */\n"
"#define NFSCTL_DELCLIENT    2    /* Remove an NFS client. */\n"
"#define NFSCTL_EXPORT       3    /* export a file system. */\n"
"#define NFSCTL_UNEXPORT     4    /* unexport a file system. */\n"
"#define NFSCTL_UGIDUPDATE   5    /* update a client's UID/GID map. */\n"
"#define NFSCTL_GETFH        6    /* get an fh (used by mountd) */\n"
msgstr ""
"/*\n"
" * nfsctl() によって理解されるコマンド\n"
" */\n"
"#define NFSCTL_SVC          0    /* サーバープロセス */\n"
"#define NFSCTL_ADDCLIENT    1    /* NFS クライアントを追加 */\n"
"#define NFSCTL_DELCLIENT    2    /* NFS クライアンドを削除 */\n"
"#define NFSCTL_EXPORT       3    /* ファイルシステムのエクスポート */\n"
"#define NFSCTL_UNEXPORT     4    /* ファイルシステムのアンエクスポート */\n"
"#define NFSCTL_UGIDUPDATE   5    /* UID/GID マップの更新 */\n"
"#define NFSCTL_GETFH        6    /* (mountd で使用される) fh の取得 */\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:45
#, no-wrap
msgid ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"
msgstr ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:50
#, no-wrap
msgid ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"
msgstr ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:56 build/C/man2/pivot_root.2:99
#: build/C/man2/vm86.2:57
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/nfsservctl.2:58
msgid "This call is Linux-specific."
msgstr "このコールは Linux 特有である。"

#. type: TH
#: build/C/man2/outb.2:28
#, no-wrap
msgid "OUTB"
msgstr "OUTB"

#. type: TH
#: build/C/man2/outb.2:28
#, no-wrap
msgid "1995-11-29"
msgstr "1995-11-29"

#. type: Plain text
#: build/C/man2/outb.2:33
msgid ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - port I/O"
msgstr ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - ポート入出力"

#. type: Plain text
#: build/C/man2/outb.2:38
msgid ""
"This family of functions is used to do low-level port input and output.  The "
"out* functions do port output, the in* functions do port input; the b-suffix "
"functions are byte-width and the w-suffix functions word-width; the _p-"
"suffix functions pause until the I/O completes."
msgstr ""
"この一連の関数はポートに対する低レベルの入出力に使用する。 out* 関数はポート"
"出力、in* 関数はポート入力を行う。 語尾に b がついている関数はバイト単位、w "
"がついている関数はワード単位である。 _p がついている関数は I/O が終了するまで"
"待つ。"

#.  , given the following information
#.  in addition to that given in
#.  .BR outb (9).
#. type: Plain text
#: build/C/man2/outb.2:44
msgid ""
"They are primarily designed for internal kernel use, but can be used from "
"user space."
msgstr ""
"これらの関数はもともとカーネル内部での使用を想定して設計されているが、 ユー"
"ザー空間からでも使用できる。"

#. type: Plain text
#: build/C/man2/outb.2:49
msgid ""
"You compile with B<-O> or B<-O2> or similar.  The functions are defined as "
"inline macros, and will not be substituted in without optimization enabled, "
"causing unresolved references at link time."
msgstr ""
"B<-O> や B<-O2> などを指定してコンパイルすること。 これらの関数はインライン・"
"マクロとして定義されており、 最適化を行わないと関数の展開が行われず、 リンク"
"の時に「解決できない参照(unresolved reference)」が発生する。"

#. type: Plain text
#: build/C/man2/outb.2:58
msgid ""
"You use B<ioperm>(2)  or alternatively B<iopl>(2)  to tell the kernel to "
"allow the user space application to access the I/O ports in question.  "
"Failure to do this will cause the application to receive a segmentation "
"fault."
msgstr ""
"ユーザー空間のアプリケーションが I/O ポートにアクセスすることを カーネルに教"
"えるために B<ioperm>(2)  もしくは B<iopl>(2)  を使用すること。これを忘れると"
"アプリケーションはセグメンテーション違反 (segmentation fault) を受けとること"
"になる。"

#. type: Plain text
#: build/C/man2/outb.2:67
msgid ""
"B<outb>()  and friends are hardware-specific.  The I<value> argument is "
"passed first and the I<port> argument is passed second, which is the "
"opposite order from most DOS implementations."
msgstr ""
"B<outb>()  とその仲間はハードウェア特有である。 I<value> 引数が最初に渡さ"
"れ、 I<port> 引数が二番目に渡される。 この順序はほとんどの DOS での実装とは逆"
"である。"

#. type: Plain text
#: build/C/man2/outb.2:70
msgid "B<ioperm>(2), B<iopl>(2)"
msgstr "B<ioperm>(2), B<iopl>(2)"

#. type: TH
#: build/C/man2/pciconfig_read.2:5
#, no-wrap
msgid "PCICONFIG_READ"
msgstr "PCICONFIG_READ"

#. type: TH
#: build/C/man2/pciconfig_read.2:5
#, no-wrap
msgid "2003-07-14"
msgstr "2003-07-14"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:8
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci デバイス情報を扱う"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:11
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr "B<#include E<lt>pci.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:18
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:24
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"userspace."
msgstr ""
"PCI デバイスとのやり取り (interaction) は カーネル PCI レイヤですでに処理され"
"ているので、 通常はこららの関数をユーザ空間からアクセスする必要はない。"

#. type: TP
#: build/C/man2/pciconfig_read.2:24 build/C/man2/pciconfig_read.2:48
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr "B<pciconfig_read>()"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:33
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr "デバイス I<dev> のオフセット I<off> の値を I<buf> に読み込む。"

#. type: TP
#: build/C/man2/pciconfig_read.2:33 build/C/man2/pciconfig_read.2:54
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr "B<pciconfig_write>()"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:42
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr "デバイス I<dev> のオフセット I<off> に I<buf> の値を書き込む。"

#. type: TP
#: build/C/man2/pciconfig_read.2:42 build/C/man2/pciconfig_read.2:60
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr "B<pciconfig_iobase>()"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:47
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""
"bus/devfn ペアをこの関数に渡し、 メモリオフセット (prep のようなものでは、こ"
"の値は 0xc0000000 である) と PIO サイクルの IO ベースの物理アドレスを取得す"
"る。 また、もしあるならば ISA hole の物理アドレスを取得する。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:54 build/C/man2/pciconfig_read.2:60
msgid ""
"On success zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、0 が返される。 エラーの場合、-1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:74
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""
"I<which> の値に基づいて、物理メモリ内の様々な I/O 領域の位置情報が返される。 "
"I<which> の値は、 B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, "
"B<IOBASE_ISA_IO>, B<IOBASE_ISA_MEM> である。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:81
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr ""
"I<len> の値が無効である。 このエラーは B<pciconfig_iobase>()  には適用されな"
"い。"

#. type: TP
#: build/C/man2/pciconfig_read.2:81 build/C/man2/ptrace.2:1598
#: build/C/man2/sendfile.2:130
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:84
msgid "I/O error."
msgstr "I/O エラー。"

#. type: TP
#: build/C/man2/pciconfig_read.2:84
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:90
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""
"B<pciconfig_iobase>()  の場合、でホース (hose) の値が NULL である。 他の呼び"
"出しの場合、スロット (slot) が見つからない。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:95
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""
"このシステムはこれらの呼び出しを実装していない。 (B<CONFIG_PCI> が定義されて"
"いない)。"

#. type: TP
#: build/C/man2/pciconfig_read.2:95
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:102
msgid ""
"This return value is only valid for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""
"この返り値は B<pciconfig_iobase>()  でのみ有効である。 このエラーは I<which> "
"の値が無効であるときに返される。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:107
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""
"ユーザが B<CAP_SYS_ADMIN> 権限を持っていない。 このエラーは "
"B<pciconfig_iobase>()  には適用されない。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:109
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""
"これらの呼び出しは Linux 特有のものであり、 Linux 2.0.26/2.1.11 から使用可能"
"である。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:111
msgid "B<capabilities>(7)"
msgstr "B<capabilities>(7)"

#. type: TH
#: build/C/man2/personality.2:30
#, no-wrap
msgid "PERSONALITY"
msgstr "PERSONALITY"

#. type: TH
#: build/C/man2/personality.2:30
#, no-wrap
msgid "2003-01-01"
msgstr "2003-01-01"

#. type: Plain text
#: build/C/man2/personality.2:33
msgid "personality - set the process execution domain"
msgstr "personality - プロセスを実行するドメインを設定する"

#. type: Plain text
#: build/C/man2/personality.2:35
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr "B<#include E<lt>sys/personality.hE<gt>>"

#. type: Plain text
#: build/C/man2/personality.2:37
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr "B<int personality(unsigned long >I<persona>B<);>"

#. type: Plain text
#: build/C/man2/personality.2:45
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""
"Linux は、プロセス毎の異なる実行ドメイン、すなわち パーソナリティ "
"(personality) をサポートしている。 実行ドメインは Linux にシグナル番号にどの"
"シグナルを割り付けるかを 教えたりする。また、実行ドメイン・システムにより、 "
"Linux は他の UNIX 風のオペレーティング・システムでコンパイルされた バイナリに"
"対する限定的なサポートを提供している。"

#. type: Plain text
#: build/C/man2/personality.2:55
msgid ""
"This function will return the current B<personality>()  when I<persona> "
"equals 0xffffffff.  Otherwise, it will make the execution domain referenced "
"by I<persona> the new execution domain of the calling process."
msgstr ""
"B<personality ()> 関数は、 I<persona> が 0xffffffff の場合は現在の B<パーソナ"
"リティ> を返す。 それ以外の場合、 I<persona> により参照される実行ドメイン"
"を、 呼び出し元のプロセスの新しい実行ドメインとする。"

#. type: Plain text
#: build/C/man2/personality.2:62
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""
"成功した場合、以前の I<persona> が返される。エラーの場合は、-1 が返され、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/personality.2:66
msgid "The kernel was unable to change the personality."
msgstr "カーネルがパーソナリティを変更できなかった。"

#. type: Plain text
#: build/C/man2/personality.2:70
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"B<personality>()  は Linux 固有であり、移植を意図したプログラムで使用すべきで"
"はない。"

#. type: TH
#: build/C/man2/pivot_root.2:7
#, no-wrap
msgid "PIVOT_ROOT"
msgstr "PIVOT_ROOT"

#. type: Plain text
#: build/C/man2/pivot_root.2:10
msgid "pivot_root - change the root file system"
msgstr "pivot_root - root ファイルシステムを変更する"

#. type: Plain text
#: build/C/man2/pivot_root.2:12
msgid ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"

#.  The
#.  .B CAP_SYS_ADMIN
#.  capability is required.
#. type: Plain text
#: build/C/man2/pivot_root.2:21
msgid ""
"B<pivot_root>()  moves the root file system of the calling process to the "
"directory I<put_old> and makes I<new_root> the new root file system of the "
"calling process."
msgstr ""
"B<pivot_root>()  は呼び出し元のプロセスの root ファイルシステムを I<put_old> "
"ディレクトリに移動し、 I<new_root> を呼び出し元のプロセスの新しい root ファイ"
"ルシステムにする。"

#. type: Plain text
#: build/C/man2/pivot_root.2:28
msgid ""
"The typical use of B<pivot_root>()  is during system startup, when the "
"system mounts a temporary root file system (e.g., an B<initrd>), then mounts "
"the real root file system, and eventually turns the latter into the current "
"root of all relevant processes or threads."
msgstr ""
"B<pivot_root>()  の典型的な利用法は、システムの起動中にシステムが一時的な "
"root ファイルシステム (例えば B<initrd>)  をマウントし、これに続いて本当の "
"root ファイルシステムをマウントし、 後者を必要な全てのプロセス・スレッドの カ"
"レント root に変更するような場合である。"

#. type: Plain text
#: build/C/man2/pivot_root.2:40
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""
"古い root ディレクトリを使っていた全てのプロセスやスレッドの カレント root と"
"カレントワーキングディレクトリを、 B<pivot_root>()  が変更するかどうかはわか"
"らない。 B<pivot_root>()  の呼びだしプロセスは、古い root やカレントワーキン"
"グディレクトリを使っていた プロセスが、いずれの場合でも正しく動作することを保"
"証しなければならない。 これを簡単に行うには、それらのプロセスの root と カレ"
"ントワーキングディレクトリを B<pivot_root>()  を呼び出す前に I<new_root> に変"
"更しておくことである。"

#. type: Plain text
#: build/C/man2/pivot_root.2:58
msgid ""
"The paragraph above is intentionally vague because the implementation of "
"B<pivot_root>()  may change in the future.  At the time of writing, "
"B<pivot_root>()  changes root and current working directory of each process "
"or thread to I<new_root> if they point to the old root directory.  This is "
"necessary in order to prevent kernel threads from keeping the old root "
"directory busy with their root and current working directory, even if they "
"never access the file system in any way.  In the future, there may be a "
"mechanism for kernel threads to explicitly relinquish any access to the file "
"system, such that this fairly intrusive mechanism can be removed from "
"B<pivot_root>()."
msgstr ""
"上記の段落は、将来 B<pivot_root>()  が変更されるかも知れないことを鑑みて、わ"
"ざと曖昧に書いてある。 本ページを記述している時点では、 B<pivot_root>()  は古"
"い root ディレクトリを用いている全てのプロセス・スレッドの root と カレント"
"ワーキングディレクトリを I<new_root> に変更する。これはカーネルのスレッドが古"
"い root ディレクトリを busy 状態にしないために必要である。これらのスレッドが "
"古いディレクトリを root やカレントワーキングディレクトリとしていると、 ファイ"
"ルシステムに一切アクセスしない場合でも 古い root が busy になってしまうからで"
"ある。 将来は、カーネルスレッドがあらゆるファイルシステムへのアクセスを 明示"
"的に放棄するメカニズムができ、このでしゃばりな機能は B<pivot_root>()  から削"
"除されるかもしれない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:66
msgid ""
"Note that this also applies to the calling process: B<pivot_root>()  may or "
"may not affect its current working directory.  It is therefore recommended "
"to call B<chdir(\"/\")> immediately after B<pivot_root>()."
msgstr ""
"これは呼び出し元のプロセスについても当てはまることに注意。 B<pivot_root>()  "
"がカレントプロセスのカレントワーキングディレクトリに影響するかどうかは 分から"
"ない。したがって B<pivot_root>()  の直後に B<chdir(\"/\")> を呼び出すとよい。"

#. type: Plain text
#: build/C/man2/pivot_root.2:68
msgid "The following restrictions apply to I<new_root> and I<put_old>:"
msgstr "I<new_root> および I<put_old> には以下の制限がある:"

#. type: IP
#: build/C/man2/pivot_root.2:68 build/C/man2/pivot_root.2:70
#: build/C/man2/pivot_root.2:73 build/C/man2/pivot_root.2:77
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: build/C/man2/pivot_root.2:70
msgid "They must be directories."
msgstr "ディレクトリでなければならない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:73
msgid ""
"I<new_root> and I<put_old> must not be on the same file system as the "
"current root."
msgstr ""
"I<new_root> と I<put_old> は現在の root と同じファイルシステムにあってはなら"
"ない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:77
msgid ""
"I<put_old> must be underneath I<new_root>, that is, adding a nonzero number "
"of I</..> to the string pointed to by I<put_old> must yield the same "
"directory as I<new_root>."
msgstr ""
"I<put_old> は I<new_root> 以下になければならない。すなわち I<put_old> を差す"
"文字列に 1 個以上の I<../> を付けることによって I<new_root> と同じディレクト"
"リが得られなければならない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:79
msgid "No other file system may be mounted on I<put_old>."
msgstr "他のファイルシステムが I<put_old> にマウントされていてはならない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:83
msgid "See also B<pivot_root>(8)  for additional usage examples."
msgstr "利用例については B<pivot_root>(8)  を参照のこと。"

#. type: Plain text
#: build/C/man2/pivot_root.2:90
msgid ""
"If the current root is not a mount point (e.g., after B<chroot>(2)  or "
"B<pivot_root>(), see also below), not the old root directory, but the mount "
"point of that file system is mounted on I<put_old>."
msgstr ""
"現在の root がマウントポイントではない (B<chroot>(2)  や B<pivot_root>()  の"
"後など。以下も参照) 場合、 古い root ディレクトリではなく、 そのファイルシス"
"テムのマウントポイントが I<put_old> にマウントされる。"

#. type: Plain text
#: build/C/man2/pivot_root.2:95
msgid ""
"I<new_root> does not have to be a mount point.  In this case, I</proc/"
"mounts> will show the mount point of the file system containing I<new_root> "
"as root (I</>)."
msgstr ""
"I<new_root> はマウントポイントでなくてもよい。 この場合 I</proc/mounts> は、 "
"I<new_root> を root (I</>)  とするファイルシステムのマウントポイントを表示す"
"る。"

#. type: Plain text
#: build/C/man2/pivot_root.2:104
msgid ""
"B<pivot_root>()  may return (in I<errno>) any of the errors returned by "
"B<stat>(2).  Additionally, it may return:"
msgstr ""
"B<pivot_root>()  は B<stat>(2)  の返すあらゆるエラーを (I<errno> に) 返す可能"
"性がある。さらに以下を返すことがある:"

#. type: Plain text
#: build/C/man2/pivot_root.2:108
msgid ""
"I<new_root> or I<put_old> are on the current root file system, or a file "
"system is already mounted on I<put_old>."
msgstr ""
"I<new_root> または I<put_old> が、現在の root ファイルシステム上にあるか、既"
"に I<put_old> になんらかのファイルシステムがマウントされている。"

#. type: Plain text
#: build/C/man2/pivot_root.2:111
msgid "I<put_old> is not underneath I<new_root>."
msgstr "I<put_old> が I<new_root> の下層にない。"

#. type: TP
#: build/C/man2/pivot_root.2:111
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/pivot_root.2:114
msgid "I<new_root> or I<put_old> is not a directory."
msgstr "I<new_root> または I<put_old> がディレクトリでない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:119
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr "呼び出し元のプロセスが B<CAP_SYS_ADMIN> ケーパビリティを持っていない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:122
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr "B<pivot_root>()  は Linux 2.3.41 で導入された。"

#. type: Plain text
#: build/C/man2/pivot_root.2:125
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr "B<pivot_root>()  は Linux に固有のものなので、移植性はない。"

#. type: SH
#: build/C/man2/pivot_root.2:128 build/C/man2/ptrace.2:1661
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/pivot_root.2:132
msgid ""
"B<pivot_root>()  should not have to change root and current working "
"directory of all other processes in the system."
msgstr ""
"B<pivot_root>()  はシステムの他のプロセス全ての root と カレントワーキング"
"ディレクトリとを変更しなくてもよいはずである。"

#. type: Plain text
#: build/C/man2/pivot_root.2:137
msgid ""
"Some of the more obscure uses of B<pivot_root>()  may quickly lead to "
"insanity."
msgstr ""
"B<pivot_root>()  の使い方がもうちょっと曖昧になると、 あっという間にわけのわ"
"からない状態になってしまうだろう"

#. type: Plain text
#: build/C/man2/pivot_root.2:143
msgid "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"
msgstr "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"

#. type: TH
#: build/C/man2/ptrace.2:48
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: TH
#: build/C/man2/ptrace.2:48
#, fuzzy, no-wrap
#| msgid "2009-03-30"
msgid "2012-03-06"
msgstr "2009-03-30"

#. type: Plain text
#: build/C/man2/ptrace.2:51
msgid "ptrace - process trace"
msgstr "ptrace - プロセスのトレース"

#. type: Plain text
#: build/C/man2/ptrace.2:54
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/ptrace.2:57
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man2/ptrace.2:66
#, fuzzy
#| msgid ""
#| "The B<ptrace>()  system call provides a means by which a parent process "
#| "may observe and control the execution of another process, and examine and "
#| "change its core image and registers.  It is primarily used to implement "
#| "breakpoint debugging and system call tracing."
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""
"B<ptrace>()  システムコールは、親プロセスが、別のプロセスの実行の監視/制御を "
"行ったり、コアイメージ (core image) やレジスタの調査/変更を 行ったりする手段"
"を提供する。 B<ptrace>()  は、主にブレークポイントによるデバッグやシステム"
"コールのトレースを 実装するのに用いられる。"

#. type: Plain text
#: build/C/man2/ptrace.2:77
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:79
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:83
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:89
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:98
#, fuzzy
#| msgid ""
#| "The parent can initiate a trace by calling B<fork>(2)  and having the "
#| "resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<exec>"
#| "(3).  Alternatively, the parent may commence trace of an existing process "
#| "using B<PTRACE_ATTACH>."
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<execve>"
"(2).  Alternatively, one process may commence tracing another process using "
"B<PTRACE_ATTACH>."
msgstr ""
"トレースを開始するには、まず親プロセスで B<fork>(2)  を呼び出す。生成された子"
"プロセスで B<PTRACE_TRACEME> を行い、続いて (典型的には)  B<exec>(3)  を行な"
"う。 別の方法としては、 親プロセスが既存のプロセスに対して B<PTRACE_ATTACH> "
"を使用し、トレースを開始する。"

#. type: Plain text
#: build/C/man2/ptrace.2:115
#, fuzzy
#| msgid ""
#| "While being traced, the child will stop each time a signal is delivered, "
#| "even if the signal is being ignored.  (The exception is B<SIGKILL>, which "
#| "has its usual effect.)  The parent will be notified at its next B<wait>"
#| "(2)  and may inspect and modify the child process while it is stopped.  "
#| "The parent then causes the child to continue, optionally ignoring the "
#| "delivered signal (or even delivering a different signal instead)."
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""
"トレースの実行中、子プロセスはシグナルが配送されるたびに、 たとえそのシグナル"
"が無視すべきものであっても停止する (B<SIGKILL> は例外で、通常どおりの効果をも"
"たらす)。 親プロセスには次の B<wait>(2)  で通知され、停止している間に子プロセ"
"スを調べたり修正したりすることができる。 そして親プロセスは子プロセスの実行を"
"再開させるが、配送された シグナルを無視することもできる (あるいは代わりに別の"
"シグナルを 配送することもできる) 。"

#. type: Plain text
#: build/C/man2/ptrace.2:119
#, fuzzy
#| msgid ""
#| "When the parent is finished tracing, it can terminate the child with "
#| "B<PTRACE_KILL> or cause it to continue executing in a normal, untraced "
#| "mode via B<PTRACE_DETACH>."
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""
"親プロセスがトレースを終了する際には、 B<PTRACE_KILL> を使用して子プロセスを"
"終了させることもできるし、 B<PTRACE_DETACH> を用いて通常のトレースなしのモー"
"ドにして、 実行を継続させることもできる。"

#. type: Plain text
#: build/C/man2/ptrace.2:123
msgid "The value of I<request> determines the action to be performed:"
msgstr "I<request> の値がこのシステムコールの動作を決定する:"

#. type: TP
#: build/C/man2/ptrace.2:123
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "B<PTRACE_TRACEME>"

#. type: Plain text
#: build/C/man2/ptrace.2:145
#, fuzzy
#| msgid ""
#| "Indicates that this process is to be traced by its parent.  Any signal "
#| "(except B<SIGKILL>)  delivered to this process will cause it to stop and "
#| "its parent to be notified via B<wait>(2).  Also, all subsequent calls to "
#| "B<execve>(2)  by this process will cause a B<SIGTRAP> to be sent to it, "
#| "giving the parent a chance to gain control before the new program begins "
#| "execution.  A process probably shouldn't make this request if its parent "
#| "isn't expecting to trace it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgid ""
"Indicate that this process is to be traced by its parent.  Any signal "
"(except B<SIGKILL>)  delivered to this process will cause it to stop and its "
"parent to be notified via B<waitpid>(2).  In addition, all subsequent calls "
"to B<execve>(2)  by the traced process will cause a B<SIGTRAP> to be sent to "
"it, giving the parent a chance to gain control before the new program begins "
"execution.  A process probably shouldn't make this request if its parent "
"isn't expecting to trace it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""
"このプロセスが親プロセスによってトレースされることを表す。 このプロセスに "
"(B<SIGKILL> 以外の) シグナルが配送されると、 プロセスは停止し、親プロセスに "
"B<wait>(2)  を通じて通知される。 また、これ以降はこのプロセスが B<execve>"
"(2)  を呼び出す度に B<SIGTRAP> が送信されるようになる。 これによって、親プロ"
"セスは 新しいプログラムが実行を開始する前に制御することができる。 親プロセス"
"が自プロセスをトレースするつもりがない場合には、 おそらくこのプロセスは本要求"
"を行うべきではないだろう。 (I<pid>, I<addr>, I<data> は無視される。)"

#. type: Plain text
#: build/C/man2/ptrace.2:156
#, fuzzy
#| msgid ""
#| "The above request is used only by the child process; the rest are used "
#| "only by the parent.  In the following requests, I<pid> specifies the "
#| "child process to be acted on.  For requests other than B<PTRACE_KILL>, "
#| "the child process must be stopped."
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""
"上記の要求は子プロセスだけが行なうものである。 残りは親プロセスだけが行なうも"
"のである。 以下の要求では、I<pid> で操作の対象となる 子プロセスを指定する。 "
"B<PTRACE_KILL> を除き、要求を行なうためには 子プロセスは停止していなければな"
"らない。"

#. type: TP
#: build/C/man2/ptrace.2:156
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"

#. type: Plain text
#: build/C/man2/ptrace.2:167
#, fuzzy
#| msgid ""
#| "Reads a word at the location I<addr> in the child's memory, returning the "
#| "word as the result of the B<ptrace>()  call.  Linux does not have "
#| "separate text and data address spaces, so the two requests are currently "
#| "equivalent.  (The argument I<data> is ignored.)"
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored.)"
msgstr ""
"子プロセスのメモリの I<addr> の位置から 1 ワードを読み出す。読み出したワード"
"は B<ptrace>()  の返り値として返される。 Linux ではテキスト (text) とデータ "
"(data) で 同じアドレス空間を使用するため、この 2 つの要求は現在のところ 同じ"
"ものである。 (引き数 I<data> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:167
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "B<PTRACE_PEEKUSER>"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: build/C/man2/ptrace.2:185
#, fuzzy
#| msgid ""
#| "Reads a word at offset I<addr> in the child's USER area, which holds the "
#| "registers and other information about the process (see I<E<lt>sys/user."
#| "hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
#| "Typically the offset must be word-aligned, though this might vary by "
#| "architecture.  See NOTES.  (I<data> is ignored.)"
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see I<E<lt>sys/user."
"hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
"Typically, the offset must be word-aligned, though this might vary by "
"architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""
"子プロセスの USER 領域のオフセット I<addr> の位置から 1 ワードを読み込む。"
"USER 領域にはそのプロセスの レジスタ (registers) などの情報が保持されている "
"(I<E<lt>sys/user.hE<gt>> を参照)。読み込んだワードは B<ptrace>()  コールの結"
"果として返される。 たいていはオフセットはワード境界になければならないが、 "
"アーキテクチャによってはその必要はない。 「注意」の節を参照。 (I<data> は無視"
"される。 )"

#. type: TP
#: build/C/man2/ptrace.2:185
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"

#. type: Plain text
#: build/C/man2/ptrace.2:197
#, fuzzy
#| msgid ""
#| "Copies the word I<data> to location I<addr> in the child's memory.  As "
#| "above, the two requests are currently equivalent."
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""
"ワード I<data> を子プロセスのメモリの I<addr> の位置へコピーする。上と同様"
"に、現在のところ二つの 要求は同じものである。"

#. type: TP
#: build/C/man2/ptrace.2:197
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "B<PTRACE_POKEUSER>"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does userspace discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:213
#, fuzzy
#| msgid ""
#| "Copies the word I<data> to offset I<addr> in the child's USER area.  As "
#| "above, the offset must typically be word-aligned.  In order to maintain "
#| "the integrity of the kernel, some modifications to the USER area are "
#| "disallowed."
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""
"ワード I<data> を子プロセスの USER 領域のオフセット I<addr> の位置にコピーす"
"る。 上と同様に、通常、オフセットはワード境界になければならない。 カーネルの"
"完全性 (integrity) を維持するため、 変更内容によっては USER 領域の変更は禁止"
"されている。"

#. type: TP
#: build/C/man2/ptrace.2:213
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"

#. type: Plain text
#: build/C/man2/ptrace.2:224
#, fuzzy
#| msgid ""
#| "Copies the child's general purpose or floating-point registers, "
#| "respectively, to location I<data> in the parent.  See I<E<lt>sys/user."
#| "hE<gt>> for information on the format of this data.  (I<addr> is ignored.)"
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)"
msgstr ""
"それぞれ、子プロセスの汎用レジスタ、浮動小数点レジスタを親プロセスの I<data> "
"の位置にコピーする。この data の書式に関しては I<E<lt>sys/user.hE<gt>> を参照"
"すること。(I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:224
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_GETSIGINFO> (Linux 2.3.99-pre6 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:236
#, fuzzy
#| msgid ""
#| "Retrieve information about the signal that caused the stop.  Copies a "
#| "I<siginfo_t> structure (see B<sigaction>(2))  from the child to location "
#| "I<data> in the parent.  (I<addr> is ignored.)"
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""
"停止の原因となったシグナルに関する情報を取得する。 I<siginfo_t> 構造体 "
"(B<sigaction>(2)  参照) を子プロセスから親プロセスの I<data> の位置にコピーす"
"る。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:236
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"

#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does userspace discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:249
#, fuzzy
#| msgid ""
#| "Copies the child's general purpose or floating-point registers, "
#| "respectively, from location I<data> in the parent.  As for "
#| "B<PTRACE_POKEUSER>, some general purpose register modifications may be "
#| "disallowed.  (I<addr> is ignored.)"
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"from the address I<data> in the tracer.  As for B<PTRACE_POKEUSER>, some "
"general-purpose register modifications may be disallowed.  (I<addr> is "
"ignored.)"
msgstr ""
"それぞれ、子プロセスの汎用レジスタ、浮動小数点レジスタに 親プロセスの "
"I<date> の位置からコピーする。 B<PTRACE_POKEUSER> と同様に、汎用レジスタに"
"よっては 変更が禁止されている場合がある。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:249
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_SETSIGINFO> (Linux 2.3.99-pre6 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:265
#, fuzzy
#| msgid ""
#| "Set signal information.  Copies a I<siginfo_t> structure from location "
#| "I<data> in the parent to the child.  This will only affect signals that "
#| "would normally be delivered to the child and were caught by the tracer.  "
#| "It may be difficult to tell these normal signals from synthetic signals "
#| "generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""
"シグナル情報を設定する。 I<siginfo_t> 構造体を親プロセスのデータ I<data> の位"
"置から 子プロセスにコピーする。 この処理を行うことができるのは、子プロセスに"
"通常は配送されるはずで トレーサに捕捉されたシグナルについてだけである。 これ"
"らの通常のシグナルと B<ptrace>()  自身が発生するシグナルを見分けるのは難しい"
"かもしれない。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:265
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr "B<PTRACE_SETOPTIONS> (Linux 2.4.6 以降; バグの章にある警告も参照)"

#. type: Plain text
#: build/C/man2/ptrace.2:274
#, fuzzy
#| msgid ""
#| "Sets ptrace options from I<data> in the parent.  (I<addr> is ignored.)  "
#| "I<data> is interpreted as a bit mask of options, which are specified by "
#| "the following flags:"
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""
"親プロセスの I<data> に基づいて ptrace のオプションを設定する (I<addr> は無視"
"される)。 I<data> はオプションのビットマスクとして解釈され、 オプションには以"
"下のフラグを指定できる:"

#. type: TP
#: build/C/man2/ptrace.2:275
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr "B<PTRACE_O_TRACESYSGOOD> (Linux 2.4.6 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:284
#, fuzzy
#| msgid ""
#| "When delivering syscall traps, set bit 7 in the signal number (i.e., "
#| "deliver I<SIGTRAP | 0x80>).  This makes it easy for the tracer to tell "
#| "the difference between normal traps and those caused by a syscall.  "
#| "(B<PTRACE_O_TRACESYSGOOD> may not work on all architectures.)"
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call.  (B<PTRACE_O_TRACESYSGOOD> "
"may not work on all architectures.)"
msgstr ""
"システムコールのトラップが配送されたときに、シグナル番号のビット 7 を設定す"
"る (すなわち、I<SIGTRAP | 0x80> を配送する)。 これにより、トレーサが通常のト"
"ラップとシステムコールによるトラップを 区別しやすくなる。 "
"(B<PTRACE_O_TRACESYSGOOD> はどのアーキテクチャでも動作しない可能性がある。)"

#. type: TP
#: build/C/man2/ptrace.2:284
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:296
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly forked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"次の B<fork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ "
"8> で 子プロセスの動作を停止させ、 新たに fork されたプロセスのトレースを自動"
"的に開始し、 B<SIGSTOP> でそのプロセスの実行を開始する。 新しいプロセスの "
"PID は B<PTRACE_GETEVENTMSG> で取得できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:299
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:303 build/C/man2/ptrace.2:322
#: build/C/man2/ptrace.2:341
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:303
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEVFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:315
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<vfork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly vforked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"次の B<vfork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ "
"8> で 子プロセスの動作を停止させ、 新たに vfork されたプロセスのトレースを自"
"動的に開始し、 B<SIGSTOP> でそのプロセスの実行を開始する。 新しいプロセスの "
"PID は B<PTRACE_GETEVENTMSG> で取得できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:318
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:322
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACECLONE> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:334
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly forked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"次の B<fork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ "
"8> で 子プロセスの動作を停止させ、 新たに fork されたプロセスのトレースを自動"
"的に開始し、 B<SIGSTOP> でそのプロセスの実行を開始する。 新しいプロセスの "
"PID は B<PTRACE_GETEVENTMSG> で取得できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:337
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:362
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<clone>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly cloned process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>.  This option "
#| "may not catch B<clone>(2)  calls in all cases.  If the child calls "
#| "B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will be "
#| "delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
#| "child calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
#| "B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""
"次の B<clone>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_CLONE\\ E<lt>E<lt> "
"\\8> で 子プロセスの動作を停止させ、 新たに clone で作成されたプロセスのト"
"レースを自動的に開始し、 B<SIGSTOP> でプロセスの実行を開始する。 新しいプロセ"
"スの PID は B<PTRACE_GETEVENTMSG> で取得できる。 このオプションで全ての "
"B<clone>(2)  コールを捕まえられるわけではない。 子プロセスが B<CLONE_VFORK> "
"フラグ付きで B<clone>(2)  を呼び出した場合、 B<PTRACE_O_TRACEVFORK> が設定さ"
"れていれば代わりに B<PTRACE_EVENT_VFORK> が配送される。 また、子プロセスが終"
"了シグナルを B<SIGCHLD> に設定して B<clone>(2)  を呼び出した場合は、 "
"B<PTRACE_O_TRACEFORK> が設定されていれば B<PTRACE_EVENT_FORK> が配送される。"

#. type: TP
#: build/C/man2/ptrace.2:362
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEEXEC> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:371
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:374
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:376
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (Linux 2.5.60 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:385
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:388
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:392
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:392
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEEXIT> (Linux 2.5.60 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:400
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:403
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:407
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:415
#, fuzzy
#| msgid ""
#| "Stop the child at exit with I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ "
#| "8>.  The child's exit status can be retrieved with "
#| "B<PTRACE_GETEVENTMSG>.  This stop will be done early during process exit "
#| "when registers are still available, allowing the tracer to see where the "
#| "exit occurred, whereas the normal exit notification is done after the "
#| "process is finished exiting.  Even though context is available, the "
#| "tracer cannot prevent the exit from happening at this point."
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""
"終了 (exit) 時に I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ 8> で子プロセス"
"の動作を停止させる。子プロセスの終了ステータスは B<PTRACE_GETEVENTMSG> で取得"
"できる。 この停止はレジスタがまだ参照可能であるプロセス終了処理の初期に行わ"
"れ、 トレーサはどこで終了が発生したかを知ることができる。 通常の終了通知 "
"(exit notification) はプロセスの終了処理が完了した後に 行われる。コンテキスト"
"を参照することはできるにも関わらず、 トレーサはこの時点から終了を止めることは"
"できない。"

#. type: TP
#: build/C/man2/ptrace.2:416
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr "B<PTRACE_GETEVENTMSG> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:436
#, fuzzy
#| msgid ""
#| "Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
#| "just happened, placing it in the location I<data> in the parent.  For "
#| "B<PTRACE_EVENT_EXIT> this is the child's exit status.  For "
#| "B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> and B<PTRACE_EVENT_CLONE> "
#| "this is the PID of the new process.  Since Linux 2.6.18, the PID of the "
#| "new process is also available for B<PTRACE_EVENT_VFORK_DONE>.  (I<addr> "
#| "is ignored.)"
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  (I<addr> is "
"ignored.)"
msgstr ""
"発生したばかりの ptrace イベントに関するメッセージを (I<unsigned long> 型で) "
"取得する。 取得したメッセージは親プロセスの I<data> の位置に格納される。 得ら"
"れる内容は、 B<PTRACE_EVENT_EXIT> の場合は子プロセスの終了ステータスであり、 "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_CLONE> の場合は新"
"しいプロセスの PID である。 Linux 2.6.18 以降では、新しいプロセスの PID は "
"B<PTRACE_EVENT_VFORK_DONE> で入手できる。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:436
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: build/C/man2/ptrace.2:448
#, fuzzy
#| msgid ""
#| "Restarts the stopped child process.  If I<data> is nonzero and not "
#| "B<SIGSTOP>, it is interpreted as a signal to be delivered to the child; "
#| "otherwise, no signal is delivered.  Thus, for example, the parent can "
#| "control whether a signal sent to the child is delivered or not.  (I<addr> "
#| "is ignored.)"
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""
"停止した子プロセスの実行を再開させる。 I<data> がゼロでなく、 B<SIGSTOP> でも"
"なければ、 子プロセスに配送されるシグナルと解釈される。 ゼロや B<SIGSTOP> の"
"場合はシグナルは配送されない。 これを使うと、例えば、親プロセスは 子プロセス"
"に送られたシグナルを実際に配送するかどうかを 制御することができる。(I<addr> "
"は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:448
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"

#. type: Plain text
#: build/C/man2/ptrace.2:472
#, fuzzy
#| msgid ""
#| "Restarts the stopped child as for B<PTRACE_CONT>, but arranges for the "
#| "child to be stopped at the next entry to or exit from a system call, or "
#| "after execution of a single instruction, respectively.  (The child will "
#| "also, as usual, be stopped upon receipt of a signal.)  From the parent's "
#| "perspective, the child will appear to have been stopped by receipt of a "
#| "B<SIGTRAP>.  So, for B<PTRACE_SYSCALL>, for example, the idea is to "
#| "inspect the arguments to the system call at the first stop, then do "
#| "another B<PTRACE_SYSCALL> and inspect the return value of the system call "
#| "at the second stop.  The I<data> argument is treated as for "
#| "B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (addr is ignored.)"
msgstr ""
"B<PTRACE_CONT> と同様に停止した子プロセスを再開する。ただし、 "
"B<PTRACE_SYSCALL> の場合は子プロセスが 次にシステムコールに入るかシステムコー"
"ルから抜けるかする時に、 B<PTRACE_SINGLESTEP> の場合は 1 命令 (instruction) "
"実行した後に停止させる (通常どおり、子プロセスはシグナルを受け取った場合にも"
"停止する)。 親プロセスから見ると、子プロセスは B<SIGTRAP> を受信して停止した"
"ように見える。そのため、例えば B<PTRACE_SYSCALL> を使うと、1回目の停止で引き"
"数を調べて B<PTRACE_SYSCALL> を実行し、 2回目の停止でシステムコールの返り値を"
"調べる、 というようなことができる。 引き数 I<data> は B<PTRACE_CONT> の場合と"
"同じ様に解釈される。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:472
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (Linux 2.6.14 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:490
#, fuzzy
#| msgid ""
#| "For B<PTRACE_SYSEMU>, continue and stop on entry to the next syscall, "
#| "which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
#| "but also singlestep if not a syscall.  This call is used by programs like "
#| "User Mode Linux that want to emulate all the child's system calls.  The "
#| "I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; "
#| "not supported on all architectures.)"
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
"but also singlestep if not a system call.  This call is used by programs "
"like User Mode Linux that want to emulate all the tracee's system calls.  "
"The I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; "
"not supported on all architectures.)"
msgstr ""
"B<PTRACE_SYSEMU> は、実行を再開し、次のシステムコールに入る時に停止させる。 "
"システムコールは実行されない。 B<PTRACE_SYSEMU_SINGLESTEP> も同様だが、システ"
"ムコールでない場合には 1 命令 (singlestep) だけ実行した時点でも停止させる。 "
"このコールは User Mode Linux のように子プロセスのシステムコールを全て エミュ"
"レートしようとするプログラムで使用される。 引き数 I<data> は B<PTRACE_CONT> "
"の場合と同じ様に解釈される。 (I<addr> は無視される。 全てのアーキテクチャでサ"
"ポートされているわけではない。)"

#. type: TP
#: build/C/man2/ptrace.2:490
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "B<PTRACE_KILL>"

#. type: Plain text
#: build/C/man2/ptrace.2:499
#, fuzzy
#| msgid ""
#| "Sends the child a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
#| "ignored.)"
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""
"子プロセスに B<SIGKILL> を送り終了させる。(I<addr> と I<data> は無視される。)"

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: build/C/man2/ptrace.2:518
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:518
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "B<PTRACE_ATTACH>"

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: build/C/man2/ptrace.2:546
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:546
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "B<PTRACE_DETACH>"

#.  In the text below, we decided to avoid prettifying the text with markup:
#.  it would make the source nearly impossible to edit, and we _do_ intend
#.  to edit it often, in order to keep it updated:
#.  ptrace API is full of quirks, no need to compound this situation by
#.  making it excruciatingly painful to document them!
#. type: Plain text
#: build/C/man2/ptrace.2:562
#, fuzzy
#| msgid ""
#| "Restarts the stopped child as for B<PTRACE_CONT>, but first detaches from "
#| "the process, undoing the reparenting effect of B<PTRACE_ATTACH>, and the "
#| "effects of B<PTRACE_TRACEME>.  Although perhaps not intended, under Linux "
#| "a traced child can be detached in this way regardless of which method was "
#| "used to initiate tracing.  (I<addr> is ignored.)"
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""
"B<PTRACE_CONT> と同様に停止した子プロセスを再開する。ただし まずそのプロセス"
"からの分離 (detach) を行い、 B<PTRACE_ATTACH> での親の切り換えによる効果と "
"B<PTRACE_TRACEME> の効果を取り消す。意図したものではないだろうが、 Linux で"
"は、トレースされている子プロセスはどのような方法でトレースを 開始されたとして"
"も、この方法で分離 (detach) することができる。 (I<addr> は無視される。)"

#. type: SS
#: build/C/man2/ptrace.2:562
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:571
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:580
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term \"signal-"
"delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:594
msgid ""
"B<SIGKILL> operates similarly, with exceptions.  No signal-delivery-stop is "
"generated for B<SIGKILL> and therefore the tracer can't suppress it.  "
"B<SIGKILL> kills even within system calls (syscall-exit-stop is not "
"generated prior to death by B<SIGKILL>).  The net effect is that B<SIGKILL> "
"always kills the process (all its threads), even if some threads of the "
"process are ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:599
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:603
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:617
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), B<exit_group>"
"(2), and signal deaths (except B<SIGKILL>), and when threads are torn down "
"on B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:642
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  I<waitpid"
"(WNOHANG)> may return 0 instead.  In other words, the tracee may be \"not "
"yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:656
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:656
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:658
msgid "A tracee can be in two states: running or stopped."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:662
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:673
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  Ptrace-"
"stops can be further subdivided into I<signal-delivery-stop>, I<group-stop>, "
"I<syscall-stop>, and so on.  These stopped states are described in detail "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:678
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:680
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr ""

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: build/C/man2/ptrace.2:692
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:700
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:707
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:715
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:719
#, no-wrap
msgid ""
"    kill(tracee, SIGKILL);\n"
"    waitpid(tracee, &status, __WALL | WNOHANG);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:744
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, group-"
"stop, PTRACE_EVENT stops, syscall-stops B<PTRACE_SINGLESTEP>, "
"B<PTRACE_SYSEMU>, and B<PTRACE_SYSEMU_SINGLESTEP>.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the I<WSTOPSIG(status)"
"> macro can't be used to perform this examination, because it returns the "
"value (I<status\\E<gt>E<gt>8)\\ >B<&\\ 0xff>B<.)>"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:744
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:764
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:778
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the stopping signal returned by "
"I<WSTOPSIG(status)>.  If the stopping signal is B<SIGTRAP>, this may be a "
"different kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" "
"sections below for details.  If I<WSTOPSIG(status)> returns a stopping "
"signal, this may be a group-stop; see below."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:778
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:781
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:783
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:796
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:802
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:813
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  Restartable system calls will be restarted (the tracer will "
"observe the tracee to execute B<restart_syscall(2)> if the tracer uses "
"B<PTRACE_SYSCALL>); non-restartable system calls may fail with B<EINTR> even "
"though no observable signal is injected to the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:824
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than signal-delivery-"
"stop are not guaranteed to inject a signal, even if I<sig> is nonzero.  No "
"error is reported; a nonzero I<sig> may simply be ignored.  Ptrace users "
"should not try to \"create a new signal\" this way: use B<tgkill>(2)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:831
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:833
#, no-wrap
msgid "    ptrace(PTRACE_rest, pid, 0, stopsig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:839
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:859
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before signal-delivery-"
"stop.  The tracer can't suppress this side-effect (it can only suppress "
"signal injection, which only causes the B<SIGCONT> handler to not be "
"executed in the tracee, if such a handler is installed).  In fact, waking up "
"from group-stop may be followed by signal-delivery-stop for signal(s)  "
"I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> was "
"delivered.  In other words, B<SIGCONT> may be not the first signal observed "
"by the tracee after it was sent."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:863
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#
#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: build/C/man2/ptrace.2:873
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:890
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:890
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:902
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:911
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via I<WSTOPSIG"
"(status)>.  The same result is returned by some other classes of ptrace-"
"stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:913
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:934
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:943
msgid ""
"As of kernel 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:957
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:957
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:963
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter ptrace-"
"stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:977
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:979
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:981
msgid "The following events exist:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:981
#, fuzzy, no-wrap
#| msgid "B<PTRACE_CONT>"
msgid "B<PTRACE_EVENT_VFORK>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: build/C/man2/ptrace.2:994
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:994
#, fuzzy, no-wrap
#| msgid "B<PTRACE_CONT>"
msgid "B<PTRACE_EVENT_FORK>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: build/C/man2/ptrace.2:1002
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1002
#, fuzzy, no-wrap
#| msgid "B<PTRACE_CONT>"
msgid "B<PTRACE_EVENT_CLONE>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: build/C/man2/ptrace.2:1006
msgid "Stop before return from B<clone>(2)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1006
#, fuzzy, no-wrap
#| msgid "B<PTRACE_PEEKUSER>"
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr "B<PTRACE_PEEKUSER>"

#. type: Plain text
#: build/C/man2/ptrace.2:1016
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1022
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1022
#, fuzzy, no-wrap
#| msgid "B<PTRACE_DETACH>"
msgid "B<PTRACE_EVENT_EXEC>"
msgstr "B<PTRACE_DETACH>"

#. type: Plain text
#: build/C/man2/ptrace.2:1026
msgid "Stop before return from B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1026
#, fuzzy, no-wrap
#| msgid "B<PTRACE_CONT>"
msgid "B<PTRACE_EVENT_EXIT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: build/C/man2/ptrace.2:1042
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1053
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP in> "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1053
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1066
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL>, the tracee enters syscall-"
"enter-stop just prior to entering any system call.  If the tracer restarts "
"the tracee with B<PTRACE_SYSCALL>, the tracee enters syscall-exit-stop when "
"the system call is finished, or if it is interrupted by a signal.  (That is, "
"signal-delivery-stop never happens between syscall-enter-stop and syscall-"
"exit-stop; it happens I<after> syscall-exit-stop.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1080
msgid ""
"Other possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop, "
"exit (if it entered B<_exit>(2)  or B<exit_group>(2)), be killed by "
"B<SIGKILL>, or die silently (if it is a thread group leader, the B<execve>"
"(2)  happened in another thread, and that thread is not traced by the same "
"tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1095
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and I<WSTOPSIG"
"(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> option was set "
"by the tracer, then I<WSTOPSIG(status)> will give the value I<(SIGTRAP\\ |\\ "
"0x80)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1101
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1101
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1113
msgid ""
"B<SIGTRAP> was delivered as a result of a userspace action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1113
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1117
msgid "B<SIGTRAP> was sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1117
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1120
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1125
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1148
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in syscall-enter-"
"stop.  Since B<SIGTRAP> (like any other signal) always happens I<after> "
"syscall-exit-stop, and at this point I<rax> almost never contains -"
"B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not syscall-"
"enter-stop\"; in other words, it looks like a \"stray syscall-exit-stop\" "
"and can be detected this way.  But such detection is fragile and is best "
"avoided."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1154
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinquish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1165
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-"
"stop or vice versa.  The rule is that syscall-enter-stop is always followed "
"by syscall-exit-stop, B<PTRACE_EVENT> stop or the tracee's death; no other "
"kinds of ptrace-stop can occur in between."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1170
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1182
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1182
#, fuzzy, no-wrap
#| msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgid "PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (Linux 2.6.14 以降)"

#
#.  FIXME
#.  document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
#.  PTRACE_SYSEMU_SINGLESTEP
#. type: Plain text
#: build/C/man2/ptrace.2:1188
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1188
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1196
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_TRACEME>, and "
"B<PTRACE_KILL>)  require the tracee to be in a ptrace-stop, otherwise they "
"fail with B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1201
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1211
#, no-wrap
msgid ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1223
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1225
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1227
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1236
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1239
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1241
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1261
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_DETACH>, B<PTRACE_SYSCALL>, "
"B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or B<PTRACE_SYSEMU_SINGLESTEP.> If "
"the tracee is in signal-delivery-stop, I<sig> is the signal to be injected "
"(if it is nonzero).  Otherwise, I<sig> may be ignored.  (When restarting a "
"tracee from a ptrace-stop other than signal-delivery-stop, recommended "
"practice is to always pass 0 in I<sig .)>"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1261
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1263
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1265
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr ""

#
#.  FIXME: Describe how to attach to a thread which is already
#.         group-stopped.
#. type: Plain text
#: build/C/man2/ptrace.2:1289
msgid ""
"This also sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1296
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray I<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1298
msgid "The request"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1300
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1306
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1308
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1311
msgid ""
"and allow the parent (which is our tracer now) to observe our signal-"
"delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1335
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1337
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1339
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1347
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME: Describe how to detach from a group-stopped tracee so that it
#.         doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: build/C/man2/ptrace.2:1371
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1379
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from signal-delivery-"
"stop, the pending signal is injected."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1379
#, no-wrap
msgid "execve(2) under ptrace"
msgstr ""

#
#.  clone(2) THREAD_CLONE says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: build/C/man2/ptrace.2:1398
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: IP
#: build/C/man2/ptrace.2:1398 build/C/man2/ptrace.2:1408
#: build/C/man2/ptrace.2:1414 build/C/man2/ptrace.2:1422
#: build/C/man2/ptrace.2:1558
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1408
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1414
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1422
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1436
msgid ""
"If the thread group leader has reported its death by this time, it appears "
"to the tracer that the dead thread leader \"reappears from nowhere\".  If "
"the thread group leader was still alive, for the tracer this may look as if "
"thread group leader returns from a different system call than it entered, or "
"even \"returned from a system call even though it was not in any system call"
"\".  If the thread group leader was not traced (or was traced by a different "
"tracer), then during B<execve>(2)  it will appear as if it has become a "
"tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1439
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1463
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  It enables B<PTRACE_EVENT_EXEC> stop, which occurs before "
"B<execve>(2)  returns.  First, it enables B<PTRACE_EVENT_EXEC>-stop, which "
"occurs before B<execve(2)> returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0).  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1469
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1477
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1479
#, no-wrap
msgid "    thread ID == thread group ID == process id.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1485
msgid ""
"Currently, there is no way to retrieve the former thread ID of the execing "
"tracee.  If the tracer doesn't keep track of its tracees' thread group "
"relations, it may be unable to know which tracee execed and therefore no "
"longer exists under the old thread ID due to a thread ID change."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1489
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1500
#, no-wrap
msgid ""
"*** we get syscall-entry-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-entry-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1505
msgid ""
"In this situation, there is no way to know which B<execve>(2)  succeeded."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1527
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, the kernel delivers an extra B<SIGTRAP> to the tracee after B<execve>"
"(2)  returns.  This is an ordinary signal (similar to one which can be "
"generated by I<kill -TRAP>), not a special kind of ptrace-stop.  Employing "
"B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set to 0 "
"(I<SI_USER>).  This signal may be blocked by signal mask, and thus may be "
"delivered (much) later."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1546
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option and thus suppressing this extra "
"B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1546
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1553
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1556
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1558
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1566
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1580
#, fuzzy
#| msgid ""
#| "On success, B<PTRACE_PEEK*> requests return the requested data, while "
#| "other requests return zero.  On error, all requests return -1, and "
#| "I<errno> is set appropriately.  Since the value returned by a successful "
#| "B<PTRACE_PEEK*> request may be -1, the caller must check I<errno> after "
#| "such requests to determine whether or not an error occurred."
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must clear I<errno> before the call, and then "
"check it afterward to determine whether or not an error occurred."
msgstr ""
"成功すると、 B<PTRACE_PEEK*> の場合は要求したデータを返し、 それ以外の場合は "
"0 を返す。 エラーの場合は -1 を返し、 I<errno> が適切に設定される。 "
"B<PTRACE_PEEK*> が成功して返す値も　-1 になることがあるため、 そのような要求"
"の場合には、呼び出し元は I<errno> を調べ、エラーか発生したのかどうかを判断し"
"なければならない。"

#. type: Plain text
#: build/C/man2/ptrace.2:1584
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr "(i386 のみ) デバッグレジスタの確保または解放でエラーが発生した。"

#. type: Plain text
#: build/C/man2/ptrace.2:1595
#, fuzzy
#| msgid ""
#| "There was an attempt to read from or write to an invalid area in the "
#| "parent's or child's memory, probably because the area wasn't mapped or "
#| "accessible.  Unfortunately, under Linux, different variations of this "
#| "fault will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""
"親プロセスまたは子プロセスのメモリの不正な領域に読み書きしようとした。 おそら"
"くその領域がマッピングされていないか、 その領域へのアクセスが許されていないか"
"である。 不運なことに、Linux ではこのようなエラーの場合、多かれ少なかれ 恣意"
"的に B<EIO> を返したり B<EFAULT> を返したりすることがある。"

#. type: Plain text
#: build/C/man2/ptrace.2:1598
msgid "An attempt was made to set an invalid option."
msgstr "不正なオプションを設定しようとした。"

#. type: Plain text
#: build/C/man2/ptrace.2:1605
#, fuzzy
#| msgid ""
#| "I<request> is invalid, or an attempt was made to read from or write to an "
#| "invalid area in the parent's or child's memory, or there was a word-"
#| "alignment violation, or an invalid signal was specified during a restart "
#| "request."
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr ""
"I<request> が不正である。 または、親プロセスまたは子プロセスのメモリの 不正な"
"領域に読み書きしようとした。 または、ワード境界違反があった。 または、実行再"
"開の要求で不正なシグナルを指定した。"

#. type: Plain text
#: build/C/man2/ptrace.2:1618
#, fuzzy
#| msgid ""
#| "The specified process cannot be traced.  This could be because the parent "
#| "has insufficient privileges (the required capability is "
#| "B<CAP_SYS_PTRACE>); unprivileged processes cannot trace processes that "
#| "they cannot send signals to or those running set-user-ID/set-group-ID "
#| "programs, for obvious reasons.  Alternatively, the process may already be "
#| "being traced, or be B<init>(8)  (PID 1)."
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(8)  (PID 1)."
msgstr ""
"指定したプロセスをトレースすることができない。これは親プロセスが 必要な権限 "
"(必要なケーパビリティは B<CAP_SYS_PTRACE>)  を持っていないことが原因の場合が"
"ある。 分かりやすい理由を挙げるなら、 非特権プロセスはシグナルを送ることがで"
"きないプロセスをトレースできないし、 set-user-ID/set-group-ID プログラムを実"
"行しているプロセスはトレースできない。 または、プロセスはすでにトレース中であ"
"る、 または B<init>(8)  プロセス (PID が 1) である。"

#. type: TP
#: build/C/man2/ptrace.2:1618 build/C/man2/quotactl.2:459
#: build/C/man2/quotactl.2:502
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/ptrace.2:1623
#, fuzzy
#| msgid ""
#| "The specified process does not exist, or is not currently being traced by "
#| "the caller, or is not stopped (for requests that require that)."
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""
"指定したプロセスが存在しない。 または、指定したプロセスは呼び出したプロセス"
"が 現在トレース中の子プロセスではない。 または、指定したプロセスが停止してい"
"ない (停止していることが必要な要求の場合)。"

#. type: Plain text
#: build/C/man2/ptrace.2:1625
msgid "SVr4, 4.3BSD."
msgstr "SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man2/ptrace.2:1638
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  This means that unneeded "
"trailing arguments may be omitted, though doing so makes use of undocumented "
"B<gcc>(1)  behavior."
msgstr ""
"B<ptrace>()  の引き数は上のようなプロトタイプに基づいて解釈されるが、 glibc "
"では、現在のところ B<ptrace>()  は I<request> 引き数だけが固定の可変長引き数"
"関数として 宣言されている。 これは必要なければ残りの引き数は省略可能であるこ"
"とを意味するが、 それは B<gcc>(1)  の明文化されていない動作を利用していること"
"になる。"

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: build/C/man2/ptrace.2:1643
#, fuzzy
#| msgid "B<init>(8), the process with PID 1, may not be traced."
msgid ""
"In Linux kernels before 2.6.26, B<init>(8), the process with PID 1, may not "
"be traced."
msgstr "B<init>(8)  すなわち PID が 1 のプロセスはトレースすることができない。"

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: build/C/man2/ptrace.2:1650
#, fuzzy
#| msgid ""
#| "The layout of the contents of memory and the USER area are quite OS- and "
#| "architecture-specific.  The offset supplied, and the data returned, might "
#| "not entirely match with the definition of I<struct user>."
msgid ""
"The layout of the contents of memory and the USER area are quite operating-"
"system- and architecture-specific.  The offset supplied, and the data "
"returned, might not entirely match with the definition of I<struct user>."
msgstr ""
"メモリや USER 領域の内容や配置は OS ごと、アーキテクチャごとに 非常に依存す"
"る。 オフセットが指定された場合、返されるデータは I<struct user> の定義と完全"
"に一致しないこともありえる。"

#. type: Plain text
#: build/C/man2/ptrace.2:1653
#, fuzzy
#| msgid ""
#| "The size of a \"word\" is determined by the OS variant (e.g., for 32-bit "
#| "Linux it is 32 bits, etc.)."
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits, etc.)."
msgstr ""
"「ワード (word) 」の大きさは OS によって決まる。 (例えば、32 ビットの Linux "
"では 32 ビットである、など。)"

#. type: Plain text
#: build/C/man2/ptrace.2:1661
#, fuzzy
#| msgid ""
#| "This page documents the way the B<ptrace>()  call works currently in "
#| "Linux.  Its behavior differs noticeably on other flavors of UNIX.  In any "
#| "case, use of B<ptrace>()  is highly OS- and architecture-specific."
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of UNIX.  In any case, use "
"of B<ptrace>()  is highly specific to the operating system and architecture."
msgstr ""
"このマニュアルは現在の Linux における B<ptrace>()  コールの動作について記述し"
"ている。他の UNIX では その動作は著しく異なる。 いかなる場合も B<ptrace>()  "
"を使うと OS やアーキテクチャに非常に依存したものになる。"

#. type: Plain text
#: build/C/man2/ptrace.2:1672
#, fuzzy
#| msgid ""
#| "On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
#| "different value than the one for 2.4.  This leads to applications "
#| "compiled with such headers failing when run on 2.4 kernels.  This can be "
#| "worked around by redefining B<PTRACE_SETOPTIONS> to "
#| "B<PTRACE_OLDSETOPTIONS>, if that is defined."
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""
"カーネル 2.6 のヘッダがインストールされたホストでは、 B<PTRACE_SETOPTIONS> は"
"カーネル 2.4 のヘッダとは異なる値で宣言される。 このため、カーネル 2.6 のヘッ"
"ダでコンパイルされたアプリケーションは カーネル 2.4 では正しく動作しない。 こ"
"の問題は、 B<PTRACE_SETOPTIONS> が定義されていた際は、 B<PTRACE_SETOPTIONS> "
"を B<PTRACE_OLDSETOPTIONS> に定義し直すことで対処できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:1675
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME: ^^^ need to test/verify this scenario
#. type: Plain text
#: build/C/man2/ptrace.2:1706
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls B<execve>"
"(2), the death of the thread group leader will I<never> be reported.  If the "
"execed thread is not traced by this tracer, the tracer will never know that "
"B<execve>(2)  happened.  One possible workaround is to B<PTRACE_DETACH> the "
"thread group leader instead of restarting it in this case.  Last confirmed "
"on 2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1716
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on "
"2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1730
#, fuzzy
#| msgid ""
#| "B<gdb>(1), B<strace>(1), B<execve>(2), B<fork>(2), B<signal>(2), B<wait>"
#| "(2), B<exec>(3), B<capabilities>(7)"
msgid ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), B<gettid>"
"(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), "
"B<capabilities>(7), B<signal>(7)"
msgstr ""
"B<gdb>(1), B<strace>(1), B<execve>(2), B<fork>(2), B<signal>(2), B<wait>(2), "
"B<exec>(3), B<capabilities>(7)"

#. type: TH
#: build/C/man2/quotactl.2:25
#, no-wrap
msgid "QUOTACTL"
msgstr "QUOTACTL"

#. type: TH
#: build/C/man2/quotactl.2:25
#, fuzzy, no-wrap
#| msgid "2010-02-15"
msgid "2010-06-16"
msgstr "2010-02-15"

#. type: Plain text
#: build/C/man2/quotactl.2:28
#, fuzzy
#| msgid "quotactl - manipulate disk quota"
msgid "quotactl - manipulate disk quotas"
msgstr "quotactl - ディスク quota を操作する"

#. type: Plain text
#: build/C/man2/quotactl.2:32
#, fuzzy, no-wrap
#| msgid ""
#| "B<#include E<lt>linux/futex.hE<gt>>\n"
#| "B<#include E<lt>sys/time.hE<gt>>\n"
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/quotactl.2:35
#, no-wrap
msgid "B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, caddr_t >I<addr>B<);>\n"
msgstr "B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, caddr_t >I<addr>B<);>\n"

#. type: Plain text
#: build/C/man2/quotactl.2:47
#, fuzzy
#| msgid ""
#| "The quota system defines for each user and/or group a soft limit and a "
#| "hard limit bounding the amount of disk space that can be used on a given "
#| "file system.  The hard limit cannot be crossed.  The soft limit can be "
#| "crossed, but warnings will ensue.  Moreover, the user cannot be above the "
#| "soft limit for more than one week (by default)  at a time: after this "
#| "week the soft limit counts as hard limit."
msgid ""
"The quota system can be used to set per-user and per-group limits on the "
"amount of disk space used on a file system.  For each user and/or group, a "
"soft limit and a hard limit can be set for each file system.  The hard limit "
"can't be exceeded.  The soft limit can be exceeded, but warnings will "
"ensue.  Moreover, the user can't exceed the soft limit for more than one "
"week (by default) at a time; after this time, the soft limit counts as a "
"hard limit."
msgstr ""
"quota システムは、各々のユーザ及び/またはグループに対して、 ソフト・リミット"
"及びハード・リミットを定める。これはあるファイル・システムで 使用する事が出来"
"るディスク容量を制限する。 ハード・リミットは超過することは出来ない。 ソフ"
"ト・リミットは超過する事が出来るが、警告が発せられる。 更に、(デフォルトで"
"は) 一週間以上ソフト・リミットを超過したままに しておく事はできない: 一週間経"
"過した後はハード・リミットを超過したと みなされる。"

#. type: Plain text
#: build/C/man2/quotactl.2:72
#, fuzzy
#| msgid ""
#| "The B<quotactl>()  system call manipulates these quota.  Its first "
#| "argument is of the form B<QCMD(>I<subcmd>B<,>I<type>B<)> where I<type> is "
#| "either B<USRQUOTA> or B<GRPQUOTA> (for user quota and group quota, "
#| "respectively), and I<subcmd> is described below."
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, or "
"B<GRPQUOTA>, for group quotas.  The I<subcmd> value is described below."
msgstr ""
"B<quotactl>()  システムコールはこれらの quota に対する操作を行なう。 最初の引"
"き数は B<QCMD(>I<subcmd>B<,>I<type>B<)> という形式である。 I<type> には、ユー"
"ザー quota については B<USRQUOTA> を、グループ quota については B<GRPQUOTA> "
"を指定する。 I<subcmd> は以下で説明する。"

#. type: Plain text
#: build/C/man2/quotactl.2:77
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the file system being "
"manipulated."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:85
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each command below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:89
#, fuzzy
#| msgid "The I<subcmd> is one of"
msgid "The I<subcmd> value is one of the following:"
msgstr "I<subcmd> は以下のいずれかである"

#. type: TP
#: build/C/man2/quotactl.2:89
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr "B<Q_QUOTAON>"

#. type: Plain text
#: build/C/man2/quotactl.2:96
msgid ""
"Turn on quotas for a file system.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported "
"quota formats:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:97
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:100
msgid "The original quota format."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:100
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:104
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:104
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:108
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64 "
"bytes and 2^64 inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:119
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the file system.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:119
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr "B<Q_QUOTAOFF>"

#. type: Plain text
#: build/C/man2/quotactl.2:129
msgid ""
"Turn off quotas for a file system.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:129
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr "B<Q_GETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:140
#, fuzzy
#| msgid ""
#| "Get limits and current usage of disk space.  The I<addr> argument is a "
#| "pointer to a dqblk structure (defined in I<E<lt>sys/quota.hE<gt>>)."
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in I<E<lt>sys/"
"quota.hE<gt>> as follows:"
msgstr ""
"ディスク使用量の制限値と現在の使用量を得る。 I<addr> 引き数は (I<E<lt>sys/"
"quota.hE<gt>> で定義された) dqblk 構造体を指すポインタである。"

#. type: Plain text
#: build/C/man2/quotactl.2:145 build/C/man2/quotactl.2:232
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:165
#, no-wrap
msgid ""
"struct dqblk {          /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;   /* absolute limit on disk\n"
"                                  quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;   /* preferred limit on\n"
"                                  disk quota blocks */\n"
"    uint64_t dqb_curspace;     /* current quota block\n"
"                                  count */\n"
"    uint64_t dqb_ihardlimit;   /* maximum number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_isoftlimit;   /* preferred inode limit */\n"
"    uint64_t dqb_curinodes;    /* current number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_btime;        /* time limit for excessive\n"
"                                  disk use */\n"
"    uint64_t dqb_itime;        /* time limit for excessive\n"
"                                  files */\n"
"    uint32_t dqb_valid;        /* bit mask of QIF_*\n"
"                                  constants */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:168
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:179
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:196
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:196
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr "B<Q_SETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:216
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and "
"B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:216
#, fuzzy, no-wrap
#| msgid "B<Q_GETQUOTA>"
msgid "B<Q_GETINFO>"
msgstr "B<Q_GETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:227
#, fuzzy
#| msgid ""
#| "Get limits and current usage of disk space.  The I<addr> argument is a "
#| "pointer to a dqblk structure (defined in I<E<lt>sys/quota.hE<gt>>)."
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""
"ディスク使用量の制限値と現在の使用量を得る。 I<addr> 引き数は (I<E<lt>sys/"
"quota.hE<gt>> で定義された) dqblk 構造体を指すポインタである。"

#. type: Plain text
#: build/C/man2/quotactl.2:236
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;    /* Time before block soft limit\n"
"                               becomes hard limit */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:243
#, no-wrap
msgid ""
"    uint64_t dqi_igrace;    /* Time before inode soft limit\n"
"                               becomes hard limit */\n"
"    uint32_t dqi_flags;     /* Flags for quotafile\n"
"                               (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:245
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:247
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:249
#, no-wrap
msgid "#define V1_DQF_RSQUASH\t1   /* Root squash enabled */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:251
#, no-wrap
msgid "/* Other quota formats have no dqi_flags bits defined */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:254
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:259
#, no-wrap
msgid ""
"# define IIF_BGRACE\t1\n"
"# define IIF_IGRACE\t2\n"
"# define IIF_FLAGS\t4\n"
"# define IIF_ALL\t(IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:275
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of "
"the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:275
#, fuzzy, no-wrap
#| msgid "B<Q_SETQLIM>"
msgid "B<Q_SETINFO>"
msgstr "B<Q_SETQLIM>"

#. type: Plain text
#: build/C/man2/quotactl.2:299
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure "
"indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:299
#, fuzzy, no-wrap
#| msgid "B<Q_GETQUOTA>"
msgid "B<Q_GETFMT>"
msgstr "B<Q_GETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:306
msgid ""
"Get quota format used on the specified file system.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:306
#, no-wrap
msgid "B<Q_SYNC>"
msgstr "B<Q_SYNC>"

#. type: Plain text
#: build/C/man2/quotactl.2:317
msgid ""
"Update the on-disk copy of quota usages for a file system.  If I<special> is "
"NULL, then all file systems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:317
#, no-wrap
msgid "B<Q_GETSTATS>"
msgstr "B<Q_GETSTATS>"

#.  Q_GETSTATS was removed in kernel 2.4.22.
#. type: Plain text
#: build/C/man2/quotactl.2:337
msgid ""
"Get statistics and other generic information about the quota subsystem.  The "
"I<addr> argument should be a pointer to a I<dqstats> structure in which data "
"should be stored.  This structure is defined in I<E<lt>sys/quota.hE<gt>.> "
"The I<special> and I<id> arguments are ignored.  This operation is obsolete "
"and not supported by recent kernels.  Files in I</proc/sys/fs/quota/> carry "
"the information instead."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:340
msgid ""
"For XFS file systems making use of the XFS Quota Manager (XQM), the above "
"commands are bypassed and the following commands are used:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:340
#, fuzzy, no-wrap
#| msgid "B<Q_QUOTAON>"
msgid "B<Q_XQUOTAON>"
msgstr "B<Q_QUOTAON>"

#. type: Plain text
#: build/C/man2/quotactl.2:361
msgid ""
"Turn on quotas for an XFS file system.  XFS provides the ability to turn on/"
"off quota limit enforcement with quota accounting.  Therefore, XFS expects "
"I<addr> to be a pointer to an I<unsigned int> that contains either the flags "
"B<XFS_QUOTA_UDQ_ACCT> and/or B<XFS_QUOTA_UDQ_ENFD> (for user quota), or "
"B<XFS_QUOTA_GDQ_ACCT> and/or B<XFS_QUOTA_GDQ_ENFD> (for group quota), as "
"defined in I<E<lt>xfs/xqm.hE<gt>>.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:361
#, fuzzy, no-wrap
#| msgid "B<Q_QUOTAOFF>"
msgid "B<Q_XQUOTAOFF>"
msgstr "B<Q_QUOTAOFF>"

#. type: Plain text
#: build/C/man2/quotactl.2:372
msgid ""
"Turn off quotas for an XFS file system.  As with B<Q_QUOTAON>, XFS file "
"systems expect a pointer to an I<unsigned int> that specifies whether quota "
"accounting and/or limit enforcement need to be turned off.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:372
#, fuzzy, no-wrap
#| msgid "B<Q_GETQUOTA>"
msgid "B<Q_XGETQUOTA>"
msgstr "B<Q_GETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:386
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure (defined in "
"I<E<lt>xfs/xqm.hE<gt>>).  Unprivileged users may retrieve only their own "
"quotas; a privileged user (B<CAP_SYS_ADMIN>)  may retrieve the quotas of any "
"user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:386
#, fuzzy, no-wrap
#| msgid "B<Q_SETQLIM>"
msgid "B<Q_XSETQLIM>"
msgstr "B<Q_SETQLIM>"

#. type: Plain text
#: build/C/man2/quotactl.2:398
#, fuzzy
#| msgid ""
#| "Get limits and current usage of disk space.  The I<addr> argument is a "
#| "pointer to a dqblk structure (defined in I<E<lt>sys/quota.hE<gt>>)."
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure (defined in I<E<lt>xfs/xqm.hE<gt>>).  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""
"ディスク使用量の制限値と現在の使用量を得る。 I<addr> 引き数は (I<E<lt>sys/"
"quota.hE<gt>> で定義された) dqblk 構造体を指すポインタである。"

#. type: TP
#: build/C/man2/quotactl.2:398
#, fuzzy, no-wrap
#| msgid "B<Q_GETSTATS>"
msgid "B<Q_XGETQSTAT>"
msgstr "B<Q_GETSTATS>"

#. type: Plain text
#: build/C/man2/quotactl.2:406
msgid ""
"Returns an I<fs_quota_stat> structure containing XFS file system specific "
"quota information.  This is useful for finding out how much space is used to "
"store quota information, and also to get quotaon/off status of a given local "
"XFS file system."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:406
#, fuzzy, no-wrap
#| msgid "B<Q_QUOTAON>"
msgid "B<Q_XQUOTARM>"
msgstr "B<Q_QUOTAON>"

#. type: Plain text
#: build/C/man2/quotactl.2:410
msgid ""
"Free the disk space taken by disk quotas.  Quotas must have already been "
"turned off."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:417
msgid ""
"There is no command equivalent to B<Q_SYNC> for XFS since B<sync>(1)  writes "
"quota information to disk (in addition to the other file system metadata "
"that it writes out)."
msgstr ""

#. type: SH
#: build/C/man2/quotactl.2:417
#, fuzzy, no-wrap
#| msgid "RETURN VALUE"
msgid "RETURN VALUES"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/quotactl.2:425
#, fuzzy
#| msgid ""
#| "On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
#| "I<errno> is set to indicate the error."
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"成功すると、 B<arch_prctl>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/quotactl.2:432
msgid "I<addr> or I<special> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:438
msgid "I<cmd> or I<type> is invalid."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:438
#, fuzzy, no-wrap
#| msgid "B<ENOMEM>"
msgid "B<ENOENT>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/quotactl.2:445
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:450
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:450
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: build/C/man2/quotactl.2:454
#, fuzzy
#| msgid "I<special> is not a block special device."
msgid "I<special> is not a block device."
msgstr "I<special> がブロック・スペシャル・デバイスではない。"

#. type: Plain text
#: build/C/man2/quotactl.2:459
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:463
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this file system."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:472
msgid "If I<cmd> is B<Q_SETQUOTA>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:475
msgid "Specified limits are out of range allowed by quota format."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:484
msgid "If I<cmd> is B<Q_QUOTAON>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:493
msgid ""
"The quota file pointed to by I<addr> exists, but is not a regular file; or, "
"the quota file pointed to by I<addr> exists, but is not on the file system "
"pointed to by I<special>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:499
msgid ""
"B<Q_QUOTAON> attempted, but another B<Q_QUOTAON> had already been performed."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:502
#, fuzzy
#| msgid "The quota file is not an ordinary file."
msgid "The quota file is corrupted."
msgstr "quota ファイルが普通のファイルではない。"

#. type: Plain text
#: build/C/man2/quotactl.2:505
msgid "Specified quota format was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:510
#, fuzzy
#| msgid ""
#| "B<quota>(1), B<getrlimit>(2), B<setrlimit>(2), B<ulimit>(3), B<quotacheck>"
#| "(8), B<quotaon>(8)"
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr ""
"B<quota>(1), B<getrlimit>(2), B<setrlimit>(2), B<ulimit>(3), B<quotacheck>"
"(8), B<quotaon>(8)"

#. type: TH
#: build/C/man2/sendfile.2:15
#, no-wrap
msgid "SENDFILE"
msgstr "SENDFILE"

#. type: TH
#: build/C/man2/sendfile.2:15
#, fuzzy, no-wrap
#| msgid "2004-09-10"
msgid "2011-09-14"
msgstr "2004-09-10"

#. type: Plain text
#: build/C/man2/sendfile.2:18
msgid "sendfile - transfer data between file descriptors"
msgstr "sendfile - ファイル・ディスクリプタ間でデータを転送する"

#. type: Plain text
#: build/C/man2/sendfile.2:20
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr "B<#include E<lt>sys/sendfile.hE<gt>>"

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" #.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: build/C/man2/sendfile.2:43
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"

#. type: Plain text
#: build/C/man2/sendfile.2:53
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""
"B<sendfile>()  は、あるファイル・ディスクリプタから別の ファイル・ディスクリ"
"プタへのデータのコピーを行う。 このコピーはカーネル内で行われるので、 "
"B<sendfile>()  は、 B<read>(2)  と B<write>(2)  を組み合わせるよりも効率がよ"
"い。 B<read>(2)  や B<write>(2)  ではユーザ空間との間でデータの転送が必要とな"
"るからである。"

#. type: Plain text
#: build/C/man2/sendfile.2:58
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""
"I<in_fd> は読み込みのためにオープンされたファイル・ディスクリプタ、 "
"I<out_fd> は書き込みのためにオープンされたディスクリプタでなければならない。"

#. type: Plain text
#: build/C/man2/sendfile.2:79
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the current file offset of I<in_fd>; "
"otherwise the current file offset is adjusted to reflect the number of bytes "
"read from I<in_fd>."
msgstr ""
"I<offset> が NULL でない場合、 I<offset> は B<sendfile>()  が I<in_fd> のどこ"
"からデータを読み始めるかを示すファイル・オフセットを保持する変数への ポインタ"
"である。 B<sendfile>()  は復帰する時、この変数に最後に読み込んだバイトの 次の"
"バイトのオフセットを書き込む。 I<offset> が NULL でない場合、 B<sendfile>()  "
"は I<in_fd> のファイル・オフセットの現在値を変更しない。 NULL の場合は、ファ"
"イル・オフセットの現在値を I<in_fd> から読み込んだバイト数を反映した位置に調"
"整する。"

#. type: Plain text
#: build/C/man2/sendfile.2:86
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"current file offset, and the file offset will be updated by the call."
msgstr ""
"I<offset> が NULL の場合、データは I<in_fd> の現在のファイル・オフセットから"
"読み出され、 ファイル・オフセットはこの呼び出しで更新される。"

#. type: Plain text
#: build/C/man2/sendfile.2:89
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr "I<count> は、ファイル・ディスクリプタ間でコピーするバイト数である。"

#. type: Plain text
#: build/C/man2/sendfile.2:96
#, fuzzy
#| msgid ""
#| "Presently (Linux 2.6.9): I<in_fd>, must correspond to a file which "
#| "supports B<mmap>(2)-like operations (i.e., it cannot be a socket); and "
#| "I<out_fd> must refer to a socket."
msgid ""
"The I<in_fd> argument must correspond to a file which supports B<mmap>(2)-"
"like operations (i.e., it cannot be a socket)."
msgstr ""
"今のところ (Linux 2.6.9 では)、 I<in_fd> は B<mmap>(2)  風の操作ができるファ"
"イルを指していなければならない (ソケットを指してはならない)。また、 "
"I<out_fd> はソケットを指していなければならない。"

#. type: Plain text
#: build/C/man2/sendfile.2:104
#, fuzzy
#| msgid ""
#| "In Linux 2.4 and earlier, I<out_fd> could refer to a regular file, and "
#| "B<sendfile>()  changed the current offset of that file."
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then B<sendfile>"
"()  changes the file offset appropriately."
msgstr ""
"Linux 2.4 とそれ以前のバージョンでは、 I<out_fd> は通常のファイルを参照で"
"き、 B<sendfile>()  はそのファイルのオフセットの現在値を変更していた。"

#. type: Plain text
#: build/C/man2/sendfile.2:111
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"転送に成功した場合、 I<out_fd> に書き込まれたバイト数を返す。エラーの場"
"合、-1 を返し、 I<errno> に適切な値を設定する。"

#. type: Plain text
#: build/C/man2/sendfile.2:117
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""
"B<O_NONBLOCK> を用いて非ブロック I/O が選択されたが、書き込みがブロックされ"
"た。"

#. type: TP
#: build/C/man2/sendfile.2:117 build/C/man2/splice.2:143
#: build/C/man2/vmsplice.2:123
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/sendfile.2:121
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""
"入力ファイルが読み込みのためにオープンされていないか、 出力ファイルが書き込み"
"のためにオープンされていない。"

#. type: Plain text
#: build/C/man2/sendfile.2:124
msgid "Bad address."
msgstr "アドレスがおかしい。"

#. type: Plain text
#: build/C/man2/sendfile.2:130
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>."
msgstr ""
"ディスクリプタが有効でないか、ロックされている。もしくは B<mmap>(2)  風の操作"
"が I<in_fd> では利用できない。"

#. type: Plain text
#: build/C/man2/sendfile.2:134
msgid "Unspecified error while reading from I<in_fd>."
msgstr "I<in_fd> から読み込んでいるうちに予期しないエラーが起こった。"

#. type: Plain text
#: build/C/man2/sendfile.2:138
msgid "Insufficient memory to read from I<in_fd>."
msgstr "I<in_fd> から読み込むための十分なメモリがない。"

#. type: Plain text
#: build/C/man2/sendfile.2:144
msgid ""
"B<sendfile>()  is a new feature in Linux 2.2.  The include file I<E<lt>sys/"
"sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""
"B<sendfile> は Linux 2.2 の新しい機能である。 インクルードファイル "
"I<E<lt>sys/sendfile.hE<gt>> は glibc 2.1 から存在している。"

#. type: Plain text
#: build/C/man2/sendfile.2:146
msgid "Not specified in POSIX.1-2001, or other standards."
msgstr "POSIX.1-2001 や他の標準では規定されていない。"

#. type: Plain text
#: build/C/man2/sendfile.2:151
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""
"他の UNIX システムでは、異なった方式やプロトタイプで B<sendfile>()  を実装し"
"ている。移植性を考慮したプログラムでは使用すべきではない。"

#. type: Plain text
#: build/C/man2/sendfile.2:161
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""
"B<sendfile>()  を使って TCP ソケットにファイルを送ろうとしていて、 ファイルの"
"内容の前にヘッダ・データを付け加える必要がある場合は、 パケット数を最小にして"
"性能を上げるために B<tcp>(7)  に記述されている B<TCP_CORK> オプションを使うと"
"いいだろう。"

#. type: Plain text
#: build/C/man2/sendfile.2:167
#, fuzzy
#| msgid ""
#| "In Linux 2.4 and earlier, I<out_fd> could refer to a regular file, and "
#| "B<sendfile>()  changed the current offset of that file."
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file, and "
"B<sendfile>()  changed the current offset of that file."
msgstr ""
"Linux 2.4 とそれ以前のバージョンでは、 I<out_fd> は通常のファイルを参照で"
"き、 B<sendfile>()  はそのファイルのオフセットの現在値を変更していた。"

#. type: Plain text
#: build/C/man2/sendfile.2:179
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:188
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""
"B<sendfile>()  が B<EINVAL> や B<ENOSYS> で失敗するような場合は、 アプリケー"
"ションは B<read>(2)/B<write>(2)  に戻すことを考えてもよいかもしれない。"

#. type: Plain text
#: build/C/man2/sendfile.2:193
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary files (e.g., a pair of sockets)."
msgstr ""

#. type: Plain text
#: build/C/man2/sendfile.2:198
msgid "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"

#. type: TH
#: build/C/man2/set_tid_address.2:23
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr "SET_TID_ADDRESS"

#. type: TH
#: build/C/man2/set_tid_address.2:23
#, no-wrap
msgid "2004-09-10"
msgstr "2004-09-10"

#. type: Plain text
#: build/C/man2/set_tid_address.2:26
msgid "set_tid_address - set pointer to thread ID"
msgstr "set_tid_address - スレッド ID へのポインタを設定する"

#. type: Plain text
#: build/C/man2/set_tid_address.2:29
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/set_tid_address.2:31
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr "B<long set_tid_address(int *>I<tidptr>B<);>\n"

#. type: Plain text
#: build/C/man2/set_tid_address.2:38
msgid ""
"The kernel keeps for each process two values called I<set_child_tid> and "
"I<clear_child_tid> that are NULL by default."
msgstr ""
"カーネルは各プロセスについて I<set_child_tid> と I<clear_child_tid> という 2 "
"つの値を保持する。 これらはデフォルトでは NULL である。"

#. type: SS
#: build/C/man2/set_tid_address.2:38
#, no-wrap
msgid "set_child_tid"
msgstr "set_child_tid"

#. type: Plain text
#: build/C/man2/set_tid_address.2:48
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to I<child_tidptr>, the fifth argument of that "
"system call."
msgstr ""
"プロセスが B<CLONE_CHILD_SETTID> フラグを指定した B<clone>(2)  によって開始さ"
"れた場合、 I<set_child_tid> は I<child_tidptr> に設定される。 これは B<clone>"
"(2)  のシステムコールの 5 番目の引き数である。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:53
msgid ""
"When I<set_child_tid> is set, the very first thing the new process does is "
"writing its PID at this address."
msgstr ""
"I<set_child_tid> が設定された場合、一番最初に新しいプロセスが行うことは、 こ"
"のアドレスに自身の PID を書き込むことである。"

#. type: SS
#: build/C/man2/set_tid_address.2:53
#, no-wrap
msgid "clear_child_tid"
msgstr "clear_child_tid"

#. type: Plain text
#: build/C/man2/set_tid_address.2:63
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to I<child_tidptr>, the fifth argument of "
"that system call."
msgstr ""
"プロセスが B<CLONE_CHILD_CLEARTID> フラグを指定した B<clone>(2)  によって開始"
"された場合、 I<clear_child_tid> は I<child_tidptr> に設定される。 これは "
"B<clone>(2)  のシステムコールの 5 番目の引き数である。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:70
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling process to I<tidptr>."
msgstr ""
"システムコール B<set_tid_address>()  は呼び出し元プロセスの "
"I<clear_child_tid> の値を I<tidptr> に設定する。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:80
msgid ""
"When I<clear_child_tid> is set, and the process exits, and the process was "
"sharing memory with other processes or threads, then 0 is written at this "
"address, and a I<futex(child_tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);> call is "
"done.  (That is, wake a single process waiting on this futex.)  Errors are "
"ignored."
msgstr ""
"I<clear_child_tid> が設定されているときにプロセスが終了すると、 そのプロセス"
"は他のプロセスまたはスレッドとメモリを共有しているので、 このアドレスに 0 が"
"書き込まれ、 I<futex(child_tidptr, FUTEX_WAKE, 1, NULL, NULL, 0);> の呼び出し"
"が実行される (つまり、この futex で待っている 1 つのプロセスを起こす "
"(wake))。 エラーは無視される。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:83
msgid "B<set_tid_address>()  always returns the PID of the calling process."
msgstr "B<set_tid_address>()  は常に現在のプロセスの PID を返す。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:86
msgid "B<set_tid_address>()  always succeeds."
msgstr "B<set_tid_address>()  は常に成功する。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:89
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""
"この呼び出しは Linux 2.5.48 以降で存在する。 ここで書かれた詳細は Linux "
"2.5.49 以降で有効である。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:94
msgid "B<clone>(2), B<futex>(2)"
msgstr "B<clone>(2), B<futex>(2)"

#. type: TH
#: build/C/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr "SPLICE"

#. type: TH
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "2009-09-15"
msgstr "2009-09-15"

#. type: Plain text
#: build/C/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr "splice - パイプとの間でデータを継ぎ合わせる"

#. type: Plain text
#: build/C/man2/splice.2:33 build/C/man2/tee.2:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#.  Return type was long before glibc 2.7
#. type: Plain text
#: build/C/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the descriptors must refer to a pipe."
msgstr ""
"B<splice>()  は、カーネルアドレス空間とユーザアドレス空間との間のコピーを伴わ"
"ずに、 2 つのファイルディスクリプタ間でデータの移動を行う。 ファイルディスク"
"リプタ I<fd_in> からファイルディスクリプタ I<fd_out> へ最大 I<len> バイトを転"
"送する。 2 つのファイルディスクリプタのうち一つは パイプを参照していなければ"
"ならない。"

#. type: Plain text
#: build/C/man2/splice.2:80
msgid ""
"If I<fd_in> refers to a pipe, then I<off_in> must be NULL.  If I<fd_in> does "
"not refer to a pipe and I<off_in> is NULL, then bytes are read from I<fd_in> "
"starting from the current file offset, and the current file offset is "
"adjusted appropriately.  If I<fd_in> does not refer to a pipe and I<off_in> "
"is not NULL, then I<off_in> must point to a buffer which specifies the "
"starting offset from which bytes will be read from I<fd_in>; in this case, "
"the current file offset of I<fd_in> is not changed.  Analogous statements "
"apply for I<fd_out> and I<off_out>."
msgstr ""
"I<fd_in> がパイプを参照している場合、 I<off_in> は NULL でなければならない。 "
"I<fd_in> がパイプを参照しておらず、 I<off_in> が NULL の場合、 I<fd_in> の現"
"在のファイルオフセットから始まるバイトを読み出す。 現在のファイルオフセットは"
"適切に調整される。 I<fd_in> がパイプを参照しておらず、 I<off_in> が NULL でな"
"い場合、 I<off_in> は I<fd_in> からのデータ読み出しを開始する先頭オフセットを"
"格納したバッファ へのポインタでなければならない。この場合、 I<fd_in> の現在の"
"ファイルオフセットは変更されない。 I<fd_out> と I<off_out> に関しても同様であ"
"る。"

#. type: Plain text
#: build/C/man2/splice.2:85 build/C/man2/vmsplice.2:78
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""
"I<flags> 引き数には、以下の値の 0 個以上をビット毎の論理和の形で指定する。"

#. type: TP
#: build/C/man2/splice.2:85 build/C/man2/tee.2:62 build/C/man2/vmsplice.2:78
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr "B<SPLICE_F_MOVE>"

#. type: Plain text
#: build/C/man2/splice.2:98
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""
"ページのコピーでなく移動を試みる。 これはカーネルに対するヒントでしかない。 "
"つまり、カーネルがパイプからページを移動できない場合や、 パイプバッファがペー"
"ジ全部を参照していない場合は、 ページのコピーが行われることもある。 このフラ"
"グの最初の実装にはバグがあった。そのため、 Linux 2.6.21 以降ではこのフラグの"
"操作はできないようになっている (ただし、 B<splice>()  コールでこのフラグを指"
"定することは今も認められている)。 将来、正しい実装が行われることだろう。"

#. type: TP
#: build/C/man2/splice.2:98 build/C/man2/tee.2:68 build/C/man2/vmsplice.2:84
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr "B<SPLICE_F_NONBLOCK>"

#. type: Plain text
#: build/C/man2/splice.2:107
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""
"入出力時に停止 (block) しない。 このフラグを指定すると、 splice によるパイプ"
"操作を非停止モード (nonblocking) で 行おうとするが、その場合でも B<splice>"
"()  は停止することもある。なぜなら、データのやり取りを行う ファイルディスクリ"
"プタは (B<O_NONBLOCK> フラグをセットされていない場合) 停止する可能性があるか"
"らである。"

#. type: TP
#: build/C/man2/splice.2:107 build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr "B<SPLICE_F_MORE>"

#. type: Plain text
#: build/C/man2/splice.2:121
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))"
msgstr ""
"この後の splice でさらに転送されるデータがあることを示す。 このフラグは "
"I<fd_out> がソケットを参照している場合に有用なヒントとなる (B<send>(2)  の "
"B<MSG_MORE> や B<tcp>(7)  の B<TCP_CORK> の説明も参照)。"

#. type: TP
#: build/C/man2/splice.2:121 build/C/man2/tee.2:79 build/C/man2/vmsplice.2:97
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr "B<SPLICE_F_GIFT>"

#. type: Plain text
#: build/C/man2/splice.2:127
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr "B<splice>()  では使用しない。 B<vmsplice>(2)  参照。"

#. type: Plain text
#: build/C/man2/splice.2:136
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe.  A return value of 0 means that there was no data to "
"transfer, and it would not make sense to block, because there are no writers "
"connected to the write end of the pipe referred to by I<fd_in>."
msgstr ""
"成功して完了すると、 B<splice>()  はパイプから出し入れしたバイト数を返す。 返"
"り値 0 はデータの転送が行わなかったことを示す。 この場合、処理を停止 (block) "
"しても無意味である。 なぜなら、 I<fd_in> が参照するパイプの書き込み側に接続さ"
"れている者がいないからである。"

#. type: Plain text
#: build/C/man2/splice.2:142
msgid ""
"On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""
"エラーの場合、 B<splice>()  は -1 を返し、 I<errno> にエラーを示す値を設定す"
"る。"

#. type: Plain text
#: build/C/man2/splice.2:147
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""
"ファイルディスクリプタの一方または両方が有効ではない、 もしくは適切な read-"
"write モードではない。"

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: build/C/man2/splice.2:155
msgid ""
"Target file system doesn't support splicing; target file is opened in append "
"mode; neither of the descriptors refers to a pipe; or offset given for "
"nonseekable device."
msgstr ""
"対象のファイルシステムが splice に対応していない、 または対象のファイルが追記"
"モードでオープンされている、 またはディスクリプタのどちらもパイプを参照してい"
"ない、 または seek できないデバイスに対してオフセットが指定された。"

#. type: Plain text
#: build/C/man2/splice.2:158 build/C/man2/tee.2:114
#: build/C/man2/vmsplice.2:138
msgid "Out of memory."
msgstr "メモリ不足。"

#. type: TP
#: build/C/man2/splice.2:158
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: build/C/man2/splice.2:165
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""
"I<off_in> か I<off_out> のいずれかが NULL ではないが、対応するファイルディス"
"クリプタが パイプを参照している。"

#. type: Plain text
#: build/C/man2/splice.2:169
msgid "The B<splice>()  system call first appeared in Linux 2.6.17."
msgstr "B<splice>()  システムコールは Linux 2.6.17 で初めて登場した。"

#. type: Plain text
#: build/C/man2/splice.2:181
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"userspace programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""
"3 つのシステムコール (B<splice>(), B<vmsplice>(2), B<tee>(2))  を使うと、ユー"
"ザ空間プログラムは任意のカーネルバッファに対する 完全な制御ができる。カーネル"
"バッファは、パイプに使用されているのと 同種のバッファを使ってカーネル内に実装"
"されている。 大まかにいうと、これらのシステムコールは以下の仕事を行う:"

#. type: TP
#: build/C/man2/splice.2:181
#, no-wrap
msgid "B<splice>()"
msgstr "B<splice>()"

#. type: Plain text
#: build/C/man2/splice.2:185
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr ""
"バッファから任意のファイルディスクリプタや、その逆方向、 もしくはあるバッファ"
"から別のバッファへの、データ移動を行う。"

#. type: TP
#: build/C/man2/splice.2:185
#, no-wrap
msgid "B<tee>(2)"
msgstr "B<tee>(2)"

#. type: Plain text
#: build/C/man2/splice.2:188
msgid "\"copies\" the data from one buffer to another."
msgstr "あるバッファから別のバッファへのデータ「コピー」を行う。"

#. type: TP
#: build/C/man2/splice.2:188
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr "B<vmsplice>(2)"

#. type: Plain text
#: build/C/man2/splice.2:191
msgid "\"copies\" data from user space into the buffer."
msgstr "ユーザ空間からバッファへのデータ「コピー」を行う。"

#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: build/C/man2/splice.2:222
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""
"ここではコピーの話をしているが、実際のコピーは一般的に回避される。 カーネル"
"は、パイプ・バッファをカーネルメモリのページへのポインタ集合として 実装し、"
"ページへの参照回数を管理することで、これを実現している。 カーネルは、対象とな"
"るページを参照する (出力バッファ用の) ポインタを 新規に作成することでバッファ"
"内のページの「コピー」を作成し、 そのページの参照回数を増やす。つまり、ポイン"
"タだけがコピーされ、 バッファのページはコピーされない。"

#. type: SH
#: build/C/man2/splice.2:222 build/C/man2/tee.2:129
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man2/splice.2:225
msgid "See B<tee>(2)."
msgstr "B<tee>(2)  参照。"

#. type: Plain text
#: build/C/man2/splice.2:229
msgid "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"
msgstr "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"

#. type: TH
#: build/C/man2/tee.2:26
#, no-wrap
msgid "TEE"
msgstr "TEE"

#. type: Plain text
#: build/C/man2/tee.2:29
msgid "tee - duplicating pipe content"
msgstr "tee - パイプの中身を複製する"

#. type: Plain text
#: build/C/man2/tee.2:36
#, no-wrap
msgid "B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"

#.  Example programs http://brick.kernel.dk/snaps
#.  add a "tee(in, out1, out2)" system call that duplicates the pages
#.  (again, incrementing their reference count, not copying the data) from
#.  one pipe to two other pipes.
#. type: Plain text
#: build/C/man2/tee.2:56
msgid ""
"B<tee>()  duplicates up to I<len> bytes of data from the pipe referred to by "
"the file descriptor I<fd_in> to the pipe referred to by the file descriptor "
"I<fd_out>.  It does not consume the data that is duplicated from I<fd_in>; "
"therefore, that data can be copied by a subsequent B<splice>(2)."
msgstr ""
"B<tee>()  は、ファイルディスクリプタ I<fd_in> が参照するパイプからファイル"
"ディスクリプタ I<fd_out> が参照するパイプへ最大 I<len> バイトのデータを複製す"
"る。 この操作では、複製されるデータは I<fd_in> からは消費されない。したがっ"
"て、これらのデータをこの後の B<splice>(2)  でコピーすることができる。"

#. type: Plain text
#: build/C/man2/tee.2:62
msgid ""
"I<flags> is a series of modifier flags, which share the name space with "
"B<splice>(2)  and B<vmsplice>(2):"
msgstr ""
"I<flags> は一連の修飾フラグであり、 B<splice>(2)  や B<vmsplice>(2)  と共通の"
"名前である。"

#. type: Plain text
#: build/C/man2/tee.2:68
msgid "Currently has no effect for B<tee>(); see B<splice>(2)."
msgstr "現在のところ B<tee>()  では何の効果もない。 B<splice>(2)  参照。"

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr "入出力で停止 (block) しない。詳細は B<splice>(2)  参照。"

#. type: Plain text
#: build/C/man2/tee.2:79
msgid ""
"Currently has no effect for B<tee>(), but may be implemented in the future; "
"see B<splice>(2)."
msgstr ""
"現在のところ B<tee>()  では何の効果もないが、将来的には実装される可能性があ"
"る。 B<splice>(2)  参照。"

#. type: Plain text
#: build/C/man2/tee.2:85
msgid "Unused for B<tee>(); see B<vmsplice>(2)."
msgstr "B<tee>()  では未使用。 B<vmsplice>(2)  参照。"

#. type: Plain text
#: build/C/man2/tee.2:94
msgid ""
"Upon successful completion, B<tee>()  returns the number of bytes that were "
"duplicated between the input and output.  A return value of 0 means that "
"there was no data to transfer, and it would not make sense to block, because "
"there are no writers connected to the write end of the pipe referred to by "
"I<fd_in>."
msgstr ""
"成功して完了すると、 B<tee>()  は入出力間で複製されたバイト数を返す。 返り値 "
"0 はデータの転送が行われなかったことを示す。 この場合、処理を停止 (block) し"
"ても無意味である。 なぜなら、 I<fd_in> が参照するパイプの書き込み側に接続され"
"ている者がいないからである。"

#. type: Plain text
#: build/C/man2/tee.2:100
msgid ""
"On error, B<tee>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""
"エラーの場合、 B<tee>()  は -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/tee.2:111
msgid ""
"I<fd_in> or I<fd_out> does not refer to a pipe; or I<fd_in> and I<fd_out> "
"refer to the same pipe."
msgstr ""
"I<fd_in> と I<fd_out> のどちらかがパイプを参照していない。もしくは I<fd_in> "
"と I<fd_out> が同じパイプを参照している。"

#. type: Plain text
#: build/C/man2/tee.2:118
msgid "The B<tee>()  system call first appeared in Linux 2.6.17."
msgstr "B<tee>()  システムコールは Linux 2.6.17 で初めて登場した。"

#. type: Plain text
#: build/C/man2/tee.2:129
msgid ""
"Conceptually, B<tee>()  copies the data between the two pipes.  In reality "
"no real data copying takes place though: under the covers, B<tee>()  assigns "
"data in the output by merely grabbing a reference to the input."
msgstr ""
"概念としては、 B<tee>()  は二つのパイプ間でデータのコピーを行う。 しかし、実"
"際には実データのコピーは行われない。 内部では、 B<tee>()  は入力側に対する参"
"照だけを作成することで出力側にデータを 追加する。"

#. type: Plain text
#: build/C/man2/tee.2:135
msgid ""
"The following example implements a basic B<tee>(1)  program using the B<tee>"
"()  system call."
msgstr ""
"以下の例は、 B<tee>()  システムコールを使って、 基本的な B<tee>(1)  プログラ"
"ムを実装したものである。"

#. type: Plain text
#: build/C/man2/tee.2:144
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"

#. type: Plain text
#: build/C/man2/tee.2:150
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"

#. type: Plain text
#: build/C/man2/tee.2:155
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/tee.2:161
#, no-wrap
msgid ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/tee.2:168
#, no-wrap
msgid ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"
msgstr ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"

#. type: Plain text
#: build/C/man2/tee.2:177
#, no-wrap
msgid ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"
msgstr ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"

#. type: Plain text
#: build/C/man2/tee.2:191
#, no-wrap
msgid ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"
msgstr ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"

#. type: Plain text
#: build/C/man2/tee.2:195
#, no-wrap
msgid ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/tee.2:199
msgid "B<splice>(2), B<vmsplice>(2)"
msgstr "B<splice>(2), B<vmsplice>(2)"

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr "VM86"

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr "2009-02-20"

#. type: Plain text
#: build/C/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr "vm86old, vm86 - 仮想 8086 モードへ移行する"

#. type: Plain text
#: build/C/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr "B<#include E<lt>sys/vm86.hE<gt>>"

#. type: Plain text
#: build/C/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr "B<int vm86old(struct vm86_struct *>I<info>B<);>"

#. type: Plain text
#: build/C/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""
"B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"

#. type: Plain text
#: build/C/man2/vm86.2:46
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28 it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""
"B<vm86>()  システムコールは Linux 0.97p2 で導入された。 これは Linux 2.1.15 "
"と 2.0.28 で B<vm86old>()  に名前が変更され、 新しい B<vm86>()  が導入され"
"た。 I<struct vm86_struct> の定義は 1.1.8 と 1.1.9 で変更された。"

#. type: Plain text
#: build/C/man2/vm86.2:50
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""
"これらのコールによってプロセスは VM86 モード (Intel の文書では仮想 8086 モー"
"ド) へと移行する。 これらのコールは B<dosemu> で使用される。"

#. type: Plain text
#: build/C/man2/vm86.2:52
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""
"VM86 モードはプロテクトモードタスクにおける リアルモードのエミュレーションで"
"ある。"

#. type: Plain text
#: build/C/man2/vm86.2:62
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"userspace data."
msgstr ""
"この返り値は i386 固有のものであり、 ユーザー空間のデータを取得する際に問題が"
"あったことを示す。"

#. type: Plain text
#: build/C/man2/vm86.2:66
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""
"この返り値は、このコールが現在のアーキテクチャで実装されていないことを示す。"

#. type: Plain text
#: build/C/man2/vm86.2:71
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should only exist within vm86 mode itself.)"
msgstr ""
"保存されたカーネルスタックが既に存在している。(これはカーネルが通常の 状態で"
"あるかをチェックしている。保存されたスタックは vm86 モードで しか存在しな"
"い。)"

#. type: Plain text
#: build/C/man2/vm86.2:74
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""
"この関数は 32 ビット Intel プロセッサ上の Linux 特有の関数であり、 移植を意図"
"したプログラムでは使用すべきでない。"

#. type: TH
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr "VMSPLICE"

#. type: Plain text
#: build/C/man2/vmsplice.2:29
msgid "vmsplice - splice user pages into a pipe"
msgstr "vmsplice - ユーザ・ページをパイプに継ぎ合わせる"

#. type: Plain text
#: build/C/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#. type: Plain text
#: build/C/man2/vmsplice.2:57
msgid ""
"The B<vmsplice>()  system call maps I<nr_segs> ranges of user memory "
"described by I<iov> into a pipe.  The file descriptor I<fd> must refer to a "
"pipe."
msgstr ""
"B<vmsplice>()  システムコールは、 I<iov> で指定されたユーザ・メモリの "
"I<nr_segs> の範囲をパイプにマッピングする。 I<fd> はパイプを参照していなけれ"
"ばならない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:64
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""
"ポインタ I<iov> は I<iovec> 構造体の配列を指す。 I<iovec> 構造体は "
"I<E<lt>sys/uio.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/vmsplice.2:71
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;            /* Starting address */\n"
"    size_t iov_len;             /* Number of bytes */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;            /* 開始アドレス */\n"
"    size_t iov_len;             /* バイト数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/vmsplice.2:84
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr "B<vmsplice>()  では未使用。 B<splice>(2)  参照。"

#. type: Plain text
#: build/C/man2/vmsplice.2:97
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""
"現在のところ B<vmsplice>()  では何の効果もないが、将来的には実装される可能性"
"がある。 B<splice>(2)  参照。"

#.  FIXME Explain the following line in a little more detail:
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: build/C/man2/vmsplice.2:113
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, or page cache and on-disk data may differ.  Gifting pages "
"to the kernel means that a subsequent B<splice>(2)  B<SPLICE_F_MOVE> can "
"successfully move the pages; if this flag is not specified, then a "
"subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the pages.  Data must "
"also be properly page aligned, both in memory and length."
msgstr ""
"ユーザ・ページがカーネルへ渡すもの (gift) であることを示す。 アプリケーション"
"はこのメモリを絶対に変更してはならない。 さもなければ、ページキャッシュとディ"
"スク上のデータは 一致しなくなるだろう。 ページをカーネルに渡すと、この次の "
"B<splice>(2)  B<SPLICE_F_MOVE> でそのページの移動を行うことができる。 このフ"
"ラグが指定されなかった場合、この次の B<splice>(2)  B<SPLICE_F_MOVE> でその"
"ページのコピーを行わなければならない。 データはメモリ上でページ境界にあってい"
"なければならず、 長さもページ境界の倍数でなければならない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:122
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""
"成功して完了すると、 B<vmsplice>()  はパイプに転送したバイト数を返す。 エラー"
"の場合、 B<vmplice>()  は -1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/vmsplice.2:127
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr "I<fd> が有効でない、もしくはパイプを参照していない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:135
msgid ""
"I<nr_segs> is 0 or greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""
"I<nr_segs> が 0 もしくは B<IOV_MAX> よりも大きい。または B<SPLICE_F_GIFT> が"
"設定されたがメモリがページ境界にあっていない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:142
msgid "The B<vmsplice>()  system call first appeared in Linux 2.6.17."
msgstr "B<vmsplice>()  システムコールは Linux 2.6.17 で初めて登場した。"

#. type: Plain text
#: build/C/man2/vmsplice.2:153
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on number of segments being passed in.  This limit "
"is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  At the time of this "
"writing, that limit is 1024."
msgstr ""
"指定されたセグメント数が上限に達した場合、 B<vmsplice>()  は他のベクトル形式"
"の read/write を行う関数と同じ動作をする。 上限は B<IOV_MAX> であり、 "
"I<E<lt>limits.hE<gt>> で定義されている。 このドキュメントを書いた時点での値"
"は 1024 である。"

#. type: Plain text
#: build/C/man2/vmsplice.2:156
msgid "B<splice>(2), B<tee>(2)"
msgstr "B<splice>(2), B<tee>(2)"

#~ msgid "1997-07-16"
#~ msgstr "1997-07-16"

#~ msgid ""
#~ "Stop the child at the next B<execve>(2)  call with I<SIGTRAP | "
#~ "PTRACE_EVENT_EXEC\\ E<lt>E<lt>\\ 8>."
#~ msgstr ""
#~ "次の B<execve>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_EXEC\\ E<lt>E<lt>"
#~ "\\ 8> で子プロセスの動作を停止させる。"

#~ msgid ""
#~ "Stop the child at the completion of the next B<vfork>(2)  call with "
#~ "I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ E<lt>E<lt>\\ 8>."
#~ msgstr ""
#~ "次の B<vfork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ "
#~ "E<lt>E<lt>\\ 8> で子プロセスの動作を停止させる。"

#~ msgid ""
#~ "Attaches to the process specified in I<pid>, making it a traced \"child\" "
#~ "of the calling process; the behavior of the child is as if it had done a "
#~ "B<PTRACE_TRACEME>.  The calling process actually becomes the parent of "
#~ "the child process for most purposes (e.g., it will receive notification "
#~ "of child events and appears in B<ps>(1)  output as the child's parent), "
#~ "but a B<getppid>(2)  by the child will still return the PID of the "
#~ "original parent.  The child is sent a B<SIGSTOP>, but will not "
#~ "necessarily have stopped by the completion of this call; use B<wait>(2)  "
#~ "to wait for the child to stop.  (I<addr> and I<data> are ignored.)"
#~ msgstr ""
#~ "I<pid> で指定されたプロセスに接続 (attach) し、それを呼び出し元のプロセス"
#~ "の 子プロセスとしてトレースできるようにする。子プロセスは "
#~ "B<PTRACE_TRACEME> したかのように振舞う。呼び出し元のプロセスはそのほとんど"
#~ "の目的において、 その子プロセスの実際の親になる (例えば、子プロセスのイベ"
#~ "ントの 通知を受けとったり、 B<ps>(1)  で親として表示されたりする)。しか"
#~ "し、子プロセスで B<getppid>(2)  を実行した場合には元の親プロセスの PID が"
#~ "返される。 子プロセスには B<SIGSTOP> が送られるが、この呼び出しが完了する"
#~ "までに 必ずしも停止するとは限らない。子プロセスの停止を待つには B<wait>"
#~ "(2)  を使用すること。(I<addr> と I<data> は無視される。)"

#~ msgid ""
#~ "Tracing causes a few subtle differences in the semantics of traced "
#~ "processes.  For example, if a process is attached to with "
#~ "B<PTRACE_ATTACH>, its original parent can no longer receive notification "
#~ "via B<wait>(2)  when it stops, and there is no way for the new parent to "
#~ "effectively simulate this notification."
#~ msgstr ""
#~ "トレースすることによってトレースされるプロセスの動作に些細な違いが 起こる"
#~ "ことがある。例えば、プロセスが B<PTRACE_ATTACH> によって接続された場合に"
#~ "は、そのプロセスが停止した時でも本来の親は B<wait>(2)  を使って通知を受け"
#~ "ることができず、新しい親が効率よく この通知を真似る方法もない。"

#~ msgid ""
#~ "When the parent receives an event with B<PTRACE_EVENT_*> set, the child "
#~ "is not in the normal signal delivery path.  This means the parent cannot "
#~ "do B<ptrace>(PTRACE_CONT)  with a signal or B<ptrace>(PTRACE_KILL).  "
#~ "B<kill>(2)  with a B<SIGKILL> signal can be used instead to kill the "
#~ "child process after receiving one of these messages."
#~ msgstr ""
#~ "親プロセスが B<PTRACE_EVENT_*> がセットされたイベントを受信した場合、 子プ"
#~ "ロセスは通常通りのシグナル配送が行われる状態にない。 つまり、親プロセス"
#~ "が、 シグナルにより B<ptrace>(PTRACE_CONT)  を行ったり、 B<ptrace>"
#~ "(PTRACE_KILL)  を行ったりできないということである。 こららのメッセージの受"
#~ "信後は、子プロセスを終了 (kill) するのに、 シグナル B<SIGKILL> を指定して "
#~ "B<kill>(2)  を行う方法を代わりに使用できる。"

#~ msgid ""
#~ "The SunOS man page describes B<ptrace>()  as \"unique and arcane\", which "
#~ "it is.  The proc-based debugging interface present in Solaris 2 "
#~ "implements a superset of B<ptrace>()  functionality in a more powerful "
#~ "and uniform way."
#~ msgstr ""
#~ "SunOS のマニュアル・ページには B<ptrace>()  は「独特で不可解」と記述されて"
#~ "おり、まさしくそうである。 Solaris 2 では proc ベースの デバッグのインター"
#~ "フェースとして B<ptrace>()  の上位互換関数が実装され、より強力で一貫性のあ"
#~ "るものとなっている。"

#~ msgid "B<#include E<lt>sys/quota.hE<gt>>\n"
#~ msgstr "B<#include E<lt>sys/quota.hE<gt>>\n"

#~ msgid ""
#~ "The second argument I<special> is the block special device these quota "
#~ "apply to.  It must be mounted."
#~ msgstr ""
#~ "二番目の引き数 I<special> は quota を適用するデバイスのブロック・スペシャ"
#~ "ル・ファイルである。 そのデバイスはマウントされていなくてはならない。"

#~ msgid ""
#~ "The third argument I<id> is the user or group ID these quota apply to "
#~ "(when relevant)."
#~ msgstr ""
#~ "三番目の引き数 I<id> には、(必要な場合に) quota を適用するユーザーもしくは"
#~ "グループの ID を指定する。"

#~ msgid ""
#~ "The fourth argument I<addr> is the address of a data structure, depending "
#~ "on the command."
#~ msgstr ""
#~ "四番目の引き数 I<addr> には、コマンドごとに異ったデータ構造体のアドレスを"
#~ "指定する。"

#~ msgid ""
#~ "Enable quota.  The I<addr> argument is the pathname of the file "
#~ "containing the quota for the file system."
#~ msgstr ""
#~ "quota を有効にする。 I<addr> 引き数には、そのファイル・システムの quota が"
#~ "記録されているファイルの パス名を指定する。"

#~ msgid "Disable quota."
#~ msgstr "quota を無効にする。"

#~ msgid "Set limits and current usage; I<addr> is as before."
#~ msgstr "制限値と現在の使用量を設定する: I<addr> は同上。"

#~ msgid "Set limits; I<addr> is as before."
#~ msgstr "制限値を設定する; I<addr> は同上。"

#~ msgid "B<Q_SETUSE>"
#~ msgstr "B<Q_SETUSE>"

#~ msgid "Set usage."
#~ msgstr "使用量を設定する。"

#~ msgid "Sync disk copy of a file system's quota."
#~ msgstr "ファイル・システムの quota ファイルをディスクと同期させる。"

#~ msgid "Get collected stats."
#~ msgstr "収集された統計を取得する。"

#~ msgid ""
#~ "On success, B<quotactl>()  returns 0.  On error, -1 is returned, and "
#~ "I<errno> is set appropriately."
#~ msgstr ""
#~ "B<quotactl>()  は、成功時には 0 を返す。エラー時は、-1 を返すとともに、 "
#~ "I<errno> が適切な値に設定される。"

#~ msgid "B<Q_QUOTAON> was asked, but quotas were enabled already."
#~ msgstr "B<Q_QUOTAON> の要求がなされたが、quota(s) は既に有効になっている。"

#~ msgid "Bad I<addr> value."
#~ msgstr "I<addr> の値に誤りがある。"

#~ msgid ""
#~ "I<type> is not a known quota type.  Or, I<special> could not be found."
#~ msgstr ""
#~ "I<type> が既知の quota の形式ではない。もしくは、 I<special> デバイスが見"
#~ "付からなかった。"

#~ msgid "Cannot read or write the quota file."
#~ msgstr "quota ファイルへの読み書きが出来ない。"

#~ msgid "B<EMFILE>"
#~ msgstr "B<EMFILE>"

#~ msgid "Too many open files: cannot open quota file."
#~ msgstr "ファイルをオープンしすぎている: quota ファイルをオープン出来ない。"

#~ msgid "I<special> cannot be found in the mount table."
#~ msgstr "I<special> がマウント・テーブル内に見当たらない。"

#~ msgid "B<ENOPKG>"
#~ msgstr "B<ENOPKG>"

#~ msgid "The kernel was compiled without quota support."
#~ msgstr "quota を使用可にしてカーネルをコンパイルしていない。"

#~ msgid ""
#~ "The process was not root (for the file system), and B<Q_GETQUOTA> was "
#~ "asked for another I<id> than that of the process itself, or anything "
#~ "other than B<Q_GETSTATS> or B<Q_SYNC> was asked."
#~ msgstr ""
#~ "プロセスが (そのファイル・システムの) root のものではなく、 かつプロセス自"
#~ "身のものとは異なる I<id> に対して B<Q_GETQUOTA> 要求を行なった。 もしく"
#~ "は、 B<Q_GETSTATS>, B<Q_SYNC> 以外の要求がなされた。"

#~ msgid ""
#~ "B<Q_GETQUOTA> or B<Q_SETQUOTA> or B<Q_SETUSE> or B<Q_SETQLIM> was asked "
#~ "for a file system that didn't have quota enabled."
#~ msgstr ""
#~ "quota が有効になっていないファイル・システムに対して B<Q_GETQUOTA>, "
#~ "B<Q_SETQUOTA>, B<Q_SETUSE>, B<Q_SETQLIM> のいずれかの要求がなされた。"

#~ msgid "BSD."
#~ msgstr "BSD."

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-07-15 16:08+0900\n"
"PO-Revision-Date: 2013-05-06 17:43+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/arch_prctl.2:25
#, no-wrap
msgid "ARCH_PRCTL"
msgstr "ARCH_PRCTL"

#. type: TH
#: build/C/man2/arch_prctl.2:25
#, no-wrap
msgid "2007-12-26"
msgstr "2007-12-26"

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/futex.2:53
#: build/C/man2/get_robust_list.2:29 build/C/man2/getunwind.2:27
#: build/C/man2/kexec_load.2:26 build/C/man2/lookup_dcookie.2:27
#: build/C/man2/modify_ldt.2:24 build/C/man2/nfsservctl.2:8
#: build/C/man2/outb.2:26 build/C/man2/pciconfig_read.2:8
#: build/C/man2/perf_event_open.2:27 build/C/man2/perfmonctl.2:27
#: build/C/man2/personality.2:32 build/C/man2/pivot_root.2:10
#: build/C/man2/process_vm_readv.2:29 build/C/man2/ptrace.2:44
#: build/C/man2/quotactl.2:27 build/C/man2/sendfile.2:19
#: build/C/man2/set_tid_address.2:25 build/C/man2/splice.2:26
#: build/C/man2/tee.2:26 build/C/man2/vm86.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/arch_prctl.2:25 build/C/man2/futex.2:53
#: build/C/man2/getunwind.2:27 build/C/man2/kexec_load.2:26
#: build/C/man2/lookup_dcookie.2:27 build/C/man2/modify_ldt.2:24
#: build/C/man2/nfsservctl.2:8 build/C/man2/outb.2:26
#: build/C/man2/pciconfig_read.2:8 build/C/man2/perf_event_open.2:27
#: build/C/man2/perfmonctl.2:27 build/C/man2/personality.2:32
#: build/C/man2/pivot_root.2:10 build/C/man2/process_vm_readv.2:29
#: build/C/man2/ptrace.2:44 build/C/man2/quotactl.2:27
#: build/C/man2/sendfile.2:19 build/C/man2/set_tid_address.2:25
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vm86.2:26
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/arch_prctl.2:26 build/C/man2/futex.2:54
#: build/C/man2/get_robust_list.2:30 build/C/man2/getunwind.2:28
#: build/C/man2/kexec_load.2:27 build/C/man2/lookup_dcookie.2:28
#: build/C/man2/modify_ldt.2:25 build/C/man2/nfsservctl.2:9
#: build/C/man2/outb.2:27 build/C/man2/pciconfig_read.2:9
#: build/C/man2/perf_event_open.2:28 build/C/man2/perfmonctl.2:28
#: build/C/man2/personality.2:33 build/C/man2/pivot_root.2:11
#: build/C/man2/process_vm_readv.2:30 build/C/man2/ptrace.2:45
#: build/C/man2/quotactl.2:28 build/C/man2/sendfile.2:20
#: build/C/man2/set_tid_address.2:26 build/C/man2/splice.2:27
#: build/C/man2/tee.2:27 build/C/man2/vm86.2:27 build/C/man2/vmsplice.2:27
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/arch_prctl.2:28
msgid "arch_prctl - set architecture-specific thread state"
msgstr "arch_prctl - アーキテクチャ固有のスレッド状態を設定する"

#. type: SH
#: build/C/man2/arch_prctl.2:28 build/C/man2/futex.2:56
#: build/C/man2/get_robust_list.2:32 build/C/man2/getunwind.2:30
#: build/C/man2/kexec_load.2:29 build/C/man2/lookup_dcookie.2:30
#: build/C/man2/modify_ldt.2:27 build/C/man2/nfsservctl.2:11
#: build/C/man2/outb.2:31 build/C/man2/pciconfig_read.2:11
#: build/C/man2/perf_event_open.2:30 build/C/man2/perfmonctl.2:30
#: build/C/man2/personality.2:35 build/C/man2/pivot_root.2:13
#: build/C/man2/process_vm_readv.2:32 build/C/man2/ptrace.2:47
#: build/C/man2/quotactl.2:30 build/C/man2/sendfile.2:22
#: build/C/man2/set_tid_address.2:28 build/C/man2/splice.2:29
#: build/C/man2/tee.2:29 build/C/man2/vm86.2:29 build/C/man2/vmsplice.2:29
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/arch_prctl.2:31
#, no-wrap
msgid "B<#include E<lt>asm/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>asm/prctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/arch_prctl.2:33
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/arch_prctl.2:36
#, no-wrap
msgid ""
"B<int arch_prctl(int >I<code>B<, unsigned long >I<addr>B<);>\n"
"B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"
msgstr "B<int arch_prctl(int >I<code>B<, unsigned long *>I<addr>B<);>\n"

#.  Return type was long before glibc 2.7
#. type: SH
#: build/C/man2/arch_prctl.2:37 build/C/man2/futex.2:68
#: build/C/man2/get_robust_list.2:44 build/C/man2/getunwind.2:40
#: build/C/man2/kexec_load.2:39 build/C/man2/lookup_dcookie.2:32
#: build/C/man2/modify_ldt.2:36 build/C/man2/nfsservctl.2:18
#: build/C/man2/outb.2:62 build/C/man2/pciconfig_read.2:22
#: build/C/man2/perf_event_open.2:42 build/C/man2/perfmonctl.2:39
#: build/C/man2/personality.2:39 build/C/man2/pivot_root.2:18
#: build/C/man2/process_vm_readv.2:50 build/C/man2/ptrace.2:54
#: build/C/man2/quotactl.2:38 build/C/man2/sendfile.2:47
#: build/C/man2/set_tid_address.2:34 build/C/man2/splice.2:39
#: build/C/man2/tee.2:38 build/C/man2/vm86.2:35 build/C/man2/vmsplice.2:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/arch_prctl.2:52
#, fuzzy
#| msgid ""
#| "The B<arch_prctl>()  function sets architecture-specific process or "
#| "thread state.  I<code> selects a subfunction and passes argument I<addr> "
#| "to it; I<addr> is interpreted as either an I<unsigned long> for the \"set"
#| "\" operations, or as an I<unsigned long *>, for the \"get\" operations."
msgid ""
"The B<arch_prctl>()  function sets architecture-specific process or thread "
"state.  I<code> selects a subfunction and passes argument I<addr> to it; "
"I<addr> is interpreted as either an I<unsigned long> for the \"set\" "
"operations, or as an I<unsigned long\\ *>, for the \"get\" operations."
msgstr ""
"B<arch_prctl>()  関数はアーキテクチャ固有のプロセス状態またはスレッド状態を設"
"定する。 I<code> は副機能を選択し、引き数 I<addr> を副機能に渡す。 I<addr> "
"は、\"set\" 操作では I<unsigned long> として、\"get\" 操作では I<unsigned "
"long *> として解釈される。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:54
msgid "Subfunctions for x86-64 are:"
msgstr "x86-64 の副機能は以下の通り:"

#. type: TP
#: build/C/man2/arch_prctl.2:54
#, no-wrap
msgid "B<ARCH_SET_FS>"
msgstr "B<ARCH_SET_FS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:60
msgid "Set the 64-bit base for the I<FS> register to I<addr>."
msgstr "I<FS> レジスタの 64 ビットベースを I<addr> に設定する。"

#. type: TP
#: build/C/man2/arch_prctl.2:60
#, no-wrap
msgid "B<ARCH_GET_FS>"
msgstr "B<ARCH_GET_FS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:68
msgid ""
"Return the 64-bit base value for the I<FS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""
"現在のスレッドの I<FS> レジスタの 64 ビットベース値を、 I<addr> が指す "
"I<unsigned long> の領域に格納する。"

#. type: TP
#: build/C/man2/arch_prctl.2:68
#, no-wrap
msgid "B<ARCH_SET_GS>"
msgstr "B<ARCH_SET_GS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:74
msgid "Set the 64-bit base for the I<GS> register to I<addr>."
msgstr "I<GS> レジスタの 64 ビットベースを I<addr> に設定する。"

#. type: TP
#: build/C/man2/arch_prctl.2:74
#, no-wrap
msgid "B<ARCH_GET_GS>"
msgstr "B<ARCH_GET_GS>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:82
msgid ""
"Return the 64-bit base value for the I<GS> register of the current thread in "
"the I<unsigned long> pointed to by I<addr>."
msgstr ""
"現在のスレッドの I<GS> レジスタの 64 ビットベース値を、 I<addr> が指す "
"I<unsigned long> の領域に格納する。"

#. type: SH
#: build/C/man2/arch_prctl.2:82 build/C/man2/futex.2:209
#: build/C/man2/get_robust_list.2:77 build/C/man2/getunwind.2:81
#: build/C/man2/kexec_load.2:114 build/C/man2/lookup_dcookie.2:43
#: build/C/man2/modify_ldt.2:98 build/C/man2/nfsservctl.2:51
#: build/C/man2/pciconfig_read.2:50 build/C/man2/perf_event_open.2:1964
#: build/C/man2/perfmonctl.2:190 build/C/man2/personality.2:57
#: build/C/man2/pivot_root.2:101 build/C/man2/process_vm_readv.2:209
#: build/C/man2/ptrace.2:1714 build/C/man2/quotactl.2:419
#: build/C/man2/sendfile.2:108 build/C/man2/set_tid_address.2:88
#: build/C/man2/splice.2:127 build/C/man2/tee.2:85 build/C/man2/vm86.2:54
#: build/C/man2/vmsplice.2:113
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/arch_prctl.2:88
msgid ""
"On success, B<arch_prctl>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<arch_prctl>()  は 0 を返す。エラーの場合、-1 を返し、 "
"I<errno> をエラーを示す値に設定する。"

#. type: SH
#: build/C/man2/arch_prctl.2:88 build/C/man2/futex.2:234
#: build/C/man2/get_robust_list.2:84 build/C/man2/getunwind.2:88
#: build/C/man2/kexec_load.2:121 build/C/man2/lookup_dcookie.2:50
#: build/C/man2/modify_ldt.2:108 build/C/man2/pciconfig_read.2:77
#: build/C/man2/perf_event_open.2:1970 build/C/man2/personality.2:64
#: build/C/man2/pivot_root.2:105 build/C/man2/process_vm_readv.2:229
#: build/C/man2/ptrace.2:1728 build/C/man2/quotactl.2:427
#: build/C/man2/sendfile.2:115 build/C/man2/set_tid_address.2:91
#: build/C/man2/splice.2:142 build/C/man2/tee.2:100 build/C/man2/vm86.2:59
#: build/C/man2/vmsplice.2:122
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/arch_prctl.2:89 build/C/man2/futex.2:249
#: build/C/man2/get_robust_list.2:111 build/C/man2/lookup_dcookie.2:51
#: build/C/man2/modify_ldt.2:109 build/C/man2/process_vm_readv.2:251
#: build/C/man2/process_vm_readv.2:256 build/C/man2/ptrace.2:1732
#: build/C/man2/quotactl.2:428 build/C/man2/sendfile.2:125
#: build/C/man2/vm86.2:60
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:93
msgid ""
"I<addr> points to an unmapped address or is outside the process address "
"space."
msgstr ""
"I<addr> がアンマップされたアドレスを指しているか、プロセスのアドレス空間の外"
"にある。"

#. type: TP
#: build/C/man2/arch_prctl.2:93 build/C/man2/futex.2:261
#: build/C/man2/get_robust_list.2:88 build/C/man2/kexec_load.2:126
#: build/C/man2/lookup_dcookie.2:54 build/C/man2/modify_ldt.2:113
#: build/C/man2/pciconfig_read.2:78 build/C/man2/perf_event_open.2:1971
#: build/C/man2/personality.2:65 build/C/man2/pivot_root.2:114
#: build/C/man2/process_vm_readv.2:230 build/C/man2/process_vm_readv.2:241
#: build/C/man2/process_vm_readv.2:245 build/C/man2/ptrace.2:1743
#: build/C/man2/quotactl.2:434 build/C/man2/quotactl.2:501
#: build/C/man2/sendfile.2:128 build/C/man2/splice.2:147
#: build/C/man2/tee.2:101 build/C/man2/vmsplice.2:127
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/arch_prctl.2:97
msgid "I<code> is not a valid subcommand."
msgstr "I<code> が有効なサブコマンドでない。"

#. type: TP
#: build/C/man2/arch_prctl.2:97 build/C/man2/get_robust_list.2:98
#: build/C/man2/kexec_load.2:133 build/C/man2/lookup_dcookie.2:65
#: build/C/man2/pciconfig_read.2:105 build/C/man2/pivot_root.2:120
#: build/C/man2/process_vm_readv.2:267 build/C/man2/ptrace.2:1753
#: build/C/man2/quotactl.2:456 build/C/man2/vm86.2:68
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#.  .SH AUTHOR
#.  Man page written by Andi Kleen.
#. type: Plain text
#: build/C/man2/arch_prctl.2:103
msgid "I<addr> is outside the process address space."
msgstr "I<addr> がプロセスのアドレス空間の外にある。"

#. type: SH
#: build/C/man2/arch_prctl.2:103 build/C/man2/futex.2:296
#: build/C/man2/getunwind.2:96 build/C/man2/kexec_load.2:142
#: build/C/man2/lookup_dcookie.2:78 build/C/man2/modify_ldt.2:130
#: build/C/man2/nfsservctl.2:56 build/C/man2/outb.2:87
#: build/C/man2/pciconfig_read.2:112 build/C/man2/perf_event_open.2:1989
#: build/C/man2/perfmonctl.2:199 build/C/man2/personality.2:68
#: build/C/man2/pivot_root.2:128 build/C/man2/process_vm_readv.2:279
#: build/C/man2/ptrace.2:1771 build/C/man2/sendfile.2:148
#: build/C/man2/set_tid_address.2:97 build/C/man2/splice.2:170
#: build/C/man2/tee.2:119 build/C/man2/vm86.2:73 build/C/man2/vmsplice.2:143
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/arch_prctl.2:107
msgid ""
"B<arch_prctl>()  is a Linux/x86-64 extension and should not be used in "
"programs intended to be portable."
msgstr ""
"B<arch_prctl>()  は Linux/x86-64 拡張であり、移植性を意図したプログラムでは使"
"うべきでない。"

#. type: SH
#: build/C/man2/arch_prctl.2:107 build/C/man2/futex.2:298
#: build/C/man2/get_robust_list.2:119 build/C/man2/getunwind.2:99
#: build/C/man2/kexec_load.2:144 build/C/man2/lookup_dcookie.2:81
#: build/C/man2/modify_ldt.2:133 build/C/man2/perf_event_open.2:1994
#: build/C/man2/perfmonctl.2:202 build/C/man2/pivot_root.2:131
#: build/C/man2/process_vm_readv.2:281 build/C/man2/ptrace.2:1773
#: build/C/man2/sendfile.2:155 build/C/man2/splice.2:172
#: build/C/man2/tee.2:121 build/C/man2/vmsplice.2:145
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/arch_prctl.2:110
msgid ""
"B<arch_prctl>()  is supported only on Linux/x86-64 for 64-bit programs "
"currently."
msgstr ""
"B<arch_prctl>()  は現在のところ Linux/x86-64 上の 64 ビットプログラムでのみサ"
"ポートされている。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:112
msgid "The 64-bit base changes when a new 32-bit segment selector is loaded."
msgstr ""
"新しい 32 ビットセグメントセレクタがロードされた場合、 64 ビットベースは変更"
"される。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:115
msgid "B<ARCH_SET_GS> is disabled in some kernels."
msgstr "B<ARCH_SET_GS> が無効にされているカーネルもある。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:130
msgid ""
"Context switches for 64-bit segment bases are rather expensive.  It may be a "
"faster alternative to set a 32-bit base using a segment selector by setting "
"up an LDT with B<modify_ldt>(2)  or using the B<set_thread_area>(2)  system "
"call in kernel 2.5 or later.  B<arch_prctl>()  is needed only when you want "
"to set bases that are larger than 4GB.  Memory in the first 2GB of address "
"space can be allocated by using B<mmap>(2)  with the B<MAP_32BIT> flag."
msgstr ""
"64 ビットセグメントベースのコンテキストスイッチは、やや高価である。 LDT を "
"B<modify_ldt>(2)  で設定してセグメントセレクタを使うか、 (カーネル 2.5 以降"
"の)  B<set_thread_area>(2)  システムコールを使うことにより、 32 ビットベース"
"を設定するという高速な代替手段もある。 4GB より大きなベースを設定したい場合に"
"のみ、 B<arch_prctl>()  が必要である。 アドレス空間の最初の 2GB にあるメモリ"
"は、 B<mmap>(2)  に B<MAP_32BIT> フラグを指定して割り当てることができる。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:135
msgid ""
"As of version 2.7, glibc provides no prototype for B<arch_prctl>().  You "
"have to declare it yourself for now.  This may be fixed in future glibc "
"versions."
msgstr ""
"バージョン 2.7 時点では、glibc には B<arch_prctl>()  のプロトタイプがない。 "
"今のところユーザは自分自身で宣言する必要がある。 これは将来の glibc のバー"
"ジョンで修正されるかもしれない。"

#. type: Plain text
#: build/C/man2/arch_prctl.2:138
msgid "I<FS> may be already used by the threading library."
msgstr "I<FS> はスレッドライブラリで既に使われているかもしれない。"

#. type: SH
#: build/C/man2/arch_prctl.2:138 build/C/man2/futex.2:312
#: build/C/man2/get_robust_list.2:128 build/C/man2/getunwind.2:111
#: build/C/man2/kexec_load.2:159 build/C/man2/modify_ldt.2:136
#: build/C/man2/outb.2:96 build/C/man2/pciconfig_read.2:114
#: build/C/man2/perf_event_open.2:2108 build/C/man2/perfmonctl.2:205
#: build/C/man2/pivot_root.2:143 build/C/man2/process_vm_readv.2:331
#: build/C/man2/ptrace.2:1927 build/C/man2/quotactl.2:507
#: build/C/man2/sendfile.2:197 build/C/man2/set_tid_address.2:99
#: build/C/man2/splice.2:226 build/C/man2/tee.2:197
#: build/C/man2/vmsplice.2:154
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/arch_prctl.2:143
msgid "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"
msgstr "B<mmap>(2), B<modify_ldt>(2), B<prctl>(2), B<set_thread_area>(2)"

#. type: Plain text
#: build/C/man2/arch_prctl.2:145
msgid "AMD X86-64 Programmer's manual"
msgstr "AMD X86-64 Programmer's manual"

#. type: SH
#: build/C/man2/arch_prctl.2:145 build/C/man2/futex.2:325
#: build/C/man2/get_robust_list.2:137 build/C/man2/getunwind.2:113
#: build/C/man2/kexec_load.2:162 build/C/man2/lookup_dcookie.2:88
#: build/C/man2/modify_ldt.2:138 build/C/man2/nfsservctl.2:58
#: build/C/man2/outb.2:99 build/C/man2/pciconfig_read.2:116
#: build/C/man2/perf_event_open.2:2114 build/C/man2/perfmonctl.2:209
#: build/C/man2/personality.2:72 build/C/man2/pivot_root.2:149
#: build/C/man2/process_vm_readv.2:334 build/C/man2/ptrace.2:1941
#: build/C/man2/quotactl.2:512 build/C/man2/sendfile.2:203
#: build/C/man2/set_tid_address.2:102 build/C/man2/splice.2:230
#: build/C/man2/tee.2:200 build/C/man2/vm86.2:76 build/C/man2/vmsplice.2:157
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/arch_prctl.2:152 build/C/man2/futex.2:332
#: build/C/man2/get_robust_list.2:144 build/C/man2/getunwind.2:120
#: build/C/man2/kexec_load.2:169 build/C/man2/lookup_dcookie.2:95
#: build/C/man2/modify_ldt.2:145 build/C/man2/nfsservctl.2:65
#: build/C/man2/outb.2:106 build/C/man2/pciconfig_read.2:123
#: build/C/man2/perf_event_open.2:2121 build/C/man2/perfmonctl.2:216
#: build/C/man2/personality.2:79 build/C/man2/pivot_root.2:156
#: build/C/man2/process_vm_readv.2:341 build/C/man2/ptrace.2:1948
#: build/C/man2/quotactl.2:519 build/C/man2/sendfile.2:210
#: build/C/man2/set_tid_address.2:109 build/C/man2/splice.2:237
#: build/C/man2/tee.2:207 build/C/man2/vm86.2:83 build/C/man2/vmsplice.2:164
#, fuzzy
#| msgid ""
#| "This page is part of release 3.51 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.52 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.51 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/futex.2:53
#, no-wrap
msgid "FUTEX"
msgstr "FUTEX"

#. type: TH
#: build/C/man2/futex.2:53
#, no-wrap
msgid "2013-03-15"
msgstr "2013-03-15"

#. type: Plain text
#: build/C/man2/futex.2:56
msgid "futex - fast user-space locking"
msgstr "futex - 高速ユーザ空間ロック"

#. type: Plain text
#: build/C/man2/futex.2:61
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/futex.2:64
#, no-wrap
msgid "B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct timespec *>I<timeout>B<,>\n"
msgstr "B<int futex(int *>I<uaddr>B<, int >I<op>B<, int >I<val>B<, const struct timespec *>I<timeout>B<,>\n"

#.  int *? void *? u32 *?
#. type: Plain text
#: build/C/man2/futex.2:67
#, no-wrap
msgid "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"
msgstr "B<          int *>I<uaddr2>B<, int >I<val3>B<);>\n"

#. type: Plain text
#: build/C/man2/futex.2:84
msgid ""
"The B<futex>()  system call provides a method for a program to wait for a "
"value at a given address to change, and a method to wake up anyone waiting "
"on a particular address (while the addresses for the same memory in separate "
"processes may not be equal, the kernel maps them internally so the same "
"memory mapped in different locations will correspond for B<futex>()  "
"calls).  This system call is typically used to implement the contended case "
"of a lock in shared memory, as described in B<futex>(7)."
msgstr ""
"B<futex>()  システムコールは、 指定したアドレスの値が変更されるのをプログラム"
"が待つ手段や 特定のアドレスに対して待機中のプロセスを wake (起床) させる手段"
"を提供する (プロセスが異なれば同じメモリに対するアドレスも同じではないかもし"
"れないが、 カーネルは異なる位置にマップされた同じメモリを B<futex>()  で使え"
"るよう内部でマップする)。 通常は、このシステムコールは B<futex>(7)  に書かれ"
"ているように、 共有メモリ中のロックが競合する場合の処理を実装するのに用いられ"
"る。"

#. type: Plain text
#: build/C/man2/futex.2:91
msgid ""
"When a B<futex>(7)  operation did not finish uncontended in user space, a "
"call needs to be made to the kernel to arbitrate.  Arbitration can either "
"mean putting the calling process to sleep or, conversely, waking a waiting "
"process."
msgstr ""
"B<futex>(7)  の操作がユーザ空間で競合なく完了しなかった場合、 カーネルに仲裁"
"させるためにシステムコールを呼ぶ必要がある。 仲裁というのは、呼び出しプロセス"
"を sleep (起床待ち) させたり、反対に 待ちプロセスを wake させたりすることを意"
"味する。"

#. type: Plain text
#: build/C/man2/futex.2:98
msgid ""
"Callers of this function are expected to adhere to the semantics as set out "
"in B<futex>(7).  As these semantics involve writing nonportable assembly "
"instructions, this in turn probably means that most users will in fact be "
"library authors and not general application developers."
msgstr ""
"この関数を呼び出すプロセスは B<futex>(7)  に記述されているセマンティクスに忠"
"実であることが要求される。 このセマンティクスには移植不可能なアセンブリ命令を"
"書くことが含まれる。 このことは言い換えると futex のユーザのほとんどは実際は"
"ライブラリの作者であり、 一般アプリケーションの開発者ではないということであ"
"る。"

#. type: Plain text
#: build/C/man2/futex.2:106
msgid ""
"The I<uaddr> argument needs to point to an aligned integer which stores the "
"counter.  The operation to execute is passed via the I<op> argument, along "
"with a value I<val>."
msgstr ""
"I<uaddr> 引き数は、カウンタを格納する、 アラインメントの揃った int 型変数を指"
"している必要がある。 実行する操作は I<op> 引き数を介して、値 I<val> とともに"
"渡される。"

#. type: Plain text
#: build/C/man2/futex.2:108
msgid "Five operations are currently defined:"
msgstr "現在のところ 5 つの操作が定義されている:"

#. type: TP
#: build/C/man2/futex.2:108 build/C/man2/futex.2:216
#, no-wrap
msgid "B<FUTEX_WAIT>"
msgstr "B<FUTEX_WAIT>"

#. type: Plain text
#: build/C/man2/futex.2:126
msgid ""
"This operation atomically verifies that the futex address I<uaddr> still "
"contains the value I<val>, and sleeps awaiting B<FUTEX_WAKE> on this futex "
"address.  If the I<timeout> argument is non-NULL, its contents describe the "
"minimum duration of the wait, which is infinite otherwise.  The arguments "
"I<uaddr2> and I<val3> are ignored."
msgstr ""
"この操作は futex アドレス I<uaddr> に指定された値 I<val> がまだ格納されている"
"かどうかを不可分操作で検証し、 sleep 状態で この futex アドレスに対して "
"B<FUTEX_WAKE> が実行されるのを待つ。 I<timeout> 引き数が NULL でない場合、そ"
"の内容は 待ち時間の最大値を表す。NULL の場合は無限大を表す。 引き数 "
"I<uaddr2> と I<val3> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:134
msgid ""
"For B<futex>(7), this call is executed if decrementing the count gave a "
"negative value (indicating contention), and will sleep until another process "
"releases the futex and executes the B<FUTEX_WAKE> operation."
msgstr ""
"B<futex>(7)  に照らし合わせると、この呼び出しは カウントのデクリメントで負の"
"値 (競合を表す) になった場合に実行され、 別のプロセスがその futex を解放し "
"B<FUTEX_WAKE> の操作を実行するまで sleep する。"

#. type: TP
#: build/C/man2/futex.2:134 build/C/man2/futex.2:222
#, no-wrap
msgid "B<FUTEX_WAKE>"
msgstr "B<FUTEX_WAKE>"

#. type: Plain text
#: build/C/man2/futex.2:145
msgid ""
"This operation wakes at most I<val> processes waiting on this futex address "
"(i.e., inside B<FUTEX_WAIT>).  The arguments I<timeout>, I<uaddr2> and "
"I<val3> are ignored."
msgstr ""
"この操作では指定した futex アドレスに対して待ち状態の (すなわち "
"B<FUTEX_WAIT> 中の) 最大 I<val> 個のプロセスを wake させる。 引き数 "
"I<timeout>, I<uaddr2>, I<val3> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:151
msgid ""
"For B<futex>(7), this is executed if incrementing the count showed that "
"there were waiters, once the futex value has been set to 1 (indicating that "
"it is available)."
msgstr ""
"B<futex>(4) に照らし合わせると、 この操作は カウントのインクリメントで待ちプ"
"ロセスがあると判明し、 futex 値が 1 に設定された (利用可能であることを表す) "
"場合に実行される。"

#. type: TP
#: build/C/man2/futex.2:151
#, no-wrap
msgid "B<FUTEX_FD> (present up to and including Linux 2.6.25)"
msgstr "B<FUTEX_FD> (Linux 2.6.25 以前)"

#.  , suitable for .BR poll (2).
#. type: Plain text
#: build/C/man2/futex.2:167
msgid ""
"To support asynchronous wakeups, this operation associates a file descriptor "
"with a futex.  If another process executes a B<FUTEX_WAKE>, the process will "
"receive the signal number that was passed in I<val>.  The calling process "
"must close the returned file descriptor after use.  The arguments "
"I<timeout>, I<uaddr2> and I<val3> are ignored."
msgstr ""
"非同期の wake に対応するため、この操作はファイルディスクリプタを futex に 関"
"連づける。 別のプロセスが B<FUTEX_WAKE> を実行すると、プロセスは I<val> で渡"
"されたシグナル番号のシグナルを受信する。 呼び出しプロセスは使用後、返された"
"ファイルディスクリプタを クローズしなければならない。 引き数 I<timeout>, "
"I<uaddr2>, I<val3> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:172
msgid ""
"To prevent race conditions, the caller should test if the futex has been "
"upped after B<FUTEX_FD> returns."
msgstr ""
"競合状態を防止するため、呼び出しプロセスは B<FUTEX_FD> が返ったあと futex が "
"up されたかどうかを確認しなければならない。"

#. type: Plain text
#: build/C/man2/futex.2:176
msgid ""
"Because it was inherently racy, B<FUTEX_FD> has been removed from Linux "
"2.6.26 onward."
msgstr ""
"B<FUTEX_FD> はもともと競合が起きやすかったため、 Linux 2.6.26 以降で削除され"
"ている。"

#. type: TP
#: build/C/man2/futex.2:176
#, no-wrap
msgid "B<FUTEX_REQUEUE> (since Linux 2.5.70)"
msgstr "B<FUTEX_REQUEUE> (Linux 2.5.70 以降)"

#. type: Plain text
#: build/C/man2/futex.2:191
msgid ""
"This operation was introduced in order to avoid a \"thundering herd\" effect "
"when B<FUTEX_WAKE> is used and all processes woken up need to acquire "
"another futex.  This call wakes up I<val> processes, and requeues all other "
"waiters on the futex at address I<uaddr2>.  The arguments I<timeout> and "
"I<val3> are ignored."
msgstr ""
"この操作は、 B<FUTEX_WAKE> が使われていて、かつ wake されている全てのプロセス"
"が 他の futex を取得する必要がある場合に、 「獣の群れの暴走 (thundering "
"herd)」効果を避けるために導入された。 この呼び出しは I<val> 個のプロセスを "
"wake し、アドレス I<uaddr2> で futex を待っている他の全てのプロセスを再度"
"キューにいれる。 引き数 I<timeout> と I<val3> は無視される。"

#. type: TP
#: build/C/man2/futex.2:191
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgstr "B<FUTEX_CMP_REQUEUE> (Linux 2.6.7 以降)"

#. type: Plain text
#: build/C/man2/futex.2:209
msgid ""
"There was a race in the intended use of B<FUTEX_REQUEUE>, so "
"B<FUTEX_CMP_REQUEUE> was introduced.  This is similar to B<FUTEX_REQUEUE>, "
"but first checks whether the location I<uaddr> still contains the value "
"I<val3>.  If not, the operation fails with the error B<EAGAIN>.  The "
"argument I<timeout> is ignored."
msgstr ""
"故意に B<FUTEX_REQUEUE> を使う場合に競合が起こるため、 B<FUTEX_CMP_REQUEUE> "
"が導入された。これは B<FUTEX_REQUEUE> と似ているが、場所 I<uaddr> に値 "
"I<val3> がまだ保持されているかを最初にチェックする。 保持されていない場合、操"
"作はエラー B<EAGAIN> で失敗する。引き数 I<timeout> は無視される。"

#. type: Plain text
#: build/C/man2/futex.2:216
msgid ""
"In the event of an error, all operations return -1, and set I<errno> to "
"indicate the error.  The return value on success depends on the operation, "
"as described in the following list:"
msgstr ""
"エラーの場合、全ての操作で -1 が返り、 I<errno> がエラーの内容を示す値に設定"
"される。成功時の返り値は操作によって異なり、以下のリストに書かれている通りで"
"ある。"

#. type: Plain text
#: build/C/man2/futex.2:222
msgid ""
"Returns 0 if the process was woken by a B<FUTEX_WAKE> call.  See ERRORS for "
"the various possible error returns."
msgstr ""
"そのプロセスが B<FUTEX_WAKE> により wake された場合 0 を返す。発生する可能性"
"があるエラーについては「エラー」の節を参照。"

#. type: Plain text
#: build/C/man2/futex.2:225 build/C/man2/futex.2:231 build/C/man2/futex.2:234
msgid "Returns the number of processes woken up."
msgstr "wake したプロセスの数を返す。"

#. type: TP
#: build/C/man2/futex.2:225
#, no-wrap
msgid "B<FUTEX_FD>"
msgstr "B<FUTEX_FD>"

#. type: Plain text
#: build/C/man2/futex.2:228
msgid "Returns the new file descriptor associated with the futex."
msgstr "futex に関連づけられた新たなファイルディスクリプタを返す。"

#. type: TP
#: build/C/man2/futex.2:228
#, no-wrap
msgid "B<FUTEX_REQUEUE>"
msgstr "B<FUTEX_REQUEUE>"

#. type: TP
#: build/C/man2/futex.2:231
#, no-wrap
msgid "B<FUTEX_CMP_REQUEUE>"
msgstr "B<FUTEX_CMP_REQUEUE>"

#. type: TP
#: build/C/man2/futex.2:235 build/C/man2/quotactl.2:486
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/futex.2:238
msgid "No read access to futex memory."
msgstr "futex メモリに読み込みアクセス権がなかった。"

#. type: TP
#: build/C/man2/futex.2:238 build/C/man2/sendfile.2:116
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/futex.2:249
msgid ""
"B<FUTEX_CMP_REQUEUE> detected that the value pointed to by I<uaddr> is not "
"equal to the expected value I<val3>.  (This probably indicates a race; use "
"the safe B<FUTEX_WAKE> now.)"
msgstr ""
"B<FUTEX_CMP_REQUEUE> で、I<uaddr> が指す値が期待値 I<val3> と異なる状況が検出"
"された。 (これは競合を示しているかもしれない。この場合は安全な B<FUTEX_WAKE> "
"を使うこと。)"

#. type: Plain text
#: build/C/man2/futex.2:254
msgid "Error retrieving I<timeout> information from user space."
msgstr "ユーザ空間から I<timeout> の情報を取得する際にエラーが発生した。"

#. type: TP
#: build/C/man2/futex.2:254
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/futex.2:261
msgid ""
"A B<FUTEX_WAIT> operation was interrupted by a signal (see B<signal>(7))  or "
"a spurious wakeup."
msgstr ""
"B<FUTEX_WAIT> 操作がシグナル (B<signal>(7) 参照) もしくは偽の wakeup により中"
"断された。"

#. type: Plain text
#: build/C/man2/futex.2:264
msgid "Invalid argument."
msgstr "無効な引き数。"

#. type: TP
#: build/C/man2/futex.2:264
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/futex.2:267
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされているファイルの総数がシステムの制限に達した。"

#. type: TP
#: build/C/man2/futex.2:267 build/C/man2/modify_ldt.2:126
#: build/C/man2/pciconfig_read.2:93 build/C/man2/quotactl.2:447
#: build/C/man2/vm86.2:64
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/futex.2:271
msgid "Invalid operation specified in I<op>."
msgstr "I<op> に無効な操作が指定された。"

#. type: TP
#: build/C/man2/futex.2:271
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man2/futex.2:276
msgid "Timeout during the B<FUTEX_WAIT> operation."
msgstr "B<FUTEX_WAIT> 操作でタイムアウトが発生した。"

#. type: TP
#: build/C/man2/futex.2:276
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: build/C/man2/futex.2:286
msgid ""
"I<op> was B<FUTEX_WAIT> and the value pointed to by I<uaddr> was not equal "
"to the expected value I<val> at the time of the call."
msgstr ""
"I<op> が B<FUTEX_WAIT> で、その呼び出しにおいて I<uaddr> が指す値が期待値 "
"I<val> と異なっていた。"

#. type: SH
#: build/C/man2/futex.2:286 build/C/man2/get_robust_list.2:115
#: build/C/man2/getunwind.2:94 build/C/man2/kexec_load.2:138
#: build/C/man2/lookup_dcookie.2:73 build/C/man2/perfmonctl.2:196
#: build/C/man2/pivot_root.2:125 build/C/man2/process_vm_readv.2:276
#: build/C/man2/sendfile.2:142 build/C/man2/set_tid_address.2:94
#: build/C/man2/splice.2:165 build/C/man2/tee.2:114
#: build/C/man2/vmsplice.2:138
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/futex.2:296
msgid ""
"Initial futex support was merged in Linux 2.5.7 but with different semantics "
"from what was described above.  A 4-argument system call with the semantics "
"described in this page was introduced in Linux 2.5.40.  In Linux 2.5.70 one "
"argument was added.  In Linux 2.6.7 a sixth argument was added\\(emmessy, "
"especially on the s390 architecture."
msgstr ""
"最初の futex 対応は Linux 2.5.7 で組み込まれたが、 上記のセマンティクスとは異"
"なる。 4 つの引き数のここに書かれているセマンティクスを持つ システムコール"
"は、Linux 2.5.40 で導入された。 Linux 2.5.70 では 1 つの引き数が追加された。 "
"Linux 2.6.7 では 6 番目の引き数が追加された。 これは汚く、s390 アーキテクチャ"
"上の特別のものである。"

#. type: Plain text
#: build/C/man2/futex.2:298 build/C/man2/kexec_load.2:144
#: build/C/man2/set_tid_address.2:99 build/C/man2/splice.2:172
#: build/C/man2/tee.2:121 build/C/man2/vmsplice.2:145
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 固有である。"

#.  .SH "AUTHORS"
#.  .PP
#.  Futexes were designed and worked on by
#.  Hubertus Franke (IBM Thomas J. Watson Research Center),
#.  Matthew Kirkwood, Ingo Molnar (Red Hat)
#.  and Rusty Russell (IBM Linux Technology Center).
#.  This page written by bert hubert.
#. type: Plain text
#: build/C/man2/futex.2:312
msgid ""
"To reiterate, bare futexes are not intended as an easy-to-use abstraction "
"for end-users.  (There is no wrapper function for this system call in "
"glibc.)  Implementors are expected to be assembly literate and to have read "
"the sources of the futex user-space library referenced below."
msgstr ""
"繰り返すが、裸の futex はエンドユーザが容易に使うことのできる概念として 意図"
"されたものではない (glibc にはこのシステムコールに対するラッパー関数はな"
"い)。 実装者は、アセンブリ言語に慣れており、以下に挙げる futex ユーザ空間ライ"
"ブラリの ソースを読み終えていることが要求される。"

#. type: Plain text
#: build/C/man2/futex.2:314
msgid "B<futex>(7)"
msgstr "B<futex>(7)"

#. type: Plain text
#: build/C/man2/futex.2:317
msgid ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"
msgstr ""
"I<Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux> (proceedings "
"of the Ottawa Linux Symposium 2002), online at"

#. type: Plain text
#: build/C/man2/futex.2:320
msgid ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"
msgstr ""
"E<.UR http://kernel.org\\:/doc\\:/ols\\:/2002\\:/ols2002-pages-479-495.pdf> "
"E<.UE>"

#. type: Plain text
#: build/C/man2/futex.2:322
msgid "Futex example library, futex-*.tar.bz2 at"
msgstr "futex の使用例ライブラリ, futex-*.tar.bz2"

#. type: Plain text
#: build/C/man2/futex.2:325
msgid ""
"E<.UR ftp://ftp.nl.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE>"
msgstr ""
"E<.UR ftp://ftp.nl.kernel.org\\:/pub\\:/linux\\:/kernel\\:/people\\:/rusty/> "
"E<.UE>"

#. type: TH
#: build/C/man2/get_robust_list.2:29
#, no-wrap
msgid "GET_ROBUST_LIST"
msgstr "GET_ROBUST_LIST"

#. type: TH
#: build/C/man2/get_robust_list.2:29 build/C/man2/kexec_load.2:26
#: build/C/man2/modify_ldt.2:24 build/C/man2/pivot_root.2:10
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: TH
#: build/C/man2/get_robust_list.2:29
#, no-wrap
msgid "Linux System Calls"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:32
msgid "get_robust_list, set_robust_list - get/set list of robust futexes"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:36
#, no-wrap
msgid ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/futex.hE<gt>>\n"
"B<#include E<lt>syscall.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/get_robust_list.2:40
#, no-wrap
msgid ""
"B<long get_robust_list(int >I<pid>B<, struct robust_list_head **>I<head_ptr>B<,>\n"
"B<\t\t\t  size_t *>I<len_ptr>B<);>\n"
"B<long set_robust_list(struct robust_list_head *>I<head>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:44
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<注意>: これらのシステムコールには glibc ラッパー関数は存在しない。 「注意」"
"の節を参照。"

#. type: Plain text
#: build/C/man2/get_robust_list.2:49
msgid ""
"The robust futex implementation needs to maintain per-thread lists of robust "
"futexes which are unlocked when the thread exits.  These lists are managed "
"in user space; the kernel is notified about only the location of the head of "
"the list."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:65
msgid ""
"The B<get_robust_list>()  system call returns the head of the robust futex "
"list of the thread whose thread ID is specified in I<pid>.  If I<pid> is 0, "
"the head of the list for the calling thread is returned.  The list head is "
"stored in the location pointed to by I<head_ptr>.  The size of the object "
"pointed to by I<**head_ptr> is stored in I<len_ptr>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:77
msgid ""
"The B<set_robust_list>()  system call requests the kernel to record the head "
"of the list of robust futexes owned by the calling thread.  The I<head> "
"argument is the list head to record.  The I<len> argument should be I<sizeof"
"(*head)>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:84
msgid ""
"The B<set_robust_list>()  and B<get_robust_list>()  system calls return zero "
"when the operation is successful, an error code otherwise."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:88
msgid ""
"The B<set_robust_list>()  system call can fail with the following error:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:94
msgid ""
"I<len> does not match the size of structure B<struct robust_list_head> "
"expected by kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:98
msgid ""
"The B<get_robust_list>()  system call can fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:106
msgid ""
"The calling process does not have permission to see the robust futex list of "
"the thread with the thread ID I<pid>, and does not have the "
"B<CAP_SYS_PTRACE> capability."
msgstr ""

#. type: TP
#: build/C/man2/get_robust_list.2:106 build/C/man2/process_vm_readv.2:271
#: build/C/man2/ptrace.2:1766 build/C/man2/quotactl.2:461
#: build/C/man2/quotactl.2:504
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/get_robust_list.2:111
msgid "No thread with the thread ID I<pid> could be found."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:115
msgid ""
"The head of the robust futex list can't be stored at the location I<head>."
msgstr ""

#. type: Plain text
#: build/C/man2/get_robust_list.2:119
msgid ""
"These system calls were added in Linux 2.6.17.  No library support is "
"provided; use B<syscall>(2)."
msgstr ""
"これらのシステムコールは Linux 2.6.17 で追加された。ライブラリによる\n"
"サポートは提供されていない。 B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/get_robust_list.2:124
msgid ""
"These system calls are not needed by normal applications.  No support for "
"them is provided in glibc.  In the unlikely event that you want to call them "
"directly, use B<syscall>(2)."
msgstr ""
"通常のアプリケーションでは、これらのシステムコールは必要ではない。 glibc によ"
"るサポートは提供されていない。おそらくないと思うが、このシステムコールを直接"
"呼び出したい場合は B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/get_robust_list.2:128
msgid ""
"A thread can have only one robust futex list; therefore applications that "
"wish to use this functionality should use the robust mutexes provided by "
"glibc."
msgstr ""

#.  .BR pthread_mutexattr_setrobust_np (3)
#. type: Plain text
#: build/C/man2/get_robust_list.2:131
msgid "B<futex>(2)"
msgstr "B<futex>(2)"

#.  http://lwn.net/Articles/172149/
#. type: Plain text
#: build/C/man2/get_robust_list.2:137
msgid ""
"I<Documentation/robust-futexes.txt> and I<Documentation/robust-futex-ABI."
"txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/getunwind.2:27
#, no-wrap
msgid "GETUNWIND"
msgstr ""

#. type: TH
#: build/C/man2/getunwind.2:27 build/C/man2/perfmonctl.2:27
#, no-wrap
msgid "2013-02-13"
msgstr "2013-02-13"

#. type: Plain text
#: build/C/man2/getunwind.2:30
msgid "getunwind - copy the unwind data to caller's buffer"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"
msgstr ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>linux/unwind.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getunwind.2:36
#, no-wrap
msgid "B<long getunwind(void >I<*buf>B<, size_t >I<buf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:40 build/C/man2/kexec_load.2:39
#: build/C/man2/modify_ldt.2:36 build/C/man2/perf_event_open.2:42
#: build/C/man2/perfmonctl.2:39 build/C/man2/pivot_root.2:18
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/getunwind.2:42
msgid "I<Note: this function is obsolete.>"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:52
msgid ""
"The IA-64-specific B<getunwind>()  system call copies the kernel's call "
"frame unwind data into the buffer pointed to by I<buf> and returns the size "
"of the unwind data; this data describes the gate page (kernel code that is "
"mapped into user space)."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:64
msgid ""
"The size of the buffer I<buf> is specified in I<buf_size>.  The data is "
"copied only if I<buf_size> is greater than or equal to the size of the "
"unwind data and I<buf> is not NULL; otherwise, no data is copied, and the "
"call succeeds, returning the size that would be needed to store the unwind "
"data."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:68
msgid ""
"The first part of the unwind data contains an unwind table.  The rest "
"contains the associated unwind information, in no particular order.  The "
"unwind table contains entries of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:73
#, no-wrap
msgid ""
"\tu64 start;      (64-bit address of start of function)\n"
"\tu64 end;        (64-bit address of end of function)\n"
"\tu64 info;       (BUF-relative offset to unwind info)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:81
msgid ""
"An entry whose I<start> value is zero indicates the end of the table.  For "
"more information about the format, see the I<IA-64 Software Conventions and "
"Runtime Architecture> manual."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:88
#, fuzzy
#| msgid ""
#| "On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
#| "I<errno> is set to indicate the error."
msgid ""
"On success, B<getunwind>()  returns the size of unwind table.  On error, -1 "
"is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<kexec_load> は 0 を返す。\n"
"エラーの場合、 -1 が返り、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/getunwind.2:94
msgid ""
"B<getunwind>()  fails with the error B<EFAULT> if the unwind info can't be "
"stored in the space specified by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:96
#, fuzzy
#| msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgid "This system call is available since Linux 2.4."
msgstr ""
"これらの呼び出しは Linux 特有のものであり、 Linux 2.0.26/2.1.11 から使用可能"
"である。"

#. type: Plain text
#: build/C/man2/getunwind.2:99
msgid ""
"This system call is Linux specific, and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:107
msgid ""
"This system call has been deprecated.  The modern way to obtain the kernel's "
"unwind data is via the gate DSO.  The address of the ELF header for this DSO "
"is passed to user level via B<AT_SYSINFO_EHDR> (see B<getauxval>(3))."
msgstr ""

#. type: Plain text
#: build/C/man2/getunwind.2:111
msgid ""
"Glibc does not provide a wrapper for this system call; in the unlikely event "
"that you want to call it, use B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。おそらくない"
"と思うが、このシステムコールを呼び出したい場合は B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/getunwind.2:113
msgid "B<getauxval>(3)"
msgstr "B<getauxval>(3)"

#. type: TH
#: build/C/man2/kexec_load.2:26
#, no-wrap
msgid "KEXEC_LOAD"
msgstr "KEXEC_LOAD"

#. type: Plain text
#: build/C/man2/kexec_load.2:29
msgid "kexec_load - load a new kernel for later execution"
msgstr "kexec_load - 新しいカーネルを後で実行するためにロードする"

#. type: Plain text
#: build/C/man2/kexec_load.2:31
msgid "B<#include E<lt>linux/kexec.hE<gt>>"
msgstr "B<#include E<lt>linux/kexec.hE<gt>>"

#. type: Plain text
#: build/C/man2/kexec_load.2:33
msgid ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long >I<nr_segments>B<,"
">"
msgstr ""
"B<long kexec_load(unsigned long >I<entry>B<, unsigned long >I<nr_segments>B<,"
">"

#. type: Plain text
#: build/C/man2/kexec_load.2:36
msgid "B< struct kexec_segment *>I<segments>B<, unsigned long >I<flags>B<);>"
msgstr "B< struct kexec_segment *>I<segments>B<, unsigned long >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/kexec_load.2:44
msgid ""
"The B<kexec_load>()  system call loads a new kernel that can be executed "
"later by B<reboot>(2)."
msgstr ""
"B<kexec_load>() システムコールは、新しいカーネルをロードし、\n"
"その後の B<reboot>(2) で実行できるようにする。"

#. type: Plain text
#: build/C/man2/kexec_load.2:50
msgid ""
"The I<flags> argument is a mask whose high-order bits control the operation "
"of the call.  The following values can be specified in I<flags>:"
msgstr ""
"I<flags> 引き数はマスクビットで、\n"
"その上位ビットでシステムコールの呼び出しの動作を制御する。\n"
"I<flags> には以下の値を指定できる。"

#. type: TP
#: build/C/man2/kexec_load.2:50
#, no-wrap
msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#.  FIXME figure out how this is really used
#. type: Plain text
#: build/C/man2/kexec_load.2:54
msgid "Execute the new kernel automatically on a system crash."
msgstr "システムのクラッシュ時に、新しいカーネルを自動的に実行する。"

#. type: TP
#: build/C/man2/kexec_load.2:54
#, no-wrap
msgid "B<KEXEC_PRESERVE_CONTEXT> (since Linux 2.6.27)"
msgstr "B<KEXEC_PRESERVE_CONTEXT> (Linux 2.6.27 以降)"

#. type: Plain text
#: build/C/man2/kexec_load.2:64
msgid ""
"Preserve the system hardware and software states before executing the new "
"kernel.  This could be used for system suspend.  This flag is available only "
"if the kernel was configured with B<CONFIG_KEXEC_JUMP>, and is effective "
"only if I<nr_segments> is greater than 0."
msgstr ""
"新しいカーネルを実行する前に、\n"
"システムのハードウェアとソフトウェアの状態を保存する。\n"
"システムの中断時 (suspend) などで使用できる。\n"
"このフラグは、カーネルの設定で B<CONFIG_KEXEC_JUMP> が有効の場合のみ\n"
"利用可能であり、 I<nr_segments> が 0 より大きい場合のみ効果がある。"

#. type: Plain text
#: build/C/man2/kexec_load.2:84
msgid ""
"The low-order bits of I<flags> contain the architecture of the to-be-"
"executed kernel.  Specify (OR) the constant B<KEXEC_ARCH_DEFAULT> to use the "
"current architecture, or one of the following architecture constants "
"B<KEXEC_ARCH_386>, B<KEXEC_ARCH_X86_64>, B<KEXEC_ARCH_PPC>, "
"B<KEXEC_ARCH_PPC64>, B<KEXEC_ARCH_IA_64>, B<KEXEC_ARCH_ARM>, "
"B<KEXEC_ARCH_S390>, B<KEXEC_ARCH_SH>, B<KEXEC_ARCH_MIPS>, and "
"B<KEXEC_ARCH_MIPS_LE>.  The architecture must be executable on the CPU of "
"the system."
msgstr ""
"I<flags> の下位ビットには、実行されるカーネルのアーキテクチャが入る。\n"
"現在のアーキテクチャを使うことを意味する定数 B<KEXEC_ARCH_DEFAULT> か、\n"
"アーキテクチャ定数 B<KEXEC_ARCH_386>, B<KEXEC_ARCH_X86_64>,\n"
"B<KEXEC_ARCH_PPC>, B<KEXEC_ARCH_PPC64>, B<KEXEC_ARCH_IA_64>,\n"
"B<KEXEC_ARCH_ARM>, B<KEXEC_ARCH_S390>, B<KEXEC_ARCH_SH>,\n"
"B<KEXEC_ARCH_MIPS>, B<KEXEC_ARCH_MIPS_LE> の\n"
"いずれか一つを (OR で) 指定する。指定するアーキテクチャは、\n"
"システムの CPU で実行可能なものでなければならない。"

#. type: Plain text
#: build/C/man2/kexec_load.2:98
msgid ""
"The I<entry> argument is the physical entry address in the kernel image.  "
"The I<nr_segments> argument is the number of segments pointed to by the "
"I<segments> pointer.  The I<segments> argument is an array of "
"I<kexec_segment> structures which define the kernel layout:"
msgstr ""
"I<entry> 引き数は、カーネルイメージの物理エントリーアドレスである。\n"
"I<nr_segments> 引き数は、 I<segments> ポインタが指すセグメントの\n"
"数である。 I<segments> 引き数は I<kexec_segment> 構造体の配列で、\n"
"この構造体によりカーネルの配置が定義される。"

#. type: Plain text
#: build/C/man2/kexec_load.2:107
#, no-wrap
msgid ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"
msgstr ""
"struct kexec_segment {\n"
"    void   *buf;        /* Buffer in user space */\n"
"    size_t  bufsz;      /* Buffer length in user space */\n"
"    void   *mem;        /* Physical address of kernel */\n"
"    size_t  memsz;      /* Physical address length */\n"
"};\n"

#.  FIXME elaborate on the following:
#. type: Plain text
#: build/C/man2/kexec_load.2:114
msgid ""
"The kernel image defined by I<segments> is copied from the calling process "
"into previously reserved memory."
msgstr ""
"I<segments> で定義されたカーネルイメージは、\n"
"呼び出したプロセスから予約済みメモリにコピーされる。"

#. type: Plain text
#: build/C/man2/kexec_load.2:121
msgid ""
"On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<kexec_load> は 0 を返す。\n"
"エラーの場合、 -1 が返り、 I<errno> にエラーを示す値が設定される。"

#. type: TP
#: build/C/man2/kexec_load.2:122 build/C/man2/pivot_root.2:110
#: build/C/man2/ptrace.2:1729 build/C/man2/quotactl.2:495
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/kexec_load.2:126
msgid ""
"Another crash kernel is already being loaded or a crash kernel is already in "
"use."
msgstr ""
"別のクラッシュカーネルがすでにロードされているか、\n"
"クラッシュカーネルがすでに使用されている。"

#.  KEXEC_SEGMENT_MAX == 16
#. type: Plain text
#: build/C/man2/kexec_load.2:133
msgid "I<flags> is invalid; or I<nr_segments> is too large"
msgstr "I<flags> が無効である。 I<nr_segments> が大きすぎる。"

#. type: Plain text
#: build/C/man2/kexec_load.2:138
msgid "The caller does not have the B<CAP_SYS_BOOT> capability."
msgstr "呼び出し側が B<CAP_SYS_BOOT> ケーパビリティを持っていない。"

#. type: Plain text
#: build/C/man2/kexec_load.2:142
msgid "The B<kexec_load>()  system call first appeared in Linux 2.6.13."
msgstr "B<kexec_load>() システムコールは Linux 2.6.13 で初めて登場した。"

#. type: Plain text
#: build/C/man2/kexec_load.2:149
msgid ""
"Currently, there is no glibc support for B<kexec_load>().  Call it using "
"B<syscall>(2)."
msgstr ""
"現在のところ、 B<kexec_load>() は glibc ではサポートされていない。\n"
"B<syscall>(2) を使って呼び出すこと。"

#.  FIXME Andi submitted a patch for this.
#.  Check if it got accepted later.
#. type: Plain text
#: build/C/man2/kexec_load.2:156
msgid ""
"The required constants are in the Linux kernel source file I<linux/kexec.h>, "
"which is not currently exported to glibc.  Therefore, these constants must "
"be defined manually."
msgstr ""
"必要な定数は Linux カーネルのソースファイル I<linux/kexec.h> で定義されてい"
"る\n"
"が、現在のところ glibc には公開されていない。\n"
"そのため、これらの定数は手動で定義しなければならない。"

#. type: Plain text
#: build/C/man2/kexec_load.2:159
msgid ""
"This system call is available only if the kernel was configured with "
"B<CONFIG_KEXEC>."
msgstr ""
"このシステムコールは、カーネルの設定で B<CONFIG_KEXEC> が有効になって\n"
"いる場合にのみ利用できる。"

#. type: Plain text
#: build/C/man2/kexec_load.2:162
msgid "B<reboot>(2), B<syscall>(2)"
msgstr "B<reboot>(2), B<syscall>(2)"

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "LOOKUP_DCOOKIE"
msgstr "LOOKUP_DCOOKIE"

#. type: TH
#: build/C/man2/lookup_dcookie.2:27
#, no-wrap
msgid "2004-06-17"
msgstr "2004-06-17"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:30
msgid "lookup_dcookie - return a directory entry's path"
msgstr "lookup_dcookie - ディレクトリ・エントリのパス名を返す"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:32
msgid ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t >I<len>B<);"
">"
msgstr ""
"B<int lookup_dcookie(u64 >I<cookie>B<, char *>I<buffer>B<, size_t >I<len>B<);"
">"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:38
msgid ""
"Look up the full path of the directory entry specified by the value "
"I<cookie>.  The cookie is an opaque identifier uniquely identifying a "
"particular directory entry.  The buffer given is filled in with the full "
"path of the directory entry."
msgstr ""
"I<cookie> 値で指定されたディレクトリ・エントリのフルパス名を検索する。 "
"cookie は、個々のディレクトリ・エントリを区別する内部識別子 (opaque "
"identifier) である。引き数で指定されたバッファに、ディレクトリ・エントリの フ"
"ルパス名が格納される。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:43
msgid ""
"For B<lookup_dcookie>()  to return successfully, the kernel must still hold "
"a cookie reference to the directory entry."
msgstr ""
"B<lookup_dcookie>()  が正常に値を返すためには、カーネルがディレクトリ・エント"
"リへの cookie 参照を 保持していなければならない。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:50
msgid ""
"On success, B<lookup_dcookie>()  returns the length of the path string "
"copied into the buffer.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、 B<lookup_dcookie>()  はバッファにコピーしたパス文字列の長さを"
"返す。 エラーの場合は -1 を返し、 I<errno> に適切な値を設定する。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:54
msgid "The buffer was not valid."
msgstr "バッファが有効でなかった。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:58
msgid ""
"The kernel has no registered cookie/directory entry mappings at the time of "
"lookup, or the cookie does not refer to a valid directory entry."
msgstr ""
"検索が行われた時、cookie とディレクトリ・エントリのマッピングがカーネルに 登"
"録されていなかったか、または cookie が有効なディレクトリ・エントリを 参照して"
"いない。"

#. type: TP
#: build/C/man2/lookup_dcookie.2:58
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:61
msgid "The name could not fit in the buffer."
msgstr "名前がバッファに入り切らなかった。"

#. type: TP
#: build/C/man2/lookup_dcookie.2:61 build/C/man2/process_vm_readv.2:262
#: build/C/man2/sendfile.2:138 build/C/man2/splice.2:155
#: build/C/man2/tee.2:111 build/C/man2/vmsplice.2:135
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:65
msgid ""
"The kernel could not allocate memory for the temporary buffer holding the "
"path."
msgstr ""
"カーネルが、パス名を保持する一時バッファ用のメモリを割り当てることが できな"
"かった。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:70
msgid ""
"The process does not have the capability B<CAP_SYS_ADMIN> required to look "
"up cookie values."
msgstr ""
"プロセスが cookie 値を検索するのに必要なケーパビリティ B<CAP_SYS_ADMIN> を"
"持っていない。"

#. type: TP
#: build/C/man2/lookup_dcookie.2:70 build/C/man2/quotactl.2:474
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:73
msgid ""
"The buffer was not large enough to hold the path of the directory entry."
msgstr ""
"バッファが、ディレクトリ・エントリのパス名を収容するのに 十分な大きさではな"
"かった。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:78
msgid ""
"Available since Linux 2.5.43.  The B<ENAMETOOLONG> error return was added in "
"2.5.70."
msgstr ""
"Linux 2.5.43 以降で利用できる。 エラー B<ENAMETOOLONG> を返す仕様は 2.5.70 で"
"追加された。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:81
msgid "B<lookup_dcookie>()  is Linux-specific."
msgstr "B<lookup_dcookie>()  は Linux 独自の関数である。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:85
msgid ""
"B<lookup_dcookie>()  is a special-purpose system call, currently used only "
"by the oprofile profiler.  It relies on a kernel driver to register cookies "
"for directory entries."
msgstr ""
"B<lookup_dcookie>()  は特殊な用途に使われるシステムコールで、現在のところ "
"oprofile profiler で 使われているだけである。"

#. type: Plain text
#: build/C/man2/lookup_dcookie.2:88
msgid ""
"The path returned may be suffixed by the string \" (deleted)\" if the "
"directory entry has been removed."
msgstr ""
"指定されたディレクトリ・エントリが削除されていた場合、返されるパス名の最後に "
"\" (deleted)\" という文字列が付加されることがある。"

#. type: TH
#: build/C/man2/modify_ldt.2:24
#, no-wrap
msgid "MODIFY_LDT"
msgstr "MODIFY_LDT"

#. type: Plain text
#: build/C/man2/modify_ldt.2:27
msgid "modify_ldt - get or set ldt"
msgstr "modify_ldt - ldt を設定または取得する"

#. type: Plain text
#: build/C/man2/modify_ldt.2:30
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/modify_ldt.2:32
#, no-wrap
msgid "B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long >I<bytecount>B<);>\n"
msgstr "B<int modify_ldt(int >I<func>B<, void *>I<ptr>B<, unsigned long >I<bytecount>B<);>\n"

#. type: Plain text
#: build/C/man2/modify_ldt.2:41
msgid ""
"B<modify_ldt>()  reads or writes the local descriptor table (ldt) for a "
"process.  The ldt is a per-process memory management table used by the i386 "
"processor.  For more information on this table, see an Intel 386 processor "
"handbook."
msgstr ""
"B<modify_ldt>()  はプロセスのローカル・ディスクリプタ・テーブル (local "
"descriptor table; ldt)  を読み書きする。 ldt は i386 プロセッサで使用されるプ"
"ロセスごとのメモリ管理テーブルである。 このテーブルに関してのより詳しい情報"
"は Intel 386 processor handbook を 参照すること。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:51
msgid ""
"When I<func> is 0, B<modify_ldt>()  reads the ldt into the memory pointed to "
"by I<ptr>.  The number of bytes read is the smaller of I<bytecount> and the "
"actual size of the ldt."
msgstr ""
"I<func> が 0 ならば、 B<modify_ldt>()  は ldt を I<ptr> が指しているメモリに"
"読み込む。 読み込むバイト数は実際の ldt のサイズか I<bytecount> より小さい方"
"である。"

#.  FIXME ? say something about func == 2 and func == 0x11?
#.  In Linux 2.4, func == 2 returned "the default ldt"
#.  In Linux 2.6, func == 2 is a nop, returning a zeroed out structure.
#.  Linux 2.4 and 2.6 implement an operation for func == 0x11
#. type: Plain text
#: build/C/man2/modify_ldt.2:69
msgid ""
"When I<func> is 1, B<modify_ldt>()  modifies one ldt entry.  I<ptr> points "
"to a I<user_desc> structure and I<bytecount> must equal the size of this "
"structure."
msgstr ""
"I<func> が 1 ならば、 B<modify_ldt>()  は ldt エントリの一つを変更する。 "
"I<ptr> は I<user_desc> 構造体を指し、 I<bytecount> はこの構造体の大きさに等し"
"くなければならない。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:73
msgid "The I<user_desc> structure is defined in I<E<lt>asm/ldt.hE<gt>> as:"
msgstr ""
"I<user_desc> 構造体は I<E<lt>asm/ldt.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/modify_ldt.2:87
#, no-wrap
msgid ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"
msgstr ""
"struct user_desc {\n"
"    unsigned int  entry_number;\n"
"    unsigned long base_addr;\n"
"    unsigned int  limit;\n"
"    unsigned int  seg_32bit:1;\n"
"    unsigned int  contents:2;\n"
"    unsigned int  read_exec_only:1;\n"
"    unsigned int  limit_in_pages:1;\n"
"    unsigned int  seg_not_present:1;\n"
"    unsigned int  useable:1;\n"
"};\n"

#.  .PP
#.  The ldt is specific for the calling process. Any attempts to change
#.  the ldt to include the address space of another process or the kernel
#.  will result in a segmentation violation when trying to access the memory
#.  outside of the process address space. The memory protection is enforced
#.  at the paging layer.
#. type: Plain text
#: build/C/man2/modify_ldt.2:98
msgid "In Linux 2.4 and earlier, this structure was named I<modify_ldt_ldt_s>."
msgstr ""
"Linux 2.4 以前では、この構造体は I<modify_ldt_ldt_s> という名前であった。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:108
msgid ""
"On success, B<modify_ldt>()  returns either the actual number of bytes read "
"(for reading)  or 0 (for writing).  On failure, B<modify_ldt>()  returns -1 "
"and sets I<errno> to indicate the error."
msgstr ""
"成功した場合は、 B<modify_ldt>()  は (読み込みの場合は) 実際に読み込んだバイ"
"ト数、 または (書き込みの場合は) 0 を返す。 失敗した場合は B<modify_ldt>()  "
"は -1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:113
msgid "I<ptr> points outside the address space."
msgstr "I<ptr> がアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:126
msgid ""
"I<ptr> is 0, or I<func> is 1 and I<bytecount> is not equal to the size of "
"the structure I<modify_ldt_ldt_s>, or I<func> is 1 and the new ldt entry has "
"invalid values."
msgstr ""
"I<ptr> が 0 である、 または I<func> が 1 で I<bytecount> が "
"I<modify_ldt_ldt_s> 構造体のサイズと等しくないか、 I<func> が 1 で新しい ldt "
"エントリが無効な値である。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:130
msgid "I<func> is neither 0 nor 1."
msgstr "I<func> が 0 でも 1 でもない。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:133
msgid ""
"This call is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムでは 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:136 build/C/man2/perfmonctl.2:205
#: build/C/man2/pivot_root.2:134
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/modify_ldt.2:138
msgid "B<vm86>(2)"
msgstr "B<vm86>(2)"

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "NFSSERVCTL"
msgstr "NFSSERVCTL"

#. type: TH
#: build/C/man2/nfsservctl.2:8
#, no-wrap
msgid "2012-03-05"
msgstr "2012-03-05"

#. type: Plain text
#: build/C/man2/nfsservctl.2:11
msgid "nfsservctl - syscall interface to kernel nfs daemon"
msgstr "nfsservctl - カーネル nfs デーモンのためのインターフェース"

#. type: Plain text
#: build/C/man2/nfsservctl.2:14
#, no-wrap
msgid "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"
msgstr "B<#include E<lt>linux/nfsd/syscall.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:17
#, no-wrap
msgid ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"
msgstr ""
"B<long nfsservctl(int >I<cmd>B<, struct nfsctl_arg *>I<argp>B<,>\n"
"B<                union nfsctl_res *>I<resp>B<);>\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:21
msgid "I<Note>: Since Linux 3.1, this system call no longer exists."
msgstr "I<注意>: Linux 3.1 以降では、このシステムコールはもはや存在しない。"

#. type: Plain text
#: build/C/man2/nfsservctl.2:33
#, no-wrap
msgid ""
"/*\n"
" * These are the commands understood by nfsctl().\n"
" */\n"
"#define NFSCTL_SVC          0    /* This is a server process. */\n"
"#define NFSCTL_ADDCLIENT    1    /* Add an NFS client. */\n"
"#define NFSCTL_DELCLIENT    2    /* Remove an NFS client. */\n"
"#define NFSCTL_EXPORT       3    /* export a file system. */\n"
"#define NFSCTL_UNEXPORT     4    /* unexport a file system. */\n"
"#define NFSCTL_UGIDUPDATE   5    /* update a client's UID/GID map. */\n"
"#define NFSCTL_GETFH        6    /* get an fh (used by mountd) */\n"
msgstr ""
"/*\n"
" * nfsctl() によって理解されるコマンド\n"
" */\n"
"#define NFSCTL_SVC          0    /* サーバープロセス */\n"
"#define NFSCTL_ADDCLIENT    1    /* NFS クライアントを追加 */\n"
"#define NFSCTL_DELCLIENT    2    /* NFS クライアンドを削除 */\n"
"#define NFSCTL_EXPORT       3    /* ファイルシステムのエクスポート */\n"
"#define NFSCTL_UNEXPORT     4    /* ファイルシステムのアンエクスポート */\n"
"#define NFSCTL_UGIDUPDATE   5    /* UID/GID マップの更新 */\n"
"#define NFSCTL_GETFH        6    /* (mountd で使用される) fh の取得 */\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:45
#, no-wrap
msgid ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"
msgstr ""
"struct nfsctl_arg {\n"
"    int                       ca_version;     /* safeguard */\n"
"    union {\n"
"        struct nfsctl_svc     u_svc;\n"
"        struct nfsctl_client  u_client;\n"
"        struct nfsctl_export  u_export;\n"
"        struct nfsctl_uidmap  u_umap;\n"
"        struct nfsctl_fhparm  u_getfh;\n"
"        unsigned int          u_debug;\n"
"    } u;\n"
"}\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:50
#, no-wrap
msgid ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"
msgstr ""
"union nfsctl_res {\n"
"        struct knfs_fh          cr_getfh;\n"
"        unsigned int            cr_debug;\n"
"};\n"

#. type: Plain text
#: build/C/man2/nfsservctl.2:56 build/C/man2/pivot_root.2:105
#: build/C/man2/vm86.2:59
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/nfsservctl.2:58
msgid "This call is Linux-specific."
msgstr "このコールは Linux 特有である。"

#. type: TH
#: build/C/man2/outb.2:26
#, no-wrap
msgid "OUTB"
msgstr "OUTB"

#. type: TH
#: build/C/man2/outb.2:26
#, no-wrap
msgid "2012-12-31"
msgstr "2012-12-31"

#. type: Plain text
#: build/C/man2/outb.2:31
msgid ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - port I/O"
msgstr ""
"outb, outw, outl, outsb, outsw, outsl, inb, inw, inl, insb, insw, insl, "
"outb_p, outw_p, outl_p, inb_p, inw_p, inl_p - ポート入出力"

#. type: Plain text
#: build/C/man2/outb.2:34
#, no-wrap
msgid "B<#include E<lt>sys/io.hE<gt>>\n"
msgstr "B<#include E<lt>sys/io.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/outb.2:41
#, no-wrap
msgid ""
"B<unsigned char inb(unsigned short int >I<port>B<);>\n"
"B<unsigned char inb_p(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw_p(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl_p(unsigned short int >I<port>B<);>\n"
msgstr ""
"B<unsigned char inb(unsigned short int >I<port>B<);>\n"
"B<unsigned char inb_p(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw(unsigned short int >I<port>B<);>\n"
"B<unsigned short int inw_p(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl(unsigned short int >I<port>B<);>\n"
"B<unsigned int inl_p(unsigned short int >I<port>B<);>\n"

#. type: Plain text
#: build/C/man2/outb.2:48
#, no-wrap
msgid ""
"B<void outb(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outb_p(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outw(unsigned short int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outw_p(unsigned short int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outl(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outl_p(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
msgstr ""
"B<void outb(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outb_p(unsigned char >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outw(unsigned short int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outw_p(unsigned short int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outl(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"
"B<void outl_p(unsigned int >I<value>B<, unsigned short int >I<port>B<);>\n"

#. type: Plain text
#: build/C/man2/outb.2:61
#, no-wrap
msgid ""
"B<void insb(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insw(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insl(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsb(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsw(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsl(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
msgstr ""
"B<void insb(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insw(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void insl(unsigned short int >I<port>B<, void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsb(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsw(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"
"B<void outsl(unsigned short int >I<port>B<, const void *>I<addr>B<,>\n"
"B<           unsigned long int >I<count>B<);>\n"

#. type: Plain text
#: build/C/man2/outb.2:67
msgid ""
"This family of functions is used to do low-level port input and output.  The "
"out* functions do port output, the in* functions do port input; the b-suffix "
"functions are byte-width and the w-suffix functions word-width; the _p-"
"suffix functions pause until the I/O completes."
msgstr ""
"この一連の関数はポートに対する低レベルの入出力に使用する。 out* 関数はポート"
"出力、in* 関数はポート入力を行う。 語尾に b がついている関数はバイト単位、w "
"がついている関数はワード単位である。 _p がついている関数は I/O が終了するまで"
"待つ。"

#.  , given the following information
#.  in addition to that given in
#.  .BR outb (9).
#. type: Plain text
#: build/C/man2/outb.2:73
msgid ""
"They are primarily designed for internal kernel use, but can be used from "
"user space."
msgstr ""
"これらの関数はもともとカーネル内部での使用を想定して設計されているが、 ユー"
"ザー空間からでも使用できる。"

#. type: Plain text
#: build/C/man2/outb.2:78
msgid ""
"You must compile with B<-O> or B<-O2> or similar.  The functions are defined "
"as inline macros, and will not be substituted in without optimization "
"enabled, causing unresolved references at link time."
msgstr ""
"B<-O> や B<-O2> などを指定してコンパイルしなければならない。 これらの関数はイ"
"ンライン・マクロとして定義されており、 最適化を行わないと関数の展開が行われ"
"ず、 リンクの時に「解決できない参照(unresolved reference)」が発生する。"

#. type: Plain text
#: build/C/man2/outb.2:87
msgid ""
"You use B<ioperm>(2)  or alternatively B<iopl>(2)  to tell the kernel to "
"allow the user space application to access the I/O ports in question.  "
"Failure to do this will cause the application to receive a segmentation "
"fault."
msgstr ""
"ユーザー空間のアプリケーションが I/O ポートにアクセスすることを カーネルに教"
"えるために B<ioperm>(2)  もしくは B<iopl>(2)  を使用すること。これを忘れると"
"アプリケーションはセグメンテーション違反 (segmentation fault) を受けとること"
"になる。"

#. type: Plain text
#: build/C/man2/outb.2:96
msgid ""
"B<outb>()  and friends are hardware-specific.  The I<value> argument is "
"passed first and the I<port> argument is passed second, which is the "
"opposite order from most DOS implementations."
msgstr ""
"B<outb>()  とその仲間はハードウェア特有である。 I<value> 引数が最初に渡さ"
"れ、 I<port> 引数が二番目に渡される。 この順序はほとんどの DOS での実装とは逆"
"である。"

#. type: Plain text
#: build/C/man2/outb.2:99
msgid "B<ioperm>(2), B<iopl>(2)"
msgstr "B<ioperm>(2), B<iopl>(2)"

#. type: TH
#: build/C/man2/pciconfig_read.2:8
#, no-wrap
msgid "PCICONFIG_READ"
msgstr "PCICONFIG_READ"

#. type: TH
#: build/C/man2/pciconfig_read.2:8
#, no-wrap
msgid "2003-07-14"
msgstr "2003-07-14"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:11
msgid ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci device information "
"handling"
msgstr ""
"pciconfig_read, pciconfig_write, pciconfig_iobase - pci デバイス情報を扱う"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:14
#, no-wrap
msgid "B<#include E<lt>pci.hE<gt>>\n"
msgstr "B<#include E<lt>pci.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:21
#, no-wrap
msgid ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"
msgstr ""
"B<int pciconfig_read(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_write(unsigned long >I<bus>B<, unsigned long >I<dfn>B<,>\n"
"B<          unsigned long >I<off>B<, unsigned long >I<len>B<, void *>I<buf>B<);>\n"
"B<int pciconfig_iobase(long >I<which>B<, unsigned long >I<bus>B<,>\n"
"B<          unsigned long >I<devfn>B<);>\n"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:27
msgid ""
"Most of the interaction with PCI devices is already handled by the kernel "
"PCI layer, and thus these calls should not normally need to be accessed from "
"user space."
msgstr ""
"PCI デバイスとのやり取り (interaction) は カーネル PCI レイヤですでに処理され"
"ているので、 通常はこららの関数をユーザ空間からアクセスする必要はない。"

#. type: TP
#: build/C/man2/pciconfig_read.2:27 build/C/man2/pciconfig_read.2:51
#, no-wrap
msgid "B<pciconfig_read>()"
msgstr "B<pciconfig_read>()"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:36
msgid "Reads to I<buf> from device I<dev> at offset I<off> value."
msgstr "デバイス I<dev> のオフセット I<off> の値を I<buf> に読み込む。"

#. type: TP
#: build/C/man2/pciconfig_read.2:36 build/C/man2/pciconfig_read.2:57
#, no-wrap
msgid "B<pciconfig_write>()"
msgstr "B<pciconfig_write>()"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:45
msgid "Writes from I<buf> to device I<dev> at offset I<off> value."
msgstr "デバイス I<dev> のオフセット I<off> に I<buf> の値を書き込む。"

#. type: TP
#: build/C/man2/pciconfig_read.2:45 build/C/man2/pciconfig_read.2:63
#, no-wrap
msgid "B<pciconfig_iobase>()"
msgstr "B<pciconfig_iobase>()"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:50
msgid ""
"You pass it a bus/devfn pair and get a physical address for either the "
"memory offset (for things like prep, this is 0xc0000000), the IO base for "
"PIO cycles, or the ISA holes if any."
msgstr ""
"bus/devfn ペアをこの関数に渡し、 メモリオフセット (prep のようなものでは、こ"
"の値は 0xc0000000 である) と PIO サイクルの IO ベースの物理アドレスを取得す"
"る。 また、もしあるならば ISA hole の物理アドレスを取得する。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:57 build/C/man2/pciconfig_read.2:63
msgid ""
"On success zero is returned.  On error, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、0 が返される。 エラーの場合、-1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:77
msgid ""
"Returns information on locations of various I/O regions in physical memory "
"according to the I<which> value.  Values for I<which> are: "
"B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, B<IOBASE_ISA_IO>, "
"B<IOBASE_ISA_MEM>."
msgstr ""
"I<which> の値に基づいて、物理メモリ内の様々な I/O 領域の位置情報が返される。 "
"I<which> の値は、 B<IOBASE_BRIDGE_NUMBER>, B<IOBASE_MEMORY>, B<IOBASE_IO>, "
"B<IOBASE_ISA_IO>, B<IOBASE_ISA_MEM> である。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:84
msgid "I<len> value is invalid.  This does not apply to B<pciconfig_iobase>()."
msgstr ""
"I<len> の値が無効である。 このエラーは B<pciconfig_iobase>()  には適用されな"
"い。"

#. type: TP
#: build/C/man2/pciconfig_read.2:84 build/C/man2/ptrace.2:1746
#: build/C/man2/sendfile.2:134
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:87
msgid "I/O error."
msgstr "I/O エラー。"

#. type: TP
#: build/C/man2/pciconfig_read.2:87
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:93
msgid ""
"For B<pciconfig_iobase>(), \"hose\" value is NULL.  For the other calls, "
"could not find a slot."
msgstr ""
"B<pciconfig_iobase>()  の場合、でホース (hose) の値が NULL である。 他の呼び"
"出しの場合、スロット (slot) が見つからない。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:98
msgid "The system has not implemented these calls (B<CONFIG_PCI> not defined)."
msgstr ""
"このシステムはこれらの呼び出しを実装していない。 (B<CONFIG_PCI> が定義されて"
"いない)。"

#. type: TP
#: build/C/man2/pciconfig_read.2:98
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:105
msgid ""
"This return value is valid only for B<pciconfig_iobase>().  It is returned "
"if the value for I<which> is invalid."
msgstr ""
"この返り値は B<pciconfig_iobase>()  でのみ有効である。 このエラーは I<which> "
"の値が無効であるときに返される。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:112
msgid ""
"User does not have the B<CAP_SYS_ADMIN> capability.  This does not apply to "
"B<pciconfig_iobase>()."
msgstr ""
"ユーザが B<CAP_SYS_ADMIN> 権限を持っていない。 このエラーは "
"B<pciconfig_iobase>()  には適用されない。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:114
msgid "These calls are Linux-specific, available since Linux 2.0.26/2.1.11."
msgstr ""
"これらの呼び出しは Linux 特有のものであり、 Linux 2.0.26/2.1.11 から使用可能"
"である。"

#. type: Plain text
#: build/C/man2/pciconfig_read.2:116
msgid "B<capabilities>(7)"
msgstr "B<capabilities>(7)"

#. type: TH
#: build/C/man2/perf_event_open.2:27
#, no-wrap
msgid "PERF_EVENT_OPEN"
msgstr "PERF_EVENT_OPEN"

#. type: TH
#: build/C/man2/perf_event_open.2:27
#, fuzzy, no-wrap
#| msgid "2013-02-04"
msgid "2013-07-02"
msgstr "2013-02-04"

#. type: Plain text
#: build/C/man2/perf_event_open.2:30
msgid "perf_event_open - set up performance monitoring"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:34
#, no-wrap
msgid ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"
msgstr ""
"B<#include E<lt>linux/perf_event.hE<gt>>\n"
"B<#include E<lt>linux/hw_breakpoint.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/perf_event_open.2:38
#, no-wrap
msgid ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"
msgstr ""
"B<int perf_event_open(struct perf_event_attr *>I<attr>B<,>\n"
"B<                    pid_t >I<pid>B<, int >I<cpu>B<, int >I<group_fd>B<,>\n"
"B<                    unsigned long >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/perf_event_open.2:47
msgid ""
"Given a list of parameters, B<perf_event_open>()  returns a file descriptor, "
"for use in subsequent system calls (B<read>(2), B<mmap>(2), B<prctl>(2), "
"B<fcntl>(2), etc.)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:55
msgid ""
"A call to B<perf_event_open>()  creates a file descriptor that allows "
"measuring performance information.  Each file descriptor corresponds to one "
"event that is measured; these can be grouped together to measure multiple "
"events simultaneously."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:62
msgid ""
"Events can be enabled and disabled in two ways: via B<ioctl>(2)  and via "
"B<prctl>(2)B<.> When an event is disabled it does not count or generate "
"overflows but does continue to exist and maintain its count value."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:76
msgid ""
"Events come in two flavors: counting and sampled.  A I<counting> event is "
"one that is used for counting the aggregate number of events that occur.  In "
"general, counting event results are gathered with a B<read>(2)  call.  A "
"I<sampling> event periodically writes measurements to a buffer that can then "
"be accessed via B<mmap>(2)B<.>"
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:76
#, no-wrap
msgid "Arguments"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:90
msgid ""
"The argument I<pid> allows events to be attached to processes in various "
"ways.  If I<pid> is 0, measurements happen on the current thread, if I<pid> "
"is greater than 0, the process indicated by I<pid> is measured, and if "
"I<pid> is -1, all processes are counted."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:101
msgid ""
"The I<cpu> argument allows measurements to be specific to a CPU.  If I<cpu> "
"is greater than or equal to 0, measurements are restricted to the specified "
"CPU; if I<cpu> is -1, the events are measured on all CPUs."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:107
msgid ""
"Note that the combination of I<pid> == -1 and I<cpu> == -1 is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:115
msgid ""
"A I<pid> E<gt> 0 and I<cpu> == -1 setting measures per-process and follows "
"that process to whatever CPU the process gets scheduled to.  Per-process "
"events can be created by any user."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:126
msgid ""
"A I<pid> == -1 and I<cpu> E<gt>= 0 setting is per-CPU and measures all "
"processes on the specified CPU.  Per-CPU events need the B<CAP_SYS_ADMIN> "
"capability or a I</proc/sys/kernel/perf_event_paranoid> value of less than 1."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:148
msgid ""
"The I<group_fd> argument allows event groups to be created.  An event group "
"has one event which is the group leader.  The leader is created first, with "
"I<group_fd> = -1.  The rest of the group members are created with subsequent "
"B<perf_event_open>()  calls with I<group_fd> being set to the fd of the "
"group leader.  (A single event on its own is created with I<group_fd> = -1 "
"and is considered to be a group with only 1 member.)  An event group is "
"scheduled onto the CPU as a unit: it will be put onto the CPU only if all of "
"the events in the group can be put onto the CPU.  This means that the values "
"of the member events can be meaningfully compared, added, divided (to get "
"ratios), etc., with each other, since they have counted events for the same "
"set of executed instructions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:152
#, fuzzy
#| msgid ""
#| "The I<flags> argument is a bit mask that is composed by ORing together "
#| "zero or more of the following values:"
msgid ""
"The I<flags> argument is formed by ORing together zero or more of the "
"following values:"
msgstr ""
"I<flags> 引き数には、以下の値の 0 個以上をビット毎の論理和の形で指定する。"

#. type: TP
#: build/C/man2/perf_event_open.2:152
#, no-wrap
msgid "B<PERF_FLAG_FD_NO_GROUP>"
msgstr ""

#.  FIXME The following sentence is unclear
#.  FIXME So, why is it useful?
#. type: Plain text
#: build/C/man2/perf_event_open.2:159
msgid ""
"This flag allows creating an event as part of an event group but having no "
"group leader.  It is unclear why this is useful."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:159
#, no-wrap
msgid "B<PERF_FLAG_FD_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:162
msgid "This flag re-routes the output from an event to the group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:162
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "B<PERF_FLAG_PID_CGROUP> (Since Linux 2.6.39)."
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:185
msgid ""
"This flag activates per-container system-wide monitoring.  A container is an "
"abstraction that isolates a set of resources for finer grain control (CPUs, "
"memory, etc...).  In this mode, the event is measured only if the thread "
"running on the monitored CPU belongs to the designated container (cgroup).  "
"The cgroup is identified by passing a file descriptor opened on its "
"directory in the cgroupfs filesystem.  For instance, if the cgroup to "
"monitor is called I<test>, then a file descriptor opened on I</dev/cgroup/"
"test> (assuming cgroupfs is mounted on I</dev/cgroup>)  must be passed as "
"the I<pid> parameter.  cgroup monitoring is available only for system-wide "
"events and may therefore require extra permissions."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:190
msgid ""
"The I<perf_event_attr> structure provides detailed configuration information "
"for the event being created."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:197
#, no-wrap
msgid ""
"struct perf_event_attr {\n"
"    __u32     type;         /* Type of event */\n"
"    __u32     size;         /* Size of attribute structure */\n"
"    __u64     config;       /* Type-specific configuration */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:202
#, no-wrap
msgid ""
"    union {\n"
"        __u64 sample_period;    /* Period of sampling */\n"
"        __u64 sample_freq;      /* Frequency of sampling */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:205
#, no-wrap
msgid ""
"    __u64     sample_type;  /* Specifies values included in sample */\n"
"    __u64     read_format;  /* Specifies values returned in read */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:231
#, no-wrap
msgid ""
"    __u64     disabled       : 1,   /* off by default */\n"
"              inherit        : 1,   /* children inherit it */\n"
"              pinned         : 1,   /* must always be on PMU */\n"
"              exclusive      : 1,   /* only group on PMU */\n"
"              exclude_user   : 1,   /* don't count user */\n"
"              exclude_kernel : 1,   /* don't count kernel */\n"
"              exclude_hv     : 1,   /* don't count hypervisor */\n"
"              exclude_idle   : 1,   /* don't count when idle */\n"
"              mmap           : 1,   /* include mmap data */\n"
"              comm           : 1,   /* include comm data */\n"
"              freq           : 1,   /* use freq, not period */\n"
"              inherit_stat   : 1,   /* per task counts */\n"
"              enable_on_exec : 1,   /* next exec enables */\n"
"              task           : 1,   /* trace fork/exit */\n"
"              watermark      : 1,   /* wakeup_watermark */\n"
"              precise_ip     : 2,   /* skid constraint */\n"
"              mmap_data      : 1,   /* non-exec mmap data */\n"
"              sample_id_all  : 1,   /* sample_type all events */\n"
"              exclude_host   : 1,   /* don't count in host */\n"
"              exclude_guest  : 1,   /* don't count in guest */\n"
"              exclude_callchain_kernel : 1,\n"
"                                    /* exclude kernel callchains */\n"
"              exclude_callchain_user   : 1,\n"
"\t                            /* exclude user callchains */\n"
"              __reserved_1   : 41;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:236
#, no-wrap
msgid ""
"    union {\n"
"        __u32 wakeup_events;    /* wakeup every n events */\n"
"        __u32 wakeup_watermark; /* bytes before wakeup */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:238
#, no-wrap
msgid "    __u32     bp_type;          /* breakpoint type */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:243
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_addr;          /* breakpoint address */\n"
"        __u64 config1;          /* extension of config */\n"
"    };\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:253
#, no-wrap
msgid ""
"    union {\n"
"        __u64 bp_len;           /* breakpoint length */\n"
"        __u64 config2;          /* extension of config1 */\n"
"    };\n"
"    __u64   branch_sample_type; /* enum perf_branch_sample_type */\n"
"    __u64   sample_regs_user;   /* user regs to dump on samples */\n"
"    __u32   sample_stack_user;  /* size of stack to dump on\n"
"                                   samples */\n"
"    __u32   __reserved_2;       /* Align to u64 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:255
#, no-wrap
msgid "};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:261
msgid ""
"The fields of the I<perf_event_attr> structure are described in more detail "
"below:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:261 build/C/man2/perf_event_open.2:1297
#, no-wrap
msgid "I<type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:265
msgid ""
"This field specifies the overall event type.  It has one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:266
#, no-wrap
msgid "B<PERF_TYPE_HARDWARE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:273
msgid ""
"This indicates one of the \"generalized\" hardware events provided by the "
"kernel.  See the I<config> field definition for more details."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:273
#, no-wrap
msgid "B<PERF_TYPE_SOFTWARE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:277
msgid ""
"This indicates one of the software-defined events provided by the kernel "
"(even if no hardware support is available)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:277
#, no-wrap
msgid "B<PERF_TYPE_TRACEPOINT>"
msgstr "B<PERF_TYPE_TRACEPOINT>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:281
msgid ""
"This indicates a tracepoint provided by the kernel tracepoint infrastructure."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:281
#, no-wrap
msgid "B<PERF_TYPE_HW_CACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:287
msgid ""
"This indicates a hardware cache event.  This has a special encoding, "
"described in the I<config> field definition."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:287
#, no-wrap
msgid "B<PERF_TYPE_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:291
msgid ""
"This indicates a \"raw\" implementation-specific event in the I<config> "
"field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:291
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "B<PERF_TYPE_BREAKPOINT> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:296
msgid ""
"This indicates a hardware breakpoint as provided by the CPU.  Breakpoints "
"can be read/write accesses to an address as well as execution of an "
"instruction address."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:296
#, no-wrap
msgid "dynamic PMU"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:315
msgid ""
"Since Linux 2.6.39, B<perf_event_open>()  can support multiple PMUs.  To "
"enable this, a value exported by the kernel can be used in the I<type> field "
"to indicate which PMU to use.  The value to use can be found in the sysfs "
"filesystem: there is a subdirectory per PMU instance under I</sys/bus/"
"event_source/devices>.  In each sub-directory there is a I<type> file whose "
"content is an integer that can be used in the I<type> field.  For instance, "
"I</sys/bus/event_source/devices/cpu/type> contains the value for the core "
"CPU PMU, which is usually 4."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:316 build/C/man2/perf_event_open.2:1734
#, no-wrap
msgid "I<size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:325
msgid ""
"The size of the I<perf_event_attr> structure for forward/backward "
"compatibility.  Set this using I<sizeof(struct perf_event_attr)> to allow "
"the kernel to see the struct size at the time of compilation."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:340
msgid ""
"The related define B<PERF_ATTR_SIZE_VER0> is set to 64; this was the size of "
"the first published struct.  B<PERF_ATTR_SIZE_VER1> is 72, corresponding to "
"the addition of breakpoints in Linux 2.6.33.  B<PERF_ATTR_SIZE_VER2> is 80 "
"corresponding to the addition of branch sampling in Linux 3.4.  "
"B<PERF_ATR_SIZE_VER3> is 96 corresponding to the addition of "
"I<sample_regs_user> and I<sample_stack_user> in Linux 3.7."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:340
#, no-wrap
msgid "I<config>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:351
msgid ""
"This specifies which event you want, in conjunction with the I<type> field.  "
"The I<config1> and I<config2> fields are also taken into account in cases "
"where 64 bits is not enough to fully specify the event.  The encoding of "
"these fields are event dependent."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:357
msgid ""
"The most significant bit (bit 63) of I<config> signifies CPU-specific (raw) "
"counter configuration data; if the most significant bit is unset, the next 7 "
"bits are an event type and the rest of the bits are the event identifier."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:368
msgid ""
"There are various ways to set the I<config> field that are dependent on the "
"value of the previously described I<type> field.  What follows are various "
"possible settings for I<config> separated out by I<type>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:378
msgid ""
"If I<type> is B<PERF_TYPE_HARDWARE>, we are measuring one of the generalized "
"hardware CPU events.  Not all of these are available on all platforms.  Set "
"I<config> to one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:379
#, no-wrap
msgid "B<PERF_COUNT_HW_CPU_CYCLES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:383
msgid "Total cycles.  Be wary of what happens during CPU frequency scaling"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:383
#, no-wrap
msgid "B<PERF_COUNT_HW_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:388
msgid ""
"Retired instructions.  Be careful, these can be affected by various issues, "
"most notably hardware interrupt counts"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:388
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_REFERENCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:395
msgid ""
"Cache accesses.  Usually this indicates Last Level Cache accesses but this "
"may vary depending on your CPU.  This may include prefetches and coherency "
"messages; again this depends on the design of your CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:395
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_MISSES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:402
msgid ""
"Cache misses.  Usually this indicates Last Level Cache misses; this is "
"intended to be used in conjunction with the "
"B<PERF_COUNT_HW_CACHE_REFERENCES> event to calculate cache miss rates."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:402
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_INSTRUCTIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:407
msgid ""
"Retired branch instructions.  Prior to Linux 2.6.34, this used the wrong "
"event on AMD processors."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:407
#, no-wrap
msgid "B<PERF_COUNT_HW_BRANCH_MISSES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:410
msgid "Mispredicted branch instructions."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:410
#, no-wrap
msgid "B<PERF_COUNT_HW_BUS_CYCLES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:413
msgid "Bus cycles, which can be different from total cycles."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:413
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_FRONTEND> (Since Linux 3.0)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (Linux 2.5.60 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:416
msgid "Stalled cycles during issue."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:416
#, no-wrap
msgid "B<PERF_COUNT_HW_STALLED_CYCLES_BACKEND> (Since Linux 3.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:419
msgid "Stalled cycles during retirement."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:419
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgid "B<PERF_COUNT_HW_REF_CPU_CYCLES> (Since Linux 3.3)"
msgstr "B<PTRACE_O_TRACECLONE> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:422
msgid "Total cycles; not affected by CPU frequency scaling."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:432
msgid ""
"If I<type> is B<PERF_TYPE_SOFTWARE>, we are measuring software events "
"provided by the kernel.  Set I<config> to one of the following:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:433
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_CLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:436
msgid "This reports the CPU clock, a high-resolution per-CPU timer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:436
#, no-wrap
msgid "B<PERF_COUNT_SW_TASK_CLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:439
msgid "This reports a clock count specific to the task that is running."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:439
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:442
msgid "This reports the number of page faults."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:442
#, no-wrap
msgid "B<PERF_COUNT_SW_CONTEXT_SWITCHES>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:447
msgid ""
"This counts context switches.  Until Linux 2.6.34, these were all reported "
"as user-space events, after that they are reported as happening in the "
"kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:447
#, no-wrap
msgid "B<PERF_COUNT_SW_CPU_MIGRATIONS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:451
msgid "This reports the number of times the process has migrated to a new CPU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:451
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:455
msgid ""
"This counts the number of minor page faults.  These did not require disk I/O "
"to handle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:455
#, no-wrap
msgid "B<PERF_COUNT_SW_PAGE_FAULTS_MAJ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:459
msgid ""
"This counts the number of major page faults.  These required disk I/O to "
"handle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:459
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "B<PERF_COUNT_SW_ALIGNMENT_FAULTS> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:465
msgid ""
"This counts the number of alignment faults.  These happen when unaligned "
"memory accesses happen; the kernel can handle these but it reduces "
"performance.  This happens only on some architectures (never on x86)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:465
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "B<PERF_COUNT_SW_EMULATION_FAULTS> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:471
msgid ""
"This counts the number of emulation faults.  The kernel sometimes traps on "
"unimplemented instructions and emulates them for user space.  This can "
"negatively impact performance."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:484
msgid ""
"If I<type> is B<PERF_TYPE_TRACEPOINT>, then we are measuring kernel "
"tracepoints.  The value to use in I<config> can be obtained from under "
"debugfs I<tracing/events/*/*/id> if ftrace is enabled in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:495
msgid ""
"If I<type> is B<PERF_TYPE_HW_CACHE>, then we are measuring a hardware CPU "
"cache event.  To calculate the appropriate I<config> value use the following "
"equation:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:500
#, no-wrap
msgid ""
"    (perf_hw_cache_id) | (perf_hw_cache_op_id E<lt>E<lt> 8) |\n"
"    (perf_hw_cache_op_result_id E<lt>E<lt> 16)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:505
msgid "where I<perf_hw_cache_id> is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:506
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1D>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:509
msgid "for measuring Level 1 Data Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:509
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_L1I>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:512
msgid "for measuring Level 1 Instruction Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:512
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_LL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:515
msgid "for measuring Last-Level Cache"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:515
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_DTLB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:518
msgid "for measuring the Data TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:518
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_ITLB>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:521
msgid "for measuring the Instruction TLB"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:521
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_BPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:524
msgid "for measuring the branch prediction unit"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:524
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgid "B<PERF_COUNT_HW_CACHE_NODE> (Since Linux 3.0)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (Linux 2.5.60 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:527
msgid "for measuring local memory accesses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:532
msgid "and I<perf_hw_cache_op_id> is one of"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:533
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:536
msgid "for read accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:536
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:539
msgid "for write accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:539
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_OP_PREFETCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:542
msgid "for prefetch accesses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:547
msgid "and I<perf_hw_cache_op_result_id> is one of"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:548
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_ACCESS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:551
msgid "to measure accesses"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:551
#, no-wrap
msgid "B<PERF_COUNT_HW_CACHE_RESULT_MISS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:554
msgid "to measure misses"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:572
msgid ""
"If I<type> is B<PERF_TYPE_RAW>, then a custom \"raw\" I<config> value is "
"needed.  Most CPUs support events that are not covered by the \"generalized"
"\" events.  These are implementation defined; see your CPU manual (for "
"example the Intel Volume 3B documentation or the AMD BIOS and Kernel "
"Developer Guide).  The libpfm4 library can be used to translate from the "
"name in the architectural manuals to the raw hex value B<perf_event_open>()  "
"expects in this field."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:581
msgid ""
"If I<type> is B<PERF_TYPE_BREAKPOINT>, then leave I<config> set to zero.  "
"Its parameters are set in other places."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:582
#, no-wrap
msgid "I<sample_period>, I<sample_freq>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:594
msgid ""
"A \"sampling\" counter is one that generates an interrupt every N events, "
"where N is given by I<sample_period>.  A sampling counter has "
"I<sample_period> E<gt> 0.  When an overflow interrupt occurs, requested data "
"is recorded in the mmap buffer.  The I<sample_type> field controls what data "
"is recorded on each interrupt."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:604
msgid ""
"I<sample_freq> can be used if you wish to use frequency rather than period.  "
"In this case you set the I<freq> flag.  The kernel will adjust the sampling "
"period to try and achieve the desired rate.  The rate of adjustment is a "
"timer tick."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:604
#, no-wrap
msgid "I<sample_type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:616
msgid ""
"The various bits in this field specify which values to include in the "
"sample.  They will be recorded in a ring-buffer, which is available to user "
"space using B<mmap>(2).  The order in which the values are saved in the "
"sample are documented in the MMAP Layout subsection below; it is not the "
"I<enum perf_event_sample_format> order."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:617
#, no-wrap
msgid "B<PERF_SAMPLE_IP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:620
msgid "Records instruction pointer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:620
#, no-wrap
msgid "B<PERF_SAMPLE_TID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:623
msgid "Records the process and thread IDs."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:623
#, no-wrap
msgid "B<PERF_SAMPLE_TIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:626
msgid "Records a timestamp."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:626
#, no-wrap
msgid "B<PERF_SAMPLE_ADDR>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:629
msgid "Records an address, if applicable."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:629
#, no-wrap
msgid "B<PERF_SAMPLE_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:632
msgid ""
"Record counter values for all events in a group, not just the group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:632
#, no-wrap
msgid "B<PERF_SAMPLE_CALLCHAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:635
msgid "Records the callchain (stack backtrace)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:635
#, no-wrap
msgid "B<PERF_SAMPLE_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:638
msgid "Records a unique ID for the opened event's group leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:638
#, no-wrap
msgid "B<PERF_SAMPLE_CPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:641
msgid "Records CPU number."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:641
#, no-wrap
msgid "B<PERF_SAMPLE_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:644
msgid "Records the current sampling period."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:644
#, no-wrap
msgid "B<PERF_SAMPLE_STREAM_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:651
msgid ""
"Records a unique ID for the opened event.  Unlike B<PERF_SAMPLE_ID> the "
"actual ID is returned, not the group leader.  This ID is the same as the one "
"returned by PERF_FORMAT_ID."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:651
#, no-wrap
msgid "B<PERF_SAMPLE_RAW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:655
msgid ""
"Records additional data, if applicable.  Usually returned by tracepoint "
"events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:655
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgid "B<PERF_SAMPLE_BRANCH_STACK> (Since Linux 3.4)"
msgstr "B<PTRACE_O_TRACEFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:659
msgid "Records the branch stack.  See branch_sample_type."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:659
#, fuzzy, no-wrap
#| msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgid "B<PERF_SAMPLE_REGS_USER> (Since Linux 3.7)"
msgstr "B<FUTEX_CMP_REQUEUE> (Linux 2.6.7 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:663
msgid ""
"Records the current user-level CPU register state (the values in the process "
"before the kernel was called)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:663
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgid "B<PERF_SAMPLE_STACK_USER> (Since Linux 3.7)"
msgstr "B<PTRACE_O_TRACEFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:666
msgid "Records the user level stack, allowing stack unwinding."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:666
#, fuzzy, no-wrap
#| msgid "B<FUTEX_CMP_REQUEUE> (since Linux 2.6.7)"
msgid "B<PERF_SAMPLE_WEIGHT> (Since Linux 3.10)"
msgstr "B<FUTEX_CMP_REQUEUE> (Linux 2.6.7 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:672
msgid ""
"Records a hardware provided weight value that expresses how costly the "
"sampled event was.  This allows the hardware to highlight expensive events "
"in a profile."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:672
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgid "B<PERF_SAMPLE_DATA_SRC> (Since Linux 3.10)"
msgstr "B<PTRACE_O_TRACEFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:678
msgid ""
"Records the data source: where in the memory hierarchy the data associated "
"with the sampled instruction came from.  This is only available if the "
"underlying hardware supports this feature."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:679
#, no-wrap
msgid "I<read_format>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:686
msgid ""
"This field specifies the format of the data returned by B<read>(2)  on a "
"B<perf_event_open>()  file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:687
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_ENABLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:694
msgid ""
"Adds the 64-bit I<time_enabled> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:694
#, no-wrap
msgid "B<PERF_FORMAT_TOTAL_TIME_RUNNING>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:701
msgid ""
"Adds the 64-bit I<time_running> field.  This can be used to calculate "
"estimated totals if the PMU is overcommitted and multiplexing is happening."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:701
#, no-wrap
msgid "B<PERF_FORMAT_ID>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:704
msgid "Adds a 64-bit unique value that corresponds to the event group."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:704
#, no-wrap
msgid "B<PERF_FORMAT_GROUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:707
msgid "Allows all counter values in an event group to be read with one read."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:708
#, no-wrap
msgid "I<disabled>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:718
msgid ""
"The I<disabled> bit specifies whether the counter starts out disabled or "
"enabled.  If disabled, the event can later be enabled by B<ioctl>(2), "
"B<prctl>(2), or I<enable_on_exec>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:718
#, no-wrap
msgid "I<inherit>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:727
msgid ""
"The I<inherit> bit specifies that this counter should count events of child "
"tasks as well as the task specified.  This applies only to new children, not "
"to any existing children at the time the counter is created (nor to any new "
"children of existing children)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:732
msgid ""
"Inherit does not work for some combinations of I<read_format>s, such as "
"B<PERF_FORMAT_GROUP>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:732
#, no-wrap
msgid "I<pinned>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:745
msgid ""
"The I<pinned> bit specifies that the counter should always be on the CPU if "
"at all possible.  It applies only to hardware counters and only to group "
"leaders.  If a pinned counter cannot be put onto the CPU (e.g., because "
"there are not enough hardware counters or because of a conflict with some "
"other event), then the counter goes into an 'error' state, where reads "
"return end-of-file (i.e., B<read>(2)  returns 0) until the counter is "
"subsequently enabled or disabled."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:745
#, no-wrap
msgid "I<exclusive>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:754
msgid ""
"The I<exclusive> bit specifies that when this counter's group is on the CPU, "
"it should be the only group using the CPU's counters.  In the future this "
"may allow monitoring programs to support PMU features that need to run alone "
"so that they do not disrupt other hardware counters."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:754
#, no-wrap
msgid "I<exclude_user>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:757
msgid ""
"If this bit is set, the count excludes events that happen in user space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:757
#, no-wrap
msgid "I<exclude_kernel>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:760
msgid ""
"If this bit is set, the count excludes events that happen in kernel-space."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:760
#, no-wrap
msgid "I<exclude_hv>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:768
msgid ""
"If this bit is set, the count excludes events that happen in the "
"hypervisor.  This is mainly for PMUs that have built-in support for handling "
"this (such as POWER).  Extra support is needed for handling hypervisor "
"measurements on most machines."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:768
#, no-wrap
msgid "I<exclude_idle>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:771
msgid "If set, don't count when the CPU is idle."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:771
#, no-wrap
msgid "I<mmap>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:776
msgid "The I<mmap> bit enables recording of exec mmap events."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:776
#, no-wrap
msgid "I<comm>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:787
msgid ""
"The I<comm> bit enables tracking of process command name as modified by the "
"I<exec>(2)  and I<prctl>(PR_SET_NAME)  system calls.  Unfortunately for "
"tools, there is no way to distinguish one system call versus the other."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:787
#, no-wrap
msgid "I<freq>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:794
msgid ""
"If this bit is set, then I<sample_frequency> not I<sample_period> is used "
"when setting up the sampling interval."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:794
#, no-wrap
msgid "I<inherit_stat>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:801
msgid ""
"This bit enables saving of event counts on context switch for inherited "
"tasks.  This is meaningful only if the I<inherit> field is set."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:801
#, no-wrap
msgid "I<enable_on_exec>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:806
msgid ""
"If this bit is set, a counter is automatically enabled after a call to "
"B<exec>(2)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:806
#, no-wrap
msgid "I<task>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:810
msgid ""
"If this bit is set, then fork/exit notifications are included in the ring "
"buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:810
#, no-wrap
msgid "I<watermark>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:818
msgid ""
"If set, have a sampling interrupt happen when we cross the "
"I<wakeup_watermark> boundary.  Otherwise interrupts happen after "
"I<wakeup_events> samples."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:818
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<precise_ip> (Since Linux 2.6.35)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:828
msgid ""
"This controls the amount of skid.  Skid is how many instructions execute "
"between an event of interest happening and the kernel being able to stop and "
"record the event.  Smaller skid is better and allows more accurate reporting "
"of which events correspond to which instructions, but hardware is often "
"limited with how small this can be."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:830
#, fuzzy
#| msgid "The I<subcmd> value is one of the following:"
msgid "The values of this are the following:"
msgstr "I<subcmd> の値は以下のいずれかである"

#. type: TP
#: build/C/man2/perf_event_open.2:831
#, no-wrap
msgid "0 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:835
msgid "B<SAMPLE_IP> can have arbitrary skid"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:835
#, no-wrap
msgid "1 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:839
msgid "B<SAMPLE_IP> must have constant skid"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:839
#, no-wrap
msgid "2 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:843
msgid "B<SAMPLE_IP> requested to have 0 skid"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:843
#, no-wrap
msgid "3 -"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:849
msgid "B<SAMPLE_IP> must have 0 skid.  See also B<PERF_RECORD_MISC_EXACT_IP>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:850
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<mmap_data> (Since Linux 2.6.36)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:856
msgid ""
"The counterpart of the I<mmap> field, but enables including data mmap events "
"in the ring-buffer."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:856
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<sample_id_all> (Since Linux 2.6.38)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:864
msgid ""
"If set, then TID, TIME, ID, CPU, and STREAM_ID can additionally be included "
"in non-B<PERF_RECORD_SAMPLE>s if the corresponding I<sample_type> is "
"selected."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:864
#, no-wrap
msgid "I<exclude_host> (Since Linux 3.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:867
msgid "Do not measure time spent in VM host"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:867
#, no-wrap
msgid "I<exclude_guest> (Since Linux 3.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:870
msgid "Do not measure time spent in VM guest"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:870
#, no-wrap
msgid "I<exclude_callchain_kernel> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:873
msgid "Do not include kernel callchains."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:873
#, no-wrap
msgid "I<exclude_callchain_user> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:876
msgid "Do not include user callchains."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:876
#, no-wrap
msgid "I<wakeup_events>, I<wakeup_watermark>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:886
msgid ""
"This union sets how many samples (I<wakeup_events>)  or bytes "
"(I<wakeup_watermark>)  happen before an overflow signal happens.  Which one "
"is used is selected by the I<watermark> bitflag."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:896
msgid ""
"I<wakeup_events> only counts B<PERF_RECORD_SAMPLE> record types.  To receive "
"a signal for every incoming B<PERF_RECORD> type set I<wakeup_watermark> to 1."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:896
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<bp_type> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:900
msgid "This chooses the breakpoint type.  It is one of:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:901
#, no-wrap
msgid "B<HW_BREAKPOINT_EMPTY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:904
msgid "no breakpoint"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:904
#, no-wrap
msgid "B<HW_BREAKPOINT_R>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:907
msgid "count when we read the memory location"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:907
#, no-wrap
msgid "B<HW_BREAKPOINT_W>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:910
msgid "count when we write the memory location"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:910
#, no-wrap
msgid "B<HW_BREAKPOINT_RW>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:913
msgid "count when we read or write the memory location"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:913
#, no-wrap
msgid "B<HW_BREAKPOINT_X>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:916
msgid "count when we execute code at the memory location"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:925
msgid ""
"The values can be combined via a bitwise or, but the combination of "
"B<HW_BREAKPOINT_R> or B<HW_BREAKPOINT_W> with B<HW_BREAKPOINT_X> is not "
"allowed."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:926
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<bp_addr> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:933
msgid ""
"I<bp_addr> address of the breakpoint.  For execution breakpoints this is the "
"memory address of the instruction of interest; for read and write "
"breakpoints it is the memory address of the memory location of interest."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:933
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<config1> (Since Linux 2.6.39)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:940
msgid ""
"I<config1> is used for setting events that need an extra register or "
"otherwise do not fit in the regular config field.  Raw OFFCORE_EVENTS on "
"Nehalem/Westmere/SandyBridge use this field on 3.3 and later kernels."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:940
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<bp_len> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:954
msgid ""
"I<bp_len> is the length of the breakpoint being measured if I<type> is "
"B<PERF_TYPE_BREAKPOINT>.  Options are B<HW_BREAKPOINT_LEN_1>, "
"B<HW_BREAKPOINT_LEN_2>, B<HW_BREAKPOINT_LEN_4>, B<HW_BREAKPOINT_LEN_8>.  For "
"an execution breakpoint, set this to I<sizeof(long)>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:954
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "I<config2> (Since Linux 2.6.39)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:961
msgid "I<config2> is a further extension of the I<config1> field."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:961
#, no-wrap
msgid "I<branch_sample_type> (Since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:965
msgid ""
"This is used with the CPUs hardware branch sampling, if available.  It can "
"have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:966
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:969
msgid "Branch target is in user space"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:969
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:972
msgid "Branch target is in kernel space"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:972
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_HV>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:975
msgid "Branch target is in hypervisor"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:975
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:978
msgid "Any branch type."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:978
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:981
msgid "Any call branch"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:981
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_ANY_RETURN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:984
msgid "Any return branch"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:984
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_IND_CALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:987
msgid "Indirect calls"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:987
#, no-wrap
msgid "B<PERF_SAMPLE_BRANCH_PLM_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:990
msgid "User, kernel, and hv"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:991
#, no-wrap
msgid "I<sample_regs_user> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:997
msgid ""
"This bitmask defines the set of user CPU registers to dump on samples.  The "
"layout of the register mask is architecture specific and described in the "
"kernel header I<arch/ARCH/include/uapi/asm/perf_regs.h>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:997
#, no-wrap
msgid "I<sample_stack_user> (Since Linux 3.7)"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1002
msgid ""
"This defines the size of the user stack to dump if B<PERF_SAMPLE_STACK_USER> "
"is specified."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1002
#, no-wrap
msgid "Reading results"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1012
msgid ""
"Once a B<perf_event_open>()  file descriptor has been opened, the values of "
"the events can be read from the file descriptor.  The values that are there "
"are specified by the I<read_format> field in the I<attr> structure at open "
"time."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1017
msgid ""
"If you attempt to read into a buffer that is not big enough to hold the data "
"B<ENOSPC> is returned"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1019
msgid "Here is the layout of the data returned by a read:"
msgstr ""

#. type: IP
#: build/C/man2/perf_event_open.2:1019 build/C/man2/perf_event_open.2:1037
#: build/C/man2/ptrace.2:1553 build/C/man2/ptrace.2:1563
#: build/C/man2/ptrace.2:1571 build/C/man2/ptrace.2:1577
#: build/C/man2/ptrace.2:1706
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1023
msgid ""
"If B<PERF_FORMAT_GROUP> was specified to allow reading all events in a group "
"at once:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1035
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 nr;            /* The number of events */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    struct\n"
"        u64 value;     /* The value of the event */\n"
"        u64 id;        /* if PERF_FORMAT_ID */\n"
"    } values[nr];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1043
msgid "If B<PERF_FORMAT_GROUP> was I<not> specified:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1052
#, no-wrap
msgid ""
"struct read_format {\n"
"    u64 value;         /* The value of the event */\n"
"    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */\n"
"    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */\n"
"    u64 id;            /* if PERF_FORMAT_ID */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1056
msgid "The values read are as follows:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1056
#, no-wrap
msgid "I<nr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1062
msgid ""
"The number of events in this file descriptor.  Only available if "
"B<PERF_FORMAT_GROUP> was specified."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1062
#, no-wrap
msgid "I<time_enabled>, I<time_running>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1074
msgid ""
"Total time the event was enabled and running.  Normally these are the same.  "
"If more events are started than available counter slots on the PMU, then "
"multiplexing happens and events run only part of the time.  In that case the "
"I<time_enabled> and I<time running> values can be used to scale an estimated "
"value for the count."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1074
#, no-wrap
msgid "I<value>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1077
msgid "An unsigned 64-bit value containing the counter result."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1077 build/C/man2/perf_event_open.2:1341
#: build/C/man2/perf_event_open.2:1478
#, no-wrap
msgid "I<id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1083
msgid ""
"A globally unique value for this particular event, only there if "
"B<PERF_FORMAT_ID> was specified in I<read_format>."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1083
#, no-wrap
msgid "MMAP layout"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1093
msgid ""
"When using B<perf_event_open>()  in sampled mode, asynchronous events (like "
"counter overflow or B<PROT_EXEC> mmap tracking)  are logged into a ring-"
"buffer.  This ring-buffer is created and accessed through B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1099
msgid ""
"The mmap size should be 1+2^n pages, where the first page is a metadata page "
"(I<struct perf_event_mmap_page>)  that contains various bits of information "
"such as where the ring-buffer head is."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1102
msgid ""
"Before kernel 2.6.39, there is a bug that means you must allocate a mmap "
"ring buffer when sampling even if you do not plan to access it."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1104
msgid "The structure of the first metadata mmap page is as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1128
#, no-wrap
msgid ""
"struct perf_event_mmap_page {\n"
"    __u32 version;          /* version number of this structure */\n"
"    __u32 compat_version;   /* lowest version this is compat with */\n"
"    __u32 lock;             /* seqlock for synchronization */\n"
"    __u32 index;            /* hardware counter identifier */\n"
"    __s64 offset;           /* add to hardware counter value */\n"
"    __u64 time_enabled;     /* time event active */\n"
"    __u64 time_running;     /* time event on CPU */\n"
"    union {\n"
"        __u64   capabilities;\n"
"        __u64   cap_usr_time  : 1,\n"
"                cap_usr_rdpmc : 1,\n"
"    };\n"
"    __u16   pmc_width;\n"
"    __u16   time_shift;\n"
"    __u32   time_mult;\n"
"    __u64   time_offset;\n"
"    __u64   __reserved[120];   /* Pad to 1k */\n"
"    __u64   data_head;         /* head in the data section */\n"
"    __u64   data_tail;         /* user-space written tail */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1134
msgid ""
"The following looks at the fields in the I<perf_event_mmap_page> structure "
"in more detail:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1134
#, no-wrap
msgid "I<version>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1137
msgid "Version number of this structure."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1137
#, no-wrap
msgid "I<compat_version>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1140
msgid "The lowest version this is compatible with."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1140
#, no-wrap
msgid "I<lock>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1143
msgid "A seqlock for synchronization."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1143
#, no-wrap
msgid "I<index>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1146
msgid "A unique hardware counter identifier."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1146
#, no-wrap
msgid "I<offset>"
msgstr ""

#.  FIXME clarify
#. type: Plain text
#: build/C/man2/perf_event_open.2:1150
msgid "Add this to hardware counter value??"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1150
#, no-wrap
msgid "I<time_enabled>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1153
msgid "Time the event was active."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1153
#, no-wrap
msgid "I<time_running>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1156
msgid "Time the event was running."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1156
#, no-wrap
msgid "I<cap_usr_time>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1159
msgid "User time capability"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1159
#, no-wrap
msgid "I<cap_usr_rdpmc>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1164
msgid ""
"If the hardware supports user-space read of performance counters without "
"syscall (this is the \"rdpmc\" instruction on x86), then the following code "
"can be used to do a read:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1171
#, no-wrap
msgid ""
"u32 seq, time_mult, time_shift, idx, width;\n"
"u64 count, enabled, running;\n"
"u64 cyc, time_offset;\n"
"s64 pmc = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1177
#, no-wrap
msgid ""
"do {\n"
"    seq = pc-E<gt>lock;\n"
"    barrier();\n"
"    enabled = pc-E<gt>time_enabled;\n"
"    running = pc-E<gt>time_running;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1184
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_time && enabled != running) {\n"
"        cyc = rdtsc();\n"
"        time_offset = pc-E<gt>time_offset;\n"
"        time_mult   = pc-E<gt>time_mult;\n"
"        time_shift  = pc-E<gt>time_shift;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1187
#, no-wrap
msgid ""
"    idx = pc-E<gt>index;\n"
"    count = pc-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1192
#, no-wrap
msgid ""
"    if (pc-E<gt>cap_usr_rdpmc && idx) {\n"
"        width = pc-E<gt>pmc_width;\n"
"        pmc = rdpmc(idx - 1);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1195
#, no-wrap
msgid ""
"    barrier();\n"
"} while (pc-E<gt>lock != seq);\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1197
#, no-wrap
msgid "I<pmc_width>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1204
msgid ""
"If I<cap_usr_rdpmc>, this field provides the bit-width of the value read "
"using the rdpmc or equivalent instruction.  This can be used to sign extend "
"the result like:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1210
#, no-wrap
msgid ""
"pmc E<lt>E<lt>= 64 - pmc_width;\n"
"pmc E<gt>E<gt>= 64 - pmc_width; // signed shift right\n"
"count += pmc;\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1212
#, no-wrap
msgid "I<time_shift>, I<time_mult>, I<time_offset>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1219
msgid ""
"If I<cap_usr_time>, these fields can be used to compute the time delta since "
"time_enabled (in nanoseconds) using rdtsc or similar."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1227
#, no-wrap
msgid ""
"    u64 quot, rem;\n"
"    u64 delta;\n"
"    quot = (cyc E<gt>E<gt> time_shift);\n"
"    rem = cyc & ((1 E<lt>E<lt> time_shift) - 1);\n"
"    delta = time_offset + quot * time_mult +\n"
"            ((rem * time_mult) E<gt>E<gt> time_shift);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1239
msgid ""
"Where I<time_offset>, I<time_mult>, I<time_shift>, and I<cyc> are read in "
"the seqcount loop described above.  This delta can then be added to enabled "
"and possible running (if idx), improving the scaling:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1247
#, no-wrap
msgid ""
"    enabled += delta;\n"
"    if (idx)\n"
"        running += delta;\n"
"    quot = count / running;\n"
"    rem  = count % running;\n"
"    count = quot * enabled + (rem * enabled) / running;\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1248
#, no-wrap
msgid "I<data_head>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1254
msgid ""
"This points to the head of the data section.  The value continuously "
"increases, it does not wrap.  The value needs to be manually wrapped by the "
"size of the mmap buffer before accessing the samples."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1257
msgid ""
"On SMP-capable platforms, after reading the data_head value, user space "
"should issue an rmb()."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1257
#, no-wrap
msgid "I<data_tail;>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1265
msgid ""
"When the mapping is B<PROT_WRITE>, the I<data_tail> value should be written "
"by user space to reflect the last read data.  In this case the kernel will "
"not over-write unread data."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1267
msgid "The following 2^n ring-buffer pages have the layout described below."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1281
msgid ""
"If I<perf_event_attr.sample_id_all> is set, then all event types will have "
"the sample_type selected fields related to where/when (identity)  an event "
"took place (TID, TIME, ID, CPU, STREAM_ID) described in "
"B<PERF_RECORD_SAMPLE> below, it will be stashed just after the "
"I<perf_event_header> and the fields already present for the existing fields, "
"i.e., at the end of the payload.  That way a newer perf.data file will be "
"supported by older perf tools, with these new optional fields being ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1283
msgid "The mmap values start with a header:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1291
#, no-wrap
msgid ""
"struct perf_event_header {\n"
"    __u32   type;\n"
"    __u16   misc;\n"
"    __u16   size;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1297
msgid "Below, we describe the I<perf_event_header> fields in more detail."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1306
msgid ""
"The I<type> value is one of the below.  The values in the corresponding "
"record (that follows the header)  depend on the I<type> selected as shown."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1307
#, no-wrap
msgid "B<PERF_RECORD_MMAP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1314
msgid ""
"The MMAP events record the B<PROT_EXEC> mappings so that we can correlate "
"user-space IPs to code.  They have the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1325
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32    pid, tid;\n"
"    u64    addr;\n"
"    u64    len;\n"
"    u64    pgoff;\n"
"    char   filename[];\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1327
#, no-wrap
msgid "B<PERF_RECORD_LOST>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1330
msgid "This record indicates when events are lost."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1338
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64 id;\n"
"    u64 lost;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1344
msgid "is the unique event ID for the samples that were lost."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1344
#, no-wrap
msgid "I<lost>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1347
#, fuzzy
#| msgid "Returns the number of processes woken up."
msgid "is the number of events that were lost."
msgstr "wake したプロセスの数を返す。"

#. type: TP
#: build/C/man2/perf_event_open.2:1348
#, no-wrap
msgid "B<PERF_RECORD_COMM>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1351
msgid "This record indicates a change in the process name."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1359
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, tid;\n"
"    char comm[];\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1361
#, no-wrap
msgid "B<PERF_RECORD_EXIT>"
msgstr "B<PERF_RECORD_EXIT>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1364
msgid "This record indicates a process exit event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1373 build/C/man2/perf_event_open.2:1401
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, ppid;\n"
"    u32 tid, ptid;\n"
"    u64 time;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1375
#, no-wrap
msgid "B<PERF_RECORD_THROTTLE>, B<PERF_RECORD_UNTHROTTLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1378
msgid "This record indicates a throttle/unthrottle event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1387
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64 time;\n"
"    u64 id;\n"
"    u64 stream_id;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1389
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_FORK>"
msgid "B<PERF_RECORD_FORK>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1392
msgid "This record indicates a fork event."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1403
#, no-wrap
msgid "B<PERF_RECORD_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1406
msgid "This record indicates a read event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1414
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u32 pid, tid;\n"
"    struct read_format values;\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1416
#, no-wrap
msgid "B<PERF_RECORD_SAMPLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1419
msgid "This record indicates a sample."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1449
#, no-wrap
msgid ""
"struct {\n"
"    struct perf_event_header header;\n"
"    u64   ip;         /* if PERF_SAMPLE_IP */\n"
"    u32   pid, tid;   /* if PERF_SAMPLE_TID */\n"
"    u64   time;       /* if PERF_SAMPLE_TIME */\n"
"    u64   addr;       /* if PERF_SAMPLE_ADDR */\n"
"    u64   id;         /* if PERF_SAMPLE_ID */\n"
"    u64   stream_id;  /* if PERF_SAMPLE_STREAM_ID */\n"
"    u32   cpu, res;   /* if PERF_SAMPLE_CPU */\n"
"    u64   period;     /* if PERF_SAMPLE_PERIOD */\n"
"    struct read_format v; /* if PERF_SAMPLE_READ */\n"
"    u64   nr;         /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u64   ips[nr];    /* if PERF_SAMPLE_CALLCHAIN */\n"
"    u32   size;       /* if PERF_SAMPLE_RAW */\n"
"    char  data[size]; /* if PERF_SAMPLE_RAW */\n"
"    u64   bnr;        /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    struct perf_branch_entry lbr[bnr];\n"
"                      /* if PERF_SAMPLE_BRANCH_STACK */\n"
"    u64   abi;        /* if PERF_SAMPLE_REGS_USER */\n"
"    u64   regs[weight(mask)];\n"
"                      /* if PERF_SAMPLE_REGS_USER */\n"
"    u64   size;       /* if PERF_SAMPLE_STACK_USER */\n"
"    char  data[size]; /* if PERF_SAMPLE_STACK_USER */\n"
"    u64   dyn_size;   /* if PERF_SAMPLE_STACK_USER */\n"
"    u64   weight;     /* if PERF_SAMPLE_WEIGHT */\n"
"    u64   data_src;   /* if PERF_SAMPLE_DATA_SRC */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1451
#, no-wrap
msgid "I<ip>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1457
msgid ""
"If B<PERF_SAMPLE_IP> is enabled, then a 64-bit instruction pointer value is "
"included."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1457
#, no-wrap
msgid "I<pid>, I<tid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1463
msgid ""
"If B<PERF_SAMPLE_TID> is enabled, then a 32-bit process ID and 32-bit thread "
"ID are included."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1463
#, no-wrap
msgid "I<time>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1471
msgid ""
"If B<PERF_SAMPLE_TIME> is enabled, then a 64-bit timestamp is included.  "
"This is obtained via local_clock() which is a hardware timestamp if "
"available and the jiffies value if not."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1471
#, no-wrap
msgid "I<addr>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1478
msgid ""
"If B<PERF_SAMPLE_ADDR> is enabled, then a 64-bit address is included.  This "
"is usually the address of a tracepoint, breakpoint, or software event; "
"otherwise the value is 0."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1486
msgid ""
"If B<PERF_SAMPLE_ID> is enabled, a 64-bit unique ID is included.  If the "
"event is a member of an event group, the group leader ID is returned.  This "
"ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1486
#, no-wrap
msgid "I<stream_id>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1496
msgid ""
"If B<PERF_SAMPLE_STREAM_ID> is enabled, a 64-bit unique ID is included.  "
"Unlike B<PERF_SAMPLE_ID> the actual ID is returned, not the group leader.  "
"This ID is the same as the one returned by B<PERF_FORMAT_ID>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1496
#, no-wrap
msgid "I<cpu>, I<res>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1503
msgid ""
"If B<PERF_SAMPLE_CPU> is enabled, this is a 32-bit value indicating which "
"CPU was being used, in addition to a reserved (unused)  32-bit value."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1503
#, no-wrap
msgid "I<period>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1509
msgid ""
"If B<PERF_SAMPLE_PERIOD> is enabled, a 64-bit value indicating the current "
"sampling period is written."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1509
#, no-wrap
msgid "I<v>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1520
msgid ""
"If B<PERF_SAMPLE_READ> is enabled, a structure of type read_format is "
"included which has values for all events in the event group.  The values "
"included depend on the I<read_format> value used at B<perf_event_open>()  "
"time."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1520
#, no-wrap
msgid "I<nr>, I<ips[nr]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1528
msgid ""
"If B<PERF_SAMPLE_CALLCHAIN> is enabled, then a 64-bit number is included "
"which indicates how many following 64-bit instruction pointers will follow.  "
"This is the current callchain."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1528
#, no-wrap
msgid "I<size>, I<data[size]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1535
msgid ""
"If B<PERF_SAMPLE_RAW> is enabled, then a 32-bit value indicating size is "
"included followed by an array of 8-bit values of length size.  The values "
"are padded with 0 to have 64-bit alignment."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1540
msgid ""
"This RAW record data is opaque with respect to the ABI.  The ABI doesn't "
"make any promises with respect to the stability of its content, it may vary "
"depending on event, hardware, and kernel version."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1540
#, no-wrap
msgid "I<bnr>, I<lbr[bnr]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1551
msgid ""
"If B<PERF_SAMPLE_BRANCH_STACK> is enabled, then a 64-bit value indicating "
"the number of records is included, followed by I<bnr> I<perf_branch_entry> "
"structures.  These structures have from, to, and flags values indicating the "
"from and to addresses from the branches on the callstack."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1551
#, no-wrap
msgid "I<abi>, I<regs[weight(mask)]>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1556
msgid ""
"If B<PERF_SAMPLE_REGS_USER> is enabled, then the user CPU registers are "
"recorded."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1562
msgid ""
"The I<abi> field is one of B<PERF_SAMPLE_REGS_ABI_NONE>, "
"B<PERF_SAMPLE_REGS_ABI_32> or B<PERF_SAMPLE_REGS_ABI_64>."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1572
msgid ""
"The I<regs> field is an array of the CPU registers that were specified by "
"the I<sample_regs_user> attr field.  The number of values is the number of "
"bits set in the I<sample_regs_user> bitmask."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1572
#, no-wrap
msgid "I<size>, I<data[size]>, I<dyn_size>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1587
msgid ""
"If B<PERF_SAMPLE_STACK_USER> is enabled, then record the user stack to "
"enable backtracing.  I<size> is the size requested by the user in "
"I<stack_user_size> or else the maximum record size.  I<data> is the stack "
"data.  I<dyn_size> is the amount of data actually dumped (can be less than "
"I<size> )."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1587
#, no-wrap
msgid "I<weight>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1595
msgid ""
"If B<PERF_SAMPLE_WEIGHT> is enabled, then a 64 bit value provided by the "
"hardwre is recorded that indicates how costly the event was.  This allows "
"expensive events to stand out more clearly in profiles."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1595
#, no-wrap
msgid "I<data_src>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1601
msgid ""
"If B<PERF_SAMPLE_DATA_SRC> is enabled, then a 64 bit value is recorded that "
"is made up of the following fields:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1602
#, no-wrap
msgid "I<mem_op>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1615
msgid ""
"type of opcode, a bitwise combination of B<PERF_MEM_OP_NA> (not available), "
"B<PERF_MEM_OP_LOAD> (load instruction), B<PERF_MEM_OP_STORE> (store "
"instruction), B<PERF_MEM_OP_PFETCH> (prefetch), and B<PERF_MEM_OP_EXEC> "
"(executable code)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1615
#, no-wrap
msgid "I<mem_lvl>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1646
msgid ""
"memory hierarchy level hit or miss, a bitwise combination of "
"B<PERF_MEM_LVL_NA> (not available), B<PERF_MEM_LVL_HIT> (hit), "
"B<PERF_MEM_LVL_MISS> (miss), B<PERF_MEM_LVL_L1> (level 1 cache), "
"B<PERF_MEM_LVL_LFB> (line fill buffer), B<PERF_MEM_LVL_L2> (level 2 cache), "
"B<PERF_MEM_LVL_L3> (level 3 cache), B<PERF_MEM_LVL_LOC_RAM> (local DRAM), "
"B<PERF_MEM_LVL_REM_RAM1> (remote DRAM 1 hop), B<PERF_MEM_LVL_REM_RAM2> "
"(remote DRAM 2 hops), B<PERF_MEM_LVL_REM_CCE1> (remote cache 1 hop), "
"B<PERF_MEM_LVL_REM_CCE2> (remote Cache 2 hops), B<PERF_MEM_LVL_IO> (I/O "
"memory), and B<PERF_MEM_LVL_UNC> (uncached memory)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1646
#, no-wrap
msgid "I<mem_snoop>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1659
msgid ""
"snoop mode, a bitwise combination of B<PERF_MEM_SNOOP_NA> (not available), "
"B<PERF_MEM_SNOOP_NONE> (no snoop), B<PERF_MEM_SNOOP_HIT> (snoop hit), "
"B<PERF_MEM_SNOOP_MISS> (snoop miss), and B<PERF_MEM_SNOOP_HITM> (snoop hit "
"modified)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1659
#, no-wrap
msgid "I<mem_lock>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1666
msgid ""
"lock instruction, a bitwise combination of B<PERF_MEM_LOCK_NA> (not "
"available) and B<PERF_MEM_LOCK_LOCKED> (locked transaction)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1666
#, no-wrap
msgid "I<mem_dtlb>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1683
msgid ""
"tlb access hit or miss, a bitwise combination of B<PERF_MEM_TLB_NA> (not "
"available), B<PERF_MEM_TLB_HIT> (hit), B<PERF_MEM_TLB_MISS> (miss), "
"B<PERF_MEM_TLB_L1> (level 1 TLB), B<PERF_MEM_TLB_L2> (level 2 TLB), "
"B<PERF_MEM_TLB_WK> (hardware walker), and B<PERF_MEM_TLB_OS> (OS fault "
"handler)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1686
#, no-wrap
msgid "I<misc>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1691
msgid "The I<misc> field contains additional information about the sample."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1696
msgid ""
"The CPU mode can be determined from this value by masking with "
"B<PERF_RECORD_MISC_CPUMODE_MASK> and looking for one of the following (note "
"these are not bit masks, only one can be set at a time):"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1697
#, no-wrap
msgid "B<PERF_RECORD_MISC_CPUMODE_UNKNOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1700
msgid "Unknown CPU mode."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1700
#, no-wrap
msgid "B<PERF_RECORD_MISC_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1703
msgid "Sample happened in the kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1703
#, no-wrap
msgid "B<PERF_RECORD_MISC_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1706
msgid "Sample happened in user code."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1706
#, no-wrap
msgid "B<PERF_RECORD_MISC_HYPERVISOR>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1709
msgid "Sample happened in the hypervisor."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1709
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_KERNEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1712
msgid "Sample happened in the guest kernel."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1712
#, no-wrap
msgid "B<PERF_RECORD_MISC_GUEST_USER>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1715
msgid "Sample happened in guest user code."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1718
msgid "In addition, one of the following bits can be set:"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1719
#, fuzzy, no-wrap
#| msgid "B<PERF_RECORD_EXIT>"
msgid "B<PERF_RECORD_MISC_MMAP_DATA>"
msgstr "B<PERF_RECORD_EXIT>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1723
msgid ""
"This is set when the mapping is not executable; otherwise the mapping is "
"executable."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1723
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXACT_IP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1731
msgid ""
"This indicates that the content of B<PERF_SAMPLE_IP> points to the actual "
"instruction that triggered the event.  See also I<perf_event_attr."
"precise_ip>."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1731
#, no-wrap
msgid "B<PERF_RECORD_MISC_EXT_RESERVED>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1734
msgid "This indicates there is extended data available (currently not used)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1737
msgid "This indicates the size of the record."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1738
#, no-wrap
msgid "Signal overflow"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1747
msgid ""
"Events can be set to deliver a signal when a threshold is crossed.  The "
"signal handler is set up using the B<poll>(2), B<select>(2), B<epoll>(2)  "
"and B<fcntl>(2), system calls."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1751
msgid ""
"To generate signals, sampling must be enabled (I<sample_period> must have a "
"non-zero value)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1753
msgid "There are two ways to generate signals."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1763
msgid ""
"The first is to set a I<wakeup_events> or I<wakeup_watermark> value that "
"will generate a signal if a certain number of samples or bytes have been "
"written to the mmap ring buffer.  In this case a signal of type B<POLL_IN> "
"is sent."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1775
msgid ""
"The other way is by use of the B<PERF_EVENT_IOC_REFRESH> ioctl.  This ioctl "
"adds to a counter that decrements each time the event overflows.  When non-"
"zero, a B<POLL_IN> signal is sent on overflow, but once the value reaches 0, "
"a signal is sent of type B<POLL_HUP> and the underlying event is disabled."
msgstr ""

#.  FIXME(Vince) : Find out when this was introduced
#. type: Plain text
#: build/C/man2/perf_event_open.2:1781
msgid ""
"Note: on newer kernels (definitely noticed with 3.2)  a signal is provided "
"for every overflow, even if I<wakeup_events> is not set."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1781
#, no-wrap
msgid "rdpmc instruction"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1788
msgid ""
"Starting with Linux 3.4 on x86, you can use the I<rdpmc> instruction to get "
"low-latency reads without having to enter the kernel.  Note that using "
"I<rdpmc> is not necessarily faster than other methods for reading event "
"values."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1793
msgid ""
"Support for this can be detected with the I<cap_usr_rdpmc> field in the mmap "
"page; documentation on how to calculate event values can be found in that "
"section."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1793
#, no-wrap
msgid "perf_event ioctl calls"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1798
msgid "Various ioctls act on B<perf_event_open>()  file descriptors"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1798
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_CLONE>"
msgid "B<PERF_EVENT_IOC_ENABLE>"
msgstr "B<PTRACE_EVENT_CLONE>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1802
msgid ""
"Enables the individual event or event group specified by the file descriptor "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1807
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are enabled, even if the event specified is not the group "
"leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1807
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_CLONE>"
msgid "B<PERF_EVENT_IOC_DISABLE>"
msgstr "B<PTRACE_EVENT_CLONE>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1811
msgid ""
"Disables the individual counter or event group specified by the file "
"descriptor argument."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1818
msgid ""
"Enabling or disabling the leader of a group enables or disables the entire "
"group; that is, while the group leader is disabled, none of the counters in "
"the group will count.  Enabling or disabling a member of a group other than "
"the leader affects only that counter; disabling a non-leader stops that "
"counter from counting but doesn't affect any other counter."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1823
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are disabled, even if the event specified is not the group "
"leader."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1823
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_FORK>"
msgid "B<PERF_EVENT_IOC_REFRESH>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1837
msgid ""
"Non-inherited overflow counters can use this to enable a counter for a "
"number of overflows specified by the argument, after which it is disabled.  "
"Subsequent calls of this ioctl add the argument value to the current count.  "
"A signal with B<POLL_IN> set will happen on each overflow until the count "
"reaches 0; when that happens a signal with POLL_HUP set is sent and the "
"event is disabled.  Using an argument of 0 is considered undefined behavior."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1837
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_FORK>"
msgid "B<PERF_EVENT_IOC_RESET>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1847
msgid ""
"Reset the event count specified by the file descriptor argumentto zero.  "
"This resets only the counts; there is no way to reset the multiplexing "
"I<time_enabled> or I<time_running> values."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1852
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is set in the ioctl argument, then all "
"events in a group are reset, even if the event specified is not the group "
"leader."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1859
msgid ""
"If the B<PERF_IOC_FLAG_GROUP> bit is not set, then the behavior is somwhat "
"unexpected: when sent to a group leader only the leader is reset (children "
"are left alone); when sent to a child all events in a group are reset."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1859
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_FORK>"
msgid "B<PERF_EVENT_IOC_PERIOD>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1863
msgid ""
"IOC_PERIOD is the command to update the period; it does not update the "
"current period but instead defers until next."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1866
msgid ""
"The argument is a pointer to a 64-bit value containing the desired new "
"period."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1866
#, no-wrap
msgid "B<PERF_EVENT_IOC_SET_OUTPUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1871
msgid ""
"This tells the kernel to report event notifications to the specified file "
"descriptor rather than the default one.  The file descriptors must all be on "
"the same CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1874
msgid ""
"The argument specifies the desired file descriptor, or -1 if output should "
"be ignored."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1874
#, fuzzy, no-wrap
#| msgid "B<KEXEC_ON_CRASH> (since Linux 2.6.13)"
msgid "B<PERF_EVENT_IOC_SET_FILTER> (Since Linux 2.6.33)"
msgstr "B<KEXEC_ON_CRASH> (Linux 2.6.13 以降)"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1877
msgid "This adds an ftrace filter to this event."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1879
msgid "The argument is a pointer to the desired ftrace filter."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1879
#, no-wrap
msgid "Using prctl"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1892
msgid ""
"A process can enable or disable all the event groups that are attached to it "
"using the B<prctl>(2)  B<PR_TASK_PERF_EVENTS_ENABLE> and "
"B<PR_TASK_PERF_EVENTS_DISABLE> operations.  This applies to all counters on "
"the current process, whether created by this process or by another, and does "
"not affect any counters that this process has created on other processes.  "
"It enables or disables only the group leaders, not any other members in the "
"groups."
msgstr ""

#. type: SS
#: build/C/man2/perf_event_open.2:1892
#, no-wrap
msgid "perf_event related configuration files"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1895
msgid "Files in I</proc/sys/kernel/>"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1896
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_paranoid>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1902
msgid ""
"The I<perf_event_paranoid> file can be set to restrict access to the "
"performance counters."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1904
msgid "2 - only allow user-space measurements"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1906
msgid "1 - (default) allow both kernel and user measurements"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1908
msgid "0 - allow access to CPU-specific data but not raw tracepoint samples"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1910
msgid "-1 - no restrictions"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1915
msgid ""
"The existence of the I<perf_event_paranoid> file is the official method for "
"determining if a kernel supports B<perf_event_open>()."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1915
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_max_sample_rate>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1924
msgid ""
"This sets the maximum sample rate.  Setting this too high can allow users to "
"sample at a rate that impacts overall machine performance and potentially "
"lock up the machine.  The default value is 100000 (samples per second)."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1924
#, no-wrap
msgid "I</proc/sys/kernel/perf_event_mlock_kb>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1929
msgid ""
"Maximum number of pages an unprivileged user can mlock (2) .  The default is "
"516 (kB)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1932
msgid "Files in I</sys/bus/event_source/devices/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1938
msgid ""
"Since Linux 2.6.34 the kernel supports having multiple PMUs available for "
"monitoring.  Information on how to program these PMUs can be found under I</"
"sys/bus/event_source/devices/>.  Each subdirectory corresponds to a "
"different PMU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1938
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/type>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1943
msgid ""
"This contains an integer that can be used in the I<type> field of "
"perf_event_attr to indicate you wish to use this PMU."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1943
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/rdpmc>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1946 build/C/man2/perf_event_open.2:1963
msgid "[To be documented]"
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1946
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/format/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1951
msgid ""
"This sub-directory contains information on what bits in the I<config> field "
"of perf_event_attr correspond to."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1951
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/events/>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1960
msgid ""
"This sub-directory contains files with pre-defined events.  The contents are "
"strings describing the event settings expressed in terms of the fields found "
"in the I<./format/> directory.  These are not necessarily complete lists of "
"all events supported by a PMU, but usually a subset of events deemed useful "
"or interesting."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1960
#, no-wrap
msgid "I</sys/bus/event_source/devices/*/uevent>"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1970
msgid ""
"B<perf_event_open>()  returns the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1974
msgid "Returned if the specified event is not available."
msgstr ""

#. type: TP
#: build/C/man2/perf_event_open.2:1974
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1984
msgid ""
"Prior to Linux 3.3, if there was not enough room for the event, B<ENOSPC> "
"was returned.  Linus did not like this, and this was changed to B<EINVAL>.  "
"B<ENOSPC> is still returned if you try to read results into too small of a "
"buffer."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:1984
#, no-wrap
msgid "VERSION"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1989
msgid ""
"B<perf_event_open>()  was introduced in Linux 2.6.31 but was called "
"B<perf_counter_open>()B<.> It was renamed in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:1994
#, fuzzy
#| msgid ""
#| "B<personality>()  is Linux-specific and should not be used in programs "
#| "intended to be portable."
msgid ""
"This B<perf_event_open>()  system call Linux- specific and should not be "
"used in programs intended to be portable."
msgstr ""
"B<personality>()  は Linux 固有であり、移植を意図したプログラムで使用すべきで"
"はない。"

#. type: Plain text
#: build/C/man2/perf_event_open.2:1998
#, fuzzy
#| msgid ""
#| "Glibc does not provide a wrapper for this system call; call it using "
#| "B<syscall>(2)."
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  See the example below."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/perf_event_open.2:2004
msgid ""
"The official way of knowing if B<perf_event_open>()  support is enabled is "
"checking for the existence of the file I</proc/sys/kernel/"
"perf_event_paranoid>."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:2004 build/C/man2/pivot_root.2:134
#: build/C/man2/ptrace.2:1811
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/perf_event_open.2:2011
msgid ""
"The B<F_SETOWN_EX> option to B<fcntl>(2)  is needed to properly get overflow "
"signals in threads.  This was introduced in Linux 2.6.32."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2019
msgid ""
"Prior to Linux 2.6.33 (at least for x86) the kernel did not check if events "
"could be scheduled together until read time.  The same happens on all known "
"kernels if the NMI watchdog is enabled.  This means to see if a given set of "
"events works you have to B<perf_event_open>(), start, then read before you "
"know for sure you can get valid measurements."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2023
msgid ""
"Prior to Linux 2.6.34 event constraints were not enforced by the kernel.  In "
"that case, some events would silently return \"0\" if the kernel scheduled "
"them in an improper counter slot."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2026
msgid ""
"Prior to Linux 2.6.34 there was a bug when multiplexing where the wrong "
"results could be returned."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2029
msgid ""
"Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the kernel if "
"\"inherit\" is enabled and many threads are started."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2033
msgid ""
"Prior to Linux 2.6.35, B<PERF_FORMAT_GROUP> did not work with attached "
"processes."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2038
msgid ""
"In older Linux 2.6 versions, refreshing an event group leader refreshed all "
"siblings, and refreshing with a parameter of 0 enabled infinite refresh.  "
"This behavior is unsupported and should not be relied on."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2044
msgid ""
"There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0 that "
"ignores the \"watermark\" field and acts as if a wakeup_event was chosen if "
"the union has a non-zero value in it."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2049
msgid ""
"Always double-check your results! Various generalized events have had wrong "
"values.  For example, retired branches measured the wrong thing on AMD "
"machines until Linux 2.6.35."
msgstr ""

#. type: SH
#: build/C/man2/perf_event_open.2:2049 build/C/man2/process_vm_readv.2:295
#: build/C/man2/splice.2:223 build/C/man2/tee.2:130
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man2/perf_event_open.2:2053
msgid ""
"The following is a short example that measures the total instruction count "
"of a call to B<printf>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2062
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/ioctl.hE<gt>\n"
"#include E<lt>linux/perf_event.hE<gt>\n"
"#include E<lt>asm/unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/perf_event_open.2:2068
#, no-wrap
msgid ""
"long\n"
"perf_event_open(struct perf_event_attr *hw_event, pid_t pid,\n"
"                int cpu, int group_fd, unsigned long flags)\n"
"{\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2073
#, no-wrap
msgid ""
"    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,\n"
"                   group_fd, flags);\n"
"    return ret;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2080
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"
msgstr ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    struct perf_event_attr pe;\n"
"    long long count;\n"
"    int fd;\n"

#. type: Plain text
#: build/C/man2/perf_event_open.2:2088
#, no-wrap
msgid ""
"    memset(&pe, 0, sizeof(struct perf_event_attr));\n"
"    pe.type = PERF_TYPE_HARDWARE;\n"
"    pe.size = sizeof(struct perf_event_attr);\n"
"    pe.config = PERF_COUNT_HW_INSTRUCTIONS;\n"
"    pe.disabled = 1;\n"
"    pe.exclude_kernel = 1;\n"
"    pe.exclude_hv = 1;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2094
#, no-wrap
msgid ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = perf_event_open(&pe, 0, -1, -1, 0);\n"
"    if (fd == -1) {\n"
"       fprintf(stderr, \"Error opening leader %llx\\en\", pe.config);\n"
"       exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/perf_event_open.2:2097
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_RESET, 0);\n"
"    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2099
#, no-wrap
msgid "    printf(\"Measuring instruction count for this printf\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2102
#, no-wrap
msgid ""
"    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);\n"
"    read(fd, &count, sizeof(long long));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2104
#, no-wrap
msgid "    printf(\"Used %lld instructions\\en\", count);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2107
#, no-wrap
msgid ""
"    close(fd);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perf_event_open.2:2114
msgid "B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"
msgstr "B<fcntl>(2), B<mmap>(2), B<open>(2), B<prctl>(2), B<read>(2)"

#. type: TH
#: build/C/man2/perfmonctl.2:27
#, no-wrap
msgid "PERFMONCTL"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:30
msgid "perfmonctl - interface to IA-64 performance monitoring unit"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"
msgstr ""
"B<#include E<lt>syscall.hE<gt>>\n"
"B<#include E<lt>perfmon.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/perfmonctl.2:36
#, no-wrap
msgid "B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int >I<narg>B<);>\n"
msgstr "B<long perfmonctl(int >I<fd>B<, int >I<cmd>B<, void *>I<arg>B<, int >I<narg>B<);>\n"

#. type: Plain text
#: build/C/man2/perfmonctl.2:47
msgid ""
"The IA-64-specific B<perfmonctl>()  system call provides an interface to the "
"PMU (performance monitoring unit).  The PMU consists of PMD (performance "
"monitoring data) registers and PMC (performance monitoring control) "
"registers, which gather hardware statistics."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:57
msgid ""
"B<perfmonctl>()  applies the operation I<cmd> to the input arguments "
"specified by I<arg>.  The number of arguments is defined by I<narg>.  The "
"I<fd> argument specifies the perfmon context to operate on."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:61
msgid "Supported values for I<cmd> are:"
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:61
#, no-wrap
msgid "B<PFM_CREATE_CONTEXT>"
msgstr "B<PFM_CREATE_CONTEXT>"

#. type: Plain text
#: build/C/man2/perfmonctl.2:65
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_CREATE_CONTEXT, pfarg_context_t *>I<ctxt>B<, 1);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:67
msgid "Set up a context."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:74
msgid ""
"The I<fd> parameter is ignored.  A new perfmon context is created as "
"specified in I<ctxt> and its file descriptor is returned in I<ctxt-"
"E<gt>ctx_fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:86
msgid ""
"The file descriptor can be used in subsequent calls to B<perfmonctl>()  and "
"can be used to read event notifications (type I<pfm_msg_t>)  using B<read>"
"(2).  The file descriptor is pollable using B<select>(2), B<poll>(2), and "
"B<epoll>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:90
msgid ""
"The context can be destroyed by calling B<close>(2)  on the file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:90
#, no-wrap
msgid "B<PFM_WRITE_PMCS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:95
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMCS, pfarg_reg_t *>I<pmcs>B<, n);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:97
msgid "Set PMC registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:97
#, no-wrap
msgid "B<PFM_WRITE_PMDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:101
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_WRITE_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#.  pfm_write_pmds()
#. type: Plain text
#: build/C/man2/perfmonctl.2:104
msgid "Set PMD registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:104
#, no-wrap
msgid "B<PFM_READ_PMDS>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:109
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_READ_PMDS, pfarg_reg_t *>I<pmds>B<, n);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:111
msgid "Read PMD registers."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:111
#, no-wrap
msgid "B<PFM_START>"
msgstr ""

#.  .BI  "perfmonctl(int " fd ", PFM_START, arg, 1);
#. type: Plain text
#: build/C/man2/perfmonctl.2:117
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_START, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:119
msgid "Start monitoring."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:119
#, no-wrap
msgid "B<PFM_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:124
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_STOP, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:126
msgid "Stop monitoring."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:126
#, no-wrap
msgid "B<PFM_LOAD_CONTEXT>"
msgstr "B<PFM_LOAD_CONTEXT>"

#. type: Plain text
#: build/C/man2/perfmonctl.2:131
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_LOAD_CONTEXT, pfarg_load_t *>I<largs>B<, 1);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:133
msgid "Attach the context to a thread."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:133
#, no-wrap
msgid "B<PFM_UNLOAD_CONTEXT>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:138
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_UNLOAD_CONTEXT, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:140
msgid "Detach the context from a thread."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:140
#, no-wrap
msgid "B<PFM_RESTART>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:145
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_RESTART, NULL, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:147
msgid "Restart monitoring after receiving an overflow notification."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:147
#, no-wrap
msgid "B<PFM_GET_FEATURES>"
msgstr "B<PFM_GET_FEATURES>"

#. type: Plain text
#: build/C/man2/perfmonctl.2:152
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_GET_FEARURES, pfarg_features_t *>I<arg>B<, 1);>\n"
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:153
#, no-wrap
msgid "B<PFM_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:158
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_DEBUG, >I<val>B<, 0);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:162
msgid "If I<val> is nonzero, enable debugging mode, otherwise disable."
msgstr ""

#. type: TP
#: build/C/man2/perfmonctl.2:162
#, no-wrap
msgid "B<PFM_GET_PMC_RESET_VAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:167
#, no-wrap
msgid "B<perfmonctl(int >I<fd>B<, PFM_GET_PMC_RESET_VAL, pfarg_reg_t * >I<req>B<, n);>\n"
msgstr ""

#
#
#
#.  .TP
#.  .B PFM_CREATE_EVTSETS
#.  create or modify event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_CREATE_EVTSETS, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_DELETE_EVTSETS
#.  delete event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_DELETE_EVTSET, pfarg_setdesc_t *desc , n);
#.  .fi
#.  .TP
#.  .B PFM_GETINFO_EVTSETS
#.  get information about event sets
#.  .nf
#.  .BI  "perfmonctl(int " fd ", PFM_GETINFO_EVTSETS, pfarg_setinfo_t *info, n);
#.  .fi
#. type: Plain text
#: build/C/man2/perfmonctl.2:190
msgid "Reset PMC registers to default values."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:196
#, fuzzy
#| msgid ""
#| "On success, B<kexec_load>()  returns 0.  On error, -1 is returned and "
#| "I<errno> is set to indicate the error."
msgid ""
"B<performctl>()  returns zero when the operation is successful.  On error, "
"-1 is returned and I<errno> is set to indicate the cause of the error."
msgstr ""
"成功すると、 B<kexec_load> は 0 を返す。\n"
"エラーの場合、 -1 が返り、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/perfmonctl.2:199
#, fuzzy
#| msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgid "B<perfmonctl>()  is available since Linux 2.4."
msgstr "B<pivot_root>()  は Linux 2.3.41 で導入された。"

#. type: Plain text
#: build/C/man2/perfmonctl.2:202
msgid ""
"B<perfmonctl>()  is Linux specific and is available only on the IA-64 "
"architecture."
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:207
msgid "B<gprof>(1)"
msgstr ""

#. type: Plain text
#: build/C/man2/perfmonctl.2:209
msgid "The perfmon2 interface specification"
msgstr ""

#. type: TH
#: build/C/man2/personality.2:32
#, no-wrap
msgid "PERSONALITY"
msgstr "PERSONALITY"

#. type: TH
#: build/C/man2/personality.2:32
#, no-wrap
msgid "2003-01-01"
msgstr "2003-01-01"

#. type: Plain text
#: build/C/man2/personality.2:35
msgid "personality - set the process execution domain"
msgstr "personality - プロセスを実行するドメインを設定する"

#. type: Plain text
#: build/C/man2/personality.2:37
msgid "B<#include E<lt>sys/personality.hE<gt>>"
msgstr "B<#include E<lt>sys/personality.hE<gt>>"

#. type: Plain text
#: build/C/man2/personality.2:39
msgid "B<int personality(unsigned long >I<persona>B<);>"
msgstr "B<int personality(unsigned long >I<persona>B<);>"

#. type: Plain text
#: build/C/man2/personality.2:47
msgid ""
"Linux supports different execution domains, or personalities, for each "
"process.  Among other things, execution domains tell Linux how to map signal "
"numbers into signal actions.  The execution domain system allows Linux to "
"provide limited support for binaries compiled under other UNIX-like "
"operating systems."
msgstr ""
"Linux は、プロセス毎の異なる実行ドメイン、すなわち パーソナリティ "
"(personality) をサポートしている。 実行ドメインは Linux にシグナル番号にどの"
"シグナルを割り付けるかを 教えたりする。また、実行ドメイン・システムにより、 "
"Linux は他の UNIX 風のオペレーティング・システムでコンパイルされた バイナリに"
"対する限定的なサポートを提供している。"

#. type: Plain text
#: build/C/man2/personality.2:57
msgid ""
"This function will return the current B<personality>()  when I<persona> "
"equals 0xffffffff.  Otherwise, it will make the execution domain referenced "
"by I<persona> the new execution domain of the calling process."
msgstr ""
"B<personality ()> 関数は、 I<persona> が 0xffffffff の場合は現在の B<パーソナ"
"リティ> を返す。 それ以外の場合、 I<persona> により参照される実行ドメイン"
"を、 呼び出し元のプロセスの新しい実行ドメインとする。"

#. type: Plain text
#: build/C/man2/personality.2:64
msgid ""
"On success, the previous I<persona> is returned.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""
"成功した場合、以前の I<persona> が返される。エラーの場合は、-1 が返され、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/personality.2:68
msgid "The kernel was unable to change the personality."
msgstr "カーネルがパーソナリティを変更できなかった。"

#. type: Plain text
#: build/C/man2/personality.2:72
msgid ""
"B<personality>()  is Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"B<personality>()  は Linux 固有であり、移植を意図したプログラムで使用すべきで"
"はない。"

#. type: TH
#: build/C/man2/pivot_root.2:10
#, no-wrap
msgid "PIVOT_ROOT"
msgstr "PIVOT_ROOT"

#. type: Plain text
#: build/C/man2/pivot_root.2:13
msgid "pivot_root - change the root file system"
msgstr "pivot_root - root ファイルシステムを変更する"

#. type: Plain text
#: build/C/man2/pivot_root.2:15
msgid ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"
msgstr ""
"B<int pivot_root(const char *>I<new_root>B<, const char *>I<put_old>B<);>"

#.  The
#.  .B CAP_SYS_ADMIN
#.  capability is required.
#. type: Plain text
#: build/C/man2/pivot_root.2:27
msgid ""
"B<pivot_root>()  moves the root file system of the calling process to the "
"directory I<put_old> and makes I<new_root> the new root file system of the "
"calling process."
msgstr ""
"B<pivot_root>()  は呼び出し元のプロセスの root ファイルシステムを I<put_old> "
"ディレクトリに移動し、 I<new_root> を呼び出し元のプロセスの新しい root ファイ"
"ルシステムにする。"

#. type: Plain text
#: build/C/man2/pivot_root.2:34
msgid ""
"The typical use of B<pivot_root>()  is during system startup, when the "
"system mounts a temporary root file system (e.g., an B<initrd>), then mounts "
"the real root file system, and eventually turns the latter into the current "
"root of all relevant processes or threads."
msgstr ""
"B<pivot_root>()  の典型的な利用法は、システムの起動中にシステムが一時的な "
"root ファイルシステム (例えば B<initrd>)  をマウントし、これに続いて本当の "
"root ファイルシステムをマウントし、 後者を必要な全てのプロセス・スレッドの カ"
"レント root に変更するような場合である。"

#. type: Plain text
#: build/C/man2/pivot_root.2:46
msgid ""
"B<pivot_root>()  may or may not change the current root and the current "
"working directory of any processes or threads which use the old root "
"directory.  The caller of B<pivot_root>()  must ensure that processes with "
"root or current working directory at the old root operate correctly in "
"either case.  An easy way to ensure this is to change their root and current "
"working directory to I<new_root> before invoking B<pivot_root>()."
msgstr ""
"古い root ディレクトリを使っていた全てのプロセスやスレッドの カレント root と"
"カレントワーキングディレクトリを、 B<pivot_root>()  が変更するかどうかはわか"
"らない。 B<pivot_root>()  の呼びだしプロセスは、古い root やカレントワーキン"
"グディレクトリを使っていた プロセスが、いずれの場合でも正しく動作することを保"
"証しなければならない。 これを簡単に行うには、それらのプロセスの root と カレ"
"ントワーキングディレクトリを B<pivot_root>()  を呼び出す前に I<new_root> に変"
"更しておくことである。"

#. type: Plain text
#: build/C/man2/pivot_root.2:64
msgid ""
"The paragraph above is intentionally vague because the implementation of "
"B<pivot_root>()  may change in the future.  At the time of writing, "
"B<pivot_root>()  changes root and current working directory of each process "
"or thread to I<new_root> if they point to the old root directory.  This is "
"necessary in order to prevent kernel threads from keeping the old root "
"directory busy with their root and current working directory, even if they "
"never access the file system in any way.  In the future, there may be a "
"mechanism for kernel threads to explicitly relinquish any access to the file "
"system, such that this fairly intrusive mechanism can be removed from "
"B<pivot_root>()."
msgstr ""
"上記の段落は、将来 B<pivot_root>()  が変更されるかも知れないことを鑑みて、わ"
"ざと曖昧に書いてある。 本ページを記述している時点では、 B<pivot_root>()  は古"
"い root ディレクトリを用いている全てのプロセス・スレッドの root と カレント"
"ワーキングディレクトリを I<new_root> に変更する。これはカーネルのスレッドが古"
"い root ディレクトリを busy 状態にしないために必要である。これらのスレッドが "
"古いディレクトリを root やカレントワーキングディレクトリとしていると、 ファイ"
"ルシステムに一切アクセスしない場合でも 古い root が busy になってしまうからで"
"ある。 将来は、カーネルスレッドがあらゆるファイルシステムへのアクセスを 明示"
"的に放棄するメカニズムができ、このでしゃばりな機能は B<pivot_root>()  から削"
"除されるかもしれない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:72
msgid ""
"Note that this also applies to the calling process: B<pivot_root>()  may or "
"may not affect its current working directory.  It is therefore recommended "
"to call B<chdir(\"/\")> immediately after B<pivot_root>()."
msgstr ""
"これは呼び出し元のプロセスについても当てはまることに注意。 B<pivot_root>()  "
"がカレントプロセスのカレントワーキングディレクトリに影響するかどうかは 分から"
"ない。したがって B<pivot_root>()  の直後に B<chdir(\"/\")> を呼び出すとよい。"

#. type: Plain text
#: build/C/man2/pivot_root.2:74
msgid "The following restrictions apply to I<new_root> and I<put_old>:"
msgstr "I<new_root> および I<put_old> には以下の制限がある:"

#. type: IP
#: build/C/man2/pivot_root.2:74 build/C/man2/pivot_root.2:76
#: build/C/man2/pivot_root.2:79 build/C/man2/pivot_root.2:83
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: build/C/man2/pivot_root.2:76
msgid "They must be directories."
msgstr "ディレクトリでなければならない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:79
msgid ""
"I<new_root> and I<put_old> must not be on the same file system as the "
"current root."
msgstr ""
"I<new_root> と I<put_old> は現在の root と同じファイルシステムにあってはなら"
"ない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:83
msgid ""
"I<put_old> must be underneath I<new_root>, that is, adding a nonzero number "
"of I</..> to the string pointed to by I<put_old> must yield the same "
"directory as I<new_root>."
msgstr ""
"I<put_old> は I<new_root> 以下になければならない。すなわち I<put_old> を差す"
"文字列に 1 個以上の I<../> を付けることによって I<new_root> と同じディレクト"
"リが得られなければならない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:85
msgid "No other file system may be mounted on I<put_old>."
msgstr "他のファイルシステムが I<put_old> にマウントされていてはならない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:89
msgid "See also B<pivot_root>(8)  for additional usage examples."
msgstr "利用例については B<pivot_root>(8)  を参照のこと。"

#. type: Plain text
#: build/C/man2/pivot_root.2:96
msgid ""
"If the current root is not a mount point (e.g., after B<chroot>(2)  or "
"B<pivot_root>(), see also below), not the old root directory, but the mount "
"point of that file system is mounted on I<put_old>."
msgstr ""
"現在の root がマウントポイントではない (B<chroot>(2)  や B<pivot_root>()  の"
"後など。以下も参照) 場合、 古い root ディレクトリではなく、 そのファイルシス"
"テムのマウントポイントが I<put_old> にマウントされる。"

#. type: Plain text
#: build/C/man2/pivot_root.2:101
msgid ""
"I<new_root> does not have to be a mount point.  In this case, I</proc/"
"mounts> will show the mount point of the file system containing I<new_root> "
"as root (I</>)."
msgstr ""
"I<new_root> はマウントポイントでなくてもよい。 この場合 I</proc/mounts> は、 "
"I<new_root> を root (I</>)  とするファイルシステムのマウントポイントを表示す"
"る。"

#. type: Plain text
#: build/C/man2/pivot_root.2:110
msgid ""
"B<pivot_root>()  may return (in I<errno>) any of the errors returned by "
"B<stat>(2).  Additionally, it may return:"
msgstr ""
"B<pivot_root>()  は B<stat>(2)  の返すあらゆるエラーを (I<errno> に) 返す可能"
"性がある。さらに以下を返すことがある:"

#. type: Plain text
#: build/C/man2/pivot_root.2:114
msgid ""
"I<new_root> or I<put_old> are on the current root file system, or a file "
"system is already mounted on I<put_old>."
msgstr ""
"I<new_root> または I<put_old> が、現在の root ファイルシステム上にあるか、既"
"に I<put_old> になんらかのファイルシステムがマウントされている。"

#. type: Plain text
#: build/C/man2/pivot_root.2:117
msgid "I<put_old> is not underneath I<new_root>."
msgstr "I<put_old> が I<new_root> の下層にない。"

#. type: TP
#: build/C/man2/pivot_root.2:117
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/pivot_root.2:120
msgid "I<new_root> or I<put_old> is not a directory."
msgstr "I<new_root> または I<put_old> がディレクトリでない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:125
msgid "The calling process does not have the B<CAP_SYS_ADMIN> capability."
msgstr "呼び出し元のプロセスが B<CAP_SYS_ADMIN> ケーパビリティを持っていない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:128
msgid "B<pivot_root>()  was introduced in Linux 2.3.41."
msgstr "B<pivot_root>()  は Linux 2.3.41 で導入された。"

#. type: Plain text
#: build/C/man2/pivot_root.2:131
msgid "B<pivot_root>()  is Linux-specific and hence is not portable."
msgstr "B<pivot_root>()  は Linux に固有のものなので、移植性はない。"

#. type: Plain text
#: build/C/man2/pivot_root.2:138
msgid ""
"B<pivot_root>()  should not have to change root and current working "
"directory of all other processes in the system."
msgstr ""
"B<pivot_root>()  はシステムの他のプロセス全ての root と カレントワーキング"
"ディレクトリとを変更しなくてもよいはずである。"

#. type: Plain text
#: build/C/man2/pivot_root.2:143
msgid ""
"Some of the more obscure uses of B<pivot_root>()  may quickly lead to "
"insanity."
msgstr ""
"B<pivot_root>()  の使い方がもうちょっと曖昧になると、 あっという間にわけのわ"
"からない状態になってしまうだろう"

#. type: Plain text
#: build/C/man2/pivot_root.2:149
msgid "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"
msgstr "B<chdir>(2), B<chroot>(2), B<stat>(2), B<initrd>(4), B<pivot_root>(8)"

#. type: TH
#: build/C/man2/process_vm_readv.2:29
#, no-wrap
msgid "PROCESS_VM_READV"
msgstr ""

#. type: TH
#: build/C/man2/process_vm_readv.2:29
#, no-wrap
msgid "2012-04-25"
msgstr "2012-04-25"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:32
msgid ""
"process_vm_readv, process_vm_writev - transfer data between process address "
"spaces"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:35
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:42
#, no-wrap
msgid ""
"B<ssize_t process_vm_readv(pid_t >I<pid>B<,>\n"
"B<                         const struct iovec *>I<local_iov>B<,>\n"
"B<                         unsigned long >I<liovcnt>B<,>\n"
"B<                         const struct iovec *>I<remote_iov>B<,>\n"
"B<                         unsigned long >I<riovcnt>B<,>\n"
"B<                         unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:49
#, no-wrap
msgid ""
"B<ssize_t process_vm_writev(pid_t >I<pid>B<,>\n"
"B<                          const struct iovec *>I<local_iov>B<,>\n"
"B<                          unsigned long >I<liovcnt>B<,>\n"
"B<                          const struct iovec *>I<remote_iov>B<,>\n"
"B<                          unsigned long >I<riovcnt>B<,>\n"
"B<                          unsigned long >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:57
msgid ""
"These system calls transfer data between the address space of the calling "
"process (\"the local process\") and the process identified by I<pid> (\"the "
"remote process\").  The data moves directly between the address spaces of "
"the two processes, without passing through kernel space."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:82
msgid ""
"The B<process_vm_readv>()  system call transfers data from the remote "
"process to the local process.  The data to be transferred is identified by "
"I<remote_iov> and I<riovcnt>: I<remote_iov> is a pointer to an array "
"describing address ranges in the process I<pid>, and I<riovcnt> specifies "
"the number of elements in I<remote_iov>.  The data is transferred to the "
"locations specified by I<local_iov> and I<liovcnt>: I<local_iov> is a "
"pointer to an array describing address ranges in the calling process, and "
"I<liovcnt> specifies the number of elements in I<local_iov>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:96
msgid ""
"The B<process_vm_writev>()  system call is the converse of "
"B<process_vm_readv>()\\(emit transfers data from the local process to the "
"remote process.  Other than the direction of the transfer, the arguments "
"I<liovcnt>, I<local_iov>, I<riovcnt>, and I<remote_iov> have the same "
"meaning as for B<process_vm_readv>()."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:106
msgid ""
"The I<local_iov> and I<remote_iov> arguments point to an array of I<iovec> "
"structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""
"引き数 I<local_iov> と I<remote_iov> は I<iovec> 構造体の配列へのポイン\n"
"タである。 I<iovec> 構造体は I<E<lt>sys/uio.hE<gt>> で以下のように定義\n"
"されている:"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:113
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:129
msgid ""
"Buffers are processed in array order.  This means that B<process_vm_readv>"
"()  completely fills I<local_iov[0]> before proceeding to I<local_iov[1]>, "
"and so on.  Likewise, I<remote_iov[0]> is completely read before proceeding "
"to I<remote_iov[1]>, and so on."
msgstr ""
"バッファは配列の順序で処理される。これは、 B<process_vm_readv>() が\n"
"I<local_iov>[0] が完全に一杯になるまでデータを詰めてから、\n"
"I<local_iov>[1] に進むといったことを意味する。同様に、\n"
"I<remote_iov>[0] を完全に読み出してから I<remote_iov>[1] に進み、\n"
"以降も同様である。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:140
msgid ""
"Similarly, B<process_vm_writev>()  writes out the entire contents of "
"I<local_iov[0]> before proceeding to I<local_iov[1]>, and it completely "
"fills I<remote_iov[0]> before proceeding to I<remote_iov[1]>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:148
msgid ""
"The lengths of I<remote_iov[i].iov_len> and I<local_iov[i].iov_len> do not "
"have to be the same.  Thus, it is possible to split a single local buffer "
"into multiple remote buffers, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:152
msgid "The I<flags> argument is currently unused and must be set to 0."
msgstr "I<flags> 引き数は現在使用されておらず、 0 を設定しなければならない。"

#.  In time, glibc might provide a wrapper that works around this limit,
#.  as is done for readv()/writev()
#. type: Plain text
#: build/C/man2/process_vm_readv.2:165
msgid ""
"The values specified in the I<liovcnt> and I<riovcnt> arguments must be less "
"than or equal to B<IOV_MAX> (defined in I<E<lt>limits.hE<gt>> or accessible "
"via the call I<sysconf(_SC_IOV_MAX)>)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:175
msgid ""
"The count arguments and I<local_iov> are checked before doing any "
"transfers.  If the counts are too big, or I<local_iov> is invalid, or the "
"addresses refer to regions that are inaccessible to the local process, none "
"of the vectors will be processed and an error will be returned immediately."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:195
msgid ""
"Note, however, that these system calls do not check the memory regions in "
"the remote process until just before doing the read/write.  Consequently, a "
"partial read/write (see RETURN VALUE)  may result if one of the "
"I<remote_iov> elements points to an invalid memory region in the remote "
"process.  No further reads/writes will be attempted beyond that point.  Keep "
"this in mind when attempting to read data of unknown length (such as C "
"strings that are null-terminated) from a remote process, by avoiding "
"spanning memory pages (typically 4KiB) in a single remote I<iovec> element.  "
"(Instead, split the remote read into two I<remote_iov> elements and have "
"them merge back into a single write I<local_iov> entry.  The first read "
"entry goes up to the page boundary, while the second starts on the next page "
"boundary.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:209
msgid ""
"In order to read from or write to another process, either the caller must "
"have the capability B<CAP_SYS_PTRACE>, or the real user ID, effective user "
"ID, and saved set-user-ID of the remote process must match the real user ID "
"of the caller I<and> the real group ID, effective group ID, and saved set-"
"group-ID of the remote process must match the real group ID of the caller.  "
"(The permission required is exactly the same as that required to perform a "
"B<ptrace>(2)  B<PTRACE_ATTACH> on the remote process.)"
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:225
msgid ""
"On success, B<process_vm_readv>()  returns the number of bytes read and "
"B<process_vm_writev>()  returns the number of bytes written.  This return "
"value may be less than the total number of requested bytes, if a partial "
"read/write occurred.  (Partial transfers apply at the granularity of "
"I<iovec> elements.  These system calls won't perform a partial transfer that "
"splits a single I<iovec> element.)  The caller should check the return value "
"to determine whether a partial read/write occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:229
msgid "On error, -1 is returned and I<errno> is set appropriately."
msgstr "エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:241
msgid ""
"The sum of the I<iov_len> values of either I<local_iov> or I<remote_iov> "
"overflows a I<ssize_t> value."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:245
msgid "I<flags> is not 0."
msgstr "I<flags> が 0 でない。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:251
msgid "I<liovcnt> or I<riovcnt> is too large."
msgstr "I<liovcnt> か I<riovcnt> が大きすぎる。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:256
msgid ""
"The memory described by I<local_iov> is outside the caller's accessible "
"address space."
msgstr ""
"I<local_iov> が示すメモリが呼び出し側がアクセス可能な\n"
"アドレス空間の外にある。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:262
msgid ""
"The memory described by I<remote_iov> is outside the accessible address "
"space of the process I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:267
msgid ""
"Could not allocate memory for internal copies of the I<iovec> structures."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:271
msgid ""
"The caller does not have permission to access the address space of the "
"process I<pid>."
msgstr ""
"呼び出し側がプロセス I<pid> のアドレス空間に対するアクセス許可を\n"
"持っていない。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:276
msgid "No process with ID I<pid> exists."
msgstr "ID が I<pid> のプロセスが存在しない。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:279
msgid ""
"These system calls were added in Linux 3.2.  Support is provided in glibc "
"since version 2.15."
msgstr ""
"これらのシステムコールは Linux 3.2 で追加された。ライブラリによる\n"
"サポートは glibc バージョン 2.15 以降で提供されている。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:281
msgid "These system calls are nonstandard Linux extensions."
msgstr "これらのシステムコールは非標準で Linux による拡張である。"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:287
msgid ""
"The data transfers performed by B<process_vm_readv>()  and "
"B<process_vm_writev>()  are not guaranteed to be atomic in any way."
msgstr ""

#.  Original user is MPI, http://www.mcs.anl.gov/research/projects/mpi/
#.  See also some benchmarks at http://lwn.net/Articles/405284/
#.  and http://marc.info/?l=linux-mm&m=130105930902915&w=2
#. type: Plain text
#: build/C/man2/process_vm_readv.2:295
msgid ""
"These system calls were designed to permit fast message passing by allowing "
"messages to be exchanged with a single copy operation (rather than the "
"double copy that would be required when using, for example, shared memory or "
"pipes)."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:303
msgid ""
"The following code sample demonstrates the use of B<process_vm_readv>().  It "
"reads 20 bytes at the address 0x10000 from the process with PID 10 and "
"writes the first 10 bytes into I<buf1> and the second 10 bytes into I<buf2>."
msgstr ""

#. type: Plain text
#: build/C/man2/process_vm_readv.2:306
#, no-wrap
msgid "#include E<lt>sys/uio.hE<gt>\n"
msgstr "#include E<lt>sys/uio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:316
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct iovec local[2];\n"
"    struct iovec remote[1];\n"
"    char buf1[10];\n"
"    char buf2[10];\n"
"    ssize_t nread;\n"
"    pid_t pid = 10;             /* PID of remote process */\n"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:323
#, no-wrap
msgid ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[1].iov_len = 20;\n"
msgstr ""
"    local[0].iov_base = buf1;\n"
"    local[0].iov_len = 10;\n"
"    local[1].iov_base = buf2;\n"
"    local[1].iov_len = 10;\n"
"    remote[0].iov_base = (void *) 0x10000;\n"
"    remote[1].iov_len = 20;\n"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:330
#, no-wrap
msgid ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"
msgstr ""
"    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
"    if (nread != 20)\n"
"        return 1;\n"
"    else\n"
"        return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man2/process_vm_readv.2:334
msgid "B<readv>(2), B<writev>(2)"
msgstr "B<readv>(2), B<writev>(2)"

#. type: TH
#: build/C/man2/ptrace.2:44
#, no-wrap
msgid "PTRACE"
msgstr "PTRACE"

#. type: TH
#: build/C/man2/ptrace.2:44
#, no-wrap
msgid "2013-02-16"
msgstr "2013-02-16"

#. type: Plain text
#: build/C/man2/ptrace.2:47
msgid "ptrace - process trace"
msgstr "ptrace - プロセスのトレース"

#. type: Plain text
#: build/C/man2/ptrace.2:50
#, no-wrap
msgid "B<#include E<lt>sys/ptrace.hE<gt>>\n"
msgstr "B<#include E<lt>sys/ptrace.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/ptrace.2:53
#, no-wrap
msgid ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"
msgstr ""
"B<long ptrace(enum __ptrace_request >I<request>B<, pid_t >I<pid>B<, >\n"
"B<            void *>I<addr>B<, void *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man2/ptrace.2:62
#, fuzzy
#| msgid ""
#| "The B<ptrace>()  system call provides a means by which a parent process "
#| "may observe and control the execution of another process, and examine and "
#| "change its core image and registers.  It is primarily used to implement "
#| "breakpoint debugging and system call tracing."
msgid ""
"The B<ptrace>()  system call provides a means by which one process (the "
"\"tracer\")  may observe and control the execution of another process (the "
"\"tracee\"), and examine and change the tracee's memory and registers.  It "
"is primarily used to implement breakpoint debugging and system call tracing."
msgstr ""
"B<ptrace>()  システムコールは、親プロセスが、別のプロセスの実行の監視/制御を "
"行ったり、コアイメージ (core image) やレジスタの調査/変更を 行ったりする手段"
"を提供する。 B<ptrace>()  は、主にブレークポイントによるデバッグやシステム"
"コールのトレースを 実装するのに用いられる。"

#. type: Plain text
#: build/C/man2/ptrace.2:73
msgid ""
"A tracee first needs to be attached to the tracer.  Attachment and "
"subsequent commands are per thread: in a multithreaded process, every thread "
"can be individually attached to a (potentially different) tracer, or left "
"not attached and thus not debugged.  Therefore, \"tracee\" always means "
"\"(one) thread\", never \"a (possibly multithreaded) process\".  Ptrace "
"commands are always sent to a specific tracee using a call of the form"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:75
#, no-wrap
msgid "    ptrace(PTRACE_foo, pid, ...)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:79
msgid "where I<pid> is the thread ID of the corresponding Linux thread."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:85
msgid ""
"(Note that in this page, a \"multithreaded process\" means a thread group "
"consisting of threads created using the B<clone>(2)  B<CLONE_THREAD> flag.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:96
#, fuzzy
#| msgid ""
#| "The parent can initiate a trace by calling B<fork>(2)  and having the "
#| "resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<exec>"
#| "(3).  Alternatively, the parent may commence trace of an existing process "
#| "using B<PTRACE_ATTACH>."
msgid ""
"A process can initiate a trace by calling B<fork>(2)  and having the "
"resulting child do a B<PTRACE_TRACEME>, followed (typically) by an B<execve>"
"(2).  Alternatively, one process may commence tracing another process using "
"B<PTRACE_ATTACH> or B<PTRACE_SEIZE>."
msgstr ""
"トレースを開始するには、まず親プロセスで B<fork>(2)  を呼び出す。生成された子"
"プロセスで B<PTRACE_TRACEME> を行い、続いて (典型的には)  B<exec>(3)  を行な"
"う。 別の方法としては、 親プロセスが既存のプロセスに対して B<PTRACE_ATTACH> "
"を使用し、トレースを開始する。"

#. type: Plain text
#: build/C/man2/ptrace.2:113
#, fuzzy
#| msgid ""
#| "While being traced, the child will stop each time a signal is delivered, "
#| "even if the signal is being ignored.  (The exception is B<SIGKILL>, which "
#| "has its usual effect.)  The parent will be notified at its next B<wait>"
#| "(2)  and may inspect and modify the child process while it is stopped.  "
#| "The parent then causes the child to continue, optionally ignoring the "
#| "delivered signal (or even delivering a different signal instead)."
msgid ""
"While being traced, the tracee will stop each time a signal is delivered, "
"even if the signal is being ignored.  (An exception is B<SIGKILL>, which has "
"its usual effect.)  The tracer will be notified at its next call to "
"B<waitpid>(2)  (or one of the related \"wait\" system calls); that call will "
"return a I<status> value containing information that indicates the cause of "
"the stop in the tracee.  While the tracee is stopped, the tracer can use "
"various ptrace requests to inspect and modify the tracee.  The tracer then "
"causes the tracee to continue, optionally ignoring the delivered signal (or "
"even delivering a different signal instead)."
msgstr ""
"トレースの実行中、子プロセスはシグナルが配送されるたびに、 たとえそのシグナル"
"が無視すべきものであっても停止する (B<SIGKILL> は例外で、通常どおりの効果をも"
"たらす)。 親プロセスには次の B<wait>(2)  で通知され、停止している間に子プロセ"
"スを調べたり修正したりすることができる。 そして親プロセスは子プロセスの実行を"
"再開させるが、配送された シグナルを無視することもできる (あるいは代わりに別の"
"シグナルを 配送することもできる) 。"

#. type: Plain text
#: build/C/man2/ptrace.2:123
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is not in effect, all successful calls "
"to B<execve>(2)  by the traced process will cause it to be sent a B<SIGTRAP> "
"signal, giving the parent a chance to gain control before the new program "
"begins execution."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:127
#, fuzzy
#| msgid ""
#| "When the parent is finished tracing, it can terminate the child with "
#| "B<PTRACE_KILL> or cause it to continue executing in a normal, untraced "
#| "mode via B<PTRACE_DETACH>."
msgid ""
"When the tracer is finished tracing, it can cause the tracee to continue "
"executing in a normal, untraced mode via B<PTRACE_DETACH>."
msgstr ""
"親プロセスがトレースを終了する際には、 B<PTRACE_KILL> を使用して子プロセスを"
"終了させることもできるし、 B<PTRACE_DETACH> を用いて通常のトレースなしのモー"
"ドにして、 実行を継続させることもできる。"

#. type: Plain text
#: build/C/man2/ptrace.2:131
msgid "The value of I<request> determines the action to be performed:"
msgstr "I<request> の値がこのシステムコールの動作を決定する:"

#. type: TP
#: build/C/man2/ptrace.2:131
#, no-wrap
msgid "B<PTRACE_TRACEME>"
msgstr "B<PTRACE_TRACEME>"

#. type: Plain text
#: build/C/man2/ptrace.2:141
msgid ""
"Indicate that this process is to be traced by its parent.  A process "
"probably shouldn't make this request if its parent isn't expecting to trace "
"it.  (I<pid>, I<addr>, and I<data> are ignored.)"
msgstr ""
"このプロセスが親プロセスによってトレースされることを表す。親プロセスが自プロ"
"セスをトレースするつもりがない場合には、 おそらくこのプロセスは本要求を行うべ"
"きではないだろう。 (I<pid>, I<addr>, I<data> は無視される。)"

#. type: Plain text
#: build/C/man2/ptrace.2:156
#, fuzzy
#| msgid ""
#| "The above request is used only by the child process; the rest are used "
#| "only by the parent.  In the following requests, I<pid> specifies the "
#| "child process to be acted on.  For requests other than B<PTRACE_KILL>, "
#| "the child process must be stopped."
msgid ""
"The B<PTRACE_TRACEME> request is used only by the tracee; the remaining "
"requests are used only by the tracer.  In the following requests, I<pid> "
"specifies the thread ID of the tracee to be acted on.  For requests other "
"than B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, B<PTRACE_INTERRUPT> and "
"B<PTRACE_KILL>, the tracee must be stopped."
msgstr ""
"上記の要求は子プロセスだけが行なうものである。 残りは親プロセスだけが行なうも"
"のである。 以下の要求では、I<pid> で操作の対象となる 子プロセスを指定する。 "
"B<PTRACE_KILL> を除き、要求を行なうためには 子プロセスは停止していなければな"
"らない。"

#. type: TP
#: build/C/man2/ptrace.2:156
#, no-wrap
msgid "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"
msgstr "B<PTRACE_PEEKTEXT>, B<PTRACE_PEEKDATA>"

#. type: Plain text
#: build/C/man2/ptrace.2:167
#, fuzzy
#| msgid ""
#| "Reads a word at the location I<addr> in the child's memory, returning the "
#| "word as the result of the B<ptrace>()  call.  Linux does not have "
#| "separate text and data address spaces, so the two requests are currently "
#| "equivalent.  (The argument I<data> is ignored.)"
msgid ""
"Read a word at the address I<addr> in the tracee's memory, returning the "
"word as the result of the B<ptrace>()  call.  Linux does not have separate "
"text and data address spaces, so these two requests are currently "
"equivalent.  (I<data> is ignored.)"
msgstr ""
"子プロセスのメモリの I<addr> の位置から 1 ワードを読み出す。読み出したワード"
"は B<ptrace>()  の返り値として返される。 Linux ではテキスト (text) とデータ "
"(data) で 同じアドレス空間を使用するため、この 2 つの要求は現在のところ 同じ"
"ものである。 (引き数 I<data> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:167
#, no-wrap
msgid "B<PTRACE_PEEKUSER>"
msgstr "B<PTRACE_PEEKUSER>"

#.  PTRACE_PEEKUSR in kernel source, but glibc uses PTRACE_PEEKUSER,
#.  and that is the name that seems common on other systems.
#. type: Plain text
#: build/C/man2/ptrace.2:185
#, fuzzy
#| msgid ""
#| "Reads a word at offset I<addr> in the child's USER area, which holds the "
#| "registers and other information about the process (see I<E<lt>sys/user."
#| "hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
#| "Typically the offset must be word-aligned, though this might vary by "
#| "architecture.  See NOTES.  (I<data> is ignored.)"
msgid ""
"Read a word at offset I<addr> in the tracee's USER area, which holds the "
"registers and other information about the process (see I<E<lt>sys/user."
"hE<gt>>).  The word is returned as the result of the B<ptrace>()  call.  "
"Typically, the offset must be word-aligned, though this might vary by "
"architecture.  See NOTES.  (I<data> is ignored.)"
msgstr ""
"子プロセスの USER 領域のオフセット I<addr> の位置から 1 ワードを読み込む。"
"USER 領域にはそのプロセスの レジスタ (registers) などの情報が保持されている "
"(I<E<lt>sys/user.hE<gt>> を参照)。読み込んだワードは B<ptrace>()  コールの結"
"果として返される。 たいていはオフセットはワード境界になければならないが、 "
"アーキテクチャによってはその必要はない。 「注意」の節を参照。 (I<data> は無視"
"される。 )"

#. type: TP
#: build/C/man2/ptrace.2:185
#, no-wrap
msgid "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"
msgstr "B<PTRACE_POKETEXT>, B<PTRACE_POKEDATA>"

#. type: Plain text
#: build/C/man2/ptrace.2:197
#, fuzzy
#| msgid ""
#| "Copies the word I<data> to location I<addr> in the child's memory.  As "
#| "above, the two requests are currently equivalent."
msgid ""
"Copy the word I<data> to the address I<addr> in the tracee's memory.  As for "
"B<PTRACE_PEEKTEXT> and B<PTRACE_PEEKDATA>, these two requests are currently "
"equivalent."
msgstr ""
"ワード I<data> を子プロセスのメモリの I<addr> の位置へコピーする。上と同様"
"に、現在のところ二つの 要求は同じものである。"

#. type: TP
#: build/C/man2/ptrace.2:197
#, no-wrap
msgid "B<PTRACE_POKEUSER>"
msgstr "B<PTRACE_POKEUSER>"

#.  PTRACE_POKEUSR in kernel source, but glibc uses PTRACE_POKEUSER,
#.  and that is the name that seems common on other systems.
#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:213
#, fuzzy
#| msgid ""
#| "Copies the word I<data> to offset I<addr> in the child's USER area.  As "
#| "above, the offset must typically be word-aligned.  In order to maintain "
#| "the integrity of the kernel, some modifications to the USER area are "
#| "disallowed."
msgid ""
"Copy the word I<data> to offset I<addr> in the tracee's USER area.  As for "
"B<PTRACE_PEEKUSER>, the offset must typically be word-aligned.  In order to "
"maintain the integrity of the kernel, some modifications to the USER area "
"are disallowed."
msgstr ""
"ワード I<data> を子プロセスの USER 領域のオフセット I<addr> の位置にコピーす"
"る。 上と同様に、通常、オフセットはワード境界になければならない。 カーネルの"
"完全性 (integrity) を維持するため、 変更内容によっては USER 領域の変更は禁止"
"されている。"

#. type: TP
#: build/C/man2/ptrace.2:213
#, no-wrap
msgid "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"
msgstr "B<PTRACE_GETREGS>, B<PTRACE_GETFPREGS>"

#. type: Plain text
#: build/C/man2/ptrace.2:236
#, fuzzy
#| msgid ""
#| "Copies the child's general purpose or floating-point registers, "
#| "respectively, to location I<data> in the parent.  See I<E<lt>sys/user."
#| "hE<gt>> for information on the format of this data.  (I<addr> is ignored.)"
msgid ""
"Copy the tracee's general-purpose or floating-point registers, respectively, "
"to the address I<data> in the tracer.  See I<E<lt>sys/user.hE<gt>> for "
"information on the format of this data.  (I<addr> is ignored.)  Note that "
"SPARC systems have the meaning of I<data> and I<addr> reversed; that is, "
"I<data> is ignored and the registers are copied to the address I<addr>.  "
"B<PTRACE_GETREGS> and B<PTRACE_GETFPREGS> are not present on all "
"architectures."
msgstr ""
"それぞれ、子プロセスの汎用レジスタ、浮動小数点レジスタを親プロセスの I<data> "
"の位置にコピーする。この data の書式に関しては I<E<lt>sys/user.hE<gt>> を参照"
"すること。(I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:236
#, fuzzy, no-wrap
#| msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgid "B<PTRACE_GETREGSET> (since Linux 2.6.34)"
msgstr "B<PTRACE_GETEVENTMSG> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:257
msgid ""
"Read the tracee's registers.  I<addr> specifies, in an architecture-"
"dependent way, the type of registers to be read.  B<NT_PRSTATUS> (with "
"numerical value 1)  usually results in reading of general-purpose "
"registers.  If the CPU has, for example, floating-point and/or vector "
"registers, they can be retrieved by setting I<addr> to the corresponding "
"B<NT_foo> constant.  I<data> points to a B<struct iovec>, which describes "
"the destination buffer's location and length.  On return, the kernel "
"modifies B<iov.len> to indicate the actual number of bytes returned."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:257
#, no-wrap
msgid "B<PTRACE_GETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_GETSIGINFO> (Linux 2.3.99-pre6 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:269
#, fuzzy
#| msgid ""
#| "Retrieve information about the signal that caused the stop.  Copies a "
#| "I<siginfo_t> structure (see B<sigaction>(2))  from the child to location "
#| "I<data> in the parent.  (I<addr> is ignored.)"
msgid ""
"Retrieve information about the signal that caused the stop.  Copy a "
"I<siginfo_t> structure (see B<sigaction>(2))  from the tracee to the address "
"I<data> in the tracer.  (I<addr> is ignored.)"
msgstr ""
"停止の原因となったシグナルに関する情報を取得する。 I<siginfo_t> 構造体 "
"(B<sigaction>(2)  参照) を子プロセスから親プロセスの I<data> の位置にコピーす"
"る。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:269
#, no-wrap
msgid "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"
msgstr "B<PTRACE_SETREGS>, B<PTRACE_SETFPREGS>"

#.  FIXME In the preceding sentence, which modifications are disallowed,
#.  and when they are disallowed, how does user space discover that fact?
#. type: Plain text
#: build/C/man2/ptrace.2:294
#, fuzzy
#| msgid ""
#| "Copies the child's general purpose or floating-point registers, "
#| "respectively, from location I<data> in the parent.  As for "
#| "B<PTRACE_POKEUSER>, some general purpose register modifications may be "
#| "disallowed.  (I<addr> is ignored.)"
msgid ""
"Modify the tracee's general-purpose or floating-point registers, "
"respectively, from the address I<data> in the tracer.  As for "
"B<PTRACE_POKEUSER>, some general-purpose register modifications may be "
"disallowed.  (I<addr> is ignored.)  Note that SPARC systems have the meaning "
"of I<data> and I<addr> reversed; that is, I<data> is ignored and the "
"registers are copied from the address I<addr>.  B<PTRACE_SETREGS> and "
"B<PTRACE_SETFPREGS> are not present on all architectures."
msgstr ""
"それぞれ、子プロセスの汎用レジスタ、浮動小数点レジスタに 親プロセスの "
"I<date> の位置からコピーする。 B<PTRACE_POKEUSER> と同様に、汎用レジスタに"
"よっては 変更が禁止されている場合がある。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:294
#, fuzzy, no-wrap
#| msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgid "B<PTRACE_SETREGSET> (since Linux 2.6.34)"
msgstr "B<PTRACE_GETEVENTMSG> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:303
msgid ""
"Modify the tracee's registers.  The meaning of I<addr> and I<data> is "
"analogous to B<PTRACE_GETREGSET>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:303
#, no-wrap
msgid "B<PTRACE_SETSIGINFO> (since Linux 2.3.99-pre6)"
msgstr "B<PTRACE_SETSIGINFO> (Linux 2.3.99-pre6 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:319
#, fuzzy
#| msgid ""
#| "Set signal information.  Copies a I<siginfo_t> structure from location "
#| "I<data> in the parent to the child.  This will only affect signals that "
#| "would normally be delivered to the child and were caught by the tracer.  "
#| "It may be difficult to tell these normal signals from synthetic signals "
#| "generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgid ""
"Set signal information: copy a I<siginfo_t> structure from the address "
"I<data> in the tracer to the tracee.  This will affect only signals that "
"would normally be delivered to the tracee and were caught by the tracer.  It "
"may be difficult to tell these normal signals from synthetic signals "
"generated by B<ptrace>()  itself.  (I<addr> is ignored.)"
msgstr ""
"シグナル情報を設定する。 I<siginfo_t> 構造体を親プロセスのデータ I<data> の位"
"置から 子プロセスにコピーする。 この処理を行うことができるのは、子プロセスに"
"通常は配送されるはずで トレーサに捕捉されたシグナルについてだけである。 これ"
"らの通常のシグナルと B<ptrace>()  自身が発生するシグナルを見分けるのは難しい"
"かもしれない。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:319
#, no-wrap
msgid "B<PTRACE_SETOPTIONS> (since Linux 2.4.6; see BUGS for caveats)"
msgstr "B<PTRACE_SETOPTIONS> (Linux 2.4.6 以降; バグの章にある警告も参照)"

#. type: Plain text
#: build/C/man2/ptrace.2:328
#, fuzzy
#| msgid ""
#| "Sets ptrace options from I<data> in the parent.  (I<addr> is ignored.)  "
#| "I<data> is interpreted as a bit mask of options, which are specified by "
#| "the following flags:"
msgid ""
"Set ptrace options from I<data>.  (I<addr> is ignored.)  I<data> is "
"interpreted as a bit mask of options, which are specified by the following "
"flags:"
msgstr ""
"親プロセスの I<data> に基づいて ptrace のオプションを設定する (I<addr> は無視"
"される)。 I<data> はオプションのビットマスクとして解釈され、 オプションには以"
"下のフラグを指定できる:"

#. type: TP
#: build/C/man2/ptrace.2:329
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgid "B<PTRACE_O_EXITKILL> (since Linux 3.8)"
msgstr "B<PTRACE_O_TRACEEXIT> (Linux 2.5.60 以降)"

#.  commit 992fb6e170639b0849bace8e49bf31bd37c4123
#. type: Plain text
#: build/C/man2/ptrace.2:337
msgid ""
"If a tracer sets this flag, a B<SIGKILL> signal will be sent to every tracee "
"if the tracer exits.  This option is useful for ptrace jailers that want to "
"ensure that tracees can never escape the tracer's control."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:337
#, no-wrap
msgid "B<PTRACE_O_TRACECLONE> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACECLONE> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:349
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly forked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<clone>(2)  and automatically start tracing the "
"newly cloned process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"次の B<fork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ "
"8> で 子プロセスの動作を停止させ、 新たに fork されたプロセスのトレースを自動"
"的に開始し、 B<SIGSTOP> でそのプロセスの実行を開始する。 新しいプロセスの "
"PID は B<PTRACE_GETEVENTMSG> で取得できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:352
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_CLONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:356 build/C/man2/ptrace.2:437
#: build/C/man2/ptrace.2:465
msgid "The PID of the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:377
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<clone>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_CLONE\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly cloned process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>.  This option "
#| "may not catch B<clone>(2)  calls in all cases.  If the child calls "
#| "B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will be "
#| "delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
#| "child calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
#| "B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgid ""
"This option may not catch B<clone>(2)  calls in all cases.  If the tracee "
"calls B<clone>(2)  with the B<CLONE_VFORK> flag, B<PTRACE_EVENT_VFORK> will "
"be delivered instead if B<PTRACE_O_TRACEVFORK> is set; otherwise if the "
"tracee calls B<clone>(2)  with the exit signal set to B<SIGCHLD>, "
"B<PTRACE_EVENT_FORK> will be delivered if B<PTRACE_O_TRACEFORK> is set."
msgstr ""
"次の B<clone>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_CLONE\\ E<lt>E<lt> "
"\\8> で 子プロセスの動作を停止させ、 新たに clone で作成されたプロセスのト"
"レースを自動的に開始し、 B<SIGSTOP> でプロセスの実行を開始する。 新しいプロセ"
"スの PID は B<PTRACE_GETEVENTMSG> で取得できる。 このオプションで全ての "
"B<clone>(2)  コールを捕まえられるわけではない。 子プロセスが B<CLONE_VFORK> "
"フラグ付きで B<clone>(2)  を呼び出した場合、 B<PTRACE_O_TRACEVFORK> が設定さ"
"れていれば代わりに B<PTRACE_EVENT_VFORK> が配送される。 また、子プロセスが終"
"了シグナルを B<SIGCHLD> に設定して B<clone>(2)  を呼び出した場合は、 "
"B<PTRACE_O_TRACEFORK> が設定されていれば B<PTRACE_EVENT_FORK> が配送される。"

#. type: TP
#: build/C/man2/ptrace.2:377
#, no-wrap
msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEEXEC> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:386
msgid ""
"Stop the tracee at the next B<execve>(2).  A B<waitpid>(2)  by the tracer "
"will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:389
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXECE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:395
msgid ""
"If the execing thread is not a thread group leader, the thread ID is reset "
"to thread group leader's ID before this stop.  Since Linux 3.0, the former "
"thread ID can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:395
#, no-wrap
msgid "B<PTRACE_O_TRACEEXIT> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEEXIT> (Linux 2.5.60 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:403
msgid ""
"Stop the tracee at exit.  A B<waitpid>(2)  by the tracer will return a "
"I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:406
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_EXITE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:410
msgid "The tracee's exit status can be retrieved with B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:418
#, fuzzy
#| msgid ""
#| "Stop the child at exit with I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ "
#| "8>.  The child's exit status can be retrieved with "
#| "B<PTRACE_GETEVENTMSG>.  This stop will be done early during process exit "
#| "when registers are still available, allowing the tracer to see where the "
#| "exit occurred, whereas the normal exit notification is done after the "
#| "process is finished exiting.  Even though context is available, the "
#| "tracer cannot prevent the exit from happening at this point."
msgid ""
"The tracee is stopped early during process exit, when registers are still "
"available, allowing the tracer to see where the exit occurred, whereas the "
"normal exit notification is done after the process is finished exiting.  "
"Even though context is available, the tracer cannot prevent the exit from "
"happening at this point."
msgstr ""
"終了 (exit) 時に I<SIGTRAP | PTRACE_EVENT_EXIT\\ E<lt>E<lt>\\ 8> で子プロセス"
"の動作を停止させる。子プロセスの終了ステータスは B<PTRACE_GETEVENTMSG> で取得"
"できる。 この停止はレジスタがまだ参照可能であるプロセス終了処理の初期に行わ"
"れ、 トレーサはどこで終了が発生したかを知ることができる。 通常の終了通知 "
"(exit notification) はプロセスの終了処理が完了した後に 行われる。コンテキスト"
"を参照することはできるにも関わらず、 トレーサはこの時点から終了を止めることは"
"できない。"

#. type: TP
#: build/C/man2/ptrace.2:418
#, no-wrap
msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:430
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<fork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly forked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<fork>(2)  and automatically start tracing the "
"newly forked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"次の B<fork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_FORK\\ E<lt>E<lt>\\ "
"8> で 子プロセスの動作を停止させ、 新たに fork されたプロセスのトレースを自動"
"的に開始し、 B<SIGSTOP> でそのプロセスの実行を開始する。 新しいプロセスの "
"PID は B<PTRACE_GETEVENTMSG> で取得できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:433
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_FORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:437
#, no-wrap
msgid "B<PTRACE_O_TRACESYSGOOD> (since Linux 2.4.6)"
msgstr "B<PTRACE_O_TRACESYSGOOD> (Linux 2.4.6 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:446
#, fuzzy
#| msgid ""
#| "When delivering syscall traps, set bit 7 in the signal number (i.e., "
#| "deliver I<SIGTRAP | 0x80>).  This makes it easy for the tracer to tell "
#| "the difference between normal traps and those caused by a syscall.  "
#| "(B<PTRACE_O_TRACESYSGOOD> may not work on all architectures.)"
msgid ""
"When delivering system call traps, set bit 7 in the signal number (i.e., "
"deliver I<SIGTRAP|0x80>).  This makes it easy for the tracer to distinguish "
"normal traps from those caused by a system call.  (B<PTRACE_O_TRACESYSGOOD> "
"may not work on all architectures.)"
msgstr ""
"システムコールのトラップが配送されたときに、シグナル番号のビット 7 を設定す"
"る (すなわち、I<SIGTRAP | 0x80> を配送する)。 これにより、トレーサが通常のト"
"ラップとシステムコールによるトラップを 区別しやすくなる。 "
"(B<PTRACE_O_TRACESYSGOOD> はどのアーキテクチャでも動作しない可能性がある。)"

#. type: TP
#: build/C/man2/ptrace.2:446
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORK> (since Linux 2.5.46)"
msgstr "B<PTRACE_O_TRACEVFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:458
#, fuzzy
#| msgid ""
#| "Stop the child at the next B<vfork>(2)  call with I<SIGTRAP | "
#| "PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ 8> and automatically start tracing the "
#| "newly vforked process, which will start with a B<SIGSTOP>.  The PID for "
#| "the new process can be retrieved with B<PTRACE_GETEVENTMSG>."
msgid ""
"Stop the tracee at the next B<vfork>(2)  and automatically start tracing the "
"newly vforked process, which will start with a B<SIGSTOP>.  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""
"次の B<vfork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_VFORK\\ E<lt>E<lt>\\ "
"8> で 子プロセスの動作を停止させ、 新たに vfork されたプロセスのトレースを自"
"動的に開始し、 B<SIGSTOP> でそのプロセスの実行を開始する。 新しいプロセスの "
"PID は B<PTRACE_GETEVENTMSG> で取得できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:461
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORKE<lt>E<lt>8))\n"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:465
#, no-wrap
msgid "B<PTRACE_O_TRACEVFORKDONE> (since Linux 2.5.60)"
msgstr "B<PTRACE_O_TRACEVFORKDONE> (Linux 2.5.60 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:474
msgid ""
"Stop the tracee at the completion of the next B<vfork>(2).  A B<waitpid>(2)  "
"by the tracer will return a I<status> value such that"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:477
#, no-wrap
msgid "  statusE<gt>E<gt>8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONEE<lt>E<lt>8))\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:481
msgid ""
"The PID of the new process can (since Linux 2.6.18) be retrieved with "
"B<PTRACE_GETEVENTMSG>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:482
#, no-wrap
msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgstr "B<PTRACE_GETEVENTMSG> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:502
#, fuzzy
#| msgid ""
#| "Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
#| "just happened, placing it in the location I<data> in the parent.  For "
#| "B<PTRACE_EVENT_EXIT> this is the child's exit status.  For "
#| "B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK> and B<PTRACE_EVENT_CLONE> "
#| "this is the PID of the new process.  Since Linux 2.6.18, the PID of the "
#| "new process is also available for B<PTRACE_EVENT_VFORK_DONE>.  (I<addr> "
#| "is ignored.)"
msgid ""
"Retrieve a message (as an I<unsigned long>)  about the ptrace event that "
"just happened, placing it at the address I<data> in the tracer.  For "
"B<PTRACE_EVENT_EXIT>, this is the tracee's exit status.  For "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_VFORK_DONE>, and "
"B<PTRACE_EVENT_CLONE>, this is the PID of the new process.  (I<addr> is "
"ignored.)"
msgstr ""
"発生したばかりの ptrace イベントに関するメッセージを (I<unsigned long> 型で) "
"取得する。 取得したメッセージは親プロセスの I<data> の位置に格納される。 得ら"
"れる内容は、 B<PTRACE_EVENT_EXIT> の場合は子プロセスの終了ステータスであり、 "
"B<PTRACE_EVENT_FORK>, B<PTRACE_EVENT_VFORK>, B<PTRACE_EVENT_CLONE> の場合は新"
"しいプロセスの PID である。 Linux 2.6.18 以降では、新しいプロセスの PID は "
"B<PTRACE_EVENT_VFORK_DONE> で入手できる。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:502
#, no-wrap
msgid "B<PTRACE_CONT>"
msgstr "B<PTRACE_CONT>"

#. type: Plain text
#: build/C/man2/ptrace.2:514
#, fuzzy
#| msgid ""
#| "Restarts the stopped child process.  If I<data> is nonzero and not "
#| "B<SIGSTOP>, it is interpreted as a signal to be delivered to the child; "
#| "otherwise, no signal is delivered.  Thus, for example, the parent can "
#| "control whether a signal sent to the child is delivered or not.  (I<addr> "
#| "is ignored.)"
msgid ""
"Restart the stopped tracee process.  If I<data> is nonzero, it is "
"interpreted as the number of a signal to be delivered to the tracee; "
"otherwise, no signal is delivered.  Thus, for example, the tracer can "
"control whether a signal sent to the tracee is delivered or not.  (I<addr> "
"is ignored.)"
msgstr ""
"停止した子プロセスの実行を再開させる。 I<data> がゼロでなく、 B<SIGSTOP> でも"
"なければ、 子プロセスに配送されるシグナルと解釈される。 ゼロや B<SIGSTOP> の"
"場合はシグナルは配送されない。 これを使うと、例えば、親プロセスは 子プロセス"
"に送られたシグナルを実際に配送するかどうかを 制御することができる。(I<addr> "
"は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:514
#, no-wrap
msgid "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"
msgstr "B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>"

#. type: Plain text
#: build/C/man2/ptrace.2:538
#, fuzzy
#| msgid ""
#| "Restarts the stopped child as for B<PTRACE_CONT>, but arranges for the "
#| "child to be stopped at the next entry to or exit from a system call, or "
#| "after execution of a single instruction, respectively.  (The child will "
#| "also, as usual, be stopped upon receipt of a signal.)  From the parent's "
#| "perspective, the child will appear to have been stopped by receipt of a "
#| "B<SIGTRAP>.  So, for B<PTRACE_SYSCALL>, for example, the idea is to "
#| "inspect the arguments to the system call at the first stop, then do "
#| "another B<PTRACE_SYSCALL> and inspect the return value of the system call "
#| "at the second stop.  The I<data> argument is treated as for "
#| "B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but arrange for the tracee "
"to be stopped at the next entry to or exit from a system call, or after "
"execution of a single instruction, respectively.  (The tracee will also, as "
"usual, be stopped upon receipt of a signal.)  From the tracer's perspective, "
"the tracee will appear to have been stopped by receipt of a B<SIGTRAP>.  So, "
"for B<PTRACE_SYSCALL>, for example, the idea is to inspect the arguments to "
"the system call at the first stop, then do another B<PTRACE_SYSCALL> and "
"inspect the return value of the system call at the second stop.  The I<data> "
"argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored.)"
msgstr ""
"B<PTRACE_CONT> と同様に停止した子プロセスを再開する。ただし、 "
"B<PTRACE_SYSCALL> の場合は子プロセスが 次にシステムコールに入るかシステムコー"
"ルから抜けるかする時に、 B<PTRACE_SINGLESTEP> の場合は 1 命令 (instruction) "
"実行した後に停止させる (通常どおり、子プロセスはシグナルを受け取った場合にも"
"停止する)。 親プロセスから見ると、子プロセスは B<SIGTRAP> を受信して停止した"
"ように見える。そのため、例えば B<PTRACE_SYSCALL> を使うと、1回目の停止で引き"
"数を調べて B<PTRACE_SYSCALL> を実行し、 2回目の停止でシステムコールの返り値を"
"調べる、 というようなことができる。 引き数 I<data> は B<PTRACE_CONT> の場合と"
"同じ様に解釈される。 (I<addr> は無視される。)"

#. type: TP
#: build/C/man2/ptrace.2:538
#, no-wrap
msgid "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (since Linux 2.6.14)"
msgstr "B<PTRACE_SYSEMU>, B<PTRACE_SYSEMU_SINGLESTEP> (Linux 2.6.14 以降)"

#.  As at 3.7
#. type: Plain text
#: build/C/man2/ptrace.2:559
#, fuzzy
#| msgid ""
#| "For B<PTRACE_SYSEMU>, continue and stop on entry to the next syscall, "
#| "which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
#| "but also singlestep if not a syscall.  This call is used by programs like "
#| "User Mode Linux that want to emulate all the child's system calls.  The "
#| "I<data> argument is treated as for B<PTRACE_CONT>.  (I<addr> is ignored; "
#| "not supported on all architectures.)"
msgid ""
"For B<PTRACE_SYSEMU>, continue and stop on entry to the next system call, "
"which will not be executed.  For B<PTRACE_SYSEMU_SINGLESTEP>, do the same "
"but also singlestep if not a system call.  This call is used by programs "
"like User Mode Linux that want to emulate all the tracee's system calls.  "
"The I<data> argument is treated as for B<PTRACE_CONT>.  The I<addr> argument "
"is ignored.  These requests are currently supported only on x86."
msgstr ""
"B<PTRACE_SYSEMU> は、実行を再開し、次のシステムコールに入る時に停止させる。 "
"システムコールは実行されない。 B<PTRACE_SYSEMU_SINGLESTEP> も同様だが、システ"
"ムコールでない場合には 1 命令 (singlestep) だけ実行した時点でも停止させる。 "
"このコールは User Mode Linux のように子プロセスのシステムコールを全て エミュ"
"レートしようとするプログラムで使用される。 引き数 I<data> は B<PTRACE_CONT> "
"の場合と同じ様に解釈される。 (I<addr> は無視される。 全てのアーキテクチャでサ"
"ポートされているわけではない。)"

#. type: TP
#: build/C/man2/ptrace.2:559
#, fuzzy, no-wrap
#| msgid "B<PTRACE_GETEVENTMSG> (since Linux 2.5.46)"
msgid "B<PTRACE_LISTEN> (since Linux 3.4)"
msgstr "B<PTRACE_GETEVENTMSG> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:570
msgid ""
"Restart the stopped tracee, but prevent it from executing.  The resulting "
"state of the tracee is similar to a process which has been stopped by a "
"B<SIGSTOP> (or other stopping signal).  See the \"group-stop\" subsection "
"for additional information.  B<PTRACE_LISTEN> works only on tracees attached "
"by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:570
#, no-wrap
msgid "B<PTRACE_KILL>"
msgstr "B<PTRACE_KILL>"

#. type: Plain text
#: build/C/man2/ptrace.2:579
#, fuzzy
#| msgid ""
#| "Sends the child a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
#| "ignored.)"
msgid ""
"Send the tracee a B<SIGKILL> to terminate it.  (I<addr> and I<data> are "
"ignored.)"
msgstr ""
"子プロセスに B<SIGKILL> を送り終了させる。(I<addr> と I<data> は無視される。)"

#.  [Note from Denys Vlasenko:
#.      deprecation suggested by Oleg Nesterov. He prefers to deprecate it
#.      instead of describing (and needing to support) PTRACE_KILL's quirks.]
#. type: Plain text
#: build/C/man2/ptrace.2:598
msgid ""
"I<This operation is deprecated; do not use it!> Instead, send a B<SIGKILL> "
"directly using B<kill>(2)  or B<tgkill>(2).  The problem with B<PTRACE_KILL> "
"is that it requires the tracee to be in signal-delivery-stop, otherwise it "
"may not work (i.e., may complete successfully but won't kill the tracee).  "
"By contrast, sending a B<SIGKILL> directly has no such limitation."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:598
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEFORK> (since Linux 2.5.46)"
msgid "B<PTRACE_INTERRUPT> (since Linux 3.4)"
msgstr "B<PTRACE_O_TRACEFORK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:612
msgid ""
"Stop a tracee.  If the tracee is running, it will stop with "
"B<PTRACE_EVENT_STOP>.  If the tracee is already stopped by a signal, or "
"receives a signal in parallel with B<PTRACE_INTERRUPT>, it may report a "
"group-stop or a signal-delivery-stop instead of B<PTRACE_EVENT_STOP>.  "
"B<PTRACE_INTERRUPT> only works on tracees attached by B<PTRACE_SEIZE>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:612
#, no-wrap
msgid "B<PTRACE_ATTACH>"
msgstr "B<PTRACE_ATTACH>"

#.  No longer true (removed by Denys Vlasenko, 2011, who remarks:
#.         "I think it isn't true in non-ancient 2.4 and in 2.6/3.x.
#.          Basically, it's not true for any Linux in practical use.
#.  ; the behavior of the tracee is as if it had done a
#.  .BR PTRACE_TRACEME .
#.  The calling process actually becomes the parent of the tracee
#.  process for most purposes (e.g., it will receive
#.  notification of tracee events and appears in
#.  .BR ps (1)
#.  output as the tracee's parent), but a
#.  .BR getppid (2)
#.  by the tracee will still return the PID of the original parent.
#. type: Plain text
#: build/C/man2/ptrace.2:640
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  The tracee is sent a B<SIGSTOP>, but will not necessarily have "
"stopped by the completion of this call; use B<waitpid>(2)  to wait for the "
"tracee to stop.  See the \"Attaching and detaching\" subsection for "
"additional information.  (I<addr> and I<data> are ignored.)"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:640
#, fuzzy, no-wrap
#| msgid "B<PTRACE_O_TRACEEXEC> (since Linux 2.5.46)"
msgid "B<PTRACE_SEIZE> (since Linux 3.4)"
msgstr "B<PTRACE_O_TRACEEXEC> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/ptrace.2:660
msgid ""
"Attach to the process specified in I<pid>, making it a tracee of the calling "
"process.  Unlike B<PTRACE_ATTACH>, B<PTRACE_SEIZE> does not stop the "
"process.  Only a B<PTRACE_SEIZE>d process can accept B<PTRACE_INTERRUPT> and "
"B<PTRACE_LISTEN> commands.  I<addr> must be zero.  I<data> contains a bit "
"mask of ptrace options to activate immediately."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:660
#, no-wrap
msgid "B<PTRACE_DETACH>"
msgstr "B<PTRACE_DETACH>"

#. type: Plain text
#: build/C/man2/ptrace.2:669
#, fuzzy
#| msgid ""
#| "Restarts the stopped child as for B<PTRACE_CONT>, but first detaches from "
#| "the process, undoing the reparenting effect of B<PTRACE_ATTACH>, and the "
#| "effects of B<PTRACE_TRACEME>.  Although perhaps not intended, under Linux "
#| "a traced child can be detached in this way regardless of which method was "
#| "used to initiate tracing.  (I<addr> is ignored.)"
msgid ""
"Restart the stopped tracee as for B<PTRACE_CONT>, but first detach from it.  "
"Under Linux, a tracee can be detached in this way regardless of which method "
"was used to initiate tracing.  (I<addr> is ignored.)"
msgstr ""
"B<PTRACE_CONT> と同様に停止した子プロセスを再開する。ただし まずそのプロセス"
"からの分離 (detach) を行い、 B<PTRACE_ATTACH> での親の切り換えによる効果と "
"B<PTRACE_TRACEME> の効果を取り消す。意図したものではないだろうが、 Linux で"
"は、トレースされている子プロセスはどのような方法でトレースを 開始されたとして"
"も、この方法で分離 (detach) することができる。 (I<addr> は無視される。)"

#. type: SS
#: build/C/man2/ptrace.2:669
#, no-wrap
msgid "Death under ptrace"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:678
msgid ""
"When a (possibly multithreaded) process receives a killing signal (one whose "
"disposition is set to B<SIG_DFL> and whose default action is to kill the "
"process), all threads exit.  Tracees report their death to their tracer(s).  "
"Notification of this event is delivered via B<waitpid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:687
msgid ""
"Note that the killing signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will death from the signal "
"happen on I<all> tracees within a multithreaded process.  (The term \"signal-"
"delivery-stop\" is explained below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:699
msgid ""
"B<SIGKILL> does not generate signal-delivery-stop and therefore the tracer "
"can't suppress it.  B<SIGKILL> kills even within system calls (syscall-exit-"
"stop is not generated prior to death by B<SIGKILL>).  The net effect is that "
"B<SIGKILL> always kills the process (all its threads), even if some threads "
"of the process are ptraced."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:704
msgid ""
"When the tracee calls B<_exit>(2), it reports its death to its tracer.  "
"Other threads are not affected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:708
msgid ""
"When any thread executes B<exit_group>(2), every tracee in its thread group "
"reports its death to its tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:722
msgid ""
"If the B<PTRACE_O_TRACEEXIT> option is on, B<PTRACE_EVENT_EXIT> will happen "
"before actual death.  This applies to exits via B<exit>(2), B<exit_group>"
"(2), and signal deaths (except B<SIGKILL>), and when threads are torn down "
"on B<execve>(2)  in a multithreaded process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:747
msgid ""
"The tracer cannot assume that the ptrace-stopped tracee exists.  There are "
"many scenarios when the tracee may die while stopped (such as B<SIGKILL>).  "
"Therefore, the tracer must be prepared to handle an B<ESRCH> error on any "
"ptrace operation.  Unfortunately, the same error is returned if the tracee "
"exists but is not ptrace-stopped (for commands which require a stopped "
"tracee), or if it is not traced by the process which issued the ptrace "
"call.  The tracer needs to keep track of the stopped/running state of the "
"tracee, and interpret B<ESRCH> as \"tracee died unexpectedly\" only if it "
"knows that the tracee has been observed to enter ptrace-stop.  Note that "
"there is no guarantee that I<waitpid(WNOHANG)> will reliably report the "
"tracee's death status if a ptrace operation returned B<ESRCH>.  I<waitpid"
"(WNOHANG)> may return 0 instead.  In other words, the tracee may be \"not "
"yet fully dead\", but already refusing ptrace requests."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:761
msgid ""
"The tracer can't assume that the tracee I<always> ends its life by reporting "
"I<WIFEXITED(status)> or I<WIFSIGNALED(status)>; there are cases where this "
"does not occur.  For example, if a thread other than thread group leader "
"does an B<execve>(2), it disappears; its PID will never be seen again, and "
"any subsequent ptrace stops will be reported under the thread group leader's "
"PID."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:761
#, no-wrap
msgid "Stopped states"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:763
msgid "A tracee can be in two states: running or stopped."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:767
msgid ""
"There are many kinds of states when the tracee is stopped, and in ptrace "
"discussions they are often conflated.  Therefore, it is important to use "
"precise terms."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:778
msgid ""
"In this manual page, any stopped state in which the tracee is ready to "
"accept ptrace commands from the tracer is called I<ptrace-stop>.  Ptrace-"
"stops can be further subdivided into I<signal-delivery-stop>, I<group-stop>, "
"I<syscall-stop>, and so on.  These stopped states are described in detail "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:783
msgid ""
"When the running tracee enters ptrace-stop, it notifies its tracer using "
"B<waitpid>(2)  (or one of the other \"wait\" system calls).  Most of this "
"manual page assumes that the tracer waits with:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:785
#, no-wrap
msgid "    pid = waitpid(pid_or_minus_1, &status, __WALL);\n"
msgstr ""

#.  Denys Vlasenko:
#.      Do we require __WALL usage, or will just using 0 be ok? (With 0,
#.      I am not 100% sure there aren't ugly corner cases.) Are the
#.      rules different if user wants to use waitid? Will waitid require
#.      WEXITED?
#. type: Plain text
#: build/C/man2/ptrace.2:797
msgid ""
"Ptrace-stopped tracees are reported as returns with I<pid> greater than 0 "
"and I<WIFSTOPPED(status)> true."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:805
msgid ""
"The B<__WALL> flag does not include the B<WSTOPPED> and B<WEXITED> flags, "
"but implies their functionality."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:812
msgid ""
"Setting the B<WCONTINUED> flag when calling B<waitpid>(2)  is not "
"recommended: the \"continued\" state is per-process and consuming it can "
"confuse the real parent of the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:820
msgid ""
"Use of the B<WNOHANG> flag may cause B<waitpid>(2)  to return 0 (\"no wait "
"results available yet\")  even if the tracer knows there should be a "
"notification.  Example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:829
#, no-wrap
msgid ""
"    errno = 0;\n"
"    ptrace(PTRACE_CONT, pid, 0L, 0L);\n"
"    if (errno == ESRCH) {\n"
"        /* tracee is dead */\n"
"        r = waitpid(tracee, &status, __WALL | WNOHANG);\n"
"        /* r can still be 0 here! */\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:852
msgid ""
"The following kinds of ptrace-stops exist: signal-delivery-stops, group-"
"stops, B<PTRACE_EVENT> stops, syscall-stops.  They all are reported by "
"B<waitpid>(2)  with I<WIFSTOPPED(status)> true.  They may be differentiated "
"by examining the value I<statusE<gt>E<gt>8>, and if there is ambiguity in "
"that value, by querying B<PTRACE_GETSIGINFO>.  (Note: the I<WSTOPSIG(status)"
"> macro can't be used to perform this examination, because it returns the "
"value I<(statusE<gt>E<gt>8)\\ &\\ 0xff>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:852
#, no-wrap
msgid "Signal-delivery-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:872
msgid ""
"When a (possibly multithreaded) process receives any signal except "
"B<SIGKILL>, the kernel selects an arbitrary thread which handles the "
"signal.  (If the signal is generated with B<tgkill>(2), the target thread "
"can be explicitly selected by the caller.)  If the selected thread is "
"traced, it enters signal-delivery-stop.  At this point, the signal is not "
"yet delivered to the process, and can be suppressed by the tracer.  If the "
"tracer doesn't suppress the signal, it passes the signal to the tracee in "
"the next ptrace restart request.  This second step of signal delivery is "
"called I<signal injection> in this manual page.  Note that if the signal is "
"blocked, signal-delivery-stop doesn't happen until the signal is unblocked, "
"with the usual exception that B<SIGSTOP> can't be blocked."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:886
msgid ""
"Signal-delivery-stop is observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)> true, with the signal returned by I<WSTOPSIG"
"(status)>.  If the signal is B<SIGTRAP>, this may be a different kind of "
"ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections below for "
"details.  If I<WSTOPSIG(status)> returns a stopping signal, this may be a "
"group-stop; see below."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:886
#, no-wrap
msgid "Signal injection and suppression"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:889
msgid ""
"After signal-delivery-stop is observed by the tracer, the tracer should "
"restart the tracee with the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:891
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, sig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:904
msgid ""
"where B<PTRACE_restart> is one of the restarting ptrace requests.  If I<sig> "
"is 0, then a signal is not delivered.  Otherwise, the signal I<sig> is "
"delivered.  This operation is called I<signal injection> in this manual "
"page, to distinguish it from signal-delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:910
msgid ""
"The I<sig> value may be different from the I<WSTOPSIG(status)> value: the "
"tracer can cause a different signal to be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:926
msgid ""
"Note that a suppressed signal still causes system calls to return "
"prematurely.  In this case system calls will be restarted: the tracer will "
"observe the tracee to reexecute the interrupted system call (or "
"B<restart_syscall>(2)  system call for a few syscalls which use a different "
"mechanism for restarting) if the tracer uses B<PTRACE_SYSCALL>.  Even system "
"calls (such as B<poll>(2))  which are not restartable after signal are "
"restarted after signal is suppressed; however, kernel bugs exist which cause "
"some syscalls to fail with B<EINTR> even though no observable signal is "
"injected to the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:937
msgid ""
"Restarting ptrace commands issued in ptrace-stops other than signal-delivery-"
"stop are not guaranteed to inject a signal, even if I<sig> is nonzero.  No "
"error is reported; a nonzero I<sig> may simply be ignored.  Ptrace users "
"should not try to \"create a new signal\" this way: use B<tgkill>(2)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:944
msgid ""
"The fact that signal injection requests may be ignored when restarting the "
"tracee after ptrace stops that are not signal-delivery-stops is a cause of "
"confusion among ptrace users.  One typical scenario is that the tracer "
"observes group-stop, mistakes it for signal-delivery-stop, restarts the "
"tracee with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:946
#, no-wrap
msgid "    ptrace(PTRACE_restart, pid, 0, stopsig)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:952
msgid ""
"with the intention of injecting I<stopsig>, but I<stopsig> gets ignored and "
"the tracee continues to run."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:972
msgid ""
"The B<SIGCONT> signal has a side effect of waking up (all threads of)  a "
"group-stopped process.  This side effect happens before signal-delivery-"
"stop.  The tracer can't suppress this side effect (it can only suppress "
"signal injection, which only causes the B<SIGCONT> handler to not be "
"executed in the tracee, if such a handler is installed).  In fact, waking up "
"from group-stop may be followed by signal-delivery-stop for signal(s)  "
"I<other than> B<SIGCONT>, if they were pending when B<SIGCONT> was "
"delivered.  In other words, B<SIGCONT> may be not the first signal observed "
"by the tracee after it was sent."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:976
msgid ""
"Stopping signals cause (all threads of) a process to enter group-stop.  This "
"side effect happens after signal injection, and therefore can be suppressed "
"by the tracer."
msgstr ""

#
#.  In the Linux 2.4 sources, in arch/i386/kernel/signal.c::do_signal(),
#.  there is:
#.              /* The debugger continued.  Ignore SIGSTOP.  */
#.              if (signr == SIGSTOP)
#.                      continue;
#. type: Plain text
#: build/C/man2/ptrace.2:986
msgid "In Linux 2.4 and earlier, the B<SIGSTOP> signal can't be injected."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1003
msgid ""
"B<PTRACE_GETSIGINFO> can be used to retrieve a I<siginfo_t> structure which "
"corresponds to the delivered signal.  B<PTRACE_SETSIGINFO> may be used to "
"modify it.  If B<PTRACE_SETSIGINFO> has been used to alter I<siginfo_t>, the "
"I<si_signo> field and the I<sig> parameter in the restarting command must "
"match, otherwise the result is undefined."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1003
#, no-wrap
msgid "Group-stop"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1015
msgid ""
"When a (possibly multithreaded) process receives a stopping signal, all "
"threads stop.  If some threads are traced, they enter a group-stop.  Note "
"that the stopping signal will first cause signal-delivery-stop (on one "
"tracee only), and only after it is injected by the tracer (or after it was "
"dispatched to a thread which isn't traced), will group-stop be initiated on "
"I<all> tracees within the multithreaded process.  As usual, every tracee "
"reports its group-stop separately to the corresponding tracer."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1024
msgid ""
"Group-stop is observed by the tracer as B<waitpid>(2)  returning with "
"I<WIFSTOPPED(status)> true, with the stopping signal available via I<WSTOPSIG"
"(status)>.  The same result is returned by some other classes of ptrace-"
"stops, therefore the recommended practice is to perform the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1026
#, no-wrap
msgid "    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1047
msgid ""
"The call can be avoided if the signal is not B<SIGSTOP>, B<SIGTSTP>, "
"B<SIGTTIN>, or B<SIGTTOU>; only these four signals are stopping signals.  If "
"the tracer sees something else, it can't be a group-stop.  Otherwise, the "
"tracer needs to call B<PTRACE_GETSIGINFO>.  If B<PTRACE_GETSIGINFO> fails "
"with B<EINVAL>, then it is definitely a group-stop.  (Other failure codes "
"are possible, such as B<ESRCH> (\"no such process\") if a B<SIGKILL> killed "
"the tracee.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1056
msgid ""
"As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and until "
"it restarts or kills it, the tracee will not run, and will not send "
"notifications (except B<SIGKILL> death) to the tracer, even if the tracer "
"enters into another B<waitpid>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1070
msgid ""
"The kernel behavior described in the previous paragraph causes a problem "
"with transparent handling of stopping signals.  If the tracer restarts the "
"tracee after group-stop, the stopping signal is effectively ignored\\(emthe "
"tracee doesn't remain stopped, it runs.  If the tracer doesn't restart the "
"tracee before entering into the next B<waitpid>(2), future B<SIGCONT> "
"signals will not be reported to the tracer; this would cause the B<SIGCONT> "
"signals to have no effect on the tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1081
msgid ""
"Since Linux 3.4, there is a method to overcome this problem: instead of "
"B<PTRACE_CONT>, a B<PTRACE_LISTEN> command can be used to restart a tracee "
"in a way where it does not execute, but waits for a new event which it can "
"report via B<waitpid>(2)  (such as when it is restarted by a B<SIGCONT>)."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1081
#, no-wrap
msgid "PTRACE_EVENT stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1087
msgid ""
"If the tracer sets B<PTRACE_O_TRACE_*> options, the tracee will enter ptrace-"
"stops called B<PTRACE_EVENT> stops."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1101
msgid ""
"B<PTRACE_EVENT> stops are observed by the tracer as B<waitpid>(2)  returning "
"with I<WIFSTOPPED(status)>, and I<WSTOPSIG(status)> returns B<SIGTRAP>.  An "
"additional bit is set in the higher byte of the status word: the value "
"I<statusE<gt>E<gt>8> will be"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1103
#, no-wrap
msgid "    (SIGTRAP | PTRACE_EVENT_foo E<lt>E<lt> 8).\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1105
msgid "The following events exist:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1105
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK>"
msgstr "B<PTRACE_EVENT_VFORK>"

#. type: Plain text
#: build/C/man2/ptrace.2:1118
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag.  When the tracee is continued after this stop, it will wait for child "
"to exit/exec before continuing its execution (in other words, the usual "
"behavior on B<vfork>(2))."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1118
#, no-wrap
msgid "B<PTRACE_EVENT_FORK>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: build/C/man2/ptrace.2:1126
msgid ""
"Stop before return from B<fork>(2)  or B<clone>(2)  with the exit signal set "
"to B<SIGCHLD>."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1126
#, no-wrap
msgid "B<PTRACE_EVENT_CLONE>"
msgstr "B<PTRACE_EVENT_CLONE>"

#. type: Plain text
#: build/C/man2/ptrace.2:1130
msgid "Stop before return from B<clone>(2)."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1130
#, no-wrap
msgid "B<PTRACE_EVENT_VFORK_DONE>"
msgstr "B<PTRACE_EVENT_VFORK_DONE>"

#. type: Plain text
#: build/C/man2/ptrace.2:1140
msgid ""
"Stop before return from B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> "
"flag, but after the child unblocked this tracee by exiting or execing."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1146
msgid ""
"For all four stops described above, the stop occurs in the parent (i.e., the "
"tracee), not in the newly created thread.  B<PTRACE_GETEVENTMSG> can be used "
"to retrieve the new thread's ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1146
#, no-wrap
msgid "B<PTRACE_EVENT_EXEC>"
msgstr "B<PTRACE_EVENT_EXEC>"

#. type: Plain text
#: build/C/man2/ptrace.2:1153
msgid ""
"Stop before return from B<execve>(2).  Since Linux 3.0, "
"B<PTRACE_GETEVENTMSG> returns the former thread ID."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1153
#, no-wrap
msgid "B<PTRACE_EVENT_EXIT>"
msgstr "B<PTRACE_EVENT_EXIT>"

#. type: Plain text
#: build/C/man2/ptrace.2:1169
msgid ""
"Stop before exit (including death from B<exit_group>(2)), signal death, or "
"exit caused by B<execve>(2)  in a multithreaded process.  "
"B<PTRACE_GETEVENTMSG> returns the exit status.  Registers can be examined "
"(unlike when \"real\" exit happens).  The tracee is still alive; it needs to "
"be B<PTRACE_CONT>ed or B<PTRACE_DETACH>ed to finish exiting."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1169
#, fuzzy, no-wrap
#| msgid "B<PTRACE_EVENT_FORK>"
msgid "B<PTRACE_EVENT_STOP>"
msgstr "B<PTRACE_EVENT_FORK>"

#. type: Plain text
#: build/C/man2/ptrace.2:1174
msgid "Stop induced by B<PTRACE_INTERRUPT> command."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1186
msgid ""
"B<PTRACE_GETSIGINFO> on B<PTRACE_EVENT> stops returns B<SIGTRAP> in "
"I<si_signo>, with I<si_code> set to I<(eventE<lt>E<lt>8)\\ |\\ SIGTRAP>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1186
#, no-wrap
msgid "Syscall-stops"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1199
msgid ""
"If the tracee was restarted by B<PTRACE_SYSCALL>, the tracee enters syscall-"
"enter-stop just prior to entering any system call.  If the tracer restarts "
"the tracee with B<PTRACE_SYSCALL>, the tracee enters syscall-exit-stop when "
"the system call is finished, or if it is interrupted by a signal.  (That is, "
"signal-delivery-stop never happens between syscall-enter-stop and syscall-"
"exit-stop; it happens I<after> syscall-exit-stop.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1213
msgid ""
"Other possibilities are that the tracee may stop in a B<PTRACE_EVENT> stop, "
"exit (if it entered B<_exit>(2)  or B<exit_group>(2)), be killed by "
"B<SIGKILL>, or die silently (if it is a thread group leader, the B<execve>"
"(2)  happened in another thread, and that thread is not traced by the same "
"tracer; this situation is discussed later)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1228
msgid ""
"Syscall-enter-stop and syscall-exit-stop are observed by the tracer as "
"B<waitpid>(2)  returning with I<WIFSTOPPED(status)> true, and I<WSTOPSIG"
"(status)> giving B<SIGTRAP>.  If the B<PTRACE_O_TRACESYSGOOD> option was set "
"by the tracer, then I<WSTOPSIG(status)> will give the value I<(SIGTRAP\\ |\\ "
"0x80)>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1234
msgid ""
"Syscall-stops can be distinguished from signal-delivery-stop with B<SIGTRAP> "
"by querying B<PTRACE_GETSIGINFO> for the following cases:"
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1234
#, no-wrap
msgid "I<si_code> E<lt>= 0"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1246
msgid ""
"B<SIGTRAP> was delivered as a result of a user-space action, for example, a "
"system call (B<tgkill>(2), B<kill>(2), B<sigqueue>(3), etc.), expiration of "
"a POSIX timer, change of state on a POSIX message queue, or completion of an "
"asynchronous I/O request."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1246
#, no-wrap
msgid "I<si_code> == SI_KERNEL (0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1250
msgid "B<SIGTRAP> was sent by the kernel."
msgstr ""

#. type: TP
#: build/C/man2/ptrace.2:1250
#, no-wrap
msgid "I<si_code> == SIGTRAP or I<si_code> == (SIGTRAP|0x80)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1253
msgid "This is a syscall-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1258
msgid ""
"However, syscall-stops happen very often (twice per system call), and "
"performing B<PTRACE_GETSIGINFO> for every syscall-stop may be somewhat "
"expensive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1281
msgid ""
"Some architectures allow the cases to be distinguished by examining "
"registers.  For example, on x86, I<rax> == -B<ENOSYS> in syscall-enter-"
"stop.  Since B<SIGTRAP> (like any other signal) always happens I<after> "
"syscall-exit-stop, and at this point I<rax> almost never contains -"
"B<ENOSYS>, the B<SIGTRAP> looks like \"syscall-stop which is not syscall-"
"enter-stop\"; in other words, it looks like a \"stray syscall-exit-stop\" "
"and can be detected this way.  But such detection is fragile and is best "
"avoided."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1287
msgid ""
"Using the B<PTRACE_O_TRACESYSGOOD> option is the recommended method to "
"distinguish syscall-stops from other kinds of ptrace-stops, since it is "
"reliable and does not incur a performance penalty."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1298
msgid ""
"Syscall-enter-stop and syscall-exit-stop are indistinguishable from each "
"other by the tracer.  The tracer needs to keep track of the sequence of "
"ptrace-stops in order to not misinterpret syscall-enter-stop as syscall-exit-"
"stop or vice versa.  The rule is that syscall-enter-stop is always followed "
"by syscall-exit-stop, B<PTRACE_EVENT> stop or the tracee's death; no other "
"kinds of ptrace-stop can occur in between."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1303
msgid ""
"If after syscall-enter-stop, the tracer uses a restarting command other than "
"B<PTRACE_SYSCALL>, syscall-exit-stop is not generated."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1315
msgid ""
"B<PTRACE_GETSIGINFO> on syscall-stops returns B<SIGTRAP> in I<si_signo>, "
"with I<si_code> set to B<SIGTRAP> or I<(SIGTRAP|0x80)>."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1315
#, no-wrap
msgid "PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops"
msgstr ""

#
#.  FIXME
#.  document stops occurring with PTRACE_SINGLESTEP, PTRACE_SYSEMU,
#.  PTRACE_SYSEMU_SINGLESTEP
#. type: Plain text
#: build/C/man2/ptrace.2:1321
msgid "[Details of these kinds of stops are yet to be documented.]"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1321
#, no-wrap
msgid "Informational and restarting ptrace commands"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1331
msgid ""
"Most ptrace commands (all except B<PTRACE_ATTACH>, B<PTRACE_SEIZE>, "
"B<PTRACE_TRACEME>, B<PTRACE_INTERRUPT>, and B<PTRACE_KILL>)  require the "
"tracee to be in a ptrace-stop, otherwise they fail with B<ESRCH>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1336
msgid ""
"When the tracee is in ptrace-stop, the tracer can read and write data to the "
"tracee using informational commands.  These commands leave the tracee in "
"ptrace-stopped state:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1348
#, no-wrap
msgid ""
"    ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);\n"
"    ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);\n"
"    ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &struct);\n"
"    ptrace(PTRACE_GETREGSET, pid, NT_foo, &iov);\n"
"    ptrace(PTRACE_SETREGSET, pid, NT_foo, &iov);\n"
"    ptrace(PTRACE_GETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_SETSIGINFO, pid, 0, &siginfo);\n"
"    ptrace(PTRACE_GETEVENTMSG, pid, 0, &long_var);\n"
"    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1360
msgid ""
"Note that some errors are not reported.  For example, setting signal "
"information (I<siginfo>)  may have no effect in some ptrace-stops, yet the "
"call may succeed (return 0 and not set I<errno>); querying "
"B<PTRACE_GETEVENTMSG> may succeed and return some random value if current "
"ptrace-stop is not documented as returning a meaningful event message."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1362
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1364
#, no-wrap
msgid "    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1373
msgid ""
"affects one tracee.  The tracee's current flags are replaced.  Flags are "
"inherited by new tracees created and \"auto-attached\" via active "
"B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or B<PTRACE_O_TRACECLONE> "
"options."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1376
msgid ""
"Another group of commands makes the ptrace-stopped tracee run.  They have "
"the form:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1378
#, no-wrap
msgid "    ptrace(cmd, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1399
msgid ""
"where I<cmd> is B<PTRACE_CONT>, B<PTRACE_LISTEN>, B<PTRACE_DETACH>, "
"B<PTRACE_SYSCALL>, B<PTRACE_SINGLESTEP>, B<PTRACE_SYSEMU>, or "
"B<PTRACE_SYSEMU_SINGLESTEP>.  If the tracee is in signal-delivery-stop, "
"I<sig> is the signal to be injected (if it is nonzero).  Otherwise, I<sig> "
"may be ignored.  (When restarting a tracee from a ptrace-stop other than "
"signal-delivery-stop, recommended practice is to always pass 0 in I<sig>.)"
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1399
#, no-wrap
msgid "Attaching and detaching"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1401
msgid "A thread can be attached to the tracer using the call"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1403
#, no-wrap
msgid "    ptrace(PTRACE_ATTACH, pid, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1405 build/C/man2/ptrace.2:1895
msgid "or"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1407
#, no-wrap
msgid "    ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);\n"
msgstr ""

#
#.  FIXME: Describe how to attach to a thread which is already
#.         group-stopped.
#. type: Plain text
#: build/C/man2/ptrace.2:1432
msgid ""
"B<PTRACE_ATTACH> sends B<SIGSTOP> to this thread.  If the tracer wants this "
"B<SIGSTOP> to have no effect, it needs to suppress it.  Note that if other "
"signals are concurrently sent to this thread during attach, the tracer may "
"see the tracee enter signal-delivery-stop with other signal(s) first! The "
"usual practice is to reinject these signals until B<SIGSTOP> is seen, then "
"suppress B<SIGSTOP> injection.  The design bug here is that a ptrace attach "
"and a concurrently delivered B<SIGSTOP> may race and the concurrent "
"B<SIGSTOP> may be lost."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1439
msgid ""
"Since attaching sends B<SIGSTOP> and the tracer usually suppresses it, this "
"may cause a stray B<EINTR> return from the currently executing system call "
"in the tracee, as described in the \"Signal injection and suppression\" "
"section."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1451
msgid ""
"Since Linux 3.4, B<PTRACE_SEIZE> can be used instead of B<PTRACE_ATTACH>.  "
"B<PTRACE_SEIZE> does not stop the attached process.  If you need to stop it "
"after attach (or at any other time) without sending it any signals, use "
"B<PTRACE_INTERRUPT> command."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1453
msgid "The request"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1455
#, no-wrap
msgid "    ptrace(PTRACE_TRACEME, 0, 0, 0);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1461
msgid ""
"turns the calling thread into a tracee.  The thread continues to run "
"(doesn't enter ptrace-stop).  A common practice is to follow the "
"B<PTRACE_TRACEME> with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1463
#, no-wrap
msgid "    raise(SIGSTOP);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1466
msgid ""
"and allow the parent (which is our tracer now) to observe our signal-"
"delivery-stop."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1490
msgid ""
"If the B<PTRACE_O_TRACEFORK>, B<PTRACE_O_TRACEVFORK>, or "
"B<PTRACE_O_TRACECLONE> options are in effect, then children created by, "
"respectively, B<vfork>(2)  or B<clone>(2)  with the B<CLONE_VFORK> flag, "
"B<fork>(2)  or B<clone>(2)  with the exit signal set to B<SIGCHLD>, and "
"other kinds of B<clone>(2), are automatically attached to the same tracer "
"which traced their parent.  B<SIGSTOP> is delivered to the children, causing "
"them to enter signal-delivery-stop after they exit the system call which "
"created them."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1492
msgid "Detaching of the tracee is performed by:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1494
#, no-wrap
msgid "    ptrace(PTRACE_DETACH, pid, 0, sig);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1502
msgid ""
"B<PTRACE_DETACH> is a restarting operation; therefore it requires the tracee "
"to be in ptrace-stop.  If the tracee is in signal-delivery-stop, a signal "
"can be injected.  Otherwise, the I<sig> parameter may be silently ignored."
msgstr ""

#.  FIXME: Describe how to detach from a group-stopped tracee so that it
#.         doesn't run, but continues to wait for SIGCONT.
#. type: Plain text
#: build/C/man2/ptrace.2:1526
msgid ""
"If the tracee is running when the tracer wants to detach it, the usual "
"solution is to send B<SIGSTOP> (using B<tgkill>(2), to make sure it goes to "
"the correct thread), wait for the tracee to stop in signal-delivery-stop for "
"B<SIGSTOP> and then detach it (suppressing B<SIGSTOP> injection).  A design "
"bug is that this can race with concurrent B<SIGSTOP>s.  Another complication "
"is that the tracee may enter other ptrace-stops and needs to be restarted "
"and waited for again, until B<SIGSTOP> is seen.  Yet another complication is "
"to be sure that the tracee is not already ptrace-stopped, because no signal "
"delivery happens while it is\\(emnot even B<SIGSTOP>."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1534
msgid ""
"If the tracer dies, all tracees are automatically detached and restarted, "
"unless they were in group-stop.  Handling of restart from group-stop is "
"currently buggy, but the \"as planned\" behavior is to leave tracee stopped "
"and waiting for B<SIGCONT>.  If the tracee is restarted from signal-delivery-"
"stop, the pending signal is injected."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1534
#, no-wrap
msgid "execve(2) under ptrace"
msgstr ""

#
#.  clone(2) CLONE_THREAD says:
#.      If  any  of the threads in a thread group performs an execve(2),
#.      then all threads other than the thread group leader are terminated,
#.      and the new program is executed in the thread group leader.
#.  In kernel 3.1 sources, see fs/exec.c::de_thread()
#. type: Plain text
#: build/C/man2/ptrace.2:1553
msgid ""
"When one thread in a multithreaded process calls B<execve>(2), the kernel "
"destroys all other threads in the process, and resets the thread ID of the "
"execing thread to the thread group ID (process ID).  (Or, to put things "
"another way, when a multithreaded process does an B<execve>(2), at "
"completion of the call, it appears as though the B<execve>(2)  occurred in "
"the thread group leader, regardless of which thread did the B<execve>(2).)  "
"This resetting of the thread ID looks very confusing to tracers:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1563
msgid ""
"All other threads stop in B<PTRACE_EVENT_EXIT> stop, if the "
"B<PTRACE_O_TRACEEXIT> option was turned on.  Then all other threads except "
"the thread group leader report death as if they exited via B<_exit>(2)  with "
"exit code 0."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1571
msgid ""
"The execing tracee changes its thread ID while it is in the B<execve>(2).  "
"(Remember, under ptrace, the \"pid\" returned from B<waitpid>(2), or fed "
"into ptrace calls, is the tracee's thread ID.)  That is, the tracee's thread "
"ID is reset to be the same as its process ID, which is the same as the "
"thread group leader's thread ID."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1577
msgid ""
"Then a B<PTRACE_EVENT_EXEC> stop happens, if the B<PTRACE_O_TRACEEXEC> "
"option was turned on."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1598
msgid ""
"If the thread group leader has reported its B<PTRACE_EVENT_EXIT> stop by "
"this time, it appears to the tracer that the dead thread leader \"reappears "
"from nowhere\".  (Note: the thread group leader does not report death via "
"I<WIFEXITED(status)> until there is at least one other live thread.  This "
"eliminates the possibility that the tracer will see it dying and then "
"reappearing.)  If the thread group leader was still alive, for the tracer "
"this may look as if thread group leader returns from a different system call "
"than it entered, or even \"returned from a system call even though it was "
"not in any system call\".  If the thread group leader was not traced (or was "
"traced by a different tracer), then during B<execve>(2)  it will appear as "
"if it has become a tracee of the tracer of the execing tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1601
msgid ""
"All of the above effects are the artifacts of the thread ID change in the "
"tracee."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1621
msgid ""
"The B<PTRACE_O_TRACEEXEC> option is the recommended tool for dealing with "
"this situation.  First, it enables B<PTRACE_EVENT_EXEC> stop, which occurs "
"before B<execve>(2)  returns.  In this stop, the tracer can use "
"B<PTRACE_GETEVENTMSG> to retrieve the tracee's former thread ID.  (This "
"feature was introduced in Linux 3.0).  Second, the B<PTRACE_O_TRACEEXEC> "
"option disables legacy B<SIGTRAP> generation on B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1627
msgid ""
"When the tracer receives B<PTRACE_EVENT_EXEC> stop notification, it is "
"guaranteed that except this tracee and the thread group leader, no other "
"threads from the process are alive."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1635
msgid ""
"On receiving the B<PTRACE_EVENT_EXEC> stop notification, the tracer should "
"clean up all its internal data structures describing the threads of this "
"process, and retain only one data structure\\(emone which describes the "
"single still running tracee, with"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1637
#, no-wrap
msgid "    thread ID == thread group ID == process ID.\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1641
msgid "Example: two threads call B<execve>(2)  at the same time:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1652
#, no-wrap
msgid ""
"*** we get syscall-enter-stop in thread 1: **\n"
"PID1 execve(\"/bin/foo\", \"foo\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 1 **\n"
"*** we get syscall-enter-stop in thread 2: **\n"
"PID2 execve(\"/bin/bar\", \"bar\" E<lt>unfinished ...E<gt>\n"
"*** we issue PTRACE_SYSCALL for thread 2 **\n"
"*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **\n"
"*** we get syscall-exit-stop for PID0: **\n"
"PID0 E<lt>... execve resumedE<gt> )             = 0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1675
msgid ""
"If the B<PTRACE_O_TRACEEXEC> option is I<not> in effect for the execing "
"tracee, the kernel delivers an extra B<SIGTRAP> to the tracee after B<execve>"
"(2)  returns.  This is an ordinary signal (similar to one which can be "
"generated by I<kill -TRAP>), not a special kind of ptrace-stop.  Employing "
"B<PTRACE_GETSIGINFO> for this signal returns I<si_code> set to 0 "
"(I<SI_USER>).  This signal may be blocked by signal mask, and thus may be "
"delivered (much) later."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1694
msgid ""
"Usually, the tracer (for example, B<strace>(1))  would not want to show this "
"extra post-execve B<SIGTRAP> signal to the user, and would suppress its "
"delivery to the tracee (if B<SIGTRAP> is set to B<SIG_DFL>, it is a killing "
"signal).  However, determining I<which> B<SIGTRAP> to suppress is not easy.  "
"Setting the B<PTRACE_O_TRACEEXEC> option and thus suppressing this extra "
"B<SIGTRAP> is the recommended approach."
msgstr ""

#. type: SS
#: build/C/man2/ptrace.2:1694
#, no-wrap
msgid "Real parent"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1701
msgid ""
"The ptrace API (ab)uses the standard UNIX parent/child signaling over "
"B<waitpid>(2).  This used to cause the real parent of the process to stop "
"receiving several kinds of B<waitpid>(2)  notifications when the child "
"process is traced by some other process."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1704
msgid ""
"Many of these bugs have been fixed, but as of Linux 2.6.38 several still "
"exist; see BUGS below."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1706
msgid "As of Linux 2.6.38, the following is believed to work correctly:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1714
msgid ""
"exit/death by signal is reported first to the tracer, then, when the tracer "
"consumes the B<waitpid>(2)  result, to the real parent (to the real parent "
"only when the whole multithreaded process exits).  If the tracer and the "
"real parent are the same process, the report is sent only once."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1728
#, fuzzy
#| msgid ""
#| "On success, B<PTRACE_PEEK*> requests return the requested data, while "
#| "other requests return zero.  On error, all requests return -1, and "
#| "I<errno> is set appropriately.  Since the value returned by a successful "
#| "B<PTRACE_PEEK*> request may be -1, the caller must check I<errno> after "
#| "such requests to determine whether or not an error occurred."
msgid ""
"On success, B<PTRACE_PEEK*> requests return the requested data, while other "
"requests return zero.  On error, all requests return -1, and I<errno> is set "
"appropriately.  Since the value returned by a successful B<PTRACE_PEEK*> "
"request may be -1, the caller must clear I<errno> before the call, and then "
"check it afterward to determine whether or not an error occurred."
msgstr ""
"成功すると、 B<PTRACE_PEEK*> の場合は要求したデータを返し、 それ以外の場合は "
"0 を返す。 エラーの場合は -1 を返し、 I<errno> が適切に設定される。 "
"B<PTRACE_PEEK*> が成功して返す値も　-1 になることがあるため、 そのような要求"
"の場合には、呼び出し元は I<errno> を調べ、エラーか発生したのかどうかを判断し"
"なければならない。"

#. type: Plain text
#: build/C/man2/ptrace.2:1732
msgid ""
"(i386 only) There was an error with allocating or freeing a debug register."
msgstr "(i386 のみ) デバッグレジスタの確保または解放でエラーが発生した。"

#. type: Plain text
#: build/C/man2/ptrace.2:1743
#, fuzzy
#| msgid ""
#| "There was an attempt to read from or write to an invalid area in the "
#| "parent's or child's memory, probably because the area wasn't mapped or "
#| "accessible.  Unfortunately, under Linux, different variations of this "
#| "fault will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgid ""
"There was an attempt to read from or write to an invalid area in the "
"tracer's or the tracee's memory, probably because the area wasn't mapped or "
"accessible.  Unfortunately, under Linux, different variations of this fault "
"will return B<EIO> or B<EFAULT> more or less arbitrarily."
msgstr ""
"親プロセスまたは子プロセスのメモリの不正な領域に読み書きしようとした。 おそら"
"くその領域がマッピングされていないか、 その領域へのアクセスが許されていないか"
"である。 不運なことに、Linux ではこのようなエラーの場合、多かれ少なかれ 恣意"
"的に B<EIO> を返したり B<EFAULT> を返したりすることがある。"

#. type: Plain text
#: build/C/man2/ptrace.2:1746
msgid "An attempt was made to set an invalid option."
msgstr "不正なオプションを設定しようとした。"

#. type: Plain text
#: build/C/man2/ptrace.2:1753
#, fuzzy
#| msgid ""
#| "I<request> is invalid, or an attempt was made to read from or write to an "
#| "invalid area in the parent's or child's memory, or there was a word-"
#| "alignment violation, or an invalid signal was specified during a restart "
#| "request."
msgid ""
"I<request> is invalid, or an attempt was made to read from or write to an "
"invalid area in the tracer's or the tracee's memory, or there was a word-"
"alignment violation, or an invalid signal was specified during a restart "
"request."
msgstr ""
"I<request> が不正である。 または、親プロセスまたは子プロセスのメモリの 不正な"
"領域に読み書きしようとした。 または、ワード境界違反があった。 または、実行再"
"開の要求で不正なシグナルを指定した。"

#. type: Plain text
#: build/C/man2/ptrace.2:1766
#, fuzzy
#| msgid ""
#| "The specified process cannot be traced.  This could be because the parent "
#| "has insufficient privileges (the required capability is "
#| "B<CAP_SYS_PTRACE>); unprivileged processes cannot trace processes that "
#| "they cannot send signals to or those running set-user-ID/set-group-ID "
#| "programs, for obvious reasons.  Alternatively, the process may already be "
#| "being traced, or be B<init>(8)  (PID 1)."
msgid ""
"The specified process cannot be traced.  This could be because the tracer "
"has insufficient privileges (the required capability is B<CAP_SYS_PTRACE>); "
"unprivileged processes cannot trace processes that they cannot send signals "
"to or those running set-user-ID/set-group-ID programs, for obvious reasons.  "
"Alternatively, the process may already be being traced, or (on kernels "
"before 2.6.26) be B<init>(8)  (PID 1)."
msgstr ""
"指定したプロセスをトレースすることができない。これは親プロセスが 必要な権限 "
"(必要なケーパビリティは B<CAP_SYS_PTRACE>)  を持っていないことが原因の場合が"
"ある。 分かりやすい理由を挙げるなら、 非特権プロセスはシグナルを送ることがで"
"きないプロセスをトレースできないし、 set-user-ID/set-group-ID プログラムを実"
"行しているプロセスはトレースできない。 または、プロセスはすでにトレース中であ"
"る、 または B<init>(8)  プロセス (PID が 1) である。"

#. type: Plain text
#: build/C/man2/ptrace.2:1771
#, fuzzy
#| msgid ""
#| "The specified process does not exist, or is not currently being traced by "
#| "the caller, or is not stopped (for requests that require that)."
msgid ""
"The specified process does not exist, or is not currently being traced by "
"the caller, or is not stopped (for requests that require a stopped tracee)."
msgstr ""
"指定したプロセスが存在しない。 または、指定したプロセスは呼び出したプロセス"
"が 現在トレース中の子プロセスではない。 または、指定したプロセスが停止してい"
"ない (停止していることが必要な要求の場合)。"

#. type: Plain text
#: build/C/man2/ptrace.2:1773
msgid "SVr4, 4.3BSD."
msgstr "SVr4, 4.3BSD."

#. type: Plain text
#: build/C/man2/ptrace.2:1788
#, fuzzy
#| msgid ""
#| "Although arguments to B<ptrace>()  are interpreted according to the "
#| "prototype given, glibc currently declares B<ptrace>()  as a variadic "
#| "function with only the I<request> argument fixed.  This means that "
#| "unneeded trailing arguments may be omitted, though doing so makes use of "
#| "undocumented B<gcc>(1)  behavior."
msgid ""
"Although arguments to B<ptrace>()  are interpreted according to the "
"prototype given, glibc currently declares B<ptrace>()  as a variadic "
"function with only the I<request> argument fixed.  It is recommended to "
"always supply four arguments, even if the requested operation does not use "
"them, setting unused/ignored arguments to I<0L> or I<(void\\ *)\\ 0>."
msgstr ""
"B<ptrace>()  の引き数は上のようなプロトタイプに基づいて解釈されるが、 glibc "
"では、現在のところ B<ptrace>()  は I<request> 引き数だけが固定の可変長引き数"
"関数として 宣言されている。 これは必要なければ残りの引き数は省略可能であるこ"
"とを意味するが、 それは B<gcc>(1)  の明文化されていない動作を利用していること"
"になる。"

#.  See commit 00cd5c37afd5f431ac186dd131705048c0a11fdb
#. type: Plain text
#: build/C/man2/ptrace.2:1793
#, fuzzy
#| msgid "B<init>(8), the process with PID 1, may not be traced."
msgid ""
"In Linux kernels before 2.6.26, B<init>(8), the process with PID 1, may not "
"be traced."
msgstr "B<init>(8)  すなわち PID が 1 のプロセスはトレースすることができない。"

#.  See http://lkml.org/lkml/2008/5/8/375
#. type: Plain text
#: build/C/man2/ptrace.2:1800
#, fuzzy
#| msgid ""
#| "The layout of the contents of memory and the USER area are quite OS- and "
#| "architecture-specific.  The offset supplied, and the data returned, might "
#| "not entirely match with the definition of I<struct user>."
msgid ""
"The layout of the contents of memory and the USER area are quite operating-"
"system- and architecture-specific.  The offset supplied, and the data "
"returned, might not entirely match with the definition of I<struct user>."
msgstr ""
"メモリや USER 領域の内容や配置は OS ごと、アーキテクチャごとに 非常に依存す"
"る。 オフセットが指定された場合、返されるデータは I<struct user> の定義と完全"
"に一致しないこともありえる。"

#. type: Plain text
#: build/C/man2/ptrace.2:1803
#, fuzzy
#| msgid ""
#| "The size of a \"word\" is determined by the OS variant (e.g., for 32-bit "
#| "Linux it is 32 bits, etc.)."
msgid ""
"The size of a \"word\" is determined by the operating-system variant (e.g., "
"for 32-bit Linux it is 32 bits)."
msgstr ""
"「ワード (word) 」の大きさは OS によって決まる。 (例えば、32 ビットの Linux "
"では 32 ビットである、など。)"

#. type: Plain text
#: build/C/man2/ptrace.2:1811
#, fuzzy
#| msgid ""
#| "This page documents the way the B<ptrace>()  call works currently in "
#| "Linux.  Its behavior differs noticeably on other flavors of UNIX.  In any "
#| "case, use of B<ptrace>()  is highly OS- and architecture-specific."
msgid ""
"This page documents the way the B<ptrace>()  call works currently in Linux.  "
"Its behavior differs noticeably on other flavors of UNIX.  In any case, use "
"of B<ptrace>()  is highly specific to the operating system and architecture."
msgstr ""
"このマニュアルは現在の Linux における B<ptrace>()  コールの動作について記述し"
"ている。他の UNIX では その動作は著しく異なる。 いかなる場合も B<ptrace>()  "
"を使うと OS やアーキテクチャに非常に依存したものになる。"

#. type: Plain text
#: build/C/man2/ptrace.2:1822
#, fuzzy
#| msgid ""
#| "On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
#| "different value than the one for 2.4.  This leads to applications "
#| "compiled with such headers failing when run on 2.4 kernels.  This can be "
#| "worked around by redefining B<PTRACE_SETOPTIONS> to "
#| "B<PTRACE_OLDSETOPTIONS>, if that is defined."
msgid ""
"On hosts with 2.6 kernel headers, B<PTRACE_SETOPTIONS> is declared with a "
"different value than the one for 2.4.  This leads to applications compiled "
"with 2.6 kernel headers failing when run on 2.4 kernels.  This can be worked "
"around by redefining B<PTRACE_SETOPTIONS> to B<PTRACE_OLDSETOPTIONS>, if "
"that is defined."
msgstr ""
"カーネル 2.6 のヘッダがインストールされたホストでは、 B<PTRACE_SETOPTIONS> は"
"カーネル 2.4 のヘッダとは異なる値で宣言される。 このため、カーネル 2.6 のヘッ"
"ダでコンパイルされたアプリケーションは カーネル 2.4 では正しく動作しない。 こ"
"の問題は、 B<PTRACE_SETOPTIONS> が定義されていた際は、 B<PTRACE_SETOPTIONS> "
"を B<PTRACE_OLDSETOPTIONS> に定義し直すことで対処できる。"

#. type: Plain text
#: build/C/man2/ptrace.2:1825
msgid ""
"Group-stop notifications are sent to the tracer, but not to real parent.  "
"Last confirmed on 2.6.38.6."
msgstr ""

#.  Note from Denys Vlasenko:
#.      Here "exits" means any kind of death - _exit, exit_group,
#.      signal death. Signal death and exit_group cases are trivial,
#.      though: since signal death and exit_group kill all other threads
#.      too, "until all other threads exit" thing happens rather soon
#.      in these cases. Therefore, only _exit presents observably
#.      puzzling behavior to ptrace users: thread leader _exit's,
#.      but WIFEXITED isn't reported! We are trying to explain here
#.      why it is so.
#.   FIXME: ^^^ need to test/verify this scenario
#. type: Plain text
#: build/C/man2/ptrace.2:1856
msgid ""
"If a thread group leader is traced and exits by calling B<_exit>(2), a "
"B<PTRACE_EVENT_EXIT> stop will happen for it (if requested), but the "
"subsequent B<WIFEXITED> notification will not be delivered until all other "
"threads exit.  As explained above, if one of other threads calls B<execve>"
"(2), the death of the thread group leader will I<never> be reported.  If the "
"execed thread is not traced by this tracer, the tracer will never know that "
"B<execve>(2)  happened.  One possible workaround is to B<PTRACE_DETACH> the "
"thread group leader instead of restarting it in this case.  Last confirmed "
"on 2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1866
msgid ""
"A B<SIGKILL> signal may still cause a B<PTRACE_EVENT_EXIT> stop before "
"actual signal death.  This may be changed in the future; B<SIGKILL> is meant "
"to always immediately kill tasks even under ptrace.  Last confirmed on "
"2.6.38.6."
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1884
msgid ""
"Some system calls return with B<EINTR> if a signal was sent to a tracee, but "
"delivery was suppressed by the tracer.  (This is very typical operation: it "
"is usually done by debuggers on every attach, in order to not introduce a "
"bogus B<SIGSTOP>).  As of Linux 3.2.9, the following system calls are "
"affected (this list is likely incomplete): B<epoll_wait>(2), and B<read>(2)  "
"from an B<inotify>(7)  file descriptor.  The usual symptom of this bug is "
"that when you attach to a quiescent process with the command"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1886
#, no-wrap
msgid "    strace -p E<lt>process-IDE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1889
msgid "then, instead of the usual and expected one-line output such as"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1892
#, no-wrap
msgid "    restart_syscall(E<lt>... resuming interrupted call ...E<gt>_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1898
#, no-wrap
msgid "    select(6, [5], NULL, [5], NULL_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1902
msgid ""
"('_' denotes the cursor position), you observe more than one line.  For "
"example:"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1906
#, no-wrap
msgid ""
"    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0\n"
"    epoll_wait(4,_\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1927
msgid ""
"What is not visible here is that the process was blocked in B<epoll_wait>"
"(2)  before B<strace>(1)  has attached to it.  Attaching caused B<epoll_wait>"
"(2)  to return to user space with the error B<EINTR>.  In this particular "
"case, the program reacted to B<EINTR> by checking the current time, and then "
"executing B<epoll_wait>(2)  again.  (Programs which do not expect such "
"\"stray\" B<EINTR> errors may behave in an unintended way upon an B<strace>"
"(1)  attach.)"
msgstr ""

#. type: Plain text
#: build/C/man2/ptrace.2:1941
msgid ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2), B<gettid>"
"(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2), B<waitpid>(2), B<exec>(3), "
"B<capabilities>(7), B<signal>(7)"
msgstr ""
"B<gdb>(1), B<strace>(1), B<clone>(2), B<execve>(2), B<fork>(2),\n"
"B<gettid>(2), B<sigaction>(2), B<tgkill>(2), B<vfork>(2),\n"
"B<waitpid>(2), B<exec>(3), B<capabilities>(7), B<signal>(7)"

#. type: TH
#: build/C/man2/quotactl.2:27
#, no-wrap
msgid "QUOTACTL"
msgstr "QUOTACTL"

#. type: TH
#: build/C/man2/quotactl.2:27
#, no-wrap
msgid "2010-06-16"
msgstr "2010-06-16"

#. type: Plain text
#: build/C/man2/quotactl.2:30
msgid "quotactl - manipulate disk quotas"
msgstr "quotactl - ディスク quota を操作する"

#. type: Plain text
#: build/C/man2/quotactl.2:34
#, no-wrap
msgid ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/quota.hE<gt>>\n"
"B<#include E<lt>xfs/xqm.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/quotactl.2:37
#, no-wrap
msgid "B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, caddr_t >I<addr>B<);>\n"
msgstr "B<int quotactl(int >I<cmd>B<, const char *>I<special>B<, int >I<id>B<, caddr_t >I<addr>B<);>\n"

#. type: Plain text
#: build/C/man2/quotactl.2:49
#, fuzzy
#| msgid ""
#| "The quota system defines for each user and/or group a soft limit and a "
#| "hard limit bounding the amount of disk space that can be used on a given "
#| "file system.  The hard limit cannot be crossed.  The soft limit can be "
#| "crossed, but warnings will ensue.  Moreover, the user cannot be above the "
#| "soft limit for more than one week (by default)  at a time: after this "
#| "week the soft limit counts as hard limit."
msgid ""
"The quota system can be used to set per-user and per-group limits on the "
"amount of disk space used on a file system.  For each user and/or group, a "
"soft limit and a hard limit can be set for each file system.  The hard limit "
"can't be exceeded.  The soft limit can be exceeded, but warnings will "
"ensue.  Moreover, the user can't exceed the soft limit for more than one "
"week (by default) at a time; after this time, the soft limit counts as a "
"hard limit."
msgstr ""
"quota システムは、各々のユーザ及び/またはグループに対して、 ソフト・リミット"
"及びハード・リミットを定める。これはあるファイル・システムで 使用する事が出来"
"るディスク容量を制限する。 ハード・リミットは超過することは出来ない。 ソフ"
"ト・リミットは超過する事が出来るが、警告が発せられる。 更に、(デフォルトで"
"は) 一週間以上ソフト・リミットを超過したままに しておく事はできない: 一週間経"
"過した後はハード・リミットを超過したと みなされる。"

#. type: Plain text
#: build/C/man2/quotactl.2:74
#, fuzzy
#| msgid ""
#| "The B<quotactl>()  system call manipulates these quota.  Its first "
#| "argument is of the form B<QCMD(>I<subcmd>B<,>I<type>B<)> where I<type> is "
#| "either B<USRQUOTA> or B<GRPQUOTA> (for user quota and group quota, "
#| "respectively), and I<subcmd> is described below."
msgid ""
"The B<quotactl>()  call manipulates disk quotas.  The I<cmd> argument "
"indicates a command to be applied to the user or group ID specified in "
"I<id>.  To initialize the I<cmd> argument, use the I<QCMD(subcmd, type)> "
"macro.  The I<type> value is either B<USRQUOTA>, for user quotas, or "
"B<GRPQUOTA>, for group quotas.  The I<subcmd> value is described below."
msgstr ""
"B<quotactl>()  システムコールはこれらの quota に対する操作を行なう。 最初の引"
"き数は B<QCMD(>I<subcmd>B<,>I<type>B<)> という形式である。 I<type> には、ユー"
"ザー quota については B<USRQUOTA> を、グループ quota については B<GRPQUOTA> "
"を指定する。 I<subcmd> は以下で説明する。"

#. type: Plain text
#: build/C/man2/quotactl.2:79
msgid ""
"The I<special> argument is a pointer to a null-terminated string containing "
"the pathname of the (mounted) block special device for the file system being "
"manipulated."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:87
msgid ""
"The I<addr> argument is the address of an optional, command-specific, data "
"structure that is copied in or out of the system.  The interpretation of "
"I<addr> is given with each command below."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:91
msgid "The I<subcmd> value is one of the following:"
msgstr "I<subcmd> の値は以下のいずれかである"

#. type: TP
#: build/C/man2/quotactl.2:91
#, no-wrap
msgid "B<Q_QUOTAON>"
msgstr "B<Q_QUOTAON>"

#. type: Plain text
#: build/C/man2/quotactl.2:98
msgid ""
"Turn on quotas for a file system.  The I<id> argument is the identification "
"number of the quota format to be used.  Currently, there are three supported "
"quota formats:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:99
#, no-wrap
msgid "B<QFMT_VFS_OLD>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:102
msgid "The original quota format."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:102
#, no-wrap
msgid "B<QFMT_VFS_V0>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:106
msgid ""
"The standard VFS v0 quota format, which can handle 32-bit UIDs and GIDs and "
"quota limits up to 2^42 bytes and 2^32 inodes."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:106
#, no-wrap
msgid "B<QFMT_VFS_V1>"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:110
msgid ""
"A quota format that can handle 32-bit UIDs and GIDs and quota limits of 2^64 "
"bytes and 2^64 inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:121
msgid ""
"The I<addr> argument points to the pathname of a file containing the quotas "
"for the file system.  The quota file must exist; it is normally created with "
"the B<quotacheck>(8)  program.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:121
#, no-wrap
msgid "B<Q_QUOTAOFF>"
msgstr "B<Q_QUOTAOFF>"

#. type: Plain text
#: build/C/man2/quotactl.2:131
msgid ""
"Turn off quotas for a file system.  The I<addr> and I<id> arguments are "
"ignored.  This operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:131
#, no-wrap
msgid "B<Q_GETQUOTA>"
msgstr "B<Q_GETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:142
#, fuzzy
#| msgid ""
#| "Get limits and current usage of disk space.  The I<addr> argument is a "
#| "pointer to a dqblk structure (defined in I<E<lt>sys/quota.hE<gt>>)."
msgid ""
"Get disk quota limits and current usage for user or group I<id>.  The "
"I<addr> argument is a pointer to a I<dqblk> structure defined in I<E<lt>sys/"
"quota.hE<gt>> as follows:"
msgstr ""
"ディスク使用量の制限値と現在の使用量を得る。 I<addr> 引き数は (I<E<lt>sys/"
"quota.hE<gt>> で定義された) dqblk 構造体を指すポインタである。"

#. type: Plain text
#: build/C/man2/quotactl.2:147 build/C/man2/quotactl.2:234
#, no-wrap
msgid ""
"/* uint64_t is an unsigned 64-bit integer;\n"
"   uint32_t is an unsigned 32-bit integer */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:167
#, no-wrap
msgid ""
"struct dqblk {          /* Definition since Linux 2.4.22 */\n"
"    uint64_t dqb_bhardlimit;   /* absolute limit on disk\n"
"                                  quota blocks alloc */\n"
"    uint64_t dqb_bsoftlimit;   /* preferred limit on\n"
"                                  disk quota blocks */\n"
"    uint64_t dqb_curspace;     /* current quota block\n"
"                                  count */\n"
"    uint64_t dqb_ihardlimit;   /* maximum number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_isoftlimit;   /* preferred inode limit */\n"
"    uint64_t dqb_curinodes;    /* current number of\n"
"                                  allocated inodes */\n"
"    uint64_t dqb_btime;        /* time limit for excessive\n"
"                                  disk use */\n"
"    uint64_t dqb_itime;        /* time limit for excessive\n"
"                                  files */\n"
"    uint32_t dqb_valid;        /* bit mask of QIF_*\n"
"                                  constants */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:170
#, no-wrap
msgid ""
"/* Flags in dqb_valid that indicate which fields in\n"
"   dqblk structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:181
#, no-wrap
msgid ""
"#define QIF_BLIMITS   1\n"
"#define QIF_SPACE     2\n"
"#define QIF_ILIMITS   4\n"
"#define QIF_INODES    8\n"
"#define QIF_BTIME     16\n"
"#define QIF_ITIME     32\n"
"#define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)\n"
"#define QIF_USAGE     (QIF_SPACE | QIF_INODES)\n"
"#define QIF_TIMES     (QIF_BTIME | QIF_ITIME)\n"
"#define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:198
msgid ""
"The I<dqb_valid> field is a bit mask that is set to indicate the entries in "
"the I<dqblk> structure that are valid.  Currently, the kernel fills in all "
"entries of the I<dqblk> structure and marks them as valid in the "
"I<dqb_valid> field.  Unprivileged users may retrieve only their own quotas; "
"a privileged user (B<CAP_SYS_ADMIN>)  can retrieve the quotas of any user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:198
#, no-wrap
msgid "B<Q_SETQUOTA>"
msgstr "B<Q_SETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:218
msgid ""
"Set quota information for user or group I<id>, using the information "
"supplied in the I<dqblk> structure pointed to by I<addr>.  The I<dqb_valid> "
"field of the I<dqblk> structure indicates which entries in the structure "
"have been set by the caller.  This operation supersedes the B<Q_SETQLIM> and "
"B<Q_SETUSE> operations in the previous quota interfaces.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:218
#, no-wrap
msgid "B<Q_GETINFO>"
msgstr "B<Q_GETINFO>"

#. type: Plain text
#: build/C/man2/quotactl.2:229
#, fuzzy
#| msgid ""
#| "Get limits and current usage of disk space.  The I<addr> argument is a "
#| "pointer to a dqblk structure (defined in I<E<lt>sys/quota.hE<gt>>)."
msgid ""
"Get information (like grace times) about quotafile.  The I<addr> argument "
"should be a pointer to a I<dqinfo> structure.  This structure is defined in "
"I<E<lt>sys/quota.hE<gt>> as follows:"
msgstr ""
"ディスク使用量の制限値と現在の使用量を得る。 I<addr> 引き数は (I<E<lt>sys/"
"quota.hE<gt>> で定義された) dqblk 構造体を指すポインタである。"

#. type: Plain text
#: build/C/man2/quotactl.2:238
#, no-wrap
msgid ""
"struct dqinfo {         /* Defined since kernel 2.4.22 */\n"
"    uint64_t dqi_bgrace;    /* Time before block soft limit\n"
"                               becomes hard limit */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:245
#, no-wrap
msgid ""
"    uint64_t dqi_igrace;    /* Time before inode soft limit\n"
"                               becomes hard limit */\n"
"    uint32_t dqi_flags;     /* Flags for quotafile\n"
"                               (DQF_*) */\n"
"    uint32_t dqi_valid;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:247
#, no-wrap
msgid "/* Bits for dqi_flags */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:249
#, no-wrap
msgid "/* Quota format QFMT_VFS_OLD */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:251
#, no-wrap
msgid "#define V1_DQF_RSQUASH\t1   /* Root squash enabled */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:253
#, no-wrap
msgid "/* Other quota formats have no dqi_flags bits defined */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:256
#, no-wrap
msgid ""
"/* Flags in dqi_valid that indicate which fields in\n"
"   dqinfo structure are valid. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:261
#, no-wrap
msgid ""
"# define IIF_BGRACE\t1\n"
"# define IIF_IGRACE\t2\n"
"# define IIF_FLAGS\t4\n"
"# define IIF_ALL\t(IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:277
msgid ""
"The I<dqi_valid> field in the I<dqinfo> structure indicates the entries in "
"the structure that are valid.  Currently, the kernel fills in all entries of "
"the I<dqinfo> structure and marks them all as valid in the I<dqi_valid> "
"field.  The I<id> argument is ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:277
#, no-wrap
msgid "B<Q_SETINFO>"
msgstr "B<Q_SETINFO>"

#. type: Plain text
#: build/C/man2/quotactl.2:301
msgid ""
"Set information about quotafile.  The I<addr> argument should be a pointer "
"to a I<dqinfo> structure.  The I<dqi_valid> field of the I<dqinfo> structure "
"indicates the entries in the structure that have been set by the caller.  "
"This operation supersedes the B<Q_SETGRACE> and B<Q_SETFLAGS> operations in "
"the previous quota interfaces.  The I<id> argument is ignored.  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:301
#, no-wrap
msgid "B<Q_GETFMT>"
msgstr "B<Q_GETFMT>"

#. type: Plain text
#: build/C/man2/quotactl.2:308
msgid ""
"Get quota format used on the specified file system.  The I<addr> argument "
"should be a pointer to a 4-byte buffer where the format number will be "
"stored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:308
#, no-wrap
msgid "B<Q_SYNC>"
msgstr "B<Q_SYNC>"

#. type: Plain text
#: build/C/man2/quotactl.2:319
msgid ""
"Update the on-disk copy of quota usages for a file system.  If I<special> is "
"NULL, then all file systems with active quotas are sync'ed.  The I<addr> and "
"I<id> arguments are ignored."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:319
#, no-wrap
msgid "B<Q_GETSTATS>"
msgstr "B<Q_GETSTATS>"

#.  Q_GETSTATS was removed in kernel 2.4.22.
#. type: Plain text
#: build/C/man2/quotactl.2:339
msgid ""
"Get statistics and other generic information about the quota subsystem.  The "
"I<addr> argument should be a pointer to a I<dqstats> structure in which data "
"should be stored.  This structure is defined in I<E<lt>sys/quota.hE<gt>.> "
"The I<special> and I<id> arguments are ignored.  This operation is obsolete "
"and not supported by recent kernels.  Files in I</proc/sys/fs/quota/> carry "
"the information instead."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:342
msgid ""
"For XFS file systems making use of the XFS Quota Manager (XQM), the above "
"commands are bypassed and the following commands are used:"
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:342
#, no-wrap
msgid "B<Q_XQUOTAON>"
msgstr "B<Q_XQUOTAON>"

#. type: Plain text
#: build/C/man2/quotactl.2:363
msgid ""
"Turn on quotas for an XFS file system.  XFS provides the ability to turn on/"
"off quota limit enforcement with quota accounting.  Therefore, XFS expects "
"I<addr> to be a pointer to an I<unsigned int> that contains either the flags "
"B<XFS_QUOTA_UDQ_ACCT> and/or B<XFS_QUOTA_UDQ_ENFD> (for user quota), or "
"B<XFS_QUOTA_GDQ_ACCT> and/or B<XFS_QUOTA_GDQ_ENFD> (for group quota), as "
"defined in I<E<lt>xfs/xqm.hE<gt>>.  This operation requires privilege "
"(B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:363
#, no-wrap
msgid "B<Q_XQUOTAOFF>"
msgstr "B<Q_XQUOTAOFF>"

#. type: Plain text
#: build/C/man2/quotactl.2:374
msgid ""
"Turn off quotas for an XFS file system.  As with B<Q_QUOTAON>, XFS file "
"systems expect a pointer to an I<unsigned int> that specifies whether quota "
"accounting and/or limit enforcement need to be turned off.  This operation "
"requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:374
#, no-wrap
msgid "B<Q_XGETQUOTA>"
msgstr "B<Q_XGETQUOTA>"

#. type: Plain text
#: build/C/man2/quotactl.2:388
msgid ""
"Get disk quota limits and current usage for user I<id>.  The I<addr> "
"argument is a pointer to an I<fs_disk_quota> structure (defined in "
"I<E<lt>xfs/xqm.hE<gt>>).  Unprivileged users may retrieve only their own "
"quotas; a privileged user (B<CAP_SYS_ADMIN>)  may retrieve the quotas of any "
"user."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:388
#, no-wrap
msgid "B<Q_XSETQLIM>"
msgstr "B<Q_XSETQLIM>"

#. type: Plain text
#: build/C/man2/quotactl.2:400
msgid ""
"Set disk quota limits for user I<id>.  The I<addr> argument is a pointer to "
"an I<fs_disk_quota> structure (defined in I<E<lt>xfs/xqm.hE<gt>>).  This "
"operation requires privilege (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:400
#, no-wrap
msgid "B<Q_XGETQSTAT>"
msgstr "B<Q_XGETQSTAT>"

#. type: Plain text
#: build/C/man2/quotactl.2:408
msgid ""
"Returns an I<fs_quota_stat> structure containing XFS file system specific "
"quota information.  This is useful for finding out how much space is used to "
"store quota information, and also to get quotaon/off status of a given local "
"XFS file system."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:408
#, no-wrap
msgid "B<Q_XQUOTARM>"
msgstr "B<Q_XQUOTARM>"

#. type: Plain text
#: build/C/man2/quotactl.2:412
msgid ""
"Free the disk space taken by disk quotas.  Quotas must have already been "
"turned off."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:419
msgid ""
"There is no command equivalent to B<Q_SYNC> for XFS since B<sync>(1)  writes "
"quota information to disk (in addition to the other file system metadata "
"that it writes out)."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:427
msgid ""
"On success, B<quotactl>()  returns 0; on error -1 is returned, and I<errno> "
"is set to indicate the error."
msgstr ""
"成功すると、 B<quotactl>()  は 0 を返す。\n"
"エラーの場合、-1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/quotactl.2:434
msgid "I<addr> or I<special> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:440
msgid "I<cmd> or I<type> is invalid."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:440
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/quotactl.2:447
msgid "The file specified by I<special> or I<addr> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:452
msgid "The kernel has not been compiled with the B<CONFIG_QUOTA> option."
msgstr ""

#. type: TP
#: build/C/man2/quotactl.2:452
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: build/C/man2/quotactl.2:456
msgid "I<special> is not a block device."
msgstr "I<special> がブロックデバイスではない。"

#. type: Plain text
#: build/C/man2/quotactl.2:461
msgid ""
"The caller lacked the required privilege (B<CAP_SYS_ADMIN>)  for the "
"specified operation."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:465
msgid ""
"No disk quota is found for the indicated user.  Quotas have not been turned "
"on for this file system."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:474
msgid "If I<cmd> is B<Q_SETQUOTA>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:477
msgid "Specified limits are out of range allowed by quota format."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:486
msgid "If I<cmd> is B<Q_QUOTAON>, B<quotactl>()  may also set I<errno> to:"
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:495
msgid ""
"The quota file pointed to by I<addr> exists, but is not a regular file; or, "
"the quota file pointed to by I<addr> exists, but is not on the file system "
"pointed to by I<special>."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:501
msgid ""
"B<Q_QUOTAON> attempted, but another B<Q_QUOTAON> had already been performed."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:504
msgid "The quota file is corrupted."
msgstr "quota ファイルが壊れている。"

#. type: Plain text
#: build/C/man2/quotactl.2:507
msgid "Specified quota format was not found."
msgstr ""

#. type: Plain text
#: build/C/man2/quotactl.2:512
msgid "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"
msgstr "B<quota>(1), B<getrlimit>(2), B<quotacheck>(8), B<quotaon>(8)"

#. type: TH
#: build/C/man2/sendfile.2:19
#, no-wrap
msgid "SENDFILE"
msgstr "SENDFILE"

#. type: TH
#: build/C/man2/sendfile.2:19
#, no-wrap
msgid "2011-09-14"
msgstr "2011-09-14"

#. type: Plain text
#: build/C/man2/sendfile.2:22
msgid "sendfile - transfer data between file descriptors"
msgstr "sendfile - ファイル・ディスクリプタ間でデータを転送する"

#. type: Plain text
#: build/C/man2/sendfile.2:24
msgid "B<#include E<lt>sys/sendfile.hE<gt>>"
msgstr "B<#include E<lt>sys/sendfile.hE<gt>>"

#.  The below is too ugly. Comments about glibc versions belong
#.  in the notes, not in the header.
#.  .B #include <features.h>
#.  .br
#.  .B #if (__GLIBC__==2 && __GLIBC_MINOR__>=1) || __GLIBC__>2
#.  .br
#.  .B #include <sys/sendfile.h>
#.  .br
#.  #else
#.  .br
#.  .B #include <sys/types.h>
#.  .br
#.  .B /* No system prototype before glibc 2.1. */
#.  .br
#.  .BI "ssize_t sendfile(int" " out_fd" ", int" " in_fd" ", off_t *" #.                        offset ", size_t" " count" )
#.  .br
#.  .B #endif
#. type: Plain text
#: build/C/man2/sendfile.2:47
msgid ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"
msgstr ""
"B<ssize_t sendfile(int>I< out_fd>B<, int>I< in_fd>B<, off_t *>I<offset>B<, "
"size_t>I< count>B<);>"

#. type: Plain text
#: build/C/man2/sendfile.2:57
msgid ""
"B<sendfile>()  copies data between one file descriptor and another.  Because "
"this copying is done within the kernel, B<sendfile>()  is more efficient "
"than the combination of B<read>(2)  and B<write>(2), which would require "
"transferring data to and from user space."
msgstr ""
"B<sendfile>()  は、あるファイル・ディスクリプタから別の ファイル・ディスクリ"
"プタへのデータのコピーを行う。 このコピーはカーネル内で行われるので、 "
"B<sendfile>()  は、 B<read>(2)  と B<write>(2)  を組み合わせるよりも効率がよ"
"い。 B<read>(2)  や B<write>(2)  ではユーザ空間との間でデータの転送が必要とな"
"るからである。"

#. type: Plain text
#: build/C/man2/sendfile.2:62
msgid ""
"I<in_fd> should be a file descriptor opened for reading and I<out_fd> should "
"be a descriptor opened for writing."
msgstr ""
"I<in_fd> は読み込みのためにオープンされたファイル・ディスクリプタ、 "
"I<out_fd> は書き込みのためにオープンされたディスクリプタでなければならない。"

#. type: Plain text
#: build/C/man2/sendfile.2:83
msgid ""
"If I<offset> is not NULL, then it points to a variable holding the file "
"offset from which B<sendfile>()  will start reading data from I<in_fd>.  "
"When B<sendfile>()  returns, this variable will be set to the offset of the "
"byte following the last byte that was read.  If I<offset> is not NULL, then "
"B<sendfile>()  does not modify the current file offset of I<in_fd>; "
"otherwise the current file offset is adjusted to reflect the number of bytes "
"read from I<in_fd>."
msgstr ""
"I<offset> が NULL でない場合、 I<offset> は B<sendfile>()  が I<in_fd> のどこ"
"からデータを読み始めるかを示すファイル・オフセットを保持する変数への ポインタ"
"である。 B<sendfile>()  は復帰する時、この変数に最後に読み込んだバイトの 次の"
"バイトのオフセットを書き込む。 I<offset> が NULL でない場合、 B<sendfile>()  "
"は I<in_fd> のファイル・オフセットの現在値を変更しない。 NULL の場合は、ファ"
"イル・オフセットの現在値を I<in_fd> から読み込んだバイト数を反映した位置に調"
"整する。"

#. type: Plain text
#: build/C/man2/sendfile.2:90
msgid ""
"If I<offset> is NULL, then data will be read from I<in_fd> starting at the "
"current file offset, and the file offset will be updated by the call."
msgstr ""
"I<offset> が NULL の場合、データは I<in_fd> の現在のファイル・オフセットから"
"読み出され、 ファイル・オフセットはこの呼び出しで更新される。"

#. type: Plain text
#: build/C/man2/sendfile.2:93
msgid "I<count> is the number of bytes to copy between the file descriptors."
msgstr "I<count> は、ファイル・ディスクリプタ間でコピーするバイト数である。"

#. type: Plain text
#: build/C/man2/sendfile.2:100
msgid ""
"The I<in_fd> argument must correspond to a file which supports B<mmap>(2)-"
"like operations (i.e., it cannot be a socket)."
msgstr ""
"I<in_fd> 引き数は B<mmap>(2) 風の操作ができるファイルを指していなければなら"
"な\n"
"い (ソケットを指定することはできない)。"

#. type: Plain text
#: build/C/man2/sendfile.2:108
msgid ""
"In Linux kernels before 2.6.33, I<out_fd> must refer to a socket.  Since "
"Linux 2.6.33 it can be any file.  If it is a regular file, then B<sendfile>"
"()  changes the file offset appropriately."
msgstr ""
"2.6.33 より前の Linux カーネルでは I<out_fd> はソケットを参照していなければ"
"な\n"
"らない。Linux 2.6.33 以降では、任意のファイルを参照することができる。\n"
"通常のファイルの場合には B<sendfile>() はファイルオフセットを適切に変更する。"

#. type: Plain text
#: build/C/man2/sendfile.2:115
msgid ""
"If the transfer was successful, the number of bytes written to I<out_fd> is "
"returned.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"転送に成功した場合、 I<out_fd> に書き込まれたバイト数を返す。エラーの場"
"合、-1 を返し、 I<errno> に適切な値を設定する。"

#. type: Plain text
#: build/C/man2/sendfile.2:121
msgid ""
"Nonblocking I/O has been selected using B<O_NONBLOCK> and the write would "
"block."
msgstr ""
"B<O_NONBLOCK> を用いて非ブロック I/O が選択されたが、書き込みがブロックされ"
"た。"

#. type: TP
#: build/C/man2/sendfile.2:121 build/C/man2/splice.2:143
#: build/C/man2/vmsplice.2:123
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/sendfile.2:125
msgid ""
"The input file was not opened for reading or the output file was not opened "
"for writing."
msgstr ""
"入力ファイルが読み込みのためにオープンされていないか、 出力ファイルが書き込み"
"のためにオープンされていない。"

#. type: Plain text
#: build/C/man2/sendfile.2:128
msgid "Bad address."
msgstr "アドレスがおかしい。"

#. type: Plain text
#: build/C/man2/sendfile.2:134
msgid ""
"Descriptor is not valid or locked, or an B<mmap>(2)-like operation is not "
"available for I<in_fd>."
msgstr ""
"ディスクリプタが有効でないか、ロックされている。もしくは B<mmap>(2)  風の操作"
"が I<in_fd> では利用できない。"

#. type: Plain text
#: build/C/man2/sendfile.2:138
msgid "Unspecified error while reading from I<in_fd>."
msgstr "I<in_fd> から読み込んでいるうちに予期しないエラーが起こった。"

#. type: Plain text
#: build/C/man2/sendfile.2:142
msgid "Insufficient memory to read from I<in_fd>."
msgstr "I<in_fd> から読み込むための十分なメモリがない。"

#. type: Plain text
#: build/C/man2/sendfile.2:148
msgid ""
"B<sendfile>()  is a new feature in Linux 2.2.  The include file I<E<lt>sys/"
"sendfile.hE<gt>> is present since glibc 2.1."
msgstr ""
"B<sendfile> は Linux 2.2 の新しい機能である。 インクルードファイル "
"I<E<lt>sys/sendfile.hE<gt>> は glibc 2.1 から存在している。"

#. type: Plain text
#: build/C/man2/sendfile.2:150
msgid "Not specified in POSIX.1-2001, or other standards."
msgstr "POSIX.1-2001 や他の標準では規定されていない。"

#. type: Plain text
#: build/C/man2/sendfile.2:155
msgid ""
"Other UNIX systems implement B<sendfile>()  with different semantics and "
"prototypes.  It should not be used in portable programs."
msgstr ""
"他の UNIX システムでは、異なった方式やプロトタイプで B<sendfile>()  を実装し"
"ている。移植性を考慮したプログラムでは使用すべきではない。"

#. type: Plain text
#: build/C/man2/sendfile.2:165
msgid ""
"If you plan to use B<sendfile>()  for sending files to a TCP socket, but "
"need to send some header data in front of the file contents, you will find "
"it useful to employ the B<TCP_CORK> option, described in B<tcp>(7), to "
"minimize the number of packets and to tune performance."
msgstr ""
"B<sendfile>()  を使って TCP ソケットにファイルを送ろうとしていて、 ファイルの"
"内容の前にヘッダ・データを付け加える必要がある場合は、 パケット数を最小にして"
"性能を上げるために B<tcp>(7)  に記述されている B<TCP_CORK> オプションを使うと"
"いいだろう。"

#. type: Plain text
#: build/C/man2/sendfile.2:171
msgid ""
"In Linux 2.4 and earlier, I<out_fd> could also refer to a regular file, and "
"B<sendfile>()  changed the current offset of that file."
msgstr ""
"Linux 2.4 とそれ以前のバージョンでも、 I<out_fd> は通常のファイルを参照で"
"き、\n"
"B<sendfile>() はそのファイルのオフセットの現在値を変更していた。"

#. type: Plain text
#: build/C/man2/sendfile.2:183
msgid ""
"The original Linux B<sendfile>()  system call was not designed to handle "
"large file offsets.  Consequently, Linux 2.4 added B<sendfile64>(), with a "
"wider type for the I<offset> argument.  The glibc B<sendfile>()  wrapper "
"function transparently deals with the kernel differences."
msgstr ""
"元々の Linux B<sendfile>() システムコールは大きなファイルオフセットを\n"
"扱えるように設計されていなかった。その結果、Linux 2.4 で、\n"
"ビット幅の大きな I<offset> 引き数を持った B<sendfile64>() が追加された。\n"
"glibc の B<sendfile>() のラッパー関数はカーネルによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/sendfile.2:192
msgid ""
"Applications may wish to fall back to B<read>(2)/B<write>(2)  in the case "
"where B<sendfile>()  fails with B<EINVAL> or B<ENOSYS>."
msgstr ""
"B<sendfile>()  が B<EINVAL> や B<ENOSYS> で失敗するような場合は、 アプリケー"
"ションは B<read>(2)/B<write>(2)  に戻すことを考えてもよいかもしれない。"

#. type: Plain text
#: build/C/man2/sendfile.2:197
msgid ""
"The Linux-specific B<splice>(2)  call supports transferring data between "
"arbitrary files (e.g., a pair of sockets)."
msgstr ""
"Linux 固有の B<splice>(2) システムコールは、任意のファイル間 (例えば、\n"
"ソケット同士) でのデータ転送をサポートしている。"

#. type: Plain text
#: build/C/man2/sendfile.2:202
msgid "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"
msgstr "B<mmap>(2), B<open>(2), B<socket>(2), B<splice>(2)"

#. type: TH
#: build/C/man2/set_tid_address.2:25
#, no-wrap
msgid "SET_TID_ADDRESS"
msgstr "SET_TID_ADDRESS"

#. type: TH
#: build/C/man2/set_tid_address.2:25
#, no-wrap
msgid "2012-07-19"
msgstr "2012-07-19"

#. type: Plain text
#: build/C/man2/set_tid_address.2:28
msgid "set_tid_address - set pointer to thread ID"
msgstr "set_tid_address - スレッド ID へのポインタを設定する"

#. type: Plain text
#: build/C/man2/set_tid_address.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/set_tid_address.2:33
#, no-wrap
msgid "B<long set_tid_address(int *>I<tidptr>B<);>\n"
msgstr "B<long set_tid_address(int *>I<tidptr>B<);>\n"

#. type: Plain text
#: build/C/man2/set_tid_address.2:40
msgid ""
"For each process, the kernel maintains two attributes (addresses) called "
"I<set_child_tid> and I<clear_child_tid>.  These two attributes contain the "
"value NULL by default."
msgstr ""
"各プロセスについて、カーネルは I<set_child_tid> と I<clear_child_tid> という "
"2 つの属性を保持する。この 2 つの属性はデフォルトでは NULL である。"

#. type: TP
#: build/C/man2/set_tid_address.2:40
#, no-wrap
msgid "I<set_child_tid>"
msgstr "I<set_child_tid>"

#. type: Plain text
#: build/C/man2/set_tid_address.2:51
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_SETTID> "
"flag, I<set_child_tid> is set to the value passed in the I<ctid> argument of "
"that system call."
msgstr ""
"プロセスが B<CLONE_CHILD_SETTID> フラグを指定した B<clone>(2)  によって開始さ"
"れた場合、 I<set_child_tid> は B<clone>(2) のシステムコールの I<ctid> 引き数"
"で渡された値に設定される。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:56
msgid ""
"When I<set_child_tid> is set, the very first thing the new process does is "
"writing its PID at this address."
msgstr ""
"I<set_child_tid> が設定された場合、一番最初に新しいプロセスが行うことは、 こ"
"のアドレスに自身の PID を書き込むことである。"

#. type: TP
#: build/C/man2/set_tid_address.2:56
#, no-wrap
msgid "I<clear_child_tid>"
msgstr "I<clear_child_tid>"

#. type: Plain text
#: build/C/man2/set_tid_address.2:67
msgid ""
"If a process is started using B<clone>(2)  with the B<CLONE_CHILD_CLEARTID> "
"flag, I<clear_child_tid> is set to the value passed in the I<ctid> argument "
"of that system call."
msgstr ""
"プロセスが B<CLONE_CHILD_CLEARTID> フラグを指定した B<clone>(2) によって開始"
"された場合、 I<clear_child_tid> は B<clone>(2) のシステムコールの I<ctid> 引"
"き数で渡された値に設定される。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:74
msgid ""
"The system call B<set_tid_address>()  sets the I<clear_child_tid> value for "
"the calling process to I<tidptr>."
msgstr ""
"システムコール B<set_tid_address>()  は呼び出し元プロセスの "
"I<clear_child_tid> の値を I<tidptr> に設定する。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:82
msgid ""
"When a process whose I<clear_child_tid> is not NULL terminates, then, if the "
"process is sharing memory with other processes or threads, then 0 is written "
"at the address specified in I<clear_child_tid> and the kernel performs the "
"following operation:"
msgstr ""
"I<clear_child_tid> が NULL でないプロセスが終了すると、そのプロセスが他のプロ"
"セスまたはスレッドとメモリを共有していれば、 I<clear_child_tid> で指定された"
"アドレスに 0 が書き込まれ、カーネルは以下の処理を実行する。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:84
#, no-wrap
msgid "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"
msgstr "    futex(clear_child_tid, FUTEX_WAKE, 1, NULL, NULL, 0);\n"

#. type: Plain text
#: build/C/man2/set_tid_address.2:88
msgid ""
"The effect of this operation is to wake a single process that is performing "
"a futex wait on the memory location.  Errors from the futex wake operation "
"are ignored."
msgstr ""
"この処理の結果、このメモリアドレスに対する futex wait を実行しているプロセス"
"を一つ起こす (wake)。 futex wake 操作でのエラーは無視される。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:91
msgid "B<set_tid_address>()  always returns the PID of the calling process."
msgstr "B<set_tid_address>()  は常に現在のプロセスの PID を返す。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:94
msgid "B<set_tid_address>()  always succeeds."
msgstr "B<set_tid_address>()  は常に成功する。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:97
msgid ""
"This call is present since Linux 2.5.48.  Details as given here are valid "
"since Linux 2.5.49."
msgstr ""
"この呼び出しは Linux 2.5.48 以降で存在する。 ここで書かれた詳細は Linux "
"2.5.49 以降で有効である。"

#. type: Plain text
#: build/C/man2/set_tid_address.2:102
msgid "B<clone>(2), B<futex>(2)"
msgstr "B<clone>(2), B<futex>(2)"

#. type: TH
#: build/C/man2/splice.2:26
#, no-wrap
msgid "SPLICE"
msgstr "SPLICE"

#. type: TH
#: build/C/man2/splice.2:26 build/C/man2/tee.2:26 build/C/man2/vmsplice.2:26
#, no-wrap
msgid "2012-05-04"
msgstr "2012-05-04"

#. type: Plain text
#: build/C/man2/splice.2:29
msgid "splice - splice data to/from a pipe"
msgstr "splice - パイプとの間でデータを継ぎ合わせる"

#. type: Plain text
#: build/C/man2/splice.2:33 build/C/man2/tee.2:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#.  Return type was long before glibc 2.7
#. type: Plain text
#: build/C/man2/splice.2:38
#, no-wrap
msgid ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t splice(int >I<fd_in>B<, loff_t *>I<off_in>B<, int >I<fd_out>B<,>\n"
"B<               loff_t *>I<off_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/splice.2:50
msgid ""
"B<splice>()  moves data between two file descriptors without copying between "
"kernel address space and user address space.  It transfers up to I<len> "
"bytes of data from the file descriptor I<fd_in> to the file descriptor "
"I<fd_out>, where one of the descriptors must refer to a pipe."
msgstr ""
"B<splice>()  は、カーネルアドレス空間とユーザアドレス空間との間のコピーを伴わ"
"ずに、 2 つのファイルディスクリプタ間でデータの移動を行う。 ファイルディスク"
"リプタ I<fd_in> からファイルディスクリプタ I<fd_out> へ最大 I<len> バイトを転"
"送する。 2 つのファイルディスクリプタのうち一つは パイプを参照していなければ"
"ならない。"

#. type: Plain text
#: build/C/man2/splice.2:80
msgid ""
"If I<fd_in> refers to a pipe, then I<off_in> must be NULL.  If I<fd_in> does "
"not refer to a pipe and I<off_in> is NULL, then bytes are read from I<fd_in> "
"starting from the current file offset, and the current file offset is "
"adjusted appropriately.  If I<fd_in> does not refer to a pipe and I<off_in> "
"is not NULL, then I<off_in> must point to a buffer which specifies the "
"starting offset from which bytes will be read from I<fd_in>; in this case, "
"the current file offset of I<fd_in> is not changed.  Analogous statements "
"apply for I<fd_out> and I<off_out>."
msgstr ""
"I<fd_in> がパイプを参照している場合、 I<off_in> は NULL でなければならない。 "
"I<fd_in> がパイプを参照しておらず、 I<off_in> が NULL の場合、 I<fd_in> の現"
"在のファイルオフセットから始まるバイトを読み出す。 現在のファイルオフセットは"
"適切に調整される。 I<fd_in> がパイプを参照しておらず、 I<off_in> が NULL でな"
"い場合、 I<off_in> は I<fd_in> からのデータ読み出しを開始する先頭オフセットを"
"格納したバッファ へのポインタでなければならない。この場合、 I<fd_in> の現在の"
"ファイルオフセットは変更されない。 I<fd_out> と I<off_out> に関しても同様であ"
"る。"

#. type: Plain text
#: build/C/man2/splice.2:85 build/C/man2/vmsplice.2:78
msgid ""
"The I<flags> argument is a bit mask that is composed by ORing together zero "
"or more of the following values:"
msgstr ""
"I<flags> 引き数には、以下の値の 0 個以上をビット毎の論理和の形で指定する。"

#. type: TP
#: build/C/man2/splice.2:85 build/C/man2/tee.2:62 build/C/man2/vmsplice.2:78
#, no-wrap
msgid "B<SPLICE_F_MOVE>"
msgstr "B<SPLICE_F_MOVE>"

#. type: Plain text
#: build/C/man2/splice.2:98
msgid ""
"Attempt to move pages instead of copying.  This is only a hint to the "
"kernel: pages may still be copied if the kernel cannot move the pages from "
"the pipe, or if the pipe buffers don't refer to full pages.  The initial "
"implementation of this flag was buggy: therefore starting in Linux 2.6.21 it "
"is a no-op (but is still permitted in a B<splice>()  call); in the future, a "
"correct implementation may be restored."
msgstr ""
"ページのコピーでなく移動を試みる。 これはカーネルに対するヒントでしかない。 "
"つまり、カーネルがパイプからページを移動できない場合や、 パイプバッファがペー"
"ジ全部を参照していない場合は、 ページのコピーが行われることもある。 このフラ"
"グの最初の実装にはバグがあった。そのため、 Linux 2.6.21 以降ではこのフラグの"
"操作はできないようになっている (ただし、 B<splice>()  コールでこのフラグを指"
"定することは今も認められている)。 将来、正しい実装が行われることだろう。"

#. type: TP
#: build/C/man2/splice.2:98 build/C/man2/tee.2:68 build/C/man2/vmsplice.2:84
#, no-wrap
msgid "B<SPLICE_F_NONBLOCK>"
msgstr "B<SPLICE_F_NONBLOCK>"

#. type: Plain text
#: build/C/man2/splice.2:107
msgid ""
"Do not block on I/O.  This makes the splice pipe operations nonblocking, but "
"B<splice>()  may nevertheless block because the file descriptors that are "
"spliced to/from may block (unless they have the B<O_NONBLOCK> flag set)."
msgstr ""
"入出力時に停止 (block) しない。 このフラグを指定すると、 splice によるパイプ"
"操作を非停止モード (nonblocking) で 行おうとするが、その場合でも B<splice>"
"()  は停止することもある。なぜなら、データのやり取りを行う ファイルディスクリ"
"プタは (B<O_NONBLOCK> フラグをセットされていない場合) 停止する可能性があるか"
"らである。"

#. type: TP
#: build/C/man2/splice.2:107 build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
#, no-wrap
msgid "B<SPLICE_F_MORE>"
msgstr "B<SPLICE_F_MORE>"

#. type: Plain text
#: build/C/man2/splice.2:121
msgid ""
"More data will be coming in a subsequent splice.  This is a helpful hint "
"when the I<fd_out> refers to a socket (see also the description of "
"B<MSG_MORE> in B<send>(2), and the description of B<TCP_CORK> in B<tcp>(7))"
msgstr ""
"この後の splice でさらに転送されるデータがあることを示す。 このフラグは "
"I<fd_out> がソケットを参照している場合に有用なヒントとなる (B<send>(2)  の "
"B<MSG_MORE> や B<tcp>(7)  の B<TCP_CORK> の説明も参照)。"

#. type: TP
#: build/C/man2/splice.2:121 build/C/man2/tee.2:79 build/C/man2/vmsplice.2:97
#, no-wrap
msgid "B<SPLICE_F_GIFT>"
msgstr "B<SPLICE_F_GIFT>"

#. type: Plain text
#: build/C/man2/splice.2:127
msgid "Unused for B<splice>(); see B<vmsplice>(2)."
msgstr "B<splice>()  では使用しない。 B<vmsplice>(2)  参照。"

#. type: Plain text
#: build/C/man2/splice.2:136
msgid ""
"Upon successful completion, B<splice>()  returns the number of bytes spliced "
"to or from the pipe.  A return value of 0 means that there was no data to "
"transfer, and it would not make sense to block, because there are no writers "
"connected to the write end of the pipe referred to by I<fd_in>."
msgstr ""
"成功して完了すると、 B<splice>()  はパイプから出し入れしたバイト数を返す。 返"
"り値 0 はデータの転送が行わなかったことを示す。 この場合、処理を停止 (block) "
"しても無意味である。 なぜなら、 I<fd_in> が参照するパイプの書き込み側に接続さ"
"れている者がいないからである。"

#. type: Plain text
#: build/C/man2/splice.2:142
msgid ""
"On error, B<splice>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""
"エラーの場合、 B<splice>()  は -1 を返し、 I<errno> にエラーを示す値を設定す"
"る。"

#. type: Plain text
#: build/C/man2/splice.2:147
msgid ""
"One or both file descriptors are not valid, or do not have proper read-write "
"mode."
msgstr ""
"ファイルディスクリプタの一方または両方が有効ではない、 もしくは適切な read-"
"write モードではない。"

#.  The append-mode error is given since 2.6.27; in earlier kernels,
#.  splice() in append mode was broken
#. type: Plain text
#: build/C/man2/splice.2:155
msgid ""
"Target file system doesn't support splicing; target file is opened in append "
"mode; neither of the descriptors refers to a pipe; or offset given for "
"nonseekable device."
msgstr ""
"対象のファイルシステムが splice に対応していない、 または対象のファイルが追記"
"モードでオープンされている、 またはディスクリプタのどちらもパイプを参照してい"
"ない、 または seek できないデバイスに対してオフセットが指定された。"

#. type: Plain text
#: build/C/man2/splice.2:158 build/C/man2/tee.2:114
#: build/C/man2/vmsplice.2:138
msgid "Out of memory."
msgstr "メモリ不足。"

#. type: TP
#: build/C/man2/splice.2:158
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: build/C/man2/splice.2:165
msgid ""
"Either I<off_in> or I<off_out> was not NULL, but the corresponding file "
"descriptor refers to a pipe."
msgstr ""
"I<off_in> か I<off_out> のいずれかが NULL ではないが、対応するファイルディス"
"クリプタが パイプを参照している。"

#. type: Plain text
#: build/C/man2/splice.2:170
msgid ""
"The B<splice>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""
"B<splice>() システムコールは Linux 2.6.17 で初めて登場した。\n"
"ライブラリによるサポートは glibc バージョン 2.5 で追加された。"

#. type: Plain text
#: build/C/man2/splice.2:182
msgid ""
"The three system calls B<splice>(), B<vmsplice>(2), and B<tee>(2), provide "
"user-space programs with full control over an arbitrary kernel buffer, "
"implemented within the kernel using the same type of buffer that is used for "
"a pipe.  In overview, these system calls perform the following tasks:"
msgstr ""
"3 つのシステムコール (B<splice>(), B<vmsplice>(2), B<tee>(2))  を使うと、ユー"
"ザ空間プログラムは任意のカーネルバッファに対する 完全な制御ができる。カーネル"
"バッファは、パイプに使用されているのと 同種のバッファを使ってカーネル内に実装"
"されている。 大まかにいうと、これらのシステムコールは以下の仕事を行う:"

#. type: TP
#: build/C/man2/splice.2:182
#, no-wrap
msgid "B<splice>()"
msgstr "B<splice>()"

#. type: Plain text
#: build/C/man2/splice.2:186
msgid ""
"moves data from the buffer to an arbitrary file descriptor, or vice versa, "
"or from one buffer to another."
msgstr ""
"バッファから任意のファイルディスクリプタや、その逆方向、 もしくはあるバッファ"
"から別のバッファへの、データ移動を行う。"

#. type: TP
#: build/C/man2/splice.2:186
#, no-wrap
msgid "B<tee>(2)"
msgstr "B<tee>(2)"

#. type: Plain text
#: build/C/man2/splice.2:189
msgid "\"copies\" the data from one buffer to another."
msgstr "あるバッファから別のバッファへのデータ「コピー」を行う。"

#. type: TP
#: build/C/man2/splice.2:189
#, no-wrap
msgid "B<vmsplice>(2)"
msgstr "B<vmsplice>(2)"

#. type: Plain text
#: build/C/man2/splice.2:192
msgid "\"copies\" data from user space into the buffer."
msgstr "ユーザ空間からバッファへのデータ「コピー」を行う。"

#.  Linus: Now, imagine using the above in a media server, for example.
#.  Let's say that a year or two has passed, so that the video drivers
#.  have been updated to be able to do the splice thing, and what can
#.  you do? You can:
#.  - splice from the (mpeg or whatever - let's just assume that the video
#.    input is either digital or does the encoding on its own - like they
#.    pretty much all do) video input into a pipe (remember: no copies - the
#.    video input will just DMA directly into memory, and splice will just
#.    set up the pages in the pipe buffer)
#.  - tee that pipe to split it up
#.  - splice one end to a file (ie "save the compressed stream to disk")
#.  - splice the other end to a real-time video decoder window for your
#.    real-time viewing pleasure.
#.  Linus: Now, the advantage of splice()/tee() is that you can
#.  do zero-copy movement of data, and unlike sendfile() you can
#.  do it on _arbitrary_ data (and, as shown by "tee()", it's more
#.  than just sending the data to somebody else: you can duplicate
#.  the data and choose to forward it to two or more different
#.  users - for things like logging etc.).
#. type: Plain text
#: build/C/man2/splice.2:223
msgid ""
"Though we talk of copying, actual copies are generally avoided.  The kernel "
"does this by implementing a pipe buffer as a set of reference-counted "
"pointers to pages of kernel memory.  The kernel creates \"copies\" of pages "
"in a buffer by creating new pointers (for the output buffer) referring to "
"the pages, and increasing the reference counts for the pages: only pointers "
"are copied, not the pages of the buffer."
msgstr ""
"ここではコピーの話をしているが、実際のコピーは一般的に回避される。 カーネル"
"は、パイプ・バッファをカーネルメモリのページへのポインタ集合として 実装し、"
"ページへの参照回数を管理することで、これを実現している。 カーネルは、対象とな"
"るページを参照する (出力バッファ用の) ポインタを 新規に作成することでバッファ"
"内のページの「コピー」を作成し、 そのページの参照回数を増やす。つまり、ポイン"
"タだけがコピーされ、 バッファのページはコピーされない。"

#. type: Plain text
#: build/C/man2/splice.2:226
msgid "See B<tee>(2)."
msgstr "B<tee>(2)  参照。"

#. type: Plain text
#: build/C/man2/splice.2:230
msgid "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"
msgstr "B<sendfile>(2), B<tee>(2), B<vmsplice>(2)"

#. type: TH
#: build/C/man2/tee.2:26
#, no-wrap
msgid "TEE"
msgstr "TEE"

#. type: Plain text
#: build/C/man2/tee.2:29
msgid "tee - duplicating pipe content"
msgstr "tee - パイプの中身を複製する"

#. type: Plain text
#: build/C/man2/tee.2:36
#, no-wrap
msgid "B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"
msgstr "B<ssize_t tee(int >I<fd_in>B<, int >I<fd_out>B<, size_t >I<len>B<, unsigned int >I<flags>B<);>\n"

#.  Example programs http://brick.kernel.dk/snaps
#.  add a "tee(in, out1, out2)" system call that duplicates the pages
#.  (again, incrementing their reference count, not copying the data) from
#.  one pipe to two other pipes.
#. type: Plain text
#: build/C/man2/tee.2:56
msgid ""
"B<tee>()  duplicates up to I<len> bytes of data from the pipe referred to by "
"the file descriptor I<fd_in> to the pipe referred to by the file descriptor "
"I<fd_out>.  It does not consume the data that is duplicated from I<fd_in>; "
"therefore, that data can be copied by a subsequent B<splice>(2)."
msgstr ""
"B<tee>()  は、ファイルディスクリプタ I<fd_in> が参照するパイプからファイル"
"ディスクリプタ I<fd_out> が参照するパイプへ最大 I<len> バイトのデータを複製す"
"る。 この操作では、複製されるデータは I<fd_in> からは消費されない。したがっ"
"て、これらのデータをこの後の B<splice>(2)  でコピーすることができる。"

#. type: Plain text
#: build/C/man2/tee.2:62
msgid ""
"I<flags> is a series of modifier flags, which share the name space with "
"B<splice>(2)  and B<vmsplice>(2):"
msgstr ""
"I<flags> は一連の修飾フラグであり、 B<splice>(2)  や B<vmsplice>(2)  と共通の"
"名前である。"

#. type: Plain text
#: build/C/man2/tee.2:68
msgid "Currently has no effect for B<tee>(); see B<splice>(2)."
msgstr "現在のところ B<tee>()  では何の効果もない。 B<splice>(2)  参照。"

#.  Not used for vmsplice
#.  May be in the future -- therefore EAGAIN
#. type: Plain text
#: build/C/man2/tee.2:73 build/C/man2/vmsplice.2:91
msgid "Do not block on I/O; see B<splice>(2)  for further details."
msgstr "入出力で停止 (block) しない。詳細は B<splice>(2)  参照。"

#. type: Plain text
#: build/C/man2/tee.2:79
msgid ""
"Currently has no effect for B<tee>(), but may be implemented in the future; "
"see B<splice>(2)."
msgstr ""
"現在のところ B<tee>()  では何の効果もないが、将来的には実装される可能性があ"
"る。 B<splice>(2)  参照。"

#. type: Plain text
#: build/C/man2/tee.2:85
msgid "Unused for B<tee>(); see B<vmsplice>(2)."
msgstr "B<tee>()  では未使用。 B<vmsplice>(2)  参照。"

#. type: Plain text
#: build/C/man2/tee.2:94
msgid ""
"Upon successful completion, B<tee>()  returns the number of bytes that were "
"duplicated between the input and output.  A return value of 0 means that "
"there was no data to transfer, and it would not make sense to block, because "
"there are no writers connected to the write end of the pipe referred to by "
"I<fd_in>."
msgstr ""
"成功して完了すると、 B<tee>()  は入出力間で複製されたバイト数を返す。 返り値 "
"0 はデータの転送が行われなかったことを示す。 この場合、処理を停止 (block) し"
"ても無意味である。 なぜなら、 I<fd_in> が参照するパイプの書き込み側に接続され"
"ている者がいないからである。"

#. type: Plain text
#: build/C/man2/tee.2:100
msgid ""
"On error, B<tee>()  returns -1 and I<errno> is set to indicate the error."
msgstr ""
"エラーの場合、 B<tee>()  は -1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/tee.2:111
msgid ""
"I<fd_in> or I<fd_out> does not refer to a pipe; or I<fd_in> and I<fd_out> "
"refer to the same pipe."
msgstr ""
"I<fd_in> と I<fd_out> のどちらかがパイプを参照していない。もしくは I<fd_in> "
"と I<fd_out> が同じパイプを参照している。"

#. type: Plain text
#: build/C/man2/tee.2:119
msgid ""
"The B<tee>()  system call first appeared in Linux 2.6.17; library support "
"was added to glibc in version 2.5."
msgstr ""
"B<tee>() システムコールは Linux 2.6.17 で初めて登場した。\n"
"ライブラリによるサポートは glibc バージョン 2.5 で追加された。"

#. type: Plain text
#: build/C/man2/tee.2:130
msgid ""
"Conceptually, B<tee>()  copies the data between the two pipes.  In reality "
"no real data copying takes place though: under the covers, B<tee>()  assigns "
"data in the output by merely grabbing a reference to the input."
msgstr ""
"概念としては、 B<tee>()  は二つのパイプ間でデータのコピーを行う。 しかし、実"
"際には実データのコピーは行われない。 内部では、 B<tee>()  は入力側に対する参"
"照だけを作成することで出力側にデータを 追加する。"

#. type: Plain text
#: build/C/man2/tee.2:136
msgid ""
"The following example implements a basic B<tee>(1)  program using the B<tee>"
"()  system call."
msgstr ""
"以下の例は、 B<tee>()  システムコールを使って、 基本的な B<tee>(1)  プログラ"
"ムを実装したものである。"

#. type: Plain text
#: build/C/man2/tee.2:145
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>limits.hE<gt>\n"

#. type: Plain text
#: build/C/man2/tee.2:151
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
"    int len, slen;\n"

#. type: Plain text
#: build/C/man2/tee.2:156
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/tee.2:162
#, no-wrap
msgid ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);\n"
"    if (fd == -1) {\n"
"        perror(\"open\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/tee.2:169
#, no-wrap
msgid ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"
msgstr ""
"    do {\n"
"        /*\n"
"         * tee stdin to stdout.\n"
"         */\n"
"        len = tee(STDIN_FILENO, STDOUT_FILENO,\n"
"                  INT_MAX, SPLICE_F_NONBLOCK);\n"

#. type: Plain text
#: build/C/man2/tee.2:178
#, no-wrap
msgid ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"
msgstr ""
"        if (len E<lt> 0) {\n"
"            if (errno == EAGAIN)\n"
"                continue;\n"
"            perror(\"tee\");\n"
"            exit(EXIT_FAILURE);\n"
"        } else\n"
"            if (len == 0)\n"
"                break;\n"

#. type: Plain text
#: build/C/man2/tee.2:192
#, no-wrap
msgid ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"
msgstr ""
"        /*\n"
"         * Consume stdin by splicing it to a file.\n"
"         */\n"
"        while (len E<gt> 0) {\n"
"            slen = splice(STDIN_FILENO, NULL, fd, NULL,\n"
"                          len, SPLICE_F_MOVE);\n"
"            if (slen E<lt> 0) {\n"
"                perror(\"splice\");\n"
"                break;\n"
"            }\n"
"            len -= slen;\n"
"        }\n"
"    } while (1);\n"

#. type: Plain text
#: build/C/man2/tee.2:196
#, no-wrap
msgid ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    close(fd);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/tee.2:200
msgid "B<splice>(2), B<vmsplice>(2)"
msgstr "B<splice>(2), B<vmsplice>(2)"

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "VM86"
msgstr "VM86"

#. type: TH
#: build/C/man2/vm86.2:26
#, no-wrap
msgid "2009-02-20"
msgstr "2009-02-20"

#. type: Plain text
#: build/C/man2/vm86.2:29
msgid "vm86old, vm86 - enter virtual 8086 mode"
msgstr "vm86old, vm86 - 仮想 8086 モードへ移行する"

#. type: Plain text
#: build/C/man2/vm86.2:31
msgid "B<#include E<lt>sys/vm86.hE<gt>>"
msgstr "B<#include E<lt>sys/vm86.hE<gt>>"

#. type: Plain text
#: build/C/man2/vm86.2:33
msgid "B<int vm86old(struct vm86_struct *>I<info>B<);>"
msgstr "B<int vm86old(struct vm86_struct *>I<info>B<);>"

#. type: Plain text
#: build/C/man2/vm86.2:35
msgid "B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"
msgstr ""
"B<int vm86(unsigned long >I<fn>B<, struct vm86plus_struct *>I<v86>B<);>"

#. type: Plain text
#: build/C/man2/vm86.2:48
msgid ""
"The system call B<vm86>()  was introduced in Linux 0.97p2.  In Linux 2.1.15 "
"and 2.0.28 it was renamed to B<vm86old>(), and a new B<vm86>()  was "
"introduced.  The definition of I<struct vm86_struct> was changed in 1.1.8 "
"and 1.1.9."
msgstr ""
"B<vm86>()  システムコールは Linux 0.97p2 で導入された。 これは Linux 2.1.15 "
"と 2.0.28 で B<vm86old>()  に名前が変更され、 新しい B<vm86>()  が導入され"
"た。 I<struct vm86_struct> の定義は 1.1.8 と 1.1.9 で変更された。"

#. type: Plain text
#: build/C/man2/vm86.2:52
msgid ""
"These calls cause the process to enter VM86 mode (virtual-8086 in Intel "
"literature), and are used by B<dosemu>."
msgstr ""
"これらのコールによってプロセスは VM86 モード (Intel の文書では仮想 8086 モー"
"ド) へと移行する。 これらのコールは B<dosemu> で使用される。"

#. type: Plain text
#: build/C/man2/vm86.2:54
msgid "VM86 mode is an emulation of real mode within a protected mode task."
msgstr ""
"VM86 モードはプロテクトモードタスクにおける リアルモードのエミュレーションで"
"ある。"

#. type: Plain text
#: build/C/man2/vm86.2:64
msgid ""
"This return value is specific to i386 and indicates a problem with getting "
"user-space data."
msgstr ""
"この返り値は i386 固有のものであり、 ユーザー空間のデータを取得する際に問題が"
"あったことを示す。"

#. type: Plain text
#: build/C/man2/vm86.2:68
msgid ""
"This return value indicates the call is not implemented on the present "
"architecture."
msgstr ""
"この返り値は、このコールが現在のアーキテクチャで実装されていないことを示す。"

#. type: Plain text
#: build/C/man2/vm86.2:73
msgid ""
"Saved kernel stack exists.  (This is a kernel sanity check; the saved stack "
"should exist only within vm86 mode itself.)"
msgstr ""
"保存されたカーネルスタックが既に存在している。(これはカーネルが通常の 状態で"
"あるかをチェックしている。保存されたスタックは vm86 モードで しか存在しな"
"い。)"

#. type: Plain text
#: build/C/man2/vm86.2:76
msgid ""
"This call is specific to Linux on 32-bit Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""
"この関数は 32 ビット Intel プロセッサ上の Linux 特有の関数であり、 移植を意図"
"したプログラムでは使用すべきでない。"

#. type: TH
#: build/C/man2/vmsplice.2:26
#, no-wrap
msgid "VMSPLICE"
msgstr "VMSPLICE"

#. type: Plain text
#: build/C/man2/vmsplice.2:29
msgid "vmsplice - splice user pages into a pipe"
msgstr "vmsplice - ユーザ・ページをパイプに継ぎ合わせる"

#. type: Plain text
#: build/C/man2/vmsplice.2:34
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
"B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/vmsplice.2:37
#, no-wrap
msgid ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"
msgstr ""
"B<ssize_t vmsplice(int >I<fd>B<, const struct iovec *>I<iov>B<,>\n"
"B<                 unsigned long >I<nr_segs>B<, unsigned int >I<flags>B<);>\n"

#.  Linus: vmsplice() system call to basically do a "write to
#.  the buffer", but using the reference counting and VM traversal
#.  to actually fill the buffer. This means that the user needs to
#.  be careful not to reuse the user-space buffer it spliced into
#.  the kernel-space one (contrast this to "write()", which copies
#.  the actual data, and you can thus reuse the buffer immediately
#.  after a successful write), but that is often easy to do.
#. type: Plain text
#: build/C/man2/vmsplice.2:57
msgid ""
"The B<vmsplice>()  system call maps I<nr_segs> ranges of user memory "
"described by I<iov> into a pipe.  The file descriptor I<fd> must refer to a "
"pipe."
msgstr ""
"B<vmsplice>()  システムコールは、 I<iov> で指定されたユーザ・メモリの "
"I<nr_segs> の範囲をパイプにマッピングする。 I<fd> はパイプを参照していなけれ"
"ばならない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:64
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures as defined in "
"I<E<lt>sys/uio.hE<gt>>:"
msgstr ""
"ポインタ I<iov> は I<iovec> 構造体の配列を指す。 I<iovec> 構造体は "
"I<E<lt>sys/uio.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/vmsplice.2:71
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;            /* Starting address */\n"
"    size_t iov_len;             /* Number of bytes */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;            /* 開始アドレス */\n"
"    size_t iov_len;             /* バイト数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/vmsplice.2:84
msgid "Unused for B<vmsplice>(); see B<splice>(2)."
msgstr "B<vmsplice>()  では未使用。 B<splice>(2)  参照。"

#. type: Plain text
#: build/C/man2/vmsplice.2:97
msgid ""
"Currently has no effect for B<vmsplice>(), but may be implemented in the "
"future; see B<splice>(2)."
msgstr ""
"現在のところ B<vmsplice>()  では何の効果もないが、将来的には実装される可能性"
"がある。 B<splice>(2)  参照。"

#.  FIXME Explain the following line in a little more detail:
#.  .... if we expect to later SPLICE_F_MOVE to the cache.
#. type: Plain text
#: build/C/man2/vmsplice.2:113
msgid ""
"The user pages are a gift to the kernel.  The application may not modify "
"this memory ever, or page cache and on-disk data may differ.  Gifting pages "
"to the kernel means that a subsequent B<splice>(2)  B<SPLICE_F_MOVE> can "
"successfully move the pages; if this flag is not specified, then a "
"subsequent B<splice>(2)  B<SPLICE_F_MOVE> must copy the pages.  Data must "
"also be properly page aligned, both in memory and length."
msgstr ""
"ユーザ・ページがカーネルへ渡すもの (gift) であることを示す。 アプリケーション"
"はこのメモリを絶対に変更してはならない。 さもなければ、ページキャッシュとディ"
"スク上のデータは 一致しなくなるだろう。 ページをカーネルに渡すと、この次の "
"B<splice>(2)  B<SPLICE_F_MOVE> でそのページの移動を行うことができる。 このフ"
"ラグが指定されなかった場合、この次の B<splice>(2)  B<SPLICE_F_MOVE> でその"
"ページのコピーを行わなければならない。 データはメモリ上でページ境界にあってい"
"なければならず、 長さもページ境界の倍数でなければならない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:122
msgid ""
"Upon successful completion, B<vmsplice>()  returns the number of bytes "
"transferred to the pipe.  On error, B<vmsplice>()  returns -1 and I<errno> "
"is set to indicate the error."
msgstr ""
"成功して完了すると、 B<vmsplice>()  はパイプに転送したバイト数を返す。 エラー"
"の場合、 B<vmplice>()  は -1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/vmsplice.2:127
msgid "I<fd> either not valid, or doesn't refer to a pipe."
msgstr "I<fd> が有効でない、もしくはパイプを参照していない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:135
msgid ""
"I<nr_segs> is 0 or greater than B<IOV_MAX>; or memory not aligned if "
"B<SPLICE_F_GIFT> set."
msgstr ""
"I<nr_segs> が 0 もしくは B<IOV_MAX> よりも大きい。または B<SPLICE_F_GIFT> が"
"設定されたがメモリがページ境界にあっていない。"

#. type: Plain text
#: build/C/man2/vmsplice.2:143
msgid ""
"The B<vmsplice>()  system call first appeared in Linux 2.6.17; library "
"support was added to glibc in version 2.5."
msgstr ""
"B<vmsplice>() システムコールは Linux 2.6.17 で初めて登場した。\n"
"ライブラリによるサポートは glibc バージョン 2.5 で追加された。"

#. type: Plain text
#: build/C/man2/vmsplice.2:154
msgid ""
"B<vmsplice>()  follows the other vectorized read/write type functions when "
"it comes to limitations on number of segments being passed in.  This limit "
"is B<IOV_MAX> as defined in I<E<lt>limits.hE<gt>>.  At the time of this "
"writing, that limit is 1024."
msgstr ""
"指定されたセグメント数が上限に達した場合、 B<vmsplice>()  は他のベクトル形式"
"の read/write を行う関数と同じ動作をする。 上限は B<IOV_MAX> であり、 "
"I<E<lt>limits.hE<gt>> で定義されている。 このドキュメントを書いた時点での値"
"は 1024 である。"

#. type: Plain text
#: build/C/man2/vmsplice.2:157
msgid "B<splice>(2), B<tee>(2)"
msgstr "B<splice>(2), B<tee>(2)"

#, fuzzy
#~| msgid "The I<subcmd> value is one of the following:"
#~ msgid "The I<flags> argument takes one of the following values:"
#~ msgstr "I<subcmd> の値は以下のいずれかである"

#~ msgid ""
#~ "Depending on which operation was executed, the returned value for a "
#~ "successful call can have differing meanings."
#~ msgstr "どの操作が実行されたかによって、 成功時の返り値の意味が変わる。"

#~ msgid ""
#~ "Returns 0 if the process was woken by a B<FUTEX_WAKE> call.  In case of "
#~ "timeout, the operation fails with the error B<ETIMEDOUT>.  If the futex "
#~ "was not equal to the expected value, the operation fails with the error "
#~ "B<EWOULDBLOCK>.  Signals (see B<signal>(7))  or other spurious wakeups "
#~ "cause B<FUTEX_WAIT> to fail with the error B<EINTR>."
#~ msgstr ""
#~ "プロセスが B<FUTEX_WAKE> の呼び出しで wake すると 0 を返す。 タイムアウト"
#~ "の場合、操作はエラー B<ETIMEOUT> で失敗する。 futex が指定された値と等しく"
#~ "ない場合、 エラー B<EWOULDBLOCK> で失敗する。 シグナルを受信するか "
#~ "(B<signal>(7)  参照) 他の偽の wake があった場合には、エラー B<EINTR> で失"
#~ "敗する。"

#~ msgid "An operation was not defined or error in page alignment."
#~ msgstr ""
#~ "操作が定義されていない。またはページ・アラインメントでエラーが発生した。"

#, fuzzy
#~| msgid ""
#~| "Indicates that this process is to be traced by its parent.  Any signal "
#~| "(except B<SIGKILL>)  delivered to this process will cause it to stop and "
#~| "its parent to be notified via B<wait>(2).  Also, all subsequent calls to "
#~| "B<execve>(2)  by this process will cause a B<SIGTRAP> to be sent to it, "
#~| "giving the parent a chance to gain control before the new program begins "
#~| "execution.  A process probably shouldn't make this request if its parent "
#~| "isn't expecting to trace it.  (I<pid>, I<addr>, and I<data> are ignored.)"
#~ msgid ""
#~ "Indicate that this process is to be traced by its parent.  Any signal "
#~ "(except B<SIGKILL>)  delivered to this process will cause it to stop and "
#~ "its parent to be notified via B<waitpid>(2).  In addition, all subsequent "
#~ "calls to B<execve>(2)  by the traced process will cause a B<SIGTRAP> to "
#~ "be sent to it, giving the parent a chance to gain control before the new "
#~ "program begins execution.  A process probably shouldn't make this request "
#~ "if its parent isn't expecting to trace it.  (I<pid>, I<addr>, and I<data> "
#~ "are ignored.)"
#~ msgstr ""
#~ "このプロセスが親プロセスによってトレースされることを表す。 このプロセスに "
#~ "(B<SIGKILL> 以外の) シグナルが配送されると、 プロセスは停止し、親プロセス"
#~ "に B<wait>(2)  を通じて通知される。 また、これ以降はこのプロセスが "
#~ "B<execve>(2)  を呼び出す度に B<SIGTRAP> が送信されるようになる。 これに"
#~ "よって、親プロセスは 新しいプログラムが実行を開始する前に制御することがで"
#~ "きる。 親プロセスが自プロセスをトレースするつもりがない場合には、 おそらく"
#~ "このプロセスは本要求を行うべきではないだろう。 (I<pid>, I<addr>, I<data> "
#~ "は無視される。)"

#~ msgid ""
#~ "Stop the child at the next B<execve>(2)  call with I<SIGTRAP | "
#~ "PTRACE_EVENT_EXEC\\ E<lt>E<lt>\\ 8>."
#~ msgstr ""
#~ "次の B<execve>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_EXEC\\ E<lt>E<lt>"
#~ "\\ 8> で子プロセスの動作を停止させる。"

#~ msgid ""
#~ "Stop the child at the completion of the next B<vfork>(2)  call with "
#~ "I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ E<lt>E<lt>\\ 8>."
#~ msgstr ""
#~ "次の B<vfork>(2)  呼び出し時に I<SIGTRAP | PTRACE_EVENT_VFORK_DONE\\ "
#~ "E<lt>E<lt>\\ 8> で子プロセスの動作を停止させる。"

#~ msgid ""
#~ "Attaches to the process specified in I<pid>, making it a traced \"child\" "
#~ "of the calling process; the behavior of the child is as if it had done a "
#~ "B<PTRACE_TRACEME>.  The calling process actually becomes the parent of "
#~ "the child process for most purposes (e.g., it will receive notification "
#~ "of child events and appears in B<ps>(1)  output as the child's parent), "
#~ "but a B<getppid>(2)  by the child will still return the PID of the "
#~ "original parent.  The child is sent a B<SIGSTOP>, but will not "
#~ "necessarily have stopped by the completion of this call; use B<wait>(2)  "
#~ "to wait for the child to stop.  (I<addr> and I<data> are ignored.)"
#~ msgstr ""
#~ "I<pid> で指定されたプロセスに接続 (attach) し、それを呼び出し元のプロセス"
#~ "の 子プロセスとしてトレースできるようにする。子プロセスは "
#~ "B<PTRACE_TRACEME> したかのように振舞う。呼び出し元のプロセスはそのほとんど"
#~ "の目的において、 その子プロセスの実際の親になる (例えば、子プロセスのイベ"
#~ "ントの 通知を受けとったり、 B<ps>(1)  で親として表示されたりする)。しか"
#~ "し、子プロセスで B<getppid>(2)  を実行した場合には元の親プロセスの PID が"
#~ "返される。 子プロセスには B<SIGSTOP> が送られるが、この呼び出しが完了する"
#~ "までに 必ずしも停止するとは限らない。子プロセスの停止を待つには B<wait>"
#~ "(2)  を使用すること。(I<addr> と I<data> は無視される。)"

#~ msgid ""
#~ "Tracing causes a few subtle differences in the semantics of traced "
#~ "processes.  For example, if a process is attached to with "
#~ "B<PTRACE_ATTACH>, its original parent can no longer receive notification "
#~ "via B<wait>(2)  when it stops, and there is no way for the new parent to "
#~ "effectively simulate this notification."
#~ msgstr ""
#~ "トレースすることによってトレースされるプロセスの動作に些細な違いが 起こる"
#~ "ことがある。例えば、プロセスが B<PTRACE_ATTACH> によって接続された場合に"
#~ "は、そのプロセスが停止した時でも本来の親は B<wait>(2)  を使って通知を受け"
#~ "ることができず、新しい親が効率よく この通知を真似る方法もない。"

#~ msgid ""
#~ "When the parent receives an event with B<PTRACE_EVENT_*> set, the child "
#~ "is not in the normal signal delivery path.  This means the parent cannot "
#~ "do B<ptrace>(PTRACE_CONT)  with a signal or B<ptrace>(PTRACE_KILL).  "
#~ "B<kill>(2)  with a B<SIGKILL> signal can be used instead to kill the "
#~ "child process after receiving one of these messages."
#~ msgstr ""
#~ "親プロセスが B<PTRACE_EVENT_*> がセットされたイベントを受信した場合、 子プ"
#~ "ロセスは通常通りのシグナル配送が行われる状態にない。 つまり、親プロセス"
#~ "が、 シグナルにより B<ptrace>(PTRACE_CONT)  を行ったり、 B<ptrace>"
#~ "(PTRACE_KILL)  を行ったりできないということである。 こららのメッセージの受"
#~ "信後は、子プロセスを終了 (kill) するのに、 シグナル B<SIGKILL> を指定して "
#~ "B<kill>(2)  を行う方法を代わりに使用できる。"

#~ msgid ""
#~ "The SunOS man page describes B<ptrace>()  as \"unique and arcane\", which "
#~ "it is.  The proc-based debugging interface present in Solaris 2 "
#~ "implements a superset of B<ptrace>()  functionality in a more powerful "
#~ "and uniform way."
#~ msgstr ""
#~ "SunOS のマニュアル・ページには B<ptrace>()  は「独特で不可解」と記述されて"
#~ "おり、まさしくそうである。 Solaris 2 では proc ベースの デバッグのインター"
#~ "フェースとして B<ptrace>()  の上位互換関数が実装され、より強力で一貫性のあ"
#~ "るものとなっている。"

#~ msgid ""
#~ "The second argument I<special> is the block special device these quota "
#~ "apply to.  It must be mounted."
#~ msgstr ""
#~ "二番目の引き数 I<special> は quota を適用するデバイスのブロック・スペシャ"
#~ "ル・ファイルである。 そのデバイスはマウントされていなくてはならない。"

#~ msgid ""
#~ "The third argument I<id> is the user or group ID these quota apply to "
#~ "(when relevant)."
#~ msgstr ""
#~ "三番目の引き数 I<id> には、(必要な場合に) quota を適用するユーザーもしくは"
#~ "グループの ID を指定する。"

#~ msgid ""
#~ "The fourth argument I<addr> is the address of a data structure, depending "
#~ "on the command."
#~ msgstr ""
#~ "四番目の引き数 I<addr> には、コマンドごとに異ったデータ構造体のアドレスを"
#~ "指定する。"

#~ msgid ""
#~ "Enable quota.  The I<addr> argument is the pathname of the file "
#~ "containing the quota for the file system."
#~ msgstr ""
#~ "quota を有効にする。 I<addr> 引き数には、そのファイル・システムの quota が"
#~ "記録されているファイルの パス名を指定する。"

#~ msgid "Disable quota."
#~ msgstr "quota を無効にする。"

#~ msgid "Set limits and current usage; I<addr> is as before."
#~ msgstr "制限値と現在の使用量を設定する: I<addr> は同上。"

#~ msgid "Set limits; I<addr> is as before."
#~ msgstr "制限値を設定する; I<addr> は同上。"

#~ msgid "Set usage."
#~ msgstr "使用量を設定する。"

#~ msgid "Sync disk copy of a file system's quota."
#~ msgstr "ファイル・システムの quota ファイルをディスクと同期させる。"

#~ msgid "Get collected stats."
#~ msgstr "収集された統計を取得する。"

#~ msgid ""
#~ "On success, B<quotactl>()  returns 0.  On error, -1 is returned, and "
#~ "I<errno> is set appropriately."
#~ msgstr ""
#~ "B<quotactl>()  は、成功時には 0 を返す。エラー時は、-1 を返すとともに、 "
#~ "I<errno> が適切な値に設定される。"

#~ msgid "B<Q_QUOTAON> was asked, but quotas were enabled already."
#~ msgstr "B<Q_QUOTAON> の要求がなされたが、quota(s) は既に有効になっている。"

#~ msgid "Bad I<addr> value."
#~ msgstr "I<addr> の値に誤りがある。"

#~ msgid ""
#~ "I<type> is not a known quota type.  Or, I<special> could not be found."
#~ msgstr ""
#~ "I<type> が既知の quota の形式ではない。もしくは、 I<special> デバイスが見"
#~ "付からなかった。"

#~ msgid "Cannot read or write the quota file."
#~ msgstr "quota ファイルへの読み書きが出来ない。"

#~ msgid "Too many open files: cannot open quota file."
#~ msgstr "ファイルをオープンしすぎている: quota ファイルをオープン出来ない。"

#~ msgid "I<special> cannot be found in the mount table."
#~ msgstr "I<special> がマウント・テーブル内に見当たらない。"

#~ msgid "The kernel was compiled without quota support."
#~ msgstr "quota を使用可にしてカーネルをコンパイルしていない。"

#~ msgid ""
#~ "The process was not root (for the file system), and B<Q_GETQUOTA> was "
#~ "asked for another I<id> than that of the process itself, or anything "
#~ "other than B<Q_GETSTATS> or B<Q_SYNC> was asked."
#~ msgstr ""
#~ "プロセスが (そのファイル・システムの) root のものではなく、 かつプロセス自"
#~ "身のものとは異なる I<id> に対して B<Q_GETQUOTA> 要求を行なった。 もしく"
#~ "は、 B<Q_GETSTATS>, B<Q_SYNC> 以外の要求がなされた。"

#~ msgid ""
#~ "B<Q_GETQUOTA> or B<Q_SETQUOTA> or B<Q_SETUSE> or B<Q_SETQLIM> was asked "
#~ "for a file system that didn't have quota enabled."
#~ msgstr ""
#~ "quota が有効になっていないファイル・システムに対して B<Q_GETQUOTA>, "
#~ "B<Q_SETQUOTA>, B<Q_SETUSE>, B<Q_SETQLIM> のいずれかの要求がなされた。"

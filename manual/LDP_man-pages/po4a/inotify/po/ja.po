# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-17 13:13+0900\n"
"PO-Revision-Date: 2014-04-13 22:48+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/inotify.7:26
#, no-wrap
msgid "INOTIFY"
msgstr "INOTIFY"

#. type: TH
#: build/C/man7/inotify.7:26
#, fuzzy, no-wrap
#| msgid "2012-04-26"
msgid "2014-04-01"
msgstr "2012-04-26"

#. type: TH
#: build/C/man7/inotify.7:26 build/C/man2/inotify_add_watch.2:28
#: build/C/man2/inotify_init.2:29 build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/inotify.7:26 build/C/man2/inotify_add_watch.2:28
#: build/C/man2/inotify_init.2:29 build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/inotify.7:27 build/C/man2/inotify_add_watch.2:29
#: build/C/man2/inotify_init.2:30 build/C/man2/inotify_rm_watch.2:28
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/inotify.7:29
msgid "inotify - monitoring filesystem events"
msgstr "inotify - ファイルシステムイベントを監視する"

#. type: SH
#: build/C/man7/inotify.7:29 build/C/man2/inotify_add_watch.2:35
#: build/C/man2/inotify_init.2:39 build/C/man2/inotify_rm_watch.2:36
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/inotify.7:37
msgid ""
"The I<inotify> API provides a mechanism for monitoring filesystem events.  "
"Inotify can be used to monitor individual files, or to monitor directories.  "
"When a directory is monitored, inotify will return events for the directory "
"itself, and for files inside the directory."
msgstr ""
"I<inotify> API はファイルシステムイベントを監視するための機構を提供する。 "
"inotify は個々のファイルやディレクトリを監視するのに使える。 ディレクトリを監"
"視する場合、inotify はディレクトリ自身と ディレクトリ内のファイルのイベントを"
"返す。"

#. type: Plain text
#: build/C/man7/inotify.7:39
msgid "The following system calls are used with this API:"
msgstr ""

#. type: IP
#: build/C/man7/inotify.7:39 build/C/man7/inotify.7:50
#: build/C/man7/inotify.7:63 build/C/man7/inotify.7:69
#: build/C/man7/inotify.7:72
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:50
#, fuzzy
#| msgid ""
#| "B<inotify_init>(2)  creates an inotify instance and returns a file "
#| "descriptor referring to the inotify instance.  The more recent "
#| "B<inotify_init1>(2)  is like B<inotify_init>(2), but provides some extra "
#| "functionality."
msgid ""
"B<inotify_init>(2)  creates an inotify instance and returns a file "
"descriptor referring to the inotify instance.  The more recent "
"B<inotify_init1>(2)  is like B<inotify_init>(2), but has a I<flags> argument "
"that provides access to some extra functionality."
msgstr ""
"B<inotify_init>(2)  は inotify インスタンスを作成し、inotify インスタンスを参"
"照する ファイルディスクリプタを返す。 もっと新しい B<inotify_init1>(2)  も "
"B<inotify_init>(2)  と同様だが、いくつかの追加の機能が提供されている。"

#. type: Plain text
#: build/C/man7/inotify.7:63
msgid ""
"B<inotify_add_watch>(2)  manipulates the \"watch list\" associated with an "
"inotify instance.  Each item (\"watch\") in the watch list specifies the "
"pathname of a file or directory, along with some set of events that the "
"kernel should monitor for the file referred to by that pathname.  "
"B<inotify_add_watch>(2)  either creates a new watch item, or modifies an "
"existing watch.  Each watch has a unique \"watch descriptor\", an integer "
"returned by B<inotify_add_watch>(2)  when the watch is created."
msgstr ""
"B<inotify_add_watch>(2)  は inotify インスタンスに関連づけられた「監視対象 "
"(watch) リスト」を操作する。 監視対象リストの各アイテム (\"watch\") は、 ファ"
"イルまたはディレクトリのパス名と、 そのパス名で参照されるファイルに対して "
"カーネルが監視する複数のイベントの集合を指定する。 B<inotify_add_watch>(2)  "
"は新しい監視アイテムの作成や既存の監視対象の変更ができる。 各監視対象は一意の"
"「監視対象ディスクリプタ」を持つ。 これは監視対象を作成したときに "
"B<inotify_add_watch>(2)  から返される整数である。"

#. type: Plain text
#: build/C/man7/inotify.7:69
msgid ""
"When events occur for monitored files and directories, those events are made "
"available to the application as structured data that can be read from the "
"inotify file descriptor using B<read>(2)  (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:72
msgid "B<inotify_rm_watch>(2)  removes an item from an inotify watch list."
msgstr ""
"B<inotify_rm_watch>(2)  は inotify の監視対象リストからアイテムを削除する。"

#. type: Plain text
#: build/C/man7/inotify.7:79
#, fuzzy
#| msgid ""
#| "When all file descriptors referring to an inotify instance have been "
#| "closed, the underlying object and its resources are freed for reuse by "
#| "the kernel; all associated watches are automatically freed."
msgid ""
"When all file descriptors referring to an inotify instance have been closed "
"(using B<close>(2)), the underlying object and its resources are freed for "
"reuse by the kernel; all associated watches are automatically freed."
msgstr ""
"inotify インスタンスを指している 全てのファイルディスクリプタがクローズされた"
"場合、 その下層にあるオブジェクトとそのリソースは、 カーネルで再利用するため"
"に解放される。 関連が切られた監視対象は自動的に解放される。"

#. type: Plain text
#: build/C/man7/inotify.7:88
msgid ""
"With careful programming, an application can use inotify to efficiently "
"monitor and cache the state of a set of filesystem objects.  However, robust "
"applications should allow for the fact that bugs in the monitoring logic or "
"races of the kind described below may leave the cache inconsistent with the "
"filesystem state.  It is probably wise to to do some consistency checking, "
"and rebuild the cache when inconsistencies are detected."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:88
#, fuzzy, no-wrap
#| msgid "The given event mask contains no valid events; or I<fd> is not an inotify file descriptor."
msgid "Reading events from an inotify file descriptor"
msgstr "指定されたイベントマスクに有効なイベントが含まれていない。 もしくは I<fd> が inotify ファイルディスクリプタではない。"

#. type: Plain text
#: build/C/man7/inotify.7:101
msgid ""
"To determine what events have occurred, an application B<read>(2)s from the "
"inotify file descriptor.  If no events have so far occurred, then, assuming "
"a blocking file descriptor, B<read>(2)  will block until at least one event "
"occurs (unless interrupted by a signal, in which case the call fails with "
"the error B<EINTR>; see B<signal>(7))."
msgstr ""
"どのようなイベントが起こっていたかを知るには、 アプリケーションで inotify "
"ファイルディスクリプタを B<read>(2)  すればよい。 これまでに何もイベントが起"
"こっていない場合、 停止 (blocking) モードのファイルディスクリプタであれば、 "
"少なくとも 1 つのイベントが起こるまで B<read>(2)  は停止する (シグナルにより"
"割り込まれなかった場合。 シグナルによる割り込みがあった場合、呼び出しはエ"
"ラー B<EINTR> で失敗する。 B<signal>(7)  参照)。"

#. type: Plain text
#: build/C/man7/inotify.7:105
msgid ""
"Each successful B<read>(2)  returns a buffer containing one or more of the "
"following structures:"
msgstr ""
"B<read>(2)  が成功すると、以下の構造体を 1 つ以上含むバッファが返される:"

#.  FIXME . The type of the 'wd' field should probably be "int32_t".
#.  I submitted a patch to fix this.  See the LKML thread
#.  "[patch] Fix type errors in inotify interfaces", 18 Nov 2008
#.  Glibc bug filed: http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man7/inotify.7:120
#, no-wrap
msgid ""
"struct inotify_event {\n"
"    int      wd;       /* Watch descriptor */\n"
"    uint32_t mask;     /* Mask of events */\n"
"    uint32_t cookie;   /* Unique cookie associating related\n"
"                          events (for rename(2)) */\n"
"    uint32_t len;      /* Size of I<name> field */\n"
"    char     name[];   /* Optional null-terminated name */\n"
"};\n"
msgstr ""
"struct inotify_event {\n"
"    int      wd;       /* 監視対象ディスクリプタ */\n"
"    uint32_t mask;     /* イベントのマスク */\n"
"    uint32_t cookie;   /* 関連するイベント群を関連づける\n"
"                          一意なクッキー (rename(2) 用) */\n"
"    uint32_t len;      /* \\(aqname\\(aq フィールドのサイズ */\n"
"    char     name[];   /* NULL で終端された任意の名前 */\n"
"};\n"

#. type: Plain text
#: build/C/man7/inotify.7:127
msgid ""
"I<wd> identifies the watch for which this event occurs.  It is one of the "
"watch descriptors returned by a previous call to B<inotify_add_watch>(2)."
msgstr ""
"I<wd> はイベント発生の監視対象を指定する。 これは、前もって行われた "
"B<inotify_add_watch>(2)  呼び出しで返された監視対象ディスクリプタのうちの 1 "
"つである。"

#. type: Plain text
#: build/C/man7/inotify.7:130
msgid ""
"I<mask> contains bits that describe the event that occurred (see below)."
msgstr ""
"I<mask> には発生したイベント (下記参照) を記述するためのビットが含まれる。"

#. type: Plain text
#: build/C/man7/inotify.7:142
msgid ""
"I<cookie> is a unique integer that connects related events.  Currently this "
"is used only for rename events, and allows the resulting pair of "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events to be connected by the "
"application.  For all other event types, I<cookie> is set to 0."
msgstr ""
"I<cookie> は関連するイベントを関連づけるための一意な整数である。\n"
"現在のところ、この値は rename イベントに対してのみ使われており、\n"
"結果のペアである B<IN_MOVED_FROM> と B<IN_MOVED_TO> イベントを\n"
"アプリケーションで関連づけることができる。\n"
"他のイベント種別の場合には、 I<cookie> は 0 に設定する。"

#. type: Plain text
#: build/C/man7/inotify.7:151
msgid ""
"The I<name> field is present only when an event is returned for a file "
"inside a watched directory; it identifies the file pathname relative to the "
"watched directory.  This pathname is null-terminated, and may include "
"further null bytes (\\(aq\\e0\\(aq) to align subsequent reads to a suitable "
"address boundary."
msgstr ""
"I<name> フィールドは監視しているディレクトリ内のファイルに対して イベントが返"
"される場合のためにだけ存在する。 監視するディレクトリからのファイルの相対パス"
"名を表す。 このパス名は NULL で終端され、 その後の読み込みで適切なアドレス境"
"界に調整するために、 さらに NULL バイト (\\(aq\\e0\\(aq) が含まれる場合もあ"
"る。"

#. type: Plain text
#: build/C/man7/inotify.7:161
msgid ""
"The I<len> field counts all of the bytes in I<name>, including the null "
"bytes; the length of each I<inotify_event> structure is thus I<sizeof(struct "
"inotify_event)+len>."
msgstr ""
"I<len> フィールドは NULL バイトを含む I<name> の全てのバイト数を表す。\n"
"よって、 I<inotify_event> 構造体のサイズは \n"
"I<sizeof(struct inotify_event)+len> である。"

#. type: Plain text
#: build/C/man7/inotify.7:172
msgid ""
"The behavior when the buffer given to B<read>(2)  is too small to return "
"information about the next event depends on the kernel version: in kernels "
"before 2.6.21, B<read>(2)  returns 0; since kernel 2.6.21, B<read>(2)  fails "
"with the error B<EINVAL>.  Specifying a buffer of size"
msgstr ""
"B<read>(2) に渡されたバッファが小さすぎて次のイベントに関する情報を返せ\n"
"ない場合の動作はカーネルのバージョンにより異なる。 2.6.21 より前のカー\n"
"ネルでは、 B<read>(2) は 0 を返す。 2.6.21 以降のカーネルでは、\n"
"B<read>(2) はエラー B<EINVAL> で失敗する。\n"
"バッファサイズとして"

#. type: Plain text
#: build/C/man7/inotify.7:174
#, no-wrap
msgid "    sizeof(struct inotify_event) + NAME_MAX + 1\n"
msgstr "    sizeof(struct inotify_event) + NAME_MAX + 1\n"

#. type: Plain text
#: build/C/man7/inotify.7:176
msgid "will be sufficient to read at least one event."
msgstr "を指定すれば、少なくとも 1 イベントで読み出しを行うには十分である。"

#. type: SS
#: build/C/man7/inotify.7:176
#, no-wrap
msgid "inotify events"
msgstr "inotify イベント"

#. type: Plain text
#: build/C/man7/inotify.7:196
msgid ""
"The B<inotify_add_watch>(2)  I<mask> argument and the I<mask> field of the "
"I<inotify_event> structure returned when B<read>(2)ing an inotify file "
"descriptor are both bit masks identifying inotify events.  The following "
"bits can be specified in I<mask> when calling B<inotify_add_watch>(2)  and "
"may be returned in the I<mask> field returned by B<read>(2):"
msgstr ""
"B<inotify_add_watch>(2)  の I<mask> 引き数と、inotify ファイル構造体を "
"B<read>(2)  したときに返される I<inotify_event> 構造体の I<mask> フィールド"
"は、ともに inotify イベントを識別するための ビットマスクである。 以下のビット"
"が B<inotify_add_watch>(2)  を呼ぶときの I<mask> に指定可能であり、 B<read>"
"(2)  で返される I<mask> フィールドで返される:"

#. type: TP
#: build/C/man7/inotify.7:197
#, fuzzy, no-wrap
#| msgid "B<IN_ACCESS>"
msgid "B<IN_ACCESS> (*)"
msgstr "B<IN_ACCESS>"

#. type: Plain text
#: build/C/man7/inotify.7:202
#, fuzzy
#| msgid "File was accessed (read) (*)."
msgid "File was accessed (e.g., B<read>(2), B<execve>(2))."
msgstr "ファイルがアクセス (read) された。(*)"

#. type: TP
#: build/C/man7/inotify.7:202
#, fuzzy, no-wrap
#| msgid "B<IN_ATTRIB>"
msgid "B<IN_ATTRIB> (*)"
msgstr "B<IN_ATTRIB>"

#. type: Plain text
#: build/C/man7/inotify.7:217
#, fuzzy
#| msgid ""
#| "Metadata changed\\(emfor example, permissions, timestamps, extended "
#| "attributes, link count (since Linux 2.6.25), UID, or GID. (*)."
msgid ""
"Metadata changed\\(emfor example, permissions (e.g., B<chmod>(2)), "
"timestamps (e.g., B<utimensat>(2)), extended attributes (B<setxattr>(2)), "
"link count (since Linux 2.6.25; e.g., for the target of B<link>(2)  and for "
"B<unlink>(2)), and user/group ID (e.g., B<chown>(2))."
msgstr ""
"メタデータが変更された。 メタデータとは、例えば、許可 (permission)、タイムス"
"タンプ、拡張属性、 リンクカウント (Linux 2.6.25 以降)、UID、GID などである。"
"(*)"

#. type: TP
#: build/C/man7/inotify.7:217
#, fuzzy, no-wrap
#| msgid "B<IN_CLOSE_WRITE>"
msgid "B<IN_CLOSE_WRITE> (*)"
msgstr "B<IN_CLOSE_WRITE>"

#. type: Plain text
#: build/C/man7/inotify.7:220
#, fuzzy
#| msgid "File opened for writing was closed (*)."
msgid "File opened for writing was closed."
msgstr "書き込みのためにオープンされたファイルがクローズされた。(*)"

#. type: TP
#: build/C/man7/inotify.7:220
#, fuzzy, no-wrap
#| msgid "B<IN_CLOSE_NOWRITE>"
msgid "B<IN_CLOSE_NOWRITE> (*)"
msgstr "B<IN_CLOSE_NOWRITE>"

#. type: Plain text
#: build/C/man7/inotify.7:223
#, fuzzy
#| msgid "File not opened for writing was closed (*)."
msgid "File not opened for writing was closed."
msgstr "書き込み以外のためにオープンされたファイルがクローズされた。(*)"

#. type: TP
#: build/C/man7/inotify.7:223
#, fuzzy, no-wrap
#| msgid "B<IN_CREATE>"
msgid "B<IN_CREATE> (*)"
msgstr "B<IN_CREATE>"

#. type: Plain text
#: build/C/man7/inotify.7:233
msgid ""
"File/directory created in watched directory (e.g., B<open>(2)  B<O_CREAT>, "
"B<mkdir>(2), B<link>(2), B<symlink>(2), B<bind>(2)  on a UNIX domain socket)."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:233
#, fuzzy, no-wrap
#| msgid "B<IN_DELETE>"
msgid "B<IN_DELETE> (*)"
msgstr "B<IN_DELETE>"

#. type: Plain text
#: build/C/man7/inotify.7:236
#, fuzzy
#| msgid "File/directory deleted from watched directory (*)."
msgid "File/directory deleted from watched directory."
msgstr "監視対象ディレクトリ内でファイルやディレクトリが削除された。(*)"

#. type: TP
#: build/C/man7/inotify.7:236
#, no-wrap
msgid "B<IN_DELETE_SELF>"
msgstr "B<IN_DELETE_SELF>"

#. type: Plain text
#: build/C/man7/inotify.7:247
msgid ""
"Watched file/directory was itself deleted.  (This event also occurs if an "
"object is moved to another filesystem, since B<mv>(1)  in effect copies the "
"file to the other filesystem and then deletes it from the original "
"filesystem.)  In addition, an B<IN_IGNORED> event will subsequently be "
"generated for the watch descriptor."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:247
#, fuzzy, no-wrap
#| msgid "B<IN_MODIFY>"
msgid "B<IN_MODIFY> (*)"
msgstr "B<IN_MODIFY>"

#. type: Plain text
#: build/C/man7/inotify.7:252
msgid "File was modified (e.g., B<write>(2), B<truncate>(2))."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:252
#, no-wrap
msgid "B<IN_MOVE_SELF>"
msgstr "B<IN_MOVE_SELF>"

#. type: Plain text
#: build/C/man7/inotify.7:255
msgid "Watched file/directory was itself moved."
msgstr "監視対象のディレクトリまたはファイル自身が移動された。"

#. type: TP
#: build/C/man7/inotify.7:255
#, fuzzy, no-wrap
#| msgid "B<IN_MOVED_FROM>"
msgid "B<IN_MOVED_FROM> (*)"
msgstr "B<IN_MOVED_FROM>"

#. type: Plain text
#: build/C/man7/inotify.7:259
#, fuzzy
#| msgid ""
#| "Generated for the directory containing the old filename when a file is "
#| "renamed (*)."
msgid ""
"Generated for the directory containing the old filename when a file is "
"renamed."
msgstr ""
"ファイル名の変更を行った際に変更前のファイル名が含まれるディレクトリに対して"
"生成される。 (*)"

#. type: TP
#: build/C/man7/inotify.7:259
#, fuzzy, no-wrap
#| msgid "B<IN_MOVED_TO>"
msgid "B<IN_MOVED_TO> (*)"
msgstr "B<IN_MOVED_TO>"

#. type: Plain text
#: build/C/man7/inotify.7:263
#, fuzzy
#| msgid ""
#| "Generated for the directory containing the new filename when a file is "
#| "renamed (*)."
msgid ""
"Generated for the directory containing the new filename when a file is "
"renamed."
msgstr ""
"ファイル名の変更を行った際に新しいファイル名が含まれるディレクトリに対して生"
"成される。 (*)"

#. type: TP
#: build/C/man7/inotify.7:263
#, fuzzy, no-wrap
#| msgid "B<IN_OPEN>"
msgid "B<IN_OPEN> (*)"
msgstr "B<IN_OPEN>"

#. type: Plain text
#: build/C/man7/inotify.7:266
#, fuzzy
#| msgid "File was opened (*)."
msgid "File was opened."
msgstr "ファイルがオープンされた。(*)"

#. type: Plain text
#: build/C/man7/inotify.7:275
msgid ""
"When monitoring a directory, the events marked with an asterisk (*) above "
"can occur for files in the directory, in which case the I<name> field in the "
"returned I<inotify_event> structure identifies the name of the file within "
"the directory."
msgstr ""
"ディレクトリを監視する場合、 上記でアスタリスク (*) を付けたイベントは、 その"
"ディレクトリ内のファイルに対して発生する。 このとき I<inotify_event> 構造体で"
"返される I<name> フィールドは、ディレクトリ内のファイル名を表す。"

#. type: Plain text
#: build/C/man7/inotify.7:283
msgid ""
"The B<IN_ALL_EVENTS> macro is defined as a bit mask of all of the above "
"events.  This macro can be used as the I<mask> argument when calling "
"B<inotify_add_watch>(2)."
msgstr ""
"B<IN_ALL_EVENTS> マクロは上記のイベント全てのマスクとして定義される。 このマ"
"クロは B<inotify_add_watch>(2)  を呼び出すときの I<mask> 引き数として使える。"

#. type: Plain text
#: build/C/man7/inotify.7:285
msgid "Two additional convenience macros are defined:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:286
#, fuzzy, no-wrap
#| msgid "B<IN_MOVED_TO>"
msgid "B<IN_MOVE>"
msgstr "B<IN_MOVED_TO>"

#. type: Plain text
#: build/C/man7/inotify.7:290
msgid "Equates to B<IN_MOVED_FROM | IN_MOVED_TO>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:290
#, fuzzy, no-wrap
#| msgid "B<IN_CLOEXEC>"
msgid "B<IN_CLOSE>"
msgstr "B<IN_CLOEXEC>"

#. type: Plain text
#: build/C/man7/inotify.7:294
msgid "Equates to B<IN_CLOSE_WRITE | IN_CLOSE_NOWRITE>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:300
msgid ""
"The following further bits can be specified in I<mask> when calling "
"B<inotify_add_watch>(2):"
msgstr ""
"その他にも以下のビットを B<inotify_add_watch>(2)  を呼ぶときの I<mask> に指定"
"できる:"

#. type: TP
#: build/C/man7/inotify.7:301
#, no-wrap
msgid "B<IN_DONT_FOLLOW> (since Linux 2.6.15)"
msgstr "B<IN_DONT_FOLLOW>"

#. type: Plain text
#: build/C/man7/inotify.7:306
msgid "Don't dereference I<pathname> if it is a symbolic link."
msgstr ""
"I<pathname> がシンボリックリンクである場合に辿らない。 (Linux 2.6.15 以降)"

#. type: TP
#: build/C/man7/inotify.7:306
#, no-wrap
msgid "B<IN_EXCL_UNLINK> (since Linux 2.6.36)"
msgstr "B<IN_EXCL_UNLINK> (Linux 2.6.36 以降)"

#.  commit 8c1934c8d70b22ca8333b216aec6c7d09fdbd6a6
#. type: Plain text
#: build/C/man7/inotify.7:322
msgid ""
"By default, when watching events on the children of a directory, events are "
"generated for children even after they have been unlinked from the "
"directory.  This can result in large numbers of uninteresting events for "
"some applications (e.g., if watching I</tmp>, in which many applications "
"create temporary files whose names are immediately unlinked).  Specifying "
"B<IN_EXCL_UNLINK> changes the default behavior, so that events are not "
"generated for children after they have been unlinked from the watched "
"directory."
msgstr ""
"デフォルトでは、あるディレクトリの子ファイルに関するイベントを監視 (watch) し"
"た際、ディレクトリからその子ファイルが削除 (unlink) された場合であってもその"
"子ファイルに対してイベントが生成される。このことは、アプリケーションによって"
"はあまり興味のないイベントが大量に発生することにつながる (例えば、I</tmp> を"
"監視している場合、たくさんのアプリケーションが、すぐにその名前が削除される一"
"時ファイルをそのディレクトリに作成する)。 B<IN_EXCL_UNLINK> を指定するとこの"
"デフォルトの動作を変更でき、監視対象のディレクトリから子ファイルが削除された"
"後に子ファイルに関するイベントが生成されなくなる。"

#. type: TP
#: build/C/man7/inotify.7:322
#, no-wrap
msgid "B<IN_MASK_ADD>"
msgstr "B<IN_MASK_ADD>"

#. type: Plain text
#: build/C/man7/inotify.7:326
msgid ""
"Add (OR) events to watch mask for this pathname if it already exists "
"(instead of replacing mask)."
msgstr ""
"I<pathname> に対する監視マスクが既に存在する場合、 (マスクの置き換えではな"
"く) イベントを追加 (OR) する。"

#. type: TP
#: build/C/man7/inotify.7:326
#, no-wrap
msgid "B<IN_ONESHOT>"
msgstr "B<IN_ONESHOT>"

#. type: Plain text
#: build/C/man7/inotify.7:332
msgid "Monitor I<pathname> for one event, then remove from watch list."
msgstr ""
"1 つのイベントについて I<pathname> を監視し、 イベントが発生したら監視対象リ"
"ストから削除する。"

#. type: TP
#: build/C/man7/inotify.7:332
#, no-wrap
msgid "B<IN_ONLYDIR> (since Linux 2.6.15)"
msgstr "B<IN_ONLYDIR> (Linux 2.6.15 以降)"

#. type: Plain text
#: build/C/man7/inotify.7:337
msgid "Only watch I<pathname> if it is a directory."
msgstr "I<pathname> がディレクトリの場合にのみ監視する。"

#. type: Plain text
#: build/C/man7/inotify.7:343
msgid ""
"The following bits may be set in the I<mask> field returned by B<read>(2):"
msgstr "以下のビットが B<read>(2)  で返される I<mask> フィールドに設定される:"

#. type: TP
#: build/C/man7/inotify.7:344
#, no-wrap
msgid "B<IN_IGNORED>"
msgstr "B<IN_IGNORED>"

#. type: Plain text
#: build/C/man7/inotify.7:350
#, fuzzy
#| msgid ""
#| "Watch was removed explicitly (B<inotify_rm_watch>(2))  or automatically "
#| "(file was deleted, or filesystem was unmounted)."
msgid ""
"Watch was removed explicitly (B<inotify_rm_watch>(2))  or automatically "
"(file was deleted, or filesystem was unmounted).  See also BUGS."
msgstr ""
"監視対象が (B<inotify_rm_watch>(2) により) 明示的に 削除された。もしくは "
"(ファイルの削除、またはファイル システムのアンマウントにより) 自動的に削除さ"
"れた。"

#. type: TP
#: build/C/man7/inotify.7:350
#, no-wrap
msgid "B<IN_ISDIR>"
msgstr "B<IN_ISDIR>"

#. type: Plain text
#: build/C/man7/inotify.7:353
msgid "Subject of this event is a directory."
msgstr "このイベントの対象がディレクトリである。"

#. type: TP
#: build/C/man7/inotify.7:353
#, no-wrap
msgid "B<IN_Q_OVERFLOW>"
msgstr "B<IN_Q_OVERFLOW>"

#. type: Plain text
#: build/C/man7/inotify.7:358
msgid "Event queue overflowed (I<wd> is -1 for this event)."
msgstr "イベントキューが溢れた (このイベントの場合、I<wd> は -1 である)。"

#. type: TP
#: build/C/man7/inotify.7:358
#, no-wrap
msgid "B<IN_UNMOUNT>"
msgstr "B<IN_UNMOUNT>"

#. type: Plain text
#: build/C/man7/inotify.7:364
#, fuzzy
#| msgid ""
#| "Removing a watch causes an B<IN_IGNORED> event to be generated for this "
#| "watch descriptor.  (See B<inotify>(7).)"
msgid ""
"Filesystem containing watched object was unmounted.  In addition, an "
"B<IN_IGNORED> event will subsequently be generated for the watch descriptor."
msgstr ""
"監視対象を削除すると、 この監視対象ディスクリプタに対して B<IN_IGNORED> イベ"
"ントが生成される (B<inotify>(7)  参照)。"

#. type: SS
#: build/C/man7/inotify.7:365
#, no-wrap
msgid "Examples"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:373
msgid ""
"Suppose an application is watching the directory I<dir> and the file I<dir/"
"myfile> for all events.  The examples below show some events that will be "
"generated for these two objects."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:374
#, no-wrap
msgid "fd = open(\"dir/myfile\", O_RDWR);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:382
msgid "Generates B<IN_OPEN> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:382
#, no-wrap
msgid "read(fd, buf, count);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:390
msgid "Generates B<IN_ACCESS> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:390
#, no-wrap
msgid "write(fd, buf, count);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:398
msgid "Generates B<IN_MODIFY> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:398
#, no-wrap
msgid "fchmod(fd, mode);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:406
msgid "Generates B<IN_ATTRIB> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:406
#, no-wrap
msgid "close(fd);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:414
msgid "Generates B<IN_CLOSE_WRITE> events for both I<dir> and I<dir/myfile>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:423
msgid ""
"Suppose an application is watching the directories I<dir1> and I<dir>, and "
"the file I<dir1/myfile>.  The following examples show some events that may "
"be generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:424
#, no-wrap
msgid "link(\"dir/myfile\", \"dir2/new\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:434
msgid ""
"Generates an B<IN_ATTRIB> event for I<myfile> and an B<IN_CREATE> event for "
"I<dir2>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:434
#, no-wrap
msgid "rename(\"dir1/myfile\", \"dir2/myfile\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:455
msgid ""
"Generates an B<IN_MOVED_FROM> event for I<dir1>, an B<IN_MOVED_TO> event for "
"I<dir2>, and an B<IN_MOVE_SELF> event for I<myfile>.  The B<IN_MOVED_FROM> "
"and B<IN_MOVED_TO> events will have the same I<cookie> value."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:469
msgid ""
"Suppose that I<dir1/xx> and I<dir2/yy> are (the only) links to the same "
"file, and an application is watching I<dir1>, I<dir2>, I<dir1/xx>, and "
"I<dir2/yy>.  Executing the following calls in the order given below will "
"generate the following events:"
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:470
#, no-wrap
msgid "unlink(\"dir2/yy\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:481
msgid ""
"Generates B<IN_ATTRIB> event for I<xx> (because its link count changes)  and "
"an B<IN_DELETE> event for I<dir2>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:481
#, no-wrap
msgid "unlink(\"dir1/xx\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:494
msgid ""
"Generates B<IN_ATTRIB>, B<IN_DELETE_SELF>, and B<IN_IGNORED> events for "
"I<xx>, and an B<IN_DELETE> for I<dir1>."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:501
msgid ""
"Suppose an application is watching the directory I<dir> and (the empty) "
"directory I<dir/subdir>.  The following examples show some events that may "
"be generated."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:502
#, no-wrap
msgid "mkdir(\"dir/new\", mode);"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:508
msgid "Generates an B<IN_CREATE | IN_ISDIR> event for I<dir>."
msgstr ""

#. type: TP
#: build/C/man7/inotify.7:508
#, no-wrap
msgid "rmdir(\"dir/sub\");"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:520
msgid ""
"Generates B<IN_DELETE_SELF> and B<IN_IGNORED> events for I<subdir>, and an "
"B<IN_DELETE | IN_ISDIR> event for I<dir>."
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:521
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インターフェース"

#. type: Plain text
#: build/C/man7/inotify.7:524
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by inotify:"
msgstr ""
"以下のインターフェースは、inotify で消費される カーネルメモリの総量を制限する"
"のに使用できる:"

#. type: TP
#: build/C/man7/inotify.7:524
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_queued_events>"
msgstr "I</proc/sys/fs/inotify/max_queued_events>"

#. type: Plain text
#: build/C/man7/inotify.7:533
msgid ""
"The value in this file is used when an application calls B<inotify_init>(2)  "
"to set an upper limit on the number of events that can be queued to the "
"corresponding inotify instance.  Events in excess of this limit are dropped, "
"but an B<IN_Q_OVERFLOW> event is always generated."
msgstr ""
"このファイルの値は、アプリケーションが B<inotify_init>(2)  を呼び出すときに使"
"用され、対応する inotify インスタンスについて キューに入れられるイベントの数"
"の上限を設定する。 この制限を超えたイベントは破棄されるが、 B<IN_Q_OVERFLOW> "
"イベントが常に生成される。"

#. type: TP
#: build/C/man7/inotify.7:533
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_instances>"
msgstr "I</proc/sys/fs/inotify/max_user_instances>"

#. type: Plain text
#: build/C/man7/inotify.7:537
msgid ""
"This specifies an upper limit on the number of inotify instances that can be "
"created per real user ID."
msgstr ""
"1 つの実ユーザ ID に対して生成できる inotify インスタンスの数の上限を指定す"
"る。"

#. type: TP
#: build/C/man7/inotify.7:537
#, no-wrap
msgid "I</proc/sys/fs/inotify/max_user_watches>"
msgstr "I</proc/sys/fs/inotify/max_user_watches>"

#. type: Plain text
#: build/C/man7/inotify.7:541
msgid ""
"This specifies an upper limit on the number of watches that can be created "
"per real user ID."
msgstr "作成可能な監視対象の数の実 UID 単位の上限を指定する。"

#. type: SH
#: build/C/man7/inotify.7:541 build/C/man2/inotify_add_watch.2:118
#: build/C/man2/inotify_init.2:94 build/C/man2/inotify_rm_watch.2:67
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/inotify.7:549
#, fuzzy
#| msgid ""
#| "Inotify was merged into the 2.6.13 Linux kernel.  The required library "
#| "interfaces were added to glibc in version 2.4.  (B<IN_DONT_FOLLOW>, "
#| "B<IN_MASK_ADD>, and B<IN_ONLYDIR> were added in version 2.5.)"
msgid ""
"Inotify was merged into the 2.6.13 Linux kernel.  The required library "
"interfaces were added to glibc in version 2.4.  (B<IN_DONT_FOLLOW>, "
"B<IN_MASK_ADD>, and B<IN_ONLYDIR> were added in glibc version 2.5.)"
msgstr ""
"inotify は 2.6.13 の Linux カーネルに組込まれた。 これに必要なライブラリのイ"
"ンターフェースは、 glibc のバージョン 2.4 に追加された (B<IN_DONT_FOLLOW>, "
"B<IN_MASK_ADD>, B<IN_ONLYDIR> はバージョン 2.5 で追加された)。"

#. type: SH
#: build/C/man7/inotify.7:549 build/C/man2/inotify_add_watch.2:120
#: build/C/man2/inotify_init.2:101 build/C/man2/inotify_rm_watch.2:69
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/inotify.7:551
msgid "The inotify API is Linux-specific."
msgstr "inotify API は Linux 独自のものである。"

#. type: SH
#: build/C/man7/inotify.7:551
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man7/inotify.7:558
msgid ""
"Inotify file descriptors can be monitored using B<select>(2), B<poll>(2), "
"and B<epoll>(7).  When an event is available, the file descriptor indicates "
"as readable."
msgstr ""
"inotify ファイルディスクリプタは B<select>(2), B<poll>(2), B<epoll>(7)  を"
"使って監視できる。 イベントがある場合、ファイルディスクリプタは読み込み可能と"
"通知する。"

#. type: Plain text
#: build/C/man7/inotify.7:587
msgid ""
"Since Linux 2.6.25, signal-driven I/O notification is available for inotify "
"file descriptors; see the discussion of B<F_SETFL> (for setting the "
"B<O_ASYNC> flag), B<F_SETOWN>, and B<F_SETSIG> in B<fcntl>(2).  The "
"I<siginfo_t> structure (described in B<sigaction>(2))  that is passed to the "
"signal handler has the following fields set: I<si_fd> is set to the inotify "
"file descriptor number; I<si_signo> is set to the signal number; I<si_code> "
"is set to B<POLL_IN>; and B<POLLIN> is set in I<si_band>."
msgstr ""
"Linux 2.6.25 以降では、シグナル駆動 (signal-driven) I/O の通知が inotify ファ"
"イルディスクリプタについて利用可能である。 B<fcntl>(2)  に書かれている "
"(B<O_ASYNC> フラグを設定するための)  B<F_SETFL>, B<F_SETOWN>, B<F_SETSIG> の"
"議論を参照のこと。 シグナルハンドラに渡される I<siginfo_t> 構造体は、以下の"
"フィールドが設定される (I<siginfo_t> は B<sigaction>(2)  で説明されている)。 "
"I<si_fd> には inotify ファイルディスクリプタ番号が、 I<si_signo> にはシグナル"
"番号が、 I<si_code> には B<POLL_IN> が、 I<si_band> には B<POLLIN> が設定され"
"る。"

#. type: Plain text
#: build/C/man7/inotify.7:600
#, fuzzy
#| msgid ""
#| "If successive output inotify events produced on the inotify file "
#| "descriptor are identical (same I<wd>, I<mask>, I<cookie>, and I<name>)  "
#| "then they are coalesced into a single event if the older event has not "
#| "yet been read (but see BUGS)."
msgid ""
"If successive output inotify events produced on the inotify file descriptor "
"are identical (same I<wd>, I<mask>, I<cookie>, and I<name>), then they are "
"coalesced into a single event if the older event has not yet been read (but "
"see BUGS).  This reduces the amount of kernel memory required for the event "
"queue, but also means that an application can't use inotify to reliably "
"count file events."
msgstr ""
"inotify ファイルディスクリプタに対して 連続して生成される出力 inotify イベン"
"トが同一の場合 (I<wd>, I<mask>, I<cookie>, I<name> が等しい場合)、 前のイベン"
"トがまだ読み込まれていなければ、 連続するイベントが 1 つのイベントにまとめら"
"れる (ただし「バグ」の節も参照のこと)。"

#. type: Plain text
#: build/C/man7/inotify.7:606
msgid ""
"The events returned by reading from an inotify file descriptor form an "
"ordered queue.  Thus, for example, it is guaranteed that when renaming from "
"one directory to another, events will be produced in the correct order on "
"the inotify file descriptor."
msgstr ""
"inotify ファイルディスクリプタの読み込みで返されるイベントは、 順序付けられた"
"キューになる。 従って、たとえば、あるディレクトリの名前を別の名前に変更した場"
"合、 inotify ファイルディスクリプタについての正しい順番で イベントが生成され"
"ることが保証される。"

#. type: Plain text
#: build/C/man7/inotify.7:612
msgid ""
"The B<FIONREAD> B<ioctl>(2)  returns the number of bytes available to read "
"from an inotify file descriptor."
msgstr ""
"B<FIONREAD> B<ioctl>(2)  は inotify ファイルディスクリプタから何バイト読み込"
"めるかを返す。"

#. type: SS
#: build/C/man7/inotify.7:612
#, no-wrap
msgid "Limitations and caveats"
msgstr "制限と警告"

#. type: Plain text
#: build/C/man7/inotify.7:619
msgid ""
"The inotify API provides no information about the user or process that "
"triggered the inotify event.  In particular, there is no easy way for a "
"process that is monitoring events via inotify to distinguish events that it "
"triggers itself from those that are triggered by other processes."
msgstr ""
"inotify API では、inotify イベントが発生するきっかけとなったユーザやプロセス"
"に関する情報は提供されない。とりわけ、inotify 経由でイベントを監視しているプ"
"ロセスが、自分自身がきっかけとなったイベントと他のプロセスがきっかけとなった"
"イベントを区別する簡単な手段はない。"

#. type: Plain text
#: build/C/man7/inotify.7:632
msgid ""
"Inotify reports only events that a user-space program triggers through the "
"filesystem API.  As a result, it does not catch remote events that occur on "
"network filesystems.  (Applications must fall back to polling the filesystem "
"to catch such events.)  Furthermore, various pseudo-filesystems such as I</"
"proc>, I</sys>, and I</dev/pts> are not monitorable with inotify."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:638
msgid ""
"The inotify API does not report file accesses and modifications that may "
"occur because of B<mmap>(2)  and B<msync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:642
msgid ""
"The inotify API identifies affected files by filename.  However, by the time "
"an application processes an inotify event, the filename may already have "
"been deleted or renamed."
msgstr ""
"inotify API では影響が受けるファイルをファイル名で特定する。\n"
"しかしながら、アプリケーションが inotify イベントを処理する時点では、\n"
"そのファイル名がすでに削除されたり変更されたりしている可能性がある。"

#. type: Plain text
#: build/C/man7/inotify.7:647
msgid ""
"The inotify API identifies events via watch descriptors.  It is the "
"application's responsibility to cache a mapping (if one is needed) between "
"watch descriptors and pathnames.  Be aware that directory renamings may "
"affect multiple cached pathnames."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:652
msgid ""
"Inotify monitoring of directories is not recursive: to monitor "
"subdirectories under a directory, additional watches must be created.  This "
"can take a significant amount time for large directory trees."
msgstr ""
"inotify によるディレクトリの監視は再帰的に行われない: あるディレクトリ以下"
"の\n"
"サブディレクトリを監視する場合、 監視対象を追加で作成しなければならない。\n"
"大きなディレクトリツリーの場合には、この作業にかなり時間がかかることがある。"

#. type: Plain text
#: build/C/man7/inotify.7:661
#, fuzzy
#| msgid ""
#| "If monitoring an entire directory subtree, and a new subdirectory is "
#| "created in that tree, be aware that by the time you create a watch for "
#| "the new subdirectory, new files may already have been created in the "
#| "subdirectory.  Therefore, you may want to scan the contents of the "
#| "subdirectory immediately after adding the watch."
msgid ""
"If monitoring an entire directory subtree, and a new subdirectory is created "
"in that tree or an existing directory is renamed into that tree, be aware "
"that by the time you create a watch for the new subdirectory, new files (and "
"subdirectories) may already exist inside the subdirectory.  Therefore, you "
"may want to scan the contents of the subdirectory immediately after adding "
"the watch (and, if desired, recursively add watches for any subdirectories "
"that it contains)."
msgstr ""
"ディレクトリツリー全体を監視していて、そのツリー内に新しいサブディレクトリ"
"が\n"
"作成される場合、新しいサブディレクトリに対する watch を作成するまでに、\n"
"新しいファイルがそのサブディレクトリ内にすでに作成されている場合がある点に\n"
"注意すること。したがって、watch を追加した直後にサブディレクトリの内容を\n"
"スキャンしたいと思う場合もあるだろう。"

#. type: Plain text
#: build/C/man7/inotify.7:673
msgid ""
"Note that the event queue can overflow.  In this case, events are lost.  "
"Robust applications should handle the possibility of lost events "
"gracefully.  For example, it may be necessary to rebuild part or all of the "
"application cache.  (One simple, but possibly expensive, approach is to "
"close the inotify file descriptor, empty the cache, create a new inotify "
"file descriptor, and then re-create watches and cache entries for the "
"objects to be monitored.)"
msgstr ""

#. type: SS
#: build/C/man7/inotify.7:673
#, no-wrap
msgid "Dealing with rename() events"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:682
msgid ""
"As noted above, the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair that is "
"generated by B<rename>(2)  can be matched up via their shared cookie value.  "
"However, the task of matching has some challenges."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:693
msgid ""
"These two events are usually consecutive in the event stream available when "
"reading from the inotify file descriptor.  However, this is not guaranteed.  "
"If multiple processes are triggering events for monitored objects, then (on "
"rare occasions) an arbitrary number of other events may appear between the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events."
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:718
msgid ""
"Matching up the B<IN_MOVED_FROM> and B<IN_MOVED_TO> event pair generated by "
"B<rename>(2)  is thus inherently racy.  (Don't forget that if an object is "
"renamed outside of a monitored directory, there may not even be an "
"B<IN_MOVED_TO> event.)  Heuristic approaches (e.g., assume the events are "
"always consecutive)  can be used to ensure a match in most cases, but will "
"inevitably miss some cases, causing the application to perceive the "
"B<IN_MOVED_FROM> and B<IN_MOVED_TO> events as being unrelated.  If watch "
"descriptors are destroyed and re-created as a result, then those watch "
"descriptors will be inconsistent with the watch descriptors in any pending "
"events.  (Re-creating the inotify file descriptor and rebuilding the cache "
"may be useful to deal with this scenario.)"
msgstr ""

#. type: Plain text
#: build/C/man7/inotify.7:728
msgid ""
"Applications should also allow for the possibility that the B<IN_MOVED_FROM> "
"event was the last event that could fit in the buffer returned by the "
"current call to B<read>(2), and the accompanying B<IN_MOVED_TO> event might "
"be fetched only on the next B<read>(2)."
msgstr ""

#. type: SH
#: build/C/man7/inotify.7:728
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  FIXME kernel commit 611da04f7a31b2208e838be55a42c7a1310ae321
#.  implies that unmount events were buggy 2.6.11 to 2.6.36
#. type: Plain text
#: build/C/man7/inotify.7:736
msgid "In kernels before 2.6.16, the B<IN_ONESHOT> I<mask> flag does not work."
msgstr "2.6.16 以前のカーネルでは B<IN_ONESHOT> I<mask> フラグが働かない。"

#. type: Plain text
#: build/C/man7/inotify.7:746
msgid ""
"As originally designed and implemented, the B<IN_ONESHOT> flag did not cause "
"an B<IN_IGNORED> event to be generated when the watch was dropped after one "
"event.  However, as an unintended effect of other changes, since Linux "
"2.6.36, an B<IN_IGNORED> event is generated in this case."
msgstr ""

#.  commit 1c17d18e3775485bf1e0ce79575eb637a94494a2
#. type: Plain text
#: build/C/man7/inotify.7:755
msgid ""
"Before kernel 2.6.25, the kernel code that was intended to coalesce "
"successive identical events (i.e., the two most recent events could "
"potentially be coalesced if the older had not yet been read)  instead "
"checked if the most recent event could be coalesced with the I<oldest> "
"unread event."
msgstr ""
"カーネル 2.6.25 より前では、 連続する同一のイベントを一つにまとめることを意図"
"したコード (古い方のイベントがまだ読み込まれていない場合に、 最新の 2 つのイ"
"ベントを一つにまとめられる可能性がある) が、 最新のイベントが「最も古い」読み"
"込まれていないイベントとまとめられるか をチェックするようになっていた。"

#. type: SH
#: build/C/man7/inotify.7:755 build/C/man2/inotify_add_watch.2:122
#: build/C/man2/inotify_init.2:103 build/C/man2/inotify_rm_watch.2:71
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/inotify.7:764
msgid ""
"B<inotifywait>(1), B<inotifywatch>(1), B<inotify_add_watch>(2), "
"B<inotify_init>(2), B<inotify_init1>(2), B<inotify_rm_watch>(2), B<read>(2), "
"B<stat>(2)"
msgstr ""
"B<inotifywait>(1), B<inotifywatch>(1), B<inotify_add_watch>(2), "
"B<inotify_init>(2), B<inotify_init1>(2), B<inotify_rm_watch>(2), B<read>(2), "
"B<stat>(2)"

#. type: Plain text
#: build/C/man7/inotify.7:767
msgid ""
"I<Documentation/filesystems/inotify.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/filesystems/inotify.txt>"

#. type: SH
#: build/C/man7/inotify.7:767 build/C/man2/inotify_add_watch.2:126
#: build/C/man2/inotify_init.2:107 build/C/man2/inotify_rm_watch.2:75
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/inotify.7:774 build/C/man2/inotify_add_watch.2:133
#: build/C/man2/inotify_init.2:114 build/C/man2/inotify_rm_watch.2:82
#, fuzzy
#| msgid ""
#| "This page is part of release 3.63 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at \\%http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.64 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.63 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/inotify_add_watch.2:28
#, no-wrap
msgid "INOTIFY_ADD_WATCH"
msgstr "INOTIFY_ADD_WATCH"

#. type: TH
#: build/C/man2/inotify_add_watch.2:28 build/C/man2/inotify_init.2:29
#, no-wrap
msgid "2014-03-28"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:31
msgid "inotify_add_watch - add a watch to an initialized inotify instance"
msgstr ""
"inotify_add_watch - 初期化済み inotify インスタンスに監視対象を追加する"

#. type: SH
#: build/C/man2/inotify_add_watch.2:31 build/C/man2/inotify_init.2:32
#: build/C/man2/inotify_rm_watch.2:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:33 build/C/man2/inotify_rm_watch.2:32
msgid "B<#include E<lt>sys/inotify.hE<gt>>"
msgstr "B<#include E<lt>sys/inotify.hE<gt>>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:35
msgid ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"
msgstr ""
"B<int inotify_add_watch(int >I<fd>B<, const char *>I<pathname>B<, uint32_t "
">I<mask>B<);>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:54
msgid ""
"B<inotify_add_watch>()  adds a new watch, or modifies an existing watch, for "
"the file whose location is specified in I<pathname>; the caller must have "
"read permission for this file.  The I<fd> argument is a file descriptor "
"referring to the inotify instance whose watch list is to be modified.  The "
"events to be monitored for I<pathname> are specified in the I<mask> bit-mask "
"argument.  See B<inotify>(7)  for a description of the bits that can be set "
"in I<mask>."
msgstr ""
"B<inotify_add_watch>()  は、 I<pathname> で指定された位置にあるファイルを監視"
"する監視アイテム (watch) の新規追加、 または既存の監視アイテムの変更を行う。 "
"呼び出し元は、監視対象のファイルに対する読み出し許可を 持っていなければならな"
"い。 I<fd> 引き数は、変更を行う監視対象リスト (watch list) を持つ inotify イ"
"ンスタンスを参照するファイルディスクリプタである。 I<pathname> のどのイベント"
"を監視するかは、引き数のビットマスク I<mask> で指定する。 I<mask> に設定でき"
"るビットの説明については B<inotify>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:68
msgid ""
"A successful call to B<inotify_add_watch>()  returns the unique watch "
"descriptor associated with I<pathname> for this inotify instance.  If "
"I<pathname> was not previously being watched by this inotify instance, then "
"the watch descriptor is newly allocated.  If I<pathname> was already being "
"watched, then the descriptor for the existing watch is returned."
msgstr ""
"B<inotify_add_watch>()  の呼び出しが成功すると、変更対象の inotify インスタン"
"スで I<pathname> に対応付けられる一意な監視対象ディスクリプタ (watch "
"descriptor) を返す。 I<pathname> がその inotify インスタンスに追加されていな"
"ければ、 監視対象ディスクリプタが新規に割り当てられる。 I<pathname> がすでに"
"監視対象になっていれば、既存の監視アイテムに対する ディスクリプタが返される。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:79
msgid ""
"The watch descriptor is returned by later B<read>(2)s from the inotify file "
"descriptor.  These reads fetch I<inotify_event> structures (see B<inotify>"
"(7))  indicating filesystem events; the watch descriptor inside this "
"structure identifies the object for which the event occurred."
msgstr ""
"これ以降に inotify ファイルディスクリプタから B<read>(2)  を行うと、監視対象"
"ディスクリプタが返される。 これらの B<read>()  を行うと、ファイルシステムイベ"
"ントを示す I<inotify_event> 構造体が読み出される (B<inotify>(7)  参照)。この"
"構造体内の監視対象ディスクリプタにより、 どのオブジェクトでそのイベントが発生"
"したかを特定できる。"

#. type: SH
#: build/C/man2/inotify_add_watch.2:79 build/C/man2/inotify_init.2:74
#: build/C/man2/inotify_rm_watch.2:48
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:86
msgid ""
"On success, B<inotify_add_watch>()  returns a nonnegative watch descriptor.  "
"On error, -1 is returned and I<errno> is set appropriately."
msgstr ""
"成功すると、 B<inotify_add_watch>()  は非負の監視対象ディスクリプタを返す。 "
"エラーの場合、-1 を返し、 I<errno> を適切に設定する。"

#. type: SH
#: build/C/man2/inotify_add_watch.2:86 build/C/man2/inotify_init.2:79
#: build/C/man2/inotify_rm_watch.2:55
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/inotify_add_watch.2:87
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:90
msgid "Read access to the given file is not permitted."
msgstr "指定されたファイルに対する読み出しアクセスが許可されていない。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:90 build/C/man2/inotify_rm_watch.2:56
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:93
msgid "The given file descriptor is not valid."
msgstr "指定されたファイルディスクリプタが有効ではない。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:93
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:97
msgid "I<pathname> points outside of the process's accessible address space."
msgstr ""
"I<pathname> が指すアドレスがプロセスがアクセスできるアドレス空間外である。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:97 build/C/man2/inotify_init.2:80
#: build/C/man2/inotify_rm_watch.2:60
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:102
msgid ""
"The given event mask contains no valid events; or I<fd> is not an inotify "
"file descriptor."
msgstr ""
"指定されたイベントマスクに有効なイベントが含まれていない。 もしくは I<fd> が "
"inotify ファイルディスクリプタではない。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:102
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:106
msgid "I<pathname> is too long."
msgstr ""

#. type: TP
#: build/C/man2/inotify_add_watch.2:106
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:111
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> のディレクトリ部分の構成要素が、存在しないか、\n"
"リンク切れのシンボリックリンクである。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:111 build/C/man2/inotify_init.2:91
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:114
msgid "Insufficient kernel memory was available."
msgstr "カーネルメモリが十分になかった。"

#. type: TP
#: build/C/man2/inotify_add_watch.2:114
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:118
msgid ""
"The user limit on the total number of inotify watches was reached or the "
"kernel failed to allocate a needed resource."
msgstr ""
"inotify 監視対象の総数がユーザが追加できる上限に達していた。 もしくは、必要な"
"資源の割り当てにカーネルが失敗した。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:120 build/C/man2/inotify_rm_watch.2:69
msgid "Inotify was merged into the 2.6.13 Linux kernel."
msgstr "inotify は Linux カーネル 2.6.13 に組み込まれた。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:122 build/C/man2/inotify_rm_watch.2:71
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/inotify_add_watch.2:126
msgid "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr "B<inotify_init>(2), B<inotify_rm_watch>(2), B<inotify>(7)"

#. type: TH
#: build/C/man2/inotify_init.2:29
#, no-wrap
msgid "INOTIFY_INIT"
msgstr "INOTIFY_INIT"

#. type: Plain text
#: build/C/man2/inotify_init.2:32
msgid "inotify_init, inotify_init1 - initialize an inotify instance"
msgstr "inotify_init, inotify_init1 - inotify インスタンスを初期化する"

#. type: Plain text
#: build/C/man2/inotify_init.2:35
#, no-wrap
msgid "B<#include E<lt>sys/inotify.hE<gt>>\n"
msgstr "B<#include E<lt>sys/inotify.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/inotify_init.2:38
#, no-wrap
msgid ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"
msgstr ""
"B<int inotify_init(void);>\n"
"B<int inotify_init1(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/inotify_init.2:42
msgid "For an overview of the inotify API, see B<inotify>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/inotify_init.2:46
msgid ""
"B<inotify_init>()  initializes a new inotify instance and returns a file "
"descriptor associated with a new inotify event queue."
msgstr ""
"B<inotify_init>()  は、新規の inotify インスタンスを初期化し、作成された "
"inotify イベントキュー に対応するファイルディスクリプタを返す。"

#. type: Plain text
#: build/C/man2/inotify_init.2:56
msgid ""
"If I<flags> is 0, then B<inotify_init1>()  is the same as B<inotify_init>"
"().  The following values can be bitwise ORed in I<flags> to obtain "
"different behavior:"
msgstr ""
"B<inotify_init1>()  は、 I<flags> が 0 の場合、 B<inotify_init>()  と同じであ"
"る。 I<flags> に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作"
"をさせることができる。"

#. type: TP
#: build/C/man2/inotify_init.2:56
#, no-wrap
msgid "B<IN_NONBLOCK>"
msgstr "B<IN_NONBLOCK>"

#. type: Plain text
#: build/C/man2/inotify_init.2:64
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成されるオープンファイル記述 (open file description) の BR "
"O_NONBLOCK ファイルステータスフラグをセットする。 このフラグを使うことで、 "
"B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなくな"
"る。"

#. type: TP
#: build/C/man2/inotify_init.2:64
#, no-wrap
msgid "B<IN_CLOEXEC>"
msgstr "B<IN_CLOEXEC>"

#. type: Plain text
#: build/C/man2/inotify_init.2:74
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイル・ディスクリプターに対して close-on-exec (B<FD_CLOEXEC>)  フラ"
"グをセットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: Plain text
#: build/C/man2/inotify_init.2:79
msgid ""
"On success, these system calls return a new file descriptor.  On error, -1 "
"is returned, and I<errno> is set to indicate the error."
msgstr ""
"成功すると、これらのシステムコールは新しいファイルディスクリプタを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/inotify_init.2:85
msgid "(B<inotify_init1>())  An invalid value was specified in I<flags>."
msgstr "(B<inotify_init1>())  無効な値が I<flags> に指定された。"

#. type: TP
#: build/C/man2/inotify_init.2:85
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/inotify_init.2:88
msgid ""
"The user limit on the total number of inotify instances has been reached."
msgstr "inotify インスタンスの総数がユーザ単位の上限に達していた。"

#. type: TP
#: build/C/man2/inotify_init.2:88
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/inotify_init.2:91
msgid ""
"The system limit on the total number of file descriptors has been reached."
msgstr "inotify インスタンスの総数がシステムの上限に達していた。"

#. type: Plain text
#: build/C/man2/inotify_init.2:94
msgid "Insufficient kernel memory is available."
msgstr "カーネルメモリが十分になかった。"

#. type: Plain text
#: build/C/man2/inotify_init.2:101
msgid ""
"B<inotify_init>()  first appeared in Linux 2.6.13; library support was added "
"to glibc in version 2.4.  B<inotify_init1>()  was added in Linux 2.6.27; "
"library support was added to glibc in version 2.9."
msgstr ""
"B<inotify_init>()  は Linux 2.6.13 で初めて登場し、\n"
"ライブラリによるサポートは glibc バージョン 2.4 で追加された。\n"
"B<inotify_init1>()  は Linux 2.6.27 で追加され、\n"
"ライブラリによるサポートは glibc バージョン 2.9 で追加された。"

#. type: Plain text
#: build/C/man2/inotify_init.2:103
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/inotify_init.2:107
msgid "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"
msgstr "B<inotify_add_watch>(2), B<inotify_rm_watch>(2), B<inotify>(7)"

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "INOTIFY_RM_WATCH"
msgstr "INOTIFY_RM_WATCH"

#. type: TH
#: build/C/man2/inotify_rm_watch.2:27
#, no-wrap
msgid "2010-10-15"
msgstr "2010-10-15"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:30
msgid "inotify_rm_watch - remove an existing watch from an inotify instance"
msgstr ""
"inotify_rm_watch - inotify インスタンスから既存の監視アイテムを削除する"

#.  Before glibc 2.10, the second argument was types as uint32_t.
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=7040
#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:36
msgid "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"
msgstr "B<int inotify_rm_watch(int >I<fd>B<, int >I<wd>B<);>"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:42
msgid ""
"B<inotify_rm_watch>()  removes the watch associated with the watch "
"descriptor I<wd> from the inotify instance associated with the file "
"descriptor I<fd>."
msgstr ""
"B<inotify_rm_watch>()  は、監視対象ディスクリプタ (watch descriptor)  I<wd> "
"に対応する監視アイテムを、 ファイルディスクリプタ I<fd> に対応する inotify イ"
"ンスタンスから削除する。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:48
msgid ""
"Removing a watch causes an B<IN_IGNORED> event to be generated for this "
"watch descriptor.  (See B<inotify>(7).)"
msgstr ""
"監視対象を削除すると、 この監視対象ディスクリプタに対して B<IN_IGNORED> イベ"
"ントが生成される (B<inotify>(7)  参照)。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:55
#, fuzzy
#| msgid ""
#| "On success, these system calls return a new file descriptor.  On error, "
#| "-1 is returned, and I<errno> is set to indicate the error."
msgid ""
"On success, B<inotify_rm_watch>()  returns zero.  On error, -1 is returned "
"and I<errno> is set to indicate the cause of the error."
msgstr ""
"成功すると、これらのシステムコールは新しいファイルディスクリプタを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> をエラーを示す値に設定する。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:60
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプタではない。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:67
msgid ""
"The watch descriptor I<wd> is not valid; or I<fd> is not an inotify file "
"descriptor."
msgstr ""
"監視対象ディスクリプタ I<wd> が有効でない。もしくは、 I<fd> が inotify ファイ"
"ルディスクリプタではない。"

#. type: Plain text
#: build/C/man2/inotify_rm_watch.2:75
msgid "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"
msgstr "B<inotify_add_watch>(2), B<inotify_init>(2), B<inotify>(7)"

#~ msgid "2013-09-16"
#~ msgstr "2013-09-16"

#~ msgid ""
#~ "The following system calls are used with this API: B<inotify_init>(2)  "
#~ "(or B<inotify_init1>(2)), B<inotify_add_watch>(2), B<inotify_rm_watch>"
#~ "(2), B<read>(2), and B<close>(2)."
#~ msgstr ""
#~ "以下のシステムコールがこの API と共に使用される: B<inotify_init>(2)  (や "
#~ "B<inotify_init1>(2)), B<inotify_add_watch>(2), B<inotify_rm_watch>(2), "
#~ "B<read>(2), B<close>(2)."

#~ msgid "File/directory created in watched directory (*)."
#~ msgstr "監視対象ディレクトリ内でファイルやディレクトリが作成された。(*)"

#~ msgid "Watched file/directory was itself deleted."
#~ msgstr "監視対象のディレクトリまたはファイル自身が削除された。"

#~ msgid "File was modified (*)."
#~ msgstr "ファイルが修正された。(*)"

#~ msgid ""
#~ "Two additional convenience macros are B<IN_MOVE>, which equates to "
#~ "IN_MOVED_FROM|IN_MOVED_TO, and B<IN_CLOSE>, which equates to "
#~ "IN_CLOSE_WRITE|IN_CLOSE_NOWRITE."
#~ msgstr ""
#~ "さらに 2 つの便利なマクロがある。\n"
#~ "B<IN_MOVE> は IN_MOVED_FROM|IN_MOVED_TO と同じで、\n"
#~ "B<IN_CLOSE> は IN_CLOSE_WRITE|IN_CLOSE_NOWRITE と同じである。"

#~ msgid "Filesystem containing watched object was unmounted."
#~ msgstr "監視対象オブジェクトを含むファイルシステムがアンマウントされた。"

#~ msgid ""
#~ "Note that the event queue can overflow.  In this case, events are lost.  "
#~ "Robust applications should handle the possibility of lost events "
#~ "gracefully."
#~ msgstr ""
#~ "イベントキューは溢れる場合があることに注意すること。この場合にはイベント"
#~ "は\n"
#~ "失われてしまう。堅牢性が必要なアプリケーションでは、イベントが失われる可能"
#~ "性\n"
#~ "を適切に扱う必要がある。"

#~ msgid "2010-10-20"
#~ msgstr "2010-10-20"

#~ msgid "2012-05-04"
#~ msgstr "2012-05-04"

#~ msgid ""
#~ "On success, B<inotify_rm_watch>()  returns zero, or -1 if an error "
#~ "occurred (in which case, I<errno> is set appropriately)."
#~ msgstr ""
#~ "成功すると、 B<inotify_rm_watch>()  は 0 を返す。 エラーの場合、-1 を返"
#~ "し、 I<errno> を適切に設定する。"

#~ msgid "File moved out of watched directory (*)."
#~ msgstr "ファイルが監視対象ディレクトリ外へ移動された。(*)"

#~ msgid "File moved into watched directory (*)."
#~ msgstr "ファイルが監視対象ディレクトリ内へ移動された。(*)"

#~ msgid ""
#~ "The inotify API provides no information about the user or process that "
#~ "triggered the inotify event."
#~ msgstr ""
#~ "inotify API では inotify イベントのきっかけとなったユーザやプロセスに関す"
#~ "る\n"
#~ "情報が提供されない。"

#~ msgid "2008-10-10"
#~ msgstr "2008-10-10"

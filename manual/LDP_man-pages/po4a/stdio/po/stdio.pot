# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-04-25 05:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/asprintf.3:25
#, no-wrap
msgid "ASPRINTF"
msgstr ""

#. type: TH
#: build/C/man3/asprintf.3:25
#, no-wrap
msgid "2001-12-18"
msgstr ""

#. type: TH
#: build/C/man3/asprintf.3:25 build/C/man3/ctermid.3:24 build/C/man3/dprintf.3:25 build/C/man3/fclose.3:42 build/C/man3/fcloseall.3:24 build/C/man3/fflush.3:43 build/C/man3/fgetwc.3:16 build/C/man3/fmemopen.3:6 build/C/man3/fopen.3:42 build/C/man3/fputwc.3:14 build/C/man3/fread.3:43 build/C/man3/fseek.3:40 build/C/man3/getline.3:24 build/C/man3/gets.3:25 build/C/man3/getw.3:23 build/C/man3/popen.3:38 build/C/man3/printf.3:34 build/C/man3/puts.3:24 build/C/man3/remove.3:31 build/C/man3/scanf.3:50 build/C/man3/wprintf.3:14
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/asprintf.3:25 build/C/man3/ctermid.3:24 build/C/man3/dprintf.3:25 build/C/man3/fclose.3:42 build/C/man3/fcloseall.3:24 build/C/man3/ferror.3:42 build/C/man3/fflush.3:43 build/C/man3/fgetwc.3:16 build/C/man3/flockfile.3:23 build/C/man3/fmemopen.3:6 build/C/man3/fmtmsg.3:9 build/C/man3/fopen.3:42 build/C/man3/fopencookie.3:24 build/C/man3/fpurge.3:23 build/C/man3/fputwc.3:14 build/C/man3/fread.3:43 build/C/man3/fseek.3:40 build/C/man3/fseeko.3:23 build/C/man3/getline.3:24 build/C/man3/gets.3:25 build/C/man3/getw.3:23 build/C/man2/link.2:31 build/C/man2/llseek.2:26 build/C/man2/lseek.2:45 build/C/man3/lseek64.3:23 build/C/man2/open.2:52 build/C/man3/perror.3:30 build/C/man2/pipe.2:36 build/C/man3/popen.3:38 build/C/man3/printf.3:34 build/C/man3/puts.3:24 build/C/man2/read.2:35 build/C/man2/readlink.2:41 build/C/man2/readv.2:30 build/C/man3/remove.3:31 build/C/man2/rename.2:32 build/C/man2/rmdir.2:30 build/C/man3/scanf.3:50 build/C/man3/setbuf.3:46 build/C/man3/stdin.3:9 build/C/man3/stdio.3:37 build/C/man3/stdio_ext.3:23 build/C/man2/symlink.2:32 build/C/man7/symlink.7:35 build/C/man3/tempnam.3:23 build/C/man3/tmpfile.3:29 build/C/man3/tmpnam.3:25 build/C/man2/unlink.2:32 build/C/man3/unlocked_stdio.3:23 build/C/man3/wprintf.3:14 build/C/man2/write.2:39
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:26 build/C/man3/ctermid.3:25 build/C/man3/dprintf.3:26 build/C/man3/fclose.3:43 build/C/man3/fcloseall.3:25 build/C/man3/ferror.3:43 build/C/man3/fflush.3:44 build/C/man3/fgetwc.3:17 build/C/man3/flockfile.3:24 build/C/man3/fmemopen.3:7 build/C/man3/fmtmsg.3:10 build/C/man3/fopen.3:43 build/C/man3/fopencookie.3:25 build/C/man3/fpurge.3:24 build/C/man3/fputwc.3:15 build/C/man3/fread.3:44 build/C/man3/fseek.3:41 build/C/man3/fseeko.3:24 build/C/man3/getline.3:25 build/C/man3/gets.3:26 build/C/man3/getw.3:24 build/C/man2/link.2:32 build/C/man2/llseek.2:27 build/C/man2/lseek.2:46 build/C/man3/lseek64.3:24 build/C/man2/open.2:53 build/C/man3/perror.3:31 build/C/man2/pipe.2:37 build/C/man3/popen.3:39 build/C/man3/printf.3:35 build/C/man3/puts.3:25 build/C/man2/read.2:36 build/C/man2/readlink.2:42 build/C/man2/readv.2:31 build/C/man3/remove.3:32 build/C/man2/rename.2:33 build/C/man2/rmdir.2:31 build/C/man3/scanf.3:51 build/C/man3/setbuf.3:47 build/C/man3/stdin.3:10 build/C/man3/stdio.3:38 build/C/man3/stdio_ext.3:24 build/C/man2/symlink.2:33 build/C/man7/symlink.7:36 build/C/man3/tempnam.3:24 build/C/man3/tmpfile.3:30 build/C/man3/tmpnam.3:26 build/C/man2/unlink.2:33 build/C/man3/unlocked_stdio.3:24 build/C/man3/wprintf.3:15 build/C/man2/write.2:40
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:28
msgid "asprintf, vasprintf - print to allocated string"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:28 build/C/man3/ctermid.3:27 build/C/man3/dprintf.3:28 build/C/man3/fclose.3:45 build/C/man3/fcloseall.3:27 build/C/man3/ferror.3:45 build/C/man3/fflush.3:46 build/C/man3/fgetwc.3:19 build/C/man3/flockfile.3:26 build/C/man3/fmemopen.3:9 build/C/man3/fmtmsg.3:12 build/C/man3/fopen.3:45 build/C/man3/fopencookie.3:27 build/C/man3/fpurge.3:26 build/C/man3/fputwc.3:17 build/C/man3/fread.3:46 build/C/man3/fseek.3:43 build/C/man3/fseeko.3:26 build/C/man3/getline.3:27 build/C/man3/gets.3:28 build/C/man3/getw.3:26 build/C/man2/link.2:34 build/C/man2/llseek.2:29 build/C/man2/lseek.2:48 build/C/man3/lseek64.3:26 build/C/man2/open.2:55 build/C/man3/perror.3:33 build/C/man2/pipe.2:39 build/C/man3/popen.3:41 build/C/man3/printf.3:38 build/C/man3/puts.3:27 build/C/man2/read.2:38 build/C/man2/readlink.2:44 build/C/man2/readv.2:33 build/C/man3/remove.3:34 build/C/man2/rename.2:35 build/C/man2/rmdir.2:33 build/C/man3/scanf.3:53 build/C/man3/setbuf.3:49 build/C/man3/stdin.3:12 build/C/man3/stdio.3:40 build/C/man3/stdio_ext.3:28 build/C/man2/symlink.2:35 build/C/man3/tempnam.3:26 build/C/man3/tmpfile.3:32 build/C/man3/tmpnam.3:28 build/C/man2/unlink.2:35 build/C/man3/unlocked_stdio.3:27 build/C/man3/wprintf.3:18 build/C/man2/write.2:42
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:30
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:32 build/C/man3/dprintf.3:30 build/C/man3/fclose.3:47 build/C/man3/ferror.3:47 build/C/man3/fflush.3:48 build/C/man3/fseek.3:45 build/C/man3/perror.3:35 build/C/man3/printf.3:40 build/C/man3/remove.3:36 build/C/man2/rename.2:37 build/C/man3/stdio.3:42 build/C/man3/stdio_ext.3:30
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:34
msgid "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:36
msgid ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list "
">I<ap>B<);>"
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:36 build/C/man3/ctermid.3:44 build/C/man3/dprintf.3:54 build/C/man3/fclose.3:49 build/C/man3/fcloseall.3:34 build/C/man3/ferror.3:63 build/C/man3/fflush.3:50 build/C/man3/fgetwc.3:28 build/C/man3/flockfile.3:49 build/C/man3/fmemopen.3:42 build/C/man3/fmtmsg.3:22 build/C/man3/fopen.3:63 build/C/man3/fopencookie.3:35 build/C/man3/fpurge.3:40 build/C/man3/fputwc.3:26 build/C/man3/fread.3:56 build/C/man3/fseek.3:55 build/C/man3/fseeko.3:35 build/C/man3/getline.3:56 build/C/man3/gets.3:44 build/C/man3/getw.3:57 build/C/man2/link.2:38 build/C/man2/llseek.2:38 build/C/man2/lseek.2:54 build/C/man3/lseek64.3:34 build/C/man2/open.2:66 build/C/man3/perror.3:54 build/C/man2/pipe.2:51 build/C/man3/popen.3:62 build/C/man3/printf.3:76 build/C/man3/puts.3:41 build/C/man2/read.2:44 build/C/man2/readlink.2:61 build/C/man2/readv.2:56 build/C/man3/remove.3:38 build/C/man2/rename.2:39 build/C/man2/rmdir.2:37 build/C/man3/scanf.3:85 build/C/man3/setbuf.3:71 build/C/man3/stdin.3:20 build/C/man3/stdio.3:48 build/C/man3/stdio_ext.3:52 build/C/man2/symlink.2:52 build/C/man3/tempnam.3:40 build/C/man3/tmpfile.3:38 build/C/man3/tmpnam.3:34 build/C/man2/unlink.2:39 build/C/man3/unlocked_stdio.3:104 build/C/man3/wprintf.3:58 build/C/man2/write.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:51
msgid ""
"The functions B<asprintf>()  and B<vasprintf>()  are analogs of "
"B<sprintf>(3)  and B<vsprintf>(3), except that they allocate a string large "
"enough to hold the output including the terminating null byte, and return a "
"pointer to it via the first argument.  This pointer should be passed to "
"B<free>(3)  to release the allocated storage when it is no longer needed."
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:51 build/C/man3/ctermid.3:57 build/C/man3/fclose.3:57 build/C/man3/fcloseall.3:49 build/C/man3/fflush.3:72 build/C/man3/fgetwc.3:53 build/C/man3/flockfile.3:112 build/C/man3/fmemopen.3:172 build/C/man3/fmtmsg.3:148 build/C/man3/fopen.3:189 build/C/man3/fopencookie.3:235 build/C/man3/fpurge.3:56 build/C/man3/fputwc.3:52 build/C/man3/fread.3:81 build/C/man3/fseek.3:117 build/C/man3/fseeko.3:63 build/C/man3/getline.3:108 build/C/man3/gets.3:109 build/C/man3/getw.3:71 build/C/man2/link.2:52 build/C/man2/llseek.2:57 build/C/man2/lseek.2:151 build/C/man2/open.2:464 build/C/man2/pipe.2:92 build/C/man3/popen.3:121 build/C/man3/puts.3:82 build/C/man2/read.2:63 build/C/man2/readlink.2:75 build/C/man2/readv.2:175 build/C/man3/remove.3:60 build/C/man2/rename.2:91 build/C/man2/rmdir.2:40 build/C/man3/scanf.3:528 build/C/man3/setbuf.3:150 build/C/man2/symlink.2:84 build/C/man3/tempnam.3:85 build/C/man3/tmpfile.3:45 build/C/man3/tmpnam.3:68 build/C/man2/unlink.2:55 build/C/man3/wprintf.3:185 build/C/man2/write.2:89
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:59
msgid ""
"When successful, these functions return the number of bytes printed, just "
"like B<sprintf>(3).  If memory allocation wasn't possible, or some other "
"error occurs, these functions will return -1, and the contents of I<strp> is "
"undefined."
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:59 build/C/man3/ctermid.3:59 build/C/man3/dprintf.3:68 build/C/man3/fclose.3:88 build/C/man3/fcloseall.3:54 build/C/man3/ferror.3:105 build/C/man3/fflush.3:91 build/C/man3/fgetwc.3:65 build/C/man3/flockfile.3:119 build/C/man3/fmemopen.3:191 build/C/man3/fmtmsg.3:221 build/C/man3/fopen.3:246 build/C/man3/fopencookie.3:242 build/C/man3/fpurge.3:68 build/C/man3/fputwc.3:63 build/C/man3/fread.3:101 build/C/man3/fseek.3:164 build/C/man3/fseeko.3:75 build/C/man3/getline.3:132 build/C/man3/gets.3:136 build/C/man3/getw.3:78 build/C/man2/link.2:128 build/C/man2/llseek.2:76 build/C/man2/lseek.2:189 build/C/man2/open.2:610 build/C/man3/perror.3:111 build/C/man2/pipe.2:118 build/C/man3/popen.3:167 build/C/man3/printf.3:807 build/C/man3/puts.3:101 build/C/man2/read.2:155 build/C/man2/readlink.2:123 build/C/man2/readv.2:212 build/C/man3/remove.3:70 build/C/man2/rename.2:229 build/C/man2/rmdir.2:127 build/C/man3/scanf.3:575 build/C/man3/setbuf.3:162 build/C/man3/stdin.3:109 build/C/man3/stdio.3:244 build/C/man2/symlink.2:144 build/C/man3/tempnam.3:94 build/C/man3/tmpfile.3:74 build/C/man3/tmpnam.3:75 build/C/man2/unlink.2:141 build/C/man3/unlocked_stdio.3:111 build/C/man3/wprintf.3:193 build/C/man2/write.2:179
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:65
msgid ""
"These functions are GNU extensions, not in C or POSIX.  They are also "
"available under *BSD.  The FreeBSD implementation sets I<strp> to NULL on "
"error."
msgstr ""

#. type: SH
#: build/C/man3/asprintf.3:65 build/C/man3/ctermid.3:69 build/C/man3/dprintf.3:94 build/C/man3/fclose.3:100 build/C/man3/fcloseall.3:56 build/C/man3/ferror.3:112 build/C/man3/fflush.3:106 build/C/man3/fgetwc.3:82 build/C/man3/flockfile.3:127 build/C/man3/fmemopen.3:273 build/C/man3/fmtmsg.3:293 build/C/man3/fopen.3:302 build/C/man3/fopencookie.3:434 build/C/man3/fpurge.3:78 build/C/man3/fputwc.3:80 build/C/man3/fread.3:103 build/C/man3/fseek.3:166 build/C/man3/fseeko.3:81 build/C/man3/getline.3:166 build/C/man3/gets.3:171 build/C/man3/getw.3:84 build/C/man2/link.2:177 build/C/man2/llseek.2:82 build/C/man2/lseek.2:234 build/C/man3/lseek64.3:157 build/C/man2/open.2:849 build/C/man3/perror.3:139 build/C/man2/pipe.2:190 build/C/man3/popen.3:196 build/C/man3/printf.3:1074 build/C/man3/puts.3:110 build/C/man2/read.2:178 build/C/man2/readlink.2:212 build/C/man2/readv.2:282 build/C/man3/remove.3:81 build/C/man2/rename.2:242 build/C/man2/rmdir.2:132 build/C/man3/scanf.3:717 build/C/man3/setbuf.3:198 build/C/man3/stdin.3:150 build/C/man3/stdio.3:248 build/C/man3/stdio_ext.3:130 build/C/man2/symlink.2:159 build/C/man7/symlink.7:470 build/C/man3/tempnam.3:164 build/C/man3/tmpfile.3:86 build/C/man3/tmpnam.3:151 build/C/man2/unlink.2:148 build/C/man3/unlocked_stdio.3:134 build/C/man3/wprintf.3:229 build/C/man2/write.2:205
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/asprintf.3:68
msgid "B<free>(3), B<malloc>(3), B<printf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ctermid.3:24
#, no-wrap
msgid "CTERMID"
msgstr ""

#. type: TH
#: build/C/man3/ctermid.3:24
#, no-wrap
msgid "2007-07-26"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:27
msgid "ctermid - get controlling terminal name"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:32 build/C/man3/fgetwc.3:22 build/C/man3/flockfile.3:29 build/C/man3/fmemopen.3:12 build/C/man3/fopen.3:48 build/C/man3/fputwc.3:20 build/C/man3/fread.3:49 build/C/man3/fseeko.3:29 build/C/man3/getline.3:30 build/C/man3/gets.3:31 build/C/man3/getw.3:29 build/C/man3/popen.3:44 build/C/man3/puts.3:30 build/C/man3/scanf.3:56 build/C/man3/setbuf.3:52 build/C/man3/stdin.3:15 build/C/man3/tempnam.3:29 build/C/man3/tmpfile.3:35 build/C/man3/tmpnam.3:31 build/C/man3/unlocked_stdio.3:30
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:34
#, no-wrap
msgid "B<char *ctermid(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:39 build/C/man3/dprintf.3:38 build/C/man3/ferror.3:59 build/C/man3/flockfile.3:40 build/C/man3/fmemopen.3:25 build/C/man3/fopen.3:59 build/C/man3/getline.3:40 build/C/man3/getw.3:38 build/C/man3/perror.3:49 build/C/man3/popen.3:53 build/C/man3/printf.3:63 build/C/man2/readlink.2:52 build/C/man2/readv.2:51 build/C/man3/scanf.3:71 build/C/man3/setbuf.3:66 build/C/man2/symlink.2:43 build/C/man3/tempnam.3:36 build/C/man3/unlocked_stdio.3:66 build/C/man3/wprintf.3:37
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#.  From <unistd.h>: _XOPEN_SOURCE
#. type: Plain text
#: build/C/man3/ctermid.3:44
msgid "B<ctermid>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:57
msgid ""
"B<ctermid>()  returns a string which is the pathname for the current "
"controlling terminal for this process.  If I<s> is NULL, a static buffer is "
"used, otherwise I<s> points to a buffer used to hold the terminal pathname.  "
"The symbolic constant B<L_ctermid> is the maximum number of characters in "
"the returned pathname."
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:59
msgid "The pointer to the pathname."
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:61
msgid "Svr4, POSIX.1-2001."
msgstr ""

#. type: SH
#: build/C/man3/ctermid.3:61 build/C/man3/fmemopen.3:201 build/C/man3/gets.3:150 build/C/man3/getw.3:80 build/C/man2/link.2:171 build/C/man2/open.2:838 build/C/man3/popen.3:173 build/C/man3/printf.3:930 build/C/man3/puts.3:103 build/C/man2/readv.2:256 build/C/man3/remove.3:78 build/C/man2/rename.2:231 build/C/man2/rmdir.2:129 build/C/man3/scanf.3:682 build/C/man3/setbuf.3:168 build/C/man3/tempnam.3:154 build/C/man3/tmpnam.3:144 build/C/man2/unlink.2:145
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:65
msgid ""
"The path returned may not uniquely identify the controlling terminal; it "
"may, for example, be I</dev/tty>."
msgstr ""

#.  in glibc 2.3.x, x >= 4, the glibc headers threw an error
#.  if ctermid() was given an argument; fixed in 2.4.
#. type: Plain text
#: build/C/man3/ctermid.3:69
msgid "It is not assured that the program can open the terminal."
msgstr ""

#. type: Plain text
#: build/C/man3/ctermid.3:70
msgid "B<ttyname>(3)"
msgstr ""

#. type: TH
#: build/C/man3/dprintf.3:25
#, no-wrap
msgid "DPRINTF"
msgstr ""

#. type: TH
#: build/C/man3/dprintf.3:25 build/C/man3/fmemopen.3:6
#, no-wrap
msgid "2010-09-15"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:28
msgid "dprintf, vdprintf - print to a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:32
msgid "B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:34
msgid "B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:42
msgid "B<dprintf>(), B<vdprintf>():"
msgstr ""

#. type: TP
#: build/C/man3/dprintf.3:45 build/C/man3/fmemopen.3:33 build/C/man3/getline.3:47
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:48 build/C/man3/fmemopen.3:36
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: build/C/man3/dprintf.3:48 build/C/man3/fmemopen.3:36 build/C/man3/getline.3:50
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:51 build/C/man3/fmemopen.3:39 build/C/man3/getline.3:53 build/C/man3/unlocked_stdio.3:102
msgid "_GNU_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:68
msgid ""
"The functions B<dprintf>()  and B<vdprintf>()  (as found in the glibc2 "
"library) are exact analogs of B<fprintf>(3)  and B<vfprintf>(3), except that "
"they output to a file descriptor I<fd> instead of to a I<stdio> stream."
msgstr ""

#.  .SH NOTES
#.  These functions are GNU extensions, not in C or POSIX.
#.  Clearly, the names were badly chosen.
#.  Many systems (like MacOS) have incompatible functions called
#.  .BR dprintf (),
#.  usually some debugging version of
#.  .BR printf (3),
#.  perhaps with a prototype like
#
#.  .BI "void dprintf(int level, const char *" format ", ...);"
#
#.  where the first argument is a debugging level (and output is to
#.  .IR stderr ).
#.  Moreover,
#.  .BR dprintf ()
#.  (or
#.  .BR DPRINTF )
#.  is also a popular macro name for a debugging printf.
#.  So, probably, it is better to avoid this function in programs
#.  intended to be portable.
#
#.  A better name would have been
#.  .BR fdprintf ().
#. type: Plain text
#: build/C/man3/dprintf.3:94
msgid ""
"These functions are GNU extensions that are nowadays specified in "
"POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/dprintf.3:95
msgid "B<printf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fclose.3:42
#, no-wrap
msgid "FCLOSE"
msgstr ""

#. type: TH
#: build/C/man3/fclose.3:42 build/C/man3/fopen.3:42 build/C/man2/read.2:35
#, no-wrap
msgid "2009-02-23"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:45
msgid "fclose - close a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:49
msgid "B<int fclose(FILE *>I<fp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:57
msgid ""
"The B<fclose>()  function will flushes the stream pointed to by I<fp> "
"(writing any buffered output data using B<fflush>(3))  and closes the "
"underlying file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:68
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error.  In either case any further access "
"(including another call to B<fclose>())  to the stream results in undefined "
"behavior."
msgstr ""

#. type: SH
#: build/C/man3/fclose.3:68 build/C/man3/ferror.3:95 build/C/man3/fflush.3:79 build/C/man3/fgetwc.3:59 build/C/man3/flockfile.3:117 build/C/man3/fopen.3:201 build/C/man3/fpurge.3:63 build/C/man3/fputwc.3:58 build/C/man3/fseek.3:132 build/C/man3/fseeko.3:72 build/C/man3/getline.3:120 build/C/man2/link.2:57 build/C/man2/llseek.2:64 build/C/man2/lseek.2:159 build/C/man2/open.2:472 build/C/man2/pipe.2:97 build/C/man3/popen.3:141 build/C/man2/read.2:77 build/C/man2/readlink.2:83 build/C/man2/readv.2:186 build/C/man3/remove.3:65 build/C/man2/rename.2:96 build/C/man2/rmdir.2:45 build/C/man3/scanf.3:545 build/C/man2/symlink.2:89 build/C/man3/tempnam.3:90 build/C/man3/tmpfile.3:52 build/C/man3/tmpnam.3:73 build/C/man2/unlink.2:60 build/C/man2/write.2:107
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man3/fclose.3:69 build/C/man3/fflush.3:80 build/C/man3/fpurge.3:64 build/C/man3/fseek.3:133 build/C/man2/llseek.2:65 build/C/man2/lseek.2:160 build/C/man2/read.2:96 build/C/man3/scanf.3:551 build/C/man2/write.2:126
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(fp)).
#. type: Plain text
#: build/C/man3/fclose.3:78
msgid "The file descriptor underlying I<fp> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:88
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2)  or B<fflush>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:90 build/C/man3/fseek.3:166 build/C/man3/puts.3:103
msgid "C89, C99."
msgstr ""

#. type: SH
#: build/C/man3/fclose.3:90 build/C/man3/fflush.3:97 build/C/man3/fgetwc.3:67 build/C/man3/fmemopen.3:195 build/C/man3/fmtmsg.3:236 build/C/man3/fopen.3:255 build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:65 build/C/man3/fseeko.3:77 build/C/man2/link.2:133 build/C/man2/llseek.2:79 build/C/man2/lseek.2:199 build/C/man2/open.2:636 build/C/man3/perror.3:124 build/C/man3/printf.3:868 build/C/man2/read.2:157 build/C/man2/readlink.2:128 build/C/man2/readv.2:224 build/C/man3/remove.3:72 build/C/man3/scanf.3:606 build/C/man3/stdin.3:118 build/C/man2/symlink.2:150 build/C/man3/tempnam.3:99 build/C/man3/tmpfile.3:76 build/C/man3/tmpnam.3:80 build/C/man3/wprintf.3:195 build/C/man2/write.2:188
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:100
msgid ""
"Note that B<fclose>()  only flushes the user space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fclose.3:105
msgid "B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fcloseall.3:24
#, no-wrap
msgid "FCLOSEALL"
msgstr ""

#. type: TH
#: build/C/man3/fcloseall.3:24
#, no-wrap
msgid "2006-12-27"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:27
msgid "fcloseall - close all open streams"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:31 build/C/man3/fopencookie.3:31
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:33
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:42
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as "
"for B<fflush>(3)); buffered input is discarded."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:49
msgid "The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:54
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:56
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/fcloseall.3:61
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ferror.3:42
#, no-wrap
msgid "FERROR"
msgstr ""

#. type: TH
#: build/C/man3/ferror.3:42 build/C/man3/flockfile.3:23 build/C/man3/unlocked_stdio.3:23
#, no-wrap
msgid "2008-08-29"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:45
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:49
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:51
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:53
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:55
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:63
msgid "B<fileno>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:68
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:77
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can only be cleared by the function B<clearerr>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:86
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can "
"only be reset by the B<clearerr>()  function."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:92
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns its "
"integer descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:95 build/C/man3/fgetwc.3:53 build/C/man3/fputwc.3:52 build/C/man3/fread.3:81 build/C/man3/gets.3:109 build/C/man3/puts.3:82
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:105
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a "
"valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:112
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89 and "
"C99."
msgstr ""

#. type: Plain text
#: build/C/man3/ferror.3:116
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fflush.3:43
#, no-wrap
msgid "FFLUSH"
msgstr ""

#. type: TH
#: build/C/man3/fflush.3:43
#, no-wrap
msgid "2009-09-06"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:46
msgid "fflush - flush a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:50
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:61
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function.  For input streams, B<fflush>()  discards any buffered data "
"that has been fetched from the underlying file, but has not been consumed by "
"the application.  The open status of the stream is unaffected."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:69
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:72
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:79
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:84
msgid "I<Stream> is not an open stream, or is not open for writing."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:91
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:93
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr ""

#.  Verified on: Solaris 8.
#. type: Plain text
#: build/C/man3/fflush.3:97
msgid ""
"The standards do not specify the behavior for input streams.  Most other "
"implementations behave the same as Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:106
msgid ""
"Note that B<fflush>()  only flushes the user space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fflush.3:113
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fopen>(3), "
"B<setbuf>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fgetwc.3:16
#, no-wrap
msgid "FGETWC"
msgstr ""

#. type: TH
#: build/C/man3/fgetwc.3:16 build/C/man3/fputwc.3:14
#, no-wrap
msgid "1999-07-25"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:19
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:24 build/C/man3/fmemopen.3:18 build/C/man3/fputwc.3:22 build/C/man3/unlocked_stdio.3:52
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:27
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:42
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the "
"B<fgetc>(3)  function.  It reads a wide character from I<stream> and returns "
"it.  If the end of stream is reached, or if I<ferror(stream)> becomes true, "
"it returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:50
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:59
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:61 build/C/man3/fputwc.3:60
msgid "Apart from the usual ones, there is"
msgstr ""

#. type: TP
#: build/C/man3/fgetwc.3:61 build/C/man3/fputwc.3:60 build/C/man3/scanf.3:556
#, no-wrap
msgid "B<EILSEQ>"
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:65
msgid "The data obtained from the input stream does not form a valid character."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:67 build/C/man3/fputwc.3:65
msgid "C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:74
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:82
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""

#. type: Plain text
#: build/C/man3/fgetwc.3:86
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/flockfile.3:23
#, no-wrap
msgid "FLOCKFILE"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:26
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:31
#, no-wrap
msgid "B<void flockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:33
#, no-wrap
msgid "B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:35
#, no-wrap
msgid "B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:44 build/C/man3/wprintf.3:41
msgid "All functions shown above:"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:47
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE "
"|| _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:61
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:67
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:75
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the "
"I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:92
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming "
"in between.  If the reason for doing this was to achieve greater efficiency, "
"one does the I/O with the nonlocking versions of the stdio functions: with "
"B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of B<getc>(3)  and "
"B<putc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:99
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked "
"by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:103
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:112
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>().  "
"It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:117
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:119
msgid "None."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:121 build/C/man3/popen.3:169
msgid "POSIX.1-2001."
msgstr ""

#. type: SH
#: build/C/man3/flockfile.3:121
#, no-wrap
msgid "AVAILABILITY"
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:127
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined.  They are in libc since libc 5.1.1 and in glibc since glibc 2.0."
msgstr ""

#. type: Plain text
#: build/C/man3/flockfile.3:128
msgid "B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fmemopen.3:6
#, no-wrap
msgid "FMEMOPEN"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:9
msgid "fmemopen, open_memstream, open_wmemstream - open memory as stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:14
#, no-wrap
msgid ""
"B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char "
"*>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:16
#, no-wrap
msgid "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:20
#, no-wrap
msgid "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:30
msgid "B<fmemopen>(), B<open_memstream>(), B<open_wmemstream>():"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:53
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified "
"by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>.  This buffer must be at least I<size> bytes "
"long."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:73
msgid ""
"The argument I<mode> is the same as for B<fopen>(3).  If I<mode> specifies "
"an append mode, then the initial file position is set to the location of the "
"first null byte (\\(aq\\e0\\(aq) in the buffer; otherwise the initial file "
"position is set to the start of the buffer.  Since glibc 2.9, the letter 'b' "
"may be specified as the second character in I<mode>.  This provides "
"\"binary\" mode: writes don't implicitly add a terminating null byte, and "
"B<fseek>(3)  B<SEEK_END> is relative to the end of the buffer (i.e., the "
"value specified by the I<size> argument), rather than the current string "
"length."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:85
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or "
"closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in "
"the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1995
#.  and
#.  http://sources.redhat.com/ml/libc-alpha/2006-04/msg00064.html
#. type: Plain text
#: build/C/man3/fmemopen.3:103
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error.  "
"(By default, such errors will only be visible when the I<stdio> buffer is "
"flushed.  Disabling buffering with I<setbuf(fp,\\ NULL)> may be useful to "
"detect errors at the time of an output operation.  Alternatively, the caller "
"can explicitly set I<buf> as the stdio stream buffer, at the same time "
"informing stdio of the buffer's size, using I<setbuffer(fp, buf, size)>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:111
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do "
"not cause read operations to return an end-of-file indication.  A read from "
"the buffer will only indicate end-of-file when the file pointer advances "
"I<size> bytes past the start of the buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:126
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  dynamically allocates a "
"buffer I<size> bytes long.  This is useful for an application that wants to "
"write data to a temporary buffer and then read it back again.  The buffer is "
"automatically freed when the stream is closed.  Note that the caller has no "
"way to obtain a pointer to the temporary buffer allocated by this call (but "
"see B<open_memstream>()  below)."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:137
msgid ""
"The B<open_memstream>()  function opens a stream for writing to a buffer.  "
"The buffer is dynamically allocated (as with B<malloc>(3)), and "
"automatically grows as required.  After closing the stream, the caller "
"should B<free>(3)  this buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:152
msgid ""
"When the stream is closed (B<fclose>(3))  or flushed (B<fflush>(3)), the "
"locations pointed to by I<ptr> and I<sizeloc> are updated to contain, "
"respectively, a pointer to the buffer and the current size of the buffer.  "
"These values remain valid only as long as the caller performs no further "
"output on the stream.  If further output is performed, then the stream must "
"again be flushed before trying to access these variables."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:158
msgid ""
"A null byte is maintained at the end of the buffer.  This byte is I<not> "
"included in the size value stored at I<sizeloc>."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:166
msgid ""
"The stream's file position can be changed with B<fseek>(3)  or "
"B<fseeko>(3).  Moving the file position past the end of the data already "
"written fills the intervening space with zeros."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:172
msgid ""
"The B<open_wmemstream>()  is similar to B<open_memstream>(), but operates on "
"wide characters instead of bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:184
msgid ""
"Upon successful completion B<fmemopen>(), B<open_memstream>()  and "
"B<open_wmemstream>()  return a I<FILE> pointer.  Otherwise, NULL is returned "
"and I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man3/fmemopen.3:184 build/C/man3/fmtmsg.3:218 build/C/man3/getline.3:130 build/C/man2/pipe.2:113 build/C/man2/readv.2:207
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:191
msgid ""
"B<fmemopen>()  and B<open_memstream>()  were already available in glibc "
"1.0.x.  B<open_wmemstream>()  is available since glibc 2.4."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:195
msgid ""
"POSIX.1-2008.  These functions are not specified in POSIX.1-2001, and are "
"not widely available on other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:201
msgid ""
"There is no file descriptor associated with the file stream returned by "
"these functions (i.e., B<fileno>(3)  will return an error if called on the "
"returned stream)."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=1996
#. type: Plain text
#: build/C/man3/fmemopen.3:208
msgid ""
"In glibc before version 2.7, seeking past the end of a stream created by "
"B<open_memstream>()  does not enlarge the buffer; instead the B<fseek>(3)  "
"call fails, returning -1."
msgstr ""

#. type: SH
#: build/C/man3/fmemopen.3:208 build/C/man3/fmtmsg.3:240 build/C/man3/fopencookie.3:244 build/C/man3/getline.3:139 build/C/man2/pipe.2:124 build/C/man3/printf.3:974 build/C/man2/readlink.2:155 build/C/man2/readv.2:263
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:218
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>()  to open a dynamically sized output buffer.  The program "
"scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:223
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr ""

#. type: SS
#: build/C/man3/fmemopen.3:225 build/C/man3/fopencookie.3:268
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:232
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:235
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:243
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:248
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:252
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:256
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:261
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:272
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
"    fclose(in);\n"
"    fclose(out);\n"
"    printf(\"size=%ld; ptr=%s\\en\", (long) size, ptr);\n"
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:275
msgid "B<fopen>(3), B<fopencookie>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fmtmsg.3:9
#, no-wrap
msgid "FMTMSG"
msgstr ""

#. type: TH
#: build/C/man3/fmtmsg.3:9
#, no-wrap
msgid "2008-06-14"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:12
msgid "fmtmsg - print formatted error messages"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:15
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:17
#, no-wrap
msgid "B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:19
#, no-wrap
msgid "B<           int >I<severity>B<, const char *>I<text>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:21
#, no-wrap
msgid "B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:32
msgid ""
"This function displays a message described by its arguments on the device(s)  "
"specified in the I<classification> argument.  For messages written to "
"I<stderr>, the format depends on the B<MSGVERB> environment variable."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:39
msgid ""
"The I<label> argument identifies the source of the message.  The string must "
"consist of two colon separated parts where the first part has not more than "
"10 and the second part not more than 14 characters."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:43
msgid "The I<text> argument describes the condition of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:48
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:56
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique "
"identification number."
msgstr ""

#. type: SS
#: build/C/man3/fmtmsg.3:56
#, no-wrap
msgid "Dummy arguments"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:75
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed.  "
"The dummy severity value B<NO_SEV> (0) says that no severity is supplied.  "
"The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char *) 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""

#. type: SS
#: build/C/man3/fmtmsg.3:75
#, no-wrap
msgid "The classification argument"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:79
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:82
msgid "The first value defines the output channel."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:82
#, no-wrap
msgid "B<MM_PRINT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:86
msgid "Output to I<stderr>."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:86
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:89
msgid "Output to the system console."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:89
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:92
msgid "Output to both."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:94
msgid "The second value is the source of the error:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:94
#, no-wrap
msgid "B<MM_HARD>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:97
msgid "A hardware error occurred."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:97
#, no-wrap
msgid "B<MM_FIRM>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:100
msgid "A firmware error occurred."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:100
#, no-wrap
msgid "B<MM_SOFT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:103
msgid "A software error occurred."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:105
msgid "The third value encodes the detector of the problem:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:105
#, no-wrap
msgid "B<MM_APPL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:108
msgid "It is detected by an application."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:108
#, no-wrap
msgid "B<MM_UTIL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:111
msgid "It is detected by a utility."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:111
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:114
msgid "It is detected by the operating system."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:116
msgid "The fourth value shows the severity of the incident:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:116
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:119
msgid "It is a recoverable error."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:119
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:122
msgid "It is a nonrecoverable error."
msgstr ""

#. type: SS
#: build/C/man3/fmtmsg.3:122
#, no-wrap
msgid "The severity argument"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:126
msgid "The I<severity> argument can take one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:126
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:129
msgid "No severity is printed."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:129
#, no-wrap
msgid "B<MM_HALT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:132
msgid "This value is printed as HALT."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:132
#, no-wrap
msgid "B<MM_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:135
msgid "This value is printed as ERROR."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:135
#, no-wrap
msgid "B<MM_WARNING>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:138
msgid "This value is printed as WARNING."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:138
#, no-wrap
msgid "B<MM_INFO>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:141
msgid "This value is printed as INFO."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:148
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:150
msgid "The function can return 4 values:"
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:150
#, no-wrap
msgid "B<MM_OK>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:153
msgid "Everything went smooth."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:153
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:156
msgid "Complete failure."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:156
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:160
msgid "Error writing to I<stderr>."
msgstr ""

#. type: TP
#: build/C/man3/fmtmsg.3:160
#, no-wrap
msgid "B<MM_NOCON>"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:163
msgid "Error writing to the console."
msgstr ""

#. type: SH
#: build/C/man3/fmtmsg.3:163
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:174
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to "
"the console.)  When this variable is defined, is non-NULL, and is a "
"colon-separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:186
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:189
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:194
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:197
msgid "severity-keyword,level,printstring"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:204
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0-4), and use the indicated printstring when "
"such a level occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:218
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the "
"string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:221
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:236
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V.  The function B<fmtmsg>()  "
"and the environment variable B<MSGVERB> are described in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:240
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:245
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:251
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:272
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:275
msgid "The output should be:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:279
#, no-wrap
msgid ""
"    util-linux:mount: ERROR: unknown mount option\n"
"    TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:282
msgid "and after"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:285
#, no-wrap
msgid "    MSGVERB=text:action; export MSGVERB\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:288
msgid "the output becomes:"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:292
#, no-wrap
msgid ""
"    unknown mount option\n"
"    TO FIX: See mount(8).\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fmtmsg.3:295
msgid "B<addseverity>(3), B<perror>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fopen.3:42
#, no-wrap
msgid "FOPEN"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:45
msgid "fopen, fdopen, freopen - stream open functions"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:50
#, no-wrap
msgid "B<FILE *fopen(const char *>I<path>B<, const char *>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:54
#, no-wrap
msgid ""
"B<FILE *freopen(const char *>I<path>B<, const char *>I<mode>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:63
msgid "B<fdopen>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:69
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<path> and associates a stream with it."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:74
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (Additional characters may follow these sequences.):"
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:74
#, no-wrap
msgid "B<r>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:78
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:78
#, no-wrap
msgid "B<r+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:82
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:82
#, no-wrap
msgid "B<w>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:86
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is "
"positioned at the beginning of the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:86
#, no-wrap
msgid "B<w+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:92
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the "
"file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:92 build/C/man3/scanf.3:444
#, no-wrap
msgid "B<a>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:97
msgid ""
"Open for appending (writing at end of file).  The file is created if it does "
"not exist.  The stream is positioned at the end of the file."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:97
#, no-wrap
msgid "B<a+>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:103
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  The initial file position for reading is at "
"the beginning of the file, but output is always appended to the end of the "
"file."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:116
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the "
"two-character strings described above.  This is strictly for compatibility "
"with C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX "
"conforming systems, including Linux.  (Other systems may treat text files "
"and binary files differently, and adding the \\(aqb\\(aq may be a good idea "
"if you do I/O to a binary file and expect that your program may be ported to "
"non-UNIX environments.)"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:119
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:124
msgid ""
"Any created files will have mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:139
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note "
"that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or "
"B<fgetpos>(3)  operation between write and read operations on such a "
"stream.  This operation may be an apparent no-op (as in I<fseek(..., 0L, "
"SEEK_CUR)> called for its synchronizing side effect."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:144
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at "
"end-of-file, as if preceded by an"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:147
#, no-wrap
msgid "    fseek(stream,0,SEEK_END);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:150
msgid "call."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:171
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", "
"\"r+\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of "
"the file descriptor.  The file position indicator of the new stream is set "
"to that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by "
"B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:189
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<path> and associates the stream pointed to by I<stream> with it.  "
"The original stream (if it exists) is closed.  The I<mode> argument is used "
"just as in the B<fopen>()  function.  The primary use of the B<freopen>()  "
"function is to change the file associated with a standard text stream "
"(I<stderr>, I<stdin>, or I<stdout>)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:201
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>()  and B<freopen>()  return "
"a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:202 build/C/man3/fseek.3:138 build/C/man3/getline.3:121 build/C/man2/llseek.2:72 build/C/man2/lseek.2:164 build/C/man2/pipe.2:102 build/C/man2/read.2:108 build/C/man2/read.2:119 build/C/man2/readlink.2:93 build/C/man2/readlink.2:102 build/C/man2/readv.2:198 build/C/man2/rename.2:136 build/C/man2/rmdir.2:67 build/C/man3/scanf.3:563 build/C/man2/write.2:148
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:212
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:222
msgid ""
"The B<fopen>(), B<fdopen>()  and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:229
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:236
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:246
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3)  and "
"B<fflush>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:255
msgid ""
"The B<fopen>()  and B<freopen>()  functions conform to C89.  The B<fdopen>()  "
"function conforms to POSIX.1-1990."
msgstr ""

#. type: SS
#: build/C/man3/fopen.3:256
#, no-wrap
msgid "Glibc Notes"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:259
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:259
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:264
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:264
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:272
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:272
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr ""

#.  As at glibc 2.4:
#. type: Plain text
#: build/C/man3/fopen.3:284
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is only attempted "
"for a file opened for reading."
msgstr ""

#. type: TP
#: build/C/man3/fopen.3:284 build/C/man3/scanf.3:418
#, no-wrap
msgid "B<x>"
msgstr ""

#.  Since glibc 2.0?
#.  FIXME C11 specifies this flag
#.  FIXME document /,ccs= charset/
#. type: Plain text
#: build/C/man3/fopen.3:302
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fopen.3:307
msgid "B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:24
#, no-wrap
msgid "FOPENCOOKIE"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:24
#, no-wrap
msgid "2008-12-05"
msgstr ""

#. type: TH
#: build/C/man3/fopencookie.3:24 build/C/man2/link.2:31 build/C/man2/llseek.2:26 build/C/man2/lseek.2:45 build/C/man3/lseek64.3:23 build/C/man2/open.2:52 build/C/man2/pipe.2:36 build/C/man2/read.2:35 build/C/man2/readlink.2:41 build/C/man2/readv.2:30 build/C/man2/rename.2:32 build/C/man2/rmdir.2:30 build/C/man3/setbuf.3:46 build/C/man3/stdin.3:9 build/C/man2/symlink.2:32 build/C/man7/symlink.7:35 build/C/man2/unlink.2:32 build/C/man2/write.2:39
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:27
msgid "fopencookie - opening a custom stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:34
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:47
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the "
"stream's data at a location of its own choosing; for example, "
"B<fopencookie>()  is used to implement B<fmemopen>(3), which provides a "
"stream interface to data that is stored in a buffer in memory."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:49
msgid "In order to create a custom stream the programmer must:"
msgstr ""

#. type: IP
#: build/C/man3/fopencookie.3:49 build/C/man3/fopencookie.3:52 build/C/man3/fopencookie.3:63 build/C/man3/scanf.3:669 build/C/man3/scanf.3:674 build/C/man3/scanf.3:680 build/C/man7/symlink.7:248 build/C/man7/symlink.7:258 build/C/man7/symlink.7:288 build/C/man7/symlink.7:348 build/C/man7/symlink.7:377 build/C/man7/symlink.7:406 build/C/man7/symlink.7:437 build/C/man7/symlink.7:450
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:52
msgid ""
"Implement four \"hook\" functions that are used internally by the standard "
"I/O library when performing I/O on the stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:63
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to "
"B<fopencookie>()), but automatically supplies the cookie as the first "
"argument when calling the hook functions."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:68
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:76
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to "
"operate on that stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:83
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is "
"to be associated with the new stream.  This pointer is supplied as the first "
"argument when the standard I/O library invokes any of the hook functions "
"described below."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:99
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:105
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:114
#, no-wrap
msgid ""
"struct cookie_io_functions_t {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:118
msgid "The four fields are as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:118
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:122
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:124
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:139
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:144
msgid ""
"If I<*read> is a NULL pointer, then reads from the custom stream always "
"return end of file."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:144
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:148
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:150
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:165
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or -1 on error.  The I<write> function should update the stream offset "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:170
msgid "If I<*write> is a NULL pointer, then output to the stream is discarded."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:170
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:174
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:176
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:182
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:183 build/C/man2/lseek.2:65
#, no-wrap
msgid "B<SEEK_SET>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:188
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:188 build/C/man2/lseek.2:70
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:192
msgid "I<*offset> should be added to the current stream offset."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:192 build/C/man2/lseek.2:75
#, no-wrap
msgid "B<SEEK_END>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:196
msgid "The stream offset should be set to the size of the stream plus I<*offset>."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:203
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:207
msgid ""
"As its function result, the I<seek> function should return 0 on success, and "
"-1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:212
msgid ""
"If I<*seek> is a NULL pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:212
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:218
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:220
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:225
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:231
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:235
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is "
"closed."
msgstr ""

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: build/C/man3/fopencookie.3:242
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error, "
"NULL is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:244
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:253
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:261
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:268
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a "
"cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:277
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:279
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:286
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:292
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:294
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:304
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:306
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:310
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:313
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:319
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:321
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:327
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:329
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:333
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:339
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:348
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:351
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:356
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:361
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:365
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:368
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:384
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *fp;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:386
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:392
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:396
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:402
#, no-wrap
msgid ""
"    fp = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (fp == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:404
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:410
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], fp) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:412
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:427
#, no-wrap
msgid ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(fp, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, fp);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:430
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:433 build/C/man2/readlink.2:211
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:438
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fpurge.3:23
#, no-wrap
msgid "FPURGE"
msgstr ""

#. type: TH
#: build/C/man3/fpurge.3:23
#, no-wrap
msgid "2001-12-15"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:26
msgid "fpurge, __fpurge - purge a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:30
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:32
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:35
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:37
#, no-wrap
msgid "B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:39
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:52
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:56
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a "
"value."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:63
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:68
msgid "I<stream> is not an open stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:76
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()  "
"was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and "
"later."
msgstr ""

#. type: Plain text
#: build/C/man3/fpurge.3:78
msgid "Usually it is a mistake to want to discard input buffers."
msgstr ""

#.  .BR fclean (3),
#. type: Plain text
#: build/C/man3/fpurge.3:82
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fputwc.3:14
#, no-wrap
msgid "FPUTWC"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:17
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:25
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:41
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the "
"B<fputc>(3)  function.  It writes the wide character I<wc> to I<stream>.  If "
"I<ferror(stream)> becomes true, it returns B<WEOF>.  If a wide-character "
"conversion error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>.  "
"Otherwise it returns I<wc>."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:49
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:58
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:63
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:72
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:80
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fputwc>()  will actually write the multibyte "
"sequence corresponding to the wide character I<wc>."
msgstr ""

#. type: Plain text
#: build/C/man3/fputwc.3:83
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fread.3:43
#, no-wrap
msgid "FREAD"
msgstr ""

#. type: TH
#: build/C/man3/fread.3:43
#, no-wrap
msgid "2012-03-30"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:46
msgid "fread, fwrite - binary stream input/output"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:52
#, no-wrap
msgid ""
"B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:55
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t "
">I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:67
msgid ""
"The function B<fread>()  reads I<nmemb> elements of data, each I<size> bytes "
"long, from the stream pointed to by I<stream>, storing them at the location "
"given by I<ptr>."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:78
msgid ""
"The function B<fwrite>()  writes I<nmemb> elements of data, each I<size> "
"bytes long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:94
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of I<items> read "
"or written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:101
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:103
msgid "C89, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/fread.3:108
msgid "B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fseek.3:40
#, no-wrap
msgid "FSEEK"
msgstr ""

#. type: TH
#: build/C/man3/fseek.3:40
#, no-wrap
msgid "1993-11-29"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:43
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:47
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:49
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:51
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:53
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:55
msgid "B<int fsetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:79
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or "
"end-of-file, respectively.  A successful call to the B<fseek>()  function "
"clears the end-of-file indicator for the stream and undoes any effects of "
"the B<ungetc>(3)  function on the same stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:85
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:92
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:95
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:99
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:117
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with whence set to B<SEEK_SET>), "
"setting and storing the current value of the file offset into or from the "
"object referenced by I<pos>.  On some non-UNIX systems an I<fpos_t> object "
"may be a complex object and these routines may be the only way to portably "
"reposition a text stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:132
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:138
msgid "The I<stream> specified is not a seekable stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:149
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:164
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fseek.3:168
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr ""

#. type: TH
#: build/C/man3/fseeko.3:23
#, no-wrap
msgid "FSEEKO"
msgstr ""

#. type: TH
#: build/C/man3/fseeko.3:23
#, no-wrap
msgid "2001-11-05"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:26
msgid "fseeko, ftello - seek to or report file position"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:31
#, no-wrap
msgid "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:34
#, no-wrap
msgid ""
"B<off_t ftello(FILE *>I<stream>B<);>\n"
"\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:52
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:55
msgid ""
"On many architectures both I<off_t> and I<long> are 32-bit types, but "
"compilation with"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:59 build/C/man3/lseek64.3:79
#, no-wrap
msgid "#define _FILE_OFFSET_BITS 64\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:63
msgid "will turn I<off_t> into a 64-bit type."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:72
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:75
msgid "See the ERRORS in B<fseek>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:77
msgid "SUSv2, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:81
msgid ""
"These functions are found on System V-like systems.  They are not present in "
"libc4, libc5, glibc 2.0 but are available since glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/fseeko.3:82
msgid "B<fseek>(3)"
msgstr ""

#. type: TH
#: build/C/man3/getline.3:24
#, no-wrap
msgid "GETLINE"
msgstr ""

#. type: TH
#: build/C/man3/getline.3:24
#, no-wrap
msgid "2010-06-12"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:27
msgid "getline, getdelim - delimited string input"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:32
#, no-wrap
msgid ""
"B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE "
"*>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:35
#, no-wrap
msgid ""
"B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, "
"FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:45
msgid "B<getline>(), B<getdelim>():"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:50
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:63
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is "
"null-terminated and includes the newline character, if one was found."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:73
msgid ""
"If I<*lineptr> is NULL, then B<getline>()  will allocate a buffer for "
"storing the line, which should be freed by the user program.  (In this case, "
"the value in I<*n> is ignored.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:91
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:97
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:108
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:117
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters "
"read, including the delimiter character, but not including the terminating "
"null byte.  This value can be used to handle embedded null bytes in the line "
"read."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:120
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition)."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:130
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:132
msgid "These functions are available since libc 4.6.27."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:139
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:144
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:152
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t read;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:156
#, no-wrap
msgid ""
"    fp = fopen(\"/etc/motd\", \"r\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:161
#, no-wrap
msgid ""
"    while ((read = getline(&line, &len, fp)) != -1) {\n"
"        printf(\"Retrieved line of length %zu :\\en\", read);\n"
"        printf(\"%s\", line);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:165
#, no-wrap
msgid ""
"    free(line);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getline.3:172
msgid "B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<gets>(3), B<scanf>(3)"
msgstr ""

#. type: TH
#: build/C/man3/gets.3:25
#, no-wrap
msgid "GETS"
msgstr ""

#. type: TH
#: build/C/man3/gets.3:25
#, no-wrap
msgid "2012-01-18"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:28
msgid "fgetc, fgets, getc, getchar, gets, ungetc - input of characters and strings"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:33
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:35
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:37
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:39
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:41
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:76
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:90
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream> "
"and stores them into the buffer pointed to by I<s>.  Reading stops after an "
"B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  A "
"terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character "
"in the buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:101
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will "
"be returned in reverse order; only one pushback is guaranteed."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:106
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:121
msgid ""
"B<fgetc>(), B<getc>()  and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:129
msgid ""
"B<gets>()  and B<fgets>()  return I<s> on success, and NULL on error or when "
"end of file occurs while no characters have been read."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:136
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:138
msgid "C89, C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:150
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:164
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because "
"B<gets>()  will continue to store characters past the end of the buffer, it "
"is extremely dangerous to use.  It has been used to break computer "
"security.  Use B<fgets>()  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:171
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""

#. type: Plain text
#: build/C/man3/gets.3:186
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), "
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<getwchar>(3), "
"B<puts>(3), B<scanf>(3), B<ungetwc>(3), B<unlocked_stdio>(3), "
"B<feature_test_macros>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getw.3:23
#, no-wrap
msgid "GETW"
msgstr ""

#. type: TH
#: build/C/man3/getw.3:23
#, no-wrap
msgid "2010-09-26"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:26
msgid "getw, putw - input and output of words (ints)"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:31
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:33
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:42
msgid "B<getw>(), B<putw>():"
msgstr ""

#. type: TP
#: build/C/man3/getw.3:45
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:48
msgid "_SVID_SOURCE || _BSD_SOURCE ||"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:51
#, no-wrap
msgid ""
"(_XOPEN_SOURCE &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600))\n"
msgstr ""

#. type: TP
#: build/C/man3/getw.3:51
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:54
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:64
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:71
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)  "
"instead."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:78
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:80
msgid "SVr4, SUSv2.  Not present in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:84
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr ""

#. type: Plain text
#: build/C/man3/getw.3:89
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/link.2:31
#, no-wrap
msgid "LINK"
msgstr ""

#. type: TH
#: build/C/man2/link.2:31
#, no-wrap
msgid "2008-08-21"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:34
msgid "link - make a new name for a file"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:36 build/C/man2/lseek.2:52 build/C/man3/lseek64.3:32 build/C/man2/readlink.2:46 build/C/man2/rmdir.2:35 build/C/man2/symlink.2:37 build/C/man2/unlink.2:37 build/C/man2/write.2:44
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:38
msgid "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:41
msgid ""
"B<link>()  creates a new link (also known as a hard link) to an existing "
"file."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:47 build/C/man2/symlink.2:84
msgid "If I<newpath> exists it will I<not> be overwritten."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:52
msgid ""
"This new name may be used exactly as the old one for any operation; both "
"names refer to the same file (and so have the same permissions and "
"ownership) and it is impossible to tell which name was the \"original\"."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:57 build/C/man2/pipe.2:97 build/C/man3/remove.3:65 build/C/man2/rename.2:96 build/C/man2/rmdir.2:45 build/C/man2/symlink.2:89 build/C/man2/unlink.2:60
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/link.2:58 build/C/man2/open.2:473 build/C/man2/readlink.2:84 build/C/man2/rename.2:97 build/C/man2/rmdir.2:46 build/C/man2/symlink.2:90 build/C/man3/tmpfile.3:53 build/C/man2/unlink.2:61
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:69
msgid ""
"Write access to the directory containing I<newpath> is denied, or search "
"permission is denied for one of the directories in the path prefix of "
"I<oldpath> or I<newpath>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/link.2:69 build/C/man2/open.2:482 build/C/man2/symlink.2:99 build/C/man3/tmpfile.3:56
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:73 build/C/man2/symlink.2:103
msgid "I<newpath> already exists."
msgstr ""

#. type: TP
#: build/C/man2/link.2:73 build/C/man2/llseek.2:69 build/C/man2/open.2:488 build/C/man2/pipe.2:98 build/C/man2/read.2:100 build/C/man2/readlink.2:89 build/C/man2/rename.2:133 build/C/man2/rmdir.2:64 build/C/man2/symlink.2:103 build/C/man2/unlink.2:80 build/C/man2/write.2:135
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:76 build/C/man2/rename.2:136 build/C/man2/symlink.2:106
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/link.2:76 build/C/man2/read.2:129 build/C/man2/readlink.2:105 build/C/man2/symlink.2:106 build/C/man2/unlink.2:84 build/C/man2/write.2:159
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:79 build/C/man2/symlink.2:109 build/C/man2/unlink.2:87
msgid "An I/O error occurred."
msgstr ""

#. type: TP
#: build/C/man2/link.2:79 build/C/man2/open.2:512 build/C/man2/readlink.2:108 build/C/man2/rename.2:146 build/C/man2/rmdir.2:73 build/C/man2/symlink.2:109 build/C/man2/unlink.2:92
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:83 build/C/man2/rename.2:150
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""

#. type: TP
#: build/C/man2/link.2:83 build/C/man2/rename.2:150
#, no-wrap
msgid "B<EMLINK>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:88
msgid ""
"The file referred to by I<oldpath> already has the maximum number of links "
"to it."
msgstr ""

#. type: TP
#: build/C/man2/link.2:88 build/C/man2/open.2:522 build/C/man2/readlink.2:111 build/C/man2/rename.2:157 build/C/man2/rmdir.2:77 build/C/man2/symlink.2:113 build/C/man2/unlink.2:96
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:91 build/C/man2/rename.2:160 build/C/man2/symlink.2:116
msgid "I<oldpath> or I<newpath> was too long."
msgstr ""

#. type: TP
#: build/C/man2/link.2:91 build/C/man2/open.2:536 build/C/man2/readlink.2:114 build/C/man2/rename.2:160 build/C/man2/rmdir.2:80 build/C/man2/symlink.2:116 build/C/man2/unlink.2:99
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:96
msgid ""
"A directory component in I<oldpath> or I<newpath> does not exist or is a "
"dangling symbolic link."
msgstr ""

#. type: TP
#: build/C/man2/link.2:96 build/C/man2/open.2:543 build/C/man2/readlink.2:117 build/C/man2/rename.2:173 build/C/man2/rmdir.2:85 build/C/man3/scanf.3:568 build/C/man2/symlink.2:123 build/C/man3/tempnam.3:91 build/C/man2/unlink.2:106
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:99 build/C/man2/open.2:546 build/C/man2/readlink.2:120 build/C/man2/rename.2:176 build/C/man2/rmdir.2:88 build/C/man2/symlink.2:126 build/C/man2/unlink.2:109
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: TP
#: build/C/man2/link.2:99 build/C/man2/open.2:546 build/C/man2/rename.2:176 build/C/man2/symlink.2:126 build/C/man3/tmpfile.3:68 build/C/man2/write.2:162
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:103 build/C/man2/rename.2:180 build/C/man2/symlink.2:130
msgid "The device containing the file has no room for the new directory entry."
msgstr ""

#. type: TP
#: build/C/man2/link.2:103 build/C/man2/open.2:552 build/C/man2/readlink.2:120 build/C/man2/rename.2:180 build/C/man2/rmdir.2:88 build/C/man2/symlink.2:130 build/C/man2/unlink.2:109
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:108
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory."
msgstr ""

#. type: TP
#: build/C/man2/link.2:108 build/C/man2/link.2:112 build/C/man2/open.2:585 build/C/man2/rmdir.2:107 build/C/man2/rmdir.2:118 build/C/man2/symlink.2:135 build/C/man2/unlink.2:114
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:112
msgid "I<oldpath> is a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:117
msgid ""
"The file system containing I<oldpath> and I<newpath> does not support the "
"creation of hard links."
msgstr ""

#. type: TP
#: build/C/man2/link.2:117 build/C/man2/open.2:593 build/C/man2/rename.2:218 build/C/man2/rmdir.2:123 build/C/man2/symlink.2:140 build/C/man3/tmpfile.3:71 build/C/man2/unlink.2:137
#, no-wrap
msgid "B<EROFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:120 build/C/man2/rename.2:221
msgid "The file is on a read-only file system."
msgstr ""

#. type: TP
#: build/C/man2/link.2:120 build/C/man2/rename.2:221
#, no-wrap
msgid "B<EXDEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:128
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted file system.  (Linux "
"permits a file system to be mounted at multiple points, but B<link>()  does "
"not work across different mount points, even if the same file system is "
"mounted on both.)"
msgstr ""

#.  SVr4 documents additional ENOLINK and
#.  EMULTIHOP error conditions; POSIX.1 does not document ELOOP.
#.  X/OPEN does not document EFAULT, ENOMEM or EIO.
#. type: Plain text
#: build/C/man2/link.2:133
msgid "SVr4, 4.3BSD, POSIX.1-2001 (but see NOTES)."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:140
msgid ""
"Hard links, as created by B<link>(), cannot span file systems.  Use "
"B<symlink>(2)  if this is required."
msgstr ""

#.  more precisely: since kernel 1.3.56
#.  For example, the default Solaris compilation environment
#.  behaves like Linux, and contributors to a March 2005
#.  thread in the Austin mailing list reported that some
#.  other (System V) implementations did/do the same -- MTK, Apr 05
#. type: Plain text
#: build/C/man2/link.2:171
msgid ""
"POSIX.1-2001 says that B<link>()  should dereference I<oldpath> if it is a "
"symbolic link.  However, since kernel 2.0, Linux does not do so: if "
"I<oldpath> is a symbolic link, then I<newpath> is created as a (hard) link "
"to the same symbolic link file (i.e., I<newpath> becomes a symbolic link to "
"the same file that I<oldpath> refers to).  Some other implementations behave "
"in the same manner as Linux.  POSIX.1-2008 changes the specification of "
"B<link>(), making it implementation-dependent whether or not I<oldpath> is "
"dereferenced if it is a symbolic link.  For precise control over the "
"treatment of symbolic links when creating a link, see B<linkat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:177
msgid ""
"On NFS file systems, the return code may be wrong in case the NFS server "
"performs the link creation and dies before it can say so.  Use B<stat>(2)  "
"to find out if the link got created."
msgstr ""

#. type: Plain text
#: build/C/man2/link.2:186
msgid ""
"B<ln>(1), B<linkat>(2), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), "
"B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/llseek.2:26
#, no-wrap
msgid "LLSEEK"
msgstr ""

#. type: TH
#: build/C/man2/llseek.2:26
#, no-wrap
msgid "2007-06-01"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:29
msgid "_llseek - reposition read/write file offset"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:37
#, no-wrap
msgid ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:57
msgid ""
"The B<_llseek>()  function repositions the offset of the open file "
"associated with the file descriptor I<fd> to I<(offset_highE<lt>E<lt>32) | "
"offset_low> bytes relative to the beginning of the file, the current "
"position in the file, or the end of the file, depending on whether I<whence> "
"is B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively.  It returns the "
"resulting file position in the argument I<result>."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:64
msgid ""
"Upon successful completion, B<_llseek>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:69 build/C/man2/lseek.2:164
msgid "I<fd> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:72
msgid "Problem with copying results to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:76
msgid "I<whence> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:79
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:82
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/llseek.2:84
msgid "B<lseek>(2), B<lseek64>(3)"
msgstr ""

#. type: TH
#: build/C/man2/lseek.2:45
#, no-wrap
msgid "LSEEK"
msgstr ""

#. type: TH
#: build/C/man2/lseek.2:45
#, no-wrap
msgid "2011-09-25"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:48
msgid "lseek - reposition read/write file offset"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:50 build/C/man3/lseek64.3:30
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:54
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:65
msgid ""
"The B<lseek>()  function repositions the offset of the open file associated "
"with the file descriptor I<fd> to the argument I<offset> according to the "
"directive I<whence> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:70
msgid "The offset is set to I<offset> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:75
msgid "The offset is set to its current location plus I<offset> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:80
msgid "The offset is set to the size of the file plus I<offset> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:88
msgid ""
"The B<lseek>()  function allows the file offset to be set beyond the end of "
"the file (but this does not change the size of the file).  If data is later "
"written at this point, subsequent reads of the data in the gap (a \"hole\") "
"return null bytes (\\(aq\\e0\\(aq) until data is actually written into the "
"gap."
msgstr ""

#. type: SS
#: build/C/man2/lseek.2:88
#, no-wrap
msgid "Seeking file data and holes"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:91
msgid ""
"Since version 3.1, Linux supports the following additional values for "
"I<whence>:"
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:91
#, no-wrap
msgid "B<SEEK_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:102
msgid ""
"Adjust the file offset to the next location in the file greater than or "
"equal to I<offset> containing data.  If I<offset> points to data, then the "
"file offset is set to I<offset>."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:102
#, no-wrap
msgid "B<SEEK_HOLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:116
msgid ""
"Adjust the file offset to the next hole in the file greater than or equal to "
"I<offset>.  If I<offset> points into the middle of a hole, then the file "
"offset is set to I<offset>.  If there is no hole past I<offset>, then the "
"file offset is adjusted to the end of the file (i.e., there is an implicit "
"hole at the end of any file)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:122
msgid ""
"In both of the above cases, B<lseek>()  fails if I<offset> points past the "
"end of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:128
msgid ""
"These operations allow applications to map holes in a sparsely allocated "
"file.  This can be useful for applications such as file backup tools, which "
"can save space when creating backups and preserve holes, if they have a "
"mechanism for discovering holes."
msgstr ""

#.  https://lkml.org/lkml/2011/4/22/79
#.  http://lwn.net/Articles/440255/
#.  http://blogs.oracle.com/bonwick/entry/seek_hole_and_seek_data
#. type: Plain text
#: build/C/man2/lseek.2:151
msgid ""
"For the purposes of these operations, a hole is a sequence of zeros that "
"(normally) has not been allocated in the underlying file storage.  However, "
"a file system is not obliged to report holes, so these operations are not a "
"guaranteed mechanism for mapping the storage space actually allocated to a "
"file.  (Furthermore, a sequence of zeros that actually has been written to "
"the underlying storage may not be reported as a hole.)  In the simplest "
"implementation, a file system can support the operations by making "
"B<SEEK_HOLE> always return the offset of the end of the file, and making "
"B<SEEK_DATA> always return I<offset> (i.e., even if the location referred to "
"by I<offset> is a hole, it can be considered to consist of data that is a "
"sequence of zeros)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:159
msgid ""
"Upon successful completion, B<lseek>()  returns the resulting offset "
"location as measured in bytes from the beginning of the file.  On error, the "
"value I<(off_t)\\ -1> is returned and I<errno> is set to indicate the error."
msgstr ""

#.  Some systems may allow negative offsets for character devices
#.  and/or for remote file systems.
#. type: Plain text
#: build/C/man2/lseek.2:172
msgid ""
"I<whence> is not valid.  Or: the resulting file offset would be negative, or "
"beyond the end of a seekable device."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:172 build/C/man2/open.2:565
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#.  HP-UX 11 says EINVAL for this case (but POSIX.1 says EOVERFLOW)
#. type: Plain text
#: build/C/man2/lseek.2:177
msgid "The resulting file offset cannot be represented in an I<off_t>."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:177
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:181
msgid "I<fd> is associated with a pipe, socket, or FIFO."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:181 build/C/man2/open.2:559
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:189
msgid ""
"I<whence> is B<SEEK_DATA> or B<SEEK_HOLE>, and the current file offset is "
"beyond the end of the file."
msgstr ""

#.  SVr4 documents additional error
#.  conditions EDEADLK, ENOLCK, ENOLNK, ENOSR, ENXIO, or ERANGE.
#. type: Plain text
#: build/C/man2/lseek.2:191 build/C/man2/read.2:157 build/C/man2/rmdir.2:129 build/C/man2/symlink.2:150 build/C/man2/unlink.2:145 build/C/man2/write.2:183
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""

#.  FIXME . Review http://austingroupbugs.net/view.php?id=415 in the future
#. type: Plain text
#: build/C/man2/lseek.2:199
msgid ""
"B<SEEK_DATA> and B<SEEK_HOLE> are nonstandard extensions also present in "
"Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion in the "
"next POSIX revision (Issue 8)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:203
msgid ""
"Some devices are incapable of seeking and POSIX does not specify which "
"devices must support B<lseek>()."
msgstr ""

#.  Other systems return the number of written characters,
#.  using SEEK_SET to set the counter. (Of written characters.)
#. type: Plain text
#: build/C/man2/lseek.2:210
msgid "On Linux, using B<lseek>()  on a tty device returns B<ESPIPE>."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:213
msgid ""
"When converting old code, substitute values for I<whence> with the following "
"macros:"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:216
#, no-wrap
msgid "old\tnew\n"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:217
#, no-wrap
msgid "0\tSEEK_SET\n"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:218
#, no-wrap
msgid "1\tSEEK_CUR\n"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:219
#, no-wrap
msgid "2\tSEEK_END\n"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:220
#, no-wrap
msgid "L_SET\tSEEK_SET\n"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:221
#, no-wrap
msgid "L_INCR\tSEEK_CUR\n"
msgstr ""

#. type: tbl table
#: build/C/man2/lseek.2:222
#, no-wrap
msgid "L_XTND\tSEEK_END\n"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:234
msgid ""
"Note that file descriptors created by B<dup>(2)  or B<fork>(2)  share the "
"current file position pointer, so seeking on such files may be subject to "
"race conditions."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:240
msgid ""
"B<dup>(2), B<fork>(2), B<open>(2), B<fseek>(3), B<lseek64>(3), "
"B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: build/C/man3/lseek64.3:23
#, no-wrap
msgid "LSEEK64"
msgstr ""

#. type: TH
#: build/C/man3/lseek64.3:23
#, no-wrap
msgid "2004-12-11"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:26
msgid "lseek64 - reposition 64-bit read/write file offset"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:28
msgid "B<#define _LARGEFILE64_SOURCE> /* See feature_test_macros(7) */"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:34
msgid "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:51
msgid ""
"The B<lseek>(2)  family of functions reposition the offset of the open file "
"associated with the file descriptor I<fd> to I<offset> bytes relative to the "
"start, current position, or end of the file, when I<whence> has the value "
"B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:54
msgid "For more details, return value, and errors, see B<lseek>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:61
msgid ""
"Four interfaces are available: B<lseek>(2), B<lseek64>(), B<llseek>(2), and "
"the raw system call B<_llseek>(2)."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:61
#, no-wrap
msgid "lseek"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:63 build/C/man3/lseek64.3:85 build/C/man3/lseek64.3:114
msgid "Prototype:"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:67
#, no-wrap
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:75
msgid ""
"B<lseek>(2)  uses the type I<off_t>.  This is a 32-bit signed type on 32-bit "
"architectures, unless one compiles with"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:83
msgid "in which case it is a 64-bit signed type."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:83
#, no-wrap
msgid "lseek64"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:89
#, no-wrap
msgid "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:100
msgid ""
"The library routine B<lseek64>()  uses a 64-bit type even when I<off_t> is a "
"32-bit type.  Its prototype (and the type I<off64_t>)  is available only "
"when one compiles with"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:104
#, no-wrap
msgid "#define _LARGEFILE64_SOURCE\n"
msgstr ""

#.  in glibc 2.0.94, not in 2.0.6
#. type: Plain text
#: build/C/man3/lseek64.3:112
msgid ""
"The function B<lseek64>()  is available since glibc 2.1, and is defined to "
"be an alias for B<llseek>()."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:112
#, no-wrap
msgid "llseek"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:118
#, no-wrap
msgid "B<loff_t llseek(int >I<fd>B<, loff_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr ""

#.  in libc 5.0.9, not in 4.7.6
#. type: Plain text
#: build/C/man3/lseek64.3:137
msgid ""
"The type I<loff_t> is a 64-bit signed type.  The library routine B<llseek>()  "
"is available in libc5 and glibc and works without special defines.  Its "
"prototype was given in I<E<lt>unistd.hE<gt>> with libc5, but glibc does not "
"provide a prototype.  This is bad, since a prototype is needed.  Users "
"should add the above prototype, or something equivalent, to their own "
"source.  When users complained about data loss caused by a miscompilation of "
"B<e2fsck>(8), glibc 2.1.3 added the link-time warning"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:140
msgid "the \\`llseek\\' function may be dangerous; use \\`lseek64\\' instead."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:144
msgid "This makes this function unusable if one desires a warning-free compilation."
msgstr ""

#. type: SS
#: build/C/man3/lseek64.3:144
#, no-wrap
msgid "_llseek"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:147
msgid ""
"All the above functions are implemented in terms of this system call.  The "
"prototype is:"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:152
#, no-wrap
msgid ""
"B<int _llseek(int >I<fd>B<, off_t >I<offset_hi>B<, off_t >I<offset_lo>B<,>\n"
"B<            loff_t *>I<result>B<, int >I<whence>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:157
msgid "For more details, see B<llseek>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/lseek64.3:159
msgid "B<llseek>(2), B<lseek>(2)"
msgstr ""

#. type: TH
#: build/C/man2/open.2:52
#, no-wrap
msgid "OPEN"
msgstr ""

#. type: TH
#: build/C/man2/open.2:52
#, no-wrap
msgid "2012-02-27"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:55
msgid "open, creat - open and possibly create a file or device"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:60
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:63
#, no-wrap
msgid ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:65
#, no-wrap
msgid "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:76
msgid ""
"Given a I<pathname> for a file, B<open>()  returns a file descriptor, a "
"small, nonnegative integer for use in subsequent system calls (B<read>(2), "
"B<write>(2), B<lseek>(2), B<fcntl>(2), etc.).  The file descriptor returned "
"by a successful call will be the lowest-numbered file descriptor not "
"currently open for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:88
msgid ""
"By default, the new file descriptor is set to remain open across an "
"B<execve>(2)  (i.e., the B<FD_CLOEXEC> file descriptor flag described in "
"B<fcntl>(2)  is initially disabled; the B<O_CLOEXEC> flag, described below, "
"can be used to change this default).  The file offset is set to the "
"beginning of the file (see B<lseek>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:107
msgid ""
"A call to B<open>()  creates a new I<open file description>, an entry in the "
"system-wide table of open files.  This entry records the file offset and the "
"file status flags (modifiable via the B<fcntl>(2)  B<F_SETFL> operation).  A "
"file descriptor is a reference to one of these entries; this reference is "
"unaffected if I<pathname> is subsequently removed or modified to refer to a "
"different file.  The new open file description is initially not shared with "
"any other process, but sharing may arise via B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:115
msgid ""
"The argument I<flags> must include one of the following I<access modes>: "
"B<O_RDONLY>, B<O_WRONLY>, or B<O_RDWR>.  These request opening the file "
"read-only, write-only, or read/write, respectively."
msgstr ""

#.  FIXME . Actually is it true that the "file status flags" are all of the
#.  remaining flags listed below?  SUSv4 divides the flags into:
#.  * Access mode
#.  * File creation
#.  * File status
#.  * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
#.  though it's not clear what the difference between "other" and
#.  "File creation" flags is.  (I've raised an Aardvark to see if this
#.  can be clarified in SUSv4; 10 Oct 2008.)
#. type: Plain text
#: build/C/man2/open.2:142
msgid ""
"In addition, zero or more file creation flags and file status flags can be "
"bitwise-I<or>'d in I<flags>.  The I<file creation flags> are B<O_CREAT>, "
"B<O_EXCL>, B<O_NOCTTY>, and B<O_TRUNC>.  The I<file status flags> are all of "
"the remaining flags listed below.  The distinction between these two groups "
"of flags is that the file status flags can be retrieved and (in some cases)  "
"modified using B<fcntl>(2).  The full list of file creation flags and file "
"status flags is as follows:"
msgstr ""

#. type: TP
#: build/C/man2/open.2:142
#, no-wrap
msgid "B<O_APPEND>"
msgstr ""

#.  For more background, see
#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
#.  http://nfs.sourceforge.net/
#. type: Plain text
#: build/C/man2/open.2:159
msgid ""
"The file is opened in append mode.  Before each B<write>(2), the file offset "
"is positioned at the end of the file, as if with B<lseek>(2).  B<O_APPEND> "
"may lead to corrupted files on NFS file systems if more than one process "
"appends data to a file at once.  This is because NFS does not support "
"appending to a file, so the client kernel has to simulate it, which can't be "
"done without a race condition."
msgstr ""

#. type: TP
#: build/C/man2/open.2:159
#, no-wrap
msgid "B<O_ASYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:172
msgid ""
"Enable signal-driven I/O: generate a signal (B<SIGIO> by default, but this "
"can be changed via B<fcntl>(2))  when input or output becomes possible on "
"this file descriptor.  This feature is only available for terminals, "
"pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See "
"B<fcntl>(2)  for further details."
msgstr ""

#. type: TP
#: build/C/man2/open.2:172
#, no-wrap
msgid "B<O_CLOEXEC> (Since Linux 2.6.23)"
msgstr ""

#.  This flag fixes only one form of the race condition;
#.  The race can also occur with, for example, descriptors
#.  returned by accept(), pipe(), etc.
#. type: Plain text
#: build/C/man2/open.2:197
msgid ""
"Enable the close-on-exec flag for the new file descriptor.  Specifying this "
"flag permits a program to avoid additional B<fcntl>(2)  B<F_SETFD> "
"operations to set the B<FD_CLOEXEC> flag.  Additionally, use of this flag is "
"essential in some multithreaded programs since using a separate B<fcntl>(2)  "
"B<F_SETFD> operation to set the B<FD_CLOEXEC> flag does not suffice to avoid "
"race conditions where one thread opens a file descriptor at the same time as "
"another thread does a B<fork>(2)  plus B<execve>(2)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:197
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#.  As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
#.  XFS (since 2.6.14).
#. type: Plain text
#: build/C/man2/open.2:213
msgid ""
"If the file does not exist it will be created.  The owner (user ID) of the "
"file is set to the effective user ID of the process.  The group ownership "
"(group ID) is set either to the effective group ID of the process or to the "
"group ID of the parent directory (depending on file system type and mount "
"options, and the mode of the parent directory, see the mount options "
"I<bsdgroups> and I<sysvgroups> described in B<mount>(8))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:236
msgid ""
"I<mode> specifies the permissions to use in case a new file is created.  "
"This argument must be supplied when B<O_CREAT> is specified in I<flags>; if "
"B<O_CREAT> is not specified, then I<mode> is ignored.  The effective "
"permissions are modified by the process's I<umask> in the usual way: The "
"permissions of the created file are I<(mode\\ &\\ ~umask)>.  Note that this "
"mode only applies to future accesses of the newly created file; the "
"B<open>()  call that creates a read-only file may well return a read/write "
"file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:239
msgid "The following symbolic constants are provided for I<mode>:"
msgstr ""

#. type: TP
#: build/C/man2/open.2:239
#, no-wrap
msgid "B<S_IRWXU>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:242
msgid "00700 user (file owner) has read, write and execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:242
#, no-wrap
msgid "B<S_IRUSR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:245
msgid "00400 user has read permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:245
#, no-wrap
msgid "B<S_IWUSR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:248
msgid "00200 user has write permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:248
#, no-wrap
msgid "B<S_IXUSR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:251
msgid "00100 user has execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:251
#, no-wrap
msgid "B<S_IRWXG>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:254
msgid "00070 group has read, write and execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:254
#, no-wrap
msgid "B<S_IRGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:257
msgid "00040 group has read permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:257
#, no-wrap
msgid "B<S_IWGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:260
msgid "00020 group has write permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:260
#, no-wrap
msgid "B<S_IXGRP>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:263
msgid "00010 group has execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:263
#, no-wrap
msgid "B<S_IRWXO>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:266
msgid "00007 others have read, write and execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:266
#, no-wrap
msgid "B<S_IROTH>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:269
msgid "00004 others have read permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:269
#, no-wrap
msgid "B<S_IWOTH>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:272
msgid "00002 others have write permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:272
#, no-wrap
msgid "B<S_IXOTH>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:275
msgid "00001 others have execute permission"
msgstr ""

#. type: TP
#: build/C/man2/open.2:276
#, no-wrap
msgid "B<O_DIRECT> (Since Linux 2.4.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:293
msgid ""
"Try to minimize cache effects of the I/O to and from this file.  In general "
"this will degrade performance, but it is useful in special situations, such "
"as when applications do their own caching.  File I/O is done directly "
"to/from user space buffers.  The B<O_DIRECT> flag on its own makes an effort "
"to transfer data synchronously, but does not give the guarantees of the "
"B<O_SYNC> flag that data and necessary metadata are transferred.  To "
"guarantee synchronous I/O, B<O_SYNC> must be used in addition to "
"B<O_DIRECT>.  See NOTES below for further discussion."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:297
msgid ""
"A semantically similar (but deprecated) interface for block devices is "
"described in B<raw>(8)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:297
#, no-wrap
msgid "B<O_DIRECTORY>"
msgstr ""

#.  But see the following and its replies:
#.  http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
#.  [PATCH] open: O_DIRECTORY and O_CREAT together should fail
#.  O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
#. type: Plain text
#: build/C/man2/open.2:311
msgid ""
"If I<pathname> is not a directory, cause the open to fail.  This flag is "
"Linux-specific, and was added in kernel version 2.1.126, to avoid "
"denial-of-service problems if B<opendir>(3)  is called on a FIFO or tape "
"device, but should not be used outside of the implementation of "
"B<opendir>(3)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:311
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:321
msgid ""
"Ensure that this call creates the file: if this flag is specified in "
"conjunction with B<O_CREAT>, and I<pathname> already exists, then B<open>()  "
"will fail."
msgstr ""

#.  POSIX.1-2001 explicitly requires this behavior.
#. type: Plain text
#: build/C/man2/open.2:329
msgid ""
"When these two flags are specified, symbolic links are not followed: if "
"I<pathname> is a symbolic link, then B<open>()  fails regardless of where "
"the symbolic link points to."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:345
msgid ""
"In general, the behavior of B<O_EXCL> is undefined if it is used without "
"B<O_CREAT>.  There is one exception: on Linux 2.6 and later, B<O_EXCL> can "
"be used without B<O_CREAT> if I<pathname> refers to a block device.  If the "
"block device is in use by the system (e.g., mounted), B<open>()  fails with "
"the error B<EBUSY>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:367
msgid ""
"On NFS, B<O_EXCL> is only supported when using NFSv3 or later on kernel 2.6 "
"or later.  In NFS environments where B<O_EXCL> support is not provided, "
"programs that rely on it for performing locking tasks will contain a race "
"condition.  Portable programs that want to perform atomic file locking using "
"a lockfile, and need to avoid reliance on NFS support for B<O_EXCL>, can "
"create a unique file on the same file system (e.g., incorporating hostname "
"and PID), and use B<link>(2)  to make a link to the lockfile.  If B<link>(2)  "
"returns 0, the lock is successful.  Otherwise, use B<stat>(2)  on the unique "
"file to check if its link count has increased to 2, in which case the lock "
"is also successful."
msgstr ""

#. type: TP
#: build/C/man2/open.2:367
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:389
msgid ""
"(LFS)  Allow files whose sizes cannot be represented in an I<off_t> (but can "
"be represented in an I<off64_t>)  to be opened.  The B<_LARGEFILE64_SOURCE> "
"macro must be defined (before including I<any> header files)  in order to "
"obtain this definition.  Setting the B<_FILE_OFFSET_BITS> feature test macro "
"to 64 (rather than using B<O_LARGEFILE>)  is the preferred method of "
"accessing large files on 32-bit systems (see B<feature_test_macros>(7))."
msgstr ""

#. type: TP
#: build/C/man2/open.2:389
#, no-wrap
msgid "B<O_NOATIME> (Since Linux 2.6.8)"
msgstr ""

#.  The O_NOATIME flag also affects the treatment of st_atime
#.  by mmap() and readdir(2), MTK, Dec 04.
#. type: Plain text
#: build/C/man2/open.2:400
msgid ""
"Do not update the file last access time (st_atime in the inode)  when the "
"file is B<read>(2).  This flag is intended for use by indexing or backup "
"programs, where its use can significantly reduce the amount of disk "
"activity.  This flag may not be effective on all file systems.  One example "
"is NFS, where the server maintains the access time."
msgstr ""

#. type: TP
#: build/C/man2/open.2:400
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:408
msgid ""
"If I<pathname> refers to a terminal device\\(emsee B<tty>(4)\\(em it will "
"not become the process's controlling terminal even if the process does not "
"have one."
msgstr ""

#. type: TP
#: build/C/man2/open.2:408
#, no-wrap
msgid "B<O_NOFOLLOW>"
msgstr ""

#.  The headers from glibc 2.0.100 and later include a
#.  definition of this flag; \fIkernels before 2.1.126 will ignore it if
#.  used\fP.
#. type: Plain text
#: build/C/man2/open.2:417
msgid ""
"If I<pathname> is a symbolic link, then the open fails.  This is a FreeBSD "
"extension, which was added to Linux in version 2.1.126.  Symbolic links in "
"earlier components of the pathname will still be followed."
msgstr ""

#. type: TP
#: build/C/man2/open.2:417
#, no-wrap
msgid "B<O_NONBLOCK> or B<O_NDELAY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:430
msgid ""
"When possible, the file is opened in nonblocking mode.  Neither the "
"B<open>()  nor any subsequent operations on the file descriptor which is "
"returned will cause the calling process to wait.  For the handling of FIFOs "
"(named pipes), see also B<fifo>(7).  For a discussion of the effect of "
"B<O_NONBLOCK> in conjunction with mandatory file locks and with file leases, "
"see B<fcntl>(2)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:430
#, no-wrap
msgid "B<O_SYNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:438
msgid ""
"The file is opened for synchronous I/O.  Any B<write>(2)s on the resulting "
"file descriptor will block the calling process until the data has been "
"physically written to the underlying hardware.  I<But see NOTES below>."
msgstr ""

#. type: TP
#: build/C/man2/open.2:438
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:452
msgid ""
"If the file already exists and is a regular file and the open mode allows "
"writing (i.e., is B<O_RDWR> or B<O_WRONLY>)  it will be truncated to length "
"0.  If the file is a FIFO or terminal device file, the B<O_TRUNC> flag is "
"ignored.  Otherwise the effect of B<O_TRUNC> is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:456
msgid ""
"Some of these optional flags can be altered using B<fcntl>(2)  after the "
"file has been opened."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:464
msgid ""
"B<creat>()  is equivalent to B<open>()  with I<flags> equal to "
"B<O_CREAT|O_WRONLY|O_TRUNC>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:472
msgid ""
"B<open>()  and B<creat>()  return the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:482
msgid ""
"The requested access to the file is not allowed, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>, or the "
"file did not exist yet and write access to the parent directory is not "
"allowed.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:488
msgid "I<pathname> already exists and B<O_CREAT> and B<O_EXCL> were used."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:492 build/C/man2/rmdir.2:67 build/C/man2/unlink.2:84
msgid "I<pathname> points outside your accessible address space."
msgstr ""

#. type: TP
#: build/C/man2/open.2:492 build/C/man2/write.2:139
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:496
msgid "See B<EOVERFLOW>."
msgstr ""

#. type: TP
#: build/C/man2/open.2:496 build/C/man2/read.2:104 build/C/man3/scanf.3:559 build/C/man3/tmpfile.3:59 build/C/man2/write.2:144
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:503
msgid ""
"While blocked waiting to complete an open of a slow device (e.g., a FIFO; "
"see B<fifo>(7)), the call was interrupted by a signal handler; see "
"B<signal>(7)."
msgstr ""

#. type: TP
#: build/C/man2/open.2:503 build/C/man2/read.2:140 build/C/man2/rename.2:140 build/C/man2/unlink.2:87
#, no-wrap
msgid "B<EISDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:512
msgid ""
"I<pathname> refers to a directory and the access requested involved writing "
"(that is, B<O_WRONLY> or B<O_RDWR> is set)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:519
msgid ""
"Too many symbolic links were encountered in resolving I<pathname>, or "
"B<O_NOFOLLOW> was specified but I<pathname> was a symbolic link."
msgstr ""

#. type: TP
#: build/C/man2/open.2:519 build/C/man2/pipe.2:107 build/C/man3/tmpfile.3:62
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:522
msgid "The process already has the maximum number of files open."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:526 build/C/man2/rmdir.2:80 build/C/man2/unlink.2:99
msgid "I<pathname> was too long."
msgstr ""

#. type: TP
#: build/C/man2/open.2:526 build/C/man2/pipe.2:110 build/C/man3/tmpfile.3:65
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:529 build/C/man2/pipe.2:113
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/open.2:529
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:536
msgid ""
"I<pathname> refers to a device special file and no corresponding device "
"exists.  (This is a Linux kernel bug; in this situation B<ENXIO> must be "
"returned.)"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:543
msgid ""
"B<O_CREAT> is not set and the named file does not exist.  Or, a directory "
"component in I<pathname> does not exist or is a dangling symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:552
msgid ""
"I<pathname> was to be created but the device containing I<pathname> has no "
"room for the new file."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:559
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory, "
"or B<O_DIRECTORY> was specified and I<pathname> was not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:565
msgid ""
"B<O_NONBLOCK> | B<O_WRONLY> is set, the named file is a FIFO and no process "
"has the file open for reading.  Or, the file is a device special file and no "
"corresponding device exists."
msgstr ""

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=7253
#.  "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
#.  Reported 2006-10-03
#. type: Plain text
#: build/C/man2/open.2:585
msgid ""
"I<pathname> refers to a regular file that is too large to be opened.  The "
"usual scenario here is that an application compiled on a 32-bit platform "
"without I<-D_FILE_OFFSET_BITS=64> tried to open a file whose size exceeds "
"I<(2E<lt>E<lt>31)-1> bits; see also B<O_LARGEFILE> above.  This is the error "
"specified by POSIX.1-2001; in kernels before 2.6.24, Linux gave the error "
"B<EFBIG> for this case."
msgstr ""

#.  Strictly speaking, it's the file system UID... (MTK)
#. type: Plain text
#: build/C/man2/open.2:593
msgid ""
"The B<O_NOATIME> flag was specified, but the effective user ID of the caller "
"did not match the owner of the file and the caller was not privileged "
"(B<CAP_FOWNER>)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:598
msgid ""
"I<pathname> refers to a file on a read-only file system and write access was "
"requested."
msgstr ""

#. type: TP
#: build/C/man2/open.2:598
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:603
msgid ""
"I<pathname> refers to an executable image which is currently being executed "
"and write access was requested."
msgstr ""

#. type: TP
#: build/C/man2/open.2:603
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:610
msgid ""
"The B<O_NONBLOCK> flag was specified, and an incompatible lease was held on "
"the file (see B<fcntl>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:623
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  The B<O_DIRECTORY>, B<O_NOATIME>, and "
"B<O_NOFOLLOW> flags are Linux-specific, and one may need to define "
"B<_GNU_SOURCE> (before including I<any> header files)  to obtain their "
"definitions."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:628
msgid ""
"The B<O_CLOEXEC> flag is not specified in POSIX.1-2001, but is specified in "
"POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:636
msgid ""
"B<O_DIRECT> is not specified in POSIX; one has to define B<_GNU_SOURCE> "
"(before including I<any> header files)  to get its definition."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:644
msgid ""
"Under Linux, the B<O_NONBLOCK> flag indicates that one wants to open but "
"does not necessarily have the intention to read or write.  This is typically "
"used to open devices in order to get a file descriptor for use with "
"B<ioctl>(2)."
msgstr ""

#.  See for example util-linux's disk-utils/setfdprm.c
#.  For some background on access mode 3, see
#.  http://thread.gmane.org/gmane.linux.kernel/653123
#.  "[RFC] correct flags to f_mode conversion in __dentry_open"
#.  LKML, 12 Mar 2008
#. type: Plain text
#: build/C/man2/open.2:673
msgid ""
"Unlike the other values that can be specified in I<flags>, the I<access "
"mode> values B<O_RDONLY>, B<O_WRONLY>, and B<O_RDWR>, do not specify "
"individual bits.  Rather, they define the low order two bits of I<flags>, "
"and are defined respectively as 0, 1, and 2.  In other words, the "
"combination B<O_RDONLY | O_WRONLY> is a logical error, and certainly does "
"not have the same meaning as B<O_RDWR>.  Linux reserves the special, "
"nonstandard access mode 3 (binary 11) in I<flags> to mean: check for read "
"and write permission on the file and return a descriptor that can't be used "
"for reading or writing.  This nonstandard access mode is used by some Linux "
"drivers to return a descriptor that is only to be used for device-specific "
"B<ioctl>(2)  operations."
msgstr ""

#.  Linux 2.0, 2.5: truncate
#.  Solaris 5.7, 5.8: truncate
#.  Irix 6.5: truncate
#.  Tru64 5.1B: truncate
#.  HP-UX 11.22: truncate
#.  FreeBSD 4.7: truncate
#. type: Plain text
#: build/C/man2/open.2:684
msgid ""
"The (undefined) effect of B<O_RDONLY | O_TRUNC> varies among "
"implementations.  On many systems the file is actually truncated."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:688
msgid ""
"There are many infelicities in the protocol underlying NFS, affecting "
"amongst others B<O_SYNC> and B<O_NDELAY>."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:710
msgid ""
"POSIX provides for three different variants of synchronized I/O, "
"corresponding to the flags B<O_SYNC>, B<O_DSYNC>, and B<O_RSYNC>.  Currently "
"(2.6.31), Linux only implements B<O_SYNC>, but glibc maps B<O_DSYNC> and "
"B<O_RSYNC> to the same numerical value as B<O_SYNC>.  Most Linux file "
"systems don't actually implement the POSIX B<O_SYNC> semantics, which "
"require all metadata updates of a write to be on disk on returning to "
"userspace, but only the B<O_DSYNC> semantics, which require only actual file "
"data and metadata necessary to retrieve it to be on disk by the time the "
"system call returns."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:718
msgid ""
"Note that B<open>()  can open device special files, but B<creat>()  cannot "
"create them; use B<mknod>(2)  instead."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:731
msgid ""
"On NFS file systems with UID mapping enabled, B<open>()  may return a file "
"descriptor but, for example, B<read>(2)  requests are denied with "
"B<EACCES>.  This is because the client performs B<open>()  by checking the "
"permissions, but UID mapping is performed by the server upon read and write "
"requests."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:750
msgid ""
"If the file is newly created, its I<st_atime>, I<st_ctime>, I<st_mtime> "
"fields (respectively, time of last access, time of last status change, and "
"time of last modification; see B<stat>(2))  are set to the current time, and "
"so are the I<st_ctime> and I<st_mtime> fields of the parent directory.  "
"Otherwise, if the file is modified because of the B<O_TRUNC> flag, its "
"st_ctime and st_mtime fields are set to the current time."
msgstr ""

#. type: SS
#: build/C/man2/open.2:750
#, no-wrap
msgid "O_DIRECT"
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:767
msgid ""
"The B<O_DIRECT> flag may impose alignment restrictions on the length and "
"address of userspace buffers and the file offset of I/Os.  In Linux "
"alignment restrictions vary by file system and kernel version and might be "
"absent entirely.  However there is currently no file system-independent "
"interface for an application to discover these restrictions for a given file "
"or file system.  Some file systems provide their own interfaces for doing "
"so, for example the B<XFS_IOC_DIOINFO> operation in B<xfsctl>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:773
msgid ""
"Under Linux 2.4, transfer sizes, and the alignment of the user buffer and "
"the file offset must all be multiples of the logical block size of the file "
"system.  Under Linux 2.6, alignment to 512-byte boundaries suffices."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:783
msgid ""
"The B<O_DIRECT> flag was introduced in SGI IRIX, where it has alignment "
"restrictions similar to those of Linux 2.4.  IRIX has also a B<fcntl>(2)  "
"call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a "
"flag of the same name, but without alignment restrictions."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:792
msgid ""
"B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  Older "
"Linux kernels simply ignore this flag.  Some file systems may not implement "
"the flag and B<open>()  will fail with B<EINVAL> if it is used."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:803
msgid ""
"Applications should avoid mixing B<O_DIRECT> and normal I/O to the same "
"file, and especially to overlapping byte regions in the same file.  Even "
"when the file system correctly handles the coherency issues in this "
"situation, overall I/O throughput is likely to be slower than using either "
"mode alone.  Likewise, applications should avoid mixing B<mmap>(2)  of files "
"with direct I/O to the same files."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:825
msgid ""
"The behaviour of B<O_DIRECT> with NFS will differ from local file systems.  "
"Older kernels, or kernels configured in certain ways, may not support this "
"combination.  The NFS protocol does not support passing the flag to the "
"server, so B<O_DIRECT> I/O will only bypass the page cache on the client; "
"the server may still cache the I/O.  The client asks the server to make the "
"I/O synchronous to preserve the synchronous semantics of B<O_DIRECT>.  Some "
"servers will perform poorly under these circumstances, especially if the I/O "
"size is small.  Some servers may also be configured to lie to clients about "
"the I/O having reached stable storage; this will avoid the performance "
"penalty at some risk to data integrity in the event of server power "
"failure.  The Linux NFS client places no alignment restrictions on "
"B<O_DIRECT> I/O."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:832
msgid ""
"In summary, B<O_DIRECT> is a potentially powerful tool that should be used "
"with caution.  It is recommended that applications treat use of B<O_DIRECT> "
"as a performance option which is disabled by default."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:837
msgid ""
"\"The thing that has always disturbed me about O_DIRECT is that the whole "
"interface is just stupid, and was probably designed by a deranged monkey on "
"some serious mind-controlling substances.\"\\(emLinus"
msgstr ""

#.  FIXME . Check bugzilla report on open(O_ASYNC)
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5993
#. type: Plain text
#: build/C/man2/open.2:849
msgid ""
"Currently, it is not possible to enable signal-driven I/O by specifying "
"B<O_ASYNC> when calling B<open>(); use B<fcntl>(2)  to enable this flag."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:870
msgid ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<openat>(2), B<read>(2), "
"B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<write>(2), "
"B<fopen>(3), B<fifo>(7), B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man3/perror.3:30
#, no-wrap
msgid "PERROR"
msgstr ""

#. type: TH
#: build/C/man3/perror.3:30
#, no-wrap
msgid "2012-04-17"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:33
msgid "perror - print a system error message"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:37
msgid "B<void perror(const char *>I<s>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:39
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:41
msgid "B<const char *>I<sys_errlist>B<[];>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:43
msgid "B<int >I<sys_nerr>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:45
msgid "B<int >I<errno>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:54
msgid "I<sys_errlist>, I<sys_nerr>: _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:67
msgid ""
"The routine B<perror>()  produces a message on the standard error output, "
"describing the last error encountered during a call to a system or library "
"function.  First (if I<s> is not NULL and I<*s> is not a null byte "
"(\\(aq\\e0\\(aq)) the argument string I<s> is printed, followed by a colon "
"and a blank.  Then the message and a new-line."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:75
msgid ""
"To be of most use, the argument string should include the name of the "
"function that incurred the error.  The error number is taken from the "
"external variable I<errno>, which is set when errors occur but not cleared "
"when successful calls are made."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:89
msgid ""
"The global error list I<sys_errlist>[] indexed by I<errno> can be used to "
"obtain the error message without the newline.  The largest message number "
"provided in the table is I<sys_nerr>-1.  Be careful when directly accessing "
"this list because new error values may not have been added to "
"I<sys_errlist>[].  The use of I<sys_errlist>[] is nowadays deprecated."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:111
msgid ""
"When a system call fails, it usually returns -1 and sets the variable "
"I<errno> to a value describing what went wrong.  (These values can be found "
"in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The function "
"B<perror>()  serves to translate this error code into human-readable form.  "
"Note that I<errno> is undefined after a successful library call: this call "
"may well change this variable, even though it succeeds, for example because "
"it internally used some other library function that failed.  Thus, if a "
"failing call is not immediately followed by a call to B<perror>(), the value "
"of I<errno> should be saved."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:124
msgid ""
"The function B<perror>()  and the external I<errno> (see B<errno>(3))  "
"conform to C89, C99, 4.3BSD, POSIX.1-2001.  The externals I<sys_nerr> and "
"I<sys_errlist> conform to BSD."
msgstr ""

#.  and only when _BSD_SOURCE is defined.
#.  When
#.  .B _GNU_SOURCE
#.  is defined, the symbols
#.  .I _sys_nerr
#.  and
#.  .I _sys_errlist
#.  are provided.
#. type: Plain text
#: build/C/man3/perror.3:139
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/perror.3:143
msgid "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"
msgstr ""

#. type: TH
#: build/C/man2/pipe.2:36
#, no-wrap
msgid "PIPE"
msgstr ""

#. type: TH
#: build/C/man2/pipe.2:36
#, no-wrap
msgid "2012-02-14"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:42 build/C/man2/read.2:41
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:44
#, no-wrap
msgid "B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:48
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant "
"definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:50
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:66
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:76
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""

#. type: TP
#: build/C/man2/pipe.2:76
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:84
msgid ""
"Set the B<O_NONBLOCK> file status flag on the two new open file "
"descriptions.  Using this flag saves extra calls to B<fcntl>(2)  to achieve "
"the same result."
msgstr ""

#. type: TP
#: build/C/man2/pipe.2:84
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:92
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:102
msgid "I<pipefd> is not valid."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:107
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:110
msgid "Too many file descriptors are in use by the process."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:118
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:121
msgid "B<pipe>(): POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:124
msgid "B<pipe2>()  is Linux-specific."
msgstr ""

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/pipe.2:140
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the descriptors "
"that it doesn't need for the pipe (see B<pipe>(7)).  The parent then writes "
"the string contained in the program's command-line argument to the pipe, and "
"the child reads this string a byte at a time from the pipe and echoes it on "
"standard output."
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:147
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:154
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:159
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:164
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:170
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:173
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:176
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:180
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:189
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/pipe.2:196
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<write>(2), B<popen>(3), "
"B<pipe>(7)"
msgstr ""

#. type: TH
#: build/C/man3/popen.3:38
#, no-wrap
msgid "POPEN"
msgstr ""

#. type: TH
#: build/C/man3/popen.3:38
#, no-wrap
msgid "2010-02-03"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:41
msgid "popen, pclose - pipe stream to or from a process"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:46
#, no-wrap
msgid "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:48
#, no-wrap
msgid "B<int pclose(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:58
msgid "B<popen>(), B<pclose>():"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:60
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:71
msgid ""
"The B<popen>()  function opens a process by creating a pipe, forking, and "
"invoking the shell.  Since a pipe is by definition unidirectional, the "
"I<type> argument may specify only reading or writing, not both; the "
"resulting stream is correspondingly read-only or write-only."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:95
msgid ""
"The I<command> argument is a pointer to a null-terminated string containing "
"a shell command line.  This command is passed to I</bin/sh> using the B<-c> "
"flag; interpretation, if any, is performed by the shell.  The I<type> "
"argument is a pointer to a null-terminated string which must contain either "
"the letter \\(aqr\\(aq for reading or the letter \\(aqw\\(aq for writing.  "
"Since glibc 2.9, this argument can additionally include the letter "
"\\(aqe\\(aq, which causes the close-on-exec flag (B<FD_CLOEXEC>)  to be set "
"on the underlying file descriptor; see the description of the B<O_CLOEXEC> "
"flag in B<open>(2)  for reasons why this may be useful."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:111
msgid ""
"The return value from B<popen>()  is a normal standard I/O stream in all "
"respects save that it must be closed with B<pclose>()  rather than "
"B<fclose>(3).  Writing to such a stream writes to the standard input of the "
"command; the command's standard output is the same as that of the process "
"that called B<popen>(), unless this is altered by the command itself.  "
"Conversely, reading from a \"popened\" stream reads the command's standard "
"output, and the command's standard input is the same as that of the process "
"that called B<popen>()."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:115
msgid "Note that output B<popen>()  streams are fully buffered by default."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:121
msgid ""
"The B<pclose>()  function waits for the associated process to terminate and "
"returns the exit status of the command as returned by B<wait4>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:129
msgid ""
"The B<popen>()  function returns NULL if the B<fork>(2)  or B<pipe>(2)  "
"calls fail, or if it cannot allocate memory."
msgstr ""

#.  These conditions actually give undefined results, so I commented
#.  them out.
#.  .I stream
#.  is not associated with a "popen()ed" command, if
#. .I stream
#.  already "pclose()d", or if
#. type: Plain text
#: build/C/man3/popen.3:141
msgid ""
"The B<pclose>()  function returns -1 if B<wait4>(2)  returns an error, or "
"some other error is detected."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:160
msgid ""
"The B<popen>()  function does not set I<errno> if memory allocation fails.  "
"If the underlying B<fork>(2)  or B<pipe>(2)  fails, I<errno> is set "
"appropriately.  If the I<type> argument is invalid, and this condition is "
"detected, I<errno> is set to B<EINVAL>."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:167
msgid ""
"If B<pclose>()  cannot obtain the child status, I<errno> is set to "
"B<ECHILD>."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:173
msgid "The \\(aqe\\(aq value for I<type> is a Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:186
msgid ""
"Since the standard input of a command opened for reading shares its seek "
"offset with the process that called B<popen>(), if the original process has "
"done a buffered read, the command's input position may not be as expected.  "
"Similarly, the output from a command opened for writing may become "
"intermingled with that of the original process.  The latter can be avoided "
"by calling B<fflush>(3)  before B<popen>()."
msgstr ""

#.  .SH HISTORY
#.  A
#.  .BR popen ()
#.  and a
#.  .BR pclose ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: build/C/man3/popen.3:196
msgid ""
"Failure to execute the shell is indistinguishable from the shell's failure "
"to execute command, or an immediate exit of the command.  The only hint is "
"an exit status of 127."
msgstr ""

#. type: Plain text
#: build/C/man3/popen.3:205
msgid ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"
msgstr ""

#. type: TH
#: build/C/man3/printf.3:34
#, no-wrap
msgid "PRINTF"
msgstr ""

#. type: TH
#: build/C/man3/printf.3:34 build/C/man3/puts.3:24 build/C/man3/scanf.3:50
#, no-wrap
msgid "2011-09-28"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:38
msgid ""
"printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - "
"formatted output conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:42
msgid "B<int printf(const char *>I<format>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:44
msgid "B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:46
msgid "B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:48
msgid ""
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char *>I<format>B<, "
"...);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:50
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:52
msgid "B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:54
msgid ""
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:56
msgid ""
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:59
msgid ""
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, va_list >I<ap>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:68
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:71
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:74 build/C/man3/scanf.3:83
msgid "or I<cc -std=c99>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:101
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>()  and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:110
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes "
"(including the terminating null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:134
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vsprintf>(), B<vsnprintf>()  "
"are equivalent to the functions B<printf>(), B<fprintf>(), B<sprintf>(), "
"B<snprintf>(), respectively, except that they are called with a I<va_list> "
"instead of a variable number of arguments.  These functions do not call the "
"I<va_end> macro.  Because they invoke the I<va_arg> macro, the value of "
"I<ap> is undefined after the call.  See B<stdarg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:141
msgid ""
"These eight functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:152
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:152
#, no-wrap
msgid "Return value"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:155
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (excluding the null byte used to end output to strings)."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:171
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the terminating null byte (\\(aq\\e0\\(aq)).  If "
"the output was truncated due to this limit then the return value is the "
"number of characters (excluding the terminating null byte)  which would have "
"been written to the final string if enough space had been available.  Thus, "
"a return value of I<size> or more means that the output was truncated.  (See "
"also below under NOTES.)"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:173
msgid "If an output error is encountered, a negative value is returned."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:173
#, no-wrap
msgid "Format of the format string"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:195
msgid ""
"The format string is a character string, beginning and ending in its initial "
"shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional "
"I<length modifier>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:208
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq and each conversion specifier asks for the "
"next argument (and it is an error if insufficiently many arguments are "
"given).  One can also specify explicitly which argument is taken, at each "
"place where an argument is required, by writing \"%m$\" instead of "
"\\(aq%\\(aq and \"*m$\" instead of \\(aq*\\(aq, where the decimal integer m "
"denotes the position in the argument list of the desired argument, indexed "
"starting from 1.  Thus,"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:212
#, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:216
msgid "and"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:220
#, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:236
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using "
"\\(aq$\\(aq is used, it must be used throughout for all conversions taking "
"an argument and all width and precision arguments, but it may be mixed with "
"\"%%\" formats which do not consume an argument.  There may be no gaps in "
"the numbers of arguments specified using \\(aq$\\(aq; for example, if "
"arguments 1 and 3 are specified, argument 2 must also be specified somewhere "
"in the format string."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:246
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on "
"the B<LC_NUMERIC> part of the locale.  The POSIX locale uses \\(aq.\\(aq as "
"radix character, and does not have a grouping character.  Thus,"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:250
#, no-wrap
msgid "    printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:255
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:255
#, no-wrap
msgid "The flag characters"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:257
msgid "The character % is followed by zero or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:257
#, no-wrap
msgid "B<#>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:291
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a "
"nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:291
#, no-wrap
msgid "B<\\&0>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:331
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the "
"B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior "
"is undefined."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:331
#, no-wrap
msgid "B<->"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:344
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  Except for B<n> conversions, the converted "
"value is padded on the right with blanks, rather than on the left with "
"blanks or zeros.  A B<-> overrides a B<\\&0> if both are given."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:344
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:348
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:348
#, no-wrap
msgid "B<+>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:356
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed "
"conversion.  By default a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:359
msgid ""
"The five flag characters above are defined in the C standard.  The SUSv2 "
"specifies one further flag character."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:359
#, no-wrap
msgid "B<\\(aq>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:376
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  Note that many versions of B<gcc>(1)  cannot "
"parse this option and will issue a warning.  SUSv2 does not include "
"I<%\\(aqF>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:378
msgid "glibc 2.2 adds one further flag character."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:378
#, no-wrap
msgid "B<I>"
msgstr ""

#.  outdigits keyword in locale file
#. type: Plain text
#: build/C/man3/printf.3:388
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:388
#, no-wrap
msgid "The field width"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:404
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one "
"may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken "
"as a \\(aq-\\(aq flag followed by a positive field width.  In no case does a "
"nonexistent or small field width cause truncation of a field; if the result "
"of a conversion is wider than the field width, the field is expanded to "
"contain the conversion result."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:404
#, no-wrap
msgid "The precision"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:440
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an "
"optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer m) to specify that the "
"precision is given in the next argument, or in the m-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, or the precision is negative, the precision is taken to be "
"zero.  This gives the minimum number of digits to appear for B<d>, B<i>, "
"B<o>, B<u>, B<x>, and B<X> conversions, the number of digits to appear after "
"the radix character for B<a>, B<A>, B<e>, B<E>, B<f>, and B<F> conversions, "
"the maximum number of significant digits for B<g> and B<G> conversions, or "
"the maximum number of characters to be printed from a string for B<s> and "
"B<S> conversions."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:440
#, no-wrap
msgid "The length modifier"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:450
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:450 build/C/man3/scanf.3:291
#, no-wrap
msgid "B<hh>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:461
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned "
"char> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<signed char> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:461 build/C/man3/scanf.3:281
#, no-wrap
msgid "B<h>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:472
msgid ""
"A following integer conversion corresponds to a I<short int> or I<unsigned "
"short int> argument, or a following B<n> conversion corresponds to a pointer "
"to a I<short int> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:472 build/C/man3/scanf.3:308
#, no-wrap
msgid "B<l>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:491
msgid ""
"(ell) A following integer conversion corresponds to a I<long int> or "
"I<unsigned long int> argument, or a following B<n> conversion corresponds to "
"a pointer to a I<long int> argument, or a following B<c> conversion "
"corresponds to a I<wint_t> argument, or a following B<s> conversion "
"corresponds to a pointer to I<wchar_t> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:491
#, no-wrap
msgid "B<ll>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:503
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long int> "
"or I<unsigned long long int> argument, or a following B<n> conversion "
"corresponds to a pointer to a I<long long int> argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:503 build/C/man3/scanf.3:335
#, no-wrap
msgid "B<L>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:519
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:519 build/C/man3/scanf.3:351
#, no-wrap
msgid "B<q>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:525
msgid ""
"(\"quad\". 4.4BSD and Linux libc5 only.  Don't use.)  This is a synonym for "
"B<ll>."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:525 build/C/man3/scanf.3:299
#, no-wrap
msgid "B<j>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:532
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t> "
"argument."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:532 build/C/man3/scanf.3:363
#, no-wrap
msgid "B<z>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:543
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument.  (Linux libc5 has B<Z> with this meaning.  Don't use it.)"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:543 build/C/man3/scanf.3:356
#, no-wrap
msgid "B<t>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:548
msgid "A following integer conversion corresponds to a I<ptrdiff_t> argument."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:577
msgid ""
"The SUSv2 only knows about the length modifiers B<h> (in B<hd>, B<hi>, "
"B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> (in B<ld>, B<li>, B<lo>, B<lx>, B<lX>, "
"B<ln>, B<lc>, B<ls>)  and B<L> (in B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""

#. type: SS
#: build/C/man3/printf.3:577
#, no-wrap
msgid "The conversion specifier"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:580
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:580
#, no-wrap
msgid "B<d>, B<i>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:590
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision, "
"if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros.  "
"The default precision is 1.  When 0 is printed with an explicit precision 0, "
"the output is empty."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:590
#, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:617
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned "
"decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it "
"is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:617
#, no-wrap
msgid "B<e>, B<E>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:622
msgid "The I<double> argument is rounded and converted in the style"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:637
msgid ""
"[-]dB<\\&.>dddB<e>\\*(Pmdd where there is one digit before the decimal-point "
"character and the number of digits after it is equal to the precision; if "
"the precision is missing, it is taken as 6; if the precision is zero, no "
"decimal-point character appears.  An B<E> conversion uses the letter B<E> "
"(rather than B<e>)  to introduce the exponent.  The exponent always contains "
"at least two digits; if the value is zero, the exponent is 00."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:637
#, no-wrap
msgid "B<f>, B<F>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:648
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no "
"decimal-point character appears.  If a decimal point appears, at least one "
"digit appears before it."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:659
msgid ""
"(The SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  The C99 "
"standard specifies \"[-]inf\" or \"[-]infinity\" for infinity, and a string "
"starting with \"nan\" for NaN, in the case of B<f> conversion, and "
"\"[-]INF\" or \"[-]INFINITY\" or \"NAN*\" in the case of B<F> conversion.)"
msgstr ""

#. type: TP
#: build/C/man3/printf.3:659
#, no-wrap
msgid "B<g>, B<G>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:684
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal "
"point appears only if it is followed by at least one digit."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:684
#, no-wrap
msgid "B<a>, B<A>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:708
msgid ""
"(C99; not in SUSv2) For B<a> conversion, the I<double> argument is converted "
"to hexadecimal notation (using the letters abcdef)  in the style "
"[-]B<0x>hB<\\&.>hhhhB<p>\\*(Pmd; for B<A> conversion the prefix B<0X>, the "
"letters ABCDEF, and the exponent separator B<P> is used.  There is one "
"hexadecimal digit before the decimal point, and the number of digits after "
"it is equal to the precision.  The default precision suffices for an exact "
"representation of the value if an exact representation in base 2 exists and "
"otherwise is sufficiently large to distinguish values of type I<double>.  "
"The digit before the decimal point is unspecified for nonnormalized numbers, "
"and nonzero but otherwise unspecified for normalized numbers."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:708 build/C/man3/scanf.3:456 build/C/man3/wprintf.3:132
#, no-wrap
msgid "B<c>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:726
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to "
"a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:726 build/C/man3/scanf.3:448 build/C/man3/wprintf.3:146
#, no-wrap
msgid "B<s>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:741
msgid ""
"If no B<l> modifier is present: The I<const char *> argument is expected to "
"be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more "
"than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:768
msgid ""
"If an B<l> modifier is present: The I<const wchar_t *> argument is expected "
"to be a pointer to an array of wide characters.  Wide characters from the "
"array are converted to multibyte characters (each by a call to the "
"B<wcrtomb>(3)  function, with a conversion state starting in the initial "
"state before the first wide character), up to and including a terminating "
"null wide character.  The resulting multibyte characters are written up to "
"(but not including) the terminating null byte.  If a precision is specified, "
"no more bytes than the number specified are written, but no partial "
"multibyte characters are written.  Note that the precision determines the "
"number of I<bytes> written, not the number of I<wide characters> or I<screen "
"positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:768
#, no-wrap
msgid "B<C>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:774
msgid "(Not in C99, but in SUSv2.)  Synonym for B<lc>.  Don't use."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:774
#, no-wrap
msgid "B<S>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:780
msgid "(Not in C99, but in SUSv2.)  Synonym for B<ls>.  Don't use."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:780 build/C/man3/scanf.3:500
#, no-wrap
msgid "B<p>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:788
msgid ""
"The I<void *> pointer argument is printed in hexadecimal (as if by B<%#x> or "
"B<%#lx>)."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:788 build/C/man3/scanf.3:508
#, no-wrap
msgid "B<n>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:795
msgid ""
"The number of characters written so far is stored into the integer indicated "
"by the I<int *> (or variant) pointer argument.  No argument is converted."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:795
#, no-wrap
msgid "B<m>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:801
msgid ""
"(Glibc extension.)  Print output of I<strerror(errno)>.  No argument is "
"required."
msgstr ""

#. type: TP
#: build/C/man3/printf.3:801 build/C/man3/scanf.3:374
#, no-wrap
msgid "B<%>"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:807
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:822
msgid ""
"The B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"and B<vsprintf>()  functions conform to C89 and C99.  The B<snprintf>()  and "
"B<vsnprintf>()  functions conform to C99."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:835
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an "
"unspecified return value less than 1, while C99 allows I<str> to be NULL in "
"this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:849
msgid ""
"Linux libc4 knows about the five C standard flags.  It knows about the "
"length modifiers B<h>, B<l>, B<L>, and the conversions B<c>, B<d>, B<e>, "
"B<E>, B<f>, B<F>, B<g>, B<G>, B<i>, B<n>, B<o>, B<p>, B<s>, B<u>, B<x>, and "
"B<X>, where B<F> is a synonym for B<f>.  Additionally, it accepts B<D>, "
"B<O>, and B<U> as synonyms for B<ld>, B<lo>, and B<lu>.  (This is bad, and "
"caused serious bugs later, when support for B<%D> disappeared.)  No "
"locale-dependent radix character, no thousands' separator, no NaN or "
"infinity, no \"%m$\" and \"*m$\"."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:860
msgid ""
"Linux libc5 knows about the five C standard flags and the \\(aq flag, "
"locale, \"%m$\" and \"*m$\".  It knows about the length modifiers B<h>, "
"B<l>, B<L>, B<Z>, and B<q>, but accepts B<L> and B<q> both for I<long "
"double> and for I<long long int> (this is a bug).  It no longer recognizes "
"B<F>, B<D>, B<O>, and B<U>, but adds the conversion character B<m>, which "
"outputs I<strerror(errno)>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:862
msgid "glibc 2.0 adds conversion characters B<C> and B<S>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:865
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:868
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:870
msgid "Some programs imprudently rely on code such as the following"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:872
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
#: build/C/man3/printf.3:888
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
#: build/C/man3/printf.3:930
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()  "
"conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6 they would return -1 when the output "
"was truncated."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:947
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:960
msgid ""
"Linux libc4.[45] does not have a B<snprintf>(), but provides a libbsd that "
"contains an B<snprintf>()  equivalent to B<sprintf>(), that is, one that "
"ignores the I<size> argument.  Thus, the use of B<snprintf>()  with early "
"libc4 leads to serious security problems."
msgstr ""

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#: build/C/man3/printf.3:974
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating "
"a security hole."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:977
msgid "To print \\*(Pi to five decimal places:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:983
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:992
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:998
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1004
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1010
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1017
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1021
#, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1025
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1028
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1033
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1041
#, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n;\n"
"    int size = 100;     /* Guess we need no more than 100 bytes. */\n"
"    char *p, *np;\n"
"    va_list ap;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1044
#, no-wrap
msgid ""
"    if ((p = malloc(size)) == NULL)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1046
#, no-wrap
msgid "    while (1) {\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1048
#, no-wrap
msgid "        /* Try to print in the allocated space. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1052
#, no-wrap
msgid ""
"        va_start(ap, fmt);\n"
"        n = vsnprintf(p, size, fmt, ap);\n"
"        va_end(ap);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1054
#, no-wrap
msgid "        /* If that worked, return the string. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1057
#, no-wrap
msgid ""
"        if (n E<gt> -1 && n E<lt> size)\n"
"            return p;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1059
#, no-wrap
msgid "        /* Else try again with more space. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1064
#, no-wrap
msgid ""
"        if (n E<gt> -1)    /* glibc 2.1 */\n"
"            size = n+1; /* precisely what is needed */\n"
"        else           /* glibc 2.0 */\n"
"            size *= 2;  /* twice the old size */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1073
#, no-wrap
msgid ""
"        if ((np = realloc (p, size)) == NULL) {\n"
"            free(p);\n"
"            return NULL;\n"
"        } else {\n"
"            p = np;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/printf.3:1082
msgid ""
"B<printf>(1), B<asprintf>(3), B<dprintf>(3), B<scanf>(3), B<setlocale>(3), "
"B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr ""

#. type: TH
#: build/C/man3/puts.3:24
#, no-wrap
msgid "PUTS"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:27
msgid "fputc, fputs, putc, putchar, puts - output of characters and strings"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:32
#, no-wrap
msgid "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:34
#, no-wrap
msgid "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:36
#, no-wrap
msgid "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:38
#, no-wrap
msgid "B<int putchar(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:40
#, no-wrap
msgid "B<int puts(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:49
msgid ""
"B<fputc>()  writes the character I<c>, cast to an I<unsigned char>, to "
"I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:56
msgid ""
"B<fputs>()  writes the string I<s> to I<stream>, without its terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:63
msgid ""
"B<putc>()  is equivalent to B<fputc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:67
msgid "B<putchar(>I<c>B<);> is equivalent to B<putc(>I<c>B<,>I<stdout>B<).>"
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:74
msgid "B<puts>()  writes the string I<s> and a trailing newline to I<stdout>."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:79
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other output functions from the I<stdio> library for the same "
"output stream."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:94
msgid ""
"B<fputc>(), B<putc>()  and B<putchar>()  return the character written as an "
"I<unsigned char> cast to an I<int> or B<EOF> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:101
msgid ""
"B<puts>()  and B<fputs>()  return a nonnegative number on success, or B<EOF> "
"on error."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:110
msgid ""
"It is not advisable to mix calls to output functions from the I<stdio> "
"library with low-level calls to B<write>(2)  for the file descriptor "
"associated with the same output stream; the results will be undefined and "
"very probably not what you want."
msgstr ""

#. type: Plain text
#: build/C/man3/puts.3:121
msgid ""
"B<write>(2), B<ferror>(3), B<fopen>(3), B<fputwc>(3), B<fputws>(3), "
"B<fseek>(3), B<fwrite>(3), B<gets>(3), B<putwchar>(3), B<scanf>(3), "
"B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man2/read.2:35
#, no-wrap
msgid "READ"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:38
msgid "read - read from a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:43
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:52
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:63
msgid ""
"If I<count> is zero, B<read>()  returns zero and has no other results.  If "
"I<count> is greater than B<SSIZE_MAX>, the result is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:77
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error "
"if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  On error, -1 is returned, and I<errno> is set appropriately.  In "
"this case it is left unspecified whether the file position (if any) changes."
msgstr ""

#. type: TP
#: build/C/man2/read.2:78 build/C/man3/scanf.3:546 build/C/man2/write.2:108
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:85
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block."
msgstr ""

#. type: TP
#: build/C/man2/read.2:85 build/C/man2/write.2:115
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/read.2:96
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either error "
"to be returned for this case, and does not require these constants to have "
"the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:100
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:104 build/C/man2/write.2:139
msgid "I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:108
msgid ""
"The call was interrupted by a signal before any data was read; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:119
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the current file offset is not "
"suitably aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:129
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:140
msgid ""
"I/O error.  This will happen for example when the process is in a background "
"process group, tries to read from its controlling tty, and either it is "
"ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may "
"also occur when there is a low-level I/O error while reading from a disk or "
"tape."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:144
msgid "I<fd> refers to a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:155
msgid ""
"Other errors may occur, depending on the object connected to I<fd>.  POSIX "
"allows a B<read>()  that is interrupted after reading some data to return -1 "
"(with I<errno> set to B<EINTR>)  or to return the number of bytes already "
"read."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:169
msgid ""
"On NFS file systems, reading small amounts of data will only update the "
"timestamp the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"st_atime (last file access time)  updates to the server and client side "
"reads satisfied from the client's cache will not cause st_atime updates on "
"the server as there are no server side reads.  UNIX semantics can be "
"obtained by disabling client side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:178
msgid ""
"Many file systems and disks were considered to be fast enough that the "
"implementation of B<O_NONBLOCK> was deemed unnecessary.  So, B<O_NONBLOCK> "
"may not be available on files and/or disks."
msgstr ""

#. type: Plain text
#: build/C/man2/read.2:190
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""

#. type: TH
#: build/C/man2/readlink.2:41
#, no-wrap
msgid "READLINK"
msgstr ""

#. type: TH
#: build/C/man2/readlink.2:41
#, no-wrap
msgid "2011-09-20"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:44
msgid "readlink - read value of a symbolic link"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:48
msgid ""
"B<ssize_t readlink(const char *>I<path>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:56
msgid "B<readlink>():"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:59 build/C/man2/symlink.2:50
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:75
msgid ""
"B<readlink>()  places the contents of the symbolic link I<path> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will truncate the contents (to a length of "
"I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:83
msgid ""
"On success, B<readlink>()  returns the number of bytes placed in I<buf>.  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:89
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:93
msgid "I<buf> extends outside the process's allocated address space."
msgstr ""

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: build/C/man2/readlink.2:102
msgid "I<bufsiz> is not positive."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:105
msgid "The named file is not a symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:108
msgid "An I/O error occurred while reading from the file system."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:111
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:114
msgid "A pathname, or a component of a pathname, was too long."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:117
msgid "The named file does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:123
msgid "A component of the path prefix is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:128
msgid "4.4BSD (B<readlink>()  first appeared in 4.2BSD), POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:136
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:155
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  should be "
"checked to make sure that the size of the symbolic link did not increase "
"between the calls.  Dynamically allocating the buffer for B<readlink>()  "
"also addresses a common portability problem when using I<PATH_MAX> for the "
"buffer size, as this constant is not guaranteed to be defined per POSIX if "
"the system does not have such limit."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:161
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(), making sure there's "
"no race condition between the calls."
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:168
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:175
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *linkname;\n"
"    ssize_t r;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:180
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:185
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:191
#, no-wrap
msgid ""
"    linkname = malloc(sb.st_size + 1);\n"
"    if (linkname == NULL) {\n"
"        fprintf(stderr, \"insufficient memory\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:193
#, no-wrap
msgid "    r = readlink(argv[1], linkname, sb.st_size + 1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:198
#, no-wrap
msgid ""
"    if (r E<lt> 0) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:204
#, no-wrap
msgid ""
"    if (r E<gt> sb.st_size) {\n"
"        fprintf(stderr, \"symlink increased in size \"\n"
"                        \"between lstat() and readlink()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:206
#, no-wrap
msgid "    linkname[sb.st_size] = \\(aq\\e0\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:208
#, no-wrap
msgid ""
"    printf(\"\\(aq%s\\(aq points to \\(aq%s\\(aq\\en\", argv[1], "
"linkname);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readlink.2:219
msgid ""
"B<readlink>(1), B<lstat>(2), B<readlinkat>(2), B<stat>(2), B<symlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/readv.2:30
#, no-wrap
msgid "READV"
msgstr ""

#. type: TH
#: build/C/man2/readv.2:30
#, no-wrap
msgid "2010-11-17"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:33
msgid "readv, writev, preadv, pwritev - read or write data into multiple buffers"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:36
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:38
#, no-wrap
msgid ""
"B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:40
#, no-wrap
msgid ""
"B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:43
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:46
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int "
">I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:56
msgid "B<preadv>(), B<pwritev>(): _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:66
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated "
"with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:76
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather "
"output\")."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:85
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:93
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:101
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple "
"buffers are filled."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:107
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:126
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov>[0] before proceeding to I<iov>[1], and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be "
"filled.)  Similarly, B<writev>()  writes out the entire contents of "
"I<iov>[0] before proceeding to I<iov>[1], and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:144
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the "
"data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)  "
"for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring "
"to the same open file description (see B<open>(2))."
msgstr ""

#. type: SS
#: build/C/man2/readv.2:144
#, no-wrap
msgid "preadv() and pwritev()"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:157
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:170
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and "
"B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:175
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:186
msgid ""
"On success, B<readv>()  and B<preadv>()  return the number of bytes read; "
"B<writev>()  and B<pwritev>()  return the number of bytes written.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:198
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>()  and B<pwritev>()  can also fail for the same reasons as "
"B<lseek>(2).  Additionally, the following error is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:207
msgid ""
"The sum of the I<iov_len> values overflows an I<ssize_t> value.  Or, the "
"vector count I<iovcnt> is less than zero or greater than the permitted "
"maximum."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:212
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""

#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: build/C/man2/readv.2:220
msgid ""
"B<readv>(), B<writev>(): 4.4BSD (these system calls first appeared in "
"4.2BSD), POSIX.1-2001.  Linux libc5 used I<size_t> as the type of the "
"I<iovcnt> argument, and I<int> as the return type."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:224
msgid "B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr ""

#. type: SS
#: build/C/man2/readv.2:225
#, no-wrap
msgid "Linux Notes"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:256
msgid ""
"POSIX.1-2001 allows an implementation to place a limit on the number of "
"items that can be passed in I<iov>.  An implementation can advertise its "
"limit by defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the "
"return value from I<sysconf(_SC_IOV_MAX)>.  On Linux, the limit advertised "
"by these mechanisms is 1024, which is the true kernel limit.  However, the "
"glibc wrapper functions do some extra work if they detect that the "
"underlying kernel system call failed because this limit was exceeded.  In "
"the case of B<readv>()  the wrapper function allocates a temporary buffer "
"large enough for all of the items specified by I<iov>, passes that buffer in "
"a call to B<read>(2), copies data from the buffer to the locations specified "
"by the I<iov_base> fields of the elements of I<iov>, and then frees the "
"buffer.  The wrapper function for B<writev>()  performs the analogous task "
"using a temporary buffer and a call to B<write>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:263
msgid ""
"It is not advisable to mix calls to B<readv>()  or B<writev>(), which "
"operate on file descriptors, with the functions from the stdio library; the "
"results will be undefined and probably not what you want."
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:266
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:273
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:278
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:280
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readv.2:285
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr ""

#. type: TH
#: build/C/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr ""

#. type: TH
#: build/C/man3/remove.3:31
#, no-wrap
msgid "2008-12-03"
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the file system.  It calls B<unlink>(2)  "
"for files, and B<rmdir>(2)  for directories."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:57
msgid "If the name referred to a symbolic link, the link is removed."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:72
msgid "C89, C99, 4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:78
msgid ""
"Under libc4 and libc5, B<remove>()  was an alias for B<unlink>(2)  (and "
"hence would not remove directories)."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:81 build/C/man2/unlink.2:148
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""

#. type: Plain text
#: build/C/man3/remove.3:91
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/rename.2:32
#, no-wrap
msgid "RENAME"
msgstr ""

#. type: TH
#: build/C/man2/rename.2:32
#, no-wrap
msgid "2009-03-30"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:35
msgid "rename - change the name or location of a file"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:39
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:48
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any "
"other hard links to the file (as created using B<link>(2))  are unaffected.  "
"Open file descriptors for I<oldpath> are also unaffected."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:56
msgid ""
"If I<newpath> already exists it will be atomically replaced (subject to a "
"few conditions; see ERRORS below), so that there is no point at which "
"another process attempting to access I<newpath> will find it missing."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:64
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:72
msgid ""
"If I<newpath> exists but the operation fails for some reason B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:78
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:85
msgid ""
"However, when overwriting there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:91
msgid ""
"If I<oldpath> refers to a symbolic link the link is renamed; if I<newpath> "
"refers to a symbolic link the link will be overwritten."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:116
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""

#. type: TP
#: build/C/man2/rename.2:116 build/C/man2/rmdir.2:55 build/C/man2/unlink.2:71
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:133
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such "
"cases\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:140
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:146
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:157
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:173
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:190
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:190
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:194
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than "
"\".\" and \"..\"."
msgstr ""

#. type: TP
#: build/C/man2/rename.2:194 build/C/man2/unlink.2:126
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:218
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and "
"the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of "
"the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the file system containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:229
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted file system.  (Linux "
"permits a file system to be mounted at multiple points, but B<rename>()  "
"does not work across different mount points, even if the same file system is "
"mounted on both.)"
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:231
msgid "4.3BSD, C89, C99, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:242
msgid ""
"On NFS file systems, you can not assume that if the operation failed the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up "
"again causes a failure.  The application is expected to deal with this.  See "
"B<link>(2)  for a similar problem."
msgstr ""

#. type: Plain text
#: build/C/man2/rename.2:250
msgid ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<renameat>(2), B<symlink>(2), "
"B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr ""

#. type: TH
#: build/C/man2/rmdir.2:30
#, no-wrap
msgid "2008-05-08"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""

#. type: TP
#: build/C/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:107
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has "
"I<..> as its final component.  POSIX.1-2001 also allows B<EEXIST> for this "
"condition."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:118
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:123
msgid ""
"The file system containing I<pathname> does not support the removal of "
"directories."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:127
msgid "I<pathname> refers to a directory on a read-only file system."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:132
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""

#. type: Plain text
#: build/C/man2/rmdir.2:140
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""

#. type: TH
#: build/C/man3/scanf.3:50
#, no-wrap
msgid "SCANF"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:53
msgid "scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:60
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:62
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:66
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:77
msgid "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:80
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:102
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the "
"corresponding conversion specification."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:113
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:125
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:143
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers "
"(see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument list "
"from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:157
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:159
msgid "A directive is one of the following:"
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:159 build/C/man3/scanf.3:165 build/C/man3/scanf.3:169 build/C/man3/scanf.3:188 build/C/man3/scanf.3:199 build/C/man3/scanf.3:217 build/C/man3/scanf.3:229 build/C/man3/scanf.3:243
#, no-wrap
msgid "\\(bu"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:165
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including "
"none, in the input."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:169
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:180
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails\\(emthis is a I<matching "
"failure>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:188
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:199
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:217
msgid ""
"An optional \\(aqa\\(aq character.  This is used with string conversions, "
"and relieves the caller of the need to allocate a corresponding buffer to "
"hold the input: instead, B<scanf>()  allocates a buffer of sufficient size, "
"and assigns the address of this buffer to the corresponding I<pointer> "
"argument, which should be a pointer to a I<char *> variable (this variable "
"does not need to be initialized before the call).  The caller should "
"subsequently B<free>(3)  this buffer when it is no longer required.  This is "
"a GNU extension; C99 employs the \\(aqa\\(aq character as a conversion "
"specifier (and it can also be used as such in the GNU implementation)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:229
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and "
"these discarded characters don't count toward the maximum field width.  "
"String input conversions store a terminating null byte (\\(aq\\e0\\(aq)  to "
"mark the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:243
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier "
"is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long int> rather than a "
"pointer to an I<int>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:248
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:277
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string "
"containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If "
"I<format> contains \\(aq%\\(aq specifications then these correspond in order "
"with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form (which "
"is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer that "
"specifies that the converted input should be placed in the location referred "
"to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""

#. type: SS
#: build/C/man3/scanf.3:277
#, no-wrap
msgid "Conversions"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:281
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:291
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short int> or "
"I<unsigned short int> (rather than I<int>)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:299
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:308
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#: build/C/man3/scanf.3:335
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long int> or "
"I<unsigned long int> (rather than I<int>), or that the conversion will be "
"one of B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> "
"(rather than I<float>).  Specifying two B<l> characters is equivalent to "
"B<L>.  If used with B<%c> or B<%s> the corresponding parameter is considered "
"as a pointer to a wide character or wide-character string respectively."
msgstr ""

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#: build/C/man3/scanf.3:351
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:356
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:363
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:370
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:374
msgid "The following I<conversion specifiers> are available:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:383
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not "
"occur."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:383
#, no-wrap
msgid "B<d>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:388
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:388
#, no-wrap
msgid "B<D>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:397
msgid ""
"Equivalent to I<ld>; this exists only for backward compatibility.  (Note: "
"thus only in libc4.  In libc5 and glibc the B<%D> is silently ignored, "
"causing old programs to fail mysteriously.)"
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:397
#, no-wrap
msgid "B<i>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:409
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in "
"base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:409
#, no-wrap
msgid "B<o>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:413
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:413
#, no-wrap
msgid "B<u>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:418
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:423
msgid ""
"Matches an unsigned hexadecimal integer; the next pointer must be a pointer "
"to I<unsigned int>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:423
#, no-wrap
msgid "B<X>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:427
msgid "Equivalent to B<x>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:427
#, no-wrap
msgid "B<f>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:432
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be "
"a pointer to I<float>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:432
#, no-wrap
msgid "B<e>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:436 build/C/man3/scanf.3:440 build/C/man3/scanf.3:444
msgid "Equivalent to B<f>."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:436
#, no-wrap
msgid "B<g>"
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:440
#, no-wrap
msgid "B<E>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:448
msgid "(C99) Equivalent to B<f>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:456
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a "
"pointer to character array that is long enough to hold the input sequence "
"and the terminating null byte (\\(aq\\e0\\(aq), which is added "
"automatically.  The input string stops at white space or at the maximum "
"field width, whichever occurs first."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:467
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and "
"there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:467
#, no-wrap
msgid "B<\\&[>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:500
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted "
"characters; the next pointer must be a pointer to I<char>, and there must be "
"enough room for all the characters in the string, plus a terminating null "
"byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<^>).  To include a "
"close bracket in the set, make it the first character after the open bracket "
"or the circumflex; any other position will end the set.  The hyphen "
"character B<-> is also special; when placed between two other characters, it "
"adds all intervening characters to the set.  To include a hyphen, make it "
"the last character before the final close bracket.  For instance, "
"B<[^]0-9-]> means the set \"everything except close bracket, zero through "
"nine, and hyphen\".  The string ends with the appearance of a character not "
"in the (or, with a circumflex, in) set or when the field width runs out."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:508
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:528
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion, although it can be suppressed with "
"the B<*> assignment-suppression character.  The C standard says: \"Execution "
"of a B<%n> directive does not increment the assignment count returned at the "
"completion of execution\" but the Corrigendum seems to contradict this.  "
"Probably it is wise not to make any assumptions on the effect of B<%n> "
"conversions on the return value."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:533
msgid ""
"These functions return the number of input items successfully matched and "
"assigned, which can be fewer than provided for, or even zero in the event of "
"an early matching failure."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:545
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set indicate the "
"error."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:551
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read "
"operation would block."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:556
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for "
"reading."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:559
msgid "Input byte sequence does not form a valid character."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:563
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:568
msgid "Not enough arguments; or I<format> is NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:571
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/scanf.3:571
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:575
msgid ""
"The result of an integer conversion would exceed the size that can be stored "
"in the corresponding integer type."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:585
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:595
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:606
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc "
"(glibc-1.08)> for a more concise description."
msgstr ""

#.  This feature seems to be present at least as far back as glibc 2.0.
#. type: Plain text
#: build/C/man3/scanf.3:624
msgid ""
"The GNU C library supports a nonstandard extension that causes the library "
"to dynamically allocate a string of sufficient size for input strings for "
"the B<%s> and B<%a[>I<range>B<]> conversion specifiers.  To make use of this "
"feature, specify B<a> as a length modifier (thus B<%as> or "
"B<%a[>I<range>B<]>).  The caller must B<free>(3)  the returned string, as in "
"the following example:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:629
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:640
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%a[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:648
msgid ""
"As shown in the above example, it is only necessary to call B<free>(3)  if "
"the B<scanf>()  call successfully read a string."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:660
msgid ""
"The B<a> modifier is not available if the program is compiled with I<gcc "
"-std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:669
msgid ""
"Since version 2.7, glibc also provides the B<m> modifier for the same "
"purpose as the B<a> modifier.  The B<m> modifier has the following "
"advantages:"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:674
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:680
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)"
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:682
msgid "It is specified in the upcoming revision of the POSIX.1 standard."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:695
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:711
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by "
"ANSI C do not make sense (e.g.  B<%Ld>).  While they may have a well-defined "
"behavior on Linux, this need not to be so on other architectures.  Therefore "
"it usually is better to use modifiers that are not defined by ANSI C at all, "
"that is, use B<q> instead of B<L> in combination with B<d>, B<i>, B<o>, "
"B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:717
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""

#. type: Plain text
#: build/C/man3/scanf.3:723
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr ""

#. type: TH
#: build/C/man3/setbuf.3:46
#, no-wrap
msgid "SETBUF"
msgstr ""

#. type: TH
#: build/C/man3/setbuf.3:46
#, no-wrap
msgid "2008-06-26"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:49
msgid "setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:54
#, no-wrap
msgid "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:56
#, no-wrap
msgid "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:58
#, no-wrap
msgid "B<void setlinebuf(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:61
#, no-wrap
msgid ""
"B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:71
msgid "B<setbuffer>(), B<setlinebuf>(): _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:94
msgid ""
"The three types of buffering available are unbuffered, block buffered, and "
"line buffered.  When an output stream is unbuffered, information appears on "
"the destination file or terminal as soon as written; when it is block "
"buffered many characters are saved up and written as a block; when it is "
"line buffered characters are saved up until a newline is output or input is "
"read from any stream attached to a terminal device (typically I<stdin>).  "
"The function B<fflush>(3)  may be used to force the block out early.  (See "
"B<fclose>(3).)  Normally all files are block buffered.  When the first I/O "
"operation occurs on a file, B<malloc>(3)  is called, and a buffer is "
"obtained.  If a stream refers to a terminal (as I<stdout> normally does) it "
"is line buffered.  The standard error stream I<stderr> is always unbuffered "
"by default."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:101
msgid ""
"The B<setvbuf>()  function may be used on any open stream to change its "
"buffer.  The I<mode> argument must be one of the following three macros:"
msgstr ""

#. type: TP
#: build/C/man3/setbuf.3:102
#, no-wrap
msgid "B<_IONBF>"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:105
msgid "unbuffered"
msgstr ""

#. type: TP
#: build/C/man3/setbuf.3:105
#, no-wrap
msgid "B<_IOLBF>"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:108
msgid "line buffered"
msgstr ""

#. type: TP
#: build/C/man3/setbuf.3:108
#, no-wrap
msgid "B<_IOFBF>"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:111
msgid "fully buffered"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:127
msgid ""
"Except for unbuffered files, the I<buf> argument should point to a buffer at "
"least I<size> bytes long; this buffer will be used instead of the current "
"buffer.  If the argument I<buf> is NULL, only the mode is affected; a new "
"buffer will be allocated on the next read or write operation.  The "
"B<setvbuf>()  function may only be used after opening a stream and before "
"any other operations have been performed on it."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:133
msgid ""
"The other three calls are, in effect, simply aliases for calls to "
"B<setvbuf>().  The B<setbuf>()  function is exactly equivalent to the call"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:136
msgid "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:146
msgid ""
"The B<setbuffer>()  function is the same, except that the size of the buffer "
"is up to the caller, rather than being determined by the default B<BUFSIZ>.  "
"The B<setlinebuf>()  function is exactly equivalent to the call:"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:149
msgid "setvbuf(stream, (char *) NULL, _IOLBF, 0);"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:160
msgid ""
"The function B<setvbuf>()  returns 0 on success.  It returns nonzero on "
"failure (I<mode> is invalid or the request cannot be honored).  It may set "
"I<errno> on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:162
msgid "The other functions do not return a value."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:168
msgid "The B<setbuf>()  and B<setvbuf>()  functions conform to C89 and C99."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:178
msgid ""
"The B<setbuffer>()  and B<setlinebuf>()  functions are not portable to "
"versions of BSD before 4.2BSD, and are available under Linux since libc "
"4.5.21.  On 4.2BSD and 4.3BSD systems, B<setbuf>()  always uses a suboptimal "
"buffer size and should be avoided."
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:185
msgid ""
"You must make sure that the space that I<buf> points to still exists by the "
"time I<stream> is closed, which also happens at program termination.  For "
"example, the following is invalid:"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:188
#, no-wrap
msgid "#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:197
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setbuf.3:205
msgid ""
"B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), B<malloc>(3), "
"B<printf>(3), B<puts>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stdin.3:9
#, no-wrap
msgid "STDIN"
msgstr ""

#. type: TH
#: build/C/man3/stdin.3:9 build/C/man3/tmpfile.3:29
#, no-wrap
msgid "2008-07-14"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:12
msgid "stdin, stdout, stderr - standard I/O streams"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:19
#, no-wrap
msgid ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:31
msgid ""
"Under normal circumstances every UNIX program has three streams opened for "
"it when it starts up, one for input, one for output, and one for printing "
"diagnostic or error messages.  These are typically attached to the user's "
"terminal (see B<tty>(4)  but might instead refer to files or other devices, "
"depending on what the parent process chose to set up.  (See also the "
"\"Redirection\" section of B<sh>(1).)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:41
msgid ""
"The input stream is referred to as \"standard input\"; the output stream is "
"referred to as \"standard output\"; and the error stream is referred to as "
"\"standard error\".  These terms are abbreviated to form the symbols used to "
"refer to these files, namely I<stdin>, I<stdout>, and I<stderr>."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:50
msgid ""
"Each of these symbols is a B<stdio>(3)  macro of type pointer to I<FILE>, "
"and can be used with functions like B<fprintf>(3)  or B<fread>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:59
msgid ""
"Since I<FILE>s are a buffering wrapper around UNIX file descriptors, the "
"same underlying files may also be accessed using the raw UNIX file "
"interface, that is, the functions like B<read>(2)  and B<lseek>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:78
msgid ""
"On program startup, the integer file descriptors associated with the streams "
"I<stdin>, I<stdout>, and I<stderr> are 0, 1, and 2, respectively.  The "
"preprocessor symbols B<STDIN_FILENO>, B<STDOUT_FILENO>, and B<STDERR_FILENO> "
"are defined with these values in I<E<lt>unistd.hE<gt>>.  (Applying "
"B<freopen>(3)  to one of these streams can change the file descriptor number "
"associated with the stream.)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:91
msgid ""
"Note that mixing use of I<FILE>s and raw file descriptors can produce "
"unexpected results and should generally be avoided.  (For the masochistic "
"among you: POSIX.1, section 8.2.3, describes in detail how this interaction "
"is supposed to work.)  A general rule is that file descriptors are handled "
"in the kernel, while stdio is just a library.  This means for example, that "
"after an B<exec>(3), the child inherits all open file descriptors, but all "
"old streams have become inaccessible."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:109
msgid ""
"Since the symbols I<stdin>, I<stdout>, and I<stderr> are specified to be "
"macros, assigning to them is nonportable.  The standard streams can be made "
"to refer to different files with help of the library function B<freopen>(3), "
"specially introduced to make it possible to reassign I<stdin>, I<stdout>, "
"and I<stderr>.  The standard streams are closed by a call to B<exit>(3)  and "
"by normal program termination."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:118
msgid ""
"The I<stdin>, I<stdout>, and I<stderr> macros conform to C89 and this "
"standard also stipulates that these three streams shall be open at program "
"startup."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:150
msgid ""
"The stream I<stderr> is unbuffered.  The stream I<stdout> is line-buffered "
"when it points to a terminal.  Partial lines will not appear until "
"B<fflush>(3)  or B<exit>(3)  is called, or a newline is printed.  This can "
"produce unexpected results, especially with debugging output.  The buffering "
"mode of the standard streams (or any other stream)  can be changed using the "
"B<setbuf>(3)  or B<setvbuf>(3)  call.  Note that in case I<stdin> is "
"associated with a terminal, there may also be input buffering in the "
"terminal driver, entirely unrelated to stdio buffering.  (Indeed, normally "
"terminal input is line buffered in the kernel.)  This kernel input handling "
"can be modified using calls like B<tcsetattr>(3); see also B<stty>(1), and "
"B<termios>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdin.3:155
msgid "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stdio.3:37
#, no-wrap
msgid "STDIO"
msgstr ""

#. type: TH
#: build/C/man3/stdio.3:37
#, no-wrap
msgid "2001-12-26"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:40
msgid "stdio - standard input/output library functions"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:44
msgid "B<FILE *>I<stdin>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:46
msgid "B<FILE *>I<stdout>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:48
msgid "B<FILE *>I<stderr>B<;>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:55
msgid ""
"The standard I/O library provides a simple and efficient buffered stream I/O "
"interface.  Input and output is mapped into logical data streams and the "
"physical I/O characteristics are concealed.  The functions and macros are "
"listed below; more information is available from the individual man pages."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:78
msgid ""
"A stream is associated with an external file (which may be a physical "
"device) by I<opening> a file, which may involve creating a new file.  "
"Creating an existing file causes its former contents to be discarded.  If a "
"file can support positioning requests (such as a disk file, as opposed to a "
"terminal) then a I<file position indicator> associated with the stream is "
"positioned at the start of the file (byte zero), unless the file is opened "
"with append mode.  If append mode is used, it is unspecified whether the "
"position indicator will be placed at the start or the end of the file.  The "
"position indicator is maintained by subsequent reads, writes and positioning "
"requests.  All input occurs as if the characters were read by successive "
"calls to the B<fgetc>(3)  function; all output takes place as if all "
"characters were written by successive calls to the B<fputc>(3)  function."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:88
msgid ""
"A file is disassociated from a stream by I<closing> the file.  Output "
"streams are flushed (any unwritten buffer contents are transferred to the "
"host environment) before the stream is disassociated from the file.  The "
"value of a pointer to a I<FILE> object is indeterminate after a file is "
"closed (garbage)."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:101
msgid ""
"A file may be subsequently reopened, by the same or another program "
"execution, and its contents reclaimed or modified (if it can be repositioned "
"at the start).  If the main function returns to its original caller, or the "
"B<exit>(3)  function is called, all open files are closed (hence all output "
"streams are flushed) before program termination.  Other methods of program "
"termination, such as B<abort>(3)  do not bother about closing files "
"properly."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:117
msgid ""
"At program startup, three text streams are predefined and need not be opened "
"explicitly: I<standard input> (for reading conventional input), I<standard "
"output> (for writing conventional input), and I<standard error> (for writing "
"diagnostic output).  These streams are abbreviated I<stdin>,I<stdout> and "
"I<stderr>.  When opened, the standard error stream is not fully buffered; "
"the standard input and output streams are fully buffered if and only if the "
"streams do not to refer to an interactive device."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:127
msgid ""
"Output streams that refer to terminal devices are always line buffered by "
"default; pending output to such streams is written automatically whenever an "
"input stream that refers to a terminal device is read.  In cases where a "
"large amount of computation is done after printing part of a line on an "
"output terminal, it is necessary to B<fflush>(3)  the standard output before "
"going off and computing so that the output will appear."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:141
msgid ""
"The I<stdio> library is a part of the library B<libc> and routines are "
"automatically loaded as needed by the compilers B<cc>(1)  and B<pc>(1).  The "
"SYNOPSIS sections of the following manual pages indicate which include files "
"are to be used, what the compiler declaration for the function looks like "
"and which external variables are of interest."
msgstr ""

#.  Not on Linux: .BR fropen ,
#.  Not on Linux: .BR fwopen ,
#. type: Plain text
#: build/C/man3/stdio.3:181
msgid ""
"The following are defined as macros; these names may not be reused without "
"first removing their current definitions with B<#undef>: B<BUFSIZ>, B<EOF>, "
"B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, B<L_ctermid>, B<L_tmpnam>, "
"B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, B<TMP_MAX>, B<clearerr>, "
"B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar>, "
"B<stderr>, B<stdin>, B<stdout>.  Function versions of the macro functions "
"B<feof>, B<ferror>, B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, "
"and B<putchar> exist and will be used if the macros definitions are "
"explicitly removed."
msgstr ""

#. type: SS
#: build/C/man3/stdio.3:181
#, no-wrap
msgid "List of Functions"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:186
#, no-wrap
msgid "Function\tDescription\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:187
#, no-wrap
msgid "_\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:188
#, no-wrap
msgid "clearerr\tcheck and reset stream status\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:189
#, no-wrap
msgid "fclose\tclose a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:190
#, no-wrap
msgid "fdopen\tstream open functions\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:191
#, no-wrap
msgid "feof\tcheck and reset stream status\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:192
#, no-wrap
msgid "ferror\tcheck and reset stream status\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:193
#, no-wrap
msgid "fflush\tflush a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:194
#, no-wrap
msgid "fgetc\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:195
#, no-wrap
msgid "fgetpos\treposition a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:196
#, no-wrap
msgid "fgets\tget a line from a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:197
#, no-wrap
msgid "fileno\treturn the integer descriptor of the argument stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:198
#, no-wrap
msgid "fopen\tstream open functions\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:199
#, no-wrap
msgid "fprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:200
#, no-wrap
msgid "fpurge\tflush a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:201
#, no-wrap
msgid "fputc\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:202
#, no-wrap
msgid "fputs\toutput a line to a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:203
#, no-wrap
msgid "fread\tbinary stream input/output\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:204
#, no-wrap
msgid "freopen\tstream open functions\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:205
#, no-wrap
msgid "fscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:206
#, no-wrap
msgid "fseek\treposition a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:207
#, no-wrap
msgid "fsetpos\treposition a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:208
#, no-wrap
msgid "ftell\treposition a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:209
#, no-wrap
msgid "fwrite\tbinary stream input/output\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:210
#, no-wrap
msgid "getc\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:211
#, no-wrap
msgid "getchar\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:212
#, no-wrap
msgid "gets\tget a line from a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:213
#, no-wrap
msgid "getw\tget next character or word from input stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:214
#, no-wrap
msgid "mktemp\tmake temporary filename (unique)\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:215
#, no-wrap
msgid "perror\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:216
#, no-wrap
msgid "printf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:217
#, no-wrap
msgid "putc\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:218
#, no-wrap
msgid "putchar\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:219
#, no-wrap
msgid "puts\toutput a line to a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:220
#, no-wrap
msgid "putw\toutput a character or word to a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:221
#, no-wrap
msgid "remove\tremove directory entry\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:222
#, no-wrap
msgid "rewind\treposition a stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:223
#, no-wrap
msgid "scanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:224
#, no-wrap
msgid "setbuf\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:225
#, no-wrap
msgid "setbuffer\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:226
#, no-wrap
msgid "setlinebuf\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:227
#, no-wrap
msgid "setvbuf\tstream buffering operations\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:228
#, no-wrap
msgid "sprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:229
#, no-wrap
msgid "sscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:230
#, no-wrap
msgid "strerror\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:231
#, no-wrap
msgid "sys_errlist\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:232
#, no-wrap
msgid "sys_nerr\tsystem error messages\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:233
#, no-wrap
msgid "tempnam\ttemporary file routines\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:234
#, no-wrap
msgid "tmpfile\ttemporary file routines\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:235
#, no-wrap
msgid "tmpnam\ttemporary file routines\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:236
#, no-wrap
msgid "ungetc\tun-get character from input stream\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:237
#, no-wrap
msgid "vfprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:238
#, no-wrap
msgid "vfscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:239
#, no-wrap
msgid "vprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:240
#, no-wrap
msgid "vscanf\tinput format conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:241
#, no-wrap
msgid "vsprintf\tformatted output conversion\n"
msgstr ""

#. type: tbl table
#: build/C/man3/stdio.3:242
#, no-wrap
msgid "vsscanf\tinput format conversion\n"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:248
msgid "The I<stdio> library conforms to C89."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio.3:254
msgid ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/stdio_ext.3:23
#, no-wrap
msgid "STDIO_EXT"
msgstr ""

#. type: TH
#: build/C/man3/stdio_ext.3:23
#, no-wrap
msgid "2001-12-16"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:28
msgid ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - interfaces to stdio FILE "
"structure"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:32
msgid "B<#include E<lt>stdio_ext.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:34
msgid "B<size_t __fbufsize(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:36
msgid "B<size_t __fpending(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:38
msgid "B<int __flbf(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:40
msgid "B<int __freadable(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:42
msgid "B<int __fwritable(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:44
msgid "B<int __freading(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:46
msgid "B<int __fwriting(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:48
msgid "B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:50
msgid "B<void _flushlbf(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:52
msgid "B<void __fpurge(FILE *>I<stream>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:57
msgid ""
"Solaris introduced routines to allow portable access to the internals of the "
"I<FILE> structure, and glibc also implemented these."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:62
msgid ""
"The B<__fbufsize>()  function returns the size of the buffer currently used "
"by the given stream."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:69
msgid ""
"The B<__fpending>()  function returns the number of bytes in the output "
"buffer.  For wide-oriented streams the unit is wide characters.  This "
"function is undefined on buffers in reading mode, or opened read-only."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:74
msgid ""
"The B<__flbf>()  function returns a nonzero value if the stream is "
"line-buffered, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:79
msgid ""
"The B<__freadable>()  function returns a nonzero value if the stream allows "
"reading, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:84
msgid ""
"The B<__fwritable>()  function returns a nonzero value if the stream allows "
"writing, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:90
msgid ""
"The B<__freading>()  function returns a nonzero value if the stream is "
"read-only, or if the last operation on the stream was a read operation, and "
"zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:96
msgid ""
"The B<__fwriting>()  function returns a nonzero value if the stream is "
"write-only (or append-only), or if the last operation on the stream was a "
"write operation, and zero otherwise."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:104
msgid ""
"The B<__fsetlocking>()  function can be used to select the desired type of "
"locking on the stream.  It returns the current type.  The I<type> argument "
"can take the following three values:"
msgstr ""

#. type: TP
#: build/C/man3/stdio_ext.3:104
#, no-wrap
msgid "B<FSETLOCKING_INTERNAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:109
msgid ""
"Perform implicit locking around every operation on the given stream (except "
"for the *_unlocked ones).  This is the default."
msgstr ""

#. type: TP
#: build/C/man3/stdio_ext.3:109
#, no-wrap
msgid "B<FSETLOCKING_BYCALLER>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:116
msgid ""
"The caller will take care of the locking (possibly using B<flockfile>(3)  in "
"case there is more than one thread), and the stdio routines will not do "
"locking until the state is reset to B<FSETLOCKING_INTERNAL>."
msgstr ""

#. type: TP
#: build/C/man3/stdio_ext.3:116
#, no-wrap
msgid "B<FSETLOCKING_QUERY>"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:120
msgid "Don't change the type of locking.  (Only return it.)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:126
msgid ""
"The B<_flushlbf>()  function flushes all line-buffered streams.  (Presumably "
"so that output to a terminal is forced out, say before reading keyboard "
"input.)"
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:130
msgid "The B<__fpurge>()  function discards the contents of the stream's buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/stdio_ext.3:132
msgid "B<flockfile>(3), B<fpurge>(3)"
msgstr ""

#. type: TH
#: build/C/man2/symlink.2:32 build/C/man7/symlink.7:35
#, no-wrap
msgid "SYMLINK"
msgstr ""

#. type: TH
#: build/C/man2/symlink.2:32
#, no-wrap
msgid "2010-09-20"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:35
msgid "symlink - make a new name for a file"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:39
msgid "B<int symlink(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:47
msgid "B<symlink>():"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:58
msgid ""
"B<symlink>()  creates a symbolic link named I<newpath> which contains the "
"string I<oldpath>."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:62
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:67
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link "
"resides."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:71
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or "
"to a nonexistent one; the latter case is known as a dangling link."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:78
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link "
"is requested and the link is in a directory with the sticky bit (B<S_ISVTX>)  "
"set."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:99
msgid ""
"Write access to the directory containing I<newpath> is denied, or one of the "
"directories in the path prefix of I<newpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:113
msgid "Too many symbolic links were encountered in resolving I<newpath>."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:123
msgid ""
"A directory component in I<newpath> does not exist or is a dangling symbolic "
"link, or I<oldpath> is the empty string."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:135
msgid "A component used as a directory in I<newpath> is not, in fact, a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:140
msgid ""
"The file system containing I<newpath> does not support the creation of "
"symbolic links."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:144
msgid "I<newpath> is on a read-only file system."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:154
msgid "No checking of I<oldpath> is done."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:159
msgid ""
"Deleting the name referred to by a symlink will actually delete the file "
"(unless it also has other hard links).  If this behavior is not desired, use "
"B<link>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/symlink.2:170
msgid ""
"B<ln>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), B<readlink>(2), "
"B<rename>(2), B<symlinkat>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man7/symlink.7:35
#, no-wrap
msgid "2008-06-18"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:38
msgid "symlink - symbolic link handling"
msgstr ""

#. type: SH
#: build/C/man7/symlink.7:38
#, no-wrap
msgid "SYMBOLIC LINK HANDLING"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:42
msgid ""
"Symbolic links are files that act as pointers to other files.  To understand "
"their behavior, you must first understand how hard links work."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:58
msgid ""
"A hard link to a file is indistinguishable from the original file because it "
"is a reference to the object underlying the original filename.  (To be "
"precise: each of the hard links to a file is a reference to the same "
"I<i-node number>, where an i-node number is an index into the i-node table, "
"which contains metadata about all files on a file system.  See B<stat>(2).)  "
"Changes to a file are independent of the name used to reference the file.  "
"Hard links may not refer to directories (to prevent the possibility of loops "
"within the file system tree, which would confuse many programs)  and may not "
"refer to files on different file systems (because i-node numbers are not "
"unique across file systems)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:65
msgid ""
"A symbolic link is a special type of file whose contents are a string that "
"is the pathname another file, the file to which the link refers.  In other "
"words, a symbolic link is a pointer to another name, and not to an "
"underlying object.  For this reason, symbolic links may refer to directories "
"and may cross file system boundaries."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:71
msgid ""
"There is no requirement that the pathname referred to by a symbolic link "
"should exist.  A symbolic link that refers to a pathname that does not exist "
"is said to be a I<dangling link>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:83
msgid ""
"Because a symbolic link and its referenced object coexist in the file system "
"name space, confusion can arise in distinguishing between the link itself "
"and the referenced object.  On historical systems, commands and system calls "
"adopted their own link-following conventions in a somewhat ad-hoc fashion.  "
"Rules for a more uniform approach, as they are implemented on Linux and "
"other systems, are outlined here.  It is important that site-local "
"applications also conform to these rules, so that the user interface can be "
"as consistent as possible."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:83
#, no-wrap
msgid "Symbolic link ownership, permissions, and timestamps"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:91
msgid ""
"The owner and group of an existing symbolic link can be changed using "
"B<lchown>(2).  The only time that the ownership of a symbolic link matters "
"is when the link is being removed or renamed in a directory that has the "
"sticky bit set (see B<stat>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:97
msgid ""
"The last access and last modification timestamps of a symbolic link can be "
"changed using B<utimensat>(2)  or B<lutimes>(3)."
msgstr ""

#.  Linux does not currently implement an lchmod(2).
#
#.  The
#.  4.4BSD
#.  system differs from historical
#.  4BSD
#.  systems in that the system call
#.  .BR chown (2)
#.  has been changed to follow symbolic links.
#.  The
#.  .BR lchown (2)
#.  system call was added later when the limitations of the new
#.  .BR chown (2)
#.  became apparent.
#. type: Plain text
#: build/C/man7/symlink.7:116
msgid ""
"On Linux, the permissions of a symbolic link are not used in any operations; "
"the permissions are always 0777 (read, write, and execute for all user "
"categories), and can't be changed."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:116
#, no-wrap
msgid "Handling of symbolic links by system calls and commands"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:131
msgid ""
"Symbolic links are handled either by operating on the link itself, or by "
"operating on the object referred to by the link.  In the latter case, an "
"application or system call is said to I<follow> the link.  Symbolic links "
"may refer to other symbolic links, in which case the links are dereferenced "
"until an object that is not a symbolic link is found, a symbolic link that "
"refers to a file which does not exist is found, or a loop is detected.  "
"(Loop detection is done by placing an upper limit on the number of links "
"that may be followed, and an error results if this limit is exceeded.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:134
msgid ""
"There are three separate areas that need to be discussed.  They are as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:134
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:136
msgid "Symbolic links used as filename arguments for system calls."
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:136
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:139
msgid ""
"Symbolic links specified as command-line arguments to utilities that are not "
"traversing a file tree."
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:139
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:143
msgid ""
"Symbolic links encountered by utilities that are traversing a file tree "
"(either specified on the command line or encountered as part of the file "
"hierarchy walk)."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:143
#, no-wrap
msgid "System calls"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:146
msgid ""
"The first area is symbolic links used as filename arguments for system "
"calls."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:156
msgid ""
"Except as noted below, all system calls follow symbolic links.  For example, "
"if there were a symbolic link I<slink> which pointed to a file named "
"I<afile>, the system call I<open(\"slink\" ...\\&)> would return a file "
"descriptor referring to the file I<afile>."
msgstr ""

#.  Maybe one day: .BR fchownat (2)
#. type: Plain text
#: build/C/man7/symlink.7:206
msgid ""
"Various system calls do not follow links, and operate on the symbolic link "
"itself.  They are: B<lchown>(2), B<lgetxattr>(2), B<llistxattr>(2), "
"B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), B<readlink>(2), "
"B<rename>(2), B<rmdir>(2), and B<unlink>(2).  Certain other system calls "
"optionally follow symbolic links.  They are: B<faccessat>(2), "
"B<fchownat>(2), B<fstatat>(2), B<linkat>(2), B<open>(2), B<openat>(2), and "
"B<utimensat>(2); see their manual pages for details.  Because B<remove>(3)  "
"is an alias for B<unlink>(2), that library function also does not follow "
"symbolic links.  When B<rmdir>(2)  is applied to a symbolic link, it fails "
"with the error B<ENOTDIR>.  The B<link>(2)  warrants special discussion.  "
"POSIX.1-2001 specifies that B<link>(2)  should dereference I<oldpath> if it "
"is a symbolic link.  However, Linux does not do this.  (By default Solaris "
"is the same, but the POSIX.1-2001 specified behavior can be obtained with "
"suitable compiler options.)  The upcoming POSIX.1 revision changes the "
"specification to allow either behavior in an implementation."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:206
#, no-wrap
msgid "Commands not traversing a file tree"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:209
msgid ""
"The second area is symbolic links, specified as command-line filename "
"arguments, to commands which are not traversing a file tree."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:220
msgid ""
"Except as noted below, commands follow symbolic links named as command-line "
"arguments.  For example, if there were a symbolic link I<slink> which "
"pointed to a file named I<afile>, the command I<cat slink> would display the "
"contents of the file I<afile>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:228
msgid ""
"It is important to realize that this rule includes commands which may "
"optionally traverse file trees, e.g., the command I<chown file> is included "
"in this rule, while the command I<chown\\ -R file>, which performs a tree "
"traversal, is not.  (The latter is described in the third area, below.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:246
msgid ""
"If it is explicitly intended that the command operate on the symbolic link "
"instead of following the symbolic link, e.g., it is desired that I<chown "
"slink> change the ownership of the file that I<slink> is, whether it is a "
"symbolic link or not, the I<-h> option should be used.  In the above "
"example, I<chown root slink> would change the ownership of the file referred "
"to by I<slink>, while I<chown\\ -h root slink> would change the ownership of "
"I<slink> itself."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:248
msgid "There are some exceptions to this rule:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:258
msgid ""
"The B<mv>(1)  and B<rm>(1)  commands do not follow symbolic links named as "
"arguments, but respectively attempt to rename and delete them.  (Note, if "
"the symbolic link references a file via a relative path, moving it to "
"another directory may very well cause it to stop working, since the path may "
"no longer be correct.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:288
msgid ""
"The B<ls>(1)  command is also an exception to this rule.  For compatibility "
"with historic systems (when B<ls>(1)  is not doing a tree walk, i.e., the "
"I<-R> option is not specified), the B<ls>(1)  command follows symbolic links "
"named as arguments if the I<-H> or I<-L> option is specified, or if the "
"I<-F>, I<-d>, or I<-l> options are not specified.  (The B<ls>(1)  command is "
"the only command where the I<-H> and I<-L> options affect its behavior even "
"though it is not doing a walk of a file tree.)"
msgstr ""

#
#. The 4.4BSD system differs from historical 4BSD systems in that the
#. .BR chown (1)
#. and
#. .BR chgrp (1)
#. commands follow symbolic links specified on the command line.
#. type: Plain text
#: build/C/man7/symlink.7:306
msgid ""
"The B<file>(1)  command is also an exception to this rule.  The B<file>(1)  "
"command does not follow symbolic links named as argument by default.  The "
"B<file>(1)  command does follow symbolic links named as argument if the "
"I<-L> option is specified."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:306
#, no-wrap
msgid "Commands traversing a file tree"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:319
msgid ""
"The following commands either optionally or always traverse file trees: "
"B<chgrp>(1), B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), "
"B<ls>(1), B<pax>(1), B<rm>(1), and B<tar>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:323
msgid ""
"It is important to realize that the following rules apply equally to "
"symbolic links encountered during the file tree traversal and symbolic links "
"listed as command-line arguments."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:328
msgid ""
"The I<first rule> applies to symbolic links that reference files other than "
"directories.  Operations that apply to symbolic links are performed on the "
"links themselves, but otherwise the links are ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:340
msgid ""
"The command I<rm\\ -r slink directory> will remove I<slink>, as well as any "
"symbolic links encountered in the tree traversal of I<directory>, because "
"symbolic links may be removed.  In no case will B<rm>(1)  affect the file "
"referred to by I<slink>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:345
msgid ""
"The I<second rule> applies to symbolic links that refer to directories.  "
"Symbolic links that refer to directories are never followed by default.  "
"This is often referred to as a \"physical\" walk, as opposed to a "
"\"logical\" walk (where symbolic links the refer to directories are "
"followed)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:348
msgid ""
"Certain conventions are (should be) followed as consistently as possible by "
"commands that perform file tree walks:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:361
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, regardless of the type of file they reference, by specifying the I<-H> "
"(for \"half-logical\") flag.  This flag is intended to make the command-line "
"name space look like the logical name space.  (Note, for commands that do "
"not always do file tree traversals, the I<-H> flag will be ignored if the "
"I<-R> flag is not also specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:377
msgid ""
"For example, the command I<chown\\ -HR user slink> will traverse the file "
"hierarchy rooted in the file pointed to by I<slink>.  Note, the I<-H> is not "
"the same as the previously discussed I<-h> flag.  The I<-H> flag causes "
"symbolic links specified on the command line to be dereferenced for the "
"purposes of both the action to be performed and the tree walk, and it is as "
"if the user had specified the name of the file to which the symbolic link "
"pointed."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:391
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, as well as any symbolic links encountered during the traversal, "
"regardless of the type of file they reference, by specifying the I<-L> (for "
"\"logical\") flag.  This flag is intended to make the entire name space look "
"like the logical name space.  (Note, for commands that do not always do file "
"tree traversals, the I<-L> flag will be ignored if the I<-R> flag is not "
"also specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:406
msgid ""
"For example, the command I<chown\\ -LR user slink> will change the owner of "
"the file referred to by I<slink>.  If I<slink> refers to a directory, "
"B<chown> will traverse the file hierarchy rooted in the directory that it "
"references.  In addition, if any symbolic links are encountered in any file "
"tree that B<chown> traverses, they will be treated in the same fashion as "
"I<slink>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:413
msgid ""
"A command can be made to provide the default behavior by specifying the "
"I<-P> (for \"physical\") flag.  This flag is intended to make the entire "
"name space look like the physical name space."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:431
msgid ""
"For commands that do not by default do file tree traversals, the I<-H>, "
"I<-L>, and I<-P> flags are ignored if the I<-R> flag is not also specified.  "
"In addition, you may specify the I<-H>, I<-L>, and I<-P> options more than "
"once; the last one specified determines the command's behavior.  This is "
"intended to permit you to alias commands to behave one way or the other, and "
"then override that behavior on the command line."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:437
msgid "The B<ls>(1)  and B<rm>(1)  commands have exceptions to these rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:450
msgid ""
"The B<rm>(1)  command operates on the symbolic link, and not the file it "
"references, and therefore never follows a symbolic link.  The B<rm>(1)  "
"command does not support the I<-H>, I<-L>, or I<-P> options."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:470
msgid ""
"To maintain compatibility with historic systems, the B<ls>(1)  command acts "
"a little differently.  If you do not specify the I<-F>, I<-d> or I<-l> "
"options, B<ls>(1)  will follow symbolic links specified on the command "
"line.  If the I<-L> flag is specified, B<ls>(1)  follows all symbolic links, "
"regardless of their type, whether specified on the command line or "
"encountered in the tree walk."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:487
msgid ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), "
"B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<readlink>(2), "
"B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2), B<lutimes>(3), "
"B<path_resolution>(7)"
msgstr ""

#. type: TH
#: build/C/man3/tempnam.3:23
#, no-wrap
msgid "TEMPNAM"
msgstr ""

#. type: TH
#: build/C/man3/tempnam.3:23
#, no-wrap
msgid "2008-08-06"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:26
msgid "tempnam - create a name for a temporary file"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:31
#, no-wrap
msgid "B<char *tempnam(const char *>I<dir>B<, const char *>I<pfx>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:40
msgid "B<tempnam>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:54
msgid ""
"The B<tempnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist when "
"B<tempnam>()  checked.  The filename suffix of the pathname generated will "
"start with I<pfx> in case I<pfx> is a non-NULL string of at most five "
"bytes.  The directory prefix part of the pathname generated is required to "
"be \"appropriate\" (often that at least implies writable)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:57
msgid "Attempts to find an appropriate directory go through the following steps:"
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:57
#, no-wrap
msgid "a)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:63
msgid ""
"In case the environment variable B<TMPDIR> exists and contains the name of "
"an appropriate directory, that is used."
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:63
#, no-wrap
msgid "b)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:68
msgid "Otherwise, if the I<dir> argument is non-NULL and appropriate, it is used."
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:68
#, no-wrap
msgid "c)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:75
msgid ""
"Otherwise, I<P_tmpdir> (as defined in I<E<lt>stdio.hE<gt>>)  is used when "
"appropriate."
msgstr ""

#. type: TP
#: build/C/man3/tempnam.3:75
#, no-wrap
msgid "d)"
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:78
msgid "Finally an implementation-defined directory may be used."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:85
msgid ""
"The string returned by B<tempnam>()  is allocated using B<malloc>(3)  and "
"hence should be freed by B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:90
msgid ""
"The B<tempnam>()  function returns a pointer to a unique temporary filename, "
"or NULL if a unique name cannot be generated."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:94
msgid "Allocation of storage failed."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:99
msgid "SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<tempnam>()  as obsolete."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:118
msgid ""
"Although B<tempnam>()  generates names that are difficult to guess, it is "
"nevertheless possible that between the time that B<tempnam>()  returns a "
"pathname, and the time that the program opens it, another program might "
"create that pathname using B<open>(2), or create it as a symbolic link.  "
"This can lead to security holes.  To avoid such possibilities, use the "
"B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
"B<mkstemp>(3)  or B<tmpfile>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:126
msgid ""
"SUSv2 does not mention the use of B<TMPDIR>; glibc will use it only when the "
"program is not set-user-ID.  On SVr4, the directory used under B<d)> is "
"I</tmp> (and this is what glibc does)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:131
msgid ""
"Because it dynamically allocates memory used to return the pathname, "
"B<tempnam>()  is reentrant, and thus thread safe, unlike B<tmpnam>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:144
msgid ""
"The B<tempnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> (defined in I<E<lt>stdio.hE<gt>>)  times.  If it is "
"called more than B<TMP_MAX> times, the behavior is implementation defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:148
msgid "B<tempnam>()  uses at most the first five bytes from I<pfx>."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:154
msgid ""
"The glibc implementation of B<tempnam>()  will fail with the error B<EEXIST> "
"upon failure to find a unique name."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:157
msgid ""
"The precise meaning of \"appropriate\" is undefined; it is unspecified how "
"accessibility of a directory is determined."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:164 build/C/man3/tmpnam.3:151
msgid "Never use this function.  Use B<mkstemp>(3)  or B<tmpfile>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/tempnam.3:168
msgid "B<mkstemp>(3), B<mktemp>(3), B<tmpfile>(3), B<tmpnam>(3)"
msgstr ""

#. type: TH
#: build/C/man3/tmpfile.3:29
#, no-wrap
msgid "TMPFILE"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:32
msgid "tmpfile - create a temporary file"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:37
#, no-wrap
msgid "B<FILE *tmpfile(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:45
msgid ""
"The B<tmpfile>()  function opens a unique temporary file in binary "
"read/write (w+b) mode.  The file will be automatically deleted when it is "
"closed or the program terminates."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:52
msgid ""
"The B<tmpfile>()  function returns a stream descriptor, or NULL if a unique "
"filename cannot be generated or the unique file cannot be opened.  In the "
"latter case, I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:56
msgid "Search permission denied for directory in file's path prefix."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:59
msgid "Unable to generate a unique filename."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:62
msgid "The call was interrupted by a signal."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:65
msgid "Too many file descriptors in use by the process."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:68
msgid "Too many files open in the system."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:71
msgid "There was no room in the directory to add the new filename."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:74
msgid "Read-only file system."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:76
msgid "SVr4, 4.3BSD, C89, C99, SUSv2, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:80
msgid ""
"POSIX.1-2001 specifies: an error message may be written to I<stdout> if the "
"stream cannot be opened."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:86
msgid ""
"The standard does not specify the directory that B<tmpfile>()  will use.  "
"Glibc will try the path prefix I<P_tmpdir> defined in I<E<lt>stdio.hE<gt>>, "
"and if that fails the directory I</tmp>."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpfile.3:91
msgid "B<exit>(3), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpnam>(3)"
msgstr ""

#. type: TH
#: build/C/man3/tmpnam.3:25
#, no-wrap
msgid "TMPNAM"
msgstr ""

#. type: TH
#: build/C/man3/tmpnam.3:25
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:28
msgid "tmpnam, tmpnam_r - create a name for a temporary file"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:33
#, no-wrap
msgid "B<char *tmpnam(char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:56
msgid ""
"The B<tmpnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist at some point in "
"time, so that naive programmers may think it a suitable name for a temporary "
"file.  If the argument I<s> is NULL this name is generated in an internal "
"static buffer and may be overwritten by the next call to B<tmpnam>().  If "
"I<s> is not NULL, the name is copied to the character array (of length at "
"least I<L_tmpnam>)  pointed to by I<s> and the value I<s> is returned in "
"case of success."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:68
msgid ""
"The pathname that is created, has a directory prefix I<P_tmpdir>.  (Both "
"I<L_tmpnam> and I<P_tmpdir> are defined in I<E<lt>stdio.hE<gt>>, just like "
"the B<TMP_MAX> mentioned below.)"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:73
msgid ""
"The B<tmpnam>()  function returns a pointer to a unique temporary filename, "
"or NULL if a unique name cannot be generated."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:75
msgid "No errors are defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:80
msgid ""
"SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX.1-2008 marks B<tmpnam>()  as "
"obsolete."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:91
msgid ""
"The B<tmpnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> times.  If it is called more than B<TMP_MAX> times, "
"the behavior is implementation defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:110
msgid ""
"Although B<tmpnam>()  generates names that are difficult to guess, it is "
"nevertheless possible that between the time that B<tmpnam>()  returns a "
"pathname, and the time that the program opens it, another program might "
"create that pathname using B<open>(2), or create it as a symbolic link.  "
"This can lead to security holes.  To avoid such possibilities, use the "
"B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
"B<mkstemp>(3)  or B<tmpfile>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:118
msgid ""
"Portable applications that use threads cannot call B<tmpnam>()  with a NULL "
"argument if either B<_POSIX_THREADS> or B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:122
msgid "A POSIX draft proposed to use a function B<tmpnam_r>()  defined by"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:130
#, no-wrap
msgid ""
"char *\n"
"tmpnam_r(char *s)\n"
"{\n"
"    return s ? tmpnam(s) : NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:144
msgid ""
"apparently as a warning not to use NULL.  A few systems implement it.  To "
"get a glibc prototype for this function from I<E<lt>stdio.hE<gt>>, define "
"B<_SVID_SOURCE> or B<_BSD_SOURCE> (before including I<any> header file)."
msgstr ""

#. type: Plain text
#: build/C/man3/tmpnam.3:155
msgid "B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3)"
msgstr ""

#. type: TH
#: build/C/man2/unlink.2:32
#, no-wrap
msgid "UNLINK"
msgstr ""

#. type: TH
#: build/C/man2/unlink.2:32
#, no-wrap
msgid "2011-09-15"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:35
msgid "unlink - delete a name and possibly the file it refers to"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:39
msgid "B<int unlink(const char *>I<pathname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:45
msgid ""
"B<unlink>()  deletes a name from the file system.  If that name was the last "
"link to a file and no processes have the file open the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:49
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:51
msgid "If the name referred to a symbolic link the link is removed."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:55
msgid ""
"If the name referred to a socket, fifo or device the name for it is removed "
"but processes which have the object open may continue to use it."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:71
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:80
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:92
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by "
"Linux since 2.1.132.)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:96
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:106
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or "
"I<pathname> is empty."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:114
msgid "A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:123
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""

#. type: TP
#: build/C/man2/unlink.2:123
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:126
msgid "The file system does not allow unlinking of files."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:137
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted "
"nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:141
msgid "I<pathname> refers to a file on a read-only file system."
msgstr ""

#. type: Plain text
#: build/C/man2/unlink.2:160
msgid ""
"B<rm>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlinkat>(2), B<mkfifo>(3), B<remove>(3), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man3/unlocked_stdio.3:23
#, no-wrap
msgid "UNLOCKED_STDIO"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:27
msgid ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"nonlocking stdio functions"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:35
#, no-wrap
msgid ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:47
#, no-wrap
msgid ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t "
">I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t "
">I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:50
#, no-wrap
msgid ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:61
#, no-wrap
msgid ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE "
"*>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:73
msgid ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:76
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE || "
"_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:87
msgid ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:89
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:100
msgid ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:111
msgid ""
"Each of these functions has the same behavior as its counterpart without the "
"\"_unlocked\" suffix, except that they do not use locking (they do not set "
"locks themselves, and do not test for the presence of locks set by others) "
"and hence are thread-unsafe.  See B<flockfile>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:118
msgid ""
"The four functions B<getc_unlocked>(), B<getchar_unlocked>(), "
"B<putc_unlocked>(), B<putchar_unlocked>()  are in POSIX.1-2001."
msgstr ""

#.  E.g., in HP-UX 10.0. In HP-UX 10.30 they are called obsolescent, and
#.  moved to a compatibility library.
#.  Available in HP-UX 10.0: clearerr_unlocked, fclose_unlocked,
#.  feof_unlocked, ferror_unlocked, fflush_unlocked, fgets_unlocked,
#.  fgetwc_unlocked, fgetws_unlocked, fileno_unlocked, fputs_unlocked,
#.  fputwc_unlocked, fputws_unlocked, fread_unlocked, fseek_unlocked,
#.  ftell_unlocked, fwrite_unlocked, getc_unlocked, getchar_unlocked,
#.  getw_unlocked, getwc_unlocked, getwchar_unlocked, putc_unlocked,
#.  putchar_unlocked, puts_unlocked, putws_unlocked, putw_unlocked,
#.  putwc_unlocked, putwchar_unlocked, rewind_unlocked, setvbuf_unlocked,
#.  ungetc_unlocked, ungetwc_unlocked.
#. type: Plain text
#: build/C/man3/unlocked_stdio.3:134
msgid ""
"The nonstandard B<*_unlocked>()  variants occur on a few UNIX systems, and "
"are available in recent glibc.  They should probably not be used."
msgstr ""

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:136
msgid "B<flockfile>(3), B<stdio>(3)"
msgstr ""

#. type: TH
#: build/C/man3/wprintf.3:14
#, no-wrap
msgid "WPRINTF"
msgstr ""

#. type: TH
#: build/C/man3/wprintf.3:14
#, no-wrap
msgid "2011-09-17"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:18
msgid ""
"wprintf, fwprintf, swprintf, vwprintf, vfwprintf, vswprintf - formatted "
"wide-character output conversion"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:22
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:27
#, no-wrap
msgid ""
"B<int wprintf(const wchar_t *>I<format>B<, ...);>\n"
"B<int fwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, ...);>\n"
"B<int swprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<             const wchar_t *>I<format>B<, ...);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:32
#, no-wrap
msgid ""
"B<int vwprintf(const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vfwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, va_list "
">I<args>B<);>\n"
"B<int vswprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<              const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
msgstr ""

#.  .BR wprintf (),
#.  .BR fwprintf (),
#.  .BR swprintf (),
#.  .BR vwprintf (),
#.  .BR vfwprintf (),
#.  .BR vswprintf ():
#. type: Plain text
#: build/C/man3/wprintf.3:49
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:51
msgid "_ISOC95_SOURCE /* Since glibc 2.12 */ ||"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:53
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:56
msgid "or I<cc\\ -std=c99>"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:67
msgid ""
"The B<wprintf>()  family of functions is the wide-character equivalent of "
"the B<printf>(3)  family of functions.  It performs formatted output of wide "
"characters."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:77
msgid ""
"The B<wprintf>()  and B<vwprintf>()  functions perform wide-character output "
"to I<stdout>.  I<stdout> must not be byte oriented; see B<fwide>(3)  for "
"more information."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:87
msgid ""
"The B<fwprintf>()  and B<vfwprintf>()  functions perform wide-character "
"output to I<stream>.  I<stream> must not be byte oriented; see B<fwide>(3)  "
"for more information."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:98
msgid ""
"The B<swprintf>()  and B<vswprintf>()  functions perform wide-character "
"output to an array of wide characters.  The programmer must ensure that "
"there is room for at least I<maxlen> wide characters at I<wcs>."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:109
msgid ""
"These functions are like the B<printf>(3), B<vprintf>(3), B<fprintf>(3), "
"B<vfprintf>(3), B<sprintf>(3), B<vsprintf>(3)  functions except for the "
"following differences:"
msgstr ""

#. type: TP
#: build/C/man3/wprintf.3:109 build/C/man3/wprintf.3:112 build/C/man3/wprintf.3:115
#, no-wrap
msgid "B<\\(bu>"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:112
msgid "The I<format> string is a wide-character string."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:115
msgid "The output consists of wide characters, not bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:130
msgid ""
"B<swprintf>()  and B<vswprintf>()  take a I<maxlen> argument, B<sprintf>(3)  "
"and B<vsprintf>(3)  do not.  (B<snprintf>(3)  and B<vsnprintf>(3)  take a "
"I<maxlen> argument, but these functions do not return -1 upon buffer "
"overflow on Linux.)"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:132
msgid "The treatment of the conversion characters B<c> and B<s> is different:"
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:146
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to a wide "
"character by a call to the B<btowc>(3)  function, and the resulting wide "
"character is written.  If an B<l> modifier is present, the I<wint_t> (wide "
"character) argument is written."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:185
msgid ""
"If no B<l> modifier is present: The I<const\\ char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string) "
"containing a multibyte character sequence beginning in the initial shift "
"state.  Characters from the array are converted to wide characters (each by "
"a call to the B<mbrtowc>(3)  function with a conversion state starting in "
"the initial state before the first byte).  The resulting wide characters are "
"written up to (but not including) the terminating null wide character.  If a "
"precision is specified, no more wide characters than the number specified "
"are written.  Note that the precision determines the number of I<wide "
"characters> written, not the number of I<bytes> or I<screen positions>.  The "
"array must contain a terminating null byte, unless a precision is given and "
"it is so small that the number of converted wide characters reaches it "
"before the end of the array is reached.  If an B<l> modifier is present: The "
"I<const\\ wchar_t\\ *> argument is expected to be a pointer to an array of "
"wide characters.  Wide characters from the array are written up to (but not "
"including) a terminating null wide character.  If a precision is specified, "
"no more than the number specified are written.  The array must contain a "
"terminating null wide character, unless a precision is given and it is "
"smaller than or equal to the number of wide characters in the array."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:193
msgid ""
"The functions return the number of wide characters written, excluding the "
"terminating null wide character in case of the functions B<swprintf>()  and "
"B<vswprintf>().  They return -1 when an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:195
msgid "C99."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:203
msgid ""
"The behavior of B<wprintf>()  et al. depends on the B<LC_CTYPE> category of "
"the current locale."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:229
msgid ""
"If the I<format> string contains non-ASCII wide characters, the program will "
"only work correctly if the B<LC_CTYPE> category of the current locale at run "
"time is the same as the B<LC_CTYPE> category of the current locale at "
"compile time.  This is because the I<wchar_t> representation is platform- "
"and locale-dependent.  (The glibc represents wide characters using their "
"Unicode (ISO-10646) code point, but other platforms don't do this.  Also, "
"the use of C99 universal character names of the form \\eunnnn does not solve "
"this problem.)  Therefore, in internationalized programs, the I<format> "
"string should consist of ASCII wide characters only, or should be "
"constructed at run time in an internationalized way (e.g., using "
"B<gettext>(3)  or B<iconv>(3), followed by B<mbstowcs>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/wprintf.3:234
msgid "B<fprintf>(3), B<fputwc>(3), B<fwide>(3), B<printf>(3), B<snprintf>(3)"
msgstr ""

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "WRITE"
msgstr ""

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "2010-08-29"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:42
msgid "write - write to a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:46
msgid "B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:54
msgid ""
"B<write>()  writes up to I<count> bytes from the buffer pointed I<buf> to "
"the file referred to by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:68
msgid ""
"The number of bytes written may be less than I<count> if, for example, there "
"is insufficient space on the underlying physical medium, or the "
"B<RLIMIT_FSIZE> resource limit is encountered (see B<setrlimit>(2)), or the "
"call was interrupted by a signal handler after having written less than "
"I<count> bytes.  (See also B<pipe>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:82
msgid ""
"For a seekable file (i.e., one to which B<lseek>(2)  may be applied, for "
"example, a regular file)  writing takes place at the current file offset, "
"and the file offset is incremented by the number of bytes actually written.  "
"If the file was B<open>(2)ed with B<O_APPEND>, the file offset is first set "
"to the end of the file before writing.  The adjustment of the file offset "
"and the write operation are performed as an atomic step."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:89
msgid ""
"POSIX requires that a B<read>(2)  which can be proved to occur after a "
"B<write>()  has returned returns the new data.  Note that not all file "
"systems are POSIX conforming."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:94
msgid ""
"On success, the number of bytes written is returned (zero indicates nothing "
"was written).  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:107
msgid ""
"If I<count> is zero and I<fd> refers to a regular file, then B<write>()  may "
"return a failure status if one of the errors below is detected.  If no "
"errors are detected, 0 will be returned without causing any other effect.  "
"If I<count> is zero and I<fd> refers to a file other than a regular file, "
"the results are not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:115
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the write would block."
msgstr ""

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/write.2:126
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the write would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:130
msgid "I<fd> is not a valid file descriptor or is not open for writing."
msgstr ""

#. type: TP
#: build/C/man2/write.2:130
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:135
msgid ""
"I<fd> refers to a datagram socket for which a peer address has not been set "
"using B<connect>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:144
msgid ""
"An attempt was made to write a file that exceeds the implementation-defined "
"maximum file size or the process's file size limit, or to write at a "
"position past the maximum allowed offset."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:148
msgid ""
"The call was interrupted by a signal before any data was written; see "
"B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:159
msgid ""
"I<fd> is attached to an object which is unsuitable for writing; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the current file offset is not "
"suitably aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:162
msgid "A low-level I/O error occurred while modifying the inode."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:167
msgid ""
"The device containing the file referred to by I<fd> has no room for the "
"data."
msgstr ""

#. type: TP
#: build/C/man2/write.2:167
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:176
msgid ""
"I<fd> is connected to a pipe or socket whose reading end is closed.  When "
"this happens the writing process will also receive a B<SIGPIPE> signal.  "
"(Thus, the write return value is seen only if the program catches, blocks or "
"ignores this signal.)"
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:179
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:188
msgid ""
"Under SVr4 a write may be interrupted and return B<EINTR> at any point, not "
"just before any data is written."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:197
msgid ""
"A successful return from B<write>()  does not make any guarantee that data "
"has been committed to disk.  In fact, on some buggy implementations, it does "
"not even guarantee that space has successfully been reserved for the data.  "
"The only way to be sure is to call B<fsync>(2)  after you are done writing "
"all your data."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:205
msgid ""
"If a B<write>()  is interrupted by a signal handler before any bytes are "
"written, then the call fails with the error B<EINTR>; if it is interrupted "
"after at least one byte has been written, the call succeeds, and returns the "
"number of bytes written."
msgstr ""

#. type: Plain text
#: build/C/man2/write.2:216
msgid ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"
msgstr ""

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:17+0900\n"
"PO-Revision-Date: 2012-05-08 01:25+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/asprintf.3:25
#, no-wrap
msgid "ASPRINTF"
msgstr "ASPRINTF"

#. type: TH
#: build/C/man3/asprintf.3:25
#, no-wrap
msgid "2001-12-18"
msgstr "2001-12-18"

#. type: TH
#: build/C/man3/asprintf.3:25 build/C/man3/ctermid.3:24
#: build/C/man3/dprintf.3:25 build/C/man3/fclose.3:42
#: build/C/man3/fcloseall.3:24 build/C/man3/fflush.3:43
#: build/C/man3/fgetwc.3:16 build/C/man3/fmemopen.3:6 build/C/man3/fopen.3:42
#: build/C/man3/fputwc.3:14 build/C/man3/fread.3:43 build/C/man3/fseek.3:40
#: build/C/man3/getline.3:24 build/C/man3/gets.3:25 build/C/man3/getw.3:23
#: build/C/man3/popen.3:38 build/C/man3/printf.3:34 build/C/man3/puts.3:24
#: build/C/man3/remove.3:31 build/C/man3/scanf.3:50 build/C/man3/wprintf.3:14
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: TH
#: build/C/man3/asprintf.3:25 build/C/man3/ctermid.3:24
#: build/C/man3/dprintf.3:25 build/C/man3/fclose.3:42
#: build/C/man3/fcloseall.3:24 build/C/man3/ferror.3:42
#: build/C/man3/fflush.3:43 build/C/man3/fgetwc.3:16
#: build/C/man3/flockfile.3:23 build/C/man3/fmemopen.3:6
#: build/C/man3/fmtmsg.3:9 build/C/man3/fopen.3:42
#: build/C/man3/fopencookie.3:24 build/C/man3/fpurge.3:23
#: build/C/man3/fputwc.3:14 build/C/man3/fread.3:43 build/C/man3/fseek.3:40
#: build/C/man3/fseeko.3:23 build/C/man3/getline.3:24 build/C/man3/gets.3:25
#: build/C/man3/getw.3:23 build/C/man2/link.2:31 build/C/man2/llseek.2:26
#: build/C/man2/lseek.2:45 build/C/man3/lseek64.3:23 build/C/man2/open.2:52
#: build/C/man3/perror.3:30 build/C/man2/pipe.2:36 build/C/man3/popen.3:38
#: build/C/man3/printf.3:34 build/C/man3/puts.3:24 build/C/man2/read.2:35
#: build/C/man2/readlink.2:41 build/C/man2/readv.2:30 build/C/man3/remove.3:31
#: build/C/man2/rename.2:32 build/C/man2/rmdir.2:30 build/C/man3/scanf.3:50
#: build/C/man3/setbuf.3:46 build/C/man3/stdin.3:9 build/C/man3/stdio.3:37
#: build/C/man3/stdio_ext.3:23 build/C/man2/symlink.2:32
#: build/C/man7/symlink.7:35 build/C/man3/tempnam.3:23
#: build/C/man3/tmpfile.3:29 build/C/man3/tmpnam.3:25 build/C/man2/unlink.2:32
#: build/C/man3/unlocked_stdio.3:23 build/C/man3/wprintf.3:14
#: build/C/man2/write.2:39
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/asprintf.3:26 build/C/man3/ctermid.3:25
#: build/C/man3/dprintf.3:26 build/C/man3/fclose.3:43
#: build/C/man3/fcloseall.3:25 build/C/man3/ferror.3:43
#: build/C/man3/fflush.3:44 build/C/man3/fgetwc.3:17
#: build/C/man3/flockfile.3:24 build/C/man3/fmemopen.3:7
#: build/C/man3/fmtmsg.3:10 build/C/man3/fopen.3:43
#: build/C/man3/fopencookie.3:25 build/C/man3/fpurge.3:24
#: build/C/man3/fputwc.3:15 build/C/man3/fread.3:44 build/C/man3/fseek.3:41
#: build/C/man3/fseeko.3:24 build/C/man3/getline.3:25 build/C/man3/gets.3:26
#: build/C/man3/getw.3:24 build/C/man2/link.2:32 build/C/man2/llseek.2:27
#: build/C/man2/lseek.2:46 build/C/man3/lseek64.3:24 build/C/man2/open.2:53
#: build/C/man3/perror.3:31 build/C/man2/pipe.2:37 build/C/man3/popen.3:39
#: build/C/man3/printf.3:35 build/C/man3/puts.3:25 build/C/man2/read.2:36
#: build/C/man2/readlink.2:42 build/C/man2/readv.2:31 build/C/man3/remove.3:32
#: build/C/man2/rename.2:33 build/C/man2/rmdir.2:31 build/C/man3/scanf.3:51
#: build/C/man3/setbuf.3:47 build/C/man3/stdin.3:10 build/C/man3/stdio.3:38
#: build/C/man3/stdio_ext.3:24 build/C/man2/symlink.2:33
#: build/C/man7/symlink.7:36 build/C/man3/tempnam.3:24
#: build/C/man3/tmpfile.3:30 build/C/man3/tmpnam.3:26 build/C/man2/unlink.2:33
#: build/C/man3/unlocked_stdio.3:24 build/C/man3/wprintf.3:15
#: build/C/man2/write.2:40
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/asprintf.3:28
msgid "asprintf, vasprintf - print to allocated string"
msgstr "asprintf, vasprintf - 文字列を割り当ててそれに出力する"

#. type: SH
#: build/C/man3/asprintf.3:28 build/C/man3/ctermid.3:27
#: build/C/man3/dprintf.3:28 build/C/man3/fclose.3:45
#: build/C/man3/fcloseall.3:27 build/C/man3/ferror.3:45
#: build/C/man3/fflush.3:46 build/C/man3/fgetwc.3:19
#: build/C/man3/flockfile.3:26 build/C/man3/fmemopen.3:9
#: build/C/man3/fmtmsg.3:12 build/C/man3/fopen.3:45
#: build/C/man3/fopencookie.3:27 build/C/man3/fpurge.3:26
#: build/C/man3/fputwc.3:17 build/C/man3/fread.3:46 build/C/man3/fseek.3:43
#: build/C/man3/fseeko.3:26 build/C/man3/getline.3:27 build/C/man3/gets.3:28
#: build/C/man3/getw.3:26 build/C/man2/link.2:34 build/C/man2/llseek.2:29
#: build/C/man2/lseek.2:48 build/C/man3/lseek64.3:26 build/C/man2/open.2:55
#: build/C/man3/perror.3:33 build/C/man2/pipe.2:39 build/C/man3/popen.3:41
#: build/C/man3/printf.3:38 build/C/man3/puts.3:27 build/C/man2/read.2:38
#: build/C/man2/readlink.2:44 build/C/man2/readv.2:33 build/C/man3/remove.3:34
#: build/C/man2/rename.2:35 build/C/man2/rmdir.2:33 build/C/man3/scanf.3:53
#: build/C/man3/setbuf.3:49 build/C/man3/stdin.3:12 build/C/man3/stdio.3:40
#: build/C/man3/stdio_ext.3:28 build/C/man2/symlink.2:35
#: build/C/man3/tempnam.3:26 build/C/man3/tmpfile.3:32
#: build/C/man3/tmpnam.3:28 build/C/man2/unlink.2:35
#: build/C/man3/unlocked_stdio.3:27 build/C/man3/wprintf.3:18
#: build/C/man2/write.2:42
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/asprintf.3:30
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/asprintf.3:32 build/C/man3/dprintf.3:30
#: build/C/man3/fclose.3:47 build/C/man3/ferror.3:47 build/C/man3/fflush.3:48
#: build/C/man3/fseek.3:45 build/C/man3/perror.3:35 build/C/man3/printf.3:40
#: build/C/man3/remove.3:36 build/C/man2/rename.2:37 build/C/man3/stdio.3:42
#: build/C/man3/stdio_ext.3:30
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: build/C/man3/asprintf.3:34
msgid "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"
msgstr "B<int asprintf(char **>I<strp>B<, const char *>I<fmt>B<, ...);>"

#. type: Plain text
#: build/C/man3/asprintf.3:36
msgid ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int vasprintf(char **>I<strp>B<, const char *>I<fmt>B<, va_list >I<ap>B<);>"

#. type: SH
#: build/C/man3/asprintf.3:36 build/C/man3/ctermid.3:44
#: build/C/man3/dprintf.3:54 build/C/man3/fclose.3:49
#: build/C/man3/fcloseall.3:34 build/C/man3/ferror.3:63
#: build/C/man3/fflush.3:50 build/C/man3/fgetwc.3:28
#: build/C/man3/flockfile.3:49 build/C/man3/fmemopen.3:42
#: build/C/man3/fmtmsg.3:22 build/C/man3/fopen.3:63
#: build/C/man3/fopencookie.3:35 build/C/man3/fpurge.3:40
#: build/C/man3/fputwc.3:26 build/C/man3/fread.3:56 build/C/man3/fseek.3:55
#: build/C/man3/fseeko.3:35 build/C/man3/getline.3:56 build/C/man3/gets.3:44
#: build/C/man3/getw.3:57 build/C/man2/link.2:38 build/C/man2/llseek.2:38
#: build/C/man2/lseek.2:54 build/C/man3/lseek64.3:34 build/C/man2/open.2:66
#: build/C/man3/perror.3:54 build/C/man2/pipe.2:51 build/C/man3/popen.3:62
#: build/C/man3/printf.3:76 build/C/man3/puts.3:41 build/C/man2/read.2:44
#: build/C/man2/readlink.2:61 build/C/man2/readv.2:56 build/C/man3/remove.3:38
#: build/C/man2/rename.2:39 build/C/man2/rmdir.2:37 build/C/man3/scanf.3:85
#: build/C/man3/setbuf.3:71 build/C/man3/stdin.3:20 build/C/man3/stdio.3:48
#: build/C/man3/stdio_ext.3:52 build/C/man2/symlink.2:52
#: build/C/man3/tempnam.3:40 build/C/man3/tmpfile.3:38
#: build/C/man3/tmpnam.3:34 build/C/man2/unlink.2:39
#: build/C/man3/unlocked_stdio.3:104 build/C/man3/wprintf.3:58
#: build/C/man2/write.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/asprintf.3:51
msgid ""
"The functions B<asprintf>()  and B<vasprintf>()  are analogs of B<sprintf>"
"(3)  and B<vsprintf>(3), except that they allocate a string large enough to "
"hold the output including the terminating null byte, and return a pointer to "
"it via the first argument.  This pointer should be passed to B<free>(3)  to "
"release the allocated storage when it is no longer needed."
msgstr ""
"B<asprintf>()  関数と B<vasprintf>()  関数とは、それぞれ B<sprintf>(3)  関数"
"と B<vsprintf>(3)  関数とに似ているが、 出力文字列を (終端の NULL バイトも含"
"めて)  保持するのに十分な大きさのメモリを確保し、 最初の引数にその文字列への"
"ポインタを返す。 このポインタは、不要になったら B<free>(3)  に渡し、割り当て"
"られた記憶領域を解放すべきである。"

#. type: SH
#: build/C/man3/asprintf.3:51 build/C/man3/ctermid.3:57
#: build/C/man3/fclose.3:57 build/C/man3/fcloseall.3:49
#: build/C/man3/fflush.3:72 build/C/man3/fgetwc.3:53
#: build/C/man3/flockfile.3:112 build/C/man3/fmemopen.3:172
#: build/C/man3/fmtmsg.3:148 build/C/man3/fopen.3:187
#: build/C/man3/fopencookie.3:236 build/C/man3/fpurge.3:56
#: build/C/man3/fputwc.3:52 build/C/man3/fread.3:81 build/C/man3/fseek.3:117
#: build/C/man3/fseeko.3:63 build/C/man3/getline.3:108 build/C/man3/gets.3:109
#: build/C/man3/getw.3:71 build/C/man2/link.2:52 build/C/man2/llseek.2:57
#: build/C/man2/lseek.2:151 build/C/man2/open.2:464 build/C/man2/pipe.2:92
#: build/C/man3/popen.3:121 build/C/man3/puts.3:82 build/C/man2/read.2:63
#: build/C/man2/readlink.2:75 build/C/man2/readv.2:175
#: build/C/man3/remove.3:60 build/C/man2/rename.2:91 build/C/man2/rmdir.2:40
#: build/C/man3/scanf.3:528 build/C/man3/setbuf.3:150
#: build/C/man2/symlink.2:84 build/C/man3/tempnam.3:85
#: build/C/man3/tmpfile.3:45 build/C/man3/tmpnam.3:68 build/C/man2/unlink.2:55
#: build/C/man3/wprintf.3:185 build/C/man2/write.2:89
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/asprintf.3:59
msgid ""
"When successful, these functions return the number of bytes printed, just "
"like B<sprintf>(3).  If memory allocation wasn't possible, or some other "
"error occurs, these functions will return -1, and the contents of I<strp> is "
"undefined."
msgstr ""
"成功すると、これらの関数は出力されたバイト数を (B<sprintf>(3)  のように) 返"
"す。 メモリの割り当てができなかったり、 その他エラーが生じると、 これらの関数"
"は -1 を返し、 I<strp> の内容は未定義となる。"

#. type: SH
#: build/C/man3/asprintf.3:59 build/C/man3/ctermid.3:59
#: build/C/man3/dprintf.3:68 build/C/man3/fclose.3:88
#: build/C/man3/fcloseall.3:54 build/C/man3/ferror.3:105
#: build/C/man3/fflush.3:91 build/C/man3/fgetwc.3:65
#: build/C/man3/flockfile.3:119 build/C/man3/fmemopen.3:191
#: build/C/man3/fmtmsg.3:221 build/C/man3/fopen.3:244
#: build/C/man3/fopencookie.3:243 build/C/man3/fpurge.3:68
#: build/C/man3/fputwc.3:63 build/C/man3/fread.3:101 build/C/man3/fseek.3:164
#: build/C/man3/fseeko.3:75 build/C/man3/getline.3:132 build/C/man3/gets.3:136
#: build/C/man3/getw.3:78 build/C/man2/link.2:128 build/C/man2/llseek.2:76
#: build/C/man2/lseek.2:189 build/C/man2/open.2:610 build/C/man3/perror.3:111
#: build/C/man2/pipe.2:118 build/C/man3/popen.3:167 build/C/man3/printf.3:806
#: build/C/man3/puts.3:101 build/C/man2/read.2:155 build/C/man2/readlink.2:123
#: build/C/man2/readv.2:212 build/C/man3/remove.3:70 build/C/man2/rename.2:229
#: build/C/man2/rmdir.2:127 build/C/man3/scanf.3:575 build/C/man3/setbuf.3:162
#: build/C/man3/stdin.3:109 build/C/man3/stdio.3:244
#: build/C/man2/symlink.2:144 build/C/man3/tempnam.3:94
#: build/C/man3/tmpfile.3:74 build/C/man3/tmpnam.3:75
#: build/C/man2/unlink.2:141 build/C/man3/unlocked_stdio.3:111
#: build/C/man3/wprintf.3:193 build/C/man2/write.2:179
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/asprintf.3:65
msgid ""
"These functions are GNU extensions, not in C or POSIX.  They are also "
"available under *BSD.  The FreeBSD implementation sets I<strp> to NULL on "
"error."
msgstr ""
"これらの関数は GNU の拡張であり、C や POSIX のものではない。 これらは *BSD で"
"も利用できる。 FreeBSD の実装では、エラーの際には I<strp> を NULL にセットす"
"る。"

#. type: SH
#: build/C/man3/asprintf.3:65 build/C/man3/ctermid.3:69
#: build/C/man3/dprintf.3:94 build/C/man3/fclose.3:100
#: build/C/man3/fcloseall.3:56 build/C/man3/ferror.3:112
#: build/C/man3/fflush.3:106 build/C/man3/fgetwc.3:82
#: build/C/man3/flockfile.3:127 build/C/man3/fmemopen.3:337
#: build/C/man3/fmtmsg.3:293 build/C/man3/fopen.3:346
#: build/C/man3/fopencookie.3:435 build/C/man3/fpurge.3:78
#: build/C/man3/fputwc.3:80 build/C/man3/fread.3:103 build/C/man3/fseek.3:166
#: build/C/man3/fseeko.3:81 build/C/man3/getline.3:166 build/C/man3/gets.3:171
#: build/C/man3/getw.3:84 build/C/man2/link.2:177 build/C/man2/llseek.2:82
#: build/C/man2/lseek.2:234 build/C/man3/lseek64.3:157 build/C/man2/open.2:882
#: build/C/man3/perror.3:139 build/C/man2/pipe.2:190 build/C/man3/popen.3:196
#: build/C/man3/printf.3:1074 build/C/man3/puts.3:110 build/C/man2/read.2:178
#: build/C/man2/readlink.2:212 build/C/man2/readv.2:282
#: build/C/man3/remove.3:81 build/C/man2/rename.2:242 build/C/man2/rmdir.2:132
#: build/C/man3/scanf.3:717 build/C/man3/setbuf.3:198 build/C/man3/stdin.3:150
#: build/C/man3/stdio.3:248 build/C/man3/stdio_ext.3:130
#: build/C/man2/symlink.2:159 build/C/man7/symlink.7:470
#: build/C/man3/tempnam.3:164 build/C/man3/tmpfile.3:86
#: build/C/man3/tmpnam.3:151 build/C/man2/unlink.2:148
#: build/C/man3/unlocked_stdio.3:134 build/C/man3/wprintf.3:229
#: build/C/man2/write.2:205
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/asprintf.3:69
msgid "B<free>(3), B<malloc>(3), B<printf>(3)"
msgstr "B<free>(3), B<malloc>(3), B<printf>(3)"

#. type: SH
#: build/C/man3/asprintf.3:69 build/C/man3/ctermid.3:71
#: build/C/man3/dprintf.3:96 build/C/man3/fclose.3:106
#: build/C/man3/fcloseall.3:62 build/C/man3/ferror.3:117
#: build/C/man3/fflush.3:114 build/C/man3/fgetwc.3:87
#: build/C/man3/flockfile.3:129 build/C/man3/fmemopen.3:340
#: build/C/man3/fmtmsg.3:296 build/C/man3/fopen.3:352
#: build/C/man3/fopencookie.3:440 build/C/man3/fpurge.3:83
#: build/C/man3/fputwc.3:84 build/C/man3/fread.3:109 build/C/man3/fseek.3:169
#: build/C/man3/fseeko.3:83 build/C/man3/getline.3:173 build/C/man3/gets.3:187
#: build/C/man3/getw.3:90 build/C/man2/link.2:187 build/C/man2/llseek.2:85
#: build/C/man2/lseek.2:241 build/C/man3/lseek64.3:160 build/C/man2/open.2:904
#: build/C/man3/perror.3:144 build/C/man2/pipe.2:197 build/C/man3/popen.3:206
#: build/C/man3/printf.3:1083 build/C/man3/puts.3:122 build/C/man2/read.2:191
#: build/C/man2/readlink.2:220 build/C/man2/readv.2:286
#: build/C/man3/remove.3:92 build/C/man2/rename.2:251 build/C/man2/rmdir.2:141
#: build/C/man3/scanf.3:724 build/C/man3/setbuf.3:206 build/C/man3/stdin.3:156
#: build/C/man3/stdio.3:255 build/C/man3/stdio_ext.3:133
#: build/C/man2/symlink.2:171 build/C/man7/symlink.7:488
#: build/C/man3/tempnam.3:169 build/C/man3/tmpfile.3:92
#: build/C/man3/tmpnam.3:156 build/C/man2/unlink.2:161
#: build/C/man3/unlocked_stdio.3:137 build/C/man3/wprintf.3:236
#: build/C/man2/write.2:217
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/asprintf.3:76 build/C/man3/ctermid.3:78
#: build/C/man3/dprintf.3:103 build/C/man3/fclose.3:113
#: build/C/man3/fcloseall.3:69 build/C/man3/ferror.3:124
#: build/C/man3/fflush.3:121 build/C/man3/fgetwc.3:94
#: build/C/man3/flockfile.3:136 build/C/man3/fmemopen.3:347
#: build/C/man3/fmtmsg.3:303 build/C/man3/fopen.3:359
#: build/C/man3/fopencookie.3:447 build/C/man3/fpurge.3:90
#: build/C/man3/fputwc.3:91 build/C/man3/fread.3:116 build/C/man3/fseek.3:176
#: build/C/man3/fseeko.3:90 build/C/man3/getline.3:180 build/C/man3/gets.3:194
#: build/C/man3/getw.3:97 build/C/man2/link.2:194 build/C/man2/llseek.2:92
#: build/C/man2/lseek.2:248 build/C/man3/lseek64.3:167 build/C/man2/open.2:911
#: build/C/man3/perror.3:151 build/C/man2/pipe.2:204 build/C/man3/popen.3:213
#: build/C/man3/printf.3:1090 build/C/man3/puts.3:129 build/C/man2/read.2:198
#: build/C/man2/readlink.2:227 build/C/man2/readv.2:293
#: build/C/man3/remove.3:99 build/C/man2/rename.2:258 build/C/man2/rmdir.2:148
#: build/C/man3/scanf.3:731 build/C/man3/setbuf.3:213 build/C/man3/stdin.3:163
#: build/C/man3/stdio.3:262 build/C/man3/stdio_ext.3:140
#: build/C/man2/symlink.2:178 build/C/man7/symlink.7:495
#: build/C/man3/tempnam.3:176 build/C/man3/tmpfile.3:99
#: build/C/man3/tmpnam.3:163 build/C/man2/unlink.2:168
#: build/C/man3/unlocked_stdio.3:144 build/C/man3/wprintf.3:243
#: build/C/man2/write.2:224
#, fuzzy
#| msgid ""
#| "This page is part of release 3.40 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.40 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/ctermid.3:24
#, no-wrap
msgid "CTERMID"
msgstr "CTERMID"

#. type: TH
#: build/C/man3/ctermid.3:24
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: build/C/man3/ctermid.3:27
msgid "ctermid - get controlling terminal name"
msgstr "ctermid - 制御端末名の取得"

#. type: Plain text
#: build/C/man3/ctermid.3:32 build/C/man3/fgetwc.3:22
#: build/C/man3/flockfile.3:29 build/C/man3/fmemopen.3:12
#: build/C/man3/fopen.3:48 build/C/man3/fputwc.3:20 build/C/man3/fread.3:49
#: build/C/man3/fseeko.3:29 build/C/man3/getline.3:30 build/C/man3/gets.3:31
#: build/C/man3/getw.3:29 build/C/man3/popen.3:44 build/C/man3/puts.3:30
#: build/C/man3/scanf.3:56 build/C/man3/setbuf.3:52 build/C/man3/stdin.3:15
#: build/C/man3/tempnam.3:29 build/C/man3/tmpfile.3:35
#: build/C/man3/tmpnam.3:31 build/C/man3/unlocked_stdio.3:30
#, no-wrap
msgid "B<#include E<lt>stdio.hE<gt>>\n"
msgstr "B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ctermid.3:34
#, no-wrap
msgid "B<char *ctermid(char *>I<s>B<);>\n"
msgstr "B<char *ctermid(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/ctermid.3:39 build/C/man3/dprintf.3:38
#: build/C/man3/ferror.3:59 build/C/man3/flockfile.3:40
#: build/C/man3/fmemopen.3:25 build/C/man3/fopen.3:59
#: build/C/man3/getline.3:40 build/C/man3/getw.3:38 build/C/man3/perror.3:49
#: build/C/man3/popen.3:53 build/C/man3/printf.3:63 build/C/man2/readlink.2:52
#: build/C/man2/readv.2:51 build/C/man3/scanf.3:71 build/C/man3/setbuf.3:66
#: build/C/man2/symlink.2:43 build/C/man3/tempnam.3:36
#: build/C/man3/unlocked_stdio.3:66 build/C/man3/wprintf.3:37
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#.  From <unistd.h>: _XOPEN_SOURCE
#. type: Plain text
#: build/C/man3/ctermid.3:44
msgid ""
"B<ctermid>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<ctermid>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/ctermid.3:57
msgid ""
"B<ctermid>()  returns a string which is the pathname for the current "
"controlling terminal for this process.  If I<s> is NULL, a static buffer is "
"used, otherwise I<s> points to a buffer used to hold the terminal pathname.  "
"The symbolic constant B<L_ctermid> is the maximum number of characters in "
"the returned pathname."
msgstr ""
"B<ctermid>()  はプロセスの現在の制御端末のパス名を返す。 I<s> が NULL の場"
"合、静的なバッファを用いる。それ以外の場合、 I<s> は端末パス名を保持するのに"
"使用されるバッファへのポインタとなる。 シンボル定数 B<L_ctermid> は返されるパ"
"ス名の最大文字数である。"

#. type: Plain text
#: build/C/man3/ctermid.3:59
msgid "The pointer to the pathname."
msgstr "パス名へのポインタ。"

#. type: Plain text
#: build/C/man3/ctermid.3:61
msgid "Svr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#. type: SH
#: build/C/man3/ctermid.3:61 build/C/man3/fmemopen.3:209
#: build/C/man3/fopen.3:329 build/C/man3/gets.3:150 build/C/man3/getw.3:80
#: build/C/man2/link.2:171 build/C/man2/open.2:871 build/C/man3/popen.3:173
#: build/C/man3/printf.3:929 build/C/man3/puts.3:103 build/C/man2/readv.2:256
#: build/C/man3/remove.3:78 build/C/man2/rename.2:231 build/C/man2/rmdir.2:129
#: build/C/man3/scanf.3:682 build/C/man3/setbuf.3:168
#: build/C/man3/tempnam.3:154 build/C/man3/tmpnam.3:144
#: build/C/man2/unlink.2:145
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/ctermid.3:65
msgid ""
"The path returned may not uniquely identify the controlling terminal; it "
"may, for example, be I</dev/tty>."
msgstr ""
"返されたパスはたぶん制御端末を一意には特定できない。 たとえば I</dev/tty> の"
"ように。"

#.  in glibc 2.3.x, x >= 4, the glibc headers threw an error
#.  if ctermid() was given an argument; fixed in 2.4.
#. type: Plain text
#: build/C/man3/ctermid.3:69
msgid "It is not assured that the program can open the terminal."
msgstr "プログラムが端末をオープンできることは保証されていない。"

#. type: Plain text
#: build/C/man3/ctermid.3:71
msgid "B<ttyname>(3)"
msgstr "B<ttyname>(3)"

#. type: TH
#: build/C/man3/dprintf.3:25
#, no-wrap
msgid "DPRINTF"
msgstr "DPRINTF"

#. type: TH
#: build/C/man3/dprintf.3:25
#, no-wrap
msgid "2010-09-15"
msgstr "2010-09-15"

#. type: Plain text
#: build/C/man3/dprintf.3:28
msgid "dprintf, vdprintf - print to a file descriptor"
msgstr "dprintf, vdprintf - ファイルディスクリプタに文字出力する"

#. type: Plain text
#: build/C/man3/dprintf.3:32
msgid "B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>"
msgstr "B<int dprintf(int >I<fd>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: build/C/man3/dprintf.3:34
msgid ""
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int vdprintf(int >I<fd>B<, const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: build/C/man3/dprintf.3:42
msgid "B<dprintf>(), B<vdprintf>():"
msgstr "B<dprintf>(), B<vdprintf>():"

#. type: TP
#: build/C/man3/dprintf.3:45 build/C/man3/fmemopen.3:33
#: build/C/man3/getline.3:47
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/dprintf.3:48 build/C/man3/fmemopen.3:36
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man3/dprintf.3:48 build/C/man3/fmemopen.3:36
#: build/C/man3/getline.3:50
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/dprintf.3:51 build/C/man3/fmemopen.3:39
#: build/C/man3/getline.3:53 build/C/man3/unlocked_stdio.3:102
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/dprintf.3:68
msgid ""
"The functions B<dprintf>()  and B<vdprintf>()  (as found in the glibc2 "
"library) are exact analogs of B<fprintf>(3)  and B<vfprintf>(3), except that "
"they output to a file descriptor I<fd> instead of to a I<stdio> stream."
msgstr ""
"(glibc2 ライブラリにおける)  B<dprintf>()  関数と B<vdprintf>()  関数とは、そ"
"れぞれ B<fprintf>(3)  関数と B<vfprintf>(3)  関数とにちょうど対応するが、 こ"
"れらは I<stdio> ストリームではなくファイルディスクリプタ I<fd> に対して出力を"
"行う。"

#.  .SH NOTES
#.  These functions are GNU extensions, not in C or POSIX.
#.  Clearly, the names were badly chosen.
#.  Many systems (like MacOS) have incompatible functions called
#.  .BR dprintf (),
#.  usually some debugging version of
#.  .BR printf (3),
#.  perhaps with a prototype like
#.  .BI "void dprintf(int level, const char *" format ", ...);"
#.  where the first argument is a debugging level (and output is to
#.  .IR stderr ).
#.  Moreover,
#.  .BR dprintf ()
#.  (or
#.  .BR DPRINTF )
#.  is also a popular macro name for a debugging printf.
#.  So, probably, it is better to avoid this function in programs
#.  intended to be portable.
#.  A better name would have been
#.  .BR fdprintf ().
#. type: Plain text
#: build/C/man3/dprintf.3:94
msgid ""
"These functions are GNU extensions that are nowadays specified in "
"POSIX.1-2008."
msgstr ""
"これらの関数は GNU による拡張であり、 現在では POSIX.1-2008 で規定されてい"
"る。"

#. type: Plain text
#: build/C/man3/dprintf.3:96
msgid "B<printf>(3)"
msgstr "B<printf>(3)"

#. type: TH
#: build/C/man3/fclose.3:42
#, no-wrap
msgid "FCLOSE"
msgstr "FCLOSE"

#. type: TH
#: build/C/man3/fclose.3:42 build/C/man2/read.2:35
#, no-wrap
msgid "2009-02-23"
msgstr "2009-02-23"

#. type: Plain text
#: build/C/man3/fclose.3:45
msgid "fclose - close a stream"
msgstr "fclose - ストリームを閉じる"

#. type: Plain text
#: build/C/man3/fclose.3:49
msgid "B<int fclose(FILE *>I<fp>B<);>"
msgstr "B<int fclose(FILE *>I<fp>B<);>"

#. type: Plain text
#: build/C/man3/fclose.3:57
#, fuzzy
#| msgid ""
#| "The B<fclose>()  function will flushes the stream pointed to by I<fp> "
#| "(writing any buffered output data using B<fflush>(3))  and closes the "
#| "underlying file descriptor."
msgid ""
"The B<fclose>()  function flushes the stream pointed to by I<fp> (writing "
"any buffered output data using B<fflush>(3))  and closes the underlying file "
"descriptor."
msgstr ""
"B<fclose>()  関数は I<fp> で指されるストリームを (バッファリングされていた全"
"ての出力データを B<fflush>(3)  を用いて書き込んで) フラッシュし、 その基とな"
"るファイルディスクリプタをクローズする。"

#. type: Plain text
#: build/C/man3/fclose.3:68
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error.  In either case any further access "
"(including another call to B<fclose>())  to the stream results in undefined "
"behavior."
msgstr ""
"関数が正常に終了すると 0 が返される。 正常に終了しなかった場合には B<EOF> が"
"返され、 I<errno> がエラーを示すために設定される。 どちらの場合も、そのスト"
"リームに対する (B<fclose>()  へのさらなる呼び出しを含む) それ以上のアクセス"
"は 未定義の動作を生じさせる。"

#. type: SH
#: build/C/man3/fclose.3:68 build/C/man3/ferror.3:95 build/C/man3/fflush.3:79
#: build/C/man3/fgetwc.3:59 build/C/man3/flockfile.3:117
#: build/C/man3/fopen.3:199 build/C/man3/fpurge.3:63 build/C/man3/fputwc.3:58
#: build/C/man3/fseek.3:132 build/C/man3/fseeko.3:72
#: build/C/man3/getline.3:120 build/C/man2/link.2:57 build/C/man2/llseek.2:64
#: build/C/man2/lseek.2:159 build/C/man2/open.2:472 build/C/man2/pipe.2:97
#: build/C/man3/popen.3:141 build/C/man2/read.2:77 build/C/man2/readlink.2:83
#: build/C/man2/readv.2:186 build/C/man3/remove.3:65 build/C/man2/rename.2:96
#: build/C/man2/rmdir.2:45 build/C/man3/scanf.3:545 build/C/man2/symlink.2:89
#: build/C/man3/tempnam.3:90 build/C/man3/tmpfile.3:52
#: build/C/man3/tmpnam.3:73 build/C/man2/unlink.2:60 build/C/man2/write.2:107
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/fclose.3:69 build/C/man3/fflush.3:80 build/C/man3/fpurge.3:64
#: build/C/man3/fseek.3:133 build/C/man2/llseek.2:65 build/C/man2/lseek.2:160
#: build/C/man2/read.2:96 build/C/man3/scanf.3:551 build/C/man2/write.2:126
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#.   This error cannot occur unless you are mixing ANSI C stdio operations and
#.   low-level file operations on the same stream. If you do get this error,
#.   you must have closed the stream's low-level file descriptor using
#.   something like close(fileno(fp)).
#. type: Plain text
#: build/C/man3/fclose.3:78
msgid "The file descriptor underlying I<fp> is not valid."
msgstr "I<fp> の基となるファイルディスクリプタが不正である。"

#. type: Plain text
#: build/C/man3/fclose.3:88
msgid ""
"The B<fclose>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<close>(2), B<write>(2)  or B<fflush>(3)."
msgstr ""
"B<fclose>()  関数はこれ以外にも B<close>(2), B<write>(2), B<fflush>(3)  の"
"ルーチンで失敗することがある。その場合は I<errno> が、失敗したルーチンで設定"
"された値に設定される。"

#. type: Plain text
#: build/C/man3/fclose.3:90 build/C/man3/fseek.3:166 build/C/man3/puts.3:103
msgid "C89, C99."
msgstr "C89, C99."

#. type: SH
#: build/C/man3/fclose.3:90 build/C/man3/fflush.3:97 build/C/man3/fgetwc.3:67
#: build/C/man3/fmemopen.3:203 build/C/man3/fmtmsg.3:236
#: build/C/man3/fopen.3:253 build/C/man3/fpurge.3:76 build/C/man3/fputwc.3:65
#: build/C/man3/fseeko.3:77 build/C/man2/link.2:133 build/C/man2/llseek.2:79
#: build/C/man2/lseek.2:199 build/C/man2/open.2:636 build/C/man3/perror.3:124
#: build/C/man3/printf.3:867 build/C/man2/read.2:157
#: build/C/man2/readlink.2:128 build/C/man2/readv.2:224
#: build/C/man3/remove.3:72 build/C/man3/scanf.3:606 build/C/man3/stdin.3:118
#: build/C/man2/symlink.2:150 build/C/man3/tempnam.3:99
#: build/C/man3/tmpfile.3:76 build/C/man3/tmpnam.3:80
#: build/C/man3/wprintf.3:195 build/C/man2/write.2:188
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/fclose.3:100
msgid ""
"Note that B<fclose>()  only flushes the user space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"B<fclose>()  は C ライブラリで提供されたユーザー空間バッファをフラッシュする"
"だけで ある点に注意すること。 データを確実に物理的にディスクに記録するために"
"は カーネルバッファも (B<sync>(2)  や B<fsync>(2)  を用いて) フラッシュしなけ"
"ればならない。"

#. type: Plain text
#: build/C/man3/fclose.3:106
msgid "B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<close>(2), B<fcloseall>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: build/C/man3/fcloseall.3:24
#, no-wrap
msgid "FCLOSEALL"
msgstr "FCLOSEALL"

#. type: TH
#: build/C/man3/fcloseall.3:24
#, no-wrap
msgid "2006-12-27"
msgstr "2006-12-27"

#. type: Plain text
#: build/C/man3/fcloseall.3:27
msgid "fcloseall - close all open streams"
msgstr "fcloseall - 開いているすべてのストリームを閉じる"

#. type: Plain text
#: build/C/man3/fcloseall.3:31 build/C/man3/fopencookie.3:31
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fcloseall.3:33
#, no-wrap
msgid "B<int fcloseall(void);>\n"
msgstr "B<int fcloseall(void);>\n"

#. type: Plain text
#: build/C/man3/fcloseall.3:42
msgid ""
"The B<fcloseall>()  function closes all of the calling process's open "
"streams.  Buffered output for each stream is written before it is closed (as "
"for B<fflush>(3)); buffered input is discarded."
msgstr ""
"B<fcloseall>()  関数は、呼び出し元プロセスが開いているすべてのストリームを閉"
"じる。 ストリームを閉じる前に、 (B<fflush>(3)  と同じように) 各ストリームの"
"バッファに溜っている出力データは書き出される。 入力バッファ内のデータは破棄さ"
"れる。"

#. type: Plain text
#: build/C/man3/fcloseall.3:49
msgid ""
"The standard streams, I<stdin>, I<stdout>, and I<stderr> are also closed."
msgstr "標準入出力 I<stdin>, I<stdout>, I<stderr> も閉じられる。"

#. type: Plain text
#: build/C/man3/fcloseall.3:54
msgid ""
"This function returns 0 if all files were successfully closed; on error, "
"B<EOF> is returned."
msgstr ""
"この関数は、すべてのファイルが正常に閉じられた場合 0 を返す。 エラーの場合、 "
"B<EOF> を返す。"

#. type: Plain text
#: build/C/man3/fcloseall.3:56
msgid "This function is a GNU extension."
msgstr "この関数は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/fcloseall.3:62
msgid "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"
msgstr "B<close>(2), B<fclose>(3), B<fflush>(3), B<fopen>(3), B<setbuf>(3)"

#. type: TH
#: build/C/man3/ferror.3:42
#, no-wrap
msgid "FERROR"
msgstr "FERROR"

#. type: TH
#: build/C/man3/ferror.3:42 build/C/man3/flockfile.3:23
#: build/C/man3/unlocked_stdio.3:23
#, no-wrap
msgid "2008-08-29"
msgstr "2008-08-29"

#. type: Plain text
#: build/C/man3/ferror.3:45
msgid "clearerr, feof, ferror, fileno - check and reset stream status"
msgstr ""
"clearerr, feof, ferror, fileno - ストリームステータスのチェックとリセット"

#. type: Plain text
#: build/C/man3/ferror.3:49
msgid "B<void clearerr(FILE *>I<stream>B<);>"
msgstr "B<void clearerr(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:51
msgid "B<int feof(FILE *>I<stream>B<);>"
msgstr "B<int feof(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:53
msgid "B<int ferror(FILE *>I<stream>B<);>"
msgstr "B<int ferror(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:55
msgid "B<int fileno(FILE *>I<stream>B<);>"
msgstr "B<int fileno(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/ferror.3:63
msgid ""
"B<fileno>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<fileno>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/ferror.3:68
msgid ""
"The function B<clearerr>()  clears the end-of-file and error indicators for "
"the stream pointed to by I<stream>."
msgstr ""
"関数 B<clearerr>()  は I<stream> で示されるストリームの EOF(end-of-file) 指示"
"子とエラー指示子をクリアする。"

#. type: Plain text
#: build/C/man3/ferror.3:77
msgid ""
"The function B<feof>()  tests the end-of-file indicator for the stream "
"pointed to by I<stream>, returning nonzero if it is set.  The end-of-file "
"indicator can only be cleared by the function B<clearerr>()."
msgstr ""
"関数 B<feof>()  は I<stream> で示されるストリームの EOF 指示子をテストし、 "
"セットされていれば 0 以外の数を返す。 EOF 指示子は、関数 B<clearerr>()  に"
"よってのみクリアすることができる。"

#. type: Plain text
#: build/C/man3/ferror.3:86
msgid ""
"The function B<ferror>()  tests the error indicator for the stream pointed "
"to by I<stream>, returning nonzero if it is set.  The error indicator can "
"only be reset by the B<clearerr>()  function."
msgstr ""
"関数 B<ferror>()  は I<stream> で示されるストリームのエラー指示子をテスト"
"し、 セットされていれば 0 以外の数を返す。 エラー指示子は、関数 B<clearerr>"
"()  によってのみリセットすることができる。"

#. type: Plain text
#: build/C/man3/ferror.3:92
msgid ""
"The function B<fileno>()  examines the argument I<stream> and returns its "
"integer descriptor."
msgstr ""
"関数 B<fileno>()  は、引数 I<stream> を調べ、その整数のディスクリプタを返す。"

#. type: Plain text
#: build/C/man3/ferror.3:95 build/C/man3/fgetwc.3:53 build/C/man3/fputwc.3:52
#: build/C/man3/fread.3:81 build/C/man3/gets.3:109 build/C/man3/puts.3:82
msgid "For nonlocking counterparts, see B<unlocked_stdio>(3)."
msgstr ""
"これらの処理を停止せずに行いたいときは、 B<unlocked_stdio>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/ferror.3:105
msgid ""
"These functions should not fail and do not set the external variable "
"I<errno>.  (However, in case B<fileno>()  detects that its argument is not a "
"valid stream, it must return -1 and set I<errno> to B<EBADF>.)"
msgstr ""
"これらの関数は失敗すべきではなく、また、外部変数 I<errno> に値をセットしな"
"い。 (しかし、 B<fileno>()  関数の場合で、引数が有効なストリームでなかった場"
"合、 関数は -1 を返し、 I<errno> に B<EBADF> を設定しなければならない。)"

#. type: Plain text
#: build/C/man3/ferror.3:112
msgid ""
"The functions B<clearerr>(), B<feof>(), and B<ferror>()  conform to C89 and "
"C99."
msgstr ""
"関数 B<clearerr>(), B<feof>(), B<ferror>()  は C89 と C99 に準拠している。"

#. type: Plain text
#: build/C/man3/ferror.3:117
msgid "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"
msgstr "B<open>(2), B<fdopen>(3), B<stdio>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fflush.3:43
#, no-wrap
msgid "FFLUSH"
msgstr "FFLUSH"

#. type: TH
#: build/C/man3/fflush.3:43
#, no-wrap
msgid "2009-09-06"
msgstr "2009-09-06"

#. type: Plain text
#: build/C/man3/fflush.3:46
msgid "fflush - flush a stream"
msgstr "fflush - ストリームの内容を強制的に出力(フラッシュ)する"

#. type: Plain text
#: build/C/man3/fflush.3:50
msgid "B<int fflush(FILE *>I<stream>B<);>"
msgstr "B<int fflush(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fflush.3:61
msgid ""
"For output streams, B<fflush>()  forces a write of all user-space buffered "
"data for the given output or update I<stream> via the stream's underlying "
"write function.  For input streams, B<fflush>()  discards any buffered data "
"that has been fetched from the underlying file, but has not been consumed by "
"the application.  The open status of the stream is unaffected."
msgstr ""
"出力ストリームに関しては、 B<fflush>()  は、ユーザー空間でバッファリングされ"
"ているすべてのデータを 指定された出力に書き出す (フラッシュする)、 もしくはス"
"トリーム I<stream> の下位にある書き込み関数を用いてこのストリームを更新す"
"る。 入力ストリームに関しては、 B<fflush>()  は、対応するファイルから取得され"
"たが、アプリケーションからは 読み出されていないバッファデータを全て破棄す"
"る。 ストリームは開いた状態のままであり、 この関数によって何の影響も受けな"
"い。"

#. type: Plain text
#: build/C/man3/fflush.3:69
msgid ""
"If the I<stream> argument is NULL, B<fflush>()  flushes I<all> open output "
"streams."
msgstr ""
"I<stream> 引数が .BR NULL ならば、 B<fflush>()  は開いているI<すべての>出力ス"
"トリームをフラッシュする。"

#. type: Plain text
#: build/C/man3/fflush.3:72
msgid "For a nonlocking counterpart, see B<unlocked_stdio>(3)."
msgstr ""
"これらの処理をロックせずに行いたいときは、 B<unlocked_stdio>(3)  を参照のこ"
"と。"

#. type: Plain text
#: build/C/man3/fflush.3:79
msgid ""
"Upon successful completion 0 is returned.  Otherwise, B<EOF> is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると 0 が返される。 その他の場合には B<EOF> が返され、 I<errno> が、エ"
"ラーに対応した値に設定される。"

#. type: Plain text
#: build/C/man3/fflush.3:84
msgid "I<Stream> is not an open stream, or is not open for writing."
msgstr ""
"I<Stream> は開いているストリームではない。 あるいはストリームは書き込み用では"
"ない。"

#. type: Plain text
#: build/C/man3/fflush.3:91
msgid ""
"The function B<fflush>()  may also fail and set I<errno> for any of the "
"errors specified for B<write>(2)."
msgstr ""
"B<fflush>()  関数は B<write>(2)  に関して規定されているエラーで失敗することも"
"ある。 この場合 I<errno> もその値に設定される。"

#. type: Plain text
#: build/C/man3/fflush.3:93
msgid "C89, C99, POSIX.1-2001, POSIX.1-2008."
msgstr "C89, C99, POSIX.1-2001, POSIX.1-2008."

#.  Verified on: Solaris 8.
#. type: Plain text
#: build/C/man3/fflush.3:97
msgid ""
"The standards do not specify the behavior for input streams.  Most other "
"implementations behave the same as Linux."
msgstr ""
"標準では、入力ストリームに対する動作は規定されていない。 他のほとんどの実装"
"は Linux と同じ動作をする。"

#. type: Plain text
#: build/C/man3/fflush.3:106
msgid ""
"Note that B<fflush>()  only flushes the user space buffers provided by the C "
"library.  To ensure that the data is physically stored on disk the kernel "
"buffers must be flushed too, for example, with B<sync>(2)  or B<fsync>(2)."
msgstr ""
"B<fflush>()  は、 C ライブラリが与えているユーザー空間のバッファしかフラッ"
"シュしない。 データが物理的にディスクに保存されることを保証したければ、 カー"
"ネルバッファもフラッシュしなければならない。 これには例えば B<sync>(2)  や "
"B<fsync>(2)  を用いる。"

#. type: Plain text
#: build/C/man3/fflush.3:114
msgid ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fopen>(3), B<setbuf>"
"(3), B<unlocked_stdio>(3)"
msgstr ""
"B<fsync>(2), B<sync>(2), B<write>(2), B<fclose>(3), B<fopen>(3), B<setbuf>"
"(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fgetwc.3:16
#, no-wrap
msgid "FGETWC"
msgstr "FGETWC"

#. type: TH
#: build/C/man3/fgetwc.3:16 build/C/man3/fputwc.3:14
#, no-wrap
msgid "1999-07-25"
msgstr "1999-07-25"

#. type: Plain text
#: build/C/man3/fgetwc.3:19
msgid "fgetwc, getwc - read a wide character from a FILE stream"
msgstr "fgetwc, getwc - ワイド文字を FILE ストリームから読み込む"

#. type: Plain text
#: build/C/man3/fgetwc.3:24 build/C/man3/fmemopen.3:18
#: build/C/man3/fputwc.3:22 build/C/man3/unlocked_stdio.3:52
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fgetwc.3:27
#, no-wrap
msgid ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fgetwc(FILE *>I<stream>B<);>\n"
"B<wint_t getwc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fgetwc.3:42
msgid ""
"The B<fgetwc>()  function is the wide-character equivalent of the B<fgetc>"
"(3)  function.  It reads a wide character from I<stream> and returns it.  If "
"the end of stream is reached, or if I<ferror(stream)> becomes true, it "
"returns B<WEOF>.  If a wide-character conversion error occurs, it sets "
"I<errno> to B<EILSEQ> and returns B<WEOF>."
msgstr ""
"B<fgetwc>()  関数は、 B<fgetc>(3)  に対応するワイド文字関数である。 この関数"
"は I<stream> からワイド文字を 1 文字読み込み、これを返す。 ストリームの終端に"
"達するか、I<ferror(stream)> が真になった場合には、 この関数は B<WEOF> を返"
"す。 ワイド文字変換でエラーが発生した場合は、 I<errno> に B<EILSEQ> をセット"
"し、 B<WEOF> を返す。"

#. type: Plain text
#: build/C/man3/fgetwc.3:50
msgid ""
"The B<getwc>()  function or macro functions identically to B<fgetwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""
"B<getwc>()  関数あるいはマクロは、 B<fgetwc>()  と全く同じ動作をする。 この関"
"数はマクロとして実装されるかもしれないので、引き数が複数回評価さ れるかもしれ"
"ない。この関数を使う理由はもはや存在しない。"

#. type: Plain text
#: build/C/man3/fgetwc.3:59
msgid ""
"The B<fgetwc>()  function returns the next wide-character from the stream, "
"or B<WEOF>."
msgstr ""
"B<fgetwc>()  関数はストリームの次のワイド文字か、あるいは B<WEOF> を返す。"

#. type: Plain text
#: build/C/man3/fgetwc.3:61 build/C/man3/fputwc.3:60
msgid "Apart from the usual ones, there is"
msgstr "通常のエラーに加えて、以下のエラーがある:"

#. type: TP
#: build/C/man3/fgetwc.3:61 build/C/man3/fputwc.3:60 build/C/man3/scanf.3:556
#, no-wrap
msgid "B<EILSEQ>"
msgstr "B<EILSEQ>"

#. type: Plain text
#: build/C/man3/fgetwc.3:65
msgid ""
"The data obtained from the input stream does not form a valid character."
msgstr "入力ストリームから取得したデータが、正しい文字でない。"

#. type: Plain text
#: build/C/man3/fgetwc.3:67 build/C/man3/fputwc.3:65
msgid "C99, POSIX.1-2001."
msgstr "C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/fgetwc.3:74
msgid ""
"The behavior of B<fgetwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr ""
"B<fgetwc>()  の動作は、現在のロケールの B<LC_CTYPE> カテゴリに依存する。"

#. type: Plain text
#: build/C/man3/fgetwc.3:82
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fgetwc>()  will actually read a multibyte "
"sequence from the stream and then convert it to a wide character."
msgstr ""
"B<fopen>(3)  システムコールに渡す追加情報がない場合には、 B<fgetwc>()  が実"
"際 にはマルチバイトシーケンスをストリームから読み込み、これをワイド文字に 変"
"換すると期待することは適切である。"

#. type: Plain text
#: build/C/man3/fgetwc.3:87
msgid "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetws>(3), B<fputwc>(3), B<ungetwc>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/flockfile.3:23
#, no-wrap
msgid "FLOCKFILE"
msgstr "FLOCKFILE"

#. type: Plain text
#: build/C/man3/flockfile.3:26
msgid "flockfile, ftrylockfile, funlockfile - lock FILE for stdio"
msgstr "flockfile, ftrylockfile, funlockfile - 標準入出力 FILE のロックを行う"

#. type: Plain text
#: build/C/man3/flockfile.3:31
#, no-wrap
msgid "B<void flockfile(FILE *>I<filehandle>B<);>\n"
msgstr "B<void flockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: build/C/man3/flockfile.3:33
#, no-wrap
msgid "B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"
msgstr "B<int ftrylockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: build/C/man3/flockfile.3:35
#, no-wrap
msgid "B<void funlockfile(FILE *>I<filehandle>B<);>\n"
msgstr "B<void funlockfile(FILE *>I<filehandle>B<);>\n"

#. type: Plain text
#: build/C/man3/flockfile.3:44 build/C/man3/wprintf.3:41
msgid "All functions shown above:"
msgstr "上記の全ての関数:"

#. type: Plain text
#: build/C/man3/flockfile.3:47
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE "
"|| _POSIX_SOURCE"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE "
"|| _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/flockfile.3:61
msgid ""
"The stdio functions are thread-safe.  This is achieved by assigning to each "
"I<FILE> object a lockcount and (if the lockcount is nonzero)  an owning "
"thread.  For each library call, these functions wait until the I<FILE> "
"object is no longer locked by a different thread, then lock it, do the "
"requested I/O, and unlock the object again."
msgstr ""
"標準入出力関数はスレッドセーフである。これは、各 I<FILE> オブジェクトに対し、"
"ロック数 (lockcount) と (ロック数が 0 でない場合は) 所有者スレッド (owner "
"thread)  を管理することで実現される。 ライブラリの呼び出しが行われる毎に、標"
"準入出力関数は I<FILE> オブジェクトが他のスレッドによってロックされていない状"
"態になるまで待ち、 I<FILE> オブジェクトをロックし、要求されて入出力を行い、 "
"オブジェクトのロックを解除する。"

#. type: Plain text
#: build/C/man3/flockfile.3:67
msgid ""
"(Note: this locking has nothing to do with the file locking done by "
"functions like B<flock>(2)  and B<lockf>(3).)"
msgstr ""
"(注: このロックは、 B<flock>(2)  や B<lockf>(3)  といった関数が行うロックとは"
"全く無関係である。)"

#. type: Plain text
#: build/C/man3/flockfile.3:75
msgid ""
"All this is invisible to the C-programmer, but there may be two reasons to "
"wish for more detailed control.  On the one hand, maybe a series of I/O "
"actions by one thread belongs together, and should not be interrupted by the "
"I/O of some other thread.  On the other hand, maybe the locking overhead "
"should be avoided for greater efficiency."
msgstr ""
"これらのことはすべて C プログラマには見えない部分で行われるが、 より細かい制"
"御ができた方がよい理由が2つあるだろう。一つは、一つのスレッドが 行う一連の入"
"出力動作は一緒に行われ、他のスレッドの入出力によって中断されない 方がよいとい"
"うことであろう。もう一つは、効率を大きく上げるためには ロックのオーバヘッドを"
"避ける必要があるということであろう。"

#. type: Plain text
#: build/C/man3/flockfile.3:92
msgid ""
"To this end, a thread can explicitly lock the I<FILE> object, then do its "
"series of I/O actions, then unlock.  This prevents other threads from coming "
"in between.  If the reason for doing this was to achieve greater efficiency, "
"one does the I/O with the nonlocking versions of the stdio functions: with "
"B<getc_unlocked>(3)  and B<putc_unlocked>(3)  instead of B<getc>(3)  and "
"B<putc>(3)."
msgstr ""
"この目的を実現するために、 I<FILE> オブジェクトのロック、一連の入出力動作の実"
"行、 ロックの解除をスレッドが明示的に指示することができる。 これにより、他の"
"スレッドが途中で入出力を行うのを防止する。 このようなことを行う理由が効率の向"
"上であるならば、 ロックを行わないバージョンの標準入出力関数を使うこともでき"
"る。 例えば、 B<getc>(3)  や B<putc>(3)  の代わりに B<getc_unlocked>(3)  や "
"B<putc_unlocked>(3)  を使用する。"

#. type: Plain text
#: build/C/man3/flockfile.3:99
msgid ""
"The B<flockfile>()  function waits for I<*filehandle> to be no longer locked "
"by a different thread, then makes the current thread owner of "
"I<*filehandle>, and increments the lockcount."
msgstr ""
"B<flockfile>()  関数は、I<*filehandle> が他のスレッドにロックされていな い状"
"態になるまで待ったのち、現在のスレッドを I<*filehandle> のオーナに設 定し、"
"ロック数を加算する。"

#. type: Plain text
#: build/C/man3/flockfile.3:103
msgid "The B<funlockfile>()  function decrements the lock count."
msgstr "B<funlockfile>()  関数は、ロック数を減算する。"

#. type: Plain text
#: build/C/man3/flockfile.3:112
msgid ""
"The B<ftrylockfile>()  function is a nonblocking version of B<flockfile>().  "
"It does nothing in case some other thread owns I<*filehandle>, and it "
"obtains ownership and increments the lockcount otherwise."
msgstr ""
"B<ftrylockfile>()  関数は B<flockfile>()  のブロッキングを行わない バージョン"
"である。他のスレッドが I<*filehandle> をロックしている時は 何も行わず、そうで"
"ない場合は I<*filehandle> の所有権を獲得し、 ロック数を加算する。"

#. type: Plain text
#: build/C/man3/flockfile.3:117
msgid ""
"The B<ftrylockfile>()  function returns zero for success (the lock was "
"obtained), and nonzero for failure."
msgstr ""
"B<ftrylockfile>()  関数はロックに成功すると 0 を返し、 失敗した場合は 0 以外"
"の値を返す。"

#. type: Plain text
#: build/C/man3/flockfile.3:119
msgid "None."
msgstr "なし。"

#. type: Plain text
#: build/C/man3/flockfile.3:121 build/C/man3/popen.3:169
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: SH
#: build/C/man3/flockfile.3:121
#, no-wrap
msgid "AVAILABILITY"
msgstr "可用性"

#. type: Plain text
#: build/C/man3/flockfile.3:127
msgid ""
"These functions are available when B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined.  They are in libc since libc 5.1.1 and in glibc since glibc 2.0."
msgstr ""
"B<_POSIX_THREAD_SAFE_FUNCTIONS> が定義されているときにこれらの関数を使用する"
"ことができる。 5.1.1 以降の libc と 2.0 以降の glibc に存在する。"

#. type: Plain text
#: build/C/man3/flockfile.3:129
msgid "B<unlocked_stdio>(3)"
msgstr "B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fmemopen.3:6
#, no-wrap
msgid "FMEMOPEN"
msgstr "FMEMOPEN"

#. type: TH
#: build/C/man3/fmemopen.3:6
#, fuzzy, no-wrap
#| msgid "2012-04-22"
msgid "2012-04-28"
msgstr "2012-04-22"

#. type: Plain text
#: build/C/man3/fmemopen.3:9
msgid "fmemopen, open_memstream, open_wmemstream - open memory as stream"
msgstr ""
"fmemopen, open_memstream, open_wmemstream - メモリをストリームとしてオープン"
"する"

#. type: Plain text
#: build/C/man3/fmemopen.3:14
#, no-wrap
msgid "B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fmemopen(void *>I<buf>B<, size_t >I<size>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:16
#, no-wrap
msgid "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr "B<FILE *open_memstream(char **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:20
#, no-wrap
msgid "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"
msgstr "B<FILE *open_wmemstream(wchar_t **>I<ptr>B<, size_t *>I<sizeloc>B<);>\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:30
msgid "B<fmemopen>(), B<open_memstream>(), B<open_wmemstream>():"
msgstr "B<fmemopen>(), B<open_memstream>(), B<open_wmemstream>():"

#. type: Plain text
#: build/C/man3/fmemopen.3:53
msgid ""
"The B<fmemopen>()  function opens a stream that permits the access specified "
"by I<mode>.  The stream allows I/O to be performed on the string or memory "
"buffer pointed to by I<buf>.  This buffer must be at least I<size> bytes "
"long."
msgstr ""
"B<fmemopen>()  関数は、ストリームをオープンし、そのストリームに I<mode> で指"
"定されたアクセス許可を設定する。 そのストリームを通じて、 I<buf> で指定された"
"文字列やメモリバッファへの読み書きができる。 このバッファは少なくとも "
"I<size> バイトの長さでなければならない。"

#. type: Plain text
#: build/C/man3/fmemopen.3:73
#, fuzzy
#| msgid ""
#| "The argument I<mode> is the same as for B<fopen>(3).  If I<mode> "
#| "specifies an append mode, then the initial file position is set to the "
#| "location of the first null byte (\\(aq\\e0\\(aq) in the buffer; otherwise "
#| "the initial file position is set to the start of the buffer.  Since glibc "
#| "2.9, the letter 'b' may be specified as the second character in I<mode>.  "
#| "This provides \"binary\" mode: writes don't implicitly add a terminating "
#| "null byte, and B<fseek>(3)  B<SEEK_END> is relative to the end of the "
#| "buffer (i.e., the value specified by the I<size> argument), rather than "
#| "the current string length."
msgid ""
"The argument I<mode> is the same as for B<fopen>(3).  If I<mode> specifies "
"an append mode, then the initial file position is set to the location of the "
"first null byte (\\(aq\\e0\\(aq) in the buffer; otherwise the initial file "
"position is set to the start of the buffer.  Since glibc 2.9, the letter "
"\\(aqb\\(aq may be specified as the second character in I<mode>.  This "
"provides \"binary\" mode: writes don't implicitly add a terminating null "
"byte, and B<fseek>(3)  B<SEEK_END> is relative to the end of the buffer (i."
"e., the value specified by the I<size> argument), rather than the current "
"string length."
msgstr ""
"引き数 I<mode> は B<fopen>(3)  の場合と同じである。 I<mode> で追記モード "
"(append mode) が指定された場合、ファイル位置の初期値は バッファ中の最初の "
"NULL バイト (\\(aq\\e0\\(aq) の位置に設定される。 それ以外の場合は、ファイル"
"位置の初期値はバッファの先頭になる。 glibc 2.9 以降では、文字 'b' を I<mode> "
"の二番目の文字として指定することができる。 この文字は「バイナリ」モードを指定"
"するものである。 このモードでは、書き込み時に文字列終端のヌルバイトが黙って追"
"加 されることはない。また、 B<fseek>(3)  B<SEEK_END> は、文字列の長さからの相"
"対値ではなく、バッファの末尾 (I<size> で指定した値) からの相対値となる。"

#. type: Plain text
#: build/C/man3/fmemopen.3:85
msgid ""
"When a stream that has been opened for writing is flushed (B<fflush>(3))  or "
"closed (B<fclose>(3)), a null byte is written at the end of the buffer if "
"there is space.  The caller should ensure that an extra byte is available in "
"the buffer (and that I<size> counts that byte)  to allow for this."
msgstr ""
"書き込み用にオープンされたストリームをフラッシュ (B<fflush>(3))  やクローズ "
"(B<fclose>(3))  した時に、 (バッファに空きがあれば) NULL バイトがバッファの末"
"尾に書き込まれる。 このようにするためには、呼び出し元は バッファに 1バイト余"
"裕を作る (I<size> にこの 1バイトを含めた値を指定する) 必要がある。"

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1995
#.  and
#.  http://sources.redhat.com/ml/libc-alpha/2006-04/msg00064.html
#. type: Plain text
#: build/C/man3/fmemopen.3:103
msgid ""
"Attempts to write more than I<size> bytes to the buffer result in an error.  "
"(By default, such errors will only be visible when the I<stdio> buffer is "
"flushed.  Disabling buffering with I<setbuf(fp,\\ NULL)> may be useful to "
"detect errors at the time of an output operation.  Alternatively, the caller "
"can explicitly set I<buf> as the stdio stream buffer, at the same time "
"informing stdio of the buffer's size, using I<setbuffer(fp, buf, size)>.)"
msgstr ""
"バッファに I<size> バイトよりたくさん書き込もうとした場合には、エラーとな"
"る。 (デフォルトでは、このようなエラーが見えるのは I<stdio> バッファがフラッ"
"シュされた時だけである。 I<setbuf(fp,\\ NULL)> を使ってバッファリングを無効に"
"する方法は、 出力操作を行った時点でエラーを検出するのに役立つ。 別の方法とし"
"ては、 I<setbuffer(fp, buf, size)> を使って、呼び出し側が明示的に stdio スト"
"リームバッファとして I<buf> を指定し、バッファの指定時にバッファのサイズを "
"stdio に教える方法がある。)"

#. type: Plain text
#: build/C/man3/fmemopen.3:111
msgid ""
"In a stream opened for reading, null bytes (\\(aq\\e0\\(aq) in the buffer do "
"not cause read operations to return an end-of-file indication.  A read from "
"the buffer will only indicate end-of-file when the file pointer advances "
"I<size> bytes past the start of the buffer."
msgstr ""
"読み出し用にオープンされたストリームでは、 バッファ内に NULL バイト (\\(aq"
"\\e0\\(aq) があっても 読み出し操作がファイル末尾 (end-of-file) を返すことはな"
"い。 バッファからの読み出しでファイル末尾が返るのは、 ファイルポインタがバッ"
"ファの先頭から I<size> バイトを越えて先に進もうとした場合だけである。"

#. type: Plain text
#: build/C/man3/fmemopen.3:126
msgid ""
"If I<buf> is specified as NULL, then B<fmemopen>()  dynamically allocates a "
"buffer I<size> bytes long.  This is useful for an application that wants to "
"write data to a temporary buffer and then read it back again.  The buffer is "
"automatically freed when the stream is closed.  Note that the caller has no "
"way to obtain a pointer to the temporary buffer allocated by this call (but "
"see B<open_memstream>()  below)."
msgstr ""
"I<buf> に NULL が指定された場合、 B<fmemopen>()  は動的に I<size> バイトの長"
"さのバッファを確保する。 この方法は、一時バッファにデータの書き込みを行ってか"
"ら、 その内容を再度読み出すようなアプリケーションで有用である。 このバッファ"
"はストリームがクローズされるときに自動的に解放される。 呼び出し元からはこの関"
"数が割り当てた一時バッファへのポインタ値を 知る方法は存在しない点に注意 (下記"
"の B<open_memstream>()  も参照)。"

#. type: Plain text
#: build/C/man3/fmemopen.3:137
msgid ""
"The B<open_memstream>()  function opens a stream for writing to a buffer.  "
"The buffer is dynamically allocated (as with B<malloc>(3)), and "
"automatically grows as required.  After closing the stream, the caller "
"should B<free>(3)  this buffer."
msgstr ""
"B<open_memstream>()  関数は、バッファへの書き込み用にストリームをオープンす"
"る。 バッファは (B<malloc>(3)  を使って) 動的に割り当てられ、必要に応じて自動"
"的に伸長する。 ストリームをクローズした後で、呼び出し元はこのバッファを "
"B<free>(3)  すべきである。"

#. type: Plain text
#: build/C/man3/fmemopen.3:152
msgid ""
"When the stream is closed (B<fclose>(3))  or flushed (B<fflush>(3)), the "
"locations pointed to by I<ptr> and I<sizeloc> are updated to contain, "
"respectively, a pointer to the buffer and the current size of the buffer.  "
"These values remain valid only as long as the caller performs no further "
"output on the stream.  If further output is performed, then the stream must "
"again be flushed before trying to access these variables."
msgstr ""
"このストリームが クローズ (B<fclose>(3))  されたりフラッシュ (B<fflush>(3))  "
"された時に、 I<ptr> と I<sizeloc> の値はそれぞれバッファへのポインタとそのサ"
"イズに更新される。 これらの値は、呼び出し元がそのストリームに新たな書き込み"
"を 行わない場合に限り有効である。 ストリームに書き込みを行った際には、これら"
"の変数を参照する前に ストリームを再度フラッシュしなければならない。"

#. type: Plain text
#: build/C/man3/fmemopen.3:158
msgid ""
"A null byte is maintained at the end of the buffer.  This byte is I<not> "
"included in the size value stored at I<sizeloc>."
msgstr ""
"バッファ末尾の NULL バイトは保持される。 この NULL バイトは I<sizeloc> に格納"
"されるサイズには「含まれない」。"

#. type: Plain text
#: build/C/man3/fmemopen.3:166
msgid ""
"The stream's file position can be changed with B<fseek>(3)  or B<fseeko>"
"(3).  Moving the file position past the end of the data already written "
"fills the intervening space with zeros."
msgstr ""
"ストリームのファイル位置は B<fseek>(3)  や B<fseeko>(3)  で変更できる。 すで"
"にデータが書き込まれた領域の末尾より先にファイル位置を動かすと、 その間の領域"
"は 0 で埋められる。"

#. type: Plain text
#: build/C/man3/fmemopen.3:172
msgid ""
"The B<open_wmemstream>()  is similar to B<open_memstream>(), but operates on "
"wide characters instead of bytes."
msgstr ""
"B<open_wmemstream>()  は B<open_memstream>()  と同様だが、バイトではなくワイ"
"ド文字に対して操作を行う点が異なる。"

#. type: Plain text
#: build/C/man3/fmemopen.3:184
msgid ""
"Upon successful completion B<fmemopen>(), B<open_memstream>()  and "
"B<open_wmemstream>()  return a I<FILE> pointer.  Otherwise, NULL is returned "
"and I<errno> is set to indicate the error."
msgstr ""
"成功して終了した場合には、 B<fmemopen>(), B<open_memstream>(), "
"B<open_wmemstream>()  は I<FILE> ポインタを返す。 失敗した場合は、 NULL を返"
"し、 I<errno> にエラーを示す値をセットする。"

#. type: SH
#: build/C/man3/fmemopen.3:184 build/C/man3/fmtmsg.3:218
#: build/C/man3/getline.3:130 build/C/man2/pipe.2:113 build/C/man2/readv.2:207
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/fmemopen.3:191
msgid ""
"B<fmemopen>()  and B<open_memstream>()  were already available in glibc 1.0."
"x.  B<open_wmemstream>()  is available since glibc 2.4."
msgstr ""
"B<fmemopen>()  と B<open_memstream>()  は glibc 1.0.x ですでに利用可能であっ"
"た。 B<open_wmemstream>()  は glibc 2.4 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/fmemopen.3:195
msgid ""
"POSIX.1-2008.  These functions are not specified in POSIX.1-2001, and are "
"not widely available on other systems."
msgstr ""
"POSIX.1-2008.  これらの関数は POSIX.1-2001 では規定れていないが、 Linux 以外"
"のシステムで広く利用可能である。"

#.  http://austingroupbugs.net/view.php?id=396
#. type: Plain text
#: build/C/man3/fmemopen.3:203
msgid ""
"POSIX.1-2008 specifies that \\(aqb\\(aq in I<mode> shall be ignored.  "
"However, Technical Corrigendum 1 adjusts the standard to allow "
"implementation-specific treatment for this case, thus permitting the glibc "
"treatment of \\(aqb\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man3/fmemopen.3:209
msgid ""
"There is no file descriptor associated with the file stream returned by "
"these functions (i.e., B<fileno>(3)  will return an error if called on the "
"returned stream)."
msgstr ""
"これらの関数が返すファイルストリームに対応するファイル ディスクリプタはない "
"(つまり、返されたストリームに対して B<fileno>(3)  を呼び出すとエラーが返るこ"
"とになる)。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=1996
#. type: Plain text
#: build/C/man3/fmemopen.3:216
msgid ""
"In glibc before version 2.7, seeking past the end of a stream created by "
"B<open_memstream>()  does not enlarge the buffer; instead the B<fseek>(3)  "
"call fails, returning -1."
msgstr ""
"バージョン 2.7 より前の glibc では、 B<open_memstream>()  で作成されたスト"
"リームの末尾より先にファイル位置を動かしても、 バッファが伸長されず、 "
"B<fseek>(3)  が失敗し -1 が返る。"

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=11216
#. type: Plain text
#: build/C/man3/fmemopen.3:227
msgid ""
"If I<size> is specified as zero, B<fmemopen>()  fails with the error "
"B<EINVAL>.  It would be more consistent if this case successfully created a "
"stream that then returned end of file on the first attempt at reading.  "
"Furthermore, POSIX.1-2008 does not specify a failure for this case."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=13152
#. type: Plain text
#: build/C/man3/fmemopen.3:235
msgid ""
"Specifying append mode (\"a\" or \"a+\") for B<fmemopen>()  sets the initial "
"file position to the first null byte, but (if the file offset is reset to a "
"location other than the end of the stream)  does not force subsequent writes "
"to append at the end of the stream."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=13151
#. type: Plain text
#: build/C/man3/fmemopen.3:251
msgid ""
"If the I<mode> argument to B<fmemopen>()  specifies append (\"a\" or \"a+"
"\"), and the I<size> argument does not cover a null byte in I<buf> then, "
"according to POSIX.1-2008, the initial file position should be set to the "
"next byte after the end of the buffer.  However, in this case the glibc "
"B<fmemopen>()  sets the file position to -1."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12836
#. type: Plain text
#: build/C/man3/fmemopen.3:264
msgid ""
"To specify binary mode for B<fmemopen>()  the \\(aqb\\(aq must be the "
"I<second> character in I<mode>.  Thus, for example, \"wb+\" has the desired "
"effect, but \"w+b\" does not.  This is inconsistent with the treatment of "
"I<mode> by B<fopen>(3)."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=6544
#. type: Plain text
#: build/C/man3/fmemopen.3:272
msgid ""
"The glibc 2.9 addition of \"binary\" mode for B<fmemopen>()  silently "
"changed the ABI: previously, B<fmemopen>()  ignored \\(aqb\\(aq in I<mode>."
msgstr ""

#. type: SH
#: build/C/man3/fmemopen.3:272 build/C/man3/fmtmsg.3:240
#: build/C/man3/fopencookie.3:245 build/C/man3/getline.3:139
#: build/C/man2/pipe.2:124 build/C/man3/printf.3:973
#: build/C/man2/readlink.2:155 build/C/man2/readv.2:263
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/fmemopen.3:282
msgid ""
"The program below uses B<fmemopen>()  to open an input buffer, and "
"B<open_memstream>()  to open a dynamically sized output buffer.  The program "
"scans its input string (taken from the program's first command-line "
"argument) reading integers, and writes the squares of these integers to the "
"output buffer.  An example of the output produced by this program is the "
"following:"
msgstr ""
"このプログラムは B<fmemopen>()  を使って出力バッファをオープンし、 "
"B<open_memstream>()  を使って動的にサイズが変化する出力バッファをオープンして"
"いる。 (プログラムの第一コマンドライン引き数から取った) 入力文字列を スキャン"
"して整数を読み込み、これらの整数の二乗を出力バッファに書き出す。 このプログラ"
"ムの実行例は以下のようになる。"

#. type: Plain text
#: build/C/man3/fmemopen.3:287
#, no-wrap
msgid ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"
msgstr ""
"$B< ./a.out \\(aq1 23 43\\(aq>\n"
"size=11; ptr=1 529 1849\n"

#. type: SS
#: build/C/man3/fmemopen.3:289 build/C/man3/fopencookie.3:269
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/fmemopen.3:296
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:299
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:307
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    FILE *out, *in;\n"
"    int v, s;\n"
"    size_t size;\n"
"    char *ptr;\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:312
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>fileE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:316
#, no-wrap
msgid ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"
msgstr ""
"    in = fmemopen(argv[1], strlen(argv[1]), \"r\");\n"
"    if (in == NULL)\n"
"        handle_error(\"fmemopen\");\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:320
#, no-wrap
msgid ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"
msgstr ""
"    out = open_memstream(&ptr, &size);\n"
"    if (out == NULL)\n"
"        handle_error(\"open_memstream\");\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:325
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"
msgstr ""
"    for (;;) {\n"
"        s = fscanf(in, \"%d\", &v);\n"
"        if (s E<lt>= 0)\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:336
#, no-wrap
msgid ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
"    fclose(in);\n"
"    fclose(out);\n"
"    printf(\"size=%ld; ptr=%s\\en\", (long) size, ptr);\n"
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"        s = fprintf(out, \"%d \", v * v);\n"
"        if (s == -1)\n"
"            handle_error(\"fprintf\");\n"
"    }\n"
"    fclose(in);\n"
"    fclose(out);\n"
"    printf(\"size=%ld; ptr=%s\\en\", (long) size, ptr);\n"
"    free(ptr);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/fmemopen.3:340
msgid "B<fopen>(3), B<fopencookie>(3)"
msgstr "B<fopen>(3), B<fopencookie>(3)"

#. type: TH
#: build/C/man3/fmtmsg.3:9
#, no-wrap
msgid "FMTMSG"
msgstr "FMTMSG"

#. type: TH
#: build/C/man3/fmtmsg.3:9
#, no-wrap
msgid "2008-06-14"
msgstr "2008-06-14"

#. type: Plain text
#: build/C/man3/fmtmsg.3:12
msgid "fmtmsg - print formatted error messages"
msgstr "fmtmsg - 整形されたエラーメッセージを表示する"

#. type: Plain text
#: build/C/man3/fmtmsg.3:15
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:17
#, no-wrap
msgid "B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"
msgstr "B<int fmtmsg(long >I<classification>B<, const char *>I<label>B<,>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:19
#, no-wrap
msgid "B<           int >I<severity>B<, const char *>I<text>B<,>\n"
msgstr "B<           int >I<severity>B<, const char *>I<text>B<,>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:21
#, no-wrap
msgid "B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"
msgstr "B<           const char *>I<action>B<, const char *>I<tag>B<);>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:32
msgid ""
"This function displays a message described by its arguments on the device"
"(s)  specified in the I<classification> argument.  For messages written to "
"I<stderr>, the format depends on the B<MSGVERB> environment variable."
msgstr ""
"この関数は、引き数で記述されたメッセージを、 I<classification> 引き数で指定さ"
"れたデバイス上に表示する。 I<stderr> に書き出されるメッセージのフォーマット"
"は、 B<MSGVERB> 環境変数に依存する。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:39
msgid ""
"The I<label> argument identifies the source of the message.  The string must "
"consist of two colon separated parts where the first part has not more than "
"10 and the second part not more than 14 characters."
msgstr ""
"I<label> 引き数はメッセージの発生源を識別する。 この文字列はコロンで区切られ"
"た 2 つの部分から構成されていなければならない。 1 つ目の部分は 10 文字以内で"
"なければならず、 2 つ目の部分は 14 文字以内でなければならない。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:43
msgid "The I<text> argument describes the condition of the error."
msgstr "I<text> 引き数にはエラー条件を記述する。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:48
msgid ""
"The I<action> argument describes possible steps to recover from the error.  "
"If it is printed, it is prefixed by \"TO FIX: \"."
msgstr ""
"I<action> 引き数にはエラーから回復するために利用可能なステップを記述する。 こ"
"れが表示される場合、\"TO FIX: \" が前に付く。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:56
msgid ""
"The I<tag> argument is a reference to the online documentation where more "
"information can be found.  It should contain the I<label> value and a unique "
"identification number."
msgstr ""
"I<tag> 引き数はより多くの情報を見つけるためのオンラインドキュメントへの参照で"
"ある。 これは I<label> 値とユニークな識別番号を含んでいるべきである。"

#. type: SS
#: build/C/man3/fmtmsg.3:56
#, no-wrap
msgid "Dummy arguments"
msgstr "ダミー引き数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:75
msgid ""
"Each of the arguments can have a dummy value.  The dummy classification "
"value B<MM_NULLMC> (0L) does not specify any output, so nothing is printed.  "
"The dummy severity value B<NO_SEV> (0) says that no severity is supplied.  "
"The values B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> are "
"synonyms for I<((char *) 0)>, the empty string, and B<MM_NULLSEV> is a "
"synonym for B<NO_SEV>."
msgstr ""
"各引き数にはダミーの値を入れることができる。 ダミーの I<classification> 値 "
"B<MM_NULLMC> (0L) は出力を何も指定しない。そのため何も表示されない。 ダミー"
"の I<severity> 値 B<NO_SEV> (0) は重大度 (severity) が与えられていないことを"
"表す。 値 B<MM_NULLLBL>, B<MM_NULLTXT>, B<MM_NULLACT>, B<MM_NULLTAG> は I<"
"((char *) 0)> と空文字列の別名であり、 B<MM_NULLSEV> は B<NO_SEV> の別名であ"
"る。"

#. type: SS
#: build/C/man3/fmtmsg.3:75
#, no-wrap
msgid "The classification argument"
msgstr "classification 引き数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:79
msgid ""
"The I<classification> argument is the sum of values describing 4 types of "
"information."
msgstr "I<classification> 引き数は 4 種類の情報を記述する値の和である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:82
msgid "The first value defines the output channel."
msgstr "最初の値は出力チャンネルを定義する。"

#. type: TP
#: build/C/man3/fmtmsg.3:82
#, no-wrap
msgid "B<MM_PRINT>"
msgstr "B<MM_PRINT>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:86
msgid "Output to I<stderr>."
msgstr "I<stderr> に出力する。"

#. type: TP
#: build/C/man3/fmtmsg.3:86
#, no-wrap
msgid "B<MM_CONSOLE>"
msgstr "B<MM_CONSOLE>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:89
msgid "Output to the system console."
msgstr "システムコンソールに出力する。"

#. type: TP
#: build/C/man3/fmtmsg.3:89
#, no-wrap
msgid "B<MM_PRINT | MM_CONSOLE>"
msgstr "B<MM_PRINT | MM_CONSOLE>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:92
msgid "Output to both."
msgstr "両方に出力する。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:94
msgid "The second value is the source of the error:"
msgstr "2 番目の値はエラーの発生源である:"

#. type: TP
#: build/C/man3/fmtmsg.3:94
#, no-wrap
msgid "B<MM_HARD>"
msgstr "B<MM_HARD>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:97
msgid "A hardware error occurred."
msgstr "ハードウェアエラーが起こった。"

#. type: TP
#: build/C/man3/fmtmsg.3:97
#, no-wrap
msgid "B<MM_FIRM>"
msgstr "B<MM_FIRM>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:100
msgid "A firmware error occurred."
msgstr "ファームウェアエラーが起こった。"

#. type: TP
#: build/C/man3/fmtmsg.3:100
#, no-wrap
msgid "B<MM_SOFT>"
msgstr "B<MM_SOFT>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:103
msgid "A software error occurred."
msgstr "ソフトウェアエラーが起こった。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:105
msgid "The third value encodes the detector of the problem:"
msgstr "3 番目の値は問題の検知を行ったものをエンコードする:"

#. type: TP
#: build/C/man3/fmtmsg.3:105
#, no-wrap
msgid "B<MM_APPL>"
msgstr "B<MM_APPL>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:108
msgid "It is detected by an application."
msgstr "アプリケーションによって検知された。"

#. type: TP
#: build/C/man3/fmtmsg.3:108
#, no-wrap
msgid "B<MM_UTIL>"
msgstr "B<MM_UTIL>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:111
msgid "It is detected by a utility."
msgstr "ユーティリティによって検知された。"

#. type: TP
#: build/C/man3/fmtmsg.3:111
#, no-wrap
msgid "B<MM_OPSYS>"
msgstr "B<MM_OPSYS>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:114
msgid "It is detected by the operating system."
msgstr "オペレーティングシステムによって検知された。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:116
msgid "The fourth value shows the severity of the incident:"
msgstr "4 番目の値は問題の重大度を表す:"

#. type: TP
#: build/C/man3/fmtmsg.3:116
#, no-wrap
msgid "B<MM_RECOVER>"
msgstr "B<MM_RECOVER>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:119
msgid "It is a recoverable error."
msgstr "回復可能なエラーである。"

#. type: TP
#: build/C/man3/fmtmsg.3:119
#, no-wrap
msgid "B<MM_NRECOV>"
msgstr "B<MM_NRECOV>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:122
msgid "It is a nonrecoverable error."
msgstr "回復不可能なエラーである。"

#. type: SS
#: build/C/man3/fmtmsg.3:122
#, no-wrap
msgid "The severity argument"
msgstr "severity 引き数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:126
msgid "The I<severity> argument can take one of the following values:"
msgstr "I<severity> 引き数は以下の 1 つの値をとることができる。"

#. type: TP
#: build/C/man3/fmtmsg.3:126
#, no-wrap
msgid "B<MM_NOSEV>"
msgstr "B<MM_NOSEV>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:129
msgid "No severity is printed."
msgstr "重大度は表示されない。"

#. type: TP
#: build/C/man3/fmtmsg.3:129
#, no-wrap
msgid "B<MM_HALT>"
msgstr "B<MM_HALT>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:132
msgid "This value is printed as HALT."
msgstr "この値は HALT として表示される。"

#. type: TP
#: build/C/man3/fmtmsg.3:132
#, no-wrap
msgid "B<MM_ERROR>"
msgstr "B<MM_ERROR>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:135
msgid "This value is printed as ERROR."
msgstr "この値は ERROR として表示される。"

#. type: TP
#: build/C/man3/fmtmsg.3:135
#, no-wrap
msgid "B<MM_WARNING>"
msgstr "B<MM_WARNING>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:138
msgid "This value is printed as WARNING."
msgstr "この値は WARNING として表示される。"

#. type: TP
#: build/C/man3/fmtmsg.3:138
#, no-wrap
msgid "B<MM_INFO>"
msgstr "B<MM_INFO>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:141
msgid "This value is printed as INFO."
msgstr "この値は INFO として表示される。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:148
msgid ""
"The numeric values are between 0 and 4.  Using B<addseverity>(3)  or the "
"environment variable B<SEV_LEVEL> you can add more levels and strings to "
"print."
msgstr ""
"数値の場合は 0 から 4 である。 B<addseverity>(3)  または環境変数 "
"B<SEV_LEVEL> を使うことにより、表示するレベルと文字列を更に追加できる。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:150
msgid "The function can return 4 values:"
msgstr "関数は 4 つの値を返す:"

#. type: TP
#: build/C/man3/fmtmsg.3:150
#, no-wrap
msgid "B<MM_OK>"
msgstr "B<MM_OK>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:153
msgid "Everything went smooth."
msgstr "全てがうまくいった。"

#. type: TP
#: build/C/man3/fmtmsg.3:153
#, no-wrap
msgid "B<MM_NOTOK>"
msgstr "B<MM_NOTOK>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:156
msgid "Complete failure."
msgstr "完全に失敗した。"

#. type: TP
#: build/C/man3/fmtmsg.3:156
#, no-wrap
msgid "B<MM_NOMSG>"
msgstr "B<MM_NOMSG>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:160
msgid "Error writing to I<stderr>."
msgstr "I<stderr> に書き込むときにエラーが起こった。"

#. type: TP
#: build/C/man3/fmtmsg.3:160
#, no-wrap
msgid "B<MM_NOCON>"
msgstr "B<MM_NOCON>"

#. type: Plain text
#: build/C/man3/fmtmsg.3:163
msgid "Error writing to the console."
msgstr "コンソールに書き込むときにエラーが起こった。"

#. type: SH
#: build/C/man3/fmtmsg.3:163
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境変数"

#. type: Plain text
#: build/C/man3/fmtmsg.3:174
msgid ""
"The environment variable B<MSGVERB> (\"message verbosity\") can be used to "
"suppress parts of the output to I<stderr>.  (It does not influence output to "
"the console.)  When this variable is defined, is non-NULL, and is a colon-"
"separated list of valid keywords, then only the parts of the message "
"corresponding to these keywords is printed.  Valid keywords are \"label\", "
"\"severity\", \"text\", \"action\" and \"tag\"."
msgstr ""
"環境変数 B<MSGVERB> (\"message verbosity\") は I<stderr> への出力の一部を抑制"
"するのに使うことができる。 (コンソールへの出力には影響しない。)  この変数が定"
"義されて、NULL でなく、 コロンで区切られた有効なキーワードのリストである場"
"合、 キーワードに対応するメッセージの一部のみが表示される。 有効なキーワード"
"は \"label\", \"severity\", \"text\", \"action\", \"tag\" である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:186
msgid ""
"The environment variable B<SEV_LEVEL> can be used to introduce new severity "
"levels.  By default, only the five severity levels described above are "
"available.  Any other numeric value would make B<fmtmsg>()  print nothing.  "
"If the user puts B<SEV_LEVEL> with a format like"
msgstr ""
"環境変数 B<SEV_LEVEL> は新しい重大度レベルを導入するのに使用できる。 デフォル"
"トでは、上記の 5 つの重大度レベルのみが利用可能である。 他の数値の場合、 "
"B<fmtmsg>()  は何も表示しない。 B<fmtmsg>()  を初めて呼び出す前に、ユーザが "
"B<SEV_LEVEL> を"

#. type: Plain text
#: build/C/man3/fmtmsg.3:189
msgid "SEV_LEVEL=[description[:description[:...]]]"
msgstr "SEV_LEVEL=[description[:description[:...]]]"

#. type: Plain text
#: build/C/man3/fmtmsg.3:194
msgid ""
"in the environment of the process before the first call to B<fmtmsg>(), "
"where each description is of the form"
msgstr ""
"のような形式でプロセスの環境に設定すると、 B<fmtmsg>()  は (標準のレベル 0-4 "
"に加えて) level に指定された値も受け付け、 そのようなレベルの問題が発生すると"
"指定された printstring を表示する。 各 description は"

#. type: Plain text
#: build/C/man3/fmtmsg.3:197
msgid "severity-keyword,level,printstring"
msgstr "severity-keyword,level,printstring"

#. type: Plain text
#: build/C/man3/fmtmsg.3:204
msgid ""
"then B<fmtmsg>()  will also accept the indicated values for the level (in "
"addition to the standard levels 0-4), and use the indicated printstring when "
"such a level occurs."
msgstr "という形式である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:218
msgid ""
"The severity-keyword part is not used by B<fmtmsg>()  but it has to be "
"present.  The level part is a string representation of a number.  The "
"numeric value must be a number greater than 4.  This value must be used in "
"the severity argument of B<fmtmsg>()  to select this class.  It is not "
"possible to overwrite any of the predefined classes.  The printstring is the "
"string printed when a message of this class is processed by B<fmtmsg>()."
msgstr ""
"severity-keyword 部は B<fmtmsg>()  に使用されないが、存在しなければならな"
"い。 level 部は数値を文字列で表したものである。 数値は 4 より大きい値でなけれ"
"ばならない。 この値は B<fmtmsg>()  の severity 引き数で使用されなければなら"
"ず、この重大度を選択する。 前もって宣言された重大度を上書きすることはできな"
"い。 printstring は、 この重大度のメッセージが B<fmtmsg>()  によって生成され"
"た場合に表示される文字列である。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:221
msgid "B<fmtmsg>()  is provided in glibc since version 2.1."
msgstr "B<fmtmsg>()  は、バージョン 2.1 以降の glibc で提供されている。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:236
msgid ""
"The functions B<fmtmsg>()  and B<addseverity>(3), and environment variables "
"B<MSGVERB> and B<SEV_LEVEL> come from System V.  The function B<fmtmsg>()  "
"and the environment variable B<MSGVERB> are described in POSIX.1-2001."
msgstr ""
"関数 B<fmtmsg>()  と B<addseverity>(3)  と環境変数 B<MSGVERB> と "
"B<SEV_LEVEL> は System V に由来している。 関数 B<fmtmsg>()  と環境変数 "
"B<MSGVERB> は POSIX.1-2001 に記述されている。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:240
msgid ""
"System V and UnixWare man pages tell us that these functions have been "
"replaced by \"pfmt() and addsev()\" or by \"pfmt(), vpfmt(), lfmt(), and "
"vlfmt()\", and will be removed later."
msgstr ""
"System V と UnixWare の man ページには、 「これらの関数は \"pfmt() と addsev"
"()\" または \"pfmt(), vpfmt(), lfmt(), vlfmt()\" で置き換えられており、 将来"
"は削除される予定である」と書かれている。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:245
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>fmtmsg.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:251
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    long class = MM_PRINT | MM_SOFT | MM_OPSYS | MM_RECOVER;\n"
"    int err;\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:272
#, no-wrap
msgid ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"        break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    err = fmtmsg(class, \"util-linux:mount\", MM_ERROR,\n"
"                \"unknown mount option\", \"See mount(8).\",\n"
"                \"util-linux:mount:017\");\n"
"    switch (err) {\n"
"    case MM_OK:\n"
"      break;\n"
"    case MM_NOTOK:\n"
"        printf(\"Nothing printed\\en\");\n"
"        break;\n"
"    case MM_NOMSG:\n"
"        printf(\"Nothing printed to stderr\\en\");\n"
"        break;\n"
"    case MM_NOCON:\n"
"        printf(\"No console output\\en\");\n"
"        break;\n"
"    default:\n"
"        printf(\"Unknown error from fmtmsg()\\en\");\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:275
msgid "The output should be:"
msgstr "出力は"

#. type: Plain text
#: build/C/man3/fmtmsg.3:279
#, no-wrap
msgid ""
"    util-linux:mount: ERROR: unknown mount option\n"
"    TO FIX: See mount(8).  util-linux:mount:017\n"
msgstr ""
"    util-linux:mount: ERROR: unknown mount option\n"
"    TO FIX: See mount(8).  util-linux:mount:017\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:282
msgid "and after"
msgstr "のようになり、"

#. type: Plain text
#: build/C/man3/fmtmsg.3:285
#, no-wrap
msgid "    MSGVERB=text:action; export MSGVERB\n"
msgstr "    MSGVERB=text:action; export MSGVERB\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:288
msgid "the output becomes:"
msgstr "を実行すると、次のようになる。"

#. type: Plain text
#: build/C/man3/fmtmsg.3:292
#, no-wrap
msgid ""
"    unknown mount option\n"
"    TO FIX: See mount(8).\n"
msgstr ""
"    unknown mount option\n"
"    TO FIX: See mount(8).\n"

#. type: Plain text
#: build/C/man3/fmtmsg.3:296
msgid "B<addseverity>(3), B<perror>(3)"
msgstr "B<addseverity>(3), B<perror>(3)"

#. type: TH
#: build/C/man3/fopen.3:42
#, no-wrap
msgid "FOPEN"
msgstr "FOPEN"

#. type: TH
#: build/C/man3/fopen.3:42
#, no-wrap
msgid "2012-04-22"
msgstr "2012-04-22"

#. type: Plain text
#: build/C/man3/fopen.3:45
msgid "fopen, fdopen, freopen - stream open functions"
msgstr "fopen, fdopen, freopen - ストリームを開く関数"

#. type: Plain text
#: build/C/man3/fopen.3:50
#, no-wrap
msgid "B<FILE *fopen(const char *>I<path>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fopen(const char *>I<path>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fopen.3:52
#, no-wrap
msgid "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"
msgstr "B<FILE *fdopen(int >I<fd>B<, const char *>I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/fopen.3:54
#, no-wrap
msgid "B<FILE *freopen(const char *>I<path>B<, const char *>I<mode>B<, FILE *>I<stream>B<);>\n"
msgstr "B<FILE *freopen(const char *>I<path>B<, const char *>I<mode>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fopen.3:63
msgid ""
"B<fdopen>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<fdopen>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/fopen.3:69
msgid ""
"The B<fopen>()  function opens the file whose name is the string pointed to "
"by I<path> and associates a stream with it."
msgstr ""
"B<fopen>()  関数は、 I<path> で指定された名前のファイルを開き、ストリームと結"
"びつける。"

#. type: Plain text
#: build/C/man3/fopen.3:74
msgid ""
"The argument I<mode> points to a string beginning with one of the following "
"sequences (possibly followed by additional characters, as described below):"
msgstr ""
"引数 I<mode> は、以下に続く文字のひとつから始まる文字列へのポインタであ\n"
"る (以下の述べる、追加の文字が後に続くこともある):"

#. type: TP
#: build/C/man3/fopen.3:74
#, no-wrap
msgid "B<r>"
msgstr "B<r>"

#. type: Plain text
#: build/C/man3/fopen.3:78
msgid ""
"Open text file for reading.  The stream is positioned at the beginning of "
"the file."
msgstr ""
"テキストファイルを読み出すために開く。 ストリームはファイルの先頭に位置され"
"る。"

#. type: TP
#: build/C/man3/fopen.3:78
#, no-wrap
msgid "B<r+>"
msgstr "B<r+>"

#. type: Plain text
#: build/C/man3/fopen.3:82
msgid ""
"Open for reading and writing.  The stream is positioned at the beginning of "
"the file."
msgstr ""
"読み出しおよび書き込みするために開く。 ストリームはファイルの先頭に位置され"
"る。"

#. type: TP
#: build/C/man3/fopen.3:82
#, no-wrap
msgid "B<w>"
msgstr "B<w>"

#. type: Plain text
#: build/C/man3/fopen.3:86
msgid ""
"Truncate file to zero length or create text file for writing.  The stream is "
"positioned at the beginning of the file."
msgstr ""
"ファイルを書き込みのために開く。 ファイルが既に存在する場合には長さゼロに切り"
"詰める。 ファイルがなかった場合には新たに作成する。 ストリームはファイルの先"
"頭に位置される。"

#. type: TP
#: build/C/man3/fopen.3:86
#, no-wrap
msgid "B<w+>"
msgstr "B<w+>"

#. type: Plain text
#: build/C/man3/fopen.3:92
msgid ""
"Open for reading and writing.  The file is created if it does not exist, "
"otherwise it is truncated.  The stream is positioned at the beginning of the "
"file."
msgstr ""
"読み出しおよび書き込みのために開く。 ファイルが存在していない場合には新たに作"
"成する。 存在している場合には長さゼロに切り詰められる。 ストリームはファイル"
"の先頭に位置される。"

#. type: TP
#: build/C/man3/fopen.3:92 build/C/man3/scanf.3:444
#, no-wrap
msgid "B<a>"
msgstr "B<a>"

#. type: Plain text
#: build/C/man3/fopen.3:97
msgid ""
"Open for appending (writing at end of file).  The file is created if it does "
"not exist.  The stream is positioned at the end of the file."
msgstr ""
"追加 (ファイルの最後に書き込む) のために開く。 ファイルが存在していない場合に"
"は新たに作成する。 ストリームはファイルの最後に位置される。"

#. type: TP
#: build/C/man3/fopen.3:97
#, no-wrap
msgid "B<a+>"
msgstr "B<a+>"

#. type: Plain text
#: build/C/man3/fopen.3:103
msgid ""
"Open for reading and appending (writing at end of file).  The file is "
"created if it does not exist.  The initial file position for reading is at "
"the beginning of the file, but output is always appended to the end of the "
"file."
msgstr ""
"読み出しおよび追加 (ファイルの最後に書き込む) のために開く。 ファイルが存在し"
"ていない場合には新たに作成する。 読み出しの初期ファイル位置はファイルの先頭で"
"あるが、 書き込みは常にファイルの最後に追加される。"

#. type: Plain text
#: build/C/man3/fopen.3:116
msgid ""
"The I<mode> string can also include the letter \\(aqb\\(aq either as a last "
"character or as a character between the characters in any of the two-"
"character strings described above.  This is strictly for compatibility with "
"C89 and has no effect; the \\(aqb\\(aq is ignored on all POSIX conforming "
"systems, including Linux.  (Other systems may treat text files and binary "
"files differently, and adding the \\(aqb\\(aq may be a good idea if you do I/"
"O to a binary file and expect that your program may be ported to non-UNIX "
"environments.)"
msgstr ""
"I<mode> 文字列には文字 \\(aqb\\(aq を追加指定することができ、 I<mode> 文字列"
"の最後の文字として指定する。 上記のうち 2 文字のモードの場合には 2 つの文字の"
"間に指定することもできる。 これは C89 との互換性のためだけに用意された もので"
"あり、関数の実行に対してはいかなる影響も持たない。 すなわち、Linux を含む全て"
"の POSIX 準拠システムでは、 この \\(aqb\\(aq は無視される。 (その他のシステム"
"ではテキストファイルとバイナリファイルを別々に扱うものもあるので、 もしバイナ"
"リファイルの入出力を行い、 そのプログラムが非 UNIX 環境へ移植されると予測する"
"なら、 \\(aqb\\(aqを付けておくのは良い考えである)"

#. type: Plain text
#: build/C/man3/fopen.3:119
msgid "See NOTES below for details of glibc extensions for I<mode>."
msgstr "I<mode> の glibc による拡張の詳細については下記の「注意」を参照。"

#. type: Plain text
#: build/C/man3/fopen.3:124
msgid ""
"Any created files will have mode B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666), as modified by the process's "
"umask value (see B<umask>(2))."
msgstr ""
"すべての生成されたファイルは、 B<S_IRUSR> | B<S_IWUSR> | B<S_IRGRP> | "
"B<S_IWGRP> | B<S_IROTH> | B<S_IWOTH> (0666) のモードを そのプロセスの umask "
"値によって修正したモードを持つ (B<umask>(2)  を見よ)。"

#. type: Plain text
#: build/C/man3/fopen.3:139
msgid ""
"Reads and writes may be intermixed on read/write streams in any order.  Note "
"that ANSI C requires that a file positioning function intervene between "
"output and input, unless an input operation encounters end-of-file.  (If "
"this condition is not met, then a read is allowed to return the result of "
"writes other than the most recent.)  Therefore it is good practice (and "
"indeed sometimes necessary under Linux) to put an B<fseek>(3)  or B<fgetpos>"
"(3)  operation between write and read operations on such a stream.  This "
"operation may be an apparent no-op (as in I<fseek(..., 0L, SEEK_CUR)> called "
"for its synchronizing side effect."
msgstr ""
"読み出し/書き込みストリームに対しては任意の順序で読み書きを行うことができ"
"る。 ただし ANSI C では、 (入力操作がファイルの末尾に到達した場合を除いて)  "
"出力と入力の間にはファイルの位置決め関数を 挟まなければならないことになってい"
"ることに注意されたい (この条件を満足しない場合には、読み込み操作は、 最後に書"
"き込まれたものでなく、以前に書き込まれた 値を返すことを許されている)。 した"
"がって、このようなストリームでの読み書き操作の間には B<fseek>(3)  または "
"B<fgetpos>(3)  操作を挟んでおくと良いだろう (Linux では本当に必要となることも"
"ときどきある)。 この操作は見かけ上何もしない操作 (no-op) でも良い (例えば "
"I<fseek(..., 0L, SEEK_CUR)> を その副次的効果である同期のためだけに呼べば良"
"い)。"

#. type: Plain text
#: build/C/man3/fopen.3:144
msgid ""
"Opening a file in append mode (B<a> as the first character of I<mode>)  "
"causes all subsequent write operations to this stream to occur at end-of-"
"file, as if preceded the call:"
msgstr ""
"ファイルを追加モード (I<mode> の最初の文字を B<a> にする) で開くと、\n"
"このストリームに対する書き込み操作は全て (先に以下の呼び出しを行った\n"
"かのように) ファイルの末尾で行われる。"

#. type: Plain text
#: build/C/man3/fopen.3:147
#, no-wrap
msgid "    fseek(stream,0,SEEK_END);\n"
msgstr "    fseek(stream,0,SEEK_END);\n"

#. type: Plain text
#: build/C/man3/fopen.3:169
msgid ""
"The B<fdopen>()  function associates a stream with the existing file "
"descriptor, I<fd>.  The I<mode> of the stream (one of the values \"r\", \"r+"
"\", \"w\", \"w+\", \"a\", \"a+\")  must be compatible with the mode of the "
"file descriptor.  The file position indicator of the new stream is set to "
"that belonging to I<fd>, and the error and end-of-file indicators are "
"cleared.  Modes \"w\" or \"w+\" do not cause truncation of the file.  The "
"file descriptor is not dup'ed, and will be closed when the stream created by "
"B<fdopen>()  is closed.  The result of applying B<fdopen>()  to a shared "
"memory object is undefined."
msgstr ""
"B<fdopen>()  関数は、既存のファイル記述子 I<fd> にストリームを結びつける。 ス"
"トリームの I<mode> (\"r\", \"r+\", \"w\", \"w+\", \"a\", \"a+\" のいずれか) "
"は ファイル記述子のモードと互換のものでなければならない。 新しいストリームの"
"ファイル位置指示子は I<fd> に属している値に設定される。 error と end-of-file "
"の各指示子はクリアされる。 \"w\" および \"w+\" モードでのファイルの切り詰めは"
"行われない。 ファイル記述子の複製は行なわれない。 B<fdopen>()  で作成されたス"
"トリームが閉じられたときにファイル記述子も 閉じられる。 共有メモリのオブジェ"
"クトへ B<fdopen>()  を行ったときの結果は定義されていない。"

#. type: Plain text
#: build/C/man3/fopen.3:187
msgid ""
"The B<freopen>()  function opens the file whose name is the string pointed "
"to by I<path> and associates the stream pointed to by I<stream> with it.  "
"The original stream (if it exists) is closed.  The I<mode> argument is used "
"just as in the B<fopen>()  function.  The primary use of the B<freopen>()  "
"function is to change the file associated with a standard text stream "
"(I<stderr>, I<stdin>, or I<stdout>)."
msgstr ""
"B<freopen>()  関数は I<path> で名前が指定されたファイルを開き、 I<stream> で"
"指定されたストリームに、そのファイルを結びつける。 もとのストリームは (もし存"
"在する場合には) 閉じられる。 I<mode> 引数は B<fopen>()  関数と同じ形で使われ"
"る。 B<freopen>()  関数の主な用途は、標準テキストストリーム (I<stderr>, "
"I<stdin>, I<stdout>)  と対応付けられているファイルを変更することである。"

#. type: Plain text
#: build/C/man3/fopen.3:199
msgid ""
"Upon successful completion B<fopen>(), B<fdopen>()  and B<freopen>()  return "
"a I<FILE> pointer.  Otherwise, NULL is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  は成功すると I<FILE> 型のポインタを返"
"す。 失敗すると NULL が返され、 I<errno> がエラーを示す値にセットされる。"

#. type: TP
#: build/C/man3/fopen.3:200 build/C/man3/fseek.3:138
#: build/C/man3/getline.3:121 build/C/man2/llseek.2:72
#: build/C/man2/lseek.2:164 build/C/man2/pipe.2:102 build/C/man2/read.2:108
#: build/C/man2/read.2:119 build/C/man2/readlink.2:93
#: build/C/man2/readlink.2:102 build/C/man2/readv.2:198
#: build/C/man2/rename.2:136 build/C/man2/rmdir.2:67 build/C/man3/scanf.3:563
#: build/C/man2/write.2:148
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/fopen.3:210
msgid ""
"The I<mode> provided to B<fopen>(), B<fdopen>(), or B<freopen>()  was "
"invalid."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  で与えられた I<mode> が不適切である。"

#. type: Plain text
#: build/C/man3/fopen.3:220
msgid ""
"The B<fopen>(), B<fdopen>()  and B<freopen>()  functions may also fail and "
"set I<errno> for any of the errors specified for the routine B<malloc>(3)."
msgstr ""
"B<fopen>(), B<fdopen>(), B<freopen>()  関数は B<malloc>(3)  ルーチンで規定さ"
"れているエラーでも失敗することがあり、 その時は対応する値に I<errno> をセット"
"する。"

#. type: Plain text
#: build/C/man3/fopen.3:227
msgid ""
"The B<fopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<open>(2)."
msgstr ""
"B<fopen>()  関数は B<open>(2)  ルーチンで規定されているエラーでも失敗すること"
"があり、 その時は対応する値に I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/fopen.3:234
msgid ""
"The B<fdopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routine B<fcntl>(2)."
msgstr ""
"B<fdopen>()  関数は B<fcntl>(2)  ルーチンで規定されているエラーでも失敗するこ"
"とがあり、 その時は対応する値に I<errno> をセットする。"

#. type: Plain text
#: build/C/man3/fopen.3:244
msgid ""
"The B<freopen>()  function may also fail and set I<errno> for any of the "
"errors specified for the routines B<open>(2), B<fclose>(3)  and B<fflush>(3)."
msgstr ""
"B<freopen>()  関数は B<open>(2), B<fclose>(3), B<fflush>(3)  各ルーチンで規定"
"されているエラーでも失敗することがあり、 その時は対応する値に I<errno> をセッ"
"トする。"

#. type: Plain text
#: build/C/man3/fopen.3:253
msgid ""
"The B<fopen>()  and B<freopen>()  functions conform to C89.  The B<fdopen>"
"()  function conforms to POSIX.1-1990."
msgstr ""
"B<fopen>()  関数と B<freopen>()  関数は C89に準拠している。 B<fdopen>()  関数"
"は POSIX.1-1990 に準拠している。"

#. type: SS
#: build/C/man3/fopen.3:254
#, no-wrap
msgid "Glibc Notes"
msgstr "glibc での注意"

#. type: Plain text
#: build/C/man3/fopen.3:257
msgid ""
"The GNU C library allows the following extensions for the string specified "
"in I<mode>:"
msgstr ""
"GNU C ライブラリでは、 I<mode> に指定できる文字列として、以下の拡張が行われて"
"いる:"

#. type: TP
#: build/C/man3/fopen.3:257
#, no-wrap
msgid "B<c> (since glibc 2.3.3)"
msgstr "B<c> (glibc 2.3.3 以降)"

#. type: Plain text
#: build/C/man3/fopen.3:264
msgid ""
"Do not make the open operation, or subsequent read and write operations, "
"thread cancellation points.  This flag is ignored for B<fdopen>()."
msgstr ""
"open 操作、それに続く read/write 操作の、 スレッドの取り消しポイント\n"
"(cancellation points) を作成しない。\n"
"このフラグは B<fdopen>() では無視される。"

#. type: TP
#: build/C/man3/fopen.3:264
#, no-wrap
msgid "B<e> (since glibc 2.7)"
msgstr "B<e> (glibc 2.7 以降)"

#. type: Plain text
#: build/C/man3/fopen.3:274
msgid ""
"Open the file with the B<O_CLOEXEC> flag.  See B<open>(2)  for more "
"information.  This flag is ignored for B<fdopen>()."
msgstr ""
"B<O_CLOEXEC> フラグを有効にしてファイルをオープンする。詳細は\n"
"B<open>(2) を参照。このフラグは B<fdopen>() では無視される。"

#. type: TP
#: build/C/man3/fopen.3:274
#, no-wrap
msgid "B<m> (since glibc 2.3)"
msgstr "B<m> (glibc 2.3 以降)"

#.  As at glibc 2.4:
#. type: Plain text
#: build/C/man3/fopen.3:286
msgid ""
"Attempt to access the file using B<mmap>(2), rather than I/O system calls "
"(B<read>(2), B<write>(2)).  Currently, use of B<mmap>(2)  is only attempted "
"for a file opened for reading."
msgstr ""
"I/O システムコール (B<read>(2), B<write>(2))  ではなく、 B<mmap>(2)  を使って"
"ファイルにアクセスしようとする。 B<mmap>(2)  を使おうとするのは、読み出し用に"
"オープンするファイルについてだけである。"

#. type: TP
#: build/C/man3/fopen.3:286 build/C/man3/scanf.3:418
#, no-wrap
msgid "B<x>"
msgstr "B<x>"

#.  Since glibc 2.0?
#.  FIXME C11 specifies this flag
#. type: Plain text
#: build/C/man3/fopen.3:303
msgid ""
"Open the file exclusively (like the B<O_EXCL> flag of B<open>(2)).  If the "
"file already exists, B<fopen>()  fails, and sets I<errno> to B<EEXIST>.  "
"This flag is ignored for B<fdopen>()."
msgstr ""
"ファイルを排他的にオープンする (B<open>(2)  の B<O_EXCL> フラグと同様)。 ファ"
"イルがすでに存在する場合、 B<fopen>()  は失敗し、 I<errno> に B<EEXIST> が"
"セットされる。 このフラグは B<fdopen>()  では無視される。"

#. type: Plain text
#: build/C/man3/fopen.3:311
msgid ""
"In addition to the above characters, B<fopen>()  and B<freopen>()  support "
"the following syntax in I<mode>:"
msgstr ""
"上記の文字に加えて、\n"
"B<fopen>() と B<freopen>() では I<mode> に\n"
"以下の書式を 指定することができる。"

#. type: Plain text
#: build/C/man3/fopen.3:313
msgid "B< ,ccs=>I<string>"
msgstr "B< ,ccs=>I<string>"

#. type: Plain text
#: build/C/man3/fopen.3:329
msgid ""
"The given I<string> is taken as the name of a coded character set and the "
"stream is marked as wide-oriented.  Thereafter, internal conversion "
"functions convert I/O to and from the character set I<string>.  If the B<,"
"ccs=>I<string> syntax is not specified, then the wide-orientation of the "
"stream is determined by the first file operation.  If that operation is a "
"wide-character operation, the stream is marked wide-oriented, and functions "
"to convert to the coded character set are loaded."
msgstr ""
"指定された I<string> は、符号化文字集合の名前と解釈され、\n"
"ストリームではワイド文字のストリームとして扱われる。\n"
"内部変換関数で入出力時に文字集合 I<string> との変換が行われる。\n"
"書式 B<,ccs=>I<string> が指定されない場合は、\n"
"ストリームをワイド文字のストリームとして扱うかは\n"
"最初のファイル操作時に決定される。\n"
"最初のファイル操作がワイド文字操作であった場合は、\n"
"そのストリームはワイド文字のストリームとして扱われ、\n"
"符号化文字集合との変換を行う関数が読み込まれる。"

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12685
#. type: Plain text
#: build/C/man3/fopen.3:346
#, fuzzy
#| msgid ""
#| "When parsing for individual flag characters in I<mode> (i.e., the "
#| "characters preceding the \"ccs\" specification\"), the glibc "
#| "implementation of B<fopen>()  and B<freopen>()  limits the number of "
#| "characters examined in I<mode> to 7 (or, in glibc versions before 2.14, "
#| "to 6, which was not enough to include possible specifications such as \"rb"
#| "+cmxe\").  The current implementation of B<fdopen>()  parses at most 5 "
#| "characters in in I<mode>."
msgid ""
"When parsing for individual flag characters in I<mode> (i.e., the characters "
"preceding the \"ccs\" specification), the glibc implementation of B<fopen>"
"()  and B<freopen>()  limits the number of characters examined in I<mode> to "
"7 (or, in glibc versions before 2.14, to 6, which was not enough to include "
"possible specifications such as \"rb+cmxe\").  The current implementation of "
"B<fdopen>()  parses at most 5 characters in I<mode>."
msgstr ""
"I<mode> の個々のフラグ文字 (\"ccs\" 指定の前の文字) を解釈する際に、\n"
"glibc の B<fopen>() と B<freopen>() の実装では、\n"
"I<mode> の確認を最大 7 文字しか行わないという制限がある\n"
"(バージョン 2.14 より前の glibc では最大 6 文字だが、\n"
"6 文字では \"rb+cmxe\" などの指定を行うには不十分であった)。\n"
"B<fdopen>() の現在の実装では最大 5 文字の I<mode> しか解釈されない。"

#. type: Plain text
#: build/C/man3/fopen.3:352
msgid ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3)"
msgstr ""
"B<open>(2), B<fclose>(3), B<fileno>(3), B<fmemopen>(3), B<fopencookie>(3)"

#. type: TH
#: build/C/man3/fopencookie.3:24
#, no-wrap
msgid "FOPENCOOKIE"
msgstr "FOPENCOOKIE"

#. type: TH
#: build/C/man3/fopencookie.3:24
#, fuzzy, no-wrap
#| msgid "2012-03-30"
msgid "2012-04-30"
msgstr "2012-03-30"

#. type: TH
#: build/C/man3/fopencookie.3:24 build/C/man2/link.2:31
#: build/C/man2/llseek.2:26 build/C/man2/lseek.2:45 build/C/man3/lseek64.3:23
#: build/C/man2/open.2:52 build/C/man2/pipe.2:36 build/C/man2/read.2:35
#: build/C/man2/readlink.2:41 build/C/man2/readv.2:30 build/C/man2/rename.2:32
#: build/C/man2/rmdir.2:30 build/C/man3/setbuf.3:46 build/C/man3/stdin.3:9
#: build/C/man2/symlink.2:32 build/C/man7/symlink.7:35
#: build/C/man2/unlink.2:32 build/C/man2/write.2:39
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/fopencookie.3:27
msgid "fopencookie - opening a custom stream"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:34
#, no-wrap
msgid ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"
msgstr ""
"B<FILE *fopencookie(void *>I<cookie>B<, const char *>I<mode>B<,>\n"
"B<                  cookie_io_functions_t >I<io_funcs>B<);>\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:47
msgid ""
"The B<fopencookie>()  function allows the programmer to create a custom "
"implementation for a standard I/O stream.  This implementation can store the "
"stream's data at a location of its own choosing; for example, B<fopencookie>"
"()  is used to implement B<fmemopen>(3), which provides a stream interface "
"to data that is stored in a buffer in memory."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:49
msgid "In order to create a custom stream the programmer must:"
msgstr ""

#. type: IP
#: build/C/man3/fopencookie.3:49 build/C/man3/fopencookie.3:52
#: build/C/man3/fopencookie.3:63 build/C/man3/scanf.3:669
#: build/C/man3/scanf.3:674 build/C/man3/scanf.3:680
#: build/C/man7/symlink.7:248 build/C/man7/symlink.7:258
#: build/C/man7/symlink.7:288 build/C/man7/symlink.7:348
#: build/C/man7/symlink.7:377 build/C/man7/symlink.7:406
#: build/C/man7/symlink.7:437 build/C/man7/symlink.7:450
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/fopencookie.3:52
msgid ""
"Implement four \"hook\" functions that are used internally by the standard I/"
"O library when performing I/O on the stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:63
msgid ""
"Define a \"cookie\" data type, a structure that provides bookkeeping "
"information (e.g., where to store data) used by the aforementioned hook "
"functions.  The standard I/O package knows nothing about the contents of "
"this cookie (thus it is typed as I<void\\ *> when passed to B<fopencookie>"
"()), but automatically supplies the cookie as the first argument when "
"calling the hook functions."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:68
msgid ""
"Call B<fopencookie>()  to open a new stream and associate the cookie and "
"hook functions with that stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:76
msgid ""
"The B<fopencookie>()  function serves a purpose similar to B<fopen>(3): it "
"opens a new stream and returns a pointer to a I<FILE> object that is used to "
"operate on that stream."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:83
msgid ""
"The I<cookie> argument is a pointer to the caller's cookie structure that is "
"to be associated with the new stream.  This pointer is supplied as the first "
"argument when the standard I/O library invokes any of the hook functions "
"described below."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:99
msgid ""
"The I<mode> argument serves the same purpose as for B<fopen>(3).  The "
"following modes are supported: I<r>, I<w>, I<a>, I<r+>, I<w+>, and I<a+>.  "
"See B<fopen>(3)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:105
msgid ""
"The I<io_funcs> argument is a structure that contains four fields pointing "
"to the programmer-defined hook functions that are used to implement this "
"stream.  The structure is defined as follows"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:114
#, no-wrap
msgid ""
"struct cookie_io_functions_t {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"};\n"
msgstr ""
"struct cookie_io_functions_t {\n"
"    cookie_read_function_t  *read;\n"
"    cookie_write_function_t *write;\n"
"    cookie_seek_function_t  *seek;\n"
"    cookie_close_function_t *close;\n"
"};\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:118
msgid "The four fields are as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:118
#, no-wrap
msgid "I<cookie_read_function_t *read>"
msgstr "I<cookie_read_function_t *read>"

#. type: Plain text
#: build/C/man3/fopencookie.3:122
msgid ""
"This function implements read operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:124
#, no-wrap
msgid "    ssize_t read(void *cookie, char *buf, size_t size);\n"
msgstr "    ssize_t read(void *cookie, char *buf, size_t size);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:139
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer into which "
"input data can be placed and the size of that buffer.  As its function "
"result, the I<read> function should return the number of bytes copied into "
"I<buf>, 0 on end of file, or -1 on error.  The I<read> function should "
"update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:144
msgid ""
"If I<*read> is a NULL pointer, then reads from the custom stream always "
"return end of file."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:144
#, no-wrap
msgid "I<cookie_write_function_t *write>"
msgstr "I<cookie_write_function_t *write>"

#. type: Plain text
#: build/C/man3/fopencookie.3:148
msgid ""
"This function implements write operations for the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:150
#, no-wrap
msgid "    ssize_t write(void *cookie, const char *buf, size_t size);\n"
msgstr "    ssize_t write(void *cookie, const char *buf, size_t size);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:166
msgid ""
"The I<buf> and I<size> arguments are, respectively, a buffer of data to be "
"output to the stream and the size of that buffer.  As its function result, "
"the I<write> function should return the number of bytes copied from I<buf>, "
"or 0 on error.  (The function must not return a negative value.)  The "
"I<write> function should update the stream offset appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:171
msgid "If I<*write> is a NULL pointer, then output to the stream is discarded."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:171
#, no-wrap
msgid "I<cookie_seek_function_t *seek>"
msgstr "I<cookie_seek_function_t *seek>"

#. type: Plain text
#: build/C/man3/fopencookie.3:175
msgid ""
"This function implements seek operations on the stream.  When called, it "
"receives three arguments:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:177
#, no-wrap
msgid "    int seek(void *cookie, off64_t *offset, int whence);\n"
msgstr "    int seek(void *cookie, off64_t *offset, int whence);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:183
msgid ""
"The I<*offset> argument specifies the new file offset depending on which of "
"the following three values is supplied in I<whence>:"
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:184 build/C/man2/lseek.2:65
#, no-wrap
msgid "B<SEEK_SET>"
msgstr "B<SEEK_SET>"

#. type: Plain text
#: build/C/man3/fopencookie.3:189
msgid ""
"The stream offset should be set I<*offset> bytes from the start of the "
"stream."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:189 build/C/man2/lseek.2:70
#, no-wrap
msgid "B<SEEK_CUR>"
msgstr "B<SEEK_CUR>"

#. type: Plain text
#: build/C/man3/fopencookie.3:193
msgid "I<*offset> should be added to the current stream offset."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:193 build/C/man2/lseek.2:75
#, no-wrap
msgid "B<SEEK_END>"
msgstr "B<SEEK_END>"

#. type: Plain text
#: build/C/man3/fopencookie.3:197
msgid ""
"The stream offset should be set to the size of the stream plus I<*offset>."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:204
msgid ""
"Before returning, the I<seek> function should update I<*offset> to indicate "
"the new stream offset."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:208
msgid ""
"As its function result, the I<seek> function should return 0 on success, and "
"-1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:213
msgid ""
"If I<*seek> is a NULL pointer, then it is not possible to perform seek "
"operations on the stream."
msgstr ""

#. type: TP
#: build/C/man3/fopencookie.3:213
#, no-wrap
msgid "I<cookie_close_function_t *close>"
msgstr "I<cookie_close_function_t *close>"

#. type: Plain text
#: build/C/man3/fopencookie.3:219
msgid ""
"This function closes the stream.  The hook function can do things such as "
"freeing buffers allocated for the stream.  When called, it receives one "
"argument:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:221
#, no-wrap
msgid "    int close(void *cookie);\n"
msgstr "    int close(void *cookie);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:226
msgid ""
"The I<cookie> argument is the cookie that the programmer supplied when "
"calling B<fopencookie>()."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:232
msgid ""
"As its function result, the I<close> function should return 0 on success, "
"and B<EOF> on error."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:236
msgid ""
"If I<*close> is NULL, then no special action is performed when the stream is "
"closed."
msgstr ""

#.  .SH ERRORS
#.  It's not clear if errno ever gets set...
#. type: Plain text
#: build/C/man3/fopencookie.3:243
msgid ""
"On success B<fopencookie>()  returns a pointer to the new stream.  On error, "
"NULL is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:245
msgid "This function is a nonstandard GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:254
msgid ""
"The program below implements a custom stream whose functionality is similar "
"(but not identical) to that available via B<fmemopen>(3).  It implements a "
"stream whose data is stored in a memory buffer.  The program writes its "
"command-line arguments to the stream, and then seeks through the stream "
"reading two out of every five characters and writing them to standard "
"output.  The following shell session demonstrates the use of the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:262
#, no-wrap
msgid ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"
msgstr ""
"$B< ./a.out \\(aqhello world\\(aq>\n"
"/he/\n"
"/ w/\n"
"/d/\n"
"Reached end of file\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:269
msgid ""
"Note that a more general version of the program below could be improved to "
"more robustly handle various error situations (e.g., opening a stream with a "
"cookie that already has an open stream; closing a stream that has already "
"been closed)."
msgstr ""

#. type: Plain text
#: build/C/man3/fopencookie.3:278
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:280
#, no-wrap
msgid "#define INIT_BUF_SIZE 4\n"
msgstr "#define INIT_BUF_SIZE 4\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:287
#, no-wrap
msgid ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"
msgstr ""
"struct memfile_cookie {\n"
"    char   *buf;        /* Dynamically sized buffer for data */\n"
"    size_t  allocated;  /* Size of buf */\n"
"    size_t  endpos;     /* Number of characters in buf */\n"
"    off_t   offset;     /* Current file offset in buf */\n"
"};\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:293
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\n"
"memfile_write(void *c, const char *buf, size_t size)\n"
"{\n"
"    char *new_buff;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:295
#, no-wrap
msgid "    /* Buffer too small? Keep doubling size until big enough */\n"
msgstr "    /* Buffer too small? Keep doubling size until big enough */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:305
#, no-wrap
msgid ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (size + cookie-E<gt>offset E<gt> cookie-E<gt>allocated) {\n"
"        new_buff = realloc(cookie-E<gt>buf, cookie-E<gt>allocated * 2);\n"
"        if (new_buff == NULL) {\n"
"            return -1;\n"
"        } else {\n"
"            cookie-E<gt>allocated *= 2;\n"
"            cookie-E<gt>buf = new_buff;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:307
#, no-wrap
msgid "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"
msgstr "    memcpy(cookie-E<gt>buf + cookie-E<gt>offset, buf, size);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:311
#, no-wrap
msgid ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"
msgstr ""
"    cookie-E<gt>offset += size;\n"
"    if (cookie-E<gt>offset E<gt> cookie-E<gt>endpos)\n"
"        cookie-E<gt>endpos = cookie-E<gt>offset;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:314
#, no-wrap
msgid ""
"    return size;\n"
"}\n"
msgstr ""
"    return size;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:320
#, no-wrap
msgid ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"ssize_t\n"
"memfile_read(void *c, char *buf, size_t size)\n"
"{\n"
"    ssize_t xbytes;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:322
#, no-wrap
msgid "    /* Fetch minimum of bytes requested and bytes available */\n"
msgstr "    /* Fetch minimum of bytes requested and bytes available */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:328
#, no-wrap
msgid ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"
msgstr ""
"    xbytes = size;\n"
"    if (cookie-E<gt>offset + size E<gt> cookie-E<gt>endpos)\n"
"        xbytes = cookie-E<gt>endpos - cookie-E<gt>offset;\n"
"    if (xbytes E<lt> 0)     /* offset may be past endpos */\n"
"       xbytes = 0;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:330
#, no-wrap
msgid "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"
msgstr "    memcpy(buf, cookie-E<gt>buf + cookie-E<gt>offset, xbytes);\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:334
#, no-wrap
msgid ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset += xbytes;\n"
"    return xbytes;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:340
#, no-wrap
msgid ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\n"
"memfile_seek(void *c, off64_t *offset, int whence)\n"
"{\n"
"    off64_t new_offset;\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:349
#, no-wrap
msgid ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"
msgstr ""
"    if (whence == SEEK_SET)\n"
"        new_offset = *offset;\n"
"    else if (whence == SEEK_END)\n"
"        new_offset = cookie-E<gt>endpos + *offset;\n"
"    else if (whence == SEEK_CUR)\n"
"        new_offset = cookie-E<gt>offset + *offset;\n"
"    else\n"
"        return -1;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:352
#, no-wrap
msgid ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"
msgstr ""
"    if (new_offset E<lt> 0)\n"
"        return -1;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:357
#, no-wrap
msgid ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"
msgstr ""
"    cookie-E<gt>offset = new_offset;\n"
"    *offset = new_offset;\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:362
#, no-wrap
msgid ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"
msgstr ""
"int\n"
"memfile_close(void *c)\n"
"{\n"
"    struct memfile_cookie *cookie = c;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:366
#, no-wrap
msgid ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"
msgstr ""
"    free(cookie-E<gt>buf);\n"
"    cookie-E<gt>allocated = 0;\n"
"    cookie-E<gt>buf = NULL;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:369
#, no-wrap
msgid ""
"    return 0;\n"
"}\n"
msgstr ""
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:385
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *fp;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cookie_io_functions_t  memfile_func = {\n"
"        .read  = memfile_read,\n"
"        .write = memfile_write,\n"
"        .seek  = memfile_seek,\n"
"        .close = memfile_close\n"
"    };\n"
"    FILE *fp;\n"
"    struct memfile_cookie mycookie;\n"
"    ssize_t nread;\n"
"    long p;\n"
"    int j;\n"
"    char buf[1000];\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:387
#, no-wrap
msgid "    /* Set up the cookie before calling fopencookie() */\n"
msgstr "    /* Set up the cookie before calling fopencookie() */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:393
#, no-wrap
msgid ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    mycookie.buf = malloc(INIT_BUF_SIZE);\n"
"    if (mycookie.buf == NULL) {\n"
"        perror(\"malloc\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:397
#, no-wrap
msgid ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"
msgstr ""
"    mycookie.allocated = INIT_BUF_SIZE;\n"
"    mycookie.offset = 0;\n"
"    mycookie.endpos = 0;\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:403
#, no-wrap
msgid ""
"    fp = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (fp == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    fp = fopencookie(&mycookie,\"w+\", memfile_func);\n"
"    if (fp == NULL) {\n"
"        perror(\"fopencookie\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:405
#, no-wrap
msgid "    /* Write command-line arguments to our file */\n"
msgstr "    /* Write command-line arguments to our file */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:411
#, no-wrap
msgid ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], fp) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    for (j = 1; j E<lt> argc; j++)\n"
"        if (fputs(argv[j], fp) == EOF) {\n"
"            perror(\"fputs\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:413
#, no-wrap
msgid "    /* Read two bytes out of every five, until EOF */\n"
msgstr "    /* Read two bytes out of every five, until EOF */\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:428
#, no-wrap
msgid ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(fp, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, fp);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"
msgstr ""
"    for (p = 0; ; p += 5) {\n"
"        if (fseek(fp, p, SEEK_SET) == -1) {\n"
"            perror(\"fseek\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        nread = fread(buf, 1, 2, fp);\n"
"        if (nread == -1) {\n"
"            perror(\"fread\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        if (nread == 0) {\n"
"            printf(\"Reached end of file\\en\");\n"
"            break;\n"
"        }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:431
#, no-wrap
msgid ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"
msgstr ""
"        printf(\"/%.*s/\\en\", nread, buf);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:434 build/C/man2/readlink.2:211
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/fopencookie.3:440
msgid "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"
msgstr "B<fclose>(3), B<fmemopen>(3), B<fopen>(3), B<fseek>(3)"

#. type: TH
#: build/C/man3/fpurge.3:23
#, no-wrap
msgid "FPURGE"
msgstr "FPURGE"

#. type: TH
#: build/C/man3/fpurge.3:23
#, no-wrap
msgid "2001-12-15"
msgstr "2001-12-15"

#. type: Plain text
#: build/C/man3/fpurge.3:26
msgid "fpurge, __fpurge - purge a stream"
msgstr "fpurge, __fpurge - ストリームを一掃 (purge) する"

#. type: Plain text
#: build/C/man3/fpurge.3:30
#, no-wrap
msgid ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"/* unsupported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:32
#, no-wrap
msgid "B<int fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<int fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:35
#, no-wrap
msgid ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"
msgstr ""
"/* supported */\n"
"B<#include E<lt>stdio.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:37
#, no-wrap
msgid "B<#include E<lt>stdio_ext.hE<gt>>\n"
msgstr "B<#include E<lt>stdio_ext.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:39
#, no-wrap
msgid "B<void  __fpurge(FILE *>I<stream>B<);>\n"
msgstr "B<void  __fpurge(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fpurge.3:52
msgid ""
"The function B<fpurge>()  clears the buffers of the given stream.  For "
"output streams this discards any unwritten output.  For input streams this "
"discards any input read from the underlying object but not yet obtained via "
"B<getc>(3); this includes any text pushed back via B<ungetc>(3).  See also "
"B<fflush>(3)."
msgstr ""
"B<fpurge>()  関数は、与えられたストリームのバッファをクリアする。 出力スト"
"リームでこれを行うと、書き出されていない出力は捨てられる。 入力ストリームでこ"
"れを行うと、 下層にあるオブジェクトから読み込まれ B<getc>(3)  による取得を"
"待っている入力が、すべて捨てられる。 これには B<ungetc>(3)  によって戻された"
"テキストも含まれる。 B<fflush>(3)  も参照のこと。"

#. type: Plain text
#: build/C/man3/fpurge.3:56
msgid ""
"The function B<__fpurge>()  does precisely the same, but without returning a "
"value."
msgstr "B<__fpurge>()  関数も全く同じことを行うが、ただし返り値を返さない。"

#. type: Plain text
#: build/C/man3/fpurge.3:63
msgid ""
"Upon successful completion B<fpurge>()  returns 0.  On error, it returns -1 "
"and sets I<errno> appropriately."
msgstr ""
"成功すると B<fpurge>()  は 0 を返す。 エラーが起こると -1 を返し、 I<errno> "
"を適切な値に設定する。"

#. type: Plain text
#: build/C/man3/fpurge.3:68
msgid "I<stream> is not an open stream."
msgstr "I<stream> がオープンされていない。"

#. type: Plain text
#: build/C/man3/fpurge.3:76
msgid ""
"These functions are nonstandard and not portable.  The function B<fpurge>()  "
"was introduced in 4.4BSD and is not available under Linux.  The function "
"B<__fpurge>()  was introduced in Solaris, and is present in glibc 2.1.95 and "
"later."
msgstr ""
"これらの関数は標準ではなく、よって移植性もない。 B<fpurge>()  関数は 4.4BSD "
"で導入されたが、Linux では利用できない。 B<__fpurge>()  関数は Solaris で導入"
"され、glibc 2.1.95 以降には存在している。"

#. type: Plain text
#: build/C/man3/fpurge.3:78
msgid "Usually it is a mistake to want to discard input buffers."
msgstr "通常は入力バッファを捨てようとするのは間違っている。"

#.  .BR fclean (3),
#. type: Plain text
#: build/C/man3/fpurge.3:83
msgid "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"
msgstr "B<fflush>(3), B<setbuf>(3), B<stdio_ext>(3)"

#. type: TH
#: build/C/man3/fputwc.3:14
#, no-wrap
msgid "FPUTWC"
msgstr "FPUTWC"

#. type: Plain text
#: build/C/man3/fputwc.3:17
msgid "fputwc, putwc - write a wide character to a FILE stream"
msgstr "fputwc, putwc - ワイド文字を FILE ストリームに書き込む"

#. type: Plain text
#: build/C/man3/fputwc.3:25
#, no-wrap
msgid ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t fputwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fputwc.3:41
msgid ""
"The B<fputwc>()  function is the wide-character equivalent of the B<fputc>"
"(3)  function.  It writes the wide character I<wc> to I<stream>.  If I<ferror"
"(stream)> becomes true, it returns B<WEOF>.  If a wide-character conversion "
"error occurs, it sets I<errno> to B<EILSEQ> and returns B<WEOF>.  Otherwise "
"it returns I<wc>."
msgstr ""
"B<fputwc>()  関数は、 B<fputc>(3)  に対応するワイド文字関数である。この 関数"
"は、ワイド文字 I<wc> を I<stream> に書き込む。 I<ferror(stream)> が真になる"
"と、この関数は B<WEOF> を返す。 ワイド文字変換でエラーが発生した場合は、 "
"I<errno> に B<EILSEQ> をセットし、 B<WEOF> を返す。 それ以外の場合では、この"
"関数は I<wc> を返す。"

#. type: Plain text
#: build/C/man3/fputwc.3:49
msgid ""
"The B<putwc>()  function or macro functions identically to B<fputwc>().  It "
"may be implemented as a macro, and may evaluate its argument more than "
"once.  There is no reason ever to use it."
msgstr ""
"B<putwc>()  関数あるいはマクロは、 B<fputwc>()  と全く同じ動作をする。 この関"
"数はマクロとして実装されるかもしれないので、引き数が複数回評価さ れるかもしれ"
"ない。この関数を使う理由はもはや存在しない。"

#. type: Plain text
#: build/C/man3/fputwc.3:58
msgid ""
"The B<fputwc>()  function returns I<wc> if no error occurred, or B<WEOF> to "
"indicate an error."
msgstr ""
"B<fputwc>()  関数は、エラーが起きなければ I<wc> を返す。エラーの場合には "
"B<WEOF> を返す。"

#. type: Plain text
#: build/C/man3/fputwc.3:63
msgid "Conversion of I<wc> to the stream's encoding fails."
msgstr "I<wc> からストリームの符号への変換に失敗した。"

#. type: Plain text
#: build/C/man3/fputwc.3:72
msgid ""
"The behavior of B<fputwc>()  depends on the B<LC_CTYPE> category of the "
"current locale."
msgstr "B<fputwc>()  の動作は現在のロケールの B<LC_CTYPE> カテゴリに依存する。"

#. type: Plain text
#: build/C/man3/fputwc.3:80
msgid ""
"In the absence of additional information passed to the B<fopen>(3)  call, it "
"is reasonable to expect that B<fputwc>()  will actually write the multibyte "
"sequence corresponding to the wide character I<wc>."
msgstr ""
"B<fopen>(3)  システムコールに渡す追加情報がない場合には、 B<fputwc>()  は 実"
"際にはワイド文字 I<wc> に対応するマルチバイトシーケンスを書き込むと 期待して"
"よい。"

#. type: Plain text
#: build/C/man3/fputwc.3:84
msgid "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"
msgstr "B<fgetwc>(3), B<fputws>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fread.3:43
#, no-wrap
msgid "FREAD"
msgstr "FREAD"

#. type: TH
#: build/C/man3/fread.3:43
#, no-wrap
msgid "2012-03-30"
msgstr "2012-03-30"

#. type: Plain text
#: build/C/man3/fread.3:46
msgid "fread, fwrite - binary stream input/output"
msgstr "fread, fwrite - バイナリストリームの入出力"

#. type: Plain text
#: build/C/man3/fread.3:52
#, no-wrap
msgid "B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>I<stream>B<);>\n"
msgstr "B<size_t fread(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fread.3:55
#, no-wrap
msgid ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"
msgstr ""
"B<size_t fwrite(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<nmemb>B<,>\n"
"B<              FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/fread.3:67
msgid ""
"The function B<fread>()  reads I<nmemb> elements of data, each I<size> bytes "
"long, from the stream pointed to by I<stream>, storing them at the location "
"given by I<ptr>."
msgstr ""
"B<fread>()  関数は I<stream> ポインタで指定されたストリームから I<nmemb> 個の"
"データを読み込み、 I<ptr> で与えられた場所に格納する。 個々のデータは "
"I<size> バイトの長さを持つ。"

#. type: Plain text
#: build/C/man3/fread.3:78
msgid ""
"The function B<fwrite>()  writes I<nmemb> elements of data, each I<size> "
"bytes long, to the stream pointed to by I<stream>, obtaining them from the "
"location given by I<ptr>."
msgstr ""
"B<fwrite>()  関数は I<ptr> で指定された場所から得た I<nmemb> 個のデータを、 "
"I<stream> ポインタで指定されたストリームに書き込む。 個々のデータは I<size> "
"バイトの長さを持つ。"

#. type: Plain text
#: build/C/man3/fread.3:94
msgid ""
"On success, B<fread>()  and B<fwrite>()  return the number of I<items> read "
"or written.  This number equals the number of bytes transferred only when "
"I<size> is 1.  If an error occurs, or the end of the file is reached, the "
"return value is a short item count (or zero)."
msgstr ""
"成功すると、 B<fread>() と B<fwrite>() は読み書きを行った要素の個数を返す。\n"
"I<size> が 1 の場合は、この数字は転送されたバイト数と等しい。\n"
"エラーが生じた場合や、ファイルの末尾 (end-of-file) に達した場合、\n"
"返り値は指定した個数よりも小さい値 (または 0) となる。"

#. type: Plain text
#: build/C/man3/fread.3:101
msgid ""
"B<fread>()  does not distinguish between end-of-file and error, and callers "
"must use B<feof>(3)  and B<ferror>(3)  to determine which occurred."
msgstr ""
"B<fread>()  は end-of-file とエラーを区別しないので、 どちらが生じたかを判断"
"するためには、 呼び出し側で B<feof>(3)  と B<ferror>(3)  とを使用しなければな"
"らない。"

#. type: Plain text
#: build/C/man3/fread.3:103
msgid "C89, POSIX.1-2001."
msgstr "C89, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/fread.3:109
msgid "B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"
msgstr ""
"B<read>(2), B<write>(2), B<feof>(3), B<ferror>(3), B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/fseek.3:40
#, no-wrap
msgid "FSEEK"
msgstr "FSEEK"

#. type: TH
#: build/C/man3/fseek.3:40
#, no-wrap
msgid "1993-11-29"
msgstr "1993-11-29"

#. type: Plain text
#: build/C/man3/fseek.3:43
msgid "fgetpos, fseek, fsetpos, ftell, rewind - reposition a stream"
msgstr "fgetpos, fseek, fsetpos, ftell, rewind - ストリームの位置を変更する"

#. type: Plain text
#: build/C/man3/fseek.3:47
msgid "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"
msgstr "B<int fseek(FILE *>I<stream>B<, long >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:49
msgid "B<long ftell(FILE *>I<stream>B<);>"
msgstr "B<long ftell(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:51
msgid "B<void rewind(FILE *>I<stream>B<);>"
msgstr "B<void rewind(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:53
msgid "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr "B<int fgetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:55
msgid "B<int fsetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"
msgstr "B<int fsetpos(FILE *>I<stream>B<, fpos_t *>I<pos>B<);>"

#. type: Plain text
#: build/C/man3/fseek.3:79
msgid ""
"The B<fseek>()  function sets the file position indicator for the stream "
"pointed to by I<stream>.  The new position, measured in bytes, is obtained "
"by adding I<offset> bytes to the position specified by I<whence>.  If "
"I<whence> is set to B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, the offset is "
"relative to the start of the file, the current position indicator, or end-of-"
"file, respectively.  A successful call to the B<fseek>()  function clears "
"the end-of-file indicator for the stream and undoes any effects of the "
"B<ungetc>(3)  function on the same stream."
msgstr ""
"B<fseek>()  関数は I<stream> によって指定されたストリームにおいて、ファイル位"
"置表示子 (file position indicator) をセットする。新たな位置 (バイト単位)  は "
"I<whence> で指定された位置に I<offset> バイトを加えることによって与えられ"
"る。 I<whence> が B<SEEK_SET>, B<SEEK_CUR>, B<SEEK_END> のどれかになっている"
"場合は、それぞれファイルの先頭、現在の位置表示子、 ファイルの末尾からのオフ"
"セットが取られる。 B<fseek>()  関数の呼び出しが成功すると、ストリームの end-"
"of-file 表示子は クリアされ、それまでに B<ungetc>(3)  関数で戻したデータはな"
"かったことになる。"

#. type: Plain text
#: build/C/man3/fseek.3:85
msgid ""
"The B<ftell>()  function obtains the current value of the file position "
"indicator for the stream pointed to by I<stream>."
msgstr ""
"B<ftell>()  関数は I<stream> によって指定されたストリームにおける、ファイル位"
"置表示子 の現時点での値を与える。"

#. type: Plain text
#: build/C/man3/fseek.3:92
msgid ""
"The B<rewind>()  function sets the file position indicator for the stream "
"pointed to by I<stream> to the beginning of the file.  It is equivalent to:"
msgstr ""
"B<rewind>()  関数は I<stream> によって指定されたストリームにおいて、ファイル"
"位置表示子 をファイルの先頭にセットする。この関数は以下と等価である。"

#. type: Plain text
#: build/C/man3/fseek.3:95
msgid "(void) fseek(stream, 0L, SEEK_SET)"
msgstr "(void) fseek(stream, 0L, SEEK_SET)"

#. type: Plain text
#: build/C/man3/fseek.3:99
msgid ""
"except that the error indicator for the stream is also cleared (see "
"B<clearerr>(3))."
msgstr ""
"ただし B<rewind>()  ではストリームに対するエラー表示子 (error indicator) も同"
"時に クリアされる ( B<clearerr>(3)  を見よ)。"

#. type: Plain text
#: build/C/man3/fseek.3:117
msgid ""
"The B<fgetpos>()  and B<fsetpos>()  functions are alternate interfaces "
"equivalent to B<ftell>()  and B<fseek>()  (with whence set to B<SEEK_SET>), "
"setting and storing the current value of the file offset into or from the "
"object referenced by I<pos>.  On some non-UNIX systems an I<fpos_t> object "
"may be a complex object and these routines may be the only way to portably "
"reposition a text stream."
msgstr ""
"B<fgetpos>()  関数と B<fsetpos>()  関数は、それぞれ B<ftell>()  と B<fseek>"
"()  で I<whence> に B<SEEK_SET> を指定した場合と同様の機能を、異なるインター"
"フェースで提供する。 B<fgetpos>()  はファイルオフセットの現在の値を I<pos> が"
"参照するオブジェクトに保存し、 B<fsetpos>()  はファイルオフセットを I<pos> に"
"設定する。 UNIX 以外のシステムにおいては、 I<fpos_t> が構造体などの複雑なオブ"
"ジェクトになっていて、これらのルーチンがテキス トストリームでファイル位置を変"
"更する方法のうち、移植性のある唯一のもの になっている場合もある。"

#. type: Plain text
#: build/C/man3/fseek.3:132
msgid ""
"The B<rewind>()  function returns no value.  Upon successful completion, "
"B<fgetpos>(), B<fseek>(), B<fsetpos>()  return 0, and B<ftell>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"B<rewind>()  は返り値を持たない。 B<fgetpos>(), B<fseek>(), B<fsetpos>()  は"
"成功すると 0 を返す。 B<ftell>()  は現在のオフセットを返す。失敗した場合は返"
"り値は -1 となり、 I<errno> にエラーを示す値がセットされる。"

#. type: Plain text
#: build/C/man3/fseek.3:138
msgid "The I<stream> specified is not a seekable stream."
msgstr "指定した I<stream> がシークできない。"

#. type: Plain text
#: build/C/man3/fseek.3:149
msgid ""
"The I<whence> argument to B<fseek>()  was not B<SEEK_SET>, B<SEEK_END>, or "
"B<SEEK_CUR>."
msgstr ""
"B<fseek>()  関数に対して与えた I<whence> 引数が B<SEEK_SET>, B<SEEK_END>, "
"B<SEEK_CUR> 以外の値であった。"

#. type: Plain text
#: build/C/man3/fseek.3:164
msgid ""
"The functions B<fgetpos>(), B<fseek>(), B<fsetpos>(), and B<ftell>()  may "
"also fail and set I<errno> for any of the errors specified for the routines "
"B<fflush>(3), B<fstat>(2), B<lseek>(2), and B<malloc>(3)."
msgstr ""
"B<fgetpos>(), B<fseek>(), B<fsetpos>(), B<ftell>()  は、それぞれ B<fflush>"
"(3), B<fstat>(2), B<lseek>(2), B<malloc>(3)  などのルーチンを呼び出す際に失敗"
"する可能性がある。この場合は それぞれ対応した I<errno> が設定される。"

#. type: Plain text
#: build/C/man3/fseek.3:169
msgid "B<lseek>(2), B<fseeko>(3)"
msgstr "B<lseek>(2), B<fseeko>(3)"

#. type: TH
#: build/C/man3/fseeko.3:23
#, no-wrap
msgid "FSEEKO"
msgstr "FSEEKO"

#. type: TH
#: build/C/man3/fseeko.3:23
#, no-wrap
msgid "2001-11-05"
msgstr "2001-11-05"

#. type: Plain text
#: build/C/man3/fseeko.3:26
msgid "fseeko, ftello - seek to or report file position"
msgstr "fseeko, ftello - ファイル位置を探す/報告する"

#. type: Plain text
#: build/C/man3/fseeko.3:31
#, no-wrap
msgid "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<int fseeko(FILE *>I<stream>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/fseeko.3:34
#, no-wrap
msgid ""
"B<off_t ftello(FILE *>I<stream>B<);>\n"
"\n"
msgstr ""
"B<off_t ftello(FILE *>I<stream>B<);>\n"
"\n"

#. type: Plain text
#: build/C/man3/fseeko.3:52
msgid ""
"The B<fseeko>()  and B<ftello>()  functions are identical to B<fseek>(3)  "
"and B<ftell>(3)  (see B<fseek>(3)), respectively, except that the I<offset> "
"argument of B<fseeko>()  and the return value of B<ftello>()  is of type "
"I<off_t> instead of I<long>."
msgstr ""
"B<fseeko>()  関数および B<ftello>()  関数は、 それぞれ B<fseek>(3)  および "
"B<ftell>(3)  と同一の機能を持つ (B<fseek>(3)  を見よ) が、ただし B<fseeko>"
"()  関数の I<offset> 引数と B<ftello>()  の返り値が、 I<long> ではなく "
"I<off_t> になっている。"

#. type: Plain text
#: build/C/man3/fseeko.3:55
msgid ""
"On many architectures both I<off_t> and I<long> are 32-bit types, but "
"compilation with"
msgstr ""
"多くのアーキテクチャでは I<off_t> も I<long> も共に 32 ビットの型であるが、"

#. type: Plain text
#: build/C/man3/fseeko.3:59 build/C/man3/lseek64.3:79
#, no-wrap
msgid "#define _FILE_OFFSET_BITS 64\n"
msgstr "#define _FILE_OFFSET_BITS 64\n"

#. type: Plain text
#: build/C/man3/fseeko.3:63
msgid "will turn I<off_t> into a 64-bit type."
msgstr "でコンパイルすると I<off_t> は 64 ビット型となる。"

#. type: Plain text
#: build/C/man3/fseeko.3:72
msgid ""
"On successful completion, B<fseeko>()  returns 0, while B<ftello>()  returns "
"the current offset.  Otherwise, -1 is returned and I<errno> is set to "
"indicate the error."
msgstr ""
"成功した場合、 B<fseeko>()  は 0 を、 B<ftello>()  は現在のオフセットを返"
"す。 失敗した場合、-1 を返し、 I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/fseeko.3:75
msgid "See the ERRORS in B<fseek>(3)."
msgstr "B<fseek>(3)  の「エラー」の節を参照。"

#. type: Plain text
#: build/C/man3/fseeko.3:77
msgid "SUSv2, POSIX.1-2001."
msgstr "SUSv2, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/fseeko.3:81
msgid ""
"These functions are found on System V-like systems.  They are not present in "
"libc4, libc5, glibc 2.0 but are available since glibc 2.1."
msgstr ""
"これらの関数は System V 的なシステムにある。 libc4, libc5, glibc 2.0 にはな"
"かったが、 glibc 2.1 から使えるようになった。"

#. type: Plain text
#: build/C/man3/fseeko.3:83
msgid "B<fseek>(3)"
msgstr "B<fseek>(3)"

#. type: TH
#: build/C/man3/getline.3:24
#, no-wrap
msgid "GETLINE"
msgstr "GETLINE"

#. type: TH
#: build/C/man3/getline.3:24
#, no-wrap
msgid "2010-06-12"
msgstr "2010-06-12"

#. type: Plain text
#: build/C/man3/getline.3:27
msgid "getline, getdelim - delimited string input"
msgstr "getline, getdelim - 区切り文字までの文字列入力を読み込む"

#. type: Plain text
#: build/C/man3/getline.3:32
#, no-wrap
msgid "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getline(char **>I<lineptr>B<, size_t *>I<n>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getline.3:35
#, no-wrap
msgid "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"
msgstr "B<ssize_t getdelim(char **>I<lineptr>B<, size_t *>I<n>B<, int >I<delim>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getline.3:45
msgid "B<getline>(), B<getdelim>():"
msgstr "B<getline>(), B<getdelim>():"

#. type: Plain text
#: build/C/man3/getline.3:50
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"

#. type: Plain text
#: build/C/man3/getline.3:63
msgid ""
"B<getline>()  reads an entire line from I<stream>, storing the address of "
"the buffer containing the text into I<*lineptr>.  The buffer is null-"
"terminated and includes the newline character, if one was found."
msgstr ""
"B<getline>()  は I<stream> から 1 行全てを読み込み、テキストが含まれている"
"バッファのアドレスを I<*lineptr> に格納する。 バッファはヌル文字 (\\e0) で終"
"端される。 改行文字が見つかった場合は、改行文字もバッファに格納される。"

#. type: Plain text
#: build/C/man3/getline.3:73
msgid ""
"If I<*lineptr> is NULL, then B<getline>()  will allocate a buffer for "
"storing the line, which should be freed by the user program.  (In this case, "
"the value in I<*n> is ignored.)"
msgstr ""
"I<*lineptr> が NULL の場合、 B<getline>()  は行の内容を格納するためのバッファ"
"を確保する。 このバッファはユーザーのプログラムで解放すべきである (この場"
"合、 I<*n> の値は無視される)。"

#. type: Plain text
#: build/C/man3/getline.3:91
msgid ""
"Alternatively, before calling B<getline>(), I<*lineptr> can contain a "
"pointer to a B<malloc>(3)-allocated buffer I<*n> bytes in size.  If the "
"buffer is not large enough to hold the line, B<getline>()  resizes it with "
"B<realloc>(3), updating I<*lineptr> and I<*n> as necessary."
msgstr ""
"別の方法として、 B<getline>()  を呼び出す際に、 I<*lineptr> に B<malloc>(3)  "
"で確保した大きさ I<*n> バイトのバッファへのポインタを入れて渡すこともでき"
"る。 読み込んだ行を保持するのに十分なバッファがない場合、 B<getline>()  は "
"B<realloc>(3)  を使ってバッファのサイズを変更し、必要に応じて I<*lineptr> と "
"I<*n> を更新する。"

#. type: Plain text
#: build/C/man3/getline.3:97
msgid ""
"In either case, on a successful call, I<*lineptr> and I<*n> will be updated "
"to reflect the buffer address and allocated size respectively."
msgstr ""
"どちらの場合でも、呼び出しに成功したときには、 I<*lineptr> と I<*n> がバッ"
"ファのアドレスと割り当てたサイズを反映した値に更新される。"

#. type: Plain text
#: build/C/man3/getline.3:108
msgid ""
"B<getdelim>()  works like B<getline>(), except that a line delimiter other "
"than newline can be specified as the I<delimiter> argument.  As with "
"B<getline>(), a delimiter character is not added if one was not present in "
"the input before end of file was reached."
msgstr ""
"B<getdelim>()  は B<getline>()  と同じように動作するが、改行文字以外の区切り"
"文字を引き数 I<delim> に指定することができる。 B<getline>()  と同様に、ファイ"
"ル終端に達するまでに入力行に区切り文字が見付からない場合は、 区切り文字をバッ"
"ファに追加しない。"

#. type: Plain text
#: build/C/man3/getline.3:117
msgid ""
"On success, B<getline>()  and B<getdelim>()  return the number of characters "
"read, including the delimiter character, but not including the terminating "
"null byte.  This value can be used to handle embedded null bytes in the line "
"read."
msgstr ""
"成功した場合、 B<getline>()  と B<getdelim>()  は読み込んだ文字数を返す。 文"
"字数には区切り文字は含まれるが、終端に使う NULL バイトは含まれない。 この値に"
"よって、読み込んだ行に含まれる NULL バイトを操作することができる。"

#. type: Plain text
#: build/C/man3/getline.3:120
msgid ""
"Both functions return -1 on failure to read a line (including end-of-file "
"condition)."
msgstr ""
"どちらの関数も、行の読み込みに失敗した場合には -1 を返す (ファイルの終端に達"
"した場合にも -1 を返す)。"

#. type: Plain text
#: build/C/man3/getline.3:130
msgid "Bad arguments (I<n> or I<lineptr> is NULL, or I<stream> is not valid)."
msgstr ""
"引き数が不正である (I<n> または I<lineptr> が NULL である。 もしくは "
"I<stream> が有効でない)。"

#. type: Plain text
#: build/C/man3/getline.3:132
msgid "These functions are available since libc 4.6.27."
msgstr "これらの関数は libc 4.6.27 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/getline.3:139
msgid ""
"Both B<getline>()  and B<getdelim>()  were originally GNU extensions.  They "
"were standardized in POSIX.1-2008."
msgstr ""
"B<getline>()  と B<getdelim>()  は、どちらも元は GNU による拡張であったが、 "
"POSIX.1-2008 で標準化された。"

#. type: Plain text
#: build/C/man3/getline.3:144
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getline.3:152
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t read;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    FILE *fp;\n"
"    char *line = NULL;\n"
"    size_t len = 0;\n"
"    ssize_t read;\n"

#. type: Plain text
#: build/C/man3/getline.3:156
#, no-wrap
msgid ""
"    fp = fopen(\"/etc/motd\", \"r\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"
msgstr ""
"    fp = fopen(\"/etc/motd\", \"r\");\n"
"    if (fp == NULL)\n"
"        exit(EXIT_FAILURE);\n"

#. type: Plain text
#: build/C/man3/getline.3:161
#, no-wrap
msgid ""
"    while ((read = getline(&line, &len, fp)) != -1) {\n"
"        printf(\"Retrieved line of length %zu :\\en\", read);\n"
"        printf(\"%s\", line);\n"
"    }\n"
msgstr ""
"    while ((read = getline(&line, &len, fp)) != -1) {\n"
"        printf(\"Retrieved line of length %zu :\\en\", read);\n"
"        printf(\"%s\", line);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getline.3:165
#, no-wrap
msgid ""
"    free(line);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(line);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/getline.3:173
msgid ""
"B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<gets>(3), B<scanf>(3)"
msgstr ""
"B<read>(2), B<fgets>(3), B<fopen>(3), B<fread>(3), B<gets>(3), B<scanf>(3)"

#. type: TH
#: build/C/man3/gets.3:25
#, no-wrap
msgid "GETS"
msgstr "GETS"

#. type: TH
#: build/C/man3/gets.3:25
#, no-wrap
msgid "2012-01-18"
msgstr "2012-01-18"

#. type: Plain text
#: build/C/man3/gets.3:28
msgid ""
"fgetc, fgets, getc, getchar, gets, ungetc - input of characters and strings"
msgstr "fgetc, fgets, getc, getchar, gets, ungetc - 文字と文字列の入力"

#. type: Plain text
#: build/C/man3/gets.3:33
#, no-wrap
msgid "B<int fgetc(FILE *>I<stream>B<);>\n"
msgstr "B<int fgetc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/gets.3:35
#, no-wrap
msgid "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"
msgstr "B<char *fgets(char *>I<s>B<, int >I<size>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/gets.3:37
#, no-wrap
msgid "B<int getc(FILE *>I<stream>B<);>\n"
msgstr "B<int getc(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/gets.3:39
#, no-wrap
msgid "B<int getchar(void);>\n"
msgstr "B<int getchar(void);>\n"

#. type: Plain text
#: build/C/man3/gets.3:41
#, no-wrap
msgid "B<char *gets(char *>I<s>B<);>\n"
msgstr "B<char *gets(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/gets.3:43
#, no-wrap
msgid "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int ungetc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/gets.3:55
msgid ""
"B<fgetc>()  reads the next character from I<stream> and returns it as an "
"I<unsigned char> cast to an I<int>, or B<EOF> on end of file or error."
msgstr ""
"B<fgetc>()  は、 I<stream> から次の文字を I<unsigned char> として読み、 "
"I<int> にキャストして返す。ファイルの終わりやエラーとなった場合は B<EOF> を返"
"す。"

#. type: Plain text
#: build/C/man3/gets.3:62
msgid ""
"B<getc>()  is equivalent to B<fgetc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""
"B<getc>()  は B<fgetc>()  と同様だが、 I<stream> を複数回評価するマクロとして"
"実装されているかもしれない。"

#. type: Plain text
#: build/C/man3/gets.3:66
msgid "B<getchar>()  is equivalent to B<getc(>I<stdin>B<)>."
msgstr "B<getchar>()  は B<getc(>I<stdin>B<)> と同じである。"

#. type: Plain text
#: build/C/man3/gets.3:76
msgid ""
"B<gets>()  reads a line from I<stdin> into the buffer pointed to by I<s> "
"until either a terminating newline or B<EOF>, which it replaces with a null "
"byte (\\(aq\\e0\\(aq).  No check for buffer overrun is performed (see BUGS "
"below)."
msgstr ""
"B<gets>()  は、改行文字か B<EOF> までの 1行を I<stdin> から読み込み I<s> が指"
"すバッファに格納する (末尾の改行文字や B<EOF> は NULL バイト (\\(aq"
"\\e0\\(aq) に置き換えられる)。 バッファオーバーランのチェックは行われない (下"
"記の「バグ」を参照)。"

#. type: Plain text
#: build/C/man3/gets.3:90
msgid ""
"B<fgets>()  reads in at most one less than I<size> characters from I<stream> "
"and stores them into the buffer pointed to by I<s>.  Reading stops after an "
"B<EOF> or a newline.  If a newline is read, it is stored into the buffer.  A "
"terminating null byte (\\(aq\\e0\\(aq)  is stored after the last character "
"in the buffer."
msgstr ""
"B<fgets>()  は I<stream> から最大で I<size> - 1 個の文字を読み込み、 I<s> が"
"指すバッファに格納する。読み込みは B<EOF> または改行文字を読み込んだ後で停止"
"する。 読み込まれた改行文字はバッファに格納される。 終端の NULL バイト (\\(aq"
"\\e0\\(aq)  が一つバッファの中の最後の文字の後に書き込まれる。"

#. type: Plain text
#: build/C/man3/gets.3:101
msgid ""
"B<ungetc>()  pushes I<c> back to I<stream>, cast to I<unsigned char>, where "
"it is available for subsequent read operations.  Pushed-back characters will "
"be returned in reverse order; only one pushback is guaranteed."
msgstr ""
"B<ungetc>()  は、後の read 操作で読めるように、 I<c> を I<unsigned char> に"
"キャストして I<stream> に書き戻す。 書き戻された文字は逆順に戻される; 書き戻"
"しとして保証されているのは、一文字だけである。"

#. type: Plain text
#: build/C/man3/gets.3:106
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other input functions from the I<stdio> library for the same input "
"stream."
msgstr ""
"ここで述べた関数や I<stdio> ライブラリの入力関数を同じ入力ストリームに対して"
"互いに混ぜて使うことができる。"

#. type: Plain text
#: build/C/man3/gets.3:121
msgid ""
"B<fgetc>(), B<getc>()  and B<getchar>()  return the character read as an "
"I<unsigned char> cast to an I<int> or B<EOF> on end of file or error."
msgstr ""
"B<fgetc>(), B<getc>(), B<getchar>()  は、文字を I<unsigned char> として読ん"
"で I<int> にキャストして返す。ファイルの終わりやエラーの場合は B<EOF> を返"
"す。"

#. type: Plain text
#: build/C/man3/gets.3:129
msgid ""
"B<gets>()  and B<fgets>()  return I<s> on success, and NULL on error or when "
"end of file occurs while no characters have been read."
msgstr ""
"B<gets>()  と B<fgets>()  は、成功すると I<s> を返し、エラーや 1 文字も読み込"
"んでいないのにファイルの終わりになった 場合に NULL を返す。"

#. type: Plain text
#: build/C/man3/gets.3:136
msgid "B<ungetc>()  returns I<c> on success, or B<EOF> on error."
msgstr "B<ungetc>()  は成功すると I<c> を返し、エラーの場合は B<EOF> を返す。"

#. type: Plain text
#: build/C/man3/gets.3:138
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/gets.3:150
msgid ""
"LSB deprecates B<gets>().  POSIX.1-2008 marks B<gets>()  obsolescent.  ISO "
"C11 removes the specification of B<gets>()  from the C language, and since "
"version 2.16, glibc header files don't expose the function declaration if "
"the B<_ISOC11_SOURCE> feature test macro is defined."
msgstr ""
"LSB は B<gets>() を非推奨としている。\n"
"POSIX.1-2008 では B<gets>() に廃止予定の印が付けられている。\n"
"ISO C11 では B<gets>)() の規定が C 言語から削除されている。\n"
"glibc バージョン 2.16 以降では、機能検査マシン B<_ISOC11_SOURCE> が定義され"
"た\n"
"場合、glibc ヘッダファイルでは B<gets>)() の宣言が公開されない。"

#. type: Plain text
#: build/C/man3/gets.3:164
msgid ""
"Never use B<gets>().  Because it is impossible to tell without knowing the "
"data in advance how many characters B<gets>()  will read, and because B<gets>"
"()  will continue to store characters past the end of the buffer, it is "
"extremely dangerous to use.  It has been used to break computer security.  "
"Use B<fgets>()  instead."
msgstr ""
"B<gets>()  は絶対に使用してはならない。 前もってデータを知ることなしに "
"B<gets>()  が何文字読むかを知ることはできず、 B<gets>()  がバッファの終わりを"
"越えて書き込み続けるため、 B<gets>()  を使うのは極めて危険である。 これを利用"
"してコンピュータのセキュリティが破られてきた。 代わりに B<fgets>()  を使うこ"
"と。"

#. type: Plain text
#: build/C/man3/gets.3:171
msgid ""
"It is not advisable to mix calls to input functions from the I<stdio> "
"library with low-level calls to B<read>(2)  for the file descriptor "
"associated with the input stream; the results will be undefined and very "
"probably not what you want."
msgstr ""
"入力ストリームのファイルディスクリプタに対して、 I<stdio> ライブラリの入力関"
"数と、低レベル呼び出しの B<read>(2)  を混ぜて呼び出す事は勧められない。 結果"
"がどうなるかは分からず、おそらくあなたの 望んでいる結果にはならないだろう。"

#. type: Plain text
#: build/C/man3/gets.3:187
msgid ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3), B<fopen>"
"(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<getwchar>(3), B<puts>(3), "
"B<scanf>(3), B<ungetwc>(3), B<unlocked_stdio>(3), B<feature_test_macros>(7)"
msgstr ""
"B<read>(2), B<write>(2), B<ferror>(3), B<fgetwc>(3), B<fgetws>(3),\n"
"B<fopen>(3), B<fread>(3), B<fseek>(3), B<getline>(3), B<getwchar>(3),\n"
"B<puts>(3), B<scanf>(3), B<ungetwc>(3), B<unlocked_stdio>(3),\n"
"B<feature_test_macros>(7)"

#. type: TH
#: build/C/man3/getw.3:23
#, no-wrap
msgid "GETW"
msgstr "GETW"

#. type: TH
#: build/C/man3/getw.3:23
#, no-wrap
msgid "2010-09-26"
msgstr "2010-09-26"

#. type: Plain text
#: build/C/man3/getw.3:26
msgid "getw, putw - input and output of words (ints)"
msgstr "getw, putw - ワード(int)の入出力"

#. type: Plain text
#: build/C/man3/getw.3:31
#, no-wrap
msgid "B<int getw(FILE *>I<stream>B<);>\n"
msgstr "B<int getw(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getw.3:33
#, no-wrap
msgid "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putw(int >I<w>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/getw.3:42
msgid "B<getw>(), B<putw>():"
msgstr "B<getw>(), B<putw>():"

#. type: TP
#: build/C/man3/getw.3:45
#, no-wrap
msgid "Since glibc 2.3.3:"
msgstr "glibc 2.3.3 以降:"

#. type: Plain text
#: build/C/man3/getw.3:48
msgid "_SVID_SOURCE || _BSD_SOURCE ||"
msgstr "_SVID_SOURCE || _BSD_SOURCE ||"

#. type: Plain text
#: build/C/man3/getw.3:51
#, no-wrap
msgid ""
"(_XOPEN_SOURCE &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600))\n"
msgstr ""
"(_XOPEN_SOURCE &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600))\n"

#. type: TP
#: build/C/man3/getw.3:51
#, no-wrap
msgid "Before glibc 2.3.3:"
msgstr "glibc 2.3.3 より前:"

#. type: Plain text
#: build/C/man3/getw.3:54
msgid "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/getw.3:64
msgid ""
"B<getw>()  reads a word (that is, an I<int>) from I<stream>.  It's provided "
"for compatibility with SVr4.  We recommend you use B<fread>(3)  instead."
msgstr ""
"B<getw>()  は I<stream> からワード (I<int>型) を読み込む。 この関数は、SVr4 "
"との互換性のために提供されている。 この関数の代わりに B<fread>(3)  を使用する"
"ことを勧める。"

#. type: Plain text
#: build/C/man3/getw.3:71
msgid ""
"B<putw>()  writes the word I<w> (that is, an I<int>) to I<stream>.  It is "
"provided for compatibility with SVr4, but we recommend you use B<fwrite>(3)  "
"instead."
msgstr ""
"B<putw>()  は I<stream> にワード I<w> (I<int>型) を書き込む。 この関数は "
"SVr4 との互換性のために提供されているが、この関数の代わりに B<fwrite>(3)  を"
"使用することを勧める。"

#. type: Plain text
#: build/C/man3/getw.3:78
msgid ""
"Normally, B<getw>()  returns the word read, and B<putw>()  returns 0.  On "
"error, they return B<EOF>."
msgstr ""
"通常、 B<getw>()  は読み込んだワードを返し、 B<putw>()  は 0 を返す。 エラー"
"が発生した場合、これらの関数は B<EOF> を返す。"

#. type: Plain text
#: build/C/man3/getw.3:80
msgid "SVr4, SUSv2.  Not present in POSIX.1-2001."
msgstr "SVr4, SUSv2.  POSIX.1-2001 には存在しない。"

#. type: Plain text
#: build/C/man3/getw.3:84
msgid ""
"The value returned on error is also a legitimate data value.  B<ferror>(3)  "
"can be used to distinguish between the two cases."
msgstr ""
"エラーの時に返される値は、正しいデータとして返されることもある。 B<ferror>"
"(3)  を用いると、この二つの場合を区別することが出来る。"

#. type: Plain text
#: build/C/man3/getw.3:90
msgid "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"
msgstr "B<ferror>(3), B<fread>(3), B<fwrite>(3), B<getc>(3), B<putc>(3)"

#. type: TH
#: build/C/man2/link.2:31
#, no-wrap
msgid "LINK"
msgstr "LINK"

#. type: TH
#: build/C/man2/link.2:31
#, no-wrap
msgid "2008-08-21"
msgstr "2008-08-21"

#. type: Plain text
#: build/C/man2/link.2:34
msgid "link - make a new name for a file"
msgstr "link - ファイルの新しい名前を作成する"

#. type: Plain text
#: build/C/man2/link.2:36 build/C/man2/lseek.2:52 build/C/man3/lseek64.3:32
#: build/C/man2/readlink.2:46 build/C/man2/rmdir.2:35
#: build/C/man2/symlink.2:37 build/C/man2/unlink.2:37 build/C/man2/write.2:44
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/link.2:38
msgid "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"
msgstr "B<int link(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"

#. type: Plain text
#: build/C/man2/link.2:41
msgid ""
"B<link>()  creates a new link (also known as a hard link) to an existing "
"file."
msgstr ""
"B<link>()  は存在するファイルへの新しいリンク (link)  (ハードリンク (hard "
"link) ともいう) を作成する。"

#. type: Plain text
#: build/C/man2/link.2:47 build/C/man2/symlink.2:84
msgid "If I<newpath> exists it will I<not> be overwritten."
msgstr "I<newpath> が存在する場合には上書きはI<されない>。"

#. type: Plain text
#: build/C/man2/link.2:52
msgid ""
"This new name may be used exactly as the old one for any operation; both "
"names refer to the same file (and so have the same permissions and "
"ownership) and it is impossible to tell which name was the \"original\"."
msgstr ""
"この新しい名前は全ての操作において古い名前と完全に同じように使用される; 両方"
"の名前は同じファイルを参照しており (それで同じ許可 (permission) や所有者 "
"(ownership) となるので)、 どちらの名前が本来のものであるか判別できない。"

#. type: Plain text
#: build/C/man2/link.2:57 build/C/man2/pipe.2:97 build/C/man3/remove.3:65
#: build/C/man2/rename.2:96 build/C/man2/rmdir.2:45 build/C/man2/symlink.2:89
#: build/C/man2/unlink.2:60
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: TP
#: build/C/man2/link.2:58 build/C/man2/open.2:473 build/C/man2/readlink.2:84
#: build/C/man2/rename.2:97 build/C/man2/rmdir.2:46 build/C/man2/symlink.2:90
#: build/C/man3/tmpfile.3:53 build/C/man2/unlink.2:61
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/link.2:69
msgid ""
"Write access to the directory containing I<newpath> is denied, or search "
"permission is denied for one of the directories in the path prefix of "
"I<oldpath> or I<newpath>.  (See also B<path_resolution>(7).)"
msgstr ""
"I<newpath> を含んでいるディレクトリへの書き込みが許されていないか、 "
"I<oldpath> または I<newpath> へのディレクトリのどれかに検索許可がない "
"(B<path_resolution>(7)  を参照)。"

#. type: TP
#: build/C/man2/link.2:69 build/C/man2/open.2:482 build/C/man2/symlink.2:99
#: build/C/man3/tmpfile.3:56
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/link.2:73 build/C/man2/symlink.2:103
msgid "I<newpath> already exists."
msgstr "I<newpath> が既に存在する。"

#. type: TP
#: build/C/man2/link.2:73 build/C/man2/llseek.2:69 build/C/man2/open.2:488
#: build/C/man2/pipe.2:98 build/C/man2/read.2:100 build/C/man2/readlink.2:89
#: build/C/man2/rename.2:133 build/C/man2/rmdir.2:64
#: build/C/man2/symlink.2:103 build/C/man2/unlink.2:80
#: build/C/man2/write.2:135
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/link.2:76 build/C/man2/rename.2:136 build/C/man2/symlink.2:106
msgid "I<oldpath> or I<newpath> points outside your accessible address space."
msgstr ""
"I<oldpath> や I<newpath> がアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/link.2:76 build/C/man2/read.2:129 build/C/man2/readlink.2:105
#: build/C/man2/symlink.2:106 build/C/man2/unlink.2:84
#: build/C/man2/write.2:159
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/link.2:79 build/C/man2/symlink.2:109 build/C/man2/unlink.2:87
msgid "An I/O error occurred."
msgstr "I/O エラーが発生した。"

#. type: TP
#: build/C/man2/link.2:79 build/C/man2/open.2:512 build/C/man2/readlink.2:108
#: build/C/man2/rename.2:146 build/C/man2/rmdir.2:73
#: build/C/man2/symlink.2:109 build/C/man2/unlink.2:92
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/link.2:83 build/C/man2/rename.2:150
msgid ""
"Too many symbolic links were encountered in resolving I<oldpath> or "
"I<newpath>."
msgstr ""
"I<oldpath> または I<newpath> を解決する際に遭遇したシンボリックリンクが多過ぎ"
"る。"

#. type: TP
#: build/C/man2/link.2:83 build/C/man2/rename.2:150
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: build/C/man2/link.2:88
msgid ""
"The file referred to by I<oldpath> already has the maximum number of links "
"to it."
msgstr ""
"I<oldpath> によって参照されるファイルは 既に最大数までのリンクを持っている。"

#. type: TP
#: build/C/man2/link.2:88 build/C/man2/open.2:522 build/C/man2/readlink.2:111
#: build/C/man2/rename.2:157 build/C/man2/rmdir.2:77
#: build/C/man2/symlink.2:113 build/C/man2/unlink.2:96
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/link.2:91 build/C/man2/rename.2:160 build/C/man2/symlink.2:116
msgid "I<oldpath> or I<newpath> was too long."
msgstr "I<oldpath> または I<newpath> が長過ぎる。"

#. type: TP
#: build/C/man2/link.2:91 build/C/man2/open.2:536 build/C/man2/readlink.2:114
#: build/C/man2/rename.2:160 build/C/man2/rmdir.2:80
#: build/C/man2/symlink.2:116 build/C/man2/unlink.2:99
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/link.2:96
msgid ""
"A directory component in I<oldpath> or I<newpath> does not exist or is a "
"dangling symbolic link."
msgstr ""
"I<oldpath> または I<newpath> のディレクトリ部分が存在しないか、 壊れた"
"(dangling)シンボリックリンクである。"

#. type: TP
#: build/C/man2/link.2:96 build/C/man2/open.2:543 build/C/man2/readlink.2:117
#: build/C/man2/rename.2:173 build/C/man2/rmdir.2:85 build/C/man3/scanf.3:568
#: build/C/man2/symlink.2:123 build/C/man3/tempnam.3:91
#: build/C/man2/unlink.2:106
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/link.2:99 build/C/man2/open.2:546 build/C/man2/readlink.2:120
#: build/C/man2/rename.2:176 build/C/man2/rmdir.2:88
#: build/C/man2/symlink.2:126 build/C/man2/unlink.2:109
msgid "Insufficient kernel memory was available."
msgstr "十分なカーネルメモリーがない。"

#. type: TP
#: build/C/man2/link.2:99 build/C/man2/open.2:546 build/C/man2/rename.2:176
#: build/C/man2/symlink.2:126 build/C/man3/tmpfile.3:68
#: build/C/man2/write.2:162
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/link.2:103 build/C/man2/rename.2:180
#: build/C/man2/symlink.2:130
msgid "The device containing the file has no room for the new directory entry."
msgstr ""
"そのファイルを含んでいるデバイスに新しいディレクトリエントリを 作成するための"
"空きがない。"

#. type: TP
#: build/C/man2/link.2:103 build/C/man2/open.2:552 build/C/man2/readlink.2:120
#: build/C/man2/rename.2:180 build/C/man2/rmdir.2:88
#: build/C/man2/symlink.2:130 build/C/man2/unlink.2:109
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/link.2:108
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory."
msgstr ""
"I<oldpath> または I<newpath> のディレクトリ部分が、実際には、ディレクトリでな"
"い。"

#. type: TP
#: build/C/man2/link.2:108 build/C/man2/link.2:112 build/C/man2/open.2:585
#: build/C/man2/rmdir.2:107 build/C/man2/rmdir.2:118
#: build/C/man2/symlink.2:135 build/C/man2/unlink.2:114
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/link.2:112
msgid "I<oldpath> is a directory."
msgstr "I<oldpath> がディレクトリである。"

#. type: Plain text
#: build/C/man2/link.2:117
msgid ""
"The file system containing I<oldpath> and I<newpath> does not support the "
"creation of hard links."
msgstr ""
"I<oldpath> と I<newpath> を含んでいるファイルシステムがハードリンクをサポート"
"していない。"

#. type: TP
#: build/C/man2/link.2:117 build/C/man2/open.2:593 build/C/man2/rename.2:218
#: build/C/man2/rmdir.2:123 build/C/man2/symlink.2:140
#: build/C/man3/tmpfile.3:71 build/C/man2/unlink.2:137
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/link.2:120 build/C/man2/rename.2:221
msgid "The file is on a read-only file system."
msgstr "ファイルが読み込み専用のファイルシステムに存在する。"

#. type: TP
#: build/C/man2/link.2:120 build/C/man2/rename.2:221
#, no-wrap
msgid "B<EXDEV>"
msgstr "B<EXDEV>"

#. type: Plain text
#: build/C/man2/link.2:128
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted file system.  (Linux "
"permits a file system to be mounted at multiple points, but B<link>()  does "
"not work across different mount points, even if the same file system is "
"mounted on both.)"
msgstr ""
"I<oldpath> と I<newpath> が同じマウントされたファイルシステムに存在しない。 "
"(Linux は 1 つのファイルシステムを複数のマウント位置に マウントすることを許可"
"している。 しかし B<link>()  は、たとえ同じファイルシステムであっても、 別々"
"のマウント位置を跨いでは動作しない。)"

#.  SVr4 documents additional ENOLINK and
#.  EMULTIHOP error conditions; POSIX.1 does not document ELOOP.
#.  X/OPEN does not document EFAULT, ENOMEM or EIO.
#. type: Plain text
#: build/C/man2/link.2:133
msgid "SVr4, 4.3BSD, POSIX.1-2001 (but see NOTES)."
msgstr "SVr4, 4.3BSD, POSIX.1-2001 (但し「注意」を参照)。"

#. type: Plain text
#: build/C/man2/link.2:140
msgid ""
"Hard links, as created by B<link>(), cannot span file systems.  Use "
"B<symlink>(2)  if this is required."
msgstr ""
"B<link>()  でファイルシステムを超えてハードリンクを作成することはできない。 "
"このような場合は B<symlink>(2)  を使用すること。"

#.  more precisely: since kernel 1.3.56
#.  For example, the default Solaris compilation environment
#.  behaves like Linux, and contributors to a March 2005
#.  thread in the Austin mailing list reported that some
#.  other (System V) implementations did/do the same -- MTK, Apr 05
#. type: Plain text
#: build/C/man2/link.2:171
msgid ""
"POSIX.1-2001 says that B<link>()  should dereference I<oldpath> if it is a "
"symbolic link.  However, since kernel 2.0, Linux does not do so: if "
"I<oldpath> is a symbolic link, then I<newpath> is created as a (hard) link "
"to the same symbolic link file (i.e., I<newpath> becomes a symbolic link to "
"the same file that I<oldpath> refers to).  Some other implementations behave "
"in the same manner as Linux.  POSIX.1-2008 changes the specification of "
"B<link>(), making it implementation-dependent whether or not I<oldpath> is "
"dereferenced if it is a symbolic link.  For precise control over the "
"treatment of symbolic links when creating a link, see B<linkat>(2)."
msgstr ""
"POSIX.1-2001 では、 I<oldpath> がシンボリックリンクである場合、 B<link>()  "
"は I<oldpath> の参照を解決すべきであると記述されている。 しかし、カーネル "
"2.0 以降の Linux ではそのようになっていない。 I<oldpath> がシンボリックリンク"
"である場合、 I<newpath> は同じシンボリックリンクファイルへの (ハード) リンク"
"として作成される (つまり I<newpath> は I<oldpath> が参照していた同じファイル"
"へのシンボリックリンクになる)。 他のいくつかの実装でも Linux と同じように動作"
"する。 POSIX.1-2008 では B<link>()  の仕様が変更され、 I<oldpath> がシンボ"
"リックリンクの場合にシンボリックリンクの参照を 解決するかどうかは実装依存と"
"なった。 リンク作成時のシンボリックリンクの扱いについての詳細な制御に 関して"
"は B<linkat>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/link.2:177
msgid ""
"On NFS file systems, the return code may be wrong in case the NFS server "
"performs the link creation and dies before it can say so.  Use B<stat>(2)  "
"to find out if the link got created."
msgstr ""
"NFS ファイルシステムでは、NFS サーバーがリンクを作成した後に、 それを伝える前"
"に死んだ場合には返り値が不正な場合がある。 リンクが作成できたかどうか見つける"
"ためには B<stat>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/link.2:187
msgid ""
"B<ln>(1), B<linkat>(2), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), "
"B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<ln>(1), B<linkat>(2), B<open>(2), B<rename>(2), B<stat>(2), B<symlink>(2), "
"B<unlink>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/llseek.2:26
#, no-wrap
msgid "LLSEEK"
msgstr "LLSEEK"

#. type: TH
#: build/C/man2/llseek.2:26
#, no-wrap
msgid "2007-06-01"
msgstr "2007-06-01"

#. type: Plain text
#: build/C/man2/llseek.2:29
msgid "_llseek - reposition read/write file offset"
msgstr "_llseek - ファイルの読み書きオフセットの位置を変える"

#. type: Plain text
#: build/C/man2/llseek.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/llseek.2:37
#, no-wrap
msgid ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"
msgstr ""
"B<int _llseek(unsigned int >I<fd>B<, unsigned long >I<offset_high>B<,>\n"
"B<            unsigned long >I<offset_low>B<, loff_t *>I<result>B<,>\n"
"B<            unsigned int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man2/llseek.2:57
msgid ""
"The B<_llseek>()  function repositions the offset of the open file "
"associated with the file descriptor I<fd> to I<(offset_highE<lt>E<lt>32) | "
"offset_low> bytes relative to the beginning of the file, the current "
"position in the file, or the end of the file, depending on whether I<whence> "
"is B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively.  It returns the "
"resulting file position in the argument I<result>."
msgstr ""
"B<_llseek>()  関数は、ファイルディスクリプタ (descriptor)  I<fd> に関連づけら"
"れたオープンされたファイルのオフセットの位置を、相対的に I<"
"(offset_highE<lt>E<lt>32) | offset_low> バイトだけ変更する。 基準となる位置を"
"表す I<whence> には B<SEEK_SET>, B<SEEK_CUR>, B<SEEK_END> のいずれかを指定"
"し、それぞれ ファイルの先頭、ファイルの現在位置、 ファイルの最後を表す。 結果"
"のファイル位置を I<result> 引き数に返す。"

#. type: Plain text
#: build/C/man2/llseek.2:64
msgid ""
"Upon successful completion, B<_llseek>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功した場合は、 B<_llseek>()  は 0 を返す。 そうでなれば -1 という値が返り、"
"エラーを示す I<errno> が設定される。"

#. type: Plain text
#: build/C/man2/llseek.2:69 build/C/man2/lseek.2:164
msgid "I<fd> is not an open file descriptor."
msgstr "I<fd> がオープンされたファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/llseek.2:72
msgid "Problem with copying results to user space."
msgstr "結果をユーザ空間にコピーするときに問題があった。"

#. type: Plain text
#: build/C/man2/llseek.2:76
msgid "I<whence> is invalid."
msgstr "I<whence> が不正である。"

#. type: Plain text
#: build/C/man2/llseek.2:79
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"この関数は Linux 特有であり、移植性の必要なプログラムでは使用してはいけない。"

#. type: Plain text
#: build/C/man2/llseek.2:82
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/llseek.2:85
msgid "B<lseek>(2), B<lseek64>(3)"
msgstr "B<lseek>(2), B<lseek64>(3)"

#. type: TH
#: build/C/man2/lseek.2:45
#, no-wrap
msgid "LSEEK"
msgstr "LSEEK"

#. type: TH
#: build/C/man2/lseek.2:45
#, no-wrap
msgid "2011-09-25"
msgstr "2011-09-25"

#. type: Plain text
#: build/C/man2/lseek.2:48
msgid "lseek - reposition read/write file offset"
msgstr "lseek - ファイルの読み書きオフセットの位置を変える"

#. type: Plain text
#: build/C/man2/lseek.2:50 build/C/man3/lseek64.3:30
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/lseek.2:54
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"
msgstr "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: build/C/man2/lseek.2:65
msgid ""
"The B<lseek>()  function repositions the offset of the open file associated "
"with the file descriptor I<fd> to the argument I<offset> according to the "
"directive I<whence> as follows:"
msgstr ""
"B<lseek>()  関数は、ファイルディスクリプタ (descriptor)  I<fd> に対応するオー"
"プンされたファイルのオフセットを、 I<whence> に基づき I<offset> 引き数の位置"
"へ以下のように変更する:"

#. type: Plain text
#: build/C/man2/lseek.2:70
msgid "The offset is set to I<offset> bytes."
msgstr "オフセットは I<offset> バイトに設定される。"

#. type: Plain text
#: build/C/man2/lseek.2:75
msgid "The offset is set to its current location plus I<offset> bytes."
msgstr "オフセットは現在位置に I<offset> バイトを足した位置になる。"

#. type: Plain text
#: build/C/man2/lseek.2:80
msgid "The offset is set to the size of the file plus I<offset> bytes."
msgstr "オフセットはファイルのサイズに I<offset> バイトを足した位置になる。"

#. type: Plain text
#: build/C/man2/lseek.2:88
msgid ""
"The B<lseek>()  function allows the file offset to be set beyond the end of "
"the file (but this does not change the size of the file).  If data is later "
"written at this point, subsequent reads of the data in the gap (a \"hole\") "
"return null bytes (\\(aq\\e0\\(aq) until data is actually written into the "
"gap."
msgstr ""
"B<lseek>()  関数は、オフセットをファイルの末尾を越えた位置に設定できる (但"
"し、これによりファイルのサイズが変わらない)。 もしデータがこのオフセット位置"
"以降に書き込まれた場合、 間の空隙の部分 (\"穴 (hole)\") の読み出しがあると、 "
"実際にそこにデータを書き込まれるまでは NULL バイト (\\(aq\\e0\\(aq) の列が返"
"される。"

#. type: SS
#: build/C/man2/lseek.2:88
#, no-wrap
msgid "Seeking file data and holes"
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:91
msgid ""
"Since version 3.1, Linux supports the following additional values for "
"I<whence>:"
msgstr ""
"Linux バージョン 3.1 以降では、\n"
"I<whence> に以下の値も指定することができる。"

#. type: TP
#: build/C/man2/lseek.2:91
#, no-wrap
msgid "B<SEEK_DATA>"
msgstr "B<SEEK_DATA>"

#. type: Plain text
#: build/C/man2/lseek.2:102
msgid ""
"Adjust the file offset to the next location in the file greater than or "
"equal to I<offset> containing data.  If I<offset> points to data, then the "
"file offset is set to I<offset>."
msgstr ""

#. type: TP
#: build/C/man2/lseek.2:102
#, no-wrap
msgid "B<SEEK_HOLE>"
msgstr "B<SEEK_HOLE>"

#. type: Plain text
#: build/C/man2/lseek.2:116
msgid ""
"Adjust the file offset to the next hole in the file greater than or equal to "
"I<offset>.  If I<offset> points into the middle of a hole, then the file "
"offset is set to I<offset>.  If there is no hole past I<offset>, then the "
"file offset is adjusted to the end of the file (i.e., there is an implicit "
"hole at the end of any file)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:122
msgid ""
"In both of the above cases, B<lseek>()  fails if I<offset> points past the "
"end of the file."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:128
msgid ""
"These operations allow applications to map holes in a sparsely allocated "
"file.  This can be useful for applications such as file backup tools, which "
"can save space when creating backups and preserve holes, if they have a "
"mechanism for discovering holes."
msgstr ""

#.  https://lkml.org/lkml/2011/4/22/79
#.  http://lwn.net/Articles/440255/
#.  http://blogs.oracle.com/bonwick/entry/seek_hole_and_seek_data
#. type: Plain text
#: build/C/man2/lseek.2:151
msgid ""
"For the purposes of these operations, a hole is a sequence of zeros that "
"(normally) has not been allocated in the underlying file storage.  However, "
"a file system is not obliged to report holes, so these operations are not a "
"guaranteed mechanism for mapping the storage space actually allocated to a "
"file.  (Furthermore, a sequence of zeros that actually has been written to "
"the underlying storage may not be reported as a hole.)  In the simplest "
"implementation, a file system can support the operations by making "
"B<SEEK_HOLE> always return the offset of the end of the file, and making "
"B<SEEK_DATA> always return I<offset> (i.e., even if the location referred to "
"by I<offset> is a hole, it can be considered to consist of data that is a "
"sequence of zeros)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:159
msgid ""
"Upon successful completion, B<lseek>()  returns the resulting offset "
"location as measured in bytes from the beginning of the file.  On error, the "
"value I<(off_t)\\ -1> is returned and I<errno> is set to indicate the error."
msgstr ""
"成功した場合、 B<lseek>()  は結果のファイル位置をファイルの先頭からのバイト数"
"で返す。 エラーの場合、値 I<(off_t)\\ -1> が返され、 I<errno> にエラーが指示"
"される。"

#.  Some systems may allow negative offsets for character devices
#.  and/or for remote file systems.
#. type: Plain text
#: build/C/man2/lseek.2:172
msgid ""
"I<whence> is not valid.  Or: the resulting file offset would be negative, or "
"beyond the end of a seekable device."
msgstr ""
"I<whence> が有効な値ではない。または、seek の結果、ファイルオフセットが負に\n"
"なってしまうか、 seek 可能なデバイスの末尾を越えてしまう。"

#. type: TP
#: build/C/man2/lseek.2:172 build/C/man2/open.2:565
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#.  HP-UX 11 says EINVAL for this case (but POSIX.1 says EOVERFLOW)
#. type: Plain text
#: build/C/man2/lseek.2:177
msgid "The resulting file offset cannot be represented in an I<off_t>."
msgstr "結果のファイルオフセットを I<off_t> 型で表現することができない。"

#. type: TP
#: build/C/man2/lseek.2:177
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: build/C/man2/lseek.2:181
msgid "I<fd> is associated with a pipe, socket, or FIFO."
msgstr "I<fd> がパイプ、ソケット、FIFO を参照している。"

#. type: TP
#: build/C/man2/lseek.2:181 build/C/man2/open.2:559
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man2/lseek.2:189
msgid ""
"I<whence> is B<SEEK_DATA> or B<SEEK_HOLE>, and the current file offset is "
"beyond the end of the file."
msgstr ""
"I<whence> が B<SEEK_DATA> か B<SEEK_HOLE> で、\n"
"現在のファイルオフセットがファイルの末尾を超えた位置である。"

#.  SVr4 documents additional error
#.  conditions EDEADLK, ENOLCK, ENOLNK, ENOSR, ENXIO, or ERANGE.
#. type: Plain text
#: build/C/man2/lseek.2:191 build/C/man2/read.2:157 build/C/man2/rmdir.2:129
#: build/C/man2/symlink.2:150 build/C/man2/unlink.2:145
#: build/C/man2/write.2:183
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#.  FIXME . Review http://austingroupbugs.net/view.php?id=415 in the future
#. type: Plain text
#: build/C/man2/lseek.2:199
msgid ""
"B<SEEK_DATA> and B<SEEK_HOLE> are nonstandard extensions also present in "
"Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion in the "
"next POSIX revision (Issue 8)."
msgstr ""

#. type: Plain text
#: build/C/man2/lseek.2:203
msgid ""
"Some devices are incapable of seeking and POSIX does not specify which "
"devices must support B<lseek>()."
msgstr ""
"いくつかのデバイスでは seek ができない。 POSIX はどのデバイスが B<lseek>()  "
"に対応すべきかは規定していない。"

#.  Other systems return the number of written characters,
#.  using SEEK_SET to set the counter. (Of written characters.)
#. type: Plain text
#: build/C/man2/lseek.2:210
msgid "On Linux, using B<lseek>()  on a tty device returns B<ESPIPE>."
msgstr ""
"Linux では、 tty デバイスに B<lseek>()  を使用すると B<ESPIPE> を返す。"

#. type: Plain text
#: build/C/man2/lseek.2:213
msgid ""
"When converting old code, substitute values for I<whence> with the following "
"macros:"
msgstr "古いコードを変換する時は I<whence> の値を以下のマクロに置き換えること:"

#. type: tbl table
#: build/C/man2/lseek.2:216
#, no-wrap
msgid "old\tnew\n"
msgstr "old \tnew\n"

#. type: tbl table
#: build/C/man2/lseek.2:217
#, no-wrap
msgid "0\tSEEK_SET\n"
msgstr "0\tSEEK_SET\n"

#. type: tbl table
#: build/C/man2/lseek.2:218
#, no-wrap
msgid "1\tSEEK_CUR\n"
msgstr "1\tSEEK_CUR\n"

#. type: tbl table
#: build/C/man2/lseek.2:219
#, no-wrap
msgid "2\tSEEK_END\n"
msgstr "2\tSEEK_END\n"

#. type: tbl table
#: build/C/man2/lseek.2:220
#, no-wrap
msgid "L_SET\tSEEK_SET\n"
msgstr "L_SET\tSEEK_SET\n"

#. type: tbl table
#: build/C/man2/lseek.2:221
#, no-wrap
msgid "L_INCR\tSEEK_CUR\n"
msgstr "L_INCR\tSEEK_CUR\n"

#. type: tbl table
#: build/C/man2/lseek.2:222
#, no-wrap
msgid "L_XTND\tSEEK_END\n"
msgstr "L_XTND\tSEEK_END\n"

#. type: Plain text
#: build/C/man2/lseek.2:234
msgid ""
"Note that file descriptors created by B<dup>(2)  or B<fork>(2)  share the "
"current file position pointer, so seeking on such files may be subject to "
"race conditions."
msgstr ""
"B<dup>(2)  や B<fork>(2)  で作成されたファイルディスクリプタは、現在のファイ"
"ル位置ポインタ (current file position pointer) を共有しているので、 このよう"
"なファイルで移動を行うと競合状態を引き起こす可能性がある。"

#. type: Plain text
#: build/C/man2/lseek.2:241
msgid ""
"B<dup>(2), B<fork>(2), B<open>(2), B<fseek>(3), B<lseek64>(3), "
"B<posix_fallocate>(3)"
msgstr ""
"B<dup>(2), B<fork>(2), B<open>(2), B<fseek>(3), B<lseek64>(3), "
"B<posix_fallocate>(3)"

#. type: TH
#: build/C/man3/lseek64.3:23
#, no-wrap
msgid "LSEEK64"
msgstr "LSEEK64"

#. type: TH
#: build/C/man3/lseek64.3:23
#, no-wrap
msgid "2004-12-11"
msgstr "2004-12-11"

#. type: Plain text
#: build/C/man3/lseek64.3:26
msgid "lseek64 - reposition 64-bit read/write file offset"
msgstr "lseek64 - ファイルの 64 ビットの読み書きオフセットの位置を変える"

#. type: Plain text
#: build/C/man3/lseek64.3:28
msgid "B<#define _LARGEFILE64_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _LARGEFILE64_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/lseek64.3:34
msgid ""
"B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>"
msgstr ""
"B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>"

#. type: Plain text
#: build/C/man3/lseek64.3:51
msgid ""
"The B<lseek>(2)  family of functions reposition the offset of the open file "
"associated with the file descriptor I<fd> to I<offset> bytes relative to the "
"start, current position, or end of the file, when I<whence> has the value "
"B<SEEK_SET>, B<SEEK_CUR>, or B<SEEK_END>, respectively."
msgstr ""
"B<lseek>(2)  関数ファミリーは、ファイルディスクリプタ I<fd> に関連するオープ"
"ンされたファイルのオフセットを、 ファイルの開始位置・現在位置・終端から "
"I<offset> の位置へ変更する。 これは I<whence> がそれぞれ B<SEEK_SET>, "
"B<SEEK_CUR>, B<SEEK_END> の場合に対応する。"

#. type: Plain text
#: build/C/man3/lseek64.3:54
msgid "For more details, return value, and errors, see B<lseek>(2)."
msgstr "更に詳しい説明・返り値・エラーは、 B<lseek>(2)  を参照すること。"

#. type: Plain text
#: build/C/man3/lseek64.3:61
msgid ""
"Four interfaces are available: B<lseek>(2), B<lseek64>(), B<llseek>(2), and "
"the raw system call B<_llseek>(2)."
msgstr ""
"4 つのインタフェースが使用可能である: B<lseek>(2), B<lseek64>(), B<llseek>"
"(2)  と元となるシステムコール B<_llseek>(2)  である。"

#. type: SS
#: build/C/man3/lseek64.3:61
#, no-wrap
msgid "lseek"
msgstr "lseek"

#. type: Plain text
#: build/C/man3/lseek64.3:63 build/C/man3/lseek64.3:85
#: build/C/man3/lseek64.3:114
msgid "Prototype:"
msgstr "プロトタイプ:"

#. type: Plain text
#: build/C/man3/lseek64.3:67
#, no-wrap
msgid "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<off_t lseek(int >I<fd>B<, off_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:75
msgid ""
"B<lseek>(2)  uses the type I<off_t>.  This is a 32-bit signed type on 32-bit "
"architectures, unless one compiles with"
msgstr ""
"B<lseek>(2)  は型 I<off_t> を使う。 これは 32 ビットアーキテクチャ上では 32 "
"ビット符号付き型である。 ただし、"

#. type: Plain text
#: build/C/man3/lseek64.3:83
msgid "in which case it is a 64-bit signed type."
msgstr "を定義してコンパイルした場合は 64 ビット符号付き型である。"

#. type: SS
#: build/C/man3/lseek64.3:83
#, no-wrap
msgid "lseek64"
msgstr "lseek64"

#. type: Plain text
#: build/C/man3/lseek64.3:89
#, no-wrap
msgid "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<off64_t lseek64(int >I<fd>B<, off64_t >I<offset>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:100
msgid ""
"The library routine B<lseek64>()  uses a 64-bit type even when I<off_t> is a "
"32-bit type.  Its prototype (and the type I<off64_t>)  is available only "
"when one compiles with"
msgstr ""
"ライブラリルーチン B<lseek64>()  は I<off_t> が 32 ビット型であっても 64 ビッ"
"ト型を使う。 このプロトタイプ (と型 I<off64_t>)  は、以下の定義をしてコンパイ"
"ルした場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man3/lseek64.3:104
#, no-wrap
msgid "#define _LARGEFILE64_SOURCE\n"
msgstr "#define _LARGEFILE64_SOURCE\n"

#.  in glibc 2.0.94, not in 2.0.6
#. type: Plain text
#: build/C/man3/lseek64.3:112
msgid ""
"The function B<lseek64>()  is available since glibc 2.1, and is defined to "
"be an alias for B<llseek>()."
msgstr ""
"関数 B<lseek64>()  は glibc 2.1 以降で使用可能であり、 B<llseek>()  のエイリ"
"アスとして定義されている。"

#. type: SS
#: build/C/man3/lseek64.3:112
#, no-wrap
msgid "llseek"
msgstr "llseek"

#. type: Plain text
#: build/C/man3/lseek64.3:118
#, no-wrap
msgid "B<loff_t llseek(int >I<fd>B<, loff_t >I<offset>B<, int >I<whence>B<);>\n"
msgstr "B<loff_t llseek(int >I<fd>B<, loff_t >I<offset>B<, int >I<whence>B<);>\n"

#.  in libc 5.0.9, not in 4.7.6
#. type: Plain text
#: build/C/man3/lseek64.3:137
msgid ""
"The type I<loff_t> is a 64-bit signed type.  The library routine B<llseek>"
"()  is available in libc5 and glibc and works without special defines.  Its "
"prototype was given in I<E<lt>unistd.hE<gt>> with libc5, but glibc does not "
"provide a prototype.  This is bad, since a prototype is needed.  Users "
"should add the above prototype, or something equivalent, to their own "
"source.  When users complained about data loss caused by a miscompilation of "
"B<e2fsck>(8), glibc 2.1.3 added the link-time warning"
msgstr ""
"型 I<loff_t> は 64 ビット符号付き型である。 ライブラリルーチン B<llseek>()  "
"は libc5 と glibc で使用可能であり、特別な定義なしに動作する。 このプロトタイ"
"プは、libc5 では I<E<lt>unistd.hE<gt>> で与えられるが、glibc はプロトタイプを"
"提供しない。 これはプロトタイプが必要になるので良くない。 ユーザは上記のプロ"
"トタイプまたはそれと同等のものを、 自身のソースに追加しなければならない。 こ"
"のデータがないことによって B<e2fsck>(8)  のコンパイルが失敗するという苦情が"
"ユーザから出たので、 glibc 2.1.3 では以下のようなリンク時の警告が追加された。"

#. type: Plain text
#: build/C/man3/lseek64.3:140
msgid "the \\`llseek\\' function may be dangerous; use \\`lseek64\\' instead."
msgstr "the \\`llseek\\' function may be dangerous; use \\`lseek64\\' instead."

#. type: Plain text
#: build/C/man3/lseek64.3:144
msgid ""
"This makes this function unusable if one desires a warning-free compilation."
msgstr ""
"これにより、警告なしでコンパイルしたい場合には、この関数を使用不可にできる。"

#. type: SS
#: build/C/man3/lseek64.3:144
#, no-wrap
msgid "_llseek"
msgstr "_llseek"

#. type: Plain text
#: build/C/man3/lseek64.3:147
msgid ""
"All the above functions are implemented in terms of this system call.  The "
"prototype is:"
msgstr ""
"上記の全ての関数は、このシステムコールに基づいて実装される。 プロトタイプは以"
"下の通り:"

#. type: Plain text
#: build/C/man3/lseek64.3:152
#, no-wrap
msgid ""
"B<int _llseek(int >I<fd>B<, off_t >I<offset_hi>B<, off_t >I<offset_lo>B<,>\n"
"B<            loff_t *>I<result>B<, int >I<whence>B<);>\n"
msgstr ""
"B<int _llseek(int >I<fd>B<, off_t >I<offset_hi>B<, off_t >I<offset_lo>B<,>\n"
"B<            loff_t *>I<result>B<, int >I<whence>B<);>\n"

#. type: Plain text
#: build/C/man3/lseek64.3:157
msgid "For more details, see B<llseek>(2)."
msgstr "更に詳しい情報は、 B<llseek>(2)  を参照すること。"

#. type: Plain text
#: build/C/man3/lseek64.3:160
msgid "B<llseek>(2), B<lseek>(2)"
msgstr "B<llseek>(2), B<lseek>(2)"

#. type: TH
#: build/C/man2/open.2:52
#, no-wrap
msgid "OPEN"
msgstr "OPEN"

#. type: TH
#: build/C/man2/open.2:52
#, fuzzy, no-wrap
#| msgid "2012-03-30"
msgid "2012-05-01"
msgstr "2012-03-30"

#. type: Plain text
#: build/C/man2/open.2:55
msgid "open, creat - open and possibly create a file or device"
msgstr "open, creat - ファイルやデバイスのオープン、作成を行う"

#. type: Plain text
#: build/C/man2/open.2:60
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/open.2:63
#, no-wrap
msgid ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
msgstr ""
"B<int open(const char *>I<pathname>B<, int >I<flags>B<);>\n"
"B<int open(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/open.2:65
#, no-wrap
msgid "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int creat(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/open.2:76
msgid ""
"Given a I<pathname> for a file, B<open>()  returns a file descriptor, a "
"small, nonnegative integer for use in subsequent system calls (B<read>(2), "
"B<write>(2), B<lseek>(2), B<fcntl>(2), etc.).  The file descriptor returned "
"by a successful call will be the lowest-numbered file descriptor not "
"currently open for the process."
msgstr ""
"ファイルの I<pathname> を与えると、 B<open>()  はファイルディスクリプタを返"
"す。 ファイルディスクリプタは、この後に続くシステムコール (B<read>(2), "
"B<write>(2), B<lseek>(2), B<fcntl>(2) など)  で使用される小さな非負の整数であ"
"る。 このシステムコールが成功した場合に返されるファイルディスクリプタは その"
"プロセスがその時点でオープンしていないファイルディスクリプタの うち最小の数字"
"のものとなる。"

#. type: Plain text
#: build/C/man2/open.2:88
msgid ""
"By default, the new file descriptor is set to remain open across an B<execve>"
"(2)  (i.e., the B<FD_CLOEXEC> file descriptor flag described in B<fcntl>(2)  "
"is initially disabled; the B<O_CLOEXEC> flag, described below, can be used "
"to change this default).  The file offset is set to the beginning of the "
"file (see B<lseek>(2))."
msgstr ""
"デフォルトでは、新しいファイルディスクリプタは B<execve>(2) を実行した後も\n"
"オープンされたままとなる (つまり、 B<fcntl>(2) に説明がある B<FD_CLOEXEC> \n"
"ファイルディスクリプタフラグは最初は無効である; 後述の B<O_CLOEXEC> フラグ\n"
"を使うとこのデフォルトを変更することができる)。 ファイルオフセット \n"
"(file offset) はファイルの先頭に設定される (B<lseek>(2) 参照)。"

#. type: Plain text
#: build/C/man2/open.2:107
msgid ""
"A call to B<open>()  creates a new I<open file description>, an entry in the "
"system-wide table of open files.  This entry records the file offset and the "
"file status flags (modifiable via the B<fcntl>(2)  B<F_SETFL> operation).  A "
"file descriptor is a reference to one of these entries; this reference is "
"unaffected if I<pathname> is subsequently removed or modified to refer to a "
"different file.  The new open file description is initially not shared with "
"any other process, but sharing may arise via B<fork>(2)."
msgstr ""
"B<open>()  を呼び出すと、「オープンファイル記述」 I<(open file description)> "
"が作成される。ファイル記述とは、システム全体の オープン中のファイルのテーブル"
"のエントリである。 このエントリは、ファイルオフセットとファイル状態フラグ "
"(B<fcntl>(2)  B<F_SETFL> 操作により変更可能) が保持する。 ファイルディスクリ"
"プタはこれらのエントリの一つへの参照である。 この後で I<pathname> が削除され"
"たり、他のファイルを参照するように変更されたりしても、 この参照は影響を受けな"
"い。 新しいオープンファイル記述は最初は他のどのプロセスとも 共有されていない"
"が、 B<fork>(2)  で共有が起こる場合がある。"

#. type: Plain text
#: build/C/man2/open.2:115
msgid ""
"The argument I<flags> must include one of the following I<access modes>: "
"B<O_RDONLY>, B<O_WRONLY>, or B<O_RDWR>.  These request opening the file read-"
"only, write-only, or read/write, respectively."
msgstr ""
"引き数 I<flags> には、アクセスモード B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR> のど"
"れかひとつが入っていなければならない。 これらはそれぞれ読み込み専用、書き込み"
"専用、読み書き用に ファイルをオープンすることを要求するものである。"

#.  FIXME . Actually is it true that the "file status flags" are all of the
#.  remaining flags listed below?  SUSv4 divides the flags into:
#.  * Access mode
#.  * File creation
#.  * File status
#.  * Other (O_CLOEXEC, O_DIRECTORY, O_NOFOLLOW)
#.  though it's not clear what the difference between "other" and
#.  "File creation" flags is.  (I've raised an Aardvark to see if this
#.  can be clarified in SUSv4; 10 Oct 2008.)
#. type: Plain text
#: build/C/man2/open.2:142
msgid ""
"In addition, zero or more file creation flags and file status flags can be "
"bitwise-I<or>'d in I<flags>.  The I<file creation flags> are B<O_CREAT>, "
"B<O_EXCL>, B<O_NOCTTY>, and B<O_TRUNC>.  The I<file status flags> are all of "
"the remaining flags listed below.  The distinction between these two groups "
"of flags is that the file status flags can be retrieved and (in some cases)  "
"modified using B<fcntl>(2).  The full list of file creation flags and file "
"status flags is as follows:"
msgstr ""
"さらに、 I<flags> には、ファイル作成フラグ (file creation flag) とファイル状"
"態フラグ (file status flag) を 0 個以上「ビット単位の OR (bitwise-or)」で 指"
"定することができる。 I<ファイル作成フラグ> は B<O_CREAT>, B<O_EXCL>, "
"B<O_NOCTTY>, B<O_TRUNC> である。 I<ファイル状態フラグ> は以下のリストのうち上"
"記以外の残りのものである。 二種類のフラグの違いは、ファイル状態フラグの方は "
"B<fcntl>(2)  を使ってその内容を取得したり (場合によっては) 変更したりできる点"
"にある。 ファイル作成フラグとファイル状態フラグの全リストを以下に示す:"

#. type: TP
#: build/C/man2/open.2:142
#, no-wrap
msgid "B<O_APPEND>"
msgstr "B<O_APPEND>"

#.  For more background, see
#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=453946
#.  http://nfs.sourceforge.net/
#. type: Plain text
#: build/C/man2/open.2:159
msgid ""
"The file is opened in append mode.  Before each B<write>(2), the file offset "
"is positioned at the end of the file, as if with B<lseek>(2).  B<O_APPEND> "
"may lead to corrupted files on NFS file systems if more than one process "
"appends data to a file at once.  This is because NFS does not support "
"appending to a file, so the client kernel has to simulate it, which can't be "
"done without a race condition."
msgstr ""
"ファイルを追加 (append) モードでオープンする。 毎回の B<write>(2)  の前に "
"B<lseek>(2)  を行ったかのように、ファイルポインタをファイルの最後に移動す"
"る。 NFS ファイルシステムで、 B<O_APPEND> を使用すると、複数のプロセスがひと"
"つのファイルに同時にデータを追加した場合、 ファイルが壊れてしまうことがあ"
"る。 これは NFS が追加モードをサポートしていないため、 クライアントのカーネ"
"ル (kernel) がそれをシミュレートしなければならないのだが、 競合状態を避けるこ"
"とはできないからである。"

#. type: TP
#: build/C/man2/open.2:159
#, no-wrap
msgid "B<O_ASYNC>"
msgstr "B<O_ASYNC>"

#. type: Plain text
#: build/C/man2/open.2:172
msgid ""
"Enable signal-driven I/O: generate a signal (B<SIGIO> by default, but this "
"can be changed via B<fcntl>(2))  when input or output becomes possible on "
"this file descriptor.  This feature is only available for terminals, "
"pseudoterminals, sockets, and (since Linux 2.6) pipes and FIFOs.  See "
"B<fcntl>(2)  for further details."
msgstr ""
"シグナル駆動 I/O (signal-driven I/O) を有効にする: このファイルディスクリプタ"
"への 入力または出力が可能になった場合に、シグナルを生成する (デフォルトは "
"B<SIGIO> であるが、 B<fcntl>(2)  によって変更可能である)。 この機能が使用可能"
"なのは端末、疑似端末、ソケットのみであり、 (Linux 2.6 以降では) パイプと "
"FIFO に対しても使用できる。 さらに詳しい説明は B<fcntl>(2)  を参照すること。"

#. type: TP
#: build/C/man2/open.2:172
#, no-wrap
msgid "B<O_CLOEXEC> (Since Linux 2.6.23)"
msgstr "B<O_CLOEXEC> (Linux 2.6.23 以降)"

#.  This flag fixes only one form of the race condition;
#.  The race can also occur with, for example, descriptors
#.  returned by accept(), pipe(), etc.
#. type: Plain text
#: build/C/man2/open.2:197
msgid ""
"Enable the close-on-exec flag for the new file descriptor.  Specifying this "
"flag permits a program to avoid additional B<fcntl>(2)  B<F_SETFD> "
"operations to set the B<FD_CLOEXEC> flag.  Additionally, use of this flag is "
"essential in some multithreaded programs since using a separate B<fcntl>(2)  "
"B<F_SETFD> operation to set the B<FD_CLOEXEC> flag does not suffice to avoid "
"race conditions where one thread opens a file descriptor at the same time as "
"another thread does a B<fork>(2)  plus B<execve>(2)."
msgstr ""
"新しいファイルディスクリプタに対して close-on-exec フラグを有効にする。 この"
"フラグを指定することで、プログラムは B<FD_CLOEXEC> フラグをセットするための "
"B<fcntl>(2)  B<F_SETFD> 操作を別途呼び出す必要がなくなる。 また、ある種のマル"
"チスレッドのプログラムはこのフラグの使用は 不可欠である。なぜなら、個別に "
"B<FD_CLOEXEC> フラグを設定する B<fcntl>(2)  B<F_SETFD> 操作を呼び出したとして"
"も、あるスレッドがファイルディスクリプタを オープンするのと同時に別のスレッド"
"が B<fork>(2)  と B<execve>(2)  を実行するという競合条件を避けるのには十分で"
"はないからである。"

#. type: TP
#: build/C/man2/open.2:197
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  As at 2.6.25, bsdgroups is supported by ext2, ext3, ext4, and
#.  XFS (since 2.6.14).
#. type: Plain text
#: build/C/man2/open.2:213
msgid ""
"If the file does not exist it will be created.  The owner (user ID) of the "
"file is set to the effective user ID of the process.  The group ownership "
"(group ID) is set either to the effective group ID of the process or to the "
"group ID of the parent directory (depending on file system type and mount "
"options, and the mode of the parent directory, see the mount options "
"I<bsdgroups> and I<sysvgroups> described in B<mount>(8))."
msgstr ""
"ファイルが存在しなかった場合は作成 (create) する。 ファイルの所有者 (ユー"
"ザー ID) は、プロセスの実効ユーザー ID に設定される。 グループ所有権 (グルー"
"プ ID) は、プロセスの実効グループ ID または親ディレクトリのグループ ID に設定"
"される (これは、ファイルシステムタイプ、マウントオプション、 親ディレクトリの"
"モードに依存する。 B<mount>(8)  で説明されているマウントオプション "
"I<bsdgroups> と I<sysvgroups> を参照)。"

#. type: Plain text
#: build/C/man2/open.2:236
msgid ""
"I<mode> specifies the permissions to use in case a new file is created.  "
"This argument must be supplied when B<O_CREAT> is specified in I<flags>; if "
"B<O_CREAT> is not specified, then I<mode> is ignored.  The effective "
"permissions are modified by the process's I<umask> in the usual way: The "
"permissions of the created file are I<(mode\\ &\\ ~umask)>.  Note that this "
"mode only applies to future accesses of the newly created file; the B<open>"
"()  call that creates a read-only file may well return a read/write file "
"descriptor."
msgstr ""
"I<mode> は新しいファイルを作成する場合に使用するアクセス許可 (permission) を"
"指定する。 I<flags> に B<O_CREAT> が指定されている場合、 I<mode> を指定しなけ"
"ればならない。 B<O_CREAT> が指定されていない場合、 I<mode> は無視される。 有"
"効なアクセス許可は、普段と同じようにプロセスの I<umask> によって修正され、作"
"成されたファイルの許可は I<(mode\\ &\\ ~umask)> となる。 このモードは、新しく"
"作成されたファイルに対するそれ以降のアクセス にのみ適用される点に注意するこ"
"と。 読み取り専用のファイルを作成する B<open>()  コールであっても、 読み書き"
"可能なファイルディスクリプタを返すことがありうる。"

#. type: Plain text
#: build/C/man2/open.2:239
msgid "The following symbolic constants are provided for I<mode>:"
msgstr "I<mode> のために以下のシンボル定数が提供されている :"

#. type: TP
#: build/C/man2/open.2:239
#, no-wrap
msgid "B<S_IRWXU>"
msgstr "B<S_IRWXU>"

#. type: Plain text
#: build/C/man2/open.2:242
msgid "00700 user (file owner) has read, write and execute permission"
msgstr ""
"00700 ユーザー (ファイルの所有者) に読み込み、書き込み、 実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:242
#, no-wrap
msgid "B<S_IRUSR>"
msgstr "B<S_IRUSR>"

#. type: Plain text
#: build/C/man2/open.2:245
msgid "00400 user has read permission"
msgstr "00400 ユーザーに読み込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:245
#, no-wrap
msgid "B<S_IWUSR>"
msgstr "B<S_IWUSR>"

#. type: Plain text
#: build/C/man2/open.2:248
msgid "00200 user has write permission"
msgstr "00200 ユーザーに書き込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:248
#, no-wrap
msgid "B<S_IXUSR>"
msgstr "B<S_IXUSR>"

#. type: Plain text
#: build/C/man2/open.2:251
msgid "00100 user has execute permission"
msgstr "00100 ユーザーに実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:251
#, no-wrap
msgid "B<S_IRWXG>"
msgstr "B<S_IRWXG>"

#. type: Plain text
#: build/C/man2/open.2:254
msgid "00070 group has read, write and execute permission"
msgstr "00070 グループに読み込み、書き込み、実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:254
#, no-wrap
msgid "B<S_IRGRP>"
msgstr "B<S_IRGRP>"

#. type: Plain text
#: build/C/man2/open.2:257
msgid "00040 group has read permission"
msgstr "00040 グループに読み込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:257
#, no-wrap
msgid "B<S_IWGRP>"
msgstr "B<S_IWGRP>"

#. type: Plain text
#: build/C/man2/open.2:260
msgid "00020 group has write permission"
msgstr "00020 グループに書き込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:260
#, no-wrap
msgid "B<S_IXGRP>"
msgstr "B<S_IXGRP>"

#. type: Plain text
#: build/C/man2/open.2:263
msgid "00010 group has execute permission"
msgstr "00010 グループに実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:263
#, no-wrap
msgid "B<S_IRWXO>"
msgstr "B<S_IRWXO>"

#. type: Plain text
#: build/C/man2/open.2:266
msgid "00007 others have read, write and execute permission"
msgstr "00007 他人 (others) に読み込み、書き込み、実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:266
#, no-wrap
msgid "B<S_IROTH>"
msgstr "B<S_IROTH>"

#. type: Plain text
#: build/C/man2/open.2:269
msgid "00004 others have read permission"
msgstr "00004 他人に読み込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:269
#, no-wrap
msgid "B<S_IWOTH>"
msgstr "B<S_IWOTH>"

#. type: Plain text
#: build/C/man2/open.2:272
msgid "00002 others have write permission"
msgstr "00002 他人に書き込みの許可がある。"

#. type: TP
#: build/C/man2/open.2:272
#, no-wrap
msgid "B<S_IXOTH>"
msgstr "B<S_IXOTH>"

#. type: Plain text
#: build/C/man2/open.2:275
msgid "00001 others have execute permission"
msgstr "00001 他人に実行の許可がある。"

#. type: TP
#: build/C/man2/open.2:276
#, no-wrap
msgid "B<O_DIRECT> (Since Linux 2.4.10)"
msgstr "B<O_DIRECT> (Linux 2.4.10 以降)"

#. type: Plain text
#: build/C/man2/open.2:293
msgid ""
"Try to minimize cache effects of the I/O to and from this file.  In general "
"this will degrade performance, but it is useful in special situations, such "
"as when applications do their own caching.  File I/O is done directly to/"
"from user space buffers.  The B<O_DIRECT> flag on its own makes an effort to "
"transfer data synchronously, but does not give the guarantees of the "
"B<O_SYNC> flag that data and necessary metadata are transferred.  To "
"guarantee synchronous I/O, B<O_SYNC> must be used in addition to "
"B<O_DIRECT>.  See NOTES below for further discussion."
msgstr ""
"このファイルに対する I/O のキャッシュの効果を最小化しようとする。このフラグ"
"を\n"
"使うと、一般的に性能が低下する。 しかしアプリケーションが独自にキャッシング"
"を\n"
"行っているような 特別な場合には役に立つ。 ファイルの I/O はユーザー空間バッ"
"ファ\n"
"に対して直接行われる。 B<O_DIRECT> フラグ自身はデータを同期で転送しようとは"
"す\n"
"るが、 B<O_SYNC> フラグのようにデータと必要なメタデータの転送が保証されるわ"
"け\n"
"ではない。同期 I/O を保証するためには、 B<O_DIRECT> に加えて B<O_SYNC> を使"
"用\n"
"しなければならない。下記の「注意」の節の議論も参照。"

#. type: Plain text
#: build/C/man2/open.2:297
msgid ""
"A semantically similar (but deprecated) interface for block devices is "
"described in B<raw>(8)."
msgstr ""
"ブロックデバイスに対する似通った意味のインターフェースが B<raw>(8)  で説明さ"
"れている (但し、このインタフェースは非推奨である)。"

#. type: TP
#: build/C/man2/open.2:297
#, no-wrap
msgid "B<O_DIRECTORY>"
msgstr "B<O_DIRECTORY>"

#.  But see the following and its replies:
#.  http://marc.theaimsgroup.com/?t=112748702800001&r=1&w=2
#.  [PATCH] open: O_DIRECTORY and O_CREAT together should fail
#.  O_DIRECTORY | O_CREAT causes O_DIRECTORY to be ignored.
#. type: Plain text
#: build/C/man2/open.2:311
msgid ""
"If I<pathname> is not a directory, cause the open to fail.  This flag is "
"Linux-specific, and was added in kernel version 2.1.126, to avoid denial-of-"
"service problems if B<opendir>(3)  is called on a FIFO or tape device, but "
"should not be used outside of the implementation of B<opendir>(3)."
msgstr ""
"I<pathname> がディレクトリでなければオープンは失敗する。 このフラグは Linux "
"特有であり、 B<opendir>(3)  が FIFO やテープデバイスに対してコールされた場合"
"の サービス不能 (denial-of-service) 攻撃を避けるために カーネル 2.1.126 で追"
"加された。 しかしこれは B<opendir>(3)  の実装以外では使用するべきではない。"

#. type: TP
#: build/C/man2/open.2:311
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: build/C/man2/open.2:321
msgid ""
"Ensure that this call creates the file: if this flag is specified in "
"conjunction with B<O_CREAT>, and I<pathname> already exists, then B<open>()  "
"will fail."
msgstr ""
"この呼び出しでファイルが作成されることを保証する。このフラグが B<O_CREAT> "
"と\n"
"一緒に指定され、 I<pathname> のファイルが既に存在した場合、 B<open>() は失"
"敗\n"
"する。"

#.  POSIX.1-2001 explicitly requires this behavior.
#. type: Plain text
#: build/C/man2/open.2:329
msgid ""
"When these two flags are specified, symbolic links are not followed: if "
"I<pathname> is a symbolic link, then B<open>()  fails regardless of where "
"the symbolic link points to."
msgstr ""
"これら二つのフラグが指定された際、シンボリックリンクは辿られない。 "
"I<pathname> がシンボリックリンクの場合、 シンボリックリンクがどこを指している"
"かに関わらず B<open>()  は失敗する。"

#. type: Plain text
#: build/C/man2/open.2:345
msgid ""
"In general, the behavior of B<O_EXCL> is undefined if it is used without "
"B<O_CREAT>.  There is one exception: on Linux 2.6 and later, B<O_EXCL> can "
"be used without B<O_CREAT> if I<pathname> refers to a block device.  If the "
"block device is in use by the system (e.g., mounted), B<open>()  fails with "
"the error B<EBUSY>."
msgstr ""
"一般的には、 B<O_CREAT> を指定せずに B<O_EXCL> を使用した場合の\n"
"B<O_EXCL> の動作は規定されていない。\n"
"これには一つ例外があり、Linux 2.6 以降では、\n"
"I<pathname> がブロックデバイスを参照している場合、\n"
"B<O_CREAT> なしで B<O_EXCL> を使用することができる。\n"
"システムがそのブロックデバイスを使用中の場合 (例えば、\n"
"マウントされているなど)、 B<open>() はエラー B<EBUSY> で失敗する。"

#. type: Plain text
#: build/C/man2/open.2:367
msgid ""
"On NFS, B<O_EXCL> is only supported when using NFSv3 or later on kernel 2.6 "
"or later.  In NFS environments where B<O_EXCL> support is not provided, "
"programs that rely on it for performing locking tasks will contain a race "
"condition.  Portable programs that want to perform atomic file locking using "
"a lockfile, and need to avoid reliance on NFS support for B<O_EXCL>, can "
"create a unique file on the same file system (e.g., incorporating hostname "
"and PID), and use B<link>(2)  to make a link to the lockfile.  If B<link>"
"(2)  returns 0, the lock is successful.  Otherwise, use B<stat>(2)  on the "
"unique file to check if its link count has increased to 2, in which case the "
"lock is also successful."
msgstr ""
"NFS では、 B<O_EXCL> は、Linux 2.6 以降で NFSv3 以降を使っている場合でのみサ"
"ポートされる。 B<O_EXCL> サポートが提供されていない NFS 環境では、このフラグ"
"に頼って ロック処理を実行するプログラムは競合状態 (race condition) に出会う "
"可能性がある。 ロックファイルを使用して不可分 (atomic) なファイルロックを実現"
"し、 NFS が B<O_EXCL> をサポートしているかに依存しないようにしたい場合、 移植"
"性のある方法は、同じファイルシステム上に他と名前の重ならない ファイル (例えば"
"ホスト名と PID を組み合わせた名前) を作成し、 B<link>(2)  を使用してそのロッ"
"クファイルへのリンクを作成することである。 B<link>(2)  コールの返り値が 0 な"
"らばロックに成功している。 あるいは、そのファイルに B<stat>(2)  を使用してリ"
"ンク数 (link count) が 2 になっているかをチェックする。 そうなっていれば、同"
"じくロックに成功しているということである。"

#. type: TP
#: build/C/man2/open.2:367
#, no-wrap
msgid "B<O_LARGEFILE>"
msgstr "B<O_LARGEFILE>"

#. type: Plain text
#: build/C/man2/open.2:389
msgid ""
"(LFS)  Allow files whose sizes cannot be represented in an I<off_t> (but can "
"be represented in an I<off64_t>)  to be opened.  The B<_LARGEFILE64_SOURCE> "
"macro must be defined (before including I<any> header files)  in order to "
"obtain this definition.  Setting the B<_FILE_OFFSET_BITS> feature test macro "
"to 64 (rather than using B<O_LARGEFILE>)  is the preferred method of "
"accessing large files on 32-bit systems (see B<feature_test_macros>(7))."
msgstr ""
"(LFS) I<off_t> ではサイズを表せない (だだし I<off64_t> ではサイズを表せる)"
"ファ\n"
"イルをオープン可能にする。この定義を有効にするためには、(I<どの>ヘッダファ"
"イ\n"
"ルをインクルードするよりも前に) B<_LARGEFILE64_SOURCE> マクロを定義しなけれ"
"ば\n"
"ならない。\n"
"32 ビットシステムにおいて大きなファイルにアクセスしたい場合、\n"
"(B<O_LARGEFILE> を使うよりも) B<_FILE_OFFSET_BITS> 機能検査マクロを 64 に\n"
"セットする方が望ましい方法である (B<feature_test_macros>(7) を参照)。"

#. type: TP
#: build/C/man2/open.2:389
#, no-wrap
msgid "B<O_NOATIME> (Since Linux 2.6.8)"
msgstr "B<O_NOATIME> (Linux 2.6.8 以降)"

#.  The O_NOATIME flag also affects the treatment of st_atime
#.  by mmap() and readdir(2), MTK, Dec 04.
#. type: Plain text
#: build/C/man2/open.2:400
msgid ""
"Do not update the file last access time (st_atime in the inode)  when the "
"file is B<read>(2).  This flag is intended for use by indexing or backup "
"programs, where its use can significantly reduce the amount of disk "
"activity.  This flag may not be effective on all file systems.  One example "
"is NFS, where the server maintains the access time."
msgstr ""
"ファイルに対して B<read>(2)  が実行されたときに、最終アクセス時刻 (inode の "
"st_atime) を更新しない。 このフラグはインデックス作成やバックアッププログラム"
"で使うことを意図している。 これを使うとディスクに対する操作を大幅に減らすこと"
"ができる。 このフラグは全てのファイルシステムに対して有効であるわけではな"
"い。 その一例が NFS であり、サーバがアクセス時刻を管理している。"

#. type: TP
#: build/C/man2/open.2:400
#, no-wrap
msgid "B<O_NOCTTY>"
msgstr "B<O_NOCTTY>"

#. type: Plain text
#: build/C/man2/open.2:408
msgid ""
"If I<pathname> refers to a terminal device\\(emsee B<tty>(4)\\(em it will "
"not become the process's controlling terminal even if the process does not "
"have one."
msgstr ""
"I<pathname> が端末 (terminal) デバイス \\(em B<tty>(4) 参照 \\(em を指してい"
"る\n"
"場合に、たとえそのプロセスが制御端末を持っていなくても、オープンしたファイ"
"ル\n"
"は制御端末にはならない。"

#. type: TP
#: build/C/man2/open.2:408
#, no-wrap
msgid "B<O_NOFOLLOW>"
msgstr "B<O_NOFOLLOW>"

#.  The headers from glibc 2.0.100 and later include a
#.  definition of this flag; \fIkernels before 2.1.126 will ignore it if
#.  used\fP.
#. type: Plain text
#: build/C/man2/open.2:417
msgid ""
"If I<pathname> is a symbolic link, then the open fails.  This is a FreeBSD "
"extension, which was added to Linux in version 2.1.126.  Symbolic links in "
"earlier components of the pathname will still be followed."
msgstr ""
"I<pathname> がシンボリックリンクだった場合、オープンは失敗する。 これは "
"FreeBSD の拡張で、Linux には 2.1.126 より追加された。 pathname の前のコンポー"
"ネント (earlier component; 訳註: 最後のディレクトリセパレータより前の部分) "
"が シンボリックリンクである場合には、それが指す先が参照される。"

#. type: TP
#: build/C/man2/open.2:417
#, no-wrap
msgid "B<O_NONBLOCK> or B<O_NDELAY>"
msgstr "B<O_NONBLOCK> または B<O_NDELAY>"

#. type: Plain text
#: build/C/man2/open.2:430
msgid ""
"When possible, the file is opened in nonblocking mode.  Neither the B<open>"
"()  nor any subsequent operations on the file descriptor which is returned "
"will cause the calling process to wait.  For the handling of FIFOs (named "
"pipes), see also B<fifo>(7).  For a discussion of the effect of "
"B<O_NONBLOCK> in conjunction with mandatory file locks and with file leases, "
"see B<fcntl>(2)."
msgstr ""
"可能ならば、ファイルは非停止 (nonblocking) モードでオープンされる。\n"
"B<open>() も、返したファイルディスクリプタに対する以後のすべての操作も呼び"
"出\n"
"したプロセスを待たせることはない。 FIFO (名前付きパイプ) を扱う場合には\n"
"B<fifo>(7) も参照すること。 強制ファイルロック (mandatory file lock) やファ"
"イ\n"
"ルリース (file lease) と組み合わせた場合の、 B<O_NONBLOCK> の効果についての\n"
"議論は、 B<fcntl>(2) を参照すること。"

#. type: TP
#: build/C/man2/open.2:430
#, no-wrap
msgid "B<O_SYNC>"
msgstr "B<O_SYNC>"

#. type: Plain text
#: build/C/man2/open.2:438
msgid ""
"The file is opened for synchronous I/O.  Any B<write>(2)s on the resulting "
"file descriptor will block the calling process until the data has been "
"physically written to the underlying hardware.  I<But see NOTES below>."
msgstr ""
"ファイルは同期 (synchronous) I/O モードでオープンされる。 B<open>()  が返した"
"ファイルディスクリプタに対して B<write>(2)  を行うと、必ず呼び出したプロセス"
"をブロックし、 該当ハードウェアに物理的に書き込まれるまで返らない。 I<以下の"
"「注意」の章も参照。>"

#. type: TP
#: build/C/man2/open.2:438
#, no-wrap
msgid "B<O_TRUNC>"
msgstr "B<O_TRUNC>"

#. type: Plain text
#: build/C/man2/open.2:452
msgid ""
"If the file already exists and is a regular file and the open mode allows "
"writing (i.e., is B<O_RDWR> or B<O_WRONLY>)  it will be truncated to length "
"0.  If the file is a FIFO or terminal device file, the B<O_TRUNC> flag is "
"ignored.  Otherwise the effect of B<O_TRUNC> is unspecified."
msgstr ""
"ファイルが既に存在し、通常ファイルであり、 書き込み可モードでオープンされてい"
"る (つまり、 B<O_RDWR>またはB<O_WRONLY> の) 場合、長さ 0 に切り詰め "
"(truncate) られる。 ファイルが FIFO または端末デバイスファイルの場合、 "
"B<O_TRUNC> フラグは無視される。 それ以外の場合、 B<O_TRUNC> の効果は未定義で"
"ある。"

#. type: Plain text
#: build/C/man2/open.2:456
msgid ""
"Some of these optional flags can be altered using B<fcntl>(2)  after the "
"file has been opened."
msgstr ""
"これらの選択フラグのいくつかはファイルをオープンした後でも B<fcntl>(2)  を使"
"用して変更することができる。"

#. type: Plain text
#: build/C/man2/open.2:464
msgid ""
"B<creat>()  is equivalent to B<open>()  with I<flags> equal to B<O_CREAT|"
"O_WRONLY|O_TRUNC>."
msgstr ""
"B<creat>()  は I<flags> に B<O_CREAT|O_WRONLY|O_TRUNC> を指定して B<open>()  "
"を行うのと等価である。"

#. type: Plain text
#: build/C/man2/open.2:472
msgid ""
"B<open>()  and B<creat>()  return the new file descriptor, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr ""
"B<open>()  と B<creat>()  は新しいファイルディスクリプタを返す。 エラーが発生"
"した場合は -1 を返す (その場合は I<errno> が適切に設定される)。"

#. type: Plain text
#: build/C/man2/open.2:482
msgid ""
"The requested access to the file is not allowed, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>, or the "
"file did not exist yet and write access to the parent directory is not "
"allowed.  (See also B<path_resolution>(7).)"
msgstr ""
"ファイルに対する要求されたアクセスが許されていないか、 I<pathname> のディレク"
"トリ部分の何れかのディレクトリに検索許可がなかった。 またはファイルが存在せ"
"ず、親ディレクトリへの書き込み許可がなかった。 (B<path_resolution>(7)  も参照"
"すること。)"

#. type: Plain text
#: build/C/man2/open.2:488
msgid "I<pathname> already exists and B<O_CREAT> and B<O_EXCL> were used."
msgstr "I<pathname> は既に存在し、 B<O_CREAT> と B<O_EXCL> が使用された。"

#. type: Plain text
#: build/C/man2/open.2:492 build/C/man2/rmdir.2:67 build/C/man2/unlink.2:84
msgid "I<pathname> points outside your accessible address space."
msgstr "I<pathname> がアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/open.2:492 build/C/man2/write.2:139
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/open.2:496
msgid "See B<EOVERFLOW>."
msgstr "B<EOVERFLOW> 参照。"

#. type: TP
#: build/C/man2/open.2:496 build/C/man2/read.2:104 build/C/man3/scanf.3:559
#: build/C/man3/tmpfile.3:59 build/C/man2/write.2:144
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/open.2:503
msgid ""
"While blocked waiting to complete an open of a slow device (e.g., a FIFO; "
"see B<fifo>(7)), the call was interrupted by a signal handler; see B<signal>"
"(7)."
msgstr ""
"遅いデバイス (例えば FIFO、 B<fifo>(7)  参照) のオープンが完了するのを待って"
"停止している間に システムコールがシグナルハンドラにより割り込まれた。 "
"B<signal>(7)  参照。"

#. type: TP
#: build/C/man2/open.2:503 build/C/man2/read.2:140 build/C/man2/rename.2:140
#: build/C/man2/unlink.2:87
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: build/C/man2/open.2:512
msgid ""
"I<pathname> refers to a directory and the access requested involved writing "
"(that is, B<O_WRONLY> or B<O_RDWR> is set)."
msgstr ""
"I<pathname> はディレクトリを参照しており、書き込み要求が含まれていた (つまり "
"B<O_WRONLY> または B<O_RDWR> が設定されている)。"

#. type: Plain text
#: build/C/man2/open.2:519
msgid ""
"Too many symbolic links were encountered in resolving I<pathname>, or "
"B<O_NOFOLLOW> was specified but I<pathname> was a symbolic link."
msgstr ""
"I<pathname> を解決する際に遭遇したシンボリックリンクが多過ぎる。 または "
"B<O_NOFOLLOW> が指定されており、 I<pathname> がシンボリックリンクだった。"

#. type: TP
#: build/C/man2/open.2:519 build/C/man2/pipe.2:107 build/C/man3/tmpfile.3:62
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/open.2:522
msgid "The process already has the maximum number of files open."
msgstr "プロセスがオープンしているファイル数がすでに最大数に達している。"

#. type: Plain text
#: build/C/man2/open.2:526 build/C/man2/rmdir.2:80 build/C/man2/unlink.2:99
msgid "I<pathname> was too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/open.2:526 build/C/man2/pipe.2:110 build/C/man3/tmpfile.3:65
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/open.2:529 build/C/man2/pipe.2:113
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされているファイルの総数がシステムの制限に達している。"

#. type: TP
#: build/C/man2/open.2:529
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/open.2:536
msgid ""
"I<pathname> refers to a device special file and no corresponding device "
"exists.  (This is a Linux kernel bug; in this situation B<ENXIO> must be "
"returned.)"
msgstr ""
"I<pathname> がデバイススペシャルファイルを参照しており、対応するデバイスが存"
"在しない。 (これは Linux カーネルのバグであり、この場合には B<ENXIO> が返され"
"るべきである)"

#. type: Plain text
#: build/C/man2/open.2:543
msgid ""
"B<O_CREAT> is not set and the named file does not exist.  Or, a directory "
"component in I<pathname> does not exist or is a dangling symbolic link."
msgstr ""
"B<O_CREAT> が設定されておらず、かつ指定されたファイルが存在しない。 または、 "
"I<pathname> のディレクトリ部分が存在しないか壊れた (dangling) シンボリックリ"
"ンクである。"

#. type: Plain text
#: build/C/man2/open.2:552
msgid ""
"I<pathname> was to be created but the device containing I<pathname> has no "
"room for the new file."
msgstr ""
"I<pathname> を作成する必要があるが、 I<pathname> を含んでいるデバイスに新しい"
"ファイルのための空き容量がない。"

#. type: Plain text
#: build/C/man2/open.2:559
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory, "
"or B<O_DIRECTORY> was specified and I<pathname> was not a directory."
msgstr ""
"I<pathname> に含まれるディレクトリ部分のどれかが実際にはディレクトリでない。 "
"または B<O_DIRECTORY> が指定されており、 I<pathname> がディレクトリでない。"

#. type: Plain text
#: build/C/man2/open.2:565
msgid ""
"B<O_NONBLOCK> | B<O_WRONLY> is set, the named file is a FIFO and no process "
"has the file open for reading.  Or, the file is a device special file and no "
"corresponding device exists."
msgstr ""
"B<O_NONBLOCK> | B<O_WRONLY> が設定されており、指定したファイルが FIFO で その"
"ファイルを読み込みのためにオープンしているプロセスが存在しない。 または、ファ"
"イルがデバイススペシャルファイルで 対応するデバイスが存在しない。"

#.  See http://bugzilla.kernel.org/show_bug.cgi?id=7253
#.  "Open of a large file on 32-bit fails with EFBIG, should be EOVERFLOW"
#.  Reported 2006-10-03
#. type: Plain text
#: build/C/man2/open.2:585
msgid ""
"I<pathname> refers to a regular file that is too large to be opened.  The "
"usual scenario here is that an application compiled on a 32-bit platform "
"without I<-D_FILE_OFFSET_BITS=64> tried to open a file whose size exceeds I<"
"(2E<lt>E<lt>31)-1> bits; see also B<O_LARGEFILE> above.  This is the error "
"specified by POSIX.1-2001; in kernels before 2.6.24, Linux gave the error "
"B<EFBIG> for this case."
msgstr ""
"I<pathname> が参照しているのが、大き過ぎてオープンできない通常のファイルであ"
"る。 通常、このエラーが発生するは、32 ビットプラットフォーム上で I<-"
"D_FILE_OFFSET_BITS=64> を指定せずにコンパイルされたアプリケーションが、ファイ"
"ルサイズが I<(2E<lt>31)-1> ビットを超えるファイルを開こうとした場合である。 "
"上記の B<O_LARGEFILE> も参照。 これは POSIX.1-2001 で規定されているエラーであ"
"る。 2.6.24 より前のカーネルでは、Linux はこの場合にエラー B<EFBIG> を返して"
"いた。"

#.  Strictly speaking, it's the file system UID... (MTK)
#. type: Plain text
#: build/C/man2/open.2:593
msgid ""
"The B<O_NOATIME> flag was specified, but the effective user ID of the caller "
"did not match the owner of the file and the caller was not privileged "
"(B<CAP_FOWNER>)."
msgstr ""
"B<O_NOATIME> フラグが指定されたが、呼び出し元の実効ユーザー ID が ファイルの"
"所有者と一致せず、かつ呼び出し元に特権 (B<CAP_FOWNER>)  がない。"

#. type: Plain text
#: build/C/man2/open.2:598
msgid ""
"I<pathname> refers to a file on a read-only file system and write access was "
"requested."
msgstr ""
"I<pathname> が読み込み専用のファイルシステム上のファイルを参照しており、 書き"
"込みアクセスが要求された。"

#. type: TP
#: build/C/man2/open.2:598
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man2/open.2:603
msgid ""
"I<pathname> refers to an executable image which is currently being executed "
"and write access was requested."
msgstr ""
"I<pathname> が現在実行中の実行イメージを参照しており、書き込みが要求された。"

#. type: TP
#: build/C/man2/open.2:603
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: build/C/man2/open.2:610
msgid ""
"The B<O_NONBLOCK> flag was specified, and an incompatible lease was held on "
"the file (see B<fcntl>(2))."
msgstr ""
"B<O_NONBLOCK> フラグが指定されたが、そのファイルには矛盾するリースが設定され"
"ていた (B<fcntl>(2)  参照)。"

#. type: Plain text
#: build/C/man2/open.2:623
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  The B<O_DIRECTORY>, B<O_NOATIME>, and "
"B<O_NOFOLLOW> flags are Linux-specific, and one may need to define "
"B<_GNU_SOURCE> (before including I<any> header files)  to obtain their "
"definitions."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  フラグ B<O_DIRECTORY>, B<O_NOATIME>, "
"B<O_NOFOLLOW> は Linux 特有のものであり、 これらのフラグの定義を得るために"
"は、 (「どの」ヘッダファイルをインクルードするよりも前に)  B<_GNU_SOURCE> を"
"定義する必要があるかもしれない。"

#. type: Plain text
#: build/C/man2/open.2:628
msgid ""
"The B<O_CLOEXEC> flag is not specified in POSIX.1-2001, but is specified in "
"POSIX.1-2008."
msgstr ""
"B<O_CLOEXEC> フラグは POSIX.1-2001 では規定されていないが、 POSIX.1-2008 で規"
"定されている。"

#. type: Plain text
#: build/C/man2/open.2:636
msgid ""
"B<O_DIRECT> is not specified in POSIX; one has to define B<_GNU_SOURCE> "
"(before including I<any> header files)  to get its definition."
msgstr ""
"B<O_DIRECT> は POSIX では規定されていない。 B<O_DIRECT> の定義を得るには "
"(「どの」ヘッダファイルをインクルードするよりも前に)  B<_GNU_SOURCE> を定義し"
"なければならない。"

#. type: Plain text
#: build/C/man2/open.2:644
msgid ""
"Under Linux, the B<O_NONBLOCK> flag indicates that one wants to open but "
"does not necessarily have the intention to read or write.  This is typically "
"used to open devices in order to get a file descriptor for use with B<ioctl>"
"(2)."
msgstr ""
"Linux では、 B<O_NONBLOCK> フラグは、 open を実行したいが read または write "
"を実行する意図は 必ずしもないことを意味する。 これは B<ioctl>(2)  のための"
"ファイルディスクリプタを取得するために、 デバイスをオープンするときによく用い"
"られる。"

#.  See for example util-linux's disk-utils/setfdprm.c
#.  For some background on access mode 3, see
#.  http://thread.gmane.org/gmane.linux.kernel/653123
#.  "[RFC] correct flags to f_mode conversion in __dentry_open"
#.  LKML, 12 Mar 2008
#. type: Plain text
#: build/C/man2/open.2:673
msgid ""
"Unlike the other values that can be specified in I<flags>, the I<access "
"mode> values B<O_RDONLY>, B<O_WRONLY>, and B<O_RDWR>, do not specify "
"individual bits.  Rather, they define the low order two bits of I<flags>, "
"and are defined respectively as 0, 1, and 2.  In other words, the "
"combination B<O_RDONLY | O_WRONLY> is a logical error, and certainly does "
"not have the same meaning as B<O_RDWR>.  Linux reserves the special, "
"nonstandard access mode 3 (binary 11) in I<flags> to mean: check for read "
"and write permission on the file and return a descriptor that can't be used "
"for reading or writing.  This nonstandard access mode is used by some Linux "
"drivers to return a descriptor that is only to be used for device-specific "
"B<ioctl>(2)  operations."
msgstr ""
"「アクセスモード」の値 B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR> は、 I<flags> に指"
"定できる他の値と違い、個々のビットを指定するものではなく、 これらの値は "
"I<flags> の下位 2 ビットを定義する。 B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR> はそ"
"れぞれ 0, 1, 2 に定義されている。 言い換えると、 B<O_RDONLY | O_WRONLY> の組"
"み合わせは論理的に間違いであり、確かに B<O_RDWR> と同じ意味ではない。 Linux "
"では、特別な、非標準なアクセスモードとして 3 (バイナリでは 11) が 予約されて"
"おり I<flags> に指定できる。 このアクセスモードを指定すると、ファイルの読み出"
"し/書き込み許可をチェックし、 読み出しにも書き込みにも使用できないディスクリ"
"プタを返す。 この非標準のアクセスモードはいくつかの Linux ドライバで使用され"
"ており、 デバイス固有の B<ioctl>(2)  操作にのみ使用されるディスクリプタを返す"
"ために使われている。"

#.  Linux 2.0, 2.5: truncate
#.  Solaris 5.7, 5.8: truncate
#.  Irix 6.5: truncate
#.  Tru64 5.1B: truncate
#.  HP-UX 11.22: truncate
#.  FreeBSD 4.7: truncate
#. type: Plain text
#: build/C/man2/open.2:684
msgid ""
"The (undefined) effect of B<O_RDONLY | O_TRUNC> varies among "
"implementations.  On many systems the file is actually truncated."
msgstr ""
"B<O_RDONLY | O_TRUNC> の影響は未定義であり、その動作は実装によって異なる。 多"
"くのシステムではファイルは実際に切り詰められる。"

#. type: Plain text
#: build/C/man2/open.2:688
msgid ""
"There are many infelicities in the protocol underlying NFS, affecting "
"amongst others B<O_SYNC> and B<O_NDELAY>."
msgstr ""
"NFS を実現しているプロトコルには多くの不備があり、特に B<O_SYNC> と "
"B<O_NDELAY> に影響する。"

#. type: Plain text
#: build/C/man2/open.2:710
msgid ""
"POSIX provides for three different variants of synchronized I/O, "
"corresponding to the flags B<O_SYNC>, B<O_DSYNC>, and B<O_RSYNC>.  Currently "
"(2.6.31), Linux only implements B<O_SYNC>, but glibc maps B<O_DSYNC> and "
"B<O_RSYNC> to the same numerical value as B<O_SYNC>.  Most Linux file "
"systems don't actually implement the POSIX B<O_SYNC> semantics, which "
"require all metadata updates of a write to be on disk on returning to "
"userspace, but only the B<O_DSYNC> semantics, which require only actual file "
"data and metadata necessary to retrieve it to be on disk by the time the "
"system call returns."
msgstr ""
"POSIX では、3 種類の同期 I/O が提供されており、 B<O_SYNC>, B<O_DSYNC>, "
"B<O_RSYNC> フラグがこれに対応するものである。 今のところ (カーネル 2.6.31)、 "
"Linux では B<O_SYNC> だけが実装されているが、 glibc は B<O_DSYNC> と "
"B<O_RSYNC> に B<O_SYNC> と同じ数値を割り当てている。 ほとんどの Linux のファ"
"イルシステムは、実際には POSIX の B<O_SYNC> の動作ではなく B<O_DSYNC> の動作"
"だけを実装している。 POSIX の B<O_SYNC> では、 B<open>()  がユーザ空間に返る"
"際に、書き込みに関する全てのメタデータの 更新がディスクに書き込まれている必要"
"がある。 一方、 B<O_DSYNC> では、 B<open>()  が返るまでに、実際のファイルの"
"データとそのデータを取得するために 必要なメタデータだけがディスクに書き込まれ"
"ていればよい。"

#. type: Plain text
#: build/C/man2/open.2:718
msgid ""
"Note that B<open>()  can open device special files, but B<creat>()  cannot "
"create them; use B<mknod>(2)  instead."
msgstr ""
"B<open>()  はスペシャルファイルをオープンすることができるが、 B<creat>()  で"
"スペシャルファイルを作成できない点に注意すること。 代わりに B<mknod>(2)  を使"
"用する。"

#. type: Plain text
#: build/C/man2/open.2:731
msgid ""
"On NFS file systems with UID mapping enabled, B<open>()  may return a file "
"descriptor but, for example, B<read>(2)  requests are denied with "
"B<EACCES>.  This is because the client performs B<open>()  by checking the "
"permissions, but UID mapping is performed by the server upon read and write "
"requests."
msgstr ""
"UID マッピングを使用している NFS ファイルシステムでは、 B<open>()  がファイル"
"ディスクリプタを返した場合でも B<read>(2)  が B<EACCES> で拒否される場合があ"
"る。 これはクライアントがアクセス許可のチェックを行って B<open>()  を実行する"
"が、読み込みや書き込みの際には サーバーで UID マッピングが行われるためであ"
"る。"

#. type: Plain text
#: build/C/man2/open.2:750
msgid ""
"If the file is newly created, its I<st_atime>, I<st_ctime>, I<st_mtime> "
"fields (respectively, time of last access, time of last status change, and "
"time of last modification; see B<stat>(2))  are set to the current time, and "
"so are the I<st_ctime> and I<st_mtime> fields of the parent directory.  "
"Otherwise, if the file is modified because of the B<O_TRUNC> flag, its "
"st_ctime and st_mtime fields are set to the current time."
msgstr ""
"ファイルが新しく作成されると、 ファイルの I<st_atime>, I<st_ctime>, "
"I<st_mtime> フィールド (それぞれ最終アクセス時刻、最終状態変更時刻、最終修正"
"時刻である。 B<stat>(2)  参照) が現在時刻に設定される。 さらに親ディレクトリ"
"の I<st_ctime> と I<st_mtime> も現在時刻に設定される。 それ以外の場合で、"
"O_TRUNC フラグでファイルが修正されたときは、 ファイルの I<st_ctime> と "
"I<st_mtime> フィールドが現在時刻に設定される。"

#. type: SS
#: build/C/man2/open.2:750
#, no-wrap
msgid "O_DIRECT"
msgstr "O_DIRECT"

#. type: Plain text
#: build/C/man2/open.2:767
msgid ""
"The B<O_DIRECT> flag may impose alignment restrictions on the length and "
"address of userspace buffers and the file offset of I/Os.  In Linux "
"alignment restrictions vary by file system and kernel version and might be "
"absent entirely.  However there is currently no file system-independent "
"interface for an application to discover these restrictions for a given file "
"or file system.  Some file systems provide their own interfaces for doing "
"so, for example the B<XFS_IOC_DIOINFO> operation in B<xfsctl>(3)."
msgstr ""
"B<O_DIRECT> フラグを使用する場合、ユーザ空間バッファの長さやアドレス、 I/O の"
"ファイルオフセットに関してアラインメントの制限が課されることがある。 Linux で"
"は、アラインメントの制限はファイルシステムやカーネルのバージョンに よって異な"
"り、全く制限が存在しない場合もある。 しかしながら、現在のところ、指定された"
"ファイルやファイルシステムに対して こうした制限があるかを見つけるための、アプ"
"リケーション向けのインタフェースで ファイルシステム非依存のものは存在しな"
"い。 いくつかのファイルシステムでは、制限を確認するための独自のインタフェース"
"が 提供されている。例えば、 B<xfsctl>(3)  の B<XFS_IOC_DIOINFO> 命令である。"

#. type: Plain text
#: build/C/man2/open.2:772
msgid ""
"Under Linux 2.4, transfer sizes, and the alignment of the user buffer and "
"the file offset must all be multiples of the logical block size of the file "
"system.  Under Linux 2.6, alignment to 512-byte boundaries suffices."
msgstr ""
"Linux 2.4 では、転送サイズ、 ユーザーバッファのアラインメント、ファイルオフ"
"セットは、 ファイルシステムの論理ブロックサイズの倍数でなければならない。 "
"Linux 2.6 では、512 バイトごとの境界に配置されていれば充分である。"

#. type: Plain text
#: build/C/man2/open.2:806
msgid ""
"B<O_DIRECT> I/Os should never be run concurrently with the B<fork>(2)  "
"system call, if the memory buffer is a private mapping (i.e., any mapping "
"created with the B<mmap(2)> B<MAP_PRIVATE> flag; this includes memory "
"allocated on the heap and statically allocated buffers).  Any such I/Os, "
"whether submitted via an asynchronous I/O interface or from another thread "
"in the process, should be completed before B<fork>(2)  is called.  Failure "
"to do so can result in data corruption and undefined behavior in parent and "
"child processes.  This restriction does not apply when the memory buffer for "
"the B<O_DIRECT> I/Os was created using B<shmat>(2)  or B<mmap>(2)  with the "
"B<MAP_SHARED> flag.  Nor does this restriction apply when the memory buffer "
"has been advised as B<MADV_DONTFORK> with B<madvise(2),> ensuring that it "
"will not be available to the child after B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/open.2:816
msgid ""
"The B<O_DIRECT> flag was introduced in SGI IRIX, where it has alignment "
"restrictions similar to those of Linux 2.4.  IRIX has also a B<fcntl>(2)  "
"call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a "
"flag of the same name, but without alignment restrictions."
msgstr ""
"B<O_DIRECT> フラグは SGI IRIX で導入された。SGI IRIX にも Linux 2.4 と同様の "
"(ユーザーバッファの) アラインメントの制限がある。 また、IRIX には適切な配置と"
"サイズを取得するための B<fcntl>(2)  コールがある。 FreeBSD 4.x も同じ名前のフ"
"ラグを導入したが、アラインメントの制限はない。"

#. type: Plain text
#: build/C/man2/open.2:825
msgid ""
"B<O_DIRECT> support was added under Linux in kernel version 2.4.10.  Older "
"Linux kernels simply ignore this flag.  Some file systems may not implement "
"the flag and B<open>()  will fail with B<EINVAL> if it is used."
msgstr ""
"B<O_DIRECT> が Linux でサポートされたのは、カーネルバージョン 2.4.10 であ"
"る。 古い Linux カーネルは、このフラグを単に無視する。 B<O_DIRECT> フラグをサ"
"ポートしていないファイルシステムもあり、その場合は、 B<O_DIRECT> を使用する"
"と B<open>()  は B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/open.2:836
msgid ""
"Applications should avoid mixing B<O_DIRECT> and normal I/O to the same "
"file, and especially to overlapping byte regions in the same file.  Even "
"when the file system correctly handles the coherency issues in this "
"situation, overall I/O throughput is likely to be slower than using either "
"mode alone.  Likewise, applications should avoid mixing B<mmap>(2)  of files "
"with direct I/O to the same files."
msgstr ""
"アプリケーションは、同じファイル、 特に同じファイルの重複するバイト領域に対し"
"て、 B<O_DIRECT> と通常の I/O を混ぜて使うのは避けるべきである。 ファイルシス"
"テムがこのような状況において一貫性の問題を正しく 扱うことができる場合であって"
"も、全体の I/O スループットは どちらか一方を使用するときと比べて低速になるで"
"あろう。 同様に、アプリケーションは、同じファイルに対して B<mmap>(2)  と直接 "
"I/O (B<O_DIRECT>)  を混ぜて使うのも避けるべきである。"

#. type: Plain text
#: build/C/man2/open.2:858
msgid ""
"The behaviour of B<O_DIRECT> with NFS will differ from local file systems.  "
"Older kernels, or kernels configured in certain ways, may not support this "
"combination.  The NFS protocol does not support passing the flag to the "
"server, so B<O_DIRECT> I/O will only bypass the page cache on the client; "
"the server may still cache the I/O.  The client asks the server to make the "
"I/O synchronous to preserve the synchronous semantics of B<O_DIRECT>.  Some "
"servers will perform poorly under these circumstances, especially if the I/O "
"size is small.  Some servers may also be configured to lie to clients about "
"the I/O having reached stable storage; this will avoid the performance "
"penalty at some risk to data integrity in the event of server power "
"failure.  The Linux NFS client places no alignment restrictions on "
"B<O_DIRECT> I/O."
msgstr ""
"NFS で B<O_DIRECT> を使った場合の動作はローカルのファイルシステムの場合と違"
"う。 古いカーネルや、ある種の設定でコンパイルされたカーネルは、 B<O_DIRECT> "
"と NFS の組み合わせをサポートしていないかもしれない。 NFS プロトコル自体は"
"サーバにフラグを渡す機能は持っていないので、 B<O_DIRECT> I/O はクライアント上"
"のページキャッシュをバイパスするだけになり、 サーバは I/O をキャッシュしてい"
"るかもしれない。 クライアントは、 B<O_DIRECT> の同期機構を保持するため、サー"
"バに対して I/O を同期して行うように依頼する。 サーバによっては、こうした状況"
"下、特に I/O サイズが小さい場合に 性能が大きく劣化する。 また、サーバによって"
"は、I/O が安定したストレージにまで行われたと、 クライアントに対して嘘をつくも"
"のもある。 これは、サーバの電源故障が起こった際にデータの完全性が保たれない "
"危険は少しあるが、性能面での不利な条件を回避するために行われている。 Linux "
"の NFS クライアントでは B<O_DIRECT> I/O でのアラインメントの制限はない。"

#. type: Plain text
#: build/C/man2/open.2:865
msgid ""
"In summary, B<O_DIRECT> is a potentially powerful tool that should be used "
"with caution.  It is recommended that applications treat use of B<O_DIRECT> "
"as a performance option which is disabled by default."
msgstr ""
"まとめると、 B<O_DIRECT> は、注意して使うべきであるが、強力なツールとなる可能"
"性を持っている。 アプリケーションは B<O_DIRECT> をデフォルトでは無効になって"
"いる性能向上のためのオプションと 考えておくのがよいであろう。"

#. type: Plain text
#: build/C/man2/open.2:870
msgid ""
"\"The thing that has always disturbed me about O_DIRECT is that the whole "
"interface is just stupid, and was probably designed by a deranged monkey on "
"some serious mind-controlling substances.\"\\(emLinus"
msgstr ""
"「O_DIRECT でいつも困るのは、インタフェース全部が本当にお馬鹿な点だ。 たぶん"
"危ないマインドコントロール剤で 頭がおかしくなったサルが設計したんじゃないか"
"な」 \\(em Linus"

#.  FIXME . Check bugzilla report on open(O_ASYNC)
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5993
#. type: Plain text
#: build/C/man2/open.2:882
msgid ""
"Currently, it is not possible to enable signal-driven I/O by specifying "
"B<O_ASYNC> when calling B<open>(); use B<fcntl>(2)  to enable this flag."
msgstr ""
"現在のところ、 B<open>()  の呼び出し時に B<O_ASYNC> を指定してシグナル駆動 I/"
"O を有効にすることはできない。 このフラグを有効にするには B<fcntl>(2)  を使用"
"すること。"

#. type: Plain text
#: build/C/man2/open.2:904
msgid ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<openat>(2), B<read>(2), "
"B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<write>(2), B<fopen>"
"(3), B<fifo>(7), B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<chmod>(2), B<chown>(2), B<close>(2), B<dup>(2), B<fcntl>(2), B<link>(2), "
"B<lseek>(2), B<mknod>(2), B<mmap>(2), B<mount>(2), B<openat>(2), B<read>(2), "
"B<socket>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<write>(2), B<fopen>"
"(3), B<fifo>(7), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man3/perror.3:30
#, no-wrap
msgid "PERROR"
msgstr "PERROR"

#. type: TH
#: build/C/man3/perror.3:30
#, no-wrap
msgid "2012-04-17"
msgstr "2012-04-17"

#. type: Plain text
#: build/C/man3/perror.3:33
msgid "perror - print a system error message"
msgstr "perror - システムエラーメッセージを出力する"

#. type: Plain text
#: build/C/man3/perror.3:37
msgid "B<void perror(const char *>I<s>B<);>"
msgstr "B<void perror(const char *>I<s>B<);>"

#. type: Plain text
#: build/C/man3/perror.3:39
msgid "B<#include E<lt>errno.hE<gt>>"
msgstr "B<#include E<lt>errno.hE<gt>>"

#. type: Plain text
#: build/C/man3/perror.3:41
msgid "B<const char *>I<sys_errlist>B<[];>"
msgstr "B<const char *>I<sys_errlist>B<[];>"

#. type: Plain text
#: build/C/man3/perror.3:43
msgid "B<int >I<sys_nerr>B<;>"
msgstr "B<int >I<sys_nerr>B<;>"

#. type: Plain text
#: build/C/man3/perror.3:45
msgid "B<int >I<errno>B<;>"
msgstr "B<int >I<errno>B<;>"

#. type: Plain text
#: build/C/man3/perror.3:54
msgid "I<sys_errlist>, I<sys_nerr>: _BSD_SOURCE"
msgstr "I<sys_errlist>, I<sys_nerr>: _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/perror.3:67
msgid ""
"The routine B<perror>()  produces a message on the standard error output, "
"describing the last error encountered during a call to a system or library "
"function.  First (if I<s> is not NULL and I<*s> is not a null byte (\\(aq"
"\\e0\\(aq)) the argument string I<s> is printed, followed by a colon and a "
"blank.  Then the message and a new-line."
msgstr ""
"関数 B<perror>()  は、システムコールやライブラリ関数の呼び出しにおいて、最後"
"に発生した エラーに関する説明メッセージを生成し、標準エラー出力に出力する。 "
"(I<s> が NULL でなく、 I<*s> が NULL バイト (\\(aq\\e0\\(aq) でない場合には) "
"引き数の文字列 I<s> がまず出力され、続いてコロン、空白が出力され、 それから"
"メッセージと改行が出力される。"

#. type: Plain text
#: build/C/man3/perror.3:75
msgid ""
"To be of most use, the argument string should include the name of the "
"function that incurred the error.  The error number is taken from the "
"external variable I<errno>, which is set when errors occur but not cleared "
"when successful calls are made."
msgstr ""
"このメッセージを最大限活用するためには、引き数文字列にエラーが発生した 関数名"
"を入れておくとよい。 エラー番号は外部変数 I<errno> から取得される。 I<errno> "
"はエラーが発生した時に設定され、 成功した呼び出しではクリアされない。"

#. type: Plain text
#: build/C/man3/perror.3:89
msgid ""
"The global error list I<sys_errlist>[] indexed by I<errno> can be used to "
"obtain the error message without the newline.  The largest message number "
"provided in the table is I<sys_nerr>-1.  Be careful when directly accessing "
"this list because new error values may not have been added to I<sys_errlist>"
"[].  The use of I<sys_errlist>[] is nowadays deprecated."
msgstr ""
"大域変数のエラーリスト I<sys_errlist>[] は I<errno> を添字とする配列で、こ"
"の\n"
"配列から改行無しのエラーメッセージが取得される。 テーブルでの最大のメッセー"
"ジ\n"
"番号は I<sys_nerr> -1 となる。 このテーブルを直接参照する際には注意するこ"
"と。\n"
"なぜなら、新しいエラー番号が I<sys_errlist>[] に追加済とは限らないからであ"
"る。\n"
"現在では、I<sys_errlist>[] の使用は非推奨となっている。"

#. type: Plain text
#: build/C/man3/perror.3:111
msgid ""
"When a system call fails, it usually returns -1 and sets the variable "
"I<errno> to a value describing what went wrong.  (These values can be found "
"in I<E<lt>errno.hE<gt>>.)  Many library functions do likewise.  The function "
"B<perror>()  serves to translate this error code into human-readable form.  "
"Note that I<errno> is undefined after a successful library call: this call "
"may well change this variable, even though it succeeds, for example because "
"it internally used some other library function that failed.  Thus, if a "
"failing call is not immediately followed by a call to B<perror>(), the value "
"of I<errno> should be saved."
msgstr ""
"システムコールが失敗した場合、通常、返り値として -1 が返り、 I<errno> にエ"
"ラーを識別する値が設定される (設定されるエラー番号は I<E<lt>errno.hE<gt>> に"
"記載されている)。 多くのライブラリ関数も同様の動作となる。 関数 B<perror>()  "
"は、このエラーコードの可読なメッセージへの変換を行う。 I<errno> は、ライブラ"
"リ呼び出しが成功した後には未定義であることに注意が必要である: その呼び出し自"
"身は成功したとしても、内部で呼び出した他のライブラリ関数が 失敗して、その結果"
"をこの変数に設定することがあるからだ。 よって、失敗した呼び出しの直後に "
"B<perror>()  を呼ばない場合には I<errno> の値を 保存しておかなければならな"
"い。"

#. type: Plain text
#: build/C/man3/perror.3:124
msgid ""
"The function B<perror>()  and the external I<errno> (see B<errno>(3))  "
"conform to C89, C99, 4.3BSD, POSIX.1-2001.  The externals I<sys_nerr> and "
"I<sys_errlist> conform to BSD."
msgstr ""
"関数 B<perror>()  と外部変数 I<errno> (B<errno>(3)  参照) は C89, 4.3BSD, "
"POSIX.1-2001 に準拠している。 外部変数 I<sys_nerr> と I<sys_errlist> は BSD "
"に準拠している。"

#.  and only when _BSD_SOURCE is defined.
#.  When
#.  .B _GNU_SOURCE
#.  is defined, the symbols
#.  .I _sys_nerr
#.  and
#.  .I _sys_errlist
#.  are provided.
#. type: Plain text
#: build/C/man3/perror.3:139
msgid ""
"The externals I<sys_nerr> and I<sys_errlist> are defined by glibc, but in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""
"外部変数 I<sys_nerr> と I<sys_errlist> は glibc で定義されているが、 "
"I<E<lt>stdio.hE<gt>> に含まれている。"

#. type: Plain text
#: build/C/man3/perror.3:144
msgid "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"
msgstr "B<err>(3), B<errno>(3), B<error>(3), B<strerror>(3)"

#. type: TH
#: build/C/man2/pipe.2:36
#, no-wrap
msgid "PIPE"
msgstr "PIPE"

#. type: TH
#: build/C/man2/pipe.2:36
#, no-wrap
msgid "2012-02-14"
msgstr "2012-02-14"

#. type: Plain text
#: build/C/man2/pipe.2:39
msgid "pipe, pipe2 - create pipe"
msgstr "pipe, pipe2 - パイプを生成する"

#. type: Plain text
#: build/C/man2/pipe.2:42 build/C/man2/read.2:41
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pipe.2:44
#, no-wrap
msgid "B<int pipe(int >I<pipefd>B<[2]);>\n"
msgstr "B<int pipe(int >I<pipefd>B<[2]);>\n"

#. type: Plain text
#: build/C/man2/pipe.2:48
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* O_* 定数の定義の取得 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/pipe.2:50
#, no-wrap
msgid "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"
msgstr "B<int pipe2(int >I<pipefd>B<[2], int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/pipe.2:66
msgid ""
"B<pipe>()  creates a pipe, a unidirectional data channel that can be used "
"for interprocess communication.  The array I<pipefd> is used to return two "
"file descriptors referring to the ends of the pipe.  I<pipefd[0]> refers to "
"the read end of the pipe.  I<pipefd[1]> refers to the write end of the "
"pipe.  Data written to the write end of the pipe is buffered by the kernel "
"until it is read from the read end of the pipe.  For further details, see "
"B<pipe>(7)."
msgstr ""
"B<pipe>(2)  はパイプを生成する。 パイプは、プロセス間通信に使用できる単方向の"
"データチャネルである。 配列 I<pipefd> は、パイプの両端を参照する二つのファイ"
"ルディスクリプタを 返すのに使用される。 I<pipefd[0]> がパイプの読み出し側、 "
"I<pipefd[1]> がパイプの書き込み側である。 パイプの書き込み側に書き込まれた"
"データは、 パイプの読み出し側から読み出されるまでカーネルでバッファリングされ"
"る。 さらなる詳細は B<pipe>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/pipe.2:76
msgid ""
"If I<flags> is 0, then B<pipe2>()  is the same as B<pipe>().  The following "
"values can be bitwise ORed in I<flags> to obtain different behavior:"
msgstr ""
"B<pipe2>()  は I<flags> が 0 の場合には B<pipe>()  と同じである。 I<flags> に"
"以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさせることがで"
"きる。"

#. type: TP
#: build/C/man2/pipe.2:76
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: build/C/man2/pipe.2:84
msgid ""
"Set the B<O_NONBLOCK> file status flag on the two new open file "
"descriptions.  Using this flag saves extra calls to B<fcntl>(2)  to achieve "
"the same result."
msgstr ""
"新しく生成される二つのオープンファイル記述 (open file description) の "
"B<O_NONBLOCK> ファイルステータスフラグをセットする。 このフラグを使うこと"
"で、 B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなく"
"なる。"

#. type: TP
#: build/C/man2/pipe.2:84
#, no-wrap
msgid "B<O_CLOEXEC>"
msgstr "B<O_CLOEXEC>"

#. type: Plain text
#: build/C/man2/pipe.2:92
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the two new file "
"descriptors.  See the description of the same flag in B<open>(2)  for "
"reasons why this may be useful."
msgstr ""
"新しく生成される二つのファイルディスクリプタの close-on-exec "
"(B<FD_CLOEXEC>)  フラグをセットする。 このフラグが役に立つ理由については、 "
"B<open>(2)  の B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: Plain text
#: build/C/man2/pipe.2:102
msgid "I<pipefd> is not valid."
msgstr "I<pipefd> が無効な値である。"

#. type: Plain text
#: build/C/man2/pipe.2:107
msgid "(B<pipe2>())  Invalid value in I<flags>."
msgstr "(B<pipe2>())  I<flags> に無効な値が入っている。"

#. type: Plain text
#: build/C/man2/pipe.2:110
msgid "Too many file descriptors are in use by the process."
msgstr "このプロセスで使われているファイルディスクリプタが多すぎる。"

#. type: Plain text
#: build/C/man2/pipe.2:118
msgid ""
"B<pipe2>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"B<pipe2>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポート"
"はバージョン 2.9 以降で利用できる。"

#. type: Plain text
#: build/C/man2/pipe.2:121
msgid "B<pipe>(): POSIX.1-2001."
msgstr "B<pipe>(): POSIX.1-2001."

#. type: Plain text
#: build/C/man2/pipe.2:124
msgid "B<pipe2>()  is Linux-specific."
msgstr "B<pipe2>()  は Linux 固有である。"

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/pipe.2:140
msgid ""
"The following program creates a pipe, and then B<fork>(2)s to create a child "
"process; the child inherits a duplicate set of file descriptors that refer "
"to the same pipe.  After the B<fork>(2), each process closes the descriptors "
"that it doesn't need for the pipe (see B<pipe>(7)).  The parent then writes "
"the string contained in the program's command-line argument to the pipe, and "
"the child reads this string a byte at a time from the pipe and echoes it on "
"standard output."
msgstr ""
"以下のプログラムではパイプを生成し、その後 B<fork>(2)  で子プロセスを生成す"
"る。 子プロセスは同じパイプを参照するファイルディスクリプタ集合のコピーを 継"
"承する。 B<fork>(2)  の後、各プロセスはパイプ (B<pipe>(7)  を参照) に必要がな"
"くなったディスクリプタをクローズする。 親プロセスはプログラムのコマンドライン"
"引き数に含まれる 文字列をパイプへ書き込み、 子プロセスはこの文字列をパイプか"
"ら 1 バイトずつ読み込んで標準出力にエコーする。"

#. type: Plain text
#: build/C/man2/pipe.2:147
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man2/pipe.2:154
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int pipefd[2];\n"
"    pid_t cpid;\n"
"    char buf;\n"

#. type: Plain text
#: build/C/man2/pipe.2:159
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"\tfprintf(stderr, \"Usage: %s E<lt>stringE<gt>\\en\", argv[0]);\n"
"\texit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pipe.2:164
#, no-wrap
msgid ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (pipe(pipefd) == -1) {\n"
"        perror(\"pipe\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pipe.2:170
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/pipe.2:173
#, no-wrap
msgid ""
"    if (cpid == 0) {    /* Child reads from pipe */\n"
"        close(pipefd[1]);          /* Close unused write end */\n"
msgstr ""
"    if (cpid == 0) {    /* 子プロセスがパイプから読み込む */\n"
"        close(pipefd[1]);  /* 使用しない write 側はクローズする */\n"

#. type: Plain text
#: build/C/man2/pipe.2:176
#, no-wrap
msgid ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"
msgstr ""
"        while (read(pipefd[0], &buf, 1) E<gt> 0)\n"
"            write(STDOUT_FILENO, &buf, 1);\n"

#. type: Plain text
#: build/C/man2/pipe.2:180
#, no-wrap
msgid ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"
msgstr ""
"        write(STDOUT_FILENO, \"\\en\", 1);\n"
"        close(pipefd[0]);\n"
"        _exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/pipe.2:189
#, no-wrap
msgid ""
"    } else {            /* Parent writes argv[1] to pipe */\n"
"        close(pipefd[0]);          /* Close unused read end */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* Reader will see EOF */\n"
"        wait(NULL);                /* Wait for child */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"    } else {            /* 親プロセスは argv[1] をパイプへ書き込む */\n"
"        close(pipefd[0]);          /* 使用しない read 側はクローズする */\n"
"        write(pipefd[1], argv[1], strlen(argv[1]));\n"
"        close(pipefd[1]);          /* 読み込み側が EOF に出会う */\n"
"        wait(NULL);                /* 子プロセスを待つ */\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/pipe.2:197
msgid ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<write>(2), B<popen>(3), B<pipe>"
"(7)"
msgstr ""
"B<fork>(2), B<read>(2), B<socketpair>(2), B<write>(2), B<popen>(3), B<pipe>"
"(7)"

#. type: TH
#: build/C/man3/popen.3:38
#, no-wrap
msgid "POPEN"
msgstr "POPEN"

#. type: TH
#: build/C/man3/popen.3:38
#, no-wrap
msgid "2010-02-03"
msgstr "2010-02-03"

#. type: Plain text
#: build/C/man3/popen.3:41
msgid "popen, pclose - pipe stream to or from a process"
msgstr "popen, pclose - プロセスとの入力/出力用のパイプストリーム"

#. type: Plain text
#: build/C/man3/popen.3:46
#, no-wrap
msgid "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *popen(const char *>I<command>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/popen.3:48
#, no-wrap
msgid "B<int pclose(FILE *>I<stream>B<);>\n"
msgstr "B<int pclose(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/popen.3:58
msgid "B<popen>(), B<pclose>():"
msgstr "B<popen>(), B<pclose>():"

#. type: Plain text
#: build/C/man3/popen.3:60
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/popen.3:71
msgid ""
"The B<popen>()  function opens a process by creating a pipe, forking, and "
"invoking the shell.  Since a pipe is by definition unidirectional, the "
"I<type> argument may specify only reading or writing, not both; the "
"resulting stream is correspondingly read-only or write-only."
msgstr ""
"B<popen>()  関数は、プロセスをオープンする。具体的には、 パイプを生成し、"
"フォークを行い、シェルを起動する。 定義から分かるように、パイプは一方向なの"
"で、 I<type> 引き数には読み込みか書き込みのどちらか一方だけを指定できる (両方"
"は指定できない)。 生成されるストリームは、この指定に対応して、読み取り専用ま"
"たは 書き込み専用のいずれかとなる。"

#. type: Plain text
#: build/C/man3/popen.3:95
msgid ""
"The I<command> argument is a pointer to a null-terminated string containing "
"a shell command line.  This command is passed to I</bin/sh> using the B<-c> "
"flag; interpretation, if any, is performed by the shell.  The I<type> "
"argument is a pointer to a null-terminated string which must contain either "
"the letter \\(aqr\\(aq for reading or the letter \\(aqw\\(aq for writing.  "
"Since glibc 2.9, this argument can additionally include the letter \\(aqe"
"\\(aq, which causes the close-on-exec flag (B<FD_CLOEXEC>)  to be set on the "
"underlying file descriptor; see the description of the B<O_CLOEXEC> flag in "
"B<open>(2)  for reasons why this may be useful."
msgstr ""
"I<command> 引き数は、シェルのコマンドラインを含む NULL 終端された文字列へのポ"
"インタである。 このコマンドは B<-c> フラグを用いて I</bin/sh> に渡される。 コ"
"マンドの解釈は (もし必要ならば) シェルによって行われる。 I<type> 引き数は、"
"NULL 終端された文字列へのポインタで、 読み込みを示す文字 \\(aqr\\(aq か、書き"
"込みを示す文字 \\(aqw\\(aq の どちらか一方を指定しなければならない。 glibc "
"2.9 以降では、この引き数に文字 \\(aqe\\(aq を追加で指定できる。 文字 \\(aqe"
"\\(aq を指定すると、 対応するファイルディスクリプタにおいて、 close-on-exec "
"フラグ (B<FD_CLOEXEC>)  がセットされる。 これが役に立つ理由については、 "
"B<open>(2)  の B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: Plain text
#: build/C/man3/popen.3:111
msgid ""
"The return value from B<popen>()  is a normal standard I/O stream in all "
"respects save that it must be closed with B<pclose>()  rather than B<fclose>"
"(3).  Writing to such a stream writes to the standard input of the command; "
"the command's standard output is the same as that of the process that called "
"B<popen>(), unless this is altered by the command itself.  Conversely, "
"reading from a \"popened\" stream reads the command's standard output, and "
"the command's standard input is the same as that of the process that called "
"B<popen>()."
msgstr ""
"B<popen>()  からの返り値は、通常の標準 I/O ストリームと同じであるが、 "
"B<fclose>(3)  ではなく B<pclose>()  で閉じなくてはならないことだけが異なる。 "
"このストリームへ書き込んだ結果はコマンドの標準入力に書き込まれる。 そして、コ"
"マンドの標準出力は、 コマンドそのものが置き換わってしまわない限り、 B<popen>"
"()  を呼んだプロセスの標準出力と同じことになる。 逆に、\"popened\" (B<popen>"
"()  によって開かれた) ストリームからの読み込みは、 そのコマンドの標準出力を読"
"み込むことになる。 そして、そのコマンドの標準入力は B<popen>()  を呼んだプロ"
"セスの標準入力と同一である。"

#. type: Plain text
#: build/C/man3/popen.3:115
msgid "Note that output B<popen>()  streams are fully buffered by default."
msgstr ""
"デフォルトでは、 B<popen>()  の出力ストリームは完全にバッファリングされること"
"に注意しよう。"

#. type: Plain text
#: build/C/man3/popen.3:121
msgid ""
"The B<pclose>()  function waits for the associated process to terminate and "
"returns the exit status of the command as returned by B<wait4>(2)."
msgstr ""
"B<pclose>()  関数は、(パイプに) 関連づけられたプロセスが終了するのを待ち、 "
"B<wait4>(2)  によって返されたコマンドの終了状態を返す。"

#. type: Plain text
#: build/C/man3/popen.3:129
msgid ""
"The B<popen>()  function returns NULL if the B<fork>(2)  or B<pipe>(2)  "
"calls fail, or if it cannot allocate memory."
msgstr ""
"B<popen>()  関数は、 B<fork>(2)  または B<pipe>(2)  呼び出しが失敗した場合"
"や、 メモリ割り当てができなかった場合、 NULL を返す。"

#.  These conditions actually give undefined results, so I commented
#.  them out.
#.  .I stream
#.  is not associated with a "popen()ed" command, if
#. .I stream
#.  already "pclose()d", or if
#. type: Plain text
#: build/C/man3/popen.3:141
msgid ""
"The B<pclose>()  function returns -1 if B<wait4>(2)  returns an error, or "
"some other error is detected."
msgstr ""
"B<pclose>()  関数は、 B<wait4>(2)  がエラーを返したり、何か他のエラーが見つ"
"かった場合、 -1 を返す。"

#. type: Plain text
#: build/C/man3/popen.3:160
msgid ""
"The B<popen>()  function does not set I<errno> if memory allocation fails.  "
"If the underlying B<fork>(2)  or B<pipe>(2)  fails, I<errno> is set "
"appropriately.  If the I<type> argument is invalid, and this condition is "
"detected, I<errno> is set to B<EINVAL>."
msgstr ""
"B<popen>()  関数は、メモリアロケーションに失敗しても I<errno> をセットしな"
"い。 B<popen>()  が中で呼び出す B<fork>(2)  や B<pipe>(2)  が失敗した場合に"
"は、 I<errno> が適切にセットされる。 引き数 I<type> が無効であり、この状態が"
"検知された場合には、 I<errno> が B<EINVAL> にセットされる。"

#. type: Plain text
#: build/C/man3/popen.3:167
msgid ""
"If B<pclose>()  cannot obtain the child status, I<errno> is set to B<ECHILD>."
msgstr ""
"B<pclose>()  が、子プロセスの状態を取得できなかった場合、 I<errno> が "
"B<ECHILD> にセットされる。"

#. type: Plain text
#: build/C/man3/popen.3:173
msgid "The \\(aqe\\(aq value for I<type> is a Linux extension."
msgstr "I<type> に指定できる \\(aqe\\(aq は Linux での拡張である。"

#. type: Plain text
#: build/C/man3/popen.3:186
msgid ""
"Since the standard input of a command opened for reading shares its seek "
"offset with the process that called B<popen>(), if the original process has "
"done a buffered read, the command's input position may not be as expected.  "
"Similarly, the output from a command opened for writing may become "
"intermingled with that of the original process.  The latter can be avoided "
"by calling B<fflush>(3)  before B<popen>()."
msgstr ""
"読み込みのために開かれたコマンドの標準入力は B<popen>(), を呼んだプロセスと一"
"緒に、その読み取り位置を共有する。 そのため、もとのプロセスがバッファリングさ"
"れた読み取りを終了したら、 そのコマンドの入力位置は予想されたものには なって"
"いないかもしれない。 同様に、書き込みのために開かれたコマンドからの出力は、 "
"もとのプロセスの出力と混ざり合うことになるかもしれない。 後者は B<popen>()  "
"の前に B<fflush>(3)  を呼び出すことによって回避可能である。"

#.  .SH HISTORY
#.  A
#.  .BR popen ()
#.  and a
#.  .BR pclose ()
#.  function appeared in Version 7 AT&T UNIX.
#. type: Plain text
#: build/C/man3/popen.3:196
msgid ""
"Failure to execute the shell is indistinguishable from the shell's failure "
"to execute command, or an immediate exit of the command.  The only hint is "
"an exit status of 127."
msgstr ""
"シェルの実行の失敗は、 シェルがコマンドの実行に失敗したことや、 コマンドがす"
"ぐに終了してしまったことと、区別がつかない。 唯一のヒントは終了状態が 127 に"
"なることである。"

#. type: Plain text
#: build/C/man3/popen.3:206
msgid ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"
msgstr ""
"B<sh>(1), B<fork>(2), B<pipe>(2), B<wait4>(2), B<fclose>(3), B<fflush>(3), "
"B<fopen>(3), B<stdio>(3), B<system>(3)"

#. type: TH
#: build/C/man3/printf.3:34
#, no-wrap
msgid "PRINTF"
msgstr "PRINTF"

#. type: TH
#: build/C/man3/printf.3:34 build/C/man3/puts.3:24 build/C/man3/scanf.3:50
#, no-wrap
msgid "2011-09-28"
msgstr "2011-09-28"

#. type: Plain text
#: build/C/man3/printf.3:38
msgid ""
"printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - "
"formatted output conversion"
msgstr ""
"printf, fprintf, sprintf, snprintf, vprintf, vfprintf, vsprintf, vsnprintf - "
"指定された書式に変換して出力を行う"

#. type: Plain text
#: build/C/man3/printf.3:42
msgid "B<int printf(const char *>I<format>B<, ...);>"
msgstr "B<int printf(const char *>I<format>B<, ...);>"

#. type: Plain text
#: build/C/man3/printf.3:44
msgid "B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>"
msgstr "B<int fprintf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: build/C/man3/printf.3:46
msgid "B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>"
msgstr "B<int sprintf(char *>I<str>B<, const char *>I<format>B<, ...);>"

#. type: Plain text
#: build/C/man3/printf.3:48
msgid ""
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, ...);>"
msgstr ""
"B<int snprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, ...);>"

#. type: Plain text
#: build/C/man3/printf.3:50
msgid "B<#include E<lt>stdarg.hE<gt>>"
msgstr "B<#include E<lt>stdarg.hE<gt>>"

#. type: Plain text
#: build/C/man3/printf.3:52
msgid "B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr "B<int vprintf(const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: build/C/man3/printf.3:54
msgid ""
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"
msgstr ""
"B<int vfprintf(FILE *>I<stream>B<, const char *>I<format>B<, va_list "
">I<ap>B<);>"

#. type: Plain text
#: build/C/man3/printf.3:56
msgid ""
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int vsprintf(char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: build/C/man3/printf.3:59
msgid ""
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, va_list >I<ap>B<);>"
msgstr ""
"B<int vsnprintf(char *>I<str>B<, size_t >I<size>B<, const char "
"*>I<format>B<, va_list >I<ap>B<);>"

#. type: Plain text
#: build/C/man3/printf.3:68
msgid "B<snprintf>(), B<vsnprintf>():"
msgstr "B<snprintf>(), B<vsnprintf>():"

#. type: Plain text
#: build/C/man3/printf.3:71
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE || "
"_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/printf.3:74 build/C/man3/scanf.3:83
msgid "or I<cc -std=c99>"
msgstr "or I<cc -std=c99>"

#. type: Plain text
#: build/C/man3/printf.3:101
msgid ""
"The functions in the B<printf>()  family produce output according to a "
"I<format> as described below.  The functions B<printf>()  and B<vprintf>()  "
"write output to I<stdout>, the standard output stream; B<fprintf>()  and "
"B<vfprintf>()  write output to the given output I<stream>; B<sprintf>(), "
"B<snprintf>(), B<vsprintf>()  and B<vsnprintf>()  write to the character "
"string I<str>."
msgstr ""
"B<printf>()  関数グループは、以下で述べるように、 I<format> に従って出力を生"
"成するものである。 B<printf>()  と B<vprintf>()  は出力を I<stdout> (標準出力"
"ストリーム) に書き出す。 B<fprintf>()  と B<vfprintf>()  は出力を指定された出"
"力 I<stream> に書き出す。 B<sprintf>(), B<snprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  は出力を文字列 I<str> に書き込む。"

#. type: Plain text
#: build/C/man3/printf.3:110
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  write at most I<size> bytes "
"(including the terminating null byte (\\(aq\\e0\\(aq)) to I<str>."
msgstr ""
"B<snprintf>()  と B<vsnprintf>()  は最大で I<size> バイトを I<str> に書き込"
"む (I<size> には文字列を終端する NULL バイト (\\(aq\\e0\\(aq) もを含まれる)。"

#. type: Plain text
#: build/C/man3/printf.3:134
msgid ""
"The functions B<vprintf>(), B<vfprintf>(), B<vsprintf>(), B<vsnprintf>()  "
"are equivalent to the functions B<printf>(), B<fprintf>(), B<sprintf>(), "
"B<snprintf>(), respectively, except that they are called with a I<va_list> "
"instead of a variable number of arguments.  These functions do not call the "
"I<va_end> macro.  Because they invoke the I<va_arg> macro, the value of "
"I<ap> is undefined after the call.  See B<stdarg>(3)."
msgstr ""
"B<vprintf>(), B<vfprintf>(), B<vsprintf>(), B<vsnprintf>()  の各関数はそれぞ"
"れ B<printf>(), B<fprintf>(), B<sprintf>(), B<snprintf>(), の各関数と等価であ"
"り、可変数引き数の代わりに I<va_list> を引き数として呼び出される点だけが異な"
"る。 これらの関数では I<va_end> マクロは呼び出されない。 これらの関数は "
"I<va_arg> を呼び出すので、呼び出し後の I<ap> の値は未定義である。 B<stdarg>"
"(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/printf.3:141
msgid ""
"These eight functions write the output under the control of a I<format> "
"string that specifies how subsequent arguments (or arguments accessed via "
"the variable-length argument facilities of B<stdarg>(3))  are converted for "
"output."
msgstr ""
"これらの 8 つの関数は I<format> 文字列の制御に従って出力を書き出す。 "
"I<format> 文字列は、これに続く引き数 (または B<stdarg>(3)  の可変長引き数機構"
"を使ってアクセスできる引き数)  をどのように変換して出力するかを指定する。"

#. type: Plain text
#: build/C/man3/printf.3:152
msgid ""
"C99 and POSIX.1-2001 specify that the results are undefined if a call to "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), or B<vsnprintf>()  would cause "
"copying to take place between objects that overlap (e.g., if the target "
"string array and one of the supplied input arguments refer to the same "
"buffer).  See NOTES."
msgstr ""
"C99 と POSIX.1-2001 では、 B<sprintf>(), B<snprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  の呼び出しで、範囲が重複するオブジェクト間でコピーが発生する"
"場合の 結果は不定であると規定されている (例えば、出力先の文字列と入力された "
"引き数の一つが同じバッファを参照している場合などである)。 「注意」の節を参"
"照。"

#. type: SS
#: build/C/man3/printf.3:152
#, no-wrap
msgid "Return value"
msgstr "Return Values"

#. type: Plain text
#: build/C/man3/printf.3:155
msgid ""
"Upon successful return, these functions return the number of characters "
"printed (excluding the null byte used to end output to strings)."
msgstr ""
"成功時には、上記の関数は書き込まれた文字数を返す (文字列の最後を示すために使"
"用する NULL バイトは数に含まれない)。"

#. type: Plain text
#: build/C/man3/printf.3:171
msgid ""
"The functions B<snprintf>()  and B<vsnprintf>()  do not write more than "
"I<size> bytes (including the terminating null byte (\\(aq\\e0\\(aq)).  If "
"the output was truncated due to this limit then the return value is the "
"number of characters (excluding the terminating null byte)  which would have "
"been written to the final string if enough space had been available.  Thus, "
"a return value of I<size> or more means that the output was truncated.  (See "
"also below under NOTES.)"
msgstr ""
"B<snprintf>()  と B<vsnprintf>()  は、 I<size> バイトを越える文字数を書き込ま"
"ない (I<size> には文字列を終端する NULL バイト (\\(aq\\e0\\(aq) も含まれ"
"る)。 この制限によって出力が切り詰められた場合には、 もし十分なスペースがあれ"
"ば書き込まれたであろう文字の個数 (文字列を終端する NULL バイトを除く) を返"
"す。 従って、返り値が I<size> 以上だった場合、出力が切り詰められたことを意味"
"する (後述の注意も参照のこと)。"

#. type: Plain text
#: build/C/man3/printf.3:173
msgid "If an output error is encountered, a negative value is returned."
msgstr "エラーが発生した場合は、負の数を返す。"

#. type: SS
#: build/C/man3/printf.3:173
#, no-wrap
msgid "Format of the format string"
msgstr "フォーマット文字列のフォーマット"

#. type: Plain text
#: build/C/man3/printf.3:195
msgid ""
"The format string is a character string, beginning and ending in its initial "
"shift state, if any.  The format string is composed of zero or more "
"directives: ordinary characters (not B<%>), which are copied unchanged to "
"the output stream; and conversion specifications, each of which results in "
"fetching zero or more subsequent arguments.  Each conversion specification "
"is introduced by the character B<%>, and ends with a I<conversion "
"specifier>.  In between there may be (in this order) zero or more I<flags>, "
"an optional minimum I<field width>, an optional I<precision> and an optional "
"I<length modifier>."
msgstr ""
"フォーマット文字列は文字の列で、 (もしあるなら) 初期シフト状態で始まり、初期"
"シフト状態で終わる。 フォーマット用の文字列は 0 個以上の命令 (directives) に"
"よって構成される。 命令には、通常文字と変換指定 (conversion specifications) "
"がある。 通常文字は B<%> 以外の文字で、出力ストリームにそのままコピーされ"
"る。 変換指定は、それぞれが 0 個以上の引き数を取る。 各変換指定は文字 B<%> で"
"始まり、 I<変換指定子 (conversion specifier)> で終わる。 B<%> と変換指定子の"
"間には、0 個以上の I<フラグ 、> 最小 I<フィールド幅 、> I<精度 、> I<長さ修飾"
"子> を (この順序で) 置くことができる。"

#. type: Plain text
#: build/C/man3/printf.3:208
msgid ""
"The arguments must correspond properly (after type promotion) with the "
"conversion specifier.  By default, the arguments are used in the order "
"given, where each \\(aq*\\(aq and each conversion specifier asks for the "
"next argument (and it is an error if insufficiently many arguments are "
"given).  One can also specify explicitly which argument is taken, at each "
"place where an argument is required, by writing \"%m$\" instead of \\(aq%"
"\\(aq and \"*m$\" instead of \\(aq*\\(aq, where the decimal integer m "
"denotes the position in the argument list of the desired argument, indexed "
"starting from 1.  Thus,"
msgstr ""
"引き数は (型の格上げの後は) 変換指定子が表す型と正確に対応しなければならな"
"い。 デフォルトでは、\\(aq*\\(aq や変換指定子が出てくる毎に次の引き数を要求さ"
"れ、 引き数は指定された順序で使用されていく (指定された引き数の個数が不十分な"
"らエラーとなる)。 また、引き数が必要な箇所で \\(aq%\\(aq の代わりに \"%m$"
"\"、 \\(aq*\\(aqの代わりに \"*m$\" と書くことで、 明示的にどの引き数を使用す"
"るかを指定することもできる。 ここで 10進の整数 m は希望の引き数の引き数リスト"
"での位置を示す (最初の引き数の番号が 1 である)。 従って、"

#. type: Plain text
#: build/C/man3/printf.3:212
#, no-wrap
msgid "printf(\"%*d\", width, num);\n"
msgstr "printf(\"%*d\", width, num);\n"

#. type: Plain text
#: build/C/man3/printf.3:216
msgid "and"
msgstr "と"

#. type: Plain text
#: build/C/man3/printf.3:220
#, no-wrap
msgid "printf(\"%2$*1$d\", width, num);\n"
msgstr "printf(\"%2$*1$d\", width, num);\n"

#. type: Plain text
#: build/C/man3/printf.3:236
msgid ""
"are equivalent.  The second style allows repeated references to the same "
"argument.  The C99 standard does not include the style using \\(aq$\\(aq, "
"which comes from the Single UNIX Specification.  If the style using \\(aq$"
"\\(aq is used, it must be used throughout for all conversions taking an "
"argument and all width and precision arguments, but it may be mixed with \"%%"
"\" formats which do not consume an argument.  There may be no gaps in the "
"numbers of arguments specified using \\(aq$\\(aq; for example, if arguments "
"1 and 3 are specified, argument 2 must also be specified somewhere in the "
"format string."
msgstr ""
"は等価である。 二番目の書き方では同じ引き数を繰り返し参照することができる。 "
"C99 標準には、 Single UNIX Specification 由来の \\(aq$\\(aq を使った書き方は"
"含まれていない。 \\(aq$\\(aq を使ったスタイルを使うと、引き数を取る変換及び幅"
"と精度の引き数を 全てこのスタイルで指定しなければならないが、 引き数を消費し"
"ない \"%%\" フォーマットと混ざっているかもしれない。 \\(aq$\\(aq で指定される"
"引き数の番号に空きがあってはならない。 例えば、もし引き数 1 と 3 が指定される"
"と、引き数 2 もフォーマット文字列のどこかで 指定されなければならない。"

#. type: Plain text
#: build/C/man3/printf.3:246
msgid ""
"For some numeric conversions a radix character (\"decimal point\") or "
"thousands' grouping character is used.  The actual character used depends on "
"the B<LC_NUMERIC> part of the locale.  The POSIX locale uses \\(aq.\\(aq as "
"radix character, and does not have a grouping character.  Thus,"
msgstr ""
"数値変換には小数点や 1000 単位の区切り文字を使うものもある。 実際にどの文字を"
"使うかはロケールの B<LC_NUMERIC> による。 POSIX ロケールでは小数点に \\(aq."
"\\(aq を用い、 区切り文字は使わない。 従って、"

#. type: Plain text
#: build/C/man3/printf.3:250
#, no-wrap
msgid "    printf(\"%\\(aq.2f\", 1234567.89);\n"
msgstr "printf(\"%\\(aq.2f\", 1234567.89);\n"

#. type: Plain text
#: build/C/man3/printf.3:255
msgid ""
"results in \"1234567.89\" in the POSIX locale, in \"1234567,89\" in the "
"nl_NL locale, and in \"1.234.567,89\" in the da_DK locale."
msgstr ""
"は、 POSIX ロケールでは \"1234567.89\" 、 nl_NL ロケールでは "
"\"1234567,89\"、 da_DK ロケールでは \"1.234.567,89\" となる。"

#. type: SS
#: build/C/man3/printf.3:255
#, no-wrap
msgid "The flag characters"
msgstr "フラグ文字"

#. type: Plain text
#: build/C/man3/printf.3:257
msgid "The character % is followed by zero or more of the following flags:"
msgstr "% 文字の後ろには 0 個以上のフラグ文字が続く。"

#. type: TP
#: build/C/man3/printf.3:257
#, no-wrap
msgid "B<#>"
msgstr "B<#>"

#. type: Plain text
#: build/C/man3/printf.3:291
msgid ""
"The value should be converted to an \"alternate form\".  For B<o> "
"conversions, the first character of the output string is made zero (by "
"prefixing a 0 if it was not zero already).  For B<x> and B<X> conversions, a "
"nonzero result has the string \"0x\" (or \"0X\" for B<X> conversions) "
"prepended to it.  For B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> "
"conversions, the result will always contain a decimal point, even if no "
"digits follow it (normally, a decimal point appears in the results of those "
"conversions only if a digit follows).  For B<g> and B<G> conversions, "
"trailing zeros are not removed from the result as they would otherwise be.  "
"For other conversions, the result is undefined."
msgstr ""
"値は「別の形式」に変換される。 B<o> 変換の場合、(先頭文字が 0 になっていない"
"場合に先頭に 0 を追加することで)  出力文字列の最初の文字を 0 にする。 B<x> "
"と B<X> 変換の場合、数値が 0 でないときには文字列 \"0x\" (B<X> 変換の場合に"
"は \"0X\") が前に付与される。 B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, B<G> "
"変換では、 小数点に続く数字がなくても、 出力には常に小数点が含まれる (通常"
"は、小数点の後に数字が続く場合にのみ、 小数点が表示される)。 B<g> と B<G> 変"
"換の場合、他の変換とは異なり、末尾のゼロが変換結果から削除されない。 その他の"
"変換では、結果は未定義である。"

#. type: TP
#: build/C/man3/printf.3:291
#, no-wrap
msgid "B<\\&0>"
msgstr "B<\\&0>"

#. type: Plain text
#: build/C/man3/printf.3:331
msgid ""
"The value should be zero padded.  For B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, "
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, and B<G> conversions, the "
"converted value is padded on the left with zeros rather than blanks.  If the "
"B<\\&0> and B<-> flags both appear, the B<\\&0> flag is ignored.  If a "
"precision is given with a numeric conversion (B<d>, B<i>, B<o>, B<u>, B<x>, "
"and B<X>), the B<\\&0> flag is ignored.  For other conversions, the behavior "
"is undefined."
msgstr ""
"値をゼロで埋める。 B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, B<a>, B<A>, B<e>, "
"B<E>, B<f>, B<F>, B<g>, B<G> 変換では、変換した値の左側を空白文字の代わりにゼ"
"ロで埋める。 B<\\&0> と B<-> が両方とも指定された場合は、 B<\\&0> フラグは無"
"視される。 精度が数値変換 (B<d>, B<i>, B<o>, B<u>, B<x>, B<X>)  と同時に指定"
"された場合には、 B<\\&0> フラグは無視される。 その他の変換では、動作は未定義"
"である。"

#. type: TP
#: build/C/man3/printf.3:331
#, no-wrap
msgid "B<->"
msgstr "B<->"

#. type: Plain text
#: build/C/man3/printf.3:344
msgid ""
"The converted value is to be left adjusted on the field boundary.  (The "
"default is right justification.)  Except for B<n> conversions, the converted "
"value is padded on the right with blanks, rather than on the left with "
"blanks or zeros.  A B<-> overrides a B<\\&0> if both are given."
msgstr ""
"変換値をフィールド境界で左揃えにする (デフォルトは右揃えである)。 B<n> 変換以"
"外では、変換された値は 左側ではなく右側を空白文字やゼロで埋められる。 B<-> "
"と B<\\&0> の両方が指定された場合には、 B<-> が優先される。"

#. type: TP
#: build/C/man3/printf.3:344
#, no-wrap
msgid "B<\\(aq \\(aq>"
msgstr "B<' '>"

#. type: Plain text
#: build/C/man3/printf.3:348
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(1個の半角スペース)  符号付き変換で生成された正の数字の前に空白 (または空文字"
"列) が置かれる。"

#. type: TP
#: build/C/man3/printf.3:348
#, no-wrap
msgid "B<+>"
msgstr "B<+>"

#. type: Plain text
#: build/C/man3/printf.3:356
msgid ""
"A sign (+ or -) should always be placed before a number produced by a signed "
"conversion.  By default a sign is used only for negative numbers.  A B<+> "
"overrides a space if both are used."
msgstr ""
"符号付き変換によって出力される数字の前に、常に符号 (+ か -) が置かれる。 デ"
"フォルトでは、符号は負の数字の場合のみ付与される。 B<+> と半角スペースの 両方"
"が使われている場合には、 B<+> が優先される。"

#. type: Plain text
#: build/C/man3/printf.3:359
msgid ""
"The five flag characters above are defined in the C standard.  The SUSv2 "
"specifies one further flag character."
msgstr ""
"上記の 5 つのフラグは C 標準で定義されている。 SUSv2 では、さらにもう一つフラ"
"グ文字が規定されている。"

#. type: TP
#: build/C/man3/printf.3:359
#, no-wrap
msgid "B<\\(aq>"
msgstr "B<\\(aq>"

#. type: Plain text
#: build/C/man3/printf.3:376
msgid ""
"For decimal conversion (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  the "
"output is to be grouped with thousands' grouping characters if the locale "
"information indicates any.  Note that many versions of B<gcc>(1)  cannot "
"parse this option and will issue a warning.  SUSv2 does not include I<%"
"\\(aqF>."
msgstr ""
"10進数変換 (B<i>, B<d>, B<u>, B<f>, B<F>, B<g>, B<G>)  において、ロケール情報"
"に指定があれば 1000 単位の区切り文字を出力する。 B<gcc>(1)  の多くのバージョ"
"ンは、このオプションを解釈することができず、 警告を出力することに注意せよ。 %"
"\\(aqF は SUSv2 には含まれていない。"

#. type: Plain text
#: build/C/man3/printf.3:378
msgid "glibc 2.2 adds one further flag character."
msgstr "glibc 2.2 では、さらに一つフラグ文字が追加されている。"

#. type: TP
#: build/C/man3/printf.3:378
#, no-wrap
msgid "B<I>"
msgstr "B<I>"

#.  outdigits keyword in locale file
#. type: Plain text
#: build/C/man3/printf.3:388
msgid ""
"For decimal integer conversion (B<i>, B<d>, B<u>)  the output uses the "
"locale's alternative output digits, if any.  For example, since glibc 2.2.3 "
"this will give Arabic-Indic digits in the Persian (\"fa_IR\") locale."
msgstr ""
"10進整数変換 (B<i>, B<d>, B<u>)  において、ロケールの代替出力数字があれば、そ"
"れを用いて出力する。 例えば、 glibc 2.2.3 以降では、ペルシア (\"fa_IR\") ロ"
"ケールで アラビア数字 (Arabic-Indic digits) を出力できる。"

#. type: SS
#: build/C/man3/printf.3:388
#, no-wrap
msgid "The field width"
msgstr "フィールド幅"

#. type: Plain text
#: build/C/man3/printf.3:404
msgid ""
"An optional decimal digit string (with nonzero first digit) specifying a "
"minimum field width.  If the converted value has fewer characters than the "
"field width, it will be padded with spaces on the left (or right, if the "
"left-adjustment flag has been given).  Instead of a decimal digit string one "
"may write \"*\" or \"*m$\" (for some decimal integer I<m>) to specify that "
"the field width is given in the next argument, or in the I<m>-th argument, "
"respectively, which must be of type I<int>.  A negative field width is taken "
"as a \\(aq-\\(aq flag followed by a positive field width.  In no case does a "
"nonexistent or small field width cause truncation of a field; if the result "
"of a conversion is wider than the field width, the field is expanded to "
"contain the conversion result."
msgstr ""
"最小のフィールド幅を指定する 10進数の数値文字列 (文字列の最初の文字は ゼロ以"
"外)。本項目はオプションである。 変換された値の文字数がフィールド長よりも少な"
"い場合、 フィールドの左側をスペースで埋める (左揃えのフラグがある場合は右側を"
"埋める)。 10進数の文字列の代わりに \"*\" や \"*m$\" (I<m> は 10進整数) を書く"
"こともできる。 \"*\" と \"*m$\" はそれぞれ、次の引き数と I<m> 番目の引き数を"
"フィールド幅として 使うことを指定する (これらの引き数は I<int> 型でなければな"
"らない)。 フィールド幅に負の数が指定された場合は、 \\(aq-\\(aq フラグと正の数"
"のフィールド幅として扱われる。 フィールド幅が小さかったり指定がなかったりして"
"も、フィールドが切り詰められる ことはない。もし変換結果がフィールド幅よりも広"
"かった場合、 フィールドは変換結果が入る幅に広げられる。"

#. type: SS
#: build/C/man3/printf.3:404
#, no-wrap
msgid "The precision"
msgstr "精度"

#. type: Plain text
#: build/C/man3/printf.3:440
msgid ""
"An optional precision, in the form of a period (\\(aq.\\(aq)  followed by an "
"optional decimal digit string.  Instead of a decimal digit string one may "
"write \"*\" or \"*m$\" (for some decimal integer m) to specify that the "
"precision is given in the next argument, or in the m-th argument, "
"respectively, which must be of type I<int>.  If the precision is given as "
"just \\(aq.\\(aq, or the precision is negative, the precision is taken to be "
"zero.  This gives the minimum number of digits to appear for B<d>, B<i>, "
"B<o>, B<u>, B<x>, and B<X> conversions, the number of digits to appear after "
"the radix character for B<a>, B<A>, B<e>, B<E>, B<f>, and B<F> conversions, "
"the maximum number of significant digits for B<g> and B<G> conversions, or "
"the maximum number of characters to be printed from a string for B<s> and "
"B<S> conversions."
msgstr ""
"オプションである精度は、ピリオド (\\(aq.\\(aq) とそれに続く10進数という 形式"
"で指定する (10進数はオプション) 。 10進数の文字列の代わりに \"*\" や \"*m$"
"\" (m は 10 進整数)を書くこともできる。 \"*\" と \"*m$\" はそれぞれ、次の引き"
"数と m 番目の引き数を精度として 使うことを指定する (これらの引き数は I<int> "
"型でなければならない)。 精度として \\(aq.\\(aq だけが指定されたり、精度が負の"
"数だった場合、 精度はゼロとみなされる。 B<d>, B<i>, B<o>, B<u>, B<x>, B<X> 変"
"換では、表示される最小の桁数を指定する。 B<a>, B<A>, B<e>, B<E>, B<f>, B<F> "
"変換では、小数点以下に表示される数字の桁数を指定する。 B<g> と B<G> 変換で"
"は、有効数字の最大桁数を指定する。 B<s> と B<S> 変換では、文字列から出力され"
"る最大文字数を指定する。"

#. type: SS
#: build/C/man3/printf.3:440
#, no-wrap
msgid "The length modifier"
msgstr "長さ修飾子"

#. type: Plain text
#: build/C/man3/printf.3:450
msgid ""
"Here, \"integer conversion\" stands for B<d>, B<i>, B<o>, B<u>, B<x>, or "
"B<X> conversion."
msgstr ""
"「整数変換」とは、 B<d>, B<i>, B<o>, B<u>, B<x>, B<X> 変換のことである。"

#. type: TP
#: build/C/man3/printf.3:450 build/C/man3/scanf.3:291
#, no-wrap
msgid "B<hh>"
msgstr "B<hh>"

#. type: Plain text
#: build/C/man3/printf.3:461
msgid ""
"A following integer conversion corresponds to a I<signed char> or I<unsigned "
"char> argument, or a following B<n> conversion corresponds to a pointer to a "
"I<signed char> argument."
msgstr ""
"整数変換に対応する引き数が I<signed char> か I<unsigned char> で、 B<n> 変換"
"に対応する引き数が I<signed char> へのポインタであることを示す。"

#. type: TP
#: build/C/man3/printf.3:461 build/C/man3/scanf.3:281
#, no-wrap
msgid "B<h>"
msgstr "B<h>"

#. type: Plain text
#: build/C/man3/printf.3:472
msgid ""
"A following integer conversion corresponds to a I<short int> or I<unsigned "
"short int> argument, or a following B<n> conversion corresponds to a pointer "
"to a I<short int> argument."
msgstr ""
"整数変換に対応する引き数が I<short int> か I<unsigned short int> で、 B<n> 変"
"換に対応する引き数が I<short int> へのポインタであることを示す。"

#. type: TP
#: build/C/man3/printf.3:472 build/C/man3/scanf.3:308
#, no-wrap
msgid "B<l>"
msgstr "B<l>"

#. type: Plain text
#: build/C/man3/printf.3:491
msgid ""
"(ell) A following integer conversion corresponds to a I<long int> or "
"I<unsigned long int> argument, or a following B<n> conversion corresponds to "
"a pointer to a I<long int> argument, or a following B<c> conversion "
"corresponds to a I<wint_t> argument, or a following B<s> conversion "
"corresponds to a pointer to I<wchar_t> argument."
msgstr ""
"各変換に対応する引き数が、 整数変換では I<long int>か I<unsigned long int>、 "
"B<n> 変換では I<long long int> へのポインタ、 B<c> 変換では I<wint_t>、 B<s> "
"変換では I<wchar_t> へのポインタであることを示す。"

#. type: TP
#: build/C/man3/printf.3:491
#, no-wrap
msgid "B<ll>"
msgstr "B<ll> (エルエル)"

#. type: Plain text
#: build/C/man3/printf.3:503
msgid ""
"(ell-ell).  A following integer conversion corresponds to a I<long long int> "
"or I<unsigned long long int> argument, or a following B<n> conversion "
"corresponds to a pointer to a I<long long int> argument."
msgstr ""
"整数変換に対応する引き数が I<long long int> か I<unsigned long long int> "
"で、 B<n> 変換に対応する引き数が I<long int> へのポインタであることを示す。"

#. type: TP
#: build/C/man3/printf.3:503 build/C/man3/scanf.3:335
#, no-wrap
msgid "B<L>"
msgstr "B<L>"

#. type: Plain text
#: build/C/man3/printf.3:519
msgid ""
"A following B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, or B<G> conversion "
"corresponds to a I<long double> argument.  (C99 allows %LF, but SUSv2 does "
"not.)"
msgstr ""
"B<a>, B<A>, B<e>, B<E>, B<f>, B<F>, B<g>, B<G> 変換に対応する引き数が I<long "
"double> であることを示す。 (C99 では %LF を使うことを認めているが、SUSv2 では"
"認められていない。)"

#. type: TP
#: build/C/man3/printf.3:519 build/C/man3/scanf.3:351
#, no-wrap
msgid "B<q>"
msgstr "B<q>"

#. type: Plain text
#: build/C/man3/printf.3:525
msgid ""
"(\"quad\". 4.4BSD and Linux libc5 only.  Don't use.)  This is a synonym for "
"B<ll>."
msgstr ""
"(\"quad\"。 4.4BSD と Linux libc5 のみ有効。使ってはならない。)  B<ll> と同じ"
"意味である。"

#. type: TP
#: build/C/man3/printf.3:525 build/C/man3/scanf.3:299
#, no-wrap
msgid "B<j>"
msgstr "B<j>"

#. type: Plain text
#: build/C/man3/printf.3:532
msgid ""
"A following integer conversion corresponds to an I<intmax_t> or I<uintmax_t> "
"argument."
msgstr ""
"整数変換に対応する引き数が I<intmax_t> か I<uintmax_t> であることを示す。"

#. type: TP
#: build/C/man3/printf.3:532 build/C/man3/scanf.3:363
#, no-wrap
msgid "B<z>"
msgstr "B<z>"

#. type: Plain text
#: build/C/man3/printf.3:543
msgid ""
"A following integer conversion corresponds to a I<size_t> or I<ssize_t> "
"argument.  (Linux libc5 has B<Z> with this meaning.  Don't use it.)"
msgstr ""
"整数変換に対応する引き数が I<size_t> か I<ssize_t> であることを示す。 (Linux "
"libc5 では、これを指定するのに B<Z> を用いる。使ってはならない。)"

#. type: TP
#: build/C/man3/printf.3:543 build/C/man3/scanf.3:356
#, no-wrap
msgid "B<t>"
msgstr "B<t>"

#. type: Plain text
#: build/C/man3/printf.3:548
msgid "A following integer conversion corresponds to a I<ptrdiff_t> argument."
msgstr "整数変換に対応する引き数が I<ptrdiff_t> であることを示す。"

#. type: Plain text
#: build/C/man3/printf.3:577
msgid ""
"The SUSv2 only knows about the length modifiers B<h> (in B<hd>, B<hi>, "
"B<ho>, B<hx>, B<hX>, B<hn>)  and B<l> (in B<ld>, B<li>, B<lo>, B<lx>, B<lX>, "
"B<ln>, B<lc>, B<ls>)  and B<L> (in B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)."
msgstr ""
"SUSv2 で長さ修飾子として使用できるのは、 B<h> (B<hd>, B<hi>, B<ho>, B<hx>, "
"B<hX>, B<hn>), B<l> (B<ld>, B<li>, B<lo>, B<lx>, B<lX>, B<ln>, B<lc>, "
"B<ls>), B<L> (B<Le>, B<LE>, B<Lf>, B<Lg>, B<LG>)  だけである。"

#. type: SS
#: build/C/man3/printf.3:577
#, no-wrap
msgid "The conversion specifier"
msgstr "変換指定子"

#. type: Plain text
#: build/C/man3/printf.3:580
msgid ""
"A character that specifies the type of conversion to be applied.  The "
"conversion specifiers and their meanings are:"
msgstr ""
"適用される変換の型を指定する文字。 変換指定子とその意味は以下の通りである。"

#. type: TP
#: build/C/man3/printf.3:580
#, no-wrap
msgid "B<d>, B<i>"
msgstr "B<d>, B<i>"

#. type: Plain text
#: build/C/man3/printf.3:590
msgid ""
"The I<int> argument is converted to signed decimal notation.  The precision, "
"if any, gives the minimum number of digits that must appear; if the "
"converted value requires fewer digits, it is padded on the left with zeros.  "
"The default precision is 1.  When 0 is printed with an explicit precision 0, "
"the output is empty."
msgstr ""
"I<int> 引き数を符号付き 10 進表記に変換する。 精度指定があれば、精度で指定し"
"た桁数は必ず出力される。変換後の値が 指定された桁数に足りない場合は、左側が "
"0 で埋められる。 デフォルトの精度は 1 である。 0 を表示しようとした時に、明示"
"的に精度として 0 が指定されていると、 出力は空文字列となる。"

#. type: TP
#: build/C/man3/printf.3:590
#, no-wrap
msgid "B<o>, B<u>, B<x>, B<X>"
msgstr "B<o>, B<u>, B<x>, B<X>"

#. type: Plain text
#: build/C/man3/printf.3:617
msgid ""
"The I<unsigned int> argument is converted to unsigned octal (B<o>), unsigned "
"decimal (B<u>), or unsigned hexadecimal (B<x> and B<X>)  notation.  The "
"letters B<abcdef> are used for B<x> conversions; the letters B<ABCDEF> are "
"used for B<X> conversions.  The precision, if any, gives the minimum number "
"of digits that must appear; if the converted value requires fewer digits, it "
"is padded on the left with zeros.  The default precision is 1.  When 0 is "
"printed with an explicit precision 0, the output is empty."
msgstr ""
"I<unsigned int> 引き数を、 符号なし8進数 (B<o>), 符号なし10進数 (B<u>), 符号"
"なし16進数 (B<x> と B<X>)  に変換する。 B<x> 変換では B<abcdef> が使用され、 "
"B<X> 変換では B<ABCDEF> が使用される。 精度指定があれば、精度で指定した桁数は"
"必ず出力される。変換後の値が 指定された桁数に足りない場合は、左側が 0 で埋め"
"られる。"

#. type: TP
#: build/C/man3/printf.3:617
#, no-wrap
msgid "B<e>, B<E>"
msgstr "B<e>, B<E>"

#. type: Plain text
#: build/C/man3/printf.3:636
#, fuzzy
#| msgid ""
#| "[-]dB<\\&.>dddB<e>\\*(Pmdd where there is one digit before the decimal-"
#| "point character and the number of digits after it is equal to the "
#| "precision; if the precision is missing, it is taken as 6; if the "
#| "precision is zero, no decimal-point character appears.  An B<E> "
#| "conversion uses the letter B<E> (rather than B<e>)  to introduce the "
#| "exponent.  The exponent always contains at least two digits; if the value "
#| "is zero, the exponent is 00."
msgid ""
"The I<double> argument is rounded and converted in the style [-]dB<\\&."
">dddB<e>\\(+-dd where there is one digit before the decimal-point character "
"and the number of digits after it is equal to the precision; if the "
"precision is missing, it is taken as 6; if the precision is zero, no decimal-"
"point character appears.  An B<E> conversion uses the letter B<E> (rather "
"than B<e>)  to introduce the exponent.  The exponent always contains at "
"least two digits; if the value is zero, the exponent is 00."
msgstr ""
"[-]dB<\\&.>dddB<e>\\*(Pmdd の形に変換する。 小数点の前には一桁の数字があり、"
"小数点以下の桁数は精度で指定された 桁数になる。精度は指定されなかった場合 6 "
"とみなされる。 精度が 0 の場合には、小数点以下は表示されない。 B<E> 変換で"
"は、指数を表現するときに (B<e> ではなく)  B<E> が使われる。 指数部分は少なく"
"とも 2桁表示される。 つまり、指数の値が 0 の場合には、00 と表示される。"

#. type: TP
#: build/C/man3/printf.3:636
#, no-wrap
msgid "B<f>, B<F>"
msgstr "B<f>, B<F>"

#. type: Plain text
#: build/C/man3/printf.3:647
msgid ""
"The I<double> argument is rounded and converted to decimal notation in the "
"style [-]dddB<\\&.>ddd, where the number of digits after the decimal-point "
"character is equal to the precision specification.  If the precision is "
"missing, it is taken as 6; if the precision is explicitly zero, no decimal-"
"point character appears.  If a decimal point appears, at least one digit "
"appears before it."
msgstr ""
"I<double> 引き数を丸めて [-]dddB<\\&.>ddd の形の10進表現に変換する。 小数点の"
"後の桁数は、精度で指定された値となる。 精度が指定されていない場合には 6 とし"
"て扱われる。 精度として明示的に 0 が指定されたときには、小数点以下は表示され"
"ない。 小数点を表示する際には、小数点の前に少なくとも一桁は数字が表示される。"

#. type: Plain text
#: build/C/man3/printf.3:658
msgid ""
"(The SUSv2 does not know about B<F> and says that character string "
"representations for infinity and NaN may be made available.  The C99 "
"standard specifies \"[-]inf\" or \"[-]infinity\" for infinity, and a string "
"starting with \"nan\" for NaN, in the case of B<f> conversion, and \"[-]INF"
"\" or \"[-]INFINITY\" or \"NAN*\" in the case of B<F> conversion.)"
msgstr ""
"(SUSv2 では、B<F> は規定されておらず、無限や NaN に関する文字列表現を\n"
"行ってもよいことになっている。\n"
" C99 標準では、B<f> 変換では、無限は \"[-]inf\" か \"[-]infinity\" と表示"
"し、\n"
"NaN は文字列の先頭に `nan' をつけて表示するように規定されている。\n"
"B<F> 変換の場合は \"[-]INF\", \"[-]INFINITY\", \"NAN*\" と表示される。)"

#. type: TP
#: build/C/man3/printf.3:658
#, no-wrap
msgid "B<g>, B<G>"
msgstr "B<g>, B<G>"

#. type: Plain text
#: build/C/man3/printf.3:683
msgid ""
"The I<double> argument is converted in style B<f> or B<e> (or B<F> or B<E> "
"for B<G> conversions).  The precision specifies the number of significant "
"digits.  If the precision is missing, 6 digits are given; if the precision "
"is zero, it is treated as 1.  Style B<e> is used if the exponent from its "
"conversion is less than -4 or greater than or equal to the precision.  "
"Trailing zeros are removed from the fractional part of the result; a decimal "
"point appears only if it is followed by at least one digit."
msgstr ""
"I<double> 引き数を B<f> か B<e> (B<G> 変換の場合は B<F> か B<E>)  の形式に変"
"換する。 精度は表示する桁数を指定する。 精度が指定されない場合は、6桁とみなさ"
"れる。 精度が 0 の場合は、1桁とみなされる。 変換される値の指数が、 -4 より小"
"さいか、精度以上の場合に、 B<e> 形式が使用される。 変換された結果の小数部分の"
"末尾の 0 は削除される。小数点が表示されるのは、 小数点以下に数字が少なくとも"
"一つある場合にだけである。"

#. type: TP
#: build/C/man3/printf.3:683
#, no-wrap
msgid "B<a>, B<A>"
msgstr "B<a>, B<A>"

#. type: Plain text
#: build/C/man3/printf.3:707
#, fuzzy
#| msgid ""
#| "(C99; not in SUSv2) For B<a> conversion, the I<double> argument is "
#| "converted to hexadecimal notation (using the letters abcdef)  in the "
#| "style [-]B<0x>hB<\\&.>hhhhB<p>\\*(Pmd; for B<A> conversion the prefix "
#| "B<0X>, the letters ABCDEF, and the exponent separator B<P> is used.  "
#| "There is one hexadecimal digit before the decimal point, and the number "
#| "of digits after it is equal to the precision.  The default precision "
#| "suffices for an exact representation of the value if an exact "
#| "representation in base 2 exists and otherwise is sufficiently large to "
#| "distinguish values of type I<double>.  The digit before the decimal point "
#| "is unspecified for nonnormalized numbers, and nonzero but otherwise "
#| "unspecified for normalized numbers."
msgid ""
"(C99; not in SUSv2) For B<a> conversion, the I<double> argument is converted "
"to hexadecimal notation (using the letters abcdef)  in the style [-]B<0x>hB<"
"\\&.>hhhhB<p>\\(+-; for B<A> conversion the prefix B<0X>, the letters "
"ABCDEF, and the exponent separator B<P> is used.  There is one hexadecimal "
"digit before the decimal point, and the number of digits after it is equal "
"to the precision.  The default precision suffices for an exact "
"representation of the value if an exact representation in base 2 exists and "
"otherwise is sufficiently large to distinguish values of type I<double>.  "
"The digit before the decimal point is unspecified for nonnormalized numbers, "
"and nonzero but otherwise unspecified for normalized numbers."
msgstr ""
"(C99 にはあるが SUSv2 にはない)  B<a> 変換では、 I<double> 引き数を (abcdef "
"の文字を使って)  [-]B<0x>hB<\\&.>hhhhB<p>\\*(Pmd; 形式の 16 進表記に変換す"
"る。 B<A> 変換では、前置文字列 B<0X>, 文字 ABCDEF, 指数文字 B<P> を用いる。 "
"小数点の前には 1桁の16進数が置かれ、小数点の後ろの桁数は 精度で指定された値と"
"なる。 デフォルトの精度は、その値が 2進数で正確に表現できる場合には、 その値"
"を正確に表現できる桁数となる。それ以外の場合は、 I<double> 型の値を区別するの"
"に十分な大きさとなる。 小数点の前の数字は、正規化されていない数の場合はいくつ"
"になるか分からない。 正規化された数の場合は、 0 以外の値になるが、いくつにな"
"るかは分からない。"

#. type: TP
#: build/C/man3/printf.3:707 build/C/man3/scanf.3:456
#: build/C/man3/wprintf.3:132
#, no-wrap
msgid "B<c>"
msgstr "B<c>"

#. type: Plain text
#: build/C/man3/printf.3:725
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to an "
"I<unsigned char>, and the resulting character is written.  If an B<l> "
"modifier is present, the I<wint_t> (wide character) argument is converted to "
"a multibyte sequence by a call to the B<wcrtomb>(3)  function, with a "
"conversion state starting in the initial state, and the resulting multibyte "
"string is written."
msgstr ""
"B<l> 修飾子がなければ、 I<int> 引き数を I<unsigned char> に変換して、その結果"
"に対応する文字を出力する。 B<l> 修飾子があれば、 I<wint_t> (ワイド文字) 引き"
"数を、 B<wcrtomb>(3)  関数を初期シフト状態で呼び出してマルチバイト文字列に変"
"換し、 変換されたマルチバイト文字列を出力する。"

#. type: TP
#: build/C/man3/printf.3:725 build/C/man3/scanf.3:448
#: build/C/man3/wprintf.3:146
#, no-wrap
msgid "B<s>"
msgstr "B<s>"

#. type: Plain text
#: build/C/man3/printf.3:740
msgid ""
"If no B<l> modifier is present: The I<const char *> argument is expected to "
"be a pointer to an array of character type (pointer to a string).  "
"Characters from the array are written up to (but not including) a "
"terminating null byte (\\(aq\\e0\\(aq); if a precision is specified, no more "
"than the number specified are written.  If a precision is given, no null "
"byte need be present; if the precision is not specified, or is greater than "
"the size of the array, the array must contain a terminating null byte."
msgstr ""
"B<l> 修飾子がない場合、 引き数は I<const char *> 型で文字型の配列へのポイン"
"タ (文字列へのポインタ) であることが 期待されている。配列中の文字は、終端の "
"NULL バイト (\\(aq\\e0\\(aq)  が出てくるまで出力される (終端文字は出力されな"
"い)。 精度が指定されていると、指定された字数以上は出力されない。 精度が指定さ"
"れた場合には、終端バイトが存在する必要はない。 精度が指定されていなかったり、"
"精度の値が配列の大きさより大きい場合には、 配列は終端の NULL バイトを含んでい"
"なければならない。"

#. type: Plain text
#: build/C/man3/printf.3:767
msgid ""
"If an B<l> modifier is present: The I<const wchar_t *> argument is expected "
"to be a pointer to an array of wide characters.  Wide characters from the "
"array are converted to multibyte characters (each by a call to the B<wcrtomb>"
"(3)  function, with a conversion state starting in the initial state before "
"the first wide character), up to and including a terminating null wide "
"character.  The resulting multibyte characters are written up to (but not "
"including) the terminating null byte.  If a precision is specified, no more "
"bytes than the number specified are written, but no partial multibyte "
"characters are written.  Note that the precision determines the number of "
"I<bytes> written, not the number of I<wide characters> or I<screen "
"positions>.  The array must contain a terminating null wide character, "
"unless a precision is given and it is so small that the number of bytes "
"written exceeds it before the end of the array is reached."
msgstr ""
"B<l> 修飾子が指定されている場合、 引き数は I<const wchar_t *> 型でワイド文字"
"の配列へのポインタであることが期待されている。 配列中のワイド文字は (1文字毎"
"に B<wcrtomb>(3)  を呼び出して) マルチバイト文字に変換される (最初のワイド文"
"字の変換の前に B<wcrtomb>()  のシフト状態を初期状態に戻してから変換は行われ"
"る)。 マルチバイト文字への変換は、文字列を終端する NULL ワイド文字が 出てくる"
"まで行われ、終端 NULL ワイド文字も含めて変換される。 結果のマルチバイト文字列"
"は、終端の NULL バイトが出てくるまで 出力される (終端の NULL バイトは出力され"
"ない)。 精度が指定された場合、指定されたバイト数以上には出力されない。 但し、"
"マルチバイト文字の一部分だけが出力されることはない。 精度は「バイト」数を指定"
"するものであり、「ワイド文字」数や 「画面での位置」を指定するものではないこと"
"に注意。 精度が指定されていて、さらに出力が配列の末尾に達する前に出力バイト数"
"が 精度の値を超える場合だけは、配列は NULL ワイド文字で終端されていなくてもよ"
"い。 それ以外の場合は、必ず配列は NULL ワイド文字で終端されていなければならな"
"い。"

#. type: TP
#: build/C/man3/printf.3:767
#, no-wrap
msgid "B<C>"
msgstr "B<C>"

#. type: Plain text
#: build/C/man3/printf.3:773
msgid "(Not in C99, but in SUSv2.)  Synonym for B<lc>.  Don't use."
msgstr "(C99 にはないが SUSv2 にはある)  B<lc> と同じ。使ってはならない。"

#. type: TP
#: build/C/man3/printf.3:773
#, no-wrap
msgid "B<S>"
msgstr "B<S>"

#. type: Plain text
#: build/C/man3/printf.3:779
msgid "(Not in C99, but in SUSv2.)  Synonym for B<ls>.  Don't use."
msgstr "(C99 にはないが SUSv2 にはある)  B<ls> と同じ。使ってはならない。"

#. type: TP
#: build/C/man3/printf.3:779 build/C/man3/scanf.3:500
#, no-wrap
msgid "B<p>"
msgstr "B<p>"

#. type: Plain text
#: build/C/man3/printf.3:787
msgid ""
"The I<void *> pointer argument is printed in hexadecimal (as if by B<%#x> or "
"B<%#lx>)."
msgstr ""
"I<void *> ポインタ引き数を (B<%#x> や B<%#lx> のような) 16 進数で出力する。"

#. type: TP
#: build/C/man3/printf.3:787 build/C/man3/scanf.3:508
#, no-wrap
msgid "B<n>"
msgstr "B<n>"

#. type: Plain text
#: build/C/man3/printf.3:794
msgid ""
"The number of characters written so far is stored into the integer indicated "
"by the I<int *> (or variant) pointer argument.  No argument is converted."
msgstr ""
"これまでに出力された文字数を I<int *> (または類似の型) のポインタ引き数が指す"
"整数に保存する。 引き数の変換は行われない。"

#. type: TP
#: build/C/man3/printf.3:794
#, no-wrap
msgid "B<m>"
msgstr "B<m>"

#. type: Plain text
#: build/C/man3/printf.3:800
msgid ""
"(Glibc extension.)  Print output of I<strerror(errno)>.  No argument is "
"required."
msgstr ""
"(glibc での拡張)  I<strerror(errno)> の出力を表示する。引き数は必要ない。"

#. type: TP
#: build/C/man3/printf.3:800 build/C/man3/scanf.3:374
#, no-wrap
msgid "B<%>"
msgstr "B<%>"

#. type: Plain text
#: build/C/man3/printf.3:806
msgid ""
"A \\(aq%\\(aq is written.  No argument is converted.  The complete "
"conversion specification is \\(aq%%\\(aq."
msgstr ""
"\\(aq%\\(aq 文字を出力する。変換される引き数は無い。 変換指定全体を書くと \"%"
"%\" となる。"

#. type: Plain text
#: build/C/man3/printf.3:821
msgid ""
"The B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"and B<vsprintf>()  functions conform to C89 and C99.  The B<snprintf>()  and "
"B<vsnprintf>()  functions conform to C99."
msgstr ""
"B<fprintf>(), B<printf>(), B<sprintf>(), B<vprintf>(), B<vfprintf>(), "
"B<vsprintf>()  関数は、C89 と C99 に準拠している。 B<snprintf>()  と "
"B<vsnprintf>()  は C99 に準拠している。"

#. type: Plain text
#: build/C/man3/printf.3:834
msgid ""
"Concerning the return value of B<snprintf>(), SUSv2 and C99 contradict each "
"other: when B<snprintf>()  is called with I<size>=0 then SUSv2 stipulates an "
"unspecified return value less than 1, while C99 allows I<str> to be NULL in "
"this case, and gives the return value (as always)  as the number of "
"characters that would have been written in case the output string has been "
"large enough."
msgstr ""
"B<snprintf>()  の返り値を見ると、 SUSv2 と C99 標準は互いに矛盾している。 "
"SUSv2 では、 B<snprintf>()  が I<size>=0 で呼び出された場合、 1 未満の値を何"
"か返り値とするように規定している。 一方 C99 では、このような場合 I<str> を "
"NULL とし、返り値として (通常通り) 出力バッファが十分な大きさが あった場合に"
"出力されるであろう文字数を返す。"

#. type: Plain text
#: build/C/man3/printf.3:848
msgid ""
"Linux libc4 knows about the five C standard flags.  It knows about the "
"length modifiers B<h>, B<l>, B<L>, and the conversions B<c>, B<d>, B<e>, "
"B<E>, B<f>, B<F>, B<g>, B<G>, B<i>, B<n>, B<o>, B<p>, B<s>, B<u>, B<x>, and "
"B<X>, where B<F> is a synonym for B<f>.  Additionally, it accepts B<D>, "
"B<O>, and B<U> as synonyms for B<ld>, B<lo>, and B<lu>.  (This is bad, and "
"caused serious bugs later, when support for B<%D> disappeared.)  No locale-"
"dependent radix character, no thousands' separator, no NaN or infinity, no "
"\"%m$\" and \"*m$\"."
msgstr ""
"Linux libc4 では、 5 つの C 標準のフラグ、 長さ修飾子 B<h>, B<l>, B<L>、変換 "
"B<c>, B<d>, B<e>, B<E>, B<f>, B<F>, B<g>, B<G>, B<i>, B<n>, B<o>, B<p>, "
"B<s>, B<u>, B<x>, B<X> が使える。 但し B<F> は B<f> と同義である。 また、 "
"B<D>, B<O>, and B<U> を B<ld>, B<lo>, and B<lu> と同じものとして使える (これ"
"はまずい仕様で、 後に B<%D> の対応が打ち切られた時に深刻なバグを 引き起こし"
"た)。ロケール依存の小数点、1000 区切り、 NaN と無限、 \"%m$\" と \"*m$\" は使"
"えない。"

#. type: Plain text
#: build/C/man3/printf.3:859
msgid ""
"Linux libc5 knows about the five C standard flags and the \\(aq flag, "
"locale, \"%m$\" and \"*m$\".  It knows about the length modifiers B<h>, "
"B<l>, B<L>, B<Z>, and B<q>, but accepts B<L> and B<q> both for I<long "
"double> and for I<long long int> (this is a bug).  It no longer recognizes "
"B<F>, B<D>, B<O>, and B<U>, but adds the conversion character B<m>, which "
"outputs I<strerror(errno)>."
msgstr ""
"Linux libc5 では、 5 つの C 標準のフラグと \\(aq フラグ、ロケール、 \"%m$\" "
"と \"*m$\" が使える。 また、長さ修飾子 B<h>, B<l>, B<L>, B<Z>, iand B<q> が使"
"えるが、 B<L> と B<q> は両方とも I<long double> と I<long long int> に対応し"
"ている (これはバグである)。 現在では変換 B<F>, B<D>, B<O>, B<U> は認識されな"
"いが、変換文字 B<m> が追加された。これは I<strerror(errno)> を出力するもので"
"ある。"

#. type: Plain text
#: build/C/man3/printf.3:861
msgid "glibc 2.0 adds conversion characters B<C> and B<S>."
msgstr "glibc 2.0 では、変換文字 B<C> と B<S> が追加された。"

#. type: Plain text
#: build/C/man3/printf.3:864
msgid ""
"glibc 2.1 adds length modifiers B<hh>, B<j>, B<t>, and B<z> and conversion "
"characters B<a> and B<A>."
msgstr ""
"glibc 2.1 では、長さ修飾子 B<hh>, B<j>, B<t>, B<z> と変換文字 B<a>, B<A> が追"
"加された。"

#. type: Plain text
#: build/C/man3/printf.3:867
msgid ""
"glibc 2.2 adds the conversion character B<F> with C99 semantics, and the "
"flag character B<I>."
msgstr ""
"glibc 2.2 では、 C99 で規定された意味での変換文字 B<F> と フラグ文字 B<I> が"
"追加された。"

#. type: Plain text
#: build/C/man3/printf.3:869
msgid "Some programs imprudently rely on code such as the following"
msgstr ""
"テキストを I<buf> に追加するのに、軽率にも次のようなコードを使っているプログ"
"ラムがある。"

#. type: Plain text
#: build/C/man3/printf.3:871
#, no-wrap
msgid "    sprintf(buf, \"%s some further text\", buf);\n"
msgstr "    sprintf(buf, \"%s some further text\", buf);\n"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7075
#. type: Plain text
#: build/C/man3/printf.3:887
msgid ""
"to append text to I<buf>.  However, the standards explicitly note that the "
"results are undefined if source and destination buffers overlap when calling "
"B<sprintf>(), B<snprintf>(), B<vsprintf>(), and B<vsnprintf>().  Depending "
"on the version of B<gcc>(1)  used, and the compiler options employed, calls "
"such as the above will B<not> produce the expected results."
msgstr ""
"しかしながら、標準規格では、 B<sprintf>(), B<snprintf>(), B<vsprintf>(), "
"B<vsnprintf>()  の呼び出しにおいて、コピー元とコピー先のバッファが重なってい"
"た場合の 結果は不定である、と明記されている。 使用する B<gcc>(1)  のバージョ"
"ンや指定したコンパイラのオプション次第では、 上記のような呼び出しで、期待した"
"結果が得られ「ない」ことがある。"

#.  .SH HISTORY
#.  UNIX V7 defines the three routines
#.  .BR printf (),
#.  .BR fprintf (),
#.  .BR sprintf (),
#.  and has the flag \-, the width or precision *, the length modifier l,
#.  and the conversions doxfegcsu, and also D,O,U,X as synonyms for ld,lo,lu,lx.
#.  This is still true for 2.9.1BSD, but 2.10BSD has the flags
#.  #, + and <space> and no longer mentions D,O,U,X.
#.  2.11BSD has
#.  .BR vprintf (),
#.  .BR vfprintf (),
#.  .BR vsprintf (),
#.  and warns not to use D,O,U,X.
#.  4.3BSD Reno has the flag 0, the length modifiers h and L,
#.  and the conversions n, p, E, G, X (with current meaning)
#.  and deprecates D,O,U.
#.  4.4BSD introduces the functions
#.  .BR snprintf ()
#.  and
#.  .BR vsnprintf (),
#.  and the length modifier q.
#.  FreeBSD also has functions
#.  .BR asprintf ()
#.  and
#.  .BR vasprintf (),
#.  that allocate a buffer large enough for
#.  .BR sprintf ().
#.  In glibc there are functions
#.  .BR dprintf ()
#.  and
#.  .BR vdprintf ()
#.  that print to a file descriptor instead of a stream.
#. type: Plain text
#: build/C/man3/printf.3:929
msgid ""
"The glibc implementation of the functions B<snprintf>()  and B<vsnprintf>()  "
"conforms to the C99 standard, that is, behaves as described above, since "
"glibc version 2.1.  Until glibc 2.0.6 they would return -1 when the output "
"was truncated."
msgstr ""
"glibc の B<snprintf>()  と B<vsnprintf>()  の実装は、バージョン 2.1 以降は "
"C99 標準に準拠しており、 上記の通りの動作をする。 glibc 2.0.6 までは、出力が"
"切り詰められた場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/printf.3:946
msgid ""
"Because B<sprintf>()  and B<vsprintf>()  assume an arbitrarily long string, "
"callers must be careful not to overflow the actual space; this is often "
"impossible to assure.  Note that the length of the strings produced is "
"locale-dependent and difficult to predict.  Use B<snprintf>()  and "
"B<vsnprintf>()  instead (or B<asprintf>(3)  and B<vasprintf>(3))."
msgstr ""
"B<sprintf>()  と B<vsprintf>()  は勝手に十分に長い文字列領域があると仮定する"
"ので、呼び出し側は 実際の領域からあふれないように注意しなければならない。 し"
"かし、これを保証することが不可能な場合が多い。 生成される文字列の長さはロケー"
"ル依存であり、予測が難しいことに注意。 代わりに B<snprintf>()  と "
"B<vsnprintf>()  (または B<asprintf>(3)  と B<vasprintf>(3))  を使うこと。"

#. type: Plain text
#: build/C/man3/printf.3:959
msgid ""
"Linux libc4.[45] does not have a B<snprintf>(), but provides a libbsd that "
"contains an B<snprintf>()  equivalent to B<sprintf>(), that is, one that "
"ignores the I<size> argument.  Thus, the use of B<snprintf>()  with early "
"libc4 leads to serious security problems."
msgstr ""
"Linux libc4.[45] には B<snprintf>()  はないが、 libbsd が提供されており、 そ"
"の中には B<sprintf>()  と等価な (つまり I<size> 引き数を無視する)  "
"B<snprintf>()  がある。 したがって、初期の libc4 で B<snprintf>()  を使うと、"
"深刻なセキュリティ問題を引き起こすことがある。"

#.  .PP
#.  Some floating-point conversions under early libc4
#.  caused memory leaks.
#. type: Plain text
#: build/C/man3/printf.3:973
msgid ""
"Code such as B<printf(>I<foo>B<);> often indicates a bug, since I<foo> may "
"contain a % character.  If I<foo> comes from untrusted user input, it may "
"contain B<%n>, causing the B<printf>()  call to write to memory and creating "
"a security hole."
msgstr ""
"B<printf(>I<foo>B<);> のようなコードはしばしばバグを引き起こす。 なぜなら "
"I<foo> に % 文字が含まれてるかもしれないからである。 I<foo> が信頼できない"
"ユーザー入力から作られている場合には、 その中に B<%n> が含まれていることがあ"
"り、 B<printf>()  呼び出し時にメモリへの書き込みが起こり、 セキュリティーホー"
"ルを作ることになるかもしれない。"

#. type: Plain text
#: build/C/man3/printf.3:977
#, fuzzy
#| msgid "To print \\*(Pi to five decimal places:"
msgid "To print I<Pi> to five decimal places:"
msgstr "\\*(Pi を 5 桁で出力する。"

#. type: Plain text
#: build/C/man3/printf.3:983
#, no-wrap
msgid ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"
msgstr ""
"#include E<lt>math.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"pi = %.5f\\en\", 4 * atan(1.0));\n"

#. type: Plain text
#: build/C/man3/printf.3:992
msgid ""
"To print a date and time in the form \"Sunday, July 3, 10:02\", where "
"I<weekday> and I<month> are pointers to strings:"
msgstr ""
"日付と時間を \"Sunday, July 3, 10:02\" の形式で出力する。 (I<weekday> と "
"I<month> は文字列へのポインタである)"

#. type: Plain text
#: build/C/man3/printf.3:998
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, \"%s, %s %d, %.2d:%.2d\\en\",\n"
"\tweekday, month, day, hour, min);\n"

#. type: Plain text
#: build/C/man3/printf.3:1004
msgid ""
"Many countries use the day-month-year order.  Hence, an internationalized "
"version must be able to print the arguments in an order specified by the "
"format:"
msgstr ""
"日 - 月 - 年 の順序で表示を行う国も多い。 従って、国際版では書式で指定された"
"順番で 引き数を表示できなければならない。"

#. type: Plain text
#: build/C/man3/printf.3:1010
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"        weekday, month, day, hour, min);\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"fprintf(stdout, format,\n"
"\tweekday, month, day, hour, min);\n"

#. type: Plain text
#: build/C/man3/printf.3:1017
msgid ""
"where I<format> depends on locale, and may permute the arguments.  With the "
"value:"
msgstr ""
"I<format> はロケールに依存しており、引き数の順番を変えることもできる。 "
"I<format> が"

#. type: Plain text
#: build/C/man3/printf.3:1021
#, no-wrap
msgid "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"
msgstr "\"%1$s, %3$d. %2$s, %4$d:%5$.2d\\en\"\n"

#. type: Plain text
#: build/C/man3/printf.3:1025
msgid "one might obtain \"Sonntag, 3. Juli, 10:02\"."
msgstr "であれば、 \"Sonntag, 3. Juli, 10:02\" という結果になる。"

#. type: Plain text
#: build/C/man3/printf.3:1028
msgid ""
"To allocate a sufficiently large string and print into it (code correct for "
"both glibc 2.0 and glibc 2.1):"
msgstr ""
"十分に大きな文字列領域を確保して、そこにメッセージを格納するには (glibc 2.0 "
"と glibc 2.1 の両方で正しく動作するコード):"

#. type: Plain text
#: build/C/man3/printf.3:1033
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdarg.hE<gt>\n"

#. type: Plain text
#: build/C/man3/printf.3:1041
#, no-wrap
msgid ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n;\n"
"    int size = 100;     /* Guess we need no more than 100 bytes. */\n"
"    char *p, *np;\n"
"    va_list ap;\n"
msgstr ""
"char *\n"
"make_message(const char *fmt, ...)\n"
"{\n"
"    int n;\n"
"    int size = 100;     /* Guess we need no more than 100 bytes. */\n"
"    char *p, *np;\n"
"    va_list ap;\n"

#. type: Plain text
#: build/C/man3/printf.3:1044
#, no-wrap
msgid ""
"    if ((p = malloc(size)) == NULL)\n"
"        return NULL;\n"
msgstr ""
"    if ((p = malloc(size)) == NULL)\n"
"        return NULL;\n"

#. type: Plain text
#: build/C/man3/printf.3:1046
#, no-wrap
msgid "    while (1) {\n"
msgstr "    while (1) {\n"

#. type: Plain text
#: build/C/man3/printf.3:1048
#, no-wrap
msgid "        /* Try to print in the allocated space. */\n"
msgstr "        /* Try to print in the allocated space. */\n"

#. type: Plain text
#: build/C/man3/printf.3:1052
#, no-wrap
msgid ""
"        va_start(ap, fmt);\n"
"        n = vsnprintf(p, size, fmt, ap);\n"
"        va_end(ap);\n"
msgstr ""
"        va_start(ap, fmt);\n"
"        n = vsnprintf(p, size, fmt, ap);\n"
"        va_end(ap);\n"

#. type: Plain text
#: build/C/man3/printf.3:1054
#, no-wrap
msgid "        /* If that worked, return the string. */\n"
msgstr "        /* If that worked, return the string. */\n"

#. type: Plain text
#: build/C/man3/printf.3:1057
#, no-wrap
msgid ""
"        if (n E<gt> -1 && n E<lt> size)\n"
"            return p;\n"
msgstr ""
"        if (n E<gt> -1 && n E<lt> size)\n"
"            return p;\n"

#. type: Plain text
#: build/C/man3/printf.3:1059
#, no-wrap
msgid "        /* Else try again with more space. */\n"
msgstr "        /* Else try again with more space. */\n"

#. type: Plain text
#: build/C/man3/printf.3:1064
#, no-wrap
msgid ""
"        if (n E<gt> -1)    /* glibc 2.1 */\n"
"            size = n+1; /* precisely what is needed */\n"
"        else           /* glibc 2.0 */\n"
"            size *= 2;  /* twice the old size */\n"
msgstr ""
"        if (n E<gt> -1)    /* glibc 2.1 */\n"
"            size = n+1; /* precisely what is needed */\n"
"        else           /* glibc 2.0 */\n"
"            size *= 2;  /* twice the old size */\n"

#. type: Plain text
#: build/C/man3/printf.3:1073
#, no-wrap
msgid ""
"        if ((np = realloc (p, size)) == NULL) {\n"
"            free(p);\n"
"            return NULL;\n"
"        } else {\n"
"            p = np;\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"        if ((np = realloc (p, size)) == NULL) {\n"
"            free(p);\n"
"            return NULL;\n"
"        } else {\n"
"            p = np;\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/printf.3:1083
msgid ""
"B<printf>(1), B<asprintf>(3), B<dprintf>(3), B<scanf>(3), B<setlocale>(3), "
"B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"
msgstr ""
"B<printf>(1), B<asprintf>(3), B<dprintf>(3), B<scanf>(3), B<setlocale>(3), "
"B<wcrtomb>(3), B<wprintf>(3), B<locale>(5)"

#. type: TH
#: build/C/man3/puts.3:24
#, no-wrap
msgid "PUTS"
msgstr "PUTS"

#. type: Plain text
#: build/C/man3/puts.3:27
msgid "fputc, fputs, putc, putchar, puts - output of characters and strings"
msgstr "fputc, fputs, putc, putchar, puts - 文字と文字列の出力"

#. type: Plain text
#: build/C/man3/puts.3:32
#, no-wrap
msgid "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:34
#, no-wrap
msgid "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int fputs(const char *>I<s>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:36
#, no-wrap
msgid "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"
msgstr "B<int putc(int >I<c>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:38
#, no-wrap
msgid "B<int putchar(int >I<c>B<);>\n"
msgstr "B<int putchar(int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:40
#, no-wrap
msgid "B<int puts(const char *>I<s>B<);>\n"
msgstr "B<int puts(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/puts.3:49
msgid ""
"B<fputc>()  writes the character I<c>, cast to an I<unsigned char>, to "
"I<stream>."
msgstr ""
"B<fputc>()  は、キャラクタ I<c> を I<unsigned char> にキャストし、 I<stream> "
"に書き込む。"

#. type: Plain text
#: build/C/man3/puts.3:56
msgid ""
"B<fputs>()  writes the string I<s> to I<stream>, without its terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""
"B<fputs>()  は、文字列 I<s> を I<stream> に書き込む。 文字列終端の NULL バイ"
"ト (\\(aq\\e0\\(aq) は出力しない。"

#. type: Plain text
#: build/C/man3/puts.3:63
msgid ""
"B<putc>()  is equivalent to B<fputc>()  except that it may be implemented as "
"a macro which evaluates I<stream> more than once."
msgstr ""
"B<putc>()  は、 I<stream> を一度以上評価するマクロとして実装されているかも知"
"れないという点を除き、 B<fputc>()  と同じである。"

#. type: Plain text
#: build/C/man3/puts.3:67
msgid "B<putchar(>I<c>B<);> is equivalent to B<putc(>I<c>B<,>I<stdout>B<).>"
msgstr "B<putchar(>I<c>B<);> は、 B<putc(>I<c>B<,>I<stdout>B<)> と同じである。"

#. type: Plain text
#: build/C/man3/puts.3:74
msgid "B<puts>()  writes the string I<s> and a trailing newline to I<stdout>."
msgstr "B<puts>()  は、文字列 I<s> と改行を I<stdout> に書き込む。"

#. type: Plain text
#: build/C/man3/puts.3:79
msgid ""
"Calls to the functions described here can be mixed with each other and with "
"calls to other output functions from the I<stdio> library for the same "
"output stream."
msgstr ""
"ここで説明された関数はお互いに混在して使用することができ、また、 I<stdio> ラ"
"イブラリに含まれる他の出力関数を同じ出力ストリームに対して 呼び出す事が出来"
"る。"

#. type: Plain text
#: build/C/man3/puts.3:94
msgid ""
"B<fputc>(), B<putc>()  and B<putchar>()  return the character written as an "
"I<unsigned char> cast to an I<int> or B<EOF> on error."
msgstr ""
"B<fputc>(), B<putc>(), B<putchar>()  は I<unsigned char> として書き込まれた文"
"字を I<int> にキャストして返す。 エラーが発生した場合は B<EOF> を返す。"

#. type: Plain text
#: build/C/man3/puts.3:101
msgid ""
"B<puts>()  and B<fputs>()  return a nonnegative number on success, or B<EOF> "
"on error."
msgstr ""
"B<puts>()  と B<fputs>()  は、成功すると負ではない数を、エラーが発生した場合"
"は B<EOF> を返す。"

#. type: Plain text
#: build/C/man3/puts.3:110
msgid ""
"It is not advisable to mix calls to output functions from the I<stdio> "
"library with low-level calls to B<write>(2)  for the file descriptor "
"associated with the same output stream; the results will be undefined and "
"very probably not what you want."
msgstr ""
"I<stdio> ライブラリに含まれる出力関数と、同じ出力ストリームに結びつけられた "
"ファイルディスクリプタに対する B<write>(2)  の低レベル呼び出しを混在して 使用"
"することは賢明ではない。 その結果は定義されておらず、望む結果が得られない可能"
"性が高い。"

#. type: Plain text
#: build/C/man3/puts.3:122
msgid ""
"B<write>(2), B<ferror>(3), B<fopen>(3), B<fputwc>(3), B<fputws>(3), B<fseek>"
"(3), B<fwrite>(3), B<gets>(3), B<putwchar>(3), B<scanf>(3), B<unlocked_stdio>"
"(3)"
msgstr ""
"B<write>(2), B<ferror>(3), B<fopen>(3), B<fputwc>(3), B<fputws>(3), B<fseek>"
"(3), B<fwrite>(3), B<gets>(3), B<putwchar>(3), B<scanf>(3), B<unlocked_stdio>"
"(3)"

#. type: TH
#: build/C/man2/read.2:35
#, no-wrap
msgid "READ"
msgstr "READ"

#. type: Plain text
#: build/C/man2/read.2:38
msgid "read - read from a file descriptor"
msgstr "read - ファイルディスクリプタから読み込む"

#. type: Plain text
#: build/C/man2/read.2:43
#, no-wrap
msgid "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t read(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: build/C/man2/read.2:52
msgid ""
"B<read>()  attempts to read up to I<count> bytes from file descriptor I<fd> "
"into the buffer starting at I<buf>."
msgstr ""
"B<read>()  はファイルディスクリプタ (file descriptor)  I<fd> から最大 "
"I<count> バイトを I<buf> で始まるバッファーへ読み込もうとする。"

#. type: Plain text
#: build/C/man2/read.2:63
msgid ""
"If I<count> is zero, B<read>()  returns zero and has no other results.  If "
"I<count> is greater than B<SSIZE_MAX>, the result is unspecified."
msgstr ""
"I<count> が 0 ならば、 B<read>()  は 0 を返し、他に何も起きない。 I<count> "
"が B<SSIZE_MAX> より大きければ、結果は特定できない。"

#. type: Plain text
#: build/C/man2/read.2:77
msgid ""
"On success, the number of bytes read is returned (zero indicates end of "
"file), and the file position is advanced by this number.  It is not an error "
"if this number is smaller than the number of bytes requested; this may "
"happen for example because fewer bytes are actually available right now "
"(maybe because we were close to end-of-file, or because we are reading from "
"a pipe, or from a terminal), or because B<read>()  was interrupted by a "
"signal.  On error, -1 is returned, and I<errno> is set appropriately.  In "
"this case it is left unspecified whether the file position (if any) changes."
msgstr ""
"成功した場合、読み込んだバイト数を返す (0 はファイルの終りを意味する)。 ファ"
"イル位置はこの数だけ進められる。 この数が要求した数より小さかったとしてもエ"
"ラーではない; 例えば今すぐには実際にそれだけの数しかない場合 (ファイルの最後"
"に近いのかも しれないし、パイプ (pipe) や端末 (terminal) から読み込んでいるか"
"もしれない) や B<read>()  がシグナル (signal) によって割り込まれた場合にこれ"
"は起こりえる。 エラーの場合は、-1 が返され、 I<errno> が適切に設定される。こ"
"の場合はファイル位置が変更されるかどうかは 不定である。"

#. type: TP
#: build/C/man2/read.2:78 build/C/man3/scanf.3:546 build/C/man2/write.2:108
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/read.2:85
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the read would block."
msgstr ""
"ファイルディスクリプタ I<fd> がソケット以外のファイルを参照していて、 非停止 "
"(nonblocking) モード (B<O_NONBLOCK>)  に設定されており、読み込みを行うと停止"
"する状況にある。"

#. type: TP
#: build/C/man2/read.2:85 build/C/man2/write.2:115
#, no-wrap
msgid "B<EAGAIN> or B<EWOULDBLOCK>"
msgstr "B<EAGAIN> または B<EWOULDBLOCK>"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/read.2:96
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the read would block.  POSIX.1-2001 allows either error "
"to be returned for this case, and does not require these constants to have "
"the same value, so a portable application should check for both "
"possibilities."
msgstr ""
"ファイルディスクリプタ I<fd> がソケットを参照していて、非停止 (nonblocking) "
"モード (B<O_NONBLOCK>)  に設定されており、読み込みを行うと停止する状況にあ"
"る。 POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めており、 これ"
"ら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性が必要なア"
"プリケーションでは、両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/read.2:100
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""
"I<fd> が有効なファイルディスクリプタでないか、読み込みのために オープン "
"(open) されていない。"

#. type: Plain text
#: build/C/man2/read.2:104 build/C/man2/write.2:139
msgid "I<buf> is outside your accessible address space."
msgstr "I<buf> がアクセス可能なアドレス空間の外にある。"

#. type: Plain text
#: build/C/man2/read.2:108
msgid ""
"The call was interrupted by a signal before any data was read; see B<signal>"
"(7)."
msgstr ""
"何のデータも読み込まないうちにシグナルに割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/read.2:119
msgid ""
"I<fd> is attached to an object which is unsuitable for reading; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the current file offset is not "
"suitably aligned."
msgstr ""
"I<fd> は読み込みに適していないオブジェクトを参照している。 もしくは、ファイル"
"が B<O_DIRECT> フラグを指定してオープンされているが、 I<buf> に指定されたアド"
"レス、 I<count> に指定された値、 現在のファイルオフセットのいずれかの アライ"
"ンメントが不適切である。"

#. type: Plain text
#: build/C/man2/read.2:129
msgid ""
"I<fd> was created via a call to B<timerfd_create>(2)  and the wrong size "
"buffer was given to B<read>(); see B<timerfd_create>(2)  for further "
"information."
msgstr ""
"I<fd> が B<timerfd_create>(2)  の呼び出しで作成されたが、 B<read>()  に間違っ"
"たサイズのバッファが渡された。 さらなる情報は B<timerfd_create>(2)  を参照の"
"こと。"

#. type: Plain text
#: build/C/man2/read.2:140
msgid ""
"I/O error.  This will happen for example when the process is in a background "
"process group, tries to read from its controlling tty, and either it is "
"ignoring or blocking B<SIGTTIN> or its process group is orphaned.  It may "
"also occur when there is a low-level I/O error while reading from a disk or "
"tape."
msgstr ""
"I/O エラー。これは例えばプロセスがバックグランド・プロセスグループで、 それを"
"制御している tty から読み込もうとし、 B<SIGTTIN> が無視 (ignore) または禁止 "
"(blocking) されている場合や、 そのプロセスグループが孤立 (orphan) している場"
"合に起こる。 またディスクやテープを読んでいる時に低レベル I/O エラー が発生し"
"た場合にも起こる。"

#. type: Plain text
#: build/C/man2/read.2:144
msgid "I<fd> refers to a directory."
msgstr "I<fd> がディレクトリを参照している。"

#. type: Plain text
#: build/C/man2/read.2:155
msgid ""
"Other errors may occur, depending on the object connected to I<fd>.  POSIX "
"allows a B<read>()  that is interrupted after reading some data to return -1 "
"(with I<errno> set to B<EINTR>)  or to return the number of bytes already "
"read."
msgstr ""
"I<fd> が接続しているオブジェクトによっては他のエラーも起こりえる。 POSIX で"
"は、 いくらかのデータを読んだ後に割り込みが起こった場合、 B<read>()  は "
"(I<errno> に B<EINTR> を設定して) -1 を返してもよいし、 既に読み込んだバイト"
"数を返してもよい。"

#. type: Plain text
#: build/C/man2/read.2:169
msgid ""
"On NFS file systems, reading small amounts of data will only update the "
"timestamp the first time, subsequent calls may not do so.  This is caused by "
"client side attribute caching, because most if not all NFS clients leave "
"st_atime (last file access time)  updates to the server and client side "
"reads satisfied from the client's cache will not cause st_atime updates on "
"the server as there are no server side reads.  UNIX semantics can be "
"obtained by disabling client side attribute caching, but in most situations "
"this will substantially increase server load and decrease performance."
msgstr ""
"NFS において。少量のデータを読み込む場合、最初の時のみにタイム スタンプが更新"
"され、続くコールでは更新されないだろう。 これはクライアント側で属性のキャッシ"
"ングを行なうためである。 なぜならば、もし全ての NFS クライアントが st_atime "
"(最終ファイルアクセス時刻)  の更新をサーバーに送らず、クライアント側でキャッ"
"シュを読むことに満足して いれば、サーバー側での read は発生しないので "
"st_atime の更新は行なわれからだ。 UNIX の方式では、クライアント側の属性の"
"キャッシングを無効にすることで、 これを得ることができる。しかしほとんどの状況"
"ではこれは続くサーバーの 負荷を増加させ、パフォーマンスの低下をもたらす。"

#. type: Plain text
#: build/C/man2/read.2:178
msgid ""
"Many file systems and disks were considered to be fast enough that the "
"implementation of B<O_NONBLOCK> was deemed unnecessary.  So, B<O_NONBLOCK> "
"may not be available on files and/or disks."
msgstr ""
"多くのファイルシステムやディスクは B<O_NONBLOCK> の実装はしなくても済むくらい"
"に十分に高速であると考えられている。 それでそのようなファイルやディスクには "
"B<O_NONBLOCK> は利用できないかもしれない。"

#. type: Plain text
#: build/C/man2/read.2:191
msgid ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"
msgstr ""
"B<close>(2), B<fcntl>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), B<pread>(2), "
"B<readdir>(2), B<readlink>(2), B<readv>(2), B<select>(2), B<write>(2), "
"B<fread>(3)"

#. type: TH
#: build/C/man2/readlink.2:41
#, no-wrap
msgid "READLINK"
msgstr "READLINK"

#. type: TH
#: build/C/man2/readlink.2:41
#, no-wrap
msgid "2011-09-20"
msgstr "2011-09-20"

#. type: Plain text
#: build/C/man2/readlink.2:44
msgid "readlink - read value of a symbolic link"
msgstr "readlink - シンボリックリンクの値を読む"

#. type: Plain text
#: build/C/man2/readlink.2:48
msgid ""
"B<ssize_t readlink(const char *>I<path>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>"
msgstr ""
"B<ssize_t readlink(const char *>I<path>B<, char *>I<buf>B<, size_t "
">I<bufsiz>B<);>"

#. type: Plain text
#: build/C/man2/readlink.2:56
msgid "B<readlink>():"
msgstr "B<readlink>():"

#. type: Plain text
#: build/C/man2/readlink.2:59 build/C/man2/symlink.2:50
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/readlink.2:75
msgid ""
"B<readlink>()  places the contents of the symbolic link I<path> in the "
"buffer I<buf>, which has size I<bufsiz>.  B<readlink>()  does not append a "
"null byte to I<buf>.  It will truncate the contents (to a length of "
"I<bufsiz> characters), in case the buffer is too small to hold all of the "
"contents."
msgstr ""
"B<readlink>()  は I<path> で与えられたシンボリックリンクの内容を I<buf> バッ"
"ファーへ格納する、 I<buf> のサイズは I<bufsiz> である。 B<readlink>()  は "
"NULL バイトを I<buf> に追加しない。 その内容全てを格納するのにバッファーが小"
"さ過ぎる場合は、 (I<bufsiz> バイトの長さに) 内容を切り詰める。"

#. type: Plain text
#: build/C/man2/readlink.2:83
msgid ""
"On success, B<readlink>()  returns the number of bytes placed in I<buf>.  On "
"error, -1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<readlink>()  は I<buf> に格納されたバイト数を返す。 エラーの場"
"合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/readlink.2:89
msgid ""
"Search permission is denied for a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"パスのディレクトリ部分に検索許可が与えられていない (B<path_resolution>(7)  も"
"参照すること)。"

#. type: Plain text
#: build/C/man2/readlink.2:93
msgid "I<buf> extends outside the process's allocated address space."
msgstr "I<buf> がプロセスに割り当てられたアドレス空間の外を指している。"

#.  At the glibc level, bufsiz is unsigned, so this error can only occur
#.  if bufsiz==0.  However, the in the kernel syscall, bufsiz is signed,
#.  and this error can also occur if bufsiz < 0.
#.  See: http://thread.gmane.org/gmane.linux.man/380
#.  Subject: [patch 0/3] [RFC] kernel/glibc mismatch of "readlink" syscall?
#. type: Plain text
#: build/C/man2/readlink.2:102
msgid "I<bufsiz> is not positive."
msgstr "I<bufsiz> が正でない。"

#. type: Plain text
#: build/C/man2/readlink.2:105
msgid "The named file is not a symbolic link."
msgstr "指定したファイルがシンボリックリンクでない。"

#. type: Plain text
#: build/C/man2/readlink.2:108
msgid "An I/O error occurred while reading from the file system."
msgstr "ファイルシステムの読み込み中に I/O エラーが起こった。"

#. type: Plain text
#: build/C/man2/readlink.2:111
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr "パス名にシンボリックリンクが多すぎる。"

#. type: Plain text
#: build/C/man2/readlink.2:114
msgid "A pathname, or a component of a pathname, was too long."
msgstr "パス名かパス名の一部分が長過ぎる。"

#. type: Plain text
#: build/C/man2/readlink.2:117
msgid "The named file does not exist."
msgstr "その名前のファイルが存在しない。"

#. type: Plain text
#: build/C/man2/readlink.2:123
msgid "A component of the path prefix is not a directory."
msgstr "パスのディレクトリ部分がディレクトリでない。"

#. type: Plain text
#: build/C/man2/readlink.2:128
msgid "4.4BSD (B<readlink>()  first appeared in 4.2BSD), POSIX.1-2001."
msgstr "4.4BSD (B<readlink>()  は 4.2BSD で初めて登場した), POSIX.1-2001."

#. type: Plain text
#: build/C/man2/readlink.2:136
msgid ""
"In versions of glibc up to and including glibc 2.4, the return type of "
"B<readlink>()  was declared as I<int>.  Nowadays, the return type is "
"declared as I<ssize_t>, as (newly) required in POSIX.1-2001."
msgstr ""
"バージョン 2.4 以前の glibc (バージョン 2.4 を含む) では、 B<readlink>()  の"
"返り値の型は I<int> で宣言されていた。現在では、返り値の型は I<ssize_t> であ"
"る (返り値 I<ssize_t> は POSIX.1-2001 で (新たに) 必須となった)。"

#. type: Plain text
#: build/C/man2/readlink.2:155
msgid ""
"Using a statically sized buffer might not provide enough room for the "
"symbolic link contents.  The required size for the buffer can be obtained "
"from the I<stat.st_size> value returned by a call to B<lstat>(2)  on the "
"link.  However, the number of bytes written by B<readlink>()  should be "
"checked to make sure that the size of the symbolic link did not increase "
"between the calls.  Dynamically allocating the buffer for B<readlink>()  "
"also addresses a common portability problem when using I<PATH_MAX> for the "
"buffer size, as this constant is not guaranteed to be defined per POSIX if "
"the system does not have such limit."
msgstr ""
"静的な大きさのバッファを使うと、シンボリックリンクの内容を\n"
"格納するのに十分な領域がない場合がある。\n"
"バッファに必要なサイズは、そのシンボリックリンクに対して B<lstat>(2)\n"
"の呼び出しで返される I<stat.st_size> の値から取得できる。\n"
"ただし、 B<readlink>() が書き込んだバイト数をチェックして、\n"
"シンボリックリンクのサイズが B<lstat>(2) と B<readlink>() の呼び出し\n"
"の間で増えていないことを確認すべきである。\n"
"B<readlink>() 用のバッファを動的に割り当てる方法でも、\n"
"バッファサイズとして I<PATH_MAX> を使用する場合に共通する移植性の\n"
"問題を解決することができる。なぜなら、POSIX では、\n"
"システムがそのような上限値を定義していない場合には、\n"
"I<PATH_MAX> が定義されることが保証されていないからである。"

#. type: Plain text
#: build/C/man2/readlink.2:161
msgid ""
"The following program allocates the buffer needed by B<readlink>()  "
"dynamically from the information provided by B<lstat>(), making sure there's "
"no race condition between the calls."
msgstr ""
"以下のプログラムは、 B<readlink>() が必要とするバッファを、\n"
"B<lstat>() が提供する情報に基づいて動的に割り当てる。\n"
"また、両方の呼び出し間で競合条件がないことを保証している。"

#. type: Plain text
#: build/C/man2/readlink.2:168
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/readlink.2:175
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *linkname;\n"
"    ssize_t r;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
"    char *linkname;\n"
"    ssize_t r;\n"

#. type: Plain text
#: build/C/man2/readlink.2:180
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:185
#, no-wrap
msgid ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (lstat(argv[1], &sb) == -1) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:191
#, no-wrap
msgid ""
"    linkname = malloc(sb.st_size + 1);\n"
"    if (linkname == NULL) {\n"
"        fprintf(stderr, \"insufficient memory\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    linkname = malloc(sb.st_size + 1);\n"
"    if (linkname == NULL) {\n"
"        fprintf(stderr, \"insufficient memory\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:193
#, no-wrap
msgid "    r = readlink(argv[1], linkname, sb.st_size + 1);\n"
msgstr "    r = readlink(argv[1], linkname, sb.st_size + 1);\n"

#. type: Plain text
#: build/C/man2/readlink.2:198
#, no-wrap
msgid ""
"    if (r E<lt> 0) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (r E<lt> 0) {\n"
"        perror(\"lstat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:204
#, no-wrap
msgid ""
"    if (r E<gt> sb.st_size) {\n"
"        fprintf(stderr, \"symlink increased in size \"\n"
"                        \"between lstat() and readlink()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (r E<gt> sb.st_size) {\n"
"        fprintf(stderr, \"symlink increased in size \"\n"
"                        \"between lstat() and readlink()\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/readlink.2:206
#, no-wrap
msgid "    linkname[sb.st_size] = \\(aq\\e0\\(aq;\n"
msgstr "    linkname[sb.st_size] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man2/readlink.2:208
#, no-wrap
msgid "    printf(\"\\(aq%s\\(aq points to \\(aq%s\\(aq\\en\", argv[1], linkname);\n"
msgstr "    printf(\"\\(aq%s\\(aq points to \\(aq%s\\(aq\\en\", argv[1], linkname);\n"

#. type: Plain text
#: build/C/man2/readlink.2:220
msgid ""
"B<readlink>(1), B<lstat>(2), B<readlinkat>(2), B<stat>(2), B<symlink>(2), "
"B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<readlink>(1), B<lstat>(2), B<readlinkat>(2), B<stat>(2), B<symlink>(2),\n"
"B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/readv.2:30
#, no-wrap
msgid "READV"
msgstr "READV"

#. type: TH
#: build/C/man2/readv.2:30
#, no-wrap
msgid "2010-11-17"
msgstr "2010-11-17"

#. type: Plain text
#: build/C/man2/readv.2:33
msgid ""
"readv, writev, preadv, pwritev - read or write data into multiple buffers"
msgstr "readv, writev, preadv, pwritev - 複数のバッファへの読み書きを行なう"

#. type: Plain text
#: build/C/man2/readv.2:36
#, no-wrap
msgid "B<#include E<lt>sys/uio.hE<gt>>\n"
msgstr "B<#include E<lt>sys/uio.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/readv.2:38
#, no-wrap
msgid "B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"
msgstr "B<ssize_t readv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:40
#, no-wrap
msgid "B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"
msgstr "B<ssize_t writev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:43
#, no-wrap
msgid ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t preadv(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<               off_t >I<offset>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:46
#, no-wrap
msgid ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"
msgstr ""
"B<ssize_t pwritev(int >I<fd>B<, const struct iovec *>I<iov>B<, int >I<iovcnt>B<,>\n"
"B<                off_t >I<offset>B<);>\n"

#. type: Plain text
#: build/C/man2/readv.2:56
msgid "B<preadv>(), B<pwritev>(): _BSD_SOURCE"
msgstr "B<preadv>(), B<pwritev>(): _BSD_SOURCE"

#. type: Plain text
#: build/C/man2/readv.2:66
msgid ""
"The B<readv>()  system call reads I<iovcnt> buffers from the file associated "
"with the file descriptor I<fd> into the buffers described by I<iov> "
"(\"scatter input\")."
msgstr ""
"B<readv>() システムコールは、ファイルディスクリプタ I<fd> に関連付けられた\n"
"ファイルから、 I<iovcnt> 個のバッファ分のデータを読み込み、 I<iov> で指定\n"
"されたバッファに格納する (\"scatter input\";「ばらまき入力」)。"

#. type: Plain text
#: build/C/man2/readv.2:76
msgid ""
"The B<writev>()  system call writes I<iovcnt> buffers of data described by "
"I<iov> to the file associated with the file descriptor I<fd> (\"gather output"
"\")."
msgstr ""
"B<writev>() システムコールは、 I<iov> で指定されたバッファから最大 "
"I<iovcnt>\n"
"個のバッファ分のデータを取り出し、 ファイルディスクリプタ I<fd> に関連付け"
"ら\n"
"れたファイルに書き込む (\"gather output\";「かき集め出力」)。"

#. type: Plain text
#: build/C/man2/readv.2:85
msgid ""
"The pointer I<iov> points to an array of I<iovec> structures, defined in "
"I<E<lt>sys/uio.hE<gt>> as:"
msgstr ""
"ポインタ I<iov> は I<iovec> 構造体の配列へのポインタである。 I<iovec> 構造体"
"は I<E<lt>sys/uio.hE<gt>> で以下のように定義されている:"

#. type: Plain text
#: build/C/man2/readv.2:93
#, no-wrap
msgid ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"
msgstr ""
"struct iovec {\n"
"    void  *iov_base;    /* Starting address */\n"
"    size_t iov_len;     /* Number of bytes to transfer */\n"
"};\n"

#. type: Plain text
#: build/C/man2/readv.2:101
msgid ""
"The B<readv>()  system call works just like B<read>(2)  except that multiple "
"buffers are filled."
msgstr ""
"B<readv>() システムコールは、複数のバッファにデータを読み込む点を除いて\n"
"B<read>(2) と全く同様の動作を行う。"

#. type: Plain text
#: build/C/man2/readv.2:107
msgid ""
"The B<writev>()  system call works just like B<write>(2)  except that "
"multiple buffers are written out."
msgstr ""
"B<writev>() システムコールは、複数のバッファのデータを書き出す点以外は\n"
"B<write>(2) と全く同様の動作を行う。"

#. type: Plain text
#: build/C/man2/readv.2:126
msgid ""
"Buffers are processed in array order.  This means that B<readv>()  "
"completely fills I<iov>[0] before proceeding to I<iov>[1], and so on.  (If "
"there is insufficient data, then not all buffers pointed to by I<iov> may be "
"filled.)  Similarly, B<writev>()  writes out the entire contents of I<iov>"
"[0] before proceeding to I<iov>[1], and so on."
msgstr ""
"バッファは配列の順序で処理される。これは、 B<readv>()  が I<iov>[0] が完全に"
"一杯になるまでデータを詰めてから、 I<iov>[1] などに進むことを意味する (データ"
"が十分ない場合は、 I<iov> が指すバッファのいずれも一杯にならない)。 同様に、 "
"B<writev>()  は I<iov>[0] の内容を全部書き出してから I<iov>[1] などに進む。"

#. type: Plain text
#: build/C/man2/readv.2:144
msgid ""
"The data transfers performed by B<readv>()  and B<writev>()  are atomic: the "
"data written by B<writev>()  is written as a single block that is not "
"intermingled with output from writes in other processes (but see B<pipe>(7)  "
"for an exception); analogously, B<readv>()  is guaranteed to read a "
"contiguous block of data from the file, regardless of read operations "
"performed in other threads or processes that have file descriptors referring "
"to the same open file description (see B<open>(2))."
msgstr ""
"B<readv>()  と B<writev>()  によるデータ転送は atomic に行われる。つまり、 "
"B<writev>()  によるデータ書き込みは一つのブロックとして行われ、他のプロセス"
"の write による書き込みと混ざり合うことはない (例外に関しては B<pipe>(7)  を"
"参照のこと)。同様に、 B<readv>()  はファイルから連続するデータブロックが読み"
"出すことが保証され、 同じファイル記述 (file description; B<open>(2)  参照) を"
"参照するファイルディスクリプタを持つ他のスレッドやプロセスが 実行した read 操"
"作の影響を受けることはない。"

#. type: SS
#: build/C/man2/readv.2:144
#, no-wrap
msgid "preadv() and pwritev()"
msgstr "preadv() と pwritev()"

#. type: Plain text
#: build/C/man2/readv.2:157
msgid ""
"The B<preadv>()  system call combines the functionality of B<readv>()  and "
"B<pread>(2).  It performs the same task as B<readv>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the input "
"operation is to be performed."
msgstr ""
"B<preadv>() システムコールは B<readv>() と B<preadv>(2) の機能を\n"
"組み合わせたものである。\n"
"B<readv>() と同じ処理を実行するが、\n"
"4 番目の引き数 I<offset> が追加されており、\n"
"この引き数は入力操作を行うファイルオフセットを指定する。"

#. type: Plain text
#: build/C/man2/readv.2:170
msgid ""
"The B<pwritev>()  system call combines the functionality of B<writev>()  and "
"B<pwrite>(2).  It performs the same task as B<writev>(), but adds a fourth "
"argument, I<offset>, which specifies the file offset at which the output "
"operation is to be performed."
msgstr ""
"B<pwritev>() システムコールは B<writev>() と B<pwrite>(2) の機能を\n"
"組み合わせたものである。\n"
"B<writev>() と同じ処理を実行するが、\n"
"4 番目の引き数 I<offset> が追加されており、\n"
"この引き数は出力操作を行うファイルオフセットを指定する。"

#. type: Plain text
#: build/C/man2/readv.2:175
msgid ""
"The file offset is not changed by these system calls.  The file referred to "
"by I<fd> must be capable of seeking."
msgstr ""
"これらのシステムコールで、ファイルオフセットは変更されない。\n"
"I<fd> が参照するファイルは seek 可能でなければならない。"

#. type: Plain text
#: build/C/man2/readv.2:186
msgid ""
"On success, B<readv>()  and B<preadv>()  return the number of bytes read; "
"B<writev>()  and B<pwritev>()  return the number of bytes written.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<readv>() と B<preadv> は読み込んだバイト数を返し、\n"
"B<writev>() と B<pwritev>()は書き込んだバイト数を返す。\n"
"エラーの場合 -1 を返し、I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/readv.2:198
msgid ""
"The errors are as given for B<read>(2)  and B<write>(2).  Furthermore, "
"B<preadv>()  and B<pwritev>()  can also fail for the same reasons as B<lseek>"
"(2).  Additionally, the following error is defined:"
msgstr ""
"B<read>(2)  や B<write>(2)  と同じエラーが定義されている。\n"
"さらに、 B<preadv>() と B<pwritev>() は B<lseek>(2) と同じ理由でも失敗す"
"る。\n"
"また、追加で以下のエラーが定義されている:"

#. type: Plain text
#: build/C/man2/readv.2:207
msgid ""
"The sum of the I<iov_len> values overflows an I<ssize_t> value.  Or, the "
"vector count I<iovcnt> is less than zero or greater than the permitted "
"maximum."
msgstr ""
"I<iov_len> の合計が I<ssize_t> の範囲をオーバーフローした。もしくは、 ベクタ"
"数 I<iovcnt> が 0 より小さいか許可された最大値よりも大きかった。"

#. type: Plain text
#: build/C/man2/readv.2:212
msgid ""
"B<preadv>()  and B<pwritev>()  first appeared in Linux 2.6.30; library "
"support was added in glibc 2.10."
msgstr ""
"B<preadv>() と B<pwritev>() は Linux 2.6.30 で初めて登場した。\n"
"ライブラリによるサポートは glibc 2.10 で追加された。"

#.  The readv/writev system calls were buggy before Linux 1.3.40.
#.  (Says release.libc.)
#. type: Plain text
#: build/C/man2/readv.2:220
msgid ""
"B<readv>(), B<writev>(): 4.4BSD (these system calls first appeared in "
"4.2BSD), POSIX.1-2001.  Linux libc5 used I<size_t> as the type of the "
"I<iovcnt> argument, and I<int> as the return type."
msgstr ""
"B<readv>(), B<writev>(): \n"
"4.4BSD (これらのシステムコールは 4.2BSD で最初に現われた)、POSIX.1-2001。 \n"
"Linux libc5 では、 I<iovcnt> 引き数の型として I<size_t> を、\n"
"返り値の型として I<int> を使用していた。"

#. type: Plain text
#: build/C/man2/readv.2:224
msgid ""
"B<preadv>(), B<pwritev>(): nonstandard, but present also on the modern BSDs."
msgstr "B<preadv>(), B<pwritev>(): 非標準だが、最近の BSD にも存在する。"

#. type: SS
#: build/C/man2/readv.2:225
#, no-wrap
msgid "Linux Notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/readv.2:256
msgid ""
"POSIX.1-2001 allows an implementation to place a limit on the number of "
"items that can be passed in I<iov>.  An implementation can advertise its "
"limit by defining B<IOV_MAX> in I<E<lt>limits.hE<gt>> or at run time via the "
"return value from I<sysconf(_SC_IOV_MAX)>.  On Linux, the limit advertised "
"by these mechanisms is 1024, which is the true kernel limit.  However, the "
"glibc wrapper functions do some extra work if they detect that the "
"underlying kernel system call failed because this limit was exceeded.  In "
"the case of B<readv>()  the wrapper function allocates a temporary buffer "
"large enough for all of the items specified by I<iov>, passes that buffer in "
"a call to B<read>(2), copies data from the buffer to the locations specified "
"by the I<iov_base> fields of the elements of I<iov>, and then frees the "
"buffer.  The wrapper function for B<writev>()  performs the analogous task "
"using a temporary buffer and a call to B<write>(2)."
msgstr ""
"POSIX.1-2001 では、 I<iov> で渡すことができる要素数に上限を設ける実装が認めら"
"れている。 実装は、 I<E<lt>limits.hE<gt>> の B<IOV_MAX> を定義することや、実"
"行時に I<sysconf(_SC_IOV_MAX)> の返り値経由で、この上限を広告することができ"
"る。 Linux では、この仕組みにより広告される上限は 1024 であり、 この値はカー"
"ネルでの上限そのものである。 一方で、glibc のラッパー関数は、その関数の内部で"
"呼ばれるカーネル システムコールがこの上限を超過して失敗したことを検出する"
"と、 追加の動作をする。 B<readv>()  の場合、ラッパー関数は I<iov> で指定され"
"た全ての要素を格納できる大きさの一時バッファを割り当て、 B<read>(2)  を呼び出"
"す際にそのバッファを渡し、 そのバッファのデータを I<iov> の各要素の "
"I<iov_base> フィールドが指定する場所にコピーしてから、 そのバッファを解放す"
"る。 B<writev>()  のラッパー関数も、同じように一時バッファを使って B<write>"
"(2)  を呼び出す。"

#. type: Plain text
#: build/C/man2/readv.2:263
msgid ""
"It is not advisable to mix calls to B<readv>()  or B<writev>(), which "
"operate on file descriptors, with the functions from the stdio library; the "
"results will be undefined and probably not what you want."
msgstr ""
"ファイルディスクリプタに対する操作を行う B<readv>() や B<writev>() と、\n"
"標準入出力ライブラリの関数をごちゃまぜにして呼ぶのはお薦めしない。\n"
"どんな結果になるかは定義されておらず、おそらく期待する結果は\n"
"得られないだろう。"

#. type: Plain text
#: build/C/man2/readv.2:266
msgid "The following code sample demonstrates the use of B<writev>():"
msgstr "以下のサンプルコードは B<writev>()  の使用方法を示すものである。"

#. type: Plain text
#: build/C/man2/readv.2:273
#, no-wrap
msgid ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"
msgstr ""
"char *str0 = \"hello \";\n"
"char *str1 = \"world\\en\";\n"
"struct iovec iov[2];\n"
"ssize_t nwritten;\n"

#. type: Plain text
#: build/C/man2/readv.2:278
#, no-wrap
msgid ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"
msgstr ""
"iov[0].iov_base = str0;\n"
"iov[0].iov_len = strlen(str0);\n"
"iov[1].iov_base = str1;\n"
"iov[1].iov_len = strlen(str1);\n"

#. type: Plain text
#: build/C/man2/readv.2:280
#, no-wrap
msgid "nwritten = writev(STDOUT_FILENO, iov, 2);\n"
msgstr "nwritten = writev(STDOUT_FILENO, iov, 2);\n"

#. type: Plain text
#: build/C/man2/readv.2:286
msgid "B<pread>(2), B<read>(2), B<write>(2)"
msgstr "B<pread>(2), B<read>(2), B<write>(2)"

#. type: TH
#: build/C/man3/remove.3:31
#, no-wrap
msgid "REMOVE"
msgstr "REMOVE"

#. type: TH
#: build/C/man3/remove.3:31
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: build/C/man3/remove.3:34
msgid "remove - remove a file or directory"
msgstr "remove - ファイルやディレクトリを削除する"

#. type: Plain text
#: build/C/man3/remove.3:38
msgid "B<int remove(const char *>I<pathname>B<);>"
msgstr "B<int remove(const char *>I<pathname>B<);>"

#. type: Plain text
#: build/C/man3/remove.3:46
msgid ""
"B<remove>()  deletes a name from the file system.  It calls B<unlink>(2)  "
"for files, and B<rmdir>(2)  for directories."
msgstr ""
"B<remove>()  はファイルシステムからファイル名を削除する。 ファイルに対しては "
"B<unlink>(2)  を、ディレクトリに対しては B<rmdir>(2)  を呼び出す。"

#. type: Plain text
#: build/C/man3/remove.3:50
msgid ""
"If the removed name was the last link to a file and no processes have the "
"file open, the file is deleted and the space it was using is made available "
"for reuse."
msgstr ""
"もしその名前が ファイルへの最後のリンクで、かつ、どのプロセスもそのファイル"
"を 開いていないなら、ファイルも削除する。ファイルの占めていた 領域は他で使う"
"ことができるようになる。"

#. type: Plain text
#: build/C/man3/remove.3:55
msgid ""
"If the name was the last link to a file, but any processes still have the "
"file open, the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"名前がファイルへの最後のリンクであっても、どこかのプロセスが そのファイルを開"
"いているなら、ファイルの最後のファイル記述子 (file descriptor) が閉じられるま"
"でファイルは存在し続ける。"

#. type: Plain text
#: build/C/man3/remove.3:57
msgid "If the name referred to a symbolic link, the link is removed."
msgstr "名前が指しているのがシンボリックリンクなら、そのリンクを削除する。"

#. type: Plain text
#: build/C/man3/remove.3:60
msgid ""
"If the name referred to a socket, FIFO, or device, the name is removed, but "
"processes which have the object open may continue to use it."
msgstr ""
"名前が指しているのがソケット、FIFO、デバイスの場合、名前は削除されるが、 その"
"ソケットなどを開いているプロセスはそのまま使い続けることができる。"

#. type: Plain text
#: build/C/man3/remove.3:70
msgid "The errors that occur are those for B<unlink>(2)  and B<rmdir>(2)."
msgstr "発生するエラーは B<unlink>(2)  および B<rmdir>(2)  と同じものである。"

#. type: Plain text
#: build/C/man3/remove.3:72
msgid "C89, C99, 4.3BSD, POSIX.1-2001."
msgstr "C89, C99, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/remove.3:78
msgid ""
"Under libc4 and libc5, B<remove>()  was an alias for B<unlink>(2)  (and "
"hence would not remove directories)."
msgstr ""
"libc4 と libc5 においては、 B<remove>()  は B<unlink>(2)  の別名であった "
"(従ってディレクトリを削除できなかった)。"

#. type: Plain text
#: build/C/man3/remove.3:81 build/C/man2/unlink.2:148
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of files which are still being used."
msgstr ""
"NFS プロトコルに内在する問題により、まだ使用中のファイルが想定外に消えてしま"
"うことがありえる。"

#. type: Plain text
#: build/C/man3/remove.3:92
msgid ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"
msgstr ""
"B<rm>(1), B<unlink>(1), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlink>(2), B<mkfifo>(3), B<symlink>(7)"

#. type: TH
#: build/C/man2/rename.2:32
#, no-wrap
msgid "RENAME"
msgstr "RENAME"

#. type: TH
#: build/C/man2/rename.2:32
#, no-wrap
msgid "2009-03-30"
msgstr "2009-03-30"

#. type: Plain text
#: build/C/man2/rename.2:35
msgid "rename - change the name or location of a file"
msgstr "rename - ファイルの名前や位置を変更する"

#. type: Plain text
#: build/C/man2/rename.2:39
msgid "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"
msgstr "B<int rename(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"

#. type: Plain text
#: build/C/man2/rename.2:48
msgid ""
"B<rename>()  renames a file, moving it between directories if required.  Any "
"other hard links to the file (as created using B<link>(2))  are unaffected.  "
"Open file descriptors for I<oldpath> are also unaffected."
msgstr ""
"B<rename>()  はファイルの名前を変更し、必要ならばディレクトリ間の移動を行な"
"う。 そのファイルに対する (B<link>(2)  を使用して作られた) 他のハードリンク "
"(hard link) には影響はない。 オープン済の I<oldpath> に対するファイルディスク"
"リプタにも影響はない。"

#. type: Plain text
#: build/C/man2/rename.2:56
msgid ""
"If I<newpath> already exists it will be atomically replaced (subject to a "
"few conditions; see ERRORS below), so that there is no point at which "
"another process attempting to access I<newpath> will find it missing."
msgstr ""
"I<newpath> が既に存在する場合、それは不可分操作で (atomically) 置き換えられ"
"る (ただし、いくつかの条件がある; 以下の「エラー」のセクションを参照)。 その"
"ため、 I<newpath> にアクセスしようとしている他のプロセスがファイルを見失うこ"
"とはない (訳註: 常にアクセス可能である)。"

#. type: Plain text
#: build/C/man2/rename.2:64
msgid ""
"If I<oldpath> and I<newpath> are existing hard links referring to the same "
"file, then B<rename>()  does nothing, and returns a success status."
msgstr ""
"I<oldpath> と I<newpath> がどちらも既存のハードリンクで、同じファイルを参照し"
"ている場合、 B<rename>()  は何も行わず、ステータスとして成功を返す。"

#. type: Plain text
#: build/C/man2/rename.2:72
msgid ""
"If I<newpath> exists but the operation fails for some reason B<rename>()  "
"guarantees to leave an instance of I<newpath> in place."
msgstr ""
"I<newpath> が存在し、何らかの理由で操作が失敗した場合、 B<rename>()  は "
"I<newpath> の実体を元のまま残すことを保証する。"

#. type: Plain text
#: build/C/man2/rename.2:78
msgid ""
"I<oldpath> can specify a directory.  In this case, I<newpath> must either "
"not exist, or it must specify an empty directory."
msgstr ""
"I<oldpath> にはディレクトリを指定することもできる。 この場合、 I<newpath> は"
"存在しないか、空のディレクトリでなければならない。"

#. type: Plain text
#: build/C/man2/rename.2:85
msgid ""
"However, when overwriting there will probably be a window in which both "
"I<oldpath> and I<newpath> refer to the file being renamed."
msgstr ""
"一方で、上書きを行なう場合は、rename が行なわれるファイルを I<oldpath> と "
"I<newpath> の両方で参照できる瞬間がおそらく存在する。"

#. type: Plain text
#: build/C/man2/rename.2:91
msgid ""
"If I<oldpath> refers to a symbolic link the link is renamed; if I<newpath> "
"refers to a symbolic link the link will be overwritten."
msgstr ""
"I<oldpath> がシンボリックリンク (symbolic link) を参照している場合は、 リンク"
"の名前が変更される。 また、 I<newpath> がシンボリックリンクを参照している場合"
"は、リンクが上書きされる。"

#. type: Plain text
#: build/C/man2/rename.2:116
msgid ""
"Write permission is denied for the directory containing I<oldpath> or "
"I<newpath>, or, search permission is denied for one of the directories in "
"the path prefix of I<oldpath> or I<newpath>, or I<oldpath> is a directory "
"and does not allow write permission (needed to update the I<..> entry).  "
"(See also B<path_resolution>(7).)"
msgstr ""
"I<oldpath> または I<newpath> を含んでいるディレクトリの書き込み許可がない。 "
"または、 I<oldpath> または I<newpath> のディレクトリ部分のどれかに検索許可が"
"ない。 または、 I<oldpath> がディレクトリで (I<..> エントリを更新するのに必要"
"な) 書き込み許可がない (B<path_resolution>(7)  も参照)。"

#. type: TP
#: build/C/man2/rename.2:116 build/C/man2/rmdir.2:55 build/C/man2/unlink.2:71
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/rename.2:133
msgid ""
"The rename fails because I<oldpath> or I<newpath> is a directory that is in "
"use by some process (perhaps as current working directory, or as root "
"directory, or because it was open for reading) or is in use by the system "
"(for example as mount point), while the system considers this an error.  "
"(Note that there is no requirement to return B<EBUSY> in such cases"
"\\(emthere is nothing wrong with doing the rename anyway\\(embut it is "
"allowed to return B<EBUSY> if the system cannot otherwise handle such "
"situations.)"
msgstr ""
"I<oldpath> または I<newpath> がディレクトリで、何らかのプロセスが使用中 (多"
"分、カレントワーキングディレクトリか、ルートディレクトリか、 読み込みのために"
"オープンされているかでろう)  もしくは、システムが使用中 (例えばマウントポイン"
"トである)  であり、システムがこれをエラーであると判断したために rename が失敗"
"した。 (このような場合に B<EBUSY> を返すことは規格では要求されていない点に注"
"意すること。 このような場合に、rename をとにかく実行してみるのは何の問題もな"
"い。 ただし、そのような状況で、システムが他に返すエラーがない場合には "
"B<EBUSY> を返すことが許されている。)"

#. type: Plain text
#: build/C/man2/rename.2:140
msgid ""
"The new pathname contained a path prefix of the old, or, more generally, an "
"attempt was made to make a directory a subdirectory of itself."
msgstr ""
"I<newpath> が I<oldpath> のパス部分を含んでいる。ディレクトリを自分自身のサブ"
"ディレクトリに 変更しようとした場合がほとんどである。"

#. type: Plain text
#: build/C/man2/rename.2:146
msgid "I<newpath> is an existing directory, but I<oldpath> is not a directory."
msgstr ""
"I<newpath> は存在しているディレクトリであるが、 I<oldpath> はディレクトリでな"
"い。"

#. type: Plain text
#: build/C/man2/rename.2:157
msgid ""
"I<oldpath> already has the maximum number of links to it, or it was a "
"directory and the directory containing I<newpath> has the maximum number of "
"links."
msgstr ""
"I<oldpath> は既に最大数までのリンクを持っているか、それがディレクトリで "
"I<newpath> を含んでいるディレクトリが最大数までのリンクを持っている。"

#. type: Plain text
#: build/C/man2/rename.2:173
msgid ""
"The link named by I<oldpath> does not exist; or, a directory component in "
"I<newpath> does not exist; or, I<oldpath> or I<newpath> is an empty string."
msgstr ""
"I<oldpath> という名前のリンクが存在しない。 または、 I<newpath> というディレ"
"クトリが存在しない。 または、 I<oldpath> か I<newpath> が空の文字列である。"

#. type: Plain text
#: build/C/man2/rename.2:190
msgid ""
"A component used as a directory in I<oldpath> or I<newpath> is not, in fact, "
"a directory.  Or, I<oldpath> is a directory, and I<newpath> exists but is "
"not a directory."
msgstr ""
"I<oldpath> か I<newpath> に含まれているディレクトリ部分が 実際にはディレクト"
"リでない。 または I<oldpath> がディレクトリで、 I<newpath> が存在してディレク"
"トリでない。"

#. type: TP
#: build/C/man2/rename.2:190
#, no-wrap
msgid "B<ENOTEMPTY> or B<EEXIST>"
msgstr "B<ENOTEMPTY  または  EEXIST>"

#. type: Plain text
#: build/C/man2/rename.2:194
msgid ""
"I<newpath> is a nonempty directory, that is, contains entries other than \"."
"\" and \"..\"."
msgstr ""
"I<newpath> が空でないディレクトリである。すなわち \".\" と \"..\" 以外を含ん"
"でいる。"

#. type: TP
#: build/C/man2/rename.2:194 build/C/man2/unlink.2:126
#, no-wrap
msgid "B<EPERM> or B<EACCES>"
msgstr "B<EPERM> または B<EACCES>"

#. type: Plain text
#: build/C/man2/rename.2:218
msgid ""
"The directory containing I<oldpath> has the sticky bit (B<S_ISVTX>)  set and "
"the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability); or "
"I<newpath> is an existing file and the directory containing it has the "
"sticky bit set and the process's effective user ID is neither the user ID of "
"the file to be replaced nor that of the directory containing it, and the "
"process is not privileged (Linux: does not have the B<CAP_FOWNER> "
"capability); or the file system containing I<pathname> does not support "
"renaming of the type requested."
msgstr ""
"I<oldpath> のあるディレクトリにスティッキービット (sticky bit)  "
"(B<S_ISVTX>)  が設定されており、 プロセスの実効ユーザー ID が 削除しようとす"
"るファイルのユーザー ID と そのファイルを含むディレクトリのユーザー ID のいず"
"れとも一致せず、かつ プロセスに特権がない (Linux では B<CAP_FOWNER> ケーパビ"
"リティ (capability) がない)。 または、 I<newpath> がすでに存在するファイル"
"で、親ディレクトリにスティッキービットが設定されており、 プロセスの実効ユー"
"ザー ID が 置き換えようとするファイルのユーザー ID と そのファイルを含むディ"
"レクトリのユーザー ID のいずれとも一致せず、かつ プロセスに特権がない (Linux "
"では B<CAP_FOWNER> ケーパビリティがない)。 または I<oldpath> と I<newpath> が"
"存在するファイルシステムが、要求された種類の名前の変更を サポートしていない。"

#. type: Plain text
#: build/C/man2/rename.2:229
msgid ""
"I<oldpath> and I<newpath> are not on the same mounted file system.  (Linux "
"permits a file system to be mounted at multiple points, but B<rename>()  "
"does not work across different mount points, even if the same file system is "
"mounted on both.)"
msgstr ""
"I<oldpath> と I<newpath> が同じマウントされたファイルシステムに存在しない。 "
"(Linux は 1 つのファイルシステムを複数のマウント位置に マウントすることを許可"
"している。 しかし B<rename>()  は、たとえ同じファイルシステムであっても、 "
"別々のマウント位置を跨いでは動作しない。)"

#. type: Plain text
#: build/C/man2/rename.2:231
msgid "4.3BSD, C89, C99, POSIX.1-2001."
msgstr "4.3BSD, C89, C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/rename.2:242
msgid ""
"On NFS file systems, you can not assume that if the operation failed the "
"file was not renamed.  If the server does the rename operation and then "
"crashes, the retransmitted RPC which will be processed when the server is up "
"again causes a failure.  The application is expected to deal with this.  See "
"B<link>(2)  for a similar problem."
msgstr ""
"NFS ファイルシステムでは、操作が失敗したからといって、 ファイルの名前が変更で"
"きなかったと決めてかかることはできない。 サーバが rename 操作を終えてからク"
"ラッシュした場合、 サーバが再び立ち上がったときに、 再送信された RPC が処理さ"
"れるが、これは失敗となる。 アプリケーションはこの問題を正しく取り扱うことが期"
"待されている。 同様の問題について B<link>(2)  にも書かれている。"

#. type: Plain text
#: build/C/man2/rename.2:251
msgid ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<renameat>(2), B<symlink>(2), B<unlink>"
"(2), B<path_resolution>(7), B<symlink>(7)"
msgstr ""
"B<mv>(1), B<chmod>(2), B<link>(2), B<renameat>(2), B<symlink>(2), B<unlink>"
"(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/rmdir.2:30
#, no-wrap
msgid "RMDIR"
msgstr "RMDIR"

#. type: TH
#: build/C/man2/rmdir.2:30
#, no-wrap
msgid "2008-05-08"
msgstr "2008-05-08"

#. type: Plain text
#: build/C/man2/rmdir.2:33
msgid "rmdir - delete a directory"
msgstr "rmdir - ディレクトリを削除する"

#. type: Plain text
#: build/C/man2/rmdir.2:37
msgid "B<int rmdir(const char *>I<pathname>B<);>"
msgstr "B<int rmdir(const char *>I<pathname>B<);>"

#. type: Plain text
#: build/C/man2/rmdir.2:40
msgid "B<rmdir>()  deletes a directory, which must be empty."
msgstr ""
"B<rmdir>()  はディレクトリを削除する。削除するディレクトリは空でなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/rmdir.2:55
msgid ""
"Write access to the directory containing I<pathname> was not allowed, or one "
"of the directories in the path prefix of I<pathname> did not allow search "
"permission.  (See also B<path_resolution>(7)."
msgstr ""
"I<pathname> を含んでいるディレクトリへの書き込みアクセスが プロセスの実効 "
"(effective) UID に対して許可されていないか、 I<pathname> に含まれているディレ"
"クトリのどれかに検索 (実行) 許可がないか、 I<pathname> に至るまでのディレクト"
"リのいずれかに対する検索許可がなかった。 (B<path_resolution>(7)  も参照のこ"
"と)"

#. type: Plain text
#: build/C/man2/rmdir.2:64
msgid ""
"I<pathname> is currently in use by the system or some process that prevents "
"its removal.  On Linux this means I<pathname> is currently used as a mount "
"point or is the root directory of the calling process."
msgstr ""
"I<pathname> がシステムや別のプロセスにより使用中で削除することができない。 "
"Linux では、 I<pathname> がマウントポイントとして使用されているか、 呼び出し"
"たプロセスのルートディレクトリであることを意味する。"

#. type: Plain text
#: build/C/man2/rmdir.2:73
msgid "I<pathname> has I<.> as last component."
msgstr "I<pathname> の最後のディレクトリ部分が I<.> である。"

#. type: Plain text
#: build/C/man2/rmdir.2:77
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr "I<pathname> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/rmdir.2:85
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> の中のディレクトリ部分が存在しないか、壊れた (dangling)  シンボ"
"リックリンク (symbolic link) である。"

#. type: Plain text
#: build/C/man2/rmdir.2:94
msgid ""
"I<pathname>, or a component used as a directory in I<pathname>, is not, in "
"fact, a directory."
msgstr ""
"I<pathname> か I<pathname> に含まれているディレクトリ部分が、実際には、ディレ"
"クトリでない。"

#. type: TP
#: build/C/man2/rmdir.2:94
#, no-wrap
msgid "B<ENOTEMPTY>"
msgstr "B<ENOTEMPTY>"

#. type: Plain text
#: build/C/man2/rmdir.2:107
msgid ""
"I<pathname> contains entries other than I<.> and I<..> ; or, I<pathname> has "
"I<..> as its final component.  POSIX.1-2001 also allows B<EEXIST> for this "
"condition."
msgstr ""
"ディレクトリ I<pathname> に I<.> と I<..> 以外のエントリがある。または、 "
"I<pathname> を構成する最後の要素が I<..> である。 POSIX.1-2001 は、この状況"
"で B<EEXIST> を返すことを認めている。"

#. type: Plain text
#: build/C/man2/rmdir.2:118
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective user ID is neither the user ID of the file to be "
"deleted nor that of the directory containing it, and the process is not "
"privileged (Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"I<pathname> を含んでいるディレクトリにスティッキービット(sticky-bit)  "
"(B<S_ISVTX>)  が設定されていて、プロセスの実効ユーザーID が削除しようとする"
"ファイルの ユーザID とそのファイルを含むディレクトリのユーザーID のどちらとも"
"異なり、 プロセスも権限 (Linux では B<CAP_FOWNER> ケーパビリティ) がない。"

#. type: Plain text
#: build/C/man2/rmdir.2:123
msgid ""
"The file system containing I<pathname> does not support the removal of "
"directories."
msgstr ""
"I<pathname> を含んでいるファイルシステムがディレクトリの 削除をサポートしてい"
"ない。"

#. type: Plain text
#: build/C/man2/rmdir.2:127
msgid "I<pathname> refers to a directory on a read-only file system."
msgstr ""
"I<pathname> が読み込み専用のファイルシステム上のディレクトリを参照している。"

#. type: Plain text
#: build/C/man2/rmdir.2:132
msgid ""
"Infelicities in the protocol underlying NFS can cause the unexpected "
"disappearance of directories which are still being used."
msgstr ""
"NFS プロトコルに潜在している欠陥によって、まだ使用中のディレクトリが 突然消滅"
"する現象が引き起こされることがある。"

#. type: Plain text
#: build/C/man2/rmdir.2:141
msgid ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"
msgstr ""
"B<rm>(1), B<rmdir>(1), B<chdir>(2), B<chmod>(2), B<mkdir>(2), B<rename>(2), "
"B<unlink>(2), B<unlinkat>(2)"

#. type: TH
#: build/C/man3/scanf.3:50
#, no-wrap
msgid "SCANF"
msgstr "SCANF"

#. type: Plain text
#: build/C/man3/scanf.3:53
msgid ""
"scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - input format conversion"
msgstr "scanf, fscanf, sscanf, vscanf, vsscanf, vfscanf - 書式付き入力変換"

#. type: Plain text
#: build/C/man3/scanf.3:60
#, no-wrap
msgid ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"
msgstr ""
"B<int scanf(const char *>I<format>B<, ...);>\n"
"B<int fscanf(FILE *>I<stream>B<, const char *>I<format>B<, ...);>\n"
"B<int sscanf(const char *>I<str>B<, const char *>I<format>B<, ...);>\n"

#. type: Plain text
#: build/C/man3/scanf.3:62
#, no-wrap
msgid "B<#include E<lt>stdarg.hE<gt>>\n"
msgstr "B<#include E<lt>stdarg.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/scanf.3:66
#, no-wrap
msgid ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
msgstr ""
"B<int vscanf(const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vsscanf(const char *>I<str>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"
"B<int vfscanf(FILE *>I<stream>B<, const char *>I<format>B<, va_list >I<ap>B<);>\n"

#. type: Plain text
#: build/C/man3/scanf.3:77
msgid "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"
msgstr "B<vscanf>(), B<vsscanf>(), B<vfscanf>():"

#. type: Plain text
#: build/C/man3/scanf.3:80
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 600 || _ISOC99_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200112L;"

#. type: Plain text
#: build/C/man3/scanf.3:102
msgid ""
"The B<scanf>()  family of functions scans input according to I<format> as "
"described below.  This format may contain I<conversion specifications>; the "
"results from such conversions, if any, are stored in the locations pointed "
"to by the I<pointer> arguments that follow I<format>.  Each I<pointer> "
"argument must be of a type that is appropriate for the value returned by the "
"corresponding conversion specification."
msgstr ""
"B<scanf>()  関数グループは、以下に述べるように、 I<format> に従って入力を読み"
"込むものである。 この書式には I<「変換指定」 (conversion specifications)> を"
"含めることができ、変換指定があれば、その変換の結果は I<format> に続く "
"I<pointer> 引き数が指す場所に格納される。 それぞれの I<pointer> 引き数の型"
"は、対応する変換指定が返す値に 適合していなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:113
msgid ""
"If the number of conversion specifications in I<format> exceeds the number "
"of I<pointer> arguments, the results are undefined.  If the number of "
"I<pointer> arguments exceeds the number of conversion specifications, then "
"the excess I<pointer> arguments are evaluated, but are otherwise ignored."
msgstr ""
"I<format> 中の変換指定の個数が I<pointer> 引き数の数より多かった場合の結果は"
"未定義である。 I<pointer> 引き数の数が変換指定の個数よりも多かった場合、 余分"
"な I<pointer> 引き数の評価は行われるが、それ以外は行われず無視される。"

#. type: Plain text
#: build/C/man3/scanf.3:125
msgid ""
"The B<scanf>()  function reads input from the standard input stream "
"I<stdin>, B<fscanf>()  reads input from the stream pointer I<stream>, and "
"B<sscanf>()  reads its input from the character string pointed to by I<str>."
msgstr ""
"B<scanf>()  関数は標準入力ストリーム I<stdin> からの入力を読み込む。 "
"B<fscanf>()  はストリームポインタ I<stream> からの入力を読み込む。 B<sscanf>"
"()  は文字列ポインタ I<str> で示された文字列からの入力を読み込む。"

#. type: Plain text
#: build/C/man3/scanf.3:143
msgid ""
"The B<vfscanf>()  function is analogous to B<vfprintf>(3)  and reads input "
"from the stream pointer I<stream> using a variable argument list of pointers "
"(see B<stdarg>(3).  The B<vscanf>()  function scans a variable argument list "
"from the standard input and the B<vsscanf>()  function scans it from a "
"string; these are analogous to the B<vprintf>(3)  and B<vsprintf>(3)  "
"functions respectively."
msgstr ""
"B<vfscanf>()  関数は B<vfprintf>(3)  と同様に、ストリームポインタ I<stream> "
"からの入力をポインタの可変長引き数リストを用いて読み込む (B<stdarg>(3)  を参"
"照)。 B<vscanf>()  関数は、可変長引き数のリストに基づき標準入力からの読み取り"
"を行う。 B<vsscanf>()  関数はそのリストに基づき文字列から読み取る。 これらの"
"関係は B<vprintf>(3)  と B<vsprintf>(3)  関数の関係と同様である。"

#. type: Plain text
#: build/C/man3/scanf.3:157
msgid ""
"The I<format> string consists of a sequence of I<directives> which describe "
"how to process the sequence of input characters.  If processing of a "
"directive fails, no further input is read, and B<scanf>()  returns.  A "
"\"failure\" can be either of the following: I<input failure>, meaning that "
"input characters were unavailable, or I<matching failure>, meaning that the "
"input was inappropriate (see below)."
msgstr ""
"I<format> 文字列は I<「命令」 (directive)> の列で構成される。命令は入力文字の"
"系列をどのように処理するかを指示する ものである。ある命令の処理が失敗すると、"
"入力はそれ以上読み込まれず、 B<scanf>()  は返る。「失敗」は I<「入力の失敗」 "
"(input failure)> と I<「一致の失敗」 (matching failure)> のいずれかである。 "
"入力の失敗は入力文字が使用できなかったことを意味し、 一致の失敗は入力が不適切"
"であったこと (下記参照) を意味する。"

#. type: Plain text
#: build/C/man3/scanf.3:159
msgid "A directive is one of the following:"
msgstr "命令は以下のいずれかである:"

#. type: TP
#: build/C/man3/scanf.3:159 build/C/man3/scanf.3:165 build/C/man3/scanf.3:169
#: build/C/man3/scanf.3:188 build/C/man3/scanf.3:199 build/C/man3/scanf.3:217
#: build/C/man3/scanf.3:229 build/C/man3/scanf.3:243
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man3/scanf.3:165
msgid ""
"A sequence of white-space characters (space, tab, newline, etc.; see "
"B<isspace>(3)).  This directive matches any amount of white space, including "
"none, in the input."
msgstr ""
"ホワイトスペース (スペース、タブ、改行など; B<isspace>(3)  参照) の列。 この"
"命令は、入力中の任意の個数のホワイトスペースに一致する。 (「何もなし」にも一"
"致する)。"

#. type: Plain text
#: build/C/man3/scanf.3:169
msgid ""
"An ordinary character (i.e., one other than white space or \\(aq%\\(aq).  "
"This character must exactly match the next character of input."
msgstr ""
"通常文字 (つまり、ホワイトスペースと \\(aq%\\(aq 以外の文字)。 この文字は入力"
"の次の文字に正確に一致しなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:180
msgid ""
"A conversion specification, which commences with a \\(aq%\\(aq (percent) "
"character.  A sequence of characters from the input is converted according "
"to this specification, and the result is placed in the corresponding "
"I<pointer> argument.  If the next item of input does not match the "
"conversion specification, the conversion fails\\(emthis is a I<matching "
"failure>."
msgstr ""
"変換指定。変換指定は \\(aq%\\(aq (パーセント) 文字で始まる。 入力された文字の"
"系列はこの指定にもとづいて変換され、 変換結果は対応する I<pointer> 引き数が指"
"す場所に格納される。 入力の次の文字が変換指定と一致しない場合は、変換は失敗す"
"る \\(emこれが I<「一致の失敗」 (matching failure)> である。"

#. type: Plain text
#: build/C/man3/scanf.3:188
msgid ""
"Each I<conversion specification> in I<format> begins with either the "
"character \\(aq%\\(aq or the character sequence \"B<%>I<n>B<$>\" (see below "
"for the distinction) followed by:"
msgstr ""
"I<format> 中の各々の I<「変換指定」> は文字 \\(aq%\\(aq か文字系列 \"B<"
"%>I<n>B<$>\" (違いについては後述) で始まり、以下の要素が続く。"

#. type: Plain text
#: build/C/man3/scanf.3:199
msgid ""
"An optional \\(aq*\\(aq assignment-suppression character: B<scanf>()  reads "
"input as directed by the conversion specification, but discards the input.  "
"No corresponding I<pointer> argument is required, and this specification is "
"not included in the count of successful assignments returned by B<scanf>()."
msgstr ""
"代入抑制文字 \\(aq*\\(aq (省略可能)。 B<scanf>()  は変換指定に指示された通り"
"入力を読み込むが、その入力は捨てられる。 対応する I<pointer> 引き数は必要な"
"く、 B<scanf>()  が返す代入が成功した数にこの指定は含まれない。"

#. type: Plain text
#: build/C/man3/scanf.3:217
msgid ""
"An optional \\(aqa\\(aq character.  This is used with string conversions, "
"and relieves the caller of the need to allocate a corresponding buffer to "
"hold the input: instead, B<scanf>()  allocates a buffer of sufficient size, "
"and assigns the address of this buffer to the corresponding I<pointer> "
"argument, which should be a pointer to a I<char *> variable (this variable "
"does not need to be initialized before the call).  The caller should "
"subsequently B<free>(3)  this buffer when it is no longer required.  This is "
"a GNU extension; C99 employs the \\(aqa\\(aq character as a conversion "
"specifier (and it can also be used as such in the GNU implementation)."
msgstr ""
"文字 \\(aqa\\(aq (省略可能)。これは文字列変換とともに使用され、これを使うと "
"呼び出し元が入力を保持する対応するバッファを確保する必要がなくなる。 代わり"
"に B<scanf>()  が必要な大きさのバッファを確保し、このバッファのアドレスを 対"
"応する I<pointer> 引き数に代入する。 I<pointer> 引き数は I<char *> 型の変数へ"
"のポインタでなければならない (変数自体は呼び出し前に初期化されている必要はな"
"い)。 呼び出し元は、不要になった時点で、このバッファを B<free>(3)  すべきであ"
"る。この機能は GNU による拡張である。 C99 は \\(aqa\\(aq 文字を変換指定として"
"使用している (こちらも GNU の実装と同じように使用することができる)。"

#. type: Plain text
#: build/C/man3/scanf.3:229
msgid ""
"An optional decimal integer which specifies the I<maximum field width>.  "
"Reading of characters stops either when this maximum is reached or when a "
"nonmatching character is found, whichever happens first.  Most conversions "
"discard initial white space characters (the exceptions are noted below), and "
"these discarded characters don't count toward the maximum field width.  "
"String input conversions store a terminating null byte (\\(aq\\e0\\(aq)  to "
"mark the end of the input; the maximum field width does not include this "
"terminator."
msgstr ""
"I<「最大フィールド幅」> を指定する 10進数 (省略可能)。 この最大値に達するか、"
"一致しない文字が見つかるか、のどちらかに なると、文字の読み込みを停止する。 "
"ほとんどの変換では、先頭のホワイトスペース文字は捨てられ (例外については後述"
"する)、 捨てられたこれらの文字は最大フィールド幅の計算には含まれない。 文字列"
"の入力変換では、入力の末尾を示す終端の NULL バイト (\\(aq\\e0\\(aq)  も格納さ"
"れるが、最大フィールド幅にはこの終端バイトは含まれない。"

#. type: Plain text
#: build/C/man3/scanf.3:243
msgid ""
"An optional I<type modifier character>.  For example, the B<l> type modifier "
"is used with integer conversions such as B<%d> to specify that the "
"corresponding I<pointer> argument refers to a I<long int> rather than a "
"pointer to an I<int>."
msgstr ""
"I<「型修飾子」 (type modifier characters)> (省略可能)。 例えば、型修飾子 "
"B<l> を B<%d> などの整数変換と一緒に使うと、対応する I<pointer> 引き数が "
"I<int> ではなく I<long int> を参照していることを指定できる。"

#. type: Plain text
#: build/C/man3/scanf.3:248
msgid ""
"A I<conversion specifier> that specifies the type of input conversion to be "
"performed."
msgstr "I<「変換指定」> : 実行すべき入力変換の種類を指定する。"

#. type: Plain text
#: build/C/man3/scanf.3:277
msgid ""
"The conversion specifications in I<format> are of two forms, either "
"beginning with \\(aq%\\(aq or beginning with \"B<%>I<n>B<$>\".  The two "
"forms should not be mixed in the same I<format> string, except that a string "
"containing \"B<%>I<n>B<$>\" specifications can include B<%%> and B<%*>.  If "
"I<format> contains \\(aq%\\(aq specifications then these correspond in order "
"with successive I<pointer> arguments.  In the \"B<%>I<n>B<$>\" form (which "
"is specified in POSIX.1-2001, but not C99), I<n> is a decimal integer that "
"specifies that the converted input should be placed in the location referred "
"to by the I<n>-th I<pointer> argument following I<format>."
msgstr ""
"I<format> 中の変換指定は、\\(aq%\\(aq で始まるか、 \"B<%>I<n>B<$>\" で始まる"
"かの、いずれかの形式である。 これら 2つの形式を同じ I<format> 文字列に混ぜる"
"ことはできない。但し、\"B<%>I<n>B<$>\" を 含む文字列に B<%%> と B<%*> を含め"
"ることはできる。 I<format> に \\(aq%\\(aq 指定が含まれている場合、各々の "
"\\(aq%\\(aq 指定と 後続の I<pointer> 引き数はその順番通りに対応する。 \"B<"
"%>I<n>B<$>\" 形式 (POSIX.1-2001 では規定されているが、C99 にはない)  では、 "
"I<n> は 10進数であり、変換後の入力を I<format> の後ろの I<n> 番目の "
"I<pointer> 引き数が参照する場所に格納することを指定する。"

#. type: SS
#: build/C/man3/scanf.3:277
#, no-wrap
msgid "Conversions"
msgstr "変換"

#. type: Plain text
#: build/C/man3/scanf.3:281
msgid ""
"The following I<type modifier characters> can appear in a conversion "
"specification:"
msgstr "変換指定には、以下の I<「型修飾子」> を入れることができる。"

#. type: Plain text
#: build/C/man3/scanf.3:291
msgid ""
"Indicates that the conversion will be one of B<d>, B<i>, B<o>, B<u>, B<x>, "
"B<X>, or B<n> and the next pointer is a pointer to a I<short int> or "
"I<unsigned short int> (rather than I<int>)."
msgstr ""
"変換が B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, B<n> のいずれかであり、次のポイン"
"タが (I<int> ではなく)  I<short int> か I<unsigned short int> へのポインタで"
"あることを示す。"

#. type: Plain text
#: build/C/man3/scanf.3:299
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<signed char> or "
"I<unsigned char>."
msgstr ""
"B<h> と同じだが、次のポインタが I<signed char> か I<unsigned char> へのポイン"
"タであることを示す。"

#. type: Plain text
#: build/C/man3/scanf.3:308
msgid ""
"As for B<h>, but the next pointer is a pointer to an I<intmax_t> or a "
"I<uintmax_t>.  This modifier was introduced in C99."
msgstr ""
"B<h> と同じだが、次のポインタが I<intmax_t> か I<uintmax_t> へのポインタであ"
"ることを示す。 この修飾子は C99 で導入された。"

#.  This use of l was introduced in Amendment 1 to ISO C90.
#. type: Plain text
#: build/C/man3/scanf.3:335
msgid ""
"Indicates either that the conversion will be one of B<d>, B<i>, B<o>, B<u>, "
"B<x>, B<X>, or B<n> and the next pointer is a pointer to a I<long int> or "
"I<unsigned long int> (rather than I<int>), or that the conversion will be "
"one of B<e>, B<f>, or B<g> and the next pointer is a pointer to I<double> "
"(rather than I<float>).  Specifying two B<l> characters is equivalent to "
"B<L>.  If used with B<%c> or B<%s> the corresponding parameter is considered "
"as a pointer to a wide character or wide-character string respectively."
msgstr ""
"変換が B<d>, B<i>, B<o>, B<u>, B<x>, B<X>, B<n> か B<n> のいずれかであり次の"
"ポインタが (I<int> ではなく)  I<long int> か I<unsigned long int> へのポイン"
"タであること、または、変換が B<e>, B<f>, B<g> のうちのひとつであり次のポイン"
"タが (I<float> ではなく)  I<double> へのポインタであることのいずれかであるこ"
"とを示す。 B<l> 文字を二つ指定すると、 B<L> と同じ意味となる。 B<%c> や B<"
"%s> とともに使用すると、 パラメータはそれぞれワイド文字やワイド文字列へのポイ"
"ンタであると みなされる。"

#.  MTK, Jul 05: The following is no longer true for modern
#.  ANSI C (i.e., C99):
#.  (Note that long long is not an
#.  ANSI C
#.  type. Any program using this will not be portable to all
#.  architectures).
#. type: Plain text
#: build/C/man3/scanf.3:351
msgid ""
"Indicates that the conversion will be either B<e>, B<f>, or B<g> and the "
"next pointer is a pointer to I<long double> or the conversion will be B<d>, "
"B<i>, B<o>, B<u>, or B<x> and the next pointer is a pointer to I<long long>."
msgstr ""
"B<e>, B<f>, B<g> 変換で、次のポインタが I<long double> へのポインタであること"
"を示す。もしくは、 B<d>, B<i>, B<o>, B<u>, B<x> 変換で、次のポインタが "
"I<long long> へのポインタであることのいずれかであることを示す。"

#. type: Plain text
#: build/C/man3/scanf.3:356
msgid "equivalent to B<L>.  This specifier does not exist in ANSI C."
msgstr "B<L> と同一である。 この修飾子は ANSI C には存在しない。"

#. type: Plain text
#: build/C/man3/scanf.3:363
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<ptrdiff_t>.  This "
"modifier was introduced in C99."
msgstr ""
"B<h> と同様だが、次のポインタが I<ptrdiff_t> へのポインタであることを示す。 "
"この修飾子は C99 で導入された。"

#. type: Plain text
#: build/C/man3/scanf.3:370
msgid ""
"As for B<h>, but the next pointer is a pointer to a I<size_t>.  This "
"modifier was introduced in C99."
msgstr ""
"B<h> と同様だが、次のポインタが I<size_t> へのポインタであることを示す。 この"
"修飾子は C99 で導入された。"

#. type: Plain text
#: build/C/man3/scanf.3:374
msgid "The following I<conversion specifiers> are available:"
msgstr "以下の I<「変換指定子」> が利用可能である。"

#. type: Plain text
#: build/C/man3/scanf.3:383
msgid ""
"Matches a literal \\(aq%\\(aq.  That is, B<%\\&%> in the format string "
"matches a single input \\(aq%\\(aq character.  No conversion is done (but "
"initial white space characters are discarded), and assignment does not occur."
msgstr ""
"文字 \\(aq%\\(aq に対応する。 書式文字列の中の B<%\\&%> は単一の文字 \\(aq%"
"\\(aq に対応する。 変換は行われず (但し、先頭のホワイトスペース文字は捨てられ"
"る)、 変数への代入は生じない。"

#. type: TP
#: build/C/man3/scanf.3:383
#, no-wrap
msgid "B<d>"
msgstr "B<d>"

#. type: Plain text
#: build/C/man3/scanf.3:388
msgid ""
"Matches an optionally signed decimal integer; the next pointer must be a "
"pointer to I<int>."
msgstr ""
"符号つきの 10進の整数に対応する。 次のポインタは I<int> へのポインタでなけれ"
"ばならない。"

#. type: TP
#: build/C/man3/scanf.3:388
#, no-wrap
msgid "B<D>"
msgstr "B<D>"

#. type: Plain text
#: build/C/man3/scanf.3:397
msgid ""
"Equivalent to I<ld>; this exists only for backward compatibility.  (Note: "
"thus only in libc4.  In libc5 and glibc the B<%D> is silently ignored, "
"causing old programs to fail mysteriously.)"
msgstr ""
"I<ld> と同一である。これは以前の仕様との互換性だけのためにある。 (注意: これ"
"は libc4 の場合だけである。 libc5 や glibc では B<%D> は暗黙のうちに無視さ"
"れ、古いプログラムにおいて謎に満ちた失敗の原因となる。)"

#. type: TP
#: build/C/man3/scanf.3:397
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: build/C/man3/scanf.3:409
msgid ""
"Matches an optionally signed integer; the next pointer must be a pointer to "
"I<int>.  The integer is read in base 16 if it begins with I<0x> or I<0X>, in "
"base 8 if it begins with I<0>, and in base 10 otherwise.  Only characters "
"that correspond to the base are used."
msgstr ""
"符号つき整数に対応する。 次のポインタは I<int> へのポインタでなければならな"
"い。 この整数は I<0x> または I<0X> で開始する場合には 16 進数、 I<0> で開始す"
"る場合には 8 進数、その他の場合には 10進数として読み込まれる。 この変換で使用"
"される文字は、これらの基数に対応しているものだけである。"

#. type: TP
#: build/C/man3/scanf.3:409
#, no-wrap
msgid "B<o>"
msgstr "B<o>"

#. type: Plain text
#: build/C/man3/scanf.3:413
msgid ""
"Matches an unsigned octal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"符号なしの 8 進の整数に対応する。 次のポインタは I<unsigned int> でなければな"
"らない。"

#. type: TP
#: build/C/man3/scanf.3:413
#, no-wrap
msgid "B<u>"
msgstr "B<u>"

#. type: Plain text
#: build/C/man3/scanf.3:418
msgid ""
"Matches an unsigned decimal integer; the next pointer must be a pointer to "
"I<unsigned int>."
msgstr ""
"符号なしの 10進の整数に対応する。 次のポインタは I<unsigned int> へのポインタ"
"でなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:423
msgid ""
"Matches an unsigned hexadecimal integer; the next pointer must be a pointer "
"to I<unsigned int>."
msgstr ""
"符号なしの 16 進の整数に対応する。 次のポインタは I<unsigned int> へのポイン"
"タでなければならない。"

#. type: TP
#: build/C/man3/scanf.3:423
#, no-wrap
msgid "B<X>"
msgstr "B<X>"

#. type: Plain text
#: build/C/man3/scanf.3:427
msgid "Equivalent to B<x>."
msgstr "B<x> と同一である。"

#. type: TP
#: build/C/man3/scanf.3:427
#, no-wrap
msgid "B<f>"
msgstr "B<f>"

#. type: Plain text
#: build/C/man3/scanf.3:432
msgid ""
"Matches an optionally signed floating-point number; the next pointer must be "
"a pointer to I<float>."
msgstr ""
"符号つき浮動小数点実数に対応する。 次のポインタは I<float> へのポインタでなけ"
"ればならない。"

#. type: TP
#: build/C/man3/scanf.3:432
#, no-wrap
msgid "B<e>"
msgstr "B<e>"

#. type: Plain text
#: build/C/man3/scanf.3:436 build/C/man3/scanf.3:440 build/C/man3/scanf.3:444
msgid "Equivalent to B<f>."
msgstr "B<f> と同一である。"

#. type: TP
#: build/C/man3/scanf.3:436
#, no-wrap
msgid "B<g>"
msgstr "B<g>"

#. type: TP
#: build/C/man3/scanf.3:440
#, no-wrap
msgid "B<E>"
msgstr "B<E>"

#. type: Plain text
#: build/C/man3/scanf.3:448
msgid "(C99) Equivalent to B<f>."
msgstr "(C99)  B<f> と同一である。"

#. type: Plain text
#: build/C/man3/scanf.3:456
msgid ""
"Matches a sequence of non-white-space characters; the next pointer must be a "
"pointer to character array that is long enough to hold the input sequence "
"and the terminating null byte (\\(aq\\e0\\(aq), which is added "
"automatically.  The input string stops at white space or at the maximum "
"field width, whichever occurs first."
msgstr ""
"ホワイトスペースではない文字で構成された文字列に対応する。 次のポインタは文字"
"の配列へのポインタでなければならず、 その文字配列は、入力された文字列と (自動"
"的に追加される) 終端の NULL バイト (\\(aq\\e0\\(aq) を格納するのに十分な大き"
"さでなければならない。 文字列の入力は、ホワイトスペースが入力されるか、最大"
"フィールド幅に 達するか、のどちらかが起こると停止される。"

#. type: Plain text
#: build/C/man3/scanf.3:467
msgid ""
"Matches a sequence of characters whose length is specified by the I<maximum "
"field width> (default 1); the next pointer must be a pointer to I<char>, and "
"there must be enough room for all the characters (no terminating null byte "
"is added).  The usual skip of leading white space is suppressed.  To skip "
"white space first, use an explicit space in the format."
msgstr ""
"I<「最大フィールド幅」> (デフォルトは 1) で指定された幅の文字の列に対応す"
"る。 次のポインタは I<char> へのポインタで、すべての文字を格納するのに十分な"
"領域が なければならない (終端の NULL バイトは追加されない)。 通常行われる先頭"
"のホワイトスペースの読み飛ばしは行われない。 先頭のホワイトスペースを読み飛ば"
"すためには、 フォーマット文の中で明示的にスペースを使用すれば良い。"

#. type: TP
#: build/C/man3/scanf.3:467
#, no-wrap
msgid "B<\\&[>"
msgstr "B<\\&[>"

#. type: Plain text
#: build/C/man3/scanf.3:500
msgid ""
"Matches a nonempty sequence of characters from the specified set of accepted "
"characters; the next pointer must be a pointer to I<char>, and there must be "
"enough room for all the characters in the string, plus a terminating null "
"byte.  The usual skip of leading white space is suppressed.  The string is "
"to be made up of characters in (or not in) a particular set; the set is "
"defined by the characters between the open bracket B<[> character and a "
"close bracket B<]> character.  The set I<excludes> those characters if the "
"first character after the open bracket is a circumflex (B<^>).  To include a "
"close bracket in the set, make it the first character after the open bracket "
"or the circumflex; any other position will end the set.  The hyphen "
"character B<-> is also special; when placed between two other characters, it "
"adds all intervening characters to the set.  To include a hyphen, make it "
"the last character before the final close bracket.  For instance, B<[^]0-9-]"
"> means the set \"everything except close bracket, zero through nine, and "
"hyphen\".  The string ends with the appearance of a character not in the "
"(or, with a circumflex, in) set or when the field width runs out."
msgstr ""
"格納された文字列のうちから取り出された、 指定された文字の集合で構成される空で"
"はない文字の列に対応する。 次のポインタは I<char> へのポインタでなければなら"
"ず、 そこには文字列中のすべての文字と終端の NULL バイト を格納するための十分"
"な領域がなければならない。 通常行われる先頭のホワイトスペースの読み飛ばしは行"
"われない。 この文字列は特別な集合の中の文字で構成されている。 この集合は 開き"
"括弧 B<[> と閉じ括弧 B<]> の間の文字で定義される。 開き括弧のあとの最初の文字"
"が曲アクセント記号 (B<^>)  の場合、集合はこれらの文字を含まないものとなる。 "
"閉じ括弧を集合に含ませるためには、この文字を開き括弧または 曲アクセント記号の"
"あとの最初の文字にすればよい。 つまり、他の位置に閉じ括弧を置くと文字の集合が"
"終る。 ハイフン B<-> もまた特殊文字である。 二つの異なる文字の間に置かれた"
"時、この文字は、 その間にある全ての文字を集合に加える。 ハイフン自体を含ませ"
"るためには、 括弧が閉じる前の最後の一文字をハイフンにすればよい。 例えば、 B<"
"[^]0-9-]> は「閉じ括弧、0 〜 9、ハイフンの 3 種類を除く全ての文字」の集合を意"
"味する。 この文字列は 集合に含まれていない (曲アクセントの場合には含まれる) "
"文字の 出現または確保された領域が使い切られた時に終了する。"

#. type: Plain text
#: build/C/man3/scanf.3:508
msgid ""
"Matches a pointer value (as printed by B<%p> in B<printf>(3); the next "
"pointer must be a pointer to a pointer to I<void>."
msgstr ""
"(B<printf>(3)  の B<%p> で印字されるような) ポインタ値に対応する。 次のポイン"
"タは I<void> へのポインタへのポインタでなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:528
msgid ""
"Nothing is expected; instead, the number of characters consumed thus far "
"from the input is stored through the next pointer, which must be a pointer "
"to I<int>.  This is I<not> a conversion, although it can be suppressed with "
"the B<*> assignment-suppression character.  The C standard says: \"Execution "
"of a B<%n> directive does not increment the assignment count returned at the "
"completion of execution\" but the Corrigendum seems to contradict this.  "
"Probably it is wise not to make any assumptions on the effect of B<%n> "
"conversions on the return value."
msgstr ""
"どんな入力も必要としない。 そのかわりに、 入力からここまで消費された文字数が"
"次のポインタで指定された場所に 格納される。 このポインタは I<int> へのポイン"
"タでなければならない。 変換を抑制するのであれば B<*> 代入抑制文字を使って抑制"
"することができるのだが、 この変換指定子は変換では「ない」。 C 言語の標準規格"
"では「実行の完了時に返される代入の回数は B<%n> 命令の実行では増加しない」と"
"なっているが、 正誤表の内容はこれと矛盾するようである。おそらく、 B<%n> 変換"
"が返り値に与える影響についてはどのような仮定もしないのが 賢明であろう。"

#. type: Plain text
#: build/C/man3/scanf.3:533
msgid ""
"These functions return the number of input items successfully matched and "
"assigned, which can be fewer than provided for, or even zero in the event of "
"an early matching failure."
msgstr ""
"これらの関数は、一致と代入が成功した入力要素の個数を返す。 返される値は渡され"
"た変換の個数よりも少ないこともあり、 最初に一致の失敗があった場合には 0 にな"
"ることもある。"

#. type: Plain text
#: build/C/man3/scanf.3:545
msgid ""
"The value B<EOF> is returned if the end of input is reached before either "
"the first successful conversion or a matching failure occurs.  B<EOF> is "
"also returned if a read error occurs, in which case the error indicator for "
"the stream (see B<ferror>(3))  is set, and I<errno> is set indicate the "
"error."
msgstr ""
"最初の変換が成功する前に入力の最後に達して、一致の失敗が起こった場合には、 "
"B<EOF> が返される。また、 読み込みエラーが発生した場合にも B<EOF> が返され"
"る。読み込みエラーの場合には、そのストリームの エラー指示子がセットされ "
"(B<ferror>(3)  参照)、 I<errno> にエラーを示す値がセットされる。"

#. type: Plain text
#: build/C/man3/scanf.3:551
msgid ""
"The file descriptor underlying I<stream> is marked nonblocking, and the read "
"operation would block."
msgstr ""
"I<stream> に対応するファイルディスクリプタが nonblocking となっており、 読み"
"込み操作は停止 (block) することになる。"

#. type: Plain text
#: build/C/man3/scanf.3:556
msgid ""
"The file descriptor underlying I<stream> is invalid, or not open for reading."
msgstr ""
"I<stream> に対応するファイルディスクリプタが無効であるが、 読み込み用にオープ"
"ンされていない。"

#. type: Plain text
#: build/C/man3/scanf.3:559
msgid "Input byte sequence does not form a valid character."
msgstr "入力されたバイト列が有効な文字を構成していない。"

#. type: Plain text
#: build/C/man3/scanf.3:563
msgid "The read operation was interrupted by a signal; see B<signal>(7)."
msgstr "読み込み操作がシグナルにより割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/scanf.3:568
msgid "Not enough arguments; or I<format> is NULL."
msgstr "引き数が十分でない。または I<format> が NULL である。"

#. type: Plain text
#: build/C/man3/scanf.3:571
msgid "Out of memory."
msgstr "メモリ不足。"

#. type: TP
#: build/C/man3/scanf.3:571
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/scanf.3:575
msgid ""
"The result of an integer conversion would exceed the size that can be stored "
"in the corresponding integer type."
msgstr "整数変換の結果が、対応する整数型に格納できるサイズを越えてしまう。"

#. type: Plain text
#: build/C/man3/scanf.3:585
msgid ""
"The functions B<fscanf>(), B<scanf>(), and B<sscanf>()  conform to C89 and "
"C99 and POSIX.1-2001.  These standards do not specify the B<ERANGE> error."
msgstr ""
"B<fscanf>(), B<scanf>(), B<sscanf>()  関数は C89, C99, POSIX.1-2001 に準拠し"
"ている。 これらの標準では、エラー B<ERANGE> は規定されていない。"

#. type: Plain text
#: build/C/man3/scanf.3:595
msgid ""
"The B<q> specifier is the 4.4BSD notation for I<long long>, while B<ll> or "
"the usage of B<L> in integer conversions is the GNU notation."
msgstr ""
"B<q> 指定子は I<long long> の 4.4BSD での記述方法である。 一方、整数変換での "
"B<ll> または B<L> の使用は GNU での拡張である。"

#. type: Plain text
#: build/C/man3/scanf.3:606
msgid ""
"The Linux version of these functions is based on the I<GNU> I<libio> "
"library.  Take a look at the I<info> documentation of I<GNU> I<libc "
"(glibc-1.08)> for a more concise description."
msgstr ""
"これらの関数の Linux 版は I<GNU> I<libio> ライブラリーを元にしている。 より簡"
"潔な説明には I<GNU> I<libc (glibc-1.08)> の I<info> 文書に目を通すこと。"

#.  This feature seems to be present at least as far back as glibc 2.0.
#. type: Plain text
#: build/C/man3/scanf.3:624
msgid ""
"The GNU C library supports a nonstandard extension that causes the library "
"to dynamically allocate a string of sufficient size for input strings for "
"the B<%s> and B<%a[>I<range>B<]> conversion specifiers.  To make use of this "
"feature, specify B<a> as a length modifier (thus B<%as> or B<%a[>I<range>B<]"
">).  The caller must B<free>(3)  the returned string, as in the following "
"example:"
msgstr ""
"GNU C ライブラリ (glibc) では非標準のオプションをサポートしており、 このオプ"
"ションを使うと変換指定子 B<%s> や B<%a[>I<range>B<]> への入力文字列に対して十"
"分な大きさの文字列をライブラリが動的に確保する ようになる。 この機能を使用す"
"るには、長さ修飾子として B<a> を指定する (したがって、全体としては B<%as> や "
"B<%a[>I<range>B<]> となる)。 以下の例にあるように、呼び出し側は返された文字列"
"を B<free>(3)  しなければならない。"

#. type: Plain text
#: build/C/man3/scanf.3:629
#, no-wrap
msgid ""
"char *p;\n"
"int n;\n"
msgstr ""
"char *p;\n"
"int n;\n"

#. type: Plain text
#: build/C/man3/scanf.3:640
#, no-wrap
msgid ""
"errno = 0;\n"
"n = scanf(\"%a[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"
msgstr ""
"errno = 0;\n"
"n = scanf(\"%a[a-z]\", &p);\n"
"if (n == 1) {\n"
"    printf(\"read: %s\\en\", p);\n"
"    free(p);\n"
"} else if (errno != 0) {\n"
"    perror(\"scanf\");\n"
"} else {\n"
"    fprintf(stderr, \"No matching characters\\en\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/scanf.3:648
msgid ""
"As shown in the above example, it is only necessary to call B<free>(3)  if "
"the B<scanf>()  call successfully read a string."
msgstr ""
"上記の例にあるように、 B<scanf>()  が文字列の読み込みに成功した場合にだけ、 "
"B<free>(3)  を呼び出す必要がある。"

#. type: Plain text
#: build/C/man3/scanf.3:660
msgid ""
"The B<a> modifier is not available if the program is compiled with I<gcc -"
"std=c99> or I<gcc -D_ISOC99_SOURCE> (unless B<_GNU_SOURCE> is also "
"specified), in which case the B<a> is interpreted as a specifier for "
"floating-point numbers (see above)."
msgstr ""
"I<gcc -std=c99> や I<gcc -D_ISOC99_SOURCE> でコンパイルしたプログラムでは "
"(B<_GNU_SOURCE> も同時に指定していない場合)、 B<a> 修飾子は利用できない。 上"
"記の場合、 B<a> は (上述の通り) 浮動小数点数を示す変換指定子と解釈される。"

#. type: Plain text
#: build/C/man3/scanf.3:669
msgid ""
"Since version 2.7, glibc also provides the B<m> modifier for the same "
"purpose as the B<a> modifier.  The B<m> modifier has the following "
"advantages:"
msgstr ""
"バージョン 2.7 以降では、glibc は B<a> 修飾子と同じ目的で B<m> 修飾子も提供し"
"ている。 B<m> 修飾子は以下の利点がある。"

#. type: Plain text
#: build/C/man3/scanf.3:674
msgid "It may also be applied to B<%c> conversion specifiers (e.g., B<%3mc>)."
msgstr "B<%c> 変換指定子にも適用できる (例えば B<%3mc>)。"

#. type: Plain text
#: build/C/man3/scanf.3:680
msgid ""
"It avoids ambiguity with respect to the B<%a> floating-point conversion "
"specifier (and is unaffected by I<gcc -std=c99> etc.)"
msgstr ""
"浮動小数点変換指定子としての B<%a> との紛らわしさが避けられる (また I<gcc -"
"std=c99> などの影響も避けられる)。"

#. type: Plain text
#: build/C/man3/scanf.3:682
msgid "It is specified in the upcoming revision of the POSIX.1 standard."
msgstr "POSIX.1 標準の次の改訂版で規定される。"

#. type: Plain text
#: build/C/man3/scanf.3:695
msgid ""
"All functions are fully C89 conformant, but provide the additional "
"specifiers B<q> and B<a> as well as an additional behavior of the B<L> and "
"B<l> specifiers.  The latter may be considered to be a bug, as it changes "
"the behavior of specifiers defined in C89."
msgstr ""
"全ての関数は、完全に C89 に準拠している。しかし 追加で B<q> と B<a> 指定子が"
"提供されており、同様に B<L> と B<l> 指定子の付加的な振る舞いもある。後者は、 "
"C89 で定義された指定子の振る舞いを変更するものなので、 バグとみなされるかもし"
"れない。"

#. type: Plain text
#: build/C/man3/scanf.3:711
#, fuzzy
#| msgid ""
#| "Some combinations of the type modifiers and conversion specifiers defined "
#| "by ANSI C do not make sense (e.g.  B<%Ld>).  While they may have a well-"
#| "defined behavior on Linux, this need not to be so on other "
#| "architectures.  Therefore it usually is better to use modifiers that are "
#| "not defined by ANSI C at all, that is, use B<q> instead of B<L> in "
#| "combination with B<d>, B<i>, B<o>, B<u>, B<x>, and B<X> conversions or "
#| "B<ll>."
msgid ""
"Some combinations of the type modifiers and conversion specifiers defined by "
"ANSI C do not make sense (e.g., B<%Ld>).  While they may have a well-defined "
"behavior on Linux, this need not to be so on other architectures.  Therefore "
"it usually is better to use modifiers that are not defined by ANSI C at all, "
"that is, use B<q> instead of B<L> in combination with B<d>, B<i>, B<o>, "
"B<u>, B<x>, and B<X> conversions or B<ll>."
msgstr ""
"ANSI C で定義された型修飾子と変換指定子の組み合わせの中には 意味をなさないも"
"のがある (例えば、 B<%Ld>)。 これらが指定された場合、 Linux 上でははっきりと"
"定義された振る舞いをするかもしれないが、 他のアーキテクチャでも同様になってい"
"るとは限らない。 それゆえに、ほとんどの場合、 ANSI C で定義されていない修飾子"
"を使用した方が良い。 すなわち、 B<d>, B<i>, B<o>, B<u>, B<x>, B<X> 変換や "
"B<ll> と組み合わせる場合には、 B<L> の代わりに B<q> を使用した方が良い。"

#. type: Plain text
#: build/C/man3/scanf.3:717
msgid ""
"The usage of B<q> is not the same as on 4.4BSD, as it may be used in float "
"conversions equivalently to B<L>."
msgstr ""
"B<q> の使用方法は 4.4BSD と同じではない。 4.4BSD では B<q> は B<L> と同等に浮"
"動小数の変換に使用される。"

#. type: Plain text
#: build/C/man3/scanf.3:724
msgid ""
"B<getc>(3), B<printf>(3), B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3)"
msgstr ""
"B<getc>(3), B<printf>(3)  B<setlocale>(3), B<strtod>(3), B<strtol>(3), "
"B<strtoul>(3),"

#. type: TH
#: build/C/man3/setbuf.3:46
#, no-wrap
msgid "SETBUF"
msgstr "SETBUF"

#. type: TH
#: build/C/man3/setbuf.3:46
#, no-wrap
msgid "2008-06-26"
msgstr "2008-06-26"

#. type: Plain text
#: build/C/man3/setbuf.3:49
msgid "setbuf, setbuffer, setlinebuf, setvbuf - stream buffering operations"
msgstr ""
"setbuf, setbuffer, setlinebuf, setvbuf - ストリームのバッファリングの操作"

#. type: Plain text
#: build/C/man3/setbuf.3:54
#, no-wrap
msgid "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"
msgstr "B<void setbuf(FILE *>I<stream>B<, char *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:56
#, no-wrap
msgid "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<void setbuffer(FILE *>I<stream>B<, char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:58
#, no-wrap
msgid "B<void setlinebuf(FILE *>I<stream>B<);>\n"
msgstr "B<void setlinebuf(FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:61
#, no-wrap
msgid "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"
msgstr "B<int setvbuf(FILE *>I<stream>B<, char *>I<buf>B<, int >I<mode>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:71
msgid "B<setbuffer>(), B<setlinebuf>(): _BSD_SOURCE"
msgstr "B<setbuffer>(), B<setlinebuf>(): _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/setbuf.3:94
msgid ""
"The three types of buffering available are unbuffered, block buffered, and "
"line buffered.  When an output stream is unbuffered, information appears on "
"the destination file or terminal as soon as written; when it is block "
"buffered many characters are saved up and written as a block; when it is "
"line buffered characters are saved up until a newline is output or input is "
"read from any stream attached to a terminal device (typically I<stdin>).  "
"The function B<fflush>(3)  may be used to force the block out early.  (See "
"B<fclose>(3).)  Normally all files are block buffered.  When the first I/O "
"operation occurs on a file, B<malloc>(3)  is called, and a buffer is "
"obtained.  If a stream refers to a terminal (as I<stdout> normally does) it "
"is line buffered.  The standard error stream I<stderr> is always unbuffered "
"by default."
msgstr ""
"バッファリングには unbuffered, block buffered, line buffered の3つのタイプが "
"ある。出力ストリームのタイプが unbuffered の場合、データを書き込むとすぐに出 "
"力先ファイルに書き込まれるかターミナルに表示される。block buffered の場合、"
"文 字の読み書きはブロック単位でいっぺんに行われる。line buffered の場合、 新"
"しい行が出力されるか、ターミナルデバイスに接続しているストリーム (通常、"
"I<stdin>) から新しい行が入力されるまで文字がたくわえられる。 ブロックを強制的"
"に出力するには B<fflush>(3)  関数を使う。 (B<fclose>(3)  を参照のこと) 通常、"
"ファイルはすべて block buffered である。ファイルに対して 初めて入出力処理を行"
"うと B<malloc>(3)  が呼び出されバッファが獲得される。もし ストリームが (通"
"常、 I<stdout> がそうであるように) ターミナルを参照する場合には、ファイルは "
"line buffered と なる。標準エラー出力 I<stderr> はデフォルトでは常に "
"unbuffered である。"

#. type: Plain text
#: build/C/man3/setbuf.3:101
msgid ""
"The B<setvbuf>()  function may be used on any open stream to change its "
"buffer.  The I<mode> argument must be one of the following three macros:"
msgstr ""
"B<setvbuf>()  関数は、オープンしている任意のストリームに対してバッファを変更"
"できる。 引き数 I<mode> は、次の 3 つのマクロのうちいずれかである:"

#. type: TP
#: build/C/man3/setbuf.3:102
#, no-wrap
msgid "B<_IONBF>"
msgstr "B<_IONBF>"

#. type: Plain text
#: build/C/man3/setbuf.3:105
msgid "unbuffered"
msgstr "unbuffered"

#. type: TP
#: build/C/man3/setbuf.3:105
#, no-wrap
msgid "B<_IOLBF>"
msgstr "B<_IOLBF>"

#. type: Plain text
#: build/C/man3/setbuf.3:108
msgid "line buffered"
msgstr "line buffered"

#. type: TP
#: build/C/man3/setbuf.3:108
#, no-wrap
msgid "B<_IOFBF>"
msgstr "B<_IOFBF>"

#. type: Plain text
#: build/C/man3/setbuf.3:111
msgid "fully buffered"
msgstr "fully buffered"

#. type: Plain text
#: build/C/man3/setbuf.3:127
msgid ""
"Except for unbuffered files, the I<buf> argument should point to a buffer at "
"least I<size> bytes long; this buffer will be used instead of the current "
"buffer.  If the argument I<buf> is NULL, only the mode is affected; a new "
"buffer will be allocated on the next read or write operation.  The B<setvbuf>"
"()  function may only be used after opening a stream and before any other "
"operations have been performed on it."
msgstr ""
"unbuffered のファイルを除き、 I<buf> 引数は I<size> バイト以上の大きさのバッ"
"ファを指していなければならない。このバッファは現在の バッファの代わりに用いら"
"れる。もし、引数 I<buf> が NULL ならば、モードだけが変更される。 新しいバッ"
"ファは次に読み書きした際に割り当てられる。 B<setvbuf>()  関数は、ストリームを"
"オープンした後、 そのストリームに対して何らかの操作をする前にのみ使用できる。"

#. type: Plain text
#: build/C/man3/setbuf.3:133
msgid ""
"The other three calls are, in effect, simply aliases for calls to B<setvbuf>"
"().  The B<setbuf>()  function is exactly equivalent to the call"
msgstr ""
"他の 3 つの関数は B<setvbuf>()  の呼び出しに単純に置き換えることができる。 "
"B<setbuf>()  関数は、"

#. type: Plain text
#: build/C/man3/setbuf.3:136
msgid "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"
msgstr "setvbuf(stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);"

#. type: Plain text
#: build/C/man3/setbuf.3:146
msgid ""
"The B<setbuffer>()  function is the same, except that the size of the buffer "
"is up to the caller, rather than being determined by the default B<BUFSIZ>.  "
"The B<setlinebuf>()  function is exactly equivalent to the call:"
msgstr ""
"と全く同等だし、 B<setbuffer>()  関数は、バッファサイズがデフォルト値 "
"B<BUFSIZ> ではなく引数で与えられる点以外は同じである。 B<setlinebuf>()  関数"
"は以下と同じである。"

#. type: Plain text
#: build/C/man3/setbuf.3:149
msgid "setvbuf(stream, (char *) NULL, _IOLBF, 0);"
msgstr "setvbuf(stream, (char *) NULL, _IOLBF, 0);"

#. type: Plain text
#: build/C/man3/setbuf.3:160
msgid ""
"The function B<setvbuf>()  returns 0 on success.  It returns nonzero on "
"failure (I<mode> is invalid or the request cannot be honored).  It may set "
"I<errno> on failure."
msgstr ""
"B<setvbuf>()  関数は、成功した場合 0 を返す。 失敗した場合、0 以外の値を返す "
"(失敗とは、 I<mode> が不正な場合またはリクエストが条件を満たさない場合であ"
"る)。 B<setvbuf>()  関数が失敗した場合は I<errno> を設定することもある。"

#. type: Plain text
#: build/C/man3/setbuf.3:162
msgid "The other functions do not return a value."
msgstr "その他の関数は値を返さない。"

#. type: Plain text
#: build/C/man3/setbuf.3:168
msgid "The B<setbuf>()  and B<setvbuf>()  functions conform to C89 and C99."
msgstr ""
"B<setbuf>()  関数および B<setvbuf>()  関数は C89 と C99 に準拠している。"

#. type: Plain text
#: build/C/man3/setbuf.3:178
msgid ""
"The B<setbuffer>()  and B<setlinebuf>()  functions are not portable to "
"versions of BSD before 4.2BSD, and are available under Linux since libc "
"4.5.21.  On 4.2BSD and 4.3BSD systems, B<setbuf>()  always uses a suboptimal "
"buffer size and should be avoided."
msgstr ""
"B<setbuffer>()  関数および B<setlinebuf>()  関数は 4.2BSD より前の BSD とは互"
"換性がない。また Linux でも(古いバージョン では)利用できないかもしれない。"
"4.2BSD および 4.3BSD のシステムでは B<setbuf>()  は必ず追加のバッファーのサイ"
"ズを使用するので、これも使うべきでない。"

#. type: Plain text
#: build/C/man3/setbuf.3:185
msgid ""
"You must make sure that the space that I<buf> points to still exists by the "
"time I<stream> is closed, which also happens at program termination.  For "
"example, the following is invalid:"
msgstr ""
"I<stream> を閉じる時 (プログラムを終了する際にもこれは起きる) には、 I<buf> "
"が指し示す空間とが存在していることを保証しなければならない。 例えば、次のよう"
"な使い方は許されない:"

#. type: Plain text
#: build/C/man3/setbuf.3:188
#, no-wrap
msgid "#include E<lt>stdio.hE<gt>\n"
msgstr "#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/setbuf.3:197
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char buf[BUFSIZ];\n"
"    setbuf(stdin, buf);\n"
"    printf(\"Hello, world!\\en\");\n"
"    return 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/setbuf.3:206
msgid ""
"B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), B<malloc>(3), B<printf>"
"(3), B<puts>(3)"
msgstr ""
"B<fclose>(3), B<fflush>(3), B<fopen>(3), B<fread>(3), B<malloc>(3), B<printf>"
"(3), B<puts>(3)"

#. type: TH
#: build/C/man3/stdin.3:9
#, no-wrap
msgid "STDIN"
msgstr "STDIN"

#. type: TH
#: build/C/man3/stdin.3:9 build/C/man3/tmpfile.3:29
#, no-wrap
msgid "2008-07-14"
msgstr "2008-07-14"

#. type: Plain text
#: build/C/man3/stdin.3:12
msgid "stdin, stdout, stderr - standard I/O streams"
msgstr "stdin, stdout, stderr - 標準入出力ストリーム"

#. type: Plain text
#: build/C/man3/stdin.3:19
#, no-wrap
msgid ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"
msgstr ""
"B<extern FILE *>I<stdin>B<;>\n"
"B<extern FILE *>I<stdout>B<;>\n"
"B<extern FILE *>I<stderr>B<;>\n"

#. type: Plain text
#: build/C/man3/stdin.3:31
msgid ""
"Under normal circumstances every UNIX program has three streams opened for "
"it when it starts up, one for input, one for output, and one for printing "
"diagnostic or error messages.  These are typically attached to the user's "
"terminal (see B<tty>(4)  but might instead refer to files or other devices, "
"depending on what the parent process chose to set up.  (See also the "
"\"Redirection\" section of B<sh>(1).)"
msgstr ""
"標準の環境では、 UNIX プログラムは起動時に、オープンされているストリー ムを "
"3 つ与えられる。それぞれ入力用、出力用、診断メッセージやエラーメッ セージの表"
"示用のものである。これらは通常ユーザの端末 (B<tty>(4)  を見よ) に接続されてい"
"るが、親プロセスでの選択・設定によってファイル や他のデバイスに関連づけられて"
"いることもある (B<sh>(1)  の「リダイレクション」セクションも参照のこと)。"

#. type: Plain text
#: build/C/man3/stdin.3:41
msgid ""
"The input stream is referred to as \"standard input\"; the output stream is "
"referred to as \"standard output\"; and the error stream is referred to as "
"\"standard error\".  These terms are abbreviated to form the symbols used to "
"refer to these files, namely I<stdin>, I<stdout>, and I<stderr>."
msgstr ""
"入力ストリームは \"standard input\" と呼ばれる。出力ストリームは \"standard "
"output\"、エラーストリームは \"standard error\" と呼ばれる。 これらの用語を短"
"縮したものがそれぞれのファイルを示すシンボルとなる。つ まり I<stdin>, "
"I<stdout>, I<stderr> である。"

#. type: Plain text
#: build/C/man3/stdin.3:50
msgid ""
"Each of these symbols is a B<stdio>(3)  macro of type pointer to I<FILE>, "
"and can be used with functions like B<fprintf>(3)  or B<fread>(3)."
msgstr ""
"これらのシンボルは B<stdio>(3)  のマクロで、 FILE へのポインタ型である。した"
"がって B<fprintf>(3)  や B<fread>(3)  などの関数とともに用いることができる。"

#. type: Plain text
#: build/C/man3/stdin.3:59
msgid ""
"Since I<FILE>s are a buffering wrapper around UNIX file descriptors, the "
"same underlying files may also be accessed using the raw UNIX file "
"interface, that is, the functions like B<read>(2)  and B<lseek>(2)."
msgstr ""
"I<FILE> は UNIX のファイルディスクリプタにバッファ機能を追加したラッパー であ"
"るから、これらのマクロにも対応するファイルがあり、 UNIX の raw ファ イルイン"
"タフェース (B<read>(2)  や B<lseek>(2)  など) によってアクセスすることもでき"
"る。"

#. type: Plain text
#: build/C/man3/stdin.3:78
msgid ""
"On program startup, the integer file descriptors associated with the streams "
"I<stdin>, I<stdout>, and I<stderr> are 0, 1, and 2, respectively.  The "
"preprocessor symbols B<STDIN_FILENO>, B<STDOUT_FILENO>, and B<STDERR_FILENO> "
"are defined with these values in I<E<lt>unistd.hE<gt>>.  (Applying B<freopen>"
"(3)  to one of these streams can change the file descriptor number "
"associated with the stream.)"
msgstr ""
"プログラムの起動時には、 ストリーム I<stdin>, I<stdout>, I<stderr> に結びつけ"
"られているファイルディスクリプタの番号は、 それぞれ 0, 1, 2 である。 プリプロ"
"セッサシンボル B<STDIN_FILENO>, B<STDOUT_FILENO>, B<STDERR_FILENO> は "
"I<E<lt>unistd.hE<gt>> 中でそれぞれこれらの値に定義されている。 (これらのスト"
"リームに対して B<freopen>(3)  を適用することで、そのストリームに関連付けられ"
"たファイルディスクリプタ の番号を変更することができる。)"

#. type: Plain text
#: build/C/man3/stdin.3:91
msgid ""
"Note that mixing use of I<FILE>s and raw file descriptors can produce "
"unexpected results and should generally be avoided.  (For the masochistic "
"among you: POSIX.1, section 8.2.3, describes in detail how this interaction "
"is supposed to work.)  A general rule is that file descriptors are handled "
"in the kernel, while stdio is just a library.  This means for example, that "
"after an B<exec>(3), the child inherits all open file descriptors, but all "
"old streams have become inaccessible."
msgstr ""
"I<FILE> と raw なファイルディスクリプタの併用は、予期できない結果を生じ るこ"
"とがあるので、通常は避けるべきである。 (マゾヒスティックな人に: POSIX.1 のセ"
"クション 8.2.3 には、この混用で動作がどのようになりそう かが詳しく記述されて"
"いる。)  一般的なルールは以下の通り: ファイルディスクリプタはカーネルによっ"
"て 扱われ、 stdio は単にライブラリによって扱われるのである。すなわち例えば "
"B<exec>(3)  の後には、子プロセスはオープンされているファイルディスクリプタ を"
"すべて継承するが、親からのストリームはすべてアクセス不可となる。"

#. type: Plain text
#: build/C/man3/stdin.3:109
msgid ""
"Since the symbols I<stdin>, I<stdout>, and I<stderr> are specified to be "
"macros, assigning to them is nonportable.  The standard streams can be made "
"to refer to different files with help of the library function B<freopen>(3), "
"specially introduced to make it possible to reassign I<stdin>, I<stdout>, "
"and I<stderr>.  The standard streams are closed by a call to B<exit>(3)  and "
"by normal program termination."
msgstr ""
"シンボル I<stdin>, I<stdout>, I<stderr> はすべてマクロとして定義されているの"
"で、これらへの代入 は移植性を保証されない。標準ストリームはライブラリ関数 "
"B<freopen>(3)  を用いれば、別のファイルを示すように変更することもできる。 こ"
"のライブラリ関数は I<stdin>, I<stdout>, I<stderr> の再割り当てが可能なように"
"特別に導入されたものである。 標準ストリームは B<exit>(3)  の呼び出しと、プロ"
"グラムの正常終了によってクローズされる。"

#. type: Plain text
#: build/C/man3/stdin.3:118
msgid ""
"The I<stdin>, I<stdout>, and I<stderr> macros conform to C89 and this "
"standard also stipulates that these three streams shall be open at program "
"startup."
msgstr ""
"I<stdin>, I<stdout>, I<stderr> マクロは C89 に準拠している。 また C89 では、"
"これら 3 つのストリームがプログラム の起動時にオープンされているべきであるこ"
"とが規定されている。"

#. type: Plain text
#: build/C/man3/stdin.3:150
msgid ""
"The stream I<stderr> is unbuffered.  The stream I<stdout> is line-buffered "
"when it points to a terminal.  Partial lines will not appear until B<fflush>"
"(3)  or B<exit>(3)  is called, or a newline is printed.  This can produce "
"unexpected results, especially with debugging output.  The buffering mode of "
"the standard streams (or any other stream)  can be changed using the "
"B<setbuf>(3)  or B<setvbuf>(3)  call.  Note that in case I<stdin> is "
"associated with a terminal, there may also be input buffering in the "
"terminal driver, entirely unrelated to stdio buffering.  (Indeed, normally "
"terminal input is line buffered in the kernel.)  This kernel input handling "
"can be modified using calls like B<tcsetattr>(3); see also B<stty>(1), and "
"B<termios>(3)."
msgstr ""
"I<stderr> ストリームはバッファリングされていない。 I<stdout> ストリームは、端"
"末に接続されているときには行単位でバッファリング されている。一行に満たない内"
"容は、 B<fflush>(3)  か B<exit>(3)  が呼び出されるか、改行文字が印字されるま"
"で表示されない。これは、 特にデバッグ時において、予期しない結果を生じる原因と"
"なるかもしれない。 標準ストリームの (あるいは他のすべてのストリームの)  バッ"
"ファリングモードは、 B<setbuf>(3)  または B<setvbuf>(3)  を呼び出すことによっ"
"て変更できる。 ただし、 I<stdin> が端末に接続されているときは、端末のドライバ"
"でバッファリングされている 可能性がある点にも注意すること。これは stdio の"
"バッファリングとは全く 関係なく存在しうる。 (実際、通常だと端末入力はカーネル"
"によって行単位 でバッファリングされている。) このカーネルによる入力の扱いは "
"B<tcsetattr>(3)  などの呼び出しによって変更することができる。 B<stty>(1)  と "
"B<termios>(3)  も参照すること。"

#. type: Plain text
#: build/C/man3/stdin.3:156
msgid "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"
msgstr "B<csh>(1), B<sh>(1), B<open>(2), B<fopen>(3), B<stdio>(3)"

#. type: TH
#: build/C/man3/stdio.3:37
#, no-wrap
msgid "STDIO"
msgstr "STDIO"

#. type: TH
#: build/C/man3/stdio.3:37
#, no-wrap
msgid "2001-12-26"
msgstr "2001-12-26"

#. type: Plain text
#: build/C/man3/stdio.3:40
msgid "stdio - standard input/output library functions"
msgstr "stdio - 標準入出力ライブラリ関数"

#. type: Plain text
#: build/C/man3/stdio.3:44
msgid "B<FILE *>I<stdin>B<;>"
msgstr "B<FILE *>I<stdin>B<;>"

#. type: Plain text
#: build/C/man3/stdio.3:46
msgid "B<FILE *>I<stdout>B<;>"
msgstr "B<FILE *>I<stdout>B<;>"

#. type: Plain text
#: build/C/man3/stdio.3:48
msgid "B<FILE *>I<stderr>B<;>"
msgstr "B<FILE *>I<stderr>B<;>"

#. type: Plain text
#: build/C/man3/stdio.3:55
msgid ""
"The standard I/O library provides a simple and efficient buffered stream I/O "
"interface.  Input and output is mapped into logical data streams and the "
"physical I/O characteristics are concealed.  The functions and macros are "
"listed below; more information is available from the individual man pages."
msgstr ""
"標準入出力ライブラリは、簡単かつ効果のよい、 バッファリングされたストリーム入"
"出力インターフェースを提供する。 入力と出力は論理データストリームに割り付けら"
"れ、 入出力の物理的な特徴は隠蔽される。 このライブラリに属する関数とマクロを"
"以下に挙げる。 より詳しい情報は個々の man ページから得ることができる。"

#. type: Plain text
#: build/C/man3/stdio.3:78
msgid ""
"A stream is associated with an external file (which may be a physical "
"device) by I<opening> a file, which may involve creating a new file.  "
"Creating an existing file causes its former contents to be discarded.  If a "
"file can support positioning requests (such as a disk file, as opposed to a "
"terminal) then a I<file position indicator> associated with the stream is "
"positioned at the start of the file (byte zero), unless the file is opened "
"with append mode.  If append mode is used, it is unspecified whether the "
"position indicator will be placed at the start or the end of the file.  The "
"position indicator is maintained by subsequent reads, writes and positioning "
"requests.  All input occurs as if the characters were read by successive "
"calls to the B<fgetc>(3)  function; all output takes place as if all "
"characters were written by successive calls to the B<fputc>(3)  function."
msgstr ""
"ファイルを I<オープン (open) する> ことによって、 ストリームは外部ファイル "
"(通常は物理デバイス) に連結される。 この操作には新しくファイルを作成すること"
"も含まれる。 既存のファイルと同じ名前のファイルを新たに作ると、 もとのファイ"
"ルの中身が捨てられてしまう。 ファイルが位置指定リクエストをサポートしている "
"(ディスクファイルなどが相当する。逆の例としては端末が挙げられる) 場合、 その"
"ストリームに連結された I<ファイル位置指示子 (file position indicator)> は、追"
"加モードで開かれない限りファイルの先頭 (0 バイト目) に位置する。 追加モードを"
"使用した場合、 位置指示子をファイルの先頭に置かれるか末尾に置かれるかは規定さ"
"れていない。 位置指示子は、 以降の読み書きや位置指定リクエストによって変更さ"
"れる。 すべての入力は、 B<fgetc>(3)  関数を次々に呼び出して文字を読み込んだか"
"のように行われる。 一方すべての出力は、 B<fputc>(3)  関数を次々に呼び出して文"
"字を書き込んだかのように行われる。"

#. type: Plain text
#: build/C/man3/stdio.3:88
msgid ""
"A file is disassociated from a stream by I<closing> the file.  Output "
"streams are flushed (any unwritten buffer contents are transferred to the "
"host environment) before the stream is disassociated from the file.  The "
"value of a pointer to a I<FILE> object is indeterminate after a file is "
"closed (garbage)."
msgstr ""
"ファイルを I<クローズ (close) する> ことによって、そのファイルはストリームか"
"ら切り離される。 出力ストリームは、そのストリームがファイルから切り離される前"
"にフラッシュされる (書き込まれていないすべてのバッファの内容がホスト環境に転"
"送される)。 I<FILE> オブジェクトへのポインタの値は、 ファイルを閉じた後では不"
"確定になる (ゴミになってしまう)。"

#. type: Plain text
#: build/C/man3/stdio.3:101
msgid ""
"A file may be subsequently reopened, by the same or another program "
"execution, and its contents reclaimed or modified (if it can be repositioned "
"at the start).  If the main function returns to its original caller, or the "
"B<exit>(3)  function is called, all open files are closed (hence all output "
"streams are flushed) before program termination.  Other methods of program "
"termination, such as B<abort>(3)  do not bother about closing files properly."
msgstr ""
"ファイルはその後 (同じまたは別のプログラムによって)  再びオープンされることも"
"あり、 その内容が修正されたり変更されたりする (そのファイルで先頭への位置移動"
"が可能であれば)。 main 関数がもとの呼び出し側に返ったり、 B<exit>(3)  関数が"
"呼ばれた場合、 プログラムの終了の前に 現在開いているすべてのファイルは閉じら"
"れる (その結果、すべての出力ストリームはフラッシュされる)。 プログラムの停止"
"に B<abort>(3)  のような他の方法を用いた場合には、 ファイルが正しく閉じられる"
"保証はない。"

#. type: Plain text
#: build/C/man3/stdio.3:117
msgid ""
"At program startup, three text streams are predefined and need not be opened "
"explicitly: I<standard input> (for reading conventional input), I<standard "
"output> (for writing conventional input), and I<standard error> (for writing "
"diagnostic output).  These streams are abbreviated I<stdin>,I<stdout> and "
"I<stderr>.  When opened, the standard error stream is not fully buffered; "
"the standard input and output streams are fully buffered if and only if the "
"streams do not to refer to an interactive device."
msgstr ""
"プログラムの起動時に 3 個のテキストストリームが予め定義されており、 それらは"
"明示的に開く必要がない。 I<標準入力 (standard input)> (通常の入力を読み取るの"
"に使う)、 I<標準出力 (standard output)> (通常の出力を書き込むのに使う)、 I<標"
"準エラー出力 (standard error)> (診断出力を書き込むのに使う) である。 これらの"
"ストリームは I<stdin>, I<stdout>, I<stderr> と短縮して表現される。 オープンさ"
"れたときには、 標準エラーストリームは 完全にはバッファリングされていない。 標"
"準入力ストリームと標準出力ストリームは、 ストリームがインタラクティブなデバイ"
"スを参照していなければ、 完全にバッファリングされている。"

#. type: Plain text
#: build/C/man3/stdio.3:127
msgid ""
"Output streams that refer to terminal devices are always line buffered by "
"default; pending output to such streams is written automatically whenever an "
"input stream that refers to a terminal device is read.  In cases where a "
"large amount of computation is done after printing part of a line on an "
"output terminal, it is necessary to B<fflush>(3)  the standard output before "
"going off and computing so that the output will appear."
msgstr ""
"端末デバイスを参照する出力ストリームは、 デフォルトでは常に行単位でバッファリ"
"ングされている。 ただしそのようなストリームにおけるバッファ内の出力は、 端末"
"デバイスを参照している入力ストリームからの読み込みがあるたびに、 自動的に書き"
"込まれる。 出力端末に行の一部を書き込んだ後で大量の計算を行う場合、 出力が表"
"示されるように、計算に取りかかる前に標準出力に対して B<fflush>(3)  を実行する"
"必要がある。"

#. type: Plain text
#: build/C/man3/stdio.3:141
msgid ""
"The I<stdio> library is a part of the library B<libc> and routines are "
"automatically loaded as needed by the compilers B<cc>(1)  and B<pc>(1).  The "
"SYNOPSIS sections of the following manual pages indicate which include files "
"are to be used, what the compiler declaration for the function looks like "
"and which external variables are of interest."
msgstr ""
"I<stdio> ライブラリは B<libc> ライブラリの一部であり、ルーチンは コンパイ"
"ラー B<cc>(1)  と B<pc>(1)  によって必要な時に自動的に読み込まれる。 後述す"
"る man ページ中の「書式」の節には、 どのインクルードファイルを使用しなければ"
"ならないか、 その関数のコンパイラー宣言はどのようなものか、 どのような外部変"
"数が関係するのかが示されている。"

#.  Not on Linux: .BR fropen ,
#.  Not on Linux: .BR fwopen ,
#. type: Plain text
#: build/C/man3/stdio.3:181
msgid ""
"The following are defined as macros; these names may not be reused without "
"first removing their current definitions with B<#undef>: B<BUFSIZ>, B<EOF>, "
"B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, B<L_ctermid>, B<L_tmpnam>, "
"B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, B<TMP_MAX>, B<clearerr>, "
"B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar>, "
"B<stderr>, B<stdin>, B<stdout>.  Function versions of the macro functions "
"B<feof>, B<ferror>, B<clearerr>, B<fileno>, B<getc>, B<getchar>, B<putc>, "
"and B<putchar> exist and will be used if the macros definitions are "
"explicitly removed."
msgstr ""
"B<BUFSIZ>, B<EOF>, B<FILENAME_MAX>, B<FOPEN_MAX>, B<L_cuserid>, "
"B<L_ctermid>, B<L_tmpnam>, B<NULL>, B<SEEK_END>, B<SEEK_SET>, B<SEEK_CUR>, "
"B<TMP_MAX>, B<clearerr>, B<feof>, B<ferror>, B<fileno>, B<getc>, B<getchar>, "
"B<putc>, B<putchar>, B<stderr>, B<stdin>, B<stdout> はマクロとして定義されて"
"いる。 これらの名前は、現在の定義を B<#undef> で削除しない限り、再利用するこ"
"とはできない。 マクロ関数の関数版として、 B<feof>, B<ferror>, B<clearerr>, "
"B<fileno>, B<getc>, B<getchar>, B<putc>, B<putchar> がある。 マクロの定義が明"
"示的に消去されている場合には、 これらを使用することになるだろう。"

#. type: SS
#: build/C/man3/stdio.3:181
#, no-wrap
msgid "List of Functions"
msgstr "関数のリスト"

#. type: tbl table
#: build/C/man3/stdio.3:186
#, no-wrap
msgid "Function\tDescription\n"
msgstr "関数\t説明\n"

#. type: tbl table
#: build/C/man3/stdio.3:187
#, no-wrap
msgid "_\n"
msgstr "_\n"

#. type: tbl table
#: build/C/man3/stdio.3:188
#, no-wrap
msgid "clearerr\tcheck and reset stream status\n"
msgstr "clearerr\tストリームの状態の確認とリセット\n"

#. type: tbl table
#: build/C/man3/stdio.3:189
#, no-wrap
msgid "fclose\tclose a stream\n"
msgstr "fclose\tストリームをクローズする\n"

#. type: tbl table
#: build/C/man3/stdio.3:190
#, no-wrap
msgid "fdopen\tstream open functions\n"
msgstr "fdopen\tストリームをオープンする\n"

#. type: tbl table
#: build/C/man3/stdio.3:191
#, no-wrap
msgid "feof\tcheck and reset stream status\n"
msgstr "feof\tストリームの状態の確認とリセット\n"

#. type: tbl table
#: build/C/man3/stdio.3:192
#, no-wrap
msgid "ferror\tcheck and reset stream status\n"
msgstr "ferror\tストリームの状態の確認とリセット\n"

#. type: tbl table
#: build/C/man3/stdio.3:193
#, no-wrap
msgid "fflush\tflush a stream\n"
msgstr "fflush\tストリームをフラッシュする\n"

#. type: tbl table
#: build/C/man3/stdio.3:194
#, no-wrap
msgid "fgetc\tget next character or word from input stream\n"
msgstr "fgetc\t次の文字または語を入力ストリームから獲得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:195
#, no-wrap
msgid "fgetpos\treposition a stream\n"
msgstr "fgetpos\tストリームの位置を取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:196
#, no-wrap
msgid "fgets\tget a line from a stream\n"
msgstr "fgets\tストリームから行を取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:197
#, no-wrap
msgid "fileno\treturn the integer descriptor of the argument stream\n"
msgstr "fileno\t引き数であるストリームの整数値のディスクリプタを返す\n"

#. type: tbl table
#: build/C/man3/stdio.3:198
#, no-wrap
msgid "fopen\tstream open functions\n"
msgstr "fopen\tストリームをオープンする\n"

#. type: tbl table
#: build/C/man3/stdio.3:199
#, no-wrap
msgid "fprintf\tformatted output conversion\n"
msgstr "fprintf\t書式付き出力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:200
#, no-wrap
msgid "fpurge\tflush a stream\n"
msgstr "fpurge\tストリームをフラッシュする\n"

#. type: tbl table
#: build/C/man3/stdio.3:201
#, no-wrap
msgid "fputc\toutput a character or word to a stream\n"
msgstr "fputc\t文字または語をストリームに出力する\n"

#. type: tbl table
#: build/C/man3/stdio.3:202
#, no-wrap
msgid "fputs\toutput a line to a stream\n"
msgstr "fputs\t行をストリームに出力する\n"

#. type: tbl table
#: build/C/man3/stdio.3:203
#, no-wrap
msgid "fread\tbinary stream input/output\n"
msgstr "fread\tバイナリーストリーム入出力\n"

#. type: tbl table
#: build/C/man3/stdio.3:204
#, no-wrap
msgid "freopen\tstream open functions\n"
msgstr "freopen\tストリームをオープンする\n"

#. type: tbl table
#: build/C/man3/stdio.3:205
#, no-wrap
msgid "fscanf\tinput format conversion\n"
msgstr "fscanf\t書式付き入力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:206
#, no-wrap
msgid "fseek\treposition a stream\n"
msgstr "fseek\tストリームの位置指示子を移動する\n"

#. type: tbl table
#: build/C/man3/stdio.3:207
#, no-wrap
msgid "fsetpos\treposition a stream\n"
msgstr "fsetpos\tストリームの位置指示子を移動する\n"

#. type: tbl table
#: build/C/man3/stdio.3:208
#, no-wrap
msgid "ftell\treposition a stream\n"
msgstr "ftell\tストリームの位置を取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:209
#, no-wrap
msgid "fwrite\tbinary stream input/output\n"
msgstr "fwrite\tバイナリーストリーム入出力\n"

#. type: tbl table
#: build/C/man3/stdio.3:210
#, no-wrap
msgid "getc\tget next character or word from input stream\n"
msgstr "getc\t次の文字または語を入力ストリームから取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:211
#, no-wrap
msgid "getchar\tget next character or word from input stream\n"
msgstr "getchar\t次の文字または語を入力ストリームから取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:212
#, no-wrap
msgid "gets\tget a line from a stream\n"
msgstr "gets\t行を入力ストリームから取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:213
#, no-wrap
msgid "getw\tget next character or word from input stream\n"
msgstr "getw\t次の文字または語を入力ストリームから取得する\n"

#. type: tbl table
#: build/C/man3/stdio.3:214
#, no-wrap
msgid "mktemp\tmake temporary filename (unique)\n"
msgstr "mktemp\t他と重ならないテンポラリファイル名を作る\n"

#. type: tbl table
#: build/C/man3/stdio.3:215
#, no-wrap
msgid "perror\tsystem error messages\n"
msgstr "perror\tシステムエラーメッセージ\n"

#. type: tbl table
#: build/C/man3/stdio.3:216
#, no-wrap
msgid "printf\tformatted output conversion\n"
msgstr "printf\t書式付き出力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:217
#, no-wrap
msgid "putc\toutput a character or word to a stream\n"
msgstr "putc\t文字または語をストリームに出力する\n"

#. type: tbl table
#: build/C/man3/stdio.3:218
#, no-wrap
msgid "putchar\toutput a character or word to a stream\n"
msgstr "putchar\t文字または語をストリームに出力する\n"

#. type: tbl table
#: build/C/man3/stdio.3:219
#, no-wrap
msgid "puts\toutput a line to a stream\n"
msgstr "puts\t行をストリームに出力する\n"

#. type: tbl table
#: build/C/man3/stdio.3:220
#, no-wrap
msgid "putw\toutput a character or word to a stream\n"
msgstr "putw\t文字または語をストリームに出力する\n"

#. type: tbl table
#: build/C/man3/stdio.3:221
#, no-wrap
msgid "remove\tremove directory entry\n"
msgstr "remove\tディレクトリエントリを削除する\n"

#. type: tbl table
#: build/C/man3/stdio.3:222
#, no-wrap
msgid "rewind\treposition a stream\n"
msgstr "rewind\tストリームの位置指示子を移動する\n"

#. type: tbl table
#: build/C/man3/stdio.3:223
#, no-wrap
msgid "scanf\tinput format conversion\n"
msgstr "scanf\t書式付き入力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:224
#, no-wrap
msgid "setbuf\tstream buffering operations\n"
msgstr "setbuf\tストリームのバッファリングの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:225
#, no-wrap
msgid "setbuffer\tstream buffering operations\n"
msgstr "setbuffer\tストリームのバッファリングの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:226
#, no-wrap
msgid "setlinebuf\tstream buffering operations\n"
msgstr "setlinebuf\tストリームのバッファリングの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:227
#, no-wrap
msgid "setvbuf\tstream buffering operations\n"
msgstr "setvbuf\tストリームのバッファリングの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:228
#, no-wrap
msgid "sprintf\tformatted output conversion\n"
msgstr "sprintf\t書式付き出力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:229
#, no-wrap
msgid "sscanf\tinput format conversion\n"
msgstr "sscanf\t書式付き入力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:230
#, no-wrap
msgid "strerror\tsystem error messages\n"
msgstr "strerror\tシステムエラーメッセージ\n"

#. type: tbl table
#: build/C/man3/stdio.3:231
#, no-wrap
msgid "sys_errlist\tsystem error messages\n"
msgstr "sys_errlist\tシステムエラーメッセージ\n"

#. type: tbl table
#: build/C/man3/stdio.3:232
#, no-wrap
msgid "sys_nerr\tsystem error messages\n"
msgstr "sys_nerr\tシステムエラーメッセージ\n"

#. type: tbl table
#: build/C/man3/stdio.3:233
#, no-wrap
msgid "tempnam\ttemporary file routines\n"
msgstr "tempnam\tテンポラリファイルの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:234
#, no-wrap
msgid "tmpfile\ttemporary file routines\n"
msgstr "tmpfile\tテンポラリファイルの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:235
#, no-wrap
msgid "tmpnam\ttemporary file routines\n"
msgstr "tmpnam\tテンポラリファイルの操作\n"

#. type: tbl table
#: build/C/man3/stdio.3:236
#, no-wrap
msgid "ungetc\tun-get character from input stream\n"
msgstr "ungetc\t入力ストリームへ 1 文字戻す。\n"

#. type: tbl table
#: build/C/man3/stdio.3:237
#, no-wrap
msgid "vfprintf\tformatted output conversion\n"
msgstr "vfprintf\t書式付き出力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:238
#, no-wrap
msgid "vfscanf\tinput format conversion\n"
msgstr "vfscanf\t書式付き入力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:239
#, no-wrap
msgid "vprintf\tformatted output conversion\n"
msgstr "vprintf\t書式付き出力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:240
#, no-wrap
msgid "vscanf\tinput format conversion\n"
msgstr "vscanf\t書式付き入力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:241
#, no-wrap
msgid "vsprintf\tformatted output conversion\n"
msgstr "vsprintf\t書式付き出力変換\n"

#. type: tbl table
#: build/C/man3/stdio.3:242
#, no-wrap
msgid "vsscanf\tinput format conversion\n"
msgstr "vsscanf\t書式付き入力変換\n"

#. type: Plain text
#: build/C/man3/stdio.3:248
msgid "The I<stdio> library conforms to C89."
msgstr "I<stdio> ライブラリは C89 に準拠している。"

#. type: Plain text
#: build/C/man3/stdio.3:255
msgid ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"
msgstr ""
"B<close>(2), B<open>(2), B<read>(2), B<write>(2), B<stdout>(3), "
"B<unlocked_stdio>(3)"

#. type: TH
#: build/C/man3/stdio_ext.3:23
#, no-wrap
msgid "STDIO_EXT"
msgstr "STDIO_EXT"

#. type: TH
#: build/C/man3/stdio_ext.3:23
#, no-wrap
msgid "2001-12-16"
msgstr "2001-12-16"

#. type: Plain text
#: build/C/man3/stdio_ext.3:28
msgid ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - interfaces to stdio FILE "
"structure"
msgstr ""
"__fbufsize, __flbf, __fpending, __fpurge, __freadable, __freading, "
"__fsetlocking, __fwritable, __fwriting, _flushlbf - 標準入出力ファイル構造体"
"へのインタフェース"

#. type: Plain text
#: build/C/man3/stdio_ext.3:32
msgid "B<#include E<lt>stdio_ext.hE<gt>>"
msgstr "B<#include E<lt>stdio_ext.hE<gt>>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:34
msgid "B<size_t __fbufsize(FILE *>I<stream>B<);>"
msgstr "B<size_t __fbufsize(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:36
msgid "B<size_t __fpending(FILE *>I<stream>B<);>"
msgstr "B<size_t __fpending(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:38
msgid "B<int __flbf(FILE *>I<stream>B<);>"
msgstr "B<int __flbf(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:40
msgid "B<int __freadable(FILE *>I<stream>B<);>"
msgstr "B<int __freadable(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:42
msgid "B<int __fwritable(FILE *>I<stream>B<);>"
msgstr "B<int __fwritable(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:44
msgid "B<int __freading(FILE *>I<stream>B<);>"
msgstr "B<int __freading(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:46
msgid "B<int __fwriting(FILE *>I<stream>B<);>"
msgstr "B<int __fwriting(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:48
msgid "B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>"
msgstr "B<int __fsetlocking(FILE *>I<stream>B<, int >I<type>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:50
msgid "B<void _flushlbf(void);>"
msgstr "B<void _flushlbf(void);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:52
msgid "B<void __fpurge(FILE *>I<stream>B<);>"
msgstr "B<void __fpurge(FILE *>I<stream>B<);>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:57
msgid ""
"Solaris introduced routines to allow portable access to the internals of the "
"I<FILE> structure, and glibc also implemented these."
msgstr ""
"Solaris では、 I<FILE> 構造体の内部へポータブルなかたちで アクセスできる手段"
"が導入されており、これらは glibc でも実装されている。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:62
msgid ""
"The B<__fbufsize>()  function returns the size of the buffer currently used "
"by the given stream."
msgstr ""
"B<__fbufsize>()  関数は、指定されたストリームが使用しているバッファサイズを返"
"す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:69
msgid ""
"The B<__fpending>()  function returns the number of bytes in the output "
"buffer.  For wide-oriented streams the unit is wide characters.  This "
"function is undefined on buffers in reading mode, or opened read-only."
msgstr ""
"B<__fpending>()  関数は、出力バッファに入っているデータのバイト数を返す。 ワ"
"イドキャラクタを扱うストリームの場合、ワイドキャラクタ単位で計算される。 バッ"
"ファが読み出しモードの場合や読み出し専用で開かれている場合の この関数の振舞い"
"は未定義である。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:74
msgid ""
"The B<__flbf>()  function returns a nonzero value if the stream is line-"
"buffered, and zero otherwise."
msgstr ""
"B<__flbf>()  関数は、ストリームがラインバッファの場合は 0 以外を、 それ以外の"
"場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:79
msgid ""
"The B<__freadable>()  function returns a nonzero value if the stream allows "
"reading, and zero otherwise."
msgstr ""
"B<__freadable>()  関数は、ストリームが読み出し可能な場合は 0 以外を、 それ以"
"外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:84
msgid ""
"The B<__fwritable>()  function returns a nonzero value if the stream allows "
"writing, and zero otherwise."
msgstr ""
"B<__fwritable>()  関数は、ストリームが書き込み可能な場合は 0 以外を、 それ以"
"外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:90
msgid ""
"The B<__freading>()  function returns a nonzero value if the stream is read-"
"only, or if the last operation on the stream was a read operation, and zero "
"otherwise."
msgstr ""
"B<__freading>()  関数は、ストリームが読み出し専用の場合、またはストリームに対"
"する直前の操作が 読み出し操作であった場合は 0 以外を返し、それ以外の場合は 0 "
"を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:96
msgid ""
"The B<__fwriting>()  function returns a nonzero value if the stream is write-"
"only (or append-only), or if the last operation on the stream was a write "
"operation, and zero otherwise."
msgstr ""
"B<__fwriting>()  関数は、ストリームが書き込み専用(もしくは追加専用)の場合、 "
"またはストリームに対する直前の操作が書き込み操作であった場合は 0 以外を返"
"し、 それ以外の場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:104
msgid ""
"The B<__fsetlocking>()  function can be used to select the desired type of "
"locking on the stream.  It returns the current type.  The I<type> argument "
"can take the following three values:"
msgstr ""
"B<__fsetlocking>()  関数は、ストリームのロック形式を選択するために使用でき"
"る。 返り値は、現在のロック形式である。 I<type> 引き数は以下の 3 種類の値をと"
"ることができる :"

#. type: TP
#: build/C/man3/stdio_ext.3:104
#, no-wrap
msgid "B<FSETLOCKING_INTERNAL>"
msgstr "B<FSETLOCKING_INTERNAL>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:109
msgid ""
"Perform implicit locking around every operation on the given stream (except "
"for the *_unlocked ones).  This is the default."
msgstr ""
"指定されたストリームに対して操作が行われる度に、操作の前後で 明示的に指示しな"
"くてもストリームのロック処理を行う (但し、*_unlocked 関数を使用した場合は例外"
"である)。 これがデフォルトのロック形式である。"

#. type: TP
#: build/C/man3/stdio_ext.3:109
#, no-wrap
msgid "B<FSETLOCKING_BYCALLER>"
msgstr "B<FSETLOCKING_BYCALLER>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:116
msgid ""
"The caller will take care of the locking (possibly using B<flockfile>(3)  in "
"case there is more than one thread), and the stdio routines will not do "
"locking until the state is reset to B<FSETLOCKING_INTERNAL>."
msgstr ""
"関数の呼び出し元でロックの面倒をみる。 (おそらく、複数のスレッドが存在する状"
"況では B<flockfile>(3)  を使うことになるだろう)  ロック形式が "
"B<FSETLOCKING_INTERNAL> にリセットされるまでは標準入出力関連の関数はロック処"
"理を行わない。"

#. type: TP
#: build/C/man3/stdio_ext.3:116
#, no-wrap
msgid "B<FSETLOCKING_QUERY>"
msgstr "B<FSETLOCKING_QUERY>"

#. type: Plain text
#: build/C/man3/stdio_ext.3:120
msgid "Don't change the type of locking.  (Only return it.)"
msgstr "ロック形式の変更を行わない。(現在の形式を返すだけである)"

#. type: Plain text
#: build/C/man3/stdio_ext.3:126
msgid ""
"The B<_flushlbf>()  function flushes all line-buffered streams.  (Presumably "
"so that output to a terminal is forced out, say before reading keyboard "
"input.)"
msgstr ""
"B<_flushlbf>()  関数は、すべてのラインバッファ (line-buffered) タイプのスト"
"リームの 内容を出力(フラッシュ)する。 (当然ながら、端末への出力が強制的に行わ"
"れることになるので、 キーボードからの入力を読みこむ前にこの関数を呼んだ方がい"
"いだろう)"

#. type: Plain text
#: build/C/man3/stdio_ext.3:130
msgid ""
"The B<__fpurge>()  function discards the contents of the stream's buffer."
msgstr "B<__fpurge>()  関数は、ストリームのバッファの内容を廃棄する。"

#. type: Plain text
#: build/C/man3/stdio_ext.3:133
msgid "B<flockfile>(3), B<fpurge>(3)"
msgstr "B<flockfile>(3), B<fpurge>(3)"

#. type: TH
#: build/C/man2/symlink.2:32 build/C/man7/symlink.7:35
#, no-wrap
msgid "SYMLINK"
msgstr "SYMLINK"

#. type: TH
#: build/C/man2/symlink.2:32
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: build/C/man2/symlink.2:35
msgid "symlink - make a new name for a file"
msgstr "symlink - ファイルに新しい名前を付ける"

#. type: Plain text
#: build/C/man2/symlink.2:39
msgid "B<int symlink(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"
msgstr "B<int symlink(const char *>I<oldpath>B<, const char *>I<newpath>B<);>"

#. type: Plain text
#: build/C/man2/symlink.2:47
msgid "B<symlink>():"
msgstr "B<symlink>():"

#. type: Plain text
#: build/C/man2/symlink.2:58
msgid ""
"B<symlink>()  creates a symbolic link named I<newpath> which contains the "
"string I<oldpath>."
msgstr ""
"B<symlink>()  は I<oldpath> という文字列をファイルの内容として持つ "
"I<newpath> というシンボリックリンク (symbolic link) を作成する。"

#. type: Plain text
#: build/C/man2/symlink.2:62
msgid ""
"Symbolic links are interpreted at run time as if the contents of the link "
"had been substituted into the path being followed to find a file or "
"directory."
msgstr ""
"シンボリックリンクは実行時に解釈され、 リンクの内容でパスを置き換えて、そのパ"
"スを辿ることで、 ファイルやディレクトリに到達する。"

#. type: Plain text
#: build/C/man2/symlink.2:67
msgid ""
"Symbolic links may contain I<..> path components, which (if used at the "
"start of the link) refer to the parent directories of that in which the link "
"resides."
msgstr ""
"シンボリックリンクはパスの部分に I<..> を含むかもしれない。これは (もしリンク"
"の最初に使用された場合は) リンクの 存在するディレクトリの親ディレクトリが参照"
"される。"

#. type: Plain text
#: build/C/man2/symlink.2:71
msgid ""
"A symbolic link (also known as a soft link) may point to an existing file or "
"to a nonexistent one; the latter case is known as a dangling link."
msgstr ""
"シンボリックリンクは (ソフトリンク (soft link) とも呼ばれ)  存在するファイル"
"を指しているかもしれないし、 存在しないファイルを指しているかもしれない; 後者"
"の場合は壊れたリンク (dangling link) とも呼ばれる。"

#. type: Plain text
#: build/C/man2/symlink.2:78
msgid ""
"The permissions of a symbolic link are irrelevant; the ownership is ignored "
"when following the link, but is checked when removal or renaming of the link "
"is requested and the link is in a directory with the sticky bit "
"(B<S_ISVTX>)  set."
msgstr ""
"シンボリックリンクの許可 (permission) は無意味である; リンクを追跡する場合に"
"は所有権 (ownership) は無視される。 ただし、リンクの削除や名前の変更が要求さ"
"れ、かつリンクが存在する ディレクトリにスティッキービット (sticky bit)  "
"(B<S_ISVTX>)  が設定されている場合には、所有権のチェックが行われる。"

#. type: Plain text
#: build/C/man2/symlink.2:99
msgid ""
"Write access to the directory containing I<newpath> is denied, or one of the "
"directories in the path prefix of I<newpath> did not allow search "
"permission.  (See also B<path_resolution>(7).)"
msgstr ""
"I<newpath> を含んでいるディレクトリへの書き込みが拒否されたか、 I<newpath> に"
"含まれているディレクトリのどれかに検索許可が与えられていない "
"(B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/symlink.2:113
msgid "Too many symbolic links were encountered in resolving I<newpath>."
msgstr "I<newpath> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/symlink.2:123
msgid ""
"A directory component in I<newpath> does not exist or is a dangling symbolic "
"link, or I<oldpath> is the empty string."
msgstr ""
"I<newpath> に含まれるディレクトリ部分が存在しないか、壊れたリンクであるか、 "
"I<oldpath> が空文字列である。"

#. type: Plain text
#: build/C/man2/symlink.2:135
msgid ""
"A component used as a directory in I<newpath> is not, in fact, a directory."
msgstr ""
"I<newpath> に含まれるディレクトリ部分が、実際には、ディレクトリではない。"

#. type: Plain text
#: build/C/man2/symlink.2:140
msgid ""
"The file system containing I<newpath> does not support the creation of "
"symbolic links."
msgstr ""
"I<newpath> を含んでいるファイルシステム (file system) が シンボリックリンクの"
"作成をサポートしていない。"

#. type: Plain text
#: build/C/man2/symlink.2:144
msgid "I<newpath> is on a read-only file system."
msgstr "I<newpath> が読み込み専用のファイルシステムに存在している。"

#. type: Plain text
#: build/C/man2/symlink.2:154
msgid "No checking of I<oldpath> is done."
msgstr "I<oldpath> についてのチェックは行なわれない。"

#. type: Plain text
#: build/C/man2/symlink.2:159
msgid ""
"Deleting the name referred to by a symlink will actually delete the file "
"(unless it also has other hard links).  If this behavior is not desired, use "
"B<link>(2)."
msgstr ""
"symlink によって参照される名前を削除すると (それが他にハードリンク (hard "
"link) を持たなければ) 実際にファイルが削除される。 この動作が望んだものでない"
"場合は、 B<link>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/symlink.2:171
msgid ""
"B<ln>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), B<readlink>(2), "
"B<rename>(2), B<symlinkat>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr ""
"B<ln>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<open>(2), B<readlink>(2), "
"B<rename>(2), B<symlinkat>(2), B<unlink>(2), B<path_resolution>(7), "
"B<symlink>(7)"

#. type: TH
#: build/C/man7/symlink.7:35
#, no-wrap
msgid "2008-06-18"
msgstr "2008-06-18"

#. type: Plain text
#: build/C/man7/symlink.7:38
msgid "symlink - symbolic link handling"
msgstr ""

#. type: SH
#: build/C/man7/symlink.7:38
#, no-wrap
msgid "SYMBOLIC LINK HANDLING"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:42
msgid ""
"Symbolic links are files that act as pointers to other files.  To understand "
"their behavior, you must first understand how hard links work."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:58
msgid ""
"A hard link to a file is indistinguishable from the original file because it "
"is a reference to the object underlying the original filename.  (To be "
"precise: each of the hard links to a file is a reference to the same I<i-"
"node number>, where an i-node number is an index into the i-node table, "
"which contains metadata about all files on a file system.  See B<stat>(2).)  "
"Changes to a file are independent of the name used to reference the file.  "
"Hard links may not refer to directories (to prevent the possibility of loops "
"within the file system tree, which would confuse many programs)  and may not "
"refer to files on different file systems (because i-node numbers are not "
"unique across file systems)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:65
msgid ""
"A symbolic link is a special type of file whose contents are a string that "
"is the pathname another file, the file to which the link refers.  In other "
"words, a symbolic link is a pointer to another name, and not to an "
"underlying object.  For this reason, symbolic links may refer to directories "
"and may cross file system boundaries."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:71
msgid ""
"There is no requirement that the pathname referred to by a symbolic link "
"should exist.  A symbolic link that refers to a pathname that does not exist "
"is said to be a I<dangling link>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:83
msgid ""
"Because a symbolic link and its referenced object coexist in the file system "
"name space, confusion can arise in distinguishing between the link itself "
"and the referenced object.  On historical systems, commands and system calls "
"adopted their own link-following conventions in a somewhat ad-hoc fashion.  "
"Rules for a more uniform approach, as they are implemented on Linux and "
"other systems, are outlined here.  It is important that site-local "
"applications also conform to these rules, so that the user interface can be "
"as consistent as possible."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:83
#, no-wrap
msgid "Symbolic link ownership, permissions, and timestamps"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:91
msgid ""
"The owner and group of an existing symbolic link can be changed using "
"B<lchown>(2).  The only time that the ownership of a symbolic link matters "
"is when the link is being removed or renamed in a directory that has the "
"sticky bit set (see B<stat>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:97
msgid ""
"The last access and last modification timestamps of a symbolic link can be "
"changed using B<utimensat>(2)  or B<lutimes>(3)."
msgstr ""

#.  Linux does not currently implement an lchmod(2).
#.  The
#.  4.4BSD
#.  system differs from historical
#.  4BSD
#.  systems in that the system call
#.  .BR chown (2)
#.  has been changed to follow symbolic links.
#.  The
#.  .BR lchown (2)
#.  system call was added later when the limitations of the new
#.  .BR chown (2)
#.  became apparent.
#. type: Plain text
#: build/C/man7/symlink.7:116
msgid ""
"On Linux, the permissions of a symbolic link are not used in any operations; "
"the permissions are always 0777 (read, write, and execute for all user "
"categories), and can't be changed."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:116
#, no-wrap
msgid "Handling of symbolic links by system calls and commands"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:131
msgid ""
"Symbolic links are handled either by operating on the link itself, or by "
"operating on the object referred to by the link.  In the latter case, an "
"application or system call is said to I<follow> the link.  Symbolic links "
"may refer to other symbolic links, in which case the links are dereferenced "
"until an object that is not a symbolic link is found, a symbolic link that "
"refers to a file which does not exist is found, or a loop is detected.  "
"(Loop detection is done by placing an upper limit on the number of links "
"that may be followed, and an error results if this limit is exceeded.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:134
msgid ""
"There are three separate areas that need to be discussed.  They are as "
"follows:"
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:134
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/symlink.7:136
msgid "Symbolic links used as filename arguments for system calls."
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:136
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/symlink.7:139
msgid ""
"Symbolic links specified as command-line arguments to utilities that are not "
"traversing a file tree."
msgstr ""

#. type: IP
#: build/C/man7/symlink.7:139
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/symlink.7:143
msgid ""
"Symbolic links encountered by utilities that are traversing a file tree "
"(either specified on the command line or encountered as part of the file "
"hierarchy walk)."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:143
#, no-wrap
msgid "System calls"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:146
msgid ""
"The first area is symbolic links used as filename arguments for system calls."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:156
msgid ""
"Except as noted below, all system calls follow symbolic links.  For example, "
"if there were a symbolic link I<slink> which pointed to a file named "
"I<afile>, the system call I<open(\"slink\" ...\\&)> would return a file "
"descriptor referring to the file I<afile>."
msgstr ""

#.  Maybe one day: .BR fchownat (2)
#. type: Plain text
#: build/C/man7/symlink.7:206
msgid ""
"Various system calls do not follow links, and operate on the symbolic link "
"itself.  They are: B<lchown>(2), B<lgetxattr>(2), B<llistxattr>(2), "
"B<lremovexattr>(2), B<lsetxattr>(2), B<lstat>(2), B<readlink>(2), B<rename>"
"(2), B<rmdir>(2), and B<unlink>(2).  Certain other system calls optionally "
"follow symbolic links.  They are: B<faccessat>(2), B<fchownat>(2), B<fstatat>"
"(2), B<linkat>(2), B<open>(2), B<openat>(2), and B<utimensat>(2); see their "
"manual pages for details.  Because B<remove>(3)  is an alias for B<unlink>"
"(2), that library function also does not follow symbolic links.  When "
"B<rmdir>(2)  is applied to a symbolic link, it fails with the error "
"B<ENOTDIR>.  The B<link>(2)  warrants special discussion.  POSIX.1-2001 "
"specifies that B<link>(2)  should dereference I<oldpath> if it is a symbolic "
"link.  However, Linux does not do this.  (By default Solaris is the same, "
"but the POSIX.1-2001 specified behavior can be obtained with suitable "
"compiler options.)  The upcoming POSIX.1 revision changes the specification "
"to allow either behavior in an implementation."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:206
#, no-wrap
msgid "Commands not traversing a file tree"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:209
msgid ""
"The second area is symbolic links, specified as command-line filename "
"arguments, to commands which are not traversing a file tree."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:220
msgid ""
"Except as noted below, commands follow symbolic links named as command-line "
"arguments.  For example, if there were a symbolic link I<slink> which "
"pointed to a file named I<afile>, the command I<cat slink> would display the "
"contents of the file I<afile>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:228
msgid ""
"It is important to realize that this rule includes commands which may "
"optionally traverse file trees, e.g., the command I<chown file> is included "
"in this rule, while the command I<chown\\ -R file>, which performs a tree "
"traversal, is not.  (The latter is described in the third area, below.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:246
msgid ""
"If it is explicitly intended that the command operate on the symbolic link "
"instead of following the symbolic link, e.g., it is desired that I<chown "
"slink> change the ownership of the file that I<slink> is, whether it is a "
"symbolic link or not, the I<-h> option should be used.  In the above "
"example, I<chown root slink> would change the ownership of the file referred "
"to by I<slink>, while I<chown\\ -h root slink> would change the ownership of "
"I<slink> itself."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:248
msgid "There are some exceptions to this rule:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:258
msgid ""
"The B<mv>(1)  and B<rm>(1)  commands do not follow symbolic links named as "
"arguments, but respectively attempt to rename and delete them.  (Note, if "
"the symbolic link references a file via a relative path, moving it to "
"another directory may very well cause it to stop working, since the path may "
"no longer be correct.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:288
msgid ""
"The B<ls>(1)  command is also an exception to this rule.  For compatibility "
"with historic systems (when B<ls>(1)  is not doing a tree walk, i.e., the I<-"
"R> option is not specified), the B<ls>(1)  command follows symbolic links "
"named as arguments if the I<-H> or I<-L> option is specified, or if the I<-"
"F>, I<-d>, or I<-l> options are not specified.  (The B<ls>(1)  command is "
"the only command where the I<-H> and I<-L> options affect its behavior even "
"though it is not doing a walk of a file tree.)"
msgstr ""

#. The 4.4BSD system differs from historical 4BSD systems in that the
#. .BR chown (1)
#. and
#. .BR chgrp (1)
#. commands follow symbolic links specified on the command line.
#. type: Plain text
#: build/C/man7/symlink.7:306
msgid ""
"The B<file>(1)  command is also an exception to this rule.  The B<file>(1)  "
"command does not follow symbolic links named as argument by default.  The "
"B<file>(1)  command does follow symbolic links named as argument if the I<-"
"L> option is specified."
msgstr ""

#. type: SS
#: build/C/man7/symlink.7:306
#, no-wrap
msgid "Commands traversing a file tree"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:319
msgid ""
"The following commands either optionally or always traverse file trees: "
"B<chgrp>(1), B<chmod>(1), B<chown>(1), B<cp>(1), B<du>(1), B<find>(1), B<ls>"
"(1), B<pax>(1), B<rm>(1), and B<tar>(1)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:323
msgid ""
"It is important to realize that the following rules apply equally to "
"symbolic links encountered during the file tree traversal and symbolic links "
"listed as command-line arguments."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:328
msgid ""
"The I<first rule> applies to symbolic links that reference files other than "
"directories.  Operations that apply to symbolic links are performed on the "
"links themselves, but otherwise the links are ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:340
msgid ""
"The command I<rm\\ -r slink directory> will remove I<slink>, as well as any "
"symbolic links encountered in the tree traversal of I<directory>, because "
"symbolic links may be removed.  In no case will B<rm>(1)  affect the file "
"referred to by I<slink>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:345
msgid ""
"The I<second rule> applies to symbolic links that refer to directories.  "
"Symbolic links that refer to directories are never followed by default.  "
"This is often referred to as a \"physical\" walk, as opposed to a \"logical"
"\" walk (where symbolic links the refer to directories are followed)."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:348
msgid ""
"Certain conventions are (should be) followed as consistently as possible by "
"commands that perform file tree walks:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:361
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, regardless of the type of file they reference, by specifying the I<-H> "
"(for \"half-logical\") flag.  This flag is intended to make the command-line "
"name space look like the logical name space.  (Note, for commands that do "
"not always do file tree traversals, the I<-H> flag will be ignored if the I<-"
"R> flag is not also specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:377
msgid ""
"For example, the command I<chown\\ -HR user slink> will traverse the file "
"hierarchy rooted in the file pointed to by I<slink>.  Note, the I<-H> is not "
"the same as the previously discussed I<-h> flag.  The I<-H> flag causes "
"symbolic links specified on the command line to be dereferenced for the "
"purposes of both the action to be performed and the tree walk, and it is as "
"if the user had specified the name of the file to which the symbolic link "
"pointed."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:391
msgid ""
"A command can be made to follow any symbolic links named on the command "
"line, as well as any symbolic links encountered during the traversal, "
"regardless of the type of file they reference, by specifying the I<-L> (for "
"\"logical\") flag.  This flag is intended to make the entire name space look "
"like the logical name space.  (Note, for commands that do not always do file "
"tree traversals, the I<-L> flag will be ignored if the I<-R> flag is not "
"also specified.)"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:406
msgid ""
"For example, the command I<chown\\ -LR user slink> will change the owner of "
"the file referred to by I<slink>.  If I<slink> refers to a directory, "
"B<chown> will traverse the file hierarchy rooted in the directory that it "
"references.  In addition, if any symbolic links are encountered in any file "
"tree that B<chown> traverses, they will be treated in the same fashion as "
"I<slink>."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:413
msgid ""
"A command can be made to provide the default behavior by specifying the I<-"
"P> (for \"physical\") flag.  This flag is intended to make the entire name "
"space look like the physical name space."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:431
msgid ""
"For commands that do not by default do file tree traversals, the I<-H>, I<-"
"L>, and I<-P> flags are ignored if the I<-R> flag is not also specified.  In "
"addition, you may specify the I<-H>, I<-L>, and I<-P> options more than "
"once; the last one specified determines the command's behavior.  This is "
"intended to permit you to alias commands to behave one way or the other, and "
"then override that behavior on the command line."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:437
msgid "The B<ls>(1)  and B<rm>(1)  commands have exceptions to these rules:"
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:450
msgid ""
"The B<rm>(1)  command operates on the symbolic link, and not the file it "
"references, and therefore never follows a symbolic link.  The B<rm>(1)  "
"command does not support the I<-H>, I<-L>, or I<-P> options."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:470
msgid ""
"To maintain compatibility with historic systems, the B<ls>(1)  command acts "
"a little differently.  If you do not specify the I<-F>, I<-d> or I<-l> "
"options, B<ls>(1)  will follow symbolic links specified on the command "
"line.  If the I<-L> flag is specified, B<ls>(1)  follows all symbolic links, "
"regardless of their type, whether specified on the command line or "
"encountered in the tree walk."
msgstr ""

#. type: Plain text
#: build/C/man7/symlink.7:488
msgid ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1), B<rm>"
"(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<readlink>(2), B<rename>(2), "
"B<symlink>(2), B<unlink>(2), B<utimensat>(2), B<lutimes>(3), "
"B<path_resolution>(7)"
msgstr ""
"B<chgrp>(1), B<chmod>(1), B<find>(1), B<ln>(1), B<ls>(1), B<mv>(1),\n"
"B<rm>(1), B<lchown>(2), B<link>(2), B<lstat>(2), B<readlink>(2),\n"
"B<rename>(2), B<symlink>(2), B<unlink>(2), B<utimensat>(2),\n"
"B<lutimes>(3), B<path_resolution>(7)"

#. type: TH
#: build/C/man3/tempnam.3:23
#, no-wrap
msgid "TEMPNAM"
msgstr "TEMPNAM"

#. type: TH
#: build/C/man3/tempnam.3:23
#, no-wrap
msgid "2008-08-06"
msgstr "2008-08-06"

#. type: Plain text
#: build/C/man3/tempnam.3:26
msgid "tempnam - create a name for a temporary file"
msgstr "tempnam - テンポラリファイルの名前を作成する"

#. type: Plain text
#: build/C/man3/tempnam.3:31
#, no-wrap
msgid "B<char *tempnam(const char *>I<dir>B<, const char *>I<pfx>B<);>\n"
msgstr "B<char *tempnam(const char *>I<dir>B<, const char *>I<pfx>B<);>\n"

#. type: Plain text
#: build/C/man3/tempnam.3:40
msgid "B<tempnam>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<tempnam>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/tempnam.3:54
msgid ""
"The B<tempnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist when B<tempnam>"
"()  checked.  The filename suffix of the pathname generated will start with "
"I<pfx> in case I<pfx> is a non-NULL string of at most five bytes.  The "
"directory prefix part of the pathname generated is required to be "
"\"appropriate\" (often that at least implies writable)."
msgstr ""
"B<tempnam>()  関数はファイル名として正しい文字列へのポインタを返す。 このファ"
"イル名を持つファイルは、 B<tempnam>()  がチェックした時点においては存在しな"
"い (しなかった)。 I<pfx> が NULL でない 5 バイト以内の文字列であれば、 生成さ"
"れるパス名のうちのファイル名の部分は I<pfx> から始まるものになる。 生成される"
"ディレクトリの部分は、「適切」でなければならない (大抵の場合、「適切」である"
"ためにはまず少なくとも 書き込み可能でなければならない)。"

#. type: Plain text
#: build/C/man3/tempnam.3:57
msgid ""
"Attempts to find an appropriate directory go through the following steps:"
msgstr "適切なディレクトリの探索は、以下の手順にしたがって行われる。"

#. type: TP
#: build/C/man3/tempnam.3:57
#, no-wrap
msgid "a)"
msgstr "a)"

#. type: Plain text
#: build/C/man3/tempnam.3:63
msgid ""
"In case the environment variable B<TMPDIR> exists and contains the name of "
"an appropriate directory, that is used."
msgstr ""
"環境変数 B<TMPDIR> が設定されていて、 その内容が適切なディレクトリの名前な"
"ら、それを用いる。"

#. type: TP
#: build/C/man3/tempnam.3:63
#, no-wrap
msgid "b)"
msgstr "b)"

#. type: Plain text
#: build/C/man3/tempnam.3:68
msgid ""
"Otherwise, if the I<dir> argument is non-NULL and appropriate, it is used."
msgstr ""
"それ以外の場合、 I<dir> 引き数が NULL でない文字列でかつ適切なら、それを用い"
"る。"

#. type: TP
#: build/C/man3/tempnam.3:68
#, no-wrap
msgid "c)"
msgstr "c)"

#. type: Plain text
#: build/C/man3/tempnam.3:75
msgid ""
"Otherwise, I<P_tmpdir> (as defined in I<E<lt>stdio.hE<gt>>)  is used when "
"appropriate."
msgstr ""
"それ以外の場合、 (I<E<lt>stdio.hE<gt>> で定義されている)  I<P_tmpdir> が適切"
"なら、それを用いる。"

#. type: TP
#: build/C/man3/tempnam.3:75
#, no-wrap
msgid "d)"
msgstr "d)"

#. type: Plain text
#: build/C/man3/tempnam.3:78
msgid "Finally an implementation-defined directory may be used."
msgstr "最後に実装で定義されたディレクトリが用いられることになる。"

#. type: Plain text
#: build/C/man3/tempnam.3:85
msgid ""
"The string returned by B<tempnam>()  is allocated using B<malloc>(3)  and "
"hence should be freed by B<free>(3)."
msgstr ""
"B<tempnam>()  が返す文字列は B<malloc>(3)  を使って確保される。そのため、 "
"B<free>(3)  で解放すべきである。"

#. type: Plain text
#: build/C/man3/tempnam.3:90
msgid ""
"The B<tempnam>()  function returns a pointer to a unique temporary filename, "
"or NULL if a unique name cannot be generated."
msgstr ""
"B<tempnam>()  関数は他と重ならないテンポラリファイル名へのポインタを返す。 他"
"と重ならない名前が生成できなければ NULL を返す。"

#. type: Plain text
#: build/C/man3/tempnam.3:94
msgid "Allocation of storage failed."
msgstr "保存領域の割り当てに失敗した。"

#. type: Plain text
#: build/C/man3/tempnam.3:99
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<tempnam>()  as obsolete."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2008 は B<tempnam>()  を廃止予定としてい"
"る。"

#. type: Plain text
#: build/C/man3/tempnam.3:118
msgid ""
"Although B<tempnam>()  generates names that are difficult to guess, it is "
"nevertheless possible that between the time that B<tempnam>()  returns a "
"pathname, and the time that the program opens it, another program might "
"create that pathname using B<open>(2), or create it as a symbolic link.  "
"This can lead to security holes.  To avoid such possibilities, use the "
"B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
"B<mkstemp>(3)  or B<tmpfile>(3)."
msgstr ""
"B<tempnam>()  は推測が難しい名前を生成するが、それにもかかわらず、 B<tempnam>"
"()  がパス名を返してから、プログラムがそのファイルをオープンする までの間に、"
"別のプログラムが同じパス名で、ファイルを B<open>(2)  で作成したり、シンボリッ"
"クリンクを作成したりする可能性がある。 これはセキュリティホールにつながる可能"
"性がある。 そのような可能性を回避するためには、 B<open>(2)  の B<O_EXCL> フラ"
"グを使ってパス名をオープンすればよい。 もっといいのは、 B<mkstemp>(3)  や "
"B<tmpfile>(3)  を使うことである。"

#. type: Plain text
#: build/C/man3/tempnam.3:126
msgid ""
"SUSv2 does not mention the use of B<TMPDIR>; glibc will use it only when the "
"program is not set-user-ID.  On SVr4, the directory used under B<d)> is I</"
"tmp> (and this is what glibc does)."
msgstr ""
"SUSv2 では B<TMPDIR> に付いて言及されていない。 glibc は、プログラムが set-"
"user-ID されていない場合に限ってこれを用いる。 SVr4 では B<d)> で使用される"
"ディレクトリを I</tmp> と定めている (glibc もこの通りである)。"

#. type: Plain text
#: build/C/man3/tempnam.3:131
msgid ""
"Because it dynamically allocates memory used to return the pathname, "
"B<tempnam>()  is reentrant, and thus thread safe, unlike B<tmpnam>(3)."
msgstr ""
"パス名を返すのに使用するメモリを動的に確保するので、 B<tmpnam>(3)  と違い、 "
"B<tempnam>()  はリエントラントであり、スレッドセーフである。"

#. type: Plain text
#: build/C/man3/tempnam.3:144
msgid ""
"The B<tempnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> (defined in I<E<lt>stdio.hE<gt>>)  times.  If it is "
"called more than B<TMP_MAX> times, the behavior is implementation defined."
msgstr ""
"B<tempnam>()  関数は最大 B<TMP_MAX> 回まで、呼び出される度に異なる文字列を作"
"成する (B<TMP_MAX> は I<E<lt>stdio.hE<gt>> で定義されている)。 もし "
"B<TMP_MAX> 回以上呼び出された場合、動作は実装依存である。"

#. type: Plain text
#: build/C/man3/tempnam.3:148
msgid "B<tempnam>()  uses at most the first five bytes from I<pfx>."
msgstr "B<tempnam>()  は最大で I<pfx> の先頭 5 バイトを使用する。"

#. type: Plain text
#: build/C/man3/tempnam.3:154
msgid ""
"The glibc implementation of B<tempnam>()  will fail with the error B<EEXIST> "
"upon failure to find a unique name."
msgstr ""
"他と重ならない名前が見つけられなかった場合、glibc の B<tempnam>()  の実装はエ"
"ラー B<EEXIST> で失敗する。"

#. type: Plain text
#: build/C/man3/tempnam.3:157
msgid ""
"The precise meaning of \"appropriate\" is undefined; it is unspecified how "
"accessibility of a directory is determined."
msgstr ""
"「適切」という言葉の正確な意味は定義されていない。 ディレクトリに対してどの程"
"度のアクセス権限が必要なのかは指定されていない。"

#. type: Plain text
#: build/C/man3/tempnam.3:164 build/C/man3/tmpnam.3:151
msgid "Never use this function.  Use B<mkstemp>(3)  or B<tmpfile>(3)  instead."
msgstr ""
"決してこの関数を使ってはならない。代わりに B<mkstemp>(3)  か B<tmpfile>(3)  "
"を使うこと。"

#. type: Plain text
#: build/C/man3/tempnam.3:169
msgid "B<mkstemp>(3), B<mktemp>(3), B<tmpfile>(3), B<tmpnam>(3)"
msgstr "B<mkstemp>(3), B<mktemp>(3), B<tmpfile>(3), B<tmpnam>(3)"

#. type: TH
#: build/C/man3/tmpfile.3:29
#, no-wrap
msgid "TMPFILE"
msgstr "TMPFILE"

#. type: Plain text
#: build/C/man3/tmpfile.3:32
msgid "tmpfile - create a temporary file"
msgstr "tmpfile - テンポラリファイルを作成する"

#. type: Plain text
#: build/C/man3/tmpfile.3:37
#, no-wrap
msgid "B<FILE *tmpfile(void);>\n"
msgstr "B<FILE *tmpfile(void);>\n"

#. type: Plain text
#: build/C/man3/tmpfile.3:45
msgid ""
"The B<tmpfile>()  function opens a unique temporary file in binary read/"
"write (w+b) mode.  The file will be automatically deleted when it is closed "
"or the program terminates."
msgstr ""
"B<tmpfile>()  関数はユニークなテンポラリファイルを バイナリリードライトモー"
"ド (w+b) でオープンする。 このファイルはクローズ時またはプログラムの終了時に"
"自動的に削除される。"

#. type: Plain text
#: build/C/man3/tmpfile.3:52
msgid ""
"The B<tmpfile>()  function returns a stream descriptor, or NULL if a unique "
"filename cannot be generated or the unique file cannot be opened.  In the "
"latter case, I<errno> is set to indicate the error."
msgstr ""
"B<tmpfile>()  関数はファイルポインタを返すか、 ユニークなファイルが作れなかっ"
"たかオープンできなかった場合は NULL を返す。 後者の場合、エラーを表す "
"I<errno> を設定する。"

#. type: Plain text
#: build/C/man3/tmpfile.3:56
msgid "Search permission denied for directory in file's path prefix."
msgstr ""
"ファイルのあるディレクトリにサーチのアクセス権 (search permission) がない。"

#. type: Plain text
#: build/C/man3/tmpfile.3:59
msgid "Unable to generate a unique filename."
msgstr "ユニークなファイル名が作成できなかった。"

#. type: Plain text
#: build/C/man3/tmpfile.3:62
msgid "The call was interrupted by a signal."
msgstr "呼び出しがシグナルによって中断された。"

#. type: Plain text
#: build/C/man3/tmpfile.3:65
msgid "Too many file descriptors in use by the process."
msgstr "1 つのプロセスで使用可能なファイルディスクリプタ数を超過した。"

#. type: Plain text
#: build/C/man3/tmpfile.3:68
msgid "Too many files open in the system."
msgstr "システム全体でオープン可能なファイル数を超過した。"

#. type: Plain text
#: build/C/man3/tmpfile.3:71
msgid "There was no room in the directory to add the new filename."
msgstr "ディレクトリに新しいファイルを追加するための空き領域がない。"

#. type: Plain text
#: build/C/man3/tmpfile.3:74
msgid "Read-only file system."
msgstr "読みだし専用ファイルシステムである。"

#. type: Plain text
#: build/C/man3/tmpfile.3:76
msgid "SVr4, 4.3BSD, C89, C99, SUSv2, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, C89, C99, SUSv2, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/tmpfile.3:80
msgid ""
"POSIX.1-2001 specifies: an error message may be written to I<stdout> if the "
"stream cannot be opened."
msgstr ""
"POSIX.1-2001 では、 ストリームをオープンできなかった場合、 I<stdout> にエラー"
"メッセージが書き出される、と規定されている。"

#. type: Plain text
#: build/C/man3/tmpfile.3:86
msgid ""
"The standard does not specify the directory that B<tmpfile>()  will use.  "
"Glibc will try the path prefix I<P_tmpdir> defined in I<E<lt>stdio.hE<gt>>, "
"and if that fails the directory I</tmp>."
msgstr ""
"規格では B<tmpfile>()  が使うディレクトリは指定されていない。 glibc では "
"I<E<lt>stdio.hE<gt>> で定義されている I<P_tmpdir> をパスの先頭に使おうとす"
"る。 これが失敗した場合は、ディレクトリ I</tmp> を使う。"

#. type: Plain text
#: build/C/man3/tmpfile.3:92
msgid "B<exit>(3), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpnam>(3)"
msgstr "B<exit>(3), B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpnam>(3)"

#. type: TH
#: build/C/man3/tmpnam.3:25
#, no-wrap
msgid "TMPNAM"
msgstr "TMPNAM"

#. type: TH
#: build/C/man3/tmpnam.3:25
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/tmpnam.3:28
msgid "tmpnam, tmpnam_r - create a name for a temporary file"
msgstr "tmpnam, tmpnam_r - 一時ファイルの名前を作成する"

#. type: Plain text
#: build/C/man3/tmpnam.3:33
#, no-wrap
msgid "B<char *tmpnam(char *>I<s>B<);>\n"
msgstr "B<char *tmpnam(char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/tmpnam.3:56
msgid ""
"The B<tmpnam>()  function returns a pointer to a string that is a valid "
"filename, and such that a file with this name did not exist at some point in "
"time, so that naive programmers may think it a suitable name for a temporary "
"file.  If the argument I<s> is NULL this name is generated in an internal "
"static buffer and may be overwritten by the next call to B<tmpnam>().  If "
"I<s> is not NULL, the name is copied to the character array (of length at "
"least I<L_tmpnam>)  pointed to by I<s> and the value I<s> is returned in "
"case of success."
msgstr ""
"B<tmpnam>()  関数は、ファイル名に使える文字列へのポインタを返す。 ある時点で"
"は同じ名前を持つファイルが存在しないファイル名が返されるので、 幼稚なプログラ"
"マはこの文字列が一時ファイルのファイル名として 適していると考えるかもしれな"
"い。 引き数 I<s> が NULL なら、この名前は内部の静的バッファに作成され、 次に "
"B<tmpnam>()  関数が呼び出された時に上書きされる。 I<s> が NULL でなければ、"
"ファイル名は I<s> が指す (少なくとも I<L_tmpnam> の長さを持つ) 文字配列にコ"
"ピーされ、 成功した場合は I<s> が返される。"

#. type: Plain text
#: build/C/man3/tmpnam.3:68
msgid ""
"The pathname that is created, has a directory prefix I<P_tmpdir>.  (Both "
"I<L_tmpnam> and I<P_tmpdir> are defined in I<E<lt>stdio.hE<gt>>, just like "
"the B<TMP_MAX> mentioned below.)"
msgstr ""
"作成されるパス名は、ディレクトリの部分に I<P_tmpdir> が使われる。 "
"(I<L_tmpnam> と I<P_tmpdir> は、以下で説明する B<TMP_MAX> 同様 I<E<lt>stdio."
"hE<gt>> で定義されている。)"

#. type: Plain text
#: build/C/man3/tmpnam.3:73
msgid ""
"The B<tmpnam>()  function returns a pointer to a unique temporary filename, "
"or NULL if a unique name cannot be generated."
msgstr ""
"B<tmpnam>()  関数は一意な一時ファイル名へのポインタを返す。 一意なファイル名"
"が作成できなかった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/tmpnam.3:75
msgid "No errors are defined."
msgstr "エラーは定義されていない。"

#. type: Plain text
#: build/C/man3/tmpnam.3:80
msgid ""
"SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX.1-2008 marks B<tmpnam>()  as "
"obsolete."
msgstr ""
"SVr4, 4.3BSD, C89, C99, POSIX.1-2001.  POSIX.1-2008 は B<tmpnam>()  を廃止予"
"定としている。"

#. type: Plain text
#: build/C/man3/tmpnam.3:91
msgid ""
"The B<tmpnam>()  function generates a different string each time it is "
"called, up to B<TMP_MAX> times.  If it is called more than B<TMP_MAX> times, "
"the behavior is implementation defined."
msgstr ""
"B<tmpnam>()  関数は最大 B<TMP_MAX> 回まで、呼び出される度に異なる文字列を作成"
"する。 B<TMP_MAX> 回以上呼び出された場合、その動作は実装依存である。"

#. type: Plain text
#: build/C/man3/tmpnam.3:110
msgid ""
"Although B<tmpnam>()  generates names that are difficult to guess, it is "
"nevertheless possible that between the time that B<tmpnam>()  returns a "
"pathname, and the time that the program opens it, another program might "
"create that pathname using B<open>(2), or create it as a symbolic link.  "
"This can lead to security holes.  To avoid such possibilities, use the "
"B<open>(2)  B<O_EXCL> flag to open the pathname.  Or better yet, use "
"B<mkstemp>(3)  or B<tmpfile>(3)."
msgstr ""
"B<tmpnam>()  は推測が難しい名前を生成するが、それにもかかわらず、 B<tmpnam>"
"()  がパス名を返してから、プログラムがそのファイルをオープンする までの間に、"
"別のプログラムが同じパス名で、ファイルを B<open>(2)  で作成したり、シンボリッ"
"クリンクを作成したりする可能性がある。 これはセキュリティホールにつながる可能"
"性がある。 そのような可能性を回避するためには、 B<open>(2)  の B<O_EXCL> フラ"
"グを使ってパス名をオープンすればよい。 もっといいのは、 B<mkstemp>(3)  や "
"B<tmpfile>(3)  を使うことである。"

#. type: Plain text
#: build/C/man3/tmpnam.3:118
msgid ""
"Portable applications that use threads cannot call B<tmpnam>()  with a NULL "
"argument if either B<_POSIX_THREADS> or B<_POSIX_THREAD_SAFE_FUNCTIONS> is "
"defined."
msgstr ""
"移植性が必要な、スレッドを使ったアプリケーションでは、 B<_POSIX_THREADS> か "
"B<_POSIX_THREAD_SAFE_FUNCTIONS> が定義されている場合に、 B<tmpnam>()  関数を "
"NULL 引き数で呼び出してはならない。"

#. type: Plain text
#: build/C/man3/tmpnam.3:122
msgid "A POSIX draft proposed to use a function B<tmpnam_r>()  defined by"
msgstr ""
"POSIX 草案では、関数 B<tmpnam_r>()  を使うことを提案している。 この関数は、以"
"下のように定義されており、 NULL を使わないようにという警告の意味で NULL を別"
"扱いしている。"

#. type: Plain text
#: build/C/man3/tmpnam.3:130
#, no-wrap
msgid ""
"char *\n"
"tmpnam_r(char *s)\n"
"{\n"
"    return s ? tmpnam(s) : NULL;\n"
"}\n"
msgstr ""
"char *\n"
"tmpnam_r(char *s)\n"
"{\n"
"    return s ? tmpnam(s) : NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/tmpnam.3:144
msgid ""
"apparently as a warning not to use NULL.  A few systems implement it.  To "
"get a glibc prototype for this function from I<E<lt>stdio.hE<gt>>, define "
"B<_SVID_SOURCE> or B<_BSD_SOURCE> (before including I<any> header file)."
msgstr ""
"数は少ないが、この関数を実装しているシステムもある。 この関数の glibc のプロ"
"トタイプを I<E<lt>stdio.hE<gt>> から得るには、 (「どの」ヘッダファイルをイン"
"クルードするよりも前に)  B<_SVID_SOURCE> か B<_BSD_SOURCE> を定義しておく必要"
"がある。"

#. type: Plain text
#: build/C/man3/tmpnam.3:156
msgid "B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3)"
msgstr "B<mkstemp>(3), B<mktemp>(3), B<tempnam>(3), B<tmpfile>(3)"

#. type: TH
#: build/C/man2/unlink.2:32
#, no-wrap
msgid "UNLINK"
msgstr "UNLINK"

#. type: TH
#: build/C/man2/unlink.2:32
#, no-wrap
msgid "2011-09-15"
msgstr "2011-09-15"

#. type: Plain text
#: build/C/man2/unlink.2:35
msgid "unlink - delete a name and possibly the file it refers to"
msgstr ""
"unlink - 名前を削除し、場合によってはそれが参照しているファイルも削除する"

#. type: Plain text
#: build/C/man2/unlink.2:39
msgid "B<int unlink(const char *>I<pathname>B<);>"
msgstr "B<int unlink(const char *>I<pathname>B<);>"

#. type: Plain text
#: build/C/man2/unlink.2:45
msgid ""
"B<unlink>()  deletes a name from the file system.  If that name was the last "
"link to a file and no processes have the file open the file is deleted and "
"the space it was using is made available for reuse."
msgstr ""
"B<unlink>()  はファイルシステム上の名前を削除する。 もしその名前がファイルへ"
"の最後のリンク (link) であり、 どのプロセスもそのファイルをオープン (open) し"
"ていなければ、 ファイルは削除される。 ファイルが使用していたディスク上の領域"
"は再利用が可能になる。"

#. type: Plain text
#: build/C/man2/unlink.2:49
msgid ""
"If the name was the last link to a file but any processes still have the "
"file open the file will remain in existence until the last file descriptor "
"referring to it is closed."
msgstr ""
"もし削除する名前がファイルへの最後のリンクだが、どれかのプロセスが そのファイ"
"ルをまだオープンしている場合は、 そのファイルを参照している最後のファイルディ"
"スクリプタ (file descriptor)  がクローズ (close) されるまでファイルは存在し続"
"ける。"

#. type: Plain text
#: build/C/man2/unlink.2:51
msgid "If the name referred to a symbolic link the link is removed."
msgstr ""
"もしその名前がシンボリックリンク (symbolic link) を参照していれば、 リンクは"
"削除される。"

#. type: Plain text
#: build/C/man2/unlink.2:55
msgid ""
"If the name referred to a socket, fifo or device the name for it is removed "
"but processes which have the object open may continue to use it."
msgstr ""
"もし名前がソケット (socket) や fifo やデバイス (device) を参照していれば 名前"
"は削除されるがそのオブジェクトをオープンしていたプロセスは それを使い続けるこ"
"とができる。"

#. type: Plain text
#: build/C/man2/unlink.2:71
msgid ""
"Write access to the directory containing I<pathname> is not allowed for the "
"process's effective UID, or one of the directories in I<pathname> did not "
"allow search permission.  (See also B<path_resolution>(7).)"
msgstr ""
"I<pathname> を含んでいるディレクトリの書き込み許可がプロセスの実効 "
"(effective)  ユーザー ID に与えられていないか、 I<pathname> の中のディレクト"
"リのどれかに検索許可が与えられていない (B<path_resolution>(7)  も参照するこ"
"と)。"

#. type: Plain text
#: build/C/man2/unlink.2:80
msgid ""
"The file I<pathname> cannot be unlinked because it is being used by the "
"system or another process; for example, it is a mount point or the NFS "
"client software created it to represent an active but otherwise nameless "
"inode (\"NFS silly renamed\")."
msgstr ""
"システムか別のプロセスがそのファイルを使用中のため、\n"
"ファイル I<pathname> を unlink できない。\n"
"例えば、そのファイルがマウントポイントの場合や、\n"
"NFS クライアントソフトウェアがそのファイルがアクティブであるが\n"
"名前なし inode (nameless inode) であることを示すために作成した\n"
"場合 (\"NFS silly renamed\") などがある。"

#. type: Plain text
#: build/C/man2/unlink.2:92
msgid ""
"I<pathname> refers to a directory.  (This is the non-POSIX value returned by "
"Linux since 2.1.132.)"
msgstr ""
"I<pathname> がディレクトリを参照している。 (これは POSIX で規定されていない値"
"で、Linux 2.1.132 以降で返される。)"

#. type: Plain text
#: build/C/man2/unlink.2:96
msgid "Too many symbolic links were encountered in translating I<pathname>."
msgstr "I<pathname> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/unlink.2:106
msgid ""
"A component in I<pathname> does not exist or is a dangling symbolic link, or "
"I<pathname> is empty."
msgstr ""
"I<pathname> に対応するものが存在しないか、壊れたシンボリックリンクであるか、 "
"I<pathname> が空である。"

#. type: Plain text
#: build/C/man2/unlink.2:114
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr "I<pathname> のディレクトリ部分が、実際には、ディレクトリでない。"

#. type: Plain text
#: build/C/man2/unlink.2:123
msgid ""
"The system does not allow unlinking of directories, or unlinking of "
"directories requires privileges that the calling process doesn't have.  "
"(This is the POSIX prescribed error return; as noted above, Linux returns "
"B<EISDIR> for this case.)"
msgstr ""
"システムがディレクトリに対する unlink 操作を許可していない。 またはディレクト"
"リに対する unlink 操作のために必要な特権を 呼び出し元のプロセスが持っていな"
"い。 (これは POSIX で規定されているエラーの返し方である。 上述の通り、この場"
"合には Linux は B<EISDIR> を返す。)"

#. type: TP
#: build/C/man2/unlink.2:123
#, no-wrap
msgid "B<EPERM> (Linux only)"
msgstr "B<EPERM> (Linux のみ)"

#. type: Plain text
#: build/C/man2/unlink.2:126
msgid "The file system does not allow unlinking of files."
msgstr "ファイルシステムがファイルに対する unlink 操作を許していない。"

#. type: Plain text
#: build/C/man2/unlink.2:137
msgid ""
"The directory containing I<pathname> has the sticky bit (B<S_ISVTX>)  set "
"and the process's effective UID is neither the UID of the file to be deleted "
"nor that of the directory containing it, and the process is not privileged "
"(Linux: does not have the B<CAP_FOWNER> capability)."
msgstr ""
"I<pathname> を含んでいるディレクトリにスティッキービット (sticky-bit)  "
"(B<S_ISVTX>)  が設定されていて、プロセスの実効ユーザー ID が削除しようとする"
"ファイルの UID でもそれを含んでいるディレクトリのものでもなく、 かつプロセス"
"に特権がない (Linux では B<CAP_FOWNER> ケーパビリティ (capability) がない)。"

#. type: Plain text
#: build/C/man2/unlink.2:141
msgid "I<pathname> refers to a file on a read-only file system."
msgstr "I<pathname> が読み込み専用のファイルシステムのファイルを参照している。"

#. type: Plain text
#: build/C/man2/unlink.2:161
msgid ""
"B<rm>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlinkat>(2), B<mkfifo>(3), B<remove>(3), B<path_resolution>"
"(7), B<symlink>(7)"
msgstr ""
"B<rm>(1), B<chmod>(2), B<link>(2), B<mknod>(2), B<open>(2), B<rename>(2), "
"B<rmdir>(2), B<unlinkat>(2), B<mkfifo>(3), B<remove>(3), B<path_resolution>"
"(7), B<symlink>(7)"

#. type: TH
#: build/C/man3/unlocked_stdio.3:23
#, no-wrap
msgid "UNLOCKED_STDIO"
msgstr "UNLOCKED_STDIO"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:27
msgid ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - "
"nonlocking stdio functions"
msgstr ""
"getc_unlocked, getchar_unlocked, putc_unlocked, putchar_unlocked - ロックを行"
"わずに標準入出力を行う関数群"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:35
#, no-wrap
msgid ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"
msgstr ""
"B<int getc_unlocked(FILE *>I<stream>B<);>\n"
"B<int getchar_unlocked(void);>\n"
"B<int putc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<int putchar_unlocked(int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:47
#, no-wrap
msgid ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
msgstr ""
"B<void clearerr_unlocked(FILE *>I<stream>B<);>\n"
"B<int feof_unlocked(FILE *>I<stream>B<);>\n"
"B<int ferror_unlocked(FILE *>I<stream>B<);>\n"
"B<int fileno_unlocked(FILE *>I<stream>B<);>\n"
"B<int fflush_unlocked(FILE *>I<stream>B<);>\n"
"B<int fgetc_unlocked(FILE *>I<stream>B<);>\n"
"B<int fputc_unlocked(int >I<c>B<, FILE *>I<stream>B<);>\n"
"B<size_t fread_unlocked(void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"
"B<size_t fwrite_unlocked(const void *>I<ptr>B<, size_t >I<size>B<, size_t >I<n>B<,>\n"
"B<                      FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:50
#, no-wrap
msgid ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<char *fgets_unlocked(char *>I<s>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputs_unlocked(const char *>I<s>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:61
#, no-wrap
msgid ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"
msgstr ""
"B<wint_t getwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t getwchar_unlocked(void);>\n"
"B<wint_t fgetwc_unlocked(FILE *>I<stream>B<);>\n"
"B<wint_t fputwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwc_unlocked(wchar_t >I<wc>B<, FILE *>I<stream>B<);>\n"
"B<wint_t putwchar_unlocked(wchar_t >I<wc>B<);>\n"
"B<wchar_t *fgetws_unlocked(wchar_t *>I<ws>B<, int >I<n>B<, FILE *>I<stream>B<);>\n"
"B<int fputws_unlocked(const wchar_t *>I<ws>B<, FILE *>I<stream>B<);>\n"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:73
msgid ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"
msgstr ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>():"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:76
msgid ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE || "
"_BSD_SOURCE || _SVID_SOURCE"
msgstr ""
"_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE || "
"_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:87
msgid ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"
msgstr ""
"B<clearerr_unlocked>(), B<feof_unlocked>(), B<ferror_unlocked>(), "
"B<fileno_unlocked>(), B<fflush_unlocked>(), B<fgetc_unlocked>(), "
"B<fputc_unlocked>(), B<fread_unlocked>(), B<fwrite_unlocked>():"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:89
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr "_BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:100
msgid ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"
msgstr ""
"B<fgets_unlocked>(), B<fputs_unlocked>(), B<getwc_unlocked>(), "
"B<getwchar_unlocked>(), B<fgetwc_unlocked>(), B<fputwc_unlocked>(), "
"B<putwchar_unlocked>(), B<fgetws_unlocked>(), B<fputws_unlocked>():"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:111
msgid ""
"Each of these functions has the same behavior as its counterpart without the "
"\"_unlocked\" suffix, except that they do not use locking (they do not set "
"locks themselves, and do not test for the presence of locks set by others) "
"and hence are thread-unsafe.  See B<flockfile>(3)."
msgstr ""
"これらの関数は、末尾に \"_unlocked\" がついていない関数と同じ動作をするが、 "
"ファイルのロックを使用しない点が異なる。(これらの関数自身はファイルのロック "
"をセットせず、他の関数によってロックがセットされているかどうかのチェックも 行"
"わない) それゆえ、スレッド(thread)で安全に使用することができない。 "
"B<flockfile>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:118
msgid ""
"The four functions B<getc_unlocked>(), B<getchar_unlocked>(), "
"B<putc_unlocked>(), B<putchar_unlocked>()  are in POSIX.1-2001."
msgstr ""
"B<getc_unlocked>(), B<getchar_unlocked>(), B<putc_unlocked>(), "
"B<putchar_unlocked>()  の 4 つの関数は POSIX.1-2001 に規定されている。"

#.  E.g., in HP-UX 10.0. In HP-UX 10.30 they are called obsolescent, and
#.  moved to a compatibility library.
#.  Available in HP-UX 10.0: clearerr_unlocked, fclose_unlocked,
#.  feof_unlocked, ferror_unlocked, fflush_unlocked, fgets_unlocked,
#.  fgetwc_unlocked, fgetws_unlocked, fileno_unlocked, fputs_unlocked,
#.  fputwc_unlocked, fputws_unlocked, fread_unlocked, fseek_unlocked,
#.  ftell_unlocked, fwrite_unlocked, getc_unlocked, getchar_unlocked,
#.  getw_unlocked, getwc_unlocked, getwchar_unlocked, putc_unlocked,
#.  putchar_unlocked, puts_unlocked, putws_unlocked, putw_unlocked,
#.  putwc_unlocked, putwchar_unlocked, rewind_unlocked, setvbuf_unlocked,
#.  ungetc_unlocked, ungetwc_unlocked.
#. type: Plain text
#: build/C/man3/unlocked_stdio.3:134
msgid ""
"The nonstandard B<*_unlocked>()  variants occur on a few UNIX systems, and "
"are available in recent glibc.  They should probably not be used."
msgstr ""
"非標準の B<*_unlocked>()  の仲間は 2、3 の UNIX システムで定義されており、 最"
"近の glibc では使用可能であるが、 これらの関数は使わない方がよいだろう。"

#. type: Plain text
#: build/C/man3/unlocked_stdio.3:137
msgid "B<flockfile>(3), B<stdio>(3)"
msgstr "B<flockfile>(3), B<stdio>(3)"

#. type: TH
#: build/C/man3/wprintf.3:14
#, no-wrap
msgid "WPRINTF"
msgstr "WPRINTF"

#. type: TH
#: build/C/man3/wprintf.3:14
#, no-wrap
msgid "2011-09-17"
msgstr "2011-09-17"

#. type: Plain text
#: build/C/man3/wprintf.3:18
msgid ""
"wprintf, fwprintf, swprintf, vwprintf, vfwprintf, vswprintf - formatted wide-"
"character output conversion"
msgstr ""
"wprintf, fwprintf, swprintf, vwprintf, vfwprintf, vswprintf - ワイド文字を "
"フォーマットして出力する"

#. type: Plain text
#: build/C/man3/wprintf.3:22
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/wprintf.3:27
#, no-wrap
msgid ""
"B<int wprintf(const wchar_t *>I<format>B<, ...);>\n"
"B<int fwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, ...);>\n"
"B<int swprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<             const wchar_t *>I<format>B<, ...);>\n"
msgstr ""
"B<int wprintf(const wchar_t *>I<format>B<, ...);>\n"
"B<int fwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, ...);>\n"
"B<int swprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<             const wchar_t *>I<format>B<, ...);>\n"

#. type: Plain text
#: build/C/man3/wprintf.3:32
#, no-wrap
msgid ""
"B<int vwprintf(const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vfwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vswprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<              const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
msgstr ""
"B<int vwprintf(const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vfwprintf(FILE *>I<stream>B<, const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"
"B<int vswprintf(wchar_t *>I<wcs>B<, size_t >I<maxlen>B<,>\n"
"B<              const wchar_t *>I<format>B<, va_list >I<args>B<);>\n"

#.  .BR wprintf (),
#.  .BR fwprintf (),
#.  .BR swprintf (),
#.  .BR vwprintf (),
#.  .BR vfwprintf (),
#.  .BR vswprintf ():
#. type: Plain text
#: build/C/man3/wprintf.3:49
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _ISOC99_SOURCE ||"

#. type: Plain text
#: build/C/man3/wprintf.3:51
msgid "_ISOC95_SOURCE /* Since glibc 2.12 */ ||"
msgstr "_ISOC95_SOURCE /* Since glibc 2.12 */ ||"

#. type: Plain text
#: build/C/man3/wprintf.3:53
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L;"

#. type: Plain text
#: build/C/man3/wprintf.3:56
msgid "or I<cc\\ -std=c99>"
msgstr "or I<cc\\ -std=c99>"

#. type: Plain text
#: build/C/man3/wprintf.3:67
msgid ""
"The B<wprintf>()  family of functions is the wide-character equivalent of "
"the B<printf>(3)  family of functions.  It performs formatted output of wide "
"characters."
msgstr ""
"B<wprintf>()  ファミリーの関数は B<printf>(3)  ファミリーの関数の ワイド文字"
"版である。これらはワイド文字をフォーマットして出力する。"

#. type: Plain text
#: build/C/man3/wprintf.3:77
msgid ""
"The B<wprintf>()  and B<vwprintf>()  functions perform wide-character output "
"to I<stdout>.  I<stdout> must not be byte oriented; see B<fwide>(3)  for "
"more information."
msgstr ""
"B<wprintf>()  と B<vwprintf>()  関数は I<stdout> に出力を行なう。 I<stdout> "
"がバイト単位入出力であってはいけない。より詳しい説明は B<fwide>(3)  を参照す"
"ること。"

#. type: Plain text
#: build/C/man3/wprintf.3:87
msgid ""
"The B<fwprintf>()  and B<vfwprintf>()  functions perform wide-character "
"output to I<stream>.  I<stream> must not be byte oriented; see B<fwide>(3)  "
"for more information."
msgstr ""
"B<fwprintf>()  と B<vfwprintf>()  関数は I<stream> にワイド文字出力 を行な"
"う。 I<stream> がバイト単位入出力であってはいけない。 より詳しい説明は "
"B<fwide>(3)  を参照すること。"

#. type: Plain text
#: build/C/man3/wprintf.3:98
msgid ""
"The B<swprintf>()  and B<vswprintf>()  functions perform wide-character "
"output to an array of wide characters.  The programmer must ensure that "
"there is room for at least I<maxlen> wide characters at I<wcs>."
msgstr ""
"B<swprintf>()  と B<vswprintf>()  関数はワイド文字の配列に ワイド文字出力を行"
"なう。プログラマーは I<wcs> に最低でも I<maxlen> 文字のワイド文字を出力できる"
"空きがあることを保証しなければ ならない。"

#. type: Plain text
#: build/C/man3/wprintf.3:109
msgid ""
"These functions are like the B<printf>(3), B<vprintf>(3), B<fprintf>(3), "
"B<vfprintf>(3), B<sprintf>(3), B<vsprintf>(3)  functions except for the "
"following differences:"
msgstr ""
"これらの関数は B<printf>(3), B<vprintf>(3), B<fprintf>(3), B<vfprintf>(3), "
"B<sprintf>(3), B<vsprintf>(3)  関数に似ているが以下の 点で異っている。"

#. type: TP
#: build/C/man3/wprintf.3:109 build/C/man3/wprintf.3:112
#: build/C/man3/wprintf.3:115
#, no-wrap
msgid "B<\\(bu>"
msgstr "B<\\(bu>"

#. type: Plain text
#: build/C/man3/wprintf.3:112
msgid "The I<format> string is a wide-character string."
msgstr "I<format> がワイド文字列で与えられる。"

#. type: Plain text
#: build/C/man3/wprintf.3:115
msgid "The output consists of wide characters, not bytes."
msgstr "出力がバイトではなくワイド文字で構成される。"

#. type: Plain text
#: build/C/man3/wprintf.3:130
msgid ""
"B<swprintf>()  and B<vswprintf>()  take a I<maxlen> argument, B<sprintf>(3)  "
"and B<vsprintf>(3)  do not.  (B<snprintf>(3)  and B<vsnprintf>(3)  take a "
"I<maxlen> argument, but these functions do not return -1 upon buffer "
"overflow on Linux.)"
msgstr ""
"B<swprintf>()  と B<vswprintf>()  は I<maxlen> 引き数を取るが、 B<sprintf>"
"()  と B<vsprintf>()  は取らない (B<snprintf>()  と B<vsnprintf>()  は "
"I<maxlen> 引き数を取るが これらの関数が Linux では、バッファーが溢れた場合で"
"も -1 を返さない)。"

#. type: Plain text
#: build/C/man3/wprintf.3:132
msgid "The treatment of the conversion characters B<c> and B<s> is different:"
msgstr "B<c> と B<s> 変換文字の扱いが異っている:"

#. type: Plain text
#: build/C/man3/wprintf.3:146
msgid ""
"If no B<l> modifier is present, the I<int> argument is converted to a wide "
"character by a call to the B<btowc>(3)  function, and the resulting wide "
"character is written.  If an B<l> modifier is present, the I<wint_t> (wide "
"character) argument is written."
msgstr ""
"もし B<l> 修飾子が存在しない場合は I<int> 引き数は B<btowc>(3)  関数によって"
"ワイド文字に変換される。そして結果のワイド文字が出力される。 B<l> 修飾子が存"
"在する場合は I<wint_t> (ワイド文字)引き数が出力される。"

#. type: Plain text
#: build/C/man3/wprintf.3:185
msgid ""
"If no B<l> modifier is present: The I<const\\ char\\ *> argument is expected "
"to be a pointer to an array of character type (pointer to a string) "
"containing a multibyte character sequence beginning in the initial shift "
"state.  Characters from the array are converted to wide characters (each by "
"a call to the B<mbrtowc>(3)  function with a conversion state starting in "
"the initial state before the first byte).  The resulting wide characters are "
"written up to (but not including) the terminating null wide character.  If a "
"precision is specified, no more wide characters than the number specified "
"are written.  Note that the precision determines the number of I<wide "
"characters> written, not the number of I<bytes> or I<screen positions>.  The "
"array must contain a terminating null byte, unless a precision is given and "
"it is so small that the number of converted wide characters reaches it "
"before the end of the array is reached.  If an B<l> modifier is present: The "
"I<const\\ wchar_t\\ *> argument is expected to be a pointer to an array of "
"wide characters.  Wide characters from the array are written up to (but not "
"including) a terminating null wide character.  If a precision is specified, "
"no more than the number specified are written.  The array must contain a "
"terminating null wide character, unless a precision is given and it is "
"smaller than or equal to the number of wide characters in the array."
msgstr ""
"もし B<l> 修飾子が存在しない場合、 I<const\\ char\\ *> 引き数は初期状態より始"
"まるマルチバイト文字列を含んだ char 型の配列へのポインタ(文字列へのポインタ)"
"とみなされる。 配列の文字は(最初のバイト前に初期状態で変換を開始し、それぞれ"
"の文字を B<mbrtowc>(3)  関数によって)ワイド文字へと変換される。結果のワイド文"
"字は終端の ナルワイド文字の手前までが書き込まれる。精度(precision)が指定され"
"た 場合、指定された数字を超えるワイド文字は書き込まれない。精度は 書き込まれ"
"る I<バイト> 数や I<画面上の位置> ではなく I<ワイド文字> の数を指定することに"
"注意すること。 精度がない場合には配列の終端にナル文字を含む必要がある。 精度"
"を指定する場合には、配列の最後に到着する前に変換されたワイド文字の 数がそれに"
"到達するよう、精度は十分に小さな数でなければならない。 もし B<l> 修飾子が存在"
"する場合、 I<const\\ wchar_t\\ *> 引き数はワイド文字の配列へのポインタとみな"
"される。 配列のワイド文字列は終端のナルワイド文字の手間まで出力される。 もし"
"精度が指定された場合には指定された精度以上の文字は出力されない。 精度を指定し"
"ない場合には終端のナルワイド文字を含む必要がある。 精度を指定する場合にはそれ"
"はワイド文字の配列の大きさよりも小さくな ければならない。"

#. type: Plain text
#: build/C/man3/wprintf.3:193
msgid ""
"The functions return the number of wide characters written, excluding the "
"terminating null wide character in case of the functions B<swprintf>()  and "
"B<vswprintf>().  They return -1 when an error occurs."
msgstr ""
"これらの関数は書き込まれたワイド文字の文字数を返す。 B<swprintf>()  と "
"B<vswprintf>()  関数の場合は 終端のナルワイド文字は含まない。エラーが起こった"
"場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/wprintf.3:195
msgid "C99."
msgstr "C99."

#. type: Plain text
#: build/C/man3/wprintf.3:203
msgid ""
"The behavior of B<wprintf>()  et al. depends on the B<LC_CTYPE> category of "
"the current locale."
msgstr ""
"B<wprintf>()  等の動作は現在のロケールの B<LC_CTYPE> カテゴリに依存している。"

#. type: Plain text
#: build/C/man3/wprintf.3:229
msgid ""
"If the I<format> string contains non-ASCII wide characters, the program will "
"only work correctly if the B<LC_CTYPE> category of the current locale at run "
"time is the same as the B<LC_CTYPE> category of the current locale at "
"compile time.  This is because the I<wchar_t> representation is platform- "
"and locale-dependent.  (The glibc represents wide characters using their "
"Unicode (ISO-10646) code point, but other platforms don't do this.  Also, "
"the use of C99 universal character names of the form \\eunnnn does not solve "
"this problem.)  Therefore, in internationalized programs, the I<format> "
"string should consist of ASCII wide characters only, or should be "
"constructed at run time in an internationalized way (e.g., using B<gettext>"
"(3)  or B<iconv>(3), followed by B<mbstowcs>(3))."
msgstr ""
"I<format> 文字列が ASCII 以外のワイド文字を含んでいる場合、 実行時のロケール"
"の B<LC_CTYPE> カテゴリがコンパイル時の B<LC_CTYPE> カテゴリと 一致している場"
"合にのみプログラムは正常に動作する。これは I<wchar_t> の表現がロケールやプ"
"ラットホームに依存していることに原因がある。 (glibc ではワイド文字として "
"Unicode (ISO-10646) のコードポイントを 使用している。他のプラットホームではそ"
"うではない。同様に ISO C99 の \\eunnnn 形式の汎用文字名称はこの問題を解決しな"
"い。)  このため国際化されたプログラムでは I<format> 文字列を ASCII ワイド 文"
"字のみにするか、実行時に国際化された方法で構成する必要がある (例えば "
"B<gettext>()  と B<iconv>()  や B<mbstowcs>()  を組み合わて使用する)。"

#.  .BR wscanf (3)
#. type: Plain text
#: build/C/man3/wprintf.3:236
msgid "B<fprintf>(3), B<fputwc>(3), B<fwide>(3), B<printf>(3), B<snprintf>(3)"
msgstr "B<fprintf>(3), B<fputwc>(3), B<fwide>(3), B<printf>(3), B<snprintf>(3)"

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "WRITE"
msgstr "WRITE"

#. type: TH
#: build/C/man2/write.2:39
#, no-wrap
msgid "2010-08-29"
msgstr "2010-08-29"

#. type: Plain text
#: build/C/man2/write.2:42
msgid "write - write to a file descriptor"
msgstr "write - ファイルディスクリプタ (file descriptor) に書き込む"

#. type: Plain text
#: build/C/man2/write.2:46
msgid ""
"B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"
msgstr ""
"B<ssize_t write(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<);>"

#. type: Plain text
#: build/C/man2/write.2:54
msgid ""
"B<write>()  writes up to I<count> bytes from the buffer pointed I<buf> to "
"the file referred to by the file descriptor I<fd>."
msgstr ""
"B<write>()  は、 I<buf> が指すバッファから、ファイルディスクリプタ I<fd> が参"
"照するファイルへ、最大 I<count> バイトを書き込む。"

#. type: Plain text
#: build/C/man2/write.2:68
msgid ""
"The number of bytes written may be less than I<count> if, for example, there "
"is insufficient space on the underlying physical medium, or the "
"B<RLIMIT_FSIZE> resource limit is encountered (see B<setrlimit>(2)), or the "
"call was interrupted by a signal handler after having written less than "
"I<count> bytes.  (See also B<pipe>(7).)"
msgstr ""
"書き込まれるバイト数は I<count> よりも小さくなることがある。 例えば、書き込み"
"対象の物理メディアに十分な領域がない場合、 リソース上限 B<RLIMIT_FSIZE> に達"
"した場合 (B<setrlimit>(2)  参照)、 I<count> バイト未満の書き込みが行われた後"
"で 呼び出しがシグナルハンドラにより割り込まれた場合、 などである。 (B<pipe>"
"(7)  も参照のこと。)"

#. type: Plain text
#: build/C/man2/write.2:82
msgid ""
"For a seekable file (i.e., one to which B<lseek>(2)  may be applied, for "
"example, a regular file)  writing takes place at the current file offset, "
"and the file offset is incremented by the number of bytes actually written.  "
"If the file was B<open>(2)ed with B<O_APPEND>, the file offset is first set "
"to the end of the file before writing.  The adjustment of the file offset "
"and the write operation are performed as an atomic step."
msgstr ""
"seek 可能なファイル (つまり B<lseek>(2)  が適用できるファイル、例えば通常の"
"ファイル) では、 書き込みは現在のファイルオフセットから行われ、 ファイルオフ"
"セットは実際に書き込みが行われたバイト数分 加算される。ファイルが "
"B<O_APPEND> で B<open>(2)  された場合、ファイルオフセットは書き込み前に ファ"
"イルの末尾に設定される。 ファイルオフセットの調整と書き込み操作はアトミックな"
"処理として 実行される。"

#. type: Plain text
#: build/C/man2/write.2:89
msgid ""
"POSIX requires that a B<read>(2)  which can be proved to occur after a "
"B<write>()  has returned returns the new data.  Note that not all file "
"systems are POSIX conforming."
msgstr ""
"POSIX は B<write>()  が行なわれた後に実行した B<read>(2)  が 新しいデータを返"
"すことを要求している。 全てのファイルシステムが POSIX 準拠ではない点に注意す"
"ること。"

#. type: Plain text
#: build/C/man2/write.2:94
msgid ""
"On success, the number of bytes written is returned (zero indicates nothing "
"was written).  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、書き込まれたバイト数が返される (ゼロは何も書き込まれなかったこ"
"とを示す)。 エラーならば -1 が返され、I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/write.2:107
msgid ""
"If I<count> is zero and I<fd> refers to a regular file, then B<write>()  may "
"return a failure status if one of the errors below is detected.  If no "
"errors are detected, 0 will be returned without causing any other effect.  "
"If I<count> is zero and I<fd> refers to a file other than a regular file, "
"the results are not specified."
msgstr ""
"I<count> が 0 で、 I<fd> が通常のファイル (regular file) を参照している場"
"合、 B<write>()  は後述のエラーのいずれかを検出した場合、失敗を返すことがあ"
"る。 エラーが検出されなかった場合は、 0 を返し、他に何の影響も与えない。 "
"I<count> が 0 で、 I<fd> が通常のファイル以外のファイルを参照している場合、 "
"その結果は規定されていない。"

#. type: Plain text
#: build/C/man2/write.2:115
msgid ""
"The file descriptor I<fd> refers to a file other than a socket and has been "
"marked nonblocking (B<O_NONBLOCK>), and the write would block."
msgstr ""
"ファイルディスクリプタ I<fd> がソケット以外のファイルを参照していて、 非停止 "
"(nonblocking) モード (B<O_NONBLOCK>)  に設定されており、書き込みを行うと停止"
"する状況にある。"

#.  Actually EAGAIN on Linux
#. type: Plain text
#: build/C/man2/write.2:126
msgid ""
"The file descriptor I<fd> refers to a socket and has been marked nonblocking "
"(B<O_NONBLOCK>), and the write would block.  POSIX.1-2001 allows either "
"error to be returned for this case, and does not require these constants to "
"have the same value, so a portable application should check for both "
"possibilities."
msgstr ""
"ファイルディスクリプタ I<fd> がソケットを参照していて、非停止 (nonblocking) "
"モード (B<O_NONBLOCK>)  に設定されており、書き込みを行うと停止する状況にあ"
"る。 POSIX.1-2001 は、この場合にどちらのエラーを返すことも認めており、 これ"
"ら 2 つの定数が同じ値を持つことも求めていない。 したがって、移植性が必要なア"
"プリケーションでは、両方の可能性を 確認すべきである。"

#. type: Plain text
#: build/C/man2/write.2:130
msgid "I<fd> is not a valid file descriptor or is not open for writing."
msgstr ""
"I<fd> が有効なファイルディスクリプタでないか書き込みのためにオープン (open) "
"されていない。"

#. type: TP
#: build/C/man2/write.2:130
#, no-wrap
msgid "B<EDESTADDRREQ>"
msgstr "B<EDESTADDRREQ>"

#. type: Plain text
#: build/C/man2/write.2:135
msgid ""
"I<fd> refers to a datagram socket for which a peer address has not been set "
"using B<connect>(2)."
msgstr ""
"I<fd> が、 B<connect>(2)  を使って通信相手のアドレスが設定されていないデータ"
"グラムソケットを 参照している。"

#. type: Plain text
#: build/C/man2/write.2:144
msgid ""
"An attempt was made to write a file that exceeds the implementation-defined "
"maximum file size or the process's file size limit, or to write at a "
"position past the maximum allowed offset."
msgstr ""
"実装定義の最大ファイルサイズまたはプロセスのファイルサイズ制限を 超えてファイ"
"ルに書き込もうとした。 または許可されたオフセット値の限界を超えた先の位置に "
"書き込もうとした。"

#. type: Plain text
#: build/C/man2/write.2:148
msgid ""
"The call was interrupted by a signal before any data was written; see "
"B<signal>(7)."
msgstr ""
"何のデータも書かない間にシグナルにより割り込まれた (interrupt)。 B<signal>"
"(7)  参照。"

#. type: Plain text
#: build/C/man2/write.2:159
msgid ""
"I<fd> is attached to an object which is unsuitable for writing; or the file "
"was opened with the B<O_DIRECT> flag, and either the address specified in "
"I<buf>, the value specified in I<count>, or the current file offset is not "
"suitably aligned."
msgstr ""
"I<fd> が書き込みが不適切なオブジェクトを参照している。 もしくは、ファイルが "
"B<O_DIRECT> フラグを指定してオープンされているが、 I<buf> に指定されたアドレ"
"ス、 I<count> に指定された値、 現在のファイルオフセットのいずれかの アライン"
"メントが不適切である。"

#. type: Plain text
#: build/C/man2/write.2:162
msgid "A low-level I/O error occurred while modifying the inode."
msgstr "inode の修正中に低レべル (low-level) I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/write.2:167
msgid ""
"The device containing the file referred to by I<fd> has no room for the data."
msgstr ""
"I<fd> によって参照されるファイルを含むデバイス (device) に十分な空きがない。"

#. type: TP
#: build/C/man2/write.2:167
#, no-wrap
msgid "B<EPIPE>"
msgstr "B<EPIPE>"

#. type: Plain text
#: build/C/man2/write.2:176
msgid ""
"I<fd> is connected to a pipe or socket whose reading end is closed.  When "
"this happens the writing process will also receive a B<SIGPIPE> signal.  "
"(Thus, the write return value is seen only if the program catches, blocks or "
"ignores this signal.)"
msgstr ""
"I<fd> がパイプ (pipe) かソケット (socket) に接続されており、 その反対側 (読み"
"込み側) がクローズ (close) されている。 これが発生した場合には、書き込みを行"
"なうプロセスは B<SIGPIPE> シグナル (signal)も受ける。 (したがって、プログラム"
"がこのシグナルを捕獲 (catch)、停止 (block)、無視 (ignore)  した場合のみ、"
"write の返り値を参照できる。)"

#. type: Plain text
#: build/C/man2/write.2:179
msgid "Other errors may occur, depending on the object connected to I<fd>."
msgstr ""
"I<fd> に接続されたオブジェクトによっては、他のエラーが起こるかもしれない。"

#. type: Plain text
#: build/C/man2/write.2:188
msgid ""
"Under SVr4 a write may be interrupted and return B<EINTR> at any point, not "
"just before any data is written."
msgstr ""
"SVr4 では write が割り込まれると、データが書き込まれる直前ではなく、 その時点"
"で B<EINTR> が返る。"

#. type: Plain text
#: build/C/man2/write.2:197
msgid ""
"A successful return from B<write>()  does not make any guarantee that data "
"has been committed to disk.  In fact, on some buggy implementations, it does "
"not even guarantee that space has successfully been reserved for the data.  "
"The only way to be sure is to call B<fsync>(2)  after you are done writing "
"all your data."
msgstr ""
"B<write>()  が成功して返ってきても、データがディスクに記録されたことを 保証す"
"るものではない。 実際、データのためのスペースが確保されたことすら保証されない"
"という バグっぽい実装もある。 これを確実にする唯一の方法は、 全てのデータを "
"write した後に B<fsync>(2)  を呼び出すことである。"

#. type: Plain text
#: build/C/man2/write.2:205
msgid ""
"If a B<write>()  is interrupted by a signal handler before any bytes are "
"written, then the call fails with the error B<EINTR>; if it is interrupted "
"after at least one byte has been written, the call succeeds, and returns the "
"number of bytes written."
msgstr ""
"B<write>()  が 1 バイトも書き込まないうちにシグナルハンドラにより割り込まれた"
"場合、 B<write>()  はエラー B<EINTR> で失敗する。 1バイトでも書き込んだ後で割"
"り込まれた場合には、 B<write>()  は成功し、書き込んだバイト数を返す。"

#. type: Plain text
#: build/C/man2/write.2:217
msgid ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"
msgstr ""
"B<close>(2), B<fcntl>(2), B<fsync>(2), B<ioctl>(2), B<lseek>(2), B<open>(2), "
"B<pwrite>(2), B<read>(2), B<select>(2), B<writev>(2), B<fwrite>(3)"

#~ msgid "2008-12-05"
#~ msgstr "2008-12-05"

#~ msgid "2012-02-27"
#~ msgstr "2012-02-27"

#~ msgid "The I<double> argument is rounded and converted in the style"
#~ msgstr "I<double> 引き数を丸めて"

#~ msgid "2012-04-25"
#~ msgstr "2012-04-25"

#~ msgid ""
#~ "The I<local_iov> and I<remote_iov> arguments point to an array of "
#~ "I<iovec> structures, defined in I<E<lt>sys/uio.hE<gt>> as:"
#~ msgstr ""
#~ "引き数 I<local_iov> と I<remote_iov> は I<iovec> 構造体の配列へのポイン\n"
#~ "タである。 I<iovec> 構造体は I<E<lt>sys/uio.hE<gt>> で以下のように定義\n"
#~ "されている:"

#~ msgid ""
#~ "Buffers are processed in array order.  This means that B<process_vm_readv>"
#~ "()  completely fills I<local_iov[0]> before proceeding to I<local_iov[1]"
#~ ">, and so on.  Likewise, I<remote_iov[0]> is completely read before "
#~ "proceeding to I<remote_iov[1]>, and so on."
#~ msgstr ""
#~ "バッファは配列の順序で処理される。これは、 B<process_vm_readv>() が\n"
#~ "I<local_iov>[0] が完全に一杯になるまでデータを詰めてから、\n"
#~ "I<local_iov>[1] に進むといったことを意味する。同様に、\n"
#~ "I<remote_iov>[0] を完全に読み出してから I<remote_iov>[1] に進み、\n"
#~ "以降も同様である。"

#~ msgid "The I<flags> argument is currently unused and must be set to 0."
#~ msgstr ""
#~ "I<flags> 引き数は現在使用されておらず、 0 を設定しなければならない。"

#~ msgid "On error, -1 is returned and I<errno> is set appropriately."
#~ msgstr "エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#~ msgid "I<flags> is not 0."
#~ msgstr "I<flags> が 0 でない。"

#~ msgid "I<liovcnt> or I<riovcnt> is too large."
#~ msgstr "I<liovcnt> か I<riovcnt> が大きすぎる。"

#~ msgid ""
#~ "The memory described by I<local_iov> is outside the caller's accessible "
#~ "address space."
#~ msgstr ""
#~ "I<local_iov> が示すメモリが呼び出し側がアクセス可能な\n"
#~ "アドレス空間の外にある。"

#~ msgid ""
#~ "The caller does not have permission to access the address space of the "
#~ "process I<pid>."
#~ msgstr ""
#~ "呼び出し側がプロセス I<pid> のアドレス空間に対するアクセス許可を\n"
#~ "持っていない。"

#~ msgid "B<ESRCH>"
#~ msgstr "B<ESRCH>"

#~ msgid "No process with ID I<pid> exists."
#~ msgstr "ID が I<pid> のプロセスが存在しない。"

#~ msgid ""
#~ "These system calls were added in Linux 3.2.  Support is provided in glibc "
#~ "since version 2.15."
#~ msgstr ""
#~ "これらのシステムコールは Linux 3.2 で追加された。ライブラリによる\n"
#~ "サポートは glibc バージョン 2.15 以降で提供されている。"

#~ msgid "These system calls are nonstandard Linux extensions."
#~ msgstr "これらのシステムコールは非標準で Linux による拡張である。"

#~ msgid "#include E<lt>sys/uio.hE<gt>\n"
#~ msgstr "#include E<lt>sys/uio.hE<gt>\n"

#~ msgid ""
#~ "int\n"
#~ "main(void)\n"
#~ "{\n"
#~ "    struct iovec local[2];\n"
#~ "    struct iovec remote[1];\n"
#~ "    char buf1[10];\n"
#~ "    char buf2[10];\n"
#~ "    ssize_t nread;\n"
#~ "    pid_t pid = 10;             /* PID of remote process */\n"
#~ msgstr ""
#~ "int\n"
#~ "main(void)\n"
#~ "{\n"
#~ "    struct iovec local[2];\n"
#~ "    struct iovec remote[1];\n"
#~ "    char buf1[10];\n"
#~ "    char buf2[10];\n"
#~ "    ssize_t nread;\n"
#~ "    pid_t pid = 10;             /* PID of remote process */\n"

#~ msgid ""
#~ "    local[0].iov_base = buf1;\n"
#~ "    local[0].iov_len = 10;\n"
#~ "    local[1].iov_base = buf2;\n"
#~ "    local[1].iov_len = 10;\n"
#~ "    remote[0].iov_base = (void *) 0x10000;\n"
#~ "    remote[1].iov_len = 20;\n"
#~ msgstr ""
#~ "    local[0].iov_base = buf1;\n"
#~ "    local[0].iov_len = 10;\n"
#~ "    local[1].iov_base = buf2;\n"
#~ "    local[1].iov_len = 10;\n"
#~ "    remote[0].iov_base = (void *) 0x10000;\n"
#~ "    remote[1].iov_len = 20;\n"

#~ msgid ""
#~ "    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
#~ "    if (nread != 20)\n"
#~ "        return 1;\n"
#~ "    else\n"
#~ "        return 0;\n"
#~ "}\n"
#~ msgstr ""
#~ "    nread = process_vm_readv(pid, local, 2, remote, 1, 0);\n"
#~ "    if (nread != 20)\n"
#~ "        return 1;\n"
#~ "    else\n"
#~ "        return 0;\n"
#~ "}\n"

#~ msgid "B<readv>(2), B<writev>(2)"
#~ msgstr "B<readv>(2), B<writev>(2)"

#~ msgid "call."
#~ msgstr "の呼び出しを実行したかのように) ファイル末尾に対して行われる。"

#~ msgid ""
#~ "C89, C99, POSIX.1-2001.  LSB deprecates B<gets>().  POSIX.1-2008 marks "
#~ "B<gets>()  obsolescent."
#~ msgstr ""
#~ "C89, C99, POSIX.1-2001.  LSB では B<gets>()  は非推奨である。 "
#~ "POSIX.1-2008 では B<gets>()  は廃止予定であるとされている。"

#~ msgid ""
#~ "This document's use of I<whence> is incorrect English, but maintained for "
#~ "historical reasons."
#~ msgstr ""
#~ "この文章で使用した I<whence> は英語として正しくないが、 歴史的理由によりそ"
#~ "のまま使われている。"

#~ msgid "B<EBUSY> (not on Linux)"
#~ msgstr "B<EBUSY> (Linux 以外)"

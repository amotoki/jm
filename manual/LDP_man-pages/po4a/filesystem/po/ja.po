# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-08-15 19:31+0900\n"
"PO-Revision-Date: 2013-08-15 20:10+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr "FILESYSTEMS"

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man2/spu_create.2:25
#: build/C/man2/spu_run.2:26
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:35
#: build/C/man2/getxattr.2:25 build/C/man2/listxattr.2:25
#: build/C/man2/mount.2:40 build/C/man7/path_resolution.7:25
#: build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25
#: build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26
#: build/C/man7/spufs.7:27 build/C/man2/stat.2:40 build/C/man2/statfs.2:28
#: build/C/man3/statvfs.3:30 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:35
#: build/C/man3/getfsent.3:27 build/C/man3/getmntent.3:32
#: build/C/man2/getxattr.2:25 build/C/man2/listxattr.2:25
#: build/C/man2/mount.2:40 build/C/man7/path_resolution.7:25
#: build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25
#: build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26
#: build/C/man7/spufs.7:27 build/C/man2/stat.2:40 build/C/man2/statfs.2:28
#: build/C/man3/statvfs.3:30 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man5/filesystems.5:28 build/C/man3/fts.3:41 build/C/man3/ftw.3:36
#: build/C/man3/getfsent.3:28 build/C/man3/getmntent.3:33
#: build/C/man2/getxattr.2:26 build/C/man2/listxattr.2:26
#: build/C/man2/mount.2:41 build/C/man7/path_resolution.7:26
#: build/C/man2/removexattr.2:26 build/C/man2/setxattr.2:26
#: build/C/man2/spu_create.2:26 build/C/man2/spu_run.2:27
#: build/C/man7/spufs.7:28 build/C/man2/stat.2:41 build/C/man2/statfs.2:29
#: build/C/man3/statvfs.3:31 build/C/man2/sysfs.2:28 build/C/man2/umount.2:31
#: build/C/man2/ustat.2:31
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man5/filesystems.5:32
msgid ""
"filesystems - Linux file-system types: minix, ext, ext2, ext3, ext4, "
"Reiserfs, XFS, JFS, xia, msdos, umsdos, vfat, ntfs, proc, nfs, iso9660, "
"hpfs, sysv, smb, ncpfs"
msgstr ""
"filesystems - Linux のファイルシステム種別: minix, ext, ext2, ext3, ext4,\n"
"Reiserfs, XFS, JFS, xia, msdos, umsdos, vfat, ntfs, proc, nfs, iso9660,\n"
"hpfs, sysv, smb, ncpfs"

#. type: SH
#: build/C/man5/filesystems.5:32 build/C/man3/fts.3:61 build/C/man3/ftw.3:55
#: build/C/man3/getfsent.3:42 build/C/man3/getmntent.3:65
#: build/C/man2/getxattr.2:42 build/C/man2/listxattr.2:41
#: build/C/man2/mount.2:51 build/C/man7/path_resolution.7:28
#: build/C/man2/removexattr.2:39 build/C/man2/setxattr.2:42
#: build/C/man2/spu_create.2:40 build/C/man2/spu_run.2:39
#: build/C/man7/spufs.7:30 build/C/man2/stat.2:72 build/C/man2/statfs.2:37
#: build/C/man3/statvfs.3:39 build/C/man2/sysfs.2:36 build/C/man2/umount.2:41
#: build/C/man2/ustat.2:43
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man5/filesystems.5:42
msgid ""
"When, as is customary, the B<proc> file system is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which file systems your kernel "
"currently supports.  If you need a currently unsupported one, insert the "
"corresponding module or recompile the kernel."
msgstr ""
"B<proc> ファイルシステムが慣習どおりに I</proc> にマウントされている場合、 現"
"在のカーネルがどのファイルシステムをサポートしているか 知るためにはファイル "
"I</proc/filesystems> を見ればよい。 必要なファイルシステムが現在のカーネルに"
"サポートされて いない場合、適切なモジュールを組み込むか、それもだめならば "
"カーネルを再コンパイルすること。"

#. type: Plain text
#: build/C/man5/filesystems.5:47
msgid ""
"In order to use a file system, you have to I<mount> it; see B<mount>(8)."
msgstr ""
"ファイルシステムを使うためには、 I<マウント> する必要がある。 B<mount>(8)  を"
"参照のこと。"

#. type: Plain text
#: build/C/man5/filesystems.5:49
msgid "Below a short description of a few of the available file systems."
msgstr "以下は利用可能なファイルシステムのうち、いくつかの簡単な説明である。"

#. type: TP
#: build/C/man5/filesystems.5:49
#, no-wrap
msgid "B<minix>"
msgstr "B<minix>"

#. type: Plain text
#: build/C/man5/filesystems.5:56
msgid ""
"is the file system used in the Minix operating system, the first to run "
"under Linux.  It has a number of shortcomings: a 64MB partition size limit, "
"short filenames, a single timestamp, etc.  It remains useful for floppies "
"and RAM disks."
msgstr ""
"Minix オペレーティングシステムのファイルシステム。 Linux で動いた最初のファイ"
"ルシステムでもある。これにはいくつか欠点がある。 まず、パーティションのサイズ"
"が最大 64MB であること。他にも、短いファイル名 しか使えない、タイムスタンプが"
"一つだけである、などなど。 フロッピーや RAM ディスクに便利なのでまだ残ってい"
"る。"

#. type: TP
#: build/C/man5/filesystems.5:56
#, no-wrap
msgid "B<ext>"
msgstr "B<ext>"

#. type: Plain text
#: build/C/man5/filesystems.5:65
msgid ""
"is an elaborate extension of the B<minix> file system.  It has been "
"completely superseded by the second version of the extended file system "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""
"B<minix> ファイルシステムの手の込んだ拡張である。これは第二拡張ファイルシステ"
"ム (second extended file system : B<ext2>)  に完全にとって代わられ、カーネル "
"2.1.21 で取り除かれた。"

#. type: TP
#: build/C/man5/filesystems.5:65
#, no-wrap
msgid "B<ext2>"
msgstr "B<ext2>"

#. type: Plain text
#: build/C/man5/filesystems.5:75
msgid ""
"is the high performance disk file system used by Linux for fixed disks as "
"well as removable media.  The second extended file system was designed as an "
"extension of the extended file system (B<ext>).  B<ext2> offers the best "
"performance (in terms of speed and CPU usage) of the file systems supported "
"under Linux."
msgstr ""
"Linux の高性能なファイルシステムである。これは固定ディスクだけではなく リムー"
"バブルディスクにもよく使われる。 拡張ファイルシステム (B<ext>)  の発展として"
"第二拡張ファイルシステム (B<ext2>)  が設計された。この B<ext2> は Linux の"
"ファイルシステムの中で (スピードおよび CPU の使用量の面で) 最も よいパフォー"
"マンスを発揮する。"

#. type: TP
#: build/C/man5/filesystems.5:75
#, no-wrap
msgid "B<ext3>"
msgstr "B<ext3>"

#. type: Plain text
#: build/C/man5/filesystems.5:80
msgid ""
"is a journaling version of the ext2 file system.  It is easy to switch back "
"and forth between ext2 and ext3."
msgstr ""
"ext2 ファイルシステムにジャーナル機能をつけたものである。\n"
"ext2 と ext3 は簡単に行きつ戻りつできる。"

#. type: TP
#: build/C/man5/filesystems.5:80
#, no-wrap
msgid "B<ext4>"
msgstr "B<ext4>"

#. type: Plain text
#: build/C/man5/filesystems.5:85
msgid ""
"is a set of upgrades to ext3 including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits."
msgstr ""
"ext3 の改良版であり、性能と信頼性のかなりの改善と、ボリューム、ファイル、\n"
"ディレクトリのサイズの上限の大幅な拡張が行われている。"

#. type: TP
#: build/C/man5/filesystems.5:85
#, no-wrap
msgid "B<Reiserfs>"
msgstr "B<Reiserfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:89
msgid ""
"is a journaling file system, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""
"Hans Reiser によって設計されたジャーナリングファイルシステムである。\n"
"カーネル 2.4.1 で Linux に統合された。"

#. type: TP
#: build/C/man5/filesystems.5:89
#, no-wrap
msgid "B<XFS>"
msgstr "B<XFS>"

#. type: Plain text
#: build/C/man5/filesystems.5:93
msgid ""
"is a journaling file system, developed by SGI, that was integrated into "
"Linux in kernel 2.4.20."
msgstr ""
"SGI により開発されたジャーナリングファイルシステムである。\n"
"カーネル 2.4.20 で Linux に統合された。"

#. type: TP
#: build/C/man5/filesystems.5:93
#, no-wrap
msgid "B<JFS>"
msgstr "B<JFS>"

#. type: Plain text
#: build/C/man5/filesystems.5:97
msgid ""
"is a journaling file system, developed by IBM, that was integrated into "
"Linux in kernel 2.4.24."
msgstr ""
"IBM により開発されたジャーナリングファイルシステムである。\n"
"カーネル 2.4.24 で Linux に統合された。"

#. type: TP
#: build/C/man5/filesystems.5:97
#, no-wrap
msgid "B<xiafs>"
msgstr "B<xiafs>"

#. type: Plain text
#: build/C/man5/filesystems.5:107
msgid ""
"was designed and implemented to be a stable, safe file system by extending "
"the Minix file system code.  It provides the basic most requested features "
"without undue complexity.  The B<xia> file system is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr ""
"は Minix ファイルシステムの拡張で、より安定し安全なファイルシステムとして 設"
"計、実装された。これは、いらない複雑さは避けつつ必要な基本的機能を 備えてい"
"る。 B<xia> ファイルシステムは、もはや開発もメンテナンスも行われていない。 "
"カーネル 2.1.21 で取り除かれた。"

#. type: TP
#: build/C/man5/filesystems.5:107
#, no-wrap
msgid "B<msdos>"
msgstr "B<msdos>"

#. type: Plain text
#: build/C/man5/filesystems.5:113
msgid ""
"is the file system used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period "
"and 3 character extension."
msgstr ""
"は DOS や Windows、いくらかの OS/2 コンピュータが使っているファイル システム"
"である。 この B<msdos> ファイルシステムでは「8 文字の名前＋ピリオド＋3 文字の"
"拡張子」より 長いファイル名はつけることができない。"

#. type: TP
#: build/C/man5/filesystems.5:113
#, no-wrap
msgid "B<umsdos>"
msgstr "B<umsdos>"

#. type: Plain text
#: build/C/man5/filesystems.5:120
msgid ""
"is an extended DOS file system used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.)  under the DOS file system, without sacrificing compatibility "
"with DOS."
msgstr ""
"は DOS ファイルシステムを拡張した Linux のファイルシステムである。 これは "
"DOS ファイルシステムのもとで、長いファイル名や UID/GID、POSIX 形式の パーミッ"
"ション、(デバイスファイルや名前付きパイプなどの) 特殊ファイルを 使えるように"
"したものである。DOS との互換性がある。"

#. type: TP
#: build/C/man5/filesystems.5:120
#, no-wrap
msgid "B<vfat>"
msgstr "B<vfat>"

#. type: Plain text
#: build/C/man5/filesystems.5:124
msgid ""
"is an extended DOS file system used by Microsoft Windows95 and Windows NT.  "
"VFAT adds the capability to use long filenames under the MSDOS file system."
msgstr ""
"は Microsoft Windows95 と Windows NT が使う DOS ファイルシステムの拡張であ"
"る。 長いファイル名が使えるようになっている。"

#. type: TP
#: build/C/man5/filesystems.5:124
#, no-wrap
msgid "B<ntfs>"
msgstr "B<ntfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:129
msgid ""
"replaces Microsoft Window's FAT file systems (VFAT, FAT32).  It has "
"reliability, performance, and space-utilization enhancements plus features "
"like ACLs, journaling, encryption, and so on."
msgstr ""
"Microsoft Windows の FAT ファイルシステム (VFAT, FAT32) を置き換えるものであ"
"る。\n"
"信頼性、性能、容量効率の向上に加えて、ACL、ジャーナリング、暗号化などの機能"
"が\n"
"追加されている。"

#. type: TP
#: build/C/man5/filesystems.5:129
#, no-wrap
msgid "B<proc>"
msgstr "B<proc>"

#. type: Plain text
#: build/C/man5/filesystems.5:137
msgid ""
"is a pseudo file system which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""
"はカーネルデータ構造へのインターフェイスとなる疑似ファイルシステムである。 こ"
"れは I</dev/kmem> を読んで解釈することの代わりとして使うことができる。 この"
"ファイルシステムのファイルはディスクスペースを使用しない。 B<proc>(5)  を参照"
"のこと。"

#. type: TP
#: build/C/man5/filesystems.5:137
#, no-wrap
msgid "B<iso9660>"
msgstr "B<iso9660>"

#. type: Plain text
#: build/C/man5/filesystems.5:140
msgid "is a CD-ROM file system type conforming to the ISO 9660 standard."
msgstr "は ISO 9660 標準に沿った CD-ROM のファイルシステムである。"

#. type: TP
#: build/C/man5/filesystems.5:141
#, no-wrap
msgid "B<High Sierra>"
msgstr "B<High Sierra>"

#. type: Plain text
#: build/C/man5/filesystems.5:148
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for CD-"
"ROM file systems.  It is automatically recognized within the B<iso9660> file-"
"system support under Linux."
msgstr ""
"Linux はハイシェラ (High Sierra) をサポートしている。これは ISO 9660 標準が "
"決まるより前に使われていた CD-ROM ファイルシステムである。Linux の "
"B<iso9660> ファイルシステムサポートがハイシェラファイルシステムを自動で 認識"
"することができる。"

#. type: TP
#: build/C/man5/filesystems.5:148
#, no-wrap
msgid "B<Rock Ridge>"
msgstr "B<Rock Ridge>"

#. type: Plain text
#: build/C/man5/filesystems.5:159
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the "
"Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> file system to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> file-system support under "
"Linux."
msgstr ""
"Linux はロックリッジ (Rock Ridge) 変換プロトコルで規定された システム使用\n"
"共有プロトコルもサポートしている。これは UNIX ホ ストのファイルを "
"B<iso9660> \n"
"ファイルシステムでより詳しく記述するために使用され、長いファイル名や UID/"
"GID、\n"
"POSIX 形式のパーミッション、デバイスファイル などの情報を提供する。Linux の\n"
"B<iso9660> ファイルシステムサポートがロックリッジファイルシステムを自動で\n"
"認識することができる。"

#. type: TP
#: build/C/man5/filesystems.5:160
#, no-wrap
msgid "B<hpfs>"
msgstr "B<hpfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:165
msgid ""
"is the High Performance Filesystem, used in OS/2.  This file system is read-"
"only under Linux due to the lack of available documentation."
msgstr ""
"は OS/2 で使われる高性能ファイルシステム(High Performance Filesystem)であ"
"る。 このファイルシステムはドキュメントが入手できないため、 Linux では読み込"
"み専用 (Read-only) でしか使用できない。"

#. type: TP
#: build/C/man5/filesystems.5:165
#, no-wrap
msgid "B<sysv>"
msgstr "B<sysv>"

#. type: Plain text
#: build/C/man5/filesystems.5:169
msgid ""
"is an implementation of the SystemV/Coherent file system for Linux.  It "
"implements all of Xenix FS, SystemV/386 FS, and Coherent FS."
msgstr ""
"は SystemV/Coherent ファイルシステムの Linux での実装である。 Xenix, "
"SystemV/386, Coherent 各ファイルシステムを使うことができる。"

#. type: TP
#: build/C/man5/filesystems.5:169
#, no-wrap
msgid "B<nfs>"
msgstr "B<nfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:172
msgid ""
"is the network file system used to access disks located on remote computers."
msgstr ""
"はネットワークファイルシステムである。 離れたコンピュータのディスクを使うこと"
"ができる。"

#. type: TP
#: build/C/man5/filesystems.5:172
#, no-wrap
msgid "B<smb>"
msgstr "B<smb>"

#. type: Plain text
#: build/C/man5/filesystems.5:176
msgid ""
"is a network file system that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager."
msgstr ""
"は SMB プロトコルをサポートしたネットワークファイルシステムである。 Windows "
"for Workgroups, Windows NT, Lan Manager が使っている。"

#. type: Plain text
#: build/C/man5/filesystems.5:183
msgid ""
"To use B<smb> fs, you need a special mount program, which can be found in "
"the ksmbfs package, found at E<.UR ftp://sunsite.unc.edu\\:/pub\\:/Linux\\:/"
"system\\:/Filesystems\\:/smbfs> E<.UE .>"
msgstr ""
"B<smb> ファイルシステムを使うためには ksmbfs パッケージに含まれる 特殊なマウ"
"ントプログラムが必要である。 ksmbfs は E<.UR ftp://sunsite.unc.edu\\:/pub\\:/"
"Linux\\:/system\\:/Filesystems\\:/smbfs> E<.UE> にある。"

#. type: TP
#: build/C/man5/filesystems.5:183
#, no-wrap
msgid "B<ncpfs>"
msgstr "B<ncpfs>"

#. type: Plain text
#: build/C/man5/filesystems.5:187
msgid ""
"is a network file system that supports the NCP protocol, used by Novell "
"NetWare."
msgstr ""
"は NCP プロトコルをサポートしたファイルシステムである。Novell NetWare が 使っ"
"ている。"

#. type: Plain text
#: build/C/man5/filesystems.5:193
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"
msgstr ""
"B<ncpfs> を使うためには E<.UR ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE> "
"にある特殊なプログラムが必要である。"

#. type: SH
#: build/C/man5/filesystems.5:193 build/C/man3/fts.3:785
#: build/C/man3/ftw.3:405 build/C/man3/getfsent.3:139
#: build/C/man3/getmntent.3:219 build/C/man2/getxattr.2:141
#: build/C/man2/listxattr.2:153 build/C/man2/mount.2:482
#: build/C/man7/path_resolution.7:237 build/C/man2/removexattr.2:110
#: build/C/man2/setxattr.2:152 build/C/man2/spu_create.2:270
#: build/C/man2/spu_run.2:264 build/C/man7/spufs.7:766 build/C/man2/stat.2:655
#: build/C/man2/statfs.2:277 build/C/man3/statvfs.3:181
#: build/C/man2/umount.2:170 build/C/man2/ustat.2:118
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man5/filesystems.5:198
msgid "B<proc>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"
msgstr "B<proc>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"

#. type: SH
#: build/C/man5/filesystems.5:198 build/C/man3/fts.3:791
#: build/C/man3/ftw.3:409 build/C/man3/getfsent.3:142
#: build/C/man3/getmntent.3:223 build/C/man2/getxattr.2:151
#: build/C/man2/listxattr.2:163 build/C/man2/mount.2:488
#: build/C/man7/path_resolution.7:242 build/C/man2/removexattr.2:120
#: build/C/man2/setxattr.2:162 build/C/man2/spu_create.2:275
#: build/C/man2/spu_run.2:269 build/C/man7/spufs.7:773 build/C/man2/stat.2:664
#: build/C/man2/statfs.2:281 build/C/man3/statvfs.3:183
#: build/C/man2/sysfs.2:104 build/C/man2/umount.2:175 build/C/man2/ustat.2:121
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man5/filesystems.5:205 build/C/man3/fts.3:798
#: build/C/man3/ftw.3:416 build/C/man3/getfsent.3:149
#: build/C/man3/getmntent.3:230 build/C/man2/getxattr.2:158
#: build/C/man2/listxattr.2:170 build/C/man2/mount.2:495
#: build/C/man7/path_resolution.7:249 build/C/man2/removexattr.2:127
#: build/C/man2/setxattr.2:169 build/C/man2/spu_create.2:282
#: build/C/man2/spu_run.2:276 build/C/man7/spufs.7:780 build/C/man2/stat.2:671
#: build/C/man2/statfs.2:288 build/C/man3/statvfs.3:190
#: build/C/man2/sysfs.2:111 build/C/man2/umount.2:182 build/C/man2/ustat.2:128
msgid ""
"This page is part of release 3.53 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.53 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr "FTS"

#. type: TH
#: build/C/man3/fts.3:40
#, no-wrap
msgid "2012-10-25"
msgstr "2012-10-25"

#. type: Plain text
#: build/C/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - ファイル階層をた"
"どる"

#. type: SH
#: build/C/man3/fts.3:44 build/C/man3/ftw.3:38 build/C/man3/getfsent.3:30
#: build/C/man3/getmntent.3:36 build/C/man2/getxattr.2:28
#: build/C/man2/listxattr.2:28 build/C/man2/mount.2:43
#: build/C/man2/removexattr.2:28 build/C/man2/setxattr.2:28
#: build/C/man2/spu_create.2:28 build/C/man2/spu_run.2:29
#: build/C/man2/stat.2:43 build/C/man2/statfs.2:31 build/C/man3/statvfs.3:33
#: build/C/man2/sysfs.2:30 build/C/man2/umount.2:33 build/C/man2/ustat.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"

#. type: Plain text
#: build/C/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<options>B<);>\n"
msgstr "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<options>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<options>B<);>\n"
msgstr "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<options>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr "B<int fts_close(FTS *>I<ftsp>B<);>\n"

#. type: Plain text
#: build/C/man3/fts.3:87
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" on a file "
"hierarchy, which is then supplied to the other fts functions.  The function "
"B<fts_read>()  returns a pointer to a structure describing one of the files "
"in the file hierarchy.  The function B<fts_children>()  returns a pointer to "
"a linked list of structures, each of which describes one of the files "
"contained in a directory in the hierarchy.  In general, directories are "
"visited two distinguishable times; in preorder (before any of their "
"descendants are visited) and in postorder (after all of their descendants "
"have been visited).  Files are visited once.  It is possible to walk the "
"hierarchy \"logically\" (visiting the files that symbolic links point to)  "
"or physically (visiting the symbolic links themselves), order the walk of "
"the hierarchy or prune and/or revisit portions of the hierarchy."
msgstr ""
"fts 関数群は、ファイル階層をたどるために提供されている。 簡単に概略すると次の"
"ようになる。 B<fts_open>()  関数は、他の fts 関数群に渡すための、ファイル階層"
"の「ハンドル」を返す。 B<fts_read>()  関数は、ファイル階層中にある 1 つのファ"
"イルを記述する構造体へのポインタを返す。 B<fts_children>()  関数は、階層中の"
"ディレクトリにあるファイルを記述する構造体の リンクリストへのポインタを返"
"す。 一般にディレクトリは、 preorder (正方向：下の階層のディレクトリをたどる"
"前) と postorder (逆方向：下の階層のディレクトリをすべてたどった後) という、 "
"異なる方向で 2 回たどられる。ファイルは 1 回たどられる。 ディレクトリ階層を"
"「論理的に」(シンボリックリングが指すファイルを見て) 辿ることも、 物理的に "
"(シンボリックリンク自身を見て) 辿ることも可能である。 また、階層中の移動の道"
"筋を指示すること・ 余分なものを取り除くこと・階層の一部を再びたどることが可能"
"である。"

#. type: Plain text
#: build/C/man3/fts.3:108
msgid ""
"Two structures are defined (and typedef'd) in the include file I<E<lt>fts."
"hE<gt>>.  The first is I<FTS>, the structure that represents the file "
"hierarchy itself.  The second is I<FTSENT>, the structure that represents a "
"file in the file hierarchy.  Normally, an I<FTSENT> structure is returned "
"for every file in the file hierarchy.  In this manual page, \"file\" and "
"\"FTSENT structure\" are generally interchangeable.  The I<FTSENT> structure "
"contains at least the following fields, which are described in greater "
"detail below:"
msgstr ""
"2 つの構造体がインクルードファイル I<E<lt>fts.hE<gt>> で定義されている (さら"
"に typedef されている)。 1 つ目は、ファイル階層そのものを表現する I<FTS> 構造"
"体である。 2 つ目は、ファイル階層中のファイルを表現する I<FTSENT> 構造体であ"
"る。 I<FTSENT> 構造体は通常、ファイル階層中のすべてのファイルに対して返され"
"る。 この man ページでは、「ファイル」と 「I<FTSENT> 構造体」を一般に読み変え"
"ることができる。 I<FTSENT> 構造体は、少なくとも次のようなフィールドを持ってお"
"り、 以下でより詳しく説明されている。"

#. type: Plain text
#: build/C/man3/fts.3:127
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short fts_info;     /* flags for FTSENT structure */\n"
"    char          *fts_accpath;  /* access path */\n"
"    char          *fts_path;     /* root path */\n"
"    short          fts_pathlen;  /* strlen(fts_path) */\n"
"    char          *fts_name;     /* filename */\n"
"    short          fts_namelen;  /* strlen(fts_name) */\n"
"    short          fts_level;    /* depth (-1 to N) */\n"
"    int            fts_errno;    /* file errno */\n"
"    long           fts_number;   /* local numeric value */\n"
"    void          *fts_pointer;  /* local address value */\n"
"    struct ftsent *fts_parent;   /* parent directory */\n"
"    struct ftsent *fts_link;     /* next file structure */\n"
"    struct ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat   *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""
"typedef struct _ftsent {\n"
"    unsigned short fts_info;     /* FTSENT 構造体のためのフラグ */\n"
"    char          *fts_accpath;  /* アクセスパス */\n"
"    char          *fts_path;     /* ルートパス */\n"
"    short          fts_pathlen;  /* fts_path の長さ */\n"
"    char          *fts_name;     /* ファイル名 */\n"
"    short          fts_namelen;  /* fts_name の長さ */\n"
"    short          fts_level;    /* 深さ (-1 〜 N) */\n"
"    int            fts_errno;    /* ファイルのエラー番号 */\n"
"    long           fts_number;   /* ローカルな番号 */\n"
"    void          *fts_pointer;  /* ローカルなアドレス番号 */\n"
"    struct ftsent *fts_parent;   /* 親ディレクトリ */\n"
"    struct ftsent *fts_link;     /* 次のファイル構造体 */\n"
"    struct ftsent *fts_cycle;    /* 循環している構造体 */\n"
"    struct stat   *fts_statp;    /* stat(2) の情報 */\n"
"} FTSENT;\n"

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: build/C/man3/fts.3:132
msgid "These fields are defined as follows:"
msgstr "これらのフィールドは、次のように定義されている。"

#. type: TP
#: build/C/man3/fts.3:132
#, no-wrap
msgid "I<fts_info>"
msgstr "I<fts_info>"

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: build/C/man3/fts.3:144
msgid ""
"One of the following flags describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""
"このフィールドは、返された I<FTSENT> 構造体とファイルを説明する以下のフラグの"
"いずれかを表している。 エラーのないディレクトリ (B<FTS_D>), の場合は例外とし"
"て、それ以外のすべてのエントリは終端である。 つまり、エントリは再びたどられる"
"こともなく、 それより下の階層がたどられることもない。"

#. type: TP
#: build/C/man3/fts.3:145
#, no-wrap
msgid "B<FTS_D>"
msgstr "B<FTS_D>"

#. type: Plain text
#: build/C/man3/fts.3:148
msgid "A directory being visited in preorder."
msgstr "preorder でたどられるディレクトリ。"

#. type: TP
#: build/C/man3/fts.3:148
#, no-wrap
msgid "B<FTS_DC>"
msgstr "B<FTS_DC>"

#. type: Plain text
#: build/C/man3/fts.3:156
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the "
"I<FTSENT> structure will be filled in as well.)"
msgstr ""
"ツリーの中で循環しているディレクトリ。 (I<FTSENT> 構造体の I<fts_cycle> "
"フィールドも同様に埋められる。)"

#. type: TP
#: build/C/man3/fts.3:156
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr "B<FTS_DEFAULT>"

#. type: Plain text
#: build/C/man3/fts.3:164
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described "
"by one of the other I<fts_info> values."
msgstr ""
"ファイルタイプを表現する I<FTSENT> 構造体が、 I<fts_info> の他のいずれかの値"
"で明示的に説明されていない。"

#. type: TP
#: build/C/man3/fts.3:164
#, no-wrap
msgid "B<FTS_DNR>"
msgstr "B<FTS_DNR>"

#. type: Plain text
#: build/C/man3/fts.3:170
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"読み込みができないディレクトリ。 これはエラーの場合の返り値であり、 何がエ"
"ラーを起こしたかを示すために I<fts_errno> フィールドが設定される。"

#. type: TP
#: build/C/man3/fts.3:170
#, no-wrap
msgid "B<FTS_DOT>"
msgstr "B<FTS_DOT>"

#. type: Plain text
#: build/C/man3/fts.3:180
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""
"B<fts_open>()  へのファイル名として指定されなかった \".\" または \"..\" とい"
"う名前のファイル (B<FTS_SEEDOT> を参照すること)。"

#. type: TP
#: build/C/man3/fts.3:180
#, no-wrap
msgid "B<FTS_DP>"
msgstr "B<FTS_DP>"

#. type: Plain text
#: build/C/man3/fts.3:190
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""
"postorder でたどられるディレクトリ。 I<FTSENT> 構造体の内容は、preorder のと"
"きに返された状態 (つまり、 I<fts_info> フィールドが B<FTS_D> に設定されている"
"状態) から変更されない。"

#. type: TP
#: build/C/man3/fts.3:190
#, no-wrap
msgid "B<FTS_ERR>"
msgstr "B<FTS_ERR>"

#. type: Plain text
#: build/C/man3/fts.3:195
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""
"これはエラーの場合の返り値であり、 I<fts_errno> フィールドは、何がエラーを起"
"こしたかを示す値に設定される。"

#. type: TP
#: build/C/man3/fts.3:195
#, no-wrap
msgid "B<FTS_F>"
msgstr "B<FTS_F>"

#. type: Plain text
#: build/C/man3/fts.3:198
msgid "A regular file."
msgstr "通常のファイル。"

#. type: TP
#: build/C/man3/fts.3:198
#, no-wrap
msgid "B<FTS_NS>"
msgstr "B<FTS_NS>"

#. type: Plain text
#: build/C/man3/fts.3:209
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""
"B<stat>(2)  情報が得られなかったファイル。 I<fts_statp> フィールドの内容は定"
"義されない。 これはエラーの場合の返り値であり、 I<fts_errno> フィールドは、何"
"がエラーを起こしたかを示す値に設定される。"

#. type: TP
#: build/C/man3/fts.3:209
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr "B<FTS_NSOK>"

#. type: Plain text
#: build/C/man3/fts.3:217
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""
"B<stat>(2)  情報が要求されなかったファイル。 I<fts_statp> フィールドの内容は"
"定義されない。"

#. type: TP
#: build/C/man3/fts.3:217
#, no-wrap
msgid "B<FTS_SL>"
msgstr "B<FTS_SL>"

#. type: Plain text
#: build/C/man3/fts.3:220
msgid "A symbolic link."
msgstr "シンボリックリンク。"

#. type: TP
#: build/C/man3/fts.3:220
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr "B<FTS_SLNONE>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:228
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp> "
"field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""
"リンク先の存在しないシンボリックリンク。 I<fts_statp> フィールドの内容は、シ"
"ンボリックリンクそのもののファイル特性情報を参照する。"

#. type: TP
#: build/C/man3/fts.3:229
#, no-wrap
msgid "I<fts_accpath>"
msgstr "I<fts_accpath>"

#. type: Plain text
#: build/C/man3/fts.3:232
msgid "A path for accessing the file from the current directory."
msgstr "現在のディレクトリからファイルにアクセスするためのパス。"

#. type: TP
#: build/C/man3/fts.3:232
#, no-wrap
msgid "I<fts_path>"
msgstr "I<fts_path>"

#. type: Plain text
#: build/C/man3/fts.3:238
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""
"階層をたどるときのルートからみたファイルの相対的なパス。 このパスには、 "
"B<fts_open>()  に指定したパスがプレフィックスとして含まれる。"

#. type: TP
#: build/C/man3/fts.3:238
#, no-wrap
msgid "I<fts_pathlen>"
msgstr "I<fts_pathlen>"

#. type: Plain text
#: build/C/man3/fts.3:242
msgid "The length of the string referenced by I<fts_path>."
msgstr "I<fts_path> で参照される文字列の長さ。"

#. type: TP
#: build/C/man3/fts.3:242
#, no-wrap
msgid "I<fts_name>"
msgstr "I<fts_name>"

#. type: Plain text
#: build/C/man3/fts.3:245
msgid "The name of the file."
msgstr "ファイルの名前。"

#. type: TP
#: build/C/man3/fts.3:245
#, no-wrap
msgid "I<fts_namelen>"
msgstr "I<fts_namelen>"

#. type: Plain text
#: build/C/man3/fts.3:249
msgid "The length of the string referenced by I<fts_name>."
msgstr "I<fts_name> で参照される文字列の長さ。"

#. type: TP
#: build/C/man3/fts.3:249
#, no-wrap
msgid "I<fts_level>"
msgstr "I<fts_level>"

#. type: Plain text
#: build/C/man3/fts.3:260
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""
"階層をたどって、このファイルがみつかった深さ。 -1 〜 N の数値で表される。 階"
"層をたどるときの出発点 (ルート) の親ディレクトリを表す I<FTSENT> 構造体では "
"-1 となる。 また、ルート自身の I<FTSENT> 構造体では 0 になる。"

#. type: TP
#: build/C/man3/fts.3:260
#, no-wrap
msgid "I<fts_errno>"
msgstr "I<fts_errno>"

#. type: Plain text
#: build/C/man3/fts.3:283
msgid ""
"Upon return of a I<FTSENT> structure from the B<fts_children>()  or "
"B<fts_read>()  functions, with its I<fts_info> field set to B<FTS_DNR>, "
"B<FTS_ERR> or B<FTS_NS>, the I<fts_errno> field contains the value of the "
"external variable I<errno> specifying the cause of the error.  Otherwise, "
"the contents of the I<fts_errno> field are undefined."
msgstr ""
"関数 B<fts_children>()  と B<fts_read>()  から返される I<FTSENT> 構造体の "
"I<fts_info> フィールドが B<FTS_DNR>, B<FTS_ERR>, B<FTS_NS> に設定されている場"
"合、 I<fts_errno> フィールドにはエラーの原因を示す外部変数 I<errno> の値が入"
"る。 それ以外の場合、 I<fts_errno> フィールドの内容は定義されない。"

#. type: TP
#: build/C/man3/fts.3:283
#, no-wrap
msgid "I<fts_number>"
msgstr "I<fts_number>"

#. type: Plain text
#: build/C/man3/fts.3:289
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""
"このフィールドは、アプリケーションプログラムから使用するために提供され、 fts "
"関数群では変更されない。 このフィールドは 0 で初期化される。"

#. type: TP
#: build/C/man3/fts.3:289
#, no-wrap
msgid "I<fts_pointer>"
msgstr "I<fts_pointer>"

#. type: Plain text
#: build/C/man3/fts.3:296
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""
"このフィールドは、アプリケーションプログラムから使用するために提供され、 fts "
"関数群では変更されない。 このフィールドは B<NULL> で初期化される。"

#. type: TP
#: build/C/man3/fts.3:296
#, no-wrap
msgid "I<fts_parent>"
msgstr "I<fts_parent>"

#. type: Plain text
#: build/C/man3/fts.3:310
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number> and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""
"現在のファイルのすぐ上の階層にあるファイル (つまり、現在のファイルがメンバー"
"になっているディレクトリ) を参照する I<FTSENT> 構造体へのポインタ。 最初の出"
"発点に対しても、親となる構造体は与えられる。 しかし、 I<fts_level>, "
"I<fts_number>, I<fts_pointer> フィールドのみの初期化しか保証されない。"

#. type: TP
#: build/C/man3/fts.3:310
#, no-wrap
msgid "I<fts_link>"
msgstr "I<fts_link>"

#. type: Plain text
#: build/C/man3/fts.3:321
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory "
"members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""
"B<fts_children>()  から返される場合、 I<fts_link> フィールドはディレクトリメ"
"ンバーの NUL 終端されたリンクリストの形式で、 次の構造体を指し示す。 それ以外"
"の場合、 I<fts_link> フィールドは定義されない。"

#. type: TP
#: build/C/man3/fts.3:321
#, no-wrap
msgid "I<fts_cycle>"
msgstr "I<fts_cycle>"

#. type: Plain text
#: build/C/man3/fts.3:337
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""
"2 つのディレクトリにハードリンクが張られているため、 または、シンボリックリン"
"クがあるディレクトリを指しているために、 ディレクトリが循環する階層構造を作っ"
"ている場合 (B<FTS_DC> を参照)、 構造体の I<fts_cycle> フィールドは、階層中で"
"現在の I<FTSENT> 構造体と同じファイルを参照している I<FTSENT> 構造体を指し示"
"す。 それ以外の場合、 I<fts_cycle> フィールドは定義されない。"

#. type: TP
#: build/C/man3/fts.3:337
#, no-wrap
msgid "I<fts_statp>"
msgstr "I<fts_statp>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:343
msgid "A pointer to B<stat>(2)  information for the file."
msgstr "このファイルの B<stat>(2)  情報へのポインタ。"

#. type: Plain text
#: build/C/man3/fts.3:370
msgid ""
"A single buffer is used for all of the paths of all of the files in the file "
"hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned "
"by B<fts_read>().  To use these fields to reference any files represented by "
"other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen> "
"field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always null-"
"terminated."
msgstr ""
"ファイル階層中のすべてのファイルのパスに対して、 ただ 1 つのバッファーが使わ"
"れる。 したがって、 I<fts_path> と I<fts_accpath> フィールドは、 B<fts_read>"
"()  によって返された最も新しいファイルに対して「のみ」 NULL 終端されることが"
"保証される。 これらのフィールドを、他の I<FTSENT> 構造体で表現されるファイル"
"を参照するために使うには、 I<FTSENT> 構造体の I<fts_pathlen> フィールドにある"
"情報を使ってパスのバッファーを修正する必要がある。 これらの修正は、さらに "
"B<fts_read>()  を呼び出そうとする場合には、元に戻しておかなければならない。 "
"I<fts_name> フィールドは、常に B<NUL> 終端される。"

#. type: SS
#: build/C/man3/fts.3:370
#, no-wrap
msgid "fts_open()"
msgstr "fts_open()"

#. type: Plain text
#: build/C/man3/fts.3:378
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a NULL pointer."
msgstr ""
"B<fts_open>()  関数は、文字列ポインタの配列へのポインタを引き数に取る。 この"
"文字列ポインタは、論理ファイル階層をつくる 1 つ以上のパスの名前になる。 配列"
"は、 B<NULL> ポインタで終端されなければならない。"

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: build/C/man3/fts.3:388
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""
"多くのオプションがあり、少なくとも 1 つ (B<FTS_LOGICAL> または "
"B<FTS_PHYSICAL>)  が指定されなければならない。 オプションは以下の値の論理和を"
"とって選択する。"

#. type: TP
#: build/C/man3/fts.3:388
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr "B<FTS_COMFOLLOW>"

#. type: Plain text
#: build/C/man3/fts.3:394
msgid ""
"This option causes any symbolic link specified as a root path to be followed "
"immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""
"このオプションは、 B<FTS_LOGICAL> の指定にかかわらず、 ルートパスに指定された"
"シンボリックリンクをすぐにたどらせる。"

#. type: TP
#: build/C/man3/fts.3:394
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr "B<FTS_LOGICAL>"

#. type: Plain text
#: build/C/man3/fts.3:413
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this "
"option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either "
"B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  "
"function."
msgstr ""
"このオプションは、 fts ルーチンにシンボリックリンクそのものではなく、 シンボ"
"リックリンクが指しているファイルの I<FTSENT> 構造体を返させる。 このオプショ"
"ンが設定された場合、 I<FTSENT> 構造体がアプリケーションに返されるような シン"
"ボリックリンクのみが、存在しないファイルを参照している。 B<FTS_LOGICAL> また"
"は B<FTS_PHYSICAL> のどちらかを、 B<fts_open>()  関数に与えなければ「ならな"
"い」。"

#. type: TP
#: build/C/man3/fts.3:413
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr "B<FTS_NOCHDIR>"

#. type: Plain text
#: build/C/man3/fts.3:429
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""
"パフォーマンスの最適化のため、 fts 関数群はファイル階層をたどるときディレクト"
"リを変える。 これには、階層をたどっている間は アプリケーションがある特定の"
"ディレクトリにいるということに 依存できない、という副作用がある。 "
"B<FTS_NOCHDIR> オプションで最適化を無効にすると、 fts 関数群は現在のディレク"
"トリを変更しない。 B<FTS_NOCHDIR> が指定され、かつ B<fts_open>()  の引き数と"
"して絶対パス名が与えられたとき以外、アプリケーションは、 自らカレントディレク"
"トリを変更したり、 ファイルにアクセスしたりすべきではない、という点に注意する"
"こと。"

#. type: TP
#: build/C/man3/fts.3:429
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr "B<FTS_NOSTAT>"

#. type: Plain text
#: build/C/man3/fts.3:445
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes "
"that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""
"デフォルトでは、返された I<FTSENT> 構造体は、たどられた各ファイルについての"
"ファイル特徴情報 I<( statp> フィールド) を参照する。 このオプションは、 fts "
"関数群が I<fts_info> フィールドを B<FTS_NSOK> に設定し I<statp> の内容を定義"
"されないままにすることを許すことにより、 パフォーマンスの最適化に必要なものを"
"緩和する。"

#. type: TP
#: build/C/man3/fts.3:445
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr "B<FTS_PHYSICAL>"

#. type: Plain text
#: build/C/man3/fts.3:464
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""
"このオプションは、 fts ルーチンにシンボリックリンクが指しているファイルではな"
"く、 シンボリックリンク自身の I<FTSENT> 構造体を返させる。 このオプションが設"
"定されると、階層中のすべてのシンボリックリンクの I<FTSENT> 構造体がアプリケー"
"ションに返される。 B<FTS_LOGICAL> または B<FTS_PHYSICAL> のどちらかを "
"B<fts_open>()  関数に与えなければ「ならない」。"

#. type: TP
#: build/C/man3/fts.3:464
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr "B<FTS_SEEDOT>"

#. type: Plain text
#: build/C/man3/fts.3:477
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures "
"for them."
msgstr ""
"デフォルトでは、 B<fts_open>()  のパス引き数として指定されない限り、ファイル"
"階層中にある \".\" または \"..\" という名前のファイルは無視される。 このオプ"
"ションは、 fts ルーチンにこれらのファイルの I<FTSENT> 構造体を返させる。"

#. type: TP
#: build/C/man3/fts.3:477
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr "B<FTS_XDEV>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:483
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""
"このオプションは、 fts が下り始めのファイルとは異なるデバイス番号を持ってい"
"る ディレクトリに下りるのを阻止する。"

#. type: Plain text
#: build/C/man3/fts.3:522
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path> and "
"I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used in "
"this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""
"引き数 B<compar>()  は、階層をたどる順番を決めるのに使われるユーザー定義関数"
"を指定する。 この関数は、引き数として I<FTSENT> 構造体のポインタのポインタを "
"2 つとり、 1 番目の引き数で参照されているファイルが 2 番目の引き数で参照され"
"ているファイルより 前にある場合は負の値・同じ場合はゼロ・後にある場合は正の値"
"を 返さなければならない。 I<FTSENT> 構造体の I<fts_accpath>, I<fts_path>, "
"I<fts_pathlen> フィールドは、この比較に「絶対」使ってはいけない。 "
"I<fts_info> フィールドが B<FTS_NS> または B<FTS_NSOK> に設定される場合、 "
"I<fts_statp> フィールドはこれらのどちらでもない。 B<compar>()  引き数が "
"B<NULL> の場合、ディレクトリをたどる順番は、ルートパスについては "
"I<path_argv> のなかでリストされた順番で、 その他のファイルについてはディレク"
"トリ内でリストされた順番となる。"

#. type: SS
#: build/C/man3/fts.3:522
#, no-wrap
msgid "fts_read()"
msgstr "fts_read()"

#. type: Plain text
#: build/C/man3/fts.3:535
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may "
"cause files to be visited more than once, or directories more than twice.)"
msgstr ""
"B<fts_read>()  関数は、階層中のファイルを記述する I<FTSENT> 構造体へのポイン"
"タを返す。 (読み込み可能で、循環していない) ディレクトリは、 1 回は preorder "
"で、もう 1 回は postorder で、少なくとも 2 回たどられる。 他のファイルは、少"
"なくとも 1 回たどられる。 (ディレクトリ間のハードリンクによって 循環やシンボ"
"リックリンクへのシンボリックリンクが起こらない場合、 ファイルは 2 回以上、"
"ディレクトリは 3 回以上たどられる。)"

#. type: Plain text
#: build/C/man3/fts.3:556
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and "
"sets I<errno> appropriately.  If an error related to a returned file occurs, "
"a pointer to an I<FTSENT> structure is returned, and I<errno> may or may not "
"have been set (see I<fts_info>)."
msgstr ""
"階層中のすべてのメンバーが返された場合、 B<fts_read>()  は B<NULL> を返し、外"
"部変数 I<errno> を 0 にする。 階層中のファイルに関係しないエラーが起こった場"
"合、 B<fts_read>()  は B<NULL> を返し、 I<errno> をエラーに対応した値にす"
"る。 階層中のファイルに関係したエラーが起こった場合、 I<FTSENT> 構造体へのポ"
"インタが返され、 I<errno> は設定される場合と設定されない場合がある "
"(I<fts_info> を参照すること)。"

#. type: Plain text
#: build/C/man3/fts.3:573
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after "
"a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""
"B<fts_read>()  によって返される I<FTSENT> 構造体は、同じファイル階層ストリー"
"ムへの B<fts_close>()  の呼出しの後に上書きされる。 また、同じファイル階層ス"
"トリームへの B<fts_read>()  の呼出しの後でも、構造体がディレクトリを表現して"
"いない限り上書きされる。 この場合、 B<fts_read>()  関数によって postorder で "
"I<FTSENT> 構造体が返された後、 B<fts_read>()  の呼出しがあるまで、 これらの構"
"造体は上書きされない。"

#. type: SS
#: build/C/man3/fts.3:573
#, no-wrap
msgid "fts_children()"
msgstr "fts_children()"

#. type: Plain text
#: build/C/man3/fts.3:591
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will recreate this "
"linked list."
msgstr ""
"B<fts_children>()  関数は、 I<FTSENT> 構造体へのポインタを返す。 この構造体"
"は、( B<fts_read>()  で最も新しく返された I<FTSENT> 構造体で表現されるディレ"
"クトリにあるファイルの)  NUL 終端されたリンクリストの最初のエントリを記述す"
"る。 このリストは、 I<FTSENT> 構造体の I<fts_link> フィールドを使ってリンクさ"
"れ、 ユーザー指定の比較関数がある場合は、それで順序づけられる。 "
"B<fts_children>()  の呼出しを繰り返すことで、 このリンクリストは再生成され"
"る。"

#. type: Plain text
#: build/C/man3/fts.3:619
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, B<fts_children>"
"()  returns NULL and sets I<errno> appropriately."
msgstr ""
"特別な場合として、 B<fts_read>()  がファイル階層について呼ばれていない場合、 "
"B<fts_children>()  は B<fts_open>()  に指定された論理ディレクトリ (つまり、 "
"B<fts_open>()  に指定された引き数) の中にあるファイルへのポインタを返す。 そ"
"れ以外の場合で、 B<fts_read>()  によって最も新しく返された I<FTSENT> 構造体"
"が preorder でたどられたディレクトリでない場合や 何も含んでいないディレクトリ"
"の場合は、 B<fts_children>()  は B<NULL> を返し、 I<errno> を 0 にする。 エ"
"ラーが起こった場合、 B<fts_children>()  は B<NULL> を返し、 I<errno> をエラー"
"に対応した値にする。"

#. type: Plain text
#: build/C/man3/fts.3:630
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>()  or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""
"B<fts_children>()  によって返される I<FTSENT> 構造体は、同じファイル階層スト"
"リームへの B<fts_children>(), B<fts_close>(), B<fts_read>()  の呼出しの後に上"
"書きされる場合がある。"

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: build/C/man3/fts.3:634
msgid "I<Option> may be set to the following value:"
msgstr "I<option> は、次の値に設定できる。"

#. type: TP
#: build/C/man3/fts.3:634
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr "B<FTS_NAMEONLY>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:644
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""
"ファイル名のみが必要とされている。 返された構造体のリンクリストの "
"I<fts_name>, I<fts_namelen> フィールド以外の すべてのフィールドの内容は定義さ"
"れない。"

#. type: SS
#: build/C/man3/fts.3:644
#, no-wrap
msgid "fts_set()"
msgstr "fts_set()"

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: build/C/man3/fts.3:659
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs.  I<Option> must be "
"set to one of the following values:"
msgstr ""
"関数 B<fts_set>()  は、ユーザーアプリケーションが ストリーム I<ftsp> のファイ"
"ル I<f> について更なる処理を決定すること許す。 B<fts_set>()  関数は、成功した"
"場合は 0 を、エラーが起こった場合は -1 を返す。 I<option> は、次の値のいずれ"
"か 1 つに設定されなければならない。"

#. type: TP
#: build/C/man3/fts.3:659
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr "B<FTS_AGAIN>"

#. type: Plain text
#: build/C/man3/fts.3:677
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""
"ファイルを再びたどる。すべてのファイルタイプが再びたどられる。 次の "
"B<fts_read>()  の呼出しにより、参照されているファイルが返される。 構造体の "
"I<fts_stat>, I<fts_info> フィールドはこの時に初期化されるが、他のフィールドは"
"変更されない。 このオプションは、 B<fts_read>()  によって最も新しく返された"
"ファイルについてのみ意味を持つ。 通常は、postorder でディレクトリをたどる場合"
"に使用し、 その下の階層と同様に、 ディレクトリを (preorder と postorder の両"
"方で) 再びたどらせる。"

#. type: TP
#: build/C/man3/fts.3:677
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr "B<FTS_FOLLOW>"

#. type: Plain text
#: build/C/man3/fts.3:705
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()  "
"returns the file with the I<fts_info> and I<fts_statp> fields reinitialized "
"to reflect the target of the symbolic link instead of the symbolic link "
"itself.  If the file is one of those most recently returned by "
"B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the structure, "
"when returned by B<fts_read>(), will reflect the target of the symbolic link "
"instead of the symbolic link itself.  In either case, if the target of the "
"symbolic link does not exist the fields of the returned structure will be "
"unchanged and the I<fts_info> field will be set to B<FTS_SLNONE>."
msgstr ""
"参照されてるファイルは、シンボリックリンクでなければならない。 参照されている"
"ファイルが B<fts_read>()  によって最も新しく返されたものである場合、次の "
"B<fts_read>()  の呼出しでは、シンボリックリンクそのものではなく、 シンボリッ"
"クリンクが指している先を反映するように I<fts_info>, I<fts_statp> を再び初期化"
"したファイルが返される。 ファイルが B<fts_children>()  によって最も新しく返さ"
"れたものの 1 つである場合、 B<fts_read>()  によって返されたとき、構造体の "
"I<fts_info>, I<fts_statp> フィールドは、シンボリックリンクそのものではなく、 "
"シンボリックリンクが指している先を反映する。 どちらの場合でも、シンボリックリ"
"ンクが指している先がないときは、 返された構造体のフィールドは変更されず、 "
"I<fts_info> フィールドが B<FTS_SLNONE> に設定される。"

#. type: Plain text
#: build/C/man3/fts.3:709
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""
"リンク先がディレクトリの場合、 ファイルが preorder で返された後、下の階層のす"
"べてファイルが返され、 その後で postorder で返される。"

#. type: TP
#: build/C/man3/fts.3:709
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr "B<FTS_SKIP>"

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:717
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""
"このファイルの下の階層はたどられない。 このファイルは、 B<fts_children>()  ま"
"たは B<fts_read>()  のどちらかによって最も新しく返されたものの 1 つである。"

#. type: SS
#: build/C/man3/fts.3:717
#, no-wrap
msgid "fts_close()"
msgstr "fts_close()"

#. type: Plain text
#: build/C/man3/fts.3:730
msgid ""
"The B<fts_close>()  function closes a file hierarchy stream I<ftsp> and "
"restores the current directory to the directory from which B<fts_open>()  "
"was called to open I<ftsp>.  The B<fts_close>()  function returns 0 on "
"success, and -1 if an error occurs."
msgstr ""
"B<fts_close>()  関数は、ファイル階層ストリーム I<ftsp> を閉じる。そして、現在"
"のディレクトリを I<ftsp> を開くために B<fts_open>()  が呼ばれたディレクトリに"
"復元する。 B<fts_close>()  関数は、成功した場合は 0 を、エラーが起こった場合"
"は -1 を返す。"

#. type: SH
#: build/C/man3/fts.3:730 build/C/man2/getxattr.2:106
#: build/C/man2/listxattr.2:127 build/C/man2/mount.2:312
#: build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:110
#: build/C/man2/spu_create.2:172 build/C/man2/spu_run.2:153
#: build/C/man2/stat.2:305 build/C/man2/statfs.2:134
#: build/C/man3/statvfs.3:101 build/C/man2/sysfs.2:79
#: build/C/man2/umount.2:104 build/C/man2/ustat.2:79
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/fts.3:739
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""
"関数 B<fts_open>()  が失敗した場合、 I<errno> は、ライブラリ関数 B<open>(2)  "
"と B<malloc>(3)  に対して指定されるエラーに設定される。"

#. type: Plain text
#: build/C/man3/fts.3:748
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors "
"specified for B<chdir>(2)  and B<close>(2)."
msgstr ""
"関数 B<fts_close>()  が失敗した場合、 I<errno> は、ライブラリ関数 B<chdir>"
"(2)  と B<close>(2)  に対して指定されるエラーに設定される。"

#. type: Plain text
#: build/C/man3/fts.3:762
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3)  and B<stat>(2)."
msgstr ""
"関数 B<fts_read>()  と B<fts_children>()  が失敗した場合、 I<errno> は、ライ"
"ブラリ関数 B<chdir>(2), B<malloc>(3), B<opendir>(3), B<readdir>(3), B<stat>"
"(2)  に対して指定されるエラーに設定される。"

#. type: Plain text
#: build/C/man3/fts.3:771
msgid ""
"In addition, B<fts_children>(), B<fts_open>()  and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""
"更に、 B<fts_children>(), B<fts_open>(), B<fts_set>()  が失敗した場合、 "
"I<errno> が次の値にされる。"

#. type: TP
#: build/C/man3/fts.3:771 build/C/man2/mount.2:348
#: build/C/man2/spu_create.2:186 build/C/man2/spu_run.2:174
#: build/C/man2/sysfs.2:84 build/C/man2/umount.2:125 build/C/man2/ustat.2:84
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/fts.3:774
msgid "The options were invalid."
msgstr "オプションが無効であった。"

#. type: SH
#: build/C/man3/fts.3:774 build/C/man2/getxattr.2:130
#: build/C/man2/listxattr.2:142 build/C/man2/mount.2:406
#: build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:141
#: build/C/man2/spu_create.2:246 build/C/man2/spu_run.2:188
#: build/C/man2/umount.2:150
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/fts.3:776
msgid "These functions are available in Linux since glibc2."
msgstr "これらの関数は、Linux では glibc2 から使用可能である。"

#. type: SH
#: build/C/man3/fts.3:776 build/C/man3/ftw.3:320 build/C/man3/getfsent.3:115
#: build/C/man3/getmntent.3:201 build/C/man2/getxattr.2:133
#: build/C/man2/listxattr.2:145 build/C/man2/mount.2:417
#: build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:144
#: build/C/man2/spu_create.2:250 build/C/man2/spu_run.2:192
#: build/C/man2/stat.2:361 build/C/man2/statfs.2:190
#: build/C/man3/statvfs.3:157 build/C/man2/sysfs.2:92
#: build/C/man2/umount.2:156 build/C/man2/ustat.2:94
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: build/C/man3/fts.3:785
msgid "4.4BSD."
msgstr "4.4BSD."

#. type: Plain text
#: build/C/man3/fts.3:791
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"

#. type: TH
#: build/C/man3/ftw.3:35
#, no-wrap
msgid "FTW"
msgstr "FTW"

#. type: TH
#: build/C/man3/ftw.3:35
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: build/C/man3/ftw.3:38
msgid "ftw, nftw - file tree walk"
msgstr "ftw, nftw - ファイルツリーを歩きまわる"

#. type: Plain text
#: build/C/man3/ftw.3:41
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr "B<#include E<lt>ftw.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ftw.3:46
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"

#. type: Plain text
#: build/C/man3/ftw.3:49
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE 500>   /* See feature_test_macros(7) */\n"
"B<#include E<lt>ftw.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE 500>   /* feature_test_macros(7) 参照 */\n"
"B<#define _XOPEN_SOURCE 500>\n"
"B<#include E<lt>ftw.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat *>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man3/ftw.3:62
msgid ""
"B<ftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By "
"default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""
"B<ftw>()  は、 I<dirpath> で指定されたディレクトリ以下のディレクトリツリー全"
"体を歩きまわり、 ツリー中でエントリが見付かるごとに、 I<fn>()  を呼び出す。 "
"デフォルトでは、ディレクトリそのものが、そのディレクトリにあるファイルや サブ"
"ディレクトリよりも先に処理される (行きがけ順探索; preorder traversal)。"

#. type: Plain text
#: build/C/man3/ftw.3:75
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<ftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<ftw>()  will become "
"slower because directories have to be closed and reopened.  B<ftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""
"呼び出し元プロセスが利用可能なファイルディスクリプタを使い切って しまわないよ"
"うにするため、 B<ftw>()  が同時にオープンするディレクトリの最大数を "
"I<nopenfd> で指定することができる。 探索の深さがこの値を越えると、 一つのディ"
"レクトリを閉じてから他のディレクトリをオープンし直すこと になるので、 B<ftw>"
"()  の動作は遅くなる。 B<ftw>()  は、ディレクトリツリーの階層 1 レベルにつ"
"き、 最大でも一つのファイルディスクリプタしか使用しない。"

#. type: Plain text
#: build/C/man3/ftw.3:104
msgid ""
"For each entry found in the tree, B<ftw>()  calls I<fn>() with three "
"arguments: I<fpath>, I<sb>, and I<typeflag>.  I<fpath> is the pathname of "
"the entry, and is expressed either as a pathname relative to the calling "
"process's current working directory at the time of the call to B<ftw>(), if "
"I<dirpath> was expressed as a relative pathname, or as an absolute pathname, "
"if I<dirpath> was expressed as an absolute pathname.  I<sb> is a pointer to "
"the I<stat> structure returned by a call to B<stat>(2)  for I<fpath>.  "
"I<typeflag> is an integer that has one of the following values:"
msgstr ""
"ディレクトリツリーで見つかったエントリ毎に、 B<ftw>()  は I<fpath>, I<sb>, "
"I<typeflag> の 3つを引き数として I<fn>()  を呼び出す。 I<fpath> はエントリの"
"パス名である。 I<dirpath> が相対パス名で指定された場合には、 I<fpath> は "
"B<ftw>()  が呼び出された時点の呼び出し元プロセスのカレントワーキングディレク"
"トリ からの相対パス名となる。 I<dirpath> が絶対パス名で指定された場合には、 "
"I<fpath> は絶対パス名となる。 I<sb> は I<fpath> に対する B<stat>(2)  の呼び出"
"しで返される I<stat> 構造体へのポインタである。 I<typeflag> は整数で、以下の"
"値のいずれか一つである:"

#. type: TP
#: build/C/man3/ftw.3:104
#, no-wrap
msgid "B<FTW_F>"
msgstr "B<FTW_F>"

#. type: Plain text
#: build/C/man3/ftw.3:108
msgid "I<fpath> is a regular file."
msgstr "I<fpath> が通常のファイルである"

#. type: TP
#: build/C/man3/ftw.3:108
#, no-wrap
msgid "B<FTW_D>"
msgstr "B<FTW_D>"

#. type: Plain text
#: build/C/man3/ftw.3:112
msgid "I<fpath> is a directory."
msgstr "I<fpath> がディレクトリである"

#. type: TP
#: build/C/man3/ftw.3:112
#, no-wrap
msgid "B<FTW_DNR>"
msgstr "B<FTW_DNR>"

#. type: Plain text
#: build/C/man3/ftw.3:116
msgid "I<fpath> is a directory which can't be read."
msgstr "I<fpath> が読み込みできないディレクトリである"

#. type: TP
#: build/C/man3/ftw.3:116
#, no-wrap
msgid "B<FTW_NS>"
msgstr "B<FTW_NS>"

#. type: Plain text
#: build/C/man3/ftw.3:123
msgid "The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link."
msgstr ""
"シンボリックリンクではない I<fpath> に対する B<stat>(2)  呼び出しが失敗した。"

#. type: Plain text
#: build/C/man3/ftw.3:132
msgid ""
"If I<fpath> is a symbolic link and B<stat>(2)  failed, POSIX.1-2001 states "
"that it is undefined whether B<FTW_NS> or B<FTW_SL> (see below)  is passed "
"in I<typeflag>."
msgstr ""
"I<fpath> がシンボリックリンクで、かつ B<stat>(2)  が失敗した場合、 B<FTW_NS> "
"と B<FTW_SL> (後述) のどちらが I<typeflag> に渡されるかは未定義であると、"
"POSIX.1-2001 には書かれている。"

#. type: Plain text
#: build/C/man3/ftw.3:143
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<ftw>().  As long as I<fn>() returns 0, B<ftw>"
"()  will continue either until it has traversed the entire tree, in which "
"case it will return zero, or until it encounters an error (such as a "
"B<malloc>(3)  failure), in which case it will return -1."
msgstr ""
"ツリーの探索を止めたい場合は、 I<fn>()  が 0 以外の値を返せば良い (この値は "
"B<ftw>()  自身の戻り値となる)。 それ以外の場合は B<ftw>()  はツリー全体の探索"
"を続け、すべてのツリーを探索し終えたところで 0 を返す。探索中に (B<malloc>"
"(3)  の失敗などの) エラーが起こると -1 を返す。"

#. type: Plain text
#: build/C/man3/ftw.3:153
msgid ""
"Because B<ftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler "
"set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr ""
"B<ftw>()  は動的なデータ構造を用いるので、ツリー探索を安全に中断する唯一の方"
"法は 0 以外の値を I<fn>()  の返り値とすることである。割り込みを扱うには、 例"
"えば発生した割り込みをマークしておいて、 0 以外の値を返すようにする シグナル"
"によりメモリリークを起こさずに探索を終了できるようにするには、 シグナルハンド"
"ラで I<fn>()  がチェックするグローバルなフラグをセットするようにすればよい。 "
"プログラムを終了させる場合以外は、 B<longjmp>(3)  を使用しないこと。"

#. type: SS
#: build/C/man3/ftw.3:153
#, no-wrap
msgid "nftw()"
msgstr "nftw()"

#. type: Plain text
#: build/C/man3/ftw.3:160
msgid ""
"The function B<nftw>()  is the same as B<ftw>(), except that it has one "
"additional argument, I<flags>, and calls I<fn>() with one more argument, "
"I<ftwbuf>."
msgstr ""
"関数 B<nftw>()  は B<ftw>()  と同じだが、引き数 I<flags> が追加される点と、 "
"I<fn>()  の引き数に I<ftwbuf> が追加される点が異なる。"

#. type: Plain text
#: build/C/man3/ftw.3:163
msgid ""
"This I<flags> argument is formed by ORing zero or more of the following "
"flags:"
msgstr ""
"この I<flags> 引き数は下記のフラグの 0 個以上の論理和を取ったものである:"

#. type: TP
#: build/C/man3/ftw.3:163
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr "B<FTW_ACTIONRETVAL> (glibc 2.3.3 以降)"

#. type: Plain text
#: build/C/man3/ftw.3:172
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value "
"from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""
"このフラグは glibc 固有である。 このフラグをセットすると、 B<nftw>()  の "
"I<fn>()  の返り値の扱いが変わる。 I<fn>()  は以下の値のいずれか一つを返す必要"
"がある。"

#. type: TP
#: build/C/man3/ftw.3:173
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr "B<FTW_CONTINUE>"

#. type: Plain text
#: build/C/man3/ftw.3:178
msgid "Instructs B<nftw>()  to continue normally."
msgstr "B<nftw>()  は通常通り処理を続ける。"

#. type: TP
#: build/C/man3/ftw.3:178
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr "B<FTW_SKIP_SIBLINGS>"

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: build/C/man3/ftw.3:186
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""
"I<fn>()  がこの値を返した場合、処理中のエントリの兄弟 (同じ階層のエントリ)  "
"の処理はスキップされ、親ディレクトリで続きの処理が行われる。"

#. type: TP
#: build/C/man3/ftw.3:186
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr "B<FTW_SKIP_SUBTREE>"

#. type: Plain text
#: build/C/man3/ftw.3:194
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from "
"being passed as arguments to I<fn>().  B<nftw>()  continues processing with "
"the next sibling of the directory."
msgstr ""
"I<fn>()  が呼び出されたエントリがディレクトリ (I<typeflag> が B<FTW_D>)  の場"
"合に、この値を返すと I<fn>()  の引き数として渡されたディレクトリ内のエントリ"
"の処理が行われなくなる。 B<nftw>()  は処理中のディレクトリの兄弟 (同じ階層の"
"エントリ) から処理を続ける。"

#. type: TP
#: build/C/man3/ftw.3:194
#, no-wrap
msgid "B<FTW_STOP>"
msgstr "B<FTW_STOP>"

#. type: Plain text
#: build/C/man3/ftw.3:200
msgid ""
"Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr "B<nftw ()> は、返り値 B<FTW_STOP> ですぐに復帰する。"

#. type: Plain text
#: build/C/man3/ftw.3:203
msgid ""
"Other return values could be associated with new actions in the future; I<fn>"
"() should not return values other than those listed above."
msgstr ""
"他の返り値は将来新しい動作に対応付けられる可能性がある。 I<fn>()  は上記のリ"
"ストにある値以外を返さないようにすべきである。"

#. type: Plain text
#: build/C/man3/ftw.3:212
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""
"I<E<lt>ftw.hE<gt>> で B<FTW_ACTIONRETVAL> の定義が有効にするためには、 (「ど"
"の」ヘッダファイルをインクルードするよりも前に)  機能検査マクロ "
"B<_GNU_SOURCE> を定義しなければならない。"

#. type: TP
#: build/C/man3/ftw.3:213
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr "B<FTW_CHDIR>"

#. type: Plain text
#: build/C/man3/ftw.3:220
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides."
msgstr ""
"セットされると、ディレクトリの内容を処理する前に そのディレクトリに B<chdir>"
"(2)  する。このフラグは、 I<fpath> が属すディレクトリで何らかの動作を実行する"
"必要がある場合に 便利である。"

#. type: TP
#: build/C/man3/ftw.3:220
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr "B<FTW_DEPTH>"

#. type: Plain text
#: build/C/man3/ftw.3:226
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""
"セットされると、帰りがけ順探索 (post-order traversal) を行う。 つまり、ディレ"
"クトリそのものを引き数とした I<fn>()  呼出しは、そのディレクトリに含まれる"
"ファイルとサブディレクトリに 対する処理の「後で」行われる (デフォルトでは、"
"ディレクトリ自身の処理はディレクトリ内のエントリ より「前に」行なわれる)。"

#. type: TP
#: build/C/man3/ftw.3:226
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr "B<FTW_MOUNT>"

#. type: Plain text
#: build/C/man3/ftw.3:230
msgid ""
"If set, stay within the same file system (i.e., do not cross mount points)."
msgstr ""
"セットされると、同じファイルシステムの中だけを探索対象とする (つまり、マウン"
"トポイントをまたぐことはない)。"

#. type: TP
#: build/C/man3/ftw.3:230
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr "B<FTW_PHYS>"

#. type: Plain text
#: build/C/man3/ftw.3:235
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set, "
"symbolic links are followed, but no file is reported twice."
msgstr ""
"セットされると、シンボリックリンクを辿らない (おそらくこちらが 通常望ましい動"
"作だろう)。セットされていないとシンボリックリンクを 辿るが、同じファイルが二"
"回報告されることはない。"

#. type: Plain text
#: build/C/man3/ftw.3:240
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function I<fn>"
"()  is never called for a directory that would be a descendant of itself."
msgstr ""
"B<FTW_PHYS> がセットされずに B<FTW_DEPTH> がセットされると、自分自身に対する"
"シンボリックリンクを配下に持つ ディレクトリに対して I<fn>()  が呼び出されるこ"
"とは決してない。"

#. type: Plain text
#: build/C/man3/ftw.3:255
msgid ""
"For each entry in the directory tree, B<nftw>()  calls I<fn>()  with four "
"arguments.  I<fpath> and I<sb> are as for B<ftw>().  I<typeflag> may receive "
"any of the same values as with B<ftw>(), or any of the following values:"
msgstr ""
"ディレクトリツリーのエントリ毎に、 B<nftw>()  は 4つの引き数で I<fn>()  を呼"
"び出す。 I<fpath> と I<sb> は B<ftw>()  と同じである。 I<typeflag> には、 "
"B<ftw>()  で取り得る値のいずれか、または以下の値のいずれかが渡される:"

#. type: TP
#: build/C/man3/ftw.3:255
#, no-wrap
msgid "B<FTW_DP>"
msgstr "B<FTW_DP>"

#. type: Plain text
#: build/C/man3/ftw.3:261
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  All of "
"the files and subdirectories within I<fpath> have been processed."
msgstr ""
"I<fpath> がディレクトリで、かつ I<flags> で B<FTW_DEPTH> が指定されていた。 "
"I<fpath> 配下のファイルとサブディレクトリは全て処理が終わっている。"

#. type: TP
#: build/C/man3/ftw.3:261
#, no-wrap
msgid "B<FTW_SL>"
msgstr "B<FTW_SL>"

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: build/C/man3/ftw.3:272
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""
"I<fpath> がシンボリックリンクで、かつ B<FTW_PHYS> が I<flags> に セットされて"
"いた。"

#. type: TP
#: build/C/man3/ftw.3:272
#, no-wrap
msgid "B<FTW_SLN>"
msgstr "B<FTW_SLN>"

#. type: Plain text
#: build/C/man3/ftw.3:277
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)"
msgstr ""
"I<fpath> がシンボリックリンクで、存在しないファイルを指している (これがセット"
"されるのは B<FTW_PHYS> がセットされていない場合だけである)。"

#. type: Plain text
#: build/C/man3/ftw.3:283
msgid ""
"The fourth argument that B<nftw>()  supplies when calling I<fn>()  is a "
"structure of type I<FTW>:"
msgstr ""
"B<nftw>()  が I<fn>()  を呼び出す際に渡す 4つめの引き数は I<FTW> 型の構造体で"
"ある。"

#. type: Plain text
#: build/C/man3/ftw.3:290
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"

#. type: Plain text
#: build/C/man3/ftw.3:303
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""
"I<base> は、ファイル名 (basename 要素) の、 I<fpath> で渡されるパス名の中での"
"オフセットである。 I<level> はディレクトリツリーでの I<fpath> の深さを示す。"
"深さはディレクトリツリーのトップ (root) からの 相対値である (I<dirpath> は深"
"さ 0 である)。"

#. type: SH
#: build/C/man3/ftw.3:303 build/C/man3/getfsent.3:99
#: build/C/man3/getmntent.3:174 build/C/man2/getxattr.2:100
#: build/C/man2/listxattr.2:121 build/C/man2/mount.2:307
#: build/C/man2/removexattr.2:78 build/C/man2/setxattr.2:105
#: build/C/man2/spu_create.2:165 build/C/man2/spu_run.2:102
#: build/C/man2/stat.2:300 build/C/man2/statfs.2:129 build/C/man3/statvfs.3:96
#: build/C/man2/sysfs.2:67 build/C/man2/umount.2:99 build/C/man2/ustat.2:70
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/ftw.3:305
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr "これらの関数は、成功すると 0 を、エラーが発生すると -1 を返す。"

#. type: Plain text
#: build/C/man3/ftw.3:312
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""
"I<fn>()  が 0 以外を返した場合、ディレクトリツリーの探索を終了し、 I<fn>()  "
"が返した値を B<ftw>()  や B<nftw>()  の結果として返す。"

#. type: Plain text
#: build/C/man3/ftw.3:320
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""
"B<nftw>()  が B<FTW_ACTIONRETVAL> フラグ付きで呼ばれた場合、ツリーの探索を終"
"了させるために I<fn>()  が使用できる、非 0 の値は B<FTW_STOP> だけであり、 こ"
"の値は B<nftw>()  の返り値として返される。"

#. type: Plain text
#: build/C/man3/ftw.3:325
msgid "POSIX.1-2001, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as obsolete."
msgstr ""
"POSIX.1-2001, SVr4, SUSv1.  POSIX.1-2008 は B<ftw>()  を廃止予定としている。"

#. type: SH
#: build/C/man3/ftw.3:325 build/C/man3/getfsent.3:127
#: build/C/man3/getmntent.3:207 build/C/man2/mount.2:420
#: build/C/man2/spu_create.2:254 build/C/man2/spu_run.2:196
#: build/C/man2/stat.2:499 build/C/man2/statfs.2:196
#: build/C/man3/statvfs.3:159 build/C/man2/sysfs.2:94
#: build/C/man2/umount.2:159 build/C/man2/ustat.2:98
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/ftw.3:329
msgid ""
"POSIX.1-2001 note that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""
"POSIX.1-2001 の注記によると、 I<fn> がカレントワーキングディレクトリを保持し"
"なかった場合の 結果は規定されていないとされている。"

#. type: Plain text
#: build/C/man3/ftw.3:335
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""
"B<nftw>()  関数と、 B<ftw>()  における B<FTW_SL> は、SUSv1 で導入された。"

#. type: Plain text
#: build/C/man3/ftw.3:345
msgid ""
"On some systems B<ftw>()  will never use B<FTW_SL>, on other systems "
"B<FTW_SL> occurs only for symbolic links that do not point to an existing "
"file, and again on other systems B<ftw>()  will use B<FTW_SL> for each "
"symbolic link.  For predictable control, use B<nftw>()."
msgstr ""
"B<ftw>()  で B<FTW_SL> を一切使わないシステムや、 存在しないファイルを指して"
"いるシンボリックリンクの場合にのみ B<FTW_SL> を使うシステム、また B<ftw>()  "
"が全てのシンボリックリンクに対して B<FTW_SL> を使うシステムもある。 予測可能"
"な動作をさせるためには、 B<nftw>()  を使うこと。"

#. type: Plain text
#: build/C/man3/ftw.3:349
msgid ""
"Under Linux, libc4 and libc5 and glibc 2.0.6 will use B<FTW_F> for all "
"objects (files, symbolic links, FIFOs, etc.)  that can be stat'ed but are "
"not a directory."
msgstr ""
"Linux では、 libc4, libc5, glibc 2.0.6 は 「stat できるがディレクトリではない"
"オブジェクト」 (ファイル, シンボリックリンク, fifo 等)  に対してはすべて "
"B<FTW_F> を使う。"

#. type: Plain text
#: build/C/man3/ftw.3:353
msgid "The function B<nftw>()  is available since glibc 2.1."
msgstr "B<nftw>()  関数は glibc 2.1 以降で利用できる。"

#. type: Plain text
#: build/C/man3/ftw.3:355
msgid "B<FTW_ACTIONRETVAL> is glibc-specific."
msgstr "B<FTW_ACTIONRETVAL> は glibc 固有である。"

#. type: SH
#: build/C/man3/ftw.3:355 build/C/man2/spu_create.2:265
#: build/C/man2/spu_run.2:207 build/C/man7/spufs.7:759 build/C/man2/stat.2:590
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/ftw.3:364
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The "
"second command-line argument can be used to specify characters that control "
"the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""
"以下のプログラムは、一つ目のコマンドライン引き数を名前に持つパス以下の ディレ"
"クトリツリーを探索する。引き数が指定されなかった場合は、 カレントディレクトリ"
"以下を探索する。 各々のファイルについて様々の情報が表示される。 二番目のコマ"
"ンドライン引き数に文字を指定することで、 B<nftw>()  を呼び出す際に I<flags> "
"引き数に渡す値を制御することができる。"

#. type: Plain text
#: build/C/man3/ftw.3:372
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"

#. type: Plain text
#: build/C/man3/ftw.3:386
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d %7jd   %-40s %d %s\\en\",\n"
"        (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"        (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"        (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"        (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"        ftwbuf-E<gt>level, (intmax_t) sb-E<gt>st_size,\n"
"        fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d %7jd   %-40s %d %s\\en\",\n"
"        (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"        (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"        (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"        (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"        ftwbuf-E<gt>level, (intmax_t) sb-E<gt>st_size,\n"
"        fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"

#. type: Plain text
#: build/C/man3/ftw.3:391
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"

#. type: Plain text
#: build/C/man3/ftw.3:396
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"

#. type: Plain text
#: build/C/man3/ftw.3:404
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/ftw.3:409
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr "B<stat>(2), B<fts>(3), B<readdir>(3)"

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr "GETFSENT"

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "2002-02-28"
msgstr "2002-02-28"

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GNU"
msgstr "Linux"

#. type: Plain text
#: build/C/man3/getfsent.3:30
msgid ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr ""
"getfsent, getfsspec, getfsfile, setfsent, endfsent - fstab エントリの処理"

#. type: Plain text
#: build/C/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr "B<#include E<lt>fstab.hE<gt>>"

#. type: Plain text
#: build/C/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr "B<void endfsent(void);>"

#. type: Plain text
#: build/C/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr "B<struct fstab *getfsent(void);>"

#. type: Plain text
#: build/C/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"

#. type: Plain text
#: build/C/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"

#. type: Plain text
#: build/C/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr "B<int setfsent(void);>"

#. type: Plain text
#: build/C/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr ""
"これらの関数は I</etc/fstab> ファイルから情報を読み込む。I<fstab> 構造体は次"
"のように定義されている。"

#. type: Plain text
#: build/C/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-sysem type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr ""
"*BSD システムの場合、 I<fs_type> フィールドには、5 つの文字列 \"rw\", \"rq"
"\", \"ro\", \"sw\", \"xx\" のいずれかが入る (それぞれ read-write, quota 付き "
"read-write, read-only, swap, ignore)。"

#. type: Plain text
#: build/C/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at "
"the first line."
msgstr ""
"関数 B<setfsent>()  は呼び出されると fstab ファイルをオープンし、 最初の行に"
"移動する。"

#. type: Plain text
#: build/C/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr ""
"関数 B<getfsent>()  は fstab ファイルから次の行をパースする (必要な場合はファ"
"イルをオープンする)。"

#. type: Plain text
#: build/C/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr "関数 B<endfsent>()  は呼び出されると fstab ファイルをクローズする。"

#. type: Plain text
#: build/C/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr ""
"関数 B<getfsspec>()  は fstab ファイルを先頭から検索し、 I<fs_spec> フィール"
"ドが I<special_file> 引数にマッチするエントリが見つかったら、その最初のものを"
"返す。"

#. type: Plain text
#: build/C/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr ""
"関数 B<getfsfile>()  は fstab ファイルを先頭から検索し、 I<fs_file> フィール"
"ドが I<mount_point> 引数にマッチするエントリが見つかったら、その最初のものを"
"返す。"

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: build/C/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and B<getfsspec>"
"()  return a pointer to a I<struct fstab>, while B<setfsent>()  returns 1.  "
"Upon failure or end-of-file, these functions return NULL and 0, respectively."
msgstr ""
"成功すると、 B<getfsent>(), B<getfsfile>(), B<getfsspec>()  の各関数は "
"I<fstab> 構造体へのポインタを返し、 B<setfsent>()  関数は 1 を返す。 失敗する"
"とこれらの関数は NULL を返し、 end-of-file になったら 0 を返す。"

#. type: Plain text
#: build/C/man3/getfsent.3:127
msgid ""
"These functions are not in POSIX.1-2001.  Several operating systems have "
"them, e.g., *BSD, SunOS, Digital UNIX, AIX (which also has a B<getfstype>"
"()).  HP-UX has functions of the same names, that however use a I<struct "
"checklist> instead of a I<struct fstab>, and calls these functions obsolete, "
"superseded by B<getmntent>(3)."
msgstr ""
"POSIX.1-2001 にはこれらの関数は存在しない。 これらの関数をもつ OS はいくつか"
"あり、 *BSD, SunOS, Digital UNIX, AIX 等である (AIX には B<getfstype>()  もあ"
"る)。 HP-UX にも同名の関数群があるが、 HP-UX のものは I<fstab> 構造体ではな"
"く I<checklist> 構造体を用いる。 またこれらの関数の呼び出しは obsolete で、 "
"B<getmntent>(3)  に取って代わられている。"

#. type: Plain text
#: build/C/man3/getfsent.3:129
msgid "These functions are not thread-safe."
msgstr "これらの関数はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/getfsent.3:139
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr ""
"Linux ではブロックスペシャルデバイスを複数の場所にマウントでき、 また複数のデ"
"バイスが同じマウントポイントを共有できる (この場合はそのマウントポイントに最"
"後にマウントされたデバイスが意味を持つ)  が、 B<getfsfile>()  と B<getfsspec>"
"()  はマッチした最初のエントリしか返さないので、 これらの 2 つの関数は Linux "
"での利用には適していない。"

#. type: Plain text
#: build/C/man3/getfsent.3:142
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr "B<getmntent>(3), B<fstab>(5)"

#. type: TH
#: build/C/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr "GETMNTENT"

#. type: TH
#: build/C/man3/getmntent.3:32
#, no-wrap
msgid "2009-09-15"
msgstr "2009-09-15"

#. type: Plain text
#: build/C/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"file system descriptor file entry"
msgstr ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - ファイル"
"システム記述ファイルのエントリを取得する"

#. type: Plain text
#: build/C/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:42
#, no-wrap
msgid "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<fp>B<);>\n"
msgstr "B<struct mntent *getmntent(FILE *>I<fp>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<fp>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr "B<int addmntent(FILE *>I<fp>B<, const struct mntent *>I<mnt>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<fp>B<);>\n"
msgstr "B<int endmntent(FILE *>I<fp>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:50
#, no-wrap
msgid "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""
"/* GNU による拡張 */\n"
"B<#include E<lt>mntent.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<fp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""
"B<struct mntent *getmntent_r(FILE *>I<fp>B<, struct mntent *>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"

#. type: Plain text
#: build/C/man3/getmntent.3:61 build/C/man2/stat.2:59
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/getmntent.3:65
msgid "B<getmntent_r>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<getmntent_r>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/getmntent.3:70
#, fuzzy
#| msgid ""
#| "These routines are used to access the file system description file I</etc/"
#| "fstab> and the mounted file system description file I<etc/mtab>."
msgid ""
"These routines are used to access the file system description file I</etc/"
"fstab> and the mounted file system description file I</etc/mtab>."
msgstr ""
"これらのルーチンは、ファイルシステムを記述したファイル I</etc/fstab> と、マウ"
"ントされているファイルシステムを記述したファイル I</etc/mtab> にアクセスする"
"ために用いられる。"

#. type: Plain text
#: build/C/man3/getmntent.3:84
msgid ""
"The B<setmntent>()  function opens the file system description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>().  "
"The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3)."
msgstr ""
"B<setmntent>()  関数は、ファイルシステムの記述ファイル I<filename> をオープン"
"して、 そのファイルポインタを返す。このファイルポインタは B<getmntent>()  に"
"よって用いられる。引き数 I<type> は要求するアクセス形式で、 B<fopen>(3)  の "
"I<mode> 引き数と同じ値を取ることができる。"

#. type: Plain text
#: build/C/man3/getmntent.3:96
msgid ""
"The B<getmntent>()  function reads the next line from the file system "
"description file I<fp> and returns a pointer to a structure containing the "
"broken out fields from a line in the file.  The pointer points to a static "
"area of memory which is overwritten by subsequent calls to B<getmntent>()."
msgstr ""
"B<getmntent>()  関数はファイルシステムの記述ファイル I<fp> から新しい行を読 "
"み込み、行をフィールドに分割した内容を収めた構造体へのポインタを返す。 ポイン"
"タはメモリの静的な領域を指しており、この領域は B<getmntent>()  を次に呼び出し"
"たときに上書きされてしまう。"

#. type: Plain text
#: build/C/man3/getmntent.3:106
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open file I<fp>."
msgstr ""
"B<addmntent>()  関数は I<mntent> 構造体 I<mnt> の内容を、オープンされている"
"ファイル I<fp> の最後に追加する。"

#. type: Plain text
#: build/C/man3/getmntent.3:111
msgid ""
"The B<endmntent>()  function closes the file system description file I<fp>."
msgstr "B<endmntent>()  関数はファイルシステムの記述ファイル I<fp> を閉じる。"

#. type: Plain text
#: build/C/man3/getmntent.3:128
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the "
"I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr ""
"B<hasmntopt>()  関数は I<mntent> 構造体 I<mnt> の I<mnt_opts> フィールド (下"
"記 参照) をスキャンし、 I<opt> に一致する部分文字列があるかを調べる。 有効な"
"マウントオプションについては I<E<lt>mntent.hE<gt>> と B<mount>(8)  を参照のこ"
"と。"

#. type: Plain text
#: build/C/man3/getmntent.3:142
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings "
"pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr ""
"リエントラントな関数 B<getmntent_r>()  は B<getmntent>()  と同じだが、 ユーザ"
"が用意した I<*mntbuf> に I<struct mount> を格納し、その構造体の各エントリが指"
"し示す文字列を ユーザが用意した大きさ I<buflen> の配列 I<buf> に書き込む。"

#. type: Plain text
#: build/C/man3/getmntent.3:148
msgid "The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr ""
"I<mntent> 構造体は I<E<lt>mntent.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man3/getmntent.3:159
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted file system */\n"
"    char *mnt_dir;      /* file system path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted file system */\n"
"    char *mnt_dir;      /* file system path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"

#. type: Plain text
#: build/C/man3/getmntent.3:174
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the four characters space (\\e040), tab "
"(\\e011), newline (\\e012) and backslash (\\e134) in those files when they "
"occur in one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back."
msgstr ""
"mtab や fstab ファイルでは、各フィールドは空白で区切られているので、 スペー"
"ス、タブ、改行、バックスラッシュの 4文字をこれらのファイルで 使いたい場合で、"
"かつ I<mntent> 構造体の 4つの文字列メンバーのいずれかに対応するフィールド内"
"で 使いたい場合には、8進のエスケープ表記を使って表現する: スペース (\\e040), "
"タブ (\\e011), 改行 (\\e012), バックスラッシュ (\\e134)。 B<addmntent>()  と "
"B<getmntent>()  は、文字列表現から エスケープ表現への変換、およびその逆を行"
"う。"

#. type: Plain text
#: build/C/man3/getmntent.3:183
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr ""
"B<getmntent>()  と B<getmntent_r>()  は I<mntent> 構造体へのポインタを返す。 "
"失敗した場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/getmntent.3:187
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr "B<addmntent>()  関数は成功したら 0 を返し、失敗したら 1 を返す。"

#. type: Plain text
#: build/C/man3/getmntent.3:191
msgid "The B<endmntent>()  function always returns 1."
msgstr "B<endmntent>()  関数はつねに 1 を返す。"

#. type: Plain text
#: build/C/man3/getmntent.3:196
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match "
"is found and NULL otherwise."
msgstr ""
"B<hasmntopt>()  関数は、マッチした場合は部分文字列へのアドレスを返し、 マッチ"
"しなければ NULL を返す。"

#. type: SH
#: build/C/man3/getmntent.3:196 build/C/man2/spu_create.2:240
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man3/getmntent.3:200
#, no-wrap
msgid ""
"/etc/fstab          file system description file\n"
"/etc/mtab           mounted file system description file\n"
msgstr ""
"/etc/fstab          ファイルシステム記述ファイル\n"
"/etc/mtab           マウントされたファイルシステムの記述ファイル\n"

#. type: Plain text
#: build/C/man3/getmntent.3:207
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine B<getmntent_r>"
"()  was introduced in HP-UX 10, but it returns an int.  The prototype shown "
"above is glibc-only."
msgstr ""
"リエントラントでない関数は SunOS 4.1.3 由来のものである。 B<getmntent_r>()  "
"関数は HPUX 10 で導入されたが、このバージョンでは int を返す。 上記に示したプ"
"ロトタイプは glibc 独自のものである。"

#. type: Plain text
#: build/C/man3/getmntent.3:219
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V I</etc/"
"mnttab> is used.  4.4BSD and Digital UNIX have a routine B<getmntinfo>(), a "
"wrapper around the system call B<getfsstat>()."
msgstr ""
"System V にも B<getmntent>()  関数はあるが、 呼び出し手順が異なり、返される構"
"造体も異なる。 System V では I</etc/mnttab> が用いられる。 4.4BSD と Digital "
"UNIX には B<getmntinfo>()  があるが、 システムコール B<getfsstat>()  のラッ"
"パー関数である。"

#. type: Plain text
#: build/C/man3/getmntent.3:223
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr "B<fopen>(3), B<fstab>(5), B<mount>(8)"

#. type: TH
#: build/C/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr "GETXATTR"

#. type: TH
#: build/C/man2/getxattr.2:25 build/C/man2/removexattr.2:25
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "2013-01-19"
msgstr "2013-01-19"

#. type: Plain text
#: build/C/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr "getxattr, lgetxattr, fgetxattr - 拡張属性の値を取得する"

#. type: Plain text
#: build/C/man2/getxattr.2:33 build/C/man2/listxattr.2:33
#: build/C/man2/removexattr.2:33 build/C/man2/setxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>attr/xattr.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>attr/xattr.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/getxattr.2:53 build/C/man2/setxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<attr>(5)."
msgstr ""
"拡張属性は、inode (ファイル、ディレクトリ、シンボリックリンク等) に 関連付け"
"られた I<name>:I<value> の対である。 これらは、システム上のすべての inode に"
"関連付けられた通常の属性 (B<stat>(2)  が返すデータ) を拡張するものである。 拡"
"張属性のコンセプトは B<attr>(5)  に書かれている。"

#. type: Plain text
#: build/C/man2/getxattr.2:65
msgid ""
"B<getxattr>()  retrieves the I<value> of the extended attribute identified "
"by I<name> and associated with the given I<path> in the file system.  The "
"length of the attribute I<value> is returned."
msgstr ""
"B<getxattr>()  は、ファイルシステム内の指定された I<path> に対応する、名前 "
"I<name> の拡張属性の I<value> (値) を取得する。 属性 I<value> の長さが返され"
"る。"

#. type: Plain text
#: build/C/man2/getxattr.2:71
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr ""
"B<lgetxattr>()  は B<getxattr>()  と同じだが、シンボリックリンクの場合に、リ"
"ンクが参照しているファイル ではなく、リンクそのものの情報を取得する点だけが異"
"なる。"

#. type: Plain text
#: build/C/man2/getxattr.2:81
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of I<path>."
msgstr ""
"B<fgetxattr>()  は B<getxattr>()  と同じだが、 I<path> の代わりに I<fd> で参"
"照されたオープン済みファイルの情報だけを取得する点が異なる (I<fd> は B<open>"
"(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/getxattr.2:89
msgid ""
"An extended attribute I<name> is a simple null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data of specified length."
msgstr ""
"拡張属性の名前 I<name> は普通の NULL 終端された文字列である。 名前には、名前"
"空間を表す接頭辞 (prefix) が含まれる; 個々の inode に対して、互いに独立な名前"
"空間が複数あってもよい。 拡張属性の値は、ある一定の長さの任意のテキスト・デー"
"タまたは バイナリ・データの集合である。"

#. type: Plain text
#: build/C/man2/getxattr.2:96
msgid ""
"An empty buffer of I<size> zero can be passed into these calls to return the "
"current size of the named extended attribute, which can be used to estimate "
"the size of a buffer which is sufficiently large to hold the value "
"associated with the extended attribute."
msgstr ""
"I<size> に 0 を指定して空のバッファをこれらのシステムコールに渡すことがで"
"き、 この場合には指定された名前の拡張属性の現在のサイズが返される。 この方法"
"は、拡張属性の値を保持するのに十分な大きさのバッファ・サイズを 見積もるのに使"
"うことができる、"

#. type: Plain text
#: build/C/man2/getxattr.2:100
msgid ""
"The interface is designed to allow guessing of initial buffer sizes, and to "
"enlarge buffers when the return value indicates that the buffer provided was "
"too small."
msgstr ""
"このシステムコール・インタフェースは、初期バッファのサイズの推測をしたり、 与"
"えられたバッファが小さすぎたことを返り値で知らせることでバッファを大きく した"
"りできるように設計されている。"

#. type: Plain text
#: build/C/man2/getxattr.2:106
msgid ""
"On success, a positive number is returned indicating the size of the "
"extended attribute value.  On failure, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、拡張属性の値の長さを表す正の数が返される。 失敗した場合、 -1 が"
"返され、 I<errno> に適切な値がセットされる。"

#. type: TP
#: build/C/man2/getxattr.2:107 build/C/man2/removexattr.2:84
#: build/C/man2/setxattr.2:119
#, no-wrap
msgid "B<ENOATTR>"
msgstr "B<ENOATTR>"

#. type: Plain text
#: build/C/man2/getxattr.2:116
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute.  (B<ENOATTR> is defined to be a synonym for B<ENODATA> in "
"I<E<lt>attr/xattr.hE<gt>>.)"
msgstr ""
"指定された名前の属性が存在しない、またはプロセスがその属性にアクセスする権限"
"がない (B<ENOATTR> は I<E<lt>attr/xattr.hE<gt>> で B<ENODATA> の同義語として"
"定義されている)。"

#. type: TP
#: build/C/man2/getxattr.2:116 build/C/man2/listxattr.2:128
#: build/C/man2/removexattr.2:92 build/C/man2/setxattr.2:131
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man2/getxattr.2:119 build/C/man2/listxattr.2:131
#: build/C/man2/removexattr.2:95
msgid ""
"Extended attributes are not supported by the file system, or are disabled."
msgstr ""
"拡張属性がそのファイルシステムでサポートされていない、 もしくは無効になってい"
"る。"

#. type: TP
#: build/C/man2/getxattr.2:119 build/C/man2/listxattr.2:131
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man2/getxattr.2:126
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr ""
"I<value> バッファの大きさ I<size> が結果を保持するのに十分な大きさでなかっ"
"た。"

#. type: Plain text
#: build/C/man2/getxattr.2:130 build/C/man2/listxattr.2:142
#: build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:141
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr "上記に加えて、 B<stat>(2) に書かれているエラーが発生する場合もある。"

#. type: Plain text
#: build/C/man2/getxattr.2:133 build/C/man2/listxattr.2:145
#: build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:144
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""
"これらのシステムコールはカーネル 2.4 以降の Linux で利用できる。 glibc でのサ"
"ポートはバージョン 2.3 以降で行われている。"

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: build/C/man2/getxattr.2:141 build/C/man2/listxattr.2:153
#: build/C/man2/removexattr.2:110 build/C/man2/setxattr.2:152
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/getxattr.2:151
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), B<removexattr>"
"(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), B<removexattr>"
"(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: build/C/man2/listxattr.2:25
#, no-wrap
msgid "LISTXATTR"
msgstr "LISTXATTR"

#. type: TH
#: build/C/man2/listxattr.2:25
#, no-wrap
msgid "2013-04-09"
msgstr "2013-04-09"

#. type: Plain text
#: build/C/man2/listxattr.2:28
msgid "listxattr, llistxattr, flistxattr - list extended attribute names"
msgstr "listxattr, llistxattr, flistxattr - 拡張属性の名前リストを得る"

#. type: Plain text
#: build/C/man2/listxattr.2:39
#, no-wrap
msgid ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
msgstr ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man2/listxattr.2:50
msgid ""
"Extended attributes are name:value pairs associated with inodes (files, "
"directories, symbolic links, etc.).  They are extensions to the normal "
"attributes which are associated with all inodes in the system (i.e., the "
"B<stat>(2)  data).  A complete overview of extended attributes concepts can "
"be found in B<attr>(5)."
msgstr ""
"拡張属性は、inode (ファイル、ディレクトリ、シンボリックリンク等) に 関連付け"
"られた I<name>:I<value> の対である。 これらは、システム上のすべての inode に"
"関連付けられた通常の属性 (B<stat>(2)  が返すデータ) を拡張するものである。 拡"
"張属性のコンセプトは B<attr>(5)  に書かれている。"

#. type: Plain text
#: build/C/man2/listxattr.2:66
msgid ""
"B<listxattr>()  retrieves the list of extended attribute names associated "
"with the given I<path> in the file system.  The retrieved list is placed in "
"I<list>, a caller-allocated buffer whose size (in bytes) is specified in the "
"argument I<size>.  The list is the set of (null-terminated) names, one after "
"the other.  Names of extended attributes to which the calling process does "
"not have access may be omitted from the list.  The length of the attribute "
"name I<list> is returned."
msgstr ""
"B<listxattr>()  は、ファイルシステム内の指定された I<path> に対応する拡張属性"
"の名前リストを取得する。取得したリストは I<list> に格納される。 I<list> は呼"
"び出し側で確保するバッファで、引き数 I<size> でバッファのサイズを (バイト単位"
"で) 指定する。リストは名前の集合で、 NULL 終端された文字列が連続して並んでい"
"る。呼び出したプロセスがアクセスする権限のない拡張属性の名前は、リストに含ま"
"れない。拡張属性の名前の I<list> の長さが返される。"

#. type: Plain text
#: build/C/man2/listxattr.2:73
msgid ""
"B<llistxattr>()  is identical to B<listxattr>(), except in the case of a "
"symbolic link, where the list of names of extended attributes associated "
"with the link itself is retrieved, not the file that it refers to."
msgstr ""
"B<llistxattr>()  は B<listxattr>()  と同じだが、シンボリックリンクの場合に、"
"リンクが参照しているファイル ではなく、リンクそのものの拡張属性の名前リストを"
"取得する点だけが異なる。"

#. type: Plain text
#: build/C/man2/listxattr.2:83
msgid ""
"B<flistxattr>()  is identical to B<listxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of I<path>."
msgstr ""
"B<flistxattr>()  は B<listxattr>()  と同じだが、 I<path> の代わりに I<fd> で"
"参照されたオープン済みファイルの情報だけを取得する点が異なる (I<filedes> は "
"B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/listxattr.2:89
msgid ""
"A single extended attribute I<name> is a simple null-terminated string.  The "
"name includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""
"個々の拡張属性の I<name> は普通の NULL 終端された文字列である。 名前には、名"
"前空間を表す接頭辞 (prefix) が含まれる; 個々の inode に対して、互いに独立な名"
"前空間が複数あってもよい。"

#. type: Plain text
#: build/C/man2/listxattr.2:95
msgid ""
"An empty buffer of I<size> zero can be passed into these calls to return the "
"current size of the list of extended attribute names, which can be used to "
"estimate the size of a buffer which is sufficiently large to hold the list "
"of names."
msgstr ""
"I<size> に 0 を指定して空のバッファをこれらのシステムコールに渡すことがで"
"き、 この場合には拡張属性の名前リストの現在のサイズが返される。 この方法は名"
"前リストを保持するのに十分な大きさのバッファ・サイズを 見積もるのに使うことが"
"できる、"

#. type: SS
#: build/C/man2/listxattr.2:95
#, no-wrap
msgid "Example"
msgstr "Example"

#. type: Plain text
#: build/C/man2/listxattr.2:100
msgid ""
"The I<list> of names is returned as an unordered array of null-terminated "
"character strings (attribute names are separated by null bytes (\\(aq"
"\\e0\\(aq)), like this:"
msgstr ""
"返される名前の I<list> は、 NULL 終端された文字列の配列 (属性名は NULL バイ"
"ト (\\(aq\\e0\\(aq)  で区切られている) で、各要素は整列されている訳ではな"
"い。 以下に例を示す:"

#. type: Plain text
#: build/C/man2/listxattr.2:105
#, no-wrap
msgid "user.name1\\e0system.name1\\e0user.name2\\e0\n"
msgstr "user.name1\\e0system.name1\\e0user.name2\\e0\n"

#. type: Plain text
#: build/C/man2/listxattr.2:113
msgid ""
"Filesystems like ext2, ext3 and XFS which implement POSIX ACLs using "
"extended attributes, might return a I<list> like this:"
msgstr ""
"拡張属性を使って POSIX ACL を実装している ext2、ext3、XFS のようなファイル シ"
"ステムでは、返される I<list> は以下のようになることだろう:"

#. type: Plain text
#: build/C/man2/listxattr.2:118
#, no-wrap
msgid "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"
msgstr "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"

#. type: Plain text
#: build/C/man2/listxattr.2:127
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute name list.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"成功した場合、拡張属性の名前リストの長さを表す非負の数が返される。 失敗した場"
"合、 -1 が返され、 I<errno> に適切な値がセットされる。"

#. type: Plain text
#: build/C/man2/listxattr.2:138
msgid "The I<size> of the I<list> buffer is too small to hold the result."
msgstr ""
"I<list> バッファの大きさ I<size> が結果を保持するのに十分な大きさでなかった。"

#. type: Plain text
#: build/C/man2/listxattr.2:163
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), B<removexattr>"
"(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), B<removexattr>"
"(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: build/C/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr "MOUNT"

#. type: TH
#: build/C/man2/mount.2:40
#, no-wrap
msgid "2012-07-05"
msgstr "2012-07-05"

#. type: Plain text
#: build/C/man2/mount.2:43
msgid "mount - mount file system"
msgstr "mount - ファイルシステムをマウント/アンマウントする"

#. type: Plain text
#: build/C/man2/mount.2:46 build/C/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mount.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long >I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man2/mount.2:58
msgid ""
"B<mount>()  attaches the file system specified by I<source> (which is often "
"a device name, but can also be a directory name or a dummy) to the directory "
"specified by I<target>."
msgstr ""
"B<mount>()  は I<source> で指定されたファイルシステム (デバイス名であることが"
"多いが、 ディレクトリ名やダミーの場合もある) を I<target> で指定されたディレ"
"クトリに結びつける。"

#. type: Plain text
#: build/C/man2/mount.2:62
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount file systems."
msgstr ""
"ファイルシステムのマウントを行うには、 適切な権限 (Linux では "
"B<CAP_SYS_ADMIN> ケーパビリティ) が必要である。"

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: build/C/man2/mount.2:67
msgid ""
"Since Linux 2.4 a single file system can be visible at multiple mount "
"points, and multiple mounts can be stacked on the same mount point."
msgstr ""
"Linux 2.4 以降、ひとつのファイルシステムを複数のマウントポイントに 結びつける"
"ことができ、同じマウントポイントに複数のマウントをスタック させることもでき"
"る。"

#. type: Plain text
#: build/C/man2/mount.2:76
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed "
"in I</proc/filesystems> (e.g., \"minix\", \"ext2\", \"ext3\", \"jfs\", \"xfs"
"\", \"reiserfs\", \"msdos\", \"proc\", \"nfs\", \"iso9660\").  Further types "
"may become available when the appropriate modules are loaded."
msgstr ""
"引き数 I<filesystemtype> としてカーネルが対応している値は、 I</proc/"
"filesystems> で参照できる (例えば \"minix\", \"ext2\", \"ext3\", \"jfs\", "
"\"xfs\", \"reiserfs\", \"msdos\", \"proc\", \"nfs\", \"iso9660\" 等)。 適切な"
"モジュールが読み込まれると、さらに別の値が利用可能になるかもしれない。"

#.  (as defined in \fI<linux/fs.h>\fP for libc4 and libc5
#.  and in \fI<sys/mount.h>\fP for glibc2)
#.  FIXME 2.6.15 added flags for "shared subtree" functionality:
#.  MS_UNBINDABLE, MS_PRIVATE, MS_SHARED, MS_SLAVE
#. 	MS_PRIVATE.
#. 		All mounts are private by default. Previously shared mouns
#. 		can be remarked PRIVATE.
#. 	MS_SHARED
#. 		Mount points that are marked SHARED propagate mount events
#. 		to one another after bing cloned.
#. 	MS_SLAVE
#. 		A previously shared mount point can be marked SALVE, meaning
#. 		it receives propagated events, but does not propagate events.
#. 	MS_UNBINDABLE
#. 		mounts cannot be bound into other places, and will not be
#. 		propagated into new subtrees	
#. 	mount --make-rshared ==> MS_SHARED | MS_REC
#.  These settings are visible in proc/mountinfo
#.  These need to be documented on this page.
#.  See:
#.  Documentation/filesystems/sharedsubtree.txt
#.  http://lwn.net/Articles/159077/
#.  http://myweb.sudhaa.com:2022/~ram/sharedsubtree/paper/sharedsubtree.1.pdf
#.  Shared-Subtree Concept, Implementation, and Applications in Linux
#.  Al Viro viro@ftp.linux.org.uk
#.  Ram Pai linuxram@us.ibm.com
#.  http://foss.in/2005/slides/sharedsubtree1.pdf
#.  Shared Subtree Concept and Implementation in the Linux Kernel
#.  Ram Pai
#.  http://www.ibm.com/developerworks/linux/library/l-mount-namespaces/index.html
#.      Applying mount namespaces
#.      Uncover practical applications for advanced Linux mounts features
#.      Serge E. Hallyn (sergeh@us.ibm.com), Software Engineer, IBM　
#.      Ram Pai (linuxram@us.ibm.com), Software Engineer, IBM
#.      Date:  17 Sep 2007
#.  2.6.25 Added MS_I_VERSION, which needs to be documented.
#. type: Plain text
#: build/C/man2/mount.2:131
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)  "
"in the top 16 bits (this was required in kernel versions prior to 2.4, but "
"is no longer required and ignored if specified), and various mount flags in "
"the low order 16 bits:"
msgstr ""
"引き数 I<mountflags> の上位 16 ビットには、マジックナンバー 0xC0ED\n"
"(B<MS_MGC_VAL>) を指定することができる (マジックナンバーは、\n"
"カーネルバージョン 2.4 より前では必須であったが、\n"
"現在は必要なく、指定されても無視される)。\n"
"I<mountflags> の下位 16 ビットにマウントフラグを指定する。"

#. type: TP
#: build/C/man2/mount.2:131
#, no-wrap
msgid "B<MS_BIND> (Linux 2.4 onward)"
msgstr "B<MS_BIND> (Linux 2.4 以降)"

#.  since 2.4.0-test9
#.  with the exception of the "hidden" MS_REC mountflags bit
#. type: Plain text
#: build/C/man2/mount.2:150
msgid ""
"Perform a bind mount, making a file or a directory subtree visible at "
"another point within a file system.  Bind mounts may cross file system "
"boundaries and span B<chroot>(2)  jails.  The I<filesystemtype> and I<data> "
"arguments are ignored.  Up until Linux 2.6.26, I<mountflags> was also "
"ignored (the bind mount has the same mount options as the underlying mount "
"point)."
msgstr ""
"バインドマウントを行う。これはファイルやディレクトリの部分木を ファイルシス\n"
"テム内部の別の場所で見えるようにするものである。 バインドマウントを使うと、\n"
"ファイルシステムをまたいで B<chroot>(2) jail を構成することが可能になる。\n"
"引き数 I<filesystemtype> と I<data> は無視される。 Linux 2.6.26 より前では\n"
"I<mountflags> も無視されていた (バインドマウントでは、マウントポイントとな"
"る\n"
"ファイルシステムと同じマウントオプションが使用される)。"

#. type: TP
#: build/C/man2/mount.2:150
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr "B<MS_DIRSYNC> (Linux 2.5.19 以降)"

#. type: Plain text
#: build/C/man2/mount.2:156
msgid ""
"Make directory changes on this file system synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr ""
"このファイルシステムへのディレクトリ変更を同期的に行う。 (この特性は個々の"
"ディレクトリ、または B<chattr>(1)  を使った部分木毎に設定できる。)"

#. type: TP
#: build/C/man2/mount.2:156
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr "B<MS_MANDLOCK>"

#.  FIXME Say more about MS_MOVE
#. type: Plain text
#: build/C/man2/mount.2:163
msgid ""
"Permit mandatory locking on files in this file system.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)"
msgstr ""
"このファイルシステムのファイルに対して強制ロックを認める。 (強制ロックを有効"
"にするには、 B<fcntl>(2)  で述べられている方法でファイル単位で許可をしなけれ"
"ばならない)"

#. type: TP
#: build/C/man2/mount.2:163
#, no-wrap
msgid "B<MS_MOVE>"
msgstr "B<MS_MOVE>"

#. type: Plain text
#: build/C/man2/mount.2:174
msgid ""
"Move a subtree.  I<source> specifies an existing mount point and I<target> "
"specifies the new location.  The move is atomic: at no point is the subtree "
"unmounted.  The I<filesystemtype>, I<mountflags>, and I<data> arguments are "
"ignored."
msgstr ""
"部分木を移動する。 I<source> にはすでに存在するマウントポイントを指定し、 "
"I<target> には新しい場所を指定する。 移動はアトミックである。 操作の実行中、"
"部分ツリーがアンマウントされることはない。 I<filesystemtype>, I<mountflags>, "
"I<data> 引き数は無視される。"

#. type: TP
#: build/C/man2/mount.2:174
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr "B<MS_NOATIME>"

#. type: Plain text
#: build/C/man2/mount.2:177
msgid ""
"Do not update access times for (all types of) files on this file system."
msgstr ""
"このファイルシステムの (全ての種類の) ファイルのアクセス時刻を更新しない。"

#. type: TP
#: build/C/man2/mount.2:177
#, no-wrap
msgid "B<MS_NODEV>"
msgstr "B<MS_NODEV>"

#. type: Plain text
#: build/C/man2/mount.2:180
msgid "Do not allow access to devices (special files) on this file system."
msgstr ""
"このファイルシステムのデバイス (スペシャルファイル) へのアクセスを許可しな"
"い。"

#. type: TP
#: build/C/man2/mount.2:180
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr "B<MS_NODIRATIME>"

#. type: Plain text
#: build/C/man2/mount.2:189
msgid ""
"Do not update access times for directories on this file system.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr ""
"このファイルシステムのディレクトリのアクセス時刻を更新しない。 このフラグは "
"B<MS_NOATIME> で提供される機能のサブセットを提供する。つまり、 B<MS_NOATIME> "
"では B<MS_NODIRATIME> が暗黙のうち設定される。"

#. type: TP
#: build/C/man2/mount.2:189
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr "B<MS_NOEXEC>"

#.  (Possibly useful for a file system that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: build/C/man2/mount.2:195
msgid "Do not allow programs to be executed from this file system."
msgstr "このファイルシステムにあるプログラムの実行を許可しない。"

#. type: TP
#: build/C/man2/mount.2:195
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr "B<MS_NOSUID>"

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: build/C/man2/mount.2:201
msgid ""
"Do not honor set-user-ID and set-group-ID bits when executing programs from "
"this file system."
msgstr ""
"このファイルシステムのプログラムを実行するときに、 set-user-ID ビットと set-"
"group-ID ビットを無視する。"

#. type: TP
#: build/C/man2/mount.2:201
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr "B<MS_RDONLY>"

#.  FIXME Document MS_REC, available since 2.4.11.
#.  This flag has meaning in conjunction with MS_BIND and
#.  also with the shared subtree flags.
#. type: Plain text
#: build/C/man2/mount.2:208
msgid "Mount file system read-only."
msgstr "ファイルシステムを読み込み専用でマウントする。"

#. type: TP
#: build/C/man2/mount.2:208
#, no-wrap
msgid "B<MS_RELATIME> (Since Linux 2.6.20)"
msgstr "B<MS_RELATIME> (Linux 2.6.20 以降)"

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last acces time) work correctly.
#. type: Plain text
#: build/C/man2/mount.2:229
msgid ""
"When a file on this file system is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the "
"file's last modification time (mtime)  or last status change time (ctime).  "
"This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr ""
"このファイルシステム上のファイルがアクセスされた際、 そのファイルの最終アクセ"
"ス時刻 (atime) の現在値が 最終修正時刻 (mtime) や最終状態変更時刻 (ctime) と "
"等しいか小さい場合にのみ、atime を更新する。 このオプションは、 B<mutt>(1)  "
"のように、最後の内容修正以降にファイルがいつ読み出されたかを知る 必要があるプ"
"ログラムで有用である。 Linux 2.6.30 以降では、 B<MS_NOATIME> が指定されていな"
"い場合には、このフラグの動作が カーネルのデフォルト動作となっており、 Linux "
"2.6.30 より前の動作をさせるためには B<MS_STRICTATIME> フラグを指定する必要が"
"ある。 これに加えて、Linux 2.6.30 以降では、 ファイルの最終アクセス時刻が 1 "
"日以上前の場合、 ファイルの最終アクセス時刻は常に更新される。"

#. type: TP
#: build/C/man2/mount.2:229
#, no-wrap
msgid "B<MS_REMOUNT>"
msgstr "B<MS_REMOUNT>"

#. type: Plain text
#: build/C/man2/mount.2:245
msgid ""
"Remount an existing mount.  This allows you to change the I<mountflags> and "
"I<data> of an existing mount without having to unmount and remount the file "
"system.  I<target> should be the same value specified in the initial B<mount>"
"()  call; I<source> and I<filesystemtype> are ignored."
msgstr ""
"すでに存在するマウントを再マウントする。これにより、すでに存在するマウントの "
"I<mountflags> と I<data> を、一度アンマウントしてから再マウントするという作業"
"をせずに 変更できる。 I<target> は最初の B<mount>() 呼び出しと同じ値を指定す"
"る必要がある。 I<source> と I<filesystemtype> は無視される。"

#. type: Plain text
#: build/C/man2/mount.2:260
msgid ""
"The following I<mountflags> can be changed: B<MS_RDONLY>, B<MS_SYNCHRONOUS>, "
"B<MS_MANDLOCK>; before kernel 2.6.16, the following could also be changed: "
"B<MS_NOATIME> and B<MS_NODIRATIME>; and, additionally, before kernel 2.4.10, "
"the following could also be changed: B<MS_NOSUID>, B<MS_NODEV>, B<MS_NOEXEC>."
msgstr ""
"I<mountflags> のうち B<MS_RDONLY>, B<MS_SYNCHRONOUS>, B<MS_MANDLOCK> は変更可"
"能である。 カーネル 2.6.16 より前では、 B<MS_NOATIME>, B<MS_NODIRATIME> も変"
"更可能であった。 カーネル 2.4.10 より前では、上記に加えて、 B<MS_NOSUID>, "
"B<MS_NODEV>, B<MS_NOEXEC> も変更可能であった。"

#. type: TP
#: build/C/man2/mount.2:260
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr "B<MS_SILENT> (Linux 2.6.17 以降)"

#. type: Plain text
#: build/C/man2/mount.2:268
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr ""
"カーネルのログ内のある種の (I<printk>())  警告メッセージの表示を抑制する。 こ"
"のフラグは、名前が不適切で廃止された B<MS_VERBOSE> フラグ (Linux 2.4.12 以降"
"で利用可能) を置き換えるもので、同じ意味を持つ。"

#. type: TP
#: build/C/man2/mount.2:268
#, no-wrap
msgid "B<MS_STRICTATIME> (Since Linux 2.6.30)"
msgstr "B<MS_STRICTATIME> (Linux 2.6.30 以降)"

#. type: Plain text
#: build/C/man2/mount.2:278
msgid ""
"Always update the last access time (atime) when files on this file system "
"are accessed.  (This was the default behavior before Linux 2.6.30.)  "
"Specifying this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr ""
"このファイルシステムがアクセスされた際に最終アクセス時刻 (atime)  を常に更新"
"する (Linux 2.6.30 より前では、これがデフォルトの動作 であった)。 このフラグ"
"を指定することで、 B<MS_NOATIME> と B<MS_RELATIME> の両フラグを設定した際の影"
"響を上書きすることができる。"

#. type: TP
#: build/C/man2/mount.2:278
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr "B<MS_SYNCHRONOUS>"

#. type: Plain text
#: build/C/man2/mount.2:286
msgid ""
"Make writes on this file system synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this file system)."
msgstr ""
"ファイルシステムに対して同期的に書き込みを行う。 (このファイルシステムの全て"
"のオープンされたファイルに対して、 B<open>(2)  のフラグに B<O_SYNC> を指定し"
"たような動作となる)"

#. type: Plain text
#: build/C/man2/mount.2:298
msgid ""
"From Linux 2.4 onward, the B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags "
"are settable on a per-mount-point basis.  From kernel 2.6.16 onward, "
"B<MS_NOATIME> and B<MS_NODIRATIME> are also settable on a per-mount-point "
"basis.  The B<MS_RELATIME> flag is also settable on a per-mount-point basis."
msgstr ""
"Linux 2.4 以降では、 B<MS_NODEV>, B<MS_NOEXEC>, B<MS_NOSUID> はマウントポイン"
"ト単位で指定できる。 カーネル 2.6.16 以降では、 B<MS_NOATIME> と "
"B<MS_NODIRATIME> もマウントポイント単位で指定できる。 また、 B<MS_RELATIME> "
"フラグもマウントポイント単位で設定できる。"

#. type: Plain text
#: build/C/man2/mount.2:307
msgid ""
"The I<data> argument is interpreted by the different file systems.  "
"Typically it is a string of comma-separated options understood by this file "
"system.  See B<mount>(8)  for details of the options available for each "
"filesystem type."
msgstr ""
"引き数 I<data> がどのように解釈されるかは、ファイルシステムによって異なる。 "
"たいていは、指定されたファイルシステムで利用可能なオプションが コンマ区切りで"
"並べられた文字列である。 各ファイルシステムに対して指定可能なオプションの詳細"
"については B<mount>(8)  を参照のこと。"

#. type: Plain text
#: build/C/man2/mount.2:312 build/C/man2/stat.2:305 build/C/man2/statfs.2:134
#: build/C/man3/statvfs.3:101 build/C/man2/umount.2:104
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、0 が返される。 失敗した場合、 -1 が返され、 I<errno> に適切な値"
"がセットされる。"

#. type: Plain text
#: build/C/man2/mount.2:318
msgid ""
"The error values given below result from filesystem type independent "
"errors.  Each file-system type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""
"以下に示すエラーは、ファイルシステムに依存しないものである。 それぞれのファイ"
"ルシステムタイプには固有のエラーが存在する場合があり、 独自の動作をすることも"
"ある。詳しくは Linux カーネルのソースを見て欲しい。"

#. type: TP
#: build/C/man2/mount.2:318 build/C/man2/spu_create.2:173
#: build/C/man2/stat.2:306 build/C/man2/statfs.2:135
#: build/C/man3/statvfs.3:102
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: build/C/man2/mount.2:333
msgid ""
"A component of a path was not searchable.  (See also B<path_resolution>"
"(7).)  Or, mounting a read-only file system was attempted without giving the "
"B<MS_RDONLY> flag.  Or, the block device I<source> is located on a file "
"system mounted with the B<MS_NODEV> option."
msgstr ""
"パスに含まれるディレクトリに検索 (実行) 許可がない (B<path_resolution>(7)  も"
"参照)。 または、 B<MS_RONLY> フラグを指定せずに読み込み専用のファイルシステム"
"を マウントしようとした。 または、ブロックデバイス I<source> が B<MS_NODEV> "
"オプションでマウントされたファイルシステム上にある。"

#. type: TP
#: build/C/man2/mount.2:333 build/C/man2/umount.2:117
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/mount.2:345
msgid ""
"I<source> is already mounted.  Or, it cannot be remounted read-only, because "
"it still holds files open for writing.  Or, it cannot be mounted on "
"I<target> because I<target> is still busy (it is the working directory of "
"some thread, the mount point of another device, has open files, etc.)."
msgstr ""
"I<source> は既にマウントされている。 または、書き込み用にオープンされたファイ"
"ルがあり、 読み込み専用で再マウントすることができない。 または、 I<target> が"
"使用中 (busy) のため、 I<target> にマウントできない。 I<target> が使用中の例"
"としては、あるスレッドの動作ディレクトリ (working directory) であるとか、別の"
"デバイスのマウントポイントであるとか、 オープンされたファイルが存在する、など"
"がある。"

#. type: TP
#: build/C/man2/mount.2:345 build/C/man2/spu_create.2:181
#: build/C/man2/spu_run.2:158 build/C/man2/stat.2:317
#: build/C/man2/statfs.2:147 build/C/man3/statvfs.3:114
#: build/C/man2/sysfs.2:80 build/C/man2/umount.2:121 build/C/man2/ustat.2:80
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/mount.2:348
msgid "One of the pointer arguments points outside the user address space."
msgstr "場所を示す引き数のひとつがユーザーのアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/mount.2:363
msgid ""
"I<source> had an invalid superblock.  Or, a remount (B<MS_REMOUNT>)  was "
"attempted, but I<source> was not already mounted on I<target>.  Or, a move "
"(B<MS_MOVE>)  was attempted, but I<source> was not a mount point, or was "
"\\(aq/\\(aq."
msgstr ""
"I<source> に不正なスーパーブロックがある。 または、 I<source> が I<target> に"
"マウントされていないのに、再マウント (B<MS_REMOUNT>)  が要求された。 また"
"は、 I<source> がマウントポイントではないか、\\(aq/\\(aq なのに、移動 "
"(B<MS_MOVE>)  が要求された。"

#. type: TP
#: build/C/man2/mount.2:363 build/C/man2/spu_create.2:192
#: build/C/man2/stat.2:320 build/C/man2/statfs.2:159
#: build/C/man3/statvfs.3:126
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/mount.2:370
msgid ""
"Too many links encountered during pathname resolution.  Or, a move was "
"attempted, while I<target> is a descendant of I<source>."
msgstr ""
"パス名の解決中に登場したリンクが多すぎた。 または、 I<target> が I<source> の"
"子孫なのに移動が要求された。"

#. type: TP
#: build/C/man2/mount.2:370 build/C/man2/spu_create.2:196
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/mount.2:374
msgid "(In case no block device is required:)  Table of dummy devices is full."
msgstr ""
"(ブロックデバイスが必要でない場合)  ダミーデバイスのテーブルが一杯になった。"

#. type: TP
#: build/C/man2/mount.2:374 build/C/man2/spu_create.2:199
#: build/C/man2/stat.2:323 build/C/man2/statfs.2:164
#: build/C/man3/statvfs.3:131 build/C/man2/umount.2:137
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/mount.2:378 build/C/man2/umount.2:141
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr "パス名の長さが B<MAXPATHLEN> より長かった。"

#. type: TP
#: build/C/man2/mount.2:378 build/C/man2/spu_create.2:206
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/mount.2:382
msgid "I<filesystemtype> not configured in the kernel."
msgstr "I<filesystemtype> がカーネル中で定義 (config) されていない。"

#. type: TP
#: build/C/man2/mount.2:382 build/C/man2/spu_create.2:210
#: build/C/man2/stat.2:327 build/C/man2/statfs.2:169
#: build/C/man3/statvfs.3:136 build/C/man2/umount.2:141
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/mount.2:385 build/C/man2/umount.2:144
msgid "A pathname was empty or had a nonexistent component."
msgstr "パス名が空である。もしくは指定されたパスが存在しない。"

#. type: TP
#: build/C/man2/mount.2:385 build/C/man2/spu_create.2:215
#: build/C/man2/spu_run.2:179 build/C/man2/stat.2:334
#: build/C/man2/statfs.2:175 build/C/man3/statvfs.3:142
#: build/C/man2/umount.2:144
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/mount.2:388 build/C/man2/umount.2:147
msgid ""
"The kernel could not allocate a free page to copy filenames or data into."
msgstr ""
"カーネルがファイル名やデータをコピーするための空きページを確保できなかった。"

#. type: TP
#: build/C/man2/mount.2:388
#, no-wrap
msgid "B<ENOTBLK>"
msgstr "B<ENOTBLK>"

#. type: Plain text
#: build/C/man2/mount.2:392
msgid "I<source> is not a block device (and a device was required)."
msgstr "(ブロックデバイスが必要だが)  I<source> がブロックデバイスではない。"

#. type: TP
#: build/C/man2/mount.2:392 build/C/man2/spu_create.2:228
#: build/C/man2/stat.2:337 build/C/man2/statfs.2:181
#: build/C/man3/statvfs.3:148
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/mount.2:398
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr "I<target> か、 I<source> のプレフィックスがディレクトリではない。"

#. type: TP
#: build/C/man2/mount.2:398
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man2/mount.2:403
msgid "The major number of the block device I<source> is out of range."
msgstr "ブロックデバイス I<source> のメジャー番号が範囲外である。"

#. type: TP
#: build/C/man2/mount.2:403 build/C/man2/spu_create.2:233
#: build/C/man2/umount.2:147
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/mount.2:406 build/C/man2/umount.2:150
msgid "The caller does not have the required privileges."
msgstr "呼び出し元が必要な権限を持っていない。"

#.  FIXME: Definitions of the so-far-undocumented MS_UNBINDABLE, MS_PRIVATE,
#.   MS_SHARED, and MS_SLAVE were (also) only added to glibc headers in 2.12.
#. type: Plain text
#: build/C/man2/mount.2:417
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_REC>, B<MS_RELATIME>, and "
"B<MS_STRICTATIME> were added to glibc headers in version 2.12."
msgstr ""
"B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_REC>, B<MS_RELATIME>, B<MS_STRICTATIME> の定"
"義が glibc のヘッダに追加されたのは バージョン 2.12 においてである。"

#. type: Plain text
#: build/C/man2/mount.2:420
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"この関数は Linux 固有の関数であり、移植を考慮したプログラムでは 使用すべきで"
"ない。"

#. type: Plain text
#: build/C/man2/mount.2:429
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr ""
"元の B<MS_SYNC> フラグは、別の B<MS_SYNC> が I<E<lt>mman.hE<gt>> に追加された"
"ので 1.1.69 から B<MS_SYNCHRONOUS> に名前が変わった。"

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: build/C/man2/mount.2:438
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program "
"on a file system mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in "
"this case."
msgstr ""
"Linux 2.4 より前のバージョンでは、 B<MS_NOSUID> オプション付きでマウントされ"
"たファイルシステム上の set-UID や set-GID のプログラムを実行しようとすると、 "
"B<EPERM> エラーとなった。 Linux 2.4 以降では、このような場合は set-UID ビット"
"や set-GID ビットが 無視されるだけである。"

#. type: SS
#: build/C/man2/mount.2:438
#, no-wrap
msgid "Per-process namespaces"
msgstr "プロセス単位の名前空間"

#. type: Plain text
#: build/C/man2/mount.2:449
msgid ""
"Starting with kernel 2.4.19, Linux provides per-process mount namespaces.  A "
"mount namespace is the set of file system mounts that are visible to a "
"process.  Mount-point namespaces can be (and usually are)  shared between "
"multiple processes, and changes to the namespace (i.e., mounts and unmounts) "
"by one process are visible to all other processes sharing the same "
"namespace.  (The pre-2.4.19 Linux situation can be considered as one in "
"which a single namespace was shared by every process on the system.)"
msgstr ""
"カーネル 2.4.19 以降の Linux では、プロセス単位のマウント名前空間 (mount "
"namespace) が提供されている。マウント名前空間とは、 あるプロセスに見えている"
"ファイルシステムのマウントの集合である。 マウントポイントの名前空間は複数のプ"
"ロセスで共有することができ、 普通は共有されている。 一つのプロセスによる名前"
"空間の変更 (すなわち、マウントやアンマウント) は 同じ名前空間を共有する他の全"
"てのプロセスにも見える。 (2.4.19 より前の Linux は、一つの名前空間がシステム"
"上の全プロセスで 共有される状況とみなすことができる。)"

#. type: Plain text
#: build/C/man2/mount.2:455
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で作成された子プロセスは親プロセスのマウント名前空間を共有す"
"る。 B<execve>(2)  の前後でマウント名前空間は保持される。"

#. type: Plain text
#: build/C/man2/mount.2:475
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice versa."
msgstr ""
"プロセスは自分用 (private) のマウント名前空間を持つことができる。 自分用の名"
"前空間を持つことができるのは、 そのプロセスが B<clone>(2)  B<CLONE_NEWNS> フ"
"ラグを使って作成された場合と、 そのプロセスが B<CLONE_NEWNS> フラグ付きで "
"B<unshare>(2)  を呼び出した場合である。 前者の場合、作成されたプロセスの新し"
"い名前空間は B<clone>(2)  を呼び出したプロセスの名前空間の「コピー」で初期化"
"される。 後者の場合、 B<unshare>(2)  を呼び出すと、呼び出し元のプロセスのマウ"
"ント名前空間が、 それまでは他のプロセスと共有していた名前空間の自分用のコピー"
"となる。 これにより、呼び出し元のプロセスがこれ以後に行うマウント/アンマウン"
"トは 他のプロセスから見えなくなる (ただし、呼び出し元のプロセスが B<unshare>"
"(2)  の呼び出し以降に作成した子プロセスには見える)。 また、その逆の、他のプロ"
"セスが行ったマウント/アンマウントも呼び出し元のプロセスには 見えなくなる。"

#. type: Plain text
#: build/C/man2/mount.2:482
msgid ""
"The Linux-specific I</proc/PID/mounts> file exposes the list of mount points "
"in the mount namespace of the process with the specified ID; see B<proc>(5)  "
"for details."
msgstr ""
"Linux 独自のファイル I</proc/PID/mounts> では、指定された ID を持つプロセスの"
"マウント名前空間における マウントポイントのリストが公開されている。詳細は "
"B<proc>(5)  を参照のこと。"

#. type: Plain text
#: build/C/man2/mount.2:488
msgid ""
"B<umount>(2), B<namespaces>(7), B<path_resolution>(7), B<mount>(8), B<umount>"
"(8)"
msgstr ""
"B<umount>(2), B<namespaces>(7), B<path_resolution>(7), B<mount>(8), B<umount>"
"(8)"

#. type: TH
#: build/C/man7/path_resolution.7:25
#, no-wrap
msgid "PATH_RESOLUTION"
msgstr "PATH_RESOLUTION"

#. type: TH
#: build/C/man7/path_resolution.7:25
#, no-wrap
msgid "2009-12-05"
msgstr "2009-12-05"

#. type: Plain text
#: build/C/man7/path_resolution.7:28
msgid "path_resolution - how a pathname is resolved to a file"
msgstr "path_resolution - ファイルのパス名の解決方法"

#. type: Plain text
#: build/C/man7/path_resolution.7:31
msgid ""
"Some UNIX/Linux system calls have as parameter one or more filenames.  A "
"filename (or pathname) is resolved as follows."
msgstr ""
"いくつかの UNIX/Linux システムコールは、 1 つ以上のファイル名を引き数として持"
"つ。 ファイル名 (またはパス名) は以下のようにして解決される。"

#. type: SS
#: build/C/man7/path_resolution.7:31
#, no-wrap
msgid "Step 1: start of the resolution process"
msgstr "ステップ 1: 解決過程を開始する"

#. type: Plain text
#: build/C/man7/path_resolution.7:50
msgid ""
"If the pathname starts with the \\(aq/\\(aq character, the starting lookup "
"directory is the root directory of the calling process.  (A process inherits "
"its root directory from its parent.  Usually this will be the root directory "
"of the file hierarchy.  A process may get a different root directory by use "
"of the B<chroot>(2)  system call.  A process may get an entirely private "
"mount namespace in case it\\(emor one of its ancestors\\(emwas started by an "
"invocation of the B<clone>(2)  system call that had the B<CLONE_NEWNS> flag "
"set.)  This handles the \\(aq/\\(aq part of the pathname."
msgstr ""
"パス名が \\(aq/\\(aq 文字で始まっている場合、 ディレクトリ検索の開始点は呼び"
"出し元のプロセスのルートディレクトリになる。 (プロセスはルートディレクトリを"
"親プロセスから継承する。 通常は、これがファイル階層のルートディレクトリにな"
"る。 プロセスは B<chroot>(2)  システムコールを使って別のルートディレクトリを"
"取得することもできる。 この場合、そのプロセスと B<CLONE_NEWNS> フラグを設定し"
"て B<clone>(2)  を呼び出すことによって開始されたそのプロセスの子孫は、 完全に"
"プライベートなマウント名前空間を取得できる。)  パス名の \\(aq/\\(aq の部分"
"は、このようにして扱われる。"

#. type: Plain text
#: build/C/man7/path_resolution.7:58
msgid ""
"If the pathname does not start with the \\(aq/\\(aq character, the starting "
"lookup directory of the resolution process is the current working directory "
"of the process.  (This is also inherited from the parent.  It can be changed "
"by use of the B<chdir>(2)  system call.)"
msgstr ""
"パス名が \\(aq/\\(aq 文字で始まっていない場合、 解決過程におけるディレクトリ"
"検索の開始点は、 プロセスの現在の作業 (working) ディレクトリとなる。 (これも"
"親プロセスから継承される。 これは B<chdir>(2)  システムコールを使うことで変更"
"できる。)"

#. type: Plain text
#: build/C/man7/path_resolution.7:61
msgid ""
"Pathnames starting with a \\(aq/\\(aq character are called absolute "
"pathnames.  Pathnames not starting with a \\(aq/\\(aq are called relative "
"pathnames."
msgstr ""
"\\(aq/\\(aq 文字で始まるパス名は絶対パス名と呼ばれ、 \\(aq/\\(aq 文字で始まら"
"ないパス名は相対パス名と呼ばれる。"

#. type: SS
#: build/C/man7/path_resolution.7:61
#, no-wrap
msgid "Step 2: walk along the path"
msgstr "ステップ 2: パスを辿る"

#. type: Plain text
#: build/C/man7/path_resolution.7:66
msgid ""
"Set the current lookup directory to the starting lookup directory.  Now, for "
"each nonfinal component of the pathname, where a component is a substring "
"delimited by \\(aq/\\(aq characters, this component is looked up in the "
"current lookup directory."
msgstr ""
"現在の検索ディレクトリをディレクトリ検索の開始点とする。 そして、パス名の最後"
"の構成要素 (component) でない各構成要素について、 現在の検索ディレクトリで検"
"索を行う。 ここで構成要素は \\(aq/\\(aq で区切られた部分文字列である。"

#. type: Plain text
#: build/C/man7/path_resolution.7:72
msgid ""
"If the process does not have search permission on the current lookup "
"directory, an B<EACCES> error is returned (\"Permission denied\")."
msgstr ""
"プロセスが現在の検索ディレクトリの検索許可を持たない場合、 B<EACCES> エラーが"
"返される (\"Permission denied\")。"

#. type: Plain text
#: build/C/man7/path_resolution.7:77
msgid ""
"If the component is not found, an B<ENOENT> error is returned (\"No such "
"file or directory\")."
msgstr ""
"構成要素が見つからない場合、 B<ENOENT> エラーが返される (\"No such file or "
"directory\")。"

#. type: Plain text
#: build/C/man7/path_resolution.7:82
msgid ""
"If the component is found, but is neither a directory nor a symbolic link, "
"an B<ENOTDIR> error is returned (\"Not a directory\")."
msgstr ""
"構成要素は見つかったが、ディレクトリでもシンボリックリンクでもない場合、 "
"B<ENOTDIR> エラーが返される (\"Not a directory\")。"

#. type: Plain text
#: build/C/man7/path_resolution.7:86
msgid ""
"If the component is found and is a directory, we set the current lookup "
"directory to that directory, and go to the next component."
msgstr ""
"構成要素が見つかって、かつディレクトリである場合、 現在の検索ディレクトリをそ"
"のディレクトリに設定し、 次の構成要素に移動する。"

#.  presently: max recursion depth during symlink resolution: 5
#.  max total number of symbolic links followed: 40
#.  _POSIX_SYMLOOP_MAX is 8
#. type: Plain text
#: build/C/man7/path_resolution.7:110
msgid ""
"If the component is found and is a symbolic link (symlink), we first resolve "
"this symbolic link (with the current lookup directory as starting lookup "
"directory).  Upon error, that error is returned.  If the result is not a "
"directory, an B<ENOTDIR> error is returned.  If the resolution of the "
"symlink is successful and returns a directory, we set the current lookup "
"directory to that directory, and go to the next component.  Note that the "
"resolution process here involves recursion.  In order to protect the kernel "
"against stack overflow, and also to protect against denial of service, there "
"are limits on the maximum recursion depth, and on the maximum number of "
"symbolic links followed.  An B<ELOOP> error is returned when the maximum is "
"exceeded (\"Too many levels of symbolic links\")."
msgstr ""
"構成要素が見つかって、かつシンボリックリンク (symlink) である場合、 (現在の検"
"索ディレクトリをディレクトリ検索の開始点として)  最初にそのシンボリックリンク"
"を解決する。 結果がディレクトリでない場合、 B<ENOTDIR> エラーが返される。 シ"
"ンボリックリンクの解決が成功してディレクトリが返された場合、 そのディレクトリ"
"を現在の検索ディレクトリとして設定し、 次の構成要素に移動する。 解決過程に再"
"帰が含まれる点に注意すること。 カーネルをスタックオーバーフローや サービス拒"
"否 (denial of service) から守るため、 再帰の最大の深さとシンボリックリンクを"
"辿る最大回数に制限がある。 最大値を超えた場合 B<ELOOP> エラーが返される "
"(\"Too many levels of symbolic links\")。"

#. type: SS
#: build/C/man7/path_resolution.7:110
#, no-wrap
msgid "Step 3: find the final entry"
msgstr "ステップ 3: 最後のエントリを見つける"

#. type: Plain text
#: build/C/man7/path_resolution.7:122
msgid ""
"The lookup of the final component of the pathname goes just like that of all "
"other components, as described in the previous step, with two differences: "
"(i) the final component need not be a directory (at least as far as the path "
"resolution process is concerned\\(emit may have to be a directory, or a "
"nondirectory, because of the requirements of the specific system call), and "
"(ii) it is not necessarily an error if the component is not found\\(emmaybe "
"we are just creating it.  The details on the treatment of the final entry "
"are described in the manual pages of the specific system calls."
msgstr ""
"パス名の最後の構成要素の検索は、前のステップで説明した 他の全ての構成要素と同"
"じように実行されるが、2 つの違いがある。 (i) 最後の構成要素はディレクトリであ"
"る必要がない (パス解決過程に関する限りはどちらでも構わない \\(em 特定のシステ"
"ムコールが要求するものによって、 ディレクトリでなければならない場合もある"
"し、 ディレクトリ以外でなければならない場合もある)。 (ii) 構成要素が見つから"
"ない場合にエラーにする必要はない \\(em その構成要素を作成するだけでよい場合も"
"ある。 最後のエントリの詳細な扱いは、 特定のシステムコールの man ページで説明"
"されている。"

#. type: SS
#: build/C/man7/path_resolution.7:122
#, no-wrap
msgid ". and .."
msgstr ". と .."

#. type: Plain text
#: build/C/man7/path_resolution.7:126
msgid ""
"By convention, every directory has the entries \".\" and \"..\", which refer "
"to the directory itself and to its parent directory, respectively."
msgstr ""
"慣習として、全てのディレクトリはエントリ \".\" と \"..\" を持つ。 これらはそ"
"れぞれ、そのディレクトリ自身とその親ディレクトリを参照する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:130
msgid ""
"The path resolution process will assume that these entries have their "
"conventional meanings, regardless of whether they are actually present in "
"the physical file system."
msgstr ""
"パス解決過程では、これらのエントリが物理的なファイルシステムに 実際に存在する"
"か否かに関わらず、慣習的な意味を持つと仮定する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:132
msgid "One cannot walk down past the root: \"/..\" is the same as \"/\"."
msgstr "ルートより上に辿ることはできない: \"/..\" は \"/\" と同じである。"

#. type: SS
#: build/C/man7/path_resolution.7:132
#, no-wrap
msgid "Mount points"
msgstr "マウント位置"

#. type: Plain text
#: build/C/man7/path_resolution.7:136
msgid ""
"After a \"mount dev path\" command, the pathname \"path\" refers to the root "
"of the file system hierarchy on the device \"dev\", and no longer to "
"whatever it referred to earlier."
msgstr ""
"\"mount dev path\" コマンドを実行した後、 パス名 \"path\" はデバイス \"dev\" "
"上のファイルシステム階層の ルートディレクトリを参照するようになり、以前の位置"
"を参照しない。"

#. type: Plain text
#: build/C/man7/path_resolution.7:140
msgid ""
"One can walk out of a mounted file system: \"path/..\" refers to the parent "
"directory of \"path\", outside of the file system hierarchy on \"dev\"."
msgstr ""
"マウントされたファイルシステムの外に出ることができる: \"path/..\" は \"dev\" "
"上のファイルシステム階層の外である \"path\" の親ディレクトリを参照する。"

#. type: SS
#: build/C/man7/path_resolution.7:140
#, no-wrap
msgid "Trailing slashes"
msgstr "末尾のスラッシュ"

#. type: Plain text
#: build/C/man7/path_resolution.7:146
msgid ""
"If a pathname ends in a \\(aq/\\(aq, that forces resolution of the preceding "
"component as in Step 2: it has to exist and resolve to a directory.  "
"Otherwise a trailing \\(aq/\\(aq is ignored.  (Or, equivalently, a pathname "
"with a trailing \\(aq/\\(aq is equivalent to the pathname obtained by "
"appending \\(aq.\\(aq to it.)"
msgstr ""
"パス名が \\(aq/\\(aq で終わっている場合、 ステップ 2 において、その前にある構"
"成要素の解決法を次のように強制する: その構成要素が存在しなければならず、ディ"
"レクトリとして解決される。 存在しない場合は、末尾の \\(aq/\\(aq が無視され"
"る。 (また同様に、末尾に \\(aq/\\(aq があるパス名は、 \\(aq.\\(aq を末尾に加"
"えて得られるパス名と等しい。)"

#. type: SS
#: build/C/man7/path_resolution.7:146
#, no-wrap
msgid "Final symlink"
msgstr "最後がシンボリックリンクのとき"

#. type: Plain text
#: build/C/man7/path_resolution.7:155
msgid ""
"If the last component of a pathname is a symbolic link, then it depends on "
"the system call whether the file referred to will be the symbolic link or "
"the result of path resolution on its contents.  For example, the system call "
"B<lstat>(2)  will operate on the symlink, while B<stat>(2)  operates on the "
"file pointed to by the symlink."
msgstr ""
"パス名の最後の構成要素がシンボリックリンクである場合、 参照されるファイルをシ"
"ンボリックリンクとするか、 その内容についてパスを解決した結果とするかは、 シ"
"ステムコールに依存する。 たとえば、システムコール B<lstat>(2)  はシンボリック"
"リンクに作用する。 一方、 B<stat>(2)  はシンボリックリンクで指されたファイル"
"に作用する。"

#. type: SS
#: build/C/man7/path_resolution.7:155
#, no-wrap
msgid "Length limit"
msgstr "長さの制限"

#. type: Plain text
#: build/C/man7/path_resolution.7:162
msgid ""
"There is a maximum length for pathnames.  If the pathname (or some "
"intermediate pathname obtained while resolving symbolic links)  is too long, "
"an B<ENAMETOOLONG> error is returned (\"Filename too long\")."
msgstr ""
"パス名には最大長がある。 パス名 (またはシンボリックリンクを解決するときに得ら"
"れる中間パス名) が 長すぎる場合、 B<ENAMETOOLONG> エラーが返される "
"(\"Filename too long\")。"

#. type: SS
#: build/C/man7/path_resolution.7:162
#, no-wrap
msgid "Empty pathname"
msgstr "空のパス名"

#. type: Plain text
#: build/C/man7/path_resolution.7:169
msgid ""
"In the original UNIX, the empty pathname referred to the current directory.  "
"Nowadays POSIX decrees that an empty pathname must not be resolved "
"successfully.  Linux returns B<ENOENT> in this case."
msgstr ""
"元々の UNIX では、空のパス名は現在のディレクトリを参照していた。 最近、POSIX "
"では空のパス名を解決するべきではないという決定がなされた。 この場合、Linux "
"は B<ENOENT> を返す。"

#. type: SS
#: build/C/man7/path_resolution.7:169
#, no-wrap
msgid "Permissions"
msgstr "許可"

#. type: Plain text
#: build/C/man7/path_resolution.7:182
msgid ""
"The permission bits of a file consist of three groups of three bits, cf.\\& "
"B<chmod>(1)  and B<stat>(2).  The first group of three is used when the "
"effective user ID of the calling process equals the owner ID of the file.  "
"The second group of three is used when the group ID of the file either "
"equals the effective group ID of the calling process, or is one of the "
"supplementary group IDs of the calling process (as set by B<setgroups>(2)).  "
"When neither holds, the third group is used."
msgstr ""
"ファイルの許可ビットは、3 組の 3 ビットから構成される。 B<chmod>(1)  と "
"B<stat>(2)  を参照すること。 呼び出し元のプロセスの実効ユーザ ID がファイルの"
"所有者 ID と等しい場合、 3 つのうち最初のグループが使われる。 ファイルのグ"
"ループ ID が呼び出し元のプロセスの実効グループ ID または (B<setgroups>(2)  で"
"設定される) 呼び出し元のプロセスの補助 (supplementary) グループ ID と 等しい"
"場合、3 つのうち 2 番目のグループが使われる。 どちらにも当てはまらない場合、"
"3 番目のグループが使われる。"

#. type: Plain text
#: build/C/man7/path_resolution.7:186
msgid ""
"Of the three bits used, the first bit determines read permission, the second "
"write permission, and the last execute permission in case of ordinary files, "
"or search permission in case of directories."
msgstr ""
"3 ビットが使われる場合、最初のビットは読み込み許可を決定し、 2 番目のビットは"
"書き込み許可を決定する。 また 3 番目のビットは、通常のファイルの場合は実行許"
"可を表し、 ディレクトリの場合は検索許可を表す。"

#. type: Plain text
#: build/C/man7/path_resolution.7:191
msgid ""
"Linux uses the fsuid instead of the effective user ID in permission checks.  "
"Ordinarily the fsuid will equal the effective user ID, but the fsuid can be "
"changed by the system call B<setfsuid>(2)."
msgstr ""
"Linux は、許可のチェックにおいて、実効ユーザ ID ではなく fsuid を使う。 通常"
"は fsuid は実効ユーザ ID と等しいが、fsuid はシステムコール B<setfsuid>(2)  "
"で変更することができる。"

#. type: Plain text
#: build/C/man7/path_resolution.7:199
msgid ""
"(Here \"fsuid\" stands for something like \"file system user ID\".  The "
"concept was required for the implementation of a user space NFS server at a "
"time when processes could send a signal to a process with the same effective "
"user ID.  It is obsolete now.  Nobody should use B<setfsuid>(2).)"
msgstr ""
"(ここで \"fsuid\" は \"file system user ID\" を表している。 この概念は「プロ"
"セスが同じ実効ユーザ ID を持つプロセスに 同時にシグナルを送ることができる」と"
"いうユーザ空間 NFS サーバを 実装する際に必要であった。 これは今では廃れてし"
"まった。 B<setfsuid>(2)  を使うべきではない。"

#.  FIXME say something about file system mounted read-only ?
#. type: Plain text
#: build/C/man7/path_resolution.7:205
msgid ""
"Similarly, Linux uses the fsgid (\"file system group ID\")  instead of the "
"effective group ID.  See B<setfsgid>(2)."
msgstr ""
"同様に、Linux では実効グループ ID の代わりに fsgid (\"ファイルシステム・グ"
"ループID\") を使う。 B<setfsgid>(2)  を参照すること。"

#. type: SS
#: build/C/man7/path_resolution.7:205
#, no-wrap
msgid "Bypassing permission checks: superuser and capabilities"
msgstr "許可の確認をスキップする: スーパーユーザとケーパビリティ"

#.  (but for exec at least one x bit must be set) -- AEB
#.  but there is variation across systems on this point: for
#.  example, HP-UX and Tru64 are as described by AEB.  However,
#.  on some implementations (e.g., Solaris, FreeBSD),
#.  access(X_OK) by superuser will report success, regardless
#.  of the file's execute permission bits. -- MTK (Oct 05)
#. type: Plain text
#: build/C/man7/path_resolution.7:216
msgid ""
"On a traditional UNIX system, the superuser (I<root>, user ID 0) is all-"
"powerful, and bypasses all permissions restrictions when accessing files."
msgstr ""
"伝統的な UNIX システムでは、スーパーユーザ (I<root>, ユーザ ID 0) は非常に強"
"力であり、ファイルアクセス時の 許可による制限を全てスキップする。"

#. type: Plain text
#: build/C/man7/path_resolution.7:224
msgid ""
"On Linux, superuser privileges are divided into capabilities (see "
"B<capabilities>(7)).  Two capabilities are relevant for file permissions "
"checks: B<CAP_DAC_OVERRIDE> and B<CAP_DAC_READ_SEARCH>.  (A process has "
"these capabilities if its fsuid is 0.)"
msgstr ""
"Linux では、スーパーユーザ権限が複数のケーパビリティに分割されている "
"(B<capabilities>(7)  参照)。ファイルの許可の確認には、 B<CAP_DAC_OVERRIDE> "
"と B<CAP_DAC_READ_SEARCH> の 2つのケーパビリティが関係する (プロセスの fsuid "
"が 0 の場合、そのプロセスはこれらのケーパビリティを持つ)。"

#. type: Plain text
#: build/C/man7/path_resolution.7:230
msgid ""
"The B<CAP_DAC_OVERRIDE> capability overrides all permission checking, but "
"grants execute permission only when at least one of the file's three execute "
"permission bits is set."
msgstr ""
"B<CAP_DAC_OVERRIDE> ケーパビリティは全ての許可チェックを上書きする。 実際に"
"は、対象となるファイルの 3 つの実行許可ビットのうちの 少なくとも 1 つが設定さ"
"れている場合のみ、実行を許可する。"

#.  FIXME say something about immutable files
#.  FIXME say something about ACLs
#. type: Plain text
#: build/C/man7/path_resolution.7:237
msgid ""
"The B<CAP_DAC_READ_SEARCH> capability grants read and search permission on "
"directories, and read permission on ordinary files."
msgstr ""
"B<CAP_DAC_READ_SEARCH> ケーパビリティは、ディレクトリに対して読み込みと検索を"
"許可し、 通常のファイルに対して読み込みを許可する。"

#. type: Plain text
#: build/C/man7/path_resolution.7:242
msgid "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"
msgstr "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr "REMOVEXATTR"

#. type: Plain text
#: build/C/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr "removexattr, lremovexattr, fremovexattr - 拡張属性を削除する"

#. type: Plain text
#: build/C/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man2/removexattr.2:49
msgid ""
"Extended attributes are I<name>:value pairs associated with inodes (files, "
"directories, symbolic links, etc.).  They are extensions to the normal "
"attributes which are associated with all inodes in the system (i.e., the "
"B<stat>(2)  data).  A complete overview of extended attributes concepts can "
"be found in B<attr>(5)."
msgstr ""
"拡張属性は、inode (ファイル、ディレクトリ、シンボリックリンク等) に 関連付け"
"られた I<name>:I<value> の対である。 これらは、システム上のすべての inode に"
"関連付けられた通常の属性 (B<stat>(2)  が返すデータ) を拡張するものである。 拡"
"張属性のコンセプトは B<attr>(5)  に書かれている。"

#. type: Plain text
#: build/C/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the file system."
msgstr ""
"B<removexattr>()  は、ファイルシステム内の指定された I<path> に対応する、名"
"前 I<name> の拡張属性を削除する。"

#. type: Plain text
#: build/C/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a "
"symbolic link, where the extended attribute is removed from the link itself, "
"not the file that it refers to."
msgstr ""
"B<lremovexattr>()  は B<removexattr>()  と同じだが、シンボリックリンクの場合"
"に、リンクが参照しているファイル ではなく、リンクそのものの情報を削除する点だ"
"けが異なる。"

#. type: Plain text
#: build/C/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by "
"B<open>(2))  in place of I<path>."
msgstr ""
"B<fremovexattr>()  は B<removexattr>()  と同じだが、 I<path> の代わりに "
"I<fd> で参照されたオープン済みファイルから拡張属性を削除するだけである点が異"
"なる (I<fd> は B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/removexattr.2:78
msgid ""
"An extended attribute name is a simple null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""
"拡張属性の名前は、普通の NULL 終端された文字列である。 I<name> には、名前空間"
"を表す接頭辞 (prefix) が含まれる。 個々の inode に対し、互いに独立な名前空間"
"が複数あってもよい。"

#. type: Plain text
#: build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:110
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""
"成功した場合、0 が返される。 失敗した場合、 -1 が返され、 I<errno> に適切な値"
"がセットされる。"

#. type: Plain text
#: build/C/man2/removexattr.2:92
msgid ""
"The named attribute does not exist.  (B<ENOATTR> is defined to be a synonym "
"for B<ENODATA> in I<E<lt>attr/xattr.hE<gt>>.)"
msgstr ""
"指定された属性が存在しない。(B<ENOATTR> は I<E<lt>attr/xattr.hE<gt>> で "
"B<ENODATA> の同義語として定義されている。)"

#. type: Plain text
#: build/C/man2/removexattr.2:120
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr "SETXATTR"

#. type: Plain text
#: build/C/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr "setxattr, lsetxattr, fsetxattr - 拡張属性の値を設定する"

#. type: Plain text
#: build/C/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/setxattr.2:67
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the file system.  The "
"I<size> of the I<value> must be specified."
msgstr ""
"B<setxattr>()  は、ファイルシステム内の指定された I<path> に対応する、名前 "
"I<name> の拡張属性の値 I<value> を設定する。 I<value> の I<size> は必ず指定し"
"なければならない。"

#. type: Plain text
#: build/C/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr ""
"B<lsetxattr>()  は B<setxattr>()  と同じだが、シンボリックリンクの場合に、リ"
"ンクが参照しているファイル ではなく、リンクそのものの拡張属性を設定する点だけ"
"が異なる。"

#. type: Plain text
#: build/C/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in "
"place of I<path>."
msgstr ""
"B<fsetxattr>()  は B<setxattr>()  と同じだが、 I<path> の代わりに I<fd> で参"
"照されたオープン済みファイルの情報だけを設定する点が異なる (I<filedes> は "
"B<open>(2)  によって返される)。"

#. type: Plain text
#: build/C/man2/setxattr.2:93
msgid ""
"An extended attribute name is a simple null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr ""
"拡張属性の名前 は普通の NULL 終端された文字列である。 I<name> には、名前空間"
"を表す接頭辞 (prefix) が含まれる。 個々の inode に対して、互いに独立な名前空"
"間が複数あってもよい。 拡張属性の値 I<value> は、ある一定の長さの任意のテキス"
"ト・データまたは バイナリ・データの集合である。"

#. type: Plain text
#: build/C/man2/setxattr.2:105
msgid ""
"The I<flags> argument can be used to refine the semantics of the operation.  "
"B<XATTR_CREATE> specifies a pure create, which fails if the named attribute "
"exists already.  B<XATTR_REPLACE> specifies a pure replace operation, which "
"fails if the named attribute does not already exist.  By default (no flags), "
"the extended attribute will be created if need be, or will simply replace "
"the value if the attribute exists."
msgstr ""
"操作の意味を明確にするために I<flags> 引き数を使用することができる。 "
"B<XATTR_CREATE> は属性の作成だけを行うことを指定する。 指定された名前の属性が"
"すでに存在する場合は失敗する。 B<XATTR_REPLACE> は属性の置換だけを行うことを"
"指定する。 指定された名前の属性がまだ存在しない場合は失敗する。 デフォルトで"
"は (フラグを指定しない場合)、拡張属性は必要な場合は作成され、 属性がすでに存"
"在する場合は属性値の置換を行う。"

#. type: TP
#: build/C/man2/setxattr.2:111
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man2/setxattr.2:115
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr ""
"ディスクのクォータ上限に達した。拡張属性を格納できるだけの空き領域がないこと"
"を意味する。"

#. type: TP
#: build/C/man2/setxattr.2:115 build/C/man2/spu_create.2:178
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/setxattr.2:119
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr "B<XATTR_CREATE> が指定されたが、その属性はすでに存在している。"

#. type: Plain text
#: build/C/man2/setxattr.2:128
msgid ""
"B<XATTR_REPLACE> was specified, and the attribute does not exist.  "
"(B<ENOATTR> is defined to be a synonym for B<ENODATA> in I<E<lt>attr/xattr."
"hE<gt>>.)"
msgstr ""
"B<XATTR_REPLACE> が指定されたが、その属性が存在しない。(B<ENOATTR> は "
"I<E<lt>attr/xattr.hE<gt>> で B<ENODATA> の同義語として定義されている。)"

#. type: TP
#: build/C/man2/setxattr.2:128 build/C/man2/spu_create.2:218
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/setxattr.2:131
msgid "There is insufficient space remaining to store the extended attribute."
msgstr "拡張属性を記憶するのに十分なスペースが残っていない。"

#. type: Plain text
#: build/C/man2/setxattr.2:137
msgid ""
"Extended attributes are not supported by the file system, or are disabled, "
"I<errno> is set to B<ENOTSUP>."
msgstr ""
"拡張属性がそのファイルシステムでサポートされていない、もしくは無効になってい"
"る。\n"
"I<errno> に B<ENOTSUP> がセットされる。"

#. type: Plain text
#: build/C/man2/setxattr.2:162
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"

#. type: TH
#: build/C/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr "SPU_CREATE"

#. type: Plain text
#: build/C/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr "spu_create - 新しい SPU コンテキストを生成する"

#. type: Plain text
#: build/C/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/spu_create.2:36
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t >I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"

#. type: Plain text
#: build/C/man2/spu_create.2:40 build/C/man2/spu_run.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/spu_create.2:59
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU file "
"system (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr ""
"B<spu_create>() システムコールは、Cell Broadband Engine アーキテクチャ\n"
"を実装した PowerPC マシンにおいて、Synergistic Processor Unit (SPU) に\n"
"アクセスする ために使用される。 このシステムコールは、SPU に対する新し\n"
"い論理コンテキストを I<pathname> に生成し、そのコンテキストに関連付けら\n"
"れたファイルディスクリプタを返す。 I<pathname> は SPU ファイルシステム\n"
"(B<spufs>) のマウントポイント内の 存在しないディレクトリを指していなけ\n"
"ればならない。 B<spu_create>() が成功すると、 I<pathname> にディレクト\n"
"リが生成され、そのディレクトリに B<spufs>(7) で説明されているファイル群\n"
"が配置される。"

#. type: Plain text
#: build/C/man2/spu_create.2:78
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:83
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr ""
"I<flags> 引き数には 0 か以下の定数の組み合わせ (ビット単位の論理和)\n"
"を指定できる。"

#. type: TP
#: build/C/man2/spu_create.2:83
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr "B<SPU_CREATE_EVENTS_ENABLED>"

#. type: Plain text
#: build/C/man2/spu_create.2:89
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:89
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr "B<SPU_CREATE_GANG>"

#. type: Plain text
#: build/C/man2/spu_create.2:97
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts "
"that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as "
"a single unit.)"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:104
msgid ""
"A new directory will be created at the location specified by the I<pathname> "
"argument.  This gang may be used to hold other SPU contexts, by providing a "
"pathname that is within the gang directory to further calls to B<spu_create>"
"()."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:104
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr "B<SPU_CREATE_NOSCHED>"

#. type: Plain text
#: build/C/man2/spu_create.2:110
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:121
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:127
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:127
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr "B<SPU_CREATE_ISOLATE>"

#. type: Plain text
#: build/C/man2/spu_create.2:134
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:140
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:140
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU>"
msgstr "B<SPU_CREATE_AFFINITY_SPU>"

#. type: Plain text
#: build/C/man2/spu_create.2:148
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed "
"in the I<neighbor_fd> argument."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:148
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM>"
msgstr "B<SPU_CREATE_AFFINITY_MEM>"

#. type: Plain text
#: build/C/man2/spu_create.2:153
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:165
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:172
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is "
"returned, and I<errno> is set to one of the error codes listed below."
msgstr ""
"成功すると、 B<spu_create>() は新しいファイルディスクリプタを返す。\n"
"エラーの場合、-1 を返し、 I<errno> に以下のリストに記載のエラーコードの\n"
"いずれかを設定する。"

#. type: Plain text
#: build/C/man2/spu_create.2:178
msgid ""
"The current user does not have write access to the B<spufs>(7)  mount point."
msgstr ""
"現在のユーザが B<spufs>(7) のマウントポイントへの書き込み許可を持って\n"
"いない。"

#. type: Plain text
#: build/C/man2/spu_create.2:181
msgid "An SPU context already exists at the given path name."
msgstr "指定されたパス名で SPU コンテキストがすでに生成されている。"

#. type: Plain text
#: build/C/man2/spu_create.2:186
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr ""
"I<pathname> が呼び出し元のプロセスのアドレス空間で有効な文字列ポインタ\n"
"ではない。"

#. type: Plain text
#: build/C/man2/spu_create.2:192
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr ""
"I<pathname> が SPUFS マウントポインタ内のディレクトリではない。\n"
"または、無効なフラグが指定された。"

#. type: Plain text
#: build/C/man2/spu_create.2:196
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr "I<pathname> を解決するまでに辿ったシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/spu_create.2:199
msgid "The process has reached its maximum open files limit."
msgstr "そのプロセスがオープンできるファイル数の上限に達していた。"

#. type: Plain text
#: build/C/man2/spu_create.2:203
msgid "I<pathname> is too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/spu_create.2:203
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/spu_create.2:206
msgid "The system has reached the global open files limit."
msgstr "システム全体でオープンできるファイル数の上限に達していた。"

#. type: Plain text
#: build/C/man2/spu_create.2:210
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:215
msgid "Part of I<pathname> could not be resolved."
msgstr "I<pathname> の一部が解決できなかった。"

#. type: Plain text
#: build/C/man2/spu_create.2:218
msgid "The kernel could not allocate all resources required."
msgstr "カーネルが必要なリソースの全てを割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/spu_create.2:223
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr ""
"新しいコンテキストを生成するのに十分な SPU リソースがなかった、\n"
"または SPU コンテキスト数がそのユーザの特定の上限に達していた。"

#. type: TP
#: build/C/man2/spu_create.2:223 build/C/man2/spu_run.2:183
#: build/C/man2/statfs.2:178 build/C/man3/statvfs.3:145
#: build/C/man2/ustat.2:88
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/spu_create.2:228 build/C/man2/spu_run.2:188
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""
"機能が動作中のシステムで提供されていない。理由は、 ハードウェアで SPU が提供"
"されていないか、 spufs モジュールがロードされていないか、のどちらかである。"

#. type: Plain text
#: build/C/man2/spu_create.2:233
msgid "A part of I<pathname> is not a directory."
msgstr "I<pathname> の一部がディレクトリではない。"

#. type: Plain text
#: build/C/man2/spu_create.2:240
msgid ""
"The I<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:246
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr ""
"I<pathname> は B<spufs> のマウントポイントの配下の場所を指して\n"
"いなければならない。 慣例では I</spu> にマウントされる。"

#. type: Plain text
#: build/C/man2/spu_create.2:250
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr ""
"B<spu_create>() システムコールはカーネル 2.6.16 で Linux に追加された。"

#. type: Plain text
#: build/C/man2/spu_create.2:254
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""
"このシステムコールは Linux 固有であり、 PowerPC アーキテクチャでのみ\n"
"実装されている。 このシステムコールを使ったプログラムは移植性がない。"

#. type: Plain text
#: build/C/man2/spu_create.2:265
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR http://www.bsc.es\\:/projects\\:/"
"deepcomputing\\:/linuxoncell/> E<.UE> for the recommended libraries."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使うこと。ただし、 B<spu_create>()  は より抽象度の高い SPU へのインタ"
"フェースを実装するライブラリから 利用されることを意図したものであり、通常のア"
"プリケーションから 使用は意図されていない。推奨のライブラリについては E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> を参照"
"のこと。"

#. type: Plain text
#: build/C/man2/spu_create.2:270
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:275
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: build/C/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr "SPU_RUN"

#. type: Plain text
#: build/C/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr "spu_run - SPU コンテキストを実行する"

#. type: Plain text
#: build/C/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr "B<#include E<lt>sys/spu.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/spu_run.2:35
#, no-wrap
msgid "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"
msgstr "B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int *>I<event>B<);>\n"

#. type: Plain text
#: build/C/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the "
"Cell Broadband Engine Architecture in order to access Synergistic Processor "
"Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr ""
"B<spu_run>()  システムコールは、Cell Broadband Engine アーキテクチャを実装し"
"た PowerPC マシンで Synergistic Processor Units (SPU) にアクセスするために 使"
"用される。 I<fd> 引き数は、 B<spu_create>(2)  が返すファイルディスクリプタ"
"で、 特定の SPU コンテキストを参照する。 そのコンテキストが物理 SPU に割り当"
"てられると、 I<npc> で渡された命令ポインタ (instruction pointer) から実行が開"
"始される。"

#. type: Plain text
#: build/C/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new "
"thread of execution must be created first (e.g., using B<pthread_create>(3))."
msgstr ""
"SPU コードの実行は同期的 (synchronously) に行われる、つまり SPU が実行中は "
"B<spu_run>()  は停止 (block) する。 SPU コードの実行をメイン CPU や他の SPU "
"と並行して行う必要がある場合は、 最初に、その SPU コードを実行する新しいス"
"レッドを、(例えば B<pthread_create>(3)  などを使って) 生成しなければならな"
"い。"

#. type: Plain text
#: build/C/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr ""
"B<spu_run>()  が返るときには、SPU のプログラムカウンタの現在値が I<npc> に書"
"き込まれる。 これにより、連続する B<spu_run>()  の呼び出しで同じ I<npc> ポイ"
"ンタを使うことができる。"

#. type: Plain text
#: build/C/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the "
"SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr ""
"I<event> 引き数には、拡張ステータスコード用のバッファを指定する。 "
"B<SPU_CREATE_EVENTS_ENABLED> フラグ付きで SPU コンテキストが作成されると、 "
"B<spu_run>()  が返る前に Linux カーネルによりこのバッファに 拡張ステータス"
"コードが格納される。"

#. type: Plain text
#: build/C/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr "ステータスコードには以下の定数が一つ以上入る。"

#. type: TP
#: build/C/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr "B<SPE_EVENT_DMA_ALIGNMENT>"

#. type: Plain text
#: build/C/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr "DMA (direct memory access) のアライメント・エラーが発生した。"

#. type: TP
#: build/C/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr "B<SPE_EVENT_INVALID_DMA>"

#. type: Plain text
#: build/C/man2/spu_run.2:90
msgid "An invalid MFC DMA command was attempted."
msgstr "無効な MFC (Memory Flow Controller) DMA コマンドを行おうとした。"

#. type: TP
#: build/C/man2/spu_run.2:90
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr "B<SPE_EVENT_SPE_DATA_STORAGE>"

#. type: Plain text
#: build/C/man2/spu_run.2:93
msgid "A DMA storage error occurred."
msgstr "DMA ストレージ・エラーが発生した。"

#. type: TP
#: build/C/man2/spu_run.2:93
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr "B<SPE_EVENT_SPE_ERROR>"

#. type: Plain text
#: build/C/man2/spu_run.2:96
msgid "An illegal instruction was executed."
msgstr "不正な命令が実行された。"

#. type: Plain text
#: build/C/man2/spu_run.2:102
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr ""
"NULL は I<event> 引き数として有効な値である。 この場合、イベントは呼び出し元"
"のプロセスに報告されない。"

#. type: Plain text
#: build/C/man2/spu_run.2:111
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr ""
"成功すると、 B<spu_run>()  は I<spu_status> レジスタの値を返す。 エラーの場"
"合、-1 を返し、 I<errno> を下記のエラーコードのいずれかに設定する。"

#. type: Plain text
#: build/C/man2/spu_run.2:120
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on "
"the SPU.  The bit masks for the status codes are:"
msgstr ""
"I<spu_status> レジスタの値は、ステータスコードと SPU の B<stop-and-signal> 命"
"令が返す 14 ビットのコードの ビットマスクで構成される。 後者の 14 ビットの"
"コードはオプションである。 ステータスコードのビットマスクは下記の通りである。"

#. type: TP
#: build/C/man2/spu_run.2:120
#, no-wrap
msgid "B<0x02>"
msgstr "B<0x02>"

#. type: Plain text
#: build/C/man2/spu_run.2:125
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr "SPU が B<stop-and-signal> 命令で停止した。"

#. type: TP
#: build/C/man2/spu_run.2:125
#, no-wrap
msgid "B<0x04>"
msgstr "B<0x04>"

#. type: Plain text
#: build/C/man2/spu_run.2:130
msgid "SPU was stopped by a B<halt> instruction."
msgstr "SPU が B<halt (停止)> 命令で止まった。"

#. type: TP
#: build/C/man2/spu_run.2:130
#, no-wrap
msgid "B<0x08>"
msgstr "B<0x08>"

#. type: Plain text
#: build/C/man2/spu_run.2:133
msgid "SPU is waiting for a channel."
msgstr "SPU はチャンネルのウェイト中である。"

#. type: TP
#: build/C/man2/spu_run.2:133
#, no-wrap
msgid "B<0x10>"
msgstr "B<0x10>"

#. type: Plain text
#: build/C/man2/spu_run.2:136
msgid "SPU is in single-step mode."
msgstr "SPU はシングルステップモードであった。"

#. type: TP
#: build/C/man2/spu_run.2:136
#, no-wrap
msgid "B<0x20>"
msgstr "B<0x20>"

#. type: Plain text
#: build/C/man2/spu_run.2:139
msgid "SPU has tried to execute an invalid instruction."
msgstr "SPU が不正な命令を実行しようとした。"

#. type: TP
#: build/C/man2/spu_run.2:139
#, no-wrap
msgid "B<0x40>"
msgstr "B<0x40>"

#. type: Plain text
#: build/C/man2/spu_run.2:142
msgid "SPU has tried to access an invalid channel."
msgstr "SPU が不正なチャンネルにアクセスしようとした。"

#. type: TP
#: build/C/man2/spu_run.2:142
#, no-wrap
msgid "B<0x3fff0000>"
msgstr "B<0x3fff0000>"

#. type: Plain text
#: build/C/man2/spu_run.2:148
msgid ""
"The bits masked with this value contain the code returned from a B<stop-and-"
"signal> instruction.  These bits are valid only if the 0x02 bit is set."
msgstr ""
"この値のマスクを適用して得られたビット値には、 stop-and-signal 命令から返され"
"たコードが入っている。 これらのビットは 0x02 ビットがセットされている場合にの"
"み有効である。"

#. type: Plain text
#: build/C/man2/spu_run.2:153
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower "
"eight ones are always set."
msgstr ""
"B<spu_run>()  がエラーを返さなかった場合、下位 8 ビットのうち 1 つ以上は 常に"
"セットされる。"

#. type: TP
#: build/C/man2/spu_run.2:154 build/C/man2/stat.2:313
#: build/C/man2/statfs.2:142 build/C/man3/statvfs.3:109
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/spu_run.2:158
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/spu_run.2:164
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr ""
"I<npc> が有効なポインタでない。または I<event> が NULL 以外で、しかも無効なポ"
"インタである。"

#. type: TP
#: build/C/man2/spu_run.2:164 build/C/man2/statfs.2:153
#: build/C/man3/statvfs.3:120
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/spu_run.2:174
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr ""
"B<spu_run>()  の実行中にシグナルが発生した。 B<signal>(7)  参照。 必要であれ"
"ば、 I<npc> の値は新しいプログラムカウンタの値に更新される。"

#. type: Plain text
#: build/C/man2/spu_run.2:179
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr ""
"I<fd> が B<spu_create>(2)  が返した有効なファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/spu_run.2:183
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr ""
"Memory Flow Controller (MFC) DMA により発生したページフォールトを 処理するの"
"に必要なメモリがなかった。"

#. type: Plain text
#: build/C/man2/spu_run.2:192
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr "B<spu_run>()  システムコールはカーネル 2.6.16 で Linux に追加された。"

#. type: Plain text
#: build/C/man2/spu_run.2:196
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""
"このシステムコールは Linux 固有であり、 PowerPC アーキテクチャでのみ実装され"
"ている。 このシステムコールを使ったプログラムは移植性がない。"

#. type: Plain text
#: build/C/man2/spu_run.2:207
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR http://www.bsc.es\\:/projects\\:/"
"deepcomputing\\:/linuxoncell/> E<.UE> for the recommended libraries."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使うこと。ただし、 B<spu_run>()  は より抽象度の高い SPU へのインタ"
"フェースを実装するライブラリから 利用されることを意図したものであり、通常のア"
"プリケーションから 使用は意図されていない。推奨のライブラリについては E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> を参照"
"のこと。"

#. type: Plain text
#: build/C/man2/spu_run.2:212
msgid ""
"The following is an example of running a simple, one-instruction SPU program "
"with the B<spu_run>()  system call."
msgstr ""
"以下は、簡単な 1 命令の SPU プログラムを B<spu_run>()  システムコールを使って"
"実行させる例である。"

#. type: Plain text
#: build/C/man2/spu_run.2:220
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"

#. type: Plain text
#: build/C/man2/spu_run.2:223
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/spu_run.2:228
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"

#. type: Plain text
#: build/C/man2/spu_run.2:232
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"

#. type: Plain text
#: build/C/man2/spu_run.2:237
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"

#. type: Plain text
#: build/C/man2/spu_run.2:242
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"

#. type: Plain text
#: build/C/man2/spu_run.2:248
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"

#. type: Plain text
#: build/C/man2/spu_run.2:252
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#: build/C/man2/spu_run.2:258
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: 0x%08x\\en\", spu_status);\n"
msgstr ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: 0x%08x\\en\", spu_status);\n"

#. type: Plain text
#: build/C/man2/spu_run.2:261 build/C/man2/stat.2:654
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/spu_run.2:269
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"

#. type: TH
#: build/C/man7/spufs.7:27
#, no-wrap
msgid "SPUFS"
msgstr "SPUFS"

#. type: TH
#: build/C/man7/spufs.7:27
#, no-wrap
msgid "2007-12-20"
msgstr "2007-12-20"

#. type: Plain text
#: build/C/man7/spufs.7:30
msgid "spufs - SPU file system"
msgstr "spufs - SPU ファイルシステム"

#. type: Plain text
#: build/C/man7/spufs.7:34
msgid ""
"The SPU file system is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic Processor Units "
"(SPUs)."
msgstr ""
"SPU ファイルシステムは、Cell Broadband Engine アーキテクチャを実装した "
"PowerPC マシンにおいて、Synergistic Processor Unit (SPU) にアクセスする ため"
"に使用される。"

#. type: Plain text
#: build/C/man7/spufs.7:43
msgid ""
"The file system provides a name space similar to POSIX shared memory or "
"message queues.  Users that have write permissions on the file system can "
"use B<spu_create>(2)  to establish SPU contexts under the B<spufs> root "
"directory."
msgstr ""
"このファイルシステムでは、POSIX 共有メモリやメッセージキューに似た名前\n"
"空間が提供される。 ファイルシステムに書き込み許可を持つユーザは\n"
"B<spu_create>(2) を使って B<spufs> のルートディレクトリに SPU コンテキ\n"
"ストを作成できる。"

#. type: Plain text
#: build/C/man7/spufs.7:50
msgid ""
"Every SPU context is represented by a directory containing a predefined set "
"of files.  These files can be used for manipulating the state of the logical "
"SPU.  Users can change permissions on the files, but can't add or remove "
"files."
msgstr ""
"各 SPU コンテキストは、あらかじめ定義されたファイル群を含むディレクトリ\n"
"として表現される。 これらのファイルを使って、論理 SPU の状態を操作でき\n"
"る。ユーザはこれらのファイルのアクセス許可を変更することはできるが、\n"
"ファイルの追加・削除を行うことはできない。"

#. type: SS
#: build/C/man7/spufs.7:50
#, no-wrap
msgid "Mount options"
msgstr "マウントオプション"

#. type: TP
#: build/C/man7/spufs.7:51
#, no-wrap
msgid "B<uid=E<lt>uidE<gt>>"
msgstr "B<uid=E<lt>uidE<gt>>"

#. type: Plain text
#: build/C/man7/spufs.7:54
msgid "Set the user owning the mount point; the default is 0 (root)."
msgstr ""
"マウントポイントを所有するユーザを設定する。 デフォルトは 0 (root) である。"

#. type: TP
#: build/C/man7/spufs.7:54
#, no-wrap
msgid "B<gid=E<lt>gidE<gt>>"
msgstr "B<gid=E<lt>gidE<gt>>"

#. type: Plain text
#: build/C/man7/spufs.7:57
msgid "Set the group owning the mount point; the default is 0 (root)."
msgstr ""
"マウントポイントを所有するグループを設定する。 デフォルトは 0 (root) である。"

#. type: TP
#: build/C/man7/spufs.7:57
#, no-wrap
msgid "B<mode=E<lt>modeE<gt>>"
msgstr "B<mode=E<lt>modeE<gt>>"

#. type: Plain text
#: build/C/man7/spufs.7:63
msgid ""
"Set the mode of the top-level directory in B<spufs>, as an octal mode "
"string.  The default is 0775."
msgstr ""

#. type: SS
#: build/C/man7/spufs.7:63
#, no-wrap
msgid "Files"
msgstr "Files"

#. type: Plain text
#: build/C/man7/spufs.7:75
msgid ""
"The files in B<spufs> mostly follow the standard behavior for regular system "
"calls like B<read>(2)  or B<write>(2), but often support only a subset of "
"the operations supported on regular file systems.  This list details the "
"supported operations and the deviations from the standard behavior described "
"in the respective man pages."
msgstr ""
"B<spufs> のファイルは、ほとんどの場合 B<read>(2) や B<write>(2) と\n"
"いった通常のシステムコールに対する標準的な振る舞いを示すが、多くの場合\n"
"通常のファイルシステムでサポートされている操作の一部分だけがサポート\n"
"されている。以下のリストでは、サポートされている操作とそれぞれのマニュ\n"
"アルページに書かれている標準的な振る舞いとの違いについて説明する。"

#. type: Plain text
#: build/C/man7/spufs.7:97
msgid ""
"All files that support the B<read>(2)  operation also support B<readv>(2)  "
"and all files that support the B<write>(2)  operation also support B<writev>"
"(2).  All files support the B<access>(2)  and B<stat>(2)  family of "
"operations, but for the latter call, the only fields of the returned I<stat> "
"structure that contain reliable information are I<st_mode>, I<st_nlink>, "
"I<st_uid>, and I<st_gid>."
msgstr ""
"B<read>(2) 操作をサポートしている全てのファイルは B<readv>(2) を\n"
"サポートしており、B<write>(2) 操作をサポートしている全てのファイルは\n"
"B<writev>(2) をサポートしている。\n"
"全てのファイルは、 B<access>(2) と B<stat>(2) 系の操作に対応しているが、\n"
"B<stat>(2) では、呼び出した際に返される I<stat> 構造体のフィールドのう\n"
"ち信頼できる情報が入っているのは I<st_mode>, I<st_nlink>, I<st_uid>,\n"
"I<st_gid> だけである。"

#. type: Plain text
#: build/C/man7/spufs.7:106
msgid ""
"All files support the B<chmod>(2)/B<fchmod>(2)  and B<chown>(2)/B<fchown>"
"(2)  operations, but will not be able to grant permissions that contradict "
"the possible operations (e.g., read access on the I<wbox> file)."
msgstr ""
"全てのファイルは B<chmod>(2)/B<fchmod>(2)  と B<chown>(2)/B<fchown>(2)  の操"
"作に対応しているが、 そのファイルが対応している操作と矛盾するアクセス許可を "
"付与することはできない (例えば、 I<wbox> ファイルに対する読み出しアクセスな"
"ど)。"

#. type: Plain text
#: build/C/man7/spufs.7:108
msgid "The current set of files is:"
msgstr "現時点でのファイルは以下の通りである。"

#. type: TP
#: build/C/man7/spufs.7:108
#, no-wrap
msgid "I</capabilities>"
msgstr "I</capabilities>"

#. type: Plain text
#: build/C/man7/spufs.7:113
msgid ""
"Contains a comma-delimited string representing the capabilities of this SPU "
"context.  Possible capabilities are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:114
#, no-wrap
msgid "B<sched>"
msgstr "B<sched>"

#. type: Plain text
#: build/C/man7/spufs.7:117
msgid "This context may be scheduled."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:117
#, no-wrap
msgid "B<step>"
msgstr "B<step>"

#. type: Plain text
#: build/C/man7/spufs.7:120
msgid "This context can be run in single-step mode, for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:122
msgid "New capabilities flags may be added in the future."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:123
#, no-wrap
msgid "I</mem>"
msgstr "I</mem>"

#. type: Plain text
#: build/C/man7/spufs.7:132
msgid ""
"the contents of the local storage memory of the SPU.  This can be accessed "
"like a regular shared memory file and contains both code and data in the "
"address space of the SPU.  The possible operations on an open I<mem> file "
"are:"
msgstr ""
"SPU のローカルストレージの内容。 このファイルは通常の共有メモリファイルと同様"
"にアクセスでき、 SPU のアドレス空間にはコードとデータの両方を格納できる。 "
"オープンされた I<mem> ファイルに可能な操作は以下である。"

#. type: TP
#: build/C/man7/spufs.7:133
#, no-wrap
msgid "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"
msgstr "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:144
msgid ""
"These operate as usual, with the exception that B<lseek>(2), B<write>(2), "
"and B<pwrite>(2)  are not supported beyond the end of the file.  The file "
"size is the size of the local storage of the SPU, which is normally 256 "
"kilobytes."
msgstr ""
"これらは通常通り動作するが、 ファイル末尾を越えての B<lseek>(2), B<write>"
"(2), B<pwrite>(2)  に対応していない点だけが異なる。 ファイルサイズは SPU の"
"ローカルストレージのサイズであり、 通常は 256 キロバイトである。"

#. type: TP
#: build/C/man7/spufs.7:144 build/C/man7/spufs.7:706 build/C/man7/spufs.7:725
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:153
msgid ""
"Mapping I<mem> into the process address space provides access to the SPU "
"local storage within the process address space.  Only B<MAP_SHARED> mappings "
"are allowed."
msgstr ""
"I<mem> をプロセスのアドレス空間にマッピングすると、プロセスのアドレス\n"
"空間の一部として SPU のローカル・ストレージにアクセスできるようになる。\n"
"許可されているマッピングは B<MAP_SHARED> だけである。"

#. type: TP
#: build/C/man7/spufs.7:154
#, no-wrap
msgid "I</regs>"
msgstr "I</regs>"

#. type: Plain text
#: build/C/man7/spufs.7:161
msgid ""
"Contains the saved general-purpose registers of the SPU context.  This file "
"contains the 128-bit values of each register, from register 0 to register "
"127, in order.  This allows the general-purpose registers to be inspected "
"for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:165
msgid ""
"Reading to or writing from this file requires that the context is scheduled "
"out, so use of this file is not recommended in normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:171
msgid ""
"The I<regs> file is not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:171
#, no-wrap
msgid "I</mbox>"
msgstr "I</mbox>"

#. type: Plain text
#: build/C/man7/spufs.7:181
msgid ""
"The first SPU-to-CPU communication mailbox.  This file is read-only and can "
"be read in units of 4 bytes.  The file can be used only in nonblocking mode "
"- even B<poll>(2)  cannot be used to block on this file.  The only possible "
"operation on an open I<mbox> file is:"
msgstr ""
"SPU から CPU への通信用の 1 つ目のメールボックス。このファイルは読み出\n"
"し専用で、読み出しは 4 バイト単位で行う。このファイルは非停止\n"
"(non-blocking) モードでのみ使用でき、 B<poll>(2) であってもこの\n"
"ファイルで停止 (block) することはできない。オープンされた I<mbox> \n"
"ファイルに可能な操作は以下である。"

#. type: TP
#: build/C/man7/spufs.7:182 build/C/man7/spufs.7:222 build/C/man7/spufs.7:317
#: build/C/man7/spufs.7:381 build/C/man7/spufs.7:418 build/C/man7/spufs.7:463
#: build/C/man7/spufs.7:517 build/C/man7/spufs.7:632 build/C/man7/spufs.7:676
#: build/C/man7/spufs.7:754
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:200
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox (i.e., the SPU "
"has not sent a mailbox message), the return value is set to -1 and I<errno> "
"is set to B<EAGAIN>.  When data has been read successfully, four bytes are "
"placed in the data buffer and the value four is returned."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2) は -1 を返し、 I<errno> を\n"
"B<EINVAL> に設定する。 メールボックスにデータがない場合 (すなわち SPU\n"
"がメールボックスメッセージを送信していない場合)、-1 が返り、 I<errno>\n"
"が B<EAGAIN> に設定される。データの読み出しに成功した場合、 4 バイトが\n"
"データバッファに格納され、返り値として 4 が返される。"

#. type: TP
#: build/C/man7/spufs.7:201
#, no-wrap
msgid "I</ibox>"
msgstr "I</ibox>"

#. type: Plain text
#: build/C/man7/spufs.7:217
msgid ""
"The second SPU-to-CPU communication mailbox.  This file is similar to the "
"first mailbox file, but can be read in blocking I/O mode, thus calling "
"B<read>(2)  on an open I<ibox> file will block until the SPU has written "
"data to its interrupt mailbox channel (unless the file has been opened with "
"B<O_NONBLOCK>, see below).  Also, B<poll>(2)  and similar system calls can "
"be used to monitor for the presence of mailbox data."
msgstr ""
"SPU から CPU への通信用の 2 つ目のメールボックスである。このファイルは\n"
"1 つ目のメールボックスファイルと似ているが、停止 (blocking) I/O モード\n"
"での読み出しが可能である。したがって、オープンされた I<ibox> ファイルに\n"
"対して B<read>(2) を呼び出すと、(ファイルが B<O_NONBLOCK> (下記参照) で\n"
"オープンされていない場合は) SPU がデータを割り込みメールボックスチャネ\n"
"ル (interrupt mailbox channel) に書き込むまでその呼び出しは停止\n"
"(block) する。また、 B<poll>(2) や同様のシステムコールを使って、メール\n"
"ボックスにデータがあるかをを監視することができる。オープンされた\n"
"I<ibox> ファイルに対して可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:221
msgid "The possible operations on an open I<ibox> file are:"
msgstr "オープンされた I<ibox> ファイルに対して可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:239
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 メールボックスにデータがない場合、ファイルディスクリプ"
"タが B<O_NONBLOCK> でオープンされていれば、返り値は -1 となり、 I<errno> は "
"B<EAGAIN> に設定される。"

#. type: Plain text
#: build/C/man7/spufs.7:247
msgid ""
"If there is no data available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU writes "
"to its interrupt mailbox channel.  When data has been read successfully, "
"four bytes are placed in the data buffer and the value four is returned."
msgstr ""
"メールボックスにデータがない場合で、ファイルディスクリプタが B<O_NONBLOCK> な"
"しでオープンされていれば、 SPU が自分の割り込みメールボックスチャネル "
"(interrupt mailbox channel)  に書き込みを行うまで B<read>(2)  は停止 (block) "
"する。 データの読み出しに成功した場合、 4 バイトがデータバッファに格納され、"
"返り値として 4 が返される。"

#. type: TP
#: build/C/man7/spufs.7:247 build/C/man7/spufs.7:295 build/C/man7/spufs.7:685
#, no-wrap
msgid "B<poll>(2)"
msgstr "B<poll>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:254
msgid ""
"Poll on the I<ibox> file returns I<(POLLIN | POLLRDNORM)> whenever data is "
"available for reading."
msgstr ""
"I<ibox> ファイルに対する B<poll>(2)  は、読み出しデータが利用可能になる度に "
"I<(POLLIN | POLLRDNORM)> を返す。"

#. type: TP
#: build/C/man7/spufs.7:255
#, no-wrap
msgid "I</wbox>"
msgstr "I</wbox>"

#. type: Plain text
#: build/C/man7/spufs.7:267
msgid ""
"The CPU-to-SPU communication mailbox.  It is write-only and can be written "
"in units of four bytes.  If the mailbox is full, B<write>(2)  will block, "
"and B<poll>(2)  can be used to block until the mailbox is available for "
"writing again.  The possible operations on an open I<wbox> file are:"
msgstr ""
"CPU から SPU への通信用のメールボックス。このファイルは書き込み専用で、\n"
"書き込みは 4 バイト単位で行う。メールボックスが一杯の場合、\n"
"B<write>(2) は停止 (block) する。 B<poll>(2) を使ってメールボックスに\n"
"再度書き込み可能になるまで待つことができる。\n"
"オープンされた I<wbox> ファイルに対して可能な操作は以下である。"

#. type: TP
#: build/C/man7/spufs.7:268 build/C/man7/spufs.7:392 build/C/man7/spufs.7:432
#: build/C/man7/spufs.7:476 build/C/man7/spufs.7:527 build/C/man7/spufs.7:638
#: build/C/man7/spufs.7:652 build/C/man7/spufs.7:749
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: build/C/man7/spufs.7:286
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no space available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""
"I<count> が 4 より小さい場合、 B<write>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 メールボックスに空き領域がない場合、ファイルディスクリ"
"プタが B<O_NONBLOCK> でオープンされていれば、返り値は -1 となり、 I<errno> "
"は B<EAGAIN> に設定される。"

#. type: Plain text
#: build/C/man7/spufs.7:295
msgid ""
"If there is no space available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU reads "
"from its PPE (PowerPC Processing Element)  mailbox channel.  When data has "
"been written successfully, the system call returns four as its function "
"result."
msgstr ""
"メールボックスに空き領域がない場合で、ファイルディスクリプタが\n"
"B<O_NONBLOCK> なしでオープンされていれば、 SPU が自分の PPE (PowerPC\n"
"Processing Element) メールボックスチャネルから読み出しを行うまで\n"
"B<write>(2) は停止 (block) する。 データの書き込みに成功した場合、\n"
"返り値として 4 が返される。"

#. type: Plain text
#: build/C/man7/spufs.7:302
msgid ""
"A poll on the I<wbox> file returns I<(POLLOUT | POLLWRNORM)> whenever space "
"is available for writing."
msgstr ""
"I<wbox> ファイルに対する B<poll>(2)  は、書き込み用の空間が利用可能になる度"
"に I<(POLLOUT | POLLWRNORM)> を返す。"

#. type: TP
#: build/C/man7/spufs.7:303
#, no-wrap
msgid "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"
msgstr "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"

#. type: Plain text
#: build/C/man7/spufs.7:316
msgid ""
"These are read-only files that contain the length of the current queue of "
"each mailbox, i.e., how many words can be read from I<mbox> or I<ibox> or "
"how many words can be written to I<wbox> without blocking.  The files can be "
"read only in four-byte units and return a big-endian binary integer number.  "
"The only possible operation on an open I<*box_stat> file is:"
msgstr ""
"これらのファイルは読み出し専用で、各メールボックスの現在のキュー長を保\n"
"持する。具体的には、停止 (blocking) せずに、 I<mbox> や I<ibox> から何\n"
"ワードを読み出すことができ、 I<wbox> に何ワードを書き込むことができるか、\n"
"ということである。これらのファイルは 4 バイト単位でのみ読み出しが可能\n"
"で、ビッグ・エンディアンの整数値を返す。オープンされた I<*box_stat>\n"
"ファイルに対して可能な操作は以下だけである。"

#. type: Plain text
#: build/C/man7/spufs.7:337
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer.  "
"This value is the number of elements that can be read from (for I<mbox_stat> "
"and I<ibox_stat>)  or written to (for I<wbox_stat>)  the respective mailbox "
"without blocking or returning an B<EAGAIN> error."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、データバッファに 4 バイトの値が書き込"
"まれる。 この値は、各メールボックスにおいて停止せずに、または B<EAGAIN> エ"
"ラーなしで、読み出し可能なエレメント数 (I<mbox_stat> や I<ibox_stat> の場"
"合)、書き込み可能なエレメント数 (I<wbox_stat> の場合) である。"

#. type: TP
#: build/C/man7/spufs.7:338
#, no-wrap
msgid "I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, I</event_status>, I</srr0>, I</lslr>"
msgstr ""
"I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>,\n"
"I</event_status>, I</srr0>, I</lslr>"

#. type: Plain text
#: build/C/man7/spufs.7:350
msgid ""
"Internal registers of the SPU.  These files contain an ASCII string "
"representing the hex value of the specified register.  Reads and writes on "
"these files (except for I<npc>, see below) require that the SPU context be "
"scheduled out, so frequent access to these files is not recommended for "
"normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:352
msgid "The contents of these files are:"
msgstr "これらのファイルの内容は以下の通り。"

#. type: TP
#: build/C/man7/spufs.7:353
#, no-wrap
msgid "I<npc>"
msgstr "I<npc>"

#. type: Plain text
#: build/C/man7/spufs.7:356
msgid "Next Program Counter - valid only when the SPU is in a stopped state."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:356
#, no-wrap
msgid "I<decr>"
msgstr "I<decr>"

#. type: Plain text
#: build/C/man7/spufs.7:359
msgid "SPU Decrementer"
msgstr "SPU Decrementer"

#. type: TP
#: build/C/man7/spufs.7:359
#, no-wrap
msgid "I<decr_status>"
msgstr "I<decr_status>"

#. type: Plain text
#: build/C/man7/spufs.7:362
msgid "Decrementer Status"
msgstr "Decrementer の状態"

#. type: TP
#: build/C/man7/spufs.7:362
#, no-wrap
msgid "I<spu_tag_mask>"
msgstr "I<spu_tag_mask>"

#. type: Plain text
#: build/C/man7/spufs.7:365
msgid "MFC tag mask for SPU DMA"
msgstr "SPU の DMA 用の MFA タグマスク"

#. type: TP
#: build/C/man7/spufs.7:365
#, no-wrap
msgid "I<event_mask>"
msgstr "I<event_mask>"

#. type: Plain text
#: build/C/man7/spufs.7:368
msgid "Event mask for SPU interrupts"
msgstr "SPU の割り込みのイベントマスク"

#. type: TP
#: build/C/man7/spufs.7:368
#, no-wrap
msgid "I<event_status>"
msgstr "I<event_status>"

#. type: Plain text
#: build/C/man7/spufs.7:371
msgid "Number of SPU events pending (read-only)"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:371
#, no-wrap
msgid "I<srr0>"
msgstr "I<srr0>"

#. type: Plain text
#: build/C/man7/spufs.7:374
msgid "Interrupt Return address register"
msgstr "割り込みリターンアドレスレジスタ"

#. type: TP
#: build/C/man7/spufs.7:374
#, no-wrap
msgid "I<lslr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:377
msgid "Local Store Limit Register"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:380
msgid "The possible operations on these files are:"
msgstr "これらのファイルに対して可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:388
msgid ""
"Reads the current register value.  If the register value is larger than the "
"buffer passed to the B<read>(2)  system call, subsequent reads will continue "
"reading from the same buffer, until the end of the buffer is reached."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:392
msgid ""
"When a complete string has been read, all subsequent read operations will "
"return zero bytes and a new file descriptor needs to be opened to read a new "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:402 build/C/man7/spufs.7:537
msgid ""
"A B<write>(2)  operation on the file sets the register to the value given in "
"the string.  The string is parsed from the beginning until the first "
"nonnumeric character or the end of the buffer.  Subsequent writes to the "
"same file descriptor overwrite the previous setting."
msgstr ""
"このファイルへの B<write>(2)  操作はレジスタ値を文字列で指定された値に設定す"
"る。 文字列の解釈は先頭から開始され、数字以外の文字が初めて登場するか、 バッ"
"ファの末尾に達するまで行われる。 同じファイルディスクリプタへ続けて write を"
"行うと、 後の write により前の設定が上書きされる。"

#. type: Plain text
#: build/C/man7/spufs.7:409
msgid ""
"Except for the I<npc> file, these files are not present on contexts that "
"have been created with the B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:410
#, no-wrap
msgid "I</fpcr>"
msgstr "I</fpcr>"

#. type: Plain text
#: build/C/man7/spufs.7:417
msgid ""
"This file provides access to the Floating Point Status and Control Register "
"(fcpr) as a binary, four-byte file.  The operations on the I<fpcr> file are:"
msgstr ""
"このファイルにより Floating Point Status and Control Register (fcpr) に\n"
"アクセスできる。このファイルはバイナリで、大きさは 4 バイトである。 \n"
"I<fpcr> ファイルに可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:432
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the I<fpcr> register."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、データバッファに 4 バイトの値が書き込"
"まれる。 書き込まれる値は I<fpcr> レジスタの現在の値である。"

#. type: Plain text
#: build/C/man7/spufs.7:446
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the I<fpcr> register."
msgstr ""
"I<count> が 4 より小さい場合、 B<write>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、 4 バイトの値がデータバッファからコ"
"ピーされ、 I<fpcr> レジスタの値が更新される。"

#. type: TP
#: build/C/man7/spufs.7:447
#, no-wrap
msgid "I</signal1>, I</signal2>"
msgstr "I</signal1>, I</signal2>"

#. type: Plain text
#: build/C/man7/spufs.7:462
msgid ""
"The files provide access to the two signal notification channels of an SPU.  "
"These are read-write files that operate on four-byte words.  Writing to one "
"of these files triggers an interrupt on the SPU.  The value written to the "
"signal files can be read from the SPU through a channel read or from host "
"user space through the file.  After the value has been read by the SPU, it "
"is reset to zero.  The possible operations on an open I<signal1> or "
"I<signal2> file are:"
msgstr ""
"これらのファイルにより SPU の二つのシグナル通知チャネル (signal\n"
"notification channel) に アクセスできる。これらは 4 バイトワード単位の\n"
"読み書きができる。これらのファイルの一つに書き込みを行うと、その SPU の\n"
"割り込みが 発生するトリガーとなる。シグナルファイルへ書き込まれた値は、\n"
"チャネル経由で SPU で読み出したり、このファイル経由でホストのユーザ空間\n"
"で読み出したりできる。 SPU が値を読み出した後では、値は 0 にリセット\n"
"される。オープンされた I<signal1> や I<signal2> ファイルに可能な操作は\n"
"以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:476
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the specified signal notification register."
msgstr ""
"I<count> が 4 より小さい場合、 B<read>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、データバッファに 4 バイトの値が書き込"
"まれる。 書き込まれる値は、指定されたシグナル通知レジスタの現在の値である。"

#. type: Plain text
#: build/C/man7/spufs.7:497
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the specified signal notification register.  The "
"signal notification register will either be replaced with the input data or "
"will be updated to the bitwise OR operation of the old value and the input "
"data, depending on the contents of the I<signal1_type> or I<signal2_type> "
"files respectively."
msgstr ""
"I<count> が 4 より小さい場合、 B<write>(2)  は -1 を返し、 I<errno> を "
"B<EINVAL> に設定する。 それ以外の場合、 4 バイトの値がデータバッファからコ"
"ピーされ、 指定されたシグナル通知レジスタの値が更新される。 シグナル通知レジ"
"スタの更新には、レジスタ値を入力データで置き換えるモードと 以前の値と入力デー"
"タのビット単位の OR をとった値に更新するモードがある。 どちらのモードになるか"
"は、それぞれ I<signal1_type>, I<signal2_type> ファイルの内容によって決まる。"

#. type: TP
#: build/C/man7/spufs.7:498
#, no-wrap
msgid "I</signal1_type>, I</signal2_type>"
msgstr "I</signal1_type>, I</signal2_type>"

#. type: Plain text
#: build/C/man7/spufs.7:516
msgid ""
"These two files change the behavior of the I<signal1> and I<signal2> "
"notification files.  They contain a numeric ASCII string which is read as "
"either \"1\" or \"0\".  In mode 0 (overwrite), the hardware replaces the "
"contents of the signal channel with the data that is written to it.  In mode "
"1 (logical OR), the hardware accumulates the bits that are subsequently "
"written to it.  The possible operations on an open I<signal1_type> or "
"I<signal2_type> file are:"
msgstr ""
"これらのファイルは、シグナル通知ファイル I<signal1> と I<signal2> の動作を変"
"更する。 これらのファイルは数値を表すアスキー文字列を保持し、 読み出すと "
"\"1\" か \"0\" のどちらかが得られる。 モード 0 (上書きモード) では、ハード"
"ウェアはシグナルチャネルの内容を シグナルチャネルに書き込まれたデータで置き換"
"える。 モード 1 (論理 OR モード) では、ハードウェアはシグナルチャネルに 書き"
"込まれたビットを積算していく。 オープンされた I<signal1_type> や "
"I<signal2_type> ファイルに可能な操作は以下である。"

#. type: Plain text
#: build/C/man7/spufs.7:527
msgid ""
"When the count supplied to the B<read>(2)  call is shorter than the required "
"length for the digit (plus a newline character), subsequent reads from the "
"same file descriptor will complete the string.  When a complete string has "
"been read, all subsequent read operations will return zero bytes and a new "
"file descriptor needs to be opened to read the value again."
msgstr ""
"B<read>(2) に渡された I<count> がレジスタの数値 (と改行 (newline) 文字\n"
"1 個) を格納するのに必要な長さより 短い場合、同じファイルディスクリプタ\n"
"を続けて read することで、文字列全体を読み出すことができる。文字列全体\n"
"が読み出されると、それ以降の read 操作では 0 バイトが返され、新しい値を\n"
"読み出すには新しいファイルディスクリプタをオープンする必要がある。"

#. type: TP
#: build/C/man7/spufs.7:538
#, no-wrap
msgid "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"
msgstr "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"

#. type: Plain text
#: build/C/man7/spufs.7:557
msgid ""
"Read-only files that contain the saved state of the SPU mailboxes and DMA "
"queues.  This allows the SPU status to be inspected, mainly for debugging.  "
"The I<mbox_info> and I<ibox_info> files each contain the four-byte mailbox "
"message that has been written by the SPU.  If no message has been written to "
"these mailboxes, then contents of these files is undefined.  The "
"I<mbox_stat>, I<ibox_stat> and I<wbox_stat> files contain the available "
"message count."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:566
msgid ""
"The I<wbox_info> file contains an array of four-byte mailbox messages, which "
"have been sent to the SPU.  With current CBEA machines, the array is four "
"items in length, so up to 4 * 4 = 16 bytes can be read from this file.  If "
"any mailbox queue entry is empty, then the bytes read at the corresponding "
"location are undefined."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:571
msgid ""
"The I<dma_info> file contains the contents of the SPU MFC DMA queue, "
"represented as the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:582
#, no-wrap
msgid ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:590
msgid ""
"The last member of this data structure is the actual DMA queue, containing "
"16 entries.  The I<mfc_cq_sr> structure is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:599
#, no-wrap
msgid ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:607
msgid ""
"The I<proxydma_info> file contains similar information, but describes the "
"proxy DMA queue (i.e., DMAs initiated by entities outside the SPU) instead.  "
"The file is in the following format:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:616
#, no-wrap
msgid ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:622
msgid ""
"Accessing these files requires that the SPU context is scheduled out - "
"frequent use can be inefficient.  These files should not be used for normal "
"program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:626
msgid ""
"These files are not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:626
#, no-wrap
msgid "I</cntl>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:631
msgid ""
"This file provides access to the SPU Run Control and SPU status registers, "
"as an ASCII string.  The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:638
msgid ""
"Reads from the I<cntl> file will return an ASCII string with the hex value "
"of the SPU Status register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:643
msgid ""
"Writes to the I<cntl> file will set the context's SPU Run Control register."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:644
#, no-wrap
msgid "I</mfc>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:651
msgid ""
"Provides access to the Memory Flow Controller of the SPU.  Reading from the "
"file returns the contents of the SPU's MFC Tag Status register, and writing "
"to the file initiates a DMA from the MFC.  The following operations are "
"supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:656
msgid ""
"Writes to this file need to be in the format of a MFC DMA command, defined "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:668
#, no-wrap
msgid ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:676
msgid ""
"Writes are required to be exactly I<sizeof(struct mfc_dma_command)> bytes in "
"size.  The command will be sent to the SPU's MFC proxy queue, and the tag "
"stored in the kernel (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:685
msgid ""
"Reads the contents of the tag status register.  If the file is opened in "
"blocking mode (i.e., without B<O_NONBLOCK>), then the read will block until "
"a DMA tag (as performed by a previous write) is complete.  In nonblocking "
"mode, the MFC tag status register will be returned without waiting."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:698
msgid ""
"Calling B<poll>(2)  on the I<mfc> file will block until a new DMA can be "
"started (by checking for B<POLLOUT>)  or until a previously started DMA (by "
"checking for B<POLLIN>)  has been completed."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:704
msgid ""
"I</mss> Provides access to the MFC MultiSource Synchronization (MSS) "
"facility.  By B<mmap>(2)-ing this file, processes can access the MSS area of "
"the SPU."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:706 build/C/man7/spufs.7:724
msgid "The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:715
msgid ""
"Mapping B<mss> into the process address space gives access to the SPU MSS "
"area within the process address space.  Only B<MAP_SHARED> mappings are "
"allowed."
msgstr ""
"I<mss> をプロセスのアドレス空間にマッピングすると、プロセスのアドレス空\n"
"間の一部として SPU の MSS 領域にアクセスできるようになる。\n"
"許可されているマッピングは B<MAP_SHARED> だけである。"

#. type: TP
#: build/C/man7/spufs.7:716
#, no-wrap
msgid "I</psmap>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:722
msgid ""
"Provides access to the whole problem-state mapping of the SPU.  Applications "
"can use this area to interface to the SPU, rather than writing to individual "
"register files in B<spufs>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:733
msgid ""
"Mapping B<psmap> gives a process a direct map of the SPU problem state "
"area.  Only B<MAP_SHARED> mappings are supported."
msgstr ""
"I<psmap> をプロセスのアドレス空間にマッピングすると、\n"
"SPU の problem state 領域に直接アクセスできるようになる。\n"
"許可されているマッピングは B<MAP_SHARED> だけである。"

#. type: TP
#: build/C/man7/spufs.7:734
#, no-wrap
msgid "I</phys-id>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:740
msgid ""
"Read-only file containing the physical SPU number that the SPU context is "
"running on.  When the context is not running, this file contains the string "
"\"-1\"."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:742
msgid "The physical SPU number is given by an ASCII hex string."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:742
#, no-wrap
msgid "I</object-id>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:748
msgid ""
"Allows applications to store (or retrieve) a single 64-bit ID into the "
"context.  This ID is later used by profiling tools to uniquely identify the "
"context."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:754
msgid ""
"By writing an ASCII hex value into this file, applications can set the "
"object ID of the SPU context.  Any previous value of the object ID is "
"overwritten."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:758
msgid ""
"Reading this file gives an ASCII hex string representing the object ID for "
"this SPU context."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:760
#, no-wrap
msgid "I</etc/fstab>  entry"
msgstr "I</etc/fstab>  entry"

#.  .SH AUTHORS
#.  Arnd Bergmann <arndb@de.ibm.com>, Mark Nutter <mnutter@us.ibm.com>,
#.  Ulrich Weigand <Ulrich.Weigand@de.ibm.com>, Jeremy Kerr <jk@ozlabs.org>
#. type: Plain text
#: build/C/man7/spufs.7:766
msgid "none \t/spu \tspufs \tgid=spu \t0\t0"
msgstr "none \t/spu \tspufs \tgid=spu \t0\t0"

#. type: Plain text
#: build/C/man7/spufs.7:771
msgid "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"
msgstr "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"

#. type: Plain text
#: build/C/man7/spufs.7:773
msgid "I<The Cell Broadband Engine Architecture (CBEA) specification>"
msgstr ""

#. type: TH
#: build/C/man2/stat.2:40
#, no-wrap
msgid "STAT"
msgstr "STAT"

#. type: TH
#: build/C/man2/stat.2:40
#, no-wrap
msgid "2012-11-11"
msgstr "2012-11-11"

#. type: Plain text
#: build/C/man2/stat.2:43
msgid "stat, fstat, lstat - get file status"
msgstr "stat, fstat, lstat - ファイルの状態を取得する"

#. type: Plain text
#: build/C/man2/stat.2:45
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/stat.2:47
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr "B<#include E<lt>sys/stat.hE<gt>>"

#. type: Plain text
#: build/C/man2/stat.2:49
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/stat.2:51
msgid "B<int stat(const char *>I<path>B<, struct stat *>I<buf>B<);>"
msgstr "B<int stat(const char *>I<path>B<, struct stat *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/stat.2:53
msgid "B<int fstat(int >I<fd>B<, struct stat *>I<buf>B<);>"
msgstr "B<int fstat(int >I<fd>B<, struct stat *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/stat.2:55
msgid "B<int lstat(const char *>I<path>B<, struct stat *>I<buf>B<);>"
msgstr "B<int lstat(const char *>I<path>B<, struct stat *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/stat.2:64
msgid "B<lstat>():"
msgstr "B<lstat>():"

#. type: Plain text
#: build/C/man2/stat.2:67
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/stat.2:69
msgid "|| /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* glibc 2.10 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/stat.2:83
msgid ""
"These functions return information about a file.  No permissions are "
"required on the file itself, but\\(emin the case of B<stat>()  and B<lstat>"
"()  \\(em execute (search) permission is required on all of the directories "
"in I<path> that lead to the file."
msgstr ""
"これらの関数はファイルについての情報を返す。\n"
"ファイルそのものに対するアクセス許可は必要としないが、\n"
"\\(emB<stat>() と B<lstat>()  の場合には \\(em\n"
"そのファイルへ至る I<path> を構成する全てのディレクトリに対する\n"
"実行 (検索) 許可が必要である。"

#. type: Plain text
#: build/C/man2/stat.2:89
msgid "B<stat>()  stats the file pointed to by I<path> and fills in I<buf>."
msgstr ""
"B<stat>()  は I<path> で指定されたファイルの状態を取得して I<buf> へ格納す"
"る。"

#. type: Plain text
#: build/C/man2/stat.2:97
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<path> is a symbolic "
"link, then the link itself is stat-ed, not the file that it refers to."
msgstr ""
"B<lstat>()  は B<stat>()  と同じであるが、 I<path> がシンボリックリンクの場"
"合、リンクが参照しているファイルではなく、 リンク自身の状態を取得する点が異な"
"る。"

#. type: Plain text
#: build/C/man2/stat.2:103
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file to be stat-ed is "
"specified by the file descriptor I<fd>."
msgstr ""
"B<fstat>()  は B<stat>()  と同じだが、 状態を取得するファイルをファイル・ディ"
"スクリプタ I<fd> で指定する。"

#. type: Plain text
#: build/C/man2/stat.2:107
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr ""
"これらのシステムコールはいずれも、結果を I<stat> 構造体に入れて返す。 "
"I<stat> 構造体には以下のフィールドが含まれている:"

#. type: Plain text
#: build/C/man2/stat.2:125
#, no-wrap
msgid ""
"struct stat {\n"
"    dev_t     st_dev;     /* ID of device containing file */\n"
"    ino_t     st_ino;     /* inode number */\n"
"    mode_t    st_mode;    /* protection */\n"
"    nlink_t   st_nlink;   /* number of hard links */\n"
"    uid_t     st_uid;     /* user ID of owner */\n"
"    gid_t     st_gid;     /* group ID of owner */\n"
"    dev_t     st_rdev;    /* device ID (if special file) */\n"
"    off_t     st_size;    /* total size, in bytes */\n"
"    blksize_t st_blksize; /* blocksize for file system I/O */\n"
"    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */\n"
"    time_t    st_atime;   /* time of last access */\n"
"    time_t    st_mtime;   /* time of last modification */\n"
"    time_t    st_ctime;   /* time of last status change */\n"
"};\n"
msgstr ""
"struct stat {\n"
"    dev_t     st_dev;     /* ファイルがあるデバイスの ID */\n"
"    ino_t     st_ino;     /* inode 番号 */\n"
"    mode_t    st_mode;    /* アクセス保護 */\n"
"    nlink_t   st_nlink;   /* ハードリンクの数 */\n"
"    uid_t     st_uid;     /* 所有者のユーザ ID */\n"
"    gid_t     st_gid;     /* 所有者のグループ ID */\n"
"    dev_t     st_rdev;    /* デバイス ID (特殊ファイルの場合) */\n"
"    off_t     st_size;    /* 全体のサイズ (バイト単位) */\n"
"    blksize_t st_blksize; /* ファイルシステム I/O での\n"
"                             ブロックサイズ */\n"
"    blkcnt_t  st_blocks;  /* 割り当てられた 512B のブロック数 */\n"
"    time_t    st_atime;   /* 最終アクセス時刻 */\n"
"    time_t    st_mtime;   /* 最終修正時刻 */\n"
"    time_t    st_ctime;   /* 最終状態変更時刻 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/stat.2:136
msgid ""
"The I<st_dev> field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr ""
"I<st_dev> フィールドは、このファイルが存在するデバイスを示す (マクロ B<major>"
"(3), B<minor>(3)  は、このフィールドのデバイス ID を分解するのに役立つだろ"
"う)。"

#. type: Plain text
#: build/C/man2/stat.2:140
msgid ""
"The I<st_rdev> field describes the device that this file (inode) represents."
msgstr "I<st_rdev> フィールドは、このファイル (inode) が表すデバイスを示す。"

#. type: Plain text
#: build/C/man2/stat.2:147
msgid ""
"The I<st_size> field gives the size of the file (if it is a regular file or "
"a symbolic link) in bytes.  The size of a symbolic link is the length of the "
"pathname it contains, without a terminating null byte."
msgstr ""
"I<st_size> フィールドは、(通常のファイルかシンボリックリンクの場合に)\n"
"ファイルの大きさをバイト単位で示す。 シンボリックリンクの大きさは、\n"
"シンボリックリンクに含まれている パス名の長さ (終端の NULL バイトは含まな"
"い)\n"
"である。"

#. type: Plain text
#: build/C/man2/stat.2:154
msgid ""
"The I<st_blocks> field indicates the number of blocks allocated to the file, "
"512-byte units.  (This may be smaller than I<st_size>/512 when the file has "
"holes.)"
msgstr ""
"I<st_blocks> フィールドは、ファイルの大きさを 512 バイトのブロックサイズ単位"
"で示す フィールドは、ファイルに割り当てされたブロック数を 512 バイト単位で示"
"す。 (ファイルに穴があるような場合、この値は I<st_size>/512 より小さくなるこ"
"ともある)。"

#. type: Plain text
#: build/C/man2/stat.2:160
msgid ""
"The I<st_blksize> field gives the \"preferred\" blocksize for efficient file "
"system I/O.  (Writing to a file in smaller chunks may cause an inefficient "
"read-modify-rewrite.)"
msgstr ""
"I<st_blksize> フィールドは、効率的にファイルシステム I/O ができる「好まし"
"い」 ブロックサイズを示す (もっと小さい単位でファイルに書き込みを行うと、 読"
"み出し--修正--再書き込みといった非効率な動作になってしまうかもしれない)。"

#. type: Plain text
#: build/C/man2/stat.2:181
msgid ""
"Not all of the Linux file systems implement all of the time fields.  Some "
"file system types allow mounting in such a way that file and/or directory "
"accesses do not cause an update of the I<st_atime> field.  (See I<noatime>, "
"I<nodiratime>, and I<relatime> in B<mount>(8), and related information in "
"B<mount>(2).)  In addition, I<st_atime> is not updated if a file is opened "
"with the B<O_NOATIME>; see B<open>(2)."
msgstr ""
"全ての Linux のファイルシステムが全ての時間フィールドを 実装しているわけでは"
"ない。 ファイルやディレクトリのアクセスが I<st_atime> フィールドを更新しない"
"ようなかたちでマウントできるファイルシステムもある。 (B<mount>(8)  の "
"I<noatime>, I<nodiratime>, I<relatime> や B<mount>(2)  の関連する情報を参"
"照)。 また、ファイルが B<O_NOATIME> 付きでオープンされている場合には "
"I<st_atime> は更新されない。 B<open>(2)  参照。"

#. type: Plain text
#: build/C/man2/stat.2:196
msgid ""
"The field I<st_atime> is changed by file accesses, for example, by B<execve>"
"(2), B<mknod>(2), B<pipe>(2), B<utime>(2)  and B<read>(2)  (of more than "
"zero bytes).  Other routines, like B<mmap>(2), may or may not update "
"I<st_atime>."
msgstr ""
"I<st_atime> フィールドはファイルアクセスがあった場合に変更される (例えば、 "
"B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2)  を使用した場合や B<read>"
"(2)  で 1 バイト以上読み込んだ場合など)。 B<mmap>(2)  などの他のルーチンで"
"は、 I<st_atime> は更新されることもあれば、そうでない場合もある。"

#. type: Plain text
#: build/C/man2/stat.2:215
msgid ""
"The field I<st_mtime> is changed by file modifications, for example, by "
"B<mknod>(2), B<truncate>(2), B<utime>(2)  and B<write>(2)  (of more than "
"zero bytes).  Moreover, I<st_mtime> of a directory is changed by the "
"creation or deletion of files in that directory.  The I<st_mtime> field is "
"I<not> changed for changes in owner, group, hard link count, or mode."
msgstr ""
"I<st_mtime> フィールドは、ファイルが修正された場合に変更される (例えば、 "
"B<mknod>(2), B<truncate>(2), B<utime>(2)  を使用した場合や B<write>(2)  で 1 "
"バイト以上書き込みをした場合など)。 さらに、ディレクトリの I<st_mtime> は、そ"
"のディレクトリで ファイルが作成されたり削除されたりすると変更される。 "
"I<st_mtime> フィールドは 所有者やグループやハード・リンク数やモードの変更では"
"変更 I<されない。>"

#. type: Plain text
#: build/C/man2/stat.2:220
msgid ""
"The field I<st_ctime> is changed by writing or by setting inode information "
"(i.e., owner, group, link count, mode, etc.)."
msgstr ""
"I<st_ctime> フィールドは書き込みや inode 情報 (所有者、グループ、リンク数、"
"モードなど) の 設定によって変更される。"

#. type: Plain text
#: build/C/man2/stat.2:224
msgid ""
"The following POSIX macros are defined to check the file type using the "
"I<st_mode> field:"
msgstr ""
"以下の POSIX マクロは、 I<st_mode> フィールド で使用されるファイル種別の"
"チェックのために定義されている :"

#. type: TP
#: build/C/man2/stat.2:225
#, no-wrap
msgid "B<S_ISREG>(m)"
msgstr "B<S_ISREG>(m)"

#. type: Plain text
#: build/C/man2/stat.2:228
msgid "is it a regular file?"
msgstr "通常のファイルか?"

#. type: TP
#: build/C/man2/stat.2:228
#, no-wrap
msgid "B<S_ISDIR>(m)"
msgstr "B<S_ISDIR>(m)"

#. type: Plain text
#: build/C/man2/stat.2:231
msgid "directory?"
msgstr "ディレクトリか?"

#. type: TP
#: build/C/man2/stat.2:231
#, no-wrap
msgid "B<S_ISCHR>(m)"
msgstr "B<S_ISCHR>(m)"

#. type: Plain text
#: build/C/man2/stat.2:234
msgid "character device?"
msgstr "キャラクター・デバイスか?"

#. type: TP
#: build/C/man2/stat.2:234
#, no-wrap
msgid "B<S_ISBLK>(m)"
msgstr "B<S_ISBLK>(m)"

#. type: Plain text
#: build/C/man2/stat.2:237
msgid "block device?"
msgstr "ブロック・デバイスか?"

#. type: TP
#: build/C/man2/stat.2:237
#, no-wrap
msgid "B<S_ISFIFO>(m)"
msgstr "B<S_ISFIFO>(m)"

#. type: Plain text
#: build/C/man2/stat.2:240
msgid "FIFO (named pipe)?"
msgstr "FIFO (名前付きパイプ) か?"

#. type: TP
#: build/C/man2/stat.2:240
#, no-wrap
msgid "B<S_ISLNK>(m)"
msgstr "B<S_ISLNK>(m)"

#. type: Plain text
#: build/C/man2/stat.2:243
msgid "symbolic link? (Not in POSIX.1-1996.)"
msgstr "シンボリックリンクか? (POSIX.1-1996 にはない)"

#. type: TP
#: build/C/man2/stat.2:243
#, no-wrap
msgid "B<S_ISSOCK>(m)"
msgstr "B<S_ISSOCK>(m)"

#. type: Plain text
#: build/C/man2/stat.2:246
msgid "socket? (Not in POSIX.1-1996.)"
msgstr "ソケットか? (POSIX.1-1996 にはない)"

#. type: Plain text
#: build/C/man2/stat.2:251
msgid "The following flags are defined for the I<st_mode> field:"
msgstr "以下のフラグが I<st_mode> フィールド用に定義されている:"

#. type: tbl table
#: build/C/man2/stat.2:254
#, no-wrap
msgid "S_IFMT\t0170000\tbit mask for the file type bit fields\n"
msgstr "S_IFMT\t0170000\tファイル種別を示すビット領域を表すビットマスク\n"

#. type: tbl table
#: build/C/man2/stat.2:255
#, no-wrap
msgid "S_IFSOCK\t0140000\tsocket\n"
msgstr "S_IFSOCK\t0140000\tソケット\n"

#. type: tbl table
#: build/C/man2/stat.2:256
#, no-wrap
msgid "S_IFLNK\t0120000\tsymbolic link\n"
msgstr "S_IFLNK\t0120000\tシンボリックリンク\n"

#. type: tbl table
#: build/C/man2/stat.2:257
#, no-wrap
msgid "S_IFREG\t0100000\tregular file\n"
msgstr "S_IFREG\t0100000\t通常のファイル\n"

#. type: tbl table
#: build/C/man2/stat.2:258
#, no-wrap
msgid "S_IFBLK\t0060000\tblock device\n"
msgstr "S_IFBLK\t0060000\tブロック・デバイス\n"

#. type: tbl table
#: build/C/man2/stat.2:259
#, no-wrap
msgid "S_IFDIR\t0040000\tdirectory\n"
msgstr "S_IFDIR\t0040000\tディレクトリ\n"

#. type: tbl table
#: build/C/man2/stat.2:260
#, no-wrap
msgid "S_IFCHR\t0020000\tcharacter device\n"
msgstr "S_IFCHR\t0020000\tキャラクター・デバイス\n"

#. type: tbl table
#: build/C/man2/stat.2:261
#, no-wrap
msgid "S_IFIFO\t0010000\tFIFO\n"
msgstr "S_IFIFO\t0010000\tFIFO\n"

#. type: tbl table
#: build/C/man2/stat.2:262
#, no-wrap
msgid "S_ISUID\t0004000\tset-user-ID bit\n"
msgstr "S_ISUID\t0004000\tset-user-ID bit\n"

#. type: tbl table
#: build/C/man2/stat.2:263
#, no-wrap
msgid "S_ISGID\t0002000\tset-group-ID bit (see below)\n"
msgstr "S_ISGID\t0002000\tset-group-ID bit (下記参照)\n"

#. type: tbl table
#: build/C/man2/stat.2:264
#, no-wrap
msgid "S_ISVTX\t0001000\tsticky bit (see below)\n"
msgstr "S_ISVTX\t0001000\tスティッキー・ビット (下記参照)\n"

#. type: tbl table
#: build/C/man2/stat.2:265
#, no-wrap
msgid "S_IRWXU\t00700\tmask for file owner permissions\n"
msgstr "S_IRWXU\t00700\tファイル所有者のアクセス許可用のビットマスク\n"

#. type: tbl table
#: build/C/man2/stat.2:266
#, no-wrap
msgid "S_IRUSR\t00400\towner has read permission\n"
msgstr "S_IRUSR\t00400\t所有者の読み込み許可\n"

#. type: tbl table
#: build/C/man2/stat.2:267
#, no-wrap
msgid "S_IWUSR\t00200\towner has write permission\n"
msgstr "S_IWUSR\t00200\t所有者の書き込み許可\n"

#. type: tbl table
#: build/C/man2/stat.2:268
#, no-wrap
msgid "S_IXUSR\t00100\towner has execute permission\n"
msgstr "S_IXUSR\t00100\t所有者の実行許可\n"

#. type: tbl table
#: build/C/man2/stat.2:269
#, no-wrap
msgid "S_IRWXG\t00070\tmask for group permissions\n"
msgstr "S_IRWXG\t00070\tグループのアクセス許可用のビットマスク\n"

#. type: tbl table
#: build/C/man2/stat.2:270
#, no-wrap
msgid "S_IRGRP\t00040\tgroup has read permission\n"
msgstr "S_IRGRP\t00040\tグループの読み込み許可\n"

#. type: tbl table
#: build/C/man2/stat.2:271
#, no-wrap
msgid "S_IWGRP\t00020\tgroup has write permission\n"
msgstr "S_IWGRP\t00020\tグループの書き込み許可\n"

#. type: tbl table
#: build/C/man2/stat.2:272
#, no-wrap
msgid "S_IXGRP\t00010\tgroup has execute permission\n"
msgstr "S_IXGRP\t00010\tグループの実行許可\n"

#. type: tbl table
#: build/C/man2/stat.2:273
#, no-wrap
msgid "S_IRWXO\t00007\tmask for permissions for others (not in group)\n"
msgstr "S_IRWXO\t00007\t他人 (others) のアクセス許可用のビットマスク\n"

#. type: tbl table
#: build/C/man2/stat.2:274
#, no-wrap
msgid "S_IROTH\t00004\tothers have read permission\n"
msgstr "S_IROTH\t00004\t他人の読み込み許可\n"

#. type: tbl table
#: build/C/man2/stat.2:275
#, no-wrap
msgid "S_IWOTH\t00002\tothers have write permission\n"
msgstr "S_IWOTH\t00002\t他人の書き込み許可\n"

#. type: tbl table
#: build/C/man2/stat.2:276
#, no-wrap
msgid "S_IXOTH\t00001\tothers have execute permission\n"
msgstr "S_IXOTH\t00001\t他人の実行許可\n"

#. type: Plain text
#: build/C/man2/stat.2:293
msgid ""
"The set-group-ID bit (B<S_ISGID>)  has several special uses.  For a "
"directory it indicates that BSD semantics is to be used for that directory: "
"files created there inherit their group ID from the directory, not from the "
"effective group ID of the creating process, and directories created there "
"will also get the B<S_ISGID> bit set.  For a file that does not have the "
"group execution bit (B<S_IXGRP>)  set, the set-group-ID bit indicates "
"mandatory file/record locking."
msgstr ""
"set-group-ID bit (B<S_ISGID>)  にはいくつかの特殊な使用法がある: ディレクトリ"
"に設定した場合には、そのディレクトリが BSD 方式で使用される ことを示す。つま"
"り、そのディレクトリに作成されたファイルのグループID は 作成したプロセスの実"
"効 (effective) グループID ではなく、ディレクトリの グループID を継承する。ま"
"た、そのディレクトリに作成されたディレクトリにも B<S_ISGID> ビットが設定され"
"る。グループ実行ビット (B<S_IXGRP>)  が設定されていないファイルに設定された場"
"合は、 set-group-ID ビットはファイル/レコードの 強制的な (mandatory) ロックを"
"表す。"

#. type: Plain text
#: build/C/man2/stat.2:300
msgid ""
"The sticky bit (B<S_ISVTX>)  on a directory means that a file in that "
"directory can be renamed or deleted only by the owner of the file, by the "
"owner of the directory, and by a privileged process."
msgstr ""
"ディレクトリにスティッキービット (S_ISVTX) が設定された場合は、 そのディレク"
"トリのファイルの名前を変更したり、削除したりできるのは、 そのファイルの所有者"
"か、そのディレクトリの所有者か、特権プロセス だけとなる。"

#. type: Plain text
#: build/C/man2/stat.2:313
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"I<path> が所属するディレクトリとその上位のディレクトリのいずれかに 対する検索"
"許可がなかった (B<path_resolution>(7)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/stat.2:317
msgid "I<fd> is bad."
msgstr "I<fd> が不正である。"

#. type: Plain text
#: build/C/man2/stat.2:320
msgid "Bad address."
msgstr "アドレスが間違っている。"

#. type: Plain text
#: build/C/man2/stat.2:323
msgid "Too many symbolic links encountered while traversing the path."
msgstr "パスを辿る際に解決すべきシンボリックリンクが多過ぎた。"

#. type: Plain text
#: build/C/man2/stat.2:327
msgid "I<path> is too long."
msgstr "I<path> が長過ぎる。"

#. type: Plain text
#: build/C/man2/stat.2:334
msgid "A component of I<path> does not exist, or I<path> is an empty string."
msgstr "I<path> の構成要素が存在しないか、 I<path> が空文字列である。"

#. type: Plain text
#: build/C/man2/stat.2:337
msgid "Out of memory (i.e., kernel memory)."
msgstr "カーネルのメモリが足りない。"

#. type: Plain text
#: build/C/man2/stat.2:342
msgid "A component of the path prefix of I<path> is not a directory."
msgstr "I<path> の前半部分 (prefix) の構成要素がディレクトリではない。"

#. type: TP
#: build/C/man2/stat.2:342 build/C/man2/statfs.2:187
#: build/C/man3/statvfs.3:154
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: build/C/man2/stat.2:361
msgid ""
"I<path> or I<fd> refers to a file whose size, inode number, or number of "
"blocks cannot be represented in, respectively, the types I<off_t>, I<ino_t>, "
"or I<blkcnt_t>.  This error can occur when, for example, an application "
"compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> calls B<stat>"
"()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr ""
"I<path> または I<fd> が、ファイルサイズ、inode 番号、ブロック数が\n"
"それぞれ I<off_t> 型、 I<ino_t> 型、 I<blkcnt_t> 型で表現できないファイルを\n"
"参照している。このエラーが起こるのは、例えば、32 ビットプラットフォーム上で\n"
"I<-D_FILE_OFFSET_BITS=64> を指定せずにコンパイルされたアプリケーションが、\n"
"ファイルサイズが I<(1E<lt>E<lt>31)-1> バイトを超えるファイルに対して\n"
"B<stat>() を呼び出した場合である。"

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: build/C/man2/stat.2:371
msgid "These system calls conform to SVr4, 4.3BSD, POSIX.1-2001."
msgstr ""
"これらのシステムコールは SVr4, 4.3BSD, POSIX.1-2001 に準拠している。 B<stat>"
"()  と B<fstat>()  コールは SVr4, SVID, POSIX, X/OPEN, 4.3BSD に準拠してい"
"る。 B<lstat>()  コールは 4.3BSD と SVr4 に準拠している。"

#. type: Plain text
#: build/C/man2/stat.2:385
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file-type component of the "
"I<st_mode> field of the I<stat> structure.  POSIX.-2008 tightens the "
"specification, requiring B<lstat>()  to return valid information in all "
"fields except the permission bits in I<st_mode>."
msgstr ""
"POSIX.1-2001 では、シンボリックリンクに対する B<lstat>() で\n"
"有効な情報を返すように求められていたのは、 I<stat> 構造体の I<st_size>\n"
"と I<st_mode> のファイル種別要素だけであった。\n"
"POSIX.1-2008 では規定が厳しくなり、 B<lstat>() は I<st_mode> の\n"
"アクセス許可ビット以外の全てのフィールドに有効な情報を返すことが\n"
"求められるようになっている。"

#. type: Plain text
#: build/C/man2/stat.2:405
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)  If you need "
"to obtain the definition of the I<blkcnt_t> or I<blksize_t> types from "
"I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the value 500 or "
"greater (before including I<any> header files)."
msgstr ""
"I<st_blocks> と I<st_blksize> フィールドの使用はあまり移植性がない\n"
"(これらのフィールドは BSD によって導入された。 システムごとに解釈が\n"
"異なっており、 NFS マウントの場合には同じシステムでも異なる可能性がある)。\n"
"I<E<lt>sys/stat.hE<gt>> から I<blkcnt_t> の I<blksize_t> 型定義を\n"
"読み込みたい場合は、(I<どの>ヘッダファイルをインクルードするよりも前に)\n"
"B<_XOPEN_SOURCE> を 500 以上の値で定義すること。"

#. type: Plain text
#: build/C/man2/stat.2:423
msgid ""
"POSIX.1-1990 did not describe the B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, "
"B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> "
"constants, but instead demanded the use of the macros B<S_ISDIR>(), etc.  "
"The B<S_IF*> constants are present in POSIX.1-2001 and later."
msgstr ""
"POSIX.1-1990 には B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, B<S_IFREG>,\n"
"B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> 定数に関する\n"
"記述はなかったが、代わりに B<S_ISDIR>() のようなマクロを使用するように\n"
"要求していた。 B<S_IF*> 定数は POSIX.1-2001 以降には存在する。"

#. type: Plain text
#: build/C/man2/stat.2:431
msgid ""
"The B<S_ISLNK>()  and B<S_ISSOCK>()  macros are not in POSIX.1-1996, but "
"both are present in POSIX.1-2001; the former is from SVID 4, the latter from "
"SUSv2."
msgstr ""
"マクロ B<S_ISLNK>() と B<S_ISSOCK>() は POSIX.1-1996 にはないが、\n"
"POSIX.1-2001 には両方とも存在する。 前者は SVID 4 に、後者は SUSv2 に\n"
"由来している。"

#. type: Plain text
#: build/C/man2/stat.2:441
msgid ""
"UNIX V7 (and later systems) had B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC>, where "
"POSIX prescribes the synonyms B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR>."
msgstr ""
"UNIX V7 (とその後のシステム) は B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC> を持って"
"おり、\n"
"POSIX はその同義語として B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR> を規定している。"

#. type: SS
#: build/C/man2/stat.2:441
#, no-wrap
msgid "Other systems"
msgstr "他のシステム"

#. type: Plain text
#: build/C/man2/stat.2:443
msgid "Values that have been (or are) in use on various systems:"
msgstr "各種システムで使用されていた(いる)値:"

#. type: tbl table
#: build/C/man2/stat.2:446
#, no-wrap
msgid "hex\tname\tls\toctal\tdescription\n"
msgstr "16進\t名前\tls\t8進数\t説明\n"

#. type: tbl table
#: build/C/man2/stat.2:447
#, no-wrap
msgid "f000\tS_IFMT\t\t170000\tmask for file type\n"
msgstr "f000\tS_IFMT\t\t170000\tファイル種別フィールドのビットマスク\n"

#. type: tbl table
#: build/C/man2/stat.2:448
#, no-wrap
msgid "0000\t\t\t000000\tT{\n"
msgstr "0000\t\t\t000000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:449
#, no-wrap
msgid "SCO out-of-service inode; BSD unknown type; SVID-v2 and XPG2\n"
msgstr "SCO では 使用不能 inode; BSD では不明なファイル種別;\n"

#. type: tbl table
#: build/C/man2/stat.2:450
#, no-wrap
msgid "have both 0 and 0100000 for ordinary file\n"
msgstr "SVID-v2 と XPG2 では 0 と 0100000 の両方が通常のファイル\n"

#. type: tbl table
#: build/C/man2/stat.2:451 build/C/man2/stat.2:459 build/C/man2/stat.2:470
#: build/C/man2/stat.2:482 build/C/man2/stat.2:487 build/C/man2/stat.2:490
#: build/C/man2/stat.2:494
#, no-wrap
msgid "T}\n"
msgstr "T}\n"

#. type: tbl table
#: build/C/man2/stat.2:452
#, no-wrap
msgid "1000\tS_IFIFO\tp|\t010000\tFIFO (named pipe)\n"
msgstr "1000\tS_IFIFO\tp|\t010000\tFIFO (名前付きパイプ)\n"

#. type: tbl table
#: build/C/man2/stat.2:453
#, no-wrap
msgid "2000\tS_IFCHR\tc\t020000\tcharacter special (V7)\n"
msgstr "2000\tS_IFCHR\tc\t020000\tキャラクタ特殊ファイル (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:454
#, no-wrap
msgid "3000\tS_IFMPC\t\t030000\tmultiplexed character special (V7)\n"
msgstr "3000\tS_IFMPC\t\t030000\t多重化されたキャラクタ特殊ファイル (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:455
#, no-wrap
msgid "4000\tS_IFDIR\td/\t040000\tdirectory (V7)\n"
msgstr "4000\tS_IFDIR\td/\t040000\tディレクトリ (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:456
#, no-wrap
msgid "5000\tS_IFNAM\t\t050000\tT{\n"
msgstr "5000\tS_IFNAM\t\t050000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:457
#, no-wrap
msgid "XENIX named special file with two subtypes, distinguished by\n"
msgstr "XENIX の二つの副型を持つ名前付きの特殊ファイル\n"

#. type: tbl table
#: build/C/man2/stat.2:458
#, no-wrap
msgid "I<st_rdev> values 1, 2\n"
msgstr "副型は I<st_rdev> の値 1, 2 で区別される\n"

#. type: tbl table
#: build/C/man2/stat.2:460
#, no-wrap
msgid "0001\tS_INSEM\ts\t000001\tXENIX semaphore subtype of IFNAM\n"
msgstr "0001\tS_INSEM\ts\t000001\tXENIX の IFNAM セマフォ副型\n"

#. type: tbl table
#: build/C/man2/stat.2:461
#, no-wrap
msgid "0002\tS_INSHD\tm\t000002\tXENIX shared data subtype of IFNAM\n"
msgstr "0002\tS_INSHD\tm\t000002\tXENIX の IFNAM 共有データ副型\n"

#. type: tbl table
#: build/C/man2/stat.2:462
#, no-wrap
msgid "6000\tS_IFBLK\tb\t060000\tblock special (V7)\n"
msgstr "6000\tS_IFBLK\tb\t060000\tブロック特殊ファイル (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:463
#, no-wrap
msgid "7000\tS_IFMPB\t\t070000\tmultiplexed block special (V7)\n"
msgstr "7000\tS_IFMPB\t\t070000\t多重化されたブロック特殊ファイル (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:464
#, no-wrap
msgid "8000\tS_IFREG\t-\t100000\tregular (V7)\n"
msgstr "8000\tS_IFREG\t-\t100000\t通常ファイル (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:465
#, no-wrap
msgid "9000\tS_IFCMP\t\t110000\tVxFS compressed\n"
msgstr "9000\tS_IFCMP\t\t110000\tVxFS 圧縮ファイル\n"

#. type: tbl table
#: build/C/man2/stat.2:466
#, no-wrap
msgid "9000\tS_IFNWK\tn\t110000\tnetwork special (HP-UX)\n"
msgstr "9000\tS_IFNWK\tn\t110000\tネットワーク特殊ファイル (HP-UX)\n"

#. type: tbl table
#: build/C/man2/stat.2:467
#, no-wrap
msgid "a000\tS_IFLNK\tl@\t120000\tsymbolic link (BSD)\n"
msgstr "a000\tS_IFLNK\tl@\t120000\tシンボリックリンク (BSD)\n"

#. type: tbl table
#: build/C/man2/stat.2:468
#, no-wrap
msgid "b000\tS_IFSHAD\t\t130000\tT{\n"
msgstr "b000\tS_IFSHAD\t\t130000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:469
#, no-wrap
msgid "Solaris shadow inode for ACL (not seen by user space)\n"
msgstr "Solaris の ACL 用の隠し inode (ユーザ空間からは見えない)\n"

#. type: tbl table
#: build/C/man2/stat.2:471
#, no-wrap
msgid "c000\tS_IFSOCK\ts=\t140000\tsocket (BSD; also \"S_IFSOC\" on VxFS)\n"
msgstr "c000\tS_IFSOCK\ts=\t140000\tソケット (BSD; VxFS の \"S_IFSOC\")\n"

#. type: tbl table
#: build/C/man2/stat.2:472
#, no-wrap
msgid "d000\tS_IFDOOR\tDE<gt>\t150000\tSolaris door\n"
msgstr "d000\tS_IFDOOR\tDE<gt>\t150000\tSolaris の door ファイル\n"

#. type: tbl table
#: build/C/man2/stat.2:473
#, no-wrap
msgid "e000\tS_IFWHT\tw%\t160000\tBSD whiteout (not used for inode)\n"
msgstr "e000\tS_IFWHT\tw%\t160000\tBSD の空白ファイル (inode を使用しない)\n"

#. type: tbl table
#: build/C/man2/stat.2:474
#, no-wrap
msgid "0200\tS_ISVTX\t\t001000\tT{\n"
msgstr "0200\tS_ISVTX\t\t001000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:475
#, no-wrap
msgid "sticky bit: save swapped text even after use (V7)\n"
msgstr "スティッキービット: 使用後もスワップに残す (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:476 build/C/man2/stat.2:478 build/C/man2/stat.2:480
#: build/C/man2/stat.2:485
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man2/stat.2:477
#, no-wrap
msgid "reserved (SVID-v2)\n"
msgstr "予約 (SVID-v2)\n"

#. type: tbl table
#: build/C/man2/stat.2:479
#, no-wrap
msgid "On nondirectories: don't cache this file (SunOS)\n"
msgstr "ディレクトリ以外: ファイルをキャッシュしない (SunOS)\n"

#. type: tbl table
#: build/C/man2/stat.2:481
#, no-wrap
msgid "On directories: restricted deletion flag (SVID-v4.2)\n"
msgstr "ディレクトリの場合: 削除制限フラグ (SVID-v4.2)\n"

#. type: tbl table
#: build/C/man2/stat.2:483
#, no-wrap
msgid "0400\tS_ISGID\t\t002000\tT{\n"
msgstr "0400\tS_ISGID\t\t002000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:484
#, no-wrap
msgid "set-group-ID on execution (V7)\n"
msgstr "実行時の set-group-ID (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:486
#, no-wrap
msgid "for directories: use BSD semantics for propagation of GID\n"
msgstr "ディレクトリの場合: GID の伝搬に BSD 方式を使用する\n"

#. type: tbl table
#: build/C/man2/stat.2:488
#, no-wrap
msgid "0400\tS_ENFMT\t\t002000\tT{\n"
msgstr "0400\tS_ENFMT\t\t002000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:489
#, no-wrap
msgid "System V file locking enforcement (shared with S_ISGID)\n"
msgstr "System V ファイルロックを強制する (S_ISGID と共有)\n"

#. type: tbl table
#: build/C/man2/stat.2:491
#, no-wrap
msgid "0800\tS_ISUID\t\t004000\tset-user-ID on execution (V7)\n"
msgstr "0800\tS_ISUID\t\t004000\t実行時の set-user-ID (V7)\n"

#. type: tbl table
#: build/C/man2/stat.2:492
#, no-wrap
msgid "0800\tS_CDF\t\t004000\tT{\n"
msgstr "0800\tS_CDF\t\t004000\tT{\n"

#. type: tbl table
#: build/C/man2/stat.2:493
#, no-wrap
msgid "directory is a context dependent file (HP-UX)\n"
msgstr "ディレクトリがコンテキスト依存ファイル (HP-UX)\n"

#. type: Plain text
#: build/C/man2/stat.2:499
msgid "A sticky command appeared in Version 32V AT&T UNIX."
msgstr "スティッキー コマンドは Version 32V AT&T UNIX で登場した。"

#.  As at kernel 2.6.25, XFS and JFS support nanosecond timestamps,
#.  but ext2, ext3, and Reiserfs do not.
#. type: Plain text
#: build/C/man2/stat.2:523
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  Glibc exposes the nanosecond component "
"of each field using names of the form I<st_atim.tv_nsec> if the "
"B<_BSD_SOURCE> or B<_SVID_SOURCE> feature test macro is defined.  These "
"fields are specified in POSIX.1-2008, and, starting with version 2.12, glibc "
"also exposes these field names if B<_POSIX_C_SOURCE> is defined with the "
"value 200809L or greater, or B<_XOPEN_SOURCE> is defined with the value 700 "
"or greater.  If none of the aforementioned macros are defined, then the "
"nanosecond values are exposed with names of the form I<st_atimensec>.  On "
"file systems that do not support subsecond timestamps, the nanosecond fields "
"are returned with the value 0."
msgstr ""
"カーネル 2.5.48 以降では、 I<stat> 構造体は 3 つのファイルのタイムスタンプ\n"
"関連のフィールドでナノ秒単位の精度に対応している。 glibc では、機能検査\n"
"マクロ B<_BSD_SOURCE> か B<_SVID_SOURCE> が定義された場合に、各フィールドの\n"
"ナノ秒の情報を I<st_atim.tv_nsec> という形式の名前で公開する。\n"
"これらのフィールドは POSIX.1-2008 で規定されており、\n"
"バージョン 2.12 以降の glibc では、\n"
"B<_POSIX_C_SOURCE> が 200809L 以上の値で定義されるか、\n"
"B<_XOPEN_SOURCE> が 700 以上の値で定義された場合に、\n"
"これらのフィールドが公開される。\n"
"上記のマクロのいずれも定義されていない場合、ナノ秒の値は\n"
"I<st_atimensec> という形式の名前で公開される。\n"
"秒より細かいタイムスタンプをサポートしていないファイルシステムでは、\n"
"ナノ秒のフィールドは 0 に設定される。"

#. type: Plain text
#: build/C/man2/stat.2:530
msgid ""
"On Linux, B<lstat>()  will generally not trigger automounter action, whereas "
"B<stat>()  will (but see B<fstatat>(2))."
msgstr ""
"Linux では、 B<lstat>() は一般には自動マウント動作 (automounter action) の\n"
"きっかけとならないが、 B<stat>() はきっかけとなる (B<fstatat>(2) を参照)。"

#. type: Plain text
#: build/C/man2/stat.2:538
msgid ""
"For most files under the I</proc> directory, B<stat>()  does not return the "
"file size in the I<st_size> field; instead the field is returned with the "
"value 0."
msgstr ""
"I</proc> ディレクトリ以下にあるファイルのほとんどでは、 B<stat>()  を呼び出し"
"た際に、 I<st_size> フィールドにファイルサイズが返されない。 代わりに "
"I<st_size> フィールドには 0 が返される。"

#. type: SS
#: build/C/man2/stat.2:538
#, no-wrap
msgid "Underlying kernel interface"
msgstr "背後のカーネル・インタフェース"

#.  A note from Andries Brouwer, July 2007
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: build/C/man2/stat.2:590
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (new in kernel "
"2.4; slot I<__NR_stat64>).  The glibc B<stat>()  wrapper function hides "
"these details from applications, invoking the most recent version of the "
"system call provided by the kernel, and repacking the returned information "
"if required for old binaries.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr ""
"時間の経過とともに、 I<stat> 構造体のサイズが大きくなり、この影響で B<stat>"
"()  には 3つのバージョンが存在する: I<sys_stat>()  (スロットは "
"I<__NR_oldstat>)、 I<sys_newstat>()  (スロットは I<__NR_stat>)、 "
"I<sys_stat64>()  (カーネル 2.4 で導入; スロットは I<__NR_stat64>).  glibc の "
"B<stat>()  ラッパー関数はこれらの詳細をアプリケーションから隠蔽してくれる。 "
"具体的には、カーネルが提供しているシステムコールのうち最新のバージョンを 起動"
"し、古いバイナリの場合には必要に応じて返された情報を再構成 (repack) する。 "
"B<fstat>()  と B<lstat>()  についても同様である。"

#. type: Plain text
#: build/C/man2/stat.2:596
msgid ""
"The following program calls B<stat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr ""
"以下のプログラムは B<stat>()  を呼び出し、返ってきた I<stat> 構造体のフィール"
"ドのいくつかを表示する。"

#. type: Plain text
#: build/C/man2/stat.2:603
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man2/stat.2:608
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"

#. type: Plain text
#: build/C/man2/stat.2:613
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/stat.2:618
#, no-wrap
msgid ""
"    if (stat(argv[1], &sb) == -1) {\n"
"        perror(\"stat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (stat(argv[1], &sb) == -1) {\n"
"        perror(\"stat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/stat.2:620
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr "    printf(\"File type:                \");\n"

#. type: Plain text
#: build/C/man2/stat.2:631
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/stat.2:633
#, no-wrap
msgid "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"
msgstr "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"

#. type: Plain text
#: build/C/man2/stat.2:636
#, no-wrap
msgid ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"
msgstr ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"

#. type: Plain text
#: build/C/man2/stat.2:640
#, no-wrap
msgid ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"
msgstr ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"

#. type: Plain text
#: build/C/man2/stat.2:647
#, no-wrap
msgid ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"
msgstr ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"

#. type: Plain text
#: build/C/man2/stat.2:651
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"

#. type: Plain text
#: build/C/man2/stat.2:664
msgid ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<fstatat>(2), B<readlink>(2), "
"B<utime>(2), B<capabilities>(7), B<symlink>(7)"
msgstr ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<fstatat>(2), B<readlink>(2), "
"B<utime>(2), B<capabilities>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr "STATFS"

#. type: TH
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "2010-11-21"
msgstr "2010-11-21"

#. type: Plain text
#: build/C/man2/statfs.2:31
msgid "statfs, fstatfs - get file system statistics"
msgstr "statfs, fstatfs - ファイルシステムの統計を取得する"

#. type: Plain text
#: build/C/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr "B<#include E<lt>sys/vfs.hE<gt> >/* または E<lt>sys/statfs.hE<gt> */"

#. type: Plain text
#: build/C/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/statfs.2:47
msgid ""
"The function B<statfs>()  returns information about a mounted file system.  "
"I<path> is the pathname of any file within the mounted file system.  I<buf> "
"is a pointer to a I<statfs> structure defined approximately as follows:"
msgstr ""
"関数 B<statfs>()  はマウントされたファイルシステムについての情報を返す。 "
"I<path> はマウントされたファイルシステムにあるファイルのパス名である。 "
"I<buf> は I<statfs> 構造体へのポインターで、およそ以下のように定義される:"

#. type: Plain text
#: build/C/man2/statfs.2:55
#, no-wrap
msgid ""
"#if __WORDSIZE == 32\t\t/* System word size */\n"
"# define __SWORD_TYPE           int\n"
"#else /* __WORDSIZE == 64 */\n"
"# define __SWORD_TYPE\t\tlong int\n"
"#endif\n"
msgstr ""
"#if __WORDSIZE == 32\t\t/* システムのワードサイズ */\n"
"# define __SWORD_TYPE           int\n"
"#else /* __WORDSIZE == 64 */\n"
"# define __SWORD_TYPE\t\tlong int\n"
"#endif\n"

#. type: Plain text
#: build/C/man2/statfs.2:70
#, no-wrap
msgid ""
"struct statfs {\n"
"    __SWORD_TYPE f_type;    /* type of file system (see below) */\n"
"    __SWORD_TYPE f_bsize;   /* optimal transfer block size */\n"
"    fsblkcnt_t   f_blocks;  /* total data blocks in file system */\n"
"    fsblkcnt_t   f_bfree;   /* free blocks in fs */\n"
"    fsblkcnt_t   f_bavail;  /* free blocks available to\n"
"                               unprivileged user */\n"
"    fsfilcnt_t   f_files;   /* total file nodes in file system */\n"
"    fsfilcnt_t   f_ffree;   /* free file nodes in fs */\n"
"    fsid_t       f_fsid;    /* file system id */\n"
"    __SWORD_TYPE f_namelen; /* maximum length of filenames */\n"
"    __SWORD_TYPE f_frsize;  /* fragment size (since Linux 2.6) */\n"
"    __SWORD_TYPE f_spare[5];\n"
"};\n"
msgstr ""
"struct statfs {\n"
"    __SWORD_TYPE f_type;    /* ファイルシステムの種別 (下記参照) */\n"
"    __SWORD_TYPE f_bsize;   /* 最適な転送ブロックサイズ */\n"
"    fsblkcnt_t   f_blocks;  /* ファイルシステムの総データブロック数 */\n"
"    fsblkcnt_t   f_bfree;   /* ファイルシステムの空きブロック数 */\n"
"    fsblkcnt_t   f_bavail;  /* 非特権ユーザが利用可能な空きブロック数 */\n"
"    fsfilcnt_t   f_files;   /* ファイルシステムの総ファイルノード数 */\n"
"    fsfilcnt_t   f_ffree;   /* ファイルシステムの空きファイルノード数 */\n"
"    fsid_t       f_fsid;    /* ファイルシステムの ID */\n"
"    __SWORD_TYPE f_namelen; /* ファイル名の最大長 */\n"
"    __SWORD_TYPE f_frsize;  /* フラグメントサイズ (Linux 2.6 以降) */\n"
"    __SWORD_TYPE f_spare[5];\n"
"};\n"

#. type: Plain text
#: build/C/man2/statfs.2:72
#, no-wrap
msgid "File system types:\n"
msgstr "ファイルシステムの型:\n"

#. type: Plain text
#: build/C/man2/statfs.2:118
#, no-wrap
msgid ""
"   ADFS_SUPER_MAGIC      0xadf5\n"
"   AFFS_SUPER_MAGIC      0xADFF\n"
"   BEFS_SUPER_MAGIC      0x42465331\n"
"   BFS_MAGIC             0x1BADFACE\n"
"   CIFS_MAGIC_NUMBER     0xFF534D42\n"
"   CODA_SUPER_MAGIC      0x73757245\n"
"   COH_SUPER_MAGIC       0x012FF7B7\n"
"   CRAMFS_MAGIC          0x28cd3d45\n"
"   DEVFS_SUPER_MAGIC     0x1373\n"
"   EFS_SUPER_MAGIC       0x00414A53\n"
"   EXT_SUPER_MAGIC       0x137D\n"
"   EXT2_OLD_SUPER_MAGIC  0xEF51\n"
"   EXT2_SUPER_MAGIC      0xEF53\n"
"   EXT3_SUPER_MAGIC      0xEF53\n"
"   EXT4_SUPER_MAGIC      0xEF53\n"
"   HFS_SUPER_MAGIC       0x4244\n"
"   HPFS_SUPER_MAGIC      0xF995E849\n"
"   HUGETLBFS_MAGIC       0x958458f6\n"
"   ISOFS_SUPER_MAGIC     0x9660\n"
"   JFFS2_SUPER_MAGIC     0x72b6\n"
"   JFS_SUPER_MAGIC       0x3153464a\n"
"   MINIX_SUPER_MAGIC     0x137F /* orig. minix */\n"
"   MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */\n"
"   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */\n"
"   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */\n"
"   MSDOS_SUPER_MAGIC     0x4d44\n"
"   NCP_SUPER_MAGIC       0x564c\n"
"   NFS_SUPER_MAGIC       0x6969\n"
"   NTFS_SB_MAGIC         0x5346544e\n"
"   OPENPROM_SUPER_MAGIC  0x9fa1\n"
"   PROC_SUPER_MAGIC      0x9fa0\n"
"   QNX4_SUPER_MAGIC      0x002f\n"
"   REISERFS_SUPER_MAGIC  0x52654973\n"
"   ROMFS_MAGIC           0x7275\n"
"   SMB_SUPER_MAGIC       0x517B\n"
"   SYSV2_SUPER_MAGIC     0x012FF7B6\n"
"   SYSV4_SUPER_MAGIC     0x012FF7B5\n"
"   TMPFS_MAGIC           0x01021994\n"
"   UDF_SUPER_MAGIC       0x15013346\n"
"   UFS_MAGIC             0x00011954\n"
"   USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"   VXFS_SUPER_MAGIC      0xa501FCF5\n"
"   XENIX_SUPER_MAGIC     0x012FF7B4\n"
"   XFS_SUPER_MAGIC       0x58465342\n"
"   _XIAFS_SUPER_MAGIC    0x012FD16D\n"
msgstr ""
"   ADFS_SUPER_MAGIC      0xadf5\n"
"   AFFS_SUPER_MAGIC      0xADFF\n"
"   BEFS_SUPER_MAGIC      0x42465331\n"
"   BFS_MAGIC             0x1BADFACE\n"
"   CIFS_MAGIC_NUMBER     0xFF534D42\n"
"   CODA_SUPER_MAGIC      0x73757245\n"
"   COH_SUPER_MAGIC       0x012FF7B7\n"
"   CRAMFS_MAGIC          0x28cd3d45\n"
"   DEVFS_SUPER_MAGIC     0x1373\n"
"   EFS_SUPER_MAGIC       0x00414A53\n"
"   EXT_SUPER_MAGIC       0x137D\n"
"   EXT2_OLD_SUPER_MAGIC  0xEF51\n"
"   EXT2_SUPER_MAGIC      0xEF53\n"
"   EXT3_SUPER_MAGIC      0xEF53\n"
"   EXT4_SUPER_MAGIC      0xEF53\n"
"   HFS_SUPER_MAGIC       0x4244\n"
"   HPFS_SUPER_MAGIC      0xF995E849\n"
"   HUGETLBFS_MAGIC       0x958458f6\n"
"   ISOFS_SUPER_MAGIC     0x9660\n"
"   JFFS2_SUPER_MAGIC     0x72b6\n"
"   JFS_SUPER_MAGIC       0x3153464a\n"
"   MINIX_SUPER_MAGIC     0x137F /* オリジナルの minix */\n"
"   MINIX_SUPER_MAGIC2    0x138F /* 30 文字ファイル名の minix */\n"
"   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */\n"
"   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 文字ファイル名 */\n"
"   MSDOS_SUPER_MAGIC     0x4d44\n"
"   NCP_SUPER_MAGIC       0x564c\n"
"   NFS_SUPER_MAGIC       0x6969\n"
"   NTFS_SB_MAGIC         0x5346544e\n"
"   OPENPROM_SUPER_MAGIC  0x9fa1\n"
"   PROC_SUPER_MAGIC      0x9fa0\n"
"   QNX4_SUPER_MAGIC      0x002f\n"
"   REISERFS_SUPER_MAGIC  0x52654973\n"
"   ROMFS_MAGIC           0x7275\n"
"   SMB_SUPER_MAGIC       0x517B\n"
"   SYSV2_SUPER_MAGIC     0x012FF7B6\n"
"   SYSV4_SUPER_MAGIC     0x012FF7B5\n"
"   TMPFS_MAGIC           0x01021994\n"
"   UDF_SUPER_MAGIC       0x15013346\n"
"   UFS_MAGIC             0x00011954\n"
"   USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"   VXFS_SUPER_MAGIC      0xa501FCF5\n"
"   XENIX_SUPER_MAGIC     0x012FF7B4\n"
"   XFS_SUPER_MAGIC       0x58465342\n"
"   _XIAFS_SUPER_MAGIC    0x012FD16D\n"

#. type: Plain text
#: build/C/man2/statfs.2:124
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr ""
"I<f_fsid> にどんな値が入るべきなのかは誰も知らない (但し、下記を参照)。"

#. type: Plain text
#: build/C/man2/statfs.2:129
msgid ""
"Fields that are undefined for a particular file system are set to 0.  "
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""
"それぞれのファイルシステムにおいて未定義のフィールドには 0 が 設定される。 "
"B<fstatfs>()  はディスクリプター I<fd> によって参照されるオープンされたファイ"
"ルについて、同じ情報を返す。"

#. type: Plain text
#: build/C/man2/statfs.2:142
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statfs>()  の場合)  I<path> のディレクトリ部分に検索許可が与えられていな"
"い (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/statfs.2:147
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr ""
"(B<fstatfs>()  の場合)  I<fd> は有効なオープンされたファイルディスクリプター"
"ではない。"

#. type: Plain text
#: build/C/man2/statfs.2:153
msgid "I<buf> or I<path> points to an invalid address."
msgstr "I<buf> または I<path> が不正なアドレスを指している。"

#. type: Plain text
#: build/C/man2/statfs.2:156 build/C/man3/statvfs.3:123
msgid "This call was interrupted by a signal."
msgstr "この呼び出しがシグナルで中断された。"

#. type: TP
#: build/C/man2/statfs.2:156 build/C/man3/statvfs.3:123
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/statfs.2:159 build/C/man3/statvfs.3:126
msgid "An I/O error occurred while reading from the file system."
msgstr "ファイルシステムからの読み込みの間に I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/statfs.2:164
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""
"(B<statfs>()  の場合)  I<path> を解決するのに辿るべきシンボリックリンクが多す"
"ぎる。"

#. type: Plain text
#: build/C/man2/statfs.2:169
msgid "(B<statfs>())  I<path> is too long."
msgstr "(B<statfs>()  の場合)  I<path> が長過ぎる。"

#. type: Plain text
#: build/C/man2/statfs.2:175
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr ""
"(B<statfs>()  の場合)  I<path> によって参照されるファイルが存在しない。"

#. type: Plain text
#: build/C/man2/statfs.2:178 build/C/man3/statvfs.3:145
msgid "Insufficient kernel memory was available."
msgstr "十分なカーネルメモリがない。"

#. type: Plain text
#: build/C/man2/statfs.2:181 build/C/man3/statvfs.3:148
msgid "The file system does not support this call."
msgstr "ファイルシステムがこの呼び出しをサポートしていない。"

#. type: Plain text
#: build/C/man2/statfs.2:187
msgid ""
"(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""
"(B<statfs>()  の場合)  I<path> のディレクトリ部分がディレクトリでない。"

#. type: Plain text
#: build/C/man2/statfs.2:190 build/C/man3/statvfs.3:157
msgid "Some values were too large to be represented in the returned struct."
msgstr "いくつかの値が大き過ぎて、返り値の構造体で表現できない。"

#. type: Plain text
#: build/C/man2/statfs.2:196
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr ""
"Linux 固有である。 Linux の B<statfs>()  は 4.4BSD のものに影響を受けてい"
"る。 (しかし同じ構造体を使用しているわけではない)"

#. type: Plain text
#: build/C/man2/statfs.2:218
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased, "
"to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr ""
"元々の Linux の B<statfs>() と B<fstatfs>() システムコールは\n"
"非常に大きなファイルサイズを念頭に入れて設計されていなかった。\n"
"その後、Linux 2.6 で、新しい構造体 I<statfs64> を使用する\n"
"新しいシステムコール B<statfs64>() と B<fstatfs64>() が追加された。\n"
"新しい構造体は元の I<statfs> 構造体と同じフィールドを持つが、\n"
"いろいろなフィールドのサイズが大きなファイルサイズに対応できるように\n"
"増やされている。 glibc の B<statfs>() と B<fstatfs>() のラッパー関数は\n"
"カーネルによるこれらの違いを吸収している。"

#. type: Plain text
#: build/C/man2/statfs.2:223
msgid ""
"Some systems only have I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr ""
"I<E<lt>sys/vfs.hE<gt>> しか持たないシステムもあり、 I<E<lt>sys/statfs."
"hE<gt>> も持っているシステムもある。 前者は後者をインクルードするので、 前者"
"をインクルードするのが良いと考えられる。"

#. type: Plain text
#: build/C/man2/statfs.2:233
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr ""
"LSB ではライブラリコール B<statfs>(), B<fstatfs>()  を非推奨として、代わりに "
"B<statvfs>(2), B<fstatvfs>(2)  を使うように指示している。"

#. type: SS
#: build/C/man2/statfs.2:233
#, no-wrap
msgid "The f_fsid field"
msgstr "f_fsid フィールド"

#. type: Plain text
#: build/C/man2/statfs.2:258
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in I<E<lt>sys/vfs."
"hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> is defined as "
"I<struct { int val[2]; }>.  The same holds for FreeBSD, except that it uses "
"the include file I<E<lt>sys/mount.hE<gt>>."
msgstr ""
"Solaris, Irix, POSIX にはシステムコール B<statvfs>(2)  があり、 I<struct "
"statvfs> を返す (I<E<lt>sys/statvfs.hE<gt>> で定義されている)。 この構造体に"
"は、 I<unsigned long> I<f_fsid> が含まれている。 Linux, SunOS, HP-UX, 4.4BSD "
"にはシステムコール B<statfs>()  があり、 I<struct statfs> を返す (I<E<lt>sys/"
"vfs.hE<gt>> で定義されている)。 この構造体には I<fsid_t> I<f_fsid>, が含まれ"
"ており、 I<fsid_t> は I<struct { int val[2]; }> と定義されている。 FreeBSD で"
"も同じであるが、インクルードファイル I<E<lt>sys/mount.hE<gt>> を使う。"

#. type: Plain text
#: build/C/man2/statfs.2:271
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems "
"use (a variation on) the device number, or the device number combined with "
"the file-system type.  Several OSes restrict giving out the I<f_fsid> field "
"to the superuser only (and zero it for unprivileged users), because this "
"field is used in the filehandle of the file system when NFS-exported, and "
"giving it out is a security concern."
msgstr ""
"I<f_fsid> はあるランダムな値を持ち、 (I<f_fsid>,I<ino>)  という 1 組の値で"
"ファイルを一意に決定できるようにする、 というのが基本的な考え方である。 いく"
"つかの OS では、デバイス番号 (の変種) を使ったり、 デバイス番号とファイルシス"
"テムタイプを組み合わせて使ったりしている。 OS の中には I<f_fsid> フィールドの"
"取得をスーパーユーザに限定しているものもある (非特権ユーザが取得すると 0 とな"
"る)。 NFS でエクスポートされる場合、 このフィールドがファイルシステムのファイ"
"ルハンドルで使われており、 この値を提供するとセキュリティ上の問題がある。"

#. type: Plain text
#: build/C/man2/statfs.2:277
msgid ""
"Under some operating systems the I<fsid> can be used as second argument to "
"the B<sysfs>(2)  system call."
msgstr ""
"いくつかの OS では、 I<fsid> を B<sysfs>(2)  システムコールの第 2 引き数とし"
"て使用できる。"

#. type: Plain text
#: build/C/man2/statfs.2:281
msgid "B<stat>(2), B<statvfs>(2), B<path_resolution>(7)"
msgstr "B<stat>(2), B<statvfs>(2), B<path_resolution>(7)"

#. type: TH
#: build/C/man3/statvfs.3:30
#, no-wrap
msgid "STATVFS"
msgstr "STATVFS"

#. type: TH
#: build/C/man3/statvfs.3:30
#, no-wrap
msgid "2003-08-22"
msgstr "2003-08-22"

#. type: Plain text
#: build/C/man3/statvfs.3:33
msgid "statvfs, fstatvfs - get file system statistics"
msgstr "statvfs, fstatvfs - ファイルシステムの統計を取得する"

#. type: Plain text
#: build/C/man3/statvfs.3:35
msgid "B<#include E<lt>sys/statvfs.hE<gt>>"
msgstr "B<#include E<lt>sys/statvfs.hE<gt>>"

#. type: Plain text
#: build/C/man3/statvfs.3:37
msgid "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man3/statvfs.3:39
msgid "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"
msgstr "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"

#. type: Plain text
#: build/C/man3/statvfs.3:49
msgid ""
"The function B<statvfs>()  returns information about a mounted file system.  "
"I<path> is the pathname of any file within the mounted file system.  I<buf> "
"is a pointer to a I<statvfs> structure defined approximately as follows:"
msgstr ""
"関数 B<statvfs>()  はマウントされたファイルシステムについての情報を返す。 "
"I<path> はマウントされたファイルシステム中の任意のファイルのパス名である。 "
"I<buf> は、だいたい以下のように定義されている I<statvfs> 構造体へのポインタで"
"ある:"

#. type: Plain text
#: build/C/man3/statvfs.3:65
#, no-wrap
msgid ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* file system block size */\n"
"    unsigned long  f_frsize;   /* fragment size */\n"
"    fsblkcnt_t     f_blocks;   /* size of fs in f_frsize units */\n"
"    fsblkcnt_t     f_bfree;    /* # free blocks */\n"
"    fsblkcnt_t     f_bavail;   /* # free blocks for unprivileged users */\n"
"    fsfilcnt_t     f_files;    /* # inodes */\n"
"    fsfilcnt_t     f_ffree;    /* # free inodes */\n"
"    fsfilcnt_t     f_favail;   /* # free inodes for unprivileged users */\n"
"    unsigned long  f_fsid;     /* file system ID */\n"
"    unsigned long  f_flag;     /* mount flags */\n"
"    unsigned long  f_namemax;  /* maximum filename length */\n"
"};\n"
msgstr ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* ファイルシステムのブロックサイズ */\n"
"    unsigned long  f_frsize;   /* フラグメントサイズ */\n"
"    fsblkcnt_t     f_blocks;   /* ファイルシステムのサイズ (f_frsize 単位) */\n"
"    fsblkcnt_t     f_bfree;    /* 解放されているブロック数 */\n"
"    fsblkcnt_t     f_bafvail;   /* 非特権ユーザ用に解放されているブロック数 */\n"
"    fsfilcnt_t     f_files;    /* inode 数 */\n"
"    fsfilcnt_t     f_ffree;    /* 解放されている inode の数 */\n"
"    fsfilcnt_t     f_favail;   /* 非特権ユーザ用に解放されている inode の数 */\n"
"    unsigned long  f_fsid;     /* ファイルシステム ID */\n"
"    unsigned long  f_flag;     /* マウントフラグ */\n"
"    unsigned long  f_namemax;  /* ファイル名の長さの最大値 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/statvfs.3:76
msgid ""
"Here the types I<fsblkcnt_t> and I<fsfilcnt_t> are defined in I<E<lt>sys/"
"types.hE<gt>>.  Both used to be I<unsigned long>."
msgstr ""
"ここで、型 I<fsblkcnt_t> と I<fsfilcnt_t> は I<E<lt>sys/types.hE<gt>> で定義"
"されている。 かつて、これらは共に I<unsigned long> であった。"

#. type: Plain text
#: build/C/man3/statvfs.3:82
msgid ""
"The field I<f_flag> is a bit mask (of mount flags, see B<mount>(8)).  Bits "
"defined by POSIX are"
msgstr ""
"フィールド I<f_flag> は (マウントフラグの) ビットマスクである (マウントフラグ"
"については、 B<mount>(8)  を参照すること)。 POSIX で定義されているビットは以"
"下の通り:"

#. type: TP
#: build/C/man3/statvfs.3:82
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr "B<ST_RDONLY>"

#. type: Plain text
#: build/C/man3/statvfs.3:85
msgid "Read-only file system."
msgstr "読み込み専用のファイルシステム。"

#. type: TP
#: build/C/man3/statvfs.3:85
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr "B<ST_NOSUID>"

#. type: Plain text
#: build/C/man3/statvfs.3:89
msgid "Set-user-ID/set-group-ID bits are ignored by B<exec>(3)."
msgstr "B<exec>(3)  に無視される set-user-id/set-group-ID ビット。"

#. type: Plain text
#: build/C/man3/statvfs.3:92
msgid ""
"It is unspecified whether all members of the returned struct have meaningful "
"values on all file systems."
msgstr ""
"返された構造体の全てのメンバが全てのファイルシステムで 意味のある値であるか否"
"かは、指定されていない。"

#. type: Plain text
#: build/C/man3/statvfs.3:96
msgid ""
"B<fstatvfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""
"B<fstatvfs>()  は、ディスクリプタ I<fd> で参照されるオープンされたファイルに"
"ついて、同じ情報を返す。"

#. type: Plain text
#: build/C/man3/statvfs.3:109
msgid ""
"(B<statvfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""
"(B<statvfs>()  の場合)  I<path> のディレクトリ部分に検索許可が与えられていな"
"い (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man3/statvfs.3:114
msgid "(B<fstatvfs>())  I<fd> is not a valid open file descriptor."
msgstr ""
"(B<fstatvfs>()  の場合)  I<fd> が有効なオープンファイルディスクリプタではな"
"い。"

#. type: Plain text
#: build/C/man3/statvfs.3:120
msgid "I<Buf> or I<path> points to an invalid address."
msgstr "I<buf> または I<path> が無効なアドレスを指している。"

#. type: Plain text
#: build/C/man3/statvfs.3:131
msgid ""
"(B<statvfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr "(B<statvfs>()  の場合)  I<path> にシンボリックリンクが多すぎる。"

#. type: Plain text
#: build/C/man3/statvfs.3:136
msgid "(B<statvfs>())  I<path> is too long."
msgstr "(B<statvfs>()  の場合)  I<path> が長すぎる。"

#. type: Plain text
#: build/C/man3/statvfs.3:142
msgid "(B<statvfs>())  The file referred to by I<path> does not exist."
msgstr "(B<statvfs>()  の場合)  I<path> で参照されるファイルが存在しない。"

#. type: Plain text
#: build/C/man3/statvfs.3:154
msgid ""
"(B<statvfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""
"(B<statvfs>()  の場合)  I<path> のディレクトリ部分がディレクトリでない。"

#. type: Plain text
#: build/C/man3/statvfs.3:159
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/statvfs.3:165
msgid ""
"The Linux kernel has system calls B<statfs>(2)  and B<fstatfs>(2)  to "
"support this library call."
msgstr ""
"Linux カーネルには、このライブラリコールをサポートするために、 B<statfs>(2), "
"B<fstatfs>(2)  システムコールがある。"

#. type: Plain text
#: build/C/man3/statvfs.3:167
msgid "The current glibc implementations of"
msgstr "現在の glibc の実装において、"

#. type: Plain text
#: build/C/man3/statvfs.3:172
#, no-wrap
msgid ""
"   pathconf(path, _PC_REC_XFER_ALIGN);\n"
"   pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"   pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"
msgstr ""
"   pathconf(path, _PC_REC_XFER_ALIGN);\n"
"   pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"   pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"

#. type: Plain text
#: build/C/man3/statvfs.3:181
msgid ""
"respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields of the "
"return value of I<statvfs(path,buf)>."
msgstr ""
"は、それぞれ I<statvfs(path,buf)> の返り値の I<f_frsize>, I<f_frsize>, "
"I<f_bsize> フィールドを使う。"

#. type: Plain text
#: build/C/man3/statvfs.3:183
msgid "B<statfs>(2)"
msgstr "B<statfs>(2)"

#. type: TH
#: build/C/man2/sysfs.2:27
#, no-wrap
msgid "SYSFS"
msgstr "SYSFS"

#. type: TH
#: build/C/man2/sysfs.2:27
#, no-wrap
msgid "2010-06-27"
msgstr "2010-06-27"

#. type: Plain text
#: build/C/man2/sysfs.2:30
msgid "sysfs - get file system type information"
msgstr "sysfs - ファイルシステム (file system) の情報を取得する"

#. type: Plain text
#: build/C/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"

#. type: Plain text
#: build/C/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"
msgstr ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr "B<int sysfs(int >I<option>B<);>"

#. type: Plain text
#: build/C/man2/sysfs.2:45
msgid ""
"B<sysfs>()  returns information about the file system types currently "
"present in the kernel.  The specific form of the B<sysfs>()  call and the "
"information returned depends on the I<option> in effect:"
msgstr ""
"B<sysfs>()  は現在カーネル (kernel) に存在しているファイルシステムの型 "
"(type) 情報を返す。 それぞれの B<sysfs>()  コールの形式と返される情報は "
"I<option> に依存しており、それは:"

#. type: TP
#: build/C/man2/sysfs.2:45
#, no-wrap
msgid "B<1>"
msgstr "B<1>"

#. type: Plain text
#: build/C/man2/sysfs.2:50
msgid ""
"Translate the file-system identifier string I<fsname> into a file-system "
"type index."
msgstr ""
"ファイルシステム識別文字列 (identifier string)  I<fsname> をファイルシステム"
"の型インデックス (type index) に翻訳する。"

#. type: TP
#: build/C/man2/sysfs.2:50
#, no-wrap
msgid "B<2>"
msgstr "B<2>"

#. type: Plain text
#: build/C/man2/sysfs.2:61
msgid ""
"Translate the file-system type index I<fs_index> into a null-terminated file-"
"system identifier string.  This string will be written to the buffer pointed "
"to by I<buf>.  Make sure that I<buf> has enough space to accept the string."
msgstr ""
"ファイルシステムの型インデックス I<fs_index> を NULL 終端されたファイルシステ"
"ム識別文字列に翻訳する。 この文字列は I<buf> で指定されたバッファーへ書き込ま"
"れる。 I<buf> に文字列を入れるだけの十分な容量があることを確かめること。"

#. type: TP
#: build/C/man2/sysfs.2:61
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man2/sysfs.2:65
msgid ""
"Return the total number of file system types currently present in the kernel."
msgstr "現在カーネルに存在するファイルシステム型の数の合計を返す。"

#. type: Plain text
#: build/C/man2/sysfs.2:67
msgid "The numbering of the file-system type indexes begins with zero."
msgstr "ファイルシステムの型インデックスの数はゼロから始まる。"

#. type: Plain text
#: build/C/man2/sysfs.2:79
msgid ""
"On success, B<sysfs>()  returns the file-system index for option B<1>, zero "
"for option B<2>, and the number of currently configured file systems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 B<sysfs>()  は、 オプション B<1> では ファイルシステムのインデッ"
"クスを返す。 オプション B<2> ではゼロを返す。 オプション B<3> は現在設定され"
"ているファイルシステムの数を返す。 エラーの場合は、-1 が返され、 I<errno> が"
"適切に設定される。"

#. type: Plain text
#: build/C/man2/sysfs.2:84
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr "fsnameI< と >buf のどちらかがアクセス可能なアドレス空間の外にある。"

#. type: Plain text
#: build/C/man2/sysfs.2:92
msgid ""
"I<fsname> is not a valid file-system type identifier; I<fs_index> is out-of-"
"bounds; I<option> is invalid."
msgstr ""
"I<fsname> が正しいファイルシステムの型識別子ではない; I<fs_index> が範囲の外"
"にある; I<option> が正しくない。"

#.  SVr4 documents additional error conditions ENOLINK, ECOMM, and EINTR
#.  but has no ENOSYS condition.
#. type: Plain text
#: build/C/man2/sysfs.2:94 build/C/man2/ustat.2:98
msgid "SVr4."
msgstr "SVr4."

#. type: Plain text
#: build/C/man2/sysfs.2:101
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via I</proc/"
"filesystems>; use that interface instead."
msgstr ""
"この System-V 由来のシステムコールは廃止予定 (obsolete) であり、 使用しないこ"
"と。 I</proc> が利用できるシステムでは、同じ情報が I</proc/filesystems> 経由"
"で取得でき、このインタフェースを使用すること。"

#. type: SH
#: build/C/man2/sysfs.2:101
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/sysfs.2:104
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr ""
"libc または glibc のサポートは存在しない。 I<buf> の大きさがどれだけ必要かを"
"推測する方法がない。"

#. type: TH
#: build/C/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr "UMOUNT"

#. type: TH
#: build/C/man2/umount.2:30
#, no-wrap
msgid "2010-06-19"
msgstr "2010-06-19"

#. type: Plain text
#: build/C/man2/umount.2:33
msgid "umount, umount2 - unmount file system"
msgstr "umount, umount2 - ファイルシステムをアンマウントする"

#. type: Plain text
#: build/C/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr "B<int umount(const char *>I<target>B<);>\n"

#. type: Plain text
#: build/C/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: build/C/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) file "
"system mounted on I<target>."
msgstr ""
"B<umount>()  と B<umount2>()  は I<target> にマウントされている (最上位の) "
"ファイルシステムを外す。"

#. type: Plain text
#: build/C/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount file systems."
msgstr ""
"ファイルシステムのアンマウントを行うには、 適切な権限 (Linux では "
"B<CAP_SYS_ADMIN> ケーパビリティ) が必要である。"

#. type: Plain text
#: build/C/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""
"Linux 2.1.116 から、 B<umount2>()  システムコールが追加された。これは "
"B<umount>()  と同様に I<target> をアンマウントするが、 I<flags> が追加されて"
"おり、操作時の振る舞いを制御できる。"

#. type: TP
#: build/C/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr "B<MNT_FORCE> (2.1.116 以降)"

#. type: Plain text
#: build/C/man2/umount.2:67
msgid ""
"Force unmount even if busy.  This can cause data loss.  (Only for NFS "
"mounts.)"
msgstr ""
"使用中 (busy) でも強制的にアンマウントを実行する。 これを行うとデータを失う可"
"能性がある。 (NFS マウント専用)"

#. type: TP
#: build/C/man2/umount.2:67
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr "B<MNT_DETACH> (2.4.11 以降)"

#. type: Plain text
#: build/C/man2/umount.2:72
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"and actually perform the unmount when the mount point ceases to be busy."
msgstr ""
"遅延アンマウントを行う。マウントポイントに対する新規のアクセスは 不可能とな"
"り、実際のアンマウントはマウントポイントがビジーで なくなった時点で行う。"

#. type: TP
#: build/C/man2/umount.2:72
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr "B<MNT_EXPIRE> (Linux 2.6.8 以降)"

#. type: Plain text
#: build/C/man2/umount.2:91
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()  "
"call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""
"マウントポイントに期限切れの印をつける。 マウントポイントが現在使用中でない場"
"合、このフラグをつけて B<umount2>()  を初めて呼び出すと B<EAGAIN> エラーで失"
"敗するが、マウントポイントには期限切れ (expire)  の印がつけられる。 そのマウ"
"ントポイントはいずれかのプロセスがアクセスしない限り 期限切れの印がついたまま"
"となる。 もう一度 B<MNT_EXPIRE> をつけて B<umount2>()  を呼び出すと、期限切れ"
"の印のついたマウントポイントが アンマウントされる。 このフラグを "
"B<MNT_FORCE> もしくは B<MNT_DETACH> と同時に指定することはできない。"

#. type: TP
#: build/C/man2/umount.2:91
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr "B<UMOUNT_NOFOLLOW> (Linux 2.6.34 以降)"

#.  Later added to 2.6.33-stable
#. type: Plain text
#: build/C/man2/umount.2:99
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount file systems."
msgstr ""
"I<target> がシンボリックリンクの場合に、シンボリックリンクの展開を行わな"
"い。\n"
"このフラグを使うと、 I<root> に set-user-ID されたプログラムにおいて、\n"
"非特権ユーザがファイルシステムのアンマウントをできてしまうという\n"
"セキュリティ問題を回避することができる。"

#. type: Plain text
#: build/C/man2/umount.2:110
msgid ""
"The error values given below result from file-system type independent "
"errors.  Each file system type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""
"以下に示すエラーは、ファイルシステムに依存しないものである。 それぞれのファイ"
"ルシステムタイプには固有のエラーが存在する場合があり、 独自の動作をすることも"
"ある。詳しくは Linux カーネルのソースを見て欲しい。"

#. type: TP
#: build/C/man2/umount.2:110
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/umount.2:117
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy file system as expired."
msgstr ""
"B<MNT_EXPIRE> を指定した B<umount2>()  の呼び出しで、正常に未使用のファイルシ"
"ステムに期限切れの印を つけることができた。"

#. type: Plain text
#: build/C/man2/umount.2:121
msgid "I<target> could not be unmounted because it is busy."
msgstr "使用中 (busy) のため、 I<target> をアンマウントできなかった。"

#. type: Plain text
#: build/C/man2/umount.2:125
msgid "I<target> points outside the user address space."
msgstr "I<target> がユーザアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/umount.2:137
msgid ""
"I<target> is not a mount point.  Or, B<umount2>()  was called with "
"B<MNT_EXPIRE> and either B<MNT_DETACH> or B<MNT_FORCE>."
msgstr ""
"I<target> がマウントポイントではない。 または、 B<umount2>()  で、 "
"B<MNT_EXPIRE> が指定された B<umount2>()  で、 B<MNT_DETACH> か B<MNT_FORCE> "
"が同時に指定された。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: build/C/man2/umount.2:156
msgid ""
"B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""
"B<MNT_DETACH> と B<MNT_EXPIRE> はバージョン 2.11 以降の glibc で利用できる。"

#. type: Plain text
#: build/C/man2/umount.2:159
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""
"この関数は Linux 固有の関数であり、移植を考慮したプログラムでは 使用すべきで"
"ない。"

#. type: Plain text
#: build/C/man2/umount.2:170
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would "
"return B<ENOTBLK> when called with something other than a block device.  In "
"Linux 0.98p4 a call I<umount(dir)> was added, in order to support anonymous "
"devices.  In Linux 2.3.99-pre7 the call I<umount(device)> was removed, "
"leaving only I<umount(dir)> (since now devices can be mounted in more than "
"one place, so specifying the device does not suffice)."
msgstr ""
"元々の B<umount>()  関数は I<umount(device)> の形で呼び出され、 ブロックデバ"
"イス以外を指定して呼び出すと B<ENOTBLK> を返した。 Linux 0.98p4 で、無名デバ"
"イス (anonymous device) に対応するために I<umount(dir)> の形での呼び出しが加"
"えられた。 Linux 2.3.99-pre7 で、I<umount(device)> は削除され、 I<umount(dir)"
"> だけが残された (一つのデバイスを複数の位置にマウント出来るようになったた"
"め、 デバイスを指定しただけでは不十分だからである)。"

#. type: Plain text
#: build/C/man2/umount.2:175
msgid "B<mount>(2), B<path_resolution>(7), B<mount>(8), B<umount>(8)"
msgstr "B<mount>(2), B<path_resolution>(7), B<mount>(8), B<umount>(8)"

#. type: TH
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr "USTAT"

#. type: TH
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "2003-08-04"
msgstr "2003-08-04"

#. type: Plain text
#: build/C/man2/ustat.2:33
msgid "ustat - get file system statistics"
msgstr "ustat - ファイルシステム (file system) の統計を得る"

#. type: Plain text
#: build/C/man2/ustat.2:36
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/ustat.2:38
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
msgstr "B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"

#. type: Plain text
#: build/C/man2/ustat.2:40
#, no-wrap
msgid "B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr "B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"

#. type: Plain text
#: build/C/man2/ustat.2:42
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"

#. type: Plain text
#: build/C/man2/ustat.2:54
msgid ""
"B<ustat>()  returns information about a mounted file system.  I<dev> is a "
"device number identifying a device containing a mounted file system.  "
"I<ubuf> is a pointer to a I<ustat> structure that contains the following "
"members:"
msgstr ""
"B<ustat>()  はマウント (mount) されたファイルシステムの情報を返す。 I<dev> は"
"調べるファイルシステムを含んでいるデバイス (device) の デバイス番号。 "
"I<ubuf> は以下のメンバーを含む ustat 構造体へのポインター:"

#. type: Plain text
#: build/C/man2/ustat.2:61
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"

#. type: Plain text
#: build/C/man2/ustat.2:70
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will "
"always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""
"後の二つのフィールド I<f_fname> と I<f_fpack> は実装されておらず、常に NULL "
"バイト (\\(aq\\e0\\(aq) で埋められる。"

#. type: Plain text
#: build/C/man2/ustat.2:79
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合にはゼロが返され、 I<ubuf> が指す I<ustat> 構造体が埋められる。 "
"エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/ustat.2:84
msgid "I<ubuf> points outside of your accessible address space."
msgstr "I<ubuf> がアクセス可能な空間の外側を指している。"

#. type: Plain text
#: build/C/man2/ustat.2:88
msgid "I<dev> does not refer to a device containing a mounted file system."
msgstr ""
"I<dev> がマウントされたファイルシステムを含むデバイスを参照していない。"

#. type: Plain text
#: build/C/man2/ustat.2:94
msgid ""
"The mounted file system referenced by I<dev> does not support this "
"operation, or any version of Linux before 1.3.16."
msgstr ""
"I<dev> で参照されるマウントされたファイルシステムがこの操作 (operation) を サ"
"ポートしていないか、Linux のバージョンが 1.3.16 以前である。"

#. type: Plain text
#: build/C/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All "
"new programs should use B<statfs>(2)  instead."
msgstr ""
"B<ustat>()  は推奨されず、互換性のためだけに提供される。 新しいプログラムは全"
"てこれの代りに B<statfs>(2)  を使用するべきである。"

#. type: SS
#: build/C/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr "HP-UX における注意"

#.  Some software tries to use this in order to test whether the
#.  underlying file system is NFS.
#. type: Plain text
#: build/C/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some file "
"systems, the number of free inodes does not change.  Such file systems will "
"return -1 in the field I<f_tinode>.  For some file systems, inodes are "
"dynamically allocated.  Such file systems will return the current number of "
"free inodes."
msgstr ""
"HP-UX 版の構造体 I<ustat> には、その他にフィールド I<f_blksize> が存在する"
"が、他では見かけない。 HP-UX は次のように警告している: ファイルシステムの中に"
"は、解放されている inode の数を変更しないものもある。 このようなファイルシス"
"テムは、フィールド I<f_tinode> に -1 を返す。 ファイルシステムの中には、"
"inode を動的に確保するものもある。 このようなファイルシステムは、現在解放され"
"ている inode の数を返す。"

#. type: Plain text
#: build/C/man2/ustat.2:121
msgid "B<stat>(2), B<statfs>(2)"
msgstr "B<stat>(2), B<statfs>(2)"

#~ msgid "2013-01-27"
#~ msgstr "2013-01-27"

#~ msgid "2010-05-24"
#~ msgstr "2010-05-24"

#~ msgid "2007-12-28"
#~ msgstr "2007-12-28"

#~ msgid ""
#~ "If the named attribute does not exist, I<errno> is set to B<ENOATTR>."
#~ msgstr ""
#~ "指定された名前の属性が存在しない場合、 I<errno> に B<ENOATTR> がセットされ"
#~ "る。"

#~ msgid "2001-12-31"
#~ msgstr "2001-12-31"

#~ msgid ""
#~ "If B<XATTR_CREATE> is specified, and the attribute exists already, "
#~ "I<errno> is set to B<EEXIST>.  If B<XATTR_REPLACE> is specified, and the "
#~ "attribute does not exist, I<errno> is set to B<ENOATTR>."
#~ msgstr ""
#~ "B<XATTR_CREATE> が指定され、かつ属性がすでに存在する場合、 I<errno> に "
#~ "B<EEXIST> がセットされる。 B<XATTR_REPLACE> が指定され、属性がまだ存在しな"
#~ "い場合、 I<errno> に B<ENOATTR> がセットされる。"

#~ msgid "2007-11-25"
#~ msgstr "2007-11-25"

#~ msgid "2012-05-07"
#~ msgstr "2012-05-07"

#~ msgid "2011-10-04"
#~ msgstr "2011-10-04"

#~ msgid "\t\t\t\ttype; SVID-v2 and XPG2 have both\n"
#~ msgstr "\t\t\t\tBSD では未知のファイル種別;\n"

#~ msgid "\t\t\t\t(not seen by userspace)\n"
#~ msgstr "b000\tS_IFSHAD\t\t130000\tSolaris ACL のための隠された inode\n"

#~ msgid "\t\t\t\tafter use (V7)\n"
#~ msgstr "0200\tS_ISVTX\t\t001000\t`スティッキー・ビット':使用後も\n"

#~ msgid "\t\t\t\tfile (SunOS)\n"
#~ msgstr "\t\t\t\tディレクトリ以外: ファイルをキャッシュ\n"

#~ msgid "\t\t\t\tflag (SVID-v4.2)\n"
#~ msgstr "\t\t\t\tディレクトリ: 削除制限フラグ (SVID-v4.2)\n"

#~ msgid "\t\t\t\tpropagation of GID\n"
#~ msgstr "\t\t\t\tBSD 方式を使用する\n"

#~ msgid "\t\t\t\twith S_ISGID)\n"
#~ msgstr "\t\t\t\t(S_ISGID と共有)\n"

#~ msgid "\t\t\t\tfile (HP-UX)\n"
#~ msgstr "\t\t\t\t(HP-UX)\n"

#~ msgid ""
#~ "The returned file handler can only be passed to B<spu_run>(2)  or closed; "
#~ "other operations are not defined on it.  A logical SPU context is "
#~ "destroyed when its file descriptor is closed as well as all the file "
#~ "descriptors pointing to files inside it.  When an SPU context is "
#~ "destroyed all its directory entries in the SPUFS are removed."
#~ msgstr ""
#~ "返されたファイルハンドラは、 B<spu_run>(2)  に渡すか、クローズするかしかで"
#~ "きない。 他の操作は定義されていない。 論理 SPU コンテキストが破棄されるの"
#~ "は、 コンテキスト自身へのファイルディスクリプタがクローズされ、 その中の"
#~ "ファイルへのファイルディスクリプタが全てクローズされたときである。 SPU コ"
#~ "ンテキストが破棄されると、SPUFS 内のそのディレクトリの全てのエントリ が削"
#~ "除される。"

#~ msgid ""
#~ "Allow mapping of some of the hardware registers of the SPU into user "
#~ "space.  This flag requires the B<CAP_SYS_RAWIO> capability."
#~ msgstr ""
#~ "SPU のハードウェアレジスタのいくつかをユーザ空間にマッピングすることを 許"
#~ "可する。このフラグを指定するには B<CAP_SYS_RAWIO> ケーパビリティが必要であ"
#~ "る。"

#~ msgid ""
#~ "The new directory and files are created in the SPUFS with the permissions "
#~ "set by the I<mode> argument minus those set in the process's B<umask>"
#~ "(2).  The actual permissions set for each file also depend on whether the "
#~ "file supports read and/or write accesses."
#~ msgstr ""
#~ "SPUFS 内に新しく生成されたディレクトリとファイルのアクセス許可は、 "
#~ "I<mode> 引き数からそのプロセスの B<umask>(2)  を引いた値に設定される。 各"
#~ "ファイルの実際のアクセス許可は、そのファイルが読み出しアクセスや 書き込み"
#~ "アクセスをサポートしているかも考慮して決まる。"

#~ msgid ""
#~ "This call is Linux specific and only implemented by the ppc64 "
#~ "architecture.  Programs using this system call are not portable."
#~ msgstr ""
#~ "このシステムコールは Linux 固有であり、 ppc64 アーキテクチャでのみ実装され"
#~ "ている。 このシステムコールを使ったプログラムは移植性がない。"

#~ msgid "The code does not yet fully implement all features outlined here."
#~ msgstr ""
#~ "実際のコードではここで述べた全ての機能が完全に実装されているわけではない。"

#~ msgid ""
#~ "All files that support the B<read>(2)  operation also support B<readv>"
#~ "(2)  and all files that support the B<write>(2)  operation also support "
#~ "B<writev>(2)."
#~ msgstr ""
#~ "B<read>(2)  操作に対応している全てのファイルは B<readv>(2)  にも対応してい"
#~ "る。また、 B<write>(2)  操作に対応している全てのファイルは B<writev>(2)  "
#~ "にも対応している。"

#~ msgid ""
#~ "These files expose internal registers of the SPU.  The values are "
#~ "represented as ASCII strings containing the numeric value of each "
#~ "register.  These can be used in read/write mode for debugging, but normal "
#~ "operation of programs should not rely on these files because accesses to "
#~ "any of them except I<npc> require an SPU context save, which is very "
#~ "inefficient."
#~ msgstr ""
#~ "これらのファイルは SPU の内部レジスタを公開するものである。 値は、各レジス"
#~ "タの数値を含むアスキー文字列で表現される。 これらのファイルはデバッグ用と"
#~ "して読み出し/書き込みの両モードで利用できるが、 プログラムの通常の操作はこ"
#~ "れらのファイルに依存すべきではない。 なぜなら、これらのファイルのうち "
#~ "I<npc> 以外へのアクセスでは SPU コンテキストの保存が必須であり、 SPU コン"
#~ "テキストの保存は非常に効率が悪いからである。"

#~ msgid "Next Program Counter"
#~ msgstr "次のプログラムカウンタ"

#~ msgid ""
#~ "When the I<count> supplied to the B<read>(2)  call is shorter than the "
#~ "required length for the register value plus a newline character, "
#~ "subsequent reads from the same file descriptor will complete the string, "
#~ "regardless of changes to the register by a running SPU task.  When a "
#~ "complete string has been read, all subsequent read operations will return "
#~ "zero bytes and a new file descriptor needs to be opened to read a new "
#~ "value."
#~ msgstr ""
#~ "B<read>(2)  に渡された I<count> がレジスタ値と改行 (newline) 文字 1 個を格"
#~ "納するのに必要な長さより短い場合、 同じファイルディスクリプタを続けて "
#~ "read することで、文字列全体を読み出すこと ができる。この際、実行中の SPU "
#~ "タスクによりレジスタ値の変更の影響は受けない。 文字列全体が読み出される"
#~ "と、それ以降の read 操作では 0 バイトが返され、 新しい値を読み出すには新し"
#~ "いファイルディスクリプタをオープンする必要がある。"

#~ msgid "File name too long."
#~ msgstr "I<path> が長過ぎる。"

#~ msgid ""
#~ "The kernel has system calls B<statfs>(), B<fstatfs>(), B<statfs64>(), and "
#~ "B<fstatfs64>()  to support this library call."
#~ msgstr ""
#~ "このライブラリコールをサポートするため、 カーネルにはシステムコール "
#~ "B<statfs>(), B<fstatfs>(), B<statfs64>(), B<fstatfs64>()  がある。"

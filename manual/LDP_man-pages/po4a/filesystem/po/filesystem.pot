# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2015-02-04 23:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man5/filesystems.5:26
#, no-wrap
msgid "FILESYSTEMS"
msgstr ""

#. type: TH
#: build/C/man5/filesystems.5:26
#, no-wrap
msgid "2014-01-15"
msgstr ""

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:35 build/C/man2/getxattr.2:25 build/C/man3/isfdtype.3:26 build/C/man2/listxattr.2:25 build/C/man2/mount.2:40 build/C/man7/path_resolution.7:25 build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25 build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26 build/C/man7/spufs.7:27 build/C/man2/stat.2:40 build/C/man2/statfs.2:28 build/C/man3/statvfs.3:30 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man2/ustat.2:30
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man5/filesystems.5:26 build/C/man3/fts.3:40 build/C/man3/ftw.3:35 build/C/man3/getfsent.3:27 build/C/man3/getmntent.3:32 build/C/man2/getxattr.2:25 build/C/man3/isfdtype.3:26 build/C/man2/listxattr.2:25 build/C/man2/mount.2:40 build/C/man7/path_resolution.7:25 build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25 build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26 build/C/man7/spufs.7:27 build/C/man2/stat.2:40 build/C/man2/statfs.2:28 build/C/man3/statvfs.3:30 build/C/man2/sysfs.2:27 build/C/man2/umount.2:30 build/C/man2/ustat.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:28 build/C/man3/fts.3:41 build/C/man3/ftw.3:36 build/C/man3/getfsent.3:28 build/C/man3/getmntent.3:33 build/C/man2/getxattr.2:26 build/C/man3/isfdtype.3:27 build/C/man2/listxattr.2:26 build/C/man2/mount.2:41 build/C/man7/path_resolution.7:26 build/C/man2/removexattr.2:26 build/C/man2/setxattr.2:26 build/C/man2/spu_create.2:26 build/C/man2/spu_run.2:27 build/C/man7/spufs.7:28 build/C/man2/stat.2:41 build/C/man2/statfs.2:29 build/C/man3/statvfs.3:31 build/C/man2/sysfs.2:28 build/C/man2/umount.2:31 build/C/man2/ustat.2:31
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:32
msgid ""
"filesystems - Linux filesystem types: minix, ext, ext2, ext3, ext4, "
"Reiserfs, XFS, JFS, xia, msdos, umsdos, vfat, ntfs, proc, nfs, iso9660, "
"hpfs, sysv, smb, ncpfs"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:32 build/C/man3/fts.3:61 build/C/man3/ftw.3:55 build/C/man3/getfsent.3:42 build/C/man3/getmntent.3:65 build/C/man2/getxattr.2:42 build/C/man3/isfdtype.3:55 build/C/man2/listxattr.2:41 build/C/man2/mount.2:51 build/C/man7/path_resolution.7:28 build/C/man2/removexattr.2:39 build/C/man2/setxattr.2:42 build/C/man2/spu_create.2:40 build/C/man2/spu_run.2:39 build/C/man7/spufs.7:30 build/C/man2/stat.2:97 build/C/man2/statfs.2:37 build/C/man3/statvfs.3:39 build/C/man2/sysfs.2:36 build/C/man2/umount.2:41 build/C/man2/ustat.2:43
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:45
msgid ""
"When, as is customary, the B<proc> filesystem is mounted on I</proc>, you "
"can find in the file I</proc/filesystems> which filesystems your kernel "
"currently supports; see B<proc>(5)  for more details.  If you need a "
"currently unsupported filesystem, insert the corresponding module or "
"recompile the kernel."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:50
msgid "In order to use a filesystem, you have to I<mount> it; see B<mount>(8)."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:52
msgid "Below a short description of a few of the available filesystems."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:52
#, no-wrap
msgid "B<minix>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:59
msgid ""
"is the filesystem used in the Minix operating system, the first to run under "
"Linux.  It has a number of shortcomings, including a 64MB partition size "
"limit, short filenames, and a single timestamp.  It remains useful for "
"floppies and RAM disks."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:59
#, no-wrap
msgid "B<ext>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:68
msgid ""
"is an elaborate extension of the B<minix> filesystem.  It has been "
"completely superseded by the second version of the extended filesystem "
"(B<ext2>)  and has been removed from the kernel (in 2.1.21)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:68
#, no-wrap
msgid "B<ext2>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:78
msgid ""
"is the high performance disk filesystem used by Linux for fixed disks as "
"well as removable media.  The second extended filesystem was designed as an "
"extension of the extended filesystem (B<ext>).  B<ext2> offers the best "
"performance (in terms of speed and CPU usage) of the filesystems supported "
"under Linux."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:78
#, no-wrap
msgid "B<ext3>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:83
msgid ""
"is a journaling version of the ext2 filesystem.  It is easy to switch back "
"and forth between ext2 and ext3."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:83
#, no-wrap
msgid "B<ext4>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:88
msgid ""
"is a set of upgrades to ext3 including substantial performance and "
"reliability enhancements, plus large increases in volume, file, and "
"directory size limits."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:88
#, no-wrap
msgid "B<Reiserfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:92
msgid ""
"is a journaling filesystem, designed by Hans Reiser, that was integrated "
"into Linux in kernel 2.4.1."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:92
#, no-wrap
msgid "B<XFS>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:96
msgid ""
"is a journaling filesystem, developed by SGI, that was integrated into Linux "
"in kernel 2.4.20."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:96
#, no-wrap
msgid "B<JFS>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:100
msgid ""
"is a journaling filesystem, developed by IBM, that was integrated into Linux "
"in kernel 2.4.24."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:100
#, no-wrap
msgid "B<xiafs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:110
msgid ""
"was designed and implemented to be a stable, safe filesystem by extending "
"the Minix filesystem code.  It provides the basic most requested features "
"without undue complexity.  The B<xia> filesystem is no longer actively "
"developed or maintained.  It was removed from the kernel in 2.1.21."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:110
#, no-wrap
msgid "B<msdos>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:116
msgid ""
"is the filesystem used by DOS, Windows, and some OS/2 computers.  B<msdos> "
"filenames can be no longer than 8 characters, followed by an optional period "
"and 3 character extension."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:116
#, no-wrap
msgid "B<umsdos>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:123
msgid ""
"is an extended DOS filesystem used by Linux.  It adds capability for long "
"filenames, UID/GID, POSIX permissions, and special files (devices, named "
"pipes, etc.)  under the DOS filesystem, without sacrificing compatibility "
"with DOS."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:123
#, no-wrap
msgid "B<vfat>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:127
msgid ""
"is an extended DOS filesystem used by Microsoft Windows95 and Windows NT.  "
"VFAT adds the capability to use long filenames under the MSDOS filesystem."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:127
#, no-wrap
msgid "B<ntfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:132
msgid ""
"replaces Microsoft Window's FAT filesystems (VFAT, FAT32).  It has "
"reliability, performance, and space-utilization enhancements plus features "
"like ACLs, journaling, encryption, and so on."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:132
#, no-wrap
msgid "B<proc>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:140
msgid ""
"is a pseudo filesystem which is used as an interface to kernel data "
"structures rather than reading and interpreting I</dev/kmem>.  In "
"particular, its files do not take disk space.  See B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:140
#, no-wrap
msgid "B<iso9660>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:143
msgid "is a CD-ROM filesystem type conforming to the ISO 9660 standard."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:144
#, no-wrap
msgid "B<High Sierra>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:151
msgid ""
"Linux supports High Sierra, the precursor to the ISO 9660 standard for "
"CD-ROM filesystems.  It is automatically recognized within the B<iso9660> "
"filesystem support under Linux."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:151
#, no-wrap
msgid "B<Rock Ridge>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:162
msgid ""
"Linux also supports the System Use Sharing Protocol records specified by the "
"Rock Ridge Interchange Protocol.  They are used to further describe the "
"files in the B<iso9660> filesystem to a UNIX host, and provide information "
"such as long filenames, UID/GID, POSIX permissions, and devices.  It is "
"automatically recognized within the B<iso9660> filesystem support under "
"Linux."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:163
#, no-wrap
msgid "B<hpfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:168
msgid ""
"is the High Performance Filesystem, used in OS/2.  This filesystem is "
"read-only under Linux due to the lack of available documentation."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:168
#, no-wrap
msgid "B<sysv>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:172
msgid ""
"is an implementation of the SystemV/Coherent filesystem for Linux.  It "
"implements all of Xenix FS, SystemV/386 FS, and Coherent FS."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:172
#, no-wrap
msgid "B<nfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:175
msgid "is the network filesystem used to access disks located on remote computers."
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:175
#, no-wrap
msgid "B<smb>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:179
msgid ""
"is a network filesystem that supports the SMB protocol, used by Windows for "
"Workgroups, Windows NT, and Lan Manager."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:186
msgid ""
"To use B<smb> fs, you need a special mount program, which can be found in "
"the ksmbfs package, found at E<.UR "
"ftp://sunsite.unc.edu\\:/pub\\:/Linux\\:/system\\:/Filesystems\\:/smbfs> "
"E<.UE .>"
msgstr ""

#. type: TP
#: build/C/man5/filesystems.5:186
#, no-wrap
msgid "B<ncpfs>"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:190
msgid ""
"is a network filesystem that supports the NCP protocol, used by Novell "
"NetWare."
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:196
msgid ""
"To use B<ncpfs>, you need special programs, which can be found at E<.UR "
"ftp://linux01.gwdg.de\\:/pub\\:/ncpfs> E<.UE .>"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:196 build/C/man3/fts.3:790 build/C/man3/ftw.3:422 build/C/man3/getfsent.3:139 build/C/man3/getmntent.3:220 build/C/man2/getxattr.2:141 build/C/man3/isfdtype.3:102 build/C/man2/listxattr.2:153 build/C/man2/mount.2:488 build/C/man7/path_resolution.7:237 build/C/man2/removexattr.2:110 build/C/man2/setxattr.2:152 build/C/man2/spu_create.2:270 build/C/man2/spu_run.2:264 build/C/man7/spufs.7:766 build/C/man2/stat.2:920 build/C/man2/statfs.2:314 build/C/man3/statvfs.3:188 build/C/man2/umount.2:176 build/C/man2/ustat.2:118
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:201
msgid "B<proc>(5), B<fsck>(8), B<mkfs>(8), B<mount>(8)"
msgstr ""

#. type: SH
#: build/C/man5/filesystems.5:201 build/C/man3/fts.3:796 build/C/man3/ftw.3:426 build/C/man3/getfsent.3:142 build/C/man3/getmntent.3:224 build/C/man2/getxattr.2:151 build/C/man3/isfdtype.3:104 build/C/man2/listxattr.2:163 build/C/man2/mount.2:495 build/C/man7/path_resolution.7:242 build/C/man2/removexattr.2:120 build/C/man2/setxattr.2:162 build/C/man2/spu_create.2:275 build/C/man2/spu_run.2:269 build/C/man7/spufs.7:773 build/C/man2/stat.2:930 build/C/man2/statfs.2:318 build/C/man3/statvfs.3:190 build/C/man2/sysfs.2:104 build/C/man2/umount.2:181 build/C/man2/ustat.2:121
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man5/filesystems.5:209 build/C/man3/fts.3:804 build/C/man3/ftw.3:434 build/C/man3/getfsent.3:150 build/C/man3/getmntent.3:232 build/C/man2/getxattr.2:159 build/C/man3/isfdtype.3:112 build/C/man2/listxattr.2:171 build/C/man2/mount.2:503 build/C/man7/path_resolution.7:250 build/C/man2/removexattr.2:128 build/C/man2/setxattr.2:170 build/C/man2/spu_create.2:283 build/C/man2/spu_run.2:277 build/C/man7/spufs.7:781 build/C/man2/stat.2:938 build/C/man2/statfs.2:326 build/C/man3/statvfs.3:198 build/C/man2/sysfs.2:112 build/C/man2/umount.2:189 build/C/man2/ustat.2:129
msgid ""
"This page is part of release 3.79 of the Linux I<man-pages> project.  A "
"description of the project, information about reporting bugs, and the latest "
"version of this page, can be found at "
"\\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/fts.3:40
#, no-wrap
msgid "FTS"
msgstr ""

#. type: TH
#: build/C/man3/fts.3:40
#, no-wrap
msgid "2014-03-18"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:44
msgid ""
"fts, fts_open, fts_read, fts_children, fts_set, fts_close - traverse a file "
"hierarchy"
msgstr ""

#. type: SH
#: build/C/man3/fts.3:44 build/C/man3/ftw.3:38 build/C/man3/getfsent.3:30 build/C/man3/getmntent.3:36 build/C/man2/getxattr.2:28 build/C/man3/isfdtype.3:29 build/C/man2/listxattr.2:28 build/C/man2/mount.2:43 build/C/man2/removexattr.2:28 build/C/man2/setxattr.2:28 build/C/man2/spu_create.2:28 build/C/man2/spu_run.2:29 build/C/man2/stat.2:43 build/C/man2/statfs.2:31 build/C/man3/statvfs.3:33 build/C/man2/sysfs.2:30 build/C/man2/umount.2:33 build/C/man2/ustat.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:49
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>fts.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:52
#, no-wrap
msgid ""
"B<FTS *fts_open(char * const *>I<path_argv>B<, int >I<options>B<, >\n"
"B<              int (*>I<compar>B<)(const FTSENT **, const FTSENT **));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:54
#, no-wrap
msgid "B<FTSENT *fts_read(FTS *>I<ftsp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:56
#, no-wrap
msgid "B<FTSENT *fts_children(FTS *>I<ftsp>B<, int >I<options>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:58
#, no-wrap
msgid "B<int fts_set(FTS *>I<ftsp>B<, FTSENT *>I<f>B<, int >I<options>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:60
#, no-wrap
msgid "B<int fts_close(FTS *>I<ftsp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:87
msgid ""
"The fts functions are provided for traversing file hierarchies.  A simple "
"overview is that the B<fts_open>()  function returns a \"handle\" on a file "
"hierarchy, which is then supplied to the other fts functions.  The function "
"B<fts_read>()  returns a pointer to a structure describing one of the files "
"in the file hierarchy.  The function B<fts_children>()  returns a pointer to "
"a linked list of structures, each of which describes one of the files "
"contained in a directory in the hierarchy.  In general, directories are "
"visited two distinguishable times; in preorder (before any of their "
"descendants are visited) and in postorder (after all of their descendants "
"have been visited).  Files are visited once.  It is possible to walk the "
"hierarchy \"logically\" (visiting the files that symbolic links point to)  "
"or physically (visiting the symbolic links themselves), order the walk of "
"the hierarchy or prune and/or revisit portions of the hierarchy."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:108
msgid ""
"Two structures are defined (and typedef'd) in the include file "
"I<E<lt>fts.hE<gt>>.  The first is I<FTS>, the structure that represents the "
"file hierarchy itself.  The second is I<FTSENT>, the structure that "
"represents a file in the file hierarchy.  Normally, an I<FTSENT> structure "
"is returned for every file in the file hierarchy.  In this manual page, "
"\"file\" and \"FTSENT structure\" are generally interchangeable.  The "
"I<FTSENT> structure contains at least the following fields, which are "
"described in greater detail below:"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:127
#, no-wrap
msgid ""
"typedef struct _ftsent {\n"
"    unsigned short fts_info;     /* flags for FTSENT structure */\n"
"    char          *fts_accpath;  /* access path */\n"
"    char          *fts_path;     /* root path */\n"
"    short          fts_pathlen;  /* strlen(fts_path) */\n"
"    char          *fts_name;     /* filename */\n"
"    short          fts_namelen;  /* strlen(fts_name) */\n"
"    short          fts_level;    /* depth (-1 to N) */\n"
"    int            fts_errno;    /* file errno */\n"
"    long           fts_number;   /* local numeric value */\n"
"    void          *fts_pointer;  /* local address value */\n"
"    struct ftsent *fts_parent;   /* parent directory */\n"
"    struct ftsent *fts_link;     /* next file structure */\n"
"    struct ftsent *fts_cycle;    /* cycle structure */\n"
"    struct stat   *fts_statp;    /* stat(2) information */\n"
"} FTSENT;\n"
msgstr ""

#.  .Bl -tag -width "fts_namelen"
#. type: Plain text
#: build/C/man3/fts.3:132
msgid "These fields are defined as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:132
#, no-wrap
msgid "I<fts_info>"
msgstr ""

#.  .Bl  -tag -width FTS_DEFAULT
#. type: Plain text
#: build/C/man3/fts.3:144
msgid ""
"One of the following flags describing the returned I<FTSENT> structure and "
"the file it represents.  With the exception of directories without errors "
"(B<FTS_D>), all of these entries are terminal, that is, they will not be "
"revisited, nor will any of their descendants be visited."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:145
#, no-wrap
msgid "B<FTS_D>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:148
msgid "A directory being visited in preorder."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:148
#, no-wrap
msgid "B<FTS_DC>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:156
msgid ""
"A directory that causes a cycle in the tree.  (The I<fts_cycle> field of the "
"I<FTSENT> structure will be filled in as well.)"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:156
#, no-wrap
msgid "B<FTS_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:164
msgid ""
"Any I<FTSENT> structure that represents a file type not explicitly described "
"by one of the other I<fts_info> values."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:164
#, no-wrap
msgid "B<FTS_DNR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:170
msgid ""
"A directory which cannot be read.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:170
#, no-wrap
msgid "B<FTS_DOT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:180
msgid ""
"A file named \".\" or \"..\" which was not specified as a filename to "
"B<fts_open>()  (see B<FTS_SEEDOT>)."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:180
#, no-wrap
msgid "B<FTS_DP>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:190
msgid ""
"A directory being visited in postorder.  The contents of the I<FTSENT> "
"structure will be unchanged from when it was returned in preorder, that is, "
"with the I<fts_info> field set to B<FTS_D>."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:190
#, no-wrap
msgid "B<FTS_ERR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:195
msgid ""
"This is an error return, and the I<fts_errno> field will be set to indicate "
"what caused the error."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:195
#, no-wrap
msgid "B<FTS_F>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:198
msgid "A regular file."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:198
#, no-wrap
msgid "B<FTS_NS>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:209
msgid ""
"A file for which no B<stat>(2)  information was available.  The contents of "
"the I<fts_statp> field are undefined.  This is an error return, and the "
"I<fts_errno> field will be set to indicate what caused the error."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:209
#, no-wrap
msgid "B<FTS_NSOK>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:217
msgid ""
"A file for which no B<stat>(2)  information was requested.  The contents of "
"the I<fts_statp> field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:217
#, no-wrap
msgid "B<FTS_SL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:220
msgid "A symbolic link."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:220
#, no-wrap
msgid "B<FTS_SLNONE>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:228
msgid ""
"A symbolic link with a nonexistent target.  The contents of the I<fts_statp> "
"field reference the file characteristic information for the symbolic link "
"itself."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:229
#, no-wrap
msgid "I<fts_accpath>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:232
msgid "A path for accessing the file from the current directory."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:232
#, no-wrap
msgid "I<fts_path>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:238
msgid ""
"The path for the file relative to the root of the traversal.  This path "
"contains the path specified to B<fts_open>()  as a prefix."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:238
#, no-wrap
msgid "I<fts_pathlen>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:242
msgid "The length of the string referenced by I<fts_path>."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:242
#, no-wrap
msgid "I<fts_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:245
msgid "The name of the file."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:245
#, no-wrap
msgid "I<fts_namelen>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:249
msgid "The length of the string referenced by I<fts_name>."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:249
#, no-wrap
msgid "I<fts_level>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:260
msgid ""
"The depth of the traversal, numbered from -1 to N, where this file was "
"found.  The I<FTSENT> structure representing the parent of the starting "
"point (or root)  of the traversal is numbered -1, and the I<FTSENT> "
"structure for the root itself is numbered 0."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:260
#, no-wrap
msgid "I<fts_errno>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:283
msgid ""
"Upon return of a I<FTSENT> structure from the B<fts_children>()  or "
"B<fts_read>()  functions, with its I<fts_info> field set to B<FTS_DNR>, "
"B<FTS_ERR> or B<FTS_NS>, the I<fts_errno> field contains the value of the "
"external variable I<errno> specifying the cause of the error.  Otherwise, "
"the contents of the I<fts_errno> field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:283
#, no-wrap
msgid "I<fts_number>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:289
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to 0."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:289
#, no-wrap
msgid "I<fts_pointer>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:296
msgid ""
"This field is provided for the use of the application program and is not "
"modified by the fts functions.  It is initialized to NULL."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:296
#, no-wrap
msgid "I<fts_parent>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:310
msgid ""
"A pointer to the I<FTSENT> structure referencing the file in the hierarchy "
"immediately above the current file, that is, the directory of which this "
"file is a member.  A parent structure for the initial entry point is "
"provided as well, however, only the I<fts_level>, I<fts_number> and "
"I<fts_pointer> fields are guaranteed to be initialized."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:310
#, no-wrap
msgid "I<fts_link>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:321
msgid ""
"Upon return from the B<fts_children>()  function, the I<fts_link> field "
"points to the next structure in the NULL-terminated linked list of directory "
"members.  Otherwise, the contents of the I<fts_link> field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:321
#, no-wrap
msgid "I<fts_cycle>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:337
msgid ""
"If a directory causes a cycle in the hierarchy (see B<FTS_DC>), either "
"because of a hard link between two directories, or a symbolic link pointing "
"to a directory, the I<fts_cycle> field of the structure will point to the "
"I<FTSENT> structure in the hierarchy that references the same file as the "
"current I<FTSENT> structure.  Otherwise, the contents of the I<fts_cycle> "
"field are undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:337
#, no-wrap
msgid "I<fts_statp>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:343
msgid "A pointer to B<stat>(2)  information for the file."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:370
msgid ""
"A single buffer is used for all of the paths of all of the files in the file "
"hierarchy.  Therefore, the I<fts_path> and I<fts_accpath> fields are "
"guaranteed to be null-terminated I<only> for the file most recently returned "
"by B<fts_read>().  To use these fields to reference any files represented by "
"other I<FTSENT> structures will require that the path buffer be modified "
"using the information contained in that I<FTSENT> structure's I<fts_pathlen> "
"field.  Any such modifications should be undone before further calls to "
"B<fts_read>()  are attempted.  The I<fts_name> field is always "
"null-terminated."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:370
#, no-wrap
msgid "fts_open()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:377
msgid ""
"The B<fts_open>()  function takes a pointer to an array of character "
"pointers naming one or more paths which make up a logical file hierarchy to "
"be traversed.  The array must be terminated by a null pointer."
msgstr ""

#.  .Bl -tag -width "FTS_PHYSICAL"
#. type: Plain text
#: build/C/man3/fts.3:387
msgid ""
"There are a number of options, at least one of which (either B<FTS_LOGICAL> "
"or B<FTS_PHYSICAL>)  must be specified.  The options are selected by ORing "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:387
#, no-wrap
msgid "B<FTS_COMFOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:393
msgid ""
"This option causes any symbolic link specified as a root path to be followed "
"immediately whether or not B<FTS_LOGICAL> is also specified."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:393
#, no-wrap
msgid "B<FTS_LOGICAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:412
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for the "
"targets of symbolic links instead of the symbolic links themselves.  If this "
"option is set, the only symbolic links for which I<FTSENT> structures are "
"returned to the application are those referencing nonexistent files.  Either "
"B<FTS_LOGICAL> or B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  "
"function."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:412
#, no-wrap
msgid "B<FTS_NOCHDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:428
msgid ""
"As a performance optimization, the fts functions change directories as they "
"walk the file hierarchy.  This has the side-effect that an application "
"cannot rely on being in any particular directory during the traversal.  The "
"B<FTS_NOCHDIR> option turns off this optimization, and the fts functions "
"will not change the current directory.  Note that applications should not "
"themselves change their current directory and try to access files unless "
"B<FTS_NOCHDIR> is specified and absolute pathnames were provided as "
"arguments to B<fts_open>()."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:428
#, no-wrap
msgid "B<FTS_NOSTAT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:444
msgid ""
"By default, returned I<FTSENT> structures reference file characteristic "
"information (the I<statp> field) for each file visited.  This option relaxes "
"that requirement as a performance optimization, allowing the fts functions "
"to set the I<fts_info> field to B<FTS_NSOK> and leave the contents of the "
"I<statp> field undefined."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:444
#, no-wrap
msgid "B<FTS_PHYSICAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:463
msgid ""
"This option causes the fts routines to return I<FTSENT> structures for "
"symbolic links themselves instead of the target files they point to.  If "
"this option is set, I<FTSENT> structures for all symbolic links in the "
"hierarchy are returned to the application.  Either B<FTS_LOGICAL> or "
"B<FTS_PHYSICAL> I<must> be provided to the B<fts_open>()  function."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:463
#, no-wrap
msgid "B<FTS_SEEDOT>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:476
msgid ""
"By default, unless they are specified as path arguments to B<fts_open>(), "
"any files named \".\" or \"..\" encountered in the file hierarchy are "
"ignored.  This option causes the fts routines to return I<FTSENT> structures "
"for them."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:476
#, no-wrap
msgid "B<FTS_XDEV>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:482
msgid ""
"This option prevents fts from descending into directories that have a "
"different device number than the file from which the descent began."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:521
msgid ""
"The argument B<compar>()  specifies a user-defined function which may be "
"used to order the traversal of the hierarchy.  It takes two pointers to "
"pointers to I<FTSENT> structures as arguments and should return a negative "
"value, zero, or a positive value to indicate if the file referenced by its "
"first argument comes before, in any order with respect to, or after, the "
"file referenced by its second argument.  The I<fts_accpath>, I<fts_path> and "
"I<fts_pathlen> fields of the I<FTSENT> structures may I<never> be used in "
"this comparison.  If the I<fts_info> field is set to B<FTS_NS> or "
"B<FTS_NSOK>, the I<fts_statp> field may not either.  If the B<compar>()  "
"argument is NULL, the directory traversal order is in the order listed in "
"I<path_argv> for the root paths, and in the order listed in the directory "
"for everything else."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:521
#, no-wrap
msgid "fts_read()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:534
msgid ""
"The B<fts_read>()  function returns a pointer to an I<FTSENT> structure "
"describing a file in the hierarchy.  Directories (that are readable and do "
"not cause cycles) are visited at least twice, once in preorder and once in "
"postorder.  All other files are visited at least once.  (Hard links between "
"directories that do not cause cycles or symbolic links to symbolic links may "
"cause files to be visited more than once, or directories more than twice.)"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:555
msgid ""
"If all the members of the hierarchy have been returned, B<fts_read>()  "
"returns NULL and sets the external variable I<errno> to 0.  If an error "
"unrelated to a file in the hierarchy occurs, B<fts_read>()  returns NULL and "
"sets I<errno> appropriately.  If an error related to a returned file occurs, "
"a pointer to an I<FTSENT> structure is returned, and I<errno> may or may not "
"have been set (see I<fts_info>)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:572
msgid ""
"The I<FTSENT> structures returned by B<fts_read>()  may be overwritten after "
"a call to B<fts_close>()  on the same file hierarchy stream, or, after a "
"call to B<fts_read>()  on the same file hierarchy stream unless they "
"represent a file of type directory, in which case they will not be "
"overwritten until after a call to B<fts_read>()  after the I<FTSENT> "
"structure has been returned by the function B<fts_read>()  in postorder."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:572
#, no-wrap
msgid "fts_children()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:590
msgid ""
"The B<fts_children>()  function returns a pointer to an I<FTSENT> structure "
"describing the first entry in a NULL-terminated linked list of the files in "
"the directory represented by the I<FTSENT> structure most recently returned "
"by B<fts_read>().  The list is linked through the I<fts_link> field of the "
"I<FTSENT> structure, and is ordered by the user-specified comparison "
"function, if any.  Repeated calls to B<fts_children>()  will re-create this "
"linked list."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:618
msgid ""
"As a special case, if B<fts_read>()  has not yet been called for a "
"hierarchy, B<fts_children>()  will return a pointer to the files in the "
"logical directory specified to B<fts_open>(), that is, the arguments "
"specified to B<fts_open>().  Otherwise, if the I<FTSENT> structure most "
"recently returned by B<fts_read>()  is not a directory being visited in "
"preorder, or the directory does not contain any files, B<fts_children>()  "
"returns NULL and sets I<errno> to zero.  If an error occurs, "
"B<fts_children>()  returns NULL and sets I<errno> appropriately."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:629
msgid ""
"The I<FTSENT> structures returned by B<fts_children>()  may be overwritten "
"after a call to B<fts_children>(), B<fts_close>()  or B<fts_read>()  on the "
"same file hierarchy stream."
msgstr ""

#.  .Bl -tag -width FTS_NAMEONLY
#. type: Plain text
#: build/C/man3/fts.3:633
msgid "I<Option> may be set to the following value:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:633
#, no-wrap
msgid "B<FTS_NAMEONLY>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:643
msgid ""
"Only the names of the files are needed.  The contents of all the fields in "
"the returned linked list of structures are undefined with the exception of "
"the I<fts_name> and I<fts_namelen> fields."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:643
#, no-wrap
msgid "fts_set()"
msgstr ""

#.  .Bl -tag -width FTS_PHYSICAL
#. type: Plain text
#: build/C/man3/fts.3:658
msgid ""
"The function B<fts_set>()  allows the user application to determine further "
"processing for the file I<f> of the stream I<ftsp>.  The B<fts_set>()  "
"function returns 0 on success, and -1 if an error occurs.  I<Option> must be "
"set to one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:658
#, no-wrap
msgid "B<FTS_AGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:676
msgid ""
"Revisit the file; any file type may be revisited.  The next call to "
"B<fts_read>()  will return the referenced file.  The I<fts_stat> and "
"I<fts_info> fields of the structure will be reinitialized at that time, but "
"no other fields will have been changed.  This option is meaningful only for "
"the most recently returned file from B<fts_read>().  Normal use is for "
"postorder directory visits, where it causes the directory to be revisited "
"(in both preorder and postorder) as well as all of its descendants."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:676
#, no-wrap
msgid "B<FTS_FOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:704
msgid ""
"The referenced file must be a symbolic link.  If the referenced file is the "
"one most recently returned by B<fts_read>(), the next call to B<fts_read>()  "
"returns the file with the I<fts_info> and I<fts_statp> fields reinitialized "
"to reflect the target of the symbolic link instead of the symbolic link "
"itself.  If the file is one of those most recently returned by "
"B<fts_children>(), the I<fts_info> and I<fts_statp> fields of the structure, "
"when returned by B<fts_read>(), will reflect the target of the symbolic link "
"instead of the symbolic link itself.  In either case, if the target of the "
"symbolic link does not exist, the fields of the returned structure will be "
"unchanged and the I<fts_info> field will be set to B<FTS_SLNONE>."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:708
msgid ""
"If the target of the link is a directory, the preorder return, followed by "
"the return of all of its descendants, followed by a postorder return, is "
"done."
msgstr ""

#. type: TP
#: build/C/man3/fts.3:708
#, no-wrap
msgid "B<FTS_SKIP>"
msgstr ""

#.  .El
#. type: Plain text
#: build/C/man3/fts.3:716
msgid ""
"No descendants of this file are visited.  The file may be one of those most "
"recently returned by either B<fts_children>()  or B<fts_read>()."
msgstr ""

#. type: SS
#: build/C/man3/fts.3:716
#, no-wrap
msgid "fts_close()"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:729
msgid ""
"The B<fts_close>()  function closes a file hierarchy stream I<ftsp> and "
"restores the current directory to the directory from which B<fts_open>()  "
"was called to open I<ftsp>.  The B<fts_close>()  function returns 0 on "
"success, and -1 if an error occurs."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:729 build/C/man2/getxattr.2:106 build/C/man3/isfdtype.3:83 build/C/man2/listxattr.2:127 build/C/man2/mount.2:318 build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:110 build/C/man2/spu_create.2:172 build/C/man2/spu_run.2:153 build/C/man2/stat.2:522 build/C/man2/statfs.2:162 build/C/man3/statvfs.3:101 build/C/man2/sysfs.2:79 build/C/man2/umount.2:104 build/C/man2/ustat.2:79
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:738
msgid ""
"The function B<fts_open>()  may fail and set I<errno> for any of the errors "
"specified for B<open>(2)  and B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:747
msgid ""
"The function B<fts_close>()  may fail and set I<errno> for any of the errors "
"specified for B<chdir>(2)  and B<close>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:761
msgid ""
"The functions B<fts_read>()  and B<fts_children>()  may fail and set "
"I<errno> for any of the errors specified for B<chdir>(2), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), and B<stat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:770
msgid ""
"In addition, B<fts_children>(), B<fts_open>(), and B<fts_set>()  may fail "
"and set I<errno> as follows:"
msgstr ""

#. type: TP
#: build/C/man3/fts.3:770 build/C/man2/mount.2:354 build/C/man2/spu_create.2:186 build/C/man2/spu_run.2:174 build/C/man2/stat.2:585 build/C/man2/sysfs.2:84 build/C/man2/umount.2:125 build/C/man2/umount.2:129 build/C/man2/ustat.2:84
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:773
msgid "The options were invalid."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:773 build/C/man3/ftw.3:339 build/C/man2/getxattr.2:130 build/C/man2/listxattr.2:142 build/C/man2/mount.2:412 build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:141 build/C/man2/spu_create.2:246 build/C/man2/spu_run.2:188 build/C/man2/stat.2:595 build/C/man2/umount.2:156
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:775
msgid "These functions are available in Linux since glibc2."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:775 build/C/man3/ftw.3:342 build/C/man3/getfsent.3:115 build/C/man3/getmntent.3:202 build/C/man2/getxattr.2:133 build/C/man3/isfdtype.3:88 build/C/man2/listxattr.2:145 build/C/man2/mount.2:423 build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:144 build/C/man2/spu_create.2:250 build/C/man2/spu_run.2:192 build/C/man2/stat.2:599 build/C/man2/statfs.2:218 build/C/man3/statvfs.3:164 build/C/man2/sysfs.2:92 build/C/man2/umount.2:162 build/C/man2/ustat.2:94
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:777
msgid "4.4BSD."
msgstr ""

#. type: SH
#: build/C/man3/fts.3:777 build/C/man2/statfs.2:305 build/C/man2/sysfs.2:101
#, no-wrap
msgid "BUGS"
msgstr ""

#.  https://sourceware.org/bugzilla/show_bug.cgi?id=15838
#.  https://sourceware.org/bugzilla/show_bug.cgi?id=11460
#.  The following statement is years old, and seems no closer to
#.  being true -- mtk
#.  The
#.  .I fts
#.  utility is expected to be included in a future
#.  POSIX.1
#.  revision.
#. type: Plain text
#: build/C/man3/fts.3:790
msgid ""
"All of the APIs described in this man page are not safe when compiling a "
"program using the LFS APIs (e.g., when compiling with "
"I<-D_FILE_OFFSET_BITS=64>)."
msgstr ""

#. type: Plain text
#: build/C/man3/fts.3:796
msgid "B<find>(1), B<chdir>(2), B<stat>(2), B<ftw>(3), B<qsort>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ftw.3:35
#, no-wrap
msgid "FTW"
msgstr ""

#. type: TH
#: build/C/man3/ftw.3:35
#, no-wrap
msgid "2014-12-31"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:38
msgid "ftw, nftw - file tree walk"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:41
#, no-wrap
msgid "B<#include E<lt>ftw.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:46
#, no-wrap
msgid ""
"B<int ftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat "
"*>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<),>\n"
"B<        int >I<nopenfd>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:49
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE 500>   /* See feature_test_macros(7) */\n"
"B<#include E<lt>ftw.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:54
#, no-wrap
msgid ""
"B<int nftw(const char *>I<dirpath>B<,>\n"
"B<        int (*>I<fn>B<) (const char *>I<fpath>B<, const struct stat "
"*>I<sb>B<,>\n"
"B<                   int >I<typeflag>B<, struct FTW *>I<ftwbuf>B<),>\n"
"B<        int >I<nopenfd>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:62
msgid ""
"B<ftw>()  walks through the directory tree that is located under the "
"directory I<dirpath>, and calls I<fn>() once for each entry in the tree.  By "
"default, directories are handled before the files and subdirectories they "
"contain (preorder traversal)."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:75
msgid ""
"To avoid using up all of the calling process's file descriptors, I<nopenfd> "
"specifies the maximum number of directories that B<ftw>()  will hold open "
"simultaneously.  When the search depth exceeds this, B<ftw>()  will become "
"slower because directories have to be closed and reopened.  B<ftw>()  uses "
"at most one file descriptor for each level in the directory tree."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:104
msgid ""
"For each entry found in the tree, B<ftw>()  calls I<fn>() with three "
"arguments: I<fpath>, I<sb>, and I<typeflag>.  I<fpath> is the pathname of "
"the entry, and is expressed either as a pathname relative to the calling "
"process's current working directory at the time of the call to B<ftw>(), if "
"I<dirpath> was expressed as a relative pathname, or as an absolute pathname, "
"if I<dirpath> was expressed as an absolute pathname.  I<sb> is a pointer to "
"the I<stat> structure returned by a call to B<stat>(2)  for I<fpath>.  "
"I<typeflag> is an integer that has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:104
#, no-wrap
msgid "B<FTW_F>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:108
msgid "I<fpath> is a regular file."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:108
#, no-wrap
msgid "B<FTW_D>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:112
msgid "I<fpath> is a directory."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:112
#, no-wrap
msgid "B<FTW_DNR>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:116
msgid "I<fpath> is a directory which can't be read."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:116
#, no-wrap
msgid "B<FTW_NS>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:130
msgid ""
"The B<stat>(2)  call failed on I<fpath>, which is not a symbolic link.  The "
"probable cause for this is that the caller had read permission on the parent "
"directory, so that the filename I<fpath> could be seen, but did not have "
"execute permission, so that the file could not be reached for B<stat>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:139
msgid ""
"If I<fpath> is a symbolic link and B<stat>(2)  failed, POSIX.1-2001 states "
"that it is undefined whether B<FTW_NS> or B<FTW_SL> (see below)  is passed "
"in I<typeflag>."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:150
msgid ""
"To stop the tree walk, I<fn>() returns a nonzero value; this value will "
"become the return value of B<ftw>().  As long as I<fn>() returns 0, B<ftw>()  "
"will continue either until it has traversed the entire tree, in which case "
"it will return zero, or until it encounters an error (such as a B<malloc>(3)  "
"failure), in which case it will return -1."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:160
msgid ""
"Because B<ftw>()  uses dynamic data structures, the only safe way to exit "
"out of a tree walk is to return a nonzero value from I<fn>().  To allow a "
"signal to terminate the walk without causing a memory leak, have the handler "
"set a global flag that is checked by I<fn>().  I<Don't> use B<longjmp>(3)  "
"unless the program is going to terminate."
msgstr ""

#. type: SS
#: build/C/man3/ftw.3:160
#, no-wrap
msgid "nftw()"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:167
msgid ""
"The function B<nftw>()  is the same as B<ftw>(), except that it has one "
"additional argument, I<flags>, and calls I<fn>() with one more argument, "
"I<ftwbuf>."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:170
msgid ""
"This I<flags> argument is formed by ORing zero or more of the following "
"flags:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:170
#, no-wrap
msgid "B<FTW_ACTIONRETVAL> (since glibc 2.3.3)"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:179
msgid ""
"If this glibc-specific flag is set, then B<nftw>()  handles the return value "
"from I<fn>()  differently.  I<fn>()  should return one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:180
#, no-wrap
msgid "B<FTW_CONTINUE>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:185
msgid "Instructs B<nftw>()  to continue normally."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:185
#, no-wrap
msgid "B<FTW_SKIP_SIBLINGS>"
msgstr ""

#.  If \fBFTW_DEPTH\fP
#.  is set, the entry's parent directory is processed next (with
#.  \fIflag\fP set to \fBFTW_DP\fP).
#. type: Plain text
#: build/C/man3/ftw.3:193
msgid ""
"If I<fn>() returns this value, then siblings of the current entry will be "
"skipped, and processing continues in the parent."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:193
#, no-wrap
msgid "B<FTW_SKIP_SUBTREE>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:201
msgid ""
"If I<fn>() is called with an entry that is a directory (I<typeflag> is "
"B<FTW_D>), this return value will prevent objects within that directory from "
"being passed as arguments to I<fn>().  B<nftw>()  continues processing with "
"the next sibling of the directory."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:201
#, no-wrap
msgid "B<FTW_STOP>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:207
msgid "Causes B<nftw>()  to return immediately with the return value B<FTW_STOP>."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:210
msgid ""
"Other return values could be associated with new actions in the future; "
"I<fn>() should not return values other than those listed above."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:219
msgid ""
"The feature test macro B<_GNU_SOURCE> must be defined (before including "
"I<any> header files)  in order to obtain the definition of "
"B<FTW_ACTIONRETVAL> from I<E<lt>ftw.hE<gt>>."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:220
#, no-wrap
msgid "B<FTW_CHDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:231
msgid ""
"If set, do a B<chdir>(2)  to each directory before handling its contents.  "
"This is useful if the program needs to perform some action in the directory "
"in which I<fpath> resides.  (Specifying this flag has no effect on the "
"pathname that is passed in the I<fpath> argument of I<fn>.)"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:231
#, no-wrap
msgid "B<FTW_DEPTH>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:237
msgid ""
"If set, do a post-order traversal, that is, call I<fn>() for the directory "
"itself I<after> handling the contents of the directory and its "
"subdirectories.  (By default, each directory is handled I<before> its "
"contents.)"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:237
#, no-wrap
msgid "B<FTW_MOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:241
msgid "If set, stay within the same filesystem (i.e., do not cross mount points)."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:241
#, no-wrap
msgid "B<FTW_PHYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:246
msgid ""
"If set, do not follow symbolic links.  (This is what you want.)  If not set, "
"symbolic links are followed, but no file is reported twice."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:251
msgid ""
"If B<FTW_PHYS> is not set, but B<FTW_DEPTH> is set, then the function "
"I<fn>()  is never called for a directory that would be a descendant of "
"itself."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:266
msgid ""
"For each entry in the directory tree, B<nftw>()  calls I<fn>()  with four "
"arguments.  I<fpath> and I<sb> are as for B<ftw>().  I<typeflag> may receive "
"any of the same values as with B<ftw>(), or any of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:266
#, no-wrap
msgid "B<FTW_DP>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:280
msgid ""
"I<fpath> is a directory, and B<FTW_DEPTH> was specified in I<flags>.  (If "
"B<FTW_DEPTH> was not specified in I<flags>, then directories will always be "
"visited with I<typeflag> set to B<FTW_D>.)  All of the files and "
"subdirectories within I<fpath> have been processed."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:280
#, no-wrap
msgid "B<FTW_SL>"
msgstr ""

#.  To obtain the definition of this constant from
#.  .IR <ftw.h> ,
#.  either
#.  .B _BSD_SOURCE
#.  must be defined, or
#.  .BR _XOPEN_SOURCE
#.  must be defined with a value of 500 or more.
#. type: Plain text
#: build/C/man3/ftw.3:291
msgid "I<fpath> is a symbolic link, and B<FTW_PHYS> was set in I<flags>."
msgstr ""

#. type: TP
#: build/C/man3/ftw.3:291
#, no-wrap
msgid "B<FTW_SLN>"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:296
msgid ""
"I<fpath> is a symbolic link pointing to a nonexistent file.  (This occurs "
"only if B<FTW_PHYS> is not set.)"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:302
msgid ""
"The fourth argument that B<nftw>()  supplies when calling I<fn>()  is a "
"structure of type I<FTW>:"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:309
#, no-wrap
msgid ""
"struct FTW {\n"
"    int base;\n"
"    int level;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:322
msgid ""
"I<base> is the offset of the filename (i.e., basename component)  in the "
"pathname given in I<fpath>.  I<level> is the depth of I<fpath> in the "
"directory tree, relative to the root of the tree (I<dirpath>, which has "
"depth 0)."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:322 build/C/man3/getfsent.3:99 build/C/man3/getmntent.3:175 build/C/man2/getxattr.2:100 build/C/man3/isfdtype.3:72 build/C/man2/listxattr.2:121 build/C/man2/mount.2:313 build/C/man2/removexattr.2:78 build/C/man2/setxattr.2:105 build/C/man2/spu_create.2:165 build/C/man2/spu_run.2:102 build/C/man2/stat.2:517 build/C/man2/statfs.2:157 build/C/man3/statvfs.3:96 build/C/man2/sysfs.2:67 build/C/man2/umount.2:99 build/C/man2/ustat.2:70
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:324
msgid "These functions return 0 on success, and -1 if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:331
msgid ""
"If I<fn>() returns nonzero, then the tree walk is terminated and the value "
"returned by I<fn>()  is returned as the result of B<ftw>()  or B<nftw>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:339
msgid ""
"If B<nftw>()  is called with the B<FTW_ACTIONRETVAL> flag, then the only "
"nonzero value that should be used by I<fn>()  to terminate the tree walk is "
"B<FTW_STOP>, and that value is returned as the result of B<nftw>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:342
msgid "B<nftw>()  is available under glibc since version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:347
msgid "POSIX.1-2001, SVr4, SUSv1.  POSIX.1-2008 marks B<ftw>()  as obsolete."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:347 build/C/man3/getfsent.3:127 build/C/man3/getmntent.3:208 build/C/man3/isfdtype.3:98 build/C/man2/mount.2:426 build/C/man2/spu_create.2:254 build/C/man2/spu_run.2:196 build/C/man2/stat.2:743 build/C/man2/statfs.2:224 build/C/man3/statvfs.3:166 build/C/man2/sysfs.2:94 build/C/man2/umount.2:165 build/C/man2/ustat.2:98
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:351
msgid ""
"POSIX.1-2001 note that the results are unspecified if I<fn> does not "
"preserve the current working directory."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:357
msgid ""
"The function B<nftw>()  and the use of B<FTW_SL> with B<ftw>()  were "
"introduced in SUSv1."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:367
msgid ""
"On some systems B<ftw>()  will never use B<FTW_SL>, on other systems "
"B<FTW_SL> occurs only for symbolic links that do not point to an existing "
"file, and again on other systems B<ftw>()  will use B<FTW_SL> for each "
"symbolic link.  For predictable control, use B<nftw>()."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:370
msgid ""
"B<FTW_F> is returned for all objects (files, symbolic links, FIFOs, etc.)  "
"that can be stat'ed but are not a directory."
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:372
msgid "B<FTW_ACTIONRETVAL> is glibc-specific."
msgstr ""

#. type: SH
#: build/C/man3/ftw.3:372 build/C/man2/spu_create.2:265 build/C/man2/spu_run.2:207 build/C/man7/spufs.7:759 build/C/man2/stat.2:855
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:381
msgid ""
"The following program traverses the directory tree under the path named in "
"its first command-line argument, or under the current directory if no "
"argument is supplied.  It displays various information about each file.  The "
"second command-line argument can be used to specify characters that control "
"the value assigned to the I<flags> argument when calling B<nftw>()."
msgstr ""

#. type: SS
#: build/C/man3/ftw.3:381
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:389
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE 500\n"
"#include E<lt>ftw.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:403
#, no-wrap
msgid ""
"static int\n"
"display_info(const char *fpath, const struct stat *sb,\n"
"             int tflag, struct FTW *ftwbuf)\n"
"{\n"
"    printf(\"%-3s %2d %7jd   %-40s %d %s\\en\",\n"
"        (tflag == FTW_D) ?   \"d\"   : (tflag == FTW_DNR) ? \"dnr\" :\n"
"        (tflag == FTW_DP) ?  \"dp\"  : (tflag == FTW_F) ?   \"f\" :\n"
"        (tflag == FTW_NS) ?  \"ns\"  : (tflag == FTW_SL) ?  \"sl\" :\n"
"        (tflag == FTW_SLN) ? \"sln\" : \"???\",\n"
"        ftwbuf-E<gt>level, (intmax_t) sb-E<gt>st_size,\n"
"        fpath, ftwbuf-E<gt>base, fpath + ftwbuf-E<gt>base);\n"
"    return 0;           /* To tell nftw() to continue */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:408
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:413
#, no-wrap
msgid ""
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqd\\(aq) != NULL)\n"
"        flags |= FTW_DEPTH;\n"
"    if (argc E<gt> 2 && strchr(argv[2], \\(aqp\\(aq) != NULL)\n"
"        flags |= FTW_PHYS;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:421
#, no-wrap
msgid ""
"    if (nftw((argc E<lt> 2) ? \".\" : argv[1], display_info, 20, flags)\n"
"            == -1) {\n"
"        perror(\"nftw\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ftw.3:426
msgid "B<stat>(2), B<fts>(3), B<readdir>(3)"
msgstr ""

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GETFSENT"
msgstr ""

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "2002-02-28"
msgstr ""

#. type: TH
#: build/C/man3/getfsent.3:27
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:30
msgid "getfsent, getfsspec, getfsfile, setfsent, endfsent - handle fstab entries"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:32
msgid "B<#include E<lt>fstab.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:34
msgid "B<void endfsent(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:36
msgid "B<struct fstab *getfsent(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:38
msgid "B<struct fstab *getfsfile(const char *>I<mount_point>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:40
msgid "B<struct fstab *getfsspec(const char *>I<special_file>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:42
msgid "B<int setfsent(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:48
msgid ""
"These functions read from the file I</etc/fstab>.  The I<struct fstab> is "
"defined by:"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:60
#, no-wrap
msgid ""
"struct fstab {\n"
"    char       *fs_spec;       /* block device name */\n"
"    char       *fs_file;       /* mount point */\n"
"    char       *fs_vfstype;    /* file-system type */\n"
"    char       *fs_mntops;     /* mount options */\n"
"    const char *fs_type;       /* rw/rq/ro/sw/xx option */\n"
"    int         fs_freq;       /* dump frequency, in days */\n"
"    int         fs_passno;     /* pass number on parallel dump */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:68
msgid ""
"Here the field I<fs_type> contains (on a *BSD system)  one of the five "
"strings \"rw\", \"rq\", \"ro\", \"sw\", \"xx\" (read-write, read-write with "
"quota, read-only, swap, ignore)."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:72
msgid ""
"The function B<setfsent>()  opens the file when required and positions it at "
"the first line."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:77
msgid ""
"The function B<getfsent>()  parses the next line from the file.  (After "
"opening it when required.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:81
msgid "The function B<endfsent>()  closes the file when required."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:90
msgid ""
"The function B<getfsspec>()  searches the file from the start and returns "
"the first entry found for which the I<fs_spec> field matches the "
"I<special_file> argument."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:99
msgid ""
"The function B<getfsfile>()  searches the file from the start and returns "
"the first entry found for which the I<fs_file> field matches the "
"I<mount_point> argument."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR getfsent ()
#.  function appeared in 4.0BSD; the other four functions appeared in 4.3BSD.
#. type: Plain text
#: build/C/man3/getfsent.3:115
msgid ""
"Upon success, the functions B<getfsent>(), B<getfsfile>(), and "
"B<getfsspec>()  return a pointer to a I<struct fstab>, while B<setfsent>()  "
"returns 1.  Upon failure or end-of-file, these functions return NULL and 0, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:127
msgid ""
"These functions are not in POSIX.1-2001.  Several operating systems have "
"them, for example, *BSD, SunOS, Digital UNIX, AIX (which also has a "
"B<getfstype>()).  HP-UX has functions of the same names, that however use a "
"I<struct checklist> instead of a I<struct fstab>, and calls these functions "
"obsolete, superseded by B<getmntent>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:129
msgid "These functions are not thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:139
msgid ""
"Since Linux allows mounting a block special device in several places, and "
"since several devices can have the same mount point, where the last device "
"with a given mount point is the interesting one, while B<getfsfile>()  and "
"B<getfsspec>()  only return the first occurrence, these two functions are "
"not suitable for use under Linux."
msgstr ""

#. type: Plain text
#: build/C/man3/getfsent.3:142
msgid "B<getmntent>(3), B<fstab>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getmntent.3:32
#, no-wrap
msgid "GETMNTENT"
msgstr ""

#. type: TH
#: build/C/man3/getmntent.3:32
#, no-wrap
msgid "2015-01-22"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:36
msgid ""
"getmntent, setmntent, addmntent, endmntent, hasmntopt, getmntent_r - get "
"filesystem descriptor file entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:40
#, no-wrap
msgid ""
"B<#include E<lt>stdio.hE<gt>>\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:42
#, no-wrap
msgid "B<FILE *setmntent(const char *>I<filename>B<, const char *>I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:44
#, no-wrap
msgid "B<struct mntent *getmntent(FILE *>I<stream>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:46
#, no-wrap
msgid "B<int addmntent(FILE *>I<stream>B<, const struct mntent *>I<mnt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:48
#, no-wrap
msgid "B<int endmntent(FILE *>I<streamp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:50
#, no-wrap
msgid "B<char *hasmntopt(const struct mntent *>I<mnt>B<, const char *>I<opt>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:53
#, no-wrap
msgid ""
"/* GNU extension */\n"
"B<#include E<lt>mntent.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:56
#, no-wrap
msgid ""
"B<struct mntent *getmntent_r(FILE *>I<streamp>B<, struct mntent "
"*>I<mntbuf>B<,>\n"
"B<                           char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:61 build/C/man3/isfdtype.3:40 build/C/man2/stat.2:68
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:65
msgid "B<getmntent_r>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:70
msgid ""
"These routines are used to access the filesystem description file "
"I</etc/fstab> and the mounted filesystem description file I</etc/mtab>."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:84
msgid ""
"The B<setmntent>()  function opens the filesystem description file "
"I<filename> and returns a file pointer which can be used by B<getmntent>().  "
"The argument I<type> is the type of access required and can take the same "
"values as the I<mode> argument of B<fopen>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:96
msgid ""
"The B<getmntent>()  function reads the next line of the filesystem "
"description file from I<stream> and returns a pointer to a structure "
"containing the broken out fields from a line in the file.  The pointer "
"points to a static area of memory which is overwritten by subsequent calls "
"to B<getmntent>()."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:106
msgid ""
"The B<addmntent>()  function adds the I<mntent> structure I<mnt> to the end "
"of the open I<stream>."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:112
msgid ""
"The B<endmntent>()  function closes the I<stream> associated with the "
"filesystem description file."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:129
msgid ""
"The B<hasmntopt>()  function scans the I<mnt_opts> field (see below)  of the "
"I<mntent> structure I<mnt> for a substring that matches I<opt>.  See "
"I<E<lt>mntent.hE<gt>> and B<mount>(8)  for valid mount options."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:143
msgid ""
"The reentrant B<getmntent_r>()  function is similar to B<getmntent>(), but "
"stores the I<struct mount> in the provided I<*mntbuf> and stores the strings "
"pointed to by the entries in that struct in the provided array I<buf> of "
"size I<buflen>."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:149
msgid "The I<mntent> structure is defined in I<E<lt>mntent.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:160
#, no-wrap
msgid ""
"struct mntent {\n"
"    char *mnt_fsname;   /* name of mounted filesystem */\n"
"    char *mnt_dir;      /* filesystem path prefix */\n"
"    char *mnt_type;     /* mount type (see mntent.h) */\n"
"    char *mnt_opts;     /* mount options (see mntent.h) */\n"
"    int   mnt_freq;     /* dump frequency in days */\n"
"    int   mnt_passno;   /* pass number on parallel fsck */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:175
msgid ""
"Since fields in the mtab and fstab files are separated by whitespace, octal "
"escapes are used to represent the four characters space (\\e040), tab "
"(\\e011), newline (\\e012) and backslash (\\e134) in those files when they "
"occur in one of the four strings in a I<mntent> structure.  The routines "
"B<addmntent>()  and B<getmntent>()  will convert from string representation "
"to escaped representation and back."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:184
msgid ""
"The B<getmntent>()  and B<getmntent_r>()  functions return a pointer to the "
"I<mntent> structure or NULL on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:188
msgid "The B<addmntent>()  function returns 0 on success and 1 on failure."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:192
msgid "The B<endmntent>()  function always returns 1."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:197
msgid ""
"The B<hasmntopt>()  function returns the address of the substring if a match "
"is found and NULL otherwise."
msgstr ""

#. type: SH
#: build/C/man3/getmntent.3:197 build/C/man2/spu_create.2:240
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:201
#, no-wrap
msgid ""
"/etc/fstab          filesystem description file\n"
"/etc/mtab           mounted filesystem description file\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:208
msgid ""
"The nonreentrant functions are from SunOS 4.1.3.  A routine B<getmntent_r>()  "
"was introduced in HP-UX 10, but it returns an int.  The prototype shown "
"above is glibc-only."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:220
msgid ""
"System V also has a B<getmntent>()  function but the calling sequence "
"differs, and the returned structure is different.  Under System V "
"I</etc/mnttab> is used.  4.4BSD and Digital UNIX have a routine "
"B<getmntinfo>(), a wrapper around the system call B<getfsstat>()."
msgstr ""

#. type: Plain text
#: build/C/man3/getmntent.3:224
msgid "B<fopen>(3), B<fstab>(5), B<mount>(8)"
msgstr ""

#. type: TH
#: build/C/man2/getxattr.2:25
#, no-wrap
msgid "GETXATTR"
msgstr ""

#. type: TH
#: build/C/man2/getxattr.2:25
#, no-wrap
msgid "2014-04-06"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:28
msgid "getxattr, lgetxattr, fgetxattr - retrieve an extended attribute value"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:33 build/C/man2/listxattr.2:33 build/C/man2/removexattr.2:33 build/C/man2/setxattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/xattr.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:40
#, no-wrap
msgid ""
"B<ssize_t getxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t lgetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
"B<ssize_t fgetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<                 void\\ *>I<value>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:53 build/C/man2/setxattr.2:53
msgid ""
"Extended attributes are I<name>:I<value> pairs associated with inodes "
"(files, directories, symbolic links, etc.).  They are extensions to the "
"normal attributes which are associated with all inodes in the system (i.e., "
"the B<stat>(2)  data).  A complete overview of extended attributes concepts "
"can be found in B<attr>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:65
msgid ""
"B<getxattr>()  retrieves the I<value> of the extended attribute identified "
"by I<name> and associated with the given I<path> in the filesystem.  The "
"length of the attribute I<value> is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:71
msgid ""
"B<lgetxattr>()  is identical to B<getxattr>(), except in the case of a "
"symbolic link, where the link itself is interrogated, not the file that it "
"refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:81
msgid ""
"B<fgetxattr>()  is identical to B<getxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:89
msgid ""
"An extended attribute I<name> is a simple null-terminated string.  The name "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The value of an extended attribute is "
"a chunk of arbitrary textual or binary data of specified length."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:96
msgid ""
"An empty buffer of I<size> zero can be passed into these calls to return the "
"current size of the named extended attribute, which can be used to estimate "
"the size of a buffer which is sufficiently large to hold the value "
"associated with the extended attribute."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:100
msgid ""
"The interface is designed to allow guessing of initial buffer sizes, and to "
"enlarge buffers when the return value indicates that the buffer provided was "
"too small."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:106
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute value.  On failure, -1 is returned and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:107 build/C/man2/removexattr.2:84 build/C/man2/setxattr.2:119
#, no-wrap
msgid "B<ENOATTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:116
msgid ""
"The named attribute does not exist, or the process has no access to this "
"attribute.  (B<ENOATTR> is defined to be a synonym for B<ENODATA> in "
"I<E<lt>attr/xattr.hE<gt>>.)"
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:116 build/C/man2/listxattr.2:128 build/C/man2/removexattr.2:92 build/C/man2/setxattr.2:131
#, no-wrap
msgid "B<ENOTSUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:119 build/C/man2/listxattr.2:131 build/C/man2/removexattr.2:95
msgid "Extended attributes are not supported by the filesystem, or are disabled."
msgstr ""

#. type: TP
#: build/C/man2/getxattr.2:119 build/C/man2/listxattr.2:131
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:126
msgid "The I<size> of the I<value> buffer is too small to hold the result."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:130 build/C/man2/listxattr.2:142 build/C/man2/removexattr.2:99 build/C/man2/setxattr.2:141
msgid "In addition, the errors documented in B<stat>(2)  can also occur."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:133 build/C/man2/listxattr.2:145 build/C/man2/removexattr.2:102 build/C/man2/setxattr.2:144
msgid ""
"These system calls have been available on Linux since kernel 2.4; glibc "
"support is provided since version 2.3."
msgstr ""

#.  .SH AUTHORS
#.  Andreas Gruenbacher,
#.  .RI < a.gruenbacher@computer.org >
#.  and the SGI XFS development team,
#.  .RI < linux-xfs@oss.sgi.com >.
#.  Please send any bug reports or comments to these addresses.
#. type: Plain text
#: build/C/man2/getxattr.2:141 build/C/man2/listxattr.2:153 build/C/man2/removexattr.2:110 build/C/man2/setxattr.2:152
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/getxattr.2:151
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man3/isfdtype.3:26
#, no-wrap
msgid "ISFDTYPE"
msgstr ""

#. type: TH
#: build/C/man3/isfdtype.3:26
#, no-wrap
msgid "2014-03-13"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:29
msgid "isfdtype - test file type of a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:35
#, no-wrap
msgid "B<int isfdtype(int >I<fd>B<, int >I<fdtype>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:43
msgid "B<isfdtype>():"
msgstr ""

#. type: TP
#: build/C/man3/isfdtype.3:46
#, no-wrap
msgid "Since glibc 2.20:"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:49
msgid "_DEFAULT_SOURCE"
msgstr ""

#. type: TP
#: build/C/man3/isfdtype.3:49
#, no-wrap
msgid "Before glibc 2.20:"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:52
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:72
msgid ""
"The B<isfdtype>()  function tests whether the file descriptor I<fd> refers "
"to a file of type I<fdtype>.  The I<fdtype> argument specifies one of the "
"B<S_IF*> constants defined in I<E<lt>sys/stat.hE<gt>> and documented in "
"B<stat>(2)  (e.g., B<S_IFREG>)."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:83
msgid ""
"The B<isfdtype>()  function returns 1 if the file descriptor I<fd> is of "
"type I<fdtype> and 0 if it is not.  On error, -1 is returned and I<errno> is "
"set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:88
msgid ""
"The B<isfdtype>()  function can fail with any of the same errors as "
"B<fstat>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:98
msgid ""
"The B<isfdtype>()  function is not specified in any standard, but did appear "
"in the draft POSIX.1g standard.  It is present on OpenBSD and Tru64 UNIX "
"(where the required header file in both cases is just "
"I<E<lt>sys/stat.hE<gt>>, as shown in the POSIX.1g draft), and possibly other "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:102
msgid "Portable applications should use B<fstat>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/isfdtype.3:104
msgid "B<fstat>(3)"
msgstr ""

#. type: TH
#: build/C/man2/listxattr.2:25
#, no-wrap
msgid "LISTXATTR"
msgstr ""

#. type: TH
#: build/C/man2/listxattr.2:25 build/C/man2/removexattr.2:25 build/C/man2/setxattr.2:25
#, no-wrap
msgid "2014-02-06"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:28
msgid "listxattr, llistxattr, flistxattr - list extended attribute names"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:39
#, no-wrap
msgid ""
"B<ssize_t listxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
"B<ssize_t llistxattr(const char\\ *>I<path>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
"B<ssize_t flistxattr(int >I<fd>B<, char\\ *>I<list>B<, size_t "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:50
msgid ""
"Extended attributes are name:value pairs associated with inodes (files, "
"directories, symbolic links, etc.).  They are extensions to the normal "
"attributes which are associated with all inodes in the system (i.e., the "
"B<stat>(2)  data).  A complete overview of extended attributes concepts can "
"be found in B<attr>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:66
msgid ""
"B<listxattr>()  retrieves the list of extended attribute names associated "
"with the given I<path> in the filesystem.  The retrieved list is placed in "
"I<list>, a caller-allocated buffer whose size (in bytes) is specified in the "
"argument I<size>.  The list is the set of (null-terminated) names, one after "
"the other.  Names of extended attributes to which the calling process does "
"not have access may be omitted from the list.  The length of the attribute "
"name I<list> is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:73
msgid ""
"B<llistxattr>()  is identical to B<listxattr>(), except in the case of a "
"symbolic link, where the list of names of extended attributes associated "
"with the link itself is retrieved, not the file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:83
msgid ""
"B<flistxattr>()  is identical to B<listxattr>(), only the open file referred "
"to by I<fd> (as returned by B<open>(2))  is interrogated in place of "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:89
msgid ""
"A single extended attribute I<name> is a simple null-terminated string.  The "
"name includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:95
msgid ""
"An empty buffer of I<size> zero can be passed into these calls to return the "
"current size of the list of extended attribute names, which can be used to "
"estimate the size of a buffer which is sufficiently large to hold the list "
"of names."
msgstr ""

#. type: SS
#: build/C/man2/listxattr.2:95
#, no-wrap
msgid "Example"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:100
msgid ""
"The I<list> of names is returned as an unordered array of null-terminated "
"character strings (attribute names are separated by null bytes "
"(\\(aq\\e0\\(aq)), like this:"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:105
#, no-wrap
msgid "user.name1\\e0system.name1\\e0user.name2\\e0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:113
msgid ""
"Filesystems like ext2, ext3 and XFS which implement POSIX ACLs using "
"extended attributes, might return a I<list> like this:"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:118
#, no-wrap
msgid "system.posix_acl_access\\e0system.posix_acl_default\\e0\n"
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:127
msgid ""
"On success, a nonnegative number is returned indicating the size of the "
"extended attribute name list.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:138
msgid "The I<size> of the I<list> buffer is too small to hold the result."
msgstr ""

#. type: Plain text
#: build/C/man2/listxattr.2:163
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<open>(2), "
"B<removexattr>(2), B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mount.2:40
#, no-wrap
msgid "MOUNT"
msgstr ""

#. type: TH
#: build/C/man2/mount.2:40
#, no-wrap
msgid "2014-09-21"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:43
msgid "mount - mount filesystem"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:46 build/C/man2/umount.2:36
#, no-wrap
msgid "B<#include E<lt>sys/mount.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:50
#, no-wrap
msgid ""
"B<int mount(const char *>I<source>B<, const char *>I<target>B<,>\n"
"B<          const char *>I<filesystemtype>B<, unsigned long "
">I<mountflags>B<,>\n"
"B<          const void *>I<data>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:58
msgid ""
"B<mount>()  attaches the filesystem specified by I<source> (which is often a "
"device name, but can also be a directory name or a dummy) to the directory "
"specified by I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:62
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to mount filesystems."
msgstr ""

#.  Multiple mounts on same mount point: since 2.3.99pre7.
#. type: Plain text
#: build/C/man2/mount.2:67
msgid ""
"Since Linux 2.4 a single filesystem can be visible at multiple mount points, "
"and multiple mounts can be stacked on the same mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:76
msgid ""
"Values for the I<filesystemtype> argument supported by the kernel are listed "
"in I</proc/filesystems> (e.g., \"minix\", \"ext2\", \"ext3\", \"jfs\", "
"\"xfs\", \"reiserfs\", \"msdos\", \"proc\", \"nfs\", \"iso9660\").  Further "
"types may become available when the appropriate modules are loaded."
msgstr ""

#.  (as defined in \fI<linux/fs.h>\fP for libc4 and libc5
#.  and in \fI<sys/mount.h>\fP for glibc2)
#.  FIXME 2.6.15 added flags for "shared subtree" functionality:
#.  MS_UNBINDABLE, MS_PRIVATE, MS_SHARED, MS_SLAVE
#
#. 	MS_PRIVATE.
#. 		All mounts are private by default. Previously shared mounts
#. 		can be remarked PRIVATE.
#. 	MS_SHARED
#. 		Mount points that are marked SHARED propagate mount events
#. 		to one another after bing cloned.
#. 	MS_SLAVE
#. 		A previously shared mount point can be marked SALVE, meaning
#. 		it receives propagated events, but does not propagate events.
#. 	MS_UNBINDABLE
#. 		mounts cannot be bound into other places, and will not be
#. 		propagated into new subtrees	
#. 	mount --make-rshared ==> MS_SHARED | MS_REC
#
#.  These settings are visible in proc/mountinfo
#
#.  These need to be documented on this page.
#.  See:
#.  Documentation/filesystems/sharedsubtree.txt
#
#.  http://lwn.net/Articles/159077/
#
#.  http://myweb.sudhaa.com:2022/~ram/sharedsubtree/paper/sharedsubtree.1.pdf
#.  Shared-Subtree Concept, Implementation, and Applications in Linux
#.  Al Viro viro@ftp.linux.org.uk
#.  Ram Pai linuxram@us.ibm.com
#
#.  http://foss.in/2005/slides/sharedsubtree1.pdf
#.  Shared Subtree Concept and Implementation in the Linux Kernel
#.  Ram Pai
#
#.  http://www.ibm.com/developerworks/linux/library/l-mount-namespaces/index.html
#.      Applying mount namespaces
#
#.      Uncover practical applications for advanced Linux mounts features
#.      Serge E. Hallyn (sergeh@us.ibm.com), Software Engineer, IBM
#.      Ram Pai (linuxram@us.ibm.com), Software Engineer, IBM
#.      Date:  17 Sep 2007
#
#.  FIXME 2.6.25 Added MS_I_VERSION, which needs to be documented.
#. type: Plain text
#: build/C/man2/mount.2:130
msgid ""
"The I<mountflags> argument may have the magic number 0xC0ED (B<MS_MGC_VAL>)  "
"in the top 16 bits (this was required in kernel versions prior to 2.4, but "
"is no longer required and ignored if specified), and various mount flags in "
"the low order 16 bits:"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:130
#, no-wrap
msgid "B<MS_BIND> (Linux 2.4 onward)"
msgstr ""

#.  since 2.4.0-test9
#.  with the exception of the "hidden" MS_REC mountflags bit
#. type: Plain text
#: build/C/man2/mount.2:149
msgid ""
"Perform a bind mount, making a file or a directory subtree visible at "
"another point within a filesystem.  Bind mounts may cross filesystem "
"boundaries and span B<chroot>(2)  jails.  The I<filesystemtype> and I<data> "
"arguments are ignored.  Up until Linux 2.6.26, I<mountflags> was also "
"ignored (the bind mount has the same mount options as the underlying mount "
"point)."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:149
#, no-wrap
msgid "B<MS_DIRSYNC> (since Linux 2.5.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:155
msgid ""
"Make directory changes on this filesystem synchronous.  (This property can "
"be obtained for individual directories or subtrees using B<chattr>(1).)"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:155
#, no-wrap
msgid "B<MS_MANDLOCK>"
msgstr ""

#.  FIXME Describe the MS_MOVE flag in more detail
#. type: Plain text
#: build/C/man2/mount.2:162
msgid ""
"Permit mandatory locking on files in this filesystem.  (Mandatory locking "
"must still be enabled on a per-file basis, as described in B<fcntl>(2).)"
msgstr ""

#. type: TP
#: build/C/man2/mount.2:162
#, no-wrap
msgid "B<MS_MOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:173
msgid ""
"Move a subtree.  I<source> specifies an existing mount point and I<target> "
"specifies the new location.  The move is atomic: at no point is the subtree "
"unmounted.  The I<filesystemtype>, I<mountflags>, and I<data> arguments are "
"ignored."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:173
#, no-wrap
msgid "B<MS_NOATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:176
msgid "Do not update access times for (all types of) files on this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:176
#, no-wrap
msgid "B<MS_NODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:179
msgid "Do not allow access to devices (special files) on this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:179
#, no-wrap
msgid "B<MS_NODIRATIME>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:188
msgid ""
"Do not update access times for directories on this filesystem.  This flag "
"provides a subset of the functionality provided by B<MS_NOATIME>; that is, "
"B<MS_NOATIME> implies B<MS_NODIRATIME>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:188
#, no-wrap
msgid "B<MS_NOEXEC>"
msgstr ""

#.  (Possibly useful for a filesystem that contains non-Linux executables.
#.  Often used as a security feature, e.g., to make sure that restricted
#.  users cannot execute files uploaded using ftp or so.)
#. type: Plain text
#: build/C/man2/mount.2:194
msgid "Do not allow programs to be executed from this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:194
#, no-wrap
msgid "B<MS_NOSUID>"
msgstr ""

#.  (This is a security feature to prevent users executing set-user-ID and
#.  set-group-ID programs from removable disk devices.)
#. type: Plain text
#: build/C/man2/mount.2:200
msgid ""
"Do not honor set-user-ID and set-group-ID bits when executing programs from "
"this filesystem."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:200
#, no-wrap
msgid "B<MS_RDONLY>"
msgstr ""

#
#.  FIXME Document MS_REC, available since 2.4.11.
#.  This flag has meaning in conjunction with MS_BIND and
#.  also with the shared subtree flags.
#. type: Plain text
#: build/C/man2/mount.2:207
msgid "Mount filesystem read-only."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:207
#, no-wrap
msgid "B<MS_RELATIME> (since Linux 2.6.20)"
msgstr ""

#.  Matthew Garrett notes in the patch that added this behavior
#.  that this lets utilities such as tmpreaper (which deletes
#.  files based on last access time) work correctly.
#. type: Plain text
#: build/C/man2/mount.2:228
msgid ""
"When a file on this filesystem is accessed, update the file's last access "
"time (atime) only if the current value of atime is less than or equal to the "
"file's last modification time (mtime)  or last status change time (ctime).  "
"This option is useful for programs, such as B<mutt>(1), that need to know "
"when a file has been read since it was last modified.  Since Linux 2.6.30, "
"the kernel defaults to the behavior provided by this flag (unless "
"B<MS_NOATIME> was specified), and the B<MS_STRICTATIME> flag is required to "
"obtain traditional semantics.  In addition, since Linux 2.6.30, the file's "
"last access time is always updated if it is more than 1 day old."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:228
#, no-wrap
msgid "B<MS_REMOUNT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:251
msgid ""
"Remount an existing mount.  This allows you to change the I<mountflags> and "
"I<data> of an existing mount without having to unmount and remount the "
"filesystem.  I<target> should be the same value specified in the initial "
"B<mount>()  call; I<source> and I<filesystemtype> are ignored.  The "
"I<mountflags> and I<data> arguments should match the values used in the "
"original B<mount>()  call, except for those parameters that are being "
"deliberately changed."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:266
msgid ""
"The following I<mountflags> can be changed: B<MS_RDONLY>, B<MS_SYNCHRONOUS>, "
"B<MS_MANDLOCK>; before kernel 2.6.16, the following could also be changed: "
"B<MS_NOATIME> and B<MS_NODIRATIME>; and, additionally, before kernel 2.4.10, "
"the following could also be changed: B<MS_NOSUID>, B<MS_NODEV>, "
"B<MS_NOEXEC>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:266
#, no-wrap
msgid "B<MS_SILENT> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:274
msgid ""
"Suppress the display of certain (I<printk>())  warning messages in the "
"kernel log.  This flag supersedes the misnamed and obsolete B<MS_VERBOSE> "
"flag (available since Linux 2.4.12), which has the same meaning."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:274
#, no-wrap
msgid "B<MS_STRICTATIME> (since Linux 2.6.30)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:284
msgid ""
"Always update the last access time (atime) when files on this filesystem are "
"accessed.  (This was the default behavior before Linux 2.6.30.)  Specifying "
"this flag overrides the effect of setting the B<MS_NOATIME> and "
"B<MS_RELATIME> flags."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:284
#, no-wrap
msgid "B<MS_SYNCHRONOUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:292
msgid ""
"Make writes on this filesystem synchronous (as though the B<O_SYNC> flag to "
"B<open>(2)  was specified for all file opens to this filesystem)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:304
msgid ""
"From Linux 2.4 onward, the B<MS_NODEV>, B<MS_NOEXEC>, and B<MS_NOSUID> flags "
"are settable on a per-mount-point basis.  From kernel 2.6.16 onward, "
"B<MS_NOATIME> and B<MS_NODIRATIME> are also settable on a per-mount-point "
"basis.  The B<MS_RELATIME> flag is also settable on a per-mount-point basis."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:313
msgid ""
"The I<data> argument is interpreted by the different filesystems.  Typically "
"it is a string of comma-separated options understood by this filesystem.  "
"See B<mount>(8)  for details of the options available for each filesystem "
"type."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:318 build/C/man2/stat.2:522 build/C/man2/statfs.2:162 build/C/man3/statvfs.3:101 build/C/man2/umount.2:104
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:324 build/C/man2/umount.2:110
msgid ""
"The error values given below result from filesystem type independent "
"errors.  Each filesystem type may have its own special errors and its own "
"special behavior.  See the Linux kernel source code for details."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:324 build/C/man2/spu_create.2:173 build/C/man2/stat.2:523 build/C/man2/statfs.2:163 build/C/man3/statvfs.3:102
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#.  mtk: Probably: write permission is required for MS_BIND, with
#.  the error EPERM if not present; CAP_DAC_OVERRIDE is required.
#. type: Plain text
#: build/C/man2/mount.2:339
msgid ""
"A component of a path was not searchable.  (See also B<path_resolution>(7).)  "
"Or, mounting a read-only filesystem was attempted without giving the "
"B<MS_RDONLY> flag.  Or, the block device I<source> is located on a "
"filesystem mounted with the B<MS_NODEV> option."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:339 build/C/man2/umount.2:117
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:351
msgid ""
"I<source> is already mounted.  Or, it cannot be remounted read-only, because "
"it still holds files open for writing.  Or, it cannot be mounted on "
"I<target> because I<target> is still busy (it is the working directory of "
"some thread, the mount point of another device, has open files, etc.)."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:351 build/C/man2/spu_create.2:181 build/C/man2/spu_run.2:158 build/C/man2/stat.2:534 build/C/man2/statfs.2:175 build/C/man3/statvfs.3:114 build/C/man2/sysfs.2:80 build/C/man2/umount.2:121 build/C/man2/ustat.2:80
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:354
msgid "One of the pointer arguments points outside the user address space."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:369
msgid ""
"I<source> had an invalid superblock.  Or, a remount (B<MS_REMOUNT>)  was "
"attempted, but I<source> was not already mounted on I<target>.  Or, a move "
"(B<MS_MOVE>)  was attempted, but I<source> was not a mount point, or was "
"\\(aq/\\(aq."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:369 build/C/man2/spu_create.2:192 build/C/man2/stat.2:537 build/C/man2/statfs.2:187 build/C/man3/statvfs.3:126
#, no-wrap
msgid "B<ELOOP>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:376
msgid ""
"Too many links encountered during pathname resolution.  Or, a move was "
"attempted, while I<target> is a descendant of I<source>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:376 build/C/man2/spu_create.2:196
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:380
msgid "(In case no block device is required:)  Table of dummy devices is full."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:380 build/C/man2/spu_create.2:199 build/C/man2/stat.2:540 build/C/man2/statfs.2:192 build/C/man3/statvfs.3:131 build/C/man2/umount.2:143
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:384 build/C/man2/umount.2:147
msgid "A pathname was longer than B<MAXPATHLEN>."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:384 build/C/man2/spu_create.2:206
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:388
msgid "I<filesystemtype> not configured in the kernel."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:388 build/C/man2/spu_create.2:210 build/C/man2/stat.2:544 build/C/man2/statfs.2:197 build/C/man3/statvfs.3:136 build/C/man2/umount.2:147
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:391 build/C/man2/umount.2:150
msgid "A pathname was empty or had a nonexistent component."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:391 build/C/man2/spu_create.2:215 build/C/man2/spu_run.2:179 build/C/man2/stat.2:551 build/C/man2/statfs.2:203 build/C/man3/statvfs.3:142 build/C/man2/umount.2:150
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:394 build/C/man2/umount.2:153
msgid "The kernel could not allocate a free page to copy filenames or data into."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:394
#, no-wrap
msgid "B<ENOTBLK>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:398
msgid "I<source> is not a block device (and a device was required)."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:398 build/C/man2/spu_create.2:228 build/C/man2/stat.2:554 build/C/man2/stat.2:589 build/C/man2/statfs.2:209 build/C/man3/statvfs.3:148
#, no-wrap
msgid "B<ENOTDIR>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:404
msgid "I<target>, or a prefix of I<source>, is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:404
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:409
msgid "The major number of the block device I<source> is out of range."
msgstr ""

#. type: TP
#: build/C/man2/mount.2:409 build/C/man2/spu_create.2:233 build/C/man2/umount.2:153
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:412 build/C/man2/umount.2:156
msgid "The caller does not have the required privileges."
msgstr ""

#.  FIXME . Definitions of the so-far-undocumented MS_UNBINDABLE, MS_PRIVATE,
#.  MS_SHARED, and MS_SLAVE were (also) only added to glibc headers in 2.12.
#. type: Plain text
#: build/C/man2/mount.2:423
msgid ""
"The definitions of B<MS_DIRSYNC>, B<MS_MOVE>, B<MS_REC>, B<MS_RELATIME>, and "
"B<MS_STRICTATIME> were added to glibc headers in version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:426
msgid ""
"This function is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:435
msgid ""
"The original B<MS_SYNC> flag was renamed B<MS_SYNCHRONOUS> in 1.1.69 when a "
"different B<MS_SYNC> was added to I<E<lt>mman.hE<gt>>."
msgstr ""

#.  The change is in patch-2.4.0-prerelease.
#. type: Plain text
#: build/C/man2/mount.2:444
msgid ""
"Before Linux 2.4 an attempt to execute a set-user-ID or set-group-ID program "
"on a filesystem mounted with B<MS_NOSUID> would fail with B<EPERM>.  Since "
"Linux 2.4 the set-user-ID and set-group-ID bits are just silently ignored in "
"this case."
msgstr ""

#. type: SS
#: build/C/man2/mount.2:444
#, no-wrap
msgid "Per-process namespaces"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:455
msgid ""
"Starting with kernel 2.4.19, Linux provides per-process mount namespaces.  A "
"mount namespace is the set of filesystem mounts that are visible to a "
"process.  Mount-point namespaces can be (and usually are)  shared between "
"multiple processes, and changes to the namespace (i.e., mounts and unmounts) "
"by one process are visible to all other processes sharing the same "
"namespace.  (The pre-2.4.19 Linux situation can be considered as one in "
"which a single namespace was shared by every process on the system.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:461
msgid ""
"A child process created by B<fork>(2)  shares its parent's mount namespace; "
"the mount namespace is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:481
msgid ""
"A process can obtain a private mount namespace if: it was created using the "
"B<clone>(2)  B<CLONE_NEWNS> flag, in which case its new namespace is "
"initialized to be a I<copy> of the namespace of the process that called "
"B<clone>(2); or it calls B<unshare>(2)  with the B<CLONE_NEWNS> flag, which "
"causes the caller's mount namespace to obtain a private copy of the "
"namespace that it was previously sharing with other processes, so that "
"future mounts and unmounts by the caller are invisible to other processes "
"(except child processes that the caller subsequently creates) and vice "
"versa."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:488
msgid ""
"The Linux-specific I</proc/PID/mounts> file exposes the list of mount points "
"in the mount namespace of the process with the specified ID; see B<proc>(5)  "
"for details."
msgstr ""

#. type: Plain text
#: build/C/man2/mount.2:495
msgid ""
"B<umount>(2), B<namespaces>(7), B<path_resolution>(7), B<lsblk>(8), "
"B<mount>(8), B<umount>(8)"
msgstr ""

#. type: TH
#: build/C/man7/path_resolution.7:25
#, no-wrap
msgid "PATH_RESOLUTION"
msgstr ""

#. type: TH
#: build/C/man7/path_resolution.7:25
#, no-wrap
msgid "2009-12-05"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:28
msgid "path_resolution - how a pathname is resolved to a file"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:31
msgid ""
"Some UNIX/Linux system calls have as parameter one or more filenames.  A "
"filename (or pathname) is resolved as follows."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:31
#, no-wrap
msgid "Step 1: start of the resolution process"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:50
msgid ""
"If the pathname starts with the \\(aq/\\(aq character, the starting lookup "
"directory is the root directory of the calling process.  (A process inherits "
"its root directory from its parent.  Usually this will be the root directory "
"of the file hierarchy.  A process may get a different root directory by use "
"of the B<chroot>(2)  system call.  A process may get an entirely private "
"mount namespace in case it\\(emor one of its ancestors\\(emwas started by an "
"invocation of the B<clone>(2)  system call that had the B<CLONE_NEWNS> flag "
"set.)  This handles the \\(aq/\\(aq part of the pathname."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:58
msgid ""
"If the pathname does not start with the \\(aq/\\(aq character, the starting "
"lookup directory of the resolution process is the current working directory "
"of the process.  (This is also inherited from the parent.  It can be changed "
"by use of the B<chdir>(2)  system call.)"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:61
msgid ""
"Pathnames starting with a \\(aq/\\(aq character are called absolute "
"pathnames.  Pathnames not starting with a \\(aq/\\(aq are called relative "
"pathnames."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:61
#, no-wrap
msgid "Step 2: walk along the path"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:66
msgid ""
"Set the current lookup directory to the starting lookup directory.  Now, for "
"each nonfinal component of the pathname, where a component is a substring "
"delimited by \\(aq/\\(aq characters, this component is looked up in the "
"current lookup directory."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:72
msgid ""
"If the process does not have search permission on the current lookup "
"directory, an B<EACCES> error is returned (\"Permission denied\")."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:77
msgid ""
"If the component is not found, an B<ENOENT> error is returned (\"No such "
"file or directory\")."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:82
msgid ""
"If the component is found, but is neither a directory nor a symbolic link, "
"an B<ENOTDIR> error is returned (\"Not a directory\")."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:86
msgid ""
"If the component is found and is a directory, we set the current lookup "
"directory to that directory, and go to the next component."
msgstr ""

#
#.  presently: max recursion depth during symlink resolution: 5
#.  max total number of symbolic links followed: 40
#.  _POSIX_SYMLOOP_MAX is 8
#. type: Plain text
#: build/C/man7/path_resolution.7:110
msgid ""
"If the component is found and is a symbolic link (symlink), we first resolve "
"this symbolic link (with the current lookup directory as starting lookup "
"directory).  Upon error, that error is returned.  If the result is not a "
"directory, an B<ENOTDIR> error is returned.  If the resolution of the "
"symlink is successful and returns a directory, we set the current lookup "
"directory to that directory, and go to the next component.  Note that the "
"resolution process here involves recursion.  In order to protect the kernel "
"against stack overflow, and also to protect against denial of service, there "
"are limits on the maximum recursion depth, and on the maximum number of "
"symbolic links followed.  An B<ELOOP> error is returned when the maximum is "
"exceeded (\"Too many levels of symbolic links\")."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:110
#, no-wrap
msgid "Step 3: find the final entry"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:122
msgid ""
"The lookup of the final component of the pathname goes just like that of all "
"other components, as described in the previous step, with two differences: "
"(i) the final component need not be a directory (at least as far as the path "
"resolution process is concerned\\(emit may have to be a directory, or a "
"nondirectory, because of the requirements of the specific system call), and "
"(ii) it is not necessarily an error if the component is not found\\(emmaybe "
"we are just creating it.  The details on the treatment of the final entry "
"are described in the manual pages of the specific system calls."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:122
#, no-wrap
msgid ". and .."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:126
msgid ""
"By convention, every directory has the entries \".\" and \"..\", which refer "
"to the directory itself and to its parent directory, respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:130
msgid ""
"The path resolution process will assume that these entries have their "
"conventional meanings, regardless of whether they are actually present in "
"the physical filesystem."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:132
msgid "One cannot walk down past the root: \"/..\" is the same as \"/\"."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:132
#, no-wrap
msgid "Mount points"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:136
msgid ""
"After a \"mount dev path\" command, the pathname \"path\" refers to the root "
"of the filesystem hierarchy on the device \"dev\", and no longer to whatever "
"it referred to earlier."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:140
msgid ""
"One can walk out of a mounted filesystem: \"path/..\" refers to the parent "
"directory of \"path\", outside of the filesystem hierarchy on \"dev\"."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:140
#, no-wrap
msgid "Trailing slashes"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:146
msgid ""
"If a pathname ends in a \\(aq/\\(aq, that forces resolution of the preceding "
"component as in Step 2: it has to exist and resolve to a directory.  "
"Otherwise, a trailing \\(aq/\\(aq is ignored.  (Or, equivalently, a pathname "
"with a trailing \\(aq/\\(aq is equivalent to the pathname obtained by "
"appending \\(aq.\\(aq to it.)"
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:146
#, no-wrap
msgid "Final symlink"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:155
msgid ""
"If the last component of a pathname is a symbolic link, then it depends on "
"the system call whether the file referred to will be the symbolic link or "
"the result of path resolution on its contents.  For example, the system call "
"B<lstat>(2)  will operate on the symlink, while B<stat>(2)  operates on the "
"file pointed to by the symlink."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:155
#, no-wrap
msgid "Length limit"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:162
msgid ""
"There is a maximum length for pathnames.  If the pathname (or some "
"intermediate pathname obtained while resolving symbolic links)  is too long, "
"an B<ENAMETOOLONG> error is returned (\"Filename too long\")."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:162
#, no-wrap
msgid "Empty pathname"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:169
msgid ""
"In the original UNIX, the empty pathname referred to the current directory.  "
"Nowadays POSIX decrees that an empty pathname must not be resolved "
"successfully.  Linux returns B<ENOENT> in this case."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:169
#, no-wrap
msgid "Permissions"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:182
msgid ""
"The permission bits of a file consist of three groups of three bits, cf.\\& "
"B<chmod>(1)  and B<stat>(2).  The first group of three is used when the "
"effective user ID of the calling process equals the owner ID of the file.  "
"The second group of three is used when the group ID of the file either "
"equals the effective group ID of the calling process, or is one of the "
"supplementary group IDs of the calling process (as set by B<setgroups>(2)).  "
"When neither holds, the third group is used."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:186
msgid ""
"Of the three bits used, the first bit determines read permission, the second "
"write permission, and the last execute permission in case of ordinary files, "
"or search permission in case of directories."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:191
msgid ""
"Linux uses the fsuid instead of the effective user ID in permission checks.  "
"Ordinarily the fsuid will equal the effective user ID, but the fsuid can be "
"changed by the system call B<setfsuid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:199
msgid ""
"(Here \"fsuid\" stands for something like \"filesystem user ID\".  The "
"concept was required for the implementation of a user space NFS server at a "
"time when processes could send a signal to a process with the same effective "
"user ID.  It is obsolete now.  Nobody should use B<setfsuid>(2).)"
msgstr ""

#.  FIXME . say something about filesystem mounted read-only ?
#. type: Plain text
#: build/C/man7/path_resolution.7:205
msgid ""
"Similarly, Linux uses the fsgid (\"filesystem group ID\")  instead of the "
"effective group ID.  See B<setfsgid>(2)."
msgstr ""

#. type: SS
#: build/C/man7/path_resolution.7:205
#, no-wrap
msgid "Bypassing permission checks: superuser and capabilities"
msgstr ""

#.  (but for exec at least one x bit must be set) -- AEB
#.  but there is variation across systems on this point: for
#.  example, HP-UX and Tru64 are as described by AEB.  However,
#.  on some implementations (e.g., Solaris, FreeBSD),
#.  access(X_OK) by superuser will report success, regardless
#.  of the file's execute permission bits. -- MTK (Oct 05)
#. type: Plain text
#: build/C/man7/path_resolution.7:216
msgid ""
"On a traditional UNIX system, the superuser (I<root>, user ID 0) is "
"all-powerful, and bypasses all permissions restrictions when accessing "
"files."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:224
msgid ""
"On Linux, superuser privileges are divided into capabilities (see "
"B<capabilities>(7)).  Two capabilities are relevant for file permissions "
"checks: B<CAP_DAC_OVERRIDE> and B<CAP_DAC_READ_SEARCH>.  (A process has "
"these capabilities if its fsuid is 0.)"
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:230
msgid ""
"The B<CAP_DAC_OVERRIDE> capability overrides all permission checking, but "
"grants execute permission only when at least one of the file's three execute "
"permission bits is set."
msgstr ""

#.  FIXME . say something about immutable files
#.  FIXME . say something about ACLs
#. type: Plain text
#: build/C/man7/path_resolution.7:237
msgid ""
"The B<CAP_DAC_READ_SEARCH> capability grants read and search permission on "
"directories, and read permission on ordinary files."
msgstr ""

#. type: Plain text
#: build/C/man7/path_resolution.7:242
msgid "B<readlink>(2), B<capabilities>(7), B<credentials>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/removexattr.2:25
#, no-wrap
msgid "REMOVEXATTR"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:28
msgid "removexattr, lremovexattr, fremovexattr - remove an extended attribute"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:37
#, no-wrap
msgid ""
"B<int removexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int lremovexattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<);>\n"
"B<int fremovexattr(int >I<fd>B<, const char\\ *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:49
msgid ""
"Extended attributes are I<name>:value pairs associated with inodes (files, "
"directories, symbolic links, etc.).  They are extensions to the normal "
"attributes which are associated with all inodes in the system (i.e., the "
"B<stat>(2)  data).  A complete overview of extended attributes concepts can "
"be found in B<attr>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:56
msgid ""
"B<removexattr>()  removes the extended attribute identified by I<name> and "
"associated with the given I<path> in the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:62
msgid ""
"B<lremovexattr>()  is identical to B<removexattr>(), except in the case of a "
"symbolic link, where the extended attribute is removed from the link itself, "
"not the file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:72
msgid ""
"B<fremovexattr>()  is identical to B<removexattr>(), only the extended "
"attribute is removed from the open file referred to by I<fd> (as returned by "
"B<open>(2))  in place of I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:78
msgid ""
"An extended attribute name is a simple null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:83 build/C/man2/setxattr.2:110
msgid ""
"On success, zero is returned.  On failure, -1 is returned and I<errno> is "
"set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:92
msgid ""
"The named attribute does not exist.  (B<ENOATTR> is defined to be a synonym "
"for B<ENODATA> in I<E<lt>attr/xattr.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/removexattr.2:120
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<setxattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/setxattr.2:25
#, no-wrap
msgid "SETXATTR"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:28
msgid "setxattr, lsetxattr, fsetxattr - set an extended attribute value"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:40
#, no-wrap
msgid ""
"B<int setxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
"B<int lsetxattr(const char\\ *>I<path>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
"B<int fsetxattr(int >I<fd>B<, const char\\ *>I<name>B<,>\n"
"B<              const void\\ *>I<value>B<, size_t >I<size>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:67
msgid ""
"B<setxattr>()  sets the I<value> of the extended attribute identified by "
"I<name> and associated with the given I<path> in the filesystem.  The "
"I<size> of the I<value> must be specified."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:73
msgid ""
"B<lsetxattr>()  is identical to B<setxattr>(), except in the case of a "
"symbolic link, where the extended attribute is set on the link itself, not "
"the file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:83
msgid ""
"B<fsetxattr>()  is identical to B<setxattr>(), only the extended attribute "
"is set on the open file referred to by I<fd> (as returned by B<open>(2))  in "
"place of I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:93
msgid ""
"An extended attribute name is a simple null-terminated string.  The I<name> "
"includes a namespace prefix; there may be several, disjoint namespaces "
"associated with an individual inode.  The I<value> of an extended attribute "
"is a chunk of arbitrary textual or binary data of specified length."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:105
msgid ""
"The I<flags> argument can be used to refine the semantics of the operation.  "
"B<XATTR_CREATE> specifies a pure create, which fails if the named attribute "
"exists already.  B<XATTR_REPLACE> specifies a pure replace operation, which "
"fails if the named attribute does not already exist.  By default (no flags), "
"the extended attribute will be created if need be, or will simply replace "
"the value if the attribute exists."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:111
#, no-wrap
msgid "B<EDQUOT>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:115
msgid ""
"Disk quota limits meant that there is insufficient space remaining to store "
"the extended attribute."
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:115 build/C/man2/spu_create.2:178
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:119
msgid "B<XATTR_CREATE> was specified, and the attribute exists already."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:128
msgid ""
"B<XATTR_REPLACE> was specified, and the attribute does not exist.  "
"(B<ENOATTR> is defined to be a synonym for B<ENODATA> in "
"I<E<lt>attr/xattr.hE<gt>>.)"
msgstr ""

#. type: TP
#: build/C/man2/setxattr.2:128 build/C/man2/spu_create.2:218
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:131
msgid "There is insufficient space remaining to store the extended attribute."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:137
msgid ""
"Extended attributes are not supported by the filesystem, or are disabled, "
"I<errno> is set to B<ENOTSUP>."
msgstr ""

#. type: Plain text
#: build/C/man2/setxattr.2:162
msgid ""
"B<getfattr>(1), B<setfattr>(1), B<getxattr>(2), B<listxattr>(2), B<open>(2), "
"B<removexattr>(2), B<stat>(2), B<attr>(5), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/spu_create.2:25
#, no-wrap
msgid "SPU_CREATE"
msgstr ""

#. type: TH
#: build/C/man2/spu_create.2:25 build/C/man2/spu_run.2:26
#, no-wrap
msgid "2012-08-05"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:28
msgid "spu_create - create a new spu context"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:32
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:36
#, no-wrap
msgid ""
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<);>\n"
"B<int spu_create(const char *>I<pathname>B<, int >I<flags>B<, mode_t "
">I<mode>B<,>\n"
"B<               int >I<neighbor_fd>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:40 build/C/man2/spu_run.2:39
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:59
msgid ""
"The B<spu_create>()  system call is used on PowerPC machines that implement "
"the Cell Broadband Engine Architecture in order to access Synergistic "
"Processor Units (SPUs).  It creates a new logical context for an SPU in "
"I<pathname> and returns a file descriptor associated with it.  I<pathname> "
"must refer to a nonexistent directory in the mount point of the SPU "
"filesystem (B<spufs>).  If B<spu_create>()  is successful, a directory is "
"created at I<pathname> and it is populated with the files described in "
"B<spufs>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:78
msgid ""
"When a context is created, the returned file descriptor can only be passed "
"to B<spu_run>(2), used as the I<dirfd> argument to the B<*at> family of "
"system calls (e.g., B<openat>(2)), or closed; other operations are not "
"defined.  A logical SPU context is destroyed (along with all files created "
"within the context's I<pathname> directory) once the last reference to the "
"context has gone; this usually occurs when the file descriptor returned by "
"B<spu_create>()  is closed."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:83
msgid ""
"The I<flags> argument can be zero or any bitwise OR-ed combination of the "
"following constants:"
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:83
#, no-wrap
msgid "B<SPU_CREATE_EVENTS_ENABLED>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:89
msgid ""
"Rather than using signals for reporting DMA errors, use the I<event> "
"argument to B<spu_run>(2)."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:89
#, no-wrap
msgid "B<SPU_CREATE_GANG>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:97
msgid ""
"Create an SPU gang instead of a context.  (A gang is a group of SPU contexts "
"that are functionally related to each other and which share common "
"scheduling parameters\\(empriority and policy.  In the future, gang "
"scheduling may be implemented causing the group to be switched in and out as "
"a single unit.)"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:104
msgid ""
"A new directory will be created at the location specified by the I<pathname> "
"argument.  This gang may be used to hold other SPU contexts, by providing a "
"pathname that is within the gang directory to further calls to "
"B<spu_create>()."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:104
#, no-wrap
msgid "B<SPU_CREATE_NOSCHED>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:110
msgid ""
"Create a context that is not affected by the SPU scheduler.  Once the "
"context is run, it will not be scheduled out until it is destroyed by the "
"creating process."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:121
msgid ""
"Because the context cannot be removed from the SPU, some functionality is "
"disabled for B<SPU_CREATE_NOSCHED> contexts.  Only a subset of the files "
"will be available in this context directory in B<spufs>.  Additionally, "
"B<SPU_CREATE_NOSCHED> contexts cannot dump a core file when crashing."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:127
msgid ""
"Creating B<SPU_CREATE_NOSCHED> contexts requires the B<CAP_SYS_NICE> "
"capability."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:127
#, no-wrap
msgid "B<SPU_CREATE_ISOLATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:134
msgid ""
"Create an isolated SPU context.  Isolated contexts are protected from some "
"PPE (PowerPC Processing Element)  operations, such as access to the SPU "
"local store and the NPC register."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:140
msgid ""
"Creating B<SPU_CREATE_ISOLATE> contexts also requires the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:140
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_SPU>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:148
msgid ""
"Create a context with affinity to another SPU context.  This affinity "
"information is used within the SPU scheduling algorithm.  Using this flag "
"requires that a file descriptor referring to the other SPU context be passed "
"in the I<neighbor_fd> argument."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:148
#, no-wrap
msgid "B<SPU_CREATE_AFFINITY_MEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:153
msgid ""
"Create a context with affinity to system memory.  This affinity information "
"is used within the SPU scheduling algorithm."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:165
msgid ""
"The I<mode> argument (minus any bits set in the process's B<umask>(2))  "
"specifies the permissions used for creating the new directory in B<spufs>.  "
"See B<stat>(2)  for a full list of the possible I<mode> values."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:172
msgid ""
"On success, B<spu_create>()  returns a new file descriptor.  On error, -1 is "
"returned, and I<errno> is set to one of the error codes listed below."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:178
msgid "The current user does not have write access to the B<spufs>(7)  mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:181
msgid "An SPU context already exists at the given pathname."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:186
msgid ""
"I<pathname> is not a valid string pointer in the calling process's address "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:192
msgid ""
"I<pathname> is not a directory in the B<spufs>(7)  mount point, or invalid "
"flags have been provided."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:196
msgid "Too many symbolic links were found while resolving I<pathname>."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:199
msgid "The process has reached its maximum open files limit."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:203 build/C/man2/stat.2:544
msgid "I<pathname> is too long."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:203
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:206
msgid "The system has reached the global open files limit."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:210
msgid ""
"An isolated context was requested, but the hardware does not support SPU "
"isolation."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:215
msgid "Part of I<pathname> could not be resolved."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:218
msgid "The kernel could not allocate all resources required."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:223
msgid ""
"There are not enough SPU resources available to create a new context or the "
"user-specific limit for the number of SPU contexts has been reached."
msgstr ""

#. type: TP
#: build/C/man2/spu_create.2:223 build/C/man2/spu_run.2:183 build/C/man2/statfs.2:206 build/C/man3/statvfs.3:145 build/C/man2/ustat.2:88
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:228 build/C/man2/spu_run.2:188
msgid ""
"The functionality is not provided by the current system, because either the "
"hardware does not provide SPUs or the spufs module is not loaded."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:233
msgid "A part of I<pathname> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:240
msgid ""
"The I<SPU_CREATE_NOSCHED> flag has been given, but the user does not have "
"the B<CAP_SYS_NICE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:246
msgid ""
"I<pathname> must point to a location beneath the mount point of B<spufs>.  "
"By convention, it gets mounted in I</spu>."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:250
msgid "The B<spu_create>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:254
msgid ""
"This call is Linux-specific and implemented only on the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:265
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_create>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:270
msgid "See B<spu_run>(2)  for an example of the use of B<spu_create>()"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_create.2:275
msgid "B<close>(2), B<spu_run>(2), B<capabilities>(7), B<spufs>(7)"
msgstr ""

#. type: TH
#: build/C/man2/spu_run.2:26
#, no-wrap
msgid "SPU_RUN"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:29
msgid "spu_run - execute an SPU context"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:32
#, no-wrap
msgid "B<#include E<lt>sys/spu.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:35
#, no-wrap
msgid ""
"B<int spu_run(int >I<fd>B<, unsigned int *>I<npc>B<, unsigned int "
"*>I<event>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:53
msgid ""
"The B<spu_run>()  system call is used on PowerPC machines that implement the "
"Cell Broadband Engine Architecture in order to access Synergistic Processor "
"Units (SPUs).  The I<fd> argument is a file descriptor returned by "
"B<spu_create>(2)  that refers to a specific SPU context.  When the context "
"gets scheduled to a physical SPU, it starts execution at the instruction "
"pointer passed in I<npc>."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:62
msgid ""
"Execution of SPU code happens synchronously, meaning that B<spu_run>()  "
"blocks while the SPU is still running.  If there is a need to execute SPU "
"code in parallel with other code on either the main CPU or other SPUs, a new "
"thread of execution must be created first (e.g., using "
"B<pthread_create>(3))."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:72
msgid ""
"When B<spu_run>()  returns, the current value of the SPU program counter is "
"written to I<npc>, so successive calls to B<spu_run>()  can use the same "
"I<npc> pointer."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:82
msgid ""
"The I<event> argument provides a buffer for an extended status code.  If the "
"SPU context was created with the B<SPU_CREATE_EVENTS_ENABLED> flag, then "
"this buffer is populated by the Linux kernel before B<spu_run>()  returns."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:84
msgid "The status code may be one (or more) of the following constants:"
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:84
#, no-wrap
msgid "B<SPE_EVENT_DMA_ALIGNMENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:87
msgid "A DMA alignment error occurred."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:87
#, no-wrap
msgid "B<SPE_EVENT_INVALID_DMA>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:90
msgid "An invalid MFC DMA command was attempted."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:90
#, no-wrap
msgid "B<SPE_EVENT_SPE_DATA_STORAGE>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:93
msgid "A DMA storage error occurred."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:93
#, no-wrap
msgid "B<SPE_EVENT_SPE_ERROR>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:96
msgid "An illegal instruction was executed."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:102
msgid ""
"NULL is a valid value for the I<event> argument.  In this case, the events "
"will not be reported to the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:111
msgid ""
"On success, B<spu_run>()  returns the value of the I<spu_status> register.  "
"On error, it returns -1 and sets I<errno> to one of the error codes listed "
"below."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:120
msgid ""
"The I<spu_status> register value is a bit mask of status codes and "
"optionally a 14-bit code returned from the B<stop-and-signal> instruction on "
"the SPU.  The bit masks for the status codes are:"
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:120
#, no-wrap
msgid "B<0x02>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:125
msgid "SPU was stopped by a B<stop-and-signal> instruction."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:125
#, no-wrap
msgid "B<0x04>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:130
msgid "SPU was stopped by a B<halt> instruction."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:130
#, no-wrap
msgid "B<0x08>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:133
msgid "SPU is waiting for a channel."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:133
#, no-wrap
msgid "B<0x10>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:136
msgid "SPU is in single-step mode."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:136
#, no-wrap
msgid "B<0x20>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:139
msgid "SPU has tried to execute an invalid instruction."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:139
#, no-wrap
msgid "B<0x40>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:142
msgid "SPU has tried to access an invalid channel."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:142
#, no-wrap
msgid "B<0x3fff0000>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:148
msgid ""
"The bits masked with this value contain the code returned from a "
"B<stop-and-signal> instruction.  These bits are valid only if the 0x02 bit "
"is set."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:153
msgid ""
"If B<spu_run>()  has not returned an error, one or more bits among the lower "
"eight ones are always set."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:154 build/C/man2/stat.2:530 build/C/man2/stat.2:581 build/C/man2/statfs.2:170 build/C/man3/statvfs.3:109
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:158
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:164
msgid ""
"I<npc> is not a valid pointer, or I<event> is non-NULL and an invalid "
"pointer."
msgstr ""

#. type: TP
#: build/C/man2/spu_run.2:164 build/C/man2/statfs.2:181 build/C/man3/statvfs.3:120
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:174
msgid ""
"A signal occurred while B<spu_run>()  was in progress; see B<signal>(7).  "
"The I<npc> value has been updated to the new program counter value if "
"necessary."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:179
msgid "I<fd> is not a valid file descriptor returned from B<spu_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:183
msgid ""
"There was not enough memory available to handle a page fault resulting from "
"a Memory Flow Controller (MFC) direct memory access."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:192
msgid "The B<spu_run>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:196
msgid ""
"This call is Linux-specific and implemented only by the PowerPC "
"architecture.  Programs using this system call are not portable."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:207
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Note however, that B<spu_run>()  is meant to be used from "
"libraries that implement a more abstract interface to SPUs, not to be used "
"from regular applications.  See E<.UR "
"http://www.bsc.es\\:/projects\\:/deepcomputing\\:/linuxoncell/> E<.UE> for "
"the recommended libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:212
msgid ""
"The following is an example of running a simple, one-instruction SPU program "
"with the B<spu_run>()  system call."
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:220
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:223
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:228
#, no-wrap
msgid ""
"int main(void)\n"
"{\n"
"    int context, fd, spu_status;\n"
"    uint32_t instruction, npc;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:232
#, no-wrap
msgid ""
"    context = spu_create(\"/spu/example-context\", 0, 0755);\n"
"    if (context == -1)\n"
"        handle_error(\"spu_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:237
#, no-wrap
msgid ""
"    /* write a \\(aqstop 0x1234\\(aq instruction to the SPU\\(aqs\n"
"     * local store memory\n"
"     */\n"
"    instruction = 0x00001234;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:242
#, no-wrap
msgid ""
"    fd = open(\"/spu/example-context/mem\", O_RDWR);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
"    write(fd, &instruction, sizeof(instruction));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:248
#, no-wrap
msgid ""
"    /* set npc to the starting instruction address of the\n"
"     * SPU program. Since we wrote the instruction at the\n"
"     * start of the mem file, the entry point will be 0x0\n"
"     */\n"
"    npc = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:252
#, no-wrap
msgid ""
"    spu_status = spu_run(context, &npc, NULL);\n"
"    if (spu_status == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:258
#, no-wrap
msgid ""
"    /* we should see a status code of 0x1234002:\n"
"     *   0x00000002 (spu was stopped due to stop-and-signal)\n"
"     * | 0x12340000 (the stop-and-signal code)\n"
"     */\n"
"    printf(\"SPU Status: 0x%08x\\en\", spu_status);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:261 build/C/man2/stat.2:919
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/spu_run.2:269
msgid "B<close>(2), B<spu_create>(2), B<capabilities>(7), B<spufs>(7)"
msgstr ""

#. type: TH
#: build/C/man7/spufs.7:27
#, no-wrap
msgid "SPUFS"
msgstr ""

#. type: TH
#: build/C/man7/spufs.7:27
#, no-wrap
msgid "2007-12-20"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:30
msgid "spufs - SPU filesystem"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:34
msgid ""
"The SPU filesystem is used on PowerPC machines that implement the Cell "
"Broadband Engine Architecture in order to access Synergistic Processor Units "
"(SPUs)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:43
msgid ""
"The filesystem provides a name space similar to POSIX shared memory or "
"message queues.  Users that have write permissions on the filesystem can use "
"B<spu_create>(2)  to establish SPU contexts under the B<spufs> root "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:50
msgid ""
"Every SPU context is represented by a directory containing a predefined set "
"of files.  These files can be used for manipulating the state of the logical "
"SPU.  Users can change permissions on the files, but can't add or remove "
"files."
msgstr ""

#. type: SS
#: build/C/man7/spufs.7:50
#, no-wrap
msgid "Mount options"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:51
#, no-wrap
msgid "B<uid=E<lt>uidE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:54
msgid "Set the user owning the mount point; the default is 0 (root)."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:54
#, no-wrap
msgid "B<gid=E<lt>gidE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:57
msgid "Set the group owning the mount point; the default is 0 (root)."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:57
#, no-wrap
msgid "B<mode=E<lt>modeE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:63
msgid ""
"Set the mode of the top-level directory in B<spufs>, as an octal mode "
"string.  The default is 0775."
msgstr ""

#. type: SS
#: build/C/man7/spufs.7:63
#, no-wrap
msgid "Files"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:75
msgid ""
"The files in B<spufs> mostly follow the standard behavior for regular system "
"calls like B<read>(2)  or B<write>(2), but often support only a subset of "
"the operations supported on regular filesystems.  This list details the "
"supported operations and the deviations from the standard behavior described "
"in the respective man pages."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:97
msgid ""
"All files that support the B<read>(2)  operation also support B<readv>(2)  "
"and all files that support the B<write>(2)  operation also support "
"B<writev>(2).  All files support the B<access>(2)  and B<stat>(2)  family of "
"operations, but for the latter call, the only fields of the returned I<stat> "
"structure that contain reliable information are I<st_mode>, I<st_nlink>, "
"I<st_uid>, and I<st_gid>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:106
msgid ""
"All files support the B<chmod>(2)/B<fchmod>(2)  and B<chown>(2)/B<fchown>(2)  "
"operations, but will not be able to grant permissions that contradict the "
"possible operations (e.g., read access on the I<wbox> file)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:108
msgid "The current set of files is:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:108
#, no-wrap
msgid "I</capabilities>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:113
msgid ""
"Contains a comma-delimited string representing the capabilities of this SPU "
"context.  Possible capabilities are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:114
#, no-wrap
msgid "B<sched>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:117
msgid "This context may be scheduled."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:117
#, no-wrap
msgid "B<step>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:120
msgid "This context can be run in single-step mode, for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:122
msgid "New capabilities flags may be added in the future."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:123
#, no-wrap
msgid "I</mem>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:132
msgid ""
"the contents of the local storage memory of the SPU.  This can be accessed "
"like a regular shared memory file and contains both code and data in the "
"address space of the SPU.  The possible operations on an open I<mem> file "
"are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:133
#, no-wrap
msgid "B<read>(2), B<pread>(2), B<write>(2), B<pwrite>(2), B<lseek>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:144
msgid ""
"These operate as usual, with the exception that B<lseek>(2), B<write>(2), "
"and B<pwrite>(2)  are not supported beyond the end of the file.  The file "
"size is the size of the local storage of the SPU, which is normally 256 "
"kilobytes."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:144 build/C/man7/spufs.7:706 build/C/man7/spufs.7:725
#, no-wrap
msgid "B<mmap>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:153
msgid ""
"Mapping I<mem> into the process address space provides access to the SPU "
"local storage within the process address space.  Only B<MAP_SHARED> mappings "
"are allowed."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:154
#, no-wrap
msgid "I</regs>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:161
msgid ""
"Contains the saved general-purpose registers of the SPU context.  This file "
"contains the 128-bit values of each register, from register 0 to register "
"127, in order.  This allows the general-purpose registers to be inspected "
"for debugging."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:165
msgid ""
"Reading to or writing from this file requires that the context is scheduled "
"out, so use of this file is not recommended in normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:171
msgid ""
"The I<regs> file is not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:171
#, no-wrap
msgid "I</mbox>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:181
msgid ""
"The first SPU-to-CPU communication mailbox.  This file is read-only and can "
"be read in units of 4 bytes.  The file can be used only in nonblocking mode "
"- even B<poll>(2)  cannot be used to block on this file.  The only possible "
"operation on an open I<mbox> file is:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:182 build/C/man7/spufs.7:222 build/C/man7/spufs.7:317 build/C/man7/spufs.7:381 build/C/man7/spufs.7:418 build/C/man7/spufs.7:463 build/C/man7/spufs.7:517 build/C/man7/spufs.7:632 build/C/man7/spufs.7:676 build/C/man7/spufs.7:754
#, no-wrap
msgid "B<read>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:200
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox (i.e., the SPU "
"has not sent a mailbox message), the return value is set to -1 and I<errno> "
"is set to B<EAGAIN>.  When data has been read successfully, four bytes are "
"placed in the data buffer and the value four is returned."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:201
#, no-wrap
msgid "I</ibox>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:217
msgid ""
"The second SPU-to-CPU communication mailbox.  This file is similar to the "
"first mailbox file, but can be read in blocking I/O mode, thus calling "
"B<read>(2)  on an open I<ibox> file will block until the SPU has written "
"data to its interrupt mailbox channel (unless the file has been opened with "
"B<O_NONBLOCK>, see below).  Also, B<poll>(2)  and similar system calls can "
"be used to monitor for the presence of mailbox data."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:221
msgid "The possible operations on an open I<ibox> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:239
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no data available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:247
msgid ""
"If there is no data available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU writes "
"to its interrupt mailbox channel.  When data has been read successfully, "
"four bytes are placed in the data buffer and the value four is returned."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:247 build/C/man7/spufs.7:295 build/C/man7/spufs.7:685
#, no-wrap
msgid "B<poll>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:254
msgid ""
"Poll on the I<ibox> file returns I<(POLLIN | POLLRDNORM)> whenever data is "
"available for reading."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:255
#, no-wrap
msgid "I</wbox>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:267
msgid ""
"The CPU-to-SPU communication mailbox.  It is write-only and can be written "
"in units of four bytes.  If the mailbox is full, B<write>(2)  will block, "
"and B<poll>(2)  can be used to block until the mailbox is available for "
"writing again.  The possible operations on an open I<wbox> file are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:268 build/C/man7/spufs.7:392 build/C/man7/spufs.7:432 build/C/man7/spufs.7:476 build/C/man7/spufs.7:527 build/C/man7/spufs.7:638 build/C/man7/spufs.7:652 build/C/man7/spufs.7:749
#, no-wrap
msgid "B<write>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:286
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  If there is no space available in the mailbox and the file "
"descriptor has been opened with B<O_NONBLOCK>, the return value is set to -1 "
"and I<errno> is set to B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:295
msgid ""
"If there is no space available in the mailbox and the file descriptor has "
"been opened without B<O_NONBLOCK>, the call will block until the SPU reads "
"from its PPE (PowerPC Processing Element)  mailbox channel.  When data has "
"been written successfully, the system call returns four as its function "
"result."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:302
msgid ""
"A poll on the I<wbox> file returns I<(POLLOUT | POLLWRNORM)> whenever space "
"is available for writing."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:303
#, no-wrap
msgid "I</mbox_stat>, I</ibox_stat>, I</wbox_stat>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:316
msgid ""
"These are read-only files that contain the length of the current queue of "
"each mailbox\\(emthat is, how many words can be read from I<mbox> or I<ibox> "
"or how many words can be written to I<wbox> without blocking.  The files can "
"be read only in four-byte units and return a big-endian binary integer "
"number.  The only possible operation on an open I<*box_stat> file is:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:337
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer.  "
"This value is the number of elements that can be read from (for I<mbox_stat> "
"and I<ibox_stat>)  or written to (for I<wbox_stat>)  the respective mailbox "
"without blocking or returning an B<EAGAIN> error."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:338
#, no-wrap
msgid ""
"I</npc>, I</decr>, I</decr_status>, I</spu_tag_mask>, I</event_mask>, "
"I</event_status>, I</srr0>, I</lslr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:350
msgid ""
"Internal registers of the SPU.  These files contain an ASCII string "
"representing the hex value of the specified register.  Reads and writes on "
"these files (except for I<npc>, see below) require that the SPU context be "
"scheduled out, so frequent access to these files is not recommended for "
"normal program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:352
msgid "The contents of these files are:"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:353
#, no-wrap
msgid "I<npc>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:356
msgid "Next Program Counter - valid only when the SPU is in a stopped state."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:356
#, no-wrap
msgid "I<decr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:359
msgid "SPU Decrementer"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:359
#, no-wrap
msgid "I<decr_status>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:362
msgid "Decrementer Status"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:362
#, no-wrap
msgid "I<spu_tag_mask>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:365
msgid "MFC tag mask for SPU DMA"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:365
#, no-wrap
msgid "I<event_mask>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:368
msgid "Event mask for SPU interrupts"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:368
#, no-wrap
msgid "I<event_status>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:371
msgid "Number of SPU events pending (read-only)"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:371
#, no-wrap
msgid "I<srr0>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:374
msgid "Interrupt Return address register"
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:374
#, no-wrap
msgid "I<lslr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:377
msgid "Local Store Limit Register"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:380
msgid "The possible operations on these files are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:388
msgid ""
"Reads the current register value.  If the register value is larger than the "
"buffer passed to the B<read>(2)  system call, subsequent reads will continue "
"reading from the same buffer, until the end of the buffer is reached."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:392
msgid ""
"When a complete string has been read, all subsequent read operations will "
"return zero bytes and a new file descriptor needs to be opened to read a new "
"value."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:402 build/C/man7/spufs.7:537
msgid ""
"A B<write>(2)  operation on the file sets the register to the value given in "
"the string.  The string is parsed from the beginning until the first "
"nonnumeric character or the end of the buffer.  Subsequent writes to the "
"same file descriptor overwrite the previous setting."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:409
msgid ""
"Except for the I<npc> file, these files are not present on contexts that "
"have been created with the B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:410
#, no-wrap
msgid "I</fpcr>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:417
msgid ""
"This file provides access to the Floating Point Status and Control Register "
"(fcpr) as a binary, four-byte file.  The operations on the I<fpcr> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:432
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the I<fpcr> register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:446
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the I<fpcr> register."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:447
#, no-wrap
msgid "I</signal1>, I</signal2>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:462
msgid ""
"The files provide access to the two signal notification channels of an SPU.  "
"These are read-write files that operate on four-byte words.  Writing to one "
"of these files triggers an interrupt on the SPU.  The value written to the "
"signal files can be read from the SPU through a channel read or from host "
"user space through the file.  After the value has been read by the SPU, it "
"is reset to zero.  The possible operations on an open I<signal1> or "
"I<signal2> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:476
msgid ""
"If I<count> is smaller than four, B<read>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is placed in the data buffer; "
"this is the current value of the specified signal notification register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:497
msgid ""
"If I<count> is smaller than four, B<write>(2)  returns -1 and sets I<errno> "
"to B<EINVAL>.  Otherwise, a four-byte value is copied from the data buffer, "
"updating the value of the specified signal notification register.  The "
"signal notification register will either be replaced with the input data or "
"will be updated to the bitwise OR operation of the old value and the input "
"data, depending on the contents of the I<signal1_type> or I<signal2_type> "
"files respectively."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:498
#, no-wrap
msgid "I</signal1_type>, I</signal2_type>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:516
msgid ""
"These two files change the behavior of the I<signal1> and I<signal2> "
"notification files.  They contain a numeric ASCII string which is read as "
"either \"1\" or \"0\".  In mode 0 (overwrite), the hardware replaces the "
"contents of the signal channel with the data that is written to it.  In mode "
"1 (logical OR), the hardware accumulates the bits that are subsequently "
"written to it.  The possible operations on an open I<signal1_type> or "
"I<signal2_type> file are:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:527
msgid ""
"When the count supplied to the B<read>(2)  call is shorter than the required "
"length for the digit (plus a newline character), subsequent reads from the "
"same file descriptor will complete the string.  When a complete string has "
"been read, all subsequent read operations will return zero bytes and a new "
"file descriptor needs to be opened to read the value again."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:538
#, no-wrap
msgid "I</mbox_info>, I</ibox_info>, I</wbox_info>, I</dma_into>, I</proxydma_info>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:557
msgid ""
"Read-only files that contain the saved state of the SPU mailboxes and DMA "
"queues.  This allows the SPU status to be inspected, mainly for debugging.  "
"The I<mbox_info> and I<ibox_info> files each contain the four-byte mailbox "
"message that has been written by the SPU.  If no message has been written to "
"these mailboxes, then contents of these files is undefined.  The "
"I<mbox_stat>, I<ibox_stat> and I<wbox_stat> files contain the available "
"message count."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:566
msgid ""
"The I<wbox_info> file contains an array of four-byte mailbox messages, which "
"have been sent to the SPU.  With current CBEA machines, the array is four "
"items in length, so up to 4 * 4 = 16 bytes can be read from this file.  If "
"any mailbox queue entry is empty, then the bytes read at the corresponding "
"location are undefined."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:571
msgid ""
"The I<dma_info> file contains the contents of the SPU MFC DMA queue, "
"represented as the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:582
#, no-wrap
msgid ""
"struct spu_dma_info {\n"
"    uint64_t         dma_info_type;\n"
"    uint64_t         dma_info_mask;\n"
"    uint64_t         dma_info_status;\n"
"    uint64_t         dma_info_stall_and_notify;\n"
"    uint64_t         dma_info_atomic_command_status;\n"
"    struct mfc_cq_sr dma_info_command_data[16];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:590
msgid ""
"The last member of this data structure is the actual DMA queue, containing "
"16 entries.  The I<mfc_cq_sr> structure is defined as:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:599
#, no-wrap
msgid ""
"struct mfc_cq_sr {\n"
"    uint64_t mfc_cq_data0_RW;\n"
"    uint64_t mfc_cq_data1_RW;\n"
"    uint64_t mfc_cq_data2_RW;\n"
"    uint64_t mfc_cq_data3_RW;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:607
msgid ""
"The I<proxydma_info> file contains similar information, but describes the "
"proxy DMA queue (i.e., DMAs initiated by entities outside the SPU) instead.  "
"The file is in the following format:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:616
#, no-wrap
msgid ""
"struct spu_proxydma_info {\n"
"    uint64_t         proxydma_info_type;\n"
"    uint64_t         proxydma_info_mask;\n"
"    uint64_t         proxydma_info_status;\n"
"    struct mfc_cq_sr proxydma_info_command_data[8];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:622
msgid ""
"Accessing these files requires that the SPU context is scheduled out - "
"frequent use can be inefficient.  These files should not be used for normal "
"program operation."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:626
msgid ""
"These files are not present on contexts that have been created with the "
"B<SPU_CREATE_NOSCHED> flag."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:626
#, no-wrap
msgid "I</cntl>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:631
msgid ""
"This file provides access to the SPU Run Control and SPU status registers, "
"as an ASCII string.  The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:638
msgid ""
"Reads from the I<cntl> file will return an ASCII string with the hex value "
"of the SPU Status register."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:643
msgid "Writes to the I<cntl> file will set the context's SPU Run Control register."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:644
#, no-wrap
msgid "I</mfc>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:651
msgid ""
"Provides access to the Memory Flow Controller of the SPU.  Reading from the "
"file returns the contents of the SPU's MFC Tag Status register, and writing "
"to the file initiates a DMA from the MFC.  The following operations are "
"supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:656
msgid ""
"Writes to this file need to be in the format of a MFC DMA command, defined "
"as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:668
#, no-wrap
msgid ""
"struct mfc_dma_command {\n"
"    int32_t  pad;    /* reserved */\n"
"    uint32_t lsa;    /* local storage address */\n"
"    uint64_t ea;     /* effective address */\n"
"    uint16_t size;   /* transfer size */\n"
"    uint16_t tag;    /* command tag */\n"
"    uint16_t class;  /* class ID */\n"
"    uint16_t cmd;    /* command opcode */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:676
msgid ""
"Writes are required to be exactly I<sizeof(struct mfc_dma_command)> bytes in "
"size.  The command will be sent to the SPU's MFC proxy queue, and the tag "
"stored in the kernel (see below)."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:685
msgid ""
"Reads the contents of the tag status register.  If the file is opened in "
"blocking mode (i.e., without B<O_NONBLOCK>), then the read will block until "
"a DMA tag (as performed by a previous write) is complete.  In nonblocking "
"mode, the MFC tag status register will be returned without waiting."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:698
msgid ""
"Calling B<poll>(2)  on the I<mfc> file will block until a new DMA can be "
"started (by checking for B<POLLOUT>)  or until a previously started DMA (by "
"checking for B<POLLIN>)  has been completed."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:704
msgid ""
"I</mss> Provides access to the MFC MultiSource Synchronization (MSS) "
"facility.  By B<mmap>(2)-ing this file, processes can access the MSS area of "
"the SPU."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:706 build/C/man7/spufs.7:724
msgid "The following operations are supported:"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:715
msgid ""
"Mapping B<mss> into the process address space gives access to the SPU MSS "
"area within the process address space.  Only B<MAP_SHARED> mappings are "
"allowed."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:716
#, no-wrap
msgid "I</psmap>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:722
msgid ""
"Provides access to the whole problem-state mapping of the SPU.  Applications "
"can use this area to interface to the SPU, rather than writing to individual "
"register files in B<spufs>."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:733
msgid ""
"Mapping B<psmap> gives a process a direct map of the SPU problem state "
"area.  Only B<MAP_SHARED> mappings are supported."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:734
#, no-wrap
msgid "I</phys-id>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:740
msgid ""
"Read-only file containing the physical SPU number that the SPU context is "
"running on.  When the context is not running, this file contains the string "
"\"-1\"."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:742
msgid "The physical SPU number is given by an ASCII hex string."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:742
#, no-wrap
msgid "I</object-id>"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:748
msgid ""
"Allows applications to store (or retrieve) a single 64-bit ID into the "
"context.  This ID is later used by profiling tools to uniquely identify the "
"context."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:754
msgid ""
"By writing an ASCII hex value into this file, applications can set the "
"object ID of the SPU context.  Any previous value of the object ID is "
"overwritten."
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:758
msgid ""
"Reading this file gives an ASCII hex string representing the object ID for "
"this SPU context."
msgstr ""

#. type: TP
#: build/C/man7/spufs.7:760
#, no-wrap
msgid "I</etc/fstab>  entry"
msgstr ""

#.  .SH AUTHORS
#.  Arnd Bergmann <arndb@de.ibm.com>, Mark Nutter <mnutter@us.ibm.com>,
#.  Ulrich Weigand <Ulrich.Weigand@de.ibm.com>, Jeremy Kerr <jk@ozlabs.org>
#. type: Plain text
#: build/C/man7/spufs.7:766
msgid "none \t/spu \tspufs \tgid=spu \t0\t0"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:771
msgid "B<close>(2), B<spu_create>(2), B<spu_run>(2), B<capabilities>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/spufs.7:773
msgid "I<The Cell Broadband Engine Architecture (CBEA) specification>"
msgstr ""

#. type: TH
#: build/C/man2/stat.2:40
#, no-wrap
msgid "STAT"
msgstr ""

#. type: TH
#: build/C/man2/stat.2:40
#, no-wrap
msgid "2014-08-19"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:43
msgid "stat, fstat, lstat, fstatat - get file status"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:46 build/C/man2/ustat.2:36
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:48
#, no-wrap
msgid "B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:50
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:52
#, no-wrap
msgid "B<int stat(const char *>I<pathname>B<, struct stat *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:54
#, no-wrap
msgid "B<int fstat(int >I<fd>B<, struct stat *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:56
#, no-wrap
msgid "B<int lstat(const char *>I<pathname>B<, struct stat *>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:59
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:63
#, no-wrap
msgid ""
"B<int fstatat(int >I<dirfd>B<, const char *>I<pathname>B<, struct stat "
"*>I<buf>B<,>\n"
"B<            int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:73
msgid "B<lstat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:75
msgid "/* glibc 2.19 and earlier */ _BSD_SOURCE ||"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:77
msgid "/* Since glibc 2.20 */_DEFAULT_SOURCE ||"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:80
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:82
msgid "|| /* Since glibc 2.10: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:85
msgid "B<fstatat>():"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:88
#, no-wrap
msgid "Since glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:91
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:91
#, no-wrap
msgid "Before glibc 2.10:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:94
msgid "_ATFILE_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:109
msgid ""
"These functions return information about a file, in the buffer pointed to by "
"I<stat>.  No permissions are required on the file itself, but\\(emin the "
"case of B<stat>(), B<fstatat>(), and B<lstat>()\\(emexecute (search) "
"permission is required on all of the directories in I<pathname> that lead to "
"the file."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:118
msgid ""
"B<stat>()  and B<fstatat>()  retrieve information about the file pointed to "
"by I<pathname>; the differences for B<fstatat>()  are described below."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:126
msgid ""
"B<lstat>()  is identical to B<stat>(), except that if I<pathname> is a "
"symbolic link, then it returns information about the link itself, not the "
"file that it refers to."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:133
msgid ""
"B<fstat>()  is identical to B<stat>(), except that the file about which "
"information is to be retrieved is specified by the file descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:137
msgid ""
"All of these system calls return a I<stat> structure, which contains the "
"following fields:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:151
#, no-wrap
msgid ""
"struct stat {\n"
"    dev_t     st_dev;         /* ID of device containing file */\n"
"    ino_t     st_ino;         /* inode number */\n"
"    mode_t    st_mode;        /* protection */\n"
"    nlink_t   st_nlink;       /* number of hard links */\n"
"    uid_t     st_uid;         /* user ID of owner */\n"
"    gid_t     st_gid;         /* group ID of owner */\n"
"    dev_t     st_rdev;        /* device ID (if special file) */\n"
"    off_t     st_size;        /* total size, in bytes */\n"
"    blksize_t st_blksize;     /* blocksize for filesystem I/O */\n"
"    blkcnt_t  st_blocks;      /* number of 512B blocks allocated */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:155
#, no-wrap
msgid ""
"    /* Since Linux 2.6, the kernel supports nanosecond\n"
"       precision for the following timestamp fields.\n"
"       For the details before Linux 2.6, see NOTES. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:159
#, no-wrap
msgid ""
"    struct timespec st_atim;  /* time of last access */\n"
"    struct timespec st_mtim;  /* time of last modification */\n"
"    struct timespec st_ctim;  /* time of last status change */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:164
#, no-wrap
msgid ""
"#define st_atime st_atim.tv_sec      /* Backward compatibility */\n"
"#define st_mtime st_mtim.tv_sec\n"
"#define st_ctime st_ctim.tv_sec\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:177
msgid ""
"I<Note:> the order of fields in the I<stat> structure varies somewhat across "
"architectures.  In addition, the definition above does not show the padding "
"bytes that may be present between some fields on various architectures.  "
"Consult the the glibc and kernel source code if you need to know the "
"details."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:186
msgid ""
"The I<st_dev> field describes the device on which this file resides.  (The "
"B<major>(3)  and B<minor>(3)  macros may be useful to decompose the device "
"ID in this field.)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:190
msgid "The I<st_rdev> field describes the device that this file (inode) represents."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:197
msgid ""
"The I<st_size> field gives the size of the file (if it is a regular file or "
"a symbolic link) in bytes.  The size of a symbolic link is the length of the "
"pathname it contains, without a terminating null byte."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:204
msgid ""
"The I<st_blocks> field indicates the number of blocks allocated to the file, "
"512-byte units.  (This may be smaller than I<st_size>/512 when the file has "
"holes.)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:210
msgid ""
"The I<st_blksize> field gives the \"preferred\" blocksize for efficient "
"filesystem I/O.  (Writing to a file in smaller chunks may cause an "
"inefficient read-modify-rewrite.)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:231
msgid ""
"Not all of the Linux filesystems implement all of the time fields.  Some "
"filesystem types allow mounting in such a way that file and/or directory "
"accesses do not cause an update of the I<st_atime> field.  (See I<noatime>, "
"I<nodiratime>, and I<relatime> in B<mount>(8), and related information in "
"B<mount>(2).)  In addition, I<st_atime> is not updated if a file is opened "
"with the B<O_NOATIME>; see B<open>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:246
msgid ""
"The field I<st_atime> is changed by file accesses, for example, by "
"B<execve>(2), B<mknod>(2), B<pipe>(2), B<utime>(2), and B<read>(2)  (of more "
"than zero bytes).  Other routines, like B<mmap>(2), may or may not update "
"I<st_atime>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:265
msgid ""
"The field I<st_mtime> is changed by file modifications, for example, by "
"B<mknod>(2), B<truncate>(2), B<utime>(2), and B<write>(2)  (of more than "
"zero bytes).  Moreover, I<st_mtime> of a directory is changed by the "
"creation or deletion of files in that directory.  The I<st_mtime> field is "
"I<not> changed for changes in owner, group, hard link count, or mode."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:270
msgid ""
"The field I<st_ctime> is changed by writing or by setting inode information "
"(i.e., owner, group, link count, mode, etc.)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:274
msgid ""
"The following mask values are defined for the file type component of the "
"I<st_mode> field:"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:277
#, no-wrap
msgid "S_IFMT\t0170000\tbit mask for the file type bit fields\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:279
#, no-wrap
msgid "S_IFSOCK\t0140000\tsocket\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:280
#, no-wrap
msgid "S_IFLNK\t0120000\tsymbolic link\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:281
#, no-wrap
msgid "S_IFREG\t0100000\tregular file\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:282
#, no-wrap
msgid "S_IFBLK\t0060000\tblock device\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:283
#, no-wrap
msgid "S_IFDIR\t0040000\tdirectory\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:284
#, no-wrap
msgid "S_IFCHR\t0020000\tcharacter device\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:285
#, no-wrap
msgid "S_IFIFO\t0010000\tFIFO\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:290
msgid "Thus, to test for a regular file (for example), one could write:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:297
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if ((sb.st_mode & S_IFMT) == S_IFREG) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:304
msgid ""
"Because tests of the above form are common, additional macros are defined by "
"POSIX to allow the test of the file type in I<st_mode> to be written more "
"concisely:"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:305
#, no-wrap
msgid "B<S_ISREG>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:308
msgid "is it a regular file?"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:308
#, no-wrap
msgid "B<S_ISDIR>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:311
msgid "directory?"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:311
#, no-wrap
msgid "B<S_ISCHR>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:314
msgid "character device?"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:314
#, no-wrap
msgid "B<S_ISBLK>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:317
msgid "block device?"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:317
#, no-wrap
msgid "B<S_ISFIFO>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:320
msgid "FIFO (named pipe)?"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:320
#, no-wrap
msgid "B<S_ISLNK>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:323
msgid "symbolic link? (Not in POSIX.1-1996.)"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:323
#, no-wrap
msgid "B<S_ISSOCK>(m)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:326
msgid "socket? (Not in POSIX.1-1996.)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:329
msgid "The preceding code snippet could thus be rewritten as:"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:336
#, no-wrap
msgid ""
"stat(pathname, &sb);\n"
"if (S_ISREG(sb.st_mode)) {\n"
"    /* Handle regular file */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:360
msgid ""
"The definitions of most of the above file type test macros are provided if "
"any of the following feature test macros is defined: B<_BSD_SOURCE> (in "
"glibc 2.19 and earlier), B<_SVID_SOURCE> (in glibc 2.19 and earlier), or "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later).  In addition, definitions of "
"all of the above macros except B<S_IFSOCK> and B<S_ISSOCK>()  are provided "
"if B<_XOPEN_SOURCE> is defined.  The definition of B<S_IFSOCK> can also be "
"exposed by defining B<_XOPEN_SOURCE> with a value of 500 or greater."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:372
msgid ""
"The definition of B<S_ISSOCK>()  is exposed if any of the following feature "
"test macros is defined: B<_BSD_SOURCE> (in glibc 2.19 and earlier), "
"B<_DEFAULT_SOURCE> (in glibc 2.20 and later), B<_XOPEN_SOURCE> with a value "
"of 500 or greater, or B<_POSIX_C_SOURCE> with a value of 200112L or greater."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:377
msgid ""
"The following mask values are defined for the file permissions component of "
"the I<st_mode> field:"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:380
#, no-wrap
msgid "S_ISUID\t0004000\tset-user-ID bit\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:381
#, no-wrap
msgid "S_ISGID\t0002000\tset-group-ID bit (see below)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:382
#, no-wrap
msgid "S_ISVTX\t0001000\tsticky bit (see below)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:384
#, no-wrap
msgid "S_IRWXU\t  00700\tmask for file owner permissions\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:385
#, no-wrap
msgid "S_IRUSR\t  00400\towner has read permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:386
#, no-wrap
msgid "S_IWUSR\t  00200\towner has write permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:387
#, no-wrap
msgid "S_IXUSR\t  00100\towner has execute permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:389
#, no-wrap
msgid "S_IRWXG\t  00070\tmask for group permissions\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:390
#, no-wrap
msgid "S_IRGRP\t  00040\tgroup has read permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:391
#, no-wrap
msgid "S_IWGRP\t  00020\tgroup has write permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:392
#, no-wrap
msgid "S_IXGRP\t  00010\tgroup has execute permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:394
#, no-wrap
msgid "S_IRWXO\t  00007\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:395
#, no-wrap
msgid "mask for permissions for others (not in group)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:396 build/C/man2/stat.2:695 build/C/man2/stat.2:703 build/C/man2/stat.2:714 build/C/man2/stat.2:726 build/C/man2/stat.2:731 build/C/man2/stat.2:734 build/C/man2/stat.2:738
#, no-wrap
msgid "T}\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:397
#, no-wrap
msgid "S_IROTH\t  00004\tothers have read permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:398
#, no-wrap
msgid "S_IWOTH\t  00002\tothers have write permission\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:399
#, no-wrap
msgid "S_IXOTH\t  00001\tothers have execute permission\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:416
msgid ""
"The set-group-ID bit (B<S_ISGID>)  has several special uses.  For a "
"directory, it indicates that BSD semantics is to be used for that directory: "
"files created there inherit their group ID from the directory, not from the "
"effective group ID of the creating process, and directories created there "
"will also get the B<S_ISGID> bit set.  For a file that does not have the "
"group execution bit (B<S_IXGRP>)  set, the set-group-ID bit indicates "
"mandatory file/record locking."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:425
msgid ""
"The sticky bit (B<S_ISVTX>)  on a directory means that a file in that "
"directory can be renamed or deleted only by the owner of the file, by the "
"owner of the directory, and by a privileged process."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:425
#, no-wrap
msgid "fstatat()"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:431
msgid ""
"The B<fstatat>()  system call operates in exactly the same way as B<stat>(), "
"except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:441
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<stat>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:453
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<stat>())."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:459
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:462
msgid ""
"I<flags> can either be 0, or include one or more of the following flags "
"ORed:"
msgstr ""

#. type: TP
#: build/C/man2/stat.2:462
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr ""

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/stat.2:485
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  If I<dirfd> is B<AT_FDCWD>, the call operates on the current working "
"directory.  In this case, I<dirfd> can refer to any type of file, not just a "
"directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to obtain its "
"definition."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:485
#, no-wrap
msgid "B<AT_NO_AUTOMOUNT> (since Linux 2.6.38)"
msgstr ""

#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/stat.2:501
msgid ""
"Don't automount the terminal (\"basename\") component of I<pathname> if it "
"is a directory that is an automount point.  This allows the caller to gather "
"attributes of an automount point (rather than the location it would mount).  "
"This flag can be used in tools that scan directories to prevent "
"mass-automounting of a directory of automount points.  The "
"B<AT_NO_AUTOMOUNT> flag has no effect if the mount point has already been "
"mounted over.  This flag is Linux-specific; define B<_GNU_SOURCE> to obtain "
"its definition."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:501
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:512
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself, like B<lstat>().  (By default, "
"B<fstatat>()  dereferences symbolic links, like B<stat>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:517
msgid "See B<openat>(2)  for an explanation of the need for B<fstatat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:530
msgid ""
"Search permission is denied for one of the directories in the path prefix of "
"I<pathname>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:534
msgid "I<fd> is bad."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:537
msgid "Bad address."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:540
msgid "Too many symbolic links encountered while traversing the path."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:551
msgid ""
"A component of I<pathname> does not exist, or I<pathname> is an empty "
"string."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:554
msgid "Out of memory (i.e., kernel memory)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:559
msgid "A component of the path prefix of I<pathname> is not a directory."
msgstr ""

#. type: TP
#: build/C/man2/stat.2:559 build/C/man2/statfs.2:215 build/C/man3/statvfs.3:154
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:578
msgid ""
"I<pathname> or I<fd> refers to a file whose size, inode number, or number of "
"blocks cannot be represented in, respectively, the types I<off_t>, I<ino_t>, "
"or I<blkcnt_t>.  This error can occur when, for example, an application "
"compiled on a 32-bit platform without I<-D_FILE_OFFSET_BITS=64> calls "
"B<stat>()  on a file whose size exceeds I<(1E<lt>E<lt>31)-1> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:581
msgid "The following additional errors can occur for B<fstatat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:585
msgid "I<dirfd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:589
msgid "Invalid flag specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:595
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:599
msgid ""
"B<fstatat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""

#.  SVr4 documents additional
#.  .BR fstat ()
#.  error conditions EINTR, ENOLINK, and EOVERFLOW.  SVr4
#.  documents additional
#.  .BR stat ()
#.  and
#.  .BR lstat ()
#.  error conditions EINTR, EMULTIHOP, ENOLINK, and EOVERFLOW.
#. type: Plain text
#: build/C/man2/stat.2:612
msgid "B<stat>(), B<fstat>(), B<lstat>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:615
msgid "B<fstatat>(): POSIX.1-2008."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:629
msgid ""
"According to POSIX.1-2001, B<lstat>()  on a symbolic link need return valid "
"information only in the I<st_size> field and the file-type component of the "
"I<st_mode> field of the I<stat> structure.  POSIX.1-2008 tightens the "
"specification, requiring B<lstat>()  to return valid information in all "
"fields except the permission bits in I<st_mode>."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:649
msgid ""
"Use of the I<st_blocks> and I<st_blksize> fields may be less portable.  "
"(They were introduced in BSD.  The interpretation differs between systems, "
"and possibly on a single system when NFS mounts are involved.)  If you need "
"to obtain the definition of the I<blkcnt_t> or I<blksize_t> types from "
"I<E<lt>sys/stat.hE<gt>>, then define B<_XOPEN_SOURCE> with the value 500 or "
"greater (before including I<any> header files)."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:667
msgid ""
"POSIX.1-1990 did not describe the B<S_IFMT>, B<S_IFSOCK>, B<S_IFLNK>, "
"B<S_IFREG>, B<S_IFBLK>, B<S_IFDIR>, B<S_IFCHR>, B<S_IFIFO>, B<S_ISVTX> "
"constants, but instead demanded the use of the macros B<S_ISDIR>(), and so "
"on.  The B<S_IF*> constants are present in POSIX.1-2001 and later."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:675
msgid ""
"The B<S_ISLNK>()  and B<S_ISSOCK>()  macros are not in POSIX.1-1996, but "
"both are present in POSIX.1-2001; the former is from SVID 4, the latter from "
"SUSv2."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:685
msgid ""
"UNIX\\ V7 (and later systems) had B<S_IREAD>, B<S_IWRITE>, B<S_IEXEC>, where "
"POSIX prescribes the synonyms B<S_IRUSR>, B<S_IWUSR>, B<S_IXUSR>."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:685
#, no-wrap
msgid "Other systems"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:687
msgid "Values that have been (or are) in use on various systems:"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:690
#, no-wrap
msgid "hex\tname\tls\toctal\tdescription\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:691
#, no-wrap
msgid "f000\tS_IFMT\t\t170000\tmask for file type\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:692
#, no-wrap
msgid "0000\t\t\t000000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:693
#, no-wrap
msgid "SCO out-of-service inode; BSD unknown type; SVID-v2 and XPG2\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:694
#, no-wrap
msgid "have both 0 and 0100000 for ordinary file\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:696
#, no-wrap
msgid "1000\tS_IFIFO\tp|\t010000\tFIFO (named pipe)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:697
#, no-wrap
msgid "2000\tS_IFCHR\tc\t020000\tcharacter special (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:698
#, no-wrap
msgid "3000\tS_IFMPC\t\t030000\tmultiplexed character special (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:699
#, no-wrap
msgid "4000\tS_IFDIR\td/\t040000\tdirectory (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:700
#, no-wrap
msgid "5000\tS_IFNAM\t\t050000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:701
#, no-wrap
msgid "XENIX named special file with two subtypes, distinguished by\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:702
#, no-wrap
msgid "I<st_rdev> values 1, 2\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:704
#, no-wrap
msgid "0001\tS_INSEM\ts\t000001\tXENIX semaphore subtype of IFNAM\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:705
#, no-wrap
msgid "0002\tS_INSHD\tm\t000002\tXENIX shared data subtype of IFNAM\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:706
#, no-wrap
msgid "6000\tS_IFBLK\tb\t060000\tblock special (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:707
#, no-wrap
msgid "7000\tS_IFMPB\t\t070000\tmultiplexed block special (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:708
#, no-wrap
msgid "8000\tS_IFREG\t-\t100000\tregular (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:709
#, no-wrap
msgid "9000\tS_IFCMP\t\t110000\tVxFS compressed\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:710
#, no-wrap
msgid "9000\tS_IFNWK\tn\t110000\tnetwork special (HP-UX)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:711
#, no-wrap
msgid "a000\tS_IFLNK\tl@\t120000\tsymbolic link (BSD)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:712
#, no-wrap
msgid "b000\tS_IFSHAD\t\t130000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:713
#, no-wrap
msgid "Solaris shadow inode for ACL (not seen by user space)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:715
#, no-wrap
msgid "c000\tS_IFSOCK\ts=\t140000\tsocket (BSD; also \"S_IFSOC\" on VxFS)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:716
#, no-wrap
msgid "d000\tS_IFDOOR\tDE<gt>\t150000\tSolaris door\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:717
#, no-wrap
msgid "e000\tS_IFWHT\tw%\t160000\tBSD whiteout (not used for inode)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:718
#, no-wrap
msgid "0200\tS_ISVTX\t\t001000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:719
#, no-wrap
msgid "sticky bit: save swapped text even after use (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:720 build/C/man2/stat.2:722 build/C/man2/stat.2:724 build/C/man2/stat.2:729
#, no-wrap
msgid ".br\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:721
#, no-wrap
msgid "reserved (SVID-v2)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:723
#, no-wrap
msgid "On nondirectories: don't cache this file (SunOS)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:725
#, no-wrap
msgid "On directories: restricted deletion flag (SVID-v4.2)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:727
#, no-wrap
msgid "0400\tS_ISGID\t\t002000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:728
#, no-wrap
msgid "set-group-ID on execution (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:730
#, no-wrap
msgid "for directories: use BSD semantics for propagation of GID\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:732
#, no-wrap
msgid "0400\tS_ENFMT\t\t002000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:733
#, no-wrap
msgid "System V file locking enforcement (shared with S_ISGID)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:735
#, no-wrap
msgid "0800\tS_ISUID\t\t004000\tset-user-ID on execution (V7)\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:736
#, no-wrap
msgid "0800\tS_CDF\t\t004000\tT{\n"
msgstr ""

#. type: tbl table
#: build/C/man2/stat.2:737
#, no-wrap
msgid "directory is a context dependent file (HP-UX)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:743
msgid "A sticky command appeared in Version 32V AT&T UNIX."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:750
msgid ""
"On Linux, B<lstat>()  will generally not trigger automounter action, whereas "
"B<stat>()  will (but see B<fstatat>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:758
msgid ""
"For most files under the I</proc> directory, B<stat>()  does not return the "
"file size in the I<st_size> field; instead the field is returned with the "
"value 0."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:758
#, no-wrap
msgid "Timestamp fields"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:769
msgid ""
"Older kernels and older standards did not support nanosecond timestamp "
"fields.  Instead, there were three timestamp fields\\(emI<st_atime>, "
"I<st_mtime>, and I<st_ctime>\\(emtyped as I<time_t> that recorded timestamps "
"with one-second precision."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:791
msgid ""
"Since kernel 2.5.48, the I<stat> structure supports nanosecond resolution "
"for the three file timestamp fields.  The nanosecond components of each "
"timestamp are available via names of the form I<st_atim.tv_nsec> if the "
"B<_BSD_SOURCE> or B<_SVID_SOURCE> feature test macro is defined.  Nanosecond "
"timestamps are nowadays standardized, starting with POSIX.1-2008, and, "
"starting with version 2.12, glibc also exposes the nanosecond component "
"names if B<_POSIX_C_SOURCE> is defined with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> is defined with the value 700 or greater.  If none of the "
"aforementioned macros are defined, then the nanosecond values are exposed "
"with names of the form I<st_atimensec>."
msgstr ""

#.  commit ef7f38359ea8b3e9c7f2cae9a4d4935f55ca9e80
#. type: Plain text
#: build/C/man2/stat.2:798
msgid ""
"Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4 (since "
"Linux 2.6.23).  Nanosecond timestamps are not supported in ext2, ext3, and "
"Reiserfs.  On filesystems that do not support subsecond timestamps, the "
"nanosecond fields are returned with the value 0."
msgstr ""

#. type: SS
#: build/C/man2/stat.2:798
#, no-wrap
msgid "Underlying kernel interface"
msgstr ""

#
#.  A note from Andries Brouwer, July 2007
#
#.  > Is the story not rather more complicated for some calls like
#.  > stat(2)?
#
#.  Yes and no, mostly no. See /usr/include/sys/stat.h .
#
#.  The idea is here not so much that syscalls change, but that
#.  the definitions of struct stat and of the types dev_t and mode_t change.
#.  This means that libc (even if it does not call the kernel
#.  but only calls some internal function) must know what the
#.  format of dev_t or of struct stat is.
#.  The communication between the application and libc goes via
#.  the include file <sys/stat.h> that defines a _STAT_VER and
#.  _MKNOD_VER describing the layout of the data that user space
#.  uses. Each (almost each) occurrence of stat() is replaced by
#.  an occurrence of xstat() where the first parameter of xstat()
#.  is this version number _STAT_VER.
#
#.  Now, also the definitions used by the kernel change.
#.  But glibc copes with this in the standard way, and the
#.  struct stat as returned by the kernel is repacked into
#.  the struct stat as expected by the application.
#.  Thus, _STAT_VER and this setup cater for the application-libc
#.  interface, rather than the libc-kernel interface.
#
#.  (Note that the details depend on gcc being used as c compiler.)
#. type: Plain text
#: build/C/man2/stat.2:850
msgid ""
"Over time, increases in the size of the I<stat> structure have led to three "
"successive versions of B<stat>(): I<sys_stat>()  (slot I<__NR_oldstat>), "
"I<sys_newstat>()  (slot I<__NR_stat>), and I<sys_stat64()> (new in kernel "
"2.4; slot I<__NR_stat64>).  The glibc B<stat>()  wrapper function hides "
"these details from applications, invoking the most recent version of the "
"system call provided by the kernel, and repacking the returned information "
"if required for old binaries.  Similar remarks apply for B<fstat>()  and "
"B<lstat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:855
msgid ""
"The underlying system call employed by the glibc B<fstatat>()  wrapper "
"function is actually called B<fstatat64>()."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:861
msgid ""
"The following program calls B<stat>()  and displays selected fields in the "
"returned I<stat> structure."
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:868
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:873
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct stat sb;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:878
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pathnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:883
#, no-wrap
msgid ""
"    if (stat(argv[1], &sb) == -1) {\n"
"        perror(\"stat\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:885
#, no-wrap
msgid "    printf(\"File type:                \");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:896
#, no-wrap
msgid ""
"    switch (sb.st_mode & S_IFMT) {\n"
"    case S_IFBLK:  printf(\"block device\\en\");            break;\n"
"    case S_IFCHR:  printf(\"character device\\en\");        break;\n"
"    case S_IFDIR:  printf(\"directory\\en\");               break;\n"
"    case S_IFIFO:  printf(\"FIFO/pipe\\en\");               break;\n"
"    case S_IFLNK:  printf(\"symlink\\en\");                 break;\n"
"    case S_IFREG:  printf(\"regular file\\en\");            break;\n"
"    case S_IFSOCK: printf(\"socket\\en\");                  break;\n"
"    default:       printf(\"unknown?\\en\");                break;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:898
#, no-wrap
msgid "    printf(\"I-node number:            %ld\\en\", (long) sb.st_ino);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:901
#, no-wrap
msgid ""
"    printf(\"Mode:                     %lo (octal)\\en\",\n"
"            (unsigned long) sb.st_mode);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:905
#, no-wrap
msgid ""
"    printf(\"Link count:               %ld\\en\", (long) sb.st_nlink);\n"
"    printf(\"Ownership:                UID=%ld   GID=%ld\\en\",\n"
"            (long) sb.st_uid, (long) sb.st_gid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:912
#, no-wrap
msgid ""
"    printf(\"Preferred I/O block size: %ld bytes\\en\",\n"
"            (long) sb.st_blksize);\n"
"    printf(\"File size:                %lld bytes\\en\",\n"
"            (long long) sb.st_size);\n"
"    printf(\"Blocks allocated:         %lld\\en\",\n"
"            (long long) sb.st_blocks);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:916
#, no-wrap
msgid ""
"    printf(\"Last status change:       %s\", ctime(&sb.st_ctime));\n"
"    printf(\"Last file access:         %s\", ctime(&sb.st_atime));\n"
"    printf(\"Last file modification:   %s\", ctime(&sb.st_mtime));\n"
msgstr ""

#. type: Plain text
#: build/C/man2/stat.2:930
msgid ""
"B<ls>(1), B<stat>(1), B<access>(2), B<chmod>(2), B<chown>(2), "
"B<readlink>(2), B<utime>(2), B<capabilities>(7), B<symlink>(7)"
msgstr ""

#. type: TH
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "STATFS"
msgstr ""

#. type: TH
#: build/C/man2/statfs.2:28
#, no-wrap
msgid "2014-06-13"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:31
msgid "statfs, fstatfs - get filesystem statistics"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:33
msgid "B<#include E<lt>sys/vfs.hE<gt> >/* or E<lt>sys/statfs.hE<gt> */"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:35
msgid "B<int statfs(const char *>I<path>B<, struct statfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:37
msgid "B<int fstatfs(int >I<fd>B<, struct statfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:47
msgid ""
"The function B<statfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statfs> structure defined approximately as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:55
#, no-wrap
msgid ""
"#if __WORDSIZE == 32\t\t/* System word size */\n"
"# define __SWORD_TYPE           int\n"
"#else /* __WORDSIZE == 64 */\n"
"# define __SWORD_TYPE\t\tlong int\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:70
#, no-wrap
msgid ""
"struct statfs {\n"
"    __SWORD_TYPE f_type;    /* type of filesystem (see below) */\n"
"    __SWORD_TYPE f_bsize;   /* optimal transfer block size */\n"
"    fsblkcnt_t   f_blocks;  /* total data blocks in filesystem */\n"
"    fsblkcnt_t   f_bfree;   /* free blocks in fs */\n"
"    fsblkcnt_t   f_bavail;  /* free blocks available to\n"
"                               unprivileged user */\n"
"    fsfilcnt_t   f_files;   /* total file nodes in filesystem */\n"
"    fsfilcnt_t   f_ffree;   /* free file nodes in fs */\n"
"    fsid_t       f_fsid;    /* filesystem id */\n"
"    __SWORD_TYPE f_namelen; /* maximum length of filenames */\n"
"    __SWORD_TYPE f_frsize;  /* fragment size (since Linux 2.6) */\n"
"    __SWORD_TYPE f_spare[5];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:72
#, no-wrap
msgid "Filesystem types:\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:142
#, no-wrap
msgid ""
"   ADFS_SUPER_MAGIC      0xadf5\n"
"   AFFS_SUPER_MAGIC      0xADFF\n"
"   BDEVFS_MAGIC          0x62646576\n"
"   BEFS_SUPER_MAGIC      0x42465331\n"
"   BFS_MAGIC             0x1BADFACE\n"
"   BINFMTFS_MAGIC        0x42494e4d\n"
"   BTRFS_SUPER_MAGIC     0x9123683E\n"
"   CGROUP_SUPER_MAGIC    0x27e0eb\n"
"   CIFS_MAGIC_NUMBER     0xFF534D42\n"
"   CODA_SUPER_MAGIC      0x73757245\n"
"   COH_SUPER_MAGIC       0x012FF7B7\n"
"   CRAMFS_MAGIC          0x28cd3d45\n"
"   DEBUGFS_MAGIC         0x64626720\n"
"   DEVFS_SUPER_MAGIC     0x1373\n"
"   DEVPTS_SUPER_MAGIC    0x1cd1\n"
"   EFIVARFS_MAGIC        0xde5e81e4\n"
"   EFS_SUPER_MAGIC       0x00414A53\n"
"   EXT_SUPER_MAGIC       0x137D\n"
"   EXT2_OLD_SUPER_MAGIC  0xEF51\n"
"   EXT2_SUPER_MAGIC      0xEF53\n"
"   EXT3_SUPER_MAGIC      0xEF53\n"
"   EXT4_SUPER_MAGIC      0xEF53\n"
"   FUSE_SUPER_MAGIC      0x65735546\n"
"   FUTEXFS_SUPER_MAGIC   0xBAD1DEA\n"
"   HFS_SUPER_MAGIC       0x4244\n"
"   HOSTFS_SUPER_MAGIC    0x00c0ffee\n"
"   HPFS_SUPER_MAGIC      0xF995E849\n"
"   HUGETLBFS_MAGIC       0x958458f6\n"
"   ISOFS_SUPER_MAGIC     0x9660\n"
"   JFFS2_SUPER_MAGIC     0x72b6\n"
"   JFS_SUPER_MAGIC       0x3153464a\n"
"   MINIX_SUPER_MAGIC     0x137F /* orig. minix */\n"
"   MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */\n"
"   MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */\n"
"   MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */\n"
"   MINIX3_SUPER_MAGIC    0x4d5a /* minix V3 fs, 60 char names */\n"
"   MQUEUE_MAGIC          0x19800202\n"
"   MSDOS_SUPER_MAGIC     0x4d44\n"
"   NCP_SUPER_MAGIC       0x564c\n"
"   NFS_SUPER_MAGIC       0x6969\n"
"   NILFS_SUPER_MAGIC     0x3434\n"
"   NTFS_SB_MAGIC         0x5346544e\n"
"   OPENPROM_SUPER_MAGIC  0x9fa1\n"
"   PIPEFS_MAGIC          0x50495045\n"
"   PROC_SUPER_MAGIC      0x9fa0\n"
"   PSTOREFS_MAGIC        0x6165676C\n"
"   QNX4_SUPER_MAGIC      0x002f\n"
"   QNX6_SUPER_MAGIC      0x68191122\n"
"   RAMFS_MAGIC           0x858458f6\n"
"   REISERFS_SUPER_MAGIC  0x52654973\n"
"   ROMFS_MAGIC           0x7275\n"
"   SELINUX_MAGIC         0xf97cff8c\n"
"   SMACK_MAGIC           0x43415d53\n"
"   SMB_SUPER_MAGIC       0x517B\n"
"   SOCKFS_MAGIC          0x534F434B\n"
"   SQUASHFS_MAGIC        0x73717368\n"
"   SYSFS_MAGIC           0x62656572\n"
"   SYSV2_SUPER_MAGIC     0x012FF7B6\n"
"   SYSV4_SUPER_MAGIC     0x012FF7B5\n"
"   TMPFS_MAGIC           0x01021994\n"
"   UDF_SUPER_MAGIC       0x15013346\n"
"   UFS_MAGIC             0x00011954\n"
"   USBDEVICE_SUPER_MAGIC 0x9fa2\n"
"   V9FS_MAGIC            0x01021997\n"
"   VXFS_SUPER_MAGIC      0xa501FCF5\n"
"   XENFS_SUPER_MAGIC     0xabba1974\n"
"   XENIX_SUPER_MAGIC     0x012FF7B4\n"
"   XFS_SUPER_MAGIC       0x58465342\n"
"   _XIAFS_SUPER_MAGIC    0x012FD16D\n"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:148
msgid ""
"Most of these MAGIC constants are defined in I</usr/include/linux/magic.h>, "
"and some are hardcoded in kernel sources."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:152
msgid "Nobody knows what I<f_fsid> is supposed to contain (but see below)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:157
msgid ""
"Fields that are undefined for a particular filesystem are set to 0.  "
"B<fstatfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:170
msgid ""
"(B<statfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:175
msgid "(B<fstatfs>())  I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:181
msgid "I<buf> or I<path> points to an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:184 build/C/man3/statvfs.3:123
msgid "This call was interrupted by a signal."
msgstr ""

#. type: TP
#: build/C/man2/statfs.2:184 build/C/man3/statvfs.3:123
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:187 build/C/man3/statvfs.3:126
msgid "An I/O error occurred while reading from the filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:192
msgid ""
"(B<statfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:197
msgid "(B<statfs>())  I<path> is too long."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:203
msgid "(B<statfs>())  The file referred to by I<path> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:206 build/C/man3/statvfs.3:145
msgid "Insufficient kernel memory was available."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:209 build/C/man3/statvfs.3:148
msgid "The filesystem does not support this call."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:215
msgid "(B<statfs>())  A component of the path prefix of I<path> is not a directory."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:218 build/C/man3/statvfs.3:157
msgid "Some values were too large to be represented in the returned struct."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:224
msgid ""
"Linux-specific.  The Linux B<statfs>()  was inspired by the 4.4BSD one (but "
"they do not use the same structure)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:246
msgid ""
"The original Linux B<statfs>()  and B<fstatfs>()  system calls were not "
"designed with extremely large file sizes in mind.  Subsequently, Linux 2.6 "
"added new B<statfs64>()  and B<fstatfs64>()  system calls that employ a new "
"structure, I<statfs64>.  The new structure contains the same fields as the "
"original I<statfs> structure, but the sizes of various fields are increased, "
"to accommodate large file sizes.  The glibc B<statfs>()  and B<fstatfs>()  "
"wrapper functions transparently deal with the kernel differences."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:251
msgid ""
"Some systems have only I<E<lt>sys/vfs.hE<gt>>, other systems also have "
"I<E<lt>sys/statfs.hE<gt>>, where the former includes the latter.  So it "
"seems including the former is the best choice."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:261
msgid ""
"LSB has deprecated the library calls B<statfs>()  and B<fstatfs>()  and "
"tells us to use B<statvfs>(2)  and B<fstatvfs>(2)  instead."
msgstr ""

#. type: SS
#: build/C/man2/statfs.2:261
#, no-wrap
msgid "The f_fsid field"
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:286
msgid ""
"Solaris, Irix and POSIX have a system call B<statvfs>(2)  that returns a "
"I<struct statvfs> (defined in I<E<lt>sys/statvfs.hE<gt>>)  containing an "
"I<unsigned long> I<f_fsid>.  Linux, SunOS, HP-UX, 4.4BSD have a system call "
"B<statfs>()  that returns a I<struct statfs> (defined in "
"I<E<lt>sys/vfs.hE<gt>>)  containing a I<fsid_t> I<f_fsid>, where I<fsid_t> "
"is defined as I<struct { int val[2]; }>.  The same holds for FreeBSD, except "
"that it uses the include file I<E<lt>sys/mount.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:299
msgid ""
"The general idea is that I<f_fsid> contains some random stuff such that the "
"pair (I<f_fsid>,I<ino>)  uniquely determines a file.  Some operating systems "
"use (a variation on) the device number, or the device number combined with "
"the filesystem type.  Several operating systems restrict giving out the "
"I<f_fsid> field to the superuser only (and zero it for unprivileged users), "
"because this field is used in the filehandle of the filesystem when "
"NFS-exported, and giving it out is a security concern."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:305
msgid ""
"Under some operating systems, the I<fsid> can be used as the second argument "
"to the B<sysfs>(2)  system call."
msgstr ""

#.  broken in commit ff0c7d15f9787b7e8c601533c015295cc68329f8
#.  fixed in commit d70ef97baf048412c395bb5d65791d8fe133a52b
#. type: Plain text
#: build/C/man2/statfs.2:314
msgid ""
"From Linux 2.6.38 up to and including Linux 3.1, B<fstatfs>()  failed with "
"the error B<ENOSYS> for file descriptors created by B<pipe>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/statfs.2:318
msgid "B<stat>(2), B<statvfs>(2), B<path_resolution>(7)"
msgstr ""

#. type: TH
#: build/C/man3/statvfs.3:30
#, no-wrap
msgid "STATVFS"
msgstr ""

#. type: TH
#: build/C/man3/statvfs.3:30
#, no-wrap
msgid "2013-09-26"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:33
msgid "statvfs, fstatvfs - get filesystem statistics"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:35
msgid "B<#include E<lt>sys/statvfs.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:37
msgid "B<int statvfs(const char *>I<path>B<, struct statvfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:39
msgid "B<int fstatvfs(int >I<fd>B<, struct statvfs *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:49
msgid ""
"The function B<statvfs>()  returns information about a mounted filesystem.  "
"I<path> is the pathname of any file within the mounted filesystem.  I<buf> "
"is a pointer to a I<statvfs> structure defined approximately as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:65
#, no-wrap
msgid ""
"struct statvfs {\n"
"    unsigned long  f_bsize;    /* filesystem block size */\n"
"    unsigned long  f_frsize;   /* fragment size */\n"
"    fsblkcnt_t     f_blocks;   /* size of fs in f_frsize units */\n"
"    fsblkcnt_t     f_bfree;    /* # free blocks */\n"
"    fsblkcnt_t     f_bavail;   /* # free blocks for unprivileged users */\n"
"    fsfilcnt_t     f_files;    /* # inodes */\n"
"    fsfilcnt_t     f_ffree;    /* # free inodes */\n"
"    fsfilcnt_t     f_favail;   /* # free inodes for unprivileged users */\n"
"    unsigned long  f_fsid;     /* filesystem ID */\n"
"    unsigned long  f_flag;     /* mount flags */\n"
"    unsigned long  f_namemax;  /* maximum filename length */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:76
msgid ""
"Here the types I<fsblkcnt_t> and I<fsfilcnt_t> are defined in "
"I<E<lt>sys/types.hE<gt>>.  Both used to be I<unsigned long>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:82
msgid ""
"The field I<f_flag> is a bit mask (of mount flags, see B<mount>(8)).  Bits "
"defined by POSIX are"
msgstr ""

#. type: TP
#: build/C/man3/statvfs.3:82
#, no-wrap
msgid "B<ST_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:85
msgid "Read-only filesystem."
msgstr ""

#. type: TP
#: build/C/man3/statvfs.3:85
#, no-wrap
msgid "B<ST_NOSUID>"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:89
msgid "Set-user-ID/set-group-ID bits are ignored by B<exec>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:92
msgid ""
"It is unspecified whether all members of the returned struct have meaningful "
"values on all filesystems."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:96
msgid ""
"B<fstatvfs>()  returns the same information about an open file referenced by "
"descriptor I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:109
msgid ""
"(B<statvfs>())  Search permission is denied for a component of the path "
"prefix of I<path>.  (See also B<path_resolution>(7).)"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:114
msgid "(B<fstatvfs>())  I<fd> is not a valid open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:120
msgid "I<Buf> or I<path> points to an invalid address."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:131
msgid ""
"(B<statvfs>())  Too many symbolic links were encountered in translating "
"I<path>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:136
msgid "(B<statvfs>())  I<path> is too long."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:142
msgid "(B<statvfs>())  The file referred to by I<path> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:154
msgid ""
"(B<statvfs>())  A component of the path prefix of I<path> is not a "
"directory."
msgstr ""

#. type: SH
#: build/C/man3/statvfs.3:157
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: SS
#: build/C/man3/statvfs.3:158
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:164
msgid "The B<statvfs>()  and B<fstatvfs>()  functions are thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:166
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:172
msgid ""
"The Linux kernel has system calls B<statfs>(2)  and B<fstatfs>(2)  to "
"support this library call."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:174
msgid "The current glibc implementations of"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:179
#, no-wrap
msgid ""
"   pathconf(path, _PC_REC_XFER_ALIGN);\n"
"   pathconf(path, _PC_ALLOC_SIZE_MIN);\n"
"   pathconf(path, _PC_REC_MIN_XFER_SIZE);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:188
msgid ""
"respectively use the I<f_frsize>, I<f_frsize>, and I<f_bsize> fields of the "
"return value of I<statvfs(path,buf)>."
msgstr ""

#. type: Plain text
#: build/C/man3/statvfs.3:190
msgid "B<statfs>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sysfs.2:27
#, no-wrap
msgid "SYSFS"
msgstr ""

#. type: TH
#: build/C/man2/sysfs.2:27
#, no-wrap
msgid "2010-06-27"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:30
msgid "sysfs - get filesystem type information"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:32
msgid "B<int sysfs(int >I<option>B<, const char *>I<fsname>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:34
msgid ""
"B<int sysfs(int >I<option>B<, unsigned int >I<fs_index>B<, char "
"*>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:36
msgid "B<int sysfs(int >I<option>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:45
msgid ""
"B<sysfs>()  returns information about the filesystem types currently present "
"in the kernel.  The specific form of the B<sysfs>()  call and the "
"information returned depends on the I<option> in effect:"
msgstr ""

#. type: TP
#: build/C/man2/sysfs.2:45
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:50
msgid ""
"Translate the filesystem identifier string I<fsname> into a filesystem type "
"index."
msgstr ""

#. type: TP
#: build/C/man2/sysfs.2:50
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:61
msgid ""
"Translate the filesystem type index I<fs_index> into a null-terminated "
"filesystem identifier string.  This string will be written to the buffer "
"pointed to by I<buf>.  Make sure that I<buf> has enough space to accept the "
"string."
msgstr ""

#. type: TP
#: build/C/man2/sysfs.2:61
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:65
msgid "Return the total number of filesystem types currently present in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:67
msgid "The numbering of the filesystem type indexes begins with zero."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:79
msgid ""
"On success, B<sysfs>()  returns the filesystem index for option B<1>, zero "
"for option B<2>, and the number of currently configured filesystems for "
"option B<3>.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:84
msgid "Either I<fsname> or I<buf> is outside your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:92
msgid ""
"I<fsname> is not a valid filesystem type identifier; I<fs_index> is "
"out-of-bounds; I<option> is invalid."
msgstr ""

#.  SVr4 documents additional error conditions ENOLINK, ECOMM, and EINTR
#.  but has no ENOSYS condition.
#. type: Plain text
#: build/C/man2/sysfs.2:94 build/C/man2/ustat.2:98
msgid "SVr4."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:101
msgid ""
"This System-V derived system call is obsolete; don't use it.  On systems "
"with I</proc>, the same information can be obtained via "
"I</proc/filesystems>; use that interface instead."
msgstr ""

#. type: Plain text
#: build/C/man2/sysfs.2:104
msgid ""
"There is no libc or glibc support.  There is no way to guess how large "
"I<buf> should be."
msgstr ""

#. type: TH
#: build/C/man2/umount.2:30
#, no-wrap
msgid "UMOUNT"
msgstr ""

#. type: TH
#: build/C/man2/umount.2:30
#, no-wrap
msgid "2014-02-26"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:33
msgid "umount, umount2 - unmount filesystem"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:38
#, no-wrap
msgid "B<int umount(const char *>I<target>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:40
#, no-wrap
msgid "B<int umount2(const char *>I<target>B<, int >I<flags>B<);>\n"
msgstr ""

#.  Note: the kernel naming differs from the glibc naming
#.  umount2 is the glibc name for what the kernel now calls umount
#.  and umount is the glibc name for oldumount
#. type: Plain text
#: build/C/man2/umount.2:50
msgid ""
"B<umount>()  and B<umount2>()  remove the attachment of the (topmost) "
"filesystem mounted on I<target>."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:54
msgid ""
"Appropriate privilege (Linux: the B<CAP_SYS_ADMIN> capability) is required "
"to unmount filesystems."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:62
msgid ""
"Linux 2.1.116 added the B<umount2>()  system call, which, like B<umount>(), "
"unmounts a target, but allows additional I<flags> controlling the behavior "
"of the operation:"
msgstr ""

#. type: TP
#: build/C/man2/umount.2:62
#, no-wrap
msgid "B<MNT_FORCE> (since Linux 2.1.116)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:67
msgid ""
"Force unmount even if busy.  This can cause data loss.  (Only for NFS "
"mounts.)"
msgstr ""

#. type: TP
#: build/C/man2/umount.2:67
#, no-wrap
msgid "B<MNT_DETACH> (since Linux 2.4.11)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:72
msgid ""
"Perform a lazy unmount: make the mount point unavailable for new accesses, "
"and actually perform the unmount when the mount point ceases to be busy."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:72
#, no-wrap
msgid "B<MNT_EXPIRE> (since Linux 2.6.8)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:91
msgid ""
"Mark the mount point as expired.  If a mount point is not currently in use, "
"then an initial call to B<umount2>()  with this flag fails with the error "
"B<EAGAIN>, but marks the mount point as expired.  The mount point remains "
"expired as long as it isn't accessed by any process.  A second B<umount2>()  "
"call specifying B<MNT_EXPIRE> unmounts an expired mount point.  This flag "
"cannot be specified with either B<MNT_FORCE> or B<MNT_DETACH>."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:91
#, no-wrap
msgid "B<UMOUNT_NOFOLLOW> (since Linux 2.6.34)"
msgstr ""

#.  Later added to 2.6.33-stable
#. type: Plain text
#: build/C/man2/umount.2:99
msgid ""
"Don't dereference I<target> if it is a symbolic link.  This flag allows "
"security problems to be avoided in set-user-ID-I<root> programs that allow "
"unprivileged users to unmount filesystems."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:110
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:117
msgid ""
"A call to B<umount2>()  specifying B<MNT_EXPIRE> successfully marked an "
"unbusy filesystem as expired."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:121
msgid "I<target> could not be unmounted because it is busy."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:125
msgid "I<target> points outside the user address space."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:129
msgid "I<target> is not a mount point."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:138
msgid ""
"B<umount2>()  was called with B<MNT_EXPIRE> and either B<MNT_DETACH> or "
"B<MNT_FORCE>."
msgstr ""

#. type: TP
#: build/C/man2/umount.2:138
#, no-wrap
msgid "B<EINVAL> (since Linux 2.6.34)"
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:143
msgid "B<umount2>()  was called with an invalid flag value in I<flags>."
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=10092
#. type: Plain text
#: build/C/man2/umount.2:162
msgid "B<MNT_DETACH> and B<MNT_EXPIRE> are available in glibc since version 2.11."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:165
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:176
msgid ""
"The original B<umount>()  function was called as I<umount(device)> and would "
"return B<ENOTBLK> when called with something other than a block device.  In "
"Linux 0.98p4, a call I<umount(dir)> was added, in order to support anonymous "
"devices.  In Linux 2.3.99-pre7, the call I<umount(device)> was removed, "
"leaving only I<umount(dir)> (since now devices can be mounted in more than "
"one place, so specifying the device does not suffice)."
msgstr ""

#. type: Plain text
#: build/C/man2/umount.2:181
msgid "B<mount>(2), B<path_resolution>(7), B<mount>(8), B<umount>(8)"
msgstr ""

#. type: TH
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "USTAT"
msgstr ""

#. type: TH
#: build/C/man2/ustat.2:30
#, no-wrap
msgid "2003-08-04"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:33
msgid "ustat - get filesystem statistics"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:38
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>    /* libc[45] */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:40
#, no-wrap
msgid "B<#include E<lt>ustat.hE<gt>>     /* glibc2 */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:42
#, no-wrap
msgid "B<int ustat(dev_t >I<dev>B<, struct ustat *>I<ubuf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:54
msgid ""
"B<ustat>()  returns information about a mounted filesystem.  I<dev> is a "
"device number identifying a device containing a mounted filesystem.  I<ubuf> "
"is a pointer to a I<ustat> structure that contains the following members:"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:61
#, no-wrap
msgid ""
"daddr_t f_tfree;      /* Total free blocks */\n"
"ino_t   f_tinode;     /* Number of free inodes */\n"
"char    f_fname[6];   /* Filsys name */\n"
"char    f_fpack[6];   /* Filsys pack name */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:70
msgid ""
"The last two fields, I<f_fname> and I<f_fpack>, are not implemented and will "
"always be filled with null bytes (\\(aq\\e0\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:79
msgid ""
"On success, zero is returned and the I<ustat> structure pointed to by "
"I<ubuf> will be filled in.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:84
msgid "I<ubuf> points outside of your accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:88
msgid "I<dev> does not refer to a device containing a mounted filesystem."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:94
msgid ""
"The mounted filesystem referenced by I<dev> does not support this operation, "
"or any version of Linux before 1.3.16."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:104
msgid ""
"B<ustat>()  is deprecated and has been provided only for compatibility.  All "
"new programs should use B<statfs>(2)  instead."
msgstr ""

#. type: SS
#: build/C/man2/ustat.2:104
#, no-wrap
msgid "HP-UX notes"
msgstr ""

#.  Some software tries to use this in order to test whether the
#.  underlying filesystem is NFS.
#. type: Plain text
#: build/C/man2/ustat.2:118
msgid ""
"The HP-UX version of the I<ustat> structure has an additional field, "
"I<f_blksize>, that is unknown elsewhere.  HP-UX warns: For some filesystems, "
"the number of free inodes does not change.  Such filesystems will return -1 "
"in the field I<f_tinode>.  For some filesystems, inodes are dynamically "
"allocated.  Such filesystems will return the current number of free inodes."
msgstr ""

#. type: Plain text
#: build/C/man2/ustat.2:121
msgid "B<stat>(2), B<statfs>(2)"
msgstr ""

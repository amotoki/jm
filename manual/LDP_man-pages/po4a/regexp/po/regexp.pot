# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-09-28 04:06+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/fnmatch.3:28
#, no-wrap
msgid "FNMATCH"
msgstr ""

#. type: TH
#: build/C/man3/fnmatch.3:28
#, no-wrap
msgid "2000-10-15"
msgstr ""

#. type: TH
#: build/C/man3/fnmatch.3:28 build/C/man3/glob.3:34 build/C/man3/re_comp.3:27 build/C/man3/regex.3:30
#, no-wrap
msgid "GNU"
msgstr ""

#. type: TH
#: build/C/man3/fnmatch.3:28 build/C/man3/glob.3:34 build/C/man7/glob.7:26 build/C/man3/re_comp.3:27 build/C/man3/regex.3:30 build/C/man7/regex.7:37 build/C/man3/wordexp.3:24
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:29 build/C/man3/glob.3:35 build/C/man7/glob.7:27 build/C/man3/re_comp.3:28 build/C/man3/regex.3:31 build/C/man7/regex.7:38 build/C/man3/wordexp.3:25
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:31
msgid "fnmatch - match filename or pathname"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:31 build/C/man3/glob.3:37 build/C/man3/re_comp.3:30 build/C/man3/regex.3:33 build/C/man3/wordexp.3:27
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:34
#, no-wrap
msgid "B<#include E<lt>fnmatch.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:36
#, no-wrap
msgid ""
"B<int fnmatch(const char *>I<pattern>B<, const char *>I<string>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:37 build/C/man3/glob.3:49 build/C/man7/glob.7:29 build/C/man3/re_comp.3:40 build/C/man3/regex.3:49 build/C/man7/regex.7:40 build/C/man3/wordexp.3:42
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:45
msgid ""
"The B<fnmatch>()  function checks whether the I<string> argument matches the "
"I<pattern> argument, which is a shell wildcard pattern."
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:50
msgid ""
"The I<flags> argument modifies the behavior; it is the bitwise OR of zero or "
"more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:50
#, no-wrap
msgid "B<FNM_NOESCAPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:54
msgid ""
"If this flag is set, treat backslash as an ordinary character, instead of an "
"escape character."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:54
#, no-wrap
msgid "B<FNM_PATHNAME>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:62
msgid ""
"If this flag is set, match a slash in I<string> only with a slash in "
"I<pattern> and not by an asterisk (*) or a question mark (?) metacharacter, "
"nor by a bracket expression ([]) containing a slash."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:62
#, no-wrap
msgid "B<FNM_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:73
msgid ""
"If this flag is set, a leading period in I<string> has to be matched exactly "
"by a period in I<pattern>.  A period is considered to be leading if it is "
"the first character in I<string>, or if both B<FNM_PATHNAME> is set and the "
"period immediately follows a slash."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:73
#, no-wrap
msgid "B<FNM_FILE_NAME>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:77
msgid "This is a GNU synonym for B<FNM_PATHNAME>."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:77
#, no-wrap
msgid "B<FNM_LEADING_DIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:85
msgid ""
"If this flag (a GNU extension) is set, the pattern is considered to be "
"matched if it matches an initial segment of I<string> which is followed by a "
"slash.  This flag is mainly for the internal use of glibc and is implemented "
"only in certain cases."
msgstr ""

#. type: TP
#: build/C/man3/fnmatch.3:85
#, no-wrap
msgid "B<FNM_CASEFOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:89
msgid ""
"If this flag (a GNU extension) is set, the pattern is matched "
"case-insensitively."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:89 build/C/man3/glob.3:262 build/C/man3/re_comp.3:58 build/C/man3/regex.3:247 build/C/man3/wordexp.3:157
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:96
msgid ""
"Zero if I<string> matches I<pattern>, B<FNM_NOMATCH> if there is no match or "
"another nonzero value if there is an error."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:96 build/C/man3/glob.3:276 build/C/man3/re_comp.3:73 build/C/man3/regex.3:304 build/C/man3/wordexp.3:187
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:101
msgid ""
"POSIX.2.  The B<FNM_FILE_NAME>, B<FNM_LEADING_DIR>, and B<FNM_CASEFOLD> "
"flags are GNU extensions."
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:101 build/C/man3/glob.3:319 build/C/man7/glob.7:208 build/C/man3/re_comp.3:79 build/C/man3/regex.3:306 build/C/man7/regex.7:286 build/C/man3/wordexp.3:213
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:107
msgid "B<sh>(1), B<glob>(3), B<scandir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""

#. type: SH
#: build/C/man3/fnmatch.3:107 build/C/man3/glob.3:330 build/C/man7/glob.7:214 build/C/man3/re_comp.3:83 build/C/man3/regex.3:312 build/C/man7/regex.7:291 build/C/man3/wordexp.3:216
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/fnmatch.3:114 build/C/man3/glob.3:337 build/C/man7/glob.7:221 build/C/man3/re_comp.3:90 build/C/man3/regex.3:319 build/C/man7/regex.7:298 build/C/man3/wordexp.3:223
msgid ""
"This page is part of release 3.54 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/glob.3:34 build/C/man7/glob.7:26
#, no-wrap
msgid "GLOB"
msgstr ""

#. type: TH
#: build/C/man3/glob.3:34
#, no-wrap
msgid "2007-10-10"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:37
msgid "glob, globfree - find pathnames matching a pattern, free memory from glob()"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:40
#, no-wrap
msgid "B<#include E<lt>glob.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:42
#, no-wrap
msgid "B<int glob(const char *>I<pattern>B<, int >I<flags>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:44
#, no-wrap
msgid ""
"B<         int (*>I<errfunc>B<) (const char *>I<epath>B<, int "
">I<eerrno>B<),>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:46
#, no-wrap
msgid "B<         glob_t *>I<pglob>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:48
#, no-wrap
msgid "B<void globfree(glob_t *>I<pglob>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:59
msgid ""
"The B<glob>()  function searches for all the pathnames matching I<pattern> "
"according to the rules used by the shell (see B<glob>(7)).  No tilde "
"expansion or parameter substitution is done; if you want these, use "
"B<wordexp>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:65
msgid ""
"The B<globfree>()  function frees the dynamically allocated storage from an "
"earlier call to B<glob>()."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:76
msgid ""
"The results of a B<glob>()  call are stored in the structure pointed to by "
"I<pglob>.  This structure is of type I<glob_t> (declared in "
"I<E<lt>glob.hE<gt>>)  and includes the following elements defined by POSIX.2 "
"(more may be present as an extension):"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:85
#, no-wrap
msgid ""
"typedef struct {\n"
"    size_t   gl_pathc;    /* Count of paths matched so far  */\n"
"    char   **gl_pathv;    /* List of matched pathnames.  */\n"
"    size_t   gl_offs;     /* Slots to reserve in I<gl_pathv>.  */\n"
"} glob_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:89
msgid "Results are stored in dynamically allocated storage."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:95
msgid ""
"The argument I<flags> is made up of the bitwise OR of zero or more the "
"following symbolic constants, which modify the behavior of B<glob>():"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:95
#, no-wrap
msgid "B<GLOB_ERR>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:103
msgid ""
"Return upon a read error (because a directory does not have read permission, "
"for example).  By default, B<glob>()  attempts carry on despite errors, "
"reading all of the directories that it can."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:103
#, no-wrap
msgid "B<GLOB_MARK>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:106
msgid "Append a slash to each path which corresponds to a directory."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:106
#, no-wrap
msgid "B<GLOB_NOSORT>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:111
msgid ""
"Don't sort the returned pathnames.  The only reason to do this is to save "
"processing time.  By default, the returned pathnames are sorted."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:111
#, no-wrap
msgid "B<GLOB_DOOFFS>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:118
msgid ""
"Reserve I<pglob-E<gt>gl_offs> slots at the beginning of the list of strings "
"in I<pglob-E<gt>pathv>.  The reserved slots contain NULL pointers."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:118
#, no-wrap
msgid "B<GLOB_NOCHECK>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:126
msgid ""
"If no pattern matches, return the original pattern.  By default, B<glob>()  "
"returns B<GLOB_NOMATCH> if there are no matches."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:126
#, no-wrap
msgid "B<GLOB_APPEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:133
msgid ""
"Append the results of this call to the vector of results returned by a "
"previous call to B<glob>().  Do not set this flag on the first invocation of "
"B<glob>()."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:133
#, no-wrap
msgid "B<GLOB_NOESCAPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:140
msgid ""
"Don't allow backslash (\\(aq\\e\\(aq) to be used as an escape character.  "
"Normally, a backslash can be used to quote the following character, "
"providing a mechanism to turn off the special meaning metacharacters."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:144
msgid ""
"I<flags> may also include any of the following, which are GNU extensions and "
"not defined by POSIX.2:"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:144
#, no-wrap
msgid "B<GLOB_PERIOD>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:148
msgid ""
"Allow a leading period to be matched by metacharacters.  By default, "
"metacharacters can't match a leading period."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:148
#, no-wrap
msgid "B<GLOB_ALTDIRFUNC>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:158
msgid ""
"Use alternative functions I<pglob-E<gt>gl_closedir>, "
"I<pglob-E<gt>gl_readdir>, I<pglob-E<gt>gl_opendir>, I<pglob-E<gt>gl_lstat>, "
"and I<pglob-E<gt>gl_stat> for filesystem access instead of the normal "
"library functions."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:158
#, no-wrap
msgid "B<GLOB_BRACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:174
msgid ""
"Expand B<csh>(1)  style brace expressions of the form B<{a,b}>.  Brace "
"expressions can be nested.  Thus, for example, specifying the pattern "
"\"{foo/{,cat,dog},bar}\" would return the same results as four separate "
"B<glob>()  calls using the strings: \"foo/\", \"foo/cat\", \"foo/dog\", and "
"\"bar\"."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:174
#, no-wrap
msgid "B<GLOB_NOMAGIC>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:179
msgid ""
"If the pattern contains no metacharacters then it should be returned as the "
"sole matching word, even if there is no file with that name."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:179
#, no-wrap
msgid "B<GLOB_TILDE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:191
msgid ""
"Carry out tilde expansion.  If a tilde (\\(aq~\\(aq) is the only character "
"in the pattern, or an initial tilde is followed immediately by a slash "
"(\\(aq/\\(aq), then the home directory of the caller is substituted for the "
"tilde.  If an initial tilde is followed by a username (e.g., "
"\"~andrea/bin\"), then the tilde and username are substituted by the home "
"directory of that user.  If the username is invalid, or the home directory "
"cannot be determined, then no substitution is performed."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:191
#, no-wrap
msgid "B<GLOB_TILDE_CHECK>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:202
msgid ""
"This provides behavior similar to that of B<GLOB_TILDE>.  The difference is "
"that if the username is invalid, or the home directory cannot be determined, "
"then instead of using the pattern itself as the name, B<glob>()  returns "
"B<GLOB_NOMATCH> to indicate an error."
msgstr ""

#. type: TP
#: build/C/man3/glob.3:202
#, no-wrap
msgid "B<GLOB_ONLYDIR>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:215
msgid ""
"This is a I<hint> to B<glob>()  that the caller is interested only in "
"directories that match the pattern.  If the implementation can easily "
"determine file-type information, then nondirectory files are not returned to "
"the caller.  However, the caller must still check that returned files are "
"directories.  (The purpose of this flag is merely to optimize performance "
"when the caller is interested only in directories.)"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:238
msgid ""
"If I<errfunc> is not NULL, it will be called in case of an error with the "
"arguments I<epath>, a pointer to the path which failed, and I<eerrno>, the "
"value of I<errno> as returned from one of the calls to B<opendir>(3), "
"B<readdir>(3), or B<stat>(2).  If I<errfunc> returns nonzero, or if "
"B<GLOB_ERR> is set, B<glob>()  will terminate after the call to I<errfunc>."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:245
msgid ""
"Upon successful return, I<pglob-E<gt>gl_pathc> contains the number of "
"matched pathnames and I<pglob-E<gt>gl_pathv> contains a pointer to the list "
"of pointers to matched pathnames.  The list of pointers is terminated by a "
"NULL pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:254
msgid ""
"It is possible to call B<glob>()  several times.  In that case, the "
"B<GLOB_APPEND> flag has to be set in I<flags> on the second and later "
"invocations."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:262
msgid ""
"As a GNU extension, I<pglob-E<gt>gl_flags> is set to the flags specified, "
"B<or>ed with B<GLOB_MAGCHAR> if any metacharacters were found."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:267
msgid ""
"On successful completion, B<glob>()  returns zero.  Other possible returns "
"are:"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:267
#, no-wrap
msgid "B<GLOB_NOSPACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:270
msgid "for running out of memory,"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:270
#, no-wrap
msgid "B<GLOB_ABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:273
msgid "for a read error, and"
msgstr ""

#. type: TP
#: build/C/man3/glob.3:273
#, no-wrap
msgid "B<GLOB_NOMATCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:276
msgid "for no found matches."
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:278
msgid "POSIX.2, POSIX.1-2001."
msgstr ""

#. type: SH
#: build/C/man3/glob.3:278 build/C/man7/glob.7:142 build/C/man3/re_comp.3:75
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:289
msgid ""
"The structure elements I<gl_pathc> and I<gl_offs> are declared as I<size_t> "
"in glibc 2.1, as they should be according to POSIX.2, but are declared as "
"I<int> in libc4, libc5 and glibc 2.0."
msgstr ""

#. type: SH
#: build/C/man3/glob.3:289 build/C/man7/regex.7:259
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:298
msgid ""
"The B<glob>()  function may fail due to failure of underlying function "
"calls, such as B<malloc>(3)  or B<opendir>(3).  These will store their error "
"code in I<errno>."
msgstr ""

#. type: SH
#: build/C/man3/glob.3:298 build/C/man3/wordexp.3:189
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:300
msgid "One example of use is the following code, which simulates typing"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:303
msgid "ls -l *.c ../*.c"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:306
msgid "in the shell:"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:310
#, no-wrap
msgid "glob_t globbuf;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:317
#, no-wrap
msgid ""
"globbuf.gl_offs = 2;\n"
"glob(\"*.c\", GLOB_DOOFFS, NULL, &globbuf);\n"
"glob(\"../*.c\", GLOB_DOOFFS | GLOB_APPEND, NULL, &globbuf);\n"
"globbuf.gl_pathv[0] = \"ls\";\n"
"globbuf.gl_pathv[1] = \"-l\";\n"
"execvp(\"ls\", &globbuf.gl_pathv[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/glob.3:330
msgid ""
"B<ls>(1), B<sh>(1), B<stat>(2), B<exec>(3), B<fnmatch>(3), B<malloc>(3), "
"B<opendir>(3), B<readdir>(3), B<wordexp>(3), B<glob>(7)"
msgstr ""

#. type: TH
#: build/C/man7/glob.7:26
#, no-wrap
msgid "2012-07-28"
msgstr ""

#. type: TH
#: build/C/man7/glob.7:26
#, no-wrap
msgid "Linux"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:29
msgid "glob - globbing pathnames"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:34
msgid ""
"Long ago, in UNIX V6, there was a program I</etc/glob> that would expand "
"wildcard patterns.  Soon afterward this became a shell built-in."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:38
msgid ""
"These days there is also a library routine B<glob>(3)  that will perform "
"this function for a user program."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:40
msgid "The rules are as follows (POSIX.2, 3.13)."
msgstr ""

#. type: SS
#: build/C/man7/glob.7:40
#, no-wrap
msgid "Wildcard matching"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:47
msgid ""
"A string is a wildcard pattern if it contains one of the characters "
"\\(aq?\\(aq, \\(aq*\\(aq or \\(aq[\\(aq.  Globbing is the operation that "
"expands a wildcard pattern into the list of pathnames matching the pattern.  "
"Matching is defined by:"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:49
msgid "A \\(aq?\\(aq (not between brackets) matches any single character."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:52
msgid ""
"A \\(aq*\\(aq (not between brackets) matches any string, including the empty "
"string."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:54
msgid "B<Character classes>"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:63
msgid ""
"An expression \"I<[...]>\" where the first character after the leading "
"\\(aq[\\(aq is not an \\(aq!\\(aq matches a single character, namely any of "
"the characters enclosed by the brackets.  The string enclosed by the "
"brackets cannot be empty; therefore \\(aq]\\(aq can be allowed between the "
"brackets, provided that it is the first character.  (Thus, \"I<[][!]>\" "
"matches the three characters \\(aq[\\(aq, \\(aq]\\(aq and \\(aq!\\(aq.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:65
msgid "B<Ranges>"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:76
msgid ""
"There is one special convention: two characters separated by \\(aq-\\(aq "
"denote a range.  (Thus, \"I<[A-Fa-f0-9]>\" is equivalent to "
"\"I<[ABCDEFabcdef0123456789]>\".)  One may include \\(aq-\\(aq in its "
"literal meaning by making it the first or last character between the "
"brackets.  (Thus, \"I<[]-]>\" matches just the two characters \\(aq]\\(aq "
"and \\(aq-\\(aq, and \"I<[--0]>\" matches the three characters \\(aq-\\(aq, "
"\\(aq.\\(aq, \\(aq0\\(aq, since \\(aq/\\(aq cannot be matched.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:78
msgid "B<Complementation>"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:84
msgid ""
"An expression \"I<[!...]>\" matches a single character, namely any character "
"that is not matched by the expression obtained by removing the first "
"\\(aq!\\(aq from it.  (Thus, \"I<[!]a-]>\" matches any single character "
"except \\(aq]\\(aq, \\(aqa\\(aq and \\(aq-\\(aq.)"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:91
msgid ""
"One can remove the special meaning of \\(aq?\\(aq, \\(aq*\\(aq and "
"\\(aq[\\(aq by preceding them by a backslash, or, in case this is part of a "
"shell command line, enclosing them in quotes.  Between brackets these "
"characters stand for themselves.  Thus, \"I<[[?*\\e]>\" matches the four "
"characters \\(aq[\\(aq, \\(aq?\\(aq, \\(aq*\\(aq and \\(aq\\e\\(aq."
msgstr ""

#. type: SS
#: build/C/man7/glob.7:91
#, no-wrap
msgid "Pathnames"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:98
msgid ""
"Globbing is applied on each of the components of a pathname separately.  A "
"\\(aq/\\(aq in a pathname cannot be matched by a \\(aq?\\(aq or \\(aq*\\(aq "
"wildcard, or by a range like \"I<[.-0]>\".  A range cannot contain an "
"explicit \\(aq/\\(aq character; this would lead to a syntax error."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:103
msgid ""
"If a filename starts with a \\(aq.\\(aq, this character must be matched "
"explicitly.  (Thus, I<rm\\ *> will not remove .profile, and I<tar\\ c\\ *> "
"will not archive all your files; I<tar\\ c\\ .> is better.)"
msgstr ""

#. type: SS
#: build/C/man7/glob.7:103
#, no-wrap
msgid "Empty lists"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:109
msgid ""
"The nice and simple rule given above: \"expand a wildcard pattern into the "
"list of matching pathnames\" was the original UNIX definition.  It allowed "
"one to have patterns that expand into an empty list, as in"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:112
#, no-wrap
msgid "    xv -wait 0 *.gif *.jpg\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:122
msgid ""
"where perhaps no *.gif files are present (and this is not an error).  "
"However, POSIX requires that a wildcard pattern is left unchanged when it is "
"syntactically incorrect, or the list of matching pathnames is empty.  With "
"I<bash> one can force the classical behavior using this command:"
msgstr ""

#.  In Bash v1, by setting allow_null_glob_expansion=true
#. type: Plain text
#: build/C/man7/glob.7:125
#, no-wrap
msgid "    shopt -s nullglob\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:128
msgid "(Similar problems occur elsewhere.  E.g., where old scripts have"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:131
#, no-wrap
msgid "    rm \\`find . -name \"*~\"\\`\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:134
msgid "new scripts require"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:137
#, no-wrap
msgid "    rm -f nosuchfile \\`find . -name \"*~\"\\`\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:142
msgid "to avoid error messages from I<rm> called with an empty argument list.)"
msgstr ""

#. type: SS
#: build/C/man7/glob.7:143
#, no-wrap
msgid "Regular expressions"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:150
msgid ""
"Note that wildcard patterns are not regular expressions, although they are a "
"bit similar.  First of all, they match filenames, rather than text, and "
"secondly, the conventions are not the same: for example, in a regular "
"expression \\(aq*\\(aq means zero or more copies of the preceding thing."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:154
msgid ""
"Now that regular expressions have bracket expressions where the negation is "
"indicated by a \\(aq^\\(aq, POSIX has declared the effect of a wildcard "
"pattern \"I<[^...]>\" to be undefined."
msgstr ""

#. type: SS
#: build/C/man7/glob.7:154
#, no-wrap
msgid "Character classes and internationalization"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:172
msgid ""
"Of course ranges were originally meant to be ASCII ranges, so that \"I<[\\ "
"-%]>\" stands for \"I<[\\ !\"#$%]>\" and \"I<[a-z]>\" stands for \"any "
"lowercase letter\".  Some UNIX implementations generalized this so that a "
"range X-Y stands for the set of characters with code between the codes for X "
"and for Y.  However, this requires the user to know the character coding in "
"use on the local system, and moreover, is not convenient if the collating "
"sequence for the local alphabet differs from the ordering of the character "
"codes.  Therefore, POSIX extended the bracket notation greatly, both for "
"wildcard patterns and for regular expressions.  In the above we saw three "
"types of items that can occur in a bracket expression: namely (i) the "
"negation, (ii) explicit single characters, and (iii) ranges.  POSIX "
"specifies ranges in an internationally more useful way and adds three more "
"types:"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:178
msgid ""
"(iii) Ranges X-Y comprise all characters that fall between X and Y "
"(inclusive) in the current collating sequence as defined by the "
"B<LC_COLLATE> category in the current locale."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:180
msgid "(iv) Named character classes, like"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:185
#, no-wrap
msgid ""
"[:alnum:]  [:alpha:]  [:blank:]  [:cntrl:]\n"
"[:digit:]  [:graph:]  [:lower:]  [:print:]\n"
"[:punct:]  [:space:]  [:upper:]  [:xdigit:]\n"
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:194
msgid ""
"so that one can say \"I<[[:lower:]]>\" instead of \"I<[a-z]>\", and have "
"things work in Denmark, too, where there are three letters past \\(aqz\\(aq "
"in the alphabet.  These character classes are defined by the B<LC_CTYPE> "
"category in the current locale."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:200
msgid ""
"(v) Collating symbols, like \"I<[.ch.]>\" or \"I<[.a-acute.]>\", where the "
"string between \"I<[.>\" and \"I<.]>\" is a collating element defined for "
"the current locale.  Note that this may be a multicharacter element."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:208
msgid ""
"(vi) Equivalence class expressions, like \"I<[=a=]>\", where the string "
"between \"I<[=>\" and \"I<=]>\" is any collating element from its "
"equivalence class, as defined for the current locale.  For example, "
"\"I<[[=a=]]>\" might be equivalent to \"I<[a\\('a\\(`a\\(:a\\(^a]>\", that "
"is, to \"I<[a[.a-acute.][.a-grave.][.a-umlaut.][.a-circumflex.]]>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/glob.7:214
msgid "B<sh>(1), B<fnmatch>(3), B<glob>(3), B<locale>(7), B<regex>(7)"
msgstr ""

#. type: TH
#: build/C/man3/re_comp.3:27
#, no-wrap
msgid "RE_COMP"
msgstr ""

#. type: TH
#: build/C/man3/re_comp.3:27
#, no-wrap
msgid "2013-06-21"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:30
msgid "re_comp, re_exec - BSD regex functions"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:32
msgid "B<#define _REGEX_RE_COMP>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:34
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:36
msgid "B<#include E<lt>regex.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:38
msgid "B<char *re_comp(char *>I<regex>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:40
msgid "B<int re_exec(char *>I<string>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:52
msgid ""
"B<re_comp>()  is used to compile the null-terminated regular expression "
"pointed to by I<regex>.  The compiled pattern occupies a static area, the "
"pattern buffer, which is overwritten by subsequent use of B<re_comp>().  If "
"I<regex> is NULL, no operation is performed and the pattern buffer's "
"contents are not altered."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:58
msgid ""
"B<re_exec>()  is used to assess whether the null-terminated string pointed "
"to by I<string> matches the previously compiled I<regex>."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:63
msgid ""
"B<re_comp>()  returns NULL on successful compilation of I<regex> otherwise "
"it returns a pointer to an appropriate error message."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:66
msgid "B<re_exec>()  returns 1 for a successful match, zero for failure."
msgstr ""

#. type: SH
#: build/C/man3/re_comp.3:66
#, no-wrap
msgid "ATTRIBUTES"
msgstr ""

#. type: SS
#: build/C/man3/re_comp.3:67
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:73
msgid "The B<re_comp>()  and B<re_exec>()  functions are not thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:75
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:79
msgid ""
"These functions are obsolete; the functions documented in B<regcomp>(3)  "
"should be used instead."
msgstr ""

#. type: Plain text
#: build/C/man3/re_comp.3:83
msgid "B<regcomp>(3), B<regex>(7), GNU regex manual"
msgstr ""

#. type: TH
#: build/C/man3/regex.3:30 build/C/man7/regex.7:37
#, no-wrap
msgid "REGEX"
msgstr ""

#. type: TH
#: build/C/man3/regex.3:30
#, no-wrap
msgid "2013-02-11"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:33
msgid "regcomp, regexec, regerror, regfree - POSIX regex functions"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:37
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>regex.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:39
#, no-wrap
msgid ""
"B<int regcomp(regex_t *>I<preg>B<, const char *>I<regex>B<, int "
">I<cflags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:43
#, no-wrap
msgid ""
"B<int regexec(const regex_t *>I<preg>B<, const char *>I<string>B<, size_t "
">I<nmatch>B<,>\n"
"B<            regmatch_t >I<pmatch[]>B<, int >I<eflags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:46
#, no-wrap
msgid ""
"B<size_t regerror(int >I<errcode>B<, const regex_t *>I<preg>B<, char "
"*>I<errbuf>B<,>\n"
"B<                size_t >I<errbuf_size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:48
#, no-wrap
msgid "B<void regfree(regex_t *>I<preg>B<);>\n"
msgstr ""

#. type: SS
#: build/C/man3/regex.3:50
#, no-wrap
msgid "POSIX regex compiling"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:56
msgid ""
"B<regcomp>()  is used to compile a regular expression into a form that is "
"suitable for subsequent B<regexec>()  searches."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:65
msgid ""
"B<regcomp>()  is supplied with I<preg>, a pointer to a pattern buffer "
"storage area; I<regex>, a pointer to the null-terminated string and "
"I<cflags>, flags used to determine the type of compilation."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:72
msgid ""
"All regular expression searching must be done via a compiled pattern buffer, "
"thus B<regexec>()  must always be supplied with the address of a "
"B<regcomp>()  initialized pattern buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:77
msgid "I<cflags> may be the bitwise-B<or> of one or more of the following:"
msgstr ""

#. type: TP
#: build/C/man3/regex.3:77
#, no-wrap
msgid "B<REG_EXTENDED>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:86
msgid ""
"Use B<POSIX> Extended Regular Expression syntax when interpreting I<regex>.  "
"If not set, B<POSIX> Basic Regular Expression syntax is used."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:86
#, no-wrap
msgid "B<REG_ICASE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:92
msgid ""
"Do not differentiate case.  Subsequent B<regexec>()  searches using this "
"pattern buffer will be case insensitive."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:92
#, no-wrap
msgid "B<REG_NOSUB>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:102
msgid ""
"Do not report position of matches.  The I<nmatch> and I<pmatch> arguments to "
"B<regexec>()  are ignored if the pattern buffer supplied was compiled with "
"this flag set."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:102
#, no-wrap
msgid "B<REG_NEWLINE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:105
msgid "Match-any-character operators don't match a newline."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:109
msgid ""
"A nonmatching list (B<[^...]>)  not containing a newline does not match a "
"newline."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:119
msgid ""
"Match-beginning-of-line operator (B<^>)  matches the empty string "
"immediately after a newline, regardless of whether I<eflags>, the execution "
"flags of B<regexec>(), contains B<REG_NOTBOL>."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:127
msgid ""
"Match-end-of-line operator (B<$>)  matches the empty string immediately "
"before a newline, regardless of whether I<eflags> contains B<REG_NOTEOL>."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:127
#, no-wrap
msgid "POSIX regex matching"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:144
msgid ""
"B<regexec>()  is used to match a null-terminated string against the "
"precompiled pattern buffer, I<preg>.  I<nmatch> and I<pmatch> are used to "
"provide information regarding the location of any matches.  I<eflags> may be "
"the bitwise-B<or> of one or both of B<REG_NOTBOL> and B<REG_NOTEOL> which "
"cause changes in matching behavior described below."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:144
#, no-wrap
msgid "B<REG_NOTBOL>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:154
msgid ""
"The match-beginning-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)  This flag may be used when different "
"portions of a string are passed to B<regexec>()  and the beginning of the "
"string should not be interpreted as the beginning of the line."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:154
#, no-wrap
msgid "B<REG_NOTEOL>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:160
msgid ""
"The match-end-of-line operator always fails to match (but see the "
"compilation flag B<REG_NEWLINE> above)"
msgstr ""

#. type: SS
#: build/C/man3/regex.3:160
#, no-wrap
msgid "Byte offsets"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:185
msgid ""
"Unless B<REG_NOSUB> was set for the compilation of the pattern buffer, it is "
"possible to obtain match addressing information.  I<pmatch> must be "
"dimensioned to have at least I<nmatch> elements.  These are filled in by "
"B<regexec>()  with substring match addresses.  The offsets of the "
"subexpression starting at the I<i>th open parenthesis are stored in "
"I<pmatch[i]>.  The entire regular expression's match addresses are stored in "
"I<pmatch[0]>.  (Note that to return the offsets of I<N> subexpression "
"matches, I<nmatch> must be at least I<N+1>.)  Any unused structure elements "
"will contain the value -1."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:192
msgid ""
"The I<regmatch_t> structure which is the type of I<pmatch> is defined in "
"I<E<lt>regex.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:199
#, no-wrap
msgid ""
"typedef struct {\n"
"    regoff_t rm_so;\n"
"    regoff_t rm_eo;\n"
"} regmatch_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:210
msgid ""
"Each I<rm_so> element that is not -1 indicates the start offset of the next "
"largest substring match within the string.  The relative I<rm_eo> element "
"indicates the end offset of the match, which is the offset of the first "
"character after the matching text."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:210
#, no-wrap
msgid "POSIX error reporting"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:217
msgid ""
"B<regerror>()  is used to turn the error codes that can be returned by both "
"B<regcomp>()  and B<regexec>()  into error message strings."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:239
msgid ""
"B<regerror>()  is passed the error code, I<errcode>, the pattern buffer, "
"I<preg>, a pointer to a character string buffer, I<errbuf>, and the size of "
"the string buffer, I<errbuf_size>.  It returns the size of the I<errbuf> "
"required to contain the null-terminated error message string.  If both "
"I<errbuf> and I<errbuf_size> are nonzero, I<errbuf> is filled in with the "
"first I<errbuf_size - 1> characters of the error message and a terminating "
"null byte (\\(aq\\e0\\(aq)."
msgstr ""

#. type: SS
#: build/C/man3/regex.3:239
#, no-wrap
msgid "POSIX pattern buffer freeing"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:247
msgid ""
"Supplying B<regfree>()  with a precompiled pattern buffer, I<preg> will free "
"the memory allocated to the pattern buffer by the compiling process, "
"B<regcomp>()."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:250
msgid ""
"B<regcomp>()  returns zero for a successful compilation or an error code for "
"failure."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:255
msgid ""
"B<regexec>()  returns zero for a successful match or B<REG_NOMATCH> for "
"failure."
msgstr ""

#. type: SH
#: build/C/man3/regex.3:255
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:258
msgid "The following errors can be returned by B<regcomp>():"
msgstr ""

#. type: TP
#: build/C/man3/regex.3:258
#, no-wrap
msgid "B<REG_BADBR>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:261
msgid "Invalid use of back reference operator."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:261
#, no-wrap
msgid "B<REG_BADPAT>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:264
msgid "Invalid use of pattern operators such as group or list."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:264
#, no-wrap
msgid "B<REG_BADRPT>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:268
msgid ""
"Invalid use of repetition operators such as using \\(aq*\\(aq as the first "
"character."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:268
#, no-wrap
msgid "B<REG_EBRACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:271
msgid "Un-matched brace interval operators."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:271
#, no-wrap
msgid "B<REG_EBRACK>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:274
msgid "Un-matched bracket list operators."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:274
#, no-wrap
msgid "B<REG_ECOLLATE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:277
msgid "Invalid collating element."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:277
#, no-wrap
msgid "B<REG_ECTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:280
msgid "Unknown character class name."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:280
#, no-wrap
msgid "B<REG_EEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:284
msgid "Nonspecific error.  This is not defined by POSIX.2."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:284
#, no-wrap
msgid "B<REG_EESCAPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:287
msgid "Trailing backslash."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:287
#, no-wrap
msgid "B<REG_EPAREN>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:290
msgid "Un-matched parenthesis group operators."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:290
#, no-wrap
msgid "B<REG_ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:294
msgid ""
"Invalid use of the range operator, e.g., the ending point of the range "
"occurs prior to the starting point."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:294
#, no-wrap
msgid "B<REG_ESIZE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:298
msgid ""
"Compiled regular expression requires a pattern buffer larger than 64Kb.  "
"This is not defined by POSIX.2."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:298
#, no-wrap
msgid "B<REG_ESPACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:301
msgid "The regex routines ran out of memory."
msgstr ""

#. type: TP
#: build/C/man3/regex.3:301
#, no-wrap
msgid "B<REG_ESUBREG>"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:304
msgid "Invalid back reference to a subexpression."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:306 build/C/man3/wordexp.3:189
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:309
msgid "B<grep>(1), B<regex>(7)"
msgstr ""

#. type: Plain text
#: build/C/man3/regex.3:312
msgid "The glibc manual section, I<Regular Expression Matching>"
msgstr ""

#. type: TH
#: build/C/man7/regex.7:37
#, no-wrap
msgid "2009-01-12"
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:40
msgid "regex - POSIX.2 regular expressions"
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:54
msgid ""
"Regular expressions (\"RE\"s), as defined in POSIX.2, come in two forms: "
"modern REs (roughly those of I<egrep>; POSIX.2 calls these \"extended\" REs)  "
"and obsolete REs (roughly those of B<ed>(1); POSIX.2 \"basic\" REs).  "
"Obsolete REs mostly exist for backward compatibility in some old programs; "
"they will be discussed at the end.  POSIX.2 leaves some aspects of RE syntax "
"and semantics open; \"\\*(dg\" marks decisions on these aspects that may not "
"be fully portable to other POSIX.2 implementations."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:58
msgid ""
"A (modern) RE is one\\*(dg or more nonempty\\*(dg I<branches>, separated by "
"\\(aq|\\(aq.  It matches anything that matches one of the branches."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:61
msgid ""
"A branch is one\\*(dg or more I<pieces>, concatenated.  It matches a match "
"for the first, followed by a match for the second, etc."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:70
msgid ""
"A piece is an I<atom> possibly followed by a single\\*(dg \\(aq*\\(aq, "
"\\(aq+\\(aq, \\(aq?\\(aq, or I<bound>.  An atom followed by \\(aq*\\(aq "
"matches a sequence of 0 or more matches of the atom.  An atom followed by "
"\\(aq+\\(aq matches a sequence of 1 or more matches of the atom.  An atom "
"followed by \\(aq?\\(aq matches a sequence of 0 or 1 matches of the atom."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:88
msgid ""
"A I<bound> is \\(aq{\\(aq followed by an unsigned decimal integer, possibly "
"followed by \\(aq,\\(aq possibly followed by another unsigned decimal "
"integer, always followed by \\(aq}\\(aq.  The integers must lie between 0 "
"and B<RE_DUP_MAX> (255\\*(dg) inclusive, and if there are two of them, the "
"first may not exceed the second.  An atom followed by a bound containing one "
"integer I<i> and no comma matches a sequence of exactly I<i> matches of the "
"atom.  An atom followed by a bound containing one integer I<i> and a comma "
"matches a sequence of I<i> or more matches of the atom.  An atom followed by "
"a bound containing two integers I<i> and I<j> matches a sequence of I<i> "
"through I<j> (inclusive) matches of the atom."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:105
msgid ""
"An atom is a regular expression enclosed in \"I<()>\" (matching a match for "
"the regular expression), an empty set of \"I<()>\" (matching the null "
"string)\\*(dg, a I<bracket expression> (see below), \\(aq.\\(aq (matching "
"any single character), \\(aq^\\(aq (matching the null string at the "
"beginning of a line), \\(aq$\\(aq (matching the null string at the end of a "
"line), a \\(aq\\e\\(aq followed by one of the characters "
"\"I<^.[$()|*+?{\\e>\" (matching that character taken as an ordinary "
"character), a \\(aq\\e\\(aq followed by any other character\\*(dg (matching "
"that character taken as an ordinary character, as if the \\(aq\\e\\(aq had "
"not been present\\*(dg), or a single character with no other significance "
"(matching that character).  A \\(aq{\\(aq followed by a character other than "
"a digit is an ordinary character, not the beginning of a bound\\*(dg.  It is "
"illegal to end an RE with \\(aq\\e\\(aq."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:119
msgid ""
"A I<bracket expression> is a list of characters enclosed in \"I<[]>\".  It "
"normally matches any single character from the list (but see below).  If the "
"list begins with \\(aq^\\(aq, it matches any single character (but see "
"below) I<not> from the rest of the list.  If two characters in the list are "
"separated by \\(aq-\\(aq, this is shorthand for the full I<range> of "
"characters between those two (inclusive) in the collating sequence, for "
"example, \"I<[0-9]>\" in ASCII matches any decimal digit.  It is "
"illegal\\*(dg for two ranges to share an endpoint, for example, "
"\"I<a-c-e>\".  Ranges are very collating-sequence-dependent, and portable "
"programs should avoid relying on them."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:130
msgid ""
"To include a literal \\(aq]\\(aq in the list, make it the first character "
"(following a possible \\(aq^\\(aq).  To include a literal \\(aq-\\(aq, make "
"it the first or last character, or the second endpoint of a range.  To use a "
"literal \\(aq-\\(aq as the first endpoint of a range, enclose it in "
"\"I<[.>\" and \"I<.]>\" to make it a collating element (see below).  With "
"the exception of these and some combinations using \\(aq[\\(aq (see next "
"paragraphs), all other special characters, including \\(aq\\e\\(aq, lose "
"their special significance within a bracket expression."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:142
msgid ""
"Within a bracket expression, a collating element (a character, a "
"multicharacter sequence that collates as if it were a single character, or a "
"collating-sequence name for either)  enclosed in \"I<[.>\" and \"I<.]>\" "
"stands for the sequence of characters of that collating element.  The "
"sequence is a single element of the bracket expression's list.  A bracket "
"expression containing a multicharacter collating element can thus match more "
"than one character, for example, if the collating sequence includes a \"ch\" "
"collating element, then the RE \"I<[[.ch.]]*c>\" matches the first five "
"characters of \"chchcc\"."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:154
msgid ""
"Within a bracket expression, a collating element enclosed in \"I<[=>\" and "
"\"I<=]>\" is an equivalence class, standing for the sequences of characters "
"of all collating elements equivalent to that one, including itself.  (If "
"there are no other equivalent collating elements, the treatment is as if the "
"enclosing delimiters were \"I<[.>\" and \"I<.]>\".)  For example, if o and "
"\\o'o^' are the members of an equivalence class, then \"I<[[=o=]]>\", "
"\"I<[[=\\o'o^'=]]>\", and \"I<[o\\o'o^']>\" are all synonymous.  An "
"equivalence class may not\\*(dg be an endpoint of a range."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:160
msgid ""
"Within a bracket expression, the name of a I<character class> enclosed in "
"\"I<[:>\" and \"I<:]>\" stands for the list of all characters belonging to "
"that class.  Standard character class names are:"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:164
#, no-wrap
msgid "alnum\tdigit\tpunct\n"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:165
#, no-wrap
msgid "alpha\tgraph\tspace\n"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:166
#, no-wrap
msgid "blank\tlower\tupper\n"
msgstr ""

#. type: tbl table
#: build/C/man7/regex.7:167
#, no-wrap
msgid "cntrl\tprint\txdigit\n"
msgstr ""

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  There are two special cases\*(dg of bracket expressions:
#.  the bracket expressions "\fI[[:<:]]\fP" and "\fI[[:>:]]\fP" match
#.  the null string at the beginning and end of a word respectively.
#.  A word is defined as a sequence of
#.  word characters
#.  which is neither preceded nor followed by
#.  word characters.
#.  A word character is an
#.  .I alnum
#.  character (as defined by
#.  .BR wctype (3))
#.  or an underscore.
#.  This is an extension,
#.  compatible with but not specified by POSIX.2,
#.  and should be used with
#.  caution in software intended to be portable to other systems.
#. type: Plain text
#: build/C/man7/regex.7:194
msgid ""
"These stand for the character classes defined in B<wctype>(3).  A locale may "
"provide others.  A character class may not be used as an endpoint of a "
"range."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:206
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string.  If the RE "
"could match more than one substring starting at that point, it matches the "
"longest.  Subexpressions also match the longest possible substrings, subject "
"to the constraint that the whole match be as long as possible, with "
"subexpressions starting earlier in the RE taking priority over ones starting "
"later.  Note that higher-level subexpressions thus take priority over their "
"lower-level component subexpressions."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:218
msgid ""
"Match lengths are measured in characters, not collating elements.  A null "
"string is considered longer than no match at all.  For example, \"I<bb*>\" "
"matches the three middle characters of \"abbbc\", "
"\"I<(wee|week)(knights|nights)>\" matches all ten characters of "
"\"weeknights\", when \"I<(.*).*>\" is matched against \"abc\" the "
"parenthesized subexpression matches all three characters, and when "
"\"I<(a*)*>\" is matched against \"bc\" both the whole RE and the "
"parenthesized subexpression match the null string."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:229
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet.  When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, for example, \\(aqx\\(aq becomes \"I<[xX]>\".  When "
"it appears inside a bracket expression, all case counterparts of it are "
"added to the bracket expression, so that, for example, \"I<[x]>\" becomes "
"\"I<[xX]>\" and \"I<[^x]>\" becomes \"I<[^xX]>\"."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:235
msgid ""
"No particular limit is imposed on the length of REs\\*(dg.  Programs "
"intended to be portable should not employ REs longer than 256 bytes, as an "
"implementation can refuse to accept such REs and remain POSIX-compliant."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:251
msgid ""
"Obsolete (\"basic\") regular expressions differ in several respects.  "
"\\(aq|\\(aq, \\(aq+\\(aq, and \\(aq?\\(aq are ordinary characters and there "
"is no equivalent for their functionality.  The delimiters for bounds are "
"\"I<\\e{>\" and \"I<\\e}>\", with \\(aq{\\(aq and \\(aq}\\(aq by themselves "
"ordinary characters.  The parentheses for nested subexpressions are "
"\"I<\\e(>\" and \"I<\\e)>\", with \\(aq(\\(aq and \\(aq)\\(aq by themselves "
"ordinary characters.  \\(aq^\\(aq is an ordinary character except at the "
"beginning of the RE or\\*(dg the beginning of a parenthesized subexpression, "
"\\(aq$\\(aq is an ordinary character except at the end of the RE or\\*(dg "
"the end of a parenthesized subexpression, and \\(aq*\\(aq is an ordinary "
"character if it appears at the beginning of the RE or the beginning of a "
"parenthesized subexpression (after a possible leading \\(aq^\\(aq)."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:259
msgid ""
"Finally, there is one new type of atom, a I<back reference>: \\(aq\\e\\(aq "
"followed by a nonzero decimal digit I<d> matches the same sequence of "
"characters matched by the I<d>th parenthesized subexpression (numbering "
"subexpressions by the positions of their opening parentheses, left to "
"right), so that, for example, \"I<\\e([bc]\\e)\\e1>\" matches \"bb\" or "
"\"cc\" but not \"bc\"."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:261
msgid "Having two kinds of REs is a botch."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:267
msgid ""
"The current POSIX.2 spec says that \\(aq)\\(aq is an ordinary character in "
"the absence of an unmatched \\(aq(\\(aq; this was an unintentional result of "
"a wording error, and change is likely.  Avoid relying on it."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:274
msgid ""
"Back references are a dreadful botch, posing major problems for efficient "
"implementations.  They are also somewhat vaguely defined (does "
"\"I<a\\e(\\e(b\\e)*\\e2\\e)*d>\" match \"abbbd\"?).  Avoid using them."
msgstr ""

#.  As per http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=295666
#.  The following does not seem to apply in the glibc implementation
#.  .PP
#.  The syntax for word boundaries is incredibly ugly.
#. type: Plain text
#: build/C/man7/regex.7:282
msgid ""
"POSIX.2's specification of case-independent matching is vague.  The \"one "
"case implies all cases\" definition given above is current consensus among "
"implementors as to the right interpretation."
msgstr ""

#. type: SH
#: build/C/man7/regex.7:282
#, no-wrap
msgid "AUTHOR"
msgstr ""

#.  Sigh... The page license means we must have the author's name
#.  in the formatted output.
#. type: Plain text
#: build/C/man7/regex.7:286
msgid "This page was taken from Henry Spencer's regex package."
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:289
msgid "B<grep>(1), B<regex>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/regex.7:291
msgid "POSIX.2, section 2.8 (Regular Expression Notation)."
msgstr ""

#. type: TH
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "WORDEXP"
msgstr ""

#. type: TH
#: build/C/man3/wordexp.3:24
#, no-wrap
msgid "2008-07-14"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:27
msgid "wordexp, wordfree - perform word expansion like a posix-shell"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:29
msgid "B<#include E<lt>wordexp.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:31
msgid "B<int wordexp(const char *>I<s>B<, wordexp_t *>I<p>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:33
msgid "B<void wordfree(wordexp_t *>I<p>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:37
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:42
msgid "B<wordexp>(), B<wordfree>(): _XOPEN_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:76
msgid ""
"The function B<wordexp>()  performs a shell-like expansion of the string "
"I<s> and returns the result in the structure pointed to by I<p>.  The data "
"type I<wordexp_t> is a structure that at least has the fields I<we_wordc>, "
"I<we_wordv>, and I<we_offs>.  The field I<we_wordc> is a I<size_t> that "
"gives the number of words in the expansion of I<s>.  The field I<we_wordv> "
"is a I<char\\ **> that points to the array of words found.  The field "
"I<we_offs> of type I<size_t> is sometimes (depending on I<flags>, see below) "
"used to indicate the number of initial elements in the I<we_wordv> array "
"that should be filled with NULLs."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:84
msgid ""
"The function B<wordfree>()  frees the allocated memory again.  More "
"precisely, it does not free its argument, but it frees the array I<we_wordv> "
"and the strings that points to."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:84
#, no-wrap
msgid "The string argument"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:94
msgid ""
"Since the expansion is the same as the expansion by the shell (see B<sh>(1))  "
"of the parameters to a command, the string I<s> must not contain characters "
"that would be illegal in shell command parameters.  In particular, there "
"must not be any unescaped newline or |, &, ;, E<lt>, E<gt>, (, ), {, } "
"characters outside a command substitution or parameter substitution context."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:100
msgid ""
"If the argument I<s> contains a word that starts with an unquoted comment "
"character #, then it is unspecified whether that word and all following "
"words are ignored, or the # is treated as a non-comment character."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:100
#, no-wrap
msgid "The expansion"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:107
msgid ""
"The expansion done consists of the following stages: tilde expansion "
"(replacing ~user by user's home directory), variable substitution (replacing "
"$FOO by the value of the environment variable FOO), command substitution "
"(replacing $(command) or \\`command\\` by the output of command), arithmetic "
"expansion, field splitting, wildcard expansion, quote removal."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:110
msgid ""
"The result of expansion of special parameters ($@, $*, $#, $?, $-, $$, $!, "
"$0) is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:113
msgid ""
"Field splitting is done using the environment variable $IFS.  If it is not "
"set, the field separators are space, tab and newline."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:113
#, no-wrap
msgid "The output array"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:117
msgid "The array I<we_wordv> contains the words found, followed by a NULL."
msgstr ""

#. type: SS
#: build/C/man3/wordexp.3:117
#, no-wrap
msgid "The flags argument"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:121
msgid "The I<flag> argument is a bitwise inclusive OR of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:121
#, no-wrap
msgid "B<WRDE_APPEND>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:124
msgid "Append the words found to the array resulting from a previous call."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:124
#, no-wrap
msgid "B<WRDE_DOOFFS>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:132
msgid ""
"Insert I<we_offs> initial NULLs in the array I<we_wordv>.  (These are not "
"counted in the returned I<we_wordc>.)"
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:132
#, no-wrap
msgid "B<WRDE_NOCMD>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:135
msgid "Don't do command substitution."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:135
#, no-wrap
msgid "B<WRDE_REUSE>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:145
msgid ""
"The argument I<p> resulted from a previous call to B<wordexp>(), and "
"B<wordfree>()  was not called.  Reuse the allocated storage."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:145
#, no-wrap
msgid "B<WRDE_SHOWERR>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:154
msgid ""
"Normally during command substitution I<stderr> is redirected to "
"I</dev/null>.  This flag specifies that I<stderr> is not to be redirected."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:154
#, no-wrap
msgid "B<WRDE_UNDEF>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:157
msgid "Consider it an error if an undefined shell variable is expanded."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:161
msgid ""
"In case of success 0 is returned.  In case of error one of the following "
"five values is returned."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:161
#, no-wrap
msgid "B<WRDE_BADCHAR>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:164
msgid "Illegal occurrence of newline or one of |, &, ;, E<lt>, E<gt>, (, ), {, }."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:164
#, no-wrap
msgid "B<WRDE_BADVAL>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:170
msgid ""
"An undefined shell variable was referenced, and the B<WRDE_UNDEF> flag told "
"us to consider this an error."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:170
#, no-wrap
msgid "B<WRDE_CMDSUB>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:175
msgid ""
"Command substitution occurred, and the B<WRDE_NOCMD> flag told us to "
"consider this an error."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:175
#, no-wrap
msgid "B<WRDE_NOSPACE>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:178
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/wordexp.3:178
#, no-wrap
msgid "B<WRDE_SYNTAX>"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:182
msgid "Shell syntax error, such as unbalanced parentheses or unmatched quotes."
msgstr ""

#. type: SH
#: build/C/man3/wordexp.3:182
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:187
msgid "B<wordexp>()  and B<wordfree>()  are provided in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:192
msgid ""
"The output of the following example program is approximately that of \"ls "
"[a-c]*.c\"."
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:197
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>wordexp.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:204
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    wordexp_t p;\n"
"    char **w;\n"
"    int i;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:212
#, no-wrap
msgid ""
"    wordexp(\"[a-c]*.c\", &p, 0);\n"
"    w = p.we_wordv;\n"
"    for (i = 0; i E<lt> p.we_wordc; i++)\n"
"        printf(\"%s\\en\", w[i]);\n"
"    wordfree(&p);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/wordexp.3:216
msgid "B<fnmatch>(3), B<glob>(3)"
msgstr ""

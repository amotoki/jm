# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-03-22 01:05+0900\n"
"PO-Revision-Date: 2013-03-11 13:46+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr "ALLOC_HUGEPAGES"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "2007-05-31"
msgstr "2007-05-31"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man2/cacheflush.2:25
#: build/C/man2/fallocate.2:11 build/C/man2/madvise.2:35
#: build/C/man3/mallinfo.3:26 build/C/man3/malloc_stats.3:26
#: build/C/man3/malloc_trim.3:26 build/C/man3/mallopt.3:26
#: build/C/man2/mlock.2:26 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29
#: build/C/man2/mprotect.2:38 build/C/man2/mremap.2:30 build/C/man2/msync.2:25
#: build/C/man2/posix_fadvise.2:28 build/C/man2/readahead.2:28
#: build/C/man2/remap_file_pages.2:28 build/C/man3/shm_open.3:26
#: build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:45
#: build/C/man2/shmget.2:38 build/C/man2/shmop.2:41
#: build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/alloca.3:43
#: build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:11
#: build/C/man2/madvise.2:35 build/C/man3/mallinfo.3:26
#: build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_hook.3:10
#: build/C/man3/malloc_info.3:25 build/C/man3/malloc_stats.3:26
#: build/C/man3/malloc_trim.3:26 build/C/man3/malloc_usable_size.3:25
#: build/C/man3/mallopt.3:26 build/C/man3/mcheck.3:25 build/C/man2/mlock.2:26
#: build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:38
#: build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man3/mtrace.3:25
#: build/C/man2/posix_fadvise.2:28 build/C/man3/posix_fallocate.3:25
#: build/C/man3/posix_memalign.3:29 build/C/man2/readahead.2:28
#: build/C/man2/remap_file_pages.2:28 build/C/man3/shm_open.3:26
#: build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:45
#: build/C/man2/shmget.2:38 build/C/man2/shmop.2:41
#: build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/alloc_hugepages.2:26 build/C/man3/alloca.3:44
#: build/C/man2/cacheflush.2:26 build/C/man2/fallocate.2:12
#: build/C/man2/madvise.2:36 build/C/man3/mallinfo.3:27
#: build/C/man3/malloc_get_state.3:26 build/C/man3/malloc_hook.3:11
#: build/C/man3/malloc_info.3:26 build/C/man3/malloc_stats.3:27
#: build/C/man3/malloc_trim.3:27 build/C/man3/malloc_usable_size.3:26
#: build/C/man3/mallopt.3:27 build/C/man3/mcheck.3:26 build/C/man2/mlock.2:27
#: build/C/man2/mmap.2:41 build/C/man2/mmap2.2:30 build/C/man2/mprotect.2:39
#: build/C/man2/mremap.2:31 build/C/man2/msync.2:26 build/C/man3/mtrace.3:26
#: build/C/man2/posix_fadvise.2:29 build/C/man3/posix_fallocate.3:26
#: build/C/man3/posix_memalign.3:30 build/C/man2/readahead.2:29
#: build/C/man2/remap_file_pages.2:29 build/C/man3/shm_open.3:27
#: build/C/man7/shm_overview.7:28 build/C/man2/shmctl.2:46
#: build/C/man2/shmget.2:39 build/C/man2/shmop.2:42
#: build/C/man2/subpage_prot.2:31 build/C/man2/sync_file_range.2:31
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""
"alloc_hugepages, free_hugepages - 大きなサイズのページの割り当てと解放を行う"

#. type: SH
#: build/C/man2/alloc_hugepages.2:28 build/C/man3/alloca.3:46
#: build/C/man2/cacheflush.2:28 build/C/man2/fallocate.2:14
#: build/C/man2/madvise.2:38 build/C/man3/mallinfo.3:29
#: build/C/man3/malloc_get_state.3:28 build/C/man3/malloc_hook.3:15
#: build/C/man3/malloc_info.3:28 build/C/man3/malloc_stats.3:29
#: build/C/man3/malloc_trim.3:29 build/C/man3/malloc_usable_size.3:28
#: build/C/man3/mallopt.3:29 build/C/man3/mcheck.3:28 build/C/man2/mlock.2:29
#: build/C/man2/mmap.2:43 build/C/man2/mmap2.2:32 build/C/man2/mprotect.2:41
#: build/C/man2/mremap.2:33 build/C/man2/msync.2:28 build/C/man3/mtrace.3:28
#: build/C/man2/posix_fadvise.2:31 build/C/man3/posix_fallocate.3:28
#: build/C/man3/posix_memalign.3:32 build/C/man2/readahead.2:31
#: build/C/man2/remap_file_pages.2:31 build/C/man3/shm_open.3:29
#: build/C/man2/shmctl.2:48 build/C/man2/shmget.2:41 build/C/man2/shmop.2:44
#: build/C/man2/subpage_prot.2:33 build/C/man2/sync_file_range.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t >I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr "B<int free_hugepages(void *>I<addr>B<);>\n"

#. type: SH
#: build/C/man2/alloc_hugepages.2:38 build/C/man3/alloca.3:50
#: build/C/man2/cacheflush.2:34 build/C/man2/fallocate.2:22
#: build/C/man2/madvise.2:50 build/C/man3/mallinfo.3:33
#: build/C/man3/malloc_get_state.3:36 build/C/man3/malloc_hook.3:33
#: build/C/man3/malloc_info.3:34 build/C/man3/malloc_stats.3:33
#: build/C/man3/malloc_trim.3:33 build/C/man3/malloc_usable_size.3:32
#: build/C/man3/mallopt.3:33 build/C/man3/mcheck.3:40 build/C/man2/mlock.2:39
#: build/C/man2/mmap.2:54 build/C/man2/mmap2.2:39 build/C/man2/mprotect.2:47
#: build/C/man2/mremap.2:42 build/C/man2/msync.2:32 build/C/man3/mtrace.3:34
#: build/C/man2/posix_fadvise.2:50 build/C/man3/posix_fallocate.3:46
#: build/C/man3/posix_memalign.3:84 build/C/man2/readahead.2:38
#: build/C/man2/remap_file_pages.2:39 build/C/man3/shm_open.3:41
#: build/C/man7/shm_overview.7:30 build/C/man2/shmctl.2:56
#: build/C/man2/shmget.2:49 build/C/man2/shmop.2:53
#: build/C/man2/subpage_prot.2:41 build/C/man2/sync_file_range.2:41
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20 "
"the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""
"システムコール B<alloc_hugepages>()  と B<free_hugepages>()  は Linux 2.5.36 "
"で導入され、2.5.54 で再び削除された。 これらのシステムコールは i386 と ia64 "
"のみで (かつ B<CONFIG_HUGETLB_PAGE> を指定してビルドされた場合に) 存在する。 "
"Linux 2.4.20 では syscall 番号が存在するが、 呼び出すとエラー B<ENOSYS> で失"
"敗する。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4 KiB)  "
"and huge pages (2 or 4 MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr ""
"i386 では、メモリ管理ハードウェアは通常のページ (4 KiB) と 大きなサイズのペー"
"ジ (以下、ヒュージページ; 2MiB または 4 MiB) を 扱うことができる。 同様に、"
"ia64 もいくつかのサイズのヒュージページを扱うことができる。 これらのシステム"
"コールは、ヒュージページをプロセスのメモリにマップしたり、 再び解放したりす"
"る。 ヒュージページはメモリ内にロックされ、スワップされない。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""
"I<key> 引き数は識別子である。 0 の場合、ページは非公開になり、子プロセスに継"
"承されない。 正の場合、ページは同じ I<key> を使う他のアプリケーションと共有さ"
"れ、子プロセスに継承される。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""
"B<free_hugepages>()  の I<addr> 引き数は、どのページを解放するかを指定する: "
"I<addr> は B<alloc_hugepages>()  の呼び出しの返り値である (全てのユーザがメモ"
"リを解放したときに、 そのメモリは初めて実際に解放される)。 B<alloc_hugepages>"
"()  の I<addr> 引き数はヒントであり、カーネルはそれに従うかもしれないし、 従"
"わないかもしれない。 アドレスは正しく配置されなければならない。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""
"I<len> 引き数は要求されたセグメントの長さである。 これはヒュージページのサイ"
"ズの倍数にしなければならない。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""
"I<prot> 引き数はセグメントのメモリ保護を指定する。 これは B<PROT_READ>, "
"B<PROT_WRITE>, B<PROT_EXEC> のいずれかである。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is "
"returned when no segment with the given key exists."
msgstr ""
"I<key> が正でない限り、 I<flag> 引き数は無視される。 I<key> が正で、かつ "
"I<flag> が B<IPC_CREAT> であり、かつ指定された I<key> で (セグメントが) 何も"
"存在しない場合、 新しいヒュージページセグメントが作成される。 I<flag> が設定"
"されておらず、かつ指定された I<key> のセグメントが存在しない場合、 B<ENOENT> "
"が返される。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:109 build/C/man3/alloca.3:60
#: build/C/man2/cacheflush.2:53 build/C/man2/fallocate.2:112
#: build/C/man2/madvise.2:268 build/C/man3/malloc_get_state.3:61
#: build/C/man3/malloc_info.3:48 build/C/man3/malloc_trim.3:51
#: build/C/man3/malloc_usable_size.3:40 build/C/man3/mallopt.3:379
#: build/C/man3/mcheck.3:129 build/C/man2/mlock.2:116 build/C/man2/mmap.2:375
#: build/C/man2/mmap2.2:54 build/C/man2/mprotect.2:78
#: build/C/man2/mremap.2:127 build/C/man2/msync.2:68
#: build/C/man2/posix_fadvise.2:87 build/C/man3/posix_fallocate.3:66
#: build/C/man3/posix_memalign.3:141 build/C/man2/readahead.2:65
#: build/C/man2/remap_file_pages.2:124 build/C/man3/shm_open.3:169
#: build/C/man2/shmctl.2:274 build/C/man2/shmget.2:180
#: build/C/man2/shmop.2:171 build/C/man2/subpage_prot.2:66
#: build/C/man2/sync_file_range.2:141
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and "
"B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"成功した場合、 B<alloc_hugepages>()  は割り当てられた仮想アドレスを返し、 "
"B<free_hugepages>()  は 0 を返す。 失敗した場合、-1 を返し、 I<errno> が適切"
"に設定される。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:118 build/C/man2/cacheflush.2:59
#: build/C/man2/fallocate.2:115 build/C/man2/madvise.2:275
#: build/C/man3/malloc_info.3:53 build/C/man3/malloc_trim.3:56
#: build/C/man3/mallopt.3:384 build/C/man2/mlock.2:122 build/C/man2/mmap.2:392
#: build/C/man2/mmap2.2:61 build/C/man2/mprotect.2:85
#: build/C/man2/mremap.2:135 build/C/man2/msync.2:73
#: build/C/man2/posix_fadvise.2:90 build/C/man3/posix_fallocate.3:72
#: build/C/man3/posix_memalign.3:155 build/C/man2/readahead.2:71
#: build/C/man2/remap_file_pages.2:131 build/C/man3/shm_open.3:178
#: build/C/man2/shmctl.2:296 build/C/man2/shmget.2:184
#: build/C/man2/shmop.2:185 build/C/man2/subpage_prot.2:71
#: build/C/man2/sync_file_range.2:147
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/alloc_hugepages.2:119 build/C/man2/fallocate.2:154
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr "このシステムコールはカーネルでサポートされていない。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:122
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:126
msgid ""
"I</proc/sys/vm/nr_hugepages> Number of configured hugetlb pages.  This can "
"be read and written."
msgstr ""
"I</proc/sys/vm/nr_hugepages> 設定された hugetlb ページの数。 このファイルは読"
"み書きできる。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:130
msgid ""
"I</proc/meminfo> Gives info on the number of configured hugetlb pages and on "
"their size in the three variables HugePages_Total, HugePages_Free, "
"Hugepagesize."
msgstr ""
"I</proc/meminfo> 設定された hugetlb ページの数と、 3 つの変数 "
"HugePages_Total, HugePages_Free, Hugepagesize の サイズについての情報を提供す"
"る。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:130 build/C/man3/alloca.3:65
#: build/C/man2/cacheflush.2:75 build/C/man2/fallocate.2:195
#: build/C/man2/madvise.2:325 build/C/man3/mallinfo.3:110
#: build/C/man3/malloc_get_state.3:86 build/C/man3/malloc_hook.3:80
#: build/C/man3/malloc_info.3:61 build/C/man3/malloc_stats.3:55
#: build/C/man3/malloc_trim.3:60 build/C/man3/malloc_usable_size.3:48
#: build/C/man3/mallopt.3:392 build/C/man3/mcheck.3:145
#: build/C/man2/mlock.2:186 build/C/man2/mmap.2:497 build/C/man2/mmap2.2:77
#: build/C/man2/mprotect.2:113 build/C/man2/mremap.2:185
#: build/C/man2/msync.2:96 build/C/man3/mtrace.3:78
#: build/C/man2/posix_fadvise.2:112 build/C/man3/posix_fallocate.3:103
#: build/C/man3/posix_memalign.3:180 build/C/man2/readahead.2:87
#: build/C/man2/remap_file_pages.2:153 build/C/man3/shm_open.3:249
#: build/C/man7/shm_overview.7:101 build/C/man2/shmctl.2:368
#: build/C/man2/shmget.2:231 build/C/man2/shmop.2:231
#: build/C/man2/subpage_prot.2:96 build/C/man2/sync_file_range.2:180
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:133
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""
"このシステムコールは Intel プロセッサ上の Linux に固有のものであり、 移植性が"
"必要なプログラムで使うべきでない。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:133 build/C/man3/alloca.3:73
#: build/C/man2/madvise.2:346 build/C/man3/malloc_get_state.3:88
#: build/C/man3/malloc_hook.3:82 build/C/man3/malloc_info.3:63
#: build/C/man3/malloc_stats.3:57 build/C/man3/malloc_trim.3:62
#: build/C/man3/malloc_usable_size.3:50 build/C/man3/mcheck.3:147
#: build/C/man2/mlock.2:213 build/C/man2/mmap.2:515 build/C/man2/mmap2.2:79
#: build/C/man2/mprotect.2:122 build/C/man2/mremap.2:191
#: build/C/man3/mtrace.3:80 build/C/man2/posix_fadvise.2:121
#: build/C/man3/posix_memalign.3:219 build/C/man3/shm_open.3:255
#: build/C/man7/shm_overview.7:103 build/C/man2/shmctl.2:373
#: build/C/man2/shmget.2:237 build/C/man2/shmop.2:250
#: build/C/man2/subpage_prot.2:98 build/C/man2/sync_file_range.2:183
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:141
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs file system can be used instead.  Memory backed "
"by huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual file system."
msgstr ""
"これらのシステムコールはなくなった。 これらは Linux 2.5.36 から 2.5.54 にのみ"
"存在する。 代わりに今は hugetlbfs ファイルシステムを使うことができる。 (CPU "
"がサポートしている場合) ヒュージページを持つメモリは、 B<mmap>(2)  を使ってこ"
"の仮想ファイルシステムでファイルをマップすることで取得できる。"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:145
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""
"ヒュージページの最大数は、 B<hugepages=> 起動パラメータを使って指定できる。"

#. type: SH
#: build/C/man2/alloc_hugepages.2:150 build/C/man3/alloca.3:155
#: build/C/man2/cacheflush.2:89 build/C/man2/fallocate.2:203
#: build/C/man2/madvise.2:379 build/C/man3/mallinfo.3:279
#: build/C/man3/malloc_get_state.3:114 build/C/man3/malloc_hook.3:142
#: build/C/man3/malloc_info.3:260 build/C/man3/malloc_stats.3:67
#: build/C/man3/malloc_trim.3:82 build/C/man3/malloc_usable_size.3:64
#: build/C/man3/mallopt.3:580 build/C/man3/mcheck.3:208
#: build/C/man2/mlock.2:336 build/C/man2/mmap.2:730 build/C/man2/mmap2.2:98
#: build/C/man2/mprotect.2:229 build/C/man2/mremap.2:214
#: build/C/man2/msync.2:122 build/C/man3/mtrace.3:172
#: build/C/man2/posix_fadvise.2:189 build/C/man3/posix_fallocate.3:133
#: build/C/man3/posix_memalign.3:275 build/C/man2/readahead.2:98
#: build/C/man2/remap_file_pages.2:164 build/C/man3/shm_open.3:280
#: build/C/man7/shm_overview.7:127 build/C/man2/shmctl.2:425
#: build/C/man2/shmget.2:313 build/C/man2/shmop.2:295
#: build/C/man2/subpage_prot.2:134 build/C/man2/sync_file_range.2:222
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:157 build/C/man3/alloca.3:162
#: build/C/man2/cacheflush.2:96 build/C/man2/fallocate.2:210
#: build/C/man2/madvise.2:386 build/C/man3/mallinfo.3:286
#: build/C/man3/malloc_get_state.3:121 build/C/man3/malloc_hook.3:149
#: build/C/man3/malloc_info.3:267 build/C/man3/malloc_stats.3:74
#: build/C/man3/malloc_trim.3:89 build/C/man3/malloc_usable_size.3:71
#: build/C/man3/mallopt.3:587 build/C/man3/mcheck.3:215
#: build/C/man2/mlock.2:343 build/C/man2/mmap.2:737 build/C/man2/mmap2.2:105
#: build/C/man2/mprotect.2:236 build/C/man2/mremap.2:221
#: build/C/man2/msync.2:129 build/C/man3/mtrace.3:179
#: build/C/man2/posix_fadvise.2:196 build/C/man3/posix_fallocate.3:140
#: build/C/man3/posix_memalign.3:282 build/C/man2/readahead.2:105
#: build/C/man2/remap_file_pages.2:171 build/C/man3/shm_open.3:287
#: build/C/man7/shm_overview.7:134 build/C/man2/shmctl.2:432
#: build/C/man2/shmget.2:320 build/C/man2/shmop.2:302
#: build/C/man2/subpage_prot.2:141 build/C/man2/sync_file_range.2:229
#, fuzzy
#| msgid ""
#| "This page is part of release 3.41 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.50 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.41 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/alloca.3:43
#, no-wrap
msgid "ALLOCA"
msgstr "ALLOCA"

#. type: TH
#: build/C/man3/alloca.3:43
#, no-wrap
msgid "2008-01-24"
msgstr "2008-01-24"

#. type: TH
#: build/C/man3/alloca.3:43 build/C/man3/malloc_get_state.3:25
#: build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25
#: build/C/man3/malloc_usable_size.3:25 build/C/man3/mcheck.3:25
#: build/C/man3/mtrace.3:25 build/C/man3/posix_fallocate.3:25
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/alloca.3:46
msgid "alloca - allocate memory that is automatically freed"
msgstr "alloca - 自動的に解放されるメモリを割り当てる"

#. type: Plain text
#: build/C/man3/alloca.3:48
msgid "B<#include E<lt>alloca.hE<gt>>"
msgstr "B<#include E<lt>alloca.hE<gt>>"

#. type: Plain text
#: build/C/man3/alloca.3:50
msgid "B<void *alloca(size_t >I<size>B<);>"
msgstr "B<void *alloca(size_t >I<size>B<);>"

#. type: Plain text
#: build/C/man3/alloca.3:60
msgid ""
"The B<alloca>()  function allocates I<size> bytes of space in the stack "
"frame of the caller.  This temporary space is automatically freed when the "
"function that called B<alloca>()  returns to its caller."
msgstr ""
"B<alloca>()  関数は、 I<size> バイトの領域を呼出元のスタック・フレームに割り"
"付ける。 この一時的な領域は、 B<alloca>()  を呼び出した関数が呼出元に返るとき"
"に自動的に解放される。"

#. type: Plain text
#: build/C/man3/alloca.3:65
msgid ""
"The B<alloca>()  function returns a pointer to the beginning of the "
"allocated space.  If the allocation causes stack overflow, program behavior "
"is undefined."
msgstr ""
"B<alloca>()  関数は、割り付けた領域の始まりを指すポインタを返す。 割り付けに"
"よってスタックオーバーフローが起った場合の プログラムの動作は定義されていな"
"い。"

#. type: Plain text
#: build/C/man3/alloca.3:67
msgid "This function is not in POSIX.1-2001."
msgstr "この関数は POSIX.1-2001 にはない。"

#. type: Plain text
#: build/C/man3/alloca.3:73
msgid ""
"There is evidence that the B<alloca>()  function appeared in 32V, PWB, "
"PWB.2, 3BSD, and 4BSD.  There is a man page for it in 4.3BSD.  Linux uses "
"the GNU version."
msgstr ""
"32V, PWB, PWB.2, 3BSD, 4BSD に B<alloca>()  関数が登場した証拠がある。 "
"4.3BSD には、マニュアルページがある。 Linux は、GNU 版を使っている。 この関数"
"は POSIX.1-2001 にはない。"

#. type: Plain text
#: build/C/man3/alloca.3:88
msgid ""
"The B<alloca>()  function is machine- and compiler-dependent.  For certain "
"applications, its use can improve efficiency compared to the use of B<malloc>"
"(3)  plus B<free>(3).  In certain cases, it can also simplify memory "
"deallocation in applications that use B<longjmp>(3)  or B<siglongjmp>(3).  "
"Otherwise, its use is discouraged."
msgstr ""
"B<alloca>()  関数は、機種とコンパイラに依存する。 特定のアプリケーションで"
"は、この関数を使うと B<malloc>(3)  と B<free>(3)  を組み合わせて使った場合に"
"比べて効率を改善することができる。 特定の場合では、この関数を使うことで、 "
"B<longjmp>(3)  や B<siglongjmp>(3)  を使うアプリケーションでのメモリの開放を"
"簡単にすることができる。 それ以外の場合では、この関数の使用は推奨されない。"

#. type: Plain text
#: build/C/man3/alloca.3:97
msgid ""
"Because the space allocated by B<alloca>()  is allocated within the stack "
"frame, that space is automatically freed if the function return is jumped "
"over by a call to B<longjmp>(3)  or B<siglongjmp>(3)."
msgstr ""
"B<alloca>()  により割り当てられる空間はスタックフレームから割り当てらるの"
"で、 関数の戻り先が B<longjmp>(3)  や B<siglongjmp>(3)  の呼び出しによりジャ"
"ンプした場合には、 割り当てられた空間は自動的に解放される。"

#. type: Plain text
#: build/C/man3/alloca.3:102
msgid "Do not attempt to B<free>(3)  space allocated by B<alloca>()!"
msgstr ""
"B<alloca>()  で割り当てられた空間を B<free>(3)  しようとすることのないよう"
"に！"

#. type: SS
#: build/C/man3/alloca.3:102
#, fuzzy, no-wrap
#| msgid "Notes on the GNU Version"
msgid "Notes on the GNU version"
msgstr "GNU 版についての注意"

#. type: Plain text
#: build/C/man3/alloca.3:124
msgid ""
"Normally, B<gcc>(1)  translates calls to B<alloca>()  with inlined code.  "
"This is not done when either the I<-ansi>, I<-std=c89>, I<-std=c99>, or the "
"I<-fno-builtin> option is given (and the header I<E<lt>alloca.hE<gt>> is not "
"included).  But beware! By default the glibc version of I<E<lt>stdlib."
"hE<gt>> includes I<E<lt>alloca.hE<gt>> and that contains the line:"
msgstr ""
"通常 B<gcc>(1)  は B<alloca>()  の呼び出しをインラインコードに変換する。 I<-"
"ansi>, I<-std=c89>, I<-std=c99>, I<-fno-builtin> のいずれかのオプションが指定"
"された場合、この変換は行われない (また I<E<lt>alloca.hE<gt>> のインクルードも"
"行われない)。 だだし、デフォルトでは glibc 版の I<E<lt>stdlib.hE<gt>> は "
"I<E<lt>alloca.hE<gt>> をインクルードしており、これには以下の行が含まれている"
"ので注意すること。"

#. type: Plain text
#: build/C/man3/alloca.3:127
#, no-wrap
msgid "    #define alloca(size)   __builtin_alloca (size)\n"
msgstr "    #define alloca(size)   __builtin_alloca (size)\n"

#. type: Plain text
#: build/C/man3/alloca.3:130
msgid "with messy consequences if one has a private version of this function."
msgstr "独自版の __builtin_alloca (size) 関数があると厄介な結果になる。"

#. type: Plain text
#: build/C/man3/alloca.3:134
msgid ""
"The fact that the code is inlined means that it is impossible to take the "
"address of this function, or to change its behavior by linking with a "
"different library."
msgstr ""
"このコードはインライン化されているので、 この関数のアドレスを取得したり、 他"
"のライブラリをリンクして動作を変更することはできない。"

#. type: Plain text
#: build/C/man3/alloca.3:138
msgid ""
"The inlined code often consists of a single instruction adjusting the stack "
"pointer, and does not check for stack overflow.  Thus, there is no NULL "
"error return."
msgstr ""
"通常このインラインコードはスタックポインタを移動する 1 つの命令 "
"(instruction) から構成されており、 スタックオーバーフローをチェックしない。 "
"よって NULL エラーが返されることはない。"

#. type: SH
#: build/C/man3/alloca.3:138 build/C/man2/cacheflush.2:82
#: build/C/man3/mallinfo.3:114 build/C/man3/mallopt.3:406
#: build/C/man2/mlock.2:304 build/C/man2/mmap.2:587 build/C/man3/mtrace.3:102
#: build/C/man2/posix_fadvise.2:178 build/C/man2/shmget.2:299
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/alloca.3:143
msgid ""
"There is no error indication if the stack frame cannot be extended.  "
"(However, after a failed allocation, the program is likely to receive a "
"B<SIGSEGV> signal if it attempts to access the unallocated space.)"
msgstr ""
"スタックフレームが拡張できなかった場合、エラー通知は行われない。 (しかしなが"
"ら、割り当てに失敗した後で、プログラムが割り当てられなかった 空間にアクセスし"
"ようとした場合に B<SIGSEGV> シグナルを受信することだろう。)"

#. type: Plain text
#: build/C/man3/alloca.3:151
msgid ""
"On many systems B<alloca>()  cannot be used inside the list of arguments of "
"a function call, because the stack space reserved by B<alloca>()  would "
"appear on the stack in the middle of the space for the function arguments."
msgstr ""
"多くのシステムにおいて、関数コールの引き数のリスト内では B<alloca>()  が使え"
"ない。 これは、 B<alloca>()  によって予約されるスタック領域が、 関数引き数に"
"使われるスタック領域の中に現れてしまうためである。"

#. type: SH
#: build/C/man3/alloca.3:151 build/C/man2/fallocate.2:198
#: build/C/man2/madvise.2:371 build/C/man3/mallinfo.3:270
#: build/C/man3/malloc_get_state.3:111 build/C/man3/malloc_hook.3:137
#: build/C/man3/malloc_info.3:254 build/C/man3/malloc_stats.3:61
#: build/C/man3/malloc_trim.3:78 build/C/man3/malloc_usable_size.3:62
#: build/C/man3/mallopt.3:566 build/C/man3/mcheck.3:204
#: build/C/man2/mlock.2:329 build/C/man2/mmap.2:712 build/C/man2/mmap2.2:92
#: build/C/man2/mprotect.2:226 build/C/man2/mremap.2:199
#: build/C/man2/msync.2:118 build/C/man3/mtrace.3:167
#: build/C/man2/posix_fadvise.2:183 build/C/man3/posix_fallocate.3:128
#: build/C/man3/posix_memalign.3:270 build/C/man2/readahead.2:92
#: build/C/man2/remap_file_pages.2:157 build/C/man3/shm_open.3:269
#: build/C/man7/shm_overview.7:114 build/C/man2/shmctl.2:418
#: build/C/man2/shmget.2:305 build/C/man2/shmop.2:287
#: build/C/man2/subpage_prot.2:128 build/C/man2/sync_file_range.2:217
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/alloca.3:155
msgid "B<brk>(2), B<longjmp>(3), B<malloc>(3)"
msgstr "B<brk>(2), B<longjmp>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/cacheflush.2:25
#, no-wrap
msgid "CACHEFLUSH"
msgstr "CACHEFLUSH"

#. type: TH
#: build/C/man2/cacheflush.2:25
#, no-wrap
msgid "2007-05-26"
msgstr "2007-05-26"

#. type: Plain text
#: build/C/man2/cacheflush.2:28
msgid "cacheflush - flush contents of instruction and/or data cache"
msgstr "cacheflush - 命令キャッシュやデータキャッシュの内容をフラッシュする"

#. type: Plain text
#: build/C/man2/cacheflush.2:31
#, no-wrap
msgid "B<#include E<lt>asm/cachectl.hE<gt>>\n"
msgstr "B<#include E<lt>asm/cachectl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/cacheflush.2:33
#, no-wrap
msgid "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"
msgstr "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"

#. type: Plain text
#: build/C/man2/cacheflush.2:43
msgid ""
"B<cacheflush>()  flushes the contents of the indicated cache(s) for the user "
"addresses in the range I<addr> to I<(addr+nbytes-1)>.  I<cache> may be one "
"of:"
msgstr ""
"B<cacheflush>()  は I<addr> から I<(addr+nbytes-1)> の範囲のユーザアドレスに"
"対応する 指定されたキャッシュをフラッシュする。 I<cache> には以下のいずれかを"
"指定する:"

#. type: TP
#: build/C/man2/cacheflush.2:43
#, no-wrap
msgid "B<ICACHE>"
msgstr "B<ICACHE>"

#. type: Plain text
#: build/C/man2/cacheflush.2:46
msgid "Flush the instruction cache."
msgstr "命令 (instruction) キャッシュをフラッシュする。"

#. type: TP
#: build/C/man2/cacheflush.2:46
#, no-wrap
msgid "B<DCACHE>"
msgstr "B<DCACHE>"

#. type: Plain text
#: build/C/man2/cacheflush.2:49
msgid "Write back to memory and invalidate the affected valid cache lines."
msgstr "変更があったキャッシュラインをメモリに書き戻し、無効にする。"

#. type: TP
#: build/C/man2/cacheflush.2:49
#, no-wrap
msgid "B<BCACHE>"
msgstr "B<BCACHE>"

#. type: Plain text
#: build/C/man2/cacheflush.2:53
msgid "Same as B<(ICACHE|DCACHE)>."
msgstr "B<(ICACHE|DCACHE)> と同じ。"

#. type: Plain text
#: build/C/man2/cacheflush.2:59
msgid ""
"B<cacheflush>()  returns 0 on success or -1 on error.  If errors are "
"detected, I<errno> will indicate the error."
msgstr ""
"B<cacheflush>()  は成功した場合は 0 を、失敗した場合は -1 を返す。エラーが検"
"出された場合は I<errno> にエラーが指示される。"

#. type: TP
#: build/C/man2/cacheflush.2:60 build/C/man2/mmap2.2:62
#: build/C/man2/mremap.2:142 build/C/man2/shmctl.2:305
#: build/C/man2/subpage_prot.2:72
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/cacheflush.2:67
msgid ""
"Some or all of the address range I<addr> to I<(addr+nbytes-1)> is not "
"accessible."
msgstr ""
"I<addr> から I<(addr+nbytes-1)> の範囲のアドレスの全てまたは一部が アクセス可"
"能ではない。"

#. type: TP
#: build/C/man2/cacheflush.2:67 build/C/man2/fallocate.2:127
#: build/C/man2/madvise.2:282 build/C/man3/malloc_info.3:54
#: build/C/man2/mlock.2:157 build/C/man2/mlock.2:164 build/C/man2/mlock.2:176
#: build/C/man2/mmap.2:423 build/C/man2/mmap.2:431 build/C/man2/mmap.2:436
#: build/C/man2/mmap2.2:65 build/C/man2/mprotect.2:95
#: build/C/man2/mremap.2:151 build/C/man2/msync.2:80
#: build/C/man2/posix_fadvise.2:94 build/C/man3/posix_fallocate.3:81
#: build/C/man3/posix_memalign.3:156 build/C/man2/readahead.2:76
#: build/C/man2/remap_file_pages.2:132 build/C/man2/remap_file_pages.2:139
#: build/C/man3/shm_open.3:211 build/C/man2/shmctl.2:319
#: build/C/man2/shmget.2:198 build/C/man2/shmop.2:200 build/C/man2/shmop.2:223
#: build/C/man2/subpage_prot.2:77 build/C/man2/sync_file_range.2:152
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/cacheflush.2:75
msgid "I<cache> is not one of B<ICACHE>, B<DCACHE>, or B<BCACHE>."
msgstr "I<cache> パラメータが B<ICACHE>, B<DCACHE>, B<BCACHE> のどれでもない。"

#.  FIXME This system call was only on MIPS back in 1.2 days, but
#.  by now it is on a number of other architectures (but not i386).
#.  Investigate the details and update this page.
#.  Irix 6.5 appears to have a cacheflush() syscall -- mtk
#. type: Plain text
#: build/C/man2/cacheflush.2:82
msgid ""
"This Linux-specific system call is only available on MIPS-based systems.  It "
"should not be used in programs intended to be portable."
msgstr ""
"この Linux 特有のシステムコールは MIPS ベースのシステムでのみ有効である。 移"
"植を意図したプログラムで使用すべきではない。"

#. type: Plain text
#: build/C/man2/cacheflush.2:89
msgid ""
"The current implementation ignores the I<addr> and I<nbytes> arguments.  "
"Therefore, the whole cache is always flushed."
msgstr ""
"現在の実装では、引き数 I<addr> と I<nbytes> は無視される。そのため、 常に全て"
"のキャッシュがフラッシュされる。"

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr "FALLOCATE"

#. type: TH
#: build/C/man2/fallocate.2:11 build/C/man3/posix_fallocate.3:25
#: build/C/man2/shmop.2:41
#, fuzzy, no-wrap
#| msgid "2009-02-25"
msgid "2013-02-12"
msgstr "2009-02-25"

#. type: Plain text
#: build/C/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr "fallocate - ファイル空間の操作"

#. type: Plain text
#: build/C/man2/fallocate.2:18 build/C/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/fallocate.2:21
#, no-wrap
msgid "B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr "B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""
"このシステムコールは、移植性のない、Linux 固有のシステムコールである。 移植性"
"が必要な場合は、ファイルに対してディスク空間を確実に確保するために、 POSIX.1 "
"で規定された方法である B<posix_fallocate>(3)  を使うこと。"

#. type: Plain text
#: build/C/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""
"B<fallocate>()  を使うと、 I<fd> が参照するファイルに割り当てられたディスク空"
"間を直接操作できる。 操作対象は、 I<offset> から始まる長さ I<len> バイトの領"
"域である。"

#. type: Plain text
#: build/C/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""
"I<mode> 引き数は、指定された領域に対して実行する操作を指定する。\n"
"サポートされている操作の詳細は以下のサブセクションで説明する。"

#. type: SS
#: build/C/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr "ディスク領域の割り当て"

#. type: Plain text
#: build/C/man2/fallocate.2:61
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"and initializes to zero the disk space within the range specified by "
"I<offset> and I<len>.  The file size (as reported by B<stat>(2))  will be "
"changed if I<offset>+I<len> is greater than the file size.  This default "
"behavior closely resembles the behavior of the B<posix_fallocate>(3)  "
"library function, and is intended as a method of optimally implementing that "
"function."
msgstr ""
"B<fallocate>() のデフォルトの動作 (つまり I<mode> が 0 の場合) は、\n"
"I<offset> と I<len> で指定された範囲のディスク領域の割り当てと初期化を行"
"う。\n"
"I<offset>+I<len> がファイルサイズよりも大きかった場合、\n"
"(B<stat>(2) で報告される) ファイルサイズが変更される。このデフォルトの動作"
"は、\n"
"ライブラリ関数 B<posix_fallocate>(3) の動作と非常に似ている。これは、\n"
"このシステムコールが B<posix_fallocate>(3) を最適に実装する手段を提供する\n"
"ことを目的としているからである。"

#. type: Plain text
#: build/C/man2/fallocate.2:67
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""
"呼び出しが成功した場合、\n"
"I<offset> と I<len> で指定された範囲へのそれ以降の書き込みでは、\n"
"ディスクの領域不足での書き込み失敗が起こらないことが保証される。"

#. type: Plain text
#: build/C/man2/fallocate.2:78
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if I<offset>"
"+I<len> is greater than the file size.  Preallocating zeroed blocks beyond "
"the end of the file in this manner is useful for optimizing append workloads."
msgstr ""
"B<FALLOC_FL_KEEP_SIZE> フラグが I<mode> に指定された場合、このシステムコー"
"ル\n"
"の動作は似ているが、 I<offset>+I<len> がファイルサイズよりも大きい場合で\n"
"あってもファイルサイズは変更されない点が異なる。この場合のファイルの末尾\n"
"よりも後ろの前もって割り当てられた 0 で埋められたブロックは、ファイルへの\n"
"追記を最適化したい場合に役に立つ。"

#. type: Plain text
#: build/C/man2/fallocate.2:82
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""
"割り当てはブロックサイズ単位で行われるため、 B<fallocate>() は指定されたよ"
"り\n"
"も大きなディスク領域を割り当てることがある。"

#. type: SS
#: build/C/man2/fallocate.2:82
#, no-wrap
msgid "Deallocating file space"
msgstr "ファイル空間の割り当て解除"

#. type: Plain text
#: build/C/man2/fallocate.2:97
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified "
"range, partial file system blocks are zeroed, and whole file system blocks "
"are removed from the file.  After a successful call, subsequent reads from "
"this range will return zeroes."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:108
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in "
"I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:112
msgid ""
"Not all file systems support B<FALLOC_FL_PUNCH_HOLE>; if a file system "
"doesn't support the operation, an error is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:115
msgid "B<fallocate>()  returns zero on success, and -1 on failure."
msgstr "B<fallocate>()  は成功すると 0 を返し、エラーの場合は -1 を返す。"

#. type: TP
#: build/C/man2/fallocate.2:116 build/C/man2/madvise.2:279
#: build/C/man2/mmap.2:417 build/C/man2/posix_fadvise.2:91
#: build/C/man3/posix_fallocate.3:73 build/C/man2/readahead.2:72
#: build/C/man2/sync_file_range.2:148
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/fallocate.2:120 build/C/man3/posix_fallocate.3:77
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""
"I<fd> が有効なファイルディスクリプタでないか、 書き込み用としてオープンされて"
"いない。"

#. type: TP
#: build/C/man2/fallocate.2:120 build/C/man3/posix_fallocate.3:77
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/fallocate.2:124
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr "I<offset + len> がファイルサイズの最大値よりも大きい。"

#. type: TP
#: build/C/man2/fallocate.2:124
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/fallocate.2:127
msgid "A signal was caught during execution."
msgstr "実行中にシグナルが捕捉された。"

#. type: Plain text
#: build/C/man2/fallocate.2:139 build/C/man3/posix_fallocate.3:87
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr "I<offset> が 0 未満だったか、 I<len> が 0 以下だった。"

#. type: TP
#: build/C/man2/fallocate.2:139 build/C/man2/madvise.2:310
#: build/C/man2/sync_file_range.2:160
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/fallocate.2:142
msgid "An I/O error occurred while reading from or writing to a file system."
msgstr "ファイルシステムとの読み書き中に入出力エラーが発生した。"

#. type: TP
#: build/C/man2/fallocate.2:142 build/C/man2/mmap.2:452
#: build/C/man3/posix_fallocate.3:87
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/fallocate.2:149
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""
"I<fd> が通常のファイルかディレクトリを参照していない (I<fd> がパイプや FIFO "
"を参照している場合、別のエラーが発生する)。"

#. type: TP
#: build/C/man2/fallocate.2:149 build/C/man3/posix_fallocate.3:91
#: build/C/man2/shmget.2:216 build/C/man2/sync_file_range.2:166
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/fallocate.2:154 build/C/man3/posix_fallocate.3:96
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr "I<fd> が参照するファイルを含むデバイスに十分な空き領域がない。"

#. type: Plain text
#: build/C/man2/fallocate.2:158
msgid "This kernel does not implement B<fallocate>()."
msgstr "このカーネルでは B<fallocate>() は実装されていない。"

#. type: TP
#: build/C/man2/fallocate.2:158
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr "B<EOPNOTSUPP>"

#. type: Plain text
#: build/C/man2/fallocate.2:167
msgid ""
"The file system containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the file system "
"containing the file referred to by I<fd>."
msgstr ""
"I<fd> が参照するファイルを含むファイルシステムが 指定された操作を\n"
"サポートしていない。 I<fd> が参照するファイルを含むファイルシステムが\n"
"I<mode> をサポートしていない。"

#. type: TP
#: build/C/man2/fallocate.2:167 build/C/man2/mlock.2:143
#: build/C/man2/mlock.2:182 build/C/man2/mmap.2:460 build/C/man2/shmctl.2:344
#: build/C/man2/shmget.2:224
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/fallocate.2:183
msgid ""
"The file referred to by I<fd> is marked immutable (see B<chattr>(1)).  Or: "
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> and the file referred to by I<fd> "
"is marked append-only (see B<chattr>(1))."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:183 build/C/man2/posix_fadvise.2:97
#: build/C/man3/posix_fallocate.3:96 build/C/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr "B<ESPIPE>"

#. type: Plain text
#: build/C/man2/fallocate.2:187
msgid "I<fd> refers to a pipe or FIFO."
msgstr "I<fd> がパイプか FIFO を参照している。"

#. type: SH
#: build/C/man2/fallocate.2:187 build/C/man3/malloc_info.3:58
#: build/C/man3/mcheck.3:134 build/C/man2/mmap2.2:74
#: build/C/man2/posix_fadvise.2:104 build/C/man3/posix_fallocate.3:100
#: build/C/man3/posix_memalign.3:165 build/C/man2/readahead.2:82
#: build/C/man2/remap_file_pages.2:148 build/C/man3/shm_open.3:247
#: build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:177
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: build/C/man2/fallocate.2:195
#, fuzzy
#| msgid ""
#| "B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
#| "provided by glibc since version 2.10."
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""
"B<fallocate>()  はカーネル 2.6.23 以降の Linux で利用可能である。 glibc での"
"対応はバージョン 3.10 以降で行われている。"

#. type: Plain text
#: build/C/man2/fallocate.2:198
msgid "B<fallocate>()  is Linux-specific."
msgstr "B<fallocate>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/fallocate.2:203
#, fuzzy
#| msgid "B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgid ""
"B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr "B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr "MADVISE"

#. type: TH
#: build/C/man2/madvise.2:35 build/C/man3/malloc_info.3:25
#, no-wrap
msgid "2012-04-28"
msgstr "2012-04-28"

#. type: Plain text
#: build/C/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr "madvise - メモリ利用に関するアドバイスを与える"

#. type: Plain text
#: build/C/man2/madvise.2:40 build/C/man2/msync.2:30
#: build/C/man3/shm_open.3:31
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: build/C/man2/madvise.2:42
msgid ""
"B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""
"B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"

#. type: Plain text
#: build/C/man2/madvise.2:46 build/C/man2/posix_fadvise.2:43
#: build/C/man3/posix_fallocate.3:39 build/C/man3/posix_memalign.3:49
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/madvise.2:50
msgid "B<madvise>(): _BSD_SOURCE"
msgstr "B<madvise>(): _BSD_SOURCE"

#. type: Plain text
#: build/C/man2/madvise.2:68
msgid ""
"The B<madvise>()  system call advises the kernel about how to handle paging "
"input/output in the address range beginning at address I<addr> and with size "
"I<length> bytes.  It allows an application to tell the kernel how it expects "
"to use some mapped or shared memory areas, so that the kernel can choose "
"appropriate read-ahead and caching techniques.  This call does not influence "
"the semantics of the application (except in the case of B<MADV_DONTNEED>), "
"but may influence its performance.  The kernel is free to ignore the advice."
msgstr ""
"B<madvise>()  システムコールは、アドレス I<addr> からはじまる I<length> バイ"
"トのメモリブロックのページング入出力をどう扱えば良いか、 カーネルにアドバイス"
"する。 これを用いると、 アプリケーションからカーネルに、 マップされたメモリや"
"共有メモリをどのように扱ってほしいか伝えることができ、 カーネルはそれに応じて"
"先読みやキャッシュなどの適切な手法を選択できる。 このコールはアプリケーション"
"の動作そのものには影響しない (B<MADV_DONTNEED> の場合は別) が、 性能には影響"
"しうる。 なおこのアドバイスを受け入れるかどうかはカーネルに任される。"

#. type: Plain text
#: build/C/man2/madvise.2:72
msgid "The advice is indicated in the I<advice> argument which can be"
msgstr ""
"アドバイスは引き数 I<advice> によって与える。以下のいずれかを指定できる。"

#. type: TP
#: build/C/man2/madvise.2:72
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr "B<MADV_NORMAL>"

#. type: Plain text
#: build/C/man2/madvise.2:76
msgid "No special treatment.  This is the default."
msgstr "特別な扱いは行わない。これがデフォルトである。"

#. type: TP
#: build/C/man2/madvise.2:76
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr "B<MADV_RANDOM>"

#. type: Plain text
#: build/C/man2/madvise.2:80
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""
"ページ参照はランダムな順序で行われそうだ。 (したがって、先読みはあまり効果が"
"なさそうだ。)"

#. type: TP
#: build/C/man2/madvise.2:80
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr "B<MADV_SEQUENTIAL>"

#. type: Plain text
#: build/C/man2/madvise.2:85
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""
"ページ参照はシーケンシャルな順序で行われそうだ。 (したがって与えた範囲のペー"
"ジは積極的に先読みしておくと良いだろう。 またアクセスが終わったら速やかに解放"
"して良い。)"

#. type: TP
#: build/C/man2/madvise.2:85
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr "B<MADV_WILLNEED>"

#. type: Plain text
#: build/C/man2/madvise.2:89
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""
"近い将来にアクセスされそうだ。 (したがってこれらのページを今のうちに先読みし"
"ておくといいだろう。)"

#. type: TP
#: build/C/man2/madvise.2:89
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr "B<MADV_DONTNEED>"

#. type: Plain text
#: build/C/man2/madvise.2:100
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)  Subsequent accesses of pages in this range "
"will succeed, but will result either in reloading of the memory contents "
"from the underlying mapped file (see B<mmap>(2))  or zero-fill-on-demand "
"pages for mappings without an underlying file."
msgstr ""
"しばらくアクセスはなさそうだ。 (現時点でアプリケーションは与えた範囲の処理を"
"終えている。 したがってカーネルはこれに関連するリソースを解放して良い。)  こ"
"れ以降この範囲のページへのアクセスがあると、 成功はするが、メモリの内容をマッ"
"プ元のファイルからロードし直すことになる (B<mmap>(2)  を見よ) か、 または元"
"ファイルがないマップページでは アクセスがあったときに 0 埋めが行われることに"
"なる。"

#. type: TP
#: build/C/man2/madvise.2:100
#, no-wrap
msgid "B<MADV_REMOVE> (Since Linux 2.6.16)"
msgstr "B<MADV_REMOVE> (Linux 2.6.16 以降)"

#.  2.6.18-rc5
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: build/C/man2/madvise.2:113
msgid ""
"Free up a given range of pages and its associated backing store.  Currently, "
"only shmfs/tmpfs supports this; other file systems return with the error "
"B<ENOSYS>."
msgstr ""
"指定された範囲のページと関連するバッキングストアを解放する。 現在のところ、 "
"shmfs/tmpfs だけがこれに対応している。 他のファイルシステムでは B<ENOSYS> が"
"返される。"

#. type: TP
#: build/C/man2/madvise.2:113
#, no-wrap
msgid "B<MADV_DONTFORK> (Since Linux 2.6.16)"
msgstr "B<MADV_DONTFORK> (Linux 2.6.16 以降)"

#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: build/C/man2/madvise.2:144
msgid ""
"Do not make the pages in this range available to the child after a B<fork>"
"(2).  This is useful to prevent copy-on-write semantics from changing the "
"physical location of a page(s) if the parent writes to it after a B<fork>"
"(2).  (Such page relocations cause problems for hardware that DMAs into the "
"page(s).)"
msgstr ""
"B<fork>(2)  が行われた後、指定された範囲のページを子プロセスが利用できないよ"
"うにする。 この機能は、書き込み時コピー (copy-on-write) 方式で、 B<fork>(2)  "
"の後で親プロセスがページに書き込みを行った場合に ページの物理位置が変化しない"
"ようにするのに有効である (ページの再配置はハードウェアがそのページに DMA 転送"
"を行うような場合に 問題を起こすことがある)。"

#. type: TP
#: build/C/man2/madvise.2:144
#, no-wrap
msgid "B<MADV_DOFORK> (Since Linux 2.6.16)"
msgstr "B<MADV_DOFORK> (Linux 2.6.16 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:150
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby "
"a mapping is inherited across B<fork>(2)."
msgstr ""
"B<MADV_DONTFORK> の影響を取り消し、デフォルトの動作に戻す。 つまり、 B<fork>"
"(2)  の前後でマッピングは継承されるようになる。"

#. type: TP
#: build/C/man2/madvise.2:150
#, no-wrap
msgid "B<MADV_HWPOISON> (Since Linux 2.6.32)"
msgstr "B<MADV_HWPOISON> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:162
msgid ""
"Poison a page and handle it like a hardware memory corruption.  This "
"operation is only available for privileged (B<CAP_SYS_ADMIN>)  processes.  "
"This operation may result in the calling process receiving a B<SIGBUS> and "
"the page being unmapped.  This feature is intended for testing of memory "
"error-handling code; it is only available if the kernel was configured with "
"B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:162
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (Since Linux 2.6.33)"
msgstr "B<MADV_SOFT_OFFLINE> (Linux 2.6.33 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:180
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The "
"memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process.  This feature is intended for testing of memory error-"
"handling code; it is only available if the kernel was configured with "
"B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:180
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr "B<MADV_MERGEABLE> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:205
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by "
"I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM only merges private anonymous pages (see B<mmap>(2)).  The KSM "
"feature is intended for applications that generate many instances of the "
"same data (e.g., virtualization systems such as KVM).  It can consume a lot "
"of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/vm/ksm.txt> for more details.  The B<MADV_MERGEABLE> and "
"B<MADV_UNMERGEABLE> operations are only available if the kernel was "
"configured with B<CONFIG_KSM>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr "B<MADV_UNMERGEABLE> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:214
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:214
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr "B<MADV_HUGEPAGE> (Linux 2.6.38 以降)"

#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: build/C/man2/madvise.2:243
msgid ""
"Enables Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages only work with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2)).  This "
"feature is primarily aimed at applications that use large mappings of data "
"and access large regions of that memory at a time (e.g., virtualization "
"systems such as QEMU).  It can very easily waste memory (e.g., a 2MB mapping "
"that only ever accesses 1 byte will result in 2MB of wired memory instead of "
"one 4KB page).  See the Linux kernel source file I<Documentation/vm/"
"transhuge.txt> for more details.  The B<MADV_HUGEPAGE> and "
"B<MADV_NOHUGEPAGE> operations are only available if the kernel was "
"configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr "B<MADV_NOHUGEPAGE> (Linux 2.6.38 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:250
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be collapsed into huge pages."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:250
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr "B<MADV_DONTDUMP> (Linux 3.4 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:264
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the I</"
"proc/PID/coredump_filter> file (see B<core>(5))."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:264
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr "B<MADV_DODUMP> (Linux 3.4 以降)"

#. type: Plain text
#: build/C/man2/madvise.2:268
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:275
msgid ""
"On success B<madvise>()  returns zero.  On error, it returns -1 and I<errno> "
"is set appropriately."
msgstr ""
"B<madvise>()  は成功すると 0 を返す。 エラーが起こると -1 を返し、 I<errno> "
"を適切な値に設定する。"

#. type: TP
#: build/C/man2/madvise.2:276 build/C/man2/mlock.2:154 build/C/man2/mmap.2:413
#: build/C/man2/mremap.2:136
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/madvise.2:279
msgid "A kernel resource was temporarily unavailable."
msgstr "何らかのカーネルリソースが一時的に利用できなかった。"

#. type: Plain text
#: build/C/man2/madvise.2:282
msgid "The map exists, but the area maps something that isn't a file."
msgstr "指定したマップは存在するが、ファイルではないところをマップしている。"

#. type: Plain text
#: build/C/man2/madvise.2:285
msgid "This error can occur for the following reasons:"
msgstr ""

#. type: IP
#: build/C/man2/madvise.2:286 build/C/man2/madvise.2:292
#: build/C/man2/madvise.2:295 build/C/man2/madvise.2:298
#: build/C/man2/madvise.2:301 build/C/man3/mallopt.3:235
#: build/C/man3/mallopt.3:241
#, no-wrap
msgid "*"
msgstr "*"

#.  .I len
#.  is zero,
#. type: Plain text
#: build/C/man2/madvise.2:292
msgid "The value I<len> is negative."
msgstr "I<len> が負の値である。"

#. type: Plain text
#: build/C/man2/madvise.2:295
msgid "I<addr> is not page-aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:298
msgid "I<advice> is not a valid value"
msgstr "I<advice> が有効な値でない。"

#. type: Plain text
#: build/C/man2/madvise.2:301
msgid ""
"The application is attempting to release locked or shared pages (with "
"B<MADV_DONTNEED>)."
msgstr ""
"アプリケーションがロックされたページや共有ページを (B<MADV_DONTNEED> で) 解"
"放\n"
"しようとしている。"

#. type: Plain text
#: build/C/man2/madvise.2:309
msgid ""
"B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE> was specified in I<advice>, but the "
"kernel was not configured with B<CONFIG_KSM>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:316
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""
"(B<MADV_WILLNEED> の場合) この範囲のページングを行うと、 プロセスの RSS "
"(resident set size) の最大値を越えてしまう。"

#. type: TP
#: build/C/man2/madvise.2:316 build/C/man2/madvise.2:321
#: build/C/man2/mlock.2:123 build/C/man2/mlock.2:131 build/C/man2/mlock.2:169
#: build/C/man2/mmap.2:456 build/C/man2/mprotect.2:100
#: build/C/man2/mprotect.2:103 build/C/man2/mremap.2:179
#: build/C/man2/msync.2:93 build/C/man3/posix_memalign.3:162
#: build/C/man2/shmctl.2:328 build/C/man2/shmget.2:213
#: build/C/man2/shmop.2:214 build/C/man2/subpage_prot.2:87
#: build/C/man2/sync_file_range.2:163
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/madvise.2:321
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr "(B<MADV_WILLNEED> の場合) メモリが足りず、ページングに失敗した。"

#. type: Plain text
#: build/C/man2/madvise.2:325
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""
"指定した範囲のアドレスが、現在マップされていない。 あるいはプロセスのアドレス"
"空間の内部にない。"

#.  FIXME . Write a posix_madvise(3) page.
#. type: Plain text
#: build/C/man2/madvise.2:337
msgid ""
"POSIX.1b.  POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, etc., with a behavior close to that described here.  "
"There is a similar B<posix_fadvise>(2)  for file access."
msgstr ""
"POSIX.1b.  POSIX.1-2001 では、 B<posix_madvise>(3)  を B<POSIX_MADV_NORMAL> "
"などの定数とともに記述していた (それぞれの振る舞いはここで述べたものに近"
"い)。 ファイルアクセスに対しても B<posix_fadvise>(2)  という類似の関数が存在"
"する。"

#. type: Plain text
#: build/C/man2/madvise.2:346
msgid ""
"B<MADV_REMOVE>, B<MADV_DONTFORK>, B<MADV_DOFORK>, B<MADV_HWPOISON>, "
"B<MADV_MERGEABLE>, and B<MADV_UNMERGEABLE> are Linux-specific."
msgstr ""
"B<MADV_REMOVE>, B<MADV_DONTFORK>, B<MADV_DOFORK>, B<MADV_HWPOISON>,\n"
"B<MADV_MERGEABLE>, B<MADV_UNMERGEABLE> は Linux 固有である。"

#. type: SS
#: build/C/man2/madvise.2:347 build/C/man2/mlock.2:267
#: build/C/man2/shmget.2:293
#, fuzzy, no-wrap
#| msgid "Linux Notes"
msgid "Linux notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/madvise.2:355
msgid ""
"The current Linux implementation (2.4.0) views this system call more as a "
"command than as advice and hence may return an error when it cannot do what "
"it usually would do in response to this advice.  (See the ERRORS description "
"above.)  This is nonstandard behavior."
msgstr ""
"現在の Linux の実装 (2.4.0) では、 このシステムコールをアドバイスというよりは"
"命令と見ている。 したがってこのアドバイスに対して通常行われる動作が不可能な場"
"合は、 エラーを返すことがある (上記の エラー の記述を参照)。 この振舞いは標準"
"とは異なる。"

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/madvise.2:371
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""
"Linux の実装では I<addr> のアドレスはページ境界の値でなければならない。また "
"I<length> は 0 であっても構わない。 また Linux 版の B<madvise>()  では、指定"
"されたアドレス範囲にマップされていない部分があると、 これらを無視して残りの部"
"分にアドバイスを適用する (しかしシステムコールに対してはちゃんと B<ENOMEM> を"
"返す)。"

#. type: Plain text
#: build/C/man2/madvise.2:379
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<core>(5)"
msgstr ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<core>(5)"

#. type: TH
#: build/C/man3/mallinfo.3:26
#, no-wrap
msgid "MALLINFO"
msgstr "MALLINFO"

#. type: TH
#: build/C/man3/mallinfo.3:26 build/C/man3/malloc_stats.3:26
#, no-wrap
msgid "2012-05-06"
msgstr "2012-05-06"

#. type: Plain text
#: build/C/man3/mallinfo.3:29
msgid "mallinfo - obtain memory allocation information"
msgstr "mallinfo - メモリ割り当て情報を取得する"

#. type: Plain text
#: build/C/man3/mallinfo.3:31 build/C/man3/malloc_stats.3:31
#: build/C/man3/malloc_trim.3:31 build/C/man3/malloc_usable_size.3:30
#: build/C/man3/mallopt.3:31
msgid "B<#include E<lt>malloc.hE<gt>>"
msgstr "B<#include E<lt>malloc.hE<gt>>"

#. type: Plain text
#: build/C/man3/mallinfo.3:33
msgid "B<struct mallinfo mallinfo(void);>"
msgstr "B<struct mallinfo mallinfo(void);>"

#. type: Plain text
#: build/C/man3/mallinfo.3:41
msgid ""
"The B<mallinfo>()  function returns a copy of a structure containing "
"information about memory allocations performed by B<malloc>(3)  and related "
"functions.  This structure is defined as follows:"
msgstr ""
"B<mallinfo>() 関数は、 B<malloc>(3) や一連の関数により実行されたメモリ\n"
"割り当てに関する情報を格納した構造体のコピーを返す。\n"
"この構造体は以下のように定義されている。"

#. type: Plain text
#: build/C/man3/mallinfo.3:56
#, no-wrap
msgid ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* Maximum total allocated space (bytes) */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"
msgstr ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* Maximum total allocated space (bytes) */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:62
msgid ""
"The fields of the I<mallinfo> structure contain the following information:"
msgstr "I<mallinfo> 構造体の各フィールドには以下の情報が格納される。"

#. type: TP
#: build/C/man3/mallinfo.3:62
#, no-wrap
msgid "I<arena>"
msgstr "I<arena>"

#. type: Plain text
#: build/C/man3/mallinfo.3:68
msgid ""
"The total amount of memory allocated by means other than B<mmap>(2)  (i.e., "
"memory allocated on the heap).  This figure includes both in-use blocks and "
"blocks on the free list."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:68
#, no-wrap
msgid "I<ordblks>"
msgstr "I<ordblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:71
msgid "The number of ordinary (i.e., non-fastbin) free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:71
#, no-wrap
msgid "I<smblks>"
msgstr "I<smblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:75
msgid "The number of fastbin free blocks (see B<mallopt>(3))."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:75
#, no-wrap
msgid "I<hblks>"
msgstr "I<hblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:83
msgid ""
"The number of blocks currently allocated using B<mmap>(2).  (See the "
"discussion of B<M_MMAP_THRESHOLD> in B<mallopt>(3).)"
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:83
#, no-wrap
msgid "I<hblkhd>"
msgstr "I<hblkhd>"

#. type: Plain text
#: build/C/man3/mallinfo.3:87
msgid "The number of bytes in blocks currently allocated using B<mmap>(2)."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:87
#, no-wrap
msgid "I<usmblks>"
msgstr "I<usmblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:92
msgid ""
"The \"highwater mark\" for allocated space\\(emthat is, the maximum amount "
"of space that was ever allocated.  This field is maintained only in "
"nonthreading environments."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:92
#, no-wrap
msgid "I<fsmblks>"
msgstr "I<fsmblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:95
msgid "The total number of bytes in fastbin free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:95
#, no-wrap
msgid "I<uordblks>"
msgstr "I<uordblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:98
msgid "The total number of bytes used by in-use allocations."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:98
#, no-wrap
msgid "I<fordblks>"
msgstr "I<fordblks>"

#. type: Plain text
#: build/C/man3/mallinfo.3:101
msgid "The total number of bytes in free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:101
#, no-wrap
msgid "I<keepcost>"
msgstr "I<keepcost>"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallinfo.3:110
msgid ""
"The total amount of releasable free space at the top of the heap.  This is "
"the maximum number of bytes that could ideally (i.e., ignoring page "
"alignment restrictions, and so on) be released by B<malloc_trim>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:114
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, and was specified in the SVID."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=208
#.  See the 24 Aug 2011 mail by Paul Pluzhnikov:
#.      "[patch] Fix mallinfo() to accumulate results for all arenas"
#.  on libc-alpha@sourceware.org
#. type: Plain text
#: build/C/man3/mallinfo.3:126
msgid ""
"B<Information is returned for only the main memory allocation area.> "
"Allocations in other arenas are excluded.  See B<malloc_stats>(3)  and "
"B<malloc_info>(3)  for alternatives that include information about other "
"arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:134
msgid ""
"The fields of the I<mallinfo> structure are typed as I<int>.  However, "
"because some internal bookkeeping values may be of type I<long>, the "
"reported values may wrap around zero and thus be inaccurate."
msgstr ""

#. type: SH
#: build/C/man3/mallinfo.3:134 build/C/man3/malloc_hook.3:89
#: build/C/man3/malloc_info.3:82 build/C/man3/mallopt.3:466
#: build/C/man3/mcheck.3:159 build/C/man2/mmap.2:630
#: build/C/man2/mprotect.2:148 build/C/man3/mtrace.3:108
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/mallinfo.3:140
msgid ""
"The program below employs B<mallinfo>()  to retrieve memory allocation "
"statistics before and after allocating and freeing some blocks of memory.  "
"The statistics are displayed on standard output."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:144
msgid ""
"The first two command-line arguments specify the number and size of blocks "
"to be allocated with B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:158
msgid ""
"The remaining three arguments specify which of the allocated blocks should "
"be freed with B<free>(3).  These three arguments are optional, and specify "
"(in order): the step size to be used in the loop that frees blocks (the "
"default is 1, meaning free all blocks in the range); the ordinal position of "
"the first block to be freed (default 0, meaning the first allocated block); "
"and a number one greater than the ordinal position of the last block to be "
"freed (default is one greater than the maximum block number).  If these "
"three arguments are omitted, then the defaults cause all allocated blocks to "
"be freed."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:162
msgid ""
"In the following example run of the program, 1000 allocations of 100 bytes "
"are performed, and then every second allocated block is freed:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:177
#, no-wrap
msgid ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"
msgstr ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:189
#, no-wrap
msgid ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:201
#, no-wrap
msgid ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"

#. type: SS
#: build/C/man3/mallinfo.3:203 build/C/man3/malloc_info.3:165
#: build/C/man3/mallopt.3:532 build/C/man3/mcheck.3:176
#: build/C/man2/mprotect.2:165
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/mallinfo.3:208
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include \"tlpi_hdr.h\"\n"
msgstr ""
"#include E<lt>malloc.hE<gt>\n"
"#include \"tlpi_hdr.h\"\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:213
#, no-wrap
msgid ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"
msgstr ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:215
#, no-wrap
msgid "    mi = mallinfo();\n"
msgstr "    mi = mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:227
#, no-wrap
msgid ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", mi.keepcost);\n"
"}\n"
msgstr ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", mi.keepcost);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:235
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, j, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, j, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:239
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0)\n"
"        usageErr(\"%s num-blocks block-size [free-step [start-free \"\n"
"                \"[end-free]]]\\en\", argv[0]);\n"
msgstr ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0)\n"
"        usageErr(\"%s num-blocks block-size [free-step [start-free \"\n"
"                \"[end-free]]]\\en\", argv[0]);\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:245
#, no-wrap
msgid ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"
msgstr ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:248
#, no-wrap
msgid ""
"    printf(\"============== Before allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""
"    printf(\"============== Before allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:252
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS)\n"
"            fatal(\"Too many allocations\");\n"
msgstr ""
"    for (j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS)\n"
"            fatal(\"Too many allocations\");\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:257
#, no-wrap
msgid ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL)\n"
"            errExit(\"malloc\");\n"
"    }\n"
msgstr ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL)\n"
"            errExit(\"malloc\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:260
#, no-wrap
msgid ""
"    printf(\"\\en============== After allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""
"    printf(\"\\en============== After allocating blocks ==============\\en\");\n"
"    display_mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:263
#, no-wrap
msgid ""
"    for (j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"
msgstr ""
"    for (j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:266
#, no-wrap
msgid ""
"    printf(\"\\en============== After freeing blocks ==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""
"    printf(\"\\en============== After freeing blocks ==============\\en\");\n"
"    display_mallinfo();\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:269 build/C/man3/malloc_info.3:253
#: build/C/man3/mallopt.3:565 build/C/man3/mcheck.3:203
#: build/C/man2/mmap.2:711
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mallinfo.3:279
msgid ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"
msgstr ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_get_state.3:25
#, no-wrap
msgid "MALLOC_GET_STATE"
msgstr "MALLOC_GET_STATE"

#. type: TH
#: build/C/man3/malloc_get_state.3:25
#, no-wrap
msgid "2012-05-04"
msgstr "2012-05-04"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:28
msgid ""
"malloc_get_state, malloc_set_state - record and restore state of malloc "
"implementation"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:31 build/C/man3/posix_memalign.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr "B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:33
#, no-wrap
msgid "B<void* malloc_get_state(void);>\n"
msgstr "B<void* malloc_get_state(void);>\n"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:35
#, no-wrap
msgid "B<int malloc_set_state(void *>I<state>B<);>\n"
msgstr "B<int malloc_set_state(void *>I<state>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:53
msgid ""
"The B<malloc_get_state>()  function records the current state of all "
"B<malloc>(3)  internal bookkeeping variables (but not the actual contents of "
"the heap or the state of B<malloc_hook>(3)  functions pointers).  The state "
"is recorded in a system-dependent opaque data structure dynamically "
"allocated via B<malloc>(3), and a pointer to that data structure is returned "
"as the function result.  (It is the caller's responsibility to B<free>(3)  "
"this memory.)"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:61
msgid ""
"The B<malloc_set_state>()  function restores the state of all B<malloc>(3)  "
"internal bookkeeping variables to the values recorded in the opaque data "
"structure pointed to by I<state>."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:68
msgid ""
"On success, B<malloc_get_state>()  returns a pointer to a newly allocated "
"opaque data structure.  On error (for example, memory could not be allocated "
"for the data structure), B<malloc_get_state>()  returns NULL."
msgstr ""

#.  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
#.  /* Must fail if the major version is too high. */
#.  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
#. type: Plain text
#: build/C/man3/malloc_get_state.3:86
msgid ""
"On success, B<malloc_set_state>()  returns 0.  If the implementation detects "
"that I<state> does not point to a correctly formed data structure, "
"B<malloc_set_state>()  returns -1.  If the implementation detects that the "
"version of the data structure referred to by I<state> is a more recent "
"version than this implementation knows about, B<malloc_set_state>()  returns "
"-2."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:88 build/C/man3/malloc_hook.3:82
#: build/C/man3/mcheck.3:147 build/C/man3/mtrace.3:80
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/malloc_get_state.3:94
msgid ""
"These functions are especially useful when using this B<malloc>(3)  "
"implementation as part of a shared library, and the heap contents are saved/"
"restored via some other method.  This technique is used by the GNU Emacs to "
"implement its \"dumping\" function."
msgstr ""

#.  i.e., calls __malloc_check_init()
#.  i.e., malloc checking is not already in use
#.  and the caller requested malloc checking
#. type: Plain text
#: build/C/man3/malloc_get_state.3:111
msgid ""
"Hook function pointers are never saved or restored by these functions, with "
"two exceptions: if malloc checking (see B<mallopt>(3))  was in use when "
"B<malloc_get_state>()  was called, then B<malloc_set_state>()  resets malloc "
"checking hooks if possible; if malloc checking was not in use in the "
"recorded state, but the caller has requested malloc checking, then the hooks "
"are reset to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:114
msgid "B<malloc>(3), B<mallopt>(3)"
msgstr "B<malloc>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_hook.3:10
#, no-wrap
msgid "MALLOC_HOOK"
msgstr "MALLOC_HOOK"

#. type: TH
#: build/C/man3/malloc_hook.3:10
#, no-wrap
msgid "2010-10-13"
msgstr "2010-10-13"

#. type: Plain text
#: build/C/man3/malloc_hook.3:15
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc デバッグ用の変数"

#. type: Plain text
#: build/C/man3/malloc_hook.3:18 build/C/man3/malloc_info.3:31
#: build/C/man3/posix_memalign.3:41
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr "B<#include E<lt>malloc.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:20
#, no-wrap
msgid "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:23
#, no-wrap
msgid "B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr "B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:26
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:30
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr "B<void (*__malloc_initialize_hook)(void);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:32
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr "B<void (*__after_morecore_hook)(void);>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:43
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), B<realloc>"
"(3), and B<free>(3)  by specifying appropriate hook functions.  You can use "
"these hooks to help you debug programs that use dynamic memory allocation, "
"for example."
msgstr ""
"GNU C ライブラリでは、適切なフック関数 (hook function) を指定することで "
"B<malloc>(3), B<realloc>(3), B<free>(3)  の動作を変更することができる。例え"
"ば、動的にメモリ割り当てを行う プログラムのデバッグにこれらのフックを使うこと"
"ができる。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:50
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called "
"once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr ""
"変数 B<__malloc_initialize_hook> は malloc の実装が初期化される際に一度だけ呼"
"ばれる関数へのポインタである。 この変数は書き換え可能 (weak) であり、アプリ"
"ケーション内で 以下のような定義で上書きできる:"

#. type: Plain text
#: build/C/man3/malloc_hook.3:53
#, no-wrap
msgid "    void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr "    void (*__malloc_initialize_hook)(void) = my_init_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:58
msgid ""
"Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr ""
"なお、関数 I<my_init_hook>()  で全てのフックの初期化をすることができる。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:74
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr ""
"B<__malloc_hook>, B<__realloc_hook>, B<__memalign_hook>, B<__free_hook> で指"
"される 4 つの関数は、各々 B<malloc>(3), B<realloc>(3), B<memalign>(3), "
"B<free>(3)  とよく似たプロトタイプを持っているが、 一番最後の引き数 "
"I<caller> をとる点が異なる。 引き数 I<caller> には、 B<malloc>(3)  などの呼び"
"出し元 (caller) のアドレスが格納される。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:80
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr ""
"変数 B<__after_morecore_hook> は、領域の追加要求があり B<sbrk>(2)  が呼ばれた"
"後で毎回呼び出される関数へのポインタである。"

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: build/C/man3/malloc_hook.3:89
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  Programmers should instead preempt calls to the "
"relevant functions by defining and exporting functions such as \"malloc\" "
"and \"free\"."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:91
msgid "Here is a short example of how to use these variables."
msgstr "これらの変数の使い方の簡単な例を以下に示す。"

#. type: Plain text
#: build/C/man3/malloc_hook.3:95
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:99
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr ""
"/* 使おうとするフックのプロトタイプ宣言 */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:102
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr ""
"/* 元々のフックを保存するための変数 */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:105
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr ""
"/* C ライブラリから呼ばれる初期化フックを上書きする */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:112
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:117
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:120
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr ""
"    /* 元々のフックを全て戻す */\n"
"    __malloc_hook = old_malloc_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:123
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr ""
"    /* malloc の再帰的呼び出し */\n"
"    result = malloc(size);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:126
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr ""
"    /* 現在設定されているフック (underlying hook) を保存する */\n"
"    old_malloc_hook = __malloc_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:130
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%u) called from %p returns %p\\en\",\n"
"            (unsigned int) size, caller, result);\n"
msgstr ""
"    /* printf() は malloc() を呼び出す可能性があるので\n"
"        ここでもガードを行う (元々のフックのままにしておく) */\n"
"    printf(\"malloc(%u) called from %p returns %p\\en\",\n"
"            (unsigned int) size, caller, result);\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:133
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr ""
"    /* ユーザが使おうとするフックを再設定する */\n"
"    __malloc_hook = my_malloc_hook;\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:136
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr ""
"    return result;\n"
"}\n"

#. type: Plain text
#: build/C/man3/malloc_hook.3:142
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"

#. type: TH
#: build/C/man3/malloc_info.3:25
#, no-wrap
msgid "MALLOC_INFO"
msgstr "MALLOC_INFO"

#. type: Plain text
#: build/C/man3/malloc_info.3:28
msgid "malloc_info - export malloc state to a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:33
#, no-wrap
msgid "B<int malloc_info(int >I<options>B<, FILE *>I<fp>B<);>\n"
msgstr "B<int malloc_info(int >I<options>B<, FILE *>I<fp>B<);>\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:44
msgid ""
"The B<malloc_info>()  function exports an XML string that describes the "
"current state of the memory-allocation implementation in the caller.  The "
"string is printed on the file stream I<fp>.  The exported string includes "
"information about all arenas (see B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:48
msgid "As currently implemented, I<options> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:53
msgid "On success, B<malloc_info>()  returns 0; on error, it returns -1."
msgstr "B<malloc_info>() は成功すると 0 を返す。エラーの場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/malloc_info.3:58
msgid "I<options> was nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:61
#, fuzzy
#| msgid "B<malloc_info>(3)  was added to glibc in version 2.10."
msgid "B<malloc_info>()  was added to glibc in version 2.10."
msgstr "B<malloc_info>(3) は glibc バージョン 2.10 で追加された。"

#. type: Plain text
#: build/C/man3/malloc_info.3:63 build/C/man3/malloc_stats.3:57
#: build/C/man3/malloc_trim.3:62 build/C/man3/malloc_usable_size.3:50
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/malloc_info.3:69
msgid ""
"The memory-allocation information is provided as an XML string (rather than "
"a C structure)  because the information may change over time (according to "
"changes in the underlying implementation).  The output XML string includes a "
"version field."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:75
msgid ""
"The B<open_memstream>(3)  function can be used to send the output of "
"B<malloc_info>()  directly into a buffer in memory, rather than to a file."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:82
msgid ""
"The B<malloc_info>()  function is designed to address deficiencies in "
"B<malloc_stats>(3)  and B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:93
msgid ""
"The program below takes up to four command-line arguments, of which the "
"first three are mandatory.  The first argument specifies the number of "
"threads that the program should create.  All of the threads, including the "
"main thread, allocate the number of blocks of memory specified by the second "
"argument.  The third argument controls the size of the blocks to be "
"allocated.  The main thread creates blocks of this size, the second thread "
"created by the program allocates blocks of twice this size, the third thread "
"allocates blocks of three times this size, and so on."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:100
msgid ""
"The program calls B<malloc_info>()  twice to display the memory-allocation "
"state.  The first call takes place before any threads are created or memory "
"allocated.  The second call is performed after all threads have allocated "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:108
msgid ""
"In the following example, the command-line arguments specify the creation of "
"one additional thread, and both the main thread and the additional thread "
"allocate 10000 blocks of memory.  After the blocks of memory have been "
"allocated, B<malloc_info>()  shows the state of two allocation arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:133
#, no-wrap
msgid ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:163
#, no-wrap
msgid ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:173
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:176
#, no-wrap
msgid ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:179
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:185
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int j;\n"
"    int tn = (int) arg;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:188
#, no-wrap
msgid ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread (including\n"
"       the main thread) allocates a different amount of memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:192
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"
msgstr ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:196
#, no-wrap
msgid ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:202
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, tn, sleepTime;\n"
"    pthread_t *thr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, tn, sleepTime;\n"
"    pthread_t *thr;\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:209
#, no-wrap
msgid ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:214
#, no-wrap
msgid ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:218
#, no-wrap
msgid ""
"    thr = calloc(numThreads, sizeof(pthread_t));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:221
#, no-wrap
msgid ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:223
#, no-wrap
msgid "    /* Create threads that allocate different amounts of memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:229
#, no-wrap
msgid ""
"    for (tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:234
#, no-wrap
msgid ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:238
#, no-wrap
msgid ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:240
#, no-wrap
msgid "    /* The main thread also allocates some memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:244
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"

#. type: Plain text
#: build/C/man3/malloc_info.3:247
#, no-wrap
msgid ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:250
#, no-wrap
msgid ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:260
msgid ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"
msgstr ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"

#. type: TH
#: build/C/man3/malloc_stats.3:26
#, no-wrap
msgid "MALLOC_STATS"
msgstr "MALLOC_STATS"

#. type: Plain text
#: build/C/man3/malloc_stats.3:29
msgid "malloc_stats - print memory allocation statistics"
msgstr "malloc_stats - メモリ割り当ての統計を表示する"

#. type: Plain text
#: build/C/man3/malloc_stats.3:33
msgid "B<void malloc_stats(void);>"
msgstr "B<void malloc_stats(void);>"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_stats.3:55
msgid ""
"The B<malloc_stats>()  function prints (on standard error) statistics about "
"memory allocated by B<malloc>(3)  and related functions.  For each arena "
"(allocation area), this function prints the total amount of memory allocated "
"and the total number of bytes consumed by in-use allocations.  (These two "
"values correspond to the I<arena> and I<uordblks> fields retrieved by "
"B<mallinfo>(3).)  In addition, the function prints the sum of these two "
"statistics for all arenas, and the maximum number of blocks and bytes that "
"were ever simultaneously allocated using B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:61
msgid ""
"More detailed information about memory allocations in the main arena can be "
"obtained using B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:67
msgid ""
"B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"
msgstr ""
"B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_trim.3:26
#, no-wrap
msgid "MALLOC_TRIM"
msgstr "MALLOC_TRIM"

#. type: TH
#: build/C/man3/malloc_trim.3:26 build/C/man3/malloc_usable_size.3:25
#, no-wrap
msgid "2012-03-29"
msgstr "2012-03-29"

#. type: Plain text
#: build/C/man3/malloc_trim.3:29
msgid "malloc_trim - release free memory from the top of the heap"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:33
msgid "B<void malloc_trim(size_t >I<pad>B<);>"
msgstr "B<void malloc_trim(size_t >I<pad>B<);>"

#. type: Plain text
#: build/C/man3/malloc_trim.3:40
msgid ""
"The B<malloc_trim>()  function attempts to release free memory at the top of "
"the heap (by calling B<sbrk>(2)  with a suitable argument)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:51
msgid ""
"The I<pad> argument specifies the amount of free space to leave untrimmed at "
"the top of the heap.  If this argument is 0, only the minimum amount of "
"memory is maintained at the top of the heap (i.e., one page or less).  A "
"nonzero argument can be used to maintain some trailing space at the top of "
"the heap in order to allow future allocations to be made without having to "
"extend the heap with B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:56
msgid ""
"The B<malloc_trim>()  function returns 1 if memory was actually released "
"back to the system, or 0 if it was not possible to release any memory."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_trim.3:60
msgid "No errors are defined."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:71
msgid ""
"This function is automatically called by B<free>(3)  in certain "
"circumstances; see the discussion of B<M_TOP_PAD> and B<M_TRIM_THRESHOLD> in "
"B<mallopt>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:74
msgid ""
"This function cannot release free memory located at places other than the "
"top of the heap."
msgstr ""

#.  malloc/malloc.c::mTRIm():
#.      return result | (av == &main_arena ? sYSTRIm (pad, av) : 0);
#. type: Plain text
#: build/C/man3/malloc_trim.3:78
msgid "This function releases only memory in the main arena."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:82
msgid "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"
msgstr "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"

#. type: TH
#: build/C/man3/malloc_usable_size.3:25
#, no-wrap
msgid "MALLOC_USABLE_SIZE"
msgstr "MALLOC_USABLE_SIZE"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:28
msgid "malloc_usable_size - obtain size of block of memory allocated from heap"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:32
msgid "B<size_t malloc_usable_size (void *>I<ptr>B<);>"
msgstr "B<size_t malloc_usable_size (void *>I<ptr>B<);>"

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:40
msgid ""
"The B<malloc_usable_size>()  function returns the number of usable bytes in "
"the block pointed to by I<ptr>, a pointer to a block of memory allocated by "
"B<malloc>(3)  or a related function."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:48
msgid ""
"B<malloc_usable_size>()  returns the number of usable bytes in the block of "
"allocated memory pointed to by I<ptr>.  If I<ptr> is NULL, 0 is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:60
msgid ""
"The value returned by B<malloc_usable_size>()  may be greater than the "
"requested size of the allocation because of alignment and minimum size "
"constraints.  Although the excess bytes can be overwritten by the "
"application without ill effects, this is not good programming practice: the "
"number of excess bytes in an allocation depends on the underlying "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:62
msgid "The main use of this function is for debugging and introspection."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:64
msgid "B<malloc>(3)"
msgstr "B<malloc>(3)"

#. type: TH
#: build/C/man3/mallopt.3:26
#, no-wrap
msgid "MALLOPT"
msgstr "MALLOPT"

#. type: TH
#: build/C/man3/mallopt.3:26
#, no-wrap
msgid "2012-04-30"
msgstr "2012-04-30"

#. type: Plain text
#: build/C/man3/mallopt.3:29
msgid "mallopt - set memory allocation parameters"
msgstr "mallopt - メモリ割り当てパラメータを設定する"

#. type: Plain text
#: build/C/man3/mallopt.3:33
msgid "B<int mallopt(int >I<param>B<, int >I<value>B<);>"
msgstr "B<int mallopt(int >I<param>B<, int >I<value>B<);>"

#. type: Plain text
#: build/C/man3/mallopt.3:44
msgid ""
"The B<mallopt>()  function adjusts parameters that control the behavior of "
"the memory-allocation functions (see B<malloc>(3)).  The I<param> argument "
"specifies the parameter to be modified, and I<value> specifies the new value "
"for that parameter."
msgstr ""
"B<mallopt>() 関数は、メモリ割り当て関数 (B<malloc>(3) を参照) の動作を\n"
"制御するパラメータの調整を行う。\n"
"I<param> 引き数で変更するパラメータを指定し、\n"
"I<value> 引き数でそのパラメータの新しい値を指定する。"

#. type: Plain text
#: build/C/man3/mallopt.3:47
msgid "The following values can be specified for I<param>:"
msgstr "I<param> には以下の値を指定することができる。"

#. type: TP
#: build/C/man3/mallopt.3:47
#, no-wrap
msgid "B<M_CHECK_ACTION>"
msgstr "B<M_CHECK_ACTION>"

#. type: Plain text
#: build/C/man3/mallopt.3:53
msgid ""
"Setting this parameter controls how glibc responds when various kinds of "
"programming errors are detected (e.g., freeing the same pointer twice).  The "
"3 least significant bits (2, 1, and 0) of the value assigned to this "
"parameter determine the glibc behavior, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:54
#, no-wrap
msgid "Bit 0"
msgstr "Bit 0"

#. type: Plain text
#: build/C/man3/mallopt.3:64
msgid ""
"If this bit is set, then print a one-line message on I<stderr> that provides "
"details about the error.  The message starts with the string \"***\\ glibc "
"detected\\ ***\", followed by the program name, the name of the memory-"
"allocation function in which the error was detected, a brief description of "
"the error, and the memory address where the error was detected."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:64
#, no-wrap
msgid "Bit 1"
msgstr "Bit 1"

#. type: Plain text
#: build/C/man3/mallopt.3:79
msgid ""
"If this bit is set, then, after printing any error message specified by bit "
"0, the program is terminated by calling B<abort>(3).  In glibc versions "
"since 2.4, if bit 0 is also set, then, between printing the error message "
"and aborting, the program also prints a stack trace in the manner of "
"B<backtrace>(3), and prints the process's memory mapping in the style of I</"
"proc/[pid]/maps> (see B<proc>(5))."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:79
#, no-wrap
msgid "Bit 2 (since glibc 2.4)"
msgstr "Bit 2 (glibc 2.4 以降)"

#. type: Plain text
#: build/C/man3/mallopt.3:86
msgid ""
"This bit has an effect only if bit 0 is also set.  If this bit is set, then "
"the one-line message describing the error is simplified to contain just the "
"name of the function where the error was detected and the brief description "
"of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:91
msgid "The remaining bits in I<value> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:95
msgid ""
"Combining the above details, the following numeric values are meaningful for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:96
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man3/mallopt.3:98
msgid "Ignore error conditions; continue execution (with undefined results)."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:98
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man3/mallopt.3:100
msgid "Print a detailed error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:100
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man3/mallopt.3:102
msgid "Abort the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:102
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: build/C/man3/mallopt.3:105
msgid ""
"Print detailed error message, stack trace, and memory mappings, and abort "
"the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:105
#, no-wrap
msgid "5"
msgstr "5"

#. type: Plain text
#: build/C/man3/mallopt.3:107
msgid "Print a simple error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:107
#, no-wrap
msgid "7"
msgstr "7"

#. type: Plain text
#: build/C/man3/mallopt.3:110
msgid ""
"Print simple error message, stack trace, and memory mappings, and abort the "
"program."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:116
msgid ""
"Since glibc 2.3.4, the default value for the B<M_CHECK_ACTION> parameter is "
"3.  In glibc version 2.3.3 and earlier, the default value is 1."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:121
msgid ""
"Using a nonzero B<M_CHECK_ACTION> value can be useful because otherwise a "
"crash may happen much later, and the true cause of the problem is then very "
"hard to track down."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:121
#, no-wrap
msgid "B<M_MMAP_MAX>"
msgstr "B<M_MMAP_MAX>"

#.  The following text adapted from comments in the glibc source:
#. type: Plain text
#: build/C/man3/mallopt.3:131
msgid ""
"This parameter specifies the maximum number of allocation requests that may "
"be simultaneously serviced using B<mmap>(2).  This parameter exists because "
"some systems have a limited number of internal tables for use by B<mmap>(2), "
"and using more than a few of them may degrade performance."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:138
msgid ""
"The default value is 65,536, a value which has no special significance and "
"which servers only as a safeguard.  Setting this parameter to 0 disables the "
"use of B<mmap>(2)  for servicing large allocation requests."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:138
#, no-wrap
msgid "B<M_MMAP_THRESHOLD>"
msgstr "B<M_MMAP_THRESHOLD>"

#. type: Plain text
#: build/C/man3/mallopt.3:147
msgid ""
"For allocations greater than or equal to the limit specified (in bytes) by "
"B<M_MMAP_THRESHOLD> that can't be satisfied from the free list, the memory-"
"allocation functions employ B<mmap>(2)  instead of increasing the program "
"break using B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:167
msgid ""
"Allocating memory using B<mmap>(2)  has the significant advantage that the "
"allocated memory blocks can always be independently released back to the "
"system.  (By contrast, the heap can be trimmed only if memory is freed at "
"the top end.)  On the other hand, there are some disadvantages to the use of "
"B<mmap>(2): deallocated space is not placed on the free list for reuse by "
"later allocations; memory may be wasted because B<mmap>(2)  allocations must "
"be page-aligned; and the kernel must perform the expensive task of zeroing "
"out memory allocated via B<mmap>(2).  Balancing these factors leads to a "
"default setting of 128*1024 for the B<M_MMAP_THRESHOLD> parameter."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:174
msgid ""
"The lower limit for this parameter is 0.  The upper limit is "
"B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 on 32-bit systems or "
"I<4*1024*1024*sizeof(long)> on 64-bit systems."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:192
msgid ""
"I<Note:> Nowadays, glibc uses a dynamic mmap threshold by default.  The "
"initial value of the threshold is 128*1024, but when blocks larger than the "
"current threshold and less than or equal to B<DEFAULT_MMAP_THRESHOLD_MAX> "
"are freed, the threshold is adjusted upwards to the size of the freed "
"block.  When dynamic mmap thresholding is in effect, the threshold for "
"trimming the heap is also dynamically adjusted to be twice the dynamic mmap "
"threshold.  Dynamic adjustment of the mmap threshold is disabled if any of "
"the B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD>, or B<M_MMAP_MAX> "
"parameters is set."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:192
#, no-wrap
msgid "B<M_MXFAST> (since glibc 2.3)"
msgstr "B<M_MXFAST> (glibc 2.3 以降)"

#.  The following text adapted from comments in the glibc sources:
#. type: Plain text
#: build/C/man3/mallopt.3:212
msgid ""
"Set the upper limit for memory allocation requests that are satisfied using "
"\"fastbins\".  (The measurement unit for this parameter is bytes.)  Fastbins "
"are storage areas that hold deallocated blocks of memory of the same size "
"without merging adjacent free blocks.  Subsequent reallocation of blocks of "
"the same size can be handled very quickly by allocating from the fastbin, "
"although memory fragmentation and the overall memory footprint of the "
"program can increase.  The default value for this parameter is I<64*sizeof"
"(size_t)/4> (i.e., 64 on 32-bit architectures).  The range for this "
"parameter is 0 to I<80*sizeof(size_t)/4>.  Setting B<M_MXFAST> to 0 disables "
"the use of fastbins."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:212
#, no-wrap
msgid "B<M_PERTURB> (since glibc 2.4)"
msgstr "B<M_PERTURB> (glibc 2.4 以降)"

#. type: Plain text
#: build/C/man3/mallopt.3:227
msgid ""
"If this parameter is set to a nonzero value, then bytes of allocated memory "
"(other than allocations via B<calloc>(3))  are initialized to the complement "
"of the value in the least significant byte of I<value>, and when allocated "
"memory is released using B<free>(3), the freed bytes are set to the least "
"significant byte of I<value>.  This can be useful for detecting errors where "
"programs incorrectly rely on allocated memory being initialized to zero, or "
"reuse values in memory that has already been freed."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:227
#, no-wrap
msgid "B<M_TOP_PAD>"
msgstr "B<M_TOP_PAD>"

#. type: Plain text
#: build/C/man3/mallopt.3:234
msgid ""
"This parameter defines the amount of padding to employ when calling B<sbrk>"
"(2)  to modify the program break.  (The measurement unit for this parameter "
"is bytes.)  This parameter has an effect in the following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:241
msgid ""
"When the program break is increased, then B<M_TOP_PAD> bytes are added to "
"the B<sbrk>(2)  request."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:247
msgid ""
"When the heap is trimmed as a consequence of calling B<free>(3)  (see the "
"discussion of B<M_TRIM_THRESHOLD>)  this much free space is preserved at the "
"top of the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:251
msgid ""
"In either case, the amount of padding is always rounded to a system page "
"boundary."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:258
msgid ""
"Modifying B<M_TOP_PAD> is a trade-off between increasing the number of "
"system calls (when the parameter is set low)  and wasting unused memory at "
"the top of the heap (when the parameter is set high)."
msgstr ""

#.  DEFAULT_TOP_PAD in glibc source
#. type: Plain text
#: build/C/man3/mallopt.3:261
msgid "The default value for this parameter is 128*1024."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:261
#, no-wrap
msgid "B<M_TRIM_THRESHOLD>"
msgstr "B<M_TRIM_THRESHOLD>"

#. type: Plain text
#: build/C/man3/mallopt.3:277
msgid ""
"When the amount of contiguous free memory at the top of the heap grows "
"sufficiently large, B<free>(3)  employs B<sbrk>(2)  to release this memory "
"back to the system.  (This can be useful in programs that continue to "
"execute for a long period after freeing a significant amount of memory.)  "
"The B<M_TRIM_THRESHOLD> parameter specifies the minimum size (in bytes) that "
"this block of memory must reach before B<sbrk>(2)  is used to trim the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:282
msgid ""
"The default value for this parameter is 128*1024.  Setting "
"B<M_TRIM_THRESHOLD> to -1 disables trimming completely."
msgstr ""

#
#
#
#.  FIXME Do the arena parameters need to be documented?
#.  .TP
#.  .BR M_ARENA_TEST " (since glibc 2.10)"
#.  .TP
#.  .BR M_ARENA_MAX " (since glibc 2.10)"
#.  Environment variables
#.      MALLOC_ARENA_MAX_
#.      MALLOC_ARENA_TEST_
#.  http://udrepper.livejournal.com/20948.html describes some details
#. 	of the MALLOC_ARENA_* environment variables.
#.  These macros aren't enabled in production releases until 2.15?
#.  (see glibc malloc/Makefile)
#. type: Plain text
#: build/C/man3/mallopt.3:305
msgid ""
"Modifying B<M_TRIM_THRESHOLD> is a trade-off between increasing the number "
"of system calls (when the parameter is set low)  and wasting unused memory "
"at the top of the heap (when the parameter is set high)."
msgstr ""

#. type: SS
#: build/C/man3/mallopt.3:305
#, fuzzy, no-wrap
#| msgid "Environment Variables"
msgid "Environment variables"
msgstr "環境変数"

#. type: Plain text
#: build/C/man3/mallopt.3:320
msgid ""
"A number of environment variables can be defined to modify some of the same "
"parameters as are controlled by B<mallopt>().  Using these variables has the "
"advantage that the source code of the program need not be changed.  To be "
"effective, these variables must be defined before the first call to a memory-"
"allocation function.  (If the same parameters are adjusted via B<mallopt>()  "
"then the B<mallopt>()  settings take precedence.)  For security reasons, "
"these variables are ignored in set-user-ID and set-group-ID programs."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:323
msgid ""
"The environment variables are as follows (note the trailing underscore at "
"the end of the name of each variable):"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:323
#, no-wrap
msgid "B<MALLOC_CHECK_>"
msgstr "B<MALLOC_CHECK_>"

#.  On glibc 2.12/x86, a simple malloc()+free() loop is about 70% slower
#.  when MALLOC_CHECK_ was set.
#. type: Plain text
#: build/C/man3/mallopt.3:340
msgid ""
"This environment variable controls the same parameter as B<mallopt>()  "
"B<M_CHECK_ACTION>.  If this variable is set to a nonzero value, then a "
"special implementation of the memory-allocation functions is used.  (This is "
"accomplished using the B<malloc_hook>(3)  feature.)  This implementation "
"performs additional error checking, but is slower than the standard set of "
"memory-allocation functions.  (This implementation does not detect all "
"possible errors; memory leaks can still occur.)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:345
msgid ""
"The value assigned to this environment variable should be a single digit, "
"whose meaning is as described for B<M_CHECK_ACTION>.  Any characters beyond "
"the initial digit are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:354
msgid ""
"For security reasons, the effect of B<MALLOC_CHECK_> is disabled by default "
"for set-user-ID and set-group-ID programs.  However, if the file I</etc/suid-"
"debug> exists (the content of the file is irrelevant), then B<MALLOC_CHECK_> "
"also has an effect for set-user-ID and set-group-ID programs."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:354
#, no-wrap
msgid "B<MALLOC_MMAP_MAX_>"
msgstr "B<MALLOC_MMAP_MAX_>"

#. type: Plain text
#: build/C/man3/mallopt.3:359
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:359
#, no-wrap
msgid "B<MALLOC_MMAP_THRESHOLD_>"
msgstr "B<MALLOC_MMAP_THRESHOLD_>"

#. type: Plain text
#: build/C/man3/mallopt.3:364
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:364
#, no-wrap
msgid "B<MALLOC_PERTURB_>"
msgstr "B<MALLOC_PERTURB_>"

#. type: Plain text
#: build/C/man3/mallopt.3:369
msgid "Controls the same parameter as B<mallopt>()  B<M_PERTURB>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:369
#, no-wrap
msgid "B<MALLOC_TRIM_THRESHOLD_>"
msgstr "B<MALLOC_TRIM_THRESHOLD_>"

#. type: Plain text
#: build/C/man3/mallopt.3:374
msgid "Controls the same parameter as B<mallopt>()  B<M_TRIM_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:374
#, no-wrap
msgid "B<MALLOC_TOP_PAD_>"
msgstr "B<MALLOC_TOP_PAD_>"

#. type: Plain text
#: build/C/man3/mallopt.3:379
msgid "Controls the same parameter as B<mallopt>()  B<M_TOP_PAD>."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:384
msgid "On success, B<mallopt>()  returns 1.  On error, it returns 0."
msgstr "B<mallopt>()  は成功すると 1 を返す。エラーの場合は 0 を返す。"

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallopt.3:392
msgid "On error, I<errno> is I<not> set."
msgstr "エラーの場合、I<errno> は設定I<されない>。"

#.  .SH NOTES
#. type: Plain text
#: build/C/man3/mallopt.3:406
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, but the range of values for "
"I<param> varies across systems.  The SVID defined options B<M_MXFAST>, "
"B<M_NLBLKS>, B<M_GRAIN>, and B<M_KEEP>, but only the first of these is "
"implemented in glibc."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:410
msgid "Specifying an invalid value for I<param> does not generate an error."
msgstr ""

#.  FIXME This looks buggy:
#.  setting the M_MXFAST limit rounds up:    (s + SIZE_SZ) & ~MALLOC_ALIGN_MASK)
#.  malloc requests are rounded up:
#.     (req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12129
#. type: Plain text
#: build/C/man3/mallopt.3:418
msgid ""
"A calculation error within the glibc implementation means that a call of the "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:421
#, no-wrap
msgid "    mallopt(M_MXFAST, n)\n"
msgstr "    mallopt(M_MXFAST, n)\n"

#.  Bins are multiples of 2 * sizeof(size_t) + sizeof(size_t)
#. type: Plain text
#: build/C/man3/mallopt.3:433
msgid ""
"does not result in fastbins being employed for all allocations of size up to "
"I<n>.  To ensure desired results, I<n> should be rounded up to the next "
"multiple greater than or equal to I<(2k+1)*sizeof(size_t)>, where I<k> is an "
"integer."
msgstr ""

#.  FIXME MALLOC_MMAP_THRESHOLD_ and MALLOC_MMAP_MAX_
#.  do have an effect for set-user-ID programs (but not
#.  set-group-ID programs).
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12155
#. type: Plain text
#: build/C/man3/mallopt.3:445
msgid ""
"The B<MALLOC_MMAP_THRESHOLD_> and B<MALLOC_MMAP_MAX_> variables are I<not> "
"ignored in set-group-ID programs."
msgstr ""

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12140
#. type: Plain text
#: build/C/man3/mallopt.3:466
msgid ""
"If B<mallopt>()  is used to set B<M_PERTURB>, then, as expected, the bytes "
"of allocated memory are initialized to the complement of the byte in "
"I<value>, and when that memory is freed, the bytes of the region are "
"initialized to the byte specified in I<value>.  However, there is an off-by-"
"I<sizeof(size_t)> error in the implementation: instead of initializing "
"precisely the block of memory being freed by the call I<free(p)>, the block "
"starting at I<p+sizeof(size_t)> is initialized."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:475
msgid ""
"The program below demonstrates the use of B<M_CHECK_ACTION>.  If the program "
"is supplied with an (integer) command-line argument, then that argument is "
"used to set the B<M_CHECK_ACTION> parameter.  The program then allocates a "
"block of memory, and frees it twice (an error)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:479
msgid ""
"The following shell session shows what happens when we run this program "
"under glibc, with the default value for B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:499
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"
msgstr ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 ***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"

#. type: Plain text
#: build/C/man3/mallopt.3:504
msgid ""
"The following runs show the results when employing other values for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:517
#, no-wrap
msgid ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"
msgstr ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 ***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"

#. type: Plain text
#: build/C/man3/mallopt.3:523
msgid ""
"The next run shows how to set the same parameter using the B<MALLOC_CHECK_> "
"environment variable:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:530
#, no-wrap
msgid ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"
msgstr ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"

#. type: Plain text
#: build/C/man3/mallopt.3:538
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mallopt.3:543 build/C/man3/mcheck.3:187
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"

#. type: Plain text
#: build/C/man3/mallopt.3:550
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallopt.3:556
#, no-wrap
msgid ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mallopt.3:559
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"
msgstr ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"

#. type: Plain text
#: build/C/man3/mallopt.3:562
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"
msgstr ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"

#. type: Plain text
#: build/C/man3/mallopt.3:580
#, fuzzy
#| msgid ""
#| "B<mmap>(2)  B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
#| "B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
#| "B<mtrace>(3), B<posix_memalign>(3)"
msgid ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"
msgstr ""
"B<mmap>(2)  B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"

#. type: TH
#: build/C/man3/mcheck.3:25
#, no-wrap
msgid "MCHECK"
msgstr ""

#. type: TH
#: build/C/man3/mcheck.3:25 build/C/man3/mtrace.3:25
#, no-wrap
msgid "2012-04-18"
msgstr "2012-04-18"

#. type: Plain text
#: build/C/man3/mcheck.3:28
msgid ""
"mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency checking"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:31
#, no-wrap
msgid "B<#include E<lt>mcheck.hE<gt>>\n"
msgstr "B<#include E<lt>mcheck.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:33
#, no-wrap
msgid "B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:35
#, no-wrap
msgid "B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:37
#, no-wrap
msgid "B<void mcheck_check_all(void);>\n"
msgstr "B<void mcheck_check_all(void);>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:39
#, no-wrap
msgid "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"
msgstr "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:51
msgid ""
"The B<mcheck>()  function installs a set of debugging hooks for the B<malloc>"
"(3)  family of memory-allocation functions.  These hooks cause certain "
"consistency checks to be performed on the state of the heap.  The checks can "
"detect application errors such as freeing a block of memory more than once "
"or corrupting the bookkeeping data structures that immediately precede a "
"block of allocated memory."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:63
msgid ""
"To be effective, the B<mcheck>()  function must be called before the first "
"call to B<malloc>(3)  or a related function.  In cases where this is "
"difficult to ensure, linking the program with I<-mcheck> inserts an implicit "
"call to B<mcheck>()  (with a NULL argument)  before the first call to a "
"memory-allocation function."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:71
msgid ""
"The B<mcheck_pedantic>()  function is similar to B<mcheck>(), but performs "
"checks on all allocated blocks whenever one of the memory-allocation "
"functions is called.  This can be very slow!"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:78
msgid ""
"The B<mcheck_check_all>()  function causes an immediate check on all "
"allocated blocks.  This call is only effective if B<mcheck>()  is called "
"beforehand."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:91
msgid ""
"If the system detects an inconsistency in the heap, the caller-supplied "
"function pointed to by I<abortfunc> is invoked with a single argument "
"argument, I<mstatus>, that indicates what type of inconsistency was "
"detected.  If I<abortfunc> is NULL, a default function prints an error "
"message on I<stderr> and calls B<abort>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:103
msgid ""
"The B<mprobe>()  function performs a consistency check on the block of "
"allocated memory pointed to by I<ptr>.  The B<mcheck>()  function should be "
"called beforehand (otherwise B<mprobe>()  returns B<MCHECK_DISABLED>)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:111
msgid ""
"The following list describes the values returned by B<mprobe>()  or passed "
"as the I<mstatus> argument when I<abortfunc> is invoked:"
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:111
#, no-wrap
msgid "B<MCHECK_DISABLED> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:116
msgid ""
"B<mcheck>()  was not called before the first memory allocation function was "
"called.  Consistency checking is not possible."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:116
#, no-wrap
msgid "B<MCHECK_OK> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:119
msgid "No inconsistency detected."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:119
#, no-wrap
msgid "B<MCHECK_HEAD>"
msgstr "B<MCHECK_HEAD>"

#. type: Plain text
#: build/C/man3/mcheck.3:122
msgid "Memory preceding an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:122
#, no-wrap
msgid "B<MCHECK_TAIL>"
msgstr "B<MCHECK_TAIL>"

#. type: Plain text
#: build/C/man3/mcheck.3:125
msgid "Memory following an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:125
#, no-wrap
msgid "B<MCHECK_FREE>"
msgstr "B<MCHECK_FREE>"

#. type: Plain text
#: build/C/man3/mcheck.3:129
msgid "A block of memory was freed twice."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:134
msgid ""
"B<mcheck>()  and B<mcheck_pedantic>()  return 0 on success, or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:145
msgid ""
"The B<mcheck_pedantic>()  and B<mcheck_check_all>()  functions are available "
"since glibc 2.2.  The B<mcheck>()  and B<mprobe>()  functions are present "
"since at least glibc 2.0"
msgstr ""

#.  But is MALLOC_CHECK_ slower?
#. type: Plain text
#: build/C/man3/mcheck.3:159
msgid ""
"Linking a program with I<-lmcheck> and using the B<MALLOC_CHECK_> "
"environment variable (described in B<mallopt>(3))  cause the same kinds of "
"errors to be detected.  But, using B<MALLOC_CHECK_> does not require the "
"application to be relinked."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:165
msgid ""
"The program below calls B<mcheck>()  with a NULL argument and then frees the "
"same block of memory twice.  The following shell session demonstrates what "
"happens when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:170
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"About to free\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:174
#, no-wrap
msgid ""
"About to free a second time\n"
"block freed twice\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:182
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mcheck.3:190
#, no-wrap
msgid ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:193
#, no-wrap
msgid ""
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mcheck.3:195
#, no-wrap
msgid "    p = malloc(1000);\n"
msgstr "    p = malloc(1000);\n"

#. type: Plain text
#: build/C/man3/mcheck.3:200
#, no-wrap
msgid ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:208
msgid "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"
msgstr "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"

#. type: TH
#: build/C/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr "MLOCK"

#. type: TH
#: build/C/man2/mlock.2:26
#, no-wrap
msgid "2011-09-14"
msgstr "2011-09-14"

#. type: Plain text
#: build/C/man2/mlock.2:29
msgid "mlock, munlock, mlockall, munlockall - lock and unlock memory"
msgstr "mlock - メモリのロックとロック解除を行う"

#. type: Plain text
#: build/C/man2/mlock.2:32 build/C/man2/mmap.2:46 build/C/man2/mmap2.2:35
#: build/C/man2/mprotect.2:44 build/C/man2/mremap.2:38
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr "B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mlock.2:35
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man2/mlock.2:38
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"

#. type: Plain text
#: build/C/man2/mlock.2:54
msgid ""
"B<mlock>()  and B<mlockall>()  respectively lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area.  B<munlock>()  and B<munlockall>()  perform the "
"converse operation, respectively unlocking part or all of the calling "
"process's virtual address space, so that pages in the specified virtual "
"address range may once more to be swapped out if required by the kernel "
"memory manager.  Memory locking and unlocking are performed in units of "
"whole pages."
msgstr ""
"B<mlock>()  と B<mlockall>()  はそれぞれ、呼び出し元プロセスの仮想アドレス空"
"間の一部または全部を RAM 上にロックし、メモリがスワップエリアにページングされ"
"るのを防ぐ。 B<munlock>()  と B<munlockall>()  は逆の操作で、それぞれ呼び出し"
"元プロセスの仮想アドレス空間の一部または全部を ロック解除する。つまり、指定さ"
"れた仮想アドレス範囲のページは カーネルメモリマネージャーから要求されればス"
"ワップアウトするようになる。 メモリのロックとロック解除はページ単位で行われ"
"る。"

#. type: SS
#: build/C/man2/mlock.2:54
#, no-wrap
msgid "mlock() and munlock()"
msgstr "mlock() と munlock()"

#. type: Plain text
#: build/C/man2/mlock.2:64
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""
"B<mlock>()  は I<addr> から始まる長さ I<len> バイトのアドレス範囲のページを"
"ロックする。 呼び出しが成功した場合には、 指定されたアドレス範囲を含む全ての"
"ページは RAM に残り続けることが保証される。 これらのページは後でロック解除さ"
"れるまで RAM に残り続けることが保証される。"

#. type: Plain text
#: build/C/man2/mlock.2:73
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""
"B<munlock>()  は、 I<addr> から始まる長さ I<len> バイトのアドレス範囲のページ"
"のロックを解除する。 この呼び出しを行った後は、カーネルが、指定されたメモリ範"
"囲を含む 全てのページを外部のスワップ空間に移動できるようになる。"

#. type: SS
#: build/C/man2/mlock.2:73
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr "mlockall() と munlockall()"

#. type: Plain text
#: build/C/man2/mlock.2:83
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and memory-"
"mapped files.  All mapped pages are guaranteed to be resident in RAM when "
"the call returns successfully; the pages are guaranteed to stay in RAM until "
"later unlocked."
msgstr ""
"B<mlockall>()  は呼び出し元プロセスのアドレス空間にマップされている全てのペー"
"ジを ロックする。これにはコード、データ、スタックの 各セグメント、共有ライブ"
"ラリ、カーネルのユーザー空間データ、 共有メモリ、メモリ・マップされたファイル"
"が含まれる。 システム・コールが成功した場合には全てのマップされたページは "
"RAM に 残ることを保証される。 これらのページは後でロック解除されるまで RAM に"
"残り続けることが保証される。"

#. type: Plain text
#: build/C/man2/mlock.2:88
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr "I<flags> 引数は以下の内容の一つまたは複数のビット OR から構成される:"

#. type: TP
#: build/C/man2/mlock.2:88
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr "B<MCL_CURRENT>"

#. type: Plain text
#: build/C/man2/mlock.2:92
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""
"現在、プロセスのアドレス空間にマップされている全てのページをロックする。"

#. type: TP
#: build/C/man2/mlock.2:92
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr "B<MCL_FUTURE>"

#. type: Plain text
#: build/C/man2/mlock.2:99
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be for instance new pages required by a "
"growing heap and stack as well as new memory mapped files or shared memory "
"regions."
msgstr ""
"将来、プロセスのアドレス空間にマップされる全てのページをロックする。 例えば、"
"ヒープ (heap) やスタックの成長により新しく必要になったページだけで なく、新し"
"くメモリマップされたファイルや共有メモリ領域もロックされる。"

#. type: Plain text
#: build/C/man2/mlock.2:112
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., B<mmap>"
"(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number of "
"locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""
"B<MCL_FUTURE> が指定されていると、以後のシステムコール (例えば、 B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3))  は、ロックするバイト数が許可された最大値 (下記参"
"照) を超えた場合に 失敗する可能性がある。 同様に、スタックの成長も失敗する可"
"能性がある。 その場合、カーネルはスタックの拡張を拒否し、 B<SIGSEGV> をプロセ"
"スに送る。"

#. type: Plain text
#: build/C/man2/mlock.2:116
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""
"B<munlockall>()  は、呼び出し元プロセスのアドレス空間にマッピングされている "
"全てのページをロック解除する。"

#. type: Plain text
#: build/C/man2/mlock.2:122
msgid ""
"On success these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""
"成功した場合は、これらのシステムコールはゼロを返す。 エラーの場合は -1 が返さ"
"れ、 I<errno> が適切に設定され、プロセスのアドレス空間におけるロックは変更さ"
"れない。"

#. type: Plain text
#: build/C/man2/mlock.2:131
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""
"(Linux 2.6.9 以降) 呼び出し元は非ゼロの ソフト資源制限 B<RLIMIT_MEMLOCK> を持"
"つが、制限が許可している以上のメモリをロックしようとした。 この制限は、プロセ"
"スが特権 (B<CAP_IPC_LOCK>)  を持っている場合は適用されない。"

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: build/C/man2/mlock.2:143
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""
"(Linux 2.4 以前) 呼び出し元プロセスが RAM の半分以上をロックしようとした。"

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: build/C/man2/mlock.2:149
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""
"呼び出し側が特権を持っていないが、\n"
"要求された操作を実行するには特権 (B<CAP_IPC_LOCK>) が必要である。"

#. type: Plain text
#: build/C/man2/mlock.2:154
msgid "For B<mlock>()  and B<munlock>():"
msgstr "B<mlock>()  と B<munlock>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:157
msgid "Some or all of the specified address range could not be locked."
msgstr "指定されたアドレス範囲の一部または全てをロックすることができなかった。"

#. type: Plain text
#: build/C/man2/mlock.2:164
msgid ""
"The result of the addition I<start>+I<len> was less than I<start> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""
"I<start>+I<len> の加算の結果が I<start> よりも小さかった\n"
"(例えば、加算でオーバーフローが発生したなど)。"

#. type: Plain text
#: build/C/man2/mlock.2:169
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""
"(Linux ではこの意味で使われない)  I<addr> がページサイズの倍数ではない。"

#. type: Plain text
#: build/C/man2/mlock.2:173
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""
"指定されたアドレス範囲がプロセスのアドレス空間にマップされたページと 一致しな"
"い。"

#. type: Plain text
#: build/C/man2/mlock.2:176
msgid "For B<mlockall>():"
msgstr "B<mlockall>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:179
msgid "Unknown I<flags> were specified."
msgstr "未知の I<flags> が指定された。"

#. type: Plain text
#: build/C/man2/mlock.2:182
msgid "For B<munlockall>():"
msgstr "B<munlockall>()  用として:"

#. type: Plain text
#: build/C/man2/mlock.2:186
msgid ""
"(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""
"(Linux 2.6.8 以前) 呼び出し元が権限 (B<CAP_IPC_LOCK>)  を持っていない。"

#. type: Plain text
#: build/C/man2/mlock.2:188
msgid "POSIX.1-2001, SVr4."
msgstr "POSIX.1-2001, SVr4."

#. type: SH
#: build/C/man2/mlock.2:188 build/C/man2/mmap.2:501 build/C/man2/msync.2:105
#, no-wrap
msgid "AVAILABILITY"
msgstr "可用性"

#. type: Plain text
#: build/C/man2/mlock.2:200
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""
"B<mlock>()  と B<munlock>()  が使用可能な POSIX システムでは "
"B<_POSIX_MEMLOCK_RANGE> が I<E<lt>unistd.hE<gt>> で定義されている。 また、"
"ページあたりのバイト数は、 I<E<lt>limits.hE<gt>> で定義される定数 "
"B<PAGESIZE> から (定義されている場合)、もしくは I<sysconf(_SC_PAGESIZE)> を呼"
"び出すことで決定できる。"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mlock.2:213
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<mlockall>()  と B<munlockall>()  が利用可能な POSIX システムでは、 "
"B<_POSIX_MEMLOCK> は I<E<lt>unistd.hE<gt>> で 0 より大きい値に定義されている "
"(B<sysconf>(3)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/mlock.2:231
msgid ""
"Memory locking has two main applications: real-time algorithms and high-"
"security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""
"メモリのロックの用途としては主に二つある: リアルタイム アルゴリズムと高いセ"
"キュリティの必要なデータ処理である。リアルタイムの アプリケーションは決定的な"
"タイミングやスケジューリングを必要とするが、 ページングは予期しないプログラム"
"の実行遅延をもたらす主要な要因となる。 リアルタイムのアプリケーションはたいて"
"いは B<sched_setscheduler>(2)  でリアルタイムスケジューラに変更される。 暗号"
"やセキュリティのソフトウェアはしばしばパスワードや秘密鍵のデータの ような重要"
"なバイト列を扱う。ページングの結果、これらの秘密が スワップ用の固定媒体に転送"
"されるかもしれない。そして、セキュリティ・ ソフトウェアが RAM 上の秘密を削除"
"して終了したずっと後になっても、 このスワップされたデータには敵がアクセスでき"
"る可能性がある (しかし、ラップトップといくつかのデスクトップコンピュータの サ"
"スペンドモードはシステムの RAM の内容をメモリのロックに関わらず ディスクに保"
"存することに注意)。"

#. type: Plain text
#: build/C/man2/mlock.2:244
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the time-"
"critical section, so that no page fault can be caused by function calls.  "
"This can be achieved by calling a function that allocates a sufficiently "
"large automatic variable (an array) and writes to the memory occupied by "
"this array in order to touch these stack pages.  This way, enough pages will "
"be mapped for the stack and can be locked into RAM.  The dummy writes ensure "
"that not even copy-on-write page faults can occur in the critical section."
msgstr ""
"リアルタイムプロセスが B<mlockall>()  を使ってページフォールトによる遅延を防"
"ごうとする場合、 関数呼び出しによってページフォールトが発生しないように、 時"
"間制限の厳しい部分 (time-critical section) に入る前に 十分な量のロックされた"
"スタックを確保しておく必要がある。 これを実現するには、十分な大きさの自動変"
"数 (の配列) を確保し、 これらのスタック用のページがメモリ上に確保されるように"
"この配列に 書き込みを行う関数を用意し、これを呼び出せばよい。こうすること"
"で、 十分な量のページがスタックにマッピングされ、RAM にロックされる。 ダミー"
"の書き込みを行うことによって、 時間制限の厳しい部分 (critical section) 内では"
"書き込み時コピーによる ページフォールトさえも発生しないことが保証される。"

#. type: Plain text
#: build/C/man2/mlock.2:250
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates."
msgstr ""
"メモリロックは B<fork>(2)  で作成された子プロセスには継承されず、 B<execve>"
"(2)  が呼ばれたり、プロセスが終了した場合は 自動的に削除される (ロック解除さ"
"れる)。"

#. type: Plain text
#: build/C/man2/mlock.2:254
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""
"あるアドレス範囲に対するメモリロックは、そのアドレス範囲が B<munmap>(2)  に"
"よってアンマップされた場合は削除される。"

#. type: Plain text
#: build/C/man2/mlock.2:267
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>()  or B<mlockall>()  will be unlocked by a single "
"call to B<munlock>()  for the corresponding range or by B<munlockall>().  "
"Pages which are mapped to several locations or by several processes stay "
"locked into RAM as long as they are locked at least at one location or by at "
"least one process."
msgstr ""
"メモリのロックは累積しない。 すなわち複数回 B<mlock>()  や B<mlockall>()  を"
"呼び出してロックされたページでも、 対応する範囲に対して B<munlock>()  を 1 回"
"呼び出したり B<munlockall>()  を呼び出したりするだけでロック解除される。 複数"
"の場所や複数のプロセスにマップされているページは、少なくとも一つの場所、 一つ"
"のプロセスでロックされている限りは RAM に残り続ける。"

#. type: Plain text
#: build/C/man2/mlock.2:278
msgid ""
"Under Linux, B<mlock>()  and B<munlock>()  automatically round I<addr> down "
"to the nearest page boundary.  However, POSIX.1-2001 allows an "
"implementation to require that I<addr> is page aligned, so portable "
"applications should ensure this."
msgstr ""
"Linux では、 B<mlock>()  と B<munlock>()  は自動的に I<addr> を端数切り捨てに"
"より一番近いページ境界へと丸める。 しかし POSIX.1-2001 は I<addr> がページ境"
"界に合っていることを要求する実装も許している。 そのため移植性を意図したアプリ"
"ケーションではきちんと境界に合わせた方が良い。"

#. type: Plain text
#: build/C/man2/mlock.2:291
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/PID/status> file shows how "
"many kilobytes of memory the process with ID I<PID> has locked using B<mlock>"
"(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""
"Linux 固有の I</proc/PID/status> ファイルの I<VmLck> フィールドには、\n"
"B<mlock>(), B<mlockall>() および B<mmap>(2) B<MAP_LOCKED> を使って、\n"
"ID が I<PID> のプロセスがロックしているメモリ量 (キロバイト単位) が\n"
"表示される。"

#. type: SS
#: build/C/man2/mlock.2:291
#, no-wrap
msgid "Limits and permissions"
msgstr "制限と権限"

#. type: Plain text
#: build/C/man2/mlock.2:298
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""
"Linux 2.6.8 以前では、メモリをロックするためには特権 (B<CAP_IPC_LOCK>)  が必"
"要で、 ソフト資源制限 B<RLIMIT_MEMLOCK> はプロセスがどれだけのメモリをロック"
"できるかの制限を定義する。"

#. type: Plain text
#: build/C/man2/mlock.2:304
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""
"Linux 2.6.9 以降では、特権を持つプロセスがロックできるメモリ量は無制限とな"
"り、 代わりにソフト資源制限 B<RLIMIT_MEMLOCK> は特権を持たないプロセスがロッ"
"クできるメモリ量の制限を定義する。"

#. type: Plain text
#: build/C/man2/mlock.2:312
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""
"2.4.17 までの 2.4 シリーズの Linux カーネルには、 B<mlockall>()  "
"B<MCL_FUTURE> フラグが B<fork>(2)  で継承されると言うバグがある。 これはカー"
"ネル 2.4.18 で修正された。"

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: build/C/man2/mlock.2:329
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""
"カーネル 2.6.9 以降では、特権を持ったプロセスが I<mlockall(MCL_FUTURE)> を呼"
"び出した後で、特権をなくした場合 (例えば、 実効 UID を 0 以外の値に変更するな"
"どにより、 B<CAP_IPC_LOCK> ケーパビリティを失った場合)、リソース上限 "
"B<RLIMIT_MEMLOCK> に達すると、それ以降のメモリ割り当て (例えば B<mmap>(2), "
"B<brk>(2))  は失敗する。"

#. type: Plain text
#: build/C/man2/mlock.2:336
msgid ""
"B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), "
"B<capabilities>(7)"
msgstr ""
"B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5),\n"
"B<capabilities>(7)"

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr "MMAP"

#. type: TH
#: build/C/man2/mmap.2:40
#, fuzzy, no-wrap
#| msgid "2009-02-25"
msgid "2013-02-25"
msgstr "2009-02-25"

#. type: Plain text
#: build/C/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr "mmap, munmap - ファイルやデバイスをメモリにマップ/アンマップする"

#. type: Plain text
#: build/C/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int >I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"

#. type: Plain text
#: build/C/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping."
msgstr ""
"B<mmap>()  は、新しいマッピングを呼び出し元プロセスの仮想アドレス空間に作成す"
"る。 新しいマッピングの開始アドレスは I<addr> で指定される。マッピングの長さ"
"は I<length> 引き数で指定される。"

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: build/C/man2/mmap.2:77
msgid ""
"If I<addr> is NULL, then the kernel chooses the address at which to create "
"the mapping; this is the most portable method of creating a new mapping.  If "
"I<addr> is not NULL, then the kernel takes it as a hint about where to place "
"the mapping; on Linux, the mapping will be created at a nearby page "
"boundary.  The address of the new mapping is returned as the result of the "
"call."
msgstr ""
"I<addr> が NULL の場合、カーネルがマッピングを作成するアドレスを選択する。 こ"
"の方法は最も移植性のある新しいマッピングの作成方法である。 I<addr> が NULL で"
"ない場合、カーネルはマッピングをどこに配置するかのヒントとして I<addr> を使用"
"する。Linux では、マッピングはすぐ近くのページ境界に作成される。 新しいマッピ"
"ングのアドレスは、呼び出しの返り値として返される。"

#. type: Plain text
#: build/C/man2/mmap.2:89
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""
"ファイルマッピングの内容は、 ファイルディスクリプタ I<fd> で参照されるファイ"
"ル (もしくは他のオブジェクト) のオフセット I<offset> から開始される "
"I<length> バイトのデータで初期化される (ファイルマッピングは無名マッピングの"
"反対語である。 B<MAP_ANONYMOUS> を参照)。 I<offset> は I<sysconf"
"(_SC_PAGE_SIZE)> が返すページサイズの倍数でなければならない。"

#. type: Plain text
#: build/C/man2/mmap.2:97
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""
"引き数 I<prot> には、マッピングのメモリ保護をどのように行なうかを指定する "
"(ファイルのオープンモードと矛盾してはいけない)。 I<prot> には、 B<PROT_NONE> "
"か、以下のフラグをひとつ以上ビット毎の論理和 (OR) をとったものを 指定できる。"

#. type: TP
#: build/C/man2/mmap.2:97 build/C/man2/mprotect.2:73
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr "B<PROT_EXEC>"

#. type: Plain text
#: build/C/man2/mmap.2:100
msgid "Pages may be executed."
msgstr "ページは実行可能である。"

#. type: TP
#: build/C/man2/mmap.2:100 build/C/man2/mprotect.2:67
#, no-wrap
msgid "B<PROT_READ>"
msgstr "B<PROT_READ>"

#. type: Plain text
#: build/C/man2/mmap.2:103
msgid "Pages may be read."
msgstr "ページは読み込み可能である。"

#. type: TP
#: build/C/man2/mmap.2:103 build/C/man2/mprotect.2:70
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr "B<PROT_WRITE>"

#. type: Plain text
#: build/C/man2/mmap.2:106
msgid "Pages may be written."
msgstr "ページに書き込み可能である。"

#. type: TP
#: build/C/man2/mmap.2:106 build/C/man2/mprotect.2:64
#, no-wrap
msgid "B<PROT_NONE>"
msgstr "B<PROT_NONE>"

#. type: Plain text
#: build/C/man2/mmap.2:109
msgid "Pages may not be accessed."
msgstr "ページにはアクセスできない。"

#. type: Plain text
#: build/C/man2/mmap.2:118
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""
"I<flags> 引き数により、マッピングに対する更新が同じ領域をマッピングしている "
"他のプロセスに見えるか、更新がマッピング元のファイルを通じて 伝えられるか、が"
"決定される。この動作は、以下の値のいずれか一つだけ (複数は指定できない) を "
"I<flags> に含めることで指定する。"

#. type: TP
#: build/C/man2/mmap.2:118
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr "B<MAP_SHARED>"

#. type: Plain text
#: build/C/man2/mmap.2:128
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"that map this file, and are carried through to the underlying file.  The "
"file may not actually be updated until B<msync>(2)  or B<munmap>()  is "
"called."
msgstr ""
"このマッピングを共有する。 マッピングに対する更新はこのファイルをマッピングし"
"ている他のプロセス から見える。更新はマッピング元のファイルを通じて伝えられ"
"る。 ただし、ファイルの実際の更新は B<msync>(2)  または B<munmap>()  が呼ばれ"
"るまで行われないこともある。"

#. type: TP
#: build/C/man2/mmap.2:128
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr "B<MAP_PRIVATE>"

#. type: Plain text
#: build/C/man2/mmap.2:137
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""
"プライベートな copy-on-write (書き込み時コピー) マップを生成する。 マッピング"
"に対する更新は同じファイルをマッピングしている他のプロセス には見えず、更新が"
"マッピング元のファイルを通じて伝えられることもない。 B<mmap>()  の呼び出し後"
"にマッピング元のファイルに対して行われた変更が、 マップ領域に反映されるかどう"
"かは規定されていない。"

#. type: Plain text
#: build/C/man2/mmap.2:139
msgid "Both of these flags are described in POSIX.1-2001."
msgstr "上記の二つのフラグは POSIX.1-2001 で規定されている。"

#. type: Plain text
#: build/C/man2/mmap.2:142
msgid ""
"In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""
"さらに、以下の値のうち 0 個以上をビット毎の論理和 (OR) で I<flags> に指定する"
"ことができる。"

#. type: TP
#: build/C/man2/mmap.2:142
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr "B<MAP_32BIT> (Linux 2.4.20, 2.6 以降)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: build/C/man2/mmap.2:158
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is only supported on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2GB of memory, so "
"as to improve context-switch performance on some early 64-bit processors.  "
"Modern x86-64 processors no longer have this performance problem, so use of "
"this flag is not required on those systems.  The B<MAP_32BIT> flag is "
"ignored when B<MAP_FIXED> is set."
msgstr ""
"マッピングをプロセスのアドレス空間の先頭 2 ギガバイト以内に配置する。 このフ"
"ラグがサポートされているのは x86-64 アーキテクチャ上の 64 ビットプログラムの"
"みである。 このフラグが追加されたのは、スレッドのスタックをメモリの先頭 2GB "
"以内の どこかに割り当てることで、初期のいくつかの 64 ビットプロセッサにおけ"
"る コンテキストスイッチの性能問題を改善するためである。 最近の x86-64 プロ"
"セッサではこの性能問題はもはや存在せず、 そのようなシステムではこのフラグを使"
"用する必要はない。 B<MAP_FIXED> がセットされている場合は、 B<MAP_32BIT> フラ"
"グは無視される。"

#. type: TP
#: build/C/man2/mmap.2:158
#, no-wrap
msgid "B<MAP_ANON>"
msgstr "B<MAP_ANON>"

#. type: Plain text
#: build/C/man2/mmap.2:163
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr "B<MAP_ANONYMOUS> の同義語。非推奨。"

#. type: TP
#: build/C/man2/mmap.2:163
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr "B<MAP_ANONYMOUS>"

#. type: Plain text
#: build/C/man2/mmap.2:185
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> and I<offset> arguments are ignored; however, some "
"implementations require I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  "
"is specified, and portable applications should ensure this.  The use of "
"B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is only supported on "
"Linux since kernel 2.4."
msgstr ""
"マッピングはどのファイルとも関連付けされない。 マッピングの内容は 0 で初期化"
"される。 引き数 I<fd> と I<offset> は無視される。 ただし、実装によっては "
"B<MAP_ANONYMOUS> (もしくは B<MAP_ANON>)  が指定された場合、 I<fd> を -1 にす"
"る必要があり、 移植性が必要なアプリケーションでは必ず I<fd> を -1 にすべきで"
"ある。 B<MAP_ANONYMOUS> と B<MAP_SHARED> を組み合わせての利用は カーネル 2.4 "
"以降の Linux でのみサポートされている。"

#. type: TP
#: build/C/man2/mmap.2:185
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr "B<MAP_DENYWRITE>"

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: build/C/man2/mmap.2:193
msgid ""
"This flag is ignored.  (Long ago, it signaled that attempts to write to the "
"underlying file should fail with B<ETXTBUSY>.  But this was a source of "
"denial-of-service attacks.)"
msgstr ""
"このフラグは無視される (ずっと前は、マップ元のファイルへの書き込みを行おうと"
"すると、エラー B<ETXTBUSY> で失敗するようにシグナルが設定されていたが、これ"
"は denial-of-service (サービス拒否) 攻撃の原因となった)。"

#. type: TP
#: build/C/man2/mmap.2:193
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr "B<MAP_EXECUTABLE>"

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: build/C/man2/mmap.2:201
msgid "This flag is ignored."
msgstr "このフラグは無視される。"

#. type: TP
#: build/C/man2/mmap.2:201
#, no-wrap
msgid "B<MAP_FILE>"
msgstr "B<MAP_FILE>"

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: build/C/man2/mmap.2:207
msgid "Compatibility flag.  Ignored."
msgstr "互換性のためのフラグ。無視される。"

#. type: TP
#: build/C/man2/mmap.2:207
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr "B<MAP_FIXED>"

#. type: Plain text
#: build/C/man2/mmap.2:225
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be a multiple of the page size.  If the memory region "
"specified by I<addr> and I<len> overlaps pages of any existing mapping(s), "
"then the overlapped part of the existing mapping(s) will be discarded.  If "
"the specified address cannot be used, B<mmap>()  will fail.  Because "
"requiring a fixed address for a mapping is less portable, the use of this "
"option is discouraged."
msgstr ""
"I<addr> をアドレスのヒントとして使用するのではなく、 I<addr> で指定されたアド"
"レスをそのまま使用してマッピングを配置する。 I<addr> はページサイズの倍数でな"
"ければならない。 I<addr> と I<len> で指定されたメモリ領域が既存のマッピングの"
"ページと重なる場合、 既存のマッピングの重なった部分は捨てられる。 もし指定さ"
"れたアドレスが使用できない場合、 B<mmap>()  は失敗する。 マッピングに対して固"
"定アドレスを要求するのは移植性の面で劣るので、 このオプションは使用しないこと"
"を推奨する。"

#. type: TP
#: build/C/man2/mmap.2:225
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr "B<MAP_GROWSDOWN>"

#. type: Plain text
#: build/C/man2/mmap.2:230
msgid ""
"Used for stacks.  Indicates to the kernel virtual memory system that the "
"mapping should extend downward in memory."
msgstr ""
"スタック用に使用される。マッピングをメモリ内で逆向きに行うことを カーネル仮想"
"メモリシステムに指示する。 (訳注：マッピングは通常はメモリ・アドレスが増加す"
"る向きに行うが、 このオプションを指定すると逆向きにマッピングを行う)"

#. type: TP
#: build/C/man2/mmap.2:230
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr "B<MAP_HUGETLB> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:236
#, fuzzy
#| msgid ""
#| "Allocate the mapping using \"huge pages.\" See the kernel source file "
#| "I<Documentation/vm/hugetlbpage.txt> for further information."
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""
"\"huge page\" を使ってマッピングを割り当てる。 詳しい情報は、カーネル・ソース"
"の I<Documentation/vm/hugetlbpage.txt> を参照。"

#. type: TP
#: build/C/man2/mmap.2:236
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr "B<MAP_LOCKED> (Linux 2.5.37 以降)"

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: build/C/man2/mmap.2:242
msgid ""
"Lock the pages of the mapped region into memory in the manner of B<mlock>"
"(2).  This flag is ignored in older kernels."
msgstr ""
"マップされた領域のページを B<mlock>(2)  の方法でメモリ内にロックする。 それ以"
"前のカーネルでは、このフラグは無視される。"

#. type: TP
#: build/C/man2/mmap.2:242
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr "B<MAP_NONBLOCK> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:257
msgid ""
"Only meaningful in conjunction with B<MAP_POPULATE>.  Don't perform read-"
"ahead: only create page tables entries for pages that are already present in "
"RAM.  Since Linux 2.6.23, this flag causes B<MAP_POPULATE> to do nothing.  "
"One day the combination of B<MAP_POPULATE> and B<MAP_NONBLOCK> may be "
"reimplemented."
msgstr ""
"B<MAP_POPULATE> と組み合わせた場合のみ意味を持つ。 read-ahead (前もって読み込"
"むこと) を実行しない。 単に、すでに RAM 上に存在するページに対して ページテー"
"ブルエントリを作成するだけである。 Linux 2.6.23 以降では、このフラグは "
"B<MAP_POPULATE> に何の影響も与えない。 いつか B<MAP_POPULATE> と "
"B<MAP_NONBLOCK> を組み合わせた場合の動作は実装し直されるかもしれない。"

#. type: TP
#: build/C/man2/mmap.2:257
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr "B<MAP_NORESERVE>"

#. type: Plain text
#: build/C/man2/mmap.2:272
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5).  In kernels before 2.6, this flag only had "
"effect for private writable mappings."
msgstr ""
"このマッピングに対するスワップ空間の予約を行わない。 スワップ空間を予約した場"
"合は、このマッピングの変更が必ず可能なことが 保証される。予約を行わなかった場"
"合、物理メモリに空きがないと 書き込み時に B<SIGSEGV> エラーを受け取ることがあ"
"る。 B<proc>(5)  の I</proc/sys/vm/overcommit_memory> ファイルについての議論"
"も参照。 バージョン 2.6 より前のカーネルでは、このフラグは書き込み可能な プラ"
"イベート・マッピングについてのみ効果があった。"

#. type: TP
#: build/C/man2/mmap.2:272
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr "B<MAP_POPULATE> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:279
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  Later accesses to the mapping will not be "
"blocked by page faults.  B<MAP_POPULATE> is only supported for private "
"mappings since Linux 2.6.23."
msgstr ""
"マッピング用のページテーブルを配置 (populate) する ファイルマッピングの場合に"
"は、これによりファイルが先読み (read-ahead)  が行われる。この以後は、マッピン"
"グに対するアクセスがページフォールトで ブロックされることがなくなる。 "
"B<MAP_POPULATE> は Linux 2.6.23 以降でプライベート・マッピングについてのみ サ"
"ポートされている。"

#. type: TP
#: build/C/man2/mmap.2:279
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr "B<MAP_STACK> (Linux 2.6.27 以降)"

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: build/C/man2/mmap.2:292
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""
"プロセスやスレッドのスタックに適したアドレスにマッピングを割り当てる。 現在の"
"ところ、このフラグは何もしないが、 glibc のスレッド実装では使用されている。 "
"これは、いくつかのアーキテクチャではスタックの割り当てに関して特別な扱い が必"
"要な場合に、glibc にそのサポートを後で透過的に実装できるようにする ためであ"
"る。"

#. type: TP
#: build/C/man2/mmap.2:292
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr "B<MAP_UNINITIALIZED> (Linux 2.6.33 以降)"

#. type: Plain text
#: build/C/man2/mmap.2:302
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is only honored if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices (i."
"e., devices where one has complete control of the contents of user memory)."
msgstr ""
"無名ページ (anonymous page) のクリアを行わない。このフラグは組み込みデバイ"
"ス\n"
"での性能向上を目的に作られてものである。カーネルの設定で\n"
"B<CONFIG_MMAP_ALLOW_UNINITIALIZED> オプションが有効になっている場合のみ、\n"
"このフラグは効果を持つ。\n"
"セキュリティ面の考慮から、このオプションは通常組み込みデバイス (すなわち、\n"
"ユーザメモリの内容を完全に制御化におけるデバイス) においてのみ有効にされる。"

#. type: Plain text
#: build/C/man2/mmap.2:310
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001.  "
"However, most systems also support B<MAP_ANONYMOUS> (or its synonym "
"B<MAP_ANON>)."
msgstr ""
"上記のフラグの中では、 B<MAP_FIXED> だけが POSIX.1-2001 で規定されている。 し"
"かしながら、ほとんどのシステムで B<MAP_ANONYMOUS> (またはその同義語である "
"B<MAP_ANON>)  もサポートされている。"

#. type: Plain text
#: build/C/man2/mmap.2:317
msgid ""
"Some systems document the additional flags B<MAP_AUTOGROW>, "
"B<MAP_AUTORESRV>, B<MAP_COPY>, and B<MAP_LOCAL>."
msgstr ""
"いくつかのシステムでは、上記以外にフラグとして B<MAP_AUTOGROW>, "
"B<MAP_AUTORESRV>, B<MAP_COPY>, B<MAP_LOCAL> が規定されている。"

#. type: Plain text
#: build/C/man2/mmap.2:323
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""
"B<mmap>()  によってマップされたメモリの属性は B<fork>(2)  の際に継承される。"

#. type: Plain text
#: build/C/man2/mmap.2:331
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""
"ファイルはページサイズの整数倍の領域にマップされる。サイズがページサイズの 整"
"数倍でないファイルの場合、マップ時に残りの領域は 0 で埋められ、この領域へ 書"
"きこみを行ってもファイルに書き出されることはない。マッピングを行った元 ファイ"
"ルのサイズを変更した場合、元ファイルの追加されたり削除された領域に対応 する"
"マップされたページに対してどのような影響があるかは規定されていない。"

#. type: SS
#: build/C/man2/mmap.2:331
#, no-wrap
msgid "munmap()"
msgstr "munmap()"

#. type: Plain text
#: build/C/man2/mmap.2:341
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""
"システムコール B<munmap>()  は指定されたアドレス範囲のマップを消去し、 これ以"
"降のその範囲内へのメモリ参照は不正となる。 この領域は、プロセスが終了したとき"
"にも自動的にアンマップされる。 一方、ファイル記述子をクローズしても、この領域"
"はアンマップされない。"

#. type: Plain text
#: build/C/man2/mmap.2:351
msgid ""
"The address I<addr> must be a multiple of the page size.  All pages "
"containing a part of the indicated range are unmapped, and subsequent "
"references to these pages will generate B<SIGSEGV>.  It is not an error if "
"the indicated range does not contain any mapped pages."
msgstr ""
"I<addr> アドレスはページサイズの整数倍でなければならない。指定された範囲の一"
"部分を 含む全てのページはアンマップされ、これ以降にこれらのページへの参照があ"
"ると B<SIGSEGV> が発生する。 指定した範囲内にマップされたページが一つも含まれ"
"ていない場合でも エラーにならない。"

#. type: SS
#: build/C/man2/mmap.2:351
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr "ファイルと関連付けられたマッピングに対するタイムスタンプの更新"

#. type: Plain text
#: build/C/man2/mmap.2:358
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""
"ファイルと関連付けられたマッピングの場合、マッピングされたファイルの "
"I<st_atime> フィールドは、 B<mmap>()  されてからアンマップ (unmap) されるまで"
"の間に更新されることがある。 それまでに更新が行われていなければ、マップされた"
"ページへの最初の参照があった 際に更新される。"

#. type: Plain text
#: build/C/man2/mmap.2:375
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""
"B<PROT_WRITE> と B<MAP_SHARED> の両方を指定してマップされたファイルの場合、書"
"き込みがあると、 I<st_ctime> と I<st_mtime> の両フィールドは、マップされた領"
"域への書き込みより後で、 B<MS_SYNC> または B<MS_ASYNC> フラグを指定して "
"B<msync>(2)  が呼ばれる前までに更新される。"

#. type: Plain text
#: build/C/man2/mmap.2:392
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set appropriately.  On success, B<munmap>()  returns 0, on failure -1, "
"and I<errno> is set (probably to B<EINVAL>)."
msgstr ""
"B<mmap>()  は成功するとマップされた領域へのポインタを返す。 失敗すると値 "
"B<MAP_FAILED> (つまり I<(void\\ *)\\ -1>)  を返し、 I<errno> がエラーの内容に"
"したがってセットされる。 B<munmap>()  は成功すると 0 を返す。失敗すると -1 を"
"返し、 I<errno> がセットされる (多くの場合 B<EINVAL> になるだろう)。"

#. type: TP
#: build/C/man2/mmap.2:393 build/C/man2/mprotect.2:86
#: build/C/man3/shm_open.3:185 build/C/man3/shm_open.3:190
#: build/C/man2/shmctl.2:297 build/C/man2/shmget.2:188
#: build/C/man2/shmop.2:191
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/mmap.2:413
msgid ""
"A file descriptor refers to a non-regular file.  Or B<MAP_PRIVATE> was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""
"以下のいずれかの場合。 ファイル記述子の参照先が通常のファイルではない (non-"
"regular file) 。 B<MAP_PRIVATE> を要求したが I<fd> は読み込み用にオープンされ"
"ていない。 B<MAP_SHARED> を要求して B<PROT_WRITE> をセットしたが I<fd> は読み"
"書きモード (B<O_RDWR>)  でオープンされていない、 B<PROT_WRITE> をセットした"
"が、ファイルは追加 (append) 専用である。"

#. type: Plain text
#: build/C/man2/mmap.2:417
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""
"ファイルがロックされている。またはロックされているメモリが多すぎる "
"(B<setrlimit>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/mmap.2:423
msgid ""
"I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""
"I<fd> が有効なファイル記述子 (file descriptor) ではない (かつ "
"B<MAP_ANONYMOUS> がセットされていない)。"

#. type: Plain text
#: build/C/man2/mmap.2:431
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""
"I<addr> か I<length> か I<offset> が適切でない (例えば、大きすぎるとか、ペー"
"ジ境界にアラインメントされていない)。"

#. type: Plain text
#: build/C/man2/mmap.2:436
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr "(Linux 2.6.12 以降)  I<length> が 0 であった。"

#. type: Plain text
#: build/C/man2/mmap.2:444
msgid ""
"I<flags> contained neither B<MAP_PRIVATE> or B<MAP_SHARED>, or contained "
"both of these values."
msgstr ""
"I<flags> に B<MAP_PRIVATE> と B<MAP_SHARED> のどちらも含まれていなかった、も"
"しくは その両方が含まれていた。"

#. type: TP
#: build/C/man2/mmap.2:444 build/C/man3/shm_open.3:227
#: build/C/man2/shmget.2:204
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#. type: Plain text
#: build/C/man2/mmap.2:452 build/C/man2/shmget.2:208
msgid "The system limit on the total number of open files has been reached."
msgstr "システム全体でオープンされているファイルの総数が上限に達した。"

#. type: Plain text
#: build/C/man2/mmap.2:456
msgid ""
"The underlying file system of the specified file does not support memory "
"mapping."
msgstr ""
"指定されたファイルが置かれているファイルシステムがメモリマッピングをサポート "
"していない。"

#. type: Plain text
#: build/C/man2/mmap.2:460
msgid ""
"No memory is available, or the process's maximum number of mappings would "
"have been exceeded."
msgstr ""
"メモリに空きがない、または処理中のプロセスのマッピング数が最大数を超過した。"

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: build/C/man2/mmap.2:469
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a file system that was mounted no-exec."
msgstr ""
"I<prot> 引き数は B<PROT_EXEC> を行うように指定されているが、 no-exec でマウン"
"トされたファイルシステム上のファイルに マップ領域が対応している。"

#. type: TP
#: build/C/man2/mmap.2:469
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man2/mmap.2:475
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""
"B<MAP_DENYWRITE> がセットされているが I<fd> で指定されているオブジェクトは書"
"き込み用に開かれている。"

#. type: TP
#: build/C/man2/mmap.2:475 build/C/man2/shmctl.2:339
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr "B<EOVERFLOW>"

#. type: Plain text
#: build/C/man2/mmap.2:487
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:489
msgid "Use of a mapped region can result in these signals:"
msgstr "マップ領域を利用する際に、以下のシグナルが発生することがある:"

#. type: TP
#: build/C/man2/mmap.2:489
#, no-wrap
msgid "B<SIGSEGV>"
msgstr "B<SIGSEGV>"

#. type: Plain text
#: build/C/man2/mmap.2:492
msgid "Attempted write into a region mapped as read-only."
msgstr "読み込み専用で mmap された領域へ書き込みを行おうとした。"

#. type: TP
#: build/C/man2/mmap.2:492
#, no-wrap
msgid "B<SIGBUS>"
msgstr "B<SIGBUS>"

#. type: Plain text
#: build/C/man2/mmap.2:497
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""
"バッファのうち、ファイルに関連づけられていない部分 (例えばファイル末尾を越え"
"た部分など。これには 他のプロセスがファイルを切り詰めた場合なども含まれる)  "
"にアクセスしようとした。"

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: build/C/man2/mmap.2:501
msgid "SVr4, 4.4BSD, POSIX.1-2001."
msgstr "SVr4, 4.4BSD, POSIX.1-2001."

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mmap.2:515
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2)  and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<mmap>(), B<msync>(2)  B<munmap>()  が利用可能な POSIX システムでは、 "
"B<_POSIX_MAPPED_FILES> は E<lt>unistd.hE<gt> で 0 より大きな値に定義される "
"(B<sysconf>(3)  も参照のこと)。"

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: build/C/man2/mmap.2:530
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by B<mmap2>"
"(2), and nowadays the glibc B<mmap>()  wrapper function invokes B<mmap2>(2)  "
"with a suitably adjusted value for I<offset>."
msgstr ""
"このページでは glibc の B<mmap>() のラッパー関数が提供するインターフェース"
"に\n"
"ついて説明している。元々は、この関数は同じ名前のシステムコールを起動してい"
"た。\n"
"カーネル 2.4 以降、このシステムコールは B<mmap2>(2) に取って代わられ、現在\n"
"では、 glibc の B<mmap>() のラッパー関数は I<offset> を適切に調整してから\n"
"B<mmap2>(2) を起動する。"

#. type: Plain text
#: build/C/man2/mmap.2:543
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""
"(i386 などの) いくつかのアーキテクチャでは、 B<PROT_WRITE> をセットすると、暗"
"黙のうちに B<PROT_READ> がセットされる。 B<PROT_READ> をセットした際に暗黙の"
"うちに B<PROT_EXEC> がセットされるかどうかは、アーキテクチャ依存である。 移植"
"性を考慮したプログラムでは、 新規にマップした領域でコードを実行したい場合は、"
"常に B<PROT_EXEC> をセットすべきである。"

#. type: Plain text
#: build/C/man2/mmap.2:558
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 (NULL)."
msgstr ""
"マッピングを作成する移植性のある方法は、 I<addr> に 0 (NULL) を指定し、 "
"I<flags> から B<MAP_FIXED> を外すことである。 この場合、システムがマッピング"
"用のアドレスの選択を行う。 アドレスは既存のマッピングと衝突しないように、 か"
"つ 0 にならないように選択される。 B<MAP_FIXED> フラグが指定され、かつ "
"I<addr> が 0 (NULL)  の場合には、マップされるアドレスが 0 (NULL) になる。"

#. type: Plain text
#: build/C/man2/mmap.2:587
msgid ""
"Certain I<flags> constants are defined only if either B<_BSD_SOURCE> or "
"B<_SVID_SOURCE> is defined.  (Requiring B<_GNU_SOURCE> also suffices, and "
"requiring that macro specifically would have been more logical, since these "
"flags are all Linux specific.)  The relevant flags are: B<MAP_32BIT>, "
"B<MAP_ANONYMOUS> (and the synonym B<MAP_ANON>), B<MAP_DENYWRITE>, "
"B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, "
"B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE>, and "
"B<MAP_STACK>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:592
msgid ""
"On Linux there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""
"Linux においては、上記の B<MAP_NORESERVE> で述べられているような保証はない。 "
"デフォルトでは、システムがメモリを使い切った場合には、 どのプロセスがいつ強制"
"終了されるか分からないからである。"

#. type: Plain text
#: build/C/man2/mmap.2:599
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag only has effect if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""
"2.6.7 より前のカーネルでは、 I<prot> に B<PROT_NONE> が指定された場合にの"
"み、 B<MAP_POPULATE> フラグが効力を持つ。"

#. type: Plain text
#: build/C/man2/mmap.2:614
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""
"SUSv3 では、 I<length> が 0 の場合、 B<mmap>()  は失敗すると規定されている。"
"しかしながら、2.6.12 より前のカーネルでは、 この場合に B<mmap>()  は成功して"
"いた (マッピングは作成されず、 I<addr> が返されていた)。 カーネル 2.6.12 以降"
"では、 B<mmap>()  はエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/mmap.2:630
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on tmpfs (for example, "
"when using POSIX shared memory interface documented in B<shm_overview>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:642
msgid ""
"The following program prints part of the file specified in its first command-"
"line argument to standard output.  The range of bytes to be printed is "
"specified via offset and length values in the second and third command-line "
"arguments.  The program creates a memory mapping of the required pages of "
"the file and then uses B<write>(2)  to output the desired bytes."
msgstr ""
"以下のプログラムは、一番目のコマンドライン引き数で指定された ファイルの一部を"
"標準出力に表示する。 表示する範囲は、二番目、三番目のコマンドライン引き数で渡"
"される オフセットと長さで指定される。 このプログラムは、指定されたファイルの"
"必要なページのメモリ・ マッピングを作成し、 B<write>(2)  を使って所望のバイト"
"を出力する。"

#. type: Plain text
#: build/C/man2/mmap.2:650
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/mmap.2:653 build/C/man2/mprotect.2:178
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/mmap.2:663
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/mmap.2:668
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:672
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:675
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:679
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"

#. type: Plain text
#: build/C/man2/mmap.2:684
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:690
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"

#. type: Plain text
#: build/C/man2/mmap.2:694
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:699
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:704
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"

#. type: Plain text
#: build/C/man2/mmap.2:708
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/mmap.2:725
msgid ""
"B<getpagesize>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), "
"B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>"
"(2), B<shm_open>(3), B<shm_overview>(7)"
msgstr ""
"B<getpagesize>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), "
"B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), B<shmat>"
"(2), B<shm_open>(3), B<shm_overview>(7)"

#. type: Plain text
#: build/C/man2/mmap.2:730 build/C/man2/msync.2:122
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391."
msgstr "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391."

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr "MMAP2"

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "2012-04-16"
msgstr "2012-04-16"

#. type: Plain text
#: build/C/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr "mmap2 - ファイルやデバイスをメモリにマップする"

#. type: Plain text
#: build/C/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<            int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"

#. type: Plain text
#: build/C/man2/mmap2.2:43
msgid ""
"This is probably not the system call you are interested; instead, see B<mmap>"
"(2), which describes the glibc wrapper function that invokes this system "
"call."
msgstr ""
"これはおそらくあなたが興味のあるシステムコールではないだろう。代わりに\n"
"B<mmap>(2) を見るとよい。そのページにはこのシステムコールを起動する glibc "
"の\n"
"ラッパー関数についての説明がある。"

#. type: Plain text
#: build/C/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in 4096-"
"byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""
"B<mmap2>() システムコールは B<mmap>(2) と同じインターフェースを提供する。た"
"だ\n"
"し、最後の引き数には、ファイルのオフセットを (B<mmap>(2) が行っている、バイ"
"ト\n"
"単位ではなく) 4096 バイトを単位として指定する。 これにより、32 ビットの\n"
"I<off_t> を使うアプリケーションで (2^44 バイトまでの) 大きなファイルをマッ"
"プ\n"
"できるようになる。"

#. type: Plain text
#: build/C/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error -1 "
"is returned and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<mmap2>()  はマップされた領域へのポインタを返す。 エラーの場"
"合は -1 が返されて、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/mmap2.2:65
#, fuzzy
#| msgid "Problem with getting the data from userspace."
msgid "Problem with getting the data from user space."
msgstr "ユーザ空間からデータを取得するときに問題があった。"

#. type: Plain text
#: build/C/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset * 4096> "
"is not a multiple of the system page size."
msgstr ""
"(ページサイズが 4096 バイトでないプラットフォームにおいて)  I<offset * 4096> "
"がシステムのページサイズの倍数ではない。"

#. type: Plain text
#: build/C/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr "B<mmap2>() は B<mmap>(2) に載っているエラーを返すこともある。"

#. type: Plain text
#: build/C/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr "B<mmap2>()  は、Linux 2.3.31 以降で使用可能である。"

#. type: Plain text
#: build/C/man2/mmap2.2:79 build/C/man2/subpage_prot.2:98
msgid "This system call is Linux-specific."
msgstr "このシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/mmap2.2:85
msgid ""
"Nowadays, the glibc B<mmap>()  wrapper function invokes this system call "
"rather than the B<mmap>(2)  system call."
msgstr ""
"現在では、glibc の B<mmap>()  のラッパー関数は、 B<mmap>(2)  システムコールで"
"はなく、このシステムコール (B<mmap2>(2))  を起動する。"

#.  ia64 can have page sizes ranging from 4kB to 64kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: build/C/man2/mmap2.2:92
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""
"ia64 では、 I<offset> の単位は、実際にはシステムのページサイズであり、 4096 "
"バイトではない。"

#. type: Plain text
#: build/C/man2/mmap2.2:98
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""
"B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"

#. type: TH
#: build/C/man2/mprotect.2:38
#, no-wrap
msgid "MPROTECT"
msgstr "MPROTECT"

#. type: TH
#: build/C/man2/mprotect.2:38
#, fuzzy, no-wrap
#| msgid "2012-05-04"
msgid "2012-08-14"
msgstr "2012-05-04"

#. type: Plain text
#: build/C/man2/mprotect.2:41
msgid "mprotect - set protection on a region of memory"
msgstr "mprotect - メモリ領域の保護を設定する"

#. type: Plain text
#: build/C/man2/mprotect.2:46
#, fuzzy, no-wrap
#| msgid "B<int mprotect(const void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr "B<int mprotect(const void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"

#. type: Plain text
#: build/C/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes protection for the calling process's memory page(s)  "
"containing any part of the address range in the interval [I<addr>,\\ I<addr>"
"+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""
"B<mprotect>()  は、区間 [I<addr>,\\ I<addr>+I<len>-1] のアドレス範囲を含む 呼"
"び出し元のプロセスのメモリページのアクセス保護を変更する。 I<addr> はページ境"
"界に一致していなければならない。"

#. type: Plain text
#: build/C/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protection, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""
"呼び出し元のプロセスがアクセス保護に違反するようなメモリアクセスを 行おうとす"
"ると、カーネルはシグナル B<SIGSEGV> をそのプロセスに対して生成する。"

#. type: Plain text
#: build/C/man2/mprotect.2:64
msgid ""
"I<prot> is either B<PROT_NONE> or a bitwise-or of the other values in the "
"following list:"
msgstr ""
"I<prot> には、 B<PROT_NONE> か、以下のリストの B<PROT_NONE> 以外の値をビット"
"毎の論理和 (bitwize-or) で指定する:"

#. type: Plain text
#: build/C/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr "そのメモリには全くアクセスできない。"

#. type: Plain text
#: build/C/man2/mprotect.2:70
msgid "The memory can be read."
msgstr "そのメモリを読み取ることができる。"

#. type: Plain text
#: build/C/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr "そのメモリを変更できる。"

#.  FIXME
#.  Document PROT_GROWSUP and PROT_GROWSDOWN
#. type: Plain text
#: build/C/man2/mprotect.2:78
msgid "The memory can be executed."
msgstr "そのメモリは実行可能である。"

#. type: Plain text
#: build/C/man2/mprotect.2:85
msgid ""
"On success, B<mprotect>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<mprotect>()  は 0 を返す。エラーの場合は -1 が返り、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/mprotect.2:95
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""
"指定されたアクセスをメモリに設定することができない。 これは、例えば ファイル"
"を読み取り専用で B<mmap>(2)  しており、その領域に対して B<mprotect>()  を呼び"
"出して B<PROT_WRITE> に設定しようとした場合に発生する。"

#.  Or: both PROT_GROWSUP and PROT_GROWSDOWN were specified in 'prot'.
#. type: Plain text
#: build/C/man2/mprotect.2:100
msgid ""
"I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""
"I<addr> が有効なポインタでないか、 システムのページサイズの倍数でない。"

#. type: Plain text
#: build/C/man2/mprotect.2:103
msgid "Internal kernel structures could not be allocated."
msgstr "カーネル内部の構造体を割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/mprotect.2:113
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced "
"for these cases.)"
msgstr ""
"[I<addr>, I<addr>+I<len>-1] という範囲のアドレスがプロセスのアドレス空間とし"
"て不正であるか、 その範囲のアドレスがマップされていない 1 つ以上のページを指"
"している (カーネル 2.4.19 より前では、この状況でエラー B<EFAULT> が間違って生"
"成されていた)。"

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: build/C/man2/mprotect.2:122
msgid ""
"SVr4, POSIX.1-2001.  POSIX says that the behavior of B<mprotect>()  is "
"unspecified if it is applied to a region of memory that was not obtained via "
"B<mmap>(2)."
msgstr ""
"SVr4, POSIX.1-2001.  POSIX では、 B<mmap>(2)  経由で獲得していないメモリ領域"
"に対して B<mprotect>()  を行った場合の B<mprotect>()  の動作は未定義であると"
"されている。"

#. type: Plain text
#: build/C/man2/mprotect.2:129
msgid ""
"On Linux it is always permissible to call B<mprotect>()  on any address in a "
"process's address space (except for the kernel vsyscall area).  In "
"particular it can be used to change existing code mappings to be writable."
msgstr ""
"Linux では、(カーネル vsyscall 領域以外の)  任意のプロセスアドレス空間に対し"
"て B<mprotect>()  を呼び出すことが、常に許されている。 これは特に既存のコード"
"マッピングを書き込み可能にするために使われる。"

#. type: Plain text
#: build/C/man2/mprotect.2:139
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> is "
"architecture- and kernel version-dependent.  On some hardware architectures "
"(e.g., i386), B<PROT_WRITE> implies B<PROT_READ>."
msgstr ""
"B<PROT_EXEC> が B<PROT_READ> と異なる影響を持つか否かは、アーキテクチャとカー"
"ネルのバージョンに依存する。 (i386 などの) いくつかのアーキテクチャでは、 "
"B<PROT_WRITE> をセットすると、暗黙のうちに B<PROT_READ> がセットされる。"

#. type: Plain text
#: build/C/man2/mprotect.2:148
msgid ""
"POSIX.1-2001 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can only allow write access if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr ""
"POSIX.1-2001 では、 I<prot> で指定されていないアクセスを許可する実装を認めて"
"いる。 ただし、最低限、 B<PROT_WRITE> がセットされている場合にのみ書き込みア"
"クセスが許可され、 B<PROT_NONE> がセットされている場合にはアクセスは許可され"
"ない点だけは 満たす必要がある。"

#. type: Plain text
#: build/C/man2/mprotect.2:154
msgid ""
"The program below allocates four pages of memory, makes the third of these "
"pages read-only, and then executes a loop that walks upward through the "
"allocated region modifying bytes."
msgstr ""
"以下のプログラムは、メモリページを 4つ確保し、そのうち 3番目のページを 読み込"
"み専用に設定する。その後で、確保した領域のアドレスの小さい方から 大きな方に向"
"かって順番にバイト値を変更するループを実行する。"

#. type: Plain text
#: build/C/man2/mprotect.2:157
msgid ""
"An example of what we might see when running the program is the following:"
msgstr "プログラムを実行した場合の一例を以下に示す。"

#. type: Plain text
#: build/C/man2/mprotect.2:163
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"

#. type: Plain text
#: build/C/man2/mprotect.2:175
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"

#. type: Plain text
#: build/C/man2/mprotect.2:180
#, no-wrap
msgid "char *buffer;\n"
msgstr "char *buffer;\n"

#. type: Plain text
#: build/C/man2/mprotect.2:188
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/mprotect.2:195
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"

#. type: Plain text
#: build/C/man2/mprotect.2:201
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:205
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:208
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"

#. type: Plain text
#: build/C/man2/mprotect.2:212
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:214
#, no-wrap
msgid "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"
msgstr "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"

#. type: Plain text
#: build/C/man2/mprotect.2:218
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"

#. type: Plain text
#: build/C/man2/mprotect.2:221
#, no-wrap
msgid ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"

#. type: Plain text
#: build/C/man2/mprotect.2:225
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/mprotect.2:229
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr "B<mmap>(2), B<sysconf>(3)"

#. type: TH
#: build/C/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr "MREMAP"

#. type: TH
#: build/C/man2/mremap.2:30
#, no-wrap
msgid "2010-06-10"
msgstr "2010-06-10"

#. type: Plain text
#: build/C/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr "mremap - 仮想メモリ・アドレスを再マッピングする"

#. type: Plain text
#: build/C/man2/mremap.2:36
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man2/mremap.2:41
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"
msgstr ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void *>I<new_address>B< */);>\n"

#. type: Plain text
#: build/C/man2/mremap.2:47
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""
"B<mremap>()  は既存のメモリ・マッピングの拡張 (または縮小) を行う。 同時に移"
"動されることもある (I<flags> 引き数と利用可能な仮想アドレス空間によって決ま"
"る)。"

#. type: Plain text
#: build/C/man2/mremap.2:61
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the "
"requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""
"I<old_address> は拡張 (または縮小) しようとする仮想メモリ・ブロック の元のア"
"ドレスである。I<old_address> はページ境界に合っていなければ ならない点に注意"
"すること。I<old_size> は元の仮想メモリ・ブロックの サイズである。 "
"I<new_size> は要求する変更後の仮想メモリ・ブロックのサイズである。 5 番目の引"
"き数として I<new_address> を指定することができる。下記の B<MREMAP_FIXED> の説"
"明を参照のこと。"

#. type: Plain text
#: build/C/man2/mremap.2:73
msgid ""
"In Linux the memory is divided into pages.  A user process has (one or)  "
"several linear virtual memory segments.  Each virtual memory segment has one "
"or more mappings to real memory pages (in the page table).  Each virtual "
"memory segment has its own protection (access rights), which may cause a "
"segmentation violation if the memory is accessed incorrectly (e.g., writing "
"to a read-only segment).  Accessing virtual memory outside of the segments "
"will also cause a segmentation violation."
msgstr ""
"Linux ではメモリはページに分割される。ユーザー・プロセスは (一つまたは)  複数"
"のリニアな仮想メモリセグメントを持つ。 それぞれの仮想メモリセグメントは一つ以"
"上の実メモリ・ページ にマッピングされている (マッピング情報はページ・テーブル"
"で管理される)。 仮想メモリセグメントにはセグメント毎の保護 (アクセス権) が設"
"定されており、 メモリが不正にアクセスされた場合 (例えば読み込み専用のセグメン"
"トに 書き込んだ場合)、セグメンテーション侵害 (segmentation violation) を 引き"
"起こす。また、セグメント外の仮想メモリにアクセスした場合にも セグメンテーショ"
"ン侵害が発生する。"

#. type: Plain text
#: build/C/man2/mremap.2:81
msgid ""
"B<mremap>()  uses the Linux page table scheme.  B<mremap>()  changes the "
"mapping between virtual addresses and memory pages.  This can be used to "
"implement a very efficient B<realloc>(3)."
msgstr ""
"B<mremap>()  は Linux のページ・テーブル方式を使用する。 B<mremap>()  は仮想"
"アドレスとメモリ・ページのマッピングを変更する。これは非常に効率的な "
"B<realloc>(3)  を実装するのに使用されている。"

#. type: Plain text
#: build/C/man2/mremap.2:83
msgid "The I<flags> bit-mask argument may be 0, or include the following flag:"
msgstr "I<flags> ビットマスク引数は 0 または以下のフラグを含む:"

#. type: TP
#: build/C/man2/mremap.2:83
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr "B<MREMAP_MAYMOVE>"

#. type: Plain text
#: build/C/man2/mremap.2:95
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if "
"necessary.  If the mapping is relocated, then absolute pointers into the old "
"mapping location become invalid (offsets relative to the starting address of "
"the mapping should be employed)."
msgstr ""
"デフォルトでは、現在の位置にマッピングを拡張するための 十分な空きがなければ "
"B<mremap>()  は失敗する。 このフラグが指定されると、カーネルは必要があれば"
"マッピングを 新しい仮想アドレスに再配置することができる マッピングが再配置さ"
"れると、古いマッピング位置への絶対ポインタは 無効になる (マッピングの開始アド"
"レスからの相対オフセットは有効のままである)。"

#. type: TP
#: build/C/man2/mremap.2:95
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr "B<MREMAP_FIXED> (Linux 2.3.31 以降)"

#. type: Plain text
#: build/C/man2/mremap.2:117
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped.  If B<MREMAP_FIXED> is "
"specified, then B<MREMAP_MAYMOVE> must also be specified."
msgstr ""
"このフラグは B<mmap>(2)  の B<MAP_FIXED> フラグと似たような目的で用いられ"
"る。 このフラグが指定されると、 B<mremap>()  は 5 番目の引き数 I<void "
"*new_address> を受け取り、この引数はマッピングが移動されるべきアドレスを指定"
"する。 このアドレスはページ境界に合っていなければならない。 I<new_address> "
"と I<new_size> で指定されるアドレス範囲に過去のマッピングがあった場合、 その"
"マッピングはアンマップされる (unmapped)。 B<MREMAP_FIXED> を指定した場合は、 "
"B<MREMAP_MAYMOVE> も指定しなければならない。"

#. type: Plain text
#: build/C/man2/mremap.2:127
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory "
"locked by the process may change."
msgstr ""
"I<old_address> と I<old_size> で指定されるメモリセグメントが (B<mlock>(2)  や"
"同様のもので) ロックされている場合、セグメントのサイズが変わったり 再配置され"
"たりした時にロックも維持される。 その結果、プロセスによってロックされるメモリ"
"の量は変化する。"

#. type: Plain text
#: build/C/man2/mremap.2:135
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned, "
"and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<mremap>()  は新しい仮想メモリ領域へのポインタを返す。 エラー"
"の場合は B<MAP_FAILED> (すなわち I<(void\\ *)\\ -1>) が返され、 I<errno> が適"
"切に設定される。"

#. type: Plain text
#: build/C/man2/mremap.2:142
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not "
"possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""
"呼び出し元がロックされているメモリセグメントを拡張しようとしたが、 "
"B<RLIMIT_MEMLOCK> リソース制限を越えずにこれを行うことができない。"

#. type: Plain text
#: build/C/man2/mremap.2:151
msgid ""
"\"Segmentation fault.\" Some address in the range I<old_address> to "
"I<old_address>+I<old_size> is an invalid virtual memory address for this "
"process.  You can also get B<EFAULT> even if there exist mappings that cover "
"the whole address space requested, but those mappings are of different types."
msgstr ""
"「セグメンテーション違反(segmentation fault)」 I<old_address> から "
"I<old_address>+I<old_size> の 範囲のアドレスのどれかがこのプロセスにおいて不"
"正な仮想メモリ・アドレスである。 たとえ要求したアドレス空間全体を含むような"
"マッピングがあったとしても、 それらのマッピングが異なった型ならば B<EFAULT> "
"を受け取るだろう。"

#. type: Plain text
#: build/C/man2/mremap.2:179
msgid ""
"An invalid argument was given.  Possible causes are: I<old_address> was not "
"page aligned; a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> was "
"specified in I<flags>; I<new_size> was zero; I<new_size> or I<new_address> "
"was invalid; or the new address range specified by I<new_address> and "
"I<new_size> overlapped the old address range specified by I<old_address> and "
"I<old_size>; or B<MREMAP_FIXED> was specified without also specifying "
"B<MREMAP_MAYMOVE>."
msgstr ""
"不正な引き数が与えられた。 可能性のある原因は以下の通りである: たいていは "
"I<old_address> がページ境界に 合ってない; I<flags> に B<MREMAP_MAYMOVE> また"
"は B<MREMAP_FIXED> 以外の値が指定されている; I<new_size> がゼロ; I<new_size> "
"または I<new_address> の値が不正; I<new_address> と I<new_size> で指定される"
"新しいアドレス範囲が I<old_address> と I<old_size> で指定される古いアドレス範"
"囲と重なっている; B<MREMAP_FIXED> が指定されているが B<MREMAP_MAYMOVE> が指定"
"されていない。"

#. type: Plain text
#: build/C/man2/mremap.2:185
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""
"現在の仮想アドレスではメモリ領域が拡張できず、 B<MREMAP_MAYMOVE> フラグが "
"I<flags> に設定されていない。 または十分な (仮想) メモリが存在しない。"

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: build/C/man2/mremap.2:191
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで 使用すべきではな"
"い。"

#. type: Plain text
#: build/C/man2/mremap.2:199
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""
"バージョン 2.4 より前の glibc では、 B<MREMAP_FIXED> の定義は公開されておら"
"ず、 B<mremap>()  のプロトタイプは I<new_address> 引き数を取らなかった。"

#. type: Plain text
#: build/C/man2/mremap.2:208
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<realloc>(3), B<malloc>(3)"

#. type: Plain text
#: build/C/man2/mremap.2:214
#, fuzzy
#| msgid ""
#| "Your favorite OS text book for more information on paged memory.  "
#| "(I<Modern Operating Systems> by Andrew S. Tanenbaum, I<Inside Linux> by "
#| "Randolf Bentson, I<The Design of the UNIX Operating System> by Maurice J. "
#| "Bach.)"
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S. Tanenbaum, I<Inside "
"Linux> by Randolf Bentson, I<The Design of the UNIX Operating System> by "
"Maurice J. Bach)"
msgstr ""
"ページ分割されたメモリについてもっと詳しく知りたいならば あなたの好みの OS "
"の\n"
"教科書を参照すること。 (I<Modern Operating Systems> by Andrew S. Tanenbaum,\n"
"I<Inside Linux> by Randolf Bentson, I<The Design of the UNIX Operating\n"
"System> by Maurice J. Bach.)"

#. type: TH
#: build/C/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr "MSYNC"

#. type: TH
#: build/C/man2/msync.2:25 build/C/man2/remap_file_pages.2:28
#, no-wrap
msgid "2008-04-22"
msgstr "2008-04-22"

#. type: Plain text
#: build/C/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr "msync - ファイルをマップしたメモリと同期させる"

#. type: Plain text
#: build/C/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to disk.  Without use of this call "
"there is no guarantee that changes are written back before B<munmap>(2)  is "
"called.  To be more precise, the part of the file that corresponds to the "
"memory area starting at I<addr> and having length I<length> is updated."
msgstr ""
"B<msync>()  は B<mmap>(2)  を使ってメモリにマップされたファイルの、 メモリ上"
"のコピーになされた変更をディスクに反映させる。 この関数を使用しないと、 "
"B<munmap>(2)  が呼び出されるまで変更が書き戻される保証はない。 より正確には、"
"ファイルのうち I<addr> から始まり長さ I<length> のメモリ領域に対応する部分が"
"更新される。"

#. type: Plain text
#: build/C/man2/msync.2:68
msgid ""
"The I<flags> argument may have the bits B<MS_ASYNC>, B<MS_SYNC>, and "
"B<MS_INVALIDATE> set, but not both B<MS_ASYNC> and B<MS_SYNC>.  B<MS_ASYNC> "
"specifies that an update be scheduled, but the call returns immediately.  "
"B<MS_SYNC> asks for an update and waits for it to complete.  "
"B<MS_INVALIDATE> asks to invalidate other mappings of the same file (so that "
"they can be updated with the fresh values just written)."
msgstr ""
"I<flags> 引数にはビット B<MS_ASYNC>, B<MS_SYNC>, B<MS_INVALIDATE> を設定する"
"ことができるが、 B<MS_ASYNC> と B<MS_SYNC> を同時に指定することはできない。 "
"B<MS_ASYNC> は更新を予定に組み込むことを表し、呼び出しは直ちに返る。 "
"B<MS_SYNC> は更新を要求し、更新が完了するまで待つ。 B<MS_INVALIDATE> は(たっ"
"た今書き込んだ新しい値でマッピングを更新することができるように)  同じファイル"
"に対する他のマッピングを無効にすることを要求する。"

#. type: Plain text
#: build/C/man2/msync.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、 0 が返る。エラーの場合、 -1 が返り、 I<errno> が適切に設定され"
"る。"

#. type: TP
#: build/C/man2/msync.2:74
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/msync.2:80
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the "
"specified address range."
msgstr ""
"I flags に B<MS_INVALIDATE> が指定されたが、指定されたアドレス範囲にロックが"
"存在する。"

#. type: Plain text
#: build/C/man2/msync.2:93
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""
"I<addr> が PAGESIZE の倍数でない。または、 I<flags> に B<MS_ASYNC>、"
"B<MS_INVALIDATE>、B<MS_SYNC> 以外のビットが設定された。 または、 I<flags> に "
"B<MS_SYNC> と B<MS_ASYNC> の両方が設定された。"

#. type: Plain text
#: build/C/man2/msync.2:96
msgid "The indicated memory (or part of it) was not mapped."
msgstr "指定されたメモリ (またはその一部) がマップされていない。"

#. type: Plain text
#: build/C/man2/msync.2:98 build/C/man3/posix_fallocate.3:105
#: build/C/man3/shm_open.3:251 build/C/man7/shm_overview.7:103
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man2/msync.2:105
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of "
"B<ENOMEM>.  In Linux 2.4.19 this was changed to the POSIX value B<ENOMEM>."
msgstr ""
"この関数は Linux 1.3.21 で導入されたが、 B<ENOMEM> ではなく B<EFAULT> が使わ"
"れていた。 これは Linux 2.4.19 で POSIX における値 B<ENOMEM> に変更された。"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/msync.2:118
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<msync>()  が使用可能な POSIX システムでは B<_POSIX_MAPPED_FILES> と "
"B<_POSIX_SYNCHRONIZED_IO> の両方が I<E<lt>unistd.hE<gt>> で 0 より大きい値に"
"定義される。 (B<sysconf>(3)  を参照すること。 )"

#. type: TP
#: build/C/man2/msync.2:120 build/C/man7/shm_overview.7:46
#, no-wrap
msgid "B<mmap>(2)"
msgstr "B<mmap>(2)"

#. type: TH
#: build/C/man3/mtrace.3:25
#, no-wrap
msgid "MTRACE"
msgstr "MTRACE"

#. type: Plain text
#: build/C/man3/mtrace.3:28
msgid "mtrace, muntrace - malloc tracing"
msgstr "mtrace, muntrace - malloc のトレース"

#. type: Plain text
#: build/C/man3/mtrace.3:30
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr "B<#include E<lt>mcheck.hE<gt>>"

#. type: Plain text
#: build/C/man3/mtrace.3:32
msgid "B<void mtrace(void);>"
msgstr "B<void mtrace(void);>"

#. type: Plain text
#: build/C/man3/mtrace.3:34
msgid "B<void muntrace(void);>"
msgstr "B<void muntrace(void);>"

#. type: Plain text
#: build/C/man3/mtrace.3:46
msgid ""
"The B<mtrace>()  function installs hook functions for the memory-allocation "
"functions (B<malloc>(3), B<realloc>(3)  B<memalign>(3), B<free>(3)).  These "
"hook functions record tracing information about memory allocation and "
"deallocation.  The tracing information can be used to discover memory leaks "
"and attempts to free nonallocated memory in a program."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:57
msgid ""
"The B<muntrace>()  function disables the hook functions installed by "
"B<mtrace>(), so that tracing information is no longer recorded for the "
"memory-allocation functions.  If no hook functions were successfully "
"installed by B<mtrace>(), B<muntrace>()  does nothing."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:65
msgid ""
"When B<mtrace>()  is called, it checks the value of the environment variable "
"B<MALLOC_TRACE>, which should contain the pathname of a file in which the "
"tracing information is to be recorded.  If the pathname is successfully "
"opened, it is truncated to zero length."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:78
msgid ""
"If B<MALLOC_TRACE> is not set, or the pathname it specifies is invalid or "
"not writable, then no hook functions are installed, and B<mtrace>()  has no "
"effect.  In set-user-ID and set-group-ID programs, B<MALLOC_TRACE> is "
"ignored, and B<mtrace>()  has no effect."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:86
msgid ""
"In normal usage, B<mtrace>()  is called once at the start of execution of a "
"program, and B<muntrace>()  is never called."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:96
msgid ""
"The tracing output produced after a call to B<mtrace>()  is textual, but not "
"designed to be human readable.  The GNU C library provides a Perl script, "
"B<mtrace>(1), that interprets the trace log and produces human-readable "
"output.  For best results, the traced program should be compiled with "
"debugging enabled, so that line-number information is recorded in the "
"executable."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:102
msgid ""
"The tracing performed by B<mtrace>()  incurs a performance penalty (if "
"B<MALLOC_TRACE> points to a valid, writable pathname)."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:108
msgid ""
"The line-number information produced by B<mtrace>(1)  is not always precise: "
"the line number references may refer to the previous or following (non-"
"blank)  line of the source code."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:115
msgid ""
"The shell session below demonstrates the use of the B<mtrace>()  function "
"and the B<mtrace>(1)  command in a program that has memory leaks at two "
"different locations.  The demonstration uses the following program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:122
#, no-wrap
msgid ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mtrace.3:127
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: build/C/man3/mtrace.3:129
#, no-wrap
msgid "    mtrace();\n"
msgstr "    mtrace();\n"

#. type: Plain text
#: build/C/man3/mtrace.3:132
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"
msgstr ""
"    for (j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"

#. type: Plain text
#: build/C/man3/mtrace.3:136
#, no-wrap
msgid ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/mtrace.3:142
msgid ""
"When we run the program as follows, we see that B<mtrace>()  diagnosed "
"memory leaks at two different locations in the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:155
#, no-wrap
msgid ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"
msgstr ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"

#. type: Plain text
#: build/C/man3/mtrace.3:167
msgid ""
"The first two messages about unfreed memory correspond to the two B<malloc>"
"(3)  calls inside the I<for> loop.  The final message corresponds to the "
"call to B<calloc>(3)  (which in turn calls B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:172
msgid "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"
msgstr "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"

#. type: TH
#: build/C/man2/posix_fadvise.2:28
#, no-wrap
msgid "POSIX_FADVISE"
msgstr "POSIX_FADVISE"

#. type: TH
#: build/C/man2/posix_fadvise.2:28 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "2010-10-09"
msgstr "2010-10-09"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:31
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr "posix_fadvise - ファイルデータのアクセスパターンをあらかじめ宣言する"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:34 build/C/man3/posix_fallocate.3:31
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr "B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:37
#, no-wrap
msgid "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"
msgstr "B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int >I<advice>B<);>\n"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:46
msgid "B<posix_fadvise>():"
msgstr "B<posix_fadvise>():"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:48 build/C/man3/posix_fallocate.3:44
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:56
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""
"プログラムは、将来特定のパターンでファイルデータに アクセスする意思を伝えるた"
"めに B<posix_fadvise>()  を使うことができる。 これにより、カーネルが適切な最"
"適化を実行することが可能になる。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:63
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""
"I<advice> は I<fd> が参照しているファイルの I<offset> から始まる I<len> バ"
"イ\n"
"トの範囲内 (I<len> が 0 の場合はファイルの終りまで) の (必ずしも存在しない)\n"
"領域に適用される。 I<advice> は義務づけではない。 I<advice> は単にアプリ"
"ケー\n"
"ションのために可能性を構成するだけである。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:65
msgid "Permissible values for I<advice> include:"
msgstr "I<advice> に許される値には、以下のものが含まれる:"

#. type: TP
#: build/C/man2/posix_fadvise.2:65
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr "B<POSIX_FADV_NORMAL>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:71
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""
"指定されたデータのアクセスパターンを指示するアドバイスを アプリケーションが何"
"も持っていないことを示す。 オープンされたファイルにアドバイスが指定されない場"
"合、 これがデフォルトで仮定される。"

#. type: TP
#: build/C/man2/posix_fadvise.2:71
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr "B<POSIX_FADV_SEQUENTIAL>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:75
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""
"アプリケーションは指定されたデータがシーケンシャルに (大きなオフセットの前に"
"小さなオフセットのデータを読むように)  アクセスされることを期待する。"

#. type: TP
#: build/C/man2/posix_fadvise.2:75
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr "B<POSIX_FADV_RANDOM>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:78
msgid "The specified data will be accessed in random order."
msgstr "指定されたデータがランダムな順番でアクセスされる。"

#. type: TP
#: build/C/man2/posix_fadvise.2:78
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr "B<POSIX_FADV_NOREUSE>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:81
msgid "The specified data will be accessed only once."
msgstr "指定されたデータは 1 度しかアクセスされない。"

#. type: TP
#: build/C/man2/posix_fadvise.2:81
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr "B<POSIX_FADV_WILLNEED>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:84
msgid "The specified data will be accessed in the near future."
msgstr "指定されたデータは近い将来アクセスされる。"

#. type: TP
#: build/C/man2/posix_fadvise.2:84
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr "B<POSIX_FADV_DONTNEED>"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:87
msgid "The specified data will not be accessed in the near future."
msgstr "指定されたデータは近い将来アクセスされない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:90
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr "成功した場合は 0 が返される。 失敗した場合はエラー番号が返される。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:94
msgid "The I<fd> argument was not a valid file descriptor."
msgstr "I<fd> 引き数が有効なファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:97
msgid "An invalid value was specified for I<advice>."
msgstr "無効な値が I<advice> に指定された。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:104
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (Linux actually "
"returns B<EINVAL> in this case.)"
msgstr ""
"指定されたファイルディスクリプタがパイプまたは FIFO を参照している (この場"
"合、Linux は実際には B<EINVAL> を返す)。"

#.  of fadvise64_64()
#. type: Plain text
#: build/C/man2/posix_fadvise.2:112
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""
"カーネルによるサポートは Linux 2.5.60 で最初に登場し、\n"
"対応するシステムコールは B<fadvise64>() という名前である。\n"
"ライブラリによるサポートは glibc バージョン 2.2 以降で提供されており、\n"
"ラッパー関数は B<posix_fadvise>() という名前である。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:121
msgid ""
"POSIX.1-2001.  Note that the type of the I<len> argument was changed from "
"I<size_t> to I<off_t> in POSIX.1-2003 TC1."
msgstr ""
"POSIX.1-2001.  I<len> 引き数の型が POSIX.1-2003 TC1 において I<size_t> から "
"I<off_t> に変更された点に注意すること。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:127
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""
"Linux では、B<POSIX_FADV_NORMAL> はバッキングデバイスの デフォルトサイズに先"
"読み (readahead) ウインドウを設定する。 B<POSIX_FADV_SEQUENTIAL> はこのサイズ"
"を 2 倍し、 B<POSIX_FADV_RANDOM> は先読みを全く無効にする。 これらの変更は"
"ファイル全体に影響し、指定された領域のみに影響するわけではない (しかし同じ"
"ファイルに対する他のオープンファイルハンドルは影響を受けない)。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:134
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""
"B<POSIX_FADV_WILLNEED> は、 ページキャッシュに指定領域のブロックされない読み"
"込みを開始する。 読み込まれるデータの総量は、 仮想メモリの負荷に依ってカーネ"
"ルが減らすかもしれない (数メガバイトであれば通常は全く十分であり、 それより多"
"くてもめったに役に立たない)。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:138
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""
"2.6.18 より前のカーネルでは、B<POSIX_FADV_NOREUSE> は B<POSIX_FADV_WILLNEED> "
"と同じ意味であった。 これは多分バグであった。 カーネル 2.6.18 以降では、この"
"フラグは何も行わない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:146
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""
"B<POSIX_FADV_DONTNEED> は指定された領域に関連付けられた キャッシュページを解"
"放しようとする。 例えば、これは大きなファイルをストリーミングするときに役立"
"つ。 プログラムは、使用済みのキャッシュされたデータを解放するように、 定期的"
"にカーネルに要求するかもしれない。 そうすることにより、さらに有効なキャッシュ"
"されたページが、 代わりに破棄されることはない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:154
msgid ""
"Pages that have not yet been written out will be unaffected, so if the "
"application wishes to guarantee that pages will be released, it should call "
"B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""
"まだ書き出されていないページは影響を受けないので、 そのページの解放が保証され"
"ることをアプリケーションが望んでいるなら、 最初に B<fsync>(2)  または "
"B<fdatasync>(2)  を呼ぶべきである。"

#. type: SS
#: build/C/man2/posix_fadvise.2:154
#, no-wrap
msgid "arm_fadvise()"
msgstr "arm_fadvise()"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:166
msgid ""
"The ARM architecture needs 64-bit arguments to be aligned in a suitable pair "
"of registers.  On this architecture, the call signature of B<posix_fadvise>"
"()  is flawed, since it forces a register to be wasted as padding between "
"the I<fd> and I<len> arguments.  Therefore, since Linux 2.6.14, ARM defines "
"a different system call that orders the arguments suitably:"
msgstr ""
"ARM アーキテクチャでは、64 ビットの引き数は適切なレジスタの組に割り当て\n"
"る必要がある。このアーキテクチャでは、B<posix_fadvise>() の呼び出し方に\n"
"は欠陥があり、それはこのシステムコールでは引き数 I<fd> と I<len> の間の\n"
"パディング (詰めもの) でレジスタが一つ消費されてしまうというものである。\n"
"そのため、Linux 2.6.14 以降では、ARM では引き数が適切な順序になった別の\n"
"システムコールが定義されている。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:171
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"

#.  No ARM support in glibc.
#. type: Plain text
#: build/C/man2/posix_fadvise.2:178
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<posix_fadvise>().  No library support is provided for this system call in "
"glibc."
msgstr ""
"上記の点以外は、このシステムコールの動作は B<posix_fadvise>() と全く\n"
"同じである。このシステムコールに対するライブラリによるサポートは glibc\n"
"では提供されていない。"

#. type: Plain text
#: build/C/man2/posix_fadvise.2:183
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""
"2.6.6 より前のカーネルでは、 I<len> に 0 が指定された場合、 「ファイルの終り"
"までの全てのバイト」という意味ではなく、 文字通り「0 バイト」として解釈されて"
"いた。"

#.  FIXME . Write a posix_fadvise(3) page.
#. type: Plain text
#: build/C/man2/posix_fadvise.2:189
msgid ""
"B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3), "
"B<posix_madvise>(3)"
msgstr ""
"B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3),\n"
"B<posix_madvise>(3)"

#. type: TH
#: build/C/man3/posix_fallocate.3:25
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr "POSIX_FALLOCATE"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:28
msgid "posix_fallocate - allocate file space"
msgstr "posix_fallocate - ファイルのスペースを確保する"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:33
#, no-wrap
msgid "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:42
msgid "B<posix_fallocate>():"
msgstr "B<posix_fallocate>():"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:61
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr ""
"関数 B<posix_fallocate>()  は、ディスクリプタ I<fd> で参照されるファイルに対"
"して、ディスクスペースを確実に確保する。 ディスクスペースは I<offset> から始"
"まる I<len> バイトの範囲のバイトである。 B<posix_fallocate>()  の呼び出しが成"
"功した後、指定された範囲のバイトに対する書き込みは、 ディスクスペースの不足で"
"失敗しないことが保証される。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:66
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""
"ファイルのサイズが I<offset>+I<len> より小さい場合、ファイルはこのサイズにな"
"るように拡大される。 それ以外の場合、ファイルサイズは変わらない。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:72
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""
"B<posix_fallocate>()  は成功した場合、0 を返す。 失敗した場合、エラー番号を返"
"す。 I<errno> が設定されない点に注意すること。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:81
msgid "I<offset+len> exceeds the maximum file size."
msgstr "I<offset+len> が最大ファイルサイズを超えている。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:91
msgid "I<fd> does not refer to a regular file."
msgstr "I<fd> が通常のファイルとして参照されていない。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:100
msgid "I<fd> refers to a pipe."
msgstr "I<fd> がパイプを参照している。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:103
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr "B<posix_fallocate>()  は glibc 2.1.94 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:128
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""
"POSIX.1-2008 では、 I<len> が 0 の場合、もしくは I<offset> が 0 未満の場合、 "
"B<EINVAL> エラーを返すものとされている。 POSIX.1-2001 では、 I<len> が 0 未満"
"の場合、もしくは I<offset> が 0 未満の場合、 B<EINVAL> エラーを返すものとされ"
"ている。また、 I<len> が 0 の場合、 B<EINVAL> エラーを返してもよいとされてい"
"る。"

#. type: Plain text
#: build/C/man3/posix_fallocate.3:133
#, fuzzy
#| msgid "B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgid "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr "B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"

#. type: TH
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr "POSIX_MEMALIGN"

#. type: TH
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "2012-03-23"
msgstr "2012-03-23"

#. type: Plain text
#: build/C/man3/posix_memalign.3:32
#, fuzzy
#| msgid ""
#| "posix_memalign, aligned_alloc, memalign, valloc, pvalloc - Allocate "
#| "aligned memory"
msgid ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - allocate aligned "
"memory"
msgstr ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - アラインメント\n"
"されたメモリの割り当てを行う"

#. type: Plain text
#: build/C/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"
msgstr ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_memalign.3:44
#, no-wrap
msgid ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"
msgstr ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/posix_memalign.3:54
msgid ""
"B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr ""
"B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"

#. type: Plain text
#: build/C/man3/posix_memalign.3:57
msgid "B<aligned_alloc>(): _ISOC11_SOURCE"
msgstr "B<aligned_alloc>(): _ISOC11_SOURCE"

#. type: Plain text
#: build/C/man3/posix_memalign.3:59
msgid "B<valloc>():"
msgstr "B<valloc>():"

#. type: TP
#: build/C/man3/posix_memalign.3:62
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "glibc 2.12 以降:"

#. type: Plain text
#: build/C/man3/posix_memalign.3:69
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: TP
#: build/C/man3/posix_memalign.3:71
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "glibc 2.12 より前:"

#. type: Plain text
#: build/C/man3/posix_memalign.3:75
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/posix_memalign.3:82
msgid ""
"(The (nonstandard) header file I<E<lt>malloc.hE<gt>> also exposes the "
"declaration of B<valloc>(); no feature test macros are required.)"
msgstr ""
"((非標準の) ヘッダファイル I<E<lt>malloc.hE<gt>> も\n"
"B<valloc>() の宣言も公開する。機能検査マクロは不要である。"

#.  glibc does this:
#. type: Plain text
#: build/C/man3/posix_memalign.3:103
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated "
"memory will be a multiple of I<alignment>, which must be a power of two and "
"a multiple of I<sizeof(void *)>.  If I<size> is 0, then B<posix_memalign>()  "
"returns either NULL, or a unique pointer value that can later be "
"successfully passed to B<free>(3)."
msgstr ""
"関数 B<posix_memalign>()  は、 I<size> バイトのメモリを割り当て、割り当てられ"
"たメモリのアドレスを I<*memptr> に設定する。 割り当てられたメモリのアドレス"
"は I<alignment> の倍数になっているはずである。 I<alignment> は 2 のべき乗で、"
"かつ I<sizeof(void *)> の倍数でなければならない。 I<size> が 0 の場合、 "
"B<posix_memalign>()  は NULL か一意なポインタ値を返す。 このポインタ値は、後"
"で B<free>(3)  に問題なく渡すことができる。"

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: build/C/man3/posix_memalign.3:114
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<alignment>, which must be a power of two."
msgstr ""
"廃止された関数である B<memalign>() は、 I<size> バイトのメモリを割り当て、\n"
"割り当てられたメモリへのポインタを返す。 メモリのアドレスは I<alignment> \n"
"の倍数になっているはずである。 I<alignment> は 2 のべき乗でなければならない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:123
msgid ""
"The function B<aligned_alloc>()  is the same as B<memalign>(), except for "
"the added restriction that I<size> should be a multiple of I<alignment>."
msgstr ""
"関数 B<aligned_alloc>() は B<memalign>() と同じだが、I<size> が "
"I<alignment>\n"
"の倍数でなければならないという追加の制限がある点が異なる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:132
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""
"廃止された関数である B<valloc>()  は I<size> バイトのメモリを割り当て、割り当"
"てられたメモリへのポインタを返す。 メモリのアドレスはページサイズの倍数になっ"
"ているはずである。 これは I<memalign(sysconf(_SC_PAGESIZE),size)> と等価であ"
"る。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:139
msgid ""
"The obsolete function B<pvalloc>()  is similar to B<valloc>(), but rounds "
"the size of the allocation up to the next multiple of the system page size."
msgstr ""
"廃止された関数 B<pvalloc>() は B<valloc>() と同様だが、\n"
"割り当てられるサイズがシステムのページサイズの倍数に切り上げられる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:141
msgid "For all of these functions, the memory is not zeroed."
msgstr "これらの関数はいずれもメモリのゼロクリアを行わない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:148
msgid ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return a "
"pointer to the allocated memory, or NULL if the request fails."
msgstr ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), B<pvalloc>() は割り当てられ"
"た\n"
"メモリへのポインタを返す。 割り当てに失敗した場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:155
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  Note that I<errno> is not set."
msgstr ""
"B<posix_memalign>()  は成功した場合は 0 を返し、 失敗した場合は次のセクション"
"に記載されたエラー値のいずれかを返す。 I<errno> はセットされないことに注意す"
"ること。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:162
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void *)>."
msgstr ""
"I<alignment> 引き数が 2 のべき乗でなかったか、 I<sizeof(void *)> の倍数でな"
"かった。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:165
msgid "There was insufficient memory to fulfill the allocation request."
msgstr "割り当て要求を満たすのに十分なメモリがなかった。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:172
msgid ""
"The functions B<memalign>(), B<valloc>(), and B<pvalloc>()  have been "
"available in all Linux libc libraries."
msgstr ""
"関数 B<memalign>(), B<valloc>(), B<pvalloc>() は\n"
"すべての Linux libc ライブラリで使用可能である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:176
msgid "The function B<aligned_alloc>()  was added to glibc in version 2.16."
msgstr "関数 B<aligned_alloc>() は glibc バージョン 2.16 で追加された。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:180
msgid "The function B<posix_memalign>()  is available since glibc 2.1.91."
msgstr "関数 B<posix_fallocate>() は glibc 2.1.91 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:187
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in "
"POSIX.1-2001."
msgstr ""
"関数 B<valloc>() は 3.0BSD で登場した。4.3BSD では廃止されたと記載されてお"
"り、\n"
"SUSv2 では過去の名残だと記載されている。 POSIX.1-2001 には存在しない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:191
msgid "The function B<pvalloc>()  is a GNU extension."
msgstr "関数 B<pvalloc>() は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:195
msgid "The function B<memalign>()  appears in SunOS 4.1.3 but not in 4.4BSD."
msgstr "関数 B<memalign>() は SunOS 4.1.3 で登場したが、4.4BSD にはない。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:199
msgid "The function B<posix_memalign>()  comes from POSIX.1d."
msgstr "関数 B<posix_memalign>() は POSIX.1d に由来する。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:204
msgid "The function B<aligned_alloc>()  is specified in the C11 standard."
msgstr "関数 I<aligned_alloc>() は C11 標準で規定されている。"

#. type: SS
#: build/C/man3/posix_memalign.3:204
#, no-wrap
msgid "Headers"
msgstr "ヘッダ"

#. type: Plain text
#: build/C/man3/posix_memalign.3:208
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in I<E<lt>stdlib."
"hE<gt>>."
msgstr ""
"B<posix_memalign>()  の宣言を I<E<lt>stdlib.hE<gt>> で行うことに関しては、 皆"
"の意見が一致している。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:212
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""
"いくつかのシステムでは、 B<memalign>()  は I<E<lt>malloc.hE<gt>> ではなく "
"I<E<lt>stdlib.hE<gt>> で宣言されている。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:219
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Libc4,5 and glibc declare it in I<E<lt>malloc.hE<gt>>, and also in "
"I<E<lt>stdlib.hE<gt>> if suitable feature test macros are defined (see "
"above)."
msgstr ""
"SUSv2 によると、 B<valloc>() は I<E<lt>stdlib.hE<gt>> で宣言される。 "
"libc4,5\n"
"や glibc では I<E<lt>malloc.hE<gt>> で宣言されており、 さらに適切な機能検査\n"
"マクロが定義された場合には I<E<lt>stdlib.hE<gt>> でも宣言される(上記を参照)。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:228
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the I<pathconf(path,"
"_PC_REC_XFER_ALIGN)> call that tells what alignment is needed.  Now one can "
"use B<posix_memalign>()  to satisfy this requirement."
msgstr ""
"多くのシステムでは、アラインメントに関して制限がある。例えば、 ブロックデバイ"
"スに対するダイレクト I/O に使用するバッファには アラインメントに関する制限が"
"ある。 POSIX では、どんなアラインメントが必要かを知るために I<pathconf(path,"
"_PC_REC_XFER_ALIGN)> コールを規定している。ここで B<posix_memalign>()  を使う"
"と、この必要条件を満たすことができる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:237
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<alignment> argument "
"is correct."
msgstr ""
"B<posix_memalign>() は I<alignment> が上で詳細に述べた必要条件を満たすか\n"
"どうかを確かめる。 B<memalign>() は I<alignment> 引き数が正しいかどうかの\n"
"確認を行わないかもしれない。"

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: build/C/man3/posix_memalign.3:265
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can only pass to B<free>"
"(3)  a pointer gotten from B<malloc>(3), while, for example, B<memalign>()  "
"would call B<malloc>(3)  and then align the obtained value).  The glibc "
"implementation allows memory obtained from any of these functions to be "
"reclaimed with B<free>(3)."
msgstr ""
"POSIX では B<posix_memalign>() によって獲得したメモリは B<free>(3) を\n"
"使って解放することができる必要がある。 いくつかのシステムでは\n"
"B<memalign>() やB<valloc>() で割り当てられたメモリを再利用する手段が\n"
"提供されていない(なぜなら B<free>(3) に渡すことができるのは\n"
"B<malloc>(3) から受け取ったポインタだけだが、例えば B<memalign>() は\n"
"B<malloc>(3) を呼び出し、得た値をアラインメントしてしまうからである)。\n"
"glibc の実装では、 ここに述べた関数のいずれで獲得したメモリも\n"
"B<free>(3) で再利用することができる。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:270
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these functions are only needed if you require larger alignment values."
msgstr ""
"glibc の B<malloc>(3) は常に 8 バイトにアラインメントされたメモリアドレスを\n"
"返すので、ここで述べた関数が必要になるのは 8 バイトよりも大きなアラインメン"
"ト\n"
"が必要な場合だけである。"

#. type: Plain text
#: build/C/man3/posix_memalign.3:275
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr "READAHEAD"

#. type: TH
#: build/C/man2/readahead.2:28 build/C/man7/shm_overview.7:27
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man2/readahead.2:31
msgid "readahead - perform file readahead into page cache"
msgstr "readahead - 前もってファイルをページ・キャッシュに読み込む"

#. type: Plain text
#: build/C/man2/readahead.2:37
#, no-wrap
msgid "B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>\n"
msgstr "B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t >I<count>B<);>\n"

#. type: Plain text
#: build/C/man2/readahead.2:65
msgid ""
"B<readahead>()  populates the page cache with data from a file so that "
"subsequent reads from that file will not block on disk I/O.  The I<fd> "
"argument is a file descriptor identifying the file which is to be read.  The "
"I<offset> argument specifies the starting point from which data is to be "
"read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  B<readahead>()  blocks until the specified data has been "
"read.  The current file offset of the open file referred to by I<fd> is left "
"unchanged."
msgstr ""
"B<readahead>()  は、この後の同じファイルからのデータ読み込み時にディスク I/O "
"で 動作が停止 (block) しないように、前もってファイルの内容を ページ・キャッ"
"シュに読み込む。 I<fd> 引き数は読み込みを行うファイルを識別するファイル・ディ"
"スクリプタである。 I<offset> 引き数はデータの読み込み開始位置を指定し、 "
"I<count> は読み込むデータのバイト数を指定する。 ディスク I/O はページ単位で実"
"行されるので、 実際には I<offset> はページ境界に切り下げられ、読み込みバイト"
"数は I<(offset+count)> より小さくない次のページ境界まで切り上げられる。 "
"B<readahead>()  はファイルの末尾を越えた範囲まで読み出しを行うことはない。ま"
"た、 B<readahead>()  は指定したデータの読み込みが終わるまで停止 (block) す"
"る。 I<fd> で参照されたオープン済のファイルのファイルオフセットの現在値は 変"
"更されない。"

#. type: Plain text
#: build/C/man2/readahead.2:71
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""
"B<readahead>()  は成功すると 0 を返す。失敗した場合 -1 を返し、 I<errno> にエ"
"ラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/readahead.2:76
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""
"I<fd> が有効なファイル・ディスクリプタでない、または 読み込み用にオープンされ"
"ていない。"

#. type: Plain text
#: build/C/man2/readahead.2:82
msgid ""
"I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""
"I<fd> が参照しているファイルが、 B<readahead>()  を行うことができないタイプの"
"ファイルであった。"

#. type: Plain text
#: build/C/man2/readahead.2:87
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""
"B<readahead>()  システムコールは Linux 2.4.13 で登場した。 glibc でのサポート"
"は glibc バージョン 2.3 以降で行われている。"

#. type: Plain text
#: build/C/man2/readahead.2:92
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""
"B<readahead>()  システムコールは Linux 固有であり、移植を考慮したプログラムで"
"は 使用を避けるべきである。"

#. type: Plain text
#: build/C/man2/readahead.2:98
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""
"B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"

#. type: TH
#: build/C/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr "REMAP_FILE_PAGES"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr "remap_file_pages - 非線形ファイルマッピングを作成する。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     ssize_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int >I<prot>B<,>\n"
"B<                     ssize_t >I<pgoff>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:51
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using B<remap_file_pages>"
"()  over using repeated calls to B<mmap>(2)  is that the former approach "
"does not require the kernel to create additional VMA (Virtual Memory Area) "
"data structures."
msgstr ""
"B<remap_file_pages>()  システムコールは非線形なマッピング、 つまりファイルの"
"ページがメモリ上で連続しない順番でマップされる マッピングを作成するために使わ"
"れる。 B<remap_file_pages>()  を使う方が B<mmap>(2)  を繰り返して使うより優れ"
"ている点は、 前者の方法ではカーネルが VMA (Virtual Memory Area, 仮想メモリ領"
"域)  データ構造体を追加で作成する必要がないことである。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:53
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr "非線形マッピングを作成するためには、 以下のようなステップを実行する:"

#. type: TP
#: build/C/man2/remap_file_pages.2:53
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/remap_file_pages.2:61
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""
"B<mmap>(2)  を使い、マッピングを作成する (このマッピングは最初は線形であ"
"る)。 このマッピングは B<MAP_SHARED> フラグを指定して作成されなければならな"
"い。"

#. type: TP
#: build/C/man2/remap_file_pages.2:61
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/remap_file_pages.2:69
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""
"B<remap_file_pages>()  を 1 回以上呼び出して、 マッピングのページとファイルの"
"ページの対応関係を再構成する。 ファイルの同じページをマッピング領域の複数の場"
"所に マップすることが可能である。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:80
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""
"I<pgoff> と I<size> 引き数は、マッピング内で再配置されるファイルの領域を指定"
"する。 I<pgoff> はファイルオフセットであり、単位はシステムのページサイズであ"
"る。 I<size> は領域の長さであり、単位はバイトである。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:98
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""
"I<addr> 引き数は 2 つの目的で使われる。 第 1 の目的は、この引き数によって再編"
"成したいページの マッピングを識別することである。 よって I<addr> は B<mmap>"
"(2)  の呼び出しで過去にマップされた領域内のアドレスでなければならない。 第 2 "
"の目的は、 I<pgoff> と I<size> で識別されるファイルページが置かれる予定のアド"
"レスを、 I<addr> によって指定することである。"

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: build/C/man2/remap_file_pages.2:112
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""
"I<addr> と I<size> に指定する値は、システムのページサイズの倍数とすべきであ"
"る。 それ以外の場合、カーネルは「両方」の値を 最も近いページサイズの倍数へ"
"「切り下げる」。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:116
msgid "The I<prot> argument must be specified as 0."
msgstr "I<prot> 引き数は 0 に指定されなければならない。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:124
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""
"I<flags> 引き数は B<mmap>(2)  のものと同じ意味であるが、 B<MAP_NONBLOCK> 以外"
"の全てのフラグは無視される。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:131
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<remap_file_pages>()  は 0 を返す。 エラーの場合、-1 が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:139
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""
"I<addr> が B<MAP_SHARED> フラグを指定して作成された有効なマッピングを参照して"
"いない。"

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: build/C/man2/remap_file_pages.2:148
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr "I<addr>, I<size>, I<prot>, I<pgoff> のいずれかが不正である。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:153
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""
"B<remap_file_pages>()  システムコールは Linux 2.5.46 で登場した。 glibc での"
"サポートは glibc バージョン 2.3.3 で追加された。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:157
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr "B<remap_file_pages>()  システムコールは Linux 固有のものである。"

#. type: Plain text
#: build/C/man2/remap_file_pages.2:164
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"

#. type: TH
#: build/C/man3/shm_open.3:26
#, no-wrap
msgid "SHM_OPEN"
msgstr "SHM_OPEN"

#. type: TH
#: build/C/man3/shm_open.3:26
#, no-wrap
msgid "2009-02-25"
msgstr "2009-02-25"

#. type: Plain text
#: build/C/man3/shm_open.3:29
#, fuzzy
#| msgid ""
#| "shm_open, shm_unlink - Create/open or unlink POSIX shared memory objects"
msgid ""
"shm_open, shm_unlink - create/open or unlink POSIX shared memory objects"
msgstr ""
"shm_open, shm_unlink - POSIX 共有メモリ・オブジェクトの作成/オープン、 削除を"
"行う"

#. type: Plain text
#: build/C/man3/shm_open.3:33
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr "B<#include E<lt>sys/stat.hE<gt>> /* mode 定数用 */"

#. type: Plain text
#: build/C/man3/shm_open.3:35
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr "B<#include E<lt>fcntl.hE<gt>> /* O_* 定数の定義用 */"

#. type: Plain text
#: build/C/man3/shm_open.3:37
msgid ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr ""
"B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"

#. type: Plain text
#: build/C/man3/shm_open.3:39
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr "B<int shm_unlink(const char *>I<name>B<);>"

#. type: Plain text
#: build/C/man3/shm_open.3:41
msgid "Link with I<-lrt>."
msgstr "I<-lrt> でリンクする。"

#. type: Plain text
#: build/C/man3/shm_open.3:53
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can "
"be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr ""
"B<shm_open>()  は、POSIX 共有メモリ・オブジェクトを新規に作成/オープンした"
"り、 すでに存在するオブジェクトをオープンしたりする。 POSIX 共有メモリ・オブ"
"ジェクトは、実際には、関係のないプロセスが 共有メモリの同じ領域を B<mmap>"
"(2)  するために使用することができる手段である。 B<shm_unlink>()  は、逆の操"
"作、つまり以前に B<shm_open>()  で作成されたオブジェクトの削除を行う。"

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: build/C/man3/shm_open.3:74
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name> "
"specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form I</"
"somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr ""
"B<shm_open>()  の動作は B<open>(2)  とよく似ている。 I<name> で作成したりオー"
"プンしたりする共有メモリ・オブジェクトを指定する。 移植性を持たせるためには、"
"共有メモリ・オブジェクトは I</somename> という形式の名前で識別し、 その名前"
"は、最大で B<NAME_MAX> (すなわち 255) 文字の NULL 終端された文字列で、 スラッ"
"シュで始まり、スラッシュ以外の文字が 1 文字以上続く形式 にすべきである。"

#. type: Plain text
#: build/C/man3/shm_open.3:81
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr ""
"I<oflag> はビットマスクで、 B<O_RDONLY> と B<O_RDWR> のいずれか一方と、以下に"
"述べる他のフラグの論理和をとったもの を指定する。"

#. type: TP
#: build/C/man3/shm_open.3:81
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: build/C/man3/shm_open.3:87
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can only be B<mmap>(2)ed for read (B<PROT_READ>) access."
msgstr ""
"読み出しアクセス用にオブジェクトをオープンする。 このフラグを指定してオープン"
"された共有メモリ・オブジェクトは、 読み出し (B<PROT_READ>) アクセスでのみ "
"B<mmap>(2)  することができる。"

#. type: TP
#: build/C/man3/shm_open.3:87
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: build/C/man3/shm_open.3:90
msgid "Open the object for read-write access."
msgstr "読み書きアクセス用にオブジェクトをオープンする。"

#. type: TP
#: build/C/man3/shm_open.3:90
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In truth it is actually the file system IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: build/C/man3/shm_open.3:110
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr ""
"存在しない場合、共有メモリ・オブジェクトを作成する。 オブジェクトのユーザとグ"
"ループの所有権は、 呼び出し元プロセスの対応する実効 ID が使われ、 オブジェク"
"トの許可ビットは I<mode> の下位 9 ビットに基づいて設定される。ただし、 ファイ"
"ルモード作成マスク (B<umask>(2)  参照) に設定されている値は、新規オブジェクト"
"に関してはクリアされる。 I<mode> を定義するために使用できるマクロ定数(群)は "
"B<open>(2)  に記載されている (これらの定数のシンボル定義は I<E<lt>sys/stat."
"hE<gt>> のインクルードにより得られる)。"

#. type: Plain text
#: build/C/man3/shm_open.3:116
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr ""
"新規に作成された共有メモリ・オブジェクトは長さ 0 で初期化される。 オブジェク"
"トの大きさは B<ftruncate>(2)  を使って設定できる。 共有メモリ・オブジェクトと"
"して新規に確保されたバイトは自動的に 0 に初期化される。"

#. type: TP
#: build/C/man3/shm_open.3:116
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: build/C/man3/shm_open.3:125
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the "
"object, and its creation if it does not exist, are performed atomically."
msgstr ""
"B<O_CREAT> が一緒に指定されており、 I<name> で指定された共有メモリ・オブジェ"
"クトが既に存在した場合、 エラーを返す。 オブジェクトの存在確認と、存在しな"
"かった場合のオブジェクト作成は、 必ず一連の操作として実行される (performed "
"atomically)。"

#. type: TP
#: build/C/man3/shm_open.3:125
#, no-wrap
msgid "B<O_TRUNC>"
msgstr "B<O_TRUNC>"

#. type: Plain text
#: build/C/man3/shm_open.3:128
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr ""
"共有メモリ・オブジェクトがすでに存在した場合、 そのオブジェクトを 0 バイトに"
"切り詰める。"

#. type: Plain text
#: build/C/man3/shm_open.3:131
msgid ""
"Definitions of these flag values can be obtained by including I<E<lt>fcntl."
"hE<gt>>."
msgstr ""
"これらのフラグ値の定義は I<E<lt>fcntl.hE<gt>> のインクルードにより得られる。"

#. type: Plain text
#: build/C/man3/shm_open.3:142
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr ""
"成功して完了した場合、 B<shm_open>()  は共有メモリ・オブジェクトを参照する新"
"しいファイル・ディスクリプタを返す。 このファイル・ディスクリプタは、そのプロ"
"セス内で過去にオープンされていない ファイル・ディスクリプタの中で最も小さな数"
"になることが保証される。 B<FD_CLOEXEC> フラグ (B<fcntl>(2)  を参照) が、この"
"ファイル・ディスクリプタに設定される。"

#. type: Plain text
#: build/C/man3/shm_open.3:151
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)  "
"(for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr ""
"通常、これらのファイル・ディスクリプタは、この後続けて実行される B<ftruncate>"
"(2)  (新規に作成されたオブジェクトの場合のみ) と B<mmap>(2)  の呼び出しに使用"
"される。 B<mmap>(2)  を呼び出した後は、ファイル・ディスクリプタをクローズして"
"もよく、 クローズしてもメモリ・マッピングに影響を与えることはない。"

#. type: Plain text
#: build/C/man3/shm_open.3:169
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a "
"shared memory object name, and, once all processes have unmapped the object, "
"de-allocates and destroys the contents of the associated memory region.  "
"After a successful B<shm_unlink>(), attempts to B<shm_open>()  an object "
"with the same I<name> will fail (unless B<O_CREAT> was specified, in which "
"case a new, distinct object is created)."
msgstr ""
"B<shm_unlink>()  の動作は B<unlink>(2)  とよく似ている: 共有メモリ・オブジェ"
"クト名を削除し、すべてのプロセスが処理対象の オブジェクトをアンマップした時点"
"でオブジェクトの割り当てを解除し、 対応するメモリ領域の内容を破棄する。 "
"B<shm_unlink>()  が成功した後で、同じ I<name> を持つオブジェクトに対して "
"B<shm_open>()  を行うと、 (B<O_CREAT> が指定されていない場合) 失敗する。 "
"(B<O_CREAT> が指定されている場合、新しく別のオブジェクトが作成される)。"

#. type: Plain text
#: build/C/man3/shm_open.3:178
msgid ""
"On success, B<shm_open>()  returns a nonnegative file descriptor.  On "
"failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns 0 on success, "
"or -1 on error."
msgstr ""
"成功した場合、 B<shm_open>()  は非負のファイル・ディスクリプタを返す。 失敗し"
"た場合、 B<shm_open>()  は -1 を返す。 B<shm_unlink>()  は、成功した場合 0 "
"を、エラーが起こった場合 -1 を返す。"

#. type: Plain text
#: build/C/man3/shm_open.3:185
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr ""
"失敗した場合、エラーの原因を示すため I<errno> が設定される。 I<errno> に設定"
"される値は以下の通りである:"

#. type: Plain text
#: build/C/man3/shm_open.3:190
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr "共有メモリオブジェクトを B<shm_unlink>()  する権限がなかった。"

#. type: Plain text
#: build/C/man3/shm_open.3:200
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or "
"B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr ""
"指定された I<mode> で I<name> を B<shm_open>()  する権限がなかった。もしく"
"は、 B<O_TRUNC> が指定されたが、呼び出し元にはそのオブジェクトに対する書き込"
"み権限が なかった。"

#. type: TP
#: build/C/man3/shm_open.3:200 build/C/man2/shmget.2:194
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man3/shm_open.3:211
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr ""
"B<O_CREAT> と B<O_EXCL> の両方が B<shm_open>()  に指定されたが、 I<name> で指"
"定された共有メモリ・オブジェクトが既に存在した。"

#. type: Plain text
#: build/C/man3/shm_open.3:218
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr "B<shm_open>()  に与えられた I<name> 引き数が不正であった。"

#. type: TP
#: build/C/man3/shm_open.3:218
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man3/shm_open.3:221
msgid "The process already has the maximum number of files open."
msgstr "プロセスがオープン可能なファイル数の上限にすでに達していた。"

#. type: TP
#: build/C/man3/shm_open.3:221
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/shm_open.3:227
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr "I<name> の長さが B<PATH_MAX> を越えている。"

#. type: Plain text
#: build/C/man3/shm_open.3:231
msgid ""
"The limit on the total number of files open on the system has been reached."
msgstr "ファイルシステムでオープンできるファイル数の上限に達した。"

#. type: TP
#: build/C/man3/shm_open.3:231 build/C/man3/shm_open.3:240
#: build/C/man2/shmget.2:208
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/shm_open.3:240
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr ""
"存在していない I<name> のオブジェクトを B<shm_open>()  しようとしたが、 "
"B<O_CREAT> が指定されていなかった。"

#. type: Plain text
#: build/C/man3/shm_open.3:247
msgid ""
"An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr "存在しない I<name> のオブジェクトを B<shm_unlink>()  しようとした。"

#. type: Plain text
#: build/C/man3/shm_open.3:249
msgid "These functions are provided in glibc 2.2 and later."
msgstr "これらの関数は glibc 2.2 以降で提供されている。"

#. type: Plain text
#: build/C/man3/shm_open.3:255
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\"."
msgstr ""
"POSIX.1-2001 には、新規に作成される共有メモリオブジェクトのグループ所有権"
"は、 呼び出し元プロセスの実効グループ ID か 「システムのデフォルトのグループ "
"ID」 のどちらかに設定される、と書かれている。"

#. type: Plain text
#: build/C/man3/shm_open.3:264
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr ""
"POSIX は B<O_RDONLY> と B<O_TRUNC> が一緒に指定された場合の動作を未定義にして"
"いる。Linux では、 既存の共有メモリ・オブジェクトに対する切り詰め (truncate) "
"は成功する。 しかし、他の UNIX システムでも同じであるとは限らない。"

#. type: Plain text
#: build/C/man3/shm_open.3:269
msgid ""
"The POSIX shared memory object implementation on Linux 2.4 makes use of a "
"dedicated file system, which is normally mounted under I</dev/shm>."
msgstr ""
"Linux 2.4 における POSIX 共有メモリ・オブジェクトの実装は 専用のファイルシス"
"テムを使用する。そのファイルシステムは通常 I</dev/shm> にマウントされる。"

#. type: Plain text
#: build/C/man3/shm_open.3:280
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<mmap>(2), B<open>(2), B<umask>(2), B<shm_overview>(7)"
msgstr ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<mmap>(2), B<open>(2), B<umask>(2), B<shm_overview>(7)"

#. type: TH
#: build/C/man7/shm_overview.7:27
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr "SHM_OVERVIEW"

#. type: Plain text
#: build/C/man7/shm_overview.7:30
#, fuzzy
#| msgid "shm_overview - Overview of POSIX shared memory"
msgid "shm_overview - overview of POSIX shared memory"
msgstr "shm_overview - POSIX 共有メモリの概要"

#. type: Plain text
#: build/C/man7/shm_overview.7:33
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""
"POSIX 共有メモリ API を使用すると、メモリのある領域を共有して、 プロセス間で"
"情報をやり取りすることができる。"

#. type: Plain text
#: build/C/man7/shm_overview.7:35
msgid "The interfaces employed in the API are:"
msgstr "この API では以下のインターフェースが採用されている。"

#. type: TP
#: build/C/man7/shm_overview.7:35
#, no-wrap
msgid "B<shm_open>(3)"
msgstr "B<shm_open>(3)"

#. type: Plain text
#: build/C/man7/shm_overview.7:42
msgid ""
"Create and open a new object, or open an existing object.  This is analogous "
"to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""
"新しいオブジェクトを生成しオープンする、もしくは 既存のオブジェクトをオープン"
"する。これは B<open>(2)  と同じである。下記にある他のインターフェースで使用す"
"る ファイルディスクリプタを返す。"

#. type: TP
#: build/C/man7/shm_overview.7:42
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr "B<ftruncate>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:46
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr "共有メモリオブジェクトの大きさを設定する。"

#. type: Plain text
#: build/C/man7/shm_overview.7:50
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""
"呼び出したプロセスの仮想アドレス空間に共有メモリオブジェクトを マップする。"

#. type: TP
#: build/C/man7/shm_overview.7:50
#, no-wrap
msgid "B<munmap>(2)"
msgstr "B<munmap>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:54
msgid ""
"Unmap the shared memory object from the virtual address space of the calling "
"process."
msgstr ""
"呼び出したプロセスの仮想アドレス空間から 共有メモリオブジェクトをアンマップす"
"る。"

#. type: TP
#: build/C/man7/shm_overview.7:54
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr "B<shm_unlink>(3)"

#. type: Plain text
#: build/C/man7/shm_overview.7:57
msgid "Remove a shared memory object name."
msgstr "共有メモリオブジェクト名を削除する。"

#. type: TP
#: build/C/man7/shm_overview.7:57
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:62
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""
"B<shm_open>(3)  で割り当てられたファイルディスクリプタが不要になった際に、 そ"
"のファイルディスクリプタをクローズする。"

#. type: TP
#: build/C/man7/shm_overview.7:62
#, no-wrap
msgid "B<fstat>(2)"
msgstr "B<fstat>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:76
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""
"その共有メモリオブジェクトについての情報が入った I<stat> 構造体を取得する。 "
"このシステムコールが返す情報には、オブジェクトのサイズ (I<st_size>)、 許可属"
"性 (I<st_mode>)、 所有者 (I<st_uid>)、 グループ (I<st_gid>)  がある。"

#. type: TP
#: build/C/man7/shm_overview.7:76
#, no-wrap
msgid "B<fchown>(2)"
msgstr "B<fchown>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:79
msgid "To change the ownership of a shared memory object."
msgstr "共有メモリオブジェクトの所有権を変更する。"

#. type: TP
#: build/C/man7/shm_overview.7:79
#, no-wrap
msgid "B<fchmod>(2)"
msgstr "B<fchmod>(2)"

#. type: Plain text
#: build/C/man7/shm_overview.7:82
msgid "To change the permissions of a shared memory object."
msgstr "共有メモリオブジェクトの許可属性を変更する。"

#. type: SS
#: build/C/man7/shm_overview.7:82
#, no-wrap
msgid "Versions"
msgstr "Versions"

#. type: Plain text
#: build/C/man7/shm_overview.7:84
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr "POSIX 共有メモリは Linux 2.4 と glibc 2.2 以降でサポートされている。"

#. type: SS
#: build/C/man7/shm_overview.7:84
#, no-wrap
msgid "Persistence"
msgstr "持続性"

#. type: Plain text
#: build/C/man7/shm_overview.7:89
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""
"POSIX 共有メモリオブジェクトはカーネル内で保持される。 共有メモリオブジェクト"
"は、システムがシャットダウンされるか、 全てのプロセスがそのオブジェクトをアン"
"マップし、 B<shm_unlink>(3)  で削除されるまで、存在し続ける。"

#. type: SS
#: build/C/man7/shm_overview.7:89
#, no-wrap
msgid "Linking"
msgstr "リンク"

#. type: Plain text
#: build/C/man7/shm_overview.7:94
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""
"POSIX 共有メモリ API を使用したプログラムは I<cc -lrt> でコンパイルし、リアル"
"タイムライブラリ I<librt> とリンクしなければならない。"

#. type: SS
#: build/C/man7/shm_overview.7:94
#, no-wrap
msgid "Accessing shared memory objects via the file system"
msgstr "ファイルシステム経由での共有メモリオブジェクトへのアクセス"

#. type: Plain text
#: build/C/man7/shm_overview.7:101
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>)  virtual file "
"system, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual file system."
msgstr ""
"Linux では、共有メモリオブジェクトは通常 I</dev/shm> 以下にマウントされる仮想"
"ファイルシステム (I<tmpfs>)  内に作成される。 カーネル 2.6.19 以降の Linux で"
"は、 仮想ファイルシステム内のオブジェクトの許可属性の制御に、 アクセス制御リ"
"スト (ACL; access control lists) を使うことができる。"

#. type: Plain text
#: build/C/man7/shm_overview.7:106
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""
"通常は、共有メモリオブジェクトにアクセスするプロセスは、 POSIX セマフォなどを"
"使ってプロセス間で同期をとらなければならない。"

#. type: Plain text
#: build/C/man7/shm_overview.7:114
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""
"System V 共有メモリ (B<shmget>(2), B<shmop>(2)  など) は古い共有メモリ API で"
"ある。 POSIX 共有メモリは、より簡単で、うまく設計されたインタフェースを提供し"
"ている。 一方で、POSIX 共有メモリは System V 共有メモリと比べると 利用できる"
"システムが少ない (特に、古いシステムでは少ない)。"

#. type: Plain text
#: build/C/man7/shm_overview.7:127
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"

#. type: TH
#: build/C/man2/shmctl.2:45
#, no-wrap
msgid "SHMCTL"
msgstr "SHMCTL"

#. type: TH
#: build/C/man2/shmctl.2:45 build/C/man2/shmget.2:38
#, fuzzy, no-wrap
#| msgid "2012-05-06"
msgid "2012-05-31"
msgstr "2012-05-06"

#. type: Plain text
#: build/C/man2/shmctl.2:48
msgid "shmctl - shared memory control"
msgstr "shmctl - 共有メモリ (shared memory) を制御する"

#. type: Plain text
#: build/C/man2/shmctl.2:51 build/C/man2/shmget.2:44
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr "B<#include E<lt>sys/ipc.hE<gt>>"

#. type: Plain text
#: build/C/man2/shmctl.2:53 build/C/man2/shmget.2:46
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr "B<#include E<lt>sys/shm.hE<gt>>"

#. type: Plain text
#: build/C/man2/shmctl.2:55
msgid ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""
"B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/shmctl.2:62
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the "
"shared memory segment whose identifier is given in I<shmid>."
msgstr ""
"B<shmctl>()  は、識別子が I<shmid> の共有メモリ・セグメントに対して I<cmd> で"
"指示した制御命令を実行する。"

#. type: Plain text
#: build/C/man2/shmctl.2:67
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""
"I<buf> 引き数は、 I<shmid_ds> 構造体へのポインタである。 この構造体は "
"I<E<lt>sys/shm.hE<gt>> で以下のように定義されている"

#. type: Plain text
#: build/C/man2/shmctl.2:81
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Last change time */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* 所有権と許可 */\n"
"    size_t          shm_segsz;   /* セグメントのサイズ (バイト) */\n"
"    time_t          shm_atime;   /* 最後の付加 (attach) の時刻 */\n"
"    time_t          shm_dtime;   /* 最後の分離 (detach) の時刻 */\n"
"    time_t          shm_ctime;   /* 最後に変更が行われた時刻 */\n"
"    pid_t           shm_cpid;    /* 作成者 (creator) の PID */\n"
"    pid_t           shm_lpid;    /* 最後の shmat(2)/shmdt(2) の PID */\n"
"    shmatt_t        shm_nattch;  /* 現在付加されている数 */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmctl.2:89
#, fuzzy
#| msgid ""
#| "The I<ipc_perm> structure is defined in I<E<lt>sys/ipc.hE<gt>> as follows "
#| "(the highlighted fields are settable using B<IPC_SET>):"
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""
"I<ipc_perm> 構造体は I<E<lt>sys/ipc.hE<gt>> で以下のように定義されている (強"
"調されたフィールドは B<IPC_SET> を使って設定可能である):"

#. type: Plain text
#: build/C/man2/shmctl.2:102
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key;    /* shmget(2) に与えられるキー */\n"
"    uid_t          B<uid>;      /* 所有者の実効 UID */\n"
"    gid_t          B<gid>;      /* 所有者の実効 GID */\n"
"    uid_t          cuid;     /* 作成者の実効 UID */\n"
"    gid_t          cgid;     /* 作成者の実効 GID */\n"
"    unsigned short B<mode>;     /* B<許可> + SHM_DEST と\n"
"                                SHM_LOCKED フラグ */\n"
"    unsigned short __seq;    /* シーケンス番号 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmctl.2:108
msgid "Valid values for I<cmd> are:"
msgstr "I<cmd> として有効な値は以下の通り:"

#. type: TP
#: build/C/man2/shmctl.2:109
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: build/C/man2/shmctl.2:118
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""
"I<shmid> に関連づけられたカーネルデータ構造体の情報を I<buf> で指された "
"I<shmid_ds> 構造体にコピーする。 呼び出し元は共有メモリ・セグメントに対する "
"読み込み許可を持たなければならない。"

#. type: TP
#: build/C/man2/shmctl.2:118
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: build/C/man2/shmctl.2:136
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member.  The following fields can be "
"changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant 9 bits "
"of) I<shm_perm.mode>.  The effective UID of the calling process must match "
"the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the shared "
"memory segment, or the caller must be privileged."
msgstr ""
"I<buf> によって指される I<shmid_ds> 構造体のいくつかのメンバーの値を、 この共"
"有メモリ・セグメントに関連づけられたカーネルデータ構造体に書き込み、 "
"I<shm_ctime> メンバーも更新する。 以下のフィールドは変更できる。 I<shm_perm."
"uid>, I<shm_perm.gid>, I<shm_perm.mode> (の最下位 9 ビット)。 呼び出したプロ"
"セスの実効 UID が所有者 (I<shm_perm.uid>)  または作成者 (I<shm_perm.cuid>)  "
"と一致するか、呼び出し元が特権を持たなければならない。"

#. type: TP
#: build/C/man2/shmctl.2:136
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: build/C/man2/shmctl.2:153
msgid ""
"Mark the segment to be destroyed.  The segment will only actually be "
"destroyed after the last process detaches it (i.e., when the I<shm_nattch> "
"member of the associated structure I<shmid_ds> is zero).  The caller must be "
"the owner or creator, or be privileged.  If a segment has been marked for "
"destruction, then the (nonstandard)  B<SHM_DEST> flag of the I<shm_perm."
"mode> field in the associated data structure retrieved by B<IPC_STAT> will "
"be set."
msgstr ""
"セグメントに破棄済みのマークを付ける。 セグメントは、実際には最後プロセスがセ"
"グメントを分離した (関連する I<shmid_ds> 構造体の I<shm_nattch> メンバーが 0 "
"になった) 後でのみ破棄される。 呼び出し元は所有者か作成者であるか、特権を持た"
"なければならない。 セグメントに破棄のマークが付けられると、 関連するデータ構"
"造体において I<shm_perm.mode> フィールドの (標準ではない)  B<SHM_DEST> フラグ"
"が設定される。 このデータ構造体は B<IPC_STAT> で取得される。"

#. type: Plain text
#: build/C/man2/shmctl.2:156
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""
"呼び出し元は最終的にはセグメントを忘れずに破棄I<しなければならない>。 そうで"
"なれば、フォールト (fault) されたページは メモリかスワップ (swap) に残り続け"
"る。"

#. type: TP
#: build/C/man2/shmctl.2:156
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:169
msgid ""
"Returns information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"システム全体での共有メモリの制限とパラメータに関する情報を、 I<buf> が指す構"
"造体に入れて返す。 この構造体は I<shminfo> 型である (そのためキャストが必要で"
"ある)。 I<shminfo> は B<_GNU_SOURCE> 機能検査マクロが定義された場合に "
"I<E<lt>sys/shm.hE<gt>> で以下のように定義される:"

#. type: Plain text
#: build/C/man2/shmctl.2:183
#, no-wrap
msgid ""
"struct  shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""
"struct  shminfo {\n"
"    unsigned long shmmax; /* 最大セグメントサイズ */\n"
"    unsigned long shmmin; /* 最小セグメントサイズ。\n"
"                             常に 1 */\n"
"    unsigned long shmmni; /* 最大セグメント数 */\n"
"    unsigned long shmseg; /* プロセスが付加できる\n"
"                             セグメントの最大数。\n"
"                             カーネル内では未使用 */\n"
"    unsigned long shmall; /* 共有メモリの最大ページ数。\n"
"                             システム全体での値 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/shmctl.2:196
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""
"設定 I<shmmni>, I<shmmax>, I<shmall> は I</proc> にある同じ名前のファイル経由"
"で変更可能である。 詳しくは B<proc>(5)  を参照。"

#. type: TP
#: build/C/man2/shmctl.2:196
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr "B<SHM_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:207
msgid ""
"Returns a I<shm_info> structure whose fields contain information about "
"system resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"共有メモリが消費しているシステム資源に関する情報を 格納した I<shm_info> 構造"
"体を返す。 この構造体は、 B<_GNU_SOURCE> 機能検査マクロが定義された場合に "
"I<E<lt>sys/shm.hE<gt>> で以下のように定義される:"

#. type: Plain text
#: build/C/man2/shmctl.2:224
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""
"struct shm_info {\n"
"    int           used_ids; /* 現在存在するセグメント数 */\n"
"    unsigned long shm_tot;  /* 共有メモリのページ総数 */\n"
"    unsigned long shm_rss;  /* メモリ上にある (スワップされて\n"
"                               いない) 共有メモリページ数 */\n"
"    unsigned long shm_swp;  /* スワップされている共有メモリ\n"
"                               ページ数 */\n"
"    unsigned long swap_attempts;\n"
"                            /* Linux 2.4 以降では未使用 */\n"
"    unsigned long swap_successes;\n"
"                            /* Linux 2.4 以降では未使用 */\n"
"};\n"

#. type: TP
#: build/C/man2/shmctl.2:226
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr "B<SHM_STAT> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:237
msgid ""
"Returns a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""
"B<IPC_STAT> と同じく I<shmid_ds> 構造体を返す。 但し、 I<shmid> 引き数は、セ"
"グメント識別子ではなく、システム上の全ての共有メモリ セグメントに関する情報を"
"管理するカーネルの内部配列へのインデックス である。"

#. type: Plain text
#: build/C/man2/shmctl.2:240
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""
"呼び出し元は、I<cmd> に以下の値を指定することで、共有メモリ・セグメントが ス"
"ワップされることを防止したり、許可したりできる:"

#. type: TP
#: build/C/man2/shmctl.2:241
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr "B<SHM_LOCK> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:253
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""
"共有メモリ・セグメントをスワップすることを防止する。 ロックが有効になった後、"
"呼び出し元は、 存在することが要求された全てのページをフォールトさせなければな"
"らない。 セグメントがロックされると、 関連するデータ構造体において "
"I<shm_perm.mode> フィールドの (標準的ではない)  B<SHM_LOCKED> フラグが設定さ"
"れる。 このデータ構造体は B<IPC_STAT> で取得される。"

#. type: TP
#: build/C/man2/shmctl.2:253
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr "B<SHM_UNLOCK> (Linux 固有)"

#. type: Plain text
#: build/C/man2/shmctl.2:256
msgid "Unlock the segment, allowing it to be swapped out."
msgstr "セグメントのロックを解除し、スワップ・アウトすることを可能にする。"

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: build/C/man2/shmctl.2:274
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""
"2.6.10 より前のカーネルでは、特権プロセスだけが B<SHM_LOCK> と B<SHM_UNLOCK> "
"を利用することができた。 2.6.10 以降のカーネルでは、非特権プロセスであっても"
"次の条件を満たせば これらの操作を利用することができる。その条件とは、プロセス"
"の実効 UID がそのセグメントの所有者もしくは作成者の UID と一致し、 "
"(B<SHM_LOCK> の場合には) ロックするメモリの合計が B<RLIMIT_MEMLOCK> リソース"
"上限 (B<setrlimit>(2)  参照) の範囲内に入っていることである。"

#. type: Plain text
#: build/C/man2/shmctl.2:292
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> operations to obtain information about all shared "
"memory segments on the system.)  A successful B<SHM_STAT> operation returns "
"the identifier of the shared memory segment whose index was given in "
"I<shmid>.  Other operations return 0 on success."
msgstr ""
"B<IPC_INFO> と B<SHM_INFO> 操作は、成功すると、全ての共有メモリセグメントに関"
"する情報を 管理しているカーネルの内部配列の使用中エントリのインデックスの う"
"ち最大値を返す (この情報は、システムの全ての共有メモリセグメントに関する情報"
"を 取得するために、 B<SHM_STAT> 操作を繰り返し実行する際に使用できる)。 "
"B<SHM_STAT> 操作は、成功すると、 I<shmid> で指定されたインデックスを持つ共有"
"メモリセグメントの識別子を返す。 他の操作は、成功の場合 0 を返す。"

#. type: Plain text
#: build/C/man2/shmctl.2:296
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/shmctl.2:305
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability."
msgstr ""
"B<IPC_STAT> または B<SHM_STAT> が要求され、 I<shm_perm.mode> が I<shmid> への"
"読み込みアクセスを許しておらず、 かつ呼び出したプロセスが B<CAP_IPC_OWNER> "
"ケーパビリティ (capability) を持っていない。"

#. type: Plain text
#: build/C/man2/shmctl.2:316
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""
"I<cmd> 引き数に B<IPC_SET> か B<IPC_STAT> が指定されたが I<buf> で指されてい"
"るアドレスにアクセスできない。"

#. type: TP
#: build/C/man2/shmctl.2:316 build/C/man2/shmop.2:197
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: build/C/man2/shmctl.2:319 build/C/man2/shmop.2:200
msgid "I<shmid> points to a removed identifier."
msgstr "I<shmid> が削除 (remove) された識別子 (identifier) を指している。"

#. type: Plain text
#: build/C/man2/shmctl.2:328
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> operation, the index value specified in I<shmid> referred "
"to an array slot that is currently unused."
msgstr ""
"I<shmid> が有効な識別子でないか、 I<cmd> が有効なコマンドでない。 もしくは、 "
"B<SHM_STAT> 操作の場合に、 I<shmid> で指定されたインデックス値が現在未使用の"
"配列のスロットを参照していた。"

#. type: Plain text
#: build/C/man2/shmctl.2:339
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the to-"
"be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""
"(2.6.9 以降のカーネルにおいて)  B<SHM_LOCK> が指定され、 ロックされる予定のセ"
"グメントのサイズ (ロックされる共有メモリ・セグメントの合計バイト数) が、 呼び"
"出したプロセスの実ユーザー ID についての制限を超えた。 この制限は "
"B<RLIMIT_MEMLOCK> ソフト資源制限で定義される (B<setrlimit>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/shmctl.2:344
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""
"B<IPC_STAT> が試みられ、GID や UID の値が I<buf> で指示される構造体に格納する"
"には大き過ぎる。"

#. type: Plain text
#: build/C/man2/shmctl.2:356
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""
"B<IPC_SET> か B<IPC_RMID> が試みられ、 呼び出したプロセスの実効ユーザー ID が"
"作成者 (I<shm_perm.cuid>)  でも所有者 (I<shm_perm.uid>)  でもなく、プロセスが"
"特権を持たない (Linux では B<CAP_SYS_ADMIN> ケーパビリティを持たない)。"

#. type: Plain text
#: build/C/man2/shmctl.2:368
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""
"または (2.6.9 より前のカーネルで)  B<SHM_LOCK> または B<SHM_UNLOCK> が指定さ"
"れているが、プロセスが特権を持たない (Linux では B<CAP_IPC_LOCK> ケーパビリ"
"ティを持たない)。 (Linux 2.6.9 以降では、 B<RLIMIT_MEMLOCK> が 0 で呼び出し元"
"が特権を持たない場合にも、このエラーが起こる。)"

#.  SVr4 documents an additional error condition EMFILE.
#. type: Plain text
#: build/C/man2/shmctl.2:373 build/C/man2/shmget.2:234
#: build/C/man2/shmop.2:234
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/shmctl.2:386 build/C/man2/shmget.2:250
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:397
msgid ""
"The B<IPC_INFO>, B<SHM_STAT> and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a /proc file system interface."
msgstr ""
"B<IPC_INFO>, B<SHM_STAT>, B<SHM_INFO> 操作は、 B<ipcs>(1)  プログラムで割り当"
"て済の資源に関する情報を提供するために 使用されている。将来、これらの操作は変"
"更されたり、 /proc ファイルシステムのインタフェースに移動されるかもしれない。"

#. type: Plain text
#: build/C/man2/shmctl.2:405
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""
"Linux では、 I<shmctl(IPC_RMID)> を使ってすでに削除マークがつけられている共有"
"メモリ・セグメントを あるプロセスが付加 (attach)  (B<shmat>(2))  することを許"
"可している。 この機能は他の UNIX の実装では利用できない。 移植性を考慮したア"
"プリケーションではこれに依存しないようにすべきである。"

#. type: Plain text
#: build/C/man2/shmctl.2:418
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"I<構造体 shmid_ds> 内の多くのフィールドは、 Linux 2.2 では I<short> 型だった"
"が、Linux 2.4 では I<long> 型になった。 この利点を生かすには、glibc-2.1.91 以"
"降の環境下で 再コンパイルすれば十分である。 カーネルは新しい形式の呼び出しと"
"古い形式の呼び出しを I<cmd> 内の B<IPC_64> フラグで区別する。"

#. type: Plain text
#: build/C/man2/shmctl.2:425
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<svipc>(7)"
msgstr ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"

#. type: TH
#: build/C/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr "SHMGET"

#. type: Plain text
#: build/C/man2/shmget.2:41
msgid "shmget - allocates a shared memory segment"
msgstr "shmget - 共有メモリ・セグメントを割り当てる"

#. type: Plain text
#: build/C/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"

#. type: Plain text
#: build/C/man2/shmget.2:72
msgid ""
"B<shmget>()  returns the identifier of the shared memory segment associated "
"with the value of the argument I<key>.  A new shared memory segment, with "
"size equal to the value of I<size> rounded up to a multiple of B<PAGE_SIZE>, "
"is created if I<key> has the value B<IPC_PRIVATE> or I<key> isn't "
"B<IPC_PRIVATE>, no shared memory segment corresponding to I<key> exists, and "
"B<IPC_CREAT> is specified in I<shmflg>."
msgstr ""
"B<shmget>()  は I<key> 引き数に対応する共有メモリ・セグメントの識別子を返"
"す。 I<key> の値が B<IPC_PRIVATE> の場合、もしくは I<key> に対応する共有メモ"
"リ・セグメントが存在せず、 I<shmflg> に B<IPC_CREAT> が指定されていた場合、 "
"新しい共有メモリ・セグメントを作成する。 作成される共有メモリ・セグメント"
"は、 I<size> 引き数の値を B<PAGE_SIZE> の倍数へと切り上げた (round up) 大きさ"
"となる。"

#. type: Plain text
#: build/C/man2/shmget.2:91
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""
"I<shmflg> に B<IPC_CREAT> と B<IPC_EXCL> の両方が指定された場合、 I<key> に対"
"応する共有メモリ・セグメントが既に存在すると、 B<shmget>()  は失敗し、 "
"I<errno> に B<EEXIST> が設定される (これは B<open>(2)  に B<O_CREAT | "
"O_EXCL> を指定した場合の動作と同じである)。"

#. type: Plain text
#: build/C/man2/shmget.2:95
msgid "The value I<shmflg> is composed of:"
msgstr "I<shmflg> は以下の内容から構成される:"

#. type: TP
#: build/C/man2/shmget.2:95
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr "B<IPC_CREAT>"

#. type: Plain text
#: build/C/man2/shmget.2:102
msgid ""
"to create a new segment.  If this flag is not used, then B<shmget>()  will "
"find the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""
"新しいセグメントを作成する。このフラグが指定されなかった場合、 B<shmget>()  "
"は I<key> に対応するセグメントを探し、 ユーザがそのセグメントにアクセスする許"
"可があるかどうかをチェックする。"

#. type: TP
#: build/C/man2/shmget.2:102
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr "B<IPC_EXCL>"

#. type: Plain text
#: build/C/man2/shmget.2:105
msgid "used with B<IPC_CREAT> to ensure failure if the segment already exists."
msgstr ""
"B<IPC_CREAT> と共に使用し、セグメントが既に存在した場合には 失敗することを保"
"証する。"

#. type: TP
#: build/C/man2/shmget.2:105
#, no-wrap
msgid "I<mode_flags>"
msgstr "I<mode_flags>"

#. type: Plain text
#: build/C/man2/shmget.2:115
msgid ""
"(least significant 9 bits)  specifying the permissions granted to the owner, "
"group, and world.  These bits have the same format, and the same meaning, as "
"the I<mode> argument of B<open>(2).  Presently, the execute permissions are "
"not used by the system."
msgstr ""
"(下位 9 ビット)  所有者、グループ、他人 (world) への許可を指定する。 これらの"
"ビットは B<open>(2)  の I<mode> 引き数と同じ形式で同じ意味を持つ。 今のとこ"
"ろ、システムは実行 (execute) 許可を参照しない。"

#. type: TP
#: build/C/man2/shmget.2:115
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr "B<SHM_HUGETLB> (Linux 2.6 以降)"

#. type: Plain text
#: build/C/man2/shmget.2:121
#, fuzzy
#| msgid ""
#| "Allocate the segment using \"huge pages.\" See the kernel source file "
#| "I<Documentation/vm/hugetlbpage.txt> for further information."
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""
"\"ヒュージページ (huge page)\" を使うセグメントを割り当てる。 詳細な情報は、"
"カーネル・ソースのファイル I<Documentation/vm/hugetlbpage.txt> を参照。"

#. type: TP
#: build/C/man2/shmget.2:121
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr "B<SHM_NORESERVE> (Linux 2.6.15 以降)"

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: build/C/man2/shmget.2:140
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file I</proc/sys/vm/"
"overcommit_memory> in B<proc>(5)."
msgstr ""
"このフラグは、 B<mmap>(2)  の B<MAP_NORESERVE> フラグと同じ役割を果たす。 こ"
"のセグメントに対するスワップ空間の予約を行わない。 スワップ空間を予約した場合"
"は、そのセグメントの変更が必ず成功することが 保証される。スワップ空間の予約を"
"行わなかった場合は、物理メモリに空きが ないと書き込み時に B<SIGSEGV> を受け取"
"る可能性がある。 B<proc>(5)  にある I</proc/sys/vm/overcommit_memory> ファイ"
"ルに関する議論も参照のこと。"

#. type: Plain text
#: build/C/man2/shmget.2:148
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see B<shmctl>"
"(2)), is initialized as follows:"
msgstr ""
"共有メモリ・セグメントが新たに作成される際、 共有メモリ・セグメントの内容は "
"0 で初期化され、 関連情報を保持するデータ構造体 I<shmid_ds> は以下のように初"
"期化される。"

#. type: Plain text
#: build/C/man2/shmget.2:153
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"I<shm_perm.cuid> と I<shm_perm.uid> に呼び出し元プロセスの実効 (effective) "
"ユーザーID を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:158
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"I<shm_perm.cgid> と I<shm_perm.gid> に呼び出し元プロセスの実効グループID を設"
"定する。"

#. type: Plain text
#: build/C/man2/shmget.2:163
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""
"I<shm_perm.mode> の下位 9 ビットに I<shmflg> の下位 9 ビットを設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:167
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr "I<shm_segsz> に I<size> の値を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:174
msgid "I<shm_lpid>, I<shm_nattch>, I<shm_atime> and I<shm_dtime> are set to 0."
msgstr ""
"I<shm_lpid>, I<shm_nattch>, I<shm_atime>, I<shm_dtime> に 0 を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:177
msgid "I<shm_ctime> is set to the current time."
msgstr "I<shm_ctime> に現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/shmget.2:180
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""
"共有メモリ・セグメントが既に存在する場合、アクセス許可の検査と、 破壊 "
"(destruction) マークがつけられていないかのチェックが行われる。"

#. type: Plain text
#: build/C/man2/shmget.2:184
msgid ""
"A valid segment identifier, I<shmid>, is returned on success, -1 on error."
msgstr ""
"成功した場合、有効なセグメント識別子 I<shmid> が返される。エラーの場合、 -1 "
"が返される。"

#. type: Plain text
#: build/C/man2/shmget.2:188
msgid "On failure, I<errno> is set to one of the following:"
msgstr "失敗した場合は I<errno> が以下のどれかに設定される:"

#. type: Plain text
#: build/C/man2/shmget.2:194
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr ""
"ユーザーはその共有メモリ・セグメントへのアクセス許可を持たず、 "
"B<CAP_IPC_OWNER> ケーパビリティも持っていない。"

#. type: Plain text
#: build/C/man2/shmget.2:198
msgid "B<IPC_CREAT | IPC_EXCL> was specified and the segment exists."
msgstr ""
"B<IPC_CREAT | IPC_EXCL> が指定されていたが、そのセグメントが既に存在する。"

#. type: Plain text
#: build/C/man2/shmget.2:204
msgid ""
"A new segment was to be created and I<size> E<lt> B<SHMMIN> or I<size> E<gt> "
"B<SHMMAX>, or no new segment was to be created, a segment with given key "
"existed, but I<size> is greater than the size of that segment."
msgstr ""
"新しいセグメントを作成しようとした際に I<size> E<lt> B<SHMMIN> または "
"I<size> E<gt> B<SHMMAX> であった。 もしくは、指定されたキーに対応するセグメン"
"トが既に存在して、新しい セグメントを作成しようとはしなかったが、I<size> が存"
"在するセグメントの サイズよりも大きかった。"

#. type: Plain text
#: build/C/man2/shmget.2:213
msgid ""
"No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr ""
"指定された I<key> に対応するセグメントが存在せず、 B<IPC_CREAT> も指定されて"
"いなかった。"

#. type: Plain text
#: build/C/man2/shmget.2:216
msgid "No memory could be allocated for segment overhead."
msgstr "セグメントの管理情報 (overhead) に割り当てるメモリがなかった。"

#. type: Plain text
#: build/C/man2/shmget.2:224
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the system-"
"wide limit on shared memory (B<SHMALL>)."
msgstr ""
"システム全体の共有メモリ・セグメント数の制限 (B<SHMMNI>)  に達した、または要"
"求された I<size> のセグメントの割り当てが システム全体の共有メモリサイズの制"
"限 (B<SHMALL>)  を超過した。"

#. type: Plain text
#: build/C/man2/shmget.2:231
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""
"B<SHM_HUGETLB> フラグが指定されたが、呼び出し元には権限がなかった "
"(B<CAP_IPC_LOCK> ケーパビリティを持っていなかった)。"

#. type: Plain text
#: build/C/man2/shmget.2:237
msgid "B<SHM_HUGETLB> is a nonportable Linux extension."
msgstr "B<SHM_HUGETLB> は Linux での拡張であり、移植性はない。"

#. type: Plain text
#: build/C/man2/shmget.2:260
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment (on "
"success)."
msgstr ""
"B<IPC_PRIVATE> はフラグではなく I<key_t> 型である。 この特別な値が I<key> に"
"使用された場合は、 B<shmget>()  は I<shmflg> の下位 9 ビットを除いた全てを無"
"視し、 (成功すれば) 新しい共有メモリ・セグメントを作成する。"

#. type: Plain text
#: build/C/man2/shmget.2:264
msgid ""
"The following limits on shared memory segment resources affect the B<shmget>"
"()  call:"
msgstr ""
"B<shmget>()  コールに影響する共有メモリ・セグメント資源の制限は以下の通りであ"
"る:"

#. type: TP
#: build/C/man2/shmget.2:264
#, no-wrap
msgid "B<SHMALL>"
msgstr "B<SHMALL>"

#. type: Plain text
#: build/C/man2/shmget.2:269
msgid ""
"System wide maximum of shared memory pages (on Linux, this limit can be read "
"and modified via I</proc/sys/kernel/shmall>)."
msgstr ""
"システム全体の共有メモリ・ページの最大数 (Linux では、この上限値は I</proc/"
"sys/kernel/shmall> 経由で参照したり、変更したりできる)。"

#. type: TP
#: build/C/man2/shmget.2:269
#, no-wrap
msgid "B<SHMMAX>"
msgstr "B<SHMMAX>"

#. type: Plain text
#: build/C/man2/shmget.2:274
msgid ""
"Maximum size in bytes for a shared memory segment: policy dependent (on "
"Linux, this limit can be read and modified via I</proc/sys/kernel/shmmax>)."
msgstr ""
"共有メモリ・セグメントのバイト単位の大きさの上限: 方針依存 (Linux では、この"
"上限値は I</proc/sys/kernel/shmmax> 経由で参照したり、変更したりできる)。"

#. type: TP
#: build/C/man2/shmget.2:274
#, no-wrap
msgid "B<SHMMIN>"
msgstr "B<SHMMIN>"

#. type: Plain text
#: build/C/man2/shmget.2:280
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""
"共有メモリ・セグメントのバイト単位の大きさの下限: 実装依存 (現在は 1 バイトだ"
"が、実質的な最小サイズは B<PAGE_SIZE> である)。"

#. type: TP
#: build/C/man2/shmget.2:280
#, no-wrap
msgid "B<SHMMNI>"
msgstr "B<SHMMNI>"

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: build/C/man2/shmget.2:289
msgid ""
"System wide maximum number of shared memory segments: implementation "
"dependent (currently 4096, was 128 before Linux 2.3.99; on Linux, this limit "
"can be read and modified via I</proc/sys/kernel/shmmni>)."
msgstr ""
"システム全体の共有メモリーの数の上限: 実装依存 (現在は 4096。Linux 2.3.99 よ"
"り前では 128。 Linux では、この上限値は I</proc/sys/kernel/shmmni> 経由で参照"
"したり、変更したりできる)。"

#. type: Plain text
#: build/C/man2/shmget.2:293
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""
"プロセス当りの共有メモリ・セグメントの個数の最大値 (B<SHMSEG>)  に関する実装"
"上の制限はない。"

#. type: Plain text
#: build/C/man2/shmget.2:299
msgid ""
"Until version 2.3.30 Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""
"バージョン 2.3.30 までは、Linux は 削除が予定されている共有メモリ・セグメント"
"に対して B<shmget>()  が行われると B<EIDRM> を返していた。"

#. type: Plain text
#: build/C/man2/shmget.2:305
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""
"B<IPC_PRIVATE> という名前を選んだのはおそらく失敗であろう。 B<IPC_NEW> の方が"
"より明確にその機能を表しているだろう。"

#. type: Plain text
#: build/C/man2/shmget.2:313
msgid ""
"B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr ""
"B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"

#. type: TH
#: build/C/man2/shmop.2:41
#, no-wrap
msgid "SHMOP"
msgstr "SHMOP"

#. type: Plain text
#: build/C/man2/shmop.2:44
msgid "shmat, shmdt - shared memory operations"
msgstr "shmat, shmdt - 共有メモリ (shared memory) の操作"

#. type: Plain text
#: build/C/man2/shmop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/shmop.2:50
#, no-wrap
msgid "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"
msgstr "B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int >I<shmflg>B<);>\n"

#. type: Plain text
#: build/C/man2/shmop.2:52
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr "B<int shmdt(const void *>I<shmaddr>B<);>\n"

#. type: Plain text
#: build/C/man2/shmop.2:61
msgid ""
"B<shmat>()  attaches the shared memory segment identified by I<shmid> to the "
"address space of the calling process.  The attaching address is specified by "
"I<shmaddr> with one of the following criteria:"
msgstr ""
"B<shmat>()  は I<shmid> で指定された共有メモリ・セグメント (shared memory "
"segment) を コールしたプロセスのアドレス空間に付加 (attach) する。 付加するア"
"ドレスは I<shmaddr> に以下のどれかの形式で指定する:"

#. type: Plain text
#: build/C/man2/shmop.2:67
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) address at "
"which to attach the segment."
msgstr ""
"I<shmaddr> が NULL ならば、システムはセグメントを付加するための 適切な (使用"
"されていない) アドレスを選択する。"

#. type: Plain text
#: build/C/man2/shmop.2:82
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>.  Otherwise I<shmaddr> must be a page-aligned address "
"at which the attach occurs."
msgstr ""
"I<shmaddr> が NULL でなく B<SHM_RND> が I<shmflg> に指定されている場合は、 "
"I<shmaddr> を B<SHMLBA> の倍数へと切り捨てた (rounding down) のと等しいアドレ"
"スへ付加する。 その他の場合は I<shmaddr> は付加を行なうアドレスで、ページ境界"
"を指している必要がある。"

#. type: Plain text
#: build/C/man2/shmop.2:92
msgid ""
"If B<SHM_RDONLY> is specified in I<shmflg>, the segment is attached for "
"reading and the process must have read permission for the segment.  "
"Otherwise the segment is attached for read and write and the process must "
"have read and write permission for the segment.  There is no notion of a "
"write-only shared memory segment."
msgstr ""
"B<SHM_RDONLY> が I<shmflg> に指定されていた場合は、 セグメントは読み込み専用"
"に付加され、プロセスはそのセグメントへの 読み込み許可を持たなければならな"
"い。 そうでなければそのセグメントは読み込みと書き込みのために付加され、 プロ"
"セスはそのセグメントに読み込みと書き込みの許可を持つ必要がある。 書き込み専用"
"の共有メモリ・セグメントという概念は存在しない。"

#. type: Plain text
#: build/C/man2/shmop.2:107
msgid ""
"The (Linux-specific)  B<SHM_REMAP> flag may be specified in I<shmflg> to "
"indicate that the mapping of the segment should replace any existing mapping "
"in the range starting at I<shmaddr> and continuing for the size of the "
"segment.  (Normally an B<EINVAL> error would result if a mapping already "
"exists in this address range.)  In this case, I<shmaddr> must not be NULL."
msgstr ""
"(Linux 特有の)  B<SHM_REMAP> フラグが I<shmflg> に指定された場合は、 セグメン"
"トのマッピングを既存のマッピングに置き換える。 マッピングの範囲は、 "
"I<shmaddr> から始まりセグメントのサイズ分だけある (通常 B<EINVAL> エラーは、"
"このアドレス範囲にマッピングが既に存在するために起る)。 このフラグを指定する"
"場合は、 I<shmaddr> が NULL であってはならない。"

#. type: Plain text
#: build/C/man2/shmop.2:114
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""
"呼び出したプロセスの B<brk>(2)  の値は付加によって変化しない。 そのセグメント"
"はプロセスが終了 (exit) したら自動的に分離 (detach) される。 同じセグメントを"
"プロセスのアドレス空間に、読み込み専用および読み書き両用 として付加でき、また"
"複数回付加することもできる。"

#. type: Plain text
#: build/C/man2/shmop.2:122
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""
"成功した B<shmat>()  コールは共有メモリ・セグメントに関連する I<shmid_ds> 構"
"造体 (B<shmctl>(2)  を参照) のメンバーを以下のように更新する:"

#. type: Plain text
#: build/C/man2/shmop.2:125
msgid "I<shm_atime> is set to the current time."
msgstr "I<shm_atime> には現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/shmop.2:128 build/C/man2/shmop.2:154
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr "I<shm_lpid> には呼び出したプロセスのプロセス ID が設定される。"

#. type: Plain text
#: build/C/man2/shmop.2:131
msgid "I<shm_nattch> is incremented by one."
msgstr "I<shm_nattch> を 1 増加させる。"

#. type: Plain text
#: build/C/man2/shmop.2:142
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""
"B<shmdt>()  は呼び出したプロセスのアドレス空間から I<shmaddr> で指定されたア"
"ドレスに配置された共有メモリ・セグメントを分離 (detach) する。 分離する共有メ"
"モリ・セグメントは、現在 I<shmaddr> に付加されているものでなければならない。 "
"I<shmaddr> は、それを付加した時に B<shmat>()  が返した値に等しくなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/shmop.2:148
msgid ""
"On a successful B<shmdt>()  call the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""
"成功した B<shmdt>()  コールはその共有メモリ・セグメントに関連する "
"I<shmid_ds> 構造体のメンバーを以下のように更新する:"

#. type: Plain text
#: build/C/man2/shmop.2:151
msgid "I<shm_dtime> is set to the current time."
msgstr "I<shm_dtime> には現在の時刻が設定される。"

#. type: Plain text
#: build/C/man2/shmop.2:159
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""
"I<shm_nattch> を 1 減少させる。 もし 0 になり、削除マークがあった場合は その"
"セグメントは削除される。"

#. type: Plain text
#: build/C/man2/shmop.2:163
msgid ""
"After a B<fork>(2)  the child inherits the attached shared memory segments."
msgstr ""
"B<fork>(2)  した後、子プロセスは付加された共有メモリ・セグメントを継承する。"

#. type: Plain text
#: build/C/man2/shmop.2:167
msgid ""
"After an B<execve>(2)  all attached shared memory segments are detached from "
"the process."
msgstr ""
"B<exec>(2)  した後、全ての付加された共有メモリ・セグメントはプロセスから分離"
"される。"

#. type: Plain text
#: build/C/man2/shmop.2:171
msgid ""
"Upon B<_exit>(2)  all attached shared memory segments are detached from the "
"process."
msgstr ""
"B<exit>(2)  において、全ての付加された共有メモリ・セグメントはプロセスから分"
"離される。"

#. type: Plain text
#: build/C/man2/shmop.2:179
msgid ""
"On success B<shmat>()  returns the address of the attached shared memory "
"segment; on error I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""
"B<shmat>()  は、成功した場合、 付加された共有メモリ・セグメントのアドレスを返"
"す。 エラーの場合、 I<(void\\ *)\\ -1> を返し、 I<errno> にエラーの原因を示す"
"値を設定する。"

#. type: Plain text
#: build/C/man2/shmop.2:185
msgid ""
"On success B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""
"B<shmdt>()  は、成功すると 0 を返す。 エラーの場合、-1 を返し、 I<errno> にエ"
"ラーの原因を示す値を設定する。"

#. type: Plain text
#: build/C/man2/shmop.2:191
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""
"B<shmat>()  が失敗した場合、 I<errno> に以下の値のどれかを設定して返す:"

#. type: Plain text
#: build/C/man2/shmop.2:197
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability."
msgstr ""
"呼び出したプロセスに要求された種類の付加に必要な許可がなく、 "
"B<CAP_IPC_OWNER> ケーパビリティ (capability) がない。"

#. type: Plain text
#: build/C/man2/shmop.2:214
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""
"I<shmid> の値が不正である。 I<shmaddr> の値が境界違反 (unaligned) (つまり、"
"ページ境界に合っておらず、 B<SHM_RND> が指定されていない) または が不正であ"
"る。 I<shmaddr> へのセグメントの付加に失敗した。 または B<SHM_REMAP> が指定さ"
"れているが、 I<shmaddr> が NULL であった。"

#. type: Plain text
#: build/C/man2/shmop.2:217
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr ""
"ディスクリプター (descriptor) やページ・テーブルのためのメモリを 割り当てるこ"
"とができない。"

#. type: Plain text
#: build/C/man2/shmop.2:223
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr "B<shmdt>()  が失敗した場合、 B<EINVAL> は以下のようにセットされる:"

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: build/C/man2/shmop.2:231
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""
"I<shmaddr> に付加された共有メモリ・セグメントが存在しない。 もしくは、 "
"I<shmaddr> がページ境界に合っていない。"

#. type: Plain text
#: build/C/man2/shmop.2:250
msgid ""
"In SVID 3 (or perhaps earlier)  the type of the I<shmaddr> argument was "
"changed from I<char *> into I<const void *>, and the returned type of "
"B<shmat>()  from I<char *> into I<void *>.  (Linux libc4 and libc5 have the "
"I<char *> prototypes; glibc2 has I<void *>.)"
msgstr ""
"SVID 3 で (たぶんそれより前だと思うが)  I<shmaddr> 引き数の型は I<char *> か"
"ら I<const void *> に、I<shmat>() の返り値の型は I<char *> から I<void *> に"
"変更された (Linux では libc4 と libc5 のプロトタイプは I<char *> であり、"
"glibc2 のプロトタイプは I<void *> である)。"

#. type: Plain text
#: build/C/man2/shmop.2:262
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""
"共有メモリセグメントを付加する場合の移植性の高い方法としては、 I<shmaddr> を "
"NULL にして B<shmat>()  を使用するのがよい。 このような方法で付加される共有メ"
"モリセグメントは、 プロセスが異なれば別のアドレスに付加される、という点に注意"
"すること。 よって共有メモリ内で管理されるポインタは、 絶対アドレスではなく、 "
"(一般的にはセグメントの開始アドレスからの)  相対アドレスで作成するべきであ"
"る。"

#. type: Plain text
#: build/C/man2/shmop.2:267
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1-2001 does not specify this "
"behavior and many other implementations do not support it."
msgstr ""
"Linux では共有メモリセグメントに既に削除マークが付けられていても、 その共有メ"
"モリセグメントを付加することができる。 しかし POSIX.1-2001 ではこのような動作"
"を指定しておらず、 他の多くの実装もこれをサポートしていない。"

#. type: Plain text
#: build/C/man2/shmop.2:270
msgid "The following system parameter affects B<shmat>():"
msgstr "以下のシステム・パラメーターは、 B<shmat>()  に影響する:"

#.  FIXME A good explanation of the rationale for the existence
#.  of SHMLBA would be useful here
#. type: TP
#: build/C/man2/shmop.2:270
#, no-wrap
msgid "B<SHMLBA>"
msgstr "B<SHMLBA>"

#.  FIXME That last sentence isn't true for all Linux
#.  architectures (i.e., SHMLBA != PAGE_SIZE for some architectures)
#.  -- MTK, Nov 04
#. type: Plain text
#: build/C/man2/shmop.2:283
msgid ""
"Segment low boundary address multiple.  Must be page aligned.  For the "
"current implementation the B<SHMLBA> value is B<PAGE_SIZE>."
msgstr ""
"セグメントの境界アドレスの最小倍数。ページ境界に合ってなければならない。 現在"
"の実装では B<SHMLBA> の値は B<PAGE_SIZE> である。"

#. type: Plain text
#: build/C/man2/shmop.2:287
msgid ""
"The implementation places no intrinsic limit on the per-process maximum "
"number of shared memory segments (B<SHMSEG>)."
msgstr ""
"現在の実装では、プロセスごとの 共有メモリ・セグメントの最大数 (B<SHMSEG>)  に"
"関する実装依存の制限はない。"

#. type: Plain text
#: build/C/man2/shmop.2:295
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"

#. type: TH
#: build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr "SUBPAGE_PROT"

#. type: TH
#: build/C/man2/subpage_prot.2:30
#, fuzzy, no-wrap
#| msgid "2012-04-23"
msgid "2012-07-13"
msgstr "2012-04-23"

#. type: Plain text
#: build/C/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"

#. type: Plain text
#: build/C/man2/subpage_prot.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4kB subpages on systems "
"configured with a page size of 64kB."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4kB subpage; thus each 32-bit word specifies the protections "
"of 16 4kB subpages inside a 64kB page (so, the number of 32-bit words "
"pointed to by I<map> should equate to the number of 64-kB pages specified by "
"I<len>).  Each 2-bit field in the protection map is either 0 to allow any "
"access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr "メモリ不足である。"

#. type: Plain text
#: build/C/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:101
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""

#. type: SS
#: build/C/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr ""

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4k hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: build/C/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the memory-"
"management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is "
"slow.)  The idea is that the emulator supplies an array of protection masks "
"to apply to a specified range of virtual addresses.  These masks are applied "
"at the level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:131
#, fuzzy
#| msgid "B<mprotect>(2), B<syscall>(2);"
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr "B<mprotect>(2), B<syscall>(2);"

#. type: Plain text
#: build/C/man2/subpage_prot.2:134
msgid "I<Documentation/vm/hugetlbpage.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr "SYNC_FILE_RANGE"

#. type: Plain text
#: build/C/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr "sync_file_range - ファイルセグメントをディスクと同期する"

#. type: Plain text
#: build/C/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t >I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""
"B<sync_file_range>()  を使うと、ファイルディスクリプタ I<fd> で参照されるオー"
"プンされたファイルのディスクとの同期に関して、 きめ細かな制御が可能となる。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""
"I<offset> は、同期を行うファイルの領域の開始バイトである。 I<nbytes> には同期"
"を行う領域の長さをバイト単位で指定する。 I<nbytes> が 0 の場合は、 I<offset> "
"からファイル末尾までの全バイトを同期する。 同期はシステムのページサイズの単位"
"で行われる。 I<offset> はページ境界にあわせて切り下げられ、 I<(offset"
"+nbytes-1)> はページ境界にあわせて切り上げられる。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr "ビットマスク引き数 I<flags> には以下の値を指定することができる:"

#. type: TP
#: build/C/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""
"何らかの書き込みを行う前に、指定された領域のページで 書き出しを行うようにデバ"
"イスドライバにすでに要求が発行されている ページの書き出しが全て完了するのを待"
"つ。"

#. type: TP
#: build/C/man2/sync_file_range.2:70 build/C/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr "B<SYNC_FILE_RANGE_WRITE>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""
"指定された領域のページで、書き出し要求が発行されていない 全ての dirty (キャッ"
"シュだけが変更されている) ページの 書き出しを開始する。 リクエストキューの大"
"きさより多く書き込もうとした場合には、 この処理は停止 (block) する可能性があ"
"る点に注意すること。"

#. type: TP
#: build/C/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:80
msgid ""
"Wait upon write-out of all pages in the range after performing any write."
msgstr ""
"何らかの書き込み後に、指定された領域の全てのページの 書き出しが行われるのを待"
"つ。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr "I<flags> に 0 を指定した場合、何もしないことを表す。"

#. type: SS
#: build/C/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr "警告"

#. type: Plain text
#: build/C/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On file systems using copy-on-write semantics (e."
"g., I<btrfs>)  an overwrite of existing allocated blocks is impossible.  "
"When writing into preallocated space, many file systems also require calls "
"into the block allocator, which this system call does not sync out to disk.  "
"This system call does not flush disk write caches and thus does not provide "
"any data integrity on systems with volatile disk write caches."
msgstr ""
"このシステムコールは非常に危険であり、 移植性が必要なプログラムで使用すべきで"
"はない。 これらの操作ではどれもファイルのメタデータの書き出しを行わない。 し"
"たがって、アプリケーションにより作成済みのディスクブロックの 上書きの実行が確"
"実に行われない限り、クラッシュの後でもデータが 利用できる保証はない。 書き込"
"みが上書きだけであるかを知るためのユーザインタフェースは存在しない。 "
"(I<btrfs> などの) copy-on-write 動作を使ったファイルシステムでは、 既存の割り"
"当て済みのブロックに対する上書き自体ができない。 前もって割り当てられた領域に"
"書き込みを行う場合、 多くのファイルシステムでは block allocator への書き込み"
"も必要となるが、 このシステムコールは block allocator のディスクへの同期を行"
"わない。 このシステムコールはディスク書き込みキャッシュのフラッシュを 行わな"
"いので、揮発性のディスク書き込みキャッシュを使ったシステムでは このシステム"
"コールではデータの一貫性を確保できないことになる。"

#. type: SS
#: build/C/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr "詳細"

#. type: Plain text
#: build/C/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> と B<SYNC_FILE_RANGE_WAIT_AFTER> は I/O エラー"
"や B<ENOSPC> 状態を検出し、呼び出し元にこれらの情報を返す。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr "I<flags> の役に立つビットの組み合わせを以下に示す:"

#. type: TP
#: build/C/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""
"指定された範囲内のページで、 B<sync_file_range>()  が呼び出された際に dirty "
"であった全てのページが、 確実に書き出し対象となるようにする。 これは、start-"
"write-for-data-integrity 操作 (データ完全性確保のための書き込み開始の操作) で"
"ある。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""
"指定された範囲内のページで、現在書き出し中でない全ての dirty ページの 書き出"
"しを開始する。これは非同期のディスクへのフラッシュ (flush-to-disk)  操作であ"
"る。データ完全性確保が必要な操作としては適切ではない。"

#. type: TP
#: build/C/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"

#. type: Plain text
#: build/C/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""
"指定された範囲内の全てのページの書き出しの完了を待つ。 このフラグは、前に行わ"
"れた操作 B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE> の後に使用で"
"き、この操作の完了を待ち、結果を取得することができる。"

#. type: TP
#: build/C/man2/sync_file_range.2:134
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | SYNC_FILE_RANGE_WAIT_AFTER>"

#. type: Plain text
#: build/C/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""
"これは write-for-data-integrity 操作 (データ完全性確保のための書き込み) であ"
"り、指定された範囲内の、 B<sync_file_range>()  が呼ばれた時点で dirty な全て"
"のページが ディスクに格納されることが保証される。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功の場合、 B<sync_file_range>()  は 0 を返す。失敗の場合、-1 を返し、 "
"I<error> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプタではない。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:160
msgid ""
"I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""
"I<flags> に不正なビットが指定されている。または I<offset> か I<nbytes> が不正"
"である。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:163
msgid "I/O error."
msgstr "I/O エラー。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr "ディスク領域不足である。"

#.  FIXME . (bug?) Actually, how can 'fd' refer to a symbolic link (S_ISLNK)?
#.  (In user space at least) it isn't possible to obtain a file descriptor
#.  for a symbolic link.
#. type: Plain text
#: build/C/man2/sync_file_range.2:177
msgid ""
"I<fd> refers to something other than a regular file, a block device, a "
"directory, or a symbolic link."
msgstr ""
"I<fd> が、通常のファイル、ブロックデバイス、ディレクトリ、シンボリックリンク "
"以外のものを指している。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:180
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr "B<sync_file_range>()  はカーネル 2.6.17 で Linux に登場した。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:183
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""
"このシステムコールは Linux 独自であり、 移植性が必要なプログラムでは使用を避"
"けるべきである。"

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: build/C/man2/sync_file_range.2:196
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  is flawed, since it forces a register to be wasted "
"as padding between the I<fd> and I<offset> arguments.  Therefore, these "
"architectures define a different system call that orders the arguments "
"suitably:"
msgstr ""
"いくつかのアーキテクチャ (例えば、 PowerPC や ARM) では、 64 ビットの\n"
"引き数は適切なレジスタの組に割り当てる必要がある。このようなアーキテク\n"
"チャでは、 B<sync_file_range>() の呼び出し方には欠陥があり、それはこの\n"
"システムコールでは引き数 I<fd> と I<offset> の間のパディング (詰めもの)\n"
"でレジスタが一つ消費されてしまうというものである。そのため、これらの\n"
"アーキテクチャでは引き数が適切な順序になった別のシステムコールが定義\n"
"されている。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:201
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"

#. type: Plain text
#: build/C/man2/sync_file_range.2:206
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""
"上記の点以外は、このシステムコールの動作は B<sync_file_range>() と\n"
"全く同じである。このシステムコールに対するライブラリによるサポートは\n"
"glibc では提供されていない。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:217
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""
"このバージョンのシステムコールは、Linux 2.6.20 で ARM アーキテクチャで\n"
"初めて登場し、 B<arm_sync_file_range>() という名前であった。\n"
"Linux 2.6.22 で、同様のシステムコールが PowerPC 用に追加された際に、\n"
"システムコールの名前が変更された。\n"
"glibc によるサポートが提供されているアーキテクチャでは、\n"
"glibc のラッパー関数は B<sync_file_range>() という名前で\n"
"B<sync_file_range2>() を適切に使用するようになっている。"

#. type: Plain text
#: build/C/man2/sync_file_range.2:222
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"

#~ msgid "2011-09-08"
#~ msgstr "2011-09-08"

#~ msgid "2010-09-20"
#~ msgstr "2010-09-20"

#~ msgid "2008-08-07"
#~ msgstr "2008-08-07"

#~ msgid "2006-05-02"
#~ msgstr "2006-05-02"

#~ msgid "2008-06-03"
#~ msgstr "2008-06-03"

#~ msgid "2010-10-30"
#~ msgstr "2010-10-30"

#~ msgid "the kernel source file I<Documentation/vm/hugetlbpage.txt>."
#~ msgstr "カーネルソースファイルの I<Documentation/vm/hugetlbpage.txt>"

#~ msgid ""
#~ "The I<mode> is not supported by the file system containing the file "
#~ "referred to by I<fd>."
#~ msgstr ""
#~ "I<fd> が参照するファイルを含むファイルシステムが I<mode> をサポートしてい"
#~ "ない。"

#~ msgid ""
#~ "The function B<mtrace>()  installs handlers for B<malloc>(3), B<realloc>"
#~ "(3)  and B<free>(3).  The function B<muntrace>()  disables these handlers."
#~ msgstr ""
#~ "関数 B<mtrace>()  は、 B<malloc>(3), B<realloc>(3), B<free>(3)  のハンドラ"
#~ "を組み込む。 関数 B<muntrace>()  はこれらのハンドラを解除する。"

#~ msgid ""
#~ "The environment variable B<MALLOC_TRACE> defines a file where B<mtrace>"
#~ "()  writes its output.  This file must be writable to the user or "
#~ "B<mtrace>()  will do nothing.  If the file is not empty it will be "
#~ "truncated."
#~ msgstr ""
#~ "環境変数 B<MALLOC_TRACE> は B<mtrace>()  が出力を書き出すファイルを指定す"
#~ "る。 ユーザが書き込み権限を持つファイルを指定しなければならない。 書き込み"
#~ "権限がない場合、 B<mtrace>()  は何もしない。 ファイルが空でない場合、ファ"
#~ "イルの元の内容を上書きする。"

#~ msgid "These are GNU extensions."
#~ msgstr "この関数は GNU 拡張である。"

#~ msgid ""
#~ "The output of B<mtrace>()  will be ASCII but not in a friendly format.  "
#~ "So glibc comes with a perl-script called mtrace to make sense of it."
#~ msgstr ""
#~ "B<mtrace>()  の出力は ASCII 形式だが、人が読みやすいフォーマットではな"
#~ "い。 そこで、glibc には mtrace 出力を分かりやすい形式に変換する perl スク"
#~ "リプトが付属している。"

#~ msgid ""
#~ "This flag allocates and initializes to zero the disk space within the "
#~ "range specified by I<offset> and I<len>.  After a successful call, "
#~ "subsequent writes into this range are guaranteed not to fail because of "
#~ "lack of disk space.  Preallocating zeroed blocks beyond the end of the "
#~ "file is useful for optimizing append workloads.  Preallocating blocks "
#~ "does not change the file size (as reported by B<stat>(2))  even if it is "
#~ "less than I<offset>+I<len>."
#~ msgstr ""
#~ "このフラグは、 I<offset> と I<len> で指定された領域のディスク空間を割り当"
#~ "て、その空間を 0 で初期化する。 呼び出しが成功すると、それに続いてこの領域"
#~ "への書き込みが行われるが、 ディスク空間の不足による書き込み失敗が発生しな"
#~ "いことが保証される。 ファイル末尾より後ろの領域について 0 で埋めたブロック"
#~ "を前もって 割り当てておくことは、追記 (append) の作業負荷を最適化するのに "
#~ "有用である。 ファイルサイズが I<offset>+I<len> よりも小さい場合であって"
#~ "も、ブロックの前もっての割り当てにより (B<stat>(2)  が返す) ファイルサイズ"
#~ "は変更されることはない。"

#~ msgid ""
#~ "(Linux 2.6.9 and later) the caller was not privileged (B<CAP_IPC_LOCK>)  "
#~ "and its B<RLIMIT_MEMLOCK> soft resource limit was 0."
#~ msgstr ""
#~ "(Linux 2.6.9 以降) 呼び出し元は特権 (B<CAP_IPC_LOCK>)  を持たず、ソフト資"
#~ "源制限 B<RLIMIT_MEMLOCK> が 0 である。"

#~ msgid ""
#~ "(Linux 2.6.8 and earlier)  The calling process has insufficient privilege "
#~ "to call B<munlockall>().  Under Linux the B<CAP_IPC_LOCK> capability is "
#~ "required."
#~ msgstr ""
#~ "(Linux 2.6.8 以前)  呼び出し元プロセスが B<munlockall>()  を呼び出すのに必"
#~ "要な特権を所有していなかった。 Linux では、 B<CAP_IPC_LOCK> ケーパビリティ"
#~ "が必要である。"

#~ msgid ""
#~ "B<posix_fadvise>()  appeared in kernel 2.5.60.  Glibc support has been "
#~ "provided since version 2.2."
#~ msgstr ""
#~ "B<posix_fadvise>()  はカーネル 2.5.60 で登場した。 glibc でのサポートは "
#~ "glibc バージョン 2.2 以降で行われている。"

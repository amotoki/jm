# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-19 23:50+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "2007-05-31"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man2/cacheflush.2:24 build/C/man2/fallocate.2:7 build/C/man2/madvise.2:35 build/C/man2/mlock.2:27 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:32 build/C/man2/mremap.2:31 build/C/man2/msync.2:25 build/C/man2/posix_fadvise.2:27 build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:26 build/C/man3/shm_open.3:26 build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:43 build/C/man2/shmget.2:36 build/C/man2/shmop.2:39 build/C/man2/subpage_prot.2:28 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/alloca.3:41 build/C/man2/cacheflush.2:24 build/C/man2/fallocate.2:7 build/C/man2/madvise.2:35 build/C/man3/malloc_hook.3:6 build/C/man2/mlock.2:27 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:32 build/C/man2/mremap.2:31 build/C/man2/msync.2:25 build/C/man3/mtrace.3:4 build/C/man2/posix_fadvise.2:27 build/C/man3/posix_fallocate.3:23 build/C/man3/posix_memalign.3:26 build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:26 build/C/man3/shm_open.3:26 build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:43 build/C/man2/shmget.2:36 build/C/man2/shmop.2:39 build/C/man2/subpage_prot.2:28 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:26 build/C/man3/alloca.3:42 build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:8 build/C/man2/madvise.2:36 build/C/man3/malloc_hook.3:7 build/C/man2/mlock.2:28 build/C/man2/mmap.2:41 build/C/man2/mmap2.2:30 build/C/man2/mprotect.2:33 build/C/man2/mremap.2:32 build/C/man2/msync.2:26 build/C/man3/mtrace.3:5 build/C/man2/posix_fadvise.2:28 build/C/man3/posix_fallocate.3:24 build/C/man3/posix_memalign.3:27 build/C/man2/readahead.2:29 build/C/man2/remap_file_pages.2:27 build/C/man3/shm_open.3:27 build/C/man7/shm_overview.7:28 build/C/man2/shmctl.2:44 build/C/man2/shmget.2:37 build/C/man2/shmop.2:40 build/C/man2/subpage_prot.2:29 build/C/man2/sync_file_range.2:31
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:28 build/C/man3/alloca.3:44 build/C/man2/cacheflush.2:27 build/C/man2/fallocate.2:10 build/C/man2/madvise.2:38 build/C/man3/malloc_hook.3:11 build/C/man2/mlock.2:30 build/C/man2/mmap.2:43 build/C/man2/mmap2.2:32 build/C/man2/mprotect.2:35 build/C/man2/mremap.2:34 build/C/man2/msync.2:28 build/C/man3/mtrace.3:7 build/C/man2/posix_fadvise.2:30 build/C/man3/posix_fallocate.3:26 build/C/man3/posix_memalign.3:29 build/C/man2/readahead.2:31 build/C/man2/remap_file_pages.2:29 build/C/man3/shm_open.3:29 build/C/man2/shmctl.2:46 build/C/man2/shmget.2:39 build/C/man2/shmop.2:42 build/C/man2/subpage_prot.2:31 build/C/man2/sync_file_range.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t "
">I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:38 build/C/man3/alloca.3:48 build/C/man2/cacheflush.2:33 build/C/man2/fallocate.2:18 build/C/man2/madvise.2:50 build/C/man3/malloc_hook.3:29 build/C/man2/mlock.2:40 build/C/man2/mmap.2:52 build/C/man2/mmap2.2:39 build/C/man2/mprotect.2:41 build/C/man2/mremap.2:43 build/C/man2/msync.2:32 build/C/man3/mtrace.3:13 build/C/man2/posix_fadvise.2:49 build/C/man3/posix_fallocate.3:44 build/C/man3/posix_memalign.3:70 build/C/man2/readahead.2:38 build/C/man2/remap_file_pages.2:37 build/C/man3/shm_open.3:41 build/C/man7/shm_overview.7:30 build/C/man2/shmctl.2:54 build/C/man2/shmget.2:47 build/C/man2/shmop.2:51 build/C/man2/subpage_prot.2:36 build/C/man2/sync_file_range.2:41
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20 "
"the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4 KiB)  "
"and huge pages (2 or 4 MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is "
"returned when no segment with the given key exists."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:109 build/C/man3/alloca.3:58 build/C/man2/cacheflush.2:52 build/C/man2/fallocate.2:81 build/C/man2/madvise.2:250 build/C/man2/mlock.2:117 build/C/man2/mmap.2:373 build/C/man2/mmap2.2:50 build/C/man2/mprotect.2:72 build/C/man2/mremap.2:128 build/C/man2/msync.2:68 build/C/man2/posix_fadvise.2:86 build/C/man3/posix_fallocate.3:64 build/C/man3/posix_memalign.3:111 build/C/man2/readahead.2:65 build/C/man2/remap_file_pages.2:122 build/C/man3/shm_open.3:169 build/C/man2/shmctl.2:272 build/C/man2/shmget.2:178 build/C/man2/shmop.2:169 build/C/man2/subpage_prot.2:61 build/C/man2/sync_file_range.2:141
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and "
"B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:118 build/C/man2/cacheflush.2:58 build/C/man2/fallocate.2:84 build/C/man2/madvise.2:257 build/C/man2/mlock.2:123 build/C/man2/mmap.2:390 build/C/man2/mmap2.2:57 build/C/man2/mprotect.2:79 build/C/man2/mremap.2:136 build/C/man2/msync.2:73 build/C/man2/posix_fadvise.2:89 build/C/man3/posix_fallocate.3:70 build/C/man3/posix_memalign.3:123 build/C/man2/readahead.2:71 build/C/man2/remap_file_pages.2:129 build/C/man3/shm_open.3:178 build/C/man2/shmctl.2:294 build/C/man2/shmget.2:182 build/C/man2/shmop.2:183 build/C/man2/subpage_prot.2:66 build/C/man2/sync_file_range.2:147
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/alloc_hugepages.2:119 build/C/man2/fallocate.2:117
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:122
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:126
msgid ""
"I</proc/sys/vm/nr_hugepages> Number of configured hugetlb pages.  This can "
"be read and written."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:130
msgid ""
"I</proc/meminfo> Gives info on the number of configured hugetlb pages and on "
"their size in the three variables HugePages_Total, HugePages_Free, "
"Hugepagesize."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:130 build/C/man3/alloca.3:63 build/C/man2/cacheflush.2:74 build/C/man2/fallocate.2:142 build/C/man2/madvise.2:307 build/C/man3/malloc_hook.3:76 build/C/man2/mlock.2:187 build/C/man2/mmap.2:483 build/C/man2/mmap2.2:73 build/C/man2/mprotect.2:107 build/C/man2/mremap.2:186 build/C/man2/msync.2:96 build/C/man3/mtrace.3:34 build/C/man2/posix_fadvise.2:111 build/C/man3/posix_fallocate.3:101 build/C/man3/posix_memalign.3:142 build/C/man2/readahead.2:87 build/C/man2/remap_file_pages.2:151 build/C/man3/shm_open.3:249 build/C/man7/shm_overview.7:101 build/C/man2/shmctl.2:366 build/C/man2/shmget.2:229 build/C/man2/shmop.2:226 build/C/man2/subpage_prot.2:91 build/C/man2/sync_file_range.2:180
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:133
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:133 build/C/man3/alloca.3:71 build/C/man2/madvise.2:328 build/C/man3/malloc_hook.3:78 build/C/man2/mlock.2:214 build/C/man2/mmap.2:501 build/C/man2/mmap2.2:75 build/C/man2/mprotect.2:116 build/C/man2/mremap.2:192 build/C/man3/mtrace.3:36 build/C/man2/posix_fadvise.2:120 build/C/man3/posix_memalign.3:179 build/C/man3/shm_open.3:255 build/C/man7/shm_overview.7:103 build/C/man2/shmctl.2:371 build/C/man2/shmget.2:235 build/C/man2/shmop.2:245 build/C/man2/subpage_prot.2:93 build/C/man2/sync_file_range.2:183
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:141
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs file system can be used instead.  Memory backed "
"by huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual file system."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:145
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:150 build/C/man3/alloca.3:153 build/C/man2/cacheflush.2:88 build/C/man2/fallocate.2:149 build/C/man2/madvise.2:360 build/C/man3/malloc_hook.3:138 build/C/man2/mlock.2:337 build/C/man2/mmap.2:667 build/C/man2/mmap2.2:94 build/C/man2/mprotect.2:223 build/C/man2/mremap.2:214 build/C/man2/msync.2:122 build/C/man3/mtrace.3:44 build/C/man2/posix_fadvise.2:188 build/C/man3/posix_fallocate.3:130 build/C/man3/posix_memalign.3:235 build/C/man2/readahead.2:98 build/C/man2/remap_file_pages.2:162 build/C/man3/shm_open.3:280 build/C/man7/shm_overview.7:127 build/C/man2/shmctl.2:410 build/C/man2/shmget.2:298 build/C/man2/shmop.2:290 build/C/man2/subpage_prot.2:126 build/C/man2/sync_file_range.2:222
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:157 build/C/man3/alloca.3:160 build/C/man2/cacheflush.2:95 build/C/man2/fallocate.2:156 build/C/man2/madvise.2:367 build/C/man3/malloc_hook.3:145 build/C/man2/mlock.2:344 build/C/man2/mmap.2:674 build/C/man2/mmap2.2:101 build/C/man2/mprotect.2:230 build/C/man2/mremap.2:221 build/C/man2/msync.2:129 build/C/man3/mtrace.3:51 build/C/man2/posix_fadvise.2:195 build/C/man3/posix_fallocate.3:137 build/C/man3/posix_memalign.3:242 build/C/man2/readahead.2:105 build/C/man2/remap_file_pages.2:169 build/C/man3/shm_open.3:287 build/C/man7/shm_overview.7:134 build/C/man2/shmctl.2:417 build/C/man2/shmget.2:305 build/C/man2/shmop.2:297 build/C/man2/subpage_prot.2:133 build/C/man2/sync_file_range.2:229
msgid ""
"This page is part of release 3.35 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://man7.org/linux/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:41
#, no-wrap
msgid "ALLOCA"
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:41
#, no-wrap
msgid "2008-01-24"
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:41 build/C/man3/malloc_hook.3:6 build/C/man3/mtrace.3:4 build/C/man3/posix_fallocate.3:23 build/C/man3/posix_memalign.3:26
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:44
msgid "alloca - allocate memory that is automatically freed"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:46
msgid "B<#include E<lt>alloca.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:48
msgid "B<void *alloca(size_t >I<size>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:58
msgid ""
"The B<alloca>()  function allocates I<size> bytes of space in the stack "
"frame of the caller.  This temporary space is automatically freed when the "
"function that called B<alloca>()  returns to its caller."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:63
msgid ""
"The B<alloca>()  function returns a pointer to the beginning of the "
"allocated space.  If the allocation causes stack overflow, program behavior "
"is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:65
msgid "This function is not in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:71
msgid ""
"There is evidence that the B<alloca>()  function appeared in 32V, PWB, "
"PWB.2, 3BSD, and 4BSD.  There is a man page for it in 4.3BSD.  Linux uses "
"the GNU version."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:86
msgid ""
"The B<alloca>()  function is machine- and compiler-dependent.  For certain "
"applications, its use can improve efficiency compared to the use of "
"B<malloc>(3)  plus B<free>(3).  In certain cases, it can also simplify "
"memory deallocation in applications that use B<longjmp>(3)  or "
"B<siglongjmp>(3).  Otherwise, its use is discouraged."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:95
msgid ""
"Because the space allocated by B<alloca>()  is allocated within the stack "
"frame, that space is automatically freed if the function return is jumped "
"over by a call to B<longjmp>(3)  or B<siglongjmp>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:100
msgid "Do not attempt to B<free>(3)  space allocated by B<alloca>()!"
msgstr ""

#. type: SS
#: build/C/man3/alloca.3:100
#, no-wrap
msgid "Notes on the GNU Version"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:122
msgid ""
"Normally, B<gcc>(1)  translates calls to B<alloca>()  with inlined code.  "
"This is not done when either the I<-ansi>, I<-std=c89>, I<-std=c99>, or the "
"I<-fno-builtin> option is given (and the header I<E<lt>alloca.hE<gt>> is not "
"included).  But beware! By default the glibc version of "
"I<E<lt>stdlib.hE<gt>> includes I<E<lt>alloca.hE<gt>> and that contains the "
"line:"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:125
#, no-wrap
msgid "    #define alloca(size)   __builtin_alloca (size)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:128
msgid "with messy consequences if one has a private version of this function."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:132
msgid ""
"The fact that the code is inlined means that it is impossible to take the "
"address of this function, or to change its behavior by linking with a "
"different library."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:136
msgid ""
"The inlined code often consists of a single instruction adjusting the stack "
"pointer, and does not check for stack overflow.  Thus, there is no NULL "
"error return."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:136 build/C/man2/cacheflush.2:81 build/C/man2/mlock.2:305 build/C/man2/mmap.2:540 build/C/man2/posix_fadvise.2:177 build/C/man2/shmget.2:284
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:141
msgid ""
"There is no error indication if the stack frame cannot be extended.  "
"(However, after a failed allocation, the program is likely to receive a "
"B<SIGSEGV> signal if it attempts to access the unallocated space.)"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:149
msgid ""
"On many systems B<alloca>()  cannot be used inside the list of arguments of "
"a function call, because the stack space reserved by B<alloca>()  would "
"appear on the stack in the middle of the space for the function arguments."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:149 build/C/man2/fallocate.2:145 build/C/man2/madvise.2:353 build/C/man3/malloc_hook.3:133 build/C/man2/mlock.2:330 build/C/man2/mmap.2:649 build/C/man2/mmap2.2:88 build/C/man2/mprotect.2:220 build/C/man2/mremap.2:200 build/C/man2/msync.2:118 build/C/man3/mtrace.3:41 build/C/man2/posix_fadvise.2:182 build/C/man3/posix_fallocate.3:126 build/C/man3/posix_memalign.3:230 build/C/man2/readahead.2:92 build/C/man2/remap_file_pages.2:155 build/C/man3/shm_open.3:269 build/C/man7/shm_overview.7:114 build/C/man2/shmctl.2:403 build/C/man2/shmget.2:290 build/C/man2/shmop.2:282 build/C/man2/subpage_prot.2:120 build/C/man2/sync_file_range.2:217
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:153
msgid "B<brk>(2), B<longjmp>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/cacheflush.2:24
#, no-wrap
msgid "CACHEFLUSH"
msgstr ""

#. type: TH
#: build/C/man2/cacheflush.2:24
#, no-wrap
msgid "2007-05-26"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:27
msgid "cacheflush - flush contents of instruction and/or data cache"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:30
#, no-wrap
msgid "B<#include E<lt>asm/cachectl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:32
#, no-wrap
msgid "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:42
msgid ""
"B<cacheflush>()  flushes the contents of the indicated cache(s) for the user "
"addresses in the range I<addr> to I<(addr+nbytes-1)>.  I<cache> may be one "
"of:"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:42
#, no-wrap
msgid "B<ICACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:45
msgid "Flush the instruction cache."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:45
#, no-wrap
msgid "B<DCACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:48
msgid "Write back to memory and invalidate the affected valid cache lines."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:48
#, no-wrap
msgid "B<BCACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:52
msgid "Same as B<(ICACHE|DCACHE)>."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:58
msgid ""
"B<cacheflush>()  returns 0 on success or -1 on error.  If errors are "
"detected, I<errno> will indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:59 build/C/man2/mmap2.2:58 build/C/man2/mremap.2:143 build/C/man2/shmctl.2:303 build/C/man2/subpage_prot.2:67
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:66
msgid ""
"Some or all of the address range I<addr> to I<(addr+nbytes-1)> is not "
"accessible."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:66 build/C/man2/fallocate.2:96 build/C/man2/madvise.2:264 build/C/man2/mlock.2:158 build/C/man2/mlock.2:165 build/C/man2/mlock.2:177 build/C/man2/mmap.2:421 build/C/man2/mmap.2:429 build/C/man2/mmap.2:434 build/C/man2/mmap2.2:61 build/C/man2/mprotect.2:89 build/C/man2/mremap.2:152 build/C/man2/msync.2:80 build/C/man2/posix_fadvise.2:93 build/C/man3/posix_fallocate.3:79 build/C/man3/posix_memalign.3:124 build/C/man2/readahead.2:76 build/C/man2/remap_file_pages.2:130 build/C/man2/remap_file_pages.2:137 build/C/man3/shm_open.3:211 build/C/man2/shmctl.2:317 build/C/man2/shmget.2:196 build/C/man2/shmop.2:195 build/C/man2/shmop.2:218 build/C/man2/subpage_prot.2:72 build/C/man2/sync_file_range.2:152
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:74
msgid "I<cache> is not one of B<ICACHE>, B<DCACHE>, or B<BCACHE>."
msgstr ""

#.  FIXME This system call was only on MIPS back in 1.2 days, but
#.  by now it is on a number of other architectures (but not i386).
#.  Investigate the details and update this page.
#.  Irix 6.5 appears to have a cacheflush() syscall -- mtk
#. type: Plain text
#: build/C/man2/cacheflush.2:81
msgid ""
"This Linux-specific system call is only available on MIPS-based systems.  It "
"should not be used in programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:88
msgid ""
"The current implementation ignores the I<addr> and I<nbytes> arguments.  "
"Therefore, the whole cache is always flushed."
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:7
#, no-wrap
msgid "FALLOCATE"
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:7
#, no-wrap
msgid "2011-09-19"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:10
msgid "fallocate - manipulate file space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:14 build/C/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:17
#, no-wrap
msgid ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:23
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:33
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:39
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Currently only one flag is supported for I<mode>:"
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:39
#, no-wrap
msgid "B<FALLOC_FL_KEEP_SIZE>"
msgstr ""

#
#.  Note from Amit Arora:
#.  There were few more flags which were discussed, but none of
#.  them have been finalized upon. Here are these flags:
#.  FA_FL_DEALLOC, FA_FL_DEL_DATA, FA_FL_ERR_FREE, FA_FL_NO_MTIME,
#.  FA_FL_NO_CTIME
#.  All of the above flags were debated upon and we can not say
#.  if any/which one of these flags will make it to the later kernels.
#. type: Plain text
#: build/C/man2/fallocate.2:63
msgid ""
"This flag allocates and initializes to zero the disk space within the range "
"specified by I<offset> and I<len>.  After a successful call, subsequent "
"writes into this range are guaranteed not to fail because of lack of disk "
"space.  Preallocating zeroed blocks beyond the end of the file is useful for "
"optimizing append workloads.  Preallocating blocks does not change the file "
"size (as reported by B<stat>(2))  even if it is less than I<offset>+I<len>."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:77
msgid ""
"If B<FALLOC_FL_KEEP_SIZE> flag is not specified in I<mode>, the default "
"behavior is almost same as when this flag is specified.  The only difference "
"is that on success, the file size will be changed if I<offset + len> is "
"greater than the file size.  This default behavior closely resembles the "
"behavior of the B<posix_fallocate>(3)  library function, and is intended as "
"a method of optimally implementing that function."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:81
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range than that which was specified."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:84
msgid "B<fallocate>()  returns zero on success, and -1 on failure."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:85 build/C/man2/madvise.2:261 build/C/man2/mmap.2:415 build/C/man2/posix_fadvise.2:90 build/C/man3/posix_fallocate.3:71 build/C/man2/readahead.2:72 build/C/man2/sync_file_range.2:148
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:89 build/C/man3/posix_fallocate.3:75
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:89 build/C/man3/posix_fallocate.3:75
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:93
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:93
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:96
msgid "A signal was caught during execution."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:102 build/C/man3/posix_fallocate.3:85
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:102 build/C/man2/madvise.2:292 build/C/man2/sync_file_range.2:160
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:105
msgid "An I/O error occurred while reading from or writing to a file system."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:105 build/C/man2/mmap.2:450 build/C/man3/posix_fallocate.3:85
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:112
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:112 build/C/man3/posix_fallocate.3:89 build/C/man2/shmget.2:214 build/C/man2/sync_file_range.2:166
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:117 build/C/man3/posix_fallocate.3:94
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:122
msgid ""
"The file system containing the file referred to by I<fd> does not support "
"this operation."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:122
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:128
msgid ""
"The I<mode> is not supported by the file system containing the file referred "
"to by I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:128 build/C/man2/mlock.2:144 build/C/man2/mlock.2:183 build/C/man2/mmap.2:458 build/C/man2/shmctl.2:342 build/C/man2/shmget.2:222
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:134
msgid "The file referred to by I<fd> is marked immutable (see B<chattr>(1))."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:134 build/C/man2/posix_fadvise.2:96 build/C/man3/posix_fallocate.3:94 build/C/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:138
msgid "I<fd> refers to a pipe or FIFO."
msgstr ""

#. type: SH
#: build/C/man2/fallocate.2:138 build/C/man2/mmap2.2:70 build/C/man2/posix_fadvise.2:103 build/C/man3/posix_fallocate.3:98 build/C/man3/posix_memalign.3:133 build/C/man2/readahead.2:82 build/C/man2/remap_file_pages.2:146 build/C/man3/shm_open.3:247 build/C/man2/subpage_prot.2:85 build/C/man2/sync_file_range.2:177
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:142
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:145
msgid "B<fallocate>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:149
msgid "B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr ""

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "2011-09-18"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:40 build/C/man2/msync.2:30 build/C/man3/shm_open.3:31
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:42
msgid "B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:46 build/C/man2/posix_fadvise.2:42 build/C/man3/posix_fallocate.3:37 build/C/man3/posix_memalign.3:44
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:50
msgid "B<madvise>(): _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:68
msgid ""
"The B<madvise>()  system call advises the kernel about how to handle paging "
"input/output in the address range beginning at address I<addr> and with size "
"I<length> bytes.  It allows an application to tell the kernel how it expects "
"to use some mapped or shared memory areas, so that the kernel can choose "
"appropriate read-ahead and caching techniques.  This call does not influence "
"the semantics of the application (except in the case of B<MADV_DONTNEED>), "
"but may influence its performance.  The kernel is free to ignore the advice."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:72
msgid "The advice is indicated in the I<advice> argument which can be"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:72
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:76
msgid "No special treatment.  This is the default."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:76
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:80
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:80
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:85
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:85
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:89
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:89
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:100
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)  Subsequent accesses of pages in this range "
"will succeed, but will result either in reloading of the memory contents "
"from the underlying mapped file (see B<mmap>(2))  or zero-fill-on-demand "
"pages for mappings without an underlying file."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:100
#, no-wrap
msgid "B<MADV_REMOVE> (Since Linux 2.6.16)"
msgstr ""

#.  2.6.18-rc5
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: build/C/man2/madvise.2:113
msgid ""
"Free up a given range of pages and its associated backing store.  Currently, "
"only shmfs/tmpfs supports this; other file systems return with the error "
"B<ENOSYS>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:113
#, no-wrap
msgid "B<MADV_DONTFORK> (Since Linux 2.6.16)"
msgstr ""

#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: build/C/man2/madvise.2:144
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing "
"the physical location of a page(s) if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page(s).)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:144
#, no-wrap
msgid "B<MADV_DOFORK> (Since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:150
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby "
"a mapping is inherited across B<fork>(2)."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:150
#, no-wrap
msgid "B<MADV_HWPOISON> (Since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:162
msgid ""
"Poison a page and handle it like a hardware memory corruption.  This "
"operation is only available for privileged (B<CAP_SYS_ADMIN>)  processes.  "
"This operation may result in the calling process receiving a B<SIGBUS> and "
"the page being unmapped.  This feature is intended for testing of memory "
"error-handling code; it is only available if the kernel was configured with "
"B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:162
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:180
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The "
"memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process.  This feature is intended for testing of memory "
"error-handling code; it is only available if the kernel was configured with "
"B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:180
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:205
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by "
"I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM only merges private anonymous pages (see B<mmap>(2)).  The KSM "
"feature is intended for applications that generate many instances of the "
"same data (e.g., virtualization systems such as KVM).  It can consume a lot "
"of processing power; use with care.  See the kernel source file "
"I<Documentation/vm/ksm.txt> for more details.  The B<MADV_MERGEABLE> and "
"B<MADV_UNMERGEABLE> operations are only available if the kernel was "
"configured with B<CONFIG_KSM>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:214
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:214
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: build/C/man2/madvise.2:243
msgid ""
"Enables Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages only work with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2)).  This "
"feature is primarily aimed at applications that use large mappings of data "
"and access large regions of that memory at a time (e.g. virtualization "
"systems such as QEMU).  It can very easily waste memory (e.g. a 2MB mapping "
"that only ever accesses 1 byte will result in 2MB of wired memory instead of "
"one 4KB page).  See the kernel source file I<Documentation/vm/transhuge.txt> "
"for more details.  The B<MADV_HUGEPAGE> and B<MADV_NOHUGEPAGE> operations "
"are only available if the kernel was configured with "
"B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:250
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be collapsed into huge pages."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:257
msgid ""
"On success B<madvise>()  returns zero.  On error, it returns -1 and I<errno> "
"is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:258 build/C/man2/mlock.2:155 build/C/man2/mmap.2:411 build/C/man2/mremap.2:137
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:261
msgid "A kernel resource was temporarily unavailable."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:264
msgid "The map exists, but the area maps something that isn't a file."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:267
msgid "This error can occur for the following reasons:"
msgstr ""

#. type: IP
#: build/C/man2/madvise.2:268 build/C/man2/madvise.2:274 build/C/man2/madvise.2:277 build/C/man2/madvise.2:280 build/C/man2/madvise.2:283
#, no-wrap
msgid "*"
msgstr ""

#.  .I len
#.  is zero,
#. type: Plain text
#: build/C/man2/madvise.2:274
msgid "The value I<len> is negative."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:277
msgid "I<addr> is not page-aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:280
msgid "I<advice> is not a valid value"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:283
msgid ""
"The application is attempting to release locked or shared pages (with "
"B<MADV_DONTNEED>)."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:291
msgid ""
"B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE> was specified in I<advice>, but the "
"kernel was not configured with B<CONFIG_KSM>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:298
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:298 build/C/man2/madvise.2:303 build/C/man2/mlock.2:124 build/C/man2/mlock.2:132 build/C/man2/mlock.2:170 build/C/man2/mmap.2:454 build/C/man2/mprotect.2:94 build/C/man2/mprotect.2:97 build/C/man2/mremap.2:180 build/C/man2/msync.2:93 build/C/man3/posix_memalign.3:130 build/C/man2/shmctl.2:326 build/C/man2/shmget.2:211 build/C/man2/shmop.2:209 build/C/man2/subpage_prot.2:82 build/C/man2/sync_file_range.2:163
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:303
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:307
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""

#.  FIXME . Write a posix_fadvise(3) page.
#. type: Plain text
#: build/C/man2/madvise.2:319
msgid ""
"POSIX.1b.  POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, etc., with a behavior close to that described here.  "
"There is a similar B<posix_fadvise>(2)  for file access."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:328
msgid ""
"B<MADV_REMOVE>, B<MADV_DONTFORK>, B<MADV_DOFORK>, B<MADV_HWPOISON>, "
"B<MADV_MERGEABLE>, and B<MADV_UNMERGEABLE> are Linux-specific."
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:329 build/C/man2/mlock.2:268 build/C/man2/shmget.2:278
#, no-wrap
msgid "Linux Notes"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:337
msgid ""
"The current Linux implementation (2.4.0) views this system call more as a "
"command than as advice and hence may return an error when it cannot do what "
"it usually would do in response to this advice.  (See the ERRORS description "
"above.)  This is nonstandard behavior."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/madvise.2:353
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:360
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_hook.3:6
#, no-wrap
msgid "MALLOC_HOOK"
msgstr ""

#. type: TH
#: build/C/man3/malloc_hook.3:6
#, no-wrap
msgid "2010-10-13"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:11
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:14 build/C/man3/posix_memalign.3:36
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:16
#, no-wrap
msgid "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:19
#, no-wrap
msgid ""
"B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void "
"*>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:22
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:24
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:26
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:39
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), "
"B<realloc>(3), and B<free>(3)  by specifying appropriate hook functions.  "
"You can use these hooks to help you debug programs that use dynamic memory "
"allocation, for example."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:46
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called "
"once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:49
#, no-wrap
msgid "    void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:54
msgid "Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:70
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:76
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:78
msgid "These functions are GNU extensions."
msgstr ""

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: build/C/man3/malloc_hook.3:85
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  Programmers should instead preempt calls to the "
"relevant functions by defining and exporting functions such as \"malloc\" "
"and \"free\"."
msgstr ""

#. type: SH
#: build/C/man3/malloc_hook.3:85 build/C/man2/mmap.2:567 build/C/man2/mprotect.2:142
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:87
msgid "Here is a short example of how to use these variables."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:91
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:95
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:98
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:101
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:108
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:113
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:116
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:119
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:122
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:126
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%u) called from %p returns %p\\en\",\n"
"            (unsigned int) size, caller, result);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:129
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:132
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:138
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mlock.2:27
#, no-wrap
msgid "MLOCK"
msgstr ""

#. type: TH
#: build/C/man2/mlock.2:27
#, no-wrap
msgid "2011-09-14"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:30
msgid "mlock, munlock, mlockall, munlockall - lock and unlock memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:33 build/C/man2/mmap.2:46 build/C/man2/mmap2.2:35 build/C/man2/mprotect.2:38 build/C/man2/mremap.2:39
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:36
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:39
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:55
msgid ""
"B<mlock>()  and B<mlockall>()  respectively lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area.  B<munlock>()  and B<munlockall>()  perform the "
"converse operation, respectively unlocking part or all of the calling "
"process's virtual address space, so that pages in the specified virtual "
"address range may once more to be swapped out if required by the kernel "
"memory manager.  Memory locking and unlocking are performed in units of "
"whole pages."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:55
#, no-wrap
msgid "mlock() and munlock()"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:65
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:74
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:74
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:84
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and "
"memory-mapped files.  All mapped pages are guaranteed to be resident in RAM "
"when the call returns successfully; the pages are guaranteed to stay in RAM "
"until later unlocked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:89
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:89
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:93
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:93
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:100
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be for instance new pages required by a "
"growing heap and stack as well as new memory mapped files or shared memory "
"regions."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:113
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number "
"of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:117
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:123
msgid ""
"On success these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:132
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: build/C/man2/mlock.2:144
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: build/C/man2/mlock.2:150
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:155
msgid "For B<mlock>()  and B<munlock>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:158
msgid "Some or all of the specified address range could not be locked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:165
msgid ""
"The result of the addition I<start>+I<len> was less than I<start> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:170
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:174
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:177
msgid "For B<mlockall>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:180
msgid "Unknown I<flags> were specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:183
msgid "For B<munlockall>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:187
msgid "(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:189
msgid "POSIX.1-2001, SVr4."
msgstr ""

#. type: SH
#: build/C/man2/mlock.2:189 build/C/man2/mmap.2:487 build/C/man2/msync.2:105
#, no-wrap
msgid "AVAILABILITY"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:201
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mlock.2:214
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:232
msgid ""
"Memory locking has two main applications: real-time algorithms and "
"high-security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:245
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the "
"time-critical section, so that no page fault can be caused by function "
"calls.  This can be achieved by calling a function that allocates a "
"sufficiently large automatic variable (an array) and writes to the memory "
"occupied by this array in order to touch these stack pages.  This way, "
"enough pages will be mapped for the stack and can be locked into RAM.  The "
"dummy writes ensure that not even copy-on-write page faults can occur in the "
"critical section."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:251
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:255
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:268
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>()  or B<mlockall>()  will be unlocked by a single "
"call to B<munlock>()  for the corresponding range or by B<munlockall>().  "
"Pages which are mapped to several locations or by several processes stay "
"locked into RAM as long as they are locked at least at one location or by at "
"least one process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:279
msgid ""
"Under Linux, B<mlock>()  and B<munlock>()  automatically round I<addr> down "
"to the nearest page boundary.  However, POSIX.1-2001 allows an "
"implementation to require that I<addr> is page aligned, so portable "
"applications should ensure this."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:292
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/PID/status> file shows how "
"many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:292
#, no-wrap
msgid "Limits and permissions"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:299
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:305
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:313
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: build/C/man2/mlock.2:330
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:337
msgid ""
"B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), "
"B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr ""

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "2010-06-20"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int "
">I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:61
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping."
msgstr ""

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: build/C/man2/mmap.2:75
msgid ""
"If I<addr> is NULL, then the kernel chooses the address at which to create "
"the mapping; this is the most portable method of creating a new mapping.  If "
"I<addr> is not NULL, then the kernel takes it as a hint about where to place "
"the mapping; on Linux, the mapping will be created at a nearby page "
"boundary.  The address of the new mapping is returned as the result of the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:87
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:95
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:95 build/C/man2/mprotect.2:67
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:98
msgid "Pages may be executed."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:98 build/C/man2/mprotect.2:61
#, no-wrap
msgid "B<PROT_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:101
msgid "Pages may be read."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:101 build/C/man2/mprotect.2:64
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:104
msgid "Pages may be written."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:104 build/C/man2/mprotect.2:58
#, no-wrap
msgid "B<PROT_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:107
msgid "Pages may not be accessed."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:116
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:116
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:126
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"that map this file, and are carried through to the underlying file.  The "
"file may not actually be updated until B<msync>(2)  or B<munmap>()  is "
"called."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:126
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:135
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:137
msgid "Both of these flags are described in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:140
msgid "In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:140
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: build/C/man2/mmap.2:156
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is only supported on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2GB of memory, so "
"as to improve context-switch performance on some early 64-bit processors.  "
"Modern x86-64 processors no longer have this performance problem, so use of "
"this flag is not required on those systems.  The B<MAP_32BIT> flag is "
"ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:156
#, no-wrap
msgid "B<MAP_ANON>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:161
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:161
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:183
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> and I<offset> arguments are ignored; however, some "
"implementations require I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  "
"is specified, and portable applications should ensure this.  The use of "
"B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is only supported on "
"Linux since kernel 2.4."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:183
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr ""

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: build/C/man2/mmap.2:191
msgid ""
"This flag is ignored.  (Long ago, it signaled that attempts to write to the "
"underlying file should fail with B<ETXTBUSY>.  But this was a source of "
"denial-of-service attacks.)"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:191
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr ""

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: build/C/man2/mmap.2:199
msgid "This flag is ignored."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:199
#, no-wrap
msgid "B<MAP_FILE>"
msgstr ""

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: build/C/man2/mmap.2:205
msgid "Compatibility flag.  Ignored."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:205
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:223
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be a multiple of the page size.  If the memory region "
"specified by I<addr> and I<len> overlaps pages of any existing mapping(s), "
"then the overlapped part of the existing mapping(s) will be discarded.  If "
"the specified address cannot be used, B<mmap>()  will fail.  Because "
"requiring a fixed address for a mapping is less portable, the use of this "
"option is discouraged."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:223
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:228
msgid ""
"Used for stacks.  Indicates to the kernel virtual memory system that the "
"mapping should extend downward in memory."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:228
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:234
msgid ""
"Allocate the mapping using \"huge pages.\" See the kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:234
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr ""

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: build/C/man2/mmap.2:240
msgid ""
"Lock the pages of the mapped region into memory in the manner of "
"B<mlock>(2).  This flag is ignored in older kernels."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:240
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:255
msgid ""
"Only meaningful in conjunction with B<MAP_POPULATE>.  Don't perform "
"read-ahead: only create page tables entries for pages that are already "
"present in RAM.  Since Linux 2.6.23, this flag causes B<MAP_POPULATE> to do "
"nothing.  One day the combination of B<MAP_POPULATE> and B<MAP_NONBLOCK> may "
"be reimplemented."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:255
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:270
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5).  In kernels before 2.6, "
"this flag only had effect for private writable mappings."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:270
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:277
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  Later accesses to the mapping will not be "
"blocked by page faults.  B<MAP_POPULATE> is only supported for private "
"mappings since Linux 2.6.23."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:277
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: build/C/man2/mmap.2:290
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:290
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:300
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is only honored if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices "
"(i.e., devices where one has complete control of the contents of user "
"memory)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:308
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001.  "
"However, most systems also support B<MAP_ANONYMOUS> (or its synonym "
"B<MAP_ANON>)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:315
msgid ""
"Some systems document the additional flags B<MAP_AUTOGROW>, "
"B<MAP_AUTORESRV>, B<MAP_COPY>, and B<MAP_LOCAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:321
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:329
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:329
#, no-wrap
msgid "munmap()"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:339
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:349
msgid ""
"The address I<addr> must be a multiple of the page size.  All pages "
"containing a part of the indicated range are unmapped, and subsequent "
"references to these pages will generate B<SIGSEGV>.  It is not an error if "
"the indicated range does not contain any mapped pages."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:349
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:356
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:373
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:390
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set appropriately.  On success, B<munmap>()  returns 0, on failure -1, "
"and I<errno> is set (probably to B<EINVAL>)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:391 build/C/man2/mprotect.2:80 build/C/man3/shm_open.3:185 build/C/man3/shm_open.3:190 build/C/man2/shmctl.2:295 build/C/man2/shmget.2:186 build/C/man2/shmop.2:189
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:411
msgid ""
"A file descriptor refers to a non-regular file.  Or B<MAP_PRIVATE> was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:415
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:421
msgid "I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:429
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:434
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:442
msgid ""
"I<flags> contained neither B<MAP_PRIVATE> or B<MAP_SHARED>, or contained "
"both of these values."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:442 build/C/man3/shm_open.3:227 build/C/man2/shmget.2:202
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#. type: Plain text
#: build/C/man2/mmap.2:450 build/C/man2/shmget.2:206
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:454
msgid ""
"The underlying file system of the specified file does not support memory "
"mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:458
msgid ""
"No memory is available, or the process's maximum number of mappings would "
"have been exceeded."
msgstr ""

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: build/C/man2/mmap.2:467
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a file system that was mounted no-exec."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:467
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:473
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:475
msgid "Use of a mapped region can result in these signals:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:475
#, no-wrap
msgid "B<SIGSEGV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:478
msgid "Attempted write into a region mapped as read-only."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:478
#, no-wrap
msgid "B<SIGBUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:483
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: build/C/man2/mmap.2:487
msgid "SVr4, 4.4BSD, POSIX.1-2001."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mmap.2:501
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2)  and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: build/C/man2/mmap.2:512
msgid ""
"Since kernel 2.4, this system call has been superseded by B<mmap2>(2).  "
"Nowadays, the glibc B<mmap>()  wrapper function invokes B<mmap2>(2)  with a "
"suitably adjusted value for I<offset>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:525
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:540
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 "
"(NULL)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:545
msgid ""
"On Linux there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:552
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag only has effect if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:567
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:579
msgid ""
"The following program prints part of the file specified in its first "
"command-line argument to standard output.  The range of bytes to be printed "
"is specified via offset and length values in the second and third "
"command-line arguments.  The program creates a memory mapping of the "
"required pages of the file and then uses B<write>(2)  to output the desired "
"bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:587
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:590 build/C/man2/mprotect.2:172
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:600
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:605
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:609
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:612
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:616
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:621
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:627
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:631
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:636
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:641
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:645
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:648
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:662
msgid ""
"B<getpagesize>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), "
"B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), "
"B<shmat>(2), B<shm_open>(3), B<shm_overview>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:667 build/C/man2/msync.2:122
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391."
msgstr ""

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr ""

#. type: TH
#: build/C/man2/mmap2.2:29 build/C/man2/msync.2:25 build/C/man2/remap_file_pages.2:26
#, no-wrap
msgid "2008-04-22"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:50
msgid ""
"The B<mmap2>()  system call operates in exactly the same way as B<mmap>(2), "
"except that the final argument specifies the offset into the file in "
"4096-byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:57
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:61
msgid "Problem with getting the data from userspace."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:66
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset * 4096> "
"is not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:70
msgid "B<mmap2>()  can return any of the same errors as B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:73
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:75 build/C/man2/subpage_prot.2:93
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:81
msgid ""
"Nowadays, the glibc B<mmap>()  wrapper function invokes this system call "
"rather than the B<mmap>(2)  system call."
msgstr ""

#.  ia64 can have page sizes ranging from 4kB to 64kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: build/C/man2/mmap2.2:88
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:94
msgid "B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mprotect.2:32
#, no-wrap
msgid "MPROTECT"
msgstr ""

#. type: TH
#: build/C/man2/mprotect.2:32
#, no-wrap
msgid "2011-09-08"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:35
msgid "mprotect - set protection on a region of memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:40
#, no-wrap
msgid "B<int mprotect(const void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:48
msgid ""
"B<mprotect>()  changes protection for the calling process's memory page(s)  "
"containing any part of the address range in the interval [I<addr>,\\ "
"I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:53
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protection, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:58
msgid ""
"I<prot> is either B<PROT_NONE> or a bitwise-or of the other values in the "
"following list:"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:61
msgid "The memory cannot be accessed at all."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:64
msgid "The memory can be read."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:67
msgid "The memory can be modified."
msgstr ""

#.  FIXME
#.  Document PROT_GROWSUP and PROT_GROWSDOWN
#. type: Plain text
#: build/C/man2/mprotect.2:72
msgid "The memory can be executed."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:79
msgid ""
"On success, B<mprotect>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:89
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""

#.  Or: both PROT_GROWSUP and PROT_GROWSDOWN were specified in 'prot'.
#. type: Plain text
#: build/C/man2/mprotect.2:94
msgid "I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:97
msgid "Internal kernel structures could not be allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:107
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced "
"for these cases.)"
msgstr ""

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: build/C/man2/mprotect.2:116
msgid ""
"SVr4, POSIX.1-2001.  POSIX says that the behavior of B<mprotect>()  is "
"unspecified if it is applied to a region of memory that was not obtained via "
"B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:123
msgid ""
"On Linux it is always permissible to call B<mprotect>()  on any address in a "
"process's address space (except for the kernel vsyscall area).  In "
"particular it can be used to change existing code mappings to be writable."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:133
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> is "
"architecture- and kernel version-dependent.  On some hardware architectures "
"(e.g., i386), B<PROT_WRITE> implies B<PROT_READ>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:142
msgid ""
"POSIX.1-2001 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can only allow write access if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:148
msgid ""
"The program below allocates four pages of memory, makes the third of these "
"pages read-only, and then executes a loop that walks upward through the "
"allocated region modifying bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:151
msgid "An example of what we might see when running the program is the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:157
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""

#. type: SS
#: build/C/man2/mprotect.2:159
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:169
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:174
#, no-wrap
msgid "char *buffer;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:182
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:189
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:195
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:199
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:202
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:206
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:208
#, no-wrap
msgid "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:212
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:215
#, no-wrap
msgid ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:219
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:223
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mremap.2:31
#, no-wrap
msgid "MREMAP"
msgstr ""

#. type: TH
#: build/C/man2/mremap.2:31
#, no-wrap
msgid "2010-06-10"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:34
msgid "mremap - remap a virtual memory address"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:37
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:42
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void "
"*>I<new_address>B< */);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:48
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:62
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the "
"requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:74
msgid ""
"In Linux the memory is divided into pages.  A user process has (one or)  "
"several linear virtual memory segments.  Each virtual memory segment has one "
"or more mappings to real memory pages (in the page table).  Each virtual "
"memory segment has its own protection (access rights), which may cause a "
"segmentation violation if the memory is accessed incorrectly (e.g., writing "
"to a read-only segment).  Accessing virtual memory outside of the segments "
"will also cause a segmentation violation."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:82
msgid ""
"B<mremap>()  uses the Linux page table scheme.  B<mremap>()  changes the "
"mapping between virtual addresses and memory pages.  This can be used to "
"implement a very efficient B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:84
msgid "The I<flags> bit-mask argument may be 0, or include the following flag:"
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:84
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:96
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if "
"necessary.  If the mapping is relocated, then absolute pointers into the old "
"mapping location become invalid (offsets relative to the starting address of "
"the mapping should be employed)."
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:96
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:118
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped.  If B<MREMAP_FIXED> is "
"specified, then B<MREMAP_MAYMOVE> must also be specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:128
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory "
"locked by the process may change."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:136
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:143
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not "
"possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:152
msgid ""
"\"Segmentation fault.\" Some address in the range I<old_address> to "
"I<old_address>+I<old_size> is an invalid virtual memory address for this "
"process.  You can also get B<EFAULT> even if there exist mappings that cover "
"the whole address space requested, but those mappings are of different "
"types."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:180
msgid ""
"An invalid argument was given.  Possible causes are: I<old_address> was not "
"page aligned; a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> was "
"specified in I<flags>; I<new_size> was zero; I<new_size> or I<new_address> "
"was invalid; or the new address range specified by I<new_address> and "
"I<new_size> overlapped the old address range specified by I<old_address> and "
"I<old_size>; or B<MREMAP_FIXED> was specified without also specifying "
"B<MREMAP_MAYMOVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:186
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: build/C/man2/mremap.2:192
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:200
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:209
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:214
msgid ""
"Your favorite OS text book for more information on paged memory.  (I<Modern "
"Operating Systems> by Andrew S. Tannenbaum, I<Inside Linux> by Randolf "
"Bentson, I<The Design of the UNIX Operating System> by Maurice J. Bach.)"
msgstr ""

#. type: TH
#: build/C/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to disk.  Without use of this call "
"there is no guarantee that changes are written back before B<munmap>(2)  is "
"called.  To be more precise, the part of the file that corresponds to the "
"memory area starting at I<addr> and having length I<length> is updated."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:68
msgid ""
"The I<flags> argument may have the bits B<MS_ASYNC>, B<MS_SYNC>, and "
"B<MS_INVALIDATE> set, but not both B<MS_ASYNC> and B<MS_SYNC>.  B<MS_ASYNC> "
"specifies that an update be scheduled, but the call returns immediately.  "
"B<MS_SYNC> asks for an update and waits for it to complete.  "
"B<MS_INVALIDATE> asks to invalidate other mappings of the same file (so that "
"they can be updated with the fresh values just written)."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:74
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:80
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the "
"specified address range."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:93
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:96
msgid "The indicated memory (or part of it) was not mapped."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:98 build/C/man3/posix_fallocate.3:103 build/C/man3/shm_open.3:251 build/C/man7/shm_overview.7:103
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:105
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of "
"B<ENOMEM>.  In Linux 2.4.19 this was changed to the POSIX value B<ENOMEM>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/msync.2:118
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: TP
#: build/C/man2/msync.2:120 build/C/man7/shm_overview.7:46
#, no-wrap
msgid "B<mmap>(2)"
msgstr ""

#. type: TH
#: build/C/man3/mtrace.3:4
#, no-wrap
msgid "MTRACE"
msgstr ""

#. type: TH
#: build/C/man3/mtrace.3:4
#, no-wrap
msgid "2002-07-20"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:7
msgid "mtrace, muntrace - malloc debugging"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:9
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:11
msgid "B<void mtrace(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:13
msgid "B<void muntrace(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:24
msgid ""
"The function B<mtrace>()  installs handlers for B<malloc>(3), B<realloc>(3)  "
"and B<free>(3).  The function B<muntrace>()  disables these handlers."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:34
msgid ""
"The environment variable B<MALLOC_TRACE> defines a file where B<mtrace>()  "
"writes its output.  This file must be writable to the user or B<mtrace>()  "
"will do nothing.  If the file is not empty it will be truncated."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:36
msgid "These are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:41
msgid ""
"The output of B<mtrace>()  will be ASCII but not in a friendly format.  So "
"glibc comes with a perl-script called mtrace to make sense of it."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:44
msgid "B<malloc>(3), B<malloc_hook>(3)"
msgstr ""

#. type: TH
#: build/C/man2/posix_fadvise.2:27
#, no-wrap
msgid "POSIX_FADVISE"
msgstr ""

#. type: TH
#: build/C/man2/posix_fadvise.2:27 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "2010-10-09"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:30
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:33 build/C/man3/posix_fallocate.3:29
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:36
#, no-wrap
msgid ""
"B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int "
">I<advice>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:45
msgid "B<posix_fadvise>():"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:47 build/C/man3/posix_fallocate.3:42
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:55
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:62
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:64
msgid "Permissible values for I<advice> include:"
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:64
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:70
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:70
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:74
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:74
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:77
msgid "The specified data will be accessed in random order."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:77
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:80
msgid "The specified data will be accessed only once."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:80
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:83
msgid "The specified data will be accessed in the near future."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:83
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:86
msgid "The specified data will not be accessed in the near future."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:89
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:93
msgid "The I<fd> argument was not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:96
msgid "An invalid value was specified for I<advice>."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:103
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (Linux actually "
"returns B<EINVAL> in this case.)"
msgstr ""

#.  of fadvise64_64()
#. type: Plain text
#: build/C/man2/posix_fadvise.2:111
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:120
msgid ""
"POSIX.1-2001.  Note that the type of the I<len> argument was changed from "
"I<size_t> to I<off_t> in POSIX.1-2003 TC1."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:126
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:133
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:137
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:145
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:153
msgid ""
"Pages that have not yet been written out will be unaffected, so if the "
"application wishes to guarantee that pages will be released, it should call "
"B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""

#. type: SS
#: build/C/man2/posix_fadvise.2:153
#, no-wrap
msgid "arm_fadvise()"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:165
msgid ""
"The ARM architecture needs 64-bit arguments to be aligned in a suitable pair "
"of registers.  On this architecture, the call signature of "
"B<posix_fadvise>()  is flawed, since it forces a register to be wasted as "
"padding between the I<fd> and I<len> arguments.  Therefore, since Linux "
"2.6.14, ARM defines a different system call that orders the arguments "
"suitably:"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:170
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""

#.  No ARM support in glibc.
#. type: Plain text
#: build/C/man2/posix_fadvise.2:177
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<posix_fadvise>().  No library support is provided for this system call in "
"glibc."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:182
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""

#.  FIXME . Write a posix_fadvise(3) page.
#. type: Plain text
#: build/C/man2/posix_fadvise.2:188
msgid ""
"B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3), "
"B<posix_madvise>(3)"
msgstr ""

#. type: TH
#: build/C/man3/posix_fallocate.3:23
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr ""

#. type: TH
#: build/C/man3/posix_fallocate.3:23 build/C/man3/posix_memalign.3:26
#, no-wrap
msgid "2010-09-20"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:26
msgid "posix_fallocate - allocate file space"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:31
#, no-wrap
msgid "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:40
msgid "B<posix_fallocate>():"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:59
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:64
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:70
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:79
msgid "I<offset+len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:89
msgid "I<fd> does not refer to a regular file."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:98
msgid "I<fd> refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:101
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:126
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:130
msgid "B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr ""

#. type: TH
#: build/C/man3/posix_memalign.3:26
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:29
msgid "posix_memalign, memalign, valloc - Allocate aligned memory"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:32
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:34
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t "
">I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<void *valloc(size_t >I<size>B<);>\n"
"B<void *memalign(size_t >I<boundary>B<, size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:49
msgid ""
"B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:51
msgid "B<valloc>():"
msgstr ""

#. type: TP
#: build/C/man3/posix_memalign.3:54
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:61
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""

#. type: TP
#: build/C/man3/posix_memalign.3:63
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:67
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""

#.  glibc does this:
#. type: Plain text
#: build/C/man3/posix_memalign.3:89
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated "
"memory will be a multiple of I<alignment>, which must be a power of two and "
"a multiple of I<sizeof(void *)>.  If I<size> is 0, then B<posix_memalign>()  "
"returns either NULL, or a unique pointer value that can later be "
"successfully passed to B<free>(3)."
msgstr ""

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: build/C/man3/posix_memalign.3:100
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<boundary>, which must be a power of two."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:109
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:111
msgid "For all three routines, the memory is not zeroed."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:116
msgid ""
"B<memalign>()  and B<valloc>()  return the pointer to the allocated memory, "
"or NULL if the request fails."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:123
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  Note that I<errno> is not set."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:130
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void *)>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:133
msgid "There was insufficient memory to fulfill the allocation request."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:142
msgid ""
"The functions B<memalign>()  and B<valloc>()  have been available in all "
"Linux libc libraries.  The function B<posix_memalign>()  is available since "
"glibc 2.1.91."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:155
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in "
"POSIX.1-2001.  The function B<memalign>()  appears in SunOS 4.1.3 but not in "
"4.4BSD.  The function B<posix_memalign>()  comes from POSIX.1d."
msgstr ""

#. type: SS
#: build/C/man3/posix_memalign.3:155
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:159
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:163
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:179
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Libc4,5 and glibc declare it in I<E<lt>malloc.hE<gt>> and perhaps also in "
"I<E<lt>stdlib.hE<gt>> (namely, if B<_GNU_SOURCE> is defined, or "
"B<_BSD_SOURCE> is defined, or, for glibc, if B<_XOPEN_SOURCE_EXTENDED> is "
"defined, or, equivalently, B<_XOPEN_SOURCE> is defined to a value not less "
"than 500)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:188
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the "
"I<pathconf(path,_PC_REC_XFER_ALIGN)> call that tells what alignment is "
"needed.  Now one can use B<posix_memalign>()  to satisfy this requirement."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:197
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<boundary> argument "
"is correct."
msgstr ""

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: build/C/man3/posix_memalign.3:225
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can only pass to B<free>(3)  "
"a pointer gotten from B<malloc>(3), while, for example, B<memalign>()  would "
"call B<malloc>(3)  and then align the obtained value).  The glibc "
"implementation allows memory obtained from any of these three routines to be "
"reclaimed with B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:230
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these routines are only needed if you require larger alignment values."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:235
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr ""

#. type: TH
#: build/C/man2/readahead.2:28 build/C/man7/shm_overview.7:27
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:31
msgid "readahead - perform file readahead into page cache"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:37
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:65
msgid ""
"B<readahead>()  populates the page cache with data from a file so that "
"subsequent reads from that file will not block on disk I/O.  The I<fd> "
"argument is a file descriptor identifying the file which is to be read.  The "
"I<offset> argument specifies the starting point from which data is to be "
"read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  B<readahead>()  blocks until the specified data has been "
"read.  The current file offset of the open file referred to by I<fd> is left "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:71
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:76
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:82
msgid "I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:87
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:92
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:98
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""

#. type: TH
#: build/C/man2/remap_file_pages.2:26
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:29
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:33
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:36
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int "
">I<prot>B<,>\n"
"B<                     ssize_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:49
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using B<remap_file_pages>()  "
"over using repeated calls to B<mmap>(2)  is that the former approach does "
"not require the kernel to create additional VMA (Virtual Memory Area) data "
"structures."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:51
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr ""

#. type: TP
#: build/C/man2/remap_file_pages.2:51
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:59
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""

#. type: TP
#: build/C/man2/remap_file_pages.2:59
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:67
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:78
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:96
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: build/C/man2/remap_file_pages.2:110
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:114
msgid "The I<prot> argument must be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:122
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:129
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:137
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: build/C/man2/remap_file_pages.2:146
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:151
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:155
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:162
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""

#. type: TH
#: build/C/man3/shm_open.3:26
#, no-wrap
msgid "SHM_OPEN"
msgstr ""

#. type: TH
#: build/C/man3/shm_open.3:26
#, no-wrap
msgid "2009-02-25"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:29
msgid "shm_open, shm_unlink - Create/open or unlink POSIX shared memory objects"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:33
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:35
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:37
msgid "B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:39
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:41
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:53
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can "
"be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr ""

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: build/C/man3/shm_open.3:74
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name> "
"specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form "
"I</somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:81
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:81
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:87
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can only be B<mmap>(2)ed for read (B<PROT_READ>) access."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:87
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:90
msgid "Open the object for read-write access."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:90
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#.  In truth it is actually the file system IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: build/C/man3/shm_open.3:110
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:116
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:116
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:125
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the "
"object, and its creation if it does not exist, are performed atomically."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:125
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:128
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:131
msgid ""
"Definitions of these flag values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:142
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:151
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)  "
"(for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:169
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a "
"shared memory object name, and, once all processes have unmapped the object, "
"de-allocates and destroys the contents of the associated memory region.  "
"After a successful B<shm_unlink>(), attempts to B<shm_open>()  an object "
"with the same I<name> will fail (unless B<O_CREAT> was specified, in which "
"case a new, distinct object is created)."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:178
msgid ""
"On success, B<shm_open>()  returns a nonnegative file descriptor.  On "
"failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns 0 on success, "
"or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:185
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:190
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:200
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or "
"B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:200 build/C/man2/shmget.2:192
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:211
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:218
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:218
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:221
msgid "The process already has the maximum number of files open."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:221
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:227
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:231
msgid "The limit on the total number of files open on the system has been reached."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:231 build/C/man3/shm_open.3:240 build/C/man2/shmget.2:206
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:240
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:247
msgid "An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:249
msgid "These functions are provided in glibc 2.2 and later."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:255
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\"."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:264
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:269
msgid ""
"The POSIX shared memory object implementation on Linux 2.4 makes use of a "
"dedicated file system, which is normally mounted under I</dev/shm>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:280
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<mmap>(2), B<open>(2), B<umask>(2), B<shm_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man7/shm_overview.7:27
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:30
msgid "shm_overview - Overview of POSIX shared memory"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:33
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:35
msgid "The interfaces employed in the API are:"
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:35
#, no-wrap
msgid "B<shm_open>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:42
msgid ""
"Create and open a new object, or open an existing object.  This is analogous "
"to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:42
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:46
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:50
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:50
#, no-wrap
msgid "B<munmap>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:54
msgid ""
"Unmap the shared memory object from the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:54
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:57
msgid "Remove a shared memory object name."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:57
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:62
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:62
#, no-wrap
msgid "B<fstat>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:76
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:76
#, no-wrap
msgid "B<fchown>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:79
msgid "To change the ownership of a shared memory object."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:79
#, no-wrap
msgid "B<fchmod>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:82
msgid "To change the permissions of a shared memory object."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:82
#, no-wrap
msgid "Versions"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:84
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:84
#, no-wrap
msgid "Persistence"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:89
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:89
#, no-wrap
msgid "Linking"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:94
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:94
#, no-wrap
msgid "Accessing shared memory objects via the file system"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:101
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>)  virtual file "
"system, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual file system."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:106
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:114
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:127
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmctl.2:43
#, no-wrap
msgid "SHMCTL"
msgstr ""

#. type: TH
#: build/C/man2/shmctl.2:43
#, no-wrap
msgid "2008-08-07"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:46
msgid "shmctl - shared memory control"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:49 build/C/man2/shmget.2:42
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:51 build/C/man2/shmget.2:44
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:53
msgid "B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:60
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the "
"shared memory segment whose identifier is given in I<shmid>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:65
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:79
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Last change time */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:87
msgid ""
"The I<ipc_perm> structure is defined in I<E<lt>sys/ipc.hE<gt>> as follows "
"(the highlighted fields are settable using B<IPC_SET>):"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:100
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:106
msgid "Valid values for I<cmd> are:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:107
#, no-wrap
msgid "B<IPC_STAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:116
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:116
#, no-wrap
msgid "B<IPC_SET>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:134
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member.  The following fields can be "
"changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant 9 bits "
"of) I<shm_perm.mode>.  The effective UID of the calling process must match "
"the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the shared "
"memory segment, or the caller must be privileged."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:134
#, no-wrap
msgid "B<IPC_RMID>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:151
msgid ""
"Mark the segment to be destroyed.  The segment will only actually be "
"destroyed after the last process detaches it (i.e., when the I<shm_nattch> "
"member of the associated structure I<shmid_ds> is zero).  The caller must be "
"the owner or creator, or be privileged.  If a segment has been marked for "
"destruction, then the (nonstandard)  B<SHM_DEST> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:154
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:154
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:167
msgid ""
"Returns information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:181
#, no-wrap
msgid ""
"struct  shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:194
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:194
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:205
msgid ""
"Returns a I<shm_info> structure whose fields contain information about "
"system resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:222
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:224
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:235
msgid ""
"Returns a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:238
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:239
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:251
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:251
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:254
msgid "Unlock the segment, allowing it to be swapped out."
msgstr ""

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: build/C/man2/shmctl.2:272
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:290
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> operations to obtain information about all shared "
"memory segments on the system.)  A successful B<SHM_STAT> operation returns "
"the identifier of the shared memory segment whose index was given in "
"I<shmid>.  Other operations return 0 on success."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:294
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:303
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:314
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:314
#, no-wrap
msgid "B<EIDRM>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:317
msgid "I<shmid> points to a removed identifier."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:326
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> operation, the index value specified in I<shmid> referred "
"to an array slot that is currently unused."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:337
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the "
"to-be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:337
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:342
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:354
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:366
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""

#.  SVr4 documents an additional error condition EMFILE.
#. type: Plain text
#: build/C/man2/shmctl.2:371 build/C/man2/shmget.2:232 build/C/man2/shmop.2:229
msgid "SVr4, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:382
msgid ""
"The B<IPC_INFO>, B<SHM_STAT> and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a /proc file system interface."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:390
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:403
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:410
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<svipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmget.2:36
#, no-wrap
msgid "SHMGET"
msgstr ""

#. type: TH
#: build/C/man2/shmget.2:36
#, no-wrap
msgid "2006-05-02"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:39
msgid "shmget - allocates a shared memory segment"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:46
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:70
msgid ""
"B<shmget>()  returns the identifier of the shared memory segment associated "
"with the value of the argument I<key>.  A new shared memory segment, with "
"size equal to the value of I<size> rounded up to a multiple of B<PAGE_SIZE>, "
"is created if I<key> has the value B<IPC_PRIVATE> or I<key> isn't "
"B<IPC_PRIVATE>, no shared memory segment corresponding to I<key> exists, and "
"B<IPC_CREAT> is specified in I<shmflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:89
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:93
msgid "The value I<shmflg> is composed of:"
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:93
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:100
msgid ""
"to create a new segment.  If this flag is not used, then B<shmget>()  will "
"find the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:100
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:103
msgid "used with B<IPC_CREAT> to ensure failure if the segment already exists."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:103
#, no-wrap
msgid "I<mode_flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:113
msgid ""
"(least significant 9 bits)  specifying the permissions granted to the owner, "
"group, and world.  These bits have the same format, and the same meaning, as "
"the I<mode> argument of B<open>(2).  Presently, the execute permissions are "
"not used by the system."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:113
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:119
msgid ""
"Allocate the segment using \"huge pages.\" See the kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:119
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr ""

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: build/C/man2/shmget.2:138
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:146
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:151
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:156
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:161
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:165
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:172
msgid "I<shm_lpid>, I<shm_nattch>, I<shm_atime> and I<shm_dtime> are set to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:175
msgid "I<shm_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:178
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:182
msgid "A valid segment identifier, I<shmid>, is returned on success, -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:186
msgid "On failure, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:192
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:196
msgid "B<IPC_CREAT | IPC_EXCL> was specified and the segment exists."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:202
msgid ""
"A new segment was to be created and I<size> E<lt> B<SHMMIN> or I<size> E<gt> "
"B<SHMMAX>, or no new segment was to be created, a segment with given key "
"existed, but I<size> is greater than the size of that segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:211
msgid "No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:214
msgid "No memory could be allocated for segment overhead."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:222
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the "
"system-wide limit on shared memory (B<SHMALL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:229
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:235
msgid "B<SHM_HUGETLB> is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:245
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment (on "
"success)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:249
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:249
#, no-wrap
msgid "B<SHMALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:254
msgid ""
"System wide maximum of shared memory pages (on Linux, this limit can be read "
"and modified via I</proc/sys/kernel/shmall>)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:254
#, no-wrap
msgid "B<SHMMAX>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:259
msgid ""
"Maximum size in bytes for a shared memory segment: policy dependent (on "
"Linux, this limit can be read and modified via I</proc/sys/kernel/shmmax>)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:259
#, no-wrap
msgid "B<SHMMIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:265
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:265
#, no-wrap
msgid "B<SHMMNI>"
msgstr ""

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: build/C/man2/shmget.2:274
msgid ""
"System wide maximum number of shared memory segments: implementation "
"dependent (currently 4096, was 128 before Linux 2.3.99; on Linux, this limit "
"can be read and modified via I</proc/sys/kernel/shmmni>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:278
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:284
msgid ""
"Until version 2.3.30 Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:290
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:298
msgid ""
"B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmop.2:39
#, no-wrap
msgid "SHMOP"
msgstr ""

#. type: TH
#: build/C/man2/shmop.2:39
#, no-wrap
msgid "2008-06-03"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:42
msgid "shmat, shmdt - shared memory operations"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:46
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:48
#, no-wrap
msgid ""
"B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int "
">I<shmflg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:50
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:59
msgid ""
"B<shmat>()  attaches the shared memory segment identified by I<shmid> to the "
"address space of the calling process.  The attaching address is specified by "
"I<shmaddr> with one of the following criteria:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:65
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) address at "
"which to attach the segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:80
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>.  Otherwise I<shmaddr> must be a page-aligned address "
"at which the attach occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:90
msgid ""
"If B<SHM_RDONLY> is specified in I<shmflg>, the segment is attached for "
"reading and the process must have read permission for the segment.  "
"Otherwise the segment is attached for read and write and the process must "
"have read and write permission for the segment.  There is no notion of a "
"write-only shared memory segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:105
msgid ""
"The (Linux-specific)  B<SHM_REMAP> flag may be specified in I<shmflg> to "
"indicate that the mapping of the segment should replace any existing mapping "
"in the range starting at I<shmaddr> and continuing for the size of the "
"segment.  (Normally an B<EINVAL> error would result if a mapping already "
"exists in this address range.)  In this case, I<shmaddr> must not be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:112
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:120
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:123
msgid "I<shm_atime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:126 build/C/man2/shmop.2:152
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:129
msgid "I<shm_nattch> is incremented by one."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:140
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:146
msgid ""
"On a successful B<shmdt>()  call the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:149
msgid "I<shm_dtime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:157
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:161
msgid "After a B<fork>(2)  the child inherits the attached shared memory segments."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:165
msgid ""
"After an B<execve>(2)  all attached shared memory segments are detached from "
"the process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:169
msgid ""
"Upon B<_exit>(2)  all attached shared memory segments are detached from the "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:177
msgid ""
"On success B<shmat>()  returns the address of the attached shared memory "
"segment; on error I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:183
msgid ""
"On success B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:189
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:195
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:209
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:212
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:218
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr ""

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: build/C/man2/shmop.2:226
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:245
msgid ""
"In SVID 3 (or perhaps earlier)  the type of the I<shmaddr> argument was "
"changed from I<char *> into I<const void *>, and the returned type of "
"B<shmat>()  from I<char *> into I<void *>.  (Linux libc4 and libc5 have the "
"I<char *> prototypes; glibc2 has I<void *>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:257
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:262
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1-2001 does not specify this "
"behavior and many other implementations do not support it."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:265
msgid "The following system parameter affects B<shmat>():"
msgstr ""

#.  FIXME A good explanation of the rationale for the existence
#.  of SHMLBA would be useful here
#. type: TP
#: build/C/man2/shmop.2:265
#, no-wrap
msgid "B<SHMLBA>"
msgstr ""

#.  FIXME That last sentence isn't true for all Linux
#.  architectures (i.e., SHMLBA != PAGE_SIZE for some architectures)
#.  -- MTK, Nov 04
#. type: Plain text
#: build/C/man2/shmop.2:278
msgid ""
"Segment low boundary address multiple.  Must be page aligned.  For the "
"current implementation the B<SHMLBA> value is B<PAGE_SIZE>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:282
msgid ""
"The implementation places no intrinsic limit on the per-process maximum "
"number of shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:290
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/subpage_prot.2:28
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr ""

#. type: TH
#: build/C/man2/subpage_prot.2:28
#, no-wrap
msgid "2010-10-30"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:31
msgid "subpage_prot - define a subpage protection for an address range"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:35
#, no-wrap
msgid ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:42
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4kB subpages on systems "
"configured with a page size of 64kB."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:49
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:61
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4kB subpage; thus each 32-bit word specifies the protections "
"of 16 4kB subpages inside a 64kB page (so, the number of 32-bit words "
"pointed to by I<map> should equate to the number of 64-kB pages specified by "
"I<len>).  Each 2-bit field in the protection map is either 0 to allow any "
"access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:66
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:72
msgid "The buffer referred to by I<map> is not accessible."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:82
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:85 build/C/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:91
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:98
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""

#. type: SS
#: build/C/man2/subpage_prot.2:98
#, no-wrap
msgid "Rationale"
msgstr ""

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4k hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: build/C/man2/subpage_prot.2:120
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the "
"memory-management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is slow.)  "
"The idea is that the emulator supplies an array of protection masks to apply "
"to a specified range of virtual addresses.  These masks are applied at the "
"level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:123
msgid "B<mprotect>(2), B<syscall>(2);"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:126
msgid "the kernel source file I<Documentation/vm/hugetlbpage.txt>."
msgstr ""

#. type: TH
#: build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t "
">I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:70 build/C/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:80
msgid "Wait upon write-out of all pages in the range after performing any write."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On file systems using copy-on-write semantics "
"(e.g., I<btrfs>)  an overwrite of existing allocated blocks is impossible.  "
"When writing into preallocated space, many file systems also require calls "
"into the block allocator, which this system call does not sync out to disk.  "
"This system call does not flush disk write caches and thus does not provide "
"any data integrity on systems with volatile disk write caches."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:134
#, no-wrap
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | "
"SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:160
msgid "I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:163
msgid "I/O error."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr ""

#.  FIXME . (bug?) Actually, how can 'fd' refer to a symbolic link (S_ISLNK)?
#.  (In userspace at least) it isn't possible to obtain a file descriptor
#.  for a symbolic link.
#. type: Plain text
#: build/C/man2/sync_file_range.2:177
msgid ""
"I<fd> refers to something other than a regular file, a block device, a "
"directory, or a symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:180
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:183
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: build/C/man2/sync_file_range.2:196
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  is flawed, since it forces a register to be wasted "
"as padding between the I<fd> and I<offset> arguments.  Therefore, these "
"architectures define a different system call that orders the arguments "
"suitably:"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:201
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:206
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:217
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:222
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr ""

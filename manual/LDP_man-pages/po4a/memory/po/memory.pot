# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-08-15 19:32+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "ALLOC_HUGEPAGES"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25
#, no-wrap
msgid "2007-05-31"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:11 build/C/man2/madvise.2:35 build/C/man3/mallinfo.3:26 build/C/man3/malloc_stats.3:26 build/C/man3/malloc_trim.3:26 build/C/man3/mallopt.3:26 build/C/man2/mlock.2:26 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:38 build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man2/posix_fadvise.2:28 build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:28 build/C/man3/shm_open.3:26 build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:45 build/C/man2/shmget.2:38 build/C/man2/shmop.2:41 build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man2/alloc_hugepages.2:25 build/C/man3/alloca.3:43 build/C/man2/cacheflush.2:25 build/C/man2/fallocate.2:11 build/C/man2/madvise.2:35 build/C/man3/mallinfo.3:26 build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25 build/C/man3/malloc_stats.3:26 build/C/man3/malloc_trim.3:26 build/C/man3/malloc_usable_size.3:25 build/C/man3/mallopt.3:26 build/C/man3/mcheck.3:25 build/C/man2/mlock.2:26 build/C/man2/mmap.2:40 build/C/man2/mmap2.2:29 build/C/man2/mprotect.2:38 build/C/man2/mremap.2:30 build/C/man2/msync.2:25 build/C/man3/mtrace.3:25 build/C/man2/posix_fadvise.2:28 build/C/man3/posix_fallocate.3:25 build/C/man3/posix_memalign.3:29 build/C/man2/readahead.2:28 build/C/man2/remap_file_pages.2:28 build/C/man3/shm_open.3:26 build/C/man7/shm_overview.7:27 build/C/man2/shmctl.2:45 build/C/man2/shmget.2:38 build/C/man2/shmop.2:41 build/C/man2/subpage_prot.2:30 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:26 build/C/man3/alloca.3:44 build/C/man2/cacheflush.2:26 build/C/man2/fallocate.2:12 build/C/man2/madvise.2:36 build/C/man3/mallinfo.3:27 build/C/man3/malloc_get_state.3:26 build/C/man3/malloc_hook.3:11 build/C/man3/malloc_info.3:26 build/C/man3/malloc_stats.3:27 build/C/man3/malloc_trim.3:27 build/C/man3/malloc_usable_size.3:26 build/C/man3/mallopt.3:27 build/C/man3/mcheck.3:26 build/C/man2/mlock.2:27 build/C/man2/mmap.2:41 build/C/man2/mmap2.2:30 build/C/man2/mprotect.2:39 build/C/man2/mremap.2:31 build/C/man2/msync.2:26 build/C/man3/mtrace.3:26 build/C/man2/posix_fadvise.2:29 build/C/man3/posix_fallocate.3:26 build/C/man3/posix_memalign.3:30 build/C/man2/readahead.2:29 build/C/man2/remap_file_pages.2:29 build/C/man3/shm_open.3:27 build/C/man7/shm_overview.7:28 build/C/man2/shmctl.2:46 build/C/man2/shmget.2:39 build/C/man2/shmop.2:42 build/C/man2/subpage_prot.2:31 build/C/man2/sync_file_range.2:31
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:28
msgid "alloc_hugepages, free_hugepages - allocate or free huge pages"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:28 build/C/man3/alloca.3:46 build/C/man2/cacheflush.2:28 build/C/man2/fallocate.2:14 build/C/man2/madvise.2:38 build/C/man3/mallinfo.3:29 build/C/man3/malloc_get_state.3:28 build/C/man3/malloc_hook.3:15 build/C/man3/malloc_info.3:28 build/C/man3/malloc_stats.3:29 build/C/man3/malloc_trim.3:29 build/C/man3/malloc_usable_size.3:28 build/C/man3/mallopt.3:29 build/C/man3/mcheck.3:28 build/C/man2/mlock.2:29 build/C/man2/mmap.2:43 build/C/man2/mmap2.2:32 build/C/man2/mprotect.2:41 build/C/man2/mremap.2:33 build/C/man2/msync.2:28 build/C/man3/mtrace.3:28 build/C/man2/posix_fadvise.2:31 build/C/man3/posix_fallocate.3:28 build/C/man3/posix_memalign.3:32 build/C/man2/readahead.2:31 build/C/man2/remap_file_pages.2:31 build/C/man3/shm_open.3:29 build/C/man2/shmctl.2:48 build/C/man2/shmget.2:41 build/C/man2/shmop.2:44 build/C/man2/subpage_prot.2:33 build/C/man2/sync_file_range.2:33
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#.  asmlinkage unsigned long sys_alloc_hugepages(int key, unsigned long addr,
#.  unsigned long len, int prot, int flag);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:34
#, no-wrap
msgid ""
"B<void *alloc_hugepages(int >I<key>B<, void *>I<addr>B<, size_t "
">I<len>B<,>\n"
"B<                      int >I<prot>B<, int >I<flag>B<);>\n"
msgstr ""

#.  asmlinkage int sys_free_hugepages(unsigned long addr);
#. type: Plain text
#: build/C/man2/alloc_hugepages.2:37
#, no-wrap
msgid "B<int free_hugepages(void *>I<addr>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:38 build/C/man3/alloca.3:50 build/C/man2/cacheflush.2:34 build/C/man2/fallocate.2:22 build/C/man2/madvise.2:50 build/C/man3/mallinfo.3:33 build/C/man3/malloc_get_state.3:36 build/C/man3/malloc_hook.3:33 build/C/man3/malloc_info.3:34 build/C/man3/malloc_stats.3:33 build/C/man3/malloc_trim.3:33 build/C/man3/malloc_usable_size.3:32 build/C/man3/mallopt.3:33 build/C/man3/mcheck.3:40 build/C/man2/mlock.2:39 build/C/man2/mmap.2:54 build/C/man2/mmap2.2:39 build/C/man2/mprotect.2:47 build/C/man2/mremap.2:42 build/C/man2/msync.2:32 build/C/man3/mtrace.3:34 build/C/man2/posix_fadvise.2:50 build/C/man3/posix_fallocate.3:46 build/C/man3/posix_memalign.3:84 build/C/man2/readahead.2:38 build/C/man2/remap_file_pages.2:39 build/C/man3/shm_open.3:41 build/C/man7/shm_overview.7:30 build/C/man2/shmctl.2:56 build/C/man2/shmget.2:49 build/C/man2/shmop.2:53 build/C/man2/subpage_prot.2:41 build/C/man2/sync_file_range.2:41
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:49
msgid ""
"The system calls B<alloc_hugepages>()  and B<free_hugepages>()  were "
"introduced in Linux 2.5.36 and removed again in 2.5.54.  They existed only "
"on i386 and ia64 (when built with B<CONFIG_HUGETLB_PAGE>).  In Linux 2.4.20 "
"the syscall numbers exist, but the calls fail with the error B<ENOSYS>."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:57
msgid ""
"On i386 the memory management hardware knows about ordinary pages (4 KiB)  "
"and huge pages (2 or 4 MiB).  Similarly ia64 knows about huge pages of "
"several sizes.  These system calls serve to map huge pages into the "
"process's memory or to free them again.  Huge pages are locked into memory, "
"and are not swapped."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:66
msgid ""
"The I<key> argument is an identifier.  When zero the pages are private, and "
"not inherited by children.  When positive the pages are shared with other "
"applications using the same I<key>, and inherited by child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:81
msgid ""
"The I<addr> argument of B<free_hugepages>()  tells which page is being "
"freed: it was the return value of a call to B<alloc_hugepages>().  (The "
"memory is first actually freed when all users have released it.)  The "
"I<addr> argument of B<alloc_hugepages>()  is a hint, that the kernel may or "
"may not follow.  Addresses must be properly aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:86
msgid ""
"The I<len> argument is the length of the required segment.  It must be a "
"multiple of the huge page size."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:94
msgid ""
"The I<prot> argument specifies the memory protection of the segment.  It is "
"one of B<PROT_READ>, B<PROT_WRITE>, B<PROT_EXEC>."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:109
msgid ""
"The I<flag> argument is ignored, unless I<key> is positive.  In that case, "
"if I<flag> is B<IPC_CREAT>, then a new huge page segment is created when "
"none with the given key existed.  If this flag is not set, then B<ENOENT> is "
"returned when no segment with the given key exists."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:109 build/C/man3/alloca.3:60 build/C/man2/cacheflush.2:53 build/C/man2/fallocate.2:112 build/C/man2/madvise.2:268 build/C/man3/malloc_get_state.3:61 build/C/man3/malloc_info.3:48 build/C/man3/malloc_trim.3:51 build/C/man3/malloc_usable_size.3:40 build/C/man3/mallopt.3:379 build/C/man3/mcheck.3:129 build/C/man2/mlock.2:116 build/C/man2/mmap.2:375 build/C/man2/mmap2.2:54 build/C/man2/mprotect.2:78 build/C/man2/mremap.2:127 build/C/man2/msync.2:68 build/C/man2/posix_fadvise.2:87 build/C/man3/posix_fallocate.3:66 build/C/man3/posix_memalign.3:141 build/C/man2/readahead.2:65 build/C/man2/remap_file_pages.2:124 build/C/man3/shm_open.3:171 build/C/man2/shmctl.2:279 build/C/man2/shmget.2:180 build/C/man2/shmop.2:171 build/C/man2/subpage_prot.2:66 build/C/man2/sync_file_range.2:141
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:118
msgid ""
"On success, B<alloc_hugepages>()  returns the allocated virtual address, and "
"B<free_hugepages>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:118 build/C/man2/cacheflush.2:59 build/C/man2/fallocate.2:119 build/C/man2/madvise.2:275 build/C/man3/malloc_info.3:55 build/C/man3/malloc_trim.3:56 build/C/man3/mallopt.3:384 build/C/man2/mlock.2:122 build/C/man2/mmap.2:392 build/C/man2/mmap2.2:61 build/C/man2/mprotect.2:85 build/C/man2/mremap.2:135 build/C/man2/msync.2:73 build/C/man2/posix_fadvise.2:90 build/C/man3/posix_fallocate.3:72 build/C/man3/posix_memalign.3:155 build/C/man2/readahead.2:71 build/C/man2/remap_file_pages.2:131 build/C/man3/shm_open.3:180 build/C/man2/shmctl.2:301 build/C/man2/shmget.2:185 build/C/man2/shmop.2:185 build/C/man2/subpage_prot.2:71 build/C/man2/sync_file_range.2:147
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/alloc_hugepages.2:119 build/C/man2/fallocate.2:158
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:122
msgid "The system call is not supported on this kernel."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:122
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:126
msgid ""
"I</proc/sys/vm/nr_hugepages> Number of configured hugetlb pages.  This can "
"be read and written."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:130
msgid ""
"I</proc/meminfo> Gives info on the number of configured hugetlb pages and on "
"their size in the three variables HugePages_Total, HugePages_Free, "
"Hugepagesize."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:130 build/C/man3/alloca.3:65 build/C/man2/cacheflush.2:75 build/C/man2/fallocate.2:199 build/C/man2/madvise.2:325 build/C/man3/mallinfo.3:110 build/C/man3/malloc_get_state.3:86 build/C/man3/malloc_hook.3:80 build/C/man3/malloc_info.3:63 build/C/man3/malloc_stats.3:55 build/C/man3/malloc_trim.3:60 build/C/man3/malloc_usable_size.3:48 build/C/man3/mallopt.3:392 build/C/man3/mcheck.3:145 build/C/man2/mlock.2:186 build/C/man2/mmap.2:497 build/C/man2/mmap2.2:77 build/C/man2/mprotect.2:113 build/C/man2/mremap.2:185 build/C/man2/msync.2:96 build/C/man3/mtrace.3:78 build/C/man2/posix_fadvise.2:112 build/C/man3/posix_fallocate.3:103 build/C/man3/posix_memalign.3:180 build/C/man2/readahead.2:87 build/C/man2/remap_file_pages.2:153 build/C/man3/shm_open.3:251 build/C/man7/shm_overview.7:101 build/C/man2/shmctl.2:373 build/C/man2/shmget.2:232 build/C/man2/shmop.2:231 build/C/man2/subpage_prot.2:96 build/C/man2/sync_file_range.2:180
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:133
msgid ""
"These calls are specific to Linux on Intel processors, and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:133 build/C/man3/alloca.3:73 build/C/man2/madvise.2:346 build/C/man3/malloc_get_state.3:88 build/C/man3/malloc_hook.3:82 build/C/man3/malloc_info.3:65 build/C/man3/malloc_stats.3:57 build/C/man3/malloc_trim.3:62 build/C/man3/malloc_usable_size.3:50 build/C/man3/mcheck.3:147 build/C/man2/mlock.2:213 build/C/man2/mmap.2:515 build/C/man2/mmap2.2:79 build/C/man2/mprotect.2:122 build/C/man2/mremap.2:191 build/C/man3/mtrace.3:80 build/C/man2/posix_fadvise.2:121 build/C/man3/posix_memalign.3:219 build/C/man2/readahead.2:92 build/C/man3/shm_open.3:257 build/C/man7/shm_overview.7:103 build/C/man2/shmctl.2:378 build/C/man2/shmget.2:238 build/C/man2/shmop.2:250 build/C/man2/subpage_prot.2:98 build/C/man2/sync_file_range.2:183
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:141
msgid ""
"These system calls are gone; they existed only in Linux 2.5.36 through to "
"2.5.54.  Now the hugetlbfs file system can be used instead.  Memory backed "
"by huge pages (if the CPU supports them) is obtained by using B<mmap>(2)  to "
"map files in this virtual file system."
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:145
msgid ""
"The maximal number of huge pages can be specified using the B<hugepages=> "
"boot parameter."
msgstr ""

#. type: SH
#: build/C/man2/alloc_hugepages.2:150 build/C/man3/alloca.3:157 build/C/man2/cacheflush.2:89 build/C/man2/fallocate.2:207 build/C/man2/madvise.2:379 build/C/man3/mallinfo.3:279 build/C/man3/malloc_get_state.3:114 build/C/man3/malloc_hook.3:142 build/C/man3/malloc_info.3:262 build/C/man3/malloc_stats.3:67 build/C/man3/malloc_trim.3:82 build/C/man3/malloc_usable_size.3:64 build/C/man3/mallopt.3:580 build/C/man3/mcheck.3:208 build/C/man2/mlock.2:336 build/C/man2/mmap.2:737 build/C/man2/mmap2.2:98 build/C/man2/mprotect.2:229 build/C/man2/mremap.2:214 build/C/man2/msync.2:124 build/C/man3/mtrace.3:172 build/C/man2/posix_fadvise.2:197 build/C/man3/posix_fallocate.3:133 build/C/man3/posix_memalign.3:275 build/C/man2/readahead.2:103 build/C/man2/remap_file_pages.2:164 build/C/man3/shm_open.3:282 build/C/man7/shm_overview.7:127 build/C/man2/shmctl.2:430 build/C/man2/shmget.2:314 build/C/man2/shmop.2:295 build/C/man2/subpage_prot.2:134 build/C/man2/sync_file_range.2:226
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man2/alloc_hugepages.2:157 build/C/man3/alloca.3:164 build/C/man2/cacheflush.2:96 build/C/man2/fallocate.2:214 build/C/man2/madvise.2:386 build/C/man3/mallinfo.3:286 build/C/man3/malloc_get_state.3:121 build/C/man3/malloc_hook.3:149 build/C/man3/malloc_info.3:269 build/C/man3/malloc_stats.3:74 build/C/man3/malloc_trim.3:89 build/C/man3/malloc_usable_size.3:71 build/C/man3/mallopt.3:587 build/C/man3/mcheck.3:215 build/C/man2/mlock.2:343 build/C/man2/mmap.2:744 build/C/man2/mmap2.2:105 build/C/man2/mprotect.2:236 build/C/man2/mremap.2:221 build/C/man2/msync.2:131 build/C/man3/mtrace.3:179 build/C/man2/posix_fadvise.2:204 build/C/man3/posix_fallocate.3:140 build/C/man3/posix_memalign.3:282 build/C/man2/readahead.2:110 build/C/man2/remap_file_pages.2:171 build/C/man3/shm_open.3:289 build/C/man7/shm_overview.7:134 build/C/man2/shmctl.2:437 build/C/man2/shmget.2:321 build/C/man2/shmop.2:302 build/C/man2/subpage_prot.2:141 build/C/man2/sync_file_range.2:233
msgid ""
"This page is part of release 3.53 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:43
#, no-wrap
msgid "ALLOCA"
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:43
#, no-wrap
msgid "2013-05-12"
msgstr ""

#. type: TH
#: build/C/man3/alloca.3:43 build/C/man3/malloc_get_state.3:25 build/C/man3/malloc_hook.3:10 build/C/man3/malloc_info.3:25 build/C/man3/malloc_usable_size.3:25 build/C/man3/mcheck.3:25 build/C/man3/mtrace.3:25 build/C/man3/posix_fallocate.3:25 build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:46
msgid "alloca - allocate memory that is automatically freed"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:48
msgid "B<#include E<lt>alloca.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:50
msgid "B<void *alloca(size_t >I<size>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:60
msgid ""
"The B<alloca>()  function allocates I<size> bytes of space in the stack "
"frame of the caller.  This temporary space is automatically freed when the "
"function that called B<alloca>()  returns to its caller."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:65
msgid ""
"The B<alloca>()  function returns a pointer to the beginning of the "
"allocated space.  If the allocation causes stack overflow, program behavior "
"is undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:67
msgid "This function is not in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:73
msgid ""
"There is evidence that the B<alloca>()  function appeared in 32V, PWB, "
"PWB.2, 3BSD, and 4BSD.  There is a man page for it in 4.3BSD.  Linux uses "
"the GNU version."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:88
msgid ""
"The B<alloca>()  function is machine- and compiler-dependent.  For certain "
"applications, its use can improve efficiency compared to the use of "
"B<malloc>(3)  plus B<free>(3).  In certain cases, it can also simplify "
"memory deallocation in applications that use B<longjmp>(3)  or "
"B<siglongjmp>(3).  Otherwise, its use is discouraged."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:97
msgid ""
"Because the space allocated by B<alloca>()  is allocated within the stack "
"frame, that space is automatically freed if the function return is jumped "
"over by a call to B<longjmp>(3)  or B<siglongjmp>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:102
msgid "Do not attempt to B<free>(3)  space allocated by B<alloca>()!"
msgstr ""

#. type: SS
#: build/C/man3/alloca.3:102
#, no-wrap
msgid "Notes on the GNU version"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:124
msgid ""
"Normally, B<gcc>(1)  translates calls to B<alloca>()  with inlined code.  "
"This is not done when either the I<-ansi>, I<-std=c89>, I<-std=c99>, or the "
"I<-std=c11> option is given B<and> the header I<E<lt>alloca.hE<gt>> is not "
"included.  Otherwise (without an -ansi or -std=c* option) the glibc version "
"of I<E<lt>stdlib.hE<gt>> includes I<E<lt>alloca.hE<gt>> and that contains "
"the lines:"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:129
#, no-wrap
msgid ""
"    #ifdef  __GNUC__\n"
"    #define alloca(size)   __builtin_alloca (size)\n"
"    #endif\n"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:132
msgid "with messy consequences if one has a private version of this function."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:136
msgid ""
"The fact that the code is inlined means that it is impossible to take the "
"address of this function, or to change its behavior by linking with a "
"different library."
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:140
msgid ""
"The inlined code often consists of a single instruction adjusting the stack "
"pointer, and does not check for stack overflow.  Thus, there is no NULL "
"error return."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:140 build/C/man2/cacheflush.2:82 build/C/man3/mallinfo.3:114 build/C/man3/mallopt.3:406 build/C/man2/mlock.2:304 build/C/man2/mmap.2:587 build/C/man3/mtrace.3:102 build/C/man2/posix_fadvise.2:186 build/C/man2/shmget.2:300
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:145
msgid ""
"There is no error indication if the stack frame cannot be extended.  "
"(However, after a failed allocation, the program is likely to receive a "
"B<SIGSEGV> signal if it attempts to access the unallocated space.)"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:153
msgid ""
"On many systems B<alloca>()  cannot be used inside the list of arguments of "
"a function call, because the stack space reserved by B<alloca>()  would "
"appear on the stack in the middle of the space for the function arguments."
msgstr ""

#. type: SH
#: build/C/man3/alloca.3:153 build/C/man2/fallocate.2:202 build/C/man2/madvise.2:371 build/C/man3/mallinfo.3:270 build/C/man3/malloc_get_state.3:111 build/C/man3/malloc_hook.3:137 build/C/man3/malloc_info.3:256 build/C/man3/malloc_stats.3:61 build/C/man3/malloc_trim.3:78 build/C/man3/malloc_usable_size.3:62 build/C/man3/mallopt.3:566 build/C/man3/mcheck.3:204 build/C/man2/mlock.2:329 build/C/man2/mmap.2:712 build/C/man2/mmap2.2:92 build/C/man2/mprotect.2:226 build/C/man2/mremap.2:199 build/C/man2/msync.2:120 build/C/man3/mtrace.3:167 build/C/man2/posix_fadvise.2:191 build/C/man3/posix_fallocate.3:128 build/C/man3/posix_memalign.3:270 build/C/man2/readahead.2:97 build/C/man2/remap_file_pages.2:157 build/C/man3/shm_open.3:271 build/C/man7/shm_overview.7:114 build/C/man2/shmctl.2:423 build/C/man2/shmget.2:306 build/C/man2/shmop.2:287 build/C/man2/subpage_prot.2:128 build/C/man2/sync_file_range.2:221
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/alloca.3:157
msgid "B<brk>(2), B<longjmp>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/cacheflush.2:25
#, no-wrap
msgid "CACHEFLUSH"
msgstr ""

#. type: TH
#: build/C/man2/cacheflush.2:25
#, no-wrap
msgid "2007-05-26"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:28
msgid "cacheflush - flush contents of instruction and/or data cache"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:31
#, no-wrap
msgid "B<#include E<lt>asm/cachectl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:33
#, no-wrap
msgid "B<int cacheflush(char *>I<addr>B<, int >I<nbytes>B<, int >I<cache>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:43
msgid ""
"B<cacheflush>()  flushes the contents of the indicated cache(s) for the user "
"addresses in the range I<addr> to I<(addr+nbytes-1)>.  I<cache> may be one "
"of:"
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:43
#, no-wrap
msgid "B<ICACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:46
msgid "Flush the instruction cache."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:46
#, no-wrap
msgid "B<DCACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:49
msgid "Write back to memory and invalidate the affected valid cache lines."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:49
#, no-wrap
msgid "B<BCACHE>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:53
msgid "Same as B<(ICACHE|DCACHE)>."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:59
msgid ""
"B<cacheflush>()  returns 0 on success or -1 on error.  If errors are "
"detected, I<errno> will indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:60 build/C/man2/mmap2.2:62 build/C/man2/mremap.2:142 build/C/man2/shmctl.2:310 build/C/man2/subpage_prot.2:72
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:67
msgid ""
"Some or all of the address range I<addr> to I<(addr+nbytes-1)> is not "
"accessible."
msgstr ""

#. type: TP
#: build/C/man2/cacheflush.2:67 build/C/man2/fallocate.2:131 build/C/man2/madvise.2:282 build/C/man3/malloc_info.3:56 build/C/man2/mlock.2:157 build/C/man2/mlock.2:164 build/C/man2/mlock.2:176 build/C/man2/mmap.2:423 build/C/man2/mmap.2:431 build/C/man2/mmap.2:436 build/C/man2/mmap2.2:65 build/C/man2/mprotect.2:95 build/C/man2/mremap.2:151 build/C/man2/msync.2:80 build/C/man2/posix_fadvise.2:94 build/C/man3/posix_fallocate.3:81 build/C/man3/posix_memalign.3:156 build/C/man2/readahead.2:76 build/C/man2/remap_file_pages.2:132 build/C/man2/remap_file_pages.2:139 build/C/man3/shm_open.3:213 build/C/man2/shmctl.2:324 build/C/man2/shmget.2:199 build/C/man2/shmop.2:200 build/C/man2/shmop.2:223 build/C/man2/subpage_prot.2:77 build/C/man2/sync_file_range.2:152
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:75
msgid "I<cache> is not one of B<ICACHE>, B<DCACHE>, or B<BCACHE>."
msgstr ""

#.  FIXME This system call was only on MIPS back in 1.2 days, but
#.  by now it is on a number of other architectures (but not i386).
#.  Investigate the details and update this page.
#.  Irix 6.5 appears to have a cacheflush() syscall -- mtk
#. type: Plain text
#: build/C/man2/cacheflush.2:82
msgid ""
"This Linux-specific system call is available only on MIPS-based systems.  It "
"should not be used in programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/cacheflush.2:89
msgid ""
"The current implementation ignores the I<addr> and I<nbytes> arguments.  "
"Therefore, the whole cache is always flushed."
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "FALLOCATE"
msgstr ""

#. type: TH
#: build/C/man2/fallocate.2:11
#, no-wrap
msgid "2013-06-10"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:14
msgid "fallocate - manipulate file space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:18 build/C/man2/readahead.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:21
#, no-wrap
msgid ""
"B<int fallocate(int >I<fd>B<, int >I<mode>B<, off_t >I<offset>B<, off_t "
">I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:27
msgid ""
"This is a nonportable, Linux-specific system call.  For the portable, "
"POSIX.1-specified method of ensuring that space is allocated for a file, see "
"B<posix_fallocate>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:37
msgid ""
"B<fallocate>()  allows the caller to directly manipulate the allocated disk "
"space for the file referred to by I<fd> for the byte range starting at "
"I<offset> and continuing for I<len> bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:42
msgid ""
"The I<mode> argument determines the operation to be performed on the given "
"range.  Details of the supported operations are given in the subsections "
"below."
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:42
#, no-wrap
msgid "Allocating disk space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:61
msgid ""
"The default operation (i.e., I<mode> is zero) of B<fallocate>()  allocates "
"and initializes to zero the disk space within the range specified by "
"I<offset> and I<len>.  The file size (as reported by B<stat>(2))  will be "
"changed if I<offset>+I<len> is greater than the file size.  This default "
"behavior closely resembles the behavior of the B<posix_fallocate>(3)  "
"library function, and is intended as a method of optimally implementing that "
"function."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:67
msgid ""
"After a successful call, subsequent writes into the range specified by "
"I<offset> and I<len> are guaranteed not to fail because of lack of disk "
"space."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:78
msgid ""
"If the B<FALLOC_FL_KEEP_SIZE> flag is specified in I<mode>, the behavior of "
"the call is similar, but the file size will not be changed even if "
"I<offset>+I<len> is greater than the file size.  Preallocating zeroed blocks "
"beyond the end of the file in this manner is useful for optimizing append "
"workloads."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:82
msgid ""
"Because allocation is done in block size chunks, B<fallocate>()  may "
"allocate a larger range of disk space than was specified."
msgstr ""

#. type: SS
#: build/C/man2/fallocate.2:82
#, no-wrap
msgid "Deallocating file space"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:97
msgid ""
"Specifying the B<FALLOC_FL_PUNCH_HOLE> flag (available since Linux 2.6.38) "
"in I<mode> deallocates space (i.e., creates a hole)  in the byte range "
"starting at I<offset> and continuing for I<len> bytes.  Within the specified "
"range, partial file system blocks are zeroed, and whole file system blocks "
"are removed from the file.  After a successful call, subsequent reads from "
"this range will return zeroes."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:108
msgid ""
"The B<FALLOC_FL_PUNCH_HOLE> flag must be ORed with B<FALLOC_FL_KEEP_SIZE> in "
"I<mode>; in other words, even when punching off the end of the file, the "
"file size (as reported by B<stat>(2))  does not change."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:112
msgid ""
"Not all file systems support B<FALLOC_FL_PUNCH_HOLE>; if a file system "
"doesn't support the operation, an error is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:119
msgid ""
"On success, B<fallocate>()  returns zero.  On error, -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:120 build/C/man2/madvise.2:279 build/C/man2/mmap.2:417 build/C/man2/posix_fadvise.2:91 build/C/man3/posix_fallocate.3:73 build/C/man2/readahead.2:72 build/C/man2/sync_file_range.2:148
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:124 build/C/man3/posix_fallocate.3:77
msgid "I<fd> is not a valid file descriptor, or is not opened for writing."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:124 build/C/man3/posix_fallocate.3:77
#, no-wrap
msgid "B<EFBIG>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:128
msgid "I<offset>+I<len> exceeds the maximum file size."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:128
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:131
msgid "A signal was caught during execution."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:143 build/C/man3/posix_fallocate.3:87
msgid "I<offset> was less than 0, or I<len> was less than or equal to 0."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:143 build/C/man2/madvise.2:310 build/C/man2/sync_file_range.2:160
#, no-wrap
msgid "B<EIO>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:146
msgid "An I/O error occurred while reading from or writing to a file system."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:146 build/C/man2/mmap.2:452 build/C/man3/posix_fallocate.3:87
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:153
msgid ""
"I<fd> does not refer to a regular file or a directory.  (If I<fd> is a pipe "
"or FIFO, a different error results.)"
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:153 build/C/man3/posix_fallocate.3:91 build/C/man2/shmget.2:217 build/C/man2/sync_file_range.2:166
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:158 build/C/man3/posix_fallocate.3:96
msgid ""
"There is not enough space left on the device containing the file referred to "
"by I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:162
msgid "This kernel does not implement B<fallocate>()."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:162
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:171
msgid ""
"The file system containing the file referred to by I<fd> does not support "
"this operation; or the I<mode> is not supported by the file system "
"containing the file referred to by I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:171 build/C/man2/mlock.2:143 build/C/man2/mlock.2:182 build/C/man2/mmap.2:460 build/C/man2/shmctl.2:349 build/C/man2/shmget.2:225
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:187
msgid ""
"The file referred to by I<fd> is marked immutable (see B<chattr>(1)).  Or: "
"I<mode> specifies B<FALLOC_FL_PUNCH_HOLE> and the file referred to by I<fd> "
"is marked append-only (see B<chattr>(1))."
msgstr ""

#. type: TP
#: build/C/man2/fallocate.2:187 build/C/man2/posix_fadvise.2:97 build/C/man3/posix_fallocate.3:96 build/C/man2/sync_file_range.2:169
#, no-wrap
msgid "B<ESPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:191
msgid "I<fd> refers to a pipe or FIFO."
msgstr ""

#. type: SH
#: build/C/man2/fallocate.2:191 build/C/man3/malloc_info.3:60 build/C/man3/mcheck.3:134 build/C/man2/mmap2.2:74 build/C/man2/posix_fadvise.2:104 build/C/man3/posix_fallocate.3:100 build/C/man3/posix_memalign.3:165 build/C/man2/readahead.2:82 build/C/man2/remap_file_pages.2:148 build/C/man3/shm_open.3:249 build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:177
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=14964
#. type: Plain text
#: build/C/man2/fallocate.2:199
msgid ""
"B<fallocate>()  is available on Linux since kernel 2.6.23.  Support is "
"provided by glibc since version 2.10.  The B<FALLOC_FL_*> flags are defined "
"in glibc headers only since version 2.18."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:202
msgid "B<fallocate>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/fallocate.2:207
msgid "B<fallocate>(1), B<ftruncate>(2), B<posix_fadvise>(3), B<posix_fallocate>(3)"
msgstr ""

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "MADVISE"
msgstr ""

#. type: TH
#: build/C/man2/madvise.2:35
#, no-wrap
msgid "2012-04-28"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:38
msgid "madvise - give advice about use of memory"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:40 build/C/man2/msync.2:30 build/C/man3/shm_open.3:31
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:42
msgid "B<int madvise(void *>I<addr>B<, size_t >I<length>B<, int >I<advice>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:46 build/C/man2/posix_fadvise.2:43 build/C/man3/posix_fallocate.3:39 build/C/man3/posix_memalign.3:49
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:50
msgid "B<madvise>(): _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:68
msgid ""
"The B<madvise>()  system call advises the kernel about how to handle paging "
"input/output in the address range beginning at address I<addr> and with size "
"I<length> bytes.  It allows an application to tell the kernel how it expects "
"to use some mapped or shared memory areas, so that the kernel can choose "
"appropriate read-ahead and caching techniques.  This call does not influence "
"the semantics of the application (except in the case of B<MADV_DONTNEED>), "
"but may influence its performance.  The kernel is free to ignore the advice."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:72
msgid "The advice is indicated in the I<advice> argument which can be"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:72
#, no-wrap
msgid "B<MADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:76
msgid "No special treatment.  This is the default."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:76
#, no-wrap
msgid "B<MADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:80
msgid ""
"Expect page references in random order.  (Hence, read ahead may be less "
"useful than normally.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:80
#, no-wrap
msgid "B<MADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:85
msgid ""
"Expect page references in sequential order.  (Hence, pages in the given "
"range can be aggressively read ahead, and may be freed soon after they are "
"accessed.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:85
#, no-wrap
msgid "B<MADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:89
msgid ""
"Expect access in the near future.  (Hence, it might be a good idea to read "
"some pages ahead.)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:89
#, no-wrap
msgid "B<MADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:100
msgid ""
"Do not expect access in the near future.  (For the time being, the "
"application is finished with the given range, so the kernel can free "
"resources associated with it.)  Subsequent accesses of pages in this range "
"will succeed, but will result either in reloading of the memory contents "
"from the underlying mapped file (see B<mmap>(2))  or zero-fill-on-demand "
"pages for mappings without an underlying file."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:100
#, no-wrap
msgid "B<MADV_REMOVE> (Since Linux 2.6.16)"
msgstr ""

#.  2.6.18-rc5
#.  Databases want to use this feature to drop a section of their
#.  bufferpool (shared memory segments) - without writing back to
#.  disk/swap space.  This feature is also useful for supporting
#.  hot-plug memory on UML.
#. type: Plain text
#: build/C/man2/madvise.2:113
msgid ""
"Free up a given range of pages and its associated backing store.  Currently, "
"only shmfs/tmpfs supports this; other file systems return with the error "
"B<ENOSYS>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:113
#, no-wrap
msgid "B<MADV_DONTFORK> (Since Linux 2.6.16)"
msgstr ""

#.  See http://lwn.net/Articles/171941/
#.  [PATCH] madvise MADV_DONTFORK/MADV_DOFORK
#.  Currently, copy-on-write may change the physical address of
#.  a page even if the user requested that the page is pinned in
#.  memory (either by mlock or by get_user_pages).  This happens
#.  if the process forks meanwhile, and the parent writes to that
#.  page.  As a result, the page is orphaned: in case of
#.  get_user_pages, the application will never see any data hardware
#.  DMA's into this page after the COW.  In case of mlock'd memory,
#.  the parent is not getting the realtime/security benefits of mlock.
#
#.  In particular, this affects the Infiniband modules which do DMA from
#.  and into user pages all the time.
#
#.  This patch adds madvise options to control whether memory range is
#.  inherited across fork. Useful e.g. for when hardware is doing DMA
#.  from/into these pages.  Could also be useful to an application
#.  wanting to speed up its forks by cutting large areas out of
#.  consideration.
#
#.  SEE ALSO: http://lwn.net/Articles/171941/
#.  "Tweaks to madvise() and posix_fadvise()", 14 Feb 2006
#. type: Plain text
#: build/C/man2/madvise.2:144
msgid ""
"Do not make the pages in this range available to the child after a "
"B<fork>(2).  This is useful to prevent copy-on-write semantics from changing "
"the physical location of a page(s) if the parent writes to it after a "
"B<fork>(2).  (Such page relocations cause problems for hardware that DMAs "
"into the page(s).)"
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:144
#, no-wrap
msgid "B<MADV_DOFORK> (Since Linux 2.6.16)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:150
msgid ""
"Undo the effect of B<MADV_DONTFORK>, restoring the default behavior, whereby "
"a mapping is inherited across B<fork>(2)."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:150
#, no-wrap
msgid "B<MADV_HWPOISON> (Since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:162
msgid ""
"Poison a page and handle it like a hardware memory corruption.  This "
"operation is available only for privileged (B<CAP_SYS_ADMIN>)  processes.  "
"This operation may result in the calling process receiving a B<SIGBUS> and "
"the page being unmapped.  This feature is intended for testing of memory "
"error-handling code; it is available only if the kernel was configured with "
"B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:162
#, no-wrap
msgid "B<MADV_SOFT_OFFLINE> (Since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:180
msgid ""
"Soft offline the pages in the range specified by I<addr> and I<length>.  The "
"memory of each page in the specified range is preserved (i.e., when next "
"accessed, the same content will be visible, but in a new physical page "
"frame), and the original page is offlined (i.e., no longer used, and taken "
"out of normal memory management).  The effect of the B<MADV_SOFT_OFFLINE> "
"operation is invisible to (i.e., does not change the semantics of)  the "
"calling process.  This feature is intended for testing of memory "
"error-handling code; it is available only if the kernel was configured with "
"B<CONFIG_MEMORY_FAILURE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:180
#, no-wrap
msgid "B<MADV_MERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:205
msgid ""
"Enable Kernel Samepage Merging (KSM) for the pages in the range specified by "
"I<addr> and I<length>.  The kernel regularly scans those areas of user "
"memory that have been marked as mergeable, looking for pages with identical "
"content.  These are replaced by a single write-protected page (which is "
"automatically copied if a process later wants to update the content of the "
"page).  KSM merges only private anonymous pages (see B<mmap>(2)).  The KSM "
"feature is intended for applications that generate many instances of the "
"same data (e.g., virtualization systems such as KVM).  It can consume a lot "
"of processing power; use with care.  See the Linux kernel source file "
"I<Documentation/vm/ksm.txt> for more details.  The B<MADV_MERGEABLE> and "
"B<MADV_UNMERGEABLE> operations are available only if the kernel was "
"configured with B<CONFIG_KSM>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:205
#, no-wrap
msgid "B<MADV_UNMERGEABLE> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:214
msgid ""
"Undo the effect of an earlier B<MADV_MERGEABLE> operation on the specified "
"address range; KSM unmerges whatever pages it had merged in the address "
"range specified by I<addr> and I<length>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:214
#, no-wrap
msgid "B<MADV_HUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#.  http://lwn.net/Articles/358904/
#.  https://lwn.net/Articles/423584/
#. type: Plain text
#: build/C/man2/madvise.2:243
msgid ""
"Enables Transparent Huge Pages (THP) for pages in the range specified by "
"I<addr> and I<length>.  Currently, Transparent Huge Pages work only with "
"private anonymous pages (see B<mmap>(2)).  The kernel will regularly scan "
"the areas marked as huge page candidates to replace them with huge pages.  "
"The kernel will also allocate huge pages directly when the region is "
"naturally aligned to the huge page size (see B<posix_memalign>(2)).  This "
"feature is primarily aimed at applications that use large mappings of data "
"and access large regions of that memory at a time (e.g., virtualization "
"systems such as QEMU).  It can very easily waste memory (e.g., a 2MB mapping "
"that only ever accesses 1 byte will result in 2MB of wired memory instead of "
"one 4KB page).  See the Linux kernel source file "
"I<Documentation/vm/transhuge.txt> for more details.  The B<MADV_HUGEPAGE> "
"and B<MADV_NOHUGEPAGE> operations are available only if the kernel was "
"configured with B<CONFIG_TRANSPARENT_HUGEPAGE>."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:243
#, no-wrap
msgid "B<MADV_NOHUGEPAGE> (since Linux 2.6.38)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:250
msgid ""
"Ensures that memory in the address range specified by I<addr> and I<length> "
"will not be collapsed into huge pages."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:250
#, no-wrap
msgid "B<MADV_DONTDUMP> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:264
msgid ""
"Exclude from a core dump those pages in the range specified by I<addr> and "
"I<length>.  This is useful in applications that have large areas of memory "
"that are known not to be useful in a core dump.  The effect of "
"B<MADV_DONTDUMP> takes precedence over the bit mask that is set via the "
"I</proc/PID/coredump_filter> file (see B<core>(5))."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:264
#, no-wrap
msgid "B<MADV_DODUMP> (since Linux 3.4)"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:268
msgid "Undo the effect of an earlier B<MADV_DONTDUMP>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:275
msgid ""
"On success B<madvise>()  returns zero.  On error, it returns -1 and I<errno> "
"is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:276 build/C/man2/mlock.2:154 build/C/man2/mmap.2:413 build/C/man2/mremap.2:136
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:279
msgid "A kernel resource was temporarily unavailable."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:282
msgid "The map exists, but the area maps something that isn't a file."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:285
msgid "This error can occur for the following reasons:"
msgstr ""

#. type: IP
#: build/C/man2/madvise.2:286 build/C/man2/madvise.2:292 build/C/man2/madvise.2:295 build/C/man2/madvise.2:298 build/C/man2/madvise.2:301 build/C/man3/mallopt.3:235 build/C/man3/mallopt.3:241
#, no-wrap
msgid "*"
msgstr ""

#.  .I len
#.  is zero,
#. type: Plain text
#: build/C/man2/madvise.2:292
msgid "The value I<len> is negative."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:295
msgid "I<addr> is not page-aligned."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:298
msgid "I<advice> is not a valid value"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:301
msgid ""
"The application is attempting to release locked or shared pages (with "
"B<MADV_DONTNEED>)."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:309
msgid ""
"B<MADV_MERGEABLE> or B<MADV_UNMERGEABLE> was specified in I<advice>, but the "
"kernel was not configured with B<CONFIG_KSM>."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:316
msgid ""
"(for B<MADV_WILLNEED>)  Paging in this area would exceed the process's "
"maximum resident set size."
msgstr ""

#. type: TP
#: build/C/man2/madvise.2:316 build/C/man2/madvise.2:321 build/C/man2/mlock.2:123 build/C/man2/mlock.2:131 build/C/man2/mlock.2:169 build/C/man2/mmap.2:456 build/C/man2/mprotect.2:100 build/C/man2/mprotect.2:103 build/C/man2/mremap.2:179 build/C/man2/msync.2:93 build/C/man3/posix_memalign.3:162 build/C/man2/shmctl.2:333 build/C/man2/shmget.2:214 build/C/man2/shmop.2:214 build/C/man2/subpage_prot.2:87 build/C/man2/sync_file_range.2:163
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:321
msgid "(for B<MADV_WILLNEED>)  Not enough memory: paging in failed."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:325
msgid ""
"Addresses in the specified range are not currently mapped, or are outside "
"the address space of the process."
msgstr ""

#.  FIXME . Write a posix_madvise(3) page.
#. type: Plain text
#: build/C/man2/madvise.2:337
msgid ""
"POSIX.1b.  POSIX.1-2001 describes B<posix_madvise>(3)  with constants "
"B<POSIX_MADV_NORMAL>, etc., with a behavior close to that described here.  "
"There is a similar B<posix_fadvise>(2)  for file access."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:346
msgid ""
"B<MADV_REMOVE>, B<MADV_DONTFORK>, B<MADV_DOFORK>, B<MADV_HWPOISON>, "
"B<MADV_MERGEABLE>, and B<MADV_UNMERGEABLE> are Linux-specific."
msgstr ""

#. type: SS
#: build/C/man2/madvise.2:347 build/C/man2/mlock.2:267 build/C/man2/shmget.2:294
#, no-wrap
msgid "Linux notes"
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:355
msgid ""
"The current Linux implementation (2.4.0) views this system call more as a "
"command than as advice and hence may return an error when it cannot do what "
"it usually would do in response to this advice.  (See the ERRORS description "
"above.)  This is nonstandard behavior."
msgstr ""

#.  .SH HISTORY
#.  The
#.  .BR madvise ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/madvise.2:371
msgid ""
"The Linux implementation requires that the address I<addr> be page-aligned, "
"and allows I<length> to be zero.  If there are some parts of the specified "
"address range that are not mapped, the Linux version of B<madvise>()  "
"ignores them and applies the call to the rest (but returns B<ENOMEM> from "
"the system call, as it should)."
msgstr ""

#. type: Plain text
#: build/C/man2/madvise.2:379
msgid ""
"B<getrlimit>(2), B<mincore>(2), B<mmap>(2), B<mprotect>(2), B<msync>(2), "
"B<munmap>(2), B<core>(5)"
msgstr ""

#. type: TH
#: build/C/man3/mallinfo.3:26
#, no-wrap
msgid "MALLINFO"
msgstr ""

#. type: TH
#: build/C/man3/mallinfo.3:26 build/C/man3/malloc_stats.3:26
#, no-wrap
msgid "2012-05-06"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:29
msgid "mallinfo - obtain memory allocation information"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:31 build/C/man3/malloc_stats.3:31 build/C/man3/malloc_trim.3:31 build/C/man3/malloc_usable_size.3:30 build/C/man3/mallopt.3:31
msgid "B<#include E<lt>malloc.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:33
msgid "B<struct mallinfo mallinfo(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:41
msgid ""
"The B<mallinfo>()  function returns a copy of a structure containing "
"information about memory allocations performed by B<malloc>(3)  and related "
"functions.  This structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:56
#, no-wrap
msgid ""
"struct mallinfo {\n"
"    int arena;     /* Non-mmapped space allocated (bytes) */\n"
"    int ordblks;   /* Number of free chunks */\n"
"    int smblks;    /* Number of free fastbin blocks */\n"
"    int hblks;     /* Number of mmapped regions */\n"
"    int hblkhd;    /* Space allocated in mmapped regions (bytes) */\n"
"    int usmblks;   /* Maximum total allocated space (bytes) */\n"
"    int fsmblks;   /* Space in freed fastbin blocks (bytes) */\n"
"    int uordblks;  /* Total allocated space (bytes) */\n"
"    int fordblks;  /* Total free space (bytes) */\n"
"    int keepcost;  /* Top-most, releasable space (bytes) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:62
msgid "The fields of the I<mallinfo> structure contain the following information:"
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:62
#, no-wrap
msgid "I<arena>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:68
msgid ""
"The total amount of memory allocated by means other than B<mmap>(2)  (i.e., "
"memory allocated on the heap).  This figure includes both in-use blocks and "
"blocks on the free list."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:68
#, no-wrap
msgid "I<ordblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:71
msgid "The number of ordinary (i.e., non-fastbin) free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:71
#, no-wrap
msgid "I<smblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:75
msgid "The number of fastbin free blocks (see B<mallopt>(3))."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:75
#, no-wrap
msgid "I<hblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:83
msgid ""
"The number of blocks currently allocated using B<mmap>(2).  (See the "
"discussion of B<M_MMAP_THRESHOLD> in B<mallopt>(3).)"
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:83
#, no-wrap
msgid "I<hblkhd>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:87
msgid "The number of bytes in blocks currently allocated using B<mmap>(2)."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:87
#, no-wrap
msgid "I<usmblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:92
msgid ""
"The \"highwater mark\" for allocated space\\(emthat is, the maximum amount "
"of space that was ever allocated.  This field is maintained only in "
"nonthreading environments."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:92
#, no-wrap
msgid "I<fsmblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:95
msgid "The total number of bytes in fastbin free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:95
#, no-wrap
msgid "I<uordblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:98
msgid "The total number of bytes used by in-use allocations."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:98
#, no-wrap
msgid "I<fordblks>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:101
msgid "The total number of bytes in free blocks."
msgstr ""

#. type: TP
#: build/C/man3/mallinfo.3:101
#, no-wrap
msgid "I<keepcost>"
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallinfo.3:110
msgid ""
"The total amount of releasable free space at the top of the heap.  This is "
"the maximum number of bytes that could ideally (i.e., ignoring page "
"alignment restrictions, and so on) be released by B<malloc_trim>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:114
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, and was specified in the SVID."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=208
#.  See the 24 Aug 2011 mail by Paul Pluzhnikov:
#.      "[patch] Fix mallinfo() to accumulate results for all arenas"
#.  on libc-alpha@sourceware.org
#. type: Plain text
#: build/C/man3/mallinfo.3:126
msgid ""
"B<Information is returned for only the main memory allocation area.> "
"Allocations in other arenas are excluded.  See B<malloc_stats>(3)  and "
"B<malloc_info>(3)  for alternatives that include information about other "
"arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:134
msgid ""
"The fields of the I<mallinfo> structure are typed as I<int>.  However, "
"because some internal bookkeeping values may be of type I<long>, the "
"reported values may wrap around zero and thus be inaccurate."
msgstr ""

#. type: SH
#: build/C/man3/mallinfo.3:134 build/C/man3/malloc_hook.3:89 build/C/man3/malloc_info.3:84 build/C/man3/mallopt.3:466 build/C/man3/mcheck.3:159 build/C/man2/mmap.2:630 build/C/man2/mprotect.2:148 build/C/man3/mtrace.3:108
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:140
msgid ""
"The program below employs B<mallinfo>()  to retrieve memory allocation "
"statistics before and after allocating and freeing some blocks of memory.  "
"The statistics are displayed on standard output."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:144
msgid ""
"The first two command-line arguments specify the number and size of blocks "
"to be allocated with B<malloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:158
msgid ""
"The remaining three arguments specify which of the allocated blocks should "
"be freed with B<free>(3).  These three arguments are optional, and specify "
"(in order): the step size to be used in the loop that frees blocks (the "
"default is 1, meaning free all blocks in the range); the ordinal position of "
"the first block to be freed (default 0, meaning the first allocated block); "
"and a number one greater than the ordinal position of the last block to be "
"freed (default is one greater than the maximum block number).  If these "
"three arguments are omitted, then the defaults cause all allocated blocks to "
"be freed."
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:162
msgid ""
"In the following example run of the program, 1000 allocations of 100 bytes "
"are performed, and then every second allocated block is freed:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:177
#, no-wrap
msgid ""
"$ B<./a.out 1000 100 2>\n"
"============== Before allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       0\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      0\n"
"Total free space (fordblks):           0\n"
"Topmost releasable block (keepcost):   0\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:189
#, no-wrap
msgid ""
"============== After allocating blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            1\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      104000\n"
"Total free space (fordblks):           31168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:201
#, no-wrap
msgid ""
"============== After freeing blocks ==============\n"
"Total non-mmapped bytes (arena):       135168\n"
"# of free chunks (ordblks):            501\n"
"# of free fastbin blocks (smblks):     0\n"
"# of mapped regions (hblks):           0\n"
"Bytes in mapped regions (hblkhd):      0\n"
"Max. total allocated space (usmblks):  0\n"
"Free bytes held in fastbins (fsmblks): 0\n"
"Total allocated space (uordblks):      52000\n"
"Total free space (fordblks):           83168\n"
"Topmost releasable block (keepcost):   31168\n"
msgstr ""

#. type: SS
#: build/C/man3/mallinfo.3:203 build/C/man3/malloc_info.3:167 build/C/man3/mallopt.3:532 build/C/man3/mcheck.3:176 build/C/man2/mprotect.2:165
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:208
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include \"tlpi_hdr.h\"\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:213
#, no-wrap
msgid ""
"static void\n"
"display_mallinfo(void)\n"
"{\n"
"    struct mallinfo mi;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:215
#, no-wrap
msgid "    mi = mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:227
#, no-wrap
msgid ""
"    printf(\"Total non-mmapped bytes (arena):       %d\\en\", mi.arena);\n"
"    printf(\"# of free chunks (ordblks):            %d\\en\", mi.ordblks);\n"
"    printf(\"# of free fastbin blocks (smblks):     %d\\en\", mi.smblks);\n"
"    printf(\"# of mapped regions (hblks):           %d\\en\", mi.hblks);\n"
"    printf(\"Bytes in mapped regions (hblkhd):      %d\\en\", mi.hblkhd);\n"
"    printf(\"Max. total allocated space (usmblks):  %d\\en\", mi.usmblks);\n"
"    printf(\"Free bytes held in fastbins (fsmblks): %d\\en\", mi.fsmblks);\n"
"    printf(\"Total allocated space (uordblks):      %d\\en\", "
"mi.uordblks);\n"
"    printf(\"Total free space (fordblks):           %d\\en\", "
"mi.fordblks);\n"
"    printf(\"Topmost releasable block (keepcost):   %d\\en\", "
"mi.keepcost);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:235
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"#define MAX_ALLOCS 2000000\n"
"    char *alloc[MAX_ALLOCS];\n"
"    int numBlocks, j, freeBegin, freeEnd, freeStep;\n"
"    size_t blockSize;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:239
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || strcmp(argv[1], \"--help\") == 0)\n"
"        usageErr(\"%s num-blocks block-size [free-step [start-free \"\n"
"                \"[end-free]]]\\en\", argv[0]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:245
#, no-wrap
msgid ""
"    numBlocks = atoi(argv[1]);\n"
"    blockSize = atoi(argv[2]);\n"
"    freeStep = (argc E<gt> 3) ? atoi(argv[3]) : 1;\n"
"    freeBegin = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
"    freeEnd = (argc E<gt> 5) ? atoi(argv[5]) : numBlocks;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:248
#, no-wrap
msgid ""
"    printf(\"============== Before allocating blocks "
"==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:252
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++) {\n"
"        if (numBlocks E<gt>= MAX_ALLOCS)\n"
"            fatal(\"Too many allocations\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:257
#, no-wrap
msgid ""
"        alloc[j] = malloc(blockSize);\n"
"        if (alloc[j] == NULL)\n"
"            errExit(\"malloc\");\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:260
#, no-wrap
msgid ""
"    printf(\"\\en============== After allocating blocks "
"==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:263
#, no-wrap
msgid ""
"    for (j = freeBegin; j E<lt> freeEnd; j += freeStep)\n"
"        free(alloc[j]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:266
#, no-wrap
msgid ""
"    printf(\"\\en============== After freeing blocks "
"==============\\en\");\n"
"    display_mallinfo();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:269 build/C/man3/malloc_info.3:255 build/C/man3/mallopt.3:565 build/C/man3/mcheck.3:203 build/C/man2/mmap.2:711
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallinfo.3:279
msgid ""
"B<mmap>(2), B<malloc>(3), B<malloc_info>(3), B<malloc_stats>(3), "
"B<malloc_trim>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_get_state.3:25
#, no-wrap
msgid "MALLOC_GET_STATE"
msgstr ""

#. type: TH
#: build/C/man3/malloc_get_state.3:25
#, no-wrap
msgid "2012-05-04"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:28
msgid ""
"malloc_get_state, malloc_set_state - record and restore state of malloc "
"implementation"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:31 build/C/man3/posix_memalign.3:35
#, no-wrap
msgid "B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:33
#, no-wrap
msgid "B<void* malloc_get_state(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:35
#, no-wrap
msgid "B<int malloc_set_state(void *>I<state>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:53
msgid ""
"The B<malloc_get_state>()  function records the current state of all "
"B<malloc>(3)  internal bookkeeping variables (but not the actual contents of "
"the heap or the state of B<malloc_hook>(3)  functions pointers).  The state "
"is recorded in a system-dependent opaque data structure dynamically "
"allocated via B<malloc>(3), and a pointer to that data structure is returned "
"as the function result.  (It is the caller's responsibility to B<free>(3)  "
"this memory.)"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:61
msgid ""
"The B<malloc_set_state>()  function restores the state of all B<malloc>(3)  "
"internal bookkeeping variables to the values recorded in the opaque data "
"structure pointed to by I<state>."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:68
msgid ""
"On success, B<malloc_get_state>()  returns a pointer to a newly allocated "
"opaque data structure.  On error (for example, memory could not be allocated "
"for the data structure), B<malloc_get_state>()  returns NULL."
msgstr ""

#.  if(ms->magic != MALLOC_STATE_MAGIC) return -1;
#.  /* Must fail if the major version is too high. */
#.  if((ms->version & ~0xffl) > (MALLOC_STATE_VERSION & ~0xffl)) return -2;
#. type: Plain text
#: build/C/man3/malloc_get_state.3:86
msgid ""
"On success, B<malloc_set_state>()  returns 0.  If the implementation detects "
"that I<state> does not point to a correctly formed data structure, "
"B<malloc_set_state>()  returns -1.  If the implementation detects that the "
"version of the data structure referred to by I<state> is a more recent "
"version than this implementation knows about, B<malloc_set_state>()  returns "
"-2."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:88 build/C/man3/malloc_hook.3:82 build/C/man3/mcheck.3:147 build/C/man3/mtrace.3:80
msgid "These functions are GNU extensions."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:94
msgid ""
"These functions are especially useful when using this B<malloc>(3)  "
"implementation as part of a shared library, and the heap contents are "
"saved/restored via some other method.  This technique is used by the GNU "
"Emacs to implement its \"dumping\" function."
msgstr ""

#.  i.e., calls __malloc_check_init()
#.  i.e., malloc checking is not already in use
#.  and the caller requested malloc checking
#. type: Plain text
#: build/C/man3/malloc_get_state.3:111
msgid ""
"Hook function pointers are never saved or restored by these functions, with "
"two exceptions: if malloc checking (see B<mallopt>(3))  was in use when "
"B<malloc_get_state>()  was called, then B<malloc_set_state>()  resets malloc "
"checking hooks if possible; if malloc checking was not in use in the "
"recorded state, but the caller has requested malloc checking, then the hooks "
"are reset to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_get_state.3:114
msgid "B<malloc>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_hook.3:10
#, no-wrap
msgid "MALLOC_HOOK"
msgstr ""

#. type: TH
#: build/C/man3/malloc_hook.3:10
#, no-wrap
msgid "2010-10-13"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:15
msgid ""
"__malloc_hook, __malloc_initialize_hook, __memalign_hook, __free_hook, "
"__realloc_hook, __after_morecore_hook - malloc debugging variables"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:18 build/C/man3/malloc_info.3:31 build/C/man3/posix_memalign.3:41
#, no-wrap
msgid "B<#include E<lt>malloc.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:20
#, no-wrap
msgid "B<void *(*__malloc_hook)(size_t >I<size>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:23
#, no-wrap
msgid ""
"B<void *(*__realloc_hook)(void *>I<ptr>B<, size_t >I<size>B<, const void "
"*>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:26
#, no-wrap
msgid ""
"B<void *(*__memalign_hook)(size_t >I<alignment>B<, size_t >I<size>B<,>\n"
"B<                         const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:28
#, no-wrap
msgid "B<void (*__free_hook)(void *>I<ptr>B<, const void *>I<caller>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:30
#, no-wrap
msgid "B<void (*__malloc_initialize_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:32
#, no-wrap
msgid "B<void (*__after_morecore_hook)(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:43
msgid ""
"The GNU C library lets you modify the behavior of B<malloc>(3), "
"B<realloc>(3), and B<free>(3)  by specifying appropriate hook functions.  "
"You can use these hooks to help you debug programs that use dynamic memory "
"allocation, for example."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:50
msgid ""
"The variable B<__malloc_initialize_hook> points at a function that is called "
"once when the malloc implementation is initialized.  This is a weak "
"variable, so it can be overridden in the application with a definition like "
"the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:53
#, no-wrap
msgid "    void (*__malloc_initialize_hook)(void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:58
msgid "Now the function I<my_init_hook>()  can do the initialization of all hooks."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:74
msgid ""
"The four functions pointed to by B<__malloc_hook>, B<__realloc_hook>, "
"B<__memalign_hook>, B<__free_hook> have a prototype like the functions "
"B<malloc>(3), B<realloc>(3), B<memalign>(3), B<free>(3), respectively, "
"except that they have a final argument I<caller> that gives the address of "
"the caller of B<malloc>(3), etc."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:80
msgid ""
"The variable B<__after_morecore_hook> points at a function that is called "
"each time after B<sbrk>(2)  was asked for more memory."
msgstr ""

#.  https://bugzilla.redhat.com/show_bug.cgi?id=450187
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=9957
#. type: Plain text
#: build/C/man3/malloc_hook.3:89
msgid ""
"The use of these hook functions is not safe in multithreaded programs, and "
"they are now deprecated.  Programmers should instead preempt calls to the "
"relevant functions by defining and exporting functions such as \"malloc\" "
"and \"free\"."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:91
msgid "Here is a short example of how to use these variables."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:95
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:99
#, no-wrap
msgid ""
"/* Prototypes for our hooks.  */\n"
"static void my_init_hook(void);\n"
"static void *my_malloc_hook(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:102
#, no-wrap
msgid ""
"/* Variables to save original hooks. */\n"
"static void *(*old_malloc_hook)(size_t, const void *);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:105
#, no-wrap
msgid ""
"/* Override initializing hook from the C library. */\n"
"void (*__malloc_initialize_hook) (void) = my_init_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:112
#, no-wrap
msgid ""
"static void\n"
"my_init_hook(void)\n"
"{\n"
"    old_malloc_hook = __malloc_hook;\n"
"    __malloc_hook = my_malloc_hook;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:117
#, no-wrap
msgid ""
"static void *\n"
"my_malloc_hook(size_t size, const void *caller)\n"
"{\n"
"    void *result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:120
#, no-wrap
msgid ""
"    /* Restore all old hooks */\n"
"    __malloc_hook = old_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:123
#, no-wrap
msgid ""
"    /* Call recursively */\n"
"    result = malloc(size);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:126
#, no-wrap
msgid ""
"    /* Save underlying hooks */\n"
"    old_malloc_hook = __malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:130
#, no-wrap
msgid ""
"    /* printf() might call malloc(), so protect it too. */\n"
"    printf(\"malloc(%u) called from %p returns %p\\en\",\n"
"            (unsigned int) size, caller, result);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:133
#, no-wrap
msgid ""
"    /* Restore our own hooks */\n"
"    __malloc_hook = my_malloc_hook;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:136
#, no-wrap
msgid ""
"    return result;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_hook.3:142
msgid "B<mallinfo>(3), B<malloc>(3), B<mcheck>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_info.3:25
#, no-wrap
msgid "MALLOC_INFO"
msgstr ""

#. type: TH
#: build/C/man3/malloc_info.3:25 build/C/man2/shmget.2:38
#, no-wrap
msgid "2013-04-19"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:28
msgid "malloc_info - export malloc state to a stream"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:33
#, no-wrap
msgid "B<int malloc_info(int >I<options>B<, FILE *>I<fp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:44
msgid ""
"The B<malloc_info>()  function exports an XML string that describes the "
"current state of the memory-allocation implementation in the caller.  The "
"string is printed on the file stream I<fp>.  The exported string includes "
"information about all arenas (see B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:48
msgid "As currently implemented, I<options> must be zero."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:55
msgid ""
"On success, B<malloc_info>()  returns 0; on error, it returns -1, with "
"I<errno> set to indicate the cause."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:60
msgid "I<options> was nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:63
msgid "B<malloc_info>()  was added to glibc in version 2.10."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:65 build/C/man3/malloc_stats.3:57 build/C/man3/malloc_trim.3:62 build/C/man3/malloc_usable_size.3:50
msgid "This function is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:71
msgid ""
"The memory-allocation information is provided as an XML string (rather than "
"a C structure)  because the information may change over time (according to "
"changes in the underlying implementation).  The output XML string includes a "
"version field."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:77
msgid ""
"The B<open_memstream>(3)  function can be used to send the output of "
"B<malloc_info>()  directly into a buffer in memory, rather than to a file."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:84
msgid ""
"The B<malloc_info>()  function is designed to address deficiencies in "
"B<malloc_stats>(3)  and B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:95
msgid ""
"The program below takes up to four command-line arguments, of which the "
"first three are mandatory.  The first argument specifies the number of "
"threads that the program should create.  All of the threads, including the "
"main thread, allocate the number of blocks of memory specified by the second "
"argument.  The third argument controls the size of the blocks to be "
"allocated.  The main thread creates blocks of this size, the second thread "
"created by the program allocates blocks of twice this size, the third thread "
"allocates blocks of three times this size, and so on."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:102
msgid ""
"The program calls B<malloc_info>()  twice to display the memory-allocation "
"state.  The first call takes place before any threads are created or memory "
"allocated.  The second call is performed after all threads have allocated "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:110
msgid ""
"In the following example, the command-line arguments specify the creation of "
"one additional thread, and both the main thread and the additional thread "
"allocate 10000 blocks of memory.  After the blocks of memory have been "
"allocated, B<malloc_info>()  shows the state of two allocation arenas."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:135
#, no-wrap
msgid ""
"$ B<getconf GNU_LIBC_VERSION>\n"
"glibc 2.13\n"
"$ B<./a.out 1 10000 100>\n"
"============ Before allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"135168\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"135168\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"135168\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:165
#, no-wrap
msgid ""
"============ After allocating blocks ============\n"
"E<lt>malloc version=\"1\"E<gt>\n"
"E<lt>heap nr=\"0\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1081344\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1081344\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1081344\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>heap nr=\"1\"E<gt>\n"
"E<lt>sizesE<gt>\n"
"E<lt>/sizesE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"1032192\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"1032192\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"1032192\"/E<gt>\n"
"E<lt>/heapE<gt>\n"
"E<lt>total type=\"fast\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>total type=\"rest\" count=\"0\" size=\"0\"/E<gt>\n"
"E<lt>system type=\"current\" size=\"2113536\"/E<gt>\n"
"E<lt>system type=\"max\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"total\" size=\"2113536\"/E<gt>\n"
"E<lt>aspace type=\"mprotect\" size=\"2113536\"/E<gt>\n"
"E<lt>/mallocE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:175
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:178
#, no-wrap
msgid ""
"static size_t blockSize;\n"
"static int numThreads, numBlocks;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:181
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:187
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *arg)\n"
"{\n"
"    int j;\n"
"    int tn = (int) arg;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:190
#, no-wrap
msgid ""
"    /* The multiplier \\(aq(2 + tn)\\(aq ensures that each thread "
"(including\n"
"       the main thread) allocates a different amount of memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:194
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize * (2 + tn)) == NULL)\n"
"            errExit(\"malloc-thread\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:198
#, no-wrap
msgid ""
"    sleep(100);         /* Sleep until main thread terminates */\n"
"    return NULL;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:204
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j, tn, sleepTime;\n"
"    pthread_t *thr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:211
#, no-wrap
msgid ""
"    if (argc E<lt> 4) {\n"
"        fprintf(stderr,\n"
"                \"%s num-threads num-blocks block-size [sleep-time]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:216
#, no-wrap
msgid ""
"    numThreads = atoi(argv[1]);\n"
"    numBlocks = atoi(argv[2]);\n"
"    blockSize = atoi(argv[3]);\n"
"    sleepTime = (argc E<gt> 4) ? atoi(argv[4]) : 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:220
#, no-wrap
msgid ""
"    thr = calloc(numThreads, sizeof(pthread_t));\n"
"    if (thr == NULL)\n"
"        errExit(\"calloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:223
#, no-wrap
msgid ""
"    printf(\"============ Before allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:225
#, no-wrap
msgid "    /* Create threads that allocate different amounts of memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:231
#, no-wrap
msgid ""
"    for (tn = 0; tn E<lt> numThreads; tn++) {\n"
"        errno = pthread_create(&thr[tn], NULL, thread_func,\n"
"                               (void *) tn);\n"
"        if (errno != 0)\n"
"            errExit(\"pthread_create\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:236
#, no-wrap
msgid ""
"        /* If we add a sleep interval after the start-up of each\n"
"           thread, the threads likely won\\(aqt contend for malloc\n"
"           mutexes, and therefore additional arenas won\\(aqt be\n"
"           allocated (see malloc(3)). */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:240
#, no-wrap
msgid ""
"        if (sleepTime E<gt> 0)\n"
"            sleep(sleepTime);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:242
#, no-wrap
msgid "    /* The main thread also allocates some memory */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:246
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> numBlocks; j++)\n"
"        if (malloc(blockSize) == NULL)\n"
"            errExit(\"malloc\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:249
#, no-wrap
msgid ""
"    sleep(2);           /* Give all threads a chance to\n"
"                           complete allocations */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:252
#, no-wrap
msgid ""
"    printf(\"\\en============ After allocating blocks ============\\en\");\n"
"    malloc_info(0, stdout);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_info.3:262
msgid ""
"B<mallinfo>(3), B<malloc>(3), B<malloc_stats>(3), B<mallopt>(3), "
"B<open_memstream>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_stats.3:26
#, no-wrap
msgid "MALLOC_STATS"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:29
msgid "malloc_stats - print memory allocation statistics"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:33
msgid "B<void malloc_stats(void);>"
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_stats.3:55
msgid ""
"The B<malloc_stats>()  function prints (on standard error) statistics about "
"memory allocated by B<malloc>(3)  and related functions.  For each arena "
"(allocation area), this function prints the total amount of memory allocated "
"and the total number of bytes consumed by in-use allocations.  (These two "
"values correspond to the I<arena> and I<uordblks> fields retrieved by "
"B<mallinfo>(3).)  In addition, the function prints the sum of these two "
"statistics for all arenas, and the maximum number of blocks and bytes that "
"were ever simultaneously allocated using B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:61
msgid ""
"More detailed information about memory allocations in the main arena can be "
"obtained using B<mallinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_stats.3:67
msgid "B<mmap>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_info>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_trim.3:26
#, no-wrap
msgid "MALLOC_TRIM"
msgstr ""

#. type: TH
#: build/C/man3/malloc_trim.3:26 build/C/man3/malloc_usable_size.3:25
#, no-wrap
msgid "2012-03-29"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:29
msgid "malloc_trim - release free memory from the top of the heap"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:33
msgid "B<void malloc_trim(size_t >I<pad>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:40
msgid ""
"The B<malloc_trim>()  function attempts to release free memory at the top of "
"the heap (by calling B<sbrk>(2)  with a suitable argument)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:51
msgid ""
"The I<pad> argument specifies the amount of free space to leave untrimmed at "
"the top of the heap.  If this argument is 0, only the minimum amount of "
"memory is maintained at the top of the heap (i.e., one page or less).  A "
"nonzero argument can be used to maintain some trailing space at the top of "
"the heap in order to allow future allocations to be made without having to "
"extend the heap with B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:56
msgid ""
"The B<malloc_trim>()  function returns 1 if memory was actually released "
"back to the system, or 0 if it was not possible to release any memory."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/malloc_trim.3:60
msgid "No errors are defined."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:71
msgid ""
"This function is automatically called by B<free>(3)  in certain "
"circumstances; see the discussion of B<M_TOP_PAD> and B<M_TRIM_THRESHOLD> in "
"B<mallopt>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:74
msgid ""
"This function cannot release free memory located at places other than the "
"top of the heap."
msgstr ""

#.  malloc/malloc.c::mTRIm():
#.      return result | (av == &main_arena ? sYSTRIm (pad, av) : 0);
#. type: Plain text
#: build/C/man3/malloc_trim.3:78
msgid "This function releases only memory in the main arena."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_trim.3:82
msgid "B<sbrk>(2), B<malloc>(3), B<mallopt>(3)"
msgstr ""

#. type: TH
#: build/C/man3/malloc_usable_size.3:25
#, no-wrap
msgid "MALLOC_USABLE_SIZE"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:28
msgid "malloc_usable_size - obtain size of block of memory allocated from heap"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:32
msgid "B<size_t malloc_usable_size (void *>I<ptr>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:40
msgid ""
"The B<malloc_usable_size>()  function returns the number of usable bytes in "
"the block pointed to by I<ptr>, a pointer to a block of memory allocated by "
"B<malloc>(3)  or a related function."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:48
msgid ""
"B<malloc_usable_size>()  returns the number of usable bytes in the block of "
"allocated memory pointed to by I<ptr>.  If I<ptr> is NULL, 0 is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:60
msgid ""
"The value returned by B<malloc_usable_size>()  may be greater than the "
"requested size of the allocation because of alignment and minimum size "
"constraints.  Although the excess bytes can be overwritten by the "
"application without ill effects, this is not good programming practice: the "
"number of excess bytes in an allocation depends on the underlying "
"implementation."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:62
msgid "The main use of this function is for debugging and introspection."
msgstr ""

#. type: Plain text
#: build/C/man3/malloc_usable_size.3:64
msgid "B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man3/mallopt.3:26
#, no-wrap
msgid "MALLOPT"
msgstr ""

#. type: TH
#: build/C/man3/mallopt.3:26
#, no-wrap
msgid "2012-04-30"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:29
msgid "mallopt - set memory allocation parameters"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:33
msgid "B<int mallopt(int >I<param>B<, int >I<value>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:44
msgid ""
"The B<mallopt>()  function adjusts parameters that control the behavior of "
"the memory-allocation functions (see B<malloc>(3)).  The I<param> argument "
"specifies the parameter to be modified, and I<value> specifies the new value "
"for that parameter."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:47
msgid "The following values can be specified for I<param>:"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:47
#, no-wrap
msgid "B<M_CHECK_ACTION>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:53
msgid ""
"Setting this parameter controls how glibc responds when various kinds of "
"programming errors are detected (e.g., freeing the same pointer twice).  The "
"3 least significant bits (2, 1, and 0) of the value assigned to this "
"parameter determine the glibc behavior, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:54
#, no-wrap
msgid "Bit 0"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:64
msgid ""
"If this bit is set, then print a one-line message on I<stderr> that provides "
"details about the error.  The message starts with the string \"***\\ glibc "
"detected\\ ***\", followed by the program name, the name of the "
"memory-allocation function in which the error was detected, a brief "
"description of the error, and the memory address where the error was "
"detected."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:64
#, no-wrap
msgid "Bit 1"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:79
msgid ""
"If this bit is set, then, after printing any error message specified by bit "
"0, the program is terminated by calling B<abort>(3).  In glibc versions "
"since 2.4, if bit 0 is also set, then, between printing the error message "
"and aborting, the program also prints a stack trace in the manner of "
"B<backtrace>(3), and prints the process's memory mapping in the style of "
"I</proc/[pid]/maps> (see B<proc>(5))."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:79
#, no-wrap
msgid "Bit 2 (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:86
msgid ""
"This bit has an effect only if bit 0 is also set.  If this bit is set, then "
"the one-line message describing the error is simplified to contain just the "
"name of the function where the error was detected and the brief description "
"of the error."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:91
msgid "The remaining bits in I<value> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:95
msgid ""
"Combining the above details, the following numeric values are meaningful for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:96
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:98
msgid "Ignore error conditions; continue execution (with undefined results)."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:98
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:100
msgid "Print a detailed error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:100
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:102
msgid "Abort the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:102
#, no-wrap
msgid "3"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:105
msgid ""
"Print detailed error message, stack trace, and memory mappings, and abort "
"the program."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:105
#, no-wrap
msgid "5"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:107
msgid "Print a simple error message and continue execution."
msgstr ""

#. type: IP
#: build/C/man3/mallopt.3:107
#, no-wrap
msgid "7"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:110
msgid ""
"Print simple error message, stack trace, and memory mappings, and abort the "
"program."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:116
msgid ""
"Since glibc 2.3.4, the default value for the B<M_CHECK_ACTION> parameter is "
"3.  In glibc version 2.3.3 and earlier, the default value is 1."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:121
msgid ""
"Using a nonzero B<M_CHECK_ACTION> value can be useful because otherwise a "
"crash may happen much later, and the true cause of the problem is then very "
"hard to track down."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:121
#, no-wrap
msgid "B<M_MMAP_MAX>"
msgstr ""

#.  The following text adapted from comments in the glibc source:
#. type: Plain text
#: build/C/man3/mallopt.3:131
msgid ""
"This parameter specifies the maximum number of allocation requests that may "
"be simultaneously serviced using B<mmap>(2).  This parameter exists because "
"some systems have a limited number of internal tables for use by B<mmap>(2), "
"and using more than a few of them may degrade performance."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:138
msgid ""
"The default value is 65,536, a value which has no special significance and "
"which servers only as a safeguard.  Setting this parameter to 0 disables the "
"use of B<mmap>(2)  for servicing large allocation requests."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:138
#, no-wrap
msgid "B<M_MMAP_THRESHOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:147
msgid ""
"For allocations greater than or equal to the limit specified (in bytes) by "
"B<M_MMAP_THRESHOLD> that can't be satisfied from the free list, the "
"memory-allocation functions employ B<mmap>(2)  instead of increasing the "
"program break using B<sbrk>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:167
msgid ""
"Allocating memory using B<mmap>(2)  has the significant advantage that the "
"allocated memory blocks can always be independently released back to the "
"system.  (By contrast, the heap can be trimmed only if memory is freed at "
"the top end.)  On the other hand, there are some disadvantages to the use of "
"B<mmap>(2): deallocated space is not placed on the free list for reuse by "
"later allocations; memory may be wasted because B<mmap>(2)  allocations must "
"be page-aligned; and the kernel must perform the expensive task of zeroing "
"out memory allocated via B<mmap>(2).  Balancing these factors leads to a "
"default setting of 128*1024 for the B<M_MMAP_THRESHOLD> parameter."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:174
msgid ""
"The lower limit for this parameter is 0.  The upper limit is "
"B<DEFAULT_MMAP_THRESHOLD_MAX>: 512*1024 on 32-bit systems or "
"I<4*1024*1024*sizeof(long)> on 64-bit systems."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:192
msgid ""
"I<Note:> Nowadays, glibc uses a dynamic mmap threshold by default.  The "
"initial value of the threshold is 128*1024, but when blocks larger than the "
"current threshold and less than or equal to B<DEFAULT_MMAP_THRESHOLD_MAX> "
"are freed, the threshold is adjusted upwards to the size of the freed "
"block.  When dynamic mmap thresholding is in effect, the threshold for "
"trimming the heap is also dynamically adjusted to be twice the dynamic mmap "
"threshold.  Dynamic adjustment of the mmap threshold is disabled if any of "
"the B<M_TRIM_THRESHOLD>, B<M_TOP_PAD>, B<M_MMAP_THRESHOLD>, or B<M_MMAP_MAX> "
"parameters is set."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:192
#, no-wrap
msgid "B<M_MXFAST> (since glibc 2.3)"
msgstr ""

#.  The following text adapted from comments in the glibc sources:
#. type: Plain text
#: build/C/man3/mallopt.3:212
msgid ""
"Set the upper limit for memory allocation requests that are satisfied using "
"\"fastbins\".  (The measurement unit for this parameter is bytes.)  Fastbins "
"are storage areas that hold deallocated blocks of memory of the same size "
"without merging adjacent free blocks.  Subsequent reallocation of blocks of "
"the same size can be handled very quickly by allocating from the fastbin, "
"although memory fragmentation and the overall memory footprint of the "
"program can increase.  The default value for this parameter is "
"I<64*sizeof(size_t)/4> (i.e., 64 on 32-bit architectures).  The range for "
"this parameter is 0 to I<80*sizeof(size_t)/4>.  Setting B<M_MXFAST> to 0 "
"disables the use of fastbins."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:212
#, no-wrap
msgid "B<M_PERTURB> (since glibc 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:227
msgid ""
"If this parameter is set to a nonzero value, then bytes of allocated memory "
"(other than allocations via B<calloc>(3))  are initialized to the complement "
"of the value in the least significant byte of I<value>, and when allocated "
"memory is released using B<free>(3), the freed bytes are set to the least "
"significant byte of I<value>.  This can be useful for detecting errors where "
"programs incorrectly rely on allocated memory being initialized to zero, or "
"reuse values in memory that has already been freed."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:227
#, no-wrap
msgid "B<M_TOP_PAD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:234
msgid ""
"This parameter defines the amount of padding to employ when calling "
"B<sbrk>(2)  to modify the program break.  (The measurement unit for this "
"parameter is bytes.)  This parameter has an effect in the following "
"circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:241
msgid ""
"When the program break is increased, then B<M_TOP_PAD> bytes are added to "
"the B<sbrk>(2)  request."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:247
msgid ""
"When the heap is trimmed as a consequence of calling B<free>(3)  (see the "
"discussion of B<M_TRIM_THRESHOLD>)  this much free space is preserved at the "
"top of the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:251
msgid ""
"In either case, the amount of padding is always rounded to a system page "
"boundary."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:258
msgid ""
"Modifying B<M_TOP_PAD> is a trade-off between increasing the number of "
"system calls (when the parameter is set low)  and wasting unused memory at "
"the top of the heap (when the parameter is set high)."
msgstr ""

#.  DEFAULT_TOP_PAD in glibc source
#. type: Plain text
#: build/C/man3/mallopt.3:261
msgid "The default value for this parameter is 128*1024."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:261
#, no-wrap
msgid "B<M_TRIM_THRESHOLD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:277
msgid ""
"When the amount of contiguous free memory at the top of the heap grows "
"sufficiently large, B<free>(3)  employs B<sbrk>(2)  to release this memory "
"back to the system.  (This can be useful in programs that continue to "
"execute for a long period after freeing a significant amount of memory.)  "
"The B<M_TRIM_THRESHOLD> parameter specifies the minimum size (in bytes) that "
"this block of memory must reach before B<sbrk>(2)  is used to trim the heap."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:282
msgid ""
"The default value for this parameter is 128*1024.  Setting "
"B<M_TRIM_THRESHOLD> to -1 disables trimming completely."
msgstr ""

#.  FIXME Do the arena parameters need to be documented?
#.  .TP
#.  .BR M_ARENA_TEST " (since glibc 2.10)"
#.  .TP
#.  .BR M_ARENA_MAX " (since glibc 2.10)"
#
#.  Environment variables
#.      MALLOC_ARENA_MAX_
#.      MALLOC_ARENA_TEST_
#
#.  http://udrepper.livejournal.com/20948.html describes some details
#. 	of the MALLOC_ARENA_* environment variables.
#
#.  These macros aren't enabled in production releases until 2.15?
#.  (see glibc malloc/Makefile)
#. type: Plain text
#: build/C/man3/mallopt.3:305
msgid ""
"Modifying B<M_TRIM_THRESHOLD> is a trade-off between increasing the number "
"of system calls (when the parameter is set low)  and wasting unused memory "
"at the top of the heap (when the parameter is set high)."
msgstr ""

#. type: SS
#: build/C/man3/mallopt.3:305
#, no-wrap
msgid "Environment variables"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:320
msgid ""
"A number of environment variables can be defined to modify some of the same "
"parameters as are controlled by B<mallopt>().  Using these variables has the "
"advantage that the source code of the program need not be changed.  To be "
"effective, these variables must be defined before the first call to a "
"memory-allocation function.  (If the same parameters are adjusted via "
"B<mallopt>()  then the B<mallopt>()  settings take precedence.)  For "
"security reasons, these variables are ignored in set-user-ID and "
"set-group-ID programs."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:323
msgid ""
"The environment variables are as follows (note the trailing underscore at "
"the end of the name of each variable):"
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:323
#, no-wrap
msgid "B<MALLOC_CHECK_>"
msgstr ""

#.  On glibc 2.12/x86, a simple malloc()+free() loop is about 70% slower
#.  when MALLOC_CHECK_ was set.
#. type: Plain text
#: build/C/man3/mallopt.3:340
msgid ""
"This environment variable controls the same parameter as B<mallopt>()  "
"B<M_CHECK_ACTION>.  If this variable is set to a nonzero value, then a "
"special implementation of the memory-allocation functions is used.  (This is "
"accomplished using the B<malloc_hook>(3)  feature.)  This implementation "
"performs additional error checking, but is slower than the standard set of "
"memory-allocation functions.  (This implementation does not detect all "
"possible errors; memory leaks can still occur.)"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:345
msgid ""
"The value assigned to this environment variable should be a single digit, "
"whose meaning is as described for B<M_CHECK_ACTION>.  Any characters beyond "
"the initial digit are ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:354
msgid ""
"For security reasons, the effect of B<MALLOC_CHECK_> is disabled by default "
"for set-user-ID and set-group-ID programs.  However, if the file "
"I</etc/suid-debug> exists (the content of the file is irrelevant), then "
"B<MALLOC_CHECK_> also has an effect for set-user-ID and set-group-ID "
"programs."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:354
#, no-wrap
msgid "B<MALLOC_MMAP_MAX_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:359
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_MAX>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:359
#, no-wrap
msgid "B<MALLOC_MMAP_THRESHOLD_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:364
msgid "Controls the same parameter as B<mallopt>()  B<M_MMAP_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:364
#, no-wrap
msgid "B<MALLOC_PERTURB_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:369
msgid "Controls the same parameter as B<mallopt>()  B<M_PERTURB>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:369
#, no-wrap
msgid "B<MALLOC_TRIM_THRESHOLD_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:374
msgid "Controls the same parameter as B<mallopt>()  B<M_TRIM_THRESHOLD>."
msgstr ""

#. type: TP
#: build/C/man3/mallopt.3:374
#, no-wrap
msgid "B<MALLOC_TOP_PAD_>"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:379
msgid "Controls the same parameter as B<mallopt>()  B<M_TOP_PAD>."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:384
msgid "On success, B<mallopt>()  returns 1.  On error, it returns 0."
msgstr ""

#.  .SH VERSIONS
#.  Available already in glibc 2.0, possibly earlier
#. type: Plain text
#: build/C/man3/mallopt.3:392
msgid "On error, I<errno> is I<not> set."
msgstr ""

#.  .SH NOTES
#. type: Plain text
#: build/C/man3/mallopt.3:406
msgid ""
"This function is not specified by POSIX or the C standards.  A similar "
"function exists on many System V derivatives, but the range of values for "
"I<param> varies across systems.  The SVID defined options B<M_MXFAST>, "
"B<M_NLBLKS>, B<M_GRAIN>, and B<M_KEEP>, but only the first of these is "
"implemented in glibc."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:410
msgid "Specifying an invalid value for I<param> does not generate an error."
msgstr ""

#.  FIXME This looks buggy:
#.  setting the M_MXFAST limit rounds up:    (s + SIZE_SZ) & ~MALLOC_ALIGN_MASK)
#.  malloc requests are rounded up:
#.     (req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12129
#. type: Plain text
#: build/C/man3/mallopt.3:418
msgid ""
"A calculation error within the glibc implementation means that a call of the "
"form:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:421
#, no-wrap
msgid "    mallopt(M_MXFAST, n)\n"
msgstr ""

#.  Bins are multiples of 2 * sizeof(size_t) + sizeof(size_t)
#. type: Plain text
#: build/C/man3/mallopt.3:433
msgid ""
"does not result in fastbins being employed for all allocations of size up to "
"I<n>.  To ensure desired results, I<n> should be rounded up to the next "
"multiple greater than or equal to I<(2k+1)*sizeof(size_t)>, where I<k> is an "
"integer."
msgstr ""

#.  FIXME MALLOC_MMAP_THRESHOLD_ and MALLOC_MMAP_MAX_
#.  do have an effect for set-user-ID programs (but not
#.  set-group-ID programs).
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12155
#. type: Plain text
#: build/C/man3/mallopt.3:445
msgid ""
"The B<MALLOC_MMAP_THRESHOLD_> and B<MALLOC_MMAP_MAX_> variables are I<not> "
"ignored in set-group-ID programs."
msgstr ""

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12140
#. type: Plain text
#: build/C/man3/mallopt.3:466
msgid ""
"If B<mallopt>()  is used to set B<M_PERTURB>, then, as expected, the bytes "
"of allocated memory are initialized to the complement of the byte in "
"I<value>, and when that memory is freed, the bytes of the region are "
"initialized to the byte specified in I<value>.  However, there is an "
"off-by-I<sizeof(size_t)> error in the implementation: instead of "
"initializing precisely the block of memory being freed by the call "
"I<free(p)>, the block starting at I<p+sizeof(size_t)> is initialized."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:475
msgid ""
"The program below demonstrates the use of B<M_CHECK_ACTION>.  If the program "
"is supplied with an (integer) command-line argument, then that argument is "
"used to set the B<M_CHECK_ACTION> parameter.  The program then allocates a "
"block of memory, and frees it twice (an error)."
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:479
msgid ""
"The following shell session shows what happens when we run this program "
"under glibc, with the default value for B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:499
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09d30008 "
"***\n"
"======= Backtrace: =========\n"
"/lib/libc.so.6(+0x6c501)[0x523501]\n"
"/lib/libc.so.6(+0x6dd70)[0x524d70]\n"
"/lib/libc.so.6(cfree+0x6d)[0x527e5d]\n"
"\\&./a.out[0x80485db]\n"
"/lib/libc.so.6(__libc_start_main+0xe7)[0x4cdce7]\n"
"\\&./a.out[0x8048471]\n"
"======= Memory map: ========\n"
"001e4000-001fe000 r-xp 00000000 08:06 1083555    /lib/libgcc_s.so.1\n"
"001fe000-001ff000 r--p 00019000 08:06 1083555    /lib/libgcc_s.so.1\n"
"[some lines omitted]\n"
"b7814000-b7817000 rw-p 00000000 00:00 0\n"
"bff53000-bff74000 rw-p 00000000 00:00 0          [stack]\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:504
msgid ""
"The following runs show the results when employing other values for "
"B<M_CHECK_ACTION>:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:517
#, no-wrap
msgid ""
"$ B<./a.out 1>             # Diagnose error and continue\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: double free or corruption (top): 0x09cbe008 "
"***\n"
"main(): returned from second free() call\n"
"$ B<./a.out 2>             # Abort without error message\n"
"main(): returned from first free() call\n"
"Aborted (core dumped)\n"
"$ B<./a.out 0>             # Ignore error and continue\n"
"main(): returned from first free() call\n"
"main(): returned from second free() call\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:523
msgid ""
"The next run shows how to set the same parameter using the B<MALLOC_CHECK_> "
"environment variable:"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:530
#, no-wrap
msgid ""
"$ B<MALLOC_CHECK_=1 ./a.out>\n"
"main(): returned from first free() call\n"
"*** glibc detected *** ./a.out: free(): invalid pointer: 0x092c2008 ***\n"
"main(): returned from second free() call\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:538
#, no-wrap
msgid ""
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:543 build/C/man3/mcheck.3:187
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:550
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (mallopt(M_CHECK_ACTION, atoi(argv[1])) != 1) {\n"
"            fprintf(stderr, \"mallopt() failed\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:556
#, no-wrap
msgid ""
"    p = malloc(1000);\n"
"    if (p == NULL) {\n"
"        fprintf(stderr, \"malloc() failed\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:559
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from first free() call\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:562
#, no-wrap
msgid ""
"    free(p);\n"
"    printf(\"main(): returned from second free() call\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mallopt.3:580
msgid ""
"B<mmap>(2), B<sbrk>(2), B<mallinfo>(3), B<malloc>(3), B<malloc_hook>(3), "
"B<malloc_info>(3), B<malloc_stats>(3), B<malloc_trim>(3), B<mcheck>(3), "
"B<mtrace>(3), B<posix_memalign>(3)"
msgstr ""

#. type: TH
#: build/C/man3/mcheck.3:25
#, no-wrap
msgid "MCHECK"
msgstr ""

#. type: TH
#: build/C/man3/mcheck.3:25 build/C/man3/mtrace.3:25
#, no-wrap
msgid "2012-04-18"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:28
msgid ""
"mcheck, mcheck_check_all, mcheck_pedantic, mprobe - heap consistency "
"checking"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:31
#, no-wrap
msgid "B<#include E<lt>mcheck.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:33
#, no-wrap
msgid "B<int mcheck(void (*>I<abortfunc>B<)(enum mcheck_status >I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:35
#, no-wrap
msgid ""
"B<int mcheck_pedantic(void (*>I<abortfunc>B<)(enum mcheck_status "
">I<mstatus>B<));>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:37
#, no-wrap
msgid "B<void mcheck_check_all(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:39
#, no-wrap
msgid "B<enum mcheck_status mprobe(void *>I<ptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:51
msgid ""
"The B<mcheck>()  function installs a set of debugging hooks for the "
"B<malloc>(3)  family of memory-allocation functions.  These hooks cause "
"certain consistency checks to be performed on the state of the heap.  The "
"checks can detect application errors such as freeing a block of memory more "
"than once or corrupting the bookkeeping data structures that immediately "
"precede a block of allocated memory."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:63
msgid ""
"To be effective, the B<mcheck>()  function must be called before the first "
"call to B<malloc>(3)  or a related function.  In cases where this is "
"difficult to ensure, linking the program with I<-mcheck> inserts an implicit "
"call to B<mcheck>()  (with a NULL argument)  before the first call to a "
"memory-allocation function."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:71
msgid ""
"The B<mcheck_pedantic>()  function is similar to B<mcheck>(), but performs "
"checks on all allocated blocks whenever one of the memory-allocation "
"functions is called.  This can be very slow!"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:78
msgid ""
"The B<mcheck_check_all>()  function causes an immediate check on all "
"allocated blocks.  This call is effective only if B<mcheck>()  is called "
"beforehand."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:91
msgid ""
"If the system detects an inconsistency in the heap, the caller-supplied "
"function pointed to by I<abortfunc> is invoked with a single argument "
"argument, I<mstatus>, that indicates what type of inconsistency was "
"detected.  If I<abortfunc> is NULL, a default function prints an error "
"message on I<stderr> and calls B<abort>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:103
msgid ""
"The B<mprobe>()  function performs a consistency check on the block of "
"allocated memory pointed to by I<ptr>.  The B<mcheck>()  function should be "
"called beforehand (otherwise B<mprobe>()  returns B<MCHECK_DISABLED>)."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:111
msgid ""
"The following list describes the values returned by B<mprobe>()  or passed "
"as the I<mstatus> argument when I<abortfunc> is invoked:"
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:111
#, no-wrap
msgid "B<MCHECK_DISABLED> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:116
msgid ""
"B<mcheck>()  was not called before the first memory allocation function was "
"called.  Consistency checking is not possible."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:116
#, no-wrap
msgid "B<MCHECK_OK> (B<mprobe>() only)"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:119
msgid "No inconsistency detected."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:119
#, no-wrap
msgid "B<MCHECK_HEAD>"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:122
msgid "Memory preceding an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:122
#, no-wrap
msgid "B<MCHECK_TAIL>"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:125
msgid "Memory following an allocated block was clobbered."
msgstr ""

#. type: TP
#: build/C/man3/mcheck.3:125
#, no-wrap
msgid "B<MCHECK_FREE>"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:129
msgid "A block of memory was freed twice."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:134
msgid "B<mcheck>()  and B<mcheck_pedantic>()  return 0 on success, or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:145
msgid ""
"The B<mcheck_pedantic>()  and B<mcheck_check_all>()  functions are available "
"since glibc 2.2.  The B<mcheck>()  and B<mprobe>()  functions are present "
"since at least glibc 2.0"
msgstr ""

#.  But is MALLOC_CHECK_ slower?
#. type: Plain text
#: build/C/man3/mcheck.3:159
msgid ""
"Linking a program with I<-lmcheck> and using the B<MALLOC_CHECK_> "
"environment variable (described in B<mallopt>(3))  cause the same kinds of "
"errors to be detected.  But, using B<MALLOC_CHECK_> does not require the "
"application to be relinked."
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:165
msgid ""
"The program below calls B<mcheck>()  with a NULL argument and then frees the "
"same block of memory twice.  The following shell session demonstrates what "
"happens when running the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:170
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"About to free\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:174
#, no-wrap
msgid ""
"About to free a second time\n"
"block freed twice\n"
"Aborted (core dumped)\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:182
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>mcheck.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:190
#, no-wrap
msgid ""
"    if (mcheck(NULL) != 0) {\n"
"        fprintf(stderr, \"mcheck() failed\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:193
#, no-wrap
msgid ""
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:195
#, no-wrap
msgid "    p = malloc(1000);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:200
#, no-wrap
msgid ""
"    fprintf(stderr, \"About to free\\en\");\n"
"    free(p);\n"
"    fprintf(stderr, \"\\enAbout to free a second time\\en\");\n"
"    free(p);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mcheck.3:208
msgid "B<malloc>(3), B<mallopt>(3), B<mtrace>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mlock.2:26
#, no-wrap
msgid "MLOCK"
msgstr ""

#. type: TH
#: build/C/man2/mlock.2:26
#, no-wrap
msgid "2011-09-14"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:29
msgid "mlock, munlock, mlockall, munlockall - lock and unlock memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:32 build/C/man2/mmap.2:46 build/C/man2/mmap2.2:35 build/C/man2/mprotect.2:44 build/C/man2/mremap.2:38
#, no-wrap
msgid "B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:35
#, no-wrap
msgid ""
"B<int mlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
"B<int munlock(const void *>I<addr>B<, size_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:38
#, no-wrap
msgid ""
"B<int mlockall(int >I<flags>B<);>\n"
"B<int munlockall(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:54
msgid ""
"B<mlock>()  and B<mlockall>()  respectively lock part or all of the calling "
"process's virtual address space into RAM, preventing that memory from being "
"paged to the swap area.  B<munlock>()  and B<munlockall>()  perform the "
"converse operation, respectively unlocking part or all of the calling "
"process's virtual address space, so that pages in the specified virtual "
"address range may once more to be swapped out if required by the kernel "
"memory manager.  Memory locking and unlocking are performed in units of "
"whole pages."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:54
#, no-wrap
msgid "mlock() and munlock()"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:64
msgid ""
"B<mlock>()  locks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  All pages that contain a part of the specified "
"address range are guaranteed to be resident in RAM when the call returns "
"successfully; the pages are guaranteed to stay in RAM until later unlocked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:73
msgid ""
"B<munlock>()  unlocks pages in the address range starting at I<addr> and "
"continuing for I<len> bytes.  After this call, all pages that contain a part "
"of the specified memory range can be moved to external swap space again by "
"the kernel."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:73
#, no-wrap
msgid "mlockall() and munlockall()"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:83
msgid ""
"B<mlockall>()  locks all pages mapped into the address space of the calling "
"process.  This includes the pages of the code, data and stack segment, as "
"well as shared libraries, user space kernel data, shared memory, and "
"memory-mapped files.  All mapped pages are guaranteed to be resident in RAM "
"when the call returns successfully; the pages are guaranteed to stay in RAM "
"until later unlocked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:88
msgid ""
"The I<flags> argument is constructed as the bitwise OR of one or more of the "
"following constants:"
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:88
#, no-wrap
msgid "B<MCL_CURRENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:92
msgid ""
"Lock all pages which are currently mapped into the address space of the "
"process."
msgstr ""

#. type: TP
#: build/C/man2/mlock.2:92
#, no-wrap
msgid "B<MCL_FUTURE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:99
msgid ""
"Lock all pages which will become mapped into the address space of the "
"process in the future.  These could be for instance new pages required by a "
"growing heap and stack as well as new memory mapped files or shared memory "
"regions."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:112
msgid ""
"If B<MCL_FUTURE> has been specified, then a later system call (e.g., "
"B<mmap>(2), B<sbrk>(2), B<malloc>(3)), may fail if it would cause the number "
"of locked bytes to exceed the permitted maximum (see below).  In the same "
"circumstances, stack growth may likewise fail: the kernel will deny stack "
"expansion and deliver a B<SIGSEGV> signal to the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:116
msgid ""
"B<munlockall>()  unlocks all pages mapped into the address space of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:122
msgid ""
"On success these system calls return 0.  On error, -1 is returned, I<errno> "
"is set appropriately, and no changes are made to any locks in the address "
"space of the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:131
msgid ""
"(Linux 2.6.9 and later) the caller had a nonzero B<RLIMIT_MEMLOCK> soft "
"resource limit, but tried to lock more memory than the limit permitted.  "
"This limit is not enforced if the process is privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#.  In the case of mlock(), this check is somewhat buggy: it doesn't
#.  take into account whether the to-be-locked range overlaps with
#.  already locked pages.  Thus, suppose we allocate
#.  (num_physpages / 4 + 1) of memory, and lock those pages once using
#.  mlock(), and then lock the *same* page range a second time.
#.  In the case, the second mlock() call will fail, since the check
#.  calculates that the process is trying to lock (num_physpages / 2 + 2)
#.  pages, which of course is not true.  (MTK, Nov 04, kernel 2.4.28)
#. type: Plain text
#: build/C/man2/mlock.2:143
msgid ""
"(Linux 2.4 and earlier) the calling process tried to lock more than half of "
"RAM."
msgstr ""

#. SVr4 documents an additional EAGAIN error code.
#. type: Plain text
#: build/C/man2/mlock.2:149
msgid ""
"The caller is not privileged, but needs privilege (B<CAP_IPC_LOCK>)  to "
"perform the requested operation."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:154
msgid "For B<mlock>()  and B<munlock>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:157
msgid "Some or all of the specified address range could not be locked."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:164
msgid ""
"The result of the addition I<start>+I<len> was less than I<start> (e.g., the "
"addition may have resulted in an overflow)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:169
msgid "(Not on Linux)  I<addr> was not a multiple of the page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:173
msgid ""
"Some of the specified address range does not correspond to mapped pages in "
"the address space of the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:176
msgid "For B<mlockall>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:179
msgid "Unknown I<flags> were specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:182
msgid "For B<munlockall>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:186
msgid "(Linux 2.6.8 and earlier) The caller was not privileged (B<CAP_IPC_LOCK>)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:188
msgid "POSIX.1-2001, SVr4."
msgstr ""

#. type: SH
#: build/C/man2/mlock.2:188 build/C/man2/mmap.2:501 build/C/man2/msync.2:105
#, no-wrap
msgid "AVAILABILITY"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:200
msgid ""
"On POSIX systems on which B<mlock>()  and B<munlock>()  are available, "
"B<_POSIX_MEMLOCK_RANGE> is defined in I<E<lt>unistd.hE<gt>> and the number "
"of bytes in a page can be determined from the constant B<PAGESIZE> (if "
"defined) in I<E<lt>limits.hE<gt>> or by calling I<sysconf(_SC_PAGESIZE)>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mlock.2:213
msgid ""
"On POSIX systems on which B<mlockall>()  and B<munlockall>()  are available, "
"B<_POSIX_MEMLOCK> is defined in I<E<lt>unistd.hE<gt>> to a value greater "
"than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:231
msgid ""
"Memory locking has two main applications: real-time algorithms and "
"high-security data processing.  Real-time applications require deterministic "
"timing, and, like scheduling, paging is one major cause of unexpected "
"program execution delays.  Real-time applications will usually also switch "
"to a real-time scheduler with B<sched_setscheduler>(2).  Cryptographic "
"security software often handles critical bytes like passwords or secret keys "
"as data structures.  As a result of paging, these secrets could be "
"transferred onto a persistent swap store medium, where they might be "
"accessible to the enemy long after the security software has erased the "
"secrets in RAM and terminated.  (But be aware that the suspend mode on "
"laptops and some desktop computers will save a copy of the system's RAM to "
"disk, regardless of memory locks.)"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:244
msgid ""
"Real-time processes that are using B<mlockall>()  to prevent delays on page "
"faults should reserve enough locked stack pages before entering the "
"time-critical section, so that no page fault can be caused by function "
"calls.  This can be achieved by calling a function that allocates a "
"sufficiently large automatic variable (an array) and writes to the memory "
"occupied by this array in order to touch these stack pages.  This way, "
"enough pages will be mapped for the stack and can be locked into RAM.  The "
"dummy writes ensure that not even copy-on-write page faults can occur in the "
"critical section."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:250
msgid ""
"Memory locks are not inherited by a child created via B<fork>(2)  and are "
"automatically removed (unlocked) during an B<execve>(2)  or when the process "
"terminates."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:254
msgid ""
"The memory lock on an address range is automatically removed if the address "
"range is unmapped via B<munmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:267
msgid ""
"Memory locks do not stack, that is, pages which have been locked several "
"times by calls to B<mlock>()  or B<mlockall>()  will be unlocked by a single "
"call to B<munlock>()  for the corresponding range or by B<munlockall>().  "
"Pages which are mapped to several locations or by several processes stay "
"locked into RAM as long as they are locked at least at one location or by at "
"least one process."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:278
msgid ""
"Under Linux, B<mlock>()  and B<munlock>()  automatically round I<addr> down "
"to the nearest page boundary.  However, POSIX.1-2001 allows an "
"implementation to require that I<addr> is page aligned, so portable "
"applications should ensure this."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:291
msgid ""
"The I<VmLck> field of the Linux-specific I</proc/PID/status> file shows how "
"many kilobytes of memory the process with ID I<PID> has locked using "
"B<mlock>(), B<mlockall>(), and B<mmap>(2)  B<MAP_LOCKED>."
msgstr ""

#. type: SS
#: build/C/man2/mlock.2:291
#, no-wrap
msgid "Limits and permissions"
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:298
msgid ""
"In Linux 2.6.8 and earlier, a process must be privileged (B<CAP_IPC_LOCK>)  "
"in order to lock memory and the B<RLIMIT_MEMLOCK> soft resource limit "
"defines a limit on how much memory the process may lock."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:304
msgid ""
"Since Linux 2.6.9, no limits are placed on the amount of memory that a "
"privileged process can lock and the B<RLIMIT_MEMLOCK> soft resource limit "
"instead defines a limit on how much memory an unprivileged process may lock."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:312
msgid ""
"In the 2.4 series Linux kernels up to and including 2.4.17, a bug caused the "
"B<mlockall>()  B<MCL_FUTURE> flag to be inherited across a B<fork>(2).  This "
"was rectified in kernel 2.4.18."
msgstr ""

#.  See the following LKML thread:
#.  http://marc.theaimsgroup.com/?l=linux-kernel&m=113801392825023&w=2
#.  "Rationale for RLIMIT_MEMLOCK"
#.  23 Jan 2006
#. type: Plain text
#: build/C/man2/mlock.2:329
msgid ""
"Since kernel 2.6.9, if a privileged process calls I<mlockall(MCL_FUTURE)> "
"and later drops privileges (loses the B<CAP_IPC_LOCK> capability by, for "
"example, setting its effective UID to a nonzero value), then subsequent "
"memory allocations (e.g., B<mmap>(2), B<brk>(2))  will fail if the "
"B<RLIMIT_MEMLOCK> resource limit is encountered."
msgstr ""

#. type: Plain text
#: build/C/man2/mlock.2:336
msgid ""
"B<mmap>(2), B<setrlimit>(2), B<shmctl>(2), B<sysconf>(3), B<proc>(5), "
"B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "MMAP"
msgstr ""

#. type: TH
#: build/C/man2/mmap.2:40
#, no-wrap
msgid "2013-04-17"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:43
msgid "mmap, munmap - map or unmap files or devices into memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:51
#, no-wrap
msgid ""
"B<void *mmap(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<, int "
">I<flags>B<,>\n"
"B<           int >I<fd>B<, off_t >I<offset>B<);>\n"
"B<int munmap(void *>I<addr>B<, size_t >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:54
msgid "See NOTES for information on feature test macro requirements."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:63
msgid ""
"B<mmap>()  creates a new mapping in the virtual address space of the calling "
"process.  The starting address for the new mapping is specified in I<addr>.  "
"The I<length> argument specifies the length of the mapping."
msgstr ""

#.  Before Linux 2.6.24, the address was rounded up to the next page
#.  boundary; since 2.6.24, it is rounded down!
#. type: Plain text
#: build/C/man2/mmap.2:77
msgid ""
"If I<addr> is NULL, then the kernel chooses the address at which to create "
"the mapping; this is the most portable method of creating a new mapping.  If "
"I<addr> is not NULL, then the kernel takes it as a hint about where to place "
"the mapping; on Linux, the mapping will be created at a nearby page "
"boundary.  The address of the new mapping is returned as the result of the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:89
msgid ""
"The contents of a file mapping (as opposed to an anonymous mapping; see "
"B<MAP_ANONYMOUS> below), are initialized using I<length> bytes starting at "
"offset I<offset> in the file (or other object) referred to by the file "
"descriptor I<fd>.  I<offset> must be a multiple of the page size as returned "
"by I<sysconf(_SC_PAGE_SIZE)>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:97
msgid ""
"The I<prot> argument describes the desired memory protection of the mapping "
"(and must not conflict with the open mode of the file).  It is either "
"B<PROT_NONE> or the bitwise OR of one or more of the following flags:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:97 build/C/man2/mprotect.2:73
#, no-wrap
msgid "B<PROT_EXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:100
msgid "Pages may be executed."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:100 build/C/man2/mprotect.2:67
#, no-wrap
msgid "B<PROT_READ>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:103
msgid "Pages may be read."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:103 build/C/man2/mprotect.2:70
#, no-wrap
msgid "B<PROT_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:106
msgid "Pages may be written."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:106 build/C/man2/mprotect.2:64
#, no-wrap
msgid "B<PROT_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:109
msgid "Pages may not be accessed."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:118
msgid ""
"The I<flags> argument determines whether updates to the mapping are visible "
"to other processes mapping the same region, and whether updates are carried "
"through to the underlying file.  This behavior is determined by including "
"exactly one of the following values in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:118
#, no-wrap
msgid "B<MAP_SHARED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:128
msgid ""
"Share this mapping.  Updates to the mapping are visible to other processes "
"that map this file, and are carried through to the underlying file.  The "
"file may not actually be updated until B<msync>(2)  or B<munmap>()  is "
"called."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:128
#, no-wrap
msgid "B<MAP_PRIVATE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:137
msgid ""
"Create a private copy-on-write mapping.  Updates to the mapping are not "
"visible to other processes mapping the same file, and are not carried "
"through to the underlying file.  It is unspecified whether changes made to "
"the file after the B<mmap>()  call are visible in the mapped region."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:139
msgid "Both of these flags are described in POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:142
msgid "In addition, zero or more of the following values can be ORed in I<flags>:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:142
#, no-wrap
msgid "B<MAP_32BIT> (since Linux 2.4.20, 2.6)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#. type: Plain text
#: build/C/man2/mmap.2:158
msgid ""
"Put the mapping into the first 2 Gigabytes of the process address space.  "
"This flag is supported only on x86-64, for 64-bit programs.  It was added to "
"allow thread stacks to be allocated somewhere in the first 2GB of memory, so "
"as to improve context-switch performance on some early 64-bit processors.  "
"Modern x86-64 processors no longer have this performance problem, so use of "
"this flag is not required on those systems.  The B<MAP_32BIT> flag is "
"ignored when B<MAP_FIXED> is set."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:158
#, no-wrap
msgid "B<MAP_ANON>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:163
msgid "Synonym for B<MAP_ANONYMOUS>.  Deprecated."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:163
#, no-wrap
msgid "B<MAP_ANONYMOUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:185
msgid ""
"The mapping is not backed by any file; its contents are initialized to "
"zero.  The I<fd> and I<offset> arguments are ignored; however, some "
"implementations require I<fd> to be -1 if B<MAP_ANONYMOUS> (or B<MAP_ANON>)  "
"is specified, and portable applications should ensure this.  The use of "
"B<MAP_ANONYMOUS> in conjunction with B<MAP_SHARED> is supported on Linux "
"only since kernel 2.4."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:185
#, no-wrap
msgid "B<MAP_DENYWRITE>"
msgstr ""

#.  Introduced in 1.1.36, removed in 1.3.24.
#. type: Plain text
#: build/C/man2/mmap.2:193
msgid ""
"This flag is ignored.  (Long ago, it signaled that attempts to write to the "
"underlying file should fail with B<ETXTBUSY>.  But this was a source of "
"denial-of-service attacks.)"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:193
#, no-wrap
msgid "B<MAP_EXECUTABLE>"
msgstr ""

#.  Introduced in 1.1.38, removed in 1.3.24. Flag tested in proc_follow_link.
#.  (Long ago, it signaled that the underlying file is an executable.
#.  However, that information was not really used anywhere.)
#.  Linus talked about DOS related to MAP_EXECUTABLE, but he was thinking of
#.  MAP_DENYWRITE?
#. type: Plain text
#: build/C/man2/mmap.2:201
msgid "This flag is ignored."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:201
#, no-wrap
msgid "B<MAP_FILE>"
msgstr ""

#.  On some systems, this was required as the opposite of
#.  MAP_ANONYMOUS -- mtk, 1 May 2007
#. type: Plain text
#: build/C/man2/mmap.2:207
msgid "Compatibility flag.  Ignored."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:207
#, no-wrap
msgid "B<MAP_FIXED>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:225
msgid ""
"Don't interpret I<addr> as a hint: place the mapping at exactly that "
"address.  I<addr> must be a multiple of the page size.  If the memory region "
"specified by I<addr> and I<len> overlaps pages of any existing mapping(s), "
"then the overlapped part of the existing mapping(s) will be discarded.  If "
"the specified address cannot be used, B<mmap>()  will fail.  Because "
"requiring a fixed address for a mapping is less portable, the use of this "
"option is discouraged."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:225
#, no-wrap
msgid "B<MAP_GROWSDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:230
msgid ""
"Used for stacks.  Indicates to the kernel virtual memory system that the "
"mapping should extend downward in memory."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:230
#, no-wrap
msgid "B<MAP_HUGETLB> (since Linux 2.6.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:236
msgid ""
"Allocate the mapping using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:236
#, no-wrap
msgid "B<MAP_LOCKED> (since Linux 2.5.37)"
msgstr ""

#.  If set, the mapped pages will not be swapped out.
#. type: Plain text
#: build/C/man2/mmap.2:242
msgid ""
"Lock the pages of the mapped region into memory in the manner of "
"B<mlock>(2).  This flag is ignored in older kernels."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:242
#, no-wrap
msgid "B<MAP_NONBLOCK> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:257
msgid ""
"Only meaningful in conjunction with B<MAP_POPULATE>.  Don't perform "
"read-ahead: create page tables entries only for pages that are already "
"present in RAM.  Since Linux 2.6.23, this flag causes B<MAP_POPULATE> to do "
"nothing.  One day the combination of B<MAP_POPULATE> and B<MAP_NONBLOCK> may "
"be reimplemented."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:257
#, no-wrap
msgid "B<MAP_NORESERVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:272
msgid ""
"Do not reserve swap space for this mapping.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the mapping.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5).  In kernels before 2.6, "
"this flag had effect only for private writable mappings."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:272
#, no-wrap
msgid "B<MAP_POPULATE> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:279
msgid ""
"Populate (prefault) page tables for a mapping.  For a file mapping, this "
"causes read-ahead on the file.  Later accesses to the mapping will not be "
"blocked by page faults.  B<MAP_POPULATE> is supported for private mappings "
"only since Linux 2.6.23."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:279
#, no-wrap
msgid "B<MAP_STACK> (since Linux 2.6.27)"
msgstr ""

#.  See http://lwn.net/Articles/294642 "Tangled up in threads", 19 Aug 08
#.  commit cd98a04a59e2f94fa64d5bf1e26498d27427d5e7
#.  http://thread.gmane.org/gmane.linux.kernel/720412
#.  "pthread_create() slow for many threads; also time to revisit 64b
#.   context switch optimization?"
#. type: Plain text
#: build/C/man2/mmap.2:292
msgid ""
"Allocate the mapping at an address suitable for a process or thread stack.  "
"This flag is currently a no-op, but is used in the glibc threading "
"implementation so that if some architectures require special treatment for "
"stack allocations, support can later be transparently implemented for glibc."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:292
#, no-wrap
msgid "B<MAP_UNINITIALIZED> (since Linux 2.6.33)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:302
msgid ""
"Don't clear anonymous pages.  This flag is intended to improve performance "
"on embedded devices.  This flag is honored only if the kernel was configured "
"with the B<CONFIG_MMAP_ALLOW_UNINITIALIZED> option.  Because of the security "
"implications, that option is normally enabled only on embedded devices "
"(i.e., devices where one has complete control of the contents of user "
"memory)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:310
msgid ""
"Of the above flags, only B<MAP_FIXED> is specified in POSIX.1-2001.  "
"However, most systems also support B<MAP_ANONYMOUS> (or its synonym "
"B<MAP_ANON>)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:317
msgid ""
"Some systems document the additional flags B<MAP_AUTOGROW>, "
"B<MAP_AUTORESRV>, B<MAP_COPY>, and B<MAP_LOCAL>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:323
msgid ""
"Memory mapped by B<mmap>()  is preserved across B<fork>(2), with the same "
"attributes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:331
msgid ""
"A file is mapped in multiples of the page size.  For a file that is not a "
"multiple of the page size, the remaining memory is zeroed when mapped, and "
"writes to that region are not written out to the file.  The effect of "
"changing the size of the underlying file of a mapping on the pages that "
"correspond to added or removed regions of the file is unspecified."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:331
#, no-wrap
msgid "munmap()"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:341
msgid ""
"The B<munmap>()  system call deletes the mappings for the specified address "
"range, and causes further references to addresses within the range to "
"generate invalid memory references.  The region is also automatically "
"unmapped when the process is terminated.  On the other hand, closing the "
"file descriptor does not unmap the region."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:351
msgid ""
"The address I<addr> must be a multiple of the page size.  All pages "
"containing a part of the indicated range are unmapped, and subsequent "
"references to these pages will generate B<SIGSEGV>.  It is not an error if "
"the indicated range does not contain any mapped pages."
msgstr ""

#. type: SS
#: build/C/man2/mmap.2:351
#, no-wrap
msgid "Timestamps changes for file-backed mappings"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:358
msgid ""
"For file-backed mappings, the I<st_atime> field for the mapped file may be "
"updated at any time between the B<mmap>()  and the corresponding unmapping; "
"the first reference to a mapped page will update the field if it has not "
"been already."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:375
msgid ""
"The I<st_ctime> and I<st_mtime> field for a file mapped with B<PROT_WRITE> "
"and B<MAP_SHARED> will be updated after a write to the mapped region, and "
"before a subsequent B<msync>(2)  with the B<MS_SYNC> or B<MS_ASYNC> flag, if "
"one occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:392
msgid ""
"On success, B<mmap>()  returns a pointer to the mapped area.  On error, the "
"value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>)  is returned, and I<errno> "
"is set appropriately.  On success, B<munmap>()  returns 0, on failure -1, "
"and I<errno> is set (probably to B<EINVAL>)."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:393 build/C/man2/mprotect.2:86 build/C/man3/shm_open.3:187 build/C/man3/shm_open.3:192 build/C/man2/shmctl.2:302 build/C/man2/shmget.2:189 build/C/man2/shmop.2:191
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:413
msgid ""
"A file descriptor refers to a non-regular file.  Or B<MAP_PRIVATE> was "
"requested, but I<fd> is not open for reading.  Or B<MAP_SHARED> was "
"requested and B<PROT_WRITE> is set, but I<fd> is not open in read/write "
"(B<O_RDWR>)  mode.  Or B<PROT_WRITE> is set, but the file is append-only."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:417
msgid ""
"The file has been locked, or too much memory has been locked (see "
"B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:423
msgid "I<fd> is not a valid file descriptor (and B<MAP_ANONYMOUS> was not set)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:431
msgid ""
"We don't like I<addr>, I<length>, or I<offset> (e.g., they are too large, or "
"not aligned on a page boundary)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:436
msgid "(since Linux 2.6.12)  I<length> was 0."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:444
msgid ""
"I<flags> contained neither B<MAP_PRIVATE> or B<MAP_SHARED>, or contained "
"both of these values."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:444 build/C/man3/shm_open.3:229 build/C/man2/shmget.2:205
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#.  [2.6.7] shmem_zero_setup()-->shmem_file_setup()-->get_empty_filp()
#. type: Plain text
#: build/C/man2/mmap.2:452 build/C/man2/shmget.2:209
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:456
msgid ""
"The underlying file system of the specified file does not support memory "
"mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:460
msgid ""
"No memory is available, or the process's maximum number of mappings would "
"have been exceeded."
msgstr ""

#.  (Since 2.4.25 / 2.6.0.)
#. type: Plain text
#: build/C/man2/mmap.2:469
msgid ""
"The I<prot> argument asks for B<PROT_EXEC> but the mapped area belongs to a "
"file on a file system that was mounted no-exec."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:469
#, no-wrap
msgid "B<ETXTBSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:475
msgid ""
"B<MAP_DENYWRITE> was set but the object specified by I<fd> is open for "
"writing."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:475 build/C/man2/shmctl.2:344
#, no-wrap
msgid "B<EOVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:487
msgid ""
"On 32-bit architecture together with the large file extension (i.e., using "
"64-bit I<off_t>): the number of pages used for I<length> plus number of "
"pages used for I<offset> would overflow I<unsigned long> (32 bits)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:489
msgid "Use of a mapped region can result in these signals:"
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:489
#, no-wrap
msgid "B<SIGSEGV>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:492
msgid "Attempted write into a region mapped as read-only."
msgstr ""

#. type: TP
#: build/C/man2/mmap.2:492
#, no-wrap
msgid "B<SIGBUS>"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:497
msgid ""
"Attempted access to a portion of the buffer that does not correspond to the "
"file (for example, beyond the end of the file, including the case where "
"another process has truncated the file)."
msgstr ""

#.  SVr4 documents additional error codes ENXIO and ENODEV.
#.  SUSv2 documents additional error codes EMFILE and EOVERFLOW.
#. type: Plain text
#: build/C/man2/mmap.2:501
msgid "SVr4, 4.4BSD, POSIX.1-2001."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines it to 1.
#. type: Plain text
#: build/C/man2/mmap.2:515
msgid ""
"On POSIX systems on which B<mmap>(), B<msync>(2)  and B<munmap>()  are "
"available, B<_POSIX_MAPPED_FILES> is defined in I<E<lt>unistd.hE<gt>> to a "
"value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#.  Since around glibc 2.1/2.2, depending on the platform.
#. type: Plain text
#: build/C/man2/mmap.2:530
msgid ""
"This page describes the interface provided by the glibc B<mmap>()  wrapper "
"function.  Originally, this function invoked a system call of the same "
"name.  Since kernel 2.4, that system call has been superseded by "
"B<mmap2>(2), and nowadays the glibc B<mmap>()  wrapper function invokes "
"B<mmap2>(2)  with a suitably adjusted value for I<offset>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:543
msgid ""
"On some hardware architectures (e.g., i386), B<PROT_WRITE> implies "
"B<PROT_READ>.  It is architecture dependent whether B<PROT_READ> implies "
"B<PROT_EXEC> or not.  Portable programs should always set B<PROT_EXEC> if "
"they intend to execute code in the new mapping."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:558
msgid ""
"The portable way to create a mapping is to specify I<addr> as 0 (NULL), and "
"omit B<MAP_FIXED> from I<flags>.  In this case, the system chooses the "
"address for the mapping; the address is chosen so as not to conflict with "
"any existing mapping, and will not be 0.  If the B<MAP_FIXED> flag is "
"specified, and I<addr> is 0 (NULL), then the mapped address will be 0 "
"(NULL)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:587
msgid ""
"Certain I<flags> constants are defined only if either B<_BSD_SOURCE> or "
"B<_SVID_SOURCE> is defined.  (Requiring B<_GNU_SOURCE> also suffices, and "
"requiring that macro specifically would have been more logical, since these "
"flags are all Linux specific.)  The relevant flags are: B<MAP_32BIT>, "
"B<MAP_ANONYMOUS> (and the synonym B<MAP_ANON>), B<MAP_DENYWRITE>, "
"B<MAP_EXECUTABLE>, B<MAP_FILE>, B<MAP_GROWSDOWN>, B<MAP_HUGETLB>, "
"B<MAP_LOCKED>, B<MAP_NONBLOCK>, B<MAP_NORESERVE>, B<MAP_POPULATE>, and "
"B<MAP_STACK>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:592
msgid ""
"On Linux there are no guarantees like those suggested above under "
"B<MAP_NORESERVE>.  By default, any process can be killed at any moment when "
"the system runs out of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:599
msgid ""
"In kernels before 2.6.7, the B<MAP_POPULATE> flag has effect only if I<prot> "
"is specified as B<PROT_NONE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:614
msgid ""
"SUSv3 specifies that B<mmap>()  should fail if I<length> is 0.  However, in "
"kernels before 2.6.12, B<mmap>()  succeeded in this case: no mapping was "
"created and the call returned I<addr>.  Since kernel 2.6.12, B<mmap>()  "
"fails with the error B<EINVAL> for this case."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:630
msgid ""
"POSIX specifies that the system shall always zero fill any partial page at "
"the end of the object and that system will never write any modification of "
"the object beyond its end.  On Linux, when you write data to such partial "
"page after the end of the object, the data stays in the page cache even "
"after the file is closed and unmapped and even though the data is never "
"written to the file itself, subsequent mappings may see the modified "
"content.  In some cases, this could be fixed by calling B<msync>(2)  before "
"the unmap takes place; however, this doesn't work on tmpfs (for example, "
"when using POSIX shared memory interface documented in B<shm_overview>(7))."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:642
msgid ""
"The following program prints part of the file specified in its first "
"command-line argument to standard output.  The range of bytes to be printed "
"is specified via offset and length values in the second and third "
"command-line arguments.  The program creates a memory mapping of the "
"required pages of the file and then uses B<write>(2)  to output the desired "
"bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:650
#, no-wrap
msgid ""
"#include E<lt>sys/mman.hE<gt>\n"
"#include E<lt>sys/stat.hE<gt>\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:653 build/C/man2/mprotect.2:178
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:663
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *addr;\n"
"    int fd;\n"
"    struct stat sb;\n"
"    off_t offset, pa_offset;\n"
"    size_t length;\n"
"    ssize_t s;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:668
#, no-wrap
msgid ""
"    if (argc E<lt> 3 || argc E<gt> 4) {\n"
"        fprintf(stderr, \"%s file offset [length]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:672
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);\n"
"    if (fd == -1)\n"
"        handle_error(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:675
#, no-wrap
msgid ""
"    if (fstat(fd, &sb) == -1)           /* To obtain file size */\n"
"        handle_error(\"fstat\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:679
#, no-wrap
msgid ""
"    offset = atoi(argv[2]);\n"
"    pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);\n"
"        /* offset for mmap() must be page aligned */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:684
#, no-wrap
msgid ""
"    if (offset E<gt>= sb.st_size) {\n"
"        fprintf(stderr, \"offset is past end of file\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:690
#, no-wrap
msgid ""
"    if (argc == 4) {\n"
"        length = atoi(argv[3]);\n"
"        if (offset + length E<gt> sb.st_size)\n"
"            length = sb.st_size - offset;\n"
"                /* Can\\(aqt display bytes past end of file */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:694
#, no-wrap
msgid ""
"    } else {    /* No length arg ==E<gt> display to end of file */\n"
"        length = sb.st_size - offset;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:699
#, no-wrap
msgid ""
"    addr = mmap(NULL, length + offset - pa_offset, PROT_READ,\n"
"                MAP_PRIVATE, fd, pa_offset);\n"
"    if (addr == MAP_FAILED)\n"
"        handle_error(\"mmap\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:704
#, no-wrap
msgid ""
"    s = write(STDOUT_FILENO, addr + offset - pa_offset, length);\n"
"    if (s != length) {\n"
"        if (s == -1)\n"
"            handle_error(\"write\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:708
#, no-wrap
msgid ""
"        fprintf(stderr, \"partial write\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:725
msgid ""
"B<getpagesize>(2), B<mincore>(2), B<mlock>(2), B<mmap2>(2), B<mprotect>(2), "
"B<mremap>(2), B<msync>(2), B<remap_file_pages>(2), B<setrlimit>(2), "
"B<shmat>(2), B<shm_open>(3), B<shm_overview>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:732
msgid ""
"The descriptions of the following files in B<proc>(5): I</proc/[pid]/maps>, "
"I</proc/[pid]/map_files>, and I</proc/[pid]/smaps>."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap.2:737 build/C/man2/msync.2:124
msgid "B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391."
msgstr ""

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "MMAP2"
msgstr ""

#. type: TH
#: build/C/man2/mmap2.2:29
#, no-wrap
msgid "2012-04-16"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:32
msgid "mmap2 - map files or devices into memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:38
#, no-wrap
msgid ""
"B<void *mmap2(void *>I<addr>B<, size_t >I<length>B<, int >I<prot>B<,>\n"
"B<             int >I<flags>B<, int >I<fd>B<, off_t >I<pgoffset>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:43
msgid ""
"This is probably not the system call you are interested; instead, see "
"B<mmap>(2), which describes the glibc wrapper function that invokes this "
"system call."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:54
msgid ""
"The B<mmap2>()  system call provides the same interface as B<mmap>(2), "
"except that the final argument specifies the offset into the file in "
"4096-byte units (instead of bytes, as is done by B<mmap>(2)).  This enables "
"applications that use a 32-bit I<off_t> to map large files (up to 2^44 "
"bytes)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:61
msgid ""
"On success, B<mmap2>()  returns a pointer to the mapped area.  On error -1 "
"is returned and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:65
msgid "Problem with getting the data from user space."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:70
msgid ""
"(Various platforms where the page size is not 4096 bytes.)  I<offset\\ *\\ "
"4096> is not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:74
msgid "B<mmap2>()  can also return any of the errors described in B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:77
msgid "B<mmap2>()  is available since Linux 2.3.31."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:79 build/C/man2/subpage_prot.2:98
msgid "This system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:85
msgid ""
"Nowadays, the glibc B<mmap>()  wrapper function invokes this system call "
"rather than the B<mmap>(2)  system call."
msgstr ""

#.  ia64 can have page sizes ranging from 4kB to 64kB.
#.  On cris, it looks like the unit might also be the page size,
#.  which is 8192 bytes. -- mtk, June 2007
#. type: Plain text
#: build/C/man2/mmap2.2:92
msgid ""
"On ia64, the unit for I<offset> is actually the system page size, rather "
"than 4096 bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mmap2.2:98
msgid "B<getpagesize>(2), B<mmap>(2), B<mremap>(2), B<msync>(2), B<shm_open>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mprotect.2:38
#, no-wrap
msgid "MPROTECT"
msgstr ""

#. type: TH
#: build/C/man2/mprotect.2:38
#, no-wrap
msgid "2012-08-14"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:41
msgid "mprotect - set protection on a region of memory"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:46
#, no-wrap
msgid "B<int mprotect(void *>I<addr>B<, size_t >I<len>B<, int >I<prot>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:54
msgid ""
"B<mprotect>()  changes protection for the calling process's memory page(s)  "
"containing any part of the address range in the interval [I<addr>,\\ "
"I<addr>+I<len>-1].  I<addr> must be aligned to a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:59
msgid ""
"If the calling process tries to access memory in a manner that violates the "
"protection, then the kernel generates a B<SIGSEGV> signal for the process."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:64
msgid ""
"I<prot> is either B<PROT_NONE> or a bitwise-or of the other values in the "
"following list:"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:67
msgid "The memory cannot be accessed at all."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:70
msgid "The memory can be read."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:73
msgid "The memory can be modified."
msgstr ""

#.  FIXME
#.  Document PROT_GROWSUP and PROT_GROWSDOWN
#. type: Plain text
#: build/C/man2/mprotect.2:78
msgid "The memory can be executed."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:85
msgid ""
"On success, B<mprotect>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:95
msgid ""
"The memory cannot be given the specified access.  This can happen, for "
"example, if you B<mmap>(2)  a file to which you have read-only access, then "
"ask B<mprotect>()  to mark it B<PROT_WRITE>."
msgstr ""

#.  Or: both PROT_GROWSUP and PROT_GROWSDOWN were specified in 'prot'.
#. type: Plain text
#: build/C/man2/mprotect.2:100
msgid "I<addr> is not a valid pointer, or not a multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:103
msgid "Internal kernel structures could not be allocated."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:113
msgid ""
"Addresses in the range [I<addr>, I<addr>+I<len>-1] are invalid for the "
"address space of the process, or specify one or more pages that are not "
"mapped.  (Before kernel 2.4.19, the error B<EFAULT> was incorrectly produced "
"for these cases.)"
msgstr ""

#.  SVr4 defines an additional error
#.  code EAGAIN. The SVr4 error conditions don't map neatly onto Linux's.
#. type: Plain text
#: build/C/man2/mprotect.2:122
msgid ""
"SVr4, POSIX.1-2001.  POSIX says that the behavior of B<mprotect>()  is "
"unspecified if it is applied to a region of memory that was not obtained via "
"B<mmap>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:129
msgid ""
"On Linux it is always permissible to call B<mprotect>()  on any address in a "
"process's address space (except for the kernel vsyscall area).  In "
"particular it can be used to change existing code mappings to be writable."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:139
msgid ""
"Whether B<PROT_EXEC> has any effect different from B<PROT_READ> is "
"architecture- and kernel version-dependent.  On some hardware architectures "
"(e.g., i386), B<PROT_WRITE> implies B<PROT_READ>."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:148
msgid ""
"POSIX.1-2001 says that an implementation may permit access other than that "
"specified in I<prot>, but at a minimum can allow write access only if "
"B<PROT_WRITE> has been set, and must not allow any access if B<PROT_NONE> "
"has been set."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:154
msgid ""
"The program below allocates four pages of memory, makes the third of these "
"pages read-only, and then executes a loop that walks upward through the "
"allocated region modifying bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:157
msgid "An example of what we might see when running the program is the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:163
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"Start of region:        0x804c000\n"
"Got SIGSEGV at address: 0x804e000\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:175
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>malloc.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>sys/mman.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:180
#, no-wrap
msgid "char *buffer;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:188
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *unused)\n"
"{\n"
"    printf(\"Got SIGSEGV at address: 0x%lx\\en\",\n"
"            (long) si-E<gt>si_addr);\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:195
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *p;\n"
"    int pagesize;\n"
"    struct sigaction sa;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:201
#, no-wrap
msgid ""
"    sa.sa_flags = SA_SIGINFO;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    sa.sa_sigaction = handler;\n"
"    if (sigaction(SIGSEGV, &sa, NULL) == -1)\n"
"        handle_error(\"sigaction\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:205
#, no-wrap
msgid ""
"    pagesize = sysconf(_SC_PAGE_SIZE);\n"
"    if (pagesize == -1)\n"
"        handle_error(\"sysconf\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:208
#, no-wrap
msgid ""
"    /* Allocate a buffer aligned on a page boundary;\n"
"       initial protection is PROT_READ | PROT_WRITE */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:212
#, no-wrap
msgid ""
"    buffer = memalign(pagesize, 4 * pagesize);\n"
"    if (buffer == NULL)\n"
"        handle_error(\"memalign\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:214
#, no-wrap
msgid "    printf(\"Start of region:        0x%lx\\en\", (long) buffer);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:218
#, no-wrap
msgid ""
"    if (mprotect(buffer + pagesize * 2, pagesize,\n"
"                PROT_READ) == -1)\n"
"        handle_error(\"mprotect\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:221
#, no-wrap
msgid ""
"    for (p = buffer ; ; )\n"
"        *(p++) = \\(aqa\\(aq;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:225
#, no-wrap
msgid ""
"    printf(\"Loop completed\\en\");     /* Should never happen */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mprotect.2:229
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr ""

#. type: TH
#: build/C/man2/mremap.2:30
#, no-wrap
msgid "MREMAP"
msgstr ""

#. type: TH
#: build/C/man2/mremap.2:30
#, no-wrap
msgid "2010-06-10"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:33
msgid "mremap - remap a virtual memory address"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:36
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:41
#, no-wrap
msgid ""
"B<void *mremap(void *>I<old_address>B<, size_t >I<old_size>B<,>\n"
"B<             size_t >I<new_size>B<, int >I<flags>B<, ... /* void "
"*>I<new_address>B< */);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:47
msgid ""
"B<mremap>()  expands (or shrinks) an existing memory mapping, potentially "
"moving it at the same time (controlled by the I<flags> argument and the "
"available virtual address space)."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:61
msgid ""
"I<old_address> is the old address of the virtual memory block that you want "
"to expand (or shrink).  Note that I<old_address> has to be page aligned.  "
"I<old_size> is the old size of the virtual memory block.  I<new_size> is the "
"requested size of the virtual memory block after the resize.  An optional "
"fifth argument, I<new_address>, may be provided; see the description of "
"B<MREMAP_FIXED> below."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:73
msgid ""
"In Linux the memory is divided into pages.  A user process has (one or)  "
"several linear virtual memory segments.  Each virtual memory segment has one "
"or more mappings to real memory pages (in the page table).  Each virtual "
"memory segment has its own protection (access rights), which may cause a "
"segmentation violation if the memory is accessed incorrectly (e.g., writing "
"to a read-only segment).  Accessing virtual memory outside of the segments "
"will also cause a segmentation violation."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:81
msgid ""
"B<mremap>()  uses the Linux page table scheme.  B<mremap>()  changes the "
"mapping between virtual addresses and memory pages.  This can be used to "
"implement a very efficient B<realloc>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:83
msgid "The I<flags> bit-mask argument may be 0, or include the following flag:"
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:83
#, no-wrap
msgid "B<MREMAP_MAYMOVE>"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:95
msgid ""
"By default, if there is not sufficient space to expand a mapping at its "
"current location, then B<mremap>()  fails.  If this flag is specified, then "
"the kernel is permitted to relocate the mapping to a new virtual address, if "
"necessary.  If the mapping is relocated, then absolute pointers into the old "
"mapping location become invalid (offsets relative to the starting address of "
"the mapping should be employed)."
msgstr ""

#. type: TP
#: build/C/man2/mremap.2:95
#, no-wrap
msgid "B<MREMAP_FIXED> (since Linux 2.3.31)"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:117
msgid ""
"This flag serves a similar purpose to the B<MAP_FIXED> flag of B<mmap>(2).  "
"If this flag is specified, then B<mremap>()  accepts a fifth argument, "
"I<void\\ *new_address>, which specifies a page-aligned address to which the "
"mapping must be moved.  Any previous mapping at the address range specified "
"by I<new_address> and I<new_size> is unmapped.  If B<MREMAP_FIXED> is "
"specified, then B<MREMAP_MAYMOVE> must also be specified."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:127
msgid ""
"If the memory segment specified by I<old_address> and I<old_size> is locked "
"(using B<mlock>(2)  or similar), then this lock is maintained when the "
"segment is resized and/or relocated.  As a consequence, the amount of memory "
"locked by the process may change."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:135
msgid ""
"On success B<mremap>()  returns a pointer to the new virtual memory area.  "
"On error, the value B<MAP_FAILED> (that is, I<(void\\ *)\\ -1>) is returned, "
"and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:142
msgid ""
"The caller tried to expand a memory segment that is locked, but this was not "
"possible without exceeding the B<RLIMIT_MEMLOCK> resource limit."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:151
msgid ""
"\"Segmentation fault.\" Some address in the range I<old_address> to "
"I<old_address>+I<old_size> is an invalid virtual memory address for this "
"process.  You can also get B<EFAULT> even if there exist mappings that cover "
"the whole address space requested, but those mappings are of different "
"types."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:179
msgid ""
"An invalid argument was given.  Possible causes are: I<old_address> was not "
"page aligned; a value other than B<MREMAP_MAYMOVE> or B<MREMAP_FIXED> was "
"specified in I<flags>; I<new_size> was zero; I<new_size> or I<new_address> "
"was invalid; or the new address range specified by I<new_address> and "
"I<new_size> overlapped the old address range specified by I<old_address> and "
"I<old_size>; or B<MREMAP_FIXED> was specified without also specifying "
"B<MREMAP_MAYMOVE>."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:185
msgid ""
"The memory area cannot be expanded at the current virtual address, and the "
"B<MREMAP_MAYMOVE> flag is not set in I<flags>.  Or, there is not enough "
"(virtual) memory available."
msgstr ""

#.  4.2BSD had a (never actually implemented)
#.  .BR mremap (2)
#.  call with completely different semantics.
#. type: Plain text
#: build/C/man2/mremap.2:191
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:199
msgid ""
"Prior to version 2.4, glibc did not expose the definition of "
"B<MREMAP_FIXED>, and the prototype for B<mremap>()  did not allow for the "
"I<new_address> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:208
msgid ""
"B<brk>(2), B<getpagesize>(2), B<getrlimit>(2), B<mlock>(2), B<mmap>(2), "
"B<sbrk>(2), B<malloc>(3), B<realloc>(3)"
msgstr ""

#. type: Plain text
#: build/C/man2/mremap.2:214
msgid ""
"Your favorite text book on operating systems for more information on paged "
"memory (e.g., I<Modern Operating Systems> by Andrew S. Tanenbaum, I<Inside "
"Linux> by Randolf Bentson, I<The Design of the UNIX Operating System> by "
"Maurice J. Bach)"
msgstr ""

#. type: TH
#: build/C/man2/msync.2:25
#, no-wrap
msgid "MSYNC"
msgstr ""

#. type: TH
#: build/C/man2/msync.2:25 build/C/man2/remap_file_pages.2:28
#, no-wrap
msgid "2008-04-22"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:28
msgid "msync - synchronize a file with a memory map"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:32
msgid "B<int msync(void *>I<addr>B<, size_t >I<length>B<, int >I<flags>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:48
msgid ""
"B<msync>()  flushes changes made to the in-core copy of a file that was "
"mapped into memory using B<mmap>(2)  back to disk.  Without use of this call "
"there is no guarantee that changes are written back before B<munmap>(2)  is "
"called.  To be more precise, the part of the file that corresponds to the "
"memory area starting at I<addr> and having length I<length> is updated."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:68
msgid ""
"The I<flags> argument may have the bits B<MS_ASYNC>, B<MS_SYNC>, and "
"B<MS_INVALIDATE> set, but not both B<MS_ASYNC> and B<MS_SYNC>.  B<MS_ASYNC> "
"specifies that an update be scheduled, but the call returns immediately.  "
"B<MS_SYNC> asks for an update and waits for it to complete.  "
"B<MS_INVALIDATE> asks to invalidate other mappings of the same file (so that "
"they can be updated with the fresh values just written)."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/msync.2:74
#, no-wrap
msgid "B<EBUSY>"
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:80
msgid ""
"B<MS_INVALIDATE> was specified in I<flags>, and a memory lock exists for the "
"specified address range."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:93
msgid ""
"I<addr> is not a multiple of PAGESIZE; or any bit other than B<MS_ASYNC> | "
"B<MS_INVALIDATE> | B<MS_SYNC> is set in I<flags>; or both B<MS_SYNC> and "
"B<MS_ASYNC> are set in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:96
msgid "The indicated memory (or part of it) was not mapped."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:98 build/C/man3/posix_fallocate.3:105 build/C/man3/shm_open.3:253 build/C/man7/shm_overview.7:103
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/msync.2:105
msgid ""
"This call was introduced in Linux 1.3.21, and then used B<EFAULT> instead of "
"B<ENOMEM>.  In Linux 2.4.19 this was changed to the POSIX value B<ENOMEM>."
msgstr ""

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/msync.2:120
msgid ""
"On POSIX systems on which B<msync>()  is available, both "
"B<_POSIX_MAPPED_FILES> and B<_POSIX_SYNCHRONIZED_IO> are defined in "
"I<E<lt>unistd.hE<gt>> to a value greater than 0.  (See also B<sysconf>(3).)"
msgstr ""

#. type: TP
#: build/C/man2/msync.2:122 build/C/man7/shm_overview.7:46
#, no-wrap
msgid "B<mmap>(2)"
msgstr ""

#. type: TH
#: build/C/man3/mtrace.3:25
#, no-wrap
msgid "MTRACE"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:28
msgid "mtrace, muntrace - malloc tracing"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:30
msgid "B<#include E<lt>mcheck.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:32
msgid "B<void mtrace(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:34
msgid "B<void muntrace(void);>"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:46
msgid ""
"The B<mtrace>()  function installs hook functions for the memory-allocation "
"functions (B<malloc>(3), B<realloc>(3)  B<memalign>(3), B<free>(3)).  These "
"hook functions record tracing information about memory allocation and "
"deallocation.  The tracing information can be used to discover memory leaks "
"and attempts to free nonallocated memory in a program."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:57
msgid ""
"The B<muntrace>()  function disables the hook functions installed by "
"B<mtrace>(), so that tracing information is no longer recorded for the "
"memory-allocation functions.  If no hook functions were successfully "
"installed by B<mtrace>(), B<muntrace>()  does nothing."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:65
msgid ""
"When B<mtrace>()  is called, it checks the value of the environment variable "
"B<MALLOC_TRACE>, which should contain the pathname of a file in which the "
"tracing information is to be recorded.  If the pathname is successfully "
"opened, it is truncated to zero length."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:78
msgid ""
"If B<MALLOC_TRACE> is not set, or the pathname it specifies is invalid or "
"not writable, then no hook functions are installed, and B<mtrace>()  has no "
"effect.  In set-user-ID and set-group-ID programs, B<MALLOC_TRACE> is "
"ignored, and B<mtrace>()  has no effect."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:86
msgid ""
"In normal usage, B<mtrace>()  is called once at the start of execution of a "
"program, and B<muntrace>()  is never called."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:96
msgid ""
"The tracing output produced after a call to B<mtrace>()  is textual, but not "
"designed to be human readable.  The GNU C library provides a Perl script, "
"B<mtrace>(1), that interprets the trace log and produces human-readable "
"output.  For best results, the traced program should be compiled with "
"debugging enabled, so that line-number information is recorded in the "
"executable."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:102
msgid ""
"The tracing performed by B<mtrace>()  incurs a performance penalty (if "
"B<MALLOC_TRACE> points to a valid, writable pathname)."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:108
msgid ""
"The line-number information produced by B<mtrace>(1)  is not always precise: "
"the line number references may refer to the previous or following "
"(non-blank)  line of the source code."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:115
msgid ""
"The shell session below demonstrates the use of the B<mtrace>()  function "
"and the B<mtrace>(1)  command in a program that has memory leaks at two "
"different locations.  The demonstration uses the following program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:122
#, no-wrap
msgid ""
"$ B<cat t_mtrace.c>\n"
"#include E<lt>mcheck.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:127
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:129
#, no-wrap
msgid "    mtrace();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:132
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> 2; j++)\n"
"        malloc(100);            /* Never freed--a memory leak */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:136
#, no-wrap
msgid ""
"    calloc(16, 16);             /* Never freed--a memory leak */\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:142
msgid ""
"When we run the program as follows, we see that B<mtrace>()  diagnosed "
"memory leaks at two different locations in the program:"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:155
#, no-wrap
msgid ""
"$ B<cc -g t_mtrace.c -o t_mtrace>\n"
"$ B<export MALLOC_TRACE=/tmp/t>\n"
"$ B<./t_mtrace>\n"
"$ B<mtrace ./t_mtrace $MALLOC_TRACE>\n"
"Memory not freed:\n"
"-----------------\n"
"   Address     Size     Caller\n"
"0x084c9378     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c93e0     0x64  at /home/cecilia/t_mtrace.c:12\n"
"0x084c9448    0x100  at /home/cecilia/t_mtrace.c:16\n"
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:167
msgid ""
"The first two messages about unfreed memory correspond to the two "
"B<malloc>(3)  calls inside the I<for> loop.  The final message corresponds "
"to the call to B<calloc>(3)  (which in turn calls B<malloc>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/mtrace.3:172
msgid "B<mtrace>(1), B<malloc>(3), B<malloc_hook>(3), B<mcheck>(3)"
msgstr ""

#. type: TH
#: build/C/man2/posix_fadvise.2:28
#, no-wrap
msgid "POSIX_FADVISE"
msgstr ""

#. type: TH
#: build/C/man2/posix_fadvise.2:28 build/C/man2/readahead.2:28 build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "2013-04-01"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:31
msgid "posix_fadvise - predeclare an access pattern for file data"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:34 build/C/man3/posix_fallocate.3:31
#, no-wrap
msgid "B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:37
#, no-wrap
msgid ""
"B<int posix_fadvise(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<, int "
">I<advice>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:46
msgid "B<posix_fadvise>():"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:48 build/C/man3/posix_fallocate.3:44
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:56
msgid ""
"Programs can use B<posix_fadvise>()  to announce an intention to access file "
"data in a specific pattern in the future, thus allowing the kernel to "
"perform appropriate optimizations."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:63
msgid ""
"The I<advice> applies to a (not necessarily existent) region starting at "
"I<offset> and extending for I<len> bytes (or until the end of the file if "
"I<len> is 0) within the file referred to by I<fd>.  The I<advice> is not "
"binding; it merely constitutes an expectation on behalf of the application."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:65
msgid "Permissible values for I<advice> include:"
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:65
#, no-wrap
msgid "B<POSIX_FADV_NORMAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:71
msgid ""
"Indicates that the application has no advice to give about its access "
"pattern for the specified data.  If no advice is given for an open file, "
"this is the default assumption."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:71
#, no-wrap
msgid "B<POSIX_FADV_SEQUENTIAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:75
msgid ""
"The application expects to access the specified data sequentially (with "
"lower offsets read before higher ones)."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:75
#, no-wrap
msgid "B<POSIX_FADV_RANDOM>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:78
msgid "The specified data will be accessed in random order."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:78
#, no-wrap
msgid "B<POSIX_FADV_NOREUSE>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:81
msgid "The specified data will be accessed only once."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:81
#, no-wrap
msgid "B<POSIX_FADV_WILLNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:84
msgid "The specified data will be accessed in the near future."
msgstr ""

#. type: TP
#: build/C/man2/posix_fadvise.2:84
#, no-wrap
msgid "B<POSIX_FADV_DONTNEED>"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:87
msgid "The specified data will not be accessed in the near future."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:90
msgid "On success, zero is returned.  On error, an error number is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:94
msgid "The I<fd> argument was not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:97
msgid "An invalid value was specified for I<advice>."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:104
msgid ""
"The specified file descriptor refers to a pipe or FIFO.  (Linux actually "
"returns B<EINVAL> in this case.)"
msgstr ""

#.  of fadvise64_64()
#. type: Plain text
#: build/C/man2/posix_fadvise.2:112
msgid ""
"Kernel support first appeared in Linux 2.5.60; the underlying system call is "
"called B<fadvise64>().  Library support has been provided since glibc "
"version 2.2, via the wrapper function B<posix_fadvise>()."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:121
msgid ""
"POSIX.1-2001.  Note that the type of the I<len> argument was changed from "
"I<size_t> to I<off_t> in POSIX.1-2003 TC1."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:127
msgid ""
"Under Linux, B<POSIX_FADV_NORMAL> sets the readahead window to the default "
"size for the backing device; B<POSIX_FADV_SEQUENTIAL> doubles this size, and "
"B<POSIX_FADV_RANDOM> disables file readahead entirely.  These changes affect "
"the entire file, not just the specified region (but other open file handles "
"to the same file are unaffected)."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:134
msgid ""
"B<POSIX_FADV_WILLNEED> initiates a nonblocking read of the specified region "
"into the page cache.  The amount of data read may be decreased by the kernel "
"depending on virtual memory load.  (A few megabytes will usually be fully "
"satisfied, and more is rarely useful.)"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:138
msgid ""
"In kernels before 2.6.18, B<POSIX_FADV_NOREUSE> had the same semantics as "
"B<POSIX_FADV_WILLNEED>.  This was probably a bug; since kernel 2.6.18, this "
"flag is a no-op."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:146
msgid ""
"B<POSIX_FADV_DONTNEED> attempts to free cached pages associated with the "
"specified region.  This is useful, for example, while streaming large "
"files.  A program may periodically request the kernel to free cached data "
"that has already been used, so that more useful cached pages are not "
"discarded instead."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:154
msgid ""
"Pages that have not yet been written out will be unaffected, so if the "
"application wishes to guarantee that pages will be released, it should call "
"B<fsync>(2)  or B<fdatasync>(2)  first."
msgstr ""

#. type: SS
#: build/C/man2/posix_fadvise.2:154
#, no-wrap
msgid "Architecture-specific variants"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:171
msgid ""
"Some architectures require 64-bit arguments to be aligned in a suitable pair "
"of registers (see B<syscall>(2)  for further detail).  On such "
"architectures, the call signature of B<posix_fadvise>()  shown in the "
"SYNOPSIS would force a register to be wasted as padding between the I<fd> "
"and I<len> arguments.  Therefore, these architectures define a version of "
"the system call that orders the arguments suitably, but otherwise is "
"otherwise exactly the same as B<posix_fadvise>()."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:173
msgid "For example, since Linux 2.6.14, ARM has the following system call:"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:178
#, no-wrap
msgid ""
"B<long arm_fadvise64_64(int >I<fd>B<, int >I<advice>B<,>\n"
"B<                      loff_t >I<offset>B<, loff_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:186
msgid ""
"These architecture-specific details are generally hidden from applications "
"by the glibc B<posix_fadvise>()  wrapper function, which invokes the "
"appropriate architecture-specific system call."
msgstr ""

#. type: Plain text
#: build/C/man2/posix_fadvise.2:191
msgid ""
"In kernels before 2.6.6, if I<len> was specified as 0, then this was "
"interpreted literally as \"zero bytes\", rather than as meaning \"all bytes "
"through to the end of the file\"."
msgstr ""

#.  FIXME . Write a posix_fadvise(3) page.
#. type: Plain text
#: build/C/man2/posix_fadvise.2:197
msgid ""
"B<readahead>(2), B<sync_file_range>(2), B<posix_fallocate>(3), "
"B<posix_madvise>(3)"
msgstr ""

#. type: TH
#: build/C/man3/posix_fallocate.3:25
#, no-wrap
msgid "POSIX_FALLOCATE"
msgstr ""

#. type: TH
#: build/C/man3/posix_fallocate.3:25 build/C/man2/shmop.2:41
#, no-wrap
msgid "2013-02-12"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:28
msgid "posix_fallocate - allocate file space"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:33
#, no-wrap
msgid "B<int posix_fallocate(int >I<fd>B<, off_t >I<offset>B<, off_t >I<len>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:42
msgid "B<posix_fallocate>():"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:61
msgid ""
"The function B<posix_fallocate>()  ensures that disk space is allocated for "
"the file referred to by the descriptor I<fd> for the bytes in the range "
"starting at I<offset> and continuing for I<len> bytes.  After a successful "
"call to B<posix_fallocate>(), subsequent writes to bytes in the specified "
"range are guaranteed not to fail because of lack of disk space."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:66
msgid ""
"If the size of the file is less than I<offset>+I<len>, then the file is "
"increased to this size; otherwise the file size is left unchanged."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:72
msgid ""
"B<posix_fallocate>()  returns zero on success, or an error number on "
"failure.  Note that I<errno> is not set."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:81
msgid "I<offset+len> exceeds the maximum file size."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:91
msgid "I<fd> does not refer to a regular file."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:100
msgid "I<fd> refers to a pipe."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:103
msgid "B<posix_fallocate>()  is available since glibc 2.1.94."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:128
msgid ""
"POSIX.1-2008 says that an implementation I<shall> give the B<EINVAL> error "
"if I<len> was 0, or I<offset> was less than 0.  POSIX.1-2001 says that an "
"implementation I<shall> give the B<EINVAL> error if I<len> is less than 0, "
"or I<offset> was less than 0, and I<may> give the error if I<len> equals "
"zero."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_fallocate.3:133
msgid "B<fallocate>(1), B<fallocate>(2), B<lseek>(2), B<posix_fadvise>(2)"
msgstr ""

#. type: TH
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "POSIX_MEMALIGN"
msgstr ""

#. type: TH
#: build/C/man3/posix_memalign.3:29
#, no-wrap
msgid "2012-03-23"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:32
msgid ""
"posix_memalign, aligned_alloc, memalign, valloc, pvalloc - allocate aligned "
"memory"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:39
#, no-wrap
msgid ""
"B<int posix_memalign(void **>I<memptr>B<, size_t >I<alignment>B<, size_t "
">I<size>B<);>\n"
"B<void *aligned_alloc(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *valloc(size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:44
#, no-wrap
msgid ""
"B<void *memalign(size_t >I<alignment>B<, size_t >I<size>B<);>\n"
"B<void *pvalloc(size_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:54
msgid ""
"B<posix_memalign>(): _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ "
"E<gt>=\\ 600"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:57
msgid "B<aligned_alloc>(): _ISOC11_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:59
msgid "B<valloc>():"
msgstr ""

#. type: TP
#: build/C/man3/posix_memalign.3:62
#, no-wrap
msgid "Since glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:69
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""

#. type: TP
#: build/C/man3/posix_memalign.3:71
#, no-wrap
msgid "Before glibc 2.12:"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:75
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:82
msgid ""
"(The (nonstandard) header file I<E<lt>malloc.hE<gt>> also exposes the "
"declaration of B<valloc>(); no feature test macros are required.)"
msgstr ""

#.  glibc does this:
#. type: Plain text
#: build/C/man3/posix_memalign.3:103
msgid ""
"The function B<posix_memalign>()  allocates I<size> bytes and places the "
"address of the allocated memory in I<*memptr>.  The address of the allocated "
"memory will be a multiple of I<alignment>, which must be a power of two and "
"a multiple of I<sizeof(void\\ *)>.  If I<size> is 0, then "
"B<posix_memalign>()  returns either NULL, or a unique pointer value that can "
"later be successfully passed to B<free>(3)."
msgstr ""

#.  The behavior of memalign() for size==0 is as for posix_memalign()
#.  but no standards govern this.
#. type: Plain text
#: build/C/man3/posix_memalign.3:114
msgid ""
"The obsolete function B<memalign>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"I<alignment>, which must be a power of two."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:123
msgid ""
"The function B<aligned_alloc>()  is the same as B<memalign>(), except for "
"the added restriction that I<size> should be a multiple of I<alignment>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:132
msgid ""
"The obsolete function B<valloc>()  allocates I<size> bytes and returns a "
"pointer to the allocated memory.  The memory address will be a multiple of "
"the page size.  It is equivalent to I<memalign(sysconf(_SC_PAGESIZE),size)>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:139
msgid ""
"The obsolete function B<pvalloc>()  is similar to B<valloc>(), but rounds "
"the size of the allocation up to the next multiple of the system page size."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:141
msgid "For all of these functions, the memory is not zeroed."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:148
msgid ""
"B<aligned_alloc>(), B<memalign>(), B<valloc>(), and B<pvalloc>()  return a "
"pointer to the allocated memory, or NULL if the request fails."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:155
msgid ""
"B<posix_memalign>()  returns zero on success, or one of the error values "
"listed in the next section on failure.  Note that I<errno> is not set."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:162
msgid ""
"The I<alignment> argument was not a power of two, or was not a multiple of "
"I<sizeof(void\\ *)>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:165
msgid "There was insufficient memory to fulfill the allocation request."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:172
msgid ""
"The functions B<memalign>(), B<valloc>(), and B<pvalloc>()  have been "
"available in all Linux libc libraries."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:176
msgid "The function B<aligned_alloc>()  was added to glibc in version 2.16."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:180
msgid "The function B<posix_memalign>()  is available since glibc 2.1.91."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:187
msgid ""
"The function B<valloc>()  appeared in 3.0BSD.  It is documented as being "
"obsolete in 4.3BSD, and as legacy in SUSv2.  It does not appear in "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:191
msgid "The function B<pvalloc>()  is a GNU extension."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:195
msgid "The function B<memalign>()  appears in SunOS 4.1.3 but not in 4.4BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:199
msgid "The function B<posix_memalign>()  comes from POSIX.1d."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:204
msgid "The function B<aligned_alloc>()  is specified in the C11 standard."
msgstr ""

#. type: SS
#: build/C/man3/posix_memalign.3:204
#, no-wrap
msgid "Headers"
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:208
msgid ""
"Everybody agrees that B<posix_memalign>()  is declared in "
"I<E<lt>stdlib.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:212
msgid ""
"On some systems B<memalign>()  is declared in I<E<lt>stdlib.hE<gt>> instead "
"of I<E<lt>malloc.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:219
msgid ""
"According to SUSv2, B<valloc>()  is declared in I<E<lt>stdlib.hE<gt>>.  "
"Libc4,5 and glibc declare it in I<E<lt>malloc.hE<gt>>, and also in "
"I<E<lt>stdlib.hE<gt>> if suitable feature test macros are defined (see "
"above)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:228
msgid ""
"On many systems there are alignment restrictions, for example, on buffers "
"used for direct block device I/O.  POSIX specifies the "
"I<pathconf(path,_PC_REC_XFER_ALIGN)> call that tells what alignment is "
"needed.  Now one can use B<posix_memalign>()  to satisfy this requirement."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:237
msgid ""
"B<posix_memalign>()  verifies that I<alignment> matches the requirements "
"detailed above.  B<memalign>()  may not check that the I<alignment> argument "
"is correct."
msgstr ""

#.  Other systems allow passing the result of
#.  .IR valloc ()
#.  to
#.  .IR free (3),
#.  but not to
#.  .IR realloc (3).
#. type: Plain text
#: build/C/man3/posix_memalign.3:265
msgid ""
"POSIX requires that memory obtained from B<posix_memalign>()  can be freed "
"using B<free>(3).  Some systems provide no way to reclaim memory allocated "
"with B<memalign>()  or B<valloc>()  (because one can pass to B<free>(3)  "
"only a pointer obtained from B<malloc>(3), while, for example, B<memalign>()  "
"would call B<malloc>(3)  and then align the obtained value).  The glibc "
"implementation allows memory obtained from any of these functions to be "
"reclaimed with B<free>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:270
msgid ""
"The glibc B<malloc>(3)  always returns 8-byte aligned memory addresses, so "
"these functions are needed only if you require larger alignment values."
msgstr ""

#. type: Plain text
#: build/C/man3/posix_memalign.3:275
msgid "B<brk>(2), B<getpagesize>(2), B<free>(3), B<malloc>(3)"
msgstr ""

#. type: TH
#: build/C/man2/readahead.2:28
#, no-wrap
msgid "READAHEAD"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:31
msgid "readahead - perform file readahead into page cache"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:37
#, no-wrap
msgid ""
"B<ssize_t readahead(int >I<fd>B<, off64_t >I<offset>B<, size_t "
">I<count>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:65
msgid ""
"B<readahead>()  populates the page cache with data from a file so that "
"subsequent reads from that file will not block on disk I/O.  The I<fd> "
"argument is a file descriptor identifying the file which is to be read.  The "
"I<offset> argument specifies the starting point from which data is to be "
"read and I<count> specifies the number of bytes to be read.  I/O is "
"performed in whole pages, so that I<offset> is effectively rounded down to a "
"page boundary and bytes are read up to the next page boundary greater than "
"or equal to I<(offset+count)>.  B<readahead>()  does not read beyond the end "
"of the file.  B<readahead>()  blocks until the specified data has been "
"read.  The current file offset of the open file referred to by I<fd> is left "
"unchanged."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:71
msgid ""
"On success, B<readahead>()  returns 0; on failure, -1 is returned, with "
"I<errno> set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:76
msgid "I<fd> is not a valid file descriptor or is not open for reading."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:82
msgid "I<fd> does not refer to a file type to which B<readahead>()  can be applied."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:87
msgid ""
"The B<readahead>()  system call appeared in Linux 2.4.13; glibc support has "
"been provided since version 2.3."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:92
msgid ""
"The B<readahead>()  system call is Linux-specific, and its use should be "
"avoided in portable applications."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:97
msgid ""
"On some 32-bit architectures, the calling signature for this system call "
"differs, for the reasons described in B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/readahead.2:103
msgid "B<lseek>(2), B<madvise>(2), B<mmap>(2), B<posix_fadvise>(2), B<read>(2)"
msgstr ""

#. type: TH
#: build/C/man2/remap_file_pages.2:28
#, no-wrap
msgid "REMAP_FILE_PAGES"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:31
msgid "remap_file_pages - create a nonlinear file mapping"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sys/mman.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:38
#, no-wrap
msgid ""
"B<int remap_file_pages(void *>I<addr>B<, size_t >I<size>B<, int "
">I<prot>B<,>\n"
"B<                     ssize_t >I<pgoff>B<, int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:51
msgid ""
"The B<remap_file_pages>()  system call is used to create a nonlinear "
"mapping, that is, a mapping in which the pages of the file are mapped into a "
"nonsequential order in memory.  The advantage of using B<remap_file_pages>()  "
"over using repeated calls to B<mmap>(2)  is that the former approach does "
"not require the kernel to create additional VMA (Virtual Memory Area) data "
"structures."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:53
msgid "To create a nonlinear mapping we perform the following steps:"
msgstr ""

#. type: TP
#: build/C/man2/remap_file_pages.2:53
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:61
msgid ""
"Use B<mmap>(2)  to create a mapping (which is initially linear).  This "
"mapping must be created with the B<MAP_SHARED> flag."
msgstr ""

#. type: TP
#: build/C/man2/remap_file_pages.2:61
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:69
msgid ""
"Use one or more calls to B<remap_file_pages>()  to rearrange the "
"correspondence between the pages of the mapping and the pages of the file.  "
"It is possible to map the same page of a file into multiple locations within "
"the mapped region."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:80
msgid ""
"The I<pgoff> and I<size> arguments specify the region of the file that is to "
"be relocated within the mapping: I<pgoff> is a file offset in units of the "
"system page size; I<size> is the length of the region in bytes."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:98
msgid ""
"The I<addr> argument serves two purposes.  First, it identifies the mapping "
"whose pages we want to rearrange.  Thus, I<addr> must be an address that "
"falls within a region previously mapped by a call to B<mmap>(2).  Second, "
"I<addr> specifies the address at which the file pages identified by I<pgoff> "
"and I<size> will be placed."
msgstr ""

#.  This rounding is weird, and not consistent with the treatment of
#.  the analogous arguments for munmap()/mprotect() and for mlock().
#.  MTK, 14 Sep 2005
#. type: Plain text
#: build/C/man2/remap_file_pages.2:112
msgid ""
"The values specified in I<addr> and I<size> should be multiples of the "
"system page size.  If they are not, then the kernel rounds I<both> values "
"I<down> to the nearest multiple of the page size."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:116
msgid "The I<prot> argument must be specified as 0."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:124
msgid ""
"The I<flags> argument has the same meaning as for B<mmap>(2), but all flags "
"other than B<MAP_NONBLOCK> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:131
msgid ""
"On success, B<remap_file_pages>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:139
msgid ""
"I<addr> does not refer to a valid mapping created with the B<MAP_SHARED> "
"flag."
msgstr ""

#.  And possibly others from vma->vm_ops->populate()
#. type: Plain text
#: build/C/man2/remap_file_pages.2:148
msgid "I<addr>, I<size>, I<prot>, or I<pgoff> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:153
msgid ""
"The B<remap_file_pages>()  system call appeared in Linux 2.5.46; glibc "
"support was added in version 2.3.3."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:157
msgid "The B<remap_file_pages>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/remap_file_pages.2:164
msgid ""
"B<getpagesize>(2), B<mmap>(2), B<mmap2>(2), B<mprotect>(2), B<mremap>(2), "
"B<msync>(2)"
msgstr ""

#. type: TH
#: build/C/man3/shm_open.3:26
#, no-wrap
msgid "SHM_OPEN"
msgstr ""

#. type: TH
#: build/C/man3/shm_open.3:26
#, no-wrap
msgid "2009-02-25"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:29
msgid "shm_open, shm_unlink - create/open or unlink POSIX shared memory objects"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:33
msgid "B<#include E<lt>sys/stat.hE<gt>> /* For mode constants */"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:35
msgid "B<#include E<lt>fcntl.hE<gt>> /* For O_* constants */"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:37
msgid "B<int shm_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:39
msgid "B<int shm_unlink(const char *>I<name>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:41
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:53
msgid ""
"B<shm_open>()  creates and opens a new, or opens an existing, POSIX shared "
"memory object.  A POSIX shared memory object is in effect a handle which can "
"be used by unrelated processes to B<mmap>(2)  the same region of shared "
"memory.  The B<shm_unlink>()  function performs the converse operation, "
"removing an object previously created by B<shm_open>()."
msgstr ""

#.  glibc allows the initial slash to be omitted, and makes
#.  multiple initial slashes equivalent to a single slash.
#.  This differs from the implementation of POSIX message queues.
#.  glibc allows subdirectory components in the name, in which
#.  case the subdirectory must exist under /dev/shm, and allow the
#.  required permissions if a user wants to create a shared memory
#.  object in that subdirectory.
#. type: Plain text
#: build/C/man3/shm_open.3:74
msgid ""
"The operation of B<shm_open>()  is analogous to that of B<open>(2).  I<name> "
"specifies the shared memory object to be created or opened.  For portable "
"use, a shared memory object should be identified by a name of the form "
"I</somename>; that is, a null-terminated string of up to B<NAME_MAX> (i.e., "
"255) characters consisting of an initial slash, followed by one or more "
"characters, none of which are slashes."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:81
msgid ""
"I<oflag> is a bit mask created by ORing together exactly one of B<O_RDONLY> "
"or B<O_RDWR> and any of the other flags listed here:"
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:81
#, no-wrap
msgid "B<O_RDONLY>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:89
msgid ""
"Open the object for read access.  A shared memory object opened in this way "
"can be B<mmap>(2)ed only for read (B<PROT_READ>)  access."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:89
#, no-wrap
msgid "B<O_RDWR>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:92
msgid "Open the object for read-write access."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:92
#, no-wrap
msgid "B<O_CREAT>"
msgstr ""

#.  In truth it is actually the file system IDs on Linux, but these
#.  are nearly always the same as the effective IDs.  (MTK, Jul 05)
#. type: Plain text
#: build/C/man3/shm_open.3:112
msgid ""
"Create the shared memory object if it does not exist.  The user and group "
"ownership of the object are taken from the corresponding effective IDs of "
"the calling process, and the object's permission bits are set according to "
"the low-order 9 bits of I<mode>, except that those bits set in the process "
"file mode creation mask (see B<umask>(2))  are cleared for the new object.  "
"A set of macro constants which can be used to define I<mode> is listed in "
"B<open>(2).  (Symbolic definitions of these constants can be obtained by "
"including I<E<lt>sys/stat.hE<gt>>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:118
msgid ""
"A new shared memory object initially has zero length\\(emthe size of the "
"object can be set using B<ftruncate>(2).  The newly allocated bytes of a "
"shared memory object are automatically initialized to 0."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:118
#, no-wrap
msgid "B<O_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:127
msgid ""
"If B<O_CREAT> was also specified, and a shared memory object with the given "
"I<name> already exists, return an error.  The check for the existence of the "
"object, and its creation if it does not exist, are performed atomically."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:127
#, no-wrap
msgid "B<O_TRUNC>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:130
msgid "If the shared memory object already exists, truncate it to zero bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:133
msgid ""
"Definitions of these flag values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:144
msgid ""
"On successful completion B<shm_open>()  returns a new file descriptor "
"referring to the shared memory object.  This file descriptor is guaranteed "
"to be the lowest-numbered file descriptor not previously opened within the "
"process.  The B<FD_CLOEXEC> flag (see B<fcntl>(2))  is set for the file "
"descriptor."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:153
msgid ""
"The file descriptor is normally used in subsequent calls to B<ftruncate>(2)  "
"(for a newly created object) and B<mmap>(2).  After a call to B<mmap>(2)  "
"the file descriptor may be closed without affecting the memory mapping."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:171
msgid ""
"The operation of B<shm_unlink>()  is analogous to B<unlink>(2): it removes a "
"shared memory object name, and, once all processes have unmapped the object, "
"de-allocates and destroys the contents of the associated memory region.  "
"After a successful B<shm_unlink>(), attempts to B<shm_open>()  an object "
"with the same I<name> will fail (unless B<O_CREAT> was specified, in which "
"case a new, distinct object is created)."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:180
msgid ""
"On success, B<shm_open>()  returns a nonnegative file descriptor.  On "
"failure, B<shm_open>()  returns -1.  B<shm_unlink>()  returns 0 on success, "
"or -1 on error."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:187
msgid ""
"On failure, I<errno> is set to indicate the cause of the error.  Values "
"which may appear in I<errno> include the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:192
msgid "Permission to B<shm_unlink>()  the shared memory object was denied."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:202
msgid ""
"Permission was denied to B<shm_open>()  I<name> in the specified I<mode>, or "
"B<O_TRUNC> was specified and the caller does not have write permission on "
"the object."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:202 build/C/man2/shmget.2:195
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:213
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified to B<shm_open>()  and the "
"shared memory object specified by I<name> already exists."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:220
msgid "The I<name> argument to B<shm_open>()  was invalid."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:220
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:223
msgid "The process already has the maximum number of files open."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:223
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:229
msgid "The length of I<name> exceeds B<PATH_MAX>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:233
msgid "The limit on the total number of files open on the system has been reached."
msgstr ""

#. type: TP
#: build/C/man3/shm_open.3:233 build/C/man3/shm_open.3:242 build/C/man2/shmget.2:209
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:242
msgid ""
"An attempt was made to B<shm_open>()  a I<name> that did not exist, and "
"B<O_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:249
msgid "An attempt was to made to B<shm_unlink>()  a I<name> that does not exist."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:251
msgid "These functions are provided in glibc 2.2 and later."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:257
msgid ""
"POSIX.1-2001 says that the group ownership of a newly created shared memory "
"object is set to either the calling process's effective group ID or \"a "
"system default group ID\"."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:266
msgid ""
"POSIX leaves the behavior of the combination of B<O_RDONLY> and B<O_TRUNC> "
"unspecified.  On Linux, this will successfully truncate an existing shared "
"memory object\\(emthis may not be so on other UNIX systems."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:271
msgid ""
"The POSIX shared memory object implementation on Linux 2.4 makes use of a "
"dedicated file system, which is normally mounted under I</dev/shm>."
msgstr ""

#. type: Plain text
#: build/C/man3/shm_open.3:282
msgid ""
"B<close>(2), B<fchmod>(2), B<fchown>(2), B<fcntl>(2), B<fstat>(2), "
"B<ftruncate>(2), B<mmap>(2), B<open>(2), B<umask>(2), B<shm_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man7/shm_overview.7:27
#, no-wrap
msgid "SHM_OVERVIEW"
msgstr ""

#. type: TH
#: build/C/man7/shm_overview.7:27
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:30
msgid "shm_overview - overview of POSIX shared memory"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:33
msgid ""
"The POSIX shared memory API allows processes to communicate information by "
"sharing a region of memory."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:35
msgid "The interfaces employed in the API are:"
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:35
#, no-wrap
msgid "B<shm_open>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:42
msgid ""
"Create and open a new object, or open an existing object.  This is analogous "
"to B<open>(2).  The call returns a file descriptor for use by the other "
"interfaces listed below."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:42
#, no-wrap
msgid "B<ftruncate>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:46
msgid ""
"Set the size of the shared memory object.  (A newly created shared memory "
"object has a length of zero.)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:50
msgid ""
"Map the shared memory object into the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:50
#, no-wrap
msgid "B<munmap>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:54
msgid ""
"Unmap the shared memory object from the virtual address space of the calling "
"process."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:54
#, no-wrap
msgid "B<shm_unlink>(3)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:57
msgid "Remove a shared memory object name."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:57
#, no-wrap
msgid "B<close>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:62
msgid ""
"Close the file descriptor allocated by B<shm_open>(3)  when it is no longer "
"needed."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:62
#, no-wrap
msgid "B<fstat>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:76
msgid ""
"Obtain a I<stat> structure that describes the shared memory object.  Among "
"the information returned by this call are the object's size (I<st_size>), "
"permissions (I<st_mode>), owner (I<st_uid>), and group (I<st_gid>)."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:76
#, no-wrap
msgid "B<fchown>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:79
msgid "To change the ownership of a shared memory object."
msgstr ""

#. type: TP
#: build/C/man7/shm_overview.7:79
#, no-wrap
msgid "B<fchmod>(2)"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:82
msgid "To change the permissions of a shared memory object."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:82
#, no-wrap
msgid "Versions"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:84
msgid "POSIX shared memory is supported since Linux 2.4 and glibc 2.2."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:84
#, no-wrap
msgid "Persistence"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:89
msgid ""
"POSIX shared memory objects have kernel persistence: a shared memory object "
"will exist until the system is shut down, or until all processes have "
"unmapped the object and it has been deleted with B<shm_unlink>(3)"
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:89
#, no-wrap
msgid "Linking"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:94
msgid ""
"Programs using the POSIX shared memory API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""

#. type: SS
#: build/C/man7/shm_overview.7:94
#, no-wrap
msgid "Accessing shared memory objects via the file system"
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:101
msgid ""
"On Linux, shared memory objects are created in a (I<tmpfs>)  virtual file "
"system, normally mounted under I</dev/shm>.  Since kernel 2.6.19, Linux "
"supports the use of access control lists (ACLs)  to control the permissions "
"of objects in the virtual file system."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:106
msgid ""
"Typically, processes must synchronize their access to a shared memory "
"object, using, for example, POSIX semaphores."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:114
msgid ""
"System V shared memory (B<shmget>(2), B<shmop>(2), etc.) is an older shared "
"memory API.  POSIX shared memory provides a simpler, and better designed "
"interface; on the other hand POSIX shared memory is somewhat less widely "
"available (especially on older systems) than System V shared memory."
msgstr ""

#. type: Plain text
#: build/C/man7/shm_overview.7:127
msgid ""
"B<fchmod>(2), B<fchown>(2), B<fstat>(2), B<ftruncate>(2), B<mmap>(2), "
"B<mprotect>(2), B<munmap>(2), B<shmget>(2), B<shmop>(2), B<shm_open>(3), "
"B<shm_unlink>(3), B<sem_overview>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmctl.2:45
#, no-wrap
msgid "SHMCTL"
msgstr ""

#. type: TH
#: build/C/man2/shmctl.2:45
#, no-wrap
msgid "2013-03-18"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:48
msgid "shmctl - System V shared memory control"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:51 build/C/man2/shmget.2:44
msgid "B<#include E<lt>sys/ipc.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:53 build/C/man2/shmget.2:46
msgid "B<#include E<lt>sys/shm.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:55
msgid "B<int shmctl(int >I<shmid>B<, int >I<cmd>B<, struct shmid_ds *>I<buf>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:62
msgid ""
"B<shmctl>()  performs the control operation specified by I<cmd> on the "
"System V shared memory segment whose identifier is given in I<shmid>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:67
msgid ""
"The I<buf> argument is a pointer to a I<shmid_ds> structure, defined in "
"I<E<lt>sys/shm.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:81
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;    /* Ownership and permissions */\n"
"    size_t          shm_segsz;   /* Size of segment (bytes) */\n"
"    time_t          shm_atime;   /* Last attach time */\n"
"    time_t          shm_dtime;   /* Last detach time */\n"
"    time_t          shm_ctime;   /* Last change time */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */\n"
"    shmatt_t        shm_nattch;  /* No. of current attaches */\n"
"    ...\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:89
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:102
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;    /* Key supplied to shmget(2) */\n"
"    uid_t          B<uid>;      /* Effective UID of owner */\n"
"    gid_t          B<gid>;      /* Effective GID of owner */\n"
"    uid_t          cuid;     /* Effective UID of creator */\n"
"    gid_t          cgid;     /* Effective GID of creator */\n"
"    unsigned short B<mode>;     /* B<Permissions> + SHM_DEST and\n"
"                                SHM_LOCKED flags */\n"
"    unsigned short __seq;    /* Sequence number */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:108
msgid "Valid values for I<cmd> are:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:109
#, no-wrap
msgid "B<IPC_STAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:118
msgid ""
"Copy information from the kernel data structure associated with I<shmid> "
"into the I<shmid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the shared memory segment."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:118
#, no-wrap
msgid "B<IPC_SET>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:136
msgid ""
"Write the values of some members of the I<shmid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this shared memory "
"segment, updating also its I<shm_ctime> member.  The following fields can be "
"changed: I<shm_perm.uid>, I<shm_perm.gid>, and (the least significant 9 bits "
"of) I<shm_perm.mode>.  The effective UID of the calling process must match "
"the owner (I<shm_perm.uid>)  or creator (I<shm_perm.cuid>)  of the shared "
"memory segment, or the caller must be privileged."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:136
#, no-wrap
msgid "B<IPC_RMID>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:153
msgid ""
"Mark the segment to be destroyed.  The segment will only actually be "
"destroyed after the last process detaches it (i.e., when the I<shm_nattch> "
"member of the associated structure I<shmid_ds> is zero).  The caller must be "
"the owner or creator, or be privileged.  If a segment has been marked for "
"destruction, then the (nonstandard)  B<SHM_DEST> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:156
msgid ""
"The caller I<must> ensure that a segment is eventually destroyed; otherwise "
"its pages that were faulted in will remain in memory or swap."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:161
msgid ""
"See also the description of I</proc/sys/kernel/shm_rmid_forced> in "
"B<proc>(5)."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:161
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:174
msgid ""
"Returns information about system-wide shared memory limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<shminfo> "
"(thus, a cast is required), defined in I<E<lt>sys/shm.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:188
#, no-wrap
msgid ""
"struct  shminfo {\n"
"    unsigned long shmmax; /* Maximum segment size */\n"
"    unsigned long shmmin; /* Minimum segment size;\n"
"                             always 1 */\n"
"    unsigned long shmmni; /* Maximum number of segments */\n"
"    unsigned long shmseg; /* Maximum number of segments\n"
"                             that a process can attach;\n"
"                             unused within kernel */\n"
"    unsigned long shmall; /* Maximum number of pages of\n"
"                             shared memory, system-wide */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:201
msgid ""
"The I<shmmni>, I<shmmax>, and I<shmall> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:201
#, no-wrap
msgid "B<SHM_INFO> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:212
msgid ""
"Returns a I<shm_info> structure whose fields contain information about "
"system resources consumed by shared memory.  This structure is defined in "
"I<E<lt>sys/shm.hE<gt>> if the B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:229
#, no-wrap
msgid ""
"struct shm_info {\n"
"    int           used_ids; /* # of currently existing\n"
"                               segments */\n"
"    unsigned long shm_tot;  /* Total number of shared\n"
"                               memory pages */\n"
"    unsigned long shm_rss;  /* # of resident shared\n"
"                               memory pages */\n"
"    unsigned long shm_swp;  /* # of swapped shared\n"
"                               memory pages */\n"
"    unsigned long swap_attempts;\n"
"                            /* Unused since Linux 2.4 */\n"
"    unsigned long swap_successes;\n"
"                            /* Unused since Linux 2.4 */\n"
"};\n"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:231
#, no-wrap
msgid "B<SHM_STAT> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:242
msgid ""
"Returns a I<shmid_ds> structure as for B<IPC_STAT>.  However, the I<shmid> "
"argument is not a segment identifier, but instead an index into the kernel's "
"internal array that maintains information about all shared memory segments "
"on the system."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:245
msgid ""
"The caller can prevent or allow swapping of a shared memory segment with the "
"following I<cmd> values:"
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:246
#, no-wrap
msgid "B<SHM_LOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:258
msgid ""
"Prevent swapping of the shared memory segment.  The caller must fault in any "
"pages that are required to be present after locking is enabled.  If a "
"segment has been locked, then the (nonstandard)  B<SHM_LOCKED> flag of the "
"I<shm_perm.mode> field in the associated data structure retrieved by "
"B<IPC_STAT> will be set."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:258
#, no-wrap
msgid "B<SHM_UNLOCK> (Linux-specific)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:261
msgid "Unlock the segment, allowing it to be swapped out."
msgstr ""

#.  There was some weirdness in 2.6.9: SHM_LOCK and SHM_UNLOCK could
#.  be applied to a segment, regardless of ownership of the segment.
#.  This was a botch-up in the move to RLIMIT_MEMLOCK, and was fixed
#.  in 2.6.10.  MTK, May 2005
#. type: Plain text
#: build/C/man2/shmctl.2:279
msgid ""
"In kernels before 2.6.10, only a privileged process could employ B<SHM_LOCK> "
"and B<SHM_UNLOCK>.  Since kernel 2.6.10, an unprivileged process can employ "
"these operations if its effective UID matches the owner or creator UID of "
"the segment, and (for B<SHM_LOCK>)  the amount of memory to be locked falls "
"within the B<RLIMIT_MEMLOCK> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:297
msgid ""
"A successful B<IPC_INFO> or B<SHM_INFO> operation returns the index of the "
"highest used entry in the kernel's internal array recording information "
"about all shared memory segments.  (This information can be used with "
"repeated B<SHM_STAT> operations to obtain information about all shared "
"memory segments on the system.)  A successful B<SHM_STAT> operation returns "
"the identifier of the shared memory segment whose index was given in "
"I<shmid>.  Other operations return 0 on success."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:301
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:310
msgid ""
"B<IPC_STAT> or B<SHM_STAT> is requested and I<shm_perm.mode> does not allow "
"read access for I<shmid>, and the calling process does not have the "
"B<CAP_IPC_OWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:321
msgid ""
"The argument I<cmd> has value B<IPC_SET> or B<IPC_STAT> but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""

#. type: TP
#: build/C/man2/shmctl.2:321 build/C/man2/shmop.2:197
#, no-wrap
msgid "B<EIDRM>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:324 build/C/man2/shmop.2:200
msgid "I<shmid> points to a removed identifier."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:333
msgid ""
"I<shmid> is not a valid identifier, or I<cmd> is not a valid command.  Or: "
"for a B<SHM_STAT> operation, the index value specified in I<shmid> referred "
"to an array slot that is currently unused."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:344
msgid ""
"(In kernels since 2.6.9), B<SHM_LOCK> was specified and the size of the "
"to-be-locked segment would mean that the total bytes in locked shared memory "
"segments would exceed the limit for the real user ID of the calling "
"process.  This limit is defined by the B<RLIMIT_MEMLOCK> soft resource limit "
"(see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:349
msgid ""
"B<IPC_STAT> is attempted, and the GID or UID value is too large to be stored "
"in the structure pointed to by I<buf>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:361
msgid ""
"B<IPC_SET> or B<IPC_RMID> is attempted, and the effective user ID of the "
"calling process is not that of the creator (found in I<shm_perm.cuid>), or "
"the owner (found in I<shm_perm.uid>), and the process was not privileged "
"(Linux: did not have the B<CAP_SYS_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:373
msgid ""
"Or (in kernels before 2.6.9), B<SHM_LOCK> or B<SHM_UNLOCK> was specified, "
"but the process was not privileged (Linux: did not have the B<CAP_IPC_LOCK> "
"capability).  (Since Linux 2.6.9, this error can also occur if the "
"B<RLIMIT_MEMLOCK> is 0 and the caller is not privileged.)"
msgstr ""

#.  SVr4 documents an additional error condition EMFILE.
#. type: Plain text
#: build/C/man2/shmctl.2:378 build/C/man2/shmget.2:235 build/C/man2/shmop.2:234
msgid "SVr4, POSIX.1-2001."
msgstr ""

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/shmctl.2:391 build/C/man2/shmget.2:251
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:402
msgid ""
"The B<IPC_INFO>, B<SHM_STAT> and B<SHM_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a /proc file system interface."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:410
msgid ""
"Linux permits a process to attach (B<shmat>(2))  a shared memory segment "
"that has already been marked for deletion using I<shmctl(IPC_RMID)>.  This "
"feature is not available on other UNIX implementations; portable "
"applications should avoid relying on it."
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:423
msgid ""
"Various fields in a I<struct shmid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmctl.2:430
msgid ""
"B<mlock>(2), B<setrlimit>(2), B<shmget>(2), B<shmop>(2), B<capabilities>(7), "
"B<svipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmget.2:38
#, no-wrap
msgid "SHMGET"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:41
msgid "shmget - allocates a System V shared memory segment"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:48
msgid "B<int shmget(key_t >I<key>B<, size_t >I<size>B<, int >I<shmflg>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:72
msgid ""
"B<shmget>()  returns the identifier of the System V shared memory segment "
"associated with the value of the argument I<key>.  A new shared memory "
"segment, with size equal to the value of I<size> rounded up to a multiple of "
"B<PAGE_SIZE>, is created if I<key> has the value B<IPC_PRIVATE> or I<key> "
"isn't B<IPC_PRIVATE>, no shared memory segment corresponding to I<key> "
"exists, and B<IPC_CREAT> is specified in I<shmflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:91
msgid ""
"If I<shmflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a shared memory "
"segment already exists for I<key>, then B<shmget>()  fails with I<errno> set "
"to B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT "
"| O_EXCL> for B<open>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:95
msgid "The value I<shmflg> is composed of:"
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:95
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:102
msgid ""
"to create a new segment.  If this flag is not used, then B<shmget>()  will "
"find the segment associated with I<key> and check to see if the user has "
"permission to access the segment."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:102
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:105
msgid "used with B<IPC_CREAT> to ensure failure if the segment already exists."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:105
#, no-wrap
msgid "I<mode_flags>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:115
msgid ""
"(least significant 9 bits)  specifying the permissions granted to the owner, "
"group, and world.  These bits have the same format, and the same meaning, as "
"the I<mode> argument of B<open>(2).  Presently, the execute permissions are "
"not used by the system."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:115
#, no-wrap
msgid "B<SHM_HUGETLB> (since Linux 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:121
msgid ""
"Allocate the segment using \"huge pages.\" See the Linux kernel source file "
"I<Documentation/vm/hugetlbpage.txt> for further information."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:121
#, no-wrap
msgid "B<SHM_NORESERVE> (since Linux 2.6.15)"
msgstr ""

#.  As at 2.6.17-rc2, this flag has no effect if SHM_HUGETLB was also
#.  specified.
#. type: Plain text
#: build/C/man2/shmget.2:140
msgid ""
"This flag serves the same purpose as the B<mmap>(2)  B<MAP_NORESERVE> flag.  "
"Do not reserve swap space for this segment.  When swap space is reserved, "
"one has the guarantee that it is possible to modify the segment.  When swap "
"space is not reserved one might get B<SIGSEGV> upon a write if no physical "
"memory is available.  See also the discussion of the file "
"I</proc/sys/vm/overcommit_memory> in B<proc>(5)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:148
msgid ""
"When a new shared memory segment is created, its contents are initialized to "
"zero values, and its associated data structure, I<shmid_ds> (see "
"B<shmctl>(2)), is initialized as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:153
msgid ""
"I<shm_perm.cuid> and I<shm_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:158
msgid ""
"I<shm_perm.cgid> and I<shm_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:163
msgid ""
"The least significant 9 bits of I<shm_perm.mode> are set to the least "
"significant 9 bit of I<shmflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:167
msgid "I<shm_segsz> is set to the value of I<size>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:174
msgid "I<shm_lpid>, I<shm_nattch>, I<shm_atime> and I<shm_dtime> are set to 0."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:177
msgid "I<shm_ctime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:180
msgid ""
"If the shared memory segment already exists, the permissions are verified, "
"and a check is made to see if it is marked for destruction."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:185
msgid ""
"On success, a valid shared memory identifier is returned.  On errir, -1 is "
"returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:189
msgid "On failure, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:195
msgid ""
"The user does not have permission to access the shared memory segment, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:199
msgid "B<IPC_CREAT | IPC_EXCL> was specified and the segment exists."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:205
msgid ""
"A new segment was to be created and I<size> E<lt> B<SHMMIN> or I<size> E<gt> "
"B<SHMMAX>, or no new segment was to be created, a segment with given key "
"existed, but I<size> is greater than the size of that segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:214
msgid "No segment exists for the given I<key>, and B<IPC_CREAT> was not specified."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:217
msgid "No memory could be allocated for segment overhead."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:225
msgid ""
"All possible shared memory IDs have been taken (B<SHMMNI>), or allocating a "
"segment of the requested I<size> would cause the system to exceed the "
"system-wide limit on shared memory (B<SHMALL>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:232
msgid ""
"The B<SHM_HUGETLB> flag was specified, but the caller was not privileged "
"(did not have the B<CAP_IPC_LOCK> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:238
msgid "B<SHM_HUGETLB> is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:261
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<shmflg> and creates a new shared memory segment (on "
"success)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:265
msgid ""
"The following limits on shared memory segment resources affect the "
"B<shmget>()  call:"
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:265
#, no-wrap
msgid "B<SHMALL>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:270
msgid ""
"System wide maximum of shared memory pages (on Linux, this limit can be read "
"and modified via I</proc/sys/kernel/shmall>)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:270
#, no-wrap
msgid "B<SHMMAX>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:275
msgid ""
"Maximum size in bytes for a shared memory segment: policy dependent (on "
"Linux, this limit can be read and modified via I</proc/sys/kernel/shmmax>)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:275
#, no-wrap
msgid "B<SHMMIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:281
msgid ""
"Minimum size in bytes for a shared memory segment: implementation dependent "
"(currently 1 byte, though B<PAGE_SIZE> is the effective minimum size)."
msgstr ""

#. type: TP
#: build/C/man2/shmget.2:281
#, no-wrap
msgid "B<SHMMNI>"
msgstr ""

#.  Kernels between 2.4.x and 2.6.8 had an off-by-one error that meant
#.  that we could create one more segment than SHMMNI -- MTK
#.  This /proc file is not available in Linux 2.2 and earlier -- MTK
#. type: Plain text
#: build/C/man2/shmget.2:290
msgid ""
"System wide maximum number of shared memory segments: implementation "
"dependent (currently 4096, was 128 before Linux 2.3.99; on Linux, this limit "
"can be read and modified via I</proc/sys/kernel/shmmni>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:294
msgid ""
"The implementation has no specific limits for the per-process maximum number "
"of shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:300
msgid ""
"Until version 2.3.30 Linux would return B<EIDRM> for a B<shmget>()  on a "
"shared memory segment scheduled for deletion."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:306
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""

#. type: Plain text
#: build/C/man2/shmget.2:314
msgid ""
"B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<ftok>(3), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/shmop.2:41
#, no-wrap
msgid "SHMOP"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:44
msgid "shmat, shmdt - System V shared memory operations"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:50
#, no-wrap
msgid ""
"B<void *shmat(int >I<shmid>B<, const void *>I<shmaddr>B<, int "
">I<shmflg>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:52
#, no-wrap
msgid "B<int shmdt(const void *>I<shmaddr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:61
msgid ""
"B<shmat>()  attaches the System V shared memory segment identified by "
"I<shmid> to the address space of the calling process.  The attaching address "
"is specified by I<shmaddr> with one of the following criteria:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:67
msgid ""
"If I<shmaddr> is NULL, the system chooses a suitable (unused) address at "
"which to attach the segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:82
msgid ""
"If I<shmaddr> isn't NULL and B<SHM_RND> is specified in I<shmflg>, the "
"attach occurs at the address equal to I<shmaddr> rounded down to the nearest "
"multiple of B<SHMLBA>.  Otherwise I<shmaddr> must be a page-aligned address "
"at which the attach occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:92
msgid ""
"If B<SHM_RDONLY> is specified in I<shmflg>, the segment is attached for "
"reading and the process must have read permission for the segment.  "
"Otherwise the segment is attached for read and write and the process must "
"have read and write permission for the segment.  There is no notion of a "
"write-only shared memory segment."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:107
msgid ""
"The (Linux-specific)  B<SHM_REMAP> flag may be specified in I<shmflg> to "
"indicate that the mapping of the segment should replace any existing mapping "
"in the range starting at I<shmaddr> and continuing for the size of the "
"segment.  (Normally an B<EINVAL> error would result if a mapping already "
"exists in this address range.)  In this case, I<shmaddr> must not be NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:114
msgid ""
"The B<brk>(2)  value of the calling process is not altered by the attach.  "
"The segment will automatically be detached at process exit.  The same "
"segment may be attached as a read and as a read-write one, and more than "
"once, in the process's address space."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:122
msgid ""
"A successful B<shmat>()  call updates the members of the I<shmid_ds> "
"structure (see B<shmctl>(2))  associated with the shared memory segment as "
"follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:125
msgid "I<shm_atime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:128 build/C/man2/shmop.2:154
msgid "I<shm_lpid> is set to the process-ID of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:131
msgid "I<shm_nattch> is incremented by one."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:142
msgid ""
"B<shmdt>()  detaches the shared memory segment located at the address "
"specified by I<shmaddr> from the address space of the calling process.  The "
"to-be-detached segment must be currently attached with I<shmaddr> equal to "
"the value returned by the attaching B<shmat>()  call."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:148
msgid ""
"On a successful B<shmdt>()  call the system updates the members of the "
"I<shmid_ds> structure associated with the shared memory segment as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:151
msgid "I<shm_dtime> is set to the current time."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:159
msgid ""
"I<shm_nattch> is decremented by one.  If it becomes 0 and the segment is "
"marked for deletion, the segment is deleted."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:163
msgid "After a B<fork>(2)  the child inherits the attached shared memory segments."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:167
msgid ""
"After an B<execve>(2)  all attached shared memory segments are detached from "
"the process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:171
msgid ""
"Upon B<_exit>(2)  all attached shared memory segments are detached from the "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:179
msgid ""
"On success B<shmat>()  returns the address of the attached shared memory "
"segment; on error I<(void\\ *)\\ -1> is returned, and I<errno> is set to "
"indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:185
msgid ""
"On success B<shmdt>()  returns 0; on error -1 is returned, and I<errno> is "
"set to indicate the cause of the error."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:191
msgid "When B<shmat>()  fails, I<errno> is set to one of the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:197
msgid ""
"The calling process does not have the required permissions for the requested "
"attach type, and does not have the B<CAP_IPC_OWNER> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:214
msgid ""
"Invalid I<shmid> value, unaligned (i.e., not page-aligned and B<SHM_RND> was "
"not specified) or invalid I<shmaddr> value, or can't attach segment at "
"I<shmaddr>, or B<SHM_REMAP> was specified and I<shmaddr> was NULL."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:217
msgid "Could not allocate memory for the descriptor or for the page tables."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:223
msgid "When B<shmdt>()  fails, I<errno> is set as follows:"
msgstr ""

#.  The following since 2.6.17-rc1:
#. type: Plain text
#: build/C/man2/shmop.2:231
msgid ""
"There is no shared memory segment attached at I<shmaddr>; or, I<shmaddr> is "
"not aligned on a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:250
msgid ""
"In SVID 3 (or perhaps earlier)  the type of the I<shmaddr> argument was "
"changed from I<char\\ *> into I<const void\\ *>, and the returned type of "
"B<shmat>()  from I<char\\ *> into I<void\\ *>.  (Linux libc4 and libc5 have "
"the I<char\\ *> prototypes; glibc2 has I<void\\ *>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:262
msgid ""
"Using B<shmat>()  with I<shmaddr> equal to NULL is the preferred, portable "
"way of attaching a shared memory segment.  Be aware that the shared memory "
"segment attached in this way may be attached at different addresses in "
"different processes.  Therefore, any pointers maintained within the shared "
"memory must be made relative (typically to the starting address of the "
"segment), rather than absolute."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:267
msgid ""
"On Linux, it is possible to attach a shared memory segment even if it is "
"already marked to be deleted.  However, POSIX.1-2001 does not specify this "
"behavior and many other implementations do not support it."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:270
msgid "The following system parameter affects B<shmat>():"
msgstr ""

#.  FIXME A good explanation of the rationale for the existence
#.  of SHMLBA would be useful here
#. type: TP
#: build/C/man2/shmop.2:270
#, no-wrap
msgid "B<SHMLBA>"
msgstr ""

#.  FIXME That last sentence isn't true for all Linux
#.  architectures (i.e., SHMLBA != PAGE_SIZE for some architectures)
#.  -- MTK, Nov 04
#. type: Plain text
#: build/C/man2/shmop.2:283
msgid ""
"Segment low boundary address multiple.  Must be page aligned.  For the "
"current implementation the B<SHMLBA> value is B<PAGE_SIZE>."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:287
msgid ""
"The implementation places no intrinsic limit on the per-process maximum "
"number of shared memory segments (B<SHMSEG>)."
msgstr ""

#. type: Plain text
#: build/C/man2/shmop.2:295
msgid ""
"B<brk>(2), B<mmap>(2), B<shmctl>(2), B<shmget>(2), B<capabilities>(7), "
"B<shm_overview>(7), B<svipc>(7)"
msgstr ""

#. type: TH
#: build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "SUBPAGE_PROT"
msgstr ""

#. type: TH
#: build/C/man2/subpage_prot.2:30
#, no-wrap
msgid "2012-07-13"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:33
msgid "subpage_prot - define a subpage protection for an address range"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:37
#, no-wrap
msgid ""
"B<long subpage_prot(unsigned long >I<addr>B<, unsigned long >I<len>B<,>\n"
"B<                  uint32_t *>I<map>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:47
msgid ""
"The PowerPC-specific B<subpage_prot>()  system call provides the facility to "
"control the access permissions on individual 4kB subpages on systems "
"configured with a page size of 64kB."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:54
msgid ""
"The protection map is applied to the memory pages in the region starting at "
"I<addr> and continuing for I<len> bytes.  Both of these arguments must be "
"aligned to a 64-kB boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:66
msgid ""
"The protection map is specified in the buffer pointed to by I<map>.  The map "
"has 2 bits per 4kB subpage; thus each 32-bit word specifies the protections "
"of 16 4kB subpages inside a 64kB page (so, the number of 32-bit words "
"pointed to by I<map> should equate to the number of 64-kB pages specified by "
"I<len>).  Each 2-bit field in the protection map is either 0 to allow any "
"access, 1 to prevent writes, or 2 or 3 to prevent all accesses."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:71
msgid ""
"On success, B<subpage_prot>()  returns 0.  Otherwise, one of the error codes "
"specified below is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:77
msgid "The buffer referred to by I<map> is not accessible."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:87
msgid ""
"The I<addr> or I<len> arguments are incorrect.  Both of these arguments must "
"be aligned to a multiple of the system page size, and they must not refer to "
"a region outside of the address space of the process or to a region that "
"consists of huge pages."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:90 build/C/man2/sync_file_range.2:166
msgid "Out of memory."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:96
msgid ""
"This system call is provided on the PowerPC architecture since Linux "
"2.6.25.  The system call is provided only if the kernel is configured with "
"B<CONFIG_PPC_64K_PAGES>.  No library support is provided."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:101
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:106
msgid ""
"Normal page protections (at the 64-kB page level) also apply; the subpage "
"protection mechanism is an additional constraint, so putting 0 in a 2-bit "
"field won't allow writes to a page that is otherwise write-protected."
msgstr ""

#. type: SS
#: build/C/man2/subpage_prot.2:106
#, no-wrap
msgid "Rationale"
msgstr ""

#.  In the initial implementation, it was the case that:
#.      In fact the whole process is switched to use 4k hardware pages when the
#.      subpage_prot system call is used, but this could be improved in future
#.      to switch only the affected segments.
#.  But Paul Mackerass says (Oct 2010): I'm pretty sure we now only switch
#.  the affected segment, not the whole process.
#. type: Plain text
#: build/C/man2/subpage_prot.2:128
msgid ""
"This system call is provided to assist writing emulators that operate using "
"64-kB pages on PowerPC systems.  When emulating systems such as x86, which "
"uses a smaller page size, the emulator can no longer use the "
"memory-management unit (MMU)  and normal system calls for controlling page "
"protections.  (The emulator could emulate the MMU by checking and possibly "
"remapping the address for each memory access in software, but that is slow.)  "
"The idea is that the emulator supplies an array of protection masks to apply "
"to a specified range of virtual addresses.  These masks are applied at the "
"level where hardware page-table entries (PTEs)  are inserted into the "
"hardware page table based on the Linux PTEs, so the Linux PTEs are not "
"affected.  Implicit in this is that the regions of the address space that "
"are protected are switched to use 4-kB hardware pages rather than 64-kB "
"hardware pages (on machines with hardware 64-kB page support)."
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:131
msgid "B<mprotect>(2), B<syscall>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/subpage_prot.2:134
msgid "I<Documentation/vm/hugetlbpage.txt> in the Linux kernel source tree"
msgstr ""

#. type: TH
#: build/C/man2/sync_file_range.2:30
#, no-wrap
msgid "SYNC_FILE_RANGE"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:33
msgid "sync_file_range - sync a file segment with disk"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:40
#, no-wrap
msgid ""
"B<int sync_file_range(int >I<fd>B<, off64_t >I<offset>B<, off64_t "
">I<nbytes>B<,>\n"
"B<                    unsigned int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:47
msgid ""
"B<sync_file_range>()  permits fine control when synchronizing the open file "
"referred to by the file descriptor I<fd> with disk."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:61
msgid ""
"I<offset> is the starting byte of the file range to be synchronized.  "
"I<nbytes> specifies the length of the range to be synchronized, in bytes; if "
"I<nbytes> is zero, then all bytes from I<offset> through to the end of file "
"are synchronized.  Synchronization is in units of the system page size: "
"I<offset> is rounded down to a page boundary; I<(offset+nbytes-1)> is "
"rounded up to a page boundary."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:65
msgid "The I<flags> bit-mask argument can include any of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:65
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:70
msgid ""
"Wait upon write-out of all pages in the specified range that have already "
"been submitted to the device driver for write-out before performing any "
"write."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:70 build/C/man2/sync_file_range.2:120
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:76
msgid ""
"Initiate write-out of all dirty pages in the specified range which are not "
"presently submitted write-out.  Note that even this may block if you attempt "
"to write more than request queue size."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:76
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:80
msgid "Wait upon write-out of all pages in the range after performing any write."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:84
msgid "Specifying I<flags> as 0 is permitted, as a no-op."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:84
#, no-wrap
msgid "Warning"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:100
msgid ""
"This system call is extremely dangerous and should not be used in portable "
"programs.  None of these operations writes out the file's metadata.  "
"Therefore, unless the application is strictly performing overwrites of "
"already-instantiated disk blocks, there are no guarantees that the data will "
"be available after a crash.  There is no user interface to know if a write "
"is purely an overwrite.  On file systems using copy-on-write semantics "
"(e.g., I<btrfs>)  an overwrite of existing allocated blocks is impossible.  "
"When writing into preallocated space, many file systems also require calls "
"into the block allocator, which this system call does not sync out to disk.  "
"This system call does not flush disk write caches and thus does not provide "
"any data integrity on systems with volatile disk write caches."
msgstr ""

#. type: SS
#: build/C/man2/sync_file_range.2:100
#, no-wrap
msgid "Some details"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:108
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE> and B<SYNC_FILE_RANGE_WAIT_AFTER> will detect "
"any I/O errors or B<ENOSPC> conditions and will return these to the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:112
msgid "Useful combinations of the I<flags> bits are:"
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:112
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:120
msgid ""
"Ensures that all pages in the specified range which were dirty when "
"B<sync_file_range>()  was called are placed under write-out.  This is a "
"start-write-for-data-integrity operation."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:127
msgid ""
"Start write-out of all dirty pages in the specified range which are not "
"presently under write-out.  This is an asynchronous flush-to-disk "
"operation.  This is not suitable for data integrity operations."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:127
#, no-wrap
msgid "B<SYNC_FILE_RANGE_WAIT_BEFORE> (or B<SYNC_FILE_RANGE_WAIT_AFTER>)"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:134
msgid ""
"Wait for completion of write-out of all pages in the specified range.  This "
"can be used after an earlier B<SYNC_FILE_RANGE_WAIT_BEFORE | "
"SYNC_FILE_RANGE_WRITE> operation to wait for completion of that operation, "
"and obtain its result."
msgstr ""

#. type: TP
#: build/C/man2/sync_file_range.2:134
#, no-wrap
msgid ""
"B<SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE | "
"SYNC_FILE_RANGE_WAIT_AFTER>"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:141
msgid ""
"This is a write-for-data-integrity operation that will ensure that all pages "
"in the specified range which were dirty when B<sync_file_range>()  was "
"called are committed to disk."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:147
msgid ""
"On success, B<sync_file_range>()  returns 0; on failure -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:152
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:160
msgid "I<flags> specifies an invalid bit; or I<offset> or I<nbytes> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:163
msgid "I/O error."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:169
msgid "Out of disk space."
msgstr ""

#.  FIXME . (bug?) Actually, how can 'fd' refer to a symbolic link (S_ISLNK)?
#.  (In user space at least) it isn't possible to obtain a file descriptor
#.  for a symbolic link.
#. type: Plain text
#: build/C/man2/sync_file_range.2:177
msgid ""
"I<fd> refers to something other than a regular file, a block device, a "
"directory, or a symbolic link."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:180
msgid "B<sync_file_range>()  appeared on Linux in kernel 2.6.17."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:183
msgid ""
"This system call is Linux-specific, and should be avoided in portable "
"programs."
msgstr ""

#.  See kernel commit edd5cd4a9424f22b0fa08bef5e299d41befd5622
#. type: Plain text
#: build/C/man2/sync_file_range.2:200
msgid ""
"Some architectures (e.g., PowerPC, ARM)  need 64-bit arguments to be aligned "
"in a suitable pair of registers.  On such architectures, the call signature "
"of B<sync_file_range>()  shown in the SYNOPSIS would force a register to be "
"wasted as padding between the I<fd> and I<offset> arguments.  (See "
"B<syscall>(2)  for details.)  Therefore, these architectures define a "
"different system call that orders the arguments suitably:"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:205
#, no-wrap
msgid ""
"B<int sync_file_range2(int >I<fd>B<, unsigned int >I<flags>B<,>\n"
"B<                     off64_t >I<offset>B<, off64_t >I<nbytes>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:210
msgid ""
"The behavior of this system call is otherwise exactly the same as "
"B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:221
msgid ""
"A system call with this signature first appeared on the ARM architecture in "
"Linux 2.6.20, with the name B<arm_sync_file_range>().  It was renamed in "
"Linux 2.6.22, when the analogous system call was added for PowerPC.  On "
"architectures where glibc support is provided, glibc transparently wraps "
"B<sync_file_range2>()  under the name B<sync_file_range>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sync_file_range.2:226
msgid "B<fdatasync>(2), B<fsync>(2), B<msync>(2), B<sync>(2)"
msgstr ""

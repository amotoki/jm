# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-13 10:27+0900\n"
"PO-Revision-Date: 2014-04-14 02:36+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/_syscall.2:38
#, no-wrap
msgid "_SYSCALL"
msgstr "_SYSCALL"

#. type: TH
#: build/C/man2/_syscall.2:38
#, no-wrap
msgid "2007-12-19"
msgstr "2007-12-19"

#. type: TH
#: build/C/man2/_syscall.2:38 build/C/man2/access.2:43 build/C/man2/alarm.2:30
#: build/C/man2/brk.2:29 build/C/man2/chdir.2:33 build/C/man2/chmod.2:32
#: build/C/man2/chown.2:38 build/C/man2/chroot.2:33 build/C/man2/close.2:35
#: build/C/man2/dup.2:36 build/C/man7/environ.7:34 build/C/man2/execve.2:37
#: build/C/man2/exit_group.2:25 build/C/man2/fcntl.2:61
#: build/C/man3/fexecve.3:25 build/C/man2/flock.2:35 build/C/man2/fork.2:39
#: build/C/man2/fsync.2:38 build/C/man2/get_thread_area.2:8
#: build/C/man2/getdomainname.2:29 build/C/man3/getdtablesize.3:27
#: build/C/man3/gethostid.3:29 build/C/man2/gethostname.2:32
#: build/C/man2/getpagesize.2:25 build/C/man2/gettid.2:26
#: build/C/man2/idle.2:32 build/C/man2/ioctl.2:41 build/C/man2/ioctl_list.2:30
#: build/C/man2/ioperm.2:34 build/C/man2/mincore.2:34 build/C/man2/mkdir.2:11
#: build/C/man2/nice.2:31 build/C/man2/pread.2:25
#: build/C/man2/set_thread_area.2:8 build/C/man2/setup.2:34
#: build/C/man2/swapon.2:37 build/C/man2/syscall.2:40
#: build/C/man2/syscalls.2:31 build/C/man2/sysctl.2:30
#: build/C/man2/sysinfo.2:14 build/C/man2/truncate.2:43
#: build/C/man2/umask.2:34 build/C/man2/uname.2:27 build/C/man2/uselib.2:31
#: build/C/man2/vfork.2:28 build/C/man2/vhangup.2:28
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/_syscall.2:38 build/C/man2/access.2:43 build/C/man2/alarm.2:30
#: build/C/man2/brk.2:29 build/C/man2/chdir.2:33 build/C/man2/chmod.2:32
#: build/C/man2/chown.2:38 build/C/man2/chroot.2:33 build/C/man2/close.2:35
#: build/C/man3/confstr.3:31 build/C/man3/crypt.3:36 build/C/man3/daemon.3:36
#: build/C/man3/des_crypt.3:14 build/C/man2/dup.2:36 build/C/man3/encrypt.3:30
#: build/C/man7/environ.7:34 build/C/man3/euidaccess.3:25
#: build/C/man3/exec.3:41 build/C/man2/execve.2:37
#: build/C/man2/exit_group.2:25 build/C/man2/fcntl.2:61
#: build/C/man3/fexecve.3:25 build/C/man2/flock.2:35 build/C/man2/fork.2:39
#: build/C/man3/fpathconf.3:41 build/C/man2/fsync.2:38
#: build/C/man3/get_nprocs_conf.3:26 build/C/man2/get_thread_area.2:8
#: build/C/man3/getcwd.3:32 build/C/man2/getdomainname.2:29
#: build/C/man3/getdtablesize.3:27 build/C/man3/gethostid.3:29
#: build/C/man2/gethostname.2:32 build/C/man3/getlogin.3:28
#: build/C/man3/getopt.3:41 build/C/man2/getpagesize.2:25
#: build/C/man2/gettid.2:26 build/C/man3/getumask.3:28
#: build/C/man3/getusershell.3:30 build/C/man2/idle.2:32
#: build/C/man2/ioctl.2:41 build/C/man2/ioctl_list.2:30
#: build/C/man2/ioperm.2:34 build/C/man3/lockf.3:28 build/C/man2/mincore.2:34
#: build/C/man2/mkdir.2:11 build/C/man2/nice.2:31 build/C/man2/pread.2:25
#: build/C/man2/set_thread_area.2:8 build/C/man2/setup.2:34
#: build/C/man5/shells.5:28 build/C/man3/sleep.3:26 build/C/man3/swab.3:31
#: build/C/man2/swapon.2:37 build/C/man2/syscall.2:40
#: build/C/man2/syscalls.2:31 build/C/man3/sysconf.3:27
#: build/C/man2/sysctl.2:30 build/C/man2/sysinfo.2:14
#: build/C/man3/tcgetpgrp.3:25 build/C/man2/truncate.2:43
#: build/C/man3/ualarm.3:24 build/C/man2/umask.2:34 build/C/man2/uname.2:27
#: build/C/man2/uselib.2:31 build/C/man3/usleep.3:33 build/C/man2/vfork.2:28
#: build/C/man2/vhangup.2:28
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/_syscall.2:39 build/C/man2/access.2:44 build/C/man2/alarm.2:31
#: build/C/man2/brk.2:30 build/C/man2/chdir.2:34 build/C/man2/chmod.2:33
#: build/C/man2/chown.2:39 build/C/man2/chroot.2:34 build/C/man2/close.2:36
#: build/C/man3/confstr.3:32 build/C/man3/crypt.3:37 build/C/man3/daemon.3:37
#: build/C/man3/des_crypt.3:15 build/C/man2/dup.2:37 build/C/man3/encrypt.3:31
#: build/C/man7/environ.7:35 build/C/man3/euidaccess.3:26
#: build/C/man3/exec.3:42 build/C/man2/execve.2:38
#: build/C/man2/exit_group.2:26 build/C/man2/fcntl.2:62
#: build/C/man3/fexecve.3:26 build/C/man2/flock.2:36 build/C/man2/fork.2:40
#: build/C/man3/fpathconf.3:42 build/C/man2/fsync.2:39
#: build/C/man3/get_nprocs_conf.3:27 build/C/man2/get_thread_area.2:9
#: build/C/man3/getcwd.3:33 build/C/man2/getdomainname.2:30
#: build/C/man3/getdtablesize.3:28 build/C/man3/gethostid.3:30
#: build/C/man2/gethostname.2:33 build/C/man3/getlogin.3:29
#: build/C/man3/getopt.3:42 build/C/man2/getpagesize.2:26
#: build/C/man2/gettid.2:27 build/C/man3/getumask.3:29
#: build/C/man3/getusershell.3:31 build/C/man2/idle.2:33
#: build/C/man2/ioctl.2:42 build/C/man2/ioctl_list.2:31
#: build/C/man2/ioperm.2:35 build/C/man3/lockf.3:29 build/C/man2/mincore.2:35
#: build/C/man2/mkdir.2:12 build/C/man2/nice.2:32 build/C/man2/pread.2:26
#: build/C/man2/set_thread_area.2:9 build/C/man2/setup.2:35
#: build/C/man5/shells.5:29 build/C/man3/sleep.3:27 build/C/man3/swab.3:32
#: build/C/man2/swapon.2:38 build/C/man2/syscall.2:41
#: build/C/man2/syscalls.2:32 build/C/man3/sysconf.3:28
#: build/C/man2/sysctl.2:31 build/C/man2/sysinfo.2:15
#: build/C/man3/tcgetpgrp.3:26 build/C/man2/truncate.2:44
#: build/C/man3/ualarm.3:25 build/C/man2/umask.2:35 build/C/man2/uname.2:28
#: build/C/man2/uselib.2:32 build/C/man3/usleep.3:34 build/C/man2/vfork.2:29
#: build/C/man2/vhangup.2:29
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/_syscall.2:41
msgid "_syscall - invoking a system call without library support (OBSOLETE)"
msgstr ""
"_syscall - ライブラリのサポートなしでシステムコールを起動する (昔の方法)"

#. type: SH
#: build/C/man2/_syscall.2:41 build/C/man2/access.2:46 build/C/man2/alarm.2:33
#: build/C/man2/brk.2:32 build/C/man2/chdir.2:36 build/C/man2/chmod.2:35
#: build/C/man2/chown.2:41 build/C/man2/chroot.2:36 build/C/man2/close.2:38
#: build/C/man3/confstr.3:34 build/C/man3/crypt.3:39 build/C/man3/daemon.3:39
#: build/C/man3/des_crypt.3:18 build/C/man2/dup.2:39 build/C/man3/encrypt.3:33
#: build/C/man7/environ.7:37 build/C/man3/euidaccess.3:28
#: build/C/man3/exec.3:44 build/C/man2/execve.2:40
#: build/C/man2/exit_group.2:28 build/C/man2/fcntl.2:64
#: build/C/man3/fexecve.3:28 build/C/man2/flock.2:38 build/C/man2/fork.2:42
#: build/C/man3/fpathconf.3:44 build/C/man2/fsync.2:41
#: build/C/man3/get_nprocs_conf.3:29 build/C/man2/get_thread_area.2:11
#: build/C/man3/getcwd.3:35 build/C/man2/getdomainname.2:32
#: build/C/man3/getdtablesize.3:30 build/C/man3/gethostid.3:32
#: build/C/man2/gethostname.2:35 build/C/man3/getlogin.3:31
#: build/C/man3/getopt.3:45 build/C/man2/getpagesize.2:28
#: build/C/man2/gettid.2:29 build/C/man3/getumask.3:31
#: build/C/man3/getusershell.3:33 build/C/man2/idle.2:35
#: build/C/man2/ioctl.2:44 build/C/man2/ioperm.2:37 build/C/man3/lockf.3:31
#: build/C/man2/mincore.2:37 build/C/man2/mkdir.2:14 build/C/man2/nice.2:34
#: build/C/man2/pread.2:28 build/C/man2/set_thread_area.2:11
#: build/C/man2/setup.2:37 build/C/man3/sleep.3:29 build/C/man3/swab.3:34
#: build/C/man2/swapon.2:40 build/C/man2/syscall.2:43
#: build/C/man2/syscalls.2:34 build/C/man3/sysconf.3:30
#: build/C/man2/sysctl.2:33 build/C/man2/sysinfo.2:17
#: build/C/man3/tcgetpgrp.3:28 build/C/man2/truncate.2:46
#: build/C/man3/ualarm.3:27 build/C/man2/umask.2:37 build/C/man2/uname.2:30
#: build/C/man2/uselib.2:34 build/C/man3/usleep.3:36 build/C/man2/vfork.2:31
#: build/C/man2/vhangup.2:31
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/_syscall.2:43 build/C/man2/get_thread_area.2:13
#: build/C/man2/set_thread_area.2:13
msgid "B<#include E<lt>linux/unistd.hE<gt>>"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/_syscall.2:45
msgid "A _syscall macro"
msgstr "A _syscall macro"

#. type: Plain text
#: build/C/man2/_syscall.2:47
msgid "desired system call"
msgstr "desired system call"

#. type: SH
#: build/C/man2/_syscall.2:47 build/C/man2/access.2:78 build/C/man2/alarm.2:39
#: build/C/man2/brk.2:64 build/C/man2/chdir.2:59 build/C/man2/chmod.2:81
#: build/C/man2/chown.2:88 build/C/man2/chroot.2:63 build/C/man2/close.2:44
#: build/C/man3/confstr.3:48 build/C/man3/crypt.3:56 build/C/man3/daemon.3:51
#: build/C/man3/des_crypt.3:34 build/C/man2/dup.2:52 build/C/man3/encrypt.3:56
#: build/C/man7/environ.7:42 build/C/man3/euidaccess.3:36
#: build/C/man3/exec.3:72 build/C/man2/execve.2:46
#: build/C/man2/exit_group.2:34 build/C/man2/fcntl.2:71
#: build/C/man3/fexecve.3:53 build/C/man2/flock.2:42 build/C/man2/fork.2:46
#: build/C/man3/fpathconf.3:52 build/C/man2/fsync.2:61
#: build/C/man3/get_nprocs_conf.3:35 build/C/man2/get_thread_area.2:20
#: build/C/man3/getcwd.3:75 build/C/man2/getdomainname.2:51
#: build/C/man3/getdtablesize.3:57 build/C/man3/gethostid.3:56
#: build/C/man2/gethostname.2:63 build/C/man3/getlogin.3:52
#: build/C/man3/getopt.3:79 build/C/man2/getpagesize.2:55
#: build/C/man2/gettid.2:38 build/C/man3/getumask.3:39
#: build/C/man3/getusershell.3:57 build/C/man2/idle.2:39
#: build/C/man2/ioctl.2:50 build/C/man2/ioctl_list.2:33
#: build/C/man2/ioperm.2:45 build/C/man3/lockf.3:48 build/C/man2/mincore.2:51
#: build/C/man2/mkdir.2:47 build/C/man2/nice.2:46 build/C/man2/pread.2:53
#: build/C/man2/set_thread_area.2:20 build/C/man2/setup.2:41
#: build/C/man5/shells.5:31 build/C/man3/sleep.3:35 build/C/man3/swab.3:41
#: build/C/man2/swapon.2:50 build/C/man2/syscall.2:51
#: build/C/man2/syscalls.2:36 build/C/man3/sysconf.3:36
#: build/C/man2/sysctl.2:44 build/C/man2/sysinfo.2:21
#: build/C/man3/tcgetpgrp.3:34 build/C/man2/truncate.2:79
#: build/C/man3/ualarm.3:58 build/C/man2/umask.2:43 build/C/man2/uname.2:34
#: build/C/man2/uselib.2:38 build/C/man3/usleep.3:67 build/C/man2/vfork.2:62
#: build/C/man2/vhangup.2:45
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/_syscall.2:53
msgid ""
"The important thing to know about a system call is its prototype.  You need "
"to know how many arguments, their types, and the function return type.  "
"There are seven macros that make the actual call into the system easier.  "
"They have the form:"
msgstr ""
"システムコールに関してそのプロトタイプを知ることが重要である。 引き数の個数、"
"それらの型、返り値の型を知る必要がある。 実際の使用にあたっては、システムコー"
"ルをシステムに呼び出しやすくするために、 7 個のマクロが用意されている。これら"
"のマクロは以下の形である。"

#. type: Plain text
#: build/C/man2/_syscall.2:56
msgid "_syscallI<X>(I<type>,I<name>,I<type1>,I<arg1>,I<type2>,I<arg2>,...)"
msgstr "_syscallI<X>(I<type>,I<name>,I<type1>,I<arg1>,I<type2>,I<arg2>,...)"

#. type: Plain text
#: build/C/man2/_syscall.2:59
msgid "where"
msgstr "ここで"

#. type: Plain text
#: build/C/man2/_syscall.2:63
msgid ""
"I<X> is 0\\(en6, which are the number of arguments taken by the system call"
msgstr "I<X> は 0〜6 で、システムコールが取る引き数の個数である。"

#. type: Plain text
#: build/C/man2/_syscall.2:66
msgid "I<type> is the return type of the system call"
msgstr "I<type> はシステムコールの返り値の型である。"

#. type: Plain text
#: build/C/man2/_syscall.2:69
msgid "I<name> is the name of the system call"
msgstr "I<name> はシステムコールの名前である。"

#. type: Plain text
#: build/C/man2/_syscall.2:72
msgid "I<typeN> is the Nth argument's type"
msgstr "I<typeN> は N 番目の引き数の型である。"

#. type: Plain text
#: build/C/man2/_syscall.2:75
msgid "I<argN> is the name of the Nth argument"
msgstr "I<argN> は N 番目の引き数の名前である。"

#. type: Plain text
#: build/C/man2/_syscall.2:83
msgid ""
"These macros create a function called I<name> with the arguments you "
"specify.  Once you include the _syscall() in your source file, you call the "
"system call by I<name>."
msgstr ""
"これらのマクロは、指定した引き数を持つ I<name> という名前の関数を生成する。 "
"一度ソースファイルの中で _syscall() をインクルードしておくと、 そのシステム"
"コールを I<name> という名前で呼ぶことができる。"

#. type: SH
#: build/C/man2/_syscall.2:83 build/C/man3/getlogin.3:132
#: build/C/man3/getusershell.3:89 build/C/man5/shells.5:43
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man2/_syscall.2:85
msgid "I</usr/include/linux/unistd.h>"
msgstr "I</usr/include/linux/unistd.h>"

#. type: SH
#: build/C/man2/_syscall.2:85 build/C/man2/access.2:262
#: build/C/man2/alarm.2:59 build/C/man2/brk.2:114 build/C/man2/chdir.2:125
#: build/C/man2/chmod.2:330 build/C/man2/chown.2:308 build/C/man2/chroot.2:134
#: build/C/man2/close.2:84 build/C/man3/confstr.3:127 build/C/man3/crypt.3:183
#: build/C/man3/daemon.3:96 build/C/man3/des_crypt.3:142
#: build/C/man2/dup.2:170 build/C/man3/encrypt.3:137
#: build/C/man3/euidaccess.3:80 build/C/man3/exec.3:199
#: build/C/man2/execve.2:456 build/C/man2/exit_group.2:43
#: build/C/man2/fcntl.2:1162 build/C/man3/fexecve.3:94
#: build/C/man2/flock.2:138 build/C/man2/fork.2:206
#: build/C/man3/fpathconf.3:169 build/C/man2/fsync.2:125
#: build/C/man3/get_nprocs_conf.3:48 build/C/man2/get_thread_area.2:46
#: build/C/man3/getcwd.3:208 build/C/man2/getdomainname.2:110
#: build/C/man3/getdtablesize.3:69 build/C/man3/gethostid.3:92
#: build/C/man2/gethostname.2:124 build/C/man3/getlogin.3:154
#: build/C/man3/getopt.3:318 build/C/man2/getpagesize.2:64
#: build/C/man2/gettid.2:58 build/C/man3/getumask.3:58
#: build/C/man3/getusershell.3:101 build/C/man2/idle.2:61
#: build/C/man2/ioctl.2:119 build/C/man2/ioperm.2:104 build/C/man3/lockf.3:154
#: build/C/man2/mincore.2:134 build/C/man2/mkdir.2:204 build/C/man2/nice.2:75
#: build/C/man2/pread.2:115 build/C/man2/set_thread_area.2:63
#: build/C/man2/setup.2:62 build/C/man3/sleep.3:44 build/C/man3/swab.3:77
#: build/C/man2/swapon.2:159 build/C/man3/sysconf.3:324
#: build/C/man2/sysctl.2:100 build/C/man2/sysinfo.2:83
#: build/C/man3/tcgetpgrp.3:116 build/C/man2/truncate.2:195
#: build/C/man3/ualarm.3:97 build/C/man2/umask.2:95 build/C/man2/uname.2:73
#: build/C/man2/uselib.2:76 build/C/man3/usleep.3:96 build/C/man2/vfork.2:159
#: build/C/man2/vhangup.2:63
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/_syscall.2:87
msgid "The use of these macros is Linux-specific, and deprecated."
msgstr "これらのマクロは Linux 固有であり、その使用は非推奨である。"

#. type: SH
#: build/C/man2/_syscall.2:87 build/C/man2/access.2:268
#: build/C/man2/alarm.2:61 build/C/man2/brk.2:122 build/C/man2/chdir.2:127
#: build/C/man2/chmod.2:337 build/C/man2/chown.2:325 build/C/man2/chroot.2:139
#: build/C/man2/close.2:87 build/C/man3/crypt.3:188 build/C/man3/daemon.3:102
#: build/C/man2/dup.2:180 build/C/man3/encrypt.3:148
#: build/C/man3/euidaccess.3:86 build/C/man3/exec.3:205
#: build/C/man2/execve.2:464 build/C/man2/exit_group.2:45
#: build/C/man2/fcntl.2:1212 build/C/man3/fexecve.3:99
#: build/C/man2/flock.2:147 build/C/man2/fork.2:208
#: build/C/man3/fpathconf.3:171 build/C/man2/fsync.2:140
#: build/C/man3/get_nprocs_conf.3:50 build/C/man2/get_thread_area.2:50
#: build/C/man3/getcwd.3:230 build/C/man2/getdomainname.2:113
#: build/C/man3/getdtablesize.3:77 build/C/man3/gethostid.3:102
#: build/C/man2/gethostname.2:130 build/C/man3/getopt.3:350
#: build/C/man2/getpagesize.2:71 build/C/man2/gettid.2:62
#: build/C/man3/getumask.3:60 build/C/man2/ioctl.2:134
#: build/C/man2/ioperm.2:108 build/C/man2/mkdir.2:211 build/C/man2/nice.2:82
#: build/C/man2/pread.2:117 build/C/man2/set_thread_area.2:67
#: build/C/man2/setup.2:65 build/C/man2/swapon.2:165 build/C/man2/syscall.2:78
#: build/C/man2/syscalls.2:655 build/C/man2/sysctl.2:114
#: build/C/man3/tcgetpgrp.3:118 build/C/man2/truncate.2:208
#: build/C/man3/ualarm.3:105 build/C/man2/umask.2:97 build/C/man2/uname.2:82
#: build/C/man2/uselib.2:80 build/C/man3/usleep.3:114 build/C/man2/vfork.2:174
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/_syscall.2:97
msgid ""
"Starting around kernel 2.6.18, the _syscall macros were removed from header "
"files supplied to user space.  Use B<syscall>(2)  instead.  (Some "
"architectures, notably ia64, never provided the _syscall macros; on those "
"architectures, B<syscall>(2)  was always required.)"
msgstr ""
"カーネル 2.6.18 あたりから、_syscall マクロ群はユーザ空間に対して提供される "
"ヘッダファイルから削除された。代わりに B<syscall>(2)  を使用すること。 (いく"
"つかのアーキテクチャ、特に ia64、では、これまで _syscall マクロが 提供された"
"ことはない。このようなアーキテクチャでは、常に B<syscall>(2)  が必要であっ"
"た。)"

#. type: Plain text
#: build/C/man2/_syscall.2:103
msgid ""
"The _syscall() macros I<do not> produce a prototype.  You may have to create "
"one, especially for C++ users."
msgstr ""
"_syscall() マクロはプロトタイプを「生成しない」。 ユーザはプロトタイプを自分"
"で書かなければならないかもしれない。 とりわけ C++ ユーザの場合はそうであろ"
"う。"

#. type: Plain text
#: build/C/man2/_syscall.2:124
msgid ""
"System calls are not required to return only positive or negative error "
"codes.  You need to read the source to be sure how it will return errors.  "
"Usually, it is the negative of a standard error code, for example, -"
"I<EPERM>.  The _syscall() macros will return the result I<r> of the system "
"call when I<r> is nonnegative, but will return -1 and set the variable "
"I<errno> to -I<r> when I<r> is negative.  For the error codes, see B<errno>"
"(3)."
msgstr ""
"システムコールは、正のエラーコードのみ、または負のエラーコードのみを返すよう"
"に 定められている訳ではない。そのシステムコールがどのようなエラーコードを返す"
"かを 確認するには、そのソースコードを読む必要がある。たいていの場合は、標準の"
"エラー コードを負にしたものである (例えば -I<EPERM>)。 _syscall() マクロは、"
"そのシステムコールの返り値 I<r> が負でない場合、その値 をそのまま返す。一方、"
"I<r> が負の場合には、変数 I<errno> に -I<r> を設定し、-1 を返す。 エラーコー"
"ドについては B<errno>(3)  を参照。"

#.  The preferred way to invoke system calls that glibc does not know
#.  about yet is via
#.  .BR syscall (2).
#.  However, this mechanism can be used only if using a libc
#.  (such as glibc) that supports
#.  .BR syscall (2),
#.  and if the
#.  .I <sys/syscall.h>
#.  header file contains the required SYS_foo definition.
#.  Otherwise, the use of a _syscall macro is required.
#. type: Plain text
#: build/C/man2/_syscall.2:140
msgid ""
"When defining a system call, the argument types I<must> be passed by-value "
"or by-pointer (for aggregates like structs)."
msgstr ""
"システムコールを定義する際、引き数の型は値渡し (by-value) か、 (構造体のよう"
"に集合的なデータの場合は) ポインタ渡し (by-pointer)  でなければならない。"

#. type: SH
#: build/C/man2/_syscall.2:140 build/C/man2/chown.2:421
#: build/C/man3/confstr.3:129 build/C/man3/encrypt.3:150
#: build/C/man2/execve.2:550 build/C/man2/fork.2:239
#: build/C/man3/get_nprocs_conf.3:67 build/C/man3/getopt.3:376
#: build/C/man5/shells.5:45 build/C/man2/syscall.2:203
#: build/C/man2/sysctl.2:143
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man2/_syscall.2:147
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>linux/unistd.hE<gt>       /* for _syscallX macros/related stuff */\n"
"#include E<lt>linux/kernel.hE<gt>       /* for struct sysinfo */\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>linux/unistd.hE<gt>       /* for _syscallX macros/related stuff */\n"
"#include E<lt>linux/kernel.hE<gt>       /* for struct sysinfo */\n"

#. type: Plain text
#: build/C/man2/_syscall.2:149
#, no-wrap
msgid "_syscall1(int, sysinfo, struct sysinfo *, info);\n"
msgstr "_syscall1(int, sysinfo, struct sysinfo *, info);\n"

#. type: Plain text
#: build/C/man2/_syscall.2:152
#, no-wrap
msgid ""
"/* Note: if you copy directly from the nroff source, remember to\n"
"REMOVE the extra backslashes in the printf statement. */\n"
msgstr ""
"/* Note: nroff のソースファイルから直接コピーする際には、\n"
"printf 文内の余分なバックスラッシュを忘れずに削除するように。 */\n"

#. type: Plain text
#: build/C/man2/_syscall.2:158
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct sysinfo s_info;\n"
"    int error;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct sysinfo s_info;\n"
"    int error;\n"

#. type: Plain text
#: build/C/man2/_syscall.2:173
#, no-wrap
msgid ""
"    error = sysinfo(&s_info);\n"
"    printf(\"code error = %d\\en\", error);\n"
"    printf(\"Uptime = %lds\\enLoad: 1 min %lu / 5 min %lu / 15 min %lu\\en\"\n"
"           \"RAM: total %lu / free %lu / shared %lu\\en\"\n"
"           \"Memory in buffers = %lu\\enSwap: total %lu / free %lu\\en\"\n"
"           \"Number of processes = %d\\en\",\n"
"           s_info.uptime, s_info.loads[0],\n"
"           s_info.loads[1], s_info.loads[2],\n"
"           s_info.totalram, s_info.freeram,\n"
"           s_info.sharedram, s_info.bufferram,\n"
"           s_info.totalswap, s_info.freeswap,\n"
"           s_info.procs);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    error = sysinfo(&s_info);\n"
"    printf(\"code error = %d\\en\", error);\n"
"    printf(\"Uptime = %lds\\enLoad: 1 min %lu / 5 min %lu / 15 min %lu\\en\"\n"
"           \"RAM: total %lu / free %lu / shared %lu\\en\"\n"
"           \"Memory in buffers = %lu\\enSwap: total %lu / free %lu\\en\"\n"
"           \"Number of processes = %d\\en\",\n"
"           s_info.uptime, s_info.loads[0],\n"
"           s_info.loads[1], s_info.loads[2],\n"
"           s_info.totalram, s_info.freeram,\n"
"           s_info.sharedram, s_info.bufferram,\n"
"           s_info.totalswap, s_info.freeswap,\n"
"           s_info.procs);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SS
#: build/C/man2/_syscall.2:174
#, no-wrap
msgid "Sample output"
msgstr "出力例"

#. type: Plain text
#: build/C/man2/_syscall.2:183
#, no-wrap
msgid ""
"code error = 0\n"
"uptime = 502034s\n"
"Load: 1 min 13376 / 5 min 5504 / 15 min 1152\n"
"RAM: total 15343616 / free 827392 / shared 8237056\n"
"Memory in buffers = 5066752\n"
"Swap: total 27881472 / free 24698880\n"
"Number of processes = 40\n"
msgstr ""
"code error = 0\n"
"uptime = 502034s\n"
"Load: 1 min 13376 / 5 min 5504 / 15 min 1152\n"
"RAM: total 15343616 / free 827392 / shared 8237056\n"
"Memory in buffers = 5066752\n"
"Swap: total 27881472 / free 24698880\n"
"Number of processes = 40\n"

#. type: SH
#: build/C/man2/_syscall.2:184 build/C/man2/access.2:372
#: build/C/man2/alarm.2:86 build/C/man2/brk.2:164 build/C/man2/chdir.2:136
#: build/C/man2/chmod.2:347 build/C/man2/chown.2:469 build/C/man2/chroot.2:151
#: build/C/man2/close.2:131 build/C/man3/confstr.3:146
#: build/C/man3/crypt.3:249 build/C/man3/daemon.3:110
#: build/C/man3/des_crypt.3:145 build/C/man2/dup.2:207
#: build/C/man3/encrypt.3:174 build/C/man7/environ.7:248
#: build/C/man3/euidaccess.3:101 build/C/man3/exec.3:241
#: build/C/man2/execve.2:645 build/C/man2/exit_group.2:49
#: build/C/man2/fcntl.2:1326 build/C/man3/fexecve.3:124
#: build/C/man2/flock.2:201 build/C/man2/fork.2:244
#: build/C/man3/fpathconf.3:180 build/C/man2/fsync.2:162
#: build/C/man2/get_thread_area.2:55 build/C/man3/getcwd.3:249
#: build/C/man2/getdomainname.2:127 build/C/man3/getdtablesize.3:90
#: build/C/man3/gethostid.3:124 build/C/man2/gethostname.2:176
#: build/C/man3/getlogin.3:209 build/C/man3/getopt.3:514
#: build/C/man2/getpagesize.2:108 build/C/man2/gettid.2:71
#: build/C/man3/getumask.3:63 build/C/man3/getusershell.3:103
#: build/C/man2/ioctl.2:142 build/C/man2/ioctl_list.2:963
#: build/C/man2/ioperm.2:121 build/C/man3/lockf.3:156
#: build/C/man2/mincore.2:166 build/C/man2/mkdir.2:223 build/C/man2/nice.2:105
#: build/C/man2/pread.2:158 build/C/man2/set_thread_area.2:72
#: build/C/man5/shells.5:56 build/C/man3/sleep.3:61 build/C/man3/swab.3:79
#: build/C/man2/swapon.2:199 build/C/man2/syscall.2:220
#: build/C/man2/syscalls.2:832 build/C/man3/sysconf.3:335
#: build/C/man2/sysctl.2:181 build/C/man2/sysinfo.2:94
#: build/C/man3/tcgetpgrp.3:127 build/C/man2/truncate.2:256
#: build/C/man3/ualarm.3:147 build/C/man2/umask.2:118 build/C/man2/uname.2:167
#: build/C/man2/uselib.2:102 build/C/man3/usleep.3:147
#: build/C/man2/vfork.2:273 build/C/man2/vhangup.2:66
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/_syscall.2:188
msgid "B<intro>(2), B<syscall>(2), B<errno>(3)"
msgstr "B<intro>(2), B<syscall>(2), B<errno>(3)"

#. type: SH
#: build/C/man2/_syscall.2:188 build/C/man2/access.2:383
#: build/C/man2/alarm.2:95 build/C/man2/brk.2:169 build/C/man2/chdir.2:140
#: build/C/man2/chmod.2:354 build/C/man2/chown.2:474 build/C/man2/chroot.2:154
#: build/C/man2/close.2:138 build/C/man3/confstr.3:150
#: build/C/man3/crypt.3:255 build/C/man3/daemon.3:113
#: build/C/man3/des_crypt.3:149 build/C/man2/dup.2:211
#: build/C/man3/encrypt.3:179 build/C/man7/environ.7:262
#: build/C/man3/euidaccess.3:112 build/C/man3/exec.3:248
#: build/C/man2/execve.2:656 build/C/man2/exit_group.2:51
#: build/C/man2/fcntl.2:1347 build/C/man3/fexecve.3:126
#: build/C/man2/flock.2:215 build/C/man2/fork.2:255
#: build/C/man3/fpathconf.3:185 build/C/man2/fsync.2:171
#: build/C/man3/get_nprocs_conf.3:88 build/C/man2/get_thread_area.2:58
#: build/C/man3/getcwd.3:256 build/C/man2/getdomainname.2:131
#: build/C/man3/getdtablesize.3:95 build/C/man3/gethostid.3:127
#: build/C/man2/gethostname.2:180 build/C/man3/getlogin.3:213
#: build/C/man3/getopt.3:516 build/C/man2/getpagesize.2:111
#: build/C/man2/gettid.2:90 build/C/man3/getumask.3:65
#: build/C/man3/getusershell.3:105 build/C/man2/idle.2:64
#: build/C/man2/ioctl.2:150 build/C/man2/ioctl_list.2:965
#: build/C/man2/ioperm.2:125 build/C/man3/lockf.3:171
#: build/C/man2/mincore.2:169 build/C/man2/mkdir.2:234 build/C/man2/nice.2:112
#: build/C/man2/pread.2:163 build/C/man2/set_thread_area.2:74
#: build/C/man2/setup.2:72 build/C/man5/shells.5:59 build/C/man3/sleep.3:66
#: build/C/man3/swab.3:81 build/C/man2/swapon.2:203 build/C/man2/syscall.2:225
#: build/C/man2/syscalls.2:838 build/C/man3/sysconf.3:343
#: build/C/man2/sysctl.2:183 build/C/man2/sysinfo.2:96
#: build/C/man3/tcgetpgrp.3:131 build/C/man2/truncate.2:260
#: build/C/man3/ualarm.3:155 build/C/man2/umask.2:124 build/C/man2/uname.2:171
#: build/C/man2/uselib.2:112 build/C/man3/usleep.3:156
#: build/C/man2/vfork.2:279 build/C/man2/vhangup.2:69
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/_syscall.2:195 build/C/man2/access.2:390
#: build/C/man2/alarm.2:102 build/C/man2/brk.2:176 build/C/man2/chdir.2:147
#: build/C/man2/chmod.2:361 build/C/man2/chown.2:481 build/C/man2/chroot.2:161
#: build/C/man2/close.2:145 build/C/man3/confstr.3:157
#: build/C/man3/crypt.3:262 build/C/man3/daemon.3:120
#: build/C/man3/des_crypt.3:156 build/C/man2/dup.2:218
#: build/C/man3/encrypt.3:186 build/C/man7/environ.7:269
#: build/C/man3/euidaccess.3:119 build/C/man3/exec.3:255
#: build/C/man2/execve.2:663 build/C/man2/exit_group.2:58
#: build/C/man2/fcntl.2:1354 build/C/man3/fexecve.3:133
#: build/C/man2/flock.2:222 build/C/man2/fork.2:262
#: build/C/man3/fpathconf.3:192 build/C/man2/fsync.2:178
#: build/C/man3/get_nprocs_conf.3:95 build/C/man2/get_thread_area.2:65
#: build/C/man3/getcwd.3:263 build/C/man2/getdomainname.2:138
#: build/C/man3/getdtablesize.3:102 build/C/man3/gethostid.3:134
#: build/C/man2/gethostname.2:187 build/C/man3/getlogin.3:220
#: build/C/man3/getopt.3:523 build/C/man2/getpagesize.2:118
#: build/C/man2/gettid.2:97 build/C/man3/getumask.3:72
#: build/C/man3/getusershell.3:112 build/C/man2/idle.2:71
#: build/C/man2/ioctl.2:157 build/C/man2/ioctl_list.2:972
#: build/C/man2/ioperm.2:132 build/C/man3/lockf.3:178
#: build/C/man2/mincore.2:176 build/C/man2/mkdir.2:241 build/C/man2/nice.2:119
#: build/C/man2/pread.2:170 build/C/man2/set_thread_area.2:81
#: build/C/man2/setup.2:79 build/C/man5/shells.5:66 build/C/man3/sleep.3:73
#: build/C/man3/swab.3:88 build/C/man2/swapon.2:210 build/C/man2/syscall.2:232
#: build/C/man2/syscalls.2:845 build/C/man3/sysconf.3:350
#: build/C/man2/sysctl.2:190 build/C/man2/sysinfo.2:103
#: build/C/man3/tcgetpgrp.3:138 build/C/man2/truncate.2:267
#: build/C/man3/ualarm.3:162 build/C/man2/umask.2:131 build/C/man2/uname.2:178
#: build/C/man2/uselib.2:119 build/C/man3/usleep.3:163
#: build/C/man2/vfork.2:286 build/C/man2/vhangup.2:76
msgid ""
"This page is part of release 3.63 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.63 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/access.2:43
#, no-wrap
msgid "ACCESS"
msgstr "ACCESS"

#. type: TH
#: build/C/man2/access.2:43 build/C/man2/chmod.2:32 build/C/man2/chown.2:38
#: build/C/man2/mkdir.2:11
#, no-wrap
msgid "2014-02-21"
msgstr "2014-02-21"

#. type: Plain text
#: build/C/man2/access.2:46
msgid "access, faccessat - check user's permissions for a file"
msgstr "access, faccessat - ユーザのファイルへのアクセス権をチェックする"

#. type: Plain text
#: build/C/man2/access.2:49 build/C/man2/alarm.2:36 build/C/man2/chown.2:44
#: build/C/man2/close.2:41 build/C/man3/confstr.3:37 build/C/man3/crypt.3:44
#: build/C/man2/dup.2:42 build/C/man3/fexecve.3:31 build/C/man3/fpathconf.3:47
#: build/C/man3/getcwd.3:38 build/C/man3/getopt.3:48
#: build/C/man3/getusershell.3:36 build/C/man3/sleep.3:32
#: build/C/man3/sysconf.3:33 build/C/man2/sysctl.2:36 build/C/man3/ualarm.3:30
#: build/C/man3/usleep.3:39
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/access.2:51
#, no-wrap
msgid "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr "B<int access(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/access.2:54 build/C/man2/chown.2:53
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/access.2:57
#, no-wrap
msgid "B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, int >I<flags>B<);>\n"
msgstr "B<int faccessat(int >I<dirfd>B<, const char *>I<pathname>B<, int >I<mode>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/access.2:62 build/C/man2/brk.2:42 build/C/man2/chdir.2:46
#: build/C/man2/chmod.2:53 build/C/man2/chown.2:62 build/C/man2/chroot.2:44
#: build/C/man3/confstr.3:44 build/C/man3/daemon.3:47 build/C/man3/exec.3:68
#: build/C/man3/fexecve.3:38 build/C/man2/fsync.2:51 build/C/man3/getcwd.3:49
#: build/C/man2/getdomainname.2:42 build/C/man3/getdtablesize.3:38
#: build/C/man3/gethostid.3:42 build/C/man2/gethostname.2:45
#: build/C/man3/getlogin.3:45 build/C/man3/getopt.3:69
#: build/C/man2/getpagesize.2:36 build/C/man3/getusershell.3:47
#: build/C/man3/lockf.3:39 build/C/man2/mincore.2:47 build/C/man2/mkdir.2:31
#: build/C/man2/nice.2:42 build/C/man2/pread.2:40 build/C/man2/truncate.2:58
#: build/C/man3/ualarm.3:37 build/C/man3/usleep.3:46 build/C/man2/vfork.2:41
#: build/C/man2/vhangup.2:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/access.2:65
msgid "B<faccessat>():"
msgstr "B<faccessat>():"

#. type: TP
#: build/C/man2/access.2:68 build/C/man2/chmod.2:71 build/C/man2/chown.2:79
#: build/C/man3/fexecve.3:44 build/C/man2/mkdir.2:37
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man2/access.2:71 build/C/man2/chmod.2:74 build/C/man2/chown.2:82
#: build/C/man3/fexecve.3:47 build/C/man2/mkdir.2:40
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man2/access.2:71 build/C/man2/chmod.2:74 build/C/man2/chown.2:82
#: build/C/man3/fexecve.3:47 build/C/man2/mkdir.2:40
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man2/access.2:74 build/C/man2/chmod.2:77 build/C/man2/chown.2:85
#: build/C/man2/mkdir.2:43
msgid "_ATFILE_SOURCE"
msgstr "_ATFILE_SOURCE"

#. type: Plain text
#: build/C/man2/access.2:85
msgid ""
"B<access>()  checks whether the calling process can access the file "
"I<pathname>.  If I<pathname> is a symbolic link, it is dereferenced."
msgstr ""
"B<access>()  は、呼び出し元プロセスがファイル I<pathname> にアクセスできるか"
"どうかをチェックする。 I<pathname> がシンボリックリンクの場合、シンボリックリ"
"ンクは展開される。"

#.  F_OK is defined as 0 on every system that I know of.
#. type: Plain text
#: build/C/man2/access.2:99
msgid ""
"The I<mode> specifies the accessibility check(s) to be performed, and is "
"either the value B<F_OK>, or a mask consisting of the bitwise OR of one or "
"more of B<R_OK>, B<W_OK>, and B<X_OK>.  B<F_OK> tests for the existence of "
"the file.  B<R_OK>, B<W_OK>, and B<X_OK> test whether the file exists and "
"grants read, write, and execute permissions, respectively."
msgstr ""
"I<mode> はチェックを行うアクセス権を指定するもので、その値は B<F_OK>、 もしく"
"は B<R_OK>, B<W_OK>, B<X_OK> の 1個以上のビット単位の論理和から構成されるマス"
"クである。 B<F_OK> はファイルが存在するかどうかのみを検査する。 B<R_OK>, "
"B<W_OK>, B<X_OK> は、ファイルが存在して、それぞれ読み込み、書き込み、実行の許"
"可があるか を検査する。"

#. type: Plain text
#: build/C/man2/access.2:108
msgid ""
"The check is done using the calling process's I<real> UID and GID, rather "
"than the effective IDs as is done when actually attempting an operation (e."
"g., B<open>(2))  on the file.  This allows set-user-ID programs to easily "
"determine the invoking user's authority."
msgstr ""
"チェックは、実際に操作が行われる際に使用される実効 (effective) ID でなく、 呼"
"び出し元プロセスの I<実 (real)> UID と I<実 (real)> GID を使って行われる。 こ"
"れにより、set-user-ID プログラムで、プログラムを起動するユーザの権限を 簡単に"
"決定することができる。"

#. type: Plain text
#: build/C/man2/access.2:114
msgid ""
"If the calling process is privileged (i.e., its real UID is zero), then an "
"B<X_OK> check is successful for a regular file if execute permission is "
"enabled for any of the file owner, group, or other."
msgstr ""
"呼び出し元プロセスが特権プロセス (つまり、プロセスの実 UID が 0) の場合、 通"
"常のファイルに対する B<X_OK> のチェックは、そのファイルの所有者、グループ、他"
"人のいずれかの 実行許可が有効になっていれば成功する。"

#. type: SS
#: build/C/man2/access.2:114 build/C/man2/access.2:326
#, no-wrap
msgid "faccessat ()"
msgstr "faccessat ()"

#. type: Plain text
#: build/C/man2/access.2:120
msgid ""
"The B<faccessat>()  system call operates in exactly the same way as B<access>"
"(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:130
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<access>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:142
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<access>())."
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:148 build/C/man2/chmod.2:216 build/C/man2/chown.2:179
#: build/C/man2/mkdir.2:110
msgid "If I<pathname> is absolute, then I<dirfd> is ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:151
#, fuzzy
#| msgid ""
#| "The new file permissions are specified in I<mode>, which is a bit mask "
#| "created by ORing together zero or more of the following:"
msgid ""
"I<flags> is constructed by ORing together zero or more of the following "
"values:"
msgstr ""
"新しいファイル許可は I<mode> で指定される。 I<mode> は、以下に示す値の 0 個以"
"上の OR (論理和) をとって作成される ビットマスクである。"

#. type: TP
#: build/C/man2/access.2:151
#, no-wrap
msgid "B<AT_EACCESS>"
msgstr "B<AT_EACCESS>"

#. type: Plain text
#: build/C/man2/access.2:158
msgid ""
"Perform access checks using the effective user and group IDs.  By default, "
"B<faccessat>()  uses the real IDs (like B<access>())."
msgstr ""

#. type: TP
#: build/C/man2/access.2:158 build/C/man2/chmod.2:219 build/C/man2/chown.2:203
#, no-wrap
msgid "B<AT_SYMLINK_NOFOLLOW>"
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:164
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead return "
"information about the link itself."
msgstr ""

#. type: Plain text
#: build/C/man2/access.2:169
msgid "See B<openat>(2)  for an explanation of the need for B<faccessat>()."
msgstr ""

#. type: SH
#: build/C/man2/access.2:169 build/C/man2/alarm.2:54 build/C/man2/brk.2:93
#: build/C/man2/chdir.2:70 build/C/man2/chmod.2:231 build/C/man2/chown.2:219
#: build/C/man2/chroot.2:90 build/C/man2/close.2:64 build/C/man3/confstr.3:94
#: build/C/man3/crypt.3:120 build/C/man3/daemon.3:73
#: build/C/man3/des_crypt.3:106 build/C/man2/dup.2:120
#: build/C/man3/encrypt.3:113 build/C/man3/euidaccess.3:58
#: build/C/man3/exec.3:183 build/C/man2/execve.2:357
#: build/C/man2/exit_group.2:39 build/C/man2/fcntl.2:1067
#: build/C/man3/fexecve.3:67 build/C/man2/flock.2:111 build/C/man2/fork.2:173
#: build/C/man3/fpathconf.3:160 build/C/man2/fsync.2:108
#: build/C/man3/get_nprocs_conf.3:46 build/C/man2/get_thread_area.2:29
#: build/C/man3/getcwd.3:156 build/C/man2/getdomainname.2:75
#: build/C/man3/getdtablesize.3:61 build/C/man3/gethostid.3:71
#: build/C/man2/gethostname.2:89 build/C/man3/getlogin.3:95
#: build/C/man3/getopt.3:274 build/C/man2/gettid.2:50
#: build/C/man3/getusershell.3:85 build/C/man2/idle.2:52
#: build/C/man2/ioctl.2:85 build/C/man2/ioctl_list.2:107
#: build/C/man2/ioperm.2:82 build/C/man3/lockf.3:116 build/C/man2/mincore.2:94
#: build/C/man2/mkdir.2:115 build/C/man2/nice.2:56 build/C/man2/pread.2:79
#: build/C/man2/set_thread_area.2:44 build/C/man2/setup.2:53
#: build/C/man3/sleep.3:40 build/C/man3/swab.3:68 build/C/man2/swapon.2:108
#: build/C/man2/syscall.2:72 build/C/man3/sysconf.3:311
#: build/C/man2/sysctl.2:74 build/C/man2/sysinfo.2:74
#: build/C/man3/tcgetpgrp.3:64 build/C/man2/truncate.2:110
#: build/C/man3/ualarm.3:81 build/C/man2/umask.2:92 build/C/man2/uname.2:63
#: build/C/man2/uselib.2:48 build/C/man3/usleep.3:75 build/C/man2/vhangup.2:50
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/access.2:185
msgid ""
"On success (all requested permissions granted, or I<mode> is B<F_OK> and the "
"file exists), zero is returned.  On error (at least one bit in I<mode> asked "
"for a permission that is denied, or I<mode> is B<F_OK> and the file does not "
"exist, or some other error occurred), -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合 (要求した全てについて許可が得られたか、 I<mode> が B<F_OK> で"
"ファイルが存在した場合)、ゼロが返される。 エラーの場合 (I<mode> の少なくとも"
"一つのビットで要求した許可がなかった場合、 I<mode> が B<F_OK> でファイルが存"
"在しなかった場合、他のエラーが起こった場合)、-1 が返され、 I<errno> が適切に"
"設定される。"

#. type: SH
#: build/C/man2/access.2:185 build/C/man2/chdir.2:75 build/C/man2/chmod.2:236
#: build/C/man2/chown.2:224 build/C/man2/chroot.2:95 build/C/man2/close.2:70
#: build/C/man3/confstr.3:121 build/C/man3/crypt.3:123 build/C/man2/dup.2:126
#: build/C/man3/encrypt.3:115 build/C/man3/euidaccess.3:66
#: build/C/man3/exec.3:190 build/C/man2/execve.2:363 build/C/man2/fcntl.2:1100
#: build/C/man3/fexecve.3:74 build/C/man2/flock.2:116 build/C/man2/fork.2:180
#: build/C/man2/fsync.2:113 build/C/man2/get_thread_area.2:35
#: build/C/man3/getcwd.3:172 build/C/man2/getdomainname.2:80
#: build/C/man3/getdtablesize.3:63 build/C/man3/gethostid.3:81
#: build/C/man2/gethostname.2:94 build/C/man3/getlogin.3:103
#: build/C/man2/gettid.2:52 build/C/man2/idle.2:55 build/C/man2/ioctl.2:94
#: build/C/man2/ioperm.2:87 build/C/man3/lockf.3:121
#: build/C/man2/mincore.2:101 build/C/man2/mkdir.2:122 build/C/man2/nice.2:61
#: build/C/man2/pread.2:89 build/C/man2/set_thread_area.2:49
#: build/C/man2/setup.2:56 build/C/man2/swapon.2:113 build/C/man2/sysctl.2:81
#: build/C/man2/sysinfo.2:79 build/C/man3/tcgetpgrp.3:86
#: build/C/man2/truncate.2:115 build/C/man3/ualarm.3:84
#: build/C/man2/uname.2:68 build/C/man2/uselib.2:53 build/C/man3/usleep.3:82
#: build/C/man2/vhangup.2:55
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man2/access.2:190
msgid "B<access>()  and B<faccessat>()  shall fail if:"
msgstr "B<access>() と B<faccessat>() は以下の場合に失敗する。"

#. type: TP
#: build/C/man2/access.2:190 build/C/man2/chdir.2:81 build/C/man2/chdir.2:117
#: build/C/man2/chmod.2:243 build/C/man2/chown.2:231 build/C/man2/chroot.2:98
#: build/C/man2/execve.2:371 build/C/man2/execve.2:378
#: build/C/man2/execve.2:381 build/C/man2/execve.2:384
#: build/C/man3/getcwd.3:173 build/C/man3/gethostid.3:84
#: build/C/man2/mkdir.2:123 build/C/man2/truncate.2:118
#: build/C/man2/uselib.2:59
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/access.2:197
msgid ""
"The requested access would be denied to the file, or search permission is "
"denied for one of the directories in the path prefix of I<pathname>.  (See "
"also B<path_resolution>(7).)"
msgstr ""
"要求されたアクセスは そのファイル自身に拒否されたか I<pathname> へ至るまで"
"ディレクトリのいずれかに対する検索許可 (search permission) が得られなかっ"
"た。 (B<path_resolution>(7)  も参照のこと)"

#. type: TP
#: build/C/man2/access.2:197 build/C/man2/chdir.2:94 build/C/man2/chmod.2:255
#: build/C/man2/chown.2:240 build/C/man2/chroot.2:112
#: build/C/man2/execve.2:409 build/C/man2/mkdir.2:145
#: build/C/man2/truncate.2:151
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/access.2:201 build/C/man2/chmod.2:259 build/C/man2/chown.2:244
#: build/C/man2/mkdir.2:149
msgid "Too many symbolic links were encountered in resolving I<pathname>."
msgstr "I<pathname> を解決するときに、解決すべきシンボリックリンクが多すぎた。"

#. type: TP
#: build/C/man2/access.2:201 build/C/man2/chdir.2:98 build/C/man2/chmod.2:259
#: build/C/man2/chown.2:244 build/C/man2/chroot.2:116
#: build/C/man2/execve.2:417 build/C/man2/gethostname.2:109
#: build/C/man2/mkdir.2:153 build/C/man2/truncate.2:154
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/access.2:205 build/C/man2/chmod.2:263 build/C/man2/chown.2:248
msgid "I<pathname> is too long."
msgstr "I<pathname> が長過ぎる。"

#. type: TP
#: build/C/man2/access.2:205 build/C/man2/chdir.2:102 build/C/man2/chmod.2:263
#: build/C/man2/chown.2:248 build/C/man2/chown.2:274 build/C/man2/chroot.2:120
#: build/C/man2/execve.2:424 build/C/man3/getcwd.3:198
#: build/C/man3/getlogin.3:122 build/C/man2/mkdir.2:156
#: build/C/man2/swapon.2:144 build/C/man2/truncate.2:158
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/access.2:210
msgid ""
"A component of I<pathname> does not exist or is a dangling symbolic link."
msgstr ""
"I<pathname> を構成するパスのいずれかが、存在しないか、 参照先のない "
"(dangling) シンボリックリンクになっている。"

#. type: TP
#: build/C/man2/access.2:210 build/C/man2/access.2:252
#: build/C/man2/chdir.2:108 build/C/man2/chmod.2:269 build/C/man2/chmod.2:314
#: build/C/man2/chown.2:254 build/C/man2/chown.2:298 build/C/man2/chroot.2:126
#: build/C/man2/execve.2:438 build/C/man2/mkdir.2:173 build/C/man2/mkdir.2:194
#: build/C/man2/sysctl.2:88 build/C/man2/truncate.2:161
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/access.2:215 build/C/man2/mkdir.2:178
msgid ""
"A component used as a directory in I<pathname> is not, in fact, a directory."
msgstr "I<pathname> のディレクトリ部分が実際にはディレクトリでない。"

#. type: TP
#: build/C/man2/access.2:215 build/C/man2/chmod.2:278 build/C/man2/chmod.2:296
#: build/C/man2/chown.2:261 build/C/man2/chown.2:280 build/C/man2/mkdir.2:183
#: build/C/man2/truncate.2:170
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/access.2:218
msgid "Write permission was requested for a file on a read-only filesystem."
msgstr ""
"読み込み専用 (read-only) のファイルシステムに対して書き込み許可を 要求した。"

#. type: Plain text
#: build/C/man2/access.2:223
msgid "B<access>()  and B<faccessat>()  may fail if:"
msgstr "B<access>() と B<faccessat>() は以下の理由により失敗することがある。"

#. type: TP
#: build/C/man2/access.2:223 build/C/man2/chdir.2:87 build/C/man2/chmod.2:248
#: build/C/man2/chown.2:236 build/C/man2/chroot.2:105
#: build/C/man2/execve.2:388 build/C/man2/fcntl.2:1122
#: build/C/man2/get_thread_area.2:36 build/C/man3/getcwd.3:176
#: build/C/man2/getdomainname.2:83 build/C/man2/gethostname.2:95
#: build/C/man2/ioctl.2:99 build/C/man2/mincore.2:104 build/C/man2/mkdir.2:142
#: build/C/man2/set_thread_area.2:53 build/C/man2/sysctl.2:82
#: build/C/man2/sysinfo.2:80 build/C/man2/truncate.2:124
#: build/C/man2/uname.2:69
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/access.2:227 build/C/man2/chmod.2:252 build/C/man2/chown.2:240
#: build/C/man2/mkdir.2:145
msgid "I<pathname> points outside your accessible address space."
msgstr "I<pathname> がアクセス可能なアドレス空間の外を指している。"

#. type: TP
#: build/C/man2/access.2:227 build/C/man2/access.2:248
#: build/C/man2/chmod.2:310 build/C/man2/chown.2:294
#: build/C/man3/confstr.3:122 build/C/man3/crypt.3:124 build/C/man2/dup.2:151
#: build/C/man2/execve.2:396 build/C/man2/fcntl.2:1138
#: build/C/man3/fexecve.3:78 build/C/man2/flock.2:126
#: build/C/man2/get_thread_area.2:39 build/C/man3/getcwd.3:180
#: build/C/man2/getdomainname.2:87 build/C/man2/getdomainname.2:99
#: build/C/man2/gethostname.2:99 build/C/man2/ioctl.2:103
#: build/C/man2/ioperm.2:88 build/C/man3/lockf.3:147
#: build/C/man2/mincore.2:108 build/C/man2/set_thread_area.2:50
#: build/C/man2/swapon.2:121 build/C/man2/swapon.2:126
#: build/C/man2/swapon.2:136 build/C/man3/tcgetpgrp.3:91
#: build/C/man2/truncate.2:140 build/C/man2/truncate.2:191
#: build/C/man3/ualarm.3:88 build/C/man3/usleep.3:87
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/access.2:231
msgid "I<mode> was incorrectly specified."
msgstr "I<mode> に不正な値が指定された。"

#. type: TP
#: build/C/man2/access.2:231 build/C/man2/chdir.2:91 build/C/man2/chmod.2:252
#: build/C/man2/chmod.2:290 build/C/man2/chown.2:271 build/C/man2/chroot.2:109
#: build/C/man2/close.2:81 build/C/man2/execve.2:400 build/C/man2/fsync.2:118
#: build/C/man2/ioperm.2:94 build/C/man2/truncate.2:145
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/access.2:234 build/C/man2/chdir.2:94 build/C/man2/chmod.2:255
#: build/C/man2/chroot.2:112 build/C/man2/close.2:84 build/C/man2/execve.2:403
msgid "An I/O error occurred."
msgstr "I/O エラーが発生した。"

#. type: TP
#: build/C/man2/access.2:234 build/C/man2/chdir.2:105 build/C/man2/chmod.2:266
#: build/C/man2/chown.2:251 build/C/man2/chroot.2:123
#: build/C/man2/execve.2:435 build/C/man2/fork.2:196
#: build/C/man3/getlogin.3:125 build/C/man2/ioperm.2:97
#: build/C/man2/mincore.2:112 build/C/man2/mincore.2:124
#: build/C/man2/mkdir.2:161 build/C/man2/swapon.2:149
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/access.2:237 build/C/man2/chdir.2:108 build/C/man2/chmod.2:269
#: build/C/man2/chown.2:254 build/C/man2/chroot.2:126
#: build/C/man2/execve.2:438 build/C/man2/mkdir.2:164
msgid "Insufficient kernel memory was available."
msgstr "カーネルに十分なメモリがない。"

#. type: TP
#: build/C/man2/access.2:237 build/C/man2/execve.2:453
#: build/C/man2/truncate.2:173
#, no-wrap
msgid "B<ETXTBSY>"
msgstr "B<ETXTBSY>"

#. type: Plain text
#: build/C/man2/access.2:241
msgid "Write access was requested to an executable which is being executed."
msgstr "実行中のファイルに対して書き込みを要求した。"

#. type: Plain text
#: build/C/man2/access.2:244
msgid "The following additional errors can occur for B<faccessat>():"
msgstr ""

#. type: TP
#: build/C/man2/access.2:244 build/C/man2/chdir.2:121 build/C/man2/chmod.2:285
#: build/C/man2/chmod.2:306 build/C/man2/chown.2:268 build/C/man2/chown.2:290
#: build/C/man2/close.2:71 build/C/man2/dup.2:127 build/C/man2/fcntl.2:1108
#: build/C/man2/flock.2:117 build/C/man2/fsync.2:114 build/C/man2/ioctl.2:95
#: build/C/man3/lockf.3:130 build/C/man2/mkdir.2:190
#: build/C/man3/tcgetpgrp.3:87 build/C/man2/truncate.2:183
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/access.2:248 build/C/man2/chmod.2:310 build/C/man2/chown.2:294
#: build/C/man2/mkdir.2:194
msgid "I<dirfd> is not a valid file descriptor."
msgstr "I<dirfd> が適切なファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/access.2:252 build/C/man2/chmod.2:314 build/C/man2/chown.2:298
msgid "Invalid flag specified in I<flags>."
msgstr "I<flags> に無効なフラグが指定された。"

#. type: Plain text
#: build/C/man2/access.2:258 build/C/man2/chmod.2:320 build/C/man2/chown.2:304
#: build/C/man2/mkdir.2:200
msgid ""
"I<pathname> is relative and I<dirfd> is a file descriptor referring to a "
"file other than a directory."
msgstr ""

#. type: SH
#: build/C/man2/access.2:258 build/C/man2/chmod.2:326 build/C/man2/chown.2:304
#: build/C/man3/des_crypt.3:131 build/C/man2/dup.2:165
#: build/C/man3/euidaccess.3:69 build/C/man3/exec.3:195
#: build/C/man2/exit_group.2:41 build/C/man3/fexecve.3:91
#: build/C/man2/get_thread_area.2:42 build/C/man2/gettid.2:54
#: build/C/man2/idle.2:59 build/C/man2/mincore.2:132 build/C/man2/mkdir.2:200
#: build/C/man2/pread.2:104 build/C/man2/set_thread_area.2:59
#: build/C/man2/setup.2:60
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man2/access.2:262
msgid ""
"B<faccessat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr "B<faccessat>()  はバージョン 2.6.16 で Linux に追加された。 ライブラリによるサポートは glibc バージョン 2.4 で追加された。"

#. type: Plain text
#: build/C/man2/access.2:265
msgid "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<access>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/access.2:268
msgid "B<faccessat>(): POSIX.1-2008."
msgstr "B<faccessat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/access.2:281
msgid ""
"B<Warning>: Using these calls to check if a user is authorized to, for "
"example, open a file before actually doing so using B<open>(2)  creates a "
"security hole, because the user might exploit the short time interval "
"between checking and opening the file to manipulate it.  B<For this reason, "
"the use of this system call should be avoided>.  (In the example just "
"described, a safer alternative would be to temporarily switch the process's "
"effective user ID to the real ID and then call B<open>(2).)"
msgstr "B<警告>: あるユーザが、例えば B<open>(2) によるアクセスが可能かどうかを、 (実際に行う前に) これらのシステムコールを使ってチェックするのは、セキュリティホールの原因になる。なぜならチェックをしてから 実際にファイルのオープン操作をする間の短い間隔を悪用できるからである。 B<この理由があるので、このシステムコールを使うのは避けるべきである。> (ここで説明した例の場合には、より安全な方法としては、 そのプロセスの実効ユーザ ID を実ユーザ ID に一時的に切り替えてから B<open>(2) を呼び出す方法がある。)"

#. type: Plain text
#: build/C/man2/access.2:288
msgid ""
"B<access>()  always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flag "
"B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"B<access>() は常にシンボリックリンクの展開を行う。\n"
"シンボリックリンクのアクセス許可を確認する必要がある場合は、\n"
"B<AT_SYMLINK_NOFOLLOW> フラグ付きで B<faccessat>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/access.2:294
msgid ""
"These calls return an error if any of the access types in I<mode> is denied, "
"even if some of the other access types in I<mode> are permitted."
msgstr "I<mode> で指定されたアクセス種別のいずれか一つでも拒否されると、 たとえ I<mode> で指定された他のアクセス種別が許可されたとしても、 これらのシステムコールはエラーを返す。"

#.  HPU-UX 11 and Tru64 5.1 do this.
#. type: Plain text
#: build/C/man2/access.2:301
msgid ""
"If the calling process has appropriate privileges (i.e., is superuser), "
"POSIX.1-2001 permits an implementation to indicate success for an B<X_OK> "
"check even if none of the execute file permission bits are set.  Linux does "
"not do this."
msgstr ""
"POSIX.1-2001 では、 呼び出し元プロセスが適切な特権を持っている場合 (つまり、"
"スーパーユーザの場合)、 たとえファイルの実行許可ビットが全くセットされていな"
"くても B<X_OK> のチェックとして成功を返す実装が認められている。 Linux はこの"
"ようにはなっていない。"

#. type: Plain text
#: build/C/man2/access.2:309
msgid ""
"A file is accessible only if the permissions on each of the directories in "
"the path prefix of I<pathname> grant search (i.e., execute) access.  If any "
"directory is inaccessible, then the B<access>()  call will fail, regardless "
"of the permissions on the file itself."
msgstr ""
"I<pathname> のプレフィックスを構成するディレクトリの全てに対して 検索アクセ"
"ス (すなわち、実行アクセス) が許可された場合にのみ、 ファイルはアクセス可能と"
"なる。 いずれかのディレクトリがアクセス不可の場合、 ファイル自身のアクセス許"
"可に関わらず、 B<access>()  は失敗する。"

#. type: Plain text
#: build/C/man2/access.2:317
msgid ""
"Only access bits are checked, not the file type or contents.  Therefore, if "
"a directory is found to be writable, it probably means that files can be "
"created in the directory, and not that the directory can be written as a "
"file.  Similarly, a DOS file may be found to be \"executable,\" but the "
"B<execve>(2)  call will still fail."
msgstr ""
"アクセスビットのみがチェックされ、ファイルの種類や内容はチェックされない。 "
"従って、ディレクトリが書き込み可能となった場合は、ディレクトリに ファイルを作"
"成することが可能なことを意味するのであり、ディレクトリに ファイルとして書き込"
"むことができるわけではない。 同様に DOS のファイルは「実行可能」と判断される"
"が、 B<execve>(2)  コールは失敗するだろう。"

#. type: Plain text
#: build/C/man2/access.2:326
msgid ""
"These calls may not work correctly on NFSv2 filesystems with UID mapping "
"enabled, because UID mapping is done on the server and hidden from the "
"client, which checks permissions.  (NFS versions 3 and higher perform the "
"check on the server.)  Similar problems can occur to FUSE mounts."
msgstr "これらのシステムコールは、 UID マッピングを使用した NFSv2 ファイルシステムでは正常に機能しないかもしれない。なぜならば UID のマッピングはサーバーで 行なわれ、権利のチェックをするクライアントには見えないからである。 (NFS バージョン 3 以降ではサーバー側でチェックが実行される。) 同様の問題は FUSE マウントでも起こり得る。"

#. type: Plain text
#: build/C/man2/access.2:339
msgid ""
"The raw B<faccessat>()  system call takes only the first three arguments.  "
"The B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW> flags are actually implemented "
"within the glibc wrapper function for B<faccessat>().  If either of these "
"flags is specified, then the wrapper function employs B<fstatat>(2)  to "
"determine access permissions."
msgstr ""

#. type: SH
#: build/C/man2/access.2:339 build/C/man7/environ.7:210
#: build/C/man2/fcntl.2:1255 build/C/man3/gethostid.3:122
#: build/C/man3/getlogin.3:177 build/C/man3/getopt.3:369
#: build/C/man2/mincore.2:144 build/C/man2/pread.2:146 build/C/man3/sleep.3:46
#: build/C/man3/sysconf.3:326 build/C/man2/sysctl.2:135
#: build/C/man2/truncate.2:248 build/C/man2/vfork.2:252
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  This behavior appears to have been an implementation accident.
#. type: Plain text
#: build/C/man2/access.2:362
msgid ""
"In kernel 2.4 (and earlier) there is some strangeness in the handling of "
"B<X_OK> tests for superuser.  If all categories of execute permission are "
"disabled for a nondirectory file, then the only B<access>()  test that "
"returns -1 is when I<mode> is specified as just B<X_OK>; if B<R_OK> or "
"B<W_OK> is also specified in I<mode>, then B<access>()  returns 0 for such "
"files.  Early 2.6 kernels (up to and including 2.6.3)  also behaved in the "
"same way as kernel 2.4."
msgstr ""
"バージョン 2.4 (とそれ以前) のカーネルには、スーパーユーザでの B<X_OK> の"
"チェックの扱いに奇妙な点がある。 ディレクトリ以外のファイルで (ユーザ、グルー"
"プ、他人の) 全てのカテゴリについて 実行許可がない場合、 B<access>()  のチェッ"
"クで -1 が返るのは I<mode> に B<X_OK> だけが指定されたときだけであり I<mode> "
"に B<R_OK> や B<W_OK> が一緒に指定された場合には B<access>()  は 0 を返す。 "
"(バージョン 2.6.3 以前の) 初期の 2.6 系のカーネルも 2.4 系のカーネルと同様の"
"動作をする。"

#. type: Plain text
#: build/C/man2/access.2:372
#, fuzzy
#| msgid ""
#| "In kernels before 2.6.20, B<access>()  ignored the effect of the "
#| "B<MS_NOEXEC> flag if it was used to B<mount>(2)  the underlying "
#| "filesystem.  Since kernel 2.6.20, B<access>()  honors this flag."
msgid ""
"In kernels before 2.6.20, these calls ignored the effect of the B<MS_NOEXEC> "
"flag if it was used to B<mount>(2)  the underlying filesystem.  Since kernel "
"2.6.20, the B<MS_NOEXEC> is honored"
msgstr ""
"2.6.20 より前のカーネルでは、 ファイルが存在するファイルシステムを B<mount>"
"(2)  する際に指定された B<MS_NOEXEC> フラグの効果を、 B<access>()  は無視して"
"いた。 カーネル 2.6.20 以降では、 B<access>()  はこのフラグを考慮するように"
"なっている。"

#. type: Plain text
#: build/C/man2/access.2:383
msgid ""
"B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), B<stat>"
"(2), B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), B<symlink>"
"(7)"
msgstr "B<chmod>(2), B<chown>(2), B<open>(2), B<setgid>(2), B<setuid>(2), B<stat>(2), B<euidaccess>(3), B<credentials>(7), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/alarm.2:30
#, no-wrap
msgid "ALARM"
msgstr "ALARM"

#. type: TH
#: build/C/man2/alarm.2:30
#, no-wrap
msgid "2014-02-23"
msgstr "2014-02-23"

#. type: Plain text
#: build/C/man2/alarm.2:33
msgid "alarm - set an alarm clock for delivery of a signal"
msgstr "alarm - シグナル配送のためのアラームクロックを設定する"

#. type: Plain text
#: build/C/man2/alarm.2:38
#, no-wrap
msgid "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int alarm(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: build/C/man2/alarm.2:46
msgid ""
"B<alarm>()  arranges for a B<SIGALRM> signal to be delivered to the calling "
"process in I<seconds> seconds."
msgstr ""
"B<alarm>()  は B<SIGALRM> シグナルを I<seconds> 秒後に呼び出したプロセスに配"
"送するように手配する。"

#. type: Plain text
#: build/C/man2/alarm.2:50
msgid "If I<seconds> is zero, any pending alarm is canceled."
msgstr ""
"I<seconds> がゼロならば、処理待ち (pending) のアラームはすべてキャンセルされ"
"る。"

#. type: Plain text
#: build/C/man2/alarm.2:54
msgid "In any event any previously set B<alarm>()  is canceled."
msgstr "今までに設定されていた B<alarm>()  は中断される。"

#. type: Plain text
#: build/C/man2/alarm.2:59
msgid ""
"B<alarm>()  returns the number of seconds remaining until any previously "
"scheduled alarm was due to be delivered, or zero if there was no previously "
"scheduled alarm."
msgstr ""
"B<alarm>()  は以前に予定されていたアラームの配送までの残り時間を返す。以前に "
"アラームが予定されていなければゼロを返す。"

#. type: Plain text
#: build/C/man2/alarm.2:61
msgid "SVr4, POSIX.1-2001, 4.3BSD."
msgstr "SVr4, POSIX.1-2001, 4.3BSD."

#. type: Plain text
#: build/C/man2/alarm.2:67
msgid ""
"B<alarm>()  and B<setitimer>(2)  share the same timer; calls to one will "
"interfere with use of the other."
msgstr ""
"B<alarm>()  と B<setitimer>(2)  は同じタイマーを共有している; 片方を呼び出す"
"ことはもう一方の 使用に影響を与える。"

#. type: Plain text
#: build/C/man2/alarm.2:74
msgid ""
"Alarms created by B<alarm()> are preserved across B<execve>(2)  and are not "
"inherited by children created via B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/alarm.2:83
msgid ""
"B<sleep>(3)  may be implemented using B<SIGALRM>; mixing calls to B<alarm>"
"()  and B<sleep>(3)  is a bad idea."
msgstr ""
"B<sleep>(3)  は B<SIGALRM> を利用して実装されているかもしれない。 B<alarm>"
"()  と B<sleep>(3)  を混ぜて使用してはならない。"

#. type: Plain text
#: build/C/man2/alarm.2:86
msgid ""
"Scheduling delays can, as ever, cause the execution of the process to be "
"delayed by an arbitrary amount of time."
msgstr ""
"スケジューリング(scheduling)の遅延により、プロセスの実行に不定量の 遅延が起き"
"る可能性がある。"

#. type: Plain text
#: build/C/man2/alarm.2:95
msgid ""
"B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), B<sigaction>"
"(2), B<signal>(2), B<sleep>(3), B<time>(7)"
msgstr ""
"B<gettimeofday>(2), B<pause>(2), B<select>(2), B<setitimer>(2), B<sigaction>"
"(2), B<signal>(2), B<sleep>(3), B<time>(7)"

#. type: TH
#: build/C/man2/brk.2:29
#, no-wrap
msgid "BRK"
msgstr "BRK"

#. type: TH
#: build/C/man2/brk.2:29 build/C/man2/chroot.2:33 build/C/man3/getcwd.3:32
#: build/C/man3/gethostid.3:29
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: build/C/man2/brk.2:32
msgid "brk, sbrk - change data segment size"
msgstr "brk, sbrk - データセグメントのサイズの変更する"

#. type: Plain text
#: build/C/man2/brk.2:34 build/C/man2/chdir.2:38 build/C/man2/chroot.2:38
#: build/C/man3/daemon.3:41 build/C/man3/encrypt.3:37 build/C/man3/exec.3:46
#: build/C/man2/execve.2:42 build/C/man2/fork.2:44 build/C/man2/fsync.2:43
#: build/C/man2/getdomainname.2:34 build/C/man3/getdtablesize.3:32
#: build/C/man3/gethostid.3:34 build/C/man2/gethostname.2:37
#: build/C/man3/getlogin.3:33 build/C/man2/getpagesize.2:30
#: build/C/man2/idle.2:37 build/C/man3/lockf.3:33 build/C/man2/mincore.2:39
#: build/C/man2/nice.2:36 build/C/man2/pread.2:30 build/C/man2/setup.2:39
#: build/C/man2/swapon.2:42 build/C/man3/tcgetpgrp.3:30
#: build/C/man2/truncate.2:48 build/C/man2/uselib.2:36 build/C/man2/vfork.2:35
#: build/C/man2/vhangup.2:33
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/brk.2:36
msgid "B<int brk(void *>I<addr>B<);>"
msgstr "B<int brk(void *>I<addr>B<);>"

#. type: Plain text
#: build/C/man2/brk.2:38
msgid "B<void *sbrk(intptr_t >I<increment>B<);>"
msgstr "B<void *sbrk(intptr_t >I<increment>B<);>"

#. type: Plain text
#: build/C/man2/brk.2:46
msgid "B<brk>(), B<sbrk>():"
msgstr "B<brk>(), B<sbrk>():"

#. type: TP
#: build/C/man2/brk.2:49 build/C/man3/getcwd.3:60
#: build/C/man3/getdtablesize.3:44 build/C/man2/getpagesize.2:42
#: build/C/man3/ualarm.3:43 build/C/man3/usleep.3:52 build/C/man2/vfork.2:47
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "glibc 2.12 以降:"

#. type: Plain text
#: build/C/man2/brk.2:56
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: Plain text
#: build/C/man2/brk.2:61
msgid ""
"Before glibc 2.12: _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ "
"500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"glibc 2.12 より前: _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ "
"500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/brk.2:76
msgid ""
"B<brk>()  and B<sbrk>()  change the location of the I<program break>, which "
"defines the end of the process's data segment (i.e., the program break is "
"the first location after the end of the uninitialized data segment).  "
"Increasing the program break has the effect of allocating memory to the "
"process; decreasing the break deallocates memory."
msgstr ""
"B<brk>()  と B<sbrk>()  は I<プログラムブレーク (program break)> の場所を変更"
"する。 プログラムブレークはプロセスのデータセグメント (data segment) の 末尾"
"を示す (プログラムブレークは、初期化されていない データセグメントの末尾の直後"
"の場所となる)。 プログラムブレークを増やすということは、そのプロセスへの メモ"
"リを割り当てる効果があり、 プログラムブレークを減らすということは、メモリを解"
"放する ということである。"

#. type: Plain text
#: build/C/man2/brk.2:83
msgid ""
"B<brk>()  sets the end of the data segment to the value specified by "
"I<addr>, when that value is reasonable, the system has enough memory, and "
"the process does not exceed its maximum data size (see B<setrlimit>(2))."
msgstr ""
"B<brk>()  は、データセグメントの末尾を I<addr> で指定した値に設定する。 設定"
"が行われるのは、指定した値が有効で、 システムに十分なメモリがあり、 プロセス"
"のデータサイズの最大値を超えていない場合である (B<setrlimit>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/brk.2:93
msgid ""
"B<sbrk>()  increments the program's data space by I<increment> bytes.  "
"Calling B<sbrk>()  with an I<increment> of 0 can be used to find the current "
"location of the program break."
msgstr ""
"B<sbrk>()  は、プログラムのデータ空間を I<increment> バイトだけ増やす。 "
"I<increment> を 0 にして B<sbrk>()  を呼び出すことで、プログラムの現在のブ"
"レーク (break) 場所を知ることができる。"

#. type: Plain text
#: build/C/man2/brk.2:102
msgid ""
"On success, B<brk>()  returns zero.  On error, -1 is returned, and I<errno> "
"is set to B<ENOMEM>.  (But see I<Linux Notes> below.)"
msgstr ""
"成功した場合、 B<brk>()  は 0 を返す。 エラーの場合には、-1 を返し、 "
"I<errno> に B<ENOMEM> を設定する (ただし「LINUX での注意」を参照すること)。"

#. type: Plain text
#: build/C/man2/brk.2:114
msgid ""
"On success, B<sbrk>()  returns the previous program break.  (If the break "
"was increased, then this value is a pointer to the start of the newly "
"allocated memory).  On error, I<(void\\ *)\\ -1> is returned, and I<errno> "
"is set to B<ENOMEM>."
msgstr ""
"成功した場合、 B<sbrk>()  は変更前のプログラムブレークを返す (プログラムブ"
"レークが増やされた場合、この値は 新しく割り当てられたメモリの先頭を指すポイン"
"タとなる)。 エラーの場合には、 I<(void\\ *)\\ -1> を返し、 I<errno> に "
"B<ENOMEM> を設定する。"

#.  .BR brk ()
#.  and
#.  .BR sbrk ()
#.  are not defined in the C Standard and are deliberately excluded from the
#.  POSIX.1-1990 standard (see paragraphs B.1.1.1.3 and B.8.3.3).
#. type: Plain text
#: build/C/man2/brk.2:122
msgid "4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001."
msgstr ""
"4.3BSD, SUSv1.  SUSv2 では「過去の名残 (LEGACY)」と位置付けられており、 "
"POSIX.1-2001 で削除された。"

#. type: Plain text
#: build/C/man2/brk.2:131
msgid ""
"Avoid using B<brk>()  and B<sbrk>(): the B<malloc>(3)  memory allocation "
"package is the portable and comfortable way of allocating memory."
msgstr ""
"B<brk>()  や B<sbrk>()  を使用するのは避けること。 B<malloc>(3)  メモリ割り当"
"てパッケージの方が、移植性が高く、 使いやすいメモリ割り当て方法を提供してい"
"る。"

#.  One sees
#.  \fIint\fP (e.g., XPGv4, DU 4.0, HP-UX 11, FreeBSD 4.0, OpenBSD 3.2),
#.  \fIssize_t\fP (OSF1 2.0, Irix 5.3, 6.5),
#.  \fIptrdiff_t\fP (libc4, libc5, ulibc, glibc 2.0, 2.1),
#.  \fIintptr_t\fP (e.g., XPGv5, AIX, SunOS 5.8, 5.9, FreeBSD 4.7, NetBSD 1.6,
#.  Tru64 5.1, glibc2.2).
#. type: Plain text
#: build/C/man2/brk.2:141
msgid ""
"Various systems use various types for the argument of B<sbrk>().  Common are "
"I<int>, I<ssize_t>, I<ptrdiff_t>, I<intptr_t>."
msgstr ""
"いろいろなシステムにおいて、 B<sbrk>()  の引き数に様々な型が使われている。 一"
"般的なのは I<int>, I<ssize_t>, I<ptrdiff_t>, I<intptr_t> である。"

#. type: SS
#: build/C/man2/brk.2:141 build/C/man2/vfork.2:213
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/brk.2:157
msgid ""
"The return value described above for B<brk>()  is the behavior provided by "
"the glibc wrapper function for the Linux B<brk>()  system call.  (On most "
"other implementations, the return value from B<brk>()  is the same; this "
"return value was also specified in SUSv2.)  However, the actual Linux system "
"call returns the new program break on success.  On failure, the system call "
"returns the current break.  The glibc wrapper function does some work (i.e., "
"checks whether the new break is less than I<addr>)  to provide the 0 and -1 "
"return values described above."
msgstr ""
"上で説明した B<brk>()  の返り値についての動作は、 Linux の B<brk>()  システム"
"コールをラップする glibc の関数によるものである。 (その他の多くの実装でも、 "
"B<brk>()  の返り値はこれと同じである。 この返り値は SUSv2 でも規定されてい"
"る。)  しかし、実際の Linux システムコールは、成功した場合、 プログラムの新し"
"いブレークを返す。 失敗した場合、このシステムコールは現在のブレークを返す。 "
"glibc ラッパー関数は同様の働きをし (すなわち、新しいブレークが I<addr> より小"
"さいかどうかをチェックし)、 上で説明した 0 と -1 という返り値を返す。"

#. type: Plain text
#: build/C/man2/brk.2:164
msgid ""
"On Linux, B<sbrk>()  is implemented as a library function that uses the "
"B<brk>()  system call, and does some internal bookkeeping so that it can "
"return the old break value."
msgstr ""
"Linux では B<sbrk>()  は B<brk>()  システムコールを使うライブラリ関数として実"
"装されており、 以前のブレークの値を返すことができるように内部で調整が行われて"
"いる。"

#. type: Plain text
#: build/C/man2/brk.2:169
msgid "B<execve>(2), B<getrlimit>(2), B<end>(3), B<malloc>(3)"
msgstr "B<execve>(2), B<getrlimit>(2), B<end>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/chdir.2:33
#, no-wrap
msgid "CHDIR"
msgstr "CHDIR"

#. type: TH
#: build/C/man2/chdir.2:33
#, no-wrap
msgid "2010-11-25"
msgstr "2010-11-25"

#. type: Plain text
#: build/C/man2/chdir.2:36
msgid "chdir, fchdir - change working directory"
msgstr "chdir, fchdir - 作業ディレクトリの変更"

#. type: Plain text
#: build/C/man2/chdir.2:40
msgid "B<int chdir(const char *>I<path>B<);>"
msgstr "B<int chdir(const char *>I<path>B<);>"

#. type: Plain text
#: build/C/man2/chdir.2:42
msgid "B<int fchdir(int >I<fd>B<);>"
msgstr "B<int fchdir(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/chdir.2:49
msgid "B<fchdir>():"
msgstr "B<fchdir>():"

#. type: Plain text
#: build/C/man2/chdir.2:54 build/C/man2/chmod.2:62 build/C/man2/chown.2:71
#: build/C/man3/gethostid.3:50 build/C/man2/truncate.2:66
#: build/C/man2/truncate.2:74
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/chdir.2:56 build/C/man2/chmod.2:64 build/C/man2/chown.2:73
#: build/C/man2/pread.2:50 build/C/man2/truncate.2:68
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: build/C/man2/chdir.2:64
msgid ""
"B<chdir>()  changes the current working directory of the calling process to "
"the directory specified in I<path>."
msgstr ""
"B<chdir>()  は、呼び出し元プロセスの現在の作業ディレクトリ (current working "
"directory) を、 I<path> に指定されたディレクトリに変更する。"

#. type: Plain text
#: build/C/man2/chdir.2:70
msgid ""
"B<fchdir>()  is identical to B<chdir>(); the only difference is that the "
"directory is given as an open file descriptor."
msgstr ""
"B<fchdir>()  は、ディレクトリがオープンされたファイルディスクリプタとして 指"
"定される以外は、 B<chdir>()  と同じである。"

#. type: Plain text
#: build/C/man2/chdir.2:75 build/C/man2/chmod.2:236 build/C/man2/chown.2:224
#: build/C/man2/chroot.2:95 build/C/man2/flock.2:116
#: build/C/man2/getdomainname.2:80 build/C/man2/gethostname.2:94
#: build/C/man2/ioperm.2:87 build/C/man3/lockf.3:121 build/C/man2/swapon.2:113
#: build/C/man2/sysinfo.2:79 build/C/man2/truncate.2:115
#: build/C/man2/uname.2:68 build/C/man2/uselib.2:53 build/C/man2/vhangup.2:55
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/chdir.2:81
msgid ""
"Depending on the filesystem, other errors can be returned.  The more general "
"errors for B<chdir>()  are listed below:"
msgstr ""
"ファイルシステムによっては他のエラーが返される事がある。 B<chdir>()  で一般的"
"なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chdir.2:87
msgid ""
"Search permission is denied for one of the components of I<path>.  (See also "
"B<path_resolution>(7).)"
msgstr ""
"I<path> の構成要素のいずれかに検索許可 (search permission) がない "
"(B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/chdir.2:91 build/C/man2/chroot.2:109
msgid "I<path> points outside your accessible address space."
msgstr "I<path> がアクセスできるアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/chdir.2:98 build/C/man2/chroot.2:116
msgid "Too many symbolic links were encountered in resolving I<path>."
msgstr "I<path> を解決する際に遭遇したシンボリックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/chdir.2:102 build/C/man2/chroot.2:120
msgid "I<path> is too long."
msgstr "I<path> が長過ぎる。"

#. type: Plain text
#: build/C/man2/chdir.2:105 build/C/man2/chmod.2:266 build/C/man2/chown.2:251
#: build/C/man2/chroot.2:123
msgid "The file does not exist."
msgstr "ファイルが存在しない。"

#. type: Plain text
#: build/C/man2/chdir.2:113 build/C/man2/chroot.2:131
msgid "A component of I<path> is not a directory."
msgstr "I<path> の構成要素がディレクトリではない。"

#. type: Plain text
#: build/C/man2/chdir.2:117
msgid "The general errors for B<fchdir>()  are listed below:"
msgstr "B<fchdir>()  で一般的なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chdir.2:121
msgid "Search permission was denied on the directory open on I<fd>."
msgstr "I<fd> をディレクトリとしてオープンするための検索許可がない。"

#. type: Plain text
#: build/C/man2/chdir.2:125 build/C/man3/tcgetpgrp.3:91
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が適切なファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/chdir.2:127
msgid "SVr4, 4.4BSD, POSIX.1-2001."
msgstr "SVr4, 4.4BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/chdir.2:130
msgid ""
"The current working directory is the starting point for interpreting "
"relative pathnames (those not starting with \\(aq/\\(aq)."
msgstr ""
"現在の作業ディレクトリは、相対パス名 (\\(aq/\\(aq) で始まっていないパス名) "
"を 解釈する際の開始点である。"

#. type: Plain text
#: build/C/man2/chdir.2:136
msgid ""
"A child process created via B<fork>(2)  inherits its parent's current "
"working directory.  The current working directory is left unchanged by "
"B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスの現在の作業ディレクトリを 継"
"承する。 B<execve>(2)  の前後で、現在の作業ディレクトリは変更されない。"

#. type: Plain text
#: build/C/man2/chdir.2:140
msgid "B<chroot>(2), B<getcwd>(3), B<path_resolution>(7)"
msgstr "B<chroot>(2), B<getcwd>(3), B<path_resolution>(7)"

#. type: TH
#: build/C/man2/chmod.2:32
#, no-wrap
msgid "CHMOD"
msgstr "CHMOD"

#. type: Plain text
#: build/C/man2/chmod.2:35
#, fuzzy
#| msgid "chmod, fchmod - change permissions of a file"
msgid "chmod, fchmod, fchmodat - change permissions of a file"
msgstr "chmod, fchmod - ファイルのモードを変更する"

#. type: Plain text
#: build/C/man2/chmod.2:38
#, no-wrap
msgid "B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr "B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/chmod.2:40
#, no-wrap
msgid "B<int chmod(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int chmod(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/chmod.2:42
#, no-wrap
msgid "B<int fchmod(int >I<fd>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int fchmod(int >I<fd>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/chmod.2:45
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>           /* AT_* 定数の定義 */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/chmod.2:48
#, no-wrap
msgid "B<int fchmodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, int >I<flags>B<);>\n"
msgstr "B<int fchmodat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/chmod.2:58
msgid "B<fchmod>():"
msgstr "B<fchmod>():"

#. type: Plain text
#: build/C/man2/chmod.2:68
msgid "B<fchmodat>():"
msgstr "B<fchmodat>():"

#. type: Plain text
#: build/C/man2/chmod.2:88
msgid ""
"The B<chmod>()  and B<fchmod>()  system calls change the permissions of a "
"file.  They differ only in how the file is specified:"
msgstr "システムコール B<chmod>() と B<fchmod>() は、ファイルのアクセス許可 (permission) を変更する。 システムコール間の違いは、ファイルの指定の仕方だけである。"

#. type: IP
#: build/C/man2/chmod.2:88 build/C/man2/chmod.2:93 build/C/man2/chown.2:96
#: build/C/man2/chown.2:101 build/C/man2/chown.2:105 build/C/man2/chown.2:366
#: build/C/man2/chown.2:371 build/C/man2/chown.2:377 build/C/man2/dup.2:62
#: build/C/man2/dup.2:68 build/C/man2/dup.2:101 build/C/man2/dup.2:110
#: build/C/man2/execve.2:124 build/C/man2/execve.2:128
#: build/C/man2/execve.2:131 build/C/man2/execve.2:134
#: build/C/man2/execve.2:137 build/C/man2/execve.2:140
#: build/C/man2/execve.2:143 build/C/man2/execve.2:146
#: build/C/man2/execve.2:149 build/C/man2/execve.2:152
#: build/C/man2/execve.2:156 build/C/man2/execve.2:160
#: build/C/man2/execve.2:169 build/C/man2/execve.2:176
#: build/C/man2/execve.2:181 build/C/man2/execve.2:188
#: build/C/man2/execve.2:195 build/C/man2/execve.2:202
#: build/C/man2/execve.2:209 build/C/man2/execve.2:213
#: build/C/man2/execve.2:216 build/C/man2/execve.2:224
#: build/C/man2/execve.2:228 build/C/man2/execve.2:233 build/C/man2/fork.2:52
#: build/C/man2/fork.2:56 build/C/man2/fork.2:58 build/C/man2/fork.2:62
#: build/C/man2/fork.2:68 build/C/man2/fork.2:71 build/C/man2/fork.2:74
#: build/C/man2/fork.2:77 build/C/man2/fork.2:82 build/C/man2/fork.2:94
#: build/C/man2/fork.2:101 build/C/man2/fork.2:107 build/C/man2/fork.2:114
#: build/C/man2/fork.2:120 build/C/man2/fork.2:125 build/C/man2/fork.2:133
#: build/C/man2/fork.2:142 build/C/man2/fork.2:156 build/C/man2/fork.2:165
#: build/C/man2/syscalls.2:87 build/C/man2/syscalls.2:90
#: build/C/man2/syscalls.2:96 build/C/man2/syscalls.2:112
#: build/C/man2/syscalls.2:118 build/C/man2/syscalls.2:124
#: build/C/man2/syscalls.2:130 build/C/man2/syscalls.2:137
#: build/C/man2/syscalls.2:691 build/C/man2/syscalls.2:712
#: build/C/man2/syscalls.2:723 build/C/man2/syscalls.2:730
#: build/C/man2/syscalls.2:741 build/C/man2/syscalls.2:753
#: build/C/man2/syscalls.2:774 build/C/man2/syscalls.2:782
#: build/C/man2/vfork.2:193 build/C/man2/vfork.2:197
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/chmod.2:93
msgid ""
"B<chmod>()  changes the permissions of the file specified whose pathname is "
"given in I<pathname>, which is dereferenced if it is a symbolic link."
msgstr "B<chmod>()  は、 I<pathname> で指定されたパス名を持つファイルの許可を変更する。 I<pathname> がシンボリックリンクの場合は、リンクの展開が行われる。"

#. type: Plain text
#: build/C/man2/chmod.2:97
msgid ""
"B<fchmod>()  changes the permissions of the file referred to by the open "
"file descriptor I<fd>."
msgstr ""
"B<fchmod>()  は、オープンされたファイルディスクリプタ I<fd> により参照される"
"ファイルの許可を変更する。"

#. type: Plain text
#: build/C/man2/chmod.2:102
msgid ""
"The new file permissions are specified in I<mode>, which is a bit mask "
"created by ORing together zero or more of the following:"
msgstr ""
"新しいファイル許可は I<mode> で指定される。 I<mode> は、以下に示す値の 0 個以"
"上の OR (論理和) をとって作成される ビットマスクである。"

#. type: TP
#: build/C/man2/chmod.2:102
#, no-wrap
msgid "B<S_ISUID>  (04000)"
msgstr "B<S_ISUID>  (04000)"

#. type: Plain text
#: build/C/man2/chmod.2:106
msgid "set-user-ID (set process effective user ID on B<execve>(2))"
msgstr "set-user-ID (B<execve>(2)  時にプロセスの実効ユーザ ID にセットされる)"

#. type: TP
#: build/C/man2/chmod.2:106
#, no-wrap
msgid "B<S_ISGID>  (02000)"
msgstr "B<S_ISGID>  (02000)"

#. type: Plain text
#: build/C/man2/chmod.2:116
msgid ""
"set-group-ID (set process effective group ID on B<execve>(2); mandatory "
"locking, as described in B<fcntl>(2); take a new file's group from parent "
"directory, as described in B<chown>(2)  and B<mkdir>(2))"
msgstr ""
"set-group-ID (以下の場合に (B<execve>(2)  実行時にプロセスの実効グループ ID "
"にセットされる、 強制ロック (mandatory locking) を行う (B<fcntl>(2)  の説明を"
"参照)、 新しいファイルのグループとして親ディレクトリと同じものを使う "
"(B<chown>(2)  と B<(>mkdirB<(2)> の説明を参照)"

#. type: TP
#: build/C/man2/chmod.2:116
#, no-wrap
msgid "B<S_ISVTX>  (01000)"
msgstr "B<S_ISVTX>  (01000)"

#. type: Plain text
#: build/C/man2/chmod.2:120
msgid "sticky bit (restricted deletion flag, as described in B<unlink>(2))"
msgstr ""
"スティッキービット (sticky bit) (削除制限フラグ、 B<unlink>(2)  の説明を参照)"

#. type: TP
#: build/C/man2/chmod.2:120
#, no-wrap
msgid "B<S_IRUSR>  (00400)"
msgstr "B<S_IRUSR>  (00400)"

#. type: Plain text
#: build/C/man2/chmod.2:123
msgid "read by owner"
msgstr "所有者による読み取り"

#. type: TP
#: build/C/man2/chmod.2:123
#, no-wrap
msgid "B<S_IWUSR>  (00200)"
msgstr "B<S_IWUSR>  (00200)"

#. type: Plain text
#: build/C/man2/chmod.2:126
msgid "write by owner"
msgstr "所有者による書き込み"

#. type: TP
#: build/C/man2/chmod.2:126
#, no-wrap
msgid "B<S_IXUSR>  (00100)"
msgstr "B<S_IXUSR>  (00100)"

#. type: Plain text
#: build/C/man2/chmod.2:130
msgid ""
"execute/search by owner (\"search\" applies for directories, and means that "
"entries within the directory can be accessed)"
msgstr ""
"所有者による実行 (execute) / 検索 (search)  (「検索」はディレクトリに対して適"
"用されるもので、 そのディレクトリ内のエントリーへアクセスできるかを意味する)"

#. type: TP
#: build/C/man2/chmod.2:130
#, no-wrap
msgid "B<S_IRGRP>  (00040)"
msgstr "B<S_IRGRP>  (00040)"

#. type: Plain text
#: build/C/man2/chmod.2:133
msgid "read by group"
msgstr "グループによる読み取り"

#. type: TP
#: build/C/man2/chmod.2:133
#, no-wrap
msgid "B<S_IWGRP>  (00020)"
msgstr "B<S_IWGRP>  (00020)"

#. type: Plain text
#: build/C/man2/chmod.2:136
msgid "write by group"
msgstr "グループによる書き込み"

#. type: TP
#: build/C/man2/chmod.2:136
#, no-wrap
msgid "B<S_IXGRP>  (00010)"
msgstr "B<S_IXGRP>  (00010)"

#. type: Plain text
#: build/C/man2/chmod.2:139
msgid "execute/search by group"
msgstr "グループによる実行 / 検索"

#. type: TP
#: build/C/man2/chmod.2:139
#, no-wrap
msgid "B<S_IROTH>  (00004)"
msgstr "B<S_IROTH>  (00004)"

#. type: Plain text
#: build/C/man2/chmod.2:142
msgid "read by others"
msgstr "他人 (others) による読み取り"

#. type: TP
#: build/C/man2/chmod.2:142
#, no-wrap
msgid "B<S_IWOTH>  (00002)"
msgstr "B<S_IWOTH>  (00002)"

#. type: Plain text
#: build/C/man2/chmod.2:145
msgid "write by others"
msgstr "他人による書き込み"

#. type: TP
#: build/C/man2/chmod.2:145
#, no-wrap
msgid "B<S_IXOTH>  (00001)"
msgstr "B<S_IXOTH>  (00001)"

#. type: Plain text
#: build/C/man2/chmod.2:148
msgid "execute/search by others"
msgstr "他人による実行 / 検索"

#. type: Plain text
#: build/C/man2/chmod.2:153
msgid ""
"The effective UID of the calling process must match the owner of the file, "
"or the process must be privileged (Linux: it must have the B<CAP_FOWNER> "
"capability)."
msgstr ""
"呼び出したプロセスの実効 (effective) UID がファイルの所有者と一致するか、 そ"
"のプロセスが特権を持たなければならない (Linux では B<CAP_FOWNER> ケーパビリ"
"ティ (capability) を持たなければならない)。"

#. type: Plain text
#: build/C/man2/chmod.2:162
msgid ""
"If the calling process is not privileged (Linux: does not have the "
"B<CAP_FSETID> capability), and the group of the file does not match the "
"effective group ID of the process or one of its supplementary group IDs, the "
"B<S_ISGID> bit will be turned off, but this will not cause an error to be "
"returned."
msgstr ""
"呼び出したプロセスに特権がなく (Linux では B<CAP_FSETID> ケーパビリティがな"
"く)、かつファイルのグループ ID が プロセスの実効グループ ID または補助的なグ"
"ループ ID にマッチしない場合、 B<S_ISGID> ビットはオフにされるが、これによっ"
"てエラーが返されることはない。"

#. type: Plain text
#: build/C/man2/chmod.2:174
msgid ""
"As a security measure, depending on the filesystem, the set-user-ID and set-"
"group-ID execution bits may be turned off if a file is written.  (On Linux "
"this occurs if the writing process does not have the B<CAP_FSETID> "
"capability.)  On some filesystems, only the superuser can set the sticky "
"bit, which may have a special meaning.  For the sticky bit, and for set-user-"
"ID and set-group-ID bits on directories, see B<stat>(2)."
msgstr ""
"安全のための処置として、 ファイルシステムによっては、ファイルの書き込みを行う"
"時に セット・ユーザー ID とセット・グループ ID ビットと実行ビットが オフにさ"
"れることがある。 (Linux では、書き込みプロセスが B<CAP_FSETID> ケーパビリティ"
"を持っていない場合に、これが起こる。)  ファイルシステムの中には、スーパーユー"
"ザーだけが 特別の意味を持つスティッキービットを設定できるものがある。 ス"
"ティッキービットとディレクトリに対する セット・ユーザー (グループ) ID ビット"
"については、 B<stat>(2)  を見よ。"

#. type: Plain text
#: build/C/man2/chmod.2:182
msgid ""
"On NFS filesystems, restricting the permissions will immediately influence "
"already open files, because the access control is done on the server, but "
"open files are maintained by the client.  Widening the permissions may be "
"delayed for other clients if attribute caching is enabled on them."
msgstr ""
"NFS ファイルシステム上では、パーミッションを制限すると、 既にオープンされてい"
"るファイルに対してすぐに影響が及ぶ。 これはアクセス制御がサーバー上で行われて"
"いるが、 オープンされているファイルはクライアント側で管理されているためであ"
"る。 クライアント側でファイル属性のキャッシュが有効になっている場合に、 パー"
"ミッションの制限を緩くすると、 他のクライアントに情報が伝わるのが遅れるかもし"
"れない。"

#. type: SS
#: build/C/man2/chmod.2:182
#, no-wrap
msgid "fchmodat()"
msgstr "fchmodat()"

#. type: Plain text
#: build/C/man2/chmod.2:188
msgid ""
"The B<fchmodat>()  system call operates in exactly the same way as B<chmod>"
"(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:198
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<chmod>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:210
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<chmod>())."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:219
msgid "I<flags> can either be 0, or include the following flag:"
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:226
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead operate on "
"the link itself.  This flag is not currently implemented."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:231
msgid "See B<openat>(2)  for an explanation of the need for B<fchmodat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:239 build/C/man2/chown.2:227
#, fuzzy
#| msgid ""
#| "Depending on the filesystem, other errors can be returned.  The more "
#| "general errors are listed below:"
msgid ""
"Depending on the filesystem, errors other than those listed below can be "
"returned."
msgstr ""
"ファイルシステムによっては他のエラーが返される事がある。 一般的なエラーを以下"
"に挙げる:"

#. type: Plain text
#: build/C/man2/chmod.2:243
#, fuzzy
#| msgid "The general errors for B<fchmod>()  are listed below:"
msgid "The more general errors for B<chmod>()  are listed below:"
msgstr "B<fchmod>()  で一般的なエラーを挙げる:"

#.  Also search permission is required on the final component,
#.  maybe just to guarantee that it is a directory?
#. type: Plain text
#: build/C/man2/chmod.2:248 build/C/man2/chown.2:236 build/C/man2/chroot.2:105
msgid ""
"Search permission is denied on a component of the path prefix.  (See also "
"B<path_resolution>(7).)"
msgstr "パス名の構成要素に検索許可がない (B<path_resolution>(7)  も見よ)。"

#. type: Plain text
#: build/C/man2/chmod.2:272 build/C/man2/chown.2:257
#: build/C/man2/truncate.2:164
msgid "A component of the path prefix is not a directory."
msgstr "パス名の構成要素がディレクトリではない。"

#. type: TP
#: build/C/man2/chmod.2:272 build/C/man2/chmod.2:293 build/C/man2/chown.2:257
#: build/C/man2/chown.2:277 build/C/man2/chroot.2:131 build/C/man3/crypt.3:169
#: build/C/man2/execve.2:443 build/C/man2/execve.2:449
#: build/C/man2/fcntl.2:1157 build/C/man2/getdomainname.2:91
#: build/C/man3/gethostid.3:88 build/C/man2/gethostname.2:117
#: build/C/man2/idle.2:56 build/C/man2/ioperm.2:101 build/C/man2/mkdir.2:178
#: build/C/man2/nice.2:62 build/C/man2/setup.2:57 build/C/man2/swapon.2:152
#: build/C/man3/tcgetpgrp.3:104 build/C/man2/truncate.2:164
#: build/C/man2/vhangup.2:56
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/chmod.2:278
msgid ""
"The effective UID does not match the owner of the file, and the process is "
"not privileged (Linux: it does not have the B<CAP_FOWNER> capability)."
msgstr ""
"実効 UID がファイルの所有者と一致せず、プロセスに特権がない (Linux では "
"B<CAP_FOWNER> ケーパビリティを持たない)。"

#. type: Plain text
#: build/C/man2/chmod.2:281 build/C/man2/chown.2:264
#: build/C/man2/truncate.2:173
msgid "The named file resides on a read-only filesystem."
msgstr "ファイルが読み込み専用 (read only) のファイルシステム上にある。"

#. type: Plain text
#: build/C/man2/chmod.2:285
msgid "The general errors for B<fchmod>()  are listed below:"
msgstr "B<fchmod>()  で一般的なエラーを挙げる:"

#. type: Plain text
#: build/C/man2/chmod.2:290
msgid "The file descriptor I<fd> is not valid."
msgstr "ファイルディスクリプタ I<fd> が有効でない。"

#. type: Plain text
#: build/C/man2/chmod.2:293 build/C/man2/chmod.2:296 build/C/man2/chmod.2:299
#: build/C/man2/chown.2:277 build/C/man2/chown.2:280 build/C/man2/chown.2:283
msgid "See above."
msgstr "上記を参照。"

#. type: Plain text
#: build/C/man2/chmod.2:306
msgid ""
"The same errors that occur for B<chmod>()  can also occur for B<fchmodat>"
"().  The following additional errors can occur for B<fchmodat>():"
msgstr ""

#. type: TP
#: build/C/man2/chmod.2:320
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man2/chmod.2:326
msgid "I<flags> specified B<AT_SYMLINK_NOFOLLOW>, which is not supported."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:330
#, fuzzy
#| msgid ""
#| "B<dup3>()  was added to Linux in version 2.6.27; glibc support is "
#| "available starting with version 2.9."
msgid ""
"B<fchmodat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<dup3>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポートは"
"バージョン 2.9 以降で利用できる。"

#. type: Plain text
#: build/C/man2/chmod.2:334
msgid "B<chmod>(), B<fchmod>(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008."
msgstr "B<chmod>(), B<fchmod>(): 4.4BSD, SVr4, POSIX.1-2001i, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/chmod.2:337
msgid "B<fchmodat>(): POSIX.1-2008."
msgstr "B<fchmodat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/chmod.2:347
msgid ""
"The GNU C library B<fchmodat>()  wrapper function implements the POSIX-"
"specified interface described in this page.  This interface differs from the "
"underlying Linux system call, which does I<not> have a I<flags> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/chmod.2:354
msgid ""
"B<chown>(2), B<execve>(2), B<open>(2), B<stat>(2), B<path_resolution>(7), "
"B<symlink>(7)"
msgstr "B<chown>(2), B<execve>(2), B<open>(2), B<stat>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/chown.2:38
#, no-wrap
msgid "CHOWN"
msgstr "CHOWN"

#. type: Plain text
#: build/C/man2/chown.2:41
msgid "chown, fchown, lchown, fchownat - change ownership of a file"
msgstr "chown, fchown, lchown, fchownat - ファイルの所有者を変更する"

#. type: Plain text
#: build/C/man2/chown.2:46
#, no-wrap
msgid "B<int chown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
msgstr "B<int chown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"

#. type: Plain text
#: build/C/man2/chown.2:48
#, no-wrap
msgid "B<int fchown(int >I<fd>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
msgstr "B<int fchown(int >I<fd>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"

#. type: Plain text
#: build/C/man2/chown.2:50
#, no-wrap
msgid "B<int lchown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"
msgstr "B<int lchown(const char *>I<pathname>B<, uid_t >I<owner>B<, gid_t >I<group>B<);>\n"

#. type: Plain text
#: build/C/man2/chown.2:56
#, no-wrap
msgid ""
"B<int fchownat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<             uid_t >I<owner>B<, gid_t >I<group>B<, int >I<flags>B<);>\n"
msgstr ""
"B<int fchownat(int >I<dirfd>B<, const char *>I<pathname>B<,>\n"
"B<             uid_t >I<owner>B<, gid_t >I<group>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/chown.2:66
msgid "B<fchown>(), B<lchown>():"
msgstr "B<fchown>(), B<lchown>():"

#. type: Plain text
#: build/C/man2/chown.2:76
msgid "B<fchownat>():"
msgstr "B<fchownat>():"

#. type: Plain text
#: build/C/man2/chown.2:96
msgid ""
"These system calls change the owner and group of a file.  The B<chown>(), "
"B<fchown>(), and B<lchown>()  system calls differ only in how the file is "
"specified:"
msgstr "これらのシステムコールは、いずれもファイルの所有者 (owner) とグループを変更する。システムコール B<chown>(), B<fchown>(), B<lchown>() 間の違いは、ファイルの指定の仕方だけである。"

#. type: Plain text
#: build/C/man2/chown.2:101
msgid ""
"B<chown>()  changes the ownership of the file specified by I<pathname>, "
"which is dereferenced if it is a symbolic link."
msgstr "B<chown>()  は I<pathname> で指定されたファイルの所有権を変更する。 I<pathname> がシンボリックリンクの場合は、リンクの展開が行われる。"

#. type: Plain text
#: build/C/man2/chown.2:105
msgid ""
"B<fchown>()  changes the ownership of the file referred to by the open file "
"descriptor I<fd>."
msgstr ""
"B<fchown>()  はオープンされたファイルディスクリプタ I<fd> により参照される"
"ファイルの所有権を変更する。"

#. type: Plain text
#: build/C/man2/chown.2:110
msgid ""
"B<lchown>()  is like B<chown>(), but does not dereference symbolic links."
msgstr ""
"B<lchown>()  は B<chown>()  と同じだが、シンボリックリンクを展開しない点が異"
"なる。"

#. type: Plain text
#: build/C/man2/chown.2:119
msgid ""
"Only a privileged process (Linux: one with the B<CAP_CHOWN> capability) may "
"change the owner of a file.  The owner of a file may change the group of the "
"file to any group of which that owner is a member.  A privileged process "
"(Linux: with B<CAP_CHOWN>)  may change the group arbitrarily."
msgstr ""
"特権を持つプロセス (Linux では B<CAP_CHOWN> ケーパビリティ (capability) を持"
"つプロセス) だけが ファイルの所有者を変更できる。 ファイルの所有者は、その所"
"有者が属しているグループのいずれかに ファイルのグループを変更することができ"
"る。 特権 (Linux では B<CAP_CHOWN>)  を持つプロセスは、任意のグループに変更で"
"きる。"

#. type: Plain text
#: build/C/man2/chown.2:125
msgid ""
"If the I<owner> or I<group> is specified as -1, then that ID is not changed."
msgstr ""
"I<owner> または I<group> に -1 が指定された場合、それらの ID は変更されない。"

#.  In Linux 2.0 kernels, superuser was like everyone else
#.  In 2.2, up to 2.2.12, these bits were not cleared for superuser.
#.  Since 2.2.13, superuser is once more like everyone else.
#. type: Plain text
#: build/C/man2/chown.2:145
msgid ""
"When the owner or group of an executable file are changed by an unprivileged "
"user the B<S_ISUID> and B<S_ISGID> mode bits are cleared.  POSIX does not "
"specify whether this also should happen when root does the B<chown>(); the "
"Linux behavior depends on the kernel version.  In case of a non-group-"
"executable file (i.e., one for which the B<S_IXGRP> bit is not set) the "
"B<S_ISGID> bit indicates mandatory locking, and is not cleared by a B<chown>"
"()."
msgstr ""
"非特権ユーザーにより実行ファイルの所有者またはグループが 変更された場合は "
"B<S_ISUID> と B<ISGID> モードビットはクリアされる。 POSIX はこの動作やルート"
"が B<chown>()  を行なった場合については特に指定されていない。 Linux における"
"動作はカーネルのバージョンに依存する。 非グループ実行ファイル (B<S_IXGRP> "
"ビットが設定されていないファイル) の場合には B<S_ISGID> ビットは強制ロック "
"(mandatory locking) を意味している。 そしてそれは B<chown>()  ではクリアでき"
"ない。"

#. type: SS
#: build/C/man2/chown.2:145
#, no-wrap
msgid "fchownat()"
msgstr "fchownat()"

#. type: Plain text
#: build/C/man2/chown.2:151
msgid ""
"The B<fchownat>()  system call operates in exactly the same way as B<chown>"
"(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:161
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<chown>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:173
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<chown>())."
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:184
#, fuzzy
#| msgid ""
#| "The new file permissions are specified in I<mode>, which is a bit mask "
#| "created by ORing together zero or more of the following:"
msgid ""
"The I<flags> argument is a bit mask created by ORing together 0 or more of "
"the following values;"
msgstr ""
"新しいファイル許可は I<mode> で指定される。 I<mode> は、以下に示す値の 0 個以"
"上の OR (論理和) をとって作成される ビットマスクである。"

#. type: TP
#: build/C/man2/chown.2:184
#, no-wrap
msgid "B<AT_EMPTY_PATH> (since Linux 2.6.39)"
msgstr "B<AT_EMPTY_PATH> (Linux 2.6.39 以降)"

#.  commit 65cfc6722361570bfe255698d9cd4dccaf47570d
#.  Before glibc 2.16, defining _ATFILE_SOURCE sufficed
#. type: Plain text
#: build/C/man2/chown.2:202
msgid ""
"If I<pathname> is an empty string, operate on the file referred to by "
"I<dirfd> (which may have been obtained using the B<open>(2)  B<O_PATH> "
"flag).  In this case, I<dirfd> can refer to any type of file, not just a "
"directory.  This flag is Linux-specific; define B<_GNU_SOURCE> to obtain its "
"definition."
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:214
msgid ""
"If I<pathname> is a symbolic link, do not dereference it: instead operate on "
"the link itself, like B<lchown>().  (By default, B<fchownat>()  dereferences "
"symbolic links, like B<chown>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:219
msgid "See B<openat>(2)  for an explanation of the need for B<fchownat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:231
#, fuzzy
#| msgid "The general errors for B<fchown>()  are listed below:"
msgid "The more general errors for B<chown>()  are listed below."
msgstr "B<fchown>()  で一般的なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chown.2:261
msgid ""
"The calling process did not have the required permissions (see above) to "
"change owner and/or group."
msgstr ""
"呼び出したプロセスに所有者またはグループ (もしくはその両方) を変更するために "
"要求される許可 (上記を参照) がない。"

#. type: Plain text
#: build/C/man2/chown.2:268
msgid "The general errors for B<fchown>()  are listed below:"
msgstr "B<fchown>()  で一般的なエラーを以下に挙げる:"

#. type: Plain text
#: build/C/man2/chown.2:271
msgid "The descriptor is not valid."
msgstr "ディスクリプターが有効でない。"

#. type: Plain text
#: build/C/man2/chown.2:274
msgid "A low-level I/O error occurred while modifying the inode."
msgstr "i ノード (inode) を変更する際に低レベル I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/chown.2:290
msgid ""
"The same errors that occur for B<chown>()  can also occur for B<fchownat>"
"().  The following additional errors can occur for B<fchownat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:308
#, fuzzy
#| msgid ""
#| "B<dup3>()  was added to Linux in version 2.6.27; glibc support is "
#| "available starting with version 2.9."
msgid ""
"B<fchownat>()  was added to Linux in kernel 2.6.16; library support was "
"added to glibc in version 2.4."
msgstr ""
"B<dup3>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポートは"
"バージョン 2.9 以降で利用できる。"

#. type: Plain text
#: build/C/man2/chown.2:313
msgid ""
"B<chown>(), B<fchown>(), B<lchown>(): 4.4BSD, SVr4, POSIX.1-2001, "
"POSIX.1-2008."
msgstr ""

#.  chown():
#.  SVr4 documents EINVAL, EINTR, ENOLINK and EMULTIHOP returns, but no
#.  ENOMEM.  POSIX.1 does not document ENOMEM or ELOOP error conditions.
#.  fchown():
#.  SVr4 documents additional EINVAL, EIO, EINTR, and ENOLINK
#.  error conditions.
#. type: Plain text
#: build/C/man2/chown.2:322
msgid ""
"The 4.4BSD version can be used only by the superuser (that is, ordinary "
"users cannot give away files)."
msgstr ""
"4.4BSD 版ではスーパーユーザーのみが使用できる (つまり、普通のユーザーはファイ"
"ルを手放すことはできない)。"

#. type: Plain text
#: build/C/man2/chown.2:325
msgid "B<fchownat>(): POSIX.1-2008."
msgstr "B<fchownat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/chown.2:344
msgid ""
"The original Linux B<chown>(), B<fchown>(), and B<lchown>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<chown32>(), B<fchown32>(), and B<lchown32>(), supporting 32-bit IDs.  The "
"glibc B<chown>(), B<fchown>(), and B<lchown>()  wrapper functions "
"transparently deal with the variations across kernel versions."
msgstr ""
"元々の Linux の B<chown>(), B<fchown>(), B<lchown>() システムコールは、\n"
"16 ビットのユーザ ID とグループ ID だけに対応していた。\n"
"その後、 32 ビットの ID に対応した B<chown32>(), B<fchown32>(), B<lchown32>"
"()\n"
"が Linux 2.4 で追加された。\n"
"B<chown>(), B<fchown>(), and B<lchown>() の glibc のラッパー関数は、\n"
"カーネルのバージョンによる違いを吸収している。"

#. type: Plain text
#: build/C/man2/chown.2:366
msgid ""
"When a new file is created (by, for example, B<open>(2)  or B<mkdir>(2)), "
"its owner is made the same as the filesystem user ID of the creating "
"process.  The group of the file depends on a range of factors, including the "
"type of filesystem, the options used to mount the filesystem, and whether or "
"not the set-group-ID permission bit is enabled on the parent directory.  If "
"the filesystem supports the I<-o\\ grpid> (or, synonymously I<-o\\ "
"bsdgroups>)  and I<-o\\ nogrpid> (or, synonymously I<-o\\ sysvgroups>)  "
"B<mount>(8)  options, then the rules are as follows:"
msgstr ""
"(B<open>(2)  や B<mkdir>(2)  などにより) 新しいファイルが作成されるとき、 そ"
"の所有者は呼び出したプロセスのファイルシステムユーザ ID と 同じに設定され"
"る。 そのファイルのグループはいくつかの要因により決定される。 その要因として"
"は、 ファイルシステムの種類、そのファイルシステムのマウント時に 使用されたオ"
"プション、親ディレクトリで set-group-ID 許可ビットが 有効になっているどうか、"
"がある。 ファイルシステムが B<mount>(8)  オプションの I<-o\\ grpid> (I<-o\\ "
"bsdgroups> も同義語) と I<-o\\ nogrpid> (I<-o sysvgroups> も同義語) に対応し"
"ている場合、ルールは以下の通りとなる。"

#. type: Plain text
#: build/C/man2/chown.2:371
msgid ""
"If the filesystem is mounted with I<-o\\ grpid>, then the group of a new "
"file is made the same as that of the parent directory."
msgstr ""
"ファイルシステムが I<-o\\ grpid> 付きでマウントされている場合、新しいファイル"
"のグループは 親ディレクトリのグループと同じになる。"

#. type: Plain text
#: build/C/man2/chown.2:377
msgid ""
"If the filesystem is mounted with I<-o\\ nogrpid> and the set-group-ID bit "
"is disabled on the parent directory, then the group of a new file is made "
"the same as the process's filesystem GID."
msgstr ""
"ファイルシステムが I<-o\\ nogrpid> 付きでマウントされており、親ディレクトリで"
"は set-group-ID ビットが 無効になっている場合、新しいファイルのグループは プ"
"ロセスのファイルシステム GID と同じになる。"

#. type: Plain text
#: build/C/man2/chown.2:383
msgid ""
"If the filesystem is mounted with I<-o\\ nogrpid> and the set-group-ID bit "
"is enabled on the parent directory, then the group of a new file is made the "
"same as that of the parent directory."
msgstr ""
"ファイルシステムが I<-o\\ nogrpid> 付きでマウントされており、親ディレクトリで"
"は set-group-ID ビットが 有効になっている場合、新しいファイルのグループは 親"
"ディレクトリのグループと同じになる。"

#. type: Plain text
#: build/C/man2/chown.2:393
msgid ""
"As at Linux 2.6.25, the I<-o\\ grpid> and I<-o\\ nogrpid> mount options are "
"supported by ext2, ext3, ext4, and XFS.  Filesystems that don't support "
"these mount options follow the I<-o\\ nogrpid> rules."
msgstr ""
"Linux 2.6.25 では、マウントオプション I<-o\\ grpid> と I<-o\\ nogrpid> に対応"
"しているファイルシステムは ext2, ext3, ext4, XFS である。 これらのマウントオ"
"プションに対応していないファイルシステムでは、 I<-o\\ nogrpid> に関するルール"
"が適用される。"

#. type: Plain text
#: build/C/man2/chown.2:406
msgid ""
"The B<chown>()  semantics are deliberately violated on NFS filesystems which "
"have UID mapping enabled.  Additionally, the semantics of all system calls "
"which access the file contents are violated, because B<chown>()  may cause "
"immediate access revocation on already open files.  Client side caching may "
"lead to a delay between the time where ownership have been changed to allow "
"access for a user and the time where the file can actually be accessed by "
"the user on other clients."
msgstr ""
"B<chown>()  方式は UID マッピングを使用した NFS ファイルシステムを侵害する。 "
"さらにファイルの内容にアクセスする全てのシステムコールを侵害する。 これは "
"B<chown>()  が既にオープンされたファイルに対する アクセスをただちに取り消すこ"
"とによる。 クライアント側のキャッシュにより所有権が変更されて ユーザーのアク"
"セスが許した時点と、実際に他のクライアントでユーザーによって ファイルにアクセ"
"スできる時点との間に時間差があるかもしれない。"

#. type: Plain text
#: build/C/man2/chown.2:421
msgid ""
"In versions of Linux prior to 2.1.81 (and distinct from 2.1.46), B<chown>()  "
"did not follow symbolic links.  Since Linux 2.1.81, B<chown>()  does follow "
"symbolic links, and there is a new system call B<lchown>()  that does not "
"follow symbolic links.  Since Linux 2.1.86, this new call (that has the same "
"semantics as the old B<chown>())  has got the same syscall number, and "
"B<chown>()  got the newly introduced number."
msgstr ""
"Linux の 2.1.81 より前のバージョン (特に 2.1.46 以前) では、 B<chown>()  はシ"
"ンボリックリンクを追跡しない。 Linux 2.1.81 以降では B<chown>()  はシンボリッ"
"クリンクを追跡し、新たなシステムコール B<lchown>()  はシンボリックリンクを追"
"跡しない。 Linux 2.1.86 以降ではこの新しいコール (古い B<chown>()  と全く同じ"
"動作を行なう) は同じシステムコール番号を持ち B<chown>()  は新しく導入された番"
"号を持つ。"

#. type: Plain text
#: build/C/man2/chown.2:430
msgid ""
"The following program changes the ownership of the file named in its second "
"command-line argument to the value specified in its first command-line "
"argument.  The new owner can be specified either as a numeric user ID, or as "
"a username (which is converted to a user ID by using B<getpwnam>(3)  to "
"perform a lookup in the system password file)."
msgstr ""
"以下のプログラムは、 二つ目のコマンドライン引き数で指定された名前のファイルの"
"所有者を、 一つ目のコマンドライン引き数で指定された値に変更する。 新しい所有"
"者は、数字のユーザ ID かユーザ名のいずれかで指定できる (ユーザ名で指定した場"
"合には、 B<getpwnam>(3)  を使ってシステムのパスワードファイルの検索が行わ"
"れ、 ユーザ ID への変換が行われる)。"

#. type: SS
#: build/C/man2/chown.2:430
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/chown.2:436
#, no-wrap
msgid ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pwd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/chown.2:443
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uid_t uid;\n"
"    struct passwd *pwd;\n"
"    char *endptr;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    uid_t uid;\n"
"    struct passwd *pwd;\n"
"    char *endptr;\n"

#. type: Plain text
#: build/C/man2/chown.2:448
#, no-wrap
msgid ""
"    if (argc != 3 || argv[1][0] == \\(aq\\e0\\(aq) {\n"
"        fprintf(stderr, \"%s E<lt>ownerE<gt> E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3 || argv[1][0] == \\(aq\\e0\\(aq) {\n"
"        fprintf(stderr, \"%s E<lt>ownerE<gt> E<lt>fileE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/chown.2:450
#, no-wrap
msgid "    uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */\n"
msgstr "    uid = strtol(argv[1], &endptr, 10);  /* Allow a numeric string */\n"

#. type: Plain text
#: build/C/man2/chown.2:457
#, no-wrap
msgid ""
"    if (*endptr != \\(aq\\e0\\(aq) {         /* Was not pure numeric string */\n"
"        pwd = getpwnam(argv[1]);   /* Try getting UID for username */\n"
"        if (pwd == NULL) {\n"
"            perror(\"getpwnam\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""
"    if (*endptr != \\(aq\\e0\\(aq) {         /* Was not pure numeric string */\n"
"        pwd = getpwnam(argv[1]);   /* Try getting UID for username */\n"
"        if (pwd == NULL) {\n"
"            perror(\"getpwnam\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"

#. type: Plain text
#: build/C/man2/chown.2:460
#, no-wrap
msgid ""
"        uid = pwd-E<gt>pw_uid;\n"
"    }\n"
msgstr ""
"        uid = pwd-E<gt>pw_uid;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/chown.2:465
#, no-wrap
msgid ""
"    if (chown(argv[2], uid, -1) == -1) {\n"
"        perror(\"chown\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (chown(argv[2], uid, -1) == -1) {\n"
"        perror(\"chown\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/chown.2:468 build/C/man2/execve.2:571
#: build/C/man3/getopt.3:428 build/C/man3/getopt.3:513
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/chown.2:474
msgid "B<chmod>(2), B<flock>(2), B<path_resolution>(7), B<symlink>(7)"
msgstr "B<chmod>(2), B<flock>(2), B<path_resolution>(7), B<symlink>(7)"

#. type: TH
#: build/C/man2/chroot.2:33
#, no-wrap
msgid "CHROOT"
msgstr "CHROOT"

#. type: Plain text
#: build/C/man2/chroot.2:36
msgid "chroot - change root directory"
msgstr "chroot - ルートディレクトリを変更する"

#. type: Plain text
#: build/C/man2/chroot.2:40
msgid "B<int chroot(const char *>I<path>B<);>"
msgstr "B<int chroot(const char *>I<path>B<);>"

#. type: Plain text
#: build/C/man2/chroot.2:47
msgid "B<chroot>():"
msgstr "B<chroot>():"

#. type: TP
#: build/C/man2/chroot.2:50
#, no-wrap
msgid "Since glibc 2.2.2:"
msgstr "glibc 2.2.2 以降:"

#. type: Plain text
#: build/C/man2/chroot.2:57
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: Plain text
#: build/C/man2/chroot.2:60
msgid "Before glibc 2.2.2: none"
msgstr "glibc 2.2.2 より前: なし"

#. type: Plain text
#: build/C/man2/chroot.2:69
msgid ""
"B<chroot>()  changes the root directory of the calling process to that "
"specified in I<path>.  This directory will be used for pathnames beginning "
"with I</>.  The root directory is inherited by all children of the calling "
"process."
msgstr ""
"B<chroot>()  は、呼び出し元プロセスのルートディレクトリを I<path> で指定され"
"たディレクトリに変更する。 このディレクトリ以下が I</> から始まるパス名として"
"使われる。 このルートディレクトリは呼び出し元のプロセスの全ての子プロセスに受"
"け継がれる。"

#. type: Plain text
#: build/C/man2/chroot.2:74
msgid ""
"Only a privileged process (Linux: one with the B<CAP_SYS_CHROOT> capability) "
"may call B<chroot>()."
msgstr ""
"特権プロセス (Linux では、 B<CAP_SYS_CHROOT> ケーパビリティを持つプロセス) の"
"みが B<chroot>()  を呼び出すことができる。"

#. type: Plain text
#: build/C/man2/chroot.2:77
msgid ""
"This call changes an ingredient in the pathname resolution process and does "
"nothing else."
msgstr ""
"このコールはパス名解決の過程で構成要素を変更するのみで、 その他には何も行わな"
"い。"

#. type: Plain text
#: build/C/man2/chroot.2:83
msgid ""
"This call does not change the current working directory, so that after the "
"call \\(aqI<.>\\(aq can be outside the tree rooted at \\(aqI</>\\(aq.  In "
"particular, the superuser can escape from a \"chroot jail\" by doing:"
msgstr ""
"このコールは現在の作業ディレクトリ (working directory) を変更しない。 そのた"
"め、このコールの後に \\(aqI<.>\\(aq が \\(aqI</>\\(aq を 根とするツリーの外に"
"なる場合がある。 特に、スーパーユーザーは以下のようにすることで \"chroot jail"
"\" から逃げ出せてしまう。"

#. type: Plain text
#: build/C/man2/chroot.2:86
#, no-wrap
msgid "    mkdir foo; chroot foo; cd ..\n"
msgstr "    mkdir foo; chroot foo; cd ..\n"

#. type: Plain text
#: build/C/man2/chroot.2:90
msgid ""
"This call does not close open file descriptors, and such file descriptors "
"may allow access to files outside the chroot tree."
msgstr ""
"このコールはオープンファイルディスクリプタをクローズしないので、 このような"
"ファイルディスクリプタは chroot ツリーの外にある ファイルにアクセスできる。"

#. type: Plain text
#: build/C/man2/chroot.2:98
msgid ""
"Depending on the filesystem, other errors can be returned.  The more general "
"errors are listed below:"
msgstr ""
"ファイルシステムによっては他のエラーが返される事がある。 一般的なエラーを以下"
"に挙げる:"

#. type: Plain text
#: build/C/man2/chroot.2:134
msgid "The caller has insufficient privilege."
msgstr "呼び出し側に十分な特権がない。"

#.  SVr4 documents additional EINTR, ENOLINK and EMULTIHOP error conditions.
#.  X/OPEN does not document EIO, ENOMEM or EFAULT error conditions.
#. type: Plain text
#: build/C/man2/chroot.2:139
msgid ""
"SVr4, 4.4BSD, SUSv2 (marked LEGACY).  This function is not part of "
"POSIX.1-2001."
msgstr ""
"SVr4, 4.4BSD, SUSv2 (但し、SUSv2 では過去の名残とされている)。 この関数は "
"POSIX.1-2001 にはない。"

#. type: Plain text
#: build/C/man2/chroot.2:145
msgid ""
"A child process created via B<fork>(2)  inherits its parent's root "
"directory.  The root directory is left unchanged by B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、 親プロセスのルートディレクトリを継承す"
"る。 B<execve>(2)  の場合も、ルートディレクトリは変更されない。"

#.  FIXME . eventually say something about containers,
#.  virtual servers, etc.?
#. type: Plain text
#: build/C/man2/chroot.2:151
msgid "FreeBSD has a stronger B<jail>()  system call."
msgstr "FreeBSD にはより強力な B<jail>()  システムコールがある。"

#. type: Plain text
#: build/C/man2/chroot.2:154
msgid "B<chdir>(2), B<path_resolution>(7)"
msgstr "B<chdir>(2), B<path_resolution>(7)"

#. type: TH
#: build/C/man2/close.2:35
#, no-wrap
msgid "CLOSE"
msgstr "CLOSE"

#. type: TH
#: build/C/man2/close.2:35
#, no-wrap
msgid "2013-12-30"
msgstr "2013-12-30"

#. type: Plain text
#: build/C/man2/close.2:38
msgid "close - close a file descriptor"
msgstr "close - ファイルディスクリプタをクローズする"

#. type: Plain text
#: build/C/man2/close.2:43
#, no-wrap
msgid "B<int close(int >I<fd>B<);>\n"
msgstr "B<int close(int >I<fd>B<);>\n"

#. type: Plain text
#: build/C/man2/close.2:53
msgid ""
"B<close>()  closes a file descriptor, so that it no longer refers to any "
"file and may be reused.  Any record locks (see B<fcntl>(2))  held on the "
"file it was associated with, and owned by the process, are removed "
"(regardless of the file descriptor that was used to obtain the lock)."
msgstr ""
"B<close>()  は、ファイルディスクリプタをクローズする。 そのディスクリプタは、"
"どのファイルも参照していない状態になり、 再利用が可能になる。 そのファイル"
"ディスクリプタに関連づけられたファイルに かけられたレコードロック (B<fcntl>"
"(2)  参照) のうち、そのプロセスが保有しているものは、 (そのファイルディスクリ"
"プタがロック取得に利用されたか どうかによらず) すべて削除される。"

#. type: Plain text
#: build/C/man2/close.2:64
msgid ""
"If I<fd> is the last file descriptor referring to the underlying open file "
"description (see B<open>(2)), the resources associated with the open file "
"description are freed; if the descriptor was the last reference to a file "
"which has been removed using B<unlink>(2)  the file is deleted."
msgstr ""
"I<fd> が、対応するオープンファイル記述 (open file description)  (B<open>(2)  "
"参照) を参照する最後のファイルディスクリプタだった場合、 オープンファイル記述"
"に関連するリソースが解放される。 そのディスクリプタが、 B<unlink> を使用して"
"削除 (remove) されたファイルに対する最後の参照だった場合には、 そのファイルは"
"削除 (delete) される。"

#. type: Plain text
#: build/C/man2/close.2:70
msgid ""
"B<close>()  returns zero on success.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"B<close>()  は成功した場合は 0 を返す。 エラーが発生した場合は -1 を返して、 "
"I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/close.2:75
msgid "I<fd> isn't a valid open file descriptor."
msgstr "I<fd> が有効なオープンされたディスクリプタでない。"

#. type: TP
#: build/C/man2/close.2:75 build/C/man2/dup.2:143 build/C/man2/fcntl.2:1126
#: build/C/man2/flock.2:121 build/C/man2/truncate.2:133
#: build/C/man3/ualarm.3:85 build/C/man3/usleep.3:83
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/close.2:81
msgid "The B<close>()  call was interrupted by a signal; see B<signal>(7)."
msgstr ""
"B<close>()  コールがシグナルにより中断 (interrupt) された。 B<signal>(7)  参"
"照。"

#. type: Plain text
#: build/C/man2/close.2:87 build/C/man2/fork.2:208 build/C/man3/swab.3:79
#: build/C/man2/umask.2:97
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/close.2:107
#, fuzzy
#| msgid ""
#| "Not checking the return value of B<close>()  is a common but nevertheless "
#| "serious programming error.  It is quite possible that errors on a "
#| "previous B<write>(2)  operation are first reported at the final B<close>"
#| "().  Not checking the return value when closing the file may lead to "
#| "silent loss of data.  This can especially be observed with NFS and with "
#| "disk quota."
msgid ""
"Not checking the return value of B<close>()  is a common but nevertheless "
"serious programming error.  It is quite possible that errors on a previous "
"B<write>(2)  operation are first reported at the final B<close>().  Not "
"checking the return value when closing the file may lead to silent loss of "
"data.  This can especially be observed with NFS and with disk quota.  Note "
"that the return value should only be used for diagnostics.  In particular "
"B<close>()  should not be retried after an B<EINTR> since this may cause a "
"reused descriptor from another thread to be closed."
msgstr ""
"B<close>()  の返り値のチェックはよく省略されるが、 これは深刻なプログラミング"
"エラーである。 前の B<write>(2)  処理に関するエラーが最後の B<close>()  のと"
"きになって初めて通知される場合がありうる。 ファイルクローズの際に返り値を"
"チェックしないと、 気付かないうちにデータを失ってしまうかもしれない。 これは"
"特に NFS やディスククォータを使用した場合に見られる。"

#. type: Plain text
#: build/C/man2/close.2:116
msgid ""
"A successful close does not guarantee that the data has been successfully "
"saved to disk, as the kernel defers writes.  It is not common for a "
"filesystem to flush the buffers when the stream is closed.  If you need to "
"be sure that the data is physically stored use B<fsync>(2).  (It will depend "
"on the disk hardware at this point.)"
msgstr ""
"クローズに成功しても、データがディスクに保存されたかどうかは 保証されない "
"(カーネルが書きこみを遅延させることがあるためである)。 ストリームがクローズさ"
"れるときにバッファをフラッシュするかどうかは、 ファイルシステムによって異な"
"る。 データが物理的に保存されることを保証する必要がある場合には、 B<fsync>"
"(2)  を使用すること (B<fsync>(3)  を行った時点で、データの保存はディスクの"
"ハードウェアに依存する 問題となる)。"

#.  Date: Tue, 4 Sep 2007 13:57:35 +0200
#.  From: Fredrik Noring <noring@nocrew.org>
#.  One such race involves signals and ERESTARTSYS. If a file descriptor
#.  in use by a system call is closed and then reused by e.g. an
#.  independent open() in some unrelated thread, before the original system
#.  call has restarted after ERESTARTSYS, the original system call will
#.  later restart with the reused file descriptor. This is most likely a
#.  serious programming error.
#. type: Plain text
#: build/C/man2/close.2:131
msgid ""
"It is probably unwise to close file descriptors while they may be in use by "
"system calls in other threads in the same process.  Since a file descriptor "
"may be reused, there are some obscure race conditions that may cause "
"unintended side effects."
msgstr ""
"同じプロセス内の他のスレッドのシステムコールが使用している可能性がある間に、 "
"ファイルディスクリプタをクローズするのは、おそらく賢明ではないだろう。 ファイ"
"ルディスクリプタは再利用されるかもしれないので、 あいまいな競合条件となること"
"があり、意図しない副作用の原因となりうる。"

#. type: Plain text
#: build/C/man2/close.2:138
msgid ""
"B<fcntl>(2), B<fsync>(2), B<open>(2), B<shutdown>(2), B<unlink>(2), B<fclose>"
"(3)"
msgstr ""
"B<fcntl>(2), B<fsync>(2), B<open>(2), B<shutdown>(2), B<unlink>(2), B<fclose>"
"(3)"

#. type: TH
#: build/C/man3/confstr.3:31
#, no-wrap
msgid "CONFSTR"
msgstr "CONFSTR"

#. type: TH
#: build/C/man3/confstr.3:31
#, no-wrap
msgid "2012-05-10"
msgstr "2012-05-10"

#. type: TH
#: build/C/man3/confstr.3:31 build/C/man3/daemon.3:36 build/C/man3/exec.3:41
#: build/C/man3/fpathconf.3:41 build/C/man3/get_nprocs_conf.3:26
#: build/C/man3/getcwd.3:32 build/C/man3/getlogin.3:28
#: build/C/man3/getopt.3:41 build/C/man3/getumask.3:28
#: build/C/man3/getusershell.3:30 build/C/man3/lockf.3:28
#: build/C/man3/sleep.3:26 build/C/man3/sysconf.3:27
#: build/C/man3/tcgetpgrp.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/confstr.3:34
msgid "confstr - get configuration dependent string variables"
msgstr "confstr - コンフィグレーションに依存した文字列変数の取得"

#. type: Plain text
#: build/C/man3/confstr.3:39
#, no-wrap
msgid "B<size_t confstr(int >I<name>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"
msgstr "B<size_t confstr(int >I<name>B<, char *>I<buf>B<, size_t >I<len>B<);>\n"

#. type: Plain text
#: build/C/man3/confstr.3:48
msgid "B<confstr>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<confstr>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/confstr.3:51
msgid ""
"B<confstr>()  gets the value of configuration-dependent string variables."
msgstr ""
"B<confstr>()  はコンフィグレーションに依存した文字列変数の値を取得する。"

#. type: Plain text
#: build/C/man3/confstr.3:56
msgid ""
"The I<name> argument is the system variable to be queried.  The following "
"variables are supported:"
msgstr ""
"引き数 I<name> は、問い合わせ内容を表すシステム変数である。 以下の変数がサ"
"ポートされている。"

#. type: TP
#: build/C/man3/confstr.3:56
#, no-wrap
msgid "B<_CS_GNU_LIBC_VERSION> (GNU C library only; since glibc 2.3.2)"
msgstr "B<_CS_GNU_LIBC_VERSION> (GNU C library 限定; glibc 2.3.2 以降)"

#. type: Plain text
#: build/C/man3/confstr.3:60
msgid ""
"A string which identifies the GNU C library version on this system (e.g, "
"\"glibc 2.3.4\")."
msgstr ""
"そのシステムの GNU C ライブラリのバージョンを示す文字列 (例えば \"glibc "
"2.3.4\")。"

#. type: TP
#: build/C/man3/confstr.3:60
#, no-wrap
msgid "B<_CS_GNU_LIBPTHREAD_VERSION> (GNU C library only; since glibc 2.3.2)"
msgstr "B<_CS_GNU_LIBPTHREAD_VERSION> (GNU C library 限定; glibc 2.3.2 以降)"

#. type: Plain text
#: build/C/man3/confstr.3:64
msgid ""
"A string which identifies the POSIX implementation supplied by this C "
"library (e.g, \"NPTL 2.3.4\" or \"linuxthreads-0.10\")."
msgstr ""
"その C ライブラリが提供している POSIX 実装を示す文字列 (例えば \"NPTL "
"2.3.4\" や \"linuxthreads-0.10\")。"

#. type: TP
#: build/C/man3/confstr.3:64
#, no-wrap
msgid "B<_CS_PATH>"
msgstr "B<_CS_PATH>"

#. type: Plain text
#: build/C/man3/confstr.3:70
msgid ""
"A value for the B<PATH> variable which indicates where all the POSIX.2 "
"standard utilities can be found."
msgstr "すべての POSIX.2 標準ユーティリティが見つかるような B<PATH> の値。"

#. type: Plain text
#: build/C/man3/confstr.3:86
msgid ""
"If I<buf> is not NULL and I<len> is not zero, B<confstr>()  copies the value "
"of the string to I<buf> truncated to I<len - 1> bytes if necessary, with a "
"null byte (\\(aq\\e0\\(aq) as terminator.  This can be detected by comparing "
"the return value of B<confstr>()  against I<len>."
msgstr ""
"I<buf> が NULL でなく、かつ I<len> が 0 でなければ B<confstr>() は取得\n"
"した文字列の内容を I<buf> にコピーする。必要ならば長さが I<len - 1> \n"
"バイトに切り捨てられて、NULL バイト (\\(aq\\e0\\(aq) で終端される。\n"
"末尾が切り捨てられたかどうかを判定するには、 B<confstr>() の返り値を\n"
"I<len> と比較すればよい。"

#. type: Plain text
#: build/C/man3/confstr.3:94
msgid ""
"If I<len> is zero and I<buf> is NULL, B<confstr>()  just returns the value "
"as defined below."
msgstr ""
"I<len> が 0 で I<buf> が NULL ならば、 B<confstr>()  は以下で定義された値 (訳"
"注: 切り捨てる前の、取得した文字列の長さ) を返す。"

#. type: Plain text
#: build/C/man3/confstr.3:106
msgid ""
"If I<name> is a valid configuration variable, B<confstr>()  returns the "
"number of bytes (including the terminating null byte)  that would be "
"required to hold the entire value of that variable.  This value may be "
"greater than I<len>, which means that the value in I<buf> is truncated."
msgstr ""
"I<name> が有効なコンフィギュレーション変数の場合、 B<confstr>()  はその変数の"
"値全体を保持するのに必要であったバイト数を返す (文字列終端のヌルバイトも含"
"む)。この値は I<len> より大きいこともある。この場合には、 I<buf> に格納された"
"値の末尾が切り詰められたことを意味する。"

#. type: Plain text
#: build/C/man3/confstr.3:121
msgid ""
"If I<name> is a valid configuration variable, but that variable does not "
"have a value, then B<confstr>()  returns 0.  If I<name> does not correspond "
"to a valid configuration variable, B<confstr>()  returns 0, and I<errno> is "
"set to B<EINVAL>."
msgstr ""
"I<name> が有効なコンフィギュレーション変数だが、 変数が値を持っていない場"
"合、 B<confstr>()  は 0 を返す。 I<name> が有効なコンフィグレーション変数に対"
"応していなければ、 B<confstr>()  は 0 を返し、 I<errno> に B<EINVAL> を設定す"
"る。"

#. type: Plain text
#: build/C/man3/confstr.3:127
msgid "The value of I<name> is invalid."
msgstr "I<name> の値が不正である。"

#. type: Plain text
#: build/C/man3/confstr.3:129 build/C/man3/fpathconf.3:171
#: build/C/man2/pread.2:117 build/C/man3/sleep.3:46 build/C/man3/sysconf.3:326
#: build/C/man3/tcgetpgrp.3:118
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/confstr.3:132
msgid ""
"The following code fragment determines the path where to find the POSIX.2 "
"system utilities:"
msgstr ""
"次の部分的なコードは、 POSIX.2 システムのユーティリティがあるパス を取得する"
"ものである。"

#. type: Plain text
#: build/C/man3/confstr.3:138
#, no-wrap
msgid ""
"char *pathbuf;\n"
"size_t n;\n"
msgstr ""
"char *pathbuf;\n"
"size_t n;\n"

#. type: Plain text
#: build/C/man3/confstr.3:144
#, no-wrap
msgid ""
"n = confstr(_CS_PATH, NULL, (size_t) 0);\n"
"pathbuf = malloc(n);\n"
"if (pathbuf == NULL)\n"
"    abort();\n"
"confstr(_CS_PATH, pathbuf, n);\n"
msgstr ""
"n = confstr(_CS_PATH, NULL, (size_t) 0);\n"
"pathbuf = malloc(n);\n"
"if (pathbuf == NULL)\n"
"    abort();\n"
"confstr(_CS_PATH, pathbuf, n);\n"

#. type: Plain text
#: build/C/man3/confstr.3:150
msgid "B<sh>(1), B<exec>(3), B<system>(3)"
msgstr "B<sh>(1), B<exec>(3), B<system>(3)"

#. type: TH
#: build/C/man3/crypt.3:36
#, no-wrap
msgid "CRYPT"
msgstr "CRYPT"

#. type: TH
#: build/C/man3/crypt.3:36 build/C/man2/swapon.2:37
#, no-wrap
msgid "2014-02-26"
msgstr "2014-02-26"

#. type: Plain text
#: build/C/man3/crypt.3:39
msgid "crypt, crypt_r - password and data encryption"
msgstr "crypt, crypt_r - パスワードとデータの暗号化"

#. type: Plain text
#: build/C/man3/crypt.3:42
#, no-wrap
msgid "B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
msgstr "B<#define _XOPEN_SOURCE>       /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/crypt.3:46
#, no-wrap
msgid "B<char *crypt(const char *>I<key>B<, const char *>I<salt>B<);>\n"
msgstr "B<char *crypt(const char *>I<key>B<, const char *>I<salt>B<);>\n"

#. type: Plain text
#: build/C/man3/crypt.3:48
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"

#. type: Plain text
#: build/C/man3/crypt.3:50
#, no-wrap
msgid "B<#include E<lt>crypt.hE<gt>>\n"
msgstr "B<#include E<lt>crypt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/crypt.3:53
#, no-wrap
msgid ""
"B<char *crypt_r(const char *>I<key>B<, const char *>I<salt>B<,>\n"
"B<              struct crypt_data *>I<data>B<);>\n"
msgstr ""
"B<char *crypt_r(const char *>I<key>B<, const char *>I<salt>B<,>\n"
"B<              struct crypt_data *>I<data>B<);>\n"

#. type: Plain text
#: build/C/man3/crypt.3:56
msgid "Link with I<-lcrypt>."
msgstr "I<-lcrypt> でリンクする。"

#. type: Plain text
#: build/C/man3/crypt.3:62
msgid ""
"B<crypt>()  is the password encryption function.  It is based on the Data "
"Encryption Standard algorithm with variations intended (among other things) "
"to discourage use of hardware implementations of a key search."
msgstr ""
"B<crypt>()  はパスワード暗号化関数である。 鍵探索のハードウェアによる実装を妨"
"げるように(その他にもいろいろ)  変更した Data Encryption Standard アルゴリズ"
"ムを元にしている。"

#. type: Plain text
#: build/C/man3/crypt.3:65
msgid "I<key> is a user's typed password."
msgstr "I<key> はユーザが入力するパスワードである。"

#. type: Plain text
#: build/C/man3/crypt.3:71
msgid ""
"I<salt> is a two-character string chosen from the set [B<a>\\(enB<zA>"
"\\(enB<Z0>\\(enB<9./>].  This string is used to perturb the algorithm in one "
"of 4096 different ways."
msgstr ""
"I<salt> は集合 [B<a>\\(enB<zA>\\(enB<Z0>\\(enB<9./>] から選ばれた 2 文字の文"
"字列である。 この文字列はアルゴリズムの出力を 4096 通りにかき乱すのに使われ"
"る。"

#. type: Plain text
#: build/C/man3/crypt.3:82
msgid ""
"By taking the lowest 7 bits of each of the first eight characters of the "
"I<key>, a 56-bit key is obtained.  This 56-bit key is used to encrypt "
"repeatedly a constant string (usually a string consisting of all zeros).  "
"The returned value points to the encrypted password, a series of 13 "
"printable ASCII characters (the first two characters represent the salt "
"itself).  The return value points to static data whose content is "
"overwritten by each call."
msgstr ""
"I<key> の最初の 8 文字の各文字から下位 7 ビットをとって 56 ビットの鍵が得られ"
"る。 この 56 ビットの鍵は特定の文字列(ふつうはすべて 0 の文字列)  を繰り返し"
"暗号化するのに用いられる。 返り値は暗号化されたパスワードへのポインタで、13 "
"の印字可能な ASCII 文字 からなる(最初の 2 文字は salt そのもの)。 返り値は、"
"関数呼出しのたびに上書きされる静的なデータへのポインタである。"

#. type: Plain text
#: build/C/man3/crypt.3:84
msgid "Warning: The key space consists of"
msgstr "警告: 鍵空間は"

#. type: Plain text
#: build/C/man3/crypt.3:99
msgid ""
"equal 7.2e16 possible values.  Exhaustive searches of this key space are "
"possible using massively parallel computers.  Software, such as B<crack>(1), "
"is available which will search the portion of this key space that is "
"generally used by humans for passwords.  Hence, password selection should, "
"at minimum, avoid common words and names.  The use of a B<passwd>(1)  "
"program that checks for crackable passwords during the selection process is "
"recommended."
msgstr ""
"= 7.2e16 の可能な値から成る。 この鍵空間の全探索は強力な並列計算機を使えば可"
"能である。また B<crack>(1)  のようなソフトウェアはこの鍵空間の中で、多くの人"
"にパスワードとして 使われるような鍵についての全探索が可能である。 それゆえ、"
"パスワードを選択するときには、すくなくとも、 一般的に使われる単語と名前は避け"
"るべきである。 B<passwd>(1)  を使う時にはクラックされうるパスワードについての"
"検査をすることが 推奨される。"

#. type: Plain text
#: build/C/man3/crypt.3:108
msgid ""
"The DES algorithm itself has a few quirks which make the use of the B<crypt>"
"()  interface a very poor choice for anything other than password "
"authentication.  If you are planning on using the B<crypt>()  interface for "
"a cryptography project, don't do it: get a good book on encryption and one "
"of the widely available DES libraries."
msgstr ""
"DES アルゴリズムにはいくつかの癖があり、それによってパスワード認証以外に "
"B<crypt>()  を使うのはたいへんよくない選択となっている。もし B<crypt>()  を暗"
"号プロジェクトに使おうという案をもっているならば、それはやめたほうが よい。暗"
"号化についてのよい本と誰でも入手できる DES ライブラリのひとつを 手にいれるべ"
"きだ。"

#. type: Plain text
#: build/C/man3/crypt.3:120
msgid ""
"B<crypt_r>()  is a reentrant version of B<crypt>().  The structure pointed "
"to by I<data> is used to store result data and bookkeeping information.  "
"Other than allocating it, the only thing that the caller should do with this "
"structure is to set I<data-E<gt>initialized> to zero before the first call "
"to B<crypt_r>()."
msgstr ""
"B<crypt_r>()  は B<crypt>()  の再入可能版である。 I<data> で示される構造体は"
"結果データの保存と情報の管理に使われる。 この構造体に対して(メモリを割り当て"
"ること以外に)呼び出し元がするべき唯一の ことは、 B<crypt_r>()  の初回の呼び出"
"しの前に I<data-E<gt>initialized> をゼロにすることだけである。"

#. type: Plain text
#: build/C/man3/crypt.3:123
msgid ""
"On success, a pointer to the encrypted password is returned.  On error, NULL "
"is returned."
msgstr ""
"成功の場合には、暗号化されたパスワードへのポインターが返される。 エラーの場合"
"には NULL が返される。"

#. type: Plain text
#: build/C/man3/crypt.3:128
msgid "I<salt> has the wrong format."
msgstr ""

#. type: TP
#: build/C/man3/crypt.3:130 build/C/man3/encrypt.3:120
#: build/C/man3/fexecve.3:86 build/C/man2/fork.2:200
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#.  This level of detail is not necessary in this man page. . .
#.  .PP
#.  When encrypting a plain text P using DES with the key K results in the
#.  encrypted text C, then the complementary plain text P' being encrypted
#.  using the complementary key K' will result in the complementary encrypted
#.  text C'.
#.  .PP
#.  Weak keys are keys which stay invariant under the DES key transformation.
#.  The four known weak keys 0101010101010101, fefefefefefefefe,
#.  1f1f1f1f0e0e0e0e and e0e0e0e0f1f1f1f1 must be avoided.
#.  .PP
#.  There are six known half weak key pairs, which keys lead to the same
#.  encrypted data.  Keys which are part of such key clusters should be
#.  avoided.
#.  Sorry, I could not find out what they are.
#. "
#.  .PP
#.  Heavily redundant data causes trouble with DES encryption, when used in the
#.  .I codebook
#.  mode that
#.  .BR crypt ()
#.  implements.  The
#.  .BR crypt ()
#.  interface should be used only for its intended purpose of password
#.  verification, and should not be used as part of a data encryption tool.
#.  .PP
#.  The first and last three output bits of the fourth S-box can be
#.  represented as function of their input bits.  Empiric studies have
#.  shown that S-boxes partially compute the same output for similar input.
#.  It is suspected that this may contain a back door which could allow the
#.  NSA to decrypt DES encrypted data.
#.  .PP
#.  Making encrypted data computed using crypt() publicly available has
#.  to be considered insecure for the given reasons.
#. type: Plain text
#: build/C/man3/crypt.3:169
msgid ""
"The B<crypt>()  function was not implemented, probably because of U.S.A. "
"export restrictions."
msgstr "B<crypt>()  関数が実装されていない。多分アメリカの輸出規制のために。"

#. type: Plain text
#: build/C/man3/crypt.3:174
msgid ""
"I</proc/sys/crypto/fips_enabled> has a nonzero value, and an attempt was "
"made to use a weak encryption type, such as DES."
msgstr ""

#. type: SH
#: build/C/man3/crypt.3:174 build/C/man3/daemon.3:91
#: build/C/man3/des_crypt.3:134 build/C/man3/encrypt.3:124
#: build/C/man3/euidaccess.3:73 build/C/man3/getlogin.3:140
#: build/C/man3/getusershell.3:93 build/C/man3/swab.3:72
#: build/C/man3/tcgetpgrp.3:109 build/C/man3/ualarm.3:92
#: build/C/man3/usleep.3:91
#, no-wrap
msgid "ATTRIBUTES"
msgstr "属性"

#. type: SS
#: build/C/man3/crypt.3:175 build/C/man3/daemon.3:92
#: build/C/man3/des_crypt.3:135 build/C/man3/encrypt.3:125
#: build/C/man3/euidaccess.3:74 build/C/man3/getlogin.3:141
#: build/C/man3/getusershell.3:94 build/C/man3/swab.3:73
#: build/C/man3/tcgetpgrp.3:110 build/C/man3/ualarm.3:93
#: build/C/man3/usleep.3:92
#, no-wrap
msgid "Multithreading (see pthreads(7))"
msgstr "マルチスレッディング (pthreads(7) 参照)"

#. type: Plain text
#: build/C/man3/crypt.3:179
msgid "The B<crypt>()  function is not thread-safe."
msgstr "B<crypt>() 関数はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/crypt.3:183
msgid "The B<crypt_r>()  function is thread-safe."
msgstr "B<crypt_r>() 関数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/crypt.3:188
msgid ""
"B<crypt>(): SVr4, 4.3BSD, POSIX.1-2001.  B<crypt_r>()  is a GNU extension."
msgstr ""
"B<crypt>(): SVr4, 4.3BSD, POSIX.1-2001.  B<crypt_r>()  は GNU 拡張である。"

#. type: SS
#: build/C/man3/crypt.3:189 build/C/man2/gethostname.2:140
#, no-wrap
msgid "Glibc notes"
msgstr "glibc での注意"

#. type: Plain text
#: build/C/man3/crypt.3:192
msgid ""
"The glibc2 version of this function supports additional encryption "
"algorithms."
msgstr "この関数の glibc2 版は追加の暗号化アルゴリズムに対応している。"

#. type: Plain text
#: build/C/man3/crypt.3:197
msgid ""
"If I<salt> is a character string starting with the characters \"$I<id>$\" "
"followed by a string terminated by \"$\":"
msgstr ""
"もし I<salt> の文字列が \"$I<id>$\" で始まっていて、\"$\" で終わっている文字"
"列が 続いている場合:"

#. type: Plain text
#: build/C/man3/crypt.3:200
msgid "$I<id>$I<salt>$I<encrypted>"
msgstr "$I<id>$I<salt>$I<encrypted>"

#. type: Plain text
#: build/C/man3/crypt.3:209
msgid ""
"then instead of using the DES machine, I<id> identifies the encryption "
"method used and this then determines how the rest of the password string is "
"interpreted.  The following values of I<id> are supported:"
msgstr ""
"DES を使う代わりに、 I<id> で使用する暗号化手法を識別し、これがパスワード文字"
"列の残りの部分を解釈する 方法を決定する。 I<id> の値として、以下の値に対応し"
"ている:"

#. type: tbl table
#: build/C/man3/crypt.3:212
#, no-wrap
msgid "ID  | Method\n"
msgstr "ID  | Method\n"

#. type: tbl table
#: build/C/man3/crypt.3:213 build/C/man2/syscall.2:158
#: build/C/man2/syscall.2:183
#, no-wrap
msgid "_\n"
msgstr "_\n"

#. type: tbl table
#: build/C/man3/crypt.3:214
#, no-wrap
msgid "1   | MD5\n"
msgstr "1   | MD5\n"

#. type: tbl table
#: build/C/man3/crypt.3:215
#, no-wrap
msgid "2a  | Blowfish (not in mainline glibc; added in some\n"
msgstr "2a  | Blowfish (本流の glibc には入っていない;\n"

#. type: tbl table
#: build/C/man3/crypt.3:216
#, no-wrap
msgid "    | Linux distributions)\n"
msgstr "    | いくつかの Linux ディストリビューションで追加されている)\n"

#.  openSUSE has Blowfish, but AFAICS, this option is not supported
#.  natively by glibc -- mtk, Jul 08
#.  md5 | Sun MD5
#.  glibc doesn't appear to natively support Sun MD5; I don't know
#.  if any distros add the support.
#. type: tbl table
#: build/C/man3/crypt.3:223
#, no-wrap
msgid "5   | SHA-256 (since glibc 2.7)\n"
msgstr "5   | SHA-256 (glibc 2.7 以降)\n"

#. type: tbl table
#: build/C/man3/crypt.3:224
#, no-wrap
msgid "6   | SHA-512 (since glibc 2.7)\n"
msgstr "6   | SHA-512 (glibc 2.7 以降)\n"

#. type: Plain text
#: build/C/man3/crypt.3:231
msgid ""
"So $5$I<salt>$I<encrypted> is an SHA-256 encoded password and $6$I<salt>"
"$I<encrypted> is an SHA-512 encoded one."
msgstr ""
"従って、$5$I<salt>$I<encrypted> は SHA-256 でエンコードされた パスワードであ"
"り、$6$I<salt>$I<encrypted> は SHA-512 で エンコードされたパスワードである。"

#. type: Plain text
#: build/C/man3/crypt.3:236
msgid ""
"\"I<salt>\" stands for the up to 16 characters following \"$I<id>$\" in the "
"salt.  The encrypted part of the password string is the actual computed "
"password.  The size of this string is fixed:"
msgstr ""
"\"I<salt>\" は salt における \"$I<id>$\" に引き続く 16 文字以下の 文字列であ"
"る。 パスワード文字列の暗号化部分は実際に計算されたパスワードである。 この文"
"字列のサイズは固定である:"

#. type: tbl table
#: build/C/man3/crypt.3:238
#, no-wrap
msgid "MD5     | 22 characters\n"
msgstr "MD5     | 22 characters\n"

#. type: tbl table
#: build/C/man3/crypt.3:239
#, no-wrap
msgid "SHA-256 | 43 characters\n"
msgstr "SHA-256 | 43 characters\n"

#. type: tbl table
#: build/C/man3/crypt.3:240
#, no-wrap
msgid "SHA-512 | 86 characters\n"
msgstr "SHA-512 | 86 characters\n"

#. type: Plain text
#: build/C/man3/crypt.3:249
msgid ""
"The characters in \"I<salt>\" and \"I<encrypted>\" are drawn from the set "
"[B<a>\\(enB<zA>\\(enB<Z0>\\(enB<9./>].  In the MD5 and SHA implementations "
"the entire I<key> is significant (instead of only the first 8 bytes in DES)."
msgstr ""
"\"I<salt>\" と \"I<encrypted>\" の文字は [B<a>\\(enB<zA>\\(enB<Z0>\\(enB<9./"
">] の集合から 選ばれる。 MD5 と SHA の実装では、 I<key> 全体が意味がある "
"(DES の場合には最初の 8 文字だけに意味がある)。"

#. type: Plain text
#: build/C/man3/crypt.3:255
msgid "B<login>(1), B<passwd>(1), B<encrypt>(3), B<getpass>(3), B<passwd>(5)"
msgstr "B<login>(1), B<passwd>(1), B<encrypt>(3), B<getpass>(3), B<passwd>(5)"

#. type: TH
#: build/C/man3/daemon.3:36
#, no-wrap
msgid "DAEMON"
msgstr "DAEMON"

#. type: TH
#: build/C/man3/daemon.3:36
#, no-wrap
msgid "2013-10-28"
msgstr "2013-10-28"

#. type: Plain text
#: build/C/man3/daemon.3:39
msgid "daemon - run in the background"
msgstr "daemon - バックグラウンドで動作させる"

#. type: Plain text
#: build/C/man3/daemon.3:43
msgid "B<int daemon(int >I<nochdir>B<, int >I<noclose>B<);>"
msgstr "B<int daemon(int >I<nochdir>B<, int >I<noclose>B<);>"

#. type: Plain text
#: build/C/man3/daemon.3:51
msgid ""
"B<daemon>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<daemon>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: build/C/man3/daemon.3:56
msgid ""
"The B<daemon>()  function is for programs wishing to detach themselves from "
"the controlling terminal and run in the background as system daemons."
msgstr ""
"B<daemon>()  は、制御端末から分離させてシステムデーモンとして動作させたい プ"
"ログラムのための関数である。"

#. type: Plain text
#: build/C/man3/daemon.3:64
msgid ""
"If I<nochdir> is zero, B<daemon>()  changes the calling process's current "
"working directory to the root directory (\"/\"); otherwise, the current "
"working directory is left unchanged."
msgstr ""
"I<nochdir> が 0 の場合、 B<daemon>()  は呼び出したプロセスの現在の作業ディレ"
"クトリ (current working directory)  をルートディレクトリ (\"/\") に変更す"
"る。 それ以外の場合、現在の作業ディレクトリは変更されない。"

#. type: Plain text
#: build/C/man3/daemon.3:73
msgid ""
"If I<noclose> is zero, B<daemon>()  redirects standard input, standard "
"output and standard error to I</dev/null>; otherwise, no changes are made to "
"these file descriptors."
msgstr ""
"I<noclose> が 0 の場合、 B<daemon>()  は標準入力・標準出力・標準エラーを I</"
"dev/null> にリダイレクトする。 それ以外の場合、これらのファイルディスクリプタ"
"は変更されない。"

#.  not .IR in order not to underline _
#. type: Plain text
#: build/C/man3/daemon.3:91
msgid ""
"(This function forks, and if the B<fork>(2)  succeeds, the parent calls "
"B<_exit>(2), so that further errors are seen by the child only.)  On success "
"B<daemon>()  returns zero.  If an error occurs, B<daemon>()  returns -1 and "
"sets I<errno> to any of the errors specified for the B<fork>(2)  and "
"B<setsid>(2)."
msgstr ""
"(この関数が fork して B<fork>(2)  が成功すると、親プロセスでは B<_exit>(2)  "
"を呼び出すので、これ以降のエラーは子プロセスからしか見れない)。 成功した場"
"合、 B<daemon>()  は 0 を返す。 エラーが起こった場合、 B<daemon>()  は -1 を"
"返す。 さらに、 I<errno> に B<fork>(2)  と B<setsid>(2)  に関して規定されたエ"
"ラーを設定する。"

#. type: Plain text
#: build/C/man3/daemon.3:96
msgid "The B<daemon>()  function is thread-safe."
msgstr "B<daemon>() 関数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/daemon.3:102
msgid ""
"Not in POSIX.1-2001.  A similar function appears on the BSDs.  The B<daemon>"
"()  function first appeared in 4.4BSD."
msgstr ""
"POSIX.1-2001 にはない。 同様の関数が BSD には見られる。 B<daemon>()  関数は "
"4.4BSD で始めて登場した。"

#. type: Plain text
#: build/C/man3/daemon.3:110
msgid ""
"The glibc implementation can also return -1 when I</dev/null> exists but is "
"not a character device with the expected major and minor numbers.  In this "
"case I<errno> need not be set."
msgstr ""
"I</dev/null> は存在するが、想定するメジャー番号とマイナー番号の キャラクタデ"
"バイスでなかった場合、 glibc の実装でも -1 が返される。 この場合、 I<errno> "
"が設定される必要はない。"

#. type: Plain text
#: build/C/man3/daemon.3:113
msgid "B<fork>(2), B<setsid>(2)"
msgstr "B<fork>(2), B<setsid>(2)"

#. type: TH
#: build/C/man3/des_crypt.3:14
#, no-wrap
msgid "DES_CRYPT"
msgstr "DES_CRYPT"

#. type: TH
#: build/C/man3/des_crypt.3:14
#, no-wrap
msgid "2013-09-18"
msgstr "2013-09-18"

#. type: Plain text
#: build/C/man3/des_crypt.3:18
msgid ""
"des_crypt, ecb_crypt, cbc_crypt, des_setparity, DES_FAILED - fast DES "
"encryption"
msgstr ""
"des_crypt, ecb_crypt, cbc_crypt, des_setparity, DES_FAILED - 高速な DES 暗号"
"化"

#.  Sun version
#.  .B #include <des_crypt.h>
#. type: Plain text
#: build/C/man3/des_crypt.3:23
#, no-wrap
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"
msgstr "B<#include E<lt>rpc/des_crypt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:26
#, no-wrap
msgid ""
"B<int ecb_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<);>\n"
msgstr ""
"B<int ecb_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:29
#, no-wrap
msgid ""
"B<int cbc_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<, char *>I<ivec>B<);>\n"
msgstr ""
"B<int cbc_crypt(char *>I<key>B<, char *>I<data>B<, unsigned >I<datalen>B<,>\n"
"B<              unsigned >I<mode>B<, char *>I<ivec>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:31
#, no-wrap
msgid "B<void des_setparity(char *>I<key>B<);>\n"
msgstr "B<void des_setparity(char *>I<key>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:33
#, no-wrap
msgid "B<int DES_FAILED(int >I<status>B<);>\n"
msgstr "B<int DES_FAILED(int >I<status>B<);>\n"

#. type: Plain text
#: build/C/man3/des_crypt.3:63
msgid ""
"B<ecb_crypt>()  and B<cbc_crypt>()  implement the NBS DES (Data Encryption "
"Standard).  These routines are faster and more general purpose than B<crypt>"
"(3).  They also are able to utilize DES hardware if it is available.  "
"B<ecb_crypt>()  encrypts in ECB (Electronic Code Book)  mode, which encrypts "
"blocks of data independently.  B<cbc_crypt>()  encrypts in CBC (Cipher Block "
"Chaining)  mode, which chains together successive blocks.  CBC mode protects "
"against insertions, deletions and substitutions of blocks.  Also, "
"regularities in the clear text will not appear in the cipher text."
msgstr ""
"B<ecb_crypt>()  と B<cbc_crypt>()  は NBS DES (Data Encryption Standard, デー"
"タ暗号化規格) を実装している。 これらのルーチンは B<crypt>(3)  よりも高速でよ"
"り一般的な目的に使用できる。 利用可能であれば、これらのルーチンは DES ハード"
"ウェアを使用することもできる。 B<ecb_crypt>()  は ECB (Electronic Code Book) "
"モードで暗号化する。 このモードでは (個々の) データのブロックを独立して暗号化"
"する B<cbc_crypt>()  は CBC (Cipher Block Chaining) モードで暗号化する。 この"
"モードでは連続するブロックを互いに連鎖させて暗号化する。 CBC はブロックの挿"
"入・削除・置き換えから保護する。 また平文の規則性が暗号文に現れない。"

#. type: Plain text
#: build/C/man3/des_crypt.3:106
msgid ""
"Here is how to use these routines.  The first argument, I<key>, is the 8-"
"byte encryption key with parity.  To set the key's parity, which for DES is "
"in the low bit of each byte, use B<des_setparity>().  The second argument, "
"I<data>, contains the data to be encrypted or decrypted.  The third "
"argument, I<datalen>, is the length in bytes of I<data>, which must be a "
"multiple of 8.  The fourth argument, I<mode>, is formed by ORing together "
"some things.  For the encryption direction OR in either B<DES_ENCRYPT> or "
"B<DES_DECRYPT>.  For software versus hardware encryption, OR in either "
"B<DES_HW> or B<DES_SW>.  If B<DES_HW> is specified, and there is no "
"hardware, then the encryption is performed in software and the routine "
"returns B<DESERR_NOHWDEVICE>.  For B<cbc_crypt>(), the argument I<ivec> is "
"the 8-byte initialization vector for the chaining.  It is updated to the "
"next initialization vector upon return."
msgstr ""
"これらのルーチンの使用法を示す。 第 1 引き数 I<key> はパリティ付きの 8 バイト"
"の暗号化鍵である。 鍵のパリティを設定するには B<des_setparity>()  を使うこ"
"と。 DES の場合、鍵のパリティは各バイトの最下位ビットである。 第 2 引き数 "
"I<data> は暗号化または復号化されるデータを含む。 第 3 引き数 I<datalen> は "
"I<data> のバイト長であり、8 の倍数でなければならない。 第 4 引き数 I<mode> は"
"いくつかの値を OR することで作成する。 暗号化の方向 (訳註: 暗号化なのか復号化"
"なのか) を指定するため、 B<DES_ENCRYPT> または B<DES_DECRYPT> を OR する。 暗"
"号化をソフトウェアで行うかハードウェアで行うかを指定するため、 B<DES_HW> また"
"は B<DES_SW> を OR する。 B<DES_HW> が指定されていて、かつハードウェアがない"
"場合、 暗号化はソフトウェアで実行されて、ルーチンは B<DESERR_NOHWDEVICE> を返"
"す。 B<cbc_crypt>()  において、引き数 I<ivec> はデータブロックを連鎖させる際"
"の 8 バイトの初期化ベクトルである。 この引き数はルーチンから戻るときに次の初"
"期化ベクトルに更新される。"

#. type: TP
#: build/C/man3/des_crypt.3:108
#, no-wrap
msgid "B<DESERR_NONE>"
msgstr "B<DESERR_NONE>"

#. type: Plain text
#: build/C/man3/des_crypt.3:111
msgid "No error."
msgstr "エラーなし。"

#. type: TP
#: build/C/man3/des_crypt.3:111
#, no-wrap
msgid "B<DESERR_NOHWDEVICE>"
msgstr "B<DESERR_NOHWDEVICE>"

#. type: Plain text
#: build/C/man3/des_crypt.3:114
msgid ""
"Encryption succeeded, but done in software instead of the requested hardware."
msgstr ""
"暗号化は成功したが、要求されたハードウェアの代わりにソフトウェアで実行され"
"た。"

#. type: TP
#: build/C/man3/des_crypt.3:114
#, no-wrap
msgid "B<DESERR_HWERROR>"
msgstr "B<DESERR_HWERROR>"

#. type: Plain text
#: build/C/man3/des_crypt.3:117
msgid "An error occurred in the hardware or driver."
msgstr "ハードウェアまたはドライバでエラーが発生した。"

#. type: TP
#: build/C/man3/des_crypt.3:117
#, no-wrap
msgid "B<DESERR_BADPARAM>"
msgstr "B<DESERR_BADPARAM>"

#. type: Plain text
#: build/C/man3/des_crypt.3:120
msgid "Bad argument to routine."
msgstr "ルーチンへの引き数が不正である。"

#.  .BR DES_FAILED\c
#.  .BR ( stat )
#.  So far the Sun page
#.  Some additions - aeb
#. type: Plain text
#: build/C/man3/des_crypt.3:131
msgid ""
"Given a result status I<stat>, the macro B<DES_FAILED(>I<stat>B<)> is false "
"only for the first two statuses."
msgstr ""
"結果の状態 I<stat> を与えたとき、マクロ B<DES_FAILED(>I<stat>B<)> が false に"
"なるのは、最初の 2 つだけである。"

#. type: Plain text
#: build/C/man3/des_crypt.3:134
msgid ""
"These routines are present in libc 4.6.27 and later, and in glibc 2.1 and "
"later."
msgstr "これらのルーチンは libc 4.6.27 以降と glibc 2.1 以降に存在する。"

#. type: Plain text
#: build/C/man3/des_crypt.3:142
msgid ""
"The B<ecb_crypt>(), B<cbc_crypt>(), and B<des_setparity>()  functions are "
"thread-safe."
msgstr "関数 B<ecb_crypt>(), B<cbc_crypt>(), B<des_setparity>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/des_crypt.3:145
msgid "4.3BSD.  Not in POSIX.1-2001."
msgstr "4.3BSD. POSIX.1-2001 にはない。"

#. type: Plain text
#: build/C/man3/des_crypt.3:149
msgid "B<des>(1), B<crypt>(3), B<xcrypt>(3)"
msgstr "B<des>(1), B<crypt>(3), B<xcrypt>(3)"

#. type: TH
#: build/C/man2/dup.2:36
#, no-wrap
msgid "DUP"
msgstr "DUP"

#. type: TH
#: build/C/man2/dup.2:36
#, no-wrap
msgid "2012-02-14"
msgstr "2012-02-14"

#. type: Plain text
#: build/C/man2/dup.2:39
msgid "dup, dup2, dup3 - duplicate a file descriptor"
msgstr "dup, dup2, dup3 - ファイルディスクリプタを複製する"

#. type: Plain text
#: build/C/man2/dup.2:45
#, no-wrap
msgid ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"
msgstr ""
"B<int dup(int >I<oldfd>B<);>\n"
"B<int dup2(int >I<oldfd>B<, int >I<newfd>B<);>\n"

#. type: Plain text
#: build/C/man2/dup.2:49
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* Obtain O_* constant definitions */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>fcntl.hE<gt>>              /* 定数 O_* の定義の取得 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/dup.2:51
#, no-wrap
msgid "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"
msgstr "B<int dup3(int >I<oldfd>B<, int >I<newfd>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/dup.2:55
msgid "These system calls create a copy of the file descriptor I<oldfd>."
msgstr ""
"これらのシステムコールは、ファイルディスクリプタ I<oldfd> の複製を作る。"

#. type: Plain text
#: build/C/man2/dup.2:58
msgid ""
"B<dup>()  uses the lowest-numbered unused descriptor for the new descriptor."
msgstr ""
"B<dup>()  は最も小さい番号の未使用のディスクリプタを 新しいディスクリプタとし"
"て使用する。"

#. type: Plain text
#: build/C/man2/dup.2:62
msgid ""
"B<dup2>()  makes I<newfd> be the copy of I<oldfd>, closing I<newfd> first if "
"necessary, but note the following:"
msgstr ""
"B<dup2>()  は I<newfd> を I<oldfd> の複製として作成する。 必要であれば最初に "
"I<newfd> をクローズする。 以下の点に注意すること。"

#. type: Plain text
#: build/C/man2/dup.2:68
msgid ""
"If I<oldfd> is not a valid file descriptor, then the call fails, and "
"I<newfd> is not closed."
msgstr ""
"I<oldfd> が有効なファイルディスクリプタでない場合、その呼び出しは失敗し、 "
"I<newfd> はクローズされない。"

#. type: Plain text
#: build/C/man2/dup.2:79
msgid ""
"If I<oldfd> is a valid file descriptor, and I<newfd> has the same value as "
"I<oldfd>, then B<dup2>()  does nothing, and returns I<newfd>."
msgstr ""
"I<oldfd> が有効なファイルディスクリプタで、 I<newfd> が I<oldfd> と同じ値の場"
"合、 B<dup2>()  は何もせず、 I<newfd> を返す。"

#. type: Plain text
#: build/C/man2/dup.2:88
msgid ""
"After a successful return from one of these system calls, the old and new "
"file descriptors may be used interchangeably.  They refer to the same open "
"file description (see B<open>(2))  and thus share file offset and file "
"status flags; for example, if the file offset is modified by using B<lseek>"
"(2)  on one of the descriptors, the offset is also changed for the other."
msgstr ""
"これらのシステムコールのいずれかが成功を返した場合には、 古いファイルディスク"
"リプタと新しいファイルディスクリプタは 互いに可換なものとして使うことができ"
"る。 2つのファイルディスクリプタは同じファイル記述 (description)  (B<open>"
"(2)  参照) を参照しており、したがってファイルオフセットやファイル状態フラグ"
"が 共有される。例えば、一方のディスクリプタに対して B<lseek>(2)  を使ってファ"
"イルオフセットを変更した場合、もう一方のディスクリプタの オフセットも変化す"
"る。"

#. type: Plain text
#: build/C/man2/dup.2:96
msgid ""
"The two descriptors do not share file descriptor flags (the close-on-exec "
"flag).  The close-on-exec flag (B<FD_CLOEXEC>; see B<fcntl>(2))  for the "
"duplicate descriptor is off."
msgstr ""
"2つのディスクリプタはファイルディスクリプタフラグ (close-on-exec flag)  を共"
"有しない。複製されたディスクリプタの close-on-exec flag (B<fcntl>(2)  参照) "
"は off となる。"

#. type: Plain text
#: build/C/man2/dup.2:101
msgid "B<dup3>()  is the same as B<dup2>(), except that:"
msgstr "B<dup3>()  は B<dup2>()  と同じだが、以下の点が異なる。"

#. type: Plain text
#: build/C/man2/dup.2:110
msgid ""
"The caller can force the close-on-exec flag to be set for the new file "
"descriptor by specifying B<O_CLOEXEC> in I<flags>.  See the description of "
"the same flag in B<open>(2)  for reasons why this may be useful."
msgstr ""
"呼び出し元が、新しいファイルディスクリプタに対して close-on-exec フラグを強制"
"的に設定することができる。 これを行うには、 I<flags> に B<O_CLOEXEC> を指定す"
"る。 このフラグが役に立つ理由については、 B<open>(2)  の B<O_CLOEXEC> フラグ"
"の説明を参照のこと。"

#.  FIXME . To confirm with Al Viro that this was intended, and its rationale
#. type: Plain text
#: build/C/man2/dup.2:120
msgid ""
"If I<oldfd> equals I<newfd>, then B<dup3>()  fails with the error B<EINVAL>."
msgstr ""
"I<oldfd> が I<newfd> と同じ場合、 B<dup3>()  は B<EINVAL> エラーで失敗する。"

#. type: Plain text
#: build/C/man2/dup.2:126
msgid ""
"On success, these system calls return the new descriptor.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功すると、これらのシステムコールは新しいディスクリプタを返す。 エラーの場"
"合、-1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/dup.2:133
msgid ""
"I<oldfd> isn't an open file descriptor, or I<newfd> is out of the allowed "
"range for file descriptors."
msgstr ""
"I<oldfd> がオープンされたファイルディスクリプタでないか、 I<newfd> がファイル"
"ディスクリプタとして許される範囲から外れている。"

#. type: TP
#: build/C/man2/dup.2:133 build/C/man2/swapon.2:114
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man2/dup.2:143
msgid ""
"(Linux only) This may be returned by B<dup2>()  or B<dup3>()  during a race "
"condition with B<open>(2)  and B<dup>()."
msgstr ""
"(Linux のみ)  B<open>(2)  や B<dup>()  との競合状態の場合に、 B<dup2>()  や "
"B<dup3>()  はこのエラーを返すかもしれない。"

#. type: Plain text
#: build/C/man2/dup.2:151
msgid ""
"The B<dup2>()  or B<dup3>()  call was interrupted by a signal; see B<signal>"
"(7)."
msgstr ""
"B<dup2>()  や B<dup3>()  の呼び出しがシグナルにより割り込まれた。 B<signal>"
"(7)  参照。"

#.  FIXME . To confirm with Al Viro that this was intended, and its rationale
#. type: Plain text
#: build/C/man2/dup.2:161
msgid ""
"(B<dup3>())  I<flags> contain an invalid value.  Or, I<oldfd> was equal to "
"I<newfd>."
msgstr ""
"(B<dup3>())  I<flags> に無効な値が入っている。 もしくは、 I<oldfd> が "
"I<newfd> と同じであった。"

#. type: TP
#: build/C/man2/dup.2:161 build/C/man2/execve.2:414 build/C/man2/fcntl.2:1148
#: build/C/man3/getlogin.3:105
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/dup.2:165
msgid ""
"The process already has the maximum number of file descriptors open and "
"tried to open a new one."
msgstr ""
"プロセスがすでにオープンできる最大数までファイルディスクリプタ を開いていて、"
"さらに新しいものを開こうとした。"

#. type: Plain text
#: build/C/man2/dup.2:170
msgid ""
"B<dup3>()  was added to Linux in version 2.6.27; glibc support is available "
"starting with version 2.9."
msgstr ""
"B<dup3>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポートは"
"バージョン 2.9 以降で利用できる。"

#. type: Plain text
#: build/C/man2/dup.2:174
msgid "B<dup>(), B<dup2>(): SVr4, 4.3BSD, POSIX.1-2001."
msgstr "B<dup>(), B<dup2>(): SVr4, 4.3BSD, POSIX.1-2001."

#.  SVr4 documents additional
#.  EINTR and ENOLINK error conditions.  POSIX.1 adds EINTR.
#.  The EBUSY return is Linux-specific.
#. type: Plain text
#: build/C/man2/dup.2:180
msgid "B<dup3>()  is Linux-specific."
msgstr "B<dup3>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/dup.2:194
msgid ""
"The error returned by B<dup2>()  is different from that returned by B<fcntl"
"(>..., B<F_DUPFD>, ...B<)> when I<newfd> is out of range.  On some systems "
"B<dup2>()  also sometimes returns B<EINVAL> like B<F_DUPFD>."
msgstr ""
"I<newfd> が範囲を超えた時に返されるエラーは、 B<dup2>()  と B<fcntl(>..., "
"B<F_DUPFD>, ...B<)> では異っている。 B<dup2>()  が B<F_DUPFD> と同じように "
"B<EINVAL> を返すシステムもある。"

#. type: Plain text
#: build/C/man2/dup.2:207
msgid ""
"If I<newfd> was open, any errors that would have been reported at B<close>"
"(2)  time are lost.  A careful programmer will not use B<dup2>()  or B<dup3>"
"()  without closing I<newfd> first."
msgstr ""
"I<newfd> がオープンされていると、 B<close>(2)  した時に報告されるはずのエラー"
"が失われてしまう。 B<dup2>()  や B<dup3>()  を使う前に先ず I<newfd> をクロー"
"ズするようにした方がいいだろう。"

#. type: Plain text
#: build/C/man2/dup.2:211
msgid "B<close>(2), B<fcntl>(2), B<open>(2)"
msgstr "B<close>(2), B<fcntl>(2), B<open>(2)"

#. type: TH
#: build/C/man3/encrypt.3:30
#, no-wrap
msgid "ENCRYPT"
msgstr "ENCRYPT"

#. type: TH
#: build/C/man3/encrypt.3:30
#, no-wrap
msgid "2013-07-22"
msgstr "2013-07-22"

#. type: Plain text
#: build/C/man3/encrypt.3:33
msgid "encrypt, setkey, encrypt_r, setkey_r - encrypt 64-bit messages"
msgstr ""
"encrypt, setkey, encrypt_r, setkey_r - 64 ビットのメッセージを暗号化する"

#. type: Plain text
#: build/C/man3/encrypt.3:35 build/C/man3/encrypt.3:41
msgid "B<#define _XOPEN_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _XOPEN_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/encrypt.3:39
msgid "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>"
msgstr "B<void encrypt(char >I<block>B<[64], int >I<edflag>B<);>"

#. type: Plain text
#: build/C/man3/encrypt.3:43
msgid "B<#include E<lt>stdlib.hE<gt>>"
msgstr "B<#include E<lt>stdlib.hE<gt>>"

#. type: Plain text
#: build/C/man3/encrypt.3:45
msgid "B<void setkey(const char *>I<key>B<);>"
msgstr "B<void setkey(const char *>I<key>B<);>"

#. type: Plain text
#: build/C/man3/encrypt.3:47 build/C/man3/getumask.3:33
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/encrypt.3:49
msgid "B<#include E<lt>crypt.hE<gt>>"
msgstr "B<#include E<lt>crypt.hE<gt>>"

#. type: Plain text
#: build/C/man3/encrypt.3:51
msgid "B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>"
msgstr ""
"B<void setkey_r(const char *>I<key>B<, struct crypt_data *>I<data>B<);>"

#. type: Plain text
#: build/C/man3/encrypt.3:54
msgid ""
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data "
"*>I<data>B<);>"
msgstr ""
"B<void encrypt_r(char *>I<block>B<, int >I<edflag>B<, struct crypt_data "
"*>I<data>B<);>"

#. type: Plain text
#: build/C/man3/encrypt.3:56
msgid "Each of these requires linking with I<-lcrypt>."
msgstr "これらの関数は I<-lcrypt> でリンクする必要がある。"

#. type: Plain text
#: build/C/man3/encrypt.3:68
msgid ""
"These functions encrypt and decrypt 64-bit messages.  The B<setkey>()  "
"function sets the key used by B<encrypt>().  The I<key> argument used here "
"is an array of 64 bytes, each of which has numerical value 1 or 0.  The "
"bytes key[n] where n=8*i-1 are ignored, so that the effective key length is "
"56 bits."
msgstr ""
"これらの関数は、64 ビットのメッセージの暗号化と復号化を行う。 B<setkey>()  関"
"数は B<encrypt>()  によって使われる暗号鍵を設定する。 ここで使われる引き数 "
"I<key> は 64 バイトの配列であり、各バイトは数値 1 または 0 である。 n=8*i-1 "
"に対するバイト key[n] は無視されるので、 有効な暗号鍵の長さは 56 ビットにな"
"る。"

#. type: Plain text
#: build/C/man3/encrypt.3:80
msgid ""
"The B<encrypt>()  function modifies the passed buffer, encoding if I<edflag> "
"is 0, and decoding if 1 is being passed.  Like the I<key> argument, also "
"I<block> is a bit vector representation of the actual value that is "
"encoded.  The result is returned in that same vector."
msgstr ""
"B<encrypt>()  関数は、 I<edflag> が 0 の場合は暗号化し、1 が渡された場合は復"
"号化するというように、 渡されたバッファを変更する。 引き数 I<key> と同様に、 "
"I<block> はエンコードされた実際の値を表現するビットの配列である。 結果はこの"
"同じ配列を使って返される。"

#. type: Plain text
#: build/C/man3/encrypt.3:90
msgid ""
"These two functions are not reentrant, that is, the key data is kept in "
"static storage.  The functions B<setkey_r>()  and B<encrypt_r>()  are the "
"reentrant versions.  They use the following structure to hold the key data:"
msgstr ""
"これら 2 つの関数はリエントラント (reentrant) ではない。 つまり暗号鍵データは"
"静的な領域に保存される。 関数 B<setkey_r>()  と B<encrypt_r>()  はリエントラ"
"ントなバージョンである。 これらの関数は暗号鍵データを保持するために以下のよう"
"な構造体を使う。"

#. type: Plain text
#: build/C/man3/encrypt.3:105
#, no-wrap
msgid ""
"struct crypt_data {\n"
"    char     keysched[16 * 8];\n"
"    char     sb0[32768];\n"
"    char     sb1[32768];\n"
"    char     sb2[32768];\n"
"    char     sb3[32768];\n"
"    char     crypt_3_buf[14];\n"
"    char     current_salt[2];\n"
"    long int current_saltbits;\n"
"    int      direction;\n"
"    int      initialized;\n"
"};\n"
msgstr ""
"struct crypt_data {\n"
"    char     keysched[16 * 8];\n"
"    char     sb0[32768];\n"
"    char     sb1[32768];\n"
"    char     sb2[32768];\n"
"    char     sb3[32768];\n"
"    char     crypt_3_buf[14];\n"
"    char     current_salt[2];\n"
"    long int current_saltbits;\n"
"    int      direction;\n"
"    int      initialized;\n"
"};\n"

#. type: Plain text
#: build/C/man3/encrypt.3:113
msgid "Before calling B<setkey_r>()  set I<data-E<gt>initialized> to zero."
msgstr ""
"B<setkey_r>()  を呼び出す前には、 I<data-E<gt>initialized> を 0 に設定するこ"
"と。"

#. type: Plain text
#: build/C/man3/encrypt.3:115
msgid "These functions do not return any value."
msgstr "これらの関数は、なにも値を返さない。"

#. type: Plain text
#: build/C/man3/encrypt.3:120
msgid ""
"Set I<errno> to zero before calling the above functions.  On success, it is "
"unchanged."
msgstr ""
"上記の関数を呼び出す前に I<errno> を 0 に設定すること。 成功した場合、この値"
"は変更されない。"

#. type: Plain text
#: build/C/man3/encrypt.3:124
msgid ""
"The function is not provided.  (For example because of former USA export "
"restrictions.)"
msgstr ""
"(例えば以前のアメリカ合衆国輸出規制などにより)  この関数が提供されていない。"

#. type: Plain text
#: build/C/man3/encrypt.3:131
msgid "The B<encrypt>()  and B<setkey>()  functions are not thread-safe."
msgstr "関数 B<encrypt>() と B<setkey>() はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/encrypt.3:137
msgid "The B<encrypt_r>()  and B<setkey_r>()  functions are thread-safe."
msgstr "関数 B<encrypt_r>() と B<setkey_r>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/encrypt.3:148
msgid ""
"The functions B<encrypt>()  and B<setkey>()  conform to SVr4, SUSv2, and "
"POSIX.1-2001.  The functions B<encrypt_r>()  and B<setkey_r>()  are GNU "
"extensions."
msgstr ""
"関数 B<encrypt>()  と B<setkey>()  は SVr4, SUSv2, and POSIX.1-2001 に準拠す"
"る。 関数 B<encrypt_r>()  と B<setkey_r>()  は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/encrypt.3:150
msgid "In glibc 2.2 these functions use the DES algorithm."
msgstr "glibc 2.2 では、これらの関数は DES アルゴリズムを使う。"

#. type: Plain text
#: build/C/man3/encrypt.3:157
msgid ""
"You need to link with libcrypt to compile this example with glibc.  To do "
"useful work the I<key[]> and I<txt[]> arrays must be filled with a useful "
"bit pattern."
msgstr ""
"この例を glibc でコンパイルするには libcrypt とリンクする必要がある。 実際に"
"動作させるためには、配列 I<key[]> と I<txt[]> に有効なビットパターンを指定し"
"なければならない。"

#. type: Plain text
#: build/C/man3/encrypt.3:162
#, no-wrap
msgid ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#define _XOPEN_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/encrypt.3:168
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];      /* bit pattern for key */\n"
"    char txt[64];      /* bit pattern for messages */\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char key[64];      /* bit pattern for key */\n"
"    char txt[64];      /* bit pattern for messages */\n"

#. type: Plain text
#: build/C/man3/encrypt.3:173
#, no-wrap
msgid ""
"    setkey(key);\n"
"    encrypt(txt, 0);   /* encode */\n"
"    encrypt(txt, 1);   /* decode */\n"
"}\n"
msgstr ""
"    setkey(key);\n"
"    encrypt(txt, 0);   /* encode */\n"
"    encrypt(txt, 1);   /* decode */\n"
"}\n"

#.  .BR fcrypt (3)
#. type: Plain text
#: build/C/man3/encrypt.3:179
msgid "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3),"
msgstr "B<cbc_crypt>(3), B<crypt>(3), B<ecb_crypt>(3)"

#. type: TH
#: build/C/man7/environ.7:34
#, no-wrap
msgid "ENVIRON"
msgstr "ENVIRON"

#. type: TH
#: build/C/man7/environ.7:34
#, no-wrap
msgid "2014-01-18"
msgstr "2014-01-18"

#. type: Plain text
#: build/C/man7/environ.7:37
msgid "environ - user environment"
msgstr "environ - ユーザ環境"

#. type: Plain text
#: build/C/man7/environ.7:40
#, no-wrap
msgid "B<extern char **>I<environ>B<;>\n"
msgstr "B<extern char **>I<environ>B<;>\n"

#. type: Plain text
#: build/C/man7/environ.7:57
msgid ""
"The variable I<environ> points to an array of pointers to strings called the "
"\"environment\".  The last pointer in this array has the value NULL.  (This "
"variable must be declared in the user program, but is declared in the header "
"file I<E<lt>unistd.hE<gt>> in case the header files came from libc4 or "
"libc5, and in case they came from glibc and B<_GNU_SOURCE> was defined.)  "
"This array of strings is made available to the process by the B<exec>(3)  "
"call that started the process."
msgstr ""
"変数 I<environ> は「環境 (environment)」と呼ばれる文字列へのポインタの配列で"
"ある。 この配列の最後のポインタの値は NULL である。 (この変数はユーザープログ"
"ラムで宣言しなければならない。 ただし libc4 や libc5 のヘッダーファイルなら "
"I<E<lt>unistd.hE<gt>> で宣言されているし、これが glibc 由来のものでも "
"B<_GNU_SOURCE> が define されていれば宣言済みとなる)。 この文字列配列は、 プ"
"ロセスを起動する B<exec>(3)  によって、その起動されたプロセスで利用できるよう"
"になる。"

#. type: Plain text
#: build/C/man7/environ.7:62
msgid ""
"By convention the strings in I<environ> have the form \"I<name>B<=>I<value>"
"\".  Common examples are:"
msgstr ""
"通例では、 I<environ> の文字列は \"I<name>B<=>I<value>\" という書式をとる。 "
"よく用いられる例を以下に示す。"

#. type: TP
#: build/C/man7/environ.7:62
#, no-wrap
msgid "B<USER>"
msgstr "B<USER>"

#. type: Plain text
#: build/C/man7/environ.7:65
msgid "The name of the logged-in user (used by some BSD-derived programs)."
msgstr "ユーザのログイン名 (BSD 起源のプログラムなどによって使用される)。"

#. type: TP
#: build/C/man7/environ.7:65
#, no-wrap
msgid "B<LOGNAME>"
msgstr "B<LOGNAME>"

#. type: Plain text
#: build/C/man7/environ.7:68
msgid ""
"The name of the logged-in user (used by some System-V derived programs)."
msgstr "ユーザのログイン名(System V 起源のプログラムなどによって使用される)。"

#. type: TP
#: build/C/man7/environ.7:68
#, no-wrap
msgid "B<HOME>"
msgstr "B<HOME>"

#. type: Plain text
#: build/C/man7/environ.7:74
msgid ""
"A user's login directory, set by B<login>(1)  from the password file "
"B<passwd>(5)."
msgstr ""
"ユーザのログインディレクトリ。 B<login>(1)  がパスワードファイル B<passwd>"
"(5)  から取得して設定する。"

#. type: TP
#: build/C/man7/environ.7:74
#, no-wrap
msgid "B<LANG>"
msgstr "B<LANG>"

#. type: Plain text
#: build/C/man7/environ.7:92
#, fuzzy
#| msgid ""
#| "The name of a locale to use for locale categories when not overridden by "
#| "B<LC_ALL> or more specific environment variables like B<LC_COLLATE>, "
#| "B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC>, B<LC_TIME>, "
#| "cf.  B<locale>(5)."
msgid ""
"The name of a locale to use for locale categories when not overridden by "
"B<LC_ALL> or more specific environment variables such as B<LC_COLLATE>, "
"B<LC_CTYPE>, B<LC_MESSAGES>, B<LC_MONETARY>, B<LC_NUMERIC>, and B<LC_TIME> "
"(see B<locale>(7)  for further details of the B<LC_*> environment variables)."
msgstr ""
"ロケールの各カテゴリで使用されるロケールの名前。B<LC_ALL> や、 より狭い範囲を"
"対象とする環境変数 (B<LC_COLLATE>, B<LC_CTYPE>, B<LC_MESSAGES>, "
"B<LC_MONETARY>, B<LC_NUMERIC>, B<LC_TIME> など)  によって上書きされることもあ"
"る。 B<locale>(5)  を見よ。"

#. type: TP
#: build/C/man7/environ.7:92
#, no-wrap
msgid "B<PATH>"
msgstr "B<PATH>"

#. type: Plain text
#: build/C/man7/environ.7:107
msgid ""
"The sequence of directory prefixes that B<sh>(1)  and many other programs "
"apply in searching for a file known by an incomplete pathname.  The prefixes "
"are separated by \\(aqB<:>\\(aq.  (Similarly one has B<CDPATH> used by some "
"shells to find the target of a change directory command, B<MANPATH> used by "
"B<man>(1)  to find manual pages, and so on)"
msgstr ""
"B<sh>(1)  や他のプログラムが、フルパスで与えられなかった実行ファイルを検索す"
"るとき、 ファイル名に前置されるディレクトリの配列。 各ディレクトリは \\(aqB<:"
">\\(aq によって区切られる。 (同じようなものに、 シェルがディレクトリ変更コマ"
"ンドの変更先を探すために用いる B<CDPATH> や、 B<man>(1)  がマニュアルページの"
"検索に用いる B<MANPATH> などがある。)"

#. type: TP
#: build/C/man7/environ.7:107
#, no-wrap
msgid "B<PWD>"
msgstr "B<PWD>"

#. type: Plain text
#: build/C/man7/environ.7:111
msgid "The current working directory.  Set by some shells."
msgstr "現在のワーキングディレクトリ。いくつかのシェルが設定する。"

#. type: TP
#: build/C/man7/environ.7:111
#, no-wrap
msgid "B<SHELL>"
msgstr "B<SHELL>"

#. type: Plain text
#: build/C/man7/environ.7:114
msgid "The pathname of the user's login shell."
msgstr "ユーザーのログインシェルのパス名。"

#. type: TP
#: build/C/man7/environ.7:114
#, no-wrap
msgid "B<TERM>"
msgstr "B<TERM>"

#. type: Plain text
#: build/C/man7/environ.7:117
msgid "The terminal type for which output is to be prepared."
msgstr "端末の種類。出力はこれにあわせて用意される。"

#. type: TP
#: build/C/man7/environ.7:117
#, no-wrap
msgid "B<PAGER>"
msgstr "B<PAGER>"

#. type: Plain text
#: build/C/man7/environ.7:120
msgid "The user's preferred utility to display text files."
msgstr ""
"テキストファイルを表示するユーテリティ。ユーザーが好みのものを設定する。"

#. type: TP
#: build/C/man7/environ.7:120
#, no-wrap
msgid "B<EDITOR>/B<VISUAL>"
msgstr "B<EDITOR>/B<VISUAL>"

#.  .TP
#.  .B BROWSER
#.  The user's preferred utility to browse URLs. Sequence of colon-separated
#.  browser commands. See http://www.catb.org/~esr/BROWSER/ .
#. type: Plain text
#: build/C/man7/environ.7:127
msgid "The user's preferred utility to edit text files."
msgstr ""
"テキストファイルを編集するユーテリティ。ユーザーが好みのものを設定する。"

#. type: Plain text
#: build/C/man7/environ.7:145
msgid ""
"Further names may be placed in the environment by the I<export> command and "
"\"name=value\" in B<sh>(1), or by the I<setenv> command if you use B<csh>"
"(1).  Arguments may also be placed in the environment at the point of an "
"B<exec>(3).  A C program can manipulate its environment using the functions "
"B<getenv>(3), B<putenv>(3), B<setenv>(3), and B<unsetenv>(3)."
msgstr ""
"環境に名前を追加する場合には、 B<sh>(1)  では I<export> コマンドと "
"\"name=value\" を使用する。 B<csh>(1)  では I<setenv> コマンドを使用する。 "
"B<exec>(3)  の引数としても環境を設定することができる。 C プログラムからは、 "
"B<getenv>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3)  などの関数を用いて"
"環境を扱うことができる。"

#. type: Plain text
#: build/C/man7/environ.7:149
msgid ""
"Note that the behavior of many programs and library routines is influenced "
"by the presence or value of certain environment variables.  A random "
"collection:"
msgstr ""
"プログラムやライブラリルーチンの多くは、それぞれ適当な環境変数の存在 や値に"
"よって、動作に影響を受けることがある。以下、適宜挙げてみよう。"

#. type: Plain text
#: build/C/man7/environ.7:158
msgid ""
"The variables B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, "
"B<LC_MESSAGES>, and so on influence locale handling; see B<catopen>(3), "
"B<gettext>(3), and B<locale>(7)."
msgstr "B<LANG>, B<LANGUAGE>, B<NLSPATH>, B<LOCPATH>, B<LC_ALL>, B<LC_MESSAGES>, などの変数は、ロケールの扱いに影響する。 B<catopen>(3), B<gettext>(3), B<locale>(5) を参照。"

#. type: Plain text
#: build/C/man7/environ.7:165
msgid ""
"B<TMPDIR> influences the path prefix of names created by B<tmpnam>(3)  and "
"other routines, and the temporary directory used by B<sort>(1)  and other "
"programs."
msgstr "B<TMPDIR> は、 B<tmpnam>(3) などのルーチンによって作成されるファイル名や B<sort>(1) や他のプログラムが使用する一時ディレクトリに前置されるパスに影響する。"

#. type: Plain text
#: build/C/man7/environ.7:169
msgid ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD> and other LD_* variables influence the "
"behavior of the dynamic loader/linker."
msgstr ""
"B<LD_LIBRARY_PATH>, B<LD_PRELOAD> などの LD_* 変数はダイナミックローダ・リン"
"カの動作に影響する。"

#. type: Plain text
#: build/C/man7/environ.7:173
msgid ""
"B<POSIXLY_CORRECT> makes certain programs and library routines follow the "
"prescriptions of POSIX."
msgstr ""
"B<POSIXLY_CORRECT> が指定されると、ある種のプログラムやライブラリルーチンは "
"POSIX の規定に従うようになる。"

#. type: Plain text
#: build/C/man7/environ.7:179
msgid "The behavior of B<malloc>(3)  is influenced by B<MALLOC_*> variables."
msgstr "B<malloc>(3)  の動作は B<MALLOC_*> 変数によって影響される。"

#. type: Plain text
#: build/C/man7/environ.7:185
msgid ""
"The variable B<HOSTALIASES> gives the name of a file containing aliases to "
"be used with B<gethostbyname>(3)."
msgstr ""
"B<HOSTALIAS> 変数は、 B<gethostbyname>(3)  が用いるエイリアスが書かれている"
"ファイル名を与える。"

#. type: Plain text
#: build/C/man7/environ.7:196
msgid ""
"B<TZ> and B<TZDIR> give timezone information used by B<tzset>(3)  and "
"through that by functions like B<ctime>(3), B<localtime>(3), B<mktime>(3), "
"B<strftime>(3).  See also B<tzselect>(8)."
msgstr ""
"B<TZ> と B<TZDIR> は B<tzset>(3)  および、この関数を使う B<ctime>(3), "
"B<localtime>(3), B<mktime>(3), B<strftime>(3)  といった関数で用いられるタイム"
"ゾーンの情報を与える。 B<tzselect>(8)  も参照のこと。"

#. type: Plain text
#: build/C/man7/environ.7:200
msgid ""
"B<TERMCAP> gives information on how to address a given terminal (or gives "
"the name of a file containing such information)."
msgstr ""
"B<TERMCAP> は、現在の端末情報の取得先 (あるいはそのような情報が書かれている"
"ファイル名) を与える。"

#. type: Plain text
#: build/C/man7/environ.7:203
msgid ""
"B<COLUMNS> and B<LINES> tell applications about the window size, possibly "
"overriding the actual size."
msgstr ""
"B<COLUMNS> と B<LINES> アプリケーションにウインドウのサイズを伝える。 実際の"
"サイズとは違う値を与えることもできる。"

#. type: Plain text
#: build/C/man7/environ.7:208
msgid ""
"B<PRINTER> or B<LPDEST> may specify the desired printer to use.  See B<lpr>"
"(1)."
msgstr ""
"B<PRINTER> または B<LPDEST> 用いたいプリンタを指定する。 B<lpr>(1)  を参照の"
"こと。"

#. type: Plain text
#: build/C/man7/environ.7:210
msgid "Etc."
msgstr "などなど..."

#. type: Plain text
#: build/C/man7/environ.7:215
msgid ""
"Clearly there is a security risk here.  Many a system command has been "
"tricked into mischief by a user who specified unusual values for B<IFS> or "
"B<LD_LIBRARY_PATH>."
msgstr ""
"これらの中には、明らかにセキュリティ上の危険が存在する。 ユーザーが B<IFS> "
"や B<LD_LIBRARY_PATH> に異常な値を与えたことによって、 これまで多くのシステム"
"コマンドがだまされて、 システムをひどい目にあわせてきた。"

#. type: Plain text
#: build/C/man7/environ.7:248
msgid ""
"There is also the risk of name space pollution.  Programs like I<make> and "
"I<autoconf> allow overriding of default utility names from the environment "
"with similarly named variables in all caps.  Thus one uses B<CC> to select "
"the desired C compiler (and similarly B<MAKE>, B<AR>, B<AS>, B<FC>, B<LD>, "
"B<LEX>, B<RM>, B<YACC>, etc.).  However, in some traditional uses such an "
"environment variable gives options for the program instead of a pathname.  "
"Thus, one has B<MORE>, B<LESS>, and B<GZIP>.  Such usage is considered "
"mistaken, and to be avoided in new programs.  The authors of I<gzip> should "
"consider renaming their option to B<GZIP_OPT>."
msgstr ""
"名前空間が汚染される危険性も存在する。 I<make> や I<autoconf> のようなプログ"
"ラムでは、デフォルトのユーティリティを 環境にある似たような名前の変数で上書き"
"することができる (通常はすべて大文字の変数を用いる)。 すなわち、利用したい C "
"コンパイラは B<CC> で選択できる。また同様に B<MAKE>, B<AR>, B<AS>, B<FC>, "
"B<LD>, B<LEX>, B<RM>, B<YACC> なども用いることができる。 ところが一方では、こ"
"のような変数を (パス名ではなく)  プログラムに対するオプションとして扱うような"
"流儀も存在してきた。 例えば B<MORE>, B<LESS>, B<GZIP> などがそうである。 この"
"ような利用法は間違っていると考えるべきで、 新しいプログラムでは避けるべきであ"
"る。 I<gzip> の作者たちは、オプションを与える環境変数を B<GZIP_OPT> に改名す"
"ることを考えるほうがよい。"

#. type: Plain text
#: build/C/man7/environ.7:262
msgid ""
"B<bash>(1), B<csh>(1), B<login>(1), B<sh>(1), B<tcsh>(1), B<execve>(2), "
"B<clearenv>(3), B<exec>(3), B<getenv>(3), B<putenv>(3), B<setenv>(3), "
"B<unsetenv>(3), B<locale>(7)"
msgstr "B<bash>(1), B<csh>(1), B<login>(1), B<sh>(1), B<tcsh>(1), B<execve>(2), B<clearenv>(3), B<exec>(3), B<getenv>(3), B<putenv>(3), B<setenv>(3), B<unsetenv>(3), B<locale>(7)"

#. type: TH
#: build/C/man3/euidaccess.3:25
#, no-wrap
msgid "EUIDACCESS"
msgstr "EUIDACCESS"

#. type: TH
#: build/C/man3/euidaccess.3:25
#, no-wrap
msgid "2013-09-25"
msgstr "2013-09-25"

#. type: Plain text
#: build/C/man3/euidaccess.3:28
msgid "euidaccess, eaccess - check effective user's permissions for a file"
msgstr "euidaccess, eaccess - ファイルへのアクセス権を実効ユーザでチェックする"

#. type: Plain text
#: build/C/man3/euidaccess.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/euidaccess.3:35
#, no-wrap
msgid ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
msgstr ""
"B<int euidaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"
"B<int eaccess(const char *>I<pathname>B<, int >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man3/euidaccess.3:47
msgid ""
"Like B<access>(2), B<euidaccess>()  checks permissions and existence of the "
"file identified by its argument I<pathname>.  However, whereas B<access>(2), "
"performs checks using the real user and group identifiers of the process, "
"B<euidaccess>()  uses the effective identifiers."
msgstr ""
"B<access>(2)  と同様、 B<euidaccess>()  は引き数 I<pathname> で指定されたファ"
"イルの許可 (permission) と存在のチェックを行う。 B<access>(2)  はプロセスの"
"実 (real) ユーザID / 実グループID を用いてチェックを行うのに対し、 "
"B<euidaccess>()  は実効 (effective) ID を用いる。"

#. type: Plain text
#: build/C/man3/euidaccess.3:53
msgid ""
"I<mode> is a mask consisting of one or more of B<R_OK>, B<W_OK>, B<X_OK>, "
"and B<F_OK>, with the same meanings as for B<access>(2)."
msgstr ""
"I<mode> は B<R_OK>, B<W_OK>, B<X_OK>, B<F_OK> の一つ以上から構成されるマスク"
"である。 B<R_OK>, B<W_OK>, B<X_OK>, B<F_OK> は B<access>(2)  と同じ意味を持"
"つ。"

#. type: Plain text
#: build/C/man3/euidaccess.3:58
msgid ""
"B<eaccess>()  is a synonym for B<euidaccess>(), provided for compatibility "
"with some other systems."
msgstr ""
"B<eaccess>()  は B<euidaccess>()  の同義語であり、他のいくつかのシステムとの"
"互換性のために提供されている。"

#. type: Plain text
#: build/C/man3/euidaccess.3:66
msgid ""
"On success (all requested permissions granted), zero is returned.  On error "
"(at least one bit in I<mode> asked for a permission that is denied, or some "
"other error occurred), -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 (要求した全てについて許可が得られたら)、ゼロが返される。 エラー"
"の場合 (I<mode> の少なくとも一つのビットで要求した許可がなかった場合や、 他の"
"エラーが起こった場合)、-1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/euidaccess.3:69
msgid "As for B<access>(2)."
msgstr "B<access>(2)  と同じ。"

#. type: Plain text
#: build/C/man3/euidaccess.3:73
msgid "The B<eaccess>()  function was added to glibc in version 2.4."
msgstr "B<eaccess>()  関数は glibc のバージョン 2.4 で追加された。"

#. type: Plain text
#: build/C/man3/euidaccess.3:80
msgid "The B<euidaccess>()  and B<eaccess>()  functions are thread-safe."
msgstr "関数 B<euidaccess>() と B<eaccess>() はスレッドセーフである。"

#.  e.g., FreeBSD 6.1.
#. type: Plain text
#: build/C/man3/euidaccess.3:86
msgid ""
"These functions are nonstandard.  Some other systems have an B<eaccess>()  "
"function."
msgstr ""
"これらの関数は非標準である。 他のいくつかのシステムには B<eaccess>()  関数が"
"ある。"

#. type: Plain text
#: build/C/man3/euidaccess.3:93
msgid ""
"I<Warning>: Using this function to check a process's permissions on a file "
"before performing some operation based on that information leads to race "
"conditions: the file permissions may change between the two steps.  "
"Generally, it is safer just to attempt the desired operation and handle any "
"permission error that occurs."
msgstr ""
"I<警告>: \n"
"ある操作を実行する前にこの関数を使ってファイルに対するプロセスのアクセス許可"
"を\n"
"確認してから、その情報に基づいて操作を行うと、競合条件が発生する可能性があ"
"る。\n"
"これは二つの操作の間でファイルのアクセス許可が変化する場合があるからであ"
"る。\n"
"一般的には、必要な操作のみを行い、その際に発生したアクセス許可に関するエラー"
"を\n"
"処理する方が安全である。"

#. type: Plain text
#: build/C/man3/euidaccess.3:101
msgid ""
"This function always dereferences symbolic links.  If you need to check the "
"permissions on a symbolic link, use B<faccessat>(2)  with the flags "
"B<AT_EACCESS> and B<AT_SYMLINK_NOFOLLOW>."
msgstr ""
"この関数は常にシンボリックリンクの展開を行う。\n"
"シンボリックリンクのアクセス許可を確認する必要がある場合は、\n"
"フラグ B<AT_EACCESS> と B<AT_SYMLINK_NOFOLLOW> を付けて\n"
"B<faccessat>(2) を使うこと。"

#. type: Plain text
#: build/C/man3/euidaccess.3:112
msgid ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), B<path_resolution>"
"(7)"
msgstr ""
"B<access>(2), B<chmod>(2), B<chown>(2), B<faccessat>(2), B<open>(2), "
"B<setgid>(2), B<setuid>(2), B<stat>(2), B<credentials>(7), B<path_resolution>"
"(7)"

#. type: TH
#: build/C/man3/exec.3:41
#, no-wrap
msgid "EXEC"
msgstr "EXEC"

#. type: TH
#: build/C/man3/exec.3:41
#, no-wrap
msgid "2010-09-25"
msgstr "2010-09-25"

#. type: Plain text
#: build/C/man3/exec.3:44
msgid "execl, execlp, execle, execv, execvp, execvpe - execute a file"
msgstr "execl, execlp, execle, execv, execvp, execvpe - ファイルを実行する"

#. type: Plain text
#: build/C/man3/exec.3:48
msgid "B<extern char **environ;>"
msgstr "B<extern char **environ;>"

#. type: Plain text
#: build/C/man3/exec.3:50
msgid "B<int execl(const char *>I<path>B<, const char *>I<arg>B<, ...);>"
msgstr "B<int execl(const char *>I<path>B<, const char *>I<arg>B<, ...);>"

#. type: Plain text
#: build/C/man3/exec.3:52
msgid "B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...);>"
msgstr "B<int execlp(const char *>I<file>B<, const char *>I<arg>B<, ...);>"

#. type: Plain text
#: build/C/man3/exec.3:54
msgid "B<int execle(const char *>I<path>B<, const char *>I<arg>B<,>"
msgstr "B<int execle(const char *>I<path>B<, const char *>I<arg>B<,>"

#. type: Plain text
#: build/C/man3/exec.3:56
msgid "B< ..., char * const >I<envp>B<[]);>"
msgstr "B< ..., char * const >I<envp>B<[]);>"

#. type: Plain text
#: build/C/man3/exec.3:58
msgid "B<int execv(const char *>I<path>B<, char *const >I<argv>B<[]);>"
msgstr "B<int execv(const char *>I<path>B<, char *const >I<argv>B<[]);>"

#. type: Plain text
#: build/C/man3/exec.3:60
msgid "B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>"
msgstr "B<int execvp(const char *>I<file>B<, char *const >I<argv>B<[]);>"

#. type: Plain text
#: build/C/man3/exec.3:62
msgid "B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>"
msgstr "B<int execvpe(const char *>I<file>B<, char *const >I<argv>B<[],>"

#. type: Plain text
#: build/C/man3/exec.3:64 build/C/man2/execve.2:46
msgid "B< char *const >I<envp>B<[]);>"
msgstr "B< char *const >I<envp>B<[]);>"

#. type: Plain text
#: build/C/man3/exec.3:72
msgid "B<execvpe>(): _GNU_SOURCE"
msgstr "B<execvpe>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/exec.3:82
msgid ""
"The B<exec>()  family of functions replaces the current process image with a "
"new process image.  The functions described in this manual page are front-"
"ends for B<execve>(2).  (See the manual page for B<execve>(2)  for further "
"details about the replacement of the current process image.)"
msgstr ""
"B<exec>()  ファミリーの関数は現在のプロセスイメージを新しいプロセスイメージで"
"置き 換える。このマニュアルで説明されている関数は B<execve>(2)  のフロントエ"
"ンドである。 (現在のプロセスイメージの置き換えについての詳細は B<execve>(2)  "
"のマニュアルを参照)"

#. type: Plain text
#: build/C/man3/exec.3:85
msgid ""
"The initial argument for these functions is the name of a file that is to be "
"executed."
msgstr "これらの関数の最初の引き数は、実行されるファイルの名前である。"

#. type: Plain text
#: build/C/man3/exec.3:107
msgid ""
"The I<const char\\ *arg> and subsequent ellipses in the B<execl>(), B<execlp>"
"(), and B<execle>()  functions can be thought of as I<arg0>, I<arg1>, "
"\\&..., I<argn>.  Together they describe a list of one or more pointers to "
"null-terminated strings that represent the argument list available to the "
"executed program.  The first argument, by convention, should point to the "
"filename associated with the file being executed.  The list of arguments "
"I<must> be terminated by a null pointer, and, since these are variadic "
"functions, this pointer must be cast I<(char\\ *) NULL>."
msgstr ""
"関数 B<execl>(), B<execlp>(), B<execle>()  の I<const char\\ *arg> とそれに続"
"く省略部分は I<arg0>, I<arg1>, \\&..., I<argn> とみなされる。 これらには、実"
"行されるプログラムで利用可能な引き数のリストを指定する (引き数のリストは "
"NULL で終端された文字列へのポインタから構成される)。 慣習として、最初の引き数"
"は、実行されるファイル名 へのポインタにする。引き数のリストは必ず NULL で終わ"
"らなければならず、これらの関数は可変長引き数関数なので、 このポインタは I<"
"(char\\ *) NULL> とキャストしなければならない。"

#. type: Plain text
#: build/C/man3/exec.3:120
msgid ""
"The B<execv>(), B<execvp>(), and B<execvpe>()  functions provide an array of "
"pointers to null-terminated strings that represent the argument list "
"available to the new program.  The first argument, by convention, should "
"point to the filename associated with the file being executed.  The array of "
"pointers I<must> be terminated by a null pointer."
msgstr ""
"関数 B<execv>(), B<execvp>(), B<execvpe>()  は、利用可能な引き数リスト (NULL "
"で終端された文字列への ポインタの配列) を新しいプログラムに渡す。 慣習とし"
"て、最初の引き数は実行されるファイル名へ のポインタにする。ポインタの配列は必"
"ず NULL で終わらなければならない。"

#. type: Plain text
#: build/C/man3/exec.3:137
msgid ""
"The B<execle>()  and B<execvpe>()  functions allow the caller to specify the "
"environment of the executed program via the argument I<envp>.  The I<envp> "
"argument is an array of pointers to null-terminated strings and I<must> be "
"terminated by a null pointer.  The other functions take the environment for "
"the new process image from the external variable I<environ> in the calling "
"process."
msgstr ""
"関数 B<execle>(), B<execvpe>()  では、呼び出し元が引き数 I<envp> 経由実行され"
"るプログラムの環境を指定することができる。 I<envp> 引き数は、NULL で終端され"
"た文字列へのポインタの配列であり、 NULL ポインタで終わらなければならない。 他"
"の関数では、呼び出し元のプロセスの外部変数 B<environ> から新しいプロセス用の"
"環境を与える。"

#. type: SS
#: build/C/man3/exec.3:137
#, no-wrap
msgid "Special semantics for execlp() and execvp()"
msgstr "execlp() と execvp() の特別な動作"

#. type: Plain text
#: build/C/man3/exec.3:157
msgid ""
"The B<execlp>(), B<execvp>(), and B<execvpe>()  functions duplicate the "
"actions of the shell in searching for an executable file if the specified "
"filename does not contain a slash (/) character.  The file is sought in the "
"colon-separated list of directory pathnames specified in the B<PATH> "
"environment variable.  If this variable isn't defined, the path list "
"defaults to the current directory followed by the list of directories "
"returned by I<confstr(_CS_PATH)>.  (This B<confstr>(3)  call typically "
"returns the value \"/bin:/usr/bin\".)"
msgstr ""
"関数 B<execlp>(), B<execvp>(), B<execvpe>()  は、指定されたファイル名がスラッ"
"シュ (/) を含んでいない場合、 シェルと同じ動作で実行可能なファイルを探索す"
"る。 ファイルの検索は、環境変数 B<PATH> で指定されたコロン区切りのディレクト"
"リのパス名のリストを対象に行われる。 この変数が定義されていない場合、パス名の"
"リストのデフォルト値として、 カレントディレクトリの後ろに、 I<confstr"
"(_CS_PATH)> が返すディレクトリのリストをつなげた値が使用される (この "
"B<confstr>(3)  の呼び出しでは通常 \"/bin:/usr/bin\" が返される)。"

#. type: Plain text
#: build/C/man3/exec.3:161
msgid ""
"If the specified filename includes a slash character, then B<PATH> is "
"ignored, and the file at the specified pathname is executed."
msgstr ""
"指定されたファイル名がスラッシュを含む場合、 B<PATH> は無視され、指定されたパ"
"ス名のファイルが実行される。"

#. type: Plain text
#: build/C/man3/exec.3:163
msgid "In addition, certain errors are treated specially."
msgstr "さらに、いくつかのエラーは特別に処理される。"

#. type: Plain text
#: build/C/man3/exec.3:174
msgid ""
"If permission is denied for a file (the attempted B<execve>(2)  failed with "
"the error B<EACCES>), these functions will continue searching the rest of "
"the search path.  If no other file is found, however, they will return with "
"I<errno> set to B<EACCES>."
msgstr ""
"ファイルが実行ファイルでない場合 (このとき呼び出そうとした B<execve>(2)  はエ"
"ラー B<EACCES> で失敗する)、これらの関数は残りの検索パスの検索を続ける。 他に"
"ファイルが見つからなくなった場合 I<errno> に B<EACCES> を設定し復帰する。"

#. type: Plain text
#: build/C/man3/exec.3:183
msgid ""
"If the header of a file isn't recognized (the attempted B<execve>(2)  failed "
"with the error B<ENOEXEC>), these functions will execute the shell (I</bin/"
"sh>)  with the path of the file as its first argument.  (If this attempt "
"fails, no further searching is done.)"
msgstr ""
"ファイルのヘッダが実行形式として認識できない場合 (このとき呼び出そうとした "
"B<execve>(2)  はエラー B<ENOEXEC> で失敗する)、これらの関数はそのファイルを最"
"初の引き数としたシェル (I</bin/sh>)  を実行する (これにも失敗した場合、これ以"
"上の検索は行われない)。"

#. type: Plain text
#: build/C/man3/exec.3:190
msgid ""
"The B<exec>()  functions return only if an error has occurred.  The return "
"value is -1, and I<errno> is set to indicate the error."
msgstr ""
"B<exec>()  群の関数が復帰するのは、エラーが発生した場合のみである。 返り値は "
"-1 で、 I<errno> にエラーの内容がセットされる。"

#. type: Plain text
#: build/C/man3/exec.3:195
msgid ""
"All of these functions may fail and set I<errno> for any of the errors "
"specified for B<execve>(2)."
msgstr ""
"これら全ての関数は失敗する場合がある。その場合、 B<execve>(2)  に対して規定さ"
"れたエラーが I<errno> に設定される。"

#. type: Plain text
#: build/C/man3/exec.3:199
msgid "The B<execvpe>()  function first appeared in glibc 2.11."
msgstr "B<execvpe>()  関数は glibc 2.11 で初めて登場した。"

#. type: Plain text
#: build/C/man3/exec.3:201
msgid "POSIX.1-2001, POSIX.1-2008."
msgstr "POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man3/exec.3:205
msgid "The B<execvpe>()  function is a GNU extension."
msgstr "B<execvpe>()  関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/exec.3:215
msgid ""
"On some other systems, the default path (used when the environment does not "
"contain the variable B<PATH>) has the current working directory listed after "
"I</bin> and I</usr/bin>, as an anti-Trojan-horse measure.  Linux uses here "
"the traditional \"current directory first\" default path."
msgstr ""
"Linux 以外のシステムには、 (環境変数 B<PATH> が定義されていないときの)  デ"
"フォルトのパスにおいて、カレントディレクトリが I</bin> と I</usr/bin> の後ろ"
"に配置されるものもある。 これはトロイの木馬対策のためである。 Linux では、デ"
"フォルトのパスに、昔ながらの「現在のディレクトリを 先に探索」というルールを"
"使っている。"

#. type: Plain text
#: build/C/man3/exec.3:229
msgid ""
"The behavior of B<execlp>()  and B<execvp>()  when errors occur while "
"attempting to execute the file is historic practice, but has not "
"traditionally been documented and is not specified by the POSIX standard.  "
"BSD (and possibly other systems) do an automatic sleep and retry if "
"B<ETXTBSY> is encountered.  Linux treats it as a hard error and returns "
"immediately."
msgstr ""
"ファイルを実行しようとしている間にエラーが発生した時の B<execlp>()  と "
"B<execvp>()  のふるまいについて歴史的な慣習はあるが、伝統的に文書として記載さ"
"れておらず、 POSIX 標準でも規定されていない。BSD (またおそらく他のシステム) "
"では、 B<ETXTBSY> が発生した場合、自動的に中断 (sleep) し再試行を行う。 "
"Linux はそれをハードエラーとして取り扱い即座に復帰する。"

#. type: Plain text
#: build/C/man3/exec.3:241
msgid ""
"Traditionally, the functions B<execlp>()  and B<execvp>()  ignored all "
"errors except for the ones described above and B<ENOMEM> and B<E2BIG>, upon "
"which they returned.  They now return if any error other than the ones "
"described above occurs."
msgstr ""
"伝統的に、関数 B<execlp>()  と B<execvp>()  は、上で説明したエラーと、これら "
"2 つの関数自身が返す B<ENOMEM> と B<E2BIG> 以外の全てのエラーを無視していた"
"が、 今では、上で説明した以外のエラーが発生した場合でも、 返ってくるよう変更"
"された。"

#. type: Plain text
#: build/C/man3/exec.3:248
msgid ""
"B<sh>(1), B<execve>(2), B<fork>(2), B<ptrace>(2), B<fexecve>(3), B<environ>"
"(7)"
msgstr ""
"B<sh>(1), B<execve>(2), B<fork>(2), B<ptrace>(2), B<fexecve>(3), B<environ>"
"(7)"

#. type: TH
#: build/C/man2/execve.2:37
#, no-wrap
msgid "EXECVE"
msgstr "EXECVE"

#. type: TH
#: build/C/man2/execve.2:37
#, no-wrap
msgid "2014-01-08"
msgstr "2014-01-08"

#. type: Plain text
#: build/C/man2/execve.2:40
msgid "execve - execute program"
msgstr "execve - プログラムを実行する"

#. type: Plain text
#: build/C/man2/execve.2:44
msgid "B<int execve(const char *>I<filename>B<, char *const >I<argv>B<[], >"
msgstr "B<int execve(const char *>I<filename>B<, char *const >I<argv>B<[], >"

#. type: Plain text
#: build/C/man2/execve.2:51
msgid ""
"B<execve>()  executes the program pointed to by I<filename>.  I<filename> "
"must be either a binary executable, or a script starting with a line of the "
"form:"
msgstr ""
"B<execve>()  は、I<filename> によって指定されたプログラムを実行する。 "
"I<filename> は、バイナリ実行形式か、 以下の形式の行で始まるスクリプトでなけれ"
"ばならない。"

#. type: Plain text
#: build/C/man2/execve.2:55 build/C/man2/execve.2:267
#, no-wrap
msgid "B<#!> I<interpreter >[optional-arg]\n"
msgstr "B<#!> I<interpreter >[optional-arg]\n"

#. type: Plain text
#: build/C/man2/execve.2:59
msgid "For details of the latter case, see \"Interpreter scripts\" below."
msgstr "後者の詳細は、後ろの「インタプリタ・スクリプト」の節を参照のこと。"

#. type: Plain text
#: build/C/man2/execve.2:68
msgid ""
"I<argv> is an array of argument strings passed to the new program.  By "
"convention, the first of these strings should contain the filename "
"associated with the file being executed.  I<envp> is an array of strings, "
"conventionally of the form B<key=value>, which are passed as environment to "
"the new program.  Both I<argv> and I<envp> must be terminated by a null "
"pointer.  The argument vector and environment can be accessed by the called "
"program's main function, when it is defined as:"
msgstr ""
"I<argv> は新しいプログラムに渡される引き数文字列の配列である。\n"
"慣例では、引き数文字列の最初の要素には実行されたファイルに関連付けられた\n"
"ファイル名を含めることになっている。\n"
"I<envp> は文字列の配列であり、伝統的に B<key=value> の形式をしており、\n"
"新しいプログラムの環境変数として渡される。\n"
"I<argv> と I<envp> はいずれもの NULL ポインタで終わっている必要がある。\n"
"引き数配列と環境変数は、呼び出されたプログラムの main 関数を\n"
"以下のように定義することによってアクセス可能になる。"

#. type: Plain text
#: build/C/man2/execve.2:72
#, no-wrap
msgid "int main(int argc, char *argv[], char *envp[])\n"
msgstr "int main(int argc, char *argv[], char *envp[])\n"

#. type: Plain text
#: build/C/man2/execve.2:79
msgid ""
"B<execve>()  does not return on success, and the text, data, bss, and stack "
"of the calling process are overwritten by that of the program loaded."
msgstr ""
"成功した場合、 B<execve>()  は返らない。 そして、呼び出し元のプロセスの "
"text, data, bss, スタックは、 読み込まれたプログラムによって上書きされる。"

#. type: Plain text
#: build/C/man2/execve.2:83
msgid ""
"If the current program is being ptraced, a B<SIGTRAP> is sent to it after a "
"successful B<execve>()."
msgstr ""
"元のプログラムが ptrace されている場合、 B<execve>()  が成功した後に そのプロ"
"グラムに B<SIGTRAP> が送られる。"

#. type: Plain text
#: build/C/man2/execve.2:98
msgid ""
"If the set-user-ID bit is set on the program file pointed to by I<filename>, "
"and the underlying filesystem is not mounted I<nosuid> (the B<MS_NOSUID> "
"flag for B<mount>(2)), and the calling process is not being ptraced, then "
"the effective user ID of the calling process is changed to that of the owner "
"of the program file.  Similarly, when the set-group-ID bit of the program "
"file is set the effective group ID of the calling process is set to the "
"group of the program file."
msgstr ""
"I<filename> で指定されたプログラムファイルに set-user-ID ビットが設定されてお"
"り、 ファイルが存在するファイルシステムが I<nosuid> (B<mount>(2)  の "
"B<MS_NOSUID> フラグ) でマウントされておらず、 呼び出したプロセスが ptrace さ"
"れていない場合、 呼び出したプロセスの実効 (effective) ユーザ ID は プログラム"
"ファイルの所有者 (owner) に変更される。 同様に、プログラムファイルに set-"
"group-ID ビットが設定されていた場合、 呼び出したプロセスの有効グループ ID は "
"プログラムファイルのグループに変更される。"

#. type: Plain text
#: build/C/man2/execve.2:103
msgid ""
"The effective user ID of the process is copied to the saved set-user-ID; "
"similarly, the effective group ID is copied to the saved set-group-ID.  This "
"copying takes place after any effective ID changes that occur because of the "
"set-user-ID and set-group-ID permission bits."
msgstr ""
"プロセスの実効ユーザ ID は保存 (saved) set-user-ID にコピーされる。 同様に、"
"実効グループ ID は保存 set-group-ID にコピーされる。 このコピーは、set-user-"
"ID / set-group-ID 許可ビットにより発生する 実効 ID の変更後に行われる。"

#. type: Plain text
#: build/C/man2/execve.2:111
msgid ""
"If the executable is an a.out dynamically linked binary executable "
"containing shared-library stubs, the Linux dynamic linker B<ld.so>(8)  is "
"called at the start of execution to bring needed shared libraries into "
"memory and link the executable with them."
msgstr ""
"実行ファイルが動的リンクされた a.out 実行形式で、共有ライブラリの スタブを含"
"むものだった場合、実行の開始時に Linux の ダイナミックリンカ B<ld.so>(8)  が"
"呼び出され、必要な共有ライブラリをメモリに読み込んでリンクを行う。"

#. type: Plain text
#: build/C/man2/execve.2:120
msgid ""
"If the executable is a dynamically linked ELF executable, the interpreter "
"named in the PT_INTERP segment is used to load the needed shared libraries.  "
"This interpreter is typically I</lib/ld-linux.so.2> for binaries linked with "
"glibc 2.  (For binaries linked with the old Linux libc5, the interpreter was "
"typically I</lib/ld-linux.so.1>.)"
msgstr ""
"実行ファイルがダイナミックリンクされた ELF 実行形式だった場合、\n"
"PT_INTERP セグメントに指定されたインタプリタが必要な 共有ライブラリ\n"
"(shared library) を読み込むのに使用される。\n"
"通常、インタプリタは glibc 2 をリンクしたバイナリでは\n"
"I</lib/ld-linux.so.2> である (古い Linux libc5 をリンクした\n"
"バイナリでは、通常のインタプリタは I</lib/ld-linux.so.1> であった)。"

#. type: Plain text
#: build/C/man2/execve.2:124
msgid ""
"All process attributes are preserved during an B<execve>(), except the "
"following:"
msgstr ""
"以下に示す以外のすべてのプロセス属性は B<execve>()  の前後で保持される。"

#. type: Plain text
#: build/C/man2/execve.2:128
msgid ""
"The dispositions of any signals that are being caught are reset to the "
"default (B<signal>(7))."
msgstr ""
"捕捉されたシグナルの処理方法 (disposition) は デフォルト動作にリセットされる "
"(B<signal>(7))。"

#. type: Plain text
#: build/C/man2/execve.2:131
msgid "Any alternate signal stack is not preserved (B<sigaltstack>(2))."
msgstr "代替シグナルスタックはどれも保持されない (B<sigaltstack>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:134
msgid "Memory mappings are not preserved (B<mmap>(2))."
msgstr "メモリマッピングは保持されない (B<mmap>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:137
msgid "Attached System V shared memory segments are detached (B<shmat>(2))."
msgstr ""
"付加された (attached) System V 共有メモリセグメントは分離される (B<shmat>"
"(2))。"

#. type: Plain text
#: build/C/man2/execve.2:140
msgid "POSIX shared memory regions are unmapped (B<shm_open>(3))."
msgstr "POSIX 共有メモリ領域はマッピングを解除される (B<shm_open>(3))。"

#. type: Plain text
#: build/C/man2/execve.2:143
msgid "Open POSIX message queue descriptors are closed (B<mq_overview>(7))."
msgstr ""
"オープンされた POSIX メッセージキューディスクリプタはクローズされる "
"(B<mq_overview>(7))。"

#. type: Plain text
#: build/C/man2/execve.2:146
msgid "Any open POSIX named semaphores are closed (B<sem_overview>(7))."
msgstr ""
"オープンされた POSIX 名前付きセマフォはいずれもクローズされる "
"(B<sem_overview>(7))。"

#. type: Plain text
#: build/C/man2/execve.2:149
msgid "POSIX timers are not preserved (B<timer_create>(2))."
msgstr "POSIX タイマは保持されない (B<timer_create>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:152
msgid "Any open directory streams are closed (B<opendir>(3))."
msgstr ""
"オープンされたディレクトリストリームはいずれもクローズされる (B<opendir>"
"(3))。"

#. type: Plain text
#: build/C/man2/execve.2:156
msgid "Memory locks are not preserved (B<mlock>(2), B<mlockall>(2))."
msgstr "メモリロックは保持されない (B<mlock>(2), B<mlockall>(2))。"

#. type: Plain text
#: build/C/man2/execve.2:160
msgid "Exit handlers are not preserved (B<atexit>(3), B<on_exit>(3))."
msgstr "終了 (exit) ハンドラは保持されない (B<atexit>(3), B<on_exit>(3))。"

#. type: Plain text
#: build/C/man2/execve.2:163
msgid ""
"The floating-point environment is reset to the default (see B<fenv>(3))."
msgstr "浮動小数点関連の環境はデフォルトにリセットされる (B<fenv>(3)  参照)。"

#. type: Plain text
#: build/C/man2/execve.2:169
msgid ""
"The process attributes in the preceding list are all specified in "
"POSIX.1-2001.  The following Linux-specific process attributes are also not "
"preserved during an B<execve>():"
msgstr ""
"上記のリストのプロセス属性はいずれも POSIX.1-2001 で規定されている。 以下に示"
"す Linux 固有のプロセス属性も B<execve>()  の前後で保持されない。"

#. type: Plain text
#: build/C/man2/execve.2:176
msgid ""
"The B<prctl>(2)  B<PR_SET_DUMPABLE> flag is set, unless a set-user-ID or set-"
"group ID program is being executed, in which case it is cleared."
msgstr ""
"set-user-ID か set-group-ID されたプログラムが実行されている場合、 B<prctl>"
"(2)  の B<PR_SET_DUMPABLE> フラグはクリアされる。それ以外の場合、このフラグは"
"セットされる。"

#. type: Plain text
#: build/C/man2/execve.2:181
msgid "The B<prctl>(2)  B<PR_SET_KEEPCAPS> flag is cleared."
msgstr "B<prctl>(2)  の B<PR_SET_KEEPCAPS> フラグはクリアされる。"

#. type: Plain text
#: build/C/man2/execve.2:188
msgid ""
"(Since Linux 2.4.36 / 2.6.23)  If a set-user-ID or set-group-ID program is "
"being executed, then the parent death signal set by B<prctl>(2)  "
"B<PR_SET_PDEATHSIG> flag is cleared."
msgstr ""
"(Linux 2.4.36 以降 / 2.6.23 以降)  set-user-ID や set-group-ID されたプログラ"
"ムが実行された場合、 B<prctl>(2) の B<PR_SET_PDEATHSIG> フラグで設定された "
"parent death シグナルはクリアされる。"

#. type: Plain text
#: build/C/man2/execve.2:195
msgid ""
"The process name, as set by B<prctl>(2)  B<PR_SET_NAME> (and displayed by "
"I<ps\\ -o comm>), is reset to the name of the new executable file."
msgstr ""
"プロセス名は新しい実行ファイルの名前にリセットされる。 プロセス名は B<prctl>"
"(2)  の B<PR_SET_NAME> で設定でき、 I<ps\\ -o comm> で表示できる。"

#. type: Plain text
#: build/C/man2/execve.2:202
msgid ""
"The B<SECBIT_KEEP_CAPS> I<securebits> flag is cleared.  See B<capabilities>"
"(7)."
msgstr ""
"B<SECBIT_KEEP_CAPS> の I<securebits> フラグはクリアされる。 B<capabilities>"
"(7) 参照。"

#. type: Plain text
#: build/C/man2/execve.2:207
msgid "The termination signal is reset to B<SIGCHLD> (see B<clone>(2))."
msgstr ""
"終了シグナル (termination signal) は B<SIGCHLD> にリセットされる (B<clone>"
"(2)  参照)。"

#. type: Plain text
#: build/C/man2/execve.2:209 build/C/man2/fork.2:133
msgid "Note the following further points:"
msgstr "以下の点についても注意すること:"

#. type: Plain text
#: build/C/man2/execve.2:213
msgid ""
"All threads other than the calling thread are destroyed during an B<execve>"
"().  Mutexes, condition variables, and other pthreads objects are not "
"preserved."
msgstr ""
"呼び出し元スレッド以外の全てのスレッドは B<execve>()  中に破棄される。 "
"mutex、条件変数、その他の pthread オブジェクトは保持されない。"

#. type: Plain text
#: build/C/man2/execve.2:216
msgid ""
"The equivalent of I<setlocale(LC_ALL, \"C\")> is executed at program start-"
"up."
msgstr "I<setlocale(LC_ALL, \"C\")> 相当の処理がプログラム開始時に実行される。"

#. type: Plain text
#: build/C/man2/execve.2:224
msgid ""
"POSIX.1-2001 specifies that the dispositions of any signals that are ignored "
"or set to the default are left unchanged.  POSIX.1-2001 specifies one "
"exception: if B<SIGCHLD> is being ignored, then an implementation may leave "
"the disposition unchanged or reset it to the default; Linux does the former."
msgstr ""
"POSIX.1-2001 は、動作が無視かデフォルトに設定されている全てのシグナル の処理"
"方法は変更せずそのままにする、と規定している。 但し、POSIX.1-2001 には一つ例"
"外があり、 B<SIGCHLD> が無視になっている場合、 その処理方法を変更せずにそのま"
"まにするか、デフォルト動作にリセットするかは 実装依存となっている。 Linux で"
"は前者 (変更しない) となっている。"

#. type: Plain text
#: build/C/man2/execve.2:228
msgid ""
"Any outstanding asynchronous I/O operations are canceled (B<aio_read>(3), "
"B<aio_write>(3))."
msgstr ""
"完了していない非同期 I/O 操作はキャンセルされる (B<aio_read>(3), B<aio_write>"
"(3))。"

#. type: Plain text
#: build/C/man2/execve.2:233
msgid ""
"For the handling of capabilities during B<execve>(), see B<capabilities>(7)."
msgstr ""
"B<execve>(2)  時のケーパビリティの扱いについては、 B<capabilities>(7)  を参"
"照。"

#.  On Linux it appears that these file descriptors are
#.  always open after an execve(), and it looks like
#.  Solaris 8 and FreeBSD 6.1 are the same. -- mtk, 30 Apr 2007
#. type: Plain text
#: build/C/man2/execve.2:260
msgid ""
"By default, file descriptors remain open across an B<execve>().  File "
"descriptors that are marked close-on-exec are closed; see the description of "
"B<FD_CLOEXEC> in B<fcntl>(2).  (If a file descriptor is closed, this will "
"cause the release of all record locks obtained on the underlying file by "
"this process.  See B<fcntl>(2)  for details.)  POSIX.1-2001 says that if "
"file descriptors 0, 1, and 2 would otherwise be closed after a successful "
"B<execve>(), and the process would gain privilege because the set-user_ID or "
"set-group_ID permission bit was set on the executed file, then the system "
"may open an unspecified file for each of these file descriptors.  As a "
"general principle, no portable program, whether privileged or not, can "
"assume that these three file descriptors will remain closed across an "
"B<execve>()."
msgstr ""
"デフォルトでは、ファイルディスクリプタは B<execve>()  を行った後でもオープン"
"されたままである。 close-on-exec の印が付いているファイルディスクリプタはク"
"ローズされる。 B<fcntl>(2)  の B<FD_CLOEXEC> の説明を参照。 (ファイルディスク"
"リプタがクローズされると、このプロセスが ファイルディスクリプタに対応するファ"
"イルに対して獲得していた レコードのロックが全て解放されることになる。)  "
"POSIX.1-2001 では、 ファイルディスクリプタ 0, 1, 2 が B<execve>()  成功後にど"
"こかでクローズされ、かつ 実行されるファイルに set-user_ID か set-group_ID の"
"許可ビットが セットされていてプロセスが特権を獲得した場合、 システムは何らか"
"のファイルをオープンする際に これらの番号のディスクリプタのどれかを使うことが"
"ある、 とされている。 原則として、移植性が必要なプログラムでは、 特権の有無に"
"関わらず、 B<execve>()  の前後でこれら 3つのファイルディスクリプタがクローズ"
"されたままで あることを前提にすることはできない。"

#. type: SS
#: build/C/man2/execve.2:260
#, no-wrap
msgid "Interpreter scripts"
msgstr "インタプリタ・スクリプト"

#. type: Plain text
#: build/C/man2/execve.2:263
msgid ""
"An interpreter script is a text file that has execute permission enabled and "
"whose first line is of the form:"
msgstr ""
"インタプリタ・スクリプトとは、実行許可が有効になっていて、 最初の行が以下の形"
"になっているテキストファイルのことである。"

#. type: Plain text
#: build/C/man2/execve.2:281
msgid ""
"The I<interpreter> must be a valid pathname for an executable which is not "
"itself a script.  If the I<filename> argument of B<execve>()  specifies an "
"interpreter script, then I<interpreter> will be invoked with the following "
"arguments:"
msgstr ""
"I<interpreter> は有効な実行ファイルのパス名でなければならず、 それ自身がスク"
"リプトであってはならない。 B<execve>()  の I<filename> 引き数がインタプリタス"
"クリプトを指定している場合、 I<interpreter> は以下の引き数で起動される。"

#. type: Plain text
#: build/C/man2/execve.2:285
#, no-wrap
msgid "I<interpreter> [optional-arg] I<filename> arg...\n"
msgstr "I<interpreter> [optional-arg] I<filename> arg...\n"

#. type: Plain text
#: build/C/man2/execve.2:296
msgid ""
"where I<arg...> is the series of words pointed to by the I<argv> argument of "
"B<execve>(), starting at I<argv>[1]."
msgstr "I<arg...> は、 B<execve>() の I<argv> 引き数が指すワード列である。 I<argv>[1] から始まる。"

#. type: Plain text
#: build/C/man2/execve.2:301
msgid ""
"For portable use, I<optional-arg> should either be absent, or be specified "
"as a single word (i.e., it should not contain white space); see NOTES below."
msgstr ""
"移植性を持たすには、 I<optional-arg> は空か 1ワードだけにすべきである (つま"
"り、ホワイトスペースを含めるべきではない)。 下記の「注意」の節を参照。"

#. type: SS
#: build/C/man2/execve.2:301
#, no-wrap
msgid "Limits on size of arguments and environment"
msgstr "引き数と環境変数の合計サイズの上限"

#. type: Plain text
#: build/C/man2/execve.2:314
msgid ""
"Most UNIX implementations impose some limit on the total size of the command-"
"line argument (I<argv>)  and environment (I<envp>)  strings that may be "
"passed to a new program.  POSIX.1 allows an implementation to advertise this "
"limit using the B<ARG_MAX> constant (either defined in I<E<lt>limits.hE<gt>> "
"or available at run time using the call I<sysconf(_SC_ARG_MAX)>)."
msgstr ""
"ほとんどの UNIX の実装は、新しいプログラムに渡すことができる コマンドライン引"
"き数 (I<argv>)  と環境変数 (I<envp>)  の文字列群の合計サイズに何らかの上限を"
"設けている。 POSIX.1 は、 B<ARG_MAX> 定数を使ってこの上限を決める実装を認めて"
"いる (B<ARG_MAX> は I<E<lt>limits.hE<gt>> で定義されるか、実行時に I<sysconf"
"(_SC_ARG_MAX)> の呼び出しで入手できるかのいずれかである)。"

#. type: Plain text
#: build/C/man2/execve.2:321
msgid ""
"On Linux prior to kernel 2.6.23, the memory used to store the environment "
"and argument strings was limited to 32 pages (defined by the kernel constant "
"B<MAX_ARG_PAGES>).  On architectures with a 4-kB page size, this yields a "
"maximum size of 128 kB."
msgstr ""
"カーネル 2.6.23 より前の Linux では、環境変数と引き数の文字列群を 格納するの"
"に使用されるメモリは 32 ページに制限されていた (32 ページというのはカーネル定"
"数 B<MAX_ARG_PAGES> で定義される)。したがって、 ページサイズが 4 kB のアーキ"
"テクチャでは、 最大サイズは 128 kB ということになる。"

#.  For some background on the changes to ARG_MAX in kernels 2.6.23 and
#.  2.6.25, see:
#.      http://sourceware.org/bugzilla/show_bug.cgi?id=5786
#.      http://bugzilla.kernel.org/show_bug.cgi?id=10095
#.      http://thread.gmane.org/gmane.linux.kernel/646709/focus=648101,
#.      checked into 2.6.25 as commit a64e715fc74b1a7dcc5944f848acc38b2c4d4ee2.
#.  Ollie: That doesn't include the lists of pointers, though,
#.  so the actual usage is a bit higher (1 pointer per argument).
#. type: Plain text
#: build/C/man2/execve.2:357
msgid ""
"On kernel 2.6.23 and later, most architectures support a size limit derived "
"from the soft B<RLIMIT_STACK> resource limit (see B<getrlimit>(2))  that is "
"in force at the time of the B<execve>()  call.  (Architectures with no "
"memory management unit are excepted: they maintain the limit that was in "
"effect before kernel 2.6.23.)  This change allows programs to have a much "
"larger argument and/or environment list.  For these architectures, the total "
"size is limited to 1/4 of the allowed stack size.  (Imposing the 1/4-limit "
"ensures that the new program always has some stack space.)  Since Linux "
"2.6.25, the kernel places a floor of 32 pages on this size limit, so that, "
"even when B<RLIMIT_STACK> is set very low, applications are guaranteed to "
"have at least as much argument and environment space as was provided by "
"Linux 2.6.23 and earlier.  (This guarantee was not provided in Linux 2.6.23 "
"and 2.6.24.)  Additionally, the limit per string is 32 pages (the kernel "
"constant B<MAX_ARG_STRLEN>), and the maximum number of strings is 0x7FFFFFFF."
msgstr ""
"カーネル 2.6.23 以降では、ほとんどのアーキテクチャにおいて、 B<execve>()  が"
"呼び出された時点で適用されているリソースのソフト上限 B<RLIMIT_STACK> に基づい"
"たサイズ上限が使われる (メモリ管理ユニット (MMU) を持たないアーキテクチャは上"
"記の変更の 例外であり、これらのアーキテクチャではカーネル 2.6.23 より前と 同"
"じ上限がそのまま使用される)。 これらのアーキテクチャでは、合計サイズは許可さ"
"れたスタックサイズの 1/4 に制限されている (1/4 の上限を設けているのは、新しい"
"プログラムが必ずある程度の スタック空間を持てることを保証するためである)。 "
"Linux 2.6.25 以降では、カーネルはこのサイズ上限に 32 ページの下限を 設けてい"
"る。これにより、 B<RLIMIT_STACK> が非常に小さく設定された場合でも、アプリケー"
"ションが少なくとも Linux 2.6.23 以前で提供されていたのと同じ大きさの引き数と"
"環境変数の空間 と同じだけは確保できることが保証されている (この最低限の保証"
"は Linux 2.6.23 と 2.6.24 では提供されていない)。 また、各文字列の上限は 32 "
"ページ (カーネル定数 B<MAX_ARG_STRLEN>)  で、文字列数の最大値は 0x7FFFFFFF で"
"ある。"

#. type: Plain text
#: build/C/man2/execve.2:363
msgid ""
"On success, B<execve>()  does not return, on error -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功すると B<execve>()  は返らない。エラーの場合は -1 を返し、 I<errno> を適"
"切に設定する。"

#. type: TP
#: build/C/man2/execve.2:364
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/execve.2:371
msgid ""
"The total number of bytes in the environment (I<envp>)  and argument list "
"(I<argv>)  is too large."
msgstr ""
"環境変数 (I<envp>)  と引き数リスト (I<argv>)  の合計バイト数が大き過ぎる。"

#. type: Plain text
#: build/C/man2/execve.2:378
msgid ""
"Search permission is denied on a component of the path prefix of I<filename> "
"or the name of a script interpreter.  (See also B<path_resolution>(7).)"
msgstr ""
"I<filename> やスクリプトインタプリタ名の構成要素に検索許可 (search "
"permission)  が与えられていない (B<path_resolution>(7)  も参照すること)。"

#. type: Plain text
#: build/C/man2/execve.2:381
msgid "The file or a script interpreter is not a regular file."
msgstr ""
"ファイルもしくはスクリプトのインタプリタが通常ファイル (regular file)  でな"
"い。"

#. type: Plain text
#: build/C/man2/execve.2:384
msgid ""
"Execute permission is denied for the file or a script or ELF interpreter."
msgstr ""
"ファイルやスクリプトや ELF インタプリタに 実行許可 (execute permission) が与"
"えられていない。"

#. type: Plain text
#: build/C/man2/execve.2:388
msgid "The filesystem is mounted I<noexec>."
msgstr "ファイルシステムが I<noexec> でマウントされている。"

#. type: Plain text
#: build/C/man2/execve.2:396
#, fuzzy
#| msgid "I<filename> points outside your accessible address space."
msgid ""
"I<filename> or one of the pointers in the vectors I<argv> or I<envp> points "
"outside your accessible address space."
msgstr "I<filename> がアクセス可能なアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/execve.2:400
msgid ""
"An ELF executable had more than one PT_INTERP segment (i.e., tried to name "
"more than one interpreter)."
msgstr ""
"ELF 実行形式で複数の PT_INTERP セグメントが存在する。 (すなわち複数のインタプ"
"リタを指定した。)"

#. type: TP
#: build/C/man2/execve.2:403 build/C/man2/truncate.2:148
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: build/C/man2/execve.2:406
msgid "An ELF interpreter was a directory."
msgstr "ELF インタプリタがディレクトリだった。"

#. type: TP
#: build/C/man2/execve.2:406
#, no-wrap
msgid "B<ELIBBAD>"
msgstr "B<ELIBBAD>"

#. type: Plain text
#: build/C/man2/execve.2:409
msgid "An ELF interpreter was not in a recognized format."
msgstr "ELF インタプリタが理解できるフォーマットでなかった。"

#. type: Plain text
#: build/C/man2/execve.2:414
msgid ""
"Too many symbolic links were encountered in resolving I<filename> or the "
"name of a script or ELF interpreter."
msgstr ""
"I<filename> やスクリプトや ELF のインタプリタを解決する際に遭遇した シンボ"
"リックリンクが多過ぎる。"

#. type: Plain text
#: build/C/man2/execve.2:417
msgid "The process has the maximum number of files open."
msgstr "そのプロセスがオープンできるファイル数の上限まで既にオープンしている。"

#. type: Plain text
#: build/C/man2/execve.2:421
msgid "I<filename> is too long."
msgstr "I<filename> が長過ぎる。"

#. type: TP
#: build/C/man2/execve.2:421 build/C/man3/getlogin.3:108
#: build/C/man2/swapon.2:141 build/C/man2/uselib.2:67
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/execve.2:424 build/C/man2/swapon.2:144
#: build/C/man2/uselib.2:70
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム全体の上限に達していた。"

#. type: Plain text
#: build/C/man2/execve.2:430
msgid ""
"The file I<filename> or a script or ELF interpreter does not exist, or a "
"shared library needed for file or interpreter cannot be found."
msgstr "ファイル I<filename> かスクリプトや ELF のインタプリタが存在しない。"

#. type: TP
#: build/C/man2/execve.2:430 build/C/man2/uselib.2:70
#, no-wrap
msgid "B<ENOEXEC>"
msgstr "B<ENOEXEC>"

#. type: Plain text
#: build/C/man2/execve.2:435
msgid ""
"An executable is not in a recognized format, is for the wrong architecture, "
"or has some other format error that means it cannot be executed."
msgstr ""
"実行ファイルが理解できない形式であるか、違うアーキテクチャのものか、 その他の"
"フォーマットエラーにより実行ができなかった。"

#. type: Plain text
#: build/C/man2/execve.2:443
msgid ""
"A component of the path prefix of I<filename> or a script or ELF interpreter "
"is not a directory."
msgstr ""
"I<filename> やスクリプトや ELF のインタプリタの構成要素がディレクトリでない。"

#. type: Plain text
#: build/C/man2/execve.2:449
msgid ""
"The filesystem is mounted I<nosuid>, the user is not the superuser, and the "
"file has the set-user-ID or set-group-ID bit set."
msgstr ""
"ファイルシステムが I<nosuid> でマウントされ、ユーザがスーパーユーザでなく、 "
"ファイルに set-user-ID あるいは set-group-ID ビットが設定されている。"

#. type: Plain text
#: build/C/man2/execve.2:453
msgid ""
"The process is being traced, the user is not the superuser and the file has "
"the set-user-ID or set-group-ID bit set."
msgstr ""
"プロセスがトレースされ、ユーザがスーパーユーザでなく、 ファイルに set-user-"
"ID あるいは set-group-ID ビットが設定されている。"

#. type: Plain text
#: build/C/man2/execve.2:456
msgid "Executable was open for writing by one or more processes."
msgstr "実行ファイルを書き込み用にオープンしているプロセスがある。"

#.  SVr4 documents additional error
#.  conditions EAGAIN, EINTR, ELIBACC, ENOLINK, EMULTIHOP; POSIX does not
#.  document ETXTBSY, EPERM, EFAULT, ELOOP, EIO, ENFILE, EMFILE, EINVAL,
#.  EISDIR or ELIBBAD error conditions.
#. type: Plain text
#: build/C/man2/execve.2:464
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 does not document the #! behavior "
"but is otherwise compatible."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 には #! 動作についての記述はない"
"が、 他は互換性がある。"

#. type: Plain text
#: build/C/man2/execve.2:467
msgid "Set-user-ID and set-group-ID processes can not be B<ptrace>(2)d."
msgstr ""
"set-user-id プロセスと set-group-ID プロセスは B<ptrace>(2)  できない。"

#. type: Plain text
#: build/C/man2/execve.2:469
msgid "Linux ignores the set-user-ID and set-group-ID bits on scripts."
msgstr "Linux はスクリプトの set-user-ID と set-group-ID ビットを無視する。"

#. type: Plain text
#: build/C/man2/execve.2:480
msgid ""
"The result of mounting a filesystem I<nosuid> varies across Linux kernel "
"versions: some will refuse execution of set-user-ID and set-group-ID "
"executables when this would give the user powers she did not have already "
"(and return B<EPERM>), some will just ignore the set-user-ID and set-group-"
"ID bits and B<exec>()  successfully."
msgstr ""
"ファイルシステムを I<nosuid> でマウントした場合に set-user-ID/set-group-ID の"
"実行ファイルを どの様に扱うかは、Linux カーネルのバージョンによって異なる: あ"
"るバージョンでは、すでに必要な権限を持っている場合を除いて、 その実行を拒否す"
"る (そして B<EPERM> を返す)。別のあるバージョンでは set-user-ID/set-group-ID "
"ビットのみを無視し B<exec>()  は成功する。"

#. type: Plain text
#: build/C/man2/execve.2:483
msgid ""
"A maximum line length of 127 characters is allowed for the first line in a "
"#! executable shell script."
msgstr ""
"#! 実行形式のシェルスクリプトの 1行目に許されている文字数は、 最大 127 文字で"
"ある。"

#.  e.g., Solaris 8
#.  e.g., FreeBSD before 6.0, but not FreeBSD 6.0 onward
#. type: Plain text
#: build/C/man2/execve.2:502
msgid ""
"The semantics of the I<optional-arg> argument of an interpreter script vary "
"across implementations.  On Linux, the entire string following the "
"I<interpreter> name is passed as a single argument to the interpreter, and "
"this string can include white space.  However, behavior differs on some "
"other systems.  Some systems use the first white space to terminate "
"I<optional-arg>.  On some systems, an interpreter script can have multiple "
"arguments, and white spaces in I<optional-arg> are used to delimit the "
"arguments."
msgstr ""
"インタプリタ・スクリプトの I<optional-arg> 引き数の解釈方法は実装により異な"
"る。 Linux では、インタプリタ名 I<interpreter> に続く文字列全体がインタプリタ"
"に 1個の引き数として渡される。 しかし、動作が異なるシステムもある。 あるシス"
"テムでは、 I<optional-arg> のうち最初のホワイトスペースまでが 引き数として渡"
"される。 また、別のシステムでは インタプリタ・スクリプトは複数の引き数を持つ"
"ことができ、 I<optional-arg> 内のホワイトスペースが引き数の区切りとなる。"

#.  e.g., EFAULT on Solaris 8 and FreeBSD 6.1; but
#.  HP-UX 11 is like Linux -- mtk, Apr 2007
#.  Bug filed 30 Apr 2007: http://bugzilla.kernel.org/show_bug.cgi?id=8408
#.  Bug rejected (because fix would constitute an ABI change).
#. type: Plain text
#: build/C/man2/execve.2:519
msgid ""
"On Linux, either I<argv> or I<envp> can be specified as NULL, which has the "
"same effect as specifying these arguments as a pointer to a list containing "
"a single null pointer.  B<Do not take advantage of this misfeature!> It is "
"nonstandard and nonportable: on most other UNIX systems doing this will "
"result in an error (B<EFAULT>)."
msgstr ""
"Linux では、 I<argv> と I<envp> のいずれかには NULL を指定することができる。"
"これは、これらの引き数に NULL ポインタ 1個だけを含むリストへのポインタを指定"
"したのと同じ効果を持つ。 B<「この間違った機能を利用しないこと」>。 これは非標"
"準で、移植性もない。 他のほとんどの UNIX システムでは、これを行うとエラー "
"(B<EFAULT>)  になる。"

#.  .SH BUGS
#.  Some Linux versions have failed to check permissions on ELF
#.  interpreters.  This is a security hole, because it allows users to
#.  open any file, such as a rewinding tape device, for reading.  Some
#.  Linux versions have also had other security holes in
#.  .BR execve ()
#.  that could be exploited for denial of service by a suitably crafted
#.  ELF binary. There are no known problems with 2.0.34 or 2.2.15.
#. type: Plain text
#: build/C/man2/execve.2:539
msgid ""
"POSIX.1-2001 says that values returned by B<sysconf>(3)  should be invariant "
"over the lifetime of a process.  However, since Linux 2.6.23, if the "
"B<RLIMIT_STACK> resource limit changes, then the value reported by "
"B<_SC_ARG_MAX> will also change, to reflect the fact that the limit on space "
"for holding command-line arguments and environment variables has changed."
msgstr ""
"POSIX.1-2001 は、 B<sysconf>(3)  が返す値はプロセスの生存中は変化しないべきだ"
"としている。 しかしながら、Linux 2.6.23 以降では、リソース上限 "
"B<RLIMIT_STACK> が変化した場合、 コマンドライン引き数と環境変数を保持するため"
"の空間に対する上限が 変化したことを反映して、 B<_SC_ARG_MAX> が返す値も変化す"
"る。"

#. type: SS
#: build/C/man2/execve.2:539
#, no-wrap
msgid "Historical"
msgstr "歴史"

#. type: Plain text
#: build/C/man2/execve.2:550
msgid ""
"With UNIX V6 the argument list of an B<exec>()  call was ended by 0, while "
"the argument list of I<main> was ended by -1.  Thus, this argument list was "
"not directly usable in a further B<exec>()  call.  Since UNIX V7 both are "
"NULL."
msgstr ""
"UNIX V6 では B<exec>()  コールの引き数リストは 0 で終端され、 I<main> の引き"
"数リストは -1 で終端されていた。 そのため、 I<main> の引き数リストは、その後"
"の B<exec>()  コールには直接使用できなかった。 UNIX V7 以降では、ともに NULL "
"で終端される。"

#. type: Plain text
#: build/C/man2/execve.2:553
msgid ""
"The following program is designed to be execed by the second program below.  "
"It just echoes its command-line one per line."
msgstr ""
"このプログラムは、以下の二つ目のプログラムから実行するためのものである。 コマ"
"ンドラインを 1行に 1個ずつ表示するだけのプログラムである。"

#. type: Plain text
#: build/C/man2/execve.2:557
#, no-wrap
msgid "/* myecho.c */\n"
msgstr "/* myecho.c */\n"

#. type: Plain text
#: build/C/man2/execve.2:560
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man2/execve.2:565
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int j;\n"

#. type: Plain text
#: build/C/man2/execve.2:568
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"
msgstr ""
"    for (j = 0; j E<lt> argc; j++)\n"
"        printf(\"argv[%d]: %s\\en\", j, argv[j]);\n"

#. type: Plain text
#: build/C/man2/execve.2:576
msgid ""
"This program can be used to exec the program named in its command-line "
"argument:"
msgstr ""
"以下のプログラムは、コマンドライン引き数で指定した名前のプログラムを 実行する"
"のに使う。"

#. type: Plain text
#: build/C/man2/execve.2:580
#, no-wrap
msgid "/* execve.c */\n"
msgstr "/* execve.c */\n"

#. type: Plain text
#: build/C/man2/execve.2:584
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/execve.2:590
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *newargv[] = { NULL, \"hello\", \"world\", NULL };\n"
"    char *newenviron[] = { NULL };\n"

#. type: Plain text
#: build/C/man2/execve.2:595
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>file-to-execE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/execve.2:597
#, no-wrap
msgid "    newargv[0] = argv[1];\n"
msgstr "    newargv[0] = argv[1];\n"

#. type: Plain text
#: build/C/man2/execve.2:602
#, no-wrap
msgid ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() only returns on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    execve(argv[1], newargv, newenviron);\n"
"    perror(\"execve\");   /* execve() only returns on error */\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/execve.2:606
msgid "We can use the second program to exec the first as follows:"
msgstr ""
"二つ目のプログラムを使って一つ目のプログラムを実行するには 以下のようにする。"

#. type: Plain text
#: build/C/man2/execve.2:615
#, no-wrap
msgid ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"
msgstr ""
"$B< cc myecho.c -o myecho>\n"
"$B< cc execve.c -o execve>\n"
"$B< ./execve ./myecho>\n"
"argv[0]: ./myecho\n"
"argv[1]: hello\n"
"argv[2]: world\n"

#. type: Plain text
#: build/C/man2/execve.2:623
msgid ""
"We can also use these programs to demonstrate the use of a script "
"interpreter.  To do this we create a script whose \"interpreter\" is our "
"I<myecho> program:"
msgstr ""
"さらに、これらのプログラムを使って、スクリプト・インタプリタの例を示す。 この"
"ために、「インタプリタ」として先ほど作成したプログラム I<myecho> を使うスクリ"
"プトを作成する。"

#. type: Plain text
#: build/C/man2/execve.2:630
#, no-wrap
msgid ""
"$B< cat E<gt> script.sh>\n"
"B<#! ./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script.sh>\n"
msgstr ""
"$B< cat E<gt> script.sh>\n"
"B<#! ./myecho script-arg>\n"
"B<^D>\n"
"$B< chmod +x script.sh>\n"

#. type: Plain text
#: build/C/man2/execve.2:634
msgid "We can then use our program to exec the script:"
msgstr "作成しておいたプログラムを使ってスクリプトを実行する。"

#. type: Plain text
#: build/C/man2/execve.2:643
#, no-wrap
msgid ""
"$B< ./execve ./script.sh>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script.sh\n"
"argv[3]: hello\n"
"argv[4]: world\n"
msgstr ""
"$B< ./execve ./script.sh>\n"
"argv[0]: ./myecho\n"
"argv[1]: script-arg\n"
"argv[2]: ./script.sh\n"
"argv[3]: hello\n"
"argv[4]: world\n"

#. type: Plain text
#: build/C/man2/execve.2:656
msgid ""
"B<chmod>(2), B<fork>(2), B<ptrace>(2), B<execl>(3), B<fexecve>(3), B<getopt>"
"(3), B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"
msgstr ""
"B<chmod>(2), B<fork>(2), B<ptrace>(2), B<execl>(3), B<fexecve>(3), B<getopt>"
"(3), B<credentials>(7), B<environ>(7), B<path_resolution>(7), B<ld.so>(8)"

#. type: TH
#: build/C/man2/exit_group.2:25
#, no-wrap
msgid "EXIT_GROUP"
msgstr "EXIT_GROUP"

#. type: TH
#: build/C/man2/exit_group.2:25
#, no-wrap
msgid "2008-11-27"
msgstr "2008-11-27"

#. type: Plain text
#: build/C/man2/exit_group.2:28
msgid "exit_group - exit all threads in a process"
msgstr "exit_group - プロセス中の全てのスレッドを exit させる"

#. type: Plain text
#: build/C/man2/exit_group.2:31
#, no-wrap
msgid "B<#include E<lt>linux/unistd.hE<gt>>\n"
msgstr "B<#include E<lt>linux/unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/exit_group.2:33
#, no-wrap
msgid "B<void exit_group(int >I<status>B<);>\n"
msgstr "B<void exit_group(int >I<status>B<);>\n"

#. type: Plain text
#: build/C/man2/exit_group.2:39
msgid ""
"This system call is equivalent to B<exit>(2)  except that it terminates not "
"only the calling thread, but all threads in the calling process's thread "
"group."
msgstr ""
"このシステムコールは、基本的に B<exit>(2)  と等しいが、 呼び出し元のスレッド"
"だけでなく、呼び出し元のプロセスのスレッドグループに ある全てのスレッドを終了"
"させる点が異なる。"

#. type: Plain text
#: build/C/man2/exit_group.2:41
msgid "This system call does not return."
msgstr "このシステムコールは値を返さない。"

#. type: Plain text
#: build/C/man2/exit_group.2:43
msgid "This call is present since Linux 2.5.35."
msgstr "このコールは、Linux 2.5.35 以降に存在する。"

#. type: Plain text
#: build/C/man2/exit_group.2:45
msgid "This call is Linux-specific."
msgstr ""
"glibc 2.3 以降では、 B<exit>(2)  のラッパー関数が呼び出された際に、 このシス"
"テムコールが起動される。"

#. type: Plain text
#: build/C/man2/exit_group.2:49
msgid ""
"Since glibc 2.3, this is the system call invoked when the B<exit>(2)  "
"wrapper function is called."
msgstr "このコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/exit_group.2:51
msgid "B<exit>(2)"
msgstr "B<exit>(2)"

#. type: TH
#: build/C/man2/fcntl.2:61
#, no-wrap
msgid "FCNTL"
msgstr "FCNTL"

#. type: TH
#: build/C/man2/fcntl.2:61 build/C/man2/syscalls.2:31
#, no-wrap
msgid "2014-02-20"
msgstr "2014-02-20"

#. type: Plain text
#: build/C/man2/fcntl.2:64
msgid "fcntl - manipulate file descriptor"
msgstr "fcntl - ファイルディスクリプタの操作を行う"

#. type: Plain text
#: build/C/man2/fcntl.2:68
#, no-wrap
msgid ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"
msgstr ""
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>fcntl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/fcntl.2:70
#, no-wrap
msgid "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"
msgstr "B<int fcntl(int >I<fd>B<, int >I<cmd>B<, ... /* >I<arg>B< */ );>\n"

#. type: Plain text
#: build/C/man2/fcntl.2:77
msgid ""
"B<fcntl>()  performs one of the operations described below on the open file "
"descriptor I<fd>.  The operation is determined by I<cmd>."
msgstr ""
"B<fcntl>()  は、オープンされたファイルディスクリプタ I<fd> に関して下記の操作"
"を行う。操作は I<cmd> によって決まる:"

#. type: Plain text
#: build/C/man2/fcntl.2:91
msgid ""
"B<fcntl>()  can take an optional third argument.  Whether or not this "
"argument is required is determined by I<cmd>.  The required argument type is "
"indicated in parentheses after each I<cmd> name (in most cases, the required "
"type is I<int>, and we identify the argument using the name I<arg>), or "
"I<void> is specified if the argument is not required."
msgstr ""
"B<fcntl>() はオプションとして第三引き数をとることができる。 第三引き数が必"
"要\n"
"かどうかは I<cmd> により決まる。必要な引き数の型は I<cmd> 名の後ろの括弧内"
"で\n"
"指定されている (ほとんどの場合、必要な型は I<int> であり、この引き数を表す"
"の\n"
"に I<arg> という名前を使っている)。引き数が必要ない場合には I<void> が指定"
"さ\n"
"れている。"

#. type: SS
#: build/C/man2/fcntl.2:91
#, no-wrap
msgid "Duplicating a file descriptor"
msgstr "ファイルディスクリプタの複製"

#. type: TP
#: build/C/man2/fcntl.2:92
#, no-wrap
msgid "B<F_DUPFD> (I<int>)"
msgstr "B<F_DUPFD> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:102
msgid ""
"Find the lowest numbered available file descriptor greater than or equal to "
"I<arg> and make it be a copy of I<fd>.  This is different from B<dup2>(2), "
"which uses exactly the descriptor specified."
msgstr ""
"利用可能なファイルディスクリプタのうち、 I<arg> 以上で最小のものを探し、 "
"I<fd> のコピーとする。これは別の形の B<dup2>(2)  である。 B<dup2>(2)  では指"
"定されたディスクリプタが使われる点が違う。"

#. type: Plain text
#: build/C/man2/fcntl.2:104
msgid "On success, the new descriptor is returned."
msgstr "成功すると、新しいディスクリプタが返される。"

#. type: Plain text
#: build/C/man2/fcntl.2:108
msgid "See B<dup>(2)  for further details."
msgstr "詳細は B<dup>(2)  を参照のこと。"

#. type: TP
#: build/C/man2/fcntl.2:108
#, no-wrap
msgid "B<F_DUPFD_CLOEXEC> (I<int>; since Linux 2.6.24)"
msgstr "B<F_DUPFD_CLOEXEC> (I<int>; Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:125
msgid ""
"As for B<F_DUPFD>, but additionally set the close-on-exec flag for the "
"duplicate descriptor.  Specifying this flag permits a program to avoid an "
"additional B<fcntl>()  B<F_SETFD> operation to set the B<FD_CLOEXEC> flag.  "
"For an explanation of why this flag is useful, see the description of "
"B<O_CLOEXEC> in B<open>(2)."
msgstr ""
"B<F_DUPFD> と同様だが、それに加えて複製されたディスクリプタに対して close-on-"
"exec フラグをセットする。 このフラグを指定することで、プログラムは "
"B<FD_CLOEXEC> フラグをセットするために B<fcntl>()  の B<F_SETFD> 操作を追加で"
"行う必要がなくなる。 このフラグがなぜ有用かについては、 B<open>(2)  の "
"B<O_CLOEXEC> の説明を参照のこと。"

#. type: SS
#: build/C/man2/fcntl.2:125
#, no-wrap
msgid "File descriptor flags"
msgstr "ファイルディスクリプタフラグ"

#. type: Plain text
#: build/C/man2/fcntl.2:136
msgid ""
"The following commands manipulate the flags associated with a file "
"descriptor.  Currently, only one such flag is defined: B<FD_CLOEXEC>, the "
"close-on-exec flag.  If the B<FD_CLOEXEC> bit is 0, the file descriptor will "
"remain open across an B<execve>(2), otherwise it will be closed."
msgstr ""
"以下のコマンドを使って、ファイルディスクリプタに関連するフラグ を操作すること"
"ができる。 現在のところ、定義されているフラグは一つだけである: B<FD_CLOEXEC> "
"(close-on-exec フラグ)。 B<FD_CLOEXEC> ビットが 0 なら、ファイルディスクリプ"
"タは B<execve>(2)  を行ってもオープンされたままだが、そうでない場合はクローズ"
"される。"

#. type: TP
#: build/C/man2/fcntl.2:136
#, no-wrap
msgid "B<F_GETFD> (I<void>)"
msgstr "B<F_GETFD> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:141
msgid "Read the file descriptor flags; I<arg> is ignored."
msgstr "ファイルディスクリプタフラグを読み出す。 I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:141
#, no-wrap
msgid "B<F_SETFD> (I<int>)"
msgstr "B<F_SETFD> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:145
msgid "Set the file descriptor flags to the value specified by I<arg>."
msgstr "ファイルディスクリプタフラグに I<arg> で指定した値を設定する。"

#. type: SS
#: build/C/man2/fcntl.2:145
#, no-wrap
msgid "File status flags"
msgstr "ファイル状態フラグ"

#.  or
#.  .BR creat (2),
#. type: Plain text
#: build/C/man2/fcntl.2:160
msgid ""
"Each open file description has certain associated status flags, initialized "
"by B<open>(2)  and possibly modified by B<fcntl>().  Duplicated file "
"descriptors (made with B<dup>(2), B<fcntl>(F_DUPFD), B<fork>(2), etc.) refer "
"to the same open file description, and thus share the same file status flags."
msgstr ""
"オープンファイル記述 (open file description) には、 ファイル記述毎に設定され"
"る状態フラグがいくつかある。これらのフラグは B<open>(2)  によって初期化さ"
"れ、 B<fcntl>(2)  により変更することもできる。これらは、 (B<dup>(2), B<fcntl>"
"(F_DUPFD), B<fork>(2)  などで) 複製されたファイルディスクリプタ同士は 同じ"
"オープンファイル記述を参照する。 そのため、 同じファイル状態フラグが共有され"
"る。"

#. type: Plain text
#: build/C/man2/fcntl.2:163
msgid "The file status flags and their semantics are described in B<open>(2)."
msgstr "ファイル状態フラグとその意味は B<open>(2)  で説明されている。"

#. type: TP
#: build/C/man2/fcntl.2:163
#, no-wrap
msgid "B<F_GETFL> (I<void>)"
msgstr "B<F_GETFL> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:168
msgid "Get the file access mode and the file status flags; I<arg> is ignored."
msgstr ""
"ファイルのアクセスモードとファイル状態フラグを取得する。\n"
"I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:168
#, no-wrap
msgid "B<F_SETFL> (I<int>)"
msgstr "B<F_SETFL> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:193
#, fuzzy
#| msgid ""
#| "Set the file status flags to the value specified by I<arg>.  File access "
#| "mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i."
#| "e., B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are "
#| "ignored.  On Linux this command can change only the B<O_APPEND>, "
#| "B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME>, and B<O_NONBLOCK> flags."
msgid ""
"Set the file status flags to the value specified by I<arg>.  File access "
"mode (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  and file creation flags (i.e., "
"B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  in I<arg> are ignored.  On "
"Linux this command can change only the B<O_APPEND>, B<O_ASYNC>, B<O_DIRECT>, "
"B<O_NOATIME>, and B<O_NONBLOCK> flags.  It is not possible to change the "
"B<O_DSYNC> and B<O_SYNC> flags; see BUGS, below."
msgstr ""
"ファイル状態フラグに I<arg> で指定された値を設定する。 I<arg> のうち、ファイ"
"ルのアクセスモード (B<O_RDONLY>, B<O_WRONLY>, B<O_RDWR>)  とファイル作成フラ"
"グ (すなわち B<O_CREAT>, B<O_EXCL>, B<O_NOCTTY>, B<O_TRUNC>)  に関するビット"
"は無視される。 Linux では、このコマンドで変更できるのは B<O_APPEND>, "
"B<O_ASYNC>, B<O_DIRECT>, B<O_NOATIME>, B<O_NONBLOCK> フラグだけである。"

#. type: SS
#: build/C/man2/fcntl.2:193
#, no-wrap
msgid "Advisory locking"
msgstr "アドバイザリロック"

#. type: Plain text
#: build/C/man2/fcntl.2:204
msgid ""
"B<F_SETLK>, B<F_SETLKW>, and B<F_GETLK> are used to acquire, release, and "
"test for the existence of record locks (also known as file-segment or file-"
"region locks).  The third argument, I<lock>, is a pointer to a structure "
"that has at least the following fields (in unspecified order)."
msgstr "B<F_SETLK>, B<F_SETLKW>, B<F_GETLK> は、レコードロックの獲得／解放／テストのために使用する (レコードロックはファイルセグメントロックや ファイル領域ロックとも呼ばれる)。 三番目の引き数 I<lock> は、以下に示すフィールドを含む構造体へのポインタである (フィールドの順序は関係なく、構造体に他のフィールドがあってもよい)。"

#. type: Plain text
#: build/C/man2/fcntl.2:219
#, no-wrap
msgid ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (F_GETLK only) */\n"
"    ...\n"
"};\n"
msgstr ""
"struct flock {\n"
"    ...\n"
"    short l_type;    /* Type of lock: F_RDLCK,\n"
"                        F_WRLCK, F_UNLCK */\n"
"    short l_whence;  /* How to interpret l_start:\n"
"                        SEEK_SET, SEEK_CUR, SEEK_END */\n"
"    off_t l_start;   /* Starting offset for lock */\n"
"    off_t l_len;     /* Number of bytes to lock */\n"
"    pid_t l_pid;     /* PID of process blocking our lock\n"
"                        (F_GETLK only) */\n"
"    ...\n"
"};\n"

#. type: Plain text
#: build/C/man2/fcntl.2:227
msgid ""
"The I<l_whence>, I<l_start>, and I<l_len> fields of this structure specify "
"the range of bytes we wish to lock.  Bytes past the end of the file may be "
"locked, but not bytes before the start of the file."
msgstr ""
"この構造体の I<l_whence>, I<l_start>, I<l_len> フィールドで、ロックを行いたい"
"バイト範囲を指定する。 ファイルの末尾より後ろのバイトをロックすることはできる"
"が、 ファイルの先頭より前のバイトをロックすることはできない。"

#. type: Plain text
#: build/C/man2/fcntl.2:247
msgid ""
"I<l_start> is the starting offset for the lock, and is interpreted relative "
"to either: the start of the file (if I<l_whence> is B<SEEK_SET>); the "
"current file offset (if I<l_whence> is B<SEEK_CUR>); or the end of the file "
"(if I<l_whence> is B<SEEK_END>).  In the final two cases, I<l_start> can be "
"a negative number provided the offset does not lie before the start of the "
"file."
msgstr ""
"I<l_start> はロックを行う領域の開始オフセットである。 その意味は I<l_whence> "
"により異なる: I<l_whence> が B<SEEK_SET> の場合はファイルの先頭からのオフセッ"
"ト、 I<l_whence> が B<SEEK_CUR> の場合は現在のファイルオフセットからのオフ"
"セット、 I<l_whence> が B<SEEK_END> の場合はファイルの末尾からのオフセットと"
"解釈される。 後ろの２つの場合には、 ファイルの先頭より前にならない範囲で、 "
"I<l_start> に負の値を指定することができる。"

#. type: Plain text
#: build/C/man2/fcntl.2:262
msgid ""
"I<l_len> specifies the number of bytes to be locked.  If I<l_len> is "
"positive, then the range to be locked covers bytes I<l_start> up to and "
"including I<l_start>+I<l_len>-1.  Specifying 0 for I<l_len> has the special "
"meaning: lock all bytes starting at the location specified by I<l_whence> "
"and I<l_start> through to the end of file, no matter how large the file "
"grows."
msgstr ""
"I<l_len> はロックしたいバイト数を示す。 I<l_len> が正の場合、ロックされるバイ"
"ト範囲は I<l_start> 以上 I<l_start>+I<l_len>-1 以下となる。 I<l_len> に 0 を"
"指定した場合は特別な意味を持つ: I<l_whence> and I<l_start> で指定される位置か"
"らファイルの末尾までの全てのバイトをロックする (ファイルがどんなに大きくなっ"
"たとしてもファイルの末尾までロックする)。"

#. type: Plain text
#: build/C/man2/fcntl.2:275
msgid ""
"POSIX.1-2001 allows (but does not require)  an implementation to support a "
"negative I<l_len> value; if I<l_len> is negative, the interval described by "
"I<lock> covers bytes I<l_start>+I<l_len> up to and including I<l_start>-1.  "
"This is supported by Linux since kernel versions 2.4.21 and 2.5.49."
msgstr ""
"POSIX.1-2001 では、負の値の I<l_len> をサポートする実装を認めている (必須では"
"ない)。 I<l_len> が負の場合、ロックされるバイト範囲は I<l_start>+I<l_len> 以"
"上 I<l_start>-1 以下となる。 この動作はカーネル 2.4.21 以降および 2.5.49 以降"
"の Linux で サポートされている。"

#. type: Plain text
#: build/C/man2/fcntl.2:294
msgid ""
"The I<l_type> field can be used to place a read (B<F_RDLCK>)  or a write "
"(B<F_WRLCK>)  lock on a file.  Any number of processes may hold a read lock "
"(shared lock)  on a file region, but only one process may hold a write lock "
"(exclusive lock).  An exclusive lock excludes all other locks, both shared "
"and exclusive.  A single process can hold only one type of lock on a file "
"region; if a new lock is applied to an already-locked region, then the "
"existing lock is converted to the new lock type.  (Such conversions may "
"involve splitting, shrinking, or coalescing with an existing lock if the "
"byte range specified by the new lock does not precisely coincide with the "
"range of the existing lock.)"
msgstr ""
"I<l_type> フィールドは、ファイルに対して読み出しロック (B<F_RDLCK>)  と書き込"
"みロック (B<F_WRLCK>)  のどちらを 設定するかを指定する。 ファイルのある領域に"
"対して、読み出しロック (共有ロック) を保持できる プロセス数に制限はないが、書"
"き込みロック (排他ロック) を保持できる のは一つのプロセスだけである。排他ロッ"
"クを設定すると、(共有ロックか 排他ロックにかかわらず) 他のロックは何も設定で"
"きない。 一つのプロセスは、ファイルのある領域に対して一種類のロックしか保持で"
"きない。 新規のロックがロックが設定されている領域に対して適用されると、既存の"
"ロック は新規のロックの種別に変換される (新規のロックで指定されたバイト範囲が"
"既存ロックの範囲と一致する場合以外では、 変換の過程で既存のロックの分割、縮"
"小、結合が行われることがある)。"

#. type: TP
#: build/C/man2/fcntl.2:294
#, no-wrap
msgid "B<F_SETLK> (I<struct flock *>)"
msgstr "B<F_SETLK> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:317
msgid ""
"Acquire a lock (when I<l_type> is B<F_RDLCK> or B<F_WRLCK>)  or release a "
"lock (when I<l_type> is B<F_UNLCK>)  on the bytes specified by the "
"I<l_whence>, I<l_start>, and I<l_len> fields of I<lock>.  If a conflicting "
"lock is held by another process, this call returns -1 and sets I<errno> to "
"B<EACCES> or B<EAGAIN>."
msgstr ""
"(I<l_type> が B<F_RDLCK> か B<F_WRLCK> の場合は) ロックの獲得を、 "
"(B<F_UNLCK> の場合は) ロックの解放を、 I<flock> 構造体のフィールド "
"I<l_whence>, I<l_start>, I<l_len> で指定された範囲のバイトに対して行う。 指定"
"されたロックが他のプロセスが設定しているロックと衝突する場合は、 -1 を返し、 "
"I<errno> に B<EACCES> か B<EAGAIN> を設定する。"

#. type: TP
#: build/C/man2/fcntl.2:317
#, no-wrap
msgid "B<F_SETLKW> (I<struct flock *>)"
msgstr "B<F_SETLKW> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:331
msgid ""
"As for B<F_SETLK>, but if a conflicting lock is held on the file, then wait "
"for that lock to be released.  If a signal is caught while waiting, then the "
"call is interrupted and (after the signal handler has returned)  returns "
"immediately (with return value -1 and I<errno> set to B<EINTR>; see B<signal>"
"(7))."
msgstr ""
"B<F_SETLK> と同様だが、こちらではそのファイルに対して衝突するロックが 適用さ"
"れていた場合に、そのロックが解放されるのを待つ点が異なる。 待っている間にシグ"
"ナルを受けた場合は、システムコールは中断され、 (シグナルハンドラが戻った直後"
"に) 返り値 -1 を返す (また I<errno> に B<EINTR> が設定される; B<signal>(7)  "
"参照)。"

#. type: TP
#: build/C/man2/fcntl.2:331
#, no-wrap
msgid "B<F_GETLK> (I<struct flock *>)"
msgstr "B<F_GETLK> (I<struct flock *>)"

#. type: Plain text
#: build/C/man2/fcntl.2:358
#, fuzzy
#| msgid ""
#| "On input to this call, I<lock> describes a lock we would like to place on "
#| "the file.  If the lock could be placed, B<fcntl>()  does not actually "
#| "place it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and "
#| "leaves the other fields of the structure unchanged.  If one or more "
#| "incompatible locks would prevent this lock being placed, then B<fcntl>()  "
#| "returns details about one of these locks in the I<l_type>, I<l_whence>, "
#| "I<l_start>, and I<l_len> fields of I<lock> and sets I<l_pid> to be the "
#| "PID of the process holding that lock."
msgid ""
"On input to this call, I<lock> describes a lock we would like to place on "
"the file.  If the lock could be placed, B<fcntl>()  does not actually place "
"it, but returns B<F_UNLCK> in the I<l_type> field of I<lock> and leaves the "
"other fields of the structure unchanged.  If one or more incompatible locks "
"would prevent this lock being placed, then B<fcntl>()  returns details about "
"one of these locks in the I<l_type>, I<l_whence>, I<l_start>, and I<l_len> "
"fields of I<lock> and sets I<l_pid> to be the PID of the process holding "
"that lock.  Note that the information returned by B<F_GETLK> may already be "
"out of date by the time the caller inspects it."
msgstr ""
"このコールの呼び出し時には、 I<lock> にはそのファイルに適用しようとするロック"
"に関する情報が入っている。 ロックを適用できる場合には、 B<fcntl>()  は実際に"
"はロックを行わず、構造体 I<lock> の I<l_type> フィールドに B<F_UNLCK> を設定"
"し、他のフィールドは変更せずに、復帰する。 違う種別のロックが (一つもしくは複"
"数) 適用されていて ロックを適用できないような場合には、 B<fcntl>()  は、原因"
"となったロックの一つについての詳細情報を構造体 I<lock> のフィールド "
"I<l_type>, I<l_whence>, I<l_start>, I<l_len> に格納し、また I<l_pid> にロック"
"を保持しているプロセスの PID を設定して、復帰する。"

#. type: Plain text
#: build/C/man2/fcntl.2:366
msgid ""
"In order to place a read lock, I<fd> must be open for reading.  In order to "
"place a write lock, I<fd> must be open for writing.  To place both types of "
"lock, open a file read-write."
msgstr ""
"読み出しロックを適用するには、 I<fd> は読み出し用にオープンされていなければな"
"らない。 書き込みロックを適用するには、 I<fd> は書き込み用にオープンされてい"
"なければならない。 読み書き両方のロックを適用するには、読み書き両用で ファイ"
"ルをオープンしなければならない。"

#.  (Additional file descriptors referring to the same file
#.  may have been obtained by calls to
#.  .BR open "(2), " dup "(2), " dup2 "(2), or " fcntl ().)
#. type: Plain text
#: build/C/man2/fcntl.2:383
msgid ""
"As well as being removed by an explicit B<F_UNLCK>, record locks are "
"automatically released when the process terminates or if it closes I<any> "
"file descriptor referring to a file on which locks are held.  This is bad: "
"it means that a process can lose the locks on a file like I</etc/passwd> or "
"I</etc/mtab> when for some reason a library function decides to open, read "
"and close it."
msgstr ""
"レコードのロックは、 B<F_UNLCK> により明示的に削除されるだけでなく、 プロセス"
"が終了したときや、ロックが適用されているファイルを参照している ファイルディス"
"クリプタのいずれかがクローズされた場合にも解放される。 このロックの解放は自動"
"的に行われる。 この動作はまずい: あるプロセスが I</etc/passwd> や I</etc/"
"mtab> といったファイルにロックを適用しているときに、 あるライブラリ関数が何か"
"の理由で同じファイルを open, read, close すると、そのファイルへのロックが失わ"
"れることになる。"

#. type: Plain text
#: build/C/man2/fcntl.2:388
msgid ""
"Record locks are not inherited by a child created via B<fork>(2), but are "
"preserved across an B<execve>(2)."
msgstr ""
"レコードのロックは B<fork>(2)  で作成された子プロセスには継承されないが、 "
"B<execve>(2)  の前後では保存される。"

#. type: Plain text
#: build/C/man2/fcntl.2:397
msgid ""
"Because of the buffering performed by the B<stdio>(3)  library, the use of "
"record locking with routines in that package should be avoided; use B<read>"
"(2)  and B<write>(2)  instead."
msgstr ""
"B<stdio>(3)  ではバッファリングが行われるので、 stdio 関連の関数ではレコード"
"のロックの使用は回避される; 代わりに B<read>(2)  や B<write>(2)  を使用するこ"
"と。"

#. type: SS
#: build/C/man2/fcntl.2:397 build/C/man2/fcntl.2:1311
#, no-wrap
msgid "Mandatory locking"
msgstr "強制ロック (mandatory locking)"

#. type: Plain text
#: build/C/man2/fcntl.2:401
msgid ""
"(Non-POSIX.)  The above record locks may be either advisory or mandatory, "
"and are advisory by default."
msgstr ""
"上述のロックにはアドバイザリロック (advisory lock) と強制ロック (mandatory "
"lock) の二種類があるが、デフォルトではアドバイザリロックとなる。"

#. type: Plain text
#: build/C/man2/fcntl.2:404
msgid ""
"Advisory locks are not enforced and are useful only between cooperating "
"processes."
msgstr ""
"アドバイザリロックに強制力はなく、協調して動作するプロセス間でのみ 有効であ"
"る。"

#. type: Plain text
#: build/C/man2/fcntl.2:423
msgid ""
"Mandatory locks are enforced for all processes.  If a process tries to "
"perform an incompatible access (e.g., B<read>(2)  or B<write>(2))  on a file "
"region that has an incompatible mandatory lock, then the result depends upon "
"whether the B<O_NONBLOCK> flag is enabled for its open file description.  If "
"the B<O_NONBLOCK> flag is not enabled, then system call is blocked until the "
"lock is removed or converted to a mode that is compatible with the access.  "
"If the B<O_NONBLOCK> flag is enabled, then the system call fails with the "
"error B<EAGAIN>."
msgstr ""
"強制ロックは全てのプロセスに対して効果がある。 あるプロセスが互換性のない強制"
"ロックが適用されたファイル領域に対して (B<read>(2)  や B<write>(2)  により) "
"互換性のないアクセスを実行しようとした場合、 アクセスの結果は そのファイルの"
"オープンファイル記述で B<O_NONBLOCK> フラグが有効になっているかにより決ま"
"る。 B<O_NONBLOCK> フラグが有効になっていないときは、ロックが削除されるか、 "
"ロックがアクセスと互換性のあるモードに変換されるまで、 システムコールは停止 "
"(block) される。 B<O_NONBLOCK> フラグが有効になっているときは、システムコール"
"はエラー B<EAGAIN> で失敗する。"

#. type: Plain text
#: build/C/man2/fcntl.2:440
msgid ""
"To make use of mandatory locks, mandatory locking must be enabled both on "
"the filesystem that contains the file to be locked, and on the file itself.  "
"Mandatory locking is enabled on a filesystem using the \"-o mand\" option to "
"B<mount>(8), or the B<MS_MANDLOCK> flag for B<mount>(2).  Mandatory locking "
"is enabled on a file by disabling group execute permission on the file and "
"enabling the set-group-ID permission bit (see B<chmod>(1)  and B<chmod>(2))."
msgstr ""
"強制ロックを使用するためには、ロック対象のファイルが含まれるファイルシステム "
"と、ロック対象のファイル自身の両方について、強制ロックが有効になっていなけれ "
"ばならない。ファイルシステムについて強制ロックを有効にするには、 B<mount>"
"(8)  に \"-o mand\" オプションを渡すか、 B<mount>(2)  に B<MS_MANDLOCK> フラ"
"グを指定する。ファイルについて強制ロックを有効にするには、 そのファイルのグ"
"ループ実行許可 (group execute permission) を無効とし、 かつ set-group-ID 許可"
"ビットを有効にする (B<chmod>(1)  と B<chmod>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/fcntl.2:443
msgid ""
"The Linux implementation of mandatory locking is unreliable.  See BUGS below."
msgstr ""
"Linux の強制ロックの実装は信頼性に欠けるものである。 下記の「バグ」の節を参照"
"のこと。"

#. type: SS
#: build/C/man2/fcntl.2:443
#, no-wrap
msgid "Managing signals"
msgstr "シグナルの管理"

#. type: Plain text
#: build/C/man2/fcntl.2:452
msgid ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG> and "
"B<F_SETSIG> are used to manage I/O availability signals:"
msgstr ""
"B<F_GETOWN>, B<F_SETOWN>, B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, "
"B<F_SETSIG> は、I/O が利用可能になったことを示すシグナルを管理するために使用"
"される。"

#. type: TP
#: build/C/man2/fcntl.2:452
#, no-wrap
msgid "B<F_GETOWN> (I<void>)"
msgstr "B<F_GETOWN> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:465
msgid ""
"Return (as the function result)  the process ID or process group currently "
"receiving B<SIGIO> and B<SIGURG> signals for events on file descriptor "
"I<fd>.  Process IDs are returned as positive values; process group IDs are "
"returned as negative values (but see BUGS below).  I<arg> is ignored."
msgstr ""
"ファイルディスクリプタ I<fd> のイベントに対するシグナル B<SIGIO> および "
"B<SIGURG> を受けているプロセスのプロセスID かプロセスグループを (関数の結果と"
"して) 返す。 プロセスID は正の値として返される。 プロセスグループID は負の値"
"として返される (下記のバグの章を参照)。 I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:465
#, no-wrap
msgid "B<F_SETOWN> (I<int>)"
msgstr "B<F_SETOWN> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:482
msgid ""
"Set the process ID or process group ID that will receive B<SIGIO> and "
"B<SIGURG> signals for events on file descriptor I<fd> to the ID given in "
"I<arg>.  A process ID is specified as a positive value; a process group ID "
"is specified as a negative value.  Most commonly, the calling process "
"specifies itself as the owner (that is, I<arg> is specified as B<getpid>(2))."
msgstr ""
"ファイルディスクリプタ I<fd> のイベント発生を知らせるシグナル B<SIGIO> や "
"B<SIGURG> を受けるプロセスの プロセス ID またはプロセスグループID を I<arg> "
"で指定された ID に設定する。 プロセスID は正の値として指定し、 プロセスグルー"
"プID は負の値として指定する。 ほとんどの場合、呼び出し元プロセスは所有者とし"
"て自分自身を指定する (つまり I<arg> に B<getpid>(2)  を指定する)。"

#.  From glibc.info:
#. type: Plain text
#: build/C/man2/fcntl.2:499
msgid ""
"If you set the B<O_ASYNC> status flag on a file descriptor by using the "
"B<F_SETFL> command of B<fcntl>(), a B<SIGIO> signal is sent whenever input "
"or output becomes possible on that file descriptor.  B<F_SETSIG> can be used "
"to obtain delivery of a signal other than B<SIGIO>.  If this permission "
"check fails, then the signal is silently discarded."
msgstr ""
"B<fcntl>()  の B<F_SETFL> コマンドを使用してファイルディスクリプタに "
"B<O_ASYNC> 状態フラグを設定した場合には、そのファイルディスクリプタへの 入出"
"力が可能になる度に B<SIGIO> シグナルが送られる。 B<F_SETSIG> は B<SIGIO> 以外"
"の別のシグナルの配送を受けられるように するのにも使うことができる。 許可 "
"(permission) のチェックで失敗した場合には、 シグナルは黙って捨てられる。"

#. type: Plain text
#: build/C/man2/fcntl.2:507
msgid ""
"Sending a signal to the owner process (group) specified by B<F_SETOWN> is "
"subject to the same permissions checks as are described for B<kill>(2), "
"where the sending process is the one that employs B<F_SETOWN> (but see BUGS "
"below)."
msgstr ""
"B<F_SETOWN> により指定された所有者のプロセス (またはプロセスグループ) に シグ"
"ナルを送る際には、 B<kill>(2)  に書かれているのと同じ許可のチェックが行われ"
"る。 このとき、シグナルを送信するプロセスは B<F_SETOWN> を使ったプロセスであ"
"る (但し、下記の「バグ」の章を参照のこと)。"

#.  The following appears to be rubbish.  It doesn't seem to
#.  be true according to the kernel source, and I can write
#.  a program that gets a terminal-generated SIGIO even though
#.  it is not the foreground process group of the terminal.
#.  -- MTK, 8 Apr 05
#.  If the file descriptor
#.  .I fd
#.  refers to a terminal device, then SIGIO
#.  signals are sent to the foreground process group of the terminal.
#. type: Plain text
#: build/C/man2/fcntl.2:531
msgid ""
"If the file descriptor I<fd> refers to a socket, B<F_SETOWN> also selects "
"the recipient of B<SIGURG> signals that are delivered when out-of-band data "
"arrives on that socket.  (B<SIGURG> is sent in any situation where B<select>"
"(2)  would report the socket as having an \"exceptional condition\".)"
msgstr ""
"ファイルディスクリプタがソケットを参照している場合は、 B<F_SETOWN> を使用し"
"て、ソケットに帯域外 (out-of-band) データが届いた時に B<SIGURG> シグナルを配"
"送する相手を選択することもできる (B<SIGURG> が送られた場合には B<select>(2)  "
"がソケットが「特別な状態」にあると報告することだろう)。"

#. type: Plain text
#: build/C/man2/fcntl.2:534
msgid ""
"The following was true in 2.6.x kernels up to and including kernel 2.6.11:"
msgstr "バージョン 2.6.11 以前の 2.6.x カーネルでは、以下に示す動作であった。"

#.  The relevant place in the (2.6) kernel source is the
#.  'switch' in fs/fcntl.c::send_sigio_to_task() -- MTK, Apr 2005
#.  send_sigurg()/send_sigurg_to_task() bypasses
#.  kill_fasync()/send_sigio()/send_sigio_to_task()
#.  to directly call send_group_sig_info()
#. 	-- MTK, Apr 2005 (kernel 2.6.11)
#. type: Plain text
#: build/C/man2/fcntl.2:574
msgid ""
"If a nonzero value is given to B<F_SETSIG> in a multithreaded process "
"running with a threading library that supports thread groups (e.g., NPTL), "
"then a positive value given to B<F_SETOWN> has a different meaning: instead "
"of being a process ID identifying a whole process, it is a thread ID "
"identifying a specific thread within a process.  Consequently, it may be "
"necessary to pass B<F_SETOWN> the result of B<gettid>(2)  instead of "
"B<getpid>(2)  to get sensible results when B<F_SETSIG> is used.  (In current "
"Linux threading implementations, a main thread's thread ID is the same as "
"its process ID.  This means that a single-threaded program can equally use "
"B<gettid>(2)  or B<getpid>(2)  in this scenario.)  Note, however, that the "
"statements in this paragraph do not apply to the B<SIGURG> signal generated "
"for out-of-band data on a socket: this signal is always sent to either a "
"process or a process group, depending on the value given to B<F_SETOWN>."
msgstr ""
"スレッドグループをサポートしているスレッドライブラリ (例えば NPTL) を 使って"
"動作しているマルチスレッドプロセスで B<F_SETSIG> に 0 以外の値を指定した場"
"合、 B<F_SETOWN> に正の値を渡すと、その意味が違ってくる: プロセス全体を示すプ"
"ロセスID ではなく、プロセス内の特定の スレッドを示すスレッドID と解釈され"
"る。 したがって、 B<F_SETSIG> を使う場合には、きちんと結果を受け取るには、 "
"B<F_SETOWN> に渡す値を B<getpid>(2)  ではなく B<gettid>(2)  の返り値にする必"
"要があるだろう。 (現状の Linux スレッド実装では、メインスレッドのスレッドID "
"は そのスレッドのプロセスID と同じである。つまり、 シグナルスレッドのプログラ"
"ムではこの場合 B<gettid>(2)  と B<getpid>(2)  は全く同じように使うことができ"
"る。)  ただし、注意すべき点として、この段落で述べたことは、 ソケットの帯域外"
"データが届いたときに生成される B<SIGURG> シグナルにはあてはまらない。 このシ"
"グナルは常にプロセスかプロセスグループに送られ、 送信先は B<F_SETOWN> に渡さ"
"れた値にしたがって決められる。"

#. type: Plain text
#: build/C/man2/fcntl.2:585
msgid ""
"The above behavior was accidentally dropped in Linux 2.6.12, and won't be "
"restored.  From Linux 2.6.32 onward, use B<F_SETOWN_EX> to target B<SIGIO> "
"and B<SIGURG> signals at a particular thread."
msgstr ""
"上記の動作は、Linux 2.6.12 で図らずも削除され、 元に戻されない予定である。 "
"Linux 2.6.32 以降で、特定のスレッド宛にシグナル B<SIGIO> と B<SIGURG> を送る"
"には B<F_SETOWN_EX> を使うこと。"

#. type: TP
#: build/C/man2/fcntl.2:585
#, no-wrap
msgid "B<F_GETOWN_EX> (struct f_owner_ex *) (since Linux 2.6.32)"
msgstr "B<F_GETOWN_EX> (struct f_owner_ex *) (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:594
msgid ""
"Return the current file descriptor owner settings as defined by a previous "
"B<F_SETOWN_EX> operation.  The information is returned in the structure "
"pointed to by I<arg>, which has the following form:"
msgstr ""
"直前の B<F_SETOWN_EX> 操作で定義された現在のファイルディスクリプタの所有者設"
"定 を返す。情報は I<arg> が指す構造体に格納されて返される。構造体は以下の通り"
"である。"

#. type: Plain text
#: build/C/man2/fcntl.2:601
#, no-wrap
msgid ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"
msgstr ""
"struct f_owner_ex {\n"
"    int   type;\n"
"    pid_t pid;\n"
"};\n"

#. type: Plain text
#: build/C/man2/fcntl.2:618
msgid ""
"The I<type> field will have one of the values B<F_OWNER_TID>, "
"B<F_OWNER_PID>, or B<F_OWNER_PGRP>.  The I<pid> field is a positive integer "
"representing a thread ID, process ID, or process group ID.  See "
"B<F_SETOWN_EX> for more details."
msgstr ""
"I<type> フィールドは、 B<F_OWNER_TID ,> B<F_OWNER_PID ,> B<F_OWNER_PGRP> のい"
"ずれか一つの値となる。 I<pid> フィールドは、スレッド ID、プロセス ID、プロセ"
"スグループ ID を 表す正の整数である。詳細は B<F_SETOWN_EX> を参照。"

#. type: TP
#: build/C/man2/fcntl.2:618
#, no-wrap
msgid "B<F_SETOWN_EX> (struct f_owner_ex *) (since Linux 2.6.32)"
msgstr "B<F_SETOWN_EX> (struct f_owner_ex *) (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:634
msgid ""
"This operation performs a similar task to B<F_SETOWN>.  It allows the caller "
"to direct I/O availability signals to a specific thread, process, or process "
"group.  The caller specifies the target of signals via I<arg>, which is a "
"pointer to a I<f_owner_ex> structure.  The I<type> field has one of the "
"following values, which define how I<pid> is interpreted:"
msgstr ""
"この操作は B<F_SETOWN> と同様の処理を行う。 この操作を使うと、I/O が利用可能"
"になったことを示すシグナルを、 特定のスレッド、プロセス、プロセスグループに送"
"ることができる ようになる。 呼び出し元は、 I<arg> 経由でシグナルの配送先を指"
"定する。 I<arg> は I<f_owner_ex> 構造体へのポインタである。 I<type> フィール"
"ドは以下のいずれかの値を取り、 この値により I<pid> がどのように解釈されるかが"
"規定される。"

#. type: TP
#: build/C/man2/fcntl.2:635
#, no-wrap
msgid "B<F_OWNER_TID>"
msgstr "B<F_OWNER_TID>"

#. type: Plain text
#: build/C/man2/fcntl.2:644
msgid ""
"Send the signal to the thread whose thread ID (the value returned by a call "
"to B<clone>(2)  or B<gettid>(2))  is specified in I<pid>."
msgstr ""
"スレッド ID が I<pid> で指定された値のスレッドにそのシグナルを送る (スレッド "
"ID は B<clone>(2)  や B<gettid>(2)  の呼び出しで返される値である)。"

#. type: TP
#: build/C/man2/fcntl.2:644
#, no-wrap
msgid "B<F_OWNER_PID>"
msgstr "B<F_OWNER_PID>"

#. type: Plain text
#: build/C/man2/fcntl.2:649
msgid "Send the signal to the process whose ID is specified in I<pid>."
msgstr "ID が I<pid> で指定された値のプロセスにそのシグナルを送る。"

#. type: TP
#: build/C/man2/fcntl.2:649
#, no-wrap
msgid "B<F_OWNER_PGRP>"
msgstr "B<F_OWNER_PGRP>"

#. type: Plain text
#: build/C/man2/fcntl.2:657
msgid ""
"Send the signal to the process group whose ID is specified in I<pid>.  (Note "
"that, unlike with B<F_SETOWN>, a process group ID is specified as a positive "
"value here.)"
msgstr ""
"ID が I<pid> で指定された値のプロセスグループにそのシグナルを送る。 "
"(B<F_SETOWN> と異なり、プロセスグループ ID には正の値を指定する点に注意するこ"
"と。)"

#. type: TP
#: build/C/man2/fcntl.2:658
#, no-wrap
msgid "B<F_GETSIG> (I<void>)"
msgstr "B<F_GETSIG> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:673
msgid ""
"Return (as the function result)  the signal sent when input or output "
"becomes possible.  A value of zero means B<SIGIO> is sent.  Any other value "
"(including B<SIGIO>)  is the signal sent instead, and in this case "
"additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>.  I<arg> is ignored."
msgstr ""
"入力や出力が可能になった場合に送るシグナルを (関数の結果として) 返す。 値ゼロ"
"は B<SIGIO> を送ることを意味する。 (B<SIGIO> を含む) 他の値はいずれも、 "
"B<SIGIO> の代わりに送るシグナル番号を表す。 後者の場合、シグナルハンドラを "
"B<SA_SIGINFO> フラグ付きで設定すれば、ハンドラで追加の情報を得ることができ"
"る。 I<arg> は無視される。"

#. type: TP
#: build/C/man2/fcntl.2:673
#, no-wrap
msgid "B<F_SETSIG> (I<int>)"
msgstr "B<F_SETSIG> (I<int>)"

#.  The following was true only up until 2.6.11:
#.  Additionally, passing a nonzero value to
#.  .B F_SETSIG
#.  changes the signal recipient from a whole process to a specific thread
#.  within a process.
#.  See the description of
#.  .B F_SETOWN
#.  for more details.
#. type: Plain text
#: build/C/man2/fcntl.2:696
msgid ""
"Set the signal sent when input or output becomes possible to the value given "
"in I<arg>.  A value of zero means to send the default B<SIGIO> signal.  Any "
"other value (including B<SIGIO>)  is the signal to send instead, and in this "
"case additional info is available to the signal handler if installed with "
"B<SA_SIGINFO>."
msgstr ""
"入力や出力が可能になった場合に送るシグナルを I<arg> に指定された値に設定す"
"る。 値ゼロは B<SIGIO> を送ることを意味する。 (B<SIGIO> を含む) 他の値はいず"
"れも、 B<SIGIO> の代わりに送るシグナル番号を表す。 後者の場合、シグナルハンド"
"ラを B<SA_SIGINFO> フラグ付きで設定すれば、 ハンドラで追加の情報を得ることが"
"できる。"

#. type: Plain text
#: build/C/man2/fcntl.2:724
msgid ""
"By using B<F_SETSIG> with a nonzero value, and setting B<SA_SIGINFO> for the "
"signal handler (see B<sigaction>(2)), extra information about I/O events is "
"passed to the handler in a I<siginfo_t> structure.  If the I<si_code> field "
"indicates the source is B<SI_SIGIO>, the I<si_fd> field gives the file "
"descriptor associated with the event.  Otherwise, there is no indication "
"which file descriptors are pending, and you should use the usual mechanisms "
"(B<select>(2), B<poll>(2), B<read>(2)  with B<O_NONBLOCK> set etc.) to "
"determine which file descriptors are available for I/O."
msgstr ""
"B<F_SETSIG> にゼロ以外の値を設定し、シグナルハンドラに B<SA_SIGINFO> フラグを"
"設定すると、 (B<sigaction>(2)  を参照) I/O イベントに関する追加の情報が "
"I<siginfo_t> 構造体でシグナルハンドラへ渡される。 I<si_code> フィールドが示す"
"シグナルの原因が B<SI_SIGIO> である場合、 I<si_fd> フィールドにはイベントに対"
"応するファイルディスクリプタが入っている。 それ以外の場合は、どのファイルディ"
"スクリプタが利用可能かを示す情報は ないので、どのファイルディスクリプタで I/"
"O が可能かを判断するためには 通常の機構 (B<select>(2), B<poll>(2), "
"B<O_NONBLOCK> を設定した B<read>(2)  など) を使用しなければならない。"

#. type: Plain text
#: build/C/man2/fcntl.2:733
msgid ""
"By selecting a real time signal (value E<gt>= B<SIGRTMIN>), multiple I/O "
"events may be queued using the same signal numbers.  (Queuing is dependent "
"on available memory).  Extra information is available if B<SA_SIGINFO> is "
"set for the signal handler, as above."
msgstr ""
"リアルタイムシグナル (値が B<SIGRTMIN> 以上) を選択している場合は、 同じシグ"
"ナル番号を持つ複数の I/O イベントがキューに入ることがある (キューに入れるかど"
"うかは利用可能なメモリに依存している)。 上記と同様、 B<SA_SIGINFO> が設定され"
"ている場合、シグナルハンドラのための追加の情報が得られる。"

#.  See fs/fcntl.c::send_sigio_to_task() (2.4/2.6) sources -- MTK, Apr 05
#. type: Plain text
#: build/C/man2/fcntl.2:746
msgid ""
"Note that Linux imposes a limit on the number of real-time signals that may "
"be queued to a process (see B<getrlimit>(2)  and B<signal>(7))  and if this "
"limit is reached, then the kernel reverts to delivering B<SIGIO>, and this "
"signal is delivered to the entire process rather than to a specific thread."
msgstr ""
"以下の点に注意すること。 Linux では一つのプロセスに対してキューに入れられるリ"
"アルタイム シグナルの数に上限が設けられており (B<getrlimit>(2)  と B<signal>"
"(7)  を参照)、この上限に達するとカーネルは B<SIGIO> シグナルを配送する。この "
"B<SIGIO> シグナルは、指定されたスレッドではなくプロセス全体に送られる。"

#. type: Plain text
#: build/C/man2/fcntl.2:753
msgid ""
"Using these mechanisms, a program can implement fully asynchronous I/O "
"without using B<select>(2)  or B<poll>(2)  most of the time."
msgstr ""
"これらの機構を使用することで、ほとんどの場合で B<select>(2)  や B<poll>(2)  "
"を使用せずに完全な非同期 I/O を実装することができる。"

#. type: Plain text
#: build/C/man2/fcntl.2:777
#, fuzzy
#| msgid ""
#| "The use of B<O_ASYNC>, B<F_GETOWN>, B<F_SETOWN> is specific to BSD and "
#| "Linux.  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and B<F_SETSIG> are "
#| "Linux-specific.  POSIX has asynchronous I/O and the I<aio_sigevent> "
#| "structure to achieve similar things; these are also available in Linux as "
#| "part of the GNU C Library (Glibc)."
msgid ""
"The use of B<O_ASYNC> is specific to BSD and Linux.  The only use of "
"B<F_GETOWN> and B<F_SETOWN> specified in POSIX.1 is in conjunction with the "
"use of the B<SIGURG> signal on sockets.  (POSIX does not specify the "
"B<SIGIO> signal.)  B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, and "
"B<F_SETSIG> are Linux-specific.  POSIX has asynchronous I/O and the "
"I<aio_sigevent> structure to achieve similar things; these are also "
"available in Linux as part of the GNU C Library (Glibc)."
msgstr ""
"B<O_ASYNC>, B<F_GETOWN>, B<F_SETOWN> の使用は BSD と Linux に特有である。 "
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_GETSIG>, B<F_SETSIG> は Linux 固有であ"
"る。POSIX には、同様のことを行うために、非同期 I/O と I<aio_sigevent> 構造体"
"がある。Linux では、GNU C ライブラリ (Glibc) の一部として これらも利用可能で"
"ある。"

#. type: SS
#: build/C/man2/fcntl.2:777
#, no-wrap
msgid "Leases"
msgstr "リース (leases)"

#. type: Plain text
#: build/C/man2/fcntl.2:792
msgid ""
"B<F_SETLEASE> and B<F_GETLEASE> (Linux 2.4 onward) are used (respectively) "
"to establish a new lease, and retrieve the current lease, on the open file "
"description referred to by the file descriptor I<fd>.  A file lease provides "
"a mechanism whereby the process holding the lease (the \"lease holder\") is "
"notified (via delivery of a signal)  when a process (the \"lease breaker\") "
"tries to B<open>(2)  or B<truncate>(2)  the file referred to by that file "
"descriptor."
msgstr ""
"(Linix 2.4 以降で利用可能)  B<F_SETLEASE> は、 I<fd> が参照するオープンファイ"
"ル記述に対して新しいリースを設定するのに使用される。 B<F_GETLEASE> は、 "
"I<fd> が参照するオープンファイル記述に対して設定されている 現在のリースを取得"
"するのに使用される。 ファイルのリースにより、 あるプロセス (\"lease breaker"
"\") がそのファイルディスクリプタが参照 しているファイルに対して B<open>(2)  "
"や B<truncate>(2)  を行おうとした際に、リースを保持しているプロセス (\"lease "
"holder\") へ (シグナルの配送による) 通知が行われるという機構が提供される。"

#. type: TP
#: build/C/man2/fcntl.2:792
#, no-wrap
msgid "B<F_SETLEASE> (I<int>)"
msgstr "B<F_SETLEASE> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:797
msgid ""
"Set or remove a file lease according to which of the following values is "
"specified in the integer I<arg>:"
msgstr ""
"I<arg> の内容に基いてファイルのリースの設定、削除を行う。整数 I<arg> には以下"
"の値が指定できる:"

#. type: TP
#: build/C/man2/fcntl.2:798
#, no-wrap
msgid "B<F_RDLCK>"
msgstr "B<F_RDLCK>"

#.  The following became true in kernel 2.6.10:
#.  See the man-pages-2.09 Changelog for further info.
#. type: Plain text
#: build/C/man2/fcntl.2:807
msgid ""
"Take out a read lease.  This will cause the calling process to be notified "
"when the file is opened for writing or is truncated.  A read lease can be "
"placed only on a file descriptor that is opened read-only."
msgstr ""
"読み出しリースを取得する。これにより、 そのファイルが書き込み用にオープンされ"
"たり、ファイルが切り詰められた場合に、 呼び出し元のプロセスに通知が行われるよ"
"うになる。 読み出しリースを設定できるのは、読み出し専用でオープンされている "
"ファイルディスクリプタに対してのみである。"

#. type: TP
#: build/C/man2/fcntl.2:807
#, no-wrap
msgid "B<F_WRLCK>"
msgstr "B<F_WRLCK>"

#. type: Plain text
#: build/C/man2/fcntl.2:814
msgid ""
"Take out a write lease.  This will cause the caller to be notified when the "
"file is opened for reading or writing or is truncated.  A write lease may be "
"placed on a file only if there are no other open file descriptors for the "
"file."
msgstr ""
"書き込みリースを取得する。これにより、 (読み出し用か書き込み用にかかわらず) "
"そのファイルがオープンされたり、 ファイルが切り詰められた場合に、呼び出し元の"
"プロセスに通知が行われるようになる。 書き込みリースは、そのファイルに対する"
"オープンされたファイルディスクリプタが 他にない場合にのみ設定できる。"

#. type: TP
#: build/C/man2/fcntl.2:814
#, no-wrap
msgid "B<F_UNLCK>"
msgstr "B<F_UNLCK>"

#. type: Plain text
#: build/C/man2/fcntl.2:817
msgid "Remove our lease from the file."
msgstr "そのファイルからリースを削除する。"

#. type: Plain text
#: build/C/man2/fcntl.2:831
msgid ""
"Leases are associated with an open file description (see B<open>(2)).  This "
"means that duplicate file descriptors (created by, for example, B<fork>(2)  "
"or B<dup>(2))  refer to the same lease, and this lease may be modified or "
"released using any of these descriptors.  Furthermore, the lease is released "
"by either an explicit B<F_UNLCK> operation on any of these duplicate "
"descriptors, or when all such descriptors have been closed."
msgstr ""
"リースはオープンファイル記述に対して関連付けられる (B<open>(2)  参照)。 つま"
"り、 (B<fork>(2)  や B<dup>(2)  などにより作成された) ファイルディスクリプタ"
"の複製は同じリースを参照し、 複製も含めたどのファイルディスクリプタを使っても"
"このリースを変更したり 解放したりできる。 また、これらのファイルディスクリプ"
"タのいずれかに対して B<F_UNLCK> 操作が明示的に実行された場合や、すべてのファ"
"イルディスクリプタが 閉じられた場合にも、リースは解放される。"

#. type: Plain text
#: build/C/man2/fcntl.2:838
msgid ""
"Leases may be taken out only on regular files.  An unprivileged process may "
"take out a lease only on a file whose UID (owner) matches the filesystem UID "
"of the process.  A process with the B<CAP_LEASE> capability may take out "
"leases on arbitrary files."
msgstr ""
"リースの取得は通常のファイル (regular file) に対してのみ可能である。 非特権プ"
"ロセスがリースを取得できるのは、UID (所有者) がプロセスの ファイルシステム "
"UID と一致するファイルに対してだけである。 B<CAP_LEASE> ケーパビリティを持つ"
"プロセスは任意のファイルに対してリースを取得できる。"

#. type: TP
#: build/C/man2/fcntl.2:838
#, no-wrap
msgid "B<F_GETLEASE> (I<void>)"
msgstr "B<F_GETLEASE> (I<void>)"

#. type: Plain text
#: build/C/man2/fcntl.2:847
msgid ""
"Indicates what type of lease is associated with the file descriptor I<fd> by "
"returning either B<F_RDLCK>, B<F_WRLCK>, or B<F_UNLCK>, indicating, "
"respectively, a read lease , a write lease, or no lease.  I<arg> is ignored."
msgstr ""
"ファイルディスクリプタ I<fd> に対して設定されているリースの種別を取得する。 "
"B<F_RDLCK>, B<F_WRLCK>, B<F_UNLCK> のいずれかが返される。 B<F_RDLCK>, "
"B<F_WRLCK> はそれぞれ、読み出しリース、書き込みリースが設定されていることを示"
"し、 B<F_UNLCK> はリースが何も設定されていないことを示す。 I<arg> は無視され"
"る。"

#. type: Plain text
#: build/C/man2/fcntl.2:878
msgid ""
"When a process (the \"lease breaker\") performs an B<open>(2)  or B<truncate>"
"(2)  that conflicts with a lease established via B<F_SETLEASE>, the system "
"call is blocked by the kernel and the kernel notifies the lease holder by "
"sending it a signal (B<SIGIO> by default).  The lease holder should respond "
"to receipt of this signal by doing whatever cleanup is required in "
"preparation for the file to be accessed by another process (e.g., flushing "
"cached buffers) and then either remove or downgrade its lease.  A lease is "
"removed by performing an B<F_SETLEASE> command specifying I<arg> as "
"B<F_UNLCK>.  If the lease holder currently holds a write lease on the file, "
"and the lease breaker is opening the file for reading, then it is sufficient "
"for the lease holder to downgrade the lease to a read lease.  This is done "
"by performing an B<F_SETLEASE> command specifying I<arg> as B<F_RDLCK>."
msgstr ""
"あるプロセス (\"lease breaker\") が B<F_SETLEASE> で設定されたリースと矛\n"
"盾するような B<open>(2) や B<truncate>(2) を実行した場合、 そのシステム\n"
"コールはカーネルによって停止され、 カーネルは lease holder にシグナル\n"
"(デフォルトでは B<SIGIO>) を送って通知を行う。 lease holder はこのシグ\n"
"ナルを受信したときにはきちんと対応すべきである。 具体的には、別のプロセ\n"
"スがそのファイルにアクセスするための準備として 必要な後片付け (例えば、\n"
"キャッシュされたバッファのフラッシュ) を すべて行ってから、そのファイル\n"
"のリースの削除または格下げを行う。リースを削除をするには、 I<arg> に\n"
"B<F_UNLCK> を指定して B<F_SETLEASE> を実行する。lease holder がファイル\n"
"に書き込みリースを保持していて、 lease breaker が読み出し用にそのファイ\n"
"ルをオープンしている場合、 lease holder が保持しているリースを読み出し\n"
"リースに格下げすれば 十分である。これをするには、 I<arg> に B<F_RDLCK>\n"
"を指定して B<F_SETLEASE> を実行する。"

#. type: Plain text
#: build/C/man2/fcntl.2:883
msgid ""
"If the lease holder fails to downgrade or remove the lease within the number "
"of seconds specified in I</proc/sys/fs/lease-break-time> then the kernel "
"forcibly removes or downgrades the lease holder's lease."
msgstr ""
"lease holder が I</proc/sys/fs/lease-break-time> で指定された秒数以内にリース"
"の格下げか削除を行えなかった場合、 カーネルは強制的にその lease holder のリー"
"スを削除もしくは格下げを行う。"

#. type: Plain text
#: build/C/man2/fcntl.2:893
msgid ""
"Once a lease break has been initiated, B<F_GETLEASE> returns the target "
"lease type (either B<F_RDLCK> or B<F_UNLCK>, depending on what would be "
"compatible with the lease breaker)  until the lease holder voluntarily "
"downgrades or removes the lease or the kernel forcibly does so after the "
"lease break timer expires."
msgstr ""
"いったん lease break が開始されると、 lease holder が自発的にそのリース\n"
"の格下げか削除を行うか、lease break timer の満了後にカーネルが強制的に\n"
"リースの格下げか削除を行うまで、 B<F_GETLEASE> は対象となるリースの型を\n"
"返す (リースの型は B<F_RDLCK> か B<F_UNLCK> のどちらであり、lease\n"
"breaker と互換性のある型となる)。"

#. type: Plain text
#: build/C/man2/fcntl.2:897
msgid ""
"Once the lease has been voluntarily or forcibly removed or downgraded, and "
"assuming the lease breaker has not unblocked its system call, the kernel "
"permits the lease breaker's system call to proceed."
msgstr ""
"一度リースの削除か格下げが自発的もしくは強制的に行われると、 lease breaker が"
"まだシステムコールを再開していない場合には、 カーネルが lease breaker のシス"
"テムコールの続行を許可する。"

#. type: Plain text
#: build/C/man2/fcntl.2:918
msgid ""
"If the lease breaker's blocked B<open>(2)  or B<truncate>(2)  is interrupted "
"by a signal handler, then the system call fails with the error B<EINTR>, but "
"the other steps still occur as described above.  If the lease breaker is "
"killed by a signal while blocked in B<open>(2)  or B<truncate>(2), then the "
"other steps still occur as described above.  If the lease breaker specifies "
"the B<O_NONBLOCK> flag when calling B<open>(2), then the call immediately "
"fails with the error B<EWOULDBLOCK>, but the other steps still occur as "
"described above."
msgstr ""
"lease breaker が実行した B<open>(2)  や B<truncate>(2)  が停止中にシグナルハ"
"ンドラにより中断された場合、 そのシステムコールは B<EINTR> エラーで失敗する"
"が、上で述べた他の処理は そのまま行われる。 B<open>(2)  や B<truncate>(2)  が"
"停止中に lease breaker がシグナルにより kill された場合、 上で述べた他の処理"
"はそのまま行われる。 lease breaker が B<open>(2)  を呼ぶ際に B<O_NONBLOCK> フ"
"ラグを指定した場合、そのシステムコールは B<EWOULDBLOCK> エラーで直ちに失敗す"
"るが、上で述べた他の処理はそのまま行われる。"

#. type: Plain text
#: build/C/man2/fcntl.2:939
msgid ""
"The default signal used to notify the lease holder is B<SIGIO>, but this can "
"be changed using the B<F_SETSIG> command to B<fcntl>().  If a B<F_SETSIG> "
"command is performed (even one specifying B<SIGIO>), and the signal handler "
"is established using B<SA_SIGINFO>, then the handler will receive a "
"I<siginfo_t> structure as its second argument, and the I<si_fd> field of "
"this argument will hold the descriptor of the leased file that has been "
"accessed by another process.  (This is useful if the caller holds leases "
"against multiple files)."
msgstr ""
"lease holder への通知に使われるデフォルトのシグナルは B<SIGIO> だが、 "
"B<fcntl>()  の B<F_SETSIG> コマンドで変更することができる。 B<F_SETSIG> コマ"
"ンドが実行され (B<SIGIO> を指定された場合も含む)、 B<SA_SIGINFO> フラグ付きで"
"シグナルハンドラが設定されている場合には、 ハンドラの第二引き数として "
"I<siginfo_t> 構造体が渡され、この引き数の I<si_fd> フィールドには別のプロセス"
"がアクセスしたリース設定済みファイルの ディスクリプタが入っている (この機能は"
"複数のファイルに対してリースを設定する場合に有用である)。"

#. type: SS
#: build/C/man2/fcntl.2:939
#, no-wrap
msgid "File and directory change notification (dnotify)"
msgstr "ファイルやディレクトリの変更の通知 (dnotify)"

#. type: TP
#: build/C/man2/fcntl.2:940
#, no-wrap
msgid "B<F_NOTIFY> (I<int>)"
msgstr "B<F_NOTIFY> (I<int>)"

#. type: Plain text
#: build/C/man2/fcntl.2:950
msgid ""
"(Linux 2.4 onward)  Provide notification when the directory referred to by "
"I<fd> or any of the files that it contains is changed.  The events to be "
"notified are specified in I<arg>, which is a bit mask specified by ORing "
"together zero or more of the following bits:"
msgstr ""
"(Linux 2.4 以降)  I<fd> で参照されるディレクトリか、その中にあるファイルに変"
"更があった場合に 通知を行う。どのイベントを通知するかは I<arg> で指定する。 "
"I<arg> はビットマスクで、以下のビットの 0個以上の論理和をとったものを指定す"
"る。"

#. type: TP
#: build/C/man2/fcntl.2:953
#, no-wrap
msgid "B<DN_ACCESS>"
msgstr "B<DN_ACCESS>"

#. type: Plain text
#: build/C/man2/fcntl.2:956
msgid "A file was accessed (read, pread, readv)"
msgstr "ファイルへのアクセスがあった (read, pread, readv)"

#. type: TP
#: build/C/man2/fcntl.2:956
#, no-wrap
msgid "B<DN_MODIFY>"
msgstr "B<DN_MODIFY>"

#. type: Plain text
#: build/C/man2/fcntl.2:959
msgid "A file was modified (write, pwrite, writev, truncate, ftruncate)."
msgstr ""
"ファイルの内容が変更された (write, pwrite, writev, truncate, ftruncate)."

#. type: TP
#: build/C/man2/fcntl.2:959
#, no-wrap
msgid "B<DN_CREATE>"
msgstr "B<DN_CREATE>"

#. type: Plain text
#: build/C/man2/fcntl.2:962
msgid "A file was created (open, creat, mknod, mkdir, link, symlink, rename)."
msgstr ""
"ファイルが作成された (open, creat, mknod, mkdir, link, symlink, rename)."

#. type: TP
#: build/C/man2/fcntl.2:962
#, no-wrap
msgid "B<DN_DELETE>"
msgstr "B<DN_DELETE>"

#. type: Plain text
#: build/C/man2/fcntl.2:965
msgid "A file was unlinked (unlink, rename to another directory, rmdir)."
msgstr ""
"ファイルが削除 (unlink) された (unlink, 別のディレクトリへの rename, rmdir)"

#. type: TP
#: build/C/man2/fcntl.2:965
#, no-wrap
msgid "B<DN_RENAME>"
msgstr "B<DN_RENAME>"

#. type: Plain text
#: build/C/man2/fcntl.2:968
msgid "A file was renamed within this directory (rename)."
msgstr "ディレクトリ内でのファイル名の変更があった (rename)"

#. type: TP
#: build/C/man2/fcntl.2:968
#, no-wrap
msgid "B<DN_ATTRIB>"
msgstr "B<DN_ATTRIB>"

#. type: Plain text
#: build/C/man2/fcntl.2:971
msgid "The attributes of a file were changed (chown, chmod, utime[s])."
msgstr "ファイル属性が変更された (chown, chmod, utime[s])"

#. type: Plain text
#: build/C/man2/fcntl.2:979
msgid ""
"(In order to obtain these definitions, the B<_GNU_SOURCE> feature test macro "
"must be defined before including I<any> header files.)"
msgstr ""
"(上記の定義を利用するには、I<どの> ヘッダファイルをインクルードするより前"
"に、\n"
"B<_GNU_SOURCE> 機能検査マクロを定義しなければならない。)"

#. type: Plain text
#: build/C/man2/fcntl.2:987
msgid ""
"Directory notifications are normally \"one-shot\", and the application must "
"reregister to receive further notifications.  Alternatively, if "
"B<DN_MULTISHOT> is included in I<arg>, then notification will remain in "
"effect until explicitly removed."
msgstr ""
"ディレクトリの変更通知は通常「一回限り (one-shot)」であり、 アプリケーション"
"側でその後さらに通知を受信したい場合は 再登録しなければならない。 I<arg> に "
"B<DN_MULTISHOT> が含まれていた場合には、 変更通知は明示的に解除されるまで有効"
"状態が継続する。"

#.  The following does seem a poor API-design choice...
#. type: Plain text
#: build/C/man2/fcntl.2:999
msgid ""
"A series of B<F_NOTIFY> requests is cumulative, with the events in I<arg> "
"being added to the set already monitored.  To disable notification of all "
"events, make an B<F_NOTIFY> call specifying I<arg> as 0."
msgstr ""
"B<F_NOTIFY> 要求は積算されていく。つまり、 I<arg> で指定されたイベントがすで"
"にモニタされている イベント集合に加算される形になる。 すべてのイベントの通知"
"を無効にするには、 I<arg> に 0 を指定して B<F_NOTIFY> を呼び出す必要がある。"

#. type: Plain text
#: build/C/man2/fcntl.2:1017
msgid ""
"Notification occurs via delivery of a signal.  The default signal is "
"B<SIGIO>, but this can be changed using the B<F_SETSIG> command to B<fcntl>"
"().  In the latter case, the signal handler receives a I<siginfo_t> "
"structure as its second argument (if the handler was established using "
"B<SA_SIGINFO>)  and the I<si_fd> field of this structure contains the file "
"descriptor which generated the notification (useful when establishing "
"notification on multiple directories)."
msgstr ""
"通知はシグナルの配送で行われる。 デフォルトのシグナルは B<SIGIO> だが、 "
"B<fcntl>()  の B<F_SETSIG> コマンドで変更することができる。 後者の場合には、 "
"(B<SA_SIGINFO> フラグ付きでシグナルハンドラが設定されている場合には)  ハンド"
"ラの第二引き数として I<siginfo_t> 構造体が渡され、この構造体の I<si_fd> "
"フィールドには通知の行われたファイルディスクリプタが入っている (この機能は複"
"数のディレクトリに対して通知を設定する場合に有用である)。"

#. type: Plain text
#: build/C/man2/fcntl.2:1022
msgid ""
"Especially when using B<DN_MULTISHOT>, a real time signal should be used for "
"notification, so that multiple notifications can be queued."
msgstr ""
"特に B<DN_MULTISHOT> を使う場合は、通知にはリアルタイムシグナルを使うべきであ"
"る。 それは、リアルタイムシグナルを使うことで、複数の通知をキューに入れる こ"
"とができるからである。"

#. type: Plain text
#: build/C/man2/fcntl.2:1031
msgid ""
"B<NOTE:> New applications should use the I<inotify> interface (available "
"since kernel 2.6.13), which provides a much superior interface for obtaining "
"notifications of filesystem events.  See B<inotify>(7)."
msgstr ""
"B<注意:> 新しくアプリケーションを書く際には、(カーネル 2.6.13 以降で利用可能"
"となった)  I<inotify> インタフェースを使用すべきである。 I<inotify> はファイ"
"ルシステムイベントの通知を取得するための ずっと優れたインタフェースである。 "
"B<inotify>(7)  を参照。"

#. type: SS
#: build/C/man2/fcntl.2:1031
#, no-wrap
msgid "Changing the capacity of a pipe"
msgstr "パイプの容量の変更"

#. type: TP
#: build/C/man2/fcntl.2:1032
#, no-wrap
msgid "B<F_SETPIPE_SZ> (I<int>; since Linux 2.6.35)"
msgstr "B<F_SETPIPE_SZ> (I<int>; Linux 2.6.35 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1063
msgid ""
"Change the capacity of the pipe referred to by I<fd> to be at least I<arg> "
"bytes.  An unprivileged process can adjust the pipe capacity to any value "
"between the system page size and the limit defined in I</proc/sys/fs/pipe-"
"max-size> (see B<proc>(5)).  Attempts to set the pipe capacity below the "
"page size are silently rounded up to the page size.  Attempts by an "
"unprivileged process to set the pipe capacity above the limit in I</proc/sys/"
"fs/pipe-max-size> yield the error B<EPERM>; a privileged process "
"(B<CAP_SYS_RESOURCE>)  can override the limit.  When allocating the buffer "
"for the pipe, the kernel may use a capacity larger than I<arg>, if that is "
"convenient for the implementation.  The B<F_GETPIPE_SZ> operation returns "
"the actual size used.  Attempting to set the pipe capacity smaller than the "
"amount of buffer space currently used to store data produces the error "
"B<EBUSY>."
msgstr ""
"I<fd> が参照するパイプの容量を少なくとも I<arg> バイトに変更する。\n"
"非特権プロセスは、パイプの容量として、\n"
"システムのページサイズと I</proc/sys/fs/pipe-max-size> で定義される\n"
"上限値 (B<proc>(5) 参照) の間の任意の値を設定できる。\n"
"パイプの容量をページサイズよりも小さな値に設定しようとした場合は、\n"
"暗黙のうちにページサイズに切り上げられる。\n"
"非特権プロセスがパイプの容量を I</proc/sys/fs/pipe-max-size> で定義\n"
"された上限より大きな値に設定しようとした場合は、エラー B<EPERM> が\n"
"発生する。特権プロセス (B<CAP_SYS_RESOURCE> ケーパビリティを持つ\n"
"プロセス) はこの上限を上書きできる。\n"
"パイプにバッファを割り当てる場合、実装側の都合に応じて、\n"
"カーネルは I<arg> よりも大きな容量を割り当ててもよい。\n"
"B<F_GETPIPE_SZ> 操作では実際に使用されている大きさが返される。\n"
"パイプの容量を現在データを格納するのに使用されているバッファの\n"
"サイズよりも小さくしようとした場合は、エラー B<EBUSY> が発生する。"

#. type: TP
#: build/C/man2/fcntl.2:1063
#, no-wrap
msgid "B<F_GETPIPE_SZ> (I<void>; since Linux 2.6.35)"
msgstr "B<F_GETPIPE_SZ> (I<void>; Linux 2.6.35 以降)"

#. type: Plain text
#: build/C/man2/fcntl.2:1067
msgid ""
"Return (as the function result) the capacity of the pipe referred to by "
"I<fd>."
msgstr "I<fd> が参照するパイプの容量を (関数の結果として) 返す。"

#. type: Plain text
#: build/C/man2/fcntl.2:1069
msgid "For a successful call, the return value depends on the operation:"
msgstr "成功した場合の返り値は操作の種類により違う:"

#. type: TP
#: build/C/man2/fcntl.2:1069
#, no-wrap
msgid "B<F_DUPFD>"
msgstr "B<F_DUPFD>"

#. type: Plain text
#: build/C/man2/fcntl.2:1072
msgid "The new descriptor."
msgstr "新しいディスクリプタを返す。"

#. type: TP
#: build/C/man2/fcntl.2:1072
#, no-wrap
msgid "B<F_GETFD>"
msgstr "B<F_GETFD>"

#. type: Plain text
#: build/C/man2/fcntl.2:1075
msgid "Value of file descriptor flags."
msgstr "ファイルディスクリプタフラグの値"

#. type: TP
#: build/C/man2/fcntl.2:1075
#, no-wrap
msgid "B<F_GETFL>"
msgstr "B<F_GETFL>"

#. type: Plain text
#: build/C/man2/fcntl.2:1078
msgid "Value of file status flags."
msgstr "ファイル状態フラグの値"

#. type: TP
#: build/C/man2/fcntl.2:1078
#, no-wrap
msgid "B<F_GETLEASE>"
msgstr "B<F_GETLEASE>"

#. type: Plain text
#: build/C/man2/fcntl.2:1081
msgid "Type of lease held on file descriptor."
msgstr "ファイルディスクリプタに対して保持されているリースの種別を返す。"

#. type: TP
#: build/C/man2/fcntl.2:1081
#, no-wrap
msgid "B<F_GETOWN>"
msgstr "B<F_GETOWN>"

#. type: Plain text
#: build/C/man2/fcntl.2:1084
msgid "Value of descriptor owner."
msgstr "ディスクリプタの所有者を返す。"

#. type: TP
#: build/C/man2/fcntl.2:1084
#, no-wrap
msgid "B<F_GETSIG>"
msgstr "B<F_GETSIG>"

#. type: Plain text
#: build/C/man2/fcntl.2:1090
msgid ""
"Value of signal sent when read or write becomes possible, or zero for "
"traditional B<SIGIO> behavior."
msgstr ""
"読み込みや書き出しが可能になった時に送られるシグナルの値、もしくは 伝統的な "
"B<SIGIO> 動作の場合にはゼロを返す。"

#. type: TP
#: build/C/man2/fcntl.2:1090
#, no-wrap
msgid "B<F_GETPIPE_SZ>"
msgstr "B<F_GETPIPE_SZ>"

#. type: Plain text
#: build/C/man2/fcntl.2:1093
msgid "The pipe capacity."
msgstr "パイプの容量。"

#. type: TP
#: build/C/man2/fcntl.2:1093
#, no-wrap
msgid "All other commands"
msgstr "他の全てのコマンド"

#. type: Plain text
#: build/C/man2/fcntl.2:1096
msgid "Zero."
msgstr "0 を返す。"

#. type: Plain text
#: build/C/man2/fcntl.2:1100
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの時は -1 が返され、 I<errno> に適切な値が設定される。"

#. type: TP
#: build/C/man2/fcntl.2:1101 build/C/man3/lockf.3:122
#, no-wrap
msgid "B<EACCES> or B<EAGAIN>"
msgstr "B<EACCES> か B<EAGAIN>"

#. type: Plain text
#: build/C/man2/fcntl.2:1104
msgid "Operation is prohibited by locks held by other processes."
msgstr "他のプロセスが保持しているロックによって操作が禁止されている。"

#. type: TP
#: build/C/man2/fcntl.2:1104 build/C/man2/fork.2:181 build/C/man2/fork.2:186
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/fcntl.2:1108
msgid ""
"The operation is prohibited because the file has been memory-mapped by "
"another process."
msgstr ""
"そのファイルは他のプロセスによってメモリマップされているため、 操作が禁止され"
"ている。"

#. type: Plain text
#: build/C/man2/fcntl.2:1117
msgid ""
"I<fd> is not an open file descriptor, or the command was B<F_SETLK> or "
"B<F_SETLKW> and the file descriptor open mode doesn't match with the type of "
"lock requested."
msgstr ""
"I<fd> がオープンされたファイルディスクリプタでない。 あるいはコマンドが "
"B<F_SETLK> または B<F_SETLKW> だったが、対象のファイルディスクリプタのオープ"
"ンモードが 必要となるロックの型にマッチしていない。"

#. type: TP
#: build/C/man2/fcntl.2:1117 build/C/man3/lockf.3:142
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1122
msgid ""
"It was detected that the specified B<F_SETLKW> command would cause a "
"deadlock."
msgstr ""
"指定された B<F_SETLKW> コマンドを実行した場合にはデッドロックになることが検出"
"された。"

#. type: Plain text
#: build/C/man2/fcntl.2:1126
msgid "I<lock> is outside your accessible address space."
msgstr "I<lock> が利用可能なアドレス空間の外部にある。"

#. type: Plain text
#: build/C/man2/fcntl.2:1138
msgid ""
"For B<F_SETLKW>, the command was interrupted by a signal; see B<signal>(7).  "
"For B<F_GETLK> and B<F_SETLK>, the command was interrupted by a signal "
"before the lock was checked or acquired.  Most likely when locking a remote "
"file (e.g., locking over NFS), but can sometimes happen locally."
msgstr ""
"B<F_SETLKW> コマンドがシグナルにより割り込まれた (B<signal>(7)  参照)。 "
"B<F_GETLK> と B<F_SETLK> の場合、ロックを確認したり取得したりする前にシグナル"
"によって割り込まれた。 これはたいていリモートのファイルをロックする場合 (例え"
"ば NFS 上でロックする場合) に起こる。 しかしローカルでも起こる場合がある。"

#. type: Plain text
#: build/C/man2/fcntl.2:1148
msgid ""
"For B<F_DUPFD>, I<arg> is negative or is greater than the maximum allowable "
"value.  For B<F_SETSIG>, I<arg> is not an allowable signal number."
msgstr ""
"B<F_DUPFD>で、 I<arg> が負か、もしくは許される最大値よりも大きい。 "
"B<F_SETSIG> の場合、 I<arg> が利用可能なシグナル番号ではない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1153
msgid ""
"For B<F_DUPFD>, the process already has the maximum number of file "
"descriptors open."
msgstr ""
"B<F_DUPFD>で、 プロセスがすでに最大数までファイルディスクリプタをオープンして"
"いる。"

#. type: TP
#: build/C/man2/fcntl.2:1153 build/C/man2/flock.2:130 build/C/man3/lockf.3:151
#, no-wrap
msgid "B<ENOLCK>"
msgstr "B<ENOLCK>"

#. type: Plain text
#: build/C/man2/fcntl.2:1157
msgid ""
"Too many segment locks open, lock table is full, or a remote locking "
"protocol failed (e.g., locking over NFS)."
msgstr ""
"オープンされているロックの数が多過ぎて、ロックテーブルがいっぱいである。 また"
"は remote locking protocol (例えば NFS 上のロック) が失敗した。"

#. type: Plain text
#: build/C/man2/fcntl.2:1162
msgid ""
"Attempted to clear the B<O_APPEND> flag on a file that has the append-only "
"attribute set."
msgstr ""
"追加専用属性が設定されたファイルの B<O_APPEND> フラグをクリアしようと試みた。"

#. type: Plain text
#: build/C/man2/fcntl.2:1175
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  Only the operations B<F_DUPFD>, B<F_GETFD>, "
"B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, B<F_GETLK>, B<F_SETLK>, and B<F_SETLKW> "
"are specified in POSIX.1-2001."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  POSIX.1-2001 で規定されている操作は、\n"
"B<F_DUPFD>, B<F_GETFD>, B<F_SETFD>, B<F_GETFL>, B<F_SETFL>, \n"
"B<F_GETLK>, B<F_SETLK>, B<F_SETLKW> だけである。"

#. type: Plain text
#: build/C/man2/fcntl.2:1187
msgid ""
"B<F_GETOWN> and B<F_SETOWN> are specified in POSIX.1-2001.  (To get their "
"definitions, define B<BSD_SOURCE>, or B<_XOPEN_SOURCE> with the value 500 or "
"greater, or define B<_POSIX_C_SOURCE> with the value 200809L or greater.)"
msgstr ""
"B<F_GETOWN> と B<F_SETOWN> は POSIX.1-2001 で規定されている。\n"
"(これら定義するには、 B<BSD_SOURCE> を定義するか、\n"
"B<_XOPEN_SOURCE> を 500 以上の値で定義するか、\n"
"B<_POSIX_C_SOURCE> を 200809L 以上の値で定義すること。)"

#. type: Plain text
#: build/C/man2/fcntl.2:1195
msgid ""
"B<F_DUPFD_CLOEXEC> is specified in POSIX.1-2008.  (To get this definition, "
"define B<_POSIX_C_SOURCE> with the value 200809L or greater, or "
"B<_XOPEN_SOURCE> with the value 700 or greater.)"
msgstr ""
"B<F_DUPFD_CLOEXEC> は POSIX.1-2008 で規定されている。\n"
"(これら定義するには、\n"
"B<_POSIX_C_SOURCE> を 200809L 以上の値で定義するか、\n"
"B<_XOPEN_SOURCE> を 700 以上の値で定義すること。)"

#.  .PP
#.  SVr4 documents additional EIO, ENOLINK and EOVERFLOW error conditions.
#. type: Plain text
#: build/C/man2/fcntl.2:1212
msgid ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, and B<F_SETLEASE> are "
"Linux-specific.  (Define the B<_GNU_SOURCE> macro to obtain these "
"definitions.)"
msgstr ""
"B<F_GETOWN_EX>, B<F_SETOWN_EX>, B<F_SETPIPE_SZ>, B<F_GETPIPE_SZ>, "
"B<F_GETSIG>, \n"
"B<F_SETSIG>, B<F_NOTIFY>, B<F_GETLEASE>, B<F_SETLEASE> は Linux 固有である\n"
"(これらの定義を有効にするには B<_GNU_SOURCE> マクロを定義すること)。"

#. type: Plain text
#: build/C/man2/fcntl.2:1233
msgid ""
"The original Linux B<fcntl>()  system call was not designed to handle large "
"file offsets (in the I<flock> structure).  Consequently, an B<fcntl64>()  "
"system call was added in Linux 2.4.  The newer system call employs a "
"different structure for file locking, I<flock64>, and corresponding "
"commands, B<F_GETLK64>, B<F_SETLK64>, and B<F_SETLKW64>.  However, these "
"details can be ignored by applications using glibc, whose B<fcntl>()  "
"wrapper function transparently employs the more recent system call where it "
"is available."
msgstr ""
"元々の Linux の B<fcntl>() システムコールは (I<flock> 構造体で) 大きな\n"
"ファイルオフセットを扱えるように設計されていなかった。\n"
"その結果、Linux 2.4 で B<fcntl64>() システムコールが追加された。\n"
"この新しいシステムコールは、ファイルのロックに I<flock64> という別の\n"
"構造体を利用し、これに対応するコマンドとして B<F_GETLK64>,\n"
"B<F_SETLK64>, B<F_SETLKW64> を使用する。\n"
"しかし、 glibc を使うアプリケーションではこれらの詳細を無視することが\n"
"できる。 glibc の B<fcntl> のラッパー関数は新しいシステムコールが\n"
"利用できる場合はそれを利用するようになっているからである。"

#. type: Plain text
#: build/C/man2/fcntl.2:1238
msgid ""
"The errors returned by B<dup2>(2)  are different from those returned by "
"B<F_DUPFD>."
msgstr "エラーの際の返り値が B<dup2>(2)  と B<F_DUPFD> では異なっている。"

#. type: Plain text
#: build/C/man2/fcntl.2:1244
msgid ""
"Since kernel 2.0, there is no interaction between the types of lock placed "
"by B<flock>(2)  and B<fcntl>()."
msgstr ""
"カーネル 2.0 以降では、 B<flock>(2)  と B<fcntl>()  が設定するロック種別の間"
"に相互作用はない。"

#.  e.g., Solaris 8 documents this field in fcntl(2), and Irix 6.5
#.  documents it in fcntl(5).  mtk, May 2007
#. type: Plain text
#: build/C/man2/fcntl.2:1255
msgid ""
"Several systems have more fields in I<struct flock> such as, for example, "
"I<l_sysid>.  Clearly, I<l_pid> alone is not going to be very useful if the "
"process holding the lock may live on a different machine."
msgstr ""
"システムによっては、 I<struct flock> に上記以外のフィールドがあるものもある "
"(例えば I<l_sysid>)。 はっきりと言えることは、ロックを保持しているプロセスが"
"別のマシンに存在 する場合には、 I<l_pid> だけはあまり役にたたないだろうという"
"ことである。"

#. type: SS
#: build/C/man2/fcntl.2:1256
#, no-wrap
msgid "F_SETFL"
msgstr "F_SETFL"

#.  FIXME . According to POSIX.1-2001, O_SYNC should also be modifiable
#.  via fcntl(2), but currently Linux does not permit this
#.  See http://bugzilla.kernel.org/show_bug.cgi?id=5994
#. type: Plain text
#: build/C/man2/fcntl.2:1268
msgid ""
"It is not possible to use B<F_SETFL> to change the state of the B<O_DSYNC> "
"and B<O_SYNC> flags.  Attempts to change the state of these flags are "
"silently ignored."
msgstr ""

#. type: SS
#: build/C/man2/fcntl.2:1268
#, no-wrap
msgid "F_GETOWN"
msgstr "F_GETOWN"

#.  glibc source: sysdeps/unix/sysv/linux/i386/sysdep.h
#.  mtk, Dec 04: some limited testing on alpha and ia64 seems to
#.  indicate that ANY negative PGID value will cause F_GETOWN
#.  to misinterpret the return as an error. Some other architectures
#.  seem to have the same range check as i386.
#. type: Plain text
#: build/C/man2/fcntl.2:1294
msgid ""
"A limitation of the Linux system call conventions on some architectures "
"(notably i386) means that if a (negative)  process group ID to be returned "
"by B<F_GETOWN> falls in the range -1 to -4095, then the return value is "
"wrongly interpreted by glibc as an error in the system call; that is, the "
"return value of B<fcntl>()  will be -1, and I<errno> will contain the "
"(positive) process group ID.  The Linux-specific B<F_GETOWN_EX> operation "
"avoids this problem.  Since glibc version 2.11, glibc makes the kernel "
"B<F_GETOWN> problem invisible by implementing B<F_GETOWN> using "
"B<F_GETOWN_EX>."
msgstr ""
"いくつかのアーキテクチャ (特に i386) における Linux システムコールの慣習\n"
"のため以下の制限が存在する。\n"
"B<F_GETOWN> が返す (負の) プロセスグループID が -1 から -4095 の範囲に入った"
"場合、\n"
"glibc はこの返り値をシステムコールでエラーが起こったと間違って解釈してしま"
"う。\n"
"つまり、 B<fcntl>() の返り値は -1 となり、 I<errno> には (正の) プロセスグ"
"ループID\n"
"が設定されることになる。Linux 固有の B<F_GETOWN_EX> ではこの問題を回避でき"
"る。\n"
"glibc バージョン 2.11 以降では、glibc では B<F_GETOWN_EX> を使って\n"
"B<F_GETOWN> を実装することで、カーネルの B<F_GETOWN> の問題を見えないようにし"
"ている。"

#. type: SS
#: build/C/man2/fcntl.2:1294
#, no-wrap
msgid "F_SETOWN"
msgstr "F_SETOWN"

#. type: Plain text
#: build/C/man2/fcntl.2:1311
msgid ""
"In Linux 2.4 and earlier, there is bug that can occur when an unprivileged "
"process uses B<F_SETOWN> to specify the owner of a socket file descriptor as "
"a process (group) other than the caller.  In this case, B<fcntl>()  can "
"return -1 with I<errno> set to B<EPERM>, even when the owner process (group) "
"is one that the caller has permission to send signals to.  Despite this "
"error return, the file descriptor owner is set, and signals will be sent to "
"the owner."
msgstr ""
"Linux 2.4 以前では、非特権プロセスが B<F_SETOWN> を使って、ソケットのファイル"
"ディスクリプタの所有者に 呼び出し元以外のプロセス (やプロセスグループ) を指定"
"すると 発生するバグがある。この場合、 呼び出し元が所有者として指定したプロセ"
"ス (やプロセスグループ) に シグナルを送る許可を持っていたとしても、 B<fcntl>"
"()  が -1 を返し I<errno> に B<EPERM> を設定することがある。 このエラーが返っ"
"たにもかかわらず、ファイルディスクリプタの所有者 は設定され、シグナルはその所"
"有者に送られる。"

#.  http://marc.info/?l=linux-kernel&m=119013491707153&w=2
#. type: Plain text
#: build/C/man2/fcntl.2:1326
msgid ""
"The implementation of mandatory locking in all known versions of Linux is "
"subject to race conditions which render it unreliable: a B<write>(2)  call "
"that overlaps with a lock may modify data after the mandatory lock is "
"acquired; a B<read>(2)  call that overlaps with a lock may detect changes to "
"data that were made only after a write lock was acquired.  Similar races "
"exist between mandatory locks and B<mmap>(2).  It is therefore inadvisable "
"to rely on mandatory locking."
msgstr ""
"これまでの Linux の全てのバージョンにおける強制ロックの実装は、 競合条件下で"
"強制ロックが不完全になるような場合がある。 ロックと重なって実行された "
"B<write>(2)  の呼び出しは強制ロックが獲得された後にもデータを変更することがで"
"きる。 ロックと重なって実行された B<read>(2)  の呼び出しは強制ロックが獲得さ"
"れた後になって行われたデータの変更を 検出することができる。 同様の競合条件が"
"強制ロックと B<mmap>(2)  の間にも存在する。それゆえ、強制ロックに頼るのはお薦"
"めできない。"

#. type: Plain text
#: build/C/man2/fcntl.2:1334
msgid ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7)"
msgstr ""
"B<dup2>(2), B<flock>(2), B<open>(2), B<socket>(2), B<lockf>(3), "
"B<capabilities>(7), B<feature_test_macros>(7)"

#. type: Plain text
#: build/C/man2/fcntl.2:1347
msgid ""
"I<locks.txt>, I<mandatory-locking.txt>, and I<dnotify.txt> in the Linux "
"kernel source directory I<Documentation/filesystems/> (on older kernels, "
"these files are directly under the I<Documentation/> directory, and "
"I<mandatory-locking.txt> is called I<mandatory.txt>)"
msgstr ""
"Linux カーネルソースの I<Documentation/filesystems/> ディレクトリ内の "
"I<locks.txt>, I<mandatory-locking.txt>, I<dnotify.txt> (以前のカーネルでは、"
"これらのファイルは I<Documentation/> ディレクトリ直下にあり、 I<mandatory-"
"locking.txt> は I<mandatory.txt> という名前であった)"

#. type: TH
#: build/C/man3/fexecve.3:25
#, no-wrap
msgid "FEXECVE"
msgstr "FEXECVE"

#. type: TH
#: build/C/man3/fexecve.3:25
#, no-wrap
msgid "2013-10-25"
msgstr "2013-10-25"

#. type: Plain text
#: build/C/man3/fexecve.3:28
msgid "fexecve - execute program specified via file descriptor"
msgstr "fexecve - ファイルディスクリプタで指定されたプログラムを実行する"

#. type: Plain text
#: build/C/man3/fexecve.3:33
#, no-wrap
msgid "B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<[]);>\n"
msgstr "B<int fexecve(int >I<fd>B<, char *const >I<argv>B<[], char *const >I<envp>B<[]);>\n"

#. type: Plain text
#: build/C/man3/fexecve.3:41
msgid "B<fexecve>():"
msgstr "B<fexecve>():"

#. type: Plain text
#: build/C/man3/fexecve.3:50 build/C/man3/getcwd.3:54
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#.  POSIX.1-2008 specifies the O_EXEC flag for open as an alternative,
#.  but Linux doesn't support this flag yet.
#. type: Plain text
#: build/C/man3/fexecve.3:67
msgid ""
"B<fexecve>()  performs the same task as B<execve>(2), with the difference "
"that the file to be executed is specified via a file descriptor, I<fd>, "
"rather than via a pathname.  The file descriptor I<fd> must be opened read-"
"only, and the caller must have permission to execute the file that it refers "
"to."
msgstr ""
"B<fexecve>()  は B<execve>(2)  と同じ作業を行う。違うのは、 実行するファイル"
"を、パス名ではなく、 ファイルディスクリプタ I<fd> を用いて指定する点である。 "
"ファイルディスクリプタ I<fd> は、読み込み専用でオープンされていなければなら"
"ず、 呼び出し元はファイルディスクリプタが参照するファイルに対する 実行許可を"
"持っていなければならない。"

#. type: Plain text
#: build/C/man3/fexecve.3:74
msgid ""
"A successful call to B<fexecve>()  never returns.  On error, the function "
"returns, with a result value of -1, and I<errno> is set appropriately."
msgstr ""
"B<fexecve>()  は呼び出しに成功した場合、戻ることはない。 エラーの場合、返り値"
"として -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/fexecve.3:78
msgid "Errors are as for B<execve>(2), with the following additions:"
msgstr "エラーは B<execve>(2)  と同じだが、以下のエラーが追加になっている:"

#. type: Plain text
#: build/C/man3/fexecve.3:86
msgid ""
"I<fd> is not a valid file descriptor, or I<argv> is NULL, or I<envp> is NULL."
msgstr ""
"I<fd> が有効なファイルディスクリプタでない。または I<argv> が NULL である。ま"
"たは I<envp> が NULL である。"

#. type: Plain text
#: build/C/man3/fexecve.3:91
msgid "The I</proc> filesystem could not be accessed."
msgstr "I</proc> ファイルシステムにアクセスできなかった。"

#. type: Plain text
#: build/C/man3/fexecve.3:94
msgid "B<fexecve>()  is implemented since glibc 2.3.2."
msgstr "B<fexecve>()  は glibc 2.3.2 以降で実装されている。"

#. type: Plain text
#: build/C/man3/fexecve.3:99
msgid ""
"POSIX.1-2008.  This function is not specified in POSIX.1-2001, and is not "
"widely available on other systems.  It is specified in POSIX.1-2008."
msgstr "POSIX.1-2008.  この関数は POSIX.1-2001 では規定されておらず、 他のシステムで広く利用できるわけではない。 POSIX.1-2008 で規定されている。"

#. type: Plain text
#: build/C/man3/fexecve.3:107
msgid ""
"On Linux, B<fexecve>()  is implemented using the B<proc>(5)  filesystem, so "
"I</proc> needs to be mounted and available at the time of the call."
msgstr ""
"Linux では、 B<fexecve>()  は B<proc>(5)  ファイルシステムを使って実装されて"
"いる。 そのため、この関数を呼び出す時点では I</proc> がマウントされて利用可能"
"となっている必要がある。"

#. type: Plain text
#: build/C/man3/fexecve.3:124
msgid ""
"The idea behind B<fexecve>()  is to allow the caller to verify (checksum) "
"the contents of an executable before executing it.  Simply opening the file, "
"checksumming the contents, and then doing an B<execve>(2)  would not "
"suffice, since, between the two steps, the filename, or a directory prefix "
"of the pathname, could have been exchanged (by, for example, modifying the "
"target of a symbolic link).  B<fexecve>()  does not mitigate the problem "
"that the I<contents> of a file could be changed between the checksumming and "
"the call to B<fexecve>(); for that, the solution is to ensure that the "
"permissions on the file prevent it from being modified by malicious users."
msgstr ""

#. type: Plain text
#: build/C/man3/fexecve.3:126
msgid "B<execve>(2)"
msgstr "B<execve>(2)"

#. type: TH
#: build/C/man2/flock.2:35
#, no-wrap
msgid "FLOCK"
msgstr "FLOCK"

#. type: TH
#: build/C/man2/flock.2:35
#, no-wrap
msgid "2013-02-11"
msgstr "2013-02-11"

#. type: Plain text
#: build/C/man2/flock.2:38
msgid "flock - apply or remove an advisory lock on an open file"
msgstr ""
"flock - オープンされたファイルに対するアドバイザリロックの適用、解除を行う"

#. type: Plain text
#: build/C/man2/flock.2:40
msgid "B<#include E<lt>sys/file.hE<gt>>"
msgstr "B<#include E<lt>sys/file.hE<gt>>"

#. type: Plain text
#: build/C/man2/flock.2:42
msgid "B<int flock(int >I<fd>B<, int >I<operation>B<);>"
msgstr "B<int flock(int >I<fd>B<, int >I<operation>B<);>"

#. type: Plain text
#: build/C/man2/flock.2:48
msgid ""
"Apply or remove an advisory lock on the open file specified by I<fd>.  The "
"argument I<operation> is one of the following:"
msgstr ""
"オープンされたファイルにアドバイザリロック (advisory lock) の適用 や解除を行"
"う。 ファイルは I<fd> で指定する。引き数 I<operation> には以下のいずれか一つ"
"を指定する:"

#. type: TP
#: build/C/man2/flock.2:49
#, no-wrap
msgid "B<LOCK_SH>"
msgstr "B<LOCK_SH>"

#. type: Plain text
#: build/C/man2/flock.2:54
msgid ""
"Place a shared lock.  More than one process may hold a shared lock for a "
"given file at a given time."
msgstr ""
"共有ロックを適用する。 指定したファイルに対して、 一つ以上のプロセスが同時に"
"共有ロックを保持することができる。"

#. type: TP
#: build/C/man2/flock.2:54
#, no-wrap
msgid "B<LOCK_EX>"
msgstr "B<LOCK_EX>"

#. type: Plain text
#: build/C/man2/flock.2:59
msgid ""
"Place an exclusive lock.  Only one process may hold an exclusive lock for a "
"given file at a given time."
msgstr ""
"排他ロックを適用する。 指定したファイルに対して、 ただ一つのプロセスだけが同"
"時に排他ロックを保持することができる。"

#. type: TP
#: build/C/man2/flock.2:59
#, no-wrap
msgid "B<LOCK_UN>"
msgstr "B<LOCK_UN>"

#. type: Plain text
#: build/C/man2/flock.2:62
msgid "Remove an existing lock held by this process."
msgstr "このプロセスが保持している既存のロックを解除する。"

#. type: Plain text
#: build/C/man2/flock.2:71
msgid ""
"A call to B<flock>()  may block if an incompatible lock is held by another "
"process.  To make a nonblocking request, include B<LOCK_NB> (by ORing)  with "
"any of the above operations."
msgstr ""
"B<flock>()  を呼び出したときに、指定したロック種別と異なるロックが別プロセス"
"によって 保持されていると、 B<flock>()  は停止 (block) されることがある。 非"
"停止 (nonblocking) タイプの要求を行うためには、 上記の操作 (operation) に "
"B<LOCK_NB> を論理和の形で指定する。"

#. type: Plain text
#: build/C/man2/flock.2:73
msgid ""
"A single file may not simultaneously have both shared and exclusive locks."
msgstr "一つのファイルに共有ロックと排他ロックを同時に設定することはできない。"

#. type: Plain text
#: build/C/man2/flock.2:87
msgid ""
"Locks created by B<flock>()  are associated with an open file table entry.  "
"This means that duplicate file descriptors (created by, for example, B<fork>"
"(2)  or B<dup>(2))  refer to the same lock, and this lock may be modified or "
"released using any of these descriptors.  Furthermore, the lock is released "
"either by an explicit B<LOCK_UN> operation on any of these duplicate "
"descriptors, or when all such descriptors have been closed."
msgstr ""
"B<flock>()  によって作られるロックは、 オープンされたファイルのテーブルエント"
"リと関連付けられる。 したがって、ファイルディスクリプタの複製 (B<fork>(2)  "
"や B<dup>(2)  などにより作成される) は同じロックを参照し、 これらのファイル"
"ディスクリプタのどれを使っても このロックを変更したり解放したりできる。 ま"
"た、ロックの解放は、 上記の複数のファイルディスクリプタのいずれかに対して 明"
"示的に B<LOCK_UN> 操作を指示した場合か、これらのファイルディスクリプタがすべ"
"て 閉じられた場合に行われる。"

#. type: Plain text
#: build/C/man2/flock.2:96
msgid ""
"If a process uses B<open>(2)  (or similar) to obtain more than one "
"descriptor for the same file, these descriptors are treated independently by "
"B<flock>().  An attempt to lock the file using one of these file descriptors "
"may be denied by a lock that the calling process has already placed via "
"another descriptor."
msgstr ""
"あるプロセスが B<open>(2)  (もしくは同様の方法) を使って同じファイルに対して "
"複数のディスクリプタを取得した場合、 B<flock>()  はこれら複数のディスクリプタ"
"を各々独立のものとして扱う。 これらのファイルディスクリプタの一つを使ってファ"
"イルをロックしようと した際、そのロック要求は、呼び出し元のプロセスがそのファ"
"イルの別の ディスクリプタ経由ですでに設定しているロックによって拒否される場合"
"がある。"

#. type: Plain text
#: build/C/man2/flock.2:103
msgid ""
"A process may hold only one type of lock (shared or exclusive)  on a file.  "
"Subsequent B<flock>()  calls on an already locked file will convert an "
"existing lock to the new lock mode."
msgstr ""
"一つのプロセスは、一つのファイルに対して (共有ロックと排他ロックのうち)  いず"
"れか一種類のロックしか設定できない。 既にロックされたファイルに対して "
"B<flock>()  を呼び出すと、既存のロックを新しいロックモードに変更することにな"
"る。"

#. type: Plain text
#: build/C/man2/flock.2:108
msgid "Locks created by B<flock>()  are preserved across an B<execve>(2)."
msgstr ""
"B<flock>()  により作成されたロックは B<execve>(2)  の前後で保存される。"

#. type: Plain text
#: build/C/man2/flock.2:111
msgid ""
"A shared or exclusive lock can be placed on a file regardless of the mode in "
"which the file was opened."
msgstr ""
"共有ロックも排他ロックも、ファイルがどのモードでオープンされたかに 関係なく適"
"用することができる。"

#. type: Plain text
#: build/C/man2/flock.2:121
msgid "I<fd> is not an open file descriptor."
msgstr "I<fd> がオープンされたファイルディスクリプタではない。"

#. type: Plain text
#: build/C/man2/flock.2:126
msgid ""
"While waiting to acquire a lock, the call was interrupted by delivery of a "
"signal caught by a handler; see B<signal>(7)."
msgstr ""
"ロックの獲得を待っている間に、ハンドラにより捕捉されたシグナルを 受信し、 "
"B<flock>()  が中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/flock.2:130
msgid "I<operation> is invalid."
msgstr "I<oepration> が無効である。"

#. type: Plain text
#: build/C/man2/flock.2:133
msgid "The kernel ran out of memory for allocating lock records."
msgstr "ロックレコードを割り当てるためのメモリが不足している。"

#. type: TP
#: build/C/man2/flock.2:133
#, no-wrap
msgid "B<EWOULDBLOCK>"
msgstr "B<EWOULDBLOCK>"

#. type: Plain text
#: build/C/man2/flock.2:138
msgid "The file is locked and the B<LOCK_NB> flag was selected."
msgstr ""
"指定したファイルがロックされており、 B<LOCK_NB> フラグが指定されている。"

#. type: Plain text
#: build/C/man2/flock.2:147
msgid ""
"4.4BSD (the B<flock>()  call first appeared in 4.2BSD).  A version of "
"B<flock>(), possibly implemented in terms of B<fcntl>(2), appears on most "
"UNIX systems."
msgstr ""
"4.4BSD (B<flock>()  コールは 4.2BSD で最初に登場した)。 B<fcntl>(2)  で実装さ"
"れているものなどを含めると、 B<flock>()  の機能はほとんどの UNIX システムで実"
"装されている。"

#. type: Plain text
#: build/C/man2/flock.2:154
msgid ""
"B<flock>()  does not lock files over NFS.  Use B<fcntl>(2)  instead: that "
"does work over NFS, given a sufficiently recent version of Linux and a "
"server which supports locking."
msgstr ""
"B<flock>()  は NFS 上のファイルのロックをしない。代わりに B<fcntl>(2)  を使用"
"すること。これにより、十分に新しいバージョンの Linux と、ロック機能を サポー"
"トした NFS サーバを使用することにより、NFS 上でロックができる。"

#. type: Plain text
#: build/C/man2/flock.2:169
msgid ""
"Since kernel 2.0, B<flock>()  is implemented as a system call in its own "
"right rather than being emulated in the GNU C library as a call to B<fcntl>"
"(2).  This yields true BSD semantics: there is no interaction between the "
"types of lock placed by B<flock>()  and B<fcntl>(2), and B<flock>()  does "
"not detect deadlock."
msgstr ""
"kernel 2.0 以降では、 B<flock>()  は、GNU C ライブラリでの B<fcntl>(2)  を呼"
"び出してのエミュレーションではなく、 それ自体がシステムコールとして実装されて"
"いる。 これにより正真正銘の BSD での動作が達成される: B<flock>()  と B<fcntl>"
"(2)  で適用されるロックの種別には相互作用がなくなり、 B<flock>()  がデッド"
"ロックを検出しなくなる。"

#. type: Plain text
#: build/C/man2/flock.2:175
msgid ""
"B<flock>()  places advisory locks only; given suitable permissions on a "
"file, a process is free to ignore the use of B<flock>()  and perform I/O on "
"the file."
msgstr ""
"B<flock>()  アドバイザリロックだけを適用する。したがって、ファイルに適切なア"
"クセス権を 付与していれば、プロセスは B<flock>()  の使用に無視して、ファイル"
"への入出力を行うことができる。"

#. type: Plain text
#: build/C/man2/flock.2:188
msgid ""
"B<flock>()  and B<fcntl>(2)  locks have different semantics with respect to "
"forked processes and B<dup>(2).  On systems that implement B<flock>()  using "
"B<fcntl>(2), the semantics of B<flock>()  will be different from those "
"described in this manual page."
msgstr ""
"B<flock>()  と B<fcntl>(2)  は fork されたプロセスと B<dup>(2)  で違った動作"
"をする。 B<flock>()  を B<fcntl>(2)  を使って実装しているシステムでは、 "
"B<flock>()  の動作はこのマニュアルページに記載されているものとは違うだろう。"

#.  Kernel 2.5.21 changed things a little: during lock conversion
#.  it is now the highest priority process that will get the lock -- mtk
#. type: Plain text
#: build/C/man2/flock.2:201
msgid ""
"Converting a lock (shared to exclusive, or vice versa) is not guaranteed to "
"be atomic: the existing lock is first removed, and then a new lock is "
"established.  Between these two steps, a pending lock request by another "
"process may be granted, with the result that the conversion either blocks, "
"or fails if B<LOCK_NB> was specified.  (This is the original BSD behavior, "
"and occurs on many other implementations.)"
msgstr ""
"ロックの変換 (共有ロックから排他ロックへ、もしくはその反対) がアトミックに 行"
"われることは保証されていない: 既存のロックがまず削除され、それから新しい ロッ"
"クが設定される。この 2つのステップの間に、他のプロセスからの処理待ちの ロック"
"要求が認められるかもしれず、結果として変換は停止 (block) したり、 "
"(B<LOCK_NB> が指定された場合には) 失敗したりする。 (これは元々の BSD の動作で"
"あり、多くの他の実装でも起こる。)"

#. type: Plain text
#: build/C/man2/flock.2:210
msgid ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3)"
msgstr ""
"B<flock>(1), B<close>(2), B<dup>(2), B<execve>(2), B<fcntl>(2), B<fork>(2), "
"B<open>(2), B<lockf>(3)"

#. type: Plain text
#: build/C/man2/flock.2:215
msgid ""
"I<Documentation/filesystems/locks.txt> in the Linux kernel source tree "
"(I<Documentation/locks.txt> in older kernels)"
msgstr ""
"Linux カーネルソース内の I<Documentation/filesystems/locks.txt> (以前のカーネ"
"ルでは I<Documentation/locks.txt>)"

#. type: TH
#: build/C/man2/fork.2:39
#, no-wrap
msgid "FORK"
msgstr "FORK"

#. type: TH
#: build/C/man2/fork.2:39 build/C/man2/ioperm.2:34
#, no-wrap
msgid "2013-03-12"
msgstr "2013-03-12"

#. type: Plain text
#: build/C/man2/fork.2:42
msgid "fork - create a child process"
msgstr "fork - 子プロセスを生成する"

#. type: Plain text
#: build/C/man2/fork.2:46
msgid "B<pid_t fork(void);>"
msgstr "B<pid_t fork(void);>"

#. type: Plain text
#: build/C/man2/fork.2:52
msgid ""
"B<fork>()  creates a new process by duplicating the calling process.  The "
"new process, referred to as the I<child>, is an exact duplicate of the "
"calling process, referred to as the I<parent>, except for the following "
"points:"
msgstr ""
"B<fork>()  は呼び出し元プロセスを複製して新しいプロセスを生成する。 I<child> "
"で参照される新しいプロセスは、以下の点を除き、 I<parent> で参照される呼び出し"
"元プロセスの完全な複製である:"

#. type: Plain text
#: build/C/man2/fork.2:56
msgid ""
"The child has its own unique process ID, and this PID does not match the ID "
"of any existing process group (B<setpgid>(2))."
msgstr ""
"子プロセスは独自のプロセス ID を持ち、 この PID は既存のどのプロセスグループ "
"(B<setpgid>(2))  の ID とも一致しない。"

#. type: Plain text
#: build/C/man2/fork.2:58
msgid "The child's parent process ID is the same as the parent's process ID."
msgstr "子プロセスの親プロセス ID は、親プロセスのプロセス ID と同じである。"

#. type: Plain text
#: build/C/man2/fork.2:62
msgid ""
"The child does not inherit its parent's memory locks (B<mlock>(2), "
"B<mlockall>(2))."
msgstr ""
"子プロセスは親プロセスのメモリロック (B<mlock>(2), B<mlockall>(2))  を引き継"
"がない。"

#. type: Plain text
#: build/C/man2/fork.2:68
msgid ""
"Process resource utilizations (B<getrusage>(2))  and CPU time counters "
"(B<times>(2))  are reset to zero in the child."
msgstr ""
"プロセスの資源利用量 (B<getrusage>(2))  と CPU タイムカウンタ (B<times>(2))  "
"が、子プロセスでは 0 にリセットされる。"

#. type: Plain text
#: build/C/man2/fork.2:71
msgid ""
"The child's set of pending signals is initially empty (B<sigpending>(2))."
msgstr ""
"子プロセスの処理待ちのシグナルの集合 (B<sigpending>(2))  は、初期状態では空に"
"なる。"

#. type: Plain text
#: build/C/man2/fork.2:74
msgid ""
"The child does not inherit semaphore adjustments from its parent (B<semop>"
"(2))."
msgstr "子プロセスは親プロセスからセマフォ調整 (B<semop>(2))  を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:77
msgid "The child does not inherit record locks from its parent (B<fcntl>(2))."
msgstr ""
"子プロセスは親プロセスからレコードロック (B<fcntl>(2))  を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:82
msgid ""
"The child does not inherit timers from its parent (B<setitimer>(2), B<alarm>"
"(2), B<timer_create>(2))."
msgstr ""
"子プロセスは親プロセスからタイマー (B<setitimer>(2), B<alarm>(2), "
"B<timer_create>(2))  を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:89
msgid ""
"The child does not inherit outstanding asynchronous I/O operations from its "
"parent (B<aio_read>(3), B<aio_write>(3)), nor does it inherit any "
"asynchronous I/O contexts from its parent (see B<io_setup>(2))."
msgstr ""
"子プロセスは親プロセスから主だった非同期 I/O 操作を引き継がない (B<aio_read>"
"(3), B<aio_write>(3)  参照)。 また、親プロセスから非同期 I/O コンテキストを引"
"き継がない (B<io_setup>(2)  参照)。"

#. type: Plain text
#: build/C/man2/fork.2:94
msgid ""
"The process attributes in the preceding list are all specified in "
"POSIX.1-2001.  The parent and child also differ with respect to the "
"following Linux-specific process attributes:"
msgstr ""
"上記のリストにあるプロセス属性は、POSIX.1-2001 で全て指定されている。 親プロ"
"セスと子プロセスは、以下の Linux 固有のプロセス属性も異なる:"

#. type: Plain text
#: build/C/man2/fork.2:101
msgid ""
"The child does not inherit directory change notifications (dnotify)  from "
"its parent (see the description of B<F_NOTIFY> in B<fcntl>(2))."
msgstr ""
"子プロセスは親プロセスからディレクトリ変更通知 (dnotify)  (B<fcntl>(2)  にお"
"ける B<F_NOTIFY> の説明を参照) を引き継がない。"

#. type: Plain text
#: build/C/man2/fork.2:107
msgid ""
"The B<prctl>(2)  B<PR_SET_PDEATHSIG> setting is reset so that the child does "
"not receive a signal when its parent terminates."
msgstr ""
"B<prctl>(2)  の B<PR_SET_PDEATHSIG> の設定がリセットされ、子プロセスは親プロ"
"セスが終了したときに シグナルを受信しない。"

#. type: Plain text
#: build/C/man2/fork.2:114
msgid ""
"The default timer slack value is set to the parent's current timer slack "
"value.  See the description of B<PR_SET_TIMERSLACK> in B<prctl>(2)."
msgstr ""
"timer slack value のデフォルト値には、親プロセスの現在の timer slack value が"
"設定される。 B<prctl>(2) の B<PR_SET_TIMERSLACK> の説明を参照。"

#. type: Plain text
#: build/C/man2/fork.2:120
msgid ""
"Memory mappings that have been marked with the B<madvise>(2)  "
"B<MADV_DONTFORK> flag are not inherited across a B<fork>()."
msgstr ""
"B<madvise>(2)  の B<MADV_DONTFORK> フラグでマークされたメモリマッピングは、 "
"B<fork>()  によって引き継がれない。"

#. type: Plain text
#: build/C/man2/fork.2:125
msgid ""
"The termination signal of the child is always B<SIGCHLD> (see B<clone>(2))."
msgstr ""
"子プロセスの終了シグナルは常に B<SIGCHLD> である (B<clone>(2)  を参照)。"

#. type: Plain text
#: build/C/man2/fork.2:131
msgid ""
"The port access permission bits set by B<ioperm>(2)  are not inherited by "
"the child; the child must turn on any bits that it requires using B<ioperm>"
"(2)."
msgstr ""
"B<ioperm>(2) で設定されるポートアクセス許可ビットは、子プロセスには継承されな"
"い。子プロセスでは、 B<ioperm>(2) を使って必要なビットをセットしなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/fork.2:142
msgid ""
"The child process is created with a single thread\\(emthe one that called "
"B<fork>().  The entire virtual address space of the parent is replicated in "
"the child, including the states of mutexes, condition variables, and other "
"pthreads objects; the use of B<pthread_atfork>(3)  may be helpful for "
"dealing with problems that this can cause."
msgstr ""
"子プロセスはシングルスレッドで生成される。つまり、 B<fork>()  を呼び出したス"
"レッドとなる。 親プロセスの仮想アドレス空間全体が子プロセスに複製される。 こ"
"れにはミューテックス (mutex) の状態・条件変数・ pthread オブジェクトが含まれ"
"る。 これが引き起こす問題を扱うには、 B<pthread_atfork>(3)  を使うと良いだろ"
"う。"

#. type: Plain text
#: build/C/man2/fork.2:156
msgid ""
"The child inherits copies of the parent's set of open file descriptors.  "
"Each file descriptor in the child refers to the same open file description "
"(see B<open>(2))  as the corresponding file descriptor in the parent.  This "
"means that the two descriptors share open file status flags, current file "
"offset, and signal-driven I/O attributes (see the description of B<F_SETOWN> "
"and B<F_SETSIG> in B<fcntl>(2))."
msgstr ""
"子プロセスは親プロセスが持つ オープンファイルディスクリプタの集合のコピーを引"
"き継ぐ。 子プロセスの各ファイルディスクリプタは、 親プロセスのファイルディス"
"クリプタに対応する 同じオープンファイル記述 (file description) を参照する "
"(B<open>(2)  を参照)。 これは 2 つのディスクリプタが、ファイル状態フラグ・ 現"
"在のファイルオフセット、シグナル駆動 (signal-driven) I/O 属性 (B<fcntl>(2)  "
"における B<F_SETOWN>, B<F_SETSIG> の説明を参照) を共有することを意味する。"

#. type: Plain text
#: build/C/man2/fork.2:165
msgid ""
"The child inherits copies of the parent's set of open message queue "
"descriptors (see B<mq_overview>(7)).  Each descriptor in the child refers to "
"the same open message queue description as the corresponding descriptor in "
"the parent.  This means that the two descriptors share the same flags "
"(I<mq_flags>)."
msgstr ""
"子プロセスは親プロセスが持つオープンメッセージキューディスクリプタ "
"(B<mq_overview>(7)  を参照) の集合のコピーを引き継ぐ。 子プロセスの各ディスク"
"リプタは、 親プロセスのディスクリプタに対応する 同じオープンメッセージキュー"
"ディスクリプタを参照する。 これは 2 つのディスクリプタが同じフラグ "
"(I<mq_flags>)  を共有することを意味する。"

#. type: Plain text
#: build/C/man2/fork.2:173
msgid ""
"The child inherits copies of the parent's set of open directory streams (see "
"B<opendir>(3)).  POSIX.1-2001 says that the corresponding directory streams "
"in the parent and child I<may> share the directory stream positioning; on "
"Linux/glibc they do not."
msgstr ""
"子プロセスは、親プロセスのオープン済みのディレクトリストリームの集合 "
"(B<opendir>(3)  参照) のコピーを継承する。 POSIX.1-2001 では、親プロセスと子"
"プロセス間の対応するディレクトリストリーム はディレクトリストリームの位置 "
"(positioning) を共有してもよいとされている。 Linux/glibc ではディレクトリスト"
"リームの位置の共有は行われていない。"

#. type: Plain text
#: build/C/man2/fork.2:180
msgid ""
"On success, the PID of the child process is returned in the parent, and 0 is "
"returned in the child.  On failure, -1 is returned in the parent, no child "
"process is created, and I<errno> is set appropriately."
msgstr ""
"成功した場合、親プロセスには子プロセスの PID が返され、 子プロセスには 0 が返"
"される。 失敗した場合、親プロセスに -1 が返され、子プロセスは生成されず、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/fork.2:186
msgid ""
"B<fork>()  cannot allocate sufficient memory to copy the parent's page "
"tables and allocate a task structure for the child."
msgstr ""
"親プロセスのページテーブルのコピーと 子プロセスのタスク構造に生成に必要なメモ"
"リを B<fork>()  が割り当てることができなかった。"

#. type: Plain text
#: build/C/man2/fork.2:196
msgid ""
"It was not possible to create a new process because the caller's "
"B<RLIMIT_NPROC> resource limit was encountered.  To exceed this limit, the "
"process must have either the B<CAP_SYS_ADMIN> or the B<CAP_SYS_RESOURCE> "
"capability."
msgstr ""
"呼び出し元の B<RLIMIT_NPROC> 資源の制限 (resource limit) に達したために、新し"
"いプロセスを生成できなかった。 この制限を超えるには、プロセスは "
"B<CAP_SYS_ADMIN> または B<CAP_SYS_RESOURCE> ケーパビリティ (capability) を"
"持っていなくてはならない。"

#. type: Plain text
#: build/C/man2/fork.2:200
msgid ""
"B<fork>()  failed to allocate the necessary kernel structures because memory "
"is tight."
msgstr ""
"メモリが足りないために、 B<fork>()  は必要なカーネル構造体を割り当てることが"
"できなかった。"

#.  e.g., arm (optionally), blackfin, c6x, frv, h8300, microblaze, xtensa
#. type: Plain text
#: build/C/man2/fork.2:206
msgid ""
"B<fork>()  is not supported on this platform (for example, hardware without "
"a Memory-Management Unit)."
msgstr ""
"B<fork>() はこのプラットフォームではサポートされていない\n"
"(例えば、メモリ管理ユニット (MMU) がないハードウェア)。"

#. type: Plain text
#: build/C/man2/fork.2:215
msgid ""
"Under Linux, B<fork>()  is implemented using copy-on-write pages, so the "
"only penalty that it incurs is the time and memory required to duplicate the "
"parent's page tables, and to create a unique task structure for the child."
msgstr ""
"Linux では、 B<fork>()  を 書き込み時コピー (copy-on-write) ページを用いて実"
"装している。 したがって、fork を行うことの唯一のデメリットは、 親プロセスの"
"ページテーブルを複製と 子プロセス自身のタスク構造の作成のための時間とメモリが"
"必要なことである。"

#.  nptl/sysdeps/unix/sysv/linux/fork.c
#.  and does some magic to ensure that getpid(2) returns the right value.
#. type: Plain text
#: build/C/man2/fork.2:239
msgid ""
"Since version 2.3.3, rather than invoking the kernel's B<fork>()  system "
"call, the glibc B<fork>()  wrapper that is provided as part of the NPTL "
"threading implementation invokes B<clone>(2)  with flags that provide the "
"same effect as the traditional system call.  (A call to B<fork>()  is "
"equivalent to a call to B<clone>(2)  specifying I<flags> as just "
"B<SIGCHLD>.)  The glibc wrapper invokes any fork handlers that have been "
"established using B<pthread_atfork>(3)."
msgstr ""
"glibc 2.3.3 以降では、 NPTL スレッド実装の一部として提供されている\n"
"glibc のB<fork>() ラッパー関数は、 カーネルの B<fork>() システムコール\n"
"を起動するのではなく、B<clone>(2) を起動する。\n"
"B<clone>(2) に渡すフラグとして、伝統的な B<fork>() システムコールと\n"
"同じ効果が得られるようなフラグが指定される (B<fork>() の呼び出しは、\n"
"I<flags> に B<SIGCHLD> だけを指定して B<clone>(2) を呼び出すのと等価であ"
"る)。\n"
"glibc のラッパー関数は B<pthread_atfork>(3) を使って設定されている\n"
"任意の fork ハンドラを起動する。"

#. type: Plain text
#: build/C/man2/fork.2:244
msgid "See B<pipe>(2)  and B<wait>(2)."
msgstr "B<pipe>(2)  および B<wait>(2)  を参照。"

#. type: Plain text
#: build/C/man2/fork.2:255
msgid ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<capabilities>(7), B<credentials>(7)"
msgstr ""
"B<clone>(2), B<execve>(2), B<exit>(2), B<setrlimit>(2), B<unshare>(2), "
"B<vfork>(2), B<wait>(2), B<daemon>(3), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man3/fpathconf.3:41
#, no-wrap
msgid "FPATHCONF"
msgstr "FPATHCONF"

#. type: TH
#: build/C/man3/fpathconf.3:41
#, no-wrap
msgid "1993-04-04"
msgstr "1993-04-04"

#. type: Plain text
#: build/C/man3/fpathconf.3:44
msgid "fpathconf, pathconf - get configuration values for files"
msgstr "fpathconf, pathconf - ファイルの設定値を取得する"

#. type: Plain text
#: build/C/man3/fpathconf.3:49
#, no-wrap
msgid "B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"
msgstr "B<long fpathconf(int >I<fd>B<, int >I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/fpathconf.3:51
#, no-wrap
msgid "B<long pathconf(char *>I<path>B<, int >I<name>B<);>\n"
msgstr "B<long pathconf(char *>I<path>B<, int >I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/fpathconf.3:58
msgid ""
"B<fpathconf>()  gets a value for the configuration option I<name> for the "
"open file descriptor I<fd>."
msgstr ""
"B<fpathconf>()  はオープンされているファイルデスクリプター I<fd> に対して設定"
"されているオプション I<name> の値を取得する。"

#. type: Plain text
#: build/C/man3/fpathconf.3:64
msgid ""
"B<pathconf>()  gets a value for configuration option I<name> for the "
"filename I<path>."
msgstr ""
"B<pathconf>()  はファイル名 I<path> に対して設定されているオプション I<name> "
"の値を取得する。"

#. type: Plain text
#: build/C/man3/fpathconf.3:73
msgid ""
"The corresponding macros defined in I<E<lt>unistd.hE<gt>> are minimum "
"values; if an application wants to take advantage of values which may "
"change, a call to B<fpathconf>()  or B<pathconf>()  can be made, which may "
"yield more liberal results."
msgstr ""
"対応するマクロのうち I<E<lt>unistd.hE<gt>> で定義されているものは最小値であ"
"る。アプリケーションによってはこれらの 値を変更してより有利な動作を行おうとす"
"るものがある。この場合でも B<fpathconf>()  または B<pathconf>()  は呼び出すこ"
"とができる。この場合はより大きな値が返ることになろう。"

#. type: Plain text
#: build/C/man3/fpathconf.3:78
msgid ""
"Setting I<name> equal to one of the following constants returns the "
"following configuration options:"
msgstr ""
"I<name> を以下の定数のどれかにすると、対応する設定オプションが返される。"

#. type: TP
#: build/C/man3/fpathconf.3:78
#, no-wrap
msgid "B<_PC_LINK_MAX>"
msgstr "B<_PC_LINK_MAX>"

#. type: Plain text
#: build/C/man3/fpathconf.3:88
msgid ""
"returns the maximum number of links to the file.  If I<fd> or I<path> refer "
"to a directory, then the value applies to the whole directory.  The "
"corresponding macro is B<_POSIX_LINK_MAX>."
msgstr ""
"ファイルへのリンクの最大数を返す。 I<fd> または I<path> がディレクトリの場合"
"は、この値はディレクトリ全体に適用される。対応する マクロは "
"B<_POSIX_LINK_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:88
#, no-wrap
msgid "B<_PC_MAX_CANON>"
msgstr "B<_PC_MAX_CANON>"

#. type: Plain text
#: build/C/man3/fpathconf.3:97
msgid ""
"returns the maximum length of a formatted input line, where I<fd> or I<path> "
"must refer to a terminal.  The corresponding macro is B<_POSIX_MAX_CANON>."
msgstr ""
"フォーマット付き入力行の最大長を返す。このとき I<fd> または I<path> は端末を"
"参照していなければならない。 対応するマクロは B<_POSIX_MAX_CANON> である。"

#. type: TP
#: build/C/man3/fpathconf.3:97
#, no-wrap
msgid "B<_PC_MAX_INPUT>"
msgstr "B<_PC_MAX_INPUT>"

#. type: Plain text
#: build/C/man3/fpathconf.3:106
msgid ""
"returns the maximum length of an input line, where I<fd> or I<path> must "
"refer to a terminal.  The corresponding macro is B<_POSIX_MAX_INPUT>."
msgstr ""
"入力行の最大長を返す。このとき I<fd> または I<path> は端末を参照していなけれ"
"ばならない。 対応するマクロは B<_POSIX_MAX_INPUT> である。"

#. type: TP
#: build/C/man3/fpathconf.3:106
#, no-wrap
msgid "B<_PC_NAME_MAX>"
msgstr "B<_PC_NAME_MAX>"

#. type: Plain text
#: build/C/man3/fpathconf.3:115
msgid ""
"returns the maximum length of a filename in the directory I<path> or I<fd> "
"that the process is allowed to create.  The corresponding macro is "
"B<_POSIX_NAME_MAX>."
msgstr ""
"ディレクトリ I<path> または I<fd> 内に、そのプロセスが作成することができる"
"ファイル名の最大長を返す。 対応するマクロは B<_POSIX_NAME_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:115
#, no-wrap
msgid "B<_PC_PATH_MAX>"
msgstr "B<_PC_PATH_MAX>"

#. type: Plain text
#: build/C/man3/fpathconf.3:124
msgid ""
"returns the maximum length of a relative pathname when I<path> or I<fd> is "
"the current working directory.  The corresponding macro is "
"B<_POSIX_PATH_MAX>."
msgstr ""
"I<path> または I<fd> がカレントディレクトリの場合、相対パス名の最大長を返"
"す。 対応するマクロは B<_POSIX_PATH_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:124
#, no-wrap
msgid "B<_PC_PIPE_BUF>"
msgstr "B<_PC_PIPE_BUF>"

#. type: Plain text
#: build/C/man3/fpathconf.3:133
msgid ""
"returns the size of the pipe buffer, where I<fd> must refer to a pipe or "
"FIFO and I<path> must refer to a FIFO.  The corresponding macro is "
"B<_POSIX_PIPE_BUF>."
msgstr ""
"パイプ (pipe) バッファのサイズを返す。このとき I<fd> はパイプか FIFO を参照し"
"ていなければならず、 I<path> は FIFO を参照していなければならない。 対応する"
"マクロは B<_POSIX_PIPE_BUF> である。"

#. type: TP
#: build/C/man3/fpathconf.3:133
#, no-wrap
msgid "B<_PC_CHOWN_RESTRICTED>"
msgstr "B<_PC_CHOWN_RESTRICTED>"

#. type: Plain text
#: build/C/man3/fpathconf.3:146
msgid ""
"returns nonzero if the B<chown>(2)  call may not be used on this file.  If "
"I<fd> or I<path> refer to a directory, then this applies to all files in "
"that directory.  The corresponding macro is B<_POSIX_CHOWN_RESTRICTED>."
msgstr ""
"このファイルに対する B<chown>(2)  の呼び出しが許されていない場合には 0 以外の"
"値を返す。 I<fd> または I<path> がディレクトリを参照している場合は、この制限"
"はそのディレクトリのすべて のファイルに適用される。 対応するマクロは "
"B<_POSIX_CHOWN_RESTRICTED> である。"

#. type: TP
#: build/C/man3/fpathconf.3:146
#, no-wrap
msgid "B<_PC_NO_TRUNC>"
msgstr "B<_PC_NO_TRUNC>"

#. type: Plain text
#: build/C/man3/fpathconf.3:153
msgid ""
"returns nonzero if accessing filenames longer than B<_POSIX_NAME_MAX> "
"generates an error.  The corresponding macro is B<_POSIX_NO_TRUNC>."
msgstr ""
"アクセス中のファイル名が B<_POSIX_NAME_MAX> よりも長く、エラーとなる場合には "
"0 以外の値を返す。 対応するマクロは B<_POSIX_NAME_MAX> である。"

#. type: TP
#: build/C/man3/fpathconf.3:153
#, no-wrap
msgid "B<_PC_VDISABLE>"
msgstr "B<_PC_VDISABLE>"

#. type: Plain text
#: build/C/man3/fpathconf.3:160
msgid ""
"returns nonzero if special character processing can be disabled, where I<fd> "
"or I<path> must refer to a terminal."
msgstr ""
"特殊文字 (special character) の処理が許されていない場合は 0 以外の値を 返す。"
"このとき I<fd> または I<path> は端末を参照していなければならない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:169
msgid ""
"The limit is returned, if one exists.  If the system does not have a limit "
"for the requested resource, -1 is returned, and I<errno> is unchanged.  If "
"there is an error, -1 is returned, and I<errno> is set to reflect the nature "
"of the error."
msgstr ""
"(存在していれば) 制限値が返される。要求されたリソースへのシステムの制 限が存"
"在していなければ -1 が返され、 I<errno> は変更されない。エラーが起こった場合"
"には -1 が返され、 I<errno> がエラーに対応した値に設定される。"

#. type: Plain text
#: build/C/man3/fpathconf.3:177
msgid ""
"Files with name lengths longer than the value returned for I<name> equal to "
"B<_PC_NAME_MAX> may exist in the given directory."
msgstr ""
"I<name> に B<_PC_NAME_MAX> を入れて返された値よりも長いファイル名を持つファイ"
"ルが、与えられたディ レクトリに存在するかもしれない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:180 build/C/man3/sysconf.3:335
msgid ""
"Some returned values may be huge; they are not suitable for allocating "
"memory."
msgstr ""
"いくつかの返り値はとても大きくなることがある。これらを使って メモリの割り当て"
"を行うのは適当ではない。"

#. type: Plain text
#: build/C/man3/fpathconf.3:185
msgid "B<getconf>(1), B<open>(2), B<statfs>(2), B<sysconf>(3)"
msgstr "B<getconf>(1), B<open>(2), B<statfs>(2), B<sysconf>(3)"

#. type: TH
#: build/C/man2/fsync.2:38
#, no-wrap
msgid "FSYNC"
msgstr "FSYNC"

#. type: TH
#: build/C/man2/fsync.2:38
#, no-wrap
msgid "2012-02-27"
msgstr "2012-02-27"

#. type: Plain text
#: build/C/man2/fsync.2:41
msgid ""
"fsync, fdatasync - synchronize a file's in-core state with storage device"
msgstr ""
"fsync - メモリ上にあるファイルの内容をストレージデバイス上のものと同期させる"

#. type: Plain text
#: build/C/man2/fsync.2:45
msgid "B<int fsync(int >I<fd>B<);>"
msgstr "B<int fsync(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/fsync.2:47
msgid "B<int fdatasync(int >I<fd>B<);>"
msgstr "B<int fdatasync(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man2/fsync.2:55
msgid "B<fsync>(): _BSD_SOURCE || _XOPEN_SOURCE"
msgstr "B<fsync>(): _BSD_SOURCE || _XOPEN_SOURCE"

#.  _POSIX_C_SOURCE\ >=\ 200112L only since glibc 2.8
#. type: Plain text
#: build/C/man2/fsync.2:58
#, no-wrap
msgid "         || /* since glibc 2.8: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"
msgstr "         || /* glibc 2.8 以降では: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L\n"

#. type: Plain text
#: build/C/man2/fsync.2:61
msgid ""
"B<fdatasync>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>="
"\\ 500"
msgstr ""
"B<fdatasync>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L || _XOPEN_SOURCE\\ E<gt>="
"\\ 500"

#. type: Plain text
#: build/C/man2/fsync.2:74
msgid ""
"B<fsync>()  transfers (\"flushes\") all modified in-core data of (i.e., "
"modified buffer cache pages for) the file referred to by the file descriptor "
"I<fd> to the disk device (or other permanent storage device) so that all "
"changed information can be retrieved even after the system crashed or was "
"rebooted.  This includes writing through or flushing a disk cache if "
"present.  The call blocks until the device reports that the transfer has "
"completed.  It also flushes metadata information associated with the file "
"(see B<stat>(2))."
msgstr ""
"B<fsync>() は、ファイル記述子 I<fd> で参照されるファイルの、メモリ内で存在"
"す\n"
"る修正されたデータ (つまり修正されたバッファキャッシュページ) を、ディスク"
"デ\n"
"バイス(またはその他の永続ストレージデバイス) に転送 (「フラッシュ」) し、こ"
"れ\n"
"により、システムがクラッシュしたり、再起動された後も、変更された全ての情報"
"が\n"
"取り出せるようになる。「フラッシュ」には、ライトスルー (write through) や\n"
"(存在する場合には) ディスクキャッシュのフラッシュも含まれる。この呼び出しは\n"
"転送が終わったとデバイスが報告するまでブロックする。またファイルに結びつい"
"た\n"
"メタデータ情報 (B<stat>(2) 参照) もフラッシュする。"

#. type: Plain text
#: build/C/man2/fsync.2:82
msgid ""
"Calling B<fsync>()  does not necessarily ensure that the entry in the "
"directory containing the file has also reached disk.  For that an explicit "
"B<fsync>()  on a file descriptor for the directory is also needed."
msgstr ""
"B<fsync>()  の呼び出しは、ファイルが存在しているディレクトリのエントリがディ"
"スクへ 書き込まれたことを保証するわけではない。 保証するためには明示的にその"
"ディレクトリのファイル記述子に対しても B<fsync>()  する必要がある。"

#. type: Plain text
#: build/C/man2/fsync.2:103
msgid ""
"B<fdatasync>()  is similar to B<fsync>(), but does not flush modified "
"metadata unless that metadata is needed in order to allow a subsequent data "
"retrieval to be correctly handled.  For example, changes to I<st_atime> or "
"I<st_mtime> (respectively, time of last access and time of last "
"modification; see B<stat>(2))  do not require flushing because they are not "
"necessary for a subsequent data read to be handled correctly.  On the other "
"hand, a change to the file size (I<st_size>, as made by say B<ftruncate>"
"(2)), would require a metadata flush."
msgstr ""
"B<fdatasync>()  は B<fsync>()  と同様であるが、メタデータの扱いが異なる。 "
"B<fdatasync>()  は、それ以降のデータ読み込みを正しく扱うためにそのメタデータ"
"が必要に ならない限り、変更されたメタデータをフラッシュしない。 例えば、 "
"st_atime や st_mtime (それぞれ最終アクセス時刻、最終修正時刻; B<stat>(2)  参"
"照) の変更はフラッシュを必要としない。 なぜならこれらはそれ以降のデータ読み込"
"みを正しく扱うために 必要ではないからである。 一方、ファイルサイズ "
"(B<ftruncate>(2)  では I<st_size>)  の変更はメタデータのフラッシュが必要であ"
"る。"

#. type: Plain text
#: build/C/man2/fsync.2:108
msgid ""
"The aim of B<fdatasync>()  is to reduce disk activity for applications that "
"do not require all metadata to be synchronized with the disk."
msgstr ""
"B<fdatasync>()  の狙いは、全てのメタデータをディスクと同期する必要のない アプ"
"リケーションに対して、ディスクアクセスを減らすことである。"

#. type: Plain text
#: build/C/man2/fsync.2:113
msgid ""
"On success, these system calls return zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールはゼロを返す。 エラーの場合、-1 が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/fsync.2:118
msgid "I<fd> is not a valid open file descriptor."
msgstr "I<fd> が有効なオープンされたディスクリプタでない。"

#. type: Plain text
#: build/C/man2/fsync.2:121
msgid "An error occurred during synchronization."
msgstr "同期操作の間にエラーが発生した。"

#. type: TP
#: build/C/man2/fsync.2:121
#, no-wrap
msgid "B<EROFS>, B<EINVAL>"
msgstr "B<EROFS>, B<EINVAL>"

#. type: Plain text
#: build/C/man2/fsync.2:125
msgid ""
"I<fd> is bound to a special file which does not support synchronization."
msgstr "I<fd> が同期操作をサポートしてない特殊なファイルを参照している。"

#. type: Plain text
#: build/C/man2/fsync.2:127
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: SH
#: build/C/man2/fsync.2:127
#, no-wrap
msgid "AVAILABILITY"
msgstr "可用性"

#.  POSIX.1-2001: It shall be defined to -1 or 0 or 200112L.
#.  -1: unavailable, 0: ask using sysconf().
#.  glibc defines them to 1.
#. type: Plain text
#: build/C/man2/fsync.2:140
msgid ""
"On POSIX systems on which B<fdatasync>()  is available, "
"B<_POSIX_SYNCHRONIZED_IO> is defined in I<E<lt>unistd.hE<gt>> to a value "
"greater than 0.  (See also B<sysconf>(3).)"
msgstr ""
"B<fdatasync>()  が利用可能な POSIX システムでは、 B<_POSIX_SYNCHRONIZED_IO> "
"が I<E<lt>unistd.hE<gt>> で 0 より大きな値に定義される (B<sysconf>(3)  参"
"照)。"

#. type: Plain text
#: build/C/man2/fsync.2:146
msgid ""
"On some UNIX systems (but not Linux), I<fd> must be a I<writable> file "
"descriptor."
msgstr ""
"(Linux はそうではないが) いくつかの UNIX システムでは\n"
"I<fd> がI<書き込み可能な>ファイルディスクリプタでなければならない。"

#. type: Plain text
#: build/C/man2/fsync.2:152
msgid ""
"In Linux 2.2 and earlier, B<fdatasync>()  is equivalent to B<fsync>(), and "
"so has no performance advantage."
msgstr ""
"Linux 2.2 以前では、 B<fdatasync>()  は B<fsync>()  と等価であり、性能面での"
"メリットはない。"

#. type: Plain text
#: build/C/man2/fsync.2:162
msgid ""
"The B<fsync>()  implementations in older kernels and lesser used filesystems "
"does not know how to flush disk caches.  In these cases disk caches need to "
"be disabled using B<hdparm>(8)  or B<sdparm>(8)  to guarantee safe operation."
msgstr ""
"古いカーネルやあまり使われていないファイルシステムの B<fsync>() の実装で"
"は、\n"
"ディスクキャッシュをフラッシュする方法が分からない場合がある。そのような場"
"合\n"
"には、安全に操作が行われることを保証するため、B<hdparm>(8) や B<sdparm>(8) "
"を\n"
"使ってディスクキャッシュを無効にする必要がある。"

#. type: Plain text
#: build/C/man2/fsync.2:171
msgid ""
"B<bdflush>(2), B<open>(2), B<sync>(2), B<sync_file_range>(2), B<hdparm>(8), "
"B<mount>(8), B<sync>(8), B<update>(8)"
msgstr ""
"B<bdflush>(2), B<open>(2), B<sync>(2), B<sync_file_range>(2), B<hdparm>(8), "
"B<mount>(8), B<sync>(8), B<update>(8)"

#. type: TH
#: build/C/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "GET_NPROCS"
msgstr "GET_NPROCS"

#. type: TH
#: build/C/man3/get_nprocs_conf.3:26
#, no-wrap
msgid "2012-03-20"
msgstr "2012-03-20"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:29
msgid "get_nprocs, get_nprocs_conf - get number of processors"
msgstr "get_nprocs, get_nprocs_conf - プロセッサ数を取得する"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:31 build/C/man2/sysinfo.2:19
msgid "B<#include E<lt>sys/sysinfo.hE<gt>>"
msgstr "B<#include E<lt>sys/sysinfo.hE<gt>>"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:33
msgid "B<int get_nprocs(void);>"
msgstr "B<int get_nprocs(void);>"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:35
msgid "B<int get_nprocs_conf(void);>"
msgstr "B<int get_nprocs_conf(void);>"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:39
msgid ""
"The function B<get_nprocs_conf>()  returns the number of processors "
"configured by the operating system."
msgstr ""
"B<get_nprocs_conf>() 関数は、オペレーティングシステムで\n"
"設定されているプロセッサ数を返す。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:46
msgid ""
"The function B<get_nprocs>()  returns the number of processors currently "
"available in the system.  This may be less than the number returned by "
"B<get_nprocs_conf>()  because processors may be offline (e.g., on "
"hotpluggable systems)."
msgstr ""
"B<get_nprocs>() 関数は、システムで現在利用可能なプロセッサ数を返す。\n"
"(例えば、ホットプラグが可能なシステムでは)\n"
"オフラインになっているプロセッサがある場合があるので、\n"
"この数は B<get_nprocs_conf>() が返す数より小さい場合がある。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:48
msgid "As given in DESCRIPTION."
msgstr "「説明」の節で説明した通りである。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:50 build/C/man3/getopt.3:350
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#.  glibc 2.15
#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:57
msgid ""
"The current implementation of these functions is rather expensive, since "
"they open and parse files in the I</sys> filesystem each time they are "
"called."
msgstr ""
"これらの関数の現在の実装はかなりコストがかかる実装になっている。\n"
"関数が呼ばれる度に I</sys> ファイルシステム内のファイルをオープンして\n"
"解析するようになっているからである。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:62
msgid ""
"The following B<sysconf>(3)  calls make use of the functions documented on "
"this page to return the same information."
msgstr ""
"以下の B<sysconf>(3) の呼び出しで、このページに書かれている関数を使った\n"
"場合に返されるのと同じ情報を得ることができる。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:66
#, no-wrap
msgid ""
"    np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"    np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"
msgstr ""
"    np = sysconf(_SC_NPROCESSORS_CONF);     /* processors configured */\n"
"    np = sysconf(_SC_NPROCESSORS_ONLN);     /* processors available */\n"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:73
msgid ""
"The following example shows how B<get_nprocs>()  and B<get_nprocs_conf>()  "
"can be used."
msgstr ""
"以下の例は、 B<get_nprocs>() と B<get_nprocs_conf>() が\n"
"どのように利用できるかを示すものである。"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:77
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>sys/sysinfo.hE<gt>\n"

#. type: Plain text
#: build/C/man3/get_nprocs_conf.3:86
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    return 0;\n"
"}\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    printf(\"This system has %d processors configured and \"\n"
"            \"%d processors available.\\en\",\n"
"            get_nprocs_conf(), get_nprocs());\n"
"    return 0;\n"
"}\n"

#. type: TH
#: build/C/man2/get_thread_area.2:8
#, no-wrap
msgid "GET_THREAD_AREA"
msgstr "GET_THREAD_AREA"

#. type: TH
#: build/C/man2/get_thread_area.2:8 build/C/man2/set_thread_area.2:8
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: Plain text
#: build/C/man2/get_thread_area.2:11
msgid "get_thread_area - get a thread-local storage (TLS) area"
msgstr "get_thread_area - スレッド局所記憶 (TLS) 領域を取り出す"

#. type: Plain text
#: build/C/man2/get_thread_area.2:15 build/C/man2/set_thread_area.2:15
msgid "B<#include E<lt>asm/ldt.hE<gt>>"
msgstr "B<#include E<lt>asm/ldt.hE<gt>>"

#. type: Plain text
#: build/C/man2/get_thread_area.2:17
msgid "B<int get_thread_area(struct user_desc *>I<u_info>B<);>"
msgstr "B<int get_thread_area(struct user_desc *>I<u_info>B<);>"

#. type: Plain text
#: build/C/man2/get_thread_area.2:20 build/C/man2/gettid.2:38
#: build/C/man2/set_thread_area.2:20 build/C/man2/sysctl.2:44
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:29
msgid ""
"B<get_thread_area>()  returns an entry in the current thread's thread-local "
"storage (TLS) array.  The index of the entry corresponds to the value of "
"I<u_info-E<gt>entry_number>, passed in by the user.  If the value is in "
"bounds, B<get_thread_area>()  copies the corresponding TLS entry into the "
"area pointed to by I<u_info>."
msgstr ""
"B<get_thread_area>()  は、カレントスレッドのスレッド局所記憶 (thread-local "
"storage; TLS) 配列の中のエントリを返す。 エントリのインデックスは、ユーザから"
"引き数として渡される I<u_info-E<gt>entry_number> の値に対応している。 値が範"
"囲内にある場合、 B<get_thread_info>()  は対応する TLS エントリを I<u_info> で"
"指された領域にコピーする。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:35
msgid ""
"B<get_thread_area>()  returns 0 on success.  Otherwise, it returns -1 and "
"sets I<errno> appropriately."
msgstr ""
"成功した場合、 B<get_thread_area>()  は 0 を返す。 そうでない場合、 -1 を返"
"し、 I<errno> に適切な値をセットする。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:39 build/C/man2/set_thread_area.2:56
msgid "I<u_info> is an invalid pointer."
msgstr "I<u_info> が不正なポインタである。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:42 build/C/man2/set_thread_area.2:53
msgid "I<u_info-E<gt>entry_number> is out of bounds."
msgstr "I<u_info-E<gt>entry_number> が範囲外である。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:46
msgid "A version of B<get_thread_area>()  first appeared in Linux 2.5.32."
msgstr "B<get_thread_area>()  は Linux 2.5.32 で初めて登場した。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:50
msgid ""
"B<get_thread_area>()  is Linux-specific and should not be used in programs "
"that are intended to be portable."
msgstr ""
"B<get_thread_area>()  は Linux 独自の関数であり、 移植を意図したプログラムで"
"は使用すべきではない。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:55
msgid ""
"Glibc does not provide a wrapper for this system call, since it is generally "
"intended for use only by threading libraries.  In the unlikely event that "
"you want to call it directly, use B<syscall>(2)."
msgstr ""
"このシステムコールは通常はスレッドライブラリでのみ使用されることを目的として"
"用意されているため、 glibc はこのシステムコールに対するラッパー関数を提供して"
"いない。おそらくないと思うが、このシステムコールを直接呼び出したい場合は "
"B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/get_thread_area.2:58
msgid "B<modify_ldt>(2), B<set_thread_area>(2)"
msgstr "B<modify_ldt>(2), B<set_thread_area>(2)"

#. type: TH
#: build/C/man3/getcwd.3:32
#, no-wrap
msgid "GETCWD"
msgstr "GETCWD"

#. type: Plain text
#: build/C/man3/getcwd.3:35
msgid "getcwd, getwd, get_current_dir_name - get current working directory"
msgstr ""
"getcwd, getwd, get_current_dir_name - カレントワーキングディレクトリ名の取得"

#. type: Plain text
#: build/C/man3/getcwd.3:40
#, no-wrap
msgid "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"
msgstr "B<char *getcwd(char *>I<buf>B<, size_t >I<size>B<);>\n"

#. type: Plain text
#: build/C/man3/getcwd.3:42
#, no-wrap
msgid "B<char *getwd(char *>I<buf>B<);>\n"
msgstr "B<char *getwd(char *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man3/getcwd.3:44
#, no-wrap
msgid "B<char *get_current_dir_name(void);>\n"
msgstr "B<char *get_current_dir_name(void);>\n"

#. type: Plain text
#: build/C/man3/getcwd.3:52
msgid "B<get_current_dir_name>():"
msgstr "B<get_current_dir_name>():"

#. type: Plain text
#: build/C/man3/getcwd.3:57
msgid "B<getwd>():"
msgstr "B<getwd>():"

#. type: Plain text
#: build/C/man3/getcwd.3:67 build/C/man3/ualarm.3:50 build/C/man3/usleep.3:59
#: build/C/man2/vfork.2:54
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700)\n"
msgstr ""
"_BSD_SOURCE ||\n"
"    (_XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"        _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED) &&\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700)\n"

#. type: Plain text
#: build/C/man3/getcwd.3:72 build/C/man3/getdtablesize.3:54
#: build/C/man2/getpagesize.2:52 build/C/man3/ualarm.3:55
#: build/C/man3/usleep.3:64 build/C/man2/vfork.2:59
msgid ""
"Before glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"glibc 2.12 より前: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || "
"_XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/getcwd.3:82
msgid ""
"These functions return a null-terminated string containing an absolute "
"pathname that is the current working directory of the calling process.  The "
"pathname is returned as the function result and via the argument I<buf>, if "
"present."
msgstr ""
"これらの関数は、呼び出したプロセスのカレントワーキングディレクトリの 絶対パス"
"名 (absolute pathname) が入った文字列を返す。 返される文字列は NULL で終端さ"
"れる。 パス名は関数の結果として返され、引数 I<buf> がある場合は I<buf> 経由で"
"も返される。"

#. type: Plain text
#: build/C/man3/getcwd.3:90
msgid ""
"The B<getcwd>()  function copies an absolute pathname of the current working "
"directory to the array pointed to by I<buf>, which is of length I<size>."
msgstr ""
"B<getcwd>()  関数はカレントワーキングディレクトリの絶対パス名を I<buf> で示さ"
"れた I<size> 長の配列にコピーする。"

#. type: Plain text
#: build/C/man3/getcwd.3:100
msgid ""
"If the length of the absolute pathname of the current working directory, "
"including the terminating null byte, exceeds I<size> bytes, NULL is "
"returned, and I<errno> is set to B<ERANGE>; an application should check for "
"this error, and allocate a larger buffer if necessary."
msgstr ""
"終端の NULL バイトも含めた、カレントワーキングディレクトリの 絶対パス名の長さ"
"が I<size> バイトを超えている場合は、返り値として NULL が返り I<errno> に "
"B<ERANGE> がセットされる。 アプリケーションはこのエラーをチェックし、 必要に"
"応じてより長いバッファを用意すべきである。"

#. type: Plain text
#: build/C/man3/getcwd.3:118
msgid ""
"As an extension to the POSIX.1-2001 standard, Linux (libc4, libc5, glibc)  "
"B<getcwd>()  allocates the buffer dynamically using B<malloc>(3)  if I<buf> "
"is NULL.  In this case, the allocated buffer has the length I<size> unless "
"I<size> is zero, when I<buf> is allocated as big as necessary.  The caller "
"should B<free>(3)  the returned buffer."
msgstr ""
"POSIX.1-2001 標準の拡張として、 Linux (libc4, libc5, glibc) では I<buf> が "
"NULL の場合、 B<getcwd>()  は必要なバッファを B<malloc>(3)  を用いて動的に割"
"り当てる。 この場合、 I<size> が 0 の場合を除き、バッファの長さは I<size> と"
"なる。 I<size> が 0 の場合には必要な大きさが確保される。 呼び出し側で、返され"
"たバッファを B<free>(3)  すべきである。"

#. type: Plain text
#: build/C/man3/getcwd.3:131
msgid ""
"B<get_current_dir_name>()  will B<malloc>(3)  an array big enough to hold "
"the absolute pathname of the current working directory.  If the environment "
"variable B<PWD> is set, and its value is correct, then that value will be "
"returned.  The caller should B<free>(3)  the returned buffer."
msgstr ""
"B<get_current_dir_name>()  はカレントワーキングディレクトリの絶対パス名を収め"
"るのに 十分な大きさの配列を B<malloc>(3)  で獲得する。環境変数 B<PWD> が設定"
"されておりその値が正しければ、その値が返される。 呼び出し側で、返されたバッ"
"ファを B<free>(3)  すべきである。"

#. type: Plain text
#: build/C/man3/getcwd.3:156
msgid ""
"B<getwd>()  does not B<malloc>(3)  any memory.  The I<buf> argument should "
"be a pointer to an array at least B<PATH_MAX> bytes long.  If the length of "
"the absolute pathname of the current working directory, including the "
"terminating null byte, exceeds B<PATH_MAX> bytes, NULL is returned, and "
"I<errno> is set to B<ENAMETOOLONG>.  (Note that on some systems, B<PATH_MAX> "
"may not be a compile-time constant; furthermore, its value may depend on the "
"filesystem, see B<pathconf>(3).)  For portability and security reasons, use "
"of B<getwd>()  is deprecated."
msgstr ""
"B<getwd>()  は B<malloc>(3)  によるメモリ獲得を一切行なわない。 I<buf> 引数は"
"少なくとも B<PATH_MAX> バイトの長さを持つ配列へのポインタである必要がある。 "
"終端の NULL バイトも含めた、カレントワーキングディレクトリの 絶対パス名の長さ"
"が B<PATH_MAX> バイトを超えている場合、 NULL が返され、 I<errno> に "
"B<ENAMETOOLONG> が設定される。 (システムによっては、 B<PATH_MAX> は必ずしもコ"
"ンパイル時に決まる定数ではない点に注意すること。 また、ファイルシステムに依存"
"する場合もある。 B<pathconf>(3)  を参照。)  移植性とセキュリティ上の理由か"
"ら、 B<getwd>()  の利用は推奨されない。"

#. type: Plain text
#: build/C/man3/getcwd.3:165
msgid ""
"On success, these functions return a pointer to a string containing the "
"pathname of the current working directory.  In the case B<getcwd>()  and "
"B<getwd>()  this is the same value as I<buf>."
msgstr ""
"成功すると、これらの関数はカレントワーキングディレクトリの絶対パス名 が入った"
"文字列へのポインタを返す。 B<getcwd>()  と B<getwd>()  の場合、返り値は "
"I<buf> と同じ値になる。"

#. type: Plain text
#: build/C/man3/getcwd.3:172
msgid ""
"On failure, these functions return NULL, and I<errno> is set to indicate the "
"error.  The contents of the array pointed to by I<buf> are undefined on "
"error."
msgstr ""
"失敗した場合、これらの関数は NULL を返し、 I<errno> にエラーを示す値を設定す"
"る。 I<buf> が指す配列の内容は未定義である。"

#. type: Plain text
#: build/C/man3/getcwd.3:176
msgid "Permission to read or search a component of the filename was denied."
msgstr "ファイル名の構成要素に対する読み込みあるいは検索の権限がない。"

#. type: Plain text
#: build/C/man3/getcwd.3:180
msgid "I<buf> points to a bad address."
msgstr "I<buf> が不正なアドレスを指している。"

#. type: Plain text
#: build/C/man3/getcwd.3:187
msgid "The I<size> argument is zero and I<buf> is not a null pointer."
msgstr "I<size> 引数が 0 かつ、 I<buf> 引数が NULL ポインタでない。"

#. type: TP
#: build/C/man3/getcwd.3:187
#, no-wrap
msgid "EINVAL"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/getcwd.3:192
msgid "B<getwd>(): I<buf> is NULL."
msgstr "B<getwd>(): I<buf> が NULL である。"

#. type: TP
#: build/C/man3/getcwd.3:192
#, no-wrap
msgid "ENAMETOOLONG"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/getcwd.3:198
msgid ""
"B<getwd>(): The size of the null-terminated absolute pathname string exceeds "
"B<PATH_MAX> bytes."
msgstr ""
"B<getwd>(): 絶対パス名が入った NULL 終端された文字列の長さが B<PATH_MAX> バイ"
"トを超えている。"

#. type: Plain text
#: build/C/man3/getcwd.3:201
msgid "The current working directory has been unlinked."
msgstr "カレントワーキングディレクトリが削除されている。"

#. type: TP
#: build/C/man3/getcwd.3:201 build/C/man3/getlogin.3:114
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/getcwd.3:208
msgid ""
"The I<size> argument is less than the length of the absolute pathname of the "
"working directory, including the terminating null byte.  You need to "
"allocate a bigger array and try again."
msgstr ""
"I<size> 引数の値がワーキングディレクトリの絶対パス名の長さより小さい。 長さに"
"は文字列の終端バイトも含まれる。 より大きい配列を確保してもう一度実行する必要"
"がある。"

#. type: Plain text
#: build/C/man3/getcwd.3:216
msgid ""
"B<getcwd>()  conforms to POSIX.1-2001.  Note however that POSIX.1-2001 "
"leaves the behavior of B<getcwd>()  unspecified if I<buf> is NULL."
msgstr ""
"B<getcwd>()  は POSIX.1-2001 に準拠している。 POSIX.1-2001 は、 I<buf> が "
"NULL の場合の B<getcwd>()  の動作を規定しないままとしている。"

#. type: Plain text
#: build/C/man3/getcwd.3:227
msgid ""
"B<getwd>()  is present in POSIX.1-2001, but marked LEGACY.  POSIX.1-2008 "
"removes the specification of B<getwd>().  Use B<getcwd>()  instead.  "
"POSIX.1-2001 does not define any errors for B<getwd>()."
msgstr ""
"B<getwd>()  は POSIX.1-2001 に存在しているが、「過去の名残(LEGACY)」とされて"
"いる。 POSIX.1-2008 では、 B<getwd>()  の仕様が削除されている。 代わりに "
"B<getcwd>()  を使うこと。 POSIX.1-2001 は B<getwd>()  に関するエラーを定義し"
"ていない。"

#. type: Plain text
#: build/C/man3/getcwd.3:230
msgid "B<get_current_dir_name>()  is a GNU extension."
msgstr "B<get_current_dir_name>()  は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/getcwd.3:241
msgid ""
"Under Linux, the function B<getcwd>()  is a system call (since 2.1.92).  On "
"older systems it would query I</proc/self/cwd>.  If both system call and "
"proc filesystem are missing, a generic implementation is called.  Only in "
"that case can these calls fail under Linux with B<EACCES>."
msgstr ""
"Linux では (2.1.92 以降)、 B<getcwd>()  はシステムコールである。 古いシステム"
"では I</proc/self/cwd> を参照する。 システムコールも proc ファイルシステムも"
"ない場合、 一般的な実装が呼び出される。 この場合においてのみ、(Linux では) こ"
"の関数は B<EACCES> で失敗する可能性がある。"

#. type: Plain text
#: build/C/man3/getcwd.3:249
msgid ""
"These functions are often used to save the location of the current working "
"directory for the purpose of returning to it later.  Opening the current "
"directory (\".\") and calling B<fchdir>(2)  to return is usually a faster "
"and more reliable alternative when sufficiently many file descriptors are "
"available, especially on platforms other than Linux."
msgstr ""
"これらの関数はしばしばカレントワーキングディレクトリの位置を保存し、 後で戻っ"
"てくるために利用される。 未使用のファイルディスクリプタが十分ある場合は、 現"
"在のディレクトリ (\".\") を開いて B<fchdir>(2)  を呼び出すほうが普通は高速で"
"信頼性がある。 特に Linux 以外のプラットフォームの場合はそうである。"

#. type: Plain text
#: build/C/man3/getcwd.3:256
msgid ""
"B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), B<malloc>(3)"
msgstr ""
"B<chdir>(2), B<fchdir>(2), B<open>(2), B<unlink>(2), B<free>(3), B<malloc>(3)"

#. type: TH
#: build/C/man2/getdomainname.2:29
#, no-wrap
msgid "GETDOMAINNAME"
msgstr "GETDOMAINNAME"

#. type: TH
#: build/C/man2/getdomainname.2:29
#, no-wrap
msgid "2012-10-25"
msgstr "2012-10-25"

#. type: Plain text
#: build/C/man2/getdomainname.2:32
msgid "getdomainname, setdomainname - get/set NIS domain name"
msgstr "getdomainname, setdomainname - NIS ドメイン名の取得・設定をする"

#. type: Plain text
#: build/C/man2/getdomainname.2:36
msgid "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int getdomainname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/getdomainname.2:38
msgid "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int setdomainname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/getdomainname.2:47
msgid "B<getdomainname>(), B<setdomainname>():"
msgstr "B<getdomainname>(), B<setdomainname>():"

#. type: Plain text
#: build/C/man2/getdomainname.2:49 build/C/man3/gethostid.3:54
#: build/C/man2/gethostname.2:60 build/C/man3/getusershell.3:55
msgid "_BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr "_BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: build/C/man2/getdomainname.2:54
msgid ""
"These functions are used to access or to change the NIS domain name of the "
"host system."
msgstr ""
"これらの関数は、ホストシステムの NIS ドメイン名を取得・変更するために使われ"
"る。"

#. type: Plain text
#: build/C/man2/getdomainname.2:65
msgid ""
"B<setdomainname>()  sets the domain name to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""
"B<setdomainname>()  は、ドメイン名を、文字配列 I<name> で指定された値に設定す"
"る。 引き数 I<len> には、 I<name> のバイト数を指定する (そのため、 I<name> で"
"は文字列終端の NULL バイトは必要ない)。"

#. type: Plain text
#: build/C/man2/getdomainname.2:75
msgid ""
"B<getdomainname>()  returns the null-terminated domain name in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"domain name requires more than I<len> bytes, B<getdomainname>()  returns the "
"first I<len> bytes (glibc) or gives an error (libc)."
msgstr ""
"B<getdomainname>()  は、NULL 終端されたドメイン名を、 I<len> バイトの長さの文"
"字配列 I<name> に格納して返す。 NULL 終端されたドメイン名が I<len> バイトより"
"長い場合、 B<getdomainname>()  は、(glibc では) 始めの I<len> バイトを返し、"
"(libc では) エラーとなる。"

#. type: Plain text
#: build/C/man2/getdomainname.2:83
msgid "B<setdomainname>()  can fail with the following errors:"
msgstr "B<setdomainname>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getdomainname.2:87
msgid "I<name> pointed outside of user address space."
msgstr "I<name> がユーザアドレス空間の外を指した。"

#. type: Plain text
#: build/C/man2/getdomainname.2:91
msgid "I<len> was negative or too large."
msgstr "I<len> が負であるか、長すぎる。"

#. type: Plain text
#: build/C/man2/getdomainname.2:96
msgid ""
"the caller is unprivileged (Linux: does not have the B<CAP_SYS_ADMIN> "
"capability)."
msgstr ""
"B<setdomainname>()  において、呼び出した人に特権がない (Linux では "
"B<CAP_SYS_ADMIN> ケーパビリティ (capability) がない)。"

#. type: Plain text
#: build/C/man2/getdomainname.2:99
msgid "B<getdomainname>()  can fail with the following errors:"
msgstr "B<getdomainname>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getdomainname.2:110
msgid ""
"For B<getdomainname>()  under libc: I<name> is NULL or I<name> is longer "
"than I<len> bytes."
msgstr ""
"libc での B<getdomainname>()  において、 I<name> が NULL ポインタであるか、 "
"I<len> バイトより長い。"

#.  But they appear on most systems...
#. type: Plain text
#: build/C/man2/getdomainname.2:113
msgid "POSIX does not specify these calls."
msgstr "POSIX では、これら関数は定義されていない。"

#. type: Plain text
#: build/C/man2/getdomainname.2:117
msgid ""
"Since Linux 1.0, the limit on the length of a domain name, including the "
"terminating null byte, is 64 bytes.  In older kernels, it was 8 bytes."
msgstr ""
"Linux 1.0 以降では、ドメイン名の長さの上限は 終端の NULL バイトを含めて 64 バ"
"イトである。 もっと古いカーネルでは 8 バイトであった。"

#. type: Plain text
#: build/C/man2/getdomainname.2:127
msgid ""
"On most Linux architectures (including x86), there is no B<getdomainname>()  "
"system call; instead, glibc implements B<getdomainname>()  as a library "
"function that returns a copy of the I<domainname> field returned from a call "
"to B<uname>(2)."
msgstr ""
"(x86 を含む) Linux のほとんどのアーキテクチャでは、 B<getdomainname>()  とい"
"うシステムコールは存在しない。 その代わり、glibc で B<getdomainname>()  がラ"
"イブラリ関数として実装されており、この関数は B<uname>(2)  の呼び出しで返され"
"た I<domainname> フィールドのコピーを返す。"

#. type: Plain text
#: build/C/man2/getdomainname.2:131
msgid "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"
msgstr "B<gethostname>(2), B<sethostname>(2), B<uname>(2)"

#. type: TH
#: build/C/man3/getdtablesize.3:27
#, no-wrap
msgid "GETDTABLESIZE"
msgstr "GETDTABLESIZE"

#. type: TH
#: build/C/man3/getdtablesize.3:27
#, no-wrap
msgid "2013-02-05"
msgstr "2013-02-05"

#. type: Plain text
#: build/C/man3/getdtablesize.3:30
msgid "getdtablesize - get descriptor table size"
msgstr "getdtablesize - ディスクリプタテーブルのサイズを取得する"

#. type: Plain text
#: build/C/man3/getdtablesize.3:34
msgid "B<int getdtablesize(void);>"
msgstr "B<int getdtablesize(void);>"

#. type: Plain text
#: build/C/man3/getdtablesize.3:41
msgid "B<getdtablesize>():"
msgstr "B<getdtablesize>():"

#. type: Plain text
#: build/C/man3/getdtablesize.3:49 build/C/man2/getpagesize.2:47
#, no-wrap
msgid ""
"_BSD_SOURCE ||\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"
msgstr ""
"_BSD_SOURCE ||\n"
"    !(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600)\n"

#. type: Plain text
#: build/C/man3/getdtablesize.3:61
msgid ""
"B<getdtablesize>()  returns the maximum number of files a process can have "
"open, one more than the largest possible value for a file descriptor."
msgstr ""
"B<getdtablesize>()  は 1 つのプロセスのオープンできるファイル数の最大値を返"
"す。 返り値はファイルディスクリプタの取り得る最大値より 1 大きい値である。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:63
msgid "The current limit on the number of open files per process."
msgstr "プロセス毎にオープンできるファイル数の現在の制限値。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:69
msgid ""
"On Linux, B<getdtablesize>()  can return any of the errors described for "
"B<getrlimit>(2); see NOTES below."
msgstr ""
"Linux では、 B<getdtablesize>()  は B<getrlimit>(2)  で説明されているエラーを"
"返すことがある。 下記の「注意」を参照のこと。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:77
msgid ""
"SVr4, 4.4BSD (the B<getdtablesize>()  function first appeared in 4.2BSD).  "
"It is not specified in POSIX.1-2001; portable applications should employ "
"I<sysconf(_SC_OPEN_MAX)> instead of this call."
msgstr ""
"SVr4, 4.4BSD (B<getdtablesize>()  関数は 4.2BSD で最初に現われた)。 これは "
"POSIX.1-2001 で規定されていないので、 移植性のあるアプリケーションはこの呼び"
"出しの代わりに I<sysconf(_SC_OPEN_MAX)> を使うべきである。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:90
msgid ""
"B<getdtablesize>()  is implemented as a libc library function.  The glibc "
"version calls B<getrlimit>(2)  and returns the current B<RLIMIT_NOFILE> "
"limit, or B<OPEN_MAX> when that fails.  The libc4 and libc5 versions return "
"B<OPEN_MAX> (set to 256 since Linux 0.98.4)."
msgstr ""
"B<getdtablesize>()  は libc のライブラリ関数として実装されている。glibc 版は "
"B<getrlimit>(2)  を呼び出して、現在の B<RLIMIT_NOFILE> を返す。 呼び出しに失"
"敗した場合は B<OPEN_MAX> を返す。 libc4 と libc5 では B<OPEN_MAX> (Linux "
"0.98.4 以降では 256 に設定されている)  を返す。"

#. type: Plain text
#: build/C/man3/getdtablesize.3:95
msgid "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"
msgstr "B<close>(2), B<dup>(2), B<getrlimit>(2), B<open>(2)"

#. type: TH
#: build/C/man3/gethostid.3:29
#, no-wrap
msgid "GETHOSTID"
msgstr "GETHOSTID"

#. type: Plain text
#: build/C/man3/gethostid.3:32
msgid ""
"gethostid, sethostid - get or set the unique identifier of the current host"
msgstr "gethostid, sethostid - 現在のホストの固有の識別子を取得/設定する"

#. type: Plain text
#: build/C/man3/gethostid.3:36
msgid "B<long gethostid(void);>"
msgstr "B<long gethostid(void);>"

#. type: Plain text
#: build/C/man3/gethostid.3:38
msgid "B<int sethostid(long >I<hostid>B<);>"
msgstr "B<int sethostid(long >I<hostid>B<);>"

#. type: Plain text
#: build/C/man3/gethostid.3:47
msgid "B<gethostid>():"
msgstr "B<gethostid>():"

#. type: Plain text
#: build/C/man3/gethostid.3:52
msgid "B<sethostid>():"
msgstr "B<sethostid>():"

#. type: Plain text
#: build/C/man3/gethostid.3:67
msgid ""
"B<gethostid>()  and B<sethostid>()  respectively get or set a unique 32-bit "
"identifier for the current machine.  The 32-bit identifier is intended to be "
"unique among all UNIX systems in existence.  This normally resembles the "
"Internet address for the local machine, as returned by B<gethostbyname>(3), "
"and thus usually never needs to be set."
msgstr ""
"B<gethostid>()  と B<sethostid>()  は、それぞれ、現在使用しているホストに固有"
"の 32 ビットの識別子の 取得/設定を行う。 この 32 ビットの識別子は、現在存在し"
"ている全ての UNIX システム の中で唯一になるように決められる。通常は "
"B<gethostbyname>(3)  により返されるローカルマシンの Internet アドレスが代わり"
"に使用され、 普通は識別子をあえて設定する必要はない。"

#. type: Plain text
#: build/C/man3/gethostid.3:71
msgid "The B<sethostid>()  call is restricted to the superuser."
msgstr "B<sethostid>()  はスーパーユーザしか使用できない。"

#. type: Plain text
#: build/C/man3/gethostid.3:75
msgid ""
"B<gethostid>()  returns the 32-bit identifier for the current host as set by "
"B<sethostid>()."
msgstr ""
"B<gethostid>()  は、 B<sethostid>()  によって設定された、現在使用しているホス"
"トの 32 ビットの識別子の値を返す。"

#. type: Plain text
#: build/C/man3/gethostid.3:81
msgid ""
"On success, B<sethostid>()  returns 0; on error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sethostid>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/gethostid.3:84
msgid "B<sethostid>()  can fail with the following errors:"
msgstr "B<sethostid>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man3/gethostid.3:88
msgid ""
"The caller did not have permission to write to the file used to store the "
"host ID."
msgstr ""
"呼び出し元がホスト ID を保存するのに使用されるファイルへの 書き込み許可を持っ"
"ていなかった。"

#. type: Plain text
#: build/C/man3/gethostid.3:92
msgid ""
"The calling process's effective user or group ID is not the same as its "
"corresponding real ID."
msgstr "呼び出し元プロセスの実効 UID/GID が対応する実 UID/GID と同じではない。"

#. type: Plain text
#: build/C/man3/gethostid.3:102
msgid ""
"4.2BSD; these functions were dropped in 4.4BSD.  SVr4 includes B<gethostid>"
"()  but not B<sethostid>().  POSIX.1-2001 specifies B<gethostid>()  but not "
"B<sethostid>()."
msgstr ""
"4.2BSD。4.4BSD ではこれらの関数はなくなった。 SVr4 には B<gethostid>()  は含"
"まれているが、 B<sethostid>()  は含まれていない。 POSIX.1-2001 では、 "
"B<gethostid>()  は規定されているが、 B<sethostid>()  は規定されていない。"

#.  libc5 used /etc/hostid; libc4 didn't have these functions
#. type: Plain text
#: build/C/man3/gethostid.3:111
msgid ""
"In the glibc implementation, the I<hostid> is stored in the file I</etc/"
"hostid>.  (In glibc versions before 2.2, the file I</var/adm/hostid> was "
"used.)"
msgstr ""
"glibc の実装では、 I<hostid> はファイル I</etc/hostid> に保存される (バージョ"
"ン 2.2 より前の glibc では、 I</var/adm/hostid> が使用されていた)。"

#. type: Plain text
#: build/C/man3/gethostid.3:122
msgid ""
"In the glibc implementation, if B<gethostid>()  cannot open the file "
"containing the host ID, then it obtains the hostname using B<gethostname>"
"(2), passes that hostname to B<gethostbyname_r>(3)  in order to obtain the "
"host's IPv4 address, and returns a value obtained by bit-twiddling the IPv4 "
"address.  (This value may not be unique.)"
msgstr ""
"glibc の実装では、ホスト ID を保存したファイルを オープンできなかった場合、 "
"B<gethostid>()  は B<gethostname>(2)  を使ってホスト名を入手し、そのホスト名"
"を B<gethostbyname_r>(3)  に渡しホストの IPv4 アドレスを取得して、 その IPv4 "
"アドレスのビット入れ替えを行った値を返す。"

#. type: Plain text
#: build/C/man3/gethostid.3:124
msgid "It is impossible to ensure that the identifier is globally unique."
msgstr "識別子が世界中で一意であることを保証することはできない。"

#. type: Plain text
#: build/C/man3/gethostid.3:127
msgid "B<hostid>(1), B<gethostbyname>(3)"
msgstr "B<hostid>(1), B<gethostbyname>(3)"

#. type: TH
#: build/C/man2/gethostname.2:32
#, no-wrap
msgid "GETHOSTNAME"
msgstr "GETHOSTNAME"

#. type: TH
#: build/C/man2/gethostname.2:32
#, no-wrap
msgid "2010-09-26"
msgstr "2010-09-26"

#. type: Plain text
#: build/C/man2/gethostname.2:35
msgid "gethostname, sethostname - get/set hostname"
msgstr "gethostname, sethostname - ホスト名の取得・設定をする"

#. type: Plain text
#: build/C/man2/gethostname.2:39
msgid "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int gethostname(char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/gethostname.2:41
msgid "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"
msgstr "B<int sethostname(const char *>I<name>B<, size_t >I<len>B<);>"

#. type: Plain text
#: build/C/man2/gethostname.2:50
msgid "B<gethostname>():"
msgstr "B<gethostname>():"

#. type: Plain text
#: build/C/man2/gethostname.2:53
msgid "Since glibc 2.12: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "glibc 2.12 以降: _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man2/gethostname.2:55
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/gethostname.2:58
msgid "B<sethostname>():"
msgstr "B<sethostname>():"

#. type: Plain text
#: build/C/man2/gethostname.2:66
msgid ""
"These system calls are used to access or to change the hostname of the "
"current processor."
msgstr ""
"これらのシステムコールは、現在のプロセッサのホスト名を取得・変更するために 使"
"用される。"

#. type: Plain text
#: build/C/man2/gethostname.2:77
msgid ""
"B<sethostname>()  sets the hostname to the value given in the character "
"array I<name>.  The I<len> argument specifies the number of bytes in "
"I<name>.  (Thus, I<name> does not require a terminating null byte.)"
msgstr ""
"B<sethostname>()  は、ホスト名を、文字配列 I<name> で指定された値に設定す"
"る。 引き数 I<len> には、 I<name> のバイト数を指定する (そのため、 I<name> で"
"は文字列終端の NULL バイトは必要ない)。"

#. type: Plain text
#: build/C/man2/gethostname.2:89
msgid ""
"B<gethostname>()  returns the null-terminated hostname in the character "
"array I<name>, which has a length of I<len> bytes.  If the null-terminated "
"hostname is too large to fit, then the name is truncated, and no error is "
"returned (but see NOTES below).  POSIX.1-2001 says that if such truncation "
"occurs, then it is unspecified whether the returned buffer includes a "
"terminating null byte."
msgstr ""
"B<gethostname>()  は、NULL 終端されたホスト名を、 I<len> バイトの長さの文字配"
"列 I<name> に格納して返す。 NULL 終端されたホスト名が格納先のバッファよりも長"
"い場合は、 ホスト名は切り詰められ、エラーは返されない (下記の「注意」の節を参"
"照)。 POSIX.1-2001 では、結果の切り詰めが発生した場合に、 返されたバッファに"
"終端の NULL バイトが含まれているかどうかは 規定されていない。"

#. type: Plain text
#: build/C/man2/gethostname.2:99
msgid "I<name> is an invalid address."
msgstr "I<name> が不正なアドレスである。"

#.  Can't occur for gethostbyname() wrapper, since 'len' has an
#.  unsigned type; can occur for the underlying system call.
#. type: Plain text
#: build/C/man2/gethostname.2:109
msgid ""
"I<len> is negative or, for B<sethostname>(), I<len> is larger than the "
"maximum allowed size."
msgstr ""
"I<len> が負である。 B<sethostname>()  において I<len> が許容された最大サイズ"
"を越えている。"

#. type: Plain text
#: build/C/man2/gethostname.2:117
msgid ""
"(glibc B<gethostname>())  I<len> is smaller than the actual size.  (Before "
"version 2.1, glibc uses B<EINVAL> for this case.)"
msgstr ""
"(glibc B<gethostname>()  で)  I<len> が実際のホスト名の長さよりも小さい "
"(glibc バージョン 2.1 より前では、この状況で B<EINVAL> が使用される)。"

#. type: Plain text
#: build/C/man2/gethostname.2:124
msgid ""
"For B<sethostname>(), the caller did not have the B<CAP_SYS_ADMIN> "
"capability."
msgstr ""
"B<sethostname>()  において、呼び出した人が B<CAP_SYS_ADMIN> ケーパビリティ "
"(capability) を持っていなかった。"

#. type: Plain text
#: build/C/man2/gethostname.2:130
msgid ""
"SVr4, 4.4BSD (these interfaces first appeared in 4.2BSD).  POSIX.1-2001 "
"specifies B<gethostname>()  but not B<sethostname>()."
msgstr ""
"SVr4, 4.4BSD (これらのインタフェースは 4.2BSD で初めて登場した)。 "
"POSIX.1-2001 では B<gethostname>()  については規定しているが、 B<sethostname>"
"()  は規定していない。"

#. type: Plain text
#: build/C/man2/gethostname.2:140
msgid ""
"SUSv2 guarantees that \"Host names are limited to 255 bytes\".  POSIX.1-2001 "
"guarantees that \"Host names (not including the terminating null byte) are "
"limited to B<HOST_NAME_MAX> bytes\".  On Linux, B<HOST_NAME_MAX> is defined "
"with the value 64, which has been the limit since Linux 1.0 (earlier kernels "
"imposed a limit of 8 bytes)."
msgstr ""
"SUSv2 では「ホスト名が 255 バイトに制限される」ことを保証している。 "
"POSIX.1-2001 では「ホスト名 (終端の NULL バイトは含まない) が "
"B<HOST_NAME_MAX> バイトに制限される」ことを保証している。 Linux では、 "
"B<HOST_NAME_MAX> は 64 に定義されており、 Linux 1.0 以降ではこれが上限となっ"
"てきた (もっと古いカーネルでは 8 バイトの上限が適用されていた)。"

#. type: Plain text
#: build/C/man2/gethostname.2:163
msgid ""
"The GNU C library does not employ the B<gethostname>()  system call; "
"instead, it implements B<gethostname>()  as a library function that calls "
"B<uname>(2)  and copies up to I<len> bytes from the returned I<nodename> "
"field into I<name>.  Having performed the copy, the function then checks if "
"the length of the I<nodename> was greater than or equal to I<len>, and if it "
"is, then the function returns -1 with I<errno> set to B<ENAMETOOLONG>; in "
"this case, a terminating null byte is not included in the returned I<name>."
msgstr ""
"GNU C ライブラリは、 B<gethostname>()  システムコールを利用していない。その代"
"わり、 B<gethostname>()  をライブラリ関数として実装しており、 この関数は "
"B<uname>(2)  を呼び出し、 B<uname>(2)  が返した I<nodename> フィールド (の最"
"大 I<len> バイト) を I<name> にコピーする。 コピーを行った際に、この関数は "
"I<nodename> の長さが I<len> 以上かの確認を行い、 I<len> 以上の場合には -1 を"
"返し、 I<errno> に B<ENAMETOOLONG> を設定する。 この場合、返された I<name> に"
"は終端の NULL バイトは含まれない。"

#.  At least glibc 2.0 and 2.1, older versions not checked
#. type: Plain text
#: build/C/man2/gethostname.2:176
msgid ""
"Versions of glibc before 2.2 handle the case where the length of the "
"I<nodename> was greater than or equal to I<len> differently: nothing is "
"copied into I<name> and the function returns -1 with I<errno> set to "
"B<ENAMETOOLONG>."
msgstr ""
"バージョン 2.2 より前の glibc では、 I<nodename> の長さが I<len> 以上の場合の"
"扱いが異なる; I<len> 以上の場合には、 I<name> には何もコピーせず、関数は -1 "
"を返し、 I<errno> に B<ENAMETOOLONG> を設定する。"

#. type: Plain text
#: build/C/man2/gethostname.2:180
msgid "B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"
msgstr "B<getdomainname>(2), B<setdomainname>(2), B<uname>(2)"

#. type: TH
#: build/C/man3/getlogin.3:28
#, no-wrap
msgid "GETLOGIN"
msgstr "GETLOGIN"

#. type: TH
#: build/C/man3/getlogin.3:28
#, no-wrap
msgid "2013-04-19"
msgstr "2013-04-19"

#. type: Plain text
#: build/C/man3/getlogin.3:31
msgid "getlogin, getlogin_r, cuserid - get username"
msgstr "getlogin, getlogin_r, cuserid - ユーザー名を取得する"

#. type: Plain text
#: build/C/man3/getlogin.3:35
msgid "B<char *getlogin(void);>"
msgstr "B<char *getlogin(void);>"

#. type: Plain text
#: build/C/man3/getlogin.3:37
msgid "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"
msgstr "B<int getlogin_r(char *>I<buf>B<, size_t >I<bufsize>B<);>"

#. type: Plain text
#: build/C/man3/getlogin.3:39
msgid "B<#include E<lt>stdio.hE<gt>>"
msgstr "B<#include E<lt>stdio.hE<gt>>"

#. type: Plain text
#: build/C/man3/getlogin.3:41
msgid "B<char *cuserid(char *>I<string>B<);>"
msgstr "B<char *cuserid(char *>I<string>B<);>"

#. type: Plain text
#: build/C/man3/getlogin.3:49
msgid "B<getlogin_r>(): _REENTRANT || _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"
msgstr "B<getlogin_r>(): _REENTRANT || _POSIX_C_SOURCE\\ E<gt>=\\ 199506L"

#. type: Plain text
#: build/C/man3/getlogin.3:52
msgid "B<cuserid>(): _XOPEN_SOURCE"
msgstr "B<cuserid>(): _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/getlogin.3:61
msgid ""
"B<getlogin>()  returns a pointer to a string containing the name of the user "
"logged in on the controlling terminal of the process, or a null pointer if "
"this information cannot be determined.  The string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<cuserid>()."
msgstr ""
"B<getlogin>()  は、現在のプロセスの制御端末にログインしているユーザー名の文字"
"列への ポインタを返す。ユーザー名が決定できない場合は NULL ポインタを返す。 "
"文字列は静的領域に割り当てられており、この後でこの関数や B<cuserid>()  が呼び"
"出された際に上書きされることがある。"

#. type: Plain text
#: build/C/man3/getlogin.3:67
msgid ""
"B<getlogin_r>()  returns this same username in the array I<buf> of size "
"I<bufsize>."
msgstr ""
"B<getlogin_r>()  は、上記の同じユーザ名を、大きさ I<bufsize> の配列 I<buf> に"
"入れて返す。"

#. type: Plain text
#: build/C/man3/getlogin.3:79
msgid ""
"B<cuserid>()  returns a pointer to a string containing a username associated "
"with the effective user ID of the process.  If I<string> is not a null "
"pointer, it should be an array that can hold at least B<L_cuserid> "
"characters; the string is returned in this array.  Otherwise, a pointer to a "
"string in a static area is returned.  This string is statically allocated "
"and might be overwritten on subsequent calls to this function or to "
"B<getlogin>()."
msgstr ""
"B<cuserid>()  は、現在のプロセスの実効ユーザーID に対応するユーザー名の 文字"
"列へのポインタを返す。 I<string> が NULL ポインタ以外の場合、I<string> は少な"
"くとも B<L_cuserid> 文字を保持できる配列でなければならない。 I<string> が "
"NULL ポインタの場合には、静的領域に置かれた文字列への ポインタが返される。こ"
"の文字列は静的領域に割り当てられており、後で この関数や B<getlogin>()  が呼び"
"出された際に上書きされることがある。"

#. type: Plain text
#: build/C/man3/getlogin.3:83
msgid ""
"The macro B<L_cuserid> is an integer constant that indicates how long an "
"array you might need to store a username.  B<L_cuserid> is declared in "
"I<E<lt>stdio.hE<gt>>."
msgstr ""
"マクロ B<L_cuserid> は integer の定数で、ユーザー名を保持するために 必要な配"
"列の長さを示す。 B<L_cuserid> は B<stdio.h> で宣言されて いる。"

#. type: Plain text
#: build/C/man3/getlogin.3:90
msgid ""
"These functions let your program identify positively the user who is running "
"(B<cuserid>())  or the user who logged in this session (B<getlogin>()).  "
"(These can differ when set-user-ID programs are involved.)"
msgstr ""
"これらの関数を使うと、プログラムを実行しているユーザー (B<cuserid>())  や こ"
"のセッションにログインしているユーザー (B<getlogin>())  を明確に特定すること"
"ができる (ただし set-user-ID プログラムでは、状況が違うこともある)。"

#. type: Plain text
#: build/C/man3/getlogin.3:95
msgid ""
"For most purposes, it is more useful to use the environment variable "
"B<LOGNAME> to find out who the user is.  This is more flexible precisely "
"because the user can set B<LOGNAME> arbitrarily."
msgstr ""
"たいていの目的では、ユーザーの特定には環境変数 B<LOGNAME> を調べ るほうが便利"
"である。LOGNAME 変数はユーザーが自由に設定できるので より柔軟な対応が可能にな"
"る。"

#. type: Plain text
#: build/C/man3/getlogin.3:103
msgid ""
"B<getlogin>()  returns a pointer to the username when successful, and NULL "
"on failure, with I<errno> set to indicate the cause of the error.  "
"B<getlogin_r>()  returns 0 when successful, and nonzero on failure."
msgstr ""
"B<getlogin>()  は成功した場合はユーザ名へのポインタを返す。 失敗した場合は "
"NULL を返し、 I<errno> にエラーの原因を示す値を設定する。 B<getlogin_r>()  は"
"成功すると 0 を返し、失敗すると 0 以外を返す。"

#. type: Plain text
#: build/C/man3/getlogin.3:105
msgid "POSIX specifies"
msgstr "POSIX では以下のエラーが規定されている:"

#. type: Plain text
#: build/C/man3/getlogin.3:108
msgid ""
"The calling process already has the maximum allowed number of open files."
msgstr ""
"呼び出し元プロセスがオープンしているファイル数がすでにプロセスあたりの 上限に"
"達している。"

#. type: Plain text
#: build/C/man3/getlogin.3:111
msgid "The system already has the maximum allowed number of open files."
msgstr "システム全体でオープンしているファイル数がすでに上限に達している。"

#. type: TP
#: build/C/man3/getlogin.3:111
#, no-wrap
msgid "B<ENXIO>"
msgstr "B<ENXIO>"

#. type: Plain text
#: build/C/man3/getlogin.3:114
msgid "The calling process has no controlling terminal."
msgstr "呼び出し元プロセスには制御端末がない。"

#. type: Plain text
#: build/C/man3/getlogin.3:120
msgid ""
"(getlogin_r)  The length of the username, including the terminating null "
"byte (\\(aq\\e0\\(aq), is larger than I<bufsize>."
msgstr ""
"(getlogin_r)  (終端の NULL バイト (\\(aq\\e0\\(aq) も含めた) ユーザ名の長さ"
"が I<bufsize> よりも長い。"

#. type: Plain text
#: build/C/man3/getlogin.3:122
msgid "Linux/glibc also has"
msgstr "Linux/glibc には以下のエラーもある。"

#. type: Plain text
#: build/C/man3/getlogin.3:125
msgid "There was no corresponding entry in the utmp-file."
msgstr "utmp ファイルに対応するエントリがなかった。"

#. type: Plain text
#: build/C/man3/getlogin.3:128
msgid "Insufficient memory to allocate passwd structure."
msgstr "passwd 構造体を割り当てるのに十分なメモリがない。"

#. type: TP
#: build/C/man3/getlogin.3:128 build/C/man2/ioctl.2:109
#: build/C/man2/ioctl.2:113 build/C/man3/tcgetpgrp.3:95
#, no-wrap
msgid "B<ENOTTY>"
msgstr "B<ENOTTY>"

#. type: Plain text
#: build/C/man3/getlogin.3:132
msgid "Standard input didn't refer to a terminal.  (See BUGS.)"
msgstr "標準入力が端末を参照していない (「バグ」の節を参照)。"

#. type: TP
#: build/C/man3/getlogin.3:133
#, no-wrap
msgid "I</etc/passwd>"
msgstr "I</etc/passwd>"

#. type: Plain text
#: build/C/man3/getlogin.3:136
msgid "password database file"
msgstr "パスワードデータベースのファイル"

#. type: TP
#: build/C/man3/getlogin.3:136
#, no-wrap
msgid "I</var/run/utmp>"
msgstr "I</var/run/utmp>"

#. type: Plain text
#: build/C/man3/getlogin.3:140
msgid "(traditionally I</etc/utmp>; some libc versions used I</var/adm/utmp>)"
msgstr ""
"(伝統的には I</etc/utmp> が使われている; libc の中には I</var/adm/utmp> を使"
"うものもある)"

#. type: Plain text
#: build/C/man3/getlogin.3:145
msgid "The B<getlogin>()  function is not thread-safe."
msgstr "B<getlogin>() 関数はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/getlogin.3:149
msgid "The B<getlogin_r>()  function is thread-safe."
msgstr "B<getlogin_r>() 関数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/getlogin.3:154
msgid ""
"The B<cuserid>()  function is thread-safe with exceptions.  It is not thread-"
"safe if called with a NULL parameter."
msgstr ""
"B<cuserid>() 関数は、例外付きのスレッドセーフである。 パラメータ NULL で呼び"
"出した場合はスレッドセーフではない。"

#. type: Plain text
#: build/C/man3/getlogin.3:159
msgid "B<getlogin>()  and B<getlogin_r>()  specified in POSIX.1-2001."
msgstr "B<getlogin>()  と B<getlogin_r>()  は POSIX.1-2001 で規定されている。"

#. type: Plain text
#: build/C/man3/getlogin.3:170
msgid ""
"System V has a B<cuserid>()  function which uses the real user ID rather "
"than the effective user ID.  The B<cuserid>()  function was included in the "
"1988 version of POSIX, but removed from the 1990 version.  It was present in "
"SUSv2, but removed in POSIX.1-2001."
msgstr ""
"System V にも B<cuserid>()  があるが、 これは実効ユーザー ID ではなく、実ユー"
"ザー ID を使用する。 B<cuserid>()  関数は 1988 年版の POSIX には含まれていた"
"が、 1990 年版では削除された。 SUSv2 に存在したが、POSIX.1-2001 で削除され"
"た。"

#. type: Plain text
#: build/C/man3/getlogin.3:177
msgid ""
"OpenBSD has B<getlogin>()  and B<setlogin>(), and a username associated with "
"a session, even if it has no controlling terminal."
msgstr ""
"OpenBSD には B<getlogin>()  と B<setlogin>()  があり、 セッションに対応した"
"ユーザ名がある。制御端末がない セッションの場合であっても、対応するユーザ名が"
"ある。"

#. type: Plain text
#: build/C/man3/getlogin.3:189
msgid ""
"Unfortunately, it is often rather easy to fool B<getlogin>().  Sometimes it "
"does not work at all, because some program messed up the utmp file.  Often, "
"it gives only the first 8 characters of the login name.  The user currently "
"logged in on the controlling terminal of our program need not be the user "
"who started it.  Avoid B<getlogin>()  for security-related purposes."
msgstr ""
"残念ながら、 B<getlogin>() をだますのはそれほど難しいことではない。別のプログ"
"ラムが utmp ファイルを 壊してしまうと、全く動作しないこともある。またログイン"
"名の最初の 8 文字 しか返さないことも多い。また、プログラムの制御端末に現在ロ"
"グインしているユーザーは、プログラムを実行したユーザーでない場合もある。 セ"
"キュリティの絡む用途には B<getlogin>() を用いるべきではない。"

#. type: Plain text
#: build/C/man3/getlogin.3:199
msgid ""
"Note that glibc does not follow the POSIX specification and uses I<stdin> "
"instead of I</dev/tty>.  A bug.  (Other recent systems, like SunOS 5.8 and "
"HP-UX 11.11 and FreeBSD 4.8 all return the login name also when I<stdin> is "
"redirected.)"
msgstr ""
"glibc は POSIX 仕様には従っておらず、 I</dev/tty> ではなく I<標準入力 (stdin)"
"> を使う。これはバグである。 (SunOS 5.8 や HP-UX 11.11 や FreeBSD 4.8 といっ"
"た他の最近のシステムはいずれも、 I<標準入力> がリダイレクトされた場合でもログ"
"イン名を返す。)"

#. type: Plain text
#: build/C/man3/getlogin.3:209
msgid ""
"Nobody knows precisely what B<cuserid>()  does; avoid it in portable "
"programs.  Or avoid it altogether: use I<getpwuid(geteuid())> instead, if "
"that is what you meant.  B<Do not use> B<cuserid>()."
msgstr ""
"B<cuserid>()  が何を行っているのか、実際のところを知っている者は誰もいない; "
"移植性が求められるプログラムでは B<cuserid>()  は使うべきではない。 というか"
"どんなプログラムでも使うべきではない: 代わりに I<getpwuid(geteuid())> を用い"
"るべきである (これが意図していることならば、だが)。 B<cuserid>()  は「使わな"
"い」こと。"

#. type: Plain text
#: build/C/man3/getlogin.3:213
msgid "B<geteuid>(2), B<getuid>(2), B<utmp>(5)"
msgstr "B<geteuid>(2), B<getuid>(2), B<utmp>(5)"

#. type: TH
#: build/C/man3/getopt.3:41
#, no-wrap
msgid "GETOPT"
msgstr "GETOPT"

#. type: TH
#: build/C/man3/getopt.3:41
#, no-wrap
msgid "2010-11-01"
msgstr "2010-11-01"

#. type: Plain text
#: build/C/man3/getopt.3:45
msgid ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - "
"Parse command-line options"
msgstr ""
"getopt, getopt_long, getopt_long_only, optarg, optind, opterr, optopt - コマ"
"ンドラインオプションを解釈する"

#. type: Plain text
#: build/C/man3/getopt.3:51
#, no-wrap
msgid ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"
msgstr ""
"B<int getopt(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<);>\n"

#. type: Plain text
#: build/C/man3/getopt.3:54
#, no-wrap
msgid ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"
msgstr ""
"B<extern char *>I<optarg>B<;>\n"
"B<extern int >I<optind>B<, >I<opterr>B<, >I<optopt>B<;>\n"

#. type: Plain text
#: build/C/man3/getopt.3:56
#, no-wrap
msgid "B<#include E<lt>getopt.hE<gt>>\n"
msgstr "B<#include E<lt>getopt.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/getopt.3:60
#, no-wrap
msgid ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""
"B<int getopt_long(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: build/C/man3/getopt.3:64
#, no-wrap
msgid ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"
msgstr ""
"B<int getopt_long_only(int >I<argc>B<, char * const >I<argv[]>B<,>\n"
"B<           const char *>I<optstring>B<,>\n"
"B<           const struct option *>I<longopts>B<, int *>I<longindex>B<);>\n"

#. type: Plain text
#: build/C/man3/getopt.3:74
msgid "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"
msgstr "B<getopt>(): _POSIX_C_SOURCE\\ E<gt>=\\ 2 || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man3/getopt.3:78
msgid "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"
msgstr "B<getopt_long>(), B<getopt_long_only>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/getopt.3:99
msgid ""
"The B<getopt>()  function parses the command-line arguments.  Its arguments "
"I<argc> and I<argv> are the argument count and array as passed to the I<main>"
"()  function on program invocation.  An element of I<argv> that starts with "
"\\(aq-\\(aq (and is not exactly \"-\" or \"--\")  is an option element.  The "
"characters of this element (aside from the initial \\(aq-\\(aq) are option "
"characters.  If B<getopt>()  is called repeatedly, it returns successively "
"each of the option characters from each of the option elements."
msgstr ""
"B<getopt>()  関数はコマンドライン引き数を解釈する。 B<getopt>()  がとる引き"
"数 I<argc> と I<argv> は、それぞれプログラムの起動時に I<main>()  関数に渡さ"
"れた引き数の個数と配列である。 I<argv> の要素のうち \\(aq-\\(aq で始まるもの "
"(かつ \"-\" 単独や \"--\" 単独ではないもの) は オプション要素 (option "
"element) とみなされる。 この要素から先頭の \\(aq-\\(aq を除いた文字は オプ"
"ション文字 (option character) とされる。 B<getopt>()  は、繰り返し呼び出され"
"るごとに、次のオプション文字を返す。"

#. type: Plain text
#: build/C/man3/getopt.3:108
msgid ""
"The variable I<optind> is the index of the next element to be processed in "
"I<argv>.  The system initializes this value to 1.  The caller can reset it "
"to 1 to restart scanning of the same I<argv>, or when scanning a new "
"argument vector."
msgstr ""
"変数 I<optind> は、 I<argv> の次に処理される要素のインデックスである。 システ"
"ムによりこの変数の値は 1 に初期化される。 呼び出し側でこの値を 1 にリセットす"
"ることで、同じ I<argv> のスキャンをやり直したり、新しい引き数ベクトルをスキャ"
"ンすることができる。"

#. type: Plain text
#: build/C/man3/getopt.3:118
msgid ""
"If B<getopt>()  finds another option character, it returns that character, "
"updating the external variable I<optind> and a static variable I<nextchar> "
"so that the next call to B<getopt>()  can resume the scan with the following "
"option character or I<argv>-element."
msgstr ""
"新たなオプション文字を見つけると、 B<getopt>()  はその文字を返し、 外部変数 "
"I<optind> とスタティックな変数 I<nextchar> を更新する。 これらによって、 "
"B<getopt>()  は次回の呼び出しの際に、 以降のオプション文字や I<argv> 要素のス"
"キャンを継続できる。"

#. type: Plain text
#: build/C/man3/getopt.3:124
msgid ""
"If there are no more option characters, B<getopt>()  returns -1.  Then "
"I<optind> is the index in I<argv> of the first I<argv>-element that is not "
"an option."
msgstr ""
"オプション文字がそれ以上見つからなくなると、 B<getopt>()  は -1 を返す。そし"
"て I<optind> は、I<argv> の要素のうち、 オプションでない最初の要素を示すよう"
"になる。"

#. type: Plain text
#: build/C/man3/getopt.3:151
msgid ""
"I<optstring> is a string containing the legitimate option characters.  If "
"such a character is followed by a colon, the option requires an argument, so "
"B<getopt>()  places a pointer to the following text in the same I<argv>-"
"element, or the text of the following I<argv>-element, in I<optarg>.  Two "
"colons mean an option takes an optional arg; if there is text in the current "
"I<argv>-element (i.e., in the same word as the option name itself, for "
"example, \"-oarg\"), then it is returned in I<optarg>, otherwise I<optarg> "
"is set to zero.  This is a GNU extension.  If I<optstring> contains B<W> "
"followed by a semicolon, then B<-W foo> is treated as the long option B<--"
"foo>.  (The B<-W> option is reserved by POSIX.2 for implementation "
"extensions.)  This behavior is a GNU extension, not available with libraries "
"before glibc 2."
msgstr ""
"I<optstring> は受け付けるオプション文字からなる文字列である。 文字のあとにコ"
"ロン (:) が置かれている場合は、 オプションには引き数が必要であることを示す。 "
"このとき B<getopt>()  は、現在注目している I<argv> 要素で、オプション文字に引"
"き続くテキストへのポインタか、 あるいは次の I<argv> 要素のテキストへのポイン"
"タを I<optarg> に代入する。 2 個連続してコロンが置かれている場合は、 そのオプ"
"ションは引き数をとってもとらなくてもよい。 現在の I<argv> 要素にテキストがあ"
"れば (つまり、\"-oarg\" のように、オプション名自身と同じワード内に テキストが"
"ある場合)、それが I<optarg> に返される。 なければ I<optarg> は 0 に設定され"
"る。 これは GNU による拡張である。 I<optstring> に B<W> とそれに続くセミコロ"
"ンが入っていると、 B<-W foo> は長いオプション B<--foo> と同じように扱われる "
"(POSIX.2 は B<-W> オプションを実装依存の拡張として予約している)。 この動作は "
"GNU による拡張であり、glibc 2 以前のライブラリでは 利用できない。"

#. type: Plain text
#: build/C/man3/getopt.3:169
msgid ""
"By default, B<getopt>()  permutes the contents of I<argv> as it scans, so "
"that eventually all the nonoptions are at the end.  Two other modes are also "
"implemented.  If the first character of I<optstring> is \\(aq+\\(aq or the "
"environment variable B<POSIXLY_CORRECT> is set, then option processing stops "
"as soon as a nonoption argument is encountered.  If the first character of "
"I<optstring> is \\(aq-\\(aq, then each nonoption I<argv>-element is handled "
"as if it were the argument of an option with character code 1.  (This is "
"used by programs that were written to expect options and other I<argv>-"
"elements in any order and that care about the ordering of the two.)  The "
"special argument \"--\" forces an end of option-scanning regardless of the "
"scanning mode."
msgstr ""
"デフォルトでは B<getopt>()  は I<argv> をスキャンする際に順序を変更し、 オプ"
"ション以外の要素を最後に移動する。 他にも 2 つのモードが実装されている。 "
"I<optstring> の先頭文字が \\(aq+\\(aq であるか、環境変数 B<POSIXLY_CORRECT> "
"が設定されている場合には、オプションを対象とする動作は、 非オプションの引き数"
"が現れた段階で終了する。 I<optstring> の先頭文字が \\(aq-\\(aq である場合に"
"は、 オプションでない I<argv> 要素は、 文字コード 1 のオプションであるかのよ"
"うに扱われる (これを用いるプログラムは、 オプションや I<argv> 要素を任意の順"
"序で受け入れ、かつそれらの順序が 意味を持つように書かれている必要がある)。 "
"\"--\" は特殊な引き数で、スキャンのモードによらず、 オプションのスキャンを強"
"制的に終了させる。"

#. type: Plain text
#: build/C/man3/getopt.3:177
msgid ""
"If B<getopt>()  does not recognize an option character, it prints an error "
"message to I<stderr>, stores the character in I<optopt>, and returns \\(aq?"
"\\(aq.  The calling program may prevent the error message by setting "
"I<opterr> to 0."
msgstr ""
"認識できないオプション文字があると、 B<getopt>()  はエラーメッセージを標準エ"
"ラー出力 I<stderr> に表示し、 その文字を I<optopt> に保存して \\(aq?\\(aq を"
"返す。 呼び出したプログラムで I<opterr> を 0 にしておけば、 エラーメッセージ"
"の表示を抑制できる。"

#. type: Plain text
#: build/C/man3/getopt.3:196
msgid ""
"If B<getopt>()  finds an option character in I<argv> that was not included "
"in I<optstring>, or if it detects a missing option argument, it returns "
"\\(aq?\\(aq and sets the external variable I<optopt> to the actual option "
"character.  If the first character (following any optional \\(aq+\\(aq or "
"\\(aq-\\(aq described above)  of I<optstring> is a colon (\\(aq:\\(aq), then "
"B<getopt>()  returns \\(aq:\\(aq instead of \\(aq?\\(aq to indicate a "
"missing option argument.  If an error was detected, and the first character "
"of I<optstring> is not a colon, and the external variable I<opterr> is "
"nonzero (which is the default), B<getopt>()  prints an error message."
msgstr ""
"B<getopt>()  は I<argv> の中に I<optstring> にないオプション文字を見つけた場"
"合、 またはオプション引き数が足りないことが分かった場合、 \\&\\(aq?\\(aq を返"
"して外部変数 I<optopt> をそのオプション文字に設定する。 I<optstring> の (上で"
"説明したオプションで指定できる \\&\\(aq+\\(aq または \\(aq-\\(aq 後に続く) 最"
"初の文字が コロン (\\(aq:\\(aq) のとき、 B<getopt>()  はオプション引き数が足"
"りない場合に \\(aq?\\(aq ではなく \\(aq:\\(aq を返す。 エラーを見つけた場合"
"で、かつ I<optstring> の最初の文字がコロンでなく、 かつ外部変数 I<opterr> が "
"0 でない場合 (これがデフォルト)、 B<getopt>()  はエラーメッセージを表示する。"

#. type: SS
#: build/C/man3/getopt.3:196
#, no-wrap
msgid "getopt_long() and getopt_long_only()"
msgstr "getopt_long() と getopt_long_only()"

#. type: Plain text
#: build/C/man3/getopt.3:212
msgid ""
"The B<getopt_long>()  function works like B<getopt>()  except that it also "
"accepts long options, started with two dashes.  (If the program accepts only "
"long options, then I<optstring> should be specified as an empty string "
"(\"\"), not NULL.)  Long option names may be abbreviated if the abbreviation "
"is unique or is an exact match for some defined option.  A long option may "
"take a parameter, of the form B<--arg=param> or B<--arg param>."
msgstr ""
"B<getopt_long>()  関数は、長いオプション (2 つのダッシュ \"--\" で始まるオプ"
"ション) を 受け入れることを除いて B<getopt>()  と同じように動作する (プログラ"
"ムに長いオプションだけが渡された場合、 I<optstring> は NULL ではなく空文字列 "
"(\"\") となる)。 長いオプションの名前は、他と重ならない範囲において短縮でき"
"る。 あるいは定義されたオプションに正確にマッチするものでも (当然) かまわな"
"い。 長いオプションは引き数を取ることができ、 B<--arg=param> または B<--arg "
"param> と言う形式で指定する。"

#. type: Plain text
#: build/C/man3/getopt.3:219
msgid ""
"I<longopts> is a pointer to the first element of an array of I<struct "
"option> declared in I<E<lt>getopt.hE<gt>> as"
msgstr ""
"I<longopts> は I<struct option> の要素からなる配列の、先頭要素へのポインタで"
"ある。 I<struct option> は I<E<lt>getopt.hE<gt>> で以下のように定義されてい"
"る。"

#. type: Plain text
#: build/C/man3/getopt.3:228
#, no-wrap
msgid ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"
msgstr ""
"struct option {\n"
"    const char *name;\n"
"    int         has_arg;\n"
"    int        *flag;\n"
"    int         val;\n"
"};\n"

#. type: Plain text
#: build/C/man3/getopt.3:232
msgid "The meanings of the different fields are:"
msgstr "それぞれのフィールドの意味は以下の通り。"

#. type: TP
#: build/C/man3/getopt.3:232
#, no-wrap
msgid "I<name>"
msgstr "I<name>"

#. type: Plain text
#: build/C/man3/getopt.3:235
msgid "is the name of the long option."
msgstr "長いオプションの名前。"

#. type: TP
#: build/C/man3/getopt.3:235
#, no-wrap
msgid "I<has_arg>"
msgstr "I<has_arg>"

#. type: Plain text
#: build/C/man3/getopt.3:241
msgid ""
"is: B<no_argument> (or 0) if the option does not take an argument; "
"B<required_argument> (or 1) if the option requires an argument; or "
"B<optional_argument> (or 2) if the option takes an optional argument."
msgstr ""
"B<no_argument> (または 0) なら、オプションは引き数をとらない。 "
"B<required_argument> (または 1) なら、オプションは引き数を必要とする。 "
"B<optional_argument> (または 2) なら、オプションは引き数をとっても とらなくて"
"も良い。"

#. type: TP
#: build/C/man3/getopt.3:241
#, no-wrap
msgid "I<flag>"
msgstr "I<flag>"

#. type: Plain text
#: build/C/man3/getopt.3:255
msgid ""
"specifies how results are returned for a long option.  If I<flag> is NULL, "
"then B<getopt_long>()  returns I<val>.  (For example, the calling program "
"may set I<val> to the equivalent short option character.)  Otherwise, "
"B<getopt_long>()  returns 0, and I<flag> points to a variable which is set "
"to I<val> if the option is found, but left unchanged if the option is not "
"found."
msgstr ""
"長いオプションに対する結果の返し方を指定する。I<flag> が NULL なら "
"B<getopt_long>()  は I<val> を返す (例えば呼び出し元のプログラムは、 I<val> "
"に等価なオプション文字を代入することができる)。 NULL 以外の場合には、 "
"B<getopt_long>()  は 0 を返す。 このときオプションが見つかると I<flag> がポイ"
"ントする変数に I<val> が代入される。見つからないとこの変数は変更されない。"

#. type: TP
#: build/C/man3/getopt.3:255
#, no-wrap
msgid "I<val>"
msgstr "I<val>"

#. type: Plain text
#: build/C/man3/getopt.3:259
msgid ""
"is the value to return, or to load into the variable pointed to by I<flag>."
msgstr "返り値、または I<flag> がポイントする変数へロードされる値。"

#. type: Plain text
#: build/C/man3/getopt.3:261
msgid "The last element of the array has to be filled with zeros."
msgstr "配列の最後の要素は、全て 0 で埋められていなければならない。"

#. type: Plain text
#: build/C/man3/getopt.3:265
msgid ""
"If I<longindex> is not NULL, it points to a variable which is set to the "
"index of the long option relative to I<longopts>."
msgstr ""
"I<longindex> は、NULL でなければ、 長いオプションのインデックスを "
"I<longopts> からの相対位置として保持している変数へのポインタとなる。"

#. type: Plain text
#: build/C/man3/getopt.3:274
msgid ""
"B<getopt_long_only>()  is like B<getopt_long>(), but \\(aq-\\(aq as well as "
"\"--\" can indicate a long option.  If an option that starts with \\(aq-"
"\\(aq (not \"--\") doesn't match a long option, but does match a short "
"option, it is parsed as a short option instead."
msgstr ""
"B<getopt_long_only>()  は B<getopt_long>()  と同様の動作をするが、 \\(aq-"
"\\(aq も \"--\" と同様に、 長いオプションとして扱われる。\\(aq-\\(aq で始ま"
"る (\"--\" 以外の) オプションが、長いものにはマッチしないが短いものに マッチ"
"する場合においては、それは短いオプションとして解釈される。"

#. type: Plain text
#: build/C/man3/getopt.3:292
msgid ""
"If an option was successfully found, then B<getopt>()  returns the option "
"character.  If all command-line options have been parsed, then B<getopt>()  "
"returns -1.  If B<getopt>()  encounters an option character that was not in "
"I<optstring>, then \\(aq?\\(aq is returned.  If B<getopt>()  encounters an "
"option with a missing argument, then the return value depends on the first "
"character in I<optstring>: if it is \\(aq:\\(aq, then \\(aq:\\(aq is "
"returned; otherwise \\(aq?\\(aq is returned."
msgstr ""
"オプションが正常に見つかれば B<getopt>()  はそのオプション文字を返す。 すべて"
"のコマンドラインオプションの解析が終わったら、 B<getopt>()  は -1 を返す。 "
"I<optstring> に含まれないオプション文字が見つかると、\\(aq?\\(aq を返す。 引"
"き数が足りないオプションが見つかった場合、 返り値は I<optstring> の最初の文字"
"による異なる: 最初の文字が \\(aq:\\(aq であれば \\(aq:\\(aq を返し、 それ以外"
"の場合は \\(aq?\\(aq を返す。"

#. type: Plain text
#: build/C/man3/getopt.3:304
msgid ""
"B<getopt_long>()  and B<getopt_long_only>()  also return the option "
"character when a short option is recognized.  For a long option, they return "
"I<val> if I<flag> is NULL, and 0 otherwise.  Error and -1 returns are the "
"same as for B<getopt>(), plus \\(aq?\\(aq for an ambiguous match or an "
"extraneous parameter."
msgstr ""
"B<getopt_long>()  と B<getopt_long_only>()  も、 短いオプション文字を認識した"
"場合にはその文字を返す。 長いオプションに対しては、 I<flag> が NULL なら "
"I<val> を返し、 I<flag> が NULL 以外なら 0 を返す。 エラーと -1 の返り値は "
"B<getopt>()  と同じである。 さらに \\(aq?\\(aq は、マッチが確定できない場合や"
"余分なパラメーターがある場合にも返る。"

#. type: SH
#: build/C/man3/getopt.3:304
#, no-wrap
msgid "ENVIRONMENT"
msgstr "環境"

#. type: TP
#: build/C/man3/getopt.3:305
#, no-wrap
msgid "B<POSIXLY_CORRECT>"
msgstr "B<POSIXLY_CORRECT>"

#. type: Plain text
#: build/C/man3/getopt.3:309
msgid ""
"If this is set, then option processing stops as soon as a nonoption argument "
"is encountered."
msgstr ""
"これが設定されていると、非オプションの引き数に到達した時点でオプション に対す"
"る操作が停止される。"

#. type: TP
#: build/C/man3/getopt.3:309
#, no-wrap
msgid "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"
msgstr "B<_E<lt>PIDE<gt>_GNU_nonoption_argv_flags_>"

#. type: Plain text
#: build/C/man3/getopt.3:318
msgid ""
"This variable was used by B<bash>(1)  2.0 to communicate to glibc which "
"arguments are the results of wildcard expansion and so should not be "
"considered as options.  This behavior was removed in B<bash>(1)  version "
"2.01, but the support remains in glibc."
msgstr ""
"この変数は B<bash>(1)  2.0 が glibc と通信するために用いられた。 どの引き数が"
"ワイルドカードを展開した結果で、 したがってオプションとみなすべきでないかを知"
"らせるものである。 この機能は B<bash>(1)  のバージョン 2.01 で削除されたが、"
"glibc にはまだ残っている。"

#. type: TP
#: build/C/man3/getopt.3:319
#, no-wrap
msgid "B<getopt>():"
msgstr "B<getopt>():"

#. type: Plain text
#: build/C/man3/getopt.3:329
msgid ""
"POSIX.2 and POSIX.1-2001, provided the environment variable "
"B<POSIXLY_CORRECT> is set.  Otherwise, the elements of I<argv> aren't really "
"const, because we permute them.  We pretend they're const in the prototype "
"to be compatible with other systems."
msgstr ""
"環境変数 B<POSIXLY_CORRECT> が設定されている場合は POSIX.2 と POSIX.1-2001 に"
"準拠する。 他の場合は I<argv> の要素は本当の意味での定数にはならない。 なぜな"
"ら順序が変更されてしまうからである。 ただしそれらは、プロトタイプでは定数であ"
"るかのようにしてある。 これは他のシステムとの互換性のためである。"

#. type: Plain text
#: build/C/man3/getopt.3:333
msgid ""
"The use of \\(aq+\\(aq and \\(aq-\\(aq in I<optstring> is a GNU extension."
msgstr ""
"I<optstring> で \\(aq+\\(aq や \\(aq-\\(aq を使うのは GNU による拡張である."

#. type: Plain text
#: build/C/man3/getopt.3:347
msgid ""
"On some older implementations, B<getopt>()  was declared in I<E<lt>stdio."
"hE<gt>>.  SUSv1 permitted the declaration to appear in either I<E<lt>unistd."
"hE<gt>> or I<E<lt>stdio.hE<gt>>.  POSIX.1-2001 marked the use of "
"I<E<lt>stdio.hE<gt>> for this purpose as LEGACY.  POSIX.1-2001 does not "
"allow the declaration to appear in I<E<lt>stdio.hE<gt>>."
msgstr ""
"古い実装のいくつかでは、 B<getopt>()  は I<E<lt>stdio.hE<gt>> で宣言されてい"
"た。 SUSv1 では、 I<E<lt>unistd.hE<gt>> か I<E<lt>stdio.hE<gt>> のどちらかで "
"宣言してもよかった。 POSIX.1-2001 では、 B<getopt> の宣言を I<E<lt>stdio."
"hE<gt>> で行うのは「過去の名残」であるとされた。 POSIX.1-2001 では "
"I<E<lt>stdio.hE<gt>> で宣言を行うことを認めていない。"

#. type: TP
#: build/C/man3/getopt.3:347
#, no-wrap
msgid "B<getopt_long>() and B<getopt_long_only>():"
msgstr "B<getopt_long>(), B<getopt_long_only>():"

#. type: Plain text
#: build/C/man3/getopt.3:369
msgid ""
"A program that scans multiple argument vectors, or rescans the same vector "
"more than once, and wants to make use of GNU extensions such as \\(aq+\\(aq "
"and \\(aq-\\(aq at the start of I<optstring>, or changes the value of "
"B<POSIXLY_CORRECT> between scans, must reinitialize B<getopt>()  by "
"resetting I<optind> to 0, rather than the traditional value of 1.  "
"(Resetting to 0 forces the invocation of an internal initialization routine "
"that rechecks B<POSIXLY_CORRECT> and checks for GNU extensions in "
"I<optstring>.)"
msgstr ""
"複数の引き数ベクトルをスキャンしたり、同じ引き数ベクトルを二回以上 スキャンす"
"るようなプログラムで、 I<optstring> の先頭で \\(aq+\\(aq や \\(aq-\\(aq と"
"いった GNU による拡張機能を使用したり、 引き数ベクトルの切り替え時に "
"B<POSIXLY_CORRECT> の値を変更したりする場合には、 I<optind> を伝統的な 1 では"
"なく 0 にリセットすることで B<getopt>()  を再初期化しなければならない (0 にリ"
"セットすることで、 B<POSIXLY_CORRECT> や I<optstring> の GNU 拡張機能のチェッ"
"クを行う内部初期化ルーチンが起動される)。"

#. type: Plain text
#: build/C/man3/getopt.3:376
msgid ""
"The POSIX.2 specification of B<getopt>()  has a technical error described in "
"POSIX.2 Interpretation 150.  The GNU implementation (and probably all other "
"implementations) implements the correct behavior rather than that specified."
msgstr ""
"POSIX.2 における B<getopt>()  の仕様には技術的な問題があり、 その内容は "
"POSIX.2 Interpretation 150 に記されている。 GNU による実装では (おそらく他の"
"すべての実装でも)、 仕様と異なる正しい動作をするように実装されている。"

#. type: Plain text
#: build/C/man3/getopt.3:384
msgid ""
"The following trivial example program uses B<getopt>()  to handle two "
"program options: I<-n>, with no associated value; and I<-t val>, which "
"expects an associated value."
msgstr ""
"以下に示す簡単なサンプルプログラムでは、 二種類のプログラムオプションを扱うの"
"に B<getopt>()  を使用している。一つは値を伴わない I<-n> で、もう一つは対応す"
"る値が必要な I<-t val> である。"

#. type: Plain text
#: build/C/man3/getopt.3:389
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getopt.3:395
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int flags, opt;\n"
"    int nsecs, tfnd;\n"

#. type: Plain text
#: build/C/man3/getopt.3:414
#, no-wrap
msgid ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"    nsecs = 0;\n"
"    tfnd = 0;\n"
"    flags = 0;\n"
"    while ((opt = getopt(argc, argv, \"nt:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqn\\(aq:\n"
"            flags = 1;\n"
"            break;\n"
"        case \\(aqt\\(aq:\n"
"            nsecs = atoi(optarg);\n"
"            tfnd = 1;\n"
"            break;\n"
"        default: /* \\(aq?\\(aq */\n"
"            fprintf(stderr, \"Usage: %s [-t nsecs] [-n] name\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:416
#, no-wrap
msgid "    printf(\"flags=%d; tfnd=%d; optind=%d\\en\", flags, tfnd, optind);\n"
msgstr "    printf(\"flags=%d; tfnd=%d; optind=%d\\en\", flags, tfnd, optind);\n"

#. type: Plain text
#: build/C/man3/getopt.3:421
#, no-wrap
msgid ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (optind E<gt>= argc) {\n"
"        fprintf(stderr, \"Expected argument after options\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:423
#, no-wrap
msgid "    printf(\"name argument = %s\\en\", argv[optind]);\n"
msgstr "    printf(\"name argument = %s\\en\", argv[optind]);\n"

#. type: Plain text
#: build/C/man3/getopt.3:425
#, no-wrap
msgid "    /* Other code omitted */\n"
msgstr "    /* Other code omitted */\n"

#. type: Plain text
#: build/C/man3/getopt.3:433
msgid ""
"The following example program illustrates the use of B<getopt_long>()  with "
"most of its features."
msgstr ""
"以下は、 B<getopt_long>()  の使用法を、ほぼすべての機能について示したプログラ"
"ムの例である。"

#. type: Plain text
#: build/C/man3/getopt.3:438
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>     /* for printf */\n"
"#include E<lt>stdlib.hE<gt>    /* for exit */\n"
"#include E<lt>getopt.hE<gt>\n"

#. type: Plain text
#: build/C/man3/getopt.3:444
#, no-wrap
msgid ""
"int\n"
"main(int argc, char **argv)\n"
"{\n"
"    int c;\n"
"    int digit_optind = 0;\n"
msgstr ""
"int\n"
"main(int argc, char **argv) {\n"
"    int c;\n"
"    int digit_optind = 0;\n"

#. type: Plain text
#: build/C/man3/getopt.3:457
#, no-wrap
msgid ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"
msgstr ""
"    while (1) {\n"
"        int this_option_optind = optind ? optind : 1;\n"
"        int option_index = 0;\n"
"        static struct option long_options[] = {\n"
"            {\"add\",     required_argument, 0,  0 },\n"
"            {\"append\",  no_argument,       0,  0 },\n"
"            {\"delete\",  required_argument, 0,  0 },\n"
"            {\"verbose\", no_argument,       0,  0 },\n"
"            {\"create\",  required_argument, 0, \\(aqc\\(aq},\n"
"            {\"file\",    required_argument, 0,  0 },\n"
"            {0,         0,                 0,  0 }\n"
"        };\n"

#. type: Plain text
#: build/C/man3/getopt.3:462
#, no-wrap
msgid ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"
msgstr ""
"        c = getopt_long(argc, argv, \"abc:d:012\",\n"
"                 long_options, &option_index);\n"
"        if (c == -1)\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:470
#, no-wrap
msgid ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"
msgstr ""
"        switch (c) {\n"
"        case 0:\n"
"            printf(\"option %s\", long_options[option_index].name);\n"
"            if (optarg)\n"
"                printf(\" with arg %s\", optarg);\n"
"            printf(\"\\en\");\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:479
#, no-wrap
msgid ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"
msgstr ""
"        case \\(aq0\\(aq:\n"
"        case \\(aq1\\(aq:\n"
"        case \\(aq2\\(aq:\n"
"            if (digit_optind != 0 && digit_optind != this_option_optind)\n"
"              printf(\"digits occur in two different argv-elements.\\en\");\n"
"            digit_optind = this_option_optind;\n"
"            printf(\"option %c\\en\", c);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:483
#, no-wrap
msgid ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"
msgstr ""
"        case \\(aqa\\(aq:\n"
"            printf(\"option a\\en\");\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:487
#, no-wrap
msgid ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"
msgstr ""
"        case \\(aqb\\(aq:\n"
"            printf(\"option b\\en\");\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:491
#, no-wrap
msgid ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""
"        case \\(aqc\\(aq:\n"
"            printf(\"option c with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:495
#, no-wrap
msgid ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"
msgstr ""
"        case \\(aqd\\(aq:\n"
"            printf(\"option d with value \\(aq%s\\(aq\\en\", optarg);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:498
#, no-wrap
msgid ""
"        case \\(aq?\\(aq:\n"
"            break;\n"
msgstr ""
"        case \\(aq?\\(aq:\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/getopt.3:503
#, no-wrap
msgid ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"
msgstr ""
"        default:\n"
"            printf(\"?? getopt returned character code 0%o ??\\en\", c);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:510
#, no-wrap
msgid ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"    if (optind E<lt> argc) {\n"
"        printf(\"non-option ARGV-elements: \");\n"
"        while (optind E<lt> argc)\n"
"            printf(\"%s \", argv[optind++]);\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/getopt.3:516
msgid "B<getsubopt>(3)"
msgstr "B<getsubopt>(3)"

#. type: TH
#: build/C/man2/getpagesize.2:25
#, no-wrap
msgid "GETPAGESIZE"
msgstr "GETPAGESIZE"

#. type: TH
#: build/C/man2/getpagesize.2:25
#, no-wrap
msgid "2010-11-16"
msgstr "2010-11-16"

#. type: Plain text
#: build/C/man2/getpagesize.2:28
msgid "getpagesize - get memory page size"
msgstr "getpagesize - メモリのページサイズを取得する"

#. type: Plain text
#: build/C/man2/getpagesize.2:32
msgid "B<int getpagesize(void);>"
msgstr "B<int getpagesize(void);>"

#. type: Plain text
#: build/C/man2/getpagesize.2:39
msgid "B<getpagesize>():"
msgstr "B<getpagesize>():"

#.  .SH HISTORY
#.  This call first appeared in 4.2BSD.
#. type: Plain text
#: build/C/man2/getpagesize.2:64
msgid ""
"The function B<getpagesize>()  returns the number of bytes in a memory page, "
"where \"page\" is a fixed-length block, the unit for memory allocation and "
"file mapping performed by B<mmap>(2)."
msgstr ""
"B<getpagesize>() 関数はメモリページの大きさをバイト数で返す。\n"
"ここでいう「ページ」は固定長のブロックであり、\n"
"B<mmap>(2) で実行されるメモリ割り当てとファイルマッピングの単位である。"

#. type: Plain text
#: build/C/man2/getpagesize.2:71
msgid ""
"SVr4, 4.4BSD, SUSv2.  In SUSv2 the B<getpagesize>()  call is labeled LEGACY, "
"and in POSIX.1-2001 it has been dropped; HP-UX does not have this call."
msgstr ""
"SVr4, 4.4BSD, SUSv2.\n"
"SUSv2 では B<getpagesize>() システムコールは「過去の遺物 (LEGACY)」とされてお"
"り、\n"
"POSIX.1-2001 からは外されている。 HP-UX にはこのシステムコールは存在しない。"

#. type: Plain text
#: build/C/man2/getpagesize.2:76
msgid ""
"Portable applications should employ I<sysconf(_SC_PAGESIZE)> instead of "
"B<getpagesize>():"
msgstr ""
"移植性が必要なアプリケーションでは、\n"
"B<getpagesize>() ではなく I<sysconf(_SC_PAGESIZE)> を利用すべきである。"

#. type: Plain text
#: build/C/man2/getpagesize.2:81
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"long sz = sysconf(_SC_PAGESIZE);\n"

#. type: Plain text
#: build/C/man2/getpagesize.2:88
msgid "(Most systems allow the synonym B<_SC_PAGE_SIZE> for B<_SC_PAGESIZE>.)"
msgstr ""
"(ほとんどのシステムでは B<_SC_PAGESIZE> の同義語として\n"
"B<_SC_PAGE_SIZE> を使用することができる。)"

#. type: Plain text
#: build/C/man2/getpagesize.2:108
msgid ""
"Whether B<getpagesize>()  is present as a Linux system call depends on the "
"architecture.  If it is, it returns the kernel symbol B<PAGE_SIZE>, whose "
"value depends on the architecture and machine model.  Generally, one uses "
"binaries that are dependent on the architecture but not on the machine "
"model, in order to have a single binary distribution per architecture.  This "
"means that a user program should not find B<PAGE_SIZE> at compile time from "
"a header file, but use an actual system call, at least for those "
"architectures (like sun4) where this dependency exists.  Here libc4, libc5, "
"glibc 2.0 fail because their B<getpagesize>()  returns a statically derived "
"value, and does not use a system call.  Things are OK in glibc 2.1."
msgstr ""
"B<getpagesize>()  が Linux のシステムコールとして存在するかどうかは、そのアー"
"キテクチャに 依存している。 システムコールとして存在する場合には、カーネルシ"
"ンボルの B<PAGE_SIZE> を返す。 B<PAGE_SIZE> の値は、アーキテクチャとマシンモ"
"デルに依存する。 一般に、バイナリは、アーキテクチャごとに1つのバイナリ配布で"
"済ませるために、 アーキテクチャには依存しているがマシンモデルには依存していな"
"い。 つまり、ユーザプログラムはコンパイル時にヘッダーファイルから "
"B<PAGE_SIZE> を見つけて使用すべきではない。 少なくとも、マシンモデルについて"
"も依存性が存在する (sun4 のような)  アーキテクチャにおいては本物のシステム"
"コールを使用する必要がある。 尚、 libc4, libc5, glibc 2.0 では、 "
"B<getpagesize>()  がシステムコールを使用せず、固定の値を返すために、この方法"
"は 失敗する。glibc 2.1 では大丈夫である。"

#. type: Plain text
#: build/C/man2/getpagesize.2:111
msgid "B<mmap>(2), B<sysconf>(3)"
msgstr "B<mmap>(2), B<sysconf>(3)"

#. type: TH
#: build/C/man2/gettid.2:26
#, no-wrap
msgid "GETTID"
msgstr "GETTID"

#. type: TH
#: build/C/man2/gettid.2:26 build/C/man3/lockf.3:28
#, no-wrap
msgid "2014-02-11"
msgstr "2014-02-11"

#. type: Plain text
#: build/C/man2/gettid.2:29
msgid "gettid - get thread identification"
msgstr "gettid - スレッドID を取得する"

#. type: Plain text
#: build/C/man2/gettid.2:32
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/gettid.2:34
#, no-wrap
msgid "B<pid_t gettid(void);>\n"
msgstr "B<pid_t gettid(void);>\n"

#. type: Plain text
#: build/C/man2/gettid.2:50
msgid ""
"B<gettid>()  returns the caller's thread ID (TID).  In a single-threaded "
"process, the thread ID is equal to the process ID (PID, as returned by "
"B<getpid>(2)).  In a multithreaded process, all threads have the same PID, "
"but each one has a unique TID.  For further details, see the discussion of "
"B<CLONE_THREAD> in B<clone>(2)."
msgstr ""
"B<gettid>()  は呼び出し元のスレッド ID (TID) を返す。 シングルスレッドのプロ"
"セスでは、スレッド ID は (B<getpid>(2)  が返すプロセス ID (PID) と等しい。 マ"
"ルチスレッドのプロセスでは、全てのスレッドは同じ PID を持つが、 それぞれのス"
"レッドは一意な TID を持つ。 さらなる詳細は、 B<clone>(2)  の B<CLONE_THREAD> "
"についての議論を参照すること。"

#. type: Plain text
#: build/C/man2/gettid.2:52
msgid "On success, returns the thread ID of the calling process."
msgstr "成功の場合、呼び出し元のプロセスのスレッドID を返す。"

#. type: Plain text
#: build/C/man2/gettid.2:54
msgid "This call is always successful."
msgstr "このコールは常に成功する。"

#. type: Plain text
#: build/C/man2/gettid.2:58
msgid "The B<gettid>()  system call first appeared on Linux in kernel 2.4.11."
msgstr ""
"B<gettid>()  システムコールは、カーネル 2.4.11 の Linux で初めて登場した。"

#. type: Plain text
#: build/C/man2/gettid.2:62
msgid ""
"B<gettid>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""
"B<gettid>()  は Linux 固有であり、 移植を想定したプログラムでは使用すべきでは"
"ない。"

#.  FIXME See http://sourceware.org/bugzilla/show_bug.cgi?id=6399
#.  "gettid() should have a wrapper"
#. type: Plain text
#: build/C/man2/gettid.2:67
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 このシステム"
"コールは呼び出すには B<syscall>(2)  を使うこと。"

#. type: Plain text
#: build/C/man2/gettid.2:71
msgid ""
"The thread ID returned by this call is not the same thing as a POSIX thread "
"ID (i.e., the opaque value returned by B<pthread_self>(3))."
msgstr ""
"このシステムコールが返すスレッド ID は POSIX スレッド ID (B<pthread_self>"
"(3)  が返す曖昧な値) と同じものではない。"

#.  .BR kcmp (2),
#.  .BR move_pages (2),
#.  .BR migrate_pages (2),
#.  .BR process_vm_readv (2),
#.  .BR ptrace (2),
#. type: Plain text
#: build/C/man2/gettid.2:90
msgid ""
"B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<get_robust_list>(2), "
"B<getpid>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<sched_setaffinity>"
"(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<tgkill>(2), "
"B<timer_create>(2)"
msgstr "B<capget>(2), B<clone>(2), B<fcntl>(2), B<fork>(2), B<get_robust_list>(2), B<getpid>(2), B<ioprio_set>(2), B<perf_event_open>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2), B<tgkill>(2), B<timer_create>(2)"

#. type: TH
#: build/C/man3/getumask.3:28
#, no-wrap
msgid "GETUMASK"
msgstr "GETUMASK"

#. type: TH
#: build/C/man3/getumask.3:28
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/getumask.3:31
msgid "getumask - get file creation mask"
msgstr "getumask - ファイル作成マスクを取得する"

#. type: Plain text
#: build/C/man3/getumask.3:35 build/C/man2/truncate.2:50
#: build/C/man2/umask.2:39 build/C/man2/vfork.2:33
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man3/getumask.3:37 build/C/man2/umask.2:41
msgid "B<#include E<lt>sys/stat.hE<gt>>"
msgstr "B<#include E<lt>sys/stat.hE<gt>>"

#. type: Plain text
#: build/C/man3/getumask.3:39
msgid "B<mode_t getumask(void);>"
msgstr "B<mode_t getumask(void);>"

#. type: Plain text
#: build/C/man3/getumask.3:42
msgid ""
"This function returns the current file creation mask.  It is equivalent to"
msgstr ""
"この関数は現在のファイル作成マスクを返す。 基本的には以下と等価である。"

#. type: Plain text
#: build/C/man3/getumask.3:51
#, no-wrap
msgid ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"
msgstr ""
"mode_t getumask(void)\n"
"{\n"
"    mode_t mask = umask( 0 );\n"
"    umask(mask);\n"
"    return mask;\n"
"}\n"

#. type: Plain text
#: build/C/man3/getumask.3:58
msgid ""
"except that it is documented to be thread-safe (that is, shares a lock with "
"the B<umask>(2)  library call)."
msgstr ""
"ドキュメントによると、この関数は スレッドセーフである (B<umask>(2)  ライブラ"
"リコールとロックを共有する)  点が異なる。"

#. type: Plain text
#: build/C/man3/getumask.3:60
msgid "This is a vaporware GNU extension."
msgstr "ドキュメントに書いてあるだけの GNU 拡張である。"

#. type: Plain text
#: build/C/man3/getumask.3:63
msgid ""
"This function is documented but not implemented yet in glibc, as at version "
"2.9."
msgstr ""
"バージョン 2.9 時点の glibc では、 この関数についての記載はあるが、まだ実装さ"
"れていない。"

#. type: Plain text
#: build/C/man3/getumask.3:65
msgid "B<umask>(2)"
msgstr "B<umask>(2)"

#. type: TH
#: build/C/man3/getusershell.3:30
#, no-wrap
msgid "GETUSERSHELL"
msgstr "GETUSERSHELL"

#. type: TH
#: build/C/man3/getusershell.3:30 build/C/man2/pread.2:25
#, no-wrap
msgid "2013-06-21"
msgstr "2013-06-21"

#. type: Plain text
#: build/C/man3/getusershell.3:33
msgid "getusershell, setusershell, endusershell - get permitted user shells"
msgstr ""
"getusershell, setusershell, endusershell - 許可されたユーザシェルを得る"

#. type: Plain text
#: build/C/man3/getusershell.3:38
#, no-wrap
msgid "B<char *getusershell(void);>\n"
msgstr "B<char *getusershell(void);>\n"

#. type: Plain text
#: build/C/man3/getusershell.3:40
#, no-wrap
msgid "B<void setusershell(void);>\n"
msgstr "B<void setusershell(void);>\n"

#. type: Plain text
#: build/C/man3/getusershell.3:42
#, no-wrap
msgid "B<void endusershell(void);>\n"
msgstr "B<void endusershell(void);>\n"

#. type: Plain text
#: build/C/man3/getusershell.3:53
msgid "B<getusershell>(), B<setusershell>(), B<endusershell>():"
msgstr "B<getusershell>(), B<setusershell>(), B<endusershell>():"

#. type: Plain text
#: build/C/man3/getusershell.3:75
msgid ""
"The B<getusershell>()  function returns the next line from the file I</etc/"
"shells>, opening the file if necessary.  The line should contain the "
"pathname of a valid user shell.  If I</etc/shells> does not exist or is "
"unreadable, B<getusershell>()  behaves as if I</bin/sh> and I</bin/csh> were "
"listed in the file."
msgstr ""
"B<getusershell>()  関数は I</etc/shells> ファイルから (開く必要があればこの"
"ファイルを開いてから) 現在行の次の一行を返す。 返された行の中身は有効なユーザ"
"シェルのうちの一つのパス名である。 (訳注. 一行に付き一つのシェルのパス名が書"
"かれている。)  もし I</etc/shells> が存在しないか、読み込み不可の場合には、 "
"B<getusershell>()  は I</bin/sh> と I</bin/csh> がファイルに記されているかの"
"ようにふるまう。"

#. type: Plain text
#: build/C/man3/getusershell.3:80
msgid "The B<setusershell>()  function rewinds I</etc/shells>."
msgstr ""
"B<setusershell>()  関数は I</etc/shells> ファイルの ファイルポインタを先頭に"
"戻す。"

#. type: Plain text
#: build/C/man3/getusershell.3:85
msgid "The B<endusershell>()  function closes I</etc/shells>."
msgstr "B<endusershell>()  関数は I</etc/shells> ファイルを閉じる。"

#. type: Plain text
#: build/C/man3/getusershell.3:89
msgid "The B<getusershell>()  function returns NULL on end-of-file."
msgstr "B<getusershell>() 関数はファイルの終端では NULL を返す。"

#. type: Plain text
#: build/C/man3/getusershell.3:92
#, no-wrap
msgid "/etc/shells\n"
msgstr "/etc/shells\n"

#. type: Plain text
#: build/C/man3/getusershell.3:101
msgid ""
"The B<getusershell>(), B<setusershell>()  and B<endusershell>()  functions "
"are not thread-safe."
msgstr ""
"関数 B<getusershell>(), B<setusershell>(), B<endusershell>() はスレッドセーフ"
"ではない。"

#. type: Plain text
#: build/C/man3/getusershell.3:103
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man3/getusershell.3:105
msgid "B<shells>(5)"
msgstr "B<shells>(5)"

#. type: TH
#: build/C/man2/idle.2:32
#, no-wrap
msgid "IDLE"
msgstr "IDLE"

#. type: TH
#: build/C/man2/idle.2:32 build/C/man5/shells.5:28
#, no-wrap
msgid "2012-12-31"
msgstr "2012-12-31"

#. type: Plain text
#: build/C/man2/idle.2:35
msgid "idle - make process 0 idle"
msgstr "idle - ID 0 のプロセスをアイドル状態にする"

#. type: Plain text
#: build/C/man2/idle.2:39
msgid "B<int idle(void);>"
msgstr "B<int idle(void);>"

#. type: Plain text
#: build/C/man2/idle.2:46
msgid ""
"B<idle>()  is an internal system call used during bootstrap.  It marks the "
"process's pages as swappable, lowers its priority, and enters the main "
"scheduling loop.  B<idle>()  never returns."
msgstr ""
"B<idle>()  はブートストラップ時に使用される、内部システムコールである。 プロ"
"セスのページをスワップ可能に設定し、優先度を下げ、メインのスケジュー ル処理の"
"ためのループへ移行する。 従って B<idle>()  は return することはない。"

#. type: Plain text
#: build/C/man2/idle.2:52
msgid ""
"Only process 0 may call B<idle>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""
"ID 0 のプロセスのみが B<idle>()  を使用することができる。 他のユーザープロセ"
"スはたとえそれがスーパーユーザー権限を持っていたとして も B<EPERM> を受け取"
"る。"

#. type: Plain text
#: build/C/man2/idle.2:55
msgid ""
"B<idle>()  never returns for process 0, and always returns -1 for a user "
"process."
msgstr ""
"B<idle>()  ID 0 のプロセスに対しては return しない。それ以外のユーザープロセ"
"スには 常に -1 を返す。"

#. type: Plain text
#: build/C/man2/idle.2:59 build/C/man2/setup.2:60
msgid "Always, for a user process."
msgstr "ユーザプロセスに対しては、常にこのエラーとなる。"

#. type: Plain text
#: build/C/man2/idle.2:61
msgid "Since Linux 2.3.13, this system call does not exist anymore."
msgstr "Linux 2.3.13 以降では、もはやこのシステムコールは存在しない。"

#. type: Plain text
#: build/C/man2/idle.2:64 build/C/man2/sysinfo.2:86
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"この関数は Linux 特有であり、移植を意図したプログラムでは 使用すべきでない。"

#. type: TH
#: build/C/man2/ioctl.2:41
#, no-wrap
msgid "IOCTL"
msgstr "IOCTL"

#. type: TH
#: build/C/man2/ioctl.2:41
#, no-wrap
msgid "2013-11-08"
msgstr "2013-11-08"

#. type: Plain text
#: build/C/man2/ioctl.2:44
msgid "ioctl - control device"
msgstr "ioctl - デバイスを制御する"

#. type: Plain text
#: build/C/man2/ioctl.2:46
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr "B<#include E<lt>sys/ioctl.hE<gt>>"

#.  POSIX says 'request' is int, but glibc has the above
#.  See https://bugzilla.kernel.org/show_bug.cgi?id=42705
#. type: Plain text
#: build/C/man2/ioctl.2:50
msgid "B<int ioctl(int >I<d>B<, unsigned long >I<request>B<, ...);>"
msgstr "B<int ioctl(int >I<d>B<, unsigned long >I<request>B<, ...);>"

#. type: Plain text
#: build/C/man2/ioctl.2:61
msgid ""
"The B<ioctl>()  function manipulates the underlying device parameters of "
"special files.  In particular, many operating characteristics of character "
"special files (e.g., terminals) may be controlled with B<ioctl>()  "
"requests.  The argument I<d> must be an open file descriptor."
msgstr ""
"B<ioctl>()  関数はスペシャルファイルを構成するデバイスのパラメータを 操作す"
"る。特に、キャラクタ型のスペシャルファイル (例えば端末 (terminal))  の多くの"
"動作特性を B<ioctl>()  リクエストによって制御することができる。引き数 I<d> は"
"オープンされたファイルディスクリプタでなければならない。"

#. type: Plain text
#: build/C/man2/ioctl.2:69
msgid ""
"The second argument is a device-dependent request code.  The third argument "
"is an untyped pointer to memory.  It's traditionally B<char *>I<argp> (from "
"the days before B<void *> was valid C), and will be so named for this "
"discussion."
msgstr ""
"2 番目の引き数は、デバイス依存のリクエストコードである。 3 番目の引き数は、メ"
"モリへの型を指定しないポインタである。 この引き数は伝統的に (C で B<void *> "
"という書き方が有効になる前から)  B<char *>I<argp> と表記されている。したがっ"
"て、この文章でもそう名付けることとする。"

#. type: Plain text
#: build/C/man2/ioctl.2:85
msgid ""
"An B<ioctl>()  I<request> has encoded in it whether the argument is an I<in> "
"parameter or I<out> parameter, and the size of the argument I<argp> in "
"bytes.  Macros and defines used in specifying an B<ioctl>()  I<request> are "
"located in the file I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""
"B<ioctl>()  の I<request> には、 その引き数が I<入力> パラメータと I<出力> パ"
"ラメータのどちらであるかの区別や、 I<argp> 引き数のバイト単位のサイズ、といっ"
"た情報がエンコードされている。 B<ioctl>()  の I<request> を指定するためのマク"
"ロ (macro) と定義は I<E<lt>sys/ioctl.hE<gt>> ファイルにある。"

#. type: Plain text
#: build/C/man2/ioctl.2:94
msgid ""
"Usually, on success zero is returned.  A few B<ioctl>()  requests use the "
"return value as an output parameter and return a nonnegative value on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"たいていの場合、成功するとゼロが返される。 ただし、 B<ioctl>()  リクエストの"
"中にはパラメータの出力に返り値を使用しているものが若干あり、 その場合は、成功"
"したときに非負の値が返される。 エラーの場合は -1 が返され、 I<errno> が適切に"
"設定される。"

#. type: Plain text
#: build/C/man2/ioctl.2:99
msgid "I<d> is not a valid descriptor."
msgstr "I<d> が有効なディスクリプタではない。"

#. type: Plain text
#: build/C/man2/ioctl.2:103
msgid "I<argp> references an inaccessible memory area."
msgstr "I<argp> がアクセス不可能なメモリを参照している。"

#. type: Plain text
#: build/C/man2/ioctl.2:109
msgid "I<Request> or I<argp> is not valid."
msgstr "I<request> または I<argp> が不正である。"

#. type: Plain text
#: build/C/man2/ioctl.2:113
msgid "I<d> is not associated with a character special device."
msgstr "I<d> がキャラクタ型のスペシャルデバイスを参照していない。"

#. type: Plain text
#: build/C/man2/ioctl.2:119
msgid ""
"The specified request does not apply to the kind of object that the "
"descriptor I<d> references."
msgstr ""
"指定されたリクエストはディスクリプタ I<d> が参照する種類のオブジェクトには適"
"用することができない。"

#. type: Plain text
#: build/C/man2/ioctl.2:134
msgid ""
"No single standard.  Arguments, returns, and semantics of B<ioctl>()  vary "
"according to the device driver in question (the call is used as a catch-all "
"for operations that don't cleanly fit the UNIX stream I/O model).  See "
"B<ioctl_list>(2)  for a list of many of the known B<ioctl>()  calls.  The "
"B<ioctl>()  function call appeared in Version 7 AT&T UNIX."
msgstr ""
"どれか一つの標準に対応しているわけではない。 B<ioctl>()  の引き数、返り値、解"
"釈は、処理対象のデバイスドライバごとに 異なる (この関数は UNIX の ストリーム "
"I/O モデル に きちんと適合していない操作のための便利屋として使用される)。 よ"
"く知られている B<ioctl>()  のリストについては B<ioctl_list>(2)  を参照するこ"
"と。 B<ioctl>()  関数コールは Version 7 AT&T UNIX で登場した。"

#. type: Plain text
#: build/C/man2/ioctl.2:142
msgid ""
"In order to use this call, one needs an open file descriptor.  Often the "
"B<open>(2)  call has unwanted side effects, that can be avoided under Linux "
"by giving it the B<O_NONBLOCK> flag."
msgstr ""
"このシステムコールを使うには、オープンされたファイルディスクリプタが 必要であ"
"る。 B<open>(2)  コールはしばしば望んでいない副作用を伴うことがあるが、Linux "
"では B<open>(2)  に B<O_NONBLOCK> フラグをつけることでこの副作用を避けること"
"ができる。"

#.  .BR mt (4),
#. type: Plain text
#: build/C/man2/ioctl.2:150
msgid ""
"B<execve>(2), B<fcntl>(2), B<ioctl_list>(2), B<open>(2), B<sd>(4), B<tty>(4)"
msgstr ""
"B<execve>(2), B<fcntl>(2), B<ioctl_list>(2), B<open>(2), B<sd>(4), B<tty>(4)"

#. type: TH
#: build/C/man2/ioctl_list.2:30
#, no-wrap
msgid "IOCTL_LIST"
msgstr "IOCTL_LIST"

#. type: TH
#: build/C/man2/ioctl_list.2:30
#, no-wrap
msgid "2013-09-17"
msgstr "2013-09-17"

#. type: Plain text
#: build/C/man2/ioctl_list.2:33
msgid "ioctl_list - list of ioctl calls in Linux/i386 kernel"
msgstr "ioctl_list - Linux/i386 カーネルの ioctl のリスト"

#. type: Plain text
#: build/C/man2/ioctl_list.2:40
msgid ""
"This is Ioctl List 1.3.27, a list of ioctl calls in Linux/i386 kernel "
"1.3.27.  It contains 421 ioctls from I<E<lt>/usr/include/{asm,linux}/*."
"hE<gt>>.  For each ioctl, its numerical value, its name, and its argument "
"type are given."
msgstr ""
"この文章は ioctl リスト 1.3.27、つまり Linux/i386 カーネル 1.3.27 に おける "
"ioctl コールの一覧です。このリストは I<E<lt>/usr/include/{asm,linux}/*."
"hE<gt>> にある 421 の ioctl を含んでいます。全ての ioctl に対して、数値、名"
"称、 引き数の型を列挙してあります。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:48
msgid ""
"An argument type of I<const struct foo\\ *> means the argument is input to "
"the kernel.  I<struct foo\\ *> means the kernel outputs the argument.  If "
"the kernel uses the argument for both input and output, this is marked with "
"I<//\\ I-O>."
msgstr ""
"引き数型 I<const struct foo\\ *> は、その引き数がカーネルへの入力である事を意"
"味します。また、 I<struct foo\\ *> は、その引き数がカーネルからの出力である事"
"を意味します。 カーネルがその引き数を入力と出力の両方に使用する場合は、 I<//"
"\\ I-O> マークを付けてあります。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:53
msgid ""
"Some ioctls take more arguments or return more values than a single "
"structure.  These are marked I<//\\ MORE> and documented further in a "
"separate section."
msgstr ""
"いくつかの ioctl は複数の構造体の引き数を必要としたり、値を返したり します。"
"これらには I<//\\ MORE> マークを付けて、 さらに分離したセクションで説明してあ"
"ります。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:55
msgid "This list is very incomplete."
msgstr "このリストは不完全です。"

#. type: SS
#: build/C/man2/ioctl_list.2:55
#, no-wrap
msgid "ioctl structure"
msgstr "ioctl の構造"

#.  added two sections - aeb
#. type: Plain text
#: build/C/man2/ioctl_list.2:60
msgid ""
"Ioctl command values are 32-bit constants.  In principle these constants are "
"completely arbitrary, but people have tried to build some structure into "
"them."
msgstr ""
"ioctl コマンドの値は 32 ビットの定数です。 原則として、これらの定数は全く任意"
"のものですが、 設計者は何らかの構造をこれらの定数に組み込もうとしています。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:79
msgid ""
"The old Linux situation was that of mostly 16-bit constants, where the last "
"byte is a serial number, and the preceding byte(s) give a type indicating "
"the driver.  Sometimes the major number was used: 0x03 for the B<HDIO_*> "
"ioctls, 0x06 for the B<LP*> ioctls.  And sometimes one or more ASCII letters "
"were used.  For example, B<TCGETS> has value 0x00005401, with 0x54 = \\(aqT"
"\\(aq indicating the terminal driver, and B<CYGETTIMEOUT> has value "
"0x00435906, with 0x43 0x59 = \\(aqC\\(aq \\(aqY\\(aq indicating the cyclades "
"driver."
msgstr ""
"昔の Linux では、大部分は 16 ビットの定数であり、 下位バイトはシリアル番号"
"で、上位バイトはドライバのタイプを表していました。 メジャー番号が使われること"
"もありました: 0x03 が B<HDIO_*> ioctl, 0x06 が B<LP*> ioctl などです。 1 文字"
"以上の ASCII 文字列が使われることもありました。 たとえば B<TCGETS> の値は "
"0x00005401 であり、 0x54 = \\(aqT\\(aq でターミナルドライバを表します。 "
"B<CYGETTIMEOUT> の値は 0x00435906 であり、 0x43 0x59 = \\(aqC\\(aq \\(aqY"
"\\(aq で cyclades ドライバを表します。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:87
msgid ""
"Later (0.98p5) some more information was built into the number.  One has 2 "
"direction bits (00: none, 01: write, 10: read, 11: read/write)  followed by "
"14 size bits (giving the size of the argument), followed by an 8-bit type "
"(collecting the ioctls in groups for a common purpose or a common driver), "
"and an 8-bit serial number."
msgstr ""
"後の時代 (0.98p5) になると、 より多くの情報が数値に組み込まれるようになりまし"
"た。 1 つの数値は、読み書きの方向を表す 2 ビット (00: 読み書きなし, 01: 書き"
"込み, 10: 読み込み, 11: 読み込み/書き込み)、 (引き数のサイズを表す) 14 ビッ"
"ト、 (共通の目的または共通のドライバで ioctl をグループにするための)  8 ビッ"
"トのタイプ、8 ビットのシリアル番号から構成されます。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:98
msgid ""
"The macros describing this structure live in I<E<lt>asm/ioctl.hE<gt>> and "
"are B<_IO(type,nr)> and B<{_IOR,_IOW,_IOWR}(type,nr,size)>.  They use "
"I<sizeof(size)> so that size is a misnomer here: this third argument is a "
"data type."
msgstr ""
"この構造を記述するマクロは I<E<lt>asm/ioctl.hE<gt>> にあり、 B<_IO(type,nr)> "
"と B<{_IOR,_IOW,_IOWR}(type,nr,size)> です。 これらのマクロは I<sizeof(size)"
"> を使うので、 ここで size という名前にしているのは間違っています: この 3 つ"
"目の引き数はデータタイプです。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:103
msgid ""
"Note that the size bits are very unreliable: in lots of cases they are "
"wrong, either because of buggy macros using I<sizeof(sizeof(struct))>, or "
"because of legacy values."
msgstr ""
"size ビットは全く当てにならない点に注意して下さい: 多くの場合、間違っていま"
"す。 これは I<sizeof(sizeof(struct))> を使ったバグを含んだマクロや、過去から"
"受け継いだ値が原因です。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:107
msgid ""
"Thus, it seems that the new structure only gave disadvantages: it does not "
"help in checking, but it causes varying values for the various architectures."
msgstr ""
"したがって、新しい構造は不都合な点しかないように思われます: この構造はチェッ"
"クの手助けにはならず、 様々なアーキテクチャによって値を変化させてしまいます。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:113
msgid ""
"Decent ioctls return 0 on success and -1 on error, while any output value is "
"stored via the argument.  However, quite a few ioctls in fact return an "
"output value.  This is not yet indicated below."
msgstr ""
"きちんとした ioctl は、成功した場合は 0 を返し、 エラーの場合は -1 を返しま"
"す。 また出力値は引き数に格納します。 しかし実際は、かなり多くの ioctl が出力"
"値を返します。 これは今のところ以下では示されていません。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:115
msgid "// Main table."
msgstr "// Main table."

#. type: Plain text
#: build/C/man2/ioctl_list.2:117
msgid "// E<lt>include/asm-i386/socket.hE<gt>"
msgstr "// E<lt>include/asm-i386/socket.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:119
#, no-wrap
msgid "0x00008901\tFIOSETOWN\tconst int *\n"
msgstr "0x00008901\tFIOSETOWN\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:120
#, no-wrap
msgid "0x00008902\tSIOCSPGRP\tconst int *\n"
msgstr "0x00008902\tSIOCSPGRP\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:121
#, no-wrap
msgid "0x00008903\tFIOGETOWN\tint *\n"
msgstr "0x00008903\tFIOGETOWN\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:122
#, no-wrap
msgid "0x00008904\tSIOCGPGRP\tint *\n"
msgstr "0x00008904\tSIOCGPGRP\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:123
#, no-wrap
msgid "0x00008905\tSIOCATMAR\tint *\n"
msgstr "0x00008905\tSIOCATMAR\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:124
#, no-wrap
msgid "0x00008906\tSIOCGSTAMP\ttimeval *\n"
msgstr "0x00008906\tSIOCGSTAMP\ttimeval *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:128
msgid "// E<lt>include/asm-i386/termios.hE<gt>"
msgstr "// E<lt>include/asm-i386/termios.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:130
#, no-wrap
msgid "0x00005401\tTCGETS\tstruct termios *\n"
msgstr "0x00005401\tTCGETS\tstruct termios *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:131
#, no-wrap
msgid "0x00005402\tTCSETS\tconst struct termios *\n"
msgstr "0x00005402\tTCSETS\tconst struct termios *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:132
#, no-wrap
msgid "0x00005403\tTCSETSW\tconst struct termios *\n"
msgstr "0x00005403\tTCSETSW\tconst struct termios *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:133
#, no-wrap
msgid "0x00005404\tTCSETSF\tconst struct termios *\n"
msgstr "0x00005404\tTCSETSF\tconst struct termios *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:134
#, no-wrap
msgid "0x00005405\tTCGETA\tstruct termio *\n"
msgstr "0x00005405\tTCGETA\tstruct termio *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:135
#, no-wrap
msgid "0x00005406\tTCSETA\tconst struct termio *\n"
msgstr "0x00005406\tTCSETA\tconst struct termio *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:136
#, no-wrap
msgid "0x00005407\tTCSETAW\tconst struct termio *\n"
msgstr "0x00005407\tTCSETAW\tconst struct termio *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:137
#, no-wrap
msgid "0x00005408\tTCSETAF\tconst struct termio *\n"
msgstr "0x00005408\tTCSETAF\tconst struct termio *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:138
#, no-wrap
msgid "0x00005409\tTCSBRK\tint\n"
msgstr "0x00005409\tTCSBRK\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:139
#, no-wrap
msgid "0x0000540A\tTCXONC\tint\n"
msgstr "0x0000540A\tTCXONC\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:140
#, no-wrap
msgid "0x0000540B\tTCFLSH\tint\n"
msgstr "0x0000540B\tTCFLSH\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:141
#, no-wrap
msgid "0x0000540C\tTIOCEXCL\tvoid\n"
msgstr "0x0000540C\tTIOCEXCL\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:142
#, no-wrap
msgid "0x0000540D\tTIOCNXCL\tvoid\n"
msgstr "0x0000540D\tTIOCNXCL\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:143
#, no-wrap
msgid "0x0000540E\tTIOCSCTTY\tint\n"
msgstr "0x0000540E\tTIOCSCTTY\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:144
#, no-wrap
msgid "0x0000540F\tTIOCGPGRP\tpid_t *\n"
msgstr "0x0000540F\tTIOCGPGRP\tpid_t *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:145
#, no-wrap
msgid "0x00005410\tTIOCSPGRP\tconst pid_t *\n"
msgstr "0x00005410\tTIOCSPGRP\tconst pid_t *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:146
#, no-wrap
msgid "0x00005411\tTIOCOUTQ\tint *\n"
msgstr "0x00005411\tTIOCOUTQ\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:147
#, no-wrap
msgid "0x00005412\tTIOCSTI\tconst char *\n"
msgstr "0x00005412\tTIOCSTI\tconst char *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:148
#, no-wrap
msgid "0x00005413\tTIOCGWINSZ\tstruct winsize *\n"
msgstr "0x00005413\tTIOCGWINSZ\tstruct winsize *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:149
#, no-wrap
msgid "0x00005414\tTIOCSWINSZ\tconst struct winsize *\n"
msgstr "0x00005414\tTIOCSWINSZ\tconst struct winsize *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:150
#, no-wrap
msgid "0x00005415\tTIOCMGET\tint *\n"
msgstr "0x00005415\tTIOCMGET\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:151
#, no-wrap
msgid "0x00005416\tTIOCMBIS\tconst int *\n"
msgstr "0x00005416\tTIOCMBIS\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:152
#, no-wrap
msgid "0x00005417\tTIOCMBIC\tconst int *\n"
msgstr "0x00005417\tTIOCMBIC\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:153
#, no-wrap
msgid "0x00005418\tTIOCMSET\tconst int *\n"
msgstr "0x00005418\tTIOCMSET\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:154
#, no-wrap
msgid "0x00005419\tTIOCGSOFTCAR\tint *\n"
msgstr "0x00005419\tTIOCGSOFTCAR\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:155
#, no-wrap
msgid "0x0000541A\tTIOCSSOFTCAR\tconst int *\n"
msgstr "0x0000541A\tTIOCSSOFTCAR\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:156
#, no-wrap
msgid "0x0000541B\tFIONREAD\tint *\n"
msgstr "0x0000541B\tFIONREAD\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:157
#, no-wrap
msgid "0x0000541B\tTIOCINQ\tint *\n"
msgstr "0x0000541B\tTIOCINQ\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:158
#, no-wrap
msgid "0x0000541C\tTIOCLINUX\tconst char *\t// MORE\n"
msgstr "0x0000541C\tTIOCLINUX\tconst char *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:159
#, no-wrap
msgid "0x0000541D\tTIOCCONS\tvoid\n"
msgstr "0x0000541D\tTIOCCONS\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:160
#, no-wrap
msgid "0x0000541E\tTIOCGSERIAL\tstruct serial_struct *\n"
msgstr "0x0000541E\tTIOCGSERIAL\tstruct serial_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:161
#, no-wrap
msgid "0x0000541F\tTIOCSSERIAL\tconst struct serial_struct *\n"
msgstr "0x0000541F\tTIOCSSERIAL\tconst struct serial_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:162
#, no-wrap
msgid "0x00005420\tTIOCPKT\tconst int *\n"
msgstr "0x00005420\tTIOCPKT\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:163
#, no-wrap
msgid "0x00005421\tFIONBIO\tconst int *\n"
msgstr "0x00005421\tFIONBIO\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:164
#, no-wrap
msgid "0x00005422\tTIOCNOTTY\tvoid\n"
msgstr "0x00005422\tTIOCNOTTY\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:165
#, no-wrap
msgid "0x00005423\tTIOCSETD\tconst int *\n"
msgstr "0x00005423\tTIOCSETD\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:166
#, no-wrap
msgid "0x00005424\tTIOCGETD\tint *\n"
msgstr "0x00005424\tTIOCGETD\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:167
#, no-wrap
msgid "0x00005425\tTCSBRKP\tint\n"
msgstr "0x00005425\tTCSBRKP\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:168
#, no-wrap
msgid "0x00005426\tTIOCTTYGSTRUCT\tstruct tty_struct *\n"
msgstr "0x00005426\tTIOCTTYGSTRUCT\tstruct tty_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:169
#, no-wrap
msgid "0x00005450\tFIONCLEX\tvoid\n"
msgstr "0x00005450\tFIONCLEX\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:170
#, no-wrap
msgid "0x00005451\tFIOCLEX\tvoid\n"
msgstr "0x00005451\tFIOCLEX\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:171
#, no-wrap
msgid "0x00005452\tFIOASYNC\tconst int *\n"
msgstr "0x00005452\tFIOASYNC\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:172
#, no-wrap
msgid "0x00005453\tTIOCSERCONFIG\tvoid\n"
msgstr "0x00005453\tTIOCSERCONFIG\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:173
#, no-wrap
msgid "0x00005454\tTIOCSERGWILD\tint *\n"
msgstr "0x00005454\tTIOCSERGWILD\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:174
#, no-wrap
msgid "0x00005455\tTIOCSERSWILD\tconst int *\n"
msgstr "0x00005455\tTIOCSERSWILD\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:175
#, no-wrap
msgid "0x00005456\tTIOCGLCKTRMIOS\tstruct termios *\n"
msgstr "0x00005456\tTIOCGLCKTRMIOS\tstruct termios *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:176
#, no-wrap
msgid "0x00005457\tTIOCSLCKTRMIOS\tconst struct termios *\n"
msgstr "0x00005457\tTIOCSLCKTRMIOS\tconst struct termios *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:177
#, no-wrap
msgid "0x00005458\tTIOCSERGSTRUCT\tstruct async_struct *\n"
msgstr "0x00005458\tTIOCSERGSTRUCT\tstruct async_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:178
#, no-wrap
msgid "0x00005459\tTIOCSERGETLSR\tint *\n"
msgstr "0x00005459\tTIOCSERGETLSR\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:185
#, no-wrap
msgid "0x0000545A\tTIOCSERGETMULTI\tstruct serial_multiport_struct *\n"
msgstr "0x0000545A\tTIOCSERGETMULTI\tstruct serial_multiport_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:186
#, no-wrap
msgid "0x0000545B\tTIOCSERSETMULTI\tconst struct serial_multiport_struct *\n"
msgstr "0x0000545B\tTIOCSERSETMULTI\tconst struct serial_multiport_struct *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:190
msgid "// E<lt>include/linux/ax25.hE<gt>"
msgstr "// E<lt>include/linux/ax25.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:192
#, no-wrap
msgid "0x000089E0\tSIOCAX25GETUID\tconst struct sockaddr_ax25 *\n"
msgstr "0x000089E0\tSIOCAX25GETUID\tconst struct sockaddr_ax25 *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:193
#, no-wrap
msgid "0x000089E1\tSIOCAX25ADDUID\tconst struct sockaddr_ax25 *\n"
msgstr "0x000089E1\tSIOCAX25ADDUID\tconst struct sockaddr_ax25 *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:194
#, no-wrap
msgid "0x000089E2\tSIOCAX25DELUID\tconst struct sockaddr_ax25 *\n"
msgstr "0x000089E2\tSIOCAX25DELUID\tconst struct sockaddr_ax25 *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:195
#, no-wrap
msgid "0x000089E3\tSIOCAX25NOUID\tconst int *\n"
msgstr "0x000089E3\tSIOCAX25NOUID\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:196
#, no-wrap
msgid "0x000089E4\tSIOCAX25DIGCTL\tconst int *\n"
msgstr "0x000089E4\tSIOCAX25DIGCTL\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:197
#, no-wrap
msgid "0x000089E5\tSIOCAX25GETPARMS\tstruct ax25_parms_struct *\t// I-O\n"
msgstr "0x000089E5\tSIOCAX25GETPARMS\tstruct ax25_parms_struct *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:201
#, no-wrap
msgid "0x000089E6\tSIOCAX25SETPARMS\tconst struct ax25_parms_struct *\n"
msgstr "0x000089E6\tSIOCAX25SETPARMS\tconst struct ax25_parms_struct *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:205
msgid "// E<lt>include/linux/cdk.hE<gt>"
msgstr "// E<lt>include/linux/cdk.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:207
#, no-wrap
msgid "0x00007314\tSTL_BINTR\tvoid\n"
msgstr "0x00007314\tSTL_BINTR\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:208
#, no-wrap
msgid "0x00007315\tSTL_BSTART\tvoid\n"
msgstr "0x00007315\tSTL_BSTART\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:209
#, no-wrap
msgid "0x00007316\tSTL_BSTOP\tvoid\n"
msgstr "0x00007316\tSTL_BSTOP\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:210
#, no-wrap
msgid "0x00007317\tSTL_BRESET\tvoid\n"
msgstr "0x00007317\tSTL_BRESET\tvoid\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:214
msgid "// E<lt>include/linux/cdrom.hE<gt>"
msgstr "// E<lt>include/linux/cdrom.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:216
#, no-wrap
msgid "0x00005301\tCDROMPAUSE\tvoid\n"
msgstr "0x00005301\tCDROMPAUSE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:217
#, no-wrap
msgid "0x00005302\tCDROMRESUME\tvoid\n"
msgstr "0x00005302\tCDROMRESUME\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:218
#, no-wrap
msgid "0x00005303\tCDROMPLAYMSF\tconst struct cdrom_msf *\n"
msgstr "0x00005303\tCDROMPLAYMSF\tconst struct cdrom_msf *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:219
#, no-wrap
msgid "0x00005304\tCDROMPLAYTRKIND\tconst struct cdrom_ti *\n"
msgstr "0x00005304\tCDROMPLAYTRKIND\tconst struct cdrom_ti *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:220
#, no-wrap
msgid "0x00005305\tCDROMREADTOCHDR\tstruct cdrom_tochdr *\n"
msgstr "0x00005305\tCDROMREADTOCHDR\tstruct cdrom_tochdr *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:224
#, no-wrap
msgid "0x00005306\tCDROMREADTOCENTRY\tstruct cdrom_tocentry *\t// I-O\n"
msgstr "0x00005306\tCDROMREADTOCENTRY\tstruct cdrom_tocentry *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:228
#, no-wrap
msgid "0x00005307\tCDROMSTOP\tvoid\n"
msgstr "0x00005307\tCDROMSTOP\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:229
#, no-wrap
msgid "0x00005308\tCDROMSTART\tvoid\n"
msgstr "0x00005308\tCDROMSTART\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:230
#, no-wrap
msgid "0x00005309\tCDROMEJECT\tvoid\n"
msgstr "0x00005309\tCDROMEJECT\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:231
#, no-wrap
msgid "0x0000530A\tCDROMVOLCTRL\tconst struct cdrom_volctrl *\n"
msgstr "0x0000530A\tCDROMVOLCTRL\tconst struct cdrom_volctrl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:232
#, no-wrap
msgid "0x0000530B\tCDROMSUBCHNL\tstruct cdrom_subchnl *\t// I-O\n"
msgstr "0x0000530B\tCDROMSUBCHNL\tstruct cdrom_subchnl *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:233
#, no-wrap
msgid "0x0000530C\tCDROMREADMODE2\tconst struct cdrom_msf *\t// MORE\n"
msgstr "0x0000530C\tCDROMREADMODE2\tconst struct cdrom_msf *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:234
#, no-wrap
msgid "0x0000530D\tCDROMREADMODE1\tconst struct cdrom_msf *\t// MORE\n"
msgstr "0x0000530D\tCDROMREADMODE1\tconst struct cdrom_msf *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:235
#, no-wrap
msgid "0x0000530E\tCDROMREADAUDIO\tconst struct cdrom_read_audio *\t// MORE\n"
msgstr "0x0000530E\tCDROMREADAUDIO\tconst struct cdrom_read_audio *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:236
#, no-wrap
msgid "0x0000530F\tCDROMEJECT_SW\tint\n"
msgstr "0x0000530F\tCDROMEJECT_SW\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:240
#, no-wrap
msgid "0x00005310\tCDROMMULTISESSION\tstruct cdrom_multisession *\t// I-O\n"
msgstr "0x00005310\tCDROMMULTISESSION\tstruct cdrom_multisession *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:244
#, no-wrap
msgid "0x00005311\tCDROM_GET_UPC\tstruct { char [8]; } *\n"
msgstr "0x00005311\tCDROM_GET_UPC\tstruct { char [8]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:245
#, no-wrap
msgid "0x00005312\tCDROMRESET\tvoid\n"
msgstr "0x00005312\tCDROMRESET\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:246
#, no-wrap
msgid "0x00005313\tCDROMVOLREAD\tstruct cdrom_volctrl *\n"
msgstr "0x00005313\tCDROMVOLREAD\tstruct cdrom_volctrl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:247
#, no-wrap
msgid "0x00005314\tCDROMREADRAW\tconst struct cdrom_msf *\t// MORE\n"
msgstr "0x00005314\tCDROMREADRAW\tconst struct cdrom_msf *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:248
#, no-wrap
msgid "0x00005315\tCDROMREADCOOKED\tconst struct cdrom_msf *\t// MORE\n"
msgstr "0x00005315\tCDROMREADCOOKED\tconst struct cdrom_msf *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:249
#, no-wrap
msgid "0x00005316\tCDROMSEEK\tconst struct cdrom_msf *\n"
msgstr "0x00005316\tCDROMSEEK\tconst struct cdrom_msf *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:253
msgid "// E<lt>include/linux/cm206.hE<gt>"
msgstr "// E<lt>include/linux/cm206.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:255
#, no-wrap
msgid "0x00002000\tCM206CTL_GET_STAT\tint\n"
msgstr "0x00002000\tCM206CTL_GET_STAT\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:256
#, no-wrap
msgid "0x00002001\tCM206CTL_GET_LAST_STAT\tint\n"
msgstr "0x00002001\tCM206CTL_GET_LAST_STAT\tint\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:260
msgid "// E<lt>include/linux/cyclades.hE<gt>"
msgstr "// E<lt>include/linux/cyclades.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:262
#, no-wrap
msgid "0x00435901\tCYGETMON\tstruct cyclades_monitor *\n"
msgstr "0x00435901\tCYGETMON\tstruct cyclades_monitor *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:263
#, no-wrap
msgid "0x00435902\tCYGETTHRESH\tint *\n"
msgstr "0x00435902\tCYGETTHRESH\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:264
#, no-wrap
msgid "0x00435903\tCYSETTHRESH\tint\n"
msgstr "0x00435903\tCYSETTHRESH\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:265
#, no-wrap
msgid "0x00435904\tCYGETDEFTHRESH\tint *\n"
msgstr "0x00435904\tCYGETDEFTHRESH\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:266
#, no-wrap
msgid "0x00435905\tCYSETDEFTHRESH\tint\n"
msgstr "0x00435905\tCYSETDEFTHRESH\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:267
#, no-wrap
msgid "0x00435906\tCYGETTIMEOUT\tint *\n"
msgstr "0x00435906\tCYGETTIMEOUT\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:268
#, no-wrap
msgid "0x00435907\tCYSETTIMEOUT\tint\n"
msgstr "0x00435907\tCYSETTIMEOUT\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:269
#, no-wrap
msgid "0x00435908\tCYGETDEFTIMEOUT\tint *\n"
msgstr "0x00435908\tCYGETDEFTIMEOUT\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:270
#, no-wrap
msgid "0x00435909\tCYSETDEFTIMEOUT\tint\n"
msgstr "0x00435909\tCYSETDEFTIMEOUT\tint\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:274
msgid "// E<lt>include/linux/ext2_fs.hE<gt>"
msgstr "// E<lt>include/linux/ext2_fs.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:276
#, no-wrap
msgid "0x80046601\tEXT2_IOC_GETFLAGS\tint *\n"
msgstr "0x80046601\tEXT2_IOC_GETFLAGS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:277
#, no-wrap
msgid "0x40046602\tEXT2_IOC_SETFLAGS\tconst int *\n"
msgstr "0x40046602\tEXT2_IOC_SETFLAGS\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:278
#, no-wrap
msgid "0x80047601\tEXT2_IOC_GETVERSION\tint *\n"
msgstr "0x80047601\tEXT2_IOC_GETVERSION\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:279
#, no-wrap
msgid "0x40047602\tEXT2_IOC_SETVERSION\tconst int *\n"
msgstr "0x40047602\tEXT2_IOC_SETVERSION\tconst int *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:283
msgid "// E<lt>include/linux/fd.hE<gt>"
msgstr "// E<lt>include/linux/fd.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:285
#, no-wrap
msgid "0x00000000\tFDCLRPRM\tvoid\n"
msgstr "0x00000000\tFDCLRPRM\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:286
#, no-wrap
msgid "0x00000001\tFDSETPRM\tconst struct floppy_struct *\n"
msgstr "0x00000001\tFDSETPRM\tconst struct floppy_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:287
#, no-wrap
msgid "0x00000002\tFDDEFPRM\tconst struct floppy_struct *\n"
msgstr "0x00000002\tFDDEFPRM\tconst struct floppy_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:288
#, no-wrap
msgid "0x00000003\tFDGETPRM\tstruct floppy_struct *\n"
msgstr "0x00000003\tFDGETPRM\tstruct floppy_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:289
#, no-wrap
msgid "0x00000004\tFDMSGON\tvoid\n"
msgstr "0x00000004\tFDMSGON\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:290
#, no-wrap
msgid "0x00000005\tFDMSGOFF\tvoid\n"
msgstr "0x00000005\tFDMSGOFF\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:291
#, no-wrap
msgid "0x00000006\tFDFMTBEG\tvoid\n"
msgstr "0x00000006\tFDFMTBEG\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:292
#, no-wrap
msgid "0x00000007\tFDFMTTRK\tconst struct format_descr *\n"
msgstr "0x00000007\tFDFMTTRK\tconst struct format_descr *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:293
#, no-wrap
msgid "0x00000008\tFDFMTEND\tvoid\n"
msgstr "0x00000008\tFDFMTEND\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:294
#, no-wrap
msgid "0x0000000A\tFDSETEMSGTRESH\tint\n"
msgstr "0x0000000A\tFDSETEMSGTRESH\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:295
#, no-wrap
msgid "0x0000000B\tFDFLUSH\tvoid\n"
msgstr "0x0000000B\tFDFLUSH\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:296
#, no-wrap
msgid "0x0000000C\tFDSETMAXERRS\tconst struct floppy_max_errors *\n"
msgstr "0x0000000C\tFDSETMAXERRS\tconst struct floppy_max_errors *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:297
#, no-wrap
msgid "0x0000000E\tFDGETMAXERRS\tstruct floppy_max_errors *\n"
msgstr "0x0000000E\tFDGETMAXERRS\tstruct floppy_max_errors *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:298
#, no-wrap
msgid "0x00000010\tFDGETDRVTYP\tstruct { char [16]; } *\n"
msgstr "0x00000010\tFDGETDRVTYP\tstruct { char [16]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:299
#, no-wrap
msgid "0x00000014\tFDSETDRVPRM\tconst struct floppy_drive_params *\n"
msgstr "0x00000014\tFDSETDRVPRM\tconst struct floppy_drive_params *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:300
#, no-wrap
msgid "0x00000015\tFDGETDRVPRM\tstruct floppy_drive_params *\n"
msgstr "0x00000015\tFDGETDRVPRM\tstruct floppy_drive_params *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:301
#, no-wrap
msgid "0x00000016\tFDGETDRVSTAT\tstruct floppy_drive_struct *\n"
msgstr "0x00000016\tFDGETDRVSTAT\tstruct floppy_drive_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:302
#, no-wrap
msgid "0x00000017\tFDPOLLDRVSTAT\tstruct floppy_drive_struct *\n"
msgstr "0x00000017\tFDPOLLDRVSTAT\tstruct floppy_drive_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:303
#, no-wrap
msgid "0x00000018\tFDRESET\tint\n"
msgstr "0x00000018\tFDRESET\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:304
#, no-wrap
msgid "0x00000019\tFDGETFDCSTAT\tstruct floppy_fdc_state *\n"
msgstr "0x00000019\tFDGETFDCSTAT\tstruct floppy_fdc_state *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:305
#, no-wrap
msgid "0x0000001B\tFDWERRORCLR\tvoid\n"
msgstr "0x0000001B\tFDWERRORCLR\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:306
#, no-wrap
msgid "0x0000001C\tFDWERRORGET\tstruct floppy_write_errors *\n"
msgstr "0x0000001C\tFDWERRORGET\tstruct floppy_write_errors *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:310
#, no-wrap
msgid "0x0000001E\tFDRAWCMD\tstruct floppy_raw_cmd *\t// MORE // I-O\n"
msgstr "0x0000001E\tFDRAWCMD\tstruct floppy_raw_cmd *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:311
#, no-wrap
msgid "0x00000028\tFDTWADDLE\tvoid\n"
msgstr "0x00000028\tFDTWADDLE\tvoid\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:315
msgid "// E<lt>include/linux/fs.hE<gt>"
msgstr "// E<lt>include/linux/fs.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:317
#, no-wrap
msgid "0x0000125D\tBLKROSET\tconst int *\n"
msgstr "0x0000125D\tBLKROSET\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:318
#, no-wrap
msgid "0x0000125E\tBLKROGET\tint *\n"
msgstr "0x0000125E\tBLKROGET\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:319
#, no-wrap
msgid "0x0000125F\tBLKRRPART\tvoid\n"
msgstr "0x0000125F\tBLKRRPART\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:320
#, no-wrap
msgid "0x00001260\tBLKGETSIZE\tunsigned long *\n"
msgstr "0x00001260\tBLKGETSIZE\tunsigned long *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:321
#, no-wrap
msgid "0x00001261\tBLKFLSBUF\tvoid\n"
msgstr "0x00001261\tBLKFLSBUF\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:322
#, no-wrap
msgid "0x00001262\tBLKRASET\tint\n"
msgstr "0x00001262\tBLKRASET\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:323
#, no-wrap
msgid "0x00001263\tBLKRAGET\tint *\n"
msgstr "0x00001263\tBLKRAGET\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:324
#, no-wrap
msgid "0x00000001\tFIBMAP\tint *\t// I-O\n"
msgstr "0x00000001\tFIBMAP\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:325
#, no-wrap
msgid "0x00000002\tFIGETBSZ\tint *\n"
msgstr "0x00000002\tFIGETBSZ\tint *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:329
msgid "// E<lt>include/linux/hdreg.hE<gt>"
msgstr "// E<lt>include/linux/hdreg.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:331
#, no-wrap
msgid "0x00000301\tHDIO_GETGEO\tstruct hd_geometry *\n"
msgstr "0x00000301\tHDIO_GETGEO\tstruct hd_geometry *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:332
#, no-wrap
msgid "0x00000302\tHDIO_GET_UNMASKINTR\tint *\n"
msgstr "0x00000302\tHDIO_GET_UNMASKINTR\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:333
#, no-wrap
msgid "0x00000304\tHDIO_GET_MULTCOUNT\tint *\n"
msgstr "0x00000304\tHDIO_GET_MULTCOUNT\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:334
#, no-wrap
msgid "0x00000307\tHDIO_GET_IDENTITY\tstruct hd_driveid *\n"
msgstr "0x00000307\tHDIO_GET_IDENTITY\tstruct hd_driveid *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:335
#, no-wrap
msgid "0x00000308\tHDIO_GET_KEEPSETTINGS\tint *\n"
msgstr "0x00000308\tHDIO_GET_KEEPSETTINGS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:336
#, no-wrap
msgid "0x00000309\tHDIO_GET_CHIPSET\tint *\n"
msgstr "0x00000309\tHDIO_GET_CHIPSET\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:337
#, no-wrap
msgid "0x0000030A\tHDIO_GET_NOWERR\tint *\n"
msgstr "0x0000030A\tHDIO_GET_NOWERR\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:338
#, no-wrap
msgid "0x0000030B\tHDIO_GET_DMA\tint *\n"
msgstr "0x0000030B\tHDIO_GET_DMA\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:339
#, no-wrap
msgid "0x0000031F\tHDIO_DRIVE_CMD\tint *\t// I-O\n"
msgstr "0x0000031F\tHDIO_DRIVE_CMD\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:340
#, no-wrap
msgid "0x00000321\tHDIO_SET_MULTCOUNT\tint\n"
msgstr "0x00000321\tHDIO_SET_MULTCOUNT\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:341
#, no-wrap
msgid "0x00000322\tHDIO_SET_UNMASKINTR\tint\n"
msgstr "0x00000322\tHDIO_SET_UNMASKINTR\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:342
#, no-wrap
msgid "0x00000323\tHDIO_SET_KEEPSETTINGS\tint\n"
msgstr "0x00000323\tHDIO_SET_KEEPSETTINGS\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:343
#, no-wrap
msgid "0x00000324\tHDIO_SET_CHIPSET\tint\n"
msgstr "0x00000324\tHDIO_SET_CHIPSET\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:344
#, no-wrap
msgid "0x00000325\tHDIO_SET_NOWERR\tint\n"
msgstr "0x00000325\tHDIO_SET_NOWERR\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:345
#, no-wrap
msgid "0x00000326\tHDIO_SET_DMA\tint\n"
msgstr "0x00000326\tHDIO_SET_DMA\tint\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:349
msgid "// E<lt>include/linux/if_eql.hE<gt>"
msgstr "// E<lt>include/linux/if_eql.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:351
#, no-wrap
msgid "0x000089F0\tEQL_ENSLAVE\tstruct ifreq *\t// MORE // I-O\n"
msgstr "0x000089F0\tEQL_ENSLAVE\tstruct ifreq *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:352
#, no-wrap
msgid "0x000089F1\tEQL_EMANCIPATE\tstruct ifreq *\t// MORE // I-O\n"
msgstr "0x000089F1\tEQL_EMANCIPATE\tstruct ifreq *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:353
#, no-wrap
msgid "0x000089F2\tEQL_GETSLAVECFG\tstruct ifreq *\t// MORE // I-O\n"
msgstr "0x000089F2\tEQL_GETSLAVECFG\tstruct ifreq *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:354
#, no-wrap
msgid "0x000089F3\tEQL_SETSLAVECFG\tstruct ifreq *\t// MORE // I-O\n"
msgstr "0x000089F3\tEQL_SETSLAVECFG\tstruct ifreq *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:355
#, no-wrap
msgid "0x000089F4\tEQL_GETMASTRCFG\tstruct ifreq *\t// MORE // I-O\n"
msgstr "0x000089F4\tEQL_GETMASTRCFG\tstruct ifreq *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:356
#, no-wrap
msgid "0x000089F5\tEQL_SETMASTRCFG\tstruct ifreq *\t// MORE // I-O\n"
msgstr "0x000089F5\tEQL_SETMASTRCFG\tstruct ifreq *\t// MORE // I-O\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:360
msgid "// E<lt>include/linux/if_plip.hE<gt>"
msgstr "// E<lt>include/linux/if_plip.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:362
#, no-wrap
msgid "0x000089F0\tSIOCDEVPLIP\tstruct ifreq *\t// I-O\n"
msgstr "0x000089F0\tSIOCDEVPLIP\tstruct ifreq *\t// I-O\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:366
msgid "// E<lt>include/linux/if_ppp.hE<gt>"
msgstr "// E<lt>include/linux/if_ppp.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:368
#, no-wrap
msgid "0x00005490\tPPPIOCGFLAGS\tint *\n"
msgstr "0x00005490\tPPPIOCGFLAGS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:369
#, no-wrap
msgid "0x00005491\tPPPIOCSFLAGS\tconst int *\n"
msgstr "0x00005491\tPPPIOCSFLAGS\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:370
#, no-wrap
msgid "0x00005492\tPPPIOCGASYNCMAP\tint *\n"
msgstr "0x00005492\tPPPIOCGASYNCMAP\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:371
#, no-wrap
msgid "0x00005493\tPPPIOCSASYNCMAP\tconst int *\n"
msgstr "0x00005493\tPPPIOCSASYNCMAP\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:372
#, no-wrap
msgid "0x00005494\tPPPIOCGUNIT\tint *\n"
msgstr "0x00005494\tPPPIOCGUNIT\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:373
#, no-wrap
msgid "0x00005495\tPPPIOCSINPSIG\tconst int *\n"
msgstr "0x00005495\tPPPIOCSINPSIG\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:374
#, no-wrap
msgid "0x00005497\tPPPIOCSDEBUG\tconst int *\n"
msgstr "0x00005497\tPPPIOCSDEBUG\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:375
#, no-wrap
msgid "0x00005498\tPPPIOCGDEBUG\tint *\n"
msgstr "0x00005498\tPPPIOCGDEBUG\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:376
#, no-wrap
msgid "0x00005499\tPPPIOCGSTAT\tstruct ppp_stats *\n"
msgstr "0x00005499\tPPPIOCGSTAT\tstruct ppp_stats *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:377
#, no-wrap
msgid "0x0000549A\tPPPIOCGTIME\tstruct ppp_ddinfo *\n"
msgstr "0x0000549A\tPPPIOCGTIME\tstruct ppp_ddinfo *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:378
#, no-wrap
msgid "0x0000549B\tPPPIOCGXASYNCMAP\tstruct { int [8]; } *\n"
msgstr "0x0000549B\tPPPIOCGXASYNCMAP\tstruct { int [8]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:379
#, no-wrap
msgid "0x0000549C\tPPPIOCSXASYNCMAP\tconst struct { int [8]; } *\n"
msgstr "0x0000549C\tPPPIOCSXASYNCMAP\tconst struct { int [8]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:380
#, no-wrap
msgid "0x0000549D\tPPPIOCSMRU\tconst int *\n"
msgstr "0x0000549D\tPPPIOCSMRU\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:381
#, no-wrap
msgid "0x0000549E\tPPPIOCRASYNCMAP\tconst int *\n"
msgstr "0x0000549E\tPPPIOCRASYNCMAP\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:382
#, no-wrap
msgid "0x0000549F\tPPPIOCSMAXCID\tconst int *\n"
msgstr "0x0000549F\tPPPIOCSMAXCID\tconst int *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:386
msgid "// E<lt>include/linux/ipx.hE<gt>"
msgstr "// E<lt>include/linux/ipx.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:388
#, no-wrap
msgid "0x000089E0\tSIOCAIPXITFCRT\tconst char *\n"
msgstr "0x000089E0\tSIOCAIPXITFCRT\tconst char *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:389
#, no-wrap
msgid "0x000089E1\tSIOCAIPXPRISLT\tconst char *\n"
msgstr "0x000089E1\tSIOCAIPXPRISLT\tconst char *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:390
#, no-wrap
msgid "0x000089E2\tSIOCIPXCFGDATA\tstruct ipx_config_data *\n"
msgstr "0x000089E2\tSIOCIPXCFGDATA\tstruct ipx_config_data *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:394
msgid "// E<lt>include/linux/kd.hE<gt>"
msgstr "// E<lt>include/linux/kd.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:396
#, no-wrap
msgid "0x00004B60\tGIO_FONT\tstruct { char [8192]; } *\n"
msgstr "0x00004B60\tGIO_FONT\tstruct { char [8192]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:397
#, no-wrap
msgid "0x00004B61\tPIO_FONT\tconst struct { char [8192]; } *\n"
msgstr "0x00004B61\tPIO_FONT\tconst struct { char [8192]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:401
#, no-wrap
msgid "0x00004B6B\tGIO_FONTX\tstruct console_font_desc *\t// MORE // I-O\n"
msgstr "0x00004B6B\tGIO_FONTX\tstruct console_font_desc *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:402
#, no-wrap
msgid "0x00004B6C\tPIO_FONTX\tconst struct console_font_desc *\t//MORE\n"
msgstr "0x00004B6C\tPIO_FONTX\tconst struct console_font_desc *\t//MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:406
#, no-wrap
msgid "0x00004B70\tGIO_CMAP\tstruct { char [48]; } *\n"
msgstr "0x00004B70\tGIO_CMAP\tstruct { char [48]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:407
#, no-wrap
msgid "0x00004B71\tPIO_CMAP\tconst struct { char [48]; }\n"
msgstr "0x00004B71\tPIO_CMAP\tconst struct { char [48]; }\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:411
#, no-wrap
msgid "0x00004B2F\tKIOCSOUND\tint\n"
msgstr "0x00004B2F\tKIOCSOUND\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:412
#, no-wrap
msgid "0x00004B30\tKDMKTONE\tint\n"
msgstr "0x00004B30\tKDMKTONE\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:413
#, no-wrap
msgid "0x00004B31\tKDGETLED\tchar *\n"
msgstr "0x00004B31\tKDGETLED\tchar *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:414
#, no-wrap
msgid "0x00004B32\tKDSETLED\tint\n"
msgstr "0x00004B32\tKDSETLED\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:415
#, no-wrap
msgid "0x00004B33\tKDGKBTYPE\tchar *\n"
msgstr "0x00004B33\tKDGKBTYPE\tchar *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:416
#, no-wrap
msgid "0x00004B34\tKDADDIO\tint\t// MORE\n"
msgstr "0x00004B34\tKDADDIO\tint\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:417
#, no-wrap
msgid "0x00004B35\tKDDELIO\tint\t// MORE\n"
msgstr "0x00004B35\tKDDELIO\tint\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:418
#, no-wrap
msgid "0x00004B36\tKDENABIO\tvoid\t// MORE\n"
msgstr "0x00004B36\tKDENABIO\tvoid\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:419
#, no-wrap
msgid "0x00004B37\tKDDISABIO\tvoid\t// MORE\n"
msgstr "0x00004B37\tKDDISABIO\tvoid\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:420
#, no-wrap
msgid "0x00004B3A\tKDSETMODE\tint\n"
msgstr "0x00004B3A\tKDSETMODE\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:421
#, no-wrap
msgid "0x00004B3B\tKDGETMODE\tint *\n"
msgstr "0x00004B3B\tKDGETMODE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:422
#, no-wrap
msgid "0x00004B3C\tKDMAPDISP\tvoid\t// MORE\n"
msgstr "0x00004B3C\tKDMAPDISP\tvoid\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:423
#, no-wrap
msgid "0x00004B3D\tKDUNMAPDISP\tvoid\t// MORE\n"
msgstr "0x00004B3D\tKDUNMAPDISP\tvoid\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:424
#, no-wrap
msgid "0x00004B40\tGIO_SCRNMAP\tstruct { char [E_TABSZ]; } *\n"
msgstr "0x00004B40\tGIO_SCRNMAP\tstruct { char [E_TABSZ]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:428
#, no-wrap
msgid "0x00004B41\tPIO_SCRNMAP\tconst struct { char [E_TABSZ]; } *\n"
msgstr "0x00004B41\tPIO_SCRNMAP\tconst struct { char [E_TABSZ]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:429
#, no-wrap
msgid "0x00004B69\tGIO_UNISCRNMAP\tstruct { short [E_TABSZ]; } *\n"
msgstr "0x00004B69\tGIO_UNISCRNMAP\tstruct { short [E_TABSZ]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:430
#, no-wrap
msgid "0x00004B6A\tPIO_UNISCRNMAP\tconst struct { short [E_TABSZ]; } *\n"
msgstr "0x00004B6A\tPIO_UNISCRNMAP\tconst struct { short [E_TABSZ]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:434
#, no-wrap
msgid "0x00004B66\tGIO_UNIMAP\tstruct unimapdesc *\t// MORE // I-O\n"
msgstr "0x00004B66\tGIO_UNIMAP\tstruct unimapdesc *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:435
#, no-wrap
msgid "0x00004B67\tPIO_UNIMAP\tconst struct unimapdesc *\t// MORE\n"
msgstr "0x00004B67\tPIO_UNIMAP\tconst struct unimapdesc *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:436
#, no-wrap
msgid "0x00004B68\tPIO_UNIMAPCLR\tconst struct unimapinit *\n"
msgstr "0x00004B68\tPIO_UNIMAPCLR\tconst struct unimapinit *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:437
#, no-wrap
msgid "0x00004B44\tKDGKBMODE\tint *\n"
msgstr "0x00004B44\tKDGKBMODE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:438
#, no-wrap
msgid "0x00004B45\tKDSKBMODE\tint\n"
msgstr "0x00004B45\tKDSKBMODE\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:439
#, no-wrap
msgid "0x00004B62\tKDGKBMETA\tint *\n"
msgstr "0x00004B62\tKDGKBMETA\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:440
#, no-wrap
msgid "0x00004B63\tKDSKBMETA\tint\n"
msgstr "0x00004B63\tKDSKBMETA\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:441
#, no-wrap
msgid "0x00004B64\tKDGKBLED\tint *\n"
msgstr "0x00004B64\tKDGKBLED\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:442
#, no-wrap
msgid "0x00004B65\tKDSKBLED\tint\n"
msgstr "0x00004B65\tKDSKBLED\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:443
#, no-wrap
msgid "0x00004B46\tKDGKBENT\tstruct kbentry *\t// I-O\n"
msgstr "0x00004B46\tKDGKBENT\tstruct kbentry *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:444
#, no-wrap
msgid "0x00004B47\tKDSKBENT\tconst struct kbentry *\n"
msgstr "0x00004B47\tKDSKBENT\tconst struct kbentry *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:445
#, no-wrap
msgid "0x00004B48\tKDGKBSENT\tstruct kbsentry *\t// I-O\n"
msgstr "0x00004B48\tKDGKBSENT\tstruct kbsentry *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:446
#, no-wrap
msgid "0x00004B49\tKDSKBSENT\tconst struct kbsentry *\n"
msgstr "0x00004B49\tKDSKBSENT\tconst struct kbsentry *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:447
#, no-wrap
msgid "0x00004B4A\tKDGKBDIACR\tstruct kbdiacrs *\n"
msgstr "0x00004B4A\tKDGKBDIACR\tstruct kbdiacrs *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:448
#, no-wrap
msgid "0x00004B4B\tKDSKBDIACR\tconst struct kbdiacrs *\n"
msgstr "0x00004B4B\tKDSKBDIACR\tconst struct kbdiacrs *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:449
#, no-wrap
msgid "0x00004B4C\tKDGETKEYCODE\tstruct kbkeycode *\t// I-O\n"
msgstr "0x00004B4C\tKDGETKEYCODE\tstruct kbkeycode *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:450
#, no-wrap
msgid "0x00004B4D\tKDSETKEYCODE\tconst struct kbkeycode *\n"
msgstr "0x00004B4D\tKDSETKEYCODE\tconst struct kbkeycode *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:451
#, no-wrap
msgid "0x00004B4E\tKDSIGACCEPT\tint\n"
msgstr "0x00004B4E\tKDSIGACCEPT\tint\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:455
msgid "// E<lt>include/linux/lp.hE<gt>"
msgstr "// E<lt>include/linux/lp.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:457
#, no-wrap
msgid "0x00000601\tLPCHAR\tint\n"
msgstr "0x00000601\tLPCHAR\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:458
#, no-wrap
msgid "0x00000602\tLPTIME\tint\n"
msgstr "0x00000602\tLPTIME\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:459
#, no-wrap
msgid "0x00000604\tLPABORT\tint\n"
msgstr "0x00000604\tLPABORT\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:460
#, no-wrap
msgid "0x00000605\tLPSETIRQ\tint\n"
msgstr "0x00000605\tLPSETIRQ\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:461
#, no-wrap
msgid "0x00000606\tLPGETIRQ\tint *\n"
msgstr "0x00000606\tLPGETIRQ\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:462
#, no-wrap
msgid "0x00000608\tLPWAIT\tint\n"
msgstr "0x00000608\tLPWAIT\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:463
#, no-wrap
msgid "0x00000609\tLPCAREFUL\tint\n"
msgstr "0x00000609\tLPCAREFUL\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:464
#, no-wrap
msgid "0x0000060A\tLPABORTOPEN\tint\n"
msgstr "0x0000060A\tLPABORTOPEN\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:465
#, no-wrap
msgid "0x0000060B\tLPGETSTATUS\tint *\n"
msgstr "0x0000060B\tLPGETSTATUS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:466
#, no-wrap
msgid "0x0000060C\tLPRESET\tvoid\n"
msgstr "0x0000060C\tLPRESET\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:467
#, no-wrap
msgid "0x0000060D\tLPGETSTATS\tstruct lp_stats *\n"
msgstr "0x0000060D\tLPGETSTATS\tstruct lp_stats *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:471
msgid "// E<lt>include/linux/mroute.hE<gt>"
msgstr "// E<lt>include/linux/mroute.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:473
#, no-wrap
msgid "0x000089E0\tSIOCGETVIFCNT\tstruct sioc_vif_req *\t// I-O\n"
msgstr "0x000089E0\tSIOCGETVIFCNT\tstruct sioc_vif_req *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:474
#, no-wrap
msgid "0x000089E1\tSIOCGETSGCNT\tstruct sioc_sg_req *\t// I-O\n"
msgstr "0x000089E1\tSIOCGETSGCNT\tstruct sioc_sg_req *\t// I-O\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:478
msgid "// E<lt>include/linux/msdos_fs.hE<gt>"
msgstr "// E<lt>include/linux/msdos_fs.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:480
#, no-wrap
msgid "0x82307201\tVFAT_IOCTL_READDIR_BOTH\tstruct dirent [2]\n"
msgstr "0x82307201\tVFAT_IOCTL_READDIR_BOTH\tstruct dirent [2]\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:481
#, no-wrap
msgid "0x82307202\tVFAT_IOCTL_READDIR_SHORT\tstruct dirent [2]\n"
msgstr "0x82307202\tVFAT_IOCTL_READDIR_SHORT\tstruct dirent [2]\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:482
#, no-wrap
msgid "0x80047210\tFAT_IOCTL_GET_ATTRIBUTES\t__u32 *\n"
msgstr "0x80047210\tFAT_IOCTL_GET_ATTRIBUTES\t__u32 *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:483
#, no-wrap
msgid "0x40047211\tFAT_IOCTL_SET_ATTRIBUTES\tconst __u32 *\n"
msgstr "0x40047211\tFAT_IOCTL_SET_ATTRIBUTES\tconst __u32 *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:487
msgid "// E<lt>include/linux/mtio.hE<gt>"
msgstr "// E<lt>include/linux/mtio.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:489
#, no-wrap
msgid "0x40086D01\tMTIOCTOP\tconst struct mtop *\n"
msgstr "0x40086D01\tMTIOCTOP\tconst struct mtop *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:490
#, no-wrap
msgid "0x801C6D02\tMTIOCGET\tstruct mtget *\n"
msgstr "0x801C6D02\tMTIOCGET\tstruct mtget *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:491
#, no-wrap
msgid "0x80046D03\tMTIOCPOS\tstruct mtpos *\n"
msgstr "0x80046D03\tMTIOCPOS\tstruct mtpos *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:492
#, no-wrap
msgid "0x80206D04\tMTIOCGETCONFIG\tstruct mtconfiginfo *\n"
msgstr "0x80206D04\tMTIOCGETCONFIG\tstruct mtconfiginfo *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:493
#, no-wrap
msgid "0x40206D05\tMTIOCSETCONFIG\tconst struct mtconfiginfo *\n"
msgstr "0x40206D05\tMTIOCSETCONFIG\tconst struct mtconfiginfo *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:497
msgid "// E<lt>include/linux/netrom.hE<gt>"
msgstr "// E<lt>include/linux/netrom.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:499
#, no-wrap
msgid "0x000089E0\tSIOCNRGETPARMS\tstruct nr_parms_struct *\t// I-O\n"
msgstr "0x000089E0\tSIOCNRGETPARMS\tstruct nr_parms_struct *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:500
#, no-wrap
msgid "0x000089E1\tSIOCNRSETPARMS\tconst struct nr_parms_struct *\n"
msgstr "0x000089E1\tSIOCNRSETPARMS\tconst struct nr_parms_struct *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:501
#, no-wrap
msgid "0x000089E2\tSIOCNRDECOBS\tvoid\n"
msgstr "0x000089E2\tSIOCNRDECOBS\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:502
#, no-wrap
msgid "0x000089E3\tSIOCNRRTCTL\tconst int *\n"
msgstr "0x000089E3\tSIOCNRRTCTL\tconst int *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:506
msgid "// E<lt>include/linux/sbpcd.hE<gt>"
msgstr "// E<lt>include/linux/sbpcd.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:508
#, no-wrap
msgid "0x00009000\tDDIOCSDBG\tconst int *\n"
msgstr "0x00009000\tDDIOCSDBG\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:509
#, no-wrap
msgid "0x00005382\tCDROMAUDIOBUFSIZ\tint\n"
msgstr "0x00005382\tCDROMAUDIOBUFSIZ\tint\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:513
msgid "// E<lt>include/linux/scc.hE<gt>"
msgstr "// E<lt>include/linux/scc.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:515
#, no-wrap
msgid "0x00005470\tTIOCSCCINI\tvoid\n"
msgstr "0x00005470\tTIOCSCCINI\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:516
#, no-wrap
msgid "0x00005471\tTIOCCHANINI\tconst struct scc_modem *\n"
msgstr "0x00005471\tTIOCCHANINI\tconst struct scc_modem *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:517
#, no-wrap
msgid "0x00005472\tTIOCGKISS\tstruct ioctl_command *\t// I-O\n"
msgstr "0x00005472\tTIOCGKISS\tstruct ioctl_command *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:518
#, no-wrap
msgid "0x00005473\tTIOCSKISS\tconst struct ioctl_command *\n"
msgstr "0x00005473\tTIOCSKISS\tconst struct ioctl_command *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:519
#, no-wrap
msgid "0x00005474\tTIOCSCCSTAT\tstruct scc_stat *\n"
msgstr "0x00005474\tTIOCSCCSTAT\tstruct scc_stat *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:523
msgid "// E<lt>include/linux/scsi.hE<gt>"
msgstr "// E<lt>include/linux/scsi.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:525
#, no-wrap
msgid "0x00005382\tSCSI_IOCTL_GET_IDLUN\tstruct { int [2]; } *\n"
msgstr "0x00005382\tSCSI_IOCTL_GET_IDLUN\tstruct { int [2]; } *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:526
#, no-wrap
msgid "0x00005383\tSCSI_IOCTL_TAGGED_ENABLE\tvoid\n"
msgstr "0x00005383\tSCSI_IOCTL_TAGGED_ENABLE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:527
#, no-wrap
msgid "0x00005384\tSCSI_IOCTL_TAGGED_DISABLE\tvoid\n"
msgstr "0x00005384\tSCSI_IOCTL_TAGGED_DISABLE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:531
#, no-wrap
msgid "0x00005385\tSCSI_IOCTL_PROBE_HOST\tconst int *\t// MORE\n"
msgstr "0x00005385\tSCSI_IOCTL_PROBE_HOST\tconst int *\t// MORE\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:535
msgid "// E<lt>include/linux/smb_fs.hE<gt>"
msgstr "// E<lt>include/linux/smb_fs.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:537
#, no-wrap
msgid "0x80027501\tSMB_IOC_GETMOUNTUID\tuid_t *\n"
msgstr "0x80027501\tSMB_IOC_GETMOUNTUID\tuid_t *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:541
msgid "// E<lt>include/linux/sockios.hE<gt>"
msgstr "// E<lt>include/linux/sockios.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:543
#, no-wrap
msgid "0x0000890B\tSIOCADDRT\tconst struct rtentry *\t// MORE\n"
msgstr "0x0000890B\tSIOCADDRT\tconst struct rtentry *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:544
#, no-wrap
msgid "0x0000890C\tSIOCDELRT\tconst struct rtentry *\t// MORE\n"
msgstr "0x0000890C\tSIOCDELRT\tconst struct rtentry *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:545
#, no-wrap
msgid "0x00008910\tSIOCGIFNAME\tchar []\n"
msgstr "0x00008910\tSIOCGIFNAME\tchar []\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:546
#, no-wrap
msgid "0x00008911\tSIOCSIFLINK\tvoid\n"
msgstr "0x00008911\tSIOCSIFLINK\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:547
#, no-wrap
msgid "0x00008912\tSIOCGIFCONF\tstruct ifconf *\t// MORE // I-O\n"
msgstr "0x00008912\tSIOCGIFCONF\tstruct ifconf *\t// MORE // I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:548
#, no-wrap
msgid "0x00008913\tSIOCGIFFLAGS\tstruct ifreq *\t// I-O\n"
msgstr "0x00008913\tSIOCGIFFLAGS\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:549
#, no-wrap
msgid "0x00008914\tSIOCSIFFLAGS\tconst struct ifreq *\n"
msgstr "0x00008914\tSIOCSIFFLAGS\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:550
#, no-wrap
msgid "0x00008915\tSIOCGIFADDR\tstruct ifreq *\t// I-O\n"
msgstr "0x00008915\tSIOCGIFADDR\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:551
#, no-wrap
msgid "0x00008916\tSIOCSIFADDR\tconst struct ifreq *\n"
msgstr "0x00008916\tSIOCSIFADDR\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:552
#, no-wrap
msgid "0x00008917\tSIOCGIFDSTADDR\tstruct ifreq *\t// I-O\n"
msgstr "0x00008917\tSIOCGIFDSTADDR\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:553
#, no-wrap
msgid "0x00008918\tSIOCSIFDSTADDR\tconst struct ifreq *\n"
msgstr "0x00008918\tSIOCSIFDSTADDR\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:554
#, no-wrap
msgid "0x00008919\tSIOCGIFBRDADDR\tstruct ifreq *\t// I-O\n"
msgstr "0x00008919\tSIOCGIFBRDADDR\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:555
#, no-wrap
msgid "0x0000891A\tSIOCSIFBRDADDR\tconst struct ifreq *\n"
msgstr "0x0000891A\tSIOCSIFBRDADDR\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:556
#, no-wrap
msgid "0x0000891B\tSIOCGIFNETMASK\tstruct ifreq *\t// I-O\n"
msgstr "0x0000891B\tSIOCGIFNETMASK\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:557
#, no-wrap
msgid "0x0000891C\tSIOCSIFNETMASK\tconst struct ifreq *\n"
msgstr "0x0000891C\tSIOCSIFNETMASK\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:558
#, no-wrap
msgid "0x0000891D\tSIOCGIFMETRIC\tstruct ifreq *\t// I-O\n"
msgstr "0x0000891D\tSIOCGIFMETRIC\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:559
#, no-wrap
msgid "0x0000891E\tSIOCSIFMETRIC\tconst struct ifreq *\n"
msgstr "0x0000891E\tSIOCSIFMETRIC\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:560
#, no-wrap
msgid "0x0000891F\tSIOCGIFMEM\tstruct ifreq *\t// I-O\n"
msgstr "0x0000891F\tSIOCGIFMEM\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:561
#, no-wrap
msgid "0x00008920\tSIOCSIFMEM\tconst struct ifreq *\n"
msgstr "0x00008920\tSIOCSIFMEM\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:562
#, no-wrap
msgid "0x00008921\tSIOCGIFMTU\tstruct ifreq *\t// I-O\n"
msgstr "0x00008921\tSIOCGIFMTU\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:563
#, no-wrap
msgid "0x00008922\tSIOCSIFMTU\tconst struct ifreq *\n"
msgstr "0x00008922\tSIOCSIFMTU\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:567
#, no-wrap
msgid "0x00008923\tOLD_SIOCGIFHWADDR\tstruct ifreq *\t// I-O\n"
msgstr "0x00008923\tOLD_SIOCGIFHWADDR\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:568
#, no-wrap
msgid "0x00008924\tSIOCSIFHWADDR\tconst struct ifreq *\t// MORE\n"
msgstr "0x00008924\tSIOCSIFHWADDR\tconst struct ifreq *\t// MORE\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:569
#, no-wrap
msgid "0x00008925\tSIOCGIFENCAP\tint *\n"
msgstr "0x00008925\tSIOCGIFENCAP\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:570
#, no-wrap
msgid "0x00008926\tSIOCSIFENCAP\tconst int *\n"
msgstr "0x00008926\tSIOCSIFENCAP\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:571
#, no-wrap
msgid "0x00008927\tSIOCGIFHWADDR\tstruct ifreq *\t// I-O\n"
msgstr "0x00008927\tSIOCGIFHWADDR\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:572
#, no-wrap
msgid "0x00008929\tSIOCGIFSLAVE\tvoid\n"
msgstr "0x00008929\tSIOCGIFSLAVE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:573
#, no-wrap
msgid "0x00008930\tSIOCSIFSLAVE\tvoid\n"
msgstr "0x00008930\tSIOCSIFSLAVE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:574
#, no-wrap
msgid "0x00008931\tSIOCADDMULTI\tconst struct ifreq *\n"
msgstr "0x00008931\tSIOCADDMULTI\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:575
#, no-wrap
msgid "0x00008932\tSIOCDELMULTI\tconst struct ifreq *\n"
msgstr "0x00008932\tSIOCDELMULTI\tconst struct ifreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:576
#, no-wrap
msgid "0x00008940\tSIOCADDRTOLD\tvoid\n"
msgstr "0x00008940\tSIOCADDRTOLD\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:577
#, no-wrap
msgid "0x00008941\tSIOCDELRTOLD\tvoid\n"
msgstr "0x00008941\tSIOCDELRTOLD\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:578
#, no-wrap
msgid "0x00008950\tSIOCDARP\tconst struct arpreq *\n"
msgstr "0x00008950\tSIOCDARP\tconst struct arpreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:579
#, no-wrap
msgid "0x00008951\tSIOCGARP\tstruct arpreq *\t// I-O\n"
msgstr "0x00008951\tSIOCGARP\tstruct arpreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:580
#, no-wrap
msgid "0x00008952\tSIOCSARP\tconst struct arpreq *\n"
msgstr "0x00008952\tSIOCSARP\tconst struct arpreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:581
#, no-wrap
msgid "0x00008960\tSIOCDRARP\tconst struct arpreq *\n"
msgstr "0x00008960\tSIOCDRARP\tconst struct arpreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:582
#, no-wrap
msgid "0x00008961\tSIOCGRARP\tstruct arpreq *\t// I-O\n"
msgstr "0x00008961\tSIOCGRARP\tstruct arpreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:583
#, no-wrap
msgid "0x00008962\tSIOCSRARP\tconst struct arpreq *\n"
msgstr "0x00008962\tSIOCSRARP\tconst struct arpreq *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:584
#, no-wrap
msgid "0x00008970\tSIOCGIFMAP\tstruct ifreq *\t// I-O\n"
msgstr "0x00008970\tSIOCGIFMAP\tstruct ifreq *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:585
#, no-wrap
msgid "0x00008971\tSIOCSIFMAP\tconst struct ifreq *\n"
msgstr "0x00008971\tSIOCSIFMAP\tconst struct ifreq *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:589
msgid "// E<lt>include/linux/soundcard.hE<gt>"
msgstr "// E<lt>include/linux/soundcard.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:591
#, no-wrap
msgid "0x00005100\tSNDCTL_SEQ_RESET\tvoid\n"
msgstr "0x00005100\tSNDCTL_SEQ_RESET\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:592
#, no-wrap
msgid "0x00005101\tSNDCTL_SEQ_SYNC\tvoid\n"
msgstr "0x00005101\tSNDCTL_SEQ_SYNC\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:596
#, no-wrap
msgid "0xC08C5102\tSNDCTL_SYNTH_INFO\tstruct synth_info *\t// I-O\n"
msgstr "0xC08C5102\tSNDCTL_SYNTH_INFO\tstruct synth_info *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:597
#, no-wrap
msgid "0xC0045103\tSNDCTL_SEQ_CTRLRATE\tint *\t// I-O\n"
msgstr "0xC0045103\tSNDCTL_SEQ_CTRLRATE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:598
#, no-wrap
msgid "0x80045104\tSNDCTL_SEQ_GETOUTCOUNT\tint *\n"
msgstr "0x80045104\tSNDCTL_SEQ_GETOUTCOUNT\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:599
#, no-wrap
msgid "0x80045105\tSNDCTL_SEQ_GETINCOUNT\tint *\n"
msgstr "0x80045105\tSNDCTL_SEQ_GETINCOUNT\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:600
#, no-wrap
msgid "0x40045106\tSNDCTL_SEQ_PERCMODE\tvoid\n"
msgstr "0x40045106\tSNDCTL_SEQ_PERCMODE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:604
#, no-wrap
msgid "0x40285107\tSNDCTL_FM_LOAD_INSTR\tconst struct sbi_instrument *\n"
msgstr "0x40285107\tSNDCTL_FM_LOAD_INSTR\tconst struct sbi_instrument *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:608
#, no-wrap
msgid "0x40045108\tSNDCTL_SEQ_TESTMIDI\tconst int *\n"
msgstr "0x40045108\tSNDCTL_SEQ_TESTMIDI\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:609
#, no-wrap
msgid "0x40045109\tSNDCTL_SEQ_RESETSAMPLES\tconst int *\n"
msgstr "0x40045109\tSNDCTL_SEQ_RESETSAMPLES\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:610
#, no-wrap
msgid "0x8004510A\tSNDCTL_SEQ_NRSYNTHS\tint *\n"
msgstr "0x8004510A\tSNDCTL_SEQ_NRSYNTHS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:611
#, no-wrap
msgid "0x8004510B\tSNDCTL_SEQ_NRMIDIS\tint *\n"
msgstr "0x8004510B\tSNDCTL_SEQ_NRMIDIS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:612
#, no-wrap
msgid "0xC074510C\tSNDCTL_MIDI_INFO\tstruct midi_info *\t// I-O\n"
msgstr "0xC074510C\tSNDCTL_MIDI_INFO\tstruct midi_info *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:613
#, no-wrap
msgid "0x4004510D\tSNDCTL_SEQ_THRESHOLD\tconst int *\n"
msgstr "0x4004510D\tSNDCTL_SEQ_THRESHOLD\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:614
#, no-wrap
msgid "0xC004510E\tSNDCTL_SYNTH_MEMAVL\tint *\t// I-O\n"
msgstr "0xC004510E\tSNDCTL_SYNTH_MEMAVL\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:615
#, no-wrap
msgid "0x4004510F\tSNDCTL_FM_4OP_ENABLE\tconst int *\n"
msgstr "0x4004510F\tSNDCTL_FM_4OP_ENABLE\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:616
#, no-wrap
msgid "0xCFB85110\tSNDCTL_PMGR_ACCESS\tstruct patmgr_info *\t// I-O\n"
msgstr "0xCFB85110\tSNDCTL_PMGR_ACCESS\tstruct patmgr_info *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:617
#, no-wrap
msgid "0x00005111\tSNDCTL_SEQ_PANIC\tvoid\n"
msgstr "0x00005111\tSNDCTL_SEQ_PANIC\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:621
#, no-wrap
msgid "0x40085112\tSNDCTL_SEQ_OUTOFBAND\tconst struct seq_event_rec *\n"
msgstr "0x40085112\tSNDCTL_SEQ_OUTOFBAND\tconst struct seq_event_rec *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:625
#, no-wrap
msgid "0xC0045401\tSNDCTL_TMR_TIMEBASE\tint *\t// I-O\n"
msgstr "0xC0045401\tSNDCTL_TMR_TIMEBASE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:626
#, no-wrap
msgid "0x00005402\tSNDCTL_TMR_START\tvoid\n"
msgstr "0x00005402\tSNDCTL_TMR_START\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:627
#, no-wrap
msgid "0x00005403\tSNDCTL_TMR_STOP\tvoid\n"
msgstr "0x00005403\tSNDCTL_TMR_STOP\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:628
#, no-wrap
msgid "0x00005404\tSNDCTL_TMR_CONTINUE\tvoid\n"
msgstr "0x00005404\tSNDCTL_TMR_CONTINUE\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:629
#, no-wrap
msgid "0xC0045405\tSNDCTL_TMR_TEMPO\tint *\t// I-O\n"
msgstr "0xC0045405\tSNDCTL_TMR_TEMPO\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:630
#, no-wrap
msgid "0xC0045406\tSNDCTL_TMR_SOURCE\tint *\t// I-O\n"
msgstr "0xC0045406\tSNDCTL_TMR_SOURCE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:631
#, no-wrap
msgid "0x40045407\tSNDCTL_TMR_METRONOME\tconst int *\n"
msgstr "0x40045407\tSNDCTL_TMR_METRONOME\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:632
#, no-wrap
msgid "0x40045408\tSNDCTL_TMR_SELECT\tint *\t// I-O\n"
msgstr "0x40045408\tSNDCTL_TMR_SELECT\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:633
#, no-wrap
msgid "0xCFB85001\tSNDCTL_PMGR_IFACE\tstruct patmgr_info *\t// I-O\n"
msgstr "0xCFB85001\tSNDCTL_PMGR_IFACE\tstruct patmgr_info *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:634
#, no-wrap
msgid "0xC0046D00\tSNDCTL_MIDI_PRETIME\tint *\t// I-O\n"
msgstr "0xC0046D00\tSNDCTL_MIDI_PRETIME\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:635
#, no-wrap
msgid "0xC0046D01\tSNDCTL_MIDI_MPUMODE\tconst int *\n"
msgstr "0xC0046D01\tSNDCTL_MIDI_MPUMODE\tconst int *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:639
#, no-wrap
msgid "0xC0216D02\tSNDCTL_MIDI_MPUCMD\tstruct mpu_command_rec *\t// I-O\n"
msgstr "0xC0216D02\tSNDCTL_MIDI_MPUCMD\tstruct mpu_command_rec *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:643
#, no-wrap
msgid "0x00005000\tSNDCTL_DSP_RESET\tvoid\n"
msgstr "0x00005000\tSNDCTL_DSP_RESET\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:644
#, no-wrap
msgid "0x00005001\tSNDCTL_DSP_SYNC\tvoid\n"
msgstr "0x00005001\tSNDCTL_DSP_SYNC\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:645
#, no-wrap
msgid "0xC0045002\tSNDCTL_DSP_SPEED\tint *\t// I-O\n"
msgstr "0xC0045002\tSNDCTL_DSP_SPEED\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:646
#, no-wrap
msgid "0xC0045003\tSNDCTL_DSP_STEREO\tint *\t// I-O\n"
msgstr "0xC0045003\tSNDCTL_DSP_STEREO\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:647
#, no-wrap
msgid "0xC0045004\tSNDCTL_DSP_GETBLKSIZE\tint *\t// I-O\n"
msgstr "0xC0045004\tSNDCTL_DSP_GETBLKSIZE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:648
#, no-wrap
msgid "0xC0045006\tSOUND_PCM_WRITE_CHANNELS\tint *\t// I-O\n"
msgstr "0xC0045006\tSOUND_PCM_WRITE_CHANNELS\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:649
#, no-wrap
msgid "0xC0045007\tSOUND_PCM_WRITE_FILTER\tint *\t// I-O\n"
msgstr "0xC0045007\tSOUND_PCM_WRITE_FILTER\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:650
#, no-wrap
msgid "0x00005008\tSNDCTL_DSP_POST\tvoid\n"
msgstr "0x00005008\tSNDCTL_DSP_POST\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:651
#, no-wrap
msgid "0xC0045009\tSNDCTL_DSP_SUBDIVIDE\tint *\t// I-O\n"
msgstr "0xC0045009\tSNDCTL_DSP_SUBDIVIDE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:652
#, no-wrap
msgid "0xC004500A\tSNDCTL_DSP_SETFRAGMENT\tint *\t// I-O\n"
msgstr "0xC004500A\tSNDCTL_DSP_SETFRAGMENT\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:653
#, no-wrap
msgid "0x8004500B\tSNDCTL_DSP_GETFMTS\tint *\n"
msgstr "0x8004500B\tSNDCTL_DSP_GETFMTS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:654
#, no-wrap
msgid "0xC0045005\tSNDCTL_DSP_SETFMT\tint *\t// I-O\n"
msgstr "0xC0045005\tSNDCTL_DSP_SETFMT\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:658
#, no-wrap
msgid "0x800C500C\tSNDCTL_DSP_GETOSPACE\tstruct audio_buf_info *\n"
msgstr "0x800C500C\tSNDCTL_DSP_GETOSPACE\tstruct audio_buf_info *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:659
#, no-wrap
msgid "0x800C500D\tSNDCTL_DSP_GETISPACE\tstruct audio_buf_info *\n"
msgstr "0x800C500D\tSNDCTL_DSP_GETISPACE\tstruct audio_buf_info *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:660
#, no-wrap
msgid "0x0000500E\tSNDCTL_DSP_NONBLOCK\tvoid\n"
msgstr "0x0000500E\tSNDCTL_DSP_NONBLOCK\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:661
#, no-wrap
msgid "0x80045002\tSOUND_PCM_READ_RATE\tint *\n"
msgstr "0x80045002\tSOUND_PCM_READ_RATE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:662
#, no-wrap
msgid "0x80045006\tSOUND_PCM_READ_CHANNELS\tint *\n"
msgstr "0x80045006\tSOUND_PCM_READ_CHANNELS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:663
#, no-wrap
msgid "0x80045005\tSOUND_PCM_READ_BITS\tint *\n"
msgstr "0x80045005\tSOUND_PCM_READ_BITS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:664
#, no-wrap
msgid "0x80045007\tSOUND_PCM_READ_FILTER\tint *\n"
msgstr "0x80045007\tSOUND_PCM_READ_FILTER\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:665
#, no-wrap
msgid "0x00004300\tSNDCTL_COPR_RESET\tvoid\n"
msgstr "0x00004300\tSNDCTL_COPR_RESET\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:666
#, no-wrap
msgid "0xCFB04301\tSNDCTL_COPR_LOAD\tconst struct copr_buffer *\n"
msgstr "0xCFB04301\tSNDCTL_COPR_LOAD\tconst struct copr_buffer *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:670
#, no-wrap
msgid "0xC0144302\tSNDCTL_COPR_RDATA\tstruct copr_debug_buf *\t// I-O\n"
msgstr "0xC0144302\tSNDCTL_COPR_RDATA\tstruct copr_debug_buf *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:671
#, no-wrap
msgid "0xC0144303\tSNDCTL_COPR_RCODE\tstruct copr_debug_buf *\t// I-O\n"
msgstr "0xC0144303\tSNDCTL_COPR_RCODE\tstruct copr_debug_buf *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:675
#, no-wrap
msgid "0x40144304\tSNDCTL_COPR_WDATA\tconst struct copr_debug_buf *\n"
msgstr "0x40144304\tSNDCTL_COPR_WDATA\tconst struct copr_debug_buf *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:676
#, no-wrap
msgid "0x40144305\tSNDCTL_COPR_WCODE\tconst struct copr_debug_buf *\n"
msgstr "0x40144305\tSNDCTL_COPR_WCODE\tconst struct copr_debug_buf *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:680
#, no-wrap
msgid "0xC0144306\tSNDCTL_COPR_RUN\tstruct copr_debug_buf *\t// I-O\n"
msgstr "0xC0144306\tSNDCTL_COPR_RUN\tstruct copr_debug_buf *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:681
#, no-wrap
msgid "0xC0144307\tSNDCTL_COPR_HALT\tstruct copr_debug_buf *\t// I-O\n"
msgstr "0xC0144307\tSNDCTL_COPR_HALT\tstruct copr_debug_buf *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:685
#, no-wrap
msgid "0x4FA44308\tSNDCTL_COPR_SENDMSG\tconst struct copr_msg *\n"
msgstr "0x4FA44308\tSNDCTL_COPR_SENDMSG\tconst struct copr_msg *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:686
#, no-wrap
msgid "0x8FA44309\tSNDCTL_COPR_RCVMSG\tstruct copr_msg *\n"
msgstr "0x8FA44309\tSNDCTL_COPR_RCVMSG\tstruct copr_msg *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:687
#, no-wrap
msgid "0x80044D00\tSOUND_MIXER_READ_VOLUME\tint *\n"
msgstr "0x80044D00\tSOUND_MIXER_READ_VOLUME\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:688
#, no-wrap
msgid "0x80044D01\tSOUND_MIXER_READ_BASS\tint *\n"
msgstr "0x80044D01\tSOUND_MIXER_READ_BASS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:689
#, no-wrap
msgid "0x80044D02\tSOUND_MIXER_READ_TREBLE\tint *\n"
msgstr "0x80044D02\tSOUND_MIXER_READ_TREBLE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:690
#, no-wrap
msgid "0x80044D03\tSOUND_MIXER_READ_SYNTH\tint *\n"
msgstr "0x80044D03\tSOUND_MIXER_READ_SYNTH\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:691
#, no-wrap
msgid "0x80044D04\tSOUND_MIXER_READ_PCM\tint *\n"
msgstr "0x80044D04\tSOUND_MIXER_READ_PCM\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:692
#, no-wrap
msgid "0x80044D05\tSOUND_MIXER_READ_SPEAKER\tint *\n"
msgstr "0x80044D05\tSOUND_MIXER_READ_SPEAKER\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:693
#, no-wrap
msgid "0x80044D06\tSOUND_MIXER_READ_LINE\tint *\n"
msgstr "0x80044D06\tSOUND_MIXER_READ_LINE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:694
#, no-wrap
msgid "0x80044D07\tSOUND_MIXER_READ_MIC\tint *\n"
msgstr "0x80044D07\tSOUND_MIXER_READ_MIC\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:695
#, no-wrap
msgid "0x80044D08\tSOUND_MIXER_READ_CD\tint *\n"
msgstr "0x80044D08\tSOUND_MIXER_READ_CD\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:696
#, no-wrap
msgid "0x80044D09\tSOUND_MIXER_READ_IMIX\tint *\n"
msgstr "0x80044D09\tSOUND_MIXER_READ_IMIX\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:697
#, no-wrap
msgid "0x80044D0A\tSOUND_MIXER_READ_ALTPCM\tint *\n"
msgstr "0x80044D0A\tSOUND_MIXER_READ_ALTPCM\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:698
#, no-wrap
msgid "0x80044D0B\tSOUND_MIXER_READ_RECLEV\tint *\n"
msgstr "0x80044D0B\tSOUND_MIXER_READ_RECLEV\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:699
#, no-wrap
msgid "0x80044D0C\tSOUND_MIXER_READ_IGAIN\tint *\n"
msgstr "0x80044D0C\tSOUND_MIXER_READ_IGAIN\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:700
#, no-wrap
msgid "0x80044D0D\tSOUND_MIXER_READ_OGAIN\tint *\n"
msgstr "0x80044D0D\tSOUND_MIXER_READ_OGAIN\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:701
#, no-wrap
msgid "0x80044D0E\tSOUND_MIXER_READ_LINE1\tint *\n"
msgstr "0x80044D0E\tSOUND_MIXER_READ_LINE1\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:702
#, no-wrap
msgid "0x80044D0F\tSOUND_MIXER_READ_LINE2\tint *\n"
msgstr "0x80044D0F\tSOUND_MIXER_READ_LINE2\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:703
#, no-wrap
msgid "0x80044D10\tSOUND_MIXER_READ_LINE3\tint *\n"
msgstr "0x80044D10\tSOUND_MIXER_READ_LINE3\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:704
#, no-wrap
msgid "0x80044D1C\tSOUND_MIXER_READ_MUTE\tint *\n"
msgstr "0x80044D1C\tSOUND_MIXER_READ_MUTE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:705
#, no-wrap
msgid "0x80044D1D\tSOUND_MIXER_READ_ENHANCE\tint *\n"
msgstr "0x80044D1D\tSOUND_MIXER_READ_ENHANCE\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:706
#, no-wrap
msgid "0x80044D1E\tSOUND_MIXER_READ_LOUD\tint *\n"
msgstr "0x80044D1E\tSOUND_MIXER_READ_LOUD\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:707
#, no-wrap
msgid "0x80044DFF\tSOUND_MIXER_READ_RECSRC\tint *\n"
msgstr "0x80044DFF\tSOUND_MIXER_READ_RECSRC\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:708
#, no-wrap
msgid "0x80044DFE\tSOUND_MIXER_READ_DEVMASK\tint *\n"
msgstr "0x80044DFE\tSOUND_MIXER_READ_DEVMASK\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:709
#, no-wrap
msgid "0x80044DFD\tSOUND_MIXER_READ_RECMASK\tint *\n"
msgstr "0x80044DFD\tSOUND_MIXER_READ_RECMASK\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:710
#, no-wrap
msgid "0x80044DFB\tSOUND_MIXER_READ_STEREODEVS\tint *\n"
msgstr "0x80044DFB\tSOUND_MIXER_READ_STEREODEVS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:711
#, no-wrap
msgid "0x80044DFC\tSOUND_MIXER_READ_CAPS\tint *\n"
msgstr "0x80044DFC\tSOUND_MIXER_READ_CAPS\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:715
#, no-wrap
msgid "0xC0044D00\tSOUND_MIXER_WRITE_VOLUME\tint *\t// I-O\n"
msgstr "0xC0044D00\tSOUND_MIXER_WRITE_VOLUME\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:716
#, no-wrap
msgid "0xC0044D01\tSOUND_MIXER_WRITE_BASS\tint *\t// I-O\n"
msgstr "0xC0044D01\tSOUND_MIXER_WRITE_BASS\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:717
#, no-wrap
msgid "0xC0044D02\tSOUND_MIXER_WRITE_TREBLE\tint *\t// I-O\n"
msgstr "0xC0044D02\tSOUND_MIXER_WRITE_TREBLE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:718
#, no-wrap
msgid "0xC0044D03\tSOUND_MIXER_WRITE_SYNTH\tint *\t// I-O\n"
msgstr "0xC0044D03\tSOUND_MIXER_WRITE_SYNTH\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:719
#, no-wrap
msgid "0xC0044D04\tSOUND_MIXER_WRITE_PCM\tint *\t// I-O\n"
msgstr "0xC0044D04\tSOUND_MIXER_WRITE_PCM\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:720
#, no-wrap
msgid "0xC0044D05\tSOUND_MIXER_WRITE_SPEAKER\tint *\t// I-O\n"
msgstr "0xC0044D05\tSOUND_MIXER_WRITE_SPEAKER\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:721
#, no-wrap
msgid "0xC0044D06\tSOUND_MIXER_WRITE_LINE\tint *\t// I-O\n"
msgstr "0xC0044D06\tSOUND_MIXER_WRITE_LINE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:722
#, no-wrap
msgid "0xC0044D07\tSOUND_MIXER_WRITE_MIC\tint *\t// I-O\n"
msgstr "0xC0044D07\tSOUND_MIXER_WRITE_MIC\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:723
#, no-wrap
msgid "0xC0044D08\tSOUND_MIXER_WRITE_CD\tint *\t// I-O\n"
msgstr "0xC0044D08\tSOUND_MIXER_WRITE_CD\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:724
#, no-wrap
msgid "0xC0044D09\tSOUND_MIXER_WRITE_IMIX\tint *\t// I-O\n"
msgstr "0xC0044D09\tSOUND_MIXER_WRITE_IMIX\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:725
#, no-wrap
msgid "0xC0044D0A\tSOUND_MIXER_WRITE_ALTPCM\tint *\t// I-O\n"
msgstr "0xC0044D0A\tSOUND_MIXER_WRITE_ALTPCM\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:726
#, no-wrap
msgid "0xC0044D0B\tSOUND_MIXER_WRITE_RECLEV\tint *\t// I-O\n"
msgstr "0xC0044D0B\tSOUND_MIXER_WRITE_RECLEV\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:727
#, no-wrap
msgid "0xC0044D0C\tSOUND_MIXER_WRITE_IGAIN\tint *\t// I-O\n"
msgstr "0xC0044D0C\tSOUND_MIXER_WRITE_IGAIN\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:728
#, no-wrap
msgid "0xC0044D0D\tSOUND_MIXER_WRITE_OGAIN\tint *\t// I-O\n"
msgstr "0xC0044D0D\tSOUND_MIXER_WRITE_OGAIN\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:729
#, no-wrap
msgid "0xC0044D0E\tSOUND_MIXER_WRITE_LINE1\tint *\t// I-O\n"
msgstr "0xC0044D0E\tSOUND_MIXER_WRITE_LINE1\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:730
#, no-wrap
msgid "0xC0044D0F\tSOUND_MIXER_WRITE_LINE2\tint *\t// I-O\n"
msgstr "0xC0044D0F\tSOUND_MIXER_WRITE_LINE2\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:731
#, no-wrap
msgid "0xC0044D10\tSOUND_MIXER_WRITE_LINE3\tint *\t// I-O\n"
msgstr "0xC0044D10\tSOUND_MIXER_WRITE_LINE3\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:732
#, no-wrap
msgid "0xC0044D1C\tSOUND_MIXER_WRITE_MUTE\tint *\t// I-O\n"
msgstr "0xC0044D1C\tSOUND_MIXER_WRITE_MUTE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:733
#, no-wrap
msgid "0xC0044D1D\tSOUND_MIXER_WRITE_ENHANCE\tint *\t// I-O\n"
msgstr "0xC0044D1D\tSOUND_MIXER_WRITE_ENHANCE\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:734
#, no-wrap
msgid "0xC0044D1E\tSOUND_MIXER_WRITE_LOUD\tint *\t// I-O\n"
msgstr "0xC0044D1E\tSOUND_MIXER_WRITE_LOUD\tint *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:735
#, no-wrap
msgid "0xC0044DFF\tSOUND_MIXER_WRITE_RECSRC\tint *\t// I-O\n"
msgstr "0xC0044DFF\tSOUND_MIXER_WRITE_RECSRC\tint *\t// I-O\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:739
msgid "// E<lt>include/linux/umsdos_fs.hE<gt>"
msgstr "// E<lt>include/linux/umsdos_fs.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:741
#, no-wrap
msgid "0x000004D2\tUMSDOS_READDIR_DOS\tstruct umsdos_ioctl *\t// I-O\n"
msgstr "0x000004D2\tUMSDOS_READDIR_DOS\tstruct umsdos_ioctl *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:742
#, no-wrap
msgid "0x000004D3\tUMSDOS_UNLINK_DOS\tconst struct umsdos_ioctl *\n"
msgstr "0x000004D3\tUMSDOS_UNLINK_DOS\tconst struct umsdos_ioctl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:743
#, no-wrap
msgid "0x000004D4\tUMSDOS_RMDIR_DOS\tconst struct umsdos_ioctl *\n"
msgstr "0x000004D4\tUMSDOS_RMDIR_DOS\tconst struct umsdos_ioctl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:744
#, no-wrap
msgid "0x000004D5\tUMSDOS_STAT_DOS\tstruct umsdos_ioctl *\t// I-O\n"
msgstr "0x000004D5\tUMSDOS_STAT_DOS\tstruct umsdos_ioctl *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:745
#, no-wrap
msgid "0x000004D6\tUMSDOS_CREAT_EMD\tconst struct umsdos_ioctl *\n"
msgstr "0x000004D6\tUMSDOS_CREAT_EMD\tconst struct umsdos_ioctl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:746
#, no-wrap
msgid "0x000004D7\tUMSDOS_UNLINK_EMD\tconst struct umsdos_ioctl *\n"
msgstr "0x000004D7\tUMSDOS_UNLINK_EMD\tconst struct umsdos_ioctl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:747
#, no-wrap
msgid "0x000004D8\tUMSDOS_READDIR_EMD\tstruct umsdos_ioctl *\t// I-O\n"
msgstr "0x000004D8\tUMSDOS_READDIR_EMD\tstruct umsdos_ioctl *\t// I-O\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:748
#, no-wrap
msgid "0x000004D9\tUMSDOS_GETVERSION\tstruct umsdos_ioctl *\n"
msgstr "0x000004D9\tUMSDOS_GETVERSION\tstruct umsdos_ioctl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:749
#, no-wrap
msgid "0x000004DA\tUMSDOS_INIT_EMD\tvoid\n"
msgstr "0x000004DA\tUMSDOS_INIT_EMD\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:750
#, no-wrap
msgid "0x000004DB\tUMSDOS_DOS_SETUP\tconst struct umsdos_ioctl *\n"
msgstr "0x000004DB\tUMSDOS_DOS_SETUP\tconst struct umsdos_ioctl *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:751
#, no-wrap
msgid "0x000004DC\tUMSDOS_RENAME_DOS\tconst struct umsdos_ioctl *\n"
msgstr "0x000004DC\tUMSDOS_RENAME_DOS\tconst struct umsdos_ioctl *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:755
msgid "// E<lt>include/linux/vt.hE<gt>"
msgstr "// E<lt>include/linux/vt.hE<gt>"

#. type: tbl table
#: build/C/man2/ioctl_list.2:757
#, no-wrap
msgid "0x00005600\tVT_OPENQRY\tint *\n"
msgstr "0x00005600\tVT_OPENQRY\tint *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:758
#, no-wrap
msgid "0x00005601\tVT_GETMODE\tstruct vt_mode *\n"
msgstr "0x00005601\tVT_GETMODE\tstruct vt_mode *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:759
#, no-wrap
msgid "0x00005602\tVT_SETMODE\tconst struct vt_mode *\n"
msgstr "0x00005602\tVT_SETMODE\tconst struct vt_mode *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:760
#, no-wrap
msgid "0x00005603\tVT_GETSTATE\tstruct vt_stat *\n"
msgstr "0x00005603\tVT_GETSTATE\tstruct vt_stat *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:761
#, no-wrap
msgid "0x00005604\tVT_SENDSIG\tvoid\n"
msgstr "0x00005604\tVT_SENDSIG\tvoid\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:762
#, no-wrap
msgid "0x00005605\tVT_RELDISP\tint\n"
msgstr "0x00005605\tVT_RELDISP\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:763
#, no-wrap
msgid "0x00005606\tVT_ACTIVATE\tint\n"
msgstr "0x00005606\tVT_ACTIVATE\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:764
#, no-wrap
msgid "0x00005607\tVT_WAITACTIVE\tint\n"
msgstr "0x00005607\tVT_WAITACTIVE\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:765
#, no-wrap
msgid "0x00005608\tVT_DISALLOCATE\tint\n"
msgstr "0x00005608\tVT_DISALLOCATE\tint\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:766
#, no-wrap
msgid "0x00005609\tVT_RESIZE\tconst struct vt_sizes *\n"
msgstr "0x00005609\tVT_RESIZE\tconst struct vt_sizes *\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:767
#, no-wrap
msgid "0x0000560A\tVT_RESIZEX\tconst struct vt_consize *\n"
msgstr "0x0000560A\tVT_RESIZEX\tconst struct vt_consize *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:774
msgid ""
"// More arguments.  Some ioctl's take a pointer to a structure which "
"contains additional pointers.  These are documented here in alphabetical "
"order."
msgstr ""
"// More arguments.  いくつかの ioctl は追加のポインタを含む構造体へのポインタ"
"を使用します。 ここでこれらをアルファベット順に説明します。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:782
msgid ""
"B<CDROMREADAUDIO> takes an input pointer I<const struct cdrom_read_audio\\ "
"*>.  The I<buf> field points to an output buffer of length I<nframes\\ * "
"CD_FRAMESIZE_RAW>."
msgstr ""
"B<CDROMREADAUDIO> は入力ポインタ I<const struct cdrom_read_audio\\ *> を使用"
"します。 I<buf> フィールドは大きさ I<nframes\\ * CD_FRAMESIZE_RAW> の出力バッ"
"ファへのポインタです。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:798
msgid ""
"B<CDROMREADCOOKED>, B<CDROMREADMODE1>, B<CDROMREADMODE2>, and "
"B<CDROMREADRAW> take an input pointer I<const struct cdrom_msf\\ *>.  They "
"use the same pointer as an output pointer to I<char []>.  The length varies "
"by request.  For B<CDROMREADMODE1>, most drivers use CD_FRAMESIZE, but the "
"Optics Storage driver uses OPT_BLOCKSIZE instead (both have the numerical "
"value 2048)."
msgstr ""
"B<CDROMREADCOOKED>, B<CDROMREADMODE1>, B<CDROMREADMODE2>, B<CDROMREADRAW> は"
"入力ポインタ I<const struct cdrom_msf\\ *> を使用します。これらは同じポインタ"
"を I<char []> への出力ポインタとして使用します。 長さは要求によって変化しま"
"す。 B<CDROMREADMODE1> には、多くのデバイスが CD_FRAMESIZE を使用しますが、光"
"学記憶装置 (光ディスク) のドライバは OPT_BLOCKSIZE を使用します (どちらも同じ"
"値で 2048 です)。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:804
#, no-wrap
msgid ""
"    CDROMREADCOOKED    char [CD_FRAMESIZE]\n"
"    CDROMREADMODE1     char [CD_FRAMESIZE or OPT_BLOCKSIZE]\n"
"    CDROMREADMODE2     char [CD_FRAMESIZE_RAW0]\n"
"    CDROMREADRAW       char [CD_FRAMESIZE_RAW]\n"
msgstr ""
"    CDROMREADCOOKED    char [CD_FRAMESIZE]\n"
"    CDROMREADMODE1     char [CD_FRAMESIZE or OPT_BLOCKSIZE]\n"
"    CDROMREADMODE2     char [CD_FRAMESIZE_RAW0]\n"
"    CDROMREADRAW       char [CD_FRAMESIZE_RAW]\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:818
msgid ""
"B<EQL_ENSLAVE>, B<EQL_EMANCIPATE>, B<EQL_GETSLAVECFG>, B<EQL_SETSLAVECFG>, "
"B<EQL_GETMASTERCFG>, and B<EQL_SETMASTERCFG> take a I<struct ifreq\\ *>.  "
"The I<ifr_data> field is a pointer to another structure as follows:"
msgstr ""
"B<EQL_ENSLAVE>, B<EQL_EMANCIPATE>, B<EQL_GETSLAVECFG>, B<EQL_SETSLAVECFG>, "
"B<EQL_GETMASTERCFG>, B<EQL_SETMASTERCFG> は I<struct ifreq\\ *> を使用しま"
"す。 I<ifr_data> フィールドは以下に示す別の構造体へのポインタです:"

#. type: Plain text
#: build/C/man2/ioctl_list.2:826
#, no-wrap
msgid ""
"    EQL_ENSLAVE         const struct slaving_request *\n"
"    EQL_EMANCIPATE      const struct slaving_request *\n"
"    EQL_GETSLAVECFG     struct slave_config *           // I-O\n"
"    EQL_SETSLAVECFG     const struct slave_config *\n"
"    EQL_GETMASTERCFG    struct master_config *\n"
"    EQL_SETMASTERCFG    const struct master_config *\n"
msgstr ""
"    EQL_ENSLAVE         const struct slaving_request *\n"
"    EQL_EMANCIPATE      const struct slaving_request *\n"
"    EQL_GETSLAVECFG     struct slave_config *           // I-O\n"
"    EQL_SETSLAVECFG     const struct slave_config *\n"
"    EQL_GETMASTERCFG    struct master_config *\n"
"    EQL_SETMASTERCFG    const struct master_config *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:843
msgid ""
"B<FDRAWCMD> takes a I<struct floppy raw_cmd\\ *>.  If I<flags & "
"FD_RAW_WRITE> is nonzero, then I<data> points to an input buffer of length "
"I<length>.  If I<flags & FD_RAW_READ> is nonzero, then I<data> points to an "
"output buffer of length I<length>."
msgstr ""
"B<FDRAWCMD> は I<struct floppy raw_cmd\\ *> を使用します。 I<flags & "
"FD_RAW_WRITE> がゼロ以外の場合、 I<data> は大きさ I<length> の入力バッファへ"
"のポインタになります。 I<flags & FD_RAW_READ> がゼロ以外の場合、 I<data> は大"
"きさ I<length> の出力バッファへのポインタになります。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:859
msgid ""
"B<GIO_FONTX> and B<PIO_FONTX> take a I<struct console_font_desc\\ *> or a "
"I<const struct console_font_desc\\ *>, respectively.  I<chardata> points to "
"a buffer of I<char [charcount]>.  This is an output buffer for B<GIO_FONTX> "
"and an input buffer for B<PIO_FONTX>."
msgstr ""
"B<GIO_FONTX>, B<PIO_FONTX> はそれぞれ I<struct console_font_desc\\ *> と "
"I<const struct console_font_desc\\ *> を使用します。 I<chardata> は I<char "
"[charcount]> バッファへのポインタです。 これは B<GIO_FONTX> の出力バッファと "
"B<PIO_FONTX> の入力バッファです。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:875
msgid ""
"B<GIO_UNIMAP> and B<PIO_UNIMAP> take a I<struct unimapdesc\\ *> or a I<const "
"struct unimapdesc\\ *>, respectively.  I<entries> points to a buffer of "
"I<struct unipair [entry_ct]>.  This is an output buffer for B<GIO_UNIMAP> "
"and an input buffer for B<PIO_UNIMAP>."
msgstr ""
"B<GIO_UNIMAP>, B<PIO_UNIMAP> はそれぞれ I<struct unimapdesc\\ *> と I<const "
"struct unimapdesc\\ *> を使用します。 I<entries> は I<struct unipair "
"[entry_ct]> バッファへのポインタです。 これは B<GIO_UNIMAP> の出力バッファと "
"B<PIO_UNIMAP> の入力バッファです。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:879
msgid ""
"KDADDIO, KDDELIO, KDDISABIO, and KDENABIO enable or disable access to I/O "
"ports.  They are essentially alternate interfaces to 'ioperm'."
msgstr ""
"KDADDIO, KDDELIO, KDDISABIO, KDENABIO は I/O ポートへのアクセスを 可能/不可能"
"にします。これらは本質的に、'ioperm' への別の インターフェースです。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:885
msgid ""
"B<KDMAPDISP> and B<KDUNMAPDISP> enable or disable memory mappings or I/O "
"port access.  They are not implemented in the kernel."
msgstr ""
"B<KDMAPDISP>, B<KDUNMAPDISP> はメモリマッピングや I/O ポートへのアクセスを可"
"能/不可能にします。 これらはカーネルに実装されていません。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:893
msgid ""
"B<SCSI_IOCTL_PROBE_HOST> takes an input pointer I<const int\\ *>, which is a "
"length.  It uses the same pointer as an output pointer to a I<char []> "
"buffer of this length."
msgstr ""
"B<SCSI_IOCTL_PROBE_HOST> は入力ポインタ I<const int\\ *> を大きさとして使用し"
"ます。これは同じ大きさの I<char []> バッファ への出力ポインタとしても使用しま"
"す。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:899
msgid ""
"B<SIOCADDRT> and B<SIOCDELRT> take an input pointer whose type depends on "
"the protocol:"
msgstr ""
"B<SIOCADDRT>, B<SIOCDELRT> は型が以下のプロトコルに依存する入力ポインタを使用"
"します:"

#. type: Plain text
#: build/C/man2/ioctl_list.2:904
#, no-wrap
msgid ""
"    Most protocols      const struct rtentry *\n"
"    AX.25               const struct ax25_route *\n"
"    NET/ROM             const struct nr_route_struct *\n"
msgstr ""
"    Most protocols      const struct rtentry *\n"
"    AX.25               const struct ax25_route *\n"
"    NET/ROM             const struct nr_route_struct *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:915
msgid ""
"B<SIOCGIFCONF> takes a I<struct ifconf\\ *>.  The I<ifc_buf> field points to "
"a buffer of length I<ifc_len> bytes, into which the kernel writes a list of "
"type I<struct ifreq []>."
msgstr ""
"B<SIOCGIFCONF> は I<struct ifconf\\ *> を使用します。この I<ifc_buf> フィール"
"ドは長さ I<ifc_len> バイトのバッファへのポインタです。 これにカーネルが "
"I<struct ifreq []> 型のリストへ書き込みます。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:918
msgid ""
"B<SIOCSIFHWADDR> takes an input pointer whose type depends on the protocol:"
msgstr ""
"B<SIOCSIFHWADDR> は型が以下のプロトコルに依存する入力ポインタを使用します:"

#. type: Plain text
#: build/C/man2/ioctl_list.2:922
#, no-wrap
msgid ""
"    Most protocols      const struct ifreq *\n"
"    AX.25               const char [AX25_ADDR_LEN]\n"
msgstr ""
"    Most protocols      const struct ifreq *\n"
"    AX.25               const char [AX25_ADDR_LEN]\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:937
msgid ""
"B<TIOCLINUX> takes a I<const char\\ *>.  It uses this to distinguish several "
"independent subcases.  In the table below, I<N + foo> means I<foo> after an "
"N-byte pad.  I<struct selection> is implicitly defined in I<drivers/char/"
"selection.c>"
msgstr ""
"B<TIOCLINUX> は I<const char\\ *> を使用します。このポインタをいくつかの 独立"
"したサブクラスを識別する為に使用します。以下のテーブルの中で、 I<N + foo> は "
"N バイトの詰めものの後にある I<foo> を意味します。 I<struct selection> は暗黙"
"的に I<drivers/char/selection.c> の中で定義されています。"

#. type: Plain text
#: build/C/man2/ioctl_list.2:946
#, no-wrap
msgid ""
"    TIOCLINUX-2         1 + const struct selection *\n"
"    TIOCLINUX-3         void\n"
"    TIOCLINUX-4         void\n"
"    TIOCLINUX-5         4 + const struct { long [8]; } *\n"
"    TIOCLINUX-6         char *\n"
"    TIOCLINUX-7         char *\n"
"    TIOCLINUX-10        1 + const char *\n"
msgstr ""
"    TIOCLINUX-2         1 + const struct selection *\n"
"    TIOCLINUX-3         void\n"
"    TIOCLINUX-4         void\n"
"    TIOCLINUX-5         4 + const struct { long [8]; } *\n"
"    TIOCLINUX-6         char *\n"
"    TIOCLINUX-7         char *\n"
"    TIOCLINUX-10        1 + const char *\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:949
msgid "// Duplicate ioctls"
msgstr "// Duplicate ioctls"

#. type: Plain text
#: build/C/man2/ioctl_list.2:954
msgid ""
"This list does not include ioctls in the range B<SIOCDEVPRIVATE> and "
"B<SIOCPROTOPRIVATE>."
msgstr ""
"このリストは B<SIOCDEVPRIVATE> から B<SIOCPROTOPRIVATE> の範囲の ioctl を含ん"
"でいません。"

#. type: tbl table
#: build/C/man2/ioctl_list.2:956
#, no-wrap
msgid "0x00000001\tFDSETPRM\tFIBMAP\n"
msgstr "0x00000001\tFDSETPRM\tFIBMAP\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:957
#, no-wrap
msgid "0x00000002\tFDDEFPRM\tFIGETBSZ\n"
msgstr "0x00000002\tFDDEFPRM\tFIGETBSZ\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:958
#, no-wrap
msgid "0x00005382\tCDROMAUDIOBUFSIZ\tSCSI_IOCTL_GET_IDLUN\n"
msgstr "0x00005382\tCDROMAUDIOBUFSIZ\tSCSI_IOCTL_GET_IDLUN\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:959
#, no-wrap
msgid "0x00005402\tSNDCTL_TMR_START\tTCSETS\n"
msgstr "0x00005402\tSNDCTL_TMR_START\tTCSETS\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:960
#, no-wrap
msgid "0x00005403\tSNDCTL_TMR_STOP\tTCSETSW\n"
msgstr "0x00005403\tSNDCTL_TMR_STOP\tTCSETSW\n"

#. type: tbl table
#: build/C/man2/ioctl_list.2:961
#, no-wrap
msgid "0x00005404\tSNDCTL_TMR_CONTINUE\tTCSETSF\n"
msgstr "0x00005404\tSNDCTL_TMR_CONTINUE\tTCSETSF\n"

#. type: Plain text
#: build/C/man2/ioctl_list.2:965
msgid "B<ioctl>(2)"
msgstr "B<ioctl>(2)"

#. type: TH
#: build/C/man2/ioperm.2:34
#, no-wrap
msgid "IOPERM"
msgstr "IOPERM"

#. type: Plain text
#: build/C/man2/ioperm.2:37
msgid "ioperm - set port input/output permissions"
msgstr "ioperm - ポートの入出力許可を設定する"

#. type: Plain text
#: build/C/man2/ioperm.2:40
msgid "B<#include E<lt>unistd.hE<gt>> /* for libc5 */"
msgstr "B<#include E<lt>unistd.hE<gt>> /* for libc5 */"

#. type: Plain text
#: build/C/man2/ioperm.2:43
msgid "B<#include E<lt>sys/io.hE<gt>> /* for glibc */"
msgstr "B<#include E<lt>sys/io.hE<gt>> /* for glibc */"

#. type: Plain text
#: build/C/man2/ioperm.2:45
msgid ""
"B<int ioperm(unsigned long >I<from>B<, unsigned long >I<num>B<, int "
">I<turn_on>B<);>"
msgstr ""
"B<int ioperm(unsigned long >I<from>B<, unsigned long >I<num>B<, int "
">I<turn_on>B<);>"

#. type: Plain text
#: build/C/man2/ioperm.2:59
msgid ""
"B<ioperm>()  sets the port access permission bits for the calling thread for "
"I<num> bits starting from port address I<from>.  If I<turn_on> is nonzero, "
"then permission for the specified bits is enabled; otherwise it is "
"disabled.  If I<turn_on> is nonzero, the calling thread must be privileged "
"(B<CAP_SYS_RAWIO>)."
msgstr ""
"B<ioperm>()  は、引き数 I<from> の I/O ポートアドレスから I<num> ビット分の領"
"域に対する、呼び出し元スレッドのアクセス許可ビットを設定する。 I<turn_on> が "
"0 以外の場合、指定されたビットに対応する許可が有効になる。 I<turn_on> が 0 以"
"外の場合、呼び出し元プロセスは特権 (B<CAP_SYS_RAWIO>)  を持っていなければなら"
"ない。"

#. type: Plain text
#: build/C/man2/ioperm.2:68
msgid ""
"Before Linux 2.6.8, only the first 0x3ff I/O ports could be specified in "
"this manner.  For more ports, the B<iopl>(2)  system call had to be used "
"(with a I<level> argument of 3).  Since Linux 2.6.8, 65,536 I/O ports can be "
"specified."
msgstr ""
"Linux 2.6.8 より前のバージョンでは、この方法で設定できるのは 0x3ff 番地まで"
"の I/Oポートに限られていた。これよりも大きなアドレスのポートに対しては "
"B<iopl>(2) 関数を使わなければならなかった。Linux 2.6.8 以降では、65,536 個の "
"I/O ポートを指定できる。"

#. type: Plain text
#: build/C/man2/ioperm.2:78
msgid ""
"Permissions are not inherited by the child created by B<fork>(2); following "
"a B<fork>(2)  the child must turn on those permissions that it needs.  "
"Permissions are preserved across B<execve>(2); this is useful for giving "
"port access permissions to unprivileged programs."
msgstr ""
"アクセス権は B<fork>(2)  で作成された子プロセスには継承されない。子プロセスで"
"は、B<fork>(2) の後で必要なアクセス権を有効にしなければならない。 B<execve>"
"(2)  の前後でアクセス権は保存される。この機能は 非特権プログラムにポートへの"
"アクセス権を 与えるのに使用できる。"

#. type: Plain text
#: build/C/man2/ioperm.2:82
msgid ""
"This call is mostly for the i386 architecture.  On many other architectures "
"it does not exist or will always return an error."
msgstr ""
"このシステムコールはほとんど i386 アーキテクチャのためだけのものである。 その"
"他の多くのアーキテクチャでは存在しないか、常にエラーを返す。"

#. type: Plain text
#: build/C/man2/ioperm.2:94
msgid "Invalid values for I<from> or I<num>."
msgstr "I<from> または I<num> の値が不正である。"

#. type: Plain text
#: build/C/man2/ioperm.2:97
msgid "(on PowerPC) This call is not supported."
msgstr "(PowerPC で) このシステムコールはサポートしていない。"

#.  Could not allocate I/O bitmap.
#. type: Plain text
#: build/C/man2/ioperm.2:101
msgid "Out of memory."
msgstr "メモリ不足。"

#. type: Plain text
#: build/C/man2/ioperm.2:104
msgid "The calling thread has insufficient privilege."
msgstr "呼び出し元スレッドに十分な権限がなかった。"

#. type: Plain text
#: build/C/man2/ioperm.2:108
msgid ""
"B<ioperm>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<ioperm>()  は Linux 特有の関数であり、移植を意図したプログラムで 使用しては"
"ならない。"

#. type: Plain text
#: build/C/man2/ioperm.2:112
msgid ""
"The I</proc/ioports> file shows the I/O ports that are currently allocated "
"on the system."
msgstr ""
"I</proc/ioports> ファイルには、現在このシステムに割り当てられている I/O ポー"
"トが表示される。"

#. type: Plain text
#: build/C/man2/ioperm.2:121
msgid ""
"Libc5 treats it as a system call and has a prototype in I<E<lt>unistd."
"hE<gt>>.  Glibc1 does not have a prototype.  Glibc2 has a prototype both in "
"I<E<lt>sys/io.hE<gt>> and in I<E<lt>sys/perm.hE<gt>>.  Avoid the latter, it "
"is available on i386 only."
msgstr ""
"libc5 ではシステムコールとして扱い I<E<lt>unistd.hE<gt>> にプロトタイプが存在"
"している。 glibc1 にはプロトタイプは存在しない。 glibc2 は I<E<lt>sys/io."
"hE<gt>> と I<E<lt>sys/perm.hE<gt>> の両方にプロトタイプを持っている。 後者は "
"i386 のみで利用可能なので、使用すべきではない。"

#. type: Plain text
#: build/C/man2/ioperm.2:125
msgid "B<iopl>(2), B<outb>(2), B<capabilities>(7)"
msgstr "B<iopl>(2), B<outb>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man3/lockf.3:28
#, no-wrap
msgid "LOCKF"
msgstr "LOCKF"

#. type: Plain text
#: build/C/man3/lockf.3:31
msgid "lockf - apply, test or remove a POSIX lock on an open file"
msgstr ""
"lockf - オープンされたファイルに対する POSIX ロックの適用・テスト・解除を行う"

#. type: Plain text
#: build/C/man3/lockf.3:35
msgid "B<int lockf(int >I<fd>B<, int >I<cmd>B<, off_t >I<len>B<);>"
msgstr "B<int lockf(int >I<fd>B<, int >I<cmd>B<, off_t >I<len>B<);>"

#. type: Plain text
#: build/C/man3/lockf.3:42
msgid "B<lockf>():"
msgstr "B<lockf>():"

#. type: Plain text
#: build/C/man3/lockf.3:46
msgid ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/lockf.3:69
msgid ""
"Apply, test or remove a POSIX lock on a section of an open file.  The file "
"is specified by I<fd>, a file descriptor open for writing, the action by "
"I<cmd>, and the section consists of byte positions I<pos>..I<pos>+I<len>-1 "
"if I<len> is positive, and I<pos>-I<len>..I<pos>-1 if I<len> is negative, "
"where I<pos> is the current file position, and if I<len> is zero, the "
"section extends from the current file position to infinity, encompassing the "
"present and future end-of-file positions.  In all cases, the section may "
"extend past current end-of-file."
msgstr ""
"オープンされたファイルのセクションに対して、 POSIX ロックの適用・テスト・解除"
"をする。 ファイルは I<fd> で指定される。 I<fd> は書き込みのためにオープンした"
"ファイルディスクリプタである。 アクションは I<cmd> で指定される。 I<pos> を現"
"在のファイル位置とすると、 I<len> が正の場合、セクションはバイト位置 I<pos>.."
"I<pos>+I<len>-1 となり、 I<len> が負の場合、セクションはバイト位置 I<pos>-"
"I<len>..I<pos>-1 となる。 I<len> が 0 の場合、セクションは現在のファイル位置"
"から無限大までとなる (つまり現在の、あるいは変更された場合は将来の、ファイル"
"終端位置まで)。 どの場合においても、セクションは以前のファイル終端よりも拡大"
"されうる。"

#. type: Plain text
#: build/C/man3/lockf.3:84
msgid ""
"On Linux, B<lockf>()  is just an interface on top of B<fcntl>(2)  locking.  "
"Many other systems implement B<lockf>()  in this way, but note that "
"POSIX.1-2001 leaves the relationship between B<lockf>()  and B<fcntl>(2)  "
"locks unspecified.  A portable application should probably avoid mixing "
"calls to these interfaces."
msgstr ""
"Linux では、 B<lockf>()  は単に B<fcntl>(2)  のロックへのインターフェースであ"
"る。 多くの他のシステムで B<lockf>()  はこのように実装されているが、 "
"POSIX.1-2001 では B<lockf>()  と B<fcntl>(2)  のロックとの関係は規定されてい"
"ない。 おそらく、移植性が必要なアプリケーションでは、 B<lockf>()  と B<fcntl>"
"(2)  のロックを混ぜて呼び出すのは避けるべきであろう。"

#. type: Plain text
#: build/C/man3/lockf.3:86
msgid "Valid operations are given below:"
msgstr "有効なオプションを以下に挙げる。"

#. type: TP
#: build/C/man3/lockf.3:86
#, no-wrap
msgid "B<F_LOCK>"
msgstr "B<F_LOCK>"

#. type: Plain text
#: build/C/man3/lockf.3:96
msgid ""
"Set an exclusive lock on the specified section of the file.  If (part of) "
"this section is already locked, the call blocks until the previous lock is "
"released.  If this section overlaps an earlier locked section, both are "
"merged.  File locks are released as soon as the process holding the locks "
"closes some file descriptor for the file.  A child process does not inherit "
"these locks."
msgstr ""
"ファイルの指定されたセクションに排他ロックを設定する。 そのセクション (の一"
"部) が既にロックされていた場合、 前のロックが解除されるまで関数の呼び出しがブ"
"ロックされる。 このセクションが前にロックされているセクションと重なった場"
"合、 2 つのセクションは結合される。 ロックを保持しているプロセスが、 そのファ"
"イルのファイルディスクリプタをクローズすると、 ファイルロックは解放される。 "
"子プロセスはロックを継承しない。"

#. type: TP
#: build/C/man3/lockf.3:96
#, no-wrap
msgid "B<F_TLOCK>"
msgstr "B<F_TLOCK>"

#. type: Plain text
#: build/C/man3/lockf.3:102
msgid ""
"Same as B<F_LOCK> but the call never blocks and returns an error instead if "
"the file is already locked."
msgstr ""
"B<F_LOCK> と同様であるが、ファイルが既にロックされている場合、 関数の呼び出し"
"はブロックを行わずにエラーを返す。"

#. type: TP
#: build/C/man3/lockf.3:102
#, no-wrap
msgid "B<F_ULOCK>"
msgstr "B<F_ULOCK>"

#. type: Plain text
#: build/C/man3/lockf.3:106
msgid ""
"Unlock the indicated section of the file.  This may cause a locked section "
"to be split into two locked sections."
msgstr ""
"ファイルの指定されたセクションのロックを解除する。 これによりロックされたセク"
"ションが 2 つに分割されるかもしれない。"

#. type: TP
#: build/C/man3/lockf.3:106
#, no-wrap
msgid "B<F_TEST>"
msgstr "B<F_TEST>"

#. type: Plain text
#: build/C/man3/lockf.3:116
msgid ""
"Test the lock: return 0 if the specified section is unlocked or locked by "
"this process; return -1, set I<errno> to B<EAGAIN> (B<EACCES> on some other "
"systems), if another process holds a lock."
msgstr ""
"次のようにロックのテストをする。 指定されたセクションがロックされていない"
"か、 このプロセスによりロックされている場合、0 を返す。 他のプロセスがロック"
"を保持している場合、-1 を返し、 I<errno> を B<EAGAIN> (いくつかの他のシステム"
"では B<EACCES>)  に設定する。"

#. type: Plain text
#: build/C/man3/lockf.3:130
msgid ""
"The file is locked and B<F_TLOCK> or B<F_TEST> was specified, or the "
"operation is prohibited because the file has been memory-mapped by another "
"process."
msgstr ""
"ロックされたファイルに対して、 B<F_TLOCK> または B<F_TEST> が指定されてい"
"る。 または、ファイルが他のプロセスによりメモリーマップされており、 指定され"
"た操作が禁止されている。"

#. type: Plain text
#: build/C/man3/lockf.3:142
msgid ""
"I<fd> is not an open file descriptor; or I<cmd> is B<F_LOCK> or B<F_TLOCK> "
"and I<fd> is not a writable file descriptor."
msgstr ""
"I<fd> がオープンされたファイルのディスクリプタではない。 または、 I<cmd> が "
"B<F_LOCK> か B<F_TLOCK> で、 I<fd> が書き込み可能なファイルディスクリプタでな"
"い。"

#. type: Plain text
#: build/C/man3/lockf.3:147
msgid ""
"The command was B<F_LOCK> and this lock operation would cause a deadlock."
msgstr ""
"コマンドが B<F_LOCK> であり、このロック操作を行うとデッドロックが発生してしま"
"う。"

#. type: Plain text
#: build/C/man3/lockf.3:151
msgid "An invalid operation was specified in I<cmd>."
msgstr "I<cmd> に無効な操作が指定された。"

#. type: Plain text
#: build/C/man3/lockf.3:154
msgid "Too many segment locks open, lock table is full."
msgstr "非常に多くのセグメントロックが開かれ、ロックテーブルが一杯である。"

#. type: Plain text
#: build/C/man3/lockf.3:156
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/lockf.3:159
msgid "B<fcntl>(2), B<flock>(2)"
msgstr "B<fcntl>(2), B<flock>(2)"

#. type: Plain text
#: build/C/man3/lockf.3:171
msgid ""
"I<locks.txt> and I<mandatory-locking.txt> in the Linux kernel source "
"directory I<Documentation/filesystems> (on older kernels, these files are "
"directly under the I<Documentation> directory, and I<mandatory-locking.txt> "
"is called I<mandatory.txt>)"
msgstr ""
"Linux カーネルソースの I<Documentation/filesystems> ディレクトリにある "
"I<locks.txt> と I<mandatory-locking.txt> (以前のカーネルでは、これらのファイ"
"ルは I<Documentation> ディレクトリ直下にあり、 I<mandatory-locking.txt> は "
"I<mandatory.txt> という名前であった。)"

#. type: TH
#: build/C/man2/mincore.2:34
#, no-wrap
msgid "MINCORE"
msgstr "MINCORE"

#. type: TH
#: build/C/man2/mincore.2:34
#, no-wrap
msgid "2008-04-22"
msgstr "2008-04-22"

#. type: Plain text
#: build/C/man2/mincore.2:37
msgid "mincore - determine whether pages are resident in memory"
msgstr "mincore - ページがメモリ内にあるかどうかを判定する"

#. type: Plain text
#: build/C/man2/mincore.2:41
msgid "B<#include E<lt>sys/mman.hE<gt>>"
msgstr "B<#include E<lt>sys/mman.hE<gt>>"

#. type: Plain text
#: build/C/man2/mincore.2:43
msgid ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"
msgstr ""
"B<int mincore(void *>I<addr>B<, size_t >I<length>B<, unsigned char "
"*>I<vec>B<);>"

#. type: Plain text
#: build/C/man2/mincore.2:51
msgid "B<mincore>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr "B<mincore>(): _BSD_SOURCE || _SVID_SOURCE"

#. type: Plain text
#: build/C/man2/mincore.2:62
msgid ""
"B<mincore>()  returns a vector that indicates whether pages of the calling "
"process's virtual memory are resident in core (RAM), and so will not cause a "
"disk access (page fault) if referenced.  The kernel returns residency "
"information about the pages starting at the address I<addr>, and continuing "
"for I<length> bytes."
msgstr ""
"B<mincore>()  は、呼び出し元プロセスの仮想メモリのページがコア (RAM) 内に存在"
"し、 ページ参照時にディスクアクセス (ページフォールト) を起こさないか どうか"
"を示すベクトルを返す。カーネルは、アドレス I<addr> から始まる I<length> バイ"
"トの範囲のページに関する存在情報を返す。"

#. type: Plain text
#: build/C/man2/mincore.2:76
msgid ""
"The I<addr> argument must be a multiple of the system page size.  The "
"I<length> argument need not be a multiple of the page size, but since "
"residency information is returned for whole pages, I<length> is effectively "
"rounded up to the next multiple of the page size.  One may obtain the page "
"size (B<PAGE_SIZE>)  using I<sysconf(_SC_PAGESIZE)>."
msgstr ""
"I<addr> 引き数はシステムのページサイズの倍数でなければならない。 I<length> 引"
"き数はページサイズの倍数である必要はないが、 ページ全体に関する存在情報が返さ"
"れるので、事実上 I<length> はページサイズの倍数に切り上げられることになる。 "
"ページサイズ (B<PAGE_SIZE>)  は I<sysconf(_SC_PAGESIZE)> を使って入手できる。"

#. type: Plain text
#: build/C/man2/mincore.2:94
msgid ""
"The I<vec> argument must point to an array containing at least I<(length"
"+PAGE_SIZE-1) / PAGE_SIZE> bytes.  On return, the least significant bit of "
"each byte will be set if the corresponding page is currently resident in "
"memory, and be clear otherwise.  (The settings of the other bits in each "
"byte are undefined; these bits are reserved for possible later use.)  Of "
"course the information returned in I<vec> is only a snapshot: pages that are "
"not locked in memory can come and go at any moment, and the contents of "
"I<vec> may already be stale by the time this call returns."
msgstr ""
"I<vec> 引き数は、少なくとも I<(length+PAGE_SIZE-1) / PAGE_SIZE> バイトが格納"
"できる配列を指していなければならない。 この呼び出しが返るとき、 各バイトの最"
"下位ビットは、対応するページがメモリ内にそのとき存在すれば セットされ、そうで"
"ない場合はクリアされる (各バイトのその他のビットは未定義であり、これらのビッ"
"トは将来の使用に そなえて予約されている)。 もちろん、 I<vec> で返された情報は"
"スナップショットでしかない。 メモリ内にロックされていないページは、任意の時点"
"でメモリ内に 入ったり出たりでき、この呼び出しが返るときには I<vec> の内容はす"
"でに古くなっているかもしれない。"

#. type: Plain text
#: build/C/man2/mincore.2:101
msgid ""
"On success, B<mincore>()  returns zero.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<mincore>()  は 0 を返す。 エラーの場合は -1 を返して、 "
"I<errno> を適切な値に設定する。"

#. type: Plain text
#: build/C/man2/mincore.2:104
msgid "B<EAGAIN> kernel is temporarily out of resources."
msgstr "B<EAGAIN> カーネルが一時的にリソースを使い果たしている。"

#. type: Plain text
#: build/C/man2/mincore.2:108
msgid "I<vec> points to an invalid address."
msgstr "I<vec> が無効なアドレスを指している。"

#. type: Plain text
#: build/C/man2/mincore.2:112
msgid "I<addr> is not a multiple of the page size."
msgstr "I<addr> がページサイズの倍数でない。"

#. type: Plain text
#: build/C/man2/mincore.2:124
msgid ""
"I<length> is greater than (I<TASK_SIZE> - I<addr>).  (This could occur if a "
"negative value is specified for I<length>, since that value will be "
"interpreted as a large unsigned integer.)  In Linux 2.6.11 and earlier, the "
"error B<EINVAL> was returned for this condition."
msgstr ""
"I<length> が (I<TASK_SIZE> - I<addr>)  より大きい。 (I<length> に負の値が指定"
"された場合、 その値が大きな符号なし整数として解釈されるために起こることがあ"
"る。)  Linux 2.6.11 以前では、この条件の場合はエラー B<EINVAL> が返されてい"
"た。"

#. type: Plain text
#: build/C/man2/mincore.2:132
msgid "I<addr> to I<addr> + I<length> contained unmapped memory."
msgstr ""
"I<addr> から I<addr> + I<length> の間にマップされていないメモリがあった。"

#. type: Plain text
#: build/C/man2/mincore.2:134
msgid "Available since Linux 2.3.99pre1 and glibc 2.2."
msgstr "Linux 2.3.99pre1 と glibc 2.2 から利用可能である。"

#.  It is on at least NetBSD, FreeBSD, OpenBSD, Solaris 8,
#.  AIX 5.1, SunOS 4.1
#.  .SH HISTORY
#.  The
#.  .BR mincore ()
#.  function first appeared in 4.4BSD.
#. type: Plain text
#: build/C/man2/mincore.2:144
msgid ""
"B<mincore>()  is not specified in POSIX.1-2001, and it is not available on "
"all UNIX implementations."
msgstr ""
"B<mincore>()  は POSIX.1-2001 に記述されておらず、 全ての UNIX 実装で利用可能"
"であるわけではない。"

#.  Linux (up to now, 2.6.5),
#.  .B mincore
#.  does not return correct information for MAP_PRIVATE mappings:
#.  for a MAP_PRIVATE file mapping,
#.  .B mincore
#.  returns the residency of the file pages, rather than any
#.  modified process-private pages that have been copied on write;
#.  for a MAP_PRIVATE mapping of
#.  .IR /dev/zero ,
#.  .B mincore
#.  always reports pages as nonresident;
#.  and for a MAP_PRIVATE, MAP_ANONYMOUS mapping,
#.  .B mincore
#.  always fails with the error
#.  .BR ENOMEM .
#. type: Plain text
#: build/C/man2/mincore.2:166
msgid ""
"Before kernel 2.6.21, B<mincore>()  did not return correct information for "
"B<MAP_PRIVATE> mappings, or for nonlinear mappings (established using "
"B<remap_file_pages>(2))."
msgstr ""
"カーネル 2.6.21 より前は、 B<mincore>()  は、 B<MAP_PRIVATE> マッピングや非線"
"形マッピング (B<remap_file_pages>(2)  を使って作成される) について正しい情報"
"を返さなかった。"

#. type: Plain text
#: build/C/man2/mincore.2:169
msgid "B<mlock>(2), B<mmap>(2)"
msgstr "B<mlock>(2), B<mmap>(2)"

#. type: TH
#: build/C/man2/mkdir.2:11
#, no-wrap
msgid "MKDIR"
msgstr "MKDIR"

#. type: Plain text
#: build/C/man2/mkdir.2:14
msgid "mkdir, mkdirat - create a directory"
msgstr "mkdir, mkdirat - ディレクトリを作成する"

#.  .B #include <unistd.h>
#. type: Plain text
#: build/C/man2/mkdir.2:19
#, no-wrap
msgid ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/stat.hE<gt>>\n"
"B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:21
#, no-wrap
msgid "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkdir(const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:24
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>           >/* Definition of AT_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>           >/* AT_* 定数の定義 */\n"
"B<#include E<lt>sys/stat.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:26
#, no-wrap
msgid "B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"
msgstr "B<int mkdirat(int >I<dirfd>B<, const char *>I<pathname>B<, mode_t >I<mode>B<);>\n"

#. type: Plain text
#: build/C/man2/mkdir.2:34
msgid "B<mkdirat>():"
msgstr "B<mkdirat>():"

#. type: Plain text
#: build/C/man2/mkdir.2:51
msgid "B<mkdir>()  attempts to create a directory named I<pathname>."
msgstr ""
"B<mkdir>()  は I<pathname> で示される名前のディレクトリを作成しようとする。"

#. type: Plain text
#: build/C/man2/mkdir.2:61
msgid ""
"The argument I<mode> specifies the permissions to use.  It is modified by "
"the process's I<umask> in the usual way: the permissions of the created "
"directory are (I<mode> & ~I<umask> & 0777).  Other mode bits of the created "
"directory depend on the operating system.  For Linux, see below."
msgstr ""
"I<mode> 引き数は、作成されたディレクトリの許可属性を決定するのに使われる。 こ"
"の値に、通常通りプロセスの I<umask> による修正が加えられる。 したがって、作成"
"されたディレクトリの許可属性は (I<mode> & ~I<umask> & 0777)  となる。 作成さ"
"れたディレクトリのその他のモードビットはオペレーティングシステムに 依存する。"
"Linux の場合は、以下の通りである。"

#. type: Plain text
#: build/C/man2/mkdir.2:71
msgid ""
"The newly created directory will be owned by the effective user ID of the "
"process.  If the directory containing the file has the set-group-ID bit set, "
"or if the filesystem is mounted with BSD group semantics (I<mount -o "
"bsdgroups> or, synonymously I<mount -o grpid>), the new directory will "
"inherit the group ownership from its parent; otherwise it will be owned by "
"the effective group ID of the process."
msgstr ""
"新しく作成されたディレクトリの所有者はプロセスの実効ユーザ ID に設定される。 "
"新たに作成されたディレクトリが含まれる親ディレクトリに set group ID ビットが"
"セットされていたり、ファイルシステムが BSD の グループセマンティクス "
"(I<mount -o bsdgroups> あるいは、同じ意味の I<mount -o grpid>)  に従ってマウ"
"ントされている場合には、 新たに作成されたディレクトリのグループ所有権は親ディ"
"レクトリの ものが継承される (親ディレクトリと同じになる)。 それ以外の場合は、"
"グループ所有権はプロセスの実効グループ ID となる。"

#. type: Plain text
#: build/C/man2/mkdir.2:76
msgid ""
"If the parent directory has the set-group-ID bit set, then so will the newly "
"created directory."
msgstr ""
"もし親ディレクトリに set group ID ビットがセットされていれば新しく作成される "
"ディレクトリにも set group ID ビットがセットされる。"

#. type: SS
#: build/C/man2/mkdir.2:76
#, no-wrap
msgid "mkdirat()"
msgstr "mkdirat()"

#. type: Plain text
#: build/C/man2/mkdir.2:82
msgid ""
"The B<mkdirat>()  system call operates in exactly the same way as B<mkdir>"
"(), except for the differences described here."
msgstr ""

#. type: Plain text
#: build/C/man2/mkdir.2:92
msgid ""
"If the pathname given in I<pathname> is relative, then it is interpreted "
"relative to the directory referred to by the file descriptor I<dirfd> "
"(rather than relative to the current working directory of the calling "
"process, as is done by B<mkdir>()  for a relative pathname)."
msgstr ""

#. type: Plain text
#: build/C/man2/mkdir.2:104
msgid ""
"If I<pathname> is relative and I<dirfd> is the special value B<AT_FDCWD>, "
"then I<pathname> is interpreted relative to the current working directory of "
"the calling process (like B<mkdir>())."
msgstr ""

#. type: Plain text
#: build/C/man2/mkdir.2:115
msgid "See B<openat>(2)  for an explanation of the need for B<mkdirat>()."
msgstr ""

#. type: Plain text
#: build/C/man2/mkdir.2:122
msgid ""
"B<mkdir>()  and B<mkdirat>()  return zero on success, or -1 if an error "
"occurred (in which case, I<errno> is set appropriately)."
msgstr "B<mkdir>() と B<mkdirat>() は成功した場合 0 を、失敗した場合 -1 を返す (また、 I<errno> がエラーの内容にしたがって適切に設定される)。"

#. type: Plain text
#: build/C/man2/mkdir.2:131
msgid ""
"The parent directory does not allow write permission to the process, or one "
"of the directories in I<pathname> did not allow search permission.  (See "
"also B<path_resolution>(7).)"
msgstr ""
"プロセスが親ディレクトリへの書き込み許可を持たない、もしくは I<pathname> 中の"
"ディレクトリのどれかに検索許可属性が無い (B<path_resolution>(7)  も参照)。"

#. type: TP
#: build/C/man2/mkdir.2:131
#, no-wrap
msgid "B<EDQUOT>"
msgstr "B<EDQUOT>"

#. type: Plain text
#: build/C/man2/mkdir.2:135
msgid ""
"The user's quota of disk blocks or inodes on the filesystem has been "
"exhausted."
msgstr ""
"ディスクブロックか inode がそのファイルシステムのユーザクォータに達していた。"

#. type: TP
#: build/C/man2/mkdir.2:135
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/mkdir.2:142
msgid ""
"I<pathname> already exists (not necessarily as a directory).  This includes "
"the case where I<pathname> is a symbolic link, dangling or not."
msgstr ""
"I<pathname> が既に存在している(ただしそれがディレクトリであるとは限らない)。 "
"I<pathname> がシンボリックリンクの場合も (その指定先が存在するかどうかに関ら"
"ず)エラーになる。"

#. type: TP
#: build/C/man2/mkdir.2:149
#, no-wrap
msgid "B<EMLINK>"
msgstr "B<EMLINK>"

#. type: Plain text
#: build/C/man2/mkdir.2:153
msgid "The number of links to the parent directory would exceed B<LINK_MAX>."
msgstr "親ディレクトリへのリンク数が B<LINK_MAX> を超えてしまう。"

#. type: Plain text
#: build/C/man2/mkdir.2:156
msgid "I<pathname> was too long."
msgstr "I<pathname> が長すぎる。"

#. type: Plain text
#: build/C/man2/mkdir.2:161
msgid ""
"A directory component in I<pathname> does not exist or is a dangling "
"symbolic link."
msgstr ""
"I<pathname> の構成要素のディレクトリのいずれかが存在しないか、 またはリンク先"
"が存在しないシンボリックリンクである。"

#. type: TP
#: build/C/man2/mkdir.2:164 build/C/man2/mkdir.2:169
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/mkdir.2:169
msgid "The device containing I<pathname> has no room for the new directory."
msgstr "I<pathname> を含むデバイスに新たにディレクトリを作成する空きが無い。"

#. type: Plain text
#: build/C/man2/mkdir.2:173
msgid ""
"The new directory cannot be created because the user's disk quota is "
"exhausted."
msgstr ""
"もしくはユーザーのディスク quota が使い切られているため、 新たにディレクトリ"
"を作成することができない。"

#. type: Plain text
#: build/C/man2/mkdir.2:183
msgid ""
"The filesystem containing I<pathname> does not support the creation of "
"directories."
msgstr ""
"I<pathname> を含むファイルシステムがディレクトリの作成をサポートしていない。"

#. type: Plain text
#: build/C/man2/mkdir.2:187
msgid "I<pathname> refers to a file on a read-only filesystem."
msgstr "I<pathname> が読み出し専用ファイルシステム上のファイルを指している。"

#. type: Plain text
#: build/C/man2/mkdir.2:190
msgid "The following additional errors can occur for B<mkdirat>():"
msgstr ""

#. type: Plain text
#: build/C/man2/mkdir.2:204
#, fuzzy
#| msgid ""
#| "B<dup3>()  was added to Linux in version 2.6.27; glibc support is "
#| "available starting with version 2.9."
msgid ""
"B<mkdirat>()  was added to Linux in kernel 2.6.16; library support was added "
"to glibc in version 2.4."
msgstr ""
"B<dup3>()  はバージョン 2.6.27 で Linux に追加された。 glibc によるサポートは"
"バージョン 2.9 以降で利用できる。"

#.  SVr4 documents additional EIO, EMULTIHOP
#. type: Plain text
#: build/C/man2/mkdir.2:208
msgid "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."
msgstr "B<mkdir>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008."

#. type: Plain text
#: build/C/man2/mkdir.2:211
msgid "B<mkdirat>(): POSIX.1-2008."
msgstr "B<mkdirat>(): POSIX.1-2008."

#. type: Plain text
#: build/C/man2/mkdir.2:219
msgid ""
"Under Linux apart from the permission bits, only the B<S_ISVTX> mode bit is "
"honored.  That is, under Linux the created directory actually gets mode "
"(I<mode> & ~I<umask> & 01777).  See also B<stat>(2)."
msgstr ""
"Linux では、許可ビット以外で意味を持つのは、 B<S_ISVTX> モードビットだけであ"
"る。 つまり、Linux では作成されたディレクトリは実際には (I<mode> & ~I<umask> "
"& 01777)  のモードを持つことになる。 B<stat>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/mkdir.2:223
msgid ""
"There are many infelicities in the protocol underlying NFS.  Some of these "
"affect B<mkdir>()."
msgstr ""
"NFS を実現しているプロトコルには多くの不備が存在し、 それら中には B<mkdir>"
"()  に影響を与えるものもある。"

#. type: Plain text
#: build/C/man2/mkdir.2:234
msgid ""
"B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), B<rmdir>"
"(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<path_resolution>(7)"
msgstr "B<mkdir>(1), B<chmod>(2), B<chown>(2), B<mknod>(2), B<mount>(2), B<rmdir>(2), B<stat>(2), B<umask>(2), B<unlink>(2), B<path_resolution>(7)"

#. type: TH
#: build/C/man2/nice.2:31
#, no-wrap
msgid "NICE"
msgstr "NICE"

#. type: TH
#: build/C/man2/nice.2:31 build/C/man2/vhangup.2:28
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: build/C/man2/nice.2:34
msgid "nice - change process priority"
msgstr "nice - プロセスの優先度を変更する"

#. type: Plain text
#: build/C/man2/nice.2:38
msgid "B<int nice(int >I<inc>B<);>"
msgstr "B<int nice(int >I<inc>B<);>"

#. type: Plain text
#: build/C/man2/nice.2:46
msgid "B<nice>(): _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"
msgstr "B<nice>(): _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE"

#. type: Plain text
#: build/C/man2/nice.2:56
msgid ""
"B<nice>()  adds I<inc> to the nice value for the calling process.  (A higher "
"nice value means a low priority.)  Only the super\\%user may specify a "
"negative increment, or priority increase.  The range for nice values is "
"described in B<getpriority>(2)."
msgstr ""
"B<nice>()  は I<inc> の値を B<nice> を呼んだプロセスの nice 値に加える (nice "
"値が大きい数値ほど低い優先度を表す)。 負の数を指定する、つまり、以前よりも優"
"先度を上げるという指定ができるのは スーパーユーザーだけである。 nice 値の範囲"
"については B<getpriority>(2)  で説明されている。"

#. type: Plain text
#: build/C/man2/nice.2:61
msgid ""
"On success, the new nice value is returned (but see NOTES below).  On error, "
"-1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、新しい nice 値が返る (但し、下記の「注意」を参照)。 失敗した場"
"合 -1 が返り、 I<errno> がエラーの内容に従って設定される。"

#. type: Plain text
#: build/C/man2/nice.2:75
msgid ""
"The calling process attempted to increase its priority by supplying a "
"negative I<inc> but has insufficient privileges.  Under Linux the "
"B<CAP_SYS_NICE> capability is required.  (But see the discussion of the "
"B<RLIMIT_NICE> resource limit in B<setrlimit>(2).)"
msgstr ""
"スーパーユーザー以外が I<inc> に負の数値を指定して優先度を上げようとした。 呼"
"び出し元のプロセスが I<inc> に負の数値を指定して優先度を上げようとしたが、 十"
"分な権限を持っていなかった。 Linux では B<CAP_SYS_NICE> ケーパビリティが必要"
"である。 (B<setrlimit>(2)  のリソース上限 B<RLIMIT_NICE> に関する議論も参照の"
"こと)。"

#. type: Plain text
#: build/C/man2/nice.2:82
msgid ""
"SVr4, 4.3BSD, POSIX.1-2001.  However, the Linux and (g)libc (earlier than "
"glibc 2.2.4) return value is nonstandard, see below.  SVr4 documents an "
"additional B<EINVAL> error code."
msgstr ""
"SVr4, 4.3BSD, POSIX.1-2001.  しかし、Linux と (2.2.4より古い) (g)libc では返"
"り値は標準と異なる。 詳細は以下を参照のこと。 SVr4 には他に B<EINVAL> エラー"
"コードについての記述がある。"

#. type: Plain text
#: build/C/man2/nice.2:92
msgid ""
"SUSv2 and POSIX.1-2001 specify that B<nice>()  should return the new nice "
"value.  However, the Linux syscall and the B<nice>()  library function "
"provided in older versions of (g)libc (earlier than glibc 2.2.4) return 0 on "
"success.  The new nice value can be found using B<getpriority>(2)."
msgstr ""
"SUSv2 と POSIX 1003.1-2003 では、 B<nice>()  は新しい nice 値を返すと規定され"
"ている。 一方、Linux システムコールと (2.2.4 より古い) (g)libc ライブラリ関数"
"は 成功時に 0 を返す。新しい nice 値は B<getpriority>(2)  を使って取得でき"
"る。"

#. type: Plain text
#: build/C/man2/nice.2:105
msgid ""
"Since glibc 2.2.4, B<nice>()  is implemented as a library function that "
"calls B<getpriority>(2)  to obtain the new nice value to be returned to the "
"caller.  With this implementation, a successful call can legitimately return "
"-1.  To reliably detect an error, set I<errno> to 0 before the call, and "
"check its value when B<nice>()  returns -1."
msgstr ""
"glibc 2.2.4 以降では、 B<nice>()  は B<getpriority>(2)  を呼び出すライブラリ"
"関数として実装されており、 呼び出し元に返す新しい nice 値を B<getpriority>"
"(2)  を呼び出して取得するようになっている。 この実装では、正常な動作でも -1 "
"が返される可能性がある。 確実にエラーを検出するためには、 呼び出しの前に "
"I<errno> に 0 を設定し、 B<nice>()  が -1 を返したときに errno をチェックする"
"と良い。"

#. type: Plain text
#: build/C/man2/nice.2:112
msgid ""
"B<nice>(1), B<renice>(1), B<fork>(2), B<getpriority>(2), B<setpriority>(2), "
"B<capabilities>(7)"
msgstr ""
"B<nice>(1), B<renice>(1), B<fork>(2), B<getpriority>(2), B<setpriority>(2), "
"B<capabilities>(7)"

#. type: TH
#: build/C/man2/pread.2:25
#, no-wrap
msgid "PREAD"
msgstr "PREAD"

#. type: Plain text
#: build/C/man2/pread.2:28
msgid ""
"pread, pwrite - read from or write to a file descriptor at a given offset"
msgstr ""
"pread, pwrite - 指定したオフセットでファイルディスクリプタを読み書きする"

#. type: Plain text
#: build/C/man2/pread.2:33
msgid ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"
msgstr ""
"B<ssize_t pread(int >I<fd>B<, void *>I<buf>B<, size_t >I<count>B<, off_t "
">I<offset>B<);>"

#. type: Plain text
#: build/C/man2/pread.2:36
msgid ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"
msgstr ""
"B<ssize_t pwrite(int >I<fd>B<, const void *>I<buf>B<, size_t >I<count>B<, "
"off_t >I<offset>B<);>"

#. type: Plain text
#: build/C/man2/pread.2:46
msgid "B<pread>(), B<pwrite>():"
msgstr "B<pread>(), B<pwrite>():"

#. type: Plain text
#: build/C/man2/pread.2:48
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 500"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 500"

#. type: Plain text
#: build/C/man2/pread.2:64
msgid ""
"B<pread>()  reads up to I<count> bytes from file descriptor I<fd> at offset "
"I<offset> (from the start of the file) into the buffer starting at I<buf>.  "
"The file offset is not changed."
msgstr ""
"B<pread>()  は、ファイルディスクリプタ I<fd> の (ファイルの先頭からの) オフ"
"セット I<offset> から最大 I<count> バイトをバッファ I<buf> へ読み込む。ファイ"
"ルオフセットは変化しない。"

#. type: Plain text
#: build/C/man2/pread.2:75
msgid ""
"B<pwrite>()  writes up to I<count> bytes from the buffer starting at I<buf> "
"to the file descriptor I<fd> at offset I<offset>.  The file offset is not "
"changed."
msgstr ""
"B<pwrite>()  は、バッファ I<buf> から最大 I<count> バイトをファイルディスクリ"
"プタ I<fd> のオフセット I<offset> に書き込む。ファイルオフセットは変化しな"
"い。"

#. type: Plain text
#: build/C/man2/pread.2:79
msgid "The file referenced by I<fd> must be capable of seeking."
msgstr "I<fd> で参照されるファイルはシーク (seek) 可能でなければならない。"

#. type: Plain text
#: build/C/man2/pread.2:89
msgid ""
"On success, the number of bytes read or written is returned (zero indicates "
"that nothing was written, in the case of B<pwrite>(), or end of file, in the "
"case of B<pread>()), or -1 on error, in which case I<errno> is set to "
"indicate the error."
msgstr ""
"成功した場合、読み書きを行ったバイト数が返される (ゼロは、 B<pwrite>()  の場"
"合には何も書かれなかったことを意味し、 B<pread>()  の場合にはファイル の末尾"
"に達したことを意味する)。 エラーの場合は -1 が返され、 I<errno> がそのエラー"
"を示すように設定される。"

#. type: Plain text
#: build/C/man2/pread.2:104
msgid ""
"B<pread>()  can fail and set I<errno> to any error specified for B<read>(2)  "
"or B<lseek>(2).  B<pwrite>()  can fail and set I<errno> to any error "
"specified for B<write>(2)  or B<lseek>(2)."
msgstr ""
"B<pread>()  では、 B<read>(2)  および B<lseek>(2)  で規定された全てのエラーが"
"発生する可能性があり、 I<error> にはエラーを示す値が設定される。 B<pwrite>"
"()  では、 B<write>(2)  および B<lseek>(2)  で規定された全てのエラーが発生す"
"る可能性があり、 I<error> にはエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/pread.2:115
msgid ""
"The B<pread>()  and B<pwrite>()  system calls were added to Linux in version "
"2.1.60; the entries in the i386 system call table were added in 2.1.69.  C "
"library support (including emulation using B<lseek>(2)  on older kernels "
"without the system calls) was added in glibc 2.1."
msgstr ""
"システムコール B<pread>()  と B<pwrite>()  は Linux にバージョン 2.1.60 で追"
"加された。 i386 のシステムコールのエントリは 2.1.69 で追加された。 (システム"
"コールを持たない古いカーネルでの B<lseek>(2)  を使ったエミュレーションを含め"
"ると)  C ライブラリにおけるサポートは glibc 2.1 で追加された。"

#. type: Plain text
#: build/C/man2/pread.2:125
msgid ""
"The B<pread>()  and B<pwrite>()  system calls are especially useful in "
"multithreaded applications.  They allow multiple threads to perform I/O on "
"the same file descriptor without being affected by changes to the file "
"offset by other threads."
msgstr ""
"システムコール B<pread>() と B<pwrite>() は、特にマルチスレッドアプリケーショ"
"ンで役に立つ。 これらを使うと、 他のスレッドによるファイルオフセットの変更の"
"影響を受けることなく、 複数のスレッドが同じファイルディスクリプタに対して入出"
"力を行うことができる。"

#. type: Plain text
#: build/C/man2/pread.2:141
msgid ""
"On Linux, the underlying system calls were renamed in kernel 2.6: B<pread>"
"()  became B<pread64>(), and B<pwrite>()  became B<pwrite64>().  The system "
"call numbers remained the same.  The glibc B<pread>()  and B<pwrite>()  "
"wrapper functions transparently deal with the change."
msgstr ""
"Linux では、裏で呼び出されるシステムコールの名前がカーネル 2.6 で変更され"
"た。\n"
"B<pread>() は B<pread64>() になり、 B<pwrite>() は B<pwrite64>() になった。\n"
"システムコールの番号は変更されていない。\n"
"glibc の B<pread>() と B<pwrite>() のラッパー関数はこれらの変更を吸収してい"
"る。"

#. type: Plain text
#: build/C/man2/pread.2:146 build/C/man2/truncate.2:248
msgid ""
"On some 32-bit architectures, the calling signature for these system calls "
"differ, for the reasons described in B<syscall>(2)."
msgstr ""
"いくつかの 32 ビットアーキテクチャでは、これらのシステムコールの呼び出し時の"
"シグネチャーが違っています。理由は B<syscall>(2) で説明されている通りです。"

#.  FIXME https://bugzilla.kernel.org/show_bug.cgi?id=43178
#. type: Plain text
#: build/C/man2/pread.2:158
msgid ""
"POSIX requires that opening a file with the B<O_APPEND> flag should have no "
"affect on the location at which B<pwrite>()  writes data.  However, on "
"Linux, if a file is opened with B<O_APPEND>, B<pwrite>()  appends data to "
"the end of the file, regardless of the value of I<offset>."
msgstr ""
"POSIX では、B<O_APPEND> フラグを指定してファイルをオープンした場合、\n"
"B<pwrite>() がデータを書き込む位置に影響を及ぼさないことが\n"
"求められている。しかし、 Linux では、ファイルを B<O_APPEND> 付きで\n"
"オープンした場合、 I<offset> の値に関わらず、\n"
"B<pwrite>() はファイルの末尾にデータを追記する。"

#. type: Plain text
#: build/C/man2/pread.2:163
msgid "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"
msgstr "B<lseek>(2), B<read>(2), B<readv>(2), B<write>(2)"

#. type: TH
#: build/C/man2/set_thread_area.2:8
#, no-wrap
msgid "SET_THREAD_AREA"
msgstr "SET_THREAD_AREA"

#. type: Plain text
#: build/C/man2/set_thread_area.2:11
msgid "set_thread_area - set a thread local storage (TLS) area"
msgstr "set_thread_area - スレッド局所記憶 (TLS) 領域を設定する"

#. type: Plain text
#: build/C/man2/set_thread_area.2:17
msgid "B<int set_thread_area(struct user_desc *>I<u_info>B<);>"
msgstr "B<int set_thread_area(struct user_desc *>I<u_info>B<);>"

#. type: Plain text
#: build/C/man2/set_thread_area.2:33
msgid ""
"B<set_thread_area>()  sets an entry in the current thread's thread-local "
"storage (TLS) array.  The TLS array entry set by B<set_thread_area>()  "
"corresponds to the value of I<u_info-E<gt>entry_number> passed in by the "
"user.  If this value is in bounds, B<set_thread_area>()  copies the TLS "
"descriptor pointed to by I<u_info> into the thread's TLS array."
msgstr ""
"B<set_thread_area>()  は、カレントスレッドのスレッド局所記憶 (thread-local "
"storage; TLS)  配列の中のエントリを設定する。 B<set_thread_area>()  により設"
"定される TLS 配列のエントリは、ユーザから引き数として渡される I<u_info-"
"E<gt>entry_number> の値に対応している。値が範囲内にある場合、 "
"B<set_thread_area>()  は I<u_info> で指された TLS ディスクリプタをスレッドの "
"TLS 配列にコピーする。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:44
msgid ""
"When B<set_thread_area>()  is passed an I<entry_number> of -1, it uses a "
"free TLS entry.  If B<set_thread_area>()  finds a free TLS entry, the value "
"of I<u_info-E<gt>entry_number> is set upon return to show which entry was "
"changed."
msgstr ""
"I<entry_number> として -1 が渡された場合、 B<set_thread_area>()  は未使用 "
"(free) の TLS エントリを使用する。 未使用の TLS エントリがあった場合、どのエ"
"ントリが変更されたかが分かる ように終了時に I<u_info-E<gt>entry_number> の値"
"が変更される。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:49
msgid ""
"B<set_thread_area>()  returns 0 on success, and -1 on failure, with I<errno> "
"set appropriately."
msgstr ""
"B<set_thread_area>()  は成功した場合 0 を返す。失敗した場合は -1 を返し、 "
"I<errno> を適切に設定する。"

#. type: TP
#: build/C/man2/set_thread_area.2:56
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/set_thread_area.2:59
msgid "A free TLS entry could not be located."
msgstr "未使用の TLS エントリが見つからなかった。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:63
msgid "A version of B<set_thread_area>()  first appeared in Linux 2.5.29."
msgstr "B<set_thread_area>()  は Linux 2.5.29 で初めて登場した。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:67
msgid ""
"B<set_thread_area>()  is Linux-specific and should not be used in programs "
"that are intended to be portable."
msgstr ""
"B<set_thread_area>()  は Linux 独自であり、移植を意図したプログラムでは使用す"
"べきではない。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:72
msgid ""
"Glibc does not provide a wrapper for this system call, since it is generally "
"intended only for use by threading libraries.  In the unlikely event that "
"you want to call it directly, use B<syscall>(2)."
msgstr ""
"このシステムコールは通常はスレッドライブラリでのみ使用されることを目的として"
"用意されているため、 glibc はこのシステムコールに対するラッパー関数を提供して"
"いない。おそらくないと思うが、このシステムコールを直接呼び出したい場合は "
"B<syscall>(2) を使うこと。"

#. type: Plain text
#: build/C/man2/set_thread_area.2:74
msgid "B<get_thread_area>(2)"
msgstr "B<get_thread_area>(2)"

#. type: TH
#: build/C/man2/setup.2:34
#, no-wrap
msgid "SETUP"
msgstr "SETUP"

#. type: TH
#: build/C/man2/setup.2:34 build/C/man2/uname.2:27
#, no-wrap
msgid "2008-12-03"
msgstr "2008-12-03"

#. type: Plain text
#: build/C/man2/setup.2:37
msgid "setup - setup devices and filesystems, mount root filesystem"
msgstr ""
"setup - デバイスとファイルシステムの初期化を行い、 ルートファイルシステムのマ"
"ウントを行う"

#. type: Plain text
#: build/C/man2/setup.2:41
msgid "B<int setup(void);>"
msgstr "B<int setup(void);>"

#. type: Plain text
#: build/C/man2/setup.2:47
msgid ""
"B<setup>()  is called once from within I<linux/init/main.c>.  It calls "
"initialization functions for devices and filesystems configured into the "
"kernel and then mounts the root filesystem."
msgstr ""
"B<setup>()  は I<linux/init/main.c> の中で一度だけ呼ばれる。 カーネル内部のデ"
"バイスとファイルシステムの初期化関数を呼び、 ルートファイルシステムのマウント"
"を行う。"

#. type: Plain text
#: build/C/man2/setup.2:53
msgid ""
"No user process may call B<setup>().  Any user process, even a process with "
"superuser permission, will receive B<EPERM>."
msgstr ""
"ユーザープロセスからは B<setup>()  を呼びだすことはできない。 ユーザープロセ"
"スからのアクセスは、たとえそのプロセスが スーパーユーザー権限を持っていても "
"B<EPERM> を受け取ることになる。"

#. type: Plain text
#: build/C/man2/setup.2:56
msgid "B<setup>()  always returns -1 for a user process."
msgstr "B<setup>()  はユーザープロセスに対して常に -1 を返す。"

#. type: Plain text
#: build/C/man2/setup.2:62
msgid "Since Linux 2.1.121, no such function exists anymore."
msgstr "Linux 2.1.121 以降では、もはやこの関数は存在しない。"

#. type: Plain text
#: build/C/man2/setup.2:65
msgid ""
"This function is Linux-specific, and should not be used in programs intended "
"to be portable, or indeed in any programs at all."
msgstr ""
"この関数は Linux に特有のものであり、移植を考慮したプログラムでは 用いるべき"
"ではない。それどころか、あらゆるプログラムで用いるべきではない。"

#. type: Plain text
#: build/C/man2/setup.2:72
msgid ""
"The calling sequence varied: at some times I<setup ()> has had a single "
"argument I<void\\ *BIOS> and at other times a single argument I<int magic>."
msgstr ""
"呼び出し手続きは変化してきた。 ある時は I<setup ()> は一つの引数 I<void\\ "
"*BIOS> を取っており、またある時には I<int magic> を一つの引数として取ってい"
"た。"

#. type: TH
#: build/C/man5/shells.5:28
#, no-wrap
msgid "SHELLS"
msgstr "SHELLS"

#. type: Plain text
#: build/C/man5/shells.5:31
msgid "shells - pathnames of valid login shells"
msgstr "shells - ログインシェルとして有効なファイルのパス名"

#. type: Plain text
#: build/C/man5/shells.5:37
msgid ""
"I</etc/shells> is a text file which contains the full pathnames of valid "
"login shells.  This file is consulted by B<chsh>(1)  and available to be "
"queried by other programs."
msgstr ""
"I</etc/shells> はログインシェルとして有効なファイルのフルパスが書かれた テキ"
"ストファイルである。 B<chsh>(1)  はこのファイルを参照する。 他のプログラムも"
"このファイルを参照できる。"

#. type: Plain text
#: build/C/man5/shells.5:43
msgid ""
"Be aware that there are programs which consult this file to find out if a "
"user is a normal user; for example, FTP daemons traditionally disallow "
"access to users with shells not included in this file."
msgstr ""
"注意して欲しいのだが、プログラムによっては、 ユーザーが通常のユーザーかどうか"
"を判断する際に、このファイルの内容を参考にすることがある。例えば FTP デーモン"
"は、ログインシェルがこのファイルに書かれていないユーザーからのアクセスを許さ"
"ないのが以前から一般的である。"

#. type: Plain text
#: build/C/man5/shells.5:45
msgid "I</etc/shells>"
msgstr "I</etc/shells>"

#. type: Plain text
#: build/C/man5/shells.5:48
msgid "I</etc/shells> may contain the following paths:"
msgstr "I</etc/shells> には以下のようなパスが含まれているだろう。"

#. type: Plain text
#: build/C/man5/shells.5:51
msgid "I</bin/sh>"
msgstr "I</bin/sh>"

#. type: Plain text
#: build/C/man5/shells.5:53
msgid "I</bin/bash>"
msgstr "I</bin/bash>"

#. type: Plain text
#: build/C/man5/shells.5:55
msgid "I</bin/csh>"
msgstr "I</bin/csh>"

#. type: Plain text
#: build/C/man5/shells.5:59
msgid "B<chsh>(1), B<getusershell>(3)"
msgstr "B<chsh>(1), B<getusershell>(3)"

#. type: TH
#: build/C/man3/sleep.3:26
#, no-wrap
msgid "SLEEP"
msgstr "SLEEP"

#. type: TH
#: build/C/man3/sleep.3:26
#, no-wrap
msgid "2010-02-03"
msgstr "2010-02-03"

#. type: Plain text
#: build/C/man3/sleep.3:29
msgid "sleep - sleep for the specified number of seconds"
msgstr "sleep - 指定の秒数の間だけ休止する"

#. type: Plain text
#: build/C/man3/sleep.3:34
#, no-wrap
msgid "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"
msgstr "B<unsigned int sleep(unsigned int >I<seconds>B<);>\n"

#. type: Plain text
#: build/C/man3/sleep.3:40
msgid ""
"B<sleep>()  makes the calling thread sleep until I<seconds> seconds have "
"elapsed or a signal arrives which is not ignored."
msgstr ""
"B<sleep>()  は、呼び出したスレッドを I<seconds> 秒間または無視されないシグナ"
"ルが到着するまで休止する。"

#. type: Plain text
#: build/C/man3/sleep.3:44
msgid ""
"Zero if the requested time has elapsed, or the number of seconds left to "
"sleep, if the call was interrupted by a signal handler."
msgstr ""
"要求された時間が過ぎた場合はゼロを返す。 呼び出しがシグナルハンドラーに割り込"
"まれた場合は、 休止の残り時間を返す。"

#. type: Plain text
#: build/C/man3/sleep.3:55
msgid ""
"B<sleep>()  may be implemented using B<SIGALRM>; mixing calls to B<alarm>"
"(2)  and B<sleep>()  is a bad idea."
msgstr ""
"B<sleep>()  は B<SIGALRM> を用いて実装されている。そのため、 B<alarm>(2)  と "
"B<sleep>()  を混ぜて使用するのは、まずい考えである。"

#. type: Plain text
#: build/C/man3/sleep.3:61
msgid ""
"Using B<longjmp>(3)  from a signal handler or modifying the handling of "
"B<SIGALRM> while sleeping will cause undefined results."
msgstr ""
"休止中にシグナルハンドラーから B<longjmp>(3)  を使用することや B<SIGALRM> の"
"ハンドリングを変更することは、定義されていない結果を生む。"

#. type: Plain text
#: build/C/man3/sleep.3:66
msgid "B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"
msgstr "B<alarm>(2), B<nanosleep>(2), B<signal>(2), B<signal>(7)"

#. type: TH
#: build/C/man3/swab.3:31
#, no-wrap
msgid "SWAB"
msgstr "SWAB"

#. type: TH
#: build/C/man3/swab.3:31
#, no-wrap
msgid "2014-02-25"
msgstr "2014-02-25"

#. type: Plain text
#: build/C/man3/swab.3:34
msgid "swab - swap adjacent bytes"
msgstr "swab - 隣接するバイトを交換する"

#. type: Plain text
#: build/C/man3/swab.3:38
#, no-wrap
msgid ""
"B<#define _XOPEN_SOURCE>       /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
msgstr ""
"B<#define _XOPEN_SOURCE>       /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/swab.3:40
#, no-wrap
msgid "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"
msgstr "B<void swab(const void *>I<from>B<, void *>I<to>B<, ssize_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/swab.3:55
msgid ""
"The B<swab>()  function copies I<n> bytes from the array pointed to by "
"I<from> to the array pointed to by I<to>, exchanging adjacent even and odd "
"bytes.  This function is used to exchange data between machines that have "
"different low/high byte ordering."
msgstr ""
"B<swab>()  関数は、I<from> で指された配列から I<n> バイトを I<to> で指された"
"配列に、隣接した偶数/奇数バイトを交換しながらコピーする。 この関数は異なるバ"
"イトオーダーを持つマシン間でのデータ交換に 使用される。"

#. type: Plain text
#: build/C/man3/swab.3:68
msgid ""
"This function does nothing when I<n> is negative.  When I<n> is positive and "
"odd, it handles I<n-1> bytes as above, and does something unspecified with "
"the last byte.  (In other words, I<n> should be even.)"
msgstr ""
"I<n> が負の数の場合、この関数は何もしない。 I<n> が正でかつ奇数の場合、"
"I<n-1> バイトは上記の通り扱い、 最後のバイトについては未規定の動作をする (言"
"い換えれば、I<n> は偶数にするべきである)。"

#. type: Plain text
#: build/C/man3/swab.3:72
msgid "The B<swab>()  function returns no value."
msgstr "B<swab>()  関数は、値を返さない。"

#. type: Plain text
#: build/C/man3/swab.3:77
msgid "The B<swab>()  function is thread-safe."
msgstr "B<swab>() 関数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/swab.3:81
msgid "B<bstring>(3)"
msgstr "B<bstring>(3)"

#. type: TH
#: build/C/man2/swapon.2:37
#, no-wrap
msgid "SWAPON"
msgstr "SWAPON"

#. type: Plain text
#: build/C/man2/swapon.2:40
msgid "swapon, swapoff - start/stop swapping to file/device"
msgstr "swapon, swapoff - ファイル/デバイスへのスワップを開始/停止する"

#. type: Plain text
#: build/C/man2/swapon.2:44
msgid "B<#include E<lt>asm/page.hE<gt> /* to find PAGE_SIZE */>"
msgstr "B<#include E<lt>asm/page.hE<gt> /* PAGE_SIZE を見つけるため */>"

#. type: Plain text
#: build/C/man2/swapon.2:46
msgid "B<#include E<lt>sys/swap.hE<gt>>"
msgstr "B<#include E<lt>sys/swap.hE<gt>>"

#. type: Plain text
#: build/C/man2/swapon.2:48
msgid "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"
msgstr "B<int swapon(const char *>I<path>B<, int >I<swapflags>B<);>"

#. type: Plain text
#: build/C/man2/swapon.2:50
msgid "B<int swapoff(const char *>I<path>B<);>"
msgstr "B<int swapoff(const char *>I<path>B<);>"

#. type: Plain text
#: build/C/man2/swapon.2:57
msgid ""
"B<swapon>()  sets the swap area to the file or block device specified by "
"I<path>.  B<swapoff>()  stops swapping to the file or block device specified "
"by I<path>."
msgstr ""
"B<swapon>()  は I<path> で指定されたファイルやブロックデバイスにスワップ領域"
"を設定する。 B<swapoff>()  は I<path> で指定されたファイルやブロックデバイス"
"へのスワップを停止する。"

#. type: Plain text
#: build/C/man2/swapon.2:67
msgid ""
"If the B<SWAP_FLAG_PREFER> flag is specified in the B<swapon>()  "
"I<swapflags> argument, the new swap area will have a higher priority than "
"default.  The priority is encoded within I<swapflags> as:"
msgstr ""
"B<swapon>() の I<swapflags> 引き数に B<SWAP_FLAG_PREFER> フラグが指定された場"
"合、\n"
"新しいスワップ領域はデフォルトよりも高い優先度を持つ。\n"
"優先度は以下のように変換されて I<swapflags> に指定する。"

#. type: Plain text
#: build/C/man2/swapon.2:70
msgid "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>"
msgstr "I<(prio E<lt>E<lt> SWAP_FLAG_PRIO_SHIFT) & SWAP_FLAG_PRIO_MASK>"

#. type: Plain text
#: build/C/man2/swapon.2:82
msgid ""
"If the B<SWAP_FLAG_DISCARD> flag is specified in the B<swapon>()  "
"I<swapflags> argument, freed swap pages will be discarded before they are "
"reused, if the swap device supports the discard or trim operation.  (This "
"may improve performance on some Solid State Devices, but often it does "
"not.)  See also NOTES."
msgstr ""
"B<SWAP_FLAG_DISCARD> フラグが B<swapon>() の I<swapflags> 引き数に指定された"
"場合、\n"
"スワップデバイスが破棄 (discard) 操作や trim 操作をサポートしている場合に"
"は、\n"
"解放されたスワップページは再利用される前に破棄される\n"
"(これにより、SSD (Solid State Device) によっては性能が向上することがある"
"が、\n"
"たいていは性能の向上はない)。\n"
"「注意」も参照のこと。"

#. type: Plain text
#: build/C/man2/swapon.2:86
msgid ""
"These functions may be used only by a privileged process (one having the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""
"これらの関数は特権プロセス (B<CAP_SYS_ADMIN> ケーパビリティ (capability) を持"
"つプロセス) のみが使用できる。"

#. type: SS
#: build/C/man2/swapon.2:86
#, no-wrap
msgid "Priority"
msgstr "優先度"

#. type: Plain text
#: build/C/man2/swapon.2:91
msgid ""
"Each swap area has a priority, either high or low.  The default priority is "
"low.  Within the low-priority areas, newer areas are even lower priority "
"than older areas."
msgstr ""
"それぞれのスワップ領域は高 (high) と低 (low) のどちらかの優先度を持つ。 デ"
"フォルトの優先度は低である。 低い優先度の領域において、新しい領域は古い領域よ"
"りさらに低い 優先度を持つ。"

#. type: Plain text
#: build/C/man2/swapon.2:97
msgid ""
"All priorities set with I<swapflags> are high-priority, higher than "
"default.  They may have any nonnegative value chosen by the caller.  Higher "
"numbers mean higher priority."
msgstr ""
"I<swapflags> が設定されたものは全て高い優先度となり、デフォルトよりも高い優先"
"度を持つ。 使用者はそれらに負でない値が指定できる。 大きな数字は高い優先度を"
"意味する。"

#. type: Plain text
#: build/C/man2/swapon.2:105
msgid ""
"Swap pages are allocated from areas in priority order, highest priority "
"first.  For areas with different priorities, a higher-priority area is "
"exhausted before using a lower-priority area.  If two or more areas have the "
"same priority, and it is the highest priority available, pages are allocated "
"on a round-robin basis between them."
msgstr ""
"高い優先度の領域から順にスワップページとして使用される。 より低い優先度の領域"
"を使用する前により高い優先度の 領域を使い切る。もし二つ以上の領域が同じ優先度"
"を持ち、 使える中で一番高い優先度であれば、それらのページは間で ラウンドロビ"
"ン方式で配分される。"

#. type: Plain text
#: build/C/man2/swapon.2:108
msgid ""
"As of Linux 1.3.6, the kernel usually follows these rules, but there are "
"exceptions."
msgstr ""
"Linux 1.3.6 において、カーネルは通常はこれらの規則に従っている。 しかし例外も"
"存在している。"

#. type: Plain text
#: build/C/man2/swapon.2:121
msgid ""
"(for B<swapon>())  The specified I<path> is already being used as a swap "
"area."
msgstr ""
"(B<swapon>()  において) 指定された I<path> が既にスワップ領域として使用されて"
"いる。"

#. type: Plain text
#: build/C/man2/swapon.2:126
msgid ""
"The file I<path> exists, but refers neither to a regular file nor to a block "
"device;"
msgstr ""

#. type: Plain text
#: build/C/man2/swapon.2:131
msgid ""
"(B<swapon>())  The indicated path does not contain a valid swap signature or "
"resides on an in-memory filesystem such as tmpfs."
msgstr ""

#. type: TP
#: build/C/man2/swapon.2:131
#, no-wrap
msgid "B<EINVAL> (since Linux 3.4)"
msgstr "B<EINVAL> (Linux 3.4 以降)"

#. type: Plain text
#: build/C/man2/swapon.2:136
#, fuzzy
#| msgid "An invalid operation was specified in I<fd>."
msgid "(B<swapon>())  An invalid flag value was specified in I<flags>."
msgstr "I<fd> に無効な操作が指定された。"

#. type: Plain text
#: build/C/man2/swapon.2:141
#, fuzzy
#| msgid ""
#| "(for B<swapon>())  The specified I<path> is already being used as a swap "
#| "area."
msgid "(B<swapoff>())  I<path> is not currently a swap area."
msgstr ""
"(B<swapon>()  において) 指定された I<path> が既にスワップ領域として使用されて"
"いる。"

#. type: Plain text
#: build/C/man2/swapon.2:149
msgid "The file I<path> does not exist."
msgstr "ファイル I<path> が存在しない。"

#. type: Plain text
#: build/C/man2/swapon.2:152
msgid "The system has insufficient memory to start swapping."
msgstr "スワップを開始するのに十分なメモリーがシステムにない。"

#. type: Plain text
#: build/C/man2/swapon.2:159
msgid ""
"The caller does not have the B<CAP_SYS_ADMIN> capability.  Alternatively, "
"the maximum number of swap files are already in use; see NOTES below."
msgstr ""
"使用者が B<CAP_SYS_ADMIN> ケーパビリティを持っていない。 もしくは、最大数のス"
"ワップファイルがすでに使用されている (下記の「注意」の節を参照)。"

#. type: Plain text
#: build/C/man2/swapon.2:165
msgid ""
"These functions are Linux-specific and should not be used in programs "
"intended to be portable.  The second I<swapflags> argument was introduced in "
"Linux 1.3.2."
msgstr ""
"これらの関数は Linux 特有であり、移植を意図したプログラムでは 使用してはいけ"
"ない。 二番目の I<swapflags> 引き数は Linux 1.3.2 から導入された。"

#. type: Plain text
#: build/C/man2/swapon.2:168
msgid "The partition or path must be prepared with B<mkswap>(8)."
msgstr ""
"パーティションやパスは B<mkswap>(8)  によって準備されていなければならない。"

#. type: Plain text
#: build/C/man2/swapon.2:188
msgid ""
"There is an upper limit on the number of swap files that may be used, "
"defined by the kernel constant B<MAX_SWAPFILES>.  Before kernel 2.4.10, "
"B<MAX_SWAPFILES> has the value 8; since kernel 2.4.10, it has the value 32.  "
"Since kernel 2.6.18, the limit is decreased by 2 (thus: 30)  if the kernel "
"is built with the B<CONFIG_MIGRATION> option (which reserves two swap table "
"entries for the page migration features of B<mbind>(2)  and B<migrate_pages>"
"(2)).  Since kernel 2.6.32, the limit is further decreased by 1 if the "
"kernel is built with the B<CONFIG_MEMORY_FAILURE> option."
msgstr ""
"使用できるスワップファイルの数には上限があり、その上限は カーネル定数 "
"B<MAX_SWAPFILES> で定義される。 B<MAX_SWAPFILES> の値は、カーネル 2.4.10 より"
"前では 8、 カーネル 2.4.10 以降では 32 である。 カーネル 2.6.18 以降では、"
"カーネルが B<CONFIG_MIGRATION> オプションを有効にして作成された場合、 この上"
"限が 2 少ない値 (つまり 30) となる (このカーネルでは、 B<mbind>(2)  と "
"B<migrate_pages>(2)  のページマイグレーション機能用にスワップテーブルのエント"
"リーが 二つ予約される)。 カーネル 2.6.32 以降では、カーネルが "
"B<CONFIG_MEMORY_FAILURE> オプションを有効にして作成された場合、 この上限がさ"
"らに 1 少ない値となる。"

#.  To be precise: 2.6.35.5
#. type: Plain text
#: build/C/man2/swapon.2:199
msgid ""
"Discard of swap pages was introduced in kernel 2.6.29, then made conditional "
"on the B<SWAP_FLAG_DISCARD> flag in kernel 2.6.36, which still discards the "
"entire swap area when B<swapon>()  is called, even if that flag bit is not "
"set."
msgstr ""
"スワップページの破棄は、カーネル 2.6.29 で導入され、その後カーネル 2.6.36 "
"で\n"
"B<SWAP_FLAG_DISCARD> フラグが指定された場合にだけ実行されるようになったが、\n"
"今でも、このフラグビットが指定されていない場合であっても、\n"
"B<swapon> が呼び出された際にスワップ領域全体の破棄が行われる。"

#. type: Plain text
#: build/C/man2/swapon.2:203
msgid "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"
msgstr "B<mkswap>(8), B<swapoff>(8), B<swapon>(8)"

#. type: TH
#: build/C/man2/syscall.2:40
#, no-wrap
msgid "SYSCALL"
msgstr "SYSCALL"

#. type: TH
#: build/C/man2/syscall.2:40
#, no-wrap
msgid "2014-01-11"
msgstr "2014-01-11"

#. type: Plain text
#: build/C/man2/syscall.2:43
msgid "syscall - indirect system call"
msgstr "syscall - 間接システムコール"

#. type: Plain text
#: build/C/man2/syscall.2:48
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* For SYS_xxx definitions */\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>unistd.hE<gt>>\n"
"B<#include E<lt>sys/syscall.hE<gt>   >/* SYS_xxx の定義用 */\n"

#. type: Plain text
#: build/C/man2/syscall.2:50
#, no-wrap
msgid "B<int syscall(int >I<number>B<, ...);>\n"
msgstr "B<int syscall(int >I<number>B<, ...);>\n"

#. type: Plain text
#: build/C/man2/syscall.2:62
msgid ""
"B<syscall>()  is a small library function that invokes the system call whose "
"assembly language interface has the specified I<number> with the specified "
"arguments.  Employing B<syscall>()  is useful, for example, when invoking a "
"system call that has no wrapper function in the C library."
msgstr ""
"B<syscall>() は、システムコールを起動する小さなライブラリ関数で、 I<number> "
"で指定されたアセンブリ言語インターフェースのシステムコールを、指定された引き"
"数をつけて実行する。 B<syscall>() が役に立つのは、例えば C ライブラリにラッ"
"パー関数が存在しないシステムコールを呼び出したい場合である。"

#. type: Plain text
#: build/C/man2/syscall.2:69
msgid ""
"B<syscall>()  saves CPU registers before making the system call, restores "
"the registers upon return from the system call, and stores any error code "
"returned by the system call in B<errno>(3)  if an error occurs."
msgstr ""
"B<syscall>() は、システムコールを行う前に CPU レジスタを保存し、システムコー"
"ルから返った際にレジスタを復元し、エラーが発生した場合はシステムコールが返し"
"たエラーコードを B<errno>(3) に格納する。"

#. type: Plain text
#: build/C/man2/syscall.2:72
msgid ""
"Symbolic constants for system call numbers can be found in the header file "
"I<E<lt>sys/syscall.hE<gt>>."
msgstr ""
"システムコールのシンボル定数は、ヘッダファイル I<E<lt>sys/syscall.hE<gt>> に"
"書かれている。"

#. type: Plain text
#: build/C/man2/syscall.2:78
msgid ""
"The return value is defined by the system call being invoked.  In general, a "
"0 return value indicates success.  A -1 return value indicates an error, and "
"an error code is stored in I<errno>."
msgstr ""
"返り値は呼び出されたシステムコールによって定義される。 一般に、返り値 0 は成"
"功を表す。 -1 はエラーを表し、エラーコードは I<errno> に入れられる。"

#. type: Plain text
#: build/C/man2/syscall.2:82
msgid "B<syscall>()  first appeared in 4BSD."
msgstr "B<syscall>()  は 4BSD で最初に登場した。"

#. type: SS
#: build/C/man2/syscall.2:82
#, no-wrap
msgid "Architecture-specific requirements"
msgstr "アーキテクチャ固有の要件"

#. type: Plain text
#: build/C/man2/syscall.2:93
msgid ""
"Each architecture ABI has its own requirements on how system call arguments "
"are passed to the kernel.  For system calls that have a glibc wrapper (e.g., "
"most system calls), glibc handles the details of copying arguments to the "
"right registers in a manner suitable for the architecture.  However, when "
"using B<syscall>()  to make a system call, the caller might need to handle "
"architecture-dependent details; this requirement is most commonly "
"encountered on certain 32-bit architectures."
msgstr ""
"各アーキテクチャの ABI には、 システムコールの引き数のカーネルへの渡し方に関"
"する独自の要件がある。\n"
"(ほとんどのシステムコールのように) glibc ラッパー関数があるシステムコールで"
"は、 glibc が詳細を処理し、アーキテクチャに応じた方法で引き数が適切なレジスタ"
"にコピーされる。 しかし、 システムコールを呼び出すのに B<syscall>() を使う場"
"合には、 呼び出し側でアーキテクチャ依存の詳細を処理しなければならない場合があ"
"る。 これはいくつかの 32 ビットアーキテクチャでは非常によくあることだ。"

#. type: Plain text
#: build/C/man2/syscall.2:104
msgid ""
"For example, on the ARM architecture Embedded ABI (EABI), a 64-bit value (e."
"g., I<long long>)  must be aligned to an even register pair.  Thus, using "
"B<syscall>()  instead of the wrapper provided by glibc, the B<readahead>()  "
"system call would be invoked as follows on the ARM architecture with the "
"EABI:"
msgstr ""
"例えば、ARM アーキテクチャの Embedded ABI (EABI) では、 (I<long long> など"
"の) 64 ビット値は偶数番地のレジスタのペアに境界があっていなければならない。し"
"たがって、 glibc が提供するラッパー関数ではなく B<syscall>() を使う場合に"
"は、 B<readahead>() システムコールは ARM アーキテクチャの EABI では以下のよう"
"にして起動されることになる。"

#. type: Plain text
#: build/C/man2/syscall.2:111
#, no-wrap
msgid ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        count);\n"
msgstr ""
"syscall(SYS_readahead, fd, 0,\n"
"        (unsigned int) (offset E<gt>E<gt> 32),\n"
"        (unsigned int) (offset & 0xFFFFFFFF),\n"
"        count);\n"

#. type: Plain text
#: build/C/man2/syscall.2:125
msgid ""
"Since the offset argument is 64 bits, and the first argument (I<fd>)  is "
"passed in I<r0>, the caller must manually split and align the 64-bit value "
"so that it is passed in the I<r2>/I<r3> register pair.  That means inserting "
"a dummy value into I<r1> (the second argument of 0)."
msgstr ""
"オフセット引き数は 64 ビットで、最初の引き数 (I<fd>) は I<r0> で渡されるの"
"で、呼び出し側では手動で 64 ビット値を分割して境界を合わせて、 64 ビット値が "
"I<r2>/I<r3> レジスタペアで渡されるようにしなければならない。このため、 I<r1> "
"(2 番目の引数 0) としてダミー値を挿入している。"

#.  Mike Frysinger: this issue ends up forcing MIPS
#.  O32 to take 7 arguments to syscall()
#. type: Plain text
#: build/C/man2/syscall.2:130
msgid ""
"Similar issues can occur on MIPS with the O32 ABI, on PowerPC with the 32-"
"bit ABI, and on Xtensa."
msgstr ""
"同様のことが、 MIPS の O32 ABI、 PowerPC の 32 ビット ABI や Xtensa でも起こ"
"りうる。"

#. type: Plain text
#: build/C/man2/syscall.2:141
msgid ""
"The affected system calls are B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), and B<truncate64>(2)."
msgstr ""
"次のシステムコールに影響がある: B<fadvise64_64>(2), B<ftruncate64>(2), "
"B<posix_fadvise>(2), B<pread64>(2), B<pwrite64>(2), B<readahead>(2), "
"B<sync_file_range>(2), B<truncate64>(2)"

#. type: SS
#: build/C/man2/syscall.2:141
#, no-wrap
msgid "Architecture calling conventions"
msgstr "アーキテクチャ毎の呼び出し規約"

#. type: Plain text
#: build/C/man2/syscall.2:145
msgid ""
"Every architecture has its own way of invoking and passing arguments to the "
"kernel.  The details for various architectures are listed in the two tables "
"below."
msgstr ""
"各アーキテクチャには、それぞれ独自のシステムコール起動方法とカーネルへの引き"
"数の渡し方がある。 各種のアーキテクチャの詳細を以下の 2 つの表にまとめる。"

#. type: Plain text
#: build/C/man2/syscall.2:152
msgid ""
"The first table lists the instruction used to transition to kernel mode, "
"(which might not be the fastest or best way to transition to the kernel, so "
"you might have to refer to B<vdso>(7)), the register used to indicate the "
"system call number, and the register used to return the system call result."
msgstr "最初の表は、 カーネルモードに遷移するのに使用される命令、 システムコール番号を示すのに使用されるレジスタ、 システムコールの結果を返すのに使用されるレジスタの一覧である (なお、 ここに載っているカーネルモードに遷移するのに使用される命令は、 カーネルモードに遷移する最速や最善の方法でない場合もあるので、 B<vdso>(7) を参照する必要があるかもしれない)。"

#. type: tbl table
#: build/C/man2/syscall.2:157
#, no-wrap
msgid "arch/ABI\tinstruction\tsyscall #\tretval\tNotes\n"
msgstr "arch/ABI\tinstruction\tsyscall #\tretval\tNotes\n"

#. type: tbl table
#: build/C/man2/syscall.2:159
#, no-wrap
msgid "arm/OABI\tswi NR\t-\ta1\tNR is syscall #\n"
msgstr "arm/OABI\tswi NR\t-\ta1\tNR is syscall #\n"

#. type: tbl table
#: build/C/man2/syscall.2:160
#, no-wrap
msgid "arm/EABI\tswi 0x0\tr7\tr0\n"
msgstr "arm/EABI\tswi 0x0\tr7\tr0\n"

#. type: tbl table
#: build/C/man2/syscall.2:161
#, no-wrap
msgid "blackfin\texcpt 0x0\tP0\tR0\n"
msgstr "blackfin\texcpt 0x0\tP0\tR0\n"

#. type: tbl table
#: build/C/man2/syscall.2:162
#, no-wrap
msgid "i386\tint $0x80\teax\teax\n"
msgstr "i386\tint $0x80\teax\teax\n"

#. type: tbl table
#: build/C/man2/syscall.2:163
#, no-wrap
msgid "ia64\tbreak 0x100000\tr15\tr10/r8\tbool error/errno value\n"
msgstr "ia64\tbreak 0x100000\tr15\tr10/r8\tbool error/errno value\n"

#. type: tbl table
#: build/C/man2/syscall.2:164
#, no-wrap
msgid "parisc\tble 0x100(%sr2, %r0)\tr20\tr28\n"
msgstr "parisc\tble 0x100(%sr2, %r0)\tr20\tr28\n"

#. type: tbl table
#: build/C/man2/syscall.2:165
#, no-wrap
msgid "s390\tsvc 0\tr1\tr2\tNR may be passed directly with\n"
msgstr "s390\tsvc 0\tr1\tr2\tNR が 256 未満の場合 \"svc NR\" で\n"

#. type: tbl table
#: build/C/man2/syscall.2:166
#, no-wrap
msgid "s390x\tsvc 0\tr1\tr2\t\"svc NR\" if NR is less than 256\n"
msgstr "s390x\tsvc 0\tr1\tr2\tNR が直接渡される場合がある\n"

#. type: tbl table
#: build/C/man2/syscall.2:167
#, no-wrap
msgid "sparc/32\tt 0x10\tg1\to0\n"
msgstr "sparc/32\tt 0x10\tg1\to0\n"

#. type: tbl table
#: build/C/man2/syscall.2:168
#, no-wrap
msgid "sparc/64\tt 0x6d\tg1\to0\n"
msgstr "sparc/64\tt 0x6d\tg1\to0\n"

#. type: tbl table
#: build/C/man2/syscall.2:169
#, no-wrap
msgid "x86_64\tsyscall\trax\trax\n"
msgstr "x86_64\tsyscall\trax\trax\n"

#. type: Plain text
#: build/C/man2/syscall.2:177
msgid ""
"The second table shows the registers used to pass the system call arguments."
msgstr ""
"2 つ目の表は、システムコールの引き数を渡すのに使用されるレジスタの一覧であ"
"る。"

#. type: tbl table
#: build/C/man2/syscall.2:182
#, no-wrap
msgid "arch/ABI\targ1\targ2\targ3\targ4\targ5\targ6\targ7\n"
msgstr "arch/ABI\targ1\targ2\targ3\targ4\targ5\targ6\targ7\n"

#. type: tbl table
#: build/C/man2/syscall.2:184
#, no-wrap
msgid "arm/OABI\ta1\ta2\ta3\ta4\tv1\tv2\tv3\n"
msgstr "arm/OABI\ta1\ta2\ta3\ta4\tv1\tv2\tv3\n"

#. type: tbl table
#: build/C/man2/syscall.2:185
#, no-wrap
msgid "arm/EABI\tr0\tr1\tr2\tr3\tr4\tr5\tr6\n"
msgstr "arm/EABI\tr0\tr1\tr2\tr3\tr4\tr5\tr6\n"

#. type: tbl table
#: build/C/man2/syscall.2:186
#, no-wrap
msgid "blackfin\tR0\tR1\tR2\tR3\tR4\tR5\t-\n"
msgstr "blackfin\tR0\tR1\tR2\tR3\tR4\tR5\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:187
#, no-wrap
msgid "i386\tebx\tecx\tedx\tesi\tedi\tebp\t-\n"
msgstr "i386\tebx\tecx\tedx\tesi\tedi\tebp\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:188
#, no-wrap
msgid "ia64\tout0\tout1\tout2\tout3\tout4\tout5\t-\n"
msgstr "ia64\tout0\tout1\tout2\tout3\tout4\tout5\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:189
#, no-wrap
msgid "parisc\tr26\tr25\tr24\tr23\tr22\tr21\t-\n"
msgstr "parisc\tr26\tr25\tr24\tr23\tr22\tr21\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:190
#, no-wrap
msgid "s390\tr2\tr3\tr4\tr5\tr6\tr7\t-\n"
msgstr "s390\tr2\tr3\tr4\tr5\tr6\tr7\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:191
#, no-wrap
msgid "s390x\tr2\tr3\tr4\tr5\tr6\tr7\t-\n"
msgstr "s390x\tr2\tr3\tr4\tr5\tr6\tr7\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:192
#, no-wrap
msgid "sparc/32\to0\to1\to2\to3\to4\to5\t-\n"
msgstr "sparc/32\to0\to1\to2\to3\to4\to5\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:193
#, no-wrap
msgid "sparc/64\to0\to1\to2\to3\to4\to5\t-\n"
msgstr "sparc/64\to0\to1\to2\to3\to4\to5\t-\n"

#. type: tbl table
#: build/C/man2/syscall.2:194
#, no-wrap
msgid "x86_64\trdi\trsi\trdx\tr10\tr8\tr9\t-\n"
msgstr "x86_64\trdi\trsi\trdx\tr10\tr8\tr9\t-\n"

#. type: Plain text
#: build/C/man2/syscall.2:203
msgid ""
"Note that these tables don't cover the entire calling convention\\(emsome "
"architectures may indiscriminately clobber other registers not listed here."
msgstr ""
"これらの表にはすべての呼び出し規約が記載されているわけではない点に注意するこ"
"と \\(em アーキテクチャによっては、ここに記載されていない他のレジスタが見境な"
"く上書きされる場合もある。"

#. type: Plain text
#: build/C/man2/syscall.2:210
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"

#. type: Plain text
#: build/C/man2/syscall.2:215
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t tid;\n"

#. type: Plain text
#: build/C/man2/syscall.2:219
#, no-wrap
msgid ""
"    tid = syscall(SYS_gettid);\n"
"    tid = syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"
msgstr ""
"    tid = syscall(SYS_gettid);\n"
"    tid = syscall(SYS_tgkill, getpid(), tid, SIGHUP);\n"
"}\n"

#. type: Plain text
#: build/C/man2/syscall.2:225
msgid "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<vdso>(7)"
msgstr "B<_syscall>(2), B<intro>(2), B<syscalls>(2), B<vdso>(7)"

#. type: TH
#: build/C/man2/syscalls.2:31
#, no-wrap
msgid "SYSCALLS"
msgstr "SYSCALLS"

#. type: Plain text
#: build/C/man2/syscalls.2:34
msgid "syscalls - Linux system calls"
msgstr "syscalls - Linux のシステムコール"

#. type: Plain text
#: build/C/man2/syscalls.2:36
msgid "Linux system calls."
msgstr "Linux のシステムコール。"

#. type: Plain text
#: build/C/man2/syscalls.2:39
msgid ""
"The system call is the fundamental interface between an application and the "
"Linux kernel."
msgstr ""
"システムコールは、アプリケーションと Linux カーネルとの間の 基本的なインタ"
"フェースである。"

#. type: SS
#: build/C/man2/syscalls.2:39
#, no-wrap
msgid "System calls and library wrapper functions"
msgstr "システムコールとライブラリのラッパー関数"

#. type: Plain text
#: build/C/man2/syscalls.2:49
msgid ""
"System calls are generally not invoked directly, but rather via wrapper "
"functions in glibc (or perhaps some other library).  For details of direct "
"invocation of a system call, see B<intro>(2).  Often, but not always, the "
"name of the wrapper function is the same as the name of the system call that "
"it invokes.  For example, glibc contains a function B<truncate>()  which "
"invokes the underlying \"truncate\" system call."
msgstr ""
"システムコールは一般には直接起動されず、 glibc (や他の何らかのライブラリ)  経"
"由で起動される。 システムコールの直接起動については、詳細は B<intro>(2)  を参"
"照のこと。 いつもという訳ではないが、普通は、ラッパー関数の名前はその関数が起"
"動する システムコールの名前と同じである。 例えば、glibc には B<truncate>()  "
"という関数があり、この関数は \"truncate\" システムコールを起動する。"

#. type: Plain text
#: build/C/man2/syscalls.2:67
msgid ""
"Often the glibc wrapper function is quite thin, doing little work other than "
"copying arguments to the right registers before invoking the system call, "
"and then setting I<errno> appropriately after the system call has returned.  "
"(These are the same steps that are performed by B<syscall>(2), which can be "
"used to invoke system calls for which no wrapper function is provided.)  "
"Note: system calls indicate a failure by returning a negative error number "
"to the caller; when this happens, the wrapper function negates the returned "
"error number (to make it positive), copies it to I<errno>, and returns -1 to "
"the caller of the wrapper."
msgstr ""
"たいていの場合、glibc のラッパー関数はかなり簡単なもので、 システムコールを起"
"動する前に引き数を適切なレジスタにコピーし、 システムコールが返った後は "
"I<errno> を適切に設定する以外は、ほとんど処理を行わない (これらは、ラッパー関"
"数が提供されていない場合に システムコールを起動するのに使用する B<syscall>"
"(2)  により実行される処理と同じである)。 [注意] システムコールは失敗を示すの"
"に負のエラー番号を呼び出し元に返す。 失敗が起こった際には、ラッパー関数は返さ"
"れたエラー番号を反転して (正の値に変換し)、それを I<errno> にコピーし、ラッ"
"パー関数の呼び出し元に -1 を返す。"

#. type: Plain text
#: build/C/man2/syscalls.2:79
msgid ""
"Sometimes, however, the wrapper function does some extra work before "
"invoking the system call.  For example, nowadays there are (for reasons "
"described below) two related system calls, B<truncate>(2)  and B<truncate64>"
"(2), and the glibc B<truncate>()  wrapper function checks which of those "
"system calls are provided by the kernel and determines which should be "
"employed."
msgstr ""
"しかしながら、時には、ラッパー関数がシステムコールを起動する前に 何らかの追加"
"の処理を行う場合がある。 例えば、現在、 二つの関連するシステムコール "
"B<truncate>(2)  と B<truncate64>(2)  があり、glibc のラッパー関数 B<truncate>"
"()  は、カーネルがこれらのシステムコールのうちどちらを提供しているかをチェッ"
"クし、 どちらを採用するかを決定する。"

#. type: SS
#: build/C/man2/syscalls.2:79
#, no-wrap
msgid "System call list"
msgstr "システムコールのリスト"

#. type: Plain text
#: build/C/man2/syscalls.2:87
msgid ""
"Below is a list of the Linux system calls.  In the list, the I<Kernel> "
"column indicates the kernel version for those system calls that were new in "
"Linux 2.2, or have appeared since that kernel version.  Note the following "
"points:"
msgstr ""
"以下は Linux のシステムコールのリストである。 このリストで、 I<Kernel> の列"
"は、Linux 2.2 以降で登場したシステムコールが 登場したカーネルバージョンを示"
"す。 以下に詳細な説明を記す。"

#. type: Plain text
#: build/C/man2/syscalls.2:90
msgid ""
"Where no kernel version is indicated, the system call appeared in kernel 1.0 "
"or earlier."
msgstr ""
"カーネルバージョンがない場合、そのシステムコールは カーネル 1.0 もしくはそれ"
"以前に登場した。"

#. type: Plain text
#: build/C/man2/syscalls.2:96
msgid ""
"Where a system call is marked \"1.2\" this means the system call probably "
"appeared in a 1.1.x kernel version, and first appeared in a stable kernel "
"with 1.2.  (Development of the 1.2 kernel was initiated from a branch of "
"kernel 1.0.6 via the 1.1.x unstable kernel series.)"
msgstr ""
"システムコールに \"1.2\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 1.1.x のカーネルで登場し、 安定版のカーネルでは 1.2 で初めて登場し"
"たことを意味する。 (バージョン 1.2 のカーネルは、カーネル 1.0.6 から分岐し、 "
"バージョン 1.1.x の不安定版のカーネル系列として開発された。)"

#.  Was kernel 2.0 started from a branch of 1.2.10?
#.  At least from the timestamps of the tarballs of
#.  of 1.2.10 and 1.3.0, that's how it looks, but in
#.  fact the diff doesn't seem very clear, the
#.  1.3.0 .tar.bz is much bigger (2.0 MB) than the
#.  1.2.10 .tar.bz2 (1.8 MB), and AEB points out the
#.  timestamps of some files in 1.3.0 seem to be older
#.  than those in 1.2.10.  All of this suggests
#.  that there might not have been a clean branch point.
#. type: Plain text
#: build/C/man2/syscalls.2:112
msgid ""
"Where a system call is marked \"2.0\" this means the system call probably "
"appeared in a 1.3.x kernel version, and first appeared in a stable kernel "
"with 2.0.  (Development of the 2.0 kernel was initiated from a branch of "
"kernel 1.2.x, somewhere around 1.2.10, via the 1.3.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.0\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 1.3.x のカーネルで登場し、 安定版のカーネルでは 2.0 で初めて登場し"
"たことを意味する。 (バージョン 2.0 のカーネルは、バージョン 1.2.10 あたりの"
"カーネル 1.2.x から分岐し、バージョン 1.3.x の不安定版のカーネル系列として開"
"発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:118
msgid ""
"Where a system call is marked \"2.2\" this means the system call probably "
"appeared in a 2.1.x kernel version, and first appeared in a stable kernel "
"with 2.2.0.  (Development of the 2.2 kernel was initiated from a branch of "
"kernel 2.0.21 via the 2.1.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.2\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 2.1.x のカーネルで登場し、 安定版のカーネルでは 2.2.0 で初めて登場"
"したことを意味する。 (バージョン 2.2 のカーネルは、カーネル 2.0.21 から分岐"
"し、 バージョン 2.1.x の不安定版のカーネル系列として開発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:124
msgid ""
"Where a system call is marked \"2.4\" this means the system call probably "
"appeared in a 2.3.x kernel version, and first appeared in a stable kernel "
"with 2.4.0.  (Development of the 2.4 kernel was initiated from a branch of "
"kernel 2.2.8 via the 2.3.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.4\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 2.3.x のカーネルで登場し、 安定版のカーネルでは 2.4.0 で初めて登場"
"したことを意味する。 (バージョン 2.4 のカーネルは、カーネル 2.2.8 から分岐"
"し、 バージョン 2.3.x の不安定版のカーネル系列として開発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:130
msgid ""
"Where a system call is marked \"2.6\" this means the system call probably "
"appeared in a 2.5.x kernel version, and first appeared in a stable kernel "
"with 2.6.0.  (Development of kernel 2.6 was initiated from a branch of "
"kernel 2.4.15 via the 2.5.x unstable kernel series.)"
msgstr ""
"システムコールに \"2.6\" と書かれている場合、 そのシステムコールがおそらく"
"バージョン 2.5.x のカーネルで登場し、 安定版のカーネルでは 2.6.0 で初めて登場"
"したことを意味する。 (バージョン 2.6 のカーネルは、カーネル 2.4.15 から分岐"
"し、 バージョン 2.5.x の不安定版のカーネル系列として開発された。)"

#. type: Plain text
#: build/C/man2/syscalls.2:137
msgid ""
"Starting with kernel 2.6.0, the development model changed, and new system "
"calls may appear in each 2.6.x release.  In this case, the exact version "
"number where the system call appeared is shown.  This convention continues "
"with the 3.x kernel series, which followed on from kernel 2.6.39."
msgstr ""
"カーネル 2.6.0 から開発モデルは変更され、新しいシステムコールが\n"
"個々の 2.6.x のリリースでも登場するようになった。\n"
"その場合、このリストでは、システムコールが登場した\n"
"厳密なバージョン番号が記載されている。この慣習は、カーネル 2.6.39 の\n"
"後継となるバージョン 3.x 系列のカーネルでも継続されている。"

#. type: Plain text
#: build/C/man2/syscalls.2:145
msgid ""
"In some cases, a system call was added to a stable kernel series after it "
"branched from the previous stable kernel series, and then backported into "
"the earlier stable kernel series.  For example some system calls that "
"appeared in 2.6.x were also backported into a 2.4.x release after 2.4.15.  "
"When this is so, the version where the system call appeared in both of the "
"major kernel series is listed."
msgstr ""
"前の安定版カーネル系列から分岐した後に安定版カーネル系列にシステムコール が追"
"加された場合、以前の安定版カーネル系列にそのシステムコールが 移植 (backport) "
"されることがある。 例えば、2.6.x で登場したシステムコールのいくつかは、 "
"2.4.15 以降の 2.4.x リリースにも backport された。 この場合、システムコールが"
"登場したバージョンとして、 両方の安定版系列のバージョンが記載されている。"

#.  Looking at scripts/checksyscalls.sh in the kernel source is
#.  instructive about x86 specifics.
#. type: Plain text
#: build/C/man2/syscalls.2:152
msgid ""
"The list of system calls that are available as at kernel 3.9 (or in a few "
"cases only on older kernels) is as follows:"
msgstr ""
"カーネル 3.9 で利用可能なシステムコールのリストを以下に示す\n"
"(それ以前のカーネルでだけ利用可能なものも少数だが含まれる):"

#. type: tbl table
#: build/C/man2/syscalls.2:157
#, no-wrap
msgid "B<System call>\tB<Kernel>\tB<Notes>\n"
msgstr "B<System call>\tB<Kernel>\tB<Notes>\n"

#. type: tbl table
#: build/C/man2/syscalls.2:159
#, no-wrap
msgid "B<_llseek>(2)\t1.2\n"
msgstr "B<_llseek>(2)\t1.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:160
#, no-wrap
msgid "B<_newselect>(2)\t2.0\n"
msgstr "B<_newselect>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:161
#, no-wrap
msgid "B<_sysctl>(2)\t2.0\n"
msgstr "B<_sysctl>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:162
#, no-wrap
msgid "B<accept>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<accept>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:163
#, no-wrap
msgid "B<accept4>(2)\t2.6.28\n"
msgstr "B<accept4>(2)\t2.6.28\n"

#. type: tbl table
#: build/C/man2/syscalls.2:164
#, no-wrap
msgid "B<access>(2)\t1.0\n"
msgstr "B<access>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:165
#, no-wrap
msgid "B<acct>(2)\t1.0\n"
msgstr "B<acct>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:166
#, no-wrap
msgid "B<add_key>(2)\t2.6.11\n"
msgstr "B<add_key>(2)\t2.6.11\n"

#. type: tbl table
#: build/C/man2/syscalls.2:167
#, no-wrap
msgid "B<adjtimex>(2)\t1.0\n"
msgstr "B<adjtimex>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:168
#, no-wrap
msgid "B<alarm>(2)\t1.0\n"
msgstr "B<alarm>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:169
#, no-wrap
msgid "B<alloc_hugepages>(2)\t2.5.36\tRemoved in 2.5.44\n"
msgstr "B<alloc_hugepages>(2)\t2.5.36\t2.5.44 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:170
#, no-wrap
msgid "B<bdflush>(2)\t1.2\tT{\n"
msgstr "B<bdflush>(2)\t1.2\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:171
#, no-wrap
msgid "Deprecated (does nothing)\n"
msgstr "2.6 以降では非推奨\n"

#. type: tbl table
#: build/C/man2/syscalls.2:172 build/C/man2/syscalls.2:184
#: build/C/man2/syscalls.2:314 build/C/man2/syscalls.2:386
#: build/C/man2/syscalls.2:402 build/C/man2/syscalls.2:414
#, no-wrap
msgid ".br\n"
msgstr ".br\n"

#. type: tbl table
#: build/C/man2/syscalls.2:173
#, no-wrap
msgid "since 2.6\n"
msgstr "(何もしない)\n"

#. type: tbl table
#: build/C/man2/syscalls.2:174 build/C/man2/syscalls.2:186
#: build/C/man2/syscalls.2:316 build/C/man2/syscalls.2:388
#: build/C/man2/syscalls.2:404 build/C/man2/syscalls.2:416
#: build/C/man2/syscalls.2:544 build/C/man2/syscalls.2:589
#, no-wrap
msgid "T}\n"
msgstr "T}\n"

#. type: tbl table
#: build/C/man2/syscalls.2:175
#, no-wrap
msgid "B<bind>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<bind>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:176
#, no-wrap
msgid "B<brk>(2)\t1.0\n"
msgstr "B<brk>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:177
#, no-wrap
msgid "B<cacheflush>(2)\t1.2\tNot on x86\n"
msgstr "B<cacheflush>(2)\t1.2\tx86 にはない\n"

#. type: tbl table
#: build/C/man2/syscalls.2:178
#, no-wrap
msgid "B<capget>(2)\t2.2\n"
msgstr "B<capget>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:179
#, no-wrap
msgid "B<capset>(2)\t2.2\n"
msgstr "B<capset>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:180
#, no-wrap
msgid "B<chdir>(2)\t1.0\n"
msgstr "B<chdir>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:181
#, no-wrap
msgid "B<chmod>(2)\t1.0\n"
msgstr "B<chmod>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:182
#, no-wrap
msgid "B<chown>(2)\t2.2\tT{\n"
msgstr "B<chown>(2)\t2.2\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:183 build/C/man2/syscalls.2:313
#, no-wrap
msgid "See B<chown>(2) for\n"
msgstr "バージョン毎の詳細は\n"

#. type: tbl table
#: build/C/man2/syscalls.2:185 build/C/man2/syscalls.2:315
#, no-wrap
msgid "version details\n"
msgstr "B<chown>(2) を参照。\n"

#. type: tbl table
#: build/C/man2/syscalls.2:187
#, no-wrap
msgid "B<chown32>(2)\t2.4\n"
msgstr "B<chown32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:188
#, no-wrap
msgid "B<chroot>(2)\t1.0\n"
msgstr "B<chroot>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:189
#, no-wrap
msgid "B<clock_adjtime>(2)\t2.6.39\n"
msgstr "B<clock_adjtime>(2)\t2.6.39\n"

#. type: tbl table
#: build/C/man2/syscalls.2:190
#, no-wrap
msgid "B<clock_getres>(2)\t2.6\n"
msgstr "B<clock_getres>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:191
#, no-wrap
msgid "B<clock_gettime>(2)\t2.6\n"
msgstr "B<clock_gettime>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:192
#, no-wrap
msgid "B<clock_nanosleep>(2)\t2.6\n"
msgstr "B<clock_nanosleep>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:193
#, no-wrap
msgid "B<clock_settime>(2)\t2.6\n"
msgstr "B<clock_settime>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:194
#, no-wrap
msgid "B<clone>(2)\t1.0\n"
msgstr "B<clone>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:195
#, no-wrap
msgid "B<close>(2)\t1.0\n"
msgstr "B<close>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:196
#, no-wrap
msgid "B<connect>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<connect>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:197
#, no-wrap
msgid "B<creat>(2)\t1.0\n"
msgstr "B<creat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:198
#, no-wrap
msgid "B<create_module>(2)\t\tRemoved in 2.6\n"
msgstr "B<create_module>(2)\t\t2.6 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:199
#, no-wrap
msgid "B<delete_module>(2)\t1.0\n"
msgstr "B<delete_module>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:200
#, no-wrap
msgid "B<dup>(2)\t1.0\n"
msgstr "B<dup>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:201
#, no-wrap
msgid "B<dup2>(2)\t1.0\n"
msgstr "B<dup2>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:202
#, no-wrap
msgid "B<dup3>(2)\t2.6.27\n"
msgstr "B<dup3>(2)\t2.6.27\n"

#. type: tbl table
#: build/C/man2/syscalls.2:203
#, no-wrap
msgid "B<epoll_create>(2)\t2.6\n"
msgstr "B<epoll_create>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:204
#, no-wrap
msgid "B<epoll_create1>(2)\t2.6.27\n"
msgstr "B<epoll_create1>(2)\t2.6.27\n"

#. type: tbl table
#: build/C/man2/syscalls.2:205
#, no-wrap
msgid "B<epoll_ctl>(2)\t2.6\n"
msgstr "B<epoll_ctl>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:206
#, no-wrap
msgid "B<epoll_pwait>(2)\t2.6.19\n"
msgstr "B<epoll_pwait>(2)\t2.6.19\n"

#. type: tbl table
#: build/C/man2/syscalls.2:207
#, no-wrap
msgid "B<epoll_wait>(2)\t2.6\n"
msgstr "B<epoll_wait>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:208
#, no-wrap
msgid "B<eventfd>(2)\t2.6.22\n"
msgstr "B<eventfd>(2)\t2.6.22\n"

#. type: tbl table
#: build/C/man2/syscalls.2:209
#, no-wrap
msgid "B<eventfd2>(2)\t2.6.27\n"
msgstr "B<eventfd2>(2)\t2.6.27\n"

#. type: tbl table
#: build/C/man2/syscalls.2:210
#, no-wrap
msgid "B<execve>(2)\t1.0\n"
msgstr "B<execve>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:211
#, no-wrap
msgid "B<exit>(2)\t1.0\n"
msgstr "B<exit>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:212
#, no-wrap
msgid "B<exit_group>(2)\t2.6\n"
msgstr "B<exit_group>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:213
#, no-wrap
msgid "B<faccessat>(2)\t2.6.16\n"
msgstr "B<faccessat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:214
#, no-wrap
msgid "B<fadvise64>(2)\t2.6\n"
msgstr "B<fadvise64>(2)\t2.6\n"

#.  Implements \fBposix_fadvise\fP(2)
#. type: tbl table
#: build/C/man2/syscalls.2:216
#, no-wrap
msgid "B<fadvise64_64>(2)\t2.6\n"
msgstr "B<fadvise64_64>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:217
#, no-wrap
msgid "B<fallocate>(2)\t2.6.23\n"
msgstr "B<fallocate>(2)\t2.6.23\n"

#. type: tbl table
#: build/C/man2/syscalls.2:218
#, no-wrap
msgid "B<fanotify_init>(2)\t2.6.37\n"
msgstr "B<fanotify_init>(2)\t2.6.37\n"

#. type: tbl table
#: build/C/man2/syscalls.2:219
#, no-wrap
msgid "B<fanotify_mark>(2)\t2.6.37\n"
msgstr "B<fanotify_mark>(2)\t2.6.37\n"

#.  The fanotify calls were added in Linux 2.6.36,
#.  but disabled while the API was finalized.
#. type: tbl table
#: build/C/man2/syscalls.2:222
#, no-wrap
msgid "B<fchdir>(2)\t1.0\n"
msgstr "B<fchdir>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:223
#, no-wrap
msgid "B<fchmod>(2)\t1.0\n"
msgstr "B<fchmod>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:224
#, no-wrap
msgid "B<fchmodat>(2)\t2.6.16\n"
msgstr "B<fchmodat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:225
#, no-wrap
msgid "B<fchown>(2)\t1.0\n"
msgstr "B<fchown>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:226
#, no-wrap
msgid "B<fchown32>(2)\t2.4\n"
msgstr "B<fchown32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:227
#, no-wrap
msgid "B<fchownat>(2)\t2.6.16\n"
msgstr "B<fchownat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:228
#, no-wrap
msgid "B<fcntl>(2)\t1.0\n"
msgstr "B<fcntl>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:229
#, no-wrap
msgid "B<fcntl64>(2)\t2.4\n"
msgstr "B<fcntl64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:230
#, no-wrap
msgid "B<fdatasync>(2)\t2.0\n"
msgstr "B<fdatasync>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:231
#, no-wrap
msgid "B<fgetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<fgetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:232
#, no-wrap
msgid "B<finit_module>(2)\t3.8\n"
msgstr "B<finit_module>(2)\t3.8\n"

#. type: tbl table
#: build/C/man2/syscalls.2:233
#, no-wrap
msgid "B<flistxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<flistxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:234
#, no-wrap
msgid "B<flock>(2)\t2.0\n"
msgstr "B<flock>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:235
#, no-wrap
msgid "B<fork>(2)\t1.0\n"
msgstr "B<fork>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:236
#, no-wrap
msgid "B<free_hugepages>(2)\t2.5.36\tRemoved in 2.5.44\n"
msgstr "B<free_hugepages>(2)\t2.5.36\t2.5.44 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:237
#, no-wrap
msgid "B<fremovexattr>(2)\t2.6; 2.4.18\n"
msgstr "B<fremovexattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:238
#, no-wrap
msgid "B<fsetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<fsetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:239
#, no-wrap
msgid "B<fstat>(2)\t1.0\n"
msgstr "B<fstat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:240
#, no-wrap
msgid "B<fstat64>(2)\t2.4\n"
msgstr "B<fstat64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:241
#, no-wrap
msgid "B<fstatat64>(2)\t2.6.16\n"
msgstr "B<fstatat64>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:242
#, no-wrap
msgid "B<fstatfs>(2)\t1.0\n"
msgstr "B<fstatfs>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:243
#, no-wrap
msgid "B<fstatfs64>(2)\t2.6\n"
msgstr "B<fstatfs64>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:244
#, no-wrap
msgid "B<fsync>(2)\t1.0\t1.0\n"
msgstr "B<fsync>(2)\t1.0\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:245
#, no-wrap
msgid "B<ftruncate>(2)\t1.0\n"
msgstr "B<ftruncate>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:246
#, no-wrap
msgid "B<ftruncate64>(2)\t2.4\n"
msgstr "B<ftruncate64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:247
#, no-wrap
msgid "B<futex>(2)\t2.6\n"
msgstr "B<futex>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:248
#, no-wrap
msgid "B<futimesat>(2)\t2.6.16\n"
msgstr "B<futimesat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:249
#, no-wrap
msgid "B<get_kernel_syms>(2)\t\tRemoved in 2.6\n"
msgstr "B<get_kernel_syms>(2)\t\t2.6 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:250
#, no-wrap
msgid "B<get_mempolicy>(2)\t2.6.6\n"
msgstr "B<get_mempolicy>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:251
#, no-wrap
msgid "B<get_robust_list>(2)\t2.6.17\n"
msgstr "B<get_robust_list>(2)\t2.6.17\n"

#. type: tbl table
#: build/C/man2/syscalls.2:252
#, no-wrap
msgid "B<get_thread_area>(2)\t2.6\n"
msgstr "B<get_thread_area>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:253
#, no-wrap
msgid "B<getcpu>(2)\t2.6.19\n"
msgstr "B<getcpu>(2)\t2.6.19\n"

#. type: tbl table
#: build/C/man2/syscalls.2:254
#, no-wrap
msgid "B<getcwd>(2)\t2.2\n"
msgstr "B<getcwd>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:255
#, no-wrap
msgid "B<getdents>(2)\t2.0\n"
msgstr "B<getdents>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:256
#, no-wrap
msgid "B<getdents64>(2)\t2.4\n"
msgstr "B<getdents64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:257
#, no-wrap
msgid "B<getegid>(2)\t1.0\n"
msgstr "B<getegid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:258
#, no-wrap
msgid "B<getegid32>(2)\t2.4\n"
msgstr "B<getegid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:259
#, no-wrap
msgid "B<geteuid>(2)\t1.0\n"
msgstr "B<geteuid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:260
#, no-wrap
msgid "B<geteuid32>(2)\t2.4\n"
msgstr "B<geteuid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:261
#, no-wrap
msgid "B<getgid>(2)\t1.0\n"
msgstr "B<getgid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:262
#, no-wrap
msgid "B<getgid32>(2)\t2.4\n"
msgstr "B<getgid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:263
#, no-wrap
msgid "B<getgroups>(2)\t1.0\n"
msgstr "B<getgroups>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:264
#, no-wrap
msgid "B<getgroups32>(2)\t2.4\n"
msgstr "B<getgroups32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:265
#, no-wrap
msgid "B<getitimer>(2)\t1.0\n"
msgstr "B<getitimer>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:266
#, no-wrap
msgid "B<getpeername>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<getpeername>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:267
#, no-wrap
msgid "B<getpagesize>(2)\t2.0\tNot on x86\n"
msgstr "B<getpagesize>(2)\t2.0\tx86 にはない\n"

#. type: tbl table
#: build/C/man2/syscalls.2:268
#, no-wrap
msgid "B<getpgid>(2)\t1.0\n"
msgstr "B<getpgid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:269
#, no-wrap
msgid "B<getpgrp>(2)\t1.0\n"
msgstr "B<getpgrp>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:270
#, no-wrap
msgid "B<getpid>(2)\t1.0\n"
msgstr "B<getpid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:271
#, no-wrap
msgid "B<getppid>(2)\t1.0\n"
msgstr "B<getppid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:272
#, no-wrap
msgid "B<getpriority>(2)\t1.0\n"
msgstr "B<getpriority>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:273
#, no-wrap
msgid "B<getresgid>(2)\t2.2\n"
msgstr "B<getresgid>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:274
#, no-wrap
msgid "B<getresgid32>(2)\t2.4\n"
msgstr "B<getresgid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:275
#, no-wrap
msgid "B<getresuid>(2)\t2.2\n"
msgstr "B<getresuid>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:276
#, no-wrap
msgid "B<getresuid32>(2)\t2.4\n"
msgstr "B<getresuid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:277
#, no-wrap
msgid "B<getrlimit>(2)\t1.0\n"
msgstr "B<getrlimit>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:278
#, no-wrap
msgid "B<getrusage>(2)\t1.0\n"
msgstr "B<getrusage>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:279
#, no-wrap
msgid "B<getsid>(2)\t2.0\n"
msgstr "B<getsid>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:280
#, no-wrap
msgid "B<getsockname>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<getsockname>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:281
#, no-wrap
msgid "B<getsockopt>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<getsockopt>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:282
#, no-wrap
msgid "B<gettid>(2)\t2.4.11\n"
msgstr "B<gettid>(2)\t2.4.11\n"

#. type: tbl table
#: build/C/man2/syscalls.2:283
#, no-wrap
msgid "B<gettimeofday>(2)\t1.0\n"
msgstr "B<gettimeofday>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:284
#, no-wrap
msgid "B<getuid>(2)\t1.0\n"
msgstr "B<getuid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:285
#, no-wrap
msgid "B<getuid32>(2)\t2.4\n"
msgstr "B<getuid32>(2)\t2.4\n"

#.  \fBgetunwind\fP(2)	2.4.8	ia64; DEPRECATED
#. type: tbl table
#: build/C/man2/syscalls.2:287
#, no-wrap
msgid "B<getxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<getxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:288
#, no-wrap
msgid "B<init_module>(2)\t1.0\n"
msgstr "B<init_module>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:289
#, no-wrap
msgid "B<inotify_add_watch>(2)\t2.6.13\n"
msgstr "B<inotify_add_watch>(2)\t2.6.13\n"

#. type: tbl table
#: build/C/man2/syscalls.2:290
#, no-wrap
msgid "B<inotify_init>(2)\t2.6.13\n"
msgstr "B<inotify_init>(2)\t2.6.13\n"

#. type: tbl table
#: build/C/man2/syscalls.2:291
#, no-wrap
msgid "B<inotify_init1>(2)\t2.6.27\n"
msgstr "B<inotify_init1>(2)\t2.6.27\n"

#. type: tbl table
#: build/C/man2/syscalls.2:292
#, no-wrap
msgid "B<inotify_rm_watch>(2)\t2.6.13\n"
msgstr "B<inotify_rm_watch>(2)\t2.6.13\n"

#. type: tbl table
#: build/C/man2/syscalls.2:293
#, no-wrap
msgid "B<io_cancel>(2)\t2.6\n"
msgstr "B<io_cancel>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:294
#, no-wrap
msgid "B<io_destroy>(2)\t2.6\n"
msgstr "B<io_destroy>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:295
#, no-wrap
msgid "B<io_getevents>(2)\t2.6\n"
msgstr "B<io_getevents>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:296
#, no-wrap
msgid "B<io_setup>(2)\t2.6\n"
msgstr "B<io_setup>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:297
#, no-wrap
msgid "B<io_submit>(2)\t2.6\n"
msgstr "B<io_submit>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:298
#, no-wrap
msgid "B<ioctl>(2)\t1.0\n"
msgstr "B<ioctl>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:299
#, no-wrap
msgid "B<ioperm>(2)\t1.0\n"
msgstr "B<ioperm>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:300
#, no-wrap
msgid "B<iopl>(2)\t1.0\n"
msgstr "B<iopl>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:301
#, no-wrap
msgid "B<ioprio_get>(2)\t2.6.13\n"
msgstr "B<ioprio_get>(2)\t2.6.13\n"

#. type: tbl table
#: build/C/man2/syscalls.2:302
#, no-wrap
msgid "B<ioprio_set>(2)\t2.6.13\n"
msgstr "B<ioprio_set>(2)\t2.6.13\n"

#. type: tbl table
#: build/C/man2/syscalls.2:303
#, no-wrap
msgid "B<ipc>(2)\t1.0\n"
msgstr "B<ipc>(2)\t1.0\n"

#.  Implements System V IPC calls
#. type: tbl table
#: build/C/man2/syscalls.2:305
#, no-wrap
msgid "B<kcmp>(2)\t3.5\n"
msgstr "B<kcmp>(2)\t3.5\n"

#. type: tbl table
#: build/C/man2/syscalls.2:306
#, no-wrap
msgid "B<kern_features>(2)\t3.7\tSparc64\n"
msgstr "B<kern_features>(2)\t3.7\tSparc64\n"

#. type: tbl table
#: build/C/man2/syscalls.2:307
#, no-wrap
msgid "B<kexec_load>(2)\t2.6.13\n"
msgstr "B<kexec_load>(2)\t2.6.13\n"

#.  The entry in the syscall table was reserved starting in 2.6.7
#.  Was named sys_kexec_load() from 2.6.7 to 2.6.16
#. type: tbl table
#: build/C/man2/syscalls.2:310
#, no-wrap
msgid "B<keyctl>(2)\t2.6.11\n"
msgstr "B<keyctl>(2)\t2.6.11\n"

#. type: tbl table
#: build/C/man2/syscalls.2:311
#, no-wrap
msgid "B<kill>(2)\t1.0\n"
msgstr "B<kill>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:312
#, no-wrap
msgid "B<lchown>(2)\t1.0\tT{\n"
msgstr "B<lchown>(2)\t1.0\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:317
#, no-wrap
msgid "B<lchown32>(2)\t2.4\n"
msgstr "B<lchown32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:318
#, no-wrap
msgid "B<lgetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<lgetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:319
#, no-wrap
msgid "B<link>(2)\t1.0\n"
msgstr "B<link>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:320
#, no-wrap
msgid "B<linkat>(2)\t2.6.16\n"
msgstr "B<linkat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:321
#, no-wrap
msgid "B<listen>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<listen>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:322
#, no-wrap
msgid "B<listxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<listxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:323
#, no-wrap
msgid "B<llistxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<llistxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:324
#, no-wrap
msgid "B<lookup_dcookie>(2)\t2.6\n"
msgstr "B<lookup_dcookie>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:325
#, no-wrap
msgid "B<lremovexattr>(2)\t2.6; 2.4.18\n"
msgstr "B<lremovexattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:326
#, no-wrap
msgid "B<lseek>(2)\t1.0\n"
msgstr "B<lseek>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:327
#, no-wrap
msgid "B<lsetxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<lsetxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:328
#, no-wrap
msgid "B<lstat>(2)\t1.0\n"
msgstr "B<lstat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:329
#, no-wrap
msgid "B<lstat64>(2)\t2.4\n"
msgstr "B<lstat64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:330
#, no-wrap
msgid "B<madvise>(2)\t2.4\n"
msgstr "B<madvise>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:331
#, no-wrap
msgid "B<mbind>(2)\t2.6.6\n"
msgstr "B<mbind>(2)\t2.6.6\n"

#.  \fBmemory_ordering\fP(2)	???	Sparc64
#. type: tbl table
#: build/C/man2/syscalls.2:333
#, no-wrap
msgid "B<migrate_pages>(2)\t2.6.16\n"
msgstr "B<migrate_pages>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:334
#, no-wrap
msgid "B<mincore>(2)\t2.4\n"
msgstr "B<mincore>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:335
#, no-wrap
msgid "B<mkdir>(2)\t1.0\n"
msgstr "B<mkdir>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:336
#, no-wrap
msgid "B<mkdirat>(2)\t2.6.16\n"
msgstr "B<mkdirat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:337
#, no-wrap
msgid "B<mknod>(2)\t1.0\n"
msgstr "B<mknod>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:338
#, no-wrap
msgid "B<mknodat>(2)\t2.6.16\n"
msgstr "B<mknodat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:339
#, no-wrap
msgid "B<mlock>(2)\t2.0\n"
msgstr "B<mlock>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:340
#, no-wrap
msgid "B<mlockall>(2)\t2.0\n"
msgstr "B<mlockall>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:341
#, no-wrap
msgid "B<mmap>(2)\t1.0\n"
msgstr "B<mmap>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:342
#, no-wrap
msgid "B<mmap2>(2)\t2.4\n"
msgstr "B<mmap2>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:343
#, no-wrap
msgid "B<modify_ldt>(2)\t1.0\n"
msgstr "B<modify_ldt>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:344
#, no-wrap
msgid "B<mount>(2)\t1.0\n"
msgstr "B<mount>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:345
#, no-wrap
msgid "B<move_pages>(2)\t2.6.18\n"
msgstr "B<move_pages>(2)\t2.6.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:346
#, no-wrap
msgid "B<mprotect>(2)\t1.0\n"
msgstr "B<mprotect>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:347
#, no-wrap
msgid "B<mq_getsetattr>(2)\t2.6.6\n"
msgstr "B<mq_getsetattr>(2)\t2.6.6\n"

#.  Implements \fBmq_getattr\fP(3) and \fBmq_setattr\fP(3)
#. type: tbl table
#: build/C/man2/syscalls.2:349
#, no-wrap
msgid "B<mq_notify>(2)\t2.6.6\n"
msgstr "B<mq_notify>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:350
#, no-wrap
msgid "B<mq_open>(2)\t2.6.6\n"
msgstr "B<mq_open>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:351
#, no-wrap
msgid "B<mq_timedreceive>(2)\t2.6.6\n"
msgstr "B<mq_timedreceive>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:352
#, no-wrap
msgid "B<mq_timedsend>(2)\t2.6.6\n"
msgstr "B<mq_timedsend>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:353
#, no-wrap
msgid "B<mq_unlink>(2)\t2.6.6\n"
msgstr "B<mq_unlink>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:354
#, no-wrap
msgid "B<mremap>(2)\t2.0\n"
msgstr "B<mremap>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:355
#, no-wrap
msgid "B<msgctl>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgctl>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:356
#, no-wrap
msgid "B<msgget>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgget>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:357
#, no-wrap
msgid "B<msgrcv>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgrcv>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:358
#, no-wrap
msgid "B<msgsnd>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<msgsnd>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:359
#, no-wrap
msgid "B<msync>(2)\t2.0\n"
msgstr "B<msync>(2)\t2.0\n"

#.  \fBmultiplexer\fP(2)	??	__NR_multiplexer reserved on
#. 		PowerPC, but unimplemented?
#. type: tbl table
#: build/C/man2/syscalls.2:362
#, no-wrap
msgid "B<munlock>(2)\t2.0\n"
msgstr "B<munlock>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:363
#, no-wrap
msgid "B<munlockall>(2)\t2.0\n"
msgstr "B<munlockall>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:364
#, no-wrap
msgid "B<munmap>(2)\t1.0\n"
msgstr "B<munmap>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:365
#, no-wrap
msgid "B<name_to_handle_at>(2)\t2.6.39\n"
msgstr "B<name_to_handle_at>(2)\t2.6.39\n"

#. type: tbl table
#: build/C/man2/syscalls.2:366
#, no-wrap
msgid "B<nanosleep>(2)\t2.0\n"
msgstr "B<nanosleep>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:367
#, no-wrap
msgid "B<nfsservctl>(2)\t2.2\tRemoved in 3.1\n"
msgstr "B<nfsservctl>(2)\t2.2\t3.1 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:368
#, no-wrap
msgid "B<nice>(2)\t1.0\n"
msgstr "B<nice>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:369
#, no-wrap
msgid "B<oldfstat>(2)\t1.0\n"
msgstr "B<oldfstat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:370
#, no-wrap
msgid "B<oldlstat>(2)\t1.0\n"
msgstr "B<oldlstat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:371
#, no-wrap
msgid "B<oldolduname>(2)\t1.0\n"
msgstr "B<oldolduname>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:372
#, no-wrap
msgid "B<oldstat>(2)\t1.0\n"
msgstr "B<oldstat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:373
#, no-wrap
msgid "B<olduname>(2)\t1.0\n"
msgstr "B<olduname>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:374
#, no-wrap
msgid "B<open>(2)\t1.0\n"
msgstr "B<open>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:375
#, no-wrap
msgid "B<open_by_handle_at>(2)\t2.6.39\n"
msgstr "B<open_by_handle_at>(2)\t2.6.39\n"

#. type: tbl table
#: build/C/man2/syscalls.2:376
#, no-wrap
msgid "B<openat>(2)\t2.6.16\n"
msgstr "B<openat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:377
#, no-wrap
msgid "B<pause>(2)\t1.0\n"
msgstr "B<pause>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:378
#, no-wrap
msgid "B<pciconfig_iobase>(2)\t2.2.15; 2.4\tNot on x86\n"
msgstr "B<pciconfig_iobase>(2)\t2.2.15; 2.4\tx86 にはない\n"

#.  Alpha, PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:380
#, no-wrap
msgid "B<pciconfig_read>(2)\t2.0.26; 2.2\tNot on x86\n"
msgstr "B<pciconfig_read>(2)\t2.0.26; 2.2\tx86 にはない\n"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:382
#, no-wrap
msgid "B<pciconfig_write>(2)\t2.0.26; 2.2\tNot on x86\n"
msgstr "B<pciconfig_write>(2)\t2.0.26; 2.2\tx86 にはない\n"

#.  , PowerPC, ARM; not x86
#. type: tbl table
#: build/C/man2/syscalls.2:384
#, no-wrap
msgid "B<perf_event_open>(2)\t2.6.31\tT{\n"
msgstr "B<perf_event_open>(2)\t2.6.31\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:385
#, no-wrap
msgid "Was called perf_counter_open()\n"
msgstr "2.6.31 では perf_counter_open() という\n"

#. type: tbl table
#: build/C/man2/syscalls.2:387
#, no-wrap
msgid "in 2.6.31; renamed in 2.6.32\n"
msgstr "名前であった; 2.6.32 で名称変更\n"

#. type: tbl table
#: build/C/man2/syscalls.2:389
#, no-wrap
msgid "B<personality>(2)\t1.2\n"
msgstr "B<personality>(2)\t1.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:390
#, no-wrap
msgid "B<perfctr>(2)\t2.2\tSparc; removed in 2.6.34\n"
msgstr "B<perfctr>(2)\t2.2\tSparc; 2.6.34 で削除\n"

#. 	commit c7d5a0050773e98d1094eaa9f2a1a793fafac300 removed perfctr()
#. type: tbl table
#: build/C/man2/syscalls.2:392
#, no-wrap
msgid "B<perfmonctl>(2)\t2.4\tia64\n"
msgstr "B<perfmonctl>(2)\t2.4\tia64\n"

#. type: tbl table
#: build/C/man2/syscalls.2:393
#, no-wrap
msgid "B<pipe>(2)\t1.0\n"
msgstr "B<pipe>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:394
#, no-wrap
msgid "B<pipe2>(2)\t2.6.27\n"
msgstr "B<pipe2>(2)\t2.6.27\n"

#. type: tbl table
#: build/C/man2/syscalls.2:395
#, no-wrap
msgid "B<pivot_root>(2)\t2.4\n"
msgstr "B<pivot_root>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:396
#, no-wrap
msgid "B<poll>(2)\t2.0.36; 2.2\n"
msgstr "B<poll>(2)\t2.0.36; 2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:397
#, no-wrap
msgid "B<ppc_rtas>(2)\t\tPowerPC only\n"
msgstr "B<ppc_rtas>(2)\t\tPowerPC のみ\n"

#. type: tbl table
#: build/C/man2/syscalls.2:398
#, no-wrap
msgid "B<ppoll>(2)\t2.6.16\n"
msgstr "B<ppoll>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:399
#, no-wrap
msgid "B<prctl>(2)\t2.2\n"
msgstr "B<prctl>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:400
#, no-wrap
msgid "B<pread64>(2)\t\tT{\n"
msgstr "B<pread64>(2)\t\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:401
#, no-wrap
msgid "Added as \"pread\" in 2.2;\n"
msgstr "2.2 で \"pread\" として追加;\n"

#. type: tbl table
#: build/C/man2/syscalls.2:403
#, no-wrap
msgid "renamed \"pread64\" in 2.6\n"
msgstr "2.6 で \"pread64\" に名称変更\n"

#. type: tbl table
#: build/C/man2/syscalls.2:405
#, no-wrap
msgid "B<preadv>(2)\t2.6.30\n"
msgstr "B<preadv>(2)\t2.6.30\n"

#. type: tbl table
#: build/C/man2/syscalls.2:406
#, no-wrap
msgid "B<prlimit>(2)\t2.6.36\n"
msgstr "B<prlimit>(2)\t2.6.36\n"

#. type: tbl table
#: build/C/man2/syscalls.2:407
#, no-wrap
msgid "B<process_vm_readv>(2)\t3.2\n"
msgstr "B<process_vm_readv>(2)\t3.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:408
#, no-wrap
msgid "B<process_vm_writev>(2)\t3.2\n"
msgstr "B<process_vm_writev>(2)\t3.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:409
#, no-wrap
msgid "B<pselect6>(2)\t2.6.16\n"
msgstr "B<pselect6>(2)\t2.6.16\n"

#.  Implements \fBpselect\fP(2)
#. type: tbl table
#: build/C/man2/syscalls.2:411
#, no-wrap
msgid "B<ptrace>(2)\t1.0\n"
msgstr "B<ptrace>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:412
#, no-wrap
msgid "B<pwrite64>(2)\t\tT{\n"
msgstr "B<pwrite64>(2)\t\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:413
#, no-wrap
msgid "Added as \"pwrite\" in 2.2;\n"
msgstr "2.2 で \"pwrite\" として追加;\n"

#. type: tbl table
#: build/C/man2/syscalls.2:415
#, no-wrap
msgid "renamed \"pwrite64\" in 2.6\n"
msgstr "2.6 で \"pwrite64\" に名称変更\n"

#. type: tbl table
#: build/C/man2/syscalls.2:417
#, no-wrap
msgid "B<pwritev>(2)\t2.6.30\n"
msgstr "B<pwritev>(2)\t2.6.30\n"

#. type: tbl table
#: build/C/man2/syscalls.2:418
#, no-wrap
msgid "B<query_module>(2)\t2.2\tRemoved in 2.6\n"
msgstr "B<query_module>(2)\t2.2\t2.6 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:419
#, no-wrap
msgid "B<quotactl>(2)\t1.0\n"
msgstr "B<quotactl>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:420
#, no-wrap
msgid "B<read>(2)\t1.0\n"
msgstr "B<read>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:421
#, no-wrap
msgid "B<readahead>(2)\t2.4.13\n"
msgstr "B<readahead>(2)\t2.4.13\n"

#. type: tbl table
#: build/C/man2/syscalls.2:422
#, no-wrap
msgid "B<readdir>(2)\t1.0\n"
msgstr "B<readdir>(2)\t1.0\n"

#.  Supersedes \fBgetdents\fP(2)
#. type: tbl table
#: build/C/man2/syscalls.2:424
#, no-wrap
msgid "B<readlink>(2)\t1.0\n"
msgstr "B<readlink>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:425
#, no-wrap
msgid "B<readlinkat>(2)\t2.6.16\n"
msgstr "B<readlinkat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:426
#, no-wrap
msgid "B<readv>(2)\t2.0\n"
msgstr "B<readv>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:427
#, no-wrap
msgid "B<reboot>(2)\t1.0\n"
msgstr "B<reboot>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:428
#, no-wrap
msgid "B<recv>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<recv>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:429
#, no-wrap
msgid "B<recvfrom>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<recvfrom>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:430
#, no-wrap
msgid "B<recvmsg>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<recvmsg>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:431
#, no-wrap
msgid "B<recvmmsg>(2)\t2.6.33\n"
msgstr "B<recvmmsg>(2)\t2.6.33\n"

#. type: tbl table
#: build/C/man2/syscalls.2:432
#, no-wrap
msgid "B<remap_file_pages>(2)\t2.6\n"
msgstr "B<remap_file_pages>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:433
#, no-wrap
msgid "B<removexattr>(2)\t2.6; 2.4.18\n"
msgstr "B<removexattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:434
#, no-wrap
msgid "B<rename>(2)\t1.0\n"
msgstr "B<rename>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:435
#, no-wrap
msgid "B<renameat>(2)\t2.6.16\n"
msgstr "B<renameat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:436
#, no-wrap
msgid "B<request_key>(2)\t2.6.11\n"
msgstr "B<request_key>(2)\t2.6.11\n"

#. type: tbl table
#: build/C/man2/syscalls.2:437
#, no-wrap
msgid "B<restart_syscall>(2)\t2.6\n"
msgstr "B<restart_syscall>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:438
#, no-wrap
msgid "B<rmdir>(2)\t1.0\n"
msgstr "B<rmdir>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:439
#, no-wrap
msgid "B<rt_sigaction>(2)\t2.2\n"
msgstr "B<rt_sigaction>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:440
#, no-wrap
msgid "B<rt_sigpending>(2)\t2.2\n"
msgstr "B<rt_sigpending>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:441
#, no-wrap
msgid "B<rt_sigprocmask>(2)\t2.2\n"
msgstr "B<rt_sigprocmask>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:442
#, no-wrap
msgid "B<rt_sigqueueinfo>(2)\t2.2\n"
msgstr "B<rt_sigqueueinfo>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:443
#, no-wrap
msgid "B<rt_sigreturn>(2)\t2.2\n"
msgstr "B<rt_sigreturn>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:444
#, no-wrap
msgid "B<rt_sigsuspend>(2)\t2.2\n"
msgstr "B<rt_sigsuspend>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:445
#, no-wrap
msgid "B<rt_sigtimedwait>(2)\t2.2\n"
msgstr "B<rt_sigtimedwait>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:446
#, no-wrap
msgid "B<rt_tgsigqueueinfo>(2)\t2.6.31\n"
msgstr "B<rt_tgsigqueueinfo>(2)\t2.6.31\n"

#. type: tbl table
#: build/C/man2/syscalls.2:447
#, no-wrap
msgid "B<s390_runtime_instr>(2)\t3.7\ts390 only\n"
msgstr "B<s390_runtime_instr>(2)\t3.7\ts390 のみ\n"

#. type: tbl table
#: build/C/man2/syscalls.2:448
#, no-wrap
msgid "B<sched_get_priority_max>(2)\t2.0\n"
msgstr "B<sched_get_priority_max>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:449
#, no-wrap
msgid "B<sched_get_priority_min>(2)\t2.0\n"
msgstr "B<sched_get_priority_min>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:450
#, no-wrap
msgid "B<sched_getaffinity>(2)\t2.6\n"
msgstr "B<sched_getaffinity>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:451
#, no-wrap
msgid "B<sched_getparam>(2)\t2.0\n"
msgstr "B<sched_getparam>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:452
#, no-wrap
msgid "B<sched_getscheduler>(2)\t2.0\n"
msgstr "B<sched_getscheduler>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:453
#, no-wrap
msgid "B<sched_rr_get_interval>(2)\t2.0\n"
msgstr "B<sched_rr_get_interval>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:454
#, no-wrap
msgid "B<sched_setaffinity>(2)\t2.6\n"
msgstr "B<sched_setaffinity>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:455
#, no-wrap
msgid "B<sched_setparam>(2)\t2.0\n"
msgstr "B<sched_setparam>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:456
#, no-wrap
msgid "B<sched_setscheduler>(2)\t2.0\n"
msgstr "B<sched_setscheduler>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:457
#, no-wrap
msgid "B<sched_yield>(2)\t2.0\n"
msgstr "B<sched_yield>(2)\t2.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:458
#, no-wrap
msgid "B<select>(2)\t1.0\n"
msgstr "B<select>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:459
#, no-wrap
msgid "B<semctl>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<semctl>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:460
#, no-wrap
msgid "B<semget>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<semget>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:461
#, no-wrap
msgid "B<semop>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<semop>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:462
#, no-wrap
msgid "B<semtimedop>(2)\t2.6; 2.4.22\n"
msgstr "B<semtimedop>(2)\t2.6; 2.4.22\n"

#. type: tbl table
#: build/C/man2/syscalls.2:463
#, no-wrap
msgid "B<send>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<send>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:464
#, no-wrap
msgid "B<sendfile>(2)\t2.2\n"
msgstr "B<sendfile>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:465
#, no-wrap
msgid "B<sendfile64>(2)\t2.6; 2.4.19\n"
msgstr "B<sendfile64>(2)\t2.6; 2.4.19\n"

#. type: tbl table
#: build/C/man2/syscalls.2:466
#, no-wrap
msgid "B<sendmmsg>(2)\t3.0\n"
msgstr "B<sendmmsg>(2)\t3.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:467
#, no-wrap
msgid "B<sendmsg>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<sendmsg>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:468
#, no-wrap
msgid "B<sendto>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<sendto>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:469
#, no-wrap
msgid "B<set_mempolicy>(2)\t2.6.6\n"
msgstr "B<set_mempolicy>(2)\t2.6.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:470
#, no-wrap
msgid "B<set_robust_list>(2)\t2.6.17\n"
msgstr "B<set_robust_list>(2)\t2.6.17\n"

#. type: tbl table
#: build/C/man2/syscalls.2:471
#, no-wrap
msgid "B<set_thread_area>(2)\t2.6\n"
msgstr "B<set_thread_area>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:472
#, no-wrap
msgid "B<set_tid_address>(2)\t2.6\n"
msgstr "B<set_tid_address>(2)\t2.6\n"

#.  See http://lkml.org/lkml/2005/8/1/83
#.  "[PATCH] remove sys_set_zone_reclaim()"
#. type: tbl table
#: build/C/man2/syscalls.2:475
#, no-wrap
msgid "B<setdomainname>(2)\t1.0\n"
msgstr "B<setdomainname>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:476
#, no-wrap
msgid "B<setfsgid>(2)\t1.2\n"
msgstr "B<setfsgid>(2)\t1.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:477
#, no-wrap
msgid "B<setfsgid32>(2)\t2.4\n"
msgstr "B<setfsgid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:478
#, no-wrap
msgid "B<setfsuid>(2)\t1.2\n"
msgstr "B<setfsuid>(2)\t1.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:479
#, no-wrap
msgid "B<setfsuid32>(2)\t2.4\n"
msgstr "B<setfsuid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:480
#, no-wrap
msgid "B<setgid>(2)\t1.0\n"
msgstr "B<setgid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:481
#, no-wrap
msgid "B<setgid32>(2)\t2.4\n"
msgstr "B<setgid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:482
#, no-wrap
msgid "B<setgroups>(2)\t1.0\n"
msgstr "B<setgroups>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:483
#, no-wrap
msgid "B<setgroups32>(2)\t2.4\n"
msgstr "B<setgroups32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:484
#, no-wrap
msgid "B<sethostname>(2)\t1.0\n"
msgstr "B<sethostname>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:485
#, no-wrap
msgid "B<setitimer>(2)\t1.0\n"
msgstr "B<setitimer>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:486
#, no-wrap
msgid "B<setns>(2)\t3.0\n"
msgstr "B<setns>(2)\t3.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:487
#, no-wrap
msgid "B<setpgid>(2)\t1.0\n"
msgstr "B<setpgid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:488
#, no-wrap
msgid "B<setpriority>(2)\t1.0\n"
msgstr "B<setpriority>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:489
#, no-wrap
msgid "B<setregid>(2)\t1.0\n"
msgstr "B<setregid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:490
#, no-wrap
msgid "B<setregid32>(2)\t2.4\n"
msgstr "B<setregid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:491
#, no-wrap
msgid "B<setresgid>(2)\t2.2\n"
msgstr "B<setresgid>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:492
#, no-wrap
msgid "B<setresgid32>(2)\t2.4\n"
msgstr "B<setresgid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:493
#, no-wrap
msgid "B<setresuid>(2)\t2.2\n"
msgstr "B<setresuid>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:494
#, no-wrap
msgid "B<setresuid32>(2)\t2.4\n"
msgstr "B<setresuid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:495
#, no-wrap
msgid "B<setreuid>(2)\t1.0\n"
msgstr "B<setreuid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:496
#, no-wrap
msgid "B<setreuid32>(2)\t2.4\n"
msgstr "B<setreuid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:497
#, no-wrap
msgid "B<setrlimit>(2)\t1.0\n"
msgstr "B<setrlimit>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:498
#, no-wrap
msgid "B<setsid>(2)\t1.0\n"
msgstr "B<setsid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:499
#, no-wrap
msgid "B<setsockopt>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<setsockopt>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:500
#, no-wrap
msgid "B<settimeofday>(2)\t1.0\n"
msgstr "B<settimeofday>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:501
#, no-wrap
msgid "B<setuid>(2)\t1.0\n"
msgstr "B<setuid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:502
#, no-wrap
msgid "B<setuid32>(2)\t2.4\n"
msgstr "B<setuid32>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:503
#, no-wrap
msgid "B<setup>(2)\t\tRemoved in 2.2\n"
msgstr "B<setup>(2)\t\t2.2 で削除\n"

#. type: tbl table
#: build/C/man2/syscalls.2:504
#, no-wrap
msgid "B<setxattr>(2)\t2.6; 2.4.18\n"
msgstr "B<setxattr>(2)\t2.6; 2.4.18\n"

#. type: tbl table
#: build/C/man2/syscalls.2:505
#, no-wrap
msgid "B<sgetmask>(2)\t1.0\n"
msgstr "B<sgetmask>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:506
#, no-wrap
msgid "B<shmat>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmat>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:507
#, no-wrap
msgid "B<shmctl>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmctl>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:508
#, no-wrap
msgid "B<shmdt>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmdt>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:509
#, no-wrap
msgid "B<shmget>(2)\t2.0\tSee notes on B<ipc>(2)\n"
msgstr "B<shmget>(2)\t2.0\tB<ipc>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:510
#, no-wrap
msgid "B<shutdown>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<shutdown>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:511
#, no-wrap
msgid "B<sigaction>(2)\t1.0\n"
msgstr "B<sigaction>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:512
#, no-wrap
msgid "B<sigaltstack>(2)\t2.2\n"
msgstr "B<sigaltstack>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:513
#, no-wrap
msgid "B<signal>(2)\t1.0\n"
msgstr "B<signal>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:514
#, no-wrap
msgid "B<signalfd>(2)\t2.6.22\n"
msgstr "B<signalfd>(2)\t2.6.22\n"

#. type: tbl table
#: build/C/man2/syscalls.2:515
#, no-wrap
msgid "B<signalfd4>(2)\t2.6.27\n"
msgstr "B<signalfd4>(2)\t2.6.27\n"

#. type: tbl table
#: build/C/man2/syscalls.2:516
#, no-wrap
msgid "B<sigpending>(2)\t1.0\n"
msgstr "B<sigpending>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:517
#, no-wrap
msgid "B<sigprocmask>(2)\t1.0\n"
msgstr "B<sigprocmask>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:518
#, no-wrap
msgid "B<sigreturn>(2)\t1.0\n"
msgstr "B<sigreturn>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:519
#, no-wrap
msgid "B<sigsuspend>(2)\t1.0\n"
msgstr "B<sigsuspend>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:520
#, no-wrap
msgid "B<socket>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<socket>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:521
#, no-wrap
msgid "B<socketcall>(2)\t1.0\n"
msgstr "B<socketcall>(2)\t1.0\n"

#.  Implements BSD socket calls
#. type: tbl table
#: build/C/man2/syscalls.2:523
#, no-wrap
msgid "B<socketpair>(2)\t2.0\tSee notes on B<socketcall>(2)\n"
msgstr "B<socketpair>(2)\t2.0\tB<socketcall>(2) の「注意」の節を参照\n"

#. type: tbl table
#: build/C/man2/syscalls.2:524
#, no-wrap
msgid "B<splice>(2)\t2.6.17\n"
msgstr "B<splice>(2)\t2.6.17\n"

#. type: tbl table
#: build/C/man2/syscalls.2:525
#, no-wrap
msgid "B<spu_create>(2)\t2.6.16\tPowerPC only\n"
msgstr "B<spu_create>(2)\t2.6.16\tPowerPC のみ\n"

#. type: tbl table
#: build/C/man2/syscalls.2:526
#, no-wrap
msgid "B<spu_run>(2)\t2.6.16\tPowerPC only\n"
msgstr "B<spu_run>(2)\t2.6.16\tPowerPC のみ\n"

#. type: tbl table
#: build/C/man2/syscalls.2:527
#, no-wrap
msgid "B<ssetmask>(2)\t1.0\n"
msgstr "B<ssetmask>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:528
#, no-wrap
msgid "B<stat>(2)\t1.0\n"
msgstr "B<stat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:529
#, no-wrap
msgid "B<stat64>(2)\t2.4\n"
msgstr "B<stat64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:530
#, no-wrap
msgid "B<statfs>(2)\t1.0\n"
msgstr "B<statfs>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:531
#, no-wrap
msgid "B<statfs64>(2)\t2.6\n"
msgstr "B<statfs64>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:532
#, no-wrap
msgid "B<stime>(2)\t1.0\n"
msgstr "B<stime>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:533
#, no-wrap
msgid "B<subpage_prot>(2)\t2.6.25\tPowerPC if\n"
msgstr "B<subpage_prot>(2)\t2.6.25\tPowerPC で\n"

#. type: tbl table
#: build/C/man2/syscalls.2:534
#, no-wrap
msgid "\t\tCONFIG_PPC_64K_PAGES\n"
msgstr "\t\tCONFIG_PPC_64K_PAGES の場合\n"

#. type: tbl table
#: build/C/man2/syscalls.2:535
#, no-wrap
msgid "B<swapoff>(2)\t1.0\n"
msgstr "B<swapoff>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:536
#, no-wrap
msgid "B<swapon>(2)\t1.0\n"
msgstr "B<swapon>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:537
#, no-wrap
msgid "B<symlink>(2)\t1.0\n"
msgstr "B<symlink>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:538
#, no-wrap
msgid "B<symlinkat>(2)\t2.6.16\n"
msgstr "B<symlinkat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:539
#, no-wrap
msgid "B<sync>(2)\t1.0\n"
msgstr "B<sync>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:540
#, no-wrap
msgid "B<sync_file_range>(2)\t2.6.17\n"
msgstr "B<sync_file_range>(2)\t2.6.17\n"

#. type: tbl table
#: build/C/man2/syscalls.2:541
#, no-wrap
msgid "B<sync_file_range2>(2)\t2.6.22\tT{\n"
msgstr "B<sync_file_range2>(2)\t2.6.22\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:542
#, no-wrap
msgid "Architecture-specific\n"
msgstr "アーキテクチャ固有の\n"

#. type: tbl table
#: build/C/man2/syscalls.2:543
#, no-wrap
msgid "variant of B<sync_file_range>(2)\n"
msgstr "B<sync_file_range>(2) の一種\n"

#.  PowerPC, ARM, tile
#.  First appeared on ARM, as arm_sync_file_range(), but later renamed
#.  \fBsys_debug_setcontext\fP(2)	???	PowerPC if CONFIG_PPC32
#. type: tbl table
#: build/C/man2/syscalls.2:548
#, no-wrap
msgid "B<syncfs>(2)\t2.6.39\n"
msgstr "B<syncfs>(2)\t2.6.39\n"

#. type: tbl table
#: build/C/man2/syscalls.2:549
#, no-wrap
msgid "B<sysfs>(2)\t1.2\n"
msgstr "B<sysfs>(2)\t1.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:550
#, no-wrap
msgid "B<sysinfo>(2)\t1.0\n"
msgstr "B<sysinfo>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:551
#, no-wrap
msgid "B<syslog>(2)\t1.0\n"
msgstr "B<syslog>(2)\t1.0\n"

#.  glibc interface is \fBklogctl\fP(3)
#. type: tbl table
#: build/C/man2/syscalls.2:553
#, no-wrap
msgid "B<tee>(2)\t2.6.17\n"
msgstr "B<tee>(2)\t2.6.17\n"

#. type: tbl table
#: build/C/man2/syscalls.2:554
#, no-wrap
msgid "B<tgkill>(2)\t2.6\n"
msgstr "B<tgkill>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:555
#, no-wrap
msgid "B<time>(2)\t1.0\n"
msgstr "B<time>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:556
#, no-wrap
msgid "B<timer_create>(2)\t2.6\n"
msgstr "B<timer_create>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:557
#, no-wrap
msgid "B<timer_delete>(2)\t2.6\n"
msgstr "B<timer_delete>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:558
#, no-wrap
msgid "B<timer_getoverrun>(2)\t2.6\n"
msgstr "B<timer_getoverrun>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:559
#, no-wrap
msgid "B<timer_gettime>(2)\t2.6\n"
msgstr "B<timer_gettime>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:560
#, no-wrap
msgid "B<timer_settime>(2)\t2.6\n"
msgstr "B<timer_settime>(2)\t2.6\n"

#. type: tbl table
#: build/C/man2/syscalls.2:561
#, no-wrap
msgid "B<timerfd_create>(2)\t2.6.25\n"
msgstr "B<timerfd_create>(2)\t2.6.25\n"

#. type: tbl table
#: build/C/man2/syscalls.2:562
#, no-wrap
msgid "B<timerfd_gettime>(2)\t2.6.25\n"
msgstr "B<timerfd_gettime>(2)\t2.6.25\n"

#. type: tbl table
#: build/C/man2/syscalls.2:563
#, no-wrap
msgid "B<timerfd_settime>(2)\t2.6.25\n"
msgstr "B<timerfd_settime>(2)\t2.6.25\n"

#. type: tbl table
#: build/C/man2/syscalls.2:564
#, no-wrap
msgid "B<times>(2)\t1.0\n"
msgstr "B<times>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:565
#, no-wrap
msgid "B<tkill>(2)\t2.6; 2.4.22\n"
msgstr "B<tkill>(2)\t2.6; 2.4.22\n"

#. type: tbl table
#: build/C/man2/syscalls.2:566
#, no-wrap
msgid "B<truncate>(2)\t1.0\n"
msgstr "B<truncate>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:567
#, no-wrap
msgid "B<truncate64>(2)\t2.4\n"
msgstr "B<truncate64>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:568
#, no-wrap
msgid "B<ugetrlimit>(2)\t2.4\n"
msgstr "B<ugetrlimit>(2)\t2.4\n"

#. type: tbl table
#: build/C/man2/syscalls.2:569
#, no-wrap
msgid "B<umask>(2)\t1.0\n"
msgstr "B<umask>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:570
#, no-wrap
msgid "B<umount>(2)\t1.0\n"
msgstr "B<umount>(2)\t1.0\n"

#.  sys_oldumount() -- __NR_umount
#. type: tbl table
#: build/C/man2/syscalls.2:572
#, no-wrap
msgid "B<umount2>(2)\t2.2\n"
msgstr "B<umount2>(2)\t2.2\n"

#.  sys_umount() -- __NR_umount2
#. type: tbl table
#: build/C/man2/syscalls.2:574
#, no-wrap
msgid "B<uname>(2)\t1.0\n"
msgstr "B<uname>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:575
#, no-wrap
msgid "B<unlink>(2)\t1.0\n"
msgstr "B<unlink>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:576
#, no-wrap
msgid "B<unlinkat>(2)\t2.6.16\n"
msgstr "B<unlinkat>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:577
#, no-wrap
msgid "B<unshare>(2)\t2.6.16\n"
msgstr "B<unshare>(2)\t2.6.16\n"

#. type: tbl table
#: build/C/man2/syscalls.2:578
#, no-wrap
msgid "B<uselib>(2)\t1.0\n"
msgstr "B<uselib>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:579
#, no-wrap
msgid "B<ustat>(2)\t1.0\n"
msgstr "B<ustat>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:580
#, no-wrap
msgid "B<utime>(2)\t1.0\n"
msgstr "B<utime>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:581
#, no-wrap
msgid "B<utimensat>(2)\t2.6.22\n"
msgstr "B<utimensat>(2)\t2.6.22\n"

#. type: tbl table
#: build/C/man2/syscalls.2:582
#, no-wrap
msgid "B<utimes>(2)\t2.2\n"
msgstr "B<utimes>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:583
#, no-wrap
msgid "B<utrap_install>(2)\t2.2\tSparc\n"
msgstr "B<utrap_install>(2)\t2.2\tSparc\n"

#. type: tbl table
#: build/C/man2/syscalls.2:584
#, no-wrap
msgid "B<vfork>(2)\t2.2\n"
msgstr "B<vfork>(2)\t2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:585
#, no-wrap
msgid "B<vhangup>(2)\t1.0\n"
msgstr "B<vhangup>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:586
#, no-wrap
msgid "B<vm86old>(2)\t1.0\tT{\n"
msgstr "B<vm86old>(2)\t1.0\tT{\n"

#. type: tbl table
#: build/C/man2/syscalls.2:587
#, no-wrap
msgid "Was \"vm86\"; renamed in\n"
msgstr "以前は \"vm86\";\n"

#. type: tbl table
#: build/C/man2/syscalls.2:588
#, no-wrap
msgid "2.0.28/2.2\n"
msgstr "2.0.28/2.2 で改名された\n"

#. type: tbl table
#: build/C/man2/syscalls.2:590
#, no-wrap
msgid "B<vm86>(2)\t2.0.28; 2.2\n"
msgstr "B<vm86>(2)\t2.0.28; 2.2\n"

#. type: tbl table
#: build/C/man2/syscalls.2:591
#, no-wrap
msgid "B<vmsplice>(2)\t2.6.17\n"
msgstr "B<vmsplice>(2)\t2.6.17\n"

#. type: tbl table
#: build/C/man2/syscalls.2:592
#, no-wrap
msgid "B<wait4>(2)\t1.0\n"
msgstr "B<wait4>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:593
#, no-wrap
msgid "B<waitid>(2)\t2.6.10\n"
msgstr "B<waitid>(2)\t2.6.10\n"

#. type: tbl table
#: build/C/man2/syscalls.2:594
#, no-wrap
msgid "B<waitpid>(2)\t1.0\n"
msgstr "B<waitpid>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:595
#, no-wrap
msgid "B<write>(2)\t1.0\n"
msgstr "B<write>(2)\t1.0\n"

#. type: tbl table
#: build/C/man2/syscalls.2:596
#, no-wrap
msgid "B<writev>(2)\t2.0\n"
msgstr "B<writev>(2)\t2.0\n"

#. type: Plain text
#: build/C/man2/syscalls.2:605
msgid ""
"On many platforms, including x86-32, socket calls are all multiplexed (via "
"glibc wrapper functions) through B<socketcall>(2)  and similarly System V "
"IPC calls are multiplexed through B<ipc>(2)."
msgstr ""
"x86-32 を含む多くのプラットフォームでは、ソケット関連のシステムコールは "
"(glibc のラッパー関数を介してだが) すべて B<socketcall>(2) 経由に多重されてい"
"る。 同様に、System V IPC 関連のシステムコールは B<ipc>(2) 経由に多重されてい"
"る。"

#.  __NR_afs_syscall is 53 on Linux 2.6.22/i386
#.  __NR_break is 17 on Linux 2.6.22/i386
#.  __NR_ftime is 35 on Linux 2.6.22/i386
#.  __NR_getpmsg is 188 on Linux 2.6.22/i386
#.  __NR_gtty is 32 on Linux 2.6.22/i386
#.  __NR_idle is 112 on Linux 2.6.22/i386
#.  __NR_lock is 53 on Linux 2.6.22/i386
#.  __NR_madvise1 is 219 on Linux 2.6.22/i386
#.  __NR_mpx is 66 on Linux 2.6.22/i386
#.  Slot has been reused
#.  __NR_prof is 44 on Linux 2.6.22/i386
#.  __NR_profil is 98 on Linux 2.6.22/i386
#.  __NR_putpmsg is 189 on Linux 2.6.22/i386
#.  __NR_security is 223 on Linux 2.4/i386
#.  __NR_security is 223 on Linux 2.4/i386; absent on 2.6/i386, present
#.  on a couple of 2.6 architectures
#.  __NR_stty is 31 on Linux 2.6.22/i386
#.  The security call is for future use.
#.  __NR_tuxcall is 184 on x86_64, also on PPC and alpha
#.  __NR_ulimit is 58 on Linux 2.6.22/i386
#.  __NR_vserver is 273 on Linux 2.6.22/i386
#. type: Plain text
#: build/C/man2/syscalls.2:650
msgid ""
"Although slots are reserved for them in the system call table, the following "
"system calls are not implemented in the standard kernel: B<afs_syscall>(2), "
"B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2), B<idle>(2), B<lock>(2), "
"B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2), B<profil>(2), B<putpmsg>"
"(2), B<security>(2), B<stty>(2), B<tuxcall>(2), B<ulimit>(2), and B<vserver>"
"(2)  (see also B<unimplemented>(2)).  However, B<ftime>(3), B<profil>(3)  "
"and B<ulimit>(3)  exist as library routines.  The slot for B<phys>(2)  is in "
"use since kernel 2.1.116 for B<umount>(2); B<phys>(2)  will never be "
"implemented.  The B<getpmsg>(2)  and B<putpmsg>(2)  calls are for kernels "
"patched to support STREAMS, and may never be in the standard kernel."
msgstr ""
"以下のシステムコールは、システムコールテーブルにスロットが予約されている"
"が、\n"
"標準のカーネルには実装されていない:\n"
"B<afs_syscall>(2), B<break>(2), B<ftime>(2), B<getpmsg>(2), B<gtty>(2),\n"
"B<idle>(2), B<lock>(2), B<madvise1>(2), B<mpx>(2), B<phys>(2), B<prof>(2),\n"
"B<profil>(2), B<putpmsg>(2), B<security>(2), B<stty>(2), B<tuxcall>(2),\n"
"B<ulimit>(2), B<vserver>(2) (B<unimplemented>(2) も参照)。\n"
"しかし、B<ftime>(3), B<profil>(3), B<ulimit>(3) はライブラリルーチンとして\n"
"実装されている。 B<phys>(2) 用の場所は 2.1.116 以降では B<umount>(2) 用に\n"
"使用されている; 将来においても B<phys>(2) は実装されない。\n"
"B<getpmsg>(2) と B<putpmsg>(2) は STREAMS 対応のパッチが適用された\n"
"カーネル用であり、標準のカーネルに登場することはないかもしれない。"

#. type: Plain text
#: build/C/man2/syscalls.2:655
msgid ""
"There was briefly B<set_zone_reclaim>(2), added in Linux 2.6.13, and removed "
"in 2.6.16; this system call was never available to user space."
msgstr ""
"B<set_zone_reclaim>(2) は少しの間だけ存在した。 Linux 2.6.13 で追加され、"
"2.6.16 で削除された。このシステムコールがユーザ空間から使える状態になったこと"
"はない。"

#. type: Plain text
#: build/C/man2/syscalls.2:672
msgid ""
"Roughly speaking, the code belonging to the system call with number __NR_xxx "
"defined in I</usr/include/asm/unistd.h> can be found in the Linux kernel "
"source in the routine I<sys_xxx>().  (The dispatch table for i386 can be "
"found in I</usr/src/linux/arch/i386/kernel/entry.S>.)  There are many "
"exceptions, however, mostly because older system calls were superseded by "
"newer ones, and this has been treated somewhat unsystematically.  On "
"platforms with proprietary operating-system emulation, such as parisc, "
"sparc, sparc64, and alpha, there are many additional system calls; mips64 "
"also contains a full set of 32-bit system calls."
msgstr ""
"たいていは、 I</usr/include/asm/unistd.h> で定義されている番号 __NR_xxx のシ"
"ステムコールのコードは、 Linux カーネルソースの I<sys_xxx>() というルーチンに"
"書かれている (i386 における実行テーブルは I</usr/src/linux/arch/i386/kernel/"
"entry.S> に書かれている)。 しかしこれには多くの例外がある。古いシステムコール"
"は新版に置き換えられて きたが、この置き換えはあまり体系立てて行われて来なかっ"
"たからである。 parisc, sparc, sparc64, alpha といったプロプリエタリなオペレー"
"ティングシステムのエミュレーション機能があるプラットフォームでは、多くの追加"
"システムコールがある。 mips64 には、32 ビットシステムコールのフルセットも含ま"
"れている。"

#. type: Plain text
#: build/C/man2/syscalls.2:691
msgid ""
"Over time, changes to the interfaces of some system calls have been "
"necessary.  One reason for such changes was the need to increase the size of "
"structures or scalar values passed to the system call.  Because of these "
"changes, there are now various groups of related system calls (e.g., "
"B<truncate>(2)  and B<truncate64>(2))  which perform similar tasks, but "
"which vary in details such as the size of their arguments.  (As noted "
"earlier, applications are generally unaware of this: the glibc wrapper "
"functions do some work to ensure that the right system call is invoked, and "
"that ABI compatibility is preserved for old binaries.)  Examples of systems "
"calls that exist in multiple versions are the following:"
msgstr ""
"時間の経過とともに、いくつかのシステムコールではインタフェースの 変更が必要に"
"なってきた。 こうした変更の理由の一つは、システムコールに渡される構造体やスカ"
"ラー値 のサイズを増やす必要があることだった。 これらの変更の結果、現在では、"
"同様の処理を実行するが 引き数のサイズなどの詳細は異なる、一連のシステムコール"
"群が いくつか存在する (例えば、 B<truncate>(2)  と B<truncate64>(2))。 (すで"
"に述べたように、 一般にはアプリケーションがこのことを意識することはない。 "
"glibc のラッパー関数が、適切なシステムコールを起動し、古いバイナリに 対して "
"ABI レベルでの互換性を保持することを保証する処理を行っている。)  複数のバー"
"ジョンが存在するシステムコールの例を以下に挙げる。"

#.  e.g., on 2.6.22/i386: __NR_oldstat 18, __NR_stat 106, __NR_stat64 195
#.  The stat system calls deal with three different data structures,
#.  defined in include/asm-i386/stat.h: __old_kernel_stat, stat, stat64
#. type: Plain text
#: build/C/man2/syscalls.2:712
msgid ""
"By now there are three different versions of B<stat>(2): I<sys_stat>()  "
"(slot I<__NR_oldstat>), I<sys_newstat>()  (slot I<__NR_stat>), and "
"I<sys_stat64>()  (slot I<__NR_stat64>), with the last being the most "
"current.  A similar story applies for B<lstat>(2)  and B<fstat>(2)."
msgstr ""
"これまでに、 B<stat>(2)  には 3 種類の異なるバージョンが存在する。 "
"I<sys_stat>()  (スロットは I<__NR_oldstat>)、 I<sys_newstat>()  (スロットは "
"I<__NR_stat>)、 I<sys_stat64>()  (カーネル 2.4 で導入; スロットは "
"I<__NR_stat64>)。 3つのうち最後のものが最新である。 B<lstat>(2)  と B<fstat>"
"(2)  についても同様である。"

#. type: Plain text
#: build/C/man2/syscalls.2:723
msgid ""
"Similarly, the defines I<__NR_oldolduname>, I<__NR_olduname>, and "
"I<__NR_uname> refer to the routines I<sys_olduname>(), I<sys_uname>()  and "
"I<sys_newuname>()."
msgstr ""
"また、 I<__NR_oldolduname>, I<__NR_olduname>, I<__NR_uname> という定義は、そ"
"れぞれ I<sys_olduname>(), I<sys_uname>(), I<sys_newuname>()  というルーチンを"
"参照している。"

#. type: Plain text
#: build/C/man2/syscalls.2:730
msgid ""
"In Linux 2.0, a new version of B<vm86>(2)  appeared, with the old and the "
"new kernel routines being named I<sys_vm86old>()  and I<sys_vm86>()."
msgstr ""
"Linux 2.0 では、 B<vm86>(2)  の新バージョンが登場した。カーネルルーチンの 古"
"いバージョン、新しいバージョンはそれぞれ I<sys_vm86old>(), I<sys_vm86>()  と"
"いう名前である。"

#. type: Plain text
#: build/C/man2/syscalls.2:741
msgid ""
"In Linux 2.4, a new version of B<getrlimit>(2)  appeared, with the old and "
"the new kernel routines being named I<sys_old_getrlimit>()  (slot "
"I<__NR_getrlimit>)  and I<sys_getrlimit>()  (slot I<__NR_ugetrlimit>)."
msgstr ""
"Linux 2.4 では、 B<getrlimit>(2)  の新バージョンが登場した。カーネルルーチン"
"の 古いバージョン、新しいバージョンはそれぞれ I<sys_old_getrlimit>()  (スロッ"
"トは I<__NR_getrlimit>), I<sys_getrlimit>()  (スロットは "
"I<__NR_ugetrlimit>)  という名前である。"

#.  64-bit off_t changes: ftruncate64, *stat64,
#.  fcntl64 (because of the flock structure), getdents64, *statfs64
#. type: Plain text
#: build/C/man2/syscalls.2:753
msgid ""
"Linux 2.4 increased the size of user and group IDs from 16 to 32 bits.  To "
"support this change, a range of system calls were added (e.g., B<chown32>"
"(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)), superseding "
"earlier calls of the same name without the \"32\" suffix."
msgstr ""
"Linux 2.4 で、ユーザ ID とグループ ID のサイズが 16 ビットから 32 ビットに増"
"えた。 この変更に対応するため、いくつかのシステムコールが追加された "
"(B<chown32>(2), B<getuid32>(2), B<getgroups32>(2), B<setresuid32>(2)  な"
"ど)。 これらのシステムコールが、末尾の \"32\" が付かない同名の 古いバージョン"
"に代わって使われるようになった。"

#. type: Plain text
#: build/C/man2/syscalls.2:770
msgid ""
"Linux 2.4 added support for applications on 32-bit architectures to access "
"large files (i.e., files for which the sizes and file offsets can't be "
"represented in 32 bits.)  To support this change, replacements were required "
"for system calls that deal with file offsets and sizes.  Thus the following "
"system calls were added: B<fcntl64>(2), B<ftruncate64>(2), B<getdents64>(2), "
"B<stat64>(2), B<statfs64>(2), and their analogs that work with file "
"descriptors or symbolic links.  These system calls supersede the older "
"system calls which, except in the case of the \"stat\" calls, have the same "
"name without the \"64\" suffix."
msgstr ""
"Linux 2.4 では、32 ビットアーキテクチャ上のアプリケーションが 大きなファイル "
"(つまり、32 ビットでは表現できないサイズや ファイルオフセットが必要なファイ"
"ル) にアクセスできるようになった。 この変更に対応するため、ファイルオフセット"
"とサイズを扱う システムコールの置き換えが必要となった。その結果、 B<fcntl64>"
"(2), B<ftruncate64>(2), B<getdents64>(2), B<stat64>(2), B<statfs64>(2)  と、"
"ファイルディスクリプタやシンボリックリンクで同じ機能を持つ システムコールが追"
"加された。 これらのシステムコールが、末尾の \"64\" が付かない同名の 古いバー"
"ジョンに代わって使われるようになった。 但し、\"stat\" 系のシステムコールはそ"
"の限りではない。"

#. type: Plain text
#: build/C/man2/syscalls.2:774
msgid ""
"On newer platforms that only have 64-bit file access and 32-bit uids (e.g., "
"alpha, ia64, s390x) there are no *64 or *32 calls.  Where the *64 and *32 "
"calls exist, the other versions are obsolete."
msgstr ""
"64-bit ファイルアクセスと 32-bit UID のみを持つ 新しいプラットフォーム "
"(alpha, ia64, s390x など) では、 *64 や *32 という名前のシステムコールはな"
"い。 *64 や *32 というシステムコールが存在する場合、 *64 や *32 がついていな"
"いシステムコールは廃止扱いである。"

#. type: Plain text
#: build/C/man2/syscalls.2:782
msgid ""
"The I<rt_sig*> calls were added in kernel 2.2 to support the addition of "
"real-time signals (see B<signal>(7)).  These system calls supersede the "
"older system calls of the same name without the \"rt_\" prefix."
msgstr ""
"リアルタイムシグナル (B<signal>(7)  参照) への対応を追加するために、 "
"I<rt_sig*> 系のシステムコールがカーネル 2.2 で追加された。 これらのシステム"
"コールが、先頭に \"rt_\" が付かない同名の 古いバージョンに代わって使われるよ"
"うになった。"

#.  (used by libc 6)
#.  .PP
#.  Two system call numbers,
#.  .IR __NR__llseek
#.  and
#.  .IR __NR__sysctl
#.  have an additional underscore absent in
#.  .IR sys_llseek ()
#.  and
#.  .IR sys_sysctl ().
#.  In kernel 2.1.81,
#.  .BR lchown (2)
#.  and
#.  .BR chown (2)
#.  were swapped; that is,
#.  .BR lchown (2)
#.  was added with the semantics that were then current for
#.  .BR chown (2),
#.  and the semantics of the latter call were changed to what
#.  they are today.
#. type: Plain text
#: build/C/man2/syscalls.2:832
msgid ""
"The B<select>(2)  and B<mmap>(2)  system calls use five or more arguments, "
"which caused problems in the way argument passing on the i386 used to be set "
"up.  Thus, while other architectures have I<sys_select>()  and I<sys_mmap>"
"()  corresponding to I<__NR_select> and I<__NR_mmap>, on i386 one finds "
"I<old_select>()  and I<old_mmap>()  (routines that use a pointer to a "
"argument block) instead.  These days passing five arguments is not a problem "
"any more, and there is a I<__NR__newselect> that corresponds directly to "
"I<sys_select>()  and similarly I<__NR_mmap2>."
msgstr ""
"B<select>(2)  と B<mmap>(2)  は 5つもしくはそれ以上の引き数を使用しており、 "
"i386 では引き数の受け渡しに問題が生じる。 そのため、他のアーキテクチャでは "
"I<__NR_select> と I<__NR_mmap> に対応する I<sys_select>()  と I<sys_mmap>()  "
"が存在するが、i386 では代わりに I<old_select>()  と I<old_mmap>()  というルー"
"チンがある (これらのルーチンは引き数ブロックへのポインタを使用する)。 現在で"
"は 5つの引き数を渡すことはもはや問題ではなくなっており、 I<__NR__newselect> "
"は I<sys_select>()  に直接対応するようになっている。 I<__NR_mmap2> についても"
"同様である。"

#. type: Plain text
#: build/C/man2/syscalls.2:838
msgid "B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<libc>(7), B<vdso>(7)"
msgstr "B<intro>(2), B<syscall>(2), B<unimplemented>(2), B<libc>(7), B<vdso>(7)"

#. type: TH
#: build/C/man3/sysconf.3:27
#, no-wrap
msgid "SYSCONF"
msgstr "SYSCONF"

#. type: TH
#: build/C/man3/sysconf.3:27
#, no-wrap
msgid "2013-02-12"
msgstr "2013-02-12"

#. type: Plain text
#: build/C/man3/sysconf.3:30
msgid "sysconf - get configuration information at run time"
msgstr "sysconf - 動作中に設定情報を取得する"

#. type: Plain text
#: build/C/man3/sysconf.3:35
#, no-wrap
msgid "B<long sysconf(int >I<name>B<);>\n"
msgstr "B<long sysconf(int >I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/sysconf.3:40
msgid ""
"POSIX allows an application to test at compile or run time whether certain "
"options are supported, or what the value is of certain configurable "
"constants or limits."
msgstr ""
"POSIX では、アプリケーションがコンパイル時や実行時に、 特定のオプションがサ"
"ポートされているかや、 設定可能な特定の定数や制限がどんな値かをテストすること"
"ができる。"

#. type: Plain text
#: build/C/man3/sysconf.3:46
msgid ""
"At compile time this is done by including I<E<lt>unistd.hE<gt>> and/or "
"I<E<lt>limits.hE<gt>> and testing the value of certain macros."
msgstr ""
"コンパイル時に行うには、 I<E<lt>unistd.hE<gt>> と I<E<lt>limits.hE<gt>> の両"
"方もしくは一方をインクルードし、 特定のマクロの値を確認する。"

#. type: Plain text
#: build/C/man3/sysconf.3:56
msgid ""
"At run time, one can ask for numerical values using the present function "
"B<sysconf>().  One can ask for numerical values that may depend on the "
"filesystem a file is in using the calls B<fpathconf>(3)  and B<pathconf>"
"(3).  One can ask for string values using B<confstr>(3)."
msgstr ""
"実行時には、ここで説明する関数 B<sysconf>()  を使って数値を問い合わせることが"
"できる。 ファイルが存在するファイルシステムに関する数値は、 B<fpathconf>(3)  "
"と B<pathconf>(3)  を使って確認できる。 文字列の値は B<confstr>(3)  を使って"
"確認できる。"

#.  except that sysconf(_SC_OPEN_MAX) may change answer after a call
#.  to setrlimit( ) which changes the RLIMIT_NOFILE soft limit
#. type: Plain text
#: build/C/man3/sysconf.3:61
msgid ""
"The values obtained from these functions are system configuration "
"constants.  They do not change during the lifetime of a process."
msgstr ""
"これらの関数で取得される値は設定可能なシステム定数である。 これらはプロセスの"
"生存期間の間は変化しない。"

#.  and 999 to indicate support for options no longer present in the latest
#.  standard. (?)
#. type: Plain text
#: build/C/man3/sysconf.3:84
msgid ""
"For options, typically, there is a constant B<_POSIX_FOO> that may be "
"defined in I<E<lt>unistd.hE<gt>>.  If it is undefined, one should ask at run "
"time.  If it is defined to -1, then the option is not supported.  If it is "
"defined to 0, then relevant functions and headers exist, but one has to ask "
"at run time what degree of support is available.  If it is defined to a "
"value other than -1 or 0, then the option is supported.  Usually the value "
"(such as 200112L) indicates the year and month of the POSIX revision "
"describing the option.  Glibc uses the value 1 to indicate support as long "
"as the POSIX revision has not been published yet.  The B<sysconf>()  "
"argument will be B<_SC_FOO>.  For a list of options, see B<posixoptions>(7)."
msgstr ""
"オプションを確認できるように、たいていは I<E<lt>unistd.hE<gt>> で定数 "
"B<_POSIX_FOO> が定義されている。 定義されていないときは、実行時に問い合わせを"
"行う必要がある。 その値が -1 に定義されているときは、そのオプションはサポート"
"されていない。 0 に定義されているときは、関連する関数やヘッダファイルが存在す"
"るが、 どの程度サポートされているかは実行時に確認しなければならない。 -1 で"
"も 0 でもない値に定義されているときは、そのオプションがサポート されている。"
"通常は、そのオプションについて記載した POSIX の改訂年月 を示す値になっている "
"(例えば 200112L)。 glibc では 1 が設定されていると、そのオプションはサポート"
"されているが、 POSIX の改訂版がまだ発行されていないことを示す。 B<sysconf>"
"()  の引き数には B<_SC_FOO> を指定する。 オプションのリストについては "
"B<posixoptions>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man3/sysconf.3:104
msgid ""
"For variables or limits, typically, there is a constant B<_FOO>, maybe "
"defined in I<E<lt>limits.hE<gt>>, or B<_POSIX_FOO>, maybe defined in "
"I<E<lt>unistd.hE<gt>>.  The constant will not be defined if the limit is "
"unspecified.  If the constant is defined, it gives a guaranteed value, and a "
"greater value might actually be supported.  If an application wants to take "
"advantage of values which may change between systems, a call to B<sysconf>"
"()  can be made.  The B<sysconf>()  argument will be B<_SC_FOO>."
msgstr ""
"変数や制限を確認できるように、たいていは、 I<E<lt>limits.hE<gt>> で定数 "
"B<_FOO> が、 I<E<lt>unistd.hE<gt>> で B<_POSIX_FOO> が定義されている。 制限が"
"規定されていない場合は定数は定義されない。 定数が定義されているときには、その"
"定数は保証できる値であり、 実際にはもっと大きな値がサポートされていることもあ"
"る。 アプリケーションがシステム毎に変化する値を利用したい場合には、 "
"B<sysconf>()  を呼び出すことで実現できる。 B<sysconf>()  の引き数には "
"B<_SC_FOO> を指定する。"

#. type: SS
#: build/C/man3/sysconf.3:104
#, no-wrap
msgid "POSIX.1 variables"
msgstr "POSIX.1 変数"

#. type: Plain text
#: build/C/man3/sysconf.3:109
msgid ""
"We give the name of the variable, the name of the B<sysconf>()  argument "
"used to inquire about its value, and a short description."
msgstr ""
"変数名、その値を取得するのに使われる B<sysconf>()  のパラメータ名、簡単な説明"
"を以下に示す。"

#.  [for the moment: only the things that are unconditionally present]
#.  .TP
#.  .BR AIO_LISTIO_MAX " - " _SC_AIO_LISTIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of I/O operations in a single list I/O call.
#.  Must not be less than _POSIX_AIO_LISTIO_MAX.
#.  .TP
#.  .BR AIO_MAX " - " _SC_AIO_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  Maximum number of outstanding asynchronous I/O operations.
#.  Must not be less than _POSIX_AIO_MAX.
#.  .TP
#.  .BR AIO_PRIO_DELTA_MAX " - " _SC_AIO_PRIO_DELTA_MAX
#.  (if _POSIX_ASYNCHRONOUS_IO)
#.  The maximum amount by which a process can decrease its
#.  asynchronous I/O priority level from its own scheduling priority.
#.  Must be nonnegative.
#. type: Plain text
#: build/C/man3/sysconf.3:128
msgid "First, the POSIX.1 compatible values."
msgstr "まず POSIX.1 互換の変数を示す。"

#. type: TP
#: build/C/man3/sysconf.3:128
#, no-wrap
msgid "B<ARG_MAX> - B<_SC_ARG_MAX>"
msgstr "B<ARG_MAX> - B<_SC_ARG_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:136
msgid ""
"The maximum length of the arguments to the B<exec>(3)  family of functions.  "
"Must not be less than B<_POSIX_ARG_MAX> (4096)."
msgstr ""
"B<exec>(3)  関数群の引き数の最大長。 B<_POSIX_ARG_MAX> (4096) 未満であっては"
"ならない。"

#. type: TP
#: build/C/man3/sysconf.3:136
#, no-wrap
msgid "B<CHILD_MAX> - B<_SC_CHILD_MAX>"
msgstr "B<CHILD_MAX> - B<_SC_CHILD_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:142
msgid ""
"The maximum number of simultaneous processes per user ID.  Must not be less "
"than B<_POSIX_CHILD_MAX> (25)."
msgstr ""
"ユーザID あたりの同時に存在できるプロセスの最大数。 B<_POSIX_CHILD_MAX> (25) "
"未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:142
#, no-wrap
msgid "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"
msgstr "B<HOST_NAME_MAX> - B<_SC_HOST_NAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:150
msgid ""
"Maximum length of a hostname, not including the terminating null byte, as "
"returned by B<gethostname>(2).  Must not be less than "
"B<_POSIX_HOST_NAME_MAX> (255)."
msgstr ""
"B<gethostname>(2)  で返されるホスト名の最大長。末尾の NULL バイトは長さに含ま"
"れない。 B<_POSIX_HOST_NAME_MAX> (255) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:150
#, no-wrap
msgid "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"
msgstr "B<LOGIN_NAME_MAX> - B<_SC_LOGIN_NAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:156
msgid ""
"Maximum length of a login name, including the terminating null byte.  Must "
"not be less than B<_POSIX_LOGIN_NAME_MAX> (9)."
msgstr ""
"ログイン名の長さの最大値。末尾の NULL バイトも長さに含まれる。 "
"B<_POSIX_LOGIN_NAME_MAX> (9) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:156
#, no-wrap
msgid "clock ticks - B<_SC_CLK_TCK>"
msgstr "clock ticks - B<_SC_CLK_TCK>"

#. type: Plain text
#: build/C/man3/sysconf.3:165
msgid ""
"The number of clock ticks per second.  The corresponding variable is "
"obsolete.  It was of course called B<CLK_TCK>.  (Note: the macro "
"B<CLOCKS_PER_SEC> does not give information: it must equal 1000000.)"
msgstr ""
"1秒あたりのクロックティック数。 対応する変数は廃止された。この変数は当然なが"
"ら B<CLK_TCK> と呼ばれていた。 (注意: マクロ B<CLOCKS_PER_SEC> からは情報は得"
"られない: この値は 1000000 でなければならない)"

#. type: TP
#: build/C/man3/sysconf.3:165
#, no-wrap
msgid "B<OPEN_MAX> - B<_SC_OPEN_MAX>"
msgstr "B<OPEN_MAX> - B<_SC_OPEN_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:171
msgid ""
"The maximum number of files that a process can have open at any time.  Must "
"not be less than B<_POSIX_OPEN_MAX> (20)."
msgstr ""
"一つのプロセスが同時にオープンできるファイル数の上限。 B<_POSIX_OPEN_MAX> "
"(20) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:171
#, no-wrap
msgid "B<PAGESIZE> - B<_SC_PAGESIZE>"
msgstr "B<PAGESIZE> - B<_SC_PAGESIZE>"

#. type: Plain text
#: build/C/man3/sysconf.3:176
msgid ""
"Size of a page in bytes.  Must not be less than 1.  (Some systems use "
"PAGE_SIZE instead.)"
msgstr ""
"バイト単位でのページサイズ。 1 より小さくなってはならない。 (この代わりに "
"PAGE_SIZE を使うシステムもある)"

#. type: TP
#: build/C/man3/sysconf.3:176 build/C/man3/sysconf.3:263
#, no-wrap
msgid "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"
msgstr "B<RE_DUP_MAX> - B<_SC_RE_DUP_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:185
msgid ""
"The number of repeated occurrences of a BRE permitted by B<regexec>(3)  and "
"B<regcomp>(3).  Must not be less than B<_POSIX2_RE_DUP_MAX> (255)."
msgstr ""
"B<regexec>(3)  と B<regcomp>(3)  で許容されている BRE (Basic Regular "
"Expression; 基本正規表現)  の繰り返し出現回数の最大値。 "
"B<_POSIX2_RE_DUP_MAX> (255) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:185
#, no-wrap
msgid "B<STREAM_MAX> - B<_SC_STREAM_MAX>"
msgstr "B<STREAM_MAX> - B<_SC_STREAM_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:194
msgid ""
"The maximum number of streams that a process can have open at any time.  If "
"defined, it has the same value as the standard C macro B<FOPEN_MAX>.  Must "
"not be less than B<_POSIX_STREAM_MAX> (8)."
msgstr ""
"一つのプロセスが同時にオープンできるストリーム数の上限。 定義されていた場合に"
"は、この値は標準 C マクロの B<FOPEN_MAX> と同じである。 B<_POSIX_STREAM_MAX> "
"(8) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:194
#, no-wrap
msgid "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"
msgstr "B<SYMLOOP_MAX> - B<_SC_SYMLOOP_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:202
msgid ""
"The maximum number of symbolic links seen in a pathname before resolution "
"returns B<ELOOP>.  Must not be less than B<_POSIX_SYMLOOP_MAX> (8)."
msgstr ""
"パス名の解決時に現れてもよいシンボリックリンクの最大数。 この数を超えると、パ"
"ス名解決時に B<ELOOP> が返される。 B<_POSIX_SYMLOOP_MAX> (8) 未満であってはな"
"らない。"

#. type: TP
#: build/C/man3/sysconf.3:202
#, no-wrap
msgid "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"
msgstr "B<TTY_NAME_MAX> - B<_SC_TTY_NAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:209
msgid ""
"The maximum length of terminal device name, including the terminating null "
"byte.  Must not be less than B<_POSIX_TTY_NAME_MAX> (9)."
msgstr ""
"端末デバイス名の最大長。長さには末尾の NULL バイトも含まれる。 "
"B<_POSIX_TTY_NAME_MAX> (9) 未満であってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:209
#, no-wrap
msgid "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"
msgstr "B<TZNAME_MAX> - B<_SC_TZNAME_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:215
msgid ""
"The maximum number of bytes in a timezone name.  Must not be less than "
"B<_POSIX_TZNAME_MAX> (6)."
msgstr ""
"タイムゾーン名として使えるバイト数の最大値。 B<_POSIX_TZNAME_MAX> (6) 未満で"
"あってはならない。"

#. type: TP
#: build/C/man3/sysconf.3:215
#, no-wrap
msgid "B<_POSIX_VERSION> - B<_SC_VERSION>"
msgstr "B<_POSIX_VERSION> - B<_SC_VERSION>"

#. type: Plain text
#: build/C/man3/sysconf.3:223
msgid ""
"indicates the year and month the POSIX.1 standard was approved in the format "
"B<YYYYMML>; the value B<199009L> indicates the Sept. 1990 revision."
msgstr ""
"POSIX.1 標準が承認された年月。 B<YYYYMML> という書式である。 B<199009L> とい"
"う値は、1990年 9月 改訂であることを示す。"

#. type: SS
#: build/C/man3/sysconf.3:223
#, no-wrap
msgid "POSIX.2 variables"
msgstr "POSIX.2 変数"

#. type: Plain text
#: build/C/man3/sysconf.3:225
msgid "Next, the POSIX.2 values, giving limits for utilities."
msgstr ""
"次に、POSIX.2 の値を示す。 これらは各ユーティリティに対する制限を指定する。"

#. type: TP
#: build/C/man3/sysconf.3:225
#, no-wrap
msgid "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"
msgstr "B<BC_BASE_MAX> - B<_SC_BC_BASE_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:232
msgid "indicates the maximum I<obase> value accepted by the B<bc>(1)  utility."
msgstr "B<bc>(1)  ユーティリティで許容される I<obase> の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:232
#, no-wrap
msgid "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"
msgstr "B<BC_DIM_MAX> - B<_SC_BC_DIM_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:236
msgid ""
"indicates the maximum value of elements permitted in an array by B<bc>(1)."
msgstr "B<bc>(1)  で許容される一つの配列中の要素数の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:236
#, no-wrap
msgid "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"
msgstr "B<BC_SCALE_MAX> - B<_SC_BC_SCALE_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:242
msgid "indicates the maximum I<scale> value allowed by B<bc>(1)."
msgstr "B<bc>(1)  で許される I<scale> の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:242
#, no-wrap
msgid "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"
msgstr "B<BC_STRING_MAX> - B<_SC_BC_STRING_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:246
msgid "indicates the maximum length of a string accepted by B<bc>(1)."
msgstr "B<bc>(1)  で許容される文字列の最大長。"

#. type: TP
#: build/C/man3/sysconf.3:246
#, no-wrap
msgid "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"
msgstr "B<COLL_WEIGHTS_MAX> - B<_SC_COLL_WEIGHTS_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:252
msgid ""
"indicates the maximum numbers of weights that can be assigned to an entry of "
"the B<LC_COLLATE order> keyword in the locale definition file,"
msgstr ""
"ロケール定義ファイル中の B<LC_COLLATE order> キーワードのエントリに割り当て可"
"能な重みの最大値。"

#. type: TP
#: build/C/man3/sysconf.3:252
#, no-wrap
msgid "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"
msgstr "B<EXPR_NEST_MAX> - B<_SC_EXPR_NEST_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:257
msgid ""
"is the maximum number of expressions which can be nested within parentheses "
"by B<expr>(1)."
msgstr "B<expr>(1)  において、括弧で入れ子にできる式の最大数。"

#. type: TP
#: build/C/man3/sysconf.3:257
#, no-wrap
msgid "B<LINE_MAX> - B<_SC_LINE_MAX>"
msgstr "B<LINE_MAX> - B<_SC_LINE_MAX>"

#. type: Plain text
#: build/C/man3/sysconf.3:263
msgid ""
"The maximum length of a utility's input line, either from standard input or "
"from a file.  This includes space for a trailing newline."
msgstr ""
"ユーティリティの入力行の最大長。標準入力だけでなく、ファイルからの入力にも 適"
"用される。長さには行の末尾の改行文字も含まれる。"

#. type: Plain text
#: build/C/man3/sysconf.3:269
msgid ""
"The maximum number of repeated occurrences of a regular expression when the "
"interval notation B<\\e{m,n\\e}> is used."
msgstr ""
"正規表現で区間表記 (interval notation)  B<\\e{m,n\\e}> が使用されたときに許容"
"される繰り返し出現回数の最大値。"

#. type: TP
#: build/C/man3/sysconf.3:269
#, no-wrap
msgid "B<POSIX2_VERSION> - B<_SC_2_VERSION>"
msgstr "B<POSIX2_VERSION> - B<_SC_2_VERSION>"

#. type: Plain text
#: build/C/man3/sysconf.3:273
msgid "indicates the version of the POSIX.2 standard in the format of YYYYMML."
msgstr "POSIX.2 標準のバージョン。YYYYMML という書式で表記される。"

#. type: TP
#: build/C/man3/sysconf.3:273
#, no-wrap
msgid "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"
msgstr "B<POSIX2_C_DEV> - B<_SC_2_C_DEV>"

#. type: Plain text
#: build/C/man3/sysconf.3:277
msgid ""
"indicates whether the POSIX.2 C language development facilities are "
"supported."
msgstr "POSIX.2 の C 言語開発機能がサポートされているかを示す。"

#. type: TP
#: build/C/man3/sysconf.3:277
#, no-wrap
msgid "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"
msgstr "B<POSIX2_FORT_DEV> - B<_SC_2_FORT_DEV>"

#. type: Plain text
#: build/C/man3/sysconf.3:281
msgid ""
"indicates whether the POSIX.2 FORTRAN development utilities are supported."
msgstr "POSIX.2 の FORTRAN 開発ユーティリティがサポートされているかを示す。"

#. type: TP
#: build/C/man3/sysconf.3:281
#, no-wrap
msgid "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"
msgstr "B<POSIX2_FORT_RUN> - B<_SC_2_FORT_RUN>"

#. type: Plain text
#: build/C/man3/sysconf.3:284
msgid "indicates whether the POSIX.2 FORTRAN run-time utilities are supported."
msgstr ""
"POSIX.2 の FORTRAN ランタイムユーティリティがサポートされているかを示す。"

#. type: TP
#: build/C/man3/sysconf.3:284
#, no-wrap
msgid "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"
msgstr "B<_POSIX2_LOCALEDEF> - B<_SC_2_LOCALEDEF>"

#. type: Plain text
#: build/C/man3/sysconf.3:289
msgid ""
"indicates whether the POSIX.2 creation of locates via B<localedef>(1)  is "
"supported."
msgstr ""
"B<localedef>(1)  を使った、POSIX.2 のロケールの作成をサポートしているかを示"
"す。"

#. type: TP
#: build/C/man3/sysconf.3:289
#, no-wrap
msgid "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"
msgstr "B<POSIX2_SW_DEV> - B<_SC_2_SW_DEV>"

#. type: Plain text
#: build/C/man3/sysconf.3:293
msgid ""
"indicates whether the POSIX.2 software development utilities option is "
"supported."
msgstr ""
"POSIX.2 ソフトウェア開発ユーティリティオプションがサポートされているかを示"
"す。"

#. type: Plain text
#: build/C/man3/sysconf.3:295
msgid "These values also exist, but may not be standard."
msgstr "以下の値も存在するが、標準には含まれていない。"

#. type: TP
#: build/C/man3/sysconf.3:295
#, no-wrap
msgid " - B<_SC_PHYS_PAGES>"
msgstr " - B<_SC_PHYS_PAGES>"

#. type: Plain text
#: build/C/man3/sysconf.3:302
msgid ""
"The number of pages of physical memory.  Note that it is possible for the "
"product of this value and the value of B<_SC_PAGESIZE> to overflow."
msgstr ""
"物理メモリのページ数。 この値と B<_SC_PAGESIZE> 値の積は桁溢れする可能性があ"
"るので注意すること。"

#. type: TP
#: build/C/man3/sysconf.3:302
#, no-wrap
msgid " - B<_SC_AVPHYS_PAGES>"
msgstr " - B<_SC_AVPHYS_PAGES>"

#. type: Plain text
#: build/C/man3/sysconf.3:305
msgid "The number of currently available pages of physical memory."
msgstr "現在利用可能な物理メモリのページ数。"

#. type: TP
#: build/C/man3/sysconf.3:305
#, no-wrap
msgid " - B<_SC_NPROCESSORS_CONF>"
msgstr " - B<_SC_NPROCESSORS_CONF>"

#. type: Plain text
#: build/C/man3/sysconf.3:308
msgid "The number of processors configured."
msgstr "設定されたプロセッサ数。"

#. type: TP
#: build/C/man3/sysconf.3:308
#, no-wrap
msgid " - B<_SC_NPROCESSORS_ONLN>"
msgstr " - B<_SC_NPROCESSORS_ONLN>"

#. type: Plain text
#: build/C/man3/sysconf.3:311
msgid "The number of processors currently online (available)."
msgstr "現在オンラインの (利用可能な) プロセッサ数。"

#. type: Plain text
#: build/C/man3/sysconf.3:324
msgid ""
"If I<name> is invalid, -1 is returned, and I<errno> is set to B<EINVAL>.  "
"Otherwise, the value returned is the value of the system resource and "
"I<errno> is not changed.  In the case of options, a positive value is "
"returned if a queried option is available, and -1 if it is not.  In the case "
"of limits, -1 means that there is no definite limit."
msgstr ""
"I<name> が不正な場合、-1 が返され、 I<errno> に B<EINVAL> が設定される。 それ"
"以外の場合、システムリソースの値が返り値として返され、 I<errno> は変更されな"
"い。問い合わせがオプションについてであれば、 そのオプションが利用できるときは"
"正の値が返され、 利用できないときは -1 が返される。問い合わせが 制限について"
"場合は、制限が設定されていないときに -1 が返される。"

#. type: Plain text
#: build/C/man3/sysconf.3:332
msgid ""
"It is difficult to use B<ARG_MAX> because it is not specified how much of "
"the argument space for B<exec>(3)  is consumed by the user's environment "
"variables."
msgstr ""
"B<ARG_MAX> を使うのは難しい、なぜなら、 B<exec>(3)  の引き数領域 (argument "
"space) のうちどれくらいが ユーザの環境変数によって使われるかは分からないから"
"である。"

#. type: Plain text
#: build/C/man3/sysconf.3:343
msgid ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<fpathconf>(3), "
"B<pathconf>(3), B<posixoptions>(7)"
msgstr ""
"B<bc>(1), B<expr>(1), B<getconf>(1), B<locale>(1), B<fpathconf>(3), "
"B<pathconf>(3), B<posixoptions>(7)"

#. type: TH
#: build/C/man2/sysctl.2:30
#, no-wrap
msgid "SYSCTL"
msgstr "SYSCTL"

#. type: TH
#: build/C/man2/sysctl.2:30
#, no-wrap
msgid "2012-12-22"
msgstr "2012-12-22"

#. type: Plain text
#: build/C/man2/sysctl.2:33
msgid "sysctl - read/write system parameters"
msgstr "sysctl - システムパラメーターを読み書きする"

#. type: Plain text
#: build/C/man2/sysctl.2:38
#, no-wrap
msgid "B<#include E<lt>linux/sysctl.hE<gt>>\n"
msgstr "B<#include E<lt>linux/sysctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/sysctl.2:40
#, no-wrap
msgid "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"
msgstr "B<int _sysctl(struct __sysctl_args *>I<args>B<);>\n"

#. type: Plain text
#: build/C/man2/sysctl.2:47
msgid "B<Do not use this system call!> See NOTES."
msgstr "B<このシステムコールを使用しないこと!> 「注意」の節を参照。"

#. type: Plain text
#: build/C/man2/sysctl.2:54
msgid ""
"The B<_sysctl>()  call reads and/or writes kernel parameters.  For example, "
"the hostname, or the maximum number of open files.  The argument has the form"
msgstr ""
"B<_sysctl>()  コールはカーネルパラメーターを読み書きする。例えば、 ホストネー"
"ムや同時にオープンできるファイルの最大数など。 引き数は以下の形式である。"

#. type: Plain text
#: build/C/man2/sysctl.2:66
#, no-wrap
msgid ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"
msgstr ""
"struct __sysctl_args {\n"
"    int    *name;    /* integer vector describing variable */\n"
"    int     nlen;    /* length of this vector */\n"
"    void   *oldval;  /* 0 or address where to store old value */\n"
"    size_t *oldlenp; /* available room for old value,\n"
"                        overwritten by actual size of old value */\n"
"    void   *newval;  /* 0 or address of new value */\n"
"    size_t  newlen;  /* size of new value */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sysctl.2:74
msgid ""
"This call does a search in a tree structure, possibly resembling a directory "
"tree under I</proc/sys>, and if the requested item is found calls some "
"appropriate routine to read or modify the value."
msgstr ""
"このコールは I</proc/sys> の下のディレクトリツリーに似た木構造(tree "
"structure)を検索する。 そして、要求された項目が見つかった場合は適切なルーチン"
"を呼び出して 値を読んだり修正したりする。"

#. type: Plain text
#: build/C/man2/sysctl.2:81
msgid ""
"Upon successful completion, B<_sysctl>()  returns 0.  Otherwise, a value of "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功した場合は B<_sysctl>()  は 0 を返す。失敗した場合、-1 が返され、 "
"I<errno> がそのエラーを示す値に設定される。"

#. type: Plain text
#: build/C/man2/sysctl.2:88
msgid ""
"The invocation asked for the previous value by setting I<oldval> non-NULL, "
"but allowed zero room in I<oldlenp>."
msgstr ""
"I<oldval> に NULL でない値を設定して、以前の値を要求しているのに、 "
"I<oldlenp> に空きがない。"

#. type: Plain text
#: build/C/man2/sysctl.2:92
msgid "I<name> was not found."
msgstr "I<name> が見つからなかった。"

#. type: TP
#: build/C/man2/sysctl.2:92
#, no-wrap
msgid "B<EACCES>, B<EPERM>"
msgstr "B<EACCES> か B<EPERM>"

#. type: Plain text
#: build/C/man2/sysctl.2:100
msgid ""
"No search permission for one of the encountered \"directories\", or no read "
"permission where I<oldval> was nonzero, or no write permission where "
"I<newval> was nonzero."
msgstr ""
"「ディレクトリ」のどれかに検索許可がなかったか、 I<oldval> が 0 でないのに読"
"み込み許可がなかったか、 I<newval> が 0 でないのに書き込み許可がなかった。"

#. type: Plain text
#: build/C/man2/sysctl.2:114
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable.  A B<sysctl>()  call has been present in Linux since version "
"1.3.57.  It originated in 4.4BSD.  Only Linux has the I</proc/sys> mirror, "
"and the object naming schemes differ between Linux and 4.4BSD, but the "
"declaration of the B<sysctl>()  function is the same in both."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで使用しては いけな"
"い。 B<sysctl>()  コールは Linux のバージョン 1.3.57 から存在している。 これ"
"は 4.4BSD に由来している。Linux は I</proc/sys> に写し(mirror)をもっており、"
"項目の名前の付け方が Linux と 4.4BSD では 異っている。しかし B<sysctl>()  関"
"数の宣言は両方で同じである。"

#.  See http://lwn.net/Articles/247243/
#.  Though comments in suggest that it is needed by old glibc binaries,
#.  so maybe it's not going away.
#. type: Plain text
#: build/C/man2/sysctl.2:131
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  Or rather...  I<don't> call it: use of this system call has "
"long been discouraged, and it is so unloved that B<it is likely to disappear "
"in a future kernel version>.  Since Linux 2.6.24, uses of this system call "
"result in warnings in the kernel log.  Remove it from your programs now; use "
"the I</proc/sys> interface instead."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2) を使って呼び出すこと。というよりは・・・このシステムコールを呼び出さない"
"こと。 長い間このシステムコールの使用は非推奨とされており、 「将来のバージョ"
"ンのカーネルで削除されるようだ」と言われるほどである。 あなたのプログラムにこ"
"のシステムコールがあれば、すぐにでも削除すること。 代わりに I</proc/sys> イン"
"ターフェースを使用すること。"

#. type: Plain text
#: build/C/man2/sysctl.2:135
msgid ""
"This system call is available only if the kernel was configured with the "
"B<CONFIG_SYSCTL_SYSCALL> option."
msgstr ""
"このシステムコールは、カーネルの B<CONFIG_SYSCTL_SYSCALL> オプションが有効に"
"なっている場合のみ利用できる。"

#. type: Plain text
#: build/C/man2/sysctl.2:138
msgid ""
"The object names vary between kernel versions, making this system call "
"worthless for applications."
msgstr ""
"オブジェクトの名前は、カーネルのバージョンごとに異なっている。 このため、この"
"システムコールはアプリケーションにとって 無価値なものとなっている。"

#. type: Plain text
#: build/C/man2/sysctl.2:140
msgid "Not all available objects are properly documented."
msgstr "全ての可能な項目が正確に記述されているわけではない。"

#. type: Plain text
#: build/C/man2/sysctl.2:143
msgid ""
"It is not yet possible to change operating system by writing to I</proc/sys/"
"kernel/ostype>."
msgstr ""
"今のところ I</proc/sys/kernel/ostype> に書き込むことでオペーレーティングシス"
"テムを変えることはできない。"

#. type: Plain text
#: build/C/man2/sysctl.2:152
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/syscall.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>linux/sysctl.hE<gt>\n"

#. type: Plain text
#: build/C/man2/sysctl.2:154
#, no-wrap
msgid "int _sysctl(struct __sysctl_args *args );\n"
msgstr "int _sysctl(struct __sysctl_args *args );\n"

#. type: Plain text
#: build/C/man2/sysctl.2:156
#, no-wrap
msgid "#define OSNAMESZ 100\n"
msgstr "#define OSNAMESZ 100\n"

#. type: Plain text
#: build/C/man2/sysctl.2:164
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct __sysctl_args args;\n"
"    char osname[OSNAMESZ];\n"
"    size_t osnamelth;\n"
"    int name[] = { CTL_KERN, KERN_OSTYPE };\n"

#. type: Plain text
#: build/C/man2/sysctl.2:170
#, no-wrap
msgid ""
"    memset(&args, 0, sizeof(struct __sysctl_args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"
msgstr ""
"    memset(&args, 0, sizeof(struct __sysctl_args));\n"
"    args.name = name;\n"
"    args.nlen = sizeof(name)/sizeof(name[0]);\n"
"    args.oldval = osname;\n"
"    args.oldlenp = &osnamelth;\n"

#. type: Plain text
#: build/C/man2/sysctl.2:172
#, no-wrap
msgid "    osnamelth = sizeof(osname);\n"
msgstr "    osnamelth = sizeof(osname);\n"

#. type: Plain text
#: build/C/man2/sysctl.2:180
#, no-wrap
msgid ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (syscall(SYS__sysctl, &args) == -1) {\n"
"        perror(\"_sysctl\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"    printf(\"This machine is running %*s\\en\", osnamelth, osname);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/sysctl.2:183 build/C/man2/sysinfo.2:96
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: build/C/man2/sysinfo.2:14
#, no-wrap
msgid "SYSINFO"
msgstr "SYSINFO"

#. type: TH
#: build/C/man2/sysinfo.2:14
#, no-wrap
msgid "2012-05-05"
msgstr "2012-05-05"

#. type: Plain text
#: build/C/man2/sysinfo.2:17
msgid "sysinfo - returns information on overall system statistics"
msgstr "sysinfo - システム全体の統計情報を返す。"

#. type: Plain text
#: build/C/man2/sysinfo.2:21
msgid "B<int sysinfo(struct sysinfo *>I<info>B<);>"
msgstr "B<int sysinfo(struct sysinfo *>I<info>B<);>"

#. type: Plain text
#: build/C/man2/sysinfo.2:25
msgid ""
"Until Linux 2.3.16, B<sysinfo>()  used to return information in the "
"following structure:"
msgstr "Linux 2.3.16 までは B<sysinfo>()  は以下の構造体に情報を入れて返す。"

#. type: Plain text
#: build/C/man2/sysinfo.2:40
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"
msgstr ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    char _f[22];             /* Pads structure to 64 bytes */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sysinfo.2:44
msgid "and the sizes were given in bytes."
msgstr "ここでバイト単位で与えられる。"

#. type: Plain text
#: build/C/man2/sysinfo.2:47
msgid "Since Linux 2.3.23 (i386), 2.3.48 (all architectures) the structure is:"
msgstr "Linux 2.3.23 (i386)、2.3.48 (全てのアーキテクチャ) からは構造体は"

#. type: Plain text
#: build/C/man2/sysinfo.2:65
#, no-wrap
msgid ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */\n"
"};\n"
msgstr ""
"struct sysinfo {\n"
"    long uptime;             /* Seconds since boot */\n"
"    unsigned long loads[3];  /* 1, 5, and 15 minute load averages */\n"
"    unsigned long totalram;  /* Total usable main memory size */\n"
"    unsigned long freeram;   /* Available memory size */\n"
"    unsigned long sharedram; /* Amount of shared memory */\n"
"    unsigned long bufferram; /* Memory used by buffers */\n"
"    unsigned long totalswap; /* Total swap space size */\n"
"    unsigned long freeswap;  /* swap space still available */\n"
"    unsigned short procs;    /* Number of current processes */\n"
"    unsigned long totalhigh; /* Total high memory size */\n"
"    unsigned long freehigh;  /* Available high memory size */\n"
"    unsigned int mem_unit;   /* Memory unit size in bytes */\n"
"    char _f[20-2*sizeof(long)-sizeof(int)]; /* Padding to 64 bytes */\n"
"};\n"

#. type: Plain text
#: build/C/man2/sysinfo.2:69
msgid "and the sizes are given as multiples of I<mem_unit> bytes."
msgstr "となり、大きさは I<mem_unit> バイトの倍数で与えられる。"

#. type: Plain text
#: build/C/man2/sysinfo.2:74
msgid ""
"B<sysinfo>()  provides a simple way of getting overall system statistics.  "
"This is more portable than reading I</dev/kmem>."
msgstr ""
"B<sysinfo>()  はシステム全体の統計を取得する簡単な方法を提供する。 これは I</"
"dev/kmem> を読むよりも移植性の高い方法である。"

#. type: Plain text
#: build/C/man2/sysinfo.2:83
msgid "pointer to I<struct\\ sysinfo> is invalid"
msgstr "I<sysinfo 構造体> へのポインターが不正である。"

#. type: Plain text
#: build/C/man2/sysinfo.2:94
msgid ""
"The Linux kernel has a B<sysinfo>()  system call since 0.98.pl6.  Linux libc "
"contains a B<sysinfo>()  routine since 5.3.5, and glibc has one since 1.90."
msgstr ""
"Linux カーネルは 0.98.pl6 から B<sysinfo>()  システムコールを持っている。 "
"Linux の libc は 5.3.5 より、glibc では 1.90 より B<sysinfo>()  ルーチンを含"
"んでいる。"

#. type: TH
#: build/C/man3/tcgetpgrp.3:25
#, no-wrap
msgid "TCGETPGRP"
msgstr "TCGETPGRP"

#. type: TH
#: build/C/man3/tcgetpgrp.3:25
#, no-wrap
msgid "2014-01-13"
msgstr "2014-01-13"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:28
msgid "tcgetpgrp, tcsetpgrp - get and set terminal foreground process group"
msgstr ""
"tcgetpgrp, tcsetpgrp - 端末のフォアグラウンドプロセスグループの 取得/設定を行"
"う"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:32
msgid "B<pid_t tcgetpgrp(int >I<fd>B<);>"
msgstr "B<pid_t tcgetpgrp(int >I<fd>B<);>"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:34
msgid "B<int tcsetpgrp(int >I<fd>B<, pid_t >I<pgrp>B<);>"
msgstr "B<int tcsetpgrp(int >I<fd>B<, pid_t >I<pgrp>B<);>"

#.  The process itself may be a background process.
#. type: Plain text
#: build/C/man3/tcgetpgrp.3:42
msgid ""
"The function B<tcgetpgrp>()  returns the process group ID of the foreground "
"process group on the terminal associated to I<fd>, which must be the "
"controlling terminal of the calling process."
msgstr ""
"関数 B<tcgetpgrp>()  は、 I<fd> に対応する端末のフォアグラウンドプロセスグ"
"ループの プロセスグループ ID を返す。 I<fd> で指定された端末は、呼び出しを行"
"うプロセスの制御端末でなければならない。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:55
msgid ""
"The function B<tcsetpgrp>()  makes the process group with process group ID "
"I<pgrp> the foreground process group on the terminal associated to I<fd>, "
"which must be the controlling terminal of the calling process, and still be "
"associated with its session.  Moreover, I<pgrp> must be a (nonempty) process "
"group belonging to the same session as the calling process."
msgstr ""
"関数 B<tcsetpgrp>()  は、プロセスグループID が I<pgrp> のプロセスグループを "
"I<fd> に対応する端末のフォアグラウンドプロセスグループにする。 このとき、 "
"I<fd> は B<tcsetpgrp>()  を呼び出すプロセスの制御端末でなければならない。 さ"
"らに、 I<pgrp> は、呼び出しを行うプロセスと同じセッションに 属する (メンバが"
"空でない) プロセスグループでなければならない。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:64
msgid ""
"If B<tcsetpgrp>()  is called by a member of a background process group in "
"its session, and the calling process is not blocking or ignoring B<SIGTTOU>, "
"a B<SIGTTOU> signal is sent to all members of this background process group."
msgstr ""
"B<tcsetpgrp>()  がセッションに属するバックグラウンドグループプロセスのメンバ"
"から 呼び出され、かつ呼び出しを行うプロセスが B<SIGTTOU> をブロックしたり 無"
"視したりするようになっていない場合、 B<SIGTTOU> シグナルは バックグラウンドプ"
"ロセスグループの全てのメンバに送られる。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:79
msgid ""
"When I<fd> refers to the controlling terminal of the calling process, the "
"function B<tcgetpgrp>()  will return the foreground process group ID of that "
"terminal if there is one, and some value larger than 1 that is not presently "
"a process group ID otherwise.  When I<fd> does not refer to the controlling "
"terminal of the calling process, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"I<fd> が呼び出しを行ったプロセスの制御端末を参照している場合、関数 "
"B<tcgetpgrp>()  は、その制御端末のフォアグラウンドプロセスグループがあれば そ"
"のプロセスグループの ID を返す。 そのようなプロセスグループがなければ、現在プ"
"ロセスグループ ID として使用されていない、1より大きな何らかの値が返される。 "
"I<fd> が呼び出しを行ったプロセスの制御端末を参照していない場合、 -1 が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:86
msgid ""
"When successful, B<tcsetpgrp>()  returns 0.  Otherwise, it returns -1, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<tcsetpgrp>()  は 0 を返す。そうでない場合、 -1 を返し、 "
"I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:95
msgid "I<pgrp> has an unsupported value."
msgstr "I<pgrp> が無効な値である。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:104
msgid ""
"The calling process does not have a controlling terminal, or it has one but "
"it is not described by I<fd>, or, for B<tcsetpgrp>(), this controlling "
"terminal is no longer associated with the session of the calling process."
msgstr ""
"呼び出しを行ったプロセスが制御端末を持っていない、もしくは 制御端末を持ってい"
"るが I<fd> で参照されるものとは異なる、 B<tcsetpgrp>()  の場合は、 I<fd> で指"
"定された制御端末がすでに呼び出しを行ったプロセスのセッション と関係のないもの"
"になっている際にも、このエラーとなる。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:109
msgid ""
"I<pgrp> has a supported value, but is not the process group ID of a process "
"in the same session as the calling process."
msgstr ""
"I<pgrp> が有効な値だが、呼び出しを行ったプロセスと同じセッションに属する プロ"
"セスのプロセスグループ ID には該当するものがない。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:116
msgid "The B<tcgetpgrp>()  and B<tcsetpgrp>()  functions are thread-safe."
msgstr "関数 B<tcgetpgrp>() と B<tcsetpgrp>() はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:124
msgid ""
"These functions are implemented via the B<TIOCGPGRP> and B<TIOCSPGRP> ioctls."
msgstr "この関数は B<TIOCGPGRP> と B<TIOCGSID> の ioctl 経由で実現されている。"

#. type: SS
#: build/C/man3/tcgetpgrp.3:124 build/C/man2/vfork.2:234
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:127
msgid "The ioctls appeared in 4.2BSD.  The functions are POSIX inventions."
msgstr ""
"これらの ioctl は 4.2BSD で登場した。 これらの関数は POSIX で考案されたもので"
"ある。"

#. type: Plain text
#: build/C/man3/tcgetpgrp.3:131
msgid "B<setpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr "B<setpgid>(2), B<setsid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/truncate.2:43
#, no-wrap
msgid "TRUNCATE"
msgstr "TRUNCATE"

#. type: TH
#: build/C/man2/truncate.2:43
#, no-wrap
msgid "2013-04-01"
msgstr "2013-04-01"

#. type: Plain text
#: build/C/man2/truncate.2:46
msgid "truncate, ftruncate - truncate a file to a specified length"
msgstr "truncate, ftruncate - 指定した長さにファイルを切り詰める"

#. type: Plain text
#: build/C/man2/truncate.2:52
msgid "B<int truncate(const char *>I<path>B<, off_t >I<length>B<);>"
msgstr "B<int truncate(const char *>I<path>B<, off_t >I<length>B<);>"

#. type: Plain text
#: build/C/man2/truncate.2:54
msgid "B<int ftruncate(int >I<fd>B<, off_t >I<length>B<);>"
msgstr "B<int ftruncate(int >I<fd>B<, off_t >I<length>B<);>"

#. type: Plain text
#: build/C/man2/truncate.2:63
msgid "B<truncate>():"
msgstr "B<truncate>():"

#. type: Plain text
#: build/C/man2/truncate.2:71
msgid "B<ftruncate>():"
msgstr "B<ftruncate>():"

#. type: Plain text
#: build/C/man2/truncate.2:76
msgid "|| /* Since glibc 2.3.5: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "|| /* glibc 2.3.5 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man2/truncate.2:91
msgid ""
"The B<truncate>()  and B<ftruncate>()  functions cause the regular file "
"named by I<path> or referenced by I<fd> to be truncated to a size of "
"precisely I<length> bytes."
msgstr ""
"B<truncate>()  は I<path> で指定されるファイルを、 B<ftruncate>()  は I<fd> "
"で参照されるファイルを I<length> バイトの長さになるように延長する、もしくは切"
"り詰める。"

#. type: Plain text
#: build/C/man2/truncate.2:95
msgid ""
"If the file previously was larger than this size, the extra data is lost.  "
"If the file previously was shorter, it is extended, and the extended part "
"reads as null bytes (\\(aq\\e0\\(aq)."
msgstr ""
"もし切り詰める前のファイルが I<length> より長ければ、length バイトを越える部"
"分のデータは失われる。 もし切り詰める前のファイルが I<length> より短かけれ"
"ば、伸張される。 伸張された部分を読んだ場合は NULL バイト (\\(aq\\e0\\(aq) の"
"列が返される。"

#. type: Plain text
#: build/C/man2/truncate.2:97
msgid "The file offset is not changed."
msgstr "ファイルオフセットは変更されない。"

#. type: Plain text
#: build/C/man2/truncate.2:104
msgid ""
"If the size changed, then the st_ctime and st_mtime fields (respectively, "
"time of last status change and time of last modification; see B<stat>(2))  "
"for the file are updated, and the set-user-ID and set-group-ID permission "
"bits may be cleared."
msgstr ""
"大きさが変更されると、ファイルの st_ctime と st_mtime フィールド (それぞれ最"
"終状態変更時刻、最終修正時刻; B<stat>(2)  参照) が更新される。 また、set-"
"user-ID と set-group-ID の許可ビットがクリアされるかもしれない。"

#. type: Plain text
#: build/C/man2/truncate.2:110
msgid ""
"With B<ftruncate>(), the file must be open for writing; with B<truncate>(), "
"the file must be writable."
msgstr ""
"B<ftruncate>()  の場合、ファイルは書き込み用に開いていなければならない。 "
"B<truncate>()  の場合、ファイルは書き込み可能でなければならない。"

#. type: Plain text
#: build/C/man2/truncate.2:118
msgid "For B<truncate>():"
msgstr "B<truncate>()  では以下のエラーコードが定義されている。"

#. type: Plain text
#: build/C/man2/truncate.2:124
msgid ""
"Search permission is denied for a component of the path prefix, or the named "
"file is not writable by the user.  (See also B<path_resolution>(7).)"
msgstr ""
"パスで指定されているディレクトリに検索許可のないものがある (訳注:x ビットが"
"立っていない)。 あるいは、指定されたファイルに対する書き込み許可を持っていな"
"い。 (B<path_resolution>(7)  も参照のこと)"

#. type: Plain text
#: build/C/man2/truncate.2:128
msgid "I<Path> points outside the process's allocated address space."
msgstr "I<path> がプロセスに割り当てられているアドレス空間外を指している。"

#. type: TP
#: build/C/man2/truncate.2:128
#, no-wrap
msgid "B<EFBIG>"
msgstr "B<EFBIG>"

#. type: Plain text
#: build/C/man2/truncate.2:133
msgid "The argument I<length> is larger than the maximum file size. (XSI)"
msgstr "引き数 I<length> が最大ファイルサイズより大きい。(XSI)"

#. type: Plain text
#: build/C/man2/truncate.2:140
msgid ""
"While blocked waiting to complete, the call was interrupted by a signal "
"handler; see B<fcntl>(2)  and B<signal>(7)."
msgstr ""
"完了待ちで停止 (block) している間に、呼び出しが シグナルハンドラにより割り込"
"まれた。 B<fcntl>(2)  と B<signal>(7)  を参照。"

#. type: Plain text
#: build/C/man2/truncate.2:145
msgid ""
"The argument I<length> is negative or larger than the maximum file size."
msgstr "引き数 I<length> が負数であるか、最大ファイルサイズより大きい。"

#. type: Plain text
#: build/C/man2/truncate.2:148
msgid "An I/O error occurred updating the inode."
msgstr "inode の更新時に I/O エラーが発生した。"

#. type: Plain text
#: build/C/man2/truncate.2:151
msgid "The named file is a directory."
msgstr "指定されたファイルはディレクトリである。"

#. type: Plain text
#: build/C/man2/truncate.2:154
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr "パス名を解釈する際にシンボリックリンクが多すぎた。"

#. type: Plain text
#: build/C/man2/truncate.2:158
msgid ""
"A component of a pathname exceeded 255 characters, or an entire pathname "
"exceeded 1023 characters."
msgstr ""
"パス名中のディレクトリ名が 255 文字を越えている、もしくはパス名全体が 1023 文"
"字を越えている。"

#. type: Plain text
#: build/C/man2/truncate.2:161
msgid "The named file does not exist."
msgstr "指定された名前のファイルが存在しない。"

#.  This happens for at least MSDOS and VFAT filesystems
#.  on kernel 2.6.13
#. type: Plain text
#: build/C/man2/truncate.2:170
msgid ""
"The underlying filesystem does not support extending a file beyond its "
"current size."
msgstr ""
"下層にあるファイルシステムでは、現在のファイル長を越えて ファイルを伸長するこ"
"とができない。"

#. type: Plain text
#: build/C/man2/truncate.2:176
msgid "The file is a pure procedure (shared text) file that is being executed."
msgstr "指定されたファイルは実行されているファイルである。"

#. type: Plain text
#: build/C/man2/truncate.2:183
msgid ""
"For B<ftruncate>()  the same errors apply, but instead of things that can be "
"wrong with I<path>, we now have things that can be wrong with the file "
"descriptor, I<fd>:"
msgstr ""
"B<ftruncate>()  にも同様のエラーが適用される。 但し、 I<path> に関するエラー"
"の場合は、ファイルディスクリプター I<fd> に関するエラーとなる。"

#. type: Plain text
#: build/C/man2/truncate.2:187
msgid "I<fd> is not a valid descriptor."
msgstr "I<fd> が無効なディスクリプターである。"

#. type: TP
#: build/C/man2/truncate.2:187
#, no-wrap
msgid "B<EBADF> or B<EINVAL>"
msgstr "B<EBADF> または B<EINVAL>"

#. type: Plain text
#: build/C/man2/truncate.2:191
msgid "I<fd> is not open for writing."
msgstr "I<fd> で指定されているものが書き込みモードで開かれていない。"

#. type: Plain text
#: build/C/man2/truncate.2:195
msgid "I<fd> does not reference a regular file."
msgstr "I<fd> が通常のファイルを参照していない。"

#.  POSIX.1-1996 has
#.  .BR ftruncate ().
#.  POSIX.1-2001 also has
#.  .BR truncate (),
#.  as an XSI extension.
#.  .LP
#.  SVr4 documents additional
#.  .BR truncate ()
#.  error conditions EMFILE, EMULTIHP, ENFILE, ENOLINK.  SVr4 documents for
#.  .BR ftruncate ()
#.  an additional EAGAIN error condition.
#. type: Plain text
#: build/C/man2/truncate.2:208
msgid "4.4BSD, SVr4, POSIX.1-2001 (these calls first appeared in 4.2BSD)."
msgstr ""
"4.4BSD, SVr4, POSIX.1-2001 (これらのコールは 4.2BSD で初めて登場した)。"

#.  At the very least: OSF/1, Solaris 7, and FreeBSD conform, mtk, Jan 2002
#. type: Plain text
#: build/C/man2/truncate.2:229
msgid ""
"The details in DESCRIPTION are for XSI-compliant systems.  For non-XSI-"
"compliant systems, the POSIX standard allows two behaviors for B<ftruncate>"
"()  when I<length> exceeds the file length (note that B<truncate>()  is not "
"specified at all in such an environment): either returning an error, or "
"extending the file.  Like most UNIX implementations, Linux follows the XSI "
"requirement when dealing with native filesystems.  However, some nonnative "
"filesystems do not permit B<truncate>()  and B<ftruncate>()  to be used to "
"extend a file beyond its current length: a notable example on Linux is VFAT."
msgstr ""
"「説明」の節で述べた詳細は XSI 準拠のシステムについてのものである。\n"
"XSI 非準拠のシステムの場合、POSIX 標準は B<ftruncate>() に対して I<length> "
"が\n"
"ファイルの長さより長かった場合、 エラーを返すかファイルを伸張するかの二つの\n"
"動作を許容している。 B<truncate>() に対しては全く規定されていない。\n"
"ほとんどの UNIX 実装と同様、Linux はネイティブ (Linux 由来) の ファイルシステ"
"ム\n"
"の扱いでは XSI 要求仕様にしたがっている。 しかしながら、いくつかの非ネイティ"
"ブ\n"
"のファイルシステムでは、 B<truncate>() や B<ftruncate>() を使って現在のファイ"
"ル\n"
"長を越えてファイルを伸長することができない。 Linux での有名な例としては\n"
"VFAT がある。"

#. type: Plain text
#: build/C/man2/truncate.2:243
msgid ""
"The original Linux B<truncate>()  and B<ftruncate>()  system calls were not "
"designed to handle large file offsets.  Consequently, Linux 2.4 added "
"B<truncate64>()  and B<ftruncate64>()  system calls that handle large "
"files.  However, these details can be ignored by applications using glibc, "
"whose wrapper functions transparently employ the more recent system calls "
"where they are available."
msgstr ""
"元々の Linux の B<truncate>() と B<ftruncate>() システムコールは\n"
"大きなファイルオフセットを扱えるように設計されていなかった。\n"
"その結果、大きなファイルファイルを扱うことができる B<truncate64>() と "
"B<ftruncate64>()\n"
"システムコールが Linux 2.4 で追加された。\n"
"ただし、glibc を使ったアプリケーションではこれらの詳細は気にする必要はな"
"い。\n"
"glibc のラッパー関数は新しいシステムコールが利用できる場合にはそれらを利用す"
"る\n"
"ようになっているからである。"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=12037
#. type: Plain text
#: build/C/man2/truncate.2:256
msgid ""
"A header file bug in glibc 2.12 meant that the minimum value of "
"B<_POSIX_C_SOURCE> required to expose the declaration of B<ftruncate>()  was "
"200809L instead of 200112L.  This has been fixed in later glibc versions."
msgstr ""
"glibc 2.12 のヘッダファイルにはバグがあり、 B<ftruncate>()  の宣言を公開する"
"のに必要な B<_POSIX_C_SOURCE> の最小値が 200112L ではなく 200809L となってい"
"た。 このバグは、これ以降のバージョンの glibc では修正されている。"

#. type: Plain text
#: build/C/man2/truncate.2:260
msgid "B<open>(2), B<stat>(2), B<path_resolution>(7)"
msgstr "B<open>(2), B<stat>(2), B<path_resolution>(7)"

#. type: TH
#: build/C/man3/ualarm.3:24
#, no-wrap
msgid "UALARM"
msgstr "UALARM"

#. type: TH
#: build/C/man3/ualarm.3:24
#, no-wrap
msgid "2013-12-23"
msgstr "2013-12-23"

#. type: Plain text
#: build/C/man3/ualarm.3:27
msgid "ualarm - schedule signal after given number of microseconds"
msgstr "ualarm - 指定したマイクロ秒後にシグナルを送る予定をする"

#. type: Plain text
#: build/C/man3/ualarm.3:32
#, no-wrap
msgid "B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"
msgstr "B<useconds_t ualarm(useconds_t >I<usecs>B<, useconds_t >I<interval>B<);>\n"

#. type: Plain text
#: build/C/man3/ualarm.3:40
msgid "B<ualarm>():"
msgstr "B<ualarm>():"

#. type: Plain text
#: build/C/man3/ualarm.3:69
msgid ""
"The B<ualarm>()  function causes the signal B<SIGALRM> to be sent to the "
"invoking process after (not less than)  I<usecs> microseconds.  The delay "
"may be lengthened slightly by any system activity or by the time spent "
"processing the call or by the granularity of system timers."
msgstr ""
"B<ualarm>()  関数は、呼び出し元のプロセスに対して I<usecs> マイクロ秒 (以上) "
"後に B<SIGALRM> シグナルを送る。 遅れはシステムの活性度・呼び出しの処理時"
"間・ システムタイマーの粒度によって長くなるかもしれない。"

#. type: Plain text
#: build/C/man3/ualarm.3:73
msgid ""
"Unless caught or ignored, the B<SIGALRM> signal will terminate the process."
msgstr ""
"捕捉または無視されない限り、 B<SIGALRM> シグナルはプロセスを終了させる。"

#. type: Plain text
#: build/C/man3/ualarm.3:81
msgid ""
"If the I<interval> argument is nonzero, further B<SIGALRM> signals will be "
"sent every I<interval> microseconds after the first."
msgstr ""
"I<interval> 引き数が 0 でない場合、最初の B<SIGALRM> シグナルの後、 さらに "
"I<interval> マイクロ秒毎に SIGALRM シグナルが送られる。"

#. type: Plain text
#: build/C/man3/ualarm.3:84
msgid ""
"This function returns the number of microseconds remaining for any alarm "
"that was previously set, or 0 if no alarm was pending."
msgstr ""
"この関数は、過去に設定された alarm の残りマイクロ秒数を返す。 実行中の alarm "
"がない場合は 0 を返す。"

#. type: Plain text
#: build/C/man3/ualarm.3:88
msgid "Interrupted by a signal."
msgstr "シグナルによって割り込まれた。"

#. type: Plain text
#: build/C/man3/ualarm.3:92
msgid ""
"I<usecs> or I<interval> is not smaller than 1000000.  (On systems where that "
"is considered an error.)"
msgstr ""
"I<usecs> または I<interval> が 1000000 未満でない (これがエラーとして扱われる"
"システムの場合)。"

#. type: Plain text
#: build/C/man3/ualarm.3:97
msgid "The B<ualarm>()  function is thread-safe."
msgstr "B<ualarm>() 関数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/ualarm.3:105
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 marks B<ualarm>()  as obsolete.  "
"POSIX.1-2008 removes the specification of B<ualarm>().  4.3BSD, SUSv2, and "
"POSIX do not define any errors."
msgstr ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 では B<ualarm>()  は過去のものとされてい"
"る。 POSIX.1-2008 では、 B<ualarm>()  の仕様が削除されている。 4.3BSD, "
"SUSv2, POSIX はエラーを定義していない。"

#.  This case is not documented in HP-US, Solar, FreeBSD, NetBSD, or OpenBSD!
#. type: Plain text
#: build/C/man3/ualarm.3:112
msgid ""
"POSIX.1-2001 does not specify what happens if the I<usecs> argument is 0.  "
"On Linux (and probably most other systems), the effect is to cancel any "
"pending alarm."
msgstr ""
"POSIX.1-2001 では、 I<usecs> 引き数が 0 の場合、何が起こるかは規定されていな"
"い。 Linux (やおそらく他ほとんどのシステム) では、 I<usecs> 引き数が 0 の場"
"合、処理待ちのアラームがキャンセルされる。"

#. type: Plain text
#: build/C/man3/ualarm.3:125
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  On the original BSD implementation, and "
"in glibc before version 2.1, the arguments to B<ualarm>()  were instead "
"typed as I<unsigned int>.  Programs will be more portable if they never "
"mention I<useconds_t> explicitly."
msgstr ""
"I<useconds_t> 型は [0,1000000] の範囲の整数を保持できる符号なし整数型であ"
"る。 もともとの BSD での実装や、バージョン 2.1 より前の glibc では、 "
"B<ualarm>()  の引き数の型は I<unsigned int> であった。 プログラム中に明示的"
"に I<useconds_t> と書かない方が、移植性が高くなる。"

#. type: Plain text
#: build/C/man3/ualarm.3:139
msgid ""
"The interaction of this function with other timer functions such as B<alarm>"
"(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), B<timer_create>(2), "
"B<timer_delete>(2), B<timer_getoverrun>(2), B<timer_gettime>(2), "
"B<timer_settime>(2), B<usleep>(3)  is unspecified."
msgstr ""
"この関数と B<alarm>(2), B<sleep>(3), B<nanosleep>(2), B<setitimer>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>(2), "
"B<timer_gettime>(2), B<timer_settime>(2), B<usleep>(3)  のような他のタイマー"
"関数との相互作用は規定されていない。"

#. type: Plain text
#: build/C/man3/ualarm.3:147
msgid ""
"This function is obsolete.  Use B<setitimer>(2)  or POSIX interval timers "
"(B<timer_create>(2), etc.)  instead."
msgstr ""
"この関数は廃止予定である。 代わりに B<setitimer>(2)  もしくは POSIX インター"
"バルタイマ (B<timer_create>(2)  など) を使うこと。"

#. type: Plain text
#: build/C/man3/ualarm.3:155
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), B<setitimer>"
"(2), B<usleep>(3), B<time>(7)"
msgstr ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), B<setitimer>"
"(2), B<usleep>(3), B<time>(7)"

#. type: TH
#: build/C/man2/umask.2:34
#, no-wrap
msgid "UMASK"
msgstr "UMASK"

#. type: TH
#: build/C/man2/umask.2:34
#, no-wrap
msgid "2008-01-09"
msgstr "2008-01-09"

#. type: Plain text
#: build/C/man2/umask.2:37
msgid "umask - set file mode creation mask"
msgstr "umask - ファイルモード作成マスクを設定する"

#. type: Plain text
#: build/C/man2/umask.2:43
msgid "B<mode_t umask(mode_t >I<mask>B<);>"
msgstr "B<mode_t umask(mode_t >I<mask>B<);>"

#. type: Plain text
#: build/C/man2/umask.2:50
msgid ""
"B<umask>()  sets the calling process's file mode creation mask (umask) to "
"I<mask> & 0777 (i.e., only the file permission bits of I<mask> are used), "
"and returns the previous value of the mask."
msgstr ""
"B<umask>()  は、呼び出し元プロセスのファイルモード作成マスク (umask) を "
"I<mask> & 0777 に設定し (I<umask> のファイル許可に対応するビットのみを使用す"
"る)、 変更前のマスク値を返す。"

#.  e.g., mkfifo(), creat(), mknod(), sem_open(), mq_open(), shm_open()
#.  but NOT the System V IPC *get() calls
#. type: Plain text
#: build/C/man2/umask.2:65
msgid ""
"The umask is used by B<open>(2), B<mkdir>(2), and other system calls that "
"create files to modify the permissions placed on newly created files or "
"directories.  Specifically, permissions in the umask are turned off from the "
"I<mode> argument to B<open>(2)  and B<mkdir>(2)."
msgstr ""
"umask は、 B<open>(2), B<mkdir>(2)  やファイル作成を行うその他のシステムコー"
"ルで、 新しく作成されるファイルやディレクトリの許可 (permission) を 修正する"
"ために使用される。 具体的には umask に設定されている許可が B<open>(2)  や "
"B<mkdir>(2)  の I<mode> 引き数から取り消される。"

#. type: Plain text
#: build/C/man2/umask.2:70
msgid ""
"The constants that should be used to specify I<mask> are described under "
"B<stat>(2)."
msgstr ""
"I<mask> に指定するのに使用すべき定数については B<stat>(2)  で説明されている。"

#. type: Plain text
#: build/C/man2/umask.2:79
msgid ""
"The typical default value for the process umask is I<S_IWGRP\\ |\\ S_IWOTH> "
"(octal 022).  In the usual case where the I<mode> argument to B<open>(2)  is "
"specified as:"
msgstr ""
"プロセスの umask のよくあるデフォルト値は I<S_IWGRP\\ |\\ S_IWOTH> (8進で "
"022) である。 新しいファイルを作成する際に B<open>(2)  の I<mode> 引き数に"

#. type: Plain text
#: build/C/man2/umask.2:82
#, no-wrap
msgid "    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"
msgstr "    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH\n"

#. type: Plain text
#: build/C/man2/umask.2:86
msgid ""
"(octal 0666) when creating a new file, the permissions on the resulting file "
"will be:"
msgstr "を指定するというよくあるケースでは、作成されたファイルは"

#. type: Plain text
#: build/C/man2/umask.2:89
#, no-wrap
msgid "    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"
msgstr "    S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH\n"

#. type: Plain text
#: build/C/man2/umask.2:92
msgid "(because 0666 & ~022 = 0644; i.e., rw-r--r--)."
msgstr ""
"という許可を持つことになる (なぜなら 0666 & ~022 = 0644、つまり rw-r--r--)。"

#. type: Plain text
#: build/C/man2/umask.2:95
msgid ""
"This system call always succeeds and the previous value of the mask is "
"returned."
msgstr "このシステムコールは必ず成功し、以前の umask 値を返す。"

#. type: Plain text
#: build/C/man2/umask.2:103
msgid ""
"A child process created via B<fork>(2)  inherits its parent's umask.  The "
"umask is left unchanged by B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスの umask を継承する。 "
"B<execve>(2)  によって umask は変更されない。"

#. type: Plain text
#: build/C/man2/umask.2:118
msgid ""
"The umask setting also affects the permissions assigned to POSIX IPC objects "
"(B<mq_open>(3), B<sem_open>(3), B<shm_open>(3)), FIFOs (B<mkfifo>(3)), and "
"UNIX domain sockets (B<unix>(7))  created by the process.  The umask does "
"not affect the permissions assigned to System V IPC objects created by the "
"process (using B<msgget>(2), B<semget>(2), B<shmget>(2))."
msgstr ""
"umask の設定は、そのプロセスが生成する POSIX IPC オブジェクト (B<mq_open>"
"(3), B<sem_open>(3), B<shm_open>(3))  や FIFO (B<mkfifo>(3))、 UNIX ドメイン"
"ソケット (B<unix>(7))  に設定される許可にも影響を与える。 一方、umask は、そ"
"のプロセスが (B<msgget>(2), B<semget>(2), B<shmget>(2)  を使って) 生成する "
"System V IPC オブジェクトに設定される許可には 影響を与えない。"

#. type: Plain text
#: build/C/man2/umask.2:124
msgid "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"
msgstr "B<chmod>(2), B<mkdir>(2), B<open>(2), B<stat>(2), B<acl>(5)"

#. type: TH
#: build/C/man2/uname.2:27
#, no-wrap
msgid "UNAME"
msgstr "UNAME"

#. type: Plain text
#: build/C/man2/uname.2:30
msgid "uname - get name and information about current kernel"
msgstr "uname - 現在稼働中のカーネルについての名前と情報を得る"

#. type: Plain text
#: build/C/man2/uname.2:32
msgid "B<#include E<lt>sys/utsname.hE<gt>>"
msgstr "B<#include E<lt>sys/utsname.hE<gt>>"

#. type: Plain text
#: build/C/man2/uname.2:34
msgid "B<int uname(struct utsname *>I<buf>B<);>"
msgstr "B<int uname(struct utsname *>I<buf>B<);>"

#. type: Plain text
#: build/C/man2/uname.2:42
msgid ""
"B<uname>()  returns system information in the structure pointed to by "
"I<buf>.  The I<utsname> struct is defined in I<E<lt>sys/utsname.hE<gt>>:"
msgstr ""
"B<uname>()  は I<buf> で指される構造体にシステム情報を返す。 I<utsname> 構造"
"体は I<E<lt>sys/utsname.hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man2/uname.2:56
#, no-wrap
msgid ""
"struct utsname {\n"
"    char sysname[];    /* Operating system name (e.g., \"Linux\") */\n"
"    char nodename[];   /* Name within \"some implementation-defined\n"
"                          network\" */\n"
"    char release[];    /* Operating system release (e.g., \"2.6.28\") */\n"
"    char version[];    /* Operating system version */\n"
"    char machine[];    /* Hardware identifier */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS or YP domain name */\n"
"#endif\n"
"};\n"
msgstr ""
"struct utsname {\n"
"    char sysname[];    /* OS の名前 (例: \"Linux\") */\n"
"    char nodename[];   /* 「実装時に定義された、何らかの\n"
"                          ネットワーク」におけるマシン名 */\n"
"    char release[];    /* オペレーションシステムのリリース番号 (例: \"2.6.28\") */\n"
"    char version[];    /* オペレーティングシステムのバージョン */\n"
"    char machine[];    /* ハードウェア識別子 */\n"
"#ifdef _GNU_SOURCE\n"
"    char domainname[]; /* NIS や YP のドメイン名 */\n"
"#endif\n"
"};\n"

#. type: Plain text
#: build/C/man2/uname.2:63
msgid ""
"The length of the arrays in a I<struct utsname> is unspecified (see NOTES); "
"the fields are terminated by a null byte (\\(aq\\e0\\(aq)."
msgstr ""
"I<struct utsname> にある配列の長さは指定されていない (「注意」の節を参照)。 "
"フィールドは NULL バイト (\\(aq\\e0\\(aq) で終端される。"

#. type: Plain text
#: build/C/man2/uname.2:73
msgid "I<buf> is not valid."
msgstr "I<buf> が有効でない。"

#. type: Plain text
#: build/C/man2/uname.2:78
msgid "SVr4, POSIX.1-2001.  There is no B<uname>()  call in 4.3BSD."
msgstr "SVr4, POSIX.1-2001.  4.3BSD には B<uname>()  コールがない。"

#. type: Plain text
#: build/C/man2/uname.2:82
msgid ""
"The I<domainname> member (the NIS or YP domain name) is a GNU extension."
msgstr ""
"I<domainname> メンバー (NIS または YP ドメイン名) は GNU の拡張である。"

#. type: Plain text
#: build/C/man2/uname.2:98
msgid ""
"This is a system call, and the operating system presumably knows its name, "
"release and version.  It also knows what hardware it runs on.  So, four of "
"the fields of the struct are meaningful.  On the other hand, the field "
"I<nodename> is meaningless: it gives the name of the present machine in some "
"undefined network, but typically machines are in more than one network and "
"have several names.  Moreover, the kernel has no way of knowing about such "
"things, so it has to be told what to answer here.  The same holds for the "
"additional I<domainname> field."
msgstr ""
"これはシステムコールであり、OS は名前・リリース・バージョンなどを たぶん分"
"かっているだろう。 さらにそれが稼働しているハードウェアも分かっているだろ"
"う。 よって構造体の 4 つのフィールドには意味がある。 一方、I<nodename> フィー"
"ルドには意味がない: このフィールドは現在のマシンの (定義されていない)  どこか"
"のネットワークにおける名前を与えるが、 通常マシンは複数のネットワークに属し、"
"複数の名前を持つ。 さらに、カーネルはこのような情報を知る術を持たないので、 "
"ここでの答えは前もって教えてやらなければならない。 これは追加フィールドであ"
"る I<domainname> についても同様である。"

#. type: Plain text
#: build/C/man2/uname.2:116
msgid ""
"To this end Linux uses the system calls B<sethostname>(2)  and "
"B<setdomainname>(2).  Note that there is no standard that says that the "
"hostname set by B<sethostname>(2)  is the same string as the I<nodename> "
"field of the struct returned by B<uname>()  (indeed, some systems allow a "
"256-byte hostname and an 8-byte nodename), but this is true on Linux.  The "
"same holds for B<setdomainname>(2)  and the I<domainname> field."
msgstr ""
"このため Linux ではシステムコール B<sethostname>(2)  と B<setdomainname>(2)  "
"が使われる。 「B<sethostname>(2)  で設定されるホスト名は、 B<uname>()  で返さ"
"れる構造体の I<nodename> フィールドと同じ文字列である」 と規定している標準規"
"格はない (実際、256 バイトのホスト名と 8 バイトのノード名を許可しているシステ"
"ムもある)。 しかし、Linux では同じ文字列が返される。 B<setdomainname>(2)  と "
"I<domainname> フィールドについても同じことが成り立つ。"

#. type: Plain text
#: build/C/man2/uname.2:131
msgid ""
"The length of the fields in the struct varies.  Some operating systems or "
"libraries use a hardcoded 9 or 33 or 65 or 257.  Other systems use "
"B<SYS_NMLN> or B<_SYS_NMLN> or B<UTSLEN> or B<_UTSNAME_LENGTH>.  Clearly, it "
"is a bad idea to use any of these constants; just use sizeof(...).  Often "
"257 is chosen in order to have room for an internet hostname."
msgstr ""
"構造体のフィールドの長さはさまざまである。 OS やライブラリの中には、 ハード"
"コードされた 9, 33, 65, 257 などの値を使っているものもある。 また "
"B<SYS_NMLN>, B<_SYS_NMLN>, B<UTSLEN>, B<_UTSNAME_LENGTH> などを使っているシス"
"テムもある。 はっきり言って、これらの定数を使うのは悪い考え方であり、 sizeof"
"(...) を使うべきである。 インターネットホスト名で使う領域を持たせるために、 "
"257 が選ばれることが多い。"

#. type: Plain text
#: build/C/man2/uname.2:138
msgid ""
"Part of the utsname information is also accessible via I</proc/sys/kernel/>"
"{I<ostype>, I<hostname>, I<osrelease>, I<version>, I<domainname>}."
msgstr ""
"utsname の情報は、 I</proc/sys/kernel/>{I<ostype>, I<hostname>, "
"I<osrelease>, I<version>, I<domainname>} を使ってアクセスすることもできる。"

#. type: SS
#: build/C/man2/uname.2:138
#, no-wrap
msgid "Underlying kernel interface"
msgstr "背後のカーネルインタフェース"

#.  That was back before Linux 1.0
#.  That was also back before Linux 1.0
#. type: Plain text
#: build/C/man2/uname.2:167
msgid ""
"Over time, increases in the size of the I<utsname> structure have led to "
"three successive versions of B<uname>(): I<sys_olduname>()  (slot "
"I<__NR_oldolduname>), I<sys_uname>()  (slot I<__NR_olduname>), and "
"I<sys_newuname>()  (slot I<__NR_uname)>.  The first one used length 9 for "
"all fields; the second used 65; the third also uses 65 but adds the "
"I<domainname> field.  The glibc B<uname>()  wrapper function hides these "
"details from applications, invoking the most recent version of the system "
"call provided by the kernel."
msgstr ""
"時間の経過とともに、 I<utsname> 構造体のサイズが大きくなり、この影響で "
"B<uname>()  には 3つのバージョンが存在する: I<sys_olduname>()  (スロットは "
"I<__NR_oldolduname>)、 I<sys_uname>()  (スロットは I<__NR_olduname>)、 "
"I<sys_newuname>()  (スロットは I<__NR_uname>)。 I<sys_olduname>()  はすべての"
"フィールドが長さ 9 を使っていた。 I<sys_uname>()  は長さ 65 を使っていた。 "
"I<sys_newuname>()  も長さ 65 を使っているが、 I<domainname> フィールドが追加"
"されている。 glibc の B<uname>()  ラッパー関数は、これらの詳細をアプリケー"
"ションから隠蔽し、 カーネルが提供しているシステムコールのうち最新のバージョン"
"を起動する。"

#. type: Plain text
#: build/C/man2/uname.2:171
msgid "B<uname>(1), B<getdomainname>(2), B<gethostname>(2)"
msgstr "B<uname>(1), B<getdomainname>(2), B<gethostname>(2)"

#. type: TH
#: build/C/man2/uselib.2:31
#, no-wrap
msgid "USELIB"
msgstr "USELIB"

#. type: TH
#: build/C/man2/uselib.2:31
#, no-wrap
msgid "2005-01-09"
msgstr "2005-01-09"

#. type: Plain text
#: build/C/man2/uselib.2:34
msgid "uselib - load shared library"
msgstr "uselib - 共有ライブラリを選択する"

#. type: Plain text
#: build/C/man2/uselib.2:38
msgid "B<int uselib(const char *>I<library>B<);>"
msgstr "B<int uselib(const char *>I<library>B<);>"

#. type: Plain text
#: build/C/man2/uselib.2:48
msgid ""
"The system call B<uselib>()  serves to load a shared library to be used by "
"the calling process.  It is given a pathname.  The address where to load is "
"found in the library itself.  The library can have any recognized binary "
"format."
msgstr ""
"システムコール B<uselib>()  は、呼び出し元プロセスが使用する 共有ライブラリを"
"ロードする際に使用される。 このシステムコールにはライブラリのパス名を指定す"
"る。 ライブラリをロードするアドレスはライブラリ自身に書かれている。 ライブラ"
"リは認識可能なバイナリ形式であればどんな形式でもよい。"

#. type: Plain text
#: build/C/man2/uselib.2:59
msgid ""
"In addition to all of the error codes returned by B<open>(2)  and B<mmap>"
"(2), the following may also be returned:"
msgstr ""
"B<open>(2)  と B<mmap>(2)  が返すエラーコードに加えて、以下のエラーコードが設"
"定されることがある。"

#. type: Plain text
#: build/C/man2/uselib.2:67
msgid ""
"The library specified by I<library> does not have read or execute "
"permission, or the caller does not have search permission for one of the "
"directories in the path prefix.  (See also B<path_resolution>(7).)"
msgstr ""
"I<library> で指定されたライブラリに対する読み込み許可、または実行許可がな"
"い。 もしくは I<library> が存在するディレクトリかその上位のいずれかに対する検"
"索許可がない (B<path_resolution>(7)  も参照)。"

#. type: Plain text
#: build/C/man2/uselib.2:76
msgid ""
"The file specified by I<library> is not an executable of a known type; for "
"example, it does not have the correct magic numbers."
msgstr "I<library> で指定されたファイルが、実行可能ファイルと認識されるファイル種別ではない。 例えば、正しいマジックナンバーが付いていない。"

#. type: Plain text
#: build/C/man2/uselib.2:80
msgid ""
"B<uselib>()  is Linux-specific, and should not be used in programs intended "
"to be portable."
msgstr ""
"B<uselib>()  は Linux 特有の関数であり、移植性を持たせたいプログラム には使用"
"すべきでない。"

#. type: Plain text
#: build/C/man2/uselib.2:85
msgid ""
"B<uselib>()  was used by early libc startup code to load the shared "
"libraries with names found in an array of names in the binary."
msgstr ""
"初期の libc の起動コードは、 B<uselib>()  を使って、 バイナリ中のリストに書か"
"れている共有ライブラリを リスト中のそのままの名前でロードしていた。"

#.  libc 4.3.1f - changelog 1993-03-02
#.  libc 4.3.4 - changelog 1993-04-21
#. type: Plain text
#: build/C/man2/uselib.2:95
msgid ""
"Since libc 4.3.2, startup code tries to prefix these names with \"/usr/lib"
"\", \"/lib\" and \"\" before giving up.  In libc 4.3.4 and later these names "
"are looked for in the directories found in B<LD_LIBRARY_PATH>, and if not "
"found there, prefixes \"/usr/lib\", \"/lib\" and \"/\" are tried."
msgstr ""
"libc 4.3.2 以降では、これらの名前の前に \"/usr/lib\", \"/lib\", \"\" を つけ"
"て共有ライブラリを探すようになった。 libc 4.3.4 以降では、これらの名前の共有"
"ライブラリをまず B<LD_LIBRARY_PATH> で指定されたディレクトリで探し、見つから"
"なければ、 名前の前に \"/usr/lib\", \"/lib\", \"/\" をつけて探す。"

#. type: Plain text
#: build/C/man2/uselib.2:100
msgid ""
"From libc 4.4.4 on only the library \"/lib/ld.so\" is loaded, so that this "
"dynamic library can load the remaining libraries needed (again using this "
"call).  This is also the state of affairs in libc5."
msgstr ""
"libc 4.4.4 以降では、ライブラリ \"/lib/ld.so\" だけがロードされ、その後で こ"
"の動的ライブラリが (このシステムコールをもう一度使って)  必要な残りのライブラ"
"リをロードできるようになっている。"

#. type: Plain text
#: build/C/man2/uselib.2:102
msgid "glibc2 does not use this call."
msgstr "glibc2 は、このシステムコールを使用しない。"

#. type: Plain text
#: build/C/man2/uselib.2:112
msgid ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), B<dlopen>"
"(3), B<capabilities>(7), B<ld.so>(8)"
msgstr ""
"B<ar>(1), B<gcc>(1), B<ld>(1), B<ldd>(1), B<mmap>(2), B<open>(2), B<dlopen>"
"(3), B<capabilities>(7), B<ld.so>(8)"

#. type: TH
#: build/C/man3/usleep.3:33
#, no-wrap
msgid "USLEEP"
msgstr "USLEEP"

#. type: TH
#: build/C/man3/usleep.3:33
#, no-wrap
msgid "2013-12-10"
msgstr "2013-12-10"

#. type: Plain text
#: build/C/man3/usleep.3:36
msgid "usleep - suspend execution for microsecond intervals"
msgstr "usleep - マイクロ秒単位で実行を延期する"

#. type: Plain text
#: build/C/man3/usleep.3:41
#, no-wrap
msgid "B<int usleep(useconds_t >I<usec>B<);>\n"
msgstr "B<int usleep(useconds_t >I<usec>B<);>\n"

#. type: Plain text
#: build/C/man3/usleep.3:49
msgid "B<usleep>():"
msgstr "B<usleep>():"

#. type: Plain text
#: build/C/man3/usleep.3:75
msgid ""
"The B<usleep>()  function suspends execution of the calling thread for (at "
"least) I<usec> microseconds.  The sleep may be lengthened slightly by any "
"system activity or by the time spent processing the call or by the "
"granularity of system timers."
msgstr ""
"B<usleep>()  関数は (少なくとも) I<usec>マイクロ秒の間、 呼び出し元スレッドの"
"実行を延期する。 システムの動作状況や呼び出しによる時間の消費やシステムタイマ"
"の粒度によって、 停止時間は設定した値よりも少し延ばされるかもしれない。"

#. type: Plain text
#: build/C/man3/usleep.3:82
msgid ""
"The B<usleep>()  function returns 0 on success.  On error, -1 is returned, "
"with I<errno> set to indicate the cause of the error."
msgstr ""
"B<usleep>() 関数は成功すると 0 を返す。 エラーの場合、 -1 が返され、 "
"I<errno> にエラーの原因を示す値が設定される。"

#. type: Plain text
#: build/C/man3/usleep.3:87
msgid "Interrupted by a signal; see B<signal>(7)."
msgstr "シグナルによって中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/usleep.3:91
msgid ""
"I<usec> is not smaller than 1000000.  (On systems where that is considered "
"an error.)"
msgstr "I<usec> が 1000000 以上だった。 (これをエラーとみなすシステムのみ)"

#. type: Plain text
#: build/C/man3/usleep.3:96
msgid "The B<usleep>()  function is thread-safe."
msgstr "B<usleep>() 関数はスレッドセーフである。"

#. type: Plain text
#: build/C/man3/usleep.3:103
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 declares this function obsolete; use "
"B<nanosleep>(2)  instead.  POSIX.1-2008 removes the specification of "
"B<usleep>()."
msgstr ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2001 では、この関数は過去のものと宣言されてい"
"る。 代わりに B<nanosleep>(2)  を使うこと。 POSIX.1-2008 では、 B<usleep>()  "
"の規定が削除されている。"

#. type: Plain text
#: build/C/man3/usleep.3:110
msgid ""
"On the original BSD implementation, and in glibc before version 2.2.2, the "
"return type of this function is I<void>.  The POSIX version returns I<int>, "
"and this is also the prototype used since glibc 2.2.2."
msgstr ""
"もともとの BSD の実装や、バージョン 2.2.2 より前の glibc では、 この関数の返"
"り値の型は I<void> である。 POSIX 版は I<int> を返し、このプロトタイプは "
"glibc 2.2.2 以降で使用されている。"

#. type: Plain text
#: build/C/man3/usleep.3:114
msgid ""
"Only the B<EINVAL> error return is documented by SUSv2 and POSIX.1-2001."
msgstr ""
"エラーとして B<EINVAL> を返すというのは SUSv2 と POSIX.1-2001 でのみ文書化さ"
"れている。"

#. type: Plain text
#: build/C/man3/usleep.3:122
msgid ""
"The type I<useconds_t> is an unsigned integer type capable of holding "
"integers in the range [0,1000000].  Programs will be more portable if they "
"never mention this type explicitly.  Use"
msgstr ""
"I<useconds_t> 型は [0,1000000] の範囲の整数を扱うことができる 符号なし整数型"
"である。 明示的にこの型を使わないことでプログラムの移植性がより高まる。 以下"
"のように使うこと。"

#. type: Plain text
#: build/C/man3/usleep.3:130
#, no-wrap
msgid ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"
msgstr ""
"#include E<lt>unistd.hE<gt>\n"
"\\&...\n"
"    unsigned int usecs;\n"
"\\&...\n"
"    usleep(usecs);\n"

#. type: Plain text
#: build/C/man3/usleep.3:147
msgid ""
"The interaction of this function with the B<SIGALRM> signal, and with other "
"timer functions such as B<alarm>(2), B<sleep>(3), B<nanosleep>(2), "
"B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), B<timer_getoverrun>"
"(2), B<timer_gettime>(2), B<timer_settime>(2), B<ualarm>(3)  is unspecified."
msgstr ""
"この関数と、 B<SIGALRM> シグナルあるいは B<alarm>(2), B<sleep>(3), "
"B<nanosleep>(2), B<setitimer>(2), B<timer_create>(2), B<timer_delete>(2), "
"B<timer_getoverrun>(2), B<timer_gettime>(2), B<timer_settime>(2), B<ualarm>"
"(3)  といったその他のタイマー関数を同時に使った場合の動作は未定義である。"

#. type: Plain text
#: build/C/man3/usleep.3:156
msgid ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), B<setitimer>"
"(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"
msgstr ""
"B<alarm>(2), B<getitimer>(2), B<nanosleep>(2), B<select>(2), B<setitimer>"
"(2), B<sleep>(3), B<ualarm>(3), B<time>(7)"

#. type: TH
#: build/C/man2/vfork.2:28
#, no-wrap
msgid "VFORK"
msgstr "VFORK"

#. type: TH
#: build/C/man2/vfork.2:28
#, no-wrap
msgid "2012-08-05"
msgstr "2012-08-05"

#. type: Plain text
#: build/C/man2/vfork.2:31
msgid "vfork - create a child process and block parent"
msgstr "vfork - 子プロセスを生成し親プロセスを停止させる"

#. type: Plain text
#: build/C/man2/vfork.2:37
msgid "B<pid_t vfork(void);>"
msgstr "B<pid_t vfork(void);>"

#. type: Plain text
#: build/C/man2/vfork.2:44
msgid "B<vfork>():"
msgstr "B<vfork>():"

#. type: SS
#: build/C/man2/vfork.2:63
#, no-wrap
msgid "Standard description"
msgstr "規格の説明"

#. type: Plain text
#: build/C/man2/vfork.2:82
msgid ""
"(From POSIX.1)  The B<vfork>()  function has the same effect as B<fork>(2), "
"except that the behavior is undefined if the process created by B<vfork>()  "
"either modifies any data other than a variable of type I<pid_t> used to "
"store the return value from B<vfork>(), or returns from the function in "
"which B<vfork>()  was called, or calls any other function before "
"successfully calling B<_exit>(2)  or one of the B<exec>(3)  family of "
"functions."
msgstr ""
"(POSIX.1 より引用)  B<vfork>()  関数は B<fork>(2)  と同じ働きをするが、 "
"B<vfork>()  で作成されたプロセスが B<vfork>()  からの返り値を格納している "
"I<pid_t> 型の変数以外を変更したり、 B<vfork>()  を呼び出している関数から "
"return したり、 B<_exit>(2)  や B<exec>(3)  族の関数をコールする前に他の関数"
"をコールした場合の動作が 未定義であるという点が異なる。"

#. type: SS
#: build/C/man2/vfork.2:82
#, no-wrap
msgid "Linux description"
msgstr "LINUX での説明"

#. type: Plain text
#: build/C/man2/vfork.2:89
msgid ""
"B<vfork>(), just like B<fork>(2), creates a child process of the calling "
"process.  For details and return value and errors, see B<fork>(2)."
msgstr ""
"B<vfork>()  は B<fork>(2)  と全く同じように呼び出したプロセスの子プロセスを生"
"成する。 詳しい説明と返り値、エラーについては B<fork>(2)  を参照すること。"

#. type: Plain text
#: build/C/man2/vfork.2:98
msgid ""
"B<vfork>()  is a special case of B<clone>(2).  It is used to create new "
"processes without copying the page tables of the parent process.  It may be "
"useful in performance-sensitive applications where a child is created which "
"then immediately issues an B<execve>(2)."
msgstr ""
"B<vfork>()  は B<clone>(2)  の特殊な場合である。 親プロセスのページテーブルの"
"コピーを行わずに新しいプロセスを 作成するために使用する。これは性能に敏感なア"
"プリケーションにおいて 子プロセスを生成してすぐに B<execve>(2)  する場合に有"
"用かもしれない。"

#. type: Plain text
#: build/C/man2/vfork.2:115
msgid ""
"B<vfork>()  differs from B<fork>(2)  in that the calling thread is suspended "
"until the child terminates (either normally, by calling B<_exit>(2), or "
"abnormally, after delivery of a fatal signal), or it makes a call to "
"B<execve>(2).  Until that point, the child shares all memory with its "
"parent, including the stack.  The child must not return from the current "
"function or call B<exit>(3), but may call B<_exit>(2)."
msgstr ""
"B<vfork>() は B<fork>(2) と違い、子プロセスが終了するか、\n"
"B<execve>(2) をコールするまで呼び出し元のスレッドを停止 (suspend) させる。\n"
"子プロセスの終了は、B<_exit>(2) の呼び出しによる通常終了、致命的なシグナル"
"の\n"
"配送後の異常終了の二つのケースがある。\n"
"この時点までは、子プロセスはスタックを含む全てのメモリを親プロセスと共有す"
"る。\n"
"子プロセスは現在の関数から return してはならず、\n"
"B<exit>(3) もコールしてはならないが、B<_exit>(2) ならばコールしてもよい。"

#. type: Plain text
#: build/C/man2/vfork.2:126
msgid ""
"As with B<fork>(2), the child process created by B<vfork>()  inherits copies "
"of various of the caller's process attributes (e.g., file descriptors, "
"signal dispositions, and current working directory); the B<vfork>()  call "
"differs only in the treatment of the virtual address space, as described "
"above."
msgstr ""
"B<fork>(2) と同様に、 B<vfork>() で作成された子プロセスは、\n"
"(ファイルディスクリプタ、シグナル配送定義、カレントワーキングディレクトリなど"
"の)\n"
"呼び出し元のプロセスの各種の属性を継承する。\n"
"B<vfork>() では、上で説明した仮想アドレス空間の扱いだけが異なる。"

#. type: Plain text
#: build/C/man2/vfork.2:132
msgid ""
"Signals sent to the parent arrive after the child releases the parent's "
"memory (i.e., after the child terminates or calls B<execve>(2))."
msgstr ""
"親プロセスへ送られたシグナルは、子プロセスが親プロセスのメモリを解放した後\n"
"(すなわち、子プロセスが終了するか B<execve>(2) を呼んだ後) に到着する。"

#. type: SS
#: build/C/man2/vfork.2:132
#, no-wrap
msgid "Historic description"
msgstr "歴史的な説明"

#. type: Plain text
#: build/C/man2/vfork.2:159
msgid ""
"Under Linux, B<fork>(2)  is implemented using copy-on-write pages, so the "
"only penalty incurred by B<fork>(2)  is the time and memory required to "
"duplicate the parent's page tables, and to create a unique task structure "
"for the child.  However, in the bad old days a B<fork>(2)  would require "
"making a complete copy of the caller's data space, often needlessly, since "
"usually immediately afterward an B<exec>(3)  is done.  Thus, for greater "
"efficiency, BSD introduced the B<vfork>()  system call, which did not fully "
"copy the address space of the parent process, but borrowed the parent's "
"memory and thread of control until a call to B<execve>(2)  or an exit "
"occurred.  The parent process was suspended while the child was using its "
"resources.  The use of B<vfork>()  was tricky: for example, not modifying "
"data in the parent process depended on knowing which variables were held in "
"a register."
msgstr ""
"Linux において B<fork>(2)  は書き込み時コピー (copy-on-write) ページを使用し"
"て実装されている。 そのため B<fork>(2)  を使用することによって被る損害は親プ"
"ロセスのページテーブルを 複製するために必要な時間とメモリだけである。 しかし"
"ながら、忌しき昔には B<fork>(2)  は呼び出したプロセスのデータ空間の全てのコ"
"ピーしていたが、 これはしばしば不必要であった。なぜなら、たいていはすぐ後に "
"B<exec>(3)  を実行していたからである。 この場合の効率を上げるために BSD は "
"B<vfork>()  システムコールを導入して親プロセスのアドレス空間を完全にコピー す"
"るかわりに、 B<execve>(2)  をコールするか exit が起きるまで親プロセスのメモリ"
"と制御スレッド を借りるようにした。 親プロセスは子プロセスがその資源を使用し"
"ている間は停止された。 B<vfork>()  は使いにくいものであった: 例えば、親プロセ"
"スの変数を変更しな いようにするためにはどの変数がレジスタに保持されているかを"
"知らな ければならなかった。"

#. type: Plain text
#: build/C/man2/vfork.2:163
msgid ""
"4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the "
"specification of B<vfork>()."
msgstr ""
"4.3BSD; POSIX.1-2001 (廃止予定とされている)。\n"
"POSIX.1-2008 では B<vfork>() の規定が削除されている。"

#.  In AIXv3.1 vfork is equivalent to fork.
#. type: Plain text
#: build/C/man2/vfork.2:174
msgid ""
"The requirements put on B<vfork>()  by the standards are weaker than those "
"put on B<fork>(2), so an implementation where the two are synonymous is "
"compliant.  In particular, the programmer cannot rely on the parent "
"remaining blocked until the child either terminates or calls B<execve>(2), "
"and cannot rely on any specific behavior with respect to shared memory."
msgstr ""
"B<vfork>() コールは他のオペレーティングシステムの同名のコールと ちょっと似\n"
"ているかもしれない。規格が B<vfork>() に要求していることは、 B<fork>(2) に"
"要\n"
"求していることよりは弱い。したがって、 両者を同じものとして実装しても、規格"
"に\n"
"準拠していることになる。 特にプログラマーは、子プロセスが終了するか\n"
"B<execve>(2) を呼び出すまで親プロセスが停止していることや、メモリを共有する"
"こ\n"
"とによる特殊な動作をあてにすべきではない。"

#. type: Plain text
#: build/C/man2/vfork.2:193
msgid ""
"Some consider the semantics of B<vfork>()  to be an architectural blemish, "
"and the 4.2BSD man page stated: \"This system call will be eliminated when "
"proper system sharing mechanisms are implemented.  Users should not depend "
"on the memory sharing semantics of B<vfork>()  as it will, in that case, be "
"made synonymous to B<fork>(2).\" However, even though modern memory "
"management hardware has decreased the performance difference between B<fork>"
"(2)  and B<vfork>(), there are various reasons why Linux and other systems "
"have retained B<vfork>():"
msgstr ""
"B<vfork>() の動作は構造的な欠陥と考える人もいるだろうし、\n"
"BSD のマニュアルには、「このシステムコールは妥当なシステム共有機構が実装さ\n"
"れた場合には削除される。ユーザは B<vfork>() のメモリ共有機能に依存するべき\n"
"ではない。何故ならば、このシステムコール が削除された場合には、それは\n"
"B<fork>(2) の同義語とされるからである。」と書かれている。しかしながら、\n"
"最近のメモリ管理ハードウェアにより B<fork>(2) と B<vfork>() の間の性能差が\n"
"減ったとはいえ、 Linux や他のシステムで B<vfork>() が残されているのには\n"
"いくつか理由がある:"

#. type: Plain text
#: build/C/man2/vfork.2:197
msgid ""
"Some performance-critical applications require the small performance "
"advantage conferred by B<vfork>()."
msgstr ""
"性能に厳しいアプリケーションでは、 B<vfork>() により得られる\n"
"小さな性能上のメリットが必要な場合がある。"

#.  http://stackoverflow.com/questions/4259629/what-is-the-difference-between-fork-and-vfork
#.  http://developers.sun.com/solaris/articles/subprocess/subprocess.html
#.  http://mailman.uclinux.org/pipermail/uclinux-dev/2009-April/000684.html
#. type: Plain text
#: build/C/man2/vfork.2:213
msgid ""
"B<vfork>()  can be implemented on systems that lack a memory-management unit "
"(MMU), but B<fork>(2)  can't be implemented on such systems.  (POSIX.1-2008 "
"removed B<vfork>()  from the standard; the POSIX rationale for the "
"B<posix_spawn>(3)  function notes that that function, which provides "
"functionality equivalent to B<fork>(2)+B<exec>(3), is designed to be "
"implementable on systems that lack an MMU.)"
msgstr ""
"B<vfork>() はメモリ管理ユニット (MMU) を持たないシステムでも実装すること\n"
"ができるが、そのようなシステムで B<fork>(2) を実装することはできない。\n"
"(POSIX.1-2008 では B<vfork>() が標準から削除された。\n"
"B<posix_spawn>(3) 関数の POSIX の原理 (rationale) には、\n"
"B<fork>(2)+B<exec>(3) と等価な機能を提供する B<posix_spawn>(3) は、\n"
"MMU を持たないシステムでも実装できるように設計されたとの注記がある。)"

#. type: Plain text
#: build/C/man2/vfork.2:224
msgid ""
"Fork handlers established using B<pthread_atfork>(3)  are not called when a "
"multithreaded program employing the NPTL threading library calls B<vfork>"
"().  Fork handlers are called in this case in a program using the "
"LinuxThreads threading library.  (See B<pthreads>(7)  for a description of "
"Linux threading libraries.)"
msgstr ""
"B<pthread_atfork>(3)  を使って設定された fork ハンドラは NPTL スレッドライブ"
"ラリコールを採用したマルチスレッドプログラムでは 呼び出されない。一方、"
"LinuxThreads スレッドライブラリを使った プログラムでは、fork ハンドラは呼び出"
"される。 (Linux のスレッドライブラリの説明は B<pthreads>(7)  を参照。)"

#. type: Plain text
#: build/C/man2/vfork.2:232
msgid ""
"A call to B<vfork>()  is equivalent to calling B<clone>(2)  with I<flags> "
"specified as:"
msgstr ""
"B<vfork>() の呼び出しは、以下の I<flags> を指定して B<clone>(2) を呼び出す\n"
"のと等価である。"

#. type: Plain text
#: build/C/man2/vfork.2:234
#, no-wrap
msgid "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"
msgstr "     CLONE_VM | CLONE_VFORK | SIGCHLD\n"

#.  In the release notes for 4.2BSD Sam Leffler wrote: `vfork: Is still
#.  present, but definitely on its way out'.
#. type: Plain text
#: build/C/man2/vfork.2:252
msgid ""
"The B<vfork>()  system call appeared in 3.0BSD.  In 4.4BSD it was made "
"synonymous to B<fork>(2)  but NetBSD introduced it again, cf.  E<.UR http://"
"www.netbsd.org\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE .> In Linux, "
"it has been equivalent to B<fork>(2)  until 2.2.0-pre6 or so.  Since 2.2.0-"
"pre9 (on i386, somewhat later on other architectures) it is an independent "
"system call.  Support was added in glibc 2.0.112."
msgstr ""
"B<vfork>()  システムコールは 3.0BSD に現われた。 4.4BSD において B<fork>(2)  "
"の同義語となったが、NetBSD では再び導入された。 E<.UR http://www.netbsd.org"
"\\:/Documentation\\:/kernel\\:/vfork.html> E<.UE> を参照。 Linux では 2.2.0-"
"pre6 あたりまでは B<fork>(2)  と等価であった。(i386 では) 2.2.0-pre9 から (他"
"のアーキテクチャでは 少し遅れて) 独立したシステムコールとなった。 glibc での"
"サポートは glibc-2.0.112 で追加された。"

#.  As far as I can tell, the following is not true in 2.6.19:
#.  Currently (Linux 2.3.25),
#.  .BR strace (1)
#.  cannot follow
#.  .BR vfork ()
#.  and requires a kernel patch.
#. type: Plain text
#: build/C/man2/vfork.2:273
msgid ""
"Details of the signal handling are obscure and differ between systems.  The "
"BSD man page states: \"To avoid a possible deadlock situation, processes "
"that are children in the middle of a B<vfork>()  are never sent B<SIGTTOU> "
"or B<SIGTTIN> signals; rather, output or I<ioctl>s are allowed and input "
"attempts result in an end-of-file indication.\""
msgstr ""
"シグナルの扱いの詳細は不明瞭でシステムごとに異っている。 BSD のマニュアルに"
"は、 「デッドロック状態になる可能性があるので B<vfork>()  の途中の子プロセス"
"に B<SIGTTOU> や B<SIGTTIN> シグナルを送信してはならない; さらに出力や "
"I<ioctl> は許されるが、入力を試みた場合には結果はファイル終端 (EOF) にな"
"る。」 と書かれている。"

#. type: Plain text
#: build/C/man2/vfork.2:279
msgid "B<clone>(2), B<execve>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"
msgstr "B<clone>(2), B<execve>(2), B<fork>(2), B<unshare>(2), B<wait>(2)"

#. type: TH
#: build/C/man2/vhangup.2:28
#, no-wrap
msgid "VHANGUP"
msgstr "VHANGUP"

#. type: Plain text
#: build/C/man2/vhangup.2:31
msgid "vhangup - virtually hangup the current terminal"
msgstr "vhangup - 現在の端末を仮想的に (virtualy) ハングアップ (hangup) させる"

#. type: Plain text
#: build/C/man2/vhangup.2:35
msgid "B<int vhangup(void);>"
msgstr "B<int vhangup(void);>"

#. type: Plain text
#: build/C/man2/vhangup.2:44
msgid ""
"B<vhangup>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<vhangup>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: build/C/man2/vhangup.2:50
msgid ""
"B<vhangup>()  simulates a hangup on the current terminal.  This call "
"arranges for other users to have a ``clean'' terminal at login time."
msgstr ""
"B<vhangup>()  は現在の端末 (terminal) でハングアップをシミュレートする。この"
"コールは他のユーザーがログインした時に綺麗 (clean) な端末を得ることができるよ"
"う手配する。"

#. type: Plain text
#: build/C/man2/vhangup.2:63
msgid ""
"The calling process has insufficient privilege to call B<vhangup>(); the "
"B<CAP_SYS_TTY_CONFIG> capability is required."
msgstr ""
"呼び出し元プロセスに B<vhangup>()  を呼び出すための十分な特権がない。 "
"B<CAP_SYS_TTY_CONFIG> ケーパビリティ (capability) が必要である。"

#. type: Plain text
#: build/C/man2/vhangup.2:66
msgid ""
"This call is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"このコールは Linux 特有であり、移植を意図したプログラムで 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/vhangup.2:69
msgid "B<capabilities>(7), B<init>(8)"
msgstr "B<capabilities>(7), B<init>(8)"

#~ msgid "access - check real user's permissions for a file"
#~ msgstr "access - ファイルに対する実ユーザーでのアクセス権をチェックする"

#~ msgid ""
#~ "Depending on the filesystem, other errors can be returned.  The more "
#~ "general errors for B<chmod>()  are listed below:"
#~ msgstr ""
#~ "ファイルシステムによっては他のエラーを返す場合がある。 B<chmod>()  で一般"
#~ "的なエラーを以下に挙げる。"

#~ msgid ""
#~ "Depending on the filesystem, other errors can be returned.  The more "
#~ "general errors for B<chown>()  are listed below."
#~ msgstr ""
#~ "ファイルシステムによっては他のエラーが返される事がある。 B<chmod> で一般的"
#~ "なエラーを以下に挙げる。"

#~ msgid ""
#~ "The file I<path> exists, but refers neither to a regular file nor to a "
#~ "block device; or, for B<swapon>(), the indicated path does not contain a "
#~ "valid swap signature or resides on an in-memory filesystem like tmpfs; "
#~ "or, for B<swapoff>(), I<path> is not currently a swap area."
#~ msgstr ""
#~ "ファイル I<path> は存在するが、通常のファイルもブロックデバイスも参照して"
#~ "いない。 または B<swapon>()  において、指定された path のファイルが有効な"
#~ "スワップの署名 (signature) を 含んでいないか、tmpfs のようなインメモリ "
#~ "(in-memory) のファイルシステム 上にある。 または B<swapoff>()  において、 "
#~ "I<path> が現在のところスワップ領域でない。"

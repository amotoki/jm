# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-07-15 16:08+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/CPU_SET.3:27
#, no-wrap
msgid "CPU_SET"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:27
#, no-wrap
msgid "2012-03-15"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:45 build/C/man2/kcmp.2:28 build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26 build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:46 build/C/man2/sched_yield.2:29 build/C/man2/setns.2:8 build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:45 build/C/man2/kcmp.2:28 build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26 build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:46 build/C/man2/sched_yield.2:29 build/C/man2/setns.2:8 build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:28 build/C/man2/clone.2:46 build/C/man2/kcmp.2:29 build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:27 build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35 build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:47 build/C/man2/sched_yield.2:30 build/C/man2/setns.2:9 build/C/man2/unshare.2:21
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:35
msgid ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:35 build/C/man2/clone.2:48 build/C/man2/kcmp.2:31 build/C/man2/sched_get_priority_max.2:32 build/C/man3/sched_getcpu.3:29 build/C/man2/sched_rr_get_interval.2:32 build/C/man2/sched_setaffinity.2:38 build/C/man2/sched_setparam.2:33 build/C/man2/sched_setscheduler.2:50 build/C/man2/sched_yield.2:32 build/C/man2/setns.2:11 build/C/man2/unshare.2:23
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:39 build/C/man2/sched_setaffinity.2:42 build/C/man2/setns.2:15
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:41
#, no-wrap
msgid "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:45
#, no-wrap
msgid ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:47
#, no-wrap
msgid "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:54
#, no-wrap
msgid ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:56
#, no-wrap
msgid "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:60
#, no-wrap
msgid ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:62
#, no-wrap
msgid "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:66
#, no-wrap
msgid ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:68
#, no-wrap
msgid "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:75
#, no-wrap
msgid ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:78
#, no-wrap
msgid ""
"B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t "
"*>I<set2>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:79 build/C/man2/clone.2:86 build/C/man2/kcmp.2:41 build/C/man2/sched_get_priority_max.2:38 build/C/man3/sched_getcpu.3:55 build/C/man2/sched_rr_get_interval.2:36 build/C/man2/sched_setaffinity.2:49 build/C/man2/sched_setparam.2:47 build/C/man2/sched_setscheduler.2:66 build/C/man2/sched_yield.2:36 build/C/man2/setns.2:18 build/C/man2/unshare.2:50
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:86
msgid ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:93
msgid ""
"The I<cpu_set_t> data type is implemented as a bitset.  However, the data "
"structure treated as considered opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:96
msgid "The following macros are provided to operate on the CPU set I<set>:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:96
#, no-wrap
msgid "B<CPU_ZERO>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:101
msgid "Clears I<set>, so that it contains no CPUs."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:101
#, no-wrap
msgid "B<CPU_SET>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:107
msgid "Add CPU I<cpu> to I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:107
#, no-wrap
msgid "B<CPU_CLR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:113
msgid "Remove CPU I<cpu> from I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:113
#, no-wrap
msgid "B<CPU_ISSET>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:119
msgid "Test to see if CPU I<cpu> is a member of I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:119
#, no-wrap
msgid "B<CPU_COUNT>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:123
msgid "Return the number of CPUs in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:128
msgid ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:139
msgid ""
"The first available CPU on the system corresponds to a I<cpu> value of 0, "
"the next CPU corresponds to a I<cpu> value of 1, and so on.  The constant "
"B<CPU_SETSIZE> (currently 1024) specifies a value one greater than the "
"maximum CPU number that can be stored in I<cpu_set_t>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:141
msgid "The following macros perform logical operations on CPU sets:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:141
#, no-wrap
msgid "B<CPU_AND>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:150
msgid ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:150
#, no-wrap
msgid "B<CPU_OR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:159
msgid ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:159
#, no-wrap
msgid "B<CPU_XOR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:173
msgid ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:173
#, no-wrap
msgid "B<CPU_EQUAL>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:176
msgid "Test whether two CPU set contain exactly the same CPUs."
msgstr ""

#. type: SS
#: build/C/man3/CPU_SET.3:176
#, no-wrap
msgid "Dynamically sized CPU sets"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:182
msgid ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:184
msgid "The following macros are used to allocate and deallocate CPU sets:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:184
#, no-wrap
msgid "B<CPU_ALLOC>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:189
msgid ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to "
"I<num_cpus-1>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:189
#, no-wrap
msgid "B<CPU_ALLOC_SIZE>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:199
msgid ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described "
"below."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:199
#, no-wrap
msgid "B<CPU_FREE>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:203
msgid "Free a CPU set previously allocated by B<CPU_ALLOC>()."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:210
msgid ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:210 build/C/man2/clone.2:874 build/C/man2/kcmp.2:124 build/C/man2/sched_get_priority_max.2:98 build/C/man3/sched_getcpu.3:58 build/C/man2/sched_rr_get_interval.2:73 build/C/man2/sched_setaffinity.2:107 build/C/man2/sched_setparam.2:87 build/C/man2/sched_setscheduler.2:422 build/C/man2/sched_yield.2:41 build/C/man2/setns.2:70 build/C/man2/unshare.2:207
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:219
msgid ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:225
msgid "B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:230
msgid ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise it returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:235
msgid ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:239
msgid ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:241
msgid "The other functions do not return a value."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:241 build/C/man2/clone.2:991 build/C/man2/kcmp.2:195 build/C/man3/sched_getcpu.3:70 build/C/man2/sched_setaffinity.2:148 build/C/man2/setns.2:97 build/C/man2/unshare.2:224
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:249
msgid ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:252
msgid "B<CPU_COUNT>()  first appeared in glibc 2.6."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:270
msgid ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), "
"B<CPU_XOR_S>(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:270 build/C/man2/clone.2:998 build/C/man2/kcmp.2:199 build/C/man2/sched_get_priority_max.2:114 build/C/man3/sched_getcpu.3:72 build/C/man2/sched_rr_get_interval.2:94 build/C/man2/sched_setaffinity.2:159 build/C/man2/sched_setparam.2:110 build/C/man2/sched_setscheduler.2:444 build/C/man2/sched_yield.2:52 build/C/man2/setns.2:102 build/C/man2/unshare.2:228
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:272
msgid "These interfaces are Linux-specific."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:272 build/C/man2/clone.2:1002 build/C/man2/kcmp.2:202 build/C/man3/sched_getcpu.3:75 build/C/man2/sched_rr_get_interval.2:96 build/C/man2/sched_setaffinity.2:161 build/C/man2/sched_setparam.2:112 build/C/man2/sched_setscheduler.2:447 build/C/man2/sched_yield.2:54 build/C/man2/setns.2:106 build/C/man2/unshare.2:232
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:275
msgid "To duplicate a CPU set, use B<memcpy>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:282
msgid ""
"Since CPU sets are bitsets allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:294
msgid ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of bits in the bitset), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:300
msgid ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:300 build/C/man2/clone.2:1027 build/C/man2/sched_setscheduler.2:530
#, no-wrap
msgid "BUGS"
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7029
#. type: Plain text
#: build/C/man3/CPU_SET.3:312
msgid ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:312 build/C/man2/clone.2:1069 build/C/man2/setns.2:112
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:315
msgid ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:323
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:330
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus, cpu;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:335
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:337
#, no-wrap
msgid "    num_cpus = atoi(argv[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:343
#, no-wrap
msgid ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:345
#, no-wrap
msgid "    size = CPU_ALLOC_SIZE(num_cpus);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:349
#, no-wrap
msgid ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:351
#, no-wrap
msgid "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:355
#, no-wrap
msgid ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:356 build/C/man2/clone.2:1167 build/C/man2/kcmp.2:219 build/C/man2/sched_get_priority_max.2:116 build/C/man3/sched_getcpu.3:95 build/C/man2/sched_rr_get_interval.2:132 build/C/man2/sched_setaffinity.2:214 build/C/man2/sched_setparam.2:118 build/C/man2/sched_setscheduler.2:538 build/C/man2/sched_yield.2:79 build/C/man2/setns.2:199 build/C/man2/unshare.2:266
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:361
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:361 build/C/man2/clone.2:1181 build/C/man2/kcmp.2:222 build/C/man2/sched_get_priority_max.2:128 build/C/man3/sched_getcpu.3:97 build/C/man2/sched_rr_get_interval.2:138 build/C/man2/sched_setaffinity.2:233 build/C/man2/sched_setparam.2:134 build/C/man2/sched_setscheduler.2:566 build/C/man2/sched_yield.2:85 build/C/man2/setns.2:205 build/C/man2/unshare.2:275
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:368 build/C/man2/clone.2:1188 build/C/man2/kcmp.2:229 build/C/man2/sched_get_priority_max.2:135 build/C/man3/sched_getcpu.3:104 build/C/man2/sched_rr_get_interval.2:145 build/C/man2/sched_setaffinity.2:240 build/C/man2/sched_setparam.2:141 build/C/man2/sched_setscheduler.2:573 build/C/man2/sched_yield.2:92 build/C/man2/setns.2:212 build/C/man2/unshare.2:282
msgid ""
"This page is part of release 3.52 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/clone.2:45
#, no-wrap
msgid "CLONE"
msgstr ""

#. type: TH
#: build/C/man2/clone.2:45
#, no-wrap
msgid "2013-04-16"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:48
msgid "clone, __clone2 - create a child process"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:51
#, no-wrap
msgid "/* Prototype for the glibc wrapper function */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:53 build/C/man3/sched_getcpu.3:32 build/C/man2/sched_setparam.2:36 build/C/man2/sched_setscheduler.2:53 build/C/man2/unshare.2:26
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:58
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t "
"*>I<ctid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:60
#, no-wrap
msgid "/* Prototype for the raw system call */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:64
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<          void *>I<ptid>B<, void *>I<ctid>B<,>\n"
"B<          struct pt_regs *>I<regs>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:69
msgid ""
"Feature Test Macro Requirements for glibc wrapper function (see "
"B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:72
msgid "B<clone>():"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:75 build/C/man3/sched_getcpu.3:45 build/C/man2/unshare.2:39
#, no-wrap
msgid "Since glibc 2.14:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:78 build/C/man3/sched_getcpu.3:48 build/C/man2/unshare.2:42
msgid "_GNU_SOURCE"
msgstr ""

#.  FIXME See http://sources.redhat.com/bugzilla/show_bug.cgi?id=4749
#. type: TP
#: build/C/man2/clone.2:78 build/C/man3/sched_getcpu.3:48 build/C/man2/unshare.2:42
#, no-wrap
msgid "Before glibc 2.14:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:83 build/C/man3/sched_getcpu.3:52 build/C/man2/unshare.2:47
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE also suffices */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:90
msgid "B<clone>()  creates a new process, in a manner similar to B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:97
msgid ""
"This page describes both the glibc B<clone>()  wrapper function and the "
"underlying system call on which it is based.  The main text describes the "
"wrapper function; the differences for the raw system call are described "
"toward the end of this page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:109
msgid ""
"Unlike B<fork>(2), B<clone>()  allows the child process to share parts of "
"its execution context with the calling process, such as the memory space, "
"the table of file descriptors, and the table of signal handlers.  (Note that "
"on this manual page, \"calling process\" normally corresponds to \"parent "
"process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:114
msgid ""
"The main use of B<clone>()  is to implement threads: multiple threads of "
"control in a program that run concurrently in a shared memory space."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:134
msgid ""
"When the child process is created with B<clone>(), it executes the function "
"I<fn>(I<arg>).  (This differs from B<fork>(2), where execution continues in "
"the child from the point of the B<fork>(2)  call.)  The I<fn> argument is a "
"pointer to a function that is called by the child process at the beginning "
"of its execution.  The I<arg> argument is passed to the I<fn> function."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:144
msgid ""
"When the I<fn>(I<arg>)  function application returns, the child process "
"terminates.  The integer returned by I<fn> is the exit code for the child "
"process.  The child process may also terminate explicitly by calling "
"B<exit>(2)  or after receiving a fatal signal."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:160
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:176
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with "
"B<wait>(2).  If no signal is specified, then the parent process is not "
"signaled when the child terminates."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:181
msgid ""
"I<flags> may also be bitwise-or'ed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:181
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:191
msgid ""
"Erase child thread ID at location I<ctid> in child memory when the child "
"exits, and do a wakeup on the futex at that address.  The address involved "
"may be changed by the B<set_tid_address>(2)  system call.  This is used by "
"threading libraries."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:191
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:196
msgid "Store child thread ID at location I<ctid> in child memory."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:196
#, no-wrap
msgid "B<CLONE_FILES> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:209
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:223
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  (The "
"duplicated file descriptors in the child refer to the same open file "
"descriptions (see B<open>(2))  as the corresponding file descriptors in the "
"calling process.)  Subsequent operations that open or close file "
"descriptors, or change file descriptor flags, performed by either the "
"calling process or the child process do not affect the other process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:223
#, no-wrap
msgid "B<CLONE_FS> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:238
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same file "
"system information.  This includes the root of the file system, the current "
"working directory, and the umask.  Any call to B<chroot>(2), B<chdir>(2), or "
"B<umask>(2)  performed by the calling process or the child process also "
"affects the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:250
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the file "
"system information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), B<umask>(2)  performed later by "
"one of the processes do not affect the other process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:250
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:259
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: build/C/man2/clone.2:276
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e, what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:280
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:280 build/C/man2/unshare.2:96
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:290
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#.  commit 7eafd7c74c3f2e67c27621b987b28397110d643f
#.  https://lwn.net/Articles/312232/
#. type: Plain text
#: build/C/man2/clone.2:302
msgid ""
"An IPC namespace provides an isolated view of System V IPC objects (see "
"B<svipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
"B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
"that IPC objects are identified by mechanisms other than filesystem "
"pathnames."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:306
msgid ""
"Objects created in an IPC namespace are visible to all other processes that "
"are members of that namespace, but are not visible to processes in other IPC "
"namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:310
msgid ""
"When an IPC namespace is destroyed (i.e., when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:319
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_SYSVIPC> "
"and B<CONFIG_IPC_NS> options and that the process be privileged "
"(B<CAP_SYS_ADMIN>).  This flag can't be specified in conjunction with "
"B<CLONE_SYSVSEM>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:319 build/C/man2/unshare.2:113
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr ""

#.  FIXME Check when the implementation was completed
#. type: Plain text
#: build/C/man2/clone.2:324
msgid ""
"(The implementation of this flag was completed only by about kernel version "
"2.6.29.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:333
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2)), the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""

#.  FIXME Add pointer to veth(4) page when it is eventually completed
#. type: Plain text
#: build/C/man2/clone.2:348
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network device (\"veth\") pair provides a "
"pipe-like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:353
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:358
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_NET_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:358
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:361
msgid "Start the child in a new mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:382
msgid ""
"Every process lives in a mount namespace.  The I<namespace> of a process is "
"the data (the set of mounts) describing the file hierarchy as seen by that "
"process.  After a B<fork>(2)  or B<clone>()  where the B<CLONE_NEWNS> flag "
"is not set, the child lives in the same mount namespace as the parent.  The "
"system calls B<mount>(2)  and B<umount>(2)  change the mount namespace of "
"the calling process, and hence affect all processes that live in the same "
"namespace, but do not affect processes in a different mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:389
msgid ""
"After a B<clone>()  where the B<CLONE_NEWNS> flag is set, the cloned child "
"is started in a new mount namespace, initialized with a copy of the "
"namespace of the parent."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:401
msgid ""
"Only a privileged process (one having the B<CAP_SYS_ADMIN> capability)  may "
"specify the B<CLONE_NEWNS> flag.  It is not permitted to specify both "
"B<CLONE_NEWNS> and B<CLONE_FS> in the same B<clone>()  call."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:401
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr ""

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: build/C/man2/clone.2:418
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:427
msgid ""
"A PID namespace provides an isolated environment for PIDs: PIDs in a new "
"namespace start at 1, somewhat like a standalone system, and calls to "
"B<fork>(2), B<vfork>(2), or B<clone>()  will produce processes with PIDs "
"that are unique within the namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:439
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using the B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process "
"for the namespace.  Children that are orphaned within the namespace will be "
"reparented to this process rather than B<init>(8).  Unlike the traditional "
"B<init> process, the \"init\" process of a PID namespace can terminate, and "
"if it does, all of the processes in the namespace are terminated."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:458
msgid ""
"PID namespaces form a hierarchy.  When a new PID namespace is created, the "
"processes in that namespace are visible in the PID namespace of the process "
"that created the new namespace; analogously, if the parent PID namespace is "
"itself the child of another PID namespace, then processes in the child and "
"parent PID namespaces will both be visible in the grandparent PID "
"namespace.  Conversely, the processes in the \"child\" PID namespace do not "
"see the processes in the parent namespace.  The existence of a namespace "
"hierarchy means that each process may now have multiple PIDs: one for each "
"namespace in which it is visible; each of these PIDs is unique within the "
"corresponding namespace.  (A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process lives.)"
msgstr ""

#.  mount -t proc proc /proc
#. type: Plain text
#: build/C/man2/clone.2:474
msgid ""
"After creating the new namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  (If B<CLONE_NEWNS> is also included in "
"I<flags>, then it isn't necessary to change the root directory: a new procfs "
"instance can be mounted directly over I</proc>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:481
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_PID_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>).  This flag "
"can't be specified in conjunction with B<CLONE_THREAD>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:481 build/C/man2/unshare.2:149
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:493
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2)), the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of "
"containers."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:505
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the host name can be modified by "
"B<setdomainname>(2)  and B<sethostname>(2), respectively.  Changes made to "
"the identifiers in a UTS namespace are visible to all other processes in the "
"same namespace, but are not visible to processes in other UTS namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:510
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_UTS_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:510
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:517
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:523
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:531
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:531
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:539
msgid ""
"Store child thread ID at location I<ptid> in parent and child memory.  (In "
"Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:539
#, no-wrap
msgid "B<CLONE_PID> (obsolete)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:550
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  Since 2.3.21 this flag can be specified only by "
"the system boot process (PID 0).  It disappeared in Linux 2.5.16."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:550
#, no-wrap
msgid "B<CLONE_PTRACE> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:557
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:557
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:564
msgid ""
"The I<newtls> argument is the new TLS (Thread Local Storage) descriptor.  "
"(See B<set_thread_area>(2).)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:564
#, no-wrap
msgid "B<CLONE_SIGHAND> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:580
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock some signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:591
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:599
msgid ""
"Since Linux 2.6.0-test6, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:599
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0-test2)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:608
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: build/C/man2/clone.2:616
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:616
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:625
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore undo values (see B<semop>(2)).  If this "
"flag is not set, then the child has a separate undo list, which is initially "
"empty."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:625
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0-test8)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:634
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:642
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:651
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:661
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:683
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:688
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:693
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:699
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:707
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:712
msgid ""
"Signals may be sent to a thread group as a whole (i.e., a TGID) using "
"B<kill>(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:717
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:730
msgid ""
"Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
"signals can be pending either: for the whole process (i.e., deliverable to "
"any member of the thread group), when sent with B<kill>(2); or for an "
"individual thread, when sent with B<tgkill>(2).  A call to B<sigpending>(2)  "
"returns a signal set that is the union of the signals pending for the whole "
"process and the signals that are pending for the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:742
msgid ""
"If B<kill>(2)  is used to send a signal to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive a signal sent using B<kill>(2)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:742
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:749
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:749
#, no-wrap
msgid "B<CLONE_VFORK> (since Linux 2.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:761
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to "
"B<execve>(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:767
msgid ""
"If B<CLONE_VFORK> is not set then both the calling process and the child are "
"schedulable after the call, and an application should not rely on execution "
"occurring in any particular order."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:767
#, no-wrap
msgid "B<CLONE_VM> (since Linux 2.0)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:780
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:789
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:789
#, no-wrap
msgid "The raw system call interface"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:805
msgid ""
"The raw B<clone>()  system call corresponds more closely to B<fork>(2)  in "
"that execution in the child continues from the point of the call.  As such, "
"the I<fn> and I<arg> arguments of the B<clone>()  wrapper function are "
"omitted.  Furthermore, the argument order changes.  The raw system call "
"interface on x86 and many other architectures is roughly:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:811
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           void *>I<ptid>B<, void *>I<ctid>B<,>\n"
"B<           struct pt_regs *>I<regs>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:822
msgid ""
"Another difference for the raw system call is that the I<child_stack> "
"argument may be zero, in which case copy-on-write semantics ensure that the "
"child gets separate copies of stack pages when either process modifies the "
"stack.  In this case, for correct operation, the B<CLONE_VM> option should "
"not be specified."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:830
msgid ""
"For some architectures, the order of the arguments for the system call "
"differs from that shown above.  On the score, microblaze, ARM, ARM 64, "
"PA-RISC, arc, Power PC, xtensa, and MIPS architectures, the order of the "
"fourth and fifth arguments is reversed.  On the cris and s390 architectures, "
"the order of the first and second arguments is reversed."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:830
#, no-wrap
msgid "blackfin, m68k, and sparc"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:834
msgid ""
"The argument-passing conventions on blackfin, m68k, and sparc are different "
"from descriptions above.  For details, see the kernel (and glibc) source."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:834
#, no-wrap
msgid "ia64"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:836
msgid "On ia64, a different interface is used:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:843
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t "
"*>I<ctid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:855
msgid ""
"The prototype shown above is for the glibc wrapper function; the raw system "
"call interface has no I<fn> or I<arg> argument, and changes the order of the "
"arguments so that I<flags> is the first argument, and I<tls> is the last "
"argument."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:866
msgid ""
"B<__clone2>()  operates in the same way as B<clone>(), except that "
"I<child_stack_base> points to the lowest address of the child's stack area, "
"and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:866
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:874
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: build/C/man2/clone.2:883
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""

#. type: SH
#: build/C/man2/clone.2:883 build/C/man2/kcmp.2:167 build/C/man2/sched_get_priority_max.2:108 build/C/man3/sched_getcpu.3:65 build/C/man2/sched_rr_get_interval.2:80 build/C/man2/sched_setaffinity.2:116 build/C/man2/sched_setparam.2:96 build/C/man2/sched_setscheduler.2:432 build/C/man2/sched_yield.2:48 build/C/man2/setns.2:77 build/C/man2/unshare.2:212
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:884
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:887
msgid "Too many processes are already running."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:887 build/C/man2/clone.2:894 build/C/man2/clone.2:909 build/C/man2/clone.2:917 build/C/man2/clone.2:925 build/C/man2/clone.2:933 build/C/man2/clone.2:939 build/C/man2/clone.2:949 build/C/man2/clone.2:957 build/C/man2/clone.2:965 build/C/man2/kcmp.2:178 build/C/man2/sched_get_priority_max.2:109 build/C/man2/sched_rr_get_interval.2:84 build/C/man2/sched_setaffinity.2:120 build/C/man2/sched_setaffinity.2:128 build/C/man2/sched_setparam.2:97 build/C/man2/sched_setscheduler.2:433 build/C/man2/setns.2:82 build/C/man2/unshare.2:213
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:894
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux "
"2.6.0-test6.)"
msgstr ""

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: build/C/man2/clone.2:909
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:917
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:925
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:933
msgid "Both B<CLONE_NEWPID> and B<CLONE_THREAD> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:939
msgid "Returned by B<clone>()  when a zero value is specified for I<child_stack>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:949
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:957
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:965
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:973
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS> option."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:973 build/C/man2/setns.2:89 build/C/man2/unshare.2:217
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:978
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be "
"copied."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:978 build/C/man2/clone.2:987 build/C/man2/kcmp.2:182 build/C/man2/sched_setaffinity.2:135 build/C/man2/sched_setparam.2:101 build/C/man2/sched_setscheduler.2:438 build/C/man2/setns.2:92 build/C/man2/unshare.2:221
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:987
msgid ""
"B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, or "
"B<CLONE_NEWUTS> was specified by an unprivileged process (process without "
"B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:991
msgid "B<CLONE_PID> was specified by a process other than process 0."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:998
msgid ""
"There is no entry for B<clone>()  in libc5.  glibc2 provides B<clone>()  as "
"described in this manual page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1002
msgid ""
"B<clone>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1012
msgid ""
"In the kernel 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in kernel 2.6)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1022
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In 2.6.2 the need to give this together with "
"B<CLONE_THREAD> disappeared.  This flag is still defined, but has no effect."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1027
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1058
msgid ""
"Versions of the GNU C library that include the NPTL threading library "
"contain a wrapper function for B<getpid>(2)  that performs caching of PIDs.  "
"This caching relies on support in the glibc wrapper for B<clone>(), but as "
"currently implemented, the cache may not be up to date in some "
"circumstances.  In particular, if a signal is delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal may return the PID of the calling process (\"the "
"parent\"), if the clone wrapper has not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it may be necessary to use code such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1061
#, no-wrap
msgid "    #include E<lt>syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1063
#, no-wrap
msgid "    pid_t mypid;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1065
#, no-wrap
msgid "    mypid = syscall(SYS_getpid);\n"
msgstr ""

#. type: SS
#: build/C/man2/clone.2:1070
#, no-wrap
msgid "Create a child that executes in a separate UTS namespace"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1080
msgid ""
"The following program demonstrates the use of B<clone>()  to create a child "
"process that executes in a separate UTS namespace.  The child changes the "
"hostname in its UTS namespace.  Both parent and child then display the "
"system hostname, making it possible to see that the hostname differs in the "
"UTS namespaces of the parent and child.  For an example of the use of this "
"program, see B<setns>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1090
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1093 build/C/man2/setns.2:177
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1098
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1100
#, no-wrap
msgid "    /* Change hostname in UTS namespace of child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1103
#, no-wrap
msgid ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1105
#, no-wrap
msgid "    /* Retrieve and display hostname */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1109
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1113
#, no-wrap
msgid ""
"    /* Keep the namespace open for a while, by sleeping.\n"
"       This allows some experimentation--for example, another\n"
"       process might join the namespace. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1115
#, no-wrap
msgid "    sleep(200);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1118
#, no-wrap
msgid ""
"    return 0;           /* Child terminates now */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1120
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1128
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* Start of stack buffer */\n"
"    char *stackTop;                 /* End of stack buffer */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1133
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", "
"argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1135
#, no-wrap
msgid "    /* Allocate stack for child */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1140
#, no-wrap
msgid ""
"    stack = malloc(STACK_SIZE);\n"
"    if (stack == NULL)\n"
"        errExit(\"malloc\");\n"
"    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1143
#, no-wrap
msgid ""
"    /* Create child that has its own UTS namespace;\n"
"       child commences execution in childFunc() */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1148
#, no-wrap
msgid ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %ld\\en\", (long) pid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1150
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1152
#, no-wrap
msgid "    sleep(1);           /* Give child time to change its hostname */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1155
#, no-wrap
msgid ""
"    /* Display hostname in parent\\(aqs UTS namespace. This will be\n"
"       different from hostname in child\\(aqs UTS namespace. */\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1159
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1163
#, no-wrap
msgid ""
"    if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1166
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1181
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), "
"B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), B<tkill>(2), "
"B<unshare>(2), B<wait>(2), B<capabilities>(7), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man2/kcmp.2:28
#, no-wrap
msgid "KCMP"
msgstr ""

#. type: TH
#: build/C/man2/kcmp.2:28
#, no-wrap
msgid "2013-01-27"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:31
msgid "kcmp - compare two processes to determine if they share a kernel resource"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:34
#, no-wrap
msgid "B<#include E<lt>linux/kcmp.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:37
#, no-wrap
msgid ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:50
msgid ""
"The B<kcmp>()  system call can be used to check whether the two processes "
"identified by I<pid1> and I<pid2> share a kernel resource such as virtual "
"memory, file descriptors, and so on."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:55
msgid ""
"The I<type> argument specifies which resource is to be compared in the two "
"processes.  It has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:55
#, no-wrap
msgid "B<KCMP_FILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:67
msgid ""
"Check whether a file descriptor I<idx1> in the process I<pid1> refers to the "
"same open file description (see B<open>(2))  as file descriptor I<idx2> in "
"the process I<pid2>."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:67
#, no-wrap
msgid "B<KCMP_FILES>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:75
msgid ""
"Check whether the process share the same set of open file descriptors.  The "
"arguments I<idx1> and I<idx2> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:75
#, no-wrap
msgid "B<KCMP_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:84
msgid ""
"Check whether the processes share the same file system information (i.e., "
"file mode creation mask, working directory, and file system root).  The "
"arguments I<idx1> and I<idx2> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:84
#, no-wrap
msgid "B<KCMP_IO>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:92
msgid ""
"Check whether the processes share I/O context.  The arguments I<idx1> and "
"I<idx2> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:92
#, no-wrap
msgid "B<KCMP_SIGHAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:100
msgid ""
"Check whether the processes share the same table of signal dispositions.  "
"The arguments I<idx1> and I<idx2> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:100
#, no-wrap
msgid "B<KCMP_SYSVSEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:109
msgid ""
"Check whether the processes share the same list of System V semaphore undo "
"operations.  The arguments I<idx1> and I<idx2> are ignored."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:109
#, no-wrap
msgid "B<KCMP_VM>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:117
msgid ""
"Check whether the processes share the same address space.  The arguments "
"I<idx1> and I<idx2> are ignored."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:124
msgid ""
"Note the B<kcmp>()  is not protected against false positives which may have "
"place if tasks are running.  Which means one should stop tasks being "
"inspected with this syscall to obtain meaningful results."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:130
msgid ""
"The return value of a successful call to B<kcmp>()  is simply the result of "
"arithmetic comparison of kernel pointers (when the kernel compares "
"resources, it uses their memory addresses)."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:138
msgid ""
"The easiest way to explain is to consider an example.  Suppose that I<v1> "
"and I<v2> are the addresses of appropriate resources, then the return value "
"is one of the following:"
msgstr ""

#. type: IP
#: build/C/man2/kcmp.2:139
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:144
msgid ""
"I<v1> is equal to I<v2>; in other words, the two processes share the "
"resource."
msgstr ""

#. type: IP
#: build/C/man2/kcmp.2:144
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:148
msgid "I<v1> is less than I<v2>."
msgstr ""

#. type: IP
#: build/C/man2/kcmp.2:148
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:152
msgid "I<v1> is greater than I<v2>."
msgstr ""

#. type: IP
#: build/C/man2/kcmp.2:152
#, no-wrap
msgid "3"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:157
msgid "I<v1> is not equal to I<v2>, but ordering information is unavailable."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:162
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:167
msgid ""
"B<kcmp ()> was designed to return values suitable for sorting.  This is "
"particularly handy if one needs to compare a large number of file "
"descriptors."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:168 build/C/man2/setns.2:78
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:178
msgid "I<type> is B<KCMP_FILE> and I<fd1> or I<fd2> is not an open file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:182
msgid "I<type> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:188
msgid ""
"Insufficient permission to inspect process resources.  The B<CAP_SYS_PTRACE> "
"capability is required to inspect processes that you do not own."
msgstr ""

#. type: TP
#: build/C/man2/kcmp.2:188 build/C/man2/sched_rr_get_interval.2:90 build/C/man2/sched_setaffinity.2:145 build/C/man2/sched_setparam.2:107 build/C/man2/sched_setscheduler.2:441
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:195
msgid "Process I<pid1> or I<pid2> does not exist."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:199
msgid "The B<kcmp>()  system call first appeared in Linux 3.5."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:202
msgid ""
"B<kcmp>()  is Linux specific and should not be used in programs intended to "
"be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:205
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:214
msgid ""
"This system call is available only if the kernel was configured with "
"B<CONFIG_CHECKPOINT_RESTORE>.  The main use of the system call is for the "
"checkpoint/restore in user space (CRIU) feature.  The alternative to this "
"system call would have been to expose suitable process information via the "
"B<proc>(5)  file system; this was deemed to be unsuitable for security "
"reasons."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:219
msgid ""
"See B<clone>(2)  for some background information on the shared resources "
"referred to on this page."
msgstr ""

#. type: Plain text
#: build/C/man2/kcmp.2:222
msgid "B<clone>(2), B<unshare>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr ""

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "2006-03-23"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:32
msgid "sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:34 build/C/man2/sched_rr_get_interval.2:34 build/C/man2/sched_yield.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:57
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, and "
"B<SCHED_BATCH>.  Further details about these policies can be found in "
"B<sched_setscheduler>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:66
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:77
msgid ""
"Linux allows the static priority value range 1 to 99 for B<SCHED_FIFO> and "
"B<SCHED_RR> and the priority 0 for B<SCHED_OTHER> and B<SCHED_BATCH>.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:89
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>().  POSIX.1-2001 requires a spread of at least 32 "
"between the maximum and the minimum values for B<SCHED_FIFO> and "
"B<SCHED_RR>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:98
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:108
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:114
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:116 build/C/man2/sched_rr_get_interval.2:96 build/C/man2/sched_setparam.2:112 build/C/man2/sched_yield.2:54
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:125
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:128 build/C/man2/sched_rr_get_interval.2:138 build/C/man2/sched_setparam.2:134 build/C/man2/sched_setscheduler.2:563 build/C/man2/sched_yield.2:85
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly "
"& Associates, Inc., ISBN 1-56592-074-0."
msgstr ""

#. type: TH
#: build/C/man3/sched_getcpu.3:26
#, no-wrap
msgid "SCHED_GETCPU"
msgstr ""

#. type: TH
#: build/C/man3/sched_getcpu.3:26 build/C/man2/unshare.2:20
#, no-wrap
msgid "2013-04-17"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:29
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:39 build/C/man2/unshare.2:33
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:42
msgid "B<sched_getcpu>():"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:58
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:65
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man3/sched_getcpu.3:66 build/C/man2/sched_rr_get_interval.2:87
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:70
msgid "This kernel does not implement B<getcpu>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:72
msgid "This function is available since glibc 2.6."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:75
msgid "B<sched_getcpu>()  is glibc specific."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:77
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:81
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:87
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:93
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:97
msgid "B<getcpu>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr ""

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "2013-03-18"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:32
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:36
msgid "B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec * >I<tp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/sched_rr_get_interval.2:81 build/C/man2/sched_setaffinity.2:117
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: SS
#: build/C/man2/sched_rr_get_interval.2:103
#, no-wrap
msgid "Linux notes"
msgstr ""

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the "
"round-robin time quantum.  Older Linux kernels provide a (nonportable) "
"method of doing this.  The quantum can be controlled by adjusting the "
"process's nice value (see B<setpriority>(2)).  Assigning a negative (i.e., "
"high) nice value results in a longer quantum; assigning a positive (i.e., "
"low) nice value results in a shorter quantum.  The default quantum is 0.1 "
"seconds; the degree to which changing the nice value affects the quantum has "
"varied somewhat across kernel versions.  This method of adjusting the "
"quantum was removed starting with Linux 2.6.24."
msgstr ""

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:135 build/C/man2/sched_setaffinity.2:177
msgid "B<sched_setscheduler>(2)  has a description of the Linux scheduling scheme."
msgstr ""

#. type: TH
#: build/C/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr ""

#. type: TH
#: build/C/man2/sched_setaffinity.2:34
#, no-wrap
msgid "2013-02-11"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a process's CPU affinity "
"mask"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:63
msgid ""
"A process's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular process (i.e., setting the affinity mask of that process "
"to specify a single CPU, and setting the affinity mask of all other "
"processes to exclude that CPU), it is possible to ensure maximum execution "
"speed for that process.  Restricting a process to run on a single CPU also "
"avoids the performance cost caused by the cache invalidation that occurs "
"when a process ceases to execute on one CPU and then recommences execution "
"on a different CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU "
"set\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the process whose ID "
"is I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling process is used.  The argument I<cpusetsize> is the length (in "
"bytes) of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:92
msgid ""
"If the process specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that process is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the process whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling process is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:116
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:120
msgid "A supplied memory address was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:128
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the process according to any "
"restrictions that may be imposed by the \"cpuset\" mechanism described in "
"B<cpuset>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:135
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:145
msgid ""
"(B<sched_setaffinity>())  The calling process does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the process identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:148 build/C/man2/sched_setparam.2:110 build/C/man2/sched_setscheduler.2:444
msgid "The process whose ID is I<pid> could not be found."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:159
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:161
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:174
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the process "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the process runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the process will run are silently imposed by "
"the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:194
msgid ""
"The affinity mask is actually a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:200
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:214
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask.  On success, the raw "
"B<sched_getaffinity>()  system call returns the size (in bytes) of the "
"I<cpumask_t> data type that is used internally by the kernel to represent "
"the CPU set bit mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:233
msgid ""
"B<taskset>(1), B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), "
"B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr ""

#. type: TH
#: build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:46
#, no-wrap
msgid "2013-02-12"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:38
#, no-wrap
msgid ""
"B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param "
"*>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:40
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:46 build/C/man2/sched_setscheduler.2:65
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:60
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the process identified by I<pid>.  If I<pid> is zero, "
"then the parameters of the calling process are set.  The interpretation of "
"the argument I<param> depends on the scheduling policy of the process "
"identified by I<pid>.  See B<sched_setscheduler>(2)  for a description of "
"the scheduling policies supported under Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the process "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"process are retrieved."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the process.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched_setscheduler>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:101
msgid "The argument I<param> does not make sense for the current scheduling policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:107
msgid ""
"The calling process does not have appropriate privileges (Linux: does not "
"have the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:118
msgid ""
"Scheduling parameters are in fact per-thread attributes on Linux; see "
"B<sched_setscheduler>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:131
msgid ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<setpriority>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setscheduler.2:46
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:50
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling "
"policy/parameters"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:55
#, no-wrap
msgid "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:57
#, no-wrap
msgid "B<                       const struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:59
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:76
msgid ""
"B<sched_setscheduler>()  sets both the scheduling policy and the associated "
"parameters for the process whose ID is specified in I<pid>.  If I<pid> "
"equals zero, the scheduling policy and parameters of the calling process "
"will be set.  The interpretation of the argument I<param> depends on the "
"selected policy.  Currently, Linux supports the following \"normal\" (i.e., "
"non-real-time) scheduling policies:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:76
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr ""

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:81
msgid "the standard round-robin time-sharing policy;"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:81
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:84
msgid "for \"batch\" style execution of processes; and"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:84
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:89
msgid "for running I<very> low priority background jobs."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:93
msgid ""
"The following \"real-time\" policies are also supported, for special "
"time-critical applications that need precise control over the way in which "
"runnable processes are selected for execution:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:93
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:96
msgid "a first-in, first-out policy; and"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:96
#, no-wrap
msgid "B<SCHED_RR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:99
msgid "a round-robin policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:101
msgid "The semantics of each of these policies are detailed below."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:108
msgid ""
"B<sched_getscheduler>()  queries the scheduling policy currently applied to "
"the process identified by I<pid>.  If I<pid> equals zero, the policy of the "
"calling process will be retrieved."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:108
#, no-wrap
msgid "Scheduling policies"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:117
msgid ""
"The scheduler is the kernel component that decides which runnable process "
"will be executed by the CPU next.  Each process has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>; these are the "
"settings that are modified by B<sched_setscheduler>().  The scheduler makes "
"it decisions based on knowledge of the scheduling policy and static priority "
"of all processes on the system."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:122
msgid ""
"For processes scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:136
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time processes always have higher "
"priority than normal processes.)  Note well: POSIX.1-2001 requires an "
"implementation to support only a minimum 32 distinct priority levels for the "
"real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:142
msgid ""
"Conceptually, the scheduler maintains a list of runnable processes for each "
"possible I<sched_priority> value.  In order to determine which process runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the process at the head of this list."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:146
msgid ""
"A process's scheduling policy determines where it will be inserted into the "
"list of processes with equal static priority and how it will move inside "
"this list."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:154
msgid ""
"All scheduling is preemptive: if a process with a higher static priority "
"becomes ready to run, the currently running process will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy determines the ordering only within the list of runnable processes "
"with equal static priority."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:154
#, no-wrap
msgid "SCHED_FIFO: First in-first out scheduling"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:163
msgid ""
"B<SCHED_FIFO> can be used only with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> processes becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> process.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For processes scheduled under the B<SCHED_FIFO> "
"policy, the following rules apply:"
msgstr ""

#. type: IP
#: build/C/man2/sched_setscheduler.2:163 build/C/man2/sched_setscheduler.2:168 build/C/man2/sched_setscheduler.2:171 build/C/man2/sched_setscheduler.2:185 build/C/man2/sched_setscheduler.2:287 build/C/man2/sched_setscheduler.2:295 build/C/man2/sched_setscheduler.2:336 build/C/man2/sched_setscheduler.2:344 build/C/man2/sched_setscheduler.2:349 build/C/man2/sched_setscheduler.2:354
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:168
msgid ""
"A B<SCHED_FIFO> process that has been preempted by another process of higher "
"priority will stay at the head of the list for its priority and will resume "
"execution as soon as all processes of higher priority are blocked again."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:171
msgid ""
"When a B<SCHED_FIFO> process becomes runnable, it will be inserted at the "
"end of the list for its priority."
msgstr ""

#.  In 2.2.x and 2.4.x, the process is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the process went to the back -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:185
msgid ""
"A call to B<sched_setscheduler>()  or B<sched_setparam>(2)  will put the "
"B<SCHED_FIFO> (or B<SCHED_RR>) process identified by I<pid> at the start of "
"the list if it was runnable.  As a consequence, it may preempt the currently "
"running process if it has the same priority.  (POSIX.1-2001 specifies that "
"the process should go to the end of the list.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:189
msgid "A process calling B<sched_yield>(2)  will be put at the end of the list."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:193
msgid ""
"No other events will move a process scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable processes with equal static priority."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:198
msgid ""
"A B<SCHED_FIFO> process runs until either it is blocked by an I/O request, "
"it is preempted by a higher priority process, or it calls B<sched_yield>(2)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:198
#, no-wrap
msgid "SCHED_RR: Round-robin scheduling"
msgstr ""

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:217
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each "
"process is allowed to run only for a maximum time quantum.  If a B<SCHED_RR> "
"process has been running for a time period equal to or longer than the time "
"quantum, it will be put at the end of the list for its priority.  A "
"B<SCHED_RR> process that has been preempted by a higher priority process and "
"subsequently resumes execution as a running process will complete the "
"unexpired portion of its round-robin time quantum.  The length of the time "
"quantum can be retrieved using B<sched_rr_get_interval>(2)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:217
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:233
msgid ""
"B<SCHED_OTHER> can be used at only static priority 0.  B<SCHED_OTHER> is the "
"standard Linux time-sharing scheduler that is intended for all processes "
"that do not require the special real-time mechanisms.  The process to run is "
"chosen from the static priority 0 list based on a I<dynamic> priority that "
"is determined only inside this list.  The dynamic priority is based on the "
"nice value (set by B<nice>(2)  or B<setpriority>(2))  and increased for each "
"time quantum the process is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> processes."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:233
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:245
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can be used only at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the "
"process according to its dynamic priority (based on the nice value).  The "
"difference is that this policy will cause the scheduler to always assume "
"that the process is CPU-intensive.  Consequently, the scheduler will apply a "
"small scheduling penalty with respect to wakeup behaviour, so that this "
"process is mildly disfavored in scheduling decisions."
msgstr ""

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:254
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:254
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:258
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can be used only at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:266
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:266
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:282
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  This feature is intended for media-playback applications, and can "
"be used to prevent applications evading the B<RLIMIT_RTTIME> resource limit "
"(see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:287
msgid ""
"More precisely, if the B<SCHED_RESET_ON_FORK> flag is specified, the "
"following rules apply for subsequently created children:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:295
msgid ""
"If the calling process has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:298
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:307
msgid ""
"After the B<SCHED_RESET_ON_FORK> flag has been enabled, it can be reset only "
"if the process has the B<CAP_SYS_NICE> capability.  This flag is disabled in "
"child processes created by B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:313
msgid ""
"The B<SCHED_RESET_ON_FORK> flag is visible in the policy value returned by "
"B<sched_getscheduler>()"
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:313
#, no-wrap
msgid "Privileges and resource limits"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:326
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  processes "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged process can make is to set "
"the B<SCHED_OTHER> policy, and this can be done only if the effective user "
"ID of the caller of B<sched_setscheduler>()  matches the real or effective "
"user ID of the target process (i.e., the process specified by I<pid>)  whose "
"policy is being changed."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:336
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged process's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:344
msgid ""
"If an unprivileged process has a nonzero B<RLIMIT_RTPRIO> soft limit, then "
"it can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:349
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:354
msgid ""
"Subject to the same rules, another unprivileged process can also make these "
"changes, as long as the effective user ID of the process making the change "
"matches the real or effective user ID of the target process."
msgstr ""

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:372
msgid ""
"Special rules apply for the B<SCHED_IDLE>.  In Linux kernels before 2.6.39, "
"an unprivileged process operating under this policy cannot change its "
"policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In "
"Linux kernels since 2.6.39, an unprivileged process can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_NORMAL> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:383
msgid ""
"Privileged (B<CAP_SYS_NICE>)  processes ignore the B<RLIMIT_RTPRIO> limit; "
"as with older kernels, they can make arbitrary changes to scheduling policy "
"and priority.  See B<getrlimit>(2)  for further information on "
"B<RLIMIT_RTPRIO>."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:383
#, no-wrap
msgid "Response time"
msgstr ""

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:391
msgid ""
"A blocked high priority process waiting for the I/O has a certain response "
"time before it is scheduled again.  The device driver writer can greatly "
"reduce this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:391
#, no-wrap
msgid "Miscellaneous"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:396
msgid ""
"Child processes inherit the scheduling policy and parameters across a "
"B<fork>(2).  The scheduling policy and parameters are preserved across "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:402
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:414
msgid ""
"Since a nonblocking infinite loop in a process scheduled under B<SCHED_FIFO> "
"or B<SCHED_RR> will block all processes with lower priority forever, a "
"software developer should always keep available on the console a shell "
"scheduled under a higher static priority than the tested application.  This "
"will allow an emergency kill of tested real-time applications that do not "
"block or terminate as expected.  See also the description of the "
"B<RLIMIT_RTTIME> resource limit in B<getrlimit>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:422
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:432
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the process (a nonnegative "
"integer).  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:438
msgid ""
"The scheduling I<policy> is not one of the recognized policies, I<param> is "
"NULL, or I<param> does not make sense for the I<policy>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:441
msgid "The calling process does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:447
msgid ""
"POSIX.1-2001 (but see BUGS below).  The B<SCHED_BATCH> and B<SCHED_IDLE> "
"policies are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:455
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged process "
"requires in order to call B<sched_setscheduler>(), and details vary across "
"systems.  For example, the Solaris 7 manual page says that the real or "
"effective user ID of the calling process must match the real user ID or the "
"save set-user-ID of the target process."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:476
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the "
"argument I<pid>.  Specifying I<pid> as 0 will operate on the attribute for "
"the calling thread, and passing the value returned from a call to "
"B<getpid>(2)  will operate on the attribute for the main thread of the "
"thread group.  (If you are using the POSIX threads API, then use "
"B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3), instead of the B<sched_*>(2)  system calls.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:486
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:486
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr ""

#.  FIXME . Probably this text will need some minor tweaking
#.  by about the time of 2.6.30; ask Carsten Emde about this then.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:500
msgid ""
"From kernel version 2.6.18 onward, however, Linux is gradually becoming "
"equipped with real-time capabilities, most of which are derived from the "
"former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
"Gleixner, Steven Rostedt, and others.  Until the patches have been "
"completely merged into the mainline kernel (this is expected to be around "
"kernel version 2.6.30), they must be installed to achieve the best real-time "
"performance.  These patches are named:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:504
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:510
msgid ""
"and can be downloaded from E<.UR "
"http://www.kernel.org\\:/pub\\:/linux\\:/kernel\\:/projects\\:/rt/> E<.UE .>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:519
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:530
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular "
"real-time operating system.  The FIFO and RR scheduling policies that can be "
"selected using B<sched_setscheduler>()  are then used to run a process with "
"true real-time priority and a minimum worst-case scheduling latency."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:538
msgid ""
"POSIX says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:559
msgid ""
"B<chrt>(1), B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<capabilities>(7), B<cpuset>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:566
msgid "The Linux kernel source file I<Documentation/scheduler/sched-rt-group.txt>"
msgstr ""

#. type: TH
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr ""

#. type: TH
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "2008-10-18"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources "
"(e.g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:82
msgid "B<sched_setscheduler>(2)  for a description of Linux scheduling"
msgstr ""

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr ""

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "2013-01-01"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:21
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:34
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<proc>(5)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:40
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/setns.2:40
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:43
msgid "Allow any type of namespace to be joined."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWIPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:47
msgid "I<fd> must refer to an IPC namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWNET>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:51
msgid "I<fd> must refer to a network namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:51
#, no-wrap
msgid "B<CLONE_NEWUTS>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:55
msgid "I<fd> must refer to a UTS namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:70
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:77
msgid ""
"On success, I<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:82
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:89
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>, or there is problem with reassociating the the thread with the "
"specified namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:92
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:97
msgid ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:102
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:106
msgid "The B<setns>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:112
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:121
msgid ""
"The program below takes two or more arguments.  The first argument specifies "
"the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(), "
"and executes the specified command inside that namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:131
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:139
msgid ""
"We begin by executing the example program in B<clone>(2)  in the "
"background.  That program creates a child in a separate UTS namespace.  The "
"child changes the hostname in its namespace, and then both processes display "
"the hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:151
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:158
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:164
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""

#. type: SS
#: build/C/man2/setns.2:166
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:174
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:187
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:191
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);   /* Get descriptor for namespace */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:194
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)         /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:198
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);      /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:205
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:28
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:36
msgid "B<unshare>():"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:62
msgid ""
"B<unshare>()  allows a process to disassociate parts of its execution "
"context that are currently being shared with other processes.  Part of the "
"execution context, such as the mount namespace, is shared implicitly when a "
"new process is created using B<fork>(2)  or B<vfork>(2), while other parts, "
"such as virtual memory, may be shared by explicit request when creating a "
"process using B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:67
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:74
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:74
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:82
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:82
#, no-wrap
msgid "B<CLONE_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:96
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare file "
"system attributes, so that the calling process no longer shares its root "
"directory (B<chroot>(2)), current directory (B<chdir>(2)), or umask "
"(B<umask>(2))  attributes with any other process."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:113
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the System V IPC namespace, so that the calling process has a "
"private copy of the System V IPC namespace which is not shared with any "
"other process.  Specifying this flag automatically implies B<CLONE_SYSVSEM> "
"as well.  Use of B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:128
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:128
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr ""

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: build/C/man2/unshare.2:149
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:163
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:163
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr ""

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  As at 2.6.16, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  CLONE_NEWNSIf CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#
#.  FIXME . CLONE_VM is not (yet, as at 2.6.16) implemented.
#.  .TP
#.  .B CLONE_VM
#.  Reverse the effect of the
#.  .BR clone (2)
#.  .B CLONE_VM
#.  flag.
#.  .RB ( CLONE_VM
#.  is also implicitly set by
#.  .BR vfork (2),
#.  and can be reversed using this
#.  .BR unshare ()
#.  flag.)
#.  Unshare virtual memory, so that the calling process no
#.  longer shares its virtual address space with any other process.
#. type: Plain text
#: build/C/man2/unshare.2:200
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System V semaphore undo values, so that the calling process has a "
"private copy which is not shared with any other process.  Use of "
"B<CLONE_SYSVSEM> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:207
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:212
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:217
msgid "An invalid bit was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:221
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:224
msgid "The calling process did not have the required privileges for this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:228
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:232
msgid "The B<unshare>()  system call is Linux-specific."
msgstr ""

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: build/C/man2/unshare.2:266
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:272
msgid "B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), B<vfork>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:275
msgid "I<Documentation/unshare.txt> in the Linux kernel source tree"
msgstr ""

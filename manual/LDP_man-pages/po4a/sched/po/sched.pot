# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-04-23 07:54+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/CPU_SET.3:25
#, no-wrap
msgid "CPU_SET"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:25
#, no-wrap
msgid "2012-03-15"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:25 build/C/man2/clone.2:43 build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:24 build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35 build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:47 build/C/man2/sched_yield.2:30 build/C/man2/setns.2:4 build/C/man2/unshare.2:17
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man3/CPU_SET.3:25 build/C/man2/clone.2:43 build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:24 build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35 build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:47 build/C/man2/sched_yield.2:30 build/C/man2/setns.2:4 build/C/man2/unshare.2:17
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:26 build/C/man2/clone.2:44 build/C/man2/sched_get_priority_max.2:31 build/C/man3/sched_getcpu.3:25 build/C/man2/sched_rr_get_interval.2:31 build/C/man2/sched_setaffinity.2:36 build/C/man2/sched_setparam.2:32 build/C/man2/sched_setscheduler.2:48 build/C/man2/sched_yield.2:31 build/C/man2/setns.2:5 build/C/man2/unshare.2:18
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:33
msgid ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:33 build/C/man2/clone.2:46 build/C/man2/sched_get_priority_max.2:33 build/C/man3/sched_getcpu.3:27 build/C/man2/sched_rr_get_interval.2:33 build/C/man2/sched_setaffinity.2:39 build/C/man2/sched_setparam.2:34 build/C/man2/sched_setscheduler.2:51 build/C/man2/sched_yield.2:33 build/C/man2/setns.2:7 build/C/man2/unshare.2:20
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#.  Actually _BSD_SOURCE || _SVID_SOURCE
#.  See http://sources.redhat.com/bugzilla/show_bug.cgi?id=4749
#. type: Plain text
#: build/C/man3/CPU_SET.3:37 build/C/man2/clone.2:52 build/C/man2/sched_setaffinity.2:43 build/C/man2/setns.2:11 build/C/man2/unshare.2:26
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:39
#, no-wrap
msgid "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:43
#, no-wrap
msgid ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:45
#, no-wrap
msgid "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:52
#, no-wrap
msgid ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:54
#, no-wrap
msgid "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:58
#, no-wrap
msgid ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:60
#, no-wrap
msgid "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:64
#, no-wrap
msgid ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t "
"*>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:66
#, no-wrap
msgid "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:73
#, no-wrap
msgid ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:76
#, no-wrap
msgid ""
"B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t "
"*>I<set2>B<);>\n"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:77 build/C/man2/clone.2:58 build/C/man2/sched_get_priority_max.2:39 build/C/man3/sched_getcpu.3:35 build/C/man2/sched_rr_get_interval.2:37 build/C/man2/sched_setaffinity.2:50 build/C/man2/sched_setparam.2:48 build/C/man2/sched_setscheduler.2:67 build/C/man2/sched_yield.2:37 build/C/man2/setns.2:14 build/C/man2/unshare.2:29
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:84
msgid ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:91
msgid ""
"The I<cpu_set_t> data type is implemented as a bitset.  However, the data "
"structure treated as considered opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:94
msgid "The following macros are provided to operate on the CPU set I<set>:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:94
#, no-wrap
msgid "B<CPU_ZERO>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:99
msgid "Clears I<set>, so that it contains no CPUs."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:99
#, no-wrap
msgid "B<CPU_SET>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:105
msgid "Add CPU I<cpu> to I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:105
#, no-wrap
msgid "B<CPU_CLR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:111
msgid "Remove CPU I<cpu> from I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:111
#, no-wrap
msgid "B<CPU_ISSET>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:117
msgid "Test to see if CPU I<cpu> is a member of I<set>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:117
#, no-wrap
msgid "B<CPU_COUNT>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:121
msgid "Return the number of CPUs in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:126
msgid ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:137
msgid ""
"The first available CPU on the system corresponds to a I<cpu> value of 0, "
"the next CPU corresponds to a I<cpu> value of 1, and so on.  The constant "
"B<CPU_SETSIZE> (currently 1024) specifies a value one greater than the "
"maximum CPU number that can be stored in I<cpu_set_t>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:139
msgid "The following macros perform logical operations on CPU sets:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:139
#, no-wrap
msgid "B<CPU_AND>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:148
msgid ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:148
#, no-wrap
msgid "B<CPU_OR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:157
msgid ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:157
#, no-wrap
msgid "B<CPU_XOR>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:171
msgid ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:171
#, no-wrap
msgid "B<CPU_EQUAL>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:174
msgid "Test whether two CPU set contain exactly the same CPUs."
msgstr ""

#. type: SS
#: build/C/man3/CPU_SET.3:174
#, no-wrap
msgid "Dynamically sized CPU sets"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:180
msgid ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:182
msgid "The following macros are used to allocate and deallocate CPU sets:"
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:182
#, no-wrap
msgid "B<CPU_ALLOC>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:187
msgid ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to "
"I<num_cpus-1>."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:187
#, no-wrap
msgid "B<CPU_ALLOC_SIZE>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:197
msgid ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described "
"below."
msgstr ""

#. type: TP
#: build/C/man3/CPU_SET.3:197
#, no-wrap
msgid "B<CPU_FREE>()"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:201
msgid "Free a CPU set previously allocated by B<CPU_ALLOC>()."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:208
msgid ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:208 build/C/man2/clone.2:792 build/C/man2/sched_get_priority_max.2:87 build/C/man3/sched_getcpu.3:38 build/C/man2/sched_rr_get_interval.2:74 build/C/man2/sched_setaffinity.2:108 build/C/man2/sched_setparam.2:88 build/C/man2/sched_setscheduler.2:423 build/C/man2/sched_yield.2:42 build/C/man2/setns.2:66 build/C/man2/unshare.2:183
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:217
msgid ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:223
msgid "B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:228
msgid ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise it returns 0."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:233
msgid ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:237
msgid ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:239
msgid "The other functions do not return a value."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:239 build/C/man2/clone.2:909 build/C/man3/sched_getcpu.3:50 build/C/man2/sched_setaffinity.2:149 build/C/man2/setns.2:93 build/C/man2/unshare.2:200
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:247
msgid ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:250
msgid "B<CPU_COUNT>()  first appeared in glibc 2.6."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:268
msgid ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), "
"B<CPU_XOR_S>(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:268 build/C/man2/clone.2:916 build/C/man2/sched_get_priority_max.2:101 build/C/man3/sched_getcpu.3:52 build/C/man2/sched_rr_get_interval.2:95 build/C/man2/sched_setaffinity.2:160 build/C/man2/sched_setparam.2:111 build/C/man2/sched_setscheduler.2:445 build/C/man2/sched_yield.2:53 build/C/man2/setns.2:97 build/C/man2/unshare.2:204
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:270
msgid "These interfaces are Linux-specific."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:270 build/C/man2/clone.2:923 build/C/man3/sched_getcpu.3:55 build/C/man2/sched_rr_get_interval.2:97 build/C/man2/sched_setaffinity.2:162 build/C/man2/sched_setscheduler.2:448 build/C/man2/sched_yield.2:55 build/C/man2/setns.2:101 build/C/man2/unshare.2:208
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:273
msgid "To duplicate a CPU set, use B<memcpy>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:280
msgid ""
"Since CPU sets are bitsets allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:292
msgid ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of bits in the bitset), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:298
msgid ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:298 build/C/man2/clone.2:970 build/C/man2/sched_setscheduler.2:509 build/C/man2/setns.2:107
#, no-wrap
msgid "BUGS"
msgstr ""

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7029
#. type: Plain text
#: build/C/man3/CPU_SET.3:310
msgid ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:310
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:313
msgid ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:321
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:328
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus, cpu;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:333
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:335
#, no-wrap
msgid "    num_cpus = atoi(argv[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:341
#, no-wrap
msgid ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:343
#, no-wrap
msgid "    size = CPU_ALLOC_SIZE(num_cpus);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:347
#, no-wrap
msgid ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:349
#, no-wrap
msgid "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:353
#, no-wrap
msgid ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:354 build/C/man2/clone.2:1012 build/C/man2/sched_get_priority_max.2:103 build/C/man3/sched_getcpu.3:75 build/C/man2/sched_rr_get_interval.2:126 build/C/man2/sched_setaffinity.2:215 build/C/man2/sched_setparam.2:113 build/C/man2/sched_setscheduler.2:517 build/C/man2/sched_yield.2:79 build/C/man2/setns.2:115 build/C/man2/unshare.2:244
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:359
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"
msgstr ""

#. type: SH
#: build/C/man3/CPU_SET.3:359 build/C/man2/clone.2:1024 build/C/man2/sched_get_priority_max.2:113 build/C/man3/sched_getcpu.3:77 build/C/man2/sched_rr_get_interval.2:132 build/C/man2/sched_setaffinity.2:231 build/C/man2/sched_setparam.2:127 build/C/man2/sched_setscheduler.2:542 build/C/man2/sched_yield.2:85 build/C/man2/setns.2:121 build/C/man2/unshare.2:249
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:366 build/C/man2/clone.2:1031 build/C/man2/sched_get_priority_max.2:120 build/C/man3/sched_getcpu.3:84 build/C/man2/sched_rr_get_interval.2:139 build/C/man2/sched_setaffinity.2:238 build/C/man2/sched_setparam.2:134 build/C/man2/sched_setscheduler.2:549 build/C/man2/sched_yield.2:92 build/C/man2/setns.2:128 build/C/man2/unshare.2:256
msgid ""
"This page is part of release 3.38 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/clone.2:43
#, no-wrap
msgid "CLONE"
msgstr ""

#. type: TH
#: build/C/man2/clone.2:43
#, no-wrap
msgid "2011-09-08"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:46
msgid "clone, __clone2 - create a child process"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:57
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t "
"*>I<ctid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:69
msgid ""
"B<clone>()  creates a new process, in a manner similar to B<fork>(2).  It is "
"actually a library function layered on top of the underlying B<clone>()  "
"system call, hereinafter referred to as B<sys_clone>.  A description of "
"B<sys_clone> is given toward the end of this page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:81
msgid ""
"Unlike B<fork>(2), these calls allow the child process to share parts of its "
"execution context with the calling process, such as the memory space, the "
"table of file descriptors, and the table of signal handlers.  (Note that on "
"this manual page, \"calling process\" normally corresponds to \"parent "
"process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:86
msgid ""
"The main use of B<clone>()  is to implement threads: multiple threads of "
"control in a program that run concurrently in a shared memory space."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:107
msgid ""
"When the child process is created with B<clone>(), it executes the function "
"application I<fn>(I<arg>).  (This differs from B<fork>(2), where execution "
"continues in the child from the point of the B<fork>(2)  call.)  The I<fn> "
"argument is a pointer to a function that is called by the child process at "
"the beginning of its execution.  The I<arg> argument is passed to the I<fn> "
"function."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:117
msgid ""
"When the I<fn>(I<arg>)  function application returns, the child process "
"terminates.  The integer returned by I<fn> is the exit code for the child "
"process.  The child process may also terminate explicitly by calling "
"B<exit>(2)  or after receiving a fatal signal."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:133
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:149
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with "
"B<wait>(2).  If no signal is specified, then the parent process is not "
"signaled when the child terminates."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:154
msgid ""
"I<flags> may also be bitwise-or'ed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:154
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:164
msgid ""
"Erase child thread ID at location I<ctid> in child memory when the child "
"exits, and do a wakeup on the futex at that address.  The address involved "
"may be changed by the B<set_tid_address>(2)  system call.  This is used by "
"threading libraries."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:164
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:169
msgid "Store child thread ID at location I<ctid> in child memory."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:169 build/C/man2/unshare.2:53
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:182
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:196
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  (The "
"duplicated file descriptors in the child refer to the same open file "
"descriptions (see B<open>(2))  as the corresponding file descriptors in the "
"calling process.)  Subsequent operations that open or close file "
"descriptors, or change file descriptor flags, performed by either the "
"calling process or the child process do not affect the other process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:196 build/C/man2/unshare.2:61
#, no-wrap
msgid "B<CLONE_FS>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:211
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same file "
"system information.  This includes the root of the file system, the current "
"working directory, and the umask.  Any call to B<chroot>(2), B<chdir>(2), or "
"B<umask>(2)  performed by the calling process or the child process also "
"affects the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:223
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the file "
"system information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), B<umask>(2)  performed later by "
"one of the processes do not affect the other process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:223
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:232
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: build/C/man2/clone.2:249
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e, what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:253
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:253 build/C/man2/unshare.2:74
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:263
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:274
msgid ""
"An IPC namespace consists of the set of identifiers for System V IPC "
"objects.  (These objects are created using B<msgctl>(2), B<semctl>(2), and "
"B<shmctl>(2)).  Objects created in an IPC namespace are visible to all other "
"processes that are members of that namespace, but are not visible to "
"processes in other IPC namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:278
msgid ""
"When an IPC namespace is destroyed (i.e, when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:287
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_SYSVIPC> "
"and B<CONFIG_IPC_NS> options and that the process be privileged "
"(B<CAP_SYS_ADMIN>).  This flag can't be specified in conjunction with "
"B<CLONE_SYSVSEM>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:287 build/C/man2/unshare.2:91
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr ""

#.  FIXME Check when the implementation was completed
#. type: Plain text
#: build/C/man2/clone.2:292
msgid ""
"(The implementation of this flag was only completed by about kernel version "
"2.6.29.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:301
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2)), the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:315
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network device (\"veth\") pair provides a "
"pipe-like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:320
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:325
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_NET_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:325
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:328
msgid "Start the child in a new mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:349
msgid ""
"Every process lives in a mount namespace.  The I<namespace> of a process is "
"the data (the set of mounts) describing the file hierarchy as seen by that "
"process.  After a B<fork>(2)  or B<clone>()  where the B<CLONE_NEWNS> flag "
"is not set, the child lives in the same mount namespace as the parent.  The "
"system calls B<mount>(2)  and B<umount>(2)  change the mount namespace of "
"the calling process, and hence affect all processes that live in the same "
"namespace, but do not affect processes in a different mount namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:356
msgid ""
"After a B<clone>()  where the B<CLONE_NEWNS> flag is set, the cloned child "
"is started in a new mount namespace, initialized with a copy of the "
"namespace of the parent."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:368
msgid ""
"Only a privileged process (one having the B<CAP_SYS_ADMIN> capability)  may "
"specify the B<CLONE_NEWNS> flag.  It is not permitted to specify both "
"B<CLONE_NEWNS> and B<CLONE_FS> in the same B<clone>()  call."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:368
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr ""

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: build/C/man2/clone.2:385
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:394
msgid ""
"A PID namespace provides an isolated environment for PIDs: PIDs in a new "
"namespace start at 1, somewhat like a standalone system, and calls to "
"B<fork>(2), B<vfork>(2), or B<clone>()  will produce processes with PIDs "
"that are unique within the namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:406
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using the B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process "
"for the namespace.  Children that are orphaned within the namespace will be "
"reparented to this process rather than B<init>(8).  Unlike the traditional "
"B<init> process, the \"init\" process of a PID namespace can terminate, and "
"if it does, all of the processes in the namespace are terminated."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:425
msgid ""
"PID namespaces form a hierarchy.  When a new PID namespace is created, the "
"processes in that namespace are visible in the PID namespace of the process "
"that created the new namespace; analogously, if the parent PID namespace is "
"itself the child of another PID namespace, then processes in the child and "
"parent PID namespaces will both be visible in the grandparent PID "
"namespace.  Conversely, the processes in the \"child\" PID namespace do not "
"see the processes in the parent namespace.  The existence of a namespace "
"hierarchy means that each process may now have multiple PIDs: one for each "
"namespace in which it is visible; each of these PIDs is unique within the "
"corresponding namespace.  (A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process lives.)"
msgstr ""

#.  mount -t proc proc /proc
#. type: Plain text
#: build/C/man2/clone.2:441
msgid ""
"After creating the new namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  (If B<CLONE_NEWNS> is also included in "
"I<flags>, then it isn't necessary to change the root directory: a new procfs "
"instance can be mounted directly over I</proc>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:448
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_PID_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>).  This flag "
"can't be specified in conjunction with B<CLONE_THREAD>."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:448 build/C/man2/unshare.2:140
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:460
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2)), the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of "
"containers."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:472
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the host name can be modified by "
"B<setdomainname>(2)  and B<sethostname>(2), respectively.  Changes made to "
"the identifiers in a UTS namespace are visible to all other processes in the "
"same namespace, but are not visible to processes in other UTS namespaces."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:477
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_UTS_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:477
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:484
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:490
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:498
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:498
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:506
msgid ""
"Store child thread ID at location I<ptid> in parent and child memory.  (In "
"Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:506
#, no-wrap
msgid "B<CLONE_PID> (obsolete)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:517
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  Since 2.3.21 this flag can be specified only by "
"the system boot process (PID 0).  It disappeared in Linux 2.5.16."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:517
#, no-wrap
msgid "B<CLONE_PTRACE>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:524
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:524
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:531
msgid ""
"The I<newtls> argument is the new TLS (Thread Local Storage) descriptor.  "
"(See B<set_thread_area>(2).)"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:531
#, no-wrap
msgid "B<CLONE_SIGHAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:547
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock some signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:558
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:566
msgid ""
"Since Linux 2.6.0-test6, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:566
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0-test2)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:575
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: build/C/man2/clone.2:583
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:583
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:592
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore undo values (see B<semop>(2)).  If this "
"flag is not set, then the child has a separate undo list, which is initially "
"empty."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:592
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0-test8)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:601
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:609
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:618
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:628
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:650
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:655
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:660
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:666
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:674
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:679
msgid ""
"Signals may be sent to a thread group as a whole (i.e., a TGID) using "
"B<kill>(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:684
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:697
msgid ""
"Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
"signals can be pending either: for the whole process (i.e., deliverable to "
"any member of the thread group), when sent with B<kill>(2); or for an "
"individual thread, when sent with B<tgkill>(2).  A call to B<sigpending>(2)  "
"returns a signal set that is the union of the signals pending for the whole "
"process and the signals that are pending for the calling thread."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:709
msgid ""
"If B<kill>(2)  is used to send a signal to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive a signal sent using B<kill>(2)."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:709
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:716
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:716
#, no-wrap
msgid "B<CLONE_VFORK>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:728
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to "
"B<execve>(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:734
msgid ""
"If B<CLONE_VFORK> is not set then both the calling process and the child are "
"schedulable after the call, and an application should not rely on execution "
"occurring in any particular order."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:734
#, no-wrap
msgid "B<CLONE_VM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:747
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other "
"process."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:756
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""

#. type: SS
#: build/C/man2/clone.2:756
#, no-wrap
msgid "sys_clone"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:773
msgid ""
"The B<sys_clone> system call corresponds more closely to B<fork>(2)  in that "
"execution in the child continues from the point of the call.  Thus, "
"B<sys_clone> only requires the I<flags> and I<child_stack> arguments, which "
"have the same meaning as for B<clone>().  (Note that the order of these "
"arguments differs from B<clone>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:784
msgid ""
"Another difference for B<sys_clone> is that the I<child_stack> argument may "
"be zero, in which case copy-on-write semantics ensure that the child gets "
"separate copies of stack pages when either process modifies the stack.  In "
"this case, for correct operation, the B<CLONE_VM> option should not be "
"specified."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:792
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: build/C/man2/clone.2:801
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""

#. type: SH
#: build/C/man2/clone.2:801 build/C/man2/sched_get_priority_max.2:97 build/C/man3/sched_getcpu.3:45 build/C/man2/sched_rr_get_interval.2:81 build/C/man2/sched_setaffinity.2:117 build/C/man2/sched_setparam.2:97 build/C/man2/sched_setscheduler.2:433 build/C/man2/sched_yield.2:49 build/C/man2/setns.2:73 build/C/man2/unshare.2:188
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/clone.2:802
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:805
msgid "Too many processes are already running."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:805 build/C/man2/clone.2:812 build/C/man2/clone.2:827 build/C/man2/clone.2:835 build/C/man2/clone.2:843 build/C/man2/clone.2:851 build/C/man2/clone.2:857 build/C/man2/clone.2:867 build/C/man2/clone.2:875 build/C/man2/clone.2:883 build/C/man2/sched_get_priority_max.2:98 build/C/man2/sched_rr_get_interval.2:85 build/C/man2/sched_setaffinity.2:121 build/C/man2/sched_setaffinity.2:129 build/C/man2/sched_setparam.2:98 build/C/man2/sched_setscheduler.2:434 build/C/man2/setns.2:78 build/C/man2/unshare.2:189
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:812
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux "
"2.6.0-test6.)"
msgstr ""

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: build/C/man2/clone.2:827
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:835
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:843
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:851
msgid "Both B<CLONE_NEWPID> and B<CLONE_THREAD> were specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:857
msgid "Returned by B<clone>()  when a zero value is specified for I<child_stack>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:867
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:875
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:883
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:891
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS> option."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:891 build/C/man2/setns.2:85 build/C/man2/unshare.2:193
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:896
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be "
"copied."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:896 build/C/man2/clone.2:905 build/C/man2/sched_setaffinity.2:136 build/C/man2/sched_setparam.2:102 build/C/man2/sched_setscheduler.2:439 build/C/man2/setns.2:88 build/C/man2/unshare.2:197
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:905
msgid ""
"B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, or "
"B<CLONE_NEWUTS> was specified by an unprivileged process (process without "
"B<CAP_SYS_ADMIN>)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:909
msgid "B<CLONE_PID> was specified by a process other than process 0."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:916
msgid ""
"There is no entry for B<clone>()  in libc5.  glibc2 provides B<clone>()  as "
"described in this manual page."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:923
msgid ""
"The B<clone>()  and B<sys_clone> calls are Linux-specific and should not be "
"used in programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:933
msgid ""
"In the kernel 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in kernel 2.6)."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:943
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In 2.6.2 the need to give this together with "
"B<CLONE_THREAD> disappeared.  This flag is still defined, but has no effect."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:948
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:950
msgid "On ia64, a different system call is used:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:957
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t "
"*>I<ctid>B< */ );>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:970
msgid ""
"The B<__clone2>()  system call operates in the same way as B<clone>(), "
"except that I<child_stack_base> points to the lowest address of the child's "
"stack area, and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1001
msgid ""
"Versions of the GNU C library that include the NPTL threading library "
"contain a wrapper function for B<getpid>(2)  that performs caching of PIDs.  "
"This caching relies on support in the glibc wrapper for B<clone>(), but as "
"currently implemented, the cache may not be up to date in some "
"circumstances.  In particular, if a signal is delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal may return the PID of the calling process (\"the "
"parent\"), if the clone wrapper has not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it may be necessary to use code such as the following:"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1004
#, no-wrap
msgid "    #include E<lt>syscall.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1006
#, no-wrap
msgid "    pid_t mypid;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1008
#, no-wrap
msgid "    mypid = syscall(SYS_getpid);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/clone.2:1024
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<set_thread_area>(2), "
"B<set_tid_address>(2), B<tkill>(2), B<unshare>(2), B<wait>(2), "
"B<capabilities>(7), B<pthreads>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_get_priority_max.2:30
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr ""

#. type: TH
#: build/C/man2/sched_get_priority_max.2:30 build/C/man2/sched_setparam.2:31
#, no-wrap
msgid "2006-03-23"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:33
msgid "sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:35 build/C/man2/sched_rr_get_interval.2:35 build/C/man2/sched_yield.2:35
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:37
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:39
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:55
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, and "
"B<SCHED_BATCH>.  Further details about these policies can be found in "
"B<sched_setscheduler>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:64
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:70
msgid ""
"Linux allows the static priority value range 1 to 99 for B<SCHED_FIFO> and "
"B<SCHED_RR> and the priority 0 for B<SCHED_OTHER> and B<SCHED_BATCH>.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:79
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>().  POSIX.1-2001 requires a spread of at least 32 "
"between the maximum and the minimum values for B<SCHED_FIFO> and "
"B<SCHED_RR>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:87
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:97
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:101
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:103 build/C/man2/sched_rr_get_interval.2:97 build/C/man2/sched_setparam.2:113 build/C/man2/sched_yield.2:55
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:110
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:113 build/C/man2/sched_rr_get_interval.2:132 build/C/man2/sched_setparam.2:127 build/C/man2/sched_setscheduler.2:538 build/C/man2/sched_yield.2:85
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly "
"& Associates, Inc., ISBN 1-56592-074-0"
msgstr ""

#. type: TH
#: build/C/man3/sched_getcpu.3:24
#, no-wrap
msgid "SCHED_GETCPU"
msgstr ""

#. type: TH
#: build/C/man3/sched_getcpu.3:24
#, no-wrap
msgid "2010-10-31"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:27
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr ""

#.  Really:_BSD_SOURCE || _SVID_SOURCE
#. type: Plain text
#: build/C/man3/sched_getcpu.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:38
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:45
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man3/sched_getcpu.3:46 build/C/man2/sched_rr_get_interval.2:88
#, no-wrap
msgid "B<ENOSYS>"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:50
msgid "This kernel does not implement B<getcpu>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:52
msgid "This function is available since glibc 2.6."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:55
msgid "B<sched_getcpu>()  is glibc specific."
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:57
msgid "The call"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:61
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:67
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:73
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/sched_getcpu.3:77
msgid "B<getcpu>(2)"
msgstr ""

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:30
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr ""

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:30
#, no-wrap
msgid "2011-10-16"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:33
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:37
msgid "B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec * >I<tp>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:48
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:52
msgid "The I<timespec> structure has the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:59
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:74
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:81
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/sched_rr_get_interval.2:82 build/C/man2/sched_setaffinity.2:118
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:85
msgid "Problem with copying information to userspace."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:88
msgid "Invalid pid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:91
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""

#. type: TP
#: build/C/man2/sched_rr_get_interval.2:91 build/C/man2/sched_setaffinity.2:146 build/C/man2/sched_setparam.2:108 build/C/man2/sched_setscheduler.2:442
#, no-wrap
msgid "B<ESRCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:95
msgid "Could not find a process with the ID I<pid>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:104
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: SS
#: build/C/man2/sched_rr_get_interval.2:104
#, no-wrap
msgid "Linux Notes"
msgstr ""

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:126
msgid ""
"POSIX does not specify any mechanism for controlling the size of the "
"round-robin time quantum.  Older Linux kernels provide a (nonportable) "
"method of doing this.  The quantum can be controlled by adjusting the "
"process's nice value (see B<setpriority>(2)).  Assigning a negative (i.e., "
"high) nice value results in a longer quantum; assigning a positive (i.e., "
"low) nice value results in a shorter quantum.  The default quantum is 0.1 "
"seconds; the degree to which changing the nice value affects the quantum has "
"varied somewhat across kernel versions.  Since Linux 2.6.24, the B<SCHED_RR> "
"quantum cannot be modified."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:129 build/C/man2/sched_setaffinity.2:178
msgid "B<sched_setscheduler>(2)  has a description of the Linux scheduling scheme."
msgstr ""

#. type: TH
#: build/C/man2/sched_setaffinity.2:35
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr ""

#. type: TH
#: build/C/man2/sched_setaffinity.2:35
#, no-wrap
msgid "2010-11-06"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:39
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a process's CPU affinity "
"mask"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:46
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:49
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:64
msgid ""
"A process's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular process (i.e., setting the affinity mask of that process "
"to specify a single CPU, and setting the affinity mask of all other "
"processes to exclude that CPU), it is possible to ensure maximum execution "
"speed for that process.  Restricting a process to run on a single CPU also "
"avoids the performance cost caused by the cache invalidation that occurs "
"when a process ceases to execute on one CPU and then recommences execution "
"on a different CPU."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:71
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU "
"set\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:86
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the process whose ID "
"is I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling process is used.  The argument I<cpusetsize> is the length (in "
"bytes) of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:93
msgid ""
"If the process specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that process is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:108
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the process whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling process is returned."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:117
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:121
msgid "A supplied memory address was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:129
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the process according to any "
"restrictions that may be imposed by the \"cpuset\" mechanism described in "
"B<cpuset>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:136
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, "
"B<sched_setaffinity>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:146
msgid ""
"(B<sched_setaffinity>())  The calling process does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the process identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:149 build/C/man2/sched_setparam.2:111 build/C/man2/sched_setscheduler.2:445
msgid "The process whose ID is I<pid> could not be found."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:160
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:162
msgid "These system calls are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:175
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the process "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the process runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the process will run are silently imposed by "
"the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:195
msgid ""
"The affinity mask is actually a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:201
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:215
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask.  On success, the raw "
"B<sched_getaffinity>()  system call returns the size (in bytes) of the "
"I<cpumask_t> data type that is used internally by the kernel to represent "
"the CPU set bit mask."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:231
msgid ""
"B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), B<nice>(2), "
"B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setparam.2:31
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:34
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:37 build/C/man2/sched_setscheduler.2:54
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:39
#, no-wrap
msgid ""
"B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param "
"*>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:41
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:47 build/C/man2/sched_setscheduler.2:66
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:61
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the process identified by I<pid>.  If I<pid> is zero, "
"then the parameters of the calling process are set.  The interpretation of "
"the argument I<param> depends on the scheduling policy of the process "
"identified by I<pid>.  See B<sched_setscheduler>(2)  for a description of "
"the scheduling policies supported under Linux."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:67
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the process "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"process are retrieved."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:76
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the process.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:80
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched_setscheduler>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:88
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:97
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:102
msgid "The argument I<param> does not make sense for the current scheduling policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:108
msgid ""
"The calling process does not have appropriate privileges (Linux: does not "
"have the B<CAP_SYS_NICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setparam.2:124
msgid ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), "
"B<sched_getscheduler>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<setpriority>(2), B<capabilities>(7)"
msgstr ""

#. type: TH
#: build/C/man2/sched_setscheduler.2:47
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr ""

#. type: TH
#: build/C/man2/sched_setscheduler.2:47
#, no-wrap
msgid "2011-09-19"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:51
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling "
"policy/parameters"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:56
#, no-wrap
msgid "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:58
#, no-wrap
msgid "B<                       const struct sched_param *>I<param>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:60
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:77
msgid ""
"B<sched_setscheduler>()  sets both the scheduling policy and the associated "
"parameters for the process whose ID is specified in I<pid>.  If I<pid> "
"equals zero, the scheduling policy and parameters of the calling process "
"will be set.  The interpretation of the argument I<param> depends on the "
"selected policy.  Currently, Linux supports the following \"normal\" (i.e., "
"non-real-time) scheduling policies:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:77
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr ""

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:82
msgid "the standard round-robin time-sharing policy;"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:82
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:85
msgid "for \"batch\" style execution of processes; and"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:85
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:90
msgid "for running I<very> low priority background jobs."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:94
msgid ""
"The following \"real-time\" policies are also supported, for special "
"time-critical applications that need precise control over the way in which "
"runnable processes are selected for execution:"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:94
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:97
msgid "a first-in, first-out policy; and"
msgstr ""

#. type: TP
#: build/C/man2/sched_setscheduler.2:97
#, no-wrap
msgid "B<SCHED_RR>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:100
msgid "a round-robin policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:102
msgid "The semantics of each of these policies are detailed below."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:109
msgid ""
"B<sched_getscheduler>()  queries the scheduling policy currently applied to "
"the process identified by I<pid>.  If I<pid> equals zero, the policy of the "
"calling process will be retrieved."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:109
#, no-wrap
msgid "Scheduling Policies"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:118
msgid ""
"The scheduler is the kernel component that decides which runnable process "
"will be executed by the CPU next.  Each process has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>; these are the "
"settings that are modified by B<sched_setscheduler>().  The scheduler makes "
"it decisions based on knowledge of the scheduling policy and static priority "
"of all processes on the system."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:123
msgid ""
"For processes scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:137
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time processes always have higher "
"priority than normal processes.)  Note well: POSIX.1-2001 only requires an "
"implementation to support a minimum 32 distinct priority levels for the "
"real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:143
msgid ""
"Conceptually, the scheduler maintains a list of runnable processes for each "
"possible I<sched_priority> value.  In order to determine which process runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the process at the head of this list."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:147
msgid ""
"A process's scheduling policy determines where it will be inserted into the "
"list of processes with equal static priority and how it will move inside "
"this list."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:155
msgid ""
"All scheduling is preemptive: if a process with a higher static priority "
"becomes ready to run, the currently running process will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy only determines the ordering within the list of runnable processes "
"with equal static priority."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:155
#, no-wrap
msgid "SCHED_FIFO: First In-First Out scheduling"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:164
msgid ""
"B<SCHED_FIFO> can only be used with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> processes becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> process.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For processes scheduled under the B<SCHED_FIFO> "
"policy, the following rules apply:"
msgstr ""

#. type: IP
#: build/C/man2/sched_setscheduler.2:164 build/C/man2/sched_setscheduler.2:169 build/C/man2/sched_setscheduler.2:172 build/C/man2/sched_setscheduler.2:186 build/C/man2/sched_setscheduler.2:288 build/C/man2/sched_setscheduler.2:296 build/C/man2/sched_setscheduler.2:337 build/C/man2/sched_setscheduler.2:345 build/C/man2/sched_setscheduler.2:350 build/C/man2/sched_setscheduler.2:355
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:169
msgid ""
"A B<SCHED_FIFO> process that has been preempted by another process of higher "
"priority will stay at the head of the list for its priority and will resume "
"execution as soon as all processes of higher priority are blocked again."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:172
msgid ""
"When a B<SCHED_FIFO> process becomes runnable, it will be inserted at the "
"end of the list for its priority."
msgstr ""

#.  In 2.2.x and 2.4.x, the process is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the process went to the back -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:186
msgid ""
"A call to B<sched_setscheduler>()  or B<sched_setparam>(2)  will put the "
"B<SCHED_FIFO> (or B<SCHED_RR>) process identified by I<pid> at the start of "
"the list if it was runnable.  As a consequence, it may preempt the currently "
"running process if it has the same priority.  (POSIX.1-2001 specifies that "
"the process should go to the end of the list.)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:190
msgid "A process calling B<sched_yield>(2)  will be put at the end of the list."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:194
msgid ""
"No other events will move a process scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable processes with equal static priority."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:199
msgid ""
"A B<SCHED_FIFO> process runs until either it is blocked by an I/O request, "
"it is preempted by a higher priority process, or it calls B<sched_yield>(2)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:199
#, no-wrap
msgid "SCHED_RR: Round Robin scheduling"
msgstr ""

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:218
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each "
"process is only allowed to run for a maximum time quantum.  If a B<SCHED_RR> "
"process has been running for a time period equal to or longer than the time "
"quantum, it will be put at the end of the list for its priority.  A "
"B<SCHED_RR> process that has been preempted by a higher priority process and "
"subsequently resumes execution as a running process will complete the "
"unexpired portion of its round robin time quantum.  The length of the time "
"quantum can be retrieved using B<sched_rr_get_interval>(2)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:218
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:234
msgid ""
"B<SCHED_OTHER> can only be used at static priority 0.  B<SCHED_OTHER> is the "
"standard Linux time-sharing scheduler that is intended for all processes "
"that do not require the special real-time mechanisms.  The process to run is "
"chosen from the static priority 0 list based on a I<dynamic> priority that "
"is determined only inside this list.  The dynamic priority is based on the "
"nice value (set by B<nice>(2)  or B<setpriority>(2))  and increased for each "
"time quantum the process is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> processes."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:234
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:246
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can only be used at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the "
"process according to its dynamic priority (based on the nice value).  The "
"difference is that this policy will cause the scheduler to always assume "
"that the process is CPU-intensive.  Consequently, the scheduler will apply a "
"small scheduling penalty with respect to wakeup behaviour, so that this "
"process is mildly disfavored in scheduling decisions."
msgstr ""

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:255
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:255
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:259
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can only be used at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:267
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:267
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:283
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  This feature is intended for media-playback applications, and can "
"be used to prevent applications evading the B<RLIMIT_RTTIME> resource limit "
"(see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:288
msgid ""
"More precisely, if the B<SCHED_RESET_ON_FORK> flag is specified, the "
"following rules apply for subsequently created children:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:296
msgid ""
"If the calling process has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:299
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:308
msgid ""
"After the B<SCHED_RESET_ON_FORK> flag has been enabled, it can only be reset "
"if the process has the B<CAP_SYS_NICE> capability.  This flag is disabled in "
"child processes created by B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:314
msgid ""
"The B<SCHED_RESET_ON_FORK> flag is visible in the policy value returned by "
"B<sched_getscheduler>()"
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:314
#, no-wrap
msgid "Privileges and resource limits"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:327
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  processes "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged process can make is to set "
"the B<SCHED_OTHER> policy, and this can only be done if the effective user "
"ID of the caller of B<sched_setscheduler>()  matches the real or effective "
"user ID of the target process (i.e., the process specified by I<pid>)  whose "
"policy is being changed."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:337
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged process's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:345
msgid ""
"If an unprivileged process has a nonzero B<RLIMIT_RTPRIO> soft limit, then "
"it can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:350
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:355
msgid ""
"Subject to the same rules, another unprivileged process can also make these "
"changes, as long as the effective user ID of the process making the change "
"matches the real or effective user ID of the target process."
msgstr ""

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:373
msgid ""
"Special rules apply for the B<SCHED_IDLE>.  In Linux kernels before 2.6.39, "
"an unprivileged process operating under this policy cannot change its "
"policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In "
"Linux kernels since 2.6.39, an unprivileged process can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_NORMAL> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:384
msgid ""
"Privileged (B<CAP_SYS_NICE>)  processes ignore the B<RLIMIT_RTPRIO> limit; "
"as with older kernels, they can make arbitrary changes to scheduling policy "
"and priority.  See B<getrlimit>(2)  for further information on "
"B<RLIMIT_RTPRIO>."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:384
#, no-wrap
msgid "Response time"
msgstr ""

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:392
msgid ""
"A blocked high priority process waiting for the I/O has a certain response "
"time before it is scheduled again.  The device driver writer can greatly "
"reduce this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:392
#, no-wrap
msgid "Miscellaneous"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:397
msgid ""
"Child processes inherit the scheduling policy and parameters across a "
"B<fork>(2).  The scheduling policy and parameters are preserved across "
"B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:403
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:415
msgid ""
"Since a nonblocking infinite loop in a process scheduled under B<SCHED_FIFO> "
"or B<SCHED_RR> will block all processes with lower priority forever, a "
"software developer should always keep available on the console a shell "
"scheduled under a higher static priority than the tested application.  This "
"will allow an emergency kill of tested real-time applications that do not "
"block or terminate as expected.  See also the description of the "
"B<RLIMIT_RTTIME> resource limit in B<getrlimit>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:423
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:433
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the process (a nonnegative "
"integer).  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:439
msgid ""
"The scheduling I<policy> is not one of the recognized policies, I<param> is "
"NULL, or I<param> does not make sense for the I<policy>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:442
msgid "The calling process does not have appropriate privileges."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:448
msgid ""
"POSIX.1-2001 (but see BUGS below).  The B<SCHED_BATCH> and B<SCHED_IDLE> "
"policies are Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:456
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged process "
"requires in order to call B<sched_setscheduler>(), and details vary across "
"systems.  For example, the Solaris 7 manual page says that the real or "
"effective user ID of the calling process must match the real user ID or the "
"save set-user-ID of the target process."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:466
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:466
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr ""

#.  FIXME . Probably this text will need some minor tweaking
#.  by about the time of 2.6.30; ask Carsten Emde about this then.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:480
msgid ""
"From kernel version 2.6.18 onward, however, Linux is gradually becoming "
"equipped with real-time capabilities, most of which are derived from the "
"former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
"Gleixner, Steven Rostedt, and others.  Until the patches have been "
"completely merged into the mainline kernel (this is expected to be around "
"kernel version 2.6.30), they must be installed to achieve the best real-time "
"performance.  These patches are named:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:484
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:489
msgid ""
"and can be downloaded from "
"I<http://www.kernel.org/pub/linux/kernel/projects/rt/>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:498
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:509
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular "
"real-time operating system.  The FIFO and RR scheduling policies that can be "
"selected using B<sched_setscheduler>()  are then used to run a process with "
"true real-time priority and a minimum worst-case scheduling latency."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:517
msgid ""
"POSIX says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:535
msgid ""
"B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<capabilities>(7), B<cpuset>(7)"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:542
msgid ""
"The kernel source file I<Documentation/scheduler/sched-rt-group.txt> (since "
"kernel 2.6.25)."
msgstr ""

#. type: TH
#: build/C/man2/sched_yield.2:30
#, no-wrap
msgid "SCHED_YIELD"
msgstr ""

#. type: TH
#: build/C/man2/sched_yield.2:30
#, no-wrap
msgid "2008-10-18"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:33
msgid "sched_yield - yield the processor"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:37
msgid "B<int sched_yield(void);>"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:42
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:49
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:53
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:60
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources "
"(e.g., mutexes)  have been released by the caller.  Avoid calling "
"B<sched_yield>()  unnecessarily or inappropriately (e.g., when resources "
"needed by other schedulable threads are still held by the caller), since "
"doing so will result in unnecessary context switches, which will degrade "
"system performance."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_yield.2:82
msgid "B<sched_setscheduler>(2)  for a description of Linux scheduling."
msgstr ""

#. type: TH
#: build/C/man2/setns.2:4
#, no-wrap
msgid "SETNS"
msgstr ""

#. type: TH
#: build/C/man2/setns.2:4
#, no-wrap
msgid "2011-10-04"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:7
msgid "setns - reassociate thread with a namespace"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:13
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:17
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:30
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<proc>(5)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:36
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""

#. type: TP
#: build/C/man2/setns.2:36
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:39
msgid "Allow any type of namespace to be joined."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:39
#, no-wrap
msgid "B<CLONE_NEWIPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:43
msgid "I<fd> must refer to an IPC namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWNET>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:47
msgid "I<fd> must refer to a network namespace."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWUTS>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:51
msgid "I<fd> must refer to a UTS namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:66
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:73
msgid ""
"On success, I<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/setns.2:74
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:78
msgid "I<fd> is not a valid file descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:85
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>, or there is problem with reassociating the the thread with the "
"specified namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:88
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:93
msgid ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:97
msgid "The B<setns>()  system call first appeared in Linux in kernel 3.0"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:101
msgid "The B<setns>()  system call is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:107
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:115
msgid ""
"The PID namespace and the mount namespace are not currently supported.  (See "
"the descriptions of B<CLONE_NEWPID> and B<CLONE_NEWNS> in B<clone>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man2/setns.2:121
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man2/unshare.2:17
#, no-wrap
msgid "UNSHARE"
msgstr ""

#. type: TH
#: build/C/man2/unshare.2:17
#, no-wrap
msgid "2010-10-30"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:20
msgid "unshare - disassociate parts of the process execution context"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:28
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:41
msgid ""
"B<unshare>()  allows a process to disassociate parts of its execution "
"context that are currently being shared with other processes.  Part of the "
"execution context, such as the mount namespace, is shared implicitly when a "
"new process is created using B<fork>(2)  or B<vfork>(2), while other parts, "
"such as virtual memory, may be shared by explicit request when creating a "
"process using B<clone>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:46
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:53
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:61
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:74
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare file "
"system attributes, so that the calling process no longer shares its root "
"directory, current directory, or umask attributes with any other process.  "
"B<chroot>(2), B<chdir>(2), or B<umask>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:91
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the System V IPC namespace, so that the calling process has a "
"private copy of the System V IPC namespace which is not shared with any "
"other process.  Specifying this flag automatically implies B<CLONE_SYSVSEM> "
"as well.  Use of B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:105
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:105
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr ""

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: build/C/man2/unshare.2:126
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: TP
#: build/C/man2/unshare.2:126
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:140
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System V semaphore undo values, so that the calling process has a "
"private copy which is not shared with any other process.  Use of "
"B<CLONE_SYSVSEM> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#.  As at 2.6.16, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  CLONE_NEWNSIf CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#
#.  FIXME . CLONE_VM is not (yet, as at 2.6.16) implemented.
#.  .TP
#.  .B CLONE_VM
#.  Reverse the effect of the
#.  .BR clone (2)
#.  .B CLONE_VM
#.  flag.
#.  .RB ( CLONE_VM
#.  is also implicitly set by
#.  .BR vfork (2),
#.  and can be reversed using this
#.  .BR unshare ()
#.  flag.)
#.  Unshare virtual memory, so that the calling process no
#.  longer shares its virtual address space with any other process.
#. type: Plain text
#: build/C/man2/unshare.2:176
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:183
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:188
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:193
msgid "An invalid bit was specified in I<flags>."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:197
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:200
msgid "The calling process did not have the required privileges for this operation."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:204
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:208
msgid "The B<unshare>()  system call is Linux-specific."
msgstr ""

#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  FIXME . check future kernel versions (e.g., 2.6.17)
#.  to see if CLONE_VM gets implemented.
#.  However, as at 2.6.16, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: build/C/man2/unshare.2:244
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 2.6.16, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_SYSVSEM>, B<CLONE_THREAD>, "
"or B<CLONE_VM>.  Such functionality may be added in the future, if required."
msgstr ""

#. type: Plain text
#: build/C/man2/unshare.2:249
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), Documentation/unshare.txt"
msgstr ""

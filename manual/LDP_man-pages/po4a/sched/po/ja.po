# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-13 10:27+0900\n"
"PO-Revision-Date: 2014-04-13 10:39+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/CPU_SET.3:27
#, no-wrap
msgid "CPU_SET"
msgstr "CPU_SET"

#. type: TH
#: build/C/man3/CPU_SET.3:27
#, no-wrap
msgid "2012-03-15"
msgstr "2012-03-15"

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:45 build/C/man2/kcmp.2:28
#: build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26
#: build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34
#: build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:46
#: build/C/man2/sched_yield.2:29 build/C/man2/setns.2:8
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/CPU_SET.3:27 build/C/man2/clone.2:45 build/C/man2/kcmp.2:28
#: build/C/man2/sched_get_priority_max.2:29 build/C/man3/sched_getcpu.3:26
#: build/C/man2/sched_rr_get_interval.2:29 build/C/man2/sched_setaffinity.2:34
#: build/C/man2/sched_setparam.2:30 build/C/man2/sched_setscheduler.2:46
#: build/C/man2/sched_yield.2:29 build/C/man2/setns.2:8
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/CPU_SET.3:28 build/C/man2/clone.2:46 build/C/man2/kcmp.2:29
#: build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:27
#: build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35
#: build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:47
#: build/C/man2/sched_yield.2:30 build/C/man2/setns.2:9
#: build/C/man2/unshare.2:21
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/CPU_SET.3:35
msgid ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"
msgstr ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - CPU 集合を操作するためのマクロ"

#. type: SH
#: build/C/man3/CPU_SET.3:35 build/C/man2/clone.2:48 build/C/man2/kcmp.2:31
#: build/C/man2/sched_get_priority_max.2:32 build/C/man3/sched_getcpu.3:29
#: build/C/man2/sched_rr_get_interval.2:32 build/C/man2/sched_setaffinity.2:38
#: build/C/man2/sched_setparam.2:33 build/C/man2/sched_setscheduler.2:50
#: build/C/man2/sched_yield.2:32 build/C/man2/setns.2:11
#: build/C/man2/unshare.2:23
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/CPU_SET.3:39 build/C/man2/sched_setaffinity.2:42
#: build/C/man2/setns.2:15
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:41
#, no-wrap
msgid "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"
msgstr "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:45
#, no-wrap
msgid ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:47
#, no-wrap
msgid "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"
msgstr "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:54
#, no-wrap
msgid ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:56
#, no-wrap
msgid "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:60
#, no-wrap
msgid ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"
msgstr ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:62
#, no-wrap
msgid "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:66
#, no-wrap
msgid ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:68
#, no-wrap
msgid "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:75
#, no-wrap
msgid ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:78
#, no-wrap
msgid "B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr "B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"

#. type: SH
#: build/C/man3/CPU_SET.3:79 build/C/man2/clone.2:86 build/C/man2/kcmp.2:41
#: build/C/man2/sched_get_priority_max.2:38 build/C/man3/sched_getcpu.3:55
#: build/C/man2/sched_rr_get_interval.2:36 build/C/man2/sched_setaffinity.2:49
#: build/C/man2/sched_setparam.2:47 build/C/man2/sched_setscheduler.2:66
#: build/C/man2/sched_yield.2:36 build/C/man2/setns.2:18
#: build/C/man2/unshare.2:50
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/CPU_SET.3:86
msgid ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."
msgstr ""
"I<cpu_set_t> データ構造体は CPU 集合を表現している。 CPU 集合は "
"B<sched_setaffinity>(2) や同様のインタフェースで使用されている。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:93
msgid ""
"The I<cpu_set_t> data type is implemented as a bitset.  However, the data "
"structure treated as considered opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."
msgstr ""
"I<cpu_set_t> データ型はビット集合として実装されている。 しかし、 データ構造体"
"はその実装を意識せずに扱うものとされており、 CPU 集合のすべての操作は、 この"
"ページで説明されているマクロを通して行うべきである。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:96
msgid "The following macros are provided to operate on the CPU set I<set>:"
msgstr "以下のマクロが CPU 集合 I<set> を操作するために提供されている。"

#. type: TP
#: build/C/man3/CPU_SET.3:96
#, no-wrap
msgid "B<CPU_ZERO>()"
msgstr "B<CPU_ZERO>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:101
msgid "Clears I<set>, so that it contains no CPUs."
msgstr "I<set> をクリアする。 集合には何も CPU が含まれない状態となる。"

#. type: TP
#: build/C/man3/CPU_SET.3:101
#, no-wrap
msgid "B<CPU_SET>()"
msgstr "B<CPU_SET>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:107
msgid "Add CPU I<cpu> to I<set>."
msgstr "I<set> に I<cpu> を追加する。"

#. type: TP
#: build/C/man3/CPU_SET.3:107
#, no-wrap
msgid "B<CPU_CLR>()"
msgstr "B<CPU_CLR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:113
msgid "Remove CPU I<cpu> from I<set>."
msgstr "I<set> から I<cpu> を削除する。"

#. type: TP
#: build/C/man3/CPU_SET.3:113
#, no-wrap
msgid "B<CPU_ISSET>()"
msgstr "B<CPU_ISSET>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:119
msgid "Test to see if CPU I<cpu> is a member of I<set>."
msgstr "CPU I<cpu> が I<set> のメンバーであるかを検査する。"

#. type: TP
#: build/C/man3/CPU_SET.3:119
#, no-wrap
msgid "B<CPU_COUNT>()"
msgstr "B<CPU_COUNT>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:123
msgid "Return the number of CPUs in I<set>."
msgstr "I<set> に含まれる CPU 数を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:128
msgid ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."
msgstr ""
"I<cpu> 引き数が指定する場合、 その引き数は副作用を伴うべきではない。 上記のマ"
"クロは引き数を複数回評価する可能性があるからである。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:139
msgid ""
"The first available CPU on the system corresponds to a I<cpu> value of 0, "
"the next CPU corresponds to a I<cpu> value of 1, and so on.  The constant "
"B<CPU_SETSIZE> (currently 1024) specifies a value one greater than the "
"maximum CPU number that can be stored in I<cpu_set_t>."
msgstr ""
"そのシステムで利用可能な最初の CPU が I<cpu> 値 0 に対応し、 次の CPU が "
"I<cpu> 値 1 に対応し、 以降も同様である。 定数 B<CPU_SETSIZE> (現在のところ "
"1024) は I<cpu_set_t> に格納できる最大 CPU 数よりも大きな値である。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:141
msgid "The following macros perform logical operations on CPU sets:"
msgstr "以下のマクロは CPU 集合どうしの論理操作を行う。"

#. type: TP
#: build/C/man3/CPU_SET.3:141
#, no-wrap
msgid "B<CPU_AND>()"
msgstr "B<CPU_AND>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:150
msgid ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."
msgstr ""
"集合 I<srcset1> と I<srcset2> の積集合を I<destset> に格納する (元の集合のい"
"ずれかが I<destset> として使用される場合もある)。"

#. type: TP
#: build/C/man3/CPU_SET.3:150
#, no-wrap
msgid "B<CPU_OR>()"
msgstr "B<CPU_OR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:159
msgid ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."
msgstr ""
"集合 I<srcset1> と I<srcset2> の和集合を I<destset> に格納する (元の集合のい"
"ずれかが I<destset> として使用される場合もある)。"

#. type: TP
#: build/C/man3/CPU_SET.3:159
#, no-wrap
msgid "B<CPU_XOR>()"
msgstr "B<CPU_XOR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:173
msgid ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."
msgstr ""
"集合 I<srcset1> と I<srcset2> の XOR を I<destset> に格納する (元の集合のいず"
"れかが I<destset> として使用される場合もある)。 XOR とは、 I<srcset1> か "
"I<srcset2> のいずれかに含まれるが、両方には含まれない集合のことである。"

#. type: TP
#: build/C/man3/CPU_SET.3:173
#, no-wrap
msgid "B<CPU_EQUAL>()"
msgstr "B<CPU_EQUAL>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:176
msgid "Test whether two CPU set contain exactly the same CPUs."
msgstr "二つの CPU 集合が全く同じ CPU を含んでいるかを検査する。"

#. type: SS
#: build/C/man3/CPU_SET.3:176
#, no-wrap
msgid "Dynamically sized CPU sets"
msgstr "動的に大きさが決まる CPU 集合"

#. type: Plain text
#: build/C/man3/CPU_SET.3:182
msgid ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."
msgstr ""
"いくつかのアプリケーションでは CPU 集合の大きさを動的に決める能力 (例えば、 "
"標準の I<cpu_set_t> データ型で定義されたよりも大きい集合を割り当てるなど) が"
"必要となることがあるため、 現在 glibc はこれに対応するためにいくつかのマクロ"
"を提供している。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:184
msgid "The following macros are used to allocate and deallocate CPU sets:"
msgstr "以下のマクロを使うと CPU 集合の割り当てと解放ができる。"

#. type: TP
#: build/C/man3/CPU_SET.3:184
#, no-wrap
msgid "B<CPU_ALLOC>()"
msgstr "B<CPU_ALLOC>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:189
msgid ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to I<num_cpus-1>."
msgstr ""
"0 から I<num_cpus-1> までの範囲の CPU を保持するのに十分な大きさの CPU 集合を"
"割り当てる。"

#. type: TP
#: build/C/man3/CPU_SET.3:189
#, no-wrap
msgid "B<CPU_ALLOC_SIZE>()"
msgstr "B<CPU_ALLOC_SIZE>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:199
msgid ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described below."
msgstr ""
"0 から I<num_cpus-1> までの範囲の CPU を保持するのに必要な CPU 集合の大きさを"
"バイト数で返す。 このマクロが返す値は、 後述の B<CPU_*_S>() マクロの "
"I<setsize> 引き数として使用できる。"

#. type: TP
#: build/C/man3/CPU_SET.3:199
#, no-wrap
msgid "B<CPU_FREE>()"
msgstr "B<CPU_FREE>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:203
msgid "Free a CPU set previously allocated by B<CPU_ALLOC>()."
msgstr "以前に B<CPU_ALLOC>() で割り当てられた CPU 集合を解放する。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:210
msgid ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."
msgstr ""
"名前が \"_S\" で終わるマクロは \"_S\" なしの同じ名前のマクロと同等である。 こ"
"れらのマクロは \"_S\" なしのものと同じ動作をするが、 動的に割り当てられた、 "
"大きさが I<setsize> バイトの CPU 集合に対して操作を行う点が異なる。"

#. type: SH
#: build/C/man3/CPU_SET.3:210 build/C/man2/clone.2:878 build/C/man2/kcmp.2:127
#: build/C/man2/sched_get_priority_max.2:100 build/C/man3/sched_getcpu.3:58
#: build/C/man2/sched_rr_get_interval.2:73
#: build/C/man2/sched_setaffinity.2:107 build/C/man2/sched_setparam.2:87
#: build/C/man2/sched_setscheduler.2:423 build/C/man2/sched_yield.2:41
#: build/C/man2/setns.2:70 build/C/man2/unshare.2:207
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/CPU_SET.3:219
msgid ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."
msgstr ""
"B<CPU_ISSET>() と B<CPU_ISSET_S>() は、 I<cpu> が I<set> に含まれていれば 0 "
"以外を返し、含まれない場合 0 を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:225
msgid ""
"B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."
msgstr "B<CPU_COUNT>() と B<CPU_COUNT_S>() は I<set> に含まれる CPU 数を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:230
msgid ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise it returns 0."
msgstr ""
"B<CPU_EQUAL>() と B<CPU_EQUAL_S>() は、 二つの CPU 集合が等しければ 0 以外を"
"返し、 等しくない場合 0 を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:235
msgid ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"
msgstr ""
"B<CPU_ALLOC>() は成功するとポインタを返し、 失敗すると NULL を返す (エラーは "
"B<malloc>(3) と同じである)。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:239
msgid ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."
msgstr ""
"B<CPU_ALLOC_SIZE>() は指定された大きさの CPU 集合を格納するのに必要なバイト数"
"を返す。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:241
msgid "The other functions do not return a value."
msgstr "他の関数は値を返さない。"

#. type: SH
#: build/C/man3/CPU_SET.3:241 build/C/man2/clone.2:995 build/C/man2/kcmp.2:198
#: build/C/man3/sched_getcpu.3:70 build/C/man2/sched_setaffinity.2:148
#: build/C/man2/setns.2:97 build/C/man2/unshare.2:224
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/CPU_SET.3:249
msgid ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."
msgstr ""
"マクロ B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), B<CPU_ISSET>() は glibc "
"2.3.3 で追加された。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:252
msgid "B<CPU_COUNT>()  first appeared in glibc 2.6."
msgstr "B<CPU_COUNT>() は glibc 2.6 で初めて登場した。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:270
msgid ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), B<CPU_XOR_S>"
"(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."
msgstr ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), B<CPU_XOR_S>"
"(), B<CPU_EQUAL_S>() は glibc 2.7 で初めて登場した。"

#. type: SH
#: build/C/man3/CPU_SET.3:270 build/C/man2/clone.2:1002
#: build/C/man2/kcmp.2:202 build/C/man2/sched_get_priority_max.2:116
#: build/C/man3/sched_getcpu.3:72 build/C/man2/sched_rr_get_interval.2:94
#: build/C/man2/sched_setaffinity.2:159 build/C/man2/sched_setparam.2:110
#: build/C/man2/sched_setscheduler.2:445 build/C/man2/sched_yield.2:52
#: build/C/man2/setns.2:102 build/C/man2/unshare.2:228
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/CPU_SET.3:272
msgid "These interfaces are Linux-specific."
msgstr "これらのインタフェースは Linux 固有である。"

#. type: SH
#: build/C/man3/CPU_SET.3:272 build/C/man2/clone.2:1006
#: build/C/man2/kcmp.2:205 build/C/man3/sched_getcpu.3:75
#: build/C/man2/sched_rr_get_interval.2:96
#: build/C/man2/sched_setaffinity.2:161 build/C/man2/sched_setparam.2:112
#: build/C/man2/sched_setscheduler.2:448 build/C/man2/sched_yield.2:54
#: build/C/man2/setns.2:106 build/C/man2/unshare.2:232
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/CPU_SET.3:275
msgid "To duplicate a CPU set, use B<memcpy>(3)."
msgstr "CPU 集合を複製するには、 B<memcpy>(3) を使用する。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:282
msgid ""
"Since CPU sets are bitsets allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."
msgstr ""
"CPU 集合はロングワード単位に割り当てられるビット集合なので、 動的に割り当てら"
"れた CPU 集合の実際の CPU 数は I<sizeof(unsigned long)> の次の倍数に切り上げ"
"られることになる。 アプリケーションは、 これらの余分なビットの内容は不定と考"
"えるべきである。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:294
msgid ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of bits in the bitset), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."
msgstr ""
"名前は似ているが、 定数 B<CPU_SETSIZE> は I<cpu_set_t> データ型に含まれる "
"CPU 数 (つまり、事実上ビット集合内のビットカウント) を示すのに対して、 マク"
"ロ B<CPU_*_S>() の I<setsize> 引き数はバイト単位のサイズである点に注意するこ"
"と。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:300
msgid ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."
msgstr ""
"「書式」に書かれている引き数と返り値のデータ型は、それぞれの場合でどんな型が"
"期待されるかのヒントである。 しかしながら、 これらのインタフェースはマクロと"
"して実装されているため、 このヒントを守らなかった場合に、 コンパイラが必ずし"
"も全ての型エラーを捕捉できるとは限らない。"

#. type: SH
#: build/C/man3/CPU_SET.3:300 build/C/man2/clone.2:1031
#: build/C/man2/sched_setscheduler.2:531
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7029
#. type: Plain text
#: build/C/man3/CPU_SET.3:312
msgid ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."
msgstr ""
"glibc 2.8 以前の 32 ビットプラットフォームでは、 B<CPU_ALLOC>() は必要な空間"
"の割り当てを二度行い、 B<CPU_ALLOC_SIZE>() は本来あるべき値の二倍の値を返"
"す。 このバグはプログラムの動作には影響を与えないはずだが、 無駄にメモリを消"
"費し、 動的に割り当てられた CPU 集合に対して操作を行うマクロの動作の効率が下"
"がる結果となる。 これらのバグは glibc 2.9 で修正された。"

#. type: SH
#: build/C/man3/CPU_SET.3:312 build/C/man2/clone.2:1073
#: build/C/man2/setns.2:112
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/CPU_SET.3:315
msgid ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."
msgstr ""
"以下のプログラムは、動的に割り当てた CPU 集合に対していくつかのマクロを使用す"
"る例を示している。"

#. type: Plain text
#: build/C/man3/CPU_SET.3:323
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:330
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus, cpu;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus, cpu;\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:335
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:337
#, no-wrap
msgid "    num_cpus = atoi(argv[1]);\n"
msgstr "    num_cpus = atoi(argv[1]);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:343
#, no-wrap
msgid ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:345
#, no-wrap
msgid "    size = CPU_ALLOC_SIZE(num_cpus);\n"
msgstr "    size = CPU_ALLOC_SIZE(num_cpus);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:349
#, no-wrap
msgid ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"
msgstr ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:351
#, no-wrap
msgid "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"
msgstr "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:355
#, no-wrap
msgid ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/CPU_SET.3:356 build/C/man2/clone.2:1170
#: build/C/man2/kcmp.2:222 build/C/man2/sched_get_priority_max.2:118
#: build/C/man3/sched_getcpu.3:95 build/C/man2/sched_rr_get_interval.2:132
#: build/C/man2/sched_setaffinity.2:214 build/C/man2/sched_setparam.2:118
#: build/C/man2/sched_setscheduler.2:539 build/C/man2/sched_yield.2:79
#: build/C/man2/setns.2:199 build/C/man2/unshare.2:266
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/CPU_SET.3:361
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"

#. type: SH
#: build/C/man3/CPU_SET.3:361 build/C/man2/clone.2:1184
#: build/C/man2/kcmp.2:225 build/C/man2/sched_get_priority_max.2:130
#: build/C/man3/sched_getcpu.3:97 build/C/man2/sched_rr_get_interval.2:138
#: build/C/man2/sched_setaffinity.2:233 build/C/man2/sched_setparam.2:134
#: build/C/man2/sched_setscheduler.2:567 build/C/man2/sched_yield.2:85
#: build/C/man2/setns.2:205 build/C/man2/unshare.2:275
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/CPU_SET.3:368 build/C/man2/clone.2:1191
#: build/C/man2/kcmp.2:232 build/C/man2/sched_get_priority_max.2:137
#: build/C/man3/sched_getcpu.3:104 build/C/man2/sched_rr_get_interval.2:145
#: build/C/man2/sched_setaffinity.2:240 build/C/man2/sched_setparam.2:141
#: build/C/man2/sched_setscheduler.2:574 build/C/man2/sched_yield.2:92
#: build/C/man2/setns.2:212 build/C/man2/unshare.2:282
msgid ""
"This page is part of release 3.63 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.63 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/clone.2:45
#, no-wrap
msgid "CLONE"
msgstr "CLONE"

#. type: TH
#: build/C/man2/clone.2:45
#, fuzzy, no-wrap
#| msgid "2013-02-12"
msgid "2014-02-27"
msgstr "2013-02-12"

#. type: Plain text
#: build/C/man2/clone.2:48
msgid "clone, __clone2 - create a child process"
msgstr "clone, __clone2 - 子プロセスを作成する"

#. type: Plain text
#: build/C/man2/clone.2:51
#, no-wrap
msgid "/* Prototype for the glibc wrapper function */\n"
msgstr "/* glibc ラッパー関数のプロトタイプ */\n"

#. type: Plain text
#: build/C/man2/clone.2:53 build/C/man3/sched_getcpu.3:32
#: build/C/man2/sched_setparam.2:36 build/C/man2/sched_setscheduler.2:53
#: build/C/man2/unshare.2:26
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr "B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/clone.2:58
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"
msgstr ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"

#. type: Plain text
#: build/C/man2/clone.2:60
#, no-wrap
msgid "/* Prototype for the raw system call */\n"
msgstr "/* 素のシステムコールのプロトタイプ */\n"

#. type: Plain text
#: build/C/man2/clone.2:64
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<          void *>I<ptid>B<, void *>I<ctid>B<,>\n"
"B<          struct pt_regs *>I<regs>B<);>\n"
msgstr ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<          void *>I<ptid>B<, void *>I<ctid>B<,>\n"
"B<          struct pt_regs *>I<regs>B<);>\n"

#. type: Plain text
#: build/C/man2/clone.2:69
msgid ""
"Feature Test Macro Requirements for glibc wrapper function (see "
"B<feature_test_macros>(7)):"
msgstr ""
"glibc ラッパー関数の機能検査マクロの要件 (B<feature_test_macros>(7) 参照):"

#. type: Plain text
#: build/C/man2/clone.2:72
msgid "B<clone>():"
msgstr "B<clone>():"

#. type: TP
#: build/C/man2/clone.2:75 build/C/man3/sched_getcpu.3:45
#: build/C/man2/unshare.2:39
#, no-wrap
msgid "Since glibc 2.14:"
msgstr "glibc 2.14 以降:"

#. type: Plain text
#: build/C/man2/clone.2:78 build/C/man3/sched_getcpu.3:48
#: build/C/man2/unshare.2:42
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#.  See http://sources.redhat.com/bugzilla/show_bug.cgi?id=4749
#. type: TP
#: build/C/man2/clone.2:78 build/C/man3/sched_getcpu.3:48
#: build/C/man2/unshare.2:42
#, no-wrap
msgid "Before glibc 2.14:"
msgstr "glibc 2.14 より前:"

#. type: Plain text
#: build/C/man2/clone.2:83 build/C/man3/sched_getcpu.3:52
#: build/C/man2/unshare.2:47
#, no-wrap
msgid ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE also suffices */\n"
msgstr ""
"_BSD_SOURCE || _SVID_SOURCE\n"
"    /* _GNU_SOURCE も定義される */\n"

#. type: Plain text
#: build/C/man2/clone.2:90
msgid "B<clone>()  creates a new process, in a manner similar to B<fork>(2)."
msgstr "B<clone>() は、 B<fork>(2) と似た方法で新しいプロセスを作成する。"

#. type: Plain text
#: build/C/man2/clone.2:97
msgid ""
"This page describes both the glibc B<clone>()  wrapper function and the "
"underlying system call on which it is based.  The main text describes the "
"wrapper function; the differences for the raw system call are described "
"toward the end of this page."
msgstr ""
"このページでは、 glibc の B<clone>() ラッパー関数とその裏で呼ばれるシステム"
"コールの両方について説明している。 メインの説明はラッパー関数に関するものであ"
"る。 素のシステムコールにおける差分はこのページの最後の方で説明する。"

#. type: Plain text
#: build/C/man2/clone.2:109
msgid ""
"Unlike B<fork>(2), B<clone>()  allows the child process to share parts of "
"its execution context with the calling process, such as the memory space, "
"the table of file descriptors, and the table of signal handlers.  (Note that "
"on this manual page, \"calling process\" normally corresponds to \"parent "
"process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""
"B<fork>(2) とは異なり、B<clone>() では、子プロセス (child process)  と呼び出"
"し元のプロセスとが、メモリ空間、ファイルディスクリプタのテーブル、シグナル・"
"ハンドラのテーブルなどの 実行コンテキストの一部を共有できる。 (このマニュアル"
"における「呼び出し元のプロセス」は、通常は 「親プロセス」と一致する。但し、後"
"述の B<CLONE_PARENT> の項も参照のこと)"

#. type: Plain text
#: build/C/man2/clone.2:114
msgid ""
"The main use of B<clone>()  is to implement threads: multiple threads of "
"control in a program that run concurrently in a shared memory space."
msgstr ""
"B<clone>()  の主要な使用法はスレッド (threads) を実装することである: 一つのプ"
"ログラムの中の複数のスレッドは共有されたメモリ空間で 同時に実行される。"

#. type: Plain text
#: build/C/man2/clone.2:134
msgid ""
"When the child process is created with B<clone>(), it executes the function "
"I<fn>(I<arg>).  (This differs from B<fork>(2), where execution continues in "
"the child from the point of the B<fork>(2)  call.)  The I<fn> argument is a "
"pointer to a function that is called by the child process at the beginning "
"of its execution.  The I<arg> argument is passed to the I<fn> function."
msgstr ""
"B<clone>()  で子プロセスが作成された時に、作成された子プロセスは関数 I<fn>"
"(I<arg>)  を実行する。 (この点が B<fork>(2)  とは異なる。 B<fork>(2)  の場"
"合、子プロセスは B<fork>(2)  が呼び出された場所から実行を続ける。)  I<fn> 引"
"き数は、子プロセスが実行を始める時に子プロセスが呼び出す 関数へのポインタであ"
"る。 I<arg> 引き数はそのまま I<fn> 関数へと渡される。"

#. type: Plain text
#: build/C/man2/clone.2:144
msgid ""
"When the I<fn>(I<arg>)  function application returns, the child process "
"terminates.  The integer returned by I<fn> is the exit code for the child "
"process.  The child process may also terminate explicitly by calling B<exit>"
"(2)  or after receiving a fatal signal."
msgstr ""
"I<fn>(I<arg>)  関数が終了すると、子プロセスは終了する。 I<fn> によって返され"
"た整数が子プロセスの終了コードとなる。 子プロセスは、 B<exit>(2)  を呼んで明"
"示的に終了することもあるし、致命的なシグナルを受信した 場合に終了することもあ"
"る。"

#. type: Plain text
#: build/C/man2/clone.2:160
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""
"I<child_stack> 引き数は、子プロセスによって使用されるスタックの位置を指定す"
"る。 子プロセスと呼び出し元のプロセスはメモリを共有することがあるため、 子プ"
"ロセスは呼び出し元のプロセスと同じスタックで実行することができない。 このた"
"め、呼び出し元のプロセスは子プロセスのスタックのためのメモリ空間を 用意して、"
"この空間へのポインタを B<clone>()  へ渡さなければならない。 (HP PA プロセッサ"
"以外の) Linux が動作する全てのプロセッサでは、 スタックは下方 (アドレスが小さ"
"い方向) へと伸びる。このため、普通は I<child_stack> は子プロセスのスタックの"
"ために用意したメモリ空間の一番大きい アドレスを指すようにする。"

#. type: Plain text
#: build/C/man2/clone.2:176
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with B<wait>"
"(2).  If no signal is specified, then the parent process is not signaled "
"when the child terminates."
msgstr ""
"I<flags> の下位 1 バイトは子プロセスが死んだ場合に親プロセスへと送られる I<終"
"了シグナル (termination signal)> の番号を指定する。このシグナルとして "
"B<SIGCHLD> 以外が指定された場合、親プロセスは、 B<wait>(2)  で子プロセスを待"
"つ際に、オプションとして B<__WALL> または B<__WCLONE> を指定しなければならな"
"い。 どのシグナルも指定されなかった場合、子プロセスが終了した時に親プロセス "
"にシグナルは送られない。"

#. type: Plain text
#: build/C/man2/clone.2:181
msgid ""
"I<flags> may also be bitwise-or'ed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""
"I<flags> には、以下の定数のうち 0個以上をビット毎の論理和 (bitwise-or)  を"
"とったものを指定できる。これらの定数は呼び出し元のプロセスと 子プロセスの間で"
"何を共有するかを指定する:"

#. type: TP
#: build/C/man2/clone.2:181
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_CLEARTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:191
msgid ""
"Erase child thread ID at location I<ctid> in child memory when the child "
"exits, and do a wakeup on the futex at that address.  The address involved "
"may be changed by the B<set_tid_address>(2)  system call.  This is used by "
"threading libraries."
msgstr ""
"子プロセスが終了したときに子プロセスのメモリ内の I<ctid> が指す場所にある子プ"
"ロセスのスレッド ID を消去し、 そのアドレスで futex を wake (起床) させる。 "
"このアドレスは B<set_tid_address>(2)  システムコールで変更することができる。 "
"この機能はスレッドライブラリで使用される。"

#. type: TP
#: build/C/man2/clone.2:191
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_SETTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:196
msgid "Store child thread ID at location I<ctid> in child memory."
msgstr ""
"子プロセスのメモリ内の I<ctid> が指す場所に子プロセスのスレッド ID を格納す"
"る。"

#. type: TP
#: build/C/man2/clone.2:196
#, no-wrap
msgid "B<CLONE_FILES> (since Linux 2.0)"
msgstr "B<CLONE_FILES> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:209
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected."
msgstr ""
"B<CLONE_FILES> が設定された場合、呼び出し元のプロセスと子プロセスはファイル"
"ディスクリプタの テーブルを共有する。 呼び出し元プロセスとその子プロセスの一"
"方が作成した ファイルディスクリプタは、もう一方においても有効である。 同じよ"
"うに、一方のプロセスがファイルディスクリプタを閉じたり、 (B<fcntl>(2)  "
"B<F_SETFD> 操作を使って) ディスクリプタに関連するフラグを変更したりすると、 "
"もう一方のプロセスにも影響する。"

#. type: Plain text
#: build/C/man2/clone.2:223
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  (The "
"duplicated file descriptors in the child refer to the same open file "
"descriptions (see B<open>(2))  as the corresponding file descriptors in the "
"calling process.)  Subsequent operations that open or close file "
"descriptors, or change file descriptor flags, performed by either the "
"calling process or the child process do not affect the other process."
msgstr ""
"B<CLONE_FILES> が設定されていない場合、子プロセスは、 B<clone>()  が実行され"
"た時点で、呼び出し元のプロセスがオープンしている全ての ファイルディスクリプタ"
"のコピーを継承する (子プロセスの複製されたファイルディスクリプタは、 対応する"
"呼び出し元のプロセスのファイルディスクリプタと 同じファイル記述 (B<open>(2)  "
"参照) を参照する)。 これ以降に、呼び出し元のプロセスと子プロセスの一方が ファ"
"イルディスクリプタの操作 (ファイルディスクリプタの オープン・クローズや、ファ"
"イルディスクリプタ・フラグの変更)  を行っても、もう一方のプロセスには影響を与"
"えない。"

#. type: TP
#: build/C/man2/clone.2:223
#, no-wrap
msgid "B<CLONE_FS> (since Linux 2.0)"
msgstr "B<CLONE_FS> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:238
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same "
"filesystem information.  This includes the root of the filesystem, the "
"current working directory, and the umask.  Any call to B<chroot>(2), B<chdir>"
"(2), or B<umask>(2)  performed by the calling process or the child process "
"also affects the other process."
msgstr ""
"B<CLONE_FS> が設定された場合、呼び出し元のプロセスと子プロセスが同じファイ"
"ル・システム 情報を共有する。ファイル・システム情報は、ファイル・システムの"
"ルート (root)、 カレント・ワーキング・ディレクトリ (current working "
"directory)  や umask などである。 呼び出し元のプロセスや子プロセスのどちらか"
"一方によって B<chroot>(2), B<chdir>(2), B<umask>(2)  が呼び出されると、もう一"
"方のプロセスにも影響が及ぶ。"

#. type: Plain text
#: build/C/man2/clone.2:250
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the "
"filesystem information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), B<umask>(2)  performed later by "
"one of the processes do not affect the other process."
msgstr ""
"B<CLONE_FS> が設定されていない場合、子プロセスは、 B<clone>()  が実行された時"
"点での、呼び出し元のプロセスのファイル・システム情報のコピーを 使用する。 こ"
"れ以降は、呼び出し元のプロセスと子プロセスの一方が B<chroot>(2), B<chdir>"
"(2), B<umask>(2)  を呼び出しても、もう一方のプロセスには影響を与えない。"

#. type: TP
#: build/C/man2/clone.2:250
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr "B<CLONE_IO> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/clone.2:259
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""
"B<CLONE_IO> が設定された場合、新しいプロセスは呼び出し元のプロセスと I/O コン"
"テキストを共有する。 このフラグが設定されていない場合には、 (B<fork>(2)  の場"
"合と同様) 新しいプロセスは自分専用の I/O コンテキストを持つ。"

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: build/C/man2/clone.2:276
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e, what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""
"I/O コンテキストは、ディスクスケジュールの I/O スコープである (言い換えると、"
"I/O コンテキストは I/O スケジューラがプロセス I/O の スケジューリングをモデル"
"化するのに使用される)。 複数のプロセスが同じ I/O コンテキストを共有する場"
"合、 これらのプロセスは I/O スケジューラからは一つとして扱われる。 結果とし"
"て、これらのプロセスはディスクアクセスの時間を共有するようになる。 いくつか"
"の I/O スケジューラでは、 二つのプロセスが I/O コンテキストを共有している場"
"合、 これらのプロセスはディスクアクセスを交互に行うことができる。 同じプロセ"
"スの複数のスレッドが I/O を実行している場合 (例えば B<aio_read>(3))、 "
"B<CLONE_IO> を利用することで I/O 性能を良くすることができる。"

#. type: Plain text
#: build/C/man2/clone.2:280
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""
"カーネルの設定が B<CONFIG_BLOCK> オプション付きでない場合、 このフラグは何の"
"意味も持たない。"

#. type: TP
#: build/C/man2/clone.2:280 build/C/man2/unshare.2:96
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWIPC> (Linux 2.6.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:290
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""
"B<CLONE_NEWIPC> が設定された場合、新しい IPC 名前空間 (namespace) でプロセス"
"を作成する。 このフラグが設定されていない場合、 (B<fork>(2)  の場合と同様) 呼"
"び出し元のプロセスと同じ IPC 名前空間でプロセスが 作成される。 このフラグは、"
"コンテナの実装での使用を意図して用意されたものである。"

#.  commit 7eafd7c74c3f2e67c27621b987b28397110d643f
#.  https://lwn.net/Articles/312232/
#. type: Plain text
#: build/C/man2/clone.2:302
msgid ""
"An IPC namespace provides an isolated view of System V IPC objects (see "
"B<svipc>(7))  and (since Linux 2.6.30)  POSIX message queues (see "
"B<mq_overview>(7)).  The common characteristic of these IPC mechanisms is "
"that IPC objects are identified by mechanisms other than filesystem "
"pathnames."
msgstr ""
"IPC 名前空間は、独立の System V IPC オブジェクト空間 (B<svipc>(7) 参照) を提"
"供する 。 (Linux 2.6.30 以降では) 独立した POSIX メッセージキュー空間 "
"(B<mq_overview>(7) 参照) も提供される。 これらの IPC 機構に共通の特徴とし"
"て、 IPC オブジェクトはファイルシステムのパス名とは違った仕組みで識別されると"
"いう点がある。"

#. type: Plain text
#: build/C/man2/clone.2:306
msgid ""
"Objects created in an IPC namespace are visible to all other processes that "
"are members of that namespace, but are not visible to processes in other IPC "
"namespaces."
msgstr ""
"ある IPC 名前空間に作成されたオブジェクトは、 その名前空間のメンバーである他"
"のすべてのプロセスからも見えるが、 違う IPC 名前空間のプロセスからは見えな"
"い。"

#. type: Plain text
#: build/C/man2/clone.2:310
msgid ""
"When an IPC namespace is destroyed (i.e., when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""
"IPC 名前空間が破棄される時 (すなわち、その名前空間のメンバーの最後のプロセス"
"が終了する時)、 その名前空間の全ての IPC オブジェクトは自動的に破棄される。"

#. type: Plain text
#: build/C/man2/clone.2:319
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_SYSVIPC> "
"and B<CONFIG_IPC_NS> options and that the process be privileged "
"(B<CAP_SYS_ADMIN>).  This flag can't be specified in conjunction with "
"B<CLONE_SYSVSEM>."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_SYSVIPC> と "
"B<CONFIG_IPC_NS> を有効になっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  "
"を持っていることが必要である。 このフラグは B<CLONE_SYSVSEM> と組み合わせて使"
"うことはできない。"

#. type: TP
#: build/C/man2/clone.2:319 build/C/man2/unshare.2:113
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWNET> (Linux 2.6.24 以降)"

#.  FIXME Check when the implementation was completed
#. type: Plain text
#: build/C/man2/clone.2:324
msgid ""
"(The implementation of this flag was completed only by about kernel version "
"2.6.29.)"
msgstr "(このフラグの実装は、Linux 2.6.29 あたりまでには完成した。)"

#. type: Plain text
#: build/C/man2/clone.2:333
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2)), the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""
"B<CLONE_NEWNET> が設定された場合、新しいネットワーク名前空間 (network "
"namaspace)  でプロセスを作成する。 このフラグが設定されていない場合、 "
"(B<fork>(2)  の場合と同様) 呼び出し元のプロセスと同じネットワーク名前空間でプ"
"ロセスが 作成される。 このフラグは、コンテナの実装での使用を意図して用意され"
"たものである。"

#.  FIXME Add pointer to veth(4) page when it is eventually completed
#. type: Plain text
#: build/C/man2/clone.2:348
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network device (\"veth\") pair provides a pipe-"
"like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""
"ネットワーク名前空間は、分離されたネットワークスタックを提供するものである "
"(ネットワークスタックとは、 ネットワークデバイスインタフェース、IPv4 や IPv6 "
"プロトコルスタック、 I</proc/net>、 I</sys/class/net> ディレクトリツリー、ソ"
"ケットなどである)。 物理ネットワークデバイスが所属できるネットワーク名前空間"
"は一つだけである。 仮想ネットワークデバイス (\"veth\") のペアにより パイプ風"
"の抽象化 (abstraction) が実現されており、 これを使うことで、ネットワーク名前"
"空間間のトンネルを作成したり、 別の名前空間の物理ネットワークデバイスへのブ"
"リッジを作成したり することができる。"

#. type: Plain text
#: build/C/man2/clone.2:353
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process)."
msgstr ""
"ネットワーク名前空間が解放される時 (すなわち、その名前空間の最後のプロセスが"
"終了する時)、 物理ネットワークデバイスは初期ネットワーク名前空間 (initial "
"network namespace) に戻される (親プロセスのネットワーク名前空間に戻される訳で"
"はない)。"

#. type: Plain text
#: build/C/man2/clone.2:358
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_NET_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_NET_NS> を有効に"
"なっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  を持っていることが必要で"
"ある。"

#. type: TP
#: build/C/man2/clone.2:358
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr "B<CLONE_NEWNS> (Linux 2.4.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:361
msgid "Start the child in a new mount namespace."
msgstr "子プロセスを新しいマウント名前空間 (mount namespace) で開始する。"

#. type: Plain text
#: build/C/man2/clone.2:382
msgid ""
"Every process lives in a mount namespace.  The I<namespace> of a process is "
"the data (the set of mounts) describing the file hierarchy as seen by that "
"process.  After a B<fork>(2)  or B<clone>()  where the B<CLONE_NEWNS> flag "
"is not set, the child lives in the same mount namespace as the parent.  The "
"system calls B<mount>(2)  and B<umount>(2)  change the mount namespace of "
"the calling process, and hence affect all processes that live in the same "
"namespace, but do not affect processes in a different mount namespace."
msgstr ""
"各プロセスはある一つのマウント名前空間中に存在する。プロセスの I<名前空間 "
"(namespace)> は、そのプロセスから見えるファイル階層を表すデータ (mount の集"
"合) である。 B<CLONE_NEWNS> フラグがセットされずに B<fork>(2)  か B<clone>"
"()  が呼ばれると、子プロセスは親プロセスと同じマウント名前空間に作成される。 "
"システムコール B<mount>(2)、 B<umount>(2)  が呼ばれると呼び出し元のプロセスの"
"マウント名前空間が変更され、この結果 呼び出し元のプロセスと同じ名前空間にいる"
"プロセスはすべて影響を受けるが、 異なるマウント名前空間にいるプロセスは影響を"
"受けない。"

#. type: Plain text
#: build/C/man2/clone.2:389
msgid ""
"After a B<clone>()  where the B<CLONE_NEWNS> flag is set, the cloned child "
"is started in a new mount namespace, initialized with a copy of the "
"namespace of the parent."
msgstr ""
"B<CLONE_NEWNS> フラグがセットされて B<clone>()  が呼ばれると、clone で作成さ"
"れた子プロセスは新しいマウント名前空間で 開始される。新しい名前空間は親プロセ"
"スの名前空間のコピーで初期化される。"

#. type: Plain text
#: build/C/man2/clone.2:401
msgid ""
"Only a privileged process (one having the B<CAP_SYS_ADMIN> capability)  may "
"specify the B<CLONE_NEWNS> flag.  It is not permitted to specify both "
"B<CLONE_NEWNS> and B<CLONE_FS> in the same B<clone>()  call."
msgstr ""
"特権プロセス (B<CAP_SYS_ADMIN> ケーパビリティを持つプロセス) のみが "
"B<CLONE_NEWNS> フラグを指定することができる。 一つの B<clone>()  呼び出し"
"で、 B<CLONE_NEWNS> と B<CLONE_FS> の両方を指定することはできない。"

#. type: TP
#: build/C/man2/clone.2:401
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWPID> (Linux 2.6.24 以降)"

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: build/C/man2/clone.2:418
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""
"B<CLONE_NEWPID> が設定された場合、新しい PID 名前空間でプロセスを作成する。 "
"このフラグが設定されていない場合、 (B<fork>(2)  の場合と同様) 呼び出し元のプ"
"ロセスと同じ PID 名前空間で プロセスが作成される。 このフラグは、コンテナの実"
"装での使用を意図して用意されたものである。"

#. type: Plain text
#: build/C/man2/clone.2:427
msgid ""
"A PID namespace provides an isolated environment for PIDs: PIDs in a new "
"namespace start at 1, somewhat like a standalone system, and calls to B<fork>"
"(2), B<vfork>(2), or B<clone>()  will produce processes with PIDs that are "
"unique within the namespace."
msgstr ""
"PID 名前空間は、PID に関して分離された環境を提供するものである。 新しい名前空"
"間における PID は 1 から始まり (これはスタンドアロンのシステムと似たような感"
"じ)、 B<fork>(2), B<vfork>(2), B<clone>()  を呼び出すと、その名前空間で一意"
"な PID を持ったプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:439
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using the B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process "
"for the namespace.  Children that are orphaned within the namespace will be "
"reparented to this process rather than B<init>(8).  Unlike the traditional "
"B<init> process, the \"init\" process of a PID namespace can terminate, and "
"if it does, all of the processes in the namespace are terminated."
msgstr ""
"新しい名前空間で作成される最初のプロセス (つまり、 B<CLONE_NEWPID> フラグを"
"使って作成されたプロセス) の PID は 1 であり、 このプロセスはその名前空間にお"
"ける \"init\" プロセスとなる。 この名前空間において孤児 (orphaned) となった子"
"プロセスについては、 B<init>(8)  ではなくこのプロセスが親プロセスとなる。 昔"
"ながらの B<init> プロセスとは違い、PID 名前空間の \"init\" プロセスは終了 "
"(terminated) する ことができ、その場合には、この名前空間の全てのプロセスが終"
"了される。"

#. type: Plain text
#: build/C/man2/clone.2:458
msgid ""
"PID namespaces form a hierarchy.  When a new PID namespace is created, the "
"processes in that namespace are visible in the PID namespace of the process "
"that created the new namespace; analogously, if the parent PID namespace is "
"itself the child of another PID namespace, then processes in the child and "
"parent PID namespaces will both be visible in the grandparent PID "
"namespace.  Conversely, the processes in the \"child\" PID namespace do not "
"see the processes in the parent namespace.  The existence of a namespace "
"hierarchy means that each process may now have multiple PIDs: one for each "
"namespace in which it is visible; each of these PIDs is unique within the "
"corresponding namespace.  (A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process lives.)"
msgstr ""
"PID 名前空間間には階層構造が形成される。 新しい PID 名前空間が作成されると、"
"その名前空間のプロセスは、 新しい名前空間を作成したプロセスの PID 名前空間で"
"見える。 同様に、親の PID 名前空間自体が別の PID 名前空間の子供の場合には、 "
"子供の PID 名前空間と親の PID 名前空間のプロセスはどれも 親の親の PID 名前空"
"間でも見えることになる。 反対に、「子供」の PID 名前空間のプロセスには、 親の"
"名前空間のプロセスは見えない。 名前空間に階層構造が存在するということは、個々"
"のプロセスは 複数の PID を持つということを意味している。 そのプロセスが見える"
"名前空間一つにつき PID が一つあり、 それぞれの PID は対応する名前空間において"
"一意である。 (B<getpid>(2)  を呼び出すと、常にそのプロセスが存在している名前"
"空間における PID が返される。)"

#.  mount -t proc proc /proc
#. type: Plain text
#: build/C/man2/clone.2:474
msgid ""
"After creating the new namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  (If B<CLONE_NEWNS> is also included in "
"I<flags>, then it isn't necessary to change the root directory: a new procfs "
"instance can be mounted directly over I</proc>.)"
msgstr ""
"新しい名前空間の作成後には、 子プロセスにおいて、 B<ps>(1)  といったツールが"
"正しく動作するように、 自身の root ディレクトリを変更し、 I</proc> に新しい "
"procfs インスタンスをマウントするのがよいだろう。 (B<flags> に "
"B<CLONE_NEWNS> も指定されていた場合には、root ディレクトリを変更する必要はな"
"く、 いきなり新しい procfs インスタンスを I</proc> にマウントすることができ"
"る。)"

#. type: Plain text
#: build/C/man2/clone.2:481
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_PID_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>).  This flag "
"can't be specified in conjunction with B<CLONE_THREAD>."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_PID_NS> を有効に"
"なっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  を持っていることが必要で"
"ある。 このフラグは B<CLONE_THREAD> と組み合わせて使うことはできない。"

#. type: TP
#: build/C/man2/clone.2:481 build/C/man2/unshare.2:149
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWUTS> (Linux 2.6.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:493
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2)), the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of containers."
msgstr ""
"B<CLONE_NEWUTS> が設定された場合、新しい UTS 名前空間でプロセスを作成する。 "
"新しい UTS 名前空間の識別子の初期値は、呼び出し元のプロセスの UTS 名前空間の"
"識別子を複製したものとなる。 このフラグが設定されていない場合、 (B<fork>(2)  "
"の場合と同様) 呼び出し元のプロセスと同じ UTS 名前空間で プロセスが作成され"
"る。 このフラグは、コンテナの実装での使用を意図して用意されたものである。"

#. type: Plain text
#: build/C/man2/clone.2:504
#, fuzzy
#| msgid ""
#| "A UTS namespace is the set of identifiers returned by B<uname>(2); among "
#| "these, the domain name and the host name can be modified by "
#| "B<setdomainname>(2)  and B<sethostname>(2), respectively.  Changes made "
#| "to the identifiers in a UTS namespace are visible to all other processes "
#| "in the same namespace, but are not visible to processes in other UTS "
#| "namespaces."
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the hostname can be modified by B<setdomainname>"
"(2)  and B<sethostname>(2), respectively.  Changes made to the identifiers "
"in a UTS namespace are visible to all other processes in the same namespace, "
"but are not visible to processes in other UTS namespaces."
msgstr ""
"UTS 名前空間は、 B<uname>(2)  が返す識別子の集合である。 識別子としてはドメイ"
"ン名とホスト名があり、 それぞれ B<setdomainname>(2), B<sethostname>(2)  で修"
"正することができる。 ある UTS 名前空間における識別子の変更は同じ名前空間の他"
"のすべての プロセスに見えるが、別の UTS 名前空間のプロセスには見えない。"

#. type: Plain text
#: build/C/man2/clone.2:509
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_UTS_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_UTS_NS> を有効に"
"なっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  を持っていることが必要で"
"ある。"

#. type: TP
#: build/C/man2/clone.2:509
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr "B<CLONE_PARENT> (Linux 2.3.12 以降)"

#. type: Plain text
#: build/C/man2/clone.2:516
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""
"B<CLONE_PARENT> が設定された場合、新しい子供の (B<getppid>(2)  で返される) 親"
"プロセスは呼び出し元のプロセスの親プロセスと同じになる。"

#. type: Plain text
#: build/C/man2/clone.2:522
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""
"B<CLONE_PARENT> が設定されていない場合、 (B<fork>(2)  と同様に) 呼び出し元の"
"プロセスがその子供の親になる。"

#. type: Plain text
#: build/C/man2/clone.2:530
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""
"子供が終了した時にシグナルが送られるのは B<getppid>(2)  が返す親プロセスであ"
"る点に注意すること。このため B<CLONE_PARENT> が設定された場合、呼び出し元のプ"
"ロセスではなく呼び出し元のプロセスの 親プロセスにシグナルが送られる。"

#. type: TP
#: build/C/man2/clone.2:530
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_PARENT_SETTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:538
msgid ""
"Store child thread ID at location I<ptid> in parent and child memory.  (In "
"Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)"
msgstr ""
"親プロセスと子プロセスのメモリ内の I<ptid> が指す領域に子プロセスのスレッド "
"ID を格納する。 (Linux 2.5.32-2.5.48 では、 同じことをする B<CLONE_SETTID> と"
"いうフラグが存在した。)"

#. type: TP
#: build/C/man2/clone.2:538
#, no-wrap
msgid "B<CLONE_PID> (obsolete)"
msgstr "B<CLONE_PID> (廃止予定)"

#. type: Plain text
#: build/C/man2/clone.2:549
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  Since 2.3.21 this flag can be specified only by "
"the system boot process (PID 0).  It disappeared in Linux 2.5.16."
msgstr ""
"B<CLONE_PID> が設定された場合、子プロセスは呼び出し元のプロセスと同じプロセ"
"ス ID で作成される。これはシステムをハッキングするのには便利だが、 それ以外に"
"はあまり使われない。 Linux 2.3.21 以降では、 システムのブートプロセス (PID "
"0) だけがこのフラグを指定できる。 Linux 2.5.16 で削除された。"

#. type: TP
#: build/C/man2/clone.2:549
#, no-wrap
msgid "B<CLONE_PTRACE> (since Linux 2.2)"
msgstr "B<CLONE_PTRACE> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/clone.2:556
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""
"B<CLONE_PTRACE> が指定され、かつ呼び出し元のプロセスが追跡 (trace) されていた"
"場合、子プロセスも 同様に追跡される。 (B<ptrace>(2)  を参照のこと)"

#. type: TP
#: build/C/man2/clone.2:556
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr "B<CLONE_SETTLS> (Linux 2.5.32 以降)"

#. type: Plain text
#: build/C/man2/clone.2:563
msgid ""
"The I<newtls> argument is the new TLS (Thread Local Storage) descriptor.  "
"(See B<set_thread_area>(2).)"
msgstr ""
"I<newtls> 引き数は、新しい TLS (Thread Local Storage) ディスクリプタである。 "
"(B<set_thread_area>(2)  を参照のこと)"

#. type: TP
#: build/C/man2/clone.2:563
#, no-wrap
msgid "B<CLONE_SIGHAND> (since Linux 2.0)"
msgstr "B<CLONE_SIGHAND> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:579
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock some signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""
"B<CLONE_SIGHAND> が設定された場合、呼び出し元のプロセスと子プロセスは同じシグ"
"ナル・ハン ドラのテーブルを共有する。呼び出し元のプロセスまたは子プロセスのど"
"ちらかが B<sigaction>(2)  を呼び出してシグナルに対応する動作を変更した場合、 "
"もう一方のプロセスのシグナル動作も変更される。 但し、呼び出し元のプロセスと子"
"プロセスは、 プロセス毎に、シグナル・マスク (signal mask) と処理待ちシグナル"
"の集合 を持っている。このため、あるプロセスは、 B<sigprocmask>(2)  を使用し"
"て、もう一方のプロセスに影響を与えずに シグナルを禁止 (block) したり許可 "
"(unblock) したりできる。"

#. type: Plain text
#: build/C/man2/clone.2:590
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""
"B<CLONE_SIGHAND> が設定されていない場合、子プロセスは B<clone>()  が実行され"
"た時点での、呼び出し元のプロセスのシグナル・ハンドラの コピーを継承する。これ"
"以降は、一方のプロセスが B<sigaction>(2)  を呼び出しても、もう一方のプロセス"
"には影響を与えない。"

#. type: Plain text
#: build/C/man2/clone.2:598
msgid ""
"Since Linux 2.6.0-test6, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""
"Linux 2.6.0-test6 以降では、 B<CLONE_SIGHAND> を指定する場合、 B<CLONE_VM> "
"も I<flags> に含めなければならない。"

#. type: TP
#: build/C/man2/clone.2:598
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0-test2)"
msgstr "B<CLONE_STOPPED> (Linux 2.6.0-test2 以降)"

#. type: Plain text
#: build/C/man2/clone.2:607
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""
"B<CLONE_STOPPED> が設定されると、子プロセスは最初 (B<SIGSTOP> シグナルを送ら"
"れたかのように) 停止した状態となる。 子プロセスを再開させるには B<SIGCONT> シ"
"グナルを送信しなければならない。"

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: build/C/man2/clone.2:615
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38."
msgstr ""
"このフラグは Linux 2.6.25 以降ではI<非推奨>であり、\n"
"Linux 2.6.38 で完全にI<削除>された。"

#. type: TP
#: build/C/man2/clone.2:615
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr "B<CLONE_SYSVSEM> (Linux 2.5.10 以降)"

#. type: Plain text
#: build/C/man2/clone.2:624
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore undo values (see B<semop>(2)).  If this "
"flag is not set, then the child has a separate undo list, which is initially "
"empty."
msgstr ""
"B<CLONE_SYSVSEM> がセットされると、子プロセスと呼び出し元プロセスは一つの "
"System V セマフォのアンドゥ値リスト (B<semop>(2)  参照) を共有する。このフラ"
"グがセットされていなければ、 子プロセスは独自のアンドゥリストを持つ (リストの"
"初期値は空である)。"

#. type: TP
#: build/C/man2/clone.2:624
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0-test8)"
msgstr "B<CLONE_THREAD> (Linux 2.4.0-test8以降)"

#. type: Plain text
#: build/C/man2/clone.2:633
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""
"B<CLONE_THREAD> が設定された場合、子プロセスは呼び出し元のプロセスと同じス"
"レッド・グループに 置かれる。 B<CLONE_THREAD> についての以降の議論を読みやす"
"くするため、 「スレッド」という用語はスレッド・グループの中のプロセスを 参照"
"するのに使うこととする。"

#. type: Plain text
#: build/C/man2/clone.2:641
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""
"スレッド・グループは、 スレッド集合で一つの PID を共有するという POSIX スレッ"
"ドの概念をサポートするために Linux 2.4 に加えられた機能であった。 内部的に"
"は、この共有 PID はいわゆるそのスレッドグループの スレッド・グループ識別子 "
"(TGID) である。 Linux 2.4 以降では、 B<getpid>(2)  の呼び出しではそのプロセス"
"のスレッド・グループ ID を返す。"

#. type: Plain text
#: build/C/man2/clone.2:650
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""
"あるグループに属するスレッドは (システム全体で) 一意なスレッド ID (TID)  で区"
"別できる。新しいスレッドの TID は B<clone>()  の呼び出し元へ関数の結果として"
"返され、 スレッドは自分自身の TID を B<gettid>(2)  で取得できる。"

#. type: Plain text
#: build/C/man2/clone.2:660
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""
"B<CLONE_THREAD> を指定せずに B<clone>()  の呼び出しが行われると、 生成された"
"スレッドはそのスレッドの TID と同じ値の TGID を持つ 新しいスレッド・グループ"
"に置かれる。このスレッドは 新しいスレッド・グループの「リーダー」である。"

#. type: Plain text
#: build/C/man2/clone.2:682
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""
"B<CLONE_THREAD> を指定して作成された新しいスレッドは、 (B<CLONE_PARENT> の場"
"合と同様に)  B<clone>()  を呼び出し元と同じ親プロセスを持つ。 そのため、 "
"B<getppid>(2)  を呼ぶと、一つのスレッド・グループに属すスレッドは全て同じ値を"
"返す。 B<CLONE_THREAD> で作られたスレッドが終了した際に、 そのスレッドを "
"B<clone>()  を使って生成したスレッドには B<SIGCHLD> (もしくは他の終了シグナ"
"ル) は送信されない。 また、 B<wait>(2)  を使って終了したスレッドの状態を取得"
"することもできない (そのようなスレッドは I<detached> (分離された) といわれ"
"る)。"

#. type: Plain text
#: build/C/man2/clone.2:687
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""
"スレッド・グループに属す全てのスレッドが終了した後、 そのスレッド・グループの"
"親プロセスに B<SIGCHLD> (もしくは他の終了シグナル) が送られる。"

#. type: Plain text
#: build/C/man2/clone.2:692
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""
"スレッド・グループに属すいずれかのスレッドが B<execve>(2)  を実行すると、ス"
"レッド・グループ・リーダー以外の全てのスレッドは 終了され、新しいプロセスがそ"
"のスレッド・グループ・リーダーの下で 実行される。"

#. type: Plain text
#: build/C/man2/clone.2:698
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""
"スレッド・グループに属すスレッドの一つが B<fork>(2)  を使って子プロセスを作成"
"した場合、 スレッド・グループのどのスレッドであっても その子供を B<wait>(2)  "
"できる。"

#. type: Plain text
#: build/C/man2/clone.2:711
#, fuzzy
#| msgid ""
#| "Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
#| "B<CLONE_THREAD> is specified."
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified (and note that, since Linux 2.6.0-test6, "
"B<CLONE_SIGHAND> also requires B<CLONE_VM> to be included)."
msgstr ""
"Linux 2.5.35 以降では、 B<CLONE_THREAD> を指定する場合、 I<flags> に "
"B<CLONE_SIGHAND> も含まれていなければならない。"

#. type: Plain text
#: build/C/man2/clone.2:716
msgid ""
"Signals may be sent to a thread group as a whole (i.e., a TGID) using B<kill>"
"(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
msgstr ""
"B<kill>(2)  を使ってスレッド・グループ全体 (つまり TGID) にシグナルを送ること"
"もできれば、 B<tgkill>(2)  を使って特定のスレッド (つまり TID) にシグナルを送"
"ることもできる。"

#. type: Plain text
#: build/C/man2/clone.2:721
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""
"シグナルの配送と処理はプロセス全体に影響する: ハンドラを設定していないシグナ"
"ルがあるスレッドに配送されると、 そのシグナルはスレッド・グループの全メンバー"
"に影響を及ぼす (終了したり、停止したり、動作を継続したり、無視されたりする)。"

#. type: Plain text
#: build/C/man2/clone.2:734
msgid ""
"Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
"signals can be pending either: for the whole process (i.e., deliverable to "
"any member of the thread group), when sent with B<kill>(2); or for an "
"individual thread, when sent with B<tgkill>(2).  A call to B<sigpending>(2)  "
"returns a signal set that is the union of the signals pending for the whole "
"process and the signals that are pending for the calling thread."
msgstr ""
"各々のスレッドは独自のシグナルマスクを持っており、 B<sigprocmask>(2)  で設定"
"できる。 だが、処理待ちのシグナルには、 B<kill>(2)  で送信されるプロセス全体"
"に対するもの (つまり、スレッド・グループの どのメンバーにも配送できるもの) "
"と、 B<tgkill>(2)  で送信される個々のスレッドに対するものがありえる。 "
"B<sigpending>(2)  を呼び出すと、プロセス全体に対する処理待ちシグナルと呼び出"
"し元の スレッドに対する処理待ちシグナルを結合したシグナル集合が返される。"

#. type: Plain text
#: build/C/man2/clone.2:746
msgid ""
"If B<kill>(2)  is used to send a signal to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive a signal sent using B<kill>(2)."
msgstr ""
"B<kill>(2)  を使ってスレッド・グループにシグナルが送られた場合で、 そのスレッ"
"ド・グループがそのシグナルに対するシグナル・ハンドラが 登録されていたときに"
"は、シグナル・ハンドラはスレッド・グループの メンバーのうち、ただ一つのスレッ"
"ドでだけ起動される。ハンドラが 起動されるスレッドは、そのシグナルを禁止 "
"(block) していない メンバーの中から一つだけが勝手に (arbitrarily) 選ばれる。 "
"スレッド・グループに属す複数のスレッドが B<sigwaitinfo>(2)  を使って同じシグ"
"ナルを待っている場合、 これらのスレッドの中から一つをカーネルが勝手に選択"
"し、 そのスレッドが B<kill (2)> を使って送信されたシグナルを受信する。"

#. type: TP
#: build/C/man2/clone.2:746
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr "B<CLONE_UNTRACED> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/clone.2:753
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""
"B<CLONE_UNTRACED> が指定されると、 trace を行っているプロセスは この子プロセ"
"スに B<CLONE_PTRACE> を適用することができない。"

#. type: TP
#: build/C/man2/clone.2:753
#, no-wrap
msgid "B<CLONE_VFORK> (since Linux 2.2)"
msgstr "B<CLONE_VFORK> (Linux 2.2 以降)"

#. type: Plain text
#: build/C/man2/clone.2:765
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to B<execve>"
"(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""
"B<CLONE_VFORK> が設定された場合、 (B<vfork>(2)  と同様に) 子プロセスが "
"B<execve>(2)  または B<_exit>(2)  によって仮想メモリを解放するまで、呼び出し"
"元のプロセスの実行は停止される。"

#. type: Plain text
#: build/C/man2/clone.2:771
msgid ""
"If B<CLONE_VFORK> is not set then both the calling process and the child are "
"schedulable after the call, and an application should not rely on execution "
"occurring in any particular order."
msgstr ""
"B<CLONE_VFORK> が設定されていない場合、 B<clone>()  呼び出し後は、呼び出し元"
"のプロセスと子プロセスの 両方がスケジュール対象となり、アプリケーションはこれ"
"らのプロセスの 実行順序に依存しないようにすべきである。"

#. type: TP
#: build/C/man2/clone.2:771
#, no-wrap
msgid "B<CLONE_VM> (since Linux 2.0)"
msgstr "B<CLONE_VM> (Linux 2.0 以降)"

#. type: Plain text
#: build/C/man2/clone.2:784
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other process."
msgstr ""
"B<CLONE_VM> が設定された場合、呼び出し元のプロセスと子プロセスは同じメモリ空"
"間で 実行される。特に、呼び出し元のプロセスや子プロセスの一方がメモリに 書き"
"込んだ内容はもう一方のプロセスからも見ることができる。さらに、 子プロセスや呼"
"び出し元のプロセスの一方が B<mmap>(2)  や B<munmap>(2)  を使ってメモリをマッ"
"プしたりアンマップした場合、 もう一方のプロセスにも影響が及ぶ。"

#. type: Plain text
#: build/C/man2/clone.2:793
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""
"B<CLONE_VM> が設定されていない場合、子プロセスは B<clone>()  が実行された時点"
"での、親プロセスのメモリ空間をコピーした 別のメモリ空間で実行される。 一方の"
"プロセスが行ったメモリへの書き込みや ファイルのマップ/アンマップは、 B<fork>"
"(2)  の場合と同様、もう一方のプロセスには影響しない。"

#. type: SS
#: build/C/man2/clone.2:793
#, no-wrap
msgid "The raw system call interface"
msgstr "素のシステムコールのインターフェース"

#. type: Plain text
#: build/C/man2/clone.2:809
msgid ""
"The raw B<clone>()  system call corresponds more closely to B<fork>(2)  in "
"that execution in the child continues from the point of the call.  As such, "
"the I<fn> and I<arg> arguments of the B<clone>()  wrapper function are "
"omitted.  Furthermore, the argument order changes.  The raw system call "
"interface on x86 and many other architectures is roughly:"
msgstr ""
"素の B<clone> システムコールは、より B<fork>(2) に近いかたちになっており、 子"
"プロセスの実行が呼び出しが行われた場所から続けられる。 そのため、 B<clone>() "
"ラッパー関数の引き数 I<fn> と I<arg> は省略される。 また、 引き数の順序も違っ"
"ている。 x86 と他の多くのアーキテクチャにおける、 素のシステムコールのイン"
"ターフェースは、 おおまかには次のようになっている。"

#. type: Plain text
#: build/C/man2/clone.2:815
#, no-wrap
msgid ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           void *>I<ptid>B<, void *>I<ctid>B<,>\n"
"B<           struct pt_regs *>I<regs>B<);>\n"
msgstr ""
"B<long clone(unsigned long >I<flags>B<, void *>I<child_stack>B<,>\n"
"B<           void *>I<ptid>B<, void *>I<ctid>B<,>\n"
"B<           struct pt_regs *>I<regs>B<);>\n"

#. type: Plain text
#: build/C/man2/clone.2:826
msgid ""
"Another difference for the raw system call is that the I<child_stack> "
"argument may be zero, in which case copy-on-write semantics ensure that the "
"child gets separate copies of stack pages when either process modifies the "
"stack.  In this case, for correct operation, the B<CLONE_VM> option should "
"not be specified."
msgstr ""
"生のシステムコールのもう一つの違いは、 I<child_stack> 引き数がゼロでも良いこ"
"とである。この場合には、どちらかのプロセスが スタックを変更した時に、書き込み"
"時コピー (copy-on-write) 方式により 子プロセスがスタック・ページの独立したコ"
"ピーを得られることが保証される。 この場合、正常に動作させるためには、 "
"B<CLONE_VM> オプションを指定してはならない。"

#. type: Plain text
#: build/C/man2/clone.2:834
msgid ""
"For some architectures, the order of the arguments for the system call "
"differs from that shown above.  On the score, microblaze, ARM, ARM 64, PA-"
"RISC, arc, Power PC, xtensa, and MIPS architectures, the order of the fourth "
"and fifth arguments is reversed.  On the cris and s390 architectures, the "
"order of the first and second arguments is reversed."
msgstr ""
"いくつかのアーキテクチャでは、システムコールの引き数の順序は上記とは異なって"
"いる。 microblaze, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa, MIPS アーキテ"
"クチャでは、 4 番目と 5 番目の引き数の順番が逆である。 cris と s390 アーキテ"
"クチャでは、最初と 2 番目の引き数の順番が逆である。"

#. type: SS
#: build/C/man2/clone.2:834
#, no-wrap
msgid "blackfin, m68k, and sparc"
msgstr "blackfin, m68k, sparc"

#. type: Plain text
#: build/C/man2/clone.2:838
msgid ""
"The argument-passing conventions on blackfin, m68k, and sparc are different "
"from descriptions above.  For details, see the kernel (and glibc) source."
msgstr ""
"blackfin, m68k, sparc では引き数渡しの規約が上記の説明とは異なる。 詳細は、"
"カーネル (と glibc) のソースを参照のこと。"

#. type: SS
#: build/C/man2/clone.2:838
#, no-wrap
msgid "ia64"
msgstr "ia64"

#. type: Plain text
#: build/C/man2/clone.2:840
msgid "On ia64, a different interface is used:"
msgstr "ia64 では、別のインターフェースが使用される:"

#. type: Plain text
#: build/C/man2/clone.2:847
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"
msgstr ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"

#. type: Plain text
#: build/C/man2/clone.2:859
msgid ""
"The prototype shown above is for the glibc wrapper function; the raw system "
"call interface has no I<fn> or I<arg> argument, and changes the order of the "
"arguments so that I<flags> is the first argument, and I<tls> is the last "
"argument."
msgstr ""
"上記のプロトタイプは glibc ラッパー関数用のものである。 素のシステムコールの"
"インターフェースには引き数 I<fn> と I<arg> がない。 また、引き数の順序が変わ"
"り、 I<flags> が最初の引き数で、 I<tls> が最後の引き数である。"

#. type: Plain text
#: build/C/man2/clone.2:870
msgid ""
"B<__clone2>()  operates in the same way as B<clone>(), except that "
"I<child_stack_base> points to the lowest address of the child's stack area, "
"and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""
"B<__clone2>() は B<clone>() と同じように動作するが、以下の点が異なる: "
"I<child_stack_base> は子プロセスのスタックエリアの最小のアドレスを指し、 "
"I<stack_size> は I<child_stack_base> が指し示すスタックエリアの大きさを示す。"

#. type: SS
#: build/C/man2/clone.2:870
#, no-wrap
msgid "Linux 2.4 and earlier"
msgstr "Linux 2.4 以前"

#. type: Plain text
#: build/C/man2/clone.2:878
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""
"Linux 2.4 以前では、 B<clone>()  は引き数 I<ptid>, I<tls>, I<ctid> を取らな"
"い。"

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: build/C/man2/clone.2:887
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""
"成功した場合、呼び出し元の実行スレッドには子プロセスのスレッドID が返され"
"る。 失敗した場合、 呼び出し元のコンテキストには -1 が返され、子プロセスは 作"
"成されず、 I<errno> が適切に設定される。"

#. type: SH
#: build/C/man2/clone.2:887 build/C/man2/kcmp.2:170
#: build/C/man2/sched_get_priority_max.2:110 build/C/man3/sched_getcpu.3:65
#: build/C/man2/sched_rr_get_interval.2:80
#: build/C/man2/sched_setaffinity.2:116 build/C/man2/sched_setparam.2:96
#: build/C/man2/sched_setscheduler.2:433 build/C/man2/sched_yield.2:48
#: build/C/man2/setns.2:77 build/C/man2/unshare.2:212
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/clone.2:888
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/clone.2:891
msgid "Too many processes are already running."
msgstr "すでに実行中のプロセスが多すぎる。"

#. type: TP
#: build/C/man2/clone.2:891 build/C/man2/clone.2:898 build/C/man2/clone.2:913
#: build/C/man2/clone.2:921 build/C/man2/clone.2:929 build/C/man2/clone.2:937
#: build/C/man2/clone.2:943 build/C/man2/clone.2:953 build/C/man2/clone.2:961
#: build/C/man2/clone.2:969 build/C/man2/kcmp.2:181
#: build/C/man2/sched_get_priority_max.2:111
#: build/C/man2/sched_rr_get_interval.2:84
#: build/C/man2/sched_setaffinity.2:120 build/C/man2/sched_setaffinity.2:128
#: build/C/man2/sched_setparam.2:97 build/C/man2/sched_setscheduler.2:434
#: build/C/man2/setns.2:82 build/C/man2/unshare.2:213
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/clone.2:898
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux 2.6.0-"
"test6.)"
msgstr ""
"B<CLONE_SIGHAND> が指定されていたが、 B<CLONE_VM> が指定されていなかった。 "
"(Linux 2.6.0-test6 以降)"

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: build/C/man2/clone.2:913
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""
"B<CLONE_THREAD> が指定されていたが、 B<CLONE_SIGHAND> が指定されていなかっ"
"た。 (Linux 2.5.35 以降)"

#. type: Plain text
#: build/C/man2/clone.2:921
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr "B<CLONE_FS> と B<CLONE_NEWNS> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/clone.2:929
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr "B<CLONE_NEWIPC> と B<CLONE_SYSVSEM> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/clone.2:937
msgid "Both B<CLONE_NEWPID> and B<CLONE_THREAD> were specified in I<flags>."
msgstr "B<CLONE_NEWPID> と B<CLONE_THREAD> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/clone.2:943
msgid ""
"Returned by B<clone>()  when a zero value is specified for I<child_stack>."
msgstr "I<child_stack> にゼロを指定した場合に B<clone>()  が返す。"

#. type: Plain text
#: build/C/man2/clone.2:953
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""
"I<flags> に B<CLONE_NEWIPC> が指定されたが、カーネルでオプション "
"B<CONFIG_SYSVIPC> と B<CONFIG_IPC_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:961
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""
"I<flags> に B<CLONE_NEWNET> が指定されたが、カーネルでオプション "
"B<CONFIG_NET_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:969
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""
"I<flags> に B<CLONE_NEWPID> が指定されたが、カーネルでオプション "
"B<CONFIG_PID_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:977
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS> option."
msgstr ""
"I<flags> に B<CLONE_NEWUTS> が指定されたが、カーネルでオプション "
"B<CONFIG_UTS> が有効になっていなかった。"

#. type: TP
#: build/C/man2/clone.2:977 build/C/man2/setns.2:89 build/C/man2/unshare.2:217
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/clone.2:982
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be copied."
msgstr ""
"子プロセスのために確保すべきタスク構造体や、呼び出し元のコンテキストの 一部を"
"コピーするのに必要なメモリを十分に割り当てることができない。"

#. type: TP
#: build/C/man2/clone.2:982 build/C/man2/clone.2:991 build/C/man2/kcmp.2:185
#: build/C/man2/sched_setaffinity.2:135 build/C/man2/sched_setparam.2:101
#: build/C/man2/sched_setscheduler.2:439 build/C/man2/setns.2:92
#: build/C/man2/unshare.2:221
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/clone.2:991
msgid ""
"B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, or "
"B<CLONE_NEWUTS> was specified by an unprivileged process (process without "
"B<CAP_SYS_ADMIN>)."
msgstr ""
"非特権プロセス (B<CAP_SYS_ADMIN> を持たないプロセス) が B<CLONE_NEWIPC>, "
"B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, B<CLONE_NEWUTS> を指定し"
"た。"

#. type: Plain text
#: build/C/man2/clone.2:995
msgid "B<CLONE_PID> was specified by a process other than process 0."
msgstr "PID が 0 以外のプロセスによって B<CLONE_PID> が指定された。"

#. type: Plain text
#: build/C/man2/clone.2:1002
msgid ""
"There is no entry for B<clone>()  in libc5.  glibc2 provides B<clone>()  as "
"described in this manual page."
msgstr ""
"libc5 には B<clone>()  はない。glibc2 では B<clone>()  が提供されており、この"
"マニュアルページに記載の通りである。"

#. type: Plain text
#: build/C/man2/clone.2:1006
msgid ""
"B<clone>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""
"B<clone>() は Linux 特有であり、移植を考慮したプログラムでは使用すべき ではな"
"い。"

#. type: Plain text
#: build/C/man2/clone.2:1016
msgid ""
"In the kernel 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in kernel 2.6)."
msgstr ""
"カーネル 2.4.x 系列では、一般的には B<CLONE_THREAD> フラグを指定しても新しい"
"スレッドの親を 呼び出し元プロセスの親と同じにはしない。 しかし、バージョン "
"2.4.7〜2.4.18 のカーネルでは、 (カーネル 2.6 と同じように) CLONE_THREAD フラ"
"グを指定すると、 暗黙のうちに CLONE_PARENT フラグを指定したことになる。"

#. type: Plain text
#: build/C/man2/clone.2:1026
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In 2.6.2 the need to give this together with "
"B<CLONE_THREAD> disappeared.  This flag is still defined, but has no effect."
msgstr ""
"B<CLONE_DETACHED> というフラグが、2.5.32 で導入されて以来しばらくの間存在し"
"た。 このフラグは親プロセスが子プロセス終了のシグナルを必要としないことを 表"
"すものである。 2.6.2 で、 CLONE_DETATCHED を CLONE_THREAD と一緒に指定する必"
"要はなくなった。 このフラグはまだ定義されているが、何の効果もない。"

#. type: Plain text
#: build/C/man2/clone.2:1031
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""
"i386 上では、 B<clone>()  は vsyscall 経由ではなく、直接 I<int $0x80> 経由で"
"呼び出すべきである。"

#. type: Plain text
#: build/C/man2/clone.2:1062
msgid ""
"Versions of the GNU C library that include the NPTL threading library "
"contain a wrapper function for B<getpid>(2)  that performs caching of PIDs.  "
"This caching relies on support in the glibc wrapper for B<clone>(), but as "
"currently implemented, the cache may not be up to date in some "
"circumstances.  In particular, if a signal is delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal may return the PID of the calling process (\"the "
"parent\"), if the clone wrapper has not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it may be necessary to use code such as the following:"
msgstr ""
"NPTL スレッド・ライブラリを含んでいる GNU C ライブラリのいくつかのバージョン "
"には、 B<getpid>(2)  のラッパー関数が含まれており、このラッパー関数は PID を"
"キャッシュする。 このキャッシュ処理が正しく動作するためには glibc の B<clone>"
"()  のラッパー関数での助けが必要だが、現状の実装では、 ある状況下において"
"キャッシュが最新とならない可能性がある。 特に、 B<clone>()  の呼び出し直後に"
"シグナルが子プロセスに配送された場合に、 そのシグナルに対するハンドラ内で "
"B<getpid>(2)  を呼び出すと、それまでに clone のラッパー関数が子プロセスの "
"PID キャッシュを 更新する機会が得られていなければ、呼び出し元プロセス (\"親プ"
"ロセス\") の PID が 返される可能性がある。 (この議論では、子プロセスが "
"B<CLONE_THREAD> を使って作成された場合のことは無視している。 子プロセスが "
"B<CLONE_THREAD> を作って作成された場合には、 呼び出し元と子プロセスは同じス"
"レッド・グループに属すので、 B<getpid>(2)  は子プロセスと B<clone>()  を呼び"
"出したプロセスで同じ値を返すのが「正しい」。 キャッシュが最新とならない問題 "
"(stale-cache problem) は、 I<flags> に B<CLONE_VM> が含まれている場合にも発生"
"しない。)  本当の値を得るためには、次のようなコードを使う必要があるかもしれな"
"い。"

#. type: Plain text
#: build/C/man2/clone.2:1065
#, no-wrap
msgid "    #include E<lt>syscall.hE<gt>\n"
msgstr "    #include E<lt>syscall.hE<gt>\n"

#. type: Plain text
#: build/C/man2/clone.2:1067
#, no-wrap
msgid "    pid_t mypid;\n"
msgstr "    pid_t mypid;\n"

#. type: Plain text
#: build/C/man2/clone.2:1069
#, no-wrap
msgid "    mypid = syscall(SYS_getpid);\n"
msgstr "    mypid = syscall(SYS_getpid);\n"

#. type: Plain text
#: build/C/man2/clone.2:1083
msgid ""
"The following program demonstrates the use of B<clone>()  to create a child "
"process that executes in a separate UTS namespace.  The child changes the "
"hostname in its UTS namespace.  Both parent and child then display the "
"system hostname, making it possible to see that the hostname differs in the "
"UTS namespaces of the parent and child.  For an example of the use of this "
"program, see B<setns>(2)."
msgstr ""
"以下のプログラムは、 別の UTS 名前空間で動作する子プロセスを B<clone>() を"
"使って作成する例である。 子プロセスは、自分の UTS 名前空間においてホスト名を"
"変更する。 それから、親プロセスと子プロセスの両方でシステムのホスト名を表示"
"し、 親プロセスと子プロセスの UTS 名前空間でホスト名が異なることを確認する。 "
"このプログラムの使用方法については B<setns>(2) を参照。"

#. type: SS
#: build/C/man2/clone.2:1083 build/C/man2/setns.2:166
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/clone.2:1093
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>sys/utsname.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man2/clone.2:1096 build/C/man2/setns.2:177
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/clone.2:1101
#, no-wrap
msgid ""
"static int              /* Start function for cloned child */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"
msgstr ""
"static int              /* clone された子プロセスの開始関数 */\n"
"childFunc(void *arg)\n"
"{\n"
"    struct utsname uts;\n"

#. type: Plain text
#: build/C/man2/clone.2:1103
#, no-wrap
msgid "    /* Change hostname in UTS namespace of child */\n"
msgstr "    /* 子プロセスの UTS 名前空間でホスト名を変更する */\n"

#. type: Plain text
#: build/C/man2/clone.2:1106
#, no-wrap
msgid ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"
msgstr ""
"    if (sethostname(arg, strlen(arg)) == -1)\n"
"        errExit(\"sethostname\");\n"

#. type: Plain text
#: build/C/man2/clone.2:1108
#, no-wrap
msgid "    /* Retrieve and display hostname */\n"
msgstr "    /* ホスト名を取得し表示する */\n"

#. type: Plain text
#: build/C/man2/clone.2:1112
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"
msgstr ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in child:  %s\\en\", uts.nodename);\n"

#. type: Plain text
#: build/C/man2/clone.2:1116
#, no-wrap
msgid ""
"    /* Keep the namespace open for a while, by sleeping.\n"
"       This allows some experimentation--for example, another\n"
"       process might join the namespace. */\n"
msgstr ""
"    /* sleep を使ってしばらく名前空間をオープンされたままにする。\n"
"       これにより実験を行うことができる -- 例えば、\n"
"       別のプロセスがこの名前空間に参加するなど。 */\n"

#. type: Plain text
#: build/C/man2/clone.2:1118
#, no-wrap
msgid "    sleep(200);\n"
msgstr "    sleep(200);\n"

#. type: Plain text
#: build/C/man2/clone.2:1121
#, no-wrap
msgid ""
"    return 0;           /* Child terminates now */\n"
"}\n"
msgstr ""
"    return 0;           /* 子プロセスを終了する */\n"
"}\n"

#. type: Plain text
#: build/C/man2/clone.2:1123
#, no-wrap
msgid "#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */\n"
msgstr "#define STACK_SIZE (1024 * 1024)    /* clone される子プロセスのスタックサイズ */\n"

#. type: Plain text
#: build/C/man2/clone.2:1131
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* Start of stack buffer */\n"
"    char *stackTop;                 /* End of stack buffer */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *stack;                    /* スタックバッファの先頭 */\n"
"    char *stackTop;                 /* スタックバッファの末尾 */\n"
"    pid_t pid;\n"
"    struct utsname uts;\n"

#. type: Plain text
#: build/C/man2/clone.2:1136
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>child-hostnameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/clone.2:1138
#, no-wrap
msgid "    /* Allocate stack for child */\n"
msgstr "    /* 子プロセス用のスタックを割り当てる */\n"

#. type: Plain text
#: build/C/man2/clone.2:1143
#, no-wrap
msgid ""
"    stack = malloc(STACK_SIZE);\n"
"    if (stack == NULL)\n"
"        errExit(\"malloc\");\n"
"    stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */\n"
msgstr ""
"    stack = malloc(STACK_SIZE);\n"
"    if (stack == NULL)\n"
"        errExit(\"malloc\");\n"
"    stackTop = stack + STACK_SIZE;  /* スタックは下方向に伸びるものとする */\n"

#. type: Plain text
#: build/C/man2/clone.2:1146
#, no-wrap
msgid ""
"    /* Create child that has its own UTS namespace;\n"
"       child commences execution in childFunc() */\n"
msgstr ""
"    /* 自分専用の UTS 名前空間を持つ子プロセスを作成する;\n"
"       子プロセスは childFunc() の実行を開始する */\n"

#. type: Plain text
#: build/C/man2/clone.2:1151
#, no-wrap
msgid ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %ld\\en\", (long) pid);\n"
msgstr ""
"    pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);\n"
"    if (pid == -1)\n"
"        errExit(\"clone\");\n"
"    printf(\"clone() returned %ld\\en\", (long) pid);\n"

#. type: Plain text
#: build/C/man2/clone.2:1153
#, no-wrap
msgid "    /* Parent falls through to here */\n"
msgstr "    /* 親プロセスの実行はここに来る */\n"

#. type: Plain text
#: build/C/man2/clone.2:1155
#, no-wrap
msgid "    sleep(1);           /* Give child time to change its hostname */\n"
msgstr "    sleep(1);           /* 子プロセスがホスト名を変更する時間を与える */\n"

#. type: Plain text
#: build/C/man2/clone.2:1158
#, no-wrap
msgid ""
"    /* Display hostname in parent\\(aqs UTS namespace. This will be\n"
"       different from hostname in child\\(aqs UTS namespace. */\n"
msgstr ""
"    /* 親プロセスの UTS 名前空間でのホスト名を表示する;\n"
"       これは子プロセスの UTS 名前空間でのホスト名とは異なる */\n"

#. type: Plain text
#: build/C/man2/clone.2:1162
#, no-wrap
msgid ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"
msgstr ""
"    if (uname(&uts) == -1)\n"
"        errExit(\"uname\");\n"
"    printf(\"uts.nodename in parent: %s\\en\", uts.nodename);\n"

#. type: Plain text
#: build/C/man2/clone.2:1166
#, no-wrap
msgid ""
"    if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"
msgstr ""
"    if (waitpid(pid, NULL, 0) == -1)    /* 子プロセスを待つ */\n"
"        errExit(\"waitpid\");\n"
"    printf(\"child has terminated\\en\");\n"

#. type: Plain text
#: build/C/man2/clone.2:1169
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/clone.2:1184
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), "
"B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), B<tkill>(2), "
"B<unshare>(2), B<wait>(2), B<capabilities>(7), B<pthreads>(7)"
msgstr ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<kcmp>(2), "
"B<set_thread_area>(2), B<set_tid_address>(2), B<setns>(2), B<tkill>(2), "
"B<unshare>(2), B<wait>(2), B<capabilities>(7), B<pthreads>(7)"

#. type: TH
#: build/C/man2/kcmp.2:28
#, no-wrap
msgid "KCMP"
msgstr "KCMP"

#. type: TH
#: build/C/man2/kcmp.2:28
#, fuzzy, no-wrap
#| msgid "2013-01-01"
msgid "2013-12-08"
msgstr "2013-01-01"

#. type: Plain text
#: build/C/man2/kcmp.2:31
msgid ""
"kcmp - compare two processes to determine if they share a kernel resource"
msgstr "kcmp - 二つのプロセスが同じカーネルリソースを共有しているかを比較する"

#. type: Plain text
#: build/C/man2/kcmp.2:34
#, no-wrap
msgid "B<#include E<lt>linux/kcmp.hE<gt>>\n"
msgstr "B<#include E<lt>linux/kcmp.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/kcmp.2:37
#, no-wrap
msgid ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"
msgstr ""
"B<int kcmp(pid_t >I<pid1>B<, pid_t >I<pid2>B<, int >I<type>B<,>\n"
"B<         unsigned long >I<idx1>B<, unsigned long >I<idx2>B<);>\n"

#. type: Plain text
#: build/C/man2/kcmp.2:41
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/kcmp.2:50
msgid ""
"The B<kcmp>()  system call can be used to check whether the two processes "
"identified by I<pid1> and I<pid2> share a kernel resource such as virtual "
"memory, file descriptors, and so on."
msgstr ""
"システムコール B<kcmp>() を使うと、 ID が I<pid1> と I<pid2> の二つのプロセス"
"が、 仮想メモリやファイルディスクリプタなどの、 同じカーネルリソースを共有し"
"ているかどうかを検査できる。"

#. type: Plain text
#: build/C/man2/kcmp.2:55
msgid ""
"The I<type> argument specifies which resource is to be compared in the two "
"processes.  It has one of the following values:"
msgstr ""
"I<type> 引き数は 2 つのプロセス間でどのリソースを比較するかを指定する。 以下"
"のいずれかの値を指定する。"

#. type: TP
#: build/C/man2/kcmp.2:55
#, no-wrap
msgid "B<KCMP_FILE>"
msgstr "B<KCMP_FILE>"

#. type: Plain text
#: build/C/man2/kcmp.2:67
msgid ""
"Check whether a file descriptor I<idx1> in the process I<pid1> refers to the "
"same open file description (see B<open>(2))  as file descriptor I<idx2> in "
"the process I<pid2>."
msgstr ""
"プロセス I<pid1> のファイルディスクリプタ I<idx1> が、 プロセス I<pid2> の"
"ファイルディスクリプタ I<idx2> と同じオープンファイル記述 (open file "
"description) を参照しているかを検査する。"

#. type: TP
#: build/C/man2/kcmp.2:67
#, no-wrap
msgid "B<KCMP_FILES>"
msgstr "B<KCMP_FILES>"

#. type: Plain text
#: build/C/man2/kcmp.2:75
msgid ""
"Check whether the process share the same set of open file descriptors.  The "
"arguments I<idx1> and I<idx2> are ignored."
msgstr ""
"二つのプロセスが同じオープンファイル記述の集合を共有しているかを検査する。 引"
"き数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:75
#, no-wrap
msgid "B<KCMP_FS>"
msgstr "B<KCMP_FS>"

#. type: Plain text
#: build/C/man2/kcmp.2:84
msgid ""
"Check whether the processes share the same filesystem information (i.e., "
"file mode creation mask, working directory, and filesystem root).  The "
"arguments I<idx1> and I<idx2> are ignored."
msgstr ""
"二つのプロセスが同じファイルシステム情報 (すなわち、ファイルのモード作成マス"
"ク、作業ディレクトリ、ファイルシステムのルート) を共有しているかを検査する。 "
"引き数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:84
#, no-wrap
msgid "B<KCMP_IO>"
msgstr "B<KCMP_IO>"

#. type: Plain text
#: build/C/man2/kcmp.2:92
msgid ""
"Check whether the processes share I/O context.  The arguments I<idx1> and "
"I<idx2> are ignored."
msgstr ""
"二つのプロセスが I/O コンテキストを共有しているかを検査する。 引き数 I<idx1> "
"と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:92
#, no-wrap
msgid "B<KCMP_SIGHAND>"
msgstr "B<KCMP_SIGHAND>"

#. type: Plain text
#: build/C/man2/kcmp.2:100
msgid ""
"Check whether the processes share the same table of signal dispositions.  "
"The arguments I<idx1> and I<idx2> are ignored."
msgstr ""
"二つのプロセスがシグナル配送 (disposition) テーブルを共有しているかを検査す"
"る。 引き数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:100
#, no-wrap
msgid "B<KCMP_SYSVSEM>"
msgstr "B<KCMP_SYSVSEM>"

#. type: Plain text
#: build/C/man2/kcmp.2:109
msgid ""
"Check whether the processes share the same list of System V semaphore undo "
"operations.  The arguments I<idx1> and I<idx2> are ignored."
msgstr ""
"二つのプロセスが同じ System V セマフォ undo 操作のリストを共有しているかを検"
"査する。 引き数 I<idx1> と I<idx2> は無視される。"

#. type: TP
#: build/C/man2/kcmp.2:109
#, no-wrap
msgid "B<KCMP_VM>"
msgstr "B<KCMP_VM>"

#. type: Plain text
#: build/C/man2/kcmp.2:117
msgid ""
"Check whether the processes share the same address space.  The arguments "
"I<idx1> and I<idx2> are ignored."
msgstr ""
"二つのプロセスが同じアドレス空間を共有しているかを検査する。 引き数 I<idx1> "
"と I<idx2> は無視される。"

#. type: Plain text
#: build/C/man2/kcmp.2:127
#, fuzzy
#| msgid ""
#| "Note the B<kcmp>()  is not protected against false positives which may "
#| "have place if tasks are running.  Which means one should stop tasks being "
#| "inspected with this syscall to obtain meaningful results."
msgid ""
"Note the B<kcmp>()  is not protected against false positives which may occur "
"if tasks are running.  One should stop tasks by sending B<SIGSTOP> (see "
"B<signal>(7))  prior to inspection with this system call to obtain "
"meaningful results."
msgstr ""
"B<kcmp>() には、タスクが実行されている場合に起こり得る誤判定 (false "
"positive) に関する保護はない。 ということは、 意味のある結果を得るためには、 "
"このシステムコールで検査されているタスクを停止すべきだということだ。"

#. type: Plain text
#: build/C/man2/kcmp.2:133
msgid ""
"The return value of a successful call to B<kcmp>()  is simply the result of "
"arithmetic comparison of kernel pointers (when the kernel compares "
"resources, it uses their memory addresses)."
msgstr ""
"B<kcmp>() の呼び出しが成功した場合の返り値は、単にカーネルポインタを数値で比"
"較した結果となる (カーネルはリソースを比較する際、リソースのメモリアドレスを"
"使用する)。"

#. type: Plain text
#: build/C/man2/kcmp.2:141
msgid ""
"The easiest way to explain is to consider an example.  Suppose that I<v1> "
"and I<v2> are the addresses of appropriate resources, then the return value "
"is one of the following:"
msgstr ""
"これを説明するには、例を見るのが一番簡単である。 I<v1> と I<v2> を適切なリ"
"ソースのアドレスとすると、 返り値は以下のいずれか一つとなる。"

#. type: IP
#: build/C/man2/kcmp.2:142
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man2/kcmp.2:147
msgid ""
"I<v1> is equal to I<v2>; in other words, the two processes share the "
"resource."
msgstr ""
"I<v1> は I<v2> と等しい。言い換えれば、二つのプロセスはそのリソースを共有して"
"いる。"

#. type: IP
#: build/C/man2/kcmp.2:147
#, no-wrap
msgid "1"
msgstr "1"

#. type: Plain text
#: build/C/man2/kcmp.2:151
msgid "I<v1> is less than I<v2>."
msgstr "I<v1> は I<v2> より小さい。"

#. type: IP
#: build/C/man2/kcmp.2:151
#, no-wrap
msgid "2"
msgstr "2"

#. type: Plain text
#: build/C/man2/kcmp.2:155
msgid "I<v1> is greater than I<v2>."
msgstr "I<v1> は I<v2> より大きい。"

#. type: IP
#: build/C/man2/kcmp.2:155
#, no-wrap
msgid "3"
msgstr "3"

#. type: Plain text
#: build/C/man2/kcmp.2:160
msgid "I<v1> is not equal to I<v2>, but ordering information is unavailable."
msgstr "I<v1> は I<v2> と等しくないが、順序情報がない。"

#. type: Plain text
#: build/C/man2/kcmp.2:165
msgid "On error, -1 is returned, and I<errno> is set appropriately."
msgstr "エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/kcmp.2:170
#, fuzzy
#| msgid ""
#| "B<kcmp ()> was designed to return values suitable for sorting.  This is "
#| "particularly handy if one needs to compare a large number of file "
#| "descriptors."
msgid ""
"B<kcmp>()  was designed to return values suitable for sorting.  This is "
"particularly handy if one needs to compare a large number of file "
"descriptors."
msgstr ""
"B<kcmp ()> は、ソートに適した値を返すように設計された。 大量のファイルディス"
"クリプタを比較する必要がある場合に、特に役に立つ。"

#. type: TP
#: build/C/man2/kcmp.2:171 build/C/man2/setns.2:78
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/kcmp.2:181
msgid ""
"I<type> is B<KCMP_FILE> and I<fd1> or I<fd2> is not an open file descriptor."
msgstr ""
"I<type> が B<KCMP_FILE> で、かつ I<fd1> か I<fd2> がオープンファイル記述でな"
"い。"

#. type: Plain text
#: build/C/man2/kcmp.2:185
msgid "I<type> is invalid."
msgstr "I<type> が無効である。"

#. type: Plain text
#: build/C/man2/kcmp.2:191
msgid ""
"Insufficient permission to inspect process resources.  The B<CAP_SYS_PTRACE> "
"capability is required to inspect processes that you do not own."
msgstr ""
"プロセスのリソースを検査するのに十分な許可がない。 自分が所有していないプロセ"
"スを検査するためには B<CAP_SYS_PTRACE> ケーパビリティが必要である。"

#. type: TP
#: build/C/man2/kcmp.2:191 build/C/man2/sched_rr_get_interval.2:90
#: build/C/man2/sched_setaffinity.2:145 build/C/man2/sched_setparam.2:107
#: build/C/man2/sched_setscheduler.2:442
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/kcmp.2:198
msgid "Process I<pid1> or I<pid2> does not exist."
msgstr "プロセス I<pid1> か I<pid2> が存在しない。"

#. type: Plain text
#: build/C/man2/kcmp.2:202
msgid "The B<kcmp>()  system call first appeared in Linux 3.5."
msgstr "B<kcmp>() システムコールは Linux 3.5 で初めて登場した。"

#. type: Plain text
#: build/C/man2/kcmp.2:205
#, fuzzy
#| msgid ""
#| "B<kcmp>()  is Linux specific and should not be used in programs intended "
#| "to be portable."
msgid ""
"B<kcmp>()  is Linux-specific and should not be used in programs intended to "
"be portable."
msgstr ""
"B<kcmp>() は Linux 特有であり、 移植を考慮したプログラムでは使用すべきではな"
"い。"

#. type: Plain text
#: build/C/man2/kcmp.2:208
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2)."
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2) を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/kcmp.2:217
msgid ""
"This system call is available only if the kernel was configured with "
"B<CONFIG_CHECKPOINT_RESTORE>.  The main use of the system call is for the "
"checkpoint/restore in user space (CRIU) feature.  The alternative to this "
"system call would have been to expose suitable process information via the "
"B<proc>(5)  filesystem; this was deemed to be unsuitable for security "
"reasons."
msgstr ""
"このシステムコールが利用できるのは、 カーネルの B<CONFIG_CHECKPOINT_RESTORE> "
"オプションが有効になっている場合だけである。 このシステムコールの主な用途"
"は、 ユーザ空間でのチェックポイント/リストア (checkpoint/restore in user "
"space; CRIU) 機能である。 このシステムコールを使わないとすると、 B<proc>(5) "
"ファイルシステム経由で必要なプロセス情報を公開することになるが、 これはセキュ"
"リティ上の理由から不適切とみなされた。"

#. type: Plain text
#: build/C/man2/kcmp.2:222
msgid ""
"See B<clone>(2)  for some background information on the shared resources "
"referred to on this page."
msgstr ""
"このページで参照されている共有リソースに関する背景についての情報は B<clone>"
"(2) を参照のこと。"

#. type: Plain text
#: build/C/man2/kcmp.2:225
msgid "B<clone>(2), B<unshare>(2)"
msgstr "B<clone>(2), B<unshare>(2)"

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr "SCHED_GET_PRIORITY_MAX"

#. type: TH
#: build/C/man2/sched_get_priority_max.2:29
#, fuzzy, no-wrap
#| msgid "2013-09-17"
msgid "2013-09-23"
msgstr "2013-09-17"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:32
msgid ""
"sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""
"sched_get_priority_max, sched_get_priority_min - 静的プライオリティの範囲を取"
"得する"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:34
#: build/C/man2/sched_rr_get_interval.2:34 build/C/man2/sched_yield.2:34
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr "B<#include E<lt>sched.hE<gt>>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:36
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_max(int >I<policy>B<);>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:38
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_min(int >I<policy>B<);>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:58
#, fuzzy
#| msgid ""
#| "B<sched_get_priority_max>()  returns the maximum priority value that can "
#| "be used with the scheduling algorithm identified by I<policy>.  "
#| "B<sched_get_priority_min>()  returns the minimum priority value that can "
#| "be used with the scheduling algorithm identified by I<policy>.  Supported "
#| "I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, and "
#| "B<SCHED_BATCH>.  Further details about these policies can be found in "
#| "B<sched_setscheduler>(2)."
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, "
"B<SCHED_BATCH>, and B<SCHED_IDLE>.  Further details about these policies can "
"be found in B<sched_setscheduler>(2)."
msgstr ""
"B<sched_get_priority_max>()  はI<policy> によって指定されたスケジューリングの"
"アルゴリズムで 使用されるプライオリティの最大値を返す。 "
"B<sched_get_priority_min>()  はI<policy> によって指定されたスケジューリングの"
"アルゴリズムで 使用されるプライオリティの最小値を返す。 サポートされる "
"I<policy> の値は B<SCHED_FIFO>、 B<SCHED_RR>、 B<SCHED_OTHER>、 "
"B<SCHED_BATCH> である。これらのスケジューリング方針に関する詳細は "
"B<sched_setscheduler>(2)  に書かれている。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:67
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""
"数値的に大きなプライオリティ値を持つプロセスは小さな プライオリティ値を持つプ"
"ロセスより前にスケジュールされる。 このため B<sched_get_priority_max>()  が返"
"す値は B<sched_get_priority_min>()  が返す値よりも大きい。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:79
#, fuzzy
#| msgid ""
#| "Linux allows the static priority value range 1 to 99 for B<SCHED_FIFO> "
#| "and B<SCHED_RR> and the priority 0 for B<SCHED_OTHER> and "
#| "B<SCHED_BATCH>.  Scheduling priority ranges for the various policies are "
#| "not alterable."
msgid ""
"Linux allows the static priority value range 1 to 99 for B<SCHED_FIFO> and "
"B<SCHED_RR> and the priority 0 for B<SCHED_OTHER>, B<SCHED_BATCH>, and "
"B<SCHED_IDLE>.  Scheduling priority ranges for the various policies are not "
"alterable."
msgstr ""
"Linux では B<SCHED_FIFO> と B<SCHED_RR> では 1 から 99 の範囲の 静的プライオ"
"リティーを持ち、B<SCHED_OTHER> と B<SCHED_BATCH> では プライオリティとして 0 "
"を持つ。 それぞれの方針のスケジューリング・プライオリティの範囲は 変更するこ"
"とができない。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:91
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>().  POSIX.1-2001 requires a spread of at least 32 "
"between the maximum and the minimum values for B<SCHED_FIFO> and B<SCHED_RR>."
msgstr ""
"スケジューリング・プライオリティの範囲は他の POSIX システムと 異なっているか"
"もしれない。それで、移植性(portable)のある アプリケーションでは仮想的な範囲を"
"用い B<sched_get_priority_max>()  と B<sched_get_priority_min>()  で与えられ"
"た間隔にマップして使用することはいい考えである。 POSIX.1-2001 では "
"B<SCHED_FIFO> と B<SCHED_RR> における 最大値と最小値の間隔を少なくとも 32 に"
"することを要求している。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:100
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムでは B<sched_get_priority_max>()  と B<sched_get_priority_min>"
"()  は I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が定義されてい"
"る場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:110
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_get_priority_max>()  と B<sched_get_priority_min>()  "
"は指定されたスケジューリング方針のプライオリティの最大値/最小値を返す。 エ"
"ラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:116
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr "引き数 I<policy> が定義されているスケジューリング方針と一致しない。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:118
#: build/C/man2/sched_rr_get_interval.2:96 build/C/man2/sched_setparam.2:112
#: build/C/man2/sched_yield.2:54
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:127
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2)"
msgstr ""
"B<sched_getaffinity>(2), B<sched_getparam>(2)  B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2),"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:130
#: build/C/man2/sched_rr_get_interval.2:138 build/C/man2/sched_setparam.2:134
#: build/C/man2/sched_setscheduler.2:564 build/C/man2/sched_yield.2:85
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly "
"& Associates, Inc., ISBN 1-56592-074-0."
msgstr ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly "
"& Associates, Inc., ISBN 1-56592-074-0."

#. type: TH
#: build/C/man3/sched_getcpu.3:26
#, no-wrap
msgid "SCHED_GETCPU"
msgstr "SCHED_GETCPU"

#. type: TH
#: build/C/man3/sched_getcpu.3:26 build/C/man2/unshare.2:20
#, no-wrap
msgid "2013-04-17"
msgstr "2013-04-17"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:29
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr "sched_getcpu - 呼び出したスレッドが実行されている CPU を知る"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr "B<int sched_getcpu(void);>\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:39 build/C/man2/unshare.2:33
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:42
msgid "B<sched_getcpu>():"
msgstr "B<sched_getcpu>():"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:58
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""
"B<sched_getcpu>()  は、呼び出したスレッドが現在実行されている CPU の番号を返"
"す。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:65
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sched_getcpu>()  は非負の CPU 番号を返す。 エラーの場合、-1 を"
"返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/sched_getcpu.3:66 build/C/man2/sched_rr_get_interval.2:87
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:70
msgid "This kernel does not implement B<getcpu>(2)."
msgstr "このカーネルでは B<getcpu>(2)  が実装されていない。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:72
msgid "This function is available since glibc 2.6."
msgstr "この関数は glibc 2.6 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:75
#, fuzzy
#| msgid "B<sched_getcpu>()  is glibc specific."
msgid "B<sched_getcpu>()  is glibc-specific."
msgstr "B<sched_getcpu>()  は glibc 固有である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:77
msgid "The call"
msgstr "呼び出し"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:81
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr "cpu = sched_getcpu();\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:87
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr "は、以下の B<getcpu>(2)  呼び出しと等価である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:93
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:97
msgid "B<getcpu>(2)"
msgstr "B<getcpu>(2)"

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr "SCHED_RR_GET_INTERVAL"

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:29
#, no-wrap
msgid "2013-03-18"
msgstr "2013-03-18"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:32
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr "sched_rr_get_interval - 指定されたプロセスの SCHED_RR 間隔を取得する"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:36
msgid ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec * >I<tp>B<);>"
msgstr ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:47
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>.  "
"The specified process should be running under the B<SCHED_RR> scheduling "
"policy."
msgstr ""
"B<sched_rr_get_interval>() は I<tp> で指定された I<timespec> 構造体に\n"
"I<pid> で指定されたプロセスのラウンドロビン時間量 (round robin time\n"
"quantum) を書き込む。指定されたプロセスは B<SCHED_RR> スケジューリング\n"
"ポリシーで動作しているはずである。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:51
msgid "The I<timespec> structure has the following form:"
msgstr "I<timespec> 構造体は以下の通りである:"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:58
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"

#
#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:73
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>."
msgstr ""
"I<pid> が 0 の場合、呼び出したプロセスの時間量 (time quantum) が\n"
"I<*tp> に書き込まれる。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:80
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_rr_get_interval>()  は 0 を返す。 エラーの場合は -1 が"
"返され、 I<errno> が適切に設定される。"

#. type: TP
#: build/C/man2/sched_rr_get_interval.2:81
#: build/C/man2/sched_setaffinity.2:117
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:84
msgid "Problem with copying information to user space."
msgstr "情報をユーザ空間にコピーする時に問題が起きた。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:87
msgid "Invalid pid."
msgstr "PID が不正である。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:90
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""
"システム・コールがまだ実装されていない (かなり古いカーネルにおいてのみ)。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:94
msgid "Could not find a process with the ID I<pid>."
msgstr "プロセス ID が I<pid> のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:103
msgid ""
"POSIX systems on which B<sched_rr_get_interval>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムで B<sched_rr_get_interval>() は I<E<lt>unistd.hE<gt>> に\n"
"B<_POSIX_PRIORITY_SCHEDULING> が定義されている場合にのみ使用可能である。"

#. type: SS
#: build/C/man2/sched_rr_get_interval.2:103
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#.  commit a4ec24b48ddef1e93f7578be53270f0b95ad666c
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:117
msgid ""
"POSIX does not specify any mechanism for controlling the size of the round-"
"robin time quantum.  Older Linux kernels provide a (nonportable) method of "
"doing this.  The quantum can be controlled by adjusting the process's nice "
"value (see B<setpriority>(2)).  Assigning a negative (i.e., high) nice value "
"results in a longer quantum; assigning a positive (i.e., low) nice value "
"results in a shorter quantum.  The default quantum is 0.1 seconds; the "
"degree to which changing the nice value affects the quantum has varied "
"somewhat across kernel versions.  This method of adjusting the quantum was "
"removed starting with Linux 2.6.24."
msgstr ""
"POSIX ではラウンドロビン時間量の大きさを制御する仕組みが規定されていない。 古"
"い Linux カーネルではこれを変更する方法が提供されている (この方法に移植性はな"
"い)。 プロセスの nice 値を調整することで時間量を制御できる (B<setpriority>"
"(2) 参照)。 負の nice 値 (すなわち、高い nice 値) を割り当てると時間量は長く"
"なり、 正の nice 値 (すなわち、低い nice 値) を割り当てると時間量は短くな"
"る。 デフォルトの時間量は 0.1 秒である。 nice 値の変更が時間量にどの程度影響"
"を与えるかは カーネルのバージョンにより多少異なる。時間量を調整するこのメソッ"
"ドは Linux 2.6.24 以降で削除された。"

#.  commit ce0dbbbb30aee6a835511d5be446462388ba9eee
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:132
msgid ""
"Linux 3.9 added a new mechanism for adjusting (and viewing) the B<SCHED_RR> "
"quantum: the I</proc/sys/kernel/sched_rr_timeslice_ms> file exposes the "
"quantum as a millisecond value, whose default is 100.  Writing 0 to this "
"file resets the quantum to the default value."
msgstr ""
"Linux 3.9 で、 B<SCHED_RR> の時間量の調整 (と参照) を行う新しい機構が追加され"
"た。 I</proc/sys/kernel/sched_rr_timeslice_ms> ファイルでミリ秒単位の時間量の"
"値が参照でき、 デフォルト値は 100 である。 このファイルに 0 を書き込むと、 時"
"間量をデフォルト値に戻すことができる。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:135
#: build/C/man2/sched_setaffinity.2:177
msgid ""
"B<sched_setscheduler>(2)  has a description of the Linux scheduling scheme."
msgstr ""
"B<sched_setscheduler>(2) に Linux のスケジューリング方式についての説明\n"
"がある。"

#. type: TH
#: build/C/man2/sched_setaffinity.2:34
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr "SCHED_SETAFFINITY"

#. type: TH
#: build/C/man2/sched_setaffinity.2:34 build/C/man2/sched_setparam.2:30
#: build/C/man2/sched_setscheduler.2:46
#, no-wrap
msgid "2013-09-17"
msgstr "2013-09-17"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:38
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity "
"mask"
msgstr ""
"sched_setaffinity, sched_getaffinity - スレッドの CPU affinity マスクを設定・"
"取得する"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:45
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:48
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:63
msgid ""
"A thread's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular thread (i.e., setting the affinity mask of that thread "
"to specify a single CPU, and setting the affinity mask of all other threads "
"to exclude that CPU), it is possible to ensure maximum execution speed for "
"that thread.  Restricting a thread to run on a single CPU also avoids the "
"performance cost caused by the cache invalidation that occurs when a thread "
"ceases to execute on one CPU and then recommences execution on a different "
"CPU."
msgstr ""
"スレッドの CPU affinity (親和度) マスクは、そのスレッドが 実行を許可されてい"
"る CPU の集合を決定する。 マルチプロセッサ・システムでは、CPU affinity マスク"
"を設定することで 性能上のメリットを得られる可能性がある。 例えば、特定のス"
"レッドを一つの CPU に括り付け (すなわち、そのスレッドの affinity マスクを一つ"
"の CPU に設定し)、 他の全てのスレッドの affinity マスクからその CPU を除外す"
"ることで、 確実にそのスレッドの実行速度を最大にすることができる。 また、ある"
"スレッドの実行を一つの CPU に限定することで、 一つの CPU での実行を停止してか"
"ら別の CPU で実行を再開するときに発生する キャッシュ無効化 (cache "
"invalidation) による性能面の劣化を避けることもできる。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:70
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU set"
"\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""
"CPU affinity マスクは「CPU の集合」を表す I<cpu_set_t> 構造体で表現され、 "
"I<cpu_set_t> へのポインタ I<mask> で指定される。 CPU 集合を操作するためのマク"
"ロ群については B<CPU_SET>(3)  で記載されている。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:85
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the thread whose ID is "
"I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling thread is used.  The argument I<cpusetsize> is the length (in bytes) "
"of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""
"B<sched_setaffinity>()  は、スレッド ID が I<pid> のスレッドの CPU affinity "
"マスクを I<mask> で指定された値に設定する。 I<pid> が 0 の場合、呼び出し元ス"
"レッドが使われる。 I<cpusetsize> 引き数には I<mask> が指すデータの長さ (バイ"
"ト単位) である。 通常は、この引き数には I<sizeof(cpu_set_t)> を指定すればよ"
"い。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:92
msgid ""
"If the thread specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that thread is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""
"I<pid> で指定されたスレッドが I<mask> で指定された CPU のいずれかで現在実行さ"
"れていない場合、 そのスレッドは I<mask> で指定された CPU のいずれかに移動され"
"る。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:107
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the thread whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling thread is returned."
msgstr ""
"B<sched_getaffinity>()  は、 スレッド ID が I<pid> のスレッドの affinity マス"
"クを I<mask> が指す I<cpu_set_t> 構造体に書き込む。 I<cpusetsize> 引き数には "
"I<mask> の (バイト単位の) 大きさを指定する。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:116
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<sched_setaffinity>()  と B<sched_getaffinity>()  は 0 を返"
"す。 エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:120
msgid "A supplied memory address was invalid."
msgstr "指定されたメモリ番地が不正である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:128
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the thread according to any "
"restrictions that may be imposed by the \"cpuset\" mechanism described in "
"B<cpuset>(7)."
msgstr ""
"システム上に現在実際に存在し、かつ \"cpuset\" 機構が課す制限においてそのス"
"レッドに対して許可されている プロセッサが、 affinity ビットマスク I<mask> に"
"含まれていない。 \"cpuset\" 機構については B<cpuset>(7)  を参照。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:135
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, B<sched_setaffinity>"
"())  I<cpusetsize> is smaller than the size of the affinity mask used by the "
"kernel."
msgstr ""
"(B<sched_getaffinity>()  と、カーネル 2.6.9 以前の B<sched_setaffinity>())  "
"I<cpusetsize> がカーネルで使われている affinity マスクのサイズより小さい。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:145
msgid ""
"(B<sched_setaffinity>())  The calling thread does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the thread identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability."
msgstr ""
"(B<sched_setaffinity>())  呼び出し元のスレッドに適切な特権がなかった。 呼び出"
"し元は、実効ユーザ ID が I<pid> で識別されるスレッドの実ユーザ ID または実効"
"ユーザ ID と同じであるか、 B<CAP_SYS_NICE> ケーパビリティ (capability) を持た"
"なければならない。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:148 build/C/man2/sched_setscheduler.2:445
msgid "The thread whose ID is I<pid> could not be found."
msgstr "ID が I<pid> のスレッドが見つからなかった。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:159
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""
"CPU affinity システムコールは Linux kernel 2.5.8 で導入された。 これらのシス"
"テムコールのラッパー関数は glibc 2.3 で導入された。 最初は、glibc のインタ"
"フェースには I<unsigned int> 型の I<cpusetsize> 引き数が入っていた。 glibc "
"2.3.3 では I<cpusetsize> 引き数が削除されたが、glibc 2.3.4 で I<size_t> 型で"
"復活した。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:161
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:174
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the thread "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the thread runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the thread will run are silently imposed by "
"the kernel."
msgstr ""
"B<sched_setaffinity>()  を呼び出した後は、スレッドが実際に実行される CPU の集"
"合は、 I<mask> 引き数で指定された集合と、システム上に実際に存在する CPU の集"
"合の 共通集合 (AND) となる。 \"cpuset\" 機構が使用されている場合には、スレッ"
"ドが動作する CPU 集合 に対してシステムはさらに制限を加えるかもしれない "
"(\"cpuset\" 機構については B<cpuset>(7)  を参照)。 スレッドが動作する実際の "
"CPU 集合に対する制限はカーネルにより 暗黙のうちに適用される。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:194
msgid ""
"The affinity mask is a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""
"affinity マスクはスレッド単位の属性で、スレッドグループの 各スレッド単位に独"
"立して調整することができる。 B<gettid>(2)  コールからの返り値をこのコールの "
"I<pid> 引き数として渡すことができる。 I<pid> に 0 を指定すると呼び出し元のス"
"レッドの属性が設定され、 B<getpid>(2)  コールからの返り値を I<pid> に指定する"
"とスレッドグループのメインスレッドの属性が設定される (POSIX スレッド API を使"
"用している場合、 B<sched_setaffinity>()  の代わりに B<pthread_setaffinity_np>"
"(3)  を使用すること)。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:200
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で生成された子プロセスは親プロセスの CPU affinity マスクを継"
"承する。 affinity マスクは B<execve>(2)  の前後で保存される。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:214
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long\\ *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask.  On success, the raw "
"B<sched_getaffinity>()  system call returns the size (in bytes) of the "
"I<cpumask_t> data type that is used internally by the kernel to represent "
"the CPU set bit mask."
msgstr ""
"このマニュアルページでは CPU affinity コールの glibc インタフェースを 説明し"
"ている。実際のシステムコール・インタフェースは少し違っており、 実際の実装で"
"は CPU 集合は簡単なビットマスクであるという実状を反映し、 I<mask> の型が "
"I<unsigned long\\ *> となっている。 成功時には、生の B<sched_getaffinity>()  "
"システムコール自身は I<cpumask_t> データ型の (バイト単位の) 大きさを返す。 "
"I<cpumask_t> はカーネル内部で CPU 集合のビットマスクを表現するのに 使われてい"
"るデータ型である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:233
msgid ""
"B<taskset>(1), B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), "
"B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7)"
msgstr ""
"B<taskset>(1), B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), "
"B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7)"

#. type: TH
#: build/C/man2/sched_setparam.2:30
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr "SCHED_SETPARAM"

#. type: Plain text
#: build/C/man2/sched_setparam.2:33
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""
"sched_setparam, sched_getparam - スケジューリング・パラメータの設定と取得を行"
"なう"

#. type: Plain text
#: build/C/man2/sched_setparam.2:38
#, no-wrap
msgid "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:40
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:46 build/C/man2/sched_setscheduler.2:65
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:60
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the process identified by I<pid>.  If I<pid> is zero, "
"then the parameters of the calling process are set.  The interpretation of "
"the argument I<param> depends on the scheduling policy of the process "
"identified by I<pid>.  See B<sched_setscheduler>(2)  for a description of "
"the scheduling policies supported under Linux."
msgstr ""
"B<sched_setparam>()  は I<pid> で指定されたプロセスのスケジューリング方針 "
"(scheduling policy) に 関連するスケジューリング・パラメータを設定する。 "
"I<pid> が 0 ならば、呼び出し元のプロセスのパラメータが設定される。 引き数 "
"I<param> の解釈は、 I<pid> で指定されたプロセスのスケジューリング方針によって"
"異なる。 Linux でサポートされているスケジューリング方針の説明は "
"B<sched_setscheduler>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:66
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the process "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"process are retrieved."
msgstr ""
"B<sched_getparam>()  は I<pid> で指定されたプロセスのスケジューリング・パラ"
"メータを取得する。 I<pid> が 0 ならば、呼び出し元のプロセスのパラメータを取得"
"する。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:75
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the thread.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""
"B<sched_setparam>()  はスレッドのスケジューリング方針における I<param> の妥当"
"性をチェックする。 I<param-E<gt>sched_priority> の値は "
"B<sched_get_priority_min>(2)  と B<sched_get_priority_max>(2)  の範囲に入って"
"いなければならない。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:79
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched_setscheduler>(2)."
msgstr ""
"スケジューリングの優先度と方針に関連する特権とリソース制限の 議論に関しては "
"B<sched_setscheduler>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:87
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"B<sched_setparam>()  と B<sched_getparam>()  が使用できる POSIX システムで"
"は、 I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が定義されてい"
"る。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:96
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_setparam>()  と B<sched_getparam>()  は 0 を返す。 エ"
"ラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:101
msgid ""
"The argument I<param> does not make sense for the current scheduling policy."
msgstr "引き数 I<param> が現在のスケジューリング方針においては 無意味である。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:107
msgid ""
"The calling process does not have appropriate privileges (Linux: does not "
"have the B<CAP_SYS_NICE> capability)."
msgstr ""
"呼び出し元のプロセスが適切な特権を持っていない (Linux では、 B<CAP_SYS_NICE> "
"ケーパビリティを持っていない)。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:110
msgid "The process whose ID is I<pid> could not be found."
msgstr "プロセス ID I<pid> のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:118
msgid ""
"Scheduling parameters are in fact per-thread attributes on Linux; see "
"B<sched_setscheduler>(2)."
msgstr ""
"Linux では、スケジューリングパラメータは実際にはスレッド単位の属性である。 "
"B<sched_setscheduler>(2) 参照。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:131
msgid ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getscheduler>"
"(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<capabilities>(7)"
msgstr ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getscheduler>"
"(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<capabilities>(7)"

#. type: TH
#: build/C/man2/sched_setscheduler.2:46
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr "SCHED_SETSCHEDULER"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:50
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling policy/"
"parameters"
msgstr ""
"sched_setscheduler, sched_getscheduler - スケジューリング・ポリシーとパラメー"
"タを設定/取得する"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:55
#, no-wrap
msgid "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
msgstr "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:57
#, no-wrap
msgid "B<                       const struct sched_param *>I<param>B<);>\n"
msgstr "B<                       const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:59
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:76
msgid ""
"B<sched_setscheduler>()  sets both the scheduling policy and the associated "
"parameters for the thread whose ID is specified in I<pid>.  If I<pid> equals "
"zero, the scheduling policy and parameters of the calling thread will be "
"set.  The interpretation of the argument I<param> depends on the selected "
"policy.  Currently, Linux supports the following \"normal\" (i.e., non-real-"
"time) scheduling policies:"
msgstr ""
"B<sched_setscheduler>()  は I<pid> で指定された ID を持つスレッドのスケジュー"
"リング・ポリシーや それに関連するパラメータを設定する。I<pid> が 0 の場合は "
"呼び出したスレッドのスケジューリング・ポリシーとパラメータが設定される。 引き"
"数 I<param> の解釈は選択されたポリシーによる。 現在のところ、Linux では 以下"
"に示す「通常」(リアルタイムでない) スケジューリング・ポリシーが サポートされ"
"ている。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:76
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr "B<SCHED_OTHER>"

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:81
msgid "the standard round-robin time-sharing policy;"
msgstr "標準の、ラウンドロビンによる時分割型のスケジューリング・ポリシー。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:81
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr "B<SCHED_BATCH>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:84
msgid "for \"batch\" style execution of processes; and"
msgstr "「バッチ」形式でのプロセスの実行用。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:84
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr "B<SCHED_IDLE>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:89
msgid "for running I<very> low priority background jobs."
msgstr "「非常に」低い優先度で動作するバックグラウンド・ジョブ用。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:93
msgid ""
"The following \"real-time\" policies are also supported, for special time-"
"critical applications that need precise control over the way in which "
"runnable threads are selected for execution:"
msgstr ""
"どの実行可能スレッドを選択するかについて、より正確な制御を必要とする 時間の制"
"約が厳しい特別なアプリケーション用として、 以下の「リアルタイム」ポリシーもサ"
"ポートされている。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:93
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr "B<SCHED_FIFO>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:96
msgid "a first-in, first-out policy; and"
msgstr "ファーストイン、ファーストアウト型のポリシー。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:96
#, no-wrap
msgid "B<SCHED_RR>"
msgstr "B<SCHED_RR>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:99
msgid "a round-robin policy."
msgstr "ラウンドロビン型のポリシー。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:101
msgid "The semantics of each of these policies are detailed below."
msgstr "これらのポリシーのそれぞれの動作については以下で説明する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:108
msgid ""
"B<sched_getscheduler>()  queries the scheduling policy currently applied to "
"the thread identified by I<pid>.  If I<pid> equals zero, the policy of the "
"calling thread will be retrieved."
msgstr ""
"B<sched_getscheduler>()  は I<pid> で識別されるスレッドに現在適用されている "
"スケジューリング・ポリシーを尋ねる。I<pid> が 0 ならば、呼び出した スレッド自"
"身のスケジューリング・ポリシーが返される。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:108
#, no-wrap
msgid "Scheduling policies"
msgstr "スケジューリング・ポリシー (scheduling policy)"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:117
msgid ""
"The scheduler is the kernel component that decides which runnable thread "
"will be executed by the CPU next.  Each thread has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>; these are the "
"settings that are modified by B<sched_setscheduler>().  The scheduler makes "
"it decisions based on knowledge of the scheduling policy and static priority "
"of all threads on the system."
msgstr ""
"スケジューラ (scheduler) とはカーネルの構成要素で、 次に CPU で実行される実行"
"可能なスレッドを決定するものである。 各々のスレッドには、スケジューリング・ポ"
"リシーと 「静的」なスケジューリング優先度 I<sched_priority> が対応付けられ、 "
"これらの設定は B<sched_setscheduler>()  で変更できる。 スケジューラは、システ"
"ム上の全スレッドのスケジューリング・ポリシーと 静的優先度に関する知識に基づい"
"て決定を行う。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:122
msgid ""
"For threads scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""
"通常のスケジューリング・ポリシー (B<SCHED_OTHER>, B<SCHED_IDLE>, "
"B<SCHED_BATCH>)  の下でスケジューリングされるスレッドでは、 "
"I<sched_priority> はスケジューリングの決定に使用されない (I<sched_priority> "
"には 0 を指定しなければならない)。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:136
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time threads always have higher "
"priority than normal threads.)  Note well: POSIX.1-2001 requires an "
"implementation to support only a minimum 32 distinct priority levels for the "
"real-time policies, and some systems supply just this minimum.  Portable "
"programs should use B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)  to find the range of priorities supported for "
"a particular policy."
msgstr ""
"リアルタイム・スケジューリング・ポリシー (B<SCHED_FIFO>, B<SCHED_RR>)  の下で"
"スケジューリングされるスレッドは、 I<sched_priority> の値は 1 (最低) から 99 "
"(最高) の範囲となる (数字から分かるように、リアルタイム・スレッドは常に通常の"
"スレッドよりも 高い優先度を持つ)。 ここで注意すべきなのは、POSIX.1-2001 が要"
"求しているのは、 リアルタイム・ポリシーの実装において最低 32 種類の異なる優先"
"度レベルが サポートされることだけであり、いくつかのシステムではこの最低限の数"
"の 優先度しか提供されていない、ということである。 移植性が必要なプログラムで"
"は、 B<sched_get_priority_min>(2)  と B<sched_get_priority_max>(2)  を使っ"
"て、あるポリシーがサポートする優先度の範囲を調べるべきである。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:142
msgid ""
"Conceptually, the scheduler maintains a list of runnable threads for each "
"possible I<sched_priority> value.  In order to determine which thread runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the thread at the head of this list."
msgstr ""
"概念としては、 スケジューラはその I<sched_priority> の値それぞれに対して 実行"
"可能なスレッドのリストを管理している。 どのスレッドを次に実行するかを決定する"
"ために、 スケジューラは静的優先度の最も高い空でないリストを探して、 そのリス"
"トの先頭のスレッドを選択する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:146
msgid ""
"A thread's scheduling policy determines where it will be inserted into the "
"list of threads with equal static priority and how it will move inside this "
"list."
msgstr ""
"各スレッドのスケジューリング・ポリシーは、 そのスレッドが同じ静的優先度を持つ"
"スレッドのリストの中のどこに挿入され、 このリストの中をどのように移動するかを"
"決定する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:154
msgid ""
"All scheduling is preemptive: if a thread with a higher static priority "
"becomes ready to run, the currently running thread will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy determines the ordering only within the list of runnable threads with "
"equal static priority."
msgstr ""
"全てのスケジューリングはプリエンプティブ (preemptive) である: より高い優先度"
"のスレッドが実行可能になると、現在実行中のスレッドは実行権を 取り上げられ "
"(preempted)、そのスレッドの静的優先度レベルの待ちリストに 戻される。スケ"
"ジューリング・ポリシーは同じ静的優先度を持つ実行可能な スレッドのリストの中で"
"順番のみを決定する。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:154
#, no-wrap
msgid "SCHED_FIFO: First in-first out scheduling"
msgstr "SCHED_FIFO: ファーストイン・ファーストアウト・スケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:163
msgid ""
"B<SCHED_FIFO> can be used only with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> threads becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> thread.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For threads scheduled under the B<SCHED_FIFO> policy, "
"the following rules apply:"
msgstr ""
"B<SCHED_FIFO> は 0 より大きな静的優先度でのみ使用できる。このポリシーでは、 "
"B<SCHED_FIFO> スレッドが実行可能になった場合、 そのポリシーが "
"B<SCHED_OTHER>、 B<SCHED_BATCH>、 B<SCHED_IDLE> の 現在実行中のスレッドは直ち"
"に実行権を取り上げられる。 B<SCHED_FIFO> は時分割のない単純なスケジューリン"
"グ・アルゴリズムである。 B<SCHED_FIFO> ポリシーでスケジューリングされているス"
"レッドには以下の ルールが適用される:"

#. type: IP
#: build/C/man2/sched_setscheduler.2:163 build/C/man2/sched_setscheduler.2:168
#: build/C/man2/sched_setscheduler.2:171 build/C/man2/sched_setscheduler.2:185
#: build/C/man2/sched_setscheduler.2:288 build/C/man2/sched_setscheduler.2:296
#: build/C/man2/sched_setscheduler.2:337 build/C/man2/sched_setscheduler.2:345
#: build/C/man2/sched_setscheduler.2:350 build/C/man2/sched_setscheduler.2:355
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:168
msgid ""
"A B<SCHED_FIFO> thread that has been preempted by another thread of higher "
"priority will stay at the head of the list for its priority and will resume "
"execution as soon as all threads of higher priority are blocked again."
msgstr ""
"より高い優先度の他のスレッドによって取って代わられた B<SCHED_FIFO> スレッドは"
"その優先度のリストの先頭に留まり続け、 より高い優先度のスレッド全てが停止 "
"(block) した場合に実行を再開する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:171
msgid ""
"When a B<SCHED_FIFO> thread becomes runnable, it will be inserted at the end "
"of the list for its priority."
msgstr ""
"B<SCHED_FIFO> スレッドが実行可能になった時、その優先度のリストの最後 に挿入さ"
"れる。"

#.  In 2.2.x and 2.4.x, the thread is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the thread went to the back -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:185
msgid ""
"A call to B<sched_setscheduler>()  or B<sched_setparam>(2)  will put the "
"B<SCHED_FIFO> (or B<SCHED_RR>) thread identified by I<pid> at the start of "
"the list if it was runnable.  As a consequence, it may preempt the currently "
"running thread if it has the same priority.  (POSIX.1-2001 specifies that "
"the thread should go to the end of the list.)"
msgstr ""
"B<sched_setscheduler>()  や B<sched_setparam>(2)  は I<pid> で指定された "
"B<SCHED_FIFO> (または B<SCHED_RR>) スレッドが 実行可能な場合、リストの最初に"
"置く。 結果として、もし優先度が同じだった場合、 現在実行中のスレッドに先んじ"
"るかもしれない。 (POSIX.1-2001 ではスレッドはリストの最後に行くべきと規定され"
"ている。)"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:189
msgid "A thread calling B<sched_yield>(2)  will be put at the end of the list."
msgstr "B<sched_yield>(2)  を呼び出したスレッドはリストの最後に置かれる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:193
msgid ""
"No other events will move a thread scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable threads with equal static priority."
msgstr ""
"その他のイベントによって B<SCHED_FIFO> ポリシーでスケジューリングされるスレッ"
"ドが同じ優先度の実行可能なスレッドの待ちリストの中を移動することはない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:198
msgid ""
"A B<SCHED_FIFO> thread runs until either it is blocked by an I/O request, it "
"is preempted by a higher priority thread, or it calls B<sched_yield>(2)."
msgstr ""
"B<SCHED_FIFO> スレッドは I/O 要求によって停止するか、 より高い優先度のスレッ"
"ドによって置きかえられるか、 B<sched_yield>(2)  を呼び出すまで実行を続ける。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:198
#, no-wrap
msgid "SCHED_RR: Round-robin scheduling"
msgstr "SCHED_RR: ラウンドロビン (round-robin)・スケジューリング"

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:217
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each thread "
"is allowed to run only for a maximum time quantum.  If a B<SCHED_RR> thread "
"has been running for a time period equal to or longer than the time quantum, "
"it will be put at the end of the list for its priority.  A B<SCHED_RR> "
"thread that has been preempted by a higher priority thread and subsequently "
"resumes execution as a running thread will complete the unexpired portion of "
"its round-robin time quantum.  The length of the time quantum can be "
"retrieved using B<sched_rr_get_interval>(2)."
msgstr ""
"B<SCHED_RR> は B<SCHED_FIFO> の単純な拡張である。 上述された\n"
"B<SCHED_FIFO> に関する記述は全て B<SCHED_RR> に 適用できる。異なるのは\n"
"それぞれのスレッドは最大時間単位までしか実行できない ということである。\n"
"B<SCHED_RR> スレッドが時間単位と同じかそれより 長い時間実行されると、\n"
"その優先度のリストの最後に置かれる。 より高い優先度のスレッドによって\n"
"置きかえられ、その後実行を再開した B<SCHED_RR> スレッドは、そのラウンド\n"
"ロビン時間単位を完全に使い切る まで実行される。その時間単位の長さは\n"
"B<sched_rr_get_interval>(2) を使って取得できる。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:217
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr "SCHED_OTHER: Linux のデフォルトの時分割スケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:233
msgid ""
"B<SCHED_OTHER> can be used at only static priority 0.  B<SCHED_OTHER> is the "
"standard Linux time-sharing scheduler that is intended for all threads that "
"do not require the special real-time mechanisms.  The thread to run is "
"chosen from the static priority 0 list based on a I<dynamic> priority that "
"is determined only inside this list.  The dynamic priority is based on the "
"nice value (set by B<nice>(2)  or B<setpriority>(2))  and increased for each "
"time quantum the thread is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> threads."
msgstr ""
"B<SCHED_OTHER> は静的優先度 0 でのみ使用できる。 B<SCHED_OTHER> は Linux 標準"
"の時分割スケジューラで、 特別なリアルタイム機構を必要としていない全てのスレッ"
"ドで使用される。 実行するスレッドは、静的優先度 0 のリストから、このリストの"
"中だけで 決定される「動的な」優先度 (dynamic priority) に基いて決定される。 "
"動的な優先度は (B<nice>(2)  や B<setpriority>(2)  により設定される) nice 値に"
"基づいて決定されるもので、 単位時間毎に、スレッドが実行可能だが、スケジューラ"
"により実行が拒否された 場合にインクリメントされる。 これにより、全ての "
"B<SCHED_OTHER> スレッドでの公平性が保証される。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:233
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr "SCHED_BATCH: バッチプロセスのスケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:245
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can be used only at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the thread "
"according to its dynamic priority (based on the nice value).  The difference "
"is that this policy will cause the scheduler to always assume that the "
"thread is CPU-intensive.  Consequently, the scheduler will apply a small "
"scheduling penalty with respect to wakeup behaviour, so that this thread is "
"mildly disfavored in scheduling decisions."
msgstr ""
"(Linux 2.6.16 以降)  B<SCHED_BATCH> は静的優先度 0 でのみ使用できる。 このポ"
"リシーは (nice 値に基づく) 動的な優先度にしたがってスレッドの スケジューリン"
"グが行われるという点で、B<SCHED_OTHER> に似ている。 異なるのは、このポリシー"
"では、スレッドが常に CPU に負荷のかかる (CPU-intensive)  処理を行うと、スケ"
"ジューラが仮定する点である。 スケジューラはスレッドを呼び起こす毎にそのスレッ"
"ドにスケジューリング上の ペナルティを少し課し、その結果、このスレッドはスケ"
"ジューリングの決定で 若干冷遇されるようになる。"

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#.  commit b0a9499c3dd50d333e2aedb7e894873c58da3785
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:255
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""
"このポリシーは、非対話的な処理だがその nice 値を下げたくない処理や、 (処理の"
"タスク間で) 余計なタスクの置き換えの原因とある対話的な処理なしで 確定的な "
"(deterministic) スケジューリング・ポリシーを適用したい処理に 対して有効であ"
"る。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:255
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr "SCHED_IDLE: 非常に優先度の低いジョブのスケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:259
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can be used only at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""
"(Linux 2.6.23 以降)  B<SCHED_IDLE> は静的優先度 0 でのみ使用できる。 このポリ"
"シーではプロセスの nice 値はスケジューリングに影響を与えない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:267
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""
"非常に低い優先度でのジョブの実行を目的としたものである (非常に低い優先度と"
"は、ポリシー B<SCHED_OTHER> か B<SCHED_BATCH> での nice 値 +19 よりさらに低い"
"優先度である)。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:267
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr "子プロセスでのスケジューリング・ポリシーのリセット"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:283
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  This feature is intended for media-playback applications, and can "
"be used to prevent applications evading the B<RLIMIT_RTTIME> resource limit "
"(see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""
"Linux 2.6.32 以降では、 B<sched_setscheduler>() を呼び出す際に I<policy> に "
"B<SCHED_RESET_ON_FORK> フラグを OR で指定できる。このフラグが指定されると、 "
"B<fork>(2) で作成された子プロセスは特権が必要なスケジューリング・ポリシーを継"
"承しない。この機能はメディア再生を行うアプリケーションを想定して作られ、この"
"機能を使うことで、アプリケーションが複数の子プロセスを作成することで "
"B<RLIMIT_RTTIME> リソース上限 (B<getrlimit>(2) 参照) を回避するのを防ぐことが"
"できる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:288
msgid ""
"More precisely, if the B<SCHED_RESET_ON_FORK> flag is specified, the "
"following rules apply for subsequently created children:"
msgstr ""
"より正確には、 B<SCHED_RESET_ON_FORK> フラグが指定された場合、それ以降に作成"
"される子プロセスに以下のルールが適用される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:296
msgid ""
"If the calling thread has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""
"呼び出したスレッドのスケジューリング・ポリシーが B<SCHED_FIFO> か "
"B<SCHED_RR> の場合、子プロセスのポリシーは B<SCHED_OTHER> にリセットされる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:299
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""
"子プロセスが負の nice 値を持っている場合、子プロセスの nice 値は 0 にリセット"
"される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:308
msgid ""
"After the B<SCHED_RESET_ON_FORK> flag has been enabled, it can be reset only "
"if the thread has the B<CAP_SYS_NICE> capability.  This flag is disabled in "
"child processes created by B<fork>(2)."
msgstr ""
"一度 B<SCHED_RESET_ON_FORK> フラグが有効にされた後は、このフラグをリセットで"
"きるのは、スレッドが B<CAP_SYS_NICE> ケーパビリティを持つ場合だけである。この"
"フラグは B<fork>(2) で作成された子プロセスでは無効になる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:314
msgid ""
"The B<SCHED_RESET_ON_FORK> flag is visible in the policy value returned by "
"B<sched_getscheduler>()"
msgstr ""
"B<SCHED_RESET_ON_FORK> フラグは、 B<sched_getscheduler>() が返すポリシー値で"
"参照できる。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:314
#, no-wrap
msgid "Privileges and resource limits"
msgstr "特権とリソース制限"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:327
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  threads "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged thread can make is to set the "
"B<SCHED_OTHER> policy, and this can be done only if the effective user ID of "
"the caller of B<sched_setscheduler>()  matches the real or effective user ID "
"of the target thread (i.e., the thread specified by I<pid>)  whose policy is "
"being changed."
msgstr ""
"2.6.12 より前のバージョンの Linux カーネルでは、 特権スレッド "
"(B<CAP_SYS_NICE> ケーパビリティを持つスレッド) だけが 0 以外の静的優先度を設"
"定する (すなわち、リアルタイム・スケジューリング・ポリシーを設定する) ことが"
"できる。 非特権スレッドができる変更は B<SCHED_OTHER> ポリシーを設定することだ"
"けであり、さらにこの変更を行えるのは B<sched_setscheduler>()  の呼び出し元の"
"実効ユーザ ID がポリシーの変更対象スレッド (I<pid> で指定されたスレッド) の実"
"ユーザ ID か実効ユーザ ID と 一致する場合だけである。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:337
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged thread's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""
"Linux 2.6.12 以降では、リソース制限 B<RLIMIT_RTPRIO> が定義されており、 スケ"
"ジューリング・ポリシーが B<SCHED_RR> と B<SCHED_FIFO> の場合の、非特権スレッ"
"ドの静的優先度の上限を定めている。 スケジューリング・ポリシーと優先度を変更す"
"る際のルールは以下の通りである。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:345
msgid ""
"If an unprivileged thread has a nonzero B<RLIMIT_RTPRIO> soft limit, then it "
"can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""
"非特権スレッドに 0 以外の B<RLIMIT_RTPRIO> ソフト・リミットが設定されている場"
"合、 非特権スレッドはそのスレッドのスケジューリング・ポリシーと優先度を 変更"
"できるが、優先度を現在の自身の優先度と B<RLIMIT_RTPRIO> ソフト・リミットの大"
"きい方よりも高い値に設定できないという制限が課される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:350
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""
"B<RLIMIT_RTPRIO> ソフト・リミットが 0 の場合、優先度を下げるか、 リアルタイム"
"でないポリシーへ切り替えるかの変更だけが許可される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:355
msgid ""
"Subject to the same rules, another unprivileged thread can also make these "
"changes, as long as the effective user ID of the thread making the change "
"matches the real or effective user ID of the target thread."
msgstr ""
"ある非特権スレッドが別のスレッドに対してこれらの変更を行う際にも、 同じルール"
"が適用される。変更を行えるのは、変更を行おうとするスレッド の実効ユーザ ID が"
"変更対象のスレッドの実ユーザ ID か実効ユーザ ID と 一致している場合に限られ"
"る。"

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:373
msgid ""
"Special rules apply for the B<SCHED_IDLE>.  In Linux kernels before 2.6.39, "
"an unprivileged thread operating under this policy cannot change its policy, "
"regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In Linux "
"kernels since 2.6.39, an unprivileged thread can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_NORMAL> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""
"B<SCHED_IDLE> の場合には特別なルールが適用される。 2.6.39 より前の Linux カー"
"ネルでは、このポリシーで動作する非特権スレッドは、 B<RLIMIT_RTPRIO> リソース"
"上限の値に関わらず、自分のポリシーを変更することができない。 2.6.39 以降の "
"Linux カーネルでは、非特権スレッドは、自分の nice 値が B<RLIMIT_NICE> リソー"
"ス上限 (B<getrlimit>(2) 参照) で許可された範囲である限りは、自分のスケジュー"
"リング・ポリシーを B<SCHED_BATCH> か B<SCHED_NORMAL> ポリシーに切り替えること"
"ができる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:384
msgid ""
"Privileged (B<CAP_SYS_NICE>)  threads ignore the B<RLIMIT_RTPRIO> limit; as "
"with older kernels, they can make arbitrary changes to scheduling policy and "
"priority.  See B<getrlimit>(2)  for further information on B<RLIMIT_RTPRIO>."
msgstr ""
"特権スレッド (B<CAP_SYS_NICE> ケーパビリティを持つスレッド) の場合、 "
"B<RLIMIT_RTPRIO> の制限は無視される; 古いカーネルと同じように、スケジューリン"
"グ・ポリシーと優先度に対し 任意の変更を行うことができる。 B<RLIMIT_RTPRIO> に"
"関するもっと詳しい情報は B<getrlimit>(2)  を参照のこと。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:384
#, no-wrap
msgid "Response time"
msgstr "応答時間 (response time)"

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:392
msgid ""
"A blocked high priority thread waiting for the I/O has a certain response "
"time before it is scheduled again.  The device driver writer can greatly "
"reduce this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""
"I/O 待ちで停止したより高い優先度のスレッドは再びスケジューリングされる 前にい"
"くらかの応答時間がかかる。デバイス・ドライバーを書く場合には \"slow interrupt"
"\" 割り込みハンドラーを使用することで この応答時間を劇的に減少させることがで"
"きる。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:392
#, no-wrap
msgid "Miscellaneous"
msgstr "その他"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:397
msgid ""
"Child processes inherit the scheduling policy and parameters across a B<fork>"
"(2).  The scheduling policy and parameters are preserved across B<execve>(2)."
msgstr ""
"子プロセスは B<fork>(2)  の際に親プロセスのスケジューリング・ポリシーとパラ"
"メータを継承する。 B<execve>(2)  の前後で、スケジューリング・ポリシーとパラ"
"メータは保持される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:403
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""
"リアルタイム・プロセスは大抵、ページングの待ち時間を避けるために B<mlock>"
"(2)  や B<mlockall>(2)  を使ってメモリ・ロックをしなければならない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:415
msgid ""
"Since a nonblocking infinite loop in a thread scheduled under B<SCHED_FIFO> "
"or B<SCHED_RR> will block all threads with lower priority forever, a "
"software developer should always keep available on the console a shell "
"scheduled under a higher static priority than the tested application.  This "
"will allow an emergency kill of tested real-time applications that do not "
"block or terminate as expected.  See also the description of the "
"B<RLIMIT_RTTIME> resource limit in B<getrlimit>(2)."
msgstr ""
"B<SCHED_FIFO> や B<SCHED_RR> でスケジューリングされる スレッドが停止せずに無"
"限ループに陥ると、 他の全てのより低い優先度のスレッドを永久に停止 (block) さ"
"せてしまうので、 ソフトウェア開発者はコンソールのシェルの静的優先度をテストす"
"る アプリケーションよりも常に高く保つべきである。 これによって期待通りに停止"
"したり終了したりしないリアルタイム・ アプリケーションを緊急終了させることが可"
"能になる。 B<getrlimit>(2)  のリソース制限 B<RLIMIT_RTTIME> の説明も参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:423
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムでは I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が"
"定義されている場合にのみ B<sched_setscheduler>()  と B<sched_getscheduler>"
"()  が使用できる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:433
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the thread (a nonnegative "
"integer).  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<sched_setscheduler>()  は 0 を返す。 成功した場合、 "
"B<sched_getscheduler>()  は現在のそのスレッドのポリシー (非負の整数) を返"
"す。 エラーの場合、-1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:439
msgid ""
"The scheduling I<policy> is not one of the recognized policies, I<param> is "
"NULL, or I<param> does not make sense for the I<policy>."
msgstr ""
"スケジューリング・ポリシー I<policy> が間違っている。\n"
"または I<param> が NULL である。\n"
"または I<param> がそのポリシーでは意味をなさない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:442
msgid "The calling thread does not have appropriate privileges."
msgstr "呼び出したスレッドが適切な特権を持っていない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:448
msgid ""
"POSIX.1-2001 (but see BUGS below).  The B<SCHED_BATCH> and B<SCHED_IDLE> "
"policies are Linux-specific."
msgstr ""
"POSIX.1-2001 (但し、下記のバグの節も参照)。 B<SCHED_BATCH> と B<SCHED_IDLE> "
"ポリシーは Linux 固有である。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:456
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged thread requires "
"in order to call B<sched_setscheduler>(), and details vary across systems.  "
"For example, the Solaris 7 manual page says that the real or effective user "
"ID of the caller must match the real user ID or the save set-user-ID of the "
"target."
msgstr ""
"POSIX.1 は、非特権スレッドが B<sched_setscheduler>()  を呼び出すために必要な"
"権限の詳細を規定しておらず、 詳細はシステムにより異なる。 例えば、Solaris 7 "
"のマニュアルページでは、 呼び出し元の実ユーザ ID または実効ユーザ ID が 設定"
"対象の実ユーザ ID か保存 (save) set-user-ID と 一致していなければならない、と"
"なっている。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:477
msgid ""
"The scheduling policy and parameters are in fact per-thread attributes on "
"Linux.  The value returned from a call to B<gettid>(2)  can be passed in the "
"argument I<pid>.  Specifying I<pid> as 0 will operate on the attribute for "
"the calling thread, and passing the value returned from a call to B<getpid>"
"(2)  will operate on the attribute for the main thread of the thread group.  "
"(If you are using the POSIX threads API, then use B<pthread_setschedparam>"
"(3), B<pthread_getschedparam>(3), and B<pthread_setschedprio>(3), instead of "
"the B<sched_*>(2)  system calls.)"
msgstr ""
"Linux では、 スケジューリングポリシーとスケジューリングパラメータは、 実際に"
"はスレッド単位の属性である。 B<gettid>(2) の呼び出しの返り値をこのシステム"
"コールの I<pid> 引き数として渡すことができる。 I<pid> に 0 を指定すると、 呼"
"び出し元のスレッドの属性が設定される。 B<getpid>(2) コールからの返り値を "
"I<pid> に指定すると、 スレッドグループのメインスレッドの属性が設定される "
"(POSIX スレッド API を使用している場合は、 B<sched_*>(2) システムコールの代わ"
"りに B<pthread_setschedparam>(3), B<pthread_getschedparam>(3), and "
"B<pthread_setschedprio>(3) を使用すること)。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:487
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""
"もともとは、標準の Linux は一般目的のオペレーティングシステムとして 設計され"
"ており、バックグラウンド・プロセスや対話的アプリケーション、 リアルタイム性の"
"要求が厳しくないリアルタイム・アプリケーション (普通はタイミングの応答期限 "
"(deadline) を満たす必要があるアプリケーション)  を扱うことができた。 Linux "
"カーネル 2.6 では、 カーネルのプリエンプション (タスクの置き換え) が可能であ"
"り、 新たに導入された O(1) スケジューラにより、 アクティブなタスクの数に関わ"
"らずスケジューリングに必要な時間は 固定で確定的 (deterministic) であることが"
"保証されている。 それにも関わらず、カーネル 2.6.17 までは 真のリアルタイム・"
"コンピューティングは実現できなかった。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:487
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr "本流の Linux カーネルでのリアルタイム機能"

#.  FIXME . Probably this text will need some minor tweaking
#.  by about the time of 2.6.30; ask Carsten Emde about this then.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:501
msgid ""
"From kernel version 2.6.18 onward, however, Linux is gradually becoming "
"equipped with real-time capabilities, most of which are derived from the "
"former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
"Gleixner, Steven Rostedt, and others.  Until the patches have been "
"completely merged into the mainline kernel (this is expected to be around "
"kernel version 2.6.30), they must be installed to achieve the best real-time "
"performance.  These patches are named:"
msgstr ""
"カーネル 2.6.18 から現在まで、 Linux は徐々にリアルタイム機能を備えつつ\n"
"あるが、 これらの機能のほとんどは、 Ingo Molnar, Thomas Gleixner,\n"
"Steven Rostedt らによって開発された、 以前の I<realtime-preempt> パッチ\n"
"からのものである。 これらのパッチが本流のカーネルに完全にマージされるま\n"
"では (マージの完了はカーネル 2.6.30 あたりの予定)、 最高のリアルタイム\n"
"性能を達成するには realtime-preempt パッチを 組み込まなければならない。\n"
"これらのパッチは"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:505
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr "patch-I<kernelversion>-rtI<patchversion>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:511
msgid ""
"and can be downloaded from E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/"
"kernel\\:/projects\\:/rt/> E<.UE .>"
msgstr ""
"という名前で、 E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/kernel\\:/"
"projects\\:/rt/> E<.UE> からダウンロードできる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:520
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""
"このパッチが適用されず、かつパッチの内容の本流のカーネルへのマージが 完了する"
"までは、カーネルの設定では B<CONFIG_PREEMPT_NONE>, "
"B<CONFIG_PREEMPT_VOLUNTARY>, B<CONFIG_PREEMPT_DESKTOP> の 3つのプリエンプショ"
"ン・クラス (preemption class) だけが提供される。 これらのクラスでは、最悪の場"
"合のスケジューリング遅延がそれぞれ 全く減らない、いくらか減る、かなり減る。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:531
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular real-"
"time operating system.  The FIFO and RR scheduling policies that can be "
"selected using B<sched_setscheduler>()  are then used to run a thread with "
"true real-time priority and a minimum worst-case scheduling latency."
msgstr ""
"パッチが適用された場合、またはパッチの内容の本流のカーネルへのマージが 完了し"
"た後では、上記に加えて設定項目として B<CONFIG_PREEMPT_RT> が利用可能になる。"
"この項目を選択すると、 Linux は通常のリアルタイム・オペレーティングシステムに"
"変身する。 この場合には、 B<sched_setscheduler>()  で選択できる FIFO と RR の"
"スケジューリング・ポリシーは、 真のリアルタイム優先度を持つスレッドを最悪の場"
"合のスケジューリング遅延が 最小となる環境で動作させるために使われることにな"
"る。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:539
msgid ""
"POSIX says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""
"POSIX では、成功時に B<sched_setscheduler>()  は直前のスケジューリング・ポリ"
"シーを返すべきとされている。 Linux の B<sched_setscheduler>()  はこの要求仕様"
"に準拠しておらず、 成功時には常に 0 を返す。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:560
msgid ""
"B<chrt>(1), B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<capabilities>(7), B<cpuset>(7)"
msgstr ""
"B<chrt>(1), B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), "
"B<munlockall>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getparam>(2), "
"B<sched_rr_get_interval>(2), B<sched_setaffinity>(2), B<sched_setparam>(2), "
"B<sched_yield>(2), B<setpriority>(2), B<capabilities>(7), B<cpuset>(7)"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:567
msgid ""
"The Linux kernel source file I<Documentation/scheduler/sched-rt-group.txt>"
msgstr ""
"Linux カーネルソースファイル I<Documentation/scheduler/sched-rt-group.txt>"

#. type: TH
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "SCHED_YIELD"
msgstr "SCHED_YIELD"

#. type: TH
#: build/C/man2/sched_yield.2:29
#, no-wrap
msgid "2008-10-18"
msgstr "2008-10-18"

#. type: Plain text
#: build/C/man2/sched_yield.2:32
msgid "sched_yield - yield the processor"
msgstr "sched_yield - プロセッサーを空け渡す(yield)"

#. type: Plain text
#: build/C/man2/sched_yield.2:36
msgid "B<int sched_yield(void);>"
msgstr "B<int sched_yield(void);>"

#. type: Plain text
#: build/C/man2/sched_yield.2:41
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""
"B<sched_yield>()  を呼び出すことで、呼び出したスレッドが CPU の使用権を手放す"
"ことができる。 そのスレッドは、そのスレッドの静的プライオリティのキューの末尾"
"に 移動し、新しいスレッドが走り始める。"

#. type: Plain text
#: build/C/man2/sched_yield.2:48
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_yield>()  は 0 を返す。 エラーの場合は -1 が返され、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_yield.2:52
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr "Linux の実装では、 B<sched_yield>()  は常に成功する。"

#. type: Plain text
#: build/C/man2/sched_yield.2:59
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""
"B<sched_yield>()  を呼び出した時点で最大優先度のリストの中に呼び出し元のス"
"レッドしか 存在しなければ、そのスレッドは呼び出し後も走り続けることになる。"

#. type: Plain text
#: build/C/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムで B<sched_yield>()  は I<E<lt>unistd.hE<gt>> に "
"B<_POSIX_PRIORITY_SCHEDULING> が定義されている場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources (e."
"g., mutexes)  have been released by the caller.  Avoid calling B<sched_yield>"
"()  unnecessarily or inappropriately (e.g., when resources needed by other "
"schedulable threads are still held by the caller), since doing so will "
"result in unnecessary context switches, which will degrade system "
"performance."
msgstr ""
"B<sched_yield>()  を戦略的に呼び出すことで、(極度に) 競合するリソース (mutex "
"など)  を呼び出し元が解放した際に他のスレッドやプロセスに実行機会を与えること"
"で、 性能を上げることができる。 B<sched_yield>()  を必要もないのに呼び出した"
"り、不適切な場面 (例えば、他のスケジューリング 対象となるスレッドが必要とする"
"リソースを呼び出し元が保持したままの状態)  で呼び出したりするのは避けること。"
"なぜなら、 B<sched_yield>()  の呼び出しより不必要なコンテキストスイッチが起こ"
"り、システム性能が 劣化する結果になるからである。"

#. type: Plain text
#: build/C/man2/sched_yield.2:82
msgid "B<sched_setscheduler>(2)  for a description of Linux scheduling"
msgstr ""
"Linux のスケージュリング (scheduling) については B<sched_setscheduler>(2) を"
"参照。"

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "SETNS"
msgstr "SETNS"

#. type: TH
#: build/C/man2/setns.2:8
#, no-wrap
msgid "2013-01-01"
msgstr "2013-01-01"

#. type: Plain text
#: build/C/man2/setns.2:11
msgid "setns - reassociate thread with a namespace"
msgstr "setns - スレッドに名前空間を関連付けしなおす"

#. type: Plain text
#: build/C/man2/setns.2:17
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"

#. type: Plain text
#: build/C/man2/setns.2:21
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""
"名前空間を参照するファイルディスクリプタを指定すると、\n"
"呼び出したスレッドにその名前空間を関連付けしなおす。"

#. type: Plain text
#: build/C/man2/setns.2:34
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<proc>(5)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""
"I<fd> 引き数は、 I</proc/[pid]/ns/> ディレクトリ内の名前空間エントリ\n"
"のいずれかを参照するファイルディスクリプタである。\n"
"I</proc/[pid]/ns/> の詳細は B<proc>(5) を参照。\n"
"I<nstype> 引き数で指定された制限の範囲内で、\n"
"呼び出したスレッドに I<fd> に対応する名前空間を関連付けしなおす。"

#. type: Plain text
#: build/C/man2/setns.2:40
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""
"I<nstype> 引き数は、呼び出したスレッドがどのタイプの名前空間を\n"
"関連付けしなおすことができるかを指定する。\n"
"この引き数には以下のいずれかの値を指定できる。"

#. type: TP
#: build/C/man2/setns.2:40
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: build/C/man2/setns.2:43
msgid "Allow any type of namespace to be joined."
msgstr "どのタイプの名前空間も関連付けることができる。"

#. type: TP
#: build/C/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWIPC>"
msgstr "B<CLONE_NEWIPC>"

#. type: Plain text
#: build/C/man2/setns.2:47
msgid "I<fd> must refer to an IPC namespace."
msgstr "I<fd> は IPC 名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWNET>"
msgstr "B<CLONE_NEWNET>"

#. type: Plain text
#: build/C/man2/setns.2:51
msgid "I<fd> must refer to a network namespace."
msgstr "I<fd> はネットワーク名前空間を参照していなければならない。"

#. type: TP
#: build/C/man2/setns.2:51
#, no-wrap
msgid "B<CLONE_NEWUTS>"
msgstr "B<CLONE_NEWUTS>"

#. type: Plain text
#: build/C/man2/setns.2:55
msgid "I<fd> must refer to a UTS namespace."
msgstr "I<fd> は UTS 名前空間を参照していなければならない。"

#. type: Plain text
#: build/C/man2/setns.2:70
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""
"呼び出し側が I<fd> がどのタイプの名前空間を参照しているかを知っている\n"
"(もしくは気にする必要がない) 場合には、 I<nstype> に 0 を指定すれば十分\n"
"である。呼び出し側が I<fd> がどのタイプの名前空間を参照しているかを\n"
"知っておらず、かつ、特定のタイプの名前空間であることを保証したい場合、\n"
"I<nstype> に 0 以外の値を指定するとよい。 (ファイルディスクリプタが別の\n"
"プロセスによりオープンされ、例えば、UNIX ドメインソケット経由で呼び出し\n"
"側に渡された場合などでは、呼び出し側が I<fd> がどのタイプの名前空間を\n"
"参照しているかを知らない可能性がある。)"

#. type: Plain text
#: build/C/man2/setns.2:77
msgid ""
"On success, I<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""
"成功すると I<setns>() は 0 を返す。\n"
"失敗すると、 -1 が返され、 I<errno> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/setns.2:82
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプタではない。"

#. type: Plain text
#: build/C/man2/setns.2:89
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>, or there is problem with reassociating the the thread with the "
"specified namespace."
msgstr ""
"I<fd> が I<nstype> で指定されたタイプと一致しない名前空間を参照している。\n"
"または、指定された名前空間をそのスレッドに関連付けし直す際に問題\n"
"があった。"

#. type: Plain text
#: build/C/man2/setns.2:92
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr "指定された名前空間に変更するのに必要なメモリが割り当てられない。"

#. type: Plain text
#: build/C/man2/setns.2:97
msgid ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."
msgstr ""
"呼び出したスレッドがこの操作を行うのに必要な特権 (B<CAP_SYS_ADMIN>) を\n"
"持っていなかった。"

#. type: Plain text
#: build/C/man2/setns.2:102
msgid ""
"The B<setns>()  system call first appeared in Linux in kernel 3.0; library "
"support was added to glibc in version 2.14."
msgstr ""
"B<setns>() システムコールはカーネル 3.0 で Linux に初めて登場した。\n"
"ライブラリによるサポートは glibc バージョン 2.14 を追加された。"

#. type: Plain text
#: build/C/man2/setns.2:106
msgid "The B<setns>()  system call is Linux-specific."
msgstr "B<setns>() システムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/setns.2:112
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""
"新しいスレッドが B<clone>(2) を使って作成された際に共有できる全ての属性を、\n"
"B<setns>() を使って変更できるわけではない。"

#. type: Plain text
#: build/C/man2/setns.2:121
msgid ""
"The program below takes two or more arguments.  The first argument specifies "
"the pathname of a namespace file in an existing I</proc/[pid]/ns/> "
"directory.  The remaining arguments specify a command and its arguments.  "
"The program opens the namespace file, joins that namespace using B<setns>(), "
"and executes the specified command inside that namespace."
msgstr ""
"以下のプログラムは 2 つ以上の引き数を取る。 最初の引き数には、 既存の I</"
"proc/[pid]/ns/> ディレクトリの名前空間ファイルのパス名を指定する。 残りの引き"
"数は、コマンドとその引き数を指定する。 このプログラムは名前空間ファイルをオー"
"プンし、 B<setns>() を使って名前空間に参加し、 指定されたコマンドをその名前空"
"間内で実行する。"

#. type: Plain text
#: build/C/man2/setns.2:131
msgid ""
"The following shell session demonstrates the use of this program (compiled "
"as a binary named I<ns_exec>)  in conjunction with the B<CLONE_NEWUTS> "
"example program in the B<clone>(2)  man page (complied as a binary named "
"I<newuts>)."
msgstr ""
"以下のシェルセッションでは、 このプログラム (I<ns_exec> という名前のバイナリ"
"としてコンパイルされている)を、 B<clone>(2) のマニュアルページの "
"B<CLONE_NEWUTS> のサンプルプログラムと組み合わせて使っている。"

#. type: Plain text
#: build/C/man2/setns.2:139
msgid ""
"We begin by executing the example program in B<clone>(2)  in the "
"background.  That program creates a child in a separate UTS namespace.  The "
"child changes the hostname in its namespace, and then both processes display "
"the hostnames in their UTS namespaces, so that we can see that they are "
"different."
msgstr ""
"まず、 B<clone>(2) のサンプルプログラムをバックグラウンドで実行する。 このプ"
"ログラムは、 別の UTS 名前空間で子プロセスを作成する。 子プロセスは自分の名前"
"空間内でホスト名を変更する。 それから、 親プロセスと子プロセスの両方でそれぞ"
"れの UTS 名前空間のホスト名を表示し、 2 つのホスト名が違うことが確認できる。"

#. type: Plain text
#: build/C/man2/setns.2:151
#, no-wrap
msgid ""
"$ B<su>                   # Need privilege for namespace operations\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # Verify hostname in the shell\n"
"antero\n"
msgstr ""
"$ B<su>                   # 名前空間の操作には特権が必要\n"
"Password:\n"
"# B<./newuts bizarro &>\n"
"[1] 3549\n"
"clone() returned 3550\n"
"uts.nodename in child:  bizarro\n"
"uts.nodename in parent: antero\n"
"# B<uname -n>             # シェルでホスト名を確認\n"
"antero\n"

#. type: Plain text
#: build/C/man2/setns.2:158
msgid ""
"We then run the program shown below, using it to execute a shell.  Inside "
"that shell, we verify that the hostname is the one set by the child created "
"by the first program:"
msgstr ""
"次に、以下のプログラムを使ってシェルを実行する。 このシェルの中では、ホスト名"
"が最初のプログラムで作成された子プロセスが設定したホスト名になっていることを"
"確認できる。"

#. type: Plain text
#: build/C/man2/setns.2:164
#, no-wrap
msgid ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             # Executed in shell started by ns_exec\n"
"bizarro\n"
msgstr ""
"# B<./ns_exec /proc/3550/ns/uts /bin/bash>\n"
"# B<uname -n>             #  ns_exec で起動されたシェル内で実行\n"
"bizarro\n"

#. type: Plain text
#: build/C/man2/setns.2:174
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>fcntl.hE<gt>\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/setns.2:182
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int fd;\n"

#. type: Plain text
#: build/C/man2/setns.2:187
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/setns.2:191
#, no-wrap
msgid ""
"    fd = open(argv[1], O_RDONLY);   /* Get descriptor for namespace */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"
msgstr ""
"    fd = open(argv[1], O_RDONLY);   /* 名前空間のディスクリプタを取得 */\n"
"    if (fd == -1)\n"
"        errExit(\"open\");\n"

#. type: Plain text
#: build/C/man2/setns.2:194
#, no-wrap
msgid ""
"    if (setns(fd, 0) == -1)         /* Join that namespace */\n"
"        errExit(\"setns\");\n"
msgstr ""
"    if (setns(fd, 0) == -1)         /* 名前空間に参加 */\n"
"        errExit(\"setns\");\n"

#. type: Plain text
#: build/C/man2/setns.2:198
#, no-wrap
msgid ""
"    execvp(argv[2], &argv[2]);      /* Execute a command in namespace */\n"
"    errExit(\"execvp\");\n"
"}\n"
msgstr ""
"    execvp(argv[2], &argv[2]);      /* 名前空間内でコマンドを実行 */\n"
"    errExit(\"execvp\");\n"
"}\n"

#. type: Plain text
#: build/C/man2/setns.2:205
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"
msgstr "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"

#. type: TH
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "UNSHARE"
msgstr "UNSHARE"

#. type: Plain text
#: build/C/man2/unshare.2:23
msgid "unshare - disassociate parts of the process execution context"
msgstr "unshare - プロセス実行コンテキストの一部を分離する"

#. type: Plain text
#: build/C/man2/unshare.2:28
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr "B<int unshare(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/unshare.2:36
msgid "B<unshare>():"
msgstr "B<unshare>():"

#. type: Plain text
#: build/C/man2/unshare.2:62
msgid ""
"B<unshare>()  allows a process to disassociate parts of its execution "
"context that are currently being shared with other processes.  Part of the "
"execution context, such as the mount namespace, is shared implicitly when a "
"new process is created using B<fork>(2)  or B<vfork>(2), while other parts, "
"such as virtual memory, may be shared by explicit request when creating a "
"process using B<clone>(2)."
msgstr ""
"B<unshare>()  を使うと、プロセスは他のプロセスと現在共有している 実行コンテキ"
"ストの一部を分離することができる。 実行コンテキストの一部、たとえばマウント名"
"前空間 (mount namespace)  などは、新しいプロセスを B<fork>(2)  または "
"B<vfork>(2)  を使って生成したときに、暗黙のうちに共有される。 一方、仮想メモ"
"リなどは、 B<clone>(2)  を使ってプロセスを生成するときに、明示的に共有するこ"
"とを要求できる。"

#. type: Plain text
#: build/C/man2/unshare.2:67
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""
"B<unshare>()  の主な利用法は、プロセスが新しいプロセスを生成することなく、 共"
"有実行コンテキストを制御することである。"

#. type: Plain text
#: build/C/man2/unshare.2:74
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""
"I<flags> 引き数はビットマスクであり、 実行コンテキストのどの部分の共有を解除"
"するかを表す。 この引き数は、以下の定数の 0 個以上の OR で指定する:"

#. type: TP
#: build/C/man2/unshare.2:74
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr "B<CLONE_FILES>"

#. type: Plain text
#: build/C/man2/unshare.2:82
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""
"B<clone>(2)  B<CLONE_FILES> フラグの効果を取り消す。 ファイルディスクリプタ"
"テーブルを共有させず、 呼び出し元プロセスは他のプロセスとファイルディスクリプ"
"タを共有しなくなる。"

#. type: TP
#: build/C/man2/unshare.2:82
#, no-wrap
msgid "B<CLONE_FS>"
msgstr "B<CLONE_FS>"

#. type: Plain text
#: build/C/man2/unshare.2:96
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare filesystem "
"attributes, so that the calling process no longer shares its root directory "
"(B<chroot>(2)), current directory (B<chdir>(2)), or umask (B<umask>(2))  "
"attributes with any other process."
msgstr ""
"B<clone>(2)  B<CLONE_FS> フラグの効果を取り消す。ファイルシステム属性を共有さ"
"せず、呼び出し元プロセスは、ルートディレクトリ (B<chroot>(2))、カレントディレ"
"クトリ (B<chdir>(2))、 umask (B<umask>(2)) を他のプロセスと共有しなくなる。"

#. type: Plain text
#: build/C/man2/unshare.2:113
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the System V IPC namespace, so that the calling process has a "
"private copy of the System V IPC namespace which is not shared with any "
"other process.  Specifying this flag automatically implies B<CLONE_SYSVSEM> "
"as well.  Use of B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWIPC> フラグと同じ効果を持つ。\n"
"System V IPC 名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは\n"
"共有しない固有の System V IPC 名前空間のコピーを持つ。 このフラグを指定\n"
"すると、 B<CLONE_SYSVSEM> も暗黙のうちに指定される。 B<CLONE_NEWIPC> を\n"
"使用するには B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/unshare.2:128
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  Use of B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWNET> フラグと同じ効果を持つ。ネット\n"
"ワーク名前空間を共有せず、呼び出し元プロセスは他のプロセスとは共有しな\n"
"い固有のネットワーク名前空間のコピーを持つ。B<CLONE_NEWNET> を使用する\n"
"には B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: TP
#: build/C/man2/unshare.2:128
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr "B<CLONE_NEWNS>"

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: build/C/man2/unshare.2:149
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWNS> フラグと同じ効果を持つ。 マウン\n"
"ト名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固\n"
"有の名前空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗\n"
"黙のうちに指定される。 B<CLONE_NEWNS> を使用するには B<CAP_SYS_ADMIN>\n"
"ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/unshare.2:163
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_NEWUTS> フラグと同じ効果を持つ。 UTS\n"
"IPC 名前空間を共有せず、呼び出し元プロセスは他のプロセスとは共有しない\n"
"固有の UTS IPC 名前空間のコピーを持つ。 このフラグを指定すると、\n"
"B<CLONE_FS> も暗黙のうちに指定される。B<CLONE_NEWUTS> を使用するには\n"
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: TP
#: build/C/man2/unshare.2:163
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr "B<CLONE_SYSVSEM> (Linux 2.6.26 以降)"

#.  commit 9edff4ab1f8d82675277a04e359d0ed8bf14a7b7
#.  As at 2.6.16, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  CLONE_NEWNSIf CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#.  FIXME . CLONE_VM is not (yet, as at 2.6.16) implemented.
#.  .TP
#.  .B CLONE_VM
#.  Reverse the effect of the
#.  .BR clone (2)
#.  .B CLONE_VM
#.  flag.
#.  .RB ( CLONE_VM
#.  is also implicitly set by
#.  .BR vfork (2),
#.  and can be reversed using this
#.  .BR unshare ()
#.  flag.)
#.  Unshare virtual memory, so that the calling process no
#.  longer shares its virtual address space with any other process.
#. type: Plain text
#: build/C/man2/unshare.2:200
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System V semaphore undo values, so that the calling process has a "
"private copy which is not shared with any other process.  Use of "
"B<CLONE_SYSVSEM> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2) B<CLONE_SYSVSEM> フラグの効果を逆転させる。\n"
"System V セマフォのアンドゥ値を共有せず、呼び出し元プロセスは 他のプロ\n"
"セスとは共有しない固有のコピーを持つ。B<CLONE_SYSVSEM> を使用するには\n"
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/unshare.2:207
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""
"I<flags> に 0 が指定された場合、 B<unshare>()  は何も行わないので、 呼び出し"
"元プロセスの実行コンテキストは、何も変更されない。"

#. type: Plain text
#: build/C/man2/unshare.2:212
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""
"成功した場合は 0 が返される。 失敗した場合は -1 が返されて、 I<errno> にはエ"
"ラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/unshare.2:217
msgid "An invalid bit was specified in I<flags>."
msgstr "I<flags> に不正なビットが指定された。"

#. type: Plain text
#: build/C/man2/unshare.2:221
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""
"呼び出し元のコンテキストのうち共有を解除する必要がある部分をコピーするため"
"に、 十分なメモリが確保できなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:224
msgid ""
"The calling process did not have the required privileges for this operation."
msgstr "呼び出し元プロセスはこの操作を行うのに必要な特権を持っていなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:228
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr "B<unshare>()  システムコールは Linux カーネル 2.6.16 で追加された。"

#. type: Plain text
#: build/C/man2/unshare.2:232
msgid "The B<unshare>()  system call is Linux-specific."
msgstr "B<unshare>()  システムコールは Linux 固有である。"

#.  FIXME all of the following needs to be reviewed for the current kernel
#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  However, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: build/C/man2/unshare.2:266
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 3.8, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_THREAD>, or B<CLONE_VM>.  "
"Such functionality may be added in the future, if required."
msgstr ""
"B<clone>(2)  で新しいプロセスを生成したときに共有される全てのプロセス属性"
"を、 B<unshare>()  によって共有の解除ができるわけではない。 特に、カーネル "
"3.8 時点では、 B<unshare>()  に B<CLONE_SIGHAND>, B<CLONE_THREAD>, "
"B<CLONE_VM> の効果を取り消すためのフラグが実装されていない。 これらの機能は、"
"必要であれば将来追加されるかもしれない。"

#. type: Plain text
#: build/C/man2/unshare.2:272
msgid "B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), B<vfork>(2)"
msgstr "B<clone>(2), B<fork>(2), B<kcmp>(2), B<setns>(2), B<vfork>(2)"

#. type: Plain text
#: build/C/man2/unshare.2:275
msgid "I<Documentation/unshare.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/unshare.txt>"

#~ msgid "2013-04-16"
#~ msgstr "2013-04-16"

#~ msgid "Create a child that executes in a separate UTS namespace"
#~ msgstr "別の UTS 名前空間で動作する子プロセスを作成する"

#~ msgid "2013-01-27"
#~ msgstr "2013-01-27"

#~ msgid "2006-03-23"
#~ msgstr "2006-03-23"

#~ msgid "2013-02-11"
#~ msgstr "2013-02-11"

#~ msgid ""
#~ "B<clone>()  creates a new process, in a manner similar to B<fork>(2).  It "
#~ "is actually a library function layered on top of the underlying B<clone>"
#~ "()  system call, hereinafter referred to as B<sys_clone>.  A description "
#~ "of B<sys_clone> is given toward the end of this page."
#~ msgstr ""
#~ "B<clone>()  は B<fork>(2)  と同じような方法で新しいプロセスを作成する。 "
#~ "B<clone>()  には、ライブラリ関数とその下層にあたる B<clone>()  システム"
#~ "コールが存在する。以下の説明では、システムコールの方を B<sys_clone> と表す"
#~ "こととする。 B<sys_clone> に関する説明はこのマニュアルの最後の方にある。"

#~ msgid ""
#~ "The B<clone>()  and B<sys_clone> calls are Linux-specific and should not "
#~ "be used in programs intended to be portable."
#~ msgstr ""
#~ "B<clone>()  と B<sys_clone> コールは Linux 特有であり、移植を考慮したプロ"
#~ "グラムでは使用すべき ではない。"

#~ msgid ""
#~ "I<Documentation/scheduler/sched-rt-group.txt> in the Linux kernel source "
#~ "tree (since kernel 2.6.25)."
#~ msgstr ""
#~ "Linux カーネルソース内の I<Documentation/scheduler/sched-rt-group.txt> "
#~ "(カーネル 2.6.25 以降)"

#~ msgid ""
#~ "The PID namespace and the mount namespace are not currently supported.  "
#~ "(See the descriptions of B<CLONE_NEWPID> and B<CLONE_NEWNS> in B<clone>"
#~ "(2).)"
#~ msgstr ""
#~ "現在のところ、 PID 名前空間とマウント名前空間はサポートされていない\n"
#~ "(B<clone>(2) の B<CLONE_NEWPID> と B<CLONE_NEWNS> の説明を参照)。"

#~ msgid ""
#~ "If I<pid> is zero, the time quantum for the calling process is written "
#~ "into I<*tp>.  The identified process should be running under the "
#~ "B<SCHED_RR> scheduling policy.  POSIX systems on which "
#~ "B<sched_rr_get_interval>()  is available define "
#~ "B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
#~ msgstr ""
#~ "I<pid> がゼロの場合、呼び出したプロセスの時間量が I<*tp> に書き込まれる。"
#~ "指定したプロセスは B<SCHED_RR> スケジューリング方針で稼動している必要があ"
#~ "る。 B<sched_rr_get_interval>()  の使用可能な POSIX システムでは "
#~ "I<E<lt>unistd.hE<gt>> で B<_POSIX_PRIORITY_SCHEDULING> が定義されている。"

#~ msgid ""
#~ "I<From Linux 2.6.25 this flag is deprecated.> You probably never wanted "
#~ "to use it, you certainly shouldn't be using it, and soon it will go away."
#~ msgstr ""
#~ "I<Linux 2.6.25 以降、このフラグは非推奨である。> このフラグを使いたいと思"
#~ "うことは決してないだろうし、 確実に使わないようにすべきである。 このフラグ"
#~ "は近いうちになくなることだろう。"

#~ msgid ""
#~ "Special rules apply for the B<SCHED_IDLE>: an unprivileged process "
#~ "operating under this policy cannot change its policy, regardless of the "
#~ "value of its B<RLIMIT_RTPRIO> resource limit."
#~ msgstr ""
#~ "B<SCHED_IDLE> には特別なルールが適用され、 このポリシーの下で動作する非特"
#~ "権プロセスは、リソース制限 B<RLIMIT_RTPRIO> の値にかかわらず自身のポリシー"
#~ "を変更することができない。"

#~ msgid ""
#~ "I<flags> specified B<CLONE_NEWNS> but the calling process was not "
#~ "privileged (did not have the B<CAP_SYS_ADMIN> capability)."
#~ msgstr ""
#~ "I<flags> に B<CLONE_NEWNS> が指定されたが、呼び出し元プロセスに特権 "
#~ "(B<CAP_SYS_ADMIN> ケーパビリティ) がなかった。"

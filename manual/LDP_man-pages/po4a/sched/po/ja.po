# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-19 23:50+0900\n"
"PO-Revision-Date: 2012-03-22 00:51+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/CPU_SET.3:25
#, no-wrap
msgid "CPU_SET"
msgstr "CPU_SET"

#. type: TH
#: build/C/man3/CPU_SET.3:25
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: TH
#: build/C/man3/CPU_SET.3:25 build/C/man2/clone.2:43
#: build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:24
#: build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35
#: build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:47
#: build/C/man2/sched_yield.2:30 build/C/man2/setns.2:4
#: build/C/man2/unshare.2:17
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/CPU_SET.3:25 build/C/man2/clone.2:43
#: build/C/man2/sched_get_priority_max.2:30 build/C/man3/sched_getcpu.3:24
#: build/C/man2/sched_rr_get_interval.2:30 build/C/man2/sched_setaffinity.2:35
#: build/C/man2/sched_setparam.2:31 build/C/man2/sched_setscheduler.2:47
#: build/C/man2/sched_yield.2:30 build/C/man2/setns.2:4
#: build/C/man2/unshare.2:17
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/CPU_SET.3:26 build/C/man2/clone.2:44
#: build/C/man2/sched_get_priority_max.2:31 build/C/man3/sched_getcpu.3:25
#: build/C/man2/sched_rr_get_interval.2:31 build/C/man2/sched_setaffinity.2:36
#: build/C/man2/sched_setparam.2:32 build/C/man2/sched_setscheduler.2:48
#: build/C/man2/sched_yield.2:31 build/C/man2/setns.2:5
#: build/C/man2/unshare.2:18
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/CPU_SET.3:33
msgid ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"
msgstr ""
"CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR, CPU_XOR, "
"CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S, CPU_CLR_S, "
"CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S, CPU_XOR_S, "
"CPU_EQUAL_S - macros for manipulating CPU sets"

#. type: SH
#: build/C/man3/CPU_SET.3:33 build/C/man2/clone.2:46
#: build/C/man2/sched_get_priority_max.2:33 build/C/man3/sched_getcpu.3:27
#: build/C/man2/sched_rr_get_interval.2:33 build/C/man2/sched_setaffinity.2:39
#: build/C/man2/sched_setparam.2:34 build/C/man2/sched_setscheduler.2:51
#: build/C/man2/sched_yield.2:33 build/C/man2/setns.2:7
#: build/C/man2/unshare.2:20
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#.  Actually _BSD_SOURCE || _SVID_SOURCE
#.  See http://sources.redhat.com/bugzilla/show_bug.cgi?id=4749
#. type: Plain text
#: build/C/man3/CPU_SET.3:37 build/C/man2/clone.2:52
#: build/C/man2/sched_setaffinity.2:43 build/C/man2/setns.2:11
#: build/C/man2/unshare.2:26
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:39
#, no-wrap
msgid "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"
msgstr "B<void CPU_ZERO(cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:43
#, no-wrap
msgid ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""
"B<void CPU_SET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET(int >I<cpu>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:45
#, no-wrap
msgid "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"
msgstr "B<int  CPU_COUNT(cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:52
#, no-wrap
msgid ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""
"B<void CPU_AND(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR(cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:54
#, no-wrap
msgid "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr "B<int  CPU_EQUAL(cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:58
#, no-wrap
msgid ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"
msgstr ""
"B<cpu_set_t *CPU_ALLOC(int >I<num_cpus>B<);>\n"
"B<void CPU_FREE(cpu_set_t *>I<set>B<);>\n"
"B<size_t CPU_ALLOC_SIZE(int >I<num_cpus>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:60
#, no-wrap
msgid "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr "B<void CPU_ZERO_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:64
#, no-wrap
msgid ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr ""
"B<void CPU_SET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<void CPU_CLR_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
"B<int  CPU_ISSET_S(int >I<cpu>B<, size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:66
#, no-wrap
msgid "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"
msgstr "B<int  CPU_COUNT_S(size_t >I<setsize>B<, cpu_set_t *>I<set>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:73
#, no-wrap
msgid ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
msgstr ""
"B<void CPU_AND_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_OR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"
"B<void CPU_XOR_S(size_t >I<setsize>B<, cpu_set_t *>I<destset>B<,>\n"
"B<             cpu_set_t *>I<srcset1>B<, cpu_set_t *>I<srcset2>B<);>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:76
#, no-wrap
msgid "B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"
msgstr "B<int  CPU_EQUAL_S(size_t >I<setsize>B<, cpu_set_t *>I<set1>B<, cpu_set_t *>I<set2>B<);>\n"

#. type: SH
#: build/C/man3/CPU_SET.3:77 build/C/man2/clone.2:58
#: build/C/man2/sched_get_priority_max.2:39 build/C/man3/sched_getcpu.3:35
#: build/C/man2/sched_rr_get_interval.2:37 build/C/man2/sched_setaffinity.2:50
#: build/C/man2/sched_setparam.2:48 build/C/man2/sched_setscheduler.2:67
#: build/C/man2/sched_yield.2:37 build/C/man2/setns.2:14
#: build/C/man2/unshare.2:29
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/CPU_SET.3:84
msgid ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."
msgstr ""
"The I<cpu_set_t> data structure represents a set of CPUs.  CPU sets are used "
"by B<sched_setaffinity>(2)  and similar interfaces."

#. type: Plain text
#: build/C/man3/CPU_SET.3:91
msgid ""
"The I<cpu_set_t> data type is implemented as a bitset.  However, the data "
"structure treated as considered opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."
msgstr ""
"The I<cpu_set_t> data type is implemented as a bitset.  However, the data "
"structure treated as considered opaque: all manipulation of CPU sets should "
"be done via the macros described in this page."

#. type: Plain text
#: build/C/man3/CPU_SET.3:94
msgid "The following macros are provided to operate on the CPU set I<set>:"
msgstr "The following macros are provided to operate on the CPU set I<set>:"

#. type: TP
#: build/C/man3/CPU_SET.3:94
#, no-wrap
msgid "B<CPU_ZERO>()"
msgstr "B<CPU_ZERO>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:99
msgid "Clears I<set>, so that it contains no CPUs."
msgstr "Clears I<set>, so that it contains no CPUs."

#. type: TP
#: build/C/man3/CPU_SET.3:99
#, no-wrap
msgid "B<CPU_SET>()"
msgstr "B<CPU_SET>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:105
msgid "Add CPU I<cpu> to I<set>."
msgstr "Add CPU I<cpu> to I<set>."

#. type: TP
#: build/C/man3/CPU_SET.3:105
#, no-wrap
msgid "B<CPU_CLR>()"
msgstr "B<CPU_CLR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:111
msgid "Remove CPU I<cpu> from I<set>."
msgstr "Remove CPU I<cpu> from I<set>."

#. type: TP
#: build/C/man3/CPU_SET.3:111
#, no-wrap
msgid "B<CPU_ISSET>()"
msgstr "B<CPU_ISSET>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:117
msgid "Test to see if CPU I<cpu> is a member of I<set>."
msgstr "Test to see if CPU I<cpu> is a member of I<set>."

#. type: TP
#: build/C/man3/CPU_SET.3:117
#, no-wrap
msgid "B<CPU_COUNT>()"
msgstr "B<CPU_COUNT>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:121
msgid "Return the number of CPUs in I<set>."
msgstr "Return the number of CPUs in I<set>."

#. type: Plain text
#: build/C/man3/CPU_SET.3:126
msgid ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."
msgstr ""
"Where a I<cpu> argument is specified, it should not produce side effects, "
"since the above macros may evaluate the argument more than once."

#. type: Plain text
#: build/C/man3/CPU_SET.3:137
msgid ""
"The first available CPU on the system corresponds to a I<cpu> value of 0, "
"the next CPU corresponds to a I<cpu> value of 1, and so on.  The constant "
"B<CPU_SETSIZE> (currently 1024) specifies a value one greater than the "
"maximum CPU number that can be stored in I<cpu_set_t>."
msgstr ""
"The first available CPU on the system corresponds to a I<cpu> value of 0, "
"the next CPU corresponds to a I<cpu> value of 1, and so on.  The constant "
"B<CPU_SETSIZE> (currently 1024) specifies a value one greater than the "
"maximum CPU number that can be stored in I<cpu_set_t>."

#. type: Plain text
#: build/C/man3/CPU_SET.3:139
msgid "The following macros perform logical operations on CPU sets:"
msgstr "The following macros perform logical operations on CPU sets:"

#. type: TP
#: build/C/man3/CPU_SET.3:139
#, no-wrap
msgid "B<CPU_AND>()"
msgstr "B<CPU_AND>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:148
msgid ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."
msgstr ""
"Store the intersection of the sets I<srcset1> and I<srcset2> in I<destset> "
"(which may be one of the source sets)."

#. type: TP
#: build/C/man3/CPU_SET.3:148
#, no-wrap
msgid "B<CPU_OR>()"
msgstr "B<CPU_OR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:157
msgid ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."
msgstr ""
"Store the union of the sets I<srcset1> and I<srcset2> in I<destset> (which "
"may be one of the source sets)."

#. type: TP
#: build/C/man3/CPU_SET.3:157
#, no-wrap
msgid "B<CPU_XOR>()"
msgstr "B<CPU_XOR>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:171
msgid ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."
msgstr ""
"Store the XOR of the sets I<srcset1> and I<srcset2> in I<destset> (which may "
"be one of the source sets).  The XOR means the set of CPUs that are in "
"either I<srcset1> or I<srcset2>, but not both."

#. type: TP
#: build/C/man3/CPU_SET.3:171
#, no-wrap
msgid "B<CPU_EQUAL>()"
msgstr "B<CPU_EQUAL>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:174
msgid "Test whether two CPU set contain exactly the same CPUs."
msgstr "Test whether two CPU set contain exactly the same CPUs."

#. type: SS
#: build/C/man3/CPU_SET.3:174
#, no-wrap
msgid "Dynamically sized CPU sets"
msgstr "Dynamically sized CPU sets"

#. type: Plain text
#: build/C/man3/CPU_SET.3:180
msgid ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."
msgstr ""
"Because some applications may require the ability to dynamically size CPU "
"sets (e.g., to allocate sets larger than that defined by the standard "
"I<cpu_set_t> data type), glibc nowadays provides a set of macros to support "
"this."

#. type: Plain text
#: build/C/man3/CPU_SET.3:182
msgid "The following macros are used to allocate and deallocate CPU sets:"
msgstr "The following macros are used to allocate and deallocate CPU sets:"

#. type: TP
#: build/C/man3/CPU_SET.3:182
#, no-wrap
msgid "B<CPU_ALLOC>()"
msgstr "B<CPU_ALLOC>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:187
msgid ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to I<num_cpus-1>."
msgstr ""
"Allocate a CPU set large enough to hold CPUs in the range 0 to I<num_cpus-1>."

#. type: TP
#: build/C/man3/CPU_SET.3:187
#, no-wrap
msgid "B<CPU_ALLOC_SIZE>()"
msgstr "B<CPU_ALLOC_SIZE>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:197
msgid ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described below."
msgstr ""
"Return the size in bytes of the CPU set that would be needed to hold CPUs in "
"the range 0 to I<num_cpus-1>.  This macro provides the value that can be "
"used for the I<setsize> argument in the B<CPU_*_S>()  macros described below."

#. type: TP
#: build/C/man3/CPU_SET.3:197
#, no-wrap
msgid "B<CPU_FREE>()"
msgstr "B<CPU_FREE>()"

#. type: Plain text
#: build/C/man3/CPU_SET.3:201
msgid "Free a CPU set previously allocated by B<CPU_ALLOC>()."
msgstr "Free a CPU set previously allocated by B<CPU_ALLOC>()."

#. type: Plain text
#: build/C/man3/CPU_SET.3:208
msgid ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."
msgstr ""
"The macros whose names end with \"_S\" are the analogs of the similarly "
"named macros without the suffix.  These macros perform the same tasks as "
"their analogs, but operate on the dynamically allocated CPU set(s) whose "
"size is I<setsize> bytes."

#. type: SH
#: build/C/man3/CPU_SET.3:208 build/C/man2/clone.2:791
#: build/C/man2/sched_get_priority_max.2:87 build/C/man3/sched_getcpu.3:38
#: build/C/man2/sched_rr_get_interval.2:72
#: build/C/man2/sched_setaffinity.2:108 build/C/man2/sched_setparam.2:88
#: build/C/man2/sched_setscheduler.2:423 build/C/man2/sched_yield.2:42
#: build/C/man2/setns.2:66 build/C/man2/unshare.2:183
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/CPU_SET.3:217
msgid ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."
msgstr ""
"B<CPU_ISSET>()  and B<CPU_ISSET_S>()  return nonzero if I<cpu> is in I<set>; "
"otherwise, it returns 0."

#. type: Plain text
#: build/C/man3/CPU_SET.3:223
msgid ""
"B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."
msgstr ""
"B<CPU_COUNT>()  and B<CPU_COUNT_S>()  return the number of CPUs in I<set>."

#. type: Plain text
#: build/C/man3/CPU_SET.3:228
msgid ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise it returns 0."
msgstr ""
"B<CPU_EQUAL>()  and B<CPU_EQUAL_S>()  return nonzero if the two CPU sets are "
"equal; otherwise it returns 0."

#. type: Plain text
#: build/C/man3/CPU_SET.3:233
msgid ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"
msgstr ""
"B<CPU_ALLOC>()  returns a pointer on success, or NULL on failure.  (Errors "
"are as for B<malloc>(3).)"

#. type: Plain text
#: build/C/man3/CPU_SET.3:237
msgid ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."
msgstr ""
"B<CPU_ALLOC_SIZE>()  returns the number of bytes required to store a CPU set "
"of the specified cardinality."

#. type: Plain text
#: build/C/man3/CPU_SET.3:239
msgid "The other functions do not return a value."
msgstr "The other functions do not return a value."

#. type: SH
#: build/C/man3/CPU_SET.3:239 build/C/man2/clone.2:908
#: build/C/man3/sched_getcpu.3:50 build/C/man2/sched_setaffinity.2:149
#: build/C/man2/setns.2:93 build/C/man2/unshare.2:200
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/CPU_SET.3:247
msgid ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."
msgstr ""
"The B<CPU_ZERO>(), B<CPU_SET>(), B<CPU_CLR>(), and B<CPU_ISSET>()  macros "
"were added in glibc 2.3.3."

#. type: Plain text
#: build/C/man3/CPU_SET.3:250
msgid "B<CPU_COUNT>()  first appeared in glibc 2.6."
msgstr "B<CPU_COUNT>()  first appeared in glibc 2.6."

#. type: Plain text
#: build/C/man3/CPU_SET.3:268
msgid ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), B<CPU_XOR_S>"
"(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."
msgstr ""
"B<CPU_AND>(), B<CPU_OR>(), B<CPU_XOR>(), B<CPU_EQUAL>(), B<CPU_ALLOC>(), "
"B<CPU_ALLOC_SIZE>(), B<CPU_FREE>(), B<CPU_ZERO_S>(), B<CPU_SET_S>(), "
"B<CPU_CLR_S>(), B<CPU_ISSET_S>(), B<CPU_AND_S>(), B<CPU_OR_S>(), B<CPU_XOR_S>"
"(), and B<CPU_EQUAL_S>()  first appeared in glibc 2.7."

#. type: SH
#: build/C/man3/CPU_SET.3:268 build/C/man2/clone.2:915
#: build/C/man2/sched_get_priority_max.2:101 build/C/man3/sched_getcpu.3:52
#: build/C/man2/sched_rr_get_interval.2:92
#: build/C/man2/sched_setaffinity.2:160 build/C/man2/sched_setparam.2:111
#: build/C/man2/sched_setscheduler.2:445 build/C/man2/sched_yield.2:53
#: build/C/man2/setns.2:97 build/C/man2/unshare.2:204
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/CPU_SET.3:270
msgid "These interfaces are Linux-specific."
msgstr "These interfaces are Linux-specific."

#. type: SH
#: build/C/man3/CPU_SET.3:270 build/C/man2/clone.2:922
#: build/C/man3/sched_getcpu.3:55 build/C/man2/sched_rr_get_interval.2:94
#: build/C/man2/sched_setaffinity.2:162 build/C/man2/sched_setscheduler.2:448
#: build/C/man2/sched_yield.2:55 build/C/man2/setns.2:101
#: build/C/man2/unshare.2:208
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/CPU_SET.3:273
msgid "To duplicate a CPU set, use B<memcpy>(3)."
msgstr "To duplicate a CPU set, use B<memcpy>(3)."

#. type: Plain text
#: build/C/man3/CPU_SET.3:280
msgid ""
"Since CPU sets are bitsets allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."
msgstr ""
"Since CPU sets are bitsets allocated in units of long words, the actual "
"number of CPUs in a dynamically allocated CPU set will be rounded up to the "
"next multiple of I<sizeof(unsigned long)>.  An application should consider "
"the contents of these extra bits to be undefined."

#. type: Plain text
#: build/C/man3/CPU_SET.3:292
msgid ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of bits in the bitset), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."
msgstr ""
"Notwithstanding the similarity in the names, note that the constant "
"B<CPU_SETSIZE> indicates the number of CPUs in the I<cpu_set_t> data type "
"(thus, it is effectively a count of bits in the bitset), while the "
"I<setsize> argument of the B<CPU_*_S>()  macros is a size in bytes."

#. type: Plain text
#: build/C/man3/CPU_SET.3:298
msgid ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."
msgstr ""
"The data types for arguments and return values shown in the SYNOPSIS are "
"hints what about is expected in each case.  However, since these interfaces "
"are implemented as macros, the compiler won't necessarily catch all type "
"errors if you violate the suggestions."

#. type: SH
#: build/C/man3/CPU_SET.3:298
#, no-wrap
msgid "EXAMPLE"
msgstr "EXAMPLE"

#. type: Plain text
#: build/C/man3/CPU_SET.3:301
msgid ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."
msgstr ""
"The following program demonstrates the use of some of the macros used for "
"dynamically allocated CPU sets."

#. type: Plain text
#: build/C/man3/CPU_SET.3:309
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>sched.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>assert.hE<gt>\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:316
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus, cpu;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    cpu_set_t *cpusetp;\n"
"    size_t size;\n"
"    int num_cpus, cpu;\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:321
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>num-cpusE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:323
#, no-wrap
msgid "    num_cpus = atoi(argv[1]);\n"
msgstr "    num_cpus = atoi(argv[1]);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:329
#, no-wrap
msgid ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpusetp = CPU_ALLOC(num_cpus);\n"
"    if (cpusetp == NULL) {\n"
"        perror(\"CPU_ALLOC\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:331
#, no-wrap
msgid "    size = CPU_ALLOC_SIZE(num_cpus);\n"
msgstr "    size = CPU_ALLOC_SIZE(num_cpus);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:335
#, no-wrap
msgid ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"
msgstr ""
"    CPU_ZERO_S(size, cpusetp);\n"
"    for (cpu = 0; cpu E<lt> num_cpus; cpu += 2)\n"
"        CPU_SET_S(cpu, size, cpusetp);\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:337
#, no-wrap
msgid "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"
msgstr "    printf(\"CPU_COUNT() of set:    %d\\en\", CPU_COUNT_S(size, cpusetp));\n"

#. type: Plain text
#: build/C/man3/CPU_SET.3:341
#, no-wrap
msgid ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    CPU_FREE(cpusetp);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: SH
#: build/C/man3/CPU_SET.3:342 build/C/man2/clone.2:969
#: build/C/man2/sched_setscheduler.2:509 build/C/man2/setns.2:107
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7029
#. type: Plain text
#: build/C/man3/CPU_SET.3:354
msgid ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."
msgstr ""
"On 32-bit platforms with glibc 2.8 and earlier, B<CPU_ALLOC>()  allocates "
"twice as much space as is required, and B<CPU_ALLOC_SIZE>()  returns a value "
"twice as large as it should.  This bug should not affect the semantics of a "
"program, but does result in wasted memory and less efficient operation of "
"the macros that operate on dynamically allocated CPU sets.  These bugs are "
"fixed in glibc 2.9."

#. type: SH
#: build/C/man3/CPU_SET.3:354 build/C/man2/clone.2:1011
#: build/C/man2/sched_get_priority_max.2:103 build/C/man3/sched_getcpu.3:75
#: build/C/man2/sched_rr_get_interval.2:119
#: build/C/man2/sched_setaffinity.2:215 build/C/man2/sched_setparam.2:113
#: build/C/man2/sched_setscheduler.2:517 build/C/man2/sched_yield.2:79
#: build/C/man2/setns.2:115 build/C/man2/unshare.2:244
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/CPU_SET.3:359
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_setaffinity_np>(3), B<cpuset>(7)"

#. type: SH
#: build/C/man3/CPU_SET.3:359 build/C/man2/clone.2:1023
#: build/C/man2/sched_get_priority_max.2:113 build/C/man3/sched_getcpu.3:77
#: build/C/man2/sched_rr_get_interval.2:125
#: build/C/man2/sched_setaffinity.2:231 build/C/man2/sched_setparam.2:127
#: build/C/man2/sched_setscheduler.2:542 build/C/man2/sched_yield.2:85
#: build/C/man2/setns.2:121 build/C/man2/unshare.2:249
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man3/CPU_SET.3:366 build/C/man2/clone.2:1030
#: build/C/man2/sched_get_priority_max.2:120 build/C/man3/sched_getcpu.3:84
#: build/C/man2/sched_rr_get_interval.2:132
#: build/C/man2/sched_setaffinity.2:238 build/C/man2/sched_setparam.2:134
#: build/C/man2/sched_setscheduler.2:549 build/C/man2/sched_yield.2:92
#: build/C/man2/setns.2:128 build/C/man2/unshare.2:256
msgid ""
"This page is part of release 3.35 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://man7.org/linux/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/clone.2:43
#, no-wrap
msgid "CLONE"
msgstr "CLONE"

#. type: TH
#: build/C/man2/clone.2:43
#, fuzzy, no-wrap
#| msgid "2011-10-04"
msgid "2011-09-08"
msgstr "2011-10-04"

#. type: Plain text
#: build/C/man2/clone.2:46
msgid "clone, __clone2 - create a child process"
msgstr "clone, __clone2 - 子プロセスを作成する"

#. type: Plain text
#: build/C/man2/clone.2:57
#, no-wrap
msgid ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"
msgstr ""
"B<int clone(int (*>I<fn>B<)(void *), void *>I<child_stack>B<,>\n"
"B<          int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"

#. type: Plain text
#: build/C/man2/clone.2:69
msgid ""
"B<clone>()  creates a new process, in a manner similar to B<fork>(2).  It is "
"actually a library function layered on top of the underlying B<clone>()  "
"system call, hereinafter referred to as B<sys_clone>.  A description of "
"B<sys_clone> is given toward the end of this page."
msgstr ""
"B<clone>()  は B<fork>(2)  と同じような方法で新しいプロセスを作成する。 "
"B<clone>()  には、ライブラリ関数とその下層にあたる B<clone>()  システムコール"
"が存在する。以下の説明では、システムコールの方を B<sys_clone> と表すこととす"
"る。 B<sys_clone> に関する説明はこのマニュアルの最後の方にある。"

#. type: Plain text
#: build/C/man2/clone.2:81
msgid ""
"Unlike B<fork>(2), these calls allow the child process to share parts of its "
"execution context with the calling process, such as the memory space, the "
"table of file descriptors, and the table of signal handlers.  (Note that on "
"this manual page, \"calling process\" normally corresponds to \"parent "
"process\".  But see the description of B<CLONE_PARENT> below.)"
msgstr ""
"B<fork>(2)  とは異なり、これらのコールでは、子プロセス (child process)  と呼"
"び出し元のプロセスとが、メモリ空間、 ファイルディスクリプタのテーブル、シグナ"
"ル・ハンドラのテーブルなどの 実行コンテキストの一部を共有できる。 (このマニュ"
"アルにおける「呼び出し元のプロセス」は、通常は 「親プロセス」と一致する。但"
"し、後述の B<CLONE_PARENT> の項も参照のこと)"

#. type: Plain text
#: build/C/man2/clone.2:86
msgid ""
"The main use of B<clone>()  is to implement threads: multiple threads of "
"control in a program that run concurrently in a shared memory space."
msgstr ""
"B<clone>()  の主要な使用法はスレッド (threads) を実装することである: 一つのプ"
"ログラムの中の複数のスレッドは共有されたメモリ空間で 同時に実行される。"

#. type: Plain text
#: build/C/man2/clone.2:107
msgid ""
"When the child process is created with B<clone>(), it executes the function "
"application I<fn>(I<arg>).  (This differs from B<fork>(2), where execution "
"continues in the child from the point of the B<fork>(2)  call.)  The I<fn> "
"argument is a pointer to a function that is called by the child process at "
"the beginning of its execution.  The I<arg> argument is passed to the I<fn> "
"function."
msgstr ""
"B<clone>()  で子プロセスが作成された時に、作成された子プロセスは関数 I<fn>"
"(I<arg>)  を実行する。 (この点が B<fork>(2)  とは異なる。 B<fork>(2)  の場"
"合、子プロセスは B<fork>(2)  が呼び出された場所から実行を続ける。)  I<fn> 引"
"き数は、子プロセスが実行を始める時に子プロセスが呼び出す 関数へのポインタであ"
"る。 I<arg> 引き数はそのまま I<fn> 関数へと渡される。"

#. type: Plain text
#: build/C/man2/clone.2:117
msgid ""
"When the I<fn>(I<arg>)  function application returns, the child process "
"terminates.  The integer returned by I<fn> is the exit code for the child "
"process.  The child process may also terminate explicitly by calling B<exit>"
"(2)  or after receiving a fatal signal."
msgstr ""
"I<fn>(I<arg>)  関数が終了すると、子プロセスは終了する。 I<fn> によって返され"
"た整数が子プロセスの終了コードとなる。 子プロセスは、 B<exit>(2)  を呼んで明"
"示的に終了することもあるし、致命的なシグナルを受信した 場合に終了することもあ"
"る。"

#. type: Plain text
#: build/C/man2/clone.2:133
msgid ""
"The I<child_stack> argument specifies the location of the stack used by the "
"child process.  Since the child and calling process may share memory, it is "
"not possible for the child process to execute in the same stack as the "
"calling process.  The calling process must therefore set up memory space for "
"the child stack and pass a pointer to this space to B<clone>().  Stacks grow "
"downward on all processors that run Linux (except the HP PA processors), so "
"I<child_stack> usually points to the topmost address of the memory space set "
"up for the child stack."
msgstr ""
"I<child_stack> 引き数は、子プロセスによって使用されるスタックの位置を指定す"
"る。 子プロセスと呼び出し元のプロセスはメモリを共有することがあるため、 子プ"
"ロセスは呼び出し元のプロセスと同じスタックで実行することができない。 このた"
"め、呼び出し元のプロセスは子プロセスのスタックのためのメモリ空間を 用意して、"
"この空間へのポインタを B<clone>()  へ渡さなければならない。 (HP PA プロセッサ"
"以外の) Linux が動作する全てのプロセッサでは、 スタックは下方 (アドレスが小さ"
"い方向) へと伸びる。このため、普通は I<child_stack> は子プロセスのスタックの"
"ために用意したメモリ空間の一番大きい アドレスを指すようにする。"

#. type: Plain text
#: build/C/man2/clone.2:149
msgid ""
"The low byte of I<flags> contains the number of the I<termination signal> "
"sent to the parent when the child dies.  If this signal is specified as "
"anything other than B<SIGCHLD>, then the parent process must specify the "
"B<__WALL> or B<__WCLONE> options when waiting for the child with B<wait>"
"(2).  If no signal is specified, then the parent process is not signaled "
"when the child terminates."
msgstr ""
"I<flags> の下位 1 バイトは子プロセスが死んだ場合に親プロセスへと送られる I<終"
"了シグナル (termination signal)> の番号を指定する。このシグナルとして "
"B<SIGCHLD> 以外が指定された場合、親プロセスは、 B<wait>(2)  で子プロセスを待"
"つ際に、オプションとして B<__WALL> または B<__WCLONE> を指定しなければならな"
"い。 どのシグナルも指定されなかった場合、子プロセスが終了した時に親プロセス "
"にシグナルは送られない。"

#. type: Plain text
#: build/C/man2/clone.2:154
msgid ""
"I<flags> may also be bitwise-or'ed with zero or more of the following "
"constants, in order to specify what is shared between the calling process "
"and the child process:"
msgstr ""
"I<flags> には、以下の定数のうち 0個以上をビット毎の論理和 (bitwise-or)  を"
"とったものを指定できる。これらの定数は呼び出し元のプロセスと 子プロセスの間で"
"何を共有するかを指定する:"

#. type: TP
#: build/C/man2/clone.2:154
#, no-wrap
msgid "B<CLONE_CHILD_CLEARTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_CLEARTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:164
msgid ""
"Erase child thread ID at location I<ctid> in child memory when the child "
"exits, and do a wakeup on the futex at that address.  The address involved "
"may be changed by the B<set_tid_address>(2)  system call.  This is used by "
"threading libraries."
msgstr ""
"子プロセスが終了したときに子プロセスのメモリ内の I<ctid> が指す場所にある子プ"
"ロセスのスレッド ID を消去し、 そのアドレスで futex を wake (起床) させる。 "
"このアドレスは B<set_tid_address>(2)  システムコールで変更することができる。 "
"この機能はスレッドライブラリで使用される。"

#. type: TP
#: build/C/man2/clone.2:164
#, no-wrap
msgid "B<CLONE_CHILD_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_CHILD_SETTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:169
msgid "Store child thread ID at location I<ctid> in child memory."
msgstr ""
"子プロセスのメモリ内の I<ctid> が指す場所に子プロセスのスレッド ID を格納す"
"る。"

#. type: TP
#: build/C/man2/clone.2:169 build/C/man2/unshare.2:53
#, no-wrap
msgid "B<CLONE_FILES>"
msgstr "B<CLONE_FILES>"

#. type: Plain text
#: build/C/man2/clone.2:182
msgid ""
"If B<CLONE_FILES> is set, the calling process and the child process share "
"the same file descriptor table.  Any file descriptor created by the calling "
"process or by the child process is also valid in the other process.  "
"Similarly, if one of the processes closes a file descriptor, or changes its "
"associated flags (using the B<fcntl>(2)  B<F_SETFD> operation), the other "
"process is also affected."
msgstr ""
"B<CLONE_FILES> が設定された場合、呼び出し元のプロセスと子プロセスはファイル"
"ディスクリプタの テーブルを共有する。 呼び出し元プロセスとその子プロセスの一"
"方が作成した ファイルディスクリプタは、もう一方においても有効である。 同じよ"
"うに、一方のプロセスがファイルディスクリプタを閉じたり、 (B<fcntl>(2)  "
"B<F_SETFD> 操作を使って) ディスクリプタに関連するフラグを変更したりすると、 "
"もう一方のプロセスにも影響する。"

#. type: Plain text
#: build/C/man2/clone.2:196
msgid ""
"If B<CLONE_FILES> is not set, the child process inherits a copy of all file "
"descriptors opened in the calling process at the time of B<clone>().  (The "
"duplicated file descriptors in the child refer to the same open file "
"descriptions (see B<open>(2))  as the corresponding file descriptors in the "
"calling process.)  Subsequent operations that open or close file "
"descriptors, or change file descriptor flags, performed by either the "
"calling process or the child process do not affect the other process."
msgstr ""
"B<CLONE_FILES> が設定されていない場合、子プロセスは、 B<clone>()  が実行され"
"た時点で、呼び出し元のプロセスがオープンしている全ての ファイルディスクリプタ"
"のコピーを継承する (子プロセスの複製されたファイルディスクリプタは、 対応する"
"呼び出し元のプロセスのファイルディスクリプタと 同じファイル記述 (B<open>(2)  "
"参照) を参照する)。 これ以降に、呼び出し元のプロセスと子プロセスの一方が ファ"
"イルディスクリプタの操作 (ファイルディスクリプタの オープン・クローズや、ファ"
"イルディスクリプタ・フラグの変更)  を行っても、もう一方のプロセスには影響を与"
"えない。"

#. type: TP
#: build/C/man2/clone.2:196 build/C/man2/unshare.2:61
#, no-wrap
msgid "B<CLONE_FS>"
msgstr "B<CLONE_FS>"

#. type: Plain text
#: build/C/man2/clone.2:211
msgid ""
"If B<CLONE_FS> is set, the caller and the child process share the same file "
"system information.  This includes the root of the file system, the current "
"working directory, and the umask.  Any call to B<chroot>(2), B<chdir>(2), or "
"B<umask>(2)  performed by the calling process or the child process also "
"affects the other process."
msgstr ""
"B<CLONE_FS> が設定された場合、呼び出し元のプロセスと子プロセスが同じファイ"
"ル・システム 情報を共有する。ファイル・システム情報は、ファイル・システムの"
"ルート (root)、 カレント・ワーキング・ディレクトリ (current working "
"directory)  や umask などである。 呼び出し元のプロセスや子プロセスのどちらか"
"一方によって B<chroot>(2), B<chdir>(2), B<umask>(2)  が呼び出されると、もう一"
"方のプロセスにも影響が及ぶ。"

#. type: Plain text
#: build/C/man2/clone.2:223
msgid ""
"If B<CLONE_FS> is not set, the child process works on a copy of the file "
"system information of the calling process at the time of the B<clone>()  "
"call.  Calls to B<chroot>(2), B<chdir>(2), B<umask>(2)  performed later by "
"one of the processes do not affect the other process."
msgstr ""
"B<CLONE_FS> が設定されていない場合、子プロセスは、 B<clone>()  が実行された時"
"点での、呼び出し元のプロセスのファイル・システム情報のコピーを 使用する。 こ"
"れ以降は、呼び出し元のプロセスと子プロセスの一方が B<chroot>(2), B<chdir>"
"(2), B<umask>(2)  を呼び出しても、もう一方のプロセスには影響を与えない。"

#. type: TP
#: build/C/man2/clone.2:223
#, no-wrap
msgid "B<CLONE_IO> (since Linux 2.6.25)"
msgstr "B<CLONE_IO> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/clone.2:232
msgid ""
"If B<CLONE_IO> is set, then the new process shares an I/O context with the "
"calling process.  If this flag is not set, then (as with B<fork>(2))  the "
"new process has its own I/O context."
msgstr ""
"B<CLONE_IO> が設定された場合、新しいプロセスは呼び出し元のプロセスと I/O コン"
"テキストを共有する。 このフラグが設定されていない場合には、 (B<fork>(2)  の場"
"合と同様) 新しいプロセスは自分専用の I/O コンテキストを持つ。"

#.  The following based on text from Jens Axboe
#.  the anticipatory and CFQ scheduler
#.  with CFQ and AS.
#. type: Plain text
#: build/C/man2/clone.2:249
msgid ""
"The I/O context is the I/O scope of the disk scheduler (i.e, what the I/O "
"scheduler uses to model scheduling of a process's I/O).  If processes share "
"the same I/O context, they are treated as one by the I/O scheduler.  As a "
"consequence, they get to share disk time.  For some I/O schedulers, if two "
"processes share an I/O context, they will be allowed to interleave their "
"disk access.  If several threads are doing I/O on behalf of the same process "
"(B<aio_read>(3), for instance), they should employ B<CLONE_IO> to get better "
"I/O performance."
msgstr ""
"I/O コンテキストは、ディスクスケジュールの I/O スコープである (言い換えると、"
"I/O コンテキストは I/O スケジューラがプロセス I/O の スケジューリングをモデル"
"化するのに使用される)。 複数のプロセスが同じ I/O コンテキストを共有する場"
"合、 これらのプロセスは I/O スケジューラからは一つとして扱われる。 結果とし"
"て、これらのプロセスはディスクアクセスの時間を共有するようになる。 いくつか"
"の I/O スケジューラでは、 二つのプロセスが I/O コンテキストを共有している場"
"合、 これらのプロセスはディスクアクセスを交互に行うことができる。 同じプロセ"
"スの複数のスレッドが I/O を実行している場合 (例えば B<aio_read>(3))、 "
"B<CLONE_IO> を利用することで I/O 性能を良くすることができる。"

#. type: Plain text
#: build/C/man2/clone.2:253
msgid ""
"If the kernel is not configured with the B<CONFIG_BLOCK> option, this flag "
"is a no-op."
msgstr ""
"カーネルの設定が B<CONFIG_BLOCK> オプション付きでない場合、 このフラグは何の"
"意味も持たない。"

#. type: TP
#: build/C/man2/clone.2:253 build/C/man2/unshare.2:74
#, no-wrap
msgid "B<CLONE_NEWIPC> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWIPC> (Linux 2.6.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:263
msgid ""
"If B<CLONE_NEWIPC> is set, then create the process in a new IPC namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same IPC namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""
"B<CLONE_NEWIPC> が設定された場合、新しい IPC 名前空間 (namespace) でプロセス"
"を作成する。 このフラグが設定されていない場合、 (B<fork>(2)  の場合と同様) 呼"
"び出し元のプロセスと同じ IPC 名前空間でプロセスが 作成される。 このフラグは、"
"コンテナの実装での使用を意図して用意されたものである。"

#. type: Plain text
#: build/C/man2/clone.2:274
msgid ""
"An IPC namespace consists of the set of identifiers for System V IPC "
"objects.  (These objects are created using B<msgctl>(2), B<semctl>(2), and "
"B<shmctl>(2)).  Objects created in an IPC namespace are visible to all other "
"processes that are members of that namespace, but are not visible to "
"processes in other IPC namespaces."
msgstr ""
"IPC 名前空間は、System V IPC オブジェクト用の識別子 (identifiers) の 集合で構"
"成される (System V IPC オブジェクトは B<msgctl>(2), B<semctl>(2), B<shmctl>"
"(2)  を使って作成される)。 ある IPC 名前空間に作成されたオブジェクトは、 その"
"名前空間のメンバーである他のすべてのプロセスからも見えるが、 違う IPC 名前空"
"間のプロセスからは見えない。"

#. type: Plain text
#: build/C/man2/clone.2:278
msgid ""
"When an IPC namespace is destroyed (i.e, when the last process that is a "
"member of the namespace terminates), all IPC objects in the namespace are "
"automatically destroyed."
msgstr ""
"IPC 名前空間が破棄される時 (すなわち、その名前空間のメンバーの最後のプロセス"
"が終了する時)、 その名前空間の全ての IPC オブジェクトは自動的に破棄される。"

#. type: Plain text
#: build/C/man2/clone.2:287
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_SYSVIPC> "
"and B<CONFIG_IPC_NS> options and that the process be privileged "
"(B<CAP_SYS_ADMIN>).  This flag can't be specified in conjunction with "
"B<CLONE_SYSVSEM>."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_SYSVIPC> と "
"B<CONFIG_IPC_NS> を有効になっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  "
"を持っていることが必要である。 このフラグは B<CLONE_SYSVSEM> と組み合わせて使"
"うことはできない。"

#. type: TP
#: build/C/man2/clone.2:287 build/C/man2/unshare.2:91
#, no-wrap
msgid "B<CLONE_NEWNET> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWNET> (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man2/clone.2:291
msgid ""
"(The implementation of this flag was only completed by about kernel version "
"2.6.29.)"
msgstr "(このフラグの実装は、Linux 2.6.29 あたりまでに完成した。)"

#. type: Plain text
#: build/C/man2/clone.2:300
msgid ""
"If B<CLONE_NEWNET> is set, then create the process in a new network "
"namespace.  If this flag is not set, then (as with B<fork>(2)), the process "
"is created in the same network namespace as the calling process.  This flag "
"is intended for the implementation of containers."
msgstr ""
"B<CLONE_NEWNET> が設定された場合、新しいネットワーク名前空間 (network "
"namaspace)  でプロセスを作成する。 このフラグが設定されていない場合、 "
"(B<fork>(2)  の場合と同様) 呼び出し元のプロセスと同じネットワーク名前空間でプ"
"ロセスが 作成される。 このフラグは、コンテナの実装での使用を意図して用意され"
"たものである。"

#. type: Plain text
#: build/C/man2/clone.2:314
msgid ""
"A network namespace provides an isolated view of the networking stack "
"(network device interfaces, IPv4 and IPv6 protocol stacks, IP routing "
"tables, firewall rules, the I</proc/net> and I</sys/class/net> directory "
"trees, sockets, etc.).  A physical network device can live in exactly one "
"network namespace.  A virtual network device (\"veth\") pair provides a pipe-"
"like abstraction that can be used to create tunnels between network "
"namespaces, and can be used to create a bridge to a physical network device "
"in another namespace."
msgstr ""
"ネットワーク名前空間は、分離されたネットワークスタックを提供するものである "
"(ネットワークスタックとは、 ネットワークデバイスインタフェース、IPv4 や IPv6 "
"プロトコルスタック、 I</proc/net>、 I</sys/class/net> ディレクトリツリー、ソ"
"ケットなどである)。 物理ネットワークデバイスが所属できるネットワーク名前空間"
"は一つだけである。 仮想ネットワークデバイス (\"veth\") のペアにより パイプ風"
"の抽象化 (abstraction) が実現されており、 これを使うことで、ネットワーク名前"
"空間間のトンネルを作成したり、 別の名前空間の物理ネットワークデバイスへのブ"
"リッジを作成したり することができる。"

#. type: Plain text
#: build/C/man2/clone.2:319
msgid ""
"When a network namespace is freed (i.e., when the last process in the "
"namespace terminates), its physical network devices are moved back to the "
"initial network namespace (not to the parent of the process)."
msgstr ""
"ネットワーク名前空間が解放される時 (すなわち、その名前空間の最後のプロセスが"
"終了する時)、 物理ネットワークデバイスは初期ネットワーク名前空間 (initial "
"network namespace) に戻される (親プロセスのネットワーク名前空間に戻される訳で"
"はない)。"

#. type: Plain text
#: build/C/man2/clone.2:324
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_NET_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_NET_NS> を有効に"
"なっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  を持っていることが必要で"
"ある。"

#. type: TP
#: build/C/man2/clone.2:324
#, no-wrap
msgid "B<CLONE_NEWNS> (since Linux 2.4.19)"
msgstr "B<CLONE_NEWNS> (Linux 2.4.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:327
msgid "Start the child in a new mount namespace."
msgstr "子プロセスを新しいマウント名前空間 (mount namespace) で開始する。"

#. type: Plain text
#: build/C/man2/clone.2:348
msgid ""
"Every process lives in a mount namespace.  The I<namespace> of a process is "
"the data (the set of mounts) describing the file hierarchy as seen by that "
"process.  After a B<fork>(2)  or B<clone>()  where the B<CLONE_NEWNS> flag "
"is not set, the child lives in the same mount namespace as the parent.  The "
"system calls B<mount>(2)  and B<umount>(2)  change the mount namespace of "
"the calling process, and hence affect all processes that live in the same "
"namespace, but do not affect processes in a different mount namespace."
msgstr ""
"各プロセスはある一つのマウント名前空間中に存在する。プロセスの I<名前空間 "
"(namespace)> は、そのプロセスから見えるファイル階層を表すデータ (mount の集"
"合) である。 B<CLONE_NEWNS> フラグがセットされずに B<fork>(2)  か B<clone>"
"()  が呼ばれると、子プロセスは親プロセスと同じマウント名前空間に作成される。 "
"システムコール B<mount>(2)、 B<umount>(2)  が呼ばれると呼び出し元のプロセスの"
"マウント名前空間が変更され、この結果 呼び出し元のプロセスと同じ名前空間にいる"
"プロセスはすべて影響を受けるが、 異なるマウント名前空間にいるプロセスは影響を"
"受けない。"

#. type: Plain text
#: build/C/man2/clone.2:355
msgid ""
"After a B<clone>()  where the B<CLONE_NEWNS> flag is set, the cloned child "
"is started in a new mount namespace, initialized with a copy of the "
"namespace of the parent."
msgstr ""
"B<CLONE_NEWNS> フラグがセットされて B<clone>()  が呼ばれると、clone で作成さ"
"れた子プロセスは新しいマウント名前空間で 開始される。新しい名前空間は親プロセ"
"スの名前空間のコピーで初期化される。"

#. type: Plain text
#: build/C/man2/clone.2:367
msgid ""
"Only a privileged process (one having the B<CAP_SYS_ADMIN> capability)  may "
"specify the B<CLONE_NEWNS> flag.  It is not permitted to specify both "
"B<CLONE_NEWNS> and B<CLONE_FS> in the same B<clone>()  call."
msgstr ""
"特権プロセス (B<CAP_SYS_ADMIN> ケーパビリティを持つプロセス) のみが "
"B<CLONE_NEWNS> フラグを指定することができる。 一つの B<clone>()  呼び出し"
"で、 B<CLONE_NEWNS> と B<CLONE_FS> の両方を指定することはできない。"

#. type: TP
#: build/C/man2/clone.2:367
#, no-wrap
msgid "B<CLONE_NEWPID> (since Linux 2.6.24)"
msgstr "B<CLONE_NEWPID> (Linux 2.6.24 以降)"

#.  This explanation draws a lot of details from
#.  http://lwn.net/Articles/259217/
#.  Authors: Pavel Emelyanov <xemul@openvz.org>
#.  and Kir Kolyshkin <kir@openvz.org>
#.  The primary kernel commit is 30e49c263e36341b60b735cbef5ca37912549264
#.  Author: Pavel Emelyanov <xemul@openvz.org>
#. type: Plain text
#: build/C/man2/clone.2:384
msgid ""
"If B<CLONE_NEWPID> is set, then create the process in a new PID namespace.  "
"If this flag is not set, then (as with B<fork>(2)), the process is created "
"in the same PID namespace as the calling process.  This flag is intended for "
"the implementation of containers."
msgstr ""
"B<CLONE_NEWPID> が設定された場合、新しい PID 名前空間でプロセスを作成する。 "
"このフラグが設定されていない場合、 (B<fork>(2)  の場合と同様) 呼び出し元のプ"
"ロセスと同じ PID 名前空間で プロセスが作成される。 このフラグは、コンテナの実"
"装での使用を意図して用意されたものである。"

#. type: Plain text
#: build/C/man2/clone.2:393
msgid ""
"A PID namespace provides an isolated environment for PIDs: PIDs in a new "
"namespace start at 1, somewhat like a standalone system, and calls to B<fork>"
"(2), B<vfork>(2), or B<clone>()  will produce processes with PIDs that are "
"unique within the namespace."
msgstr ""
"PID 名前空間は、PID に関して分離された環境を提供するものである。 新しい名前空"
"間における PID は 1 から始まり (これはスタンドアロンのシステムと似たような感"
"じ)、 B<fork>(2), B<vfork>(2), B<clone>()  を呼び出すと、その名前空間で一意"
"な PID を持ったプロセスが作成される。"

#. type: Plain text
#: build/C/man2/clone.2:405
msgid ""
"The first process created in a new namespace (i.e., the process created "
"using the B<CLONE_NEWPID> flag) has the PID 1, and is the \"init\" process "
"for the namespace.  Children that are orphaned within the namespace will be "
"reparented to this process rather than B<init>(8).  Unlike the traditional "
"B<init> process, the \"init\" process of a PID namespace can terminate, and "
"if it does, all of the processes in the namespace are terminated."
msgstr ""
"新しい名前空間で作成される最初のプロセス (つまり、 B<CLONE_NEWPID> フラグを"
"使って作成されたプロセス) の PID は 1 であり、 このプロセスはその名前空間にお"
"ける \"init\" プロセスとなる。 この名前空間において孤児 (orphaned) となった子"
"プロセスについては、 B<init>(8)  ではなくこのプロセスが親プロセスとなる。 昔"
"ながらの B<init> プロセスとは違い、PID 名前空間の \"init\" プロセスは終了 "
"(terminated) する ことができ、その場合には、この名前空間の全てのプロセスが終"
"了される。"

#. type: Plain text
#: build/C/man2/clone.2:424
msgid ""
"PID namespaces form a hierarchy.  When a new PID namespace is created, the "
"processes in that namespace are visible in the PID namespace of the process "
"that created the new namespace; analogously, if the parent PID namespace is "
"itself the child of another PID namespace, then processes in the child and "
"parent PID namespaces will both be visible in the grandparent PID "
"namespace.  Conversely, the processes in the \"child\" PID namespace do not "
"see the processes in the parent namespace.  The existence of a namespace "
"hierarchy means that each process may now have multiple PIDs: one for each "
"namespace in which it is visible; each of these PIDs is unique within the "
"corresponding namespace.  (A call to B<getpid>(2)  always returns the PID "
"associated with the namespace in which the process lives.)"
msgstr ""
"PID 名前空間間には階層構造が形成される。 新しい PID 名前空間が作成されると、"
"その名前空間のプロセスは、 新しい名前空間を作成したプロセスの PID 名前空間で"
"見える。 同様に、親の PID 名前空間自体が別の PID 名前空間の子供の場合には、 "
"子供の PID 名前空間と親の PID 名前空間のプロセスはどれも 親の親の PID 名前空"
"間でも見えることになる。 反対に、「子供」の PID 名前空間のプロセスには、 親の"
"名前空間のプロセスは見えない。 名前空間に階層構造が存在するということは、個々"
"のプロセスは 複数の PID を持つということを意味している。 そのプロセスが見える"
"名前空間一つにつき PID が一つあり、 それぞれの PID は対応する名前空間において"
"一意である。 (B<getpid>(2)  を呼び出すと、常にそのプロセスが存在している名前"
"空間における PID が返される。)"

#.  mount -t proc proc /proc
#. type: Plain text
#: build/C/man2/clone.2:440
msgid ""
"After creating the new namespace, it is useful for the child to change its "
"root directory and mount a new procfs instance at I</proc> so that tools "
"such as B<ps>(1)  work correctly.  (If B<CLONE_NEWNS> is also included in "
"I<flags>, then it isn't necessary to change the root directory: a new procfs "
"instance can be mounted directly over I</proc>.)"
msgstr ""
"新しい名前空間の作成後には、 子プロセスにおいて、 B<ps>(1)  といったツールが"
"正しく動作するように、 自身の root ディレクトリを変更し、 I</proc> に新しい "
"procfs インスタンスをマウントするのがよいだろう。 (B<flags> に "
"B<CLONE_NEWNS> も指定されていた場合には、root ディレクトリを変更する必要はな"
"く、 いきなり新しい procfs インスタンスを I</proc> にマウントすることができ"
"る。)"

#. type: Plain text
#: build/C/man2/clone.2:447
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_PID_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>).  This flag "
"can't be specified in conjunction with B<CLONE_THREAD>."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_PID_NS> を有効に"
"なっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  を持っていることが必要で"
"ある。 このフラグは B<CLONE_THREAD> と組み合わせて使うことはできない。"

#. type: TP
#: build/C/man2/clone.2:447 build/C/man2/unshare.2:140
#, no-wrap
msgid "B<CLONE_NEWUTS> (since Linux 2.6.19)"
msgstr "B<CLONE_NEWUTS> (Linux 2.6.19 以降)"

#. type: Plain text
#: build/C/man2/clone.2:459
msgid ""
"If B<CLONE_NEWUTS> is set, then create the process in a new UTS namespace, "
"whose identifiers are initialized by duplicating the identifiers from the "
"UTS namespace of the calling process.  If this flag is not set, then (as "
"with B<fork>(2)), the process is created in the same UTS namespace as the "
"calling process.  This flag is intended for the implementation of containers."
msgstr ""
"B<CLONE_NEWUTS> が設定された場合、新しい UTS 名前空間でプロセスを作成する。 "
"新しい UTS 名前空間の識別子の初期値は、呼び出し元のプロセスの UTS 名前空間の"
"識別子を複製したものとなる。 このフラグが設定されていない場合、 (B<fork>(2)  "
"の場合と同様) 呼び出し元のプロセスと同じ UTS 名前空間で プロセスが作成され"
"る。 このフラグは、コンテナの実装での使用を意図して用意されたものである。"

#. type: Plain text
#: build/C/man2/clone.2:471
msgid ""
"A UTS namespace is the set of identifiers returned by B<uname>(2); among "
"these, the domain name and the host name can be modified by B<setdomainname>"
"(2)  and B<sethostname>(2), respectively.  Changes made to the identifiers "
"in a UTS namespace are visible to all other processes in the same namespace, "
"but are not visible to processes in other UTS namespaces."
msgstr ""
"UTS 名前空間は、 B<uname>(2)  が返す識別子の集合である。 識別子としてはドメイ"
"ン名とホスト名があり、 それぞれ B<setdomainname>(2), B<sethostname>(2)  で修"
"正することができる。 ある UTS 名前空間における識別子の変更は同じ名前空間の他"
"のすべての プロセスに見えるが、別の UTS 名前空間のプロセスには見えない。"

#. type: Plain text
#: build/C/man2/clone.2:476
msgid ""
"Use of this flag requires: a kernel configured with the B<CONFIG_UTS_NS> "
"option and that the process be privileged (B<CAP_SYS_ADMIN>)."
msgstr ""
"このフラグを使用するためには、 カーネルでオプション B<CONFIG_UTS_NS> を有効に"
"なっていること、 プロセスが特権 (B<CAP_SYS_ADMIN>)  を持っていることが必要で"
"ある。"

#. type: TP
#: build/C/man2/clone.2:476
#, no-wrap
msgid "B<CLONE_PARENT> (since Linux 2.3.12)"
msgstr "B<CLONE_PARENT> (Linux 2.3.12 以降)"

#. type: Plain text
#: build/C/man2/clone.2:483
msgid ""
"If B<CLONE_PARENT> is set, then the parent of the new child (as returned by "
"B<getppid>(2))  will be the same as that of the calling process."
msgstr ""
"B<CLONE_PARENT> が設定された場合、新しい子供の (B<getppid>(2)  で返される) 親"
"プロセスは呼び出し元のプロセスの親プロセスと同じになる。"

#. type: Plain text
#: build/C/man2/clone.2:489
msgid ""
"If B<CLONE_PARENT> is not set, then (as with B<fork>(2))  the child's parent "
"is the calling process."
msgstr ""
"B<CLONE_PARENT> が設定されていない場合、 (B<fork>(2)  と同様に) 呼び出し元の"
"プロセスがその子供の親になる。"

#. type: Plain text
#: build/C/man2/clone.2:497
msgid ""
"Note that it is the parent process, as returned by B<getppid>(2), which is "
"signaled when the child terminates, so that if B<CLONE_PARENT> is set, then "
"the parent of the calling process, rather than the calling process itself, "
"will be signaled."
msgstr ""
"子供が終了した時にシグナルが送られるのは B<getppid>(2)  が返す親プロセスであ"
"る点に注意すること。このため B<CLONE_PARENT> が設定された場合、呼び出し元のプ"
"ロセスではなく呼び出し元のプロセスの 親プロセスにシグナルが送られる。"

#. type: TP
#: build/C/man2/clone.2:497
#, no-wrap
msgid "B<CLONE_PARENT_SETTID> (since Linux 2.5.49)"
msgstr "B<CLONE_PARENT_SETTID> (Linux 2.5.49 以降)"

#. type: Plain text
#: build/C/man2/clone.2:505
msgid ""
"Store child thread ID at location I<ptid> in parent and child memory.  (In "
"Linux 2.5.32-2.5.48 there was a flag B<CLONE_SETTID> that did this.)"
msgstr ""
"親プロセスと子プロセスのメモリ内の I<ptid> が指す領域に子プロセスのスレッド "
"ID を格納する。 (Linux 2.5.32-2.5.48 では、 同じことをする B<CLONE_SETTID> と"
"いうフラグが存在した。)"

#. type: TP
#: build/C/man2/clone.2:505
#, no-wrap
msgid "B<CLONE_PID> (obsolete)"
msgstr "B<CLONE_PID> (廃止予定)"

#. type: Plain text
#: build/C/man2/clone.2:516
msgid ""
"If B<CLONE_PID> is set, the child process is created with the same process "
"ID as the calling process.  This is good for hacking the system, but "
"otherwise of not much use.  Since 2.3.21 this flag can be specified only by "
"the system boot process (PID 0).  It disappeared in Linux 2.5.16."
msgstr ""
"B<CLONE_PID> が設定された場合、子プロセスは呼び出し元のプロセスと同じプロセ"
"ス ID で作成される。これはシステムをハッキングするのには便利だが、 それ以外に"
"はあまり使われない。 Linux 2.3.21 以降では、 システムのブートプロセス (PID "
"0) だけがこのフラグを指定できる。 Linux 2.5.16 で削除された。"

#. type: TP
#: build/C/man2/clone.2:516
#, no-wrap
msgid "B<CLONE_PTRACE>"
msgstr "B<CLONE_PTRACE>"

#. type: Plain text
#: build/C/man2/clone.2:523
msgid ""
"If B<CLONE_PTRACE> is specified, and the calling process is being traced, "
"then trace the child also (see B<ptrace>(2))."
msgstr ""
"B<CLONE_PTRACE> が指定され、かつ呼び出し元のプロセスが追跡 (trace) されていた"
"場合、子プロセスも 同様に追跡される。 (B<ptrace>(2)  を参照のこと)"

#. type: TP
#: build/C/man2/clone.2:523
#, no-wrap
msgid "B<CLONE_SETTLS> (since Linux 2.5.32)"
msgstr "B<CLONE_SETTLS> (Linux 2.5.32 以降)"

#. type: Plain text
#: build/C/man2/clone.2:530
msgid ""
"The I<newtls> argument is the new TLS (Thread Local Storage) descriptor.  "
"(See B<set_thread_area>(2).)"
msgstr ""
"I<newtls> 引き数は、新しい TLS (Thread Local Storage) ディスクリプタである。 "
"(B<set_thread_area>(2)  を参照のこと)"

#. type: TP
#: build/C/man2/clone.2:530
#, no-wrap
msgid "B<CLONE_SIGHAND>"
msgstr "B<CLONE_SIGHAND>"

#. type: Plain text
#: build/C/man2/clone.2:546
msgid ""
"If B<CLONE_SIGHAND> is set, the calling process and the child process share "
"the same table of signal handlers.  If the calling process or child process "
"calls B<sigaction>(2)  to change the behavior associated with a signal, the "
"behavior is changed in the other process as well.  However, the calling "
"process and child processes still have distinct signal masks and sets of "
"pending signals.  So, one of them may block or unblock some signals using "
"B<sigprocmask>(2)  without affecting the other process."
msgstr ""
"B<CLONE_SIGHAND> が設定された場合、呼び出し元のプロセスと子プロセスは同じシグ"
"ナル・ハン ドラのテーブルを共有する。呼び出し元のプロセスまたは子プロセスのど"
"ちらかが B<sigaction>(2)  を呼び出してシグナルに対応する動作を変更した場合、 "
"もう一方のプロセスのシグナル動作も変更される。 但し、呼び出し元のプロセスと子"
"プロセスは、 プロセス毎に、シグナル・マスク (signal mask) と処理待ちシグナル"
"の集合 を持っている。このため、あるプロセスは、 B<sigprocmask>(2)  を使用し"
"て、もう一方のプロセスに影響を与えずに シグナルを禁止 (block) したり許可 "
"(unblock) したりできる。"

#. type: Plain text
#: build/C/man2/clone.2:557
msgid ""
"If B<CLONE_SIGHAND> is not set, the child process inherits a copy of the "
"signal handlers of the calling process at the time B<clone>()  is called.  "
"Calls to B<sigaction>(2)  performed later by one of the processes have no "
"effect on the other process."
msgstr ""
"B<CLONE_SIGHAND> が設定されていない場合、子プロセスは B<clone>()  が実行され"
"た時点での、呼び出し元のプロセスのシグナル・ハンドラの コピーを継承する。これ"
"以降は、一方のプロセスが B<sigaction>(2)  を呼び出しても、もう一方のプロセス"
"には影響を与えない。"

#. type: Plain text
#: build/C/man2/clone.2:565
msgid ""
"Since Linux 2.6.0-test6, I<flags> must also include B<CLONE_VM> if "
"B<CLONE_SIGHAND> is specified"
msgstr ""
"Linux 2.6.0-test6 以降では、 B<CLONE_SIGHAND> を指定する場合、 B<CLONE_VM> "
"も I<flags> に含めなければならない。"

#. type: TP
#: build/C/man2/clone.2:565
#, no-wrap
msgid "B<CLONE_STOPPED> (since Linux 2.6.0-test2)"
msgstr "B<CLONE_STOPPED> (Linux 2.6.0-test2 以降)"

#. type: Plain text
#: build/C/man2/clone.2:574
msgid ""
"If B<CLONE_STOPPED> is set, then the child is initially stopped (as though "
"it was sent a B<SIGSTOP> signal), and must be resumed by sending it a "
"B<SIGCONT> signal."
msgstr ""
"B<CLONE_STOPPED> が設定されると、子プロセスは最初 (B<SIGSTOP> シグナルを送ら"
"れたかのように) 停止した状態となる。 子プロセスを再開させるには B<SIGCONT> シ"
"グナルを送信しなければならない。"

#.  glibc 2.8 removed this defn from bits/sched.h
#. type: Plain text
#: build/C/man2/clone.2:582
msgid ""
"This flag was I<deprecated> from Linux 2.6.25 onward, and was I<removed> "
"altogether in Linux 2.6.38."
msgstr ""

#. type: TP
#: build/C/man2/clone.2:582
#, no-wrap
msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgstr "B<CLONE_SYSVSEM> (Linux 2.5.10 以降)"

#. type: Plain text
#: build/C/man2/clone.2:591
msgid ""
"If B<CLONE_SYSVSEM> is set, then the child and the calling process share a "
"single list of System V semaphore undo values (see B<semop>(2)).  If this "
"flag is not set, then the child has a separate undo list, which is initially "
"empty."
msgstr ""
"B<CLONE_SYSVSEM> がセットされると、子プロセスと呼び出し元プロセスは一つの "
"System V セマフォのアンドゥ値リスト (B<semop>(2)  参照) を共有する。このフラ"
"グがセットされていなければ、 子プロセスは独自のアンドゥリストを持つ (リストの"
"初期値は空である)。"

#. type: TP
#: build/C/man2/clone.2:591
#, no-wrap
msgid "B<CLONE_THREAD> (since Linux 2.4.0-test8)"
msgstr "B<CLONE_THREAD> (Linux 2.4.0-test8以降)"

#. type: Plain text
#: build/C/man2/clone.2:600
msgid ""
"If B<CLONE_THREAD> is set, the child is placed in the same thread group as "
"the calling process.  To make the remainder of the discussion of "
"B<CLONE_THREAD> more readable, the term \"thread\" is used to refer to the "
"processes within a thread group."
msgstr ""
"B<CLONE_THREAD> が設定された場合、子プロセスは呼び出し元のプロセスと同じス"
"レッド・グループに 置かれる。 B<CLONE_THREAD> についての以降の議論を読みやす"
"くするため、 「スレッド」という用語はスレッド・グループの中のプロセスを 参照"
"するのに使うこととする。"

#. type: Plain text
#: build/C/man2/clone.2:608
msgid ""
"Thread groups were a feature added in Linux 2.4 to support the POSIX threads "
"notion of a set of threads that share a single PID.  Internally, this shared "
"PID is the so-called thread group identifier (TGID) for the thread group.  "
"Since Linux 2.4, calls to B<getpid>(2)  return the TGID of the caller."
msgstr ""
"スレッド・グループは、 スレッド集合で一つの PID を共有するという POSIX スレッ"
"ドの概念をサポートするために Linux 2.4 に加えられた機能であった。 内部的に"
"は、この共有 PID はいわゆるそのスレッドグループの スレッド・グループ識別子 "
"(TGID) である。 Linux 2.4 以降では、 B<getpid>(2)  の呼び出しではそのプロセス"
"のスレッド・グループ ID を返す。"

#. type: Plain text
#: build/C/man2/clone.2:617
msgid ""
"The threads within a group can be distinguished by their (system-wide)  "
"unique thread IDs (TID).  A new thread's TID is available as the function "
"result returned to the caller of B<clone>(), and a thread can obtain its own "
"TID using B<gettid>(2)."
msgstr ""
"あるグループに属するスレッドは (システム全体で) 一意なスレッド ID (TID)  で区"
"別できる。新しいスレッドの TID は B<clone>()  の呼び出し元へ関数の結果として"
"返され、 スレッドは自分自身の TID を B<gettid>(2)  で取得できる。"

#. type: Plain text
#: build/C/man2/clone.2:627
msgid ""
"When a call is made to B<clone>()  without specifying B<CLONE_THREAD>, then "
"the resulting thread is placed in a new thread group whose TGID is the same "
"as the thread's TID.  This thread is the I<leader> of the new thread group."
msgstr ""
"B<CLONE_THREAD> を指定せずに B<clone>()  の呼び出しが行われると、 生成された"
"スレッドはそのスレッドの TID と同じ値の TGID を持つ 新しいスレッド・グループ"
"に置かれる。このスレッドは 新しいスレッド・グループの「リーダー」である。"

#. type: Plain text
#: build/C/man2/clone.2:649
msgid ""
"A new thread created with B<CLONE_THREAD> has the same parent process as the "
"caller of B<clone>()  (i.e., like B<CLONE_PARENT>), so that calls to "
"B<getppid>(2)  return the same value for all of the threads in a thread "
"group.  When a B<CLONE_THREAD> thread terminates, the thread that created it "
"using B<clone>()  is not sent a B<SIGCHLD> (or other termination) signal; "
"nor can the status of such a thread be obtained using B<wait>(2).  (The "
"thread is said to be I<detached>.)"
msgstr ""
"B<CLONE_THREAD> を指定して作成された新しいスレッドは、 (B<CLONE_PARENT> の場"
"合と同様に)  B<clone>()  を呼び出し元と同じ親プロセスを持つ。 そのため、 "
"B<getppid>(2)  を呼ぶと、一つのスレッド・グループに属すスレッドは全て同じ値を"
"返す。 B<CLONE_THREAD> で作られたスレッドが終了した際に、 そのスレッドを "
"B<clone>()  を使って生成したスレッドには B<SIGCHLD> (もしくは他の終了シグナ"
"ル) は送信されない。 また、 B<wait>(2)  を使って終了したスレッドの状態を取得"
"することもできない (そのようなスレッドは I<detached> (分離された) といわれ"
"る)。"

#. type: Plain text
#: build/C/man2/clone.2:654
msgid ""
"After all of the threads in a thread group terminate the parent process of "
"the thread group is sent a B<SIGCHLD> (or other termination) signal."
msgstr ""
"スレッド・グループに属す全てのスレッドが終了した後、 そのスレッド・グループの"
"親プロセスに B<SIGCHLD> (もしくは他の終了シグナル) が送られる。"

#. type: Plain text
#: build/C/man2/clone.2:659
msgid ""
"If any of the threads in a thread group performs an B<execve>(2), then all "
"threads other than the thread group leader are terminated, and the new "
"program is executed in the thread group leader."
msgstr ""
"スレッド・グループに属すいずれかのスレッドが B<execve>(2)  を実行すると、ス"
"レッド・グループ・リーダー以外の全てのスレッドは 終了され、新しいプロセスがそ"
"のスレッド・グループ・リーダーの下で 実行される。"

#. type: Plain text
#: build/C/man2/clone.2:665
msgid ""
"If one of the threads in a thread group creates a child using B<fork>(2), "
"then any thread in the group can B<wait>(2)  for that child."
msgstr ""
"スレッド・グループに属すスレッドの一つが B<fork>(2)  を使って子プロセスを作成"
"した場合、 スレッド・グループのどのスレッドであっても その子供を B<wait>(2)  "
"できる。"

#. type: Plain text
#: build/C/man2/clone.2:673
msgid ""
"Since Linux 2.5.35, I<flags> must also include B<CLONE_SIGHAND> if "
"B<CLONE_THREAD> is specified."
msgstr ""
"Linux 2.5.35 以降では、 B<CLONE_THREAD> を指定する場合、 I<flags> に "
"B<CLONE_SIGHAND> も含まれていなければならない。"

#. type: Plain text
#: build/C/man2/clone.2:678
msgid ""
"Signals may be sent to a thread group as a whole (i.e., a TGID) using B<kill>"
"(2), or to a specific thread (i.e., TID) using B<tgkill>(2)."
msgstr ""
"B<kill>(2)  を使ってスレッド・グループ全体 (つまり TGID) にシグナルを送ること"
"もできれば、 B<tgkill>(2)  を使って特定のスレッド (つまり TID) にシグナルを送"
"ることもできる。"

#. type: Plain text
#: build/C/man2/clone.2:683
msgid ""
"Signal dispositions and actions are process-wide: if an unhandled signal is "
"delivered to a thread, then it will affect (terminate, stop, continue, be "
"ignored in)  all members of the thread group."
msgstr ""
"シグナルの配送と処理はプロセス全体に影響する: ハンドラを設定していないシグナ"
"ルがあるスレッドに配送されると、 そのシグナルはスレッド・グループの全メンバー"
"に影響を及ぼす (終了したり、停止したり、動作を継続したり、無視されたりする)。"

#. type: Plain text
#: build/C/man2/clone.2:696
msgid ""
"Each thread has its own signal mask, as set by B<sigprocmask>(2), but "
"signals can be pending either: for the whole process (i.e., deliverable to "
"any member of the thread group), when sent with B<kill>(2); or for an "
"individual thread, when sent with B<tgkill>(2).  A call to B<sigpending>(2)  "
"returns a signal set that is the union of the signals pending for the whole "
"process and the signals that are pending for the calling thread."
msgstr ""
"各々のスレッドは独自のシグナルマスクを持っており、 B<sigprocmask>(2)  で設定"
"できる。 だが、処理待ちのシグナルには、 B<kill>(2)  で送信されるプロセス全体"
"に対するもの (つまり、スレッド・グループの どのメンバーにも配送できるもの) "
"と、 B<tgkill>(2)  で送信される個々のスレッドに対するものがありえる。 "
"B<sigpending>(2)  を呼び出すと、プロセス全体に対する処理待ちシグナルと呼び出"
"し元の スレッドに対する処理待ちシグナルを結合したシグナル集合が返される。"

#. type: Plain text
#: build/C/man2/clone.2:708
msgid ""
"If B<kill>(2)  is used to send a signal to a thread group, and the thread "
"group has installed a handler for the signal, then the handler will be "
"invoked in exactly one, arbitrarily selected member of the thread group that "
"has not blocked the signal.  If multiple threads in a group are waiting to "
"accept the same signal using B<sigwaitinfo>(2), the kernel will arbitrarily "
"select one of these threads to receive a signal sent using B<kill>(2)."
msgstr ""
"B<kill>(2)  を使ってスレッド・グループにシグナルが送られた場合で、 そのスレッ"
"ド・グループがそのシグナルに対するシグナル・ハンドラが 登録されていたときに"
"は、シグナル・ハンドラはスレッド・グループの メンバーのうち、ただ一つのスレッ"
"ドでだけ起動される。ハンドラが 起動されるスレッドは、そのシグナルを禁止 "
"(block) していない メンバーの中から一つだけが勝手に (arbitrarily) 選ばれる。 "
"スレッド・グループに属す複数のスレッドが B<sigwaitinfo>(2)  を使って同じシグ"
"ナルを待っている場合、 これらのスレッドの中から一つをカーネルが勝手に選択"
"し、 そのスレッドが B<kill (2)> を使って送信されたシグナルを受信する。"

#. type: TP
#: build/C/man2/clone.2:708
#, no-wrap
msgid "B<CLONE_UNTRACED> (since Linux 2.5.46)"
msgstr "B<CLONE_UNTRACED> (Linux 2.5.46 以降)"

#. type: Plain text
#: build/C/man2/clone.2:715
msgid ""
"If B<CLONE_UNTRACED> is specified, then a tracing process cannot force "
"B<CLONE_PTRACE> on this child process."
msgstr ""
"B<CLONE_UNTRACED> が指定されると、 trace を行っているプロセスは この子プロセ"
"スに B<CLONE_PTRACE> を適用することができない。"

#. type: TP
#: build/C/man2/clone.2:715
#, no-wrap
msgid "B<CLONE_VFORK>"
msgstr "B<CLONE_VFORK>"

#. type: Plain text
#: build/C/man2/clone.2:727
msgid ""
"If B<CLONE_VFORK> is set, the execution of the calling process is suspended "
"until the child releases its virtual memory resources via a call to B<execve>"
"(2)  or B<_exit>(2)  (as with B<vfork>(2))."
msgstr ""
"B<CLONE_VFORK> が設定された場合、 (B<vfork>(2)  と同様に) 子プロセスが "
"B<execve>(2)  または B<_exit>(2)  によって仮想メモリを解放するまで、呼び出し"
"元のプロセスの実行は停止される。"

#. type: Plain text
#: build/C/man2/clone.2:733
msgid ""
"If B<CLONE_VFORK> is not set then both the calling process and the child are "
"schedulable after the call, and an application should not rely on execution "
"occurring in any particular order."
msgstr ""
"B<CLONE_VFORK> が設定されていない場合、 B<clone>()  呼び出し後は、呼び出し元"
"のプロセスと子プロセスの 両方がスケジュール対象となり、アプリケーションはこれ"
"らのプロセスの 実行順序に依存しないようにすべきである。"

#. type: TP
#: build/C/man2/clone.2:733
#, no-wrap
msgid "B<CLONE_VM>"
msgstr "B<CLONE_VM>"

#. type: Plain text
#: build/C/man2/clone.2:746
msgid ""
"If B<CLONE_VM> is set, the calling process and the child process run in the "
"same memory space.  In particular, memory writes performed by the calling "
"process or by the child process are also visible in the other process.  "
"Moreover, any memory mapping or unmapping performed with B<mmap>(2)  or "
"B<munmap>(2)  by the child or calling process also affects the other process."
msgstr ""
"B<CLONE_VM> が設定された場合、呼び出し元のプロセスと子プロセスは同じメモリ空"
"間で 実行される。特に、呼び出し元のプロセスや子プロセスの一方がメモリに 書き"
"込んだ内容はもう一方のプロセスからも見ることができる。さらに、 子プロセスや呼"
"び出し元のプロセスの一方が B<mmap>(2)  や B<munmap>(2)  を使ってメモリをマッ"
"プしたりアンマップした場合、 もう一方のプロセスにも影響が及ぶ。"

#. type: Plain text
#: build/C/man2/clone.2:755
msgid ""
"If B<CLONE_VM> is not set, the child process runs in a separate copy of the "
"memory space of the calling process at the time of B<clone>().  Memory "
"writes or file mappings/unmappings performed by one of the processes do not "
"affect the other, as with B<fork>(2)."
msgstr ""
"B<CLONE_VM> が設定されていない場合、子プロセスは B<clone>()  が実行された時点"
"での、親プロセスのメモリ空間をコピーした 別のメモリ空間で実行される。 一方の"
"プロセスが行ったメモリへの書き込みや ファイルのマップ/アンマップは、 B<fork>"
"(2)  の場合と同様、もう一方のプロセスには影響しない。"

#. type: SS
#: build/C/man2/clone.2:755
#, no-wrap
msgid "sys_clone"
msgstr "sys_clone"

#. type: Plain text
#: build/C/man2/clone.2:772
msgid ""
"The B<sys_clone> system call corresponds more closely to B<fork>(2)  in that "
"execution in the child continues from the point of the call.  Thus, "
"B<sys_clone> only requires the I<flags> and I<child_stack> arguments, which "
"have the same meaning as for B<clone>().  (Note that the order of these "
"arguments differs from B<clone>().)"
msgstr ""
"B<sys_clone> システムコールは、より B<fork>(2)  に近いかたちになっており、子"
"プロセスの実行が呼び出しが行われた場所から 続けられる。 そのため、 "
"B<sys_clone> が必要とする引き数は I<flags> と I<child_stack> だけであり、それ"
"らは B<clone>()  と同じ意味を持つ (これらの引き数の順番は B<clone>()  とは異"
"なることに注意せよ)。"

#. type: Plain text
#: build/C/man2/clone.2:783
msgid ""
"Another difference for B<sys_clone> is that the I<child_stack> argument may "
"be zero, in which case copy-on-write semantics ensure that the child gets "
"separate copies of stack pages when either process modifies the stack.  In "
"this case, for correct operation, the B<CLONE_VM> option should not be "
"specified."
msgstr ""
"B<sys_clone> のもう一つの違いは、 I<child_stack> 引き数がゼロでも良いことであ"
"る。この場合には、どちらかのプロセスが スタックを変更した時に、書き込み時コ"
"ピー (copy-on-write) 方式により 子プロセスがスタック・ページの独立したコピー"
"を得られることが保証される。 この場合、正常に動作させるためには、 "
"B<CLONE_VM> オプションを指定してはならない。"

#. type: Plain text
#: build/C/man2/clone.2:791
msgid ""
"In Linux 2.4 and earlier, B<clone>()  does not take arguments I<ptid>, "
"I<tls>, and I<ctid>."
msgstr ""
"Linux 2.4 以前では、 B<clone>()  は引き数 I<ptid>, I<tls>, I<ctid> を取らな"
"い。"

#.  gettid(2) returns current->pid;
#.  getpid(2) returns current->tgid;
#. type: Plain text
#: build/C/man2/clone.2:800
msgid ""
"On success, the thread ID of the child process is returned in the caller's "
"thread of execution.  On failure, -1 is returned in the caller's context, no "
"child process will be created, and I<errno> will be set appropriately."
msgstr ""
"成功した場合、呼び出し元の実行スレッドには子プロセスのスレッドID が返され"
"る。 失敗した場合、 呼び出し元のコンテキストには -1 が返され、子プロセスは 作"
"成されず、 I<errno> が適切に設定される。"

#. type: SH
#: build/C/man2/clone.2:800 build/C/man2/sched_get_priority_max.2:97
#: build/C/man3/sched_getcpu.3:45 build/C/man2/sched_rr_get_interval.2:79
#: build/C/man2/sched_setaffinity.2:117 build/C/man2/sched_setparam.2:97
#: build/C/man2/sched_setscheduler.2:433 build/C/man2/sched_yield.2:49
#: build/C/man2/setns.2:73 build/C/man2/unshare.2:188
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/clone.2:801
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/clone.2:804
msgid "Too many processes are already running."
msgstr "すでに実行中のプロセスが多すぎる。"

#. type: TP
#: build/C/man2/clone.2:804 build/C/man2/clone.2:811 build/C/man2/clone.2:826
#: build/C/man2/clone.2:834 build/C/man2/clone.2:842 build/C/man2/clone.2:850
#: build/C/man2/clone.2:856 build/C/man2/clone.2:866 build/C/man2/clone.2:874
#: build/C/man2/clone.2:882 build/C/man2/sched_get_priority_max.2:98
#: build/C/man2/sched_rr_get_interval.2:83
#: build/C/man2/sched_setaffinity.2:121 build/C/man2/sched_setaffinity.2:129
#: build/C/man2/sched_setparam.2:98 build/C/man2/sched_setscheduler.2:434
#: build/C/man2/setns.2:78 build/C/man2/unshare.2:189
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/clone.2:811
msgid ""
"B<CLONE_SIGHAND> was specified, but B<CLONE_VM> was not.  (Since Linux 2.6.0-"
"test6.)"
msgstr ""
"B<CLONE_SIGHAND> が指定されていたが、 B<CLONE_VM> が指定されていなかった。 "
"(Linux 2.6.0-test6 以降)"

#.  .TP
#.  .B EINVAL
#.  Precisely one of
#.  .B CLONE_DETACHED
#.  and
#.  .B CLONE_THREAD
#.  was specified.
#.  (Since Linux 2.6.0-test6.)
#. type: Plain text
#: build/C/man2/clone.2:826
msgid ""
"B<CLONE_THREAD> was specified, but B<CLONE_SIGHAND> was not.  (Since Linux "
"2.5.35.)"
msgstr ""
"B<CLONE_THREAD> が指定されていたが、 B<CLONE_SIGHAND> が指定されていなかっ"
"た。 (Linux 2.5.35 以降)"

#. type: Plain text
#: build/C/man2/clone.2:834
msgid "Both B<CLONE_FS> and B<CLONE_NEWNS> were specified in I<flags>."
msgstr "B<CLONE_FS> と B<CLONE_NEWNS> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/clone.2:842
msgid "Both B<CLONE_NEWIPC> and B<CLONE_SYSVSEM> were specified in I<flags>."
msgstr "B<CLONE_NEWIPC> と B<CLONE_SYSVSEM> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/clone.2:850
msgid "Both B<CLONE_NEWPID> and B<CLONE_THREAD> were specified in I<flags>."
msgstr "B<CLONE_NEWPID> と B<CLONE_THREAD> の両方が I<flags> に指定された。"

#. type: Plain text
#: build/C/man2/clone.2:856
msgid ""
"Returned by B<clone>()  when a zero value is specified for I<child_stack>."
msgstr "I<child_stack> にゼロを指定した場合に B<clone>()  が返す。"

#. type: Plain text
#: build/C/man2/clone.2:866
msgid ""
"B<CLONE_NEWIPC> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_SYSVIPC> and B<CONFIG_IPC_NS> options."
msgstr ""
"I<flags> に B<CLONE_NEWIPC> が指定されたが、カーネルでオプション "
"B<CONFIG_SYSVIPC> と B<CONFIG_IPC_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:874
msgid ""
"B<CLONE_NEWNET> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_NET_NS> option."
msgstr ""
"I<flags> に B<CLONE_NEWNET> が指定されたが、カーネルでオプション "
"B<CONFIG_NET_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:882
msgid ""
"B<CLONE_NEWPID> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_PID_NS> option."
msgstr ""
"I<flags> に B<CLONE_NEWPID> が指定されたが、カーネルでオプション "
"B<CONFIG_PID_NS> が有効になっていなかった。"

#. type: Plain text
#: build/C/man2/clone.2:890
msgid ""
"B<CLONE_NEWUTS> was specified in I<flags>, but the kernel was not configured "
"with the B<CONFIG_UTS> option."
msgstr ""
"I<flags> に B<CLONE_NEWUTS> が指定されたが、カーネルでオプション "
"B<CONFIG_UTS> が有効になっていなかった。"

#. type: TP
#: build/C/man2/clone.2:890 build/C/man2/setns.2:85 build/C/man2/unshare.2:193
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/clone.2:895
msgid ""
"Cannot allocate sufficient memory to allocate a task structure for the "
"child, or to copy those parts of the caller's context that need to be copied."
msgstr ""
"子プロセスのために確保すべきタスク構造体や、呼び出し元のコンテキストの 一部を"
"コピーするのに必要なメモリを十分に割り当てることができない。"

#. type: TP
#: build/C/man2/clone.2:895 build/C/man2/clone.2:904
#: build/C/man2/sched_setaffinity.2:136 build/C/man2/sched_setparam.2:102
#: build/C/man2/sched_setscheduler.2:439 build/C/man2/setns.2:88
#: build/C/man2/unshare.2:197
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/clone.2:904
msgid ""
"B<CLONE_NEWIPC>, B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, or "
"B<CLONE_NEWUTS> was specified by an unprivileged process (process without "
"B<CAP_SYS_ADMIN>)."
msgstr ""
"非特権プロセス (B<CAP_SYS_ADMIN> を持たないプロセス) が B<CLONE_NEWIPC>, "
"B<CLONE_NEWNET>, B<CLONE_NEWNS>, B<CLONE_NEWPID>, B<CLONE_NEWUTS> を指定し"
"た。"

#. type: Plain text
#: build/C/man2/clone.2:908
msgid "B<CLONE_PID> was specified by a process other than process 0."
msgstr "PID が 0 以外のプロセスによって B<CLONE_PID> が指定された。"

#. type: Plain text
#: build/C/man2/clone.2:915
msgid ""
"There is no entry for B<clone>()  in libc5.  glibc2 provides B<clone>()  as "
"described in this manual page."
msgstr ""
"libc5 には B<clone>()  はない。glibc2 では B<clone>()  が提供されており、この"
"マニュアルページに記載の通りである。"

#. type: Plain text
#: build/C/man2/clone.2:922
msgid ""
"The B<clone>()  and B<sys_clone> calls are Linux-specific and should not be "
"used in programs intended to be portable."
msgstr ""
"B<clone>()  と B<sys_clone> コールは Linux 特有であり、移植を考慮したプログラ"
"ムでは使用すべき ではない。"

#. type: Plain text
#: build/C/man2/clone.2:932
msgid ""
"In the kernel 2.4.x series, B<CLONE_THREAD> generally does not make the "
"parent of the new thread the same as the parent of the calling process.  "
"However, for kernel versions 2.4.7 to 2.4.18 the B<CLONE_THREAD> flag "
"implied the B<CLONE_PARENT> flag (as in kernel 2.6)."
msgstr ""
"カーネル 2.4.x 系列では、一般的には B<CLONE_THREAD> フラグを指定しても新しい"
"スレッドの親を 呼び出し元プロセスの親と同じにはしない。 しかし、バージョン "
"2.4.7〜2.4.18 のカーネルでは、 (カーネル 2.6 と同じように) CLONE_THREAD フラ"
"グを指定すると、 暗黙のうちに CLONE_PARENT フラグを指定したことになる。"

#. type: Plain text
#: build/C/man2/clone.2:942
msgid ""
"For a while there was B<CLONE_DETACHED> (introduced in 2.5.32): parent wants "
"no child-exit signal.  In 2.6.2 the need to give this together with "
"B<CLONE_THREAD> disappeared.  This flag is still defined, but has no effect."
msgstr ""
"B<CLONE_DETACHED> というフラグが、2.5.32 で導入されて以来しばらくの間存在し"
"た。 このフラグは親プロセスが子プロセス終了のシグナルを必要としないことを 表"
"すものである。 2.6.2 で、 CLONE_DETATCHED を CLONE_THREAD と一緒に指定する必"
"要はなくなった。 このフラグはまだ定義されているが、何の効果もない。"

#. type: Plain text
#: build/C/man2/clone.2:947
msgid ""
"On i386, B<clone>()  should not be called through vsyscall, but directly "
"through I<int $0x80>."
msgstr ""
"i386 上では、 B<clone>()  は vsyscall 経由ではなく、直接 I<int $0x80> 経由で"
"呼び出すべきである。"

#. type: Plain text
#: build/C/man2/clone.2:949
msgid "On ia64, a different system call is used:"
msgstr "ia64 では、別のシステムコールが使用される:"

#. type: Plain text
#: build/C/man2/clone.2:956
#, no-wrap
msgid ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"
msgstr ""
"B<int __clone2(int (*>I<fn>B<)(void *), >\n"
"B<             void *>I<child_stack_base>B<, size_t >I<stack_size>B<,>\n"
"B<             int >I<flags>B<, void *>I<arg>B<, ... >\n"
"B<          /* pid_t *>I<ptid>B<, struct user_desc *>I<tls>B<, pid_t *>I<ctid>B< */ );>\n"

#. type: Plain text
#: build/C/man2/clone.2:969
msgid ""
"The B<__clone2>()  system call operates in the same way as B<clone>(), "
"except that I<child_stack_base> points to the lowest address of the child's "
"stack area, and I<stack_size> specifies the size of the stack pointed to by "
"I<child_stack_base>."
msgstr ""
"B<__clone2>()  システムコールは B<clone>()  と同じように動作するが、以下の点"
"が異なる: I<child_stack_base> は子プロセスのスタックエリアの最小のアドレスを"
"指し、 I<stack_size> は I<child_stack_base> が指し示すスタックエリアの大きさ"
"を示す。"

#. type: Plain text
#: build/C/man2/clone.2:1000
msgid ""
"Versions of the GNU C library that include the NPTL threading library "
"contain a wrapper function for B<getpid>(2)  that performs caching of PIDs.  "
"This caching relies on support in the glibc wrapper for B<clone>(), but as "
"currently implemented, the cache may not be up to date in some "
"circumstances.  In particular, if a signal is delivered to the child "
"immediately after the B<clone>()  call, then a call to B<getpid>(2)  in a "
"handler for the signal may return the PID of the calling process (\"the "
"parent\"), if the clone wrapper has not yet had a chance to update the PID "
"cache in the child.  (This discussion ignores the case where the child was "
"created using B<CLONE_THREAD>, when B<getpid>(2)  I<should> return the same "
"value in the child and in the process that called B<clone>(), since the "
"caller and the child are in the same thread group.  The stale-cache problem "
"also does not occur if the I<flags> argument includes B<CLONE_VM>.)  To get "
"the truth, it may be necessary to use code such as the following:"
msgstr ""
"NPTL スレッド・ライブラリを含んでいる GNU C ライブラリのいくつかのバージョン "
"には、 B<getpid>(2)  のラッパー関数が含まれており、このラッパー関数は PID を"
"キャッシュする。 このキャッシュ処理が正しく動作するためには glibc の B<clone>"
"()  のラッパー関数での助けが必要だが、現状の実装では、 ある状況下において"
"キャッシュが最新とならない可能性がある。 特に、 B<clone>()  の呼び出し直後に"
"シグナルが子プロセスに配送された場合に、 そのシグナルに対するハンドラ内で "
"B<getpid>(2)  を呼び出すと、それまでに clone のラッパー関数が子プロセスの "
"PID キャッシュを 更新する機会が得られていなければ、呼び出し元プロセス (\"親プ"
"ロセス\") の PID が 返される可能性がある。 (この議論では、子プロセスが "
"B<CLONE_THREAD> を使って作成された場合のことは無視している。 子プロセスが "
"B<CLONE_THREAD> を作って作成された場合には、 呼び出し元と子プロセスは同じス"
"レッド・グループに属すので、 B<getpid>(2)  は子プロセスと B<clone>()  を呼び"
"出したプロセスで同じ値を返すのが「正しい」。 キャッシュが最新とならない問題 "
"(stale-cache problem) は、 I<flags> に B<CLONE_VM> が含まれている場合にも発生"
"しない。)  本当の値を得るためには、次のようなコードを使う必要があるかもしれな"
"い。"

#. type: Plain text
#: build/C/man2/clone.2:1003
#, no-wrap
msgid "    #include E<lt>syscall.hE<gt>\n"
msgstr "    #include E<lt>syscall.hE<gt>\n"

#. type: Plain text
#: build/C/man2/clone.2:1005
#, no-wrap
msgid "    pid_t mypid;\n"
msgstr "    pid_t mypid;\n"

#. type: Plain text
#: build/C/man2/clone.2:1007
#, no-wrap
msgid "    mypid = syscall(SYS_getpid);\n"
msgstr "    mypid = syscall(SYS_getpid);\n"

#. type: Plain text
#: build/C/man2/clone.2:1023
msgid ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<set_thread_area>(2), "
"B<set_tid_address>(2), B<tkill>(2), B<unshare>(2), B<wait>(2), "
"B<capabilities>(7), B<pthreads>(7)"
msgstr ""
"B<fork>(2), B<futex>(2), B<getpid>(2), B<gettid>(2), B<set_thread_area>(2), "
"B<set_tid_address>(2), B<tkill>(2), B<unshare>(2), B<wait>(2), "
"B<capabilities>(7), B<pthreads>(7)"

#. type: TH
#: build/C/man2/sched_get_priority_max.2:30
#, no-wrap
msgid "SCHED_GET_PRIORITY_MAX"
msgstr "SCHED_GET_PRIORITY_MAX"

#. type: TH
#: build/C/man2/sched_get_priority_max.2:30 build/C/man2/sched_setparam.2:31
#, no-wrap
msgid "2006-03-23"
msgstr "2006-03-23"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:33
msgid ""
"sched_get_priority_max, sched_get_priority_min - get static priority range"
msgstr ""
"sched_get_priority_max, sched_get_priority_min - 静的プライオリティの範囲を取"
"得する"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:35
#: build/C/man2/sched_rr_get_interval.2:35 build/C/man2/sched_yield.2:35
msgid "B<#include E<lt>sched.hE<gt>>"
msgstr "B<#include E<lt>sched.hE<gt>>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:37
msgid "B<int sched_get_priority_max(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_max(int >I<policy>B<);>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:39
msgid "B<int sched_get_priority_min(int >I<policy>B<);>"
msgstr "B<int sched_get_priority_min(int >I<policy>B<);>"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:55
msgid ""
"B<sched_get_priority_max>()  returns the maximum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  "
"B<sched_get_priority_min>()  returns the minimum priority value that can be "
"used with the scheduling algorithm identified by I<policy>.  Supported "
"I<policy> values are B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>, and "
"B<SCHED_BATCH>.  Further details about these policies can be found in "
"B<sched_setscheduler>(2)."
msgstr ""
"B<sched_get_priority_max>()  はI<policy> によって指定されたスケジューリングの"
"アルゴリズムで 使用されるプライオリティの最大値を返す。 "
"B<sched_get_priority_min>()  はI<policy> によって指定されたスケジューリングの"
"アルゴリズムで 使用されるプライオリティの最小値を返す。 サポートされる "
"I<policy> の値は B<SCHED_FIFO>、 B<SCHED_RR>、 B<SCHED_OTHER>、 "
"B<SCHED_BATCH> である。これらのスケジューリング方針に関する詳細は "
"B<sched_setscheduler>(2)  に書かれている。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:64
msgid ""
"Processes with numerically higher priority values are scheduled before "
"processes with numerically lower priority values.  Thus, the value returned "
"by B<sched_get_priority_max>()  will be greater than the value returned by "
"B<sched_get_priority_min>()."
msgstr ""
"数値的に大きなプライオリティ値を持つプロセスは小さな プライオリティ値を持つプ"
"ロセスより前にスケジュールされる。 このため B<sched_get_priority_max>()  が返"
"す値は B<sched_get_priority_min>()  が返す値よりも大きい。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:70
msgid ""
"Linux allows the static priority value range 1 to 99 for B<SCHED_FIFO> and "
"B<SCHED_RR> and the priority 0 for B<SCHED_OTHER> and B<SCHED_BATCH>.  "
"Scheduling priority ranges for the various policies are not alterable."
msgstr ""
"Linux では B<SCHED_FIFO> と B<SCHED_RR> では 1 から 99 の範囲の 静的プライオ"
"リティーを持ち、B<SCHED_OTHER> と B<SCHED_BATCH> では プライオリティとして 0 "
"を持つ。 それぞれの方針のスケジューリング・プライオリティの範囲は 変更するこ"
"とができない。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:79
msgid ""
"The range of scheduling priorities may vary on other POSIX systems, thus it "
"is a good idea for portable applications to use a virtual priority range and "
"map it to the interval given by B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>().  POSIX.1-2001 requires a spread of at least 32 "
"between the maximum and the minimum values for B<SCHED_FIFO> and B<SCHED_RR>."
msgstr ""
"スケジューリング・プライオリティの範囲は他の POSIX システムと 異なっているか"
"もしれない。それで、移植性(portable)のある アプリケーションでは仮想的な範囲を"
"用い B<sched_get_priority_max>()  と B<sched_get_priority_min>()  で与えられ"
"た間隔にマップして使用することはいい考えである。 POSIX.1-2001 では "
"B<SCHED_FIFO> と B<SCHED_RR> における 最大値と最小値の間隔を少なくとも 32 に"
"することを要求している。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:87
msgid ""
"POSIX systems on which B<sched_get_priority_max>()  and "
"B<sched_get_priority_min>()  are available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムでは B<sched_get_priority_max>()  と B<sched_get_priority_min>"
"()  は I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が定義されてい"
"る場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:97
msgid ""
"On success, B<sched_get_priority_max>()  and B<sched_get_priority_min>()  "
"return the maximum/minimum priority value for the named scheduling policy.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_get_priority_max>()  と B<sched_get_priority_min>()  "
"は指定されたスケジューリング方針のプライオリティの最大値/最小値を返す。 エ"
"ラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:101
msgid "The argument I<policy> does not identify a defined scheduling policy."
msgstr "引き数 I<policy> が定義されているスケジューリング方針と一致しない。"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:103
#: build/C/man2/sched_rr_get_interval.2:94 build/C/man2/sched_setparam.2:113
#: build/C/man2/sched_yield.2:55
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:110
msgid ""
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2)"
msgstr ""
"B<sched_getaffinity>(2), B<sched_getparam>(2)  B<sched_getscheduler>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_setscheduler>(2),"

#. type: Plain text
#: build/C/man2/sched_get_priority_max.2:113
#: build/C/man2/sched_rr_get_interval.2:125 build/C/man2/sched_setparam.2:127
#: build/C/man2/sched_setscheduler.2:538 build/C/man2/sched_yield.2:85
msgid ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly "
"& Associates, Inc., ISBN 1-56592-074-0"
msgstr ""
"I<Programming for the real world - POSIX.4> by Bill O. Gallmeister, O'Reilly "
"& Associates, Inc., ISBN 1-56592-074-0"

#. type: TH
#: build/C/man3/sched_getcpu.3:24
#, no-wrap
msgid "SCHED_GETCPU"
msgstr "SCHED_GETCPU"

#. type: TH
#: build/C/man3/sched_getcpu.3:24
#, no-wrap
msgid "2010-10-31"
msgstr "2010-10-31"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:27
msgid "sched_getcpu - determine CPU on which the calling thread is running"
msgstr "sched_getcpu - 呼び出したスレッドが実行されている CPU を知る"

#.  Really:_BSD_SOURCE || _SVID_SOURCE
#. type: Plain text
#: build/C/man3/sched_getcpu.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>sched.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:34
#, no-wrap
msgid "B<int sched_getcpu(void);>\n"
msgstr "B<int sched_getcpu(void);>\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:38
msgid ""
"B<sched_getcpu>()  returns the number of the CPU on which the calling thread "
"is currently executing."
msgstr ""
"B<sched_getcpu>()  は、呼び出したスレッドが現在実行されている CPU の番号を返"
"す。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:45
msgid ""
"On success, B<sched_getcpu>()  returns a nonnegative CPU number.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<sched_getcpu>()  は非負の CPU 番号を返す。 エラーの場合、-1 を"
"返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/sched_getcpu.3:46 build/C/man2/sched_rr_get_interval.2:86
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:50
msgid "This kernel does not implement B<getcpu>(2)."
msgstr "このカーネルでは B<getcpu>(2)  が実装されていない。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:52
msgid "This function is available since glibc 2.6."
msgstr "この関数は glibc 2.6 以降で利用可能である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:55
msgid "B<sched_getcpu>()  is glibc specific."
msgstr "B<sched_getcpu>()  は glibc 固有である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:57
msgid "The call"
msgstr "呼び出し"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:61
#, no-wrap
msgid "cpu = sched_getcpu();\n"
msgstr "cpu = sched_getcpu();\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:67
msgid "is equivalent to the following B<getcpu>(2)  call:"
msgstr "は、以下の B<getcpu>(2)  呼び出しと等価である。"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:73
#, no-wrap
msgid ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"
msgstr ""
"int c, s;\n"
"s = getcpu(&c, NULL, NULL);\n"
"cpu = (s == -1) ? s : c;\n"

#. type: Plain text
#: build/C/man3/sched_getcpu.3:77
msgid "B<getcpu>(2)"
msgstr "B<getcpu>(2)"

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:30
#, no-wrap
msgid "SCHED_RR_GET_INTERVAL"
msgstr "SCHED_RR_GET_INTERVAL"

#. type: TH
#: build/C/man2/sched_rr_get_interval.2:30
#, no-wrap
msgid "2007-04-06"
msgstr "2007-04-06"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:33
msgid "sched_rr_get_interval - get the SCHED_RR interval for the named process"
msgstr "sched_rr_get_interval - 指定されたプロセスの SCHED_RR 間隔を取得する"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:37
msgid ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec * >I<tp>B<);>"
msgstr ""
"B<int sched_rr_get_interval(pid_t >I<pid>B<, struct timespec *>I<tp>B<);>"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:41
msgid ""
"B<sched_rr_get_interval>()  writes into the I<timespec> structure pointed to "
"by I<tp> the round-robin time quantum for the process identified by I<pid>."
msgstr ""
"B<sched_rr_get_interval>()  は I<tp> で指定された I<timespec> 構造体に "
"I<pid> で指定されたプロセスのラウンド・ロビン時間量 (round robin time "
"quantum) を書き込む。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:43
msgid "The I<timespec> structure has the following form:"
msgstr "I<timespec> 構造体は以下の通りである:"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:50
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;    /* seconds */\n"
"    long   tv_nsec;   /* nanoseconds */\n"
"};\n"

#.  FIXME . On Linux, sched_rr_get_interval()
#.  returns the timeslice for SCHED_OTHER processes -- this timeslice
#.  is influenced by the nice value.
#.  For SCHED_FIFO processes, this always returns 0.
#.  The round-robin time quantum value is not alterable under Linux
#.  1.3.81.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:72
msgid ""
"If I<pid> is zero, the time quantum for the calling process is written into "
"I<*tp>.  The identified process should be running under the B<SCHED_RR> "
"scheduling policy.  POSIX systems on which B<sched_rr_get_interval>()  is "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"I<pid> がゼロの場合、呼び出したプロセスの時間量が I<*tp> に書き込まれる。指定"
"したプロセスは B<SCHED_RR> スケジューリング方針で稼動している必要がある。 "
"B<sched_rr_get_interval>()  の使用可能な POSIX システムでは I<E<lt>unistd."
"hE<gt>> で B<_POSIX_PRIORITY_SCHEDULING> が定義されている。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:79
msgid ""
"On success, B<sched_rr_get_interval>()  returns 0.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_rr_get_interval>()  は 0 を返す。 エラーの場合は -1 が"
"返され、 I<errno> が適切に設定される。"

#. type: TP
#: build/C/man2/sched_rr_get_interval.2:80
#: build/C/man2/sched_setaffinity.2:118
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:83
msgid "Problem with copying information to userspace."
msgstr "情報をユーザ空間にコピーする時に問題が起きた。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:86
msgid "Invalid pid."
msgstr "PID が不正である。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:89
msgid "The system call is not yet implemented (only on rather old kernels)."
msgstr ""
"システム・コールがまだ実装されていない (かなり古いカーネルにおいてのみ)。"

#. type: TP
#: build/C/man2/sched_rr_get_interval.2:89
#: build/C/man2/sched_setaffinity.2:146 build/C/man2/sched_setparam.2:108
#: build/C/man2/sched_setscheduler.2:442
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:92
#: build/C/man2/sched_setaffinity.2:149 build/C/man2/sched_setparam.2:111
#: build/C/man2/sched_setscheduler.2:445
msgid "The process whose ID is I<pid> could not be found."
msgstr "プロセス ID I<pid> のプロセスが見つからなかった。"

#. type: SS
#: build/C/man2/sched_rr_get_interval.2:95
#, no-wrap
msgid "Linux Notes"
msgstr "Linux での注意"

#.  FIXME
#.  From at least Linux 2.6.9, the following is no longer true
#.  for SCHED_RR processes.  For RR processes the timeslice is always
#.  DEF_TIMESLICE, or 0.1 secs.
#.  Was the following really true for older kernels?
#.  Must build a 2.6.8 kernel and retest, and rewrite the following text
#.  appropriately.
#.  .SH BUGS
#.  As of Linux 1.3.81
#.  .BR sched_rr_get_interval ()
#.  returns with error
#.  ENOSYS, because SCHED_RR has not yet been fully implemented and tested
#.  properly.
#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:119
msgid ""
"POSIX does not specify any mechanism for controlling the size of the round-"
"robin time quantum.  However, Linux provides a (nonportable) method of doing "
"this.  The quantum can be controlled by adjusting the process's nice value "
"(see B<setpriority>(2)).  Assigning a negative (i.e., high) nice value "
"results in a longer quantum; assigning a positive (i.e., low) nice value "
"results in a shorter quantum.  The default quantum is 0.1 seconds; the "
"degree to which changing the nice value affects the quantum has varied "
"somewhat across kernel versions."
msgstr ""
"POSIX ではラウンド・ロビン時間量の大きさを制御する仕組みが規定されていない。 "
"しかし、Linux ではこれを変更する方法が提供されており (この方法に移植性はな"
"い)、 プロセスの nice 値を調整することで時間量を制御できる (B<setpriority>"
"(2)  参照)。 負の nice 値 (すなわち、高い nice 値) を割り当てると時間量は長く"
"なり、 正の nice 値 (すなわち、低い nice 値) を割り当てると時間量は短くな"
"る。 デフォルトの時間量は 0.1 秒である。 nice 値の変更が時間量にどの程度影響"
"を与えるかは カーネルのバージョンにより多少異なる。"

#. type: Plain text
#: build/C/man2/sched_rr_get_interval.2:122
#: build/C/man2/sched_setaffinity.2:178
msgid ""
"B<sched_setscheduler>(2)  has a description of the Linux scheduling scheme."
msgstr ""
"B<sched_setscheduler>(2)  に Linux のスケジューリング方式についての説明があ"
"る。"

#. type: TH
#: build/C/man2/sched_setaffinity.2:35
#, no-wrap
msgid "SCHED_SETAFFINITY"
msgstr "SCHED_SETAFFINITY"

#. type: TH
#: build/C/man2/sched_setaffinity.2:35
#, no-wrap
msgid "2010-11-06"
msgstr "2010-11-06"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:39
msgid ""
"sched_setaffinity, sched_getaffinity - set and get a process's CPU affinity "
"mask"
msgstr ""
"sched_setaffinity, sched_getaffinity - プロセスの CPU affinity マスクを設定・"
"取得する"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:46
#, no-wrap
msgid ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_setaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:49
#, no-wrap
msgid ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"
msgstr ""
"B<int sched_getaffinity(pid_t >I<pid>B<, size_t >I<cpusetsize>B<,>\n"
"B<                      cpu_set_t *>I<mask>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:64
msgid ""
"A process's CPU affinity mask determines the set of CPUs on which it is "
"eligible to run.  On a multiprocessor system, setting the CPU affinity mask "
"can be used to obtain performance benefits.  For example, by dedicating one "
"CPU to a particular process (i.e., setting the affinity mask of that process "
"to specify a single CPU, and setting the affinity mask of all other "
"processes to exclude that CPU), it is possible to ensure maximum execution "
"speed for that process.  Restricting a process to run on a single CPU also "
"avoids the performance cost caused by the cache invalidation that occurs "
"when a process ceases to execute on one CPU and then recommences execution "
"on a different CPU."
msgstr ""
"プロセスの CPU affinity (親和度) マスクは、そのプロセスが 実行を許可されてい"
"る CPU の集合を決定する。 マルチプロセッサ・システムでは、CPU affinity マスク"
"を設定することで 性能上のメリットを得られる可能性がある。 例えば、特定のプロ"
"セスを一つの CPU に括り付け (すなわち、そのプロセスの affinity マスクを一つ"
"の CPU に設定し)、 他の全てのプロセスの affinity マスクからその CPU を除外す"
"ることで、 確実にそのプロセスの実行速度を最大にすることができる。 また、ある"
"プロセスの実行を一つの CPU に限定することで、 一つの CPU での実行を停止してか"
"ら別の CPU で実行を再開するときに発生する キャッシュ無効化 (cache "
"invalidation) による性能面の劣化を避けることもできる。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:71
msgid ""
"A CPU affinity mask is represented by the I<cpu_set_t> structure, a \"CPU set"
"\", pointed to by I<mask>.  A set of macros for manipulating CPU sets is "
"described in B<CPU_SET>(3)."
msgstr ""
"CPU affinity マスクは「CPU の集合」を表す I<cpu_set_t> 構造体で表現され、 "
"I<cpu_set_t> へのポインタ I<mask> で指定される。 CPU 集合を操作するためのマク"
"ロ群については B<CPU_SET>(3)  で記載されている。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:86
msgid ""
"B<sched_setaffinity>()  sets the CPU affinity mask of the process whose ID "
"is I<pid> to the value specified by I<mask>.  If I<pid> is zero, then the "
"calling process is used.  The argument I<cpusetsize> is the length (in "
"bytes) of the data pointed to by I<mask>.  Normally this argument would be "
"specified as I<sizeof(cpu_set_t)>."
msgstr ""
"B<sched_setaffinity>()  は、プロセスID が I<pid> のプロセスの CPU affinity マ"
"スクを I<mask> で指定された値に設定する。 I<pid> が 0 の場合、呼び出し元プロ"
"セスが使われる。 I<cpusetsize> 引き数には I<mask> が指すデータの長さ (バイト"
"単位) である。 通常は、この引き数には I<sizeof(cpu_set_t)> を指定すればよい。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:93
msgid ""
"If the process specified by I<pid> is not currently running on one of the "
"CPUs specified in I<mask>, then that process is migrated to one of the CPUs "
"specified in I<mask>."
msgstr ""
"I<pid> で指定されたプロセスが I<mask> で指定された CPU のいずれかで現在実行さ"
"れていない場合、 そのプロセスは I<mask> で指定された CPU のいずれかに移動され"
"る。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:108
msgid ""
"B<sched_getaffinity>()  writes the affinity mask of the process whose ID is "
"I<pid> into the I<cpu_set_t> structure pointed to by I<mask>.  The "
"I<cpusetsize> argument specifies the size (in bytes) of I<mask>.  If I<pid> "
"is zero, then the mask of the calling process is returned."
msgstr ""
"B<sched_getaffinity>()  は、 プロセスID が I<pid> のプロセスの affinity マス"
"クを I<mask> が指す I<cpu_set_t> 構造体に書き込む。 I<cpusetsize> 引き数には "
"I<mask> の (バイト単位の) 大きさを指定する。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:117
msgid ""
"On success, B<sched_setaffinity>()  and B<sched_getaffinity>()  return 0.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<sched_setaffinity>()  と B<sched_getaffinity>()  は 0 を返"
"す。 エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:121
msgid "A supplied memory address was invalid."
msgstr "指定されたメモリ番地が不正である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:129
msgid ""
"The affinity bit mask I<mask> contains no processors that are currently "
"physically on the system and permitted to the process according to any "
"restrictions that may be imposed by the \"cpuset\" mechanism described in "
"B<cpuset>(7)."
msgstr ""
"システム上に現在実際に存在し、かつ \"cpuset\" 機構が課す制限においてそのプロ"
"セスに対して許可されている プロセッサが、 affinity ビットマスク I<mask> に含"
"まれていない。 \"cpuset\" 機構については B<cpuset>(7)  を参照。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:136
msgid ""
"(B<sched_getaffinity>()  and, in kernels before 2.6.9, B<sched_setaffinity>"
"())  I<cpusetsize> is smaller than the size of the affinity mask used by the "
"kernel."
msgstr ""
"(B<sched_getaffinity>()  と、カーネル 2.6.9 以前の B<sched_setaffinity>())  "
"I<cpusetsize> がカーネルで使われている affinity マスクのサイズより小さい。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:146
msgid ""
"(B<sched_setaffinity>())  The calling process does not have appropriate "
"privileges.  The caller needs an effective user ID equal to the real user ID "
"or effective user ID of the process identified by I<pid>, or it must possess "
"the B<CAP_SYS_NICE> capability."
msgstr ""
"(B<sched_setaffinity>())  呼び出し元のプロセスに適切な特権がなかった。 呼び出"
"し元は、実効ユーザ ID が I<pid> で識別されるプロセスの実ユーザ ID または実効"
"ユーザ ID と同じであるか、 B<CAP_SYS_NICE> ケーパビリティ (capability) を持た"
"なければならない。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:160
msgid ""
"The CPU affinity system calls were introduced in Linux kernel 2.5.8.  The "
"system call wrappers were introduced in glibc 2.3.  Initially, the glibc "
"interfaces included a I<cpusetsize> argument, typed as I<unsigned int>.  In "
"glibc 2.3.3, the I<cpusetsize> argument was removed, but was then restored "
"in glibc 2.3.4, with type I<size_t>."
msgstr ""
"CPU affinity システムコールは Linux kernel 2.5.8 で導入された。 これらのシス"
"テムコールのラッパー関数は glibc 2.3 で導入された。 最初は、glibc のインタ"
"フェースには I<unsigned int> 型の I<cpusetsize> 引き数が入っていた。 glibc "
"2.3.3 では I<cpusetsize> 引き数が削除されたが、glibc 2.3.4 で I<size_t> 型で"
"復活した。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:162
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:175
msgid ""
"After a call to B<sched_setaffinity>(), the set of CPUs on which the process "
"will actually run is the intersection of the set specified in the I<mask> "
"argument and the set of CPUs actually present on the system.  The system may "
"further restrict the set of CPUs on which the process runs if the \"cpuset\" "
"mechanism described in B<cpuset>(7)  is being used.  These restrictions on "
"the actual set of CPUs on which the process will run are silently imposed by "
"the kernel."
msgstr ""
"B<sched_setaffinity>()  を呼び出した後は、プロセスが実際に実行される CPU の集"
"合は、 I<mask> 引き数で指定された集合と、システム上に実際に存在する CPU の集"
"合の 共通集合 (AND) となる。 \"cpuset\" 機構が使用されている場合には、プロセ"
"スが動作する CPU 集合 に対してシステムはさらに制限を加えるかもしれない "
"(\"cpuset\" 機構については B<cpuset>(7)  を参照)。 プロセスが動作する実際の "
"CPU 集合に対する制限はカーネルにより 暗黙のうちに適用される。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:195
msgid ""
"The affinity mask is actually a per-thread attribute that can be adjusted "
"independently for each of the threads in a thread group.  The value returned "
"from a call to B<gettid>(2)  can be passed in the argument I<pid>.  "
"Specifying I<pid> as 0 will set the attribute for the calling thread, and "
"passing the value returned from a call to B<getpid>(2)  will set the "
"attribute for the main thread of the thread group.  (If you are using the "
"POSIX threads API, then use B<pthread_setaffinity_np>(3)  instead of "
"B<sched_setaffinity>().)"
msgstr ""
"実際には affinity マスクはスレッド単位の属性で、スレッドグループの 各スレッド"
"単位に独立して調整することができる。 B<gettid>(2)  コールからの返り値をこの"
"コールの I<pid> 引き数として渡すことができる。 I<pid> に 0 を指定すると呼び出"
"し元のスレッドの属性が設定され、 B<getpid>(2)  コールからの返り値を I<pid> に"
"指定するとスレッドグループのメインスレッドの属性が設定される (POSIX スレッド "
"API を使用している場合、 B<sched_setaffinity>()  の代わりに "
"B<pthread_setaffinity_np>(3)  を使用すること)。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:201
msgid ""
"A child created via B<fork>(2)  inherits its parent's CPU affinity mask.  "
"The affinity mask is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で生成された子プロセスは親プロセスの CPU affinity マスクを継"
"承する。 affinity マスクは B<execve>(2)  の前後で保存される。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:215
msgid ""
"This manual page describes the glibc interface for the CPU affinity calls.  "
"The actual system call interface is slightly different, with the I<mask> "
"being typed as I<unsigned long *>, reflecting the fact that the underlying "
"implementation of CPU sets is a simple bit mask.  On success, the raw "
"B<sched_getaffinity>()  system call returns the size (in bytes) of the "
"I<cpumask_t> data type that is used internally by the kernel to represent "
"the CPU set bit mask."
msgstr ""
"このマニュアルページでは CPU affinity コールの glibc インタフェースを 説明し"
"ている。実際のシステムコール・インタフェースは少し違っており、 実際の実装で"
"は CPU 集合は簡単なビットマスクであるという実状を反映し、 I<mask> の型が "
"I<unsigned long *> となっている。 成功時には、生の B<sched_getaffinity>()  シ"
"ステムコール自身は I<cpumask_t> データ型の (バイト単位の) 大きさを返す。 "
"I<cpumask_t> はカーネル内部で CPU 集合のビットマスクを表現するのに 使われてい"
"るデータ型である。"

#. type: Plain text
#: build/C/man2/sched_setaffinity.2:231
msgid ""
"B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), B<nice>(2), "
"B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7)"
msgstr ""
"B<clone>(2), B<getcpu>(2), B<getpriority>(2), B<gettid>(2), B<nice>(2), "
"B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getscheduler>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<CPU_SET>(3), B<pthread_setaffinity_np>(3), B<sched_getcpu>(3), "
"B<capabilities>(7), B<cpuset>(7)"

#. type: TH
#: build/C/man2/sched_setparam.2:31
#, no-wrap
msgid "SCHED_SETPARAM"
msgstr "SCHED_SETPARAM"

#. type: Plain text
#: build/C/man2/sched_setparam.2:34
msgid "sched_setparam, sched_getparam - set and get scheduling parameters"
msgstr ""
"sched_setparam, sched_getparam - スケジューリング・パラメータの設定と取得を行"
"なう"

#. type: Plain text
#: build/C/man2/sched_setparam.2:37 build/C/man2/sched_setscheduler.2:54
#, no-wrap
msgid "B<#include E<lt>sched.hE<gt>>\n"
msgstr "B<#include E<lt>sched.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:39
#, no-wrap
msgid "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_setparam(pid_t >I<pid>B<, const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:41
#, no-wrap
msgid "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"
msgstr "B<int sched_getparam(pid_t >I<pid>B<, struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:47 build/C/man2/sched_setscheduler.2:66
#, no-wrap
msgid ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"
msgstr ""
"B<struct sched_param {\n"
"    ...\n"
"    int >I<sched_priority>B<;\n"
"    ...\n"
"};>\n"

#. type: Plain text
#: build/C/man2/sched_setparam.2:61
msgid ""
"B<sched_setparam>()  sets the scheduling parameters associated with the "
"scheduling policy for the process identified by I<pid>.  If I<pid> is zero, "
"then the parameters of the calling process are set.  The interpretation of "
"the argument I<param> depends on the scheduling policy of the process "
"identified by I<pid>.  See B<sched_setscheduler>(2)  for a description of "
"the scheduling policies supported under Linux."
msgstr ""
"B<sched_setparam>()  は I<pid> で指定されたプロセスのスケジューリング方針 "
"(scheduling policy) に 関連するスケジューリング・パラメータを設定する。 "
"I<pid> が 0 ならば、呼び出し元のプロセスのパラメータが設定される。 引き数 "
"I<param> の解釈は、 I<pid> で指定されたプロセスのスケジューリング方針によって"
"異なる。 Linux でサポートされているスケジューリング方針の説明は "
"B<sched_setscheduler>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:67
msgid ""
"B<sched_getparam>()  retrieves the scheduling parameters for the process "
"identified by I<pid>.  If I<pid> is zero, then the parameters of the calling "
"process are retrieved."
msgstr ""
"B<sched_getparam>()  は I<pid> で指定されたプロセスのスケジューリング・パラ"
"メータを取得する。 I<pid> が 0 ならば、呼び出し元のプロセスのパラメータを取得"
"する。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:76
msgid ""
"B<sched_setparam>()  checks the validity of I<param> for the scheduling "
"policy of the process.  The value I<param-E<gt>sched_priority> must lie "
"within the range given by B<sched_get_priority_min>(2)  and "
"B<sched_get_priority_max>(2)."
msgstr ""
"B<sched_setparam>()  はプロセスのスケジューリング方針における I<param> の妥当"
"性をチェックする。 I<param-E<gt>sched_priority> の値は "
"B<sched_get_priority_min>(2)  と B<sched_get_priority_max>(2)  の範囲に入って"
"いなければならない。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:80
msgid ""
"For a discussion of the privileges and resource limits related to scheduling "
"priority and policy, see B<sched_setscheduler>(2)."
msgstr ""
"スケジューリングの優先度と方針に関連する特権とリソース制限の 議論に関しては "
"B<sched_setscheduler>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:88
msgid ""
"POSIX systems on which B<sched_setparam>()  and B<sched_getparam>()  are "
"available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"B<sched_setparam>()  と B<sched_getparam>()  が使用できる POSIX システムで"
"は、 I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が定義されてい"
"る。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:97
msgid ""
"On success, B<sched_setparam>()  and B<sched_getparam>()  return 0.  On "
"error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_setparam>()  と B<sched_getparam>()  は 0 を返す。 エ"
"ラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:102
msgid ""
"The argument I<param> does not make sense for the current scheduling policy."
msgstr "引き数 I<param> が現在のスケジューリング方針においては 無意味である。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:108
msgid ""
"The calling process does not have appropriate privileges (Linux: does not "
"have the B<CAP_SYS_NICE> capability)."
msgstr ""
"呼び出し元のプロセスが適切な特権を持っていない (Linux では、 B<CAP_SYS_NICE> "
"ケーパビリティを持っていない)。"

#. type: Plain text
#: build/C/man2/sched_setparam.2:124
msgid ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getscheduler>"
"(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<capabilities>(7)"
msgstr ""
"B<getpriority>(2), B<nice>(2), B<sched_get_priority_max>(2), "
"B<sched_get_priority_min>(2), B<sched_getaffinity>(2), B<sched_getscheduler>"
"(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<setpriority>(2), "
"B<capabilities>(7)"

#. type: TH
#: build/C/man2/sched_setscheduler.2:47
#, no-wrap
msgid "SCHED_SETSCHEDULER"
msgstr "SCHED_SETSCHEDULER"

#. type: TH
#: build/C/man2/sched_setscheduler.2:47
#, fuzzy, no-wrap
#| msgid "2010-09-10"
msgid "2011-09-19"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:51
msgid ""
"sched_setscheduler, sched_getscheduler - set and get scheduling policy/"
"parameters"
msgstr ""
"sched_setscheduler, sched_getscheduler - スケジューリング・ポリシーとパラメー"
"タを設定/取得する"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:56
#, no-wrap
msgid "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"
msgstr "B<int sched_setscheduler(pid_t >I<pid>B<, int >I<policy>B<,>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:58
#, no-wrap
msgid "B<                       const struct sched_param *>I<param>B<);>\n"
msgstr "B<                       const struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:60
#, no-wrap
msgid "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"
msgstr "B<int sched_getscheduler(pid_t >I<pid>B<);>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:77
msgid ""
"B<sched_setscheduler>()  sets both the scheduling policy and the associated "
"parameters for the process whose ID is specified in I<pid>.  If I<pid> "
"equals zero, the scheduling policy and parameters of the calling process "
"will be set.  The interpretation of the argument I<param> depends on the "
"selected policy.  Currently, Linux supports the following \"normal\" (i.e., "
"non-real-time) scheduling policies:"
msgstr ""
"B<sched_setscheduler>()  は I<pid> で指定された ID を持つプロセスのスケジュー"
"リング・ポリシーや それに関連するパラメータを設定する。I<pid> が 0 の場合は "
"呼び出したプロセスのスケジューリング・ポリシーとパラメータが設定される。 引き"
"数 I<param> の解釈は選択されたポリシーによる。 現在のところ、Linux では 以下"
"に示す「通常」(リアルタイムでない) スケジューリング・ポリシーが サポートされ"
"ている。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:77
#, no-wrap
msgid "B<SCHED_OTHER>"
msgstr "B<SCHED_OTHER>"

#.  In the 2.6 kernel sources, SCHED_OTHER is actually called
#.  SCHED_NORMAL.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:82
msgid "the standard round-robin time-sharing policy;"
msgstr "標準の、ラウンドロビンによる時分割型のスケジューリング・ポリシー。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:82
#, no-wrap
msgid "B<SCHED_BATCH>"
msgstr "B<SCHED_BATCH>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:85
msgid "for \"batch\" style execution of processes; and"
msgstr "「バッチ」形式でのプロセスの実行用。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:85
#, no-wrap
msgid "B<SCHED_IDLE>"
msgstr "B<SCHED_IDLE>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:90
msgid "for running I<very> low priority background jobs."
msgstr "「非常に」低い優先度で動作するバックグラウンド・ジョブ用。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:94
msgid ""
"The following \"real-time\" policies are also supported, for special time-"
"critical applications that need precise control over the way in which "
"runnable processes are selected for execution:"
msgstr ""
"どの実行可能プロセスを選択するかについて、より正確な制御を必要とする 時間の制"
"約が厳しい特別なアプリケーション用として、 以下の「リアルタイム」ポリシーもサ"
"ポートされている。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:94
#, no-wrap
msgid "B<SCHED_FIFO>"
msgstr "B<SCHED_FIFO>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:97
msgid "a first-in, first-out policy; and"
msgstr "ファーストイン、ファーストアウト型のポリシー。"

#. type: TP
#: build/C/man2/sched_setscheduler.2:97
#, no-wrap
msgid "B<SCHED_RR>"
msgstr "B<SCHED_RR>"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:100
msgid "a round-robin policy."
msgstr "ラウンドロビン型のポリシー。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:102
msgid "The semantics of each of these policies are detailed below."
msgstr "これらのポリシーのそれぞれの動作については以下で説明する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:109
msgid ""
"B<sched_getscheduler>()  queries the scheduling policy currently applied to "
"the process identified by I<pid>.  If I<pid> equals zero, the policy of the "
"calling process will be retrieved."
msgstr ""
"B<sched_getscheduler>()  は I<pid> で識別されるプロセスに現在適用されている "
"スケジューリング・ポリシーを尋ねる。I<pid> が 0 ならば、呼び出した プロセス自"
"身のスケジューリング・ポリシーが返される。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:109
#, no-wrap
msgid "Scheduling Policies"
msgstr "スケジューリング・ポリシー (scheduling policy)"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:118
msgid ""
"The scheduler is the kernel component that decides which runnable process "
"will be executed by the CPU next.  Each process has an associated scheduling "
"policy and a I<static> scheduling priority, I<sched_priority>; these are the "
"settings that are modified by B<sched_setscheduler>().  The scheduler makes "
"it decisions based on knowledge of the scheduling policy and static priority "
"of all processes on the system."
msgstr ""
"スケジューラ (scheduler) とはカーネルの構成要素で、 次に CPU で実行される実行"
"可能なプロセスを決定するものである。 各々のプロセスには、スケジューリング・ポ"
"リシーと 「静的」なスケジューリング優先度 I<sched_priority> が対応付けられ、 "
"これらの設定は B<sched_setscheduler>()  で変更できる。 スケジューラは、システ"
"ム上の全プロセスのスケジューリング・ポリシーと 静的優先度に関する知識に基づい"
"て決定を行う。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:123
msgid ""
"For processes scheduled under one of the normal scheduling policies "
"(B<SCHED_OTHER>, B<SCHED_IDLE>, B<SCHED_BATCH>), I<sched_priority> is not "
"used in scheduling decisions (it must be specified as 0)."
msgstr ""
"通常のスケジューリング・ポリシー (B<SCHED_OTHER>, B<SCHED_IDLE>, "
"B<SCHED_BATCH>)  の下でスケジューリングされるプロセスでは、 "
"I<sched_priority> はスケジューリングの決定に使用されない (I<sched_priority> "
"には 0 を指定しなければならない)。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:137
msgid ""
"Processes scheduled under one of the real-time policies (B<SCHED_FIFO>, "
"B<SCHED_RR>) have a I<sched_priority> value in the range 1 (low) to 99 "
"(high).  (As the numbers imply, real-time processes always have higher "
"priority than normal processes.)  Note well: POSIX.1-2001 only requires an "
"implementation to support a minimum 32 distinct priority levels for the real-"
"time policies, and some systems supply just this minimum.  Portable programs "
"should use B<sched_get_priority_min>(2)  and B<sched_get_priority_max>(2)  "
"to find the range of priorities supported for a particular policy."
msgstr ""
"リアルタイム・スケジューリング・ポリシー (B<SCHED_FIFO>, B<SCHED_RR>)  の下で"
"スケジューリングされるプロセスは、 I<sched_priority> の値は 1 (最低) から 99 "
"(最高) の範囲となる (数字から分かるように、リアルタイム・プロセスは常に通常の"
"プロセスよりも 高い優先度を持つ)。 ここで注意すべきなのは、POSIX.1-2001 が要"
"求しているのは、 リアルタイム・ポリシーの実装において最低 32 種類の異なる優先"
"度レベルが サポートされることだけであり、いくつかのシステムではこの最低限の数"
"の 優先度しか提供されていない、ということである。 移植性が必要なプログラムで"
"は、 B<sched_get_priority_min>(2)  と B<sched_get_priority_max>(2)  を使っ"
"て、あるポリシーがサポートする優先度の範囲を調べるべきである。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:143
msgid ""
"Conceptually, the scheduler maintains a list of runnable processes for each "
"possible I<sched_priority> value.  In order to determine which process runs "
"next, the scheduler looks for the nonempty list with the highest static "
"priority and selects the process at the head of this list."
msgstr ""
"概念としては、 スケジューラはその I<sched_priority> の値それぞれに対して 実行"
"可能なプロセスのリストを管理している。 どのプロセスを次に実行するかを決定する"
"ために、 スケジューラは静的優先度の最も高い空でないリストを探して、 そのリス"
"トの先頭のプロセスを選択する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:147
msgid ""
"A process's scheduling policy determines where it will be inserted into the "
"list of processes with equal static priority and how it will move inside "
"this list."
msgstr ""
"各プロセスのスケジューリング・ポリシーは、 そのプロセスが同じ静的優先度を持つ"
"プロセスのリストの中のどこに挿入され、 このリストの中をどのように移動するかを"
"決定する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:155
msgid ""
"All scheduling is preemptive: if a process with a higher static priority "
"becomes ready to run, the currently running process will be preempted and "
"returned to the wait list for its static priority level.  The scheduling "
"policy only determines the ordering within the list of runnable processes "
"with equal static priority."
msgstr ""
"全てのスケジューリングはプリエンプティブ (preemptive) である: より高い優先度"
"のプロセスが実行可能になると、現在実行中のプロセスは実行権を 取り上げられ "
"(preempted)、そのプロセスの静的優先度レベルの待ちリストに 戻される。スケ"
"ジューリング・ポリシーは同じ静的優先度を持つ実行可能な プロセスのリストの中で"
"順番のみを決定する。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:155
#, no-wrap
msgid "SCHED_FIFO: First In-First Out scheduling"
msgstr "SCHED_FIFO: ファーストイン・ファーストアウト・スケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:164
msgid ""
"B<SCHED_FIFO> can only be used with static priorities higher than 0, which "
"means that when a B<SCHED_FIFO> processes becomes runnable, it will always "
"immediately preempt any currently running B<SCHED_OTHER>, B<SCHED_BATCH>, or "
"B<SCHED_IDLE> process.  B<SCHED_FIFO> is a simple scheduling algorithm "
"without time slicing.  For processes scheduled under the B<SCHED_FIFO> "
"policy, the following rules apply:"
msgstr ""
"B<SCHED_FIFO> は 0 より大きな静的優先度でのみ使用できる。このポリシーでは、 "
"B<SCHED_FIFO> プロセスが実行可能になった場合、 そのポリシーが "
"B<SCHED_OTHER>、 B<SCHED_BATCH>、 B<SCHED_IDLE> の 現在実行中のプロセスは直ち"
"に実行権を取り上げられる。 B<SCHED_FIFO> は時分割のない単純なスケジューリン"
"グ・アルゴリズムである。 B<SCHED_FIFO> ポリシーでスケジューリングされているプ"
"ロセスには以下の ルールが適用される:"

#. type: IP
#: build/C/man2/sched_setscheduler.2:164 build/C/man2/sched_setscheduler.2:169
#: build/C/man2/sched_setscheduler.2:172 build/C/man2/sched_setscheduler.2:186
#: build/C/man2/sched_setscheduler.2:288 build/C/man2/sched_setscheduler.2:296
#: build/C/man2/sched_setscheduler.2:337 build/C/man2/sched_setscheduler.2:345
#: build/C/man2/sched_setscheduler.2:350 build/C/man2/sched_setscheduler.2:355
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:169
msgid ""
"A B<SCHED_FIFO> process that has been preempted by another process of higher "
"priority will stay at the head of the list for its priority and will resume "
"execution as soon as all processes of higher priority are blocked again."
msgstr ""
"より高い優先度の他のプロセスによって取って代わられた B<SCHED_FIFO> プロセスは"
"その優先度のリストの先頭に留まり続け、 より高い優先度のプロセス全てが停止 "
"(block) した場合に実行を再開する。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:172
msgid ""
"When a B<SCHED_FIFO> process becomes runnable, it will be inserted at the "
"end of the list for its priority."
msgstr ""
"B<SCHED_FIFO> プロセスが実行可能になった時、その優先度のリストの最後 に挿入さ"
"れる。"

#.  In 2.2.x and 2.4.x, the process is placed at the front of the queue
#.  In 2.0.x, the Right Thing happened: the process went to the back -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:186
msgid ""
"A call to B<sched_setscheduler>()  or B<sched_setparam>(2)  will put the "
"B<SCHED_FIFO> (or B<SCHED_RR>) process identified by I<pid> at the start of "
"the list if it was runnable.  As a consequence, it may preempt the currently "
"running process if it has the same priority.  (POSIX.1-2001 specifies that "
"the process should go to the end of the list.)"
msgstr ""
"B<sched_setscheduler>()  や B<sched_setparam>(2)  は I<pid> で指定された "
"B<SCHED_FIFO> (または B<SCHED_RR>) プロセスが 実行可能な場合、リストの最初に"
"置く。 結果として、もし優先度が同じだった場合、 現在実行中のプロセスに先んじ"
"るかもしれない。 (POSIX.1-2001 ではプロセスはリストの最後に行くべきと規定され"
"ている。)"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:190
msgid ""
"A process calling B<sched_yield>(2)  will be put at the end of the list."
msgstr "B<sched_yield>(2)  を呼び出したプロセスはリストの最後に置かれる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:194
msgid ""
"No other events will move a process scheduled under the B<SCHED_FIFO> policy "
"in the wait list of runnable processes with equal static priority."
msgstr ""
"その他のイベントによって B<SCHED_FIFO> ポリシーで スケジューリングされるプロ"
"セスが同じ優先度の実行可能な プロセスの待ちリストの中を移動することはない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:199
msgid ""
"A B<SCHED_FIFO> process runs until either it is blocked by an I/O request, "
"it is preempted by a higher priority process, or it calls B<sched_yield>(2)."
msgstr ""
"B<SCHED_FIFO> プロセスは I/O 要求によって停止するか、 より高い優先度のプロセ"
"スによって置きかえられるか、 B<sched_yield>(2)  を呼び出すまで実行を続ける。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:199
#, no-wrap
msgid "SCHED_RR: Round Robin scheduling"
msgstr "SCHED_RR: ラウンド・ロビン (round robin) ・スケジューリング"

#.  On Linux 2.4, the length of the RR interval is influenced
#.  by the process nice value -- MTK
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:218
msgid ""
"B<SCHED_RR> is a simple enhancement of B<SCHED_FIFO>.  Everything described "
"above for B<SCHED_FIFO> also applies to B<SCHED_RR>, except that each "
"process is only allowed to run for a maximum time quantum.  If a B<SCHED_RR> "
"process has been running for a time period equal to or longer than the time "
"quantum, it will be put at the end of the list for its priority.  A "
"B<SCHED_RR> process that has been preempted by a higher priority process and "
"subsequently resumes execution as a running process will complete the "
"unexpired portion of its round robin time quantum.  The length of the time "
"quantum can be retrieved using B<sched_rr_get_interval>(2)."
msgstr ""
"B<SCHED_RR> は B<SCHED_FIFO> の単純な拡張である。 上述された B<SCHED_FIFO> に"
"関する記述は全て B<SCHED_RR> に 適用できる。異なるのはそれぞれのプロセスは最"
"大時間単位までしか実行できない ということである。B<SCHED_RR> プロセスが時間単"
"位と同じかそれより 長い時間実行されると、その優先度のリストの最後に置かれ"
"る。 より高い優先度のプロセスによって置きかえられ、その後実行を再開した "
"B<SCHED_RR> プロセスは、そのラウンド・ロビン時間単位を完全に使い切る まで実行"
"される。その時間単位の長さは B<sched_rr_get_interval>(2)  を使って取得でき"
"る。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:218
#, no-wrap
msgid "SCHED_OTHER: Default Linux time-sharing scheduling"
msgstr "SCHED_OTHER: Linux のデフォルトの時分割スケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:234
msgid ""
"B<SCHED_OTHER> can only be used at static priority 0.  B<SCHED_OTHER> is the "
"standard Linux time-sharing scheduler that is intended for all processes "
"that do not require the special real-time mechanisms.  The process to run is "
"chosen from the static priority 0 list based on a I<dynamic> priority that "
"is determined only inside this list.  The dynamic priority is based on the "
"nice value (set by B<nice>(2)  or B<setpriority>(2))  and increased for each "
"time quantum the process is ready to run, but denied to run by the "
"scheduler.  This ensures fair progress among all B<SCHED_OTHER> processes."
msgstr ""
"B<SCHED_OTHER> は静的優先度 0 でのみ使用できる。 B<SCHED_OTHER> は Linux 標準"
"の時分割スケジューラで、 特別なリアルタイム機構を必要としていない全てのプロセ"
"スで使用される。 実行するプロセスは、静的優先度 0 のリストから、このリストの"
"中だけで 決定される「動的な」優先度 (dynamic priority) に基いて決定される。 "
"動的な優先度は (B<nice>(2)  や B<setpriority>(2)  により設定される) nice 値に"
"基づいて決定されるもので、 単位時間毎に、プロセスが実行可能だが、スケジューラ"
"により実行が拒否された 場合にインクリメントされる。 これにより、全ての "
"B<SCHED_OTHER> プロセスでの公平性が保証される。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:234
#, no-wrap
msgid "SCHED_BATCH: Scheduling batch processes"
msgstr "SCHED_BATCH: バッチプロセスのスケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:246
msgid ""
"(Since Linux 2.6.16.)  B<SCHED_BATCH> can only be used at static priority "
"0.  This policy is similar to B<SCHED_OTHER> in that it schedules the "
"process according to its dynamic priority (based on the nice value).  The "
"difference is that this policy will cause the scheduler to always assume "
"that the process is CPU-intensive.  Consequently, the scheduler will apply a "
"small scheduling penalty with respect to wakeup behaviour, so that this "
"process is mildly disfavored in scheduling decisions."
msgstr ""
"(Linux 2.6.16 以降)  B<SCHED_BATCH> は静的優先度 0 でのみ使用できる。 このポ"
"リシーは (nice 値に基づく) 動的な優先度にしたがってプロセスの スケジューリン"
"グが行われるという点で、B<SCHED_OTHER> に似ている。 異なるのは、このポリシー"
"では、プロセスが常に CPU に負荷のかかる (CPU-intensive)  処理を行うと、スケ"
"ジューラが仮定する点である。 スケジューラはプロセスを呼び起こす毎にそのプロセ"
"スにスケジューリング上の ペナルティを少し課し、その結果、このプロセスはスケ"
"ジューリングの決定で 若干冷遇されるようになる。"

#.  The following paragraph is drawn largely from the text that
#.  accompanied Ingo Molnar's patch for the implementation of
#.  SCHED_BATCH.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:255
msgid ""
"This policy is useful for workloads that are noninteractive, but do not want "
"to lower their nice value, and for workloads that want a deterministic "
"scheduling policy without interactivity causing extra preemptions (between "
"the workload's tasks)."
msgstr ""
"このポリシーは、非対話的な処理だがその nice 値を下げたくない処理や、 (処理の"
"タスク間で) 余計なタスクの置き換えの原因とある対話的な処理なしで 確定的な "
"(deterministic) スケジューリング・ポリシーを適用したい処理に 対して有効であ"
"る。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:255
#, no-wrap
msgid "SCHED_IDLE: Scheduling very low priority jobs"
msgstr "SCHED_IDLE: 非常に優先度の低いジョブのスケジューリング"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:259
msgid ""
"(Since Linux 2.6.23.)  B<SCHED_IDLE> can only be used at static priority 0; "
"the process nice value has no influence for this policy."
msgstr ""
"(Linux 2.6.23 以降)  B<SCHED_IDLE> は静的優先度 0 でのみ使用できる。 このポリ"
"シーではプロセスの nice 値はスケジューリングに影響を与えない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:267
msgid ""
"This policy is intended for running jobs at extremely low priority (lower "
"even than a +19 nice value with the B<SCHED_OTHER> or B<SCHED_BATCH> "
"policies)."
msgstr ""
"非常に低い優先度でのジョブの実行を目的としたものである (非常に低い優先度と"
"は、ポリシー B<SCHED_OTHER> か B<SCHED_BATCH> での nice 値 +19 よりさらに低い"
"優先度である)。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:267
#, no-wrap
msgid "Resetting scheduling policy for child processes"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:283
msgid ""
"Since Linux 2.6.32, the B<SCHED_RESET_ON_FORK> flag can be ORed in I<policy> "
"when calling B<sched_setscheduler>().  As a result of including this flag, "
"children created by B<fork>(2)  do not inherit privileged scheduling "
"policies.  This feature is intended for media-playback applications, and can "
"be used to prevent applications evading the B<RLIMIT_RTTIME> resource limit "
"(see B<getrlimit>(2))  by creating multiple child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:288
msgid ""
"More precisely, if the B<SCHED_RESET_ON_FORK> flag is specified, the "
"following rules apply for subsequently created children:"
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:296
msgid ""
"If the calling process has a scheduling policy of B<SCHED_FIFO> or "
"B<SCHED_RR>, the policy is reset to B<SCHED_OTHER> in child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:299
msgid ""
"If the calling process has a negative nice value, the nice value is reset to "
"zero in child processes."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:308
msgid ""
"After the B<SCHED_RESET_ON_FORK> flag has been enabled, it can only be reset "
"if the process has the B<CAP_SYS_NICE> capability.  This flag is disabled in "
"child processes created by B<fork>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:314
msgid ""
"The B<SCHED_RESET_ON_FORK> flag is visible in the policy value returned by "
"B<sched_getscheduler>()"
msgstr ""

#. type: SS
#: build/C/man2/sched_setscheduler.2:314
#, no-wrap
msgid "Privileges and resource limits"
msgstr "特権とリソース制限"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:327
msgid ""
"In Linux kernels before 2.6.12, only privileged (B<CAP_SYS_NICE>)  processes "
"can set a nonzero static priority (i.e., set a real-time scheduling "
"policy).  The only change that an unprivileged process can make is to set "
"the B<SCHED_OTHER> policy, and this can only be done if the effective user "
"ID of the caller of B<sched_setscheduler>()  matches the real or effective "
"user ID of the target process (i.e., the process specified by I<pid>)  whose "
"policy is being changed."
msgstr ""
"2.6.12 より前のバージョンの Linux カーネルでは、 特権プロセス "
"(B<CAP_SYS_NICE> ケーパビリティを持つプロセス) だけが 0 以外の静的優先度を設"
"定する (すなわち、リアルタイム・スケジューリング・ポリシーを設定する) ことが"
"できる。 非特権プロセスができる変更は B<SCHED_OTHER> ポリシーを設定することだ"
"けであり、さらにこの変更を行えるのは B<sched_setscheduler>()  の呼び出し元の"
"実効ユーザ ID がポリシーの変更対象プロセス (I<pid> で指定されたプロセス) の実"
"ユーザ ID か実効ユーザ ID と 一致する場合だけである。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:337
msgid ""
"Since Linux 2.6.12, the B<RLIMIT_RTPRIO> resource limit defines a ceiling on "
"an unprivileged process's static priority for the B<SCHED_RR> and "
"B<SCHED_FIFO> policies.  The rules for changing scheduling policy and "
"priority are as follows:"
msgstr ""
"Linux 2.6.12 以降では、リソース制限 B<RLIMIT_RTPRIO> が定義されており、 スケ"
"ジューリング・ポリシーが B<SCHED_RR> と B<SCHED_FIFO> の場合の、非特権プロセ"
"スの静的優先度の上限を定めている。 スケジューリング・ポリシーと優先度を変更す"
"る際のルールは以下の通りである。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:345
msgid ""
"If an unprivileged process has a nonzero B<RLIMIT_RTPRIO> soft limit, then "
"it can change its scheduling policy and priority, subject to the restriction "
"that the priority cannot be set to a value higher than the maximum of its "
"current priority and its B<RLIMIT_RTPRIO> soft limit."
msgstr ""
"非特権プロセスに 0 以外の B<RLIMIT_RTPRIO> ソフト・リミットが設定されている場"
"合、 非特権プロセスはそのプロセスのスケジューリング・ポリシーと優先度を 変更"
"できるが、優先度を現在の自身の優先度と B<RLIMIT_RTPRIO> ソフト・リミットの大"
"きい方よりも高い値に設定できないという制限が課される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:350
msgid ""
"If the B<RLIMIT_RTPRIO> soft limit is 0, then the only permitted changes are "
"to lower the priority, or to switch to a non-real-time policy."
msgstr ""
"B<RLIMIT_RTPRIO> ソフト・リミットが 0 の場合、優先度を下げるか、 リアルタイム"
"でないポリシーへ切り替えるかの変更だけが許可される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:355
msgid ""
"Subject to the same rules, another unprivileged process can also make these "
"changes, as long as the effective user ID of the process making the change "
"matches the real or effective user ID of the target process."
msgstr ""
"ある非特権プロセスが別のプロセスに対してこれらの変更を行う際にも、 同じルール"
"が適用される。変更を行えるのは、変更を行おうとするプロセス の実効ユーザ ID が"
"変更対象のプロセスの実ユーザ ID か実効ユーザ ID と 一致している場合に限られ"
"る。"

#.  commit c02aa73b1d18e43cfd79c2f193b225e84ca497c8
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:373
msgid ""
"Special rules apply for the B<SCHED_IDLE>.  In Linux kernels before 2.6.39, "
"an unprivileged process operating under this policy cannot change its "
"policy, regardless of the value of its B<RLIMIT_RTPRIO> resource limit.  In "
"Linux kernels since 2.6.39, an unprivileged process can switch to either the "
"B<SCHED_BATCH> or the B<SCHED_NORMAL> policy so long as its nice value falls "
"within the range permitted by its B<RLIMIT_NICE> resource limit (see "
"B<getrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:384
msgid ""
"Privileged (B<CAP_SYS_NICE>)  processes ignore the B<RLIMIT_RTPRIO> limit; "
"as with older kernels, they can make arbitrary changes to scheduling policy "
"and priority.  See B<getrlimit>(2)  for further information on "
"B<RLIMIT_RTPRIO>."
msgstr ""
"特権プロセス (B<CAP_SYS_NICE> ケーパビリティを持つプロセス) の場合、 "
"B<RLIMIT_RTPRIO> の制限は無視される; 古いカーネルと同じように、スケジューリン"
"グ・ポリシーと優先度に対し 任意の変更を行うことができる。 B<RLIMIT_RTPRIO> に"
"関するもっと詳しい情報は B<getrlimit>(2)  を参照のこと。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:384
#, no-wrap
msgid "Response time"
msgstr "応答時間 (response time)"

#.  as described in
#.  .BR request_irq (9).
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:392
msgid ""
"A blocked high priority process waiting for the I/O has a certain response "
"time before it is scheduled again.  The device driver writer can greatly "
"reduce this response time by using a \"slow interrupt\" interrupt handler."
msgstr ""
"I/O 待ちで停止したより高い優先度のプロセスは再びスケジューリングされる 前にい"
"くらかの応答時間がかかる。デバイス・ドライバーを書く場合には \"slow interrupt"
"\" 割り込みハンドラーを使用することで この応答時間を劇的に減少させることがで"
"きる。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:392
#, no-wrap
msgid "Miscellaneous"
msgstr "その他"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:397
msgid ""
"Child processes inherit the scheduling policy and parameters across a B<fork>"
"(2).  The scheduling policy and parameters are preserved across B<execve>(2)."
msgstr ""
"子プロセスは B<fork>(2)  の際に親プロセスのスケジューリング・ポリシーとパラ"
"メータを継承する。 B<execve>(2)  の前後で、スケジューリング・ポリシーとパラ"
"メータは保持される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:403
msgid ""
"Memory locking is usually needed for real-time processes to avoid paging "
"delays; this can be done with B<mlock>(2)  or B<mlockall>(2)."
msgstr ""
"リアルタイム・プロセスは大抵、ページングの待ち時間を避けるために B<mlock>"
"(2)  や B<mlockall>(2)  を使ってメモリ・ロックをしなければならない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:415
msgid ""
"Since a nonblocking infinite loop in a process scheduled under B<SCHED_FIFO> "
"or B<SCHED_RR> will block all processes with lower priority forever, a "
"software developer should always keep available on the console a shell "
"scheduled under a higher static priority than the tested application.  This "
"will allow an emergency kill of tested real-time applications that do not "
"block or terminate as expected.  See also the description of the "
"B<RLIMIT_RTTIME> resource limit in B<getrlimit>(2)."
msgstr ""
"B<SCHED_FIFO> や B<SCHED_RR> でスケジューリングされる プロセスが停止せずに無"
"限ループに陥ると、 他の全てのより低い優先度のプロセスを永久に停止 (block) さ"
"せてしまうので、 ソフトウェア開発者はコンソールのシェルの静的優先度をテストす"
"る アプリケーションよりも常に高く保つべきである。 これによって期待通りに停止"
"したり終了したりしないリアルタイム・ アプリケーションを緊急終了させることが可"
"能になる。 B<getrlimit>(2)  のリソース制限 B<RLIMIT_RTTIME> の説明も参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:423
msgid ""
"POSIX systems on which B<sched_setscheduler>()  and B<sched_getscheduler>()  "
"are available define B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムでは I<E<lt>unistd.hE<gt>> に B<_POSIX_PRIORITY_SCHEDULING> が"
"定義されている場合にのみ B<sched_setscheduler>()  と B<sched_getscheduler>"
"()  が使用できる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:433
msgid ""
"On success, B<sched_setscheduler>()  returns zero.  On success, "
"B<sched_getscheduler>()  returns the policy for the process (a nonnegative "
"integer).  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<sched_setscheduler>()  は 0 を返す。 成功した場合、 "
"B<sched_getscheduler>()  は現在のそのプロセスのポリシー (非負の整数) を返"
"す。 エラーの場合、-1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:439
#, fuzzy
#| msgid ""
#| "The scheduling I<policy> is not one of the recognized policies, or "
#| "I<param> does not make sense for the I<policy>."
msgid ""
"The scheduling I<policy> is not one of the recognized policies, I<param> is "
"NULL, or I<param> does not make sense for the I<policy>."
msgstr ""
"スケジューリング・ポリシー I<policy> が間違っているか、 I<param> がそのポリ"
"シーでは意味をなさない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:442
msgid "The calling process does not have appropriate privileges."
msgstr "呼び出したプロセスが適切な特権を持っていない。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:448
msgid ""
"POSIX.1-2001 (but see BUGS below).  The B<SCHED_BATCH> and B<SCHED_IDLE> "
"policies are Linux-specific."
msgstr ""
"POSIX.1-2001 (但し、下記のバグの節も参照)。 B<SCHED_BATCH> と B<SCHED_IDLE> "
"ポリシーは Linux 固有である。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:456
msgid ""
"POSIX.1 does not detail the permissions that an unprivileged process "
"requires in order to call B<sched_setscheduler>(), and details vary across "
"systems.  For example, the Solaris 7 manual page says that the real or "
"effective user ID of the calling process must match the real user ID or the "
"save set-user-ID of the target process."
msgstr ""
"POSIX.1 は、非特権プロセスが B<sched_setscheduler>()  を呼び出すために必要な"
"権限の詳細を規定しておらず、 詳細はシステムにより異なる。 例えば、Solaris 7 "
"のマニュアルページでは、 呼び出し元プロセスの実ユーザ ID または実効ユーザ ID "
"が 設定対象のプロセスの実ユーザ ID か保存 (save) set-user-ID と 一致していな"
"ければならない、となっている。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:466
msgid ""
"Originally, Standard Linux was intended as a general-purpose operating "
"system being able to handle background processes, interactive applications, "
"and less demanding real-time applications (applications that need to usually "
"meet timing deadlines).  Although the Linux kernel 2.6 allowed for kernel "
"preemption and the newly introduced O(1) scheduler ensures that the time "
"needed to schedule is fixed and deterministic irrespective of the number of "
"active tasks, true real-time computing was not possible up to kernel version "
"2.6.17."
msgstr ""
"もともとは、標準の Linux は一般目的のオペレーティングシステムとして 設計され"
"ており、バックグラウンド・プロセスや対話的アプリケーション、 リアルタイム性の"
"要求が厳しくないリアルタイム・アプリケーション (普通はタイミングの応答期限 "
"(deadline) を満たす必要があるアプリケーション)  を扱うことができた。 Linux "
"カーネル 2.6 では、 カーネルのプリエンプション (タスクの置き換え) が可能であ"
"り、 新たに導入された O(1) スケジューラにより、 アクティブなタスクの数に関わ"
"らずスケジューリングに必要な時間は 固定で確定的 (deterministic) であることが"
"保証されている。 それにも関わらず、カーネル 2.6.17 までは 真のリアルタイム・"
"コンピューティングは実現できなかった。"

#. type: SS
#: build/C/man2/sched_setscheduler.2:466
#, no-wrap
msgid "Real-time features in the mainline Linux kernel"
msgstr "本流の Linux カーネルでのリアルタイム機能"

#.  FIXME . Probably this text will need some minor tweaking
#.  by about the time of 2.6.30; ask Carsten Emde about this then.
#. type: Plain text
#: build/C/man2/sched_setscheduler.2:480
#, fuzzy
#| msgid ""
#| "From kernel version 2.6.18 onwards, however, Linux is gradually becoming "
#| "equipped with real-time capabilities, most of which are derived from the "
#| "former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
#| "Gleixner, Steven Rostedt, and others.  Until the patches have been "
#| "completely merged into the mainline kernel (this is expected to be around "
#| "kernel version 2.6.30), they must be installed to achieve the best real-"
#| "time performance.  These patches are named:"
msgid ""
"From kernel version 2.6.18 onward, however, Linux is gradually becoming "
"equipped with real-time capabilities, most of which are derived from the "
"former I<realtime-preempt> patches developed by Ingo Molnar, Thomas "
"Gleixner, Steven Rostedt, and others.  Until the patches have been "
"completely merged into the mainline kernel (this is expected to be around "
"kernel version 2.6.30), they must be installed to achieve the best real-time "
"performance.  These patches are named:"
msgstr ""
"カーネル 2.6.18 から現在まで、 Linux は徐々にリアルタイム機能を備えつつある"
"が、 これらの機能のほとんどは、 Ingo Molnar, Thomas Gleixner, Steven Rostedt "
"らによって開発された、 以前の I<realtime-preempt> パッチからのものである。 こ"
"れらのパッチが本流のカーネルに完全にマージされるまでは (マージの完了はカーネ"
"ル 2.6.30 あたりの予定)、 最高のリアルタイム性能を達成するには realtime-"
"preempt パッチを 組み込まなければならない。 これらのパッチは"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:484
#, no-wrap
msgid "patch-I<kernelversion>-rtI<patchversion>\n"
msgstr "patch-I<kernelversion>-rtI<patchversion>\n"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:489
msgid ""
"and can be downloaded from I<http://www.kernel.org/pub/linux/kernel/projects/"
"rt/>."
msgstr ""
"という名前で、 I<http://www.kernel.org/pub/linux/kernel/projects/rt/> からダ"
"ウンロードできる。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:498
msgid ""
"Without the patches and prior to their full inclusion into the mainline "
"kernel, the kernel configuration offers only the three preemption classes "
"B<CONFIG_PREEMPT_NONE>, B<CONFIG_PREEMPT_VOLUNTARY>, and "
"B<CONFIG_PREEMPT_DESKTOP> which respectively provide no, some, and "
"considerable reduction of the worst-case scheduling latency."
msgstr ""
"このパッチが適用されず、かつパッチの内容の本流のカーネルへのマージが 完了する"
"までは、カーネルの設定では B<CONFIG_PREEMPT_NONE>, "
"B<CONFIG_PREEMPT_VOLUNTARY>, B<CONFIG_PREEMPT_DESKTOP> の 3つのプリエンプショ"
"ン・クラス (preemption class) だけが提供される。 これらのクラスでは、最悪の場"
"合のスケジューリング遅延がそれぞれ 全く減らない、いくらか減る、かなり減る。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:509
msgid ""
"With the patches applied or after their full inclusion into the mainline "
"kernel, the additional configuration item B<CONFIG_PREEMPT_RT> becomes "
"available.  If this is selected, Linux is transformed into a regular real-"
"time operating system.  The FIFO and RR scheduling policies that can be "
"selected using B<sched_setscheduler>()  are then used to run a process with "
"true real-time priority and a minimum worst-case scheduling latency."
msgstr ""
"パッチが適用された場合、またはパッチの内容の本流のカーネルへのマージが 完了し"
"た後では、上記に加えて設定項目として B<CONFIG_PREEMPT_RT> が利用可能になる。"
"この項目を選択すると、 Linux は通常のリアルタイム・オペレーティングシステムに"
"変身する。 この場合には、 B<sched_setscheduler>()  で選択できる FIFO と RR の"
"スケジューリング・ポリシーは、 真のリアルタイム優先度を持つプロセスを最悪の場"
"合のスケジューリング遅延が 最小となる環境で動作させるために使われることにな"
"る。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:517
msgid ""
"POSIX says that on success, B<sched_setscheduler>()  should return the "
"previous scheduling policy.  Linux B<sched_setscheduler>()  does not conform "
"to this requirement, since it always returns 0 on success."
msgstr ""
"POSIX では、成功時に B<sched_setscheduler>()  は直前のスケジューリング・ポリ"
"シーを返すべきとされている。 Linux の B<sched_setscheduler>()  はこの要求仕様"
"に準拠しておらず、 成功時には常に 0 を返す。"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:535
msgid ""
"B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), B<munlockall>"
"(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7)"
msgstr ""
"B<getpriority>(2), B<mlock>(2), B<mlockall>(2), B<munlock>(2), B<munlockall>"
"(2), B<nice>(2), B<sched_get_priority_max>(2), B<sched_get_priority_min>(2), "
"B<sched_getaffinity>(2), B<sched_getparam>(2), B<sched_rr_get_interval>(2), "
"B<sched_setaffinity>(2), B<sched_setparam>(2), B<sched_yield>(2), "
"B<setpriority>(2), B<capabilities>(7), B<cpuset>(7)"

#. type: Plain text
#: build/C/man2/sched_setscheduler.2:542
msgid ""
"The kernel source file I<Documentation/scheduler/sched-rt-group.txt> (since "
"kernel 2.6.25)."
msgstr ""
"カーネル・ソース内のファイル I<Documentation/scheduler/sched-rt-group.txt> "
"(カーネル 2.6.25 以降)"

#. type: TH
#: build/C/man2/sched_yield.2:30
#, no-wrap
msgid "SCHED_YIELD"
msgstr "SCHED_YIELD"

#. type: TH
#: build/C/man2/sched_yield.2:30
#, no-wrap
msgid "2008-10-18"
msgstr "2008-10-18"

#. type: Plain text
#: build/C/man2/sched_yield.2:33
msgid "sched_yield - yield the processor"
msgstr "sched_yield - プロセッサーを空け渡す(yield)"

#. type: Plain text
#: build/C/man2/sched_yield.2:37
msgid "B<int sched_yield(void);>"
msgstr "B<int sched_yield(void);>"

#. type: Plain text
#: build/C/man2/sched_yield.2:42
msgid ""
"B<sched_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is moved to the end of the queue for its static priority and a new "
"thread gets to run."
msgstr ""
"B<sched_yield>()  を呼び出すことで、呼び出したスレッドが CPU の使用権を手放す"
"ことができる。 そのスレッドは、そのスレッドの静的プライオリティのキューの末尾"
"に 移動し、新しいスレッドが走り始める。"

#. type: Plain text
#: build/C/man2/sched_yield.2:49
msgid ""
"On success, B<sched_yield>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合は B<sched_yield>()  は 0 を返す。 エラーの場合は -1 が返され、 "
"I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/sched_yield.2:53
msgid "In the Linux implementation, B<sched_yield>()  always succeeds."
msgstr "Linux の実装では、 B<sched_yield>()  は常に成功する。"

#. type: Plain text
#: build/C/man2/sched_yield.2:60
msgid ""
"If the calling thread is the only thread in the highest priority list at "
"that time, it will continue to run after a call to B<sched_yield>()."
msgstr ""
"B<sched_yield>()  を呼び出した時点で最大優先度のリストの中に呼び出し元のス"
"レッドしか 存在しなければ、そのスレッドは呼び出し後も走り続けることになる。"

#. type: Plain text
#: build/C/man2/sched_yield.2:66
msgid ""
"POSIX systems on which B<sched_yield>()  is available define "
"B<_POSIX_PRIORITY_SCHEDULING> in I<E<lt>unistd.hE<gt>>."
msgstr ""
"POSIX システムで B<sched_yield>()  は I<E<lt>unistd.hE<gt>> に "
"B<_POSIX_PRIORITY_SCHEDULING> が定義されている場合にのみ使用可能である。"

#. type: Plain text
#: build/C/man2/sched_yield.2:79
msgid ""
"Strategic calls to B<sched_yield>()  can improve performance by giving other "
"threads or processes a chance to run when (heavily) contended resources (e."
"g., mutexes)  have been released by the caller.  Avoid calling B<sched_yield>"
"()  unnecessarily or inappropriately (e.g., when resources needed by other "
"schedulable threads are still held by the caller), since doing so will "
"result in unnecessary context switches, which will degrade system "
"performance."
msgstr ""
"B<sched_yield>()  を戦略的に呼び出すことで、(極度に) 競合するリソース (mutex "
"など)  を呼び出し元が解放した際に他のスレッドやプロセスに実行機会を与えること"
"で、 性能を上げることができる。 B<sched_yield>()  を必要もないのに呼び出した"
"り、不適切な場面 (例えば、他のスケジューリング 対象となるスレッドが必要とする"
"リソースを呼び出し元が保持したままの状態)  で呼び出したりするのは避けること。"
"なぜなら、 B<sched_yield>()  の呼び出しより不必要なコンテキストスイッチが起こ"
"り、システム性能が 劣化する結果になるからである。"

#. type: Plain text
#: build/C/man2/sched_yield.2:82
msgid "B<sched_setscheduler>(2)  for a description of Linux scheduling."
msgstr ""
"Linux のスケージュリング(scheduling)については B<sched_setscheduler>(2)  を参"
"照せよ。"

#. type: TH
#: build/C/man2/setns.2:4
#, no-wrap
msgid "SETNS"
msgstr "SETNS"

#. type: TH
#: build/C/man2/setns.2:4
#, no-wrap
msgid "2011-10-04"
msgstr "2011-10-04"

#. type: Plain text
#: build/C/man2/setns.2:7
msgid "setns - reassociate thread with a namespace"
msgstr "setns - reassociate thread with a namespace"

#. type: Plain text
#: build/C/man2/setns.2:13
#, no-wrap
msgid "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"
msgstr "B<int setns(int >I<fd>B<, int >I<nstype>B<);>\n"

#. type: Plain text
#: build/C/man2/setns.2:17
msgid ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."
msgstr ""
"Given a file descriptor referring to a namespace, reassociate the calling "
"thread with that namespace."

#. type: Plain text
#: build/C/man2/setns.2:30
msgid ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<proc>(5)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."
msgstr ""
"The I<fd> argument is a file descriptor referring to one of the namespace "
"entries in a I</proc/[pid]/ns/> directory; see B<proc>(5)  for further "
"information on I</proc/[pid]/ns/>.  The calling thread will be reassociated "
"with the corresponding namespace, subject to any constraints imposed by the "
"I<nstype> argument."

#. type: Plain text
#: build/C/man2/setns.2:36
msgid ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"
msgstr ""
"The I<nstype> argument specifies which type of namespace the calling thread "
"may be reassociated with.  This argument can have one of the following "
"values:"

#. type: TP
#: build/C/man2/setns.2:36
#, no-wrap
msgid "B<0>"
msgstr "B<0>"

#. type: Plain text
#: build/C/man2/setns.2:39
msgid "Allow any type of namespace to be joined."
msgstr "Allow any type of namespace to be joined."

#. type: TP
#: build/C/man2/setns.2:39
#, no-wrap
msgid "B<CLONE_NEWIPC>"
msgstr "B<CLONE_NEWIPC>"

#. type: Plain text
#: build/C/man2/setns.2:43
msgid "I<fd> must refer to an IPC namespace."
msgstr "I<fd> must refer to an IPC namespace."

#. type: TP
#: build/C/man2/setns.2:43
#, no-wrap
msgid "B<CLONE_NEWNET>"
msgstr "B<CLONE_NEWNET>"

#. type: Plain text
#: build/C/man2/setns.2:47
msgid "I<fd> must refer to a network namespace."
msgstr "I<fd> must refer to a network namespace."

#. type: TP
#: build/C/man2/setns.2:47
#, no-wrap
msgid "B<CLONE_NEWUTS>"
msgstr "B<CLONE_NEWUTS>"

#. type: Plain text
#: build/C/man2/setns.2:51
msgid "I<fd> must refer to a UTS namespace."
msgstr "I<fd> must refer to a UTS namespace."

#. type: Plain text
#: build/C/man2/setns.2:66
msgid ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"
msgstr ""
"Specifying I<nstype> as 0 suffices if the caller knows (or does not care)  "
"what type of namespace is referred to by I<fd>.  Specifying a nonzero value "
"for I<nstype> is useful if the caller does not know what type of namespace "
"is referred to by I<fd> and wants to ensure that the namespace is of a "
"particular type.  (The caller might not know the type of the namespace "
"referred to by I<fd> if the file descriptor was opened by another process "
"and, for example, passed to the caller via a UNIX domain socket.)"

#. type: Plain text
#: build/C/man2/setns.2:73
msgid ""
"On success, I<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."
msgstr ""
"On success, I<setns>()  returns 0.  On failure, -1 is returned and I<errno> "
"is set to indicate the error."

#. type: TP
#: build/C/man2/setns.2:74
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/setns.2:78
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> is not a valid file descriptor."

#. type: Plain text
#: build/C/man2/setns.2:85
msgid ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>, or there is problem with reassociating the the thread with the "
"specified namespace."
msgstr ""
"I<fd> refers to a namespace whose type does not match that specified in "
"I<nstype>, or there is problem with reassociating the the thread with the "
"specified namespace."

#. type: Plain text
#: build/C/man2/setns.2:88
msgid "Cannot allocate sufficient memory to change the specified namespace."
msgstr "Cannot allocate sufficient memory to change the specified namespace."

#. type: Plain text
#: build/C/man2/setns.2:93
msgid ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."
msgstr ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."

#. type: Plain text
#: build/C/man2/setns.2:97
msgid "The B<setns>()  system call first appeared in Linux in kernel 3.0"
msgstr "The B<setns>()  system call first appeared in Linux in kernel 3.0"

#. type: Plain text
#: build/C/man2/setns.2:101
msgid "The B<setns>()  system call is Linux-specific."
msgstr "The B<setns>()  system call is Linux-specific."

#. type: Plain text
#: build/C/man2/setns.2:107
msgid ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."
msgstr ""
"Not all of the attributes that can be shared when a new thread is created "
"using B<clone>(2)  can be changed using B<setns>()."

#. type: Plain text
#: build/C/man2/setns.2:115
msgid ""
"The PID namespace and the mount namespace are not currently supported.  (See "
"the descriptions of B<CLONE_NEWPID> and B<CLONE_NEWNS> in B<clone>(2).)"
msgstr ""
"The PID namespace and the mount namespace are not currently supported.  (See "
"the descriptions of B<CLONE_NEWPID> and B<CLONE_NEWNS> in B<clone>(2).)"

#. type: Plain text
#: build/C/man2/setns.2:121
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"
msgstr "B<clone>(2), B<fork>(2), B<vfork>(2), B<proc>(5), B<unix>(7)"

#. type: TH
#: build/C/man2/unshare.2:17
#, no-wrap
msgid "UNSHARE"
msgstr "UNSHARE"

#. type: TH
#: build/C/man2/unshare.2:17
#, fuzzy, no-wrap
#| msgid "2010-10-31"
msgid "2010-10-30"
msgstr "2010-10-31"

#. type: Plain text
#: build/C/man2/unshare.2:20
msgid "unshare - disassociate parts of the process execution context"
msgstr "unshare - プロセス実行コンテキストの一部を分離する"

#. type: Plain text
#: build/C/man2/unshare.2:28
#, no-wrap
msgid "B<int unshare(int >I<flags>B<);>\n"
msgstr "B<int unshare(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/unshare.2:41
msgid ""
"B<unshare>()  allows a process to disassociate parts of its execution "
"context that are currently being shared with other processes.  Part of the "
"execution context, such as the mount namespace, is shared implicitly when a "
"new process is created using B<fork>(2)  or B<vfork>(2), while other parts, "
"such as virtual memory, may be shared by explicit request when creating a "
"process using B<clone>(2)."
msgstr ""
"B<unshare>()  を使うと、プロセスは他のプロセスと現在共有している 実行コンテキ"
"ストの一部を分離することができる。 実行コンテキストの一部、たとえばマウント名"
"前空間 (mount namespace)  などは、新しいプロセスを B<fork>(2)  または "
"B<vfork>(2)  を使って生成したときに、暗黙のうちに共有される。 一方、仮想メモ"
"リなどは、 B<clone>(2)  を使ってプロセスを生成するときに、明示的に共有するこ"
"とを要求できる。"

#. type: Plain text
#: build/C/man2/unshare.2:46
msgid ""
"The main use of B<unshare>()  is to allow a process to control its shared "
"execution context without creating a new process."
msgstr ""
"B<unshare>()  の主な利用法は、プロセスが新しいプロセスを生成することなく、 共"
"有実行コンテキストを制御することである。"

#. type: Plain text
#: build/C/man2/unshare.2:53
msgid ""
"The I<flags> argument is a bit mask that specifies which parts of the "
"execution context should be unshared.  This argument is specified by ORing "
"together zero or more of the following constants:"
msgstr ""
"I<flags> 引き数はビットマスクであり、 実行コンテキストのどの部分の共有を解除"
"するかを表す。 この引き数は、以下の定数の 0 個以上の OR で指定する:"

#. type: Plain text
#: build/C/man2/unshare.2:61
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FILES> flag.  Unshare the "
"file descriptor table, so that the calling process no longer shares its file "
"descriptors with any other process."
msgstr ""
"B<clone>(2)  B<CLONE_FILES> フラグの効果を取り消す。 ファイルディスクリプタ"
"テーブルを共有させず、 呼び出し元プロセスは他のプロセスとファイルディスクリプ"
"タを共有しなくなる。"

#. type: Plain text
#: build/C/man2/unshare.2:74
msgid ""
"Reverse the effect of the B<clone>(2)  B<CLONE_FS> flag.  Unshare file "
"system attributes, so that the calling process no longer shares its root "
"directory, current directory, or umask attributes with any other process.  "
"B<chroot>(2), B<chdir>(2), or B<umask>(2)"
msgstr ""
"B<clone>(2)  B<CLONE_FS> フラグの効果を取り消す。 ファイルシステム属性を共有"
"させず、 呼び出し元プロセスは他のプロセスとルートディレクトリ・ カレントディ"
"レクトリ・umask 属性を共有しなくなる。 B<chroot>(2), B<chdir>(2), B<umask>"
"(2)  に影響する。"

#. type: Plain text
#: build/C/man2/unshare.2:91
#, fuzzy
#| msgid ""
#| "This flag has the I<same> effect as the B<clone>(2)  B<CLONE_NEWNS> "
#| "flag.  Unshare the mount namespace, so that the calling process has a "
#| "private copy of its namespace which is not shared with any other "
#| "process.  Specifying this flag automatically implies B<CLONE_FS> as well."
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWIPC> flag.  "
"Unshare the System V IPC namespace, so that the calling process has a "
"private copy of the System V IPC namespace which is not shared with any "
"other process.  Specifying this flag automatically implies B<CLONE_SYSVSEM> "
"as well.  Use of B<CLONE_NEWIPC> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2)  B<CLONE_NEWNS> フラグとI<同じ>効果を持つ。 マウント"
"名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の名前"
"空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗黙のうちに指定"
"される。"

#. type: Plain text
#: build/C/man2/unshare.2:105
#, fuzzy
#| msgid ""
#| "This flag has the I<same> effect as the B<clone>(2)  B<CLONE_NEWNS> "
#| "flag.  Unshare the mount namespace, so that the calling process has a "
#| "private copy of its namespace which is not shared with any other "
#| "process.  Specifying this flag automatically implies B<CLONE_FS> as well."
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNET> flag.  "
"Unshare the network namespace, so that the calling process is moved into a "
"new network namespace which is not shared with any previously existing "
"process.  B<CLONE_NEWNET> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2)  B<CLONE_NEWNS> フラグとI<同じ>効果を持つ。 マウント"
"名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の名前"
"空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗黙のうちに指定"
"される。"

#. type: TP
#: build/C/man2/unshare.2:105
#, no-wrap
msgid "B<CLONE_NEWNS>"
msgstr "B<CLONE_NEWNS>"

#.  These flag name are inconsistent:
#.  CLONE_NEWNS does the same thing in clone(), but CLONE_VM,
#.  CLONE_FS, and CLONE_FILES reverse the action of the clone()
#.  flags of the same name.
#. type: Plain text
#: build/C/man2/unshare.2:126
#, fuzzy
#| msgid ""
#| "This flag has the I<same> effect as the B<clone>(2)  B<CLONE_NEWNS> "
#| "flag.  Unshare the mount namespace, so that the calling process has a "
#| "private copy of its namespace which is not shared with any other "
#| "process.  Specifying this flag automatically implies B<CLONE_FS> as well."
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWNS> flag.  "
"Unshare the mount namespace, so that the calling process has a private copy "
"of its namespace which is not shared with any other process.  Specifying "
"this flag automatically implies B<CLONE_FS> as well.  Use of B<CLONE_NEWNS> "
"requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2)  B<CLONE_NEWNS> フラグとI<同じ>効果を持つ。 マウント"
"名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の名前"
"空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗黙のうちに指定"
"される。"

#. type: TP
#: build/C/man2/unshare.2:126
#, fuzzy, no-wrap
#| msgid "B<CLONE_SYSVSEM> (since Linux 2.5.10)"
msgid "B<CLONE_SYSVSEM> (since Linux 2.6.26)"
msgstr "B<CLONE_SYSVSEM> (Linux 2.5.10 以降)"

#. type: Plain text
#: build/C/man2/unshare.2:140
#, fuzzy
#| msgid ""
#| "This flag has the I<same> effect as the B<clone>(2)  B<CLONE_NEWNS> "
#| "flag.  Unshare the mount namespace, so that the calling process has a "
#| "private copy of its namespace which is not shared with any other "
#| "process.  Specifying this flag automatically implies B<CLONE_FS> as well."
msgid ""
"This flag reverses the effect of the B<clone>(2)  B<CLONE_SYSVSEM> flag.  "
"Unshare System V semaphore undo values, so that the calling process has a "
"private copy which is not shared with any other process.  Use of "
"B<CLONE_SYSVSEM> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2)  B<CLONE_NEWNS> フラグとI<同じ>効果を持つ。 マウント"
"名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の名前"
"空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗黙のうちに指定"
"される。"

#.  As at 2.6.16, the following forced implications also apply,
#.  although the relevant flags are not yet implemented.
#.  If CLONE_THREAD is set force CLONE_VM.
#.  If CLONE_VM is set, force CLONE_SIGHAND.
#.  CLONE_NEWNSIf CLONE_SIGHAND is set and signals are also being shared
#.  (i.e., current->signal->count > 1), force CLONE_THREAD.
#.  FIXME . CLONE_VM is not (yet, as at 2.6.16) implemented.
#.  .TP
#.  .B CLONE_VM
#.  Reverse the effect of the
#.  .BR clone (2)
#.  .B CLONE_VM
#.  flag.
#.  .RB ( CLONE_VM
#.  is also implicitly set by
#.  .BR vfork (2),
#.  and can be reversed using this
#.  .BR unshare ()
#.  flag.)
#.  Unshare virtual memory, so that the calling process no
#.  longer shares its virtual address space with any other process.
#. type: Plain text
#: build/C/man2/unshare.2:176
#, fuzzy
#| msgid ""
#| "This flag has the I<same> effect as the B<clone>(2)  B<CLONE_NEWNS> "
#| "flag.  Unshare the mount namespace, so that the calling process has a "
#| "private copy of its namespace which is not shared with any other "
#| "process.  Specifying this flag automatically implies B<CLONE_FS> as well."
msgid ""
"This flag has the same effect as the B<clone>(2)  B<CLONE_NEWUTS> flag.  "
"Unshare the UTS IPC namespace, so that the calling process has a private "
"copy of the UTS namespace which is not shared with any other process.  Use "
"of B<CLONE_NEWUTS> requires the B<CAP_SYS_ADMIN> capability."
msgstr ""
"このフラグは B<clone>(2)  B<CLONE_NEWNS> フラグとI<同じ>効果を持つ。 マウント"
"名前空間を共有せず、呼び出し元プロセスは 他のプロセスとは共有しない固有の名前"
"空間のコピーを持つ。 このフラグを指定すると、 B<CLONE_FS> も暗黙のうちに指定"
"される。"

#. type: Plain text
#: build/C/man2/unshare.2:183
msgid ""
"If I<flags> is specified as zero, then B<unshare>()  is a no-op; no changes "
"are made to the calling process's execution context."
msgstr ""
"I<flags> に 0 が指定された場合、 B<unshare>()  は何も行わないので、 呼び出し"
"元プロセスの実行コンテキストは、何も変更されない。"

#. type: Plain text
#: build/C/man2/unshare.2:188
msgid ""
"On success, zero returned.  On failure, -1 is returned and I<errno> is set "
"to indicate the error."
msgstr ""
"成功した場合は 0 が返される。 失敗した場合は -1 が返されて、 I<errno> にはエ"
"ラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/unshare.2:193
msgid "An invalid bit was specified in I<flags>."
msgstr "I<flags> に不正なビットが指定された。"

#. type: Plain text
#: build/C/man2/unshare.2:197
msgid ""
"Cannot allocate sufficient memory to copy parts of caller's context that "
"need to be unshared."
msgstr ""
"呼び出し元のコンテキストのうち共有を解除する必要がある部分をコピーするため"
"に、 十分なメモリが確保できなかった。"

#. type: Plain text
#: build/C/man2/unshare.2:200
#, fuzzy
#| msgid ""
#| "The calling thread did not have the required privilege "
#| "(B<CAP_SYS_ADMIN>)  for this operation."
msgid ""
"The calling process did not have the required privileges for this operation."
msgstr ""
"The calling thread did not have the required privilege (B<CAP_SYS_ADMIN>)  "
"for this operation."

#. type: Plain text
#: build/C/man2/unshare.2:204
msgid "The B<unshare>()  system call was added to Linux in kernel 2.6.16."
msgstr "B<unshare>()  システムコールは Linux カーネル 2.6.16 で追加された。"

#. type: Plain text
#: build/C/man2/unshare.2:208
msgid "The B<unshare>()  system call is Linux-specific."
msgstr "B<unshare>()  システムコールは Linux 固有である。"

#.  However, we can do unshare(CLONE_SIGHAND) if CLONE_SIGHAND
#.  was not specified when doing clone(); i.e., unsharing
#.  signal handlers is permitted if we are not actually
#.  sharing signal handlers.   mtk
#.  FIXME . check future kernel versions (e.g., 2.6.17)
#.  to see if CLONE_VM gets implemented.
#.  However, as at 2.6.16, we can do unshare(CLONE_VM) if CLONE_VM
#.  was not specified when doing clone(); i.e., unsharing
#.  virtual memory is permitted if we are not actually
#.  sharing virtual memory.   mtk
#. 9) Future Work
#. --------------
#. The current implementation of unshare does not allow unsharing of
#. signals and signal handlers. Signals are complex to begin with and
#. to unshare signals and/or signal handlers of a currently running
#. process is even more complex. If in the future there is a specific
#. need to allow unsharing of signals and/or signal handlers, it can
#. be incrementally added to unshare without affecting legacy
#. applications using unshare.
#. type: Plain text
#: build/C/man2/unshare.2:244
msgid ""
"Not all of the process attributes that can be shared when a new process is "
"created using B<clone>(2)  can be unshared using B<unshare>().  In "
"particular, as at kernel 2.6.16, B<unshare>()  does not implement flags that "
"reverse the effects of B<CLONE_SIGHAND>, B<CLONE_SYSVSEM>, B<CLONE_THREAD>, "
"or B<CLONE_VM>.  Such functionality may be added in the future, if required."
msgstr ""
"B<clone>(2)  で新しいプロセスを生成したときに共有される全てのプロセス属性"
"を、 B<unshare>()  によって共有の解除ができるわけではない。 特に、カーネル "
"2.6.16 においては、 B<unshare>()  に B<CLONE_SIGHAND>, B<CLONE_SYSVSEM>, "
"B<CLONE_THREAD>, B<CLONE_VM> の効果を取り消すためのフラグが実装されていな"
"い。 これらの機能は、必要であれば将来追加されるかもしれない。"

#. type: Plain text
#: build/C/man2/unshare.2:249
msgid "B<clone>(2), B<fork>(2), B<vfork>(2), Documentation/unshare.txt"
msgstr "B<clone>(2), B<fork>(2), B<vfork>(2), Documentation/unshare.txt"

#~ msgid "2010-11-01"
#~ msgstr "2010-11-01"

#~ msgid ""
#~ "I<From Linux 2.6.25 this flag is deprecated.> You probably never wanted "
#~ "to use it, you certainly shouldn't be using it, and soon it will go away."
#~ msgstr ""
#~ "I<Linux 2.6.25 以降、このフラグは非推奨である。> このフラグを使いたいと思"
#~ "うことは決してないだろうし、 確実に使わないようにすべきである。 このフラグ"
#~ "は近いうちになくなることだろう。"

#~ msgid "2008-11-06"
#~ msgstr "2008-11-06"

#~ msgid ""
#~ "Special rules apply for the B<SCHED_IDLE>: an unprivileged process "
#~ "operating under this policy cannot change its policy, regardless of the "
#~ "value of its B<RLIMIT_RTPRIO> resource limit."
#~ msgstr ""
#~ "B<SCHED_IDLE> には特別なルールが適用され、 このポリシーの下で動作する非特"
#~ "権プロセスは、リソース制限 B<RLIMIT_RTPRIO> の値にかかわらず自身のポリシー"
#~ "を変更することができない。"

#~ msgid ""
#~ "I<flags> specified B<CLONE_NEWNS> but the calling process was not "
#~ "privileged (did not have the B<CAP_SYS_ADMIN> capability)."
#~ msgstr ""
#~ "I<flags> に B<CLONE_NEWNS> が指定されたが、呼び出し元プロセスに特権 "
#~ "(B<CAP_SYS_ADMIN> ケーパビリティ) がなかった。"

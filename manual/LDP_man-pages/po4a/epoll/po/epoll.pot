# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-13 10:26+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr ""

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "2012-04-17"
msgstr ""

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:24 build/C/man2/epoll_ctl.2:20 build/C/man2/epoll_wait.2:22 build/C/man2/poll.2:31
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:24 build/C/man2/epoll_ctl.2:20 build/C/man2/epoll_wait.2:22 build/C/man2/poll.2:31
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:22 build/C/man2/epoll_create.2:25 build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23 build/C/man2/poll.2:32
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:24 build/C/man2/epoll_create.2:27 build/C/man2/epoll_ctl.2:23 build/C/man2/epoll_wait.2:25 build/C/man2/poll.2:34
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:26 build/C/man2/epoll_ctl.2:25
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:26 build/C/man2/epoll_create.2:34 build/C/man2/epoll_ctl.2:28 build/C/man2/epoll_wait.2:35 build/C/man2/poll.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:40
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API "
"can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors.  The following "
"system calls are provided to create and manage an B<epoll> instance:"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:40 build/C/man7/epoll.7:49 build/C/man7/epoll.7:57 build/C/man2/epoll_wait.2:59 build/C/man2/epoll_wait.2:61 build/C/man2/epoll_wait.2:63 build/C/man2/poll.2:132 build/C/man2/poll.2:134 build/C/man2/poll.2:136
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:49
msgid ""
"B<epoll_create>(2)  creates an B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent B<epoll_create1>(2)  "
"extends the functionality of B<epoll_create>(2).)"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:57
msgid ""
"Interest in particular file descriptors is then registered via "
"B<epoll_ctl>(2).  The set of file descriptors currently registered on an "
"B<epoll> instance is sometimes called an I<epoll> set."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:61
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:61
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:70
msgid ""
"The B<epoll> event distribution interface is able to behave both as "
"edge-triggered (ET) and as level-triggered (LT).  The difference between the "
"two mechanisms can be described as follows.  Suppose that this scenario "
"happens:"
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:70
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:76
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:76
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:78
msgid "A pipe writer writes 2 kB of data on the write side of the pipe."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:78
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:84
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:84
#, no-wrap
msgid "4."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:87
msgid "The pipe reader reads 1 kB of data from I<rfd>."
msgstr ""

#. type: IP
#: build/C/man7/epoll.7:87
#, no-wrap
msgid "5."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:91
msgid "A call to B<epoll_wait>(2)  is done."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:126
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using "
"the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done in "
"step B<5> will probably hang despite the available data still present in the "
"file input buffer; meanwhile the remote peer might be expecting a response "
"based on the data it already sent.  The reason for this is that "
"edge-triggered mode delivers events only when changes occur on the monitored "
"file descriptor.  So, in step B<5> the caller might end up waiting for some "
"data that is already present inside the input buffer.  In the above example, "
"an event on I<rfd> will be generated because of the write done in B<2> and "
"the event is consumed in B<3>.  Since the read operation done in B<4> does "
"not consume the whole buffer data, the call to B<epoll_wait>(2)  done in "
"step B<5> might block indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:136
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an "
"edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:137
#, no-wrap
msgid "B<i>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:140
msgid "with nonblocking file descriptors; and"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:140
#, no-wrap
msgid "B<ii>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:148
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:159
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:176
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated "
"file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:176
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: build/C/man7/epoll.7:184
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:184
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr ""

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: build/C/man7/epoll.7:198
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:198
#, no-wrap
msgid "Example for suggested usage"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:227
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has "
"been called.  The function I<do_use_fd()> uses the new ready file descriptor "
"until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2).  An "
"event-driven state machine application should, after having received "
"B<EAGAIN>, record its current state so that at the next call to "
"I<do_use_fd()> it will continue to B<read>(2)  or B<write>(2)  from where it "
"stopped before."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:233
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:236
#, no-wrap
msgid ""
"/* Set up listening socket, \\(aqlisten_sock\\(aq (socket(),\n"
"   bind(), listen()) */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:242
#, no-wrap
msgid ""
"epollfd = epoll_create(10);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:249
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:256
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_pwait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:278
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                            (struct sockaddr *) &local, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:297
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:297
#, no-wrap
msgid "Questions and answers"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:298
#, no-wrap
msgid "B<Q0>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:303
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"B<epoll> set?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:303
#, no-wrap
msgid "B<A0>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:309
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:309
#, no-wrap
msgid "B<Q1>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:314
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:314
#, no-wrap
msgid "B<A1>"
msgstr ""

#.  But a descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, descriptors duplicated by fork have
#.  similar semantics to descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  descriptor means that even if the parent closes its descriptor, then
#.  epoll_wait() in the parent will continue to receive notifications for
#.  that descriptor because of the duplicated descriptor in the child.
#
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#
#.  mtk, Feb 2008
#. type: Plain text
#: build/C/man7/epoll.7:345
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate "
"(B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  descriptor to the same "
"B<epoll> instance.  This can be a useful technique for filtering events, if "
"the duplicate file descriptors are registered with different I<events> "
"masks."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:345
#, no-wrap
msgid "B<Q2>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:353
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:353
#, no-wrap
msgid "B<A2>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:357
msgid ""
"Yes, and events would be reported to both.  However, careful programming may "
"be needed to do this correctly."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:357
#, no-wrap
msgid "B<Q3>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:362
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:362
#, no-wrap
msgid "B<A3>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:369
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting then it will "
"indicate as being readable."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:369
#, no-wrap
msgid "B<Q4>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:374
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own "
"file descriptor set?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:374
#, no-wrap
msgid "B<A4>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:385
msgid ""
"The B<epoll_ctl>(2)  call will fail (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:385
#, no-wrap
msgid "B<Q5>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:390
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:390
#, no-wrap
msgid "B<A5>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:396
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the B<epoll> set."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:396
#, no-wrap
msgid "B<Q6>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:401
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> sets "
"automatically?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:401
#, no-wrap
msgid "B<A6>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:429
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or "
"B<fork>(2), a new file descriptor referring to the same open file "
"description is created.  An open file description continues to exist until "
"all file descriptors referring to it have been closed.  A file descriptor is "
"removed from an B<epoll> set only after all the file descriptors referring "
"to the underlying open file description have been closed (or before if the "
"descriptor is explicitly removed using B<epoll_ctl>(2)  B<EPOLL_CTL_DEL>).  "
"This means that even after a file descriptor that is part of an B<epoll> set "
"has been closed, events may be reported for that file descriptor if other "
"file descriptors referring to the same underlying file description remain "
"open."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:429
#, no-wrap
msgid "B<Q7>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:434
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:434
#, no-wrap
msgid "B<A7>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:437
msgid "They will be combined."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:437
#, no-wrap
msgid "B<Q8>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:441
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:441
#, no-wrap
msgid "B<A8>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:447
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:447
#, no-wrap
msgid "B<Q9>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:455
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior) ?"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:455
#, no-wrap
msgid "B<A9>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:465
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider "
"it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:471
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:487
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when "
"writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a "
"stream-oriented file.)"
msgstr ""

#. type: SS
#: build/C/man7/epoll.7:487
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:488
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:496
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:504
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""

#. type: TP
#: build/C/man7/epoll.7:504
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:520
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)  "
"the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:531
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and "
"B<close>(2), then mark its associated data structure as removed and link it "
"to a cleanup list.  If you find another event for file descriptor 13 in your "
"batch processing, you will discover the file descriptor had been previously "
"removed and there will be no confusion."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:531 build/C/man2/epoll_create.2:108 build/C/man2/epoll_ctl.2:225 build/C/man2/epoll_wait.2:187 build/C/man2/poll.2:325
#, no-wrap
msgid "VERSIONS"
msgstr ""

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man7/epoll.7:537
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:537 build/C/man2/epoll_create.2:118 build/C/man2/epoll_ctl.2:230 build/C/man2/epoll_wait.2:197 build/C/man2/poll.2:342
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:546
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has "
"I</dev/poll>."
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:546 build/C/man2/epoll_create.2:144 build/C/man2/epoll_ctl.2:253 build/C/man2/epoll_wait.2:229 build/C/man2/poll.2:379
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:551
msgid "B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"
msgstr ""

#. type: SH
#: build/C/man7/epoll.7:551 build/C/man2/epoll_create.2:149 build/C/man2/epoll_ctl.2:258 build/C/man2/epoll_wait.2:233 build/C/man2/poll.2:384
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/epoll.7:558 build/C/man2/epoll_create.2:156 build/C/man2/epoll_ctl.2:265 build/C/man2/epoll_wait.2:240 build/C/man2/poll.2:391
msgid ""
"This page is part of release 3.63 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man2/epoll_create.2:24
#, no-wrap
msgid "EPOLL_CREATE"
msgstr ""

#. type: TH
#: build/C/man2/epoll_create.2:24 build/C/man2/epoll_ctl.2:20
#, no-wrap
msgid "2012-04-15"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:27
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:30 build/C/man2/epoll_wait.2:28
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:33
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:42
msgid ""
"B<epoll_create>()  creates an B<epoll>(7)  instance.  Since Linux 2.6.8, the "
"I<size> argument is ignored, but must be greater than zero; see NOTES below."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:55
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""

#. type: SS
#: build/C/man2/epoll_create.2:55
#, no-wrap
msgid "epoll_create1()"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:67
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different "
"behavior:"
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:67
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:77
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""

#. type: SH
#: build/C/man2/epoll_create.2:77 build/C/man2/epoll_ctl.2:157 build/C/man2/epoll_wait.2:150 build/C/man2/poll.2:296
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:84
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: SH
#: build/C/man2/epoll_create.2:84 build/C/man2/epoll_ctl.2:166 build/C/man2/epoll_wait.2:162 build/C/man2/poll.2:306
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:85 build/C/man2/epoll_create.2:89 build/C/man2/epoll_ctl.2:181 build/C/man2/epoll_wait.2:179 build/C/man2/poll.2:315
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:89
msgid "I<size> is not positive."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:94
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:94
#, no-wrap
msgid "B<EMFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:102
msgid ""
"The per-user limit on the number of epoll instances imposed by "
"I</proc/sys/fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  "
"for further details."
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:102
#, no-wrap
msgid "B<ENFILE>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:105
msgid "The system limit on the total number of open files has been reached."
msgstr ""

#. type: TP
#: build/C/man2/epoll_create.2:105 build/C/man2/epoll_ctl.2:204 build/C/man2/poll.2:322
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:108
msgid "There was insufficient memory to create the kernel object."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:112
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_create.2:118
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:121
msgid "B<epoll_create>()  is Linux-specific."
msgstr ""

#. type: SH
#: build/C/man2/epoll_create.2:121 build/C/man2/epoll_ctl.2:234 build/C/man2/epoll_wait.2:200 build/C/man2/poll.2:348
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:144
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more "
"space if the caller's usage exceeded the hint given in I<size>.)  Nowadays, "
"this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater "
"than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:149
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/epoll_ctl.2:20
#, no-wrap
msgid "EPOLL_CTL"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:23
msgid "epoll_ctl - control interface for an epoll descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:28
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:38
msgid ""
"This system call performs control operations on the B<epoll>(7)  instance "
"referred to by the file descriptor I<epfd>.  It requests that the operation "
"I<op> be performed for the target file descriptor, I<fd>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:42
msgid "Valid values for the I<op> argument are :"
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:42
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:54
msgid ""
"Register the target file descriptor I<fd> on the B<epoll> instance referred "
"to by the file descriptor I<epfd> and associate the event I<event> with the "
"internal file linked to I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:54
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:60
msgid "Change the event I<event> associated with the target file descriptor I<fd>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:60
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:71
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the B<epoll> "
"instance referred to by I<epfd>.  The I<event> is ignored and can be NULL "
"(but see BUGS below)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:79
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as :"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:88
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:93
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:100
msgid ""
"The I<events> member is a bit set composed using the following available "
"event types:"
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:100
#, no-wrap
msgid "B<EPOLLIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:105
msgid "The associated file is available for B<read>(2)  operations."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:105
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:110
msgid "The associated file is available for B<write>(2)  operations."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:110
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:116
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:116
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:121
msgid "There is urgent data available for B<read>(2)  operations."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:121
#, no-wrap
msgid "B<EPOLLERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:127
msgid ""
"Error condition happened on the associated file descriptor.  "
"B<epoll_wait>(2)  will always wait for this event; it is not necessary to "
"set it in I<events>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:127
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:133
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:133
#, no-wrap
msgid "B<EPOLLET>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:143
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more "
"detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:143
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:157
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file "
"descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:166
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:167 build/C/man2/epoll_wait.2:163
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:173
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:173
#, no-wrap
msgid "B<EEXIST>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:181
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:194
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:194
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:204
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:209
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:209
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:219
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""

#. type: TP
#: build/C/man2/epoll_ctl.2:219
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:225
msgid "The target file I<fd> does not support B<epoll>."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_ctl.2:230
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:234
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:239
msgid ""
"The B<epoll> interface supports all file descriptors that support "
"B<poll>(2)."
msgstr ""

#. type: SH
#: build/C/man2/epoll_ctl.2:239 build/C/man2/epoll_wait.2:217 build/C/man2/poll.2:375
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:253
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-null pointer in I<event>."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:258
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/epoll_wait.2:22
#, no-wrap
msgid "EPOLL_WAIT"
msgstr ""

#. type: TH
#: build/C/man2/epoll_wait.2:22 build/C/man2/poll.2:31
#, no-wrap
msgid "2014-01-31"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:25
msgid "epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:34
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:52
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The memory area "
"pointed to by I<events> will contain the events that will be available for "
"the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
"I<maxevents> argument must be greater than zero."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:59
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  The call will block until either:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:61
msgid "a file descriptor delivers an event;"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:63 build/C/man2/poll.2:136
msgid "the call is interrupted by a signal handler; or"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:65
msgid "the timout expires."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:80
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:84
msgid "The I<struct epoll_event> is defined as :"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:93
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:98
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:109
msgid ""
"The I<data> of each returned structure will contain the same data the user "
"set with an B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  while the "
"I<events> member will contain the returned event bit field."
msgstr ""

#. type: SS
#: build/C/man2/epoll_wait.2:109
#, no-wrap
msgid "epoll_pwait()"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:123
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like "
"B<pselect>(2), B<epoll_pwait>()  allows an application to safely wait until "
"either a file descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:127
msgid "The following B<epoll_pwait>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:130
#, no-wrap
msgid "    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:135 build/C/man2/poll.2:245
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:138
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:142
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:150
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:162
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:167
msgid "I<epfd> is not a valid file descriptor."
msgstr ""

#. type: TP
#: build/C/man2/epoll_wait.2:167 build/C/man2/poll.2:307
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:172
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr ""

#. type: TP
#: build/C/man2/epoll_wait.2:172 build/C/man2/poll.2:311
#, no-wrap
msgid "B<EINTR>"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:179
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:187
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_wait.2:193
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:197
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:200
msgid "B<epoll_wait>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:210
msgid ""
"While one thread is blocked in a call to B<epoll_pwait>(), it is possible "
"for another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:217
msgid ""
"For a discussion of what may happen if a file descriptor in an B<epoll> "
"instance being monitored by B<epoll_wait>()  is closed in another thread, "
"see B<select>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:229
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where the I<sizeof(long)> is 4 and the kernel I<HZ> "
"value is 1000, this means that timeouts greater than 35.79 minutes are "
"treated as infinity."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:233
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr ""

#. type: TH
#: build/C/man2/poll.2:31
#, no-wrap
msgid "POLL"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:34
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:37
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:39
#, no-wrap
msgid ""
"B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int "
">I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:45
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<timeout_ts>B<, const sigset_t "
"*>I<sigmask>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:52
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:56
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:64
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:71
msgid ""
"The caller should specify the number of items in the I<fds> array in "
"I<nfds>."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:86
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> "
"field.)"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:101
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned "
"in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:120
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:125
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:132
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()  "
"should block waiting for a file descriptor to become ready.  The call will "
"block until either:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:134
msgid "a file descriptor becomes ready;"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:138
msgid "the timeout expires."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:152
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes B<poll>()  "
"to return immediately, even if no file descriptors are ready."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:158
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""

#. type: TP
#: build/C/man2/poll.2:159
#, no-wrap
msgid "B<POLLIN>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:162
msgid "There is data to read."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:162
#, no-wrap
msgid "B<POLLPRI>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:166
msgid ""
"There is urgent data to read (e.g., out-of-band data on TCP socket; "
"pseudoterminal master in packet mode has seen state change in slave)."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:166
#, no-wrap
msgid "B<POLLOUT>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:169
msgid "Writing now will not block."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:169
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:180
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:180
#, no-wrap
msgid "B<POLLERR>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:183
msgid "Error condition (output only)."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:183
#, no-wrap
msgid "B<POLLHUP>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:186
msgid "Hang up (output only)."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:186
#, no-wrap
msgid "B<POLLNVAL>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:191
msgid "Invalid request: I<fd> not open (output only)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:197
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""

#. type: TP
#: build/C/man2/poll.2:198
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:202
msgid "Equivalent to B<POLLIN>."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:202
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr ""

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: build/C/man2/poll.2:206
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:206
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:210
msgid "Equivalent to B<POLLOUT>."
msgstr ""

#. type: TP
#: build/C/man2/poll.2:210
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:213
msgid "Priority data may be written."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:217
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr ""

#. type: SS
#: build/C/man2/poll.2:217
#, no-wrap
msgid "ppoll()"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:231
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:237
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:240
#, no-wrap
msgid "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:249
#, no-wrap
msgid ""
"    sigset_t origmask;\n"
"    int timeout;\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:255
#, no-wrap
msgid ""
"    timeout = (timeout_ts == NULL) ? -1 :\n"
"              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n"
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = poll(&fds, nfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:262
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:274
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:281
msgid ""
"The I<timeout_ts> argument specifies an upper limit on the amount of time "
"that B<ppoll>()  will block.  This argument is a pointer to a structure of "
"the following form:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:288
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:296
msgid ""
"If I<timeout_ts> is specified as NULL, then B<ppoll>()  can block "
"indefinitely."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:306
msgid ""
"On success, a positive number is returned; this is the number of structures "
"which have nonzero I<revents> fields (in other words, those descriptors with "
"events or errors reported).  A value of 0 indicates that the call timed out "
"and no file descriptors were ready.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:311
msgid ""
"The array given as argument was not contained in the calling program's "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:315
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:322
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:325
msgid "There was no space to allocate file descriptor tables."
msgstr ""

#.  library call was introduced in libc 5.4.28
#. type: Plain text
#: build/C/man2/poll.2:335
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels "
"that lack this system call, the glibc (and the old Linux libc)  B<poll>()  "
"wrapper function provides emulation using B<select>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:342
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""

#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: build/C/man2/poll.2:348
msgid "B<poll>()  conforms to POSIX.1-2001.  B<ppoll>()  is Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:356
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:361
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr ""

#. type: SS
#: build/C/man2/poll.2:361
#, no-wrap
msgid "Linux notes"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:375
msgid ""
"The Linux B<ppoll>()  system call modifies its I<timeout_ts> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<ppoll>()  function does not modify its I<timeout_ts> argument."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:379
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:384
msgid "B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<time>(7)"
msgstr ""

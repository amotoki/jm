# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-13 10:26+0900\n"
"PO-Revision-Date: 2014-04-13 10:35+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr "EPOLL"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "2012-04-17"
msgstr "2012-04-17"

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:24
#: build/C/man2/epoll_ctl.2:20 build/C/man2/epoll_wait.2:22
#: build/C/man2/poll.2:31
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:24
#: build/C/man2/epoll_ctl.2:20 build/C/man2/epoll_wait.2:22
#: build/C/man2/poll.2:31
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/epoll.7:22 build/C/man2/epoll_create.2:25
#: build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23
#: build/C/man2/poll.2:32
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr "epoll - I/O イベント通知機能"

#. type: SH
#: build/C/man7/epoll.7:24 build/C/man2/epoll_create.2:27
#: build/C/man2/epoll_ctl.2:23 build/C/man2/epoll_wait.2:25
#: build/C/man2/poll.2:34
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man7/epoll.7:26 build/C/man2/epoll_ctl.2:25
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>"

#. type: SH
#: build/C/man7/epoll.7:26 build/C/man2/epoll_create.2:34
#: build/C/man2/epoll_ctl.2:28 build/C/man2/epoll_wait.2:35
#: build/C/man2/poll.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/epoll.7:40
msgid ""
"The B<epoll> API performs a similar task to B<poll>(2): monitoring multiple "
"file descriptors to see if I/O is possible on any of them.  The B<epoll> API "
"can be used either as an edge-triggered or a level-triggered interface and "
"scales well to large numbers of watched file descriptors.  The following "
"system calls are provided to create and manage an B<epoll> instance:"
msgstr ""
"B<epoll> API は B<poll>(2) と同様の処理を行う、つまり、複数のファイルディス"
"ク\n"
"リプタを監視し、その中のいずれかが入出力可能な状態であるかを確認する。\n"
"B<epoll> API は、エッジトリガインタフェースとレベルトリガインタフェースの\n"
"いずれとしても使用することができ、監視するファイルディスクリプタの数が多い\n"
"場合にも使用できる。 B<epoll> インスタンスの作成や管理を行うために\n"
"以下のシステムコールが提供されている:"

#. type: IP
#: build/C/man7/epoll.7:40 build/C/man7/epoll.7:49 build/C/man7/epoll.7:57
#: build/C/man2/epoll_wait.2:59 build/C/man2/epoll_wait.2:61
#: build/C/man2/epoll_wait.2:63 build/C/man2/poll.2:132
#: build/C/man2/poll.2:134 build/C/man2/poll.2:136
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/epoll.7:49
msgid ""
"B<epoll_create>(2)  creates an B<epoll> instance and returns a file "
"descriptor referring to that instance.  (The more recent B<epoll_create1>"
"(2)  extends the functionality of B<epoll_create>(2).)"
msgstr ""
"B<epoll_create>(2) は B<epoll> インスタンスを作成し、そのインスタンスを参照す"
"る\n"
"ファイルディスクリプタを返す。(もっと新しい B<epoll_create1>(2) では、\n"
"B<epoll_create>(2) の機能が拡張されている)。"

#. type: Plain text
#: build/C/man7/epoll.7:57
msgid ""
"Interest in particular file descriptors is then registered via B<epoll_ctl>"
"(2).  The set of file descriptors currently registered on an B<epoll> "
"instance is sometimes called an I<epoll> set."
msgstr ""
"特定のファイルディスクリプタに対する監視内容を B<epoll_ctl>(2)  で登録する。 "
"B<epoll> インスタンスに現在登録されているファイルディスクリプタの集合は "
"I<epoll> 集合と呼ばれることもある。"

#. type: Plain text
#: build/C/man7/epoll.7:61
msgid ""
"B<epoll_wait>(2)  waits for I/O events, blocking the calling thread if no "
"events are currently available."
msgstr ""
"B<epoll_wait>(2) は I/O イベントを待つ。\n"
"現在利用可能な状態のイベントがなければ、呼び出したスレッドを停止する。"

#. type: SS
#: build/C/man7/epoll.7:61
#, no-wrap
msgid "Level-triggered and edge-triggered"
msgstr "レベルトリガとエッジトリガ"

#. type: Plain text
#: build/C/man7/epoll.7:70
msgid ""
"The B<epoll> event distribution interface is able to behave both as edge-"
"triggered (ET) and as level-triggered (LT).  The difference between the two "
"mechanisms can be described as follows.  Suppose that this scenario happens:"
msgstr ""
"B<epoll> イベント配送 (distribution) インタフェースは、 エッジトリガ (ET) と"
"してもレベルトリガ (LT) としても動作させることができる。 二つの配送機構の違い"
"は、次のように説明できる。 このようなシナリオが起こったとしよう:"

#. type: IP
#: build/C/man7/epoll.7:70
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/epoll.7:76
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""
"パイプの読み込み側を表すファイルディスクリプタ (I<rfd>)  が B<epoll> インスタ"
"ンスに登録される。"

#. type: IP
#: build/C/man7/epoll.7:76
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/epoll.7:78
msgid "A pipe writer writes 2 kB of data on the write side of the pipe."
msgstr ""
"パイプへ書き込むプログラムが 2 kB のデータをパイプの書き込み側へ書き込む。"

#. type: IP
#: build/C/man7/epoll.7:78
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/epoll.7:84
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""
"B<epoll_wait>(2)  を呼び出すと、読み込み可能 (ready) なファイルディスクリプタ"
"として I<rfd> が返る。"

#. type: IP
#: build/C/man7/epoll.7:84
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/epoll.7:87
msgid "The pipe reader reads 1 kB of data from I<rfd>."
msgstr "パイプから読み出すプログラムが、1 kB のデータを I<rfd> から読み出す。"

#. type: IP
#: build/C/man7/epoll.7:87
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man7/epoll.7:91
msgid "A call to B<epoll_wait>(2)  is done."
msgstr "B<epoll_wait>(2)  の呼び出しが行われる。"

#. type: Plain text
#: build/C/man7/epoll.7:126
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using "
"the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done in "
"step B<5> will probably hang despite the available data still present in the "
"file input buffer; meanwhile the remote peer might be expecting a response "
"based on the data it already sent.  The reason for this is that edge-"
"triggered mode delivers events only when changes occur on the monitored file "
"descriptor.  So, in step B<5> the caller might end up waiting for some data "
"that is already present inside the input buffer.  In the above example, an "
"event on I<rfd> will be generated because of the write done in B<2> and the "
"event is consumed in B<3>.  Since the read operation done in B<4> does not "
"consume the whole buffer data, the call to B<epoll_wait>(2)  done in step "
"B<5> might block indefinitely."
msgstr ""
"I<rfd> ファイルディスクリプタが B<EPOLLET> フラグ (エッジトリガ) を使って "
"B<epoll> に追加されていると、 利用可能なデータがファイル入力バッファにまだ存"
"在するにもかかわらず ステップ B<5> の B<epoll_wait>(2)  の呼び出しでハングす"
"る可能性がある。 その一方で、リモートの接続先 (peer) は既に送られたデータに "
"基づいて応答を期待しているかもしれない。 このようなことが起こる理由は、エッジ"
"トリガイベント配送では、 モニタしているファイルでイベントが起ったときにのみイ"
"ベントが 配送されるためである。 したがって、ステップ B<5> では、呼び出し側は"
"結果的に 入力バッファ内にすで存在するデータを待つことになるかもしれない。 上"
"記の例では、 B<2> で行われた書き込みによって I<rfd> に関するイベントが生成さ"
"れ、 B<3> でイベントが消費 (consume) される。 B<4> で行われる読み込み操作で"
"は、全部のバッファデータを消費しないので、 ステップ B<5> で行われる "
"B<epoll_wait>(2)  の呼び出しが 無期限に停止 (block) するかもしれない。"

#. type: Plain text
#: build/C/man7/epoll.7:136
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an "
"edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""
"B<EPOLLET> フラグを採用するアプリケーションでは、 インタフェースはブロックし"
"ない (nonblocking) ファイルディスクリプタを 使うべきである。 これは、ブロック"
"される読み込みや書き込みによって、 複数のファイルディスクリプタを扱うタスク"
"が 停止してしまうのを避けるためである。 B<epoll> をエッジトリガ "
"(B<EPOLLET>)  インタフェースとして使うために提案される方法は以下の通りであ"
"る。"

#. type: TP
#: build/C/man7/epoll.7:137
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: build/C/man7/epoll.7:140
msgid "with nonblocking file descriptors; and"
msgstr "ブロックしないファイルディスクリプタと共に使う。"

#. type: TP
#: build/C/man7/epoll.7:140
#, no-wrap
msgid "B<ii>"
msgstr "B<ii>"

#. type: Plain text
#: build/C/man7/epoll.7:148
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""
"B<read>(2)  または B<write>(2)  が B<EAGAIN> を返した後でのみ、イベントを待"
"つ。"

#. type: Plain text
#: build/C/man7/epoll.7:159
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""
"一方、レベルトリガインタフェースとして使う場合\n"
" (こちらがデフォルトである、\n"
"B<EPOLLET> が指定されなかった場合)、\n"
"B<epoll> は単に高速な B<poll>(2) であり、使い方が同じなので、\n"
"B<poll>(2) が使われているところではどこでも使用することができる。"

#. type: Plain text
#: build/C/man7/epoll.7:176
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated "
"file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"エッジトリガを使った場合でも、複数のデータを受信すると複数の B<epoll> イベン"
"トが生成されるので、 呼び出し側には B<EPOLLONESHOT> フラグを指定するオプショ"
"ンがある。 このフラグは B<epoll> に対して、 B<epoll_wait>(2)  によるイベント"
"を受信した後で、関連するファイルディスクリプタを無効にさせる。 "
"B<EPOLLONESHOT> フラグが指定された場合、 B<epoll_ctl>(2)  に "
"B<EPOLL_CTL_MOD> を指定してファイルディスクリプタを再度使用できるようにするの"
"は、 呼び出し側の責任である。"

#. type: SS
#: build/C/man7/epoll.7:176
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インタフェース"

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: build/C/man7/epoll.7:184
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""
"epoll が消費するカーネルメモリの量を制限するために、 以下のインタフェースを使"
"用することができる。"

#. type: TP
#: build/C/man7/epoll.7:184
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll/max_user_watches> (Linux 2.6.28 以降)"

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: build/C/man7/epoll.7:198
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""
"このファイルは、あるユーザがシステム上の全ての epoll インスタンスに 登録でき"
"るファイルディスクリプタの総数の上限を規定する。 この上限は実ユーザ ID 単位で"
"ある。 登録されたファイルディスクリプタ 1 つが消費するメモリ量は、 32 ビット"
"カーネルでおよそ 90 バイト、 64 ビットカーネルでおよそ 160 バイトである。 現"
"在のところ、 I<max_user_watches> のデフォルト値は、利用可能なメモリ下限の "
"1/25 (4%) であり、 登録で消費されるメモリ量 (バイト単位) で割った値となる。"

#. type: SS
#: build/C/man7/epoll.7:198
#, no-wrap
msgid "Example for suggested usage"
msgstr "おすすめな使用例"

#. type: Plain text
#: build/C/man7/epoll.7:227
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has "
"been called.  The function I<do_use_fd()> uses the new ready file descriptor "
"until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2).  An event-"
"driven state machine application should, after having received B<EAGAIN>, "
"record its current state so that at the next call to I<do_use_fd()> it will "
"continue to B<read>(2)  or B<write>(2)  from where it stopped before."
msgstr ""
"レベルトリガインタフェースとして使用するときの B<epoll> の使い方は B<poll>"
"(2)  と同じである。 しかしエッジトリガとして使う場合は、 アプリケーションのイ"
"ベントループでストール (stall) しないように、 使い方をより明確にしておく必要"
"がある。 この例では、リスナはブロックしないソケットであり、 B<listen>(2)  が"
"呼ばれている。 関数 I<do_use_fd()> は、 B<read>(2)  または B<write>(2)  に"
"よって B<EAGAIN> が返されるまでは、新しい準備済みのファイルディスクリプタを使"
"う。 イベント駆動ステートマシンアプリケーションは、 B<EAGAIN> を受信した後、"
"カレントの状態を記録しておくべきである。 これにより、次の I<do_use_fd()> 呼び"
"出しのときに、以前に停止したところから B<read>(2)  または B<write>(2)  を継続"
"することができる。"

#. type: Plain text
#: build/C/man7/epoll.7:233
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"

#. type: Plain text
#: build/C/man7/epoll.7:236
#, no-wrap
msgid ""
"/* Set up listening socket, \\(aqlisten_sock\\(aq (socket(),\n"
"   bind(), listen()) */\n"
msgstr ""
"/* Set up listening socket, \\(aqlisten_sock\\(aq (socket(),\n"
"   bind(), listen()) */\n"

#. type: Plain text
#: build/C/man7/epoll.7:242
#, no-wrap
msgid ""
"epollfd = epoll_create(10);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"epollfd = epoll_create(10);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:249
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:256
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_pwait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_pwait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/epoll.7:278
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                            (struct sockaddr *) &local, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                            (struct sockaddr *) &local, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:297
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"エッジトリガインタフェースとして使う場合、性能上の理由により、 一度 "
"(B<EPOLLIN>|B<EPOLLOUT>)  を指定してから (B<EPOLL_CTL_ADD> で) ファイルディス"
"クリプタを B<epoll> インタフェースに追加することができる。 これにより、 "
"B<epoll_ctl>(2)  に B<EPOLL_CTL_MOD> を指定して呼び出すことで B<EPOLLIN> と "
"B<EPOLLOUT> の連続的な切り替えが避けられる。"

#. type: SS
#: build/C/man7/epoll.7:297
#, no-wrap
msgid "Questions and answers"
msgstr "質問と解答"

#. type: TP
#: build/C/man7/epoll.7:298
#, no-wrap
msgid "B<Q0>"
msgstr "B<Q0>"

#. type: Plain text
#: build/C/man7/epoll.7:303
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"B<epoll> set?"
msgstr ""
"B<epoll> 集合内の登録されたファイルディスクリプタを区別するには、 何をキーと"
"して使えばよいか？"

#. type: TP
#: build/C/man7/epoll.7:303
#, no-wrap
msgid "B<A0>"
msgstr "B<A0>"

#. type: Plain text
#: build/C/man7/epoll.7:309
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""
"キーはファイルディスクリプタ番号とオープンファイル記述 (open file "
"description) の組である (オープンファイル記述は \"open file handle\" とも 呼"
"ばれ、オープンされたファイルのカーネルの内部表現である)。"

#. type: TP
#: build/C/man7/epoll.7:309
#, no-wrap
msgid "B<Q1>"
msgstr "B<Q1>"

#. type: Plain text
#: build/C/man7/epoll.7:314
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""
"1 つの B<epoll> インスタンスに同じファイルディスクリプタを 2 回登録するとどう"
"なるか？"

#. type: TP
#: build/C/man7/epoll.7:314
#, no-wrap
msgid "B<A1>"
msgstr "B<A1>"

#.  But a descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, descriptors duplicated by fork have
#.  similar semantics to descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  descriptor means that even if the parent closes its descriptor, then
#.  epoll_wait() in the parent will continue to receive notifications for
#.  that descriptor because of the duplicated descriptor in the child.
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#.  mtk, Feb 2008
#. type: Plain text
#: build/C/man7/epoll.7:345
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate "
"(B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  descriptor to the same "
"B<epoll> instance.  This can be a useful technique for filtering events, if "
"the duplicate file descriptors are registered with different I<events> masks."
msgstr ""
"たぶん B<EEXIST> を受け取るだろう。 しかしながら、同じ B<epoll> インスタンス"
"に対して複製されたディスクリプタを追加することは可能である (B<dup>(2), "
"B<dup2>(2), B<fcntl>(2)  B<F_DUPFD> など)。 複製したファイルディスクリプタを"
"異なる I<events> マスクで登録すれば、イベントをフィルタリングするのに この機"
"能は有用な手法である。"

#. type: TP
#: build/C/man7/epoll.7:345
#, no-wrap
msgid "B<Q2>"
msgstr "B<Q2>"

#. type: Plain text
#: build/C/man7/epoll.7:353
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""
"2 つの B<epoll> インスタンスが同じファイルディスクリプタを待ち受けることは可"
"能か？ もし可能であれば、イベントは両方の B<epoll> ファイルディスクリプタに報"
"告されるか？"

#. type: TP
#: build/C/man7/epoll.7:353
#, no-wrap
msgid "B<A2>"
msgstr "B<A2>"

#. type: Plain text
#: build/C/man7/epoll.7:357
msgid ""
"Yes, and events would be reported to both.  However, careful programming may "
"be needed to do this correctly."
msgstr ""
"イベントは両方に報告される。 しかしながら、これを正しく扱うには注意深くプログ"
"ラミングする必要が あるかもしれない。"

#. type: TP
#: build/C/man7/epoll.7:357
#, no-wrap
msgid "B<Q3>"
msgstr "B<Q3>"

#. type: Plain text
#: build/C/man7/epoll.7:362
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr "B<epoll> ファイルディスクリプタ自身は poll/epoll/select が可能か？"

#. type: TP
#: build/C/man7/epoll.7:362
#, no-wrap
msgid "B<A3>"
msgstr "B<A3>"

#. type: Plain text
#: build/C/man7/epoll.7:369
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting then it will "
"indicate as being readable."
msgstr ""
"可能である。 B<epoll> ファイルディスクリプタに処理待ちのイベントがある場合"
"は、 読み出し可能だと通知されることだろう。"

#. type: TP
#: build/C/man7/epoll.7:369
#, no-wrap
msgid "B<Q4>"
msgstr "B<Q4>"

#. type: Plain text
#: build/C/man7/epoll.7:374
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own "
"file descriptor set?"
msgstr ""
"B<epoll> ファイルディスクリプタを自身のファイルディスクリプタ集合に 入れよう"
"とするとどうなるか？"

#. type: TP
#: build/C/man7/epoll.7:374
#, no-wrap
msgid "B<A4>"
msgstr "B<A4>"

#. type: Plain text
#: build/C/man7/epoll.7:385
msgid ""
"The B<epoll_ctl>(2)  call will fail (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""
"B<epoll_ctl>(2)  の呼び出しは (B<EINVAL> で) 失敗するだろう。 ただし "
"B<epoll> ファイルディスクリプタを他の B<epoll> ファイルディスクリプタ集合の内"
"部に追加することは可能である。"

#. type: TP
#: build/C/man7/epoll.7:385
#, no-wrap
msgid "B<Q5>"
msgstr "B<Q5>"

#. type: Plain text
#: build/C/man7/epoll.7:390
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""
"B<epoll> ファイルディスクリプタを UNIX ドメインソケットで他のプロセスに送るこ"
"とは可能か？"

#. type: TP
#: build/C/man7/epoll.7:390
#, no-wrap
msgid "B<A5>"
msgstr "B<A5>"

#. type: Plain text
#: build/C/man7/epoll.7:396
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the B<epoll> set."
msgstr ""
"可能だが、これをすることに意味はない。 なぜなら、受信側のプロセスが B<epoll> "
"集合内のファイルディスクリプタのコピーを持っていないからである。"

#. type: TP
#: build/C/man7/epoll.7:396
#, no-wrap
msgid "B<Q6>"
msgstr "B<Q6>"

#. type: Plain text
#: build/C/man7/epoll.7:401
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> sets "
"automatically?"
msgstr ""
"ファイルディスクリプタをクローズすると、そのファイルディスクリプタは全ての "
"B<epoll> 集合から自動的に削除されるか？"

#. type: TP
#: build/C/man7/epoll.7:401
#, no-wrap
msgid "B<A6>"
msgstr "B<A6>"

#. type: Plain text
#: build/C/man7/epoll.7:429
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or B<fork>"
"(2), a new file descriptor referring to the same open file description is "
"created.  An open file description continues to exist until all file "
"descriptors referring to it have been closed.  A file descriptor is removed "
"from an B<epoll> set only after all the file descriptors referring to the "
"underlying open file description have been closed (or before if the "
"descriptor is explicitly removed using B<epoll_ctl>(2)  B<EPOLL_CTL_DEL>).  "
"This means that even after a file descriptor that is part of an B<epoll> set "
"has been closed, events may be reported for that file descriptor if other "
"file descriptors referring to the same underlying file description remain "
"open."
msgstr ""
"削除されるが、以下の点に注意が必要である。 ファイルディスクリプタはオープン"
"ファイル記述 (B<open>(2)  参照) への参照である。 ディスクリプタの複製を "
"B<dup>(2), B<dup2>(2), B<fcntl>(2)  の B<F_DUPFD> や B<fork>(2)  経由で行う度"
"に、同じオープンファイル記述を参照する新規のファイル ディスクリプタが生成され"
"る。 オープンファイル記述自体は、自身を参照する全てのファイルディスクリプタ "
"がクローズされるまで存在し続ける。 ファイルディスクリプタが B<epoll> 集合から"
"削除されるのは、対応するオープンファイル記述を参照している 全てのファイルディ"
"スクリプタがクローズされた後である (B<epoll_ctl>(2)  B<EPOLL_CTL_DEL> を使っ"
"てそのディスクリプタを明示的に削除した場合にも削除される)。 このことは、 "
"B<epoll> 集合に属しているあるファイルディスクリプタをクローズした後であって"
"も、 同じファイル記述を参照する他のファイルディスクリプタがオープンされている"
"間は、 クローズしたファイルディスクリプタ宛にイベントが報告される可能性がある"
"と いうことを意味する。"

#. type: TP
#: build/C/man7/epoll.7:429
#, no-wrap
msgid "B<Q7>"
msgstr "B<Q7>"

#. type: Plain text
#: build/C/man7/epoll.7:434
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""
"2 つ以上のイベントが B<epoll_wait>(2)  コールの間に発生した場合、それらはまと"
"めて報告されるか、 それとも別々に報告されるか？"

#. type: TP
#: build/C/man7/epoll.7:434
#, no-wrap
msgid "B<A7>"
msgstr "B<A7>"

#. type: Plain text
#: build/C/man7/epoll.7:437
msgid "They will be combined."
msgstr "まとめて報告されるだろう。"

#. type: TP
#: build/C/man7/epoll.7:437
#, no-wrap
msgid "B<Q8>"
msgstr "B<Q8>"

#. type: Plain text
#: build/C/man7/epoll.7:441
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""
"ファイルディスクリプタに対する操作は、 既に集められているがまだ報告されていな"
"いイベントに影響するか？"

#. type: TP
#: build/C/man7/epoll.7:441
#, no-wrap
msgid "B<A8>"
msgstr "B<A8>"

#. type: Plain text
#: build/C/man7/epoll.7:447
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""
"既存のファイルディスクリプタに対して 2 つの操作を行うことができる。 この場"
"合、削除には意味がない。 変更すると、使用可能な I/O が再び読み込まれる。"

#. type: TP
#: build/C/man7/epoll.7:447
#, no-wrap
msgid "B<Q9>"
msgstr "B<Q9>"

#. type: Plain text
#: build/C/man7/epoll.7:455
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior) ?"
msgstr ""
"B<EPOLLET> フラグ (エッジトリガ動作) を使っている場合、 B<EAGAIN> を受け取る"
"まで、 継続してファイルディスクリプタを読み書きする必要があるか？"

#. type: TP
#: build/C/man7/epoll.7:455
#, no-wrap
msgid "B<A9>"
msgstr "B<A9>"

#. type: Plain text
#: build/C/man7/epoll.7:465
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider "
"it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""
"B<epoll_wait>(2)  からイベントを受け取ることは、 そのファイルディスクリプタが"
"要求された I/O 操作に対して準備済みである、 ということをユーザに示すものであ"
"る。 次の (ブロックしない) read/write で B<EAGAIN> を受け取るまではファイル"
"ディスクリプタは準備済みであると 考えなければならない。 そのファイルディスク"
"リプタをいつどのように使うかは、 全くユーザに任されてる。"

#. type: Plain text
#: build/C/man7/epoll.7:471
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""
"パケット指向やトークン指向のファイル (例えば、データグラムソケット、 "
"canonical モードの端末) では、 読み込み用 / 書き込み用の I/O 空間の末尾を検知"
"する唯一の方法は B<EAGAIN> になるまで read/write を行うことである。"

#. type: Plain text
#: build/C/man7/epoll.7:487
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when "
"writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a stream-"
"oriented file.)"
msgstr ""
"ストリーム指向のファイル (例えば、パイプ、FIFO、ストリームソケット) では、 読"
"み込み用 / 書き込み用の I/O 空間が使い尽くされた状態は、 対象となるファイル"
"ディスクリプタから読み込んだデータ量または 書き込んだデータ量をチェックするこ"
"とでも検知できる。 例えば、ある特定の量のデータを読み込むために B<read>(2)  "
"を呼んだときに、 B<read>(2)  が返したバイト数がそれより少なかった場合、 その"
"ファイルディスクリプタの読み込み用 I/O 空間が 使い尽くされたことが分かる。 "
"B<write>(2)  を使って書き込みをするときも、同じことが言える (監視しているファ"
"イルディスクリプタが常にストリーム指向のファイルを 参照していることを保証でき"
"ない場合には、後者の手法の使用を避けること)。"

#. type: SS
#: build/C/man7/epoll.7:487
#, no-wrap
msgid "Possible pitfalls and ways to avoid them"
msgstr "ありがちな落とし穴と回避方法"

#. type: TP
#: build/C/man7/epoll.7:488
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr "B<o 飢餓 (starvation) (エッジトリガ)>"

#. type: Plain text
#: build/C/man7/epoll.7:496
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""
"大きな I/O 空間がある場合、 その I/O 空間のデータを全て処理 (drain) しようと"
"すると、 他のファイルが処理されず、飢餓を発生させることがある (この問題は "
"B<epoll> に固有のものではない)。"

#. type: Plain text
#: build/C/man7/epoll.7:504
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""
"この問題の解決法は、準備済み状態のリストを管理して、 関連する data 構造体の中"
"でファイルディスクリプタが 利用可能であるとマークすることである。 それによっ"
"て、利用可能なすべてのファイルの中で どのファイルを処理する必要があるかを憶え"
"ることができ、 しかも順番に処理 (round robin) することができる。 既に利用可能"
"であるファイルディスクリプタに対して それ以後に受け取るイベントを無視すること"
"もできる。"

#. type: TP
#: build/C/man7/epoll.7:504
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr "B<o イベントキャッシュを使っている場合>"

#. type: Plain text
#: build/C/man7/epoll.7:520
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)  "
"the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""
"イベントキャッシュを使っている場合、 または B<epoll_wait>(2)  から返された全"
"てのファイルディスクリプタを格納している場合、 クローズされたことを動的にマー"
"クする (つまり前のイベントの処理によってマークされる) 方法を提供すべきであ"
"る。 B<epoll_wait>(2)  から 100 個のイベントを受け取り、 イベント #47 ではあ"
"る条件でイベント #13 が閉じられると仮定する。 イベント #13 の構造体を削除し"
"ファイルディスクリプタを B<close>(2)  すると、イベントキャッシュはそのファイ"
"ルディスクリプタを待つイベントが 存在するといって、混乱が起きる。"

#. type: Plain text
#: build/C/man7/epoll.7:531
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and B<close>"
"(2), then mark its associated data structure as removed and link it to a "
"cleanup list.  If you find another event for file descriptor 13 in your "
"batch processing, you will discover the file descriptor had been previously "
"removed and there will be no confusion."
msgstr ""
"この問題を解決する 1 つの方法は、イベント 47 の処理をしている間に、 ファイル"
"ディスクリプタ 13 を削除して B<close>(2)  するために B<epoll_ctl>"
"(B<EPOLL_CTL_DEL>)  を呼び出し、関連付けられた data 構造体を削除済みとマーク"
"して、 クリーンアップリストにリンクすることである。 バッチ処理の中でファイル"
"ディスクリプタ 13 についての 他のイベントを見つけた場合、 そのファイルディス"
"クリプタが以前に削除されたものであると分かるので、 混乱は起きない。"

#. type: SH
#: build/C/man7/epoll.7:531 build/C/man2/epoll_create.2:108
#: build/C/man2/epoll_ctl.2:225 build/C/man2/epoll_wait.2:187
#: build/C/man2/poll.2:325
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man7/epoll.7:537
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""
"B<epoll> API は Linux カーネル 2.5.44 に導入された。 glibc でのサポートはバー"
"ジョン 2.3.2 で追加された。"

#. type: SH
#: build/C/man7/epoll.7:537 build/C/man2/epoll_create.2:118
#: build/C/man2/epoll_ctl.2:230 build/C/man2/epoll_wait.2:197
#: build/C/man2/poll.2:342
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/epoll.7:546
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has I</dev/poll>."
msgstr ""
"B<epoll> API は Linux 固有である。 他のシステムでも同様の機構が提供されている"
"場合がある。 例えば、FreeBSD の I<kqueue> や Solaris の I</dev/poll> などであ"
"る。"

#. type: SH
#: build/C/man7/epoll.7:546 build/C/man2/epoll_create.2:144
#: build/C/man2/epoll_ctl.2:253 build/C/man2/epoll_wait.2:229
#: build/C/man2/poll.2:379
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/epoll.7:551
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"
msgstr ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"

#. type: SH
#: build/C/man7/epoll.7:551 build/C/man2/epoll_create.2:149
#: build/C/man2/epoll_ctl.2:258 build/C/man2/epoll_wait.2:233
#: build/C/man2/poll.2:384
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/epoll.7:558 build/C/man2/epoll_create.2:156
#: build/C/man2/epoll_ctl.2:265 build/C/man2/epoll_wait.2:240
#: build/C/man2/poll.2:391
msgid ""
"This page is part of release 3.63 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.63 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/epoll_create.2:24
#, no-wrap
msgid "EPOLL_CREATE"
msgstr "EPOLL_CREATE"

#. type: TH
#: build/C/man2/epoll_create.2:24 build/C/man2/epoll_ctl.2:20
#, no-wrap
msgid "2012-04-15"
msgstr "2012-04-15"

#. type: Plain text
#: build/C/man2/epoll_create.2:27
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""
"epoll_create, epoll_create1 - epoll ファイルディスクリプタをオープンする"

#. type: Plain text
#: build/C/man2/epoll_create.2:30 build/C/man2/epoll_wait.2:28
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/epoll_create.2:33
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/epoll_create.2:42
msgid ""
"B<epoll_create>()  creates an B<epoll>(7)  instance.  Since Linux 2.6.8, the "
"I<size> argument is ignored, but must be greater than zero; see NOTES below."
msgstr ""
"B<epoll_create>()は B<epoll>(7) インスタンスを作成する。\n"
"Linux 2.6.8 以降では、I<size> 引き数は無視されるが、 0 より大きな値で\n"
"なければならない。下記の「注意」を参照。"

#. type: Plain text
#: build/C/man2/epoll_create.2:55
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""
"B<epoll_create>()  は、新しい epoll インスタンスを参照するファイルディスクリ"
"プタを返す。 このファイルディスクリプタは、その後の B<epoll> インタフェースの"
"呼び出しに使われる。 もう必要でなくなった場合は、 B<epoll_create>()  で返され"
"たファイルディスクリプタは B<close>(2)  を使ってクローズされるべきである。 あ"
"る epoll インスタンスを参照する全てのファイルディスクリプタがクローズされる"
"と、 カーネルはそのインスタンスを破壊して、対応するリソースを解放し、 再使用"
"できるようにする。"

#. type: SS
#: build/C/man2/epoll_create.2:55
#, no-wrap
msgid "epoll_create1()"
msgstr "epoll_create1()"

#. type: Plain text
#: build/C/man2/epoll_create.2:67
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different behavior:"
msgstr ""
"B<epoll_create1>()  は、 I<flags> が 0 の場合、現在では使われていない "
"I<size> 引き数がなくなっている点を除けば B<epoll_create>()  と同じである。 "
"I<flags> に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさ"
"せることができる。"

#. type: TP
#: build/C/man2/epoll_create.2:67
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr "B<EPOLL_CLOEXEC>"

#. type: Plain text
#: build/C/man2/epoll_create.2:77
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプタに対して close-on-exec (B<FD_CLOEXEC>)  フラグを"
"セットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: SH
#: build/C/man2/epoll_create.2:77 build/C/man2/epoll_ctl.2:157
#: build/C/man2/epoll_wait.2:150 build/C/man2/poll.2:296
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/epoll_create.2:84
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"成功すると、これらのシステムコールは 非負のファイルディスクリプタを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: SH
#: build/C/man2/epoll_create.2:84 build/C/man2/epoll_ctl.2:166
#: build/C/man2/epoll_wait.2:162 build/C/man2/poll.2:306
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/epoll_create.2:85 build/C/man2/epoll_create.2:89
#: build/C/man2/epoll_ctl.2:181 build/C/man2/epoll_wait.2:179
#: build/C/man2/poll.2:315
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/epoll_create.2:89
msgid "I<size> is not positive."
msgstr "I<size> が正でない。"

#. type: Plain text
#: build/C/man2/epoll_create.2:94
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr "(B<epoll_create1>())  I<flags> に無効な値が指定された。"

#. type: TP
#: build/C/man2/epoll_create.2:94
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/epoll_create.2:102
msgid ""
"The per-user limit on the number of epoll instances imposed by I</proc/sys/"
"fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  for further "
"details."
msgstr ""
"I</proc/sys/fs/epoll/max_user_instances> によって指定されている、epoll インス"
"タンスのユーザー単位の制限に達した。 更なる詳細については B<epoll>(7)  を参照"
"のこと。"

#. type: TP
#: build/C/man2/epoll_create.2:102
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/epoll_create.2:105
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム制限に達した。"

#. type: TP
#: build/C/man2/epoll_create.2:105 build/C/man2/epoll_ctl.2:204
#: build/C/man2/poll.2:322
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/epoll_create.2:108
msgid "There was insufficient memory to create the kernel object."
msgstr "カーネルオブジェクトを作成するのに十分なメモリがなかった。"

#. type: Plain text
#: build/C/man2/epoll_create.2:112
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll_create>() はカーネル 2.6 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_create.2:118
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""
"B<epoll_create1>() はカーネル 2.6.27 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.9 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_create.2:121
msgid "B<epoll_create>()  is Linux-specific."
msgstr "B<epoll_create>() は Linux 独自である。"

#. type: SH
#: build/C/man2/epoll_create.2:121 build/C/man2/epoll_ctl.2:234
#: build/C/man2/epoll_wait.2:200 build/C/man2/poll.2:348
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/epoll_create.2:144
msgid ""
"In the initial B<epoll_create>()  implementation, the I<size> argument "
"informed the kernel of the number of file descriptors that the caller "
"expected to add to the B<epoll> instance.  The kernel used this information "
"as a hint for the amount of space to initially allocate in internal data "
"structures describing events.  (If necessary, the kernel would allocate more "
"space if the caller's usage exceeded the hint given in I<size>.)  Nowadays, "
"this hint is no longer required (the kernel dynamically sizes the required "
"data structures without needing the hint), but I<size> must still be greater "
"than zero, in order to ensure backward compatibility when new B<epoll> "
"applications are run on older kernels."
msgstr ""
"初期の B<epoll_create>() の実装では、I<size> 引き数は、呼び出し元が "
"B<epoll>\n"
"インスタンスに追加しようとするファイルディスクリプタ数をカーネルに教えるの"
"に\n"
"使われていた。カーネルはこの情報をイベントの情報を格納する内部データ構造に"
"最\n"
"初に割り当てる大きさを決める際のヒントとして使用していた (I<size> で渡され"
"た\n"
"ヒントよりも使用量が大きくなった場合には、必要に応じてカーネルは追加で領域"
"を\n"
"割り当てる)。\n"
"\n"
"現在では、このヒントはもはや必要なくなっている (カーネルはヒントなしで必要"
"な\n"
"データ構造のサイズを動的に変更する) が、今も I<size> には 0 より大きい値を\n"
"指定しなければならない。これは、B<epoll> を使うアプリケーションが古いカーネ"
"ル\n"
"で実行される際の後方互換性を保証するためである。"

#. type: Plain text
#: build/C/man2/epoll_create.2:149
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/epoll_ctl.2:20
#, no-wrap
msgid "EPOLL_CTL"
msgstr "EPOLL_CTL"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:23
msgid "epoll_ctl - control interface for an epoll descriptor"
msgstr "epoll_ctl - epoll ディスクリプタのインタフェースを操作する"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:28
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:38
msgid ""
"This system call performs control operations on the B<epoll>(7)  instance "
"referred to by the file descriptor I<epfd>.  It requests that the operation "
"I<op> be performed for the target file descriptor, I<fd>."
msgstr ""
"このシステムコールは、ファイルディスクリプタ I<epfd> が参照する B<epoll>(7)\n"
"インスタンスに対する操作を行う。 対象のファイルディスクリプタ I<fd> に対し"
"て、\n"
"操作 I<op> の実行が要求される。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:42
msgid "Valid values for the I<op> argument are :"
msgstr "I<op> 引き数に指定できる有効な値は以下の通りである。"

#. type: TP
#: build/C/man2/epoll_ctl.2:42
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr "B<EPOLL_CTL_ADD>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:54
msgid ""
"Register the target file descriptor I<fd> on the B<epoll> instance referred "
"to by the file descriptor I<epfd> and associate the event I<event> with the "
"internal file linked to I<fd>."
msgstr ""
"対象のファイルディスクリプタ I<fd> をファイルディスクリプタ I<epfd> が参照す"
"る B<epoll> インスタンスに登録し、イベント I<event> を I<fd> に結び付けられた"
"内部ファイルに関連付ける。"

#. type: TP
#: build/C/man2/epoll_ctl.2:54
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr "B<EPOLL_CTL_MOD>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:60
msgid ""
"Change the event I<event> associated with the target file descriptor I<fd>."
msgstr ""
"イベント I<event> を対象のファイルディスクリプタ I<fd> に関連付けるように変更"
"する。"

#. type: TP
#: build/C/man2/epoll_ctl.2:60
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr "B<EPOLL_CTL_DEL>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:71
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the B<epoll> "
"instance referred to by I<epfd>.  The I<event> is ignored and can be NULL "
"(but see BUGS below)."
msgstr ""
"対象のファイルディスクリプタ I<fd> を I<epfd> が参照する B<epoll> インスタン"
"スから削除する。 I<event> 引き数は無視されるので、NULL にすることもできる (但"
"し、下記の「バグ」を参照)。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:79
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as :"
msgstr ""
"I<event> 引き数は、ファイルディスクリプタ I<fd> にリンクされたオブジェクトを"
"表す。 I<struct epoll_event> は以下のように定義される:"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:88
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:93
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;      /* epoll イベント */\n"
"    epoll_data_t data;        /* ユーザデータ変数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:100
msgid ""
"The I<events> member is a bit set composed using the following available "
"event types:"
msgstr ""
"I<events> メンバは、以下のような使用可能なイベントタイプを使って構成された "
"ビットセットである。"

#. type: TP
#: build/C/man2/epoll_ctl.2:100
#, no-wrap
msgid "B<EPOLLIN>"
msgstr "B<EPOLLIN>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:105
msgid "The associated file is available for B<read>(2)  operations."
msgstr "関連付けられたファイルに対して、 B<read>(2)  操作が可能である。"

#. type: TP
#: build/C/man2/epoll_ctl.2:105
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr "B<EPOLLOUT>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:110
msgid "The associated file is available for B<write>(2)  operations."
msgstr "関連付けられたファイルに対して、 B<write>(2)  操作が可能である。"

#. type: TP
#: build/C/man2/epoll_ctl.2:110
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr "B<EPOLLRDHUP\">(LinuxB<2.6.17>以降)\""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:116
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""
"ストリームソケットの他端が、コネクションの close 、 またはコネクションの書き"
"込み側の shutdown を行った。 (このフラグを使うと、エッジトリガの監視を行う場"
"合に、 通信のもう一端が閉じられたことを検知するコードを 非常に簡潔に書くこと"
"ができる。)"

#. type: TP
#: build/C/man2/epoll_ctl.2:116
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr "B<EPOLLPRI>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:121
msgid "There is urgent data available for B<read>(2)  operations."
msgstr "B<read>(2)  操作が可能な緊急 (urgent) データがある。"

#. type: TP
#: build/C/man2/epoll_ctl.2:121
#, no-wrap
msgid "B<EPOLLERR>"
msgstr "B<EPOLLERR>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:127
msgid ""
"Error condition happened on the associated file descriptor.  B<epoll_wait>"
"(2)  will always wait for this event; it is not necessary to set it in "
"I<events>."
msgstr ""
"関連付けられたファイルディスクリプタにエラー条件が起こった。 B<epoll_wait>"
"(2)  は常にこのイベントを待つので、 I<events> に設定する必要はない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:127
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr "B<EPOLLHUP>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:133
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""
"関連付けられたファイルディスクリプタにハングアップが起こった。 B<epoll_wait>"
"(2)  は常にこのイベントを待つので、 I<events> に設定する必要はない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:133
#, no-wrap
msgid "B<EPOLLET>"
msgstr "B<EPOLLET>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:143
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more "
"detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""
"関連付けられたファイルディスクリプタに エッジトリガ動作 (Edge Triggered "
"behavior) を設定する。 B<epoll> のデフォルトの動作は、レベルトリガ (Level "
"Triggered) である。 エッジトリガとレベルトリガによるイベント分配機構 (event "
"distribution architectures) についての詳細な情報は、 B<epoll>(7)  を参照する"
"こと。"

#. type: TP
#: build/C/man2/epoll_ctl.2:143
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr "B<EPOLLONESHOT> (Linux 2.6.2 以降)"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:157
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file "
"descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""
"関連付けられたファイルディスクリプタに 一撃動作 (One-Shot behavior) を設定す"
"る。 これはイベントが B<epoll_wait>(2)  によって引き出された後、 関連付けられ"
"たファイルディスクリプタが内部的に破棄され、 B<epoll> インタフェースによって"
"イベントが報告されなくなることを意味する。 新しいイベントマスクでファイルディ"
"スクリプタを再度有効にするためには、 B<epoll_ctl>()  に B<EPOLL_CTL_MOD> を指"
"定して呼び出さなければならない。 I<op> 引き数に指定できる有効な値は、以下の通"
"り:"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:166
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<epoll_ctl>()  は 0 を返す。 エラーが起こった場合、 "
"B<epoll_ctl>()  は -1 を返し、 I<errno> を適切に設定する。"

#. type: TP
#: build/C/man2/epoll_ctl.2:167 build/C/man2/epoll_wait.2:163
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:173
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr "I<epfd> か I<fd> が有効なファイルディスクリプタでない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:173
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:181
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""
"I<op> が B<EPOLL_CTL_ADD> であり、かつ与えられたファイルディスクリプタ I<fd> "
"がこの epoll インスタンスに既に登録されている。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:194
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""
"I<epfd> が B<epoll> ファイルディスクリプタでない。 または I<fd> が I<epfd> と"
"同一である。 または要求された操作 I<op> がこのインタフェースでサポートされて"
"いない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:194
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:204
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""
"I<op> が B<EPOLL_CTL_MOD> または B<EPOLL_CTL_DEL> で、かつ I<fd> がこの "
"epoll インスタンスに登録されていない。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:209
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr "要求された I<op> 制御操作を扱うのに十分なメモリがない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:209
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:219
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""
"epoll インスタンスに新しいファイルディスクリプタを登録 (B<EPOLL_CTL_ADD>)  し"
"ようとした際に、 I</proc/sys/fs/epoll/max_user_watches> で決まる上限に達し"
"た。 詳細は B<epoll>(7)  を参照。"

#. type: TP
#: build/C/man2/epoll_ctl.2:219
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:225
msgid "The target file I<fd> does not support B<epoll>."
msgstr "対象ファイル I<fd> が B<epoll> をサポートしていない。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_ctl.2:230
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr "B<epoll_ctl>()  はカーネル 2.6 で追加された。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:234
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr ""
"B<epoll_ctl>()  は Linux 独自である。\n"
"ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:239
msgid ""
"The B<epoll> interface supports all file descriptors that support B<poll>(2)."
msgstr ""
"B<epoll> インタフェースは、 B<poll>(2)  に対応している全てのファイルディスク"
"リプタに対応している。"

#. type: SH
#: build/C/man2/epoll_ctl.2:239 build/C/man2/epoll_wait.2:217
#: build/C/man2/poll.2:375
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:253
#, fuzzy
#| msgid ""
#| "In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required "
#| "a non-NULL pointer in I<event>, even though this argument is ignored.  "
#| "Since Linux 2.6.9, I<event> can be specified as NULL when using "
#| "B<EPOLL_CTL_DEL>.  Applications that need to be portable to kernels "
#| "before 2.6.9 should specify a non-NULL pointer in I<event>."
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-null pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-null pointer in I<event>."
msgstr ""
"Linux 2.6.9 より前では、 B<EPOLL_CTL_DEL> 操作の際、引き数 I<event> に (たと"
"え無視される場合であっても) NULL でないポインタを渡す必要があった。 カーネル "
"2.6.9 以降では、 B<EPOLL_CTL_DEL> を使う際に I<event> に NULL を指定できるよ"
"うになっている。 2.6.9 より前のカーネルへの移植性が必要なアプリケーションで"
"は、 I<event> に NULL でないポインタを指定すべきである。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:258
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/epoll_wait.2:22
#, no-wrap
msgid "EPOLL_WAIT"
msgstr "EPOLL_WAIT"

#. type: TH
#: build/C/man2/epoll_wait.2:22 build/C/man2/poll.2:31
#, no-wrap
msgid "2014-01-31"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:25
msgid ""
"epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""
"epoll_wait, epoll_pwait - epoll ファイルディスクリプタの I/O イベントを待つ"

#. type: Plain text
#: build/C/man2/epoll_wait.2:34
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:52
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll>(7)  "
"instance referred to by the file descriptor I<epfd>.  The memory area "
"pointed to by I<events> will contain the events that will be available for "
"the caller.  Up to I<maxevents> are returned by B<epoll_wait>().  The "
"I<maxevents> argument must be greater than zero."
msgstr ""
"B<epoll_wait>() システムコールは、ファイルディスクリプタ I<epfd> で参照され"
"る\n"
"B<epoll>(7) インスタンスに対するイベントを待つ。 I<events> が指すメモリ領域に"
"は、\n"
"呼び出し側が利用可能なイベントが格納される。最大 I<maxevents> 個のイベント"
"が\n"
"B<epoll_wait>() によって返される。\n"
"I<maxevents> 引き数は 0 より大きくなければならない。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:59
#, fuzzy
#| msgid ""
#| "The I<timeout_ts> argument specifies an upper limit on the amount of time "
#| "that B<ppoll>()  will block.  This argument is a pointer to a structure "
#| "of the following form:"
msgid ""
"The I<timeout> argument specifies the number of milliseconds that "
"B<epoll_wait>()  will block.  The call will block until either:"
msgstr ""
"I<timeout> 引き数は B<ppoll>()  が停止する時間の上限を指定するものである。 こ"
"の引き数には以下の型の構造体へのポインタを指定する。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:61
msgid "a file descriptor delivers an event;"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:63 build/C/man2/poll.2:136
msgid "the call is interrupted by a signal handler; or"
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:65
msgid "the timout expires."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_wait.2:80
#, fuzzy
#| msgid ""
#| "The I<timeout> argument specifies the minimum number of milliseconds that "
#| "B<epoll_wait>()  will block.  (This interval will be rounded up to the "
#| "system clock granularity, and kernel scheduling delays mean that the "
#| "blocking interval may overrun by a small amount.)  Specifying a "
#| "I<timeout> of -1 causes B<epoll_wait>()  to block indefinitely, while "
#| "specifying a I<timeout> equal to zero cause B<epoll_wait>()  to return "
#| "immediately, even if no events are available."
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a I<timeout> of -1 causes "
"B<epoll_wait>()  to block indefinitely, while specifying a I<timeout> equal "
"to zero cause B<epoll_wait>()  to return immediately, even if no events are "
"available."
msgstr ""
"I<timeout> 引き数は、 B<epoll_wait>() が停止する最小時間をミリ秒で指定\n"
"する (この停止時間はシステムクロックの粒度に切り上げられ、カーネルの\n"
"スケジューリング遅延により少しだけ長くなる可能性がある)。 \n"
"I<timeout> を -1 に指定すると、 B<epoll_wait>() は無限に停止する。 \n"
"I<timeout> を 0 に指定すると、 B<epoll_wait>() は利用可能なイベントが\n"
"なくても、すぐに返る。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:84
msgid "The I<struct epoll_event> is defined as :"
msgstr "I<struct epoll_event> は以下のように定義される:"

#. type: Plain text
#: build/C/man2/epoll_wait.2:93
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:98
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;    /* epoll イベント */\n"
"    epoll_data_t data;      /* ユーザデータ変数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:109
msgid ""
"The I<data> of each returned structure will contain the same data the user "
"set with an B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  while the "
"I<events> member will contain the returned event bit field."
msgstr ""
"返される構造体の I<data> メンバには、ユーザが B<epoll_ctl>(2)  "
"(B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  で指定したデータが格納される。 一方、 "
"I<events> メンバには返された利用可能なイベントのビットフィールドが格納され"
"る。"

#. type: SS
#: build/C/man2/epoll_wait.2:109
#, no-wrap
msgid "epoll_pwait()"
msgstr "epoll_pwait()"

#. type: Plain text
#: build/C/man2/epoll_wait.2:123
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like B<pselect>"
"(2), B<epoll_pwait>()  allows an application to safely wait until either a "
"file descriptor becomes ready or until a signal is caught."
msgstr ""
"B<epoll_wait>()  と B<epoll_pwait>()  の関係は、 B<select>(2)  と B<pselect>"
"(2)  の関係と同様である。 B<pselect>(2)  同様、 B<epoll_pwait>()  を使うと、"
"アプリケーションは、ファイルディスクリプタが準備できた状態になるか、 シグナル"
"が捕捉されるまで、安全に待つことができる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:127
msgid "The following B<epoll_pwait>()  call:"
msgstr "以下の B<epoll_pwait>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/epoll_wait.2:130
#, no-wrap
msgid "    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr "    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:135 build/C/man2/poll.2:245
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "次の呼び出しを I<atomic> に実行するのと等価である。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:138
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:142
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:150
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""
"I<sigmask> 引き数には NULL を指定してもよい。 その場合には、 B<epoll_pwait>"
"()  は B<epoll_wait>()  と等価となる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:162
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<epoll_wait>()  は要求された I/O に対して準備ができているファ"
"イルディスクリプタの数を返す。 また要求された I<timeout> ミリ秒の間にファイル"
"ディスクリプタが準備できない場合は、0 を返す。 エラーが起こった場合、 "
"B<epoll_wait>()  は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:167
msgid "I<epfd> is not a valid file descriptor."
msgstr "I<epfd> が有効なファイルディスクリプタでない。"

#. type: TP
#: build/C/man2/epoll_wait.2:167 build/C/man2/poll.2:307
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/epoll_wait.2:172
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr "I<events> で指されるメモリ領域に書き込み権限でアクセスできない。"

#. type: TP
#: build/C/man2/epoll_wait.2:172 build/C/man2/poll.2:311
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/epoll_wait.2:179
#, fuzzy
#| msgid ""
#| "The call was interrupted by a signal handler before either any of the "
#| "requested events occurred or the I<timeout> expired; see B<signal>(7)."
msgid ""
"The call was interrupted by a signal handler before either (1) any of the "
"requested events occurred or (2) the I<timeout> expired; see B<signal>(7)."
msgstr ""
"要求されたどのイベントも発生せず、かつ I<timeout> の期限が切れる前に、\n"
"システムコールがシグナルハンドラによって割り込まれた。 \n"
"B<signal>(7) 参照。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:187
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""
"I<epfd> が B<epoll> ファイルディスクリプタでない。 または I<maxevents> が 0 "
"以下である。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_wait.2:193
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll_wait>() はカーネル 2.6 で追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.3.2 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:197
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""
"B<epoll_pwait>() はカーネル 2.6.19 で Linux に追加された。\n"
"ライブラリによるサポートは glibc バージョン 2.6 以降で提供されている。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:200
msgid "B<epoll_wait>()  is Linux-specific."
msgstr "B<epoll_wait>() は Linux 独自である。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:210
msgid ""
"While one thread is blocked in a call to B<epoll_pwait>(), it is possible "
"for another thread to add a file descriptor to the waited-upon B<epoll> "
"instance.  If the new file descriptor becomes ready, it will cause the "
"B<epoll_wait>()  call to unblock."
msgstr ""
"あるスレッドが B<epoll_pwait>() を呼び出して停止されている間に、\n"
"別のスレッドが wait 中の B<epoll> インストールにファイルディスクリプタを\n"
"追加することがある。新しいファイルディスクリプタでイベントが発生すると、\n"
"B<epoll_wait>() の呼び出しによる停止が解除されることになる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:217
msgid ""
"For a discussion of what may happen if a file descriptor in an B<epoll> "
"instance being monitored by B<epoll_wait>()  is closed in another thread, "
"see B<select>(2)."
msgstr ""
"B<epoll_wait>() で監視中の B<epoll> インスタンス内のファイルディスクリプタが"
"別のスレッドによってクローズされた場合に何が起こるかの議論については、 "
"B<select>(2) を参照してほしい。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:229
msgid ""
"In kernels before 2.6.37, a I<timeout> value larger than approximately "
"I<LONG_MAX / HZ> milliseconds is treated as -1 (i.e., infinity).  Thus, for "
"example, on a system where the I<sizeof(long)> is 4 and the kernel I<HZ> "
"value is 1000, this means that timeouts greater than 35.79 minutes are "
"treated as infinity."
msgstr ""
"バージョン 2.6.37 より前のカーネルでは、おおよそ I<LONG_MAX / HZ> ミリ秒より"
"大きい I<timeout> 値は -1 (つまり無限大) として扱われる。したがって、例えば、"
"I<sizeof(long)> が 4 で、カーネルの I<HZ> の値が 1000 のシステムでは、 35.79 "
"分よりも大きなタイムアウトは無限大として扱われるということである。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:233
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/poll.2:31
#, no-wrap
msgid "POLL"
msgstr "POLL"

#. type: Plain text
#: build/C/man2/poll.2:34
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr "poll, ppoll - ファイルディスクリプタにおけるイベントを待つ"

#. type: Plain text
#: build/C/man2/poll.2:37
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr "B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/poll.2:39
#, no-wrap
msgid "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"
msgstr "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/poll.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/poll.2:45
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<timeout_ts>B<, const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<timeout_ts>B<, const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/poll.2:52
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O."
msgstr ""
"B<poll>()  は B<select>(2)  と同様の仕事を行う、つまり、ファイルディスクリプ"
"タ集合のいずれか一つが I/O を実行可能な状態になるのを待つ。"

#. type: Plain text
#: build/C/man2/poll.2:56
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""
"監視するファイルディスクリプタ集合は、 I<fds> 引き数で指定する。 I<fds> は、"
"以下の型の構造体の配列である。"

#. type: Plain text
#: build/C/man2/poll.2:64
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"

#. type: Plain text
#: build/C/man2/poll.2:71
msgid ""
"The caller should specify the number of items in the I<fds> array in I<nfds>."
msgstr "I<nfds> には、 I<fds> 配列の要素数を指定する。"

#. type: Plain text
#: build/C/man2/poll.2:86
msgid ""
"The field I<fd> contains a file descriptor for an open file.  If this field "
"is negative, then the corresponding I<events> field is ignored and the "
"I<revents> field returns zero.  (This provides an easy way of ignoring a "
"file descriptor for a single B<poll>()  call: simply negate the I<fd> field.)"
msgstr ""
"I<fd> フィールドには、オープンされたファイルのファイルディスクリプタが入"
"る。\n"
"このフィールドが負の場合、対応する I<events> フィールドは無視され、\n"
"I<revents> には 0 が返される。(この機能により、一つの B<poll>() の呼び出し"
"で\n"
"簡単にあるファイルディスクリプタを無視することができる。\n"
"単に I<fd> フィールドの符号を反転するだけでよい。)"

#. type: Plain text
#: build/C/man2/poll.2:101
#, fuzzy
#| msgid ""
#| "The field I<events> is an input parameter, a bit mask specifying the "
#| "events the application is interested in for the file descriptor I<fd>.  "
#| "If this field is specified as zero, then all events are ignored for I<fd> "
#| "and I<revents> returns zero."
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in for the file descriptor I<fd>.  This field "
"may be specified as zero, in which case the only events that can be returned "
"in I<revents> are B<POLLHUP>, B<POLLERR>, and B<POLLNVAL> (see below)."
msgstr ""
"構造体の I<events> 要素は入力パラメータで、\n"
"ファイルディスクリプタ I<fd> に関して、\n"
"アプリケーションが興味を持っているイベントのビットマスクを指定する。\n"
"このフィールドに 0 が指定された場合は、I<fd> の全てのイベントが無視され、\n"
"I<revents> には 0 が返される。"

#. type: Plain text
#: build/C/man2/poll.2:120
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""
"I<revents> 要素は出力パラメータで、実際に起こったイベントがカーネルにより設定"
"される。 I<revents> で返されるビット列には、 I<events> で指定したもののどれ"
"か、もしくは B<POLLERR>, B<POLLHUP>, B<POLLNVAL> のうちの一つが含まれる "
"(B<POLLERR>, B<POLLHUP>, B<POLLNVAL> の 3つのビットは I<events> に指定しても"
"意味がなく、対応した状態が真の場合に I<revents> に設定される)。"

#. type: Plain text
#: build/C/man2/poll.2:125
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""
"どのファイルディスクリプタにも要求したイベントが発生しておらず、 エラーも起こ"
"らない場合、 B<poll>()  はイベントのうちいずれか一つが発生するまで停止 "
"(block) する。"

#. type: Plain text
#: build/C/man2/poll.2:132
msgid ""
"The I<timeout> argument specifies the number of milliseconds that B<poll>()  "
"should block waiting for a file descriptor to become ready.  The call will "
"block until either:"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:134
msgid "a file descriptor becomes ready;"
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:138
msgid "the timeout expires."
msgstr ""

#. type: Plain text
#: build/C/man2/poll.2:152
#, fuzzy
#| msgid ""
#| "The I<timeout> argument specifies the number of milliseconds that B<poll>"
#| "()  should block waiting for a file descriptor to become ready.  This "
#| "interval will be rounded up to the system clock granularity, and kernel "
#| "scheduling delays mean that the blocking interval may overrun by a small "
#| "amount.  Specifying a negative value in I<timeout> means an infinite "
#| "timeout.  Specifying a I<timeout> of zero causes B<poll>()  to return "
#| "immediately, even if no file descriptors are ready."
msgid ""
"Note that the I<timeout> interval will be rounded up to the system clock "
"granularity, and kernel scheduling delays mean that the blocking interval "
"may overrun by a small amount.  Specifying a negative value in I<timeout> "
"means an infinite timeout.  Specifying a I<timeout> of zero causes B<poll>"
"()  to return immediately, even if no file descriptors are ready."
msgstr ""
"I<timeout> 引き数は、 ファイルディスクリプタが利用可能になるまで B<poll>() が"
"停止する時間をミリ秒で指定する。 この停止時間はシステムクロックの粒度に切り上"
"げられ、 カーネルのスケジューリング遅延により少しだけ長くなる可能性がある。 "
"I<timeout> に負の値を指定した場合、タイムアウト時間が無限大を意味する。 "
"I<timeout> を 0 に指定した場合、I/O 可能なファイルディスクリプタがない場合で"
"あっても、 B<poll>() はすぐに返る。"

#. type: Plain text
#: build/C/man2/poll.2:158
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""
"I<events> に指定したり、 I<revents> で返されるビットは I<E<lt>poll.hE<gt>> で"
"定義されている:"

#. type: TP
#: build/C/man2/poll.2:159
#, no-wrap
msgid "B<POLLIN>"
msgstr "B<POLLIN>"

#. type: Plain text
#: build/C/man2/poll.2:162
msgid "There is data to read."
msgstr "読み出し可能なデータがある。"

#. type: TP
#: build/C/man2/poll.2:162
#, no-wrap
msgid "B<POLLPRI>"
msgstr "B<POLLPRI>"

#. type: Plain text
#: build/C/man2/poll.2:166
msgid ""
"There is urgent data to read (e.g., out-of-band data on TCP socket; "
"pseudoterminal master in packet mode has seen state change in slave)."
msgstr ""
"読み出し可能な緊急データ (urgent data) がある (例えば、TCP ソケットの帯域外 "
"(out-of-band data) データを受信した場合や、 パケットモードの擬似端末のマスタ"
"がスレーブ側の変化を見つけたとき)。"

#. type: TP
#: build/C/man2/poll.2:166
#, no-wrap
msgid "B<POLLOUT>"
msgstr "B<POLLOUT>"

#. type: Plain text
#: build/C/man2/poll.2:169
msgid "Writing now will not block."
msgstr "書き込みが停止 (block) しない状態である。"

#. type: TP
#: build/C/man2/poll.2:169
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr "B<POLLRDHUP> (Linux 2.6.17 以降)"

#. type: Plain text
#: build/C/man2/poll.2:180
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""
"ストリームソケットの他端が、コネクションを close したか、 コネクションの書き"
"込み側を shutdown した。 この定義を有効にするには、 (「どの」ヘッダファイルを"
"インクルードするよりも前に)  B<_GNU_SOURCE> 機能検査マクロを定義しなければな"
"らない。"

#. type: TP
#: build/C/man2/poll.2:180
#, no-wrap
msgid "B<POLLERR>"
msgstr "B<POLLERR>"

#. type: Plain text
#: build/C/man2/poll.2:183
msgid "Error condition (output only)."
msgstr "エラー状態 (出力の場合のみ)。"

#. type: TP
#: build/C/man2/poll.2:183
#, no-wrap
msgid "B<POLLHUP>"
msgstr "B<POLLHUP>"

#. type: Plain text
#: build/C/man2/poll.2:186
msgid "Hang up (output only)."
msgstr "ハングアップした (出力の場合のみ)。"

#. type: TP
#: build/C/man2/poll.2:186
#, no-wrap
msgid "B<POLLNVAL>"
msgstr "B<POLLNVAL>"

#. type: Plain text
#: build/C/man2/poll.2:191
msgid "Invalid request: I<fd> not open (output only)."
msgstr "不正な要求: I<fd> がオープンされていない (出力の場合のみ)。"

#. type: Plain text
#: build/C/man2/poll.2:197
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""
"B<_XOPEN_SOURCE> を定義してコンパイルした場合には、以下の定義も行われる。 た"
"だし、上記のリストにあるビット以上の情報が得られる訳ではない。"

#. type: TP
#: build/C/man2/poll.2:198
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr "B<POLLRDNORM>"

#. type: Plain text
#: build/C/man2/poll.2:202
msgid "Equivalent to B<POLLIN>."
msgstr "B<POLLIN> と同じ。"

#. type: TP
#: build/C/man2/poll.2:202
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr "B<POLLRDBAND>"

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: build/C/man2/poll.2:206
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""
"優先帯域データ (priority band data) が読み出し可能である (普通は Linux では使"
"用されない)。"

#. type: TP
#: build/C/man2/poll.2:206
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr "B<POLLWRNORM>"

#. type: Plain text
#: build/C/man2/poll.2:210
msgid "Equivalent to B<POLLOUT>."
msgstr "B<POLLOUT> と同じ。"

#. type: TP
#: build/C/man2/poll.2:210
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr "B<POLLWRBAND>"

#. type: Plain text
#: build/C/man2/poll.2:213
msgid "Priority data may be written."
msgstr "優先帯域データ (priority data) が書き込み可能である。"

#. type: Plain text
#: build/C/man2/poll.2:217
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr "Linux では B<POLLMSG> も定義されているが、使用されていない。"

#. type: SS
#: build/C/man2/poll.2:217
#, no-wrap
msgid "ppoll()"
msgstr "ppoll()"

#. type: Plain text
#: build/C/man2/poll.2:231
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""
"B<poll>()  と B<ppoll>()  の関係は B<select>(2)  と B<pselect>(2)  の関係と同"
"じようなものである: B<pselect>(2)  と同様に、 B<ppoll>()  を使うと、アプリ"
"ケーションはファイルディスクリプタの状態変化 もしくはシグナルの捕捉を安全に待"
"つことができる。"

#. type: Plain text
#: build/C/man2/poll.2:237
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr ""
"I<timeout> 引き数の精度の違いを除くと、以下の B<ppoll>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/poll.2:240
#, no-wrap
msgid "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"
msgstr "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"

#. type: Plain text
#: build/C/man2/poll.2:249
#, no-wrap
msgid ""
"    sigset_t origmask;\n"
"    int timeout;\n"
msgstr ""
"    sigset_t origmask;\n"
"    int timeout;\n"

#. type: Plain text
#: build/C/man2/poll.2:255
#, no-wrap
msgid ""
"    timeout = (timeout_ts == NULL) ? -1 :\n"
"              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n"
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = poll(&fds, nfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    timeout = (timeout_ts == NULL) ? -1 :\n"
"              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n"
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = poll(&fds, nfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/poll.2:262
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr ""
"なぜ B<ppoll>()  が必要なのかについての説明は B<pselect>(2)  の説明を参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/poll.2:274
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""
"I<sigmask> 引き数に NULL が指定された場合、シグナルマスクの操作は行われない "
"(したがって、 B<ppoll>()  の B<poll>()  との違いは I<timeout> 引き数の精度だ"
"けとなる)。"

#. type: Plain text
#: build/C/man2/poll.2:281
msgid ""
"The I<timeout_ts> argument specifies an upper limit on the amount of time "
"that B<ppoll>()  will block.  This argument is a pointer to a structure of "
"the following form:"
msgstr ""
"I<timeout> 引き数は B<ppoll>()  が停止する時間の上限を指定するものである。 こ"
"の引き数には以下の型の構造体へのポインタを指定する。"

#. type: Plain text
#: build/C/man2/poll.2:288
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man2/poll.2:296
msgid ""
"If I<timeout_ts> is specified as NULL, then B<ppoll>()  can block "
"indefinitely."
msgstr ""
"I<timeout_ts> に NULL が指定された場合、 B<ppoll> は無限に停止することがあり"
"得る。"

#. type: Plain text
#: build/C/man2/poll.2:306
msgid ""
"On success, a positive number is returned; this is the number of structures "
"which have nonzero I<revents> fields (in other words, those descriptors with "
"events or errors reported).  A value of 0 indicates that the call timed out "
"and no file descriptors were ready.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"成功した場合は正の数を返す。この数は 0 以外の I<revents> 要素を持つ構造体の数"
"である (別の言い方をすると、これらのディスクリプタ にはイベントかエラー報告が"
"ある)。 値 0 は、タイムアウトとなり、どのファイルディスクリプタでもイベント"
"が 発生しなかったことを示す。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/poll.2:311
msgid ""
"The array given as argument was not contained in the calling program's "
"address space."
msgstr ""
"引き数として指定した配列が、呼び出したプロセスのアドレス空間に 含まれていな"
"い。"

#. type: Plain text
#: build/C/man2/poll.2:315
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""
"要求されたイベントのどれかが起こる前にシグナルが発生した。 B<signal>(7)  参"
"照。"

#. type: Plain text
#: build/C/man2/poll.2:322
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr "I<nfds> の値が B<RLIMIT_NOFILE> を超えた。"

#. type: Plain text
#: build/C/man2/poll.2:325
msgid "There was no space to allocate file descriptor tables."
msgstr "ファイルディスクリプタ・テーブルを確保するためのメモリがない。"

#.  library call was introduced in libc 5.4.28
#. type: Plain text
#: build/C/man2/poll.2:335
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  On older kernels "
"that lack this system call, the glibc (and the old Linux libc)  B<poll>()  "
"wrapper function provides emulation using B<select>(2)."
msgstr ""
"B<poll>() システムコールは Linux 2.1.23 で導入された。\n"
"このシステムコールが存在しない古いカーネルでは、\n"
"glibc (や古い Linux libc) は B<select>(2) を使用して B<poll>() \n"
"ラッパー関数のエミュレーションを行う。"

#. type: Plain text
#: build/C/man2/poll.2:342
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""
"B<ppoll>()  システムコールは カーネル 2.6.16 で Linux に追加された。 B<ppoll>"
"()  ライブラリコールは glibc 2.4 に追加された。"

#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: build/C/man2/poll.2:348
msgid "B<poll>()  conforms to POSIX.1-2001.  B<ppoll>()  is Linux-specific."
msgstr ""
"B<poll>()  は POSIX.1-2001 に準拠している。 B<ppoll>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/poll.2:356
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""
"いくつかの実装では、値 -1 を持った非標準の定数 B<INFTIM> が定義されており、 "
"B<poll>()  の I<timeout> の指定に使用できる。 この定数は glibc では定義されて"
"いない。"

#. type: Plain text
#: build/C/man2/poll.2:361
msgid ""
"For a discussion of what may happen if a file descriptor being monitored by "
"B<poll>()  is closed in another thread, see B<select>(2)."
msgstr ""
"B<poll>() で監視中のファイルディスクリプタが別のスレッドによってクローズされ"
"た場合に何が起こるかの議論については、 B<select>(2) を参照してほしい。"

#. type: SS
#: build/C/man2/poll.2:361
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/poll.2:375
msgid ""
"The Linux B<ppoll>()  system call modifies its I<timeout_ts> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<ppoll>()  function does not modify its I<timeout_ts> argument."
msgstr ""
"Linux の B<ppoll>()  システムコールは I<timeout_ts> 引き数を変更する。 しか"
"し、glibc のラッパー関数は、システムコールに渡す timeout 引き数 としてローカ"
"ル変数を使うことでこの動作を隠蔽している。 このため、glibc の B<ppoll>()  関"
"数では I<timeout_ts> 引き数は変更されない。"

#. type: Plain text
#: build/C/man2/poll.2:379
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""
"B<select>(2)  の「バグ」の節に書かれている、誤った準備完了通知 (spurious "
"readiness notifications) についての議論を参照のこと。"

#. type: Plain text
#: build/C/man2/poll.2:384
msgid "B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<time>(7)"
msgstr "B<restart_syscall>(2), B<select>(2), B<select_tut>(2), B<time>(7)"

#~ msgid "2012-08-17"
#~ msgstr "2012-08-17"

#~ msgid "2013-09-04"
#~ msgstr "2013-09-04"

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-03-22 04:25+0900\n"
"PO-Revision-Date: 2012-03-23 04:42+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "EPOLL"
msgstr "EPOLL"

#. type: TH
#: build/C/man7/epoll.7:21
#, no-wrap
msgid "2009-02-01"
msgstr "2009-02-01"

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:25
#: build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23
#: build/C/man2/poll.2:31
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man7/epoll.7:21 build/C/man2/epoll_create.2:25
#: build/C/man2/epoll_ctl.2:21 build/C/man2/epoll_wait.2:23
#: build/C/man2/poll.2:31
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man7/epoll.7:22 build/C/man2/epoll_create.2:26
#: build/C/man2/epoll_ctl.2:22 build/C/man2/epoll_wait.2:24
#: build/C/man2/poll.2:32
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man7/epoll.7:24
msgid "epoll - I/O event notification facility"
msgstr "epoll - I/O イベント通知機能"

#. type: SH
#: build/C/man7/epoll.7:24 build/C/man2/epoll_create.2:28
#: build/C/man2/epoll_ctl.2:24 build/C/man2/epoll_wait.2:26
#: build/C/man2/poll.2:34
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man7/epoll.7:26 build/C/man2/epoll_ctl.2:26
msgid "B<#include E<lt>sys/epoll.hE<gt>>"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>"

#. type: SH
#: build/C/man7/epoll.7:26 build/C/man2/epoll_create.2:35
#: build/C/man2/epoll_ctl.2:29 build/C/man2/epoll_wait.2:36
#: build/C/man2/poll.2:46
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man7/epoll.7:36
msgid ""
"B<epoll> is a variant of B<poll>(2)  that can be used either as an edge-"
"triggered or a level-triggered interface and scales well to large numbers of "
"watched file descriptors.  The following system calls are provided to create "
"and manage an B<epoll> instance:"
msgstr ""
"B<epoll> は B<poll>(2)  の一種であり、エッジトリガインタフェースと レベルトリ"
"ガインタフェースのどちらとしても使用することができ、 監視するファイルディスク"
"リプタの数が多い場合にも使用できる。 B<epoll> インスタンスの作成や管理を行う"
"ために 以下のシステムコールが提供されている:"

#. type: IP
#: build/C/man7/epoll.7:36 build/C/man7/epoll.7:46 build/C/man7/epoll.7:54
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/epoll.7:46
msgid ""
"An B<epoll> instance created by B<epoll_create>(2), which returns a file "
"descriptor referring to the epoll instance.  (The more recent "
"B<epoll_create1>(2)  extends the functionality of B<epoll_create>(2).)"
msgstr ""
"B<epoll> インスタンスは B<epoll_create>(2)  で作成される。 B<epoll_create>"
"(2)  は作成した epoll インスタンスを参照するファイルディスクリプタを返す。 "
"(もっと新しい B<epoll_create1>(2)  では、 B<epoll_create>(2)  の機能が拡張さ"
"れている)。"

#. type: Plain text
#: build/C/man7/epoll.7:54
msgid ""
"Interest in particular file descriptors is then registered via B<epoll_ctl>"
"(2).  The set of file descriptors currently registered on an B<epoll> "
"instance is sometimes called an I<epoll> set."
msgstr ""
"特定のファイルディスクリプタに対する監視内容を B<epoll_ctl>(2)  で登録する。 "
"B<epoll> インスタンスに現在登録されているファイルディスクリプタの集合は "
"I<epoll> 集合と呼ばれることもある。"

#. type: Plain text
#: build/C/man7/epoll.7:57
msgid "Finally, the actual wait is started by B<epoll_wait>(2)."
msgstr "最後に B<epoll_wait>(2)  で実際のイベント待ちを開始する。"

#. type: SS
#: build/C/man7/epoll.7:57
#, no-wrap
msgid "Level-Triggered and Edge-Triggered"
msgstr "レベルトリガとエッジトリガ"

#. type: Plain text
#: build/C/man7/epoll.7:66
msgid ""
"The B<epoll> event distribution interface is able to behave both as edge-"
"triggered (ET) and as level-triggered (LT).  The difference between the two "
"mechanisms can be described as follows.  Suppose that this scenario happens:"
msgstr ""
"B<epoll> イベント配送 (distribution) インタフェースは、 エッジトリガ (ET) と"
"してもレベルトリガ (LT) としても動作させることができる。 二つの配送機構の違い"
"は、次のように説明できる。 このようなシナリオが起こったとしよう:"

#. type: IP
#: build/C/man7/epoll.7:66
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/epoll.7:72
msgid ""
"The file descriptor that represents the read side of a pipe (I<rfd>)  is "
"registered on the B<epoll> instance."
msgstr ""
"パイプの読み込み側を表すファイルディスクリプタ (I<rfd>)  が B<epoll> インスタ"
"ンスに登録される。"

#. type: IP
#: build/C/man7/epoll.7:72
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/epoll.7:74
msgid "A pipe writer writes 2 kB of data on the write side of the pipe."
msgstr ""
"パイプへ書き込むプログラムが 2 kB のデータをパイプの書き込み側へ書き込む。"

#. type: IP
#: build/C/man7/epoll.7:74
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/epoll.7:80
msgid ""
"A call to B<epoll_wait>(2)  is done that will return I<rfd> as a ready file "
"descriptor."
msgstr ""
"B<epoll_wait>(2)  を呼び出すと、読み込み可能 (ready) なファイルディスクリプタ"
"として I<rfd> が返る。"

#. type: IP
#: build/C/man7/epoll.7:80
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/epoll.7:83
msgid "The pipe reader reads 1 kB of data from I<rfd>."
msgstr "パイプから読み出すプログラムが、1 kB のデータを I<rfd> から読み出す。"

#. type: IP
#: build/C/man7/epoll.7:83
#, no-wrap
msgid "5."
msgstr "5."

#. type: Plain text
#: build/C/man7/epoll.7:87
msgid "A call to B<epoll_wait>(2)  is done."
msgstr "B<epoll_wait>(2)  の呼び出しが行われる。"

#. type: Plain text
#: build/C/man7/epoll.7:122
msgid ""
"If the I<rfd> file descriptor has been added to the B<epoll> interface using "
"the B<EPOLLET> (edge-triggered)  flag, the call to B<epoll_wait>(2)  done in "
"step B<5> will probably hang despite the available data still present in the "
"file input buffer; meanwhile the remote peer might be expecting a response "
"based on the data it already sent.  The reason for this is that edge-"
"triggered mode only delivers events when changes occur on the monitored file "
"descriptor.  So, in step B<5> the caller might end up waiting for some data "
"that is already present inside the input buffer.  In the above example, an "
"event on I<rfd> will be generated because of the write done in B<2> and the "
"event is consumed in B<3>.  Since the read operation done in B<4> does not "
"consume the whole buffer data, the call to B<epoll_wait>(2)  done in step "
"B<5> might block indefinitely."
msgstr ""
"I<rfd> ファイルディスクリプタが B<EPOLLET> フラグ (エッジトリガ) を使って "
"B<epoll> に追加されていると、 利用可能なデータがファイル入力バッファにまだ存"
"在するにもかかわらず ステップ B<5> の B<epoll_wait>(2)  の呼び出しでハングす"
"る可能性がある。 その一方で、リモートの接続先 (peer) は既に送られたデータに "
"基づいて応答を期待しているかもしれない。 このようなことが起こる理由は、エッジ"
"トリガイベント配送では、 モニタしているファイルでイベントが起ったときにのみイ"
"ベントが 配送されるためである。 したがって、ステップ B<5> では、呼び出し側は"
"結果的に 入力バッファ内にすで存在するデータを待つことになるかもしれない。 上"
"記の例では、 B<2> で行われた書き込みによって I<rfd> に関するイベントが生成さ"
"れ、 B<3> でイベントが消費 (consume) される。 B<4> で行われる読み込み操作で"
"は、全部のバッファデータを消費しないので、 ステップ B<5> で行われる "
"B<epoll_wait>(2)  の呼び出しが 無期限に停止 (block) するかもしれない。"

#. type: Plain text
#: build/C/man7/epoll.7:132
msgid ""
"An application that employs the B<EPOLLET> flag should use nonblocking file "
"descriptors to avoid having a blocking read or write starve a task that is "
"handling multiple file descriptors.  The suggested way to use B<epoll> as an "
"edge-triggered (B<EPOLLET>)  interface is as follows:"
msgstr ""
"B<EPOLLET> フラグを採用するアプリケーションでは、 インタフェースはブロックし"
"ない (nonblocking) ファイルディスクリプタを 使うべきである。 これは、ブロック"
"される読み込みや書き込みによって、 複数のファイルディスクリプタを扱うタスク"
"が 停止してしまうのを避けるためである。 B<epoll> をエッジトリガ "
"(B<EPOLLET>)  インタフェースとして使うために提案される方法は以下の通りであ"
"る。"

#. type: TP
#: build/C/man7/epoll.7:133
#, no-wrap
msgid "B<i>"
msgstr "B<i>"

#. type: Plain text
#: build/C/man7/epoll.7:136
msgid "with nonblocking file descriptors; and"
msgstr "ブロックしないファイルディスクリプタと共に使う。"

#. type: TP
#: build/C/man7/epoll.7:136
#, no-wrap
msgid "B<ii>"
msgstr "B<ii>"

#. type: Plain text
#: build/C/man7/epoll.7:144
msgid ""
"by waiting for an event only after B<read>(2)  or B<write>(2)  return "
"B<EAGAIN>."
msgstr ""
"B<read>(2)  または B<write>(2)  が B<EAGAIN> を返した後でのみ、イベントを待"
"つ。"

#. type: Plain text
#: build/C/man7/epoll.7:155
msgid ""
"By contrast, when used as a level-triggered interface (the default, when "
"B<EPOLLET> is not specified), B<epoll> is simply a faster B<poll>(2), and "
"can be used wherever the latter is used since it shares the same semantics."
msgstr ""
"一方、レベルトリガインタフェースとして使う場合\n"
" (こちらがデフォルトである、\n"
"B<EPOLLET> が指定されなかった場合)、\n"
"B<epoll> は単に高速な B<poll>(2) であり、使い方が同じなので、\n"
"B<poll>(2) が使われているところではどこでも使用することができる。"

#. type: Plain text
#: build/C/man7/epoll.7:172
msgid ""
"Since even with edge-triggered B<epoll>, multiple events can be generated "
"upon receipt of multiple chunks of data, the caller has the option to "
"specify the B<EPOLLONESHOT> flag, to tell B<epoll> to disable the associated "
"file descriptor after the receipt of an event with B<epoll_wait>(2).  When "
"the B<EPOLLONESHOT> flag is specified, it is the caller's responsibility to "
"rearm the file descriptor using B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"エッジトリガを使った場合でも、複数のデータを受信すると複数の B<epoll> イベン"
"トが生成されるので、 呼び出し側には B<EPOLLONESHOT> フラグを指定するオプショ"
"ンがある。 このフラグは B<epoll> に対して、 B<epoll_wait>(2)  によるイベント"
"を受信した後で、関連するファイルディスクリプタを無効にさせる。 "
"B<EPOLLONESHOT> フラグが指定された場合、 B<epoll_ctl>(2)  に "
"B<EPOLL_CTL_MOD> を指定してファイルディスクリプタを再度使用できるようにするの"
"は、 呼び出し側の責任である。"

#. type: SS
#: build/C/man7/epoll.7:172
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インタフェース"

#.  Following was added in 2.6.28, but them removed in 2.6.29
#.  .TP
#.  .IR /proc/sys/fs/epoll/max_user_instances " (since Linux 2.6.28)"
#.  This specifies an upper limit on the number of epoll instances
#.  that can be created per real user ID.
#. type: Plain text
#: build/C/man7/epoll.7:180
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by epoll:"
msgstr ""
"epoll が消費するカーネルメモリの量を制限するために、 以下のインタフェースを使"
"用することができる。"

#. type: TP
#: build/C/man7/epoll.7:180
#, no-wrap
msgid "I</proc/sys/fs/epoll/max_user_watches> (since Linux 2.6.28)"
msgstr "I</proc/sys/fs/epoll/max_user_watches> (Linux 2.6.28 以降)"

#.  2.6.29 (in 2.6.28, the default was 1/32 of lowmem)
#. type: Plain text
#: build/C/man7/epoll.7:194
msgid ""
"This specifies a limit on the total number of file descriptors that a user "
"can register across all epoll instances on the system.  The limit is per "
"real user ID.  Each registered file descriptor costs roughly 90 bytes on a "
"32-bit kernel, and roughly 160 bytes on a 64-bit kernel.  Currently, the "
"default value for I<max_user_watches> is 1/25 (4%) of the available low "
"memory, divided by the registration cost in bytes."
msgstr ""
"このファイルは、あるユーザがシステム上の全ての epoll インスタンスに 登録でき"
"るファイルディスクリプタの総数の上限を規定する。 この上限は実ユーザ ID 単位で"
"ある。 登録されたファイルディスクリプタ 1 つが消費するメモリ量は、 32 ビット"
"カーネルでおよそ 90 バイト、 64 ビットカーネルでおよそ 160 バイトである。 現"
"在のところ、 I<max_user_watches> のデフォルト値は、利用可能なメモリ下限の "
"1/25 (4%) であり、 登録で消費されるメモリ量 (バイト単位) で割った値となる。"

#. type: SS
#: build/C/man7/epoll.7:194
#, no-wrap
msgid "Example for Suggested Usage"
msgstr "おすすめな使用例"

#. type: Plain text
#: build/C/man7/epoll.7:223
msgid ""
"While the usage of B<epoll> when employed as a level-triggered interface "
"does have the same semantics as B<poll>(2), the edge-triggered usage "
"requires more clarification to avoid stalls in the application event loop.  "
"In this example, listener is a nonblocking socket on which B<listen>(2)  has "
"been called.  The function I<do_use_fd()> uses the new ready file descriptor "
"until B<EAGAIN> is returned by either B<read>(2)  or B<write>(2).  An event-"
"driven state machine application should, after having received B<EAGAIN>, "
"record its current state so that at the next call to I<do_use_fd()> it will "
"continue to B<read>(2)  or B<write>(2)  from where it stopped before."
msgstr ""
"レベルトリガインタフェースとして使用するときの B<epoll> の使い方は B<poll>"
"(2)  と同じである。 しかしエッジトリガとして使う場合は、 アプリケーションのイ"
"ベントループでストール (stall) しないように、 使い方をより明確にしておく必要"
"がある。 この例では、リスナはブロックしないソケットであり、 B<listen>(2)  が"
"呼ばれている。 関数 I<do_use_fd()> は、 B<read>(2)  または B<write>(2)  に"
"よって B<EAGAIN> が返されるまでは、新しい準備済みのファイルディスクリプタを使"
"う。 イベント駆動ステートマシンアプリケーションは、 B<EAGAIN> を受信した後、"
"カレントの状態を記録しておくべきである。 これにより、次の I<do_use_fd()> 呼び"
"出しのときに、以前に停止したところから B<read>(2)  または B<write>(2)  を継続"
"することができる。"

#. type: Plain text
#: build/C/man7/epoll.7:229
#, no-wrap
msgid ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"
msgstr ""
"#define MAX_EVENTS 10\n"
"struct epoll_event ev, events[MAX_EVENTS];\n"
"int listen_sock, conn_sock, nfds, epollfd;\n"

#. type: Plain text
#: build/C/man7/epoll.7:232
#, no-wrap
msgid ""
"/* Set up listening socket, \\(aqlisten_sock\\(aq (socket(),\n"
"   bind(), listen()) */\n"
msgstr ""
"/* Set up listening socket, \\(aqlisten_sock\\(aq (socket(),\n"
"   bind(), listen()) */\n"

#. type: Plain text
#: build/C/man7/epoll.7:238
#, no-wrap
msgid ""
"epollfd = epoll_create(10);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"epollfd = epoll_create(10);\n"
"if (epollfd == -1) {\n"
"    perror(\"epoll_create\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:245
#, no-wrap
msgid ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"ev.events = EPOLLIN;\n"
"ev.data.fd = listen_sock;\n"
"if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &ev) == -1) {\n"
"    perror(\"epoll_ctl: listen_sock\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:252
#, no-wrap
msgid ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_pwait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"for (;;) {\n"
"    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);\n"
"    if (nfds == -1) {\n"
"        perror(\"epoll_pwait\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man7/epoll.7:274
#, no-wrap
msgid ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                            (struct sockaddr *) &local, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"    for (n = 0; n E<lt> nfds; ++n) {\n"
"        if (events[n].data.fd == listen_sock) {\n"
"            conn_sock = accept(listen_sock,\n"
"                            (struct sockaddr *) &local, &addrlen);\n"
"            if (conn_sock == -1) {\n"
"                perror(\"accept\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            setnonblocking(conn_sock);\n"
"            ev.events = EPOLLIN | EPOLLET;\n"
"            ev.data.fd = conn_sock;\n"
"            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,\n"
"                        &ev) == -1) {\n"
"                perror(\"epoll_ctl: conn_sock\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        } else {\n"
"            do_use_fd(events[n].data.fd);\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man7/epoll.7:293
msgid ""
"When used as an edge-triggered interface, for performance reasons, it is "
"possible to add the file descriptor inside the B<epoll> interface "
"(B<EPOLL_CTL_ADD>)  once by specifying (B<EPOLLIN>|B<EPOLLOUT>).  This "
"allows you to avoid continuously switching between B<EPOLLIN> and "
"B<EPOLLOUT> calling B<epoll_ctl>(2)  with B<EPOLL_CTL_MOD>."
msgstr ""
"エッジトリガインタフェースとして使う場合、性能上の理由により、 一度 "
"(B<EPOLLIN>|B<EPOLLOUT>)  を指定してから (B<EPOLL_CTL_ADD> で) ファイルディス"
"クリプタを B<epoll> インタフェースに追加することができる。 これにより、 "
"B<epoll_ctl>(2)  に B<EPOLL_CTL_MOD> を指定して呼び出すことで B<EPOLLIN> と "
"B<EPOLLOUT> の連続的な切り替えが避けられる。"

#. type: SS
#: build/C/man7/epoll.7:293
#, no-wrap
msgid "Questions and Answers"
msgstr "質問と解答"

#. type: TP
#: build/C/man7/epoll.7:294
#, no-wrap
msgid "B<Q0>"
msgstr "B<Q0>"

#. type: Plain text
#: build/C/man7/epoll.7:299
msgid ""
"What is the key used to distinguish the file descriptors registered in an "
"B<epoll> set?"
msgstr ""
"B<epoll> 集合内の登録されたファイルディスクリプタを区別するには、 何をキーと"
"して使えばよいか？"

#. type: TP
#: build/C/man7/epoll.7:299
#, no-wrap
msgid "B<A0>"
msgstr "B<A0>"

#. type: Plain text
#: build/C/man7/epoll.7:305
msgid ""
"The key is the combination of the file descriptor number and the open file "
"description (also known as an \"open file handle\", the kernel's internal "
"representation of an open file)."
msgstr ""
"キーはファイルディスクリプタ番号とオープンファイル記述 (open file "
"description) の組である (オープンファイル記述は \"open file handle\" とも 呼"
"ばれ、オープンされたファイルのカーネルの内部表現である)。"

#. type: TP
#: build/C/man7/epoll.7:305
#, no-wrap
msgid "B<Q1>"
msgstr "B<Q1>"

#. type: Plain text
#: build/C/man7/epoll.7:310
msgid ""
"What happens if you register the same file descriptor on an B<epoll> "
"instance twice?"
msgstr ""
"1 つの B<epoll> インスタンスに同じファイルディスクリプタを 2 回登録するとどう"
"なるか？"

#. type: TP
#: build/C/man7/epoll.7:310
#, no-wrap
msgid "B<A1>"
msgstr "B<A1>"

#.  But a descriptor duplicated by fork(2) can't be added to the
#.  set, because the [file *, fd] pair is already in the epoll set.
#.  That is a somewhat ugly inconsistency.  On the one hand, a child process
#.  cannot add the duplicate file descriptor to the epoll set.  (In every
#.  other case that I can think of, descriptors duplicated by fork have
#.  similar semantics to descriptors duplicated by dup() and friends.)  On
#.  the other hand, the very fact that the child has a duplicate of the
#.  descriptor means that even if the parent closes its descriptor, then
#.  epoll_wait() in the parent will continue to receive notifications for
#.  that descriptor because of the duplicated descriptor in the child.
#.  See http://thread.gmane.org/gmane.linux.kernel/596462/
#.  "epoll design problems with common fork/exec patterns"
#.  mtk, Feb 2008
#. type: Plain text
#: build/C/man7/epoll.7:341
msgid ""
"You will probably get B<EEXIST>.  However, it is possible to add a duplicate "
"(B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>)  descriptor to the same "
"B<epoll> instance.  This can be a useful technique for filtering events, if "
"the duplicate file descriptors are registered with different I<events> masks."
msgstr ""
"たぶん B<EEXIST> を受け取るだろう。 しかしながら、同じ B<epoll> インスタンス"
"に対して複製されたディスクリプタを追加することは可能である (B<dup>(2), "
"B<dup2>(2), B<fcntl>(2)  B<F_DUPFD> など)。 複製したファイルディスクリプタを"
"異なる I<events> マスクで登録すれば、イベントをフィルタリングするのに この機"
"能は有用な手法である。"

#. type: TP
#: build/C/man7/epoll.7:341
#, no-wrap
msgid "B<Q2>"
msgstr "B<Q2>"

#. type: Plain text
#: build/C/man7/epoll.7:349
msgid ""
"Can two B<epoll> instances wait for the same file descriptor? If so, are "
"events reported to both B<epoll> file descriptors?"
msgstr ""
"2 つの B<epoll> インスタンスが同じファイルディスクリプタを待ち受けることは可"
"能か？ もし可能であれば、イベントは両方の B<epoll> ファイルディスクリプタに報"
"告されるか？"

#. type: TP
#: build/C/man7/epoll.7:349
#, no-wrap
msgid "B<A2>"
msgstr "B<A2>"

#. type: Plain text
#: build/C/man7/epoll.7:353
msgid ""
"Yes, and events would be reported to both.  However, careful programming may "
"be needed to do this correctly."
msgstr ""
"イベントは両方に報告される。 しかしながら、これを正しく扱うには注意深くプログ"
"ラミングする必要が あるかもしれない。"

#. type: TP
#: build/C/man7/epoll.7:353
#, no-wrap
msgid "B<Q3>"
msgstr "B<Q3>"

#. type: Plain text
#: build/C/man7/epoll.7:358
msgid "Is the B<epoll> file descriptor itself poll/epoll/selectable?"
msgstr "B<epoll> ファイルディスクリプタ自身は poll/epoll/select が可能か？"

#. type: TP
#: build/C/man7/epoll.7:358
#, no-wrap
msgid "B<A3>"
msgstr "B<A3>"

#. type: Plain text
#: build/C/man7/epoll.7:365
msgid ""
"Yes.  If an B<epoll> file descriptor has events waiting then it will "
"indicate as being readable."
msgstr ""
"可能である。 B<epoll> ファイルディスクリプタに処理待ちのイベントがある場合"
"は、 読み出し可能だと通知されることだろう。"

#. type: TP
#: build/C/man7/epoll.7:365
#, no-wrap
msgid "B<Q4>"
msgstr "B<Q4>"

#. type: Plain text
#: build/C/man7/epoll.7:370
msgid ""
"What happens if one attempts to put an B<epoll> file descriptor into its own "
"file descriptor set?"
msgstr ""
"B<epoll> ファイルディスクリプタを自身のファイルディスクリプタ集合に 入れよう"
"とするとどうなるか？"

#. type: TP
#: build/C/man7/epoll.7:370
#, no-wrap
msgid "B<A4>"
msgstr "B<A4>"

#. type: Plain text
#: build/C/man7/epoll.7:381
msgid ""
"The B<epoll_ctl>(2)  call will fail (B<EINVAL>).  However, you can add an "
"B<epoll> file descriptor inside another B<epoll> file descriptor set."
msgstr ""
"B<epoll_ctl>(2)  の呼び出しは (B<EINVAL> で) 失敗するだろう。 ただし "
"B<epoll> ファイルディスクリプタを他の B<epoll> ファイルディスクリプタ集合の内"
"部に追加することは可能である。"

#. type: TP
#: build/C/man7/epoll.7:381
#, no-wrap
msgid "B<Q5>"
msgstr "B<Q5>"

#. type: Plain text
#: build/C/man7/epoll.7:386
msgid ""
"Can I send an B<epoll> file descriptor over a UNIX domain socket to another "
"process?"
msgstr ""
"B<epoll> ファイルディスクリプタを UNIX ドメインソケットで他のプロセスに送るこ"
"とは可能か？"

#. type: TP
#: build/C/man7/epoll.7:386
#, no-wrap
msgid "B<A5>"
msgstr "B<A5>"

#. type: Plain text
#: build/C/man7/epoll.7:392
msgid ""
"Yes, but it does not make sense to do this, since the receiving process "
"would not have copies of the file descriptors in the B<epoll> set."
msgstr ""
"可能だが、これをすることに意味はない。 なぜなら、受信側のプロセスが B<epoll> "
"集合内のファイルディスクリプタのコピーを持っていないからである。"

#. type: TP
#: build/C/man7/epoll.7:392
#, no-wrap
msgid "B<Q6>"
msgstr "B<Q6>"

#. type: Plain text
#: build/C/man7/epoll.7:397
msgid ""
"Will closing a file descriptor cause it to be removed from all B<epoll> sets "
"automatically?"
msgstr ""
"ファイルディスクリプタをクローズすると、そのファイルディスクリプタは全ての "
"B<epoll> 集合から自動的に削除されるか？"

#. type: TP
#: build/C/man7/epoll.7:397
#, no-wrap
msgid "B<A6>"
msgstr "B<A6>"

#. type: Plain text
#: build/C/man7/epoll.7:425
msgid ""
"Yes, but be aware of the following point.  A file descriptor is a reference "
"to an open file description (see B<open>(2)).  Whenever a descriptor is "
"duplicated via B<dup>(2), B<dup2>(2), B<fcntl>(2)  B<F_DUPFD>, or B<fork>"
"(2), a new file descriptor referring to the same open file description is "
"created.  An open file description continues to exist until all file "
"descriptors referring to it have been closed.  A file descriptor is removed "
"from an B<epoll> set only after all the file descriptors referring to the "
"underlying open file description have been closed (or before if the "
"descriptor is explicitly removed using B<epoll_ctl>(2)  B<EPOLL_CTL_DEL>).  "
"This means that even after a file descriptor that is part of an B<epoll> set "
"has been closed, events may be reported for that file descriptor if other "
"file descriptors referring to the same underlying file description remain "
"open."
msgstr ""
"削除されるが、以下の点に注意が必要である。 ファイルディスクリプタはオープン"
"ファイル記述 (B<open>(2)  参照) への参照である。 ディスクリプタの複製を "
"B<dup>(2), B<dup2>(2), B<fcntl>(2)  の B<F_DUPFD> や B<fork>(2)  経由で行う度"
"に、同じオープンファイル記述を参照する新規のファイル ディスクリプタが生成され"
"る。 オープンファイル記述自体は、自身を参照する全てのファイルディスクリプタ "
"がクローズされるまで存在し続ける。 ファイルディスクリプタが B<epoll> 集合から"
"削除されるのは、対応するオープンファイル記述を参照している 全てのファイルディ"
"スクリプタがクローズされた後である (B<epoll_ctl>(2)  B<EPOLL_CTL_DEL> を使っ"
"てそのディスクリプタを明示的に削除した場合にも削除される)。 このことは、 "
"B<epoll> 集合に属しているあるファイルディスクリプタをクローズした後であって"
"も、 同じファイル記述を参照する他のファイルディスクリプタがオープンされている"
"間は、 クローズしたファイルディスクリプタ宛にイベントが報告される可能性がある"
"と いうことを意味する。"

#. type: TP
#: build/C/man7/epoll.7:425
#, no-wrap
msgid "B<Q7>"
msgstr "B<Q7>"

#. type: Plain text
#: build/C/man7/epoll.7:430
msgid ""
"If more than one event occurs between B<epoll_wait>(2)  calls, are they "
"combined or reported separately?"
msgstr ""
"2 つ以上のイベントが B<epoll_wait>(2)  コールの間に発生した場合、それらはまと"
"めて報告されるか、 それとも別々に報告されるか？"

#. type: TP
#: build/C/man7/epoll.7:430
#, no-wrap
msgid "B<A7>"
msgstr "B<A7>"

#. type: Plain text
#: build/C/man7/epoll.7:433
msgid "They will be combined."
msgstr "まとめて報告されるだろう。"

#. type: TP
#: build/C/man7/epoll.7:433
#, no-wrap
msgid "B<Q8>"
msgstr "B<Q8>"

#. type: Plain text
#: build/C/man7/epoll.7:437
msgid ""
"Does an operation on a file descriptor affect the already collected but not "
"yet reported events?"
msgstr ""
"ファイルディスクリプタに対する操作は、 既に集められているがまだ報告されていな"
"いイベントに影響するか？"

#. type: TP
#: build/C/man7/epoll.7:437
#, no-wrap
msgid "B<A8>"
msgstr "B<A8>"

#. type: Plain text
#: build/C/man7/epoll.7:443
msgid ""
"You can do two operations on an existing file descriptor.  Remove would be "
"meaningless for this case.  Modify will reread available I/O."
msgstr ""
"既存のファイルディスクリプタに対して 2 つの操作を行うことができる。 この場"
"合、削除には意味がない。 変更すると、使用可能な I/O が再び読み込まれる。"

#. type: TP
#: build/C/man7/epoll.7:443
#, no-wrap
msgid "B<Q9>"
msgstr "B<Q9>"

#. type: Plain text
#: build/C/man7/epoll.7:451
msgid ""
"Do I need to continuously read/write a file descriptor until B<EAGAIN> when "
"using the B<EPOLLET> flag (edge-triggered behavior) ?"
msgstr ""
"B<EPOLLET> フラグ (エッジトリガ動作) を使っている場合、 B<EAGAIN> を受け取る"
"まで、 継続してファイルディスクリプタを読み書きする必要があるか？"

#. type: TP
#: build/C/man7/epoll.7:451
#, no-wrap
msgid "B<A9>"
msgstr "B<A9>"

#. type: Plain text
#: build/C/man7/epoll.7:461
msgid ""
"Receiving an event from B<epoll_wait>(2)  should suggest to you that such "
"file descriptor is ready for the requested I/O operation.  You must consider "
"it ready until the next (nonblocking)  read/write yields B<EAGAIN>.  When "
"and how you will use the file descriptor is entirely up to you."
msgstr ""
"B<epoll_wait>(2)  からイベントを受け取ることは、 そのファイルディスクリプタが"
"要求された I/O 操作に対して準備済みである、 ということをユーザに示すものであ"
"る。 次の (ブロックしない) read/write で B<EAGAIN> を受け取るまではファイル"
"ディスクリプタは準備済みであると 考えなければならない。 そのファイルディスク"
"リプタをいつどのように使うかは、 全くユーザに任されてる。"

#. type: Plain text
#: build/C/man7/epoll.7:467
msgid ""
"For packet/token-oriented files (e.g., datagram socket, terminal in "
"canonical mode), the only way to detect the end of the read/write I/O space "
"is to continue to read/write until B<EAGAIN>."
msgstr ""
"パケット指向やトークン指向のファイル (例えば、データグラムソケット、 "
"canonical モードの端末) では、 読み込み用 / 書き込み用の I/O 空間の末尾を検知"
"する唯一の方法は B<EAGAIN> になるまで read/write を行うことである。"

#. type: Plain text
#: build/C/man7/epoll.7:483
msgid ""
"For stream-oriented files (e.g., pipe, FIFO, stream socket), the condition "
"that the read/write I/O space is exhausted can also be detected by checking "
"the amount of data read from / written to the target file descriptor.  For "
"example, if you call B<read>(2)  by asking to read a certain amount of data "
"and B<read>(2)  returns a lower number of bytes, you can be sure of having "
"exhausted the read I/O space for the file descriptor.  The same is true when "
"writing using B<write>(2).  (Avoid this latter technique if you cannot "
"guarantee that the monitored file descriptor always refers to a stream-"
"oriented file.)"
msgstr ""
"ストリーム指向のファイル (例えば、パイプ、FIFO、ストリームソケット) では、 読"
"み込み用 / 書き込み用の I/O 空間が使い尽くされた状態は、 対象となるファイル"
"ディスクリプタから読み込んだデータ量または 書き込んだデータ量をチェックするこ"
"とでも検知できる。 例えば、ある特定の量のデータを読み込むために B<read>(2)  "
"を呼んだときに、 B<read>(2)  が返したバイト数がそれより少なかった場合、 その"
"ファイルディスクリプタの読み込み用 I/O 空間が 使い尽くされたことが分かる。 "
"B<write>(2)  を使って書き込みをするときも、同じことが言える (監視しているファ"
"イルディスクリプタが常にストリーム指向のファイルを 参照していることを保証でき"
"ない場合には、後者の手法の使用を避けること)。"

#. type: SS
#: build/C/man7/epoll.7:483
#, no-wrap
msgid "Possible Pitfalls and Ways to Avoid Them"
msgstr "ありがちな落とし穴と回避方法"

#. type: TP
#: build/C/man7/epoll.7:484
#, no-wrap
msgid "B<o Starvation (edge-triggered)>"
msgstr "B<o 飢餓 (starvation) (エッジトリガ)>"

#. type: Plain text
#: build/C/man7/epoll.7:492
msgid ""
"If there is a large amount of I/O space, it is possible that by trying to "
"drain it the other files will not get processed causing starvation.  (This "
"problem is not specific to B<epoll>.)"
msgstr ""
"大きな I/O 空間がある場合、 その I/O 空間のデータを全て処理 (drain) しようと"
"すると、 他のファイルが処理されず、飢餓を発生させることがある (この問題は "
"B<epoll> に固有のものではない)。"

#. type: Plain text
#: build/C/man7/epoll.7:500
msgid ""
"The solution is to maintain a ready list and mark the file descriptor as "
"ready in its associated data structure, thereby allowing the application to "
"remember which files need to be processed but still round robin amongst all "
"the ready files.  This also supports ignoring subsequent events you receive "
"for file descriptors that are already ready."
msgstr ""
"この問題の解決法は、準備済み状態のリストを管理して、 関連する data 構造体の中"
"でファイルディスクリプタが 利用可能であるとマークすることである。 それによっ"
"て、利用可能なすべてのファイルの中で どのファイルを処理する必要があるかを憶え"
"ることができ、 しかも順番に処理 (round robin) することができる。 既に利用可能"
"であるファイルディスクリプタに対して それ以後に受け取るイベントを無視すること"
"もできる。"

#. type: TP
#: build/C/man7/epoll.7:500
#, no-wrap
msgid "B<o If using an event cache...>"
msgstr "B<o イベントキャッシュを使っている場合>"

#. type: Plain text
#: build/C/man7/epoll.7:516
msgid ""
"If you use an event cache or store all the file descriptors returned from "
"B<epoll_wait>(2), then make sure to provide a way to mark its closure "
"dynamically (i.e., caused by a previous event's processing).  Suppose you "
"receive 100 events from B<epoll_wait>(2), and in event #47 a condition "
"causes event #13 to be closed.  If you remove the structure and B<close>(2)  "
"the file descriptor for event #13, then your event cache might still say "
"there are events waiting for that file descriptor causing confusion."
msgstr ""
"イベントキャッシュを使っている場合、 または B<epoll_wait>(2)  から返された全"
"てのファイルディスクリプタを格納している場合、 クローズされたことを動的にマー"
"クする (つまり前のイベントの処理によってマークされる) 方法を提供すべきであ"
"る。 B<epoll_wait>(2)  から 100 個のイベントを受け取り、 イベント #47 ではあ"
"る条件でイベント #13 が閉じられると仮定する。 イベント #13 の構造体を削除し"
"ファイルディスクリプタを B<close>(2)  すると、イベントキャッシュはそのファイ"
"ルディスクリプタを待つイベントが 存在するといって、混乱が起きる。"

#. type: Plain text
#: build/C/man7/epoll.7:527
msgid ""
"One solution for this is to call, during the processing of event 47, "
"B<epoll_ctl>(B<EPOLL_CTL_DEL>)  to delete file descriptor 13 and B<close>"
"(2), then mark its associated data structure as removed and link it to a "
"cleanup list.  If you find another event for file descriptor 13 in your "
"batch processing, you will discover the file descriptor had been previously "
"removed and there will be no confusion."
msgstr ""
"この問題を解決する 1 つの方法は、イベント 47 の処理をしている間に、 ファイル"
"ディスクリプタ 13 を削除して B<close>(2)  するために B<epoll_ctl>"
"(B<EPOLL_CTL_DEL>)  を呼び出し、関連付けられた data 構造体を削除済みとマーク"
"して、 クリーンアップリストにリンクすることである。 バッチ処理の中でファイル"
"ディスクリプタ 13 についての 他のイベントを見つけた場合、 そのファイルディス"
"クリプタが以前に削除されたものであると分かるので、 混乱は起きない。"

#. type: SH
#: build/C/man7/epoll.7:527 build/C/man2/epoll_create.2:114
#: build/C/man2/epoll_ctl.2:224 build/C/man2/epoll_wait.2:174
#: build/C/man2/poll.2:286
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  Its interface should be finalized in Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man7/epoll.7:533
msgid ""
"The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was added "
"to glibc in version 2.3.2."
msgstr ""
"B<epoll> API は Linux カーネル 2.5.44 に導入された。 glibc でのサポートはバー"
"ジョン 2.3.2 で追加された。"

#. type: SH
#: build/C/man7/epoll.7:533 build/C/man2/epoll_create.2:124
#: build/C/man2/epoll_ctl.2:229 build/C/man2/epoll_wait.2:184
#: build/C/man2/poll.2:306
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man7/epoll.7:542
msgid ""
"The B<epoll> API is Linux-specific.  Some other systems provide similar "
"mechanisms, for example, FreeBSD has I<kqueue>, and Solaris has I</dev/poll>."
msgstr ""
"B<epoll> API は Linux 固有である。 他のシステムでも同様の機構が提供されている"
"場合がある。 例えば、FreeBSD の I<kqueue> や Solaris の I</dev/poll> などであ"
"る。"

#. type: SH
#: build/C/man7/epoll.7:542 build/C/man2/epoll_create.2:133
#: build/C/man2/epoll_ctl.2:252 build/C/man2/epoll_wait.2:187
#: build/C/man2/poll.2:338
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man7/epoll.7:547
msgid ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"
msgstr ""
"B<epoll_create>(2), B<epoll_create1>(2), B<epoll_ctl>(2), B<epoll_wait>(2)"

#. type: SH
#: build/C/man7/epoll.7:547 build/C/man2/epoll_create.2:138
#: build/C/man2/epoll_ctl.2:257 build/C/man2/epoll_wait.2:191
#: build/C/man2/poll.2:342
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man7/epoll.7:554 build/C/man2/epoll_create.2:145
#: build/C/man2/epoll_ctl.2:264 build/C/man2/epoll_wait.2:198
#: build/C/man2/poll.2:349
msgid ""
"This page is part of release 3.37 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.37 の一部である。\n"
"プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/epoll_create.2:25
#, no-wrap
msgid "EPOLL_CREATE"
msgstr "EPOLL_CREATE"

#. type: TH
#: build/C/man2/epoll_create.2:25 build/C/man2/epoll_ctl.2:21
#: build/C/man2/epoll_wait.2:23
#, fuzzy, no-wrap
#| msgid "2010-09-20"
msgid "2010-12-03"
msgstr "2010-09-20"

#. type: Plain text
#: build/C/man2/epoll_create.2:28
msgid "epoll_create, epoll_create1 - open an epoll file descriptor"
msgstr ""
"epoll_create, epoll_create1 - epoll ファイルディスクリプタをオープンする"

#. type: Plain text
#: build/C/man2/epoll_create.2:31 build/C/man2/epoll_wait.2:29
#, no-wrap
msgid "B<#include E<lt>sys/epoll.hE<gt>>\n"
msgstr "B<#include E<lt>sys/epoll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/epoll_create.2:34
#, no-wrap
msgid ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"
msgstr ""
"B<int epoll_create(int >I<size>B<);>\n"
"B<int epoll_create1(int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/epoll_create.2:48
#, fuzzy
#| msgid ""
#| "B<epoll_create>()  creates an epoll \"instance\", requesting the kernel "
#| "to allocate an event backing store dimensioned for I<size> descriptors.  "
#| "The I<size> is not the maximum size of the backing store but just a hint "
#| "to the kernel about how to dimension internal structures.  (Nowadays, "
#| "I<size> is ignored; see NOTES below.)"
msgid ""
"B<epoll_create>()  creates an epoll \"instance\", requesting the kernel to "
"allocate an event backing store dimensioned for I<size> descriptors.  The "
"I<size> is not the maximum size of the backing store but just a hint to the "
"kernel about how to dimension internal structures.  (Nowadays, I<size> is "
"unused; see NOTES below.)"
msgstr ""
"B<epoll_create>()  は、 I<size> 個のディスクリプタを保持できる大きさのイベン"
"トバッキング ストアの割り当てをカーネルに対して要求することにより、 epoll "
"「インスタンス」を作成する。 I<size> はバッキングストアの最大サイズではな"
"く、 内部構造の大きさをどの位にするかをカーネルに知らせるヒントでしかない。 "
"(現在は I<size> は無視される。下記の「注意」を参照。)"

#. type: Plain text
#: build/C/man2/epoll_create.2:61
msgid ""
"B<epoll_create>()  returns a file descriptor referring to the new epoll "
"instance.  This file descriptor is used for all the subsequent calls to the "
"B<epoll> interface.  When no longer required, the file descriptor returned "
"by B<epoll_create>()  should be closed by using B<close>(2).  When all file "
"descriptors referring to an epoll instance have been closed, the kernel "
"destroys the instance and releases the associated resources for reuse."
msgstr ""
"B<epoll_create>()  は、新しい epoll インスタンスを参照するファイルディスクリ"
"プタを返す。 このファイルディスクリプタは、その後の B<epoll> インタフェースの"
"呼び出しに使われる。 もう必要でなくなった場合は、 B<epoll_create>()  で返され"
"たファイルディスクリプタは B<close>(2)  を使ってクローズされるべきである。 あ"
"る epoll インスタンスを参照する全てのファイルディスクリプタがクローズされる"
"と、 カーネルはそのインスタンスを破壊して、対応するリソースを解放し、 再使用"
"できるようにする。"

#. type: Plain text
#: build/C/man2/epoll_create.2:73
msgid ""
"If I<flags> is 0, then, other than the fact that the obsolete I<size> "
"argument is dropped, B<epoll_create1>()  is the same as B<epoll_create>().  "
"The following value can be included in I<flags> to obtain different behavior:"
msgstr ""
"B<epoll_create1>()  は、 I<flags> が 0 の場合、現在では使われていない "
"I<size> 引き数がなくなっている点を除けば B<epoll_create>()  と同じである。 "
"I<flags> に以下の値をビット毎の論理和 (OR) で指定することで、 異なる動作をさ"
"せることができる。"

#. type: TP
#: build/C/man2/epoll_create.2:73
#, no-wrap
msgid "B<EPOLL_CLOEXEC>"
msgstr "B<EPOLL_CLOEXEC>"

#. type: Plain text
#: build/C/man2/epoll_create.2:83
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプタに対して close-on-exec (B<FD_CLOEXEC>)  フラグを"
"セットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: SH
#: build/C/man2/epoll_create.2:83 build/C/man2/epoll_ctl.2:156
#: build/C/man2/epoll_wait.2:137 build/C/man2/poll.2:257
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/epoll_create.2:90
msgid ""
"On success, these system calls return a nonnegative file descriptor.  On "
"error, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""
"成功すると、これらのシステムコールは 非負のファイルディスクリプタを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: SH
#: build/C/man2/epoll_create.2:90 build/C/man2/epoll_ctl.2:165
#: build/C/man2/epoll_wait.2:149 build/C/man2/poll.2:267
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/epoll_create.2:91 build/C/man2/epoll_create.2:95
#: build/C/man2/epoll_ctl.2:180 build/C/man2/epoll_wait.2:166
#: build/C/man2/poll.2:276
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/epoll_create.2:95
msgid "I<size> is not positive."
msgstr "I<size> が正でない。"

#. type: Plain text
#: build/C/man2/epoll_create.2:100
msgid "(B<epoll_create1>())  Invalid value specified in I<flags>."
msgstr "(B<epoll_create1>())  I<flags> に無効な値が指定された。"

#. type: TP
#: build/C/man2/epoll_create.2:100
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/epoll_create.2:108
msgid ""
"The per-user limit on the number of epoll instances imposed by I</proc/sys/"
"fs/epoll/max_user_instances> was encountered.  See B<epoll>(7)  for further "
"details."
msgstr ""
"I</proc/sys/fs/epoll/max_user_instances> によって指定されている、epoll インス"
"タンスのユーザー単位の制限に達した。 更なる詳細については B<epoll>(7)  を参照"
"のこと。"

#. type: TP
#: build/C/man2/epoll_create.2:108
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/epoll_create.2:111
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム制限に達した。"

#. type: TP
#: build/C/man2/epoll_create.2:111 build/C/man2/epoll_ctl.2:203
#: build/C/man2/poll.2:283
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/epoll_create.2:114
msgid "There was insufficient memory to create the kernel object."
msgstr "カーネルオブジェクトを作成するのに十分なメモリがなかった。"

#. type: Plain text
#: build/C/man2/epoll_create.2:118
#, fuzzy
#| msgid ""
#| "The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was "
#| "added to glibc in version 2.3.2."
msgid ""
"B<epoll_create>()  was added to the kernel in version 2.6.  Library support "
"is provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll> API は Linux カーネル 2.5.44 に導入された。 glibc でのサポートはバー"
"ジョン 2.3.2 で追加された。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_create.2:124
msgid ""
"B<epoll_create1>()  was added to the kernel in version 2.6.27.  Library "
"support is provided in glibc starting with version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man2/epoll_create.2:127
#, fuzzy
#| msgid ""
#| "B<epoll_create>()  is Linux-specific, and was introduced in kernel 2.5.44."
msgid "B<epoll_create>()  is Linux-specific."
msgstr "B<epoll_create>()  は Linux 独自であり、カーネル 2.5.44 で導入された。"

#. type: SH
#: build/C/man2/epoll_create.2:127 build/C/man2/epoll_ctl.2:233
#: build/C/man2/poll.2:312
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/epoll_create.2:133
#, fuzzy
#| msgid ""
#| "Since Linux 2.6.8, the I<size> argument is unused.  (The kernel "
#| "dynamically sizes the required data structures without needing this "
#| "initial hint.)"
msgid ""
"Since Linux 2.6.8, the I<size> argument is unused, but must be greater than "
"zero.  (The kernel dynamically sizes the required data structures without "
"needing this initial hint.)"
msgstr ""
"Linux 2.6.8 以降では、 I<size> 引き数は使用されない (カーネルは、動的に必要な"
"データ構造の大きさを決定し、 最初のヒントを必要しない)。"

#. type: Plain text
#: build/C/man2/epoll_create.2:138
msgid "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"
msgstr "B<close>(2), B<epoll_ctl>(2), B<epoll_wait>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/epoll_ctl.2:21
#, no-wrap
msgid "EPOLL_CTL"
msgstr "EPOLL_CTL"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:24
msgid "epoll_ctl - control interface for an epoll descriptor"
msgstr "epoll_ctl - epoll ディスクリプタのインタフェースを操作する"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:29
msgid ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"
msgstr ""
"B<int epoll_ctl(int >I<epfd>B<, int >I<op>B<, int >I<fd>B<, struct "
"epoll_event *>I<event>B<);>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:37
msgid ""
"This system call performs control operations on the epoll instance referred "
"to by the file descriptor I<epfd>.  It requests that the operation I<op> be "
"performed for the target file descriptor, I<fd>."
msgstr ""
"このシステムコールは、ファイルディスクリプタ I<epfd> が参照する epoll インス"
"タンスに対する操作を行う。 対象のファイルディスクリプタ I<fd> に対して、操作 "
"I<op> の実行が要求される。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:41
msgid "Valid values for the I<op> argument are :"
msgstr "I<op> 引き数に指定できる有効な値は以下の通りである。"

#. type: TP
#: build/C/man2/epoll_ctl.2:41
#, no-wrap
msgid "B<EPOLL_CTL_ADD>"
msgstr "B<EPOLL_CTL_ADD>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:53
msgid ""
"Register the target file descriptor I<fd> on the B<epoll> instance referred "
"to by the file descriptor I<epfd> and associate the event I<event> with the "
"internal file linked to I<fd>."
msgstr ""
"対象のファイルディスクリプタ I<fd> をファイルディスクリプタ I<epfd> が参照す"
"る B<epoll> インスタンスに登録し、イベント I<event> を I<fd> に結び付けられた"
"内部ファイルに関連付ける。"

#. type: TP
#: build/C/man2/epoll_ctl.2:53
#, no-wrap
msgid "B<EPOLL_CTL_MOD>"
msgstr "B<EPOLL_CTL_MOD>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:59
msgid ""
"Change the event I<event> associated with the target file descriptor I<fd>."
msgstr ""
"イベント I<event> を対象のファイルディスクリプタ I<fd> に関連付けるように変更"
"する。"

#. type: TP
#: build/C/man2/epoll_ctl.2:59
#, no-wrap
msgid "B<EPOLL_CTL_DEL>"
msgstr "B<EPOLL_CTL_DEL>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:70
msgid ""
"Remove (deregister) the target file descriptor I<fd> from the B<epoll> "
"instance referred to by I<epfd>.  The I<event> is ignored and can be NULL "
"(but see BUGS below)."
msgstr ""
"対象のファイルディスクリプタ I<fd> を I<epfd> が参照する B<epoll> インスタン"
"スから削除する。 I<event> 引き数は無視されるので、NULL にすることもできる (但"
"し、下記の「バグ」を参照)。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:78
msgid ""
"The I<event> argument describes the object linked to the file descriptor "
"I<fd>.  The I<struct epoll_event> is defined as :"
msgstr ""
"I<event> 引き数は、ファイルディスクリプタ I<fd> にリンクされたオブジェクトを"
"表す。 I<struct epoll_event> は以下のように定義される:"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:87
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void        *ptr;\n"
"    int          fd;\n"
"    uint32_t     u32;\n"
"    uint64_t     u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:92
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;      /* Epoll events */\n"
"    epoll_data_t data;        /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;      /* epoll イベント */\n"
"    epoll_data_t data;        /* ユーザデータ変数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:99
msgid ""
"The I<events> member is a bit set composed using the following available "
"event types:"
msgstr ""
"I<events> メンバは、以下のような使用可能なイベントタイプを使って構成された "
"ビットセットである。"

#. type: TP
#: build/C/man2/epoll_ctl.2:99
#, no-wrap
msgid "B<EPOLLIN>"
msgstr "B<EPOLLIN>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:104
msgid "The associated file is available for B<read>(2)  operations."
msgstr "関連付けられたファイルに対して、 B<read>(2)  操作が可能である。"

#. type: TP
#: build/C/man2/epoll_ctl.2:104
#, no-wrap
msgid "B<EPOLLOUT>"
msgstr "B<EPOLLOUT>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:109
msgid "The associated file is available for B<write>(2)  operations."
msgstr "関連付けられたファイルに対して、 B<write>(2)  操作が可能である。"

#. type: TP
#: build/C/man2/epoll_ctl.2:109
#, no-wrap
msgid "B<EPOLLRDHUP> (since Linux 2.6.17)"
msgstr "B<EPOLLRDHUP\">(LinuxB<2.6.17>以降)\""

#. type: Plain text
#: build/C/man2/epoll_ctl.2:115
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  (This flag is especially useful for writing simple code to "
"detect peer shutdown when using Edge Triggered monitoring.)"
msgstr ""
"ストリームソケットの他端が、コネクションの close 、 またはコネクションの書き"
"込み側の shutdown を行った。 (このフラグを使うと、エッジトリガの監視を行う場"
"合に、 通信のもう一端が閉じられたことを検知するコードを 非常に簡潔に書くこと"
"ができる。)"

#. type: TP
#: build/C/man2/epoll_ctl.2:115
#, no-wrap
msgid "B<EPOLLPRI>"
msgstr "B<EPOLLPRI>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:120
msgid "There is urgent data available for B<read>(2)  operations."
msgstr "B<read>(2)  操作が可能な緊急 (urgent) データがある。"

#. type: TP
#: build/C/man2/epoll_ctl.2:120
#, no-wrap
msgid "B<EPOLLERR>"
msgstr "B<EPOLLERR>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:126
msgid ""
"Error condition happened on the associated file descriptor.  B<epoll_wait>"
"(2)  will always wait for this event; it is not necessary to set it in "
"I<events>."
msgstr ""
"関連付けられたファイルディスクリプタにエラー条件が起こった。 B<epoll_wait>"
"(2)  は常にこのイベントを待つので、 I<events> に設定する必要はない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:126
#, no-wrap
msgid "B<EPOLLHUP>"
msgstr "B<EPOLLHUP>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:132
msgid ""
"Hang up happened on the associated file descriptor.  B<epoll_wait>(2)  will "
"always wait for this event; it is not necessary to set it in I<events>."
msgstr ""
"関連付けられたファイルディスクリプタにハングアップが起こった。 B<epoll_wait>"
"(2)  は常にこのイベントを待つので、 I<events> に設定する必要はない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:132
#, no-wrap
msgid "B<EPOLLET>"
msgstr "B<EPOLLET>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:142
msgid ""
"Sets the Edge Triggered behavior for the associated file descriptor.  The "
"default behavior for B<epoll> is Level Triggered.  See B<epoll>(7)  for more "
"detailed information about Edge and Level Triggered event distribution "
"architectures."
msgstr ""
"関連付けられたファイルディスクリプタに エッジトリガ動作 (Edge Triggered "
"behavior) を設定する。 B<epoll> のデフォルトの動作は、レベルトリガ (Level "
"Triggered) である。 エッジトリガとレベルトリガによるイベント分配機構 (event "
"distribution architectures) についての詳細な情報は、 B<epoll>(7)  を参照する"
"こと。"

#. type: TP
#: build/C/man2/epoll_ctl.2:142
#, no-wrap
msgid "B<EPOLLONESHOT> (since Linux 2.6.2)"
msgstr "B<EPOLLONESHOT> (Linux 2.6.2 以降)"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:156
msgid ""
"Sets the one-shot behavior for the associated file descriptor.  This means "
"that after an event is pulled out with B<epoll_wait>(2)  the associated file "
"descriptor is internally disabled and no other events will be reported by "
"the B<epoll> interface.  The user must call B<epoll_ctl>()  with "
"B<EPOLL_CTL_MOD> to rearm the file descriptor with a new event mask."
msgstr ""
"関連付けられたファイルディスクリプタに 一撃動作 (One-Shot behavior) を設定す"
"る。 これはイベントが B<epoll_wait>(2)  によって引き出された後、 関連付けられ"
"たファイルディスクリプタが内部的に破棄され、 B<epoll> インタフェースによって"
"イベントが報告されなくなることを意味する。 新しいイベントマスクでファイルディ"
"スクリプタを再度有効にするためには、 B<epoll_ctl>()  に B<EPOLL_CTL_MOD> を指"
"定して呼び出さなければならない。 I<op> 引き数に指定できる有効な値は、以下の通"
"り:"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:165
msgid ""
"When successful, B<epoll_ctl>()  returns zero.  When an error occurs, "
"B<epoll_ctl>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<epoll_ctl>()  は 0 を返す。 エラーが起こった場合、 "
"B<epoll_ctl>()  は -1 を返し、 I<errno> を適切に設定する。"

#. type: TP
#: build/C/man2/epoll_ctl.2:166 build/C/man2/epoll_wait.2:150
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:172
msgid "I<epfd> or I<fd> is not a valid file descriptor."
msgstr "I<epfd> か I<fd> が有効なファイルディスクリプタでない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:172
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:180
msgid ""
"I<op> was B<EPOLL_CTL_ADD>, and the supplied file descriptor I<fd> is "
"already registered with this epoll instance."
msgstr ""
"I<op> が B<EPOLL_CTL_ADD> であり、かつ与えられたファイルディスクリプタ I<fd> "
"がこの epoll インスタンスに既に登録されている。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:193
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<fd> is the same as I<epfd>, "
"or the requested operation I<op> is not supported by this interface."
msgstr ""
"I<epfd> が B<epoll> ファイルディスクリプタでない。 または I<fd> が I<epfd> と"
"同一である。 または要求された操作 I<op> がこのインタフェースでサポートされて"
"いない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:193
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:203
msgid ""
"I<op> was B<EPOLL_CTL_MOD> or B<EPOLL_CTL_DEL>, and I<fd> is not registered "
"with this epoll instance."
msgstr ""
"I<op> が B<EPOLL_CTL_MOD> または B<EPOLL_CTL_DEL> で、かつ I<fd> がこの "
"epoll インスタンスに登録されていない。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:208
msgid ""
"There was insufficient memory to handle the requested I<op> control "
"operation."
msgstr "要求された I<op> 制御操作を扱うのに十分なメモリがない。"

#. type: TP
#: build/C/man2/epoll_ctl.2:208
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:218
msgid ""
"The limit imposed by I</proc/sys/fs/epoll/max_user_watches> was encountered "
"while trying to register (B<EPOLL_CTL_ADD>)  a new file descriptor on an "
"epoll instance.  See B<epoll>(7)  for further details."
msgstr ""
"epoll インスタンスに新しいファイルディスクリプタを登録 (B<EPOLL_CTL_ADD>)  し"
"ようとした際に、 I</proc/sys/fs/epoll/max_user_watches> で決まる上限に達し"
"た。 詳細は B<epoll>(7)  を参照。"

#. type: TP
#: build/C/man2/epoll_ctl.2:218
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:224
msgid "The target file I<fd> does not support B<epoll>."
msgstr "対象ファイル I<fd> が B<epoll> をサポートしていない。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_ctl.2:229
#, fuzzy
#| msgid "B<epoll_pwait>()  was added to Linux in kernel 2.6.19."
msgid "B<epoll_ctl>()  was added to the kernel in version 2.6."
msgstr "B<epoll_pwait>()  はカーネル 2.6.19 で Linux に追加された。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:233
#, fuzzy
#| msgid ""
#| "B<epoll_ctl>()  is Linux-specific, and was introduced in kernel 2.5.44."
msgid ""
"B<epoll_ctl>()  is Linux-specific.  Library support is provided in glibc "
"starting with version 2.3.2."
msgstr "B<epoll_ctl>()  は Linux 独自であり、カーネル 2.5.44 で導入された。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:238
msgid ""
"The B<epoll> interface supports all file descriptors that support B<poll>(2)."
msgstr ""
"B<epoll> インタフェースは、 B<poll>(2)  に対応している全てのファイルディスク"
"リプタに対応している。"

#. type: SH
#: build/C/man2/epoll_ctl.2:238 build/C/man2/poll.2:334
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:252
msgid ""
"In kernel versions before 2.6.9, the B<EPOLL_CTL_DEL> operation required a "
"non-NULL pointer in I<event>, even though this argument is ignored.  Since "
"Linux 2.6.9, I<event> can be specified as NULL when using B<EPOLL_CTL_DEL>.  "
"Applications that need to be portable to kernels before 2.6.9 should specify "
"a non-NULL pointer in I<event>."
msgstr ""
"Linux 2.6.9 より前では、 B<EPOLL_CTL_DEL> 操作の際、引き数 I<event> に (たと"
"え無視される場合であっても) NULL でないポインタを渡す必要があった。 カーネル "
"2.6.9 以降では、 B<EPOLL_CTL_DEL> を使う際に I<event> に NULL を指定できるよ"
"うになっている。 2.6.9 より前のカーネルへの移植性が必要なアプリケーションで"
"は、 I<event> に NULL でないポインタを指定すべきである。"

#. type: Plain text
#: build/C/man2/epoll_ctl.2:257
msgid "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_wait>(2), B<poll>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/epoll_wait.2:23
#, no-wrap
msgid "EPOLL_WAIT"
msgstr "EPOLL_WAIT"

#. type: Plain text
#: build/C/man2/epoll_wait.2:26
msgid ""
"epoll_wait, epoll_pwait - wait for an I/O event on an epoll file descriptor"
msgstr ""
"epoll_wait, epoll_pwait - epoll ファイルディスクリプタの I/O イベントを待つ"

#. type: Plain text
#: build/C/man2/epoll_wait.2:35
#, no-wrap
msgid ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int epoll_wait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<);>\n"
"B<int epoll_pwait(int >I<epfd>B<, struct epoll_event *>I<events>B<,>\n"
"B<               int >I<maxevents>B<, int >I<timeout>B<,>\n"
"B<               const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:53
msgid ""
"The B<epoll_wait>()  system call waits for events on the B<epoll> instance "
"referred to by the file descriptor I<epfd>.  The memory area pointed to by "
"I<events> will contain the events that will be available for the caller.  Up "
"to I<maxevents> are returned by B<epoll_wait>().  The I<maxevents> argument "
"must be greater than zero."
msgstr ""
"B<epoll_wait>()  システムコールは、 ファイルディスクリプタ I<epfd> で参照され"
"る B<epoll> インスタンスに対するイベントを待つ。 I<events> が指すメモリ領域に"
"は、呼び出し側が利用可能なイベントが格納される。 最大 I<maxevents> 個のイベン"
"トが B<epoll_wait>()  によって返される。 I<maxevents> 引き数は 0 より大きくな"
"ければならない。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:67
msgid ""
"The call waits for a maximum time of I<timeout> milliseconds.  Specifying a "
"I<timeout> of -1 makes B<epoll_wait>()  wait indefinitely, while specifying "
"a I<timeout> equal to zero makes B<epoll_wait>()  to return immediately even "
"if no events are available (return code equal to zero)."
msgstr ""
"最大で I<timeout> ミリ秒間イベントを待つ。 I<timeout> を -1 に指定すると、 "
"B<epoll_wait>()  は無限に待つ。 また I<timeout> を 0 に指定すると、 "
"B<epoll_wait>()  はイベントが利用可能でなくても、すぐに返る (返り値は 0 であ"
"る)。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:71
msgid "The I<struct epoll_event> is defined as :"
msgstr "I<struct epoll_event> は以下のように定義される:"

#. type: Plain text
#: build/C/man2/epoll_wait.2:80
#, no-wrap
msgid ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"
msgstr ""
"typedef union epoll_data {\n"
"    void    *ptr;\n"
"    int      fd;\n"
"    uint32_t u32;\n"
"    uint64_t u64;\n"
"} epoll_data_t;\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:85
#, no-wrap
msgid ""
"struct epoll_event {\n"
"    uint32_t     events;    /* Epoll events */\n"
"    epoll_data_t data;      /* User data variable */\n"
"};\n"
msgstr ""
"struct epoll_event {\n"
"    uint32_t     events;    /* epoll イベント */\n"
"    epoll_data_t data;      /* ユーザデータ変数 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:96
msgid ""
"The I<data> of each returned structure will contain the same data the user "
"set with an B<epoll_ctl>(2)  (B<EPOLL_CTL_ADD>,B<EPOLL_CTL_MOD>)  while the "
"I<events> member will contain the returned event bit field."
msgstr ""
"返される構造体の I<data> メンバには、ユーザが B<epoll_ctl>(2)  "
"(B<EPOLL_CTL_ADD>, B<EPOLL_CTL_MOD>)  で指定したデータが格納される。 一方、 "
"I<events> メンバには返された利用可能なイベントのビットフィールドが格納され"
"る。"

#. type: SS
#: build/C/man2/epoll_wait.2:96
#, no-wrap
msgid "epoll_pwait()"
msgstr "epoll_pwait()"

#. type: Plain text
#: build/C/man2/epoll_wait.2:110
msgid ""
"The relationship between B<epoll_wait>()  and B<epoll_pwait>()  is analogous "
"to the relationship between B<select>(2)  and B<pselect>(2): like B<pselect>"
"(2), B<epoll_pwait>()  allows an application to safely wait until either a "
"file descriptor becomes ready or until a signal is caught."
msgstr ""
"B<epoll_wait>()  と B<epoll_pwait>()  の関係は、 B<select>(2)  と B<pselect>"
"(2)  の関係と同様である。 B<pselect>(2)  同様、 B<epoll_pwait>()  を使うと、"
"アプリケーションは、ファイルディスクリプタが準備できた状態になるか、 シグナル"
"が捕捉されるまで、安全に待つことができる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:114
msgid "The following B<epoll_pwait>()  call:"
msgstr "以下の B<epoll_pwait>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/epoll_wait.2:117
#, no-wrap
msgid "    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"
msgstr "    ready = epoll_pwait(epfd, &events, maxevents, timeout, &sigmask);\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:122 build/C/man2/poll.2:206
msgid "is equivalent to I<atomically> executing the following calls:"
msgstr "次の呼び出しを I<atomic> に実行するのと等価である。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:125
#, no-wrap
msgid "    sigset_t origmask;\n"
msgstr "    sigset_t origmask;\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:129
#, no-wrap
msgid ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = epoll_wait(epfd, &events, maxevents, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/epoll_wait.2:137
msgid ""
"The I<sigmask> argument may be specified as NULL, in which case "
"B<epoll_pwait>()  is equivalent to B<epoll_wait>()."
msgstr ""
"I<sigmask> 引き数には NULL を指定してもよい。 その場合には、 B<epoll_pwait>"
"()  は B<epoll_wait>()  と等価となる。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:149
msgid ""
"When successful, B<epoll_wait>()  returns the number of file descriptors "
"ready for the requested I/O, or zero if no file descriptor became ready "
"during the requested I<timeout> milliseconds.  When an error occurs, "
"B<epoll_wait>()  returns -1 and I<errno> is set appropriately."
msgstr ""
"成功した場合、 B<epoll_wait>()  は要求された I/O に対して準備ができているファ"
"イルディスクリプタの数を返す。 また要求された I<timeout> ミリ秒の間にファイル"
"ディスクリプタが準備できない場合は、0 を返す。 エラーが起こった場合、 "
"B<epoll_wait>()  は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:154
msgid "I<epfd> is not a valid file descriptor."
msgstr "I<epfd> が有効なファイルディスクリプタでない。"

#. type: TP
#: build/C/man2/epoll_wait.2:154 build/C/man2/poll.2:268
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/epoll_wait.2:159
msgid ""
"The memory area pointed to by I<events> is not accessible with write "
"permissions."
msgstr "I<events> で指されるメモリ領域に書き込み権限でアクセスできない。"

#. type: TP
#: build/C/man2/epoll_wait.2:159 build/C/man2/poll.2:272
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/epoll_wait.2:166
msgid ""
"The call was interrupted by a signal handler before any of the requested "
"events occurred or the I<timeout> expired; see B<signal>(7)."
msgstr ""
"要求されたどのイベントも発生せず、かつ I<timeout> の期限が切れる前に、システ"
"ムコールがシグナルハンドラによって割り込まれた。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:174
msgid ""
"I<epfd> is not an B<epoll> file descriptor, or I<maxevents> is less than or "
"equal to zero."
msgstr ""
"I<epfd> が B<epoll> ファイルディスクリプタでない。 または I<maxevents> が 0 "
"以下である。"

#.  To be precise: kernel 2.5.44.
#.  The interface should be finalized by Linux kernel 2.5.66.
#. type: Plain text
#: build/C/man2/epoll_wait.2:180
#, fuzzy
#| msgid ""
#| "The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was "
#| "added to glibc in version 2.3.2."
msgid ""
"B<epoll_wait>()  was added to the kernel in version 2.6.  Library support is "
"provided in glibc starting with version 2.3.2."
msgstr ""
"B<epoll> API は Linux カーネル 2.5.44 に導入された。 glibc でのサポートはバー"
"ジョン 2.3.2 で追加された。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:184
#, fuzzy
#| msgid ""
#| "The B<epoll> API was introduced in Linux kernel 2.5.44.  Support was "
#| "added to glibc in version 2.3.2."
msgid ""
"B<epoll_pwait>()  was added to Linux in kernel 2.6.19.  Library support is "
"provided in glibc starting with version 2.6."
msgstr ""
"B<epoll> API は Linux カーネル 2.5.44 に導入された。 glibc でのサポートはバー"
"ジョン 2.3.2 で追加された。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:187
#, fuzzy
#| msgid ""
#| "B<epoll_wait>()  is Linux-specific, and was introduced in kernel 2.5.44."
msgid "B<epoll_wait>()  is Linux-specific."
msgstr "B<epoll_wait>()  は Linux 独自であり、カーネル 2.5.44 で導入された。"

#. type: Plain text
#: build/C/man2/epoll_wait.2:191
msgid "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"
msgstr "B<epoll_create>(2), B<epoll_ctl>(2), B<epoll>(7)"

#. type: TH
#: build/C/man2/poll.2:31
#, no-wrap
msgid "POLL"
msgstr "POLL"

#. type: TH
#: build/C/man2/poll.2:31
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: build/C/man2/poll.2:34
msgid "poll, ppoll - wait for some event on a file descriptor"
msgstr "poll, ppoll - ファイルディスクリプタにおけるイベントを待つ"

#. type: Plain text
#: build/C/man2/poll.2:37
#, no-wrap
msgid "B<#include E<lt>poll.hE<gt>>\n"
msgstr "B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/poll.2:39
#, no-wrap
msgid "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"
msgstr "B<int poll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, int >I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/poll.2:42
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>poll.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>poll.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/poll.2:45
#, no-wrap
msgid ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<timeout_ts>B<, const sigset_t *>I<sigmask>B<);>\n"
msgstr ""
"B<int ppoll(struct pollfd *>I<fds>B<, nfds_t >I<nfds>B<, >\n"
"B<        const struct timespec *>I<timeout_ts>B<, const sigset_t *>I<sigmask>B<);>\n"

#. type: Plain text
#: build/C/man2/poll.2:52
msgid ""
"B<poll>()  performs a similar task to B<select>(2): it waits for one of a "
"set of file descriptors to become ready to perform I/O."
msgstr ""
"B<poll>()  は B<select>(2)  と同様の仕事を行う、つまり、ファイルディスクリプ"
"タ集合のいずれか一つが I/O を実行可能な状態になるのを待つ。"

#. type: Plain text
#: build/C/man2/poll.2:56
msgid ""
"The set of file descriptors to be monitored is specified in the I<fds> "
"argument, which is an array of structures of the following form:"
msgstr ""
"監視するファイルディスクリプタ集合は、 I<fds> 引き数で指定する。 I<fds> は、"
"以下の型の構造体の配列である。"

#. type: Plain text
#: build/C/man2/poll.2:64
#, no-wrap
msgid ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"
msgstr ""
"struct pollfd {\n"
"    int   fd;         /* file descriptor */\n"
"    short events;     /* requested events */\n"
"    short revents;    /* returned events */\n"
"};\n"

#. type: Plain text
#: build/C/man2/poll.2:71
msgid ""
"The caller should specify the number of items in the I<fds> array in I<nfds>."
msgstr "I<nfds> には、 I<fds> 配列の要素数を指定する。"

#. type: Plain text
#: build/C/man2/poll.2:75
msgid "The field I<fd> contains a file descriptor for an open file."
msgstr ""
"構造体の I<fd> にはオープンしたファイルのファイルディスクリプタを入れる。"

#. type: Plain text
#: build/C/man2/poll.2:80
msgid ""
"The field I<events> is an input parameter, a bit mask specifying the events "
"the application is interested in."
msgstr ""
"構造体の I<events> 要素は入力パラメータで、アプリケーションが興味を持っている"
"イベントの ビットマスクを指定する。"

#. type: Plain text
#: build/C/man2/poll.2:99
msgid ""
"The field I<revents> is an output parameter, filled by the kernel with the "
"events that actually occurred.  The bits returned in I<revents> can include "
"any of those specified in I<events>, or one of the values B<POLLERR>, "
"B<POLLHUP>, or B<POLLNVAL>.  (These three bits are meaningless in the "
"I<events> field, and will be set in the I<revents> field whenever the "
"corresponding condition is true.)"
msgstr ""
"I<revents> 要素は出力パラメータで、実際に起こったイベントがカーネルにより設定"
"される。 I<revents> で返されるビット列には、 I<events> で指定したもののどれ"
"か、もしくは B<POLLERR>, B<POLLHUP>, B<POLLNVAL> のうちの一つが含まれる "
"(B<POLLERR>, B<POLLHUP>, B<POLLNVAL> の 3つのビットは I<events> に指定しても"
"意味がなく、対応した状態が真の場合に I<revents> に設定される)。"

#. type: Plain text
#: build/C/man2/poll.2:104
msgid ""
"If none of the events requested (and no error) has occurred for any of the "
"file descriptors, then B<poll>()  blocks until one of the events occurs."
msgstr ""
"どのファイルディスクリプタにも要求したイベントが発生しておらず、 エラーも起こ"
"らない場合、 B<poll>()  はイベントのうちいずれか一つが発生するまで停止 "
"(block) する。"

#. type: Plain text
#: build/C/man2/poll.2:113
msgid ""
"The I<timeout> argument specifies an upper limit on the time for which "
"B<poll>()  will block, in milliseconds.  Specifying a negative value in "
"I<timeout> means an infinite timeout."
msgstr ""
"I<timeout> 引き数は B<poll>()  が停止する時間の上限を設定するもので、ミリ秒単"
"位で指定する。 I<timeout> に負の値を指定すると、タイムアウト時間が無限とな"
"る。"

#. type: Plain text
#: build/C/man2/poll.2:119
msgid ""
"The bits that may be set/returned in I<events> and I<revents> are defined in "
"I<E<lt>poll.hE<gt>>:"
msgstr ""
"I<events> に指定したり、 I<revents> で返されるビットは I<E<lt>poll.hE<gt>> で"
"定義されている:"

#. type: TP
#: build/C/man2/poll.2:120
#, no-wrap
msgid "B<POLLIN>"
msgstr "B<POLLIN>"

#. type: Plain text
#: build/C/man2/poll.2:123
msgid "There is data to read."
msgstr "読み出し可能なデータがある。"

#. type: TP
#: build/C/man2/poll.2:123
#, no-wrap
msgid "B<POLLPRI>"
msgstr "B<POLLPRI>"

#. type: Plain text
#: build/C/man2/poll.2:127
msgid ""
"There is urgent data to read (e.g., out-of-band data on TCP socket; "
"pseudoterminal master in packet mode has seen state change in slave)."
msgstr ""
"読み出し可能な緊急データ (urgent data) がある (例えば、TCP ソケットの帯域外 "
"(out-of-band data) データを受信した場合や、 パケットモードの擬似端末のマスタ"
"がスレーブ側の変化を見つけたとき)。"

#. type: TP
#: build/C/man2/poll.2:127
#, no-wrap
msgid "B<POLLOUT>"
msgstr "B<POLLOUT>"

#. type: Plain text
#: build/C/man2/poll.2:130
msgid "Writing now will not block."
msgstr "書き込みが停止 (block) しない状態である。"

#. type: TP
#: build/C/man2/poll.2:130
#, no-wrap
msgid "B<POLLRDHUP> (since Linux 2.6.17)"
msgstr "B<POLLRDHUP> (Linux 2.6.17 以降)"

#. type: Plain text
#: build/C/man2/poll.2:141
msgid ""
"Stream socket peer closed connection, or shut down writing half of "
"connection.  The B<_GNU_SOURCE> feature test macro must be defined (before "
"including I<any> header files)  in order to obtain this definition."
msgstr ""
"ストリームソケットの他端が、コネクションを close したか、 コネクションの書き"
"込み側を shutdown した。 この定義を有効にするには、 (「どの」ヘッダファイルを"
"インクルードするよりも前に)  B<_GNU_SOURCE> 機能検査マクロを定義しなければな"
"らない。"

#. type: TP
#: build/C/man2/poll.2:141
#, no-wrap
msgid "B<POLLERR>"
msgstr "B<POLLERR>"

#. type: Plain text
#: build/C/man2/poll.2:144
msgid "Error condition (output only)."
msgstr "エラー状態 (出力の場合のみ)。"

#. type: TP
#: build/C/man2/poll.2:144
#, no-wrap
msgid "B<POLLHUP>"
msgstr "B<POLLHUP>"

#. type: Plain text
#: build/C/man2/poll.2:147
msgid "Hang up (output only)."
msgstr "ハングアップした (出力の場合のみ)。"

#. type: TP
#: build/C/man2/poll.2:147
#, no-wrap
msgid "B<POLLNVAL>"
msgstr "B<POLLNVAL>"

#. type: Plain text
#: build/C/man2/poll.2:152
msgid "Invalid request: I<fd> not open (output only)."
msgstr "不正な要求: I<fd> がオープンされていない (出力の場合のみ)。"

#. type: Plain text
#: build/C/man2/poll.2:158
msgid ""
"When compiling with B<_XOPEN_SOURCE> defined, one also has the following, "
"which convey no further information beyond the bits listed above:"
msgstr ""
"B<_XOPEN_SOURCE> を定義してコンパイルした場合には、以下の定義も行われる。 た"
"だし、上記のリストにあるビット以上の情報が得られる訳ではない。"

#. type: TP
#: build/C/man2/poll.2:159
#, no-wrap
msgid "B<POLLRDNORM>"
msgstr "B<POLLRDNORM>"

#. type: Plain text
#: build/C/man2/poll.2:163
msgid "Equivalent to B<POLLIN>."
msgstr "B<POLLIN> と同じ。"

#. type: TP
#: build/C/man2/poll.2:163
#, no-wrap
msgid "B<POLLRDBAND>"
msgstr "B<POLLRDBAND>"

#.  POLLRDBAND is used in the DECnet protocol.
#. type: Plain text
#: build/C/man2/poll.2:167
msgid "Priority band data can be read (generally unused on Linux)."
msgstr ""
"優先帯域データ (priority band data) が読み出し可能である (普通は Linux では使"
"用されない)。"

#. type: TP
#: build/C/man2/poll.2:167
#, no-wrap
msgid "B<POLLWRNORM>"
msgstr "B<POLLWRNORM>"

#. type: Plain text
#: build/C/man2/poll.2:171
msgid "Equivalent to B<POLLOUT>."
msgstr "B<POLLOUT> と同じ。"

#. type: TP
#: build/C/man2/poll.2:171
#, no-wrap
msgid "B<POLLWRBAND>"
msgstr "B<POLLWRBAND>"

#. type: Plain text
#: build/C/man2/poll.2:174
msgid "Priority data may be written."
msgstr "優先帯域データ (priority data) が書き込み可能である。"

#. type: Plain text
#: build/C/man2/poll.2:178
msgid "Linux also knows about, but does not use B<POLLMSG>."
msgstr "Linux では B<POLLMSG> も定義されているが、使用されていない。"

#. type: SS
#: build/C/man2/poll.2:178
#, no-wrap
msgid "ppoll()"
msgstr "ppoll()"

#. type: Plain text
#: build/C/man2/poll.2:192
msgid ""
"The relationship between B<poll>()  and B<ppoll>()  is analogous to the "
"relationship between B<select>(2)  and B<pselect>(2): like B<pselect>(2), "
"B<ppoll>()  allows an application to safely wait until either a file "
"descriptor becomes ready or until a signal is caught."
msgstr ""
"B<poll>()  と B<ppoll>()  の関係は B<select>(2)  と B<pselect>(2)  の関係と同"
"じようなものである: B<pselect>(2)  と同様に、 B<ppoll>()  を使うと、アプリ"
"ケーションはファイルディスクリプタの状態変化 もしくはシグナルの捕捉を安全に待"
"つことができる。"

#. type: Plain text
#: build/C/man2/poll.2:198
msgid ""
"Other than the difference in the precision of the I<timeout> argument, the "
"following B<ppoll>()  call:"
msgstr ""
"I<timeout> 引き数の精度の違いを除くと、以下の B<ppoll>()  の呼び出しは、"

#. type: Plain text
#: build/C/man2/poll.2:201
#, no-wrap
msgid "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"
msgstr "    ready = ppoll(&fds, nfds, timeout_ts, &sigmask);\n"

#. type: Plain text
#: build/C/man2/poll.2:210
#, no-wrap
msgid ""
"    sigset_t origmask;\n"
"    int timeout;\n"
msgstr ""
"    sigset_t origmask;\n"
"    int timeout;\n"

#. type: Plain text
#: build/C/man2/poll.2:216
#, no-wrap
msgid ""
"    timeout = (timeout_ts == NULL) ? -1 :\n"
"              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n"
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = poll(&fds, nfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"
msgstr ""
"    timeout = (timeout_ts == NULL) ? -1 :\n"
"              (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);\n"
"    sigprocmask(SIG_SETMASK, &sigmask, &origmask);\n"
"    ready = poll(&fds, nfds, timeout);\n"
"    sigprocmask(SIG_SETMASK, &origmask, NULL);\n"

#. type: Plain text
#: build/C/man2/poll.2:223
msgid ""
"See the description of B<pselect>(2)  for an explanation of why B<ppoll>()  "
"is necessary."
msgstr ""
"なぜ B<ppoll>()  が必要なのかについての説明は B<pselect>(2)  の説明を参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/poll.2:235
msgid ""
"If the I<sigmask> argument is specified as NULL, then no signal mask "
"manipulation is performed (and thus B<ppoll>()  differs from B<poll>()  only "
"in the precision of the I<timeout> argument)."
msgstr ""
"I<sigmask> 引き数に NULL が指定された場合、シグナルマスクの操作は行われない "
"(したがって、 B<ppoll>()  の B<poll>()  との違いは I<timeout> 引き数の精度だ"
"けとなる)。"

#. type: Plain text
#: build/C/man2/poll.2:242
msgid ""
"The I<timeout_ts> argument specifies an upper limit on the amount of time "
"that B<ppoll>()  will block.  This argument is a pointer to a structure of "
"the following form:"
msgstr ""
"I<timeout> 引き数は B<ppoll>()  が停止する時間の上限を指定するものである。 こ"
"の引き数には以下の型の構造体へのポインタを指定する。"

#. type: Plain text
#: build/C/man2/poll.2:249
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man2/poll.2:257
msgid ""
"If I<timeout_ts> is specified as NULL, then B<ppoll>()  can block "
"indefinitely."
msgstr ""
"I<timeout_ts> に NULL が指定された場合、 B<ppoll> は無限に停止することがあり"
"得る。"

#. type: Plain text
#: build/C/man2/poll.2:267
msgid ""
"On success, a positive number is returned; this is the number of structures "
"which have nonzero I<revents> fields (in other words, those descriptors with "
"events or errors reported).  A value of 0 indicates that the call timed out "
"and no file descriptors were ready.  On error, -1 is returned, and I<errno> "
"is set appropriately."
msgstr ""
"成功した場合は正の数を返す。この数は 0 以外の I<revents> 要素を持つ構造体の数"
"である (別の言い方をすると、これらのディスクリプタ にはイベントかエラー報告が"
"ある)。 値 0 は、タイムアウトとなり、どのファイルディスクリプタでもイベント"
"が 発生しなかったことを示す。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: Plain text
#: build/C/man2/poll.2:272
msgid ""
"The array given as argument was not contained in the calling program's "
"address space."
msgstr ""
"引き数として指定した配列が、呼び出したプロセスのアドレス空間に 含まれていな"
"い。"

#. type: Plain text
#: build/C/man2/poll.2:276
msgid "A signal occurred before any requested event; see B<signal>(7)."
msgstr ""
"要求されたイベントのどれかが起こる前にシグナルが発生した。 B<signal>(7)  参"
"照。"

#. type: Plain text
#: build/C/man2/poll.2:283
msgid "The I<nfds> value exceeds the B<RLIMIT_NOFILE> value."
msgstr "I<nfds> の値が B<RLIMIT_NOFILE> を超えた。"

#. type: Plain text
#: build/C/man2/poll.2:286
msgid "There was no space to allocate file descriptor tables."
msgstr "ファイルディスクリプタ・テーブルを確保するためのメモリがない。"

#. type: Plain text
#: build/C/man2/poll.2:299
msgid ""
"The B<poll>()  system call was introduced in Linux 2.1.23.  The B<poll>()  "
"library call was introduced in libc 5.4.28 (and provides emulation using "
"B<select>(2)  if your kernel does not have a B<poll>()  system call)."
msgstr ""
"B<poll>()  システムコールは Linux 2.1.23 で導入された。 B<poll>()  ライブラ"
"リ・コールは libc 5.4.28 から導入された (これはカーネルが B<poll>()  システム"
"コールをサポートしていない場合に B<select>(2)  を使用してエミュレートを行"
"う)。"

#. type: Plain text
#: build/C/man2/poll.2:306
msgid ""
"The B<ppoll>()  system call was added to Linux in kernel 2.6.16.  The "
"B<ppoll>()  library call was added in glibc 2.4."
msgstr ""
"B<ppoll>()  システムコールは カーネル 2.6.16 で Linux に追加された。 B<ppoll>"
"()  ライブラリコールは glibc 2.4 に追加された。"

#.  NetBSD 3.0 has a pollts() which is like Linux ppoll().
#. type: Plain text
#: build/C/man2/poll.2:312
msgid "B<poll>()  conforms to POSIX.1-2001.  B<ppoll>()  is Linux-specific."
msgstr ""
"B<poll>()  は POSIX.1-2001 に準拠している。 B<ppoll>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/poll.2:320
msgid ""
"Some implementations define the nonstandard constant B<INFTIM> with the "
"value -1 for use as a I<timeout> for B<poll>().  This constant is not "
"provided in glibc."
msgstr ""
"いくつかの実装では、値 -1 を持った非標準の定数 B<INFTIM> が定義されており、 "
"B<poll>()  の I<timeout> の指定に使用できる。 この定数は glibc では定義されて"
"いない。"

#. type: SS
#: build/C/man2/poll.2:320
#, no-wrap
msgid "Linux Notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/poll.2:334
msgid ""
"The Linux B<ppoll>()  system call modifies its I<timeout_ts> argument.  "
"However, the glibc wrapper function hides this behavior by using a local "
"variable for the timeout argument that is passed to the system call.  Thus, "
"the glibc B<ppoll>()  function does not modify its I<timeout_ts> argument."
msgstr ""
"Linux の B<ppoll>()  システムコールは I<timeout_ts> 引き数を変更する。 しか"
"し、glibc のラッパー関数は、システムコールに渡す timeout 引き数 としてローカ"
"ル変数を使うことでこの動作を隠蔽している。 このため、glibc の B<ppoll>()  関"
"数では I<timeout_ts> 引き数は変更されない。"

#. type: Plain text
#: build/C/man2/poll.2:338
msgid ""
"See the discussion of spurious readiness notifications under the BUGS "
"section of B<select>(2)."
msgstr ""
"B<select>(2)  の「バグ」の節に書かれている、誤った準備完了通知 (spurious "
"readiness notifications) についての議論を参照のこと。"

#. type: Plain text
#: build/C/man2/poll.2:342
msgid "B<select>(2), B<select_tut>(2), B<time>(7)"
msgstr "B<select>(2), B<select_tut>(2), B<time>(7)"

#~ msgid "2009-01-17"
#~ msgstr "2009-01-17"

#~ msgid "2010-08-29"
#~ msgstr "2010-08-29"

#~ msgid ""
#~ "Glibc support for B<epoll_pwait>()  is provided starting with version 2.6."
#~ msgstr ""
#~ "B<epoll_pwait>()  の glibc でのサポートは glibc 2.6 以降で提供されている。"

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-03-22 01:07+0900\n"
"PO-Revision-Date: 2013-03-24 01:05+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bcmp.3:31
#, no-wrap
msgid "BCMP"
msgstr "BCMP"

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bzero.3:31
#, no-wrap
msgid "2008-08-06"
msgstr "2008-08-06"

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/bzero.3:31
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/bcmp.3:31 build/C/man3/bcopy.3:33 build/C/man3/bstring.3:32
#: build/C/man3/bzero.3:31 build/C/man3/ffs.3:33 build/C/man3/index.3:31
#: build/C/man3/memccpy.3:30 build/C/man3/memchr.3:32 build/C/man3/memcmp.3:30
#: build/C/man3/memcpy.3:30 build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30
#: build/C/man3/memmove.3:30 build/C/man3/mempcpy.3:10
#: build/C/man3/memset.3:30 build/C/man3/stpcpy.3:25 build/C/man3/stpncpy.3:14
#: build/C/man3/strcasecmp.3:30 build/C/man3/strcat.3:32
#: build/C/man3/strchr.3:33 build/C/man3/strcmp.3:32 build/C/man3/strcoll.3:30
#: build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31
#: build/C/man3/strerror.3:39 build/C/man3/strfry.3:30
#: build/C/man3/string.3:30 build/C/man3/strlen.3:30 build/C/man3/strnlen.3:13
#: build/C/man3/strpbrk.3:30 build/C/man3/strsep.3:33
#: build/C/man3/strsignal.3:30 build/C/man3/strspn.3:30
#: build/C/man3/strstr.3:33 build/C/man3/strtok.3:30
#: build/C/man3/strverscmp.3:25 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/bcmp.3:32 build/C/man3/bcopy.3:34 build/C/man3/bstring.3:33
#: build/C/man3/bzero.3:32 build/C/man3/ffs.3:34 build/C/man3/index.3:32
#: build/C/man3/memccpy.3:31 build/C/man3/memchr.3:33 build/C/man3/memcmp.3:31
#: build/C/man3/memcpy.3:31 build/C/man3/memfrob.3:31 build/C/man3/memmem.3:31
#: build/C/man3/memmove.3:31 build/C/man3/mempcpy.3:11
#: build/C/man3/memset.3:31 build/C/man3/stpcpy.3:26 build/C/man3/stpncpy.3:15
#: build/C/man3/strcasecmp.3:31 build/C/man3/strcat.3:33
#: build/C/man3/strchr.3:34 build/C/man3/strcmp.3:33 build/C/man3/strcoll.3:31
#: build/C/man3/strcpy.3:36 build/C/man3/strdup.3:32
#: build/C/man3/strerror.3:40 build/C/man3/strfry.3:31
#: build/C/man3/string.3:31 build/C/man3/strlen.3:31 build/C/man3/strnlen.3:14
#: build/C/man3/strpbrk.3:31 build/C/man3/strsep.3:34
#: build/C/man3/strsignal.3:31 build/C/man3/strspn.3:31
#: build/C/man3/strstr.3:34 build/C/man3/strtok.3:31
#: build/C/man3/strverscmp.3:26 build/C/man3/strxfrm.3:31
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/bcmp.3:34
msgid "bcmp - compare byte sequences"
msgstr "bcmp - バイト列を比較する"

#. type: SH
#: build/C/man3/bcmp.3:34 build/C/man3/bcopy.3:36 build/C/man3/bstring.3:36
#: build/C/man3/bzero.3:34 build/C/man3/ffs.3:36 build/C/man3/index.3:34
#: build/C/man3/memccpy.3:33 build/C/man3/memchr.3:35 build/C/man3/memcmp.3:33
#: build/C/man3/memcpy.3:33 build/C/man3/memfrob.3:33 build/C/man3/memmem.3:33
#: build/C/man3/memmove.3:33 build/C/man3/mempcpy.3:13
#: build/C/man3/memset.3:33 build/C/man3/stpcpy.3:28 build/C/man3/stpncpy.3:17
#: build/C/man3/strcasecmp.3:33 build/C/man3/strcat.3:35
#: build/C/man3/strchr.3:36 build/C/man3/strcmp.3:35 build/C/man3/strcoll.3:33
#: build/C/man3/strcpy.3:38 build/C/man3/strdup.3:34
#: build/C/man3/strerror.3:42 build/C/man3/strfry.3:33
#: build/C/man3/string.3:36 build/C/man3/strlen.3:33 build/C/man3/strnlen.3:16
#: build/C/man3/strpbrk.3:33 build/C/man3/strsep.3:36
#: build/C/man3/strsignal.3:33 build/C/man3/strspn.3:33
#: build/C/man3/strstr.3:36 build/C/man3/strtok.3:33
#: build/C/man3/strverscmp.3:28 build/C/man3/strxfrm.3:33
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bcmp.3:37 build/C/man3/bcopy.3:39 build/C/man3/bzero.3:37
#: build/C/man3/ffs.3:39 build/C/man3/index.3:37 build/C/man3/strcasecmp.3:36
#: build/C/man3/string.3:39
#, no-wrap
msgid "B<#include E<lt>strings.hE<gt>>\n"
msgstr "B<#include E<lt>strings.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bcmp.3:39
#, no-wrap
msgid "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: SH
#: build/C/man3/bcmp.3:40 build/C/man3/bcopy.3:42 build/C/man3/bstring.3:63
#: build/C/man3/bzero.3:40 build/C/man3/ffs.3:74 build/C/man3/index.3:42
#: build/C/man3/memccpy.3:39 build/C/man3/memchr.3:54 build/C/man3/memcmp.3:39
#: build/C/man3/memcpy.3:39 build/C/man3/memfrob.3:40 build/C/man3/memmem.3:41
#: build/C/man3/memmove.3:39 build/C/man3/mempcpy.3:27
#: build/C/man3/memset.3:39 build/C/man3/stpcpy.3:53 build/C/man3/stpncpy.3:42
#: build/C/man3/strcasecmp.3:41 build/C/man3/strcat.3:43
#: build/C/man3/strchr.3:49 build/C/man3/strcmp.3:43 build/C/man3/strcoll.3:39
#: build/C/man3/strcpy.3:46 build/C/man3/strdup.3:77
#: build/C/man3/strerror.3:67 build/C/man3/strfry.3:41
#: build/C/man3/string.3:90 build/C/man3/strlen.3:39 build/C/man3/strnlen.3:41
#: build/C/man3/strpbrk.3:39 build/C/man3/strsep.3:50
#: build/C/man3/strsignal.3:60 build/C/man3/strspn.3:41
#: build/C/man3/strstr.3:48 build/C/man3/strtok.3:52
#: build/C/man3/strverscmp.3:36 build/C/man3/strxfrm.3:39
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/bcmp.3:56
msgid ""
"The B<bcmp>()  function compares the two byte sequences I<s1> and I<s2> of "
"length I<n> each.  If they are equal, and in particular if I<n> is zero, "
"B<bcmp>()  returns 0.  Otherwise it returns a nonzero result."
msgstr ""
"B<bcmp>()  は、2 つのバイト列 I<s1> と I<s2> の先頭 I<n> バイトを 比較する。"
"2 つが等しいか、特に I<n> が 0 の場合 B<bcmp>()  は 0 を返す。 さもなければ "
"0 以外を返す。"

#. type: SH
#: build/C/man3/bcmp.3:56 build/C/man3/bcopy.3:52 build/C/man3/bzero.3:48
#: build/C/man3/ffs.3:87 build/C/man3/index.3:55 build/C/man3/memccpy.3:47
#: build/C/man3/memchr.3:105 build/C/man3/memcmp.3:45 build/C/man3/memcpy.3:48
#: build/C/man3/memfrob.3:53 build/C/man3/memmem.3:47
#: build/C/man3/memmove.3:53 build/C/man3/mempcpy.3:53
#: build/C/man3/memset.3:44 build/C/man3/stpcpy.3:61 build/C/man3/stpncpy.3:61
#: build/C/man3/strcasecmp.3:54 build/C/man3/strcat.3:97
#: build/C/man3/strchr.3:81 build/C/man3/strcmp.3:56 build/C/man3/strcoll.3:51
#: build/C/man3/strcpy.3:97 build/C/man3/strdup.3:104
#: build/C/man3/strerror.3:136 build/C/man3/strfry.3:49
#: build/C/man3/strlen.3:44 build/C/man3/strnlen.3:51
#: build/C/man3/strpbrk.3:44 build/C/man3/strsep.3:63
#: build/C/man3/strsignal.3:75 build/C/man3/strspn.3:53
#: build/C/man3/strstr.3:60 build/C/man3/strtok.3:106
#: build/C/man3/strverscmp.3:81 build/C/man3/strxfrm.3:56
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bcmp.3:61
msgid ""
"The B<bcmp>()  function returns 0 if the byte sequences are equal, otherwise "
"a nonzero result is returned."
msgstr "バイト列が等しい場合は 0 、等しくない場合は 0 以外を返す。"

#. type: SH
#: build/C/man3/bcmp.3:61 build/C/man3/bcopy.3:54 build/C/man3/bzero.3:50
#: build/C/man3/ffs.3:91 build/C/man3/index.3:62 build/C/man3/memccpy.3:53
#: build/C/man3/memchr.3:124 build/C/man3/memcmp.3:60 build/C/man3/memcpy.3:52
#: build/C/man3/memfrob.3:58 build/C/man3/memmem.3:52
#: build/C/man3/memmove.3:57 build/C/man3/mempcpy.3:58
#: build/C/man3/memset.3:49 build/C/man3/stpcpy.3:66 build/C/man3/stpncpy.3:66
#: build/C/man3/strcasecmp.3:63 build/C/man3/strcat.3:103
#: build/C/man3/strchr.3:104 build/C/man3/strcmp.3:65
#: build/C/man3/strcoll.3:58 build/C/man3/strcpy.3:104
#: build/C/man3/strdup.3:113 build/C/man3/strerror.3:175
#: build/C/man3/strfry.3:54 build/C/man3/strlen.3:48 build/C/man3/strnlen.3:58
#: build/C/man3/strpbrk.3:50 build/C/man3/strsep.3:68
#: build/C/man3/strsignal.3:82 build/C/man3/strspn.3:65
#: build/C/man3/strstr.3:63 build/C/man3/strtok.3:113
#: build/C/man3/strverscmp.3:88 build/C/man3/strxfrm.3:64
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bcmp.3:68
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memcmp>(3)  in new programs.  POSIX.1-2008 removes the specification of "
"B<bcmp>()."
msgstr ""
"4.3BSD.  この関数は廃止予定である (POSIX.1-2001 では 過去の名残 (LEGACY) とさ"
"れている)。新しいプログラムでは B<memcmp>(3)  を使うべきである。 "
"POSIX.1-2008 では B<bcmp>()  の仕様が削除されている。"

#. type: SH
#: build/C/man3/bcmp.3:68 build/C/man3/bcopy.3:68 build/C/man3/bstring.3:82
#: build/C/man3/bzero.3:57 build/C/man3/ffs.3:103 build/C/man3/index.3:73
#: build/C/man3/memccpy.3:55 build/C/man3/memchr.3:136
#: build/C/man3/memcmp.3:62 build/C/man3/memcpy.3:54 build/C/man3/memfrob.3:63
#: build/C/man3/memmem.3:65 build/C/man3/memmove.3:59
#: build/C/man3/mempcpy.3:71 build/C/man3/memset.3:51 build/C/man3/stpcpy.3:99
#: build/C/man3/stpncpy.3:68 build/C/man3/strcasecmp.3:65
#: build/C/man3/strcat.3:142 build/C/man3/strchr.3:111
#: build/C/man3/strcmp.3:67 build/C/man3/strcoll.3:65
#: build/C/man3/strcpy.3:194 build/C/man3/strdup.3:123
#: build/C/man3/strerror.3:204 build/C/man3/strfry.3:59
#: build/C/man3/string.3:94 build/C/man3/strlen.3:50 build/C/man3/strnlen.3:60
#: build/C/man3/strpbrk.3:52 build/C/man3/strsep.3:88
#: build/C/man3/strsignal.3:85 build/C/man3/strspn.3:67
#: build/C/man3/strstr.3:76 build/C/man3/strtok.3:203
#: build/C/man3/strverscmp.3:90 build/C/man3/strxfrm.3:72
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/bcmp.3:75
msgid ""
"B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), B<strncasecmp>"
"(3), B<strncmp>(3)"
msgstr ""
"B<memcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), B<strncasecmp>"
"(3), B<strncmp>(3)"

#. type: SH
#: build/C/man3/bcmp.3:75 build/C/man3/bcopy.3:74 build/C/man3/bstring.3:94
#: build/C/man3/bzero.3:60 build/C/man3/ffs.3:105 build/C/man3/index.3:83
#: build/C/man3/memccpy.3:61 build/C/man3/memchr.3:147
#: build/C/man3/memcmp.3:70 build/C/man3/memcpy.3:62 build/C/man3/memfrob.3:65
#: build/C/man3/memmem.3:67 build/C/man3/memmove.3:66
#: build/C/man3/mempcpy.3:76 build/C/man3/memset.3:55
#: build/C/man3/stpcpy.3:108 build/C/man3/stpncpy.3:71
#: build/C/man3/strcasecmp.3:74 build/C/man3/strcat.3:151
#: build/C/man3/strchr.3:124 build/C/man3/strcmp.3:77
#: build/C/man3/strcoll.3:73 build/C/man3/strcpy.3:205
#: build/C/man3/strdup.3:131 build/C/man3/strerror.3:210
#: build/C/man3/strfry.3:62 build/C/man3/string.3:119 build/C/man3/strlen.3:55
#: build/C/man3/strnlen.3:62 build/C/man3/strpbrk.3:63
#: build/C/man3/strsep.3:98 build/C/man3/strsignal.3:88
#: build/C/man3/strspn.3:79 build/C/man3/strstr.3:88 build/C/man3/strtok.3:214
#: build/C/man3/strverscmp.3:95 build/C/man3/strxfrm.3:80
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/bcmp.3:82 build/C/man3/bcopy.3:81 build/C/man3/bstring.3:101
#: build/C/man3/bzero.3:67 build/C/man3/ffs.3:112 build/C/man3/index.3:90
#: build/C/man3/memccpy.3:68 build/C/man3/memchr.3:154
#: build/C/man3/memcmp.3:77 build/C/man3/memcpy.3:69 build/C/man3/memfrob.3:72
#: build/C/man3/memmem.3:74 build/C/man3/memmove.3:73
#: build/C/man3/mempcpy.3:83 build/C/man3/memset.3:62
#: build/C/man3/stpcpy.3:115 build/C/man3/stpncpy.3:78
#: build/C/man3/strcasecmp.3:81 build/C/man3/strcat.3:158
#: build/C/man3/strchr.3:131 build/C/man3/strcmp.3:84
#: build/C/man3/strcoll.3:80 build/C/man3/strcpy.3:212
#: build/C/man3/strdup.3:138 build/C/man3/strerror.3:217
#: build/C/man3/strfry.3:69 build/C/man3/string.3:126 build/C/man3/strlen.3:62
#: build/C/man3/strnlen.3:69 build/C/man3/strpbrk.3:70
#: build/C/man3/strsep.3:105 build/C/man3/strsignal.3:95
#: build/C/man3/strspn.3:86 build/C/man3/strstr.3:95 build/C/man3/strtok.3:221
#: build/C/man3/strverscmp.3:102 build/C/man3/strxfrm.3:87
msgid ""
"This page is part of release 3.50 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.50 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/bcopy.3:33
#, no-wrap
msgid "BCOPY"
msgstr "BCOPY"

#. type: TH
#: build/C/man3/bcopy.3:33
#, no-wrap
msgid "2009-03-15"
msgstr "2009-03-15"

#. type: Plain text
#: build/C/man3/bcopy.3:36
msgid "bcopy - copy byte sequence"
msgstr "bcopy - バイト列をコピーする"

#. type: Plain text
#: build/C/man3/bcopy.3:41
#, no-wrap
msgid "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, size_t >I<n>B<);>\n"
msgstr "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bcopy.3:52
msgid ""
"The B<bcopy>()  function copies I<n> bytes from I<src> to I<dest>.  The "
"result is correct, even when both areas overlap."
msgstr ""
"B<bcopy>()  は I<src> から先頭 I<n> バイトを I<dest> にコピーする。 領域が重"
"なっていても、結果は正しいものである。"

#. type: Plain text
#: build/C/man3/bcopy.3:54 build/C/man3/bzero.3:50
msgid "None."
msgstr "なし。"

#. type: Plain text
#: build/C/man3/bcopy.3:68
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memcpy>(3)  or B<memmove>(3)  in new programs.  Note that the first two "
"arguments are interchanged for B<memcpy>(3)  and B<memmove>(3).  "
"POSIX.1-2008 removes the specification of B<bcopy>()."
msgstr ""
"4.3BSD.  この関数は廃止予定である (POSIX.1-2001 では 過去の名残 (LEGACY) とさ"
"れている)。新しいプログラムでは B<memcpy>()  や B<memmove>()  を使用すべきで"
"ある。 B<memcpy>()  や B<memmove>()  では、最初の 2 つの引数の順序が入れ替"
"わっていることに注意すること。 POSIX.1-2008 では、 B<bcopy>()  の仕様が削除さ"
"れている。"

#. type: Plain text
#: build/C/man3/bcopy.3:74
msgid "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"
msgstr ""
"B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"

#. type: TH
#: build/C/man3/bstring.3:32
#, no-wrap
msgid "BSTRING"
msgstr "BSTRING"

#. type: TH
#: build/C/man3/bstring.3:32
#, no-wrap
msgid "2002-01-20"
msgstr "2002-01-20"

#. type: Plain text
#: build/C/man3/bstring.3:36
msgid ""
"bcmp, bcopy, bzero, memccpy, memchr, memcmp, memcpy, memfrob, memmem, "
"memmove, memset - byte string operations"
msgstr ""
"bcmp, bcopy, bzero, memccpy, memchr, memcmp, memcpy, memfrob, memmem, "
"memmove, memset - バイト列の操作を行なう"

#. type: Plain text
#: build/C/man3/bstring.3:39 build/C/man3/ffs.3:43 build/C/man3/memccpy.3:36
#: build/C/man3/memchr.3:38 build/C/man3/memcmp.3:36 build/C/man3/memcpy.3:36
#: build/C/man3/memmove.3:36 build/C/man3/mempcpy.3:18
#: build/C/man3/memset.3:36 build/C/man3/stpcpy.3:31 build/C/man3/stpncpy.3:20
#: build/C/man3/strcat.3:38 build/C/man3/strchr.3:39 build/C/man3/strcmp.3:38
#: build/C/man3/strcoll.3:36 build/C/man3/strcpy.3:41 build/C/man3/strdup.3:37
#: build/C/man3/strerror.3:45 build/C/man3/strfry.3:38
#: build/C/man3/string.3:49 build/C/man3/strlen.3:36 build/C/man3/strnlen.3:19
#: build/C/man3/strpbrk.3:36 build/C/man3/strsep.3:39
#: build/C/man3/strsignal.3:36 build/C/man3/strspn.3:36
#: build/C/man3/strstr.3:39 build/C/man3/strstr.3:45 build/C/man3/strtok.3:36
#: build/C/man3/strverscmp.3:33 build/C/man3/strxfrm.3:36
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/bstring.3:41
#, no-wrap
msgid "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, int >I<n>B<);>\n"
msgstr "B<int bcmp(const void *>I<s1>B<, const void *>I<s2>B<, int >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:43
#, no-wrap
msgid "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, int >I<n>B<);>\n"
msgstr "B<void bcopy(const void *>I<src>B<, void *>I<dest>B<, int >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:45
#, no-wrap
msgid "B<void bzero(void *>I<s>B<, int >I<n>B<);>\n"
msgstr "B<void bzero(void *>I<s>B<, int >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:47 build/C/man3/memccpy.3:38
#, no-wrap
msgid "B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memccpy(void *>I<dest>B<, const void *>I<src>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:49 build/C/man3/memchr.3:40
#, no-wrap
msgid "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:51 build/C/man3/memcmp.3:38
#, no-wrap
msgid "B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int memcmp(const void *>I<s1>B<, const void *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:53 build/C/man3/memcpy.3:38
#, no-wrap
msgid "B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:55 build/C/man3/memfrob.3:39
#, no-wrap
msgid "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memfrob(void *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:58
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<needle>B<, size_t >I<needlelen>B<,>\n"
"B<             const void *>I<haystack>B<, size_t >I<haystacklen>B<);>\n"
msgstr ""
"B<void *memmem(const void *>I<needle>B<, size_t >I<needlelen>B<,>\n"
"B<             const void *>I<haystack>B<, size_t >I<haystacklen>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:60 build/C/man3/memmove.3:38
#, no-wrap
msgid "B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memmove(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:62 build/C/man3/memset.3:38
#, no-wrap
msgid "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memset(void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bstring.3:68
msgid ""
"The byte string functions perform operations on strings (byte arrays)  that "
"are not necessarily null-terminated.  See the individual man pages for "
"descriptions of each function."
msgstr ""
"これらの関数は NULL 終端する必要のない文字列 (バイト配列) の操作を行う。 関数"
"の詳しい説明は、それぞれの man ページを参照すること。"

#. type: SH
#: build/C/man3/bstring.3:68 build/C/man3/ffs.3:100 build/C/man3/strcat.3:105
#: build/C/man3/strcoll.3:60 build/C/man3/strcpy.3:106
#: build/C/man3/strsep.3:70 build/C/man3/strxfrm.3:66
#, no-wrap
msgid "NOTES"
msgstr "注意"

#.  The old functions are not even available on some non-GNU/Linux systems.
#. type: Plain text
#: build/C/man3/bstring.3:82
msgid ""
"The functions B<bcmp>(), B<bcopy>()  and B<bzero>()  are obsolete.  Use "
"B<memcmp>(), B<memcpy>()  and B<memset>()  instead."
msgstr ""
"B<bcmp>(), B<bcopy>(), B<bzero>()  関数は古いものである。代わりに B<memcmp>"
"(), B<memcpy>()  B<memset>()  を使うこと。"

#. type: Plain text
#: build/C/man3/bstring.3:94
msgid ""
"B<bcmp>(3), B<bcopy>(3), B<bzero>(3), B<memccpy>(3), B<memchr>(3), B<memcmp>"
"(3), B<memcpy>(3), B<memfrob>(3), B<memmem>(3), B<memmove>(3), B<memset>(3)"
msgstr ""
"B<bcmp>(3), B<bcopy>(3), B<bzero>(3), B<memccpy>(3), B<memchr>(3), B<memcmp>"
"(3), B<memcpy>(3), B<memfrob>(3), B<memmem>(3), B<memmove>(3), B<memset>(3)"

#. type: TH
#: build/C/man3/bzero.3:31
#, no-wrap
msgid "BZERO"
msgstr "BZERO"

#. type: Plain text
#: build/C/man3/bzero.3:34
msgid "bzero - write zero-valued bytes"
msgstr "bzero - 値 0 のバイトで埋める"

#. type: Plain text
#: build/C/man3/bzero.3:39
#, no-wrap
msgid "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<void bzero(void *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/bzero.3:48
msgid ""
"The B<bzero>()  function sets the first I<n> bytes of the area starting at "
"I<s> to zero (bytes containing \\(aq\\e0\\(aq)."
msgstr ""
"B<bzero>()  関数は バイト列 I<s> から始まる領域の先頭 I<n> バイトを 数値ゼロ "
"(値が \\(aq\\e0\\(aq のバイト) で埋める。"

#. type: Plain text
#: build/C/man3/bzero.3:57
msgid ""
"4.3BSD.  This function is deprecated (marked as LEGACY in POSIX.1-2001): use "
"B<memset>(3)  in new programs.  POSIX.1-2008 removes the specification of "
"B<bzero>()."
msgstr ""
"4.3BSD.  この関数は廃止予定である (POSIX.1-2001 では 過去の名残 (LEGACY) とさ"
"れている)。新しいプログラムでは B<memset>(3)  を使用すべきである。 "
"POSIX.1-2008 では B<bzero>()  の仕様が削除されている。"

#. type: Plain text
#: build/C/man3/bzero.3:60
msgid "B<memset>(3), B<swab>(3)"
msgstr "B<memset>(3), B<swab>(3)"

#. type: TH
#: build/C/man3/ffs.3:33
#, no-wrap
msgid "FFS"
msgstr "FFS"

#. type: TH
#: build/C/man3/ffs.3:33 build/C/man3/strcoll.3:30 build/C/man3/strfry.3:30
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: TH
#: build/C/man3/ffs.3:33 build/C/man3/index.3:31 build/C/man3/memccpy.3:30
#: build/C/man3/memfrob.3:30 build/C/man3/memmem.3:30
#: build/C/man3/memmove.3:30 build/C/man3/mempcpy.3:10
#: build/C/man3/memset.3:30 build/C/man3/stpcpy.3:25 build/C/man3/stpncpy.3:14
#: build/C/man3/strcat.3:32 build/C/man3/strchr.3:33 build/C/man3/strcoll.3:30
#: build/C/man3/strcpy.3:35 build/C/man3/strdup.3:31 build/C/man3/strfry.3:30
#: build/C/man3/strlen.3:30 build/C/man3/strnlen.3:13 build/C/man3/strsep.3:33
#: build/C/man3/strsignal.3:30 build/C/man3/strstr.3:33
#: build/C/man3/strtok.3:30 build/C/man3/strverscmp.3:25
#: build/C/man3/strxfrm.3:30
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/ffs.3:36
msgid "ffs, ffsl, ffsll - find first bit set in a word"
msgstr "ffs, ffsl, ffsll - ワードの中で最初にセットされているビットの検出"

#. type: Plain text
#: build/C/man3/ffs.3:41
#, no-wrap
msgid "B<int ffs(int >I<i>B<);>\n"
msgstr "B<int ffs(int >I<i>B<);>\n"

#. type: Plain text
#: build/C/man3/ffs.3:45
#, no-wrap
msgid "B<int ffsl(long int >I<i>B<);>\n"
msgstr "B<int ffsl(long int >I<i>B<);>\n"

#. type: Plain text
#: build/C/man3/ffs.3:47
#, no-wrap
msgid "B<int ffsll(long long int >I<i>B<);>\n"
msgstr "B<int ffsll(long long int >I<i>B<);>\n"

#. type: Plain text
#: build/C/man3/ffs.3:52 build/C/man3/memchr.3:49 build/C/man3/stpcpy.3:38
#: build/C/man3/stpncpy.3:27 build/C/man3/strdup.3:50
#: build/C/man3/strerror.3:58 build/C/man3/strnlen.3:26
#: build/C/man3/strsep.3:46 build/C/man3/strsignal.3:45
#: build/C/man3/strtok.3:45
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/ffs.3:57
msgid "B<ffs>():"
msgstr "B<ffs>():"

#. type: TP
#: build/C/man3/ffs.3:58
#, no-wrap
msgid "Since glibc 2.12:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/ffs.3:62
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 700 ||"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L || "
"_XOPEN_SOURCE\\ E<gt>=\\ 700 ||"

#. type: TP
#: build/C/man3/ffs.3:62
#, no-wrap
msgid "Before glibc 2.12:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/ffs.3:65
msgid "none"
msgstr "none"

#. type: Plain text
#: build/C/man3/ffs.3:69
msgid "B<ffsl>(), B<ffsll>():"
msgstr "B<ffsl>(), B<ffsll>():"

#. type: Plain text
#: build/C/man3/ffs.3:71 build/C/man3/stpcpy.3:50 build/C/man3/stpncpy.3:39
#: build/C/man3/strdup.3:70 build/C/man3/strnlen.3:38
#: build/C/man3/strsignal.3:57
msgid "_GNU_SOURCE"
msgstr "_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/ffs.3:87
msgid ""
"The B<ffs>()  function returns the position of the first (least significant) "
"bit set in the word I<i>.  The least significant bit is position 1 and the "
"most significant position is, for example, 32 or 64.  The functions B<ffsll>"
"()  and B<ffsl>()  do the same but take arguments of possibly different size."
msgstr ""
"B<ffs>()  関数は、ワード I<i> の中で最初にセットされている (最下位)ビットの位"
"置を返す。 最下位ビットの位置は 1、最上位ビットの位置は例えば 32 や 64 であ"
"る。 B<ffsll>()  関数と B<ffsl>()  関数も同様だが、 異なったサイズの引数をと"
"る。"

#. type: Plain text
#: build/C/man3/ffs.3:91
msgid ""
"These functions return the position of the first bit set, or 0 if no bits "
"are set in I<i>."
msgstr ""
"これらの関数は、最初にセットされているビットの位置を返し、 I<i> のどのビット"
"もセットされていなければ 0 を返す。"

#. type: Plain text
#: build/C/man3/ffs.3:94
msgid "B<ffs>(): 4.3BSD, POSIX.1-2001."
msgstr "B<ffs>(): 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/ffs.3:100
msgid "The B<ffsl>()  and B<ffsll>()  functions are glibc extensions."
msgstr "関数 B<ffsl>()  と B<ffsll>()  は glibc による拡張である。"

#. type: Plain text
#: build/C/man3/ffs.3:103
msgid "BSD systems have a prototype in I<E<lt>string.hE<gt>>."
msgstr "BSD システムでは I<E<lt>string.hE<gt>> にプロトタイプがある。"

#. type: Plain text
#: build/C/man3/ffs.3:105
msgid "B<memchr>(3)"
msgstr "B<memchr>(3)"

#. type: TH
#: build/C/man3/index.3:31
#, no-wrap
msgid "INDEX"
msgstr "INDEX"

#. type: TH
#: build/C/man3/index.3:31
#, no-wrap
msgid "2011-09-21"
msgstr "2011-09-21"

#. type: Plain text
#: build/C/man3/index.3:34
msgid "index, rindex - locate character in string"
msgstr "index, rindex - 文字列中の文字の位置を示す"

#. type: Plain text
#: build/C/man3/index.3:39 build/C/man3/string.3:45
#, no-wrap
msgid "B<char *index(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *index(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/index.3:41 build/C/man3/string.3:47
#, no-wrap
msgid "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *rindex(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/index.3:47
msgid ""
"The B<index>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<index>()  関数は、文字列 I<s> 中に最初に文字 I<c> が 現れた位置へのポインタ"
"を返す。"

#. type: Plain text
#: build/C/man3/index.3:52
msgid ""
"The B<rindex>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<rindex>()  関数は、文字列 I<s> 中に最後に文字 I<c> が 現れた位置へのポイン"
"タを返す。"

#. type: Plain text
#: build/C/man3/index.3:55
msgid ""
"The terminating null byte (\\(aq\\e0\\(aq) is considered to be a part of the "
"strings."
msgstr ""
"文字列を終端する NULL バイト (\\(aq\\e0\\(aq) は、文字列の一部とみなされる。"

#. type: Plain text
#: build/C/man3/index.3:62
msgid ""
"The B<index>()  and B<rindex>()  functions return a pointer to the matched "
"character or NULL if the character is not found."
msgstr ""
"B<index>()  と B<rindex>()  関数は、一致した文字へのポインタか、 もし文字が見"
"つからない場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/index.3:73
msgid ""
"4.3BSD; marked as LEGACY in POSIX.1-2001.  POSIX.1-2008 removes the "
"specifications of B<index>()  and B<rindex>(), recommending B<strchr>(3)  "
"and B<strrchr>(3)  instead."
msgstr ""
"4.3BSD; POSIX.1-2001 では「過去の名残 (LEGACY)」と位置付けられている。 "
"POSIX.1-2008 では B<index>()  と B<rindex>()  の仕様が削除されている。 代わり"
"に、 B<strchr>(3)  と B<strrchr>(3)  の使用が推奨されている。"

#. type: Plain text
#: build/C/man3/index.3:83
msgid ""
"B<memchr>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strrchr>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""
"B<memchr>(3), B<strchr>(3), B<string>(3), B<strpbrk>(3), B<strrchr>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"

#. type: TH
#: build/C/man3/memccpy.3:30
#, no-wrap
msgid "MEMCCPY"
msgstr "MEMCCPY"

#. type: TH
#: build/C/man3/memccpy.3:30
#, no-wrap
msgid "2009-01-13"
msgstr "1993-04-10"

#. type: Plain text
#: build/C/man3/memccpy.3:33
msgid "memccpy - copy memory area"
msgstr "memccpy - メモリ領域をコピーする"

#. type: Plain text
#: build/C/man3/memccpy.3:45
msgid ""
"The B<memccpy>()  function copies no more than I<n> bytes from memory area "
"I<src> to memory area I<dest>, stopping when the character I<c> is found."
msgstr ""
"B<memccpy>()  は、メモリ領域 I<src> からメモリ領域 I<dest> に 最大で I<n> バ"
"イトのコピーを行う。 I<n> バイトコピーする前に文字 I<c> が見つかると、 そこで"
"コピーを中止する。"

#. type: Plain text
#: build/C/man3/memccpy.3:47
msgid "If the memory areas overlap, the results are undefined."
msgstr "コピー元とコピー先のメモリ領域が重なっている場合、 結果は不定である。"

#. type: Plain text
#: build/C/man3/memccpy.3:53
msgid ""
"The B<memccpy>()  function returns a pointer to the next character in "
"I<dest> after I<c>, or NULL if I<c> was not found in the first I<n> "
"characters of I<src>."
msgstr ""
"B<memccpy>()  は、I<dest> 中に見つかった I<c> の 次にあるキャラクター型の変数"
"を指すポインタを返す。 見つからなかった場合、NULL を返す。"

#. type: Plain text
#: build/C/man3/memccpy.3:55
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/memccpy.3:61
msgid "B<bcopy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"
msgstr "B<bcopy>(3), B<memcpy>(3), B<memmove>(3), B<strcpy>(3), B<strncpy>(3)"

#. type: TH
#: build/C/man3/memchr.3:32
#, no-wrap
msgid "MEMCHR"
msgstr "MEMCHR"

#. type: TH
#: build/C/man3/memchr.3:32
#, no-wrap
msgid "2012-04-23"
msgstr "2012-04-23"

#. type: Plain text
#: build/C/man3/memchr.3:35
msgid "memchr, memrchr, rawmemchr - scan memory for a character"
msgstr "memchr, memrchr, rawmemchr - 文字を探すためにメモリをスキャンする"

#. type: Plain text
#: build/C/man3/memchr.3:42
#, no-wrap
msgid "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"
msgstr "B<void *memrchr(const void *>I<s>B<, int >I<c>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/memchr.3:44
#, no-wrap
msgid "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<void *rawmemchr(const void *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/memchr.3:54
msgid "B<memrchr>(), B<rawmemchr>(): _GNU_SOURCE"
msgstr "B<memrchr>(): B<rawmemchr>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/memchr.3:70
msgid ""
"The B<memchr>()  function scans the initial I<n> bytes of the memory area "
"pointed to by I<s> for the first instance of I<c>.  Both I<c> and the bytes "
"of the memory area pointed to by I<s> are interpreted as I<unsigned char>."
msgstr ""
"B<memchr>() 関数は、ポインタ I<s> が指し示すメモリ領域の先頭の\n"
"I<n> バイトから最初に登場する文字 I<c> を探す。\n"
"I<c> と I<s> が指し示すメモリ領域の各バイトは両方とも\n"
"I<unsigned char> と解釈される。"

#. type: Plain text
#: build/C/man3/memchr.3:81
msgid ""
"The B<memrchr>()  function is like the B<memchr>()  function, except that it "
"searches backward from the end of the I<n> bytes pointed to by I<s> instead "
"of forward from the beginning."
msgstr ""
"B<memrchr>()  関数は B<memchr>()  関数に似ているが、 先頭から順方向に探すので"
"はなく、 ポインタ I<s> が指し示す I<n> バイトのメモリブロックの 末尾から逆向"
"きに探す。"

#. type: Plain text
#: build/C/man3/memchr.3:99
msgid ""
"The B<rawmemchr>()  function is similar to B<memchr>(): it assumes (i.e., "
"the programmer knows for certain)  that an instance of I<c> lies somewhere "
"in the memory area starting at the location pointed to by I<s>, and so "
"performs an optimized search for I<c> (i.e., no use of a count argument to "
"limit the range of the search).  If an instance of I<c> is not found, the "
"results are unpredictable.  The following call is a fast means of locating a "
"string's terminating null byte:"
msgstr ""
"B<rawmemchr>() 関数は B<memchr>() と同様だが、 I<c> が I<s> が指す場所\n"
"から始まるメモリ領域のどこかにあることを前提にして (つまり、プログラマ\n"
"はそのことを知っている)、最適化した方法で I<c> の検索を実行する (すなわ\n"
"ち、検索範囲の上限を示す引き数も使用されない)。I<c> が見つからなかった\n"
"場合、その結果はどうなるか分からない。次に示す呼び出しは、文字列終端の\n"
"NULL バイトの位置を特定する高速な手段である。"

#. type: Plain text
#: build/C/man3/memchr.3:103
#, no-wrap
msgid "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"
msgstr "char *p = rawmemchr(s,\\ \\(aq\\e0\\(aq);\n"

#. type: Plain text
#: build/C/man3/memchr.3:113
msgid ""
"The B<memchr>()  and B<memrchr>()  functions return a pointer to the "
"matching byte or NULL if the character does not occur in the given memory "
"area."
msgstr ""
"B<memchr>()  関数と B<memrchr>()  関数は一致する文字へのポインタを返し、 もし"
"文字が指定メモリ領域に現れない場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/memchr.3:118
msgid ""
"The B<rawmemchr>()  function returns a pointer to the matching byte, if one "
"is found.  If no matching byte is found, the result is unspecified."
msgstr ""
"B<rawmemchr>()  関数はマッチするバイトが見つかった場合はマッチしたバイトへの"
"ポインタを返す。 マッチするバイトが見つからなかった場合、結果は不定である。"

#. type: SH
#: build/C/man3/memchr.3:118 build/C/man3/mempcpy.3:55
#: build/C/man3/strchr.3:101
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/memchr.3:121
msgid "B<rawmemchr>()  first appeared in glibc in version 2.1."
msgstr "B<rawmemchr>()  は glibc バージョン 2.1 で初めて登場した。"

#. type: Plain text
#: build/C/man3/memchr.3:124
msgid "B<memrchr>()  first appeared in glibc in version 2.2."
msgstr "B<memrchr>()  は glibc バージョン 2.2 で初めて登場した。"

#. type: Plain text
#: build/C/man3/memchr.3:128
msgid ""
"The B<memchr>()  function conforms to SVr4, 4.3BSD, C89, C99, POSIX.1-2001."
msgstr "B<memchr>()  関数は SVr4, 4.3BSD, C89, C99, POSIX.1-2001 に準拠する。"

#. type: Plain text
#: build/C/man3/memchr.3:132
msgid ""
"The B<memrchr>()  function is a GNU extension, available since glibc 2.1.91."
msgstr "B<memrchr>()  関数は GNU 拡張であり、glibc 2.1.91 から使用可能である。"

#. type: Plain text
#: build/C/man3/memchr.3:136
msgid ""
"The B<rawmemchr>()  function is a GNU extension, available since glibc 2.1."
msgstr "B<rawmemchr>()  関数は GNU 拡張であり、glibc 2.1 から使用可能である。"

#. type: Plain text
#: build/C/man3/memchr.3:147
msgid ""
"B<ffs>(3), B<index>(3), B<rindex>(3), B<strchr>(3), B<strpbrk>(3), B<strrchr>"
"(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wmemchr>(3)"
msgstr ""
"B<ffs>(3), B<index>(3), B<rindex>(3), B<strchr>(3), B<strpbrk>(3), B<strrchr>"
"(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wmemchr>(3)"

#. type: TH
#: build/C/man3/memcmp.3:30
#, no-wrap
msgid "MEMCMP"
msgstr "MEMCMP"

#. type: TH
#: build/C/man3/memcmp.3:30 build/C/man3/strcmp.3:32
#, fuzzy, no-wrap
#| msgid "2010-11-15"
msgid "2012-11-25"
msgstr "2010-11-15"

#. type: Plain text
#: build/C/man3/memcmp.3:33
msgid "memcmp - compare memory areas"
msgstr "memcmp - メモリ領域を比較する"

#. type: Plain text
#: build/C/man3/memcmp.3:45
#, fuzzy
#| msgid ""
#| "The B<memcmp>()  function compares the first I<n> bytes (each interpreted "
#| "as I<unsigned char>)  of the memory areas I<s1> and I<s2>.  It returns an "
#| "integer less than, equal to, or greater than zero if I<s1> is found, "
#| "respectively, to be less than, to match, or be greater than I<s2>."
msgid ""
"The B<memcmp>()  function compares the first I<n> bytes (each interpreted as "
"I<unsigned char>)  of the memory areas I<s1> and I<s2>."
msgstr ""
"B<memcmp>()  関数は、メモリ領域 I<s1> とI<s2> の最初の I<n> バイトを比較する "
"(各バイトは I<unsigned char> として解釈される)。 I<s1> が I<s2> より小さい"
"か、同じか、あるいは大きいかによって それぞれ、負の整数、0、正の整数を返す。"

#. type: Plain text
#: build/C/man3/memcmp.3:52
msgid ""
"The B<memcmp>()  function returns an integer less than, equal to, or greater "
"than zero if the first I<n> bytes of I<s1> is found, respectively, to be "
"less than, to match, or be greater than the first I<n> bytes of I<s2>."
msgstr ""
"B<memcmp>()  関数は、I<s1> の最初の I<n> バイトが I<s2> の最初の I<n> バイト"
"よりも 小さいか、同じか、あるいは大きいかによってそれぞれ、負の整数、0、 正の"
"整数を返す。"

#. type: Plain text
#: build/C/man3/memcmp.3:60
msgid ""
"For a nonzero return value, the sign is determined by the sign of the "
"difference between the first pair of bytes (interpreted as I<unsigned "
"char>)  that differ in I<s1> and I<s2>."
msgstr ""

#. type: Plain text
#: build/C/man3/memcmp.3:62 build/C/man3/memcpy.3:54 build/C/man3/memmove.3:59
#: build/C/man3/memset.3:51
msgid "SVr4, 4.3BSD, C89, C99, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, C89, C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/memcmp.3:70
msgid ""
"B<bcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), B<strncasecmp>"
"(3), B<strncmp>(3), B<wmemcmp>(3)"
msgstr ""
"B<bcmp>(3), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3), B<strncasecmp>"
"(3), B<strncmp>(3), B<wmemcmp>(3)"

#. type: TH
#: build/C/man3/memcpy.3:30
#, no-wrap
msgid "MEMCPY"
msgstr "MEMCPY"

#. type: TH
#: build/C/man3/memcpy.3:30
#, no-wrap
msgid "2010-11-15"
msgstr "2010-11-15"

#. type: Plain text
#: build/C/man3/memcpy.3:33
msgid "memcpy - copy memory area"
msgstr "memcpy - メモリ領域をコピーする。"

#. type: Plain text
#: build/C/man3/memcpy.3:48
msgid ""
"The B<memcpy>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas must not overlap.  Use B<memmove>(3)  "
"if the memory areas do overlap."
msgstr ""
"B<memcpy>()  はメモリ領域 I<src> の先頭 I<n> バイトを メモリ領域 I<dest> にコ"
"ピーする。コピー元の領域と コピー先の領域が重なってはならない。重なっている場"
"合は B<memmove>(3)  を使うこと。"

#. type: Plain text
#: build/C/man3/memcpy.3:52
msgid "The B<memcpy>()  function returns a pointer to I<dest>."
msgstr "B<memcpy>()  は I<dest> へのポインタを返す。"

#. type: Plain text
#: build/C/man3/memcpy.3:62
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemcpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memmove>(3), B<mempcpy>(3), B<strcpy>(3), "
"B<strncpy>(3), B<wmemcpy>(3)"

#. type: TH
#: build/C/man3/memfrob.3:30
#, no-wrap
msgid "MEMFROB"
msgstr "MEMFROB"

#. type: TH
#: build/C/man3/memfrob.3:30
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/memfrob.3:33
msgid "memfrob - frobnicate (encrypt) a memory area"
msgstr "memfrob - メモリエリアの操作 (暗号化)"

#. type: Plain text
#: build/C/man3/memfrob.3:37
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/memfrob.3:50
msgid ""
"The B<memfrob>()  function encrypts the first I<n> bytes of the memory area "
"I<s> by exclusive-ORing each character with the number 42.  The effect can "
"be reversed by using B<memfrob>()  on the encrypted memory area."
msgstr ""
"B<memfrob>()  関数は、メモリエリア I<s> の最初の I<n> バイトの それぞれの文字"
"を 42 との排他的論理をとることによって暗号化する。 変換後のデータは、暗号化さ"
"れているメモリエリアに (再度)  B<memfrob>()  関数を施すことで、元に戻すことが"
"できる。"

#. type: Plain text
#: build/C/man3/memfrob.3:53
msgid ""
"Note that this function is not a proper encryption routine as the XOR "
"constant is fixed, and is only suitable for hiding strings."
msgstr ""
"この関数は妥当な暗号化ルーチンであるとは言えないことに注意して欲しい。 XOR を"
"とる定数を固定しているので、せいぜい、文字列を隠す程度の用法にし か向いていな"
"い。"

#. type: Plain text
#: build/C/man3/memfrob.3:58
msgid ""
"The B<memfrob>()  function returns a pointer to the encrypted memory area."
msgstr "B<memfrob>()  関数は、暗号化されたメモリエリアへのポインタを返す。"

#. type: Plain text
#: build/C/man3/memfrob.3:63
msgid "The B<memfrob>()  function is unique to the GNU C Library."
msgstr "B<memfrob>()  関数は GNU C ライブラリに固有である。"

#. type: Plain text
#: build/C/man3/memfrob.3:65
msgid "B<strfry>(3)"
msgstr "B<strfry>(3)"

#. type: TH
#: build/C/man3/memmem.3:30
#, no-wrap
msgid "MEMMEM"
msgstr "MEMMEM"

#. type: TH
#: build/C/man3/memmem.3:30
#, no-wrap
msgid "2008-12-05"
msgstr "2008-12-05"

#. type: Plain text
#: build/C/man3/memmem.3:33
msgid "memmem - locate a substring"
msgstr "memmem - 部分文字列の位置を示す"

#. type: Plain text
#: build/C/man3/memmem.3:37 build/C/man3/strchr.3:46
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>string.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/memmem.3:40
#, no-wrap
msgid ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"
msgstr ""
"B<void *memmem(const void *>I<haystack>B<, size_t >I<haystacklen>B<,>\n"
"B<             const void *>I<needle>B<, size_t >I<needlelen>B<);>\n"

#. type: Plain text
#: build/C/man3/memmem.3:47
msgid ""
"The B<memmem>()  function finds the start of the first occurrence of the "
"substring I<needle> of length I<needlelen> in the memory area I<haystack> of "
"length I<haystacklen>."
msgstr ""
"B<memmem>()  関数は、 I<haystacklen> の大きさを持つメモリ領域 I<haystack> の"
"中で I<needlelen> の大きさを持つ部分文字列 I<needle> が 最初に現れる位置を見"
"つける。"

#. type: Plain text
#: build/C/man3/memmem.3:52
msgid ""
"The B<memmem>()  function returns a pointer to the beginning of the "
"substring, or NULL if the substring is not found."
msgstr ""
"B<memmem>()  関数は、部分文字列の開始を指すポインタを返し、もし部分文字列が "
"見つからない場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/memmem.3:54 build/C/man3/mempcpy.3:60
#: build/C/man3/strverscmp.3:90
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: SH
#: build/C/man3/memmem.3:54 build/C/man3/stpcpy.3:72 build/C/man3/strcpy.3:183
#: build/C/man3/strsep.3:79 build/C/man3/strstr.3:70 build/C/man3/strtok.3:120
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/memmem.3:59
msgid ""
"This function was broken in Linux libraries up to and including libc 5.0.9; "
"there the I<needle> and I<haystack> arguments were interchanged, and a "
"pointer to the end of the first occurrence of I<needle> was returned."
msgstr ""
"Linux のライブラリに関していうと、 libc 5.0.9 と それ以前のすべてのバージョン"
"で、この関数は壊れている。 それらのライブラリでは I<needle> と I<haystack> 引"
"数が 入れ替わっており、 I<needle> が最初に出現する部分の最後を 示すポインタが"
"返されていたのである。"

#. type: Plain text
#: build/C/man3/memmem.3:65
msgid ""
"Both old and new libc's have the bug that if I<needle> is empty, "
"I<haystack-1> (instead of I<haystack>) is returned.  And glibc 2.0 makes it "
"worse, returning a pointer to the last byte of I<haystack>.  This is fixed "
"in glibc 2.1."
msgstr ""
"新旧両方の libc ライブラリが、 I<needle> が空の場合 (I<haystack> のかわりに) "
"I<haystack-1>\\ が 返されるというバグを持っている。 そして、glibc 2.0 ではさ"
"らに悪くなっており、 I<haystack> の最後のバイトへのポインタを返す。 これは "
"glibc 2.1 で修正された。"

#. type: Plain text
#: build/C/man3/memmem.3:67
msgid "B<strstr>(3)"
msgstr "B<strstr>(3)"

#. type: TH
#: build/C/man3/memmove.3:30
#, no-wrap
msgid "MEMMOVE"
msgstr "MEMMOVE"

#. type: TH
#: build/C/man3/memmove.3:30
#, no-wrap
msgid "1993-04-10"
msgstr "1993-04-10"

#. type: Plain text
#: build/C/man3/memmove.3:33
msgid "memmove - copy memory area"
msgstr "memmove - メモリ領域をコピーする"

#. type: Plain text
#: build/C/man3/memmove.3:53
msgid ""
"The B<memmove>()  function copies I<n> bytes from memory area I<src> to "
"memory area I<dest>.  The memory areas may overlap: copying takes place as "
"though the bytes in I<src> are first copied into a temporary array that does "
"not overlap I<src> or I<dest>, and the bytes are then copied from the "
"temporary array to I<dest>."
msgstr ""
"B<memmove>()  は、メモリ領域 I<src> の先頭 I<n> バイトを メモリ領域 I<dest> "
"にコピーする。コピー元とコピー先の 領域が重なっていてもよい。 最初に I<src> "
"のバイトが I<src> とも I<dest> とも重ならない一時的な配列にコピーされてから、"
"一時的な配列から I<dest> にバイトのコピーが行われたかのように、コピーが行われ"
"る。"

#. type: Plain text
#: build/C/man3/memmove.3:57
msgid "The B<memmove>()  function returns a pointer to I<dest>."
msgstr "B<memmove>()  は I<dest> へのポインタを返す。"

#. type: Plain text
#: build/C/man3/memmove.3:66
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<strncpy>(3), "
"B<wmemmove>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<strncpy>(3), "
"B<wmemmove>(3)"

#. type: TH
#: build/C/man3/mempcpy.3:10
#, no-wrap
msgid "MEMPCPY"
msgstr "MEMPCPY"

#. type: TH
#: build/C/man3/mempcpy.3:10
#, no-wrap
msgid "2008-08-12"
msgstr "2008-08-11"

#. type: Plain text
#: build/C/man3/mempcpy.3:13
msgid "mempcpy, wmempcpy - copy memory area"
msgstr "mempcpy, wmempcpy - メモリ領域をコピーする"

#. type: Plain text
#: build/C/man3/mempcpy.3:16 build/C/man3/mempcpy.3:22
#: build/C/man3/strfry.3:36 build/C/man3/strstr.3:43
#: build/C/man3/strverscmp.3:31
#, no-wrap
msgid "B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:20
#, no-wrap
msgid "B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<void *mempcpy(void *>I<dest>B<, const void *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:24
#, no-wrap
msgid "B<#include E<lt>wchar.hE<gt>>\n"
msgstr "B<#include E<lt>wchar.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:26
#, no-wrap
msgid "B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<wchar_t *wmempcpy(wchar_t *>I<dest>B<, const wchar_t *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:42
msgid ""
"The B<mempcpy>()  function is nearly identical to the B<memcpy>(3)  "
"function.  It copies I<n> bytes from the object beginning at I<src> into the "
"object pointed to by I<dest>.  But instead of returning the value of I<dest> "
"it returns a pointer to the byte following the last written byte."
msgstr ""
"B<mempcpy>()  関数は B<memcpy>(3)  関数とほぼ同一である。 この関数は、 "
"I<src> で始まるオブジェクトから I<n> バイトを、 I<dest> で指されるオブジェク"
"トにコピーする。 ただし I<dest> の値を返すのではなく、 最後に書き込まれたバイ"
"トの後に続くバイトへのポインタを返す。"

#. type: Plain text
#: build/C/man3/mempcpy.3:45
msgid ""
"This function is useful in situations where a number of objects shall be "
"copied to consecutive memory positions."
msgstr ""
"この関数はいくつかのオブジェクトが 連続的なメモリの場所にコピーされるような状"
"況で役に立つ。"

#. type: Plain text
#: build/C/man3/mempcpy.3:53
msgid ""
"The B<wmempcpy>()  function is identical but takes I<wchar_t> type arguments "
"and copies I<n> wide characters."
msgstr ""
"B<wmempcpy>()  関数はこの関数と同じであるが、 I<wchar_t> 型の引き数をとり、 "
"I<n> ワイド文字列をコピーする。"

#. type: Plain text
#: build/C/man3/mempcpy.3:55
msgid "I<dest> + I<n>."
msgstr "I<dest> + I<n>."

#. type: Plain text
#: build/C/man3/mempcpy.3:58
msgid "B<mempcpy>()  first appeared in glibc in version 2.1."
msgstr "B<mempcpy>()  は glibc バージョン 2.1 で初めて登場した。"

#. type: SH
#: build/C/man3/mempcpy.3:60 build/C/man3/stpcpy.3:75
#: build/C/man3/strtok.3:136
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/mempcpy.3:70
#, no-wrap
msgid ""
"void *\n"
"combine(void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"
"}\n"
msgstr ""
"void *\n"
"combine (void *o1, size_t s1, void *o2, size_t s2)\n"
"{\n"
"    void *result = malloc(s1 + s2);\n"
"    if (result != NULL)\n"
"        mempcpy(mempcpy(result, o1, s1), o2, s2);\n"
"    return result;\n"

#. type: Plain text
#: build/C/man3/mempcpy.3:76
msgid "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"
msgstr "B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<wmemcpy>(3)"

#. type: TH
#: build/C/man3/memset.3:30
#, no-wrap
msgid "MEMSET"
msgstr "MEMSET"

#. type: TH
#: build/C/man3/memset.3:30
#, no-wrap
msgid "1993-04-11"
msgstr "1993-04-11"

#. type: Plain text
#: build/C/man3/memset.3:33
msgid "memset - fill memory with a constant byte"
msgstr "memset - ある一定のバイトでメモリ領域を埋める。"

#. type: Plain text
#: build/C/man3/memset.3:44
msgid ""
"The B<memset>()  function fills the first I<n> bytes of the memory area "
"pointed to by I<s> with the constant byte I<c>."
msgstr ""
"B<memset>()  は I<s> で示されるメモリ領域の先頭から I<n> バイトを I<c> で埋め"
"る。"

#. type: Plain text
#: build/C/man3/memset.3:49
msgid "The B<memset>()  function returns a pointer to the memory area I<s>."
msgstr "B<memset>()  は I<s> へのポインタを返す。"

#. type: Plain text
#: build/C/man3/memset.3:55
msgid "B<bzero>(3), B<swab>(3), B<wmemset>(3)"
msgstr "B<bzero>(3), B<swab>(3), B<wmemset>(3)"

#. type: TH
#: build/C/man3/stpcpy.3:25
#, no-wrap
msgid "STPCPY"
msgstr "STPCPY"

#. type: TH
#: build/C/man3/stpcpy.3:25
#, no-wrap
msgid "2012-03-15"
msgstr "2012-03-15"

#. type: Plain text
#: build/C/man3/stpcpy.3:28
msgid "stpcpy - copy a string returning a pointer to its end"
msgstr "stpcpy - 文字列をコピーし、コピーした文字列の終りへのポインタを返す"

#. type: Plain text
#: build/C/man3/stpcpy.3:33 build/C/man3/string.3:51
#, no-wrap
msgid "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *stpcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:41
msgid "B<stpcpy>():"
msgstr "B<stpcpy>():"

#. type: TP
#: build/C/man3/stpcpy.3:44 build/C/man3/stpncpy.3:33 build/C/man3/strdup.3:64
#: build/C/man3/strnlen.3:32 build/C/man3/strsignal.3:51
#, no-wrap
msgid "Since glibc 2.10:"
msgstr "glibc 2.10 以降:"

#. type: Plain text
#: build/C/man3/stpcpy.3:47 build/C/man3/stpncpy.3:36
#: build/C/man3/strnlen.3:35 build/C/man3/strsignal.3:54
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: TP
#: build/C/man3/stpcpy.3:47 build/C/man3/stpncpy.3:36 build/C/man3/strdup.3:67
#: build/C/man3/strnlen.3:35 build/C/man3/strsignal.3:54
#, no-wrap
msgid "Before glibc 2.10:"
msgstr "glibc 2.10 より前:"

#. type: Plain text
#: build/C/man3/stpcpy.3:61
msgid ""
"The B<stpcpy>()  function copies the string pointed to by I<src> (including "
"the terminating null byte (\\(aq\\e0\\(aq)) to the array pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy."
msgstr ""
"B<stpcpy>()  関数は、I<src> で指された文字列を (文字列を終端する NULL バイト "
"(\\(aq\\e0\\(aq) を含めて) I<dest> で指された配列にコピーする。 文字列は重複"
"してはならず、コピー先の文字列 I<dest> はコピーを受け取る のに十分大きくなく"
"てはならない。"

#. type: Plain text
#: build/C/man3/stpcpy.3:66
msgid ""
"B<stpcpy>()  returns a pointer to the B<end> of the string I<dest> (that is, "
"the address of the terminating null byte)  rather than the beginning."
msgstr ""
"B<stpcpy>()  は、文字列 I<dest> の始まりではなく B<終り>を指すポインタ (すな"
"わち、文字列を終端する NULL バイト) を返す。"

#. type: Plain text
#: build/C/man3/stpcpy.3:72
msgid ""
"This function was added to POSIX.1-2008. Before that, it was not part of the "
"C or POSIX.1 standards, nor customary on UNIX systems, but was not a GNU "
"invention either.  Perhaps it came from MS-DOS.  It is also present on the "
"BSDs."
msgstr ""
"この関数は POSIX.1-2008 に追加された。 それ以前は、この関数は C や POSIX.1 標"
"準の一部でも UNIX システムの慣習的なものでもなかったが、 GNU の発明というわけ"
"でもなかった。 ひょっとしたら MS-DOS 由来のものかもしれない。 この関数は BSD "
"系にも存在する。"

#. type: Plain text
#: build/C/man3/stpcpy.3:75
msgid "This function may overrun the buffer I<dest>."
msgstr "この関数はバッファ I<dest> の範囲を行き過ぎてしまう可能性がある。"

#. type: Plain text
#: build/C/man3/stpcpy.3:80
msgid ""
"For example, this program uses B<stpcpy>()  to concatenate B<foo> and B<bar> "
"to produce B<foobar>, which it then prints."
msgstr ""
"例として、このプログラムは B<foo> と B<bar> を連結して B<foobar> を作るため"
"に B<stpcpy>()  を使用し、その後表示する。"

#. type: Plain text
#: build/C/man3/stpcpy.3:86
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:92
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    char buffer[20];\n"
"    char *to = buffer;\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:97
#, no-wrap
msgid ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"
msgstr ""
"    to = stpcpy(to, \"foo\");\n"
"    to = stpcpy(to, \"bar\");\n"
"    printf(\"%s\\en\", buffer);\n"
"}\n"

#. type: Plain text
#: build/C/man3/stpcpy.3:108
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpncpy>(3), "
"B<strcpy>(3), B<string>(3), B<wcpcpy>(3)"

#. type: TH
#: build/C/man3/stpncpy.3:14
#, no-wrap
msgid "STPNCPY"
msgstr "STPNCPY"

#. type: TH
#: build/C/man3/stpncpy.3:14 build/C/man3/strsep.3:33 build/C/man3/strstr.3:33
#, no-wrap
msgid "2011-09-28"
msgstr "2011-09-28"

#. type: Plain text
#: build/C/man3/stpncpy.3:17
msgid "stpncpy - copy a fixed-size string, returning a pointer to its end"
msgstr "stpncpy - 固定長の文字列をコピーして、その最後へのポインターを返す"

#. type: Plain text
#: build/C/man3/stpncpy.3:22
#, no-wrap
msgid "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *stpncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/stpncpy.3:30
msgid "B<stpncpy>():"
msgstr "B<stpncpy>():"

#. type: Plain text
#: build/C/man3/stpncpy.3:56
msgid ""
"The B<stpncpy>()  function copies at most I<n> characters from the string "
"pointed to by I<src>, including the terminating null byte (\\(aq\\e0\\(aq), "
"to the array pointed to by I<dest>.  Exactly I<n> characters are written at "
"I<dest>.  If the length I<strlen(src)> is smaller than I<n>, the remaining "
"characters in the array pointed to by I<dest> are filled with null bytes "
"(\\(aq\\e0\\(aq), If the length I<strlen(src)> is greater or equal to I<n>, "
"the string pointed to by I<dest> will not be null-terminated."
msgstr ""
"B<stpncpy>()  関数は I<src> が指している文字列から終端の NULL バイト (\\(aq"
"\\e0\\(aq)  を含めて最大 I<n> バイトを I<dest> にコピーする。長さ I<strlen"
"(src)> が I<n> より小さい場合には I<dest> の残りの 部分には NULL バイト "
"(\\(aq\\e0\\(aq) 文字が埋められる。 長さ I<strlen(src)> が I<n> 以上ならば、 "
"I<dest> が指す文字列は NULL で終端されていない。"

#. type: Plain text
#: build/C/man3/stpncpy.3:58
msgid "The strings may not overlap."
msgstr "二つの文字列は重なってはならない。"

#. type: Plain text
#: build/C/man3/stpncpy.3:61
msgid ""
"The programmer must ensure that there is room for at least I<n> characters "
"at I<dest>."
msgstr ""
"プログラマーは I<dest> に少なくとも I<n> バイトの空きがあることを 保証しなけ"
"ればならない。"

#. type: Plain text
#: build/C/man3/stpncpy.3:66
msgid ""
"B<stpncpy>()  returns a pointer to the terminating null byte in I<dest>, or, "
"if I<dest> is not null-terminated, I<dest + n>."
msgstr ""
"B<stpncpy>()  は I<dest> の終端の NULL バイトを指すポインターを返すか、 "
"I<dest> が NULL バイトで終端されていない場合には I<dest + n> を返す。"

#. type: Plain text
#: build/C/man3/stpncpy.3:68
msgid ""
"This function was added to POSIX.1-2008. Before that, it was a GNU extension."
msgstr ""
"この関数は POSIX.1-2008 に追加された。 それ以前は GNU による拡張であった。"

#. type: Plain text
#: build/C/man3/stpncpy.3:71
msgid "B<strncpy>(3), B<wcpncpy>(3)"
msgstr "B<strncpy>(3), B<wcpncpy>(3)"

#. type: TH
#: build/C/man3/strcasecmp.3:30
#, no-wrap
msgid "STRCASECMP"
msgstr "STRCASECMP"

#. type: TH
#: build/C/man3/strcasecmp.3:30 build/C/man3/strdup.3:31
#: build/C/man3/strnlen.3:13 build/C/man3/strpbrk.3:30
#: build/C/man3/strspn.3:30 build/C/man3/strtok.3:30 build/C/man3/strxfrm.3:30
#, no-wrap
msgid "2012-05-10"
msgstr "2012-05-10"

#. type: Plain text
#: build/C/man3/strcasecmp.3:33
msgid "strcasecmp, strncasecmp - compare two strings ignoring case"
msgstr "strcasecmp, strncasecmp - 二つの文字列を大文字小文字を区別せず比較する"

#. type: Plain text
#: build/C/man3/strcasecmp.3:38 build/C/man3/string.3:41
#, no-wrap
msgid "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcasecmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: build/C/man3/strcasecmp.3:40 build/C/man3/string.3:43
#, no-wrap
msgid "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncasecmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcasecmp.3:49
msgid ""
"The B<strcasecmp>()  function compares the two strings I<s1> and I<s2>, "
"ignoring the case of the characters.  It returns an integer less than, equal "
"to, or greater than zero if I<s1> is found, respectively, to be less than, "
"to match, or be greater than I<s2>."
msgstr ""
"B<strcasecmp>()  関数は、二つの文字列　I<s1> と I<s2> を、 大文字小文字を区別"
"せずに比較する。 I<s1> が I<s2> よりも小さいか、同じか、大きいかによってそれ"
"ぞれ 負の整数、0、正の整数を返す。"

#. type: Plain text
#: build/C/man3/strcasecmp.3:54
msgid ""
"The B<strncasecmp>()  function is similar, except it only compares the first "
"I<n> bytes of I<s1>."
msgstr ""
"B<strncasecmp>() 関数も同様であるが、 I<s1> の最初の I<n> バイトだけを\n"
"比較する点だけが異なる。"

#. type: Plain text
#: build/C/man3/strcasecmp.3:63
msgid ""
"The B<strcasecmp>()  and B<strncasecmp>()  functions return an integer less "
"than, equal to, or greater than zero if I<s1> (or the first I<n> bytes "
"thereof) is found, respectively, to be less than, to match, or be greater "
"than I<s2>."
msgstr ""
"B<strcasecmp>()  と B<strncasecmp>()  関数は、I<s1> (または、その最初の I<n> "
"バイト)が I<s2> よりも小さいか、 同じか、大きいかにより、それぞれ負の整数、"
"0、正の整数を返す。"

#. type: Plain text
#: build/C/man3/strcasecmp.3:65
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/strcasecmp.3:74
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<strcmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncmp>(3), B<wcscasecmp>(3), B<wcsncasecmp>(3)"

#. type: TH
#: build/C/man3/strcat.3:32
#, no-wrap
msgid "STRCAT"
msgstr "STRCAT"

#. type: TH
#: build/C/man3/strcat.3:32 build/C/man3/strcpy.3:35
#, fuzzy, no-wrap
#| msgid "2012-03-15"
msgid "2012-07-19"
msgstr "2012-03-15"

#. type: Plain text
#: build/C/man3/strcat.3:35
msgid "strcat, strncat - concatenate two strings"
msgstr "strcat, strncat - 二つの文字列を連結する"

#. type: Plain text
#: build/C/man3/strcat.3:40 build/C/man3/string.3:53
#, no-wrap
msgid "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcat(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: build/C/man3/strcat.3:42 build/C/man3/string.3:71
#, no-wrap
msgid "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncat(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcat.3:56
#, fuzzy
#| msgid ""
#| "The B<strcat>()  function appends the I<src> string to the I<dest> "
#| "string, overwriting the terminating null byte (\\(aq\\e0\\(aq) at the end "
#| "of I<dest>, and then adds a terminating null byte.  The strings may not "
#| "overlap, and the I<dest> string must have enough space for the result."
msgid ""
"The B<strcat>()  function appends the I<src> string to the I<dest> string, "
"overwriting the terminating null byte (\\(aq\\e0\\(aq) at the end of "
"I<dest>, and then adds a terminating null byte.  The strings may not "
"overlap, and the I<dest> string must have enough space for the result.  If "
"I<dest> is not large enough, program behavior is unpredictable; I<buffer "
"overruns are a favorite avenue for attacking secure programs>."
msgstr ""
"B<strcat>()  関数は、I<dest> 文字列の後に I<src> 文字列を付け加える。 その際"
"に、I<dest> の最後にある終端の NULL バイト (\\(aq\\e0\\(aq)  は上書きされ、新"
"たに生成された文字列の末尾に終端の NULL バイトが付与される。 二つの文字列 "
"I<src> と I<dest> は重なってはならない。 また、文字列 I<dest> は、連結後の結"
"果を格納するのに 十分な大きさでなければならない。"

#. type: Plain text
#: build/C/man3/strcat.3:60
msgid "The B<strncat>()  function is similar, except that"
msgstr "B<strncat>()  も同様だが、以下の点が異なる。"

#. type: IP
#: build/C/man3/strcat.3:60 build/C/man3/strcat.3:62 build/C/man3/strsep.3:82
#: build/C/man3/strsep.3:84 build/C/man3/strsep.3:86 build/C/man3/strtok.3:123
#: build/C/man3/strtok.3:125 build/C/man3/strtok.3:127
#: build/C/man3/strtok.3:129
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/strcat.3:62
msgid "it will use at most I<n> bytes from I<src>; and"
msgstr "I<src> のうち最大 I<n> バイトが使用される。"

#. type: Plain text
#: build/C/man3/strcat.3:65
msgid ""
"I<src> does not need to be null-terminated if it contains I<n> or more bytes."
msgstr ""
"I<src> が I<n> バイト以上の場合、 \n"
"I<src> は NULL 終端されている必要はない。"

#. type: Plain text
#: build/C/man3/strcat.3:69
msgid ""
"As with B<strcat>(), the resulting string in I<dest> is always null-"
"terminated."
msgstr ""
"B<strcat>()  と同じく、I<dest> に格納される結果の文字列は常に NULL 終端され"
"る。"

#. type: Plain text
#: build/C/man3/strcat.3:76
msgid ""
"If I<src> contains I<n> or more bytes, B<strncat>()  writes I<n+1> bytes to "
"I<dest> (I<n> from I<src> plus the terminating null byte).  Therefore, the "
"size of I<dest> must be at least I<strlen(dest)+n+1>."
msgstr ""
"I<src> が I<n> バイト以上の場合、 B<strncat>() は I<dest> に I<n+1> \n"
"バイトを書き込む (I<src> からの I<n> バイトと終端の NULL バイトである)。\n"
"したがって、I<dest> の大きさは最低でも I<strlen(dest)+n+1> でなければ\n"
"ならない。"

#. type: Plain text
#: build/C/man3/strcat.3:80
msgid "A simple implementation of B<strncat>()  might be:"
msgstr "B<strncat>()  の簡単な実装は以下のような感じであろう:"

#. type: Plain text
#: build/C/man3/strcat.3:88
#, no-wrap
msgid ""
"char*\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"
msgstr ""
"char*\n"
"strncat(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t dest_len = strlen(dest);\n"
"    size_t i;\n"

#. type: Plain text
#: build/C/man3/strcat.3:92
#, no-wrap
msgid ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    for (i = 0 ; i E<lt> n && src[i] != \\(aq\\e0\\(aq ; i++)\n"
"        dest[dest_len + i] = src[i];\n"
"    dest[dest_len + i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man3/strcat.3:95 build/C/man3/strcpy.3:95
#, no-wrap
msgid ""
"    return dest;\n"
"}\n"
msgstr ""
"    return dest;\n"
"}\n"

#. type: Plain text
#: build/C/man3/strcat.3:103
msgid ""
"The B<strcat>()  and B<strncat>()  functions return a pointer to the "
"resulting string I<dest>."
msgstr ""
"B<strcat>()  関数と B<strncat>()  関数は、結果としてできる文字列 I<dest> への"
"ポインタを返す。"

#. type: Plain text
#: build/C/man3/strcat.3:105 build/C/man3/strcmp.3:67
#: build/C/man3/strcoll.3:60 build/C/man3/strcpy.3:106
#: build/C/man3/strlen.3:50 build/C/man3/strpbrk.3:52 build/C/man3/strspn.3:67
#: build/C/man3/strxfrm.3:66
msgid "SVr4, 4.3BSD, C89, C99."
msgstr "SVr4, 4.3BSD, C89, C99."

#. type: Plain text
#: build/C/man3/strcat.3:107 build/C/man3/strcpy.3:146
msgid ""
"Some systems (the BSDs, Solaris, and others) provide the following function:"
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:109
#, fuzzy, no-wrap
#| msgid ""
#| "char *\n"
#| "strncpy(char *dest, const char *src, size_t n)\n"
#| "{\n"
#| "    size_t i;\n"
msgid "    size_t strlcat(char *dest, const char *src, size_t size);\n"
msgstr ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"

#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: build/C/man3/strcat.3:142
msgid ""
"This function appends the null-terminated string I<src> to the string "
"I<dest>, copying at most I<size-strlen(dest)-1> from I<src>, and adds a null "
"terminator to the result, I<unless> I<size> is less than I<strlen(dest)>.  "
"This function fixes the buffer overrun problem of B<strcat>(), but the "
"caller must still handle the possibility of data loss if I<size> is too "
"small.  The function returns the length of the string B<strlcat>()  tried to "
"create; if the return value is greater than or equal to I<size>, data loss "
"occurred.  If data loss matters, the caller I<must> either check the "
"arguments before the call, or test the function return value.  B<strlcat>()  "
"is not present in glibc and is not standardized by POSIX, but is available "
"on Linux via the I<libbsd> library."
msgstr ""

#. type: Plain text
#: build/C/man3/strcat.3:151
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<strcpy>(3), B<string>(3), "
"B<strncpy>(3), B<wcscat>(3), B<wcsncat>(3)"

#. type: TH
#: build/C/man3/strchr.3:33
#, no-wrap
msgid "STRCHR"
msgstr "STRCHR"

#. type: TH
#: build/C/man3/strchr.3:33
#, no-wrap
msgid "2012-04-24"
msgstr "2012-04-24"

#. type: Plain text
#: build/C/man3/strchr.3:36
msgid "strchr, strrchr, strchrnul - locate character in string"
msgstr "strchr, strrchr, strchrnul - 文字列中の文字の位置を特定する"

#. type: Plain text
#: build/C/man3/strchr.3:41 build/C/man3/string.3:55
#, no-wrap
msgid "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/strchr.3:43 build/C/man3/string.3:79
#, no-wrap
msgid "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strrchr(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/strchr.3:48
#, no-wrap
msgid "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"
msgstr "B<char *strchrnul(const char *>I<s>B<, int >I<c>B<);>\n"

#. type: Plain text
#: build/C/man3/strchr.3:57
msgid ""
"The B<strchr>()  function returns a pointer to the first occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<strchr>()  関数は、文字列 I<s> 中に最初に文字 I<c> が現れた位置へのポインタ"
"を返す。"

#. type: Plain text
#: build/C/man3/strchr.3:65
msgid ""
"The B<strrchr>()  function returns a pointer to the last occurrence of the "
"character I<c> in the string I<s>."
msgstr ""
"B<strrchr>()  関数は、文字列 I<s> 中に最後に文字 I<c> が現れた位置へのポイン"
"タを返す。"

#. type: Plain text
#: build/C/man3/strchr.3:78
msgid ""
"The B<strchrnul>()  function is like B<strchr>()  except that if I<c> is not "
"found in I<s>, then it returns a pointer to the null byte at the end of "
"I<s>, rather than NULL."
msgstr ""
"B<strchrnul>()  関数は B<strchr>()  と同様だが、 I<c> が I<s> 中に見つからな"
"かった場合に、返り値として NULL でなく、I<s> の末尾のヌルバイトへのポインタを"
"返す点が異なる。"

#. type: Plain text
#: build/C/man3/strchr.3:81
msgid ""
"Here \"character\" means \"byte\"; these functions do not work with wide or "
"multibyte characters."
msgstr ""
"ここでいう「文字」は「バイト」の意味なので、 これらの関数はワイド文字やマルチ"
"バイト文字では動作しない。"

#. type: Plain text
#: build/C/man3/strchr.3:93
msgid ""
"The B<strchr>()  and B<strrchr>()  functions return a pointer to the matched "
"character or NULL if the character is not found.  The terminating null byte "
"is considered part of the string, so that if I<c> is specified as \\(aq"
"\\e0\\(aq, these functions return a pointer to the terminator."
msgstr ""
"B<strchr>() と B<strrchr>() 関数は一致した文字へのポインタを返し、もし\n"
"文字が見つからない場合は NULL を返す。終端の NULL バイトは文字列の一部と\n"
"みなされ、I<c> に \\(aq\\e0\\(aq が指定された場合には、これらの関数は\n"
"終端の NULL バイトへのポインタを返す。"

#. type: Plain text
#: build/C/man3/strchr.3:101
msgid ""
"The B<strchrnul>()  function returns a pointer to the matched character, or "
"a pointer to the null byte at the end of I<s> (i.e., I<s+strlen(s)>)  if the "
"character is not found."
msgstr ""
"B<strchrnul>()  関数は一致した文字へのポインタを返す。 文字が見つからない場合"
"は、I<s> の末尾のヌルバイトへの ポインタ (つまり I<s+strlen(s)>) を返す。"

#. type: Plain text
#: build/C/man3/strchr.3:104
msgid "B<strchrnul>()  first appeared in glibc in version 2.1.1."
msgstr "B<strchrnul>()  は glibc バージョン 2.1.1 で初めて登場した。"

#. type: Plain text
#: build/C/man3/strchr.3:111
msgid ""
"B<strchr>()  and B<strrchr>()  are in SVr4, 4.3BSD, C89, C99.  B<strchrnul>"
"()  is a GNU extension."
msgstr ""
"B<strchr>()  と B<strrchr>()  は SVr4, 4.3BSD, C89, C99 に準拠している。 "
"B<strchrnul>()  は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/strchr.3:124
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<string>(3), B<strlen>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), "
"B<wcschr>(3), B<wcsrchr>(3)"

#. type: TH
#: build/C/man3/strcmp.3:32
#, no-wrap
msgid "STRCMP"
msgstr "STRCMP"

#. type: Plain text
#: build/C/man3/strcmp.3:35
msgid "strcmp, strncmp - compare two strings"
msgstr "strcmp, strncmp - 二つの文字列を比べる"

#. type: Plain text
#: build/C/man3/strcmp.3:40 build/C/man3/string.3:57
#, no-wrap
msgid "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: build/C/man3/strcmp.3:42 build/C/man3/string.3:73
#, no-wrap
msgid "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"
msgstr "B<int strncmp(const char *>I<s1>B<, const char *>I<s2>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcmp.3:51
msgid ""
"The B<strcmp>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""
"B<strcmp>()  関数は二つの文字列 I<s1> と I<s2> を較べる。 この関数は、 I<s1> "
"が I<s2> に較べて 1)小さい、2)等しい、3)大きい場合に、 ゼロよりも 1)小さい、"
"2)等しい、3)大きい整数を返す。"

#. type: Plain text
#: build/C/man3/strcmp.3:56
msgid ""
"The B<strncmp>()  function is similar, except it only compares the first (at "
"most) I<n> bytes of I<s1> and I<s2>."
msgstr ""
"B<strncmp>() 関数は、I<s1> と I<s2> の最初の I<n> バイトだけを比較する\n"
"ことを除けば、strcmp()と同様である。"

#. type: Plain text
#: build/C/man3/strcmp.3:65
msgid ""
"The B<strcmp>()  and B<strncmp>()  functions return an integer less than, "
"equal to, or greater than zero if I<s1> (or the first I<n> bytes thereof) is "
"found, respectively, to be less than, to match, or be greater than I<s2>."
msgstr ""
"B<strcmp>()  関数と B<strncmp>()  関数は整数を返す。 この整数は、ゼロよりも、"
"1)小さい、2)等しい、3)大きいのいずれかである。 それぞれは、I<s1>（または、こ"
"の文字列の最初の I<n> バイト）が I<s2> よりも、1)小さい、2)等しい、3)大きいに"
"対応している。"

#. type: Plain text
#: build/C/man3/strcmp.3:77
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<strcasecmp>(3), B<strcoll>(3), B<string>(3), "
"B<strncasecmp>(3), B<strverscmp>(3), B<wcscmp>(3), B<wcsncmp>(3)"

#. type: TH
#: build/C/man3/strcoll.3:30
#, no-wrap
msgid "STRCOLL"
msgstr "STRCOLL"

#. type: Plain text
#: build/C/man3/strcoll.3:33
msgid "strcoll - compare two strings using the current locale"
msgstr "strcoll - 現在のロケールを使用して二つの文字列を比較する"

#. type: Plain text
#: build/C/man3/strcoll.3:38 build/C/man3/string.3:59
#, no-wrap
msgid "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strcoll(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#. type: Plain text
#: build/C/man3/strcoll.3:51
msgid ""
"The B<strcoll>()  function compares the two strings I<s1> and I<s2>.  It "
"returns an integer less than, equal to, or greater than zero if I<s1> is "
"found, respectively, to be less than, to match, or be greater than I<s2>.  "
"The comparison is based on strings interpreted as appropriate for the "
"program's current locale for category B<LC_COLLATE>.  (See B<setlocale>(3).)"
msgstr ""
"B<strcoll>() 関数は二つの文字列 I<s1> と I<s2> を比較する。 この関数は、"
"I<s1> が I<s2> よりも小さいか、等しいか、大きいかによって それぞれ負の整数、"
"0、正の整数を返す。 比較は、プログラムの現在のロケールの B<LC_COLLATE> カテゴ"
"リに応じて 解釈された文字列に基づいて行われる (B<setlocale>(3)  参照)。"

#. type: Plain text
#: build/C/man3/strcoll.3:58
msgid ""
"The B<strcoll>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be less than, to "
"match, or be greater than I<s2>, when both are interpreted as appropriate "
"for the current locale."
msgstr ""
"B<strcoll>()  関数は、I<s1> が I<s2> よりも小さいか、等しいか、 大きいかに"
"よって、それぞれ負の整数、0、正の整数を返す。 どちらの文字列も現在のロケール"
"に応じて解釈されたものが使用される。"

#. type: Plain text
#: build/C/man3/strcoll.3:65
msgid ""
"In the I<\"POSIX\"> or I<\"C\"> locales B<strcoll>()  is equivalent to "
"B<strcmp>(3)."
msgstr ""
"I<\"POSIX\"> および I<\"C\"> ロケールにおいては、 B<strcoll>()  は B<strcmp>"
"(3)  と等価である。"

#. type: Plain text
#: build/C/man3/strcoll.3:73
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<string>(3), B<strxfrm>(3)"

#. type: TH
#: build/C/man3/strcpy.3:35
#, no-wrap
msgid "STRCPY"
msgstr "STRCPY"

#. type: Plain text
#: build/C/man3/strcpy.3:38
msgid "strcpy, strncpy - copy a string"
msgstr "strcpy, strncpy - 文字列をコピーする"

#. type: Plain text
#: build/C/man3/strcpy.3:43 build/C/man3/string.3:61
#, no-wrap
msgid "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"
msgstr "B<char *strcpy(char *>I<dest>B<, const char *>I<src>B<);>\n"

#. type: Plain text
#: build/C/man3/strcpy.3:45 build/C/man3/string.3:75
#, no-wrap
msgid "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strncpy(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strcpy.3:56
#, fuzzy
#| msgid ""
#| "The B<strcpy>()  function copies the string pointed to by I<src>, "
#| "including the terminating null byte (\\(aq\\e0\\(aq), to the buffer "
#| "pointed to by I<dest>.  The strings may not overlap, and the destination "
#| "string I<dest> must be large enough to receive the copy."
msgid ""
"The B<strcpy>()  function copies the string pointed to by I<src>, including "
"the terminating null byte (\\(aq\\e0\\(aq), to the buffer pointed to by "
"I<dest>.  The strings may not overlap, and the destination string I<dest> "
"must be large enough to receive the copy.  I<Beware of buffer overruns!> "
"(See BUGS.)"
msgstr ""
"B<strcpy>()  関数は I<src> が指す文字列を末尾のヌルバイト (\\(aq\\e0\\(aq) も"
"含めて I<dest> が指すバッファにコピーする。 二つの文字列は重なってはならな"
"い。受け側の文字列 I<dest> は コピーを受け取るのに十分な大きさでなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/strcpy.3:65
msgid ""
"The B<strncpy>()  function is similar, except that at most I<n> bytes of "
"I<src> are copied.  B<Warning>: If there is no null byte among the first "
"I<n> bytes of I<src>, the string placed in I<dest> will not be null-"
"terminated."
msgstr ""
"B<strncpy>()  関数も同様だが、 I<src> のうち最大でも I<n> バイトしかコピーさ"
"れない点が異なる。 B<警告>: I<src> の最初の I<n> バイトの中にヌルバイトがない"
"場合、 I<dest> に格納される文字列はヌルで終端されないことになる。"

#. type: Plain text
#: build/C/man3/strcpy.3:76
#, fuzzy
#| msgid ""
#| "If the length of I<src> is less than I<n>, B<strncpy>()  pads the "
#| "remainder of I<dest> with null bytes."
msgid ""
"If the length of I<src> is less than I<n>, B<strncpy>()  writes additional "
"null bytes to I<dest> to ensure that a total of I<n> bytes are written."
msgstr ""
"I<src> の長さが I<n> よりも短い場合、 B<strncpy>()  は I<dest> の残りをヌルバ"
"イトで埋める。"

#. type: Plain text
#: build/C/man3/strcpy.3:80
msgid "A simple implementation of B<strncpy>()  might be:"
msgstr "B<strncpy>()  の簡単な実装は以下のような感じであろう:"

#. type: Plain text
#: build/C/man3/strcpy.3:87
#, no-wrap
msgid ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"
msgstr ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"

#. type: Plain text
#: build/C/man3/strcpy.3:92
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"
msgstr ""
"    for (i = 0; i E<lt> n && src[i] != \\(aq\\e0\\(aq; i++)\n"
"        dest[i] = src[i];\n"
"    for ( ; i E<lt> n; i++)\n"
"        dest[i] = \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man3/strcpy.3:104
msgid ""
"The B<strcpy>()  and B<strncpy>()  functions return a pointer to the "
"destination string I<dest>."
msgstr ""
"B<strcpy>()  関数と B<strncpy>()  関数は 受け側の文字列I<dest>へのポインタを"
"返す。"

#. type: Plain text
#: build/C/man3/strcpy.3:115
msgid ""
"Some programmers consider B<strncpy>()  to be inefficient and error prone.  "
"If the programmer knows (i.e., includes code to test!)  that the size of "
"I<dest> is greater than the length of I<src>, then B<strcpy>()  can be used."
msgstr ""
"B<strncpy>()  は効率的でなく間違いを起こしやすいと考えるプログラマもいるだろ"
"う。 プログラマが I<dest> の大きさが I<src> の長さよりも 大きいことを知ってい"
"る (つまり、そのことをチェックするコードを 書いている) 場合は、 B<strcpy()> "
"を使うことができる。"

#. type: Plain text
#: build/C/man3/strcpy.3:124
msgid ""
"One valid (and intended) use of B<strncpy>()  is to copy a C string to a "
"fixed-length buffer while ensuring both that the buffer is not overflowed "
"and that unused bytes in the target buffer are zeroed out (perhaps to "
"prevent information leaks if the buffer is to be written to media or "
"transmitted to another process via an interprocess communication technique)."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:130
#, fuzzy
#| msgid ""
#| "If there is no terminating null byte in the first I<n> bytes of I<src>, "
#| "B<strncpy>()  produces an unterminated string in I<dest>.  Programmers "
#| "often prevent this mistake by forcing termination as follows:"
msgid ""
"If there is no terminating null byte in the first I<n> bytes of I<src>, "
"B<strncpy>()  produces an unterminated string in I<dest>.  You can force "
"termination using something like the following:"
msgstr ""
"I<src> の最初の I<n> バイトに終端のヌルバイトがない場合、 B<strncpy>()\n"
"は I<dest> に終端されていない文字列を生成する。 プログラマは間違いを防\n"
"止するために、 以下のように強制的に終端を行うことがよくある。"

#. type: Plain text
#: build/C/man3/strcpy.3:136
#, no-wrap
msgid ""
"strncpy(buf, str, n);\n"
"if (n E<gt> 0)\n"
"    buf[n - 1]= \\(aq\\e0\\(aq;\n"
msgstr ""
"strncpy(buf, str, n);\n"
"if (n E<gt> 0)\n"
"    buf[n - 1]= \\(aq\\e0\\(aq;\n"

#. type: Plain text
#: build/C/man3/strcpy.3:144
msgid ""
"(Of course, the above technique ignores the fact that information contained "
"in I<src> is lost in the copying to I<dest>.)"
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:148
#, fuzzy, no-wrap
#| msgid ""
#| "char *\n"
#| "strncpy(char *dest, const char *src, size_t n)\n"
#| "{\n"
#| "    size_t i;\n"
msgid "    size_t strlcpy(char *dest, const char *src, size_t size);\n"
msgstr ""
"char *\n"
"strncpy(char *dest, const char *src, size_t n)\n"
"{\n"
"    size_t i;\n"

#.  http://static.usenix.org/event/usenix99/full_papers/millert/millert_html/index.html
#.      "strlcpy and strlcat - consistent, safe, string copy and concatenation"
#.      1999 USENIX Annual Technical Conference
#.  https://lwn.net/Articles/506530/
#. type: Plain text
#: build/C/man3/strcpy.3:183
msgid ""
"This function is similar to B<strncpy>(), but it copies at most I<size-1> "
"bytes to I<dest>, always adds a terminating null byte, and does not pad the "
"target with (further) null bytes.  This function fixes some of the problems "
"of B<strcpy>()  and B<strncpy>(), but the caller must still handle the "
"possibility of data loss if I<size> is too small.  The return value of the "
"function is the length of I<src>, which allows truncation to be easily "
"detected: if the return value is greater than or equal to I<size>, "
"truncation occurred.  If loss of data matters, the caller I<must> either "
"check the arguments before the call, or test the function return value.  "
"B<strlcpy>()  is not present in glibc and is not standardized by POSIX, but "
"is available on Linux via the I<libbsd> library."
msgstr ""

#. type: Plain text
#: build/C/man3/strcpy.3:194
msgid ""
"If the destination string of a B<strcpy>()  is not large enough, then "
"anything might happen.  Overflowing fixed-length string buffers is a "
"favorite cracker technique for taking complete control of the machine.  Any "
"time a program reads or copies data into a buffer, the program first needs "
"to check that there's enough space.  This may be unnecessary if you can show "
"that overflow is impossible, but be careful: programs can get changed over "
"time, in ways that may make the impossible possible."
msgstr ""
"B<strcpy>()  の受け側の文字列が十分な大きさでない場合、何が起こるかわからな"
"い。 固定長文字列を溢れさせるのは、マシンの制御を掌中に収めるために クラッ"
"カーが好んで使うテクニックである。 プログラムでデータをバッファに読み込んだり"
"コピーしたりする場合には、 必ずまず最初に十分な大きさがあるかどうかをチェック"
"する必要がある。 プログラマがオーバーフローが不可能だと示せる場合には この"
"チェックは不要かもしれないが、十分注意すること。 長い間には、不可能だったこと"
"が可能になるような方法でプログラムが 変更されることもあるからだ。"

#. type: Plain text
#: build/C/man3/strcpy.3:205
msgid ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"
msgstr ""
"B<bcopy>(3), B<memccpy>(3), B<memcpy>(3), B<memmove>(3), B<stpcpy>(3), "
"B<stpncpy>(3), B<strdup>(3), B<string>(3), B<wcscpy>(3), B<wcsncpy>(3)"

#. type: TH
#: build/C/man3/strdup.3:31
#, no-wrap
msgid "STRDUP"
msgstr "STRDUP"

#. type: Plain text
#: build/C/man3/strdup.3:34
msgid "strdup, strndup, strdupa, strndupa - duplicate a string"
msgstr "strdup, strndup, strdupa, strndupa - 文字列を複製する"

#. type: Plain text
#: build/C/man3/strdup.3:39 build/C/man3/string.3:65
#, no-wrap
msgid "B<char *strdup(const char *>I<s>B<);>\n"
msgstr "B<char *strdup(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/strdup.3:41
#, no-wrap
msgid "B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strndup(const char *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strdup.3:43
#, no-wrap
msgid "B<char *strdupa(const char *>I<s>B<);>\n"
msgstr "B<char *strdupa(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/strdup.3:45
#, no-wrap
msgid "B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"
msgstr "B<char *strndupa(const char *>I<s>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/strdup.3:55
msgid "B<strdup>():"
msgstr "B<strdup>():"

#. type: Plain text
#: build/C/man3/strdup.3:58
msgid ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"_SVID_SOURCE || _BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE"
"\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/strdup.3:60
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: build/C/man3/strdup.3:63
msgid "B<strndup>():"
msgstr "B<strndup>():"

#. type: Plain text
#: build/C/man3/strdup.3:67
msgid "POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"
msgstr "POSIX_C_SOURCE\\ E<gt>=\\ 200809L || _XOPEN_SOURCE\\ E<gt>=\\ 700"

#. type: Plain text
#: build/C/man3/strdup.3:75
msgid "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"
msgstr "B<strdupa>(), B<strndupa>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/strdup.3:87
msgid ""
"The B<strdup>()  function returns a pointer to a new string which is a "
"duplicate of the string I<s>.  Memory for the new string is obtained with "
"B<malloc>(3), and can be freed with B<free>(3)."
msgstr ""
"B<strdup>()  関数は、文字列 I<s>の複製である 新しい文字列へのポインタを返"
"す。 新しい文字列のためのメモリは B<malloc>(3)  で得ている。 そして、 B<free>"
"(3)  で解放することができる。"

#. type: Plain text
#: build/C/man3/strdup.3:94
msgid ""
"The B<strndup>()  function is similar, but only copies at most I<n> bytes.  "
"If I<s> is longer than I<n>, only I<n> bytes are copied, and a terminating "
"null byte (\\(aq\\e0\\(aq) is added."
msgstr ""
"B<strndup>() 関数は同様であるが、最大で I<n> バイトだけを複製する。\n"
"I<s> が I<n> よりも長い場合、I<n> バイトだけが複製され、\n"
"終端の NULL バイト (\\(aq\\e0\\(aq)) が追加される。"

#. type: Plain text
#: build/C/man3/strdup.3:104
msgid ""
"B<strdupa>()  and B<strndupa>()  are similar, but use B<alloca>(3)  to "
"allocate the buffer.  They are only available when using the GNU GCC suite, "
"and suffer from the same limitations described in B<alloca>(3)."
msgstr ""
"B<strdupa>() と B<strndupa>() も同様だが、バッファの確保に\n"
"B<alloca>(3) を使用する点が異なる。\n"
"これらが使用できるのは GNU GCC ツール群を使う場合だけであり、\n"
"B<alloca>(3) で説明されているのと同じ制限がある。"

#. type: Plain text
#: build/C/man3/strdup.3:109
msgid ""
"The B<strdup>()  function returns a pointer to the duplicated string, or "
"NULL if insufficient memory was available."
msgstr ""
"B<strdup>()  関数は複製された文字列へのポインタ、または 十分なメモリが確保で"
"きなかった場合にはNULLを返す。"

#. type: SH
#: build/C/man3/strdup.3:109 build/C/man3/strerror.3:166
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/strdup.3:110
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/strdup.3:113
msgid "Insufficient memory available to allocate duplicate string."
msgstr "複製された文字列を割り当てる十分なメモリが確保できなかった。"

#.  4.3BSD-Reno, not (first) 4.3BSD.
#. type: Plain text
#: build/C/man3/strdup.3:123
msgid ""
"B<strdup>()  conforms to SVr4, 4.3BSD, POSIX.1-2001.  B<strndup>()  conforms "
"to POSIX.1-2008.  B<strdupa>()  and B<strndupa>()  are GNU extensions."
msgstr ""
"B<strdup>()  は SVr4, 4.3BSD, POSIX.1-2001 準拠である。 B<strndup>()  は "
"POSIX.1-2008 準拠である。 B<strdupa>(), B<strndupa>()  は GNU 拡張である。"

#. type: Plain text
#: build/C/man3/strdup.3:131
msgid ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"
msgstr ""
"B<alloca>(3), B<calloc>(3), B<free>(3), B<malloc>(3), B<realloc>(3), "
"B<string>(3), B<wcsdup>(3)"

#. type: TH
#: build/C/man3/strerror.3:39
#, no-wrap
msgid "STRERROR"
msgstr "STRERROR"

#. type: TH
#: build/C/man3/strerror.3:39
#, no-wrap
msgid "2012-04-22"
msgstr "2012-04-22"

#. type: Plain text
#: build/C/man3/strerror.3:42
msgid "strerror, strerror_r - return string describing error number"
msgstr "strerror, strerror_r - エラー番号を説明する文字列を返す。"

#. type: Plain text
#: build/C/man3/strerror.3:47
#, no-wrap
msgid "B<char *strerror(int >I<errnum>B<);>\n"
msgstr "B<char *strerror(int >I<errnum>B<);>\n"

#. type: Plain text
#: build/C/man3/strerror.3:50
#, no-wrap
msgid ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"
msgstr ""
"B<int strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* XSI-compliant */\n"

#. type: Plain text
#: build/C/man3/strerror.3:53
#, no-wrap
msgid ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* GNU-specific */\n"
msgstr ""
"B<char *strerror_r(int >I<errnum>B<, char *>I<buf>B<, size_t >I<buflen>B<);>\n"
"            /* GNU-specific */\n"

#. type: Plain text
#: build/C/man3/strerror.3:63
msgid "The XSI-compliant version of B<strerror_r>()  is provided if:"
msgstr "次の場合には XSI 準拠のバージョンの B<strerror_r>()  が提供される:"

#. type: Plain text
#: build/C/man3/strerror.3:65
msgid ""
"(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600) && !\\ "
"_GNU_SOURCE"
msgstr ""
"(_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600) && !\\ "
"_GNU_SOURCE"

#. type: Plain text
#: build/C/man3/strerror.3:67
msgid "Otherwise, the GNU-specific version is provided."
msgstr "それ以外の場合、GNU バージョンが提供される。"

#. type: Plain text
#: build/C/man3/strerror.3:87
msgid ""
"The B<strerror>()  function returns a pointer to a string that describes the "
"error code passed in the argument I<errnum>, possibly using the "
"B<LC_MESSAGES> part of the current locale to select the appropriate "
"language.  (For example, if I<errnum> is B<EINVAL>, the returned description "
"will \"Invalid argument\".)  This string must not be modified by the "
"application, but may be modified by a subsequent call to B<strerror>().  No "
"library function, including B<perror>(3), will modify this string."
msgstr ""
"B<strerror>() 関数は、引き数 I<errnum> で渡されたエラーコードについての\n"
"説明が入った文字列へのポインタを返す。 可能であるならば、適切な言語を選\n"
"択するために、 現在のロケールの B<LC_MESSAGES> を使う。(例えば、\n"
"I<errnum> が B<EINVAL> の場合、説明として\"Invalid argument\" が返され\n"
"る。) この文字列は、アプリケーションで変更してはならないが、 これ以降に\n"
"行われる B<strerror>() の呼び出しで 変更されても構わない。この文字列を\n"
"変更するライブラリ関数はない (B<perror>(3) も含まれる)。"

#. type: Plain text
#: build/C/man3/strerror.3:108
msgid ""
"The B<strerror_r>()  function is similar to B<strerror>(), but is thread "
"safe.  This function is available in two versions: an XSI-compliant version "
"specified in POSIX.1-2001 (available since glibc 2.3.4, but not POSIX-"
"compliant until glibc 2.13), and a GNU-specific version (available since "
"glibc 2.0).  The XSI-compliant version is provided with the feature test "
"macros settings shown in the SYNOPSIS; otherwise the GNU-specific version is "
"provided.  If no feature test macros are explicitly defined, then (since "
"glibc 2.4)  B<_POSIX_SOURCE> is defined by default with the value 200112L, "
"so that the XSI-compliant version of B<strerror_r>()  is provided by default."
msgstr ""
"B<strerror_r>() 関数は B<strerror>() と似ているが、スレッドセーフである。\n"
"この関数には二種類のバージョンが存在し、 POSIX.1-2001 で規定された XSI\n"
"準拠のバージョン (glibc 2.3.4 以降で利用可能だが、glibc 2.13 までは\n"
"POSIX 準拠ではない) と、 GNU 仕様のバージョン (glibc 2.0 以降で利用可能)\n"
"である。 「書式」の節に記載された機能検査マクロの場合には、 XSI 準拠の\n"
"バージョンが提供される。それ以外の場合には GNU 仕様のバージョンが提供さ\n"
"れる。機能検査マクロが一つも明示的に定義されない場合、 (glibc 2.4 以降\n"
"では) デフォルトで B<_POSIX_SOURCE> は値 200112l で定義され、その結果\n"
"XSI 準拠のバージョンの B<strerror_r>() がデフォルトで提供される。"

#. type: Plain text
#: build/C/man3/strerror.3:116
msgid ""
"The XSI-compliant B<strerror_r>()  is preferred for portable applications.  "
"It returns the error string in the user-supplied buffer I<buf> of length "
"I<buflen>."
msgstr ""
"移植性が必要なアプリケーションでは、 XSI 準拠の B<strerror_r>()  を使う方がよ"
"い。 この関数は、ユーザーから提供される長さ I<buflen> のバッファ I<buf> にエ"
"ラー文字列を返す。"

#. type: Plain text
#: build/C/man3/strerror.3:136
msgid ""
"The GNU-specific B<strerror_r>()  returns a pointer to a string containing "
"the error message.  This may be either a pointer to a string that the "
"function stores in I<buf>, or a pointer to some (immutable) static string "
"(in which case I<buf> is unused).  If the function stores a string in "
"I<buf>, then at most I<buflen> bytes are stored (the string may be truncated "
"if I<buflen> is too small and I<errnum> is unknown).  The string always "
"includes a terminating null byte."
msgstr ""
"GNU 仕様の B<strerror_r>() は、エラーメッセージを格納した文字列へのポイ\n"
"ンタを返す。返り値は、この関数が I<buf> に格納した文字列へのポインタか、\n"
"何らかの (不変な) 静的な文字列へのポインタ、のいずれかとなる (後者の場\n"
"合は I<buf> は使用されない)。 I<buf> に文字列が格納される場合は、最大で\n"
"I<buflen> バイトが格納される (I<buflen> が小さ過ぎたときには文字列は切\n"
"り詰められ、 I<errnum> は不定である)。文字列には必ず終端ヌル文字が含ま\n"
"れる。"

#. type: Plain text
#: build/C/man3/strerror.3:144
msgid ""
"The B<strerror>()  and the GNU-specific B<strerror_r>()  functions return "
"the appropriate error description string, or an \"Unknown error nnn\" "
"message if the error number is unknown."
msgstr ""
"B<strerror>()  と B<strerror_r>()  はエラー内容を説明する 文字列を返す。エ"
"ラー番号が未知の場合は \"Unknown error nnn\" という メッセージを返す。"

#. type: Plain text
#: build/C/man3/strerror.3:157
#, fuzzy
#| msgid ""
#| "POSIX.1-2001 and POSIX.1-2008 require that a successful call to "
#| "B<strerror>(3)  shall leave I<errno> unchanged, and note that, since no "
#| "function return value is reserved to indicate an error, an application "
#| "that wishes to check for errors should initialize I<errno> to zero before "
#| "the call, and then check I<errno> after the call."
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that a successful call to B<strerror>"
"()  shall leave I<errno> unchanged, and note that, since no function return "
"value is reserved to indicate an error, an application that wishes to check "
"for errors should initialize I<errno> to zero before the call, and then "
"check I<errno> after the call."
msgstr ""
"POSIX.1-2001 と POSIX.1-2008 では、 B<strerror>(3) が成功した場合は\n"
"I<errno> を変更せずに元のままにしなければならないとされている。関数のど\n"
"の返り値もエラーを示すために予約されていないので、エラーをチェックした\n"
"いアプリケーションは呼び出しを行う前に I<errno> を 0 に初期化し、呼び出\n"
"しの後で I<errno> をチェックすべき点に注意すること。"

#. type: Plain text
#: build/C/man3/strerror.3:166
msgid ""
"The XSI-compliant B<strerror_r>()  function returns 0 on success.  On error, "
"a (positive) error number is returned (since glibc 2.13), or -1 is returned "
"and I<errno> is set to indicate the error (glibc versions before 2.13)."
msgstr ""
"XSI 準拠の B<strerror_r>() 関数は成功すると 0 を返す。エラーの場合には、\n"
"(glibc 2.13 以降では) (正の) エラー番号が返され、(バージョン 2.13 より前\n"
"の glibc では) -1 が返され、 I<errno> にエラーを示す値がセットされる。"

#. type: TP
#: build/C/man3/strerror.3:167
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/strerror.3:172
msgid "The value of I<errnum> is not a valid error number."
msgstr "I<errnum> の値が有効なエラー番号ではない。"

#. type: TP
#: build/C/man3/strerror.3:172
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man3/strerror.3:175
msgid ""
"Insufficient storage was supplied to contain the error description string."
msgstr "エラーコードを説明する文字列のために、充分な領域が確保できなかった。"

#. type: Plain text
#: build/C/man3/strerror.3:180
msgid ""
"B<strerror>()  is specified by POSIX.1-2001, C89, C99.  B<strerror_r>()  is "
"specified by POSIX.1-2001."
msgstr ""
"B<strerror>()  は POSIX.1-2001, C89, C99 で規定されている。 B<strerror_r>()  "
"は POSIX.1-2001 で規定されている。"

#. type: Plain text
#: build/C/man3/strerror.3:184
msgid "The GNU-specific B<strerror_r>()  function is a nonstandard extension."
msgstr "GNU 仕様の B<strerror_r>()  関数は非標準の拡張である。"

#.  e.g., Solaris 8, HP-UX 11
#.  e.g., FreeBSD 5.4, Tru64 5.1B
#. type: Plain text
#: build/C/man3/strerror.3:204
msgid ""
"POSIX.1-2001 permits B<strerror>()  to set I<errno> if the call encounters "
"an error, but does not specify what value should be returned as the function "
"result in the event of an error.  On some systems, B<strerror>()  returns "
"NULL if the error number is unknown.  On other systems, B<strerror>()  "
"returns a string something like \"Error nnn occurred\" and sets I<errno> to "
"B<EINVAL> if the error number is unknown.  C99 and POSIX.1-2008 require the "
"return value to be non-NULL."
msgstr ""
"POSIX.1-2001 は、 B<strerror>() がエラーに遭遇した場合に I<errno> をセッ\n"
"トすることを認めているが、エラー発生時に関数の結果として どんな値を返す\n"
"べきかを規定してない。 あるシステムでは、 エラー番号が未知の場合、\n"
"B<strerror>() は NULL を返す。 他のシステムでは、 エラー番号が未知の場\n"
"合、 B<strerror>() は \"Error nnn occurred\" といった文字列を返し、\n"
"I<errno> に B<EINVAL> をセットする。 C99 と POSIX.1-2008 では、返り値が\n"
"NULL 以外になることが求められている。"

#. type: Plain text
#: build/C/man3/strerror.3:210
msgid "B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3)"
msgstr "B<err>(3), B<errno>(3), B<error>(3), B<perror>(3), B<strsignal>(3)"

#. type: TH
#: build/C/man3/strfry.3:30
#, no-wrap
msgid "STRFRY"
msgstr "STRFRY"

#. type: Plain text
#: build/C/man3/strfry.3:33
msgid "strfry - randomize a string"
msgstr "strfry - 文字列をランダムに並べ変える"

#. type: Plain text
#: build/C/man3/strfry.3:40 build/C/man3/string.3:67
#, no-wrap
msgid "B<char *strfry(char *>I<string>B<);>\n"
msgstr "B<char *strfry(char *>I<string>B<);>\n"

#. type: Plain text
#: build/C/man3/strfry.3:49
msgid ""
"The B<strfry>()  function randomizes the contents of I<string> by using "
"B<rand>(3)  to randomly swap characters in the string.  The result is an "
"anagram of I<string>."
msgstr ""
"B<strfry>()  関数は、文字列 I<string> の内容をランダムに並び換える。 並び換え"
"は、 B<rand>(3)  関数を用いて、文字列中の各文字を無作為に 交換することで実現"
"される。結果は、文字列 I<string> のアナグラムである。"

#. type: Plain text
#: build/C/man3/strfry.3:54
msgid "The B<strfry>()  functions returns a pointer to the randomized string."
msgstr ""
"B<strfry>()  関数は、ランダムに並び換えられた文字列へのポインタを返す。"

#. type: Plain text
#: build/C/man3/strfry.3:59
msgid "The B<strfry>()  function is unique to the GNU C Library."
msgstr "B<strfry>()  関数は GNU C ライブラリに特有である。"

#. type: Plain text
#: build/C/man3/strfry.3:62
msgid "B<memfrob>(3), B<string>(3)"
msgstr "B<memfrob>(3), B<string>(3)"

#. type: TH
#: build/C/man3/string.3:30
#, no-wrap
msgid "STRING"
msgstr "STRING"

#. type: TH
#: build/C/man3/string.3:30
#, no-wrap
msgid "2010-02-25"
msgstr "2010-02-25"

#. type: Plain text
#: build/C/man3/string.3:36
msgid ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - string "
"operations"
msgstr ""
"stpcpy, strcasecmp, strcat, strchr, strcmp, strcoll, strcpy, strcspn, "
"strdup, strfry, strlen, strncat, strncmp, strncpy, strncasecmp, strpbrk, "
"strrchr, strsep, strspn, strstr, strtok, strxfrm, index, rindex - 文字列を操"
"作する関数"

#. type: Plain text
#: build/C/man3/string.3:63 build/C/man3/strspn.3:40
#, no-wrap
msgid "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"
msgstr "B<size_t strcspn(const char *>I<s>B<, const char *>I<reject>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:69 build/C/man3/strlen.3:38
#, no-wrap
msgid "B<size_t strlen(const char *>I<s>B<);>\n"
msgstr "B<size_t strlen(const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:77 build/C/man3/strpbrk.3:38
#, no-wrap
msgid "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<char *strpbrk(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:81 build/C/man3/strsep.3:41
#, no-wrap
msgid "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strsep(char **>I<stringp>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:83 build/C/man3/strspn.3:38
#, no-wrap
msgid "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"
msgstr "B<size_t strspn(const char *>I<s>B<, const char *>I<accept>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:85 build/C/man3/strstr.3:41
#, no-wrap
msgid "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strstr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:87
#, no-wrap
msgid "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strtok(char *>I<s>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:89 build/C/man3/strxfrm.3:38
#, no-wrap
msgid "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"
msgstr "B<size_t strxfrm(char *>I<dest>B<, const char *>I<src>B<, size_t >I<n>B<);>\n"

#. type: Plain text
#: build/C/man3/string.3:94
msgid ""
"The string functions perform string operations on null-terminated strings.  "
"See the individual man pages for descriptions of each function."
msgstr ""
"文字列関数は、NULL 終端された文字列に 対して、文字列操作を実行する。 それぞれ"
"の関数の説明については個々のmanページを見よ。"

#. type: Plain text
#: build/C/man3/string.3:119
msgid ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"
msgstr ""
"B<index>(3), B<rindex>(3), B<stpcpy>(3), B<strcasecmp>(3), B<strcat>(3), "
"B<strchr>(3), B<strcmp>(3), B<strcoll>(3), B<strcpy>(3), B<strcspn>(3), "
"B<strdup>(3), B<strfry>(3), B<strlen>(3), B<strncasecmp>(3), B<strncat>(3), "
"B<strncmp>(3), B<strncpy>(3), B<strpbrk>(3), B<strrchr>(3), B<strsep>(3), "
"B<strspn>(3), B<strstr>(3), B<strtok>(3), B<strxfrm>(3)"

#. type: TH
#: build/C/man3/strlen.3:30
#, no-wrap
msgid "STRLEN"
msgstr "STRLEN"

#. type: TH
#: build/C/man3/strlen.3:30
#, no-wrap
msgid "2012-05-04"
msgstr "2012-05-04"

#. type: Plain text
#: build/C/man3/strlen.3:33
msgid "strlen - calculate the length of a string"
msgstr "strlen - 文字列の長さを計算する"

#. type: Plain text
#: build/C/man3/strlen.3:44
msgid ""
"The B<strlen>()  function calculates the length of the string I<s>, "
"excluding the terminating null byte (\\(aq\\e0\\(aq)."
msgstr ""
"B<strlen>()  関数は文字列 I<s> の長さを計算する。 このとき、終端 NULL バイト "
"(\\(aq\\e0\\(aq) は計算に含まれない。"

#. type: Plain text
#: build/C/man3/strlen.3:48
msgid ""
"The B<strlen>()  function returns the number of bytes in the string I<s>."
msgstr "B<strlen>() 関数は文字列 I<s> のバイト数を返す。"

#. type: Plain text
#: build/C/man3/strlen.3:55
msgid "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"
msgstr "B<string>(3), B<strnlen>(3), B<wcslen>(3), B<wcsnlen>(3)"

#. type: TH
#: build/C/man3/strnlen.3:13
#, no-wrap
msgid "STRNLEN"
msgstr "STRNLEN"

#. type: Plain text
#: build/C/man3/strnlen.3:16
msgid "strnlen - determine the length of a fixed-size string"
msgstr "strnlen - 固定長の文字列の長さを調べる"

#. type: Plain text
#: build/C/man3/strnlen.3:21
#, no-wrap
msgid "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"
msgstr "B<size_t strnlen(const char *>I<s>B<, size_t >I<maxlen>B<);>\n"

#. type: Plain text
#: build/C/man3/strnlen.3:29
msgid "B<strnlen>():"
msgstr "B<strnlen>():"

#. type: Plain text
#: build/C/man3/strnlen.3:51
msgid ""
"The B<strnlen>()  function returns the number of bytes in the string pointed "
"to by I<s>, excluding the terminating null bye (\\(aq\\e0\\(aq), but at most "
"I<maxlen>.  In doing this, B<strnlen>()  looks only at the first I<maxlen> "
"bytes at I<s> and never beyond I<s+maxlen>."
msgstr ""
"B<strnlen>() 関数は I<s> が指す文字列の長さをバイト数で返す。 長さには\n"
"終端の NULL バイト (\\(aq\\e0\\(aq) は含まない。 また長さは最大で\n"
"I<maxlen> までであり、 B<strnlen>() は I<s> の最初の I<maxlen> バイト\n"
"のみを検査し I<s+maxlen> より先を検査することはない。"

#. type: Plain text
#: build/C/man3/strnlen.3:58
msgid ""
"The B<strnlen>()  function returns I<strlen(s)>, if that is less than "
"I<maxlen>, or I<maxlen> if there is no null byte (\\(aq\\e0\\(aq) among the "
"first I<maxlen> bytes pointed to by I<s>."
msgstr ""
"B<strnlen>() 関数は I<maxlen> 以下ならば I<strlen(s)> と同じ値を返す。\n"
"I<s> の指す文字列が最大 I<maxlen> バイトまでに NULL バイト\n"
"(\\(aq\\e0\\(aq) 文字を含まない場合には I<maxlen> を返す。"

#. type: Plain text
#: build/C/man3/strnlen.3:60
msgid "POSIX.1-2008."
msgstr "POSIX.1-2008."

#. type: Plain text
#: build/C/man3/strnlen.3:62
msgid "B<strlen>(3)"
msgstr "B<strlen>(3)"

#. type: TH
#: build/C/man3/strpbrk.3:30
#, no-wrap
msgid "STRPBRK"
msgstr "STRPBRK"

#. type: Plain text
#: build/C/man3/strpbrk.3:33
msgid "strpbrk - search a string for any of a set of bytes"
msgstr "strpbrk - 文字列からバイト集合に含まれるバイトを探す"

#. type: Plain text
#: build/C/man3/strpbrk.3:44
msgid ""
"The B<strpbrk>()  function locates the first occurrence in the string I<s> "
"of any of the bytes in the string I<accept>."
msgstr ""
"B<strpbrk>() 関数は、文字列 I<accept> に含まれるバイトのいずれかが、\n"
"文字列 I<s> 内で最初に現れる位置を特定する。"

#. type: Plain text
#: build/C/man3/strpbrk.3:50
msgid ""
"The B<strpbrk>()  function returns a pointer to the byte in I<s> that "
"matches one of the bytes in I<accept>, or NULL if no such byte is found."
msgstr ""
"B<strpbrk>() 関数は、I<s> 内のバイトで、I<accept> に含まれる\n"
"バイトのいずれかに一致したバイトへのポインタを返す。\n"
"I<accept> に含まれるバイトが見つからなかった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/strpbrk.3:63
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strsep>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3), B<wcspbrk>(3)"

#. type: TH
#: build/C/man3/strsep.3:33
#, no-wrap
msgid "STRSEP"
msgstr "STRSEP"

#. type: Plain text
#: build/C/man3/strsep.3:36
msgid "strsep - extract token from string"
msgstr "strsep - 文字列からトークンを取り出す"

#. type: Plain text
#: build/C/man3/strsep.3:50
msgid "B<strsep>(): _BSD_SOURCE"
msgstr "B<strsep>(): _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/strsep.3:63
msgid ""
"If I<*stringp> is NULL, the B<strsep>()  function returns NULL and does "
"nothing else.  Otherwise, this function finds the first token in the string "
"I<*stringp>, where tokens are delimited by symbols in the string I<delim>.  "
"This token is terminated by overwriting the delimiter with a null byte (\\(aq"
"\\e0\\(aq)  and I<*stringp> is updated to point past the token.  In case no "
"delimiter was found, the token is taken to be the entire string I<*stringp>, "
"and I<*stringp> is made NULL."
msgstr ""
"I<*stringp> が NULL の場合、 B<strsep>()  関数は何もせずに NULL を返す。 さも"
"なければ、文字列 I<stringp> を I<delim> に含まれる文字で区切った トークンのう"
"ち最初のものを返す。 トークンは、区切り文字を NULL バイト (\\(aq\\e0\\(aq) で"
"上書きすることで 終端される。 I<*stringp> は切り出されたトークンの次の位置を"
"示すように更新される。 区切り文字が見つからない場合、I<*stringp> 文字列全体が"
"トークンとして 扱われ、I<*stringp> は NULL となる。"

#. type: Plain text
#: build/C/man3/strsep.3:68
msgid ""
"The B<strsep>()  function returns a pointer to the token, that is, it "
"returns the original value of I<*stringp>."
msgstr ""
"B<strsep>()  関数は、トークンへのポインタを返す。 つまり、元の I<*stringp> の"
"値を返す。"

#. type: Plain text
#: build/C/man3/strsep.3:70
msgid "4.4BSD."
msgstr "4.4BSD."

#. type: Plain text
#: build/C/man3/strsep.3:79
msgid ""
"The B<strsep>()  function was introduced as a replacement for B<strtok>(3), "
"since the latter cannot handle empty fields.  However, B<strtok>(3)  "
"conforms to C89/C99 and hence is more portable."
msgstr ""
"B<strsep>()  関数は、 B<strtok>(3)  関数が空のフィールドを 扱えないために、そ"
"の代替品として導入された。 しかしながら、 B<strtok>(3)  関数は C89/C99 に準拠"
"しており、より移植性がある。"

#. type: Plain text
#: build/C/man3/strsep.3:82
msgid "Be cautious when using this function.  If you do use it, note that:"
msgstr ""
"この関数を使う時は注意すること。 もし使うなら、以下のことに注意すること。"

#. type: Plain text
#: build/C/man3/strsep.3:84
msgid "This function modifies its first argument."
msgstr "この関数は最初の引数を変更する。"

#. type: Plain text
#: build/C/man3/strsep.3:86
msgid "This function cannot be used on constant strings."
msgstr "この関数は定数文字列には使えない。"

#. type: Plain text
#: build/C/man3/strsep.3:88
msgid "The identity of the delimiting character is lost."
msgstr "区切り文字自体は失われてしまう。"

#. type: Plain text
#: build/C/man3/strsep.3:98
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strspn>(3), B<strstr>(3), B<strtok>(3)"

#. type: TH
#: build/C/man3/strsignal.3:30
#, no-wrap
msgid "STRSIGNAL"
msgstr "STRSIGNAL"

#. type: TH
#: build/C/man3/strsignal.3:30
#, no-wrap
msgid "2010-09-15"
msgstr "2010-09-15"

#. type: Plain text
#: build/C/man3/strsignal.3:33
msgid "strsignal - return string describing signal"
msgstr "strsignal - シグナルを説明する文字列を返す"

#. type: Plain text
#: build/C/man3/strsignal.3:38
#, no-wrap
msgid "B<char *strsignal(int >I<sig>B<);>\n"
msgstr "B<char *strsignal(int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/strsignal.3:40
#, no-wrap
msgid "B<extern const char * const >I<sys_siglist>B<[];>\n"
msgstr "B<extern const char * const >I<sys_siglist>B<[];>\n"

#. type: Plain text
#: build/C/man3/strsignal.3:48
msgid "B<strsignal>():"
msgstr "B<strsignal>():"

#. type: Plain text
#: build/C/man3/strsignal.3:68
msgid ""
"The B<strsignal>()  function returns a string describing the signal number "
"passed in the argument I<sig>.  The string can only be used until the next "
"call to B<strsignal>()."
msgstr ""
"B<strsignal>()  関数は、引数 I<sig> で渡されたシグナル番号を 説明する文字列を"
"返す。 文字列は、次の B<strsignal>()  が呼ばれるまでの間だけ使用できる。"

#. type: Plain text
#: build/C/man3/strsignal.3:75
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number.  The B<strsignal>()  function should be used if possible "
"instead of this array."
msgstr ""
"配列 I<sys_siglist> はシグナルを説明する文字列を保持しており、 配列へのアクセ"
"スにはシグナル番号を添え字として用いる事ができる。 出来るだけこの配列の代わり"
"に B<strsignal>()  関数を 使うべきである。"

#. type: Plain text
#: build/C/man3/strsignal.3:82
msgid ""
"The B<strsignal>()  function returns the appropriate description string, or "
"an unknown signal message if the signal number is invalid.  On some systems "
"(but not on Linux), a NULL pointer may be returned instead for an invalid "
"signal number."
msgstr ""
"B<strsignal>()  関数は、シグナルの適切な説明を返す。 もしシグナル番号が不正な"
"場合は、未知のシグナル(unknown signal)を示す メッセージを返す。 (Linux はそう"
"ではないが)不正なシグナル番号に対して、 NULL ポインタを 返すシステムもある。"

#. type: Plain text
#: build/C/man3/strsignal.3:85
msgid "POSIX.1-2008.  Present on Solaris and the BSDs."
msgstr "POSIX.1-2008.  Solaris と BSD 系にも存在する。"

#. type: Plain text
#: build/C/man3/strsignal.3:88
msgid "B<psignal>(3), B<strerror>(3)"
msgstr "B<psignal>(3), B<strerror>(3)"

#. type: TH
#: build/C/man3/strspn.3:30
#, no-wrap
msgid "STRSPN"
msgstr "STRSPN"

#. type: Plain text
#: build/C/man3/strspn.3:33
msgid "strspn, strcspn - search a string for a set of bytes"
msgstr "strspn, strcspn - バイト集合で構成される文字列を探す"

#. type: Plain text
#: build/C/man3/strspn.3:47
msgid ""
"The B<strspn>()  function calculates the length (in bytes) of the initial "
"segment of I<s> which consists entirely of bytes in I<accept>."
msgstr ""
"B<strspn>() 関数は、 I<s> から、I<accept> に含まれる文字だけで\n"
"構成される最初の部分文字列を探し、\n"
"その部分の (バイト単位の) 長さを計算する。"

#. type: Plain text
#: build/C/man3/strspn.3:53
msgid ""
"The B<strcspn>()  function calculates the length of the initial segment of "
"I<s> which consists entirely of bytes not in I<reject>."
msgstr ""
"B<strcspn>() 関数は、 I<s> から、I<reject> に含まれない文字だけで\n"
"構成される最初の部分文字列を探し、\n"
"その部分の (バイト単位の) 長さを計算する。"

#. type: Plain text
#: build/C/man3/strspn.3:59
msgid ""
"The B<strspn>()  function returns the number of bytes in the initial segment "
"of I<s> which consist only of bytes from I<accept>."
msgstr ""
"B<strspn>() 関数は、 I<s> 内の、I<accept> からの文字だけで\n"
"構成される最初の部分文字列のバイト数を返す。"

#. type: Plain text
#: build/C/man3/strspn.3:65
msgid ""
"The B<strcspn>()  function returns the number of bytes in the initial "
"segment of I<s> which are not in the string I<reject>."
msgstr ""
"B<strcspn>() 関数は、I<s> 内の、文字列 I<reject> に含まれない\n"
"文字だけで構成される最初の部分文字列のバイト数を返す。"

#. type: Plain text
#: build/C/man3/strspn.3:79
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strstr>(3), B<strtok>(3), B<wcscspn>(3), "
"B<wcsspn>(3)"

#. type: TH
#: build/C/man3/strstr.3:33
#, no-wrap
msgid "STRSTR"
msgstr "STRSTR"

#. type: Plain text
#: build/C/man3/strstr.3:36
msgid "strstr, strcasestr - locate a substring"
msgstr "strstr, strcasestr - 部分文字列の位置を示す"

#. type: Plain text
#: build/C/man3/strstr.3:47
#, no-wrap
msgid "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"
msgstr "B<char *strcasestr(const char *>I<haystack>B<, const char *>I<needle>B<);>\n"

#. type: Plain text
#: build/C/man3/strstr.3:54
msgid ""
"The B<strstr>()  function finds the first occurrence of the substring "
"I<needle> in the string I<haystack>.  The terminating null bytes (\\(aq"
"\\e0\\(aq) are not compared."
msgstr ""
"B<strstr>()  関数は、部分文字列 I<needle> が文字列 I<haystack> 中 で最初に現"
"れる位置を見つける。 文字列を終端 NULL バイト (\\(aq\\e0\\(aq) は比較されな"
"い。"

#. type: Plain text
#: build/C/man3/strstr.3:60
msgid ""
"The B<strcasestr>()  function is like B<strstr>(), but ignores the case of "
"both arguments."
msgstr ""
"B<strcasestr>()  関数は B<strstr>()  関数と同様だが、 両方の引数に対して大文"
"字小文字を無視する。"

#. type: Plain text
#: build/C/man3/strstr.3:63
msgid ""
"These functions return a pointer to the beginning of the substring, or NULL "
"if the substring is not found."
msgstr ""
"これらの関数は、部分文字列の開始を指すポインタを返し、 もし部分文字列が見つか"
"らない場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/strstr.3:70
msgid ""
"The B<strstr>()  function conforms to C89 and C99.  The B<strcasestr>()  "
"function is a nonstandard extension."
msgstr ""
"B<strstr>()  関数は C89 と C99 に準拠している。 B<strcasestr>()  関数は非標準"
"拡張である。"

#. type: Plain text
#: build/C/man3/strstr.3:76
msgid ""
"Early versions of Linux libc (like 4.5.26) would not allow an empty "
"I<needle> argument for B<strstr>().  Later versions (like 4.6.27) work "
"correctly, and return I<haystack> when I<needle> is empty."
msgstr ""
"Linux libc の初期のバージョン(4.5.26 まで)は B<strstr>()  関数の I<needle> 引"
"数に空文字列を指定できない。 最近のバージョン(4.6.27 以降)は正しく動作し、 "
"I<needle> が空の時は I<haystack> を返す。"

#. type: Plain text
#: build/C/man3/strstr.3:88
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strcasecmp>(3), B<strchr>(3), "
"B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strtok>(3), "
"B<wcsstr>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strcasecmp>(3), B<strchr>(3), "
"B<string>(3), B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strtok>(3), "
"B<wcsstr>(3)"

#. type: TH
#: build/C/man3/strtok.3:30
#, no-wrap
msgid "STRTOK"
msgstr "STRTOK"

#. type: Plain text
#: build/C/man3/strtok.3:33
msgid "strtok, strtok_r - extract tokens from strings"
msgstr "strtok, strtok_r - 文字列からトークンを取り出す"

#. type: Plain text
#: build/C/man3/strtok.3:38
#, no-wrap
msgid "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"
msgstr "B<char *strtok(char *>I<str>B<, const char *>I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/strtok.3:40
#, no-wrap
msgid "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"
msgstr "B<char *strtok_r(char *>I<str>B<, const char *>I<delim>B<, char **>I<saveptr>B<);>\n"

#. type: Plain text
#: build/C/man3/strtok.3:51
msgid ""
"B<strtok_r>(): _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 1 "
"|| _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<strtok_r>(): _SVID_SOURCE || _BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 1 "
"|| _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/strtok.3:62
msgid ""
"The B<strtok>()  function parses a string into a sequence of tokens.  On the "
"first call to B<strtok>()  the string to be parsed should be specified in "
"I<str>.  In each subsequent call that should parse the same string, I<str> "
"should be NULL."
msgstr ""
"B<strtok>()  関数は文字列を解析してトークンに分割する。 B<strtok>()  を最初に"
"呼び出す際には、解析対象の文字列を I<str> に 指定する。同じ文字列の解析を行う"
"その後の呼び出しでは、 I<str> には NULL を指定する。"

#. type: Plain text
#: build/C/man3/strtok.3:67
msgid ""
"The I<delim> argument specifies a set of bytes that delimit the tokens in "
"the parsed string.  The caller may specify different strings in I<delim> in "
"successive calls that parse the same string."
msgstr ""
"I<delim> 引き数には、解析対象の文字列をトークンに区切るのに使用する\n"
"バイト集合を指定する。同じ文字列を解析する一連の呼び出しにおいて、\n"
"I<delim> に違う文字列を指定してもよい。"

#. type: Plain text
#: build/C/man3/strtok.3:76
msgid ""
"Each call to B<strtok>()  returns a pointer to a null-terminated string "
"containing the next token.  This string does not include the delimiting "
"byte.  If no more tokens are found, B<strtok>()  returns NULL."
msgstr ""
"B<strtok>() のそれぞれの呼び出しでは、次のトークンを格納した NULL 終端\n"
"された文字列へのポインタが返される。この文字列には区切りバイトは含まれ\n"
"ない。これ以上トークンが見つからなかった場合には、NULL が返される。"

#. type: Plain text
#: build/C/man3/strtok.3:83
msgid ""
"A sequence of two or more contiguous delimiter bytes in the parsed string is "
"considered to be a single delimiter.  Delimiter bytes at the start or end of "
"the string are ignored.  Put another way: the tokens returned by B<strtok>"
"()  are always nonempty strings."
msgstr ""
"解析対象の文字列に 2 つ以上の区切りバイトが連続している場合には、\n"
"一つの区切りバイトとみなされる。 文字列の先頭や末尾にある区切りバイトは\n"
"無視される。言い換えると、 B<strtok>() が返すトークンは必ず空でない\n"
"文字列となる。"

#. type: Plain text
#: build/C/man3/strtok.3:93
msgid ""
"The B<strtok_r>()  function is a reentrant version B<strtok>().  The "
"I<saveptr> argument is a pointer to a I<char *> variable that is used "
"internally by B<strtok_r>()  in order to maintain context between successive "
"calls that parse the same string."
msgstr ""
"B<strtok_r>()  関数は B<strtok>()  のリエントラント版である。 I<saveptr> 引き"
"数は I<char *> 変数へのポインタであり、 同じ文字列の解析を行う B<strtok_r>"
"()  の呼び出し間で処理状況を保存するために B<strtok_r>()  内部で使用される。"

#. type: Plain text
#: build/C/man3/strtok.3:102
msgid ""
"On the first call to B<strtok_r>(), I<str> should point to the string to be "
"parsed, and the value of I<saveptr> is ignored.  In subsequent calls, I<str> "
"should be NULL, and I<saveptr> should be unchanged since the previous call."
msgstr ""
"B<strtok_r>()  を最初に呼び出す際には、 I<str> は解析対象の文字列を指していな"
"ければならず、 I<saveptr> の値は無視される。それ以降の呼び出しでは、 I<str> "
"は NULL とし、 I<saveptr> は前回の呼び出し以降変更しないようにしなければなら"
"ない。"

#. type: Plain text
#: build/C/man3/strtok.3:106
msgid ""
"Different strings may be parsed concurrently using sequences of calls to "
"B<strtok_r>()  that specify different I<saveptr> arguments."
msgstr ""
"B<strtok_r>()  の呼び出し時に異なる I<saveptr> 引き数を指定することで、 異な"
"る文字列の解析を同時に行うことができる。"

#. type: Plain text
#: build/C/man3/strtok.3:113
msgid ""
"The B<strtok>()  and B<strtok_r>()  functions return a pointer to the next "
"token, or NULL if there are no more tokens."
msgstr ""
"B<strtok>()  と B<strtok_r>()  は次のトークンへのポインタか、 トークンがなけ"
"れば NULL を返す。"

#. type: TP
#: build/C/man3/strtok.3:114
#, no-wrap
msgid "B<strtok>()"
msgstr "B<strtok>()"

#. type: Plain text
#: build/C/man3/strtok.3:117
msgid "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."
msgstr "SVr4, POSIX.1-2001, 4.3BSD, C89, C99."

#. type: TP
#: build/C/man3/strtok.3:117
#, no-wrap
msgid "B<strtok_r>()"
msgstr "B<strtok_r>()"

#. type: Plain text
#: build/C/man3/strtok.3:120
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/strtok.3:123
msgid "Be cautious when using these functions.  If you do use them, note that:"
msgstr ""
"これらの関数を使うのは慎重に吟味すること。 使用する場合は、以下の点に注意が必"
"要である。"

#. type: Plain text
#: build/C/man3/strtok.3:125
msgid "These functions modify their first argument."
msgstr "これらの関数はその最初の引数を変更する。"

#. type: Plain text
#: build/C/man3/strtok.3:127
msgid "These functions cannot be used on constant strings."
msgstr "これらの関数は const な文字列では使えない。"

#. type: Plain text
#: build/C/man3/strtok.3:129
msgid "The identity of the delimiting byte is lost."
msgstr "区切りバイト自体は失われてしまう。"

#. type: Plain text
#: build/C/man3/strtok.3:136
msgid ""
"The B<strtok>()  function uses a static buffer while parsing, so it's not "
"thread safe.  Use B<strtok_r>()  if this matters to you."
msgstr ""
"B<strtok>()  関数は文字列の解析に静的バッファを用いるので、スレッドセーフでな"
"い。 これが問題になる場合は B<strtok_r>()  を用いること。"

#. type: Plain text
#: build/C/man3/strtok.3:145
msgid ""
"The program below uses nested loops that employ B<strtok_r>()  to break a "
"string into a two-level hierarchy of tokens.  The first command-line "
"argument specifies the string to be parsed.  The second argument specifies "
"the delimiter byte(s)  to be used to separate that string into \"major\" "
"tokens.  The third argument specifies the delimiter byte(s)  to be used to "
"separate the \"major\" tokens into subtokens."
msgstr ""
"以下のプログラムは、 B<strtok_r>() を利用するループを入れ子にして使用し、\n"
"文字列を 2 階層のトークンに分割するものである。 1番目のコマンドライン\n"
"引き数には、解析対象の文字列を指定する。 2 番目の引き数には、文字列を\n"
"「大きな」トークンに分割するために 使用する区切りバイトを指定する。\n"
"3 番目の引き数には、「大きな」トークンを細かく分割するために使用する\n"
"区切りバイトを指定する。"

#. type: Plain text
#: build/C/man3/strtok.3:147
msgid "An example of the output produced by this program is the following:"
msgstr "このプログラムの出力例を以下に示す。"

#. type: Plain text
#: build/C/man3/strtok.3:159
#, no-wrap
msgid ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"
msgstr ""
"$B< ./a.out \\(aqa/bbb///cc;xxx:yyy:\\(aq \\(aq:;\\(aq \\(aq/\\(aq>\n"
"1: a/bbb///cc\n"
"         --E<gt> a\n"
"         --E<gt> bbb\n"
"         --E<gt> cc\n"
"2: xxx\n"
"         --E<gt> xxx\n"
"3: yyy\n"
"         --E<gt> yyy\n"

#. type: SS
#: build/C/man3/strtok.3:161
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/strtok.3:167
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"

#. type: Plain text
#: build/C/man3/strtok.3:174
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
"    int j;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *str1, *str2, *token, *subtoken;\n"
"    char *saveptr1, *saveptr2;\n"
"    int j;\n"

#. type: Plain text
#: build/C/man3/strtok.3:180
#, no-wrap
msgid ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 4) {\n"
"        fprintf(stderr, \"Usage: %s string delim subdelim\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/strtok.3:186
#, no-wrap
msgid ""
"    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"
msgstr ""
"    for (j = 1, str1 = argv[1]; ; j++, str1 = NULL) {\n"
"        token = strtok_r(str1, argv[2], &saveptr1);\n"
"        if (token == NULL)\n"
"            break;\n"
"        printf(\"%d: %s\\en\", j, token);\n"

#. type: Plain text
#: build/C/man3/strtok.3:194
#, no-wrap
msgid ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"
msgstr ""
"        for (str2 = token; ; str2 = NULL) {\n"
"            subtoken = strtok_r(str2, argv[3], &saveptr2);\n"
"            if (subtoken == NULL)\n"
"                break;\n"
"            printf(\"\\t --E<gt> %s\\en\", subtoken);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/strtok.3:197
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/strtok.3:203
msgid ""
"Another example program using B<strtok>()  can be found in B<getaddrinfo_a>"
"(3)."
msgstr "B<strtok>()  を使った別のプログラム例が B<getaddrinfo_a>(3)  にある。"

#. type: Plain text
#: build/C/man3/strtok.3:214
msgid ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"
msgstr ""
"B<index>(3), B<memchr>(3), B<rindex>(3), B<strchr>(3), B<string>(3), "
"B<strpbrk>(3), B<strsep>(3), B<strspn>(3), B<strstr>(3), B<wcstok>(3)"

#. type: TH
#: build/C/man3/strverscmp.3:25
#, no-wrap
msgid "STRVERSCMP"
msgstr "STRVERSCMP"

#. type: TH
#: build/C/man3/strverscmp.3:25
#, no-wrap
msgid "2001-12-19"
msgstr "2001-12-19"

#. type: Plain text
#: build/C/man3/strverscmp.3:28
msgid "strverscmp - compare two version strings"
msgstr "strverscmp - 2つのバージョン文字列を比較する"

#. type: Plain text
#: build/C/man3/strverscmp.3:35
#, no-wrap
msgid "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"
msgstr "B<int strverscmp(const char *>I<s1>B<, const char *>I<s2>B<);>\n"

#.  classical solution: "rename jan jan0 jan?"
#. type: Plain text
#: build/C/man3/strverscmp.3:52
msgid ""
"Often one has files I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  and it "
"feels wrong when B<ls>(1)  orders them I<jan1>, I<jan10>, ..., I<jan2>, ..., "
"I<jan9>.  In order to rectify this, GNU introduced the I<-v> option to B<ls>"
"(1), which is implemented using B<versionsort>(3), which again uses "
"B<strverscmp>()."
msgstr ""
"I<jan1>, I<jan2>, ..., I<jan9>, I<jan10>, ...  といった名前のファイルがある状"
"況はよくあるが、 B<ls>(1)  を実行したときに I<jan1>, I<jan10>, ..., "
"I<jan2>, ..., I<jan9> の順番で表示されるのには違和感がある。 これを修正するた"
"めに、GNU は B<ls>(1)  に I<-v> オプションを導入した。 この機能は "
"B<versionsort>(3)  を使って実装されているが、この中で B<strverscmp>()  が使用"
"されている。"

#. type: Plain text
#: build/C/man3/strverscmp.3:63
msgid ""
"Thus, the task of B<strverscmp>()  is to compare two strings and find the "
"\"right\" order, while B<strcmp>(3)  only finds the lexicographic order.  "
"This function does not use the locale category B<LC_COLLATE>, so is meant "
"mostly for situations where the strings are expected to be in ASCII."
msgstr ""
"このように B<strverscmp>()  の役目は2つの文字列を比較して「正しい」順序を探す"
"ことである。 これに対して B<strcmp>(3)  は辞書順で比較した結果を返すだけであ"
"る。 関数 B<strverscmp>()  はロケールのカテゴリである B<LC_COLLATE> を使用し"
"ない。 このことから、この関数が主にアスキー文字から成る文字列を 想定している"
"ことが分かる。"

#. type: Plain text
#: build/C/man3/strverscmp.3:81
msgid ""
"What this function does is the following.  If both strings are equal, return "
"0.  Otherwise find the position between two bytes with the property that "
"before it both strings are equal, while directly after it there is a "
"difference.  Find the largest consecutive digit strings containing (or "
"starting at, or ending at) this position.  If one or both of these is empty, "
"then return what B<strcmp>(3)  would have returned (numerical ordering of "
"byte values).  Otherwise, compare both digit strings numerically, where "
"digit strings with one or more leading zeros are interpreted as if they have "
"a decimal point in front (so that in particular digit strings with more "
"leading zeros come before digit strings with fewer leading zeros).  Thus, "
"the ordering is I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, I<1>, I<9>, I<10>."
msgstr ""
"この関数の動作は以下の通りである。 両方の文字列が等しい場合、0 を返す。 それ"
"以外の場合、その直前までは両方の文字列が等しく、 その直後のバイトで両者に違い"
"があるような、バイトの境界を探す。 見つかったバイト境界を含む数字列(数字だけ"
"の文字列)の最長一致検索を行う。 (数字列は境界から始まっていても、境界で終わっ"
"ていてもよい)。 2つの文字列から得られた数字列の一方または両方が空であれば、 "
"B<strcmp>(3)  が返した結果を関数の返り値として返す。 すなわち、バイト値を比較"
"した結果を返す。 それ以外の(数字列が両方とも空でない)場合、両方の数字列を数字"
"順で比較する。 このとき、1つ以上の 0 が先頭にある数字列は、前に小数点がついて"
"いるものと 解釈される。(先頭に 0 が多くある数字列ほど前に来ることになる)  こ"
"の結果、順序は次のようになる: I<000>, I<00>, I<01>, I<010>, I<09>, I<0>, "
"I<1>, I<9>, I<10>"

#. type: Plain text
#: build/C/man3/strverscmp.3:88
msgid ""
"The B<strverscmp>()  function returns an integer less than, equal to, or "
"greater than zero if I<s1> is found, respectively, to be earlier than, equal "
"to, or later than I<s2>."
msgstr ""
"関数 B<strverscmp>()  は、ゼロよりも 1)小さい、2)等しい、3)大きいのいずれかの"
"整数を返す。 それぞれは、I<s1> が I<s2> よりも、 1)小さい、2)等しい、3)大き"
"い ことを示す。"

#. type: Plain text
#: build/C/man3/strverscmp.3:95
msgid "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"
msgstr "B<rename>(1), B<strcasecmp>(3), B<strcmp>(3), B<strcoll>(3)"

#. type: TH
#: build/C/man3/strxfrm.3:30
#, no-wrap
msgid "STRXFRM"
msgstr "STRXFRM"

#. type: Plain text
#: build/C/man3/strxfrm.3:33
msgid "strxfrm - string transformation"
msgstr "strxfrm - 文字列の変換"

#. type: Plain text
#: build/C/man3/strxfrm.3:56
msgid ""
"The B<strxfrm>()  function transforms the I<src> string into a form such "
"that the result of B<strcmp>(3)  on two strings that have been transformed "
"with B<strxfrm>()  is the same as the result of B<strcoll>(3)  on the two "
"strings before their transformation.  The first I<n> bytes of the "
"transformed string are placed in I<dest>.  The transformation is based on "
"the program's current locale for category B<LC_COLLATE>.  (See B<setlocale>"
"(3))."
msgstr ""
"B<strxfrm>() 関数は、文字列 I<src> に対して、次のような変換を行う。\n"
"変換は、ある二つの文字列に対して、それぞれを B<strxfrm>() で変換\n"
"した文字列に対して B<strcmp>(3) を行った結果が、 \n"
"変換を行わずにB<strcoll>(3) を行った結果と同じとなるように行う。\n"
"変換された文字列の先頭から I<n> バイト分が I<dest> に代入される。\n"
"変換は、プログラムの現在のロケールのカテゴリ B<LC_COLLATE> に\n"
"基づいて行われる (B<setlocale>(3) を参照)。"

#. type: Plain text
#: build/C/man3/strxfrm.3:64
msgid ""
"The B<strxfrm>()  function returns the number of bytes required to store the "
"transformed string in I<dest> excluding the terminating null byte (\\(aq"
"\\e0\\(aq).  If the value returned is I<n> or more, the contents of I<dest> "
"are indeterminate."
msgstr ""
"B<strxfrm>()  関数は、変換された文字列を I<dest> に代入するときに 必要なバイ"
"ト数から、終端の NULL バイト (\\(aq\\e0\\(aq) の分を 引いたものを返す。もし返"
"り値が I<n> 以上の場合、 I<dest> の内容は不定となる。"

#. type: Plain text
#: build/C/man3/strxfrm.3:72
msgid ""
"In the I<\"POSIX\"> or I<\"C\"> locales B<strxfrm>()  is equivalent to "
"copying the string with B<strncpy>(3)."
msgstr ""
"I<\"POSIX\"> または I<\"C\"> ロケールでは、関数 B<strxfrm>()  は、 関数 "
"B<strncpy>(3)  を使って文字列をコピーするのと同じである。"

#. type: Plain text
#: build/C/man3/strxfrm.3:80
msgid ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"
msgstr ""
"B<bcmp>(3), B<memcmp>(3), B<setlocale>(3), B<strcasecmp>(3), B<strcmp>(3), "
"B<strcoll>(3), B<string>(3)"

#~ msgid "2011-09-14"
#~ msgstr "2011-09-14"

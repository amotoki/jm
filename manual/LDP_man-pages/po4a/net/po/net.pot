# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:16+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man7/arp.7:9
#, no-wrap
msgid "ARP"
msgstr ""

#. type: TH
#: build/C/man7/arp.7:9
#, no-wrap
msgid "2008-11-25"
msgstr ""

#. type: TH
#: build/C/man7/arp.7:9 build/C/man3/cmsg.3:7 build/C/man7/ddp.7:7 build/C/man1/getent.1:23 build/C/man3/getipnodebyname.3:24 build/C/man2/getpeername.2:40 build/C/man5/host.conf.5:26 build/C/man7/hostname.7:37 build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:3 build/C/man7/icmp.7:7 build/C/man3/inet_ntop.3:24 build/C/man3/inet_pton.3:25 build/C/man7/ip.7:12 build/C/man7/ipv6.7:7 build/C/man7/netdevice.7:15 build/C/man5/nsswitch.conf.5:24 build/C/man7/packet.7:7 build/C/man5/protocols.5:28 build/C/man7/raw.7:9 build/C/man3/rcmd.3:41 build/C/man3/rexec.3:39 build/C/man5/services.5:34 build/C/man2/shutdown.2:38 build/C/man7/tcp.7:16 build/C/man7/udp.7:8 build/C/man7/udplite.7:25 build/C/man7/unix.7:15 build/C/man7/x25.7:7
#, no-wrap
msgid "Linux"
msgstr ""

#. type: TH
#: build/C/man7/arp.7:9 build/C/man3/byteorder.3:30 build/C/man3/cmsg.3:7 build/C/man7/ddp.7:7 build/C/man3/endian.3:26 build/C/man3/ether_aton.3:31 build/C/man3/getaddrinfo.3:41 build/C/man3/getaddrinfo_a.3:27 build/C/man3/gethostbyname.3:36 build/C/man3/getipnodebyname.3:24 build/C/man3/getnameinfo.3:7 build/C/man3/getnetent.3:28 build/C/man3/getnetent_r.3:24 build/C/man2/getpeername.2:40 build/C/man3/getprotoent.3:28 build/C/man3/getprotoent_r.3:24 build/C/man3/getservent.3:32 build/C/man3/getservent_r.3:24 build/C/man7/hostname.7:37 build/C/man5/hosts.5:27 build/C/man5/hosts.equiv.5:3 build/C/man7/icmp.7:7 build/C/man3/inet.3:42 build/C/man3/inet_ntop.3:24 build/C/man3/inet_pton.3:25 build/C/man7/ip.7:12 build/C/man7/ipv6.7:7 build/C/man7/netdevice.7:15 build/C/man8/nscd.8:23 build/C/man5/nscd.conf.5:20 build/C/man5/nsswitch.conf.5:24 build/C/man7/packet.7:7 build/C/man5/protocols.5:28 build/C/man7/raw.7:9 build/C/man3/rcmd.3:41 build/C/man5/resolv.conf.5:21 build/C/man3/resolver.3:30 build/C/man3/rexec.3:39 build/C/man5/services.5:34 build/C/man3/setnetgrent.3:5 build/C/man2/shutdown.2:38 build/C/man7/tcp.7:16 build/C/man7/udp.7:8 build/C/man7/udplite.7:25 build/C/man7/unix.7:15 build/C/man7/x25.7:7
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr ""

#. type: SH
#: build/C/man7/arp.7:10 build/C/man3/byteorder.3:31 build/C/man3/cmsg.3:8 build/C/man7/ddp.7:8 build/C/man3/endian.3:27 build/C/man3/ether_aton.3:32 build/C/man3/getaddrinfo.3:42 build/C/man3/getaddrinfo_a.3:28 build/C/man1/getent.1:24 build/C/man3/gethostbyname.3:37 build/C/man3/getipnodebyname.3:25 build/C/man3/getnameinfo.3:8 build/C/man3/getnetent.3:29 build/C/man3/getnetent_r.3:25 build/C/man2/getpeername.2:41 build/C/man3/getprotoent.3:29 build/C/man3/getprotoent_r.3:25 build/C/man3/getservent.3:33 build/C/man3/getservent_r.3:25 build/C/man5/host.conf.5:27 build/C/man7/hostname.7:38 build/C/man5/hosts.5:28 build/C/man5/hosts.equiv.5:4 build/C/man7/icmp.7:8 build/C/man3/inet.3:43 build/C/man3/inet_ntop.3:25 build/C/man3/inet_pton.3:26 build/C/man7/ip.7:13 build/C/man7/ipv6.7:8 build/C/man7/netdevice.7:16 build/C/man5/networks.5:25 build/C/man8/nscd.8:24 build/C/man5/nscd.conf.5:21 build/C/man5/nsswitch.conf.5:25 build/C/man7/packet.7:8 build/C/man5/protocols.5:29 build/C/man7/raw.7:10 build/C/man3/rcmd.3:42 build/C/man5/resolv.conf.5:23 build/C/man3/resolver.3:31 build/C/man3/rexec.3:40 build/C/man5/services.5:35 build/C/man3/setnetgrent.3:6 build/C/man2/shutdown.2:39 build/C/man7/tcp.7:17 build/C/man7/udp.7:9 build/C/man7/udplite.7:26 build/C/man7/unix.7:16 build/C/man7/x25.7:8
#, no-wrap
msgid "NAME"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:12
msgid "arp - Linux ARP kernel module."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:12 build/C/man3/byteorder.3:46 build/C/man3/cmsg.3:33 build/C/man7/ddp.7:18 build/C/man3/endian.3:51 build/C/man3/ether_aton.3:57 build/C/man3/getaddrinfo.3:73 build/C/man3/getaddrinfo_a.3:48 build/C/man1/getent.1:29 build/C/man3/gethostbyname.3:116 build/C/man3/getipnodebyname.3:42 build/C/man3/getnameinfo.3:29 build/C/man3/getnetent.3:46 build/C/man3/getnetent_r.3:60 build/C/man2/getpeername.2:48 build/C/man3/getprotoent.3:46 build/C/man3/getprotoent_r.3:57 build/C/man3/getservent.3:50 build/C/man3/getservent_r.3:57 build/C/man5/host.conf.5:29 build/C/man7/hostname.7:40 build/C/man5/hosts.5:32 build/C/man5/hosts.equiv.5:7 build/C/man7/icmp.7:10 build/C/man3/inet.3:75 build/C/man3/inet_ntop.3:34 build/C/man3/inet_pton.3:34 build/C/man7/ip.7:29 build/C/man7/ipv6.7:20 build/C/man7/netdevice.7:22 build/C/man5/networks.5:27 build/C/man8/nscd.8:26 build/C/man5/nscd.conf.5:23 build/C/man5/nsswitch.conf.5:27 build/C/man7/packet.7:20 build/C/man5/protocols.5:31 build/C/man7/raw.7:18 build/C/man3/rcmd.3:90 build/C/man5/resolv.conf.5:27 build/C/man3/resolver.3:83 build/C/man3/rexec.3:54 build/C/man5/services.5:37 build/C/man3/setnetgrent.3:39 build/C/man2/shutdown.2:45 build/C/man7/tcp.7:27 build/C/man7/udp.7:17 build/C/man7/udplite.7:36 build/C/man7/unix.7:27 build/C/man7/x25.7:16
#, no-wrap
msgid "DESCRIPTION"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:20
msgid ""
"This kernel protocol module implements the Address Resolution Protocol "
"defined in RFC\\ 826.  It is used to convert between Layer2 hardware "
"addresses and IPv4 protocol addresses on directly connected networks.  The "
"user normally doesn't interact directly with this module except to configure "
"it; instead it provides a service for other protocols in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:33
msgid ""
"A user process can receive ARP packets by using B<packet>(7)  sockets.  "
"There is also a mechanism for managing the ARP cache in user-space by using "
"B<netlink>(7)  sockets.  The ARP table can also be controlled via "
"B<ioctl>(2)  on any B<AF_INET> socket."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:45
msgid ""
"The ARP module maintains a cache of mappings between hardware addresses and "
"protocol addresses.  The cache has a limited size so old and less frequently "
"used entries are garbage-collected.  Entries which are marked as permanent "
"are never deleted by the garbage-collector.  The cache can be directly "
"manipulated by the use of ioctls and its behavior can be tuned by the "
"I</proc> interfaces described below."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:68
msgid ""
"When there is no positive feedback for an existing mapping after some time "
"(see the I</proc> interfaces below), a neighbor cache entry is considered "
"stale.  Positive feedback can be gotten from a higher layer; for example "
"from a successful TCP ACK.  Other protocols can signal forward progress "
"using the B<MSG_CONFIRM> flag to B<sendmsg>(2).  When there is no forward "
"progress, ARP tries to reprobe.  It first tries to ask a local arp daemon "
"B<app_solicit> times for an updated MAC address.  If that fails and an old "
"MAC address is known, a unicast probe is sent B<ucast_solicit> times.  If "
"that fails too, it will broadcast a new ARP request to the network.  "
"Requests are only sent when there is data queued for sending."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:73
msgid ""
"Linux will automatically add a nonpermanent proxy arp entry when it receives "
"a request for an address it forwards to and proxy arp is enabled on the "
"receiving interface.  When there is a reject route for the target, no proxy "
"arp entry is added."
msgstr ""

#. type: SS
#: build/C/man7/arp.7:73 build/C/man7/ddp.7:139 build/C/man7/ip.7:898 build/C/man7/netdevice.7:69 build/C/man7/packet.7:225 build/C/man7/tcp.7:997 build/C/man7/udp.7:192 build/C/man7/unix.7:280
#, no-wrap
msgid "Ioctls"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:80
msgid ""
"Three ioctls are available on all B<AF_INET> sockets.  They take a pointer "
"to a I<struct arpreq> as their argument."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:90
#, no-wrap
msgid ""
"struct arpreq {\n"
"    struct sockaddr arp_pa;      /* protocol address */\n"
"    struct sockaddr arp_ha;      /* hardware address */\n"
"    int             arp_flags;   /* flags */\n"
"    struct sockaddr arp_netmask; /* netmask of protocol address */\n"
"    char            arp_dev[16];\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:99
msgid ""
"B<SIOCSARP>, B<SIOCDARP> and B<SIOCGARP> respectively set, delete and get an "
"ARP mapping.  Setting and deleting ARP maps are privileged operations and "
"may only be performed by a process with the B<CAP_NET_ADMIN> capability or "
"an effective UID of 0."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:109
msgid ""
"I<arp_pa> must be an B<AF_INET> address and I<arp_ha> must have the same "
"type as the device which is specified in I<arp_dev>.  I<arp_dev> is a "
"zero-terminated string which names a device."
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:114
#, no-wrap
msgid "I<arp_flags>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:115
#, no-wrap
msgid "flag:meaning\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:116
#, no-wrap
msgid "ATF_COM:Lookup complete\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:117
#, no-wrap
msgid "ATF_PERM:Permanent entry\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:118
#, no-wrap
msgid "ATF_PUBL:Publish entry\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:119
#, no-wrap
msgid "ATF_USETRAILERS:Trailers requested\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:120
#, no-wrap
msgid "ATF_NETMASK:Use a netmask\n"
msgstr ""

#. type: tbl table
#: build/C/man7/arp.7:121
#, no-wrap
msgid "ATF_DONTPUB:Don't answer\n"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:135
msgid ""
"If the B<ATF_NETMASK> flag is set, then I<arp_netmask> should be valid.  "
"Linux 2.2 does not support proxy network ARP entries, so this should be set "
"to 0xffffffff, or 0 to remove an existing proxy arp entry.  "
"B<ATF_USETRAILERS> is obsolete and should not be used."
msgstr ""

#. type: SS
#: build/C/man7/arp.7:135 build/C/man7/ddp.7:117 build/C/man7/icmp.7:36 build/C/man7/ip.7:774 build/C/man7/tcp.7:159 build/C/man7/udp.7:131
#, no-wrap
msgid "/proc interfaces"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:148
msgid ""
"ARP supports a range of I</proc> interfaces to configure parameters on a "
"global or per-interface basis.  The interfaces can be accessed by reading or "
"writing the I</proc/sys/net/ipv4/neigh/*/*> files.  Each interface in the "
"system has its own directory in I</proc/sys/net/ipv4/neigh/>.  The setting "
"in the \"default\" directory is used for all newly created devices.  Unless "
"otherwise specified, time-related interfaces are specified in seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:148
#, no-wrap
msgid "I<anycast_delay> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:155
msgid ""
"The maximum number of jiffies to delay before replying to a IPv6 neighbor "
"solicitation message.  Anycast support is not yet implemented.  Defaults to "
"1 second."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:155
#, no-wrap
msgid "I<app_solicit> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:162
msgid ""
"The maximum number of probes to send to the user space ARP daemon via "
"netlink before dropping back to multicast probes (see I<mcast_solicit>).  "
"Defaults to 0."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:162
#, no-wrap
msgid "I<base_reachable_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:173
msgid ""
"Once a neighbor has been found, the entry is considered to be valid for at "
"least a random value between I<base_reachable_time>/2 and "
"3*I<base_reachable_time>/2.  An entry's validity will be extended if it "
"receives positive feedback from higher level protocols.  Defaults to 30 "
"seconds.  This file is now obsolete in favor of I<base_reachable_time_ms>."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:173
#, no-wrap
msgid "I<base_reachable_time_ms> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:179
msgid ""
"As for I<base_reachable_time>, but measures time in milliseconds.  Defaults "
"to 30000 milliseconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:179
#, no-wrap
msgid "I<delay_first_probe_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:185
msgid ""
"Delay before first probe after it has been decided that a neighbor is "
"stale.  Defaults to 5 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:185
#, no-wrap
msgid "I<gc_interval> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:191
msgid ""
"How frequently the garbage collector for neighbor entries should attempt to "
"run.  Defaults to 30 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:191
#, no-wrap
msgid "I<gc_stale_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:198
msgid ""
"Determines how often to check for stale neighbor entries.  When a neighbor "
"entry is considered stale, it is resolved again before sending data to it.  "
"Defaults to 60 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:198
#, no-wrap
msgid "I<gc_thresh1> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:205
msgid ""
"The minimum number of entries to keep in the ARP cache.  The garbage "
"collector will not run if there are fewer than this number of entries in the "
"cache.  Defaults to 128."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:205
#, no-wrap
msgid "I<gc_thresh2> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:212
msgid ""
"The soft maximum number of entries to keep in the ARP cache.  The garbage "
"collector will allow the number of entries to exceed this for 5 seconds "
"before collection will be performed.  Defaults to 512."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:212
#, no-wrap
msgid "I<gc_thresh3> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:219
msgid ""
"The hard maximum number of entries to keep in the ARP cache.  The garbage "
"collector will always run if there are more than this number of entries in "
"the cache.  Defaults to 1024."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:219
#, no-wrap
msgid "I<locktime> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:226
msgid ""
"The minimum number of jiffies to keep an ARP entry in the cache.  This "
"prevents ARP cache thrashing if there is more than one potential mapping "
"(generally due to network misconfiguration).  Defaults to 1 second."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:226
#, no-wrap
msgid "I<mcast_solicit> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:232
msgid ""
"The maximum number of attempts to resolve an address by multicast/broadcast "
"before marking the entry as unreachable.  Defaults to 3."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:232
#, no-wrap
msgid "I<proxy_delay> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:240
msgid ""
"When an ARP request for a known proxy-ARP address is received, delay up to "
"I<proxy_delay> jiffies before replying.  This is used to prevent network "
"flooding in some cases.  Defaults to 0.8 seconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:240
#, no-wrap
msgid "I<proxy_qlen> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:245
msgid ""
"The maximum number of packets which may be queued to proxy-ARP addresses.  "
"Defaults to 64."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:245
#, no-wrap
msgid "I<retrans_time> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:252
msgid ""
"The number of jiffies to delay before retransmitting a request.  Defaults to "
"1 second.  This file is now obsolete in favor of I<retrans_time_ms>."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:252
#, no-wrap
msgid "I<retrans_time_ms> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:256
msgid ""
"The number of milliseconds to delay before retransmitting a request.  "
"Defaults to 1000 milliseconds."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:256
#, no-wrap
msgid "I<ucast_solicit> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:263
msgid ""
"The maximum number of attempts to send unicast probes before asking the ARP "
"daemon (see I<app_solicit>).  Defaults to 3."
msgstr ""

#. type: TP
#: build/C/man7/arp.7:263
#, no-wrap
msgid "I<unres_qlen> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.79
#. type: Plain text
#: build/C/man7/arp.7:269
msgid ""
"The maximum number of packets which may be queued for each unresolved "
"address by other network layers.  Defaults to 3."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:269 build/C/man7/ddp.7:216 build/C/man3/endian.3:72 build/C/man3/getnameinfo.3:200 build/C/man7/icmp.7:155 build/C/man7/ipv6.7:282 build/C/man7/packet.7:277 build/C/man7/raw.7:171 build/C/man3/rcmd.3:260 build/C/man3/rexec.3:136 build/C/man7/tcp.7:1114 build/C/man7/udp.7:241 build/C/man7/udplite.7:142 build/C/man7/unix.7:397 build/C/man7/x25.7:95
#, no-wrap
msgid "VERSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:276
msgid ""
"The I<struct arpreq> changed in Linux 2.0 to include the I<arp_dev> member "
"and the ioctl numbers changed at the same time.  Support for the old ioctls "
"was dropped in Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:282
msgid ""
"Support for proxy arp entries for networks (netmask not equal 0xffffffff)  "
"was dropped in Linux 2.2.  It is replaced by automatic proxy arp setup by "
"the kernel for all reachable hosts on other interfaces (when forwarding and "
"proxy arp is enabled for the interface)."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:286
msgid "The I<neigh/*> interfaces did not exist before Linux 2.2."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:286 build/C/man7/ddp.7:239 build/C/man3/ether_aton.3:125 build/C/man3/gethostbyname.3:422 build/C/man3/inet_ntop.3:110 build/C/man3/inet_pton.3:148 build/C/man7/ip.7:1067 build/C/man7/ipv6.7:321 build/C/man7/netdevice.7:321 build/C/man7/packet.7:358 build/C/man7/raw.7:248 build/C/man3/rcmd.3:276 build/C/man3/rexec.3:149 build/C/man7/tcp.7:1121 build/C/man7/udplite.7:124 build/C/man7/x25.7:97
#, no-wrap
msgid "BUGS"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:290
msgid ""
"Some timer settings are specified in jiffies, which is architecture- and "
"kernel version-dependent; see B<time>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:296
msgid ""
"There is no way to signal positive feedback from user space.  This means "
"connection-oriented protocols implemented in user space will generate "
"excessive ARP traffic, because ndisc will regularly reprobe the MAC "
"address.  The same problem applies for some kernel protocols (e.g., NFS over "
"UDP)."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:299
msgid ""
"This man page mashes IPv4 specific and shared between IPv4 and IPv6 "
"functionality together."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:299 build/C/man3/byteorder.3:77 build/C/man3/cmsg.3:213 build/C/man7/ddp.7:244 build/C/man3/endian.3:149 build/C/man3/ether_aton.3:129 build/C/man3/getaddrinfo.3:815 build/C/man3/getaddrinfo_a.3:600 build/C/man1/getent.1:367 build/C/man3/gethostbyname.3:427 build/C/man3/getipnodebyname.3:264 build/C/man3/getnameinfo.3:272 build/C/man3/getnetent.3:133 build/C/man3/getnetent_r.3:143 build/C/man2/getpeername.2:114 build/C/man3/getprotoent.3:122 build/C/man3/getprotoent_r.3:235 build/C/man3/getservent.3:131 build/C/man3/getservent_r.3:239 build/C/man5/host.conf.5:199 build/C/man7/hostname.7:83 build/C/man5/hosts.5:115 build/C/man5/hosts.equiv.5:62 build/C/man7/icmp.7:185 build/C/man3/inet.3:297 build/C/man3/inet_ntop.3:116 build/C/man3/inet_pton.3:213 build/C/man7/ip.7:1086 build/C/man7/ipv6.7:332 build/C/man7/netdevice.7:335 build/C/man5/networks.5:73 build/C/man8/nscd.8:85 build/C/man5/nscd.conf.5:186 build/C/man5/nsswitch.conf.5:339 build/C/man7/packet.7:389 build/C/man5/protocols.5:80 build/C/man7/raw.7:265 build/C/man3/rcmd.3:283 build/C/man5/resolv.conf.5:273 build/C/man3/resolver.3:267 build/C/man3/rexec.3:158 build/C/man5/services.5:209 build/C/man3/setnetgrent.3:102 build/C/man2/shutdown.2:97 build/C/man7/tcp.7:1133 build/C/man7/udp.7:246 build/C/man7/udplite.7:144 build/C/man7/unix.7:441 build/C/man7/x25.7:113
#, no-wrap
msgid "SEE ALSO"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:302
msgid "B<capabilities>(7), B<ip>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:304
msgid "RFC\\ 826 for a description of ARP."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:307
msgid ""
"RFC\\ 2461 for a description of IPv6 neighbor discovery and the base "
"algorithms used."
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:309
msgid "Linux 2.2+ IPv4 ARP uses the IPv6 algorithms when applicable."
msgstr ""

#. type: SH
#: build/C/man7/arp.7:309 build/C/man3/byteorder.3:81 build/C/man3/cmsg.3:218 build/C/man7/ddp.7:249 build/C/man3/endian.3:151 build/C/man3/ether_aton.3:131 build/C/man3/getaddrinfo.3:824 build/C/man3/getaddrinfo_a.3:607 build/C/man1/getent.1:369 build/C/man3/gethostbyname.3:441 build/C/man3/getipnodebyname.3:269 build/C/man3/getnameinfo.3:303 build/C/man3/getnetent.3:140 build/C/man3/getnetent_r.3:146 build/C/man2/getpeername.2:121 build/C/man3/getprotoent.3:127 build/C/man3/getprotoent_r.3:238 build/C/man3/getservent.3:136 build/C/man3/getservent_r.3:242 build/C/man5/host.conf.5:204 build/C/man7/hostname.7:91 build/C/man5/hosts.5:125 build/C/man5/hosts.equiv.5:66 build/C/man7/icmp.7:189 build/C/man3/inet.3:307 build/C/man3/inet_ntop.3:120 build/C/man3/inet_pton.3:217 build/C/man7/ip.7:1104 build/C/man7/ipv6.7:340 build/C/man7/netdevice.7:340 build/C/man5/networks.5:79 build/C/man8/nscd.8:91 build/C/man5/nscd.conf.5:191 build/C/man5/nsswitch.conf.5:342 build/C/man7/packet.7:404 build/C/man5/protocols.5:84 build/C/man7/raw.7:279 build/C/man3/rcmd.3:291 build/C/man5/resolv.conf.5:280 build/C/man3/resolver.3:273 build/C/man3/rexec.3:161 build/C/man5/services.5:221 build/C/man3/setnetgrent.3:106 build/C/man2/shutdown.2:101 build/C/man7/tcp.7:1159 build/C/man7/udp.7:257 build/C/man7/udplite.7:153 build/C/man7/unix.7:450 build/C/man7/x25.7:123
#, no-wrap
msgid "COLOPHON"
msgstr ""

#. type: Plain text
#: build/C/man7/arp.7:316 build/C/man3/byteorder.3:88 build/C/man3/cmsg.3:225 build/C/man7/ddp.7:256 build/C/man3/endian.3:158 build/C/man3/ether_aton.3:138 build/C/man3/getaddrinfo.3:831 build/C/man3/getaddrinfo_a.3:614 build/C/man1/getent.1:376 build/C/man3/gethostbyname.3:448 build/C/man3/getipnodebyname.3:276 build/C/man3/getnameinfo.3:310 build/C/man3/getnetent.3:147 build/C/man3/getnetent_r.3:153 build/C/man2/getpeername.2:128 build/C/man3/getprotoent.3:134 build/C/man3/getprotoent_r.3:245 build/C/man3/getservent.3:143 build/C/man3/getservent_r.3:249 build/C/man5/host.conf.5:211 build/C/man7/hostname.7:98 build/C/man5/hosts.5:132 build/C/man5/hosts.equiv.5:73 build/C/man7/icmp.7:196 build/C/man3/inet.3:314 build/C/man3/inet_ntop.3:127 build/C/man3/inet_pton.3:224 build/C/man7/ip.7:1111 build/C/man7/ipv6.7:347 build/C/man7/netdevice.7:347 build/C/man5/networks.5:86 build/C/man8/nscd.8:98 build/C/man5/nscd.conf.5:198 build/C/man5/nsswitch.conf.5:349 build/C/man7/packet.7:411 build/C/man5/protocols.5:91 build/C/man7/raw.7:286 build/C/man3/rcmd.3:298 build/C/man5/resolv.conf.5:287 build/C/man3/resolver.3:280 build/C/man3/rexec.3:168 build/C/man5/services.5:228 build/C/man3/setnetgrent.3:113 build/C/man2/shutdown.2:108 build/C/man7/tcp.7:1166 build/C/man7/udp.7:264 build/C/man7/udplite.7:160 build/C/man7/unix.7:457 build/C/man7/x25.7:130
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""

#. type: TH
#: build/C/man3/byteorder.3:30
#, no-wrap
msgid "BYTEORDER"
msgstr ""

#. type: TH
#: build/C/man3/byteorder.3:30
#, no-wrap
msgid "2009-01-15"
msgstr ""

#. type: TH
#: build/C/man3/byteorder.3:30 build/C/man3/endian.3:26 build/C/man3/ether_aton.3:31 build/C/man3/getaddrinfo.3:41 build/C/man3/getaddrinfo_a.3:27 build/C/man3/getnameinfo.3:7 build/C/man3/getnetent.3:28 build/C/man3/getnetent_r.3:24 build/C/man3/getprotoent.3:28 build/C/man3/getprotoent_r.3:24 build/C/man3/getservent.3:32 build/C/man3/getservent_r.3:24 build/C/man3/inet.3:42 build/C/man8/nscd.8:23 build/C/man5/nscd.conf.5:20 build/C/man3/resolver.3:30 build/C/man3/setnetgrent.3:5
#, no-wrap
msgid "GNU"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:34
msgid ""
"htonl, htons, ntohl, ntohs - convert values between host and network byte "
"order"
msgstr ""

#. type: SH
#: build/C/man3/byteorder.3:34 build/C/man3/cmsg.3:10 build/C/man7/ddp.7:10 build/C/man3/endian.3:31 build/C/man3/ether_aton.3:35 build/C/man3/getaddrinfo.3:45 build/C/man3/getaddrinfo_a.3:31 build/C/man1/getent.1:26 build/C/man3/gethostbyname.3:44 build/C/man3/getipnodebyname.3:28 build/C/man3/getnameinfo.3:10 build/C/man3/getnetent.3:32 build/C/man3/getnetent_r.3:28 build/C/man2/getpeername.2:43 build/C/man3/getprotoent.3:32 build/C/man3/getprotoent_r.3:28 build/C/man3/getservent.3:36 build/C/man3/getservent_r.3:28 build/C/man5/hosts.5:30 build/C/man3/inet.3:46 build/C/man3/inet_ntop.3:27 build/C/man3/inet_pton.3:28 build/C/man7/ip.7:15 build/C/man7/ipv6.7:10 build/C/man7/netdevice.7:18 build/C/man7/packet.7:10 build/C/man7/raw.7:12 build/C/man3/rcmd.3:46 build/C/man5/resolv.conf.5:25 build/C/man3/resolver.3:34 build/C/man3/rexec.3:42 build/C/man3/setnetgrent.3:9 build/C/man2/shutdown.2:41 build/C/man7/tcp.7:19 build/C/man7/udp.7:11 build/C/man7/udplite.7:28 build/C/man7/unix.7:19 build/C/man7/x25.7:10
#, no-wrap
msgid "SYNOPSIS"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:37 build/C/man3/inet_ntop.3:30 build/C/man3/inet_pton.3:31
#, no-wrap
msgid "B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:39
#, no-wrap
msgid "B<uint32_t htonl(uint32_t >I<hostlong>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:41
#, no-wrap
msgid "B<uint16_t htons(uint16_t >I<hostshort>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:43
#, no-wrap
msgid "B<uint32_t ntohl(uint32_t >I<netlong>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:45
#, no-wrap
msgid "B<uint16_t ntohs(uint16_t >I<netshort>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:51
msgid ""
"The B<htonl>()  function converts the unsigned integer I<hostlong> from host "
"byte order to network byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:56
msgid ""
"The B<htons>()  function converts the unsigned short integer I<hostshort> "
"from host byte order to network byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:61
msgid ""
"The B<ntohl>()  function converts the unsigned integer I<netlong> from "
"network byte order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:66
msgid ""
"The B<ntohs>()  function converts the unsigned short integer I<netshort> "
"from network byte order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:70
msgid ""
"On the i386 the host byte order is Least Significant Byte first, whereas the "
"network byte order, as used on the Internet, is Most Significant Byte first."
msgstr ""

#. type: SH
#: build/C/man3/byteorder.3:70 build/C/man3/cmsg.3:137 build/C/man3/endian.3:74 build/C/man3/ether_aton.3:123 build/C/man3/getaddrinfo.3:582 build/C/man3/getaddrinfo_a.3:303 build/C/man3/gethostbyname.3:301 build/C/man3/getipnodebyname.3:256 build/C/man3/getnameinfo.3:203 build/C/man3/getnetent.3:124 build/C/man3/getnetent_r.3:139 build/C/man2/getpeername.2:99 build/C/man3/getprotoent.3:120 build/C/man3/getprotoent_r.3:129 build/C/man3/getservent.3:129 build/C/man3/getservent_r.3:128 build/C/man3/inet.3:210 build/C/man3/inet_ntop.3:98 build/C/man3/inet_pton.3:127 build/C/man3/rcmd.3:268 build/C/man3/resolver.3:265 build/C/man3/rexec.3:140 build/C/man3/setnetgrent.3:87 build/C/man2/shutdown.2:84
#, no-wrap
msgid "CONFORMING TO"
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:72 build/C/man3/inet_pton.3:129
msgid "POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:77
msgid ""
"Some systems require the inclusion of I<E<lt>netinet/in.hE<gt>> instead of "
"I<E<lt>arpa/inet.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man3/byteorder.3:81
msgid "B<endian>(3), B<gethostbyname>(3), B<getservent>(3)"
msgstr ""

#. type: TH
#: build/C/man3/cmsg.3:7
#, no-wrap
msgid "CMSG"
msgstr ""

#. type: TH
#: build/C/man3/cmsg.3:7 build/C/man7/ddp.7:7
#, no-wrap
msgid "2008-11-20"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:10
msgid "CMSG_ALIGN, CMSG_SPACE, CMSG_NXTHDR, CMSG_FIRSTHDR - Access ancillary data"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:12 build/C/man7/ddp.7:12 build/C/man2/getpeername.2:45 build/C/man7/ip.7:17 build/C/man7/ipv6.7:12 build/C/man7/raw.7:14 build/C/man2/shutdown.2:43 build/C/man7/tcp.7:21 build/C/man7/udp.7:13 build/C/man7/udplite.7:30 build/C/man7/unix.7:21 build/C/man7/x25.7:12
msgid "B<#include E<lt>sys/socket.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:14
msgid "B<struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *>I<msgh>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:16
msgid ""
"B<struct cmsghdr *CMSG_NXTHDR(struct msghdr *>I<msgh>B<, struct cmsghdr "
"*>I<cmsg>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:18
msgid "B<size_t CMSG_ALIGN(size_t >I<length>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:20
msgid "B<size_t CMSG_SPACE(size_t >I<length>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:22
msgid "B<size_t CMSG_LEN(size_t >I<length>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:24
msgid "B<unsigned char *CMSG_DATA(struct cmsghdr *>I<cmsg>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:32
#, no-wrap
msgid ""
"struct cmsghdr {\n"
"    socklen_t cmsg_len;    /* data byte count, including header */\n"
"    int       cmsg_level;  /* originating protocol */\n"
"    int       cmsg_type;   /* protocol-specific type */\n"
"    /* followed by unsigned char cmsg_data[]; */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:47
msgid ""
"These macros are used to create and access control messages (also called "
"ancillary data) that are not a part of the socket payload.  This control "
"information may include the interface the packet was received on, various "
"rarely used header fields, an extended error description, a set of file "
"descriptors or UNIX credentials.  For instance, control messages can be used "
"to send additional header fields such as IP options.  Ancillary data is sent "
"by calling B<sendmsg>(2)  and received by calling B<recvmsg>(2).  See their "
"manual pages for more information."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:58
msgid ""
"Ancillary data is a sequence of I<struct cmsghdr> structures with appended "
"data.  This sequence should only be accessed using the macros described in "
"this manual page and never directly.  See the specific protocol man pages "
"for the available control message types.  The maximum ancillary buffer size "
"allowed per socket can be set using I</proc/sys/net/core/optmem_max>; see "
"B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:65
msgid ""
"B<CMSG_FIRSTHDR>()  returns a pointer to the first I<cmsghdr> in the "
"ancillary data buffer associated with the passed I<msghdr>."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:72
msgid ""
"B<CMSG_NXTHDR>()  returns the next valid I<cmsghdr> after the passed "
"I<cmsghdr>.  It returns NULL when there isn't enough space left in the "
"buffer."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:77
msgid ""
"B<CMSG_ALIGN>(), given a length, returns it including the required "
"alignment.  This is a constant expression."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:82
msgid ""
"B<CMSG_SPACE>()  returns the number of bytes an ancillary element with "
"payload of the passed data length occupies.  This is a constant expression."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:86
msgid "B<CMSG_DATA>()  returns a pointer to the data portion of a I<cmsghdr>."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:97
msgid ""
"B<CMSG_LEN>()  returns the value to store in the I<cmsg_len> member of the "
"I<cmsghdr> structure, taking into account any necessary alignment.  It takes "
"the data length as an argument.  This is a constant expression."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:130
msgid ""
"To create ancillary data, first initialize the I<msg_controllen> member of "
"the I<msghdr> with the length of the control message buffer.  Use "
"B<CMSG_FIRSTHDR>()  on the I<msghdr> to get the first control message and "
"B<CMSG_NXTHDR>()  to get all subsequent ones.  In each control message, "
"initialize I<cmsg_len> (with B<CMSG_LEN>()), the other I<cmsghdr> header "
"fields, and the data portion using B<CMSG_DATA>().  Finally, the "
"I<msg_controllen> field of the I<msghdr> should be set to the sum of the "
"B<CMSG_SPACE>()  of the length of all control messages in the buffer.  For "
"more information on the I<msghdr>, see B<recvmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:137
msgid ""
"When the control message buffer is too short to store all messages, the "
"B<MSG_CTRUNC> flag is set in the I<msg_flags> member of the I<msghdr>."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:142
msgid ""
"This ancillary data model conforms to the POSIX.1g draft, 4.4BSD-Lite, the "
"IPv6 advanced API described in RFC\\ 2292 and the SUSv2.  B<CMSG_ALIGN>()  "
"is a Linux extension."
msgstr ""

#. type: SH
#: build/C/man3/cmsg.3:142 build/C/man7/ddp.7:221 build/C/man3/endian.3:89 build/C/man3/getaddrinfo.3:587 build/C/man3/getaddrinfo_a.3:306 build/C/man3/gethostbyname.3:325 build/C/man3/getipnodebyname.3:259 build/C/man3/getnameinfo.3:205 build/C/man3/getnetent.3:126 build/C/man2/getpeername.2:103 build/C/man5/host.conf.5:190 build/C/man5/hosts.5:88 build/C/man5/hosts.equiv.5:49 build/C/man7/icmp.7:163 build/C/man3/inet.3:218 build/C/man3/inet_pton.3:129 build/C/man7/ip.7:1006 build/C/man7/ipv6.7:311 build/C/man7/netdevice.7:303 build/C/man8/nscd.8:60 build/C/man5/nsswitch.conf.5:320 build/C/man7/packet.7:295 build/C/man7/raw.7:183 build/C/man3/setnetgrent.3:98 build/C/man2/shutdown.2:88 build/C/man7/unix.7:403
#, no-wrap
msgid "NOTES"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:147
msgid ""
"For portability, ancillary data should be accessed only using the macros "
"described here.  B<CMSG_ALIGN>()  is a Linux extension and should be not "
"used in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:157
msgid ""
"In Linux, B<CMSG_LEN>(), B<CMSG_DATA>(), and B<CMSG_ALIGN>()  are constant "
"expressions (assuming their argument is constant); this could be used to "
"declare the size of global variables.  This may be not portable, however."
msgstr ""

#. type: SH
#: build/C/man3/cmsg.3:157 build/C/man3/endian.3:105 build/C/man3/getaddrinfo.3:610 build/C/man3/getaddrinfo_a.3:312 build/C/man3/getnameinfo.3:233 build/C/man3/getprotoent_r.3:133 build/C/man3/getservent_r.3:132 build/C/man5/hosts.5:107 build/C/man3/inet.3:254 build/C/man3/inet_ntop.3:113 build/C/man3/inet_pton.3:154 build/C/man7/unix.7:433
#, no-wrap
msgid "EXAMPLE"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:161
msgid "This code looks for the B<IP_TTL> option in a received ancillary buffer:"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:168
#, no-wrap
msgid ""
"struct msghdr msgh;\n"
"struct cmsghdr *cmsg;\n"
"int *ttlptr;\n"
"int received_ttl;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:185
#, no-wrap
msgid ""
"/* Receive auxiliary data in msgh */\n"
"for (cmsg = CMSG_FIRSTHDR(&msgh); cmsg != NULL;\n"
"        cmsg = CMSG_NXTHDR(&msgh,cmsg)) {\n"
"    if (cmsg-E<gt>cmsg_level == IPPROTO_IP\n"
"            && cmsg-E<gt>cmsg_type == IP_TTL) {\n"
"        ttlptr = (int *) CMSG_DATA(cmsg);\n"
"        received_ttl = *ttlptr;\n"
"        break;\n"
"    }\n"
"}\n"
"if (cmsg == NULL) {\n"
"    /*\n"
"     * Error: IP_TTL not enabled or small buffer\n"
"     * or I/O error.\n"
"     */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:191
msgid ""
"The code below passes an array of file descriptors over a UNIX domain socket "
"using B<SCM_RIGHTS>:"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:199
#, no-wrap
msgid ""
"struct msghdr msg = {0};\n"
"struct cmsghdr *cmsg;\n"
"int myfds[NUM_FD]; /* Contains the file descriptors to pass. */\n"
"char buf[CMSG_SPACE(sizeof myfds)];  /* ancillary data buffer */\n"
"int *fdptr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:211
#, no-wrap
msgid ""
"msg.msg_control = buf;\n"
"msg.msg_controllen = sizeof buf;\n"
"cmsg = CMSG_FIRSTHDR(&msg);\n"
"cmsg-E<gt>cmsg_level = SOL_SOCKET;\n"
"cmsg-E<gt>cmsg_type = SCM_RIGHTS;\n"
"cmsg-E<gt>cmsg_len = CMSG_LEN(sizeof(int) * NUM_FD);\n"
"/* Initialize the payload: */\n"
"fdptr = (int *) CMSG_DATA(cmsg);\n"
"memcpy(fdptr, myfds, NUM_FD * sizeof(int));\n"
"/* Sum of the length of all control messages in the buffer: */\n"
"msg.msg_controllen = cmsg-E<gt>cmsg_len;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:216
msgid "B<recvmsg>(2), B<sendmsg>(2)"
msgstr ""

#. type: Plain text
#: build/C/man3/cmsg.3:218
msgid "RFC\\ 2292"
msgstr ""

#. type: TH
#: build/C/man7/ddp.7:7
#, no-wrap
msgid "DDP"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:10
msgid "ddp - Linux AppleTalk protocol implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:14
msgid "B<#include E<lt>netatalk/at.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:16
msgid "I<ddp_socket>B< = socket(AF_APPLETALK, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:18
msgid "I<raw_socket>B< = socket(AF_APPLETALK, SOCK_RAW, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:29
msgid ""
"Linux implements the Appletalk protocols described in I<Inside Appletalk>.  "
"Only the DDP layer and AARP are present in the kernel.  They are designed to "
"be used via the B<netatalk> protocol libraries.  This page documents the "
"interface for those who wish or need to use the DDP layer directly."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:34
msgid ""
"The communication between Appletalk and the user program works using a "
"BSD-compatible socket interface.  For more information on sockets, see "
"B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:55
msgid ""
"An AppleTalk socket is created by calling the B<socket>(2)  function with a "
"B<AF_APPLETALK> socket family argument.  Valid socket types are "
"B<SOCK_DGRAM> to open a B<ddp> socket or B<SOCK_RAW> to open a B<raw> "
"socket.  I<protocol> is the Appletalk protocol to be received or sent.  For "
"B<SOCK_RAW> you must specify B<ATPROTO_DDP>."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:60
msgid ""
"Raw sockets may be only opened by a process with effective user ID 0 or when "
"the process has the B<CAP_NET_RAW> capability."
msgstr ""

#. type: SS
#: build/C/man7/ddp.7:60 build/C/man7/ip.7:96 build/C/man7/ipv6.7:63 build/C/man7/raw.7:89 build/C/man7/udp.7:92 build/C/man7/udplite.7:56 build/C/man7/unix.7:53
#, no-wrap
msgid "Address Format"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:63
msgid ""
"An Appletalk socket address is defined as a combination of a network number, "
"a node number, and a port number."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:70
#, no-wrap
msgid ""
"struct at_addr {\n"
"    unsigned short s_net;\n"
"    unsigned char  s_node;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:76
#, no-wrap
msgid ""
"struct sockaddr_atalk {\n"
"    sa_family_t    sat_family;    /* address family */\n"
"    unsigned char  sat_port;      /* port */\n"
"    struct at_addr sat_addr;      /* net/node */\n"
"};\n"
msgstr ""

#.  FIXME this doesn't make sense [johnl]
#. type: Plain text
#: build/C/man7/ddp.7:115
msgid ""
"I<sat_family> is always set to B<AF_APPLETALK>.  I<sat_port> contains the "
"port.  The port numbers below 129 are known as I<reserved ports>.  Only "
"processes with the effective user ID 0 or the B<CAP_NET_BIND_SERVICE> "
"capability may B<bind>(2)  to these sockets.  I<sat_addr> is the host "
"address.  The I<net> member of I<struct at_addr> contains the host network "
"in network byte order.  The value of B<AT_ANYNET> is a wildcard and also "
"implies \\(lqthis network.\\(rq The I<node> member of I<struct at_addr> "
"contains the host node number.  The value of B<AT_ANYNODE> is a wildcard and "
"also implies \\(lqthis node.\\(rq The value of B<ATADDR_BCAST> is a link "
"local broadcast address."
msgstr ""

#. type: SS
#: build/C/man7/ddp.7:115 build/C/man7/ip.7:197 build/C/man7/ipv6.7:113 build/C/man7/packet.7:174 build/C/man7/raw.7:105 build/C/man7/tcp.7:809 build/C/man7/udp.7:172 build/C/man7/udplite.7:65 build/C/man7/unix.7:133 build/C/man7/x25.7:67
#, no-wrap
msgid "Socket Options"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:117
msgid "No protocol-specific socket options are supported."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:123
msgid ""
"IP supports a set of I</proc> interfaces to configure some global AppleTalk "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/atalk/>."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:123
#, no-wrap
msgid "I<aarp-expiry-time>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:126
msgid "The time interval (in seconds) before an AARP cache entry expires."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:126
#, no-wrap
msgid "I<aarp-resolve-time>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:129
msgid "The time interval (in seconds) before an AARP cache entry is resolved."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:129
#, no-wrap
msgid "I<aarp-retransmit-limit>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:133
msgid ""
"The number of retransmissions of an AARP query before the node is declared "
"dead."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:133
#, no-wrap
msgid "I<aarp-tick-time>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:136
msgid "The timer rate (in seconds) for the timer driving AARP."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:139
msgid ""
"The default values match the specification and should never need to be "
"changed."
msgstr ""

#.  FIXME Add a section about multicasting
#. type: Plain text
#: build/C/man7/ddp.7:144
msgid "All ioctls described in B<socket>(7)  apply to DDP."
msgstr ""

#. type: SH
#: build/C/man7/ddp.7:144 build/C/man3/gethostbyname.3:276 build/C/man3/getnetent_r.3:127 build/C/man2/getpeername.2:71 build/C/man3/getprotoent_r.3:117 build/C/man3/getservent_r.3:116 build/C/man3/inet_ntop.3:89 build/C/man7/ip.7:915 build/C/man7/ipv6.7:270 build/C/man7/packet.7:241 build/C/man7/raw.7:140 build/C/man2/shutdown.2:72 build/C/man7/tcp.7:1096 build/C/man7/udp.7:231 build/C/man7/udplite.7:119 build/C/man7/unix.7:318
#, no-wrap
msgid "ERRORS"
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:148 build/C/man7/ip.7:919 build/C/man7/raw.7:141
#, no-wrap
msgid "B<EACCES>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:155
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include sending to a broadcast address without having the broadcast "
"flag set, and trying to bind to a reserved port without effective user ID 0 "
"or B<CAP_NET_BIND_SERVICE>."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:155 build/C/man7/ip.7:935 build/C/man7/unix.7:319
#, no-wrap
msgid "B<EADDRINUSE>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:158 build/C/man7/ip.7:938
msgid "Tried to bind to an address already in use."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:158 build/C/man7/ip.7:938 build/C/man7/packet.7:242
#, no-wrap
msgid "B<EADDRNOTAVAIL>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:162 build/C/man7/ip.7:942
msgid ""
"A nonexistent interface was requested or the requested source address was "
"not local."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:162 build/C/man7/ip.7:942
#, no-wrap
msgid "B<EAGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:165 build/C/man7/ip.7:945
msgid "Operation on a nonblocking socket would block."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:165 build/C/man7/ip.7:945
#, no-wrap
msgid "B<EALREADY>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:168
msgid "A connection operation on a nonblocking socket is already in progress."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:168 build/C/man7/ip.7:948
#, no-wrap
msgid "B<ECONNABORTED>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:172 build/C/man7/ip.7:952
msgid "A connection was closed during an B<accept>(2)."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:172 build/C/man7/ip.7:952
#, no-wrap
msgid "B<EHOSTUNREACH>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:175
msgid "No routing table entry matches the destination address."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:175 build/C/man2/getpeername.2:83 build/C/man7/ip.7:957 build/C/man7/packet.7:248 build/C/man7/raw.7:148 build/C/man7/unix.7:335
#, no-wrap
msgid "B<EINVAL>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:178
msgid "Invalid argument passed."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:178 build/C/man7/ip.7:963 build/C/man7/unix.7:344
#, no-wrap
msgid "B<EISCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:182 build/C/man7/ip.7:967
msgid "B<connect>(2)  was called on an already connected socket."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:182 build/C/man7/ip.7:967 build/C/man7/packet.7:251 build/C/man7/raw.7:151
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:185
msgid "Datagram is bigger than the DDP MTU."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:185 build/C/man7/ipv6.7:272 build/C/man7/packet.7:260
#, no-wrap
msgid "B<ENODEV>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:188
msgid "Network device not available or not capable of sending IP."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:188 build/C/man3/getnetent_r.3:128 build/C/man3/getprotoent_r.3:118 build/C/man3/getservent_r.3:117 build/C/man7/ip.7:975 build/C/man7/packet.7:263 build/C/man7/unix.7:349
#, no-wrap
msgid "B<ENOENT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:192 build/C/man7/ip.7:979
msgid "B<SIOCGSTAMP> was called on a socket where no packet arrived."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:192
#, no-wrap
msgid "B<ENOMEM> and B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:195
msgid "Not enough memory available."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:195 build/C/man7/ip.7:979
#, no-wrap
msgid "B<ENOPKG>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:198 build/C/man7/ip.7:982
msgid "A kernel subsystem was not configured."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:198 build/C/man7/ip.7:982
#, no-wrap
msgid "B<ENOPROTOOPT> and B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:201 build/C/man7/ip.7:985
msgid "Invalid socket option passed."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:201 build/C/man2/getpeername.2:91 build/C/man7/ip.7:985 build/C/man7/packet.7:266 build/C/man2/shutdown.2:77 build/C/man7/unix.7:357
#, no-wrap
msgid "B<ENOTCONN>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:205 build/C/man7/ip.7:989
msgid ""
"The operation is only defined on a connected socket, but the socket wasn't "
"connected."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:205 build/C/man7/ip.7:989 build/C/man7/packet.7:272 build/C/man7/raw.7:162 build/C/man7/unix.7:364
#, no-wrap
msgid "B<EPERM>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:210
msgid ""
"User doesn't have permission to set high priority, make a configuration "
"change, or send signals to the requested process or group,"
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:210 build/C/man7/ip.7:993 build/C/man7/tcp.7:1103 build/C/man7/unix.7:368
#, no-wrap
msgid "B<EPIPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:213 build/C/man7/ip.7:996
msgid "The connection was unexpectedly closed or shut down by the other end."
msgstr ""

#. type: TP
#: build/C/man7/ddp.7:213 build/C/man7/ip.7:996 build/C/man7/unix.7:390
#, no-wrap
msgid "B<ESOCKTNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:216
msgid "The socket was unconfigured, or an unknown socket type was requested."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:221
msgid ""
"Appletalk is supported by Linux 2.0 or higher.  The I</proc> interfaces "
"exist since Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:227
msgid ""
"Be very careful with the B<SO_BROADCAST> option - it is not privileged in "
"Linux.  It is easy to overload the network with careless sending to "
"broadcast addresses."
msgstr ""

#. type: SS
#: build/C/man7/ddp.7:227 build/C/man7/ip.7:1054 build/C/man7/packet.7:326
#, no-wrap
msgid "Compatibility"
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:234
msgid ""
"The basic AppleTalk socket interface is compatible with B<netatalk> on "
"BSD-derived systems.  Many BSD systems fail to check B<SO_BROADCAST> when "
"sending broadcast frames; this can lead to compatibility problems."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:239
msgid ""
"The raw socket mode is unique to Linux and exists to support the alternative "
"CAP package and AppleTalk monitoring tools more easily."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:241 build/C/man7/ip.7:1069
msgid "There are too many inconsistent error values."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:244
msgid ""
"The ioctls used to configure routing tables, devices, AARP tables and other "
"devices are not yet described."
msgstr ""

#. type: Plain text
#: build/C/man7/ddp.7:249
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man3/endian.3:26
#, no-wrap
msgid "ENDIAN"
msgstr ""

#. type: TH
#: build/C/man3/endian.3:26 build/C/man3/getnetent_r.3:24 build/C/man3/getprotoent_r.3:24 build/C/man3/getservent_r.3:24
#, no-wrap
msgid "2010-09-10"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:31
msgid ""
"htobe16, htole16, be16toh, le16toh, htobe32, htole32, be32toh, le32toh, "
"htobe64, htole64, be64toh, le64toh - convert values between host and "
"big-/little-endian byte order"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:35
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>endian.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:40
#, no-wrap
msgid ""
"B<uint16_t htobe16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t htole16(uint16_t >I<host_16bits>B<);>\n"
"B<uint16_t be16toh(uint16_t >I<big_endian_16bits>B<);>\n"
"B<uint16_t le16toh(uint16_t >I<little_endian_16bits>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:45
#, no-wrap
msgid ""
"B<uint32_t htobe32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t htole32(uint32_t >I<host_32bits>B<);>\n"
"B<uint32_t be32toh(uint32_t >I<big_endian_32bits>B<);>\n"
"B<uint32_t le32toh(uint32_t >I<little_endian_32bits>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:50
#, no-wrap
msgid ""
"B<uint64_t htobe64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t htole64(uint64_t >I<host_64bits>B<);>\n"
"B<uint64_t be64toh(uint64_t >I<big_endian_64bits>B<);>\n"
"B<uint64_t le64toh(uint64_t >I<little_endian_64bits>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:55
msgid ""
"These functions convert the byte encoding of integer values from the byte "
"order that the current CPU (the \"host\") uses, to and from little-endian "
"and big-endian byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:60
msgid ""
"The number, I<nn>, in the name of each function indicates the size of "
"integer handled by the function, either 16, 32, or 64 bits."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:63
msgid ""
"The functions with names of the form \"htobeI<nn>\" convert from host byte "
"order to big-endian order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:66
msgid ""
"The functions with names of the form \"htoleI<nn>\" convert from host byte "
"order to little-endian order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:69
msgid ""
"The functions with names of the form \"beI<nn>toh\" convert from big-endian "
"order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:72
msgid ""
"The functions with names of the form \"leI<nn>toh\" convert from "
"little-endian order to host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:74
msgid "These functions were added to glibc in version 2.9."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:89
msgid ""
"These functions are nonstandard.  Similar functions are present on the BSDs, "
"where the required header file is I<E<lt>sys/endian.hE<gt>> instead of "
"I<E<lt>endian.hE<gt>>.  Unfortunately, NetBSD, FreeBSD, and glibc haven't "
"followed the original OpenBSD naming convention for these functions, whereby "
"the I<nn> component always appears at the end of the function name (thus, "
"for example, in NetBSD, FreeBSD, and glibc, the equivalent of OpenBSDs "
"\"betoh32\" is \"be32toh\")."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:97
msgid ""
"These functions are similar to the older B<byteorder>(3)  family of "
"functions.  For example, B<be32toh>()  is identical to B<ntohl>()B<.>"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:105
msgid ""
"The advantage of the B<byteorder>(3)  functions is that they are standard "
"functions available on all UNIX systems.  On the other hand, the fact that "
"they were designed for use in the context of TCP/IP means that they lack the "
"64-bit and little-endian variants described in this page."
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:112
msgid ""
"The program below display the results of converting an integer from host "
"byte order to both little-endian and big-endian byte order.  Since host byte "
"order is either little-endian or big-endian, only one of these conversions "
"will have an effect.  When we run this program on a little-endian system "
"such as x86-32, we see the following:"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:119
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"x.u32 = 0x44332211\n"
"htole32(x.u32) = 0x44332211\n"
"htobe32(x.u32) = 0x11223344\n"
msgstr ""

#. type: SS
#: build/C/man3/endian.3:121 build/C/man3/getprotoent_r.3:160 build/C/man3/getservent_r.3:158 build/C/man3/inet.3:270 build/C/man3/inet_pton.3:171
#, no-wrap
msgid "Program source"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:128
#, no-wrap
msgid ""
"#include E<lt>endian.hE<gt>\n"
"#include E<lt>stdint.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:136
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    union {\n"
"\tuint32_t u32;\n"
"\tuint8_t arr[4];\n"
"    } x;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:141
#, no-wrap
msgid ""
"    x.arr[0] = 0x11;\t/* Lowest-address byte */\n"
"    x.arr[1] = 0x22;\n"
"    x.arr[2] = 0x33;\n"
"    x.arr[3] = 0x44;\t/* Highest-address byte */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:145
#, no-wrap
msgid ""
"    printf(\"x.u32 = 0x%x\\en\", x.u32);\n"
"    printf(\"htole32(x.u32) = 0x%x\\en\", htole32(x.u32));\n"
"    printf(\"htobe32(x.u32) = 0x%x\\en\", htobe32(x.u32));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:148 build/C/man3/getaddrinfo.3:814 build/C/man3/getprotoent_r.3:234 build/C/man3/getservent_r.3:238 build/C/man3/inet_pton.3:212
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/endian.3:151
msgid "B<byteorder>(3)"
msgstr ""

#. type: TH
#: build/C/man3/ether_aton.3:31
#, no-wrap
msgid "ETHER_ATON"
msgstr ""

#. type: TH
#: build/C/man3/ether_aton.3:31
#, no-wrap
msgid "2002-07-20"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:35
msgid ""
"ether_aton, ether_ntoa, ether_ntohost, ether_hostton, ether_line, "
"ether_ntoa_r, ether_aton_r - Ethernet address manipulation routines"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:38
#, no-wrap
msgid "B<#include E<lt>netinet/ether.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:40
#, no-wrap
msgid "B<char *ether_ntoa(const struct ether_addr *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:42
#, no-wrap
msgid "B<struct ether_addr *ether_aton(const char *>I<asc>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:44
#, no-wrap
msgid ""
"B<int ether_ntohost(char *>I<hostname>B<, const struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:46
#, no-wrap
msgid ""
"B<int ether_hostton(const char *>I<hostname>B<, struct ether_addr "
"*>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:49
#, no-wrap
msgid ""
"B<int ether_line(const char *>I<line>B<, struct ether_addr *>I<addr>B<,>\n"
"B<               char *>I<hostname>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:51 build/C/man3/gethostbyname.3:68
#, no-wrap
msgid "/* GNU extensions */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:53
#, no-wrap
msgid ""
"B<char *ether_ntoa_r(const struct ether_addr *>I<addr>B<, char "
"*>I<buf>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:56
#, no-wrap
msgid ""
"B<struct ether_addr *ether_aton_r(const char *>I<asc>B<,>\n"
"B<                                struct ether_addr *>I<addr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:66
msgid ""
"B<ether_aton>()  converts the 48-bit Ethernet host address I<asc> from the "
"standard hex-digits-and-colons notation into binary data in network byte "
"order and returns a pointer to it in a statically allocated buffer, which "
"subsequent calls will overwrite.  B<ether_aton>()  returns NULL if the "
"address is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:74
msgid ""
"The B<ether_ntoa>()  function converts the Ethernet host address I<addr> "
"given in network byte order to a string in standard hex-digits-and-colons "
"notation, omitting leading zeros.  The string is returned in a statically "
"allocated buffer, which subsequent calls will overwrite."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:81
msgid ""
"The B<ether_ntohost>()  function maps an Ethernet address to the "
"corresponding hostname in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:88
msgid ""
"The B<ether_hostton>()  function maps a hostname to the corresponding "
"Ethernet address in I</etc/ethers> and returns nonzero if it cannot be "
"found."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:100
msgid ""
"The B<ether_line>()  function parses a line in I</etc/ethers> format "
"(ethernet address followed by whitespace followed by hostname; \\(aq#\\(aq "
"introduces a comment) and returns an address and hostname pair, or nonzero "
"if it cannot be parsed.  The buffer pointed to by I<hostname> must be "
"sufficiently long, for example, have the same length as I<line>."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:111
msgid ""
"The functions B<ether_ntoa_r>()  and B<ether_aton_r>()  are reentrant "
"thread-safe versions of B<ether_ntoa>()  and B<ether_aton>()  respectively, "
"and do not use static buffers."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:115
msgid "The structure I<ether_addr> is defined in I<E<lt>net/ethernet.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:121
#, no-wrap
msgid ""
"struct ether_addr {\n"
"    uint8_t ether_addr_octet[6];\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:125
msgid "4.3BSD, SunOS."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:129
msgid "The glibc 2.2.5 implementation of B<ether_line>()  is broken."
msgstr ""

#. type: Plain text
#: build/C/man3/ether_aton.3:131
msgid "B<ethers>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getaddrinfo.3:41
#, no-wrap
msgid "GETADDRINFO"
msgstr ""

#. type: TH
#: build/C/man3/getaddrinfo.3:41
#, no-wrap
msgid "2012-04-29"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:45
msgid ""
"getaddrinfo, freeaddrinfo, gai_strerror - network address and service "
"translation"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:50 build/C/man3/getipnodebyname.3:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:54
#, no-wrap
msgid ""
"B<int getaddrinfo(const char *>I<node>B<, const char *>I<service>B<,>\n"
"B<                const struct addrinfo *>I<hints>B<,>\n"
"B<                struct addrinfo **>I<res>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:56
#, no-wrap
msgid "B<void freeaddrinfo(struct addrinfo *>I<res>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:58
#, no-wrap
msgid "B<const char *gai_strerror(int >I<errcode>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:63 build/C/man3/gethostbyname.3:91 build/C/man3/getnameinfo.3:23 build/C/man3/getnetent_r.3:50 build/C/man3/getprotoent_r.3:47 build/C/man3/getservent_r.3:47 build/C/man3/inet.3:70 build/C/man3/rcmd.3:79 build/C/man3/setnetgrent.3:29
msgid "Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:69
msgid "B<getaddrinfo>(), B<freeaddrinfo>(), B<gai_strerror>():"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:71
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""

#.  .BR getipnodebyname (3),
#.  .BR getipnodebyaddr (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:98
msgid ""
"Given I<node> and I<service>, which identify an Internet host and a service, "
"B<getaddrinfo>()  returns one or more I<addrinfo> structures, each of which "
"contains an Internet address that can be specified in a call to B<bind>(2)  "
"or B<connect>(2).  The B<getaddrinfo>()  function combines the functionality "
"provided by the B<getservbyname>(3)  and B<getservbyport>(3)  functions into "
"a single interface, but unlike the latter functions, B<getaddrinfo>()  is "
"reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:104
msgid ""
"The I<addrinfo> structure used by B<getaddrinfo>()  contains the following "
"fields:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:117
#, no-wrap
msgid ""
"struct addrinfo {\n"
"    int              ai_flags;\n"
"    int              ai_family;\n"
"    int              ai_socktype;\n"
"    int              ai_protocol;\n"
"    socklen_t        ai_addrlen;\n"
"    struct sockaddr *ai_addr;\n"
"    char            *ai_canonname;\n"
"    struct addrinfo *ai_next;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:139
msgid ""
"The I<hints> argument points to an I<addrinfo> structure that specifies "
"criteria for selecting the socket address structures returned in the list "
"pointed to by I<res>.  If I<hints> is not NULL it points to an I<addrinfo> "
"structure whose I<ai_family>, I<ai_socktype>, and I<ai_protocol> specify "
"criteria that limit the set of socket addresses returned by "
"B<getaddrinfo>(), as follows:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:139
#, no-wrap
msgid "I<ai_family>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:155
msgid ""
"This field specifies the desired address family for the returned addresses.  "
"Valid values for this field include B<AF_INET> and B<AF_INET6>.  The value "
"B<AF_UNSPEC> indicates that B<getaddrinfo>()  should return socket addresses "
"for any address family (either IPv4 or IPv6, for example) that can be used "
"with I<node> and I<service>."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:155
#, no-wrap
msgid "I<ai_socktype>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:164
msgid ""
"This field specifies the preferred socket type, for example B<SOCK_STREAM> "
"or B<SOCK_DGRAM>.  Specifying 0 in this field indicates that socket "
"addresses of any type can be returned by B<getaddrinfo>()."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:164
#, no-wrap
msgid "I<ai_protocol>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:170
msgid ""
"This field specifies the protocol for the returned socket addresses.  "
"Specifying 0 in this field indicates that socket addresses with any protocol "
"can be returned by B<getaddrinfo>()."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:170
#, no-wrap
msgid "I<ai_flags>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:174
msgid ""
"This field specifies additional options, described below.  Multiple flags "
"are specified by bitwise OR-ing them together."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:192
msgid ""
"All the other fields in the structure pointed to by I<hints> must contain "
"either 0 or a NULL pointer, as appropriate.  Specifying I<hints> as NULL is "
"equivalent to setting I<ai_socktype> and I<ai_protocol> to 0; I<ai_family> "
"to B<AF_UNSPEC>; and I<ai_flags> to B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)>."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:210
msgid ""
"I<node> specifies either a numerical network address (for IPv4, "
"numbers-and-dots notation as supported by B<inet_aton>(3); for IPv6, "
"hexadecimal string format as supported by B<inet_pton>(3)), or a network "
"hostname, whose network addresses are looked up and resolved.  If "
"I<hints.ai_flags> contains the B<AI_NUMERICHOST> flag then I<node> must be a "
"numerical network address.  The B<AI_NUMERICHOST> flag suppresses any "
"potentially lengthy network host address lookups."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:235
msgid ""
"If the B<AI_PASSIVE> flag is specified in I<hints.ai_flags>, and I<node> is "
"NULL, then the returned socket addresses will be suitable for B<bind>(2)ing "
"a socket that will B<accept>(2)  connections.  The returned socket address "
"will contain the \"wildcard address\" (B<INADDR_ANY> for IPv4 addresses, "
"B<IN6ADDR_ANY_INIT> for IPv6 address).  The wildcard address is used by "
"applications (typically servers)  that intend to accept connections on any "
"of the hosts's network addresses.  If I<node> is not NULL, then the "
"B<AI_PASSIVE> flag is ignored."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:255
msgid ""
"If the B<AI_PASSIVE> flag is not set in I<hints.ai_flags>, then the returned "
"socket addresses will be suitable for use with B<connect>(2), B<sendto>(2), "
"or B<sendmsg>(2).  If I<node> is NULL, then the network address will be set "
"to the loopback interface address (B<INADDR_LOOPBACK> for IPv4 addresses, "
"B<IN6ADDR_LOOPBACK_INIT> for IPv6 address); this is used by applications "
"that intend to communicate with peers running on the same host."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:278
msgid ""
"I<service> sets the port in each returned address structure.  If this "
"argument is a service name (see B<services>(5)), it is translated to the "
"corresponding port number.  This argument can also be specified as a decimal "
"number, which is simply converted to binary.  If I<service> is NULL, then "
"the port number of the returned socket addresses will be left "
"uninitialized.  If B<AI_NUMERICSERV> is specified in I<hints.ai_flags> and "
"I<service> is not NULL, then I<service> must point to a string containing a "
"numeric port number.  This flag is used to inhibit the invocation of a name "
"resolution service in cases where it is known not to be required."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:284
msgid "Either I<node> or I<service>, but not both, may be NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:300
msgid ""
"The B<getaddrinfo>()  function allocates and initializes a linked list of "
"I<addrinfo> structures, one for each network address that matches I<node> "
"and I<service>, subject to any restrictions imposed by I<hints>, and returns "
"a pointer to the start of the list in I<res>.  The items in the linked list "
"are linked by the I<ai_next> field."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:322
msgid ""
"There are several reasons why the linked list may have more than one "
"I<addrinfo> structure, including: the network host is multihomed, accessible "
"over multiple protocols (e.g., both B<AF_INET> and B<AF_INET6>); or the same "
"service is available from multiple socket types (one B<SOCK_STREAM> address "
"and another B<SOCK_DGRAM> address, for example).  Normally, the application "
"should try using the addresses in the order in which they are returned.  The "
"sorting function used within B<getaddrinfo>()  is defined in RFC\\ 3484; the "
"order can be tweaked for a particular system by editing I</etc/gai.conf> "
"(available since glibc 2.5)."
msgstr ""

#.  In glibc prior to 2.3.4, the ai_canonname of each addrinfo
#.  structure was set pointing to the canonical name; that was
#.  more than POSIX.1-2001 specified, or other implementations provided.
#.  MTK, Aug 05
#. type: Plain text
#: build/C/man3/getaddrinfo.3:337
msgid ""
"If I<hints.ai_flags> includes the B<AI_CANONNAME> flag, then the "
"I<ai_canonname> field of the first of the I<addrinfo> structures in the "
"returned list is set to point to the official name of the host."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:341
msgid ""
"The remaining fields of each returned I<addrinfo> structure are initialized "
"as follows:"
msgstr ""

#. type: IP
#: build/C/man3/getaddrinfo.3:341 build/C/man3/getaddrinfo.3:364 build/C/man3/getaddrinfo_a.3:189 build/C/man3/getaddrinfo_a.3:193 build/C/man3/getaddrinfo_a.3:195 build/C/man5/nsswitch.conf.5:138 build/C/man5/nsswitch.conf.5:142 build/C/man7/unix.7:72 build/C/man7/unix.7:87 build/C/man7/unix.7:107
#, no-wrap
msgid "*"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:364
msgid ""
"The I<ai_family>, I<ai_socktype>, and I<ai_protocol> fields return the "
"socket creation parameters (i.e., these fields have the same meaning as the "
"corresponding arguments of B<socket>(2)).  For example, I<ai_family> might "
"return B<AF_INET> or B<AF_INET6>; I<ai_socktype> might return B<SOCK_DGRAM> "
"or B<SOCK_STREAM>; and I<ai_protocol> returns the protocol for the socket."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:371
msgid ""
"A pointer to the socket address is placed in the I<ai_addr> field, and the "
"length of the socket address, in bytes, is placed in the I<ai_addrlen> "
"field."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:383
msgid ""
"If I<hints.ai_flags> includes the B<AI_ADDRCONFIG> flag, then IPv4 addresses "
"are returned in the list pointed to by I<res> only if the local system has "
"at least one IPv4 address configured, and IPv6 addresses are only returned "
"if the local system has at least one IPv6 address configured.  The loopback "
"address is not considered for this case as valid as a configured address."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:408
msgid ""
"If I<hint.ai_flags> specifies the B<AI_V4MAPPED> flag, and "
"I<hints.ai_family> was specified as B<AF_INET6>, and no matching IPv6 "
"addresses could be found, then return IPv4-mapped IPv6 addresses in the list "
"pointed to by I<res>.  If both B<AI_V4MAPPED> and B<AI_ALL> are specified in "
"I<hints.ai_flags>, then return both IPv6 and IPv4-mapped IPv6 addresses in "
"the list pointed to by I<res>.  B<AI_ALL> is ignored if B<AI_V4MAPPED> is "
"not also specified."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:414
msgid ""
"The B<freeaddrinfo>()  function frees the memory that was allocated for the "
"dynamically allocated linked list I<res>."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo.3:414 build/C/man3/getnameinfo.3:114
#, no-wrap
msgid "Extensions to getaddrinfo() for Internationalized Domain Names"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:423
msgid ""
"Starting with glibc 2.3.4, B<getaddrinfo>()  has been extended to "
"selectively allow the incoming and outgoing hostnames to be transparently "
"converted to and from the Internationalized Domain Name (IDN) format (see "
"RFC 3490, I<Internationalizing Domain Names in Applications (IDNA)>).  Four "
"new flags are defined:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:423
#, no-wrap
msgid "B<AI_IDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:429
msgid ""
"If this flag is specified, then the node name given in I<node> is converted "
"to IDN format if necessary.  The source encoding is that of the current "
"locale."
msgstr ""

#.  Implementation Detail:
#.  To minimize effects on system performance the implementation might
#.  want to check whether the input string contains any non-ASCII
#.  characters.  If there are none the IDN step can be skipped completely.
#.  On systems which allow not-ASCII safe encodings for a locale this
#.  might be a problem.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:441
msgid ""
"If the input name contains non-ASCII characters, then the IDN encoding is "
"used.  Those parts of the node name (delimited by dots) that contain "
"non-ASCII characters are encoded using ASCII Compatible Encoding (ACE)  "
"before being passed to the name resolution functions."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:441
#, no-wrap
msgid "B<AI_CANONIDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:453
msgid ""
"After a successful name lookup, and if the B<AI_CANONNAME> flag was "
"specified, B<getaddrinfo>()  will return the canonical name of the node "
"corresponding to the I<addrinfo> structure value passed back.  The return "
"value is an exact copy of the value returned by the name resolution "
"function."
msgstr ""

#
#. Implementation Detail:
#. If no component of the returned name starts with xn\-\- the IDN
#. step can be skipped, therefore avoiding unnecessary slowdowns.
#. type: Plain text
#: build/C/man3/getaddrinfo.3:466
msgid ""
"If the name is encoded using ACE, then it will contain the I<xn--> prefix "
"for one or more components of the name.  To convert these components into a "
"readable form the B<AI_CANONIDN> flag can be passed in addition to "
"B<AI_CANONNAME>.  The resulting string is encoded using the current locale's "
"encoding."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:466
#, no-wrap
msgid "B<AI_IDN_ALLOW_UNASSIGNED>, B<AI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:473 build/C/man3/getnameinfo.3:136
msgid ""
"Setting these flags will enable the IDNA_ALLOW_UNASSIGNED (allow unassigned "
"Unicode code points) and IDNA_USE_STD3_ASCII_RULES (check output to make "
"sure it is a STD3 conforming hostname)  flags respectively to be used in the "
"IDNA handling."
msgstr ""

#. type: SH
#: build/C/man3/getaddrinfo.3:473 build/C/man3/getaddrinfo_a.3:240 build/C/man3/gethostbyname.3:264 build/C/man3/getipnodebyname.3:184 build/C/man3/getnameinfo.3:136 build/C/man3/getnetent.3:111 build/C/man3/getnetent_r.3:116 build/C/man2/getpeername.2:66 build/C/man3/getprotoent.3:105 build/C/man3/getprotoent_r.3:106 build/C/man3/getservent.3:116 build/C/man3/getservent_r.3:105 build/C/man3/inet_ntop.3:81 build/C/man3/inet_pton.3:114 build/C/man3/rcmd.3:237 build/C/man3/resolver.3:238 build/C/man3/setnetgrent.3:81 build/C/man2/shutdown.2:67
#, no-wrap
msgid "RETURN VALUE"
msgstr ""

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getaddrinfo(); they need to
#.  be documented.
#.  #ifdef __USE_GNU
#.  #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.  #define EAI_CANCELED    -101  /* Request canceled.  */
#.  #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.  #define EAI_ALLDONE     -103  /* All requests done.  */
#.  #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.  #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.  #endif
#. type: Plain text
#: build/C/man3/getaddrinfo.3:487
msgid ""
"B<getaddrinfo>()  returns 0 if it succeeds, or one of the following nonzero "
"error codes:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:487
#, no-wrap
msgid "B<EAI_ADDRFAMILY>"
msgstr ""

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:492
msgid ""
"The specified network host does not have any network addresses in the "
"requested address family."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:492 build/C/man3/getaddrinfo_a.3:245 build/C/man3/getaddrinfo_a.3:262 build/C/man3/getnameinfo.3:152
#, no-wrap
msgid "B<EAI_AGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:496
msgid "The name server returned a temporary failure indication.  Try again later."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:496 build/C/man3/getnameinfo.3:156
#, no-wrap
msgid "B<EAI_BADFLAGS>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:506
msgid ""
"I<hints.ai_flags> contains invalid flags; or, I<hints.ai_flags> included "
"B<AI_CANONNAME> and I<name> was NULL."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:506 build/C/man3/getnameinfo.3:161
#, no-wrap
msgid "B<EAI_FAIL>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:509
msgid "The name server returned a permanent failure indication."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:509 build/C/man3/getnameinfo.3:164
#, no-wrap
msgid "B<EAI_FAMILY>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:512
msgid "The requested address family is not supported."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:512 build/C/man3/getaddrinfo_a.3:250 build/C/man3/getnameinfo.3:168
#, no-wrap
msgid "B<EAI_MEMORY>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:515 build/C/man3/getaddrinfo_a.3:253 build/C/man3/getnameinfo.3:171 build/C/man7/unix.7:357
msgid "Out of memory."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:515
#, no-wrap
msgid "B<EAI_NODATA>"
msgstr ""

#.  Not in SUSv3
#. type: Plain text
#: build/C/man3/getaddrinfo.3:520
msgid ""
"The specified network host exists, but does not have any network addresses "
"defined."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:520 build/C/man3/getnameinfo.3:171
#, no-wrap
msgid "B<EAI_NONAME>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:537
msgid ""
"The I<node> or I<service> is not known; or both I<node> and I<service> are "
"NULL; or B<AI_NUMERICSERV> was specified in I<hints.ai_flags> and I<service> "
"was not a numeric port-number string."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:537
#, no-wrap
msgid "B<EAI_SERVICE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:558
msgid ""
"The requested service is not available for the requested socket type.  It "
"may be available through another socket type.  For example, this error could "
"occur if I<service> was \"shell\" (a service only available on stream "
"sockets), and either I<hints.ai_protocol> was B<IPPROTO_UDP>, or "
"I<hints.ai_socktype> was B<SOCK_DGRAM>; or the error could occur if "
"I<service> was not NULL, and I<hints.ai_socktype> was B<SOCK_RAW> (a socket "
"type that does not support the concept of services)."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:558
#, no-wrap
msgid "B<EAI_SOCKTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:570
msgid ""
"The requested socket type is not supported.  This could occur, for example, "
"if I<hints.ai_socktype> and I<hints.ai_protocol> are inconsistent (e.g., "
"B<SOCK_DGRAM> and B<IPPROTO_TCP>, respectively)."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo.3:570 build/C/man3/getaddrinfo_a.3:253 build/C/man3/getnameinfo.3:184
#, no-wrap
msgid "B<EAI_SYSTEM>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:575
msgid "Other system error, check I<errno> for details."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:580
msgid ""
"The B<gai_strerror>()  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: SH
#: build/C/man3/getaddrinfo.3:580 build/C/man3/gethostbyname.3:291 build/C/man3/getnameinfo.3:194 build/C/man3/getnetent.3:120 build/C/man3/getprotoent.3:114 build/C/man3/getservent.3:125 build/C/man5/host.conf.5:180 build/C/man5/hosts.5:86 build/C/man5/hosts.equiv.5:47 build/C/man5/networks.5:69 build/C/man5/nsswitch.conf.5:285 build/C/man5/protocols.5:76 build/C/man5/resolv.conf.5:270 build/C/man3/resolver.3:260 build/C/man5/services.5:184 build/C/man3/setnetgrent.3:83 build/C/man7/udplite.7:136
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:582
msgid "I</etc/gai.conf>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:587
msgid "POSIX.1-2001.  The B<getaddrinfo>()  function is documented in RFC\\ 2553."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:592
msgid ""
"B<getaddrinfo>()  supports the I<address>B<%>I<scope-id> notation for "
"specifying the IPv6 scope-ID."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:600
msgid ""
"B<AI_ADDRCONFIG>, B<AI_ALL>, and B<AI_V4MAPPED> are available since glibc "
"2.3.3.  B<AI_NUMERICSERV> is available since glibc 2.3.4."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:610
msgid ""
"According to POSIX.1-2001, specifying I<hints> as NULL should cause "
"I<ai_flags> to be assumed as 0.  The GNU C library instead assumes a value "
"of B<(AI_V4MAPPED\\ |\\ AI_ADDRCONFIG)> for this case, since this value is "
"considered an improvement on the specification."
msgstr ""

#.  getnameinfo.3 refers to this example
#.  socket.2 refers to this example
#.  bind.2 refers to this example
#.  connect.2 refers to this example
#.  recvfrom.2 refers to this example
#.  sendto.2 refers to this example
#. type: Plain text
#: build/C/man3/getaddrinfo.3:624
msgid ""
"The following programs demonstrate the use of B<getaddrinfo>(), "
"B<gai_strerror>(), B<freeaddrinfo>(), and B<getnameinfo>(3).  The programs "
"are an echo server and client for UDP datagrams."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo.3:624
#, no-wrap
msgid "Server program"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:634
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:636 build/C/man3/getaddrinfo.3:731
#, no-wrap
msgid "#define BUF_SIZE 500\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:647
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s;\n"
"    struct sockaddr_storage peer_addr;\n"
"    socklen_t peer_addr_len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:652
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s port\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:661
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
"    hints.ai_canonname = NULL;\n"
"    hints.ai_addr = NULL;\n"
"    hints.ai_next = NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:667
#, no-wrap
msgid ""
"    s = getaddrinfo(NULL, argv[1], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:672
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully bind(2).\n"
"       If socket(2) (or bind(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:678
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:681
#, no-wrap
msgid ""
"        if (bind(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) == 0)\n"
"            break;                  /* Success */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:684 build/C/man3/getaddrinfo.3:777
#, no-wrap
msgid ""
"        close(sfd);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:689
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not bind\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:691 build/C/man3/getaddrinfo.3:784
#, no-wrap
msgid "    freeaddrinfo(result);           /* No longer needed */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:693
#, no-wrap
msgid "    /* Read datagrams and echo them back to sender */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:700
#, no-wrap
msgid ""
"    for (;;) {\n"
"        peer_addr_len = sizeof(struct sockaddr_storage);\n"
"        nread = recvfrom(sfd, buf, BUF_SIZE, 0,\n"
"                (struct sockaddr *) &peer_addr, &peer_addr_len);\n"
"        if (nread == -1)\n"
"            continue;               /* Ignore failed request */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:702
#, no-wrap
msgid "        char host[NI_MAXHOST], service[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:711
#, no-wrap
msgid ""
"        s = getnameinfo((struct sockaddr *) &peer_addr,\n"
"                        peer_addr_len, host, NI_MAXHOST,\n"
"                        service, NI_MAXSERV, NI_NUMERICSERV);\n"
"       if (s == 0)\n"
"            printf(\"Received %ld bytes from %s:%s\\en\",\n"
"                    (long) nread, host, service);\n"
"        else\n"
"            fprintf(stderr, \"getnameinfo: %s\\en\", gai_strerror(s));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:718
#, no-wrap
msgid ""
"        if (sendto(sfd, buf, nread, 0,\n"
"                    (struct sockaddr *) &peer_addr,\n"
"                    peer_addr_len) != nread)\n"
"            fprintf(stderr, \"Error sending response\\en\");\n"
"    }\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo.3:719
#, no-wrap
msgid "Client program"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:729
#, no-wrap
msgid ""
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>sys/socket.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:741
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct addrinfo hints;\n"
"    struct addrinfo *result, *rp;\n"
"    int sfd, s, j;\n"
"    size_t len;\n"
"    ssize_t nread;\n"
"    char buf[BUF_SIZE];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:746
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        fprintf(stderr, \"Usage: %s host port msg...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:748
#, no-wrap
msgid "    /* Obtain address(es) matching host/port */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:754
#, no-wrap
msgid ""
"    memset(&hints, 0, sizeof(struct addrinfo));\n"
"    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */\n"
"    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */\n"
"    hints.ai_flags = 0;\n"
"    hints.ai_protocol = 0;          /* Any protocol */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:760
#, no-wrap
msgid ""
"    s = getaddrinfo(argv[1], argv[2], &hints, &result);\n"
"    if (s != 0) {\n"
"        fprintf(stderr, \"getaddrinfo: %s\\en\", gai_strerror(s));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:765
#, no-wrap
msgid ""
"    /* getaddrinfo() returns a list of address structures.\n"
"       Try each address until we successfully connect(2).\n"
"       If socket(2) (or connect(2)) fails, we (close the socket\n"
"       and) try the next address. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:771
#, no-wrap
msgid ""
"    for (rp = result; rp != NULL; rp = rp-E<gt>ai_next) {\n"
"        sfd = socket(rp-E<gt>ai_family, rp-E<gt>ai_socktype,\n"
"                     rp-E<gt>ai_protocol);\n"
"        if (sfd == -1)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:774
#, no-wrap
msgid ""
"        if (connect(sfd, rp-E<gt>ai_addr, rp-E<gt>ai_addrlen) != -1)\n"
"            break;                  /* Success */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:782
#, no-wrap
msgid ""
"    if (rp == NULL) {               /* No address succeeded */\n"
"        fprintf(stderr, \"Could not connect\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:787
#, no-wrap
msgid ""
"    /* Send remaining command-line arguments as separate\n"
"       datagrams, and read responses from server */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:791
#, no-wrap
msgid ""
"    for (j = 3; j E<lt> argc; j++) {\n"
"        len = strlen(argv[j]) + 1;\n"
"                /* +1 for terminating null byte */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:797
#, no-wrap
msgid ""
"        if (len + 1 E<gt> BUF_SIZE) {\n"
"            fprintf(stderr,\n"
"                    \"Ignoring long message in argument %d\\en\", j);\n"
"            continue;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:802
#, no-wrap
msgid ""
"        if (write(sfd, argv[j], len) != len) {\n"
"            fprintf(stderr, \"partial/failed write\\en\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:808
#, no-wrap
msgid ""
"        nread = read(sfd, buf, BUF_SIZE);\n"
"        if (nread == -1) {\n"
"            perror(\"read\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo.3:811
#, no-wrap
msgid ""
"        printf(\"Received %ld bytes: %s\\en\", (long) nread, buf);\n"
"    }\n"
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#. type: Plain text
#: build/C/man3/getaddrinfo.3:824
msgid ""
"B<getaddrinfo_a>(3), B<gethostbyname>(3), B<getnameinfo>(3), B<inet>(3), "
"B<hostname>(7), B<ip>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getaddrinfo_a.3:27
#, no-wrap
msgid "GETADDRINFO_A"
msgstr ""

#. type: TH
#: build/C/man3/getaddrinfo_a.3:27
#, no-wrap
msgid "2010-09-27"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:31
msgid ""
"getaddrinfo_a, gai_suspend, gai_error, gai_cancel - asynchronous network "
"address and service translation"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:35
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:38
#, no-wrap
msgid ""
"B<int getaddrinfo_a(int >I<mode>B<, struct gaicb *>I<list[]>B<,>\n"
"B<                int >I<nitems>B<, struct sigevent *>I<sevp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:41
#, no-wrap
msgid ""
"B<int gai_suspend(struct gaicb *>I<list[]>B<, int >I<nitems>B<,>\n"
"B<                struct timespec *>I<timeout>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:43
#, no-wrap
msgid "B<int gai_error(struct gaicb *>I<req>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:45
#, no-wrap
msgid "B<int gai_cancel(struct gaicb *>I<req>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:47
#, no-wrap
msgid "Link with I<-lanl>.\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:55
msgid ""
"The B<getaddrinfo_a>()  function performs the same task as "
"B<getaddrinfo>(3), but allows multiple name look-ups to be performed "
"asynchronously, with optional notification on completion of look-up "
"operations."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:59
msgid "The I<mode> argument has one of the following values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:59
#, no-wrap
msgid "B<GAI_WAIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:63
msgid ""
"Perform the look-ups synchronously.  The call blocks until the look-ups have "
"completed."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:63
#, no-wrap
msgid "B<GAI_NOWAIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:71
msgid ""
"Perform the look-ups asynchronously.  The call returns immediately, and the "
"requests are resolved in the background.  See the discussion of the I<sevp> "
"argument below."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:86
msgid ""
"The array I<list> specifies the look-up requests to process.  The I<nitems> "
"argument specifies the number of elements in I<list>.  The requested look-up "
"operations are started in parallel.  NULL elements in I<list> are ignored.  "
"Each request is described by a I<gaicb> structure, defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:95
#, no-wrap
msgid ""
"struct gaicb {\n"
"    const char            *ar_name;\n"
"    const char            *ar_service;\n"
"    const struct addrinfo *ar_request;\n"
"    struct addrinfo       *ar_result;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:126
msgid ""
"The elements of this structure correspond to the arguments of "
"B<getaddrinfo>(3).  Thus, I<ar_name> corresponds to the I<node> argument and "
"I<ar_service> to the I<service> argument, identifying an Internet host and a "
"service.  The I<ar_request> element corresponds to the I<hints> argument, "
"specifying the criteria for selecting the returned socket address "
"structures.  Finally, I<ar_result> corresponds to the I<res> argument; you "
"do not need to initialize this element, it will be automatically set when "
"the request is resolved.  The I<addrinfo> structure referenced by the last "
"two elements is described in B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:142
msgid ""
"When I<mode> is specified as B<GAI_NOWAIT>, notifications about resolved "
"requests can be obtained by employing the I<sigevent> structure pointed to "
"by the I<sevp> argument.  For the definition and general details of this "
"structure, see B<sigevent>(7).  The I<sevp-E<gt>sigev_notify> field can have "
"the following values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:142
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:145
msgid "Don't provide any notification."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:145
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr ""

#.  si_pid and si_uid are also set, to the values of the calling process,
#.  which doesn't provide useful information, so we'll skip mentioning it.
#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:161
msgid ""
"When a look-up completes, generate the signal I<sigev_signo> for the "
"process.  See B<sigevent>(7)  for general details.  The I<si_code> field of "
"the I<siginfo_t> structure will be set to B<SI_ASYNCNL>."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:161
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:169
msgid ""
"When a look-up completes, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:178
msgid ""
"For B<SIGEV_SIGNAL> and B<SIGEV_THREAD>, it may be useful to point "
"I<sevp-E<gt>sigev_value.sival_ptr> to I<list>."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:189
msgid ""
"The B<gai_suspend>()  function suspends execution of the calling thread, "
"waiting for the completion of one or more requests in the array I<list>.  "
"The I<nitems> argument specifies the size of the array I<list>.  The call "
"blocks until one of the following occurs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:193
msgid "One or more of the operations in I<list> completes."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:195
msgid "The call is interrupted by a signal that is caught."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:208
msgid ""
"The time interval specified in I<timeout> elapses.  This argument specifies "
"a timeout in seconds plus nanoseconds (see B<nanosleep>(2)  for details of "
"the I<timespec> structure).  If I<timeout> is NULL, then the call blocks "
"indefinitely (until one of the events above occurs)."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:213
msgid ""
"No explicit indication of which request was completed is given; you must "
"determine which request(s) have completed by iterating with B<gai_error>()  "
"over the list of requests."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:223
msgid ""
"The B<gai_error>()  function returns the status of the request I<req>: "
"either B<EAI_INPROGRESS> if the request was not completed yet, 0 if it was "
"handled successfully, or an error code if the request could not be resolved."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:240
msgid ""
"The B<gai_cancel>()  function cancels the request I<req>.  If the request "
"has been canceled successfully, the error status of the request will be set "
"to B<EAI_CANCELLED> and normal asynchronous notification will be performed.  "
"The request cannot be canceled if it is currently being processed; in that "
"case, it will be handled as if B<gai_cancel>()  has never been called.  If "
"I<req> is NULL, an attempt is made to cancel all outstanding requests that "
"the process has made."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:245
msgid ""
"The B<getaddrinfo_a>()  function returns 0 if all of the requests have been "
"enqueued successfully, or one of the following nonzero error codes:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:250
msgid ""
"The resources necessary to enqueue the look-up requests were not available.  "
"The application may check the error status of each request to determine "
"which ones failed."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:257
msgid "I<mode> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:262
msgid ""
"The B<gai_suspend>()  function returns 0 if at least one of the listed "
"requests has been completed.  Otherwise, it returns one of the following "
"nonzero error codes:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:265
msgid "The given timeout expired before any of the requests could be completed."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:265 build/C/man3/getaddrinfo_a.3:295
#, no-wrap
msgid "B<EAI_ALLDONE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:268
msgid "There were no actual requests given to the function."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:268
#, no-wrap
msgid "B<EAI_INTR>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:273
msgid ""
"A signal has interrupted the function.  Note that this interruption might "
"have been caused by signal notification of some completed look-up request."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:285
msgid ""
"The B<gai_error>()  function can return B<EAI_INPROGRESS> for an unfinished "
"look-up request, 0 for a successfully completed look-up (as described "
"above), one of the error codes that could be returned by B<getaddrinfo>(3), "
"or the error code B<EAI_CANCELLED> if the request has been canceled "
"explicitly before it could be finished."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:289
msgid "The B<gai_cancel>()  function can return one of these values:"
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:289
#, no-wrap
msgid "B<EAI_CANCELLED>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:292
msgid "The request has been canceled successfully."
msgstr ""

#. type: TP
#: build/C/man3/getaddrinfo_a.3:292
#, no-wrap
msgid "B<EAI_NOTCANCELLED>"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:295
msgid "The request has not been canceled."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:298
msgid "The request has already completed."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:303 build/C/man3/getnameinfo.3:194
msgid ""
"The B<gai_strerror>(3)  function translates these error codes to a human "
"readable string, suitable for error reporting."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:306
msgid ""
"These functions are GNU extensions; they first appeared in glibc in version "
"2.2.3."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:312
msgid ""
"The interface of B<getaddrinfo_a>()  was modeled after the B<lio_listio>(3)  "
"interface."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:316
msgid ""
"Two examples are provided: a simple example that resolves several requests "
"in parallel synchronously, and a complex example showing some of the "
"asynchronous capabilities."
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo_a.3:316
#, no-wrap
msgid "Synchronous Example"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:321
msgid ""
"The program below simply resolves several hostnames in parallel, giving a "
"speed-up compared to resolving the hostnames sequentially using "
"B<getaddrinfo>(3).  The program might be used like this:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:328
#, no-wrap
msgid ""
"$ B<./a.out ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz>\n"
"ftp.us.kernel.org: 128.30.2.36\n"
"enoent.linuxfoundation.org: Name or service not known\n"
"gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:332
msgid "Here is the program source code"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:339 build/C/man3/getaddrinfo_a.3:430
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:347
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int i, ret;\n"
"    struct gaicb *reqs[argc - 1];\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:352
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s HOST...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:362
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        reqs[i] = malloc(sizeof(*reqs[0]));\n"
"        if (reqs[i] == NULL) {\n"
"            perror(\"malloc\");\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"        memset(reqs[i], 0, sizeof(*reqs[0]));\n"
"        reqs[i]-E<gt>ar_name = argv[i + 1];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:369
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_WAIT, reqs, argc - 1, NULL);\n"
"    if (ret != 0) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:375
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> argc - 1; i++) {\n"
"        printf(\"%s: \", reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
"        if (ret == 0) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:385
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                    host, sizeof(host),\n"
"                    NULL, 0, NI_NUMERICHOST);\n"
"            if (ret != 0) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:392
#, no-wrap
msgid ""
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: SS
#: build/C/man3/getaddrinfo_a.3:394
#, no-wrap
msgid "Asynchronous Example"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:399
msgid ""
"This example shows a simple interactive B<getaddrinfo_a>()  front-end.  The "
"notification facility is not demonstrated."
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:401
msgid "An example session might look like this:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:418
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"E<gt> a ftp.us.kernel.org enoent.linuxfoundation.org gnu.cz\n"
"E<gt> c 2\n"
"[2] gnu.cz: Request not canceled\n"
"E<gt> w 0 1\n"
"[00] ftp.us.kernel.org: Finished\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Processing request in progress\n"
"[02] gnu.cz: 87.236.197.13\n"
"E<gt> l\n"
"[00] ftp.us.kernel.org: 216.165.129.139\n"
"[01] enoent.linuxfoundation.org: Name or service not known\n"
"[02] gnu.cz: 87.236.197.13\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:422
msgid "The program source goes as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:433
#, no-wrap
msgid ""
"static struct gaicb **reqs = NULL;\n"
"static int nreqs = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:438
#, no-wrap
msgid ""
"static char *\n"
"getcmd(void)\n"
"{\n"
"    static char buf[256];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:442
#, no-wrap
msgid ""
"    fputs(\"E<gt> \", stdout); fflush(stdout);\n"
"    if (fgets(buf, sizeof(buf), stdin) == NULL)\n"
"        return NULL;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:445
#, no-wrap
msgid ""
"    if (buf[strlen(buf) - 1] == \\(aq\\en\\(aq)\n"
"        buf[strlen(buf) - 1] = 0;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:448
#, no-wrap
msgid ""
"    return buf;\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:456
#, no-wrap
msgid ""
"/* Add requests for specified hostnames */\n"
"static void\n"
"add_requests(void)\n"
"{\n"
"    int nreqs_base = nreqs;\n"
"    char *host;\n"
"    int ret;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:460
#, no-wrap
msgid ""
"    while ((host = strtok(NULL, \" \"))) {\n"
"        nreqs++;\n"
"        reqs = realloc(reqs, nreqs * sizeof(reqs[0]));\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:464
#, no-wrap
msgid ""
"        reqs[nreqs - 1] = calloc(1, sizeof(*reqs[0]));\n"
"        reqs[nreqs - 1]-E<gt>ar_name = strdup(host);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:466
#, no-wrap
msgid "    /* Queue nreqs_base..nreqs requests. */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:475
#, no-wrap
msgid ""
"    ret = getaddrinfo_a(GAI_NOWAIT, &reqs[nreqs_base],\n"
"                        nreqs - nreqs_base, NULL);\n"
"    if (ret) {\n"
"        fprintf(stderr, \"getaddrinfo_a() failed: %s\\en\",\n"
"                gai_strerror(ret));\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:484
#, no-wrap
msgid ""
"/* Wait until at least one of specified requests completes */\n"
"static void\n"
"wait_requests(void)\n"
"{\n"
"    char *id;\n"
"    int i, ret, n;\n"
"    struct gaicb const **wait_reqs = calloc(nreqs, sizeof(*wait_reqs));\n"
"                /* NULL elements are ignored by gai_suspend(). */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:487 build/C/man3/getaddrinfo_a.3:524
#, no-wrap
msgid ""
"    while ((id = strtok(NULL, \" \")) != NULL) {\n"
"        n = atoi(id);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:492 build/C/man3/getaddrinfo_a.3:529
#, no-wrap
msgid ""
"        if (n E<gt>= nreqs) {\n"
"            printf(\"Bad request number: %s\\en\", id);\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:495
#, no-wrap
msgid ""
"        wait_reqs[n] = reqs[n];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:501
#, no-wrap
msgid ""
"    ret = gai_suspend(wait_reqs, nreqs, NULL);\n"
"    if (ret) {\n"
"        printf(\"gai_suspend(): %s\\en\", gai_strerror(ret));\n"
"        return;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:505
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        if (wait_reqs[i] == NULL)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:509
#, no-wrap
msgid ""
"        ret = gai_error(reqs[i]);\n"
"        if (ret == EAI_INPROGRESS)\n"
"            continue;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:514
#, no-wrap
msgid ""
"        printf(\"[%02d] %s: %s\\en\", i, reqs[i]-E<gt>ar_name,\n"
"               ret == 0 ? \"Finished\" : gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:521
#, no-wrap
msgid ""
"/* Cancel specified requests */\n"
"static void\n"
"cancel_requests(void)\n"
"{\n"
"    char *id;\n"
"    int ret, n;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:535
#, no-wrap
msgid ""
"        ret = gai_cancel(reqs[n]);\n"
"        printf(\"[%s] %s: %s\\en\", id, reqs[atoi(id)]-E<gt>ar_name,\n"
"               gai_strerror(ret));\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:543
#, no-wrap
msgid ""
"/* List all requests */\n"
"static void\n"
"list_requests(void)\n"
"{\n"
"    int i, ret;\n"
"    char host[NI_MAXHOST];\n"
"    struct addrinfo *res;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:547
#, no-wrap
msgid ""
"    for (i = 0; i E<lt> nreqs; i++) {\n"
"        printf(\"[%02d] %s: \", i, reqs[i]-E<gt>ar_name);\n"
"        ret = gai_error(reqs[i]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:550
#, no-wrap
msgid ""
"        if (!ret) {\n"
"            res = reqs[i]-E<gt>ar_result;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:565
#, no-wrap
msgid ""
"            ret = getnameinfo(res-E<gt>ai_addr, res-E<gt>ai_addrlen,\n"
"                              host, sizeof(host),\n"
"                              NULL, 0, NI_NUMERICHOST);\n"
"            if (ret) {\n"
"                fprintf(stderr, \"getnameinfo() failed: %s\\en\",\n"
"                        gai_strerror(ret));\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"            puts(host);\n"
"        } else {\n"
"            puts(gai_strerror(ret));\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:571
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char *cmdline;\n"
"    char *cmd;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:574
#, no-wrap
msgid ""
"    while ((cmdline = getcmd()) != NULL) {\n"
"        cmd = strtok(cmdline, \" \");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:599
#, no-wrap
msgid ""
"        if (cmd == NULL) {\n"
"            list_requests();\n"
"        } else {\n"
"            switch (cmd[0]) {\n"
"            case \\(aqa\\(aq:\n"
"                add_requests();\n"
"                break;\n"
"            case \\(aqw\\(aq:\n"
"                wait_requests();\n"
"                break;\n"
"            case \\(aqc\\(aq:\n"
"                cancel_requests();\n"
"                break;\n"
"            case \\(aql\\(aq:\n"
"                list_requests();\n"
"                break;\n"
"            default:\n"
"                fprintf(stderr, \"Bad command: %c\\en\", cmd[0]);\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getaddrinfo_a.3:607
msgid ""
"B<getaddrinfo>(3), B<inet>(3), B<lio_listio>(3), B<hostname>(7), B<ip>(7), "
"B<sigevent>(7)"
msgstr ""

#. type: TH
#: build/C/man1/getent.1:23
#, no-wrap
msgid "GETENT"
msgstr ""

#. type: TH
#: build/C/man1/getent.1:23
#, no-wrap
msgid "2011-10-31"
msgstr ""

#. type: TH
#: build/C/man1/getent.1:23
#, no-wrap
msgid "User Commands"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:26
msgid "getent - get entries from Name Service Switch libraries"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:29
msgid "B<getent> I<database> [I<key> ...]"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:44
msgid ""
"The B<getent> command displays entries from databases supported by the Name "
"Service Switch libraries, which are configured in I</etc/nsswitch.conf>.  If "
"one or more I<key> arguments are provided, then only the entries that match "
"the supplied keys will be displayed.  Otherwise, if no I<key> is provided, "
"all entries will be displayed (unless the database does not support "
"enumeration)."
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:48
msgid ""
"The I<database> may be any of those supported by the GNU C Library, listed "
"below:"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:49
#, no-wrap
msgid "B<ahosts>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:70
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  This is identical to "
"using B<hosts>.  When one or more I<key> arguments are provided, pass each "
"I<key> in succession to B<getaddrinfo>(3)  with the address family "
"B<AF_UNSPEC>, enumerating each socket address structure returned."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:70
#, no-wrap
msgid "B<ahostsv4>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:76
msgid "Same as B<ahosts>, but use the address family B<AF_INET>."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:76
#, no-wrap
msgid "B<ahostsv6>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:87
msgid ""
"Same as B<ahosts>, but use the address family B<AF_INET6>.  The call to "
"B<getaddrinfo>(3)  in this case includes the B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:87 build/C/man5/nsswitch.conf.5:43
#, no-wrap
msgid "B<aliases>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:104
msgid ""
"When no I<key> is provided, use B<setaliasent>(3), B<getaliasent>(3), and "
"B<endaliasent>(3)  to enumerate the aliases database.  When one or more "
"I<key> arguments are provided, pass each I<key> in succession to "
"B<getaliasbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:104 build/C/man5/nsswitch.conf.5:48
#, no-wrap
msgid "B<ethers>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:120
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<ether_aton>(3)  and B<ether_hostton>(3)  until a result is "
"obtained, and display the result.  Enumeration is not supported on "
"B<ethers>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:120 build/C/man5/nsswitch.conf.5:51
#, no-wrap
msgid "B<group>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:141
msgid ""
"When no I<key> is provided, use B<setgrent>(3), B<getgrent>(3), and "
"B<endgrent>(3)  to enumerate the group database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getgrgid>(3)  and each "
"nonnumeric I<key> to B<getgrnam>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:141
#, no-wrap
msgid "B<gshadow>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:158
msgid ""
"When no I<key> is provided, use B<setsgent>(3), B<getsgent>(3), and "
"B<endsgent>(3)  to enumerate the gshadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getsgnam>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:158 build/C/man5/nsswitch.conf.5:56
#, no-wrap
msgid "B<hosts>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:181
msgid ""
"When no I<key> is provided, use B<sethostent>(3), B<gethostent>(3), and "
"B<endhostent>(3)  to enumerate the hosts database.  When one or more I<key> "
"arguments are provided, pass each I<key> to B<gethostbyaddr>(3)  or "
"B<gethostbyname2>(3), depending on whether a call to B<inet_pton>(3)  "
"indicates that the I<key> is an IPv6 or IPv4 address or not, and display the "
"result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:181
#, no-wrap
msgid "B<initgroups>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:195
msgid ""
"When one or more I<key> arguments are provided, pass each I<key> in "
"succession to B<getgrouplist>(3)  and display the result.  Enumeration is "
"not supported on B<initgroups>, so a I<key> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:195 build/C/man5/nsswitch.conf.5:61
#, no-wrap
msgid "B<netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:221
msgid ""
"When one I<key> is provided, pass the I<key> to B<setnetgrent>(3)  and, "
"using B<getnetgrent>(3)  display the resulting string triple (I<hostname>, "
"I<username>, I<domainname>).  Alternatively, three I<keys> may be provided, "
"which are interpreted as the I<hostname>, I<username> and I<domainname> to "
"match to a netgroup name via B<innetgr>(3).  Enumeration is not supported on "
"B<initgroups>, so either one or three I<keys> must be provided."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:221 build/C/man5/nsswitch.conf.5:65
#, no-wrap
msgid "B<networks>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:242
msgid ""
"When no I<key> is provided, use B<setnetent>(3), B<getnetent>(3), and "
"B<endnetent>(3)  to enumerate the networks database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getnetbyaddr>(3)  and each nonnumeric I<key> to B<getnetbyname>(3)  and "
"display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:242 build/C/man5/nsswitch.conf.5:70
#, no-wrap
msgid "B<passwd>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:263
msgid ""
"When no I<key> is provided, use B<setpwent>(3), B<getpwent>(3), and "
"B<endpwent>(3)  to enumerate the passwd database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getpwuid>(3)  and each "
"nonnumeric I<key> to B<getpwnam>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:263 build/C/man5/nsswitch.conf.5:75
#, no-wrap
msgid "B<protocols>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:284
msgid ""
"When no I<key> is provided, use B<setprotoent>(3), B<getprotoent>(3), and "
"B<endprotoent>(3)  to enumerate the protocols database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getprotobynumber>(3)  and each nonnumeric I<key> to B<getprotobyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:284 build/C/man5/nsswitch.conf.5:83
#, no-wrap
msgid "B<rpc>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:305
msgid ""
"When no I<key> is provided, use B<setrpcent>(3), B<getrpcent>(3), and "
"B<endrpcent>(3)  to enumerate the rpc database.  When one or more I<key> "
"arguments are provided, pass each numeric I<key> to B<getrpcbynumber>(3)  "
"and each nonnumeric I<key> to B<getrpcbyname>(3)  and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:305 build/C/man5/nsswitch.conf.5:88
#, no-wrap
msgid "B<services>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:326
msgid ""
"When no I<key> is provided, use B<setservent>(3), B<getservent>(3), and "
"B<endservent>(3)  to enumerate the services database.  When one or more "
"I<key> arguments are provided, pass each numeric I<key> to "
"B<getservbynumber>(3)  and each nonnumeric I<key> to B<getservbyname>(3)  "
"and display the result."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:326 build/C/man5/nsswitch.conf.5:93
#, no-wrap
msgid "B<shadow>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:343
msgid ""
"When no I<key> is provided, use B<setspent>(3), B<getspent>(3), and "
"B<endspent>(3)  to enumerate the shadow database.  When one or more I<key> "
"arguments are provided, pass each I<key> in succession to B<getspnam>(3)  "
"and display the result."
msgstr ""

#. type: SH
#: build/C/man1/getent.1:344
#, no-wrap
msgid "EXIT STATUS"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:347
msgid "One of the following exit values can be returned by B<getent>:"
msgstr ""

#. type: TP
#: build/C/man1/getent.1:348
#, no-wrap
msgid "B<0>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:351
msgid "Command completed successfully."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:351
#, no-wrap
msgid "B<1>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:356
msgid "Missing arguments, or I<database> unknown."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:356
#, no-wrap
msgid "B<2>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:362
msgid "One or more supplied I<key> could not be found in the I<database>."
msgstr ""

#. type: TP
#: build/C/man1/getent.1:362
#, no-wrap
msgid "B<3>"
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:366
msgid "Enumeration not supported on this I<database>."
msgstr ""

#. type: Plain text
#: build/C/man1/getent.1:369
msgid "B<nsswitch.conf>(5)"
msgstr ""

#. type: TH
#: build/C/man3/gethostbyname.3:36
#, no-wrap
msgid "GETHOSTBYNAME"
msgstr ""

#. type: TH
#: build/C/man3/gethostbyname.3:36
#, no-wrap
msgid "2010-10-04"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:44
msgid ""
"gethostbyname, gethostbyaddr, sethostent, gethostent, endhostent, h_errno, "
"herror, hstrerror, gethostbyaddr_r, gethostbyname2, gethostbyname2_r, "
"gethostbyname_r, gethostent_r - get network host entry"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:48
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt>>\n"
"B<extern int h_errno;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:50
#, no-wrap
msgid "B<struct hostent *gethostbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:54
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>       /* for AF_INET */\n"
"B<struct hostent *gethostbyaddr(const void *>I<addr>B<,>\n"
"B<                              socklen_t >I<len>B<, int >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:56
#, no-wrap
msgid "B<void sethostent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:58
#, no-wrap
msgid "B<void endhostent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:60
#, no-wrap
msgid "B<void herror(const char *>I<s>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:62
#, no-wrap
msgid "B<const char *hstrerror(int >I<err>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:64
#, no-wrap
msgid "/* System V/POSIX extension */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:66
#, no-wrap
msgid "B<struct hostent *gethostent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:70
#, no-wrap
msgid "B<struct hostent *gethostbyname2(const char *>I<name>B<, int >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:74
#, no-wrap
msgid ""
"B<int gethostent_r(>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:78
#, no-wrap
msgid ""
"B<int gethostbyaddr_r(const void *>I<addr>B<, socklen_t >I<len>B<, int "
">I<type>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:82
#, no-wrap
msgid ""
"B<int gethostbyname_r(const char *>I<name>B<,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:86
#, no-wrap
msgid ""
"B<int gethostbyname2_r(const char *>I<name>B<, int >I<af,>\n"
"B<        struct hostent *>I<ret>B<, char *>I<buf>B<, size_t "
">I<buflen>B<,>\n"
"B<        struct hostent **>I<result>B<, int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:100
msgid ""
"B<gethostbyname2>(), B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>(), B<gethostbyname2_r>():"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:102 build/C/man3/getnetent_r.3:58 build/C/man3/getprotoent_r.3:55 build/C/man3/getservent_r.3:55
msgid "_BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:106
msgid "B<herror>(), B<hstrerror>():"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:107
#, no-wrap
msgid "Since glibc 2.8:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:110
msgid "_BSD_SOURCE || _SVID_SOURCE || _GNU_SOURCE"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:110
#, no-wrap
msgid "Before glibc 2.8:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:113
msgid "none"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:127
msgid ""
"The B<gethostbyname*>()  and B<gethostbyaddr*>()  functions are obsolete.  "
"Applications should use B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:168
msgid ""
"The B<gethostbyname>()  function returns a structure of type I<hostent> for "
"the given host I<name>.  Here I<name> is either a hostname, or an IPv4 "
"address in standard dot notation (as for B<inet_addr>(3)), or an IPv6 "
"address in colon (and possibly dot) notation.  (See RFC\\ 1884 for the "
"description of IPv6 addresses.)  If I<name> is an IPv4 or IPv6 address, no "
"lookup is performed and B<gethostbyname>()  simply copies I<name> into the "
"I<h_name> field and its I<struct in_addr> equivalent into the "
"I<h_addr_list[0]> field of the returned I<hostent> structure.  If I<name> "
"doesn't end in a dot and the environment variable B<HOSTALIASES> is set, the "
"alias file pointed to by B<HOSTALIASES> will first be searched for I<name> "
"(see B<hostname>(7)  for the file format).  The current domain and its "
"parents are searched unless I<name> ends in a dot."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:184
msgid ""
"The B<gethostbyaddr>()  function returns a structure of type I<hostent> for "
"the given host address I<addr> of length I<len> and address type I<type>.  "
"Valid address types are B<AF_INET> and B<AF_INET6>.  The host address "
"argument is a pointer to a struct of a type depending on the address type, "
"for example a I<struct in_addr *> (probably obtained via a call to "
"B<inet_addr>(3))  for address type B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:191
msgid ""
"The B<sethostent>()  function specifies, if I<stayopen> is true (1), that a "
"connected TCP socket should be used for the name server queries and that the "
"connection should remain open during successive queries.  Otherwise, name "
"server queries will use UDP datagrams."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:196
msgid ""
"The B<endhostent>()  function ends the use of a TCP connection for name "
"server queries."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:201
msgid ""
"The (obsolete)  B<herror>()  function prints the error message associated "
"with the current value of I<h_errno> on I<stderr>."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:206
msgid ""
"The (obsolete)  B<hstrerror>()  function takes an error number (typically "
"I<h_errno>) and returns the corresponding message string."
msgstr ""

#.  (See
#.  .BR resolv+ (8)).
#. type: Plain text
#: build/C/man3/gethostbyname.3:223
msgid ""
"The domain name queries carried out by B<gethostbyname>()  and "
"B<gethostbyaddr>()  use a combination of any or all of the name server "
"B<named>(8), a broken out line from I</etc/hosts>, and the Network "
"Information Service (NIS or YP), depending upon the contents of the I<order> "
"line in I</etc/host.conf>.  The default action is to query B<named>(8), "
"followed by I</etc/hosts>."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:225
msgid "The I<hostent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:237
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;            /* official name of host */\n"
"    char **h_aliases;         /* alias list */\n"
"    int    h_addrtype;        /* host address type */\n"
"    int    h_length;          /* length of address */\n"
"    char **h_addr_list;       /* list of addresses */\n"
"}\n"
"#define h_addr h_addr_list[0] /* for backward compatibility */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:241
msgid "The members of the I<hostent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:241 build/C/man3/getipnodebyname.3:208
#, no-wrap
msgid "I<h_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:244
msgid "The official name of the host."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:244 build/C/man3/getipnodebyname.3:211
#, no-wrap
msgid "I<h_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:247
msgid "An array of alternative names for the host, terminated by a NULL pointer."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:247 build/C/man3/getipnodebyname.3:215
#, no-wrap
msgid "I<h_addrtype>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:254
msgid "The type of address; always B<AF_INET> or B<AF_INET6> at present."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:254 build/C/man3/getipnodebyname.3:237
#, no-wrap
msgid "I<h_length>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:257
msgid "The length of the address in bytes."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:257 build/C/man3/getipnodebyname.3:251
#, no-wrap
msgid "I<h_addr_list>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:261
msgid ""
"An array of pointers to network addresses for the host (in network byte "
"order), terminated by a NULL pointer."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:261
#, no-wrap
msgid "I<h_addr>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:264
msgid "The first address in I<h_addr_list> for backward compatibility."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:276
msgid ""
"The B<gethostbyname>()  and B<gethostbyaddr>()  functions return the "
"I<hostent> structure or a NULL pointer if an error occurs.  On error, the "
"I<h_errno> variable holds an error number.  When non-NULL, the return value "
"may point at static data, see the notes below."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:278
msgid "The variable I<h_errno> can have the following values:"
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:278 build/C/man3/getipnodebyname.3:188
#, no-wrap
msgid "B<HOST_NOT_FOUND>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:281
msgid "The specified host is unknown."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:281
#, no-wrap
msgid "B<NO_ADDRESS> or B<NO_DATA>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:284
msgid "The requested name is valid but does not have an IP address."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:284 build/C/man3/getipnodebyname.3:197
#, no-wrap
msgid "B<NO_RECOVERY>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:287
msgid "A nonrecoverable name server error occurred."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:287 build/C/man3/getipnodebyname.3:200
#, no-wrap
msgid "B<TRY_AGAIN>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:291
msgid ""
"A temporary error occurred on an authoritative name server.  Try again "
"later."
msgstr ""

#. type: TP
#: build/C/man3/gethostbyname.3:292 build/C/man5/host.conf.5:181
#, no-wrap
msgid "I</etc/host.conf>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:295
msgid "resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:295 build/C/man5/host.conf.5:187 build/C/man5/hosts.5:88
#, no-wrap
msgid "I</etc/hosts>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:298
msgid "host database file"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:298 build/C/man5/nsswitch.conf.5:293 build/C/man3/setnetgrent.3:87
#, no-wrap
msgid "I</etc/nsswitch.conf>"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:301
msgid "name service switch configuration"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:325
msgid ""
"POSIX.1-2001 specifies B<gethostbyname>(), B<gethostbyaddr>(), "
"B<sethostent>(), B<endhostent>(), B<gethostent>(), and I<h_errno>; "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno> are marked "
"obsolescent in that standard.  POSIX.1-2008 removes the specifications of "
"B<gethostbyname>(), B<gethostbyaddr>(), and I<h_errno>, recommending the use "
"of B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:335
msgid ""
"The functions B<gethostbyname>()  and B<gethostbyaddr>()  may return "
"pointers to static data, which may be overwritten by later calls.  Copying "
"the I<struct hostent> does not suffice, since it contains pointers; a deep "
"copy is required."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:359
msgid ""
"In the original BSD implementation the I<len> argument of B<gethostbyname>()  "
"was an I<int>.  The SUSv2 standard is buggy and declares the I<len> argument "
"of B<gethostbyaddr>()  to be of type I<size_t>.  (That is wrong, because it "
"has to be I<int>, and I<size_t> is not.  POSIX.1-2001 makes it I<socklen_t>, "
"which is OK.)  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:365
msgid ""
"The BSD prototype for B<gethostbyaddr>()  uses I<const char *> for the first "
"argument."
msgstr ""

#. type: SS
#: build/C/man3/gethostbyname.3:365
#, no-wrap
msgid "System V/POSIX Extension"
msgstr ""

#.  e.g., Linux, FreeBSD, UnixWare, HP-UX
#.  e.g., FreeBSD, AIX
#. type: Plain text
#: build/C/man3/gethostbyname.3:382
msgid ""
"POSIX requires the B<gethostent>()  call, that should return the next entry "
"in the host data base.  When using DNS/BIND this does not make much sense, "
"but it may be reasonable if the host data base is a file that can be read "
"line by line.  On many systems a routine of this name reads from the file "
"I</etc/hosts>.  It may be available only when the library was built without "
"DNS support.  The glibc version will ignore ipv6 entries.  This function is "
"not reentrant, and glibc adds a reentrant version B<gethostent_r>()."
msgstr ""

#. type: SS
#: build/C/man3/gethostbyname.3:382
#, no-wrap
msgid "GNU Extensions"
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:388
msgid ""
"Glibc2 also has a B<gethostbyname2>()  that works like B<gethostbyname>(), "
"but permits to specify the address family to which the address must belong."
msgstr ""

#. type: Plain text
#: build/C/man3/gethostbyname.3:422
msgid ""
"Glibc2 also has reentrant versions B<gethostent_r>(), B<gethostbyaddr_r>(), "
"B<gethostbyname_r>()  and B<gethostbyname2_r>().  The caller supplies a "
"I<hostent> structure I<ret> which will be filled in on success, and a "
"temporary work buffer I<buf> of size I<buflen>.  After the call, I<result> "
"will point to the result on success.  In case of an error or if no entry is "
"found I<result> will be NULL.  The functions return 0 on success and a "
"nonzero error number on failure.  In addition to the errors returned by the "
"nonreentrant versions of these functions, if I<buf> is too small, the "
"functions will return B<ERANGE>, and the call should be retried with a "
"larger buffer.  The global variable I<h_errno> is not modified, but the "
"address of a variable in which to store error numbers is passed in "
"I<h_errnop>."
msgstr ""

#.  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=482973
#. type: Plain text
#: build/C/man3/gethostbyname.3:427
msgid ""
"B<gethostbyname>()  does not recognize components of a dotted IPv4 address "
"string that are expressed in hexadecimal."
msgstr ""

#.  .BR getipnodebyaddr (3),
#.  .BR getipnodebyname (3),
#.  .BR resolv+ (8)
#. type: Plain text
#: build/C/man3/gethostbyname.3:441
msgid ""
"B<getaddrinfo>(3), B<getnameinfo>(3), B<inet>(3), B<inet_ntop>(3), "
"B<inet_pton>(3), B<resolver>(3), B<hosts>(5), B<nsswitch.conf>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: TH
#: build/C/man3/getipnodebyname.3:24
#, no-wrap
msgid "GETIPNODEBYNAME"
msgstr ""

#. type: TH
#: build/C/man3/getipnodebyname.3:24
#, no-wrap
msgid "2010-09-04"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:28
msgid ""
"getipnodebyname, getipnodebyaddr, freehostent - get network hostnames and "
"addresses"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:36
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyname(const char *>I<name>B<, int >I<af>B<,>\n"
"B<                                int >I<flags>B<, int *>I<error_num>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:39
#, no-wrap
msgid ""
"B<struct hostent *getipnodebyaddr(const void *>I<addr>B<, size_t "
">I<len>B<,>\n"
"B<                                int >I<af>B<, int *>I<error_num>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:41
#, no-wrap
msgid "B<void freehostent(struct hostent *>I<ip>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:49
msgid ""
"These functions are deprecated (and unavailable in glibc).  Use "
"B<getaddrinfo>(3)  and B<getnameinfo>(3)  instead."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:57
msgid ""
"The B<getipnodebyname>()  and B<getipnodebyaddr>()  functions return the "
"names and addresses of a network host.  These functions return a pointer to "
"the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:67
#, no-wrap
msgid ""
"struct hostent {\n"
"    char  *h_name;\n"
"    char **h_aliases;\n"
"    int    h_addrtype;\n"
"    int    h_length;\n"
"    char **h_addr_list;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:80
msgid ""
"These functions replace the B<gethostbyname>(3)  and B<gethostbyaddr>(3)  "
"functions, which could only access the IPv4 network address family.  The "
"B<getipnodebyname>()  and B<getipnodebyaddr>()  functions can access "
"multiple network address families."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:91
msgid ""
"Unlike the B<gethostby> functions, these functions return pointers to "
"dynamically allocated memory.  The B<freehostent>()  function is used to "
"release the dynamically allocated memory after the caller no longer needs "
"the I<hostent> structure."
msgstr ""

#. type: SS
#: build/C/man3/getipnodebyname.3:91
#, no-wrap
msgid "getipnodebyname() arguments"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:102
msgid ""
"The B<getipnodebyname>()  function looks up network addresses for the host "
"specified by the I<name> argument.  The I<af> argument specifies one of the "
"following values:"
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:102 build/C/man3/getipnodebyname.3:164 build/C/man3/inet_ntop.3:55 build/C/man3/inet_pton.3:51
#, no-wrap
msgid "B<AF_INET>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:108
msgid ""
"The I<name> argument points to a dotted-quad IPv4 address or a name of an "
"IPv4 network host."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:108 build/C/man3/getipnodebyname.3:174 build/C/man3/inet_ntop.3:68 build/C/man3/inet_pton.3:65
#, no-wrap
msgid "B<AF_INET6>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:114
msgid ""
"The I<name> argument points to a hexadecimal IPv6 address or a name of an "
"IPv6 network host."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:123
msgid ""
"The I<flags> argument specifies additional options.  More than one option "
"can be specified by bitwise OR-ing them together.  I<flags> should be set to "
"0 if no options are desired."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:123
#, no-wrap
msgid "B<AI_V4MAPPED>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:130
msgid ""
"This flag is used with B<AF_INET6> to request a query for IPv4 addresses "
"instead of IPv6 addresses; the IPv4 addresses will be mapped to IPv6 "
"addresses."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:130
#, no-wrap
msgid "B<AI_ALL>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:136
msgid ""
"This flag is used with B<AI_V4MAPPED> to request a query for both IPv4 and "
"IPv6 addresses.  Any IPv4 address found will be mapped to an IPv6 address."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:136
#, no-wrap
msgid "B<AI_ADDRCONFIG>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:148
msgid ""
"This flag is used with B<AF_INET6> to further request that queries for IPv6 "
"addresses should not be made unless the system has at least one IPv6 address "
"assigned to a network interface, and that queries for IPv4 addresses should "
"not be made unless the system has at least one IPv4 address assigned to a "
"network interface.  This flag may be used by itself or with the "
"B<AI_V4MAPPED> flag."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:148
#, no-wrap
msgid "B<AI_DEFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:152
msgid "This flag is equivalent to B<(AI_ADDRCONFIG | AI_V4MAPPED)>."
msgstr ""

#. type: SS
#: build/C/man3/getipnodebyname.3:152
#, no-wrap
msgid "getipnodebyaddr() arguments"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:164
msgid ""
"The B<getipnodebyaddr>()  function looks up the name of the host whose "
"network address is specified by the I<addr> argument.  The I<af> argument "
"specifies one of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:174
msgid ""
"The I<addr> argument points to a I<struct in_addr> and I<len> must be set to "
"I<sizeof(struct in_addr)>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:184
msgid ""
"The I<addr> argument points to a I<struct in6_addr> and I<len> must be set "
"to I<sizeof(struct in6_addr)>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:188
msgid ""
"A NULL pointer is returned if an error occurred, and I<error_num> will "
"contain an error code from the following list:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:191
msgid "The hostname or network address was not found."
msgstr ""

#. type: TP
#: build/C/man3/getipnodebyname.3:191
#, no-wrap
msgid "B<NO_ADDRESS>"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:197
msgid ""
"The domain name server recognized the network address or name, but no answer "
"was returned.  This can happen if the network host has only IPv4 addresses "
"and a request has been made for IPv6 information only, or vice versa."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:200
msgid "The domain name server returned a permanent failure response."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:204
msgid ""
"The domain name server returned a temporary failure response.  You might "
"have better luck next time."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:208
msgid ""
"A successful query returns a pointer to a I<hostent> structure that contains "
"the following fields:"
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:211
msgid "This is the official name of this network host."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:215
msgid ""
"This is an array of pointers to unofficial aliases for the same host.  The "
"array is terminated by a NULL pointer."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:237
msgid ""
"This is a copy of the I<af> argument to B<getipnodebyname>()  or "
"B<getipnodebyaddr>().  I<h_addrtype> will always be B<AF_INET> if the I<af> "
"argument was B<AF_INET>.  I<h_addrtype> will always be B<AF_INET6> if the "
"I<af> argument was B<AF_INET6>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:251
msgid ""
"This field will be set to I<sizeof(struct in_addr)> if I<h_addrtype> is "
"B<AF_INET>, and to I<sizeof(struct in6_addr)> if I<h_addrtype> is "
"B<AF_INET6>."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:256
msgid ""
"This is an array of one or more pointers to network address structures for "
"the network host.  The array is terminated by a NULL pointer."
msgstr ""

#.  Not in POSIX.1-2001.
#. type: Plain text
#: build/C/man3/getipnodebyname.3:259
msgid "RFC\\ 2553."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:264
msgid ""
"These functions were present in glibc 2.1.91-95, but were removed again.  "
"Several UNIX-like systems support them, but all call them deprecated."
msgstr ""

#. type: Plain text
#: build/C/man3/getipnodebyname.3:269
msgid "B<getaddrinfo>(3), B<getnameinfo>(3), B<inet_ntop>(3), B<inet_pton>(3)"
msgstr ""

#. type: TH
#: build/C/man3/getnameinfo.3:7
#, no-wrap
msgid "GETNAMEINFO"
msgstr ""

#. type: TH
#: build/C/man3/getnameinfo.3:7
#, no-wrap
msgid "2009-12-03"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:10
msgid "getnameinfo - address-to-name translation in protocol-independent manner"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:14
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:18
#, no-wrap
msgid ""
"B<int getnameinfo(const struct sockaddr *>I<sa>B<, socklen_t >I<salen>B<,>\n"
"B<                char *>I<host>B<, size_t >I<hostlen>B<,>\n"
"B<                char *>I<serv>B<, size_t >I<servlen>B<, int "
">I<flags>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:28
msgid ""
"B<getnameinfo>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:44
msgid ""
"The B<getnameinfo>()  function is the inverse of B<getaddrinfo>(3): it "
"converts a socket address to a corresponding host and service, in a "
"protocol-independent manner.  It combines the functionality of "
"B<gethostbyaddr>(3)  and B<getservbyport>(3), but unlike those functions, "
"B<getaddrinfo>(3)  is reentrant and allows programs to eliminate "
"IPv4-versus-IPv6 dependencies."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:67
msgid ""
"The I<sa> argument is a pointer to a generic socket address structure (of "
"type I<sockaddr_in> or I<sockaddr_in6>)  of size I<salen> that holds the "
"input IP address and port number.  The arguments I<host> and I<serv> are "
"pointers to caller-allocated buffers (of size I<hostlen> and I<servlen> "
"respectively) into which B<getnameinfo>()  places null-terminated strings "
"containing the host and service names respectively."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:80
msgid ""
"The caller can specify that no hostname (or no service name)  is required by "
"providing a NULL I<host> (or I<serv>)  argument or a zero I<hostlen> (or "
"I<servlen>)  argument.  However, at least one of hostname or service name "
"must be requested."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:86
msgid "The I<flags> argument modifies the behavior of B<getnameinfo>()  as follows:"
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:86
#, no-wrap
msgid "B<NI_NAMEREQD>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:89
msgid "If set, then an error is returned if the hostname cannot be determined."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:89
#, no-wrap
msgid "B<NI_DGRAM>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:95
msgid ""
"If set, then the service is datagram (UDP) based rather than stream (TCP) "
"based.  This is required for the few ports (512-514)  that have different "
"services for UDP and TCP."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:95
#, no-wrap
msgid "B<NI_NOFQDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:99
msgid ""
"If set, return only the hostname part of the fully qualified domain name for "
"local hosts."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:99
#, no-wrap
msgid "B<NI_NUMERICHOST>"
msgstr ""

#.  For example, by calling
#.  .BR inet_ntop ()
#.  instead of
#.  .BR gethostbyaddr ().
#.  POSIX.1-2003 has NI_NUMERICSCOPE, but glibc doesn't have it.
#. type: Plain text
#: build/C/man3/getnameinfo.3:109
msgid ""
"If set, then the numeric form of the hostname is returned.  (When not set, "
"this will still happen in case the node's name cannot be determined.)"
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:109
#, no-wrap
msgid "B<NI_NUMERICSERV>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:114
msgid ""
"If set, then the numeric form of the service address is returned.  (When not "
"set, this will still happen in case the service's name cannot be "
"determined.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:123
msgid ""
"Starting with glibc 2.3.4, B<getnameinfo>()  has been extended to "
"selectively allow hostnames to be transparently converted to and from the "
"Internationalized Domain Name (IDN) format (see RFC 3490, "
"I<Internationalizing Domain Names in Applications (IDNA)>).  Three new flags "
"are defined:"
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:123
#, no-wrap
msgid "B<NI_IDN>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:129
msgid ""
"If this flag is used, then the name found in the lookup process is converted "
"from IDN format to the locale's encoding if necessary.  ASCII-only names are "
"not affected by the conversion, which makes this flag usable in existing "
"programs and environments."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:129
#, no-wrap
msgid "B<NI_IDN_ALLOW_UNASSIGNED>, B<NI_IDN_USE_STD3_ASCII_RULES>"
msgstr ""

#.  FIXME glibc defines the following additional errors, some which
#.  can probably be returned by getnameinfo(); they need to
#.  be documented.
#.  #ifdef __USE_GNU
#.  #define EAI_INPROGRESS  -100  /* Processing request in progress.  */
#.  #define EAI_CANCELED    -101  /* Request canceled.  */
#.  #define EAI_NOTCANCELED -102  /* Request not canceled.  */
#.  #define EAI_ALLDONE     -103  /* All requests done.  */
#.  #define EAI_INTR        -104  /* Interrupted by a signal.  */
#.  #define EAI_IDN_ENCODE  -105  /* IDN encoding failed.  */
#.  #endif
#. type: Plain text
#: build/C/man3/getnameinfo.3:152
msgid ""
"On success 0 is returned, and node and service names, if requested, are "
"filled with null-terminated strings, possibly truncated to fit the specified "
"buffer lengths.  On error one of the following nonzero error codes is "
"returned:"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:156
msgid "The name could not be resolved at this time.  Try again later."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:161
msgid "The I<flags> argument has an invalid value."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:164
msgid "A nonrecoverable error occurred."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:168
msgid ""
"The address family was not recognized, or the address length was invalid for "
"the specified family."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:177
msgid ""
"The name does not resolve for the supplied arguments.  B<NI_NAMEREQD> is set "
"and the host's name cannot be located, or neither hostname nor service name "
"were requested."
msgstr ""

#. type: TP
#: build/C/man3/getnameinfo.3:177
#, no-wrap
msgid "B<EAI_OVERFLOW>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:184
msgid "The buffer pointed to by I<host> or I<serv> was too small."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:189
msgid "A system error occurred.  The error code can be found in I<errno>."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:196
msgid "/etc/hosts"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:198
msgid "/etc/nsswitch.conf"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:200
msgid "/etc/resolv.conf"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:203
msgid "B<getnameinfo>()  is provided in glibc since version 2.1."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:205
msgid "RFC\\ 2553, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:210
msgid ""
"In order to assist the programmer in choosing reasonable sizes for the "
"supplied buffers, I<E<lt>netdb.hE<gt>> defines the constants"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:215
#, no-wrap
msgid ""
"#define NI_MAXHOST      1025\n"
"#define NI_MAXSERV      32\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:225
msgid ""
"Since glibc 2.8, these definitions are exposed only if one of the feature "
"test macros B<_BSD_SOURCE>, B<_SVID_SOURCE>, or B<_GNU_SOURCE> is defined."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:233
msgid ""
"The former is the constant B<MAXDNAME> in recent versions of BIND's "
"I<E<lt>arpa/nameser.hE<gt>> header file.  The latter is a guess based on the "
"services listed in the current Assigned Numbers RFC."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:238
msgid ""
"The following code tries to get the numeric hostname and service name, for a "
"given socket address.  Note that there is no hardcoded reference to a "
"particular address family."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:244
#, no-wrap
msgid ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;         /* input */\n"
"char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:248
#, no-wrap
msgid ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf), sbuf,\n"
"            sizeof(sbuf), NI_NUMERICHOST | NI_NUMERICSERV) == 0)\n"
"    printf(\"host=%s, serv=%s\\en\", hbuf, sbuf);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:253
msgid ""
"The following version checks if the socket address has a reverse address "
"mapping."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:259
#, no-wrap
msgid ""
"struct sockaddr *sa;    /* input */\n"
"socklen_t len;         /* input */\n"
"char hbuf[NI_MAXHOST];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:265
#, no-wrap
msgid ""
"if (getnameinfo(sa, len, hbuf, sizeof(hbuf),\n"
"            NULL, 0, NI_NAMEREQD))\n"
"    printf(\"could not resolve hostname\");\n"
"else\n"
"    printf(\"host=%s\\en\", hbuf);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:272
msgid ""
"An example program using B<getnameinfo>()  can be found in "
"B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:287
msgid ""
"B<accept>(2), B<getpeername>(2), B<getsockname>(2), B<recvfrom>(2), "
"B<socket>(2), B<getaddrinfo>(3), B<gethostbyaddr>(3), B<getservbyname>(3), "
"B<getservbyport>(3), B<inet_ntop>(3), B<hosts>(5), B<services>(5), "
"B<hostname>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:291
msgid ""
"R. Gilligan, S. Thomson, J. Bound and W. Stevens, I<Basic Socket Interface "
"Extensions for IPv6>, RFC\\ 2553, March 1999."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:296
msgid ""
"Tatsuya Jinmei and Atsushi Onoe, I<An Extension of Format for IPv6 Scoped "
"Addresses>, internet draft, work in progress.  "
"ftp://ftp.ietf.org/internet-drafts/draft-ietf-ipngwg-scopedaddr-format-02.txt"
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:301
msgid ""
"Craig Metz, I<Protocol Independence Using the Sockets API>, Proceedings of "
"the freenix track: 2000 USENIX annual technical conference, June 2000."
msgstr ""

#. type: Plain text
#: build/C/man3/getnameinfo.3:303
msgid "http://www.usenix.org/publications/library/proceedings/usenix2000/freenix/metzprotocol.html"
msgstr ""

#. type: TH
#: build/C/man3/getnetent.3:28
#, no-wrap
msgid "GETNETENT"
msgstr ""

#. type: TH
#: build/C/man3/getnetent.3:28 build/C/man3/getprotoent.3:28 build/C/man3/getservent.3:32
#, no-wrap
msgid "2008-08-19"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:32
msgid ""
"getnetent, getnetbyname, getnetbyaddr, setnetent, endnetent - get network "
"entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:35 build/C/man3/getnetent_r.3:31 build/C/man3/getprotoent.3:35 build/C/man3/getprotoent_r.3:31 build/C/man3/getservent.3:39 build/C/man3/getservent_r.3:31 build/C/man3/setnetgrent.3:12
#, no-wrap
msgid "B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:37
#, no-wrap
msgid "B<struct netent *getnetent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:39
#, no-wrap
msgid "B<struct netent *getnetbyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:41
#, no-wrap
msgid "B<struct netent *getnetbyaddr(uint32_t >I<net>B<, int >I<type>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:43
#, no-wrap
msgid "B<void setnetent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:45
#, no-wrap
msgid "B<void endnetent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:53
msgid ""
"The B<getnetent>()  function reads the next entry from the networks database "
"and returns a I<netent> structure containing the broken-out fields from the "
"entry.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:59
msgid ""
"The B<getnetbyname>()  function returns a I<netent> structure for the entry "
"from the database that matches the network I<name>."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:69
msgid ""
"The B<getnetbyaddr>()  function returns a I<netent> structure for the entry "
"from the database that matches the network number I<net> of type I<type>.  "
"The I<net> argument must be in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:79
msgid ""
"The B<setnetent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getnet*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:83
msgid "The B<endnetent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:85
msgid "The I<netent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:94
#, no-wrap
msgid ""
"struct netent {\n"
"    char      *n_name;     /* official network name */\n"
"    char     **n_aliases;  /* alias list */\n"
"    int        n_addrtype; /* net address type */\n"
"    uint32_t   n_net;      /* network number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:98
msgid "The members of the I<netent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:98
#, no-wrap
msgid "I<n_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:101
msgid "The official name of the network."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:101
#, no-wrap
msgid "I<n_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:104
msgid "A NULL-terminated list of alternative names for the network."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:104
#, no-wrap
msgid "I<n_addrtype>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:108
msgid "The type of the network number; always B<AF_INET>."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:108
#, no-wrap
msgid "I<n_net>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:111
msgid "The network number in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:120
msgid ""
"The B<getnetent>(), B<getnetbyname>()  and B<getnetbyaddr>()  functions "
"return a pointer to a statically allocated I<netent> structure, or a NULL "
"pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: build/C/man3/getnetent.3:121 build/C/man5/networks.5:70
#, no-wrap
msgid "I</etc/networks>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:124
msgid "networks database file"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:126 build/C/man3/getprotoent.3:122 build/C/man3/getservent.3:131
msgid "4.3BSD, POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:133
msgid ""
"In glibc versions before 2.2, the I<net> argument of B<getnetbyaddr>()  was "
"of type I<long>."
msgstr ""

#.  .BR networks (5)
#. type: Plain text
#: build/C/man3/getnetent.3:138
msgid "B<getnetent_r>(3), B<getprotoent>(3), B<getservent>(3)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent.3:140
msgid "RFC\\ 1101"
msgstr ""

#. type: TH
#: build/C/man3/getnetent_r.3:24
#, no-wrap
msgid "GETNETENT_R"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:28
msgid "getnetent_r, getnetbyname_r, getnetbyaddr_r - get network entry (reentrant)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:35
#, no-wrap
msgid ""
"B<int getnetent_r(struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:40
#, no-wrap
msgid ""
"B<int getnetbyname_r(const char *>I<name>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:45
#, no-wrap
msgid ""
"B<int getnetbyaddr_r(uint32_t >I<net>B<, int >I<type>B<,>\n"
"B<                struct netent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct netent **>I<result>B<,>\n"
"B<                int *>I<h_errnop>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:56
msgid "B<getnetent_r>(), B<getnetbyname_r>(), B<getnetbyaddr_r>():"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:77
msgid ""
"The B<getnetent_r>(), B<getnetbyname_r>(), and B<getnetbyaddr_r>()  "
"functions are the reentrant equivalents of, respectively, B<getnetent>(3), "
"B<getnetbyname>(3), and B<getnetbynumber>(3).  They differ in the way that "
"the I<netent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:83
msgid ""
"Instead of returning a pointer to a statically allocated I<netent> structure "
"as the function result, these functions copy the structure into the location "
"pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getnetent_r.3:100
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<netent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:108
msgid ""
"If the function call successfully obtains a network record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#.  getnetent.3 doesn't document any use of h_errno, but nevertheless
#.  the nonreentrant functions no seem to set h_errno.
#. type: Plain text
#: build/C/man3/getnetent_r.3:116
msgid ""
"The buffer pointed to by I<h_errnop> is used to return the value that would "
"be stored in the global variable I<h_errno> by the nonreentrant versions of "
"these functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:119 build/C/man3/getprotoent_r.3:109
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in ERRORS."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:127
msgid ""
"On error, record not found (B<getnetbyname_r>(), B<getnetbyaddr_r>()), or "
"end of input (B<getnetent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:132
msgid "(B<getnetent_r>())  No more records in database."
msgstr ""

#. type: TP
#: build/C/man3/getnetent_r.3:132 build/C/man3/getprotoent_r.3:122 build/C/man3/getservent_r.3:121
#, no-wrap
msgid "B<ERANGE>"
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:139 build/C/man3/getprotoent_r.3:129 build/C/man3/getservent_r.3:128
msgid ""
"I<buf> is too small.  Try again with a larger buffer (and increased "
"I<buflen>)."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:143 build/C/man3/getprotoent_r.3:133 build/C/man3/getservent_r.3:132
msgid ""
"These functions are GNU extensions.  Functions with similar names exist on "
"some other systems, though typically with different calling signatures."
msgstr ""

#. type: Plain text
#: build/C/man3/getnetent_r.3:146
msgid "B<getnetent>(3), B<networks>(5)"
msgstr ""

#. type: TH
#: build/C/man2/getpeername.2:40
#, no-wrap
msgid "GETPEERNAME"
msgstr ""

#. type: TH
#: build/C/man2/getpeername.2:40 build/C/man2/shutdown.2:38 build/C/man7/udplite.7:25
#, no-wrap
msgid "2008-12-03"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:43
msgid "getpeername - get name of connected peer socket"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:48
msgid ""
"B<int getpeername(int >I<sockfd>B<, struct sockaddr *>I<addr>B<, socklen_t "
"*>I<addrlen>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:61
msgid ""
"B<getpeername>()  returns the address of the peer connected to the socket "
"I<sockfd>, in the buffer pointed to by I<addr>.  The I<addrlen> argument "
"should be initialized to indicate the amount of space pointed to by "
"I<addr>.  On return it contains the actual size of the name returned (in "
"bytes).  The name is truncated if the buffer provided is too small."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:66
msgid ""
"The returned address is truncated if the buffer provided is too small; in "
"this case, I<addrlen> will return a value greater than was supplied to the "
"call."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:71 build/C/man2/shutdown.2:72
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:72 build/C/man2/shutdown.2:73
#, no-wrap
msgid "B<EBADF>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:77
msgid "The argument I<sockfd> is not a valid descriptor."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:77 build/C/man7/packet.7:245 build/C/man7/raw.7:145 build/C/man7/unix.7:332
#, no-wrap
msgid "B<EFAULT>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:83
msgid ""
"The I<addr> argument points to memory not in a valid part of the process "
"address space."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:87
msgid "I<addrlen> is invalid (e.g., is negative)."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:87 build/C/man7/packet.7:257
#, no-wrap
msgid "B<ENOBUFS>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:91
msgid ""
"Insufficient resources were available in the system to perform the "
"operation."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:94
msgid "The socket is not connected."
msgstr ""

#. type: TP
#: build/C/man2/getpeername.2:94 build/C/man2/shutdown.2:80
#, no-wrap
msgid "B<ENOTSOCK>"
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:99
msgid "The argument I<sockfd> is a file, not a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:103
msgid ""
"SVr4, 4.4BSD (the B<getpeername>()  function call first appeared in 4.2BSD), "
"POSIX.1-2001."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:114
msgid ""
"The third argument of B<getpeername>()  is in reality an I<int *> (and this "
"is what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion resulted in "
"the present I<socklen_t>, also used by glibc.  See also B<accept>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/getpeername.2:121
msgid ""
"B<accept>(2), B<bind>(2), B<getsockname>(2), B<ip>(7), B<socket>(7), "
"B<unix>(7)"
msgstr ""

#. type: TH
#: build/C/man3/getprotoent.3:28
#, no-wrap
msgid "GETPROTOENT"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:32
msgid ""
"getprotoent, getprotobyname, getprotobynumber, setprotoent, endprotoent - "
"get protocol entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:37
#, no-wrap
msgid "B<struct protoent *getprotoent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:39
#, no-wrap
msgid "B<struct protoent *getprotobyname(const char *>I<name>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:41
#, no-wrap
msgid "B<struct protoent *getprotobynumber(int >I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:43
#, no-wrap
msgid "B<void setprotoent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:45
#, no-wrap
msgid "B<void endprotoent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:54
msgid ""
"The B<getprotoent>()  function reads the next entry from the protocols "
"database (see B<protocols>(5))  and returns a I<protoent> structure "
"containing the broken-out fields from the entry.  A connection is opened to "
"the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:61
msgid ""
"The B<getprotobyname>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol name I<name>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:68
msgid ""
"The B<getprotobynumber>()  function returns a I<protoent> structure for the "
"entry from the database that matches the protocol number I<number>.  A "
"connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:78
msgid ""
"The B<setprotoent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getproto*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:82
msgid "The B<endprotoent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:84
msgid "The I<protoent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:92
#, no-wrap
msgid ""
"struct protoent {\n"
"    char  *p_name;       /* official protocol name */\n"
"    char **p_aliases;    /* alias list */\n"
"    int    p_proto;      /* protocol number */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:96
msgid "The members of the I<protoent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:96
#, no-wrap
msgid "I<p_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:99
msgid "The official name of the protocol."
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:99
#, no-wrap
msgid "I<p_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:102
msgid "A NULL-terminated list of alternative names for the protocol."
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:102
#, no-wrap
msgid "I<p_proto>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:105
msgid "The protocol number."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:114
msgid ""
"The B<getprotoent>(), B<getprotobyname>()  and B<getprotobynumber>()  "
"functions return a pointer to a statically allocated I<protoent> structure, "
"or a NULL pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: build/C/man3/getprotoent.3:116 build/C/man5/protocols.5:77
#, no-wrap
msgid "I</etc/protocols>"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:119
msgid "protocol database file"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent.3:127
msgid "B<getnetent>(3), B<getprotoent_r>(3), B<getservent>(3), B<protocols>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getprotoent_r.3:24
#, no-wrap
msgid "GETPROTOENT_R"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:28
msgid ""
"getprotoent_r, getprotobyname_r, getprotobynumber_r - get protocol entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:34
#, no-wrap
msgid ""
"B<int getprotoent_r(struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:38
#, no-wrap
msgid ""
"B<int getprotobyname_r(const char *>I<name>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:42
#, no-wrap
msgid ""
"B<int getprotobynumber_r(int >I<proto>B<,>\n"
"B<                struct protoent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct protoent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:53
msgid "B<getprotoent_r>(), B<getprotobyname_r>(), B<getprotobynumber_r>():"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:74
msgid ""
"The B<getprotoent_r>(), B<getprotobyname_r>(), and B<getprotobynumber_r>()  "
"functions are the reentrant equivalents of, respectively, B<getprotoent>(3), "
"B<getprotobyname>(3), and B<getprotobynumber>(3).  They differ in the way "
"that the I<protoent> structure is returned, and in the function calling "
"signature and return value.  This manual page describes just the differences "
"from the nonreentrant functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:80
msgid ""
"Instead of returning a pointer to a statically allocated I<protoent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer.
#.  The 1024 byte value is also what the Solaris man page suggests. -- mtk
#. type: Plain text
#: build/C/man3/getprotoent_r.3:98
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<protoent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:106
msgid ""
"If the function call successfully obtains a protocol record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:117
msgid ""
"On error, record not found (B<getprotobyname_r>(), B<getprotobynumber_r>()), "
"or end of input (B<getprotoent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:122
msgid "(B<getprotoent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:147
msgid ""
"The program below uses B<getprotobyname_r>()  to retrieve the protocol "
"record for the protocol named in its first command-line argument.  If a "
"second (integer) command-line argument is supplied, it is used as the "
"initial value for I<buflen>; if B<getprotobyname_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:158
#, no-wrap
msgid ""
"$B< ./a.out tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=78)\n"
"p_name=tcp; p_proto=6; aliases=TCP\n"
"$B< ./a.out xxx 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getprotobyname_r() returned: 0 (success)  (buflen=100)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:170 build/C/man3/getservent_r.3:168
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>ctype.hE<gt>\n"
"#include E<lt>netdb.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:172 build/C/man3/getservent_r.3:170
#, no-wrap
msgid "#define MAX_BUF 10000\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:181
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, s;\n"
"    struct protoent result_buf;\n"
"    struct protoent *result;\n"
"    char buf[MAX_BUF];\n"
"    char **p;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:186
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        printf(\"Usage: %s proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:190
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 2)\n"
"        buflen = atoi(argv[2]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:195 build/C/man3/getservent_r.3:198
#, no-wrap
msgid ""
"    if (buflen E<gt> MAX_BUF) {\n"
"        printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:204
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getprotobyname_r(argv[1], &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:207 build/C/man3/getservent_r.3:210
#, no-wrap
msgid ""
"            /* Increment a byte at a time so we can see exactly\n"
"               what size buffer was required */\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:209 build/C/man3/getservent_r.3:212
#, no-wrap
msgid "            buflen++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:216 build/C/man3/getservent_r.3:219
#, no-wrap
msgid ""
"            if (buflen E<gt> MAX_BUF) {\n"
"                printf(\"Exceeded buffer limit (%d)\\en\", MAX_BUF);\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
"        }\n"
"    } while (s == ERANGE);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:220
#, no-wrap
msgid ""
"    printf(\"getprotobyname_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:225 build/C/man3/getservent_r.3:228
#, no-wrap
msgid ""
"    if (s != 0 || result == NULL) {\n"
"        printf(\"Call failed/record not found\\en\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:231
#, no-wrap
msgid ""
"    printf(\"p_name=%s; p_proto=%d; aliases=\",\n"
"                result_buf.p_name, result_buf.p_proto);\n"
"    for (p = result_buf.p_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getprotoent_r.3:238
msgid "B<getprotoent>(3), B<protocols>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getservent.3:32
#, no-wrap
msgid "GETSERVENT"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:36
msgid ""
"getservent, getservbyname, getservbyport, setservent, endservent - get "
"service entry"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:41
#, no-wrap
msgid "B<struct servent *getservent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:43
#, no-wrap
msgid ""
"B<struct servent *getservbyname(const char *>I<name>B<, const char "
"*>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:45
#, no-wrap
msgid "B<struct servent *getservbyport(int >I<port>B<, const char *>I<proto>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:47
#, no-wrap
msgid "B<void setservent(int >I<stayopen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:49
#, no-wrap
msgid "B<void endservent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:58
msgid ""
"The B<getservent>()  function reads the next entry from the services "
"database (see B<services>(5))  and returns a I<servent> structure containing "
"the broken-out fields from the entry.  A connection is opened to the "
"database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:66
msgid ""
"The B<getservbyname>()  function returns a I<servent> structure for the "
"entry from the database that matches the service I<name> using protocol "
"I<proto>.  If I<proto> is NULL, any protocol will be matched.  A connection "
"is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:75
msgid ""
"The B<getservbyport>()  function returns a I<servent> structure for the "
"entry from the database that matches the port I<port> (given in network byte "
"order)  using protocol I<proto>.  If I<proto> is NULL, any protocol will be "
"matched.  A connection is opened to the database if necessary."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:85
msgid ""
"The B<setservent>()  function opens a connection to the database, and sets "
"the next entry to the first entry.  If I<stayopen> is nonzero, then the "
"connection to the database will not be closed between calls to one of the "
"B<getserv*>()  functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:89
msgid "The B<endservent>()  function closes the connection to the database."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:91
msgid "The I<servent> structure is defined in I<E<lt>netdb.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:100
#, no-wrap
msgid ""
"struct servent {\n"
"    char  *s_name;       /* official service name */\n"
"    char **s_aliases;    /* alias list */\n"
"    int    s_port;       /* port number */\n"
"    char  *s_proto;      /* protocol to use */\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:104
msgid "The members of the I<servent> structure are:"
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:104
#, no-wrap
msgid "I<s_name>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:107
msgid "The official name of the service."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:107
#, no-wrap
msgid "I<s_aliases>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:110
msgid "A NULL-terminated list of alternative names for the service."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:110
#, no-wrap
msgid "I<s_port>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:113
msgid "The port number for the service given in network byte order."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:113
#, no-wrap
msgid "I<s_proto>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:116
msgid "The name of the protocol to use with this service."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:125
msgid ""
"The B<getservent>(), B<getservbyname>()  and B<getservbyport>()  functions "
"return a pointer to a statically allocated I<servent> structure, or a NULL "
"pointer if an error occurs or the end of the file is reached."
msgstr ""

#. type: TP
#: build/C/man3/getservent.3:126 build/C/man5/services.5:185
#, no-wrap
msgid "I</etc/services>"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:129
msgid "services database file"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent.3:136
msgid "B<getnetent>(3), B<getprotoent>(3), B<getservent_r>(3), B<services>(5)"
msgstr ""

#. type: TH
#: build/C/man3/getservent_r.3:24
#, no-wrap
msgid "GETSERVENT_R"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:28
msgid ""
"getservent_r, getservbyname_r, getservbyport_r - get service entry "
"(reentrant)"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:34
#, no-wrap
msgid ""
"B<int getservent_r(struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:38
#, no-wrap
msgid ""
"B<int getservbyname_r(const char *>I<name>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:42
#, no-wrap
msgid ""
"B<int getservbyport_r(int >I<port>B<, const char *>I<proto>B<,>\n"
"B<                struct servent *>I<result_buf>B<, char *>I<buf>B<,>\n"
"B<                size_t >I<buflen>B<, struct servent **>I<result>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:53
msgid "B<getservent_r>(), B<getservbyname_r>(), B<getservbyport_r>():"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:74
msgid ""
"The B<getservent_r>(), B<getservbyname_r>(), and B<getservbyport_r>()  "
"functions are the reentrant equivalents of, respectively, B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  They differ in the way that "
"the I<servent> structure is returned, and in the function calling signature "
"and return value.  This manual page describes just the differences from the "
"nonreentrant functions."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:80
msgid ""
"Instead of returning a pointer to a statically allocated I<servent> "
"structure as the function result, these functions copy the structure into "
"the location pointed to by I<result_buf>."
msgstr ""

#.  I can find no information on the required/recommended buffer size;
#.  the nonreentrant functions use a 1024 byte buffer -- mtk.
#. type: Plain text
#: build/C/man3/getservent_r.3:97
msgid ""
"The I<buf> array is used to store the string fields pointed to by the "
"returned I<servent> structure.  (The nonreentrant functions allocate these "
"strings in static storage.)  The size of this array is specified in "
"I<buflen>.  If I<buf> is too small, the call fails with the error B<ERANGE>, "
"and the caller must try again with a larger buffer.  (A buffer of length "
"1024 bytes should be sufficient for most applications.)"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:105
msgid ""
"If the function call successfully obtains a service record, then I<*result> "
"is set pointing to I<result_buf>; otherwise, I<*result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:108
msgid ""
"On success, these functions return 0.  On error, they return one of the "
"positive error numbers listed in errors."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:116
msgid ""
"On error, record not found (B<getservbyname_r>(), B<getservbyport_r>()), or "
"end of input (B<getservent_r>())  I<result> is set to NULL."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:121
msgid "(B<getservent_r>())  No more records in database."
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:146
msgid ""
"The program below uses B<getservbyport_r>()  to retrieve the service record "
"for the port and protocol named in its first command-line argument.  If a "
"third (integer) command-line argument is supplied, it is used as the initial "
"value for I<buflen>; if B<getservbyport_r>()  fails with the error "
"B<ERANGE>, the program retries with larger buffer sizes.  The following "
"shell session shows a couple of sample runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:156
#, no-wrap
msgid ""
"$B< ./a.out 7 tcp 1>\n"
"ERANGE! Retrying with larger buffer\n"
"getservbyport_r() returned: 0 (success)  (buflen=87)\n"
"s_name=echo; s_proto=tcp; s_port=7; aliases=\n"
"$B< ./a.out 77777 tcp>\n"
"getservbyport_r() returned: 0 (success)  (buflen=1024)\n"
"Call failed/record not found\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:180
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int buflen, erange_cnt, port, s;\n"
"    struct servent result_buf;\n"
"    struct servent *result;\n"
"    char buf[MAX_BUF];\n"
"    char *protop;\n"
"    char **p;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:185
#, no-wrap
msgid ""
"    if (argc E<lt> 3) {\n"
"        printf(\"Usage: %s port-num proto-name [buflen]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:189
#, no-wrap
msgid ""
"    port = htons(atoi(argv[1]));\n"
"    protop = (strcmp(argv[2], \"null\") == 0 ||\n"
"\t      strcmp(argv[2], \"NULL\") == 0) ?  NULL : argv[2];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:193
#, no-wrap
msgid ""
"    buflen = 1024;\n"
"    if (argc E<gt> 3)\n"
"        buflen = atoi(argv[3]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:207
#, no-wrap
msgid ""
"    erange_cnt = 0;\n"
"    do {\n"
"        s = getservbyport_r(port, protop, &result_buf,\n"
"                     buf, buflen, &result);\n"
"        if (s == ERANGE) {\n"
"            if (erange_cnt == 0)\n"
"                printf(\"ERANGE! Retrying with larger buffer\\en\");\n"
"            erange_cnt++;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:223
#, no-wrap
msgid ""
"    printf(\"getservbyport_r() returned: %s  (buflen=%d)\\en\",\n"
"            (s == 0) ? \"0 (success)\" : (s == ENOENT) ? \"ENOENT\" :\n"
"            strerror(s), buflen);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:235
#, no-wrap
msgid ""
"    printf(\"s_name=%s; s_proto=%s; s_port=%d; aliases=\",\n"
"                result_buf.s_name, result_buf.s_proto,\n"
"                ntohs(result_buf.s_port));\n"
"    for (p = result_buf.s_aliases; *p != NULL; p++)\n"
"        printf(\"%s \", *p);\n"
"    printf(\"\\en\");\n"
msgstr ""

#. type: Plain text
#: build/C/man3/getservent_r.3:242
msgid "B<getservent>(3), B<services>(5)"
msgstr ""

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "HOST.CONF"
msgstr ""

#. type: TH
#: build/C/man5/host.conf.5:26
#, no-wrap
msgid "2003-08-23"
msgstr ""

#. type: TH
#: build/C/man5/host.conf.5:26 build/C/man5/networks.5:24
#, no-wrap
msgid "Linux System Administration"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:29
msgid "host.conf - resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:38
msgid ""
"The file I</etc/host.conf> contains configuration information specific to "
"the resolver library.  It should contain one configuration keyword per line, "
"followed by appropriate configuration information.  The keywords recognized "
"are I<order>, I<trim>, I<multi>, I<nospoof>, I<spoof>, and I<reorder>.  "
"These keywords are described below."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:38
#, no-wrap
msgid "I<order>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:44
msgid ""
"This keyword specifies how host lookups are to be performed.  It should be "
"followed by one or more lookup methods, separated by commas.  Valid methods "
"are I<bind>, I<hosts>, and I<nis>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:44
#, no-wrap
msgid "I<trim>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:61
msgid ""
"This keyword may be listed more than once.  Each time it should be followed "
"by a list of domains, separated by colons (\\(aq:\\(aq), semicolons "
"(\\(aq;\\(aq) or commas (\\(aq,\\(aq), with the leading dot.  When set, the "
"resolv+ library will automatically trim the given domain name from the end "
"of any hostname resolved via DNS.  This is intended for use with local hosts "
"and domains.  (Related note: trim will not affect hostnames gathered via NIS "
"or the hosts file.  Care should be taken to ensure that the first hostname "
"for each entry in the hosts file is fully qualified or unqualified, as "
"appropriate for the local installation.)"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:61
#, no-wrap
msgid "I<multi>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:76
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolv+ library "
"will return all valid addresses for a host that appears in the I</etc/hosts> "
"file, instead of only the first.  This is I<off> by default, as it may cause "
"a substantial performance loss at sites with large hosts files."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:76
#, no-wrap
msgid "I<nospoof>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:91
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, the resolv+ library "
"will attempt to prevent hostname spoofing to enhance the security of "
"B<rlogin> and B<rsh>.  It works as follows: after performing a host address "
"lookup, resolv+ will perform a hostname lookup for that address.  If the two "
"hostnames do not match, the query will fail.  The default value is I<off>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:91
#, no-wrap
msgid "I<spoofalert>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:103
msgid ""
"Valid values are I<on> and I<off>.  If this option is set to I<on> and the "
"I<nospoof> option is also set, resolv+ will log a warning of the error via "
"the syslog facility.  The default value is I<off>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:103
#, no-wrap
msgid "I<spoof>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:122
msgid ""
"Valid values are I<off>, I<nowarn> and I<warn>.  If this option is set to "
"I<off>, spoofed addresses are permitted and no warnings will be emitted via "
"the syslog facility.  If this option is set to I<warn>, resolv+ will attempt "
"to prevent hostname spoofing to enhance the security and log a warning of "
"the error via the syslog facility.  If this option is set to I<nowarn>, the "
"resolv+ library will attempt to prevent hostname spoofing to enhance the "
"security but not emit warnings via the syslog facility.  Setting this option "
"to anything else is equal to setting it to I<nowarn>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:122
#, no-wrap
msgid "I<reorder>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:135
msgid ""
"Valid values are I<on> and I<off>.  If set to I<on>, resolv+ will attempt to "
"reorder host addresses so that local addresses (i.e., on the same subnet) "
"are listed first when a B<gethostbyname>(3)  is performed.  Reordering is "
"done for all lookup methods.  The default value is I<off>."
msgstr ""

#. type: SH
#: build/C/man5/host.conf.5:135
#, no-wrap
msgid "ENVIRONMENT"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:139
msgid ""
"There are six environment variables that can be used to allow users to "
"override the behavior which is configured in I</etc/host.conf>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:139
#, no-wrap
msgid "B<RESOLV_HOST_CONF>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:143
msgid ""
"If set this variable points to a file that should be read instead of "
"I</etc/host.conf>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:143
#, no-wrap
msgid "B<RESOLV_SERV_ORDER>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:148
msgid "Overrides the I<order> command."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:148
#, no-wrap
msgid "B<RESOLV_SPOOF_CHECK>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:157
msgid ""
"Overrides the I<nospoof>, I<spoofalert> and I<spoof> commands in the same "
"way as the I<spoof> command is parsed.  Valid values are I<off>, I<nowarn> "
"and I<warn>."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:157
#, no-wrap
msgid "B<RESOLV_MULTI>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:162
msgid "Overrides the I<multi> command."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:162
#, no-wrap
msgid "B<RESOLV_REORDER>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:167
msgid "Overrides the I<reorder> command."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:167
#, no-wrap
msgid "B<RESOLV_ADD_TRIM_DOMAINS>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:172
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons "
"(\\(aq;\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will be "
"added to the list of domains that should be trimmed."
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:172
#, no-wrap
msgid "B<RESOLV_OVERRIDE_TRIM_DOMAINS>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:180
msgid ""
"A list of domains, separated by colons (\\(aq:\\(aq), semicolons "
"(\\(aq;\\(aq) or commas (\\(aq,\\(aq), with the leading dot, which will "
"replace the list of domains that should be trimmed.  Overrides the I<trim> "
"command."
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:184 build/C/man5/host.conf.5:187
msgid "Resolver configuration file"
msgstr ""

#. type: TP
#: build/C/man5/host.conf.5:184
#, no-wrap
msgid "I</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:190
msgid "Local hosts database"
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:199
msgid ""
"The following differences exist compared to the original implementation.  A "
"new command I<spoof> and a new environment variable B<RESOLV_SPOOF_CHECK> "
"can take arguments like I<off>, I<nowarn> and I<warn>.  Line comments can "
"appear anywhere and not only at the beginning of a line."
msgstr ""

#. type: Plain text
#: build/C/man5/host.conf.5:204
msgid "B<gethostbyname>(3), B<hostname>(7), B<named>(8), B<resolv+>(8)"
msgstr ""

#. type: TH
#: build/C/man7/hostname.7:37
#, no-wrap
msgid "HOSTNAME"
msgstr ""

#. type: TH
#: build/C/man7/hostname.7:37
#, no-wrap
msgid "2010-11-07"
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:40
msgid "hostname - hostname resolution description"
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:44
msgid ""
"Hostnames are domains, where a domain is a hierarchical, dot-separated list "
"of subdomains; for example, the machine monet, in the Berkeley subdomain of "
"the EDU domain would be represented as \"monet.Berkeley.EDU\"."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:53
msgid ""
"Hostnames are often used with network client and server programs, which must "
"generally translate the name to an address for use.  (This task is generally "
"performed by either B<getaddrinfo>(3)  or the obsolete B<gethostbyname>(3).)  "
"Hostnames are resolved by the Internet name resolver in the following "
"fashion."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:66
msgid ""
"If the name consists of a single component, that is, contains no dot, and if "
"the environment variable B<HOSTALIASES> is set to the name of a file, that "
"file is searched for any string matching the input hostname.  The file "
"should consist of lines made up of two white-space separated strings, the "
"first of which is the hostname alias, and the second of which is the "
"complete hostname to be substituted for that alias.  If a case-insensitive "
"match is found between the hostname to be resolved and the first field of a "
"line in the file, the substituted name is looked up with no further "
"processing."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:70
msgid ""
"If the input name ends with a trailing dot, the trailing dot is removed, and "
"the remaining name is looked up with no further processing."
msgstr ""

#. type: Plain text
#: build/C/man7/hostname.7:83
msgid ""
"If the input name does not end with a trailing dot, it is looked up by "
"searching through a list of domains until a match is found.  The default "
"search list includes first the local domain, then its parent domains with at "
"least 2 name components (longest first).  For example, in the domain "
"CS.Berkeley.EDU, the name lithium.CChem will be checked first as "
"lithium.CChem.CS.Berkeley.EDU and then as lithium.CChem.Berkeley.EDU.  "
"Lithium.CChem.EDU will not be tried, as there is only one component "
"remaining from the local domain.  The search path can be changed from the "
"default by a system-wide configuration file (see B<resolver>(5))."
msgstr ""

#.  .SH HISTORY
#.  Hostname appeared in
#.  4.2BSD.
#. type: Plain text
#: build/C/man7/hostname.7:91
msgid "B<gethostbyname>(3), B<resolver>(5), B<mailaddr>(7), B<named>(8)"
msgstr ""

#. type: TH
#: build/C/man5/hosts.5:27
#, no-wrap
msgid "HOSTS"
msgstr ""

#. type: TH
#: build/C/man5/hosts.5:27
#, no-wrap
msgid "2002-06-16"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:30
msgid "hosts - static table lookup for hostnames"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:32
msgid "B</etc/hosts>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:40
msgid ""
"This manual page describes the format of the I</etc/hosts> file.  This file "
"is a simple text file that associates IP addresses with hostnames, one line "
"per IP address.  For each host a single line should be present with the "
"following information:"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:43
msgid "IP_address canonical_hostname [aliases...]"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:56
msgid ""
"Fields of the entry are separated by any number of blanks and/or tab "
"characters.  Text from a \"#\" character until the end of the line is a "
"comment, and is ignored.  Host names may contain only alphanumeric "
"characters, minus signs (\"-\"), and periods (\".\").  They must begin with "
"an alphabetic character and end with an alphanumeric character.  Optional "
"aliases provide for name changes, alternate spellings, shorter hostnames, or "
"generic hostnames (for example, I<localhost>)."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:64
msgid ""
"The Berkeley Internet Name Domain (BIND) Server implements the Internet name "
"server for UNIX systems.  It augments or replaces the I</etc/hosts> file or "
"hostname lookup, and frees a host from relying on I</etc/hosts> being up to "
"date and complete."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:67
msgid ""
"In modern systems, even though the host table has been superseded by DNS, it "
"is still widely used for:"
msgstr ""

#. type: TP
#: build/C/man5/hosts.5:67
#, no-wrap
msgid "B<bootstrapping>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:73
msgid ""
"Most systems have a small host table containing the name and address "
"information for important hosts on the local network.  This is useful when "
"DNS is not running, for example during system bootup."
msgstr ""

#. type: TP
#: build/C/man5/hosts.5:73
#, no-wrap
msgid "B<NIS>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:79
msgid ""
"Sites that use NIS use the host table as input to the NIS host database.  "
"Even though NIS can be used with DNS, most NIS sites still use the host "
"table with an entry for all local hosts as a backup."
msgstr ""

#. type: TP
#: build/C/man5/hosts.5:79
#, no-wrap
msgid "B<isolated nodes>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:86
msgid ""
"Very small sites that are isolated from the network use the host table "
"instead of DNS.  If the local information rarely changes, and the network is "
"not connected to the Internet, DNS offers little advantage."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:91
msgid ""
"Modifications to this file normally take effect immediately, except in cases "
"where the file is cached by applications."
msgstr ""

#. type: SS
#: build/C/man5/hosts.5:91
#, no-wrap
msgid "Historical Notes"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:94
msgid ""
"RFC\\ 952 gave the original format for the host table, though it has since "
"changed."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:107
msgid ""
"Before the advent of DNS, the host table was the only way of resolving "
"hostnames on the fledgling Internet.  Indeed, this file could be created "
"from the official host data base maintained at the Network Information "
"Control Center (NIC), though local changes were often required to bring it "
"up to date regarding unofficial aliases and/or unknown hosts.  The NIC no "
"longer maintains the hosts.txt files, though looking around at the time of "
"writing (circa 2000), there are historical hosts.txt files on the WWW.  I "
"just found three, from 92, 94, and 95."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.5:114
#, no-wrap
msgid ""
"127.0.0.1       localhost\n"
"192.168.1.10    foo.mydomain.org       foo\n"
"192.168.1.13    bar.mydomain.org       bar\n"
"146.82.138.7    master.debian.org      master\n"
"209.237.226.90  www.opensource.org\n"
msgstr ""

#.  .SH AUTHOR
#.  This manual page was written by Manoj Srivastava <srivasta@debian.org>,
#.  for the Debian GNU/Linux system.
#. type: Plain text
#: build/C/man5/hosts.5:125
msgid ""
"B<hostname>(1), B<resolver>(3), B<resolver>(5), B<hostname>(7), B<named>(8), "
"Internet RFC\\ 952"
msgstr ""

#. type: TH
#: build/C/man5/hosts.equiv.5:3
#, no-wrap
msgid "HOSTS.EQUIV"
msgstr ""

#. type: TH
#: build/C/man5/hosts.equiv.5:3
#, no-wrap
msgid "2003-08-24"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:7
msgid ""
"/etc/hosts.equiv - list of hosts and users that are granted \"trusted\" B<r> "
"command access to your system"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:11
msgid ""
"The B<hosts.equiv> file allows or denies hosts and users to use the "
"B<r>-commands (e.g., B<rlogin>, B<rsh> or B<rcp>) without supplying a "
"password."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:13
msgid "The file uses the following format:"
msgstr ""

#. type: TP
#: build/C/man5/hosts.equiv.5:13
#, no-wrap
msgid "I<[ + | - ]> I<[hostname]> I<[username]>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:27
msgid ""
"The I<hostname> is the name of a host which is logically equivalent to the "
"local host.  Users logged into that host are allowed to access like-named "
"user accounts on the local host without supplying a password.  The "
"I<hostname> may be (optionally) preceded by a plus (+) sign.  If the plus "
"sign is used alone it allows any host to access your system.  You can "
"explicitly deny access to a host by preceding the I<hostname> by a minus (-) "
"sign.  Users from that host must always supply a password.  For security "
"reasons you should always use the FQDN of the hostname and not the short "
"hostname."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:39
msgid ""
"The I<username> entry grants a specific user access to all user accounts "
"(except root) without supplying a password.  That means the user is NOT "
"restricted to like-named accounts.  The I<username> may be (optionally) "
"preceded by a plus (+) sign.  You can also explicitly deny access to a "
"specific user by preceding the I<username> with a minus (-) sign.  This says "
"that the user is not trusted no matter what other entries for that host "
"exist."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:41
msgid "Netgroups can be specified by preceding the netgroup by an @ sign."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:47
msgid ""
"Be extremely careful when using the plus (+) sign.  A simple typographical "
"error could result in a standalone plus sign.  A standalone plus sign is a "
"wildcard character that means \"any host\"!"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:49
msgid "I</etc/hosts.equiv>"
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:54
msgid ""
"Some systems will only honor the contents of this file when it has owner "
"root and no write permission for anybody else.  Some exceptionally paranoid "
"systems even require that there be no other hard links to the file."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:62
msgid ""
"Modern systems use the Pluggable Authentication Modules library (PAM).  With "
"PAM a standalone plus sign is only considered a wildcard character which "
"means \"any host\" when the word I<promiscuous> is added to the auth "
"component line in your PAM file for the particular service (e.g., "
"B<rlogin>)."
msgstr ""

#. type: Plain text
#: build/C/man5/hosts.equiv.5:66
msgid "B<rhosts>(5), B<rlogind>(8), B<rshd>(8)"
msgstr ""

#. type: TH
#: build/C/man7/icmp.7:7
#, no-wrap
msgid "ICMP"
msgstr ""

#. type: TH
#: build/C/man7/icmp.7:7 build/C/man7/ipv6.7:7 build/C/man8/nscd.8:23 build/C/man7/packet.7:7 build/C/man7/raw.7:9 build/C/man7/unix.7:15 build/C/man7/x25.7:7
#, no-wrap
msgid "2012-05-10"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:10
msgid "icmp - Linux IPv4 ICMP kernel module."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:18
msgid ""
"This kernel protocol module implements the Internet Control Message Protocol "
"defined in RFC\\ 792.  It is used to signal error conditions and for "
"diagnosis.  The user doesn't interact directly with this module; instead it "
"communicates with the other protocols in the kernel and these pass the ICMP "
"errors to the application layers.  The kernel ICMP module also answers ICMP "
"requests."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:30
msgid ""
"A user protocol may receive ICMP packets for all local sockets by opening a "
"raw socket with the protocol B<IPPROTO_ICMP>.  See B<raw>(7)  for more "
"information.  The types of ICMP packets passed to the socket can be filtered "
"using the B<ICMP_FILTER> socket option.  ICMP packets are always processed "
"by the kernel too, even when passed to a user socket."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:36
msgid ""
"Linux limits the rate of ICMP error packets to each destination.  "
"B<ICMP_REDIRECT> and B<ICMP_DEST_UNREACH> are also limited by the "
"destination route of the incoming packets."
msgstr ""

#.  FIXME better description needed
#. type: Plain text
#: build/C/man7/icmp.7:49
msgid ""
"ICMP supports a set of I</proc> interfaces to configure some global IP "
"parameters.  The parameters can be accessed by reading or writing files in "
"the directory I</proc/sys/net/ipv4/>.  Most of these parameters are rate "
"limitations for specific ICMP types.  Linux 2.2 uses a token bucket filter "
"to limit ICMPs.  The value is the timeout in jiffies until the token bucket "
"filter is cleared after a burst.  A jiffy is a system dependent unit, "
"usually 10ms on i386 and about 1ms on alpha and ia64."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:49
#, no-wrap
msgid "I<icmp_destunreach_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:58
msgid ""
"Maximum rate to send ICMP Destination Unreachable packets.  This limits the "
"rate at which packets are sent to any individual route or destination.  The "
"limit does not affect sending of B<ICMP_FRAG_NEEDED> packets needed for path "
"MTU discovery."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:58
#, no-wrap
msgid "I<icmp_echo_ignore_all> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:64
msgid "If this value is nonzero, Linux will ignore all B<ICMP_ECHO> requests."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:64
#, no-wrap
msgid "I<icmp_echo_ignore_broadcasts> (since Linux 2.2)"
msgstr ""

#.  Precisely: from 2.1.68
#. type: Plain text
#: build/C/man7/icmp.7:70
msgid ""
"If this value is nonzero, Linux will ignore all B<ICMP_ECHO> packets sent to "
"broadcast addresses."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:70
#, no-wrap
msgid "I<icmp_echoreply_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:78
msgid ""
"Maximum rate for sending B<ICMP_ECHOREPLY> packets in response to "
"B<ICMP_ECHOREQUEST> packets."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:78
#, no-wrap
msgid ""
"I<icmp_errors_use_inbound_ifaddr> (Boolean; default: disabled; since Linux "
"2.6.12)"
msgstr ""

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:83
msgid ""
"If disabled, ICMP error messages are sent with the primary address of the "
"exiting interface."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:89
msgid ""
"If enabled, the message will be sent with the primary address of the "
"interface that received the packet that caused the ICMP error.  This is the "
"behavior that many network administrators will expect from a router.  And it "
"can make debugging complicated network layouts much easier."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:93
msgid ""
"Note that if no primary address exists for the interface selected, then the "
"primary address of the first non-loopback interface that has one will be "
"used regardless of this setting."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:93
#, no-wrap
msgid ""
"I<icmp_ignore_bogus_error_responses> (Boolean; default: disabled; since "
"Linux 2.2)"
msgstr ""

#.  precisely: since 2.1.32
#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:101
msgid ""
"Some routers violate RFC1122 by sending bogus responses to broadcast "
"frames.  Such violations are normally logged via a kernel warning.  If this "
"parameter is enabled, the kernel will not give such warnings, which will "
"avoid log file clutter."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:101
#, no-wrap
msgid "I<icmp_paramprob_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#.  Precisely: from 2.1.102
#. type: Plain text
#: build/C/man7/icmp.7:108
msgid ""
"Maximum rate for sending B<ICMP_PARAMETERPROB> packets.  These packets are "
"sent when a packet arrives with an invalid IP header."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:108
#, no-wrap
msgid "I<icmp_ratelimit> (integer; default: 1000; since Linux 2.4.10)"
msgstr ""

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:116
msgid ""
"Limit the maximum rates for sending ICMP packets whose type matches "
"I<icmp_ratemask> (see below) to specific targets.  0 to disable any "
"limiting, otherwise the minimum space between responses in milliseconds."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:116
#, no-wrap
msgid "I<icmp_ratemask> (integer; default: see below; since Linux 2.4.10)"
msgstr ""

#.  The following taken from 2.6.28-rc4 Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/icmp.7:120
msgid "Mask made of ICMP types for which rates are being limited."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:122
msgid "Significant bits: IHGFEDCBA9876543210"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:124
msgid "Default mask: 0000001100000011000 (0x1818)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:127
msgid "Bit definitions (see the kernel source file I<include/linux/icmp.h>):"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:143
#, no-wrap
msgid ""
"0 Echo Reply\n"
"3 Destination Unreachable *\n"
"4 Source Quench *\n"
"5 Redirect\n"
"8 Echo Request\n"
"B Time Exceeded *\n"
"C Parameter Problem *\n"
"D Timestamp Request\n"
"E Timestamp Reply\n"
"F Info Request\n"
"G Info Reply\n"
"H Address Mask Request\n"
"I Address Mask Reply\n"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:148
msgid ""
"The bits marked with an asterisk are rate limited by default (see the "
"default mask above)."
msgstr ""

#. type: TP
#: build/C/man7/icmp.7:148
#, no-wrap
msgid "I<icmp_timeexceed_rate> (Linux 2.2 to 2.4.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:155
msgid ""
"Maximum rate for sending B<ICMP_TIME_EXCEEDED> packets.  These packets are "
"sent to prevent loops when a packet has crossed too many hops."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:159
msgid "Support for the B<ICMP_ADDRESS> request was removed in 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:163
msgid "Support for B<ICMP_SOURCE_QUENCH> was removed in Linux 2.2."
msgstr ""

#.  not really true ATM
#.  .PP
#.  Linux ICMP should be compliant to RFC 1122.
#. type: Plain text
#: build/C/man7/icmp.7:171
msgid ""
"As many other implementations don't support B<IPPROTO_ICMP> raw sockets, "
"this feature should not be relied on in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:176
msgid ""
"B<ICMP_REDIRECT> packets are not sent when Linux is not acting as a router.  "
"They are also only accepted from the old gateway defined in the routing "
"table and the redirect routes are expired after some time."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:180
msgid ""
"The 64-bit timestamp returned by B<ICMP_TIMESTAMP> is in milliseconds since "
"the Epoch, 1970-01-01 00:00:00 +0000 (UTC)."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:185
msgid ""
"Linux ICMP internally uses a raw socket to send ICMPs.  This raw socket may "
"appear in B<netstat>(8)  output with a zero inode."
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:187
msgid "B<ip>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/icmp.7:189
msgid "RFC\\ 792 for a description of the ICMP protocol."
msgstr ""

#. type: TH
#: build/C/man3/inet.3:42
#, no-wrap
msgid "INET"
msgstr ""

#. type: TH
#: build/C/man3/inet.3:42
#, no-wrap
msgid "2008-06-19"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:46
msgid ""
"inet_aton, inet_addr, inet_network, inet_ntoa, inet_makeaddr, inet_lnaof, "
"inet_netof - Internet address manipulation routines"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:51
#, no-wrap
msgid ""
"B<#include E<lt>sys/socket.hE<gt>>\n"
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/inet.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:53
#, no-wrap
msgid "B<int inet_aton(const char *>I<cp>B<, struct in_addr *>I<inp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:55
#, no-wrap
msgid "B<in_addr_t inet_addr(const char *>I<cp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:57
#, no-wrap
msgid "B<in_addr_t inet_network(const char *>I<cp>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:59
#, no-wrap
msgid "B<char *inet_ntoa(struct in_addr >I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:61
#, no-wrap
msgid "B<struct in_addr inet_makeaddr(int >I<net>B<, int >I<host>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:63
#, no-wrap
msgid "B<in_addr_t inet_lnaof(struct in_addr >I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:65
#, no-wrap
msgid "B<in_addr_t inet_netof(struct in_addr >I<in>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:75
msgid "B<inet_aton>(), B<inet_ntoa>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:85
msgid ""
"B<inet_aton>()  converts the Internet host address I<cp> from the IPv4 "
"numbers-and-dots notation into binary form (in network byte order)  and "
"stores it in the structure that I<inp> points to.  B<inet_aton>()  returns "
"nonzero if the address is valid, zero if not.  The address supplied in I<cp> "
"can have one of the following forms:"
msgstr ""

#. type: TP
#: build/C/man3/inet.3:85
#, no-wrap
msgid "I<a.b.c.d>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:89
msgid ""
"Each of the four numeric parts specifies a byte of the address; the bytes "
"are assigned in left-to-right order to produce the binary address."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:89
#, no-wrap
msgid "I<a.b.c>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:102
msgid ""
"Parts I<a> and I<b> specify the first two bytes of the binary address.  Part "
"I<c> is interpreted as a 16-bit value that defines the rightmost two bytes "
"of the binary address.  This notation is suitable for specifying (outmoded) "
"Class B network addresses."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:102
#, no-wrap
msgid "I<a.b>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:113
msgid ""
"Part I<a> specifies the first byte of the binary address.  Part I<b> is "
"interpreted as a 24-bit value that defines the rightmost three bytes of the "
"binary address.  This notation is suitable for specifying (outmoded) Class C "
"network addresses."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:113
#, no-wrap
msgid "I<a>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:119
msgid ""
"The value I<a> is interpreted as a 32-bit value that is stored directly into "
"the binary address without any byte rearrangement."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:132
msgid ""
"In all of the above forms, components of the dotted address can be specified "
"in decimal, octal (with a leading I<0>), or hexadecimal, with a leading "
"I<0X>).  Addresses in any of these forms are collectively termed I<IPV4 "
"numbers-and-dots notation>.  The form that uses exactly four decimal numbers "
"is referred to as I<IPv4 dotted-decimal notation> (or sometimes: I<IPv4 "
"dotted-quad notation>)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:149
msgid ""
"The B<inet_addr>()  function converts the Internet host address I<cp> from "
"IPv4 numbers-and-dots notation into binary data in network byte order.  If "
"the input is invalid, B<INADDR_NONE> (usually -1) is returned.  Use of this "
"function is problematic because -1 is a valid address (255.255.255.255).  "
"Avoid its use in favor of B<inet_aton>(), B<inet_pton>(3), or "
"B<getaddrinfo>(3)  which provide a cleaner way to indicate error return."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:159
msgid ""
"The B<inet_network>()  function converts I<cp>, a string in IPv4 "
"numbers-and-dots notation, into a number in host byte order suitable for use "
"as an Internet network address.  On success, the converted address is "
"returned.  If the input is invalid, -1 is returned."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:167
msgid ""
"The B<inet_ntoa>()  function converts the Internet host address I<in>, given "
"in network byte order, to a string in IPv4 dotted-decimal notation.  The "
"string is returned in a statically allocated buffer, which subsequent calls "
"will overwrite."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:173
msgid ""
"The B<inet_lnaof>()  function returns the local network address part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:179
msgid ""
"The B<inet_netof>()  function returns the network number part of the "
"Internet address I<in>.  The returned value is in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:190
msgid ""
"The B<inet_makeaddr>()  function is the converse of B<inet_netof>()  and "
"B<inet_lnaof>().  It returns an Internet host address in network byte order, "
"created by combining the network number I<net> with the local address "
"I<host>, both in host byte order."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:200
msgid ""
"The structure I<in_addr> as used in B<inet_ntoa>(), B<inet_makeaddr>(), "
"B<inet_lnaof>()  and B<inet_netof>()  is defined in "
"I<E<lt>netinet/in.hE<gt>> as:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:204
#, no-wrap
msgid "typedef uint32_t in_addr_t;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:208
#, no-wrap
msgid ""
"struct in_addr {\n"
"    in_addr_t s_addr;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:218
msgid ""
"4.3BSD.  B<inet_addr>()  and B<inet_ntoa>()  are specified in POSIX.1-2001.  "
"B<inet_aton>()  is not specified in POSIX.1-2001, but is available on most "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:222
msgid ""
"On the i386 the host byte order is Least Significant Byte first (little "
"endian), whereas the network byte order, as used on the Internet, is Most "
"Significant Byte first (big endian)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:231
msgid ""
"B<inet_lnaof>(), B<inet_netof>(), and B<inet_makeaddr>()  are legacy "
"functions that assume they are dealing with I<classful network addresses>.  "
"Classful networking divides IPv4 network addresses into host and network "
"components at byte boundaries, as follows:"
msgstr ""

#. type: TP
#: build/C/man3/inet.3:231
#, no-wrap
msgid "Class A"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:237
msgid ""
"This address type is indicated by the value 0 in the most significant bit of "
"the (network byte ordered) address.  The network address is contained in the "
"most significant byte, and the host address occupies the remaining three "
"bytes."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:237
#, no-wrap
msgid "Class B"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:243
msgid ""
"This address type is indicated by the binary value 10 in the most "
"significant two bits of the address.  The network address is contained in "
"the two most significant bytes, and the host address occupies the remaining "
"two bytes."
msgstr ""

#. type: TP
#: build/C/man3/inet.3:243
#, no-wrap
msgid "Class C"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:249
msgid ""
"This address type is indicated by the binary value 110 in the most "
"significant three bits of the address.  The network address is contained in "
"the three most significant bytes, and the host address occupies the "
"remaining byte."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:254
msgid ""
"Classful network addresses are now obsolete, having been superseded by "
"Classless Inter-Domain Routing (CIDR), which divides addresses into network "
"and host components at arbitrary bit (rather than byte) boundaries."
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:261
msgid ""
"An example of the use of B<inet_aton>()  and B<inet_ntoa>()  is shown "
"below.  Here are some example runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:268
#, no-wrap
msgid ""
"$B< ./a.out 226.000.000.037>      # Last byte is in octal\n"
"226.0.0.31\n"
"$B< ./a.out 0x7f.1         >      # First byte is in hex\n"
"127.0.0.1\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:277
#, no-wrap
msgid ""
"#define _BSD_SOURCE\n"
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:282
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct in_addr addr;\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:287
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s E<lt>dotted-addressE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:292
#, no-wrap
msgid ""
"    if (inet_aton(argv[1], &addr) == 0) {\n"
"        perror(\"inet_aton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:296
#, no-wrap
msgid ""
"    printf(\"%s\\en\", inet_ntoa(addr));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet.3:307
msgid ""
"B<byteorder>(3), B<getaddrinfo>(3), B<gethostbyname>(3), B<getnameinfo>(3), "
"B<getnetent>(3), B<inet_ntop>(3), B<inet_pton>(3), B<hosts>(5), "
"B<networks>(5)"
msgstr ""

#. type: TH
#: build/C/man3/inet_ntop.3:24
#, no-wrap
msgid "INET_NTOP"
msgstr ""

#. type: TH
#: build/C/man3/inet_ntop.3:24
#, no-wrap
msgid "2008-11-11"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:27
msgid "inet_ntop - convert IPv4 and IPv6 addresses from binary to text form"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:33
#, no-wrap
msgid ""
"B<const char *inet_ntop(int >I<af>B<, const void *>I<src>B<,>\n"
"B<                      char *>I<dst>B<, socklen_t >I<size>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:46
msgid ""
"This function converts the network address structure I<src> in the I<af> "
"address family into a character string.  The resulting string is copied to "
"the buffer pointed to by I<dst>, which must be a non-NULL pointer.  The "
"caller specifies the number of bytes available in this buffer in the "
"argument I<size>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:55
msgid ""
"B<inet_ntop>()  extends the B<inet_ntoa>(3)  function to support multiple "
"address families, B<inet_ntoa>(3)  is now considered to be deprecated in "
"favor of B<inet_ntop>().  The following address families are currently "
"supported:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:68
msgid ""
"I<src> points to a I<struct in_addr> (in network byte order)  which is "
"converted to an IPv4 network address in the dotted-decimal format, "
"\"I<ddd.ddd.ddd.ddd>\".  The buffer I<dst> must be at least "
"B<INET_ADDRSTRLEN> bytes long."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:81
msgid ""
"I<src> points to a I<struct in6_addr> (in network byte order)  which is "
"converted to a representation of this address in the most appropriate IPv6 "
"network address format for this address.  The buffer I<dst> must be at least "
"B<INET6_ADDRSTRLEN> bytes long."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:89
msgid ""
"On success, B<inet_ntop>()  returns a non-NULL pointer to I<dst>.  NULL is "
"returned if there was an error, with I<errno> set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man3/inet_ntop.3:90
#, no-wrap
msgid "B<EAFNOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:94
msgid "I<af> was not a valid address family."
msgstr ""

#. type: TP
#: build/C/man3/inet_ntop.3:94
#, no-wrap
msgid "B<ENOSPC>"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:98
msgid "The converted address string would exceed the size given by I<size>."
msgstr ""

#.  2.1.3: size_t, 2.1.91: socklen_t
#. type: Plain text
#: build/C/man3/inet_ntop.3:110
msgid ""
"POSIX.1-2001.  Note that RFC\\ 2553 defines a prototype where the last "
"argument I<size> is of type I<size_t>.  Many systems follow RFC\\ 2553.  "
"Glibc 2.0 and 2.1 have I<size_t>, but 2.2 and later have I<socklen_t>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:113
msgid "B<AF_INET6> converts IPv4-mapped IPv6 addresses into an IPv6 format."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:116
msgid "See B<inet_pton>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_ntop.3:120
msgid "B<getnameinfo>(3), B<inet>(3), B<inet_pton>(3)"
msgstr ""

#. type: TH
#: build/C/man3/inet_pton.3:25
#, no-wrap
msgid "INET_PTON"
msgstr ""

#. type: TH
#: build/C/man3/inet_pton.3:25
#, no-wrap
msgid "2008-06-18"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:28
msgid "inet_pton - convert IPv4 and IPv6 addresses from text to binary form"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:33
#, no-wrap
msgid "B<int inet_pton(int >I<af>B<, const char *>I<src>B<, void *>I<dst>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:49
msgid ""
"This function converts the character string I<src> into a network address "
"structure in the I<af> address family, then copies the network address "
"structure to I<dst>.  The I<af> argument must be either B<AF_INET> or "
"B<AF_INET6>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:51
msgid "The following address families are currently supported:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:65
msgid ""
"I<src> points to a character string containing an IPv4 network address in "
"dotted-decimal format, \"I<ddd.ddd.ddd.ddd>\", where I<ddd> is a decimal "
"number of up to three digits in the range 0 to 255.  The address is "
"converted to a I<struct in_addr> and copied to I<dst>, which must be "
"I<sizeof(struct in_addr)> (4) bytes (32 bits) long."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:77
msgid ""
"I<src> points to a character string containing an IPv6 network address.  The "
"address is converted to a I<struct in6_addr> and copied to I<dst>, which "
"must be I<sizeof(struct in6_addr)> (16) bytes (128 bits) long.  The allowed "
"formats for IPv6 addresses follow these rules:"
msgstr ""

#. type: IP
#: build/C/man3/inet_pton.3:78
#, no-wrap
msgid "1."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:85
msgid ""
"The preferred format is I<x:x:x:x:x:x:x:x>.  This form consists of eight "
"hexadecimal numbers, each of which expresses a 16-bit value (i.e., each I<x> "
"can be up to 4 hex digits)."
msgstr ""

#. type: IP
#: build/C/man3/inet_pton.3:85
#, no-wrap
msgid "2."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:98
msgid ""
"A series of contiguous zero values in the preferred format can be "
"abbreviated to I<::>.  Only one instance of I<::> can occur in an address.  "
"For example, the loopback address I<0:0:0:0:0:0:0:1> can be abbreviated as "
"I<::1>.  The wildcard address, consisting of all zeros, can be written as "
"I<::>."
msgstr ""

#. type: IP
#: build/C/man3/inet_pton.3:98
#, no-wrap
msgid "3."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:111
msgid ""
"An alternate format is useful for expressing IPv4-mapped IPv6 addresses.  "
"This form is written as I<x:x:x:x:x:x:d.d.d.d>, where the six leading I<x>s "
"are hexadecimal values that define the six most-significant 16-bit pieces of "
"the address (i.e., 96 bits), and the I<d>s express a value in dotted-decimal "
"notation that defines the least significant 32 bits of the address.  An "
"example of such an address is I<::FFFF:204.152.189.116>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:114
msgid "See RFC 2373 for further details on the representation of IPv6 addresses."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:127
msgid ""
"B<inet_pton>()  returns 1 on success (network address was successfully "
"converted).  0 is returned if I<src> does not contain a character string "
"representing a valid network address in the specified address family.  If "
"I<af> does not contain a valid address family, -1 is returned and I<errno> "
"is set to B<EAFNOSUPPORT>."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:148
msgid ""
"Unlike B<inet_aton>(3)  and B<inet_addr>(3), B<inet_pton>()  supports IPv6 "
"addresses.  On the other hand, B<inet_pton>()  only accepts IPv4 addresses "
"in dotted-decimal notation, whereas B<inet_aton>(3)  and B<inet_addr>(3)  "
"allow the more general numbers-and-dots notation (hexadecimal and octal "
"number formats, and formats that don't require all four bytes to be "
"explicitly written).  For an interface that handles both IPv6 addresses, and "
"IPv4 addresses in numbers-and-dots notation, see B<getaddrinfo>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:154
msgid ""
"B<AF_INET6> does not recognize IPv4 addresses.  An explicit IPv4-mapped IPv6 "
"address must be supplied in I<src> instead."
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:160
msgid ""
"The program below demonstrates the use of B<inet_pton>()  and "
"B<inet_ntop>(3).  Here are some example runs:"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:169
#, no-wrap
msgid ""
"$B< ./a.out i6 0:0:0:0:0:0:0:0>\n"
"::\n"
"$B< ./a.out i6 1:0:0:0:0:0:0:8>\n"
"1::8\n"
"$B< ./a.out i6 0:0:0:0:0:FFFF:204.152.189.116>\n"
"::ffff:204.152.189.116\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:178
#, no-wrap
msgid ""
"#include E<lt>arpa/inet.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:185
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    unsigned char buf[sizeof(struct in6_addr)];\n"
"    int domain, s;\n"
"    char str[INET6_ADDRSTRLEN];\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:190
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s {i4|i6|E<lt>numE<gt>} string\\en\", "
"argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:193
#, no-wrap
msgid ""
"    domain = (strcmp(argv[1], \"i4\") == 0) ? AF_INET :\n"
"             (strcmp(argv[1], \"i6\") == 0) ? AF_INET6 : atoi(argv[1]);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:202
#, no-wrap
msgid ""
"    s = inet_pton(domain, argv[2], buf);\n"
"    if (s E<lt>= 0) {\n"
"        if (s == 0)\n"
"            fprintf(stderr, \"Not in presentation format\");\n"
"        else\n"
"            perror(\"inet_pton\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:207
#, no-wrap
msgid ""
"    if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL) {\n"
"        perror(\"inet_ntop\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:209
#, no-wrap
msgid "    printf(\"%s\\en\", str);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/inet_pton.3:217
msgid "B<getaddrinfo>(3), B<inet>(3), B<inet_ntop>(3)"
msgstr ""

#. type: TH
#: build/C/man7/ip.7:12
#, no-wrap
msgid "IP"
msgstr ""

#. type: TH
#: build/C/man7/ip.7:12
#, no-wrap
msgid "2011-09-22"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:15
msgid "ip - Linux IPv4 protocol implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:21 build/C/man7/ipv6.7:14 build/C/man7/raw.7:16 build/C/man7/tcp.7:23 build/C/man7/udp.7:15
msgid "B<#include E<lt>netinet/in.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:23
msgid "B<#include E<lt>netinet/ip.hE<gt> >/* superset of previous */"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:25
msgid "I<tcp_socket>B< = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:27
msgid "I<udp_socket>B< = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:29
msgid "I<raw_socket>B< = socket(AF_INET, SOCK_RAW, >I<protocol>B<);>"
msgstr ""

#.  FIXME has someone verified that 2.1 is really 1812 compliant?
#. type: Plain text
#: build/C/man7/ip.7:36
msgid ""
"Linux implements the Internet Protocol, version 4, described in RFC\\ 791 "
"and RFC\\ 1122.  B<ip> contains a level 2 multicasting implementation "
"conforming to RFC\\ 1112.  It also contains an IP router including a packet "
"filter."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:40
msgid ""
"The programming interface is BSD-sockets compatible.  For more information "
"on sockets, see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:71
msgid ""
"An IP socket is created by calling the B<socket>(2)  function as "
"B<socket(AF_INET, >I<socket_type>B<, >I<protocol>B<)>.  Valid socket types "
"are B<SOCK_STREAM> to open a B<tcp>(7)  socket, B<SOCK_DGRAM> to open a "
"B<udp>(7)  socket, or B<SOCK_RAW> to open a B<raw>(7)  socket to access the "
"IP protocol directly.  I<protocol> is the IP protocol in the IP header to be "
"received or sent.  The only valid values for I<protocol> are 0 and "
"B<IPPROTO_TCP> for TCP sockets, and 0 and B<IPPROTO_UDP> for UDP sockets.  "
"For B<SOCK_RAW> you may specify a valid IANA IP protocol defined in RFC\\ "
"1700 assigned numbers."
msgstr ""

#.  FIXME ip current does an autobind in listen, but I'm not sure
#.  if that should be documented.
#. type: Plain text
#: build/C/man7/ip.7:90
msgid ""
"When a process wants to receive new incoming packets or connections, it "
"should bind a socket to a local interface address using B<bind>(2).  Only "
"one IP socket may be bound to any given local (address, port) pair.  When "
"B<INADDR_ANY> is specified in the bind call, the socket will be bound to "
"I<all> local interfaces.  When B<listen>(2)  or B<connect>(2)  are called on "
"an unbound socket, it is automatically bound to a random free port with the "
"local address set to B<INADDR_ANY>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:96
msgid ""
"A TCP local socket address that has been bound is unavailable for some time "
"after closing, unless the B<SO_REUSEADDR> flag has been set.  Care should be "
"taken when using this flag as it makes TCP less reliable."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:107
msgid ""
"An IP socket address is defined as a combination of an IP interface address "
"and a 16-bit port number.  The basic IP protocol does not supply port "
"numbers, they are implemented by higher level protocols like B<udp>(7)  and "
"B<tcp>(7).  On raw sockets I<sin_port> is set to the IP protocol."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:115
#, no-wrap
msgid ""
"struct sockaddr_in {\n"
"    sa_family_t    sin_family; /* address family: AF_INET */\n"
"    in_port_t      sin_port;   /* port in network byte order */\n"
"    struct in_addr sin_addr;   /* internet address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:120
#, no-wrap
msgid ""
"/* Internet address. */\n"
"struct in_addr {\n"
"    uint32_t       s_addr;     /* address in network byte order */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:145
msgid ""
"I<sin_family> is always set to B<AF_INET>.  This is required; in Linux 2.2 "
"most networking functions return B<EINVAL> when this setting is missing.  "
"I<sin_port> contains the port in network byte order.  The port numbers below "
"1024 are called I<privileged ports> (or sometimes: I<reserved ports>).  Only "
"privileged processes (i.e., those having the B<CAP_NET_BIND_SERVICE> "
"capability) may B<bind>(2)  to these sockets.  Note that the raw IPv4 "
"protocol as such has no concept of a port, they are only implemented by "
"higher protocols like B<tcp>(7)  and B<udp>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:164
msgid ""
"I<sin_addr> is the IP host address.  The I<s_addr> member of I<struct "
"in_addr> contains the host interface address in network byte order.  "
"I<in_addr> should be assigned one of the B<INADDR_*> values (e.g., "
"B<INADDR_ANY>)  or set using the B<inet_aton>(3), B<inet_addr>(3), "
"B<inet_makeaddr>(3)  library functions or directly with the name resolver "
"(see B<gethostbyname>(3))."
msgstr ""

#.  Leave a loophole for XTP @)
#. type: Plain text
#: build/C/man7/ip.7:176
msgid ""
"IPv4 addresses are divided into unicast, broadcast and multicast addresses.  "
"Unicast addresses specify a single interface of a host, broadcast addresses "
"specify all hosts on a network and multicast addresses address all hosts in "
"a multicast group.  Datagrams to broadcast addresses can be only sent or "
"received when the B<SO_BROADCAST> socket flag is set.  In the current "
"implementation, connection-oriented sockets are only allowed to use unicast "
"addresses."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:184
msgid ""
"Note that the address and the port are always stored in network byte order.  "
"In particular, this means that you need to call B<htons>(3)  on the number "
"that is assigned to a port.  All address/port manipulation functions in the "
"standard library work in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:197
msgid ""
"There are several special addresses: B<INADDR_LOOPBACK> (127.0.0.1)  always "
"refers to the local host via the loopback device; B<INADDR_ANY> (0.0.0.0)  "
"means any address for binding; B<INADDR_BROADCAST> (255.255.255.255)  means "
"any host and has the same effect on bind as B<INADDR_ANY> for historical "
"reasons."
msgstr ""

#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:206
msgid ""
"IP supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IP is B<IPPROTO_IP>.  A boolean integer flag is zero when it is false, "
"otherwise true."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:206
#, no-wrap
msgid "B<IP_ADD_MEMBERSHIP> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:212
msgid "Join a multicast group.  Argument is an I<ip_mreqn> structure."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:222
#, no-wrap
msgid ""
"struct ip_mreqn {\n"
"    struct in_addr imr_multiaddr; /* IP multicast group\n"
"                                     address */\n"
"    struct in_addr imr_address;   /* IP address of local\n"
"                                     interface */\n"
"    int            imr_ifindex;   /* interface index */\n"
"};\n"
msgstr ""

#.  (i.e., within the 224.0.0.0-239.255.255.255 range)
#. type: Plain text
#: build/C/man7/ip.7:243
msgid ""
"I<imr_multiaddr> contains the address of the multicast group the application "
"wants to join or leave.  It must be a valid multicast address (or "
"B<setsockopt>(2)  fails with the error B<EINVAL>).  I<imr_address> is the "
"address of the local interface with which the system should join the "
"multicast group; if it is equal to B<INADDR_ANY> an appropriate interface is "
"chosen by the system.  I<imr_ifindex> is the interface index of the "
"interface that should join/leave the I<imr_multiaddr> group, or 0 to "
"indicate any interface."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:258
msgid ""
"The I<ip_mreqn> structure is available only since Linux 2.2.  For "
"compatibility, the old I<ip_mreq> structure (present since Linux 1.2) is "
"still supported; it differs from I<ip_mreqn> only by not including the "
"I<imr_ifindex> field.  Only valid as a B<setsockopt>(2)."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:258
#, no-wrap
msgid "B<IP_DROP_MEMBERSHIP> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:267
msgid ""
"Leave a multicast group.  Argument is an I<ip_mreqn> or I<ip_mreq> structure "
"similar to B<IP_ADD_MEMBERSHIP>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:267
#, no-wrap
msgid "B<IP_FREEBIND> (since Linux 2.4)"
msgstr ""

#.  Precisely: 2.4.0-test10
#. type: Plain text
#: build/C/man7/ip.7:280
msgid ""
"If enabled, this boolean option allows binding to an IP address that is "
"nonlocal or does not (yet) exist.  This permits listening on a socket, "
"without requiring the underlying network interface or the specified dynamic "
"IP address to be up at the time that the application is trying to bind to "
"it.  This option is the per-socket equivalent of the I<ip_nonlocal_bind> "
"I</proc> interface described below."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:280
#, no-wrap
msgid "B<IP_HDRINCL> (since Linux 2.0)"
msgstr ""

#
#.  FIXME Document IP_IPSEC_POLICY
#.  Since Linux 2.5.47
#.  Needs CAP_NET_ADMIN
#. type: Plain text
#: build/C/man7/ip.7:300
msgid ""
"If enabled, the user supplies an IP header in front of the user data.  Only "
"valid for B<SOCK_RAW> sockets.  See B<raw>(7)  for more information.  When "
"this flag is enabled the values set by B<IP_OPTIONS>, B<IP_TTL> and "
"B<IP_TOS> are ignored."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:300
#, no-wrap
msgid "B<IP_MTU> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:308
msgid ""
"Retrieve the current known path MTU of the current socket.  Only valid when "
"the socket has been connected.  Returns an integer.  Only valid as a "
"B<getsockopt>(2)."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:308
#, no-wrap
msgid "B<IP_MTU_DISCOVER> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.124
#. type: Plain text
#: build/C/man7/ip.7:329
msgid ""
"Set or receive the Path MTU Discovery setting for a socket.  When enabled, "
"Linux will perform Path MTU Discovery as defined in RFC\\ 1191 on "
"B<SOCK_STREAM> sockets.  For non-B<SOCK_STREAM> sockets, B<IP_PMTUDISC_DO> "
"forces the don't-fragment flag to be set on all outgoing packets.  It is the "
"user's responsibility to packetize the data in MTU-sized chunks and to do "
"the retransmits if necessary.  The kernel will reject (with B<EMSGSIZE>)  "
"datagrams that are bigger than the known path MTU.  B<IP_PMTUDISC_WANT> will "
"fragment a datagram if needed according to the path MTU, or will set the "
"don't-fragment flag otherwise."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:337
msgid ""
"The system-wide default can be toggled between B<IP_PMTUDISC_WANT> and "
"B<IP_PMTUDISC_DONT> by writing (respectively, zero and nonzero values) to "
"the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file."
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:342
#, no-wrap
msgid "Path MTU discovery value:Meaning\n"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:343
#, no-wrap
msgid "IP_PMTUDISC_WANT:Use per-route settings.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:344
#, no-wrap
msgid "IP_PMTUDISC_DONT:Never do Path MTU Discovery.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:345
#, no-wrap
msgid "IP_PMTUDISC_DO:Always do Path MTU Discovery.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/ip.7:346
#, no-wrap
msgid "IP_PMTUDISC_PROBE:Set DF but ignore Path MTU.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:364
msgid ""
"When PMTU discovery is enabled, the kernel automatically keeps track of the "
"path MTU per destination host.  When it is connected to a specific peer with "
"B<connect>(2), the currently known path MTU can be retrieved conveniently "
"using the B<IP_MTU> socket option (e.g., after an B<EMSGSIZE> error "
"occurred).  The path MTU may change over time.  For connectionless sockets "
"with many destinations, the new MTU for a given destination can also be "
"accessed using the error queue (see B<IP_RECVERR>).  A new error will be "
"queued for every incoming MTU update."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:369
msgid ""
"While MTU discovery is in progress, initial packets from datagram sockets "
"may be dropped.  Applications using UDP should be aware of this and not take "
"it into account for their packet retransmit strategy."
msgstr ""

#.  FIXME this is an ugly hack
#. type: Plain text
#: build/C/man7/ip.7:374
msgid ""
"To bootstrap the path MTU discovery process on unconnected sockets, it is "
"possible to start with a big datagram size (up to 64K-headers bytes long) "
"and let it shrink by updates of the path MTU."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:383
msgid ""
"To get an initial estimate of the path MTU, connect a datagram socket to the "
"destination address using B<connect>(2)  and retrieve the MTU by calling "
"B<getsockopt>(2)  with the B<IP_MTU> option."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:395
msgid ""
"It is possible to implement RFC 4821 MTU probing with B<SOCK_DGRAM> or "
"B<SOCK_RAW> sockets by setting a value of B<IP_PMTUDISC_PROBE> (available "
"since Linux 2.6.22).  This is also particularly useful for diagnostic tools "
"such as B<tracepath>(8)  that wish to deliberately send probe packets larger "
"than the observed Path MTU."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:395
#, no-wrap
msgid "B<IP_MULTICAST_IF> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:404
msgid ""
"Set the local device for a multicast socket.  Argument is an I<ip_mreqn> or "
"I<ip_mreq> structure similar to B<IP_ADD_MEMBERSHIP>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:408
msgid "When an invalid socket option is passed, B<ENOPROTOOPT> is returned."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:408
#, no-wrap
msgid "B<IP_MULTICAST_LOOP> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:412
msgid ""
"Set or read a boolean integer argument that determines whether sent "
"multicast packets should be looped back to the local sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:412
#, no-wrap
msgid "B<IP_MULTICAST_TTL> (since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:420
msgid ""
"Set or read the time-to-live value of outgoing multicast packets for this "
"socket.  It is very important for multicast packets to set the smallest TTL "
"possible.  The default is 1 which means that multicast packets don't leave "
"the local network unless the user program explicitly requests it.  Argument "
"is an integer."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:420
#, no-wrap
msgid "B<IP_NODEFRAG> (since Linux 2.6.36)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:428
msgid ""
"If enabled (argument is nonzero), the reassembly of outgoing packets is "
"disabled in the netfilter layer.  This option is only valid for B<SOCK_RAW> "
"sockets.  The argument is an integer."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:428
#, no-wrap
msgid "B<IP_OPTIONS> (since Linux 2.0)"
msgstr ""

#.  Precisely: 1.3.30
#.  FIXME Document IP_PASSSEC
#.  Boolean
#.  Since Linux 2.6.17
#.  commit 2c7946a7bf45ae86736ab3b43d0085e43947945c
#.  Author: Catherine Zhang <cxzhang@watson.ibm.com>
#. type: Plain text
#: build/C/man7/ip.7:462
msgid ""
"Set or get the IP options to be sent with every packet from this socket.  "
"The arguments are a pointer to a memory buffer containing the options and "
"the option length.  The B<setsockopt>(2)  call sets the IP options "
"associated with a socket.  The maximum option size for IPv4 is 40 bytes.  "
"See RFC\\ 791 for the allowed options.  When the initial connection request "
"packet for a B<SOCK_STREAM> socket contains IP options, the IP options will "
"be set automatically to the options from the initial packet with routing "
"headers reversed.  Incoming packets are not allowed to change options after "
"the connection is established.  The processing of all incoming source "
"routing options is disabled by default and can be enabled by using the "
"I<accept_source_route> I</proc> interface.  Other options like timestamps "
"are still handled.  For datagram sockets, IP options can be only set by the "
"local user.  Calling B<getsockopt>(2)  with B<IP_OPTIONS> puts the current "
"IP options used for sending into the supplied buffer."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:462
#, no-wrap
msgid "B<IP_PKTINFO> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:479
msgid ""
"Pass an B<IP_PKTINFO> ancillary message that contains a I<pktinfo> structure "
"that supplies some information about the incoming packet.  This only works "
"for datagram oriented sockets.  The argument is a flag that tells the socket "
"whether the B<IP_PKTINFO> message should be passed or not.  The message "
"itself can only be sent/retrieved as control message with a packet using "
"B<recvmsg>(2)  or B<sendmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:488
#, no-wrap
msgid ""
"struct in_pktinfo {\n"
"    unsigned int   ipi_ifindex;  /* Interface index */\n"
"    struct in_addr ipi_spec_dst; /* Local address */\n"
"    struct in_addr ipi_addr;     /* Header Destination\n"
"                                    address */\n"
"};\n"
msgstr ""

#.  FIXME elaborate on that.
#.  This field is grossly misnamed
#. type: Plain text
#: build/C/man7/ip.7:513
msgid ""
"I<ipi_ifindex> is the unique index of the interface the packet was received "
"on.  I<ipi_spec_dst> is the local address of the packet and I<ipi_addr> is "
"the destination address in the packet header.  If B<IP_PKTINFO> is passed to "
"B<sendmsg>(2)  and I<ipi_spec_dst> is not zero, then it is used as the local "
"source address for the routing table lookup and for setting up IP source "
"route options.  When I<ipi_ifindex> is not zero, the primary local address "
"of the interface specified by the index overwrites I<ipi_spec_dst> for the "
"routing table lookup."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:513
#, no-wrap
msgid "B<IP_RECVERR> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#.  or SOL_IP on Linux
#. type: Plain text
#: build/C/man7/ip.7:535
msgid ""
"Enable extended reliable error message passing.  When enabled on a datagram "
"socket, all generated errors will be queued in a per-socket error queue.  "
"When the user receives an error from a socket operation, the errors can be "
"received by calling B<recvmsg>(2)  with the B<MSG_ERRQUEUE> flag set.  The "
"I<sock_extended_err> structure describing the error will be passed in an "
"ancillary message with the type B<IP_RECVERR> and the level B<IPPROTO_IP>.  "
"This is useful for reliable error handling on unconnected sockets.  The "
"received data portion of the error queue contains the error packet."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:541
msgid "The B<IP_RECVERR> control message contains a I<sock_extended_err> structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:549
#, no-wrap
msgid ""
"#define SO_EE_ORIGIN_NONE    0\n"
"#define SO_EE_ORIGIN_LOCAL   1\n"
"#define SO_EE_ORIGIN_ICMP    2\n"
"#define SO_EE_ORIGIN_ICMP6   3\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:560
#, no-wrap
msgid ""
"struct sock_extended_err {\n"
"    uint32_t ee_errno;   /* error number */\n"
"    uint8_t  ee_origin;  /* where the error originated */\n"
"    uint8_t  ee_type;    /* type */\n"
"    uint8_t  ee_code;    /* code */\n"
"    uint8_t  ee_pad;\n"
"    uint32_t ee_info;    /* additional information */\n"
"    uint32_t ee_data;    /* other data */\n"
"    /* More data may follow */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:562
#, no-wrap
msgid "struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:585
msgid ""
"I<ee_errno> contains the I<errno> number of the queued error.  I<ee_origin> "
"is the origin code of where the error originated.  The other fields are "
"protocol-specific.  The macro B<SO_EE_OFFENDER> returns a pointer to the "
"address of the network object where the error originated from given a "
"pointer to the ancillary message.  If this address is not known, the "
"I<sa_family> member of the I<sockaddr> contains B<AF_UNSPEC> and the other "
"fields of the I<sockaddr> are undefined."
msgstr ""

#.  FIXME . Is it a good idea to document that? It is a dubious feature.
#.  On
#.  .B SOCK_STREAM
#.  sockets,
#.  .B IP_RECVERR
#.  has slightly different semantics. Instead of
#.  saving the errors for the next timeout, it passes all incoming
#.  errors immediately to the user.
#.  This might be useful for very short-lived TCP connections which
#.  need fast error handling. Use this option with care:
#.  it makes TCP unreliable
#.  by not allowing it to recover properly from routing
#.  shifts and other normal
#.  conditions and breaks the protocol specification.
#. type: Plain text
#: build/C/man7/ip.7:644
msgid ""
"IP uses the I<sock_extended_err> structure as follows: I<ee_origin> is set "
"to B<SO_EE_ORIGIN_ICMP> for errors received as an ICMP packet, or "
"B<SO_EE_ORIGIN_LOCAL> for locally generated errors.  Unknown values should "
"be ignored.  I<ee_type> and I<ee_code> are set from the type and code fields "
"of the ICMP header.  I<ee_info> contains the discovered MTU for B<EMSGSIZE> "
"errors.  The message also contains the I<sockaddr_in of the node> caused the "
"error, which can be accessed with the B<SO_EE_OFFENDER> macro.  The "
"I<sin_family> field of the B<SO_EE_OFFENDER> address is B<AF_UNSPEC> when "
"the source was unknown.  When the error originated from the network, all IP "
"options (B<IP_OPTIONS>, B<IP_TTL>, etc.) enabled on the socket and contained "
"in the error packet are passed as control messages.  The payload of the "
"packet causing the error is returned as normal payload.  Note that TCP has "
"no error queue; B<MSG_ERRQUEUE> is not permitted on B<SOCK_STREAM> sockets.  "
"B<IP_RECVERR> is valid for TCP, but all errors are returned by socket "
"function return or B<SO_ERROR> only."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:649
msgid ""
"For raw sockets, B<IP_RECVERR> enables passing of all received ICMP errors "
"to the application, otherwise errors are only reported on connected sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:653
msgid ""
"It sets or retrieves an integer boolean flag.  B<IP_RECVERR> defaults to "
"off."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:653
#, no-wrap
msgid "B<IP_RECVOPTS> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:664
msgid ""
"Pass all incoming IP options to the user in a B<IP_OPTIONS> control "
"message.  The routing header and other options are already filled in for the "
"local host.  Not supported for B<SOCK_STREAM> sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:664
#, no-wrap
msgid "B<IP_RECVORIGDSTADDR> (since Linux 2.6.29)"
msgstr ""

#.  commit e8b2dfe9b4501ed0047459b2756ba26e5a940a69
#. type: Plain text
#: build/C/man7/ip.7:675
msgid ""
"This boolean option enables the B<IP_ORIGDSTADDR> ancillary message in "
"B<recvmsg>(2), in which the kernel returns the original destination address "
"of the datagram being received.  The ancillary message contains a I<struct "
"sockaddr_in>."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:675
#, no-wrap
msgid "B<IP_RECVTOS> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:684
msgid ""
"If enabled the B<IP_TOS> ancillary message is passed with incoming packets.  "
"It contains a byte which specifies the Type of Service/Precedence field of "
"the packet header.  Expects a boolean integer flag."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:684
#, no-wrap
msgid "B<IP_RECVTTL> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:694
msgid ""
"When this flag is set, pass a B<IP_TTL> control message with the time to "
"live field of the received packet as a byte.  Not supported for "
"B<SOCK_STREAM> sockets."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:694
#, no-wrap
msgid "B<IP_RETOPTS> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:701
msgid ""
"Identical to B<IP_RECVOPTS>, but returns raw unprocessed options with "
"timestamp and route record options not filled in for this hop."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:701
#, no-wrap
msgid "B<IP_ROUTER_ALERT> (since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:713
msgid ""
"Pass all to-be forwarded packets with the IP Router Alert option set to this "
"socket.  Only valid for raw sockets.  This is useful, for instance, for "
"user-space RSVP daemons.  The tapped packets are not forwarded by the "
"kernel; it is the user's responsibility to send them out again.  Socket "
"binding is ignored, such packets are only filtered by protocol.  Expects an "
"integer flag."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:713
#, no-wrap
msgid "B<IP_TOS> (since Linux 1.0)"
msgstr ""

#.  FIXME elaborate on this
#.  Needs CAP_NET_ADMIN
#.  Boolean
#.  Since Linux 2.6.27
#.  Author: KOVACS Krisztian <hidden@sch.bme.hu>
#.  http://lwn.net/Articles/252545/
#. type: Plain text
#: build/C/man7/ip.7:747
msgid ""
"Set or receive the Type-Of-Service (TOS) field that is sent with every IP "
"packet originating from this socket.  It is used to prioritize packets on "
"the network.  TOS is a byte.  There are some standard TOS flags defined: "
"B<IPTOS_LOWDELAY> to minimize delays for interactive traffic, "
"B<IPTOS_THROUGHPUT> to optimize throughput, B<IPTOS_RELIABILITY> to optimize "
"for reliability, B<IPTOS_MINCOST> should be used for \"filler data\" where "
"slow transmission doesn't matter.  At most one of these TOS values can be "
"specified.  Other bits are invalid and shall be cleared.  Linux sends "
"B<IPTOS_LOWDELAY> datagrams first by default, but the exact behavior depends "
"on the configured queueing discipline.  Some high priority levels may "
"require superuser privileges (the B<CAP_NET_ADMIN> capability).  The "
"priority can also be set in a protocol independent way by the "
"(B<SOL_SOCKET>, B<SO_PRIORITY>)  socket option (see B<socket>(7))."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:747
#, no-wrap
msgid "B<IP_TRANSPARENT> (since Linux 2.6.24)"
msgstr ""

#.  commit f5715aea4564f233767ea1d944b2637a5fd7cd2e
#.      This patch introduces the IP_TRANSPARENT socket option: enabling that
#.      will make the IPv4 routing omit the non-local source address check on
#.      output. Setting IP_TRANSPARENT requires NET_ADMIN capability.
#.  http://lwn.net/Articles/252545/
#. type: Plain text
#: build/C/man7/ip.7:764
msgid ""
"Setting this boolean option enables transparent proxying on this socket.  "
"This socket option allows the calling application to bind to a nonlocal IP "
"address and operate both as a client and a server with the foreign address "
"as the local endpoint.  NOTE: this requires that routing be set up in a way "
"that packets going to the foreign address are routed through the TProxy "
"box.  Enabling this socket option requires superuser privileges (the "
"B<CAP_NET_ADMIN> capability)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:767
msgid ""
"TProxy redirection with the iptables TPROXY target also requires that this "
"option be set on the redirected socket."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:767
#, no-wrap
msgid "B<IP_TTL> (since Linux 1.0)"
msgstr ""

#.  FIXME Document IP_XFRM_POLICY
#.  Since Linux 2.5.48
#.  Needs CAP_NET_ADMIN
#. type: Plain text
#: build/C/man7/ip.7:774
msgid ""
"Set or retrieve the current time-to-live field that is used in every packet "
"sent from this socket."
msgstr ""

#.  FIXME As at 2.6.12, 14 Jun 2005, the following are undocumented:
#. 	ip_queue_maxlen
#. 	ip_conntrack_max
#. type: Plain text
#: build/C/man7/ip.7:790
msgid ""
"The IP protocol supports a set of I</proc> interfaces to configure some "
"global parameters.  The parameters can be accessed by reading or writing "
"files in the directory I</proc/sys/net/ipv4/>.  Interfaces described as "
"I<Boolean> take an integer value, with a nonzero value (\"true\") meaning "
"that the corresponding option is enabled, and a zero value (\"false\")  "
"meaning that the option is disabled."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:790
#, no-wrap
msgid "I<ip_always_defrag> (Boolean; since Linux 2.2.13)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:796
msgid ""
"[New with kernel 2.2.13; in earlier kernel versions this feature was "
"controlled at compile time by the B<CONFIG_IP_ALWAYS_DEFRAG> option; this "
"option is not present in 2.4.x and later]"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:803
msgid ""
"When this boolean flag is enabled (not equal 0), incoming fragments (parts "
"of IP packets that arose when some host between origin and destination "
"decided that the packets were too large and cut them into pieces) will be "
"reassembled (defragmented) before being processed, even if they are about to "
"be forwarded."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:810
msgid ""
"Only enable if running either a firewall that is the sole link to your "
"network or a transparent proxy; never ever use it for a normal router or "
"host.  Otherwise fragmented communication can be disturbed if the fragments "
"travel over different links.  Defragmentation also has a large memory and "
"CPU time cost."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:814
msgid ""
"This is automagically turned on when masquerading or transparent proxying "
"are configured."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:814
#, no-wrap
msgid "I<ip_autoconfig> (since Linux 2.2 to 2.6.17)"
msgstr ""

#.  Precisely: since 2.1.68
#.  FIXME document ip_autoconfig
#. type: Plain text
#: build/C/man7/ip.7:820
msgid "Not documented."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:820
#, no-wrap
msgid "I<ip_default_ttl> (integer; default: 64; since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#. type: Plain text
#: build/C/man7/ip.7:828
msgid ""
"Set the default time-to-live value of outgoing packets.  This can be changed "
"per socket with the B<IP_TTL> option."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:828
#, no-wrap
msgid "I<ip_dynaddr> (Boolean; default: disabled; since Linux 2.0.31)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:835
msgid ""
"Enable dynamic socket address and masquerading entry rewriting on interface "
"address change.  This is useful for dialup interface with changing IP "
"addresses.  0 means no rewriting, 1 turns it on and 2 enables verbose mode."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:835
#, no-wrap
msgid "I<ip_forward> (Boolean; default: disabled; since Linux 1.2)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:840
msgid ""
"Enable IP forwarding with a boolean flag.  IP forwarding can be also set on "
"a per-interface basis."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:840
#, no-wrap
msgid "I<ip_local_port_range> (since Linux 2.2)"
msgstr ""

#.  Precisely: since 2.1.68
#. type: Plain text
#: build/C/man7/ip.7:854
msgid ""
"Contains two integers that define the default local port range allocated to "
"sockets.  Allocation starts with the first number and ends with the second "
"number.  Note that these should not conflict with the ports used by "
"masquerading (although the case is handled).  Also arbitrary choices may "
"cause problems with some firewall packet filters that make assumptions about "
"the local ports in use.  First number should be at least greater than 1024, "
"or better, greater than 4096, to avoid clashes with well known ports and to "
"minimize firewall problems."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:854
#, no-wrap
msgid "I<ip_no_pmtu_disc> (Boolean; default: disabled; since Linux 2.2)"
msgstr ""

#.  Precisely: 2.1.15
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:866
msgid ""
"If enabled, don't do Path MTU Discovery for TCP sockets by default.  Path "
"MTU discovery may fail if misconfigured firewalls (that drop all ICMP "
"packets) or misconfigured interfaces (e.g., a point-to-point link where the "
"both ends don't agree on the MTU) are on the path.  It is better to fix the "
"broken routers on the path than to turn off Path MTU Discovery globally, "
"because not doing it incurs a high cost to the network."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:866
#, no-wrap
msgid "I<ip_nonlocal_bind> (Boolean; default: disabled; since Linux 2.4)"
msgstr ""

#.  Precisely: patch-2.4.0-test10
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:875
msgid ""
"If set, allows processes to B<bind>(2)  to nonlocal IP addresses, which can "
"be quite useful, but may break some applications."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:875
#, no-wrap
msgid "I<ip6frag_time> (integer; default: 30)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/ip.7:880
msgid "Time in seconds to keep an IPv6 fragment in memory."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:880
#, no-wrap
msgid "I<ip6frag_secret_interval> (integer; default: 600)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:884
msgid ""
"Regeneration interval (in seconds) of the hash secret (or lifetime for the "
"hash secret) for IPv6 fragments."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:884
#, no-wrap
msgid "I<ipfrag_high_thresh> (integer), I<ipfrag_low_thresh> (integer)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:891
msgid ""
"If the amount of queued IP fragments reaches I<ipfrag_high_thresh>, the "
"queue is pruned down to I<ipfrag_low_thresh>.  Contains an integer with the "
"number of bytes."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:891
#, no-wrap
msgid "I<neigh/*>"
msgstr ""

#.  FIXME Document the conf/*/* interfaces
#.  FIXME Document the route/* interfaces
#.  FIXME document them all
#. type: Plain text
#: build/C/man7/ip.7:898
msgid "See B<arp>(7)."
msgstr ""

#.  2006-04-02, mtk
#.  commented out the following because ipchains is obsolete
#.  .PP
#.  The ioctls to configure firewalling are documented in
#.  .BR ipfw (4)
#.  from the
#.  .B ipchains
#.  package.
#. type: Plain text
#: build/C/man7/ip.7:911
msgid "All ioctls described in B<socket>(7)  apply to B<ip>."
msgstr ""

#.  FIXME Add a discussion of multicasting
#. type: Plain text
#: build/C/man7/ip.7:915
msgid ""
"Ioctls to configure generic device parameters are described in "
"B<netdevice>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:935
msgid ""
"The user tried to execute an operation without the necessary permissions.  "
"These include: sending a packet to a broadcast address without having the "
"B<SO_BROADCAST> flag set; sending a packet via a I<prohibit> route; "
"modifying firewall settings without superuser privileges (the "
"B<CAP_NET_ADMIN> capability); binding to a privileged port without superuser "
"privileges (the B<CAP_NET_BIND_SERVICE> capability)."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:948
msgid "An connection operation on a nonblocking socket is already in progress."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:957
msgid ""
"No valid routing table entry matches the destination address.  This error "
"can be caused by a ICMP message from a remote router or for the local "
"routing table."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:963
msgid ""
"Invalid argument passed.  For send operations this can be caused by sending "
"to a I<blackhole> route."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:970
msgid "Datagram is bigger than an MTU on the path and it cannot be fragmented."
msgstr ""

#. type: TP
#: build/C/man7/ip.7:970
#, no-wrap
msgid "B<ENOBUFS>, B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:975
msgid ""
"Not enough free memory.  This often means that the memory allocation is "
"limited by the socket buffer limits, not by the system memory, but this is "
"not 100% consistent."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:993
msgid ""
"User doesn't have permission to set high priority, change configuration, or "
"send signals to the requested process or group."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:999
msgid "The socket is not configured or an unknown socket type was requested."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1006
msgid ""
"Other errors may be generated by the overlaying protocols; see B<tcp>(7), "
"B<raw>(7), B<udp>(7)  and B<socket>(7)."
msgstr ""

#.  IP_PASSSEC is Linux-specific
#.  IP_XFRM_POLICY is Linux-specific
#.  IP_IPSEC_POLICY is a nonstandard extension, also present on some BSDs
#. type: Plain text
#: build/C/man7/ip.7:1020
msgid ""
"B<IP_FREEBIND>, B<IP_MTU>, B<IP_MTU_DISCOVER>, B<IP_RECVORIGDSTADDR>, "
"B<IP_PKTINFO>, B<IP_RECVERR>, B<IP_ROUTER_ALERT>, and B<IP_TRANSPARENT> are "
"Linux-specific."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1029
msgid ""
"Be very careful with the B<SO_BROADCAST> option - it is not privileged in "
"Linux.  It is easy to overload the network with careless broadcasts.  For "
"new application protocols it is better to use a multicast group instead of "
"broadcasting.  Broadcasting is discouraged."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1039
msgid ""
"Some other BSD sockets implementations provide B<IP_RCVDSTADDR> and "
"B<IP_RECVIF> socket options to get the destination address and the interface "
"of received datagrams.  Linux has the more general B<IP_PKTINFO> for the "
"same task."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1048
msgid ""
"Some BSD sockets implementations also provide an B<IP_RECVTTL> option, but "
"an ancillary message with type B<IP_RECVTTL> is passed with the incoming "
"packet.  This is different from the B<IP_TTL> option used in Linux."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1054
msgid ""
"Using B<SOL_IP> socket options level isn't portable, BSD-based stacks use "
"B<IPPROTO_IP> level."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1067
msgid ""
"For compatibility with Linux 2.0, the obsolete B<socket(AF_INET, "
"SOCK_PACKET, >I<protocol>B<)> syntax is still supported to open a "
"B<packet>(7)  socket.  This is deprecated and should be replaced by "
"B<socket(AF_PACKET, SOCK_RAW, >I<protocol>B<)> instead.  The main difference "
"is the new I<sockaddr_ll> address structure for generic link layer "
"information instead of the old B<sockaddr_pkt>."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1072
msgid ""
"The ioctls to configure IP-specific interface options and ARP tables are not "
"described."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1076
msgid ""
"Some versions of glibc forget to declare I<in_pktinfo>.  Workaround "
"currently is to copy it into your program from this man page."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/ip.7:1086
msgid ""
"Receiving the original destination address with B<MSG_ERRQUEUE> in "
"I<msg_name> by B<recvmsg>(2)  does not work in some 2.2 kernels."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1097
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<byteorder>(3), B<ipfw>(4), "
"B<capabilities>(7), B<netlink>(7), B<raw>(7), B<socket>(7), B<tcp>(7), "
"B<udp>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1099
msgid "RFC\\ 791 for the original IP specification."
msgstr ""

#. type: Plain text
#: build/C/man7/ip.7:1101
msgid "RFC\\ 1122 for the IPv4 host requirements."
msgstr ""

#.  FIXME autobind INADDR REUSEADDR
#. type: Plain text
#: build/C/man7/ip.7:1104
msgid "RFC\\ 1812 for the IPv4 router requirements."
msgstr ""

#. type: TH
#: build/C/man7/ipv6.7:7
#, no-wrap
msgid "IPV6"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:10
msgid "ipv6 - Linux IPv6 protocol implementation"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:16
msgid "I<tcp6_socket>B< = socket(AF_INET6, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:18
msgid "I<raw6_socket>B< = socket(AF_INET6, SOCK_RAW, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:20
msgid "I<udp6_socket>B< = socket(AF_INET6, SOCK_DGRAM, >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:27
msgid ""
"Linux 2.2 optionally implements the Internet Protocol, version 6.  This man "
"page contains a description of the IPv6 basic API as implemented by the "
"Linux kernel and glibc 2.1.  The interface is based on the BSD sockets "
"interface; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:32
msgid ""
"The IPv6 API aims to be mostly compatible with the IPv4 API (see B<ip>(7)).  "
"Only differences are described in this man page."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:44
msgid ""
"To bind an B<AF_INET6> socket to any process, the local address should be "
"copied from the I<in6addr_any> variable which has I<in6_addr> type.  In "
"static initializations, B<IN6ADDR_ANY_INIT> may also be used, which expands "
"to a constant expression.  Both of them are in network byte order."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:51
msgid ""
"The IPv6 loopback address (::1) is available in the global "
"I<in6addr_loopback> variable.  For initializations, B<IN6ADDR_LOOPBACK_INIT> "
"should be used."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:58
msgid ""
"IPv4 connections can be handled with the v6 API by using the v4-mapped-on-v6 "
"address type; thus a program only needs to support this API type to support "
"both protocols.  This is handled transparently by the address handling "
"functions in the C library."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:63
msgid ""
"IPv4 and IPv6 share the local port space.  When you get an IPv4 connection "
"or packet to a IPv6 socket, its source address will be mapped to v6 and it "
"will be mapped to v6."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:73
#, no-wrap
msgid ""
"struct sockaddr_in6 {\n"
"    sa_family_t     sin6_family;   /* AF_INET6 */\n"
"    in_port_t       sin6_port;     /* port number */\n"
"    uint32_t        sin6_flowinfo; /* IPv6 flow information */\n"
"    struct in6_addr sin6_addr;     /* IPv6 address */\n"
"    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:77
#, no-wrap
msgid ""
"struct in6_addr {\n"
"    unsigned char   s6_addr[16];   /* IPv6 address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:99
msgid ""
"I<sin6_family> is always set to B<AF_INET6>; I<sin6_port> is the protocol "
"port (see I<sin_port> in B<ip>(7)); I<sin6_flowinfo> is the IPv6 flow "
"identifier; I<sin6_addr> is the 128-bit IPv6 address.  I<sin6_scope_id> is "
"an ID depending on the scope of the address.  It is new in Linux 2.4.  Linux "
"only supports it for link-local addresses, in that case I<sin6_scope_id> "
"contains the interface index (see B<netdevice>(7))"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:105
msgid ""
"IPv6 supports several address types: unicast to address a single host, "
"multicast to address a group of hosts, anycast to address the nearest member "
"of a group of hosts (not implemented in Linux), IPv4-on-IPv6 to address a "
"IPv4 host, and other reserved address types."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:111
msgid ""
"The address notation for IPv6 is a group of 8 4-digit hexadecimal numbers, "
"separated with a \\(aq:\\(aq.  \\&\"::\" stands for a string of 0 bits.  "
"Special addresses are ::1 for loopback and ::FFFF:E<lt>IPv4 addressE<gt> for "
"IPv4-mapped-on-IPv6."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:113
msgid "The port space of IPv6 is shared with IPv4."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:121
msgid ""
"IPv6 supports some protocol-specific socket options that can be set with "
"B<setsockopt>(2)  and read with B<getsockopt>(2).  The socket option level "
"for IPv6 is B<IPPROTO_IPV6>.  A boolean integer flag is zero when it is "
"false, otherwise true."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:121
#, no-wrap
msgid "B<IPV6_ADDRFORM>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:135
msgid ""
"Turn an B<AF_INET6> socket into a socket of a different address family.  "
"Only B<AF_INET> is currently supported for that.  It is only allowed for "
"IPv6 sockets that are connected and bound to a v4-mapped-on-v6 address.  The "
"argument is a pointer to an integer containing B<AF_INET>.  This is useful "
"to pass v4-mapped sockets as file descriptors to programs that don't know "
"how to deal with the IPv6 API."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:135
#, no-wrap
msgid "B<IPV6_ADD_MEMBERSHIP, IPV6_DROP_MEMBERSHIP>"
msgstr ""

#.  FIXME IPV6_CHECKSUM is not documented, and probably should be
#.  FIXME IPV6_JOIN_ANYCAST is not documented, and probably should be
#.  FIXME IPV6_LEAVE_ANYCAST is not documented, and probably should be
#.  FIXME IPV6_RECVPKTINFO is not documented, and probably should be
#.  FIXME IPV6_2292PKTINFO is not documented, and probably should be
#.  FIXME there are probably many other IPV6_* socket options that
#.  should be documented
#. type: Plain text
#: build/C/man7/ipv6.7:148
msgid ""
"Control membership in multicast groups.  Argument is a pointer to a I<struct "
"ipv6_mreq> structure."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:148
#, no-wrap
msgid "B<IPV6_MTU>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:154
msgid ""
"Set the MTU to be used for the socket.  The MTU is limited by the device MTU "
"or the path MTU when path MTU discovery is enabled.  Argument is a pointer "
"to integer."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:154
#, no-wrap
msgid "B<IPV6_MTU_DISCOVER>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:162
msgid ""
"Control path-MTU discovery on the socket.  See B<IP_MTU_DISCOVER> in "
"B<ip>(7)  for details."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:162
#, no-wrap
msgid "B<IPV6_MULTICAST_HOPS>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:169
msgid ""
"Set the multicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:169
#, no-wrap
msgid "B<IPV6_MULTICAST_IF>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:181
msgid ""
"Set the device for outgoing multicast packets on the socket.  This is only "
"allowed for B<SOCK_DGRAM> and B<SOCK_RAW> socket.  The argument is a pointer "
"to an interface index (see B<netdevice>(7))  in an integer."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:181
#, no-wrap
msgid "B<IPV6_MULTICAST_LOOP>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:185
msgid ""
"Control whether the socket sees multicast packets that it has send itself.  "
"Argument is a pointer to boolean."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:185
#, no-wrap
msgid "B<IPV6_PKTINFO>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:196
msgid ""
"Set delivery of the B<IPV6_PKTINFO> control message on incoming datagrams.  "
"Only allowed for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a "
"pointer to a boolean value in an integer."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:199
msgid ""
"B<IPV6_RTHDR, IPV6_AUTHHDR, IPV6_DSTOPTS, IPV6_HOPOPTS, IPV6_FLOWINFO, "
"IPV6_HOPLIMIT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:224
msgid ""
"Set delivery of control messages for incoming datagrams containing extension "
"headers from the received packet.  B<IPV6_RTHDR> delivers the routing "
"header, B<IPV6_AUTHHDR> delivers the authentication header, B<IPV6_DSTOPTS> "
"delivers the destination options, B<IPV6_HOPOPTS> delivers the hop options, "
"B<IPV6_FLOWINFO> delivers an integer containing the flow ID, "
"B<IPV6_HOPLIMIT> delivers an integer containing the hop count of the "
"packet.  The control messages have the same type as the socket option.  All "
"these header options can also be set for outgoing packets by putting the "
"appropriate control message into the control buffer of B<sendmsg>(2).  Only "
"allowed for B<SOCK_DGRAM> or B<SOCK_RAW> sockets.  Argument is a pointer to "
"a boolean value."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:224
#, no-wrap
msgid "B<IPV6_RECVERR>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:233
msgid ""
"Control receiving of asynchronous error options.  See B<IP_RECVERR> in "
"B<ip>(7)  for details.  Argument is a pointer to boolean."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:233
#, no-wrap
msgid "B<IPV6_ROUTER_ALERT>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:246
msgid ""
"Pass forwarded packets containing a router alert hop-by-hop option to this "
"socket.  Only allowed for SOCK_RAW sockets.  The tapped packets are not "
"forwarded by the kernel, it is the user's responsibility to send them out "
"again.  Argument is a pointer to an integer.  A positive integer indicates a "
"router alert option value to intercept.  Packets carrying a router alert "
"option with a value field containing this integer will be delivered to the "
"socket.  A negative integer disables delivery of packets with router alert "
"options to this socket."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:246
#, no-wrap
msgid "B<IPV6_UNICAST_HOPS>"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:252
msgid ""
"Set the unicast hop limit for the socket.  Argument is a pointer to an "
"integer.  -1 in the value means use the route default, otherwise it should "
"be between 0 and 255."
msgstr ""

#. type: TP
#: build/C/man7/ipv6.7:252
#, no-wrap
msgid "B<IPV6_V6ONLY> (since Linux 2.4.21 and 2.6)"
msgstr ""

#.  See RFC 3493
#. type: Plain text
#: build/C/man7/ipv6.7:259
msgid ""
"If this flag is set to true (nonzero), then the socket is restricted to "
"sending and receiving IPv6 packets only.  In this case, an IPv4 and an IPv6 "
"application can bind to a single port at the same time."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:263
msgid ""
"If this flag is set to false (zero), then the socket can be used to send and "
"receive packets to and from an IPv6 address or an IPv4-mapped IPv6 address."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:265
msgid "The argument is a pointer to a boolean value in an integer."
msgstr ""

#.  FLOWLABEL_MGR, FLOWINFO_SEND
#. type: Plain text
#: build/C/man7/ipv6.7:270
msgid ""
"The default value for this flag is defined by the contents of the file "
"I</proc/sys/net/ipv6/bindv6only>.  The default value for that file is 0 "
"(false)."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:282
msgid ""
"The user tried to B<bind>(2)  to a link-local IPv6 address, but the "
"I<sin6_scope_id> in the supplied I<sockaddr_in6> structure is not a valid "
"interface index."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:287
msgid ""
"The older I<libinet6> libc5 based IPv6 API implementation for Linux is not "
"described here and may vary in details."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:303
msgid ""
"Linux 2.4 will break binary compatibility for the I<sockaddr_in6> for 64-bit "
"hosts by changing the alignment of I<in6_addr> and adding an additional "
"I<sin6_scope_id> field.  The kernel interfaces stay compatible, but a "
"program including I<sockaddr_in6> or I<in6_addr> into other structures may "
"not be.  This is not a problem for 32-bit hosts like i386."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:311
msgid ""
"The I<sin6_flowinfo> field is new in Linux 2.4.  It is transparently "
"passed/read by the kernel when the passed address length contains it.  Some "
"programs that pass a longer address buffer and then check the outgoing "
"address length may break."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:321
msgid ""
"The I<sockaddr_in6> structure is bigger than the generic I<sockaddr>.  "
"Programs that assume that all address types can be stored safely in a "
"I<struct sockaddr> need to be changed to use I<struct sockaddr_storage> for "
"that instead."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:326
msgid ""
"The IPv6 extended API as in RFC\\ 2292 is currently only partly implemented; "
"although the 2.2 kernel has near complete support for receiving options, the "
"macros for generating IPv6 options are missing in glibc 2.1."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:328
msgid "IPSec support for EH and AH headers is missing."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:330
msgid "Flow label management is not complete and not documented here."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:332
msgid "This man page is not complete."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:335
msgid "B<cmsg>(3), B<ip>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:338
msgid "RFC\\ 2553: IPv6 BASIC API.  Linux tries to be compliant to this."
msgstr ""

#. type: Plain text
#: build/C/man7/ipv6.7:340
msgid "RFC\\ 2460: IPv6 specification."
msgstr ""

#. type: TH
#: build/C/man7/netdevice.7:15
#, no-wrap
msgid "NETDEVICE"
msgstr ""

#. type: TH
#: build/C/man7/netdevice.7:15
#, no-wrap
msgid "2012-04-26"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:18
msgid "netdevice - Low level access to Linux network devices"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:20
msgid "B<#include E<lt>sys/ioctl.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:22
msgid "B<#include E<lt>net/if.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:25
msgid ""
"This man page describes the sockets interface which is used to configure "
"network devices."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:32
msgid ""
"Linux supports some standard ioctls to configure network devices.  They can "
"be used on any socket's file descriptor regardless of the family or type.  "
"They pass an I<ifreq> structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:53
#, no-wrap
msgid ""
"struct ifreq {\n"
"    char ifr_name[IFNAMSIZ]; /* Interface name */\n"
"    union {\n"
"        struct sockaddr ifr_addr;\n"
"        struct sockaddr ifr_dstaddr;\n"
"        struct sockaddr ifr_broadaddr;\n"
"        struct sockaddr ifr_netmask;\n"
"        struct sockaddr ifr_hwaddr;\n"
"        short           ifr_flags;\n"
"        int             ifr_ifindex;\n"
"        int             ifr_metric;\n"
"        int             ifr_mtu;\n"
"        struct ifmap    ifr_map;\n"
"        char            ifr_slave[IFNAMSIZ];\n"
"        char            ifr_newname[IFNAMSIZ];\n"
"        char           *ifr_data;\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:61
#, no-wrap
msgid ""
"struct ifconf {\n"
"    int                 ifc_len; /* size of buffer */\n"
"    union {\n"
"        char           *ifc_buf; /* buffer address */\n"
"        struct ifreq   *ifc_req; /* array of structures */\n"
"    };\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:69
msgid ""
"Normally, the user specifies which device to affect by setting I<ifr_name> "
"to the name of the interface.  All other members of the structure may share "
"memory."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:77
msgid ""
"If an ioctl is marked as privileged then using it requires an effective user "
"ID of 0 or the B<CAP_NET_ADMIN> capability.  If this is not the case "
"B<EPERM> will be returned."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:77
#, no-wrap
msgid "B<SIOCGIFNAME>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:85
msgid ""
"Given the I<ifr_ifindex>, return the name of the interface in I<ifr_name>.  "
"This is the only ioctl which returns its result in I<ifr_name>."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:85
#, no-wrap
msgid "B<SIOCGIFINDEX>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:89
msgid "Retrieve the interface index of the interface into I<ifr_ifindex>."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:89
#, no-wrap
msgid "B<SIOCGIFFLAGS>, B<SIOCSIFFLAGS>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:94
msgid ""
"Get or set the active flag word of the device.  I<ifr_flags> contains a bit "
"mask of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:98
#, no-wrap
msgid "Device flags\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:99
#, no-wrap
msgid "IFF_UP:Interface is running.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:100
#, no-wrap
msgid "IFF_BROADCAST:Valid broadcast address set.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:101
#, no-wrap
msgid "IFF_DEBUG:Internal debugging flag.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:102
#, no-wrap
msgid "IFF_LOOPBACK:Interface is a loopback interface.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:103
#, no-wrap
msgid "IFF_POINTOPOINT:Interface is a point-to-point link.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:104
#, no-wrap
msgid "IFF_RUNNING:Resources allocated.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:105
#, no-wrap
msgid "IFF_NOARP:No arp protocol, L2 destination address not set.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:106
#, no-wrap
msgid "IFF_PROMISC:Interface is in promiscuous mode.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:107
#, no-wrap
msgid "IFF_NOTRAILERS:Avoid use of trailers.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:108
#, no-wrap
msgid "IFF_ALLMULTI:Receive all multicast packets.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:109
#, no-wrap
msgid "IFF_MASTER:Master of a load balancing bundle.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:110
#, no-wrap
msgid "IFF_SLAVE:Slave of a load balancing bundle.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:111
#, no-wrap
msgid "IFF_MULTICAST:Supports multicast\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:112
#, no-wrap
msgid "IFF_PORTSEL:Is able to select media type via ifmap.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:113
#, no-wrap
msgid "IFF_AUTOMEDIA:Auto media selection active.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:114
#, no-wrap
msgid "IFF_DYNAMIC:T{\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:115
#, no-wrap
msgid "The addresses are lost when the interface goes down.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:116
#, no-wrap
msgid "T}\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:117
#, no-wrap
msgid "IFF_LOWER_UP:Driver signals L1 up (since Linux 2.6.17)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:118
#, no-wrap
msgid "IFF_DORMANT:Driver signals dormant (since Linux 2.6.17)\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:119
#, no-wrap
msgid "IFF_ECHO:Echo sent packets (since Linux 2.6.25)\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:125
msgid ""
"Setting the active flag word is a privileged operation, but any process may "
"read it."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:125
#, no-wrap
msgid "B<SIOCGIFPFLAGS>, B<SIOCSIFPFLAGS>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:130
msgid ""
"Get or set extended (private) flags for the device.  I<ifr_flags> contains a "
"bit mask of the following values:"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:134
#, no-wrap
msgid "Private flags\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:135
#, no-wrap
msgid "IFF_802_1Q_VLAN:Interface is 802.1Q VLAN device.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:136
#, no-wrap
msgid "IFF_EBRIDGE:Interface is Ethernet bridging device.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:137
#, no-wrap
msgid "IFF_SLAVE_INACTIVE:Interface is inactive bonding slave.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:138
#, no-wrap
msgid "IFF_MASTER_8023AD:Interface is 802.3ad bonding master.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:139
#, no-wrap
msgid "IFF_MASTER_ALB:Interface is balanced-alb bonding master.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:140
#, no-wrap
msgid "IFF_BONDING:Interface is a bonding master or slave.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:141
#, no-wrap
msgid "IFF_SLAVE_NEEDARP:Interface needs ARPs for validation.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/netdevice.7:142
#, no-wrap
msgid "IFF_ISATAP:Interface is RFC4214 ISATAP interface.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:146
msgid "Setting the extended (private) interface flags is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:146
#, no-wrap
msgid "B<SIOCGIFADDR>, B<SIOCSIFADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:154
msgid ""
"Get or set the address of the device using I<ifr_addr>.  Setting the "
"interface address is a privileged operation.  For compatibility, only "
"B<AF_INET> addresses are accepted or returned."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:154
#, no-wrap
msgid "B<SIOCGIFDSTADDR>, B<SIOCSIFDSTADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:162
msgid ""
"Get or set the destination address of a point-to-point device using "
"I<ifr_dstaddr>.  For compatibility, only B<AF_INET> addresses are accepted "
"or returned.  Setting the destination address is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:162
#, no-wrap
msgid "B<SIOCGIFBRDADDR>, B<SIOCSIFBRDADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:170
msgid ""
"Get or set the broadcast address for a device using I<ifr_brdaddr>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the broadcast address is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:170
#, no-wrap
msgid "B<SIOCGIFNETMASK>, B<SIOCSIFNETMASK>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:178
msgid ""
"Get or set the network mask for a device using I<ifr_netmask>.  For "
"compatibility, only B<AF_INET> addresses are accepted or returned.  Setting "
"the network mask is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:178
#, no-wrap
msgid "B<SIOCGIFMETRIC>, B<SIOCSIFMETRIC>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:187
msgid ""
"Get or set the metric of the device using I<ifr_metric>.  This is currently "
"not implemented; it sets I<ifr_metric> to 0 if you attempt to read it and "
"returns B<EOPNOTSUPP> if you attempt to set it."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:187
#, no-wrap
msgid "B<SIOCGIFMTU>, B<SIOCSIFMTU>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:194
msgid ""
"Get or set the MTU (Maximum Transfer Unit) of a device using I<ifr_mtu>.  "
"Setting the MTU is a privileged operation.  Setting the MTU to too small "
"values may cause kernel crashes."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:194
#, no-wrap
msgid "B<SIOCGIFHWADDR>, B<SIOCSIFHWADDR>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:205
msgid ""
"Get or set the hardware address of a device using I<ifr_hwaddr>.  The "
"hardware address is specified in a struct I<sockaddr>.  I<sa_family> "
"contains the ARPHRD_* device type, I<sa_data> the L2 hardware address "
"starting from byte 0.  Setting the hardware address is a privileged "
"operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:205
#, no-wrap
msgid "B<SIOCSIFHWBROADCAST>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:210
msgid ""
"Set the hardware broadcast address of a device from I<ifr_hwaddr>.  This is "
"a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:210
#, no-wrap
msgid "B<SIOCGIFMAP>, B<SIOCSIFMAP>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:215
msgid ""
"Get or set the interface's hardware parameters using I<ifr_map>.  Setting "
"the parameters is a privileged operation."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:226
#, no-wrap
msgid ""
"struct ifmap {\n"
"    unsigned long   mem_start;\n"
"    unsigned long   mem_end;\n"
"    unsigned short  base_addr;\n"
"    unsigned char   irq;\n"
"    unsigned char   dma;\n"
"    unsigned char   port;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:231
msgid ""
"The interpretation of the ifmap structure depends on the device driver and "
"the architecture."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:231
#, no-wrap
msgid "B<SIOCADDMULTI>, B<SIOCDELMULTI>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:240
msgid ""
"Add an address to or delete an address from the device's link layer "
"multicast filters using I<ifr_hwaddr>.  These are privileged operations.  "
"See also B<packet>(7)  for an alternative."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:240
#, no-wrap
msgid "B<SIOCGIFTXQLEN>, B<SIOCSIFTXQLEN>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:245
msgid ""
"Get or set the transmit queue length of a device using I<ifr_qlen>.  Setting "
"the transmit queue length is a privileged operation."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:245
#, no-wrap
msgid "B<SIOCSIFNAME>"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:254
msgid ""
"Changes the name of the interface specified in I<ifr_name> to "
"I<ifr_newname>.  This is a privileged operation.  It is only allowed when "
"the interface is not up."
msgstr ""

#. type: TP
#: build/C/man7/netdevice.7:254
#, no-wrap
msgid "B<SIOCGIFCONF>"
msgstr ""

#.  Slaving isn't supported in 2.2
#.  .
#.  .TP
#.  .BR SIOCGIFSLAVE ", " SIOCSIFSLAVE
#.  Get or set the slave device using
#.  .IR ifr_slave .
#.  Setting the slave device is a privileged operation.
#.  .PP
#.  FIXME add amateur radio stuff.
#. type: Plain text
#: build/C/man7/netdevice.7:294
msgid ""
"Return a list of interface (transport layer) addresses.  This currently "
"means only addresses of the B<AF_INET> (IPv4) family for compatibility.  The "
"user passes a I<ifconf> structure as argument to the ioctl.  It contains a "
"pointer to an array of I<ifreq> structures in I<ifc_req> and its length in "
"bytes in I<ifc_len>.  The kernel fills the ifreqs with all current L3 "
"interface addresses that are running: I<ifr_name> contains the interface "
"name (eth0:1 etc.), I<ifr_addr> the address.  The kernel returns with the "
"actual length in I<ifc_len>.  If I<ifc_len> is equal to the original length "
"the buffer probably has overflowed and you should retry with a bigger buffer "
"to get all addresses.  When no error occurs the ioctl returns 0; otherwise "
"-1.  Overflow is not an error."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:300
msgid ""
"Most protocols support their own ioctls to configure protocol-specific "
"interface options.  See the protocol man pages for a description.  For "
"configuring IP addresses see B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:303
msgid ""
"In addition some devices support private ioctls.  These are not described "
"here."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:311
msgid ""
"Strictly speaking, B<SIOCGIFCONF> and the other ioctls that only accept or "
"return B<AF_INET> socket addresses, are IP specific and belong in B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:316
msgid ""
"The names of interfaces with no addresses or that don't have the "
"B<IFF_RUNNING> flag set can be found via I</proc/net/dev>."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:321
msgid ""
"Local IPv6 IP addresses can be found via I</proc/net> or via "
"B<rtnetlink>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:327
msgid ""
"glibc 2.1 is missing the I<ifr_newname> macro in I<E<lt>net/if.hE<gt>>.  Add "
"the following to your program as a workaround:"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:333
#, no-wrap
msgid ""
"#ifndef ifr_newname\n"
"#define ifr_newname     ifr_ifru.ifru_slave\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man7/netdevice.7:340
msgid "B<proc>(5), B<capabilities>(7), B<ip>(7), B<rtnetlink>(7)"
msgstr ""

#. type: TH
#: build/C/man5/networks.5:24
#, no-wrap
msgid "NETWORKS"
msgstr ""

#. type: TH
#: build/C/man5/networks.5:24
#, no-wrap
msgid "2008-09-04"
msgstr ""

#. type: TH
#: build/C/man5/networks.5:24
#, no-wrap
msgid "GNU/Linux"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:27
msgid "networks - network name information"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:33
msgid ""
"The file I</etc/networks> is a plain ASCII file that describes known DARPA "
"networks and symbolic names for these networks.  Each line represents a "
"network and has the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:36
msgid "I<name number aliases ...>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:44
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"The hash character (B<#>) indicates the start of a comment: this character, "
"and the remaining characters up to the end of the current line, are ignored "
"by library functions that process the file."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:46 build/C/man5/protocols.5:58
msgid "The field descriptions are:"
msgstr ""

#. type: TP
#: build/C/man5/networks.5:47
#, no-wrap
msgid "I<name>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:52
msgid ""
"The symbolic name for the network.  Network names can contain any printable "
"characters execept white-space characters or the comment character."
msgstr ""

#. type: TP
#: build/C/man5/networks.5:52 build/C/man5/protocols.5:66
#, no-wrap
msgid "I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:57
msgid ""
"The official number for this network in numbers-and-dots notation (see "
"B<inet>(3)).  The trailing \".0\" (for the host component of the network "
"address) may be omitted."
msgstr ""

#. type: TP
#: build/C/man5/networks.5:57 build/C/man5/protocols.5:70 build/C/man5/services.5:120
#, no-wrap
msgid "I<aliases>"
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:60
msgid "Optional aliases for the network."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:69
msgid ""
"This file is read by the B<route>(8)  and B<netstat>(8)  utilities.  Only "
"Class A, B or C networks are supported, partitioned networks (i.e., "
"network/26 or network/28) are not supported by this facility."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:73
msgid "The networks definition file."
msgstr ""

#. type: Plain text
#: build/C/man5/networks.5:79
msgid ""
"B<getnetbyaddr>(3), B<getnetbyname>(3), B<getnetent>(3), B<netstat>(8), "
"B<route>(8)"
msgstr ""

#. type: TH
#: build/C/man8/nscd.8:23
#, no-wrap
msgid "NSCD"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:26
msgid "nscd - name service cache daemon"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:34
msgid ""
"Nscd is a daemon that provides a cache for the most common name service "
"requests.  The default configuration file, I</etc/nscd.conf>, determines the "
"behavior of the cache daemon.  See B<nscd.conf>(5)."
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:47
msgid ""
"Nscd provides caching for accesses of the B<passwd>(5), B<group>(5), and "
"B<hosts>(5)  databases through standard libc interfaces, such as "
"B<getpwnam>(3), B<getpwuid>(3), B<getgrnam>(3), B<getgrgid>(3), "
"B<gethostbyname>(3), and others."
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:56
msgid ""
"There are two caches for each database: a positive one for items found, and "
"a negative one for items not found.  Each cache has a separate TTL "
"(time-to-live)  period for its data.  Note that the shadow file is "
"specifically not cached.  B<getspnam>(3)  calls remain uncached as a result."
msgstr ""

#. type: SH
#: build/C/man8/nscd.8:56
#, no-wrap
msgid "OPTIONS"
msgstr ""

#. type: TP
#: build/C/man8/nscd.8:57
#, no-wrap
msgid "B<--help>"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:60
msgid "will give you a list with all options and what they do."
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:83
msgid ""
"The daemon will try to watch for changes in configuration files appropriate "
"for each database (e.g., I</etc/passwd> for the I<passwd> database or "
"I</etc/hosts> and I</etc/resolv.conf> for the I<hosts> database), and flush "
"the cache when these are changed.  However, this will happen only after a "
"short delay (unless the B<inotify>(7)  mechanism is available and glibc 2.9 "
"or later is available), and this auto-detection does not cover configuration "
"files required by nonstandard NSS modules, if any are specified in "
"I</etc/nsswitch.conf>.  In that case, you need to run the following command "
"after changing the configuration file of the database so that B<nscd> "
"invalidates its cache:"
msgstr ""

#. type: Plain text
#: build/C/man8/nscd.8:85
#, no-wrap
msgid "    $ B<nscd -i> I<E<lt>databaseE<gt>>\n"
msgstr ""

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man8/nscd.8:91
msgid "B<nscd.conf>(5), B<nsswitch.conf>(5)"
msgstr ""

#. type: TH
#: build/C/man5/nscd.conf.5:20
#, no-wrap
msgid "NSCD.CONF"
msgstr ""

#. type: TH
#: build/C/man5/nscd.conf.5:20
#, no-wrap
msgid "1999-10-01"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:23
msgid "/etc/nscd.conf - name service cache daemon configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:36
msgid ""
"The file I</etc/nscd.conf> is read from B<nscd>(8)  at startup.  Each line "
"specifies either an attribute and a value, or an attribute, service, and a "
"value.  Fields are separated either by SPACE or TAB characters.  A "
"\\(aq#\\(aq (number sign) indicates the beginning of a comment; following "
"characters, up to the end of the line, are not interpreted by nscd."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:38
msgid "Valid services are I<passwd>, I<group>, or I<hosts>."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:41
msgid "B<logfile> I<debug-file-name>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:43
msgid "Specifies name of the file to which debug info should be written."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:47
msgid "B<debug-level> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:49
msgid "Sets the desired debug level."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:53
msgid "B<threads> I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:57
msgid ""
"This is the number of threads that are started to wait for requests.  At "
"least five threads will always be created."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:61
msgid "B<server-user> I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:65
msgid ""
"If this option is set, nscd will run as this user and not as root.  If a "
"separate cache for every user is used (-S parameter), this option is "
"ignored."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:70
msgid "B<enable-cache> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:74
msgid "Enables or disables the specified I<service> cache."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:79
msgid "B<positive-time-to-live> I<service> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:87
msgid ""
"Sets the TTL (time-to-live) for positive entries (successful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Larger values "
"increase cache hit rates and reduce mean response times, but increase "
"problems with cache coherence."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:92
msgid "B<negative-time-to-live> I<service> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:102
msgid ""
"Sets the TTL (time-to-live) for negative entries (unsuccessful queries)  in "
"the specified cache for I<service>.  I<Value> is in seconds.  Can result in "
"significant performance improvements if there are several files owned by "
"UIDs (user IDs) not in system databases (for example untarring the linux "
"kernel sources as root); should be kept small to reduce cache coherency "
"problems."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:107
msgid "B<suggested-size> I<service> I<value>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:111
msgid ""
"This is the internal hash table size, I<value> should remain a prime number "
"for optimum efficiency."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:116
msgid "B<check-files> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:125
msgid ""
"Enables or disables checking the file belonging to the specified I<service> "
"for changes.  The files are I</etc/passwd>, I</etc/group>, and "
"I</etc/hosts>."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:129
msgid "B<max-threads> I<threads>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:131
msgid "Specifies the maximum number of threads to be started."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:135
msgid "B<stat-user> I<username>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:137
msgid "Specifies the user who is allowed to request statistics."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:142
msgid "B<reload-count> unlimited | I<number>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:146
msgid ""
"Limit on the number of times a cached entry gets reloaded without being used "
"before it gets removed.  The default is 5."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:150
msgid "B<paranoia> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:152
msgid "Enabling paranoia mode causes nscd to restart itself periodically."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:156
msgid "B<restart-interval> I<time>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:163
msgid ""
"Sets the restart interval to I<time> seconds if periodic restart is enabled "
"by enabling B<paranoia> mode."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:168
msgid "B<persistent> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:174
msgid ""
"Keep the content of the cache for I<service> over server restarts; useful "
"when B<paranoia> mode is set."
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:179
msgid "B<shared> I<service> I<E<lt>yes|noE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/nscd.conf.5:185
msgid ""
"The memory mapping of the nscd databases for I<service> is shared with the "
"clients so that they can directly search in them instead of having to ask "
"the daemon over the socket each time a lookup is performed."
msgstr ""

#.  .SH AUTHOR
#.  .B nscd
#.  was written by Thorsten Kukuk and Ulrich Drepper.
#. type: Plain text
#: build/C/man5/nscd.conf.5:191
msgid "B<nscd>(8)"
msgstr ""

#. type: TH
#: build/C/man5/nsswitch.conf.5:24
#, no-wrap
msgid "NSSWITCH.CONF"
msgstr ""

#. type: TH
#: build/C/man5/nsswitch.conf.5:24
#, no-wrap
msgid "2012-04-14"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:27
msgid "nsswitch.conf - Name Service Switch configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:35
msgid ""
"The Name Service Switch (NSS) configuration file, I</etc/nsswitch.conf>, is "
"used by the GNU C Library to determine the sources from which to obtain "
"name-service information in a range of categories, and in what order.  Each "
"category of information is identified by a database name."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:41
msgid ""
"The file is plain ASCII text, with columns separated by spaces or tab "
"characters.  The first column specifies the database name.  The remaining "
"columns describe the order of sources to query and a limited set of actions "
"that can be performed by lookup result."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:43
msgid "The following databases are understood by the GNU C Library:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:48
msgid "Mail aliases, used by B<getaliasent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:51
msgid "Ethernet numbers."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:56
msgid "Groups of users, used by B<getgrent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:61
msgid "Host names and numbers, used by B<gethostbyname>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:65
msgid ""
"Network-wide list of hosts and users, used for access rules.  C libraries "
"before glibc 2.1 supported netgroups only over NIS."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:70
msgid "Network names and numbers, used by B<getnetent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:75
msgid "User passwords, used by B<getpwent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:80
msgid "Network protocols, used by B<getprotoent>(3)  and related functions."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:80
#, no-wrap
msgid "B<publickey>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:83
msgid "Public and secret keys for Secure_RPC used by NFS and NIS+."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:88
msgid ""
"Remote procedure call names and numbers, used by B<getrpcbyname>(3)  and "
"related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:93
msgid "Network services, used by B<getservent>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:98
msgid "Shadow user passwords, used by B<getspnam>(3)  and related functions."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:102
msgid "Here is an example I</etc/nsswitch.conf> file:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:105
#, no-wrap
msgid "passwd:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:108 build/C/man5/nsswitch.conf.5:111 build/C/man5/nsswitch.conf.5:114
msgid "compat"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:108
#, no-wrap
msgid "group:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:111
#, no-wrap
msgid "shadow:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:115
#, no-wrap
msgid "hosts:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:118
msgid "dns [!UNAVAIL=return] files"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:118
#, no-wrap
msgid "networks:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:121 build/C/man5/nsswitch.conf.5:124 build/C/man5/nsswitch.conf.5:127 build/C/man5/nsswitch.conf.5:130 build/C/man5/nsswitch.conf.5:133
msgid "nis [NOTFOUND=return] files"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:121
#, no-wrap
msgid "ethers:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:124
#, no-wrap
msgid "protocols:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:127
#, no-wrap
msgid "rpc:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:130
#, no-wrap
msgid "services:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:138
msgid "The first column is the database name.  The remaining columns specify:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:142
msgid ""
"One or more service specifications e.g., \"files\", \"db\", or \"nis\".  The "
"order of the services on the line determines the order in which those "
"services will be queried, in turn, until a result is found."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:145
msgid ""
"Optional actions to perform if a particular result is obtained from the "
"preceding service, e.g., \"[NOTFOUND=return]\"."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:172
msgid ""
"The service specifications supported on your system depend on the presence "
"of shared libraries, and are therefore extensible.  Libraries called "
"I</lib/libnss_SERVICE.so.>B<X> will provide the named I<SERVICE>.  On a "
"standard installation, you can use \"files\", \"db\", \"nis\", and "
"\"nisplus\".  For the B<hosts> database, you can additionally specify "
"\"dns\".  For the B<passwd>, B<group>, and B<shadow> databases, you can "
"additionally specify \"compat\" (see B<Compatibility mode> below).  The "
"version number B<X> may be 1 for glibc 2.0, or 2 for glibc 2.1 and later.  "
"On systems with additional libraries installed, you may have access to "
"further services such as \"hesiod\", \"ldap\", \"winbind\" and \"wins\"."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:177
msgid ""
"An action may also be specified following a service specification.  The "
"action modifies the behavior following a result obtained from the preceding "
"data source.  Action items take the general form:"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:180
msgid "[I<STATUS>=I<ACTION>]"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:182
msgid "[!I<STATUS>=I<ACTION>]"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:185
msgid "where"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:196
msgid "I<STATUS> =E<gt> B<success> | B<notfound> | B<unavail> | B<tryagain>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:202
msgid "I<ACTION> =E<gt> B<return> | B<continue>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:207
msgid ""
"The ! negates the test, matching all possible results except the one "
"specified.  The case of the keywords is not significant."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:212
msgid ""
"The I<STATUS> value is matched against the result of the lookup function "
"called by the preceding service specification, and can be one of:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:213
#, no-wrap
msgid "B<success>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:217
msgid ""
"No error occurred and the requested entry is returned.  The default action "
"for this condition is \"return\"."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:217
#, no-wrap
msgid "B<notfound>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:221
msgid ""
"The lookup succeeded, but the requested entry was not found.  The default "
"action for this condition is \"continue\"."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:221
#, no-wrap
msgid "B<unavail>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:228
msgid ""
"The service is permanently unavailable.  This can mean either that the "
"required file cannot be read, or, for network services, that the server is "
"not available or does not allow queries.  The default action for this "
"condition is \"continue\"."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:228
#, no-wrap
msgid "B<tryagain>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:234
msgid ""
"The service is temporarily unavailable.  This could mean a file is locked or "
"a server currently cannot accept more connections.  The default action for "
"this condition is \"continue\"."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:239
msgid "The I<ACTION> value can be one of:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:240
#, no-wrap
msgid "B<return>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:244
msgid "Return a result now.  Do not call any further lookup functions."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:244
#, no-wrap
msgid "B<continue>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:247
msgid "Call the next lookup function."
msgstr ""

#. type: SS
#: build/C/man5/nsswitch.conf.5:248
#, no-wrap
msgid "Compatibility mode (compat)"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:254
msgid ""
"The NSS \"compat\" service is similar to \"files\" except that it "
"additionally permits special entries in I</etc/passwd> for granting users or "
"members of netgroups access to the system.  The following entries are valid "
"in this mode:"
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:255
#, no-wrap
msgid "B<+>I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:260
msgid "Include the specified I<user> from the NIS passwd map."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:260
#, no-wrap
msgid "B<+@>I<netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:264
msgid "Include all users in the given I<netgroup>."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:264
#, no-wrap
msgid "B<->I<user>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:269
msgid "Exclude the specified I<user> from the NIS passwd map."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:269
#, no-wrap
msgid "B<-@>I<netgroup>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:273
msgid "Exclude all users in the given I<netgroup>."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:273
#, no-wrap
msgid "B<+>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:277
msgid ""
"Include every user, except previously excluded ones, from the NIS passwd "
"map."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:285
msgid ""
"By default the source is \"nis\", but this may be overridden by specifying "
"\"nisplus\" as the source for the pseudo-databases B<passwd_compat>, "
"B<group_compat>, and B<shadow_compat>."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:292
msgid ""
"A service named I<SERVICE> is implemented by a shared object library named "
"I<libnss_SERVICE.so.>B<X> that resides in I</lib>."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:297
msgid "NSS configuration file."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:297
#, no-wrap
msgid "I</lib/libnss_compat.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:300
msgid "implements \"compat\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:300
#, no-wrap
msgid "I</lib/libnss_db.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:303
msgid "implements \"db\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:303
#, no-wrap
msgid "I</lib/libnss_dns.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:306
msgid "implements \"dns\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:306
#, no-wrap
msgid "I</lib/libnss_files.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:309
msgid "implements \"files\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:309
#, no-wrap
msgid "I</lib/libnss_hesiod.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:312
msgid "implements \"hesiod\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:312
#, no-wrap
msgid "I</lib/libnss_nis.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:315
msgid "implements \"nis\" source."
msgstr ""

#. type: TP
#: build/C/man5/nsswitch.conf.5:315
#, no-wrap
msgid "I</lib/libnss_nisplus.so.>B<X>"
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:318
msgid "implements \"nisplus\" source."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:326
msgid ""
"Within each process that uses B<nsswitch.conf>, the entire file is read only "
"once.  If the file is later changed, the process will continue using the old "
"configuration."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:339
msgid ""
"Traditionally, there was only a single source for service information, often "
"in the form of a single configuration file (e.g., I</etc/passwd>).  However, "
"as other name services, such as the Network Information Service (NIS) and "
"the Domain Name Service (DNS), became popular, a method was needed that "
"would be more flexible than fixed search orders coded into the C library.  "
"The Name Service Switch mechanism, which was based on the mechanism used by "
"Sun Microsystems in the Solaris 2 C library, introduced a cleaner solution "
"to the problem."
msgstr ""

#. type: Plain text
#: build/C/man5/nsswitch.conf.5:342
msgid "B<getent>(1), B<nss>(5)"
msgstr ""

#. type: TH
#: build/C/man7/packet.7:7
#, no-wrap
msgid "PACKET"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:10
msgid "packet - packet interface on device level."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:13
#, no-wrap
msgid "B<#include E<lt>sys/socket.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:15
#, no-wrap
msgid "B<#include E<lt>netpacket/packet.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:17
#, no-wrap
msgid "B<#include E<lt>net/ethernet.hE<gt> /* the L2 protocols */>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:19
#, no-wrap
msgid ""
"B<packet_socket = socket(AF_PACKET, int >I<socket_type>B<, int "
">I<protocol>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:25
msgid ""
"Packet sockets are used to receive or send raw packets at the device driver "
"(OSI Layer 2) level.  They allow the user to implement protocol modules in "
"user space on top of the physical layer."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:47
msgid ""
"The I<socket_type> is either B<SOCK_RAW> for raw packets including the link "
"level header or B<SOCK_DGRAM> for cooked packets with the link level header "
"removed.  The link level header information is available in a common format "
"in a I<sockaddr_ll>.  I<protocol> is the IEEE 802.3 protocol number in "
"network order.  See the I<E<lt>linux/if_ether.hE<gt>> include file for a "
"list of allowed protocols.  When protocol is set to B<htons(ETH_P_ALL)> then "
"all protocols are received.  All incoming packets of that protocol type will "
"be passed to the packet socket before they are passed to the protocols "
"implemented in the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:51
msgid ""
"Only processes with effective UID 0 or the B<CAP_NET_RAW> capability may "
"open packet sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:69
msgid ""
"B<SOCK_RAW> packets are passed to and from the device driver without any "
"changes in the packet data.  When receiving a packet, the address is still "
"parsed and passed in a standard I<sockaddr_ll> address structure.  When "
"transmitting a packet, the user supplied buffer should contain the physical "
"layer header.  That packet is then queued unmodified to the network driver "
"of the interface defined by the destination address.  Some device drivers "
"always add other headers.  B<SOCK_RAW> is similar to but not compatible with "
"the obsolete B<AF_INET/SOCK_PACKET> of Linux 2.0."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:79
msgid ""
"B<SOCK_DGRAM> operates on a slightly higher level.  The physical header is "
"removed before the packet is passed to the user.  Packets sent through a "
"B<SOCK_DGRAM> packet socket get a suitable physical layer header based on "
"the information in the I<sockaddr_ll> destination address before they are "
"queued."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:92
msgid ""
"By default all packets of the specified protocol type are passed to a packet "
"socket.  To only get packets from a specific interface use B<bind>(2)  "
"specifying an address in a I<struct sockaddr_ll> to bind the packet socket "
"to an interface.  Only the I<sll_protocol> and the I<sll_ifindex> address "
"fields are used for purposes of binding."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:96
msgid "The B<connect>(2)  operation is not supported on packet sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:105
msgid ""
"When the B<MSG_TRUNC> flag is passed to B<recvmsg>(2), B<recv>(2), "
"B<recvfrom>(2)  the real length of the packet on the wire is always "
"returned, even when it is longer than the buffer."
msgstr ""

#. type: SS
#: build/C/man7/packet.7:105
#, no-wrap
msgid "Address Types"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:107
msgid "The sockaddr_ll is a device independent physical layer address."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:119
#, no-wrap
msgid ""
"struct sockaddr_ll {\n"
"    unsigned short sll_family;   /* Always AF_PACKET */\n"
"    unsigned short sll_protocol; /* Physical layer protocol */\n"
"    int            sll_ifindex;  /* Interface number */\n"
"    unsigned short sll_hatype;   /* ARP hardware type */\n"
"    unsigned char  sll_pkttype;  /* Packet type */\n"
"    unsigned char  sll_halen;    /* Length of address */\n"
"    unsigned char  sll_addr[8];  /* Physical layer address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:158
msgid ""
"I<sll_protocol> is the standard ethernet protocol type in network order as "
"defined in the I<E<lt>linux/if_ether.hE<gt>> include file.  It defaults to "
"the socket's protocol.  I<sll_ifindex> is the interface index of the "
"interface (see B<netdevice>(7)); 0 matches any interface (only permitted for "
"binding).  I<sll_hatype> is an ARP type as defined in the "
"I<E<lt>linux/if_arp.hE<gt>> include file.  I<sll_pkttype> contains the "
"packet type.  Valid types are B<PACKET_HOST> for a packet addressed to the "
"local host, B<PACKET_BROADCAST> for a physical layer broadcast packet, "
"B<PACKET_MULTICAST> for a packet sent to a physical layer multicast address, "
"B<PACKET_OTHERHOST> for a packet to some other host that has been caught by "
"a device driver in promiscuous mode, and B<PACKET_OUTGOING> for a packet "
"originated from the local host that is looped back to a packet socket.  "
"These types make only sense for receiving.  I<sll_addr> and I<sll_halen> "
"contain the physical layer (e.g., IEEE 802.3) address and its length.  The "
"exact interpretation depends on the device."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:174
msgid ""
"When you send packets it is enough to specify I<sll_family>, I<sll_addr>, "
"I<sll_halen>, I<sll_ifindex>.  The other fields should be 0.  I<sll_hatype> "
"and I<sll_pkttype> are set on received packets for your information.  For "
"bind only I<sll_protocol> and I<sll_ifindex> are used."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:189
msgid ""
"Packet sockets can be used to configure physical layer multicasting and "
"promiscuous mode.  It works by calling B<setsockopt>(2)  on a packet socket "
"for B<SOL_PACKET> and one of the options B<PACKET_ADD_MEMBERSHIP> to add a "
"binding or B<PACKET_DROP_MEMBERSHIP> to drop it.  They both expect a "
"B<packet_mreq> structure as argument:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:198
#, no-wrap
msgid ""
"struct packet_mreq {\n"
"    int            mr_ifindex;    /* interface index */\n"
"    unsigned short mr_type;       /* action */\n"
"    unsigned short mr_alen;       /* address length */\n"
"    unsigned char  mr_address[8]; /* physical layer address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:219
msgid ""
"B<mr_ifindex> contains the interface index for the interface whose status "
"should be changed.  The B<mr_type> parameter specifies which action to "
"perform.  B<PACKET_MR_PROMISC> enables receiving all packets on a shared "
"medium (often known as \"promiscuous mode\"), B<PACKET_MR_MULTICAST> binds "
"the socket to the physical layer multicast group specified in B<mr_address> "
"and B<mr_alen>, and B<PACKET_MR_ALLMULTI> sets the socket up to receive all "
"multicast packets arriving at the interface."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:225
msgid ""
"In addition the traditional ioctls B<SIOCSIFFLAGS>, B<SIOCADDMULTI>, "
"B<SIOCDELMULTI> can be used for the same purpose."
msgstr ""

#.  FIXME Document SIOCGSTAMPNS
#. type: Plain text
#: build/C/man7/packet.7:231
msgid ""
"B<SIOCGSTAMP> can be used to receive the timestamp of the last received "
"packet.  Argument is a I<struct timeval.>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:237
msgid ""
"In addition all standard ioctls defined in B<netdevice>(7)  and B<socket>(7)  "
"are valid on packet sockets."
msgstr ""

#. type: SS
#: build/C/man7/packet.7:237 build/C/man7/raw.7:127 build/C/man7/tcp.7:1080 build/C/man7/udp.7:97
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:241
msgid ""
"Packet sockets do no error handling other than errors occurred while passing "
"the packet to the device driver.  They don't have the concept of a pending "
"error."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:245
msgid "Unknown multicast group address passed."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:248
msgid "User passed invalid memory address."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:251 build/C/man7/raw.7:151
msgid "Invalid argument."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:254
msgid "Packet is bigger than interface MTU."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:254
#, no-wrap
msgid "B<ENETDOWN>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:257
msgid "Interface is not up."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:260
msgid "Not enough memory to allocate the packet."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:263
msgid "Unknown device name or interface index specified in interface address."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:266
msgid "No packet received."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:269
msgid "No interface address passed."
msgstr ""

#. type: TP
#: build/C/man7/packet.7:269
#, no-wrap
msgid "B<ENXIO>"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:272
msgid "Interface address contained an invalid interface index."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:275
msgid "User has insufficient privileges to carry out this operation."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:277
msgid "In addition other errors may be generated by the low-level driver."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:282
msgid ""
"B<AF_PACKET> is a new feature in Linux 2.2.  Earlier Linux versions "
"supported only B<SOCK_PACKET>."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:287
msgid ""
"The include file I<E<lt>netpacket/packet.hE<gt>> is present since glibc "
"2.1.  Older systems need:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:293
#, no-wrap
msgid ""
"#include E<lt>asm/types.hE<gt>\n"
"#include E<lt>linux/if_packet.hE<gt>\n"
"#include E<lt>linux/if_ether.hE<gt>  /* The L2 protocols */\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:303
msgid ""
"For portable programs it is suggested to use B<AF_PACKET> via B<pcap>(3); "
"although this only covers a subset of the B<AF_PACKET> features."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:324
msgid ""
"The B<SOCK_DGRAM> packet sockets make no attempt to create or parse the IEEE "
"802.2 LLC header for a IEEE 802.3 frame.  When B<ETH_P_802_3> is specified "
"as protocol for sending the kernel creates the 802.3 frame and fills out the "
"length field; the user has to supply the LLC header to get a fully "
"conforming packet.  Incoming 802.3 packets are not multiplexed on the "
"DSAP/SSAP protocol fields; instead they are supplied to the user as protocol "
"B<ETH_P_802_2> with the LLC header prepended.  It is thus not possible to "
"bind to B<ETH_P_802_3>; bind to B<ETH_P_802_2> instead and do the protocol "
"multiplex yourself.  The default for sending is the standard Ethernet DIX "
"encapsulation with the protocol filled in."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:326
msgid "Packet sockets are not subject to the input or output firewall chains."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:336
msgid ""
"In Linux 2.0, the only way to get a packet socket was by calling "
"B<socket(AF_INET, SOCK_PACKET, >I<protocol>B<)>.  This is still supported "
"but strongly deprecated.  The main difference between the two methods is "
"that B<SOCK_PACKET> uses the old I<struct sockaddr_pkt> to specify an "
"interface, which doesn't provide physical layer independence."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:344
#, no-wrap
msgid ""
"struct sockaddr_pkt {\n"
"    unsigned short spkt_family;\n"
"    unsigned char  spkt_device[14];\n"
"    unsigned short spkt_protocol;\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:356
msgid ""
"I<spkt_family> contains the device type, I<spkt_protocol> is the IEEE 802.3 "
"protocol type as defined in I<E<lt>sys/if_ether.hE<gt>> and I<spkt_device> "
"is the device name as a null-terminated string, for example, eth0."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:358
msgid "This structure is obsolete and should not be used in new code."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:362
msgid ""
"glibc 2.1 does not have a define for B<SOL_PACKET>.  The suggested "
"workaround is to use:"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:368
#, no-wrap
msgid ""
"#ifndef SOL_PACKET\n"
"#define SOL_PACKET 263\n"
"#endif\n"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:373
msgid ""
"This is fixed in later glibc versions and also does not occur on libc5 "
"systems."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:375
msgid "The IEEE 802.2/803.3 LLC handling could be considered as a bug."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:377
msgid "Socket filters are not documented."
msgstr ""

#.  .SH CREDITS
#.  This man page was written by Andi Kleen with help from Matthew Wilcox.
#.  AF_PACKET in Linux 2.2 was implemented
#.  by Alexey Kuznetsov, based on code by Alan Cox and others.
#. type: Plain text
#: build/C/man7/packet.7:389
msgid ""
"The B<MSG_TRUNC> B<recvmsg>(2)  extension is an ugly hack and should be "
"replaced by a control message.  There is currently no way to get the "
"original destination address of packets via B<SOCK_DGRAM>."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:396
msgid ""
"B<socket>(2), B<pcap>(3), B<capabilities>(7), B<ip>(7), B<raw>(7), "
"B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:398
msgid "RFC\\ 894 for the standard IP Ethernet encapsulation."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:400
msgid "RFC\\ 1700 for the IEEE 802.3 IP encapsulation."
msgstr ""

#. type: Plain text
#: build/C/man7/packet.7:404
msgid "The I<E<lt>linux/if_ether.hE<gt>> include file for physical layer protocols."
msgstr ""

#. type: TH
#: build/C/man5/protocols.5:28
#, no-wrap
msgid "PROTOCOLS"
msgstr ""

#. type: TH
#: build/C/man5/protocols.5:28
#, no-wrap
msgid "2008-09-23"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:31
msgid "protocols - protocols definition file"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:39
msgid ""
"This file is a plain ASCII file, describing the various DARPA internet "
"protocols that are available from the TCP/IP subsystem.  It should be "
"consulted instead of using the numbers in the ARPA include files, or, even "
"worse, just guessing them.  These numbers will occur in the protocol field "
"of any IP header."
msgstr ""

#.  .. by the DDN Network Information Center.
#. type: Plain text
#: build/C/man5/protocols.5:45
msgid ""
"Keep this file untouched since changes would result in incorrect IP "
"packages.  Protocol numbers and names are specified by the IANA (Internet "
"Assigned Numbers Authority)."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:47
msgid "Each line is of the following format:"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:50
msgid "I<protocol number aliases ...>"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:56
msgid ""
"where the fields are delimited by spaces or tabs.  Empty lines are ignored.  "
"If a line contains a hash mark (#), the hash mark and the part of the line "
"following it are ignored."
msgstr ""

#. type: TP
#: build/C/man5/protocols.5:58 build/C/man5/services.5:109
#, no-wrap
msgid "I<protocol>"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:66
msgid "the native name for the protocol.  For example I<ip>, I<tcp>, or I<udp>."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:70
msgid ""
"the official number for this protocol as it will appear within the IP "
"header."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:73
msgid "optional aliases for the protocol."
msgstr ""

#.  The following is not true as at glibc 2.8 (a line with a comma is
#.  ignored by getservent()); it's not clear if/when it was ever true.
#.    As a backward compatibility feature, the slash (/) between the
#.    .I port
#.    number and
#.    .I protocol
#.    name can in fact be either a slash or a comma (,).
#.    Use of the comma in
#.    modern installations is deprecated.
#. type: Plain text
#: build/C/man5/protocols.5:76 build/C/man5/services.5:165
msgid ""
"This file might be distributed over a network using a network-wide naming "
"service like Yellow Pages/NIS or BIND/Hesiod."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:80
msgid "The protocols definition file."
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:82
msgid "B<getprotoent>(3)"
msgstr ""

#. type: Plain text
#: build/C/man5/protocols.5:84
msgid "http://www.iana.org/assignments/protocol-numbers"
msgstr ""

#. type: TH
#: build/C/man7/raw.7:9
#, no-wrap
msgid "RAW"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:12
msgid "raw - Linux IPv4 raw sockets"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:18
msgid "B<raw_socket = socket(AF_INET, SOCK_RAW, int >I<protocol>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:22
msgid ""
"Raw sockets allow new IPv4 protocols to be implemented in user space.  A raw "
"socket receives or sends the raw datagram not including link level headers."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:28
msgid ""
"The IPv4 layer generates an IP header when sending a packet unless the "
"B<IP_HDRINCL> socket option is enabled on the socket.  When it is enabled, "
"the packet must contain an IP header.  For receiving the IP header is always "
"included in the packet."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:32
msgid ""
"Only processes with an effective user ID of 0 or the B<CAP_NET_RAW> "
"capability are allowed to open raw sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:39
msgid ""
"All packets or errors matching the I<protocol> number specified for the raw "
"socket are passed to this socket.  For a list of the allowed protocols see "
"RFC\\ 1700 assigned numbers and B<getprotobyname>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:49
msgid ""
"A protocol of B<IPPROTO_RAW> implies enabled B<IP_HDRINCL> and is able to "
"send any IP protocol that is specified in the passed header.  Receiving of "
"all IP protocols via B<IPPROTO_RAW> is not possible using raw sockets."
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:54
#, no-wrap
msgid "IP Header fields modified on sending by B<IP_HDRINCL>\n"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:55
#, no-wrap
msgid "IP Checksum:Always filled in.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:56
#, no-wrap
msgid "Source Address:Filled in when zero.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:57
#, no-wrap
msgid "Packet Id:Filled in when zero.\n"
msgstr ""

#. type: tbl table
#: build/C/man7/raw.7:58
#, no-wrap
msgid "Total Length:Always filled in.\n"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:72
msgid ""
"If B<IP_HDRINCL> is specified and the IP header has a nonzero destination "
"address then the destination address of the socket is used to route the "
"packet.  When B<MSG_DONTROUTE> is specified, the destination address should "
"refer to a local interface, otherwise a routing table lookup is done anyway "
"but gatewayed routes are ignored."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:80
msgid ""
"If B<IP_HDRINCL> isn't set, then IP header options can be set on raw sockets "
"with B<setsockopt>(2); see B<ip>(7)  for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:85
msgid ""
"In Linux 2.2, all IP header fields and options can be set using IP socket "
"options.  This means raw sockets are usually only needed for new protocols "
"or protocols with no user interface (like ICMP)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:89
msgid ""
"When a packet is received, it is passed to any raw sockets which have been "
"bound to its protocol before it is passed to other protocol handlers (e.g., "
"kernel protocol modules)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:105
msgid ""
"Raw sockets use the standard I<sockaddr_in> address structure defined in "
"B<ip>(7).  The I<sin_port> field could be used to specify the IP protocol "
"number, but it is ignored for sending in Linux 2.2 and should be always set "
"to 0 (see BUGS).  For incoming packets, I<sin_port> is set to the protocol "
"of the packet.  See the I<E<lt>netinet/in.hE<gt>> include file for valid IP "
"protocols."
msgstr ""

#.  Or SOL_RAW on Linux
#. type: Plain text
#: build/C/man7/raw.7:114
msgid ""
"Raw socket options can be set with B<setsockopt>(2)  and read with "
"B<getsockopt>(2)  by passing the B<IPPROTO_RAW> family flag."
msgstr ""

#. type: TP
#: build/C/man7/raw.7:114
#, no-wrap
msgid "B<ICMP_FILTER>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:122
msgid ""
"Enable a special filter for raw sockets bound to the B<IPPROTO_ICMP> "
"protocol.  The value has a bit set for each ICMP message type which should "
"be filtered out.  The default is to filter no ICMP messages."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:127
msgid ""
"In addition, all B<ip>(7)  B<IPPROTO_IP> socket options valid for datagram "
"sockets are supported."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:140
msgid ""
"Errors originating from the network are only passed to the user when the "
"socket is connected or the B<IP_RECVERR> flag is enabled.  For connected "
"sockets, only B<EMSGSIZE> and B<EPROTO> are passed for compatibility.  With "
"B<IP_RECVERR>, all network errors are saved in the error queue."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:145
msgid ""
"User tried to send to a broadcast address without having the broadcast flag "
"set on the socket."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:148
msgid "An invalid memory address was supplied."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:158
msgid ""
"Packet too big.  Either Path MTU Discovery is enabled (the "
"B<IP_MTU_DISCOVER> socket flag) or the packet size exceeds the maximum "
"allowed IPv4 packet size of 64KB."
msgstr ""

#. type: TP
#: build/C/man7/raw.7:158 build/C/man7/unix.7:360
#, no-wrap
msgid "B<EOPNOTSUPP>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:162
msgid "Invalid flag has been passed to a socket call (like B<MSG_OOB>)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:168
msgid ""
"The user doesn't have permission to open raw sockets.  Only processes with "
"an effective user ID of 0 or the B<CAP_NET_RAW> attribute may do that."
msgstr ""

#. type: TP
#: build/C/man7/raw.7:168
#, no-wrap
msgid "B<EPROTO>"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:171
msgid "An ICMP error has arrived reporting a parameter problem."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:177
msgid ""
"B<IP_RECVERR> and B<ICMP_FILTER> are new in Linux 2.2.  They are Linux "
"extensions and should not be used in portable programs."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:183
msgid ""
"Linux 2.0 enabled some bug-to-bug compatibility with BSD in the raw socket "
"code when the B<SO_BSDCOMPAT> socket option was set \\(em since Linux 2.2, "
"this option no longer has that effect."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:201
msgid ""
"By default, raw sockets do path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a raw packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file, see B<ip>(7)  for "
"details.  When turned off, raw sockets will fragment outgoing packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:210
msgid ""
"A raw socket can be bound to a specific local address using the B<bind>(2)  "
"call.  If it isn't bound, all packets with the specified IP protocol are "
"received.  In addition, a RAW socket can be bound to a specific network "
"device using B<SO_BINDTODEVICE>; see B<socket>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:221
msgid ""
"An B<IPPROTO_RAW> socket is send only.  If you really want to receive all IP "
"packets, use a B<packet>(7)  socket with the B<ETH_P_IP> protocol.  Note "
"that packet sockets don't reassemble IP fragments, unlike raw sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:227
msgid ""
"If you want to receive all ICMP packets for a datagram socket, it is often "
"better to use B<IP_RECVERR> on that particular socket; see B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:234
msgid ""
"Raw sockets may tap all IP protocols in Linux, even protocols like ICMP or "
"TCP which have a protocol module in the kernel.  In this case, the packets "
"are passed to both the kernel module and the raw socket(s).  This should not "
"be relied upon in portable programs, many other BSD socket implementation "
"have limitations here."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:239
msgid ""
"Linux never changes headers passed from the user (except for filling in some "
"zeroed fields as described for B<IP_HDRINCL>).  This differs from many other "
"implementations of raw sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:242
msgid ""
"RAW sockets are generally rather unportable and should be avoided in "
"programs intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:248
msgid ""
"Sending on raw sockets should take the IP protocol from I<sin_port>; this "
"ability was lost in Linux 2.2.  The workaround is to use B<IP_HDRINCL>."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:250
msgid "Transparent proxy extensions are not described."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:255
msgid ""
"When the B<IP_HDRINCL> option is set, datagrams will not be fragmented and "
"are limited to the interface MTU."
msgstr ""

#.  .SH AUTHORS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/raw.7:265
msgid ""
"Setting the IP protocol for sending in I<sin_port> got lost in Linux 2.2.  "
"The protocol that the socket was bound to or that was specified in the "
"initial B<socket>(2)  call is always used."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:271
msgid "B<recvmsg>(2), B<sendmsg>(2), B<capabilities>(7), B<ip>(7), B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:274
msgid "B<RFC\\ 1191> for path MTU discovery."
msgstr ""

#. type: Plain text
#: build/C/man7/raw.7:279
msgid ""
"B<RFC\\ 791> and the I<E<lt>linux/ip.hE<gt>> include file for the IP "
"protocol."
msgstr ""

#. type: TH
#: build/C/man3/rcmd.3:41
#, no-wrap
msgid "RCMD"
msgstr ""

#. type: TH
#: build/C/man3/rcmd.3:41 build/C/man3/resolver.3:30 build/C/man3/rexec.3:39 build/C/man7/tcp.7:16
#, no-wrap
msgid "2012-04-23"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:46
msgid ""
"rcmd, rresvport, iruserok, ruserok, rcmd_af, rresvport_af, iruserok_af, "
"ruserok_af - routines for returning a stream to a remote command"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:49
#, no-wrap
msgid ""
"B<#include E<lt>netdb.hE<gt> \\ \\ >/* Or E<lt>unistd.hE<gt> on some systems "
"*/\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:52
#, no-wrap
msgid ""
"B<int rcmd(char **>I<ahost>B<, int >I<inport>B<, const char *>I<locuser>B<, "
">\n"
"B<         const char *>I<remuser>B<, const char *>I<cmd>B<, int "
"*>I<fd2p>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:54
#, no-wrap
msgid "B<int rresvport(int *>I<port>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:57
#, no-wrap
msgid ""
"B<int iruserok(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<             const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:60
#, no-wrap
msgid ""
"B<int ruserok(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<            const char *>I<ruser>B<, const char *>I<luser>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:64
#, no-wrap
msgid ""
"B<int rcmd_af(char **>I<ahost>B<, int >I<inport>B<, const char "
"*>I<locuser>B<, >\n"
"B<            const char *>I<remuser>B<, const char *>I<cmd>B<, int "
"*>I<fd2p>B<,>\n"
"B<            sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:66
#, no-wrap
msgid "B<int rresvport_af(int *>I<port>B<, sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:70
#, no-wrap
msgid ""
"B<int iruserok_af(uint32_t >I<raddr>B<, int >I<superuser>B<, >\n"
"B<                const char *>I<ruser>B<, const char *>I<luser>B<, "
"sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:74
#, no-wrap
msgid ""
"B<int ruserok_af(const char *>I<rhost>B<, int >I<superuser>B<, >\n"
"B<               const char *>I<ruser>B<, const char *>I<luser>B<, "
"sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:90
msgid ""
"B<rcmd>(), B<rcmd_af>(), B<rresvport>(), B<rresvport_af>(), B<iruserok>(), "
"B<iruserok_af>(), B<ruserok>(), B<ruserok_af>(): _BSD_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:111
msgid ""
"The B<rcmd>()  function is used by the superuser to execute a command on a "
"remote machine using an authentication scheme based on privileged port "
"numbers.  The B<rresvport>()  function returns a descriptor to a socket with "
"an address in the privileged port space.  The B<iruserok>()  and "
"B<ruserok>()  functions are used by servers to authenticate clients "
"requesting service with B<rcmd>().  All four functions are used by the "
"B<rshd>(8)  server (among others)."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:111
#, no-wrap
msgid "rcmd()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:127
msgid ""
"The B<rcmd>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise "
"I<*ahost> is set to the standard name of the host and a connection is "
"established to a server residing at the well-known Internet port I<inport>."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:156
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be set up, and a descriptor for it will be placed in "
"I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  If I<fd2p> is 0, then the I<stderr> (unit 2 of the remote command) "
"will be made the same as the I<stdout> and no provision is made for sending "
"arbitrary signals to the remote process, although you may be able to get its "
"attention by using out-of-band data."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:159
msgid "The protocol is described in detail in B<rshd>(8)."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:159
#, no-wrap
msgid "rresvport()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:181
msgid ""
"The B<rresvport>()  function is used to obtain a socket with a privileged "
"port bound to it.  This socket is suitable for use by B<rcmd>()  and several "
"other functions.  Privileged ports are those in the range 0 to 1023.  Only a "
"privileged process (B<CAP_NET_BIND_SERVICE>)  is allowed to bind to a "
"privileged port.  In the glibc implementation, this function restricts its "
"search to the ports from 512 to 1023.  The I<port> argument is value-result: "
"the value it supplies to the call is used as the starting point for a "
"circular search of the port range; on (successful) return, it contains the "
"port number that was bound to."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:181
#, no-wrap
msgid "iruserok() and ruserok()"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:199
msgid ""
"The B<iruserok>()  and B<ruserok>()  functions take a remote host's IP "
"address or name, respectively, two usernames and a flag indicating whether "
"the local user's name is that of the superuser.  Then, if the user is I<not> "
"the superuser, it checks the I</etc/hosts.equiv> file.  If that lookup is "
"not done, or is unsuccessful, the I<.rhosts> in the local user's home "
"directory is checked to see if the request for service is allowed."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:215
msgid ""
"If this file does not exist, is not a regular file, is owned by anyone other "
"than the user or the superuser, or is writable by anyone other than the "
"owner, the check automatically fails.  Zero is returned if the machine name "
"is listed in the I<hosts.equiv> file, or the host and remote username are "
"found in the I<.rhosts> file; otherwise B<iruserok>()  and B<ruserok>()  "
"return -1.  If the local domain (as obtained from B<gethostname>(2))  is the "
"same as the remote domain, only the machine name need be specified."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:221
msgid ""
"If the IP address of the remote host is known, B<iruserok>()  should be used "
"in preference to B<ruserok>(), as it does not require trusting the DNS "
"server for the remote host's domain."
msgstr ""

#. type: SS
#: build/C/man3/rcmd.3:221
#, no-wrap
msgid "*_af() variants"
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:237
msgid ""
"All of the functions described above work with IPv4 (B<AF_INET>)  sockets.  "
"The \"_af\" variants take an extra argument that allows the socket address "
"family to be specified.  For these functions, the I<af> argument can be "
"specified as B<AF_INET> or B<AF_INET6>.  In addition, B<rcmd_af>()  supports "
"the use of B<AF_UNSPEC>."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:243
msgid ""
"The B<rcmd>()  function returns a valid socket descriptor on success.  It "
"returns -1 on error and prints a diagnostic message on the standard error."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:254
msgid ""
"The B<rresvport>()  function returns a valid, bound socket descriptor on "
"success.  It returns -1 on error with the global value I<errno> set "
"according to the reason for failure.  The error code B<EAGAIN> is overloaded "
"to mean \"All network ports in use.\""
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:260
msgid ""
"For information on the return from B<ruserok>()  and B<iruserok>(), see "
"above."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:268
msgid ""
"The functions B<iruserok_af>(), B<rcmd_af>(), B<rresvport_af>(), and "
"B<ruserok_af>()  functions are provide in glibc since version 2.2."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:276
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs, Solaris, and many other systems.  "
"These functions appeared in 4.2BSD.  The \"_af\" variants are more recent "
"additions, and are not present on as wide a range of systems."
msgstr ""

#.  Bug filed 25 Nov 2007:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=5399
#. type: Plain text
#: build/C/man3/rcmd.3:283
msgid ""
"B<iruserok>()  and B<iruserok_af>()  are declared in glibc headers only "
"since version 2.12."
msgstr ""

#. type: Plain text
#: build/C/man3/rcmd.3:291
msgid ""
"B<rlogin>(1), B<rsh>(1), B<intro>(2), B<rexec>(3), B<rexecd>(8), "
"B<rlogind>(8), B<rshd>(8)"
msgstr ""

#. type: TH
#: build/C/man5/resolv.conf.5:21
#, no-wrap
msgid "RESOLV.CONF"
msgstr ""

#. type: TH
#: build/C/man5/resolv.conf.5:21
#, no-wrap
msgid "2012-05-04"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:25
msgid "resolv.conf - resolver configuration file"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:27
msgid "B</etc/resolv.conf>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:36
msgid ""
"The I<resolver> is a set of routines in the C library that provide access to "
"the Internet Domain Name System (DNS).  The resolver configuration file "
"contains information that is read by the resolver routines the first time "
"they are invoked by a process.  The file is designed to be human readable "
"and contains a list of keywords with values that provide various types of "
"resolver information."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:41
msgid ""
"If this file does not exist, only the name server on the local machine will "
"be queried; the domain name is determined from the hostname and the domain "
"search path is constructed from the domain name."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:43
msgid "The different configuration options are:"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:43
#, no-wrap
msgid "B<nameserver> Name server IP address"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:59
msgid ""
"Internet address (in dot notation) of a name server that the resolver should "
"query.  Up to B<MAXNS> (currently 3, see I<E<lt>resolv.hE<gt>>) name servers "
"may be listed, one per keyword.  If there are multiple servers, the resolver "
"library queries them in the order listed.  If no B<nameserver> entries are "
"present, the default is to use the name server on the local machine.  (The "
"algorithm used is to try a name server, and if the query times out, try the "
"next, until out of name servers, then repeat trying all the name servers "
"until a maximum number of retries are made.)"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:59
#, no-wrap
msgid "B<domain> Local domain name."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:69
msgid ""
"Most queries for names within this domain can use short names relative to "
"the local domain.  If no B<domain> entry is present, the domain is "
"determined from the local hostname returned by B<gethostname>(2); the domain "
"part is taken to be everything after the first \\(aq.\\(aq.  Finally, if the "
"hostname does not contain a domain part, the root domain is assumed."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:69
#, no-wrap
msgid "B<search> Search list for host-name lookup."
msgstr ""

#.  When having a resolv.conv with a line
#.   search subdomain.domain.tld domain.tld
#.  and doing a hostlookup, for example by
#.   ping host.anothersubdomain
#.  it sends dns-requests for
#.   host.anothersubdomain.
#.   host.anothersubdomain.subdomain.domain.tld.
#.   host.anothersubdomain.domain.tld.
#.  thus not only causing unnecessary traffic for the root-dns-servers
#.  but broadcasting information to the outside and making man-in-the-middle
#.  attacks possible.
#. type: Plain text
#: build/C/man5/resolv.conf.5:99
msgid ""
"The search list is normally determined from the local domain name; by "
"default, it contains only the local domain name.  This may be changed by "
"listing the desired domain search path following the I<search> keyword with "
"spaces or tabs separating the names.  Resolver queries having fewer than "
"I<ndots> dots (default is 1) in them will be attempted using each component "
"of the search path in turn until a match is found.  For environments with "
"multiple subdomains please read B<options ndots:>I<n> below to avoid "
"man-in-the-middle attacks and unnecessary traffic for the root-dns-servers.  "
"Note that this process may be slow and will generate a lot of network "
"traffic if the servers for the listed domains are not local, and that "
"queries will time out if no server is available for one of the domains."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:102
msgid ""
"The search list is currently limited to six domains with a total of 256 "
"characters."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:102
#, no-wrap
msgid "B<sortlist>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:115
msgid ""
"This option allows addresses returned by B<gethostbyname>(3)  to be sorted.  "
"A sortlist is specified by IP-address-netmask pairs.  The netmask is "
"optional and defaults to the natural netmask of the net.  The IP address and "
"optional network pairs are separated by slashes.  Up to 10 pairs may be "
"specified.  Here is an example:"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:118
msgid "sortlist 130.155.160.0/255.255.240.0 130.155.0.0"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:120
#, no-wrap
msgid "B<options>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:124
msgid ""
"Options allows certain internal resolver variables to be modified.  The "
"syntax is"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:127
msgid "B<options> I<option> I<...>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:129
msgid "where I<option> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:129
#, no-wrap
msgid "B<debug>"
msgstr ""

#.  Since glibc 2.2?
#. type: Plain text
#: build/C/man5/resolv.conf.5:136
msgid "sets B<RES_DEBUG> in I<_res.options>."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:136
#, no-wrap
msgid "B<ndots:>I<n>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:150
msgid ""
"sets a threshold for the number of dots which must appear in a name given to "
"B<res_query>(3)  (see B<resolver>(3))  before an I<initial absolute query> "
"will be made.  The default for I<n> is 1, meaning that if there are any dots "
"in a name, the name will be tried first as an absolute name before any "
"I<search list> elements are appended to it.  The value for this option is "
"silently capped to 15."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:150
#, no-wrap
msgid "B<timeout:>I<n>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:161
msgid ""
"sets the amount of time the resolver will wait for a response from a remote "
"name server before retrying the query via a different name server.  Measured "
"in seconds, the default is B<RES_TIMEOUT> (currently 5, see "
"I<E<lt>resolv.hE<gt>>).  The value for this option is silently capped to 30."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:161
#, no-wrap
msgid "B<attempts:>I<n>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:170
msgid ""
"sets the number of times the resolver will send a query to its name servers "
"before giving up and returning an error to the calling application.  The "
"default is B<RES_DFLRETRY> (currently 2, see I<E<lt>resolv.hE<gt>>).  The "
"value for this option is silently capped to 5."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:170
#, no-wrap
msgid "B<rotate>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:180
msgid ""
"sets B<RES_ROTATE> in I<_res.options>, which causes round robin selection of "
"nameservers from among those listed.  This has the effect of spreading the "
"query load among all listed servers, rather than having all clients try the "
"first listed server first every time."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:180
#, no-wrap
msgid "B<no-check-names>"
msgstr ""

#.  since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:190
msgid ""
"sets B<RES_NOCHECKNAME> in I<_res.options>, which disables the modern BIND "
"checking of incoming hostnames and mail names for invalid characters such as "
"underscore (_), non-ASCII, or control characters."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:190
#, no-wrap
msgid "B<inet6>"
msgstr ""

#.  Since glibc 2.2
#. type: Plain text
#: build/C/man5/resolv.conf.5:201
msgid ""
"sets B<RES_USE_INET6> in I<_res.options>.  This has the effect of trying a "
"AAAA query before an A query inside the B<gethostbyname>(3)  function, and "
"of mapping IPv4 responses in IPv6 \"tunneled form\" if no AAAA records are "
"found but an A record set exists."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:201
#, no-wrap
msgid "B<ip6-bytestring> (since glibc 2.3.4)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:210
msgid ""
"sets B<RES_USE_BSTRING> in I<_res.options>.  This causes reverse IPv6 "
"lookups to be made using the bit-label format described in RFC\\ 2673; if "
"this option is not set, then nibble format is used."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:210
#, no-wrap
msgid "B<ip6-dotint>/B<no-ip6-dotint> (since glibc 2.3.4)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:227
msgid ""
"Clear/set B<RES_NOIP6DOTINT> in I<_res.options>.  When this option is clear "
"(B<ip6-dotint>), reverse IPv6 lookups are made in the (deprecated)  "
"I<ip6.int> zone; when this option is set (B<no-ip6-dotint>), reverse IPv6 "
"lookups are made in the I<ip6.arpa> zone by default.  This option is set by "
"default."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:227
#, no-wrap
msgid "B<edns0> (since glibc 2.6)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:234
msgid ""
"sets B<RES_USE_EDNSO> in I<_res.options>.  This enables support for the DNS "
"extensions described in RFC\\ 2671."
msgstr ""

#. type: TP
#: build/C/man5/resolv.conf.5:234
#, no-wrap
msgid "B<single-request> (since glibc 2.10)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:247
msgid ""
"sets B<RES_SNGLKUP> in I<_res.options>.  By default, glibc performs IPv4 and "
"IPv6 lookups in parallel since version 2.9.  Some appliance DNS servers "
"cannot handle these queries properly and make the requests time out.  This "
"option disables the behavior and makes glibc perform the IPv6 and IPv4 "
"requests sequentially (at the cost of some slowdown of the resolving "
"process)."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:252
msgid ""
"The I<domain> and I<search> keywords are mutually exclusive.  If more than "
"one instance of these keywords is present, the last instance wins."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:257
msgid ""
"The I<search> keyword of a system's I<resolv.conf> file can be overridden on "
"a per-process basis by setting the environment variable B<LOCALDOMAIN> to a "
"space-separated list of search domains."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:263
msgid ""
"The I<options> keyword of a system's I<resolv.conf> file can be amended on a "
"per-process basis by setting the environment variable B<RES_OPTIONS> to a "
"space-separated list of resolver options as explained above under "
"B<options>."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:267
msgid ""
"The keyword and value must appear on a single line, and the keyword (e.g., "
"B<nameserver>) must start the line.  The value follows the keyword, "
"separated by white space."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:270
msgid ""
"Lines that contain a semicolon (;) or hash character (#)  in the first "
"column are treated as comments."
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:273
msgid "I</etc/resolv.conf>, I<E<lt>resolv.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:278
msgid "B<gethostbyname>(3), B<resolver>(3), B<hostname>(7), B<named>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/resolv.conf.5:280
msgid "Name Server Operations Guide for BIND"
msgstr ""

#. type: TH
#: build/C/man3/resolver.3:30
#, no-wrap
msgid "RESOLVER"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:34
msgid ""
"res_init, res_query, res_search, res_querydomain, res_mkquery, res_send, "
"dn_comp, dn_expand - resolver routines"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:40
#, no-wrap
msgid ""
"B<#include E<lt>netinet/in.hE<gt>>\n"
"B<#include E<lt>arpa/nameser.hE<gt>>\n"
"B<#include E<lt>resolv.hE<gt>>\n"
"B<extern struct state _res;>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:42
#, no-wrap
msgid "B<int res_init(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:44
#, no-wrap
msgid "B<int res_query(const char *>I<dname>B<, int >I<class>B<, int >I<type>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:46 build/C/man3/resolver.3:51
#, no-wrap
msgid "B<unsigned char *>I<answer>B<, int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:49
#, no-wrap
msgid ""
"B<int res_search(const char *>I<dname>B<, int >I<class>B<, int "
">I<type>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:54
#, no-wrap
msgid "B<int res_querydomain(const char *>I<name>B<, const char *>I<domain>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:57
#, no-wrap
msgid ""
"B<int >I<class>B<, int >I<type>B<, unsigned char *>I<answer>B<,>\n"
"B<int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:60
#, no-wrap
msgid "B<int res_mkquery(int >I<op>B<, const char *>I<dname>B<, int >I<class>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:63
#, no-wrap
msgid ""
"B<int >I<type>B<, char *>I<data>B<, int >I<datalen>B<, struct rrec "
"*>I<newrr>B<,>\n"
"B<char *>I<buf>B<, int >I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:66
#, no-wrap
msgid ""
"B<int res_send(const char *>I<msg>B<, int >I<msglen>B<, char "
"*>I<answer>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:68
#, no-wrap
msgid "B<int >I<anslen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:71
#, no-wrap
msgid "B<int dn_comp(unsigned char *>I<exp_dn>B<, unsigned char *>I<comp_dn>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:73
#, no-wrap
msgid ""
"B<int >I<length>B<, unsigned char **>I<dnptrs>B<, unsigned char "
"**>I<lastdnptr>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:76
#, no-wrap
msgid "B<int dn_expand(unsigned char *>I<msg>B<, unsigned char *>I<eomorig>B<,>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:79
#, no-wrap
msgid ""
"B<unsigned char *>I<comp_dn>B<, char *>I<exp_dn>B<,>\n"
"B<int >I<length>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:83
msgid "Link with I<-lresolv>."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:86
msgid ""
"These functions make queries to and interpret the responses from Internet "
"domain name servers."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:99
msgid ""
"The B<res_init>()  function reads the configuration files (see "
"resolv.conf(5)) to get the default domain name, search order and name server "
"address(es).  If no server is given, the local host is tried.  If no domain "
"is given, that associated with the local host is used.  It can be overridden "
"with the environment variable B<LOCALDOMAIN>.  B<res_init>()  is normally "
"executed by the first call to one of the other functions."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:107
msgid ""
"The B<res_query>()  function queries the name server for the fully qualified "
"domain name I<name> of specified I<type> and I<class>.  The reply is left in "
"the buffer I<answer> of length I<anslen> supplied by the caller."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:120
msgid ""
"The B<res_search>()  function makes a query and waits for the response like "
"B<res_query>(), but in addition implements the default and search rules "
"controlled by B<RES_DEFNAMES> and B<RES_DNSRCH> (see description of I<_res> "
"options below)."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:126
msgid ""
"The B<res_querydomain>()  function makes a query using B<res_query>()  on "
"the concatenation of I<name> and I<domain>."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:129
msgid "The following functions are lower-level routines used by B<res_query>()."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:140
msgid ""
"The B<res_mkquery>()  function constructs a query message in I<buf> of "
"length I<buflen> for the domain name I<dname>.  The query type I<op> is "
"usually B<QUERY>, but can be any of the types defined in "
"I<E<lt>arpa/nameser.hE<gt>>.  I<newrr> is currently unused."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:150
msgid ""
"The B<res_send>()  function sends a preformatted query given in I<msg> of "
"length I<msglen> and returns the answer in I<answer> which is of length "
"I<anslen>.  It will call B<res_init>(), if it has not already been called."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:163
msgid ""
"The B<dn_comp>()  function compresses the domain name I<exp_dn> and stores "
"it in the buffer I<comp_dn> of length I<length>.  The compression uses an "
"array of pointers I<dnptrs> to previously compressed names in the current "
"message.  The first pointer points to the beginning of the message and the "
"list ends with NULL.  The limit of the array is specified by I<lastdnptr>.  "
"If I<dnptr> is NULL, domain names are not compressed.  If I<lastdnptr> is "
"NULL, the list of labels is not updated."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:172
msgid ""
"The B<dn_expand>()  function expands the compressed domain name I<comp_dn> "
"to a full domain name, which is placed in the buffer I<exp_dn> of size "
"I<length>.  The compressed name is contained in a query or reply message, "
"and I<msg> points to the beginning of the message."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:180
msgid ""
"The resolver routines use global configuration and state information "
"contained in the structure I<_res>, which is defined in "
"I<E<lt>resolv.hE<gt>>.  The only field that is normally manipulated by the "
"user is I<_res.options>.  This field can contain the bitwise \"OR\" of the "
"following options:"
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:180
#, no-wrap
msgid "B<RES_INIT>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:185
msgid "True if B<res_init>()  has been called."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:185
#, no-wrap
msgid "B<RES_DEBUG>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:188
msgid "Print debugging messages."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:188
#, no-wrap
msgid "B<RES_AAONLY>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:195
msgid ""
"Accept authoritative answers only.  B<res_send>()  continues until it finds "
"an authoritative answer or returns an error.  [Not currently implemented]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:195
#, no-wrap
msgid "B<RES_USEVC>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:198
msgid "Use TCP connections for queries rather than UDP datagrams."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:198
#, no-wrap
msgid "B<RES_PRIMARY>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:201
msgid "Query primary domain name server only."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:201
#, no-wrap
msgid "B<RES_IGNTC>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:206
msgid ""
"Ignore truncation errors.  Don't retry with TCP.  [Not currently "
"implemented]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:206
#, no-wrap
msgid "B<RES_RECURSE>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:213
msgid ""
"Set the recursion desired bit in queries.  Recursion is carried out by the "
"domain name server, not by B<res_send>().  [Enabled by default]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:213
#, no-wrap
msgid "B<RES_DEFNAMES>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:220
msgid ""
"If set, B<res_search>()  will append the default domain name to single "
"component names, i.e., those that do not contain a dot.  [Enabled by "
"default]."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:220
#, no-wrap
msgid "B<RES_STAYOPEN>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:225
msgid "Used with B<RES_USEVC> to keep the TCP connection open between queries."
msgstr ""

#. type: TP
#: build/C/man3/resolver.3:225
#, no-wrap
msgid "B<RES_DNSRCH>"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:234
msgid ""
"If set, B<res_search>()  will search for hostnames in the current domain and "
"in parent domains.  This option is used by B<gethostbyname>(3).  [Enabled by "
"default]."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:238
msgid ""
"This list is not complete.  You can find some other flags described in "
"B<resolv.conf>(5)."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:243
msgid "The B<res_init>()  function returns 0 on success, or -1 if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:253
msgid ""
"The B<res_query>(), B<res_search>(), B<res_querydomain>(), B<res_mkquery>()  "
"and B<res_send>()  functions return the length of the response, or -1 if an "
"error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:260
msgid ""
"The B<dn_comp>()  and B<dn_expand>()  functions return the length of the "
"compressed name, or -1 if an error occurs."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:264
#, no-wrap
msgid ""
"/etc/resolv.conf          resolver configuration file\n"
"/etc/host.conf            resolver configuration file\n"
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:267
msgid "4.3BSD."
msgstr ""

#. type: Plain text
#: build/C/man3/resolver.3:273
msgid ""
"B<gethostbyname>(3), B<resolv.conf>(5), B<resolver>(5), B<hostname>(7), "
"B<named>(8)"
msgstr ""

#. type: TH
#: build/C/man3/rexec.3:39
#, no-wrap
msgid "REXEC"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:42
msgid "rexec, rexec_af - return stream to a remote command"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:46
#, no-wrap
msgid ""
"B<#define _BSD_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>netdb.hE<gt>>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:49
#, no-wrap
msgid ""
"B<int rexec(char **>I<ahost>B<, int >I<inport>B<, char *>I<user>B<, >\n"
"B<          char *>I<passwd>B<, char *>I<cmd>B<, int *>I<fd2p>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:53
#, no-wrap
msgid ""
"B<int rexec_af(char **>I<ahost>B<, int >I<inport>B<, char *>I<user>B<, >\n"
"B<             char *>I<passwd>B<, char *>I<cmd>B<, int *>I<fd2p>B<,>\n"
"B<             sa_family_t >I<af>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:57
msgid "This interface is obsoleted by B<rcmd>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:76
msgid ""
"The B<rexec>()  function looks up the host I<*ahost> using "
"B<gethostbyname>(3), returning -1 if the host does not exist.  Otherwise "
"I<*ahost> is set to the standard name of the host.  If a username and "
"password are both specified, then these are used to authenticate to the "
"foreign host; otherwise the environment and then the user's I<.netrc> file "
"in his home directory are searched for appropriate information.  If all this "
"fails, the user is prompted for the information."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:87
msgid ""
"The port I<inport> specifies which well-known DARPA Internet port to use for "
"the connection; the call I<getservbyname(\"exec\", \"tcp\")> (see "
"B<getservent>(3))  will return a pointer to a structure that contains the "
"necessary port.  The protocol for connection is described in detail in "
"B<rexecd>(8)."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:120
msgid ""
"If the connection succeeds, a socket in the Internet domain of type "
"B<SOCK_STREAM> is returned to the caller, and given to the remote command as "
"I<stdin> and I<stdout>.  If I<fd2p> is nonzero, then an auxiliary channel to "
"a control process will be setup, and a descriptor for it will be placed in "
"I<*fd2p>.  The control process will return diagnostic output from the "
"command (unit 2) on this channel, and will also accept bytes on this channel "
"as being UNIX signal numbers, to be forwarded to the process group of the "
"command.  The diagnostic information returned does not include remote "
"authorization failure, as the secondary connection is set up after "
"authorization has been verified.  If I<fd2p> is 0, then the I<stderr> (unit "
"2 of the remote command) will be made the same as the I<stdout> and no "
"provision is made for sending arbitrary signals to the remote process, "
"although you may be able to get its attention by using out-of-band data."
msgstr ""

#. type: SS
#: build/C/man3/rexec.3:120
#, no-wrap
msgid "rexec_af()"
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:136
msgid ""
"The B<rexec>()  function works over IPv4 (B<AF_INET>).  By contrast, the "
"B<rexec_af>()  function provides an extra argument, I<af>, that allows the "
"caller to select the protocol.  This argument can be specified as "
"B<AF_INET>, B<AF_INET6>, or B<AF_UNSPEC> (to allow the implementation to "
"select the protocol)."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:140
msgid "The B<rexec_af>()  function was added to glibc in version 2.2."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:149
msgid ""
"These functions are not in POSIX.1-2001.  The B<rexec>()  function first "
"appeared in 4.2BSD, and is present on the BSDs, Solaris, and many other "
"systems.  The B<rexec_af>()  function is more recent, and less widespread."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:153
msgid "The B<rexec>()  function sends the unencrypted password across the network."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:158
msgid ""
"The underlying service is considered a big security hole and therefore not "
"enabled on many sites; see B<rexecd>(8)  for explanations."
msgstr ""

#. type: Plain text
#: build/C/man3/rexec.3:161
msgid "B<rcmd>(3), B<rexecd>(8)"
msgstr ""

#. type: TH
#: build/C/man5/services.5:34
#, no-wrap
msgid "SERVICES"
msgstr ""

#. type: TH
#: build/C/man5/services.5:34
#, no-wrap
msgid "2010-05-22"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:37
msgid "services - Internet network services list"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:52
msgid ""
"B<services> is a plain ASCII file providing a mapping between human-friendly "
"textual names for internet services, and their underlying assigned port "
"numbers and protocol types.  Every networking program should look into this "
"file to get the port number (and protocol) for its service.  The C library "
"routines B<getservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<setservent>(3), and B<endservent>(3)  support querying this file from "
"programs."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:58
msgid ""
"Port numbers are assigned by the IANA (Internet Assigned Numbers Authority), "
"and their current policy is to assign both TCP and UDP protocols when "
"assigning a port number.  Therefore, most entries will have two entries, "
"even for TCP-only services."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:70
msgid ""
"Port numbers below 1024 (so-called \"low numbered\" ports) can only be bound "
"to by root (see B<bind>(2), B<tcp>(7), and B<udp>(7)).  This is so clients "
"connecting to low numbered ports can trust that the service running on the "
"port is the standard implementation, and not a rogue service run by a user "
"of the machine.  Well-known port numbers specified by the IANA are normally "
"located in this root-only space."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:85
msgid ""
"The presence of an entry for a service in the B<services> file does not "
"necessarily mean that the service is currently running on the machine.  See "
"B<inetd.conf>(5)  for the configuration of Internet services offered.  Note "
"that not all networking services are started by B<inetd>(8), and so won't "
"appear in B<inetd.conf>(5).  In particular, news (NNTP) and mail (SMTP) "
"servers are often initialized from the system boot scripts."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:94
msgid ""
"The location of the B<services> file is defined by B<_PATH_SERVICES> in "
"I<E<lt>netdb.hE<gt>>.  This is usually set to I</etc/services>."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:96
msgid "Each line describes one service, and is of the form:"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:98
msgid "I<service-name\\ \\ \\ port>B</>I<protocol\\ \\ \\ >[I<aliases ...>]"
msgstr ""

#. type: TP
#: build/C/man5/services.5:98
#, no-wrap
msgid "where:"
msgstr ""

#. type: TP
#: build/C/man5/services.5:100
#, no-wrap
msgid "I<service-name>"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:106
msgid ""
"is the friendly name the service is known by and looked up under.  It is "
"case sensitive.  Often, the client program is named after the "
"I<service-name>."
msgstr ""

#. type: TP
#: build/C/man5/services.5:106
#, no-wrap
msgid "I<port>"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:109
msgid "is the port number (in decimal) to use for this service."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:120
msgid ""
"is the type of protocol to be used.  This field should match an entry in the "
"B<protocols>(5)  file.  Typical values include B<tcp> and B<udp>."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:126
msgid ""
"is an optional space or tab separated list of other names for this service.  "
"Again, the names are case sensitive."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:128
msgid "Either spaces or tabs may be used to separate the fields."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:132
msgid ""
"Comments are started by the hash sign (#) and continue until the end of the "
"line.  Blank lines are skipped."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:143
msgid ""
"The I<service-name> should begin in the first column of the file, since "
"leading spaces are not stripped.  I<service-names> can be any printable "
"characters excluding space and tab.  However, a conservative choice of "
"characters should be used to minimize compatibility problems.  E.g., a-z, "
"0-9, and hyphen (-) would seem a sensible choice."
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:152
msgid ""
"Lines not matching this format should not be present in the file.  "
"(Currently, they are silently skipped by B<getservent>(3), "
"B<getservbyname>(3), and B<getservbyport>(3).  However, this behavior should "
"not be relied on.)"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:169
msgid "A sample B<services> file might look like this:"
msgstr ""

#. type: ta
#: build/C/man5/services.5:172
#, no-wrap
msgid "3i"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:182
#, no-wrap
msgid ""
"netstat         15/tcp\n"
"qotd            17/tcp          quote\n"
"msp             18/tcp          # message send protocol\n"
"msp             18/udp          # message send protocol\n"
"chargen         19/tcp          ttytst source\n"
"chargen         19/udp          ttytst source\n"
"ftp             21/tcp\n"
"# 22 - unassigned\n"
"telnet          23/tcp\n"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:188
msgid "The Internet network services list"
msgstr ""

#. type: TP
#: build/C/man5/services.5:188
#, no-wrap
msgid "I<E<lt>netdb.hE<gt>>"
msgstr ""

#.  .SH BUGS
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     There is a maximum of 35 aliases, due to the way the
#.     .BR getservent (3)
#.     code is written.
#
#.  It's not clear when/if the following was ever true;
#.  it isn't true for glibc 2.8:
#.     Lines longer than
#.     .B BUFSIZ
#.     (currently 1024) characters will be ignored by
#.     .BR getservent (3),
#.     .BR getservbyname (3),
#.     and
#.     .BR getservbyport (3).
#.     However, this will also cause the next line to be mis-parsed.
#. type: Plain text
#: build/C/man5/services.5:209
msgid "Definition of B<_PATH_SERVICES>"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:219
msgid ""
"B<listen>(2), B<endservent>(3), B<getservbyname>(3), B<getservbyport>(3), "
"B<getservent>(3), B<setservent>(3), B<inetd.conf>(5), B<protocols>(5), "
"B<inetd>(8)"
msgstr ""

#. type: Plain text
#: build/C/man5/services.5:221
msgid "Assigned Numbers RFC, most recently RFC\\ 1700, (AKA STD0002)"
msgstr ""

#. type: TH
#: build/C/man3/setnetgrent.3:5
#, no-wrap
msgid "SETNETGRENT"
msgstr ""

#. type: TH
#: build/C/man3/setnetgrent.3:5
#, no-wrap
msgid "2007-07-26"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:9
msgid ""
"setnetgrent, endnetgrent, getnetgrent, getnetgrent_r, innetgr - handle "
"network group entries"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:14
#, no-wrap
msgid "B<int setnetgrent(const char *>I<netgroup>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:16
#, no-wrap
msgid "B<void endnetgrent(void);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:18
#, no-wrap
msgid ""
"B<int getnetgrent(char **>I<host>B<, char **>I<user>B<, char "
"**>I<domain>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:21
#, no-wrap
msgid ""
"B<int getnetgrent_r(char **>I<host>B<, char **>I<user>B<,>\n"
"B<                  char **>I<domain>B<, char *>I<buf>B<, int "
">I<buflen>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:24
#, no-wrap
msgid ""
"B<int innetgr(const char *>I<netgroup>B<, const char *>I<host>B<,>\n"
"B<            const char *>I<user>B<, const char *>I<domain>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:38
msgid ""
"B<setnetgrent>(), B<endnetgrent>(), B<getnetgrent>(), B<getnetgrent_r>(), "
"B<innetgr>(): _BSD_SOURCE || _SVID_SOURCE"
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:52
msgid ""
"The I<netgroup> is a SunOS invention.  A netgroup database is a list of "
"string triples (I<hostname>, I<username>, I<domainname>)  or other netgroup "
"names.  Any of the elements in a triple can be empty, which means that "
"anything matches.  The functions described here allow access to the netgroup "
"databases.  The file I</etc/nsswitch.conf> defines what database is "
"searched."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:72
msgid ""
"The B<setnetgrent>()  call defines the netgroup that will be searched by "
"subsequent B<getnetgrent>()  calls.  The B<getnetgrent>()  function "
"retrieves the next netgroup entry, and returns pointers in I<host>, I<user>, "
"I<domain>.  A NULL pointer means that the corresponding entry matches any "
"string.  The pointers are valid only as long as there is no call to other "
"netgroup-related functions.  To avoid this problem you can use the GNU "
"function B<getnetgrent_r>()  that stores the strings in the supplied "
"buffer.  To free all allocated buffers use B<endnetgrent>()."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:81
msgid ""
"In most cases you only want to check if the triplet (I<hostname>, "
"I<username>, I<domainname>)  is a member of a netgroup.  The function "
"B<innetgr>()  can be used for this without calling the above three "
"functions.  Again, a NULL pointer is a wildcard and matches any string.  The "
"function is thread-safe."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:83
msgid "These functions return 1 on success and 0 for failure."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:85
msgid "I</etc/netgroup>"
msgstr ""

#.  getnetgrent_r() is on Solaris 8 and AIX 5.1, but not the BSDs.
#. type: Plain text
#: build/C/man3/setnetgrent.3:98
msgid ""
"These functions are not in POSIX.1-2001, but B<setnetgrent>(), "
"B<endnetgrent>(), B<getnetgrent>(), and B<innetgr>()  are available on most "
"UNIX systems.  B<getnetgrent_r>()  is not widely available on other systems."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:102
msgid "In the BSD implementation, B<setnetgrent>()  returns void."
msgstr ""

#. type: Plain text
#: build/C/man3/setnetgrent.3:106
msgid "B<sethostent>(3), B<setprotoent>(3), B<setservent>(3)"
msgstr ""

#. type: TH
#: build/C/man2/shutdown.2:38
#, no-wrap
msgid "SHUTDOWN"
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:41
msgid "shutdown - shut down part of a full-duplex connection"
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:45
msgid "B<int shutdown(int >I<sockfd>B<, int >I<how>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:67
msgid ""
"The B<shutdown>()  call causes all or part of a full-duplex connection on "
"the socket associated with I<sockfd> to be shut down.  If I<how> is "
"B<SHUT_RD>, further receptions will be disallowed.  If I<how> is B<SHUT_WR>, "
"further transmissions will be disallowed.  If I<how> is B<SHUT_RDWR>, "
"further receptions and transmissions will be disallowed."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:77
msgid "I<sockfd> is not a valid descriptor."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:80
msgid "The specified socket is not connected."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:84
msgid "I<sockfd> is a file, not a socket."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:88
msgid ""
"POSIX.1-2001, 4.4BSD (the B<shutdown>()  function call first appeared in "
"4.2BSD)."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:97
msgid ""
"The constants B<SHUT_RD>, B<SHUT_WR>, B<SHUT_RDWR> have the value 0, 1, 2, "
"respectively, and are defined in I<E<lt>sys/socket.hE<gt>> since "
"glibc-2.1.91."
msgstr ""

#. type: Plain text
#: build/C/man2/shutdown.2:101
msgid "B<connect>(2), B<socket>(2), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man7/tcp.7:16
#, no-wrap
msgid "TCP"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:19
msgid "tcp - TCP protocol"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:25
msgid "B<#include E<lt>netinet/tcp.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:27
msgid "B<tcp_socket = socket(AF_INET, SOCK_STREAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:40
msgid ""
"This is an implementation of the TCP protocol defined in RFC\\ 793, RFC\\ "
"1122 and RFC\\ 2001 with the NewReno and SACK extensions.  It provides a "
"reliable, stream-oriented, full-duplex connection between two sockets on top "
"of B<ip>(7), for both v4 and v6 versions.  TCP guarantees that the data "
"arrives in order and retransmits lost packets.  It generates and checks a "
"per-packet checksum to catch transmission errors.  TCP does not preserve "
"record boundaries."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:59
msgid ""
"A newly created TCP socket has no remote or local address and is not fully "
"specified.  To create an outgoing TCP connection use B<connect>(2)  to "
"establish a connection to another TCP socket.  To receive new incoming "
"connections, first B<bind>(2)  the socket to a local address and port and "
"then call B<listen>(2)  to put the socket into the listening state.  After "
"that a new socket for each incoming connection can be accepted using "
"B<accept>(2).  A socket which has had B<accept>(2)  or B<connect>(2)  "
"successfully called on it is fully specified and may transmit data.  Data "
"cannot be transmitted on listening or not yet connected sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:79
msgid ""
"Linux supports RFC\\ 1323 TCP high performance extensions.  These include "
"Protection Against Wrapped Sequence Numbers (PAWS), Window Scaling and "
"Timestamps.  Window scaling allows the use of large (E<gt> 64K) TCP windows "
"in order to support links with high latency or bandwidth.  To make use of "
"them, the send and receive buffer sizes must be increased.  They can be set "
"globally with the I</proc/sys/net/ipv4/tcp_wmem> and "
"I</proc/sys/net/ipv4/tcp_rmem> files, or on individual sockets by using the "
"B<SO_SNDBUF> and B<SO_RCVBUF> socket options with the B<setsockopt>(2)  "
"call."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:110
msgid ""
"The maximum sizes for socket buffers declared via the B<SO_SNDBUF> and "
"B<SO_RCVBUF> mechanisms are limited by the values in the "
"I</proc/sys/net/core/rmem_max> and I</proc/sys/net/core/wmem_max> files.  "
"Note that TCP actually allocates twice the size of the buffer requested in "
"the B<setsockopt>(2)  call, and so a succeeding B<getsockopt>(2)  call will "
"not return the same size of buffer as requested in the B<setsockopt>(2)  "
"call.  TCP uses the extra space for administrative purposes and internal "
"kernel structures, and the I</proc> file values reflect the larger sizes "
"compared to the actual TCP windows.  On individual connections, the socket "
"buffer size must be set prior to the B<listen>(2)  or B<connect>(2)  calls "
"in order to have it take effect.  See B<socket>(7)  for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:142
msgid ""
"TCP supports urgent data.  Urgent data is used to signal the receiver that "
"some important message is part of the data stream and that it should be "
"processed as soon as possible.  To send urgent data specify the B<MSG_OOB> "
"option to B<send>(2).  When urgent data is received, the kernel sends a "
"B<SIGURG> signal to the process or process group that has been set as the "
"socket \"owner\" using the B<SIOCSPGRP> or B<FIOSETOWN> ioctls (or the "
"POSIX.1-2001-specified B<fcntl>(2)  B<F_SETOWN> operation).  When the "
"B<SO_OOBINLINE> socket option is enabled, urgent data is put into the normal "
"data stream (a program can test for its location using the B<SIOCATMARK> "
"ioctl described below), otherwise it can be only received when the "
"B<MSG_OOB> flag is set for B<recv>(2)  or B<recvmsg>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:150
msgid ""
"Linux 2.4 introduced a number of changes for improved throughput and "
"scaling, as well as enhanced functionality.  Some of these features include "
"support for zero-copy B<sendfile>(2), Explicit Congestion Notification, new "
"management of TIME_WAIT sockets, keep-alive socket options and support for "
"Duplicate SACK extensions."
msgstr ""

#. type: SS
#: build/C/man7/tcp.7:150
#, no-wrap
msgid "Address Formats"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:159
msgid ""
"TCP is built on top of IP (see B<ip>(7)).  The address formats defined by "
"B<ip>(7)  apply to TCP.  TCP only supports point-to-point communication; "
"broadcasting and multicasting are not supported."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:171
msgid ""
"System-wide TCP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>.  In addition, most IP I</proc> interfaces also apply "
"to TCP; see B<ip>(7).  Variables described as I<Boolean> take an integer "
"value, with a nonzero value (\"true\") meaning that the corresponding option "
"is enabled, and a zero value (\"false\")  meaning that the option is "
"disabled."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:171
#, no-wrap
msgid "I<tcp_abc> (Integer; default: 0; since Linux 2.6.15)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:179
msgid ""
"Control the Appropriate Byte Count (ABC), defined in RFC 3465.  ABC is a way "
"of increasing the congestion window (I<cwnd>)  more slowly in response to "
"partial acknowledgments.  Possible values are:"
msgstr ""

#. type: IP
#: build/C/man7/tcp.7:180 build/C/man7/tcp.7:349 build/C/man7/tcp.7:370 build/C/man7/tcp.7:514
#, no-wrap
msgid "0"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:184
msgid "increase I<cwnd> once per acknowledgment (no ABC)"
msgstr ""

#. type: IP
#: build/C/man7/tcp.7:184 build/C/man7/tcp.7:351 build/C/man7/tcp.7:377 build/C/man7/tcp.7:516
#, no-wrap
msgid "1"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:188
msgid "increase I<cwnd> once per acknowledgment of full sized segment"
msgstr ""

#. type: IP
#: build/C/man7/tcp.7:188 build/C/man7/tcp.7:353 build/C/man7/tcp.7:384 build/C/man7/tcp.7:518
#, no-wrap
msgid "2"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:193
msgid ""
"allow increase I<cwnd> by two if acknowledgment is of two segments to "
"compensate for delayed acknowledgments."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:194
#, no-wrap
msgid "I<tcp_abort_on_overflow> (Boolean; default: disabled; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:206
msgid ""
"Enable resetting connections if the listening service is too slow and unable "
"to keep up and accept them.  It means that if overflow occurred due to a "
"burst, the connection will recover.  Enable this option I<only> if you are "
"really sure that the listening daemon cannot be tuned to accept connections "
"faster.  Enabling this option can harm the clients of your server."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:206
#, no-wrap
msgid "I<tcp_adv_win_scale> (integer; default: 2; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:218
msgid ""
"Count buffering overhead as I<bytes/2^tcp_adv_win_scale>, if "
"I<tcp_adv_win_scale> is greater than 0; or "
"I<bytes-bytes/2^(-tcp_adv_win_scale)>, if I<tcp_adv_win_scale> is less than "
"or equal to zero."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:231
msgid ""
"The socket receive buffer space is shared between the application and "
"kernel.  TCP maintains part of the buffer as the TCP window, this is the "
"size of the receive window advertised to the other end.  The rest of the "
"space is used as the \"application\" buffer, used to isolate the network "
"from scheduling and application latencies.  The I<tcp_adv_win_scale> default "
"value of 2 implies that the space used for the application buffer is one "
"fourth that of the total."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:231
#, no-wrap
msgid ""
"I<tcp_allowed_congestion_control> (String; default: see text; since Linux "
"2.4.20)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#.  FIXME How are the items in this delimited? Null bytes, spaces, commas?
#. type: Plain text
#: build/C/man7/tcp.7:243
msgid ""
"Show/set the congestion control algorithm choices available to unprivileged "
"processes (see the description of the B<TCP_CONGESTION> socket option).  The "
"list is a subset of those listed in I<tcp_available_congestion_control>.  "
"The default value for this list is \"reno\" plus the default setting of "
"I<tcp_congestion_control>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:243
#, no-wrap
msgid "I<tcp_available_congestion_control> (String; read-only; since Linux 2.4.20)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#.  FIXME How are the items in this delimited? Null bytes, spaces, commas?
#. type: Plain text
#: build/C/man7/tcp.7:253
msgid ""
"Show a list of the congestion-control algorithms that are registered.  This "
"list is a limiting set for the list in I<tcp_allowed_congestion_control>.  "
"More congestion-control algorithms may be available as modules, but not "
"loaded."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:253
#, no-wrap
msgid "I<tcp_app_win> (integer; default: 31; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:258
msgid ""
"This variable defines how many bytes of the TCP window are reserved for "
"buffering overhead."
msgstr ""

#
#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:264
msgid ""
"A maximum of (I<window/2^tcp_app_win>, mss) bytes in the window are reserved "
"for the application buffer.  A value of 0 implies that no amount is "
"reserved."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:264
#, no-wrap
msgid "I<tcp_base_mss> (Integer; default: 512; since Linux 2.6.17)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:273
msgid ""
"The initial value of I<search_low> to be used by the packetization layer "
"Path MTU discovery (MTU probing).  If MTU probing is enabled, this is the "
"initial MSS used by the connection."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:273
#, no-wrap
msgid "I<tcp_bic> (Boolean; default: disabled; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:287
msgid ""
"Enable BIC TCP congestion control algorithm.  BIC-TCP is a sender-side only "
"change that ensures a linear RTT fairness under large windows while offering "
"both scalability and bounded TCP-friendliness.  The protocol combines two "
"schemes called additive increase and binary search increase.  When the "
"congestion window is large, additive increase with a large increment ensures "
"linear RTT fairness as well as good scalability.  Under small congestion "
"windows, binary search increase provides TCP friendliness."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:287
#, no-wrap
msgid "I<tcp_bic_low_window> (integer; default: 14; Linux 2.4.27/2.6.6 to 2.6.13)"
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:294
msgid ""
"Set the threshold window (in packets) where BIC TCP starts to adjust the "
"congestion window.  Below this threshold BIC TCP behaves the same as the "
"default TCP Reno."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:294
#, no-wrap
msgid ""
"I<tcp_bic_fast_convergence> (Boolean; default: enabled; Linux 2.4.27/2.6.6 "
"to 2.6.13)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:298
msgid ""
"Force BIC TCP to more quickly respond to changes in congestion window.  "
"Allows two flows sharing the same connection to converge more rapidly."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:298
#, no-wrap
msgid "I<tcp_congestion_control> (String; default: see text; since Linux 2.4.13)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:305
msgid ""
"Set the default congestion-control algorithm to be used for new "
"connections.  The algorithm \"reno\" is always available, but additional "
"choices may be available depending on kernel configuration.  The default "
"value for this file is set as part of kernel configuration."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:305
#, no-wrap
msgid "I<tcp_dma_copybreak> (integer; default: 4096; since Linux 2.6.24)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:312
msgid ""
"Lower limit, in bytes, of the size of socket reads that will be offloaded to "
"a DMA copy engine, if one is present in the system and the kernel was "
"configured with the B<CONFIG_NET_DMA> option."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:312
#, no-wrap
msgid "I<tcp_dsack> (Boolean; default: enabled; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:316
msgid "Enable RFC\\ 2883 TCP Duplicate SACK support."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:316
#, no-wrap
msgid "I<tcp_ecn> (Boolean; default: disabled; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:323
msgid ""
"Enable RFC\\ 2884 Explicit Congestion Notification.  When enabled, "
"connectivity to some destinations could be affected due to older, "
"misbehaving routers along the path causing connections to be dropped."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:323
#, no-wrap
msgid "I<tcp_fack> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.92
#. type: Plain text
#: build/C/man7/tcp.7:327
msgid "Enable TCP Forward Acknowledgement support."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:327
#, no-wrap
msgid "I<tcp_fin_timeout> (integer; default: 60; since Linux 2.2)"
msgstr ""

#.  Since 2.1.53
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:337
msgid ""
"This specifies how many seconds to wait for a final FIN packet before the "
"socket is forcibly closed.  This is strictly a violation of the TCP "
"specification, but required to prevent denial-of-service attacks.  In Linux "
"2.2, the default value was 180."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:337
#, no-wrap
msgid "I<tcp_frto> (integer; default: 0; since Linux 2.4.21/2.6)"
msgstr ""

#.  Since 2.4.21/2.5.43
#. type: Plain text
#: build/C/man7/tcp.7:346
msgid ""
"Enable F-RTO, an enhanced recovery algorithm for TCP retransmission timeouts "
"(RTOs).  It is particularly beneficial in wireless environments where packet "
"loss is typically due to random radio interference rather than intermediate "
"router congestion.  See RFC 4138 for more details."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:348
msgid "This file can have one of the following values:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:351
msgid "Disabled."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:353
msgid "The basic version F-RTO algorithm is enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:358
msgid ""
"Enable SACK-enhanced F-RTO if flow uses SACK.  The basic version can be used "
"also when SACK is in use though in that case scenario(s) exists where F-RTO "
"interacts badly with the packet counting of the SACK-enabled TCP flow."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:362
msgid ""
"Before Linux 2.6.22, this parameter was a Boolean value, supporting just "
"values 0 and 1 above."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:362
#, no-wrap
msgid "I<tcp_frto_response> (integer; default: 0; since Linux 2.6.22)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:369
msgid ""
"When F-RTO has detected that a TCP retransmission timeout was spurious (i.e, "
"the timeout would have been avoided had TCP set a longer retransmission "
"timeout), TCP has several options concerning what to do next.  Possible "
"values are:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:377
msgid ""
"Rate halving based; a smooth and conservative response, results in halved "
"congestion window (I<cwnd>)  and slow-start threshold (I<ssthresh>)  after "
"one RTT."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:384
msgid ""
"Very conservative response; not recommended because even though being valid, "
"it interacts poorly with the rest of Linux TCP; halves I<cwnd> and "
"I<ssthresh> immediately."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:393
msgid ""
"Aggressive response; undoes congestion-control measures that are now known "
"to be unnecessary (ignoring the possibility of a lost retransmission that "
"would require TCP to be more cautious); I<cwnd> and I<ssthresh> are restored "
"to the values prior to timeout."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:394
#, no-wrap
msgid "I<tcp_keepalive_intvl> (integer; default: 75; since Linux 2.4)"
msgstr ""

#.  Since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:398
msgid "The number of seconds between TCP keep-alive probes."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:398
#, no-wrap
msgid "I<tcp_keepalive_probes> (integer; default: 9; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:404
msgid ""
"The maximum number of TCP keep-alive probes to send before giving up and "
"killing the connection if no response is obtained from the other end."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:404
#, no-wrap
msgid "I<tcp_keepalive_time> (integer; default: 7200; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:416
msgid ""
"The number of seconds a connection needs to be idle before TCP begins "
"sending out keep-alive probes.  Keep-alives are only sent when the "
"B<SO_KEEPALIVE> socket option is enabled.  The default value is 7200 seconds "
"(2 hours).  An idle connection is terminated after approximately an "
"additional 11 minutes (9 probes an interval of 75 seconds apart) when "
"keep-alive is enabled."
msgstr ""

#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:421
msgid ""
"Note that underlying connection tracking mechanisms and application timeouts "
"may be much shorter."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:421
#, no-wrap
msgid "I<tcp_low_latency> (Boolean; default: disabled; since Linux 2.4.21/2.6)"
msgstr ""

#.  Since 2.4.21/2.5.60
#. type: Plain text
#: build/C/man7/tcp.7:429
msgid ""
"If enabled, the TCP stack makes decisions that prefer lower latency as "
"opposed to higher throughput.  It this option is disabled, then higher "
"throughput is preferred.  An example of an application where this default "
"should be changed would be a Beowulf compute cluster."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:429
#, no-wrap
msgid "I<tcp_max_orphans> (integer; default: see below; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:443
msgid ""
"The maximum number of orphaned (not attached to any user file handle) TCP "
"sockets allowed in the system.  When this number is exceeded, the orphaned "
"connection is reset and a warning is printed.  This limit exists only to "
"prevent simple denial-of-service attacks.  Lowering this limit is not "
"recommended.  Network conditions might require you to increase the number of "
"orphans allowed, but note that each orphan can eat up to ~64K of unswappable "
"memory.  The default initial value is set equal to the kernel parameter "
"NR_FILE.  This initial default is adjusted depending on the memory in the "
"system."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:443
#, no-wrap
msgid "I<tcp_max_syn_backlog> (integer; default: see below; since Linux 2.2)"
msgstr ""

#.  Since 2.1.53
#. type: Plain text
#: build/C/man7/tcp.7:460
msgid ""
"The maximum number of queued connection requests which have still not "
"received an acknowledgement from the connecting client.  If this number is "
"exceeded, the kernel will begin dropping requests.  The default value of 256 "
"is increased to 1024 when the memory present in the system is adequate or "
"greater (E<gt>= 128Mb), and reduced to 128 for those systems with very low "
"memory (E<lt>= 32Mb).  It is recommended that if this needs to be increased "
"above 1024, TCP_SYNQ_HSIZE in I<include/net/tcp.h> be modified to keep "
"TCP_SYNQ_HSIZE*16E<lt>=tcp_max_syn_backlog, and the kernel be recompiled."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:460
#, no-wrap
msgid "I<tcp_max_tw_buckets> (integer; default: see below; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:470
msgid ""
"The maximum number of sockets in TIME_WAIT state allowed in the system.  "
"This limit exists only to prevent simple denial-of-service attacks.  The "
"default value of NR_FILE*2 is adjusted depending on the memory in the "
"system.  If this number is exceeded, the socket is closed and a warning is "
"printed."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:470
#, no-wrap
msgid "I<tcp_moderate_rcvbuf> (Boolean; default: enabled; since Linux 2.4.17/2.6.7)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:477
msgid ""
"If enabled, TCP performs receive buffer auto-tuning, attempting to "
"automatically size the buffer (no greater than I<tcp_rmem[2]>)  to match the "
"size required by the path for full throughput."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:477
#, no-wrap
msgid "I<tcp_mem> (since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:489
msgid ""
"This is a vector of 3 integers: [low, pressure, high].  These bounds, "
"measured in units of the system page size, are used by TCP to track its "
"memory usage.  The defaults are calculated at boot time from the amount of "
"available memory.  (TCP can only use I<low memory> for this, which is "
"limited to around 900 megabytes on 32-bit systems.  64-bit systems do not "
"suffer this limitation.)"
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:490
#, no-wrap
msgid "I<low>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:494
msgid ""
"TCP doesn't regulate its memory allocation when the number of pages it has "
"allocated globally is below this number."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:494 build/C/man7/udp.7:145
#, no-wrap
msgid "I<pressure>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:503
msgid ""
"When the amount of memory allocated by TCP exceeds this number of pages, TCP "
"moderates its memory consumption.  This memory pressure state is exited once "
"the number of pages allocated falls below the I<low> mark."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:503
#, no-wrap
msgid "I<high>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:507
msgid ""
"The maximum number of pages, globally, that TCP will allocate.  This value "
"overrides any other limits imposed by the kernel."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:508
#, no-wrap
msgid "I<tcp_mtu_probing> (integer; default: 0; since Linux 2.6.17)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:513
msgid ""
"This parameter controls TCP Packetization-Layer Path MTU Discovery.  The "
"following values may be assigned to the file:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:516
msgid "Disabled"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:518
msgid "Disabled by default, enabled when an ICMP black hole detected"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:521
msgid "Always enabled, use initial MSS of I<tcp_base_mss>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:522
#, no-wrap
msgid "I<tcp_no_metrics_save> (Boolean; default: disabled; since Linux 2.6.6)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:533
msgid ""
"By default, TCP saves various connection metrics in the route cache when the "
"connection closes, so that connections established in the near future can "
"use these to set initial conditions.  Usually, this increases overall "
"performance, but it may sometimes cause performance degradation.  If "
"I<tcp_no_metrics_save> is enabled, TCP will not cache metrics on closing "
"connections."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:533
#, no-wrap
msgid "I<tcp_orphan_retries> (integer; default: 8; since Linux 2.4)"
msgstr ""

#.  Since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:538
msgid ""
"The maximum number of attempts made to probe the other end of a connection "
"which has been closed by our end."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:538
#, no-wrap
msgid "I<tcp_reordering> (integer; default: 3; since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:547
msgid ""
"The maximum a packet can be reordered in a TCP packet stream without TCP "
"assuming packet loss and going into slow start.  It is not advisable to "
"change this number.  This is a packet reordering detection metric designed "
"to minimize unnecessary back off and retransmits provoked by reordering of "
"packets on a connection."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:547
#, no-wrap
msgid "I<tcp_retrans_collapse> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.96
#. type: Plain text
#: build/C/man7/tcp.7:551
msgid "Try to send full-sized packets during retransmit."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:551
#, no-wrap
msgid "I<tcp_retries1> (integer; default: 3; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:561
msgid ""
"The number of times TCP will attempt to retransmit a packet on an "
"established connection normally, without the extra effort of getting the "
"network layers involved.  Once we exceed this number of retransmits, we "
"first have the network layer update the route if possible before each new "
"retransmit.  The default is the RFC specified minimum of 3."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:561
#, no-wrap
msgid "I<tcp_retries2> (integer; default: 15; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:571
msgid ""
"The maximum number of times a TCP packet is retransmitted in established "
"state before giving up.  The default value is 15, which corresponds to a "
"duration of approximately between 13 to 30 minutes, depending on the "
"retransmission timeout.  The RFC\\ 1122 specified minimum limit of 100 "
"seconds is typically deemed too short."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:571
#, no-wrap
msgid "I<tcp_rfc1337> (Boolean; default: disabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.90
#. type: Plain text
#: build/C/man7/tcp.7:579
msgid ""
"Enable TCP behavior conformant with RFC\\ 1337.  When disabled, if a RST is "
"received in TIME_WAIT state, we close the socket immediately without waiting "
"for the end of the TIME_WAIT period."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:579
#, no-wrap
msgid "I<tcp_rmem> (since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:587
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate receive buffer sizes.  TCP dynamically adjusts the "
"size of the receive buffer from the defaults listed below, in the range of "
"these values, depending on memory available in the system."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:588 build/C/man7/tcp.7:764 build/C/man7/udp.7:139
#, no-wrap
msgid "I<min>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:603
msgid ""
"minimum size of the receive buffer used by each TCP socket.  The default "
"value is the system page size.  (On Linux 2.4, the default value is 4K, "
"lowered to B<PAGE_SIZE> bytes in low-memory systems.)  This value is used to "
"ensure that in memory pressure mode, allocations below this size will still "
"succeed.  This is not used to bound the size of the receive buffer declared "
"using B<SO_RCVBUF> on a socket."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:603 build/C/man7/tcp.7:774
#, no-wrap
msgid "I<default>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:617
msgid ""
"the default size of the receive buffer for a TCP socket.  This value "
"overwrites the initial default buffer size from the generic global "
"I<net.core.rmem_default> defined for all protocols.  The default value is "
"87380 bytes.  (On Linux 2.4, this will be lowered to 43689 in low-memory "
"systems.)  If larger receive buffer sizes are desired, this value should be "
"increased (to affect all sockets).  To employ large TCP windows, the "
"I<net.ipv4.tcp_window_scaling> must be enabled (default)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:617 build/C/man7/tcp.7:788 build/C/man7/udp.7:151
#, no-wrap
msgid "I<max>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:626
msgid ""
"the maximum size of the receive buffer used by each TCP socket.  This value "
"does not override the global I<net.core.rmem_max>.  This is not used to "
"limit the size of the receive buffer declared using B<SO_RCVBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:628
#, no-wrap
msgid "    max(87380, min(4MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:631
msgid ""
"(On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in low-memory "
"systems)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:632
#, no-wrap
msgid "I<tcp_sack> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:636
msgid "Enable RFC\\ 2018 TCP Selective Acknowledgements."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:636
#, no-wrap
msgid "I<tcp_slow_start_after_idle> (Boolean; default: enabled; since Linux 2.6.18)"
msgstr ""

#.  The following is from 2.6.28-rc4: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:644
msgid ""
"If enabled, provide RFC 2861 behavior and time out the congestion window "
"after an idle period.  An idle period is defined as the current RTO "
"(retransmission timeout).  If disabled, the congestion window will not be "
"timed out after an idle period."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:644
#, no-wrap
msgid "I<tcp_stdurg> (Boolean; default: disabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.44
#.  RFC 793 was ambiguous in its specification of the meaning of the
#.  urgent pointer.  RFC 1122 (and RFC 961) fixed on a particular
#.  resolution of this ambiguity (unfortunately the "wrong" one).
#. type: Plain text
#: build/C/man7/tcp.7:658
msgid ""
"If this option is enabled, then use the RFC\\ 1122 interpretation of the TCP "
"urgent-pointer field.  According to this interpretation, the urgent pointer "
"points to the last byte of urgent data.  If this option is disabled, then "
"use the BSD-compatible interpretation of the urgent pointer: the urgent "
"pointer points to the first byte after the urgent data.  Enabling this "
"option may lead to interoperability problems."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:658
#, no-wrap
msgid "I<tcp_syn_retries> (integer; default: 5; since Linux 2.2)"
msgstr ""

#.  Since 2.1.38
#. type: Plain text
#: build/C/man7/tcp.7:665
msgid ""
"The maximum number of times initial SYNs for an active TCP connection "
"attempt will be retransmitted.  This value should not be higher than 255.  "
"The default value is 5, which corresponds to approximately 180 seconds."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:665
#, no-wrap
msgid "I<tcp_synack_retries> (integer; default: 5; since Linux 2.2)"
msgstr ""

#.  Since 2.1.38
#. type: Plain text
#: build/C/man7/tcp.7:671
msgid ""
"The maximum number of times a SYN/ACK segment for a passive TCP connection "
"will be retransmitted.  This number should not be higher than 255."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:671
#, no-wrap
msgid "I<tcp_syncookies> (Boolean; since Linux 2.2)"
msgstr ""

#.  Since 2.1.43
#. type: Plain text
#: build/C/man7/tcp.7:691
msgid ""
"Enable TCP syncookies.  The kernel must be compiled with "
"B<CONFIG_SYN_COOKIES>.  Send out syncookies when the syn backlog queue of a "
"socket overflows.  The syncookies feature attempts to protect a socket from "
"a SYN flood attack.  This should be used as a last resort, if at all.  This "
"is a violation of the TCP protocol, and conflicts with other areas of TCP "
"such as TCP extensions.  It can cause problems for clients and relays.  It "
"is not recommended as a tuning mechanism for heavily loaded servers to help "
"with overloaded or misconfigured conditions.  For recommended alternatives "
"see I<tcp_max_syn_backlog>, I<tcp_synack_retries>, and "
"I<tcp_abort_on_overflow>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:691
#, no-wrap
msgid "I<tcp_timestamps> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:695
msgid "Enable RFC\\ 1323 TCP timestamps."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:695
#, no-wrap
msgid "I<tcp_tso_win_divisor> (integer; default: 3; since Linux 2.6.9)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:701
msgid ""
"This parameter controls what percentage of the congestion window can be "
"consumed by a single TCP Segmentation Offload (TSO) frame.  The setting of "
"this parameter is a tradeoff between burstiness and building larger TSO "
"frames."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:701
#, no-wrap
msgid "I<tcp_tw_recycle> (Boolean; default: disabled; since Linux 2.4)"
msgstr ""

#.  Since 2.3.15
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:710
msgid ""
"Enable fast recycling of TIME_WAIT sockets.  Enabling this option is not "
"recommended since this causes problems when working with NAT (Network "
"Address Translation)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:710
#, no-wrap
msgid "I<tcp_tw_reuse> (Boolean; default: disabled; since Linux 2.4.19/2.6)"
msgstr ""

#.  Since 2.4.19/2.5.43
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:718
msgid ""
"Allow to reuse TIME_WAIT sockets for new connections when it is safe from "
"protocol viewpoint.  It should not be changed without advice/request of "
"technical experts."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:718
#, no-wrap
msgid "I<tcp_vegas_cong_avoid> (Boolean; default: disabled; Linux 2.2 to 2.6.13)"
msgstr ""

#.  Since 2.1.8; removed in 2.6.13
#
#.  The following is from 2.6.12: Documentation/networking/ip-sysctl.txt
#. type: Plain text
#: build/C/man7/tcp.7:729
msgid ""
"Enable TCP Vegas congestion avoidance algorithm.  TCP Vegas is a sender-side "
"only change to TCP that anticipates the onset of congestion by estimating "
"the bandwidth.  TCP Vegas adjusts the sending rate by modifying the "
"congestion window.  TCP Vegas should provide less packet loss, but it is not "
"as aggressive as TCP Reno."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:729
#, no-wrap
msgid "I<tcp_westwood> (Boolean; default: disabled; Linux 2.4.26/2.6.3 to 2.6.13)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:741
msgid ""
"Enable TCP Westwood+ congestion control algorithm.  TCP Westwood+ is a "
"sender-side only modification of the TCP Reno protocol stack that optimizes "
"the performance of TCP congestion control.  It is based on end-to-end "
"bandwidth estimation to set congestion window and slow start threshold after "
"a congestion episode.  Using this estimation, TCP Westwood+ adaptively sets "
"a slow start threshold and a congestion window which takes into account the "
"bandwidth used at the time congestion is experienced.  TCP Westwood+ "
"significantly increases fairness with respect to TCP Reno in wired networks "
"and throughput over wireless links."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:741
#, no-wrap
msgid "I<tcp_window_scaling> (Boolean; default: enabled; since Linux 2.2)"
msgstr ""

#.  Since 2.1.36
#. type: Plain text
#: build/C/man7/tcp.7:755
msgid ""
"Enable RFC\\ 1323 TCP window scaling.  This feature allows the use of a "
"large window (E<gt> 64K) on a TCP connection, should the other end support "
"it.  Normally, the 16 bit window length field in the TCP header limits the "
"window size to less than 64K bytes.  If larger windows are desired, "
"applications can increase the size of their socket buffers and the window "
"scaling option will be employed.  If I<tcp_window_scaling> is disabled, TCP "
"will not negotiate the use of window scaling with the other end during "
"connection setup."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:755
#, no-wrap
msgid "I<tcp_wmem> (since Linux 2.4)"
msgstr ""

#.  Since 2.4.0-test7
#. type: Plain text
#: build/C/man7/tcp.7:763
msgid ""
"This is a vector of 3 integers: [min, default, max].  These parameters are "
"used by TCP to regulate send buffer sizes.  TCP dynamically adjusts the size "
"of the send buffer from the default values listed below, in the range of "
"these values, depending on memory available."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:774
msgid ""
"Minimum size of the send buffer used by each TCP socket.  The default value "
"is the system page size.  (On Linux 2.4, the default value is 4K bytes.)  "
"This value is used to ensure that in memory pressure mode, allocations below "
"this size will still succeed.  This is not used to bound the size of the "
"send buffer declared using B<SO_SNDBUF> on a socket."
msgstr ""

#.  True in Linux 2.4 and 2.6
#. type: Plain text
#: build/C/man7/tcp.7:788
msgid ""
"The default size of the send buffer for a TCP socket.  This value overwrites "
"the initial default buffer size from the generic global "
"I</proc/sys/net/core/wmem_default> defined for all protocols.  The default "
"value is 16K bytes.  If larger send buffer sizes are desired, this value "
"should be increased (to affect all sockets).  To employ large TCP windows, "
"the I</proc/sys/net/ipv4/tcp_window_scaling> must be set to a nonzero value "
"(default)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:797
msgid ""
"The maximum size of the send buffer used by each TCP socket.  This value "
"does not override the value in I</proc/sys/net/core/wmem_max>.  This is not "
"used to limit the size of the send buffer declared using B<SO_SNDBUF> on a "
"socket.  The default value is calculated using the formula"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:799
#, no-wrap
msgid "    max(65536, min(4MB, I<tcp_mem>[1]*PAGE_SIZE/128))\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:802
msgid ""
"(On Linux 2.4, the default value is 128K bytes, lowered 64K depending on "
"low-memory systems.)"
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:803
#, no-wrap
msgid ""
"I<tcp_workaround_signed_windows> (Boolean; default: disabled; since Linux "
"2.6.26)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:809
msgid ""
"If enabled, assume that no receipt of a window-scaling option means that the "
"remote TCP is broken and treats the window as a signed quantity.  If "
"disabled, assume that the remote TCP is not broken even if we do not receive "
"a window scaling option from it."
msgstr ""

#.  or SOL_TCP on Linux
#.  FIXME Document TCP_CONGESTION (new in 2.6.13)
#. type: Plain text
#: build/C/man7/tcp.7:824
msgid ""
"To set or get a TCP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_TCP>.  In addition, most B<IPPROTO_IP> socket options are valid on "
"TCP sockets.  For more information see B<ip>(7)."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:824
#, no-wrap
msgid "B<TCP_CORK> (since Linux 2.2)"
msgstr ""

#.  precisely: since 2.1.127
#. type: Plain text
#: build/C/man7/tcp.7:840
msgid ""
"If set, don't send out partial frames.  All queued partial frames are sent "
"when the option is cleared again.  This is useful for prepending headers "
"before calling B<sendfile>(2), or for throughput optimization.  As currently "
"implemented, there is a 200 millisecond ceiling on the time for which output "
"is corked by B<TCP_CORK>.  If this ceiling is reached, then queued data is "
"automatically transmitted.  This option can be combined with B<TCP_NODELAY> "
"only since Linux 2.5.71.  This option should not be used in code intended to "
"be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:840
#, no-wrap
msgid "B<TCP_DEFER_ACCEPT> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.38
#. type: Plain text
#: build/C/man7/tcp.7:848
msgid ""
"Allow a listener to be awakened only when data arrives on the socket.  Takes "
"an integer value (seconds), this can bound the maximum number of attempts "
"TCP will make to complete the connection.  This option should not be used in "
"code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:848
#, no-wrap
msgid "B<TCP_INFO> (since Linux 2.4)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:854
msgid ""
"Used to collect information about this socket.  The kernel returns a "
"I<struct tcp_info> as defined in the file I</usr/include/linux/tcp.h>.  This "
"option should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:854
#, no-wrap
msgid "B<TCP_KEEPCNT> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:861
msgid ""
"The maximum number of keepalive probes TCP should send before dropping the "
"connection.  This option should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:861
#, no-wrap
msgid "B<TCP_KEEPIDLE> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:870
msgid ""
"The time (in seconds) the connection needs to remain idle before TCP starts "
"sending keepalive probes, if the socket option B<SO_KEEPALIVE> has been set "
"on this socket.  This option should not be used in code intended to be "
"portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:870
#, no-wrap
msgid "B<TCP_KEEPINTVL> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:875
msgid ""
"The time (in seconds) between individual keepalive probes.  This option "
"should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:875
#, no-wrap
msgid "B<TCP_LINGER2> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:887
msgid ""
"The lifetime of orphaned FIN_WAIT2 state sockets.  This option can be used "
"to override the system-wide setting in the file "
"I</proc/sys/net/ipv4/tcp_fin_timeout> for this socket.  This is not to be "
"confused with the B<socket>(7)  level option B<SO_LINGER>.  This option "
"should not be used in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:887
#, no-wrap
msgid "B<TCP_MAXSEG>"
msgstr ""

#.  Present in Linux 1.0
#.  FIXME
#.  Document TCP_MD5SIG, added in Linux 2.6.20,
#.  Needs CONFIG_TCP_MD5SIG
#.  From net/inet/Kconfig
#.  bool "TCP: MD5 Signature Option support (RFC2385) (EXPERIMENTAL)"
#.  RFC2385 specifies a method of giving MD5 protection to TCP sessions.
#.  Its main (only?) use is to protect BGP sessions between core routers
#.  on the Internet.
#
#.  There is a TCP_MD5SIG option documented in FreeBSD's tcp(4),
#.  but probably many details are different on Linux
#.  Authors were yoshfuji@linux-ipv6.org and Dave Muller
#.  http://thread.gmane.org/gmane.linux.network/47490
#.  http://www.daemon-systems.org/man/tcp.4.html
#.  http://article.gmane.org/gmane.os.netbsd.devel.network/3767/match=tcp_md5sig+freebsd
#. type: Plain text
#: build/C/man7/tcp.7:912
msgid ""
"The maximum segment size for outgoing TCP packets.  In Linux 2.2 and "
"earlier, and in Linux 2.6.28 and later, if this option is set before "
"connection establishment, it also changes the MSS value announced to the "
"other end in the initial packet.  Values greater than the (eventual) "
"interface MTU have no effect.  TCP will also impose its minimum and maximum "
"bounds over the value provided."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:912
#, no-wrap
msgid "B<TCP_NODELAY>"
msgstr ""

#.  Present in Linux 1.0
#. type: Plain text
#: build/C/man7/tcp.7:929
msgid ""
"If set, disable the Nagle algorithm.  This means that segments are always "
"sent as soon as possible, even if there is only a small amount of data.  "
"When not set, data is buffered until there is a sufficient amount to send "
"out, thereby avoiding the frequent sending of small packets, which results "
"in poor utilization of the network.  This option is overridden by "
"B<TCP_CORK>; however, setting this option forces an explicit flush of "
"pending output, even if B<TCP_CORK> is currently set."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:929
#, no-wrap
msgid "B<TCP_QUICKACK> (since Linux 2.4.4)"
msgstr ""

#.  FIXME Document TCP_USER_TIMEOUT (new in 2.6.37)
#.  See commit dca43c75e7e545694a9dd6288553f55c53e2a3a3
#. type: Plain text
#: build/C/man7/tcp.7:946
msgid ""
"Enable quickack mode if set or disable quickack mode if cleared.  In "
"quickack mode, acks are sent immediately, rather than delayed if needed in "
"accordance to normal TCP operation.  This flag is not permanent, it only "
"enables a switch to or from quickack mode.  Subsequent operation of the TCP "
"protocol will once again enter/leave quickack mode depending on internal "
"protocol processing and factors such as delayed ack timeouts occurring and "
"data transfer.  This option should not be used in code intended to be "
"portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:946
#, no-wrap
msgid "B<TCP_SYNCNT> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.18
#. type: Plain text
#: build/C/man7/tcp.7:953
msgid ""
"Set the number of SYN retransmits that TCP should send before aborting the "
"attempt to connect.  It cannot exceed 255.  This option should not be used "
"in code intended to be portable."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:953
#, no-wrap
msgid "B<TCP_WINDOW_CLAMP> (since Linux 2.4)"
msgstr ""

#.  Precisely: since 2.3.41
#. type: Plain text
#: build/C/man7/tcp.7:960
msgid ""
"Bound the size of the advertised window to this value.  The kernel imposes a "
"minimum size of SOCK_MIN_RCVBUF/2.  This option should not be used in code "
"intended to be portable."
msgstr ""

#. type: SS
#: build/C/man7/tcp.7:960 build/C/man7/unix.7:173
#, no-wrap
msgid "Sockets API"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:969
msgid ""
"TCP provides limited support for out-of-band data, in the form of (a single "
"byte of) urgent data.  In Linux this means if the other end sends newer "
"out-of-band data the older urgent data is inserted as normal data into the "
"stream (even when B<SO_OOBINLINE> is not set).  This differs from BSD-based "
"stacks."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:976
msgid ""
"Linux uses the BSD compatible interpretation of the urgent pointer field by "
"default.  This violates RFC\\ 1122, but is required for interoperability "
"with other stacks.  It can be changed via I</proc/sys/net/ipv4/tcp_stdurg>."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:981
msgid ""
"It is possible to peek at out-of-band data using the I<recv>(2)  B<MSG_PEEK> "
"flag."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:997
msgid ""
"Since version 2.4, Linux supports the use of B<MSG_TRUNC> in the I<flags> "
"argument of B<recv>(2)  (and B<recvmsg>(2)).  This flag causes the received "
"bytes of data to be discarded, rather than passed back in a caller-supplied "
"buffer.  Since Linux 2.4.4, B<MSG_PEEK> also has this effect when used in "
"conjunction with B<MSG_OOB> to receive out-of-band data."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1003 build/C/man7/unix.7:286
msgid ""
"The following B<ioctl>(2)  calls return information in I<value>.  The "
"correct syntax is:"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1008
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<tcp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1013
msgid "I<ioctl_type> is one of the following:"
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1013 build/C/man7/unix.7:296
#, no-wrap
msgid "B<SIOCINQ>"
msgstr ""

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCINQ to be defined in glibc headers
#.  SIOCOUTQ also has an effect for UNIX domain sockets, but not
#.  quite what userland might expect. It seems to return the number
#.  of bytes allocated for buffers containing pending output.
#.  That number is normally larger than the number of bytes of pending
#.  output. Since this info is, from userland's point of view, imprecise,
#.  and it may well change, probably best not to document this now.
#. type: Plain text
#: build/C/man7/tcp.7:1029 build/C/man7/unix.7:318
msgid ""
"Returns the amount of queued unread data in the receive buffer.  The socket "
"must not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCINQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<FIONREAD>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1029
#, no-wrap
msgid "B<SIOCATMARK>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1034
msgid ""
"Returns true (i.e., I<value> is nonzero) if the inbound data stream is at "
"the urgent mark."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1050
msgid ""
"If the B<SO_OOBINLINE> socket option is set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the urgent data.  If the "
"B<SO_OOBINLINE> socket option is not set, and B<SIOCATMARK> returns true, "
"then the next read from the socket will return the bytes following the "
"urgent data (to actually read the urgent data requires the B<recv(MSG_OOB)> "
"flag)."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1064
msgid ""
"Note that a read never reads across the urgent mark.  If an application is "
"informed of the presence of urgent data via B<select>(2)  (using the "
"I<exceptfds> argument) or through delivery of a B<SIGURG> signal, then it "
"can advance up to the mark using a loop which repeatedly tests B<SIOCATMARK> "
"and performs a read (requesting any number of bytes) as long as "
"B<SIOCATMARK> returns false."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1064
#, no-wrap
msgid "B<SIOCOUTQ>"
msgstr ""

#.  FIXME http://sources.redhat.com/bugzilla/show_bug.cgi?id=12002,
#.  filed 2010-09-10, may cause SIOCOUTQ to be defined in glibc headers
#. type: Plain text
#: build/C/man7/tcp.7:1080
msgid ""
"Returns the amount of unsent data in the socket send queue.  The socket must "
"not be in LISTEN state, otherwise an error (B<EINVAL>)  is returned.  "
"B<SIOCOUTQ> is defined in I<E<lt>linux/sockios.hE<gt>>.  Alternatively, you "
"can use the synonymous B<TIOCOUTQ>, defined in I<E<lt>sys/ioctl.hE<gt>>."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1085
msgid ""
"When a network error occurs, TCP tries to resend the packet.  If it doesn't "
"succeed after some time, either B<ETIMEDOUT> or the last received error on "
"this connection is reported."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1096
msgid ""
"Some applications require a quicker error notification.  This can be enabled "
"with the B<IPPROTO_IP> level B<IP_RECVERR> socket option.  When this option "
"is enabled, all incoming errors are immediately passed to the user program.  "
"Use this option with care \\(em it makes TCP less tolerant to routing "
"changes and other normal network conditions."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1097
#, no-wrap
msgid "B<EAFNOTSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1103
msgid "Passed socket address type in I<sin_family> was not B<AF_INET>."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1107
msgid ""
"The other end closed the socket unexpectedly or a read is executed on a shut "
"down socket."
msgstr ""

#. type: TP
#: build/C/man7/tcp.7:1107
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1110
msgid "The other end didn't acknowledge retransmitted data after some time."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1114
msgid ""
"Any errors defined for B<ip>(7)  or the generic socket layer may also be "
"returned for TCP."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1121
msgid ""
"Support for Explicit Congestion Notification, zero-copy B<sendfile>(2), "
"reordering support and some SACK extensions (DSACK) were introduced in 2.4.  "
"Support for forward acknowledgement (FACK), TIME_WAIT recycling, and "
"per-connection keepalive socket options were introduced in 2.3."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1123
msgid "Not all errors are documented."
msgstr ""

#.  Only a single Linux kernel version is described
#.  Info for 2.2 was lost. Should be added again,
#.  or put into a separate page.
#.  .SH AUTHORS
#.  This man page was originally written by Andi Kleen.
#.  It was updated for 2.4 by Nivedita Singhvi with input from
#.  Alexey Kuznetsov's Documentation/networking/ip-sysctl.txt
#.  document.
#. type: Plain text
#: build/C/man7/tcp.7:1133
msgid "IPv6 is not described."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1145
msgid ""
"B<accept>(2), B<bind>(2), B<connect>(2), B<getsockopt>(2), B<listen>(2), "
"B<recvmsg>(2), B<sendfile>(2), B<sendmsg>(2), B<socket>(2), B<ip>(7), "
"B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1147
msgid "RFC\\ 793 for the TCP specification."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1149
msgid ""
"RFC\\ 1122 for the TCP requirements and a description of the Nagle "
"algorithm."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1151
msgid "RFC\\ 1323 for TCP timestamp and window scaling options."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1153
msgid "RFC\\ 1337 for a description of TIME_WAIT assassination hazards."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1155
msgid "RFC\\ 3168 for a description of Explicit Congestion Notification."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1157
msgid "RFC\\ 2581 for TCP congestion control algorithms."
msgstr ""

#. type: Plain text
#: build/C/man7/tcp.7:1159
msgid "RFC\\ 2018 and RFC\\ 2883 for SACK and extensions to SACK."
msgstr ""

#. type: TH
#: build/C/man7/udp.7:8
#, no-wrap
msgid "UDP"
msgstr ""

#. type: TH
#: build/C/man7/udp.7:8
#, no-wrap
msgid "2010-06-13"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:11
msgid "udp - User Datagram Protocol for IPv4"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:17
msgid "B<udp_socket = socket(AF_INET, SOCK_DGRAM, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:23
msgid ""
"This is an implementation of the User Datagram Protocol described in RFC\\ "
"768.  It implements a connectionless, unreliable datagram packet service.  "
"Packets may be reordered or duplicated before they arrive.  UDP generates "
"and checks checksums to catch transmission errors."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:52
msgid ""
"When a UDP socket is created, its local and remote addresses are "
"unspecified.  Datagrams can be sent immediately using B<sendto>(2)  or "
"B<sendmsg>(2)  with a valid destination address as an argument.  When "
"B<connect>(2)  is called on the socket, the default destination address is "
"set and datagrams can now be sent using B<send>(2)  or B<write>(2)  without "
"specifying a destination address.  It is still possible to send to other "
"destinations by passing an address to B<sendto>(2)  or B<sendmsg>(2).  In "
"order to receive packets, the socket can be bound to a local address first "
"by using B<bind>(2).  Otherwise the socket layer will automatically assign a "
"free local port out of the range defined by "
"I</proc/sys/net/ipv4/ip_local_port_range> and bind the socket to "
"B<INADDR_ANY>."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:60
msgid ""
"All receive operations return only one packet.  When the packet is smaller "
"than the passed buffer, only that much data is returned; when it is bigger, "
"the packet is truncated and the B<MSG_TRUNC> flag is set.  B<MSG_WAITALL> is "
"not supported."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:69
msgid ""
"IP options may be sent or received using the socket options described in "
"B<ip>(7).  They are only processed by the kernel when the appropriate "
"I</proc> parameter is enabled (but still passed to the user even when it is "
"turned off).  See B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:74
msgid ""
"When the B<MSG_DONTROUTE> flag is set on sending, the destination address "
"must refer to a local interface address and the packet is only sent to that "
"interface."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:92
msgid ""
"By default, Linux UDP does path MTU (Maximum Transmission Unit) discovery.  "
"This means the kernel will keep track of the MTU to a specific target IP "
"address and return B<EMSGSIZE> when a UDP packet write exceeds it.  When "
"this happens, the application should decrease the packet size.  Path MTU "
"discovery can be also turned off using the B<IP_MTU_DISCOVER> socket option "
"or the I</proc/sys/net/ipv4/ip_no_pmtu_disc> file; see B<ip>(7)  for "
"details.  When turned off, UDP will fragment outgoing UDP packets that "
"exceed the interface MTU.  However, disabling it is not recommended for "
"performance and reliability reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:97
msgid "UDP uses the IPv4 I<sockaddr_in> address format described in B<ip>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:108
msgid ""
"All fatal errors will be passed to the user as an error return even when the "
"socket is not connected.  This includes asynchronous errors received from "
"the network.  You may get an error for an earlier packet that was sent on "
"the same socket.  This behavior differs from many other BSD socket "
"implementations which don't pass any errors unless the socket is connected.  "
"Linux's behavior is mandated by B<RFC\\ 1122>."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:122
msgid ""
"For compatibility with legacy code, in Linux 2.0 and 2.2 it was possible to "
"set the B<SO_BSDCOMPAT> B<SOL_SOCKET> option to receive remote errors only "
"when the socket has been connected (except for B<EPROTO> and B<EMSGSIZE>).  "
"Locally generated errors are always passed.  Support for this socket option "
"was removed in later kernels; see B<socket>(7)  for further information."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:131
msgid ""
"When the B<IP_RECVERR> option is enabled, all errors are stored in the "
"socket error queue, and can be received by B<recvmsg>(2)  with the "
"B<MSG_ERRQUEUE> flag set."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:134
msgid ""
"System-wide UDP parameter settings can be accessed by files in the directory "
"I</proc/sys/net/ipv4/>."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:134
#, no-wrap
msgid "I<udp_mem> (since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:138
msgid ""
"This is a vector of three integers governing the number of pages allowed for "
"queueing by all UDP sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:145
msgid ""
"Below this number of pages, UDP is not bothered about its memory appetite.  "
"When the amount of memory allocated by UDP exceeds this number, UDP starts "
"to moderate memory usage."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:151
msgid ""
"This value was introduced to follow the format of I<tcp_mem> (see "
"B<tcp>(7))."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:154
msgid "Number of pages allowed for queueing by all UDP sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:158
msgid ""
"Defaults values for these three items are calculated at boot time from the "
"amount of available memory."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:158
#, no-wrap
msgid "I<udp_rmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:165
msgid ""
"Minimal size, in bytes, of receive buffers used by UDP sockets in "
"moderation.  Each UDP socket is able to use the size for receiving data, "
"even if total pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:165
#, no-wrap
msgid "I<udp_wmem_min> (integer; default value: PAGE_SIZE; since Linux 2.6.25)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:172
msgid ""
"Minimal size, in bytes, of send buffer used by UDP sockets in moderation.  "
"Each UDP socket is able to use the size for sending data, even if total "
"pages of UDP sockets exceed I<udp_mem> pressure."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:179
msgid ""
"To set or get a UDP socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDP>."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:179
#, no-wrap
msgid "B<UDP_CORK> (since Linux 2.5.44)"
msgstr ""

#.  FIXME document UDP_ENCAP (new in kernel 2.5.67)
#.  From include/linux/udp.h:
#.  /* UDP encapsulation types */
#.  #define UDP_ENCAP_ESPINUDP_NON_IKE      1 /* draft-ietf-ipsec-nat-t-ike-00/01 */
#.  #define UDP_ENCAP_ESPINUDP      2 /* draft-ietf-ipsec-udp-encaps-06 */
#.  #define UDP_ENCAP_L2TPINUDP     3 /* rfc2661 */
#. type: Plain text
#: build/C/man7/udp.7:192
msgid ""
"If this option is enabled, then all data output on this socket is "
"accumulated into a single datagram that is transmitted when the option is "
"disabled.  This option should not be used in code intended to be portable."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:196
msgid "These ioctls can be accessed using B<ioctl>(2).  The correct syntax is:"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:201
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<udp_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: TP
#: build/C/man7/udp.7:203
#, no-wrap
msgid "B<FIONREAD> (B<SIOCINQ>)"
msgstr ""

#.  See http://www.securiteam.com/unixfocus/5KP0I15IKO.html
#.  "GNUnet DoS (UDP Socket Unreachable)", 14 May 2006
#. type: Plain text
#: build/C/man7/udp.7:221
msgid ""
"Gets a pointer to an integer as argument.  Returns the size of the next "
"pending datagram in the integer in bytes, or 0 when no datagram is pending.  "
"B<Warning:> Using B<FIONREAD>, it is impossible to distinguish the case "
"where no datagram is pending from the case where the next pending datagram "
"contains zero bytes of data.  It is safer to use B<select>(2), B<poll>(2), "
"or B<epoll>(7)  to distinguish these cases."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:221
#, no-wrap
msgid "B<TIOCOUTQ> (B<SIOCOUTQ>)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:225
msgid ""
"Returns the number of data bytes in the local send queue.  Only supported "
"with Linux 2.4 and above."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:231
msgid ""
"In addition all ioctls documented in B<ip>(7)  and B<socket>(7)  are "
"supported."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:237
msgid ""
"All errors documented for B<socket>(7)  or B<ip>(7)  may be returned by a "
"send or receive on a UDP socket."
msgstr ""

#. type: TP
#: build/C/man7/udp.7:237 build/C/man7/unix.7:323
#, no-wrap
msgid "B<ECONNREFUSED>"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:241
msgid ""
"No receiver was associated with the destination address.  This might be "
"caused by a previous packet sent over the socket."
msgstr ""

#.  .SH CREDITS
#.  This man page was written by Andi Kleen.
#. type: Plain text
#: build/C/man7/udp.7:246
msgid "B<IP_RECVERR> is a new feature in Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:251
msgid "B<ip>(7), B<raw>(7), B<socket>(7), B<udplite>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:253
msgid "RFC\\ 768 for the User Datagram Protocol."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:255
msgid "RFC\\ 1122 for the host requirements."
msgstr ""

#. type: Plain text
#: build/C/man7/udp.7:257
msgid "RFC\\ 1191 for a description of path MTU discovery."
msgstr ""

#. type: TH
#: build/C/man7/udplite.7:25
#, no-wrap
msgid "UDPLITE"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:28
msgid "udplite - Lightweight User Datagram Protocol"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:36
msgid "B<sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDPLITE);>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:39
msgid ""
"This is an implementation of the Lightweight User Datagram Protocol "
"(UDP-Lite), as described in RFC\\ 3828."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:45
msgid ""
"UDP-Lite is an extension of UDP (RFC\\ 768) to support variable-length "
"checksums.  This has advantages for some types of multimedia transport that "
"may be able to make use of slightly damaged datagrams, rather than having "
"them discarded by lower-layer protocols."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:51
msgid ""
"The variable-length checksum coverage is set via a B<setsockopt>(2)  "
"option.  If this option is not set, the only difference to UDP is in using a "
"different IP protocol identifier (IANA number 136)."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:56
msgid ""
"The UDP-Lite implementation is a full extension of B<udp>(7), i.e., it "
"shares the same API and API behaviour, and in addition offers two socket "
"options to control the checksum coverage."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:65
msgid ""
"UDP-Litev4 uses the I<sockaddr_in> address format described in B<ip>(7).  "
"UDP-Litev6 uses the I<sockaddr_in6> address format described in B<ipv6>(7)."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:78
msgid ""
"To set or get a UDP-Lite socket option, call B<getsockopt>(2)  to read or "
"B<setsockopt>(2)  to write the option with the option level argument set to "
"B<IPPROTO_UDPLITE>.  In addition, all B<IPPROTO_UDP> socket options are "
"valid on a UDP-Lite socket.  See B<udp>(7)  for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:80
msgid "The following two options are specific to UDP-Lite."
msgstr ""

#. type: TP
#: build/C/man7/udplite.7:80
#, no-wrap
msgid "B<UDPLITE_SEND_CSCOV>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:85
msgid ""
"This option sets the sender checksum coverage and takes an I<int> as "
"argument, with a checksum coverage value in the range 0..2^16-1."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:89
msgid ""
"A value of 0 means that the entire datagram is always covered.  Values from "
"1-7 are illegal (RFC\\ 3828, 3.1) and are rounded up to the minimum coverage "
"of 8."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:95
msgid ""
"With regard to IPv6 jumbograms (RFC\\ 2675), the UDP-Litev6 checksum "
"coverage is limited to the first 2^16-1 octets, as per RFC\\ 3828, 3.5.  "
"Higher values are therefore silently truncated to 2^16-1.  If in doubt, the "
"current coverage value can always be queried using B<getsockopt>(2)."
msgstr ""

#. type: TP
#: build/C/man7/udplite.7:95
#, no-wrap
msgid "B<UDPLITE_RECV_CSCOV>"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:106
msgid ""
"This is the receiver-side analogue and uses the same argument format and "
"value range as B<UDPLITE_SEND_CSCOV>.  This option is not required to enable "
"traffic with partial checksum coverage.  Its function is that of a traffic "
"filter: when enabled, it instructs the kernel to drop all packets which have "
"a coverage I<less> than the specified coverage value."
msgstr ""

#.  SO_NO_CHECK exists and is supported by UDPv4, but is
#.  commented out in socket(7), hence also commented out here
#. .PP
#. Since UDP-Lite mandates checksums, checksumming can not be disabled
#. via the
#. .B SO_NO_CHECK
#. option from
#. .BR socket (7).
#. type: Plain text
#: build/C/man7/udplite.7:119
msgid ""
"When the value of B<UDPLITE_RECV_CSCOV> exceeds the actual packet coverage, "
"incoming packets are silently dropped, but may generate a warning message in "
"the system log."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:124
msgid ""
"All errors documented for B<udp>(7)  may be returned.  UDP-Lite does not add "
"further errors."
msgstr ""

#.  FIXME . remove this section once glibc supports UDP-Lite
#. type: Plain text
#: build/C/man7/udplite.7:127
msgid "Where glibc support is missing, the following definitions are needed:"
msgstr ""

#.  The following two are defined in the kernel in linux/net/udplite.h
#. type: Plain text
#: build/C/man7/udplite.7:134
#, no-wrap
msgid ""
"#define IPPROTO_UDPLITE     136\n"
"#define UDPLITE_SEND_CSCOV  10\n"
"#define UDPLITE_RECV_CSCOV  11\n"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:139
msgid "I</proc/net/snmp> - basic UDP-Litev4 statistics counters."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:142
msgid "I</proc/net/snmp6> - basic UDP-Litev6 statistics counters."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:144
msgid "UDP-Litev4/v6 first appeared in Linux 2.6.20."
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:149
msgid "B<ip>(7), B<ipv6>(7), B<socket>(7), B<udp>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:151
msgid "RFC\\ 3828 for the Lightweight User Datagram Protocol (UDP-Lite)"
msgstr ""

#. type: Plain text
#: build/C/man7/udplite.7:153
msgid "I<Documentation/networking/udplite.txt>"
msgstr ""

#. type: TH
#: build/C/man7/unix.7:15
#, no-wrap
msgid "UNIX"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:19
msgid "unix - Sockets for local interprocess communication"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:23
msgid "B<#include E<lt>sys/un.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:25
msgid "I<unix_socket>B< = socket(AF_UNIX, type, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:27
msgid "I<error>B< = socketpair(AF_UNIX, type, 0, int *>I<sv>B<);>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:38
msgid ""
"The B<AF_UNIX> (also known as B<AF_LOCAL>)  socket family is used to "
"communicate between processes on the same machine efficiently.  "
"Traditionally, UNIX domain sockets can be either unnamed, or bound to a file "
"system pathname (marked as being of type socket).  Linux also supports an "
"abstract namespace which is independent of the file system."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:50
msgid ""
"Valid types are: B<SOCK_STREAM>, for a stream-oriented socket and "
"B<SOCK_DGRAM>, for a datagram-oriented socket that preserves message "
"boundaries (as on most UNIX implementations, UNIX domain datagram sockets "
"are always reliable and don't reorder datagrams); and (since Linux 2.6.4)  "
"B<SOCK_SEQPACKET>, for a connection-oriented socket that preserves message "
"boundaries and delivers messages in the order that they were sent."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:53
msgid ""
"UNIX domain sockets support passing file descriptors or process credentials "
"to other processes using ancillary data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:55
msgid "A UNIX domain socket address is represented in the following structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:59
#, no-wrap
msgid "#define UNIX_PATH_MAX    108\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:64
#, no-wrap
msgid ""
"struct sockaddr_un {\n"
"    sa_family_t sun_family;               /* AF_UNIX */\n"
"    char        sun_path[UNIX_PATH_MAX];  /* pathname */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:70
msgid "I<sun_family> always contains B<AF_UNIX>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:72
msgid "Three types of address are distinguished in this structure:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:87
msgid ""
"I<pathname>: a UNIX domain socket can be bound to a null-terminated file "
"system pathname using B<bind>(2).  When the address of the socket is "
"returned by B<getsockname>(2), B<getpeername>(2), and B<accept>(2), its "
"length is I<offsetof(struct sockaddr_un, sun_path) + strlen(sun_path) + 1>, "
"and I<sun_path> contains the null-terminated pathname."
msgstr ""

#.  There is quite some variation across implementations: FreeBSD
#.  says the length is 16 bytes, HP-UX 11 says it's zero bytes.
#. type: Plain text
#: build/C/man7/unix.7:107
msgid ""
"I<unnamed>: A stream socket that has not been bound to a pathname using "
"B<bind>(2)  has no name.  Likewise, the two sockets created by "
"B<socketpair>(2)  are unnamed.  When the address of an unnamed socket is "
"returned by B<getsockname>(2), B<getpeername>(2), and B<accept>(2), its "
"length is I<sizeof(sa_family_t)>, and I<sun_path> should not be inspected."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:133
msgid ""
"I<abstract>: an abstract socket address is distinguished by the fact that "
"I<sun_path[0]> is a null byte (\\(aq\\e0\\(aq).  The socket's address in "
"this namespace is given by the additional bytes in I<sun_path> that are "
"covered by the specified length of the address structure.  (Null bytes in "
"the name have no special significance.)  The name has no connection with "
"file system pathnames.  When the address of an abstract socket is returned "
"by B<getsockname>(2), B<getpeername>(2), and B<accept>(2), the returned "
"I<addrlen> is greater than I<sizeof(sa_family_t)> (i.e., greater than 2), "
"and the name of the socket is contained in the first I<(addrlen - "
"sizeof(sa_family_t))> bytes of I<sun_path>.  The abstract socket namespace "
"is a nonportable Linux extension."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:146
msgid ""
"For historical reasons these socket options are specified with a "
"B<SOL_SOCKET> type even though they are B<AF_UNIX> specific.  They can be "
"set with B<setsockopt>(2)  and read with B<getsockopt>(2)  by specifying "
"B<SOL_SOCKET> as the socket family."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:146
#, no-wrap
msgid "B<SO_PASSCRED>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:153
msgid ""
"Enables the receiving of the credentials of the sending process in an "
"ancillary message.  When this option is set and the socket is not yet "
"connected a unique name in the abstract namespace will be generated "
"automatically.  Expects an integer boolean flag."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:153
#, no-wrap
msgid "Autobind Feature"
msgstr ""

#.  i.e. sizeof(short)
#. type: Plain text
#: build/C/man7/unix.7:173
msgid ""
"If a B<bind>(2)  call specifies I<addrlen> as I<sizeof(sa_family_t)>, or the "
"B<SO_PASSCRED> socket option was specified for a socket that was not "
"explicitly bound to an address, then the socket is autobound to an abstract "
"address.  The address consists of a null byte followed by 5 bytes in the "
"character set I<[0-9a-f]>.  Thus, there is a limit of 2^20 autobind "
"addresses.  (From Linux 2.1.15, when the autobind feature was added, 8 bytes "
"were used, and the limit was thus 2^32 autobind addresses.  The change to 5 "
"bytes came in Linux 2.3.15.)"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:176
msgid ""
"The following paragraphs describe domain-specific details and unsupported "
"features of the sockets API for UNIX domain sockets on Linux."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:184
msgid ""
"UNIX domain sockets do not support the transmission of out-of-band data (the "
"B<MSG_OOB> flag for B<send>(2)  and B<recv>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:189
msgid "The B<send>(2)  B<MSG_MORE> flag is not supported by UNIX domain sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:197
msgid ""
"The use of B<MSG_TRUNC> in the I<flags> argument of B<recv>(2)  is not "
"supported by UNIX domain sockets."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:209
msgid ""
"The B<SO_SNDBUF> socket option does have an effect for UNIX domain sockets, "
"but the B<SO_RCVBUF> option does not.  For datagram sockets, the "
"B<SO_SNDBUF> value imposes an upper limit on the size of outgoing "
"datagrams.  This limit is calculated as the doubled (see B<socket>(7))  "
"option value less 32 bytes used for overhead."
msgstr ""

#. type: SS
#: build/C/man7/unix.7:209
#, no-wrap
msgid "Ancillary Messages"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:231
msgid ""
"Ancillary data is sent and received using B<sendmsg>(2)  and B<recvmsg>(2).  "
"For historical reasons the ancillary message types listed below are "
"specified with a B<SOL_SOCKET> type even though they are B<AF_UNIX> "
"specific.  To send them set the I<cmsg_level> field of the struct I<cmsghdr> "
"to B<SOL_SOCKET> and the I<cmsg_type> field to the type.  For more "
"information see B<cmsg>(3)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:231
#, no-wrap
msgid "B<SCM_RIGHTS>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:237
msgid ""
"Send or receive a set of open file descriptors from another process.  The "
"data portion contains an integer array of the file descriptors.  The passed "
"file descriptors behave as though they have been created with B<dup>(2)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:237
#, no-wrap
msgid "B<SCM_CREDENTIALS>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:247
msgid ""
"Send or receive UNIX credentials.  This can be used for authentication.  The "
"credentials are passed as a I<struct ucred> ancillary message.  Thus "
"structure is defined in I<E<lt>sys/socket.hE<gt>> as follows:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:255
#, no-wrap
msgid ""
"struct ucred {\n"
"    pid_t pid;    /* process ID of the sending process */\n"
"    uid_t uid;    /* user ID of the sending process */\n"
"    gid_t gid;    /* group ID of the sending process */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:264
msgid ""
"Since glibc 2.8, the B<_GNU_SOURCE> feature test macro must be defined "
"(before including I<any> header files) in order to obtain the definition of "
"this structure."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:280
msgid ""
"The credentials which the sender specifies are checked by the kernel.  A "
"process with effective user ID 0 is allowed to specify values that do not "
"match its own.  The sender must specify its own process ID (unless it has "
"the capability B<CAP_SYS_ADMIN>), its user ID, effective user ID, or saved "
"set-user-ID (unless it has B<CAP_SETUID>), and its group ID, effective group "
"ID, or saved set-group-ID (unless it has B<CAP_SETGID>).  To receive a "
"I<struct ucred> message the B<SO_PASSCRED> option must be enabled on the "
"socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:291
#, no-wrap
msgid ""
"B<int>I< value>B<;>\n"
"I<error>B< = ioctl(>I<unix_socket>B<, >I<ioctl_type>B<, &>I<value>B<);>\n"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:296
msgid "I<ioctl_type> can be:"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:323
msgid ""
"The specified local address is already in use or the file system socket "
"object already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:329
msgid ""
"The remote address specified by B<connect>(2)  was not a listening socket.  "
"This error can also occur if the target filename is not a socket."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:329
#, no-wrap
msgid "B<ECONNRESET>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:332
msgid "Remote socket was unexpectedly closed."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:335
msgid "User memory address was not valid."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:344
msgid ""
"Invalid argument passed.  A common cause is that the value B<AF_UNIX> was "
"not specified in the I<sun_type> field of passed addresses, or the socket "
"was in an invalid state for the applied operation."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:349
msgid ""
"B<connect>(2)  called on an already connected socket or a target address was "
"specified on a connected socket."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:354
msgid ""
"The pathname in the remote address specified to B<connect>(2)  did not "
"exist."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:354
#, no-wrap
msgid "B<ENOMEM>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:360
msgid "Socket operation needs a target address, but the socket is not connected."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:364
msgid ""
"Stream operation called on non-stream oriented socket or tried to use the "
"out-of-band data option."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:368
msgid "The sender passed invalid credentials in the I<struct ucred>."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:380
msgid ""
"Remote socket was closed on a stream socket.  If enabled, a B<SIGPIPE> is "
"sent as well.  This can be avoided by passing the B<MSG_NOSIGNAL> flag to "
"B<sendmsg>(2)  or B<recvmsg>(2)."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:380
#, no-wrap
msgid "B<EPROTONOSUPPORT>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:384
msgid "Passed protocol is not B<AF_UNIX>."
msgstr ""

#. type: TP
#: build/C/man7/unix.7:384
#, no-wrap
msgid "B<EPROTOTYPE>"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:390
msgid ""
"Remote socket does not match the local socket type (B<SOCK_DGRAM> versus "
"B<SOCK_STREAM>)"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:393
msgid "Unknown socket type."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:397
msgid ""
"Other errors can be generated by the generic socket layer or by the file "
"system while generating a file system socket object.  See the appropriate "
"manual pages for more information."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:403
msgid ""
"B<SCM_CREDENTIALS> and the abstract namespace were introduced with Linux 2.2 "
"and should not be used in portable programs.  (Some BSD-derived systems also "
"support credential passing, but the implementation details differ.)"
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:414
msgid ""
"In the Linux implementation, sockets which are visible in the file system "
"honor the permissions of the directory they are in.  Their owner, group and "
"their permissions can be changed.  Creation of a new socket will fail if the "
"process does not have write and search (execute) permission on the directory "
"the socket is created in.  Connecting to the socket object requires "
"read/write permission.  This behavior differs from many BSD-derived systems "
"which ignore permissions for UNIX domain sockets.  Portable programs should "
"not rely on this feature for security."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:422
msgid ""
"Binding to a socket with a filename creates a socket in the file system that "
"must be deleted by the caller when it is no longer needed (using "
"B<unlink>(2)).  The usual UNIX close-behind semantics apply; the socket can "
"be unlinked at any time and will be finally removed from the file system "
"when the last reference to it is closed."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:431
msgid ""
"To pass file descriptors or credentials over a B<SOCK_STREAM>, you need to "
"send or receive at least one byte of nonancillary data in the same "
"B<sendmsg>(2)  or B<recvmsg>(2)  call."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:433
msgid "UNIX domain stream sockets do not support the notion of out-of-band data."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:436
msgid "See B<bind>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:441
msgid "For an example of the use of B<SCM_RIGHTS> see B<cmsg>(3)."
msgstr ""

#. type: Plain text
#: build/C/man7/unix.7:450
msgid ""
"B<recvmsg>(2), B<sendmsg>(2), B<socket>(2), B<socketpair>(2), B<cmsg>(3), "
"B<capabilities>(7), B<credentials>(7), B<socket>(7)"
msgstr ""

#. type: TH
#: build/C/man7/x25.7:7
#, no-wrap
msgid "X25"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:10
msgid "x25 - ITU-T X.25 / ISO-8208 protocol interface."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:14
msgid "B<#include E<lt>linux/x25.hE<gt>>"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:16
msgid "B<x25_socket = socket(AF_X25, SOCK_SEQPACKET, 0);>"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:25
msgid ""
"X25 sockets provide an interface to the X.25 packet layer protocol.  This "
"allows applications to communicate over a public X.25 data network as "
"standardized by International Telecommunication Union's recommendation X.25 "
"(X.25 DTE-DCE mode).  X25 sockets can also be used for communication without "
"an intermediate X.25 network (X.25 DTE-DTE mode) as described in ISO-8208."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:42
msgid ""
"Message boundaries are preserved \\(em a B<read>(2)  from a socket will "
"retrieve the same chunk of data as output with the corresponding B<write>(2)  "
"to the peer socket.  When necessary, the kernel takes care of segmenting and "
"reassembling long messages by means of the X.25 M-bit.  There is no "
"hard-coded upper limit for the message size.  However, reassembling of a "
"long message might fail if there is a temporary lack of system resources or "
"when other constraints (such as socket memory or buffer size limits) become "
"effective.  If that occurs, the X.25 connection will be reset."
msgstr ""

#. type: SS
#: build/C/man7/x25.7:42
#, no-wrap
msgid "Socket Addresses"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:49
msgid ""
"The B<AF_X25> socket address family uses the I<struct sockaddr_x25> for "
"representing network addresses as defined in ITU-T recommendation X.121."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:56
#, no-wrap
msgid ""
"struct sockaddr_x25 {\n"
"    sa_family_t sx25_family;    /* must be AF_X25 */\n"
"    x25_address sx25_addr;      /* X.121 Address */\n"
"};\n"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:67
msgid ""
"I<sx25_addr> contains a char array I<x25_addr[]> to be interpreted as a "
"null-terminated string.  I<sx25_addr.x25_addr[]> consists of up to 15 (not "
"counting the terminating 0) ASCII characters forming the X.121 address.  "
"Only the decimal digit characters from \\(aq0\\(aq to \\(aq9\\(aq are "
"allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:76
msgid ""
"The following X.25-specific socket options can be set by using "
"B<setsockopt>(2)  and read with B<getsockopt>(2)  with the I<level> argument "
"set to B<SOL_X25>."
msgstr ""

#. type: TP
#: build/C/man7/x25.7:76
#, no-wrap
msgid "B<X25_QBITINCL>"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:95
msgid ""
"Controls whether the X.25 Q-bit (Qualified Data Bit) is accessible by the "
"user.  It expects an integer argument.  If set to 0 (default), the Q-bit is "
"never set for outgoing packets and the Q-bit of incoming packets is "
"ignored.  If set to 1, an additional first byte is prepended to each message "
"read from or written to the socket.  For data read from the socket, a 0 "
"first byte indicates that the Q-bits of the corresponding incoming data "
"packets were not set.  A first byte with value 1 indicates that the Q-bit of "
"the corresponding incoming data packets was set.  If the first byte of the "
"data written to the socket is 1 the Q-bit of the corresponding outgoing data "
"packets will be set.  If the first byte is 0 the Q-bit will not be set."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:97
msgid "The AF_X25 protocol family is a new feature of Linux 2.2."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:100
msgid "Plenty, as the X.25 PLP implementation is B<CONFIG_EXPERIMENTAL>."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:102
msgid "This man page is incomplete."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:109
msgid ""
"There is no dedicated application programmer's header file yet; you need to "
"include the kernel header file I<E<lt>linux/x25.hE<gt>>.  "
"B<CONFIG_EXPERIMENTAL> might also imply that future versions of the "
"interface are not binary compatible."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:113
msgid ""
"X.25 N-Reset events are not propagated to the user process yet.  Thus, if a "
"reset occurred, data might be lost without notice."
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:116
msgid "B<socket>(2), B<socket>(7)"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:120
msgid ""
"Jonathan Simon Naylor: \\(lqThe Re-Analysis and Re-Implementation of "
"X.25.\\(rq The URL is"
msgstr ""

#. type: Plain text
#: build/C/man7/x25.7:122
msgid "I<ftp://ftp.pspt.fi/pub/ham/linux/ax25/x25doc.tgz>"
msgstr ""

# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-08-15 19:32+0900\n"
"PO-Revision-Date: 2013-07-24 00:18+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/__setfpucw.3:8
#, no-wrap
msgid "__SETFPUCW"
msgstr "__SETFPUCW"

#. type: TH
#: build/C/man3/__setfpucw.3:8
#, no-wrap
msgid "2012-12-31"
msgstr "2012-12-31"

#. type: TH
#: build/C/man3/__setfpucw.3:8 build/C/man3/queue.3:39
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/__setfpucw.3:8 build/C/man3/addseverity.3:9
#: build/C/man3/argz_add.3:10 build/C/man3/backtrace.3:27
#: build/C/man3/basename.3:27 build/C/man3/envz_add.3:10
#: build/C/man3/ftok.3:29 build/C/man3/longjmp.3:27 build/C/man3/offsetof.3:28
#: build/C/man3/program_invocation_name.3:24 build/C/man3/queue.3:39
#: build/C/man3/realpath.3:28 build/C/man3/setjmp.3:27
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/__setfpucw.3:9 build/C/man3/addseverity.3:10
#: build/C/man3/argz_add.3:11 build/C/man3/backtrace.3:28
#: build/C/man3/basename.3:28 build/C/man3/envz_add.3:11
#: build/C/man3/ftok.3:30 build/C/man3/longjmp.3:28 build/C/man3/offsetof.3:29
#: build/C/man3/program_invocation_name.3:25 build/C/man3/queue.3:40
#: build/C/man3/realpath.3:29 build/C/man3/setjmp.3:28
#: build/C/man3/xcrypt.3:14
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/__setfpucw.3:11
msgid "__setfpucw - set FPU control word on i386 architecture (obsolete)"
msgstr ""
"__setfpucw - i386 アーキテクチャにおける FPU のコントロールワードの設定 "
"(obsolete)"

#. type: SH
#: build/C/man3/__setfpucw.3:11 build/C/man3/addseverity.3:12
#: build/C/man3/argz_add.3:15 build/C/man3/backtrace.3:31
#: build/C/man3/basename.3:30 build/C/man3/envz_add.3:14
#: build/C/man3/ftok.3:32 build/C/man3/longjmp.3:30 build/C/man3/offsetof.3:31
#: build/C/man3/program_invocation_name.3:28 build/C/man3/queue.3:48
#: build/C/man3/realpath.3:31 build/C/man3/setjmp.3:30
#: build/C/man3/xcrypt.3:16
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/__setfpucw.3:13
msgid "B<#include E<lt>i386/fpu_control.hE<gt>>"
msgstr "B<#include E<lt>i386/fpu_control.hE<gt>>"

#. type: Plain text
#: build/C/man3/__setfpucw.3:15
msgid "B<void __setfpucw(unsigned short >I<control_word>B<);>"
msgstr "B<void __setfpucw(unsigned short >I<control_word>B<);>"

#. type: SH
#: build/C/man3/__setfpucw.3:15 build/C/man3/addseverity.3:27
#: build/C/man3/argz_add.3:51 build/C/man3/backtrace.3:50
#: build/C/man3/basename.3:38 build/C/man3/envz_add.3:36
#: build/C/man3/ftok.3:39 build/C/man3/longjmp.3:46 build/C/man3/offsetof.3:37
#: build/C/man3/program_invocation_name.3:36 build/C/man3/queue.3:86
#: build/C/man3/realpath.3:51 build/C/man3/setjmp.3:49
#: build/C/man3/xcrypt.3:24
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/__setfpucw.3:22
msgid ""
"B<__setfpucw>()  transfers I<control_word> to the registers of the FPU "
"(floating-point unit) on the i386 architecture.  This was used to control "
"floating-point precision, rounding and floating-point exceptions."
msgstr ""
"B<__setfpucw>()  は、i386アーキテクチャにおいて I<control_word> を FPU "
"(floating-point unit) のレジスタに転送する。 これは浮動小数点演算の精度、丸め"
"方、 および浮動小数点例外を制御するのに使われる。"

#. type: SH
#: build/C/man3/__setfpucw.3:22 build/C/man3/addseverity.3:60
#: build/C/man3/argz_add.3:198 build/C/man3/backtrace.3:143
#: build/C/man3/basename.3:129 build/C/man3/envz_add.3:118
#: build/C/man3/ftok.3:70 build/C/man3/longjmp.3:90 build/C/man3/offsetof.3:63
#: build/C/man3/program_invocation_name.3:56 build/C/man3/queue.3:485
#: build/C/man3/realpath.3:137 build/C/man3/setjmp.3:88
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/__setfpucw.3:24
msgid "This function was a nonstandard GNU extension."
msgstr "この関数は非標準で GNU 拡張である。"

#. type: SH
#: build/C/man3/__setfpucw.3:24 build/C/man3/addseverity.3:67
#: build/C/man3/backtrace.3:145 build/C/man3/basename.3:131
#: build/C/man3/ftok.3:72 build/C/man3/longjmp.3:95
#: build/C/man3/program_invocation_name.3:59 build/C/man3/realpath.3:144
#: build/C/man3/setjmp.3:93
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/__setfpucw.3:43
msgid ""
"As of glibc 2.1 this function does not exist anymore.  There are new "
"functions from C99, with prototypes in I<E<lt>fenv.hE<gt>>, to control FPU "
"rounding modes, like B<fegetround>(3), B<fesetround>(3), and the floating-"
"point environment, like B<fegetenv>(3), B<feholdexcept>(3), B<fesetenv>(3), "
"B<feupdateenv>(3), and FPU exception handling, like B<feclearexcept>(3), "
"B<fegetexceptflag>(3), B<feraiseexcept>(3), B<fesetexceptflag>(3), and "
"B<fetestexcept>(3)."
msgstr ""
"glibc 2.1 以降では、この関数は存在しない。 新たな関数群が C99 から導入され"
"た。これらのプロトタイプは I<E<lt>fenv.hE<gt>> に置かれている。 FPU の丸め"
"モードの制御には B<fegetround>(3), B<fesetround>(3) などが、浮動小数点関連の"
"環境には B<fegetenv>(3), B<feholdexcept>(3), B<fesetenv>(3), B<feupdateenv>"
"(3) などが、 FPU 例外処理には B<feclearexcept>(3), B<fegetexceptflag>(3), "
"B<feraiseexcept>(3), B<fesetexceptflag>(3), B<fetestexcept>(3) などが導入され"
"た。"

#. type: Plain text
#: build/C/man3/__setfpucw.3:51
msgid ""
"If direct access to the FPU control word is still needed, the B<_FPU_GETCW> "
"and B<_FPU_SETCW> macros from I<E<lt>fpu_control.hE<gt>> can be used."
msgstr ""
"FPU のコントロールワードへどうしても直接アクセスする必要がある場合には、 "
"I<E<lt>fpu_control.hE<gt>> の B<_FPU_GETCW> マクロと B<_FPU_SETCW> マクロを用"
"いることは可能である。"

#. type: SH
#: build/C/man3/__setfpucw.3:51 build/C/man3/backtrace.3:167
#: build/C/man3/basename.3:164 build/C/man3/envz_add.3:121
#: build/C/man3/offsetof.3:65
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/__setfpucw.3:53
msgid "B<__setfpucw(0x1372)>"
msgstr "B<__setfpucw(0x1372)>"

#. type: Plain text
#: build/C/man3/__setfpucw.3:55
msgid "Set FPU control word on the i386 architecture to"
msgstr "は、i386アーキテクチャにおける FPU のコントロールワードを、"

#. type: Plain text
#: build/C/man3/__setfpucw.3:57
#, no-wrap
msgid "     - extended precision\n"
msgstr "     - 拡張精度\n"

#. type: Plain text
#: build/C/man3/__setfpucw.3:59
#, no-wrap
msgid "     - rounding to nearest\n"
msgstr "     - 最も近い整数へ丸める、中間の場合は偶数を選択する。\n"

#. type: Plain text
#: build/C/man3/__setfpucw.3:61
#, no-wrap
msgid "     - exceptions on overflow, zero divide and NaN\n"
msgstr "     - 桁溢れ、0で除算、及び無効値(NaN)ときに例外を発生に設定する。\n"

#. type: SH
#: build/C/man3/__setfpucw.3:61 build/C/man3/addseverity.3:70
#: build/C/man3/argz_add.3:204 build/C/man3/backtrace.3:251
#: build/C/man3/basename.3:177 build/C/man3/envz_add.3:143
#: build/C/man3/ftok.3:101 build/C/man3/longjmp.3:132
#: build/C/man3/program_invocation_name.3:63 build/C/man3/realpath.3:226
#: build/C/man3/setjmp.3:126 build/C/man3/xcrypt.3:72
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/__setfpucw.3:63
msgid "B<feclearexcept>(3)"
msgstr "B<feclearexcept>(3)"

#. type: Plain text
#: build/C/man3/__setfpucw.3:65
msgid "I<E<lt>fpu_control.hE<gt>>"
msgstr "I<E<lt>fpu_control.hE<gt>>"

#. type: SH
#: build/C/man3/__setfpucw.3:65 build/C/man3/addseverity.3:72
#: build/C/man3/argz_add.3:206 build/C/man3/backtrace.3:256
#: build/C/man3/basename.3:180 build/C/man3/envz_add.3:145
#: build/C/man3/ftok.3:107 build/C/man3/longjmp.3:135
#: build/C/man3/offsetof.3:105 build/C/man3/program_invocation_name.3:65
#: build/C/man3/queue.3:491 build/C/man3/realpath.3:232
#: build/C/man3/setjmp.3:129 build/C/man3/xcrypt.3:74
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/__setfpucw.3:72 build/C/man3/addseverity.3:79
#: build/C/man3/argz_add.3:213 build/C/man3/backtrace.3:263
#: build/C/man3/basename.3:187 build/C/man3/envz_add.3:152
#: build/C/man3/ftok.3:114 build/C/man3/longjmp.3:142
#: build/C/man3/offsetof.3:112 build/C/man3/program_invocation_name.3:72
#: build/C/man3/queue.3:498 build/C/man3/realpath.3:239
#: build/C/man3/setjmp.3:136 build/C/man3/xcrypt.3:81
#, fuzzy
#| msgid ""
#| "This page is part of release 3.52 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at \\%http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.53 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.52 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/addseverity.3:9
#, no-wrap
msgid "ADDSEVERITY"
msgstr "ADDSEVERITY"

#. type: TH
#: build/C/man3/addseverity.3:9 build/C/man3/backtrace.3:27
#, no-wrap
msgid "2008-06-14"
msgstr "2008-06-14"

#. type: TH
#: build/C/man3/addseverity.3:9 build/C/man3/backtrace.3:27
#: build/C/man3/basename.3:27 build/C/man3/ftok.3:29
#: build/C/man3/offsetof.3:28 build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/addseverity.3:12
msgid "addseverity - introduce new severity classes"
msgstr "addseverity - 新しい重大度 (severity class) を導入する"

#. type: Plain text
#: build/C/man3/addseverity.3:16
#, no-wrap
msgid "B<#include E<lt>fmtmsg.hE<gt>>\n"
msgstr "B<#include E<lt>fmtmsg.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/addseverity.3:18
#, no-wrap
msgid "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"
msgstr "B<int addseverity(int >I<severity>B<, const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/addseverity.3:23 build/C/man3/longjmp.3:42
#: build/C/man3/realpath.3:42 build/C/man3/setjmp.3:42
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/addseverity.3:27
msgid "B<addseverity>(): _SVID_SOURCE"
msgstr "B<addseverity>(): _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/addseverity.3:49
msgid ""
"This function allows the introduction of new severity classes which can be "
"addressed by the I<severity> argument of the B<fmtmsg>(3)  function.  By "
"default that latter function only knows how to print messages for severity "
"0-4 (with strings (none), HALT, ERROR, WARNING, INFO).  This call attaches "
"the given string I<s> to the given value I<severity>.  If I<s> is NULL, the "
"severity class with the numeric value I<severity> is removed.  It is not "
"possible to overwrite or remove one of the default severity classes.  The "
"severity value must be nonnegative."
msgstr ""
"この関数により、新しい重大度を導入できる。 この重大度は、 B<fmtmsg>(3)  関数"
"の I<severity> 引き数に入れることができる。 デフォルトでは、後者の B<fmtmsg>"
"(3)  関数は重大度 0-4 (文字列では (none), HALT, ERROR, WARNING, INFO) の メッ"
"セージを表示する方法しか知らない。 この B<addseverity>(3)  の呼び出しにより、"
"指定された文字列 I<s> に指定された値 I<severity> を付加する。 I<s> が NULL の"
"場合、数値 I<severity> の重大度が削除される。 デフォルトの重大度のどれかを上"
"書きしたり削除したりすることはできない。 重大度の値は負でない数としなければな"
"らない。"

#. type: SH
#: build/C/man3/addseverity.3:49 build/C/man3/argz_add.3:192
#: build/C/man3/backtrace.3:118 build/C/man3/basename.3:121
#: build/C/man3/envz_add.3:112 build/C/man3/ftok.3:61
#: build/C/man3/longjmp.3:88 build/C/man3/offsetof.3:56
#: build/C/man3/realpath.3:91 build/C/man3/setjmp.3:78
#: build/C/man3/xcrypt.3:61
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/addseverity.3:57
msgid ""
"Upon success, the value B<MM_OK> is returned.  Upon error, the return value "
"is B<MM_NOTOK>.  Possible errors include: out of memory, attempt to remove a "
"nonexistent or default severity class."
msgstr ""
"成功した場合、値 B<MM_OK> が返される。 エラーの場合、返り値は B<MM_NOTOK> で"
"ある。 起こる可能性があるエラーには、以下のものが含まれる: メモリを使い果たし"
"た。 存在しない重大度またはデフォルトの重大度を削除しようとした。"

#. type: SH
#: build/C/man3/addseverity.3:57 build/C/man3/backtrace.3:137
#: build/C/man3/realpath.3:135 build/C/man3/xcrypt.3:67
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/addseverity.3:60
msgid "B<addseverity>()  is provided in glibc since version 2.1."
msgstr "B<addseverity>()  はバージョン 2.1 以降の glibc で提供されている。"

#. type: Plain text
#: build/C/man3/addseverity.3:67
msgid ""
"This function is not specified in the X/Open Portability Guide although the "
"B<fmtmsg>(3)  function is.  It is available on System V systems."
msgstr ""
"B<fmtmsg>(3)  関数は X/Open Portability Guide に指定されているが、 この関数は"
"指定されていない。 この関数は System V システムで利用可能である。"

#. type: Plain text
#: build/C/man3/addseverity.3:70
msgid ""
"New severity classes can also be added by setting the environment variable "
"B<SEV_LEVEL>."
msgstr ""
"新しい重大度は、環境変数 B<SEV_LEVEL> を設定することで追加することもできる。"

#. type: Plain text
#: build/C/man3/addseverity.3:72
msgid "B<fmtmsg>(3)"
msgstr "B<fmtmsg>(3)"

#. type: TH
#: build/C/man3/argz_add.3:10
#, no-wrap
msgid "ARGZ_ADD"
msgstr "ARGZ_ADD"

#. type: TH
#: build/C/man3/argz_add.3:10 build/C/man3/envz_add.3:10
#, no-wrap
msgid "2007-05-18"
msgstr "2007-05-18"

#. type: Plain text
#: build/C/man3/argz_add.3:15
msgid ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - functions to handle an argz list"
msgstr ""
"argz_add, argz_add_sep, argz_append, argz_count, argz_create, "
"argz_create_sep, argz_delete, argz_extract, argz_insert, argz_next, "
"argz_replace, argz_stringify - argz リストを操作するための関数群"

#. type: Plain text
#: build/C/man3/argz_add.3:18
#, no-wrap
msgid "B<#include E<lt>argz.hE<gt>>\n"
msgstr "B<#include E<lt>argz.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:21
#, no-wrap
msgid "B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<);>\n"
msgstr "B<error_t argz_add(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:24
#, no-wrap
msgid ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<str>B<, int >I<delim>B<);>\n"
msgstr ""
"B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<str>B<, int >I<delim>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:27
#, no-wrap
msgid ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"
msgstr ""
"B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
"B<                     const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:29
#, no-wrap
msgid "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"
msgstr "B<size_t argz_count(const char *>I<argz>B<, size_t >I<argz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:32
#, no-wrap
msgid ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""
"B<error_t argz_create(char * const >I<argv>B<[], char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:35
#, no-wrap
msgid ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"
msgstr ""
"B<error_t argz_create_sep(const char *>I<str>B<, int >I<sep>B<, char **>I<argz>B<,>\n"
"B<                     size_t *>I<argz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:37
#, no-wrap
msgid "B<error_t argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<entry>B<);>\n"
msgstr "B<error_t argz_delete(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<entry>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:39
#, no-wrap
msgid "B<void argz_extract(char *>I<argz>B<, size_t >I<argz_len>B<, char  **>I<argv>B<);>\n"
msgstr "B<void argz_extract(char *>I<argz>B<, size_t >I<argz_len>B<, char  **>I<argv>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:42
#, no-wrap
msgid ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<before>B<,>\n"
"B<                     const char *>I<entry>B<);>\n"
msgstr ""
"B<error_t argz_insert(char **>I<argz>B<, size_t *>I<argz_len>B<, char *>I<before>B<,>\n"
"B<                     const char *>I<entry>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:44
#, no-wrap
msgid "B<char *argz_next(char *>I<argz>B<, size_t >I<argz_len>B<, const char *>I<entry>B<);>\n"
msgstr "B<char *argz_next(char *>I<argz>B<, size_t >I<argz_len>B<, const char *>I<entry>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:48
#, no-wrap
msgid ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<,>\n"
"B<                     const char *>I<with>B<, unsigned int *>I<replace_count>B<);>\n"
msgstr ""
"B<error_t argz_replace(char **>I<argz>B<, size_t *>I<argz_len>B<, const char *>I<str>B<,>\n"
"B<                     const char *>I<with>B<, unsigned int *>I<replace_count>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:50
#, no-wrap
msgid "B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"
msgstr "B<void argz_stringify(char *>I<argz>B<, size_t >I<len>B<, int >I<sep>B<);>\n"

#. type: Plain text
#: build/C/man3/argz_add.3:53 build/C/man3/envz_add.3:38
msgid "These functions are glibc-specific."
msgstr "これらの関数は glibc 固有である。"

#. type: Plain text
#: build/C/man3/argz_add.3:58
msgid ""
"An argz vector is a pointer to a character buffer together with a length.  "
"The intended interpretation of the character buffer is an array of strings, "
"where the strings are separated by null bytes (\\(aq\\e0\\(aq).  If the "
"length is nonzero, the last byte of the buffer must be a null byte."
msgstr ""
"argz vector は長さ情報付きの文字バッファへのポインタである。 文字バッファで"
"は、複数の文字列が NULL バイト (\\(aq\\e0\\(aq) で区切られており、 文字列の配"
"列として解釈されるようになっている。 長さが 0 でない場合、バッファの最後のバ"
"イトは NULL バイトでなければならない。"

#. type: Plain text
#: build/C/man3/argz_add.3:67
msgid ""
"These functions are for handling argz vectors.  The pair (NULL,0) is an argz "
"vector, and, conversely, argz vectors of length 0 must have NULL pointer.  "
"Allocation of nonempty argz vectors is done using B<malloc>(3), so that "
"B<free>(3)  can be used to dispose of them again."
msgstr ""
"これらの関数は argz vector を操作するためのものである。 ペア (NULL,0) は "
"argz vector であり、逆に言えば 長さ 0 の argz vectorは NULL ポインタを持たな"
"ければならない。 空でない argz vector の割り当ては B<malloc>(3)  を使って行わ"
"れる。したがって、argz vector を解放するのに B<free>(3)  を使うことができる。"

#. type: Plain text
#: build/C/man3/argz_add.3:77
msgid ""
"B<argz_add>()  adds the string I<str> at the end of the array I<*argz>, and "
"updates I<*argz> and I<*argz_len>."
msgstr ""
"B<argz_add>()  は、文字列 I<str> を配列 I<*argz> の末尾に追加し、 I<*argz> "
"と I<*argz_len> を更新する。"

#. type: Plain text
#: build/C/man3/argz_add.3:85
msgid ""
"B<argz_add_sep>()  is similar, but splits the string I<str> into substrings "
"separated by the delimiter I<delim>.  For example, one might use this on a "
"UNIX search path with delimiter \\(aq:\\(aq."
msgstr ""
"B<argz_add_sep>()  も同様の動作をするが、区切り文字 I<delim> にしたがって文字"
"列 I<str> を複数の文字列に分割する点が異なる。 例えば、区切り文字 \\(aq:"
"\\(aq を指定して、UNIX サーチ・パスに対して この関数を使うことができるだろ"
"う。"

#. type: Plain text
#: build/C/man3/argz_add.3:99
#, fuzzy
#| msgid ""
#| "B<argz_append>()  appends the argz vector (I<buf>,\\ buf_lenI<)> after "
#| "(I<*argz>,\\ *argz_lenI<)> and updates I<*argz> and I<*argz_len>.  (Thus, "
#| "I<*argz_len> will be increased by I<buf_len>.)"
msgid ""
"B<argz_append>()  appends the argz vector (I<buf>,\\ I<buf_len>)  after "
"(I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  (Thus, "
"I<*argz_len> will be increased by I<buf_len>.)"
msgstr ""
"B<argz_append>()  は argz vector (I<buf>,\\ I<buf_len>)  の後ろに (I<*argz>,"
"\\ I<*argz_len>) を付け加え、 I<*argz> と I<*argz_len> を更新する。 (したがっ"
"て、 I<*argz_len> は I<buf_len> だけ増加する。)"

#. type: Plain text
#: build/C/man3/argz_add.3:104
#, fuzzy
#| msgid ""
#| "B<argz_count>()  counts the number of strings, that is, the number of "
#| "null bytes (\\(aq\\e0\\(aq), in (I<argz>,\\ argz_lenI<).>"
msgid ""
"B<argz_count>()  counts the number of strings, that is, the number of null "
"bytes (\\(aq\\e0\\(aq), in (I<argz>,\\ I<argz_len>)."
msgstr ""
"B<argz_count>()  は (I<argz>,\\ I<argz_len>)  内の文字列の数を数える。実際に"
"は NULL バイト (\\(aq\\e0\\(aq) の数を数えている。"

#. type: Plain text
#: build/C/man3/argz_add.3:112
#, fuzzy
#| msgid ""
#| "B<argz_create>()  converts a UNIX-style argument vector I<argv>, "
#| "terminated by I<(char\\ *)\\ 0>, into an argz vector (I<*argz>,\\ "
#| "*argz_lenI<).>"
msgid ""
"B<argz_create>()  converts a UNIX-style argument vector I<argv>, terminated "
"by I<(char\\ *)\\ 0>, into an argz vector (I<*argz>,\\ I<*argz_len>)."
msgstr ""
"B<argz_create>() は、UNIX 流の引き数ベクトルである (I<(char\\ *) 0> で終端さ"
"れる) I<argv> を、argz vector (I<*argz>,\\ I<*argz_len>)  に変換する。"

#. type: Plain text
#: build/C/man3/argz_add.3:120
#, fuzzy
#| msgid ""
#| "B<argz_create_sep>()  converts the null-terminated string I<str> into an "
#| "argz vector (I<*argz>,\\ *argz_lenI<)> by breaking it up at every "
#| "occurrence of the separator I<sep>."
msgid ""
"B<argz_create_sep>()  converts the null-terminated string I<str> into an "
"argz vector (I<*argz>,\\ I<*argz_len>)  by breaking it up at every "
"occurrence of the separator I<sep>."
msgstr ""
"B<argz_create_sep>()  は、NULL 終端された文字列 I<str> を区切り文字 I<sep> が"
"現れる毎に分割しながら、argz vector (*I<argz>,\\ I<*argz_len>)  に変換する。"

#. type: Plain text
#: build/C/man3/argz_add.3:130
#, fuzzy
#| msgid ""
#| "B<argz_delete>()  removes the substring pointed to by I<entry> from the "
#| "argz vector (I<*argz>,\\ *argz_lenI<)> and updates I<*argz> and "
#| "I<*argz_len>."
msgid ""
"B<argz_delete>()  removes the substring pointed to by I<entry> from the argz "
"vector (I<*argz>,\\ I<*argz_len>)  and updates I<*argz> and I<*argz_len>."
msgstr ""
"B<argz_delete>()  は、 I<entry> で指し示された文字列を argz vector (I<*argz>,"
"\\ I<*argz_len>) から削除し、 I<*argz> と I<*argz_len> を更新する。"

#. type: Plain text
#: build/C/man3/argz_add.3:145
#, fuzzy
#| msgid ""
#| "B<argz_extract>()  is the opposite of B<argz_create>().  It takes the "
#| "argz vector (I<argz>,\\ argz_lenI<)> and fills the array starting at "
#| "I<argv> with pointers to the substrings, and a final NULL, making a UNIX-"
#| "style argv vector.  The array I<argv> must have room for I<argz_count>"
#| "(I<argz>,I<argz_len>) + 1 pointers."
msgid ""
"B<argz_extract>()  is the opposite of B<argz_create>().  It takes the argz "
"vector (I<argz>,\\ I<argz_len>)  and fills the array starting at I<argv> "
"with pointers to the substrings, and a final NULL, making a UNIX-style argv "
"vector.  The array I<argv> must have room for I<argz_count>(I<argz>,"
"I<argz_len>) + 1 pointers."
msgstr ""
"B<argz_extract>()  は B<argz_create>()  の反対の操作を行う。argz vector "
"(I<argz>,\\ I<argz_len>)  を調べ、 I<argv> から始まる配列をサブ文字列へのポイ"
"ンタで埋めていき、 一番最後に NULL を入れて、UNIX 流の argv ベクトルを作成す"
"る。 配列 I<argv> は I<argz_count>(I<argz>,I<argz_len>) + 1 個のポインタを収"
"容できる空間を持っていなければならない。"

#. type: Plain text
#: build/C/man3/argz_add.3:164
#, fuzzy
#| msgid ""
#| "B<argz_insert>()  is the opposite of B<argz_delete>().  It inserts the "
#| "argument I<entry> at position I<before> into the argz vector (I<*argz>,\\ "
#| "*argz_lenI<)> and updates I<*argz> and I<*argz_len>.  If I<before> is "
#| "NULL, then I<entry> will inserted at the end."
msgid ""
"B<argz_insert>()  is the opposite of B<argz_delete>().  It inserts the "
"argument I<entry> at position I<before> into the argz vector (I<*argz>,\\ "
"I<*argz_len>)  and updates I<*argz> and I<*argz_len>.  If I<before> is NULL, "
"then I<entry> will inserted at the end."
msgstr ""
"B<argz_insert>()  は B<argz_delete>()  の反対の操作を行う。argz vector "
"(I<*argz>,\\ I<*argz_len>)  の位置 I<before> に引き数 I<entry> を挿入し、 "
"I<*argz> と I<*argz_len> を更新する。 I<before> が NULL の場合、 I<entry> は"
"末尾に挿入される。"

#. type: Plain text
#: build/C/man3/argz_add.3:173
msgid ""
"B<argz_next>()  is a function to step trough the argz vector.  If I<entry> "
"is NULL, the first entry is returned.  Otherwise, the entry following is "
"returned.  It returns NULL if there is no following entry."
msgstr ""
"B<argz_next>()  は argz vector を順番に調べるための関数である。 I<entry> が "
"NULL の場合、最初のエントリを返す。 そうでない場合、次のエントリを返す。 次の"
"エントリがない場合、NULL を返す。"

#. type: Plain text
#: build/C/man3/argz_add.3:185
msgid ""
"B<argz_replace>()  replaces each occurrence of I<str> with I<with>, "
"reallocating argz as necessary.  If I<replace_count> is non-NULL, "
"I<*replace_count> will be incremented by the number of replacements."
msgstr ""
"B<argz_replace>()  は、 I<str> をすべて I<with> で置き換える (必要に応じて "
"argz の再割り当てを行う)。 I<replace_count> が NULL でない場合、 "
"I<*replace_count> を置き換えを行った数だけ増やす。"

#. type: Plain text
#: build/C/man3/argz_add.3:192
msgid ""
"B<argz_stringify>()  is the opposite of B<argz_create_sep>().  It transforms "
"the argz vector into a normal string by replacing all null bytes (\\(aq"
"\\e0\\(aq) except the last by I<sep>."
msgstr ""
"B<argz_stringify>()  は B<argz_create_sep>()  の反対の操作を行う。 末尾の "
"NULL バイト以外の全ての NULL バイト (\\(aq\\e0\\(aq) を I<sep> で置き換え"
"て、 argz vector を通常の文字列に変換する。"

#. type: Plain text
#: build/C/man3/argz_add.3:198
msgid ""
"All argz functions that do memory allocation have a return type of "
"I<error_t>, and return 0 for success, and B<ENOMEM> if an allocation error "
"occurs."
msgstr ""
"メモリ割り当てを行う argz 関数群はすべて I<error_t> 型の返り値を持つ。 成功し"
"た場合は 0 を返し、割り当てエラーが発生した場合は B<ENOMEM> を返す。"

#. type: Plain text
#: build/C/man3/argz_add.3:201 build/C/man3/envz_add.3:121
msgid "These functions are a GNU extension.  Handle with care."
msgstr "これらの関数は GNU による拡張である。注意して使用すること。"

#. type: SH
#: build/C/man3/argz_add.3:201 build/C/man3/basename.3:156
#: build/C/man3/realpath.3:195 build/C/man3/xcrypt.3:70
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/argz_add.3:204
msgid ""
"Argz vectors without a terminating null byte may lead to Segmentation Faults."
msgstr ""
"NULL バイトで終端されていない argz vector を使用した場合、 segmentation "
"fault を起こすかもしれない。"

#. type: Plain text
#: build/C/man3/argz_add.3:206
msgid "B<envz_add>(3)"
msgstr "B<envz_add>(3)"

#. type: TH
#: build/C/man3/backtrace.3:27
#, no-wrap
msgid "BACKTRACE"
msgstr "BACKTRACE"

#. type: Plain text
#: build/C/man3/backtrace.3:31
msgid ""
"backtrace, backtrace_symbols, backtrace_symbols_fd - support for application "
"self-debugging"
msgstr ""
"backtrace, backtrace_symbols, backtrace_symbols_fd - アプリケーション自身での"
"デバッグのサポート"

#. type: Plain text
#: build/C/man3/backtrace.3:33
msgid "B<#include E<lt>execinfo.hE<gt>>"
msgstr "B<#include E<lt>execinfo.hE<gt>>"

#. type: Plain text
#: build/C/man3/backtrace.3:38
msgid "B<int backtrace(void> B<**>I<buffer>B<,> B<int> I<size>B<);>"
msgstr "B<int backtrace(void> B<**>I<buffer>B<,> B<int> I<size>B<);>"

#. type: Plain text
#: build/C/man3/backtrace.3:43
msgid ""
"B<char **backtrace_symbols(void *const> B<*>I<buffer>B<,> B<int> I<size>B<);>"
msgstr ""
"B<char **backtrace_symbols(void *const> B<*>I<buffer>B<,> B<int> I<size>B<);>"

#. type: Plain text
#: build/C/man3/backtrace.3:50
msgid ""
"B<void backtrace_symbols_fd(void *const> B<*>I<buffer>B<,> B<int> I<size>B<,"
"> B<int> I<fd>B<);>"
msgstr ""
"B<void backtrace_symbols_fd(void *const> B<*>I<buffer>B<,> B<int> I<size>B<,"
"> B<int> I<fd>B<);>"

#. type: Plain text
#: build/C/man3/backtrace.3:78
msgid ""
"B<backtrace>()  returns a backtrace for the calling program, in the array "
"pointed to by I<buffer>.  A backtrace is the series of currently active "
"function calls for the program.  Each item in the array pointed to by "
"I<buffer> is of type I<void\\ *>, and is the return address from the "
"corresponding stack frame.  The I<size> argument specifies the maximum "
"number of addresses that can be stored in I<buffer>.  If the backtrace is "
"larger than I<size>, then the addresses corresponding to the I<size> most "
"recent function calls are returned; to obtain the complete backtrace, make "
"sure that I<buffer> and I<size> are large enough."
msgstr ""
"B<backtrace>()  は、呼び出したプログラムのバックトレースを I<buffer> が指す配"
"列に入れて返す。バックトレースは、プログラムで 現在動作中の関数呼び出しの並び"
"である。 I<buffer> が指す配列の個々の要素は I<void\\ *> 型で、 対応するスタッ"
"クフレームからのリターンアドレスである。 I<size> 引き数は I<buffer> に格納で"
"きるアドレスの最大個数を指定する。 バックトレースが I<size> より大きい場合、 "
"I<size> 個の直近の関数呼び出しに対応するアドレスが返される。 完全なバックト"
"レースを取得するためには、確実に I<buffer> と I<size> が十分大きくなるように"
"すること。"

#. type: Plain text
#: build/C/man3/backtrace.3:103
msgid ""
"Given the set of addresses returned by B<backtrace>()  in I<buffer>, "
"B<backtrace_symbols>()  translates the addresses into an array of strings "
"that describe the addresses symbolically.  The I<size> argument specifies "
"the number of addresses in I<buffer>.  The symbolic representation of each "
"address consists of the function name (if this can be determined), a "
"hexadecimal offset into the function, and the actual return address (in "
"hexadecimal).  The address of the array of string pointers is returned as "
"the function result of B<backtrace_symbols>().  This array is B<malloc>(3)ed "
"by B<backtrace_symbols>(), and must be freed by the caller.  (The strings "
"pointed to by the array of pointers need not and should not be freed.)"
msgstr ""
"B<backtrace>()  によって I<buffer> にアドレスの集合が得られたら、 "
"B<backtrace_symbols>()  によって、アドレス集合を、そのアドレスをシンボルで表"
"した文字列の配列 に翻訳できる。 I<size> 引き数は I<buffer> に格納されたアドレ"
"スの数を指定する。 個々のアドレスのシンボル表現は、関数名 (特定できた場合)、 "
"関数へのオフセット (16進表記)、実際のリターンアドレス (16進表記)  から構成さ"
"れる。 B<backtrace_symbols>()  の実行結果としては、 文字列ポインタの配列のア"
"ドレスが返される。 この配列は B<backtrace_symbols>()  によって B<malloc>(3)  "
"され、呼び出し側で free しなければならない (ポインタの配列が指す個々の文字列"
"は free する必要はないし、 free すべきでもない)。"

#. type: Plain text
#: build/C/man3/backtrace.3:118
msgid ""
"B<backtrace_symbols_fd>()  takes the same I<buffer> and I<size> arguments as "
"B<backtrace_symbols>(), but instead of returning an array of strings to the "
"caller, it writes the strings, one per line, to the file descriptor I<fd>.  "
"B<backtrace_symbols_fd>()  does not call B<malloc>(3), and so can be "
"employed in situations where the latter function might fail."
msgstr ""
"B<backtrace_symbols_fd>()  は、 B<backtrace_symbols>()  と同じ引き数 "
"I<buffer> と I<size> をとるが、呼び出し側に文字列の配列を返す代わりに、 文字"
"列をファイルディスクリプタ I<fd> に 1 行に 1 エントリの形で書き込む。 "
"B<backtrace_symbols_fd>()  は B<malloc>(3)  を呼び出さない。 そのため、これに"
"続く関数が失敗する可能性がある状況でも利用できる。"

#. type: Plain text
#: build/C/man3/backtrace.3:130
msgid ""
"B<backtrace>()  returns the number of addresses returned in I<buffer>, which "
"is not greater than I<size>.  If the return value is less than I<size>, then "
"the full backtrace was stored; if it is equal to I<size>, then it may have "
"been truncated, in which case the addresses of the oldest stack frames are "
"not returned."
msgstr ""
"B<backtrace>()  は I<buffer> に格納したアドレスの個数を返す。その個数は "
"I<size> より大きくなることはない。 返り値が I<size> より小さい場合、バックト"
"レース全体が格納されている。返り値が I<size> と等しい場合、バックトレースは切"
"り詰められているかもしれない。 切り詰められた場合、最も古いスタックフレームの"
"アドレスは 返されないことになる。"

#. type: Plain text
#: build/C/man3/backtrace.3:137
msgid ""
"On success, B<backtrace_symbols>()  returns a pointer to the array B<malloc>"
"(3)ed by the call; on error, NULL is returned."
msgstr ""
"B<backtrace_symbols>()  は、成功すると、この呼び出しで B<malloc>(3)  された配"
"列へのポインタを返す。 エラーの場合、 NULL を返す。"

#. type: Plain text
#: build/C/man3/backtrace.3:143
msgid ""
"B<backtrace>(), B<backtrace_symbols>(), and B<backtrace_symbols_fd>()  are "
"provided in glibc since version 2.1."
msgstr ""
"B<backtrace>(), B<backtrace_symbols>(), B<backtrace_symbols_fd>()  はバージョ"
"ン 2.1 以降の glibc で提供されている。"

#. type: Plain text
#: build/C/man3/backtrace.3:145
msgid "These functions are GNU extensions."
msgstr "これらの関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/backtrace.3:149
msgid ""
"These functions make some assumptions about how a function's return address "
"is stored on the stack.  Note the following:"
msgstr ""
"これらの関数は、関数のリターンアドレスがスタック上でどのように格納されるか に"
"関してある仮定を置いている。 以下の点に注意。"

#. type: IP
#: build/C/man3/backtrace.3:149 build/C/man3/backtrace.3:155
#: build/C/man3/backtrace.3:157 build/C/man3/queue.3:93
#: build/C/man3/queue.3:95 build/C/man3/queue.3:97 build/C/man3/queue.3:99
#: build/C/man3/queue.3:109 build/C/man3/queue.3:131 build/C/man3/queue.3:133
#: build/C/man3/queue.3:135
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/backtrace.3:155
msgid ""
"Omission of the frame pointers (as implied by any of B<gcc>(1)'s nonzero "
"optimization levels) may cause these assumptions to be violated."
msgstr ""
"(B<gcc>(1)  の 0 以外の最適化レベルで暗黙のうちに行われる)  フレームポインタ"
"の省略を行うと、これらの前提が崩れる可能性がある。"

#. type: Plain text
#: build/C/man3/backtrace.3:157
msgid "Inlined functions do not have stack frames."
msgstr "インライン関数はスタックフレームを持たない。"

#. type: Plain text
#: build/C/man3/backtrace.3:159
msgid "Tail-call optimization causes one stack frame to replace another."
msgstr ""
"末尾呼び出しの最適化 (tail-call optimization) を行うと、 あるスタックフレーム"
"が別のスタックフレームを置き換える可能性がある。"

#. type: Plain text
#: build/C/man3/backtrace.3:167
msgid ""
"The symbol names may be unavailable without the use of special linker "
"options.  For systems using the GNU linker, it is necessary to use the I<-"
"rdynamic> linker option.  Note that names of \"static\" functions are not "
"exposed, and won't be available in the backtrace."
msgstr ""
"シンボル名は特別なリンカ・オプションを使用しないと利用できない場合がある。 "
"GNU リンカを使用するシステムでは、 I<-rdynamic> リンカ・オプションを使う必要"
"がある。 \"static\" な関数のシンボル名は公開されず、 バックトレースでは利用で"
"きない点に注意すること。"

#. type: Plain text
#: build/C/man3/backtrace.3:174
msgid ""
"The program below demonstrates the use of B<backtrace>()  and "
"B<backtrace_symbols>().  The following shell session shows what we might see "
"when running the program:"
msgstr ""
"以下のプログラムは、 B<backtrace>()  と B<backtrace_symbols>()  の使用例を示"
"したものである。 以下に示すシェルのセッションは、 このプログラムを動かした際"
"の実行例である。"

#. type: Plain text
#: build/C/man3/backtrace.3:188
#, no-wrap
msgid ""
"$B< cc -rdynamic prog.c -o prog>\n"
"$B< ./prog 3>\n"
"backtrace() returned 8 addresses\n"
"\\&./prog(myfunc3+0x5c) [0x80487f0]\n"
"\\&./prog [0x8048871]\n"
"\\&./prog(myfunc+0x21) [0x8048894]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(main+0x65) [0x80488fb]\n"
"\\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]\n"
"\\&./prog [0x8048711]\n"
msgstr ""
"$B< cc -rdynamic prog.c -o prog>\n"
"$B< ./prog 3>\n"
"backtrace() returned 8 addresses\n"
"\\&./prog(myfunc3+0x5c) [0x80487f0]\n"
"\\&./prog [0x8048871]\n"
"\\&./prog(myfunc+0x21) [0x8048894]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(myfunc+0x1a) [0x804888d]\n"
"\\&./prog(main+0x65) [0x80488fb]\n"
"\\&/lib/libc.so.6(__libc_start_main+0xdc) [0xb7e38f9c]\n"
"\\&./prog [0x8048711]\n"

#. type: SS
#: build/C/man3/backtrace.3:190 build/C/man3/offsetof.3:76
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/backtrace.3:197
#, no-wrap
msgid ""
"#include E<lt>execinfo.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>execinfo.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/backtrace.3:205
#, no-wrap
msgid ""
"void\n"
"myfunc3(void)\n"
"{\n"
"    int j, nptrs;\n"
"#define SIZE 100\n"
"    void *buffer[100];\n"
"    char **strings;\n"
msgstr ""
"void\n"
"myfunc3(void)\n"
"{\n"
"    int j, nptrs;\n"
"#define SIZE 100\n"
"    void *buffer[100];\n"
"    char **strings;\n"

#. type: Plain text
#: build/C/man3/backtrace.3:208
#, no-wrap
msgid ""
"    nptrs = backtrace(buffer, SIZE);\n"
"    printf(\"backtrace() returned %d addresses\\en\", nptrs);\n"
msgstr ""
"    nptrs = backtrace(buffer, SIZE);\n"
"    printf(\"backtrace() returned %d addresses\\en\", nptrs);\n"

#. type: Plain text
#: build/C/man3/backtrace.3:211
#, no-wrap
msgid ""
"    /* The call backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO)\n"
"       would produce similar output to the following: */\n"
msgstr ""
"    /* backtrace_symbols_fd(buffer, nptrs, STDOUT_FILENO) を\n"
"       呼び出しても、以下と同様の出力が得られる。 */\n"

#. type: Plain text
#: build/C/man3/backtrace.3:217
#, no-wrap
msgid ""
"    strings = backtrace_symbols(buffer, nptrs);\n"
"    if (strings == NULL) {\n"
"        perror(\"backtrace_symbols\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    strings = backtrace_symbols(buffer, nptrs);\n"
"    if (strings == NULL) {\n"
"        perror(\"backtrace_symbols\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/backtrace.3:220
#, no-wrap
msgid ""
"    for (j = 0; j E<lt> nptrs; j++)\n"
"        printf(\"%s\\en\", strings[j]);\n"
msgstr ""
"    for (j = 0; j E<lt> nptrs; j++)\n"
"        printf(\"%s\\en\", strings[j]);\n"

#. type: Plain text
#: build/C/man3/backtrace.3:223
#, no-wrap
msgid ""
"    free(strings);\n"
"}\n"
msgstr ""
"    free(strings);\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:229
#, no-wrap
msgid ""
"static void   /* \"static\" means don\\(aqt export the symbol... */\n"
"myfunc2(void)\n"
"{\n"
"    myfunc3();\n"
"}\n"
msgstr ""
"static void   /* \"static\" はシンボルを公開しないことを意味する */\n"
"myfunc2(void)\n"
"{\n"
"    myfunc3();\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:238
#, no-wrap
msgid ""
"void\n"
"myfunc(int ncalls)\n"
"{\n"
"    if (ncalls E<gt> 1)\n"
"        myfunc(ncalls - 1);\n"
"    else\n"
"        myfunc2();\n"
"}\n"
msgstr ""
"void\n"
"myfunc(int ncalls)\n"
"{\n"
"    if (ncalls E<gt> 1)\n"
"        myfunc(ncalls - 1);\n"
"    else\n"
"        myfunc2();\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:246
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s num-calls\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    if (argc != 2) {\n"
"        fprintf(stderr, \"%s num-calls\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/backtrace.3:250
#, no-wrap
msgid ""
"    myfunc(atoi(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    myfunc(atoi(argv[1]));\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/backtrace.3:256
msgid "B<gcc>(1), B<ld>(1), B<dlopen>(3), B<malloc>(3)"
msgstr "B<gcc>(1), B<ld>(1), B<dlopen>(3), B<malloc>(3)"

#. type: TH
#: build/C/man3/basename.3:27
#, no-wrap
msgid "BASENAME"
msgstr "BASENAME"

#. type: TH
#: build/C/man3/basename.3:27
#, no-wrap
msgid "2009-03-30"
msgstr "2009-03-30"

#. type: Plain text
#: build/C/man3/basename.3:30
msgid "basename, dirname - parse pathname components"
msgstr "basename, dirname - パス名を解析して各部分を取り出す"

#. type: Plain text
#: build/C/man3/basename.3:33
#, no-wrap
msgid "B<#include E<lt>libgen.hE<gt>>\n"
msgstr "B<#include E<lt>libgen.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/basename.3:35
#, no-wrap
msgid "B<char *dirname(char *>I<path>B<);>\n"
msgstr "B<char *dirname(char *>I<path>B<);>\n"

#. type: Plain text
#: build/C/man3/basename.3:37
#, no-wrap
msgid "B<char *basename(char *>I<path>B<);>\n"
msgstr "B<char *basename(char *>I<path>B<);>\n"

#. type: Plain text
#: build/C/man3/basename.3:42
msgid "Warning: there are two different functions B<basename>()  - see below."
msgstr ""
"警告: B<basename>()  には異なるバージョンが 2つ存在する。下記の「注意」の節を"
"参照のこと。"

#. type: Plain text
#: build/C/man3/basename.3:55
msgid ""
"The functions B<dirname>()  and B<basename>()  break a null-terminated "
"pathname string into directory and filename components.  In the usual case, "
"B<dirname>()  returns the string up to, but not including, the final \\(aq/"
"\\(aq, and B<basename>()  returns the component following the final \\(aq/"
"\\(aq.  Trailing \\(aq/\\(aq characters are not counted as part of the "
"pathname."
msgstr ""
"B<dirname>()  と B<basename>()  は、NULL で終端されたパス名の文字列を、 ディ"
"レクトリ部分・ファイル名部分に分割する。 通常は、 B<dirname>()  は最後の "
"\\(aq/\\(aq までの部分 (最後の \\(aq/\\(aq は含まない) を返し、 B<basename>"
"()  は最後の \\(aq/\\(aq 以降の部分を返す。 文字列の末尾についた \\(aq/\\(aq "
"文字は、パス名の一部とはみなされない。"

#. type: Plain text
#: build/C/man3/basename.3:78
msgid ""
"If I<path> does not contain a slash, B<dirname>()  returns the string \".\" "
"while B<basename>()  returns a copy of I<path>.  If I<path> is the string \"/"
"\", then both B<dirname>()  and B<basename>()  return the string \"/\".  If "
"I<path> is a NULL pointer or points to an empty string, then both B<dirname>"
"()  and B<basename>()  return the string \".\"."
msgstr ""
"I<path> に '/' 文字がない場合は、 B<dirname>()  は文字列 \".\" を返し、 "
"B<basename>()  は I<path> と同じ内容を返す。 I<path> が文字列 \"/\" に等しい"
"場合は、 B<dirname>()  も B<basename>()  も文字列 \"/\" を返す。 I<path> が "
"NULL ポインタだったり、空の文字列を指していた場合は、 B<dirname>()  も "
"B<basename>()  も文字列 \".\" を返す。"

#. type: Plain text
#: build/C/man3/basename.3:84
msgid ""
"Concatenating the string returned by B<dirname>(), a \"/\", and the string "
"returned by B<basename>()  yields a complete pathname."
msgstr ""
"B<dirname>()  の返した文字列、 \"/\"、 B<basename>()  の返した文字列、 を順に"
"結合すると、完全なパス名が得られる。"

#. type: Plain text
#: build/C/man3/basename.3:93
msgid ""
"Both B<dirname>()  and B<basename>()  may modify the contents of I<path>, so "
"it may be desirable to pass a copy when calling one of these functions."
msgstr ""
"B<dirname>()  と B<basename>()  は、いずれも I<path> の内容を変更することがあ"
"る。 したがって、これらの関数を呼び出す際には コピーを渡すのが望ましい。"

#. type: Plain text
#: build/C/man3/basename.3:102
msgid ""
"These functions may return pointers to statically allocated memory which may "
"be overwritten by subsequent calls.  Alternatively, they may return a "
"pointer to some part of I<path>, so that the string referred to by I<path> "
"should not be modified or freed until the pointer returned by the function "
"is no longer required."
msgstr ""
"これらの関数は、静的に割り当てられたメモリへのポインタを返すことがあり、 これ"
"らの領域は後の関数呼び出しで上書きされるかもしれない。 また、これらの関数は "
"I<path> の一部分を指すポインタを返すこともある。そのため、 I<path> で参照され"
"る文字列は、関数が返すポインタが不要になるまでは 変更したり free したりすべき"
"ではない。"

#. type: Plain text
#: build/C/man3/basename.3:109
msgid ""
"The following list of examples (taken from SUSv2)  shows the strings "
"returned by B<dirname>()  and B<basename>()  for different paths:"
msgstr ""
"以下の一連の例 (SUSv2 から引用) は、 いろいろな path に対して B<dirname>()  "
"と B<basename>()  が返す文字列を表したものである。"

#. type: tbl table
#: build/C/man3/basename.3:113
#, no-wrap
msgid "path    \tdirname\tbasename\n"
msgstr "path    \tdirname\tbasename\n"

#. type: tbl table
#: build/C/man3/basename.3:114
#, no-wrap
msgid "/usr/lib\t/usr\tlib\n"
msgstr "/usr/lib\t/usr\tlib\n"

#. type: tbl table
#: build/C/man3/basename.3:115
#, no-wrap
msgid "/usr/   \t/\tusr\n"
msgstr "/usr/   \t/\tusr\n"

#. type: tbl table
#: build/C/man3/basename.3:116
#, no-wrap
msgid "usr     \t.\tusr\n"
msgstr "usr     \t.\tusr\n"

#. type: tbl table
#: build/C/man3/basename.3:117
#, no-wrap
msgid "/       \t/\t/\n"
msgstr "/       \t/\t/\n"

#. type: tbl table
#: build/C/man3/basename.3:118
#, no-wrap
msgid ".       \t.\t.\n"
msgstr "\\.       \t.\t.\n"

#. type: tbl table
#: build/C/man3/basename.3:119
#, no-wrap
msgid "..      \t.\t..\n"
msgstr "\\..      \t.\t..\n"

#. type: Plain text
#: build/C/man3/basename.3:129
msgid ""
"Both B<dirname>()  and B<basename>()  return pointers to null-terminated "
"strings.  (Do not pass these pointers to B<free>(3).)"
msgstr ""
"B<dirname>()  と B<basename>()  は、いずれも NULL で終端された文字列へのポイ"
"ンタを返す。 (これらのポインタを B<free>(3)  に渡さないこと。)"

#. type: Plain text
#: build/C/man3/basename.3:131 build/C/man3/ftok.3:72
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/basename.3:136
msgid ""
"There are two different versions of B<basename>()  - the POSIX version "
"described above, and the GNU version, which one gets after"
msgstr ""
"B<basename>()  には 2種類の異なるバージョンがある。 一つはすでに説明した "
"POSIX バージョンであり、 もう一つは GNU バージョンである。 GNU バージョンを使"
"用するには以下のようにする。"

#. type: Plain text
#: build/C/man3/basename.3:140
#, no-wrap
msgid "B<    #define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
msgstr "B<    #define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"

#. type: Plain text
#: build/C/man3/basename.3:142
#, no-wrap
msgid "B<#include E<lt>string.hE<gt>>\n"
msgstr "B<#include E<lt>string.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/basename.3:150
msgid ""
"The GNU version never modifies its argument, and returns the empty string "
"when I<path> has a trailing slash, and in particular also when it is \"/\".  "
"There is no GNU version of B<dirname>()."
msgstr ""
"GNU バージョンは引き数を変更することはなく、 I<path> の末尾が '/'の場合は空の"
"文字列を返す。 特に I<path> が \"/\" の場合も空文字列を返す。 B<dirname>()  "
"には GNU バージョンはない。"

#. type: Plain text
#: build/C/man3/basename.3:156
msgid ""
"With glibc, one gets the POSIX version of B<basename>()  when I<E<lt>libgen."
"hE<gt>> is included, and the GNU version otherwise."
msgstr ""
"glibc では、 I<E<lt>libgen.hE<gt>> をインクルードすると POSIX バージョンの "
"B<basename>()  が使用され、それ以外の場合は GNU バージョンとなる。"

#. type: Plain text
#: build/C/man3/basename.3:164
msgid ""
"In the glibc implementation of the POSIX versions of these functions they "
"modify their argument, and segfault when called with a static string like \"/"
"usr/\".  Before glibc 2.2.1, the glibc version of B<dirname>()  did not "
"correctly handle pathnames with trailing \\(aq/\\(aq characters, and "
"generated a segfault if given a NULL argument."
msgstr ""
"glibc の POSIX バージョンの実装では、引き数の内容が変更され、 引き数に (\"/"
"usr/\" などの) 定数文字列を指定されると セグメンテーションフォールトを起こ"
"す。 バージョン 2.2.1 以前の glibc では、 glibc の B<dirname>()  は末尾が "
"\\(aq/\\(aq 文字になっているパス名を正しく扱えず、 引き数が NULL だとセグメン"
"テーションフォールトを起こした。"

#. type: Plain text
#: build/C/man3/basename.3:169
#, no-wrap
msgid ""
"char *dirc, *basec, *bname, *dname;\n"
"char *path = \"/etc/passwd\";\n"
msgstr ""
"char *dirc, *basec, *bname, *dname;\n"
"char *path = \"/etc/passwd\";\n"

#. type: Plain text
#: build/C/man3/basename.3:175
#, no-wrap
msgid ""
"dirc = strdup(path);\n"
"basec = strdup(path);\n"
"dname = dirname(dirc);\n"
"bname = basename(basec);\n"
"printf(\"dirname=%s, basename=%s\\en\", dname, bname);\n"
msgstr ""
"dirc = strdup(path);\n"
"basec = strdup(path);\n"
"dname = dirname(dirc);\n"
"bname = basename(basec);\n"
"printf(\"dirname=%s, basename=%s\\en\", dname, bname);\n"

#. type: Plain text
#: build/C/man3/basename.3:180
msgid "B<basename>(1), B<dirname>(1)"
msgstr "B<basename>(1), B<dirname>(1)"

#. type: TH
#: build/C/man3/envz_add.3:10
#, no-wrap
msgid "ENVZ_ADD"
msgstr "ENVZ_ADD"

#. type: Plain text
#: build/C/man3/envz_add.3:14
msgid ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - "
"environment string support"
msgstr ""
"envz_add, envz_entry, envz_get, envz_merge, envz_remove, envz_strip - 環境変"
"数文字列の操作"

#. type: Plain text
#: build/C/man3/envz_add.3:17
#, no-wrap
msgid "B<#include E<lt>envz.hE<gt>>\n"
msgstr "B<#include E<lt>envz.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:20
#, no-wrap
msgid ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"
msgstr ""
"B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                 const char *>I<name>B<, const char *>I<value>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:23
#, no-wrap
msgid "B<char *envz_entry(const char *>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<char *envz_entry(const char *>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:26
#, no-wrap
msgid "B<char *envz_get(const char *>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<char *envz_get(const char *>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:30
#, no-wrap
msgid ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"
msgstr ""
"B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
"B<                   const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:33
#, no-wrap
msgid "B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"
msgstr "B<void envz_remove(char **>I<envz>B<, size_t *>I<envz_len>B<, const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:35
#, no-wrap
msgid "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"
msgstr "B<void envz_strip(char **>I<envz>B<, size_t *>I<envz_len>B<);>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:48
msgid ""
"An argz vector is a pointer to a character buffer together with a length, "
"see B<argz_add>(3).  An envz vector is a special argz vector, namely one "
"where the strings have the form \"name=value\".  Everything after the first "
"\\(aq=\\(aq is considered to be the value.  If there is no \\(aq=\\(aq, the "
"value is taken to be NULL.  (While the value in case of a trailing \\(aq="
"\\(aq is the empty string \"\".)"
msgstr ""
"argz vector は長さ情報付きの文字バッファへのポインタである。 B<argz_add>(3)  "
"を参照のこと。 envz vector は、文字列が \"name=value (名前=値)\" の形式になっ"
"ている特別な argz vector である。 最初の \\(aq=\\(aq 以降はすべて値とみなされ"
"る。\\(aq=\\(aq がなければ、 値は NULL と解釈される。(文字列の一番最後の文字"
"が \\(aq=\\(aq の場合、値は空文字列 \"\" と解釈される。)"

#. type: Plain text
#: build/C/man3/envz_add.3:50
msgid "These functions are for handling envz vectors."
msgstr "これらの関数は envz vector を操作するためのものである。"

#. type: Plain text
#: build/C/man3/envz_add.3:69
msgid ""
"B<envz_add>()  adds the string \"I<name>=I<value>\" (in case I<value> is non-"
"NULL) or \"I<name>\" (in case I<value> is NULL) to the envz vector (I<*envz>,"
"\\ I<*envz_len>)  and updates I<*envz> and I<*envz_len>.  If an entry with "
"the same I<name> existed, it is removed."
msgstr ""
"B<envz_add>()  は、文字列 \"I<name>=I<value>\" (I<value> が NULL でない場合) "
"または \"I<name>\" (I<value> が NULL の場合) を envz vector (I<*envz>,\\ "
"I<*envz_len>)  に追加し、 I<*envz> と I<*envz_len> を更新する。 I<name> と同"
"じ名前を持つエントリがあった場合、元のエントリは削除される。"

#. type: Plain text
#: build/C/man3/envz_add.3:76
msgid ""
"B<envz_entry>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the entry if found, or NULL if not."
msgstr ""
"B<envz_entry>()  は、envz vector (I<envz>,\\ I<envz_len>)  から名前が "
"I<name> のエントリを検索する。 見つかった場合はそのエントリを返し、見つからな"
"かった場合は NULL を返す。"

#. type: Plain text
#: build/C/man3/envz_add.3:87
msgid ""
"B<envz_get>()  looks for I<name> in the envz vector (I<envz>,\\ "
"I<envz_len>)  and returns the value if found, or NULL if not.  (Note that "
"the value can also be NULL, namely when there is an entry for I<name> "
"without \\(aq=\\(aq sign.)"
msgstr ""
"B<envz_get>()  は、envz vector (I<envz>,\\ I<envz_len>)  から名前が I<name> "
"のエントリを検索する。 見つかった場合はエントリの値を返し、見つからなかった場"
"合は NULL を返す。 (値は NULL の場合もあることに注意すること。名前が I<name> "
"のエントリに \\(aq=\\(aq 符号がない場合が該当する。)"

#. type: Plain text
#: build/C/man3/envz_add.3:102
msgid ""
"B<envz_merge>()  adds each entry in I<envz2> to I<*envz>, as if with "
"B<envz_add>().  If I<override> is true, then values in I<envz2> will "
"supersede those with the same name in I<*envz>, otherwise not."
msgstr ""
"B<envz_merge>()  は、 B<envz_add>()  と同じように I<envz2> の各エントリを "
"I<*envz> に追加する。 I<override> が真の場合、 I<envz2> の値で I<*envz> 内の"
"同じ名前をもつ値は上書きされる。 偽の場合は上書きされない。"

#. type: Plain text
#: build/C/man3/envz_add.3:109
msgid ""
"B<envz_remove>()  removes the entry for I<name> from (I<*envz>,\\ "
"I<*envz_len>)  if there was one."
msgstr ""
"B<envz_remove>()  は、名前が I<name> のエントリがあれば (I<*envz>,\\ "
"I<*envz_len>)  から削除する。"

#. type: Plain text
#: build/C/man3/envz_add.3:112
msgid "B<envz_strip>()  removes all entries with value NULL."
msgstr "B<envz_strip>()  は、値が NULL のエントリをすべて削除する。"

#. type: Plain text
#: build/C/man3/envz_add.3:118
msgid ""
"All envz functions that do memory allocation have a return type of "
"I<error_t>, and return 0 for success, and B<ENOMEM> if an allocation error "
"occurs."
msgstr ""
"メモリ割り当てを行う envz 関数群はすべて I<error_t> 型の返り値を持つ。 成功し"
"た場合は 0 を返し、割り当てエラーが発生した場合は B<ENOMEM> を返す。"

#. type: Plain text
#: build/C/man3/envz_add.3:126
#, no-wrap
msgid ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"
msgstr ""
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>envz.hE<gt>\n"

#. type: Plain text
#: build/C/man3/envz_add.3:132
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int i, e_len = 0;\n"
"    char *str;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[], char *envp[])\n"
"{\n"
"    int i, e_len = 0;\n"
"    char *str;\n"

#. type: Plain text
#: build/C/man3/envz_add.3:135
#, no-wrap
msgid ""
"    for (i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"
msgstr ""
"    for (i = 0; envp[i] != NULL; i++)\n"
"        e_len += strlen(envp[i]) + 1;\n"

#. type: Plain text
#: build/C/man3/envz_add.3:142
#, no-wrap
msgid ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    str = envz_entry(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    str = envz_get(*envp, e_len, \"HOME\");\n"
"    printf(\"%s\\en\", str);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/envz_add.3:145
msgid "B<argz_add>(3)"
msgstr "B<argz_add>(3)"

#. type: TH
#: build/C/man3/ftok.3:29
#, no-wrap
msgid "FTOK"
msgstr "FTOK"

#. type: TH
#: build/C/man3/ftok.3:29
#, no-wrap
msgid "2001-11-28"
msgstr "2001-11-28"

#. type: Plain text
#: build/C/man3/ftok.3:32
msgid ""
"ftok - convert a pathname and a project identifier to a System V IPC key"
msgstr "ftok - パス名とプロジェクト識別子を System V IPC キーに変換する"

#. type: Plain text
#: build/C/man3/ftok.3:36
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/ftok.3:39
msgid "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"
msgstr "B<key_t ftok(const char *>I<pathname>B<, int >I<proj_id>B<);>"

#. type: Plain text
#: build/C/man3/ftok.3:54
msgid ""
"The B<ftok>()  function uses the identity of the file named by the given "
"I<pathname> (which must refer to an existing, accessible file)  and the "
"least significant 8 bits of I<proj_id> (which must be nonzero) to generate a "
"I<key_t> type System V IPC key, suitable for use with B<msgget>(2), B<semget>"
"(2), or B<shmget>(2)."
msgstr ""
"B<ftok>()  関数は I<pathname> で与えられたファイル (存在し、アクセス可能でな"
"ければならない)  のファイル名の識別情報 (identity) と、 I<proj_id> (0 であっ"
"てはならない) の低位 8 ビットとを用いて、 I<key_t> 型の System V IPC キーを生"
"成する。 このキーは B<msgget>(2), B<semget>(2), B<shmget>(2)  などでの利用に"
"適している。"

#. type: Plain text
#: build/C/man3/ftok.3:61
msgid ""
"The resulting value is the same for all pathnames that name the same file, "
"when the same value of I<proj_id> is used.  The value returned should be "
"different when the (simultaneously existing) files or the project IDs differ."
msgstr ""
"同じファイルを示すあらゆるパス名と、同じ I<proj_id> に対しては、結果の値は等"
"しくなる。 ファイルが違ったり (この場合両者は同時に存在しているはず)、 "
"I<proj_id> が異なると、返り値も異なる。"

#. type: Plain text
#: build/C/man3/ftok.3:70
msgid ""
"On success, the generated I<key_t> value is returned.  On failure -1 is "
"returned, with I<errno> indicating the error as for the B<stat>(2)  system "
"call."
msgstr ""
"成功した場合は生成された I<key_t> の値が返される。 失敗すると -1 が返され、エ"
"ラーの内容が B<errno> に書き込まれる。この内容はシステムコール B<stat>(2)  の"
"ものと同じである。"

#. type: Plain text
#: build/C/man3/ftok.3:74
msgid "Under libc4 and libc5 (and under SunOS 4.x) the prototype was:"
msgstr ""
"libc4 と libc5 (および SunOS 4.x) では、 プロトタイプは以下のようになってい"
"る。"

#. type: Plain text
#: build/C/man3/ftok.3:77
msgid "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>"
msgstr "B<key_t ftok(char *>I<pathname>B<, char >I<proj_id>B<);>"

#. type: Plain text
#: build/C/man3/ftok.3:89
msgid ""
"Today I<proj_id> is an I<int>, but still only 8 bits are used.  Typical "
"usage has an ASCII character I<proj_id>, that is why the behavior is said to "
"be undefined when I<proj_id> is zero."
msgstr ""
"現在では I<proj_id> は I<int> だが、依然として 8 ビットしか用いられない。 通"
"常は ASCII キャラクタが I<proj_id> に用いられる。 I<proj_id> が 0 のときの振"
"る舞いが未定義になっているのは、これが理由である。"

#. type: Plain text
#: build/C/man3/ftok.3:101
msgid ""
"Of course no guarantee can be given that the resulting I<key_t> is unique.  "
"Typically, a best effort attempt combines the given I<proj_id> byte, the "
"lower 16 bits of the inode number, and the lower 8 bits of the device number "
"into a 32-bit result.  Collisions may easily happen, for example between "
"files on I</dev/hda1> and files on I</dev/sda1>."
msgstr ""
"もちろん I<key_t> が他と重ならないものであるかどうかは保証されない。 最善の場"
"合の組み合わせを考えても、 I<proj_id> の 1 バイト、i ノード番号の低位 16 ビッ"
"ト、および デバイス番号の低位 8 ビットなので、結果は 32 ビットに過ぎない。 例"
"えば I</dev/hda1> と I</dev/sda1> それぞれにあるファイルに対して、衝突は容易"
"に起こりうる。"

#. type: Plain text
#: build/C/man3/ftok.3:107
msgid "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<svipc>(7)"
msgstr "B<msgget>(2), B<semget>(2), B<shmget>(2), B<stat>(2), B<svipc>(7)"

#. type: TH
#: build/C/man3/longjmp.3:27
#, no-wrap
msgid "LONGJMP"
msgstr "LONGJMP"

#. type: TH
#: build/C/man3/longjmp.3:27
#, no-wrap
msgid "2009-01-13"
msgstr "2009-01-13"

#. type: Plain text
#: build/C/man3/longjmp.3:30
msgid "longjmp, siglongjmp - nonlocal jump to a saved stack context"
msgstr ""
"longjmp, siglongjmp - 保存されたスタックコンテキスト (stack context)  への非"
"局所的なジャンプ"

#. type: Plain text
#: build/C/man3/longjmp.3:33
#, no-wrap
msgid "B<#include E<lt>setjmp.hE<gt>>\n"
msgstr "B<#include E<lt>setjmp.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/longjmp.3:35
#, no-wrap
msgid "B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"
msgstr "B<void longjmp(jmp_buf >I<env>B<, int >I<val>B<);>\n"

#. type: Plain text
#: build/C/man3/longjmp.3:37
#, no-wrap
msgid "B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"
msgstr "B<void siglongjmp(sigjmp_buf >I<env>B<, int >I<val>B<);>\n"

#. type: Plain text
#: build/C/man3/longjmp.3:46
msgid ""
"B<siglongjmp>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_C_SOURCE"
msgstr ""
"B<siglongjmp>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man3/longjmp.3:70
msgid ""
"B<longjmp>()  and B<setjmp>(3)  are useful for dealing with errors and "
"interrupts encountered in a low-level subroutine of a program.  B<longjmp>"
"()  restores the environment saved by the last call of B<setjmp>(3)  with "
"the corresponding I<env> argument.  After B<longjmp>()  is completed, "
"program execution continues as if the corresponding call of B<setjmp>(3)  "
"had just returned the value I<val>.  B<longjmp>()  cannot cause 0 to be "
"returned.  If B<longjmp>()  is invoked with a second argument of 0, 1 will "
"be returned instead."
msgstr ""
"B<longjmp>()  と B<setjmp>(3)  は、プログラムの低レベルなサブルーチンにおい"
"て、 エラーや割り込みが発生した時の処理に便利である。 B<longjmp>()  は、"
"I<env> 引き数を指定して呼び出された最後の B<setjmp>(3)  によって保存された環"
"境を復元する。 B<longjmp>()  の完了後、プログラムの実行は、まるで対応する "
"B<setjmp>(3)  の呼び出しが値 I<val> で返って来たかように続行される。 "
"B<longjmp>()  は 0 を返すように指示することはできない。 二番目の引き数に 0 を"
"指定して B<longjmp>()  が呼ばれた場合は、代わりに 1 が返されることになる。"

#. type: Plain text
#: build/C/man3/longjmp.3:88
msgid ""
"B<siglongjmp>()  is similar to B<longjmp>()  except for the type of its "
"I<env> argument.  If, and only if, the B<sigsetjmp>(3)  call that set this "
"I<env> used a nonzero I<savesigs> flag, B<siglongjmp>()  also restores the "
"signal mask that was saved by B<sigsetjmp>(3)."
msgstr ""
"B<siglongjmp>()  は、引き数 I<env> の型が異なる点以外は、 B<longjmp>()  と同"
"様である。 I<env> を保存した B<sigsetjmp>(3)  が 0 以外の I<savesigs> フラグ"
"で呼び出されていた場合で、 かつ、その場合にのみ、 B<siglongjmp>(3)  は "
"B<sigsetjmp>(3)  より保存されていたシグナルマスクの復元を行う。"

#. type: Plain text
#: build/C/man3/longjmp.3:90
msgid "These functions never return."
msgstr "これらの関数が返ることはない。"

#. type: Plain text
#: build/C/man3/longjmp.3:95
msgid ""
"C89, C99, and POSIX.1-2001 specify B<longjmp>().  POSIX.1-2001 specifies "
"B<siglongjmp>()."
msgstr ""
"B<longjmp>()  は C89, C99, POSIX.1-2001 で規定されている。 B<siglongjmp>()  "
"は POSIX.1-2001 で規定されている。"

#. type: Plain text
#: build/C/man3/longjmp.3:105
msgid ""
"POSIX does not specify whether B<longjmp>()  will restore the signal context "
"(see B<setjmp>(3)  for some more details).  If you want to portably save and "
"restore signal masks, use B<sigsetjmp>(3)  and B<siglongjmp>()."
msgstr ""
"POSIX では、 B<longjmp>() がシグナルコンテキスト (signal context) を復元\n"
"するかどうか規定されていない (B<setjmp>(3) にも少し詳しい情報がある)。\n"
"移植性のある方法で、シグナルマスクを保存し復元させたい場合には、\n"
"B<sigsetjmp>(3) と B<siglongjmp>() を使うこと。"

#. type: Plain text
#: build/C/man3/longjmp.3:109
msgid ""
"The values of automatic variables are unspecified after a call to B<longjmp>"
"()  if they meet all the following criteria:"
msgstr ""
"以下の条件が全て成立する場合、 B<longjmp>()  の呼び出しが行われた後の自動変数"
"の値は未定義 (unspecified) となる。"

#. type: IP
#: build/C/man3/longjmp.3:109 build/C/man3/longjmp.3:113
#: build/C/man3/longjmp.3:119
#, no-wrap
msgid "\\(bu"
msgstr "\\(bu"

#. type: Plain text
#: build/C/man3/longjmp.3:113
msgid ""
"they are local to the function that made the corresponding B<setjmp>(3)  "
"call;"
msgstr ""
"その自動変数が、対応する B<setjmp>(3)  呼び出しを行った関数のローカル変数であ"
"る。"

#. type: Plain text
#: build/C/man3/longjmp.3:119
msgid ""
"their values are changed between the calls to B<setjmp>(3)  and B<longjmp>"
"(); and"
msgstr "自動変数の値が B<setjmp>(3)  と B<longjmp>()  の間で変更されている。"

#. type: Plain text
#: build/C/man3/longjmp.3:122
msgid "they are not declared as I<volatile>."
msgstr "I<volatile> として宣言されていない。"

#. type: Plain text
#: build/C/man3/longjmp.3:125
msgid "Analogous remarks apply for B<siglongjmp>()."
msgstr "同様の注意が B<siglongjmp>()  にもあてはまる。"

#. type: Plain text
#: build/C/man3/longjmp.3:132
msgid ""
"B<longjmp>()  and B<siglongjmp>()  make programs hard to understand and "
"maintain.  If possible an alternative should be used."
msgstr ""
"B<longjmp>()  や B<siglongjmp>()  を使うと、プログラムは理解しづらく、保守し"
"にくいものになる。 別の方法が可能なら、それを使うべきである。"

#. type: Plain text
#: build/C/man3/longjmp.3:135
msgid "B<setjmp>(3), B<sigsetjmp>(3)"
msgstr "B<setjmp>(3), B<sigsetjmp>(3)"

#. type: TH
#: build/C/man3/offsetof.3:28
#, no-wrap
msgid "OFFSETOF"
msgstr "OFFSETOF"

#. type: TH
#: build/C/man3/offsetof.3:28
#, no-wrap
msgid "2008-07-12"
msgstr "2008-07-12"

#. type: Plain text
#: build/C/man3/offsetof.3:31
msgid "offsetof - offset of a structure member"
msgstr "offsetof - 構造体のメンバーのオフセットを返す"

#. type: Plain text
#: build/C/man3/offsetof.3:34
#, no-wrap
msgid "B<#include E<lt>stddef.hE<gt>>\n"
msgstr "B<#include E<lt>stddef.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/offsetof.3:36
#, no-wrap
msgid "B<size_t offsetof(>I<type>B<, >I<member>B<);>\n"
msgstr "B<size_t offsetof(>I<type>B<, >I<member>B<);>\n"

#. type: Plain text
#: build/C/man3/offsetof.3:44
msgid ""
"The macro B<offsetof>()  returns the offset of the field I<member> from the "
"start of the structure I<type>."
msgstr ""
"B<offsetof>()  マクロは、フィールド I<member> の 構造体 I<type> の先頭からの"
"オフセットを返す。"

#. type: Plain text
#: build/C/man3/offsetof.3:51
msgid ""
"This macro is useful because the sizes of the fields that compose a "
"structure can vary across implementations, and compilers may insert "
"different numbers of padding bytes between fields.  Consequently, an "
"element's offset is not necessarily given by the sum of the sizes of the "
"previous elements."
msgstr ""
"このマクロが有用なのは、 構造体を構成するフィールドのサイズは実装によって変化"
"するし、 コンパイラによりフィールド間に挿入するパディングのバイト数も 違う可"
"能性があるからである。 その結果、あるエレメントのオフセットは必ずしもそれより"
"前の エレメントのサイズの合計とはならない。"

#. type: Plain text
#: build/C/man3/offsetof.3:56
msgid ""
"A compiler error will result if I<member> is not aligned to a byte boundary "
"(i.e., it is a bit field)."
msgstr ""
"I<member> がバイト境界に位置していない場合 (すなわち、ビットフィールドの場"
"合) には、 コンパイラでエラーが発生する。"

#. type: Plain text
#: build/C/man3/offsetof.3:63
msgid ""
"B<offsetof>()  returns the offset of the given I<member> within the given "
"I<type>, in units of bytes."
msgstr ""
"B<offsetof>()  は、指定された I<member> の指定された I<type> の中でのオフセッ"
"トを、バイト単位で返す。"

#. type: Plain text
#: build/C/man3/offsetof.3:65
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/offsetof.3:69
msgid ""
"On a Linux/i386 system, when compiled using the default B<gcc>(1)  options, "
"the program below produces the following output:"
msgstr ""
"Linux/i386 システムで、 B<gcc>(1)  のデフォルトオプションで コンパイルされた"
"場合、下記のプログラムは以下のような出力を返す。"

#. type: Plain text
#: build/C/man3/offsetof.3:75
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"offsets: i=0; c=4; d=8 a=16\n"
"sizeof(struct s)=16\n"
msgstr ""
"$B< ./a.out>\n"
"offsets: i=0; c=4; d=8 a=16\n"
"sizeof(struct s)=16\n"

#. type: Plain text
#: build/C/man3/offsetof.3:82
#, no-wrap
msgid ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>stddef.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/offsetof.3:92
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    struct s {\n"
"        int i;\n"
"        char c;\n"
"        double d;\n"
"        char a[];\n"
"    };\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    struct s {\n"
"        int i;\n"
"        char c;\n"
"        double d;\n"
"        char a[];\n"
"    };\n"

#. type: Plain text
#: build/C/man3/offsetof.3:94
#, no-wrap
msgid "    /* Output is compiler dependent */\n"
msgstr "    /* 出力はコンパイラ依存である */\n"

#. type: Plain text
#: build/C/man3/offsetof.3:101
#, no-wrap
msgid ""
"    printf(\"offsets: i=%ld; c=%ld; d=%ld a=%ld\\en\",\n"
"            (long) offsetof(struct s, i),\n"
"            (long) offsetof(struct s, c),\n"
"            (long) offsetof(struct s, d),\n"
"            (long) offsetof(struct s, a));\n"
"    printf(\"sizeof(struct s)=%ld\\en\", (long) sizeof(struct s));\n"
msgstr ""
"    printf(\"offsets: i=%ld; c=%ld; d=%ld a=%ld\\en\",\n"
"            (long) offsetof(struct s, i),\n"
"            (long) offsetof(struct s, c),\n"
"            (long) offsetof(struct s, d),\n"
"            (long) offsetof(struct s, a));\n"
"    printf(\"sizeof(struct s)=%ld\\en\", (long) sizeof(struct s));\n"

#. type: Plain text
#: build/C/man3/offsetof.3:104
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: TH
#: build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "INVOCATION_NAME"
msgstr "INVOCATION_NAME"

#. type: TH
#: build/C/man3/program_invocation_name.3:24
#, no-wrap
msgid "2006-04-29"
msgstr "2006-04-29"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:28
msgid ""
"program_invocation_name, program_invocation_short_name - obtain name used to "
"invoke calling program"
msgstr ""
"program_invocation_name, program_invocation_short_name - プログラムの起動に使"
"われた名前を取得する"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>         /* See feature_test_macros(7) */\n"
"B<#include E<lt>errno.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>         /* feature_test_macros(7) 参照 */\n"
"B<#include E<lt>errno.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:35
#, no-wrap
msgid ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"
msgstr ""
"B<extern char *>I<program_invocation_name>B<;>\n"
"B<extern char *>I<program_invocation_short_name>B<;>\n"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:46
msgid ""
"I<program_invocation_name> contains the name that was used to invoke the "
"calling program.  This is the same as the value of I<argv[0]> in I<main>(), "
"with the difference that the scope of I<program_invocation_name> is global."
msgstr ""
"I<program_invocation_name> は、呼び出し元プログラムの起動に使用された名前を保"
"持する。 内容は I<main>()  の I<argv[0]> の値と同じだが、 "
"I<program_invocation_name> の方はスコープがグローバルである点が異なる。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:53
msgid ""
"I<program_invocation_short_name> contains the basename component of name "
"that was used to invoke the calling program.  That is, it is the same value "
"as I<program_invocation_name>, with all text up to and including the final "
"slash (/), if any, removed."
msgstr ""
"I<program_invocation_short_name> は、呼び出し元プログラムの起動に使用された名"
"前の basename 部分を 保持する。つまり、この変数の内容は、最後のスラッシュ "
"(/) とそれより前の 部分がある場合、 I<program_invocation_name> からこの部分を"
"削除したものとなる。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:56
msgid ""
"These variables are automatically initialized by the glibc run-time startup "
"code."
msgstr ""
"これらの変数は glibc のランタイム・スタートアップ・コードで 自動的に初期化さ"
"れる。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:59
msgid ""
"These variables are GNU extensions, and should not be used in programs "
"intended to be portable."
msgstr ""
"これらの変数は GNU の拡張であり、 移植性が必要なプログラムでは使用すべきでな"
"い。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:63
msgid ""
"The Linux-specific I</proc/[number]/cmdline> file provides access to similar "
"information."
msgstr ""
"Linux 独自のファイル I</proc/[number]/cmdline> でも同様の情報を得ることができ"
"る。"

#. type: Plain text
#: build/C/man3/program_invocation_name.3:65
msgid "B<proc>(5)"
msgstr "B<proc>(5)"

#. type: TH
#: build/C/man3/queue.3:39
#, no-wrap
msgid "QUEUE"
msgstr "QUEUE"

#. type: TH
#: build/C/man3/queue.3:39
#, no-wrap
msgid "2007-12-28"
msgstr "2007-12-28"

#. type: Plain text
#: build/C/man3/queue.3:48
msgid ""
"LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
"LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
"TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
"CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - implementations "
"of lists, tail queues, and circular queues"
msgstr ""
"LIST_ENTRY, LIST_HEAD, LIST_INIT, LIST_INSERT_AFTER, LIST_INSERT_HEAD, "
"LIST_REMOVE, TAILQ_ENTRY, TAILQ_HEAD, TAILQ_INIT, TAILQ_INSERT_AFTER, "
"TAILQ_INSERT_HEAD, TAILQ_INSERT_TAIL, TAILQ_REMOVE, CIRCLEQ_ENTRY, "
"CIRCLEQ_HEAD, CIRCLEQ_INIT, CIRCLEQ_INSERT_AFTER, CIRCLEQ_INSERT_BEFORE, "
"CIRCLEQ_INSERT_HEAD, CIRCLEQ_INSERT_TAIL, CIRCLEQ_REMOVE - リスト・テール "
"(tail) キュー・循環キューの実装"

#. type: Plain text
#: build/C/man3/queue.3:51
#, no-wrap
msgid "B<#include E<lt>sys/queue.hE<gt>>\n"
msgstr "B<#include E<lt>sys/queue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/queue.3:60
#, no-wrap
msgid ""
"B<LIST_ENTRY(>I<TYPE>B<);>\n"
"B<LIST_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
"B<LIST_INSERT_AFTER(LIST_ENTRY *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
"B<LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
"B<LIST_REMOVE(TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
msgstr ""
"B<LIST_ENTRY(>I<TYPE>B<);>\n"
"B<LIST_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<LIST_INIT(LIST_HEAD *>I<head>B<);>\n"
"B<LIST_INSERT_AFTER(LIST_ENTRY *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
"B<LIST_INSERT_HEAD(LIST_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"
"B<LIST_REMOVE(TYPE *>I<elm>B<, LIST_ENTRY >I<NAME>B<);>\n"

#. type: Plain text
#: build/C/man3/queue.3:71
#, no-wrap
msgid ""
"B<TAILQ_ENTRY(>I<TYPE>B<);>\n"
"B<TAILQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
"B<TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
msgstr ""
"B<TAILQ_ENTRY(>I<TYPE>B<);>\n"
"B<TAILQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<TAILQ_INIT(TAILQ_HEAD *>I<head>B<);>\n"
"B<TAILQ_INSERT_AFTER(TAILQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_INSERT_HEAD(TAILQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_INSERT_TAIL(TAILQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"
"B<TAILQ_REMOVE(TAILQ_HEAD *>I<head>B<, TYPE *>I<elm>B<, TAILQ_ENTRY >I<NAME>B<);>\n"

#. type: Plain text
#: build/C/man3/queue.3:85
#, no-wrap
msgid ""
"B<CIRCLEQ_ENTRY(>I<TYPE>B<);>\n"
"B<CIRCLEQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
"B<CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
msgstr ""
"B<CIRCLEQ_ENTRY(>I<TYPE>B<);>\n"
"B<CIRCLEQ_HEAD(>I<HEADNAME>B<, >I<TYPE>B<);>\n"
"B<CIRCLEQ_INIT(CIRCLEQ_HEAD *>I<head>B<);>\n"
"B<CIRCLEQ_INSERT_AFTER(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_BEFORE(CIRCLEQ_HEAD *>I<head>B<, TYPE *>I<listelm>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_HEAD(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_INSERT_TAIL(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"
"B<CIRCLEQ_REMOVE(CIRCLEQ_HEAD *>I<head>B<, >\n"
"B<                TYPE *>I<elm>B<, CIRCLEQ_ENTRY >I<NAME>B<);>\n"

#. type: Plain text
#: build/C/man3/queue.3:90
msgid ""
"These macros define and operate on three types of data structures: lists, "
"tail queues, and circular queues.  All three structures support the "
"following functionality:"
msgstr ""
"これらのマクロは、次の 3 つのデータ構造を定義して操作する: リスト・テール"
"キュー・循環キュー。 3 つのデータ構造すべてにおいて以下の機能がサポートされて"
"いる:"

#. type: Plain text
#: build/C/man3/queue.3:95
msgid "Insertion of a new entry at the head of the list."
msgstr "新たなエントリをリストの先頭に挿入する。"

#. type: Plain text
#: build/C/man3/queue.3:97
msgid "Insertion of a new entry after any element in the list."
msgstr "新たなエントリをリストのどの要素よりも後に挿入する。"

#. type: Plain text
#: build/C/man3/queue.3:99
msgid "Removal of any entry in the list."
msgstr "リストの任意のエントリを削除する。"

#. type: Plain text
#: build/C/man3/queue.3:101
msgid "Forward traversal through the list."
msgstr "リストを順方向に辿る。"

#. type: Plain text
#: build/C/man3/queue.3:106
msgid ""
"Lists are the simplest of the three data structures and support only the "
"above functionality."
msgstr ""
"リストは 3 つのデータ構造の中で最も単純であり、 上記の機能のみをサポートす"
"る。"

#. type: Plain text
#: build/C/man3/queue.3:108
msgid "Tail queues add the following functionality:"
msgstr "テールキューは以下の機能を追加する:"

#. type: Plain text
#: build/C/man3/queue.3:111 build/C/man3/queue.3:133
msgid "Entries can be added at the end of a list."
msgstr "エントリをリストの最後に追加できる。"

#. type: Plain text
#: build/C/man3/queue.3:114 build/C/man3/queue.3:141
msgid "However:"
msgstr "ただし:"

#. type: IP
#: build/C/man3/queue.3:117 build/C/man3/queue.3:144
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man3/queue.3:119 build/C/man3/queue.3:146
msgid "All list insertions and removals must specify the head of the list."
msgstr "全てのリスト挿入と削除において、リストの先頭を指定しなければならない。"

#. type: IP
#: build/C/man3/queue.3:119 build/C/man3/queue.3:146
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man3/queue.3:121 build/C/man3/queue.3:148
msgid "Each head entry requires two pointers rather than one."
msgstr "各先頭エントリは 1 つではなく 2 つのポインタを必要とする。"

#. type: IP
#: build/C/man3/queue.3:121 build/C/man3/queue.3:148
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man3/queue.3:124
msgid ""
"Code size is about 15% greater and operations run about 20% slower than "
"lists."
msgstr "リストと比べて、コードサイズは 15% 大きくなり、操作は 20% 遅くなる。"

#. type: Plain text
#: build/C/man3/queue.3:128
msgid "Circular queues add the following functionality:"
msgstr "循環キューは以下の機能を追加する:"

#. type: Plain text
#: build/C/man3/queue.3:135
msgid "Entries can be added before another entry."
msgstr "エントリを他のエントリの前に追加できる。"

#. type: Plain text
#: build/C/man3/queue.3:137
msgid "They may be traversed backward, from tail to head."
msgstr "逆方向に末尾から先頭へ辿ることができる。"

#. type: Plain text
#: build/C/man3/queue.3:150
msgid "The termination condition for traversal is more complex."
msgstr "辿る際の終了条件がより複雑である。"

#. type: IP
#: build/C/man3/queue.3:150
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man3/queue.3:153
msgid ""
"Code size is about 40% greater and operations run about 45% slower than "
"lists."
msgstr "リストと比べて、コードサイズは 40% 大きくなり、操作は 45% 遅くなる。"

#. type: Plain text
#: build/C/man3/queue.3:176
msgid ""
"In the macro definitions, I<TYPE> is the name of a user-defined structure, "
"that must contain a field of type B<LIST_ENTRY>, B<TAILQ_ENTRY>, or "
"B<CIRCLEQ_ENTRY>, named I<NAME>.  The argument I<HEADNAME> is the name of a "
"user-defined structure that must be declared using the macros B<LIST_HEAD>, "
"B<TAILQ_HEAD>, or B<CIRCLEQ_HEAD>.  See the examples below for further "
"explanation of how these macros are used."
msgstr ""
"マクロ定義において I<TYPE> はユーザ定義構造体の名前であり、 B<LIST_ENTRY>, "
"B<TAILQ_ENTRY>, B<CIRCLEQ_ENTRY> の何れか型のフィールドと 指定された I<NAME> "
"を含まなければならない。 引き数 I<HEADNAME> はユーザ定義構造体の名前であり、 "
"マクロ B<LIST_HEAD>, B<TAILQ_HEAD>, B<CIRCLEQ_HEAD> を用いて宣言されなければ"
"ならない。 これらのマクロがどのように使われるかについての更なる説明は、 以下"
"の例を参照すること。"

#. type: SS
#: build/C/man3/queue.3:176
#, no-wrap
msgid "Lists"
msgstr "リスト"

#. type: Plain text
#: build/C/man3/queue.3:189
msgid ""
"A list is headed by a structure defined by the B<LIST_HEAD> macro.  This "
"structure contains a single pointer to the first element on the list.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the list.  New elements can be added to the list after an "
"existing element or at the head of the list.  A B<LIST_HEAD> structure is "
"declared as follows:"
msgstr ""
"リストの先頭には、 B<LIST_HEAD> マクロで定義される構造体が置かれる。 この構造"
"体はリストの最初の要素へのポインタを 1 つ含む。 要素は 2 重にリンクされてお"
"り、 任意の要素はリストを辿らずに削除できる。 新しい要素は既存の要素の後また"
"はリストの先頭に追加できる。 B<LIST_HEAD> 構造体は以下のように宣言されている:"

#. type: Plain text
#: build/C/man3/queue.3:193
#, no-wrap
msgid "LIST_HEAD(HEADNAME, TYPE) head;\n"
msgstr "LIST_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/queue.3:202
msgid ""
"where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> is "
"the type of the elements to be linked into the list.  A pointer to the head "
"of the list can later be declared as:"
msgstr ""
"ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> はリンク内でリン"
"クされる要素の型である。 リストの先頭へのポインタは、その後で次のように宣言さ"
"れる:"

#. type: Plain text
#: build/C/man3/queue.3:206 build/C/man3/queue.3:299 build/C/man3/queue.3:401
#, no-wrap
msgid "struct HEADNAME *headp;\n"
msgstr "struct HEADNAME *headp;\n"

#. type: Plain text
#: build/C/man3/queue.3:214 build/C/man3/queue.3:307 build/C/man3/queue.3:409
msgid "(The names I<head> and I<headp> are user selectable.)"
msgstr "(名前 I<head> と I<headp> はユーザが選択できる。)"

#. type: Plain text
#: build/C/man3/queue.3:219
msgid ""
"The macro B<LIST_ENTRY> declares a structure that connects the elements in "
"the list."
msgstr "マクロ B<LIST_ENTRY> はリストの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/queue.3:224
msgid "The macro B<LIST_INIT> initializes the list referenced by I<head>."
msgstr "マクロ B<LIST_INIT> は I<head> で参照されるリストを初期化する。"

#. type: Plain text
#: build/C/man3/queue.3:230
msgid ""
"The macro B<LIST_INSERT_HEAD> inserts the new element I<elm> at the head of "
"the list."
msgstr ""
"マクロ B<LIST_INSERT_HEAD> は新たな要素 I<elm> をリストの先頭に挿入する。"

#. type: Plain text
#: build/C/man3/queue.3:237
msgid ""
"The macro B<LIST_INSERT_AFTER> inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<LIST_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿入"
"する。"

#. type: Plain text
#: build/C/man3/queue.3:243
msgid "The macro B<LIST_REMOVE> removes the element I<elm> from the list."
msgstr "マクロ B<LIST_REMOVE> は要素 I<elm> をリストから削除する。"

#. type: SS
#: build/C/man3/queue.3:243
#, no-wrap
msgid "List example"
msgstr "リストの例"

#. type: Plain text
#: build/C/man3/queue.3:252
#, no-wrap
msgid ""
"LIST_HEAD(listhead, entry) head;\n"
"struct listhead *headp;                 /* List head. */\n"
"struct entry {\n"
"    ...\n"
"    LIST_ENTRY(entry) entries;          /* List. */\n"
"    ...\n"
"} *n1, *n2, *np;\n"
msgstr ""
"LIST_HEAD(listhead, entry) head;\n"
"struct listhead *headp;                 /* リストの先頭。*/\n"
"struct entry {\n"
"    ...\n"
"    LIST_ENTRY(entry) entries;          /* リスト。 */\n"
"    ...\n"
"} *n1, *n2, *np;\n"

#. type: Plain text
#: build/C/man3/queue.3:254
#, no-wrap
msgid "LIST_INIT(&head);                       /* Initialize the list. */\n"
msgstr "LIST_INIT(&head);                       /* リストを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/queue.3:257
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"LIST_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:263
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"LIST_INSERT_AFTER(n1, n2, entries);\n"
"                                        /* Forward traversal. */\n"
"for (np = head.lh_first; np != NULL; np = np-E<gt>entries.le_next)\n"
"    np-E<gt> ...\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"LIST_INSERT_AFTER(n1, n2, entries);\n"
"                                        /* 順方向に辿る。*/\n"
"for (np = head.lh_first; np != NULL; np = np-E<gt>entries.le_next)\n"
"    np-E<gt> ...\n"

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=1506
#. type: Plain text
#: build/C/man3/queue.3:267
#, no-wrap
msgid ""
"while (head.lh_first != NULL)           /* Delete. */\n"
"    LIST_REMOVE(head.lh_first, entries);\n"
msgstr ""
"while (head.lh_first != NULL)           /* 削除する。*/\n"
"    LIST_REMOVE(head.lh_first, entries);\n"

#. type: SS
#: build/C/man3/queue.3:268
#, no-wrap
msgid "Tail queues"
msgstr "テールキュー"

#. type: Plain text
#: build/C/man3/queue.3:282
msgid ""
"A tail queue is headed by a structure defined by the B<TAILQ_HEAD> macro.  "
"This structure contains a pair of pointers, one to the first element in the "
"tail queue and the other to the last element in the tail queue.  The "
"elements are doubly linked so that an arbitrary element can be removed "
"without traversing the tail queue.  New elements can be added to the tail "
"queue after an existing element, at the head of the tail queue, or at the "
"end of the tail queue.  A B<TAILQ_HEAD> structure is declared as follows:"
msgstr ""
"テールキューの先頭には B<TAILQ_HEAD> マクロで定義される構造体が置かれる。 こ"
"の構造体は 1 組のポインタを含んでいる。 1 つはテールキューの最初の要素へのポ"
"インタであり、 もう 1 つはテールキューの最後の要素へのポインタである。 要素"
"は 2 重にリンクされており、 任意の要素はテールキューを辿らずに削除できる。 新"
"しい要素は既存の要素の後またはテールキューの先頭または末尾に追加できる。 "
"B<TAILQ_HEAD> 構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/queue.3:286
#, no-wrap
msgid "TAILQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "TAILQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/queue.3:295
msgid ""
"where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> is "
"the type of the elements to be linked into the tail queue.  A pointer to the "
"head of the tail queue can later be declared as:"
msgstr ""
"ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> はテールキュー内"
"でリンクされる要素の型である。 テールキューの先頭へのポインタは、その後で次の"
"ように宣言される:"

#. type: Plain text
#: build/C/man3/queue.3:312
msgid ""
"The macro B<TAILQ_ENTRY> declares a structure that connects the elements in "
"the tail queue."
msgstr "マクロ B<TAILQ_ENTRY> はテールキューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/queue.3:317
msgid ""
"The macro B<TAILQ_INIT> initializes the tail queue referenced by I<head>."
msgstr "マクロ B<TAILQ_INIT> は I<head> で参照されるテールキューを初期化する。"

#. type: Plain text
#: build/C/man3/queue.3:323
msgid ""
"The macro B<TAILQ_INSERT_HEAD> inserts the new element I<elm> at the head of "
"the tail queue."
msgstr ""
"マクロ B<TAILQ_INSERT_HEAD> は新たな要素 I<elm> をテールキューの先頭に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/queue.3:329
msgid ""
"The macro B<TAILQ_INSERT_TAIL> inserts the new element I<elm> at the end of "
"the tail queue."
msgstr ""
"マクロ B<TAILQ_INSERT_TAIL> は新たな要素 I<elm> をテールキューの末尾に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/queue.3:336
msgid ""
"The macro B<TAILQ_INSERT_AFTER> inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<TAILQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿入"
"する。"

#. type: Plain text
#: build/C/man3/queue.3:342
msgid ""
"The macro B<TAILQ_REMOVE> removes the element I<elm> from the tail queue."
msgstr "マクロ B<TAILQ_REMOVE> は要素 I<elm> をテールキューから削除する。"

#. type: SS
#: build/C/man3/queue.3:342
#, no-wrap
msgid "Tail queue example"
msgstr "テールキューの例"

#. type: Plain text
#: build/C/man3/queue.3:351
#, no-wrap
msgid ""
"TAILQ_HEAD(tailhead, entry) head;\n"
"struct tailhead *headp;                 /* Tail queue head. */\n"
"struct entry {\n"
"    ...\n"
"    TAILQ_ENTRY(entry) entries;         /* Tail queue. */\n"
"    ...\n"
"} *n1, *n2, *np;\n"
msgstr ""
"TAILQ_HEAD(tailhead, entry) head;\n"
"struct tailhead *headp;                 /* テールキューの先頭。*/\n"
"struct entry {\n"
"    ...\n"
"    TAILQ_ENTRY(entry) entries;         /* テールキュー。*/\n"
"    ...\n"
"} *n1, *n2, *np;\n"

#. type: Plain text
#: build/C/man3/queue.3:353
#, no-wrap
msgid "TAILQ_INIT(&head);                      /* Initialize the queue. */\n"
msgstr "TAILQ_INIT(&head);                      /* キューを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/queue.3:356
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));      /* Insert at the head. */\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"TAILQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:359
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */\n"
"TAILQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/\n"
"TAILQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:368
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));      /* Insert after. */\n"
"TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
"                                        /* Forward traversal. */\n"
"for (np = head.tqh_first; np != NULL; np = np-E<gt>entries.tqe_next)\n"
"    np-E<gt> ...\n"
"                                        /* Delete. */\n"
"while (head.tqh_first != NULL)\n"
"    TAILQ_REMOVE(&head, head.tqh_first, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"TAILQ_INSERT_AFTER(&head, n1, n2, entries);\n"
"                                        /* 順方向に辿る。*/\n"
"for (np = head.tqh_first; np != NULL; np = np-E<gt>entries.tqe_next)\n"
"    np-E<gt> ...\n"
"                                        /* 削除する。*/\n"
"while (head.tqh_first != NULL)\n"
"    TAILQ_REMOVE(&head, head.tqh_first, entries);\n"

#. type: SS
#: build/C/man3/queue.3:369
#, no-wrap
msgid "Circular queues"
msgstr "循環キュー"

#. type: Plain text
#: build/C/man3/queue.3:384
msgid ""
"A circular queue is headed by a structure defined by the B<CIRCLEQ_HEAD> "
"macro.  This structure contains a pair of pointers, one to the first element "
"in the circular queue and the other to the last element in the circular "
"queue.  The elements are doubly linked so that an arbitrary element can be "
"removed without traversing the queue.  New elements can be added to the "
"queue after an existing element, before an existing element, at the head of "
"the queue, or at the end of the queue.  A B<CIRCLEQ_HEAD> structure is "
"declared as follows:"
msgstr ""
"循環キューの先頭には B<CIRCLEQ_HEAD> マクロで定義される構造体が置かれる。 こ"
"の構造体は 1 組のポインタを含んでいる。 1 つは循環キューの最初の要素へのポイ"
"ンタであり、 もう 1 つは循環キューの最後の要素へのポインタである。 要素は 2 "
"重にリンクされており、 任意の要素はキューを辿らずに削除できる。 新しい要素"
"は、既存の要素の後または前、またはキューの先頭または末尾に追加できる。 A "
"B<CIRCLEQ_HEAD> 構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/queue.3:388
#, no-wrap
msgid "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"
msgstr "CIRCLEQ_HEAD(HEADNAME, TYPE) head;\n"

#. type: Plain text
#: build/C/man3/queue.3:397
msgid ""
"where I<HEADNAME> is the name of the structure to be defined, and I<TYPE> is "
"the type of the elements to be linked into the circular queue.  A pointer to "
"the head of the circular queue can later be declared as:"
msgstr ""
"ここで I<HEADNAME> は定義される構造体の名前であり、 I<TYPE> は循環キュー内で"
"リンクされる要素の型である。 循環キューの先頭へのポインタは、その後で次のよう"
"に宣言される:"

#. type: Plain text
#: build/C/man3/queue.3:414
msgid ""
"The macro B<CIRCLEQ_ENTRY> declares a structure that connects the elements "
"in the circular queue."
msgstr "マクロ B<CIRCLEQ_ENTRY> は循環キューの要素を接続する構造体を宣言する。"

#. type: Plain text
#: build/C/man3/queue.3:419
msgid ""
"The macro B<CIRCLEQ_INIT> initializes the circular queue referenced by "
"I<head>."
msgstr "マクロ B<CIRCLEQ_INIT> は I<head> で参照される循環キューを初期化する。"

#. type: Plain text
#: build/C/man3/queue.3:425
msgid ""
"The macro B<CIRCLEQ_INSERT_HEAD> inserts the new element I<elm> at the head "
"of the circular queue."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_HEAD> は新たな要素 I<elm> を循環キューの先頭に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/queue.3:431
msgid ""
"The macro B<CIRCLEQ_INSERT_TAIL> inserts the new element I<elm> at the end "
"of the circular queue."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_TAIL> は新たな要素 I<elm> を循環キューの末尾に挿入す"
"る。"

#. type: Plain text
#: build/C/man3/queue.3:438
msgid ""
"The macro B<CIRCLEQ_INSERT_AFTER> inserts the new element I<elm> after the "
"element I<listelm>."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の後に挿"
"入する。"

#. type: Plain text
#: build/C/man3/queue.3:445
msgid ""
"The macro B<CIRCLEQ_INSERT_BEFORE> inserts the new element I<elm> before the "
"element I<listelm>."
msgstr ""
"マクロ B<CIRCLEQ_INSERT_AFTER> は新たな要素 I<elm> を要素 I<listelm> の前に挿"
"入する。"

#. type: Plain text
#: build/C/man3/queue.3:451
msgid ""
"The macro B<CIRCLEQ_REMOVE> removes the element I<elm> from the circular "
"queue."
msgstr "マクロ B<CIRCLEQ_REMOVE> は要素 I<elm> を循環キューから削除する。"

#. type: SS
#: build/C/man3/queue.3:451
#, no-wrap
msgid "Circular queue example"
msgstr "循環キューの例"

#. type: Plain text
#: build/C/man3/queue.3:460
#, no-wrap
msgid ""
"CIRCLEQ_HEAD(circleq, entry) head;\n"
"struct circleq *headp;              /* Circular queue head. */\n"
"struct entry {\n"
"    ...\n"
"    CIRCLEQ_ENTRY(entry) entries;   /* Circular queue. */\n"
"    ...\n"
"} *n1, *n2, *np;\n"
msgstr ""
"CIRCLEQ_HEAD(circleq, entry) head;\n"
"struct circleq *headp;                  /* 循環キューの先頭。*/\n"
"struct entry {\n"
"    ...\n"
"    CIRCLEQ_ENTRY(entry) entries;       /* 循環キュー。*/\n"
"    ...\n"
"} *n1, *n2, *np;\n"

#. type: Plain text
#: build/C/man3/queue.3:462
#, no-wrap
msgid "CIRCLEQ_INIT(&head);                /* Initialize the circular queue. */\n"
msgstr "CIRCLEQ_INIT(&head);                    /* 循環キューを初期化する。*/\n"

#. type: Plain text
#: build/C/man3/queue.3:465
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));  /* Insert at the head. */\n"
"CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 先頭に挿入する。*/\n"
"CIRCLEQ_INSERT_HEAD(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:468
#, no-wrap
msgid ""
"n1 = malloc(sizeof(struct entry));  /* Insert at the tail. */\n"
"CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"
msgstr ""
"n1 = malloc(sizeof(struct entry));      /* 末尾に挿入する。*/\n"
"CIRCLEQ_INSERT_TAIL(&head, n1, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:471
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));  /* Insert after. */\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 後ろに挿入する。*/\n"
"CIRCLEQ_INSERT_AFTER(&head, n1, n2, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:484
#, no-wrap
msgid ""
"n2 = malloc(sizeof(struct entry));  /* Insert before. */\n"
"CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n"
"                                    /* Forward traversal. */\n"
"for (np = head.cqh_first; np != (void *)&head;\n"
"        np = np-E<gt>entries.cqe_next)\n"
"    np-E<gt> ...\n"
"                                    /* Reverse traversal. */\n"
"for (np = head.cqh_last; np != (void *)&head; np = np-E<gt>entries.cqe_prev)\n"
"    np-E<gt> ...\n"
"                                    /* Delete. */\n"
"while (head.cqh_first != (void *)&head)\n"
"    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"
msgstr ""
"n2 = malloc(sizeof(struct entry));      /* 前に挿入する。*/\n"
"CIRCLEQ_INSERT_BEFORE(&head, n1, n2, entries);\n"
"                                        /* 順方向に辿る。*/\n"
"for (np = head.cqh_first; np != (void *)&head; np = np-E<gt>entries.cqe_next)\n"
"    np-E<gt> ...\n"
"                                        /* 逆方向に辿る。*/\n"
"for (np = head.cqh_last; np != (void *)&head; np = np-E<gt>entries.cqe_prev)\n"
"    np-E<gt> ...\n"
"                                        /* 削除する。*/\n"
"while (head.cqh_first != (void *)&head)\n"
"    CIRCLEQ_REMOVE(&head, head.cqh_first, entries);\n"

#. type: Plain text
#: build/C/man3/queue.3:491
msgid ""
"Not in POSIX.1-2001.  Present on the BSDs.  The queue functions first "
"appeared in 4.4BSD."
msgstr ""
"POSIX.1-2001 にはない。 BSD 系に存在する。 queue 関数は 4.4BSD で初めて登場し"
"た。"

#. type: TH
#: build/C/man3/realpath.3:28
#, no-wrap
msgid "REALPATH"
msgstr "REALPATH"

#. type: TH
#: build/C/man3/realpath.3:28
#, no-wrap
msgid "2013-03-15"
msgstr "2013-03-15"

#. type: Plain text
#: build/C/man3/realpath.3:31
msgid "realpath - return the canonicalized absolute pathname"
msgstr "realpath - 正規化された絶対パス名を返す"

#. type: Plain text
#: build/C/man3/realpath.3:35
#, no-wrap
msgid ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"
msgstr ""
"B<#include E<lt>limits.hE<gt>>\n"
"B<#include E<lt>stdlib.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/realpath.3:37
#, no-wrap
msgid "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"
msgstr "B<char *realpath(const char *>I<path>B<, char *>I<resolved_path>B<);>\n"

#. type: Plain text
#: build/C/man3/realpath.3:45
msgid "B<realpath>():"
msgstr "B<realpath>():"

#. type: Plain text
#: build/C/man3/realpath.3:49
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/realpath.3:71
msgid ""
"B<realpath>()  expands all symbolic links and resolves references to I</./>, "
"I</../> and extra \\(aq/\\(aq characters in the null-terminated string named "
"by I<path> to produce a canonicalized absolute pathname.  The resulting "
"pathname is stored as a null-terminated string, up to a maximum of "
"B<PATH_MAX> bytes, in the buffer pointed to by I<resolved_path>.  The "
"resulting path will have no symbolic link, I</./> or I</../> components."
msgstr ""
"B<realpath>()  は I<path> として与えられた NULL 終端された文字列中の すべての"
"シンボリックリンクを展開し、 I</./>, I</../> による参照や余分な \\(aq/\\(aq "
"を解決して、正規化された絶対パス名を生成する。 得られた絶対パス名は、最大で "
"B<PATH_MAX> バイトの NULL 終端された文字列として、 I<resolved_path> により参"
"照されるバッファに格納される。 結果として返るパスの中には、シンボリックリンク"
"や I</./>, I</../> といった要素は含まれない。"

#.  Even if we use resolved_path == NULL, then realpath() will still
#.  return ENAMETOOLONG if the resolved pathname would exceed PATH_MAX
#.  bytes -- MTK, Dec 04
#.  .SH HISTORY
#.  The
#.  .BR realpath ()
#.  function first appeared in 4.4BSD, contributed by Jan-Simon Pendry.
#. type: Plain text
#: build/C/man3/realpath.3:91
msgid ""
"If I<resolved_path> is specified as NULL, then B<realpath>()  uses B<malloc>"
"(3)  to allocate a buffer of up to B<PATH_MAX> bytes to hold the resolved "
"pathname, and returns a pointer to this buffer.  The caller should "
"deallocate this buffer using B<free>(3)."
msgstr ""
"I<resolved_path> に NULL が指定されると、 B<realpath>()  は B<malloc>(3)  を"
"使って解決したパス名を保持するためのバッファを 最大で B<PATH_MAX> バイトまで"
"割り当て、このバッファへのポインタを返す。 呼び出し元は、 B<free>(3)  を使っ"
"てこのバッファを解放すべきである。"

#. type: Plain text
#: build/C/man3/realpath.3:96
msgid ""
"If there is no error, B<realpath>()  returns a pointer to the "
"I<resolved_path>."
msgstr ""
"エラーがなかった場合、 B<realpath>()  は I<resolved_path> へのポインターを返"
"す。"

#. type: Plain text
#: build/C/man3/realpath.3:103
msgid ""
"Otherwise, it returns a NULL pointer, the contents of the array "
"I<resolved_path> are undefined, and I<errno> is set to indicate the error."
msgstr ""
"それ以外の場合は、ヌル (NULL) ポインターが返り、配列 I<resolved_path> の内容"
"は不定となり、 I<errno> にエラーの内容を示す値がセットされる。"

#. type: SH
#: build/C/man3/realpath.3:103
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/realpath.3:104
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man3/realpath.3:107
msgid ""
"Read or search permission was denied for a component of the path prefix."
msgstr ""
"パスのディレクトリ部分に、読み出し許可または検索許可が与えられていない。"

#. type: TP
#: build/C/man3/realpath.3:107
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#.  (In libc5 this would just cause a segfault.)
#. type: Plain text
#: build/C/man3/realpath.3:116
msgid ""
"I<path> is NULL.  (In glibc versions before 2.3, this error is also returned "
"if I<resolved_path> is NULL.)"
msgstr ""
"I<path> が NULL である。 (バージョン 2.3 より前の glibc では、 "
"I<resolved_path> が NULL の場合にもこのエラーが返される。)"

#. type: TP
#: build/C/man3/realpath.3:116
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man3/realpath.3:119
msgid "An I/O error occurred while reading from the file system."
msgstr "ファイルシステムを読むときに、I/Oエラーが起こった。"

#. type: TP
#: build/C/man3/realpath.3:119
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man3/realpath.3:122
msgid "Too many symbolic links were encountered in translating the pathname."
msgstr "パス名の変換にあたり、解決すべきシンボリック・リンクの数が多過ぎた。"

#. type: TP
#: build/C/man3/realpath.3:122
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/realpath.3:129
msgid ""
"A component of a pathname exceeded B<NAME_MAX> characters, or an entire "
"pathname exceeded B<PATH_MAX> characters."
msgstr ""
"パス名の一要素の文字数が B<NAME_MAX> を越えている、またはパス名全体の文字数"
"が B<PATH_MAX> を越えている。"

#. type: TP
#: build/C/man3/realpath.3:129
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/realpath.3:132
msgid "The named file does not exist."
msgstr "指定されたファイルが存在しない。"

#. type: TP
#: build/C/man3/realpath.3:132
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man3/realpath.3:135
msgid "A component of the path prefix is not a directory."
msgstr "パスのディレクトリ要素が、ディレクトリでない。"

#. type: Plain text
#: build/C/man3/realpath.3:137
msgid "On Linux, this function appeared in libc 4.5.21."
msgstr "Linux では、この関数が登場したのは libc 4.5.21 である。"

#. type: Plain text
#: build/C/man3/realpath.3:139
msgid "4.4BSD, POSIX.1-2001."
msgstr "4.4BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man3/realpath.3:144
msgid ""
"POSIX.1-2001 says that the behavior if I<resolved_path> is NULL is "
"implementation-defined.  POSIX.1-2008 specifies the behavior described in "
"this page."
msgstr ""
"POSIX.1-2001 では I<resolved_path> が NULL の場合の動作は実装に依存するとして"
"いる。 POSIX.1-2008 では、このマニュアルページに書かれている動作が規定されて"
"いる。"

#. type: Plain text
#: build/C/man3/realpath.3:156
msgid ""
"In 4.4BSD and Solaris, the limit on the pathname length is B<MAXPATHLEN> "
"(found in I<E<lt>sys/param.hE<gt>>).  SUSv2 prescribes B<PATH_MAX> and "
"B<NAME_MAX>, as found in I<E<lt>limits.hE<gt>> or provided by the B<pathconf>"
"(3)  function.  A typical source fragment would be"
msgstr ""
"4.4BSD と Solaris では、パス名の長さの上限は (I<E<lt>sys/param.hE<gt>> の中に"
"ある)  B<MAXPATHLEN> である。SUSv2 では B<PATH_MAX> と B<NAME_MAX> が規定され"
"ており、 これらは I<E<lt>limits.hE<gt>> で定義されているか、 B<pathconf>(3)  "
"関数から得られる。以下のようなソースコードになっていることが多い。"

#. type: Plain text
#: build/C/man3/realpath.3:166
#, no-wrap
msgid ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"    path_max = 4096;\n"
"#endif\n"
msgstr ""
"#ifdef PATH_MAX\n"
"  path_max = PATH_MAX;\n"
"#else\n"
"  path_max = pathconf(path, _PC_PATH_MAX);\n"
"  if (path_max E<lt>= 0)\n"
"\t path_max = 4096;\n"
"#endif\n"

#. type: Plain text
#: build/C/man3/realpath.3:170
msgid "(But see the BUGS section.)"
msgstr "(バグの章も参照のこと。)"

#.      2012-05-05, According to Casper Dik, the statement about
#.      Solaris was not true at least as far back as 1997, and
#.      may never have been true.
#.  The 4.4BSD, Linux and SUSv2 versions always return an absolute
#.  pathname.
#.  Solaris may return a relative pathname when the
#.  .I path
#.  argument is relative.
#. type: Plain text
#: build/C/man3/realpath.3:184
msgid ""
"The prototype of B<realpath>()  is given in I<E<lt>unistd.hE<gt>> in libc4 "
"and libc5, but in I<E<lt>stdlib.hE<gt>> everywhere else."
msgstr ""
"B<realpath>() のプロトタイプ宣言は、 libc4 と libc5 では\n"
"I<E<lt>unistd.hE<gt>> にあるが、それ以外の環境ではいずれも\n"
"I<E<lt>stdlib.hE<gt>> にある。"

#. type: SS
#: build/C/man3/realpath.3:184
#, no-wrap
msgid "GNU extensions"
msgstr "GNU による拡張"

#. type: Plain text
#: build/C/man3/realpath.3:195
msgid ""
"If the call fails with either B<EACCES> or B<ENOENT> and I<resolved_path> is "
"not NULL, then the prefix of I<path> that is not readable or does not exist "
"is returned in I<resolved_path>."
msgstr ""
"呼び出しが B<EACCES> か B<ENOENT> で失敗し I<resolved_path> が NULL でない場"
"合、読むことができない、もしくは存在しない I<path> のディレクトリ要素 "
"(prefix) が I<resolved_path> で返される。"

#. type: Plain text
#: build/C/man3/realpath.3:220
msgid ""
"The POSIX.1-2001 standard version of this function is broken by design, "
"since it is impossible to determine a suitable size for the output buffer, "
"I<resolved_path>.  According to POSIX.1-2001 a buffer of size B<PATH_MAX> "
"suffices, but B<PATH_MAX> need not be a defined constant, and may have to be "
"obtained using B<pathconf>(3).  And asking B<pathconf>(3)  does not really "
"help, since, on the one hand POSIX warns that the result of B<pathconf>(3)  "
"may be huge and unsuitable for mallocing memory, and on the other hand "
"B<pathconf>(3)  may return -1 to signify that B<PATH_MAX> is not bounded.  "
"The I<resolved_path\\ ==\\ NULL> feature, not standardized in POSIX.1-2001, "
"but standardized in POSIX.1-2008, allows this design problem to be avoided."
msgstr ""
"この関数の POSIX.1-2001 版は、設計段階から問題がある。 出力バッファ "
"I<resolved_path> の適切なサイズを決定することができないからである。 "
"POSIX.1-2001 ではバッファ・サイズとして B<PATH_MAX> は十分だとされているが、 "
"B<PATH_MAX> は定義済の定数である必要はなく、 B<pathconf>(3)  を使って得られる"
"値であってもよいことになっている。 B<pathconf>(3)  からバッファ・サイズを取得"
"したとしても必ずしも十分ではない。 なぜなら、POSIX で警告されているように、 "
"B<pathconf>(3)  の返り値が大き過ぎて適切にメモリを確保することができない かも"
"しれない一方で、 B<pathconf>(3)  は B<PATH_MAX> に制限がないことを示す -1 を"
"返すかもしれないからである。 I<resolved_path\\ ==\\ NULL> の機能を使うと、こ"
"の設計上の問題を回避することができる。 この機能は POSIX.1-2001 では標準化され"
"ていないが、 POSIX.1-2008 では標準化されている。"

#. type: Plain text
#: build/C/man3/realpath.3:226
msgid ""
"The libc4 and libc5 implementation contained a buffer overflow (fixed in "
"libc-5.4.13).  Thus, set-user-ID programs like B<mount>(8)  needed a private "
"version."
msgstr ""
"libc4 と libc5 の実装はバッファ・オーバーフローの可能性を持っていた "
"(libc-5.4.13 で修正されたが)。したがって、 B<mount>(8)  のような set-user-ID "
"されるプログラムでは、この関数相当の関数を自前で持つ必要があった。"

#. type: Plain text
#: build/C/man3/realpath.3:232
msgid ""
"B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), B<pathconf>(3), "
"B<sysconf>(3)"
msgstr ""
"B<readlink>(2), B<canonicalize_file_name>(3), B<getcwd>(3), B<pathconf>(3), "
"B<sysconf>(3)"

#. type: TH
#: build/C/man3/setjmp.3:27
#, no-wrap
msgid "SETJMP"
msgstr "SETJMP"

#. type: TH
#: build/C/man3/setjmp.3:27
#, no-wrap
msgid "2009-06-26"
msgstr "2009-06-26"

#. type: Plain text
#: build/C/man3/setjmp.3:30
msgid "setjmp, sigsetjmp - save stack context for nonlocal goto"
msgstr ""
"setjmp, sigsetjmp - 非局所的なジャンプのために、スタックコンテキスト (stack "
"context) を保存する"

#. type: Plain text
#: build/C/man3/setjmp.3:32
msgid "B<#include E<lt>setjmp.hE<gt>>"
msgstr "B<#include E<lt>setjmp.hE<gt>>"

#. type: Plain text
#: build/C/man3/setjmp.3:35
#, no-wrap
msgid "B<int setjmp(jmp_buf >I<env>B<);>\n"
msgstr "B<int setjmp(jmp_buf >I<env>B<);>\n"

#. type: Plain text
#: build/C/man3/setjmp.3:37
#, no-wrap
msgid "B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"
msgstr "B<int sigsetjmp(sigjmp_buf >I<env>B<, int >I<savesigs>B<);>\n"

#. type: Plain text
#: build/C/man3/setjmp.3:46
msgid "B<setjmp>(): see NOTES."
msgstr "B<setjmp>(): 「注意」参照。"

#. type: Plain text
#: build/C/man3/setjmp.3:49
msgid ""
"B<sigsetjmp>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_C_SOURCE"
msgstr ""
"B<sigsetjmp>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_C_SOURCE"

#. type: Plain text
#: build/C/man3/setjmp.3:65
msgid ""
"B<setjmp>()  and B<longjmp>(3)  are useful for dealing with errors and "
"interrupts encountered in a low-level subroutine of a program.  B<setjmp>()  "
"saves the stack context/environment in I<env> for later use by B<longjmp>"
"(3).  The stack context will be invalidated if the function which called "
"B<setjmp>()  returns."
msgstr ""
"B<setjmp>()  と B<longjmp>(3)  は、プログラムの低レベルなサブルーチン におい"
"て、エラーや割り込みが発生した時の処理に便利である。 B<setjmp>()  は、 "
"B<longjmp>(3)  によって使われる I<env> に スタックコンテキスト/スタック環境を"
"保存する。 B<setjmp>()  を呼び出した 関数が返るときに、そのスタックコンテキス"
"トは無効になる。"

#. type: Plain text
#: build/C/man3/setjmp.3:78
msgid ""
"B<sigsetjmp>()  is similar to B<setjmp>().  If, and only if, I<savesigs> is "
"nonzero, the process's current signal mask is saved in I<env> and will be "
"restored if a B<siglongjmp>(3)  is later performed with this I<env>."
msgstr ""
"B<sigsetjmp>()  も B<setjmp>()  と同様である。 I<savesigs> が 0 以外の場合、 "
"このプロセスの現在のシグナルマスクも I<env> に保存され、 このシグナルは後で "
"B<siglongjmp>(3)  がこの I<env> で実行された際に復元される。"

#. type: Plain text
#: build/C/man3/setjmp.3:88
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  return 0 if returning directly, and nonzero "
"when returning from B<longjmp>(3)  or B<siglongjmp>(3)  using the saved "
"context."
msgstr ""
"直接返ってくるときは、 B<setjmp>()  と B<sigsetjmp>()  は 0 を返し、保存した"
"コンテキストを使って B<longjmp>(3)  や B<siglongjmp>(3)  から返ってくるとき"
"は 0 以外を返す。"

#. type: Plain text
#: build/C/man3/setjmp.3:93
msgid ""
"C89, C99, and POSIX.1-2001 specify B<setjmp>().  POSIX.1-2001 specifies "
"B<sigsetjmp>()."
msgstr ""
"B<setjmp>()  は C89, C99, POSIX.1-2001 で規定されている。 B<sigsetjmp>()  は "
"POSIX.1-2001 で規定されている。"

#. type: Plain text
#: build/C/man3/setjmp.3:114
msgid ""
"POSIX does not specify whether B<setjmp>()  will save the signal mask.  In "
"System V it will not.  In 4.3BSD it will, and there is a function B<_setjmp> "
"that will not.  By default, Linux/glibc follows the System V behavior, but "
"the BSD behavior is provided if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_XOPEN_SOURCE_EXTENDED>, B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined."
msgstr ""
"POSIX は、 B<setjmp>()  がシグナルマスクを保存すべきかどうかを規定していな"
"い。 System V では保存しない。 4.3BSD では保存する; 4.3BSD にはシグナルコンテ"
"キストを保存しない関数 B<_setjmp> もある。 デフォルトでは、Linux/glibc は "
"System V の振る舞いに従うが、 B<_BSD_SOURCE> 機能検査マクロが定義され、 "
"B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_XOPEN_SOURCE_EXTENDED>, B<_GNU_SOURCE>, B<_SVID_SOURCE> のいずれも定義され"
"ていない時は BSD の振る舞いとなる。"

#. type: Plain text
#: build/C/man3/setjmp.3:119
msgid ""
"If you want to portably save and restore signal masks, use B<sigsetjmp>()  "
"and B<siglongjmp>(3)."
msgstr ""
"移植性のある形でシグナルマスクを保存および復元したいのなら、 B<sigsetjmp>()  "
"と B<siglongjmp>(3)  を使うこと。"

#. type: Plain text
#: build/C/man3/setjmp.3:126
msgid ""
"B<setjmp>()  and B<sigsetjmp>()  make programs hard to understand and "
"maintain.  If possible an alternative should be used."
msgstr ""
"B<setjmp>()  や B<sigsetjmp>()  を使うと、プログラムは理解しづらく、保守しに"
"くいものになる。 別の方法が可能なら、それを使うべきである。"

#. type: Plain text
#: build/C/man3/setjmp.3:129
msgid "B<longjmp>(3), B<siglongjmp>(3)"
msgstr "B<longjmp>(3), B<siglongjmp>(3)"

#. type: TH
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "XCRYPT"
msgstr "XCRYPT"

#. type: TH
#: build/C/man3/xcrypt.3:13
#, no-wrap
msgid "2003-04-04"
msgstr "2003-04-04"

#. type: Plain text
#: build/C/man3/xcrypt.3:16
msgid "xencrypt, xdecrypt, passwd2des - RFS password encryption"
msgstr "xencrypt, xdecrypt, passwd2des - RFS パスワード暗号化"

#. type: Plain text
#: build/C/man3/xcrypt.3:18
msgid "B<#include E<lt>rpc/des_crypt.hE<gt>>"
msgstr "B<#include E<lt>rpc/des_crypt.hE<gt>>"

#. type: Plain text
#: build/C/man3/xcrypt.3:20
msgid "B<void passwd2des(char >I<*passwd>B<, char *>I<key>B<);>"
msgstr "B<void passwd2des(char >I<*passwd>B<, char *>I<key>B<);>"

#. type: Plain text
#: build/C/man3/xcrypt.3:22
msgid "B<int xencrypt(char *>I<secret>B<, char *>I<passwd>B<);>"
msgstr "B<int xencrypt(char *>I<secret>B<, char *>I<passwd>B<);>"

#. type: Plain text
#: build/C/man3/xcrypt.3:24
msgid "B<int xdecrypt(char *>I<secret>B<, char *>I<passwd>B<);>"
msgstr "B<int xdecrypt(char *>I<secret>B<, char *>I<passwd>B<);>"

#. type: Plain text
#: build/C/man3/xcrypt.3:40
msgid ""
"The function B<passwd2des>()  takes a character string I<passwd> of "
"arbitrary length and fills a character array I<key> of length 8.  The array "
"I<key> is suitable for use as DES key.  It has odd parity set in bit 0 of "
"each byte.  Both other functions described here use this function to turn "
"their argument I<passwd> into a DES key."
msgstr ""
"関数 B<passwd2des>()  は任意の長さの文字列 I<passwd> をとり、長さ 8 の文字配"
"列 I<key> を埋める。 配列 I<key> は DES キーとして使うのに適している。 この配"
"列の各バイトのビット 0 は奇数パリティである。 ここで説明されている残りの 2 つ"
"の関数は、 この関数を使い、引き数 I<passwd> を DES キーに変換する。"

#.  (over the alphabet 0123456789abcdefABCDEF),
#.  (over the alphabet 0123456789abcdef)
#. type: Plain text
#: build/C/man3/xcrypt.3:57
msgid ""
"The B<xencrypt>()  function takes the ASCII character string I<secret> given "
"in hex, which must have a length that is a multiple of 16, encrypts it using "
"the DES key derived from I<passwd> by B<passwd2des>(), and outputs the "
"result again in I<secret> as a hex string of the same length."
msgstr ""
"B<xencrypt>()  関数は 16 進数で与えられた ASCII 文字列 I<secret> をとる。 こ"
"の長さは 16 の倍数でなければならない。 そして B<passwd2des>()  によって "
"I<passwd> から導き出された DES キーを使い、 I<secret> を暗号化する。 その結果"
"は 16 進数文字列として I<secret> に再び同じ長さで出力される。"

#. type: Plain text
#: build/C/man3/xcrypt.3:61
msgid "The B<xdecrypt>()  function performs the converse operation."
msgstr "B<xdecrypt>()  関数は逆の操作を行う。"

#. type: Plain text
#: build/C/man3/xcrypt.3:67
msgid ""
"The functions B<xencrypt>()  and B<xdecrypt>()  return 1 on success and 0 on "
"error."
msgstr ""
"関数 B<xencrypt>()  と B<xdecrypt>()  は、成功した場合に 1 を返し、失敗した場"
"合に 0 を返す。"

#. type: Plain text
#: build/C/man3/xcrypt.3:70
msgid ""
"These routines are present in libc 4.6.27 and later, and in glibc 2.1 and "
"later."
msgstr "これらのルーチンは libc 4.6.27 以降と glibc 2.1 以降に存在する。"

#. type: Plain text
#: build/C/man3/xcrypt.3:72
msgid "The prototypes are missing from the abovementioned include file."
msgstr "上記のインクルードファイルにプロトタイプがない。"

#. type: Plain text
#: build/C/man3/xcrypt.3:74
msgid "B<cbc_crypt>(3)"
msgstr "B<cbc_crypt>(3)"

#~ msgid "B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
#~ msgstr ""
#~ "B<error_t argz_add_sep(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"

#~ msgid "B<const char *>I<str>B<, int >I<delim>B<);>\n"
#~ msgstr "B<const char *>I<str>B<, int >I<delim>B<);>\n"

#~ msgid "B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"
#~ msgstr "B<error_t argz_append(char **>I<argz>B<, size_t *>I<argz_len>B<,>\n"

#~ msgid "B<const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"
#~ msgstr "B<const char *>I<buf>B<, size_t >I<buf_len>B<);>\n"

#~ msgid "B<size_t *>I<argz_len>B<);>\n"
#~ msgstr "B<size_t *>I<argz_len>B<);>\n"

#~ msgid "B<const char *>I<entry>B<);>\n"
#~ msgstr "B<const char *>I<entry>B<);>\n"

#~ msgid "B<const char *>I<with>B<, unsigned int *>I<replace_count>B<);>\n"
#~ msgstr "B<const char *>I<with>B<, unsigned int *>I<replace_count>B<);>\n"

#~ msgid ""
#~ "B<path         dirname    basename>\n"
#~ "\"/usr/lib\"    \"/usr\"    \"lib\"\n"
#~ "\"/usr/\"       \"/\"       \"usr\"\n"
#~ "\"usr\"         \".\"       \"usr\"\n"
#~ "\"/\"           \"/\"       \"/\"\n"
#~ "\".\"           \".\"       \".\"\n"
#~ "\"..\"          \".\"       \"..\"\n"
#~ msgstr ""
#~ "B<path         dirname    basename>\n"
#~ "\"/usr/lib\"    \"/usr\"    \"lib\"\n"
#~ "\"/usr/\"       \"/\"       \"usr\"\n"
#~ "\"usr\"         \".\"       \"usr\"\n"
#~ "\"/\"           \"/\"       \"/\"\n"
#~ "\".\"           \".\"       \".\"\n"
#~ "\"..\"          \".\"       \"..\"\n"

#~ msgid "B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
#~ msgstr "B<error_t envz_add(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"

#~ msgid "B<const char *>I<name>B<, const char *>I<value>B<);>\n"
#~ msgstr "B<const char *>I<name>B<, const char *>I<value>B<);>\n"

#~ msgid "B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"
#~ msgstr "B<error_t envz_merge(char **>I<envz>B<, size_t *>I<envz_len>B<,>\n"

#~ msgid ""
#~ "B<const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"
#~ msgstr ""
#~ "B<const char *>I<envz2>B<, size_t >I<envz2_len>B<, int >I<override>B<);>\n"

#~ msgid "1997-03-08"
#~ msgstr "1997-03-08"

#~ msgid "2011-09-10"
#~ msgstr "2011-09-10"

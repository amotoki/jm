# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2013-08-15 19:32+0900\n"
"PO-Revision-Date: 2013-08-15 20:29+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25
#, no-wrap
msgid "ACCT"
msgstr "ACCT"

#. type: TH
#: build/C/man2/acct.2:31
#, no-wrap
msgid "2008-06-16"
msgstr "2008-06-16"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25
#: build/C/man7/capabilities.7:48 build/C/man2/capget.2:15
#: build/C/man7/cpuset.7:25 build/C/man7/credentials.7:27
#: build/C/man2/getgid.2:25 build/C/man2/getgroups.2:31
#: build/C/man2/getpid.2:25 build/C/man2/getpriority.2:48
#: build/C/man2/getresuid.2:28 build/C/man2/getrlimit.2:64
#: build/C/man2/getrusage.2:39 build/C/man2/getsid.2:26
#: build/C/man2/getuid.2:26 build/C/man2/iopl.2:33
#: build/C/man2/ioprio_set.2:24 build/C/man2/ipc.2:25
#: build/C/man2/seteuid.2:29 build/C/man2/setfsgid.2:31
#: build/C/man2/setfsuid.2:31 build/C/man2/setgid.2:29
#: build/C/man2/setpgid.2:48 build/C/man2/setresuid.2:26
#: build/C/man2/setreuid.2:45 build/C/man2/setsid.2:30
#: build/C/man2/setuid.2:30 build/C/man7/svipc.7:40 build/C/man3/ulimit.3:27
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/acct.2:31 build/C/man5/acct.5:25
#: build/C/man7/capabilities.7:48 build/C/man2/capget.2:15
#: build/C/man7/cpuset.7:25 build/C/man7/credentials.7:27
#: build/C/man2/getgid.2:25 build/C/man2/getgroups.2:31
#: build/C/man2/getpid.2:25 build/C/man2/getpriority.2:48
#: build/C/man2/getresuid.2:28 build/C/man2/getrlimit.2:64
#: build/C/man2/getrusage.2:39 build/C/man2/getsid.2:26
#: build/C/man2/getuid.2:26 build/C/man2/iopl.2:33
#: build/C/man2/ioprio_set.2:24 build/C/man2/ipc.2:25
#: build/C/man2/seteuid.2:29 build/C/man2/setfsgid.2:31
#: build/C/man2/setfsuid.2:31 build/C/man2/setgid.2:29
#: build/C/man2/setpgid.2:48 build/C/man2/setresuid.2:26
#: build/C/man2/setreuid.2:45 build/C/man2/setsid.2:30
#: build/C/man2/setuid.2:30 build/C/man7/svipc.7:40 build/C/man3/ulimit.3:27
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/acct.2:32 build/C/man5/acct.5:26
#: build/C/man7/capabilities.7:49 build/C/man2/capget.2:16
#: build/C/man7/cpuset.7:26 build/C/man7/credentials.7:28
#: build/C/man2/getgid.2:26 build/C/man2/getgroups.2:32
#: build/C/man2/getpid.2:26 build/C/man2/getpriority.2:49
#: build/C/man2/getresuid.2:29 build/C/man2/getrlimit.2:65
#: build/C/man2/getrusage.2:40 build/C/man2/getsid.2:27
#: build/C/man2/getuid.2:27 build/C/man2/iopl.2:34
#: build/C/man2/ioprio_set.2:25 build/C/man2/ipc.2:26
#: build/C/man2/seteuid.2:30 build/C/man2/setfsgid.2:32
#: build/C/man2/setfsuid.2:32 build/C/man2/setgid.2:30
#: build/C/man2/setpgid.2:49 build/C/man2/setresuid.2:27
#: build/C/man2/setreuid.2:46 build/C/man2/setsid.2:31
#: build/C/man2/setuid.2:31 build/C/man7/svipc.7:41 build/C/man3/ulimit.3:28
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/acct.2:34
msgid "acct - switch process accounting on or off"
msgstr "acct - プロセス・アカウントのオンとオフを切り換える"

#. type: SH
#: build/C/man2/acct.2:34 build/C/man5/acct.5:28 build/C/man2/capget.2:18
#: build/C/man2/getgid.2:28 build/C/man2/getgroups.2:34
#: build/C/man2/getpid.2:28 build/C/man2/getpriority.2:51
#: build/C/man2/getresuid.2:31 build/C/man2/getrlimit.2:67
#: build/C/man2/getrusage.2:42 build/C/man2/getsid.2:29
#: build/C/man2/getuid.2:29 build/C/man2/iopl.2:36
#: build/C/man2/ioprio_set.2:27 build/C/man2/ipc.2:28
#: build/C/man2/seteuid.2:32 build/C/man2/setfsgid.2:34
#: build/C/man2/setfsuid.2:34 build/C/man2/setgid.2:32
#: build/C/man2/setpgid.2:51 build/C/man2/setresuid.2:29
#: build/C/man2/setreuid.2:48 build/C/man2/setsid.2:33
#: build/C/man2/setuid.2:33 build/C/man7/svipc.7:43 build/C/man3/ulimit.3:30
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/acct.2:38
#, no-wrap
msgid "B<#include E<lt>unistd.hE<gt>>\n"
msgstr "B<#include E<lt>unistd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/acct.2:40
#, no-wrap
msgid "B<int acct(const char *>I<filename>B<);>\n"
msgstr "B<int acct(const char *>I<filename>B<);>\n"

#. type: Plain text
#: build/C/man2/acct.2:46 build/C/man2/getgroups.2:48
#: build/C/man2/getrlimit.2:84 build/C/man2/getsid.2:37
#: build/C/man2/seteuid.2:44 build/C/man2/setpgid.2:71
#: build/C/man2/setreuid.2:60
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man2/acct.2:50
msgid ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<acct>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: SH
#: build/C/man2/acct.2:50 build/C/man5/acct.5:30
#: build/C/man7/capabilities.7:51 build/C/man2/capget.2:24
#: build/C/man7/cpuset.7:28 build/C/man7/credentials.7:30
#: build/C/man2/getgid.2:36 build/C/man2/getgroups.2:52
#: build/C/man2/getpid.2:36 build/C/man2/getpriority.2:59
#: build/C/man2/getresuid.2:39 build/C/man2/getrlimit.2:88
#: build/C/man2/getrusage.2:48 build/C/man2/getsid.2:50
#: build/C/man2/getuid.2:37 build/C/man2/iopl.2:40
#: build/C/man2/ioprio_set.2:35 build/C/man2/ipc.2:34
#: build/C/man2/seteuid.2:53 build/C/man2/setfsgid.2:39
#: build/C/man2/setfsuid.2:39 build/C/man2/setgid.2:38
#: build/C/man2/setpgid.2:98 build/C/man2/setresuid.2:37
#: build/C/man2/setreuid.2:70 build/C/man2/setsid.2:40
#: build/C/man2/setuid.2:39 build/C/man7/svipc.7:49 build/C/man3/ulimit.3:34
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/acct.2:60
msgid ""
"The B<acct>()  system call enables or disables process accounting.  If "
"called with the name of an existing file as its argument, accounting is "
"turned on, and records for each terminating process are appended to "
"I<filename> as it terminates.  An argument of NULL causes accounting to be "
"turned off."
msgstr ""
"B<acct>()  システムコールは、プロセス・アカウントの有効・無効を切り替える。 "
"既存のファイルの名前を引き数に指定して呼び出されたら、 アカウント (account) "
"が有効になり、 終了したプロセスの記録が I<filename> に追記される。 NULL を引"
"き数として呼び出されたらアカウントをオフにする。"

#. type: SH
#: build/C/man2/acct.2:60 build/C/man2/capget.2:160
#: build/C/man2/getgroups.2:92 build/C/man2/getpriority.2:107
#: build/C/man2/getresuid.2:50 build/C/man2/getrlimit.2:430
#: build/C/man2/getrusage.2:181 build/C/man2/getsid.2:58
#: build/C/man2/iopl.2:66 build/C/man2/ioprio_set.2:149
#: build/C/man2/seteuid.2:67 build/C/man2/setfsgid.2:69
#: build/C/man2/setfsuid.2:69 build/C/man2/setgid.2:53
#: build/C/man2/setpgid.2:172 build/C/man2/setresuid.2:64
#: build/C/man2/setreuid.2:91 build/C/man2/setsid.2:51
#: build/C/man2/setuid.2:70 build/C/man3/ulimit.3:67
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/acct.2:65 build/C/man2/capget.2:165
#: build/C/man2/getresuid.2:55 build/C/man2/getrusage.2:186
#: build/C/man2/iopl.2:71 build/C/man2/seteuid.2:72 build/C/man2/setgid.2:58
#: build/C/man2/setresuid.2:69 build/C/man2/setreuid.2:96
#: build/C/man2/setuid.2:75
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合は 0 が返される。エラーの場合は -1 が返され、 I<errno> が適切に設"
"定される。"

#. type: SH
#: build/C/man2/acct.2:65 build/C/man2/capget.2:179 build/C/man7/cpuset.7:1100
#: build/C/man2/getgid.2:42 build/C/man2/getgroups.2:106
#: build/C/man2/getpid.2:44 build/C/man2/getpriority.2:120
#: build/C/man2/getresuid.2:55 build/C/man2/getrlimit.2:435
#: build/C/man2/getrusage.2:186 build/C/man2/getsid.2:63
#: build/C/man2/getuid.2:43 build/C/man2/iopl.2:71
#: build/C/man2/ioprio_set.2:169 build/C/man2/seteuid.2:72
#: build/C/man2/setgid.2:58 build/C/man2/setpgid.2:193
#: build/C/man2/setresuid.2:69 build/C/man2/setreuid.2:96
#: build/C/man2/setsid.2:58 build/C/man2/setuid.2:75 build/C/man3/ulimit.3:74
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man2/acct.2:66 build/C/man7/cpuset.7:1116
#: build/C/man7/cpuset.7:1123 build/C/man7/cpuset.7:1129
#: build/C/man7/cpuset.7:1137 build/C/man7/cpuset.7:1144
#: build/C/man2/getpriority.2:140 build/C/man2/setpgid.2:194
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man2/acct.2:77
msgid ""
"Write permission is denied for the specified file, or search permission is "
"denied for one of the directories in the path prefix of I<filename> (see "
"also B<path_resolution>(7)), or I<filename> is not a regular file."
msgstr ""
"指定したファイルへの書き込み許可がなく、書き込みが拒否された。 または "
"I<filename> のディレクトリ部分の何れかのディレクトリに検索許可がなく拒否され"
"た (B<path_resolution>(7)  も参照すること)。 または I<filename> が通常 "
"(regular) のファイルでない。"

#. type: TP
#: build/C/man2/acct.2:77 build/C/man2/capget.2:180 build/C/man7/cpuset.7:1172
#: build/C/man2/getgroups.2:107 build/C/man2/getresuid.2:56
#: build/C/man2/getrlimit.2:436 build/C/man2/getrusage.2:187
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/acct.2:81
msgid "I<filename> points outside your accessible address space."
msgstr "アクセスできるアドレス空間の外を I<filename> が指している。"

#. type: TP
#: build/C/man2/acct.2:81 build/C/man7/cpuset.7:1238
#: build/C/man7/cpuset.7:1246
#, no-wrap
msgid "B<EIO>"
msgstr "B<EIO>"

#. type: Plain text
#: build/C/man2/acct.2:85
msgid "Error writing to the file I<filename>."
msgstr "I<filename> への書き込みにエラーが発生した。"

#. type: TP
#: build/C/man2/acct.2:85
#, no-wrap
msgid "B<EISDIR>"
msgstr "B<EISDIR>"

#. type: Plain text
#: build/C/man2/acct.2:89
msgid "I<filename> is a directory."
msgstr "I<filename> がディレクトリである。"

#. type: TP
#: build/C/man2/acct.2:89
#, no-wrap
msgid "B<ELOOP>"
msgstr "B<ELOOP>"

#. type: Plain text
#: build/C/man2/acct.2:93
msgid "Too many symbolic links were encountered in resolving I<filename>."
msgstr "I<filename> の実体にたどり着くまでのシンボリックリンクの数が多すぎる。"

#. type: TP
#: build/C/man2/acct.2:93 build/C/man7/cpuset.7:1251
#: build/C/man7/cpuset.7:1258 build/C/man7/cpuset.7:1263
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man2/acct.2:97
msgid "I<filename> was too long."
msgstr "I<filename> が長すぎる。"

#. type: TP
#: build/C/man2/acct.2:97
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/acct.2:100
msgid "The system limit on the total number of open files has been reached."
msgstr "オープンされたファイルの総数がシステム制限に達した。"

#. type: TP
#: build/C/man2/acct.2:100 build/C/man7/cpuset.7:1275
#: build/C/man7/cpuset.7:1280
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man2/acct.2:103
msgid "The specified filename does not exist."
msgstr "指定されたファイルが存在しない。"

#. type: TP
#: build/C/man2/acct.2:103 build/C/man7/cpuset.7:1287
#: build/C/man2/getgroups.2:127
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/acct.2:106 build/C/man2/getgroups.2:130
msgid "Out of memory."
msgstr "メモリ不足。"

#. type: TP
#: build/C/man2/acct.2:106 build/C/man2/iopl.2:76
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man2/acct.2:112
msgid ""
"BSD process accounting has not been enabled when the operating system kernel "
"was compiled.  The kernel configuration parameter controlling this feature "
"is B<CONFIG_BSD_PROCESS_ACCT>."
msgstr ""
"カーネルをコンパイルした時に BSD プロセス・アカウントが有効になっていない。 "
"この機能はカーネルのコンフィグの B<CONFIG_BSD_PROCESS_ACCT> パラメータによっ"
"て制御される。"

#. type: TP
#: build/C/man2/acct.2:112 build/C/man7/cpuset.7:1314
#, no-wrap
msgid "B<ENOTDIR>"
msgstr "B<ENOTDIR>"

#. type: Plain text
#: build/C/man2/acct.2:117
msgid ""
"A component used as a directory in I<filename> is not in fact a directory."
msgstr ""
"I<filename> の中でディレクトリして扱われている要素が、 実際はディレクトリでな"
"い。"

#. type: TP
#: build/C/man2/acct.2:117 build/C/man2/capget.2:191 build/C/man2/capget.2:196
#: build/C/man7/cpuset.7:1319 build/C/man2/getgroups.2:130
#: build/C/man2/getpriority.2:152 build/C/man2/getrlimit.2:452
#: build/C/man2/getsid.2:64 build/C/man2/iopl.2:79
#: build/C/man2/ioprio_set.2:179 build/C/man2/seteuid.2:75
#: build/C/man2/setgid.2:59 build/C/man2/setpgid.2:208
#: build/C/man2/setresuid.2:77 build/C/man2/setreuid.2:97
#: build/C/man2/setsid.2:59 build/C/man2/setuid.2:85 build/C/man3/ulimit.3:75
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/acct.2:123
msgid ""
"The calling process has insufficient privilege to enable process "
"accounting.  On Linux the B<CAP_SYS_PACCT> capability is required."
msgstr ""
"呼び出したプロセスにはプロセス・アカウントを有効にするのに十分な特権がない。 "
"Linux では B<CAP_SYS_PACCT> ケーパビリティ (capability) が必要である。"

#. type: TP
#: build/C/man2/acct.2:123
#, no-wrap
msgid "B<EROFS>"
msgstr "B<EROFS>"

#. type: Plain text
#: build/C/man2/acct.2:127
msgid "I<filename> refers to a file on a read-only file system."
msgstr ""
"読み込みだけのファイルシステム上のファイルを I<filename> が参照している。"

#. type: TP
#: build/C/man2/acct.2:127
#, no-wrap
msgid "B<EUSERS>"
msgstr "B<EUSERS>"

#. type: Plain text
#: build/C/man2/acct.2:130
msgid "There are no more free file structures or we ran out of memory."
msgstr "使用可能なファイル構造体がないか、メモリが足りない。"

#. type: SH
#: build/C/man2/acct.2:130 build/C/man5/acct.5:153
#: build/C/man7/capabilities.7:1079 build/C/man2/capget.2:218
#: build/C/man7/credentials.7:234 build/C/man2/getgid.2:44
#: build/C/man2/getgroups.2:133 build/C/man2/getpid.2:46
#: build/C/man2/getpriority.2:160 build/C/man2/getresuid.2:67
#: build/C/man2/getrlimit.2:473 build/C/man2/getrusage.2:195
#: build/C/man2/getsid.2:79 build/C/man2/getuid.2:45 build/C/man2/iopl.2:87
#: build/C/man2/ioprio_set.2:196 build/C/man2/ipc.2:45
#: build/C/man2/seteuid.2:91 build/C/man2/setfsgid.2:80
#: build/C/man2/setfsuid.2:80 build/C/man2/setgid.2:66
#: build/C/man2/setpgid.2:227 build/C/man2/setresuid.2:83
#: build/C/man2/setreuid.2:113 build/C/man2/setsid.2:65
#: build/C/man2/setuid.2:92 build/C/man3/ulimit.3:78
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#.  SVr4 documents an EBUSY error condition, but no EISDIR or ENOSYS.
#.  Also AIX and HP-UX document EBUSY (attempt is made
#.  to enable accounting when it is already enabled), as does Solaris
#.  (attempt is made to enable accounting using the same file that is
#.  currently being used).
#. type: Plain text
#: build/C/man2/acct.2:137
msgid "SVr4, 4.3BSD (but not POSIX)."
msgstr "SVr4, 4.3BSD (POSIX ではない)。"

#. type: SH
#: build/C/man2/acct.2:137 build/C/man5/acct.5:157
#: build/C/man7/capabilities.7:1085 build/C/man2/capget.2:220
#: build/C/man7/cpuset.7:1341 build/C/man7/credentials.7:240
#: build/C/man2/getgid.2:46 build/C/man2/getgroups.2:141
#: build/C/man2/getpid.2:48 build/C/man2/getpriority.2:163
#: build/C/man2/getresuid.2:70 build/C/man2/getrlimit.2:496
#: build/C/man2/getrusage.2:206 build/C/man2/getsid.2:81
#: build/C/man2/getuid.2:47 build/C/man2/iopl.2:91
#: build/C/man2/ioprio_set.2:198 build/C/man2/ipc.2:49
#: build/C/man2/seteuid.2:93 build/C/man2/setfsgid.2:84
#: build/C/man2/setfsuid.2:84 build/C/man2/setgid.2:68
#: build/C/man2/setpgid.2:249 build/C/man2/setresuid.2:86
#: build/C/man2/setreuid.2:119 build/C/man2/setsid.2:67
#: build/C/man2/setuid.2:97
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/acct.2:140
msgid ""
"No accounting is produced for programs running when a system crash occurs.  "
"In particular, nonterminating processes are never accounted for."
msgstr ""
"システムがクラッシュした時に実行中だったプログラムのアカウントは生成されな"
"い。 特に、終了しないプログラムがアカウントされることはない。"

#. type: Plain text
#: build/C/man2/acct.2:143
msgid ""
"The structure of the records written to the accounting file is described in "
"B<acct>(5)."
msgstr ""
"アカウント用ファイルに書き込まれるレコードの構造体については B<acct>(5)  に説"
"明がある。"

#. type: SH
#: build/C/man2/acct.2:143 build/C/man5/acct.5:174
#: build/C/man7/capabilities.7:1141 build/C/man2/capget.2:228
#: build/C/man7/cpuset.7:1488 build/C/man7/credentials.7:251
#: build/C/man2/getgid.2:62 build/C/man2/getgroups.2:171
#: build/C/man2/getpid.2:100 build/C/man2/getpriority.2:232
#: build/C/man2/getresuid.2:86 build/C/man2/getrlimit.2:656
#: build/C/man2/getrusage.2:246 build/C/man2/getsid.2:84
#: build/C/man2/getuid.2:73 build/C/man2/iopl.2:100
#: build/C/man2/ioprio_set.2:346 build/C/man2/ipc.2:57
#: build/C/man2/seteuid.2:124 build/C/man2/setfsgid.2:112
#: build/C/man2/setfsuid.2:112 build/C/man2/setgid.2:78
#: build/C/man2/setpgid.2:317 build/C/man2/setresuid.2:106
#: build/C/man2/setreuid.2:159 build/C/man2/setsid.2:84
#: build/C/man2/setuid.2:120 build/C/man7/svipc.7:331 build/C/man3/ulimit.3:83
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/acct.2:145
msgid "B<acct>(5)"
msgstr "B<acct>(5)"

#. type: SH
#: build/C/man2/acct.2:145 build/C/man5/acct.5:179
#: build/C/man7/capabilities.7:1161 build/C/man2/capget.2:232
#: build/C/man7/cpuset.7:1505 build/C/man7/credentials.7:282
#: build/C/man2/getgid.2:67 build/C/man2/getgroups.2:178
#: build/C/man2/getpid.2:110 build/C/man2/getpriority.2:240
#: build/C/man2/getresuid.2:92 build/C/man2/getrlimit.2:674
#: build/C/man2/getrusage.2:253 build/C/man2/getsid.2:88
#: build/C/man2/getuid.2:78 build/C/man2/iopl.2:104
#: build/C/man2/ioprio_set.2:354 build/C/man2/ipc.2:70
#: build/C/man2/seteuid.2:131 build/C/man2/setfsgid.2:117
#: build/C/man2/setfsuid.2:117 build/C/man2/setgid.2:84
#: build/C/man2/setpgid.2:324 build/C/man2/setresuid.2:115
#: build/C/man2/setreuid.2:167 build/C/man2/setsid.2:91
#: build/C/man2/setuid.2:127 build/C/man7/svipc.7:348 build/C/man3/ulimit.3:88
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/acct.2:152 build/C/man5/acct.5:186
#: build/C/man7/capabilities.7:1168 build/C/man2/capget.2:239
#: build/C/man7/cpuset.7:1512 build/C/man7/credentials.7:289
#: build/C/man2/getgid.2:74 build/C/man2/getgroups.2:185
#: build/C/man2/getpid.2:117 build/C/man2/getpriority.2:247
#: build/C/man2/getresuid.2:99 build/C/man2/getrlimit.2:681
#: build/C/man2/getrusage.2:260 build/C/man2/getsid.2:95
#: build/C/man2/getuid.2:85 build/C/man2/iopl.2:111
#: build/C/man2/ioprio_set.2:361 build/C/man2/ipc.2:77
#: build/C/man2/seteuid.2:138 build/C/man2/setfsgid.2:124
#: build/C/man2/setfsuid.2:124 build/C/man2/setgid.2:91
#: build/C/man2/setpgid.2:331 build/C/man2/setresuid.2:122
#: build/C/man2/setreuid.2:174 build/C/man2/setsid.2:98
#: build/C/man2/setuid.2:134 build/C/man7/svipc.7:355 build/C/man3/ulimit.3:95
msgid ""
"This page is part of release 3.53 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.53 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man5/acct.5:25
#, no-wrap
msgid "2008-06-15"
msgstr "2008-06-15"

#. type: Plain text
#: build/C/man5/acct.5:28
msgid "acct - process accounting file"
msgstr "acct - プロセス・アカウンティング・ファイル"

#. type: Plain text
#: build/C/man5/acct.5:30
msgid "B<#include E<lt>sys/acct.hE<gt>>"
msgstr "B<#include E<lt>sys/acct.hE<gt>>"

#. type: Plain text
#: build/C/man5/acct.5:36
msgid ""
"If the kernel is built with the process accounting option enabled "
"(B<CONFIG_BSD_PROCESS_ACCT>), then calling B<acct>(2)  starts process "
"accounting, for example:"
msgstr ""
"カーネルがプロセス・アカウンティングのオプション "
"(B<CONFIG_BSD_PROCESS_ACCT>)  を有効にして作成されていると、以下のように "
"B<acct>(2)  を呼び出すとプロセス・アカウンティングが開始される。"

#. type: Plain text
#: build/C/man5/acct.5:39
msgid "acct(\"/var/log/pacct\");"
msgstr "acct(\"/var/log/pacct\");"

#. type: Plain text
#: build/C/man5/acct.5:47
msgid ""
"When process accounting is enabled, the kernel writes a record to the "
"accounting file as each process on the system terminates.  This record "
"contains information about the terminated process, and is defined in "
"I<E<lt>sys/acct.hE<gt>> as follows:"
msgstr ""
"プロセス・アカウンティングが有効になっていると、カーネルは システム上の各プロ"
"セスが終了するたびにアカウンティングファイルに レコードを書き込む。 このレ"
"コードは、終了したプロセスに関する情報を保持するもので、 I<E<lt>sys/acct."
"hE<gt>> で以下のように定義されている。"

#. type: Plain text
#: build/C/man5/acct.5:51
#, no-wrap
msgid "#define ACCT_COMM 16\n"
msgstr "#define ACCT_COMM 16\n"

#. type: Plain text
#: build/C/man5/acct.5:53
#, no-wrap
msgid "typedef u_int16_t comp_t;\n"
msgstr "typedef u_int16_t comp_t;\n"

#. type: Plain text
#: build/C/man5/acct.5:77
#, no-wrap
msgid ""
"struct acct {\n"
"    char ac_flag;           /* Accounting flags */\n"
"    u_int16_t ac_uid;       /* Accounting user ID */\n"
"    u_int16_t ac_gid;       /* Accounting group ID */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_btime;     /* Process creation time\n"
"                               (seconds since the Epoch) */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System CPU time */\n"
"    comp_t    ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    u_int32_t ac_exitcode;  /* Process termination status\n"
"                               (see wait(2)) */\n"
"    char      ac_comm[ACCT_COMM+1];\n"
"                            /* Command name (basename of last\n"
"                               executed command; null-terminated) */\n"
"    char      ac_pad[I<X>];    /* padding bytes */\n"
"};\n"
msgstr ""
"struct acct {\n"
"    char ac_flag;           /* Accounting flags */\n"
"    u_int16_t ac_uid;       /* Accounting user ID */\n"
"    u_int16_t ac_gid;       /* Accounting group ID */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_btime;     /* Process creation time\n"
"                               (seconds since the Epoch) */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System CPU time */\n"
"    comp_t    ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    u_int32_t ac_exitcode;  /* Process termination status\n"
"                               (see wait(2)) */\n"
"    char      ac_comm[ACCT_COMM+1];\n"
"                            /* Command name (basename of last\n"
"                               executed command; null-terminated) */\n"
"    char      ac_pad[I<X>];    /* padding bytes */\n"
"};\n"

#. type: Plain text
#: build/C/man5/acct.5:84
#, no-wrap
msgid ""
"enum {          /* Bits that may be set in ac_flag field */\n"
"    AFORK = 0x01,           /* Has executed fork, but no exec */\n"
"    ASU   = 0x02,           /* Used superuser privileges */\n"
"    ACORE = 0x08,           /* Dumped core */\n"
"    AXSIG = 0x10            /* Killed by a signal */\n"
"};\n"
msgstr ""
"enum {          /* Bits that may be set in ac_flag field */\n"
"    AFORK = 0x01,           /* Has executed fork, but no exec */\n"
"    ASU   = 0x02,           /* Used superuser privileges */\n"
"    ACORE = 0x08,           /* Dumped core */\n"
"    AXSIG = 0x10            /* Killed by a signal */\n"
"};\n"

#. type: Plain text
#: build/C/man5/acct.5:94
msgid ""
"The I<comp_t> data type is a floating-point value consisting of a 3-bit, "
"base-8 exponent, and a 13-bit mantissa.  A value, I<c>, of this type can be "
"converted to a (long) integer as follows:"
msgstr ""
"データ型 I<comp_t> は浮動小数点値で、3 ビット幅の基数が 8 の指数部と 13 ビッ"
"ト幅の仮数部から 構成される。 I<comp_t> 型の値 I<c> は以下のようにして (long "
"型の) 整数に変換できる。"

#. type: Plain text
#: build/C/man5/acct.5:97
#, no-wrap
msgid "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"
msgstr "    v = (c & 0x1fff) E<lt>E<lt> (((c E<gt>E<gt> 13) & 0x7) * 3);\n"

#. type: Plain text
#: build/C/man5/acct.5:107
msgid ""
"The I<ac_utime>, I<ac_stime>, and I<ac_etime> fields measure time in \"clock "
"ticks\"; divide these values by I<sysconf(_SC_CLK_TCK)> to convert them to "
"seconds."
msgstr ""
"フィールド I<ac_utime>, I<ac_stime>, I<ac_etime> は \"clock ticks\" 単位で計"
"測した時間である。 これらの値を I<sysconf(_SC_CLK_TCK)> で割ると、秒に変換で"
"きる。"

#. type: SS
#: build/C/man5/acct.5:107
#, no-wrap
msgid "Version 3 accounting file format"
msgstr "バージョン 3 のアカウンティングファイルのフォーマット"

#. type: Plain text
#: build/C/man5/acct.5:122
msgid ""
"Since kernel 2.6.8, an optional alternative version of the accounting file "
"can be produced if the B<CONFIG_BSD_PROCESS_ACCT_V3> option is set when "
"building the kernel.  With this option is set, the records written to the "
"accounting file contain additional fields, and the width of I<c_uid> and "
"I<ac_gid> fields is widened from 16 to 32 bits (in line with the increased "
"size of UID and GIDs in Linux 2.4 and later).  The records are defined as "
"follows:"
msgstr ""
"カーネル 2.6.8 以降では、 別のバージョンのアカウンティングファイルを生成する"
"ことができ、 これを使うにはカーネル構築時に B<CONFIG_BSD_PROCESS_ACCT_V3> オ"
"プションが有効になっている必要がある。 このオプションが設定されると、アカウン"
"ティングファイルに書き込まれる レコードにフィールドが追加される。 また、"
"フィールド I<c_uid> と I<ac_gid> の幅が 16 ビットから 32 ビットに拡張される "
"(これは Linux 2.4 以降で UID と GID のサイズが増えているのに 対応したものであ"
"る)。 このレコードは以下のように定義されている。"

#. type: Plain text
#: build/C/man5/acct.5:147
#, no-wrap
msgid ""
"struct acct_v3 {\n"
"    char      ac_flag;      /* Flags */\n"
"    char      ac_version;   /* Always set to ACCT_VERSION (3) */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_exitcode;  /* Process termination status */\n"
"    u_int32_t ac_uid;       /* Real user ID */\n"
"    u_int32_t ac_gid;       /* Real group ID */\n"
"    u_int32_t ac_pid;       /* Process ID */\n"
"    u_int32_t ac_ppid;      /* Parent process ID */\n"
"    u_int32_t ac_btime;     /* Process creation time */\n"
"    float     ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written\n"
"                               (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    char      ac_comm[ACCT_COMM]; /* Command name */\n"
"};\n"
msgstr ""
"struct acct_v3 {\n"
"    char      ac_flag;      /* Flags */\n"
"    char      ac_version;   /* Always set to ACCT_VERSION (3) */\n"
"    u_int16_t ac_tty;       /* Controlling terminal */\n"
"    u_int32_t ac_exitcode;  /* Process termination status */\n"
"    u_int32_t ac_uid;       /* Real user ID */\n"
"    u_int32_t ac_gid;       /* Real group ID */\n"
"    u_int32_t ac_pid;       /* Process ID */\n"
"    u_int32_t ac_ppid;      /* Parent process ID */\n"
"    u_int32_t ac_btime;     /* Process creation time */\n"
"    float     ac_etime;     /* Elapsed time */\n"
"    comp_t    ac_utime;     /* User CPU time */\n"
"    comp_t    ac_stime;     /* System time */\n"
"    comp_t    ac_mem;       /* Average memory usage (kB) */\n"
"    comp_t    ac_io;        /* Characters transferred (unused) */\n"
"    comp_t    ac_rw;        /* Blocks read or written\n"
"                               (unused) */\n"
"    comp_t    ac_minflt;    /* Minor page faults */\n"
"    comp_t    ac_majflt;    /* Major page faults */\n"
"    comp_t    ac_swaps;     /* Number of swaps (unused) */\n"
"    char      ac_comm[ACCT_COMM]; /* Command name */\n"
"};\n"

#. type: SH
#: build/C/man5/acct.5:149 build/C/man7/cpuset.7:1338
#: build/C/man2/getresuid.2:60 build/C/man2/getrlimit.2:468
#: build/C/man2/getsid.2:75 build/C/man2/ioprio_set.2:193
#: build/C/man2/setfsgid.2:76 build/C/man2/setfsuid.2:76
#: build/C/man2/setresuid.2:81
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man5/acct.5:153
msgid "The I<acct_v3> structure is defined in glibc since version 2.6."
msgstr "I<acct_v3> 構造体はバージョン 2.6 以降の glibc で定義されている。"

#. type: Plain text
#: build/C/man5/acct.5:157
msgid ""
"Process accounting originated on BSD.  Although it is present on most "
"systems, it is not standardized, and the details vary somewhat between "
"systems."
msgstr ""
"プロセスアカウンティングは BSD 由来である。 この機能はほとんどのシステムに存"
"在するが、標準化されておらず、 その詳細はシステムによりいくらか異なる。"

#. type: Plain text
#: build/C/man5/acct.5:160
msgid ""
"Records in the accounting file are ordered by termination time of the "
"process."
msgstr "アカウンティングファイルのレコードは、プロセスの終了時刻の順序となる。"

#. type: Plain text
#: build/C/man5/acct.5:167
msgid ""
"In kernels up to and including 2.6.9, a separate accounting record is "
"written for each thread created using the NPTL threading library; since "
"Linux 2.6.10, a single accounting record is written for the entire process "
"on termination of the last thread in the process."
msgstr ""
"バージョン 2.6.9 以前のカーネルでは、 NPTL スレッドライブラリを使って作成され"
"たスレッドでは スレッド毎に別々のアカウンティングレコードが書き込まれてい"
"た。 Linux 2.6.10 以降では、プロセス内の最後のスレッドが終了すると、 プロセス"
"全体についてのアカウンティングレコードが一つだけ書き込まれる。"

#. type: Plain text
#: build/C/man5/acct.5:174
msgid ""
"The I<proc/sys/kernel/acct> file, described in B<proc>(5), defines settings "
"that control the behavior of process accounting when disk space runs low."
msgstr ""
"I<proc/sys/kernel/acct> ファイル (B<proc>(5)  で説明されている) は、ディスク"
"容量の残りが少なくなった際の プロセス・アカウンティングの動作を制御する設定を"
"保持している。"

#. type: Plain text
#: build/C/man5/acct.5:179
msgid "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"
msgstr "B<lastcomm>(1), B<acct>(2), B<accton>(8), B<sa>(8)"

#. type: TH
#: build/C/man7/capabilities.7:48
#, no-wrap
msgid "CAPABILITIES"
msgstr "CAPABILITIES"

#. type: TH
#: build/C/man7/capabilities.7:48
#, fuzzy, no-wrap
#| msgid "2013-04-17"
msgid "2013-07-21"
msgstr "2013-04-17"

#. type: Plain text
#: build/C/man7/capabilities.7:51
msgid "capabilities - overview of Linux capabilities"
msgstr "capabilities - Linux のケーパビリティ (capability) の概要"

#. type: Plain text
#: build/C/man7/capabilities.7:63
msgid ""
"For the purpose of performing permission checks, traditional UNIX "
"implementations distinguish two categories of processes: I<privileged> "
"processes (whose effective user ID is 0, referred to as superuser or root), "
"and I<unprivileged> processes (whose effective UID is nonzero).  Privileged "
"processes bypass all kernel permission checks, while unprivileged processes "
"are subject to full permission checking based on the process's credentials "
"(usually: effective UID, effective GID, and supplementary group list)."
msgstr ""
"権限のチェックを行う観点から見ると、伝統的な UNIX の実装では プロセスは二つの"
"カテゴリに分類できる: I<特権> プロセス (実効ユーザID が 0 のプロセス。ユーザ"
"ID 0 は スーパーユーザや root と呼ばれる) と I<非特権> プロセス (実効ユーザ"
"ID が 0 以外のプロセス) である。 非特権プロセスでは、プロセスの資格情報 (通常"
"は、実効UID 、実効GID と追加のグループリスト) に基づく権限チェックが行われる"
"のに対し、 特権プロセスでは全てのカーネルの権限チェックがバイパスされる。"

#. type: Plain text
#: build/C/man7/capabilities.7:70
msgid ""
"Starting with kernel 2.2, Linux divides the privileges traditionally "
"associated with superuser into distinct units, known as I<capabilities>, "
"which can be independently enabled and disabled.  Capabilities are a per-"
"thread attribute."
msgstr ""
"バージョン 2.2 以降の Linux では、 これまでスーパーユーザに結び付けられてきた"
"権限を、 いくつかのグループに分割している。これらのグループは I<ケーパビリ"
"ティ>(capability)  と呼ばれ、グループ毎に独立に有効、無効を設定できる。 ケー"
"パビリティはスレッド単位の属性である。"

#. type: SS
#: build/C/man7/capabilities.7:70
#, no-wrap
msgid "Capabilities list"
msgstr "ケーパビリティのリスト"

#. type: Plain text
#: build/C/man7/capabilities.7:73
msgid ""
"The following list shows the capabilities implemented on Linux, and the "
"operations or behaviors that each capability permits:"
msgstr ""
"以下のリストは、 Linux で実装されているケーパビリティと 各ケーパビリティが許"
"可する操作と動作をまとめたものである。"

#. type: TP
#: build/C/man7/capabilities.7:73
#, no-wrap
msgid "B<CAP_AUDIT_CONTROL> (since Linux 2.6.11)"
msgstr "B<CAP_AUDIT_CONTROL> (Linux 2.6.11 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:77
msgid ""
"Enable and disable kernel auditing; change auditing filter rules; retrieve "
"auditing status and filtering rules."
msgstr ""
"カーネル監査 (audit) の有効無効の切り替え、 監査のフィルタルールの変更、 監査"
"の状況やフィルタルールの取得ができる。"

#. type: TP
#: build/C/man7/capabilities.7:77
#, no-wrap
msgid "B<CAP_AUDIT_WRITE> (since Linux 2.6.11)"
msgstr "B<CAP_AUDIT_WRITE> (Linux 2.6.11 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:80
msgid "Write records to kernel auditing log."
msgstr "カーネル監査のログにレコードを書き込む。"

#. type: TP
#: build/C/man7/capabilities.7:80
#, no-wrap
msgid "B<CAP_BLOCK_SUSPEND> (since Linux 3.5)"
msgstr "B<CAP_BLOCK_SUSPEND> (Linux 3.5 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:86
msgid ""
"Employ features that can block system suspend (B<epoll>(7)  B<EPOLLWAKEUP>, "
"I</proc/sys/wake_lock>)."
msgstr ""
"システムのサスペンドをブロックできる機能を使用する (B<epoll>(7)  "
"B<EPOLLWAKEUP>, I</proc/sys/wake_lock>)。"

#. type: TP
#: build/C/man7/capabilities.7:86
#, no-wrap
msgid "B<CAP_CHOWN>"
msgstr "B<CAP_CHOWN>"

#. type: Plain text
#: build/C/man7/capabilities.7:90
msgid "Make arbitrary changes to file UIDs and GIDs (see B<chown>(2))."
msgstr "ファイルの UID とGID を任意に変更する (B<chown>(2)  参照)。"

#. type: TP
#: build/C/man7/capabilities.7:90
#, no-wrap
msgid "B<CAP_DAC_OVERRIDE>"
msgstr "B<CAP_DAC_OVERRIDE>"

#. type: Plain text
#: build/C/man7/capabilities.7:94
msgid ""
"Bypass file read, write, and execute permission checks.  (DAC is an "
"abbreviation of \"discretionary access control\".)"
msgstr ""
"ファイルの読み出し、書き込み、実行の権限チェックをバイパスする (DAC は "
"\"discretionary access control (任意のアクセス制御)\" の略である)。"

#. type: TP
#: build/C/man7/capabilities.7:94
#, no-wrap
msgid "B<CAP_DAC_READ_SEARCH>"
msgstr "B<CAP_DAC_READ_SEARCH>"

#. type: IP
#: build/C/man7/capabilities.7:98 build/C/man7/capabilities.7:101
#: build/C/man7/capabilities.7:111 build/C/man7/capabilities.7:121
#: build/C/man7/capabilities.7:125 build/C/man7/capabilities.7:127
#: build/C/man7/capabilities.7:129 build/C/man7/capabilities.7:199
#: build/C/man7/capabilities.7:201 build/C/man7/capabilities.7:203
#: build/C/man7/capabilities.7:205 build/C/man7/capabilities.7:207
#: build/C/man7/capabilities.7:209 build/C/man7/capabilities.7:211
#: build/C/man7/capabilities.7:213 build/C/man7/capabilities.7:215
#: build/C/man7/capabilities.7:239 build/C/man7/capabilities.7:241
#: build/C/man7/capabilities.7:287 build/C/man7/capabilities.7:297
#: build/C/man7/capabilities.7:303 build/C/man7/capabilities.7:308
#: build/C/man7/capabilities.7:314 build/C/man7/capabilities.7:321
#: build/C/man7/capabilities.7:324 build/C/man7/capabilities.7:332
#: build/C/man7/capabilities.7:334 build/C/man7/capabilities.7:343
#: build/C/man7/capabilities.7:350 build/C/man7/capabilities.7:353
#: build/C/man7/capabilities.7:357 build/C/man7/capabilities.7:360
#: build/C/man7/capabilities.7:363 build/C/man7/capabilities.7:370
#: build/C/man7/capabilities.7:375 build/C/man7/capabilities.7:381
#: build/C/man7/capabilities.7:385 build/C/man7/capabilities.7:389
#: build/C/man7/capabilities.7:393 build/C/man7/capabilities.7:397
#: build/C/man7/capabilities.7:424 build/C/man7/capabilities.7:429
#: build/C/man7/capabilities.7:434 build/C/man7/capabilities.7:437
#: build/C/man7/capabilities.7:440 build/C/man7/capabilities.7:449
#: build/C/man7/capabilities.7:453 build/C/man7/capabilities.7:479
#: build/C/man7/capabilities.7:484 build/C/man7/capabilities.7:487
#: build/C/man7/capabilities.7:492 build/C/man7/capabilities.7:495
#: build/C/man7/capabilities.7:498 build/C/man7/capabilities.7:501
#: build/C/man7/capabilities.7:504 build/C/man7/capabilities.7:509
#: build/C/man7/capabilities.7:511 build/C/man7/capabilities.7:517
#: build/C/man7/capabilities.7:525 build/C/man7/capabilities.7:527
#: build/C/man7/capabilities.7:531 build/C/man7/capabilities.7:533
#: build/C/man7/capabilities.7:536 build/C/man7/capabilities.7:540
#: build/C/man7/capabilities.7:542 build/C/man7/capabilities.7:544
#: build/C/man7/capabilities.7:546 build/C/man7/capabilities.7:555
#: build/C/man7/capabilities.7:562 build/C/man7/capabilities.7:567
#: build/C/man7/capabilities.7:572 build/C/man7/capabilities.7:577
#: build/C/man7/capabilities.7:600 build/C/man7/capabilities.7:607
#: build/C/man7/capabilities.7:806 build/C/man7/capabilities.7:814
#: build/C/man7/capabilities.7:1130 build/C/man7/capabilities.7:1135
#: build/C/man7/cpuset.7:540 build/C/man7/cpuset.7:545
#: build/C/man7/cpuset.7:550 build/C/man7/cpuset.7:726
#: build/C/man7/cpuset.7:730 build/C/man7/cpuset.7:927
#: build/C/man7/cpuset.7:930 build/C/man7/cpuset.7:934
#: build/C/man7/cpuset.7:938 build/C/man7/cpuset.7:942
#: build/C/man7/credentials.7:125 build/C/man7/credentials.7:131
#: build/C/man7/credentials.7:143 build/C/man7/credentials.7:165
#: build/C/man7/credentials.7:182 build/C/man7/credentials.7:214
#: build/C/man7/credentials.7:217 build/C/man7/credentials.7:227
#: build/C/man7/credentials.7:230
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man7/capabilities.7:101
#, fuzzy
#| msgid ""
#| "Bypass file read permission checks and directory read and execute "
#| "permission checks."
msgid ""
"Bypass file read permission checks and directory read and execute permission "
"checks;"
msgstr ""
"ファイルの読み出し権限のチェックとディレクトリの読み出しと実行 の権限チェック"
"をバイパスする。"

#. type: Plain text
#: build/C/man7/capabilities.7:104
msgid "Invoke B<open_by_handle_at>(2)."
msgstr ""

#. type: TP
#: build/C/man7/capabilities.7:107
#, no-wrap
msgid "B<CAP_FOWNER>"
msgstr "B<CAP_FOWNER>"

#. type: Plain text
#: build/C/man7/capabilities.7:121
msgid ""
"Bypass permission checks on operations that normally require the file system "
"UID of the process to match the UID of the file (e.g., B<chmod>(2), B<utime>"
"(2)), excluding those operations covered by B<CAP_DAC_OVERRIDE> and "
"B<CAP_DAC_READ_SEARCH>;"
msgstr ""
"通常、プロセスのファイルシステム UID がファイルの UID に一致することが 要求さ"
"れる操作 (例えば B<chmod>(2), B<utime>(2))  における権限チェックをバイパスす"
"る。 但し、 B<CAP_DAC_OVERRIDE> か B<CAP_DAC_READ_SEARCH> によりチェックが行"
"われる操作は除く。"

#. type: Plain text
#: build/C/man7/capabilities.7:125
msgid "set extended file attributes (see B<chattr>(1))  on arbitrary files;"
msgstr ""
"任意のファイルに対して拡張ファイル属性を設定する (B<chattr>(1)  参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:127
msgid "set Access Control Lists (ACLs) on arbitrary files;"
msgstr "任意のファイルに対してアクセス制御リスト (ACL) を設定する。"

#. type: Plain text
#: build/C/man7/capabilities.7:129
msgid "ignore directory sticky bit on file deletion;"
msgstr "ファイルの削除の際にディレクトリのスティッキービットを無視する。"

#. type: Plain text
#: build/C/man7/capabilities.7:136
msgid ""
"specify B<O_NOATIME> for arbitrary files in B<open>(2)  and B<fcntl>(2)."
msgstr ""
"B<open>(2)  や B<fcntl>(2)  で任意のファイルに対して B<O_NOATIME> を指定す"
"る。"

#. type: TP
#: build/C/man7/capabilities.7:138
#, no-wrap
msgid "B<CAP_FSETID>"
msgstr "B<CAP_FSETID>"

#. type: Plain text
#: build/C/man7/capabilities.7:144
msgid ""
"Don't clear set-user-ID and set-group-ID permission bits when a file is "
"modified; set the set-group-ID bit for a file whose GID does not match the "
"file system or any of the supplementary GIDs of the calling process."
msgstr ""
"ファイルが変更されたときに set-user-ID とset-group-ID の許可ビットをクリア し"
"ない。呼び出し元プロセスのファイルシステム GID と追加の GID のいずれとも GID "
"が一致しないファイルに対して set-group-ID ビットを設定する。"

#. type: TP
#: build/C/man7/capabilities.7:144
#, no-wrap
msgid "B<CAP_IPC_LOCK>"
msgstr "B<CAP_IPC_LOCK>"

#.  FIXME As at Linux 3.2, there are some strange uses of this capability
#.  in other places; they probably should be replaced with something else.
#. type: Plain text
#: build/C/man7/capabilities.7:153
msgid "Lock memory (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))."
msgstr ""
"メモリーのロック (B<mlock>(2), B<mlockall>(2), B<mmap>(2), B<shmctl>(2))  を"
"行う。"

#. type: TP
#: build/C/man7/capabilities.7:153
#, no-wrap
msgid "B<CAP_IPC_OWNER>"
msgstr "B<CAP_IPC_OWNER>"

#. type: Plain text
#: build/C/man7/capabilities.7:156
msgid "Bypass permission checks for operations on System V IPC objects."
msgstr ""
"System V IPC オブジェクトに対する操作に関して権限チェックをバイパスする。"

#. type: TP
#: build/C/man7/capabilities.7:156
#, no-wrap
msgid "B<CAP_KILL>"
msgstr "B<CAP_KILL>"

#.  FIXME CAP_KILL also has an effect for threads + setting child
#.        termination signal to other than SIGCHLD: without this
#.        capability, the termination signal reverts to SIGCHLD
#.        if the child does an exec().  What is the rationale
#.        for this?
#. type: Plain text
#: build/C/man7/capabilities.7:169
msgid ""
"Bypass permission checks for sending signals (see B<kill>(2)).  This "
"includes use of the B<ioctl>(2)  B<KDSIGACCEPT> operation."
msgstr ""
"シグナルを送信する際に権限チェックをバイパスする (B<kill>(2)  参照)。これに"
"は B<ioctl>(2)  の B<KDSIGACCEPT> 操作の使用も含まれる。"

#. type: TP
#: build/C/man7/capabilities.7:169
#, no-wrap
msgid "B<CAP_LEASE> (since Linux 2.4)"
msgstr "B<CAP_LEASE> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:173
msgid "Establish leases on arbitrary files (see B<fcntl>(2))."
msgstr "任意のファイルに対して ファイルリースを設定する (B<fcntl>(2)  参照)。"

#. type: TP
#: build/C/man7/capabilities.7:173
#, no-wrap
msgid "B<CAP_LINUX_IMMUTABLE>"
msgstr "B<CAP_LINUX_IMMUTABLE>"

#.  These attributes are now available on ext2, ext3, Reiserfs, XFS, JFS
#. type: Plain text
#: build/C/man7/capabilities.7:182
msgid ""
"Set the B<FS_APPEND_FL> and B<FS_IMMUTABLE_FL> i-node flags (see B<chattr>"
"(1))."
msgstr ""
"拡張ファイル属性 B<FS_APPEND_FL> と B<FS_IMMUTABLE_FL> を設定する (B<chattr>"
"(1)  参照)。"

#. type: TP
#: build/C/man7/capabilities.7:182
#, no-wrap
msgid "B<CAP_MAC_ADMIN> (since Linux 2.6.25)"
msgstr "B<CAP_MAC_ADMIN> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:186
msgid ""
"Override Mandatory Access Control (MAC).  Implemented for the Smack Linux "
"Security Module (LSM)."
msgstr ""
"強制アクセス制御 (MAC) を上書きする。 Smack Linux Security Module (LSM) 用に"
"実装されている。"

#. type: TP
#: build/C/man7/capabilities.7:186
#, no-wrap
msgid "B<CAP_MAC_OVERRIDE> (since Linux 2.6.25)"
msgstr "B<CAP_MAC_OVERRIDE> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:190
msgid ""
"Allow MAC configuration or state changes.  Implemented for the Smack LSM."
msgstr "MAC の設定や状態を変更する。 Smack LSM 用に実装されている。"

#. type: TP
#: build/C/man7/capabilities.7:190
#, no-wrap
msgid "B<CAP_MKNOD> (since Linux 2.4)"
msgstr "B<CAP_MKNOD> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:194
msgid "Create special files using B<mknod>(2)."
msgstr ""
"(Linux 2.4 以降)  B<mknod>(2)  を使用してスペシャルファイルを作成する。"

#. type: TP
#: build/C/man7/capabilities.7:194
#, no-wrap
msgid "B<CAP_NET_ADMIN>"
msgstr "B<CAP_NET_ADMIN>"

#. type: Plain text
#: build/C/man7/capabilities.7:197
msgid "Perform various network-related operations:"
msgstr "各種のネットワーク関係の操作を実行する:"

#. type: Plain text
#: build/C/man7/capabilities.7:201
msgid "interface configuration;"
msgstr "インターフェースの設定"

#. type: Plain text
#: build/C/man7/capabilities.7:203
msgid "administration of IP firewall, masquerading, and accounting;"
msgstr "IP のファイアウォール、マスカレード、アカウンティング"

#. type: Plain text
#: build/C/man7/capabilities.7:205
msgid "modify routing tables;"
msgstr "ルーティングテーブルの変更"

#. type: Plain text
#: build/C/man7/capabilities.7:207
msgid "bind to any address for transparent proxying;"
msgstr "透過的プロキシでの任意のアドレスの割り当て (bind)"

#. type: Plain text
#: build/C/man7/capabilities.7:209
msgid "set type-of-service (TOS)"
msgstr "サービス種別 (type-of-service; TOS) のセット"

#. type: Plain text
#: build/C/man7/capabilities.7:211
msgid "clear driver statistics;"
msgstr "ドライバの統計情報のクリア"

#. type: Plain text
#: build/C/man7/capabilities.7:213
msgid "set promiscuous mode;"
msgstr "promiscuous モードをセットする"

#. type: Plain text
#: build/C/man7/capabilities.7:215
msgid "enabling multicasting;"
msgstr "マルチキャストを有効にする"

#. type: Plain text
#: build/C/man7/capabilities.7:226
msgid ""
"use B<setsockopt>(2)  to set the following socket options: B<SO_DEBUG>, "
"B<SO_MARK>, B<SO_PRIORITY> (for a priority outside the range 0 to 6), "
"B<SO_RCVBUFFORCE>, and B<SO_SNDBUFFORCE>."
msgstr ""
"B<setsockopt>(2) を使って以下のソケットオプションを設定する:\n"
"B<SO_DEBUG>, B<SO_MARK>, \n"
"B<SO_PRIORITY> (優先度を 0 から 6 以外に設定する場合),\n"
"B<SO_RCVBUFFORCE>, and B<SO_SNDBUFFORCE>"

#. type: TP
#: build/C/man7/capabilities.7:228
#, no-wrap
msgid "B<CAP_NET_BIND_SERVICE>"
msgstr "B<CAP_NET_BIND_SERVICE>"

#. type: Plain text
#: build/C/man7/capabilities.7:232
msgid ""
"Bind a socket to Internet domain privileged ports (port numbers less than "
"1024)."
msgstr ""
"インターネットドメインの特権ポート (ポート番号が 1024 番未満)  をバインドでき"
"る。"

#. type: TP
#: build/C/man7/capabilities.7:232
#, no-wrap
msgid "B<CAP_NET_BROADCAST>"
msgstr "B<CAP_NET_BROADCAST>"

#. type: Plain text
#: build/C/man7/capabilities.7:235
msgid "(Unused)  Make socket broadcasts, and listen to multicasts."
msgstr ""
"(未使用) ソケットのブロードキャストと、マルチキャストの待ち受けを行う。"

#. type: TP
#: build/C/man7/capabilities.7:235
#, no-wrap
msgid "B<CAP_NET_RAW>"
msgstr "B<CAP_NET_RAW>"

#. type: Plain text
#: build/C/man7/capabilities.7:241
msgid "use RAW and PACKET sockets;"
msgstr "RAW ソケットと PACKET ソケットを使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:243
msgid "bind to any address for transparent proxying."
msgstr "透過的プロキシでの任意のアドレスの割り当て (bind)"

#. type: TP
#: build/C/man7/capabilities.7:246
#, no-wrap
msgid "B<CAP_SETGID>"
msgstr "B<CAP_SETGID>"

#. type: Plain text
#: build/C/man7/capabilities.7:250
msgid ""
"Make arbitrary manipulations of process GIDs and supplementary GID list; "
"forge GID when passing socket credentials via UNIX domain sockets."
msgstr ""
"プロセスの GID と追加の GID リストに対する任意の操作を行う。 UNIX ドメインソ"
"ケット経由でソケットの資格情報 (credential) を渡す際に 偽の GID を渡すことが"
"できる。"

#. type: TP
#: build/C/man7/capabilities.7:250
#, no-wrap
msgid "B<CAP_SETFCAP> (since Linux 2.6.24)"
msgstr "B<CAP_SETFCAP> (Linux 2.6.24 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:253
msgid "Set file capabilities."
msgstr "ファイルケーパビリティを設定する。"

#. type: TP
#: build/C/man7/capabilities.7:253
#, no-wrap
msgid "B<CAP_SETPCAP>"
msgstr "B<CAP_SETPCAP>"

#. type: Plain text
#: build/C/man7/capabilities.7:264
msgid ""
"If file capabilities are not supported: grant or remove any capability in "
"the caller's permitted capability set to or from any other process.  (This "
"property of B<CAP_SETPCAP> is not available when the kernel is configured to "
"support file capabilities, since B<CAP_SETPCAP> has entirely different "
"semantics for such kernels.)"
msgstr ""
"ファイルケーパビリティがサポートされていない場合: 呼び出し元が許可されている"
"ケーパビリティセットに含まれる任意のケーパビリティを、 他のプロセスに付与した"
"り、削除したりできる。 (カーネルがファイルケーパビリティをサポートしている場"
"合、 B<CAP_SETPCAP> はこの役割を持たない。 なぜなら、ファイルケーパビリティを"
"サポートしているカーネルでは B<CAP_SETPCAP> は全く別の意味を持つからである。)"

#. type: Plain text
#: build/C/man7/capabilities.7:274
msgid ""
"If file capabilities are supported: add any capability from the calling "
"thread's bounding set to its inheritable set; drop capabilities from the "
"bounding set (via B<prctl>(2)  B<PR_CAPBSET_DROP>); make changes to the "
"I<securebits> flags."
msgstr ""
"ファイルケーパビリティがサポートされている場合: 呼び出し元スレッドのバウン"
"ディングセットの任意のケーパビリティを 自身の継承可能ケーパビリティセットに追"
"加できる。 (B<prctl>(2)  B<PR_CAPBSET_DROP> を使って)  バウンディングセットか"
"らケーパビリティを削除できる。 I<securebits> フラグを変更できる。"

#. type: TP
#: build/C/man7/capabilities.7:274
#, no-wrap
msgid "B<CAP_SETUID>"
msgstr "B<CAP_SETUID>"

#.  FIXME CAP_SETUID also an effect in exec(); document this.
#. type: Plain text
#: build/C/man7/capabilities.7:283
msgid ""
"Make arbitrary manipulations of process UIDs (B<setuid>(2), B<setreuid>(2), "
"B<setresuid>(2), B<setfsuid>(2)); make forged UID when passing socket "
"credentials via UNIX domain sockets."
msgstr ""
"プロセスの UID に対する任意の操作 (B<setuid>(2), B<setreuid>(2), B<setresuid>"
"(2), B<setfsuid>(2))  を行う。 UNIX ドメインソケット経由でソケットの資格情報 "
"(credential) を渡す際に 偽の UID を渡すことができる。"

#. type: TP
#: build/C/man7/capabilities.7:283
#, no-wrap
msgid "B<CAP_SYS_ADMIN>"
msgstr "B<CAP_SYS_ADMIN>"

#. type: Plain text
#: build/C/man7/capabilities.7:297
msgid ""
"Perform a range of system administration operations including: B<quotactl>"
"(2), B<mount>(2), B<umount>(2), B<swapon>(2), B<swapoff>(2), B<sethostname>"
"(2), and B<setdomainname>(2);"
msgstr ""
"以下のシステム管理用の操作を実行する: B<quotactl>(2), B<mount>(2), B<umount>"
"(2), B<swapon>(2), B<swapoff>(2), B<sethostname>(2), B<setdomainname>(2)."

#. type: Plain text
#: build/C/man7/capabilities.7:303
msgid ""
"perform privileged B<syslog>(2)  operations (since Linux 2.6.37, "
"B<CAP_SYSLOG> should be used to permit such operations);"
msgstr ""
"特権が必要な B<syslog>(2) の操作を実行する\n"
"(Linux 2.6.37 以降では、このような操作を許可するには\n"
"B<CAP_SYSLOG> を使うべきである)"

#. type: Plain text
#: build/C/man7/capabilities.7:308
msgid "perform B<VM86_REQUEST_IRQ> B<vm86>(2)  command;"
msgstr "B<VM86_REQUEST_IRQ> B<vm86>(2) コマンドを実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:314
msgid ""
"perform B<IPC_SET> and B<IPC_RMID> operations on arbitrary System V IPC "
"objects;"
msgstr ""
"任意の System V IPC オブジェクトに対する B<IPC_SET> と B<IPC_RMID> 操作を実行"
"する。"

#. type: Plain text
#: build/C/man7/capabilities.7:321
msgid ""
"perform operations on I<trusted> and I<security> Extended Attributes (see "
"B<attr>(5));"
msgstr ""
"拡張属性 I<trusted> と I<security> に対する操作を実行する (B<attr>(5)  参"
"照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:324
msgid "use B<lookup_dcookie>(2);"
msgstr "B<lookup_dcookie>(2)  を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:332
msgid ""
"use B<ioprio_set>(2)  to assign B<IOPRIO_CLASS_RT> and (before Linux "
"2.6.25)  B<IOPRIO_CLASS_IDLE> I/O scheduling classes;"
msgstr ""
"B<ioprio_set>(2)  を使って I/O スケジューリングクラス B<IOPRIO_CLASS_RT>, "
"B<IOPRIO_CLASS_IDLE> を割り当てる (B<IOPRIO_CLASS_IDLE> は Linux 2.6.25 より"
"前のバージョンのみ)。"

#. type: Plain text
#: build/C/man7/capabilities.7:334
msgid "forge UID when passing socket credentials;"
msgstr "ソケットの資格情報 (credential) を渡す際に偽の UID を渡す。"

#. type: Plain text
#: build/C/man7/capabilities.7:343
msgid ""
"exceed I</proc/sys/fs/file-max>, the system-wide limit on the number of open "
"files, in system calls that open files (e.g., B<accept>(2), B<execve>(2), "
"B<open>(2), B<pipe>(2));"
msgstr ""
"ファイルをオープンするシステムコール (例えば B<accept>(2), B<execve>(2), "
"B<open>(2), B<pipe>(2))  でシステム全体でオープンできるファイル数の上限 I</"
"proc/sys/fs/file-max> を超過する。"

#. type: Plain text
#: build/C/man7/capabilities.7:350
msgid ""
"employ B<CLONE_*> flags that create new namespaces with B<clone>(2)  and "
"B<unshare>(2);"
msgstr ""
"B<clone>(2) と B<unshare>(2) で新しい名前空間を作成する B<CLONE_*> \n"
"フラグを利用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:353
msgid "call B<perf_event_open>(2);"
msgstr "B<perf_event_open>(2) を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:357
msgid "access privileged I<perf> event information;"
msgstr "特権が必要な I<perf> イベントの情報にアクセスする。"

#. type: Plain text
#: build/C/man7/capabilities.7:360
msgid "call B<setns>(2);"
msgstr "B<setns>(2) を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:363
msgid "call B<fanotify_init>(2);"
msgstr "B<fanotify_init>(2) を呼び出す。"

#. type: Plain text
#: build/C/man7/capabilities.7:370
msgid "perform B<KEYCTL_CHOWN> and B<KEYCTL_SETPERM> B<keyctl>(2)  operations;"
msgstr "B<keyctl>(2)  の B<KEYCTL_CHOWN> と B<KEYCTL_SETPERM> 操作を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:375
msgid "perform B<madvise>(2)  B<MADV_HWPOISON> operation;"
msgstr "B<madvise>(2)  の B<MADV_HWPOISON> 操作を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:381
msgid ""
"employ the B<TIOCSTI> B<ioctl>(2)  to insert characters into the input queue "
"of a terminal other than the caller's controlling terminal."
msgstr ""
"B<TIOCSTI> B<ioctl>(2) を使って、\n"
"呼び出し元の制御端末以外の端末の入力キューに文字を挿入する。"

#. type: Plain text
#: build/C/man7/capabilities.7:385
msgid "employ the obsolete B<nfsservctl>(2)  system call;"
msgstr "廃止予定の B<nfsservctl>(2) システムコールを使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:389
msgid "employ the obsolete B<bdflush>(2)  system call;"
msgstr "廃止予定の B<bdflush>(2) システムコールを使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:393
msgid "perform various privileged block-device B<ioctl>(2)  operations;"
msgstr ""
"特権が必要なブロックデバイスに対する各種の B<ioctl>(2) 操作を\n"
"実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:397
msgid "perform various privileged file-system B<ioctl>(2)  operations;"
msgstr ""
"特権が必要なファイルシステムに対する各種の B<ioctl>(2) 操作を\n"
"実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:399
msgid "perform administrative operations on many device drivers."
msgstr "多くのデバイスドライバに対する管理命令を実行する。"

#. type: TP
#: build/C/man7/capabilities.7:401
#, no-wrap
msgid "B<CAP_SYS_BOOT>"
msgstr "B<CAP_SYS_BOOT>"

#. type: Plain text
#: build/C/man7/capabilities.7:407
msgid "Use B<reboot>(2)  and B<kexec_load>(2)."
msgstr "B<reboot>(2)  と B<kexec_load>(2)  を呼び出す。"

#. type: TP
#: build/C/man7/capabilities.7:407
#, no-wrap
msgid "B<CAP_SYS_CHROOT>"
msgstr "B<CAP_SYS_CHROOT>"

#. type: Plain text
#: build/C/man7/capabilities.7:411
msgid "Use B<chroot>(2)."
msgstr "B<chroot>(2).  を呼び出す。"

#. type: TP
#: build/C/man7/capabilities.7:411
#, no-wrap
msgid "B<CAP_SYS_MODULE>"
msgstr "B<CAP_SYS_MODULE>"

#. type: Plain text
#: build/C/man7/capabilities.7:420
msgid ""
"Load and unload kernel modules (see B<init_module>(2)  and B<delete_module>"
"(2)); in kernels before 2.6.25: drop capabilities from the system-wide "
"capability bounding set."
msgstr ""
"カーネルモジュールのロード、アンロードを行う (B<init_module>(2)  と "
"B<delete_module>(2)  を参照のこと)。 バージョン 2.6.25 より前のカーネルで、 "
"システム全体のケーパビリティバウンディングセット (capability bounding set)  "
"からケーパビリティを外す。"

#. type: TP
#: build/C/man7/capabilities.7:420
#, no-wrap
msgid "B<CAP_SYS_NICE>"
msgstr "B<CAP_SYS_NICE>"

#. type: Plain text
#: build/C/man7/capabilities.7:429
msgid ""
"Raise process nice value (B<nice>(2), B<setpriority>(2))  and change the "
"nice value for arbitrary processes;"
msgstr ""
"プロセスの nice 値の引き上げ (B<nice>(2), B<setpriority>(2))  や、任意のプロ"
"セスの nice 値の変更を行う。"

#. type: Plain text
#: build/C/man7/capabilities.7:434
msgid ""
"set real-time scheduling policies for calling process, and set scheduling "
"policies and priorities for arbitrary processes (B<sched_setscheduler>(2), "
"B<sched_setparam>(2));"
msgstr ""
"呼び出し元プロセスに対するリアルタイムスケジューリングポリシーと、 任意のプロ"
"セスに対するスケジューリングポリシーと優先度を設定する (B<sched_setscheduler>"
"(2), B<sched_setparam>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:437
msgid "set CPU affinity for arbitrary processes (B<sched_setaffinity>(2));"
msgstr ""
"任意のプロセスに対する CPU affinity を設定できる (B<sched_setaffinity>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:440
msgid ""
"set I/O scheduling class and priority for arbitrary processes (B<ioprio_set>"
"(2));"
msgstr ""
"任意のプロセスに対して I/O スケジューリングクラスと優先度を設定できる "
"(B<ioprio_set>(2))。"

#.  FIXME CAP_SYS_NICE also has the following effect for
#.  migrate_pages(2):
#.      do_migrate_pages(mm, &old, &new,
#.          capable(CAP_SYS_NICE) ? MPOL_MF_MOVE_ALL : MPOL_MF_MOVE);
#. type: Plain text
#: build/C/man7/capabilities.7:449
msgid ""
"apply B<migrate_pages>(2)  to arbitrary processes and allow processes to be "
"migrated to arbitrary nodes;"
msgstr ""
"B<migrate_pages>(2)  を任意のプロセスに適用し、プロセスを任意のノードに移動す"
"る。"

#. type: Plain text
#: build/C/man7/capabilities.7:453
msgid "apply B<move_pages>(2)  to arbitrary processes;"
msgstr "B<move_pages>(2)  を任意のプロセスに対して行う。"

#. type: Plain text
#: build/C/man7/capabilities.7:460
msgid ""
"use the B<MPOL_MF_MOVE_ALL> flag with B<mbind>(2)  and B<move_pages>(2)."
msgstr ""
"B<mbind>(2)  と B<move_pages>(2)  で B<MPOL_MF_MOVE_ALL> フラグを使用する。"

#. type: TP
#: build/C/man7/capabilities.7:462
#, no-wrap
msgid "B<CAP_SYS_PACCT>"
msgstr "B<CAP_SYS_PACCT>"

#. type: Plain text
#: build/C/man7/capabilities.7:466
msgid "Use B<acct>(2)."
msgstr "B<acct>(2)  を呼び出す。"

#. type: TP
#: build/C/man7/capabilities.7:466
#, no-wrap
msgid "B<CAP_SYS_PTRACE>"
msgstr "B<CAP_SYS_PTRACE>"

#. type: Plain text
#: build/C/man7/capabilities.7:475
msgid ""
"Trace arbitrary processes using B<ptrace>(2); apply B<get_robust_list>(2)  "
"to arbitrary processes; inspect processes using B<kcmp>(2)."
msgstr ""
"B<ptrace>(2)  を使って任意のプロセスをトレースする。 任意のプロセスに "
"B<get_robust_list>(2)  を適用する。 B<kcmp>(2) を使ってプロセス内部を調査す"
"る。"

#. type: TP
#: build/C/man7/capabilities.7:475
#, no-wrap
msgid "B<CAP_SYS_RAWIO>"
msgstr "B<CAP_SYS_RAWIO>"

#. type: Plain text
#: build/C/man7/capabilities.7:484
msgid "Perform I/O port operations (B<iopl>(2)  and B<ioperm>(2));"
msgstr "I/O ポート操作を実行する (B<iopl>(2)、 B<ioperm>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:487
msgid "access I</proc/kcore>;"
msgstr "I</proc/kcore> にアクセスする。"

#. type: Plain text
#: build/C/man7/capabilities.7:492
msgid "employ the B<FIBMAP> B<ioctl>(2)  operation;"
msgstr "B<FIBMAP> B<ioctl>(2) 操作を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:495
msgid ""
"open devices for accessing x86 model-specific registers (MSRs, see B<msr>(4))"
msgstr ""
"x86 モデルに固有のレジスタ (MSR レジスタ群、 B<msr>(4) 参照) にアクセスするた"
"めのデバイスをオープンする。"

#. type: Plain text
#: build/C/man7/capabilities.7:498
msgid "update I</proc/sys/vm/mmap_min_addr>;"
msgstr "I</proc/sys/vm/mmap_min_addr> を更新する。"

#. type: Plain text
#: build/C/man7/capabilities.7:501
msgid ""
"create memory mappings at addresses below the value specified by I</proc/sys/"
"vm/mmap_min_addr>;"
msgstr ""
"I</proc/sys/vm/mmap_min_addr> で指定された値よりも小さなアドレスにメモリマッ"
"ピングを作成する。"

#. type: Plain text
#: build/C/man7/capabilities.7:504
msgid "map files in I</proc/bus/pci>;"
msgstr "I</proc/bus/pci> にあるファイルをマップする。"

#. type: Plain text
#: build/C/man7/capabilities.7:509
msgid "open I</dev/mem> and I</dev/kmem>;"
msgstr "I</dev/mem> や I</dev/kmem> をオープンする。"

#. type: Plain text
#: build/C/man7/capabilities.7:511
msgid "perform various SCSI device commands;"
msgstr "各種の SCSI デバイスコマンドを実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:517
msgid "perform certain operations on B<hpsa>(4)  and B<cciss>(4)  devices;"
msgstr "B<hpsa>(4) デバイスや B<cciss>(4) デバイスの特定の操作を実行する。"

#. type: Plain text
#: build/C/man7/capabilities.7:519
msgid "perform a range of device-specific operations on other devices."
msgstr "他のデバイスに対して各種のデバイス固有命令を実行する。"

#. type: TP
#: build/C/man7/capabilities.7:521
#, no-wrap
msgid "B<CAP_SYS_RESOURCE>"
msgstr "B<CAP_SYS_RESOURCE>"

#. type: Plain text
#: build/C/man7/capabilities.7:527
msgid "Use reserved space on ext2 file systems;"
msgstr "ext2 ファイルシステム上の予約されている領域を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:531
msgid "make B<ioctl>(2)  calls controlling ext3 journaling;"
msgstr "ext3 のジャーナル機能を制御する B<ioctl>(2)  を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:533
msgid "override disk quota limits;"
msgstr "ディスク quota の上限を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:536
msgid "increase resource limits (see B<setrlimit>(2));"
msgstr "リソース上限を増やす (B<setrlimit>(2))。"

#. type: Plain text
#: build/C/man7/capabilities.7:540
msgid "override B<RLIMIT_NPROC> resource limit;"
msgstr "B<RLIMIT_NPROC> リソース制限を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:542
msgid "override maximum number of consoles on console allocation;"
msgstr "コンソール割り当てにおいてコンソールの最大数を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:544
msgid "override maximum number of keymaps;"
msgstr "キーマップの最大数を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:546
msgid "allow more than 64hz interrupts from the real-time clock;"
msgstr "リアルタイムクロックから秒間 64 回を越える回数の割り当てが許可する。"

#. type: Plain text
#: build/C/man7/capabilities.7:555
msgid ""
"raise I<msg_qbytes> limit for a System V message queue above the limit in I</"
"proc/sys/kernel/msgmnb> (see B<msgop>(2)  and B<msgctl>(2));"
msgstr ""
"メッセージキューに関する上限 I<msg_qbytes> を \n"
"I</proc/sys/kernel/msgmnb> に指定されている上限よりも大きく設定する\n"
"(B<msgop>(2) と B<msgctl>(2) 参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:562
msgid ""
"override the I</proc/sys/fs/pipe-size-max> limit when setting the capacity "
"of a pipe using the B<F_SETPIPE_SZ> B<fcntl>(2)  command."
msgstr ""
"B<F_SETPIPE_SZ> B<fcntl>(2) を使ってパイプの容量を設定する際に\n"
"上限 I</proc/sys/fs/pipe-size-max> を上書きする。"

#. type: Plain text
#: build/C/man7/capabilities.7:567
msgid ""
"use B<F_SETPIPE_SZ> to increase the capacity of a pipe above the limit "
"specified by I</proc/sys/fs/pipe-max-size>;"
msgstr ""
"I</proc/sys/fs/pipe-max-size> に指定されている上限を超えてパイプの容量\n"
"を増やすのに B<F_SETPIPE_SZ> を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:572
msgid ""
"override I</proc/sys/fs/mqueue/queues_max> limit when creating POSIX message "
"queues (see B<mq_overview>(7));"
msgstr ""
"POSIX メッセージキューを作成する際に、\n"
"上限 I</proc/sys/fs/mqueue/queues_max> を上書きする\n"
"(B<mq_overview>(7) 参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:577
msgid "employ B<prctl>(2)  B<PR_SET_MM> operation;"
msgstr "B<prctl>(2) B<PR_SET_MM> 操作を使用する。"

#. type: Plain text
#: build/C/man7/capabilities.7:582
msgid ""
"set I</proc/PID/oom_score_adj> to a value lower than the value last set by a "
"process with B<CAP_SYS_RESOURCE>."
msgstr ""
"B<CAP_SYS_RESOURCE> を持ったプロセスによって最後に設定された値よりも小さな値"
"を I</proc/PID/oom_score_adj> に設定する。"

#. type: TP
#: build/C/man7/capabilities.7:584
#, no-wrap
msgid "B<CAP_SYS_TIME>"
msgstr "B<CAP_SYS_TIME>"

#. type: Plain text
#: build/C/man7/capabilities.7:591
msgid ""
"Set system clock (B<settimeofday>(2), B<stime>(2), B<adjtimex>(2)); set real-"
"time (hardware) clock."
msgstr ""
"システムクロックを変更する (B<settimeofday>(2), B<stime>(2), B<adjtimex>"
"(2))。 リアルタイム (ハードウェア) クロックを変更する。"

#. type: TP
#: build/C/man7/capabilities.7:591
#, no-wrap
msgid "B<CAP_SYS_TTY_CONFIG>"
msgstr "B<CAP_SYS_TTY_CONFIG>"

#. type: Plain text
#: build/C/man7/capabilities.7:598
msgid ""
"Use B<vhangup>(2); employ various privileged B<ioctl>(2)  operations on "
"virtual terminals."
msgstr ""
"B<vhangup>(2) を使用する。\n"
"特権が必要な仮想端末に関する各種の B<ioctl>(2) 操作を利用できる。"

#. type: TP
#: build/C/man7/capabilities.7:598
#, no-wrap
msgid "B<CAP_SYSLOG> (since Linux 2.6.37)"
msgstr "B<CAP_SYSLOG> (Linux 2.6.37 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:607
msgid ""
"Perform privileged B<syslog>(2)  operations.  See B<syslog>(2)  for "
"information on which operations require privilege."
msgstr ""
"特権が必要な B<syslog>(2) 操作を実行できる。\n"
"どの操作が特権が必要かについての情報は B<syslog>(2) を参照。"

#. type: Plain text
#: build/C/man7/capabilities.7:617
msgid ""
"View kernel addresses exposed via I</proc> and other interfaces when I</proc/"
"sys/kernel/kptr_restrict> has the value 1.  (See the discussion of the "
"I<kptr_restrict> in B<proc>(5).)"
msgstr ""
"I</proc/sys/kernel/kptr_restrict> の値が 1 の場合、 I</proc> や他のインター"
"フェース経由で公開されているカーネルアドレスを参照する (B<proc>(5) の "
"I<kptr_restrict> の議論を参照)。"

#. type: TP
#: build/C/man7/capabilities.7:617
#, no-wrap
msgid "B<CAP_WAKE_ALARM> (since Linux 3.0)"
msgstr "B<CAP_WAKE_ALARM> (Linux 3.0 以降)"

#. type: Plain text
#: build/C/man7/capabilities.7:625
msgid ""
"Trigger something that will wake up the system (set B<CLOCK_REALTIME_ALARM> "
"and B<CLOCK_BOOTTIME_ALARM> timers)."
msgstr ""
"システムを起こすトリガーを有効にする (タイマー B<CLOCK_REALTIME_ALARM>\n"
"や B<CLOCK_BOOTTIME_ALARM> を設定する)。"

#. type: SS
#: build/C/man7/capabilities.7:625
#, no-wrap
msgid "Past and current implementation"
msgstr "過去と現在の実装"

#. type: Plain text
#: build/C/man7/capabilities.7:627
msgid "A full implementation of capabilities requires that:"
msgstr "完全な形のケーパビリティを実装するには、以下の要件を満たす必要がある："

#. type: IP
#: build/C/man7/capabilities.7:627 build/C/man7/capabilities.7:778
#: build/C/man7/capabilities.7:925 build/C/man7/capabilities.7:978
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man7/capabilities.7:631
msgid ""
"For all privileged operations, the kernel must check whether the thread has "
"the required capability in its effective set."
msgstr ""
"全ての特権操作について、カーネルはそのスレッドの実効ケーパビリティセットに 必"
"要なケーパビリティがあるかを確認する。"

#. type: IP
#: build/C/man7/capabilities.7:631 build/C/man7/capabilities.7:783
#: build/C/man7/capabilities.7:931 build/C/man7/capabilities.7:984
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man7/capabilities.7:634
msgid ""
"The kernel must provide system calls allowing a thread's capability sets to "
"be changed and retrieved."
msgstr ""
"カーネルで、あるスレッドのケーパビリティセットを変更したり、 取得したりできる"
"システムコールが提供される。"

#. type: IP
#: build/C/man7/capabilities.7:634 build/C/man7/capabilities.7:934
#: build/C/man7/capabilities.7:988
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man7/capabilities.7:637
msgid ""
"The file system must support attaching capabilities to an executable file, "
"so that a process gains those capabilities when the file is executed."
msgstr ""
"ファイルシステムが、実行可能ファイルにケーパビリティを付与でき、ファイル 実行"
"時にそのケーパビリティをプロセスが取得できるような機能をサポートする。"

#. type: Plain text
#: build/C/man7/capabilities.7:641
msgid ""
"Before kernel 2.6.24, only the first two of these requirements are met; "
"since kernel 2.6.24, all three requirements are met."
msgstr ""
"カーネル 2.6.24 より前では、最初の 2つの要件のみが満たされている。 カーネル "
"2.6.24 以降では、3つの要件すべてが満たされている。"

#. type: SS
#: build/C/man7/capabilities.7:641
#, no-wrap
msgid "Thread capability sets"
msgstr "スレッドケーパビリティセット"

#. type: Plain text
#: build/C/man7/capabilities.7:644
msgid ""
"Each thread has three capability sets containing zero or more of the above "
"capabilities:"
msgstr ""
"各スレッドは以下の 3種類のケーパビリティセットを持つ。各々のケーパビリティ"
"セットは 上記のケーパビリティの組み合わせである (全てのケーパビリティが無効で"
"もよい)。"

#. type: TP
#: build/C/man7/capabilities.7:644
#, no-wrap
msgid "I<Permitted>:"
msgstr "I<許可 (permitted)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:652
msgid ""
"This is a limiting superset for the effective capabilities that the thread "
"may assume.  It is also a limiting superset for the capabilities that may be "
"added to the inheritable set by a thread that does not have the "
"B<CAP_SETPCAP> capability in its effective set."
msgstr ""
"そのスレッドが持つことになっている実効ケーパビリティの 限定的なスーパーセット"
"である。 これは、実効ケーパビリティセットに B<CAP_SETPCAP> ケーパビリティを"
"持っていないスレッドが継承可能ケーパビリティセットに 追加可能なケーパビリティ"
"の限定的なスーパーセットでもある。"

#. type: Plain text
#: build/C/man7/capabilities.7:658
msgid ""
"If a thread drops a capability from its permitted set, it can never "
"reacquire that capability (unless it B<execve>(2)s either a set-user-ID-root "
"program, or a program whose associated file capabilities grant that "
"capability)."
msgstr ""
"許可ケーパビリティセットから削除してしまったケーパビリティは、 (set-user-ID-"
"root プログラムか、 そのケーパビリティをファイルケーパビリティで許可している"
"プログラムを B<execve>(2)  しない限りは) もう一度獲得することはできない。"

#. type: TP
#: build/C/man7/capabilities.7:658
#, no-wrap
msgid "I<Inheritable>:"
msgstr "I<継承可能 (inheritable)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:665
msgid ""
"This is a set of capabilities preserved across an B<execve>(2).  It provides "
"a mechanism for a process to assign capabilities to the permitted set of the "
"new program during an B<execve>(2)."
msgstr ""
"B<execve>(2)  を前後で保持されるケーパビリティセットである。 この仕組みを使う"
"ことで、あるプロセスが B<execve>(2)  を行う際に新しいプログラムの許可ケーパビ"
"リティセットとして 割り当てるケーパビリティを指定することができる。"

#. type: TP
#: build/C/man7/capabilities.7:665 build/C/man7/capabilities.7:715
#, no-wrap
msgid "I<Effective>:"
msgstr "I<実効 (effective)>:"

#. type: Plain text
#: build/C/man7/capabilities.7:669
msgid ""
"This is the set of capabilities used by the kernel to perform permission "
"checks for the thread."
msgstr ""
"カーネルがスレッドの権限 (permission) をチェックするときに 使用するケーパビリ"
"ティセットである。"

#. type: Plain text
#: build/C/man7/capabilities.7:675
msgid ""
"A child created via B<fork>(2)  inherits copies of its parent's capability "
"sets.  See below for a discussion of the treatment of capabilities during "
"B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成される子プロセスは、親のケーパビリティセットのコピーを継承"
"する。 B<execve>(2)  中のケーパビリティの扱いについては下記を参照のこと。"

#. type: Plain text
#: build/C/man7/capabilities.7:679
msgid ""
"Using B<capset>(2), a thread may manipulate its own capability sets (see "
"below)."
msgstr ""
"B<capset>(2)  を使うと、プロセスは自分自身のケーパビリティセット を操作するこ"
"とができる (下記参照)。"

#.  commit 73efc0394e148d0e15583e13712637831f926720
#. type: Plain text
#: build/C/man7/capabilities.7:688
msgid ""
"Since Linux 3.2, the file I</proc/sys/kernel/cap_last_cap> exposes the "
"numerical value of the highest capability supported by the running kernel; "
"this can be used to determine the highest bit that may be set in a "
"capability set."
msgstr ""
"Linux 3.2 以降では、 ファイル I</proc/sys/kernel/cap_last_cap> で、 実行中の"
"カーネルでサポートされているケーパビリティの最大値を参照できる。 この情報を"
"使って、 ケーパビリティセットに設定される可能性がある最上位ビットを判定するこ"
"とができる。"

#. type: SS
#: build/C/man7/capabilities.7:688
#, no-wrap
msgid "File capabilities"
msgstr "ファイルケーパビリティ"

#. type: Plain text
#: build/C/man7/capabilities.7:703
msgid ""
"Since kernel 2.6.24, the kernel supports associating capability sets with an "
"executable file using B<setcap>(8).  The file capability sets are stored in "
"an extended attribute (see B<setxattr>(2))  named I<security.capability>.  "
"Writing to this extended attribute requires the B<CAP_SETFCAP> capability.  "
"The file capability sets, in conjunction with the capability sets of the "
"thread, determine the capabilities of a thread after an B<execve>(2)."
msgstr ""
"カーネル 2.6.24 以降では、 B<setcap>(8)  を使って実行ファイルにケーパビリティ"
"セットを対応付けることができる。 ファイルケーパビリティセットは I<security."
"capability> という名前の拡張属性に保存される (B<setxattr>(2)  参照)。この拡張"
"属性への書き込みには B<CAP_SETFCAP> ケーパビリティが必要である。 ファイルケー"
"パビリティセットとスレッドのケーパビリティセットの両方が 考慮され、 B<execve>"
"(2)  後のスレッドのケーパビリティセットが決定される。"

#. type: Plain text
#: build/C/man7/capabilities.7:705
msgid "The three file capability sets are:"
msgstr "3 つのファイルケーパビリティセットが定義されている。"

#. type: TP
#: build/C/man7/capabilities.7:705
#, no-wrap
msgid "I<Permitted> (formerly known as I<forced>):"
msgstr "I<許可 (Permitted)> (以前のI<強制 (Forced)>):"

#. type: Plain text
#: build/C/man7/capabilities.7:709
msgid ""
"These capabilities are automatically permitted to the thread, regardless of "
"the thread's inheritable capabilities."
msgstr ""
"スレッドの継承可能ケーパビリティに関わらず、そのスレッドに自動的に 認められる"
"ケーパビリティ。"

#. type: TP
#: build/C/man7/capabilities.7:709
#, no-wrap
msgid "I<Inheritable> (formerly known as I<allowed>):"
msgstr "I<継承可能 (Inheritable)> (以前の I<許容 (Allowed)>):"

#. type: Plain text
#: build/C/man7/capabilities.7:715
msgid ""
"This set is ANDed with the thread's inheritable set to determine which "
"inheritable capabilities are enabled in the permitted set of the thread "
"after the B<execve>(2)."
msgstr ""
"このセットと、スレッドの継承可能ケーパビリティセットとの 論理積 (AND) がとら"
"れ、 B<execve>(2)  の後にそのスレッドの許可ケーパビリティセットで有効となる "
"継承可能ケーパビリティが決定される。"

#. type: Plain text
#: build/C/man7/capabilities.7:725
msgid ""
"This is not a set, but rather just a single bit.  If this bit is set, then "
"during an B<execve>(2)  all of the new permitted capabilities for the thread "
"are also raised in the effective set.  If this bit is not set, then after an "
"B<execve>(2), none of the new permitted capabilities is in the new effective "
"set."
msgstr ""
"これは集合ではなく、1 ビットの情報である。 このビットがセットされていると、 "
"B<execve>(2)  実行中に、そのスレッドの新しい許可ケーパビリティが全て 実効ケー"
"パビリティ集合においてもセットされる。 このビットがセットされていない場合、 "
"B<execve>(2)  後には新しい許可ケーパビリティのどれも新しい実効ケーパビリティ"
"集合 にセットされない。"

#. type: Plain text
#: build/C/man7/capabilities.7:741
msgid ""
"Enabling the file effective capability bit implies that any file permitted "
"or inheritable capability that causes a thread to acquire the corresponding "
"permitted capability during an B<execve>(2)  (see the transformation rules "
"described below) will also acquire that capability in its effective set.  "
"Therefore, when assigning capabilities to a file (B<setcap>(8), "
"B<cap_set_file>(3), B<cap_set_fd>(3)), if we specify the effective flag as "
"being enabled for any capability, then the effective flag must also be "
"specified as enabled for all other capabilities for which the corresponding "
"permitted or inheritable flags is enabled."
msgstr ""
"ファイルの実効ケーパビリティビットを有効にするというのは、 B<execve>(2)  実行"
"時に、ファイルの許可ケーパビリティと継承ケーパビリティに対応するものが スレッ"
"ドの許可ケーパビリティセットとしてセットされるが、 これが実効ケーパビリティ"
"セットにもセットされるということである (ケーパビリティの変換ルールは下記参"
"照)。 したがって、ファイルにケーパビリティを割り当てる際 (B<setcap>(8), "
"B<cap_set_file>(3), B<cap_set_fd>(3))、 いずれかのケーパビリティに対して実効"
"フラグを有効と指定する場合、 許可フラグや継承可能フラグを有効にした他の全ての"
"ケーパビリティ についても実効フラグを有効と指定しなければならない。"

#. type: SS
#: build/C/man7/capabilities.7:741
#, no-wrap
msgid "Transformation of capabilities during execve()"
msgstr "execve() 中のケーパビリティの変換"

#. type: Plain text
#: build/C/man7/capabilities.7:747
msgid ""
"During an B<execve>(2), the kernel calculates the new capabilities of the "
"process using the following algorithm:"
msgstr ""
"B<execve>(2)  実行時に、カーネルはプロセスの新しいケーパビリティを次の アルゴ"
"リズムを用いて計算する："

#. type: Plain text
#: build/C/man7/capabilities.7:752
#, no-wrap
msgid ""
"P'(permitted) = (P(inheritable) & F(inheritable)) |\n"
"                (F(permitted) & cap_bset)\n"
msgstr ""
"P'(permitted) = (P(inheritable) & F(inheritable)) |\n"
"                (F(permitted) & cap_bset)\n"

#. type: Plain text
#: build/C/man7/capabilities.7:754
#, no-wrap
msgid "P'(effective) = F(effective) ? P'(permitted) : 0\n"
msgstr "P'(effective) = F(effective) ? P'(permitted) : 0\n"

#. type: Plain text
#: build/C/man7/capabilities.7:756
#, no-wrap
msgid "P'(inheritable) = P(inheritable)    [i.e., unchanged]\n"
msgstr "P'(inheritable) = P(inheritable)    [つまり、変更されない]\n"

#. type: Plain text
#: build/C/man7/capabilities.7:760
msgid "where:"
msgstr "各変数の意味は以下の通り:"

#. type: IP
#: build/C/man7/capabilities.7:761
#, no-wrap
msgid "P"
msgstr "P"

#. type: Plain text
#: build/C/man7/capabilities.7:764
msgid "denotes the value of a thread capability set before the B<execve>(2)"
msgstr "B<execve>(2)  前のスレッドのケーパビリティセットの値"

#. type: IP
#: build/C/man7/capabilities.7:764
#, no-wrap
msgid "P'"
msgstr "P'"

#. type: Plain text
#: build/C/man7/capabilities.7:767
msgid "denotes the value of a capability set after the B<execve>(2)"
msgstr "B<execve>(2)  後のスレッドのケーパビリティセットの値"

#. type: IP
#: build/C/man7/capabilities.7:767
#, no-wrap
msgid "F"
msgstr "F"

#. type: Plain text
#: build/C/man7/capabilities.7:769
msgid "denotes a file capability set"
msgstr "ファイルケーパビリティセットの値"

#. type: IP
#: build/C/man7/capabilities.7:769
#, no-wrap
msgid "cap_bset"
msgstr "cap_bset"

#. type: Plain text
#: build/C/man7/capabilities.7:771
msgid "is the value of the capability bounding set (described below)."
msgstr "ケーパビリティバウンディングセットの値 (下記参照)"

#. type: SS
#: build/C/man7/capabilities.7:773
#, no-wrap
msgid "Capabilities and execution of programs by root"
msgstr "ケーパビリティと、ルートによるプログラムの実行"

#. type: Plain text
#: build/C/man7/capabilities.7:778
msgid ""
"In order to provide an all-powerful I<root> using capability sets, during an "
"B<execve>(2):"
msgstr ""
"B<execve>(2)  時に、ケーパビリティセットを使って、全ての権限を持った I<root> "
"を実現するには、以下のようにする。"

#. type: Plain text
#: build/C/man7/capabilities.7:783
msgid ""
"If a set-user-ID-root program is being executed, or the real user ID of the "
"process is 0 (root)  then the file inheritable and permitted sets are "
"defined to be all ones (i.e., all capabilities enabled)."
msgstr ""
"set-user-ID-root プログラムが実行される場合、 またはプロセスの実ユーザ ID が "
"0 (root) の場合、 ファイルの継承可能セットと許可セットを全て 1 (全てのケーパ"
"ビリティが有効) に定義する。"

#. type: Plain text
#: build/C/man7/capabilities.7:786
msgid ""
"If a set-user-ID-root program is being executed, then the file effective bit "
"is defined to be one (enabled)."
msgstr ""
"set-user-ID-root プログラムが実行される場合、 ファイルの実効ケーパビリティ"
"ビットを 1 (enabled) に定義する。"

#.  If a process with real UID 0, and nonzero effective UID does an
#.  exec(), then it gets all capabilities in its
#.  permitted set, and no effective capabilities
#. type: Plain text
#: build/C/man7/capabilities.7:801
msgid ""
"The upshot of the above rules, combined with the capabilities "
"transformations described above, is that when a process B<execve>(2)s a set-"
"user-ID-root program, or when a process with an effective UID of 0 B<execve>"
"(2)s a program, it gains all capabilities in its permitted and effective "
"capability sets, except those masked out by the capability bounding set.  "
"This provides semantics that are the same as those provided by traditional "
"UNIX systems."
msgstr ""
"上記のルールにケーパビリティ変換を適用した結果をまとめると、 プロセスが set-"
"user-ID-root プログラムを B<execve>(2)  する場合、または実効 UID が 0 のプロ"
"セスがプログラムを B<execve>(2)  する場合、許可と実効のケーパビリティセットの"
"全ケーパビリティ (正確には、ケーパビリティバウンディングセットによるマスクで"
"除外されるもの 以外の全てのケーパビリティ) を取得するということである。 これ"
"により、伝統的な UNIX システムと同じ振る舞いができるようになっている。"

#. type: SS
#: build/C/man7/capabilities.7:801
#, no-wrap
msgid "Capability bounding set"
msgstr "ケーパビリティ・バウンディングセット"

#. type: Plain text
#: build/C/man7/capabilities.7:806
msgid ""
"The capability bounding set is a security mechanism that can be used to "
"limit the capabilities that can be gained during an B<execve>(2).  The "
"bounding set is used in the following ways:"
msgstr ""
"ケーパビリティ・バウンディングセット (capability bounding set) は、 B<execve>"
"(2)  時に獲得できるケーパビリティを制限するために使われる セキュリティ機構で"
"ある。 バウンディングセットは以下のように使用される。"

#. type: Plain text
#: build/C/man7/capabilities.7:814
msgid ""
"During an B<execve>(2), the capability bounding set is ANDed with the file "
"permitted capability set, and the result of this operation is assigned to "
"the thread's permitted capability set.  The capability bounding set thus "
"places a limit on the permitted capabilities that may be granted by an "
"executable file."
msgstr ""
"B<execve>(2)  実行時に、ケーパビリティ・バウンディングセットと ファイルの許可"
"ケーパビリティセットの論理和 (AND) を取ったものが、 そのスレッドの許可ケーパ"
"ビリティセットに割り当てられる。 つまり、ケーパビリティ・バウンディングセット"
"は、 実行ファイルが認めている許可ケーパビリティに対して 制限を課す働きをす"
"る。"

#. type: Plain text
#: build/C/man7/capabilities.7:826
msgid ""
"(Since Linux 2.6.25)  The capability bounding set acts as a limiting "
"superset for the capabilities that a thread can add to its inheritable set "
"using B<capset>(2).  This means that if a capability is not in the bounding "
"set, then a thread can't add this capability to its inheritable set, even if "
"it was in its permitted capabilities, and thereby cannot have this "
"capability preserved in its permitted set when it B<execve>(2)s a file that "
"has the capability in its inheritable set."
msgstr ""
"(Linux 2.6.25 以降)  ケーパビリティ・バウンディングセットは、スレッドが "
"B<capset>(2)  により自身の継承可能セットに追加可能なケーパビリティの母集団を "
"制限する役割を持つ。 スレッドに許可されたケーパビリティであっても、バウンディ"
"ングセットに 含まれていなければ、スレッドはそのケーパビリティは自身の継承可能"
"セットに 追加できず、その結果、継承可能セットにそのケーパビリティを含むファイ"
"ルを B<execve>(2)  する場合、そのケーパビリティを許可セットに持ち続けることが"
"できない、 ということである。"

#. type: Plain text
#: build/C/man7/capabilities.7:833
msgid ""
"Note that the bounding set masks the file permitted capabilities, but not "
"the inherited capabilities.  If a thread maintains a capability in its "
"inherited set that is not in its bounding set, then it can still gain that "
"capability in its permitted set by executing a file that has the capability "
"in its inherited set."
msgstr ""
"バウンディングセットがマスクを行うのは、継承可能ケーパビリティではなく、 ファ"
"イルの許可ケーパビリティのマスクを行う点に注意すること。 あるスレッドの継承可"
"能セットにそのスレッドのバウンディングセットに 存在しないケーパビリティが含ま"
"れている場合、そのスレッドは、 継承可能セットに含まれるケーパビリティを持つ"
"ファイルを実行することにより、 許可セットに含まれるケーパビリティも獲得できる"
"ということである。"

#. type: Plain text
#: build/C/man7/capabilities.7:836
msgid ""
"Depending on the kernel version, the capability bounding set is either a "
"system-wide attribute, or a per-process attribute."
msgstr ""
"カーネルのバージョンにより、ケーパビリティ・バウンディングセットは システム共"
"通の属性の場合と、プロセス単位の属性の場合がある。"

#. type: Plain text
#: build/C/man7/capabilities.7:838
msgid "B<Capability bounding set prior to Linux 2.6.25>"
msgstr "B<Linux 2.6.25 より前のケーパビリティ・バウンディングセット>"

#. type: Plain text
#: build/C/man7/capabilities.7:846
msgid ""
"In kernels before 2.6.25, the capability bounding set is a system-wide "
"attribute that affects all threads on the system.  The bounding set is "
"accessible via the file I</proc/sys/kernel/cap-bound>.  (Confusingly, this "
"bit mask parameter is expressed as a signed decimal number in I</proc/sys/"
"kernel/cap-bound>.)"
msgstr ""
"2.6.25 より前のカーネルでは、ケーパビリティ・バウンディングセットは システム"
"共通の属性で、システム上の全てのスレッドに適用される。 バウンディングセット"
"は I</proc/sys/kernel/cap-bound> ファイル経由で参照できる。 (間違えやすいが、"
"このビットマスク形式のパラメータは、 I</proc/sys/kernel/cap-bound> では符号付"
"きの十進数で表現される。)"

#. type: Plain text
#: build/C/man7/capabilities.7:853
msgid ""
"Only the B<init> process may set capabilities in the capability bounding "
"set; other than that, the superuser (more precisely: programs with the "
"B<CAP_SYS_MODULE> capability) may only clear capabilities from this set."
msgstr ""
"B<init> プロセスだけがケーパビリティ・バウンディングセットで ケーパビリティを"
"セットすることができる。 それ以外では、スーパーユーザ (より正確には、 "
"B<CAP_SYS_MODULE> ケーパビリティを持ったプログラム) が、 ケーパビリティ・バウ"
"ンディングセットのケーパビリティのクリアが できるだけである。"

#. type: Plain text
#: build/C/man7/capabilities.7:862
msgid ""
"On a standard system the capability bounding set always masks out the "
"B<CAP_SETPCAP> capability.  To remove this restriction (dangerous!), modify "
"the definition of B<CAP_INIT_EFF_SET> in I<include/linux/capability.h> and "
"rebuild the kernel."
msgstr ""
"通常のシステムでは、ケーパビリティ・バウンディングセットは、 B<CAP_SETPCAP> "
"が無効になっている。 この制限を取り去るには (取り去るのは危険!)、 I<include/"
"linux/capability.h> 内の B<CAP_INIT_EFF_SET> の定義を修正し、カーネルを再構築"
"する必要がある。"

#. type: Plain text
#: build/C/man7/capabilities.7:866
msgid ""
"The system-wide capability bounding set feature was added to Linux starting "
"with kernel version 2.2.11."
msgstr ""
"システム共通のケーパビリティ・バウンディングセット機能は、 カーネル 2.2.11 以"
"降で Linux に追加された。"

#. type: Plain text
#: build/C/man7/capabilities.7:868
msgid "B<Capability bounding set from Linux 2.6.25 onward>"
msgstr "B<Linux 2.6.25 以降のケーパビリティ・バウンディングセット>"

#. type: Plain text
#: build/C/man7/capabilities.7:873
msgid ""
"From Linux 2.6.25, the I<capability bounding set> is a per-thread "
"attribute.  (There is no longer a system-wide capability bounding set.)"
msgstr ""
"Linux 2.6.25 以降では、 「ケーパビリティ・バウンディングセット」はスレッド単"
"位の属性である (システム共通のケーパビリティ・バウンディングセットはもはや存"
"在しない)。"

#. type: Plain text
#: build/C/man7/capabilities.7:878
msgid ""
"The bounding set is inherited at B<fork>(2)  from the thread's parent, and "
"is preserved across an B<execve>(2)."
msgstr ""
"バウンディングセットは B<fork>(2)  時にはスレッドの親プロセスから継承され、 "
"B<execve>(2)  の前後では保持される。"

#. type: Plain text
#: build/C/man7/capabilities.7:891
msgid ""
"A thread may remove capabilities from its capability bounding set using the "
"B<prctl>(2)  B<PR_CAPBSET_DROP> operation, provided it has the "
"B<CAP_SETPCAP> capability.  Once a capability has been dropped from the "
"bounding set, it cannot be restored to that set.  A thread can determine if "
"a capability is in its bounding set using the B<prctl>(2)  "
"B<PR_CAPBSET_READ> operation."
msgstr ""
"スレッドが B<CAP_SETPCAP> ケーパビリティを持っている場合、そのスレッドは "
"B<prctl>(2)  の B<PR_CAPBSET_DROP> 操作を使って自身のケーパビリティ・バウン"
"ディングセットから ケーパビリティを削除することができる。 いったんケーパビリ"
"ティをバウンディングセットから削除してしまうと、 スレッドはそのケーパビリティ"
"を再度セットすることはできない。 B<prctl>(2)  の B<PR_CAPBSET_READ> 操作を使"
"うことで、スレッドがあるケーパビリティが自身のバウンディングセット に含まれて"
"いるかを知ることができる。"

#. type: Plain text
#: build/C/man7/capabilities.7:909
msgid ""
"Removing capabilities from the bounding set is supported only if file "
"capabilities are compiled into the kernel.  In kernels before Linux 2.6.33, "
"file capabilities were an optional feature configurable via the "
"CONFIG_SECURITY_FILE_CAPABILITIES option.  Since Linux 2.6.33, the "
"configuration option has been removed and file capabilities are always part "
"of the kernel.  When file capabilities are compiled into the kernel, the "
"B<init> process (the ancestor of all processes) begins with a full bounding "
"set.  If file capabilities are not compiled into the kernel, then B<init> "
"begins with a full bounding set minus B<CAP_SETPCAP>, because this "
"capability has a different meaning when there are no file capabilities."
msgstr ""
"バウンディングセットからのケーパビリティの削除がサポートされるのは、\n"
"カーネルのコンパイル時にファイルケーパビリティが有効になっている場合\n"
"だけである。Linux 2.6.33 より前のカーネルでは、ファイルケーパビリティは\n"
"設定オプション CONFIG_SECURITY_FILE_CAPABILITIES で切り替えられる追加の\n"
"機能であった。Linux 2.6.33 以降では、この設定オプションは削除され、\n"
"ファイルケーパビリティは常にカーネルに組込まれるようになった。\n"
"ファイルケーパビリティがカーネルにコンパイル時に組み込まれている場合、\n"
"(全てのプロセスの先祖である) I<init> プロセスはバウンディングセットで\n"
"全てのケーパビリティが セットされた状態で開始する。ファイルケーパビリティ\n"
"が有効になっていない場合には、 I<init> はバウンディングセットで\n"
"B<CAP_SETPCAP> 以外の全てのケーパビリティがセットされた状態で開始する。\n"
"このようになっているのは、 B<CAP_SETPCAP> ケーパビリティがファイルケー\n"
"パビリティがサポートされていない場合には 違った意味を持つからである。"

#. type: Plain text
#: build/C/man7/capabilities.7:916
msgid ""
"Removing a capability from the bounding set does not remove it from the "
"thread's inherited set.  However it does prevent the capability from being "
"added back into the thread's inherited set in the future."
msgstr ""
"バウンディングセットからケーパビリティを削除しても、 スレッドの継承可能セット"
"からはそのケーパビリティは削除されない。 しかしながら、バウンディングセットか"
"らの削除により、 この先そのケーパビリティをスレッドの継承可能セットに追加する"
"こと はできなくなる。"

#. type: SS
#: build/C/man7/capabilities.7:916
#, no-wrap
msgid "Effect of user ID changes on capabilities"
msgstr "ユーザ ID 変更のケーパビリティへの影響"

#. type: Plain text
#: build/C/man7/capabilities.7:925
msgid ""
"To preserve the traditional semantics for transitions between 0 and nonzero "
"user IDs, the kernel makes the following changes to a thread's capability "
"sets on changes to the thread's real, effective, saved set, and file system "
"user IDs (using B<setuid>(2), B<setresuid>(2), or similar):"
msgstr ""
"ユーザ ID が 0 と 0 以外の間で変化する際の振る舞いを従来と同じにするため、 ス"
"レッドの実 UID、実効 UID、保存 set-user-ID、ファイルシステム UID が "
"(B<setuid>(2), B<setresuid>(2)  などを使って) 変更された際に、カーネルはその"
"スレッドのケーパビリティセットに 以下の変更を行う:"

#. type: Plain text
#: build/C/man7/capabilities.7:931
msgid ""
"If one or more of the real, effective or saved set user IDs was previously "
"0, and as a result of the UID changes all of these IDs have a nonzero value, "
"then all capabilities are cleared from the permitted and effective "
"capability sets."
msgstr ""
"UID の変更前には実 UID、実効 UID、保存 set-user-ID のうち 少なくとも一つが 0 "
"で、変更後に実 UID、実効 UID、保存 set-user-ID が すべて 0 以外の値になった場"
"合、許可と実効のケーパビリティセットの 全ケーパビリティをクリアする。"

#. type: Plain text
#: build/C/man7/capabilities.7:934
msgid ""
"If the effective user ID is changed from 0 to nonzero, then all capabilities "
"are cleared from the effective set."
msgstr ""
"実効 UID が 0 から 0 以外に変更された場合、 実効ケーパビリティセットの全ケー"
"パビリティをクリアする。"

#. type: Plain text
#: build/C/man7/capabilities.7:937
msgid ""
"If the effective user ID is changed from nonzero to 0, then the permitted "
"set is copied to the effective set."
msgstr ""
"実効 UID が 0 以外から 0 に変更された場合、 許可ケーパビリティセットの内容を"
"実効ケーパビリティセットにコピーする。"

#. type: IP
#: build/C/man7/capabilities.7:937 build/C/man7/capabilities.7:992
#, no-wrap
msgid "4."
msgstr "4."

#. type: Plain text
#: build/C/man7/capabilities.7:955
msgid ""
"If the file system user ID is changed from 0 to nonzero (see B<setfsuid>"
"(2))  then the following capabilities are cleared from the effective set: "
"B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, "
"B<CAP_FSETID>, B<CAP_LINUX_IMMUTABLE> (since Linux 2.2.30), "
"B<CAP_MAC_OVERRIDE>, and B<CAP_MKNOD> (since Linux 2.2.30).  If the file "
"system UID is changed from nonzero to 0, then any of these capabilities that "
"are enabled in the permitted set are enabled in the effective set."
msgstr ""
"ファイルシステム UID が 0 から 0 以外に変更された場合 (B<setfsuid>(2)  参"
"照)、実効ケーパビリティセットの以下のケーパビリティがクリアされる: "
"B<CAP_CHOWN>, B<CAP_DAC_OVERRIDE>, B<CAP_DAC_READ_SEARCH>, B<CAP_FOWNER>, "
"B<CAP_FSETID>, B<CAP_LINUX_IMMUTABLE> (Linux 2.2.30 以降), "
"B<CAP_MAC_OVERRIDE>, B<CAP_MKNOD> (Linux 2.2.30 以降)。 ファイルシステム UID "
"が 0 以外から 0 に変更された場合、 上記のケーパビリティのうち許可ケーパビリ"
"ティセットで有効になっているものが 実効ケーパビリティセットで有効にされる。"

#. type: Plain text
#: build/C/man7/capabilities.7:963
msgid ""
"If a thread that has a 0 value for one or more of its user IDs wants to "
"prevent its permitted capability set being cleared when it resets all of its "
"user IDs to nonzero values, it can do so using the B<prctl>(2)  "
"B<PR_SET_KEEPCAPS> operation."
msgstr ""
"各種 UID のうち少なくとも一つが 0 であるスレッドが、 その UID の全てが 0 以外"
"になったときに許可ケーパビリティセットが クリアされないようにしたい場合に"
"は、 B<prctl>(2)  の B<PR_SET_KEEPCAPS> 操作を使えばよい。"

#. type: SS
#: build/C/man7/capabilities.7:963
#, no-wrap
msgid "Programmatically adjusting capability sets"
msgstr "プログラムでケーパビリティセットを調整する"

#. type: Plain text
#: build/C/man7/capabilities.7:978
msgid ""
"A thread can retrieve and change its capability sets using the B<capget>(2)  "
"and B<capset>(2)  system calls.  However, the use of B<cap_get_proc>(3)  and "
"B<cap_set_proc>(3), both provided in the I<libcap> package, is preferred for "
"this purpose.  The following rules govern changes to the thread capability "
"sets:"
msgstr ""
"各スレッドは、 B<capget>(2)  や B<capset>(2)  を使って、自身のケーパビリティ"
"セットを取得したり変更したりできる。 ただし、これを行うには、 I<libcap> パッ"
"ケージで提供されている B<cap_get_proc>(3)  や B<cap_set_proc>(3)  を使うのが"
"望ましい。 スレッドのケーパビリティセットの変更には以下のルールが適用される。"

#. type: Plain text
#: build/C/man7/capabilities.7:984
msgid ""
"If the caller does not have the B<CAP_SETPCAP> capability, the new "
"inheritable set must be a subset of the combination of the existing "
"inheritable and permitted sets."
msgstr ""
"呼び出し側が B<CAP_SETPCAP> ケーパビリティを持っていない場合、新しい継承可能"
"セットは、 既存の継承可能セットと許可セットの積集合 (AND) の部分集合で なけれ"
"ばならない。"

#. type: Plain text
#: build/C/man7/capabilities.7:988
msgid ""
"(Since Linux 2.6.25)  The new inheritable set must be a subset of the "
"combination of the existing inheritable set and the capability bounding set."
msgstr ""
"(Linux 2.6.25 以降)  新しい継承可能セットは、既存の継承可能セットとケーパビリ"
"ティ・ バウンディングセットの積集合 (AND) の部分集合でなければならない。"

#. type: Plain text
#: build/C/man7/capabilities.7:992
msgid ""
"The new permitted set must be a subset of the existing permitted set (i.e., "
"it is not possible to acquire permitted capabilities that the thread does "
"not currently have)."
msgstr ""
"新しい許可セットは、既存の許可セットの部分集合でなければならない (つまり、そ"
"のスレッドが現在持っていない許可ケーパビリティを 獲得することはできない)。"

#. type: Plain text
#: build/C/man7/capabilities.7:994
msgid "The new effective set must be a subset of the new permitted set."
msgstr ""
"新しい実効ケーパビリティセットは新しい許可ケーパビリティセットの 部分集合に"
"なっていなければならない。"

#. type: SS
#: build/C/man7/capabilities.7:994
#, no-wrap
msgid "The securebits flags: establishing a capabilities-only environment"
msgstr "securebits フラグ: ケーパビリティだけの環境を構築する"

#.  For some background:
#.        see http://lwn.net/Articles/280279/ and
#.        http://article.gmane.org/gmane.linux.kernel.lsm/5476/
#. type: Plain text
#: build/C/man7/capabilities.7:1005
msgid ""
"Starting with kernel 2.6.26, and with a kernel in which file capabilities "
"are enabled, Linux implements a set of per-thread I<securebits> flags that "
"can be used to disable special handling of capabilities for UID 0 "
"(I<root>).  These flags are as follows:"
msgstr ""
"カーネル 2.6.26 以降で、 ファイルケーパビリティが有効になったカーネルでは、 "
"スレッド単位の I<securebits> フラグが実装されており、このフラグを使うと UID "
"0 (I<root>)  に対するケーパビリティの特別扱いを無効することができる。 以下の"
"ようなフラグがある。"

#. type: TP
#: build/C/man7/capabilities.7:1005
#, no-wrap
msgid "B<SECBIT_KEEP_CAPS>"
msgstr "B<SECBIT_KEEP_CAPS>"

#. type: Plain text
#: build/C/man7/capabilities.7:1017
msgid ""
"Setting this flag allows a thread that has one or more 0 UIDs to retain its "
"capabilities when it switches all of its UIDs to a nonzero value.  If this "
"flag is not set, then such a UID switch causes the thread to lose all "
"capabilities.  This flag is always cleared on an B<execve>(2).  (This flag "
"provides the same functionality as the older B<prctl>(2)  B<PR_SET_KEEPCAPS> "
"operation.)"
msgstr ""
"このフラグをセットされている場合、UID が 0 のスレッドの UID が 0 以外の値に "
"切り替わる際に、そのスレッドはケーパビリティを維持することができる。 このフラ"
"グがセットされていない場合には、UID が 0 から 0 以外の値に 切り替わると、その"
"スレッドは全てのケーパビリティを失う。 このフラグは B<execve>(2)  時には全て"
"クリアされる (このフラグは、以前の B<prctl>(2)  の B<PR_SET_KEEPCAPS> 操作と"
"同じ機能を提供するものである)。"

#. type: TP
#: build/C/man7/capabilities.7:1017
#, no-wrap
msgid "B<SECBIT_NO_SETUID_FIXUP>"
msgstr "B<SECBIT_NO_SETUID_FIXUP>"

#. type: Plain text
#: build/C/man7/capabilities.7:1024
msgid ""
"Setting this flag stops the kernel from adjusting capability sets when the "
"threads's effective and file system UIDs are switched between zero and "
"nonzero values.  (See the subsection I<Effect of User ID Changes on "
"Capabilities>.)"
msgstr ""
"このフラグをセットすると、スレッドの実効 UID とファイルシステム UID が 0 と "
"0 以外の間で切り替わった場合に、 カーネルはケーパビリティセットの調整を行わな"
"くなる (「ユーザ ID 変更のケーパビリティへの影響」の節を参照)。"

#. type: TP
#: build/C/man7/capabilities.7:1024
#, no-wrap
msgid "B<SECBIT_NOROOT>"
msgstr "B<SECBIT_NOROOT>"

#. type: Plain text
#: build/C/man7/capabilities.7:1032
msgid ""
"If this bit is set, then the kernel does not grant capabilities when a set-"
"user-ID-root program is executed, or when a process with an effective or "
"real UID of 0 calls B<execve>(2).  (See the subsection I<Capabilities and "
"execution of programs by root>.)"
msgstr ""
"このビットがセットされている場合、 set-user-ID-root プログラムの実行時や、 実"
"効 UID か 実 UID が 0 のプロセスが B<execve>(2)  を呼び出した時に、カーネルは"
"ケーパビリティを許可しない (「ケーパビリティと、ルートによるプログラムの実"
"行」の節を参照)。"

#. type: Plain text
#: build/C/man7/capabilities.7:1042
msgid ""
"Each of the above \"base\" flags has a companion \"locked\" flag.  Setting "
"any of the \"locked\" flags is irreversible, and has the effect of "
"preventing further changes to the corresponding \"base\" flag.  The locked "
"flags are: B<SECBIT_KEEP_CAPS_LOCKED>, B<SECBIT_NO_SETUID_FIXUP_LOCKED>, and "
"B<SECBIT_NOROOT_LOCKED>."
msgstr ""
"上記の \"base\" フラグの各々には対応する \"locked\" フラグが存在する。 いずれ"
"の \"locked\" フラグも一度セットされると戻すことはできず、 それ以降は対応す"
"る \"base\" フラグを変更することができなくなる。 \"locked\" フラグは "
"B<SECBIT_KEEP_CAPS_LOCKED>, B<SECBIT_NO_SETUID_FIXUP_LOCKED>, "
"B<SECBIT_NOROOT_LOCKED> という名前である。"

#. type: Plain text
#: build/C/man7/capabilities.7:1054
msgid ""
"The I<securebits> flags can be modified and retrieved using the B<prctl>(2)  "
"B<PR_SET_SECUREBITS> and B<PR_GET_SECUREBITS> operations.  The "
"B<CAP_SETPCAP> capability is required to modify the flags."
msgstr ""
"I<securebits> フラグは、 B<prctl>(2)  の操作 B<PR_SET_SECUREBITS> や "
"B<PR_GET_SECUREBITS> を使うことで変更したり取得したりできる。 フラグを変更す"
"るには B<CAP_SETPCAP> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man7/capabilities.7:1063
msgid ""
"The I<securebits> flags are inherited by child processes.  During an "
"B<execve>(2), all of the flags are preserved, except B<SECBIT_KEEP_CAPS> "
"which is always cleared."
msgstr ""
"I<securebits> フラグは子プロセスに継承される。 B<execve>(2) においては、\n"
"B<SECBIT_KEEP_CAPS> が常にクリアされる以外は、全てのフラグが保持される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1068
msgid ""
"An application can use the following call to lock itself, and all of its "
"descendants, into an environment where the only way of gaining capabilities "
"is by executing a program with associated file capabilities:"
msgstr ""
"アプリケーションは、以下の呼び出しを行うことにより、 自分自身および子孫となる"
"プロセス全てに対して、 必要なファイルケーパビリティを持ったプログラムを実行し"
"ない限り、 対応するケーパビリティを獲得できないような状況に閉じこめることがで"
"きる。"

#. type: Plain text
#: build/C/man7/capabilities.7:1077
#, no-wrap
msgid ""
"prctl(PR_SET_SECUREBITS,\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"
msgstr ""
"prctl(PR_SET_SECUREBITS,\n"
"        SECBIT_KEEP_CAPS_LOCKED |\n"
"        SECBIT_NO_SETUID_FIXUP |\n"
"        SECBIT_NO_SETUID_FIXUP_LOCKED |\n"
"        SECBIT_NOROOT |\n"
"        SECBIT_NOROOT_LOCKED);\n"

#. type: Plain text
#: build/C/man7/capabilities.7:1085
msgid ""
"No standards govern capabilities, but the Linux capability implementation is "
"based on the withdrawn POSIX.1e draft standard; see E<.UR http://wt."
"tuxomania.net\\:/publications\\:/posix.1e/> E<.UE .>"
msgstr ""
"ケーパビリティに関する標準はないが、 Linux のケーパビリティは廃案になった "
"POSIX.1e 草案に基づいて実装されている。 E<.UR http://wt.xpilot.org\\:/"
"publications\\:/posix.1e/> E<.UE> を参照。"

#. type: Plain text
#: build/C/man7/capabilities.7:1089
msgid ""
"Since kernel 2.5.27, capabilities are an optional kernel component, and can "
"be enabled/disabled via the CONFIG_SECURITY_CAPABILITIES kernel "
"configuration option."
msgstr ""
"カーネル 2.5.27 以降、ケーパビリティは選択式のカーネルコンポーネント となって"
"おり、カーネル設定オプション CONFIG_SECURITY_CAPABILITIES により有効/無効を切"
"り替えることができる。"

#.  7b9a7ec565505699f503b4fcf61500dceb36e744
#. type: Plain text
#: build/C/man7/capabilities.7:1103
msgid ""
"The I</proc/PID/task/TID/status> file can be used to view the capability "
"sets of a thread.  The I</proc/PID/status> file shows the capability sets of "
"a process's main thread.  Before Linux 3.8, nonexistent capabilities were "
"shown as being enabled (1) in these sets.  Since Linux 3.8, all non-existent "
"capabilities (above B<CAP_LAST_CAP>)  are shown as disabled (0)."
msgstr ""
"I</proc/PID/task/TID/status> ファイルを使うと、スレッドのケーパビリティセット"
"を見ることができる。 I</proc/PID/status> ファイルには、プロセスのメインスレッ"
"ドのケーパビリティセットが表示される。 Linux 3.8 より前では、 これらのケーパ"
"ビリティセットの表示で、 存在しないケーパビリティはすべて有効 (1) として表示"
"される。 Linux 3.8 以降では、 存在しないケーパビリティはすべて無効 (0) として"
"表示される。 (B<CAP_LAST_CAP> より大きい値を持つケーパビリティが存在しない"
"ケーパビリティである)。"

#. type: Plain text
#: build/C/man7/capabilities.7:1118
msgid ""
"The I<libcap> package provides a suite of routines for setting and getting "
"capabilities that is more comfortable and less likely to change than the "
"interface provided by B<capset>(2)  and B<capget>(2).  This package also "
"provides the B<setcap>(8)  and B<getcap>(8)  programs.  It can be found at"
msgstr ""
"I<libcap> パッケージは、ケーパビリティを設定・取得するための ルーチン群を提供"
"している。これらのインタフェースは、 B<capset>(2)  と B<capget>(2)  が提供す"
"るインターフェースと比べて、より使いやすく、変更される可能性が少ない。 この"
"パッケージでは、 B<setcap>(8), B<getcap>(8)  というプログラムも提供されてい"
"る。 パッケージは以下で入手できる。"

#. type: Plain text
#: build/C/man7/capabilities.7:1121
msgid ""
"E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/libs\\:/security\\:/linux-"
"privs> E<.UE .>"
msgstr ""
"E<.UR http://www.kernel.org\\:/pub\\:/linux\\:/libs\\:/security\\:/linux-"
"privs> E<.UE .>"

#. type: Plain text
#: build/C/man7/capabilities.7:1130
msgid ""
"Before kernel 2.6.24, and since kernel 2.6.24 if file capabilities are not "
"enabled, a thread with the B<CAP_SETPCAP> capability can manipulate the "
"capabilities of threads other than itself.  However, this is only "
"theoretically possible, since no thread ever has B<CAP_SETPCAP> in either of "
"these cases:"
msgstr ""
"バージョン 2.6.24 より前、およびファイルケーパビリティが 有効になっていない"
"2.6.24 以降のカーネルでは、 B<CAP_SETPCAP> ケーパビリティを持ったスレッドは自"
"分以外のスレッドの ケーパビリティを操作できる。 しかしながら、これは理論的に"
"可能というだけである。 以下のいずれかの場合においても、どのスレッドも "
"B<CAP_SETPCAP> ケーパビリティを持つことはないからである。"

#. type: Plain text
#: build/C/man7/capabilities.7:1135
msgid ""
"In the pre-2.6.25 implementation the system-wide capability bounding set, I</"
"proc/sys/kernel/cap-bound>, always masks out this capability, and this can "
"not be changed without modifying the kernel source and rebuilding."
msgstr ""
"2.6.25 より前の実装では、システム共通のケーパビリティ・バウンディングセット "
"I</proc/sys/kernel/cap-bound> ではこのケーパビリティは常に無効になっており、 "
"ソースを変更してカーネルを再コンパイルしない限り、 これを変更することはできな"
"い。"

#. type: Plain text
#: build/C/man7/capabilities.7:1141
msgid ""
"If file capabilities are disabled in the current implementation, then "
"B<init> starts out with this capability removed from its per-process "
"bounding set, and that bounding set is inherited by all other processes "
"created on the system."
msgstr ""
"現在の実装ではファイルケーパビリティが無効になっている場合、 プロセス毎のバウ"
"ンディングセットからこのケーパビリティを抜いて B<init> は開始され、 システム"
"上で生成される他の全てのプロセスでこのバウンディングセットが 継承される。"

#. type: Plain text
#: build/C/man7/capabilities.7:1158
msgid ""
"B<capget>(2), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3), B<cap_copy_ext>"
"(3), B<cap_from_text>(3), B<cap_get_file>(3), B<cap_get_proc>(3), B<cap_init>"
"(3), B<capgetp>(3), B<capsetp>(3), B<libcap>(3), B<credentials>(7), "
"B<pthreads>(7), B<getcap>(8), B<setcap>(8)"
msgstr ""
"B<capget>(2), B<prctl>(2), B<setfsuid>(2), B<cap_clear>(3),\n"
"B<cap_copy_ext>(3), B<cap_from_text>(3), B<cap_get_file>(3),\n"
"B<cap_get_proc>(3), B<cap_init>(3), B<capgetp>(3), B<capsetp>(3),\n"
"B<libcap>(3), B<credentials>(7), B<pthreads>(7), B<getcap>(8), B<setcap>(8)"

#. type: Plain text
#: build/C/man7/capabilities.7:1161
msgid "I<include/linux/capability.h> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<include/linux/capability.h>"

#. type: TH
#: build/C/man2/capget.2:15
#, no-wrap
msgid "CAPGET"
msgstr "CAPGET"

#. type: TH
#: build/C/man2/capget.2:15
#, no-wrap
msgid "2013-03-11"
msgstr "2013-03-11"

#. type: Plain text
#: build/C/man2/capget.2:18
msgid "capget, capset - set/get capabilities of thread(s)"
msgstr "capget, capset - スレッドのケーパビリティを設定/取得する"

#. type: Plain text
#: build/C/man2/capget.2:20
msgid "B<#include E<lt>sys/capability.hE<gt>>"
msgstr "B<#include E<lt>sys/capability.hE<gt>>"

#. type: Plain text
#: build/C/man2/capget.2:22
msgid ""
"B<int capget(cap_user_header_t >I<hdrp>B<, cap_user_data_t >I<datap>B<);>"
msgstr ""
"B<int capget(cap_user_header_t >I<hdrp>B<, cap_user_data_t >I<datap>B<);>"

#. type: Plain text
#: build/C/man2/capget.2:24
msgid ""
"B<int capset(cap_user_header_t >I<hdrp>B<, const cap_user_data_t "
">I<datap>B<);>"
msgstr ""
"B<int capset(cap_user_header_t >I<hdrp>B<, const cap_user_data_t "
">I<datap>B<);>"

#. type: Plain text
#: build/C/man2/capget.2:35
msgid ""
"As of Linux 2.2, the power of the superuser (root) has been partitioned into "
"a set of discrete capabilities.  Each thread has a set of effective "
"capabilities identifying which capabilities (if any) it may currently "
"exercise.  Each thread also has a set of inheritable capabilities that may "
"be passed through an B<execve>(2)  call, and a set of permitted capabilities "
"that it can make effective or inheritable."
msgstr ""
"Linux 2.2 で、スーパーユーザー (root) の権限は、個別のケーパビリティ "
"(capabilities) へと分割され、その集合として表現されるようになった。 各スレッ"
"ドは「実効ケーパビリティ (effective capability) の集合」を持ち、 それによって"
"現在どの操作が実行可能かを識別できる。 また、各スレッドは、 「継承可能ケーパ"
"ビリティ (inheritable capability) の集合」と 「許可ケーパビリティ (permitted "
"capability) の集合」を持つ。 「継承可能ケーパビリティの集合」は B<execve>"
"(2)  を通じて渡すことができるケーパビリティの集合であり、 「許可ケーパビリ"
"ティ (permitted capability) の集合」は 実効ケーパビリティや継承可能ケーパビリ"
"ティとして有効にできる ケーパビリティを規定するものである。"

#. type: Plain text
#: build/C/man2/capget.2:44
msgid ""
"These two system calls are the raw kernel interface for getting and setting "
"thread capabilities.  Not only are these system calls specific to Linux, but "
"the kernel API is likely to change and use of these system calls (in "
"particular the format of the I<cap_user_*_t> types) is subject to extension "
"with each kernel revision, but old programs will keep working."
msgstr ""
"この二つのシステムコールはスレッドのケーパビリティを取得したり設定したりする"
"ための 生のカーネルインターフェースである。 これらのシステムコールは Linux 特"
"有であるというだけでなく、 カーネル API は変更されるかもしれず、これらのシス"
"テムコールの使用法 (特に I<cap_user_*_t> 型という書式) はカーネルのリビジョン"
"毎に拡張されるかもしれないが、 以前のプログラムはそのまま動作する。"

#. type: Plain text
#: build/C/man2/capget.2:55
msgid ""
"The portable interfaces are B<cap_set_proc>(3)  and B<cap_get_proc>(3); if "
"possible you should use those interfaces in applications.  If you wish to "
"use the Linux extensions in applications, you should use the easier-to-use "
"interfaces B<capsetp>(3)  and B<capgetp>(3)."
msgstr ""
"移植性のあるインターフェースは B<cap_set_proc>(3)  と B<cap_get_proc>(3)  で"
"ある。 可能ならばアプリケーションはこれらの関数を使用すべきである。 アプリ"
"ケーションに Linux 拡張を使用したい場合には、より簡単に 使えるインターフェー"
"スである B<capsetp>(3)  と B<capgetp>(3)  を使用すべきである。"

#. type: SS
#: build/C/man2/capget.2:55
#, no-wrap
msgid "Current details"
msgstr "現在の詳細"

#. type: Plain text
#: build/C/man2/capget.2:58
msgid ""
"Now that you have been warned, some current kernel details.  The structures "
"are defined as follows."
msgstr ""
"現在のカーネルの詳細について注意を述べておく。 構造体は以下のように定義され"
"る。"

#. type: Plain text
#: build/C/man2/capget.2:63
#, no-wrap
msgid ""
"#define _LINUX_CAPABILITY_VERSION_1  0x19980330\n"
"#define _LINUX_CAPABILITY_U32S_1     1\n"
msgstr ""
"#define _LINUX_CAPABILITY_VERSION_1  0x19980330\n"
"#define _LINUX_CAPABILITY_U32S_1     1\n"

#. type: Plain text
#: build/C/man2/capget.2:66
#, no-wrap
msgid ""
"#define _LINUX_CAPABILITY_VERSION_2  0x20071026\n"
"#define _LINUX_CAPABILITY_U32S_2     2\n"
msgstr ""
"#define _LINUX_CAPABILITY_VERSION_2  0x20071026\n"
"#define _LINUX_CAPABILITY_U32S_2     2\n"

#. type: Plain text
#: build/C/man2/capget.2:71
#, no-wrap
msgid ""
"typedef struct __user_cap_header_struct {\n"
"   __u32 version;\n"
"   int pid;\n"
"} *cap_user_header_t;\n"
msgstr ""
"typedef struct __user_cap_header_struct {\n"
"   __u32 version;\n"
"   int pid;\n"
"} *cap_user_header_t;\n"

#. type: Plain text
#: build/C/man2/capget.2:77
#, no-wrap
msgid ""
"typedef struct __user_cap_data_struct {\n"
"   __u32 effective;\n"
"   __u32 permitted;\n"
"   __u32 inheritable;\n"
"} *cap_user_data_t;\n"
msgstr ""
"typedef struct __user_cap_data_struct {\n"
"   __u32 effective;\n"
"   __u32 permitted;\n"
"   __u32 inheritable;\n"
"} *cap_user_data_t;\n"

#. type: Plain text
#: build/C/man2/capget.2:96
msgid ""
"The I<effective>, I<permitted>, and I<inheritable> fields are bit masks of "
"the capabilities defined in I<capability(7).> Note the B<CAP_*> values are "
"bit indexes and need to be bit-shifted before ORing into the bit fields.  To "
"define the structures for passing to the system call you have to use the "
"I<struct __user_cap_header_struct> and I<struct __user_cap_data_struct> "
"names because the typedefs are only pointers."
msgstr ""
"フィールド I<effective>, I<permitted>, I<inheritable> は、 B<capability>(7)  "
"で定義されるケーパビリティのビットマスクである。 I<CAP_*> はビット番号を表す"
"インデックス値であり、 ビットフィールドに OR を行う前に I<CAP_*> の値の分だけ"
"ビットシフトを行う必要がある。 typedef の方はポインタなので、 このシステム"
"コールに渡す構造体を定義するには、 I<struct __user_cap_header_struct> と "
"I<struct __user_cap_data_struct> という名前を使用しなければならない。"

#. type: Plain text
#: build/C/man2/capget.2:108
msgid ""
"Kernels prior to 2.6.25 prefer 32-bit capabilities with version "
"B<_LINUX_CAPABILITY_VERSION_1>, and kernels 2.6.25+ prefer 64-bit "
"capabilities with version B<_LINUX_CAPABILITY_VERSION_2>.  Note, 64-bit "
"capabilities use I<datap>[0] and I<datap>[1], whereas 32-bit capabilities "
"use only I<datap>[0]."
msgstr ""
"カーネル 2.6.25 より前では、バージョン B<_LINUX_CAPABILITY_VERSION_1> の 32 "
"ビットケーパビリティが推奨である。 カーネル 2.6.25 以降では、バージョン "
"B<_LINUX_CAPABILITY_VERSION_2> の 64 ビットケーパビリティが推奨である。 64 "
"ビットケーパビリティでは I<datap>[0] と I<datap>[1] が使用されるのに対し、 "
"32 ビットケーパビリティでは I<datap>[0] だけが使用される。"

#. type: Plain text
#: build/C/man2/capget.2:112
msgid ""
"Another change affecting the behavior of these system calls is kernel "
"support for file capabilities (VFS capability support).  This support is "
"currently a compile time option (added in kernel 2.6.24)."
msgstr ""
"これらのシステムコールの挙動に影響があるもう一つの変更点は、 ファイルケーパビ"
"リティ (file capabilities) のカーネルによるサポート (VFS ケーパビリティのサ"
"ポート) である。 VFS ケーパビリティのサポートは現在のところコンパイル時のオプ"
"ションである (カーネル 2.6.24 で追加された)。"

#. type: Plain text
#: build/C/man2/capget.2:119
msgid ""
"For B<capget>()  calls, one can probe the capabilities of any process by "
"specifying its process ID with the I<hdrp-E<gt>pid> field value."
msgstr ""
"B<capget>()  では、 I<hdrp-E<gt>pid> のフィールド値にケーパビリティを知りたい"
"プロセスのプロセス ID を 指定することで、任意のプロセスのケーパビリティを調べ"
"ることができる。"

#. type: SS
#: build/C/man2/capget.2:119
#, no-wrap
msgid "With VFS capability support"
msgstr "VFS ケーパビリティがサポートされている場合"

#. type: Plain text
#: build/C/man2/capget.2:131
msgid ""
"VFS Capability support creates a file-attribute method for adding "
"capabilities to privileged executables.  This privilege model obsoletes "
"kernel support for one process asynchronously setting the capabilities of "
"another.  That is, with VFS support, for B<capset>()  calls the only "
"permitted values for I<hdrp-E<gt>pid> are 0 or B<getpid>(2), which are "
"equivalent."
msgstr ""
"VFS ケーパビリティのサポートでは、特権実行ファイルにケーパビリティを 追加する"
"ためのファイル属性メソッドが作成された。 この特権モデルの導入により、あるプロ"
"セスにより別のプロセスのケーパビリティ を非同期に設定する機能のカーネルによる"
"サポートは廃止される。 つまり、VFS サポートでは、 B<capset>()  を呼び出す際"
"に I<hdrp-E<gt>pid> の値として許されるのは 0 と B<getpid>(2)  が返す値だけと"
"なる (どちらの値でも等価である)。"

#. type: SS
#: build/C/man2/capget.2:131
#, no-wrap
msgid "Without VFS capability support"
msgstr "VFS ケーパビリティがサポートされていない場合"

#. type: Plain text
#: build/C/man2/capget.2:157
msgid ""
"When the kernel does not support VFS capabilities, B<capset>()  calls can "
"operate on the capabilities of the thread specified by the I<pid> field of "
"I<hdrp> when that is nonzero, or on the capabilities of the calling thread "
"if I<pid> is 0.  If I<pid> refers to a single-threaded process, then I<pid> "
"can be specified as a traditional process ID; operating on a thread of a "
"multithreaded process requires a thread ID of the type returned by B<gettid>"
"(2).  For B<capset>(), I<pid> can also be: -1, meaning perform the change on "
"all threads except the caller and B<init>(8); or a value less than -1, in "
"which case the change is applied to all members of the process group whose "
"ID is -I<pid>."
msgstr ""
"カーネルが VFS ケーパビリティをサポートしていない場合、 I<hdrp> の I<pid> "
"フィールドが 0 以外であれば、 B<capset>()  の操作対象は I<pid> で指定されたス"
"レッドのケーパビリティになる。 I<pid> が 0 の場合は呼び出し元のスレッドのケー"
"パビリティが操作対象となる。 I<pid> がシングルスレッド・プロセスを参照してい"
"る場合、 I<pid> は以前から使われているプロセスID を使って指定できる。 マルチ"
"スレッド・プロセス内のあるスレッドを対象にする場合は、 B<gettid>(2)  が返すス"
"レッドID を用いて指定する必要がある。 また、 B<capset>()  では -1 や -1 より"
"小さな値を指定することもできる。 -1 は呼び出し元と B<init>(8)  を除く全てのス"
"レッドを対象として変更を行うことを、 -1 より小さな値は ID が -I<pid> のプロセ"
"スグループの全メンバ を対象として変更を行うことを意味する。"

#. type: Plain text
#: build/C/man2/capget.2:160
msgid "For details on the data, see B<capabilities>(7)."
msgstr "このデータの詳細は B<capabilities>(7)  を参照すること。"

#. type: Plain text
#: build/C/man2/capget.2:179
msgid ""
"The calls will fail with the error B<EINVAL>, and set the I<version> field "
"of I<hdrp> to the kernel preferred value of B<_LINUX_CAPABILITY_VERSION_?> "
"when an unsupported I<version> value is specified.  In this way, one can "
"probe what the current preferred capability revision is."
msgstr ""
"I<hdrp> のフィールド I<version> にサポートされていない値が指定された場合、 呼"
"び出しはエラー B<EINVAL> で失敗し、 I<version> にカーネル推奨の "
"B<_LINUX_CAPABILITY_VERSION_?> を設定する。 このようにして、現在の推奨ケーパ"
"ビリティ・リビジョンが何かを 調べることができる。"

#. type: Plain text
#: build/C/man2/capget.2:188
msgid ""
"Bad memory address.  I<hdrp> must not be NULL.  I<datap> may be NULL only "
"when the user is trying to determine the preferred capability version format "
"supported by the kernel."
msgstr ""
"不正なメモリアドレス。 I<hdrp> は NULL であってはならない。 I<datap> に NULL "
"を指定してよいのは、ユーザがカーネルがサポートしている 推奨のケーパビリティ・"
"バージョンを判定しようとしているときだけである。"

#. type: TP
#: build/C/man2/capget.2:188 build/C/man7/cpuset.7:1180
#: build/C/man7/cpuset.7:1189 build/C/man7/cpuset.7:1198
#: build/C/man7/cpuset.7:1208 build/C/man7/cpuset.7:1217
#: build/C/man7/cpuset.7:1224 build/C/man7/cpuset.7:1231
#: build/C/man2/getgroups.2:114 build/C/man2/getgroups.2:121
#: build/C/man2/getpriority.2:121 build/C/man2/getrlimit.2:440
#: build/C/man2/getrusage.2:191 build/C/man2/iopl.2:72
#: build/C/man2/ioprio_set.2:170 build/C/man2/setpgid.2:202
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/capget.2:191
msgid "One of the arguments was invalid."
msgstr "引き数のどれかが無効である。"

#. type: Plain text
#: build/C/man2/capget.2:196
msgid ""
"An attempt was made to add a capability to the Permitted set, or to set a "
"capability in the Effective or Inheritable sets that is not in the Permitted "
"set."
msgstr ""
"「許可ケーパビリティセット」にケーパビリティを追加しようとしているか、 もしく"
"は「許可ケーパビリティセット」に含まれないケーパビリティを 「実効ケーパビリ"
"ティセット」や「継承可能ケーパビリティセット」に セットしようとしている。"

#. type: Plain text
#: build/C/man2/capget.2:215
msgid ""
"The caller attempted to use B<capset>()  to modify the capabilities of a "
"thread other than itself, but lacked sufficient privilege.  For kernels "
"supporting VFS capabilities, this is never permitted.  For kernels lacking "
"VFS support, the B<CAP_SETPCAP> capability is required.  (A bug in kernels "
"before 2.6.11 meant that this error could also occur if a thread without "
"this capability tried to change its own capabilities by specifying the "
"I<pid> field as a nonzero value (i.e., the value returned by B<getpid>(2))  "
"instead of 0.)"
msgstr ""
"呼び出し元が自分以外のスレッドのケーパビリティを B<capset>()  を使って修正し"
"ようとしたが、十分な特権がなかった。 VFS ケーパビリティをサポートしているカー"
"ネルでは、 この操作が許可されることは決してない。 VFS ケーパビリティをサポー"
"トしていないカーネルでは、 B<CAP_SETPCAP> ケーパビリティが必要である。 (バー"
"ジョン 2.6.11 より前のカーネルには、 このケーパビリティを持たないスレッドが "
"I<pid> フィールドに 0 でない値 (つまり、0 の代わりに B<getpid>(2)  が返す値) "
"を指定して自分自身のケーパビリティを変更しようとした場合にも、 このエラーが発"
"生するというバグがあった。)"

#. type: TP
#: build/C/man2/capget.2:215 build/C/man7/cpuset.7:1330
#: build/C/man2/getpriority.2:129 build/C/man2/getrlimit.2:464
#: build/C/man2/getsid.2:70 build/C/man2/ioprio_set.2:187
#: build/C/man2/setpgid.2:217
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/capget.2:218
msgid "No such thread."
msgstr "そのようなスレッドが存在しない。"

#. type: Plain text
#: build/C/man2/capget.2:220 build/C/man2/ioprio_set.2:198
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 独自である。"

#. type: Plain text
#: build/C/man2/capget.2:225
msgid ""
"The portable interface to the capability querying and setting functions is "
"provided by the I<libcap> library and is available here:"
msgstr ""
"ケーパビリティを設定したり取得したりする機能のための移植性ある インターフェー"
"スは I<libcap> ライブラリによって提供される。 このライブラリは以下から入手で"
"きる:"

#. type: Plain text
#: build/C/man2/capget.2:228
msgid ""
"E<.UR http://git.kernel.org/cgit\\:/linux\\:/kernel\\:/git\\:/morgan\\:\\:/"
"libcap.git> E<.UE>"
msgstr ""
"E<.UR http://git.kernel.org/cgit\\:/linux\\:/kernel\\:/git\\:/morgan\\:\\:/"
"libcap.git> E<.UE>"

#. type: Plain text
#: build/C/man2/capget.2:232
msgid "B<clone>(2), B<gettid>(2), B<capabilities>(7)"
msgstr "B<clone>(2), B<gettid>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man7/cpuset.7:25
#, no-wrap
msgid "CPUSET"
msgstr "CPUSET"

#. type: TH
#: build/C/man7/cpuset.7:25 build/C/man2/getpriority.2:48
#: build/C/man2/ioprio_set.2:24 build/C/man7/svipc.7:40
#, no-wrap
msgid "2013-02-12"
msgstr "2013-02-12"

#. type: Plain text
#: build/C/man7/cpuset.7:28
msgid "cpuset - confine processes to processor and memory node subsets"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:35
msgid ""
"The cpuset file system is a pseudo-file-system interface to the kernel "
"cpuset mechanism, which is used to control the processor placement and "
"memory placement of processes.  It is commonly mounted at I</dev/cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:52
msgid ""
"On systems with kernels compiled with built in support for cpusets, all "
"processes are attached to a cpuset, and cpusets are always present.  If a "
"system supports cpusets, then it will have the entry B<nodev cpuset> in the "
"file I</proc/filesystems>.  By mounting the cpuset file system (see the "
"B<EXAMPLE> section below), the administrator can configure the cpusets on a "
"system to control the processor and memory placement of processes on that "
"system.  By default, if the cpuset configuration on a system is not modified "
"or if the cpuset file system is not even mounted, then the cpuset mechanism, "
"though present, has no affect on the system's behavior."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:54
msgid "A cpuset defines a list of CPUs and memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:63
msgid ""
"The CPUs of a system include all the logical processing units on which a "
"process can execute, including, if present, multiple processor cores within "
"a package and Hyper-Threads within a processor core.  Memory nodes include "
"all distinct banks of main memory; small and SMP systems typically have just "
"one memory node that contains all the system's main memory, while NUMA (non-"
"uniform memory access) systems have multiple memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:73
msgid ""
"Cpusets are represented as directories in a hierarchical pseudo-file system, "
"where the top directory in the hierarchy (I</dev/cpuset>)  represents the "
"entire system (all online CPUs and memory nodes)  and any cpuset that is the "
"child (descendant) of another parent cpuset contains a subset of that "
"parent's CPUs and memory nodes.  The directories and files representing "
"cpusets have normal file-system permissions."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:84
msgid ""
"Every process in the system belongs to exactly one cpuset.  A process is "
"confined to run only on the CPUs in the cpuset it belongs to, and to "
"allocate memory only on the memory nodes in that cpuset.  When a process "
"B<fork>(2)s, the child process is placed in the same cpuset as its parent.  "
"With sufficient privilege, a process may be moved from one cpuset to another "
"and the allowed CPUs and memory nodes of an existing cpuset may be changed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:92
msgid ""
"When the system begins booting, a single cpuset is defined that includes all "
"CPUs and memory nodes on the system, and all processes are in that cpuset.  "
"During the boot process, or later during normal system operation, other "
"cpusets may be created, as subdirectories of this top cpuset, under the "
"control of the system administrator, and processes may be placed in these "
"other cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:114
msgid ""
"Cpusets are integrated with the B<sched_setaffinity>(2)  scheduling affinity "
"mechanism and the B<mbind>(2)  and B<set_mempolicy>(2)  memory-placement "
"mechanisms in the kernel.  Neither of these mechanisms let a process make "
"use of a CPU or memory node that is not allowed by that process's cpuset.  "
"If changes to a process's cpuset placement conflict with these other "
"mechanisms, then cpuset placement is enforced even if it means overriding "
"these other mechanisms.  The kernel accomplishes this overriding by silently "
"restricting the CPUs and memory nodes requested by these other mechanisms to "
"those allowed by the invoking process's cpuset.  This can result in these "
"other calls returning an error, if for example, such a call ends up "
"requesting an empty set of CPUs or memory nodes, after that request is "
"restricted to the invoking process's cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:120
msgid ""
"Typically, a cpuset is used to manage the CPU and memory-node confinement "
"for a set of cooperating processes such as a batch scheduler job, and these "
"other mechanisms are used to manage the placement of individual processes or "
"memory regions within that set or job."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:120
#, no-wrap
msgid "FILES"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:125
msgid ""
"Each directory below I</dev/cpuset> represents a cpuset and contains a fixed "
"set of pseudo-files describing the state of that cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:135
msgid ""
"New cpusets are created using the B<mkdir>(2)  system call or the B<mkdir>"
"(1)  command.  The properties of a cpuset, such as its flags, allowed CPUs "
"and memory nodes, and attached processes, are queried and modified by "
"reading or writing to the appropriate file in that cpuset's directory, as "
"listed below."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:141
msgid ""
"The pseudo-files in each cpuset directory are automatically created when the "
"cpuset is created, as a result of the B<mkdir>(2)  invocation.  It is not "
"possible to directly add or remove these pseudo-files."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:149
msgid ""
"A cpuset directory that contains no child cpuset directories, and has no "
"attached processes, can be removed using B<rmdir>(2)  or B<rmdir>(1).  It is "
"not necessary, or possible, to remove the pseudo-files inside the directory "
"before removing it."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:163
msgid ""
"The pseudo-files in each cpuset directory are small text files that may be "
"read and written using traditional shell utilities such as B<cat>(1), and "
"B<echo>(1), or from a program by using file I/O library functions or system "
"calls, such as B<open>(2), B<read>(2), B<write>(2), and B<close>(2)."
msgstr ""

#.  ====================== tasks ======================
#. type: Plain text
#: build/C/man7/cpuset.7:168
msgid ""
"The pseudo-files in a cpuset directory represent internal kernel state and "
"do not have any persistent image on disk.  Each of these per-cpuset files is "
"listed and described below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:168
#, no-wrap
msgid "I<tasks>"
msgstr "I<tasks>"

#. type: Plain text
#: build/C/man7/cpuset.7:178
msgid ""
"List of the process IDs (PIDs) of the processes in that cpuset.  The list is "
"formatted as a series of ASCII decimal numbers, each followed by a newline.  "
"A process may be added to a cpuset (automatically removing it from the "
"cpuset that previously contained it) by writing its PID to that cpuset's "
"I<tasks> file (with or without a trailing newline.)"
msgstr ""

#.  =================== notify_on_release ===================
#. type: Plain text
#: build/C/man7/cpuset.7:186
msgid ""
"B<Warning:> only one PID may be written to the I<tasks> file at a time.  If "
"a string is written that contains more than one PID, only the first one will "
"be used."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:186
#, no-wrap
msgid "I<notify_on_release>"
msgstr "I<notify_on_release>"

#.  ====================== cpus ======================
#. type: Plain text
#: build/C/man7/cpuset.7:195
msgid ""
"Flag (0 or 1).  If set (1), that cpuset will receive special handling after "
"it is released, that is, after all processes cease using it (i.e., terminate "
"or are moved to a different cpuset)  and all child cpuset directories have "
"been removed.  See the B<Notify On Release> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:195
#, no-wrap
msgid "I<cpuset.cpus>"
msgstr "I<cpuset.cpus>"

#. type: Plain text
#: build/C/man7/cpuset.7:202
msgid ""
"List of the physical numbers of the CPUs on which processes in that cpuset "
"are allowed to execute.  See B<List Format> below for a description of the "
"format of I<cpus>."
msgstr ""

#.  ==================== cpu_exclusive ====================
#. type: Plain text
#: build/C/man7/cpuset.7:208
msgid ""
"The CPUs allowed to a cpuset may be changed by writing a new list to its "
"I<cpus> file."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:208
#, no-wrap
msgid "I<cpuset.cpu_exclusive>"
msgstr "I<cpuset.cpu_exclusive>"

#. type: Plain text
#: build/C/man7/cpuset.7:215
msgid ""
"Flag (0 or 1).  If set (1), the cpuset has exclusive use of its CPUs (no "
"sibling or cousin cpuset may overlap CPUs).  By default this is off (0).  "
"Newly created cpusets also initially default this to off (0)."
msgstr ""

#.  ====================== mems ======================
#. type: Plain text
#: build/C/man7/cpuset.7:237
msgid ""
"Two cpusets are I<sibling> cpusets if they share the same parent cpuset in "
"the I</dev/cpuset> hierarchy.  Two cpusets are I<cousin> cpusets if neither "
"is the ancestor of the other.  Regardless of the I<cpu_exclusive> setting, "
"if one cpuset is the ancestor of another, and if both of these cpusets have "
"nonempty I<cpus>, then their I<cpus> must overlap, because the I<cpus> of "
"any cpuset are always a subset of the I<cpus> of its parent cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:237
#, no-wrap
msgid "I<cpuset.mems>"
msgstr "I<cpuset.mems>"

#.  ==================== mem_exclusive ====================
#. type: Plain text
#: build/C/man7/cpuset.7:245
msgid ""
"List of memory nodes on which processes in this cpuset are allowed to "
"allocate memory.  See B<List Format> below for a description of the format "
"of I<mems>."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:245
#, no-wrap
msgid "I<cpuset.mem_exclusive>"
msgstr "I<cpuset.mem_exclusive>"

#. type: Plain text
#: build/C/man7/cpuset.7:253
msgid ""
"Flag (0 or 1).  If set (1), the cpuset has exclusive use of its memory nodes "
"(no sibling or cousin may overlap).  Also if set (1), the cpuset is a "
"B<Hardwall> cpuset (see below.)  By default this is off (0).  Newly created "
"cpusets also initially default this to off (0)."
msgstr ""

#.  ==================== mem_hardwall ====================
#. type: Plain text
#: build/C/man7/cpuset.7:261
msgid ""
"Regardless of the I<mem_exclusive> setting, if one cpuset is the ancestor of "
"another, then their memory nodes must overlap, because the memory nodes of "
"any cpuset are always a subset of the memory nodes of that cpuset's parent "
"cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:261
#, no-wrap
msgid "I<cpuset.mem_hardwall> (since Linux 2.6.26)"
msgstr "I<cpuset.mem_hardwall> (Linux 2.6.26 以降)"

#.  ==================== memory_migrate ====================
#. type: Plain text
#: build/C/man7/cpuset.7:272
msgid ""
"Flag (0 or 1).  If set (1), the cpuset is a B<Hardwall> cpuset (see below.)  "
"Unlike B<mem_exclusive>, there is no constraint on whether cpusets marked "
"B<mem_hardwall> may have overlapping memory nodes with sibling or cousin "
"cpusets.  By default this is off (0).  Newly created cpusets also initially "
"default this to off (0)."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:272
#, no-wrap
msgid "I<cpuset.memory_migrate> (since Linux 2.6.16)"
msgstr "I<cpuset.memory_migrate> (Linux 2.6.16 以降)"

#.  ==================== memory_pressure ====================
#. type: Plain text
#: build/C/man7/cpuset.7:279
msgid ""
"Flag (0 or 1).  If set (1), then memory migration is enabled.  By default "
"this is off (0).  See the B<Memory Migration> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:279
#, no-wrap
msgid "I<cpuset.memory_pressure> (since Linux 2.6.16)"
msgstr "I<cpuset.memory_pressure> (Linux 2.6.16 以降)"

#.  ================= memory_pressure_enabled =================
#. type: Plain text
#: build/C/man7/cpuset.7:292
msgid ""
"A measure of how much memory pressure the processes in this cpuset are "
"causing.  See the B<Memory Pressure> section, below.  Unless "
"I<memory_pressure_enabled> is enabled, always has value zero (0).  This file "
"is read-only.  See the B<WARNINGS> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:292
#, no-wrap
msgid "I<cpuset.memory_pressure_enabled> (since Linux 2.6.16)"
msgstr "I<cpuset.memory_pressure_enabled> (Linux 2.6.16 以降)"

#.  ================== memory_spread_page ==================
#. type: Plain text
#: build/C/man7/cpuset.7:304
msgid ""
"Flag (0 or 1).  This file is present only in the root cpuset, normally I</"
"dev/cpuset>.  If set (1), the I<memory_pressure> calculations are enabled "
"for all cpusets in the system.  By default this is off (0).  See the "
"B<Memory Pressure> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:304
#, no-wrap
msgid "I<cpuset.memory_spread_page> (since Linux 2.6.17)"
msgstr "I<cpuset.memory_spread_page> (Linux 2.6.17 以降)"

#.  ================== memory_spread_slab ==================
#. type: Plain text
#: build/C/man7/cpuset.7:314
msgid ""
"Flag (0 or 1).  If set (1), pages in the kernel page cache (file-system "
"buffers) are uniformly spread across the cpuset.  By default this is off (0) "
"in the top cpuset, and inherited from the parent cpuset in newly created "
"cpusets.  See the B<Memory Spread> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:314
#, no-wrap
msgid "I<cpuset.memory_spread_slab> (since Linux 2.6.17)"
msgstr "I<cpuset.memory_spread_slab> (Linux 2.6.17 以降)"

#.  ================== sched_load_balance ==================
#. type: Plain text
#: build/C/man7/cpuset.7:325
msgid ""
"Flag (0 or 1).  If set (1), the kernel slab caches for file I/O (directory "
"and inode structures) are uniformly spread across the cpuset.  By default "
"this is off (0) in the top cpuset, and inherited from the parent cpuset in "
"newly created cpusets.  See the B<Memory Spread> section, below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:325
#, no-wrap
msgid "I<cpuset.sched_load_balance> (since Linux 2.6.24)"
msgstr "I<cpuset.sched_load_balance> (Linux 2.6.24 以降)"

#.  ================== sched_relax_domain_level ==================
#. type: Plain text
#: build/C/man7/cpuset.7:339
msgid ""
"Flag (0 or 1).  If set (1, the default) the kernel will automatically load "
"balance processes in that cpuset over the allowed CPUs in that cpuset.  If "
"cleared (0) the kernel will avoid load balancing processes in this cpuset, "
"I<unless> some other cpuset with overlapping CPUs has its "
"I<sched_load_balance> flag set.  See B<Scheduler Load Balancing>, below, for "
"further details."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:339
#, no-wrap
msgid "I<cpuset.sched_relax_domain_level> (since Linux 2.6.26)"
msgstr "I<cpuset.sched_relax_domain_level> (Linux 2.6.26 以降)"

#.  ================== proc cpuset ==================
#. type: Plain text
#: build/C/man7/cpuset.7:359
msgid ""
"Integer, between -1 and a small positive value.  The "
"I<sched_relax_domain_level> controls the width of the range of CPUs over "
"which the kernel scheduler performs immediate rebalancing of runnable tasks "
"across CPUs.  If I<sched_load_balance> is disabled, then the setting of "
"I<sched_relax_domain_level> does not matter, as no such load balancing is "
"done.  If I<sched_load_balance> is enabled, then the higher the value of the "
"I<sched_relax_domain_level>, the wider the range of CPUs over which "
"immediate load balancing is attempted.  See B<Scheduler Relax Domain Level>, "
"below, for further details."
msgstr ""

#.  ================== proc status ==================
#. type: Plain text
#: build/C/man7/cpuset.7:367
msgid ""
"In addition to the above pseudo-files in each directory below I</dev/"
"cpuset>, each process has a pseudo-file, I</proc/E<lt>pidE<gt>/cpuset>, that "
"displays the path of the process's cpuset directory relative to the root of "
"the cpuset file system."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:378
msgid ""
"Also the I</proc/E<lt>pidE<gt>/status> file for each process has four added "
"lines, displaying the process's I<Cpus_allowed> (on which CPUs it may be "
"scheduled) and I<Mems_allowed> (on which memory nodes it may obtain memory), "
"in the two formats B<Mask Format> and B<List Format> (see below)  as shown "
"in the following example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:385
#, no-wrap
msgid ""
"Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff\n"
"Cpus_allowed_list:     0-127\n"
"Mems_allowed:   ffffffff,ffffffff\n"
"Mems_allowed_list:     0-63\n"
msgstr ""
"Cpus_allowed:   ffffffff,ffffffff,ffffffff,ffffffff\n"
"Cpus_allowed_list:     0-127\n"
"Mems_allowed:   ffffffff,ffffffff\n"
"Mems_allowed_list:     0-63\n"

#.  ================== EXTENDED CAPABILITIES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:391
msgid ""
"The \"allowed\" fields were added in Linux 2.6.24; the \"allowed_list\" "
"fields were added in Linux 2.6.26."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:391
#, no-wrap
msgid "EXTENDED CAPABILITIES"
msgstr ""

#.  ================== Exclusive Cpusets ==================
#. type: Plain text
#: build/C/man7/cpuset.7:399
msgid ""
"In addition to controlling which I<cpus> and I<mems> a process is allowed to "
"use, cpusets provide the following extended capabilities."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:399
#, no-wrap
msgid "Exclusive cpusets"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:406
msgid ""
"If a cpuset is marked I<cpu_exclusive> or I<mem_exclusive>, no other cpuset, "
"other than a direct ancestor or descendant, may share any of the same CPUs "
"or memory nodes."
msgstr ""

#.  ================== Hardwall ==================
#. type: Plain text
#: build/C/man7/cpuset.7:432
msgid ""
"A cpuset that is I<mem_exclusive> restricts kernel allocations for buffer "
"cache pages and other internal kernel data pages commonly shared by the "
"kernel across multiple users.  All cpusets, whether I<mem_exclusive> or not, "
"restrict allocations of memory for user space.  This enables configuring a "
"system so that several independent jobs can share common kernel data, while "
"isolating each job's user allocation in its own cpuset.  To do this, "
"construct a large I<mem_exclusive> cpuset to hold all the jobs, and "
"construct child, non-I<mem_exclusive> cpusets for each individual job.  Only "
"a small amount of kernel memory, such as requests from interrupt handlers, "
"is allowed to be placed on memory nodes outside even a I<mem_exclusive> "
"cpuset."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:432
#, no-wrap
msgid "Hardwall"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:447
msgid ""
"A cpuset that has I<mem_exclusive> or I<mem_hardwall> set is a I<hardwall> "
"cpuset.  A I<hardwall> cpuset restricts kernel allocations for page, buffer, "
"and other data commonly shared by the kernel across multiple users.  All "
"cpusets, whether I<hardwall> or not, restrict allocations of memory for user "
"space."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:458
msgid ""
"This enables configuring a system so that several independent jobs can share "
"common kernel data, such as file system pages, while isolating each job's "
"user allocation in its own cpuset.  To do this, construct a large "
"I<hardwall> cpuset to hold all the jobs, and construct child cpusets for "
"each individual job which are not I<hardwall> cpusets."
msgstr ""

#.  ================== Notify On Release ==================
#. type: Plain text
#: build/C/man7/cpuset.7:464
msgid ""
"Only a small amount of kernel memory, such as requests from interrupt "
"handlers, is allowed to be taken outside even a I<hardwall> cpuset."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:464
#, no-wrap
msgid "Notify on release"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:476
msgid ""
"If the I<notify_on_release> flag is enabled (1) in a cpuset, then whenever "
"the last process in the cpuset leaves (exits or attaches to some other "
"cpuset)  and the last child cpuset of that cpuset is removed, the kernel "
"will run the command I</sbin/cpuset_release_agent>, supplying the pathname "
"(relative to the mount point of the cpuset file system) of the abandoned "
"cpuset.  This enables automatic removal of abandoned cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:484
msgid ""
"The default value of I<notify_on_release> in the root cpuset at system boot "
"is disabled (0).  The default value of other cpusets at creation is the "
"current value of their parent's I<notify_on_release> setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:492
msgid ""
"The command I</sbin/cpuset_release_agent> is invoked, with the name (I</dev/"
"cpuset> relative path)  of the to-be-released cpuset in I<argv[1]>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:496
msgid ""
"The usual contents of the command I</sbin/cpuset_release_agent> is simply "
"the shell script:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:501
#, no-wrap
msgid ""
"#!/bin/sh\n"
"rmdir /dev/cpuset/$1\n"
msgstr ""
"#!/bin/sh\n"
"rmdir /dev/cpuset/$1\n"

#.  ================== Memory Pressure ==================
#. type: Plain text
#: build/C/man7/cpuset.7:509
msgid ""
"As with other flag values below, this flag can be changed by writing an "
"ASCII number 0 or 1 (with optional trailing newline)  into the file, to "
"clear or set the flag, respectively."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:509
#, no-wrap
msgid "Memory pressure"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:515
msgid ""
"The I<memory_pressure> of a cpuset provides a simple per-cpuset running "
"average of the rate that the processes in a cpuset are attempting to free up "
"in-use memory on the nodes of the cpuset to satisfy additional memory "
"requests."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:519
msgid ""
"This enables batch managers that are monitoring jobs running in dedicated "
"cpusets to efficiently detect what level of memory pressure that job is "
"causing."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:526
msgid ""
"This is useful both on tightly managed systems running a wide mix of "
"submitted jobs, which may choose to terminate or reprioritize jobs that are "
"trying to use more memory than allowed on the nodes assigned them, and with "
"tightly coupled, long-running, massively parallel scientific computing jobs "
"that will dramatically fail to meet required performance goals if they start "
"to use more memory than allowed to them."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:531
msgid ""
"This mechanism provides a very economical way for the batch manager to "
"monitor a cpuset for signs of memory pressure.  It's up to the batch manager "
"or other user code to decide what action to take if it detects signs of "
"memory pressure."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:538
msgid ""
"Unless memory pressure calculation is enabled by setting the pseudo-file I</"
"dev/cpuset/cpuset.memory_pressure_enabled>, it is not computed for any "
"cpuset, and reads from any I<memory_pressure> always return zero, as "
"represented by the ASCII string \"0\\en\".  See the B<WARNINGS> section, "
"below."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:540
msgid "A per-cpuset, running average is employed for the following reasons:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:545
msgid ""
"Because this meter is per-cpuset rather than per-process or per virtual "
"memory region, the system load imposed by a batch scheduler monitoring this "
"metric is sharply reduced on large systems, because a scan of the tasklist "
"can be avoided on each set of queries."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:550
msgid ""
"Because this meter is a running average rather than an accumulating counter, "
"a batch scheduler can detect memory pressure with a single read, instead of "
"having to read and accumulate results for a period of time."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:556
msgid ""
"Because this meter is per-cpuset rather than per-process, the batch "
"scheduler can obtain the key information\\(emmemory pressure in a cpuset"
"\\(emwith a single read, rather than having to query and accumulate results "
"over all the (dynamically changing)  set of processes in the cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:564
msgid ""
"The I<memory_pressure> of a cpuset is calculated using a per-cpuset simple "
"digital filter that is kept within the kernel.  For each cpuset, this filter "
"tracks the recent rate at which processes attached to that cpuset enter the "
"kernel direct reclaim code."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:573
msgid ""
"The kernel direct reclaim code is entered whenever a process has to satisfy "
"a memory page request by first finding some other page to repurpose, due to "
"lack of any readily available already free pages.  Dirty file system pages "
"are repurposed by first writing them to disk.  Unmodified file system buffer "
"pages are repurposed by simply dropping them, though if that page is needed "
"again, it will have to be reread from disk."
msgstr ""

#.  ================== Memory Spread ==================
#. type: Plain text
#: build/C/man7/cpuset.7:581
msgid ""
"The I<cpuset.memory_pressure> file provides an integer number representing "
"the recent (half-life of 10 seconds) rate of entries to the direct reclaim "
"code caused by any process in the cpuset, in units of reclaims attempted per "
"second, times 1000."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:581
#, no-wrap
msgid "Memory spread"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:589
msgid ""
"There are two Boolean flag files per cpuset that control where the kernel "
"allocates pages for the file-system buffers and related in-kernel data "
"structures.  They are called I<cpuset.memory_spread_page> and I<cpuset."
"memory_spread_slab>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:596
msgid ""
"If the per-cpuset Boolean flag file I<cpuset.memory_spread_page> is set, "
"then the kernel will spread the file-system buffers (page cache) evenly over "
"all the nodes that the faulting process is allowed to use, instead of "
"preferring to put those pages on the node where the process is running."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:604
msgid ""
"If the per-cpuset Boolean flag file I<cpuset.memory_spread_slab> is set, "
"then the kernel will spread some file-system-related slab caches, such as "
"those for inodes and directory entries, evenly over all the nodes that the "
"faulting process is allowed to use, instead of preferring to put those pages "
"on the node where the process is running."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:609
msgid ""
"The setting of these flags does not affect the data segment (see B<brk>(2))  "
"or stack segment pages of a process."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:617
msgid ""
"By default, both kinds of memory spreading are off and the kernel prefers to "
"allocate memory pages on the node local to where the requesting process is "
"running.  If that node is not allowed by the process's NUMA memory policy or "
"cpuset configuration or if there are insufficient free memory pages on that "
"node, then the kernel looks for the nearest node that is allowed and has "
"sufficient free memory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:620
msgid ""
"When new cpusets are created, they inherit the memory spread settings of "
"their parent."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:635
msgid ""
"Setting memory spreading causes allocations for the affected page or slab "
"caches to ignore the process's NUMA memory policy and be spread instead.  "
"However, the effect of these changes in memory placement caused by cpuset-"
"specified memory spreading is hidden from the B<mbind>(2)  or "
"B<set_mempolicy>(2)  calls.  These two NUMA memory policy calls always "
"appear to behave as if no cpuset-specified memory spreading is in effect, "
"even if it is.  If cpuset memory spreading is subsequently turned off, the "
"NUMA memory policy most recently specified by these calls is automatically "
"reapplied."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:644
msgid ""
"Both I<cpuset.memory_spread_page> and I<cpuset.memory_spread_slab> are "
"Boolean flag files.  By default they contain \"0\", meaning that the feature "
"is off for that cpuset.  If a \"1\" is written to that file, that turns the "
"named feature on."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:647
msgid ""
"Cpuset-specified memory spreading behaves similarly to what is known (in "
"other contexts) as round-robin or interleave memory placement."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:650
msgid ""
"Cpuset-specified memory spreading can provide substantial performance "
"improvements for jobs that:"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:650
#, no-wrap
msgid "a)"
msgstr "a)"

#. type: Plain text
#: build/C/man7/cpuset.7:654
msgid ""
"need to place thread-local data on memory nodes close to the CPUs which are "
"running the threads that most frequently access that data; but also"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:654
#, no-wrap
msgid "b)"
msgstr "b)"

#. type: Plain text
#: build/C/man7/cpuset.7:657
msgid ""
"need to access large file-system data sets that must to be spread across the "
"several nodes in the job's cpuset in order to fit."
msgstr ""

#.  ================== Memory Migration ==================
#. type: Plain text
#: build/C/man7/cpuset.7:664
msgid ""
"Without this policy, the memory allocation across the nodes in the job's "
"cpuset can become very uneven, especially for jobs that might have just a "
"single thread initializing or reading in the data set."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:664
#, no-wrap
msgid "Memory migration"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:673
msgid ""
"Normally, under the default setting (disabled) of I<cpuset.memory_migrate>, "
"once a page is allocated (given a physical page of main memory) then that "
"page stays on whatever node it was allocated, so long as it remains "
"allocated, even if the cpuset's memory-placement policy I<mems> subsequently "
"changes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:679
msgid ""
"When memory migration is enabled in a cpuset, if the I<mems> setting of the "
"cpuset is changed, then any memory page in use by any process in the cpuset "
"that is on a memory node that is no longer allowed will be migrated to a "
"memory node that is allowed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:685
msgid ""
"Furthermore, if a process is moved into a cpuset with I<memory_migrate> "
"enabled, any memory pages it uses that were on memory nodes allowed in its "
"previous cpuset, but which are not allowed in its new cpuset, will be "
"migrated to a memory node allowed in the new cpuset."
msgstr ""

#.  ================== Scheduler Load Balancing ==================
#. type: Plain text
#: build/C/man7/cpuset.7:693
msgid ""
"The relative placement of a migrated page within the cpuset is preserved "
"during these migration operations if possible.  For example, if the page was "
"on the second valid node of the prior cpuset, then the page will be placed "
"on the second valid node of the new cpuset, if possible."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:693
#, no-wrap
msgid "Scheduler load balancing"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:700
msgid ""
"The kernel scheduler automatically load balances processes.  If one CPU is "
"underutilized, the kernel will look for processes on other more overloaded "
"CPUs and move those processes to the underutilized CPU, within the "
"constraints of such placement mechanisms as cpusets and B<sched_setaffinity>"
"(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:713
msgid ""
"The algorithmic cost of load balancing and its impact on key shared kernel "
"data structures such as the process list increases more than linearly with "
"the number of CPUs being balanced.  For example, it costs more to load "
"balance across one large set of CPUs than it does to balance across two "
"smaller sets of CPUs, each of half the size of the larger set.  (The precise "
"relationship between the number of CPUs being balanced and the cost of load "
"balancing depends on implementation details of the kernel process scheduler, "
"which is subject to change over time, as improved kernel scheduler "
"algorithms are implemented.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:719
msgid ""
"The per-cpuset flag I<sched_load_balance> provides a mechanism to suppress "
"this automatic scheduler load balancing in cases where it is not needed and "
"suppressing it would have worthwhile performance benefits."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:723
msgid ""
"By default, load balancing is done across all CPUs, except those marked "
"isolated using the kernel boot time \"isolcpus=\" argument.  (See "
"B<Scheduler Relax Domain Level>, below, to change this default.)"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:726
msgid ""
"This default load balancing across all CPUs is not well suited to the "
"following two situations:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:730
msgid ""
"On large systems, load balancing across many CPUs is expensive.  If the "
"system is managed using cpusets to place independent jobs on separate sets "
"of CPUs, full load balancing is unnecessary."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:734
msgid ""
"Systems supporting real-time on some CPUs need to minimize system overhead "
"on those CPUs, including avoiding process load balancing if that is not "
"needed."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:744
msgid ""
"When the per-cpuset flag I<sched_load_balance> is enabled (the default "
"setting), it requests load balancing across all the CPUs in that cpuset's "
"allowed CPUs, ensuring that load balancing can move a process (not otherwise "
"pinned, as by B<sched_setaffinity>(2))  from any CPU in that cpuset to any "
"other."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:753
msgid ""
"When the per-cpuset flag I<sched_load_balance> is disabled, then the "
"scheduler will avoid load balancing across the CPUs in that cpuset, "
"I<except> in so far as is necessary because some overlapping cpuset has "
"I<sched_load_balance> enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:761
msgid ""
"So, for example, if the top cpuset has the flag I<sched_load_balance> "
"enabled, then the scheduler will load balance across all CPUs, and the "
"setting of the I<sched_load_balance> flag in other cpusets has no effect, as "
"we're already fully load balancing."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:766
msgid ""
"Therefore in the above two situations, the flag I<sched_load_balance> should "
"be disabled in the top cpuset, and only some of the smaller, child cpusets "
"would have this flag enabled."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:774
msgid ""
"When doing this, you don't usually want to leave any unpinned processes in "
"the top cpuset that might use nontrivial amounts of CPU, as such processes "
"may be artificially constrained to some subset of CPUs, depending on the "
"particulars of this flag setting in descendant cpusets.  Even if such a "
"process could use spare CPU cycles in some other CPUs, the kernel scheduler "
"might not consider the possibility of load balancing that process to the "
"underused CPU."
msgstr ""

#.  ================== Scheduler Relax Domain Level ==================
#. type: Plain text
#: build/C/man7/cpuset.7:780
msgid ""
"Of course, processes pinned to a particular CPU can be left in a cpuset that "
"disables I<sched_load_balance> as those processes aren't going anywhere else "
"anyway."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:780
#, no-wrap
msgid "Scheduler relax domain level"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:801
msgid ""
"The kernel scheduler performs immediate load balancing whenever a CPU "
"becomes free or another task becomes runnable.  This load balancing works to "
"ensure that as many CPUs as possible are usefully employed running tasks.  "
"The kernel also performs periodic load balancing off the software clock "
"described in I<time>(7).  The setting of I<sched_relax_domain_level> applies "
"only to immediate load balancing.  Regardless of the "
"I<sched_relax_domain_level> setting, periodic load balancing is attempted "
"over all CPUs (unless disabled by turning off I<sched_load_balance>.)  In "
"any case, of course, tasks will be scheduled to run only on CPUs allowed by "
"their cpuset, as modified by B<sched_setaffinity>(2)  system calls."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:809
msgid ""
"On small systems, such as those with just a few CPUs, immediate load "
"balancing is useful to improve system interactivity and to minimize wasteful "
"idle CPU cycles.  But on large systems, attempting immediate load balancing "
"across a large number of CPUs can be more costly than it is worth, depending "
"on the particular performance characteristics of the job mix and the "
"hardware."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:817
msgid ""
"The exact meaning of the small integer values of I<sched_relax_domain_level> "
"will depend on internal implementation details of the kernel scheduler code "
"and on the non-uniform architecture of the hardware.  Both of these will "
"evolve over time and vary by system architecture and kernel version."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:822
msgid ""
"As of this writing, when this capability was introduced in Linux 2.6.26, on "
"certain popular architectures, the positive values of "
"I<sched_relax_domain_level> have the following meanings."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:824
#, no-wrap
msgid "B<(1)>"
msgstr "B<(1)>"

#. type: Plain text
#: build/C/man7/cpuset.7:827
msgid ""
"Perform immediate load balancing across Hyper-Thread siblings on the same "
"core."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:827
#, no-wrap
msgid "B<(2)>"
msgstr "B<(2)>"

#. type: Plain text
#: build/C/man7/cpuset.7:829
msgid ""
"Perform immediate load balancing across other cores in the same package."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:829
#, no-wrap
msgid "B<(3)>"
msgstr "B<(3)>"

#. type: Plain text
#: build/C/man7/cpuset.7:832
msgid ""
"Perform immediate load balancing across other CPUs on the same node or blade."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:832
#, no-wrap
msgid "B<(4)>"
msgstr "B<(4)>"

#. type: Plain text
#: build/C/man7/cpuset.7:835
msgid ""
"Perform immediate load balancing across over several (implementation detail) "
"nodes [On NUMA systems]."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:835
#, no-wrap
msgid "B<(5)>"
msgstr "B<(5)>"

#. type: Plain text
#: build/C/man7/cpuset.7:838
msgid ""
"Perform immediate load balancing across over all CPUs in system [On NUMA "
"systems]."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:847
msgid ""
"The I<sched_relax_domain_level> value of zero (0) always means don't perform "
"immediate load balancing, hence that load balancing is done only "
"periodically, not immediately when a CPU becomes available or another task "
"becomes runnable."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:855
msgid ""
"The I<sched_relax_domain_level> value of minus one (-1)  always means use "
"the system default value.  The system default value can vary by architecture "
"and kernel version.  This system default value can be changed by kernel boot-"
"time \"relax_domain_level=\" argument."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:863
msgid ""
"In the case of multiple overlapping cpusets which have conflicting "
"I<sched_relax_domain_level> values, then the highest such value applies to "
"all CPUs in any of the overlapping cpusets.  In such cases, the value "
"B<minus one (-1)> is the lowest value, overridden by any other value, and "
"the value B<zero (0)> is the next lowest value."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:863
#, no-wrap
msgid "FORMATS"
msgstr ""

#.  ================== Mask Format ==================
#. type: Plain text
#: build/C/man7/cpuset.7:867
msgid ""
"The following formats are used to represent sets of CPUs and memory nodes."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:867
#, no-wrap
msgid "Mask format"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:872
msgid ""
"The B<Mask Format> is used to represent CPU and memory-node bit masks in the "
"I</proc/E<lt>pidE<gt>/status> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:880
msgid ""
"This format displays each 32-bit word in hexadecimal (using ASCII characters "
"\"0\" - \"9\" and \"a\" - \"f\"); words are filled with leading zeros, if "
"required.  For masks longer than one word, a comma separator is used between "
"words.  Words are displayed in big-endian order, which has the most "
"significant bit first.  The hex digits within a word are also in big-endian "
"order."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:883
msgid ""
"The number of 32-bit words displayed is the minimum number needed to display "
"all bits of the bit mask, based on the size of the bit mask."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:885
msgid "Examples of the B<Mask Format>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:893
#, no-wrap
msgid ""
"00000001                        # just bit 0 set\n"
"40000000,00000000,00000000      # just bit 94 set\n"
"00000001,00000000,00000000      # just bit 64 set\n"
"000000ff,00000000               # bits 32-39 set\n"
"00000000,000E3862               # 1,5,6,11-13,17-19 set\n"
msgstr ""
"00000001                        # just bit 0 set\n"
"40000000,00000000,00000000      # just bit 94 set\n"
"00000001,00000000,00000000      # just bit 64 set\n"
"000000ff,00000000               # bits 32-39 set\n"
"00000000,000E3862               # 1,5,6,11-13,17-19 set\n"

#. type: Plain text
#: build/C/man7/cpuset.7:897
msgid "A mask with bits 0, 1, 2, 4, 8, 16, 32, and 64 set displays as:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:901
#, no-wrap
msgid "00000001,00000001,00010117\n"
msgstr "00000001,00000001,00010117\n"

#.  ================== List Format ==================
#. type: Plain text
#: build/C/man7/cpuset.7:908
msgid ""
"The first \"1\" is for bit 64, the second for bit 32, the third for bit 16, "
"the fourth for bit 8, the fifth for bit 4, and the \"7\" is for bits 2, 1, "
"and 0."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:908
#, no-wrap
msgid "List format"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:915
msgid ""
"The B<List Format> for I<cpus> and I<mems> is a comma-separated list of CPU "
"or memory-node numbers and ranges of numbers, in ASCII decimal."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:917
msgid "Examples of the B<List Format>:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:922
#, no-wrap
msgid ""
"0-4,9           # bits 0, 1, 2, 3, 4, and 9 set\n"
"0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13, and 14 set\n"
msgstr ""
"0-4,9           # bits 0, 1, 2, 3, 4, and 9 set\n"
"0-2,7,12-14     # bits 0, 1, 2, 7, 12, 13, and 14 set\n"

#.  ================== RULES ==================
#. type: SH
#: build/C/man7/cpuset.7:925
#, no-wrap
msgid "RULES"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:927
msgid "The following rules apply to each cpuset:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:930
msgid ""
"Its CPUs and memory nodes must be a (possibly equal)  subset of its parent's."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:934
msgid "It can be marked I<cpu_exclusive> only if its parent is."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:938
msgid "It can be marked I<mem_exclusive> only if its parent is."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:942
msgid "If it is I<cpu_exclusive>, its CPUs may not overlap any sibling."
msgstr ""

#.  ================== PERMISSIONS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:947
msgid ""
"If it is I<memory_exclusive>, its memory nodes may not overlap any sibling."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:947
#, no-wrap
msgid "PERMISSIONS"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:952
msgid ""
"The permissions of a cpuset are determined by the permissions of the "
"directories and pseudo-files in the cpuset file system, normally mounted at "
"I</dev/cpuset>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:961
msgid ""
"For instance, a process can put itself in some other cpuset (than its "
"current one) if it can write the I<tasks> file for that cpuset.  This "
"requires execute permission on the encompassing directories and write "
"permission on the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:968
msgid ""
"An additional constraint is applied to requests to place some other process "
"in a cpuset.  One process may not attach another to a cpuset unless it would "
"have permission to send that process a signal (see B<kill>(2))."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:979
msgid ""
"A process may create a child cpuset if it can access and write the parent "
"cpuset directory.  It can modify the CPUs or memory nodes in a cpuset if it "
"can access that cpuset's directory (execute permissions on the each of the "
"parent directories) and write the corresponding I<cpus> or I<mems> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1000
msgid ""
"There is one minor difference between the manner in which these permissions "
"are evaluated and the manner in which normal file-system operation "
"permissions are evaluated.  The kernel interprets relative pathnames "
"starting at a process's current working directory.  Even if one is operating "
"on a cpuset file, relative pathnames are interpreted relative to the "
"process's current working directory, not relative to the process's current "
"cpuset.  The only ways that cpuset paths relative to a process's current "
"cpuset can be used are if either the process's current working directory is "
"its cpuset (it first did a B<cd> or B<chdir>(2)  to its cpuset directory "
"beneath I</dev/cpuset>, which is a bit unusual)  or if some user code "
"converts the relative cpuset path to a full file-system path."
msgstr ""

#.  ================== WARNINGS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1015
msgid ""
"In theory, this means that user code should specify cpusets using absolute "
"pathnames, which requires knowing the mount point of the cpuset file system "
"(usually, but not necessarily, I</dev/cpuset>).  In practice, all user level "
"code that this author is aware of simply assumes that if the cpuset file "
"system is mounted, then it is mounted at I</dev/cpuset>.  Furthermore, it is "
"common practice for carefully written user code to verify the presence of "
"the pseudo-file I</dev/cpuset/tasks> in order to verify that the cpuset "
"pseudo-file system is currently mounted."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1015
#, no-wrap
msgid "WARNINGS"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1016
#, no-wrap
msgid "Enabling memory_pressure"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1025
msgid ""
"By default, the per-cpuset file I<cpuset.memory_pressure> always contains "
"zero (0).  Unless this feature is enabled by writing \"1\" to the pseudo-"
"file I</dev/cpuset/cpuset.memory_pressure_enabled>, the kernel does not "
"compute per-cpuset I<memory_pressure>."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1025
#, no-wrap
msgid "Using the echo command"
msgstr ""

#.  Gack!  csh(1)'s echo does this
#. type: Plain text
#: build/C/man7/cpuset.7:1036
msgid ""
"When using the B<echo> command at the shell prompt to change the values of "
"cpuset files, beware that the built-in B<echo> command in some shells does "
"not display an error message if the B<write>(2)  system call fails.  For "
"example, if the command:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1040
#, no-wrap
msgid "echo 19 E<gt> cpuset.mems\n"
msgstr "echo 19 E<gt> cpuset.mems\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1053
msgid ""
"failed because memory node 19 was not allowed (perhaps the current system "
"does not have a memory node 19), then the B<echo> command might not display "
"any error.  It is better to use the B</bin/echo> external command to change "
"cpuset file settings, as this command will display B<write>(2)  errors, as "
"in the example:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1058
#, no-wrap
msgid ""
"/bin/echo 19 E<gt> cpuset.mems\n"
"/bin/echo: write error: Invalid argument\n"
msgstr ""
"/bin/echo 19 E<gt> cpuset.mems\n"
"/bin/echo: write error: Invalid argument\n"

#.  ================== EXCEPTIONS ==================
#. type: SH
#: build/C/man7/cpuset.7:1061
#, no-wrap
msgid "EXCEPTIONS"
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1062
#, no-wrap
msgid "Memory placement"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1065
msgid ""
"Not all allocations of system memory are constrained by cpusets, for the "
"following reasons."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1080
msgid ""
"If hot-plug functionality is used to remove all the CPUs that are currently "
"assigned to a cpuset, then the kernel will automatically update the "
"I<cpus_allowed> of all processes attached to CPUs in that cpuset to allow "
"all CPUs.  When memory hot-plug functionality for removing memory nodes is "
"available, a similar exception is expected to apply there as well.  In "
"general, the kernel prefers to violate cpuset placement, rather than "
"starving a process that has had all its allowed CPUs or memory nodes taken "
"offline.  User code should reconfigure cpusets to refer only to online CPUs "
"and memory nodes when using hot-plug to add or remove such resources."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1088
msgid ""
"A few kernel-critical, internal memory-allocation requests, marked "
"GFP_ATOMIC, must be satisfied immediately.  The kernel may drop some request "
"or malfunction if one of these allocations fail.  If such a request cannot "
"be satisfied within the current process's cpuset, then we relax the cpuset, "
"and look for memory anywhere we can find it.  It's better to violate the "
"cpuset than stress the kernel."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1092
msgid ""
"Allocations of memory requested by kernel drivers while processing an "
"interrupt lack any relevant process context, and are not confined by cpusets."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1092
#, no-wrap
msgid "Renaming cpusets"
msgstr ""

#.  ================== ERRORS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1100
msgid ""
"You can use the B<rename>(2)  system call to rename cpusets.  Only simple "
"renaming is supported; that is, changing the name of a cpuset directory is "
"permitted, but moving a directory into a different directory is not "
"permitted."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1104
msgid ""
"The Linux kernel implementation of cpusets sets I<errno> to specify the "
"reason for a failed system call affecting cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1109
msgid ""
"The possible I<errno> settings and their meaning when set on a failed cpuset "
"call are as listed below."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1109
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man7/cpuset.7:1116
msgid ""
"Attempted a B<write>(2)  on a special cpuset file with a length larger than "
"some kernel-determined upper limit on the length of such writes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1123
msgid ""
"Attempted to B<write>(2)  the process ID (PID) of a process to a cpuset "
"I<tasks> file when one lacks permission to move that process."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1129
msgid ""
"Attempted to add, using B<write>(2), a CPU or memory node to a cpuset, when "
"that CPU or memory node was not already in its parent."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1137
msgid ""
"Attempted to set, using B<write>(2), I<cpuset.cpu_exclusive> or I<cpuset."
"mem_exclusive> on a cpuset whose parent lacks the same setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1144
msgid "Attempted to B<write>(2)  a I<cpuset.memory_pressure> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1147
msgid "Attempted to create a file in a cpuset directory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1147 build/C/man7/cpuset.7:1152
#: build/C/man7/cpuset.7:1157
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man7/cpuset.7:1152
msgid ""
"Attempted to remove, using B<rmdir>(2), a cpuset with attached processes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1157
msgid "Attempted to remove, using B<rmdir>(2), a cpuset with child cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1162
msgid ""
"Attempted to remove a CPU or memory node from a cpuset that is also in a "
"child of that cpuset."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1162 build/C/man7/cpuset.7:1167
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man7/cpuset.7:1167
msgid "Attempted to create, using B<mkdir>(2), a cpuset that already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1172
msgid "Attempted to B<rename>(2)  a cpuset to a name that already exists."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1180
msgid ""
"Attempted to B<read>(2)  or B<write>(2)  a cpuset file using a buffer that "
"is outside the writing processes accessible address space."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1189
msgid ""
"Attempted to change a cpuset, using B<write>(2), in a way that would violate "
"a I<cpu_exclusive> or I<mem_exclusive> attribute of that cpuset or any of "
"its siblings."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1198
msgid ""
"Attempted to B<write>(2)  an empty I<cpuset.cpus> or I<cpuset.mems> list to "
"a cpuset which has attached processes or child cpusets."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1208
msgid ""
"Attempted to B<write>(2)  a I<cpuset.cpus> or I<cpuset.mems> list which "
"included a range with the second number smaller than the first number."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1217
msgid ""
"Attempted to B<write>(2)  a I<cpuset.cpus> or I<cpuset.mems> list which "
"included an invalid character in the string."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1224
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.cpus> file that did not "
"include any online CPUs."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1231
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.mems> file that did not "
"include any online memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1238
msgid ""
"Attempted to B<write>(2)  a list to a I<cpuset.mems> file that included a "
"node that held no memory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1246
msgid ""
"Attempted to B<write>(2)  a string to a cpuset I<tasks> file that does not "
"begin with an ASCII decimal integer."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1251
msgid "Attempted to B<rename>(2)  a cpuset into a different directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1258
msgid ""
"Attempted to B<read>(2)  a I</proc/E<lt>pidE<gt>/cpuset> file for a cpuset "
"path that is longer than the kernel page size."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1263
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset whose base directory name "
"is longer than 255 characters."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1270
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset whose full pathname, "
"including the mount point (typically \"/dev/cpuset/\") prefix, is longer "
"than 4095 characters."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1270
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man7/cpuset.7:1275
msgid ""
"The cpuset was removed by another process at the same time as a B<write>(2)  "
"was attempted on one of the pseudo-files in the cpuset directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1280
msgid ""
"Attempted to create, using B<mkdir>(2), a cpuset in a parent cpuset that "
"doesn't exist."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1287
msgid ""
"Attempted to B<access>(2)  or B<open>(2)  a nonexistent file in a cpuset "
"directory."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1292
msgid ""
"Insufficient memory is available within the kernel; can occur on a variety "
"of system calls affecting cpusets, but only if the system is extremely short "
"of memory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1292 build/C/man7/cpuset.7:1304
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man7/cpuset.7:1304
msgid ""
"Attempted to B<write>(2)  the process ID (PID)  of a process to a cpuset "
"I<tasks> file when the cpuset had an empty I<cpuset.cpus> or empty I<cpuset."
"mems> setting."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1314
msgid ""
"Attempted to B<write>(2)  an empty I<cpuset.cpus> or I<cpuset.mems> setting "
"to a cpuset that has tasks attached."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1319
msgid "Attempted to B<rename>(2)  a nonexistent cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1322
msgid "Attempted to remove a file from a cpuset directory."
msgstr ""

#. type: TP
#: build/C/man7/cpuset.7:1322
#, no-wrap
msgid "B<ERANGE>"
msgstr "B<ERANGE>"

#. type: Plain text
#: build/C/man7/cpuset.7:1330
msgid ""
"Specified a I<cpuset.cpus> or I<cpuset.mems> list to the kernel which "
"included a number too large for the kernel to set in its bit masks."
msgstr ""

#.  ================== VERSIONS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1338
msgid ""
"Attempted to B<write>(2)  the process ID (PID) of a nonexistent process to a "
"cpuset I<tasks> file."
msgstr ""

#.  ================== NOTES ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1341
msgid "Cpusets appeared in version 2.6.12 of the Linux kernel."
msgstr ""

#.  ================== BUGS ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1352
msgid ""
"Despite its name, the I<pid> parameter is actually a thread ID, and each "
"thread in a threaded group can be attached to a different cpuset.  The value "
"returned from a call to B<gettid>(2)  can be passed in the argument I<pid>."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1352 build/C/man2/getpriority.2:225
#: build/C/man2/getrlimit.2:525 build/C/man2/ioprio_set.2:337
#: build/C/man2/setfsgid.2:104 build/C/man2/setfsuid.2:104
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#.  ================== EXAMPLE ==================
#. type: Plain text
#: build/C/man7/cpuset.7:1365
msgid ""
"I<cpuset.memory_pressure> cpuset files can be opened for writing, creation, "
"or truncation, but then the B<write>(2)  fails with I<errno> set to "
"B<EACCES>, and the creation and truncation options on B<open>(2)  have no "
"effect."
msgstr ""

#. type: SH
#: build/C/man7/cpuset.7:1365 build/C/man2/getrlimit.2:600
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man7/cpuset.7:1368
msgid ""
"The following examples demonstrate querying and setting cpuset options using "
"shell commands."
msgstr ""

#. type: SS
#: build/C/man7/cpuset.7:1368
#, no-wrap
msgid "Creating and attaching to a cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1371
msgid ""
"To create a new cpuset and attach the current command shell to it, the steps "
"are:"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1373 build/C/man7/cpuset.7:1412
#, no-wrap
msgid "1)"
msgstr "1)"

#. type: Plain text
#: build/C/man7/cpuset.7:1375
msgid "mkdir /dev/cpuset (if not already done)"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1375 build/C/man7/cpuset.7:1418
#, no-wrap
msgid "2)"
msgstr "2)"

#. type: Plain text
#: build/C/man7/cpuset.7:1377
msgid "mount -t cpuset none /dev/cpuset (if not already done)"
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1377 build/C/man7/cpuset.7:1421
#, no-wrap
msgid "3)"
msgstr "3)"

#. type: Plain text
#: build/C/man7/cpuset.7:1380
msgid "Create the new cpuset using B<mkdir>(1)."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1380 build/C/man7/cpuset.7:1424
#, no-wrap
msgid "4)"
msgstr "4)"

#. type: Plain text
#: build/C/man7/cpuset.7:1382
msgid "Assign CPUs and memory nodes to the new cpuset."
msgstr ""

#. type: IP
#: build/C/man7/cpuset.7:1382 build/C/man7/cpuset.7:1429
#, no-wrap
msgid "5)"
msgstr "5)"

#. type: Plain text
#: build/C/man7/cpuset.7:1384
msgid "Attach the shell to the new cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1389
msgid ""
"For example, the following sequence of commands will set up a cpuset named "
"\"Charlie\", containing just CPUs 2 and 3, and memory node 1, and then "
"attach the current shell to that cpuset."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1403
#, no-wrap
msgid ""
"$B< mkdir /dev/cpuset>\n"
"$B< mount -t cpuset cpuset /dev/cpuset>\n"
"$B< cd /dev/cpuset>\n"
"$B< mkdir Charlie>\n"
"$B< cd Charlie>\n"
"$B< /bin/echo 2-3 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 1 E<gt> cpuset.mems>\n"
"$B< /bin/echo $$ E<gt> tasks>\n"
"# The current shell is now running in cpuset Charlie\n"
"# The next line should display '/Charlie'\n"
"$B< cat /proc/self/cpuset>\n"
msgstr ""
"$B< mkdir /dev/cpuset>\n"
"$B< mount -t cpuset cpuset /dev/cpuset>\n"
"$B< cd /dev/cpuset>\n"
"$B< mkdir Charlie>\n"
"$B< cd Charlie>\n"
"$B< /bin/echo 2-3 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 1 E<gt> cpuset.mems>\n"
"$B< /bin/echo $$ E<gt> tasks>\n"
"# The current shell is now running in cpuset Charlie\n"
"# The next line should display '/Charlie'\n"
"$B< cat /proc/self/cpuset>\n"

#. type: SS
#: build/C/man7/cpuset.7:1405
#, no-wrap
msgid "Migrating a job to different memory nodes."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1410
msgid ""
"To migrate a job (the set of processes attached to a cpuset)  to different "
"CPUs and memory nodes in the system, including moving the memory pages "
"currently allocated to that job, perform the following steps."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1418
msgid ""
"Let's say we want to move the job in cpuset I<alpha> (CPUs 4-7 and memory "
"nodes 2-3) to a new cpuset I<beta> (CPUs 16-19 and memory nodes 8-9)."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1421
msgid "First create the new cpuset I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1424
msgid "Then allow CPUs 16-19 and memory nodes 8-9 in I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1429
msgid "Then enable I<memory_migration> in I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1434
msgid "Then move each process from I<alpha> to I<beta>."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1437
msgid "The following sequence of commands accomplishes this."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1447
#, no-wrap
msgid ""
"$B< cd /dev/cpuset>\n"
"$B< mkdir beta>\n"
"$B< cd beta>\n"
"$B< /bin/echo 16-19 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 8-9 E<gt> cpuset.mems>\n"
"$B< /bin/echo 1 E<gt> cpuset.memory_migrate>\n"
"$B< while read i; do /bin/echo $i; done E<lt> ../alpha/tasks E<gt> tasks>\n"
msgstr ""
"$B< cd /dev/cpuset>\n"
"$B< mkdir beta>\n"
"$B< cd beta>\n"
"$B< /bin/echo 16-19 E<gt> cpuset.cpus>\n"
"$B< /bin/echo 8-9 E<gt> cpuset.mems>\n"
"$B< /bin/echo 1 E<gt> cpuset.memory_migrate>\n"
"$B< while read i; do /bin/echo $i; done E<lt> ../alpha/tasks E<gt> tasks>\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1456
msgid ""
"The above should move any processes in I<alpha> to I<beta>, and any memory "
"held by these processes on memory nodes 2-3 to memory nodes 8-9, "
"respectively."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1458
msgid "Notice that the last step of the above sequence did not do:"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1462
#, no-wrap
msgid "$B< cp ../alpha/tasks tasks>\n"
msgstr "$B< cp ../alpha/tasks tasks>\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1473
msgid ""
"The I<while> loop, rather than the seemingly easier use of the B<cp>(1)  "
"command, was necessary because only one process PID at a time may be written "
"to the I<tasks> file."
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1481
msgid ""
"The same effect (writing one PID at a time) as the I<while> loop can be "
"accomplished more efficiently, in fewer keystrokes and in syntax that works "
"on any shell, but alas more obscurely, by using the B<-u> (unbuffered) "
"option of B<sed>(1):"
msgstr ""

#. type: Plain text
#: build/C/man7/cpuset.7:1485
#, no-wrap
msgid "$B< sed -un p E<lt> ../alpha/tasks E<gt> tasks>\n"
msgstr "$B< sed -un p E<lt> ../alpha/tasks E<gt> tasks>\n"

#. type: Plain text
#: build/C/man7/cpuset.7:1502
msgid ""
"B<taskset>(1), B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), "
"B<sched_getaffinity>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<set_mempolicy>(2), B<CPU_SET>(3), B<proc>(5), B<numa>(7), B<migratepages>"
"(8), B<numactl>(8)"
msgstr ""
"B<taskset>(1), B<get_mempolicy>(2), B<getcpu>(2), B<mbind>(2), "
"B<sched_getaffinity>(2), B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<set_mempolicy>(2), B<CPU_SET>(3), B<proc>(5), B<numa>(7), B<migratepages>"
"(8), B<numactl>(8)"

#. type: Plain text
#: build/C/man7/cpuset.7:1505
msgid "I<Documentation/cpusets.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/cpusets.txt>"

#. type: TH
#: build/C/man7/credentials.7:27
#, no-wrap
msgid "CREDENTIALS"
msgstr "CREDENTIALS"

#. type: TH
#: build/C/man7/credentials.7:27
#, no-wrap
msgid "2008-06-03"
msgstr "2008-06-03"

#. type: Plain text
#: build/C/man7/credentials.7:30
msgid "credentials - process identifiers"
msgstr "credentials - 認証に用いられるプロセスの識別子"

#. type: SS
#: build/C/man7/credentials.7:31
#, no-wrap
msgid "Process ID (PID)"
msgstr "プロセスID (PID)"

#. type: Plain text
#: build/C/man7/credentials.7:41
msgid ""
"Each process has a unique nonnegative integer identifier that is assigned "
"when the process is created using B<fork>(2).  A process can obtain its PID "
"using B<getpid>(2).  A PID is represented using the type I<pid_t> (defined "
"in I<E<lt>sys/types.hE<gt>>)."
msgstr ""
"各プロセスは、負でない整数の一意な識別子を持つ。 この識別子は B<fork>(2)  を"
"使ってプロセスが生成される際に割り当てられる。 プロセスは B<getpid>(2)  を"
"使って自分の PID を取得できる。 PID は I<pid_t> 型で表現される (I<pid_t> は "
"I<E<lt>sys/types.hE<gt>> で定義されている)。"

#.  .BR sched_rr_get_interval (2),
#.  .BR sched_getaffinity (2),
#.  .BR sched_setaffinity (2),
#.  .BR sched_getparam (2),
#.  .BR sched_setparam (2),
#.  .BR sched_setscheduler (2),
#.  .BR sched_getscheduler (2),
#.  .BR getsid (2),
#.  .BR waitid (2),
#.  .BR wait4 (2),
#. type: Plain text
#: build/C/man7/credentials.7:62
msgid ""
"PIDs are used in a range of system calls to identify the process affected by "
"the call, for example: B<kill>(2), B<ptrace>(2), B<setpriority>(2)  "
"B<setpgid>(2), B<setsid>(2), B<sigqueue>(3), and B<waitpid>(2)."
msgstr ""
"PID は各種のシステムコールでそのシステムコールが作用するプロセスを 特定するた"
"めに使用される。以下に例を挙げる: B<kill>(2), B<ptrace>(2), B<setpriority>"
"(2), B<setpgid>(2), B<setsid>(2), B<sigqueue>(3), B<waitpid>(2)."

#. type: Plain text
#: build/C/man7/credentials.7:65
msgid "A process's PID is preserved across an B<execve>(2)."
msgstr "プロセスの PID は B<execve>(2)  の前後で不変である。"

#. type: SS
#: build/C/man7/credentials.7:65
#, no-wrap
msgid "Parent process ID (PPID)"
msgstr "親プロセス ID (PPID)"

#. type: Plain text
#: build/C/man7/credentials.7:73
msgid ""
"A process's parent process ID identifies the process that created this "
"process using B<fork>(2).  A process can obtain its PPID using B<getppid>"
"(2).  A PPID is represented using the type I<pid_t>."
msgstr ""
"プロセスの親プロセスの ID は、 B<fork>(2)  を使ってそのプロセスを生成したプロ"
"セスを示す。 プロセスは B<getppid>(2)  を使って自分の PPID を取得できる。 "
"PPID は I<pid_t> 型で表現される。"

#. type: Plain text
#: build/C/man7/credentials.7:76
msgid "A process's PPID is preserved across an B<execve>(2)."
msgstr "プロセスの PPID は B<execve>(2)  の前後で不変である。"

#. type: SS
#: build/C/man7/credentials.7:76
#, no-wrap
msgid "Process group ID and session ID"
msgstr "プロセスグループ ID とセッション ID"

#. type: Plain text
#: build/C/man7/credentials.7:84
msgid ""
"Each process has a session ID and a process group ID, both represented using "
"the type I<pid_t>.  A process can obtain its session ID using B<getsid>(2), "
"and its process group ID using B<getpgrp>(2)."
msgstr ""
"各プロセスはセッション ID とプロセスグループ ID を持つ。 これらの ID はどちら"
"も I<pid_t> 型で表現される。 プロセスは、それぞれ B<getsid>(2), B<getpgrp>"
"(2)  を使って自分のセッション ID、プロセスグループ ID を取得できる。"

#. type: Plain text
#: build/C/man7/credentials.7:90
msgid ""
"A child created by B<fork>(2)  inherits its parent's session ID and process "
"group ID.  A process's session ID and process group ID are preserved across "
"an B<execve>(2)."
msgstr ""
"B<fork>(2)  で生成された子プロセスは親プロセスのセッション ID とプロセスグ"
"ループ ID を継承する。プロセスのセッション ID とプロセスグループ ID は "
"B<execve>(2)  の前後で不変である。"

#. type: Plain text
#: build/C/man7/credentials.7:103
msgid ""
"Sessions and process groups are abstractions devised to support shell job "
"control.  A process group (sometimes called a \"job\") is a collection of "
"processes that share the same process group ID; the shell creates a new "
"process group for the process(es) used to execute single command or pipeline "
"(e.g., the two processes created to execute the command \"ls\\ |\\ wc\" are "
"placed in the same process group).  A process's group membership can be set "
"using B<setpgid>(2).  The process whose process ID is the same as its "
"process group ID is the I<process group leader> for that group."
msgstr ""
"セッションとプロセスグループの概念は、シェルのジョブ制御を行うために 考案され"
"たものである。 プロセスグループ (時には「ジョブ」と呼ばれることもある) は、 "
"同じプロセスグループ ID を共有するプロセスの集まりである。 シェルは、一つのコ"
"マンドもしくはパイプラインの実行に使われるプロセス群に 対して一つのプロセスグ"
"ループを生成する (例えば、コマンド \"ls\\ |\\ wc\" を実行するために生成される"
"二つのプロセスは 同じプロセスグループに置かれる)。 所属するプロセスグループ"
"は B<setpgid>(2)  を使って設定できる。 自身のプロセス ID がプロセスグループ "
"ID と同じプロセスは、 そのグループの「プロセスグループ・リーダー」である。"

#. type: Plain text
#: build/C/man7/credentials.7:115
msgid ""
"A session is a collection of processes that share the same session ID.  All "
"of the members of a process group also have the same session ID (i.e., all "
"of the members of a process group always belong to the same session, so that "
"sessions and process groups form a strict two-level hierarchy of "
"processes.)  A new session is created when a process calls B<setsid>(2), "
"which creates a new session whose session ID is the same as the PID of the "
"process that called B<setsid>(2).  The creator of the session is called the "
"I<session leader>."
msgstr ""
"セッションは、同じセッション ID を共有するプロセスの集まりである。 ある一つの"
"プロセスグループの全メンバーは同じセッション ID を持つ (つまり、一つのプロセ"
"スグループのメンバーは全て同じセッションに所属し、 これにより、セッションとプ"
"ロセスグループで二階層のプロセス階層が形成できる)。 新たなセッションの生成は"
"プロセスが B<setsid>(2)  を呼び出すことで行う。 B<setsid>(2)  は、 B<setsid>"
"(2)  を呼び出したプロセスの PID と同じ値のセッション ID を持つ 新たなセッショ"
"ンを生成する。 セッションの生成者は「セッション・リーダー」と呼ばれる。"

#. type: SS
#: build/C/man7/credentials.7:115
#, no-wrap
msgid "User and group identifiers"
msgstr "ユーザ ID とグループ ID"

#. type: Plain text
#: build/C/man7/credentials.7:123
msgid ""
"Each process has various associated user and groups IDs.  These IDs are "
"integers, respectively represented using the types I<uid_t> and I<gid_t> "
"(defined in I<E<lt>sys/types.hE<gt>>)."
msgstr ""
"各プロセスは、数種類のユーザ ID とグループ ID を持つ。 ユーザ ID、グループ "
"ID は整数で、それぞれ I<uid_t>, I<gid_t> 型で表現される (これらは I<E<lt>sys/"
"types.hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man7/credentials.7:125
msgid "On Linux, each process has the following user and group identifiers:"
msgstr ""
"Linux では、各プロセスは以下のような種類のユーザ ID とグループ ID を持つ。"

#. type: Plain text
#: build/C/man7/credentials.7:131
msgid ""
"Real user ID and real group ID.  These IDs determine who owns the process.  "
"A process can obtain its real user (group) ID using B<getuid>(2)  (B<getgid>"
"(2))."
msgstr ""
"実ユーザ ID と実グループ ID。 これらの ID によりプロセスの所有者が決定され"
"る。 プロセスが自分の実ユーザ ID、実グループ ID を取得するには、それぞれ "
"B<getuid>(2), B<getgid>(2)  を使用する。"

#. type: Plain text
#: build/C/man7/credentials.7:143
msgid ""
"Effective user ID and effective group ID.  These IDs are used by the kernel "
"to determine the permissions that the process will have when accessing "
"shared resources such as message queues, shared memory, and semaphores.  On "
"most UNIX systems, these IDs also determine the permissions when accessing "
"files.  However, Linux uses the file system IDs described below for this "
"task.  A process can obtain its effective user (group) ID using B<geteuid>"
"(2)  (B<getegid>(2))."
msgstr ""
"実効ユーザ ID と実効グループ ID。 これらの ID は、メッセージキュー、共有メモ"
"リ、セマフォなどの 共有リソースにアクセスしようとした際にそのプロセスがアクセ"
"ス許可を 持っているかをカーネルが判定するのに使用される。 ほとんどの UNIX シ"
"ステムでは、これらの ID はファイルへのアクセス時の アクセス許可の判定にも使用"
"される。 しかしながら、Linux ではファイルへのアクセス許可の判定には 後述の"
"ファイルシステム ID が使用される。 プロセスが自分の実効ユーザ ID、実効グルー"
"プ ID を取得するには、それぞれ B<geteuid>(2), B<getegid>(2)  を使用する。"

#. type: Plain text
#: build/C/man7/credentials.7:165
msgid ""
"Saved set-user-ID and saved set-group-ID.  These IDs are used in set-user-ID "
"and set-group-ID programs to save a copy of the corresponding effective IDs "
"that were set when the program was executed (see B<execve>(2)).  A set-user-"
"ID program can assume and drop privileges by switching its effective user ID "
"back and forth between the values in its real user ID and saved set-user-"
"ID.  This switching is done via calls to B<seteuid>(2), B<setreuid>(2), or "
"B<setresuid>(2).  A set-group-ID program performs the analogous tasks using "
"B<setegid>(2), B<setregid>(2), or B<setresgid>(2).  A process can obtain its "
"saved set-user-ID (set-group-ID) using B<getresuid>(2)  (B<getresgid>(2))."
msgstr ""
"保存 (saved) set-user-ID と保存 set-group-ID。 これらの ID は、set-user-ID "
"や set-group-ID されたプログラムにおいて、 プログラムの実行時に設定された実"
"効 ID のコピーを保存するために 使用される (B<execve>(2)  参照)。 set-user-ID "
"プログラムは、実効ユーザ ID を実ユーザID と保存 set-user-ID の間で行ったり来"
"たり切り替えることで、特権を得たり落としたりできる。 この切り替えは "
"B<seteuid>(2), B<setreuid>(2), B<setresuid>(2)  を呼び出すことで実行できる。 "
"set-group-ID プログラムは、 B<setegid>(2), B<setregid>(2), B<setresgid>(2)  "
"を使って同様のことができる。 プロセスが自分の保存 set-user-ID、保存 set-"
"group-ID を取得するには、 B<getresuid(2),> B<getresgids>(2)  をそれぞれ使用す"
"る。"

#. type: Plain text
#: build/C/man7/credentials.7:182
msgid ""
"File system user ID and file system group ID (Linux-specific).  These IDs, "
"in conjunction with the supplementary group IDs described below, are used to "
"determine permissions for accessing files; see B<path_resolution>(7)  for "
"details.  Whenever a process's effective user (group) ID is changed, the "
"kernel also automatically changes the file system user (group) ID to the "
"same value.  Consequently, the file system IDs normally have the same values "
"as the corresponding effective ID, and the semantics for file-permission "
"checks are thus the same on Linux as on other UNIX systems.  The file system "
"IDs can be made to differ from the effective IDs by calling B<setfsuid>(2)  "
"and B<setfsgid>(2)."
msgstr ""
"ファイルシステム・ユーザ ID とファイルシステム・グループ ID (Linux 固有)。 こ"
"れらの ID は、後述の補助グループ ID と組み合わせて使用され、 ファイルへのアク"
"セス権の決定に利用される。詳細は B<path_resolution>(7)  を参照。 プロセスの実"
"効 ID (ユーザ ID や グループ ID) が変更されるたびに、 カーネルは自動的に対応"
"するファイルシステム ID を同じ値に変更する。 その結果、ファイルシステム ID は"
"通常は対応する実効 ID と同じ値となり、 ファイルのアクセス権のチェック方法は "
"Linux と他の UNIX システムで同じである。 ファイルシステム ID は実効 ID とは異"
"なる値にすることができ、 変更は B<setfsuid>(2)  と B<setfsgid>(2)  を呼び出し"
"て行う。"

#.  Since kernel 2.6.4, the limit is visible via the read-only file
#.  /proc/sys/kernel/ngroups_max.
#.  As at 2.6.22-rc2, this file is still read-only.
#. type: Plain text
#: build/C/man7/credentials.7:201
msgid ""
"Supplementary group IDs.  This is a set of additional group IDs that are "
"used for permission checks when accessing files and other shared resources.  "
"On Linux kernels before 2.6.4, a process can be a member of up to 32 "
"supplementary groups; since kernel 2.6.4, a process can be a member of up to "
"65536 supplementary groups.  The call I<sysconf(_SC_NGROUPS_MAX)> can be "
"used to determine the number of supplementary groups of which a process may "
"be a member.  A process can obtain its set of supplementary group IDs using "
"B<getgroups>(2), and can modify the set using B<setgroups>(2)."
msgstr ""
"補助グループ ID。 この ID は、ファイルや他の共有リソースへのアクセス時にアク"
"セス許可の チェックに使用される、追加のグループ ID の集合である。 カーネル "
"2.6.4 より前の Linux では、一つのプロセスあたりの 補助グループのメンバー数は"
"最大で 32 である。 カーネル 2.6.4 以降では、一つのプロセスあたりの 補助グルー"
"プのメンバー数は最大で 65536 である。 I<sysconf(_SC_NGROUPS_MAX)> を呼び出す"
"ことで、あるプロセスがメンバーとなることができる可能性のある 補助グループ数を"
"知ることができる。 プロセスは、自分の補助グループ ID の集合を B<getgroups>"
"(2)  で取得でき、 B<setgroups>(2)  で集合を変更できる。"

#. type: Plain text
#: build/C/man7/credentials.7:211
msgid ""
"A child process created by B<fork>(2)  inherits copies of its parent's user "
"and groups IDs.  During an B<execve>(2), a process's real user and group ID "
"and supplementary group IDs are preserved; the effective and saved set IDs "
"may be changed, as described in B<execve>(2)."
msgstr ""
"B<fork>(2)  で生成された子プロセスは親プロセスのユーザ ID とグループ ID を継"
"承する。 B<execve>(2)  の間、プロセスの実ユーザ/グループ ID と補助グループ "
"ID 集合は不変である。 実効 ID と保存セット ID は変更される可能性がある "
"(B<execve>(2)  で説明されている)。"

#. type: Plain text
#: build/C/man7/credentials.7:214
msgid ""
"Aside from the purposes noted above, a process's user IDs are also employed "
"in a number of other contexts:"
msgstr "上記の目的以外にも、プロセスのユーザ ID は他の様々な場面で利用される。"

#. type: Plain text
#: build/C/man7/credentials.7:217
msgid ""
"when determining the permissions for sending signals\\(emsee B<kill>(2);"
msgstr "シグナルを送る許可の判定時\\(em B<kill>(2)  参照。"

#. type: Plain text
#: build/C/man7/credentials.7:227
msgid ""
"when determining the permissions for setting process-scheduling parameters "
"(nice value, real time scheduling policy and priority, CPU affinity, I/O "
"priority) using B<setpriority>(2), B<sched_setaffinity>(2), "
"B<sched_setscheduler>(2), B<sched_setparam>(2), and B<ioprio_set>(2);"
msgstr ""
"プロセスのスケジューリング関連のパラメータ (nice 値、 リアルタイム・スケ"
"ジューリングポリシーや優先度、CPU affinity、 入出力優先度) の設定許可の判定"
"時。 スケジューリング関連のパラメータ設定には B<setpriority>(2), "
"B<sched_setaffinity>(2), B<sched_setscheduler>(2), B<sched_setparam>(2), "
"B<ioprio_set>(2)  が使用される。"

#. type: Plain text
#: build/C/man7/credentials.7:230
msgid "when checking resource limits; see B<getrlimit>(2);"
msgstr "リソース上限のチェック時。 B<getrlimit>(2)  参照。"

#. type: Plain text
#: build/C/man7/credentials.7:234
msgid ""
"when checking the limit on the number of inotify instances that the process "
"may create; see B<inotify>(7)."
msgstr ""
"プロセスが生成できる inotify インスタンス数の上限のチェック時。 B<inotify>"
"(7)  参照。"

#. type: Plain text
#: build/C/man7/credentials.7:240
msgid ""
"Process IDs, parent process IDs, process group IDs, and session IDs are "
"specified in POSIX.1-2001.  The real, effective, and saved set user and "
"groups IDs, and the supplementary group IDs, are specified in POSIX.1-2001.  "
"The file system user and group IDs are a Linux extension."
msgstr ""
"プロセス ID、親プロセス ID、プロセスグループ ID、セッション ID は "
"POSIX.1-2001 で規定されている。 実 ID、実効 ID、保存セット ID のユーザ ID / "
"グループ ID および 補助グループ ID は POSIX.1-2001 で規定されている。 ファイ"
"ルシステム・ユーザ ID / グループ ID は Linux による拡張である。"

#. type: Plain text
#: build/C/man7/credentials.7:251
msgid ""
"The POSIX threads specification requires that credentials are shared by all "
"of the threads in a process.  However, at the kernel level, Linux maintains "
"separate user and group credentials for each thread.  The NPTL threading "
"implementation does some work to ensure that any change to user or group "
"credentials (e.g., calls to B<setuid>(2), B<setresuid>(2))  is carried "
"through to all of the POSIX threads in a process."
msgstr ""
"POSIX のスレッド仕様では、これらの識別子がプロセス内の全スレッドで 共有される"
"ことを求めている。 しかしながら、カーネルのレベルでは、Linux はスレッド毎に"
"別々の ユーザとグループに関する識別子を管理している。 NPTL スレッド実装が、"
"(例えば B<setuid>(2), B<setresuid>(2)  などの呼び出しによる) ユーザやグループ"
"に関する識別子に対する変更が プロセス内の全ての POSIX スレッドに対して反映さ"
"れることを保証する ための処理を行っている。"

#. type: Plain text
#: build/C/man7/credentials.7:282
msgid ""
"B<bash>(1), B<csh>(1), B<ps>(1), B<access>(2), B<execve>(2), B<faccessat>"
"(2), B<fork>(2), B<getpgrp>(2), B<getpid>(2), B<getppid>(2), B<getsid>(2), "
"B<kill>(2), B<killpg>(2), B<setegid>(2), B<seteuid>(2), B<setfsgid>(2), "
"B<setfsuid>(2), B<setgid>(2), B<setgroups>(2), B<setresgid>(2), B<setresuid>"
"(2), B<setuid>(2), B<waitpid>(2), B<euidaccess>(3), B<initgroups>(3), "
"B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<capabilities>(7), B<path_resolution>(7), "
"B<unix>(7)"
msgstr ""
"B<bash>(1), B<csh>(1), B<ps>(1), B<access>(2), B<execve>(2), B<faccessat>"
"(2), B<fork>(2), B<getpgrp>(2), B<getpid>(2), B<getppid>(2), B<getsid>(2), "
"B<kill>(2), B<killpg>(2), B<setegid>(2), B<seteuid>(2), B<setfsgid>(2), "
"B<setfsuid>(2), B<setgid>(2), B<setgroups>(2), B<setresgid>(2), B<setresuid>"
"(2), B<setuid>(2), B<waitpid>(2), B<euidaccess>(3), B<initgroups>(3), "
"B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<capabilities>(7), B<path_resolution>(7), "
"B<unix>(7)"

#. type: TH
#: build/C/man2/getgid.2:25
#, no-wrap
msgid "GETGID"
msgstr "GETGID"

#. type: TH
#: build/C/man2/getgid.2:25 build/C/man2/getgroups.2:31
#: build/C/man2/getresuid.2:28 build/C/man2/getuid.2:26
#: build/C/man2/setfsgid.2:31 build/C/man2/setfsuid.2:31
#: build/C/man2/setgid.2:29 build/C/man2/setresuid.2:26
#: build/C/man2/setreuid.2:45 build/C/man2/setuid.2:30
#, no-wrap
msgid "2010-11-22"
msgstr "2010-11-22"

#. type: Plain text
#: build/C/man2/getgid.2:28
msgid "getgid, getegid - get group identity"
msgstr "getgid, getegid - グループ ID を得る"

#. type: Plain text
#: build/C/man2/getgid.2:30 build/C/man2/getgroups.2:38
#: build/C/man2/getpid.2:32 build/C/man2/getresuid.2:35
#: build/C/man2/getsid.2:31 build/C/man2/getuid.2:31 build/C/man2/seteuid.2:36
#: build/C/man2/setgid.2:36 build/C/man2/setpgid.2:53
#: build/C/man2/setresuid.2:33 build/C/man2/setreuid.2:52
#: build/C/man2/setsid.2:36 build/C/man2/setuid.2:37
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/getgid.2:32 build/C/man2/getgroups.2:36
#: build/C/man2/getpid.2:30 build/C/man2/getuid.2:33 build/C/man2/seteuid.2:34
#: build/C/man2/setgid.2:34 build/C/man2/setreuid.2:50
#: build/C/man2/setuid.2:35
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/getgid.2:34
msgid "B<gid_t getgid(void);>"
msgstr "B<gid_t getgid(void);>"

#. type: Plain text
#: build/C/man2/getgid.2:36
msgid "B<gid_t getegid(void);>"
msgstr "B<gid_t getegid(void);>"

#. type: Plain text
#: build/C/man2/getgid.2:39
msgid "B<getgid>()  returns the real group ID of the calling process."
msgstr "B<getgid>()  は呼び出し元のプロセスの実グループ ID を返す。"

#. type: Plain text
#: build/C/man2/getgid.2:42
msgid "B<getegid>()  returns the effective group ID of the calling process."
msgstr "B<getegid>()  は呼び出し元のプロセスの実効グループ ID を返す。"

#. type: Plain text
#: build/C/man2/getgid.2:44 build/C/man2/getpid.2:46 build/C/man2/getuid.2:45
msgid "These functions are always successful."
msgstr "これらの関数は常に成功する。"

#. type: Plain text
#: build/C/man2/getgid.2:46 build/C/man2/getuid.2:47
msgid "POSIX.1-2001, 4.3BSD."
msgstr "POSIX.1-2001, 4.3BSD."

#. type: Plain text
#: build/C/man2/getgid.2:62
msgid ""
"The original Linux B<getgid>()  and B<getegid>()  system calls supported "
"only 16-bit group IDs.  Subsequently, Linux 2.4 added B<getgid32>()  and "
"B<getegid32>(), supporting 32-bit IDs.  The glibc B<getgid>()  and B<getegid>"
"()  wrapper functions transparently deal with the variations across kernel "
"versions."
msgstr ""
"元々の Linux の B<getgid>() と B<getegid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getgid32>() と B<getegid32>() が追加された。\n"
"glibc の B<getgid>() と B<getegid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getgid.2:67
msgid "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"
msgstr "B<getresgid>(2), B<setgid>(2), B<setregid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/getgroups.2:31
#, no-wrap
msgid "GETGROUPS"
msgstr "GETGROUPS"

#. type: Plain text
#: build/C/man2/getgroups.2:34
msgid "getgroups, setgroups - get/set list of supplementary group IDs"
msgstr "getgroups, setgroups - 補助グループ ID のリストを取得/設定する"

#. type: Plain text
#: build/C/man2/getgroups.2:40
msgid "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"
msgstr "B<int getgroups(int >I<size>B<, gid_t >I<list>B<[]);>"

#. type: Plain text
#: build/C/man2/getgroups.2:42
msgid "B<#include E<lt>grp.hE<gt>>"
msgstr "B<#include E<lt>grp.hE<gt>>"

#. type: Plain text
#: build/C/man2/getgroups.2:44
msgid "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"
msgstr "B<int setgroups(size_t >I<size>B<, const gid_t *>I<list>B<);>"

#. type: Plain text
#: build/C/man2/getgroups.2:52
msgid "B<setgroups>(): _BSD_SOURCE"
msgstr "B<setgroups>(): _BSD_SOURCE"

#. type: Plain text
#: build/C/man2/getgroups.2:70
msgid ""
"B<getgroups>()  returns the supplementary group IDs of the calling process "
"in I<list>.  The argument I<size> should be set to the maximum number of "
"items that can be stored in the buffer pointed to by I<list>.  If the "
"calling process is a member of more than I<size> supplementary groups, then "
"an error results.  It is unspecified whether the effective group ID of the "
"calling process is included in the returned list.  (Thus, an application "
"should also call B<getegid>(2)  and add or remove the resulting value.)"
msgstr ""
"B<getgroups>()  は呼び出し元プロセスの補助グループ (supplementary group) ID "
"を I<list> に返す。 I<size> 引き数には、 I<list> により参照されるバッファに格"
"納できる要素の最大数を設定すべきである。 呼び出し元プロセスが I<size> 個より"
"多くの補助グループのメンバの場合には、エラーとなる。 この関数を呼び出したプロ"
"セスの実効グループ ID が、 返されるリストに含まれるかどうかは規定されていな"
"い (したがって、アプリケーションは B<getegid>(2)  を呼び出し、その結果の値を"
"追加・削除すべきである)。"

#. type: Plain text
#: build/C/man2/getgroups.2:81
msgid ""
"If I<size> is zero, I<list> is not modified, but the total number of "
"supplementary group IDs for the process is returned.  This allows the caller "
"to determine the size of a dynamically allocated I<list> to be used in a "
"further call to B<getgroups>()."
msgstr ""
"I<size> が 0 ならば、 I<list> は修正されないが、そのプロセスの補助グループ "
"ID の合計数が返される。 これを使うことで、それ以降の B<getgroups>()  の呼び出"
"しで必要となる動的割り当てバッファ I<list> のサイズを、呼び出し元が決定するこ"
"とができる。"

#. type: Plain text
#: build/C/man2/getgroups.2:92
msgid ""
"B<setgroups>()  sets the supplementary group IDs for the calling process.  "
"Appropriate privileges (Linux: the B<CAP_SETGID> capability) are required.  "
"The I<size> argument specifies the number of supplementary group IDs in the "
"buffer pointed to by I<list>."
msgstr ""
"B<setgroups>()  は、呼び出し元プロセスの補助グループ ID を設定する。 適切な特"
"権 (Linux では B<CAP_SETGID> ケーパビリティ (capability)) が必要である。 "
"I<size> 引き数には、 I<list> により参照されるバッファに格納された補助グルー"
"プ ID の数を指定する。"

#. type: Plain text
#: build/C/man2/getgroups.2:99
msgid ""
"On success, B<getgroups>()  returns the number of supplementary group IDs.  "
"On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"B<getgroups>()  は、成功すると補助グループ ID の数を返す。 エラーの場合 -1 を"
"返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/getgroups.2:106
msgid ""
"On success, B<setgroups>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"B<setgroups>()  は、成功すると 0 を返す。 エラーの場合 -1 を返し、 I<errno> "
"を適切に設定する。"

#. type: Plain text
#: build/C/man2/getgroups.2:111
msgid "I<list> has an invalid address."
msgstr "I<list> が不正なアドレスである。"

#. type: Plain text
#: build/C/man2/getgroups.2:114
msgid "B<getgroups>()  can additionally fail with the following error:"
msgstr "B<getgroups>()  は、上記に加えて以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getgroups.2:118
msgid ""
"I<size> is less than the number of supplementary group IDs, but is not zero."
msgstr "I<size> が補助グループ ID の数より小さいが 0 でない。"

#. type: Plain text
#: build/C/man2/getgroups.2:121
msgid "B<setgroups>()  can additionally fail with the following errors:"
msgstr "B<setgroups>()  は、上記に加えて以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/getgroups.2:127
msgid ""
"I<size> is greater than B<NGROUPS_MAX> (32 before Linux 2.6.4; 65536 since "
"Linux 2.6.4)."
msgstr ""
"I<size> が B<NGROUPS_MAX> より大きい (B<NGROUPS_MAX> は Linux 2.6.4 より前で"
"は 32、Linux 2.6.4 以降では 65536)。"

#. type: Plain text
#: build/C/man2/getgroups.2:133
msgid "The calling process has insufficient privilege."
msgstr "呼び出し元プロセスが十分な特権を持っていない。"

#. type: Plain text
#: build/C/man2/getgroups.2:141
msgid ""
"SVr4, 4.3BSD.  The B<getgroups>()  function is in POSIX.1-2001.  Since "
"B<setgroups>()  requires privilege, it is not covered by POSIX.1-2001."
msgstr ""
"SVr4, 4.3BSD.  B<getgroups>()  関数は POSIX.1-2001 に準拠している。 "
"B<setgroups>()  は特権を必要とするため、POSIX.1-2001 に従っていない。"

#. type: Plain text
#: build/C/man2/getgroups.2:149
msgid ""
"A process can have up to B<NGROUPS_MAX> supplementary group IDs in addition "
"to the effective group ID.  The set of supplementary group IDs is inherited "
"from the parent process, and preserved across an B<execve>(2)."
msgstr ""
"プロセスは、実効グループ ID に加え、最大 B<NGROUPS_MAX> までの補助グループ "
"ID を持つことができる。 補助グループ ID の集合は親プロセスから継承され、 "
"B<execve>(2)  の前後で保持される。"

#. type: Plain text
#: build/C/man2/getgroups.2:152
msgid ""
"The maximum number of supplementary group IDs can be found using B<sysconf>"
"(3):"
msgstr ""
"補助グループ ID の最大数は B<sysconf>(3)  を使って以下のようにして調べること"
"ができる:"

#. type: Plain text
#: build/C/man2/getgroups.2:156
#, no-wrap
msgid ""
"    long ngroups_max;\n"
"    ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"
msgstr ""
"    long ngroups_max;\n"
"    ngroups_max = sysconf(_SC_NGROUPS_MAX);\n"

#. type: Plain text
#: build/C/man2/getgroups.2:161
msgid ""
"The maximum return value of B<getgroups>()  cannot be larger than one more "
"than this value."
msgstr ""
"B<getgroups>()  の返り値の最大値は、この値より 1 大きい値より大きくなることは"
"ない。"

#. type: Plain text
#: build/C/man2/getgroups.2:171
msgid ""
"The original Linux B<getgroups>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<getgroups32>(), supporting 32-bit "
"IDs.  The glibc B<getgroups>()  wrapper function transparently deals with "
"the variation across kernel versions."
msgstr ""
"元々の Linux の B<getgroups>() システムコールは 16 ビットのグループ ID だけ\n"
"に対応していた。その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getgroups>() が追加された。glibc の B<getgroups> のラッパー関数はカーネル\n"
"バージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getgroups.2:178
msgid ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<initgroups>(3), "
"B<capabilities>(7), B<credentials>(7)"
msgstr ""
"B<getgid>(2), B<setgid>(2), B<getgrouplist>(3), B<initgroups>(3), "
"B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/getpid.2:25
#, no-wrap
msgid "GETPID"
msgstr "GETPID"

#. type: TH
#: build/C/man2/getpid.2:25
#, no-wrap
msgid "2008-09-23"
msgstr "2008-09-23"

#. type: Plain text
#: build/C/man2/getpid.2:28
msgid "getpid, getppid - get process identification"
msgstr "getpid, getppid - プロセス ID を得る"

#. type: Plain text
#: build/C/man2/getpid.2:34
msgid "B<pid_t getpid(void);>"
msgstr "B<pid_t getpid(void);>"

#. type: Plain text
#: build/C/man2/getpid.2:36
msgid "B<pid_t getppid(void);>"
msgstr "B<pid_t getppid(void);>"

#. type: Plain text
#: build/C/man2/getpid.2:41
msgid ""
"B<getpid>()  returns the process ID of the calling process.  (This is often "
"used by routines that generate unique temporary filenames.)"
msgstr ""
"B<getpid>()  は呼び出し元のプロセスのプロセス ID を返す。(テンポラリ用のファ"
"イル名として 他と重ならない名前を生成するルーチンでしばしば使用される。)"

#. type: Plain text
#: build/C/man2/getpid.2:44
msgid ""
"B<getppid>()  returns the process ID of the parent of the calling process."
msgstr "B<getppid>()  は呼び出し元のプロセスの親プロセスのプロセス ID を返す。"

#. type: Plain text
#: build/C/man2/getpid.2:48
msgid "POSIX.1-2001, 4.3BSD, SVr4."
msgstr "POSIX.1-2001, 4.3BSD, SVr4."

#.  The following program demonstrates this "feature":
#.  #define _GNU_SOURCE
#.  #include <sys/syscall.h>
#.  #include <sys/wait.h>
#.  #include <stdio.h>
#.  #include <stdlib.h>
#.  #include <unistd.h>
#.  int
#.  main(int argc, char *argv[])
#.  {
#.     /* The following statement fills the getpid() cache */
#.     printf("parent PID = %ld
#. ", (long) getpid());
#.     if (syscall(SYS_fork) == 0) {
#.         if (getpid() != syscall(SYS_getpid))
#.             printf("child getpid() mismatch: getpid()=%ld; "
#.                     "syscall(SYS_getpid)=%ld
#. ",
#.                     (long) getpid(), (long) syscall(SYS_getpid));
#.         exit(EXIT_SUCCESS);
#.     }
#.     wait(NULL);
#. }
#. type: Plain text
#: build/C/man2/getpid.2:100
msgid ""
"Since glibc version 2.3.4, the glibc wrapper function for B<getpid>()  "
"caches PIDs, so as to avoid additional system calls when a process calls "
"B<getpid>()  repeatedly.  Normally this caching is invisible, but its "
"correct operation relies on support in the wrapper functions for B<fork>(2), "
"B<vfork>(2), and B<clone>(2): if an application bypasses the glibc wrappers "
"for these system calls by using B<syscall>(2), then a call to B<getpid>()  "
"in the child will return the wrong value (to be precise: it will return the "
"PID of the parent process).  See also B<clone>(2)  for discussion of a case "
"where B<getpid>()  may return the wrong value even when invoking B<clone>"
"(2)  via the glibc wrapper function."
msgstr ""
"glibc バージョン 2.3.4 以降では、 glibc の B<getpid>()  のラッパー関数は PID "
"をキャッシュする。 これは、プロセスが繰り返し B<getpid>()  を呼び出した場合に"
"その都度システムコールを呼ぶのを避けるためである。 通常は、このキャッシュ処理"
"が見えることはないが、 キャッシュ処理が正しく働くためには B<fork>(2), "
"B<vfork>(2), B<clone>(2)  のラッパー関数でのサポートが必要である。 アプリケー"
"ションがこれらのシステムコールを呼び出す際に、 glibc のラッパー関数を経由せず"
"に B<syscall>(2)  を使った場合には、子プロセスで B<getpid>()  を呼び出すと間"
"違った値が返ることだろう (正確にいうと、親プロセスの PID が返される)。 "
"B<clone>(2)  を glibc のラッパー関数経由で起動した際にも B<getpid>()  が間"
"違った値を返す場合があり、これに関する議論は B<clone>(2)  も参照してほしい。"

#. type: Plain text
#: build/C/man2/getpid.2:110
msgid ""
"B<clone>(2), B<fork>(2), B<kill>(2), B<exec>(3), B<mkstemp>(3), B<tempnam>"
"(3), B<tmpfile>(3), B<tmpnam>(3), B<credentials>(7)"
msgstr ""
"B<clone>(2), B<fork>(2), B<kill>(2), B<exec>(3), B<mkstemp>(3), B<tempnam>"
"(3), B<tmpfile>(3), B<tmpnam>(3), B<credentials>(7)"

#. type: TH
#: build/C/man2/getpriority.2:48
#, no-wrap
msgid "GETPRIORITY"
msgstr "GETPRIORITY"

#. type: Plain text
#: build/C/man2/getpriority.2:51
msgid "getpriority, setpriority - get/set program scheduling priority"
msgstr ""
"getpriority, setpriority - プログラムのスケジューリングの優先度を取得/設定す"
"る"

#. type: Plain text
#: build/C/man2/getpriority.2:53 build/C/man2/getrlimit.2:69
#: build/C/man2/getrusage.2:44
msgid "B<#include E<lt>sys/time.hE<gt>>"
msgstr "B<#include E<lt>sys/time.hE<gt>>"

#. type: Plain text
#: build/C/man2/getpriority.2:55 build/C/man2/getrlimit.2:71
#: build/C/man2/getrusage.2:46
msgid "B<#include E<lt>sys/resource.hE<gt>>"
msgstr "B<#include E<lt>sys/resource.hE<gt>>"

#. type: Plain text
#: build/C/man2/getpriority.2:57
msgid "B<int getpriority(int >I<which>B<, int >I<who>B<);>"
msgstr "B<int getpriority(int >I<which>B<, int >I<who>B<);>"

#. type: Plain text
#: build/C/man2/getpriority.2:59
msgid "B<int setpriority(int >I<which>B<, int >I<who>B<, int >I<prio>B<);>"
msgstr "B<int setpriority(int >I<which>B<, int >I<who>B<, int >I<prio>B<);>"

#. type: Plain text
#: build/C/man2/getpriority.2:70
msgid ""
"The scheduling priority of the process, process group, or user, as indicated "
"by I<which> and I<who> is obtained with the B<getpriority>()  call and set "
"with the B<setpriority>()  call."
msgstr ""
"システムコール B<getpriority>()  や B<setpriority>()  は、 I<which> と "
"I<who> で指定されたプロセス、プロセスグループ、ユーザーの スケジューリング優"
"先度 (scheduling priority) の 取得や設定をそれぞれ行う。"

#. type: Plain text
#: build/C/man2/getpriority.2:97
msgid ""
"The value I<which> is one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>, "
"and I<who> is interpreted relative to I<which> (a process identifier for "
"B<PRIO_PROCESS>, process group identifier for B<PRIO_PGRP>, and a user ID "
"for B<PRIO_USER>).  A zero value for I<who> denotes (respectively) the "
"calling process, the process group of the calling process, or the real user "
"ID of the calling process.  I<Prio> is a value in the range -20 to 19 (but "
"see the Notes below).  The default priority is 0; lower priorities cause "
"more favorable scheduling."
msgstr ""
"I<which> の値は B<PRIO_PROCESS>, B<PRIO_PGRP>, B<PRIO_USER>, のどれか一つ"
"で、 I<who> は I<which> に応じて解釈される (B<PRIO_PROCESS> だとプロセス識別"
"子、 B<PRIO_PGRP> だとプロセスグループ識別子、 B<PRIO_USER> だと UID (ユーザ"
"ID) と解釈される)。 I<who> がゼロならば、(それぞれ)呼び出したプロセス、 呼び"
"出したプロセスのプロセスグループ、 呼び出したプロセスの実UID を意味する。 "
"I<prio> は -20 から 19 の範囲の値で (但し以下の注意の項を参照のこと)、 デフォ"
"ルトの優先度は 0 である; 小さな数字ほど、有利なスケジューリングとなる。"

#. type: Plain text
#: build/C/man2/getpriority.2:107
msgid ""
"The B<getpriority>()  call returns the highest priority (lowest numerical "
"value)  enjoyed by any of the specified processes.  The B<setpriority>()  "
"call sets the priorities of all of the specified processes to the specified "
"value.  Only the superuser may lower priorities."
msgstr ""
"B<getpriority>()  コールは指定したプロセスの中の最も高い優先度 (数値的には最"
"小の値) を返す。 B<setpriority>()  コールは指定したプロセス全ての優先度を指定"
"した値に設定する。 優先度を今より小さい値に設定できるのはスーパーユーザーだけ"
"である。"

#. type: Plain text
#: build/C/man2/getpriority.2:120
msgid ""
"Since B<getpriority>()  can legitimately return the value -1, it is "
"necessary to clear the external variable I<errno> prior to the call, then "
"check it afterward to determine if -1 is an error or a legitimate value.  "
"The B<setpriority>()  call returns 0 if there is no error, or -1 if there is."
msgstr ""
"B<getpriority>()  は成功した場合にも -1 の値を返す可能性があるので、 呼び出し"
"の前に外部変数の I<errno> をクリアし、呼び出しの後に返り値の -1 が正当な値か "
"エラーかを判別する必要がある。 B<setpriority>()  コールはエラーがなければ 0 "
"を返し、エラーがあれば -1 を返す。"

#. type: Plain text
#: build/C/man2/getpriority.2:129
msgid "I<which> was not one of B<PRIO_PROCESS>, B<PRIO_PGRP>, or B<PRIO_USER>."
msgstr ""
"I<which> が B<PRIO_PROCESS>, B<PRIO_PGRP>, B<PRIO_USER> のいずれでもない。"

#. type: Plain text
#: build/C/man2/getpriority.2:136
msgid "No process was located using the I<which> and I<who> values specified."
msgstr "I<which> と I<who> で指定されたプロセスが存在しない。"

#. type: Plain text
#: build/C/man2/getpriority.2:140
msgid ""
"In addition to the errors indicated above, B<setpriority>()  may fail if:"
msgstr "上記のものに加えて B<setpriority>()  では以下のエラーがある:"

#. type: Plain text
#: build/C/man2/getpriority.2:152
msgid ""
"The caller attempted to lower a process priority, but did not have the "
"required privilege (on Linux: did not have the B<CAP_SYS_NICE> capability).  "
"Since Linux 2.6.12, this error occurs only if the caller attempts to set a "
"process priority outside the range of the B<RLIMIT_NICE> soft resource limit "
"of the target process; see B<getrlimit>(2)  for details."
msgstr ""
"呼び出し元がプロセスの優先度を下げようとしたが、必要な特権を 持っていなかっ"
"た (Linux の場合、 B<CAP_SYS_NICE> ケーパビリティがなかった)。 Linux 2.6.12 "
"以降では、呼び出し元が、あるプロセスの優先度を、 変更対象のプロセスのリソー"
"ス B<RLIMIT_NICE> のソフトリミットの範囲外に設定しようとした場合にのみ、 この"
"エラーが発生する。詳細は B<getrlimit>(2)  を参照。"

#. type: Plain text
#: build/C/man2/getpriority.2:160
msgid ""
"A process was located, but its effective user ID did not match either the "
"effective or the real user ID of the caller, and was not privileged (on "
"Linux: did not have the B<CAP_SYS_NICE> capability).  But see NOTES below."
msgstr ""
"プロセスは見つかったが、そのプロセスの実効 (effective) UID が 呼び出し元の実"
"効UID にも実 (real) UID にも一致せず、 呼び出し元が特権も持っていなかった "
"(Linux の場合、 B<CAP_SYS_NICE> ケーパビリティがなかった)。 以下の「注意」も"
"参照のこと。"

#. type: Plain text
#: build/C/man2/getpriority.2:163
msgid ""
"SVr4, 4.4BSD (these function calls first appeared in 4.2BSD), POSIX.1-2001."
msgstr "SVr4, 4.4BSD (これらの関数は 4.2BSD で最初に登場した), POSIX.1-2001."

#. type: Plain text
#: build/C/man2/getpriority.2:169
msgid ""
"A child created by B<fork>(2)  inherits its parent's nice value.  The nice "
"value is preserved across B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、 親プロセスの nice 値を継承する。 "
"B<execve>(2)  の前後で nice 値は保存される。"

#. type: Plain text
#: build/C/man2/getpriority.2:180
msgid ""
"The degree to which their relative nice value affects the scheduling of "
"processes varies across UNIX systems, and, on Linux, across kernel "
"versions.  Starting with kernel 2.6.23, Linux adopted an algorithm that "
"causes relative differences in nice values to have a much stronger effect.  "
"This causes very low nice values (+19) to truly provide little CPU to a "
"process whenever there is any other higher priority load on the system, and "
"makes high nice values (-20) deliver most of the CPU to applications that "
"require it (e.g., some audio applications)."
msgstr ""
"相対的な nice 値の違いがプロセス間のスケジューリングにどの程度影響を与えるか "
"は、UNIX システム間で異なり、Linux ではカーネルバージョンにより異なる。 "
"Linux は、カーネル 2.6.23 以降で、nice 値の相対的な違いが、非常に強い影響を "
"与えるアルゴリズムを採用した。このアルゴリズムでは、 他に優先度の高いものがシ"
"ステムに存在する時には、 非常に低い nice 値 (+19) ではプロセスに本当にほとん"
"ど CPU が割り当てられない。 また、高い nice 値 (-20) では CPU を必要とするア"
"プリケーション (例えば オーディオアプリケーション) に CPU のほとんどが割り当"
"てられる。"

#. type: Plain text
#: build/C/man2/getpriority.2:195
msgid ""
"The details on the condition for B<EPERM> depend on the system.  The above "
"description is what POSIX.1-2001 says, and seems to be followed on all "
"System V-like systems.  Linux kernels before 2.6.12 required the real or "
"effective user ID of the caller to match the real user of the process I<who> "
"(instead of its effective user ID).  Linux 2.6.12 and later require the "
"effective user ID of the caller to match the real or effective user ID of "
"the process I<who>.  All BSD-like systems (SunOS 4.1.3, Ultrix 4.2, 4.3BSD, "
"FreeBSD 4.3, OpenBSD-2.5, ...) behave in the same manner as Linux 2.6.12 and "
"later."
msgstr ""
"B<EPERM> が発生する条件の詳細はシステムに依存する。 上記の説明は "
"POSIX.1-2001 のものであり、全ての System V 風システムは これに従っているよう"
"である。 2.6.12 より前の Linux カーネルでは、呼び出し元の実 UID または 実効 "
"UID がプロセス I<who> の (実効 UID でなく)  実 UID に一致する必要がある。 "
"Linux 2.6.12 以降では、呼び出し元の実行 UID がプロセス I<who> の実 UID か実"
"効 UID のいずれかと一致する必要がある。 全ての BSD 風システム (SunOS 4.1.3, "
"Ultrix 4.2, 4.3BSD, FreeBSD 4.3, OpenBSD-2.5等) は、 Linux 2.6.12 以降と同じ"
"動作をする。"

#. type: Plain text
#: build/C/man2/getpriority.2:211
msgid ""
"The actual priority range varies between kernel versions.  Linux before "
"1.3.36 had -infinity..15.  Since kernel 1.3.43, Linux has the range "
"-20..19.  Within the kernel, nice values are actually represented using the "
"corresponding range 40..1 (since negative numbers are error codes) and these "
"are the values employed by the B<setpriority>()  and B<getpriority>()  "
"system calls.  The glibc wrapper functions for these system calls handle the "
"translations between the user-land and kernel representations of the nice "
"value according to the formula I<unice\\ =\\ 20\\ -\\ knice>."
msgstr ""
"実際の優先度の値の範囲はカーネルのバージョンによって異なる。 1.3.36 より前の "
"Linux では、優先度の範囲は負の無限大 〜 15 である。 1.3.43 以降の Linux で"
"は、優先度の範囲は -20 〜 19 である。 カーネル内部では、nice 値は実際には 40 "
"〜 1 の範囲を使って 表現されており (負の値はエラーコードとなるため)、こちらの"
"値が システムコール B<setpriority>()  と B<getpriority>()  で使用されてい"
"る。 glibc のこれらのシステムコールのラッパー関数において、nice 値の ユーザ領"
"域 (user-land) とカーネル表現の間の変換が行われる。 変換式は以下の通り: "
"I<unice\\ =\\ 20\\ -\\ knice>"

#. type: Plain text
#: build/C/man2/getpriority.2:213
msgid "On some systems, the range of nice values is -20..20."
msgstr "いくつかのシステムでは、nice 値の範囲は \\20 〜 20 である。"

#. type: Plain text
#: build/C/man2/getpriority.2:225
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in I<E<lt>sys/time."
"hE<gt>>.)"
msgstr ""
"現在では I<E<lt>sys/time.hE<gt>> をインクルードする必要はないが、インクルード"
"すれば移植性を高めることができる (実際には I<E<lt>sys/resource.hE<gt>> で "
"I<rusage> 構造体が定義されているが、そのフィールドで使用されている I<struct "
"timeval> 型は I<E<lt>sys/time.hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man2/getpriority.2:232
msgid ""
"According to POSIX, the nice value is a per-process setting.  However, under "
"the current Linux/NPTL implementation of POSIX threads, the nice value is a "
"per-thread attribute: different threads in the same process can have "
"different nice values.  Portable applications should avoid relying on the "
"Linux behavior, which may be made standards conformant in the future."
msgstr ""
"POSIX では nice 値はプロセス単位の設定となっている。 一方、 現在の POSIX ス"
"レッドの Linux/NPTL 実装では、 nice 値はスレッド単位の属性である。 同じプロセ"
"スの別々のスレッドが異なる nice 値を持つ場合がある。 移植性が必要なアプリケー"
"ションではこの Linux の動作を前提するのは避けるべきである。 Linux の動作は将"
"来標準に準拠した動作になるかもしれない。"

#. type: Plain text
#: build/C/man2/getpriority.2:237
msgid "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7)"
msgstr "B<nice>(1), B<renice>(1), B<fork>(2), B<capabilities>(7)"

#. type: Plain text
#: build/C/man2/getpriority.2:240
msgid ""
"I<Documentation/scheduler/sched-nice-design.txt> in the Linux kernel source "
"tree (since Linux 2.6.23)"
msgstr ""
"Linux カーネルのソースツリー内の I<Documentation/scheduler/sched-nice-design."
"txt> (Linux 2.6.23 以降)"

#. type: TH
#: build/C/man2/getresuid.2:28
#, no-wrap
msgid "GETRESUID"
msgstr "GETRESUID"

#. type: Plain text
#: build/C/man2/getresuid.2:31
msgid "getresuid, getresgid - get real, effective and saved user/group IDs"
msgstr ""
"getresuid, getresgid - 実、実効、保存、ユーザー ID / グループ ID を取得する"

#. type: Plain text
#: build/C/man2/getresuid.2:33 build/C/man2/setresuid.2:31
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man2/getresuid.2:37
msgid ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"
msgstr ""
"B<int getresuid(uid_t *>I<ruid>B<, uid_t *>I<euid>B<, uid_t *>I<suid>B<);>"

#. type: Plain text
#: build/C/man2/getresuid.2:39
msgid ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"
msgstr ""
"B<int getresgid(gid_t *>I<rgid>B<, gid_t *>I<egid>B<, gid_t *>I<sgid>B<);>"

#. type: Plain text
#: build/C/man2/getresuid.2:50
msgid ""
"B<getresuid>()  returns the real UID, the effective UID, and the saved set-"
"user-ID of the calling process, in the arguments I<ruid>, I<euid>, and "
"I<suid>, respectively.  B<getresgid>()  performs the analogous task for the "
"process's group IDs."
msgstr ""
"B<getresuid>()  は、呼び出したプロセスの実 (real) UID、実効 (effective) "
"UID、 保存 (saved) set-user-ID (B<getresgid> の場合はグループ ID) を、 それぞ"
"れ引き数 I<ruid>, I<euid>, I<suid> に格納して返す。 B<getresgid>()  は、呼び"
"出したプロセスのグループ ID について同様の処理を行う。"

#. type: Plain text
#: build/C/man2/getresuid.2:60
msgid ""
"One of the arguments specified an address outside the calling program's "
"address space."
msgstr ""
"指定した引き数のどれかが、呼び出したプログラムのアドレス空間の外の アドレスで"
"ある。"

#. type: Plain text
#: build/C/man2/getresuid.2:62
msgid "These system calls appeared on Linux starting with kernel 2.1.44."
msgstr "これらのシステムコールはカーネル 2.1.44 から Linux に登場した。"

#. type: Plain text
#: build/C/man2/getresuid.2:67
msgid ""
"The prototypes are given by glibc since version 2.3.2, provided "
"B<_GNU_SOURCE> is defined."
msgstr ""
"プロトタイプ宣言は 2.3.2 以降の glibc では B<_GNU_SOURCE> を定義していると得"
"られる。"

#. type: Plain text
#: build/C/man2/getresuid.2:70 build/C/man2/setresuid.2:86
msgid ""
"These calls are nonstandard; they also appear on HP-UX and some of the BSDs."
msgstr "これらのコールは非標準である。 HP-UX や BSD 系のいくつかにも存在する。"

#. type: Plain text
#: build/C/man2/getresuid.2:86
msgid ""
"The original Linux B<getresuid>()  and B<getresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<getresuid32>()  and B<getresgid32>(), supporting 32-bit IDs.  The glibc "
"B<getresuid>()  and B<getresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""
"元々の Linux の B<getresuid>() と B<getresgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getresuid32>() と B<getresgid32>() が追加された。\n"
"glibc の B<getresuid>() と B<getresgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getresuid.2:92
msgid ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>"
"(7)"
msgstr ""
"B<getuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>"
"(7)"

#. type: TH
#: build/C/man2/getrlimit.2:64
#, no-wrap
msgid "GETRLIMIT"
msgstr "GETRLIMIT"

#. type: TH
#: build/C/man2/getrlimit.2:64 build/C/man2/setsid.2:30
#, no-wrap
msgid "2013-02-11"
msgstr "2013-02-11"

#. type: Plain text
#: build/C/man2/getrlimit.2:67
msgid "getrlimit, setrlimit, prlimit - get/set resource limits"
msgstr "getrlimit, setrlimit, prlimit - 資源の制限を取得/設定する"

#. type: Plain text
#: build/C/man2/getrlimit.2:73
msgid "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"
msgstr "B<int getrlimit(int >I<resource>B<, struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: build/C/man2/getrlimit.2:75
msgid "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"
msgstr "B<int setrlimit(int >I<resource>B<, const struct rlimit *>I<rlim>B<);>"

#. type: Plain text
#: build/C/man2/getrlimit.2:78
msgid ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"
msgstr ""
"B<int prlimit(pid_t >I<pid>B<, int >I<resource>B<, const struct rlimit "
"*>I<new_limit>B<,>"

#. type: Plain text
#: build/C/man2/getrlimit.2:80
msgid "B< struct rlimit *>I<old_limit>B<);>"
msgstr "B< struct rlimit *>I<old_limit>B<);>"

#. type: Plain text
#: build/C/man2/getrlimit.2:88
msgid "B<prlimit>(): _GNU_SOURCE && _FILE_OFFSET_BITS == 64"
msgstr "B<prlimit>(): _GNU_SOURCE && _FILE_OFFSET_BITS == 64"

#. type: Plain text
#: build/C/man2/getrlimit.2:97
msgid ""
"The B<getrlimit>()  and B<setrlimit>()  system calls get and set resource "
"limits respectively.  Each resource has an associated soft and hard limit, "
"as defined by the I<rlimit> structure:"
msgstr ""
"B<getrlimit>() と B<setrlimit>() はそれぞれ資源 (resource) の制限\n"
"(limit) の設定と取得を行う。 各リソースには、それに対応するソフトリミッ\n"
"トとハードリミットがあり、 I<rlimit> 構造体で定義される:"

#. type: Plain text
#: build/C/man2/getrlimit.2:104
#, no-wrap
msgid ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* Soft limit */\n"
"    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */\n"
"};\n"
msgstr ""
"struct rlimit {\n"
"    rlim_t rlim_cur;  /* ソフトリミット */\n"
"    rlim_t rlim_max;  /* ハードリミット\n"
"                         (rlim_cur より小さくない) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:115
msgid ""
"The soft limit is the value that the kernel enforces for the corresponding "
"resource.  The hard limit acts as a ceiling for the soft limit: an "
"unprivileged process may set only its soft limit to a value in the range "
"from 0 up to the hard limit, and (irreversibly) lower its hard limit.  A "
"privileged process (under Linux: one with the B<CAP_SYS_RESOURCE> "
"capability) may make arbitrary changes to either limit value."
msgstr ""
"ソフトリミットは、カーネルが対応するリソースに対して課す制限値である。 ハード"
"リミットはソフトリミットの上限として働く。 特権を持たないプロセスは、ソフトリ"
"ミットの値を 0 からハードリミットの範囲に設定することと、 ハードリミットを下"
"げることのみができる (一度下げたハードリミットは上げられない)。 特権プロセス "
"(Linux では B<CAP_SYS_RESOURCE> ケーパビリティ (capability) を持つプロセス) "
"は ソフトリミットとハードリミットを自由に変更できる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:122
msgid ""
"The value B<RLIM_INFINITY> denotes no limit on a resource (both in the "
"structure returned by B<getrlimit>()  and in the structure passed to "
"B<setrlimit>())."
msgstr ""
"値 B<RLIM_INFINITY> はリソースに制限がないことを表す (この値は B<getrlimit>"
"()  が返す構造体と B<setrlimit>()  に渡す構造体の両方で使用される)。"

#. type: Plain text
#: build/C/man2/getrlimit.2:126
msgid "The I<resource> argument must be one of:"
msgstr "I<resource> 引き数は次のいずれか 1 つである。"

#. type: TP
#: build/C/man2/getrlimit.2:126
#, no-wrap
msgid "B<RLIMIT_AS>"
msgstr "B<RLIMIT_AS>"

#.  since 2.0.27 / 2.1.12
#. type: Plain text
#: build/C/man2/getrlimit.2:146
msgid ""
"The maximum size of the process's virtual memory (address space) in bytes.  "
"This limit affects calls to B<brk>(2), B<mmap>(2)  and B<mremap>(2), which "
"fail with the error B<ENOMEM> upon exceeding this limit.  Also automatic "
"stack expansion will fail (and generate a B<SIGSEGV> that kills the process "
"if no alternate stack has been made available via B<sigaltstack>(2)).  Since "
"the value is a I<long>, on machines with a 32-bit I<long> either this limit "
"is at most 2 GiB, or this resource is unlimited."
msgstr ""
"プロセスの仮想メモリ (アドレス空間) の最大サイズ (バイト単位)。 この制限は "
"B<brk>(2), B<mmap>(2), B<mremap>(2)  の呼び出しに影響し、この制限を超えた場合"
"は エラー B<ENOMEM> で失敗する。 また自動的なスタック拡張にも失敗する (さら"
"に B<sigaltstack>(2)  を使った代替スタックを利用可能にしていなかった場合に"
"は、 B<SIGSEGV> を生成してそのプロセスを kill する)。 この値は I<long> 型なの"
"で、32 ビットの I<long> 型を持つマシンでは、 この制限は最大で 2 GiB になる"
"か、この資源が無制限になる。"

#. type: TP
#: build/C/man2/getrlimit.2:146
#, no-wrap
msgid "B<RLIMIT_CORE>"
msgstr "B<RLIMIT_CORE>"

#. type: Plain text
#: build/C/man2/getrlimit.2:153
msgid ""
"Maximum size of I<core> file.  When 0 no core dump files are created.  When "
"nonzero, larger dumps are truncated to this size."
msgstr ""
"I<core> ファイルの最大サイズ。 0 の場合、core ファイルは生成されない。 0 以外"
"の場合、このサイズより大きいダンプは切り詰められる。"

#. type: TP
#: build/C/man2/getrlimit.2:153
#, no-wrap
msgid "B<RLIMIT_CPU>"
msgstr "B<RLIMIT_CPU>"

#. type: Plain text
#: build/C/man2/getrlimit.2:173
msgid ""
"CPU time limit in seconds.  When the process reaches the soft limit, it is "
"sent a B<SIGXCPU> signal.  The default action for this signal is to "
"terminate the process.  However, the signal can be caught, and the handler "
"can return control to the main program.  If the process continues to consume "
"CPU time, it will be sent B<SIGXCPU> once per second until the hard limit is "
"reached, at which time it is sent B<SIGKILL>.  (This latter point describes "
"Linux behavior.  Implementations vary in how they treat processes which "
"continue to consume CPU time after reaching the soft limit.  Portable "
"applications that need to catch this signal should perform an orderly "
"termination upon first receipt of B<SIGXCPU>.)"
msgstr ""
"CPU 時間の上限 (秒数)。プロセスがソフトリミットに達した場合に、\n"
"B<SIGXCPU> シグナルを送る。このシグナルに対するデフォルトの動作は、\n"
"プロセスの終了である。ただし、シグナルをキャッチして、ハンドラがメイン\n"
"プログラムに制御を返すこともできる。プロセスが CPU 時間を使い続けた\n"
"場合は、ハードリミットに達するまで 1 秒毎にプロセスに B<SIGXCPU> を送り、\n"
"ハードリミットに達すると B<SIGKILL> を送る。\n"
"(ソフトリミットを超過したときの動作は、 Linux における動作である。ソフ\n"
"トリミットを超えて CPU 時間を使い続けるプロセスの扱い方についての実装は\n"
"変化してきている。 このシグナルをキャッチする必要のある 移植性を考えた\n"
"アプリケーションでは、 最初に B<SIGXCPU> を受け取った時点で正しく終了\n"
"すべきである。)"

#. type: TP
#: build/C/man2/getrlimit.2:173
#, no-wrap
msgid "B<RLIMIT_DATA>"
msgstr "B<RLIMIT_DATA>"

#. type: Plain text
#: build/C/man2/getrlimit.2:184
msgid ""
"The maximum size of the process's data segment (initialized data, "
"uninitialized data, and heap).  This limit affects calls to B<brk>(2)  and "
"B<sbrk>(2), which fail with the error B<ENOMEM> upon encountering the soft "
"limit of this resource."
msgstr ""
"プロセスのデータセグメント (初期化されたデータ・初期化されていないデータ・"
"ヒープ) の最大値。 このリミットは B<brk>(2)  と B<sbrk>(2)  の呼び出しに影響"
"する。 これらの関数は、このリソースのソフトリミットに達すると、 エラー "
"B<ENOMEM> で失敗する。"

#. type: TP
#: build/C/man2/getrlimit.2:184
#, no-wrap
msgid "B<RLIMIT_FSIZE>"
msgstr "B<RLIMIT_FSIZE>"

#. type: Plain text
#: build/C/man2/getrlimit.2:196
msgid ""
"The maximum size of files that the process may create.  Attempts to extend a "
"file beyond this limit result in delivery of a B<SIGXFSZ> signal.  By "
"default, this signal terminates a process, but a process can catch this "
"signal instead, in which case the relevant system call (e.g., B<write>(2), "
"B<truncate>(2))  fails with the error B<EFBIG>."
msgstr ""
"プロセスが作成できるファイルサイズの最大値。 このサイズを超えてファイルを拡張"
"すると、 B<SIGXFSZ> シグナルを送る。 デフォルトでは、このシグナルはプロセスを"
"終了する。 プロセスをキャッチすることもできるが、 関連するシステムコール "
"(B<write>(2), B<truncate>(2)  など) はエラー B<EFBIG> で失敗する。"

#. type: TP
#: build/C/man2/getrlimit.2:196
#, no-wrap
msgid "B<RLIMIT_LOCKS> (Early Linux 2.4 only)"
msgstr "B<RLIMIT_LOCKS> (初期の Linux 2.4 のみ)"

#.  to be precise: Linux 2.4.0-test9; no longer in 2.4.25 / 2.5.65
#. type: Plain text
#: build/C/man2/getrlimit.2:204
msgid ""
"A limit on the combined number of B<flock>(2)  locks and B<fcntl>(2)  leases "
"that this process may establish."
msgstr ""
"このプロセスが実行できる B<flock>(2)  ロック数と B<fcntl>(2)  リース数の合計"
"値を制限する。"

#. type: TP
#: build/C/man2/getrlimit.2:204
#, no-wrap
msgid "B<RLIMIT_MEMLOCK>"
msgstr "B<RLIMIT_MEMLOCK>"

#. type: Plain text
#: build/C/man2/getrlimit.2:242
msgid ""
"The maximum number of bytes of memory that may be locked into RAM.  In "
"effect this limit is rounded down to the nearest multiple of the system page "
"size.  This limit affects B<mlock>(2)  and B<mlockall>(2)  and the B<mmap>"
"(2)  B<MAP_LOCKED> operation.  Since Linux 2.6.9 it also affects the "
"B<shmctl>(2)  B<SHM_LOCK> operation, where it sets a maximum on the total "
"bytes in shared memory segments (see B<shmget>(2))  that may be locked by "
"the real user ID of the calling process.  The B<shmctl>(2)  B<SHM_LOCK> "
"locks are accounted for separately from the per-process memory locks "
"established by B<mlock>(2), B<mlockall>(2), and B<mmap>(2)  B<MAP_LOCKED>; a "
"process can lock bytes up to this limit in each of these two categories.  In "
"Linux kernels before 2.6.9, this limit controlled the amount of memory that "
"could be locked by a privileged process.  Since Linux 2.6.9, no limits are "
"placed on the amount of memory that a privileged process may lock, and this "
"limit instead governs the amount of memory that an unprivileged process may "
"lock."
msgstr ""
"RAM 内にロックできるメモリの最大バイト数。 実際には、この制限はシステムページ"
"サイズの最も近い倍数に 切り捨てて丸められる。 この制限は B<mlock>(2), "
"B<mlockall>(2), B<mmap>(2)  の B<MAP_LOCKED> 操作に影響する。 Linux 2.6.9 以"
"降では B<shmctl>(2)  B<SHM_LOCK> 操作にも影響する。 この操作は呼び出し元プロ"
"セスの実 (real) ユーザー ID にロックされる 共有メモリセグメント (B<shmget>"
"(2)  を参照) の合計バイト数の最大値を設定する。 B<shmctl>(2)  B<SHM_LOCK> に"
"よるロックは、 B<mlock>(2), B<mlockall>(2), B<mmap>(2)  の B<MAP_LOCKED> に"
"よって確立されるプロセス毎のメモリロックとは分けて数える。 1 つのプロセスはこ"
"の制限までのバイトをロックできる。 この制限には 2 つの種類がある。 2.6.9 より"
"前の Linux カーネル では、 この制限は特権プロセスによってロックされるメモリの"
"合計を制御していた。 Linux 2.6.9 以降では、特権プロセスがロックするメモリの合"
"計に制限はなく、 代わりにこの制限は非特権プロセスがロックするメモリの合計に "
"適用されるようになった。"

#. type: TP
#: build/C/man2/getrlimit.2:242
#, no-wrap
msgid "B<RLIMIT_MSGQUEUE> (Since Linux 2.6.8)"
msgstr "B<RLIMIT_MSGQUEUE> (Linux 2.6.8 以降)"

#. type: Plain text
#: build/C/man2/getrlimit.2:250
msgid ""
"Specifies the limit on the number of bytes that can be allocated for POSIX "
"message queues for the real user ID of the calling process.  This limit is "
"enforced for B<mq_open>(3).  Each message queue that the user creates counts "
"(until it is removed)  against this limit according to the formula:"
msgstr ""
"呼び出し元プロセスの実ユーザー ID に対して、 POSIX メッセージキューのために確"
"保できるバイト数の制限を指定する。 この制限は B<mq_open>(3)  に対して適用され"
"る。 ユーザが作成した各々のメッセージキューのバイト数は 以下の式により計算さ"
"れ、(そのキューが削除されるまでの間)  この制限の計算対象に含められる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:254
#, no-wrap
msgid ""
"    bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"            attr.mq_maxmsg * attr.mq_msgsize\n"
msgstr ""
"    bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +\n"
"            attr.mq_maxmsg * attr.mq_msgsize\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:262
msgid ""
"where I<attr> is the I<mq_attr> structure specified as the fourth argument "
"to B<mq_open>(3)."
msgstr ""
"ここで I<attr> は I<mq_attr> 構造体であり、 B<mq_open>(3)  の第 4 引き数とし"
"て指定される。"

#. type: Plain text
#: build/C/man2/getrlimit.2:268
msgid ""
"The first addend in the formula, which includes I<sizeof(struct msg_msg\\ *)"
"> (4 bytes on Linux/i386), ensures that the user cannot create an unlimited "
"number of zero-length messages (such messages nevertheless each consume some "
"system memory for bookkeeping overhead)."
msgstr ""
"I<sizeof(struct msg_msg\\ *)> (Linux/i386 では 4 バイト) を含む最初の加数"
"は、 ユーザーが長さ 0 のメッセージを無制限に作れないこと保証している (このよ"
"うなメッセージであっても、 記録のためのオーバーヘッドでシステムメモリを消費す"
"る)。"

#. type: TP
#: build/C/man2/getrlimit.2:268
#, no-wrap
msgid "B<RLIMIT_NICE> (since Linux 2.6.12, but see BUGS below)"
msgstr "B<RLIMIT_NICE> (Linux 2.6.12 以降, 下記の「バグ」の節も参照)"

#. type: Plain text
#: build/C/man2/getrlimit.2:281
msgid ""
"Specifies a ceiling to which the process's nice value can be raised using "
"B<setpriority>(2)  or B<nice>(2).  The actual ceiling for the nice value is "
"calculated as I<20\\ -\\ rlim_cur>.  (This strangeness occurs because "
"negative numbers cannot be specified as resource limit values, since they "
"typically have special meanings.  For example, B<RLIM_INFINITY> typically is "
"the same as -1.)"
msgstr ""
"B<setpriority>(2)  や B<nice>(2)  を使って引き上げられるプロセスの nice 値の"
"上限を指定する。 nice 値の実際の上限は I<20\\ -\\ rlim_cur> で計算される (こ"
"のような変な状況は、リソース制限値として負の数を指定できないため 発生する。通"
"常、負の値は特別な意味を持っているからである。 例えば、通常は "
"B<RLIM_INFINITY> の値は -1 である)。"

#. type: TP
#: build/C/man2/getrlimit.2:281
#, no-wrap
msgid "B<RLIMIT_NOFILE>"
msgstr "B<RLIMIT_NOFILE>"

#. type: Plain text
#: build/C/man2/getrlimit.2:295
msgid ""
"Specifies a value one greater than the maximum file descriptor number that "
"can be opened by this process.  Attempts (B<open>(2), B<pipe>(2), B<dup>(2), "
"etc.)  to exceed this limit yield the error B<EMFILE>.  (Historically, this "
"limit was named B<RLIMIT_OFILE> on BSD.)"
msgstr ""
"このプロセスがオープンできるファイルディスクリプタ数の最大値より 1 大きい値を"
"指定する。 (B<open>(2), B<pipe>(2), B<dup>(2)  などにより) この上限を超えよう"
"とした場合、エラー B<EMFILE> が発生する (歴史的に、BSD ではこの上限は "
"B<RLIMIT_OFILE> という名前となっている)。"

#. type: TP
#: build/C/man2/getrlimit.2:295
#, no-wrap
msgid "B<RLIMIT_NPROC>"
msgstr "B<RLIMIT_NPROC>"

#. type: Plain text
#: build/C/man2/getrlimit.2:303
msgid ""
"The maximum number of processes (or, more precisely on Linux, threads)  that "
"can be created for the real user ID of the calling process.  Upon "
"encountering this limit, B<fork>(2)  fails with the error B<EAGAIN>."
msgstr ""
"呼び出したプロセスの実ユーザー ID で作成できる最大プロセス数 (より正確には "
"Linux ではスレッド数)。 この上限に達すると、 B<fork>(2)  はエラー B<EAGAIN> "
"で失敗する。"

#. type: TP
#: build/C/man2/getrlimit.2:303
#, no-wrap
msgid "B<RLIMIT_RSS>"
msgstr "B<RLIMIT_RSS>"

#.  As at kernel 2.6.12, this limit still does nothing in 2.6 though
#.  talk of making it do something has surfaced from time to time in LKML
#.        -- MTK, Jul 05
#. type: Plain text
#: build/C/man2/getrlimit.2:315
msgid ""
"Specifies the limit (in pages) of the process's resident set (the number of "
"virtual pages resident in RAM).  This limit has effect only in Linux 2.4.x, "
"x E<lt> 30, and there affects only calls to B<madvise>(2)  specifying "
"B<MADV_WILLNEED>."
msgstr ""
"プロセスの resident set (RAM 上に存在する仮想ページの数) の 上限を (ページ数"
"で) 指定する。 この制限は 2.4.30 より前でしか影響がなく、 B<madvise>(2)  に "
"B<MADV_WILLNEED> を指定した関数コールにしか影響しない。"

#. type: TP
#: build/C/man2/getrlimit.2:315
#, no-wrap
msgid "B<RLIMIT_RTPRIO> (Since Linux 2.6.12, but see BUGS)"
msgstr "B<RLIMIT_RTPRIO> (Linux 2.6.12 以降, バグの節も参照)"

#. type: Plain text
#: build/C/man2/getrlimit.2:322
msgid ""
"Specifies a ceiling on the real-time priority that may be set for this "
"process using B<sched_setscheduler>(2)  and B<sched_setparam>(2)."
msgstr ""
"B<sched_setscheduler>(2)  や B<sched_setparam>(2)  を使って設定できる、そのプ"
"ロセスのリアルタイム優先度の上限を指定する。"

#. type: TP
#: build/C/man2/getrlimit.2:322
#, no-wrap
msgid "B<RLIMIT_RTTIME> (Since Linux 2.6.25)"
msgstr "B<RLIMIT_RTTIME> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/getrlimit.2:334
msgid ""
"Specifies a limit (in microseconds)  on the amount of CPU time that a "
"process scheduled under a real-time scheduling policy may consume without "
"making a blocking system call.  For the purpose of this limit, each time a "
"process makes a blocking system call, the count of its consumed CPU time is "
"reset to zero.  The CPU time count is not reset if the process continues "
"trying to use the CPU but is preempted, its time slice expires, or it calls "
"B<sched_yield>(2)."
msgstr ""
"リアルタイムスケジューリング方針でスケジューリングされるプロセスが ブロッキン"
"グ型のシステムコールを呼び出さずに消費することのできる CPU 時間の合計について"
"の上限を (マイクロ秒単位で) 指定する。 この上限の目的のため、プロセスがブロッ"
"キング型のシステムコールを 呼び出す度に、消費された CPU 時間のカウントは 0 に"
"リセットされる。 プロセスが CPU を使い続けようとしたが他のプロセスに置き換え"
"られた (preempted) 場合や、そのプロセスのタイムスライスが満了した場合、 その"
"プロセスが B<sched_yield>(2)  を呼び出した場合は、CPU 時間のカウントはリセッ"
"トされない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:345
msgid ""
"Upon reaching the soft limit, the process is sent a B<SIGXCPU> signal.  If "
"the process catches or ignores this signal and continues consuming CPU time, "
"then B<SIGXCPU> will be generated once each second until the hard limit is "
"reached, at which point the process is sent a B<SIGKILL> signal."
msgstr ""
"ソフトリミットに達すると、そのプロセスに B<SIGXCPU> シグナルが送られる。その"
"プロセスがこのシグナルを捕捉するか 無視して、CPU 時間を消費し続けた場合に"
"は、 ハードリミットに達するまで 1 秒に 1 回 B<SIGXCPU> が生成され続けることに"
"なる。 ハードリミットに達した時点で、そのプロセスには B<SIGKILL> シグナルが送"
"られる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:348
msgid ""
"The intended use of this limit is to stop a runaway real-time process from "
"locking up the system."
msgstr ""
"この上限を意図的に使用するのは、暴走したリアルタイムプロセスを 停止して、シス"
"テムが動かなくなるのを避ける場合である。"

#. type: TP
#: build/C/man2/getrlimit.2:348
#, no-wrap
msgid "B<RLIMIT_SIGPENDING> (Since Linux 2.6.8)"
msgstr "B<RLIMIT_SIGPENDING> (Linux 2.6.8 以降)"

#.  This replaces the /proc/sys/kernel/rtsig-max system-wide limit
#.  that was present in kernels <= 2.6.7.  MTK Dec 04
#. type: Plain text
#: build/C/man2/getrlimit.2:362
msgid ""
"Specifies the limit on the number of signals that may be queued for the real "
"user ID of the calling process.  Both standard and real-time signals are "
"counted for the purpose of checking this limit.  However, the limit is "
"enforced only for B<sigqueue>(3); it is always possible to use B<kill>(2)  "
"to queue one instance of any of the signals that are not already queued to "
"the process."
msgstr ""
"呼び出し元プロセスの実ユーザー ID に対して キューに入れられるシグナルの\n"
"数の制限を指定する。この制限をチェックするため、標準シグナルとリアルタ\n"
"イムシグナルの両方がカウントされる。しかし、この制限は B<sigqueue>(3)\n"
"に対してのみ適用され、 B<kill>(2) 使うことで、そのプロセスに対してま\n"
"だキューに入れられていない シグナルのインスタンスをキューに入れることが\n"
"できる。"

#. type: TP
#: build/C/man2/getrlimit.2:362
#, no-wrap
msgid "B<RLIMIT_STACK>"
msgstr "B<RLIMIT_STACK>"

#. type: Plain text
#: build/C/man2/getrlimit.2:370
msgid ""
"The maximum size of the process stack, in bytes.  Upon reaching this limit, "
"a B<SIGSEGV> signal is generated.  To handle this signal, a process must "
"employ an alternate signal stack (B<sigaltstack>(2))."
msgstr ""
"プロセススタックの最大サイズをバイト単位で指定する。 この上限に達すると、 "
"B<SIGSEGV> シグナルが生成される。 このシグナルを扱うためには、 プロセスは代り"
"のシグナルスタック (B<sigaltstack>(2))  を使用しなければならない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:375
msgid ""
"Since Linux 2.6.23, this limit also determines the amount of space used for "
"the process's command-line arguments and environment variables; for details, "
"see B<execve>(2)."
msgstr ""
"Linux 2.6.23 以降では、この制限はプロセスのコマンドライン引き数と環境変数 に"
"使用される空間の合計サイズの上限の決定にも使用される。詳細については "
"B<execve>(2)  を参照。"

#. type: SS
#: build/C/man2/getrlimit.2:375
#, no-wrap
msgid "prlimit()"
msgstr "prlimit()"

#.  commit c022a0acad534fd5f5d5f17280f6d4d135e74e81
#.  Author: Jiri Slaby <jslaby@suse.cz>
#.  Date:   Tue May 4 18:03:50 2010 +0200
#. type: Plain text
#: build/C/man2/getrlimit.2:386
msgid ""
"The Linux-specific B<prlimit>()  system call combines and extends the "
"functionality of B<setrlimit>()  and B<getrlimit>().  It can be used to both "
"set and get the resource limits of an arbitrary process."
msgstr ""
"Linux 固有の B<prlimit>() システムコールは、 B<setrlimit>() と B<getrlimit> "
"の機能を合わせて拡張したものである。 このシステムコールを使って、任意のプロセ"
"スのリソース上限の設定と取得を行うことができる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:393
msgid ""
"The I<resource> argument has the same meaning as for B<setrlimit>()  and "
"B<getrlimit>()."
msgstr ""
"I<resource> 引き数は B<setrlimit>() や B<getrlimit>() と同じ意味である。"

#. type: Plain text
#: build/C/man2/getrlimit.2:411
msgid ""
"If the I<new_limit> argument is a not NULL, then the I<rlimit> structure to "
"which it points is used to set new values for the soft and hard limits for "
"I<resource>.  If the I<old_limit> argument is a not NULL, then a successful "
"call to B<prlimit>()  places the previous soft and hard limits for "
"I<resource> in the I<rlimit> structure pointed to by I<old_limit>."
msgstr ""
"I<new_limit> 引き数が NULL 以外の場合、 I<new_limit> が指す I<rlimit> 構造体"
"を使って I<resource> のソフトリミットとハードリミットの新しい値が設定され"
"る。 I<old_limit> 引き数が NULL 以外の場合、 B<prlimit>() の呼び出しが成功す"
"ると、 I<resource> の直前のソフトリミットとハードリミットが I<old_limit> が指"
"す I<rlimit> 構造体に格納される。"

#.  FIXME this permission check is strange
#.  Asked about this on LKML, 7 Nov 2010
#.      "Inconsistent credential checking in prlimit() syscall"
#. type: Plain text
#: build/C/man2/getrlimit.2:430
msgid ""
"The I<pid> argument specifies the ID of the process on which the call is to "
"operate.  If I<pid> is 0, then the call applies to the calling process.  To "
"set or get the resources of a process other than itself, the caller must "
"have the B<CAP_SYS_RESOURCE> capability, or the real, effective, and saved "
"set user IDs of the target process must match the real user ID of the caller "
"I<and> the real, effective, and saved set group IDs of the target process "
"must match the real group ID of the caller."
msgstr ""
"I<pid> 引き数は呼び出しの操作対象となるプロセス ID を指定する。 I<pid> が 0 "
"の場合、呼び出しは呼び出し元プロセスに対して適用される。 自分以外のプロセスの"
"リソースの設定と取得を行うためには、 呼び出し元プロセスが "
"B<CAP_SYS_RESOURCE> ケーパビリティを持っているか、 対象となるプロセスの実ユー"
"ザ ID、 実効ユーザ ID、 保存 set-user-ID が呼び出し元プロセスの実ユーザ ID と"
"一致し、 かつ、 対象となるプロセスの実グループ ID、 実効グループ ID、 保存 "
"set-group-ID が呼び出し元プロセスの実グループ ID と一致していなければならな"
"い。"

#. type: Plain text
#: build/C/man2/getrlimit.2:435
msgid ""
"On success, these system calls return 0.  On error, -1 is returned, and "
"I<errno> is set appropriately."
msgstr ""
"成功した場合、これらのシステムコールは 0 を返す。\n"
"エラーの場合は -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/getrlimit.2:440
msgid ""
"A pointer argument points to a location outside the accessible address space."
msgstr "場所を指すポインタ引き数がアクセス可能なアドレス空間外を指している。"

#. type: Plain text
#: build/C/man2/getrlimit.2:452
msgid ""
"The value specified in I<resource> is not valid; or, for B<setrlimit>()  or "
"B<prlimit>(): I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr ""
"I<resource> で指定された値が有効でない。\n"
"または、 B<setrlimit>() や B<prlimit>() で、\n"
"I<rlim-E<gt>rlim_cur> が I<rlim-E<gt>rlim_max> よりも大きかった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:464
msgid ""
"An unprivileged process tried to raise the hard limit; the "
"B<CAP_SYS_RESOURCE> capability is required to do this.  Or, the caller tried "
"to increase the hard B<RLIMIT_NOFILE> limit above the current kernel maximum "
"(B<NR_OPEN>).  Or, the calling process did not have permission to set limits "
"for the process specified by I<pid>."
msgstr ""
"特権のないプロセスがハードリミットを上げようとした。\n"
"これを行うためには B<CAP_SYS_RESOURCE> ケーパビリティが必要である。\n"
"または、特権のないプロセスが B<RLIMIT_NOFILE> ハードリミットを\n"
"現在のカーネルの最大値 (B<NR_OPEN>) 以上に増やそうとした。\n"
"または、呼び出したプロセスが I<pid> で指定されたプロセスのリミットを\n"
"設定する許可を持っていなかった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:468
msgid "Could not find a process with the ID specified in I<pid>."
msgstr "I<pid> で指定された ID のプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/getrlimit.2:473
msgid ""
"The B<prlimit>()  system call is available since Linux 2.6.36.  Library "
"support is available since glibc 2.13."
msgstr ""
"B<prlimit>() システムコールは Linux 2.6.36 以降で利用できる。 ライブラリのサ"
"ポートは glibc 2.13 以降で利用できる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:477
msgid "B<getrlimit>(), B<setrlimit>(): SVr4, 4.3BSD, POSIX.1-2001."
msgstr "B<getrlimit>(), B<setrlimit>(): SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/getrlimit.2:480
msgid "B<prlimit>(): Linux-specific."
msgstr "B<prlimit>(): Linux 固有。"

#. type: Plain text
#: build/C/man2/getrlimit.2:496
msgid ""
"B<RLIMIT_MEMLOCK> and B<RLIMIT_NPROC> derive from BSD and are not specified "
"in POSIX.1-2001; they are present on the BSDs and Linux, but on few other "
"implementations.  B<RLIMIT_RSS> derives from BSD and is not specified in "
"POSIX.1-2001; it is nevertheless present on most implementations.  "
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>, and "
"B<RLIMIT_SIGPENDING> are Linux-specific."
msgstr ""
"B<RLIMIT_MEMLOCK> と B<RLIMIT_NPROC> は BSD から派生し、\n"
"POSIX.1-2001 には指定されていない。\n"
"これらは BSD 系と Linux に存在するが、他の実装は少ない。\n"
"B<RLIMIT_RSS> は BSD から派生し、POSIX.1-2001 には指定されていない。\n"
"それにも関わらず多くの実装で存在する。\n"
"B<RLIMIT_MSGQUEUE>, B<RLIMIT_NICE>, B<RLIMIT_RTPRIO>, B<RLIMIT_RTTIME>,\n"
"B<RLIMIT_SIGPENDING> は Linux 固有のものである。"

#. type: Plain text
#: build/C/man2/getrlimit.2:502
msgid ""
"A child process created via B<fork>(2)  inherits its parent's resource "
"limits.  Resource limits are preserved across B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された作成された子プロセスは、 親プロセスのリソース制限を継"
"承する。 B<execve>(2)  の前後でリソース制限は保存される。"

#. type: Plain text
#: build/C/man2/getrlimit.2:511
msgid ""
"One can set the resource limits of the shell using the built-in I<ulimit> "
"command (I<limit> in B<csh>(1)).  The shell's resource limits are inherited "
"by the processes that it creates to execute commands."
msgstr ""
"シェルのリソース制限は、シェルの組み込みコマンドである I<ulimit> (B<csh>(1)  "
"では I<limit )> を使って設定することができる。 このシェルのリソース制限は、コ"
"マンドを実行してシェルが生成するプロセス に引き継がれる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:516
msgid ""
"Since Linux 2.6.24, the resource limits of any process can be inspected via "
"I</proc/[pid]/limits>; see B<proc>(5)."
msgstr ""
"Linux 2.6.24 以降では、 プロセスのリソース上限は I</proc/[pid]/limits> で知る"
"ことができる。 B<proc>(5) 参照。"

#. type: Plain text
#: build/C/man2/getrlimit.2:525
msgid ""
"Ancient systems provided a B<vlimit>()  function with a similar purpose to "
"B<setrlimit>().  For backward compatibility, glibc also provides B<vlimit>"
"().  All new applications should be written using B<setrlimit>()."
msgstr ""
"古いシステムでは、 B<setrlimit>()  と同様の目的を持つ関数 B<vlimit>()  が提供"
"されていた。 後方互換性のため、glibc でも B<vlimit>()  を提供している。 全て"
"の新しいアプリケーションでは、 B<setrlimit>()  を使用すべきである。"

#.  FIXME prlimit() does not suffer
#.  https://bugzilla.kernel.org/show_bug.cgi?id=5042
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=12201
#.  Since versions 2.13, glibc has library implementations of
#.  getrlimit() and setrlimit() that use prlimit() to work around
#.  this bug.
#. type: Plain text
#: build/C/man2/getrlimit.2:540
msgid ""
"In older Linux kernels, the B<SIGXCPU> and B<SIGKILL> signals delivered when "
"a process encountered the soft and hard B<RLIMIT_CPU> limits were delivered "
"one (CPU) second later than they should have been.  This was fixed in kernel "
"2.6.8."
msgstr ""
"以前の Linux カーネルでは、プロセスがソフトまたはハード B<RLIMIT_CPU> リミッ"
"トに達した場合に送られる B<SIGXCPU> と B<SIGKILL> シグナルが、本来送られるべ"
"き時点の 1 (CPU) 秒後に送られてしまう。 これはカーネル 2.6.8 で修正された。"

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=114008066530167&w=2
#. type: Plain text
#: build/C/man2/getrlimit.2:548
msgid ""
"In 2.6.x kernels before 2.6.17, a B<RLIMIT_CPU> limit of 0 is wrongly "
"treated as \"no limit\" (like B<RLIM_INFINITY>).  Since Linux 2.6.17, "
"setting a limit of 0 does have an effect, but is actually treated as a limit "
"of 1 second."
msgstr ""
"2.6.17 より前の 2.6.x カーネルでは、 B<RLIMIT_CPU> リミットが 0 の場合、 "
"(B<RLIM_INFINITY> と同じように) 「制限なし」と間違って解釈されていた。 Linux "
"2.6.17 以降では、リミットを 0 に設定した場合にも 効果を持つようになっている"
"が、実際にはリミットの値は 1 秒となる。"

#.  See https://lwn.net/Articles/145008/
#. type: Plain text
#: build/C/man2/getrlimit.2:553
msgid ""
"A kernel bug means that B<RLIMIT_RTPRIO> does not work in kernel 2.6.12; the "
"problem is fixed in kernel 2.6.13."
msgstr ""
"カーネル 2.6.12 には、 B<RLIMIT_RTPRIO> が動作しないというバグがある。この問"
"題はカーネル 2.6.13 で修正されている。"

#.  see http://marc.theaimsgroup.com/?l=linux-kernel&m=112256338703880&w=2
#. type: Plain text
#: build/C/man2/getrlimit.2:564
msgid ""
"In kernel 2.6.12, there was an off-by-one mismatch between the priority "
"ranges returned by B<getpriority>(2)  and B<RLIMIT_NICE>.  This had the "
"effect that the actual ceiling for the nice value was calculated as I<19\\ -"
"\\ rlim_cur>.  This was fixed in kernel 2.6.13."
msgstr ""
"カーネル 2.6.12 では、 B<getpriority>(2)  と B<RLIMIT_NICE> が返す優先度の範"
"囲が一つずれていた。このため、nice 値の実際の上限が I<19\\ -\\ rlim_cur> に"
"なってしまうという影響があった。これはカーネル 2.6.13 で修正された。"

#.  The relevant patch, sent to LKML, seems to be
#.  http://thread.gmane.org/gmane.linux.kernel/273462
#.  From: Roland McGrath <roland <at> redhat.com>
#.  Subject: [PATCH 7/7] make RLIMIT_CPU/SIGXCPU per-process
#.  Date: 2005-01-23 23:27:46 GMT
#.  Tested Solaris 10, FreeBSD 9, OpenBSD 5.0
#.  FIXME https://bugzilla.kernel.org/show_bug.cgi?id=50951
#. type: Plain text
#: build/C/man2/getrlimit.2:591
msgid ""
"Since Linux 2.6.12, if a process reaches its soft B<RLIMIT_CPU> limit and "
"has a handler installed for B<SIGXCPU>, then, in addition to invoking the "
"signal handler, the kernel increases the soft limit by one second.  This "
"behavior repeats if the process continues to consume CPU time, until the "
"hard limit is reached, at which point the process is killed.  Other "
"implementations do not change the B<RLIMIT_CPU> soft limit in this manner, "
"and the Linux behavior is probably not standards conformant; portable "
"applications should avoid relying on this Linux-specific behavior.  The "
"Linux-specific B<RLIMIT_RTTIME> limit exhibits the same behavior when the "
"soft limit is encountered."
msgstr ""
"Linux 2.6.12 以降では、 プロセスがその B<RLIMIT_CPU> ソフトリミットに達し、 "
"B<SIGXCPU> に対してシグナルハンドラが設定されている場合、 シグナルハンドラを"
"起動するだけでなく、 カーネルは 1 秒間ソフトリミットを増やす。 そのプロセス"
"が CPU 時間を消費し続けている限り、 ハードリミットに達するまで、この動作が繰"
"り返される。 ハードリミットに達すると、その時点でプロセスは kill される。 他"
"の実装では、上記のような B<RLIMIT_CPU> ソフトリミットの変更は行われず、 おそ"
"らく Linux の動作は標準に準拠していない。 移植性が必要なアプリケーションでは"
"この Linux 固有の動作を前提にするのは避けるべきである。 Linux 固有の上限 "
"B<RLIMIT_RTTIME> でも、 ソフトリミットに達した場合に同じ動作となる。"

#. type: Plain text
#: build/C/man2/getrlimit.2:600
msgid ""
"Kernels before 2.4.22 did not diagnose the error B<EINVAL> for B<setrlimit>"
"()  when I<rlim-E<gt>rlim_cur> was greater than I<rlim-E<gt>rlim_max>."
msgstr ""
"2.4.22 より前のカーネルでは、 I<rlim-E<gt>rlim_cur> が I<rlim-E<gt>rlim_max> "
"より大きかった場合、 B<setrlimit>()  での B<EINVAL> エラーを検出できない。"

#. type: Plain text
#: build/C/man2/getrlimit.2:603
msgid "The program below demonstrates the use of B<prlimit>()."
msgstr "以下のプログラムに B<prlimit>() の使用例を示す。"

#. type: Plain text
#: build/C/man2/getrlimit.2:612
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#define _FILE_OFFSET_BITS 64\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>sys/resource.hE<gt>\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:615
#, no-wrap
msgid ""
"#define errExit(msg) \tdo { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg) \tdo { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:622
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct rlimit old, new;\n"
"    struct rlimit *newp;\n"
"    pid_t pid;\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:628
#, no-wrap
msgid ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (!(argc == 2 || argc == 4)) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>pidE<gt> [E<lt>new-soft-limitE<gt> \"\n"
"                \"E<lt>new-hard-limitE<gt>]\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:630
#, no-wrap
msgid "    pid = atoi(argv[1]);        /* PID of target process */\n"
msgstr "    pid = atoi(argv[1]);        /* PID of target process */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:637
#, no-wrap
msgid ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"
msgstr ""
"    newp = NULL;\n"
"    if (argc == 4) {\n"
"        new.rlim_cur = atoi(argv[2]);\n"
"        new.rlim_max = atoi(argv[3]);\n"
"        newp = &new;\n"
"    }\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:640
#, no-wrap
msgid ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"
msgstr ""
"    /* Set CPU time limit of target process; retrieve and display\n"
"       previous limit */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:645
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr ""
"    if (prlimit(pid, RLIMIT_CPU, newp, &old) == -1)\n"
"        errExit(\"prlimit-1\");\n"
"    printf(\"Previous limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:647
#, no-wrap
msgid "    /* Retrieve and display new CPU time limit */\n"
msgstr "    /* Retrieve and display new CPU time limit */\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:652
#, no-wrap
msgid ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"
msgstr ""
"    if (prlimit(pid, RLIMIT_CPU, NULL, &old) == -1)\n"
"        errExit(\"prlimit-2\");\n"
"    printf(\"New limits: soft=%lld; hard=%lld\\en\",\n"
"            (long long) old.rlim_cur, (long long) old.rlim_max);\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:655
#, no-wrap
msgid ""
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man2/getrlimit.2:674
msgid ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), B<mlock>"
"(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), B<shmctl>(2), "
"B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), B<capabilities>(7), "
"B<signal>(7)"
msgstr ""
"B<prlimit>(1), B<dup>(2), B<fcntl>(2), B<fork>(2), B<getrusage>(2), B<mlock>"
"(2), B<mmap>(2), B<open>(2), B<quotactl>(2), B<sbrk>(2), B<shmctl>(2), "
"B<malloc>(3), B<sigqueue>(3), B<ulimit>(3), B<core>(5), B<capabilities>(7), "
"B<signal>(7)"

#. type: TH
#: build/C/man2/getrusage.2:39
#, no-wrap
msgid "GETRUSAGE"
msgstr "GETRUSAGE"

#. type: TH
#: build/C/man2/getrusage.2:39 build/C/man2/getsid.2:26
#, no-wrap
msgid "2010-09-26"
msgstr "2010-09-26"

#. type: Plain text
#: build/C/man2/getrusage.2:42
msgid "getrusage - get resource usage"
msgstr "getrusage - 資源の使用量を取得する"

#. type: Plain text
#: build/C/man2/getrusage.2:48
msgid "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"
msgstr "B<int getrusage(int >I<who>B<, struct rusage *>I<usage>B<);>"

#. type: Plain text
#: build/C/man2/getrusage.2:54
msgid ""
"B<getrusage>()  returns resource usage measures for I<who>, which can be one "
"of the following:"
msgstr ""
"B<getrusage>()  は I<who> の資源 (resource) の使用量を返す。 I<who> には以下"
"のいずれか一つを指定できる。"

#. type: TP
#: build/C/man2/getrusage.2:54
#, no-wrap
msgid "B<RUSAGE_SELF>"
msgstr "B<RUSAGE_SELF>"

#. type: Plain text
#: build/C/man2/getrusage.2:58
msgid ""
"Return resource usage statistics for the calling process, which is the sum "
"of resources used by all threads in the process."
msgstr ""
"呼び出したプロセスの資源使用量、 そのプロセス内の全スレッドが使用している資源"
"の合計を返す。"

#. type: TP
#: build/C/man2/getrusage.2:58
#, no-wrap
msgid "B<RUSAGE_CHILDREN>"
msgstr "B<RUSAGE_CHILDREN>"

#. type: Plain text
#: build/C/man2/getrusage.2:65
msgid ""
"Return resource usage statistics for all children of the calling process "
"that have terminated and been waited for.  These statistics will include the "
"resources used by grandchildren, and further removed descendants, if all of "
"the intervening descendants waited on their terminated children."
msgstr ""
"呼び出したプロセスの子プロセスのうち、 終了して待ち状態にある全プロセスが使用"
"している資源使用量の統計を返す。 これらの統計情報には、孫プロセスやその子孫の"
"プロセスのうち、 削除待ちのものが使用している資源も含まれる。"

#. type: TP
#: build/C/man2/getrusage.2:65
#, no-wrap
msgid "B<RUSAGE_THREAD> (since Linux 2.6.26)"
msgstr "B<RUSAGE_THREAD> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:68
msgid "Return resource usage statistics for the calling thread."
msgstr "呼び出したスレッドに関する資源使用量の統計を返す。"

#. type: Plain text
#: build/C/man2/getrusage.2:72
msgid ""
"The resource usages are returned in the structure pointed to by I<usage>, "
"which has the following form:"
msgstr ""
"資源使用量は I<usage> が指す構造体に格納されて返される。 構造体は以下の形式で"
"ある。"

#. type: Plain text
#: build/C/man2/getrusage.2:93
#, no-wrap
msgid ""
"struct rusage {\n"
"    struct timeval ru_utime; /* user CPU time used */\n"
"    struct timeval ru_stime; /* system CPU time used */\n"
"    long   ru_maxrss;        /* maximum resident set size */\n"
"    long   ru_ixrss;         /* integral shared memory size */\n"
"    long   ru_idrss;         /* integral unshared data size */\n"
"    long   ru_isrss;         /* integral unshared stack size */\n"
"    long   ru_minflt;        /* page reclaims (soft page faults) */\n"
"    long   ru_majflt;        /* page faults (hard page faults) */\n"
"    long   ru_nswap;         /* swaps */\n"
"    long   ru_inblock;       /* block input operations */\n"
"    long   ru_oublock;       /* block output operations */\n"
"    long   ru_msgsnd;        /* IPC messages sent */\n"
"    long   ru_msgrcv;        /* IPC messages received */\n"
"    long   ru_nsignals;      /* signals received */\n"
"    long   ru_nvcsw;         /* voluntary context switches */\n"
"    long   ru_nivcsw;        /* involuntary context switches */\n"
"};\n"
msgstr ""
"struct rusage {\n"
"    struct timeval ru_utime; /* 使用されたユーザー CPU 時間 */\n"
"    struct timeval ru_stime; /* 使用されたシステム CPU 時間 */\n"
"    long   ru_maxrss;        /* RAM 上に存在する仮想ページのサイズ\n"
"                               (resident set size) の最大値 */\n"
"    long   ru_ixrss;         /* 共有メモリの合計サイズ */\n"
"    long   ru_idrss;         /* 非共有データの合計サイズ */\n"
"    long   ru_isrss;         /* 非共有スタックの合計サイズ */\n"
"    long   ru_minflt;        /* ページの再利用 (ソフトページフォルト) */\n"
"    long   ru_majflt;        /* ページフォールト (ハードページフォルト) */\n"
"    long   ru_nswap;         /* スワップ */\n"
"    long   ru_inblock;       /* ブロック入力操作 */\n"
"    long   ru_oublock;       /* ブロック出力操作 */\n"
"    long   ru_msgsnd;        /* 送信された IPC メッセージ */\n"
"    long   ru_msgrcv;        /* 受信された IPC メッセージ */\n"
"    long   ru_nsignals;      /* 受信されたシグナル */\n"
"    long   ru_nvcsw;         /* 意図したコンテキスト切り替え */\n"
"    long   ru_nivcsw;        /* 意図しないコンテキスト切り替え */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getrusage.2:101
msgid ""
"Not all fields are completed; unmaintained fields are set to zero by the "
"kernel.  (The unmaintained fields are provided for compatibility with other "
"systems, and because they may one day be supported on Linux.)  The fields "
"are interpreted as follows:"
msgstr ""
"すべてのフィールドがサポートされているわけではない。 メンテナンスされていない"
"フィールドには、 カーネルが 0 を設定する (メンテナンスされていないフィールド"
"は、 他のシステムとの互換性のために提供されており、 いつか Linux でもサポート"
"されるかもしれない)。 各フィールドの詳細は以下の通りである。"

#. type: TP
#: build/C/man2/getrusage.2:101
#, no-wrap
msgid "I<ru_utime>"
msgstr "I<ru_utime>"

#. type: Plain text
#: build/C/man2/getrusage.2:107
msgid ""
"This is the total amount of time spent executing in user mode, expressed in "
"a I<timeval> structure (seconds plus microseconds)."
msgstr ""
"ユーザモードでの実行で消費された合計時間。 I<timeval> 構造体 (秒とミリ秒) で"
"表現される。"

#. type: TP
#: build/C/man2/getrusage.2:107
#, no-wrap
msgid "I<ru_stime>"
msgstr "I<ru_stime>"

#. type: Plain text
#: build/C/man2/getrusage.2:113
msgid ""
"This is the total amount of time spent executing in kernel mode, expressed "
"in a I<timeval> structure (seconds plus microseconds)."
msgstr ""
"カーネルモードでの実行で消費された合計時間。 I<timeval> 構造体 (秒とミリ秒) "
"で表現される。"

#. type: TP
#: build/C/man2/getrusage.2:113
#, no-wrap
msgid "I<ru_maxrss> (since Linux 2.6.32)"
msgstr "I<ru_maxrss> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:120
msgid ""
"This is the maximum resident set size used (in kilobytes).  For "
"B<RUSAGE_CHILDREN>, this is the resident set size of the largest child, not "
"the maximum resident set size of the process tree."
msgstr ""
"使用された resident set size の最大値 (キロバイト単位)。 B<RUSAGE_CHILDREN> "
"の場合には、プロセスツリーの resident set size の最大値ではなく、 最も大きい"
"子プロセスの resident set size となる。"

#. type: TP
#: build/C/man2/getrusage.2:120
#, no-wrap
msgid "I<ru_ixrss> (unmaintained)"
msgstr "I<ru_ixrss> (メンテナンスされていない)"

#.  On some systems, this field records the number of signals received.
#. type: Plain text
#: build/C/man2/getrusage.2:126 build/C/man2/getrusage.2:131
#: build/C/man2/getrusage.2:136 build/C/man2/getrusage.2:148
#: build/C/man2/getrusage.2:160 build/C/man2/getrusage.2:166
#: build/C/man2/getrusage.2:170
msgid "This field is currently unused on Linux."
msgstr "このフィールドは現在のところ Linux では未使用である。"

#. type: TP
#: build/C/man2/getrusage.2:126
#, no-wrap
msgid "I<ru_idrss> (unmaintained)"
msgstr "I<ru_idrss> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:131
#, no-wrap
msgid "I<ru_isrss> (unmaintained)"
msgstr "I<ru_isrss> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:136
#, no-wrap
msgid "I<ru_minflt>"
msgstr "I<ru_minflt>"

#. type: Plain text
#: build/C/man2/getrusage.2:141
msgid ""
"The number of page faults serviced without any I/O activity; here I/O "
"activity is avoided by ``reclaiming'' a page frame from the list of pages "
"awaiting reallocation."
msgstr ""
"I/O 動作なしで発生したページフォルトの回数。 再割り当てを待っているページリス"
"トからページフレームを「回収」 (reclaim) することで、 I/O 動作を避けることが"
"できる。"

#. type: TP
#: build/C/man2/getrusage.2:141
#, no-wrap
msgid "I<ru_majflt>"
msgstr "I<ru_majflt>"

#. type: Plain text
#: build/C/man2/getrusage.2:144
msgid "The number of page faults serviced that required I/O activity."
msgstr "I/O 動作を必要とするページフォルトの回数。"

#. type: TP
#: build/C/man2/getrusage.2:144
#, no-wrap
msgid "I<ru_nswap> (unmaintained)"
msgstr "I<ru_nswap> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:148
#, no-wrap
msgid "I<ru_inblock> (since Linux 2.6.22)"
msgstr "I<ru_inblock> (Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:151
msgid "The number of times the file system had to perform input."
msgstr "ファイルシステムが入力を実行する必要があった回数。"

#. type: TP
#: build/C/man2/getrusage.2:151
#, no-wrap
msgid "I<ru_oublock> (since Linux 2.6.22)"
msgstr "I<ru_oublock> (Linux 2.6.22 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:154
msgid "The number of times the file system had to perform output."
msgstr "ファイルシステムが出力を実行する必要があった回数。"

#. type: TP
#: build/C/man2/getrusage.2:154
#, no-wrap
msgid "I<ru_msgsnd> (unmaintained)"
msgstr "I<ru_msgsnd> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:160
#, no-wrap
msgid "I<ru_msgrcv> (unmaintained)"
msgstr "I<ru_msgrcv> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:166
#, no-wrap
msgid "I<ru_nsignals> (unmaintained)"
msgstr "I<ru_nsignals> (メンテナンスされていない)"

#. type: TP
#: build/C/man2/getrusage.2:170
#, no-wrap
msgid "I<ru_nvcsw> (since Linux 2.6)"
msgstr "I<ru_nvcsw> (Linux 2.6 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:175
msgid ""
"The number of times a context switch resulted due to a process voluntarily "
"giving up the processor before its time slice was completed (usually to "
"await availability of a resource)."
msgstr ""
"自分のタイムスライスが完了する前にプロセスが自発的にプロセッサを解放して行わ"
"れたコンテキストスイッチの回数 (通常はリソースが利用可能になるのを待つために"
"行われる)。"

#. type: TP
#: build/C/man2/getrusage.2:175
#, no-wrap
msgid "I<ru_nivcsw> (since Linux 2.6)"
msgstr "I<memory_migrate> (Linux 2.6.16 以降)"

#. type: Plain text
#: build/C/man2/getrusage.2:180
msgid ""
"The number of times a context switch resulted due to a higher priority "
"process becoming runnable or because the current process exceeded its time "
"slice."
msgstr ""
"優先度が自分より高いプロセッサが実行可能になったか、現在のプロセスが自分のタ"
"イムスライスを超過したことにより行われたコンテキストスイッチの回数。"

#. type: Plain text
#: build/C/man2/getrusage.2:191
msgid "I<usage> points outside the accessible address space."
msgstr "I<usage> がアクセス可能なアドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/getrusage.2:195
msgid "I<who> is invalid."
msgstr "I<who> が無効である。"

#. type: Plain text
#: build/C/man2/getrusage.2:203
msgid ""
"SVr4, 4.3BSD.  POSIX.1-2001 specifies B<getrusage>(), but specifies only the "
"fields I<ru_utime> and I<ru_stime>."
msgstr ""
"SVr4, 4.3BSD.  POSIX.1-2001 は B<getrusage>()  を規定しているが、規定している"
"フィールドは I<ru_utime> と I<ru_stime> だけである。"

#. type: Plain text
#: build/C/man2/getrusage.2:206
msgid "B<RUSAGE_THREAD> is Linux-specific."
msgstr "B<RUSAGE_THREAD> は Linux 固有である。"

#. type: Plain text
#: build/C/man2/getrusage.2:209
msgid "Resource usage metrics are preserved across an B<execve>(2)."
msgstr "B<execve>(2)  の前後でリソース使用量の指標は保持される。"

#. type: Plain text
#: build/C/man2/getrusage.2:217
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<struct timeval> is defined in I<E<lt>sys/time."
"hE<gt>>.)"
msgstr ""
"今日では I<E<lt>sys/time.hE<gt>> をインクルードする必要はないが、 インクルー"
"ドしておけば移植性が増す。 (実際 I<struct timeval> は I<E<lt>sys/time."
"hE<gt>> で定義されている。)"

#.  See the description of getrusage() in XSH.
#.  A similar statement was also in SUSv2.
#. type: Plain text
#: build/C/man2/getrusage.2:229
msgid ""
"In Linux kernel versions before 2.6.9, if the disposition of B<SIGCHLD> is "
"set to B<SIG_IGN> then the resource usages of child processes are "
"automatically included in the value returned by B<RUSAGE_CHILDREN>, although "
"POSIX.1-2001 explicitly prohibits this.  This nonconformance is rectified in "
"Linux 2.6.9 and later."
msgstr ""
"2.6.9 より前のバージョンの Linux カーネルでは、 B<SIGCHLD> の処理が "
"B<SIG_IGN> に設定されていると、 子プロセスのリソース使用量が "
"B<RUSAGE_CHILDREN> で返される値に自動的に含められる。 しかし POSIX.1-2001 で"
"は、これを明確に禁止している。 この準拠していなかった点は、Linux 2.6.9 以降で"
"改正された。"

#. type: Plain text
#: build/C/man2/getrusage.2:232
msgid ""
"The structure definition shown at the start of this page was taken from "
"4.3BSD Reno."
msgstr "このページの最初で示した構造体の定義は 4.3BSD Reno のものである。"

#. type: Plain text
#: build/C/man2/getrusage.2:241
msgid ""
"Ancient systems provided a B<vtimes>()  function with a similar purpose to "
"B<getrusage>().  For backward compatibility, glibc also provides B<vtimes>"
"().  All new applications should be written using B<getrusage>()."
msgstr ""
"古いシステムでは、 B<getrusage>() と同様の目的を持つ関数 B<vtimes>() が提供\n"
"されていた。後方互換性のため、glibc でも B<vtimes>() を提供している。\n"
"全ての新しいアプリケーションでは B<getrusage>() を使用すべきである。"

#. type: Plain text
#: build/C/man2/getrusage.2:246
msgid "See also the description of I</proc/PID/stat> in B<proc>(5)."
msgstr "B<proc>(5)  にある I</proc/PID/stat> の説明も参照のこと。"

#. type: Plain text
#: build/C/man2/getrusage.2:253
msgid ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"
msgstr ""
"B<clock_gettime>(2), B<getrlimit>(2), B<times>(2), B<wait>(2), B<wait4>(2), "
"B<clock>(3)"

#. type: TH
#: build/C/man2/getsid.2:26
#, no-wrap
msgid "GETSID"
msgstr "GETSID"

#. type: Plain text
#: build/C/man2/getsid.2:29
msgid "getsid - get session ID"
msgstr "getsid - セッション ID を取得する。"

#. type: Plain text
#: build/C/man2/getsid.2:33
msgid "B<pid_t getsid(pid_t>I< pid>B<);>"
msgstr "B<pid_t getsid(pid_t>I< pid>B<);>"

#. type: Plain text
#: build/C/man2/getsid.2:42
msgid "B<getsid>():"
msgstr "B<getsid>():"

#. type: Plain text
#: build/C/man2/getsid.2:45 build/C/man2/setpgid.2:79
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/getsid.2:47 build/C/man2/setpgid.2:81
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: build/C/man2/getsid.2:58
msgid ""
"I<getsid(0)> returns the session ID of the calling process.  I<getsid(p)> "
"returns the session ID of the process with process ID I<p>.  (The session ID "
"of a process is the process group ID of the session leader.)"
msgstr ""
"I<getsid(0)> は呼び出し元のプロセスのセッション ID を返す。 I<getsid(p)> はプ"
"ロセス ID I<p> を持つプロセスのセッション ID を返す (プロセスのセッション ID "
"は セッションリーダーのプロセスグループ ID である)。"

#. type: Plain text
#: build/C/man2/getsid.2:63
msgid ""
"On success, a session ID is returned.  On error, I<(pid_t)\\ -1> will be "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功すると、セッション ID が返される。 エラーの場合、I<(pid_t) -1> が返さ"
"れ、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/getsid.2:70
msgid ""
"A process with process ID I<p> exists, but it is not in the same session as "
"the calling process, and the implementation considers this an error."
msgstr ""
"プロセス ID I<p> のプロセスは存在するが、呼び出し元のプロセスと同じセッション"
"ではなく、 さらに実装がこの状態をエラーと判断した場合。"

#. type: Plain text
#: build/C/man2/getsid.2:75
msgid "No process with process ID I<p> was found."
msgstr "プロセス ID が I<p> のプロセスがない。"

#.  Linux has this system call since Linux 1.3.44.
#.  There is libc support since libc 5.2.19.
#. type: Plain text
#: build/C/man2/getsid.2:79
msgid "This system call is available on Linux since version 2.0."
msgstr "このシステムコールは Linux バージョン 2.0 以降で利用可能である。"

#. type: Plain text
#: build/C/man2/getsid.2:81 build/C/man2/setgid.2:68 build/C/man2/setsid.2:67
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/getsid.2:84
msgid "Linux does not return B<EPERM>."
msgstr "Linux は B<EPERM> を返さない。"

#. type: Plain text
#: build/C/man2/getsid.2:88
msgid "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"
msgstr "B<getpgid>(2), B<setsid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/getuid.2:26
#, no-wrap
msgid "GETUID"
msgstr "GETUID"

#. type: Plain text
#: build/C/man2/getuid.2:29
msgid "getuid, geteuid - get user identity"
msgstr "getuid, geteuid - ユーザー ID を得る"

#. type: Plain text
#: build/C/man2/getuid.2:35
msgid "B<uid_t getuid(void);>"
msgstr "B<uid_t getuid(void);>"

#. type: Plain text
#: build/C/man2/getuid.2:37
msgid "B<uid_t geteuid(void);>"
msgstr "B<uid_t geteuid(void);>"

#. type: Plain text
#: build/C/man2/getuid.2:40
msgid "B<getuid>()  returns the real user ID of the calling process."
msgstr "B<getuid>()  は呼び出し元のプロセスの実ユーザー ID を返す。"

#. type: Plain text
#: build/C/man2/getuid.2:43
msgid "B<geteuid>()  returns the effective user ID of the calling process."
msgstr "B<geteuid>()  は呼び出し元のプロセスの実効ユーザー ID を返す。"

#. type: SS
#: build/C/man2/getuid.2:48
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man2/getuid.2:57
msgid ""
"In UNIX V6 the B<getuid>()  call returned I<(euid E<lt>E<lt> 8) + uid>.  "
"UNIX V7 introduced separate calls B<getuid>()  and B<geteuid>()."
msgstr ""
"UNIX V6 では B<getuid>()  コールは I<(euid E<lt>E<lt> 8) + uid> を返してい"
"た。 UNIX V7 では B<getuid>()  と B<geteuid>()  という別々のコールが導入され"
"た。"

#. type: Plain text
#: build/C/man2/getuid.2:73
msgid ""
"The original Linux B<getuid>()  and B<geteuid>()  system calls supported "
"only 16-bit user IDs.  Subsequently, Linux 2.4 added B<getuid32>()  and "
"B<geteuid32>(), supporting 32-bit IDs.  The glibc B<getuid>()  and B<geteuid>"
"()  wrapper functions transparently deal with the variations across kernel "
"versions."
msgstr ""
"元々の Linux の B<getuid>() と B<geteuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<getuid32>() と B<geteuid32>() が追加された。\n"
"glibc の B<getuid>() と B<geteuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/getuid.2:78
msgid "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"
msgstr "B<getresuid>(2), B<setreuid>(2), B<setuid>(2), B<credentials>(7)"

#. type: TH
#: build/C/man2/iopl.2:33
#, no-wrap
msgid "IOPL"
msgstr "IOPL"

#. type: TH
#: build/C/man2/iopl.2:33
#, no-wrap
msgid "2013-03-15"
msgstr "2013-03-15"

#. type: Plain text
#: build/C/man2/iopl.2:36
msgid "iopl - change I/O privilege level"
msgstr "iopl - I/O 特権レベルを変更する"

#. type: Plain text
#: build/C/man2/iopl.2:38
msgid "B<#include E<lt>sys/io.hE<gt>>"
msgstr "B<#include E<lt>sys/io.hE<gt>>"

#. type: Plain text
#: build/C/man2/iopl.2:40
msgid "B<int iopl(int >I<level>B<);>"
msgstr "B<int iopl(int >I<level>B<);>"

#. type: Plain text
#: build/C/man2/iopl.2:45
msgid ""
"B<iopl>()  changes the I/O privilege level of the calling process, as "
"specified by the two least significant bits in I<level>."
msgstr ""
"B<iopl>()  は呼び出し元のプロセスの I/O 特権レベルを I<level> の下位 2 ビット"
"で指定した値に変更する。"

#. type: Plain text
#: build/C/man2/iopl.2:51
msgid ""
"This call is necessary to allow 8514-compatible X servers to run under "
"Linux.  Since these X servers require access to all 65536 I/O ports, the "
"B<ioperm>(2)  call is not sufficient."
msgstr ""
"この関数は 8514 互換の X サーバを Linux で動作させるために必要である。 なぜな"
"らこの X サーバは 65536 個の I/O ポート全てへのアクセスを要求するので "
"B<ioperm>(2)  関数では不十分だからである。"

#. type: Plain text
#: build/C/man2/iopl.2:55
msgid ""
"In addition to granting unrestricted I/O port access, running at a higher I/"
"O privilege level also allows the process to disable interrupts.  This will "
"probably crash the system, and is not recommended."
msgstr ""
"より高い I/O 特権レベルでの動作をさせることによって I/O ポートアクセスの制限"
"を解除することに加えて、プロセスが割り込みを 無効にすることもできるようにな"
"る。この機能は時としてシステムの破壊を もたらすので勧められない。"

#. type: Plain text
#: build/C/man2/iopl.2:60
msgid "Permissions are inherited by B<fork>(2)  and B<execve>(2)."
msgstr "B<fork>(2)  や B<exec>(2)  を行った場合、特権は継承される。"

#. type: Plain text
#: build/C/man2/iopl.2:62
msgid "The I/O privilege level for a normal process is 0."
msgstr "通常のプロセスの I/O 特権レベルは 0 である。"

#. type: Plain text
#: build/C/man2/iopl.2:66
msgid ""
"This call is mostly for the i386 architecture.  On many other architectures "
"it does not exist or will always return an error."
msgstr ""
"このシステムコールはほとんど i386 アーキテクチャのためだけのものである。 その"
"他の多くのアーキテクチャでは存在しないか、常にエラーを返す。"

#. type: Plain text
#: build/C/man2/iopl.2:76
msgid "I<level> is greater than 3."
msgstr "引き数 I<level> が 3 より大きい。"

#. type: Plain text
#: build/C/man2/iopl.2:79
msgid "This call is unimplemented."
msgstr "このシステムコールは実装されていない。"

#. type: Plain text
#: build/C/man2/iopl.2:87
msgid ""
"The calling process has insufficient privilege to call B<iopl>(); the "
"B<CAP_SYS_RAWIO> capability is required to raise the I/O privilege level "
"above its current value."
msgstr ""
"呼び出し元プロセスに B<iopl>()  を呼び出すのに十分な権限がなかった。 I/O 特権"
"レベルを現在の値より上げるには B<CAP_SYS_RAWIO> ケーパビリティが必要である。"

#. type: Plain text
#: build/C/man2/iopl.2:91
msgid ""
"B<iopl>()  is Linux-specific and should not be used in programs that are "
"intended to be portable."
msgstr ""
"B<ipc>()  は Linux 特有であり、 移植を意図したプログラムでは 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/iopl.2:100
msgid ""
"Libc5 treats it as a system call and has a prototype in I<E<lt>unistd."
"hE<gt>>.  Glibc1 does not have a prototype.  Glibc2 has a prototype both in "
"I<E<lt>sys/io.hE<gt>> and in I<E<lt>sys/perm.hE<gt>>.  Avoid the latter, it "
"is available on i386 only."
msgstr ""
"libc5 ではシステムコールとして扱い I<E<lt>unistd.hE<gt>> にプロトタイプが存在"
"している。 glibc1 にはプロトタイプは存在していない。 glibc2 は I<E<lt>sys/io."
"hE<gt>> と I<E<lt>sys/perm.hE<gt>> の両方にプロトタイプを持っている。 後者は "
"i386 のみで利用可能なので、使用すべきではない。"

#. type: Plain text
#: build/C/man2/iopl.2:104
msgid "B<ioperm>(2), B<outb>(2), B<capabilities>(7)"
msgstr "B<ioperm>(2), B<outb>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man2/ioprio_set.2:24
#, no-wrap
msgid "IOPRIO_SET"
msgstr "IOPRIO_SET"

#. type: Plain text
#: build/C/man2/ioprio_set.2:27
msgid "ioprio_get, ioprio_set - get/set I/O scheduling class and priority"
msgstr "ioprio_get, ioprio_set - I/O スケジューリングクラスと優先度の設定/取得"

#. type: Plain text
#: build/C/man2/ioprio_set.2:31
#, no-wrap
msgid ""
"B<int ioprio_get(int >I<which>B<, int >I<who>B<);>\n"
"B<int ioprio_set(int >I<which>B<, int >I<who>B<, int >I<ioprio>B<);>\n"
msgstr ""
"B<int ioprio_get(int >I<which>B<, int >I<who>B<);>\n"
"B<int ioprio_set(int >I<which>B<, int >I<who>B<, int >I<ioprio>B<);>\n"

#. type: Plain text
#: build/C/man2/ioprio_set.2:35
msgid "I<Note>: There are no glibc wrappers for these system calls; see NOTES."
msgstr ""
"I<注意>: これらのシステムコールには glibc ラッパー関数は存在しない。 「注意」"
"の節を参照。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:42
msgid ""
"The B<ioprio_get>()  and B<ioprio_set>()  system calls respectively get and "
"set the I/O scheduling class and priority of one or more threads."
msgstr ""
"システムコール B<ioprio_get>()  / B<ioprio_set>()  は、(1つ以上の) スレッド"
"の I/O スケジューリングクラスと 優先度の取得/設定を行う。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:54
msgid ""
"The I<which> and I<who> arguments identify the thread(s) on which the system "
"calls operate.  The I<which> argument determines how I<who> is interpreted, "
"and has one of the following values:"
msgstr ""
"I<which> と I<who> 引き数でシステムコールの操作対象となるスレッドを指示す"
"る。 I<which> 引き数は、 I<who> をどのように解釈するかを決めるもので、以下の"
"いずれか一つを指定する。"

#. type: TP
#: build/C/man2/ioprio_set.2:54
#, no-wrap
msgid "B<IOPRIO_WHO_PROCESS>"
msgstr "B<IOPRIO_WHO_PROCESS>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:61
msgid ""
"I<who> is a process ID or thread ID identifying a single process or thread.  "
"If I<who> is 0, then operate on the calling thread."
msgstr ""
"I<who> は特定のプロセスやスレッドを特定するためのプロセス ID かスレッド ID で"
"ある。 I<who> が 0 の場合、呼び出し元のスレッドに対して操作が行われる。"

#. type: TP
#: build/C/man2/ioprio_set.2:61
#, no-wrap
msgid "B<IOPRIO_WHO_PGRP>"
msgstr "B<IOPRIO_WHO_PGRP>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:68
msgid ""
"I<who> is a process group ID identifying all the members of a process "
"group.  If I<who> is 0, then operate on the process group of which the "
"caller is a member."
msgstr ""
"I<who> はプロセスグループ ID であり、プロセスグループの全メンバが対象とな"
"る。 I<who> が 0 の場合、 呼び出し元がメンバーとなっているプロセスグループに"
"対して操作が行われる。"

#. type: TP
#: build/C/man2/ioprio_set.2:68
#, no-wrap
msgid "B<IOPRIO_WHO_USER>"
msgstr "B<IOPRIO_WHO_USER>"

#.  FIXME who==0 needs to be documented,
#.  See http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=652443
#. type: Plain text
#: build/C/man2/ioprio_set.2:75
msgid ""
"I<who> is a user ID identifying all of the processes that have a matching "
"real UID."
msgstr "I<who> はユーザID であり、実 UID に一致する全プロセスが対象となる。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:98
msgid ""
"If I<which> is specified as B<IOPRIO_WHO_PGRP> or B<IOPRIO_WHO_USER> when "
"calling B<ioprio_get>(), and more than one process matches I<who>, then the "
"returned priority will be the highest one found among all of the matching "
"processes.  One priority is said to be higher than another one if it belongs "
"to a higher priority class (B<IOPRIO_CLASS_RT> is the highest priority "
"class; B<IOPRIO_CLASS_IDLE> is the lowest)  or if it belongs to the same "
"priority class as the other process but has a higher priority level (a lower "
"priority number means a higher priority level)."
msgstr ""
"B<ioprio_get>()  の呼び出し時に I<which> に B<IOPRIO_WHO_PGRP> か "
"B<IOPRIO_WHO_USER> が指定され、 I<who> に一致するプロセスが複数あった場合、 "
"一致するプロセス全体の中で最も高い優先度が返される。 優先度が高いとは、より高"
"い優先度クラスに属している (B<IOPRIO_CLASS_RT> が最も高い優先度クラスで、 "
"B<IOPRIO_CLASS_IDLE> が最も低い)、もしくは 同じ優先度クラスに属しているが優先"
"度レベルが高い (優先度番号が小さい方が優先度レベルが高いことを意味する)、 と"
"いうことである。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:108
msgid ""
"The I<ioprio> argument given to B<ioprio_set>()  is a bit mask that "
"specifies both the scheduling class and the priority to be assigned to the "
"target process(es).  The following macros are used for assembling and "
"dissecting I<ioprio> values:"
msgstr ""
"B<ioprio_set>()  に渡す I<ioprio> 引き数は、対象となるプロセスに割り当てるス"
"ケジューリングクラスと 優先度の両方を指定するビットマスクである。 I<ioprio> "
"の値を組み立てたり解釈するのに、以下のマクロが利用できる。"

#. type: TP
#: build/C/man2/ioprio_set.2:108
#, no-wrap
msgid "B<IOPRIO_PRIO_VALUE(>I<class>B<, >I<data>B<)>"
msgstr "B<IOPRIO_PRIO_VALUE(>I<class>B<, >I<data>B<)>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:117
msgid ""
"Given a scheduling I<class> and priority (I<data>), this macro combines the "
"two values to produce an I<ioprio> value, which is returned as the result of "
"the macro."
msgstr ""
"スケジューリングクラス I<class> と優先度 (I<data>)  を与えると、このマクロは "
"2つの値を組み合わせて、 I<ioprio> 値を生成し、マクロの結果として返す。"

#. type: TP
#: build/C/man2/ioprio_set.2:117
#, no-wrap
msgid "B<IOPRIO_PRIO_CLASS(>I<mask>B<)>"
msgstr "B<IOPRIO_PRIO_CLASS(>I<mask>B<)>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:129
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its I/O class "
"component, that is, one of the values B<IOPRIO_CLASS_RT>, "
"B<IOPRIO_CLASS_BE>, or B<IOPRIO_CLASS_IDLE>."
msgstr ""
"I<mask> (I<ioprio> 値) を与えると、このマクロは I/O クラス要素、つまり "
"B<IOPRIO_CLASS_RT>, B<IOPRIO_CLASS_BE>, B<IOPRIO_CLASS_IDLE> のいずれか一つの"
"値を返す。"

#. type: TP
#: build/C/man2/ioprio_set.2:129
#, no-wrap
msgid "B<IOPRIO_PRIO_DATA(>I<mask>B<)>"
msgstr "B<IOPRIO_PRIO_DATA(>I<mask>B<)>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:138
msgid ""
"Given I<mask> (an I<ioprio> value), this macro returns its priority "
"(I<data>)  component."
msgstr ""
"I<mask> (I<ioprio> 値) を与えると、このマクロは優先度 (I<data>)  要素を返す。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:141
msgid ""
"See the NOTES section for more information on scheduling classes and "
"priorities."
msgstr ""
"スケジューリングクラスと優先度に関する詳しい情報は、 「備考」の節を参照のこ"
"と。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:149
msgid ""
"I/O priorities are supported for reads and for synchronous (B<O_DIRECT>, "
"B<O_SYNC>)  writes.  I/O priorities are not supported for asynchronous "
"writes because they are issued outside the context of the program dirtying "
"the memory, and thus program-specific priorities do not apply."
msgstr ""
"I/O 優先度は読み出しと同期書き込み (B<O_DIRECT>, B<O_SYNC>)  に対応してい"
"る。 I/O 優先度は非同期書き込みには対応していない。なぜなら、 非同期書き込み"
"はメモリ書き換えを行うプログラムの動作 (context) とは 関係なく発行され、その"
"ためプログラム単位の優先度は適用されないから である。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:162
msgid ""
"On success, B<ioprio_get>()  returns the I<ioprio> value of the process with "
"highest I/O priority of any of the processes that match the criteria "
"specified in I<which> and I<who>.  On error, -1 is returned, and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<ioprio_get>()  は、 I<which> と I<who> で指定された基準に合致"
"した全プロセスで最も高い I/O 優先度を持つプロセスの I<ioprio> 値を返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:169
msgid ""
"On success, B<ioprio_set>()  returns 0.  On error, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<ioprio_set>()  は 0 を返す。 エラーの場合、-1 を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:179
msgid ""
"Invalid value for I<which> or I<ioprio>.  Refer to the NOTES section for "
"available scheduler classes and priority levels for I<ioprio>."
msgstr ""
"I<which> か I<ioprio> の値が不正である。 I<ioprio> 用に指定可能なスケジューラ"
"クラスと優先度レベルについては 「備考」を参照のこと。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:187
msgid ""
"The calling process does not have the privilege needed to assign this "
"I<ioprio> to the specified process(es).  See the NOTES section for more "
"information on required privileges for B<ioprio_set>()."
msgstr ""
"呼び出し元プロセスが、指定されたプロセスに I<ioprio> を割り当てるのに必要な権"
"限を持っていない。 B<ioprio_set>()  に必要な権限についての詳しい情報は「備"
"考」の節を参照のこと。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:193
msgid ""
"No process(es) could be found that matched the specification in I<which> and "
"I<who>."
msgstr ""
"I<which> と I<who> で指定された基準に合致するプロセスが見つからなかった。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:196
msgid "These system calls have been available on Linux since kernel 2.6.13."
msgstr ""
"これらのシステムコールはカーネル 2.6.13 以降の Linux で利用可能である。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:201
msgid ""
"Glibc does not provide a wrapper for these system calls; call them using "
"B<syscall>(2)."
msgstr ""
"glibc はこれらのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:220
msgid ""
"Two or more processes or threads can share an I/O context.  This will be the "
"case when B<clone>(2)  was called with the B<CLONE_IO> flag.  However, by "
"default, the distinct threads of a process will B<not> share the same I/O "
"context.  This means that if you want to change the I/O priority of all "
"threads in a process, you may need to call B<ioprio_set>()  on each of the "
"threads.  The thread ID that you would need for this operation is the one "
"that is returned by B<gettid>(2)  or B<clone>(2)."
msgstr ""
"複数のプロセスやスレッドが一つの I/O コンテキストを共有する場合がある。 "
"B<clone>(2) を B<CLONE_IO> フラグ付きで呼び出した場合にはこの状況となる。 し"
"かしながら、デフォルトでは、一つのプロセスの個々のスレッドは I/O コンテキスト"
"を共有「しない」。 したがって、 プロセス内のすべてのスレッドの I/O 優先度を変"
"更したい場合には、 それぞれのスレッドに対して B<ioprio_set>() を呼び出す必要"
"がある。 この操作を行うのに必要となるスレッド ID には B<gettid>(2) か "
"B<clone>(2) が返す値を指定する。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:225
msgid ""
"These system calls have an effect only when used in conjunction with an I/O "
"scheduler that supports I/O priorities.  As at kernel 2.6.17 the only such "
"scheduler is the Completely Fair Queuing (CFQ) I/O scheduler."
msgstr ""
"これらのシステムコールは、I/O 優先度に対応した I/O スケジューラと 組み合わせ"
"て使用された場合にのみ効果を持つ。 カーネル 2.6.17 では、この条件を満たすスケ"
"ジューラは Completely Fair Queuing (CFQ) I/O スケジューラだけである。"

#. type: SS
#: build/C/man2/ioprio_set.2:225
#, no-wrap
msgid "Selecting an I/O scheduler"
msgstr "I/O スケジューラの選択"

#. type: Plain text
#: build/C/man2/ioprio_set.2:229
msgid ""
"I/O Schedulers are selected on a per-device basis via the special file I</"
"sys/block/E<lt>deviceE<gt>/queue/scheduler>."
msgstr ""
"I/O スケジューラの選択はデバイス単位に行われ、その選択は スペシャルファイル "
"I</sys/block/E<lt>deviceE<gt>/queue/scheduler> 経由で行われる。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:235
msgid ""
"One can view the current I/O scheduler via the I</sys> file system.  For "
"example, the following command displays a list of all schedulers currently "
"loaded in the kernel:"
msgstr ""
"現在の I/O スケジューラは I</sys> ファイルシステム経由で参照できる。例えば、"
"以下のコマンドを実行すると、 現在カーネルでロードされているスケジューラの全リ"
"ストが表示される。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:240
#, no-wrap
msgid ""
"$B< cat /sys/block/hda/queue/scheduler>\n"
"noop anticipatory deadline [cfq]\n"
msgstr ""
"$B< cat /sys/block/hda/queue/scheduler>\n"
"noop anticipatory deadline [cfq]\n"

#. type: Plain text
#: build/C/man2/ioprio_set.2:254
msgid ""
"The scheduler surrounded by brackets is the one actually in use for the "
"device (I<hda> in the example).  Setting another scheduler is done by "
"writing the name of the new scheduler to this file.  For example, the "
"following command will set the scheduler for the I<hda> device to I<cfq>:"
msgstr ""
"括弧で囲まれたスケジューラがそのデバイス (上の例では I<hda>)  について実際に"
"使用されているスケジューラである。 別のスケジューラを設定するには、このファイ"
"ルに新しいスケジューラ名を 書き込めばよい。例えば、以下のコマンドを実行する"
"と、デバイス I<hda> のスケジューラとして I<cfq> が設定される。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:260
#, no-wrap
msgid ""
"$B< su>\n"
"Password:\n"
"#B< echo cfq E<gt> /sys/block/hda/queue/scheduler>\n"
msgstr ""
"$B< su>\n"
"Password:\n"
"#B< echo cfq E<gt> /sys/block/hda/queue/scheduler>\n"

#. type: SS
#: build/C/man2/ioprio_set.2:262
#, no-wrap
msgid "The Completely Fair Queuing (CFQ) I/O scheduler"
msgstr "Completely Fair Queuing (CFQ) I/O スケジューラ"

#. type: Plain text
#: build/C/man2/ioprio_set.2:268
msgid ""
"Since v3 (aka CFQ Time Sliced) CFQ implements I/O nice levels similar to "
"those of CPU scheduling.  These nice levels are grouped in three scheduling "
"classes each one containing one or more priority levels:"
msgstr ""
"バージョン 3 (別名 CFQ Time Sliced) 以降、 CPU スケジューリングと同様の I/O "
"nice レベルが CFQ に実装されている。 これらの nice レベルは 3つのスケジューリ"
"ングクラスに分類でき、 各スケジューリングクラスにつき 1つ以上の優先度レベルが"
"定義されている。"

#. type: TP
#: build/C/man2/ioprio_set.2:268
#, no-wrap
msgid "B<IOPRIO_CLASS_RT> (1)"
msgstr "B<IOPRIO_CLASS_RT> (1)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:283
msgid ""
"This is the real-time I/O class.  This scheduling class is given higher "
"priority than any other class: processes from this class are given first "
"access to the disk every time.  Thus this I/O class needs to be used with "
"some care: one I/O real-time process can starve the entire system.  Within "
"the real-time class, there are 8 levels of class data (priority) that "
"determine exactly how much time this process needs the disk for on each "
"service.  The highest real-time priority level is 0; the lowest is 7.  In "
"the future this might change to be more directly mappable to performance, by "
"passing in a desired data rate instead."
msgstr ""
"これはリアルタイム I/O クラスである。 このスケジューリングクラスには他のクラ"
"スよりも高い優先度が与えられる。 このクラスのプロセスには、常にディスクへのア"
"クセスが優先して 割り当てられる。そのため、この I/O クラスを使う際には、 たっ"
"た一つの リアルタイム I/O クラスのプロセスにより システム全体のディスクアクセ"
"スができなくなってしまうことがある という点に、注意を払う必要がある。 このク"
"ラスには、8 段階の class data (優先度レベル) がある。 この値は、そのプロセス"
"が 1回のディスクアクセスにどれだけの 時間が必要かを正確に決めるためのものであ"
"る。 最高のリアルタイム優先度レベルは 0 で、最低は 7 である。 将来的には、優"
"先度レベルは、希望するデータレートを渡すなど、 より直接的に性能条件を反映でき"
"るように変更されるかもしれない。"

#. type: TP
#: build/C/man2/ioprio_set.2:283
#, no-wrap
msgid "B<IOPRIO_CLASS_BE> (2)"
msgstr "B<IOPRIO_CLASS_BE> (2)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:296
msgid ""
"This is the best-effort scheduling class, which is the default for any "
"process that hasn't set a specific I/O priority.  The class data (priority) "
"determines how much I/O bandwidth the process will get.  Best-effort "
"priority levels are analogous to CPU nice values (see B<getpriority>(2)).  "
"The priority level determines a priority relative to other processes in the "
"best-effort scheduling class.  Priority levels range from 0 (highest) to 7 "
"(lowest)."
msgstr ""
"これは ベストエフォート・スケジューリングクラスである。 このクラスは、特定の "
"I/O 優先度を設定していないプロセスの デフォルト値である。 class data (優先度"
"レベル) により、そのプロセスがどの程度の I/O 帯域を得られるかが決定される。 "
"ベストエフォート・優先度レベルは、CPU の nice 値 (B<getpriority>(2)  参照) と"
"同様のものである。 優先度レベルは、ベストエフォート・スケジューリングクラスの"
"中で 他のプロセスとの相対的な優先度を決定する。 優先度レベルの値の範囲は 0 "
"(最高) から 7 (最低) である。"

#. type: TP
#: build/C/man2/ioprio_set.2:296
#, no-wrap
msgid "B<IOPRIO_CLASS_IDLE> (3)"
msgstr "B<IOPRIO_CLASS_IDLE> (3)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:305
msgid ""
"This is the idle scheduling class.  Processes running at this level only get "
"I/O time when no-one else needs the disk.  The idle class has no class "
"data.  Attention is required when assigning this priority class to a "
"process, since it may become starved if higher priority processes are "
"constantly accessing the disk."
msgstr ""
"これは idle スケジューリングクラスである。 このレベルで動作するプロセスは他に"
"ディスクアクセスをしようとする プロセスがない場合にのみ I/O 時間を取得する。 "
"idle クラスには class data (優先度) は用意されていない。 プロセスにこの優先度"
"を割り当てる際には注意が必要である。 なぜなら、優先度の高いプロセスが常にディ"
"スクにアクセスしている場合には ディスクにアクセスできなくなる可能性があるから"
"だ。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:309
msgid ""
"Refer to I<Documentation/block/ioprio.txt> for more information on the CFQ I/"
"O Scheduler and an example program."
msgstr ""
"CFQ I/O スケジューラの更なる情報とサンプルプログラムについては "
"I<Documentation/block/ioprio.txt> を参照のこと。"

#. type: SS
#: build/C/man2/ioprio_set.2:309
#, no-wrap
msgid "Required permissions to set I/O priorities"
msgstr "I/O 優先度の設定に必要な許可"

#. type: Plain text
#: build/C/man2/ioprio_set.2:312
msgid ""
"Permission to change a process's priority is granted or denied based on two "
"assertions:"
msgstr ""
"プロセスの優先度を変更する許可が得られるかどうかは 以下の 2つの条件に基いて決"
"定される。"

#. type: TP
#: build/C/man2/ioprio_set.2:312
#, no-wrap
msgid "B<Process ownership>"
msgstr "B<プロセスの所有権>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:320
msgid ""
"An unprivileged process may set only the I/O priority of a process whose "
"real UID matches the real or effective UID of the calling process.  A "
"process which has the B<CAP_SYS_NICE> capability can change the priority of "
"any process."
msgstr ""
"非特権プロセスは、プロセスの実 UID が呼び出し元プロセスの実 UID もしくは 実"
"効 UID と一致するプロセスの I/O 優先度のみを設定できる。 B<CAP_SYS_NICE> ケー"
"パビリティを持つプロセスは、どのプロセスの優先度でも変更できる。"

#. type: TP
#: build/C/man2/ioprio_set.2:320
#, no-wrap
msgid "B<What is the desired priority>"
msgstr "B<どの優先度に設定しようとしているか>"

#. type: Plain text
#: build/C/man2/ioprio_set.2:332
msgid ""
"Attempts to set very high priorities (B<IOPRIO_CLASS_RT>)  require the "
"B<CAP_SYS_ADMIN> capability.  Kernel versions up to 2.6.24 also required "
"B<CAP_SYS_ADMIN> to set a very low priority (B<IOPRIO_CLASS_IDLE>), but "
"since Linux 2.6.25, this is no longer required."
msgstr ""
"非常に高い優先度 (B<IOPRIO_CLASS_RT>)  を設定しようとする場合、 "
"B<CAP_SYS_ADMIN> ケーパビリティが必要である。 カーネル 2.6.24 以前では、非常"
"に低い優先度 (B<IOPRIO_CLASS_IDLE>)  を設定するためにも B<CAP_SYS_ADMIN> ケー"
"パビリティが必要であったが、 Linux 2.6.25 以降ではもはや必要なくなった。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:337
msgid ""
"A call to B<ioprio_set>()  must follow both rules, or the call will fail "
"with the error B<EPERM>."
msgstr ""
"B<ioprio_set>()  はこの両方のルールに従い、条件を満たさない場合、エラー "
"B<EPERM> で失敗する。"

#.  6 May 07: Bug report raised:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=4464
#.  Ulrich Drepper replied that he wasn't going to add these
#.  to glibc.
#. type: Plain text
#: build/C/man2/ioprio_set.2:346
msgid ""
"Glibc does not yet provide a suitable header file defining the function "
"prototypes and macros described on this page.  Suitable definitions can be "
"found in I<linux/ioprio.h>."
msgstr ""
"glibc は、このページに記載された関数プロトタイプやマクロを定義する 適切なヘッ"
"ダファイルをまだ提供していない。 必要な定義については I<linux/ioprio.h> を見"
"ればよい。"

#. type: Plain text
#: build/C/man2/ioprio_set.2:351
msgid "B<ionice>(1), B<getpriority>(2), B<open>(2), B<capabilities>(7)"
msgstr "B<ionice>(1), B<getpriority>(2), B<open>(2), B<capabilities>(7)"

#. type: Plain text
#: build/C/man2/ioprio_set.2:354
msgid "I<Documentation/block/ioprio.txt> in the Linux kernel source tree"
msgstr "Linux カーネルソース内の I<Documentation/block/ioprio.txt>"

#. type: TH
#: build/C/man2/ipc.2:25
#, no-wrap
msgid "IPC"
msgstr "IPC"

#. type: TH
#: build/C/man2/ipc.2:25
#, no-wrap
msgid "2012-10-16"
msgstr "2012-10-16"

#. type: Plain text
#: build/C/man2/ipc.2:28
msgid "ipc - System V IPC system calls"
msgstr "ipc - System V IPC システムコール"

#. type: Plain text
#: build/C/man2/ipc.2:33
#, no-wrap
msgid ""
"B<int ipc(unsigned int >I<call>B<, int >I<first>B<, int >I<second>B<, int >I<third>B<,>\n"
"B<        void *>I<ptr>B<, long >I<fifth>B<);>\n"
msgstr ""
"B<int ipc(unsigned int >I<call>B<, int >I<first>B<, int >I<second>B<, int >I<third>B<,>\n"
"B<        void *>I<ptr>B<, long >I<fifth>B<);>\n"

#. type: Plain text
#: build/C/man2/ipc.2:41
msgid ""
"B<ipc>()  is a common kernel entry point for the System V IPC calls for "
"messages, semaphores, and shared memory.  I<call> determines which IPC "
"function to invoke; the other arguments are passed through to the "
"appropriate call."
msgstr ""
"B<ipc>()  は メッセージ、セマフォー、共有メモリに関する System V IPC コール"
"の 共通のカーネルへのエントリポイントである。 I<call> はどの IPC 関数を呼び出"
"すかを決め； 他の引き数は適切なコールへと渡される。"

#. type: Plain text
#: build/C/man2/ipc.2:45
msgid ""
"User programs should call the appropriate functions by their usual names.  "
"Only standard library implementors and kernel hackers need to know about "
"B<ipc>()."
msgstr ""
"ユーザープログラムは通常の名前で適切な関数を呼び出すべきである。 標準ライブラ"
"リの実装者やカーネルハッカーのみが B<ipc>()  について知る必要がある。"

#. type: Plain text
#: build/C/man2/ipc.2:49
msgid ""
"B<ipc>()  is Linux-specific, and should not be used in programs intended to "
"be portable."
msgstr ""
"B<ipc>()  は Linux 特有であり、 移植を意図したプログラムでは 使用してはいけな"
"い。"

#. type: Plain text
#: build/C/man2/ipc.2:57
msgid ""
"On some architectures\\(emfor example x86-64 and ARM\\(emthere is no B<ipc>"
"()  system call; instead B<msgctl>(2), B<semctl>(2), B<shmctl>(2), and so on "
"really are implemented as separate system calls."
msgstr ""
"いくつかのアーキテクチャ\\(emfor 例えば x86-64 や ARM\\(emでは、システムコー"
"ル B<ipc>()  が存在しない。実際には、その代わりに B<msgctl>(2), B<semctl>"
"(2), B<shmctl>(2)  などが独立したシステムコールとして実装されている。"

#. type: Plain text
#: build/C/man2/ipc.2:70
msgid ""
"B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), "
"B<semget>(2), B<semop>(2), B<semtimedop>(2), B<shmat>(2), B<shmctl>(2), "
"B<shmdt>(2), B<shmget>(2)"
msgstr ""
"B<msgctl>(2), B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), "
"B<semget>(2), B<semop>(2), B<shmat>(2), B<shmctl>(2), B<shmdt>(2), B<shmget>"
"(2)"

#. type: TH
#: build/C/man2/seteuid.2:29
#, no-wrap
msgid "SETEUID"
msgstr "SETEUID"

#. type: TH
#: build/C/man2/seteuid.2:29
#, no-wrap
msgid "2012-07-02"
msgstr "2012-07-02"

#. type: Plain text
#: build/C/man2/seteuid.2:32
msgid "seteuid, setegid - set effective user or group ID"
msgstr "seteuid, setegid - 実効ユーザー ID や 実効グループ ID を設定する"

#. type: Plain text
#: build/C/man2/seteuid.2:38
msgid "B<int seteuid(uid_t >I<euid>B<);>"
msgstr "B<int seteuid(uid_t >I<euid>B<);>"

#. type: Plain text
#: build/C/man2/seteuid.2:40
msgid "B<int setegid(gid_t >I<egid>B<);>"
msgstr "B<int setegid(gid_t >I<egid>B<);>"

#. type: Plain text
#: build/C/man2/seteuid.2:49
msgid "B<seteuid>(), B<setegid>():"
msgstr "B<seteuid>(), B<setegid>():"

#. type: Plain text
#: build/C/man2/seteuid.2:51
msgid ""
"_BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>="
"\\ 600"
msgstr ""
"_BSD_SOURCE || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>="
"\\ 600"

#. type: Plain text
#: build/C/man2/seteuid.2:58
msgid ""
"B<seteuid>()  sets the effective user ID of the calling process.  "
"Unprivileged user processes may only set the effective user ID to the real "
"user ID, the effective user ID or the saved set-user-ID."
msgstr ""
"B<seteuid>()  は呼び出し元のプロセスの実効ユーザー ID を設定する。 非特権ユー"
"ザーのプロセスの場合、実効ユーザー ID に設定できるのは、 実ユーザー ID・実効"
"ユーザー ID・保存 set-user-ID のいずれかだけである。"

#.  When
#.  .I euid
#.  equals \-1, nothing is changed.
#.  (This is an artifact of the implementation in glibc of seteuid()
#.  using setresuid(2).)
#. type: Plain text
#: build/C/man2/seteuid.2:67
msgid ""
"Precisely the same holds for B<setegid>()  with \"group\" instead of \"user"
"\"."
msgstr ""
"B<setegid>()  は「ユーザー」ではなく「グループ」に対して全く同じことを行う。"

#. type: Plain text
#: build/C/man2/seteuid.2:91
msgid ""
"The calling process is not privileged (Linux: does not have the "
"B<CAP_SETUID> capability in the case of B<seteuid>(), or the B<CAP_SETGID> "
"capability in the case of B<setegid>())  and I<euid> (respectively, "
"I<egid>)  is not the real user (group) ID, the effective user (group) ID, or "
"the saved set-user-ID (saved set-group-ID)."
msgstr ""
"呼び出し元のプロセスに特権がなく、 I<euid> (I<egid>)  が実ユーザー (グルー"
"プ) ID、または実効ユーザー (グループ) ID、 保存 set-user-ID (保存 set-group-"
"ID) のいずれでもではない (Linux においては、 B<seteuid>()  では "
"B<CAP_SETUID> ケーパビリティ (capability) が、 B<setegid>()  では "
"B<CAP_SETGID> ケーパビリティがない場合に、特権がないと判断される)。"

#. type: Plain text
#: build/C/man2/seteuid.2:93
msgid "4.3BSD, POSIX.1-2001."
msgstr "4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/seteuid.2:99
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38).  On an arbitrary system "
"one should check B<_POSIX_SAVED_IDS>."
msgstr ""
"実効ユーザー (グループ) ID を保存 set-user-ID (保存 set-group-ID) に 設定でき"
"るのは、Linux 1.1.37 (1.1.38) 以降である。 全てのシステムにおいて "
"B<_POSIX_SAVED_IDS> をチェックすべきである。"

#. type: Plain text
#: build/C/man2/seteuid.2:115
msgid ""
"Under libc4, libc5 and glibc 2.0 B<seteuid(>I<euid>B<)> is equivalent to "
"B<setreuid(-1,>I< euid>B<)> and hence may change the saved set-user-ID.  "
"Under glibc 2.1 and later it is equivalent to B<setresuid(-1,>I< euid>B<, -1)"
"> and hence does not change the saved set-user-ID.  Analogous remarks hold "
"for B<setegid>(), with the difference that the change in implementation from "
"B<setregid(-1,>I< egid>B<)> to B<setresgid(-1,>I< egid>B<, -1)> occurred in "
"glibc 2.2 or 2.3 (dependeing on the hardware architecture)."
msgstr ""
"libc4, libc5, glibc 2.0 では、 B<seteuid(>I<euid>B<)> は B<setreuid(-1,>I< "
"euid>B<)> と等価であり、保存 set-user-ID を変更するかもしれない。 glibc 2.1 "
"では、 B<setresuid(-1,>I< euid>B<, -1)> と等価であり、保存 set-user-ID 変更し"
"ない。 同様のことが B<setegid>() にも言えるが、 glibc 2.2 か 2.3 で、 実装が "
"B<setregid(-1,>I< egid>B<)> から B<setresgid(-1,>I< egid>B<, -1)> へ変更され"
"た点だけが違う (どの glibc バージョンで変更が行われたかは、ハードウェアアーキ"
"テクチャによって異なる)。"

#. type: Plain text
#: build/C/man2/seteuid.2:124
msgid ""
"According to POSIX.1, B<seteuid>()  (B<setegid>())  need not permit I<euid> "
"(I<egid>)  to be the same value as the current effective user (group) ID, "
"and some implementations do not permit this."
msgstr ""
"POSIX.1 では、 B<seteuid>()  (B<setegid>())  で、 I<euid> (I<egid>)  として現"
"在の実効ユーザ (グループ) ID と同じ値を指定可能である 必要はないとされてお"
"り、いくつかの実装では I<euid> (I<egid>)  として現在の実効ユーザ (グループ) "
"ID と同じ値を 指定することができない。"

#. type: Plain text
#: build/C/man2/seteuid.2:131
msgid ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<capabilities>"
"(7), B<credentials>(7)"
msgstr ""
"B<geteuid>(2), B<setresuid>(2), B<setreuid>(2), B<setuid>(2), B<capabilities>"
"(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/setfsgid.2:31
#, no-wrap
msgid "SETFSGID"
msgstr "SETFSGID"

#. type: Plain text
#: build/C/man2/setfsgid.2:34
msgid "setfsgid - set group identity used for file system checks"
msgstr ""
"setfsgid - ファイルシステムのチェックに用いられるグループ ID を設定する"

#. type: Plain text
#: build/C/man2/setfsgid.2:37 build/C/man2/setfsuid.2:37
msgid "B<#include E<lt>unistd.hE<gt>> /* glibc uses E<lt>sys/fsuid.hE<gt> */"
msgstr "B<#include E<lt>unistd.hE<gt>> /* glibc では E<lt>sys/fsuid.hE<gt> */"

#. type: Plain text
#: build/C/man2/setfsgid.2:39
msgid "B<int setfsgid(uid_t >I<fsgid>B<);>"
msgstr "B<int setfsgid(uid_t >I<fsgid>B<);>"

#. type: Plain text
#: build/C/man2/setfsgid.2:51
msgid ""
"The system call B<setfsgid>()  sets the group ID that the Linux kernel uses "
"to check for all accesses to the file system.  Normally, the value of "
"I<fsgid> will shadow the value of the effective group ID.  In fact, whenever "
"the effective group ID is changed, I<fsgid> will also be changed to the new "
"value of the effective group ID."
msgstr ""
"システムコール B<setfsgid>()  は Linux カーネルがファイルシステムに対する 全"
"てのアクセスのチェックに使用するグループ IDを設定する。通常は I<fsgid> の値は"
"実効 (effective) グループID と同じになる。実際、 実効グループ ID が変更される"
"度に I<fsgid> もまた新しい実効グループID の値に変更される。"

#. type: Plain text
#: build/C/man2/setfsgid.2:62
msgid ""
"Explicit calls to B<setfsuid>(2)  and B<setfsgid>()  are usually used only "
"by programs such as the Linux NFS server that need to change what user and "
"group ID is used for file access without a corresponding change in the real "
"and effective user and group IDs.  A change in the normal user IDs for a "
"program such as the NFS server is a security hole that can expose it to "
"unwanted signals.  (But see below.)"
msgstr ""
"通常、 B<setfsuid>()  や B<setfsgid>() を明示的に呼び出すのは、Linux NFS サー"
"バー のように、 ファイルアクセスに用いるユーザID / グループID を変更しなけれ"
"ばならないが、 対応する実(real)/実効(effective) ユーザID / グループID は変更"
"したくないような プログラムに限られる。 NFS サーバーのようなプログラムで、通"
"常のユーザID を変更すると、 プロセスを望まないシグナルにさらす可能性があり、 "
"セキュリティホールになる。(下記参照)"

#. type: Plain text
#: build/C/man2/setfsgid.2:69
msgid ""
"B<setfsgid>()  will succeed only if the caller is the superuser or if "
"I<fsgid> matches either the real group ID, effective group ID, saved set-"
"group-ID, or the current value of I<fsgid>."
msgstr ""
"B<setfsgid>()  は、スーパーユーザによって呼び出された場合か、 I<fsgid> が実グ"
"ループID、実効グループID、 保存セットグループID (saved set-group-ID)、現在の "
"I<fsgid> の値のいずれかに一致する場合にのみ成功する。"

#. type: Plain text
#: build/C/man2/setfsgid.2:76
msgid ""
"On success, the previous value of I<fsgid> is returned.  On error, the "
"current value of I<fsgid> is returned."
msgstr ""
"成功した場合、 I<fsgid> の以前の値を返す。エラーの場合は I<fsgid> の現在の値"
"を返す。"

#.  This system call is present since Linux 1.1.44
#.  and in libc since libc 4.7.6.
#. type: Plain text
#: build/C/man2/setfsgid.2:80 build/C/man2/setfsuid.2:80
msgid "This system call is present in Linux since version 1.2."
msgstr "このシステムコールはバージョン 1.2 以降の Linux に存在する。"

#. type: Plain text
#: build/C/man2/setfsgid.2:84
msgid ""
"B<setfsgid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<setfsgid>()  は Linux 特有であり、移植を想定したプログラムで使用してはいけ"
"ない。"

#. type: Plain text
#: build/C/man2/setfsgid.2:90
msgid ""
"When glibc determines that the argument is not a valid group ID, it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""
"glibc が引き数がグループID として不正だと判断した場合は、 システムコールを行"
"わず I<errno> に B<EINVAL> を設定して -1 が返される。"

#. type: Plain text
#: build/C/man2/setfsgid.2:94 build/C/man2/setfsuid.2:94
msgid ""
"Note that at the time this system call was introduced, a process could send "
"a signal to a process with the same effective user ID.  Today signal "
"permission handling is slightly different."
msgstr ""
"このシステムコールが導入された当時、プロセスは 同じ実効ユーザIDのプロセスへシ"
"グナルを送ることができた。 今日では、シグナル送信権限の扱いはかなり違うものに"
"なっている。"

#. type: Plain text
#: build/C/man2/setfsgid.2:104
msgid ""
"The original Linux B<setfsgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setfsgid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"元々の Linux の B<setfsgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setfsgid32>() が追加された。\n"
"glibc の B<setfsgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setfsgid.2:112
msgid ""
"No error messages of any kind are returned to the caller.  At the very "
"least, B<EPERM> should be returned when the call fails (because the caller "
"lacks the B<CAP_SETGID> capability)."
msgstr ""
"いかなる種類のエラーメッセージも返さない。 失敗した場合は (呼び出し元には "
"B<CAP_SETGID> ケーパビリティがなかったのだから) 最低でも B<EPERM> くらいは返"
"すべきである。"

#. type: Plain text
#: build/C/man2/setfsgid.2:117
msgid "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/setfsuid.2:31
#, no-wrap
msgid "SETFSUID"
msgstr "SETFSUID"

#. type: Plain text
#: build/C/man2/setfsuid.2:34
msgid "setfsuid - set user identity used for file system checks"
msgstr "setfsuid - ファイルシステムのチェックに用いられるユーザ ID を設定する"

#. type: Plain text
#: build/C/man2/setfsuid.2:39
msgid "B<int setfsuid(uid_t >I<fsuid>B<);>"
msgstr "B<int setfsuid(uid_t >I<fsuid>B<);>"

#. type: Plain text
#: build/C/man2/setfsuid.2:51
msgid ""
"The system call B<setfsuid>()  sets the user ID that the Linux kernel uses "
"to check for all accesses to the file system.  Normally, the value of "
"I<fsuid> will shadow the value of the effective user ID.  In fact, whenever "
"the effective user ID is changed, I<fsuid> will also be changed to the new "
"value of the effective user ID."
msgstr ""
"B<setfsuid>()  は Linux カーネルがファイルシステムに対する 全てのアクセスの"
"チェックに使用するユーザID を設定する。通常は I<fsuid> の値は実効 "
"(effective) ユーザID と同じになる。実際、 実効ユーザID が変更される度に "
"I<fsuid> もまた新しい実効ユーザID の値に変更される。"

#. type: Plain text
#: build/C/man2/setfsuid.2:62
msgid ""
"Explicit calls to B<setfsuid>()  and B<setfsgid>(2)  are usually used only "
"by programs such as the Linux NFS server that need to change what user and "
"group ID is used for file access without a corresponding change in the real "
"and effective user and group IDs.  A change in the normal user IDs for a "
"program such as the NFS server is a security hole that can expose it to "
"unwanted signals.  (But see below.)"
msgstr ""
"通常、 B<setfsuid>()  や B<setfsgid>() を明示的に呼び出すのは、Linux NFS サー"
"バー のように、 ファイルアクセスに用いるユーザID / グループID を変更しなけれ"
"ばならないが、 対応する実(real)/実効(effective) ユーザID / グループID は変更"
"したくないような プログラムに限られる。 NFS サーバーのようなプログラムで、通"
"常のユーザID を変更すると、 プロセスを望まないシグナルにさらす可能性があり、 "
"セキュリティホールになる。(下記参照)"

#. type: Plain text
#: build/C/man2/setfsuid.2:69
msgid ""
"B<setfsuid>()  will succeed only if the caller is the superuser or if "
"I<fsuid> matches either the real user ID, effective user ID, saved set-user-"
"ID, or the current value of I<fsuid>."
msgstr ""
"B<setfsuid>()  は、スーパーユーザによって呼び出された場合か、 I<fsuid> が実"
"ユーザID、実効ユーザID、 保存セットユーザID (saved set-user-ID)、現在の "
"I<fsuid> の値のいずれかに一致する場合にのみ成功する。"

#. type: Plain text
#: build/C/man2/setfsuid.2:76
msgid ""
"On success, the previous value of I<fsuid> is returned.  On error, the "
"current value of I<fsuid> is returned."
msgstr ""
"成功した場合、 I<fsuid> の以前の値を返す。エラーの場合は I<fsuid> の現在の値"
"を返す。"

#. type: Plain text
#: build/C/man2/setfsuid.2:84
msgid ""
"B<setfsuid>()  is Linux-specific and should not be used in programs intended "
"to be portable."
msgstr ""
"B<setfsuid>()  は Linux 特有であり、移植を想定したプログラムで使用してはいけ"
"ない。"

#. type: Plain text
#: build/C/man2/setfsuid.2:90
msgid ""
"When glibc determines that the argument is not a valid user ID, it will "
"return -1 and set I<errno> to B<EINVAL> without attempting the system call."
msgstr ""
"glibc が引き数がユーザID として不正だと判断した場合は、 システムコールを行わ"
"ず I<errno> に B<EINVAL> を設定して -1 が返される。"

#. type: Plain text
#: build/C/man2/setfsuid.2:104
msgid ""
"The original Linux B<setfsuid>()  system call supported only 16-bit user "
"IDs.  Subsequently, Linux 2.4 added B<setfsuid32>()  supporting 32-bit IDs.  "
"The glibc B<setfsuid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"元々の Linux の B<setfsuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setfsuid32>() が追加された。\n"
"glibc の B<setfsuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setfsuid.2:112
msgid ""
"No error messages of any kind are returned to the caller.  At the very "
"least, B<EPERM> should be returned when the call fails (because the caller "
"lacks the B<CAP_SETUID> capability)."
msgstr ""
"いかなる種類のエラーメッセージも呼び出し元に返さない。 失敗した場合は (呼び出"
"し元には B<CAP_SETUID> ケーパビリティがなかったのだから) 最低でも B<EPERM> く"
"らいは返すべきである。"

#. type: Plain text
#: build/C/man2/setfsuid.2:117
msgid "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr "B<kill>(2), B<setfsgid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/setgid.2:29
#, no-wrap
msgid "SETGID"
msgstr "SETGID"

#. type: Plain text
#: build/C/man2/setgid.2:32
msgid "setgid - set group identity"
msgstr "setgid - グループ識別(identity)を設定する"

#. type: Plain text
#: build/C/man2/setgid.2:38
msgid "B<int setgid(gid_t >I<gid>B<);>"
msgstr "B<int setgid(gid_t >I<gid>B<);>"

#. type: Plain text
#: build/C/man2/setgid.2:43
msgid ""
"B<setgid>()  sets the effective group ID of the calling process.  If the "
"caller is the superuser, the real GID and saved set-group-ID are also set."
msgstr ""
"B<setgid>()  は呼び出し元のプロセスの実効 (effective) グループID を設定す"
"る。 もしスーパーユーザーによって呼び出された場合は、 実 (real) グループID と"
"保存 (saved) set-group-ID も設定される。"

#. type: Plain text
#: build/C/man2/setgid.2:53
msgid ""
"Under Linux, B<setgid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-group-ID program that is not "
"set-user-ID-root to drop all of its group privileges, do some un-privileged "
"work, and then reengage the original effective group ID in a secure manner."
msgstr ""
"Linux において、 B<setgid>()  は B<_POSIX_SAVED_IDS> をもった POSIX 版のよう"
"に実装されている。 これは set-user-ID-root でない set-group-ID プログラムにそ"
"のグループの 特権の全て落とし、特権の必要ない仕事をし、本来の実効グループID "
"に 安全な方法で再び戻すことを許す。"

#. type: Plain text
#: build/C/man2/setgid.2:66
msgid ""
"The calling process is not privileged (does not have the B<CAP_SETGID> "
"capability), and I<gid> does not match the real group ID or saved set-group-"
"ID of the calling process."
msgstr ""
"呼び出し元のプロセスに権限がなく (B<CAP_SETGID> ケーパビリティがなく)、かつ "
"I<gid> が呼び出し元のプロセスの実グループID と保存セットグループID のどちらと"
"も一致しない。"

#. type: Plain text
#: build/C/man2/setgid.2:78
msgid ""
"The original Linux B<setgid>()  system call supported only 16-bit group "
"IDs.  Subsequently, Linux 2.4 added B<setgid32>()  supporting 32-bit IDs.  "
"The glibc B<setgid>()  wrapper function transparently deals with the "
"variation across kernel versions."
msgstr ""
"元々の Linux の B<setgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setgid32>() が追加された。\n"
"glibc の B<setgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setgid.2:84
msgid ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7)"
msgstr ""
"B<getgid>(2), B<setegid>(2), B<setregid>(2), B<capabilities>(7), "
"B<credentials>(7)"

#. type: TH
#: build/C/man2/setpgid.2:48
#, no-wrap
msgid "SETPGID"
msgstr "SETPGID"

#. type: TH
#: build/C/man2/setpgid.2:48
#, fuzzy, no-wrap
#| msgid "2013-04-17"
msgid "2013-07-31"
msgstr "2013-04-17"

#. type: Plain text
#: build/C/man2/setpgid.2:51
msgid "setpgid, getpgid, setpgrp, getpgrp - set/get process group"
msgstr "setpgid, getpgid, setpgrp, getpgrp - プロセスグループの設定/取得を行う"

#. type: Plain text
#: build/C/man2/setpgid.2:55
msgid "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"
msgstr "B<int setpgid(pid_t >I<pid>B<, pid_t >I<pgid>B<);>"

#. type: Plain text
#: build/C/man2/setpgid.2:57
msgid "B<pid_t getpgid(pid_t >I<pid>B<);>"
msgstr "B<pid_t getpgid(pid_t >I<pid>B<);>"

#. type: Plain text
#: build/C/man2/setpgid.2:59
msgid "B<pid_t getpgrp(void);> /* POSIX.1 version */"
msgstr "B<pid_t getpgrp(void);> /* POSIX.1 version */"

#. type: Plain text
#: build/C/man2/setpgid.2:62
msgid ""
"B<pid_t getpgrp(pid_t >I<pid>B<);\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ > /* BSD "
"version */"
msgstr ""
"B<pid_t getpgrp(pid_t >I<pid>B<);\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ > /* BSD "
"version */"

#. type: Plain text
#: build/C/man2/setpgid.2:64
msgid "B<int setpgrp(void);> /* System V version */"
msgstr "B<int setpgrp(void);> /* System V version */"

#. type: Plain text
#: build/C/man2/setpgid.2:67
msgid "B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);\\ > /* BSD version */"
msgstr ""
"B<int setpgrp(pid_t >I<pid>B<, pid_t >I<pgid>B<);\\ > /* BSD version */"

#. type: Plain text
#: build/C/man2/setpgid.2:76
msgid "B<getpgid>():"
msgstr "B<getpgid>():"

#. type: Plain text
#: build/C/man2/setpgid.2:84
msgid "B<setpgrp>() (POSIX.1):"
msgstr "B<setpgrp>() (POSIX.1):"

#. type: Plain text
#: build/C/man2/setpgid.2:87
#, no-wrap
msgid ""
"    _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"    _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED\n"
msgstr ""
"    _SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 ||\n"
"    _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED\n"

#. type: Plain text
#: build/C/man2/setpgid.2:91
msgid "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"
msgstr "B<setpgrp>()\\ (BSD), B<getpgrp>()\\ (BSD):"

#. type: Plain text
#: build/C/man2/setpgid.2:95
#, no-wrap
msgid ""
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"           _XOPEN_SOURCE_EXTENDED || _GNU_SOURCE || _SVID_SOURCE)\n"
msgstr ""
"    _BSD_SOURCE &&\n"
"        !\\ (_POSIX_SOURCE || _POSIX_C_SOURCE || _XOPEN_SOURCE ||\n"
"           _XOPEN_SOURCE_EXTENDED || _GNU_SOURCE || _SVID_SOURCE)\n"

#. type: Plain text
#: build/C/man2/setpgid.2:107
msgid ""
"All of these interfaces are available on Linux, and are used for getting and "
"setting the process group ID (PGID) of a process.  The preferred, POSIX.1-"
"specified ways of doing this are: B<getpgrp>(void), for retrieving the "
"calling process's PGID; and B<setpgid>(), for setting a process's PGID."
msgstr ""
"これらのインタフェースすべてが Linux で利用可能で、 これらを使ってプロセスの"
"プロセスグループ ID (PGID) の 取得や設定ができる。 推奨の、POSIX.1 で規定され"
"た方法では、 B<getpgrp>(void)  で呼び出し元プロセスの PGID を取得し、 "
"B<setpgid>()  で設定する。"

#. type: Plain text
#: build/C/man2/setpgid.2:132
msgid ""
"B<setpgid>()  sets the PGID of the process specified by I<pid> to I<pgid>.  "
"If I<pid> is zero, then the process ID of the calling process is used.  If "
"I<pgid> is zero, then the PGID of the process specified by I<pid> is made "
"the same as its process ID.  If B<setpgid>()  is used to move a process from "
"one process group to another (as is done by some shells when creating "
"pipelines), both process groups must be part of the same session (see "
"B<setsid>(2)  and B<credentials>(7)).  In this case, the I<pgid> specifies "
"an existing process group to be joined and the session ID of that group must "
"match the session ID of the joining process."
msgstr ""
"B<setpgid>()  は I<pid> で指定したプロセスの PGID に I<pgid> を設定する。 "
"I<pid> がゼロならば、呼び出し元プロセスのプロセス ID が pid として使用され"
"る。 I<pgid> がゼロならば、 I<pid> で指定されたプロセスの PGID がそのプロセス"
"のプロセス ID と 同じに設定される。 B<setpgid>()  をプロセスをあるプロセスグ"
"ループから別のグループへ 移動するために使用する場合は (一部のシェルはパイプラ"
"インを生成 する時にこれを行う)、両方のプロセスグループは同じセッションの 一部"
"でなければならない (B<setsid>(2)  と B<credentials>(7)  参照)。この場合は "
"I<pgid> は参加すべき既存の プロセスグループを指定し、そのセッション ID は参加"
"するプロセスの セッション ID に一致しなければならない。"

#. type: Plain text
#: build/C/man2/setpgid.2:137
msgid ""
"The POSIX.1 version of B<getpgrp>(), which takes no arguments, returns the "
"PGID of the calling process."
msgstr ""
"POSIX.1 バージョンの B<getpgrp>()  は引き数を一つもとらず、 呼び出し元プロセ"
"スの PGID を返す。"

#. type: Plain text
#: build/C/man2/setpgid.2:148
msgid ""
"B<getpgid>()  returns the PGID of the process specified by I<pid>.  If "
"I<pid> is zero, the process ID of the calling process is used.  (Retrieving "
"the PGID of a process other than the caller is rarely necessary, and the "
"POSIX.1 B<getpgrp>()  is preferred for that task.)"
msgstr ""
"B<getpgid>()  は I<pid> で指定されたプロセスの PGID を返す。 I<pid> がゼロな"
"らば、呼び出し元プロセスのプロセス ID が pid として使用される。 (呼び出し元プ"
"ロセス以外のプロセスの PGID の取得が必要になることは めったになく、呼び出し元"
"プロセスの PGID を取得するには POSIX.1 バージョンの B<getpgrp>()  を使うのが"
"望ましい。)"

#. type: Plain text
#: build/C/man2/setpgid.2:153
msgid ""
"The System V-style B<setpgrp>(), which takes no arguments, is equivalent to "
"I<setpgid(0,\\ 0)>."
msgstr ""
"System V バージョンの B<setpgrp>()  は引き数を一つもとらず、 I<setpgid(0,\\ "
"0)> と等価である。"

#.  The true BSD setpgrp() system call differs in allowing the PGID
#.  to be set to arbitrary values, rather than being restricted to
#.  PGIDs in the same session.
#. type: Plain text
#: build/C/man2/setpgid.2:165
msgid ""
"The BSD-specific B<setpgrp>()  call, which takes arguments I<pid> and "
"I<pgid>, is equivalent to I<setpgid(pid, pgid)>."
msgstr ""
"BSD 仕様の B<setpgrp>()  は I<pid> と I<pgid> を引き数にとり、 I<setpgid"
"(pid, pgid)> と等価である。"

#. type: Plain text
#: build/C/man2/setpgid.2:172
msgid ""
"The BSD-specific B<getpgrp>()  call, which takes a single I<pid> argument, "
"is equivalent to I<getpgid(pid)>."
msgstr ""
"BSD 仕様の B<getpgrp>()  は I<pid> だけを引き数にとり、 I<getpgid(pid)> と等"
"価である。"

#. type: Plain text
#: build/C/man2/setpgid.2:181
msgid ""
"On success, B<setpgid>()  and B<setpgrp>()  return zero.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"B<setpgid>()  と B<setpgrp>()  は成功した場合、ゼロを返す。エラーの場合は -1 "
"を返し、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/setpgid.2:185
msgid "The POSIX.1 B<getpgrp>()  always returns the PGID of the caller."
msgstr ""
"POSIX.1 バージョンの B<getpgrp>()  は常に呼び出しプロセスの PGID を返す。"

#. type: Plain text
#: build/C/man2/setpgid.2:193
msgid ""
"B<getpgid>(), and the BSD-specific B<getpgrp>()  return a process group on "
"success.  On error, -1 is returned, and I<errno> is set appropriately."
msgstr ""
"B<getpgid>()  と BSD 仕様の B<getpgrp>()  は成功した場合プロセスグループを返"
"す。 エラーの場合は -1 を返し、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/setpgid.2:202
msgid ""
"An attempt was made to change the process group ID of one of the children of "
"the calling process and the child had already performed an B<execve>(2)  "
"(B<setpgid>(), B<setpgrp>())."
msgstr ""
"呼び出し元プロセスの子プロセスのプロセスグループ ID を変更しようとしたが、 す"
"でにその子プロセスは B<execve>(2)  を実行していた。 (B<setpgid>(), B<setpgrp>"
"())"

#. type: Plain text
#: build/C/man2/setpgid.2:208
msgid "I<pgid> is less than 0 (B<setpgid>(), B<setpgrp>())."
msgstr "I<pgid> が 0 より小さい。 (B<setpgid>(), B<setpgrp>())"

#. type: Plain text
#: build/C/man2/setpgid.2:217
msgid ""
"An attempt was made to move a process into a process group in a different "
"session, or to change the process group ID of one of the children of the "
"calling process and the child was in a different session, or to change the "
"process group ID of a session leader (B<setpgid>(), B<setpgrp>())."
msgstr ""
"プロセスを異なるセッションのプロセスグループに移動させようとした。 または呼び"
"出し元プロセスの子プロセスのプロセスグループ ID を変更しようと したが、その子"
"プロセスは別のセッションだった。 またはセッションリーダーのプロセスグループ "
"ID を変更しようとした。 (B<setpgid>(), B<setpgrp>())"

#. type: Plain text
#: build/C/man2/setpgid.2:227
msgid ""
"For B<getpgid>(): I<pid> does not match any process.  For B<setpgid>(): "
"I<pid> is not the calling process and not a child of the calling process."
msgstr ""
"B<getpgid>()  の場合: I<pid> がどのプロセスにも一致しない。 B<setpgid>()  の"
"場合: I<pid> が呼び出し元のプロセスではなく、呼び出し元のプロセスの子プロセス"
"でもない。"

#. type: Plain text
#: build/C/man2/setpgid.2:233
msgid ""
"B<setpgid>()  and the version of B<getpgrp>()  with no arguments conform to "
"POSIX.1-2001."
msgstr ""
"B<setpgid>()  と、引き数なしバージョンの B<getpgrp>()  は POSIX.1-2001 に準拠"
"している。"

#. type: Plain text
#: build/C/man2/setpgid.2:242
msgid ""
"POSIX.1-2001 also specifies B<getpgid>()  and the version of B<setpgrp>()  "
"that takes no arguments.  (POSIX.1-2008 marks this B<setpgrp>()  "
"specification as obsolete.)"
msgstr ""
"POSIX.1-2001 は、 B<getpgid>()  と、引き数なしバージョンの B<setpgrp>()  も規"
"定している。 POSIX.1-2008 は、この B<setpgrp>()  の仕様を廃止予定としている。"

#. type: Plain text
#: build/C/man2/setpgid.2:249
msgid ""
"The version of B<getpgrp>()  with one argument and the version of B<setpgrp>"
"()  that takes two arguments derive from 4.2BSD, and are not specified by "
"POSIX.1."
msgstr ""
"引き数 1 個バージョンの B<getpgrp>()  と引き数 2 個バージョンの B<setpgrp>"
"()  は 4.2BSD に由来し、 POSIX.1 では規定されていない。"

#. type: Plain text
#: build/C/man2/setpgid.2:255
msgid ""
"A child created via B<fork>(2)  inherits its parent's process group ID.  The "
"PGID is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスの PGID を継承する。 "
"B<execve>(2)  の前後で PGID は保存される。"

#. type: Plain text
#: build/C/man2/setpgid.2:258
msgid ""
"Each process group is a member of a session and each process is a member of "
"the session of which its process group is a member."
msgstr ""
"各プロセスグループはセッションのメンバーであり、各プロセスは そのプロセスグ"
"ループが所属しているセッションのメンバーである。"

#. type: Plain text
#: build/C/man2/setpgid.2:285
#, fuzzy
#| msgid ""
#| "A session can have a controlling terminal.  At any time, one (and only "
#| "one) of the process groups in the session can be the foreground process "
#| "group for the terminal; the remaining process groups are in the "
#| "background.  If a signal is generated from the terminal (e.g., typing the "
#| "interrupt key to generate B<SIGINT>), that signal is sent to the "
#| "foreground process group.  (See B<termios>(3)  for a description of the "
#| "characters that generate signals.)  Only the foreground process group may "
#| "B<read>(2)  from the terminal; if a background process group tries to "
#| "B<read>(2)  from the terminal, then the group is sent a B<SIGTSTP> "
#| "signal, which suspends it.  The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  "
#| "functions are used to get/set the foreground process group of the "
#| "controlling terminal."
msgid ""
"A session can have a controlling terminal.  At any time, one (and only one) "
"of the process groups in the session can be the foreground process group for "
"the terminal; the remaining process groups are in the background.  If a "
"signal is generated from the terminal (e.g., typing the interrupt key to "
"generate B<SIGINT>), that signal is sent to the foreground process group.  "
"(See B<termios>(3)  for a description of the characters that generate "
"signals.)  Only the foreground process group may B<read>(2)  from the "
"terminal; if a background process group tries to B<read>(2)  from the "
"terminal, then the group is sent a B<SIGTTIN> signal, which suspends it.  "
"The B<tcgetpgrp>(3)  and B<tcsetpgrp>(3)  functions are used to get/set the "
"foreground process group of the controlling terminal."
msgstr ""
"セッションは制御端末 (controlling terminal) を持つことができる。 いつでも、"
"セッションに所属するプロセスグループの一つ (だけ) が 端末のフォアグランドのプ"
"ロセスグループになることができ、 残りのプロセスグループはバックグラウンドにな"
"る。 端末からシグナルが生成された場合 (例えば、中断キーを叩いて B<SIGINT> が"
"生成されるなど)、そのシグナルはフォアグラウンドのプロセスグループ に送られる "
"(シグナルを生成する文字の説明は B<termios>(3)  を参照)。 フォアグラウンドのプ"
"ロセスグループだけが端末からの B<read>(2)  ができる。 バックグラウンドのプロ"
"セスグループが端末からの B<read>(2)  を行おうとした場合、そのプロセスグループ"
"にはシグナル B<SIGTSTP> が送られ、そのプロセスグループは一時停止 (suspend) す"
"る。 関数 B<tcgetpgrp>(3)  と B<tcsetpgrp>(3)  を使うと、制御端末のフォアグラ"
"ウンドのプロセスグループを 取得/設定できる。"

#. type: Plain text
#: build/C/man2/setpgid.2:293
msgid ""
"The B<setpgid>()  and B<getpgrp>()  calls are used by programs such as "
"B<bash>(1)  to create process groups in order to implement shell job control."
msgstr ""
"B<setpgid>()  と B<getpgrp>()  は、 B<bash>(1)  のようなプログラムで、シェル"
"のジョブ制御 (job control) の実装のための プロセスグループを作成するのに使わ"
"れる。"

#. type: Plain text
#: build/C/man2/setpgid.2:303
msgid ""
"If a session has a controlling terminal, and the B<CLOCAL> flag for that "
"terminal is not set, and a terminal hangup occurs, then the session leader "
"is sent a B<SIGHUP>.  If the session leader exits, then a B<SIGHUP> signal "
"will also be sent to each process in the foreground process group of the "
"controlling terminal."
msgstr ""
"セッションが制御端末を持っていて、その端末に対して B<CLOCAL> フラグが設定され"
"ておらず、端末のハングアップが起きた場合、 セッション・リーダーに B<SIGHUP> "
"が送られる。 セッション・リーダーが終了した場合には、その制御端末の フォアグ"
"ランドのプロセスグループに所属する各プロセスにも B<SIGHUP> シグナルが送られ"
"る。"

#.  exit.3 refers to the following text:
#. type: Plain text
#: build/C/man2/setpgid.2:317
msgid ""
"If the exit of the process causes a process group to become orphaned, and if "
"any member of the newly orphaned process group is stopped, then a B<SIGHUP> "
"signal followed by a B<SIGCONT> signal will be sent to each process in the "
"newly orphaned process group.  An orphaned process group is one in which the "
"parent of every member of process group is either itself also a member of "
"the process group or is a member of a process group in a different session "
"(see also B<credentials>(7))."
msgstr ""
"プロセスの終了によってプロセスグループが孤児 (orphaned) になった際に、 その新"
"たに孤児になったプロセスグループに停止しているメンバーがいれば、 その孤児に"
"なったプロセスグループに属す全てのプロセスに B<SIGHUP> シグナルに続けて "
"B<SIGCONT> シグナルが送られる。 孤児になった (orphaned) プロセスグループと"
"は、 そのプロセスグループの全てのメンバーについて、メンバーの親プロセスが、 "
"親プロセス自身もそのプロセスグループのメンバーか、 別のセッションに属すプロセ"
"スグループのメンバーのいずれかであるような、 プロセスグループのことである。"

#. type: Plain text
#: build/C/man2/setpgid.2:324
msgid ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"
msgstr ""
"B<getuid>(2), B<setsid>(2), B<tcgetpgrp>(3), B<tcsetpgrp>(3), B<termios>(3), "
"B<credentials>(7)"

#. type: TH
#: build/C/man2/setresuid.2:26
#, no-wrap
msgid "SETRESUID"
msgstr "SETRESUID"

#. type: Plain text
#: build/C/man2/setresuid.2:29
msgid "setresuid, setresgid - set real, effective and saved user or group ID"
msgstr "setresuid, setresgid - ユーザやグループの 実、実効、保存 ID を設定する"

#. type: Plain text
#: build/C/man2/setresuid.2:35
msgid "B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"
msgstr ""
"B<int setresuid(uid_t >I<ruid>B<, uid_t >I<euid>B<, uid_t >I<suid>B<);>"

#. type: Plain text
#: build/C/man2/setresuid.2:37
msgid "B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"
msgstr ""
"B<int setresgid(gid_t >I<rgid>B<, gid_t >I<egid>B<, gid_t >I<sgid>B<);>"

#. type: Plain text
#: build/C/man2/setresuid.2:41
msgid ""
"B<setresuid>()  sets the real user ID, the effective user ID, and the saved "
"set-user-ID of the calling process."
msgstr ""
"B<setresuid>()  は呼び出し元のプロセスの実 (real) ユーザーID、実効 "
"(effective) ユーザーID、 保存 set-user-ID を設定する。"

#. type: Plain text
#: build/C/man2/setresuid.2:47
msgid ""
"Unprivileged user processes may change the real UID, effective UID, and "
"saved set-user-ID, each to one of: the current real UID, the current "
"effective UID or the current saved set-user-ID."
msgstr ""
"非特権ユーザーのプロセスは、その実 UID、実効 UID、保存 set-user-ID を、 現在"
"の実 UID、現在の実効 UID、現在の保存 set-user-ID のどれかに変更することができ"
"る:"

#. type: Plain text
#: build/C/man2/setresuid.2:51
msgid ""
"Privileged processes (on Linux, those having the B<CAP_SETUID> capability)  "
"may set the real UID, effective UID, and saved set-user-ID to arbitrary "
"values."
msgstr ""
"特権プロセス (Linux では B<CAP_SETUID> ケーパビリティ (capability) を持つ プ"
"ロセス) は、実 UID、実効 UID、保存 set-user-ID を任意の値に設定できる。"

#. type: Plain text
#: build/C/man2/setresuid.2:53
msgid ""
"If one of the arguments equals -1, the corresponding value is not changed."
msgstr "引き数のどれかが -1 の場合はその値は変更されずに残される。"

#. type: Plain text
#: build/C/man2/setresuid.2:57
msgid ""
"Regardless of what changes are made to the real UID, effective UID, and "
"saved set-user-ID, the file system UID is always set to the same value as "
"the (possibly new) effective UID."
msgstr ""
"実 UID、実効 UID、保存 set-user-ID にどんな変更が行われたかに関わらず、 ファ"
"イルシステム UID は常に実効 UID (可能であれば変更後の新しい実効 UID)  と同じ"
"値に設定される。"

#. type: Plain text
#: build/C/man2/setresuid.2:64
msgid ""
"Completely analogously, B<setresgid>()  sets the real GID, effective GID, "
"and saved set-group-ID of the calling process (and always modifies the file "
"system GID to be the same as the effective GID), with the same restrictions "
"for unprivileged processes."
msgstr ""
"全く同じように、 B<setresgid>()  は呼び出し元のプロセスの実 GID、実効 GID、保"
"存 set-group-ID を設定する (さらにファイルシステム GID を実効 GID と同じ値に"
"修正する)。 非特権プロセスは同様の制限を受ける。"

#. type: TP
#: build/C/man2/setresuid.2:70 build/C/man2/setuid.2:76
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/setresuid.2:77
msgid ""
"I<uid> does not match the current UID and this call would bring that user ID "
"over its B<RLIMIT_NPROC> resource limit."
msgstr ""
"I<uid> が現在のユーザー ID と違う値で、 この呼び出しにより ユーザー ID が リ"
"ソース上限 B<RLIMIT_NPROC> を超えてしまう。"

#. type: Plain text
#: build/C/man2/setresuid.2:81
msgid ""
"The calling process is not privileged (did not have the B<CAP_SETUID> "
"capability) and tried to change the IDs to values that are not permitted."
msgstr ""
"呼び出したプロセスが特権を持たないのに (B<CAP_SETUID> ケーパビリティを持たな"
"いのに)、 ID を許されていない値に変更しようとした。"

#. type: Plain text
#: build/C/man2/setresuid.2:83
msgid "These calls are available under Linux since Linux 2.1.44."
msgstr "Linux ではバージョン 2.1.44 より利用可能になった。"

#. type: Plain text
#: build/C/man2/setresuid.2:90
msgid ""
"Under HP-UX and FreeBSD, the prototype is found in I<E<lt>unistd.hE<gt>>.  "
"Under Linux the prototype is provided by glibc since version 2.3.2."
msgstr ""
"HP-UX や FreeBSD では I<E<lt>unistd.hE<gt>> にプロトタイプが存在する。 \n"
"Linux では、glibc 2.3.2 以降で プロトタイプが提供されている。"

#. type: Plain text
#: build/C/man2/setresuid.2:106
msgid ""
"The original Linux B<setresuid>()  and B<setresgid>()  system calls "
"supported only 16-bit user and group IDs.  Subsequently, Linux 2.4 added "
"B<setresuid32>()  and B<setresgid32>(), supporting 32-bit IDs.  The glibc "
"B<setresuid>()  and B<setresgid>()  wrapper functions transparently deal "
"with the variations across kernel versions."
msgstr ""
"元々の Linux の B<setresuid>() と B<setresgid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setresuid32>() と B<setresgid32>() が追加された。\n"
"glibc の B<setresuid>() と B<setresgid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setresuid.2:115
msgid ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), B<setreuid>"
"(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7)"
msgstr ""
"B<getresuid>(2), B<getuid>(2), B<setfsgid>(2), B<setfsuid>(2), B<setreuid>"
"(2), B<setuid>(2), B<capabilities>(7), B<credentials>(7)"

#. type: TH
#: build/C/man2/setreuid.2:45
#, no-wrap
msgid "SETREUID"
msgstr "SETREUID"

#. type: Plain text
#: build/C/man2/setreuid.2:48
msgid "setreuid, setregid - set real and/or effective user or group ID"
msgstr ""
"setreuid, setregid - 実 (real) と実効 (effective) ユーザー (グループ) ID を設"
"定する"

#. type: Plain text
#: build/C/man2/setreuid.2:54
msgid "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"
msgstr "B<int setreuid(uid_t >I<ruid>B<, uid_t >I<euid>B<);>"

#. type: Plain text
#: build/C/man2/setreuid.2:56
msgid "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"
msgstr "B<int setregid(gid_t >I<rgid>B<, gid_t >I<egid>B<);>"

#. type: Plain text
#: build/C/man2/setreuid.2:64
msgid "B<setreuid>(), B<setregid>():"
msgstr "B<setreuid>(), B<setregid>():"

#. type: Plain text
#: build/C/man2/setreuid.2:68
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/setreuid.2:73
msgid "B<setreuid>()  sets real and effective user IDs of the calling process."
msgstr ""
"B<setreuid>()  は呼び出し元のプロセスの実 (real) ユーザー ID と 実効 "
"(effective) ユーザー ID を設定する。"

#. type: Plain text
#: build/C/man2/setreuid.2:76
msgid ""
"Supplying a value of -1 for either the real or effective user ID forces the "
"system to leave that ID unchanged."
msgstr ""
"実ユーザー ID や実効ユーザー ID に -1 を与えた場合、 システムはその ID を変更"
"しない。"

#. type: Plain text
#: build/C/man2/setreuid.2:79
msgid ""
"Unprivileged processes may only set the effective user ID to the real user "
"ID, the effective user ID, or the saved set-user-ID."
msgstr ""
"非特権プロセスは実効ユーザー ID を実ユーザー ID または実効ユーザー ID または "
"保存 set-user-ID にしか設定できない。"

#. type: Plain text
#: build/C/man2/setreuid.2:82
msgid ""
"Unprivileged users may only set the real user ID to the real user ID or the "
"effective user ID."
msgstr ""
"非特権ユーザーは、実ユーザー ID を実ユーザー ID または 実効ユーザー ID にしか"
"設定できない。"

#. type: Plain text
#: build/C/man2/setreuid.2:86
msgid ""
"If the real user ID is set or the effective user ID is set to a value not "
"equal to the previous real user ID, the saved set-user-ID will be set to the "
"new effective user ID."
msgstr ""
"実ユーザーID が設定されたり、実効ユーザーID が前の実ユーザーID と 異った値に"
"設定された場合、保存 set-user-ID には新しい実効ユーザーID の値が設定される。"

#. type: Plain text
#: build/C/man2/setreuid.2:91
msgid ""
"Completely analogously, B<setregid>()  sets real and effective group ID's of "
"the calling process, and all of the above holds with \"group\" instead of "
"\"user\"."
msgstr ""
"これと全く同様に、 B<setregid>()  は呼び出し元のプロセスの実グループ ID と実"
"効グループ ID を設定し、 上記の説明で「ユーザー」を「グループ」に読み替えたこ"
"とが成り立つ。"

#. type: Plain text
#: build/C/man2/setreuid.2:113
msgid ""
"The calling process is not privileged (Linux: does not have the "
"B<CAP_SETUID> capability in the case of B<setreuid>(), or the B<CAP_SETGID> "
"capability in the case of B<setregid>())  and a change other than (i)  "
"swapping the effective user (group) ID with the real user (group) ID, or "
"(ii) setting one to the value of the other or (iii) setting the effective "
"user (group) ID to the value of the saved set-user-ID (saved set-group-ID) "
"was specified."
msgstr ""
"呼び出し元のプロセスに特権がなく (Linux では B<setreuid>()  の場合に "
"B<CAP_SETUID> ケーパビリティ (capability) がなく、 B<setregid>()  の場合に "
"B<CAP_SETGID> ケーパビリティがない)、 以下のいずれでもない変更が指定された: "
"(i) 実効ユーザー (グループ) ID と実ユーザー (グループ) ID を入れ換える。 "
"(ii) 片方の値を他方に設定する。 (iii) 実効ユーザー (グループ) ID に保存 set-"
"user-ID (保存 set-group-ID)  の値を設定する。"

#. type: Plain text
#: build/C/man2/setreuid.2:119
msgid ""
"POSIX.1-2001, 4.3BSD (the B<setreuid>()  and B<setregid>()  function calls "
"first appeared in 4.2BSD)."
msgstr ""
"POSIX.1-2001, 4.3BSD (B<setreuid>()  と B<setregid>()  関数コールは 4.2BSD で"
"登場した)。"

#. type: Plain text
#: build/C/man2/setreuid.2:123
msgid ""
"Setting the effective user (group) ID to the saved set-user-ID (saved set-"
"group-ID) is possible since Linux 1.1.37 (1.1.38)."
msgstr ""
"実効ユーザー (グループ) ID を保存ユーザー (グループ) ID に 設定することが、"
"Linux 1.1.37 (1.1.38) から可能になった。"

#. type: Plain text
#: build/C/man2/setreuid.2:140
msgid ""
"POSIX.1 does not specify all of possible ID changes that are permitted on "
"Linux for an unprivileged process.  For B<setreuid>(), the effective user ID "
"can be made the same as the real user ID or the save set-user-ID, and it is "
"unspecified whether unprivileged processes may set the real user ID to the "
"real user ID, the effective user ID, or the saved set-user-ID.  For "
"B<setregid>(), the real group ID can be changed to the value of the saved "
"set-group-ID, and the effective group ID can be changed to the value of the "
"real group ID or the saved set-group-ID.  The precise details of what ID "
"changes are permitted vary across implementations."
msgstr ""
"POSIX.1 では、非特権プロセスに対して Linux 上で認められている ID の変更の 全"
"パターンを規定しているわけではない。 B<setreuid>()  では、実効ユーザ ID を実"
"ユーザ ID もしくは保存 set-user-ID と 同じ値にすることができるが、 非特権プロ"
"セスが実ユーザ ID を実ユーザ ID、実効ユーザ ID、 保存 set-user-ID のどの値に"
"も設定できるかは規定されていない。 B<setregid>()  では、実グループ ID を保存 "
"set-group-ID と同じ値に変更でき、 実効グループ ID を実グループ ID や保存 set-"
"group-ID と同じ値に変更できる。 どのような ID の変更が認められているかの正確"
"な詳細は 実装ごとに異なる。"

#. type: Plain text
#: build/C/man2/setreuid.2:143
msgid ""
"POSIX.1 makes no specification about the effect of these calls on the saved "
"set-user-ID and saved set-group-ID."
msgstr ""
"POSIX.1 では、これらのシステムコールが保存 set-user-ID や 保存 set-group-ID "
"に与える影響については規定していない。"

#. type: Plain text
#: build/C/man2/setreuid.2:159
msgid ""
"The original Linux B<setreuid>()  and B<setregid>()  system calls supported "
"only 16-bit user and group IDs.  Subsequently, Linux 2.4 added B<setreuid32>"
"()  and B<setregid32>(), supporting 32-bit IDs.  The glibc B<setreuid>()  "
"and B<setregid>()  wrapper functions transparently deal with the variations "
"across kernel versions."
msgstr ""
"元々の Linux の B<setreuid>() と B<setregid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setreuid32>() と B<setregid32>() が追加された。\n"
"glibc の B<setreuid>() と B<setregid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setreuid.2:167
msgid ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7)"
msgstr ""
"B<getgid>(2), B<getuid>(2), B<seteuid>(2), B<setgid>(2), B<setresuid>(2), "
"B<setuid>(2), B<capabilities>(7)"

#. type: TH
#: build/C/man2/setsid.2:30
#, no-wrap
msgid "SETSID"
msgstr "SETSID"

#. type: Plain text
#: build/C/man2/setsid.2:33
msgid "setsid - creates a session and sets the process group ID"
msgstr "setsid - セッション (session) を作成し、プロセスグループ ID を設定する"

#. type: Plain text
#: build/C/man2/setsid.2:38
msgid "B<pid_t setsid(void);>"
msgstr "B<pid_t setsid(void);>"

#. type: Plain text
#: build/C/man2/setsid.2:51
msgid ""
"B<setsid>()  creates a new session if the calling process is not a process "
"group leader.  The calling process is the leader of the new session, the "
"process group leader of the new process group, and has no controlling "
"terminal.  The process group ID and session ID of the calling process are "
"set to the PID of the calling process.  The calling process will be the only "
"process in this new process group and in this new session."
msgstr ""
"B<setsid>()  は呼び出したプロセスがプロセスグループ・リーダー (process group "
"leader) でなければ、新しいセッションを作成する。 呼び出したプロセスは新しい"
"セッションのリーダー、新しいプロセスグループの プロセスグループ・リーダーとな"
"り、端末の制御を持たない。 呼び出したプロセスのプロセスグループ ID とセッショ"
"ン ID には、 呼び出したプロセスの PID が設定される。呼び出したプロセスはこの "
"新しいプロセスグループ、この新しいセッションの唯一のプロセスとなる。"

#. type: Plain text
#: build/C/man2/setsid.2:58
msgid ""
"On success, the (new) session ID of the calling process is returned.  On "
"error, I<(pid_t)\\ -1> is returned, and I<errno> is set to indicate the "
"error."
msgstr ""
"成功すると、呼び出したプロセスの (新しい) セッション ID が返される。 エラーの"
"場合は、 I<(pid_t)\\ -1> が返され、 I<error> にエラーを示す値が設定される。"

#. type: Plain text
#: build/C/man2/setsid.2:65
msgid ""
"The process group ID of any process equals the PID of the calling process.  "
"Thus, in particular, B<setsid>()  fails if the calling process is already a "
"process group leader."
msgstr ""
"いずれかのプロセスのプロセスグループ ID が、 呼び出したプロセスの PID と等し"
"い。 これは、呼び出したプロセスが既にプロセスリーダーの場合には B<setsid>()  "
"は失敗することを意味する。"

#. type: Plain text
#: build/C/man2/setsid.2:73
msgid ""
"A child created via B<fork>(2)  inherits its parent's session ID.  The "
"session ID is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、親プロセスのセッション ID を継承する。 "
"B<execve>(2)  の前後でセッション ID は保存される。"

#. type: Plain text
#: build/C/man2/setsid.2:84
msgid ""
"A process group leader is a process with process group ID equal to its PID.  "
"In order to be sure that B<setsid>()  will succeed, B<fork>(2)  and B<_exit>"
"(2), and have the child do B<setsid>()."
msgstr ""
"プロセスグループ・リーダーとは、そのプロセスのプロセスグループ ID が その "
"PID に等しいプロセスである。 B<setsid>()  を確実に成功させるためには、 "
"B<fork>(2)  して B<exit>(2)  し、子プロセスで B<setsid>()  を行なえば良い。"

#. type: Plain text
#: build/C/man2/setsid.2:91
msgid ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7)"
msgstr ""
"B<setsid>(1), B<getsid>(2), B<setpgid>(2), B<setpgrp>(2), B<tcgetsid>(3), "
"B<credentials>(7)"

#. type: TH
#: build/C/man2/setuid.2:30
#, no-wrap
msgid "SETUID"
msgstr "SETUID"

#. type: Plain text
#: build/C/man2/setuid.2:33
msgid "setuid - set user identity"
msgstr "setuid - ユーザー識別 (identity) を設定する"

#. type: Plain text
#: build/C/man2/setuid.2:39
msgid "B<int setuid(uid_t >I<uid>B<);>"
msgstr "B<int setuid(uid_t >I<uid>B<);>"

#. type: Plain text
#: build/C/man2/setuid.2:44
msgid ""
"B<setuid>()  sets the effective user ID of the calling process.  If the "
"effective UID of the caller is root, the real UID and saved set-user-ID are "
"also set."
msgstr ""
"B<setuid>()  は呼び出し元のプロセスの実効 (effective) ユーザー ID を設定す"
"る。 もし呼び出し元プロセスの実効 UID が root ならば、 実 (real) UID と保存 "
"(saved) set-user-ID も設定される。"

#. type: Plain text
#: build/C/man2/setuid.2:53
msgid ""
"Under Linux, B<setuid>()  is implemented like the POSIX version with the "
"B<_POSIX_SAVED_IDS> feature.  This allows a set-user-ID (other than root) "
"program to drop all of its user privileges, do some un-privileged work, and "
"then reengage the original effective user ID in a secure manner."
msgstr ""
"Linux では、 B<setuid>()  は B<_POSIX_SAVED_IDS> をもった POSIX 版のように実"
"装されている。 これは (ルート以外の) set-user-ID プログラムにそのユーザーの特"
"権を 全て与え、特権の必要ない仕事をし、本来の実効ユーザー ID に 安全な方法で"
"再び戻すことを許す。"

#. type: Plain text
#: build/C/man2/setuid.2:63
msgid ""
"If the user is root or the program is set-user-ID-root, special care must be "
"taken.  The B<setuid>()  function checks the effective user ID of the caller "
"and if it is the superuser, all process-related user ID's are set to "
"I<uid>.  After this has occurred, it is impossible for the program to regain "
"root privileges."
msgstr ""
"ユーザーが root またはプログラムが root に set-user-ID されているならば、 特"
"別の注意が払われる。 B<setuid>()  関数は呼び出し者の実効ユーザー ID をチェッ"
"クし、 それがスーパーユーザーならば、 プロセスに関連する全てのユーザー ID に "
"I<uid> を設定する。 これが行なわれた後にはプログラムが再びルートの特権を得る"
"ことはできない。"

#. type: Plain text
#: build/C/man2/setuid.2:70
msgid ""
"Thus, a set-user-ID-root program wishing to temporarily drop root "
"privileges, assume the identity of an unprivileged user, and then regain "
"root privileges afterward cannot use B<setuid>().  You can accomplish this "
"with B<seteuid>(2)."
msgstr ""
"したがって、set-user-ID-root プログラムで、一時的にルート特権を解除し、 非特"
"権ユーザであるかのように振舞い、後でルート権限をもう一度得ようと する場合に"
"は、 B<setuid>()  を使うことができない。その場合には、 B<seteuid>(2)  を使う"
"必要がある。"

#. type: Plain text
#: build/C/man2/setuid.2:85
msgid ""
"The I<uid> does not match the current uid and I<uid> brings process over its "
"B<RLIMIT_NPROC> resource limit."
msgstr ""
"I<uid> が現在のユーザー ID とマッチせず、この I<uid> によってプロセスがリソー"
"ス上限 B<RLIMIT_NPROC> を超えた。"

#. type: Plain text
#: build/C/man2/setuid.2:92
msgid ""
"The user is not privileged (Linux: does not have the B<CAP_SETUID> "
"capability) and I<uid> does not match the real UID or saved set-user-ID of "
"the calling process."
msgstr ""
"ユーザーが特権を持たず (Linux では B<CAP_SETUID> ケーパビリティ (capability) "
"を持たず)、 I<uid> が呼び出し元プロセスの実 UID または保存 set-user-ID と一致"
"しない。"

#.  SVr4 documents an additional EINVAL error condition.
#. type: Plain text
#: build/C/man2/setuid.2:97
msgid ""
"SVr4, POSIX.1-2001.  Not quite compatible with the 4.4BSD call, which sets "
"all of the real, saved, and effective user IDs."
msgstr ""
"SVr4, POSIX.1-2001.  4.4BSD のコールとは完全な互換性はない、 BSD のコールは"
"実 (real)、保存 (saved)、実効 (effective) ID の全てを設定する。"

#. type: Plain text
#: build/C/man2/setuid.2:105
msgid ""
"Linux has the concept of the file system user ID, normally equal to the "
"effective user ID.  The B<setuid>()  call also sets the file system user ID "
"of the calling process.  See B<setfsuid>(2)."
msgstr ""
"Linux はファイルシステム・ユーザー ID の概念を持つ。\n"
"通常、これは実効ユーザー ID に等しい。 \n"
"B<setuid>()  コールは呼び出し元のプロセスの\n"
"ファイルシステム・ユーザー ID も設定する。 \n"
"B<setfsuid>(2) も参照すること。"

#. type: Plain text
#: build/C/man2/setuid.2:110
msgid ""
"If I<uid> is different from the old effective UID, the process will be "
"forbidden from leaving core dumps."
msgstr ""
"I<uid> が前の実効 UID と異っていた場合、\n"
"プロセスはコアダンプすることを禁止される。"

#. type: Plain text
#: build/C/man2/setuid.2:120
msgid ""
"The original Linux B<setuid>()  system call supported only 16-bit user IDs.  "
"Subsequently, Linux 2.4 added B<setuid32>()  supporting 32-bit IDs.  The "
"glibc B<setuid>()  wrapper function transparently deals with the variation "
"across kernel versions."
msgstr ""
"元々の Linux の B<setuid>() システムコールは\n"
"16 ビットのグループ ID だけに対応していた。\n"
"その後、Linux 2.4 で、32 ビットの ID に対応した\n"
"B<setuid32>() が追加された。\n"
"glibc の B<setuid>() のラッパー関数は\n"
"カーネルバージョンによるこの違いを吸収している。"

#. type: Plain text
#: build/C/man2/setuid.2:127
msgid ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), B<capabilities>"
"(7), B<credentials>(7)"
msgstr ""
"B<getuid>(2), B<seteuid>(2), B<setfsuid>(2), B<setreuid>(2), B<capabilities>"
"(7), B<credentials>(7)"

#. type: TH
#: build/C/man7/svipc.7:40
#, no-wrap
msgid "SVIPC"
msgstr "SVIPC"

#. type: Plain text
#: build/C/man7/svipc.7:43
msgid "svipc - System V interprocess communication mechanisms"
msgstr "svipc - System V プロセス間通信機構"

#. type: Plain text
#: build/C/man7/svipc.7:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/msg.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/msg.hE<gt>>\n"
"B<#include E<lt>sys/sem.hE<gt>>\n"
"B<#include E<lt>sys/shm.hE<gt>>\n"

#. type: Plain text
#: build/C/man7/svipc.7:56
msgid ""
"This manual page refers to the Linux implementation of the System V "
"interprocess communication (IPC) mechanisms: message queues, semaphore sets, "
"and shared memory segments.  In the following, the word I<resource> means an "
"instantiation of one among such mechanisms."
msgstr ""
"このマニュアルページは System V プロセス間通信 (interprocess communication; "
"IPC) 機構の Linux に おける実装を説明する。 このプロセス間通信機構には、 メッ"
"セージキュー (message queue)、セマフォー集合 (semaphore set)、 共有メモリセグ"
"メント (shared memory segment) などがある。以下で I<資源 (resource)> という用"
"語を使用した場合にはこれらの機構のどれかを意味する。"

#. type: SS
#: build/C/man7/svipc.7:56
#, no-wrap
msgid "Resource access permissions"
msgstr "資源へのアクセス許可"

#. type: Plain text
#: build/C/man7/svipc.7:64
msgid ""
"For each resource, the system uses a common structure of type I<struct "
"ipc_perm> to store information needed in determining permissions to perform "
"an IPC operation.  The I<ipc_perm> structure includes the following members:"
msgstr ""
"システムのそれぞれの資源は、IPC への操作を許可するかどうかを決定する ための情"
"報を共通の構造体 I<struct ipc_perm> に格納して使用する。 I<ipc_perm> 構造体に"
"は以下のメンバーが定義されている:"

#. type: Plain text
#: build/C/man7/svipc.7:74
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    uid_t          cuid;   /* creator user ID */\n"
"    gid_t          cgid;   /* creator group ID */\n"
"    uid_t          uid;    /* owner user ID */\n"
"    gid_t          gid;    /* owner group ID */\n"
"    unsigned short mode;   /* r/w permissions */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    uid_t          cuid;   /* 作成者のユーザーID */\n"
"    gid_t          cgid;   /* 作成者のグループID */\n"
"    uid_t          uid;    /* 所有者のユーザーID */\n"
"    gid_t          gid;    /* 所有者のグループID */\n"
"    unsigned short mode;   /* 読み書きの許可 */\n"
"};\n"

#. type: Plain text
#: build/C/man7/svipc.7:84
msgid ""
"The I<mode> member of the I<ipc_perm> structure defines, with its lower 9 "
"bits, the access permissions to the resource for a process executing an IPC "
"system call.  The permissions are interpreted as follows:"
msgstr ""
"I<ipc_perm> 構造体の I<mode> メンバーは以下の 9 ビットで、プロセスの IPC シス"
"テムコール による資源へのアクセス許可を定義する。 許可は以下のように解釈され"
"る:"

#. type: Plain text
#: build/C/man7/svipc.7:88
#, no-wrap
msgid ""
"    0400    Read by user.\n"
"    0200    Write by user.\n"
msgstr ""
"    0400    ユーザーによる読み込み。\n"
"    0200    ユーザーによる書き込み。\n"

#. type: Plain text
#: build/C/man7/svipc.7:91
#, no-wrap
msgid ""
"    0040    Read by group.\n"
"    0020    Write by group.\n"
msgstr ""
"    0040    グループによる読み込み。\n"
"    0020    グループによる書き込み。\n"

#. type: Plain text
#: build/C/man7/svipc.7:94
#, no-wrap
msgid ""
"    0004    Read by others.\n"
"    0002    Write by others.\n"
msgstr ""
"    0004    他人による読み込み。\n"
"    0002    他人による書き込み。\n"

#. type: Plain text
#: build/C/man7/svipc.7:102
msgid ""
"Bits 0100, 0010, and 0001 (the execute bits) are unused by the system.  "
"Furthermore, \"write\" effectively means \"alter\" for a semaphore set."
msgstr ""
"システムはビット 0100, 0010, 0001 (実行ビット) は使用しない。 さらに、セマ"
"フォーの場合には \"書き込み(write)\" は実際には \"変更(alter)\" を意味する。"

#. type: Plain text
#: build/C/man7/svipc.7:105
msgid ""
"The same system header file also defines the following symbolic constants:"
msgstr "同じヘッダーファイルには以下のシンボルの定義が含まれている:"

#. type: TP
#: build/C/man7/svipc.7:105
#, no-wrap
msgid "B<IPC_CREAT>"
msgstr "B<IPC_CREAT>"

#. type: Plain text
#: build/C/man7/svipc.7:108
msgid "Create entry if key doesn't exist."
msgstr "キー(key)が存在しない場合には新たなエントリを作成する。"

#. type: TP
#: build/C/man7/svipc.7:108
#, no-wrap
msgid "B<IPC_EXCL>"
msgstr "B<IPC_EXCL>"

#. type: Plain text
#: build/C/man7/svipc.7:111
msgid "Fail if key exists."
msgstr "キー(key)が存在する場合には失敗する。"

#. type: TP
#: build/C/man7/svipc.7:111
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr "B<IPC_NOWAIT>"

#. type: Plain text
#: build/C/man7/svipc.7:114
msgid "Error if request must wait."
msgstr "要求が待たされる場合にはエラーになる。"

#. type: TP
#: build/C/man7/svipc.7:114
#, no-wrap
msgid "B<IPC_PRIVATE>"
msgstr "B<IPC_PRIVATE>"

#. type: Plain text
#: build/C/man7/svipc.7:117
msgid "Private key."
msgstr "プライベートキー。"

#. type: TP
#: build/C/man7/svipc.7:117
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: build/C/man7/svipc.7:120
msgid "Remove resource."
msgstr "資源を削除する。"

#. type: TP
#: build/C/man7/svipc.7:120
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: build/C/man7/svipc.7:123
msgid "Set resource options."
msgstr "資源にオプションを設定する。"

#. type: TP
#: build/C/man7/svipc.7:123
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: build/C/man7/svipc.7:126
msgid "Get resource options."
msgstr "資源のオプションを取得する。"

#. type: Plain text
#: build/C/man7/svipc.7:135
msgid ""
"Note that B<IPC_PRIVATE> is a I<key_t> type, while all the other symbolic "
"constants are flag fields and can be OR'ed into an I<int> type variable."
msgstr ""
"B<IPC_PRIVATE> は I<key_t> 型である。その他の全てのシンボルはフラグフィールド"
"として I<int> 変数に OR 演算で格納することができる。"

#. type: SS
#: build/C/man7/svipc.7:135
#, no-wrap
msgid "Message queues"
msgstr "メッセージキュー"

#. type: Plain text
#: build/C/man7/svipc.7:143
msgid ""
"A message queue is uniquely identified by a positive integer (its I<msqid>)  "
"and has an associated data structure of type I<struct msqid_ds>, defined in "
"I<E<lt>sys/msg.hE<gt>>, containing the following members:"
msgstr ""
"メッセージキューは正の整数 (I<msqid>)  によって識別され、 I<E<lt>sys/msg."
"hE<gt>> に定義されている構造体 I<struct msqid_ds> に結びつけられている。 この"
"構造体は以下のメンバーを含んでいる:"

#. type: Plain text
#: build/C/man7/svipc.7:156
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;\n"
"    msgqnum_t       msg_qnum;    /* no of messages on queue */\n"
"    msglen_t        msg_qbytes;  /* bytes max on a queue */\n"
"    pid_t           msg_lspid;   /* PID of last msgsnd(2) call */\n"
"    pid_t           msg_lrpid;   /* PID of last msgrcv(2) call */\n"
"    time_t          msg_stime;   /* last msgsnd(2) time */\n"
"    time_t          msg_rtime;   /* last msgrcv(2) time */\n"
"    time_t          msg_ctime;   /* last change time */\n"
"};\n"
msgstr ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;\n"
"    msgqnum_t       msg_qnum;    /* キューにあるメッセージの数 */\n"
"    msglen_t        msg_qbytes;  /* キューの最大バイト数 */\n"
"    pid_t           msg_lspid;   /* 最後に msgsnd(2) をした PID */\n"
"    pid_t           msg_lrpid;   /* 最後に msgrcv(2) をした PID */\n"
"    time_t          msg_stime;   /* 最後に msgsnd(2) をした時間 */\n"
"    time_t          msg_rtime;   /* 最後に msgrcv(2) をした時間 */\n"
"    time_t          msg_ctime;   /* 最後に変更された時間 */\n"
"};\n"

#. type: TP
#: build/C/man7/svipc.7:158
#, no-wrap
msgid "I<msg_perm>"
msgstr "I<msg_perm>"

#. type: Plain text
#: build/C/man7/svipc.7:163
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the message "
"queue."
msgstr "メッセージキューへのアクセス許可を指定する I<ipc_perm> 構造体。"

#. type: TP
#: build/C/man7/svipc.7:163
#, no-wrap
msgid "I<msg_qnum>"
msgstr "I<msg_qnum>"

#. type: Plain text
#: build/C/man7/svipc.7:166
msgid "Number of messages currently on the message queue."
msgstr "現在、このメッセージキューにあるメッセージの数。"

#. type: TP
#: build/C/man7/svipc.7:166
#, no-wrap
msgid "I<msg_qbytes>"
msgstr "I<msg_qbytes>"

#. type: Plain text
#: build/C/man7/svipc.7:170
msgid "Maximum number of bytes of message text allowed on the message queue."
msgstr "メッセージキューに入れることができるメッセージの最大バイト数。"

#. type: TP
#: build/C/man7/svipc.7:170
#, no-wrap
msgid "I<msg_lspid>"
msgstr "I<msg_lspid>"

#. type: Plain text
#: build/C/man7/svipc.7:175
msgid "ID of the process that performed the last B<msgsnd>(2)  system call."
msgstr "最後に B<msgsnd>(2)  システムコールを行なったプロセスの ID。"

#. type: TP
#: build/C/man7/svipc.7:175
#, no-wrap
msgid "I<msg_lrpid>"
msgstr "I<msg_lrpid>"

#. type: Plain text
#: build/C/man7/svipc.7:180
msgid "ID of the process that performed the last B<msgrcv>(2)  system call."
msgstr "最後に B<msgrcv>(2)  システムコールを行なったプロセスの ID。"

#. type: TP
#: build/C/man7/svipc.7:180
#, no-wrap
msgid "I<msg_stime>"
msgstr "I<msg_stime>"

#. type: Plain text
#: build/C/man7/svipc.7:185
msgid "Time of the last B<msgsnd>(2)  system call."
msgstr "最後に B<msgsnd>(2)  システムコールを行なった時間。"

#. type: TP
#: build/C/man7/svipc.7:185
#, no-wrap
msgid "I<msg_rtime>"
msgstr "I<msg_rtime>"

#. type: Plain text
#: build/C/man7/svipc.7:190
msgid "Time of the last B<msgrcv>(2)  system call."
msgstr "最後に B<msgrcv>(2)  を行なった時間。"

#. type: TP
#: build/C/man7/svipc.7:190
#, no-wrap
msgid "I<msg_ctime>"
msgstr "I<msg_ctime>"

#. type: Plain text
#: build/C/man7/svipc.7:196
msgid ""
"Time of the last system call that changed a member of the I<msqid_ds> "
"structure."
msgstr "最後に I<msqid_ds> 構造体のメンバーが変更された時間。"

#. type: SS
#: build/C/man7/svipc.7:196
#, no-wrap
msgid "Semaphore sets"
msgstr "セマフォー集合"

#. type: Plain text
#: build/C/man7/svipc.7:204
msgid ""
"A semaphore set is uniquely identified by a positive integer (its I<semid>)  "
"and has an associated data structure of type I<struct semid_ds>, defined in "
"I<E<lt>sys/sem.hE<gt>>, containing the following members:"
msgstr ""
"セマフォー集合は正の整数 (I<semid>)  によって識別され、 I<E<lt>sys/sem."
"hE<gt>> に定義されている構造体 I<struct semid_ds> に結びつけられている。 この"
"構造体は以下のメンバーを含んでいる:"

#. type: Plain text
#: build/C/man7/svipc.7:213
#, no-wrap
msgid ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;\n"
"    time_t          sem_otime;   /* last operation time */\n"
"    time_t          sem_ctime;   /* last change time */\n"
"    unsigned long   sem_nsems;   /* count of sems in set */\n"
"};\n"
msgstr ""
"struct semid_ds {\n"
"    struct ipc_perm sem_perm;\n"
"    time_t          sem_otime;   /* 最後に操作した時間 */\n"
"    time_t          sem_ctime;   /* 最後に変更した時間 */\n"
"    unsigned long   sem_nsems;   /* 集合の中にあるセマフォー数 */\n"
"};\n"

#. type: TP
#: build/C/man7/svipc.7:215
#, no-wrap
msgid "I<sem_perm>"
msgstr "I<sem_perm>"

#. type: Plain text
#: build/C/man7/svipc.7:220
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the semaphore "
"set."
msgstr "セマフォー集合へのアクセス許可を指定する I<ipc_perm> 構造体。"

#. type: TP
#: build/C/man7/svipc.7:220
#, no-wrap
msgid "I<sem_otime>"
msgstr "I<sem_otime>"

#. type: Plain text
#: build/C/man7/svipc.7:225
msgid "Time of last B<semop>(2)  system call."
msgstr "最後に B<semop>(2)  システムコールを行なった時間。"

#. type: TP
#: build/C/man7/svipc.7:225
#, no-wrap
msgid "I<sem_ctime>"
msgstr "I<sem_ctime>"

#. type: Plain text
#: build/C/man7/svipc.7:231
msgid ""
"Time of last B<semctl>(2)  system call that changed a member of the above "
"structure or of one semaphore belonging to the set."
msgstr ""
"最後に B<semctl>(2)  を行なって上記の構造体のメンバーを変更するか、セマフォー"
"集合に属する セマフォーを変更した時間。"

#. type: TP
#: build/C/man7/svipc.7:231
#, no-wrap
msgid "I<sem_nsems>"
msgstr "I<sem_nsems>"

#. type: Plain text
#: build/C/man7/svipc.7:239
msgid ""
"Number of semaphores in the set.  Each semaphore of the set is referenced by "
"a nonnegative integer ranging from B<0> to I<sem_nsems-1>."
msgstr ""
"セマフォー集合の中にあるセマフォーの数。 集合の中にあるそれぞれのセマフォーは"
"負でない整数によって参照され、 B<0> から I<sem_nsems-1> までの番号を持つ。"

#. type: Plain text
#: build/C/man7/svipc.7:243
msgid ""
"A semaphore is a data structure of type I<struct sem> containing the "
"following members:"
msgstr ""
"セマフォーは I<struct sem> 型のデータ構造体であり、以下のメンバーを含んでい"
"る:"

#.     unsigned short semncnt; /* nr awaiting semval to increase */
#.     unsigned short semzcnt; /* nr awaiting semval = 0 */
#. type: Plain text
#: build/C/man7/svipc.7:252
#, no-wrap
msgid ""
"struct sem {\n"
"    int semval;  /* semaphore value */\n"
"    int sempid;  /* PID for last operation */\n"
"};\n"
msgstr ""
"struct sem {\n"
"    int semval;  /* セマフォーの値 */\n"
"    int sempid;  /* 最後に操作したプロセス ID */\n"
"};\n"

#. type: TP
#: build/C/man7/svipc.7:254
#, no-wrap
msgid "I<semval>"
msgstr "I<semval>"

#. type: Plain text
#: build/C/man7/svipc.7:257
msgid "Semaphore value: a nonnegative integer."
msgstr "セマフォー値: 負でない整数。"

#. type: TP
#: build/C/man7/svipc.7:257
#, no-wrap
msgid "I<sempid>"
msgstr "I<sempid>"

#. .TP
#. .I semncnt
#. Number of processes suspended awaiting for
#. .I semval
#. to increase.
#. .TP
#. .I semznt
#. Number of processes suspended awaiting for
#. .I semval
#. to become zero.
#. type: Plain text
#: build/C/man7/svipc.7:271
msgid ""
"ID of the last process that performed a semaphore operation on this "
"semaphore."
msgstr "このセマフォーを最後に操作したプロセスの ID。"

#. type: SS
#: build/C/man7/svipc.7:271
#, no-wrap
msgid "Shared memory segments"
msgstr "共有メモリセグメント"

#. type: Plain text
#: build/C/man7/svipc.7:279
msgid ""
"A shared memory segment is uniquely identified by a positive integer (its "
"I<shmid>)  and has an associated data structure of type I<struct shmid_ds>, "
"defined in I<E<lt>sys/shm.hE<gt>>, containing the following members:"
msgstr ""
"共有メモリセグメントは正の整数 (I<shmid>)  によって識別され、 I<E<lt>sys/shm."
"hE<gt>> に定義されている I<struct shmid_ds> 構造体に結びつけられている。 この"
"構造体は以下のメンバーを含んでいる:"

#. type: Plain text
#: build/C/man7/svipc.7:292
#, no-wrap
msgid ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;\n"
"    size_t          shm_segsz;   /* size of segment */\n"
"    pid_t           shm_cpid;    /* PID of creator */\n"
"    pid_t           shm_lpid;    /* PID, last operation */\n"
"    shmatt_t        shm_nattch;  /* no. of current attaches */\n"
"    time_t          shm_atime;   /* time of last attach */\n"
"    time_t          shm_dtime;   /* time of last detach */\n"
"    time_t          shm_ctime;   /* time of last change */\n"
"};\n"
msgstr ""
"struct shmid_ds {\n"
"    struct ipc_perm shm_perm;\n"
"    size_t          shm_segsz;   /* セグメントのサイズ */\n"
"    pid_t           shm_cpid;    /* 作成者のプロセス ID */\n"
"    pid_t           shm_lpid;    /* 最後に操作したプロセス ID */\n"
"    shmatt_t        shm_nattch;  /* 現在、付加している数 */\n"
"    time_t          shm_atime;   /* 最後に付加した時間 */\n"
"    time_t          shm_dtime;   /* 最後に分離した時間 */\n"
"    time_t          shm_ctime;   /* 最後に変更した時間 */\n"
"};\n"

#. type: TP
#: build/C/man7/svipc.7:294
#, no-wrap
msgid "I<shm_perm>"
msgstr "I<shm_perm>"

#. type: Plain text
#: build/C/man7/svipc.7:299
msgid ""
"I<ipc_perm> structure that specifies the access permissions on the shared "
"memory segment."
msgstr "共有メモリセグメントへのアクセス許可を指定した I<ipc_perm> 構造体。"

#. type: TP
#: build/C/man7/svipc.7:299
#, no-wrap
msgid "I<shm_segsz>"
msgstr "I<shm_segsz>"

#. type: Plain text
#: build/C/man7/svipc.7:302
msgid "Size in bytes of the shared memory segment."
msgstr "共有メモリセグメントのバイト数。"

#. type: TP
#: build/C/man7/svipc.7:302
#, no-wrap
msgid "I<shm_cpid>"
msgstr "I<shm_cpid>"

#. type: Plain text
#: build/C/man7/svipc.7:305
msgid "ID of the process that created the shared memory segment."
msgstr "共有メモリセグメントを作成したプロセスの ID。"

#. type: TP
#: build/C/man7/svipc.7:305
#, no-wrap
msgid "I<shm_lpid>"
msgstr "I<shm_lpid>"

#. type: Plain text
#: build/C/man7/svipc.7:312
msgid ""
"ID of the last process that executed a B<shmat>(2)  or B<shmdt>(2)  system "
"call."
msgstr ""
"最後に B<shmat>(2)  または B<shmdt>(2)  システムコールを実行したプロセスの "
"ID。"

#. type: TP
#: build/C/man7/svipc.7:312
#, no-wrap
msgid "I<shm_nattch>"
msgstr "I<shm_nattch>"

#. type: Plain text
#: build/C/man7/svipc.7:315
msgid "Number of current alive attaches for this shared memory segment."
msgstr "この共有メモリセグメントをメモリに付加 (attach) しているプロセスの数。"

#. type: TP
#: build/C/man7/svipc.7:315
#, no-wrap
msgid "I<shm_atime>"
msgstr "I<shm_atime>"

#. type: Plain text
#: build/C/man7/svipc.7:320
msgid "Time of the last B<shmat>(2)  system call."
msgstr "最後に B<shmat>(2)  システムコールを行なった時間。"

#. type: TP
#: build/C/man7/svipc.7:320
#, no-wrap
msgid "I<shm_dtime>"
msgstr "I<shm_dtime>"

#. type: Plain text
#: build/C/man7/svipc.7:325
msgid "Time of the last B<shmdt>(2)  system call."
msgstr "最後に B<shmdt>(2)  システムコールを行なった時間。"

#. type: TP
#: build/C/man7/svipc.7:325
#, no-wrap
msgid "I<shm_ctime>"
msgstr "I<shm_ctime>"

#. type: Plain text
#: build/C/man7/svipc.7:331
msgid "Time of the last B<shmctl>(2)  system call that changed I<shmid_ds>."
msgstr ""
"最後に B<shmctl>(2)  システムコールを行なって、 I<shmid_ds> 構造体を変更した"
"時間。"

#. type: Plain text
#: build/C/man7/svipc.7:348
msgid ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<ipc>(2), B<msgctl>(2), B<msgget>(2), "
"B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), B<semop>(2), B<shmat>"
"(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), B<ftok>(3)"
msgstr ""
"B<ipcmk>(1), B<ipcrm>(1), B<ipcs>(1), B<ipc>(2), B<msgctl>(2), B<msgget>(2), "
"B<msgrcv>(2), B<msgsnd>(2), B<semctl>(2), B<semget>(2), B<semop>(2), B<shmat>"
"(2), B<shmctl>(2), B<shmdt>(2), B<shmget>(2), B<ftok>(3)"

#. type: TH
#: build/C/man3/ulimit.3:27
#, no-wrap
msgid "ULIMIT"
msgstr "ULIMIT"

#. type: TH
#: build/C/man3/ulimit.3:27
#, no-wrap
msgid "2008-08-06"
msgstr "2008-08-06"

#. type: Plain text
#: build/C/man3/ulimit.3:30
msgid "ulimit - get and set user limits"
msgstr "ulimit - ユーザー制限を取得・設定する"

#. type: Plain text
#: build/C/man3/ulimit.3:32
msgid "B<#include E<lt>ulimit.hE<gt>>"
msgstr "B<#include E<lt>ulimit.hE<gt>>"

#. type: Plain text
#: build/C/man3/ulimit.3:34
msgid "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"
msgstr "B<long ulimit(int >I<cmd>B<, long >I<newlimit>B<);>"

#. type: Plain text
#: build/C/man3/ulimit.3:46
msgid ""
"Warning: This routine is obsolete.  Use B<getrlimit>(2), B<setrlimit>(2), "
"and B<sysconf>(3)  instead.  For the shell command B<ulimit>(), see B<bash>"
"(1)."
msgstr ""
"注意: このルーチンは古い。 代わりに B<getrlimit>(2), B<setrlimit>(2), "
"B<sysconf>(3)  などを用いること。 シェルコマンドとしての B<ulimit>()  につい"
"ては、 B<bash>(1)  を見ること。"

#. type: Plain text
#: build/C/man3/ulimit.3:53
msgid ""
"The B<ulimit>()  call will get or set some limit for the calling process.  "
"The I<cmd> argument can have one of the following values."
msgstr ""
"B<ulimit>()  は呼び出し元のプロセスに関する制限のいくつかを取得・設定する。 "
"I<cmd> 引き数には、以下の値のうちのどれか一つを与えることができる。"

#. type: TP
#: build/C/man3/ulimit.3:53
#, no-wrap
msgid "B<UL_GETFSIZE>"
msgstr "B<UL_GETFSIZE>"

#. type: Plain text
#: build/C/man3/ulimit.3:56
msgid "Return the limit on the size of a file, in units of 512 bytes."
msgstr "ファイルサイズに関する制限を返す。単位は 512 バイト。"

#. type: TP
#: build/C/man3/ulimit.3:56
#, no-wrap
msgid "B<UL_SETFSIZE>"
msgstr "B<UL_SETFSIZE>"

#. type: Plain text
#: build/C/man3/ulimit.3:59
msgid "Set the limit on the size of a file."
msgstr "ファイルサイズに関する制限を設定する。"

#. type: TP
#: build/C/man3/ulimit.3:59
#, no-wrap
msgid "B<3>"
msgstr "B<3>"

#. type: Plain text
#: build/C/man3/ulimit.3:63
msgid ""
"(Not implemented for Linux.)  Return the maximum possible address of the "
"data segment."
msgstr ""
"(Linux では実装されていない)  データセグメントで指定できるアドレスの最大値を"
"返す。"

#. type: TP
#: build/C/man3/ulimit.3:63
#, no-wrap
msgid "B<4>"
msgstr "B<4>"

#. type: Plain text
#: build/C/man3/ulimit.3:67
msgid ""
"(Implemented but no symbolic constant provided.)  Return the maximum number "
"of files that the calling process can open."
msgstr ""
"(実装されているが、対応するシンボリックな定数は存在しない)  プロセスがオープ"
"ンできるファイル数の最大値を返す。"

#. type: Plain text
#: build/C/man3/ulimit.3:74
msgid ""
"On success, B<ulimit>()  returns a nonnegative value.  On error, -1 is "
"returned, and I<errno> is set appropriately."
msgstr ""
"成功すると B<ulimit>()  は 0 または正の値を返す。 エラーが生じると -1 を返"
"し、 I<errno> を適切な値に設定する。"

#. type: Plain text
#: build/C/man3/ulimit.3:78
msgid "A unprivileged process tried to increase a limit."
msgstr "非特権プロセスが制限値を増加させようとした。"

#. type: Plain text
#: build/C/man3/ulimit.3:83
msgid "SVr4, POSIX.1-2001.  POSIX.1-2008 marks B<ulimit>()  as obsolete."
msgstr ""
"SVr4, POSIX.1-2001.  POSIX.1-2008 は B<ulimit>()  を廃止予定としている。"

#. type: Plain text
#: build/C/man3/ulimit.3:88
msgid "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"
msgstr "B<bash>(1), B<getrlimit>(2), B<setrlimit>(2), B<sysconf>(3)"

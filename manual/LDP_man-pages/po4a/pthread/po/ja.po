# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:16+0900\n"
"PO-Revision-Date: 2012-05-28 13:00+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man2/getcontext.2:23
#, no-wrap
msgid "GETCONTEXT"
msgstr "GETCONTEXT"

#. type: TH
#: build/C/man2/getcontext.2:23
#, no-wrap
msgid "2009-03-15"
msgstr "2009-03-15"

#. type: TH
#: build/C/man2/getcontext.2:23 build/C/man3/pthread_attr_init.3:24
#: build/C/man3/pthread_attr_setaffinity_np.3:24
#: build/C/man3/pthread_attr_setdetachstate.3:24
#: build/C/man3/pthread_attr_setguardsize.3:24
#: build/C/man3/pthread_attr_setinheritsched.3:24
#: build/C/man3/pthread_attr_setschedparam.3:24
#: build/C/man3/pthread_attr_setschedpolicy.3:24
#: build/C/man3/pthread_attr_setscope.3:24
#: build/C/man3/pthread_attr_setstack.3:24
#: build/C/man3/pthread_attr_setstackaddr.3:24
#: build/C/man3/pthread_attr_setstacksize.3:24
#: build/C/man3/pthread_cancel.3:24 build/C/man3/pthread_cleanup_push.3:24
#: build/C/man3/pthread_cleanup_push_defer_np.3:24
#: build/C/man3/pthread_create.3:24 build/C/man3/pthread_detach.3:24
#: build/C/man3/pthread_equal.3:24 build/C/man3/pthread_exit.3:24
#: build/C/man3/pthread_getattr_np.3:24
#: build/C/man3/pthread_getcpuclockid.3:24 build/C/man3/pthread_join.3:24
#: build/C/man3/pthread_kill.3:24
#: build/C/man3/pthread_kill_other_threads_np.3:24
#: build/C/man3/pthread_self.3:24 build/C/man3/pthread_setaffinity_np.3:24
#: build/C/man3/pthread_setcancelstate.3:24
#: build/C/man3/pthread_setconcurrency.3:23
#: build/C/man3/pthread_setschedparam.3:24
#: build/C/man3/pthread_setschedprio.3:24 build/C/man3/pthread_sigmask.3:24
#: build/C/man3/pthread_sigqueue.3:23 build/C/man3/pthread_testcancel.3:24
#: build/C/man3/pthread_tryjoin_np.3:24 build/C/man3/pthread_yield.3:23
#: build/C/man7/pthreads.7:24
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man2/getcontext.2:23 build/C/man3/makecontext.3:25
#: build/C/man3/pthread_attr_init.3:24
#: build/C/man3/pthread_attr_setaffinity_np.3:24
#: build/C/man3/pthread_attr_setdetachstate.3:24
#: build/C/man3/pthread_attr_setguardsize.3:24
#: build/C/man3/pthread_attr_setinheritsched.3:24
#: build/C/man3/pthread_attr_setschedparam.3:24
#: build/C/man3/pthread_attr_setschedpolicy.3:24
#: build/C/man3/pthread_attr_setscope.3:24
#: build/C/man3/pthread_attr_setstack.3:24
#: build/C/man3/pthread_attr_setstackaddr.3:24
#: build/C/man3/pthread_attr_setstacksize.3:24
#: build/C/man3/pthread_cancel.3:24 build/C/man3/pthread_cleanup_push.3:24
#: build/C/man3/pthread_cleanup_push_defer_np.3:24
#: build/C/man3/pthread_create.3:24 build/C/man3/pthread_detach.3:24
#: build/C/man3/pthread_equal.3:24 build/C/man3/pthread_exit.3:24
#: build/C/man3/pthread_getattr_np.3:24
#: build/C/man3/pthread_getcpuclockid.3:24 build/C/man3/pthread_join.3:24
#: build/C/man3/pthread_kill.3:24
#: build/C/man3/pthread_kill_other_threads_np.3:24
#: build/C/man3/pthread_self.3:24 build/C/man3/pthread_setaffinity_np.3:24
#: build/C/man3/pthread_setcancelstate.3:24
#: build/C/man3/pthread_setconcurrency.3:23
#: build/C/man3/pthread_setschedparam.3:24
#: build/C/man3/pthread_setschedprio.3:24 build/C/man3/pthread_sigmask.3:24
#: build/C/man3/pthread_sigqueue.3:23 build/C/man3/pthread_testcancel.3:24
#: build/C/man3/pthread_tryjoin_np.3:24 build/C/man3/pthread_yield.3:23
#: build/C/man7/pthreads.7:24
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man2/getcontext.2:24 build/C/man3/makecontext.3:26
#: build/C/man3/pthread_attr_init.3:25
#: build/C/man3/pthread_attr_setaffinity_np.3:25
#: build/C/man3/pthread_attr_setdetachstate.3:25
#: build/C/man3/pthread_attr_setguardsize.3:25
#: build/C/man3/pthread_attr_setinheritsched.3:25
#: build/C/man3/pthread_attr_setschedparam.3:25
#: build/C/man3/pthread_attr_setschedpolicy.3:25
#: build/C/man3/pthread_attr_setscope.3:25
#: build/C/man3/pthread_attr_setstack.3:25
#: build/C/man3/pthread_attr_setstackaddr.3:25
#: build/C/man3/pthread_attr_setstacksize.3:25
#: build/C/man3/pthread_cancel.3:25 build/C/man3/pthread_cleanup_push.3:25
#: build/C/man3/pthread_cleanup_push_defer_np.3:25
#: build/C/man3/pthread_create.3:25 build/C/man3/pthread_detach.3:25
#: build/C/man3/pthread_equal.3:25 build/C/man3/pthread_exit.3:25
#: build/C/man3/pthread_getattr_np.3:25
#: build/C/man3/pthread_getcpuclockid.3:25 build/C/man3/pthread_join.3:25
#: build/C/man3/pthread_kill.3:25
#: build/C/man3/pthread_kill_other_threads_np.3:25
#: build/C/man3/pthread_self.3:25 build/C/man3/pthread_setaffinity_np.3:25
#: build/C/man3/pthread_setcancelstate.3:25
#: build/C/man3/pthread_setconcurrency.3:24
#: build/C/man3/pthread_setschedparam.3:25
#: build/C/man3/pthread_setschedprio.3:25 build/C/man3/pthread_sigmask.3:25
#: build/C/man3/pthread_sigqueue.3:24 build/C/man3/pthread_testcancel.3:25
#: build/C/man3/pthread_tryjoin_np.3:25 build/C/man3/pthread_yield.3:24
#: build/C/man7/pthreads.7:25
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man2/getcontext.2:26
msgid "getcontext, setcontext - get or set the user context"
msgstr "getcontext, setcontext - ユーザコンテキストを取得/設定する"

#. type: SH
#: build/C/man2/getcontext.2:26 build/C/man3/makecontext.3:28
#: build/C/man3/pthread_attr_init.3:28
#: build/C/man3/pthread_attr_setaffinity_np.3:28
#: build/C/man3/pthread_attr_setdetachstate.3:28
#: build/C/man3/pthread_attr_setguardsize.3:28
#: build/C/man3/pthread_attr_setinheritsched.3:28
#: build/C/man3/pthread_attr_setschedparam.3:28
#: build/C/man3/pthread_attr_setschedpolicy.3:28
#: build/C/man3/pthread_attr_setscope.3:28
#: build/C/man3/pthread_attr_setstack.3:28
#: build/C/man3/pthread_attr_setstackaddr.3:28
#: build/C/man3/pthread_attr_setstacksize.3:28
#: build/C/man3/pthread_cancel.3:27 build/C/man3/pthread_cleanup_push.3:28
#: build/C/man3/pthread_cleanup_push_defer_np.3:28
#: build/C/man3/pthread_create.3:27 build/C/man3/pthread_detach.3:27
#: build/C/man3/pthread_equal.3:27 build/C/man3/pthread_exit.3:27
#: build/C/man3/pthread_getattr_np.3:27
#: build/C/man3/pthread_getcpuclockid.3:27 build/C/man3/pthread_join.3:27
#: build/C/man3/pthread_kill.3:27
#: build/C/man3/pthread_kill_other_threads_np.3:27
#: build/C/man3/pthread_self.3:27 build/C/man3/pthread_setaffinity_np.3:28
#: build/C/man3/pthread_setcancelstate.3:28
#: build/C/man3/pthread_setconcurrency.3:27
#: build/C/man3/pthread_setschedparam.3:28
#: build/C/man3/pthread_setschedprio.3:27 build/C/man3/pthread_sigmask.3:27
#: build/C/man3/pthread_sigqueue.3:26 build/C/man3/pthread_testcancel.3:27
#: build/C/man3/pthread_tryjoin_np.3:28 build/C/man3/pthread_yield.3:26
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man2/getcontext.2:28 build/C/man3/makecontext.3:30
msgid "B<#include E<lt>ucontext.hE<gt>>"
msgstr "B<#include E<lt>ucontext.hE<gt>>"

#. type: Plain text
#: build/C/man2/getcontext.2:30
msgid "B<int getcontext(ucontext_t *>I<ucp>B<);>"
msgstr "B<int getcontext(ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: build/C/man2/getcontext.2:32
msgid "B<int setcontext(const ucontext_t *>I<ucp>B<);>"
msgstr "B<int setcontext(const ucontext_t *>I<ucp>B<);>"

#. type: SH
#: build/C/man2/getcontext.2:32 build/C/man3/makecontext.3:35
#: build/C/man3/pthread_attr_init.3:37
#: build/C/man3/pthread_attr_setaffinity_np.3:40
#: build/C/man3/pthread_attr_setdetachstate.3:39
#: build/C/man3/pthread_attr_setguardsize.3:39
#: build/C/man3/pthread_attr_setinheritsched.3:39
#: build/C/man3/pthread_attr_setschedparam.3:39
#: build/C/man3/pthread_attr_setschedpolicy.3:39
#: build/C/man3/pthread_attr_setscope.3:39
#: build/C/man3/pthread_attr_setstack.3:52
#: build/C/man3/pthread_attr_setstackaddr.3:39
#: build/C/man3/pthread_attr_setstacksize.3:39
#: build/C/man3/pthread_cancel.3:35 build/C/man3/pthread_cleanup_push.3:38
#: build/C/man3/pthread_cleanup_push_defer_np.3:38
#: build/C/man3/pthread_create.3:36 build/C/man3/pthread_detach.3:35
#: build/C/man3/pthread_equal.3:35 build/C/man3/pthread_exit.3:35
#: build/C/man3/pthread_getattr_np.3:36
#: build/C/man3/pthread_getcpuclockid.3:36 build/C/man3/pthread_join.3:35
#: build/C/man3/pthread_kill.3:35
#: build/C/man3/pthread_kill_other_threads_np.3:33
#: build/C/man3/pthread_self.3:35 build/C/man3/pthread_setaffinity_np.3:40
#: build/C/man3/pthread_setcancelstate.3:37
#: build/C/man3/pthread_setconcurrency.3:36
#: build/C/man3/pthread_setschedparam.3:39
#: build/C/man3/pthread_setschedprio.3:35 build/C/man3/pthread_sigmask.3:36
#: build/C/man3/pthread_sigqueue.3:43 build/C/man3/pthread_testcancel.3:35
#: build/C/man3/pthread_tryjoin_np.3:40 build/C/man3/pthread_yield.3:34
#: build/C/man7/pthreads.7:27
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man2/getcontext.2:44
msgid ""
"In a System V-like environment, one has the two types I<mcontext_t> and "
"I<ucontext_t> defined in I<E<lt>ucontext.hE<gt>> and the four functions "
"B<getcontext>(), B<setcontext>(), B<makecontext>(3)  and B<swapcontext>(3)  "
"that allow user-level context switching between multiple threads of control "
"within a process."
msgstr ""
"System V 的な環境では、 I<mcontext_t> および I<ucontext_t> という 2 つの型"
"と、 B<getcontext>(), B<setcontext>(), B<makecontext>(3), B<swapcontext>(3)  "
"という 4 つの関数が I<E<lt>ucontext.hE<gt>> で定義されており、あるプロセス内"
"部で制御下にある複数のスレッド間で、 ユーザレベルのコンテキスト切替えができる"
"ようになっている。"

#. type: Plain text
#: build/C/man2/getcontext.2:48
msgid ""
"The I<mcontext_t> type is machine-dependent and opaque.  The I<ucontext_t> "
"type is a structure that has at least the following fields:"
msgstr ""
"I<mcontext_t> 型はマシン依存で、外部からは隠蔽されている。 I<ucontext_t> 型は"
"構造体で、少なくとも以下の 4 つのフィールドを持つ。"

#. type: Plain text
#: build/C/man2/getcontext.2:58
#, no-wrap
msgid ""
"typedef struct ucontext {\n"
"    struct ucontext *uc_link;\n"
"    sigset_t         uc_sigmask;\n"
"    stack_t          uc_stack;\n"
"    mcontext_t       uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"
msgstr ""
"typedef struct ucontext {\n"
"    struct ucontext *uc_link;\n"
"    sigset_t         uc_sigmask;\n"
"    stack_t          uc_stack;\n"
"    mcontext_t       uc_mcontext;\n"
"    ...\n"
"} ucontext_t;\n"

#. type: Plain text
#: build/C/man2/getcontext.2:75
msgid ""
"with I<sigset_t> and I<stack_t> defined in I<E<lt>signal.hE<gt>>.  Here "
"I<uc_link> points to the context that will be resumed when the current "
"context terminates (in case the current context was created using "
"B<makecontext>(3)), I<uc_sigmask> is the set of signals blocked in this "
"context (see B<sigprocmask>(2)), I<uc_stack> is the stack used by this "
"context (see B<sigaltstack>(2)), and I<uc_mcontext> is the machine-specific "
"representation of the saved context, that includes the calling thread's "
"machine registers."
msgstr ""
"I<sigset_t> と I<stack_t> は I<E<lt>signal.hE<gt>> で定義されている。 ここで "
"I<uc_link> は、 現在のコンテキストが終了したとき、 続いて切り替わるコンテキス"
"トへのポインタである (現在のコンテキストが B<makecontext>(3)  で生成されたも"
"のの場合)。 I<uc_sigmask> はこのコンテキストでブロックされている シグナル群で"
"ある (B<sigprocmask>(2)  を見よ)。 I<uc_stack> はこのコンテキストが用いている"
"スタックである (B<signalstack>(2)  を見よ)。 I<uc_mcontext> は保存されている"
"コンテキストの マシン特有の表現形式であり、 ここには呼び出したスレッドのマシ"
"ンレジスタが格納される。"

#. type: Plain text
#: build/C/man2/getcontext.2:80
msgid ""
"The function B<getcontext>()  initializes the structure pointed at by I<ucp> "
"to the currently active context."
msgstr ""
"B<getcontext>()  関数は、 ポインタ I<ucp> が指す構造体を、 現在アクティブなコ"
"ンテキストに初期化する。"

#. type: Plain text
#: build/C/man2/getcontext.2:92
msgid ""
"The function B<setcontext>()  restores the user context pointed at by "
"I<ucp>.  A successful call does not return.  The context should have been "
"obtained by a call of B<getcontext>(), or B<makecontext>(3), or passed as "
"third argument to a signal handler."
msgstr ""
"B<setcontext>()  関数は、ポインタ I<ucp> が指すユーザコンテキストをリストアす"
"る。 呼び出しに成功すると返らない。 このコンテキストは、以前に B<getcontext>"
"()  または B<makecontext>(3)  で得られたものか、 あるいはシグナルの第三引数と"
"して与えられたものになる。"

#. type: Plain text
#: build/C/man2/getcontext.2:96
msgid ""
"If the context was obtained by a call of B<getcontext>(), program execution "
"continues as if this call just returned."
msgstr ""
"コンテキストが B<getcontext>()  の呼び出しによって得られていたものの場合は、 "
"プログラムはこの呼び出しから返った直後からのように実行を継続する。"

#. type: Plain text
#: build/C/man2/getcontext.2:107
msgid ""
"If the context was obtained by a call of B<makecontext>(3), program "
"execution continues by a call to the function I<func> specified as the "
"second argument of that call to B<makecontext>(3).  When the function "
"I<func> returns, we continue with the I<uc_link> member of the structure "
"I<ucp> specified as the first argument of that call to B<makecontext>(3).  "
"When this member is NULL, the thread exits."
msgstr ""
"コンテキストが B<makecontext>(3)  の呼び出しによって得られていたものの場合"
"は、 プログラムの実行はその B<makecontext>(3)  呼び出しの第二引数で指定された"
"関数 I<func> を呼び出すかたちで継続する。 I<func> から返ると、 B<makecontext>"
"(3)  呼び出しの第一引数で指定されていた I<ucp> 構造体の I<uc_link> メンバで継"
"続する。 このメンバが NULL だった場合は、そのスレッドは終了する。"

#. type: Plain text
#: build/C/man2/getcontext.2:114
msgid ""
"If the context was obtained by a call to a signal handler, then old standard "
"text says that \"program execution continues with the program instruction "
"following the instruction interrupted by the signal\".  However, this "
"sentence was removed in SUSv2, and the present verdict is \"the result is "
"unspecified\"."
msgstr ""
"コンテキストがシグナルハンドラの呼び出しによって得られていたものの場合は、 古"
"い標準によれば 「プログラムの実行はシグナルによって割り込まれた命令の次の命令"
"から継続される」。 しかしこの文は SUSv2 で削除されたので、 現在の判断は「結果"
"は定義されていない」である。"

#. type: SH
#: build/C/man2/getcontext.2:114 build/C/man3/makecontext.3:81
#: build/C/man3/pthread_attr_init.3:66
#: build/C/man3/pthread_attr_setaffinity_np.3:74
#: build/C/man3/pthread_attr_setdetachstate.3:75
#: build/C/man3/pthread_attr_setguardsize.3:88
#: build/C/man3/pthread_attr_setinheritsched.3:82
#: build/C/man3/pthread_attr_setschedparam.3:72
#: build/C/man3/pthread_attr_setschedpolicy.3:70
#: build/C/man3/pthread_attr_setscope.3:89
#: build/C/man3/pthread_attr_setstack.3:83
#: build/C/man3/pthread_attr_setstackaddr.3:72
#: build/C/man3/pthread_attr_setstacksize.3:59
#: build/C/man3/pthread_cancel.3:107 build/C/man3/pthread_cleanup_push.3:117
#: build/C/man3/pthread_create.3:113 build/C/man3/pthread_detach.3:47
#: build/C/man3/pthread_equal.3:39 build/C/man3/pthread_exit.3:69
#: build/C/man3/pthread_getattr_np.3:71
#: build/C/man3/pthread_getcpuclockid.3:44 build/C/man3/pthread_join.3:68
#: build/C/man3/pthread_kill.3:50 build/C/man3/pthread_self.3:44
#: build/C/man3/pthread_setaffinity_np.3:75
#: build/C/man3/pthread_setcancelstate.3:90
#: build/C/man3/pthread_setconcurrency.3:54
#: build/C/man3/pthread_setschedparam.3:102
#: build/C/man3/pthread_setschedprio.3:51 build/C/man3/pthread_sigmask.3:47
#: build/C/man3/pthread_sigqueue.3:63 build/C/man3/pthread_testcancel.3:48
#: build/C/man3/pthread_tryjoin_np.3:83 build/C/man3/pthread_yield.3:41
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man2/getcontext.2:122
msgid ""
"When successful, B<getcontext>()  returns 0 and B<setcontext>()  does not "
"return.  On error, both return -1 and set I<errno> appropriately."
msgstr ""
"成功すると、 B<getcontext>()  は 0 を返し、 B<setcontext>()  は返らない。 失"
"敗すると、両者とも -1 を返し、I<errno> をエラーに応じて設定する。"

#. type: SH
#: build/C/man2/getcontext.2:122 build/C/man3/makecontext.3:93
#: build/C/man3/pthread_attr_init.3:69
#: build/C/man3/pthread_attr_setaffinity_np.3:77
#: build/C/man3/pthread_attr_setdetachstate.3:78
#: build/C/man3/pthread_attr_setguardsize.3:91
#: build/C/man3/pthread_attr_setinheritsched.3:85
#: build/C/man3/pthread_attr_setschedparam.3:75
#: build/C/man3/pthread_attr_setschedpolicy.3:73
#: build/C/man3/pthread_attr_setscope.3:92
#: build/C/man3/pthread_attr_setstack.3:86
#: build/C/man3/pthread_attr_setstackaddr.3:75
#: build/C/man3/pthread_attr_setstacksize.3:62
#: build/C/man3/pthread_cancel.3:112 build/C/man3/pthread_cleanup_push.3:119
#: build/C/man3/pthread_create.3:120 build/C/man3/pthread_detach.3:52
#: build/C/man3/pthread_equal.3:43 build/C/man3/pthread_exit.3:71
#: build/C/man3/pthread_getattr_np.3:74
#: build/C/man3/pthread_getcpuclockid.3:47 build/C/man3/pthread_join.3:73
#: build/C/man3/pthread_kill.3:55 build/C/man3/pthread_self.3:46
#: build/C/man3/pthread_setaffinity_np.3:78
#: build/C/man3/pthread_setcancelstate.3:93
#: build/C/man3/pthread_setconcurrency.3:66
#: build/C/man3/pthread_setschedparam.3:110
#: build/C/man3/pthread_setschedprio.3:59 build/C/man3/pthread_sigmask.3:52
#: build/C/man3/pthread_sigqueue.3:68 build/C/man3/pthread_testcancel.3:52
#: build/C/man3/pthread_tryjoin_np.3:87 build/C/man3/pthread_yield.3:46
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man2/getcontext.2:124
msgid "None defined."
msgstr "定義されていない。"

#. type: SH
#: build/C/man2/getcontext.2:124 build/C/man3/makecontext.3:102
#: build/C/man3/pthread_attr_init.3:77
#: build/C/man3/pthread_attr_setaffinity_np.3:106
#: build/C/man3/pthread_attr_setdetachstate.3:85
#: build/C/man3/pthread_attr_setguardsize.3:104
#: build/C/man3/pthread_attr_setinheritsched.3:99
#: build/C/man3/pthread_attr_setschedparam.3:87
#: build/C/man3/pthread_attr_setschedpolicy.3:87
#: build/C/man3/pthread_attr_setscope.3:105
#: build/C/man3/pthread_attr_setstack.3:110
#: build/C/man3/pthread_attr_setstackaddr.3:81
#: build/C/man3/pthread_attr_setstacksize.3:81
#: build/C/man3/pthread_cancel.3:120 build/C/man3/pthread_cleanup_push.3:123
#: build/C/man3/pthread_cleanup_push_defer_np.3:99
#: build/C/man3/pthread_create.3:144 build/C/man3/pthread_detach.3:62
#: build/C/man3/pthread_equal.3:45 build/C/man3/pthread_exit.3:73
#: build/C/man3/pthread_getattr_np.3:96
#: build/C/man3/pthread_getcpuclockid.3:63 build/C/man3/pthread_join.3:96
#: build/C/man3/pthread_kill.3:64
#: build/C/man3/pthread_kill_other_threads_np.3:45
#: build/C/man3/pthread_self.3:48 build/C/man3/pthread_setaffinity_np.3:119
#: build/C/man3/pthread_setcancelstate.3:111
#: build/C/man3/pthread_setconcurrency.3:81
#: build/C/man3/pthread_setschedparam.3:139
#: build/C/man3/pthread_setschedprio.3:81 build/C/man3/pthread_sigmask.3:55
#: build/C/man3/pthread_sigqueue.3:91 build/C/man3/pthread_testcancel.3:56
#: build/C/man3/pthread_tryjoin_np.3:110 build/C/man3/pthread_yield.3:50
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man2/getcontext.2:130
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specification of B<getcontext>"
"(), citing portability issues, and recommending that applications be "
"rewritten to use POSIX threads instead."
msgstr ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 では、移植性の問題から B<getcontext>()  の"
"仕様が削除された。 代わりに、アプリケーションを POSIX スレッドを使って書き直"
"すことが 推奨されている。"

#. type: SH
#: build/C/man2/getcontext.2:130 build/C/man3/makecontext.3:110
#: build/C/man3/pthread_attr_init.3:79
#: build/C/man3/pthread_attr_setaffinity_np.3:109
#: build/C/man3/pthread_attr_setdetachstate.3:87
#: build/C/man3/pthread_attr_setguardsize.3:106
#: build/C/man3/pthread_attr_setschedparam.3:89
#: build/C/man3/pthread_attr_setscope.3:107
#: build/C/man3/pthread_attr_setstack.3:112
#: build/C/man3/pthread_attr_setstackaddr.3:84
#: build/C/man3/pthread_attr_setstacksize.3:83
#: build/C/man3/pthread_cancel.3:122 build/C/man3/pthread_cleanup_push.3:125
#: build/C/man3/pthread_create.3:146 build/C/man3/pthread_detach.3:64
#: build/C/man3/pthread_equal.3:47 build/C/man3/pthread_exit.3:75
#: build/C/man3/pthread_getcpuclockid.3:65 build/C/man3/pthread_join.3:98
#: build/C/man3/pthread_kill.3:66
#: build/C/man3/pthread_kill_other_threads_np.3:48
#: build/C/man3/pthread_self.3:50 build/C/man3/pthread_setaffinity_np.3:122
#: build/C/man3/pthread_setcancelstate.3:113
#: build/C/man3/pthread_setconcurrency.3:83
#: build/C/man3/pthread_setschedparam.3:141
#: build/C/man3/pthread_setschedprio.3:83 build/C/man3/pthread_sigmask.3:57
#: build/C/man3/pthread_yield.3:56
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man2/getcontext.2:147
msgid ""
"The earliest incarnation of this mechanism was the B<setjmp>(3)/B<longjmp>"
"(3)  mechanism.  Since that does not define the handling of the signal "
"context, the next stage was the B<sigsetjmp>(3)/B<siglongjmp>(3)  pair.  The "
"present mechanism gives much more control.  On the other hand, there is no "
"easy way to detect whether a return from B<getcontext>()  is from the first "
"call, or via a B<setcontext>()  call.  The user has to invent her own "
"bookkeeping device, and a register variable won't do since registers are "
"restored."
msgstr ""
"このメカニズムの最古の実装は、 B<setjmp>(3)/B<longjmp>(3)  機構であった。 こ"
"れらにはシグナルコンテキストの取り扱いが定義されていなかったので、 次の段階で"
"は B<sigsetjmp>(3)/B<siglongjmp>(3)  のペアが現われた。 現在の機構ではずっと"
"細かな制御ができる。 一方 B<getcontext>()  から返ったとき、 これが最初の呼び"
"出しであったか、 それとも B<setcontext>()  呼び出しからのものであるかを 区別"
"する容易な方法がなくなってしまった。 ユーザは「しおり」機構を自分で作らなけれ"
"ばならない。 レジスタ変数は (レジスタはリストアされてしまうので) これをやって"
"くれない。"

#. type: Plain text
#: build/C/man2/getcontext.2:158
msgid ""
"When a signal occurs, the current user context is saved and a new context is "
"created by the kernel for the signal handler.  Do not leave the handler "
"using B<longjmp>(3): it is undefined what would happen with contexts.  Use "
"B<siglongjmp>(3)  or B<setcontext>()  instead."
msgstr ""
"シグナルが発生すると、 現在のユーザコンテキストは保存され、 シグナルハンドラ"
"用のコンテキストがカーネルによって生成される。 今後はハンドラに B<longjmp>"
"(3)  を使わせないこと: この関数のコンテキスト下での動作は定義されていない。 "
"代わりに B<siglongjmp>(3)  か B<setcontext>()  を使うこと。"

#. type: SH
#: build/C/man2/getcontext.2:158 build/C/man3/makecontext.3:217
#: build/C/man3/pthread_attr_init.3:295
#: build/C/man3/pthread_attr_setaffinity_np.3:116
#: build/C/man3/pthread_attr_setdetachstate.3:109
#: build/C/man3/pthread_attr_setguardsize.3:156
#: build/C/man3/pthread_attr_setinheritsched.3:120
#: build/C/man3/pthread_attr_setschedparam.3:96
#: build/C/man3/pthread_attr_setschedpolicy.3:92
#: build/C/man3/pthread_attr_setscope.3:118
#: build/C/man3/pthread_attr_setstack.3:154
#: build/C/man3/pthread_attr_setstackaddr.3:108
#: build/C/man3/pthread_attr_setstacksize.3:109
#: build/C/man3/pthread_cancel.3:221 build/C/man3/pthread_cleanup_push.3:309
#: build/C/man3/pthread_cleanup_push_defer_np.3:102
#: build/C/man3/pthread_create.3:367 build/C/man3/pthread_detach.3:95
#: build/C/man3/pthread_equal.3:54 build/C/man3/pthread_exit.3:103
#: build/C/man3/pthread_getattr_np.3:343
#: build/C/man3/pthread_getcpuclockid.3:167 build/C/man3/pthread_join.3:125
#: build/C/man3/pthread_kill.3:73
#: build/C/man3/pthread_kill_other_threads_np.3:64
#: build/C/man3/pthread_self.3:74 build/C/man3/pthread_setaffinity_np.3:204
#: build/C/man3/pthread_setcancelstate.3:175
#: build/C/man3/pthread_setconcurrency.3:98
#: build/C/man3/pthread_setschedparam.3:429
#: build/C/man3/pthread_setschedprio.3:89 build/C/man3/pthread_sigmask.3:133
#: build/C/man3/pthread_sigqueue.3:93 build/C/man3/pthread_testcancel.3:61
#: build/C/man3/pthread_tryjoin_np.3:133 build/C/man3/pthread_yield.3:59
#: build/C/man7/pthreads.7:893
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man2/getcontext.2:165
msgid ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3)"
msgstr ""
"B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), B<longjmp>(3), "
"B<makecontext>(3), B<sigsetjmp>(3)"

#. type: SH
#: build/C/man2/getcontext.2:165 build/C/man3/makecontext.3:223
#: build/C/man3/pthread_attr_init.3:309
#: build/C/man3/pthread_attr_setaffinity_np.3:122
#: build/C/man3/pthread_attr_setdetachstate.3:115
#: build/C/man3/pthread_attr_setguardsize.3:164
#: build/C/man3/pthread_attr_setinheritsched.3:129
#: build/C/man3/pthread_attr_setschedparam.3:106
#: build/C/man3/pthread_attr_setschedpolicy.3:101
#: build/C/man3/pthread_attr_setscope.3:126
#: build/C/man3/pthread_attr_setstack.3:164
#: build/C/man3/pthread_attr_setstackaddr.3:114
#: build/C/man3/pthread_attr_setstacksize.3:116
#: build/C/man3/pthread_cancel.3:231 build/C/man3/pthread_cleanup_push.3:315
#: build/C/man3/pthread_cleanup_push_defer_np.3:108
#: build/C/man3/pthread_create.3:378 build/C/man3/pthread_detach.3:102
#: build/C/man3/pthread_equal.3:58 build/C/man3/pthread_exit.3:107
#: build/C/man3/pthread_getattr_np.3:357
#: build/C/man3/pthread_getcpuclockid.3:175 build/C/man3/pthread_join.3:132
#: build/C/man3/pthread_kill.3:82
#: build/C/man3/pthread_kill_other_threads_np.3:70
#: build/C/man3/pthread_self.3:78 build/C/man3/pthread_setaffinity_np.3:212
#: build/C/man3/pthread_setcancelstate.3:180
#: build/C/man3/pthread_setconcurrency.3:101
#: build/C/man3/pthread_setschedparam.3:441
#: build/C/man3/pthread_setschedprio.3:101 build/C/man3/pthread_sigmask.3:142
#: build/C/man3/pthread_sigqueue.3:101 build/C/man3/pthread_testcancel.3:66
#: build/C/man3/pthread_tryjoin_np.3:138 build/C/man3/pthread_yield.3:63
#: build/C/man7/pthreads.7:927
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man2/getcontext.2:172 build/C/man3/makecontext.3:230
#: build/C/man3/pthread_attr_init.3:316
#: build/C/man3/pthread_attr_setaffinity_np.3:129
#: build/C/man3/pthread_attr_setdetachstate.3:122
#: build/C/man3/pthread_attr_setguardsize.3:171
#: build/C/man3/pthread_attr_setinheritsched.3:136
#: build/C/man3/pthread_attr_setschedparam.3:113
#: build/C/man3/pthread_attr_setschedpolicy.3:108
#: build/C/man3/pthread_attr_setscope.3:133
#: build/C/man3/pthread_attr_setstack.3:171
#: build/C/man3/pthread_attr_setstackaddr.3:121
#: build/C/man3/pthread_attr_setstacksize.3:123
#: build/C/man3/pthread_cancel.3:238 build/C/man3/pthread_cleanup_push.3:322
#: build/C/man3/pthread_cleanup_push_defer_np.3:115
#: build/C/man3/pthread_create.3:385 build/C/man3/pthread_detach.3:109
#: build/C/man3/pthread_equal.3:65 build/C/man3/pthread_exit.3:114
#: build/C/man3/pthread_getattr_np.3:364
#: build/C/man3/pthread_getcpuclockid.3:182 build/C/man3/pthread_join.3:139
#: build/C/man3/pthread_kill.3:89
#: build/C/man3/pthread_kill_other_threads_np.3:77
#: build/C/man3/pthread_self.3:85 build/C/man3/pthread_setaffinity_np.3:219
#: build/C/man3/pthread_setcancelstate.3:187
#: build/C/man3/pthread_setconcurrency.3:108
#: build/C/man3/pthread_setschedparam.3:448
#: build/C/man3/pthread_setschedprio.3:108 build/C/man3/pthread_sigmask.3:149
#: build/C/man3/pthread_sigqueue.3:108 build/C/man3/pthread_testcancel.3:73
#: build/C/man3/pthread_tryjoin_np.3:145 build/C/man3/pthread_yield.3:70
#: build/C/man7/pthreads.7:934
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.41 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/makecontext.3:25
#, no-wrap
msgid "MAKECONTEXT"
msgstr "MAKECONTEXT"

#. type: TH
#: build/C/man3/makecontext.3:25
#, no-wrap
msgid "2009-03-31"
msgstr "2009-03-31"

#. type: TH
#: build/C/man3/makecontext.3:25
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/makecontext.3:28
msgid "makecontext, swapcontext - manipulate user context"
msgstr "makecontext, swapcontext - ユーザコンテキストを操作する"

#. type: Plain text
#: build/C/man3/makecontext.3:33
msgid ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"
msgstr ""
"B<void makecontext(ucontext_t *>I<ucp>B<, void (*>I<func>B<)(),> B<int "
">I<argc>B<, ...);>"

#. type: Plain text
#: build/C/man3/makecontext.3:35
msgid "B<int swapcontext(ucontext_t *>I<oucp>B<, ucontext_t *>I<ucp>B<);>"
msgstr "B<int swapcontext(ucontext_t *>I<oucp>B<, ucontext_t *>I<ucp>B<);>"

#. type: Plain text
#: build/C/man3/makecontext.3:46
msgid ""
"In a System V-like environment, one has the type I<ucontext_t> defined in "
"I<E<lt>ucontext.hE<gt>> and the four functions B<getcontext>(2), "
"B<setcontext>(2), B<makecontext>()  and B<swapcontext>()  that allow user-"
"level context switching between multiple threads of control within a process."
msgstr ""
"System V 的な環境では、 B<mcontext_t> および B<ucontext_t> という 2 つの型"
"と、 B<getcontext>(2), B<setcontext>(2), B<makecontext>(), B<swapcontext>()  "
"という 4 つの関数が I<E<lt>ucontext.hE<gt>> で定義されており、あるプロセス内"
"部で制御下にある複数のスレッド間で、 ユーザレベルのコンテキスト切替えができる"
"ようになっている。"

#. type: Plain text
#: build/C/man3/makecontext.3:49
msgid "For the type and the first two functions, see B<getcontext>(2)."
msgstr ""
"これらの型と、最初の 2 つの関数については、 B<getcontext>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man3/makecontext.3:61
msgid ""
"The B<makecontext>()  function modifies the context pointed to by I<ucp> "
"(which was obtained from a call to B<getcontext>(2)).  Before invoking "
"B<makecontext>(), the caller must allocate a new stack for this context and "
"assign its address to I<ucp-E<gt>uc_stack>, and define a successor context "
"and assign its address to I<ucp-E<gt>uc_link>."
msgstr ""
"B<makecontext>()  関数は、ポインタ I<ucp> が指すコンテキストを変更する "
"(I<ucp> は以前の B<getcontext>(2)  呼び出しで得られたものである)。 "
"B<makecontext>()  を起動する前には、呼び出し者は、このコンテキスト用に 新しい"
"スタックを確保し、そのアドレスを I<ucp-E<gt>uc_stack> に代入し、 さらに後継の"
"コンテキストを定義し、そのアドレスを I<ucp-E<gt>uc_link> に 代入しなければな"
"らない。"

#. type: Plain text
#: build/C/man3/makecontext.3:75
msgid ""
"When this context is later activated (using B<setcontext>(2)  or "
"B<swapcontext>())  the function I<func> is called, and passed the series of "
"integer (I<int>)  arguments that follow I<argc>; the caller must specify the "
"number of these arguments in I<argc>.  When this function returns, the "
"successor context is activated.  If the successor context pointer is NULL, "
"the thread exits."
msgstr ""
"このコンテキストが将来 (B<setcontext>(2)  または B<swapcontext>()  によっ"
"て)  有効にされると、関数 I<func> が呼ばれ、 引き数として I<argc> 以降の整数 "
"(I<int>)  引き数の列が渡される。 呼び出し者は I<argc> にこれらの引き数の個数"
"を指定しなければならない。 この関数が戻ると、後継のコンテキストが有効にな"
"る。 後継コンテキストのポインタが NULL の場合、そのスレッドが終了する。"

#. type: Plain text
#: build/C/man3/makecontext.3:81
msgid ""
"The B<swapcontext>()  function saves the current context in the structure "
"pointed to by I<oucp>, and then activates the context pointed to by I<ucp>."
msgstr ""
"B<swapcontext>()  関数は現在のコンテキストを ポインタ I<oucp> が指す構造体に"
"保存し、 ポインタ I<ucp> が指すコンテキストを有効にする。"

#. type: Plain text
#: build/C/man3/makecontext.3:93
msgid ""
"When successful, B<swapcontext>()  does not return.  (But we may return "
"later, in case I<oucp> is activated, in which case it looks like "
"B<swapcontext>()  returns 0.)  On error, B<swapcontext>()  returns -1 and "
"sets I<errno> appropriately."
msgstr ""
"成功すると、 B<swapcontext>()  は返らない (しかし後に I<oucp> が有効になった"
"場合には返ることがある。 このときには B<swapcontext>()  は 0 を返すように見え"
"る。)  失敗すると、 B<swapcontext>()  は -1 を返し、 I<errno> をエラーに応じ"
"て設定する。"

#. type: TP
#: build/C/man3/makecontext.3:94
#: build/C/man3/pthread_attr_setaffinity_np.3:100
#: build/C/man3/pthread_getattr_np.3:75
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/makecontext.3:97
msgid "Insufficient stack space left."
msgstr "スタックに割り当てる空間が残っていない。"

#. type: SH
#: build/C/man3/makecontext.3:97
#: build/C/man3/pthread_attr_setaffinity_np.3:104
#: build/C/man3/pthread_attr_setguardsize.3:102
#: build/C/man3/pthread_attr_setstack.3:108
#: build/C/man3/pthread_attr_setstackaddr.3:79
#: build/C/man3/pthread_attr_setstacksize.3:79
#: build/C/man3/pthread_getattr_np.3:94
#: build/C/man3/pthread_getcpuclockid.3:61
#: build/C/man3/pthread_setaffinity_np.3:117
#: build/C/man3/pthread_setconcurrency.3:79
#: build/C/man3/pthread_setschedprio.3:79 build/C/man3/pthread_sigqueue.3:87
#: build/C/man3/pthread_tryjoin_np.3:108
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#. type: Plain text
#: build/C/man3/makecontext.3:102
msgid ""
"B<makecontext>()  and B<swapcontext>()  are provided in glibc since version "
"2.1."
msgstr ""
"B<makecontext>()  と B<swapcontext>()  は、バージョン 2.1 以降の glibc で提供"
"されている。"

#. type: Plain text
#: build/C/man3/makecontext.3:110
msgid ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 removes the specifications of "
"B<makecontext>()  and B<swapcontext>(), citing portability issues, and "
"recommending that applications be rewritten to use POSIX threads instead."
msgstr ""
"SUSv2, POSIX.1-2001.  POSIX.1-2008 では、移植性の問題から B<makecontext>()  "
"と B<swapcontext>()  の仕様が削除されている。 代わりに、アプリケーションを "
"POSIX スレッドを使って書き直すことが 推奨されている。"

#. type: Plain text
#: build/C/man3/makecontext.3:118
msgid ""
"The interpretation of I<ucp-E<gt>uc_stack> is just as in B<sigaltstack>(2), "
"namely, this struct contains the start and length of a memory area to be "
"used as the stack, regardless of the direction of growth of the stack.  "
"Thus, it is not necessary for the user program to worry about this direction."
msgstr ""
"I<ucp-E<gt>uc_stack> の解釈は B<sigaltstack>(2)  の場合と同じである。 すなわ"
"ちこの構造体には、 スタックとして用いられるメモリ領域の開始アドレスと長さが含"
"まれ、 これはスタックが伸びる方向がどちらであるかには関係しない。 したがっ"
"て、ユーザプログラムはこの件については心配しなくてよい。"

#. type: Plain text
#: build/C/man3/makecontext.3:134
msgid ""
"On architectures where I<int> and pointer types are the same size (e.g., "
"x86-32, where both types are 32 bits), you may be able to get away with "
"passing pointers as arguments to B<makecontext>()  following I<argc>.  "
"However, doing this is not guaranteed to be portable, is undefined according "
"to the standards, and won't work on architectures where pointers are larger "
"than I<int>s.  Nevertheless, starting with version 2.8, glibc makes some "
"changes to B<makecontext>(), to permit this on some 64-bit architectures (e."
"g., x86-64)."
msgstr ""
"I<int> とポインタ型が同じ大きさであるアーキテクチャでは (x86-32 はその例であ"
"り、両方の型とも 32 ビットである)、 B<makecontext>()  の I<argc> 以降の引き数"
"としてポインタを渡してもうまく動くかもしれない。 しかしながら、このようにする"
"と、移植性は保証されず、 標準に従えば動作は未定義であり、ポインタが I<int> よ"
"りも大きいアーキテクチャでは正しく動作しないことだろう。 それにも関わらず、"
"バージョン 2.8 以降の glibc では、 B<makecontext>()  に変更が行われ、(x86-64 "
"などの) いくつかの 64 ビットアーキテクチャで 引き数としてポインタを渡すことが"
"できるようになっている。"

#. type: SH
#: build/C/man3/makecontext.3:134 build/C/man3/pthread_attr_init.3:85
#: build/C/man3/pthread_attr_setdetachstate.3:106
#: build/C/man3/pthread_attr_setguardsize.3:153
#: build/C/man3/pthread_attr_setinheritsched.3:117
#: build/C/man3/pthread_attr_setschedparam.3:93
#: build/C/man3/pthread_attr_setschedpolicy.3:89
#: build/C/man3/pthread_attr_setstack.3:151
#: build/C/man3/pthread_attr_setstacksize.3:106
#: build/C/man3/pthread_cancel.3:130 build/C/man3/pthread_cleanup_push.3:149
#: build/C/man3/pthread_create.3:200 build/C/man3/pthread_detach.3:91
#: build/C/man3/pthread_getattr_np.3:99
#: build/C/man3/pthread_getcpuclockid.3:76 build/C/man3/pthread_join.3:122
#: build/C/man3/pthread_setaffinity_np.3:152
#: build/C/man3/pthread_setcancelstate.3:172
#: build/C/man3/pthread_setschedparam.3:147 build/C/man3/pthread_sigmask.3:59
#: build/C/man3/pthread_testcancel.3:58 build/C/man3/pthread_tryjoin_np.3:113
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/makecontext.3:142
msgid ""
"The example program below demonstrates the use of B<getcontext>(2), "
"B<makecontext>(), and B<swapcontext>().  Running the program produces the "
"following output:"
msgstr ""
"以下のサンプル・プログラムは、 B<getcontext>(2), B<makecontext>(), "
"B<swapcontext>()  の使用方法の例を示すものである。 このプログラムを実行する"
"と、以下のような出力が得られる:"

#. type: Plain text
#: build/C/man3/makecontext.3:154
#, no-wrap
msgid ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"
msgstr ""
"$B< ./a.out>\n"
"main: swapcontext(&uctx_main, &uctx_func2)\n"
"func2: started\n"
"func2: swapcontext(&uctx_func2, &uctx_func1)\n"
"func1: started\n"
"func1: swapcontext(&uctx_func1, &uctx_func2)\n"
"func2: returning\n"
"func1: returning\n"
"main: exiting\n"

#. type: SS
#: build/C/man3/makecontext.3:156 build/C/man3/pthread_attr_init.3:146
#: build/C/man3/pthread_cancel.3:146 build/C/man3/pthread_cleanup_push.3:225
#: build/C/man3/pthread_create.3:239 build/C/man3/pthread_getattr_np.3:177
#: build/C/man3/pthread_getcpuclockid.3:93
#: build/C/man3/pthread_setschedparam.3:222 build/C/man3/pthread_sigmask.3:77
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/makecontext.3:162
#, no-wrap
msgid ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
msgstr ""
"#include E<lt>ucontext.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"

#. type: Plain text
#: build/C/man3/makecontext.3:164
#, no-wrap
msgid "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"
msgstr "static ucontext_t uctx_main, uctx_func1, uctx_func2;\n"

#. type: Plain text
#: build/C/man3/makecontext.3:167
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/makecontext.3:177
#, no-wrap
msgid ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"
msgstr ""
"static void\n"
"func1(void)\n"
"{\n"
"    printf(\"func1: started\\en\");\n"
"    printf(\"func1: swapcontext(&uctx_func1, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_func1, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func1: returning\\en\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/makecontext.3:187
#, no-wrap
msgid ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"
msgstr ""
"static void\n"
"func2(void)\n"
"{\n"
"    printf(\"func2: started\\en\");\n"
"    printf(\"func2: swapcontext(&uctx_func2, &uctx_func1)\\en\");\n"
"    if (swapcontext(&uctx_func2, &uctx_func1) == -1)\n"
"        handle_error(\"swapcontext\");\n"
"    printf(\"func2: returning\\en\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/makecontext.3:193
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    char func1_stack[16384];\n"
"    char func2_stack[16384];\n"

#. type: Plain text
#: build/C/man3/makecontext.3:200
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"
msgstr ""
"    if (getcontext(&uctx_func1) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func1.uc_stack.ss_sp = func1_stack;\n"
"    uctx_func1.uc_stack.ss_size = sizeof(func1_stack);\n"
"    uctx_func1.uc_link = &uctx_main;\n"
"    makecontext(&uctx_func1, func1, 0);\n"

#. type: Plain text
#: build/C/man3/makecontext.3:208
#, no-wrap
msgid ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"
msgstr ""
"    if (getcontext(&uctx_func2) == -1)\n"
"        handle_error(\"getcontext\");\n"
"    uctx_func2.uc_stack.ss_sp = func2_stack;\n"
"    uctx_func2.uc_stack.ss_size = sizeof(func2_stack);\n"
"    /* Successor context is f1(), unless argc E<gt> 1 */\n"
"    uctx_func2.uc_link = (argc E<gt> 1) ? NULL : &uctx_func1;\n"
"    makecontext(&uctx_func2, func2, 0);\n"

#. type: Plain text
#: build/C/man3/makecontext.3:212
#, no-wrap
msgid ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"
msgstr ""
"    printf(\"main: swapcontext(&uctx_main, &uctx_func2)\\en\");\n"
"    if (swapcontext(&uctx_main, &uctx_func2) == -1)\n"
"        handle_error(\"swapcontext\");\n"

#. type: Plain text
#: build/C/man3/makecontext.3:216
#, no-wrap
msgid ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    printf(\"main: exiting\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/makecontext.3:223
msgid ""
"B<getcontext>(2), B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), "
"B<sigsetjmp>(3)"
msgstr ""
"B<getcontext>(2), B<sigaction>(2), B<sigaltstack>(2), B<sigprocmask>(2), "
"B<sigsetjmp>(3)"

#. type: TH
#: build/C/man3/pthread_attr_init.3:24
#, no-wrap
msgid "PTHREAD_ATTR_INIT"
msgstr "PTHREAD_ATTR_INIT"

#. type: TH
#: build/C/man3/pthread_attr_init.3:24
#, no-wrap
msgid "2008-11-11"
msgstr "2008-11-11"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:28
msgid ""
"pthread_attr_init, pthread_attr_destroy - initialize and destroy thread "
"attributes object"
msgstr ""
"pthread_attr_init, pthread_attr_destroy - \n"
"スレッド属性オブジェクトの初期化と破棄を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:31
#: build/C/man3/pthread_attr_setdetachstate.3:31
#: build/C/man3/pthread_attr_setguardsize.3:31
#: build/C/man3/pthread_attr_setinheritsched.3:31
#: build/C/man3/pthread_attr_setschedparam.3:31
#: build/C/man3/pthread_attr_setschedpolicy.3:31
#: build/C/man3/pthread_attr_setscope.3:31
#: build/C/man3/pthread_attr_setstack.3:31
#: build/C/man3/pthread_attr_setstackaddr.3:31
#: build/C/man3/pthread_attr_setstacksize.3:31
#: build/C/man3/pthread_cancel.3:30 build/C/man3/pthread_cleanup_push.3:31
#: build/C/man3/pthread_cleanup_push_defer_np.3:31
#: build/C/man3/pthread_create.3:30 build/C/man3/pthread_detach.3:30
#: build/C/man3/pthread_equal.3:30 build/C/man3/pthread_exit.3:30
#: build/C/man3/pthread_join.3:30
#: build/C/man3/pthread_kill_other_threads_np.3:30
#: build/C/man3/pthread_self.3:30 build/C/man3/pthread_setcancelstate.3:31
#: build/C/man3/pthread_setconcurrency.3:30
#: build/C/man3/pthread_setschedparam.3:31
#: build/C/man3/pthread_setschedprio.3:30 build/C/man3/pthread_sigqueue.3:29
#: build/C/man3/pthread_testcancel.3:30 build/C/man3/pthread_yield.3:29
#, no-wrap
msgid "B<#include E<lt>pthread.hE<gt>>\n"
msgstr "B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:34
#, no-wrap
msgid ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"
msgstr ""
"B<int pthread_attr_init(pthread_attr_t *>I<attr>B<);>\n"
"B<int pthread_attr_destroy(pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:36
#: build/C/man3/pthread_attr_setaffinity_np.3:39
#: build/C/man3/pthread_attr_setdetachstate.3:38
#: build/C/man3/pthread_attr_setguardsize.3:38
#: build/C/man3/pthread_attr_setinheritsched.3:38
#: build/C/man3/pthread_attr_setschedparam.3:38
#: build/C/man3/pthread_attr_setschedpolicy.3:38
#: build/C/man3/pthread_attr_setscope.3:38
#: build/C/man3/pthread_attr_setstack.3:38
#: build/C/man3/pthread_attr_setstackaddr.3:38
#: build/C/man3/pthread_attr_setstacksize.3:38
#: build/C/man3/pthread_cancel.3:34 build/C/man3/pthread_cleanup_push.3:37
#: build/C/man3/pthread_equal.3:34 build/C/man3/pthread_exit.3:34
#: build/C/man3/pthread_getattr_np.3:35
#: build/C/man3/pthread_getcpuclockid.3:35 build/C/man3/pthread_self.3:34
#: build/C/man3/pthread_setaffinity_np.3:39
#: build/C/man3/pthread_setcancelstate.3:36
#: build/C/man3/pthread_setconcurrency.3:35
#: build/C/man3/pthread_setschedparam.3:38
#: build/C/man3/pthread_setschedprio.3:34 build/C/man3/pthread_testcancel.3:34
#, no-wrap
msgid "Compile and link with I<-pthread>.\n"
msgstr "I<-pthread> でコンパイルしてリンクする。\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:48
msgid ""
"The B<pthread_attr_init>()  function initializes the thread attributes "
"object pointed to by I<attr> with default attribute values.  After this "
"call, individual attributes of the object can be set using various related "
"functions (listed under SEE ALSO), and then the object can be used in one or "
"more B<pthread_create>(3)  calls that create threads."
msgstr ""
"B<pthread_attr_init>() 関数は I<attr> が指すスレッド属性オブジェクト\n"
"(thread attributes object) をデフォルトの属性値で初期化する。\n"
"この呼び出しの後、オブジェクトの各属性は (関連項目に載っている) 種々の\n"
"関数を使って設定することができ、このオブジェクトはスレッドの作成を行う\n"
"B<pthread_create>(3) の呼び出しにおいて使用することができる (一つの\n"
"オブジェクトを複数の B<pthread_create>(3) に渡してもよい)。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:53
msgid ""
"Calling B<pthread_attr_init>()  on a thread attributes object that has "
"already been initialized results in undefined behavior."
msgstr ""
"すでに初期化されているスレッド属性オブジェクトに対して\n"
"B<pthread_attr_init>() を呼び出した場合、\n"
"どのような動作になるかは不定である。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:60
msgid ""
"When a thread attributes object is no longer required, it should be "
"destroyed using the B<pthread_attr_destroy>()  function.  Destroying a "
"thread attributes object has no effect on threads that were created using "
"that object."
msgstr ""
"スレッド属性オブジェクトがもはや必要なくなった際には、\n"
"そのオブジェクトは B<pthread_attr_destroy>() 関数を使って破棄すべきである。\n"
"スレッド属性オブジェクトを破棄しても、\n"
"そのオブジェクトを使って作成されたスレッドには影響はない。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:66
msgid ""
"Once a thread attributes object has been destroyed, it can be reinitialized "
"using B<pthread_attr_init>().  Any other use of a destroyed thread "
"attributes object has undefined results."
msgstr ""
"いったん破棄したスレッド属性オブジェクトは、\n"
"B<pthread_attr_init>() を使って再初期化することができる。\n"
"破棄したスレッド属性オブジェクトをこれ以外の用途で\n"
"使った場合の結果は不定である。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:69
#: build/C/man3/pthread_attr_setaffinity_np.3:77
#: build/C/man3/pthread_attr_setdetachstate.3:78
#: build/C/man3/pthread_attr_setguardsize.3:91
#: build/C/man3/pthread_attr_setinheritsched.3:85
#: build/C/man3/pthread_attr_setschedparam.3:75
#: build/C/man3/pthread_attr_setschedpolicy.3:73
#: build/C/man3/pthread_attr_setscope.3:92
#: build/C/man3/pthread_attr_setstack.3:86
#: build/C/man3/pthread_attr_setstackaddr.3:75
#: build/C/man3/pthread_attr_setstacksize.3:62
#: build/C/man3/pthread_setaffinity_np.3:78
#: build/C/man3/pthread_setcancelstate.3:93
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:77
msgid ""
"POSIX.1-2001 documents an B<ENOMEM> error for B<pthread_attr_init>(); on "
"Linux these functions always succeed (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""
"POSIX.1-2001 では B<pthread_attr_init>() にはエラー B<ENOMEM> が\n"
"記載されている。\n"
"Linux では、これらの関数は常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:79
#: build/C/man3/pthread_attr_setdetachstate.3:87
#: build/C/man3/pthread_attr_setguardsize.3:106
#: build/C/man3/pthread_attr_setinheritsched.3:101
#: build/C/man3/pthread_attr_setschedparam.3:89
#: build/C/man3/pthread_attr_setschedpolicy.3:89
#: build/C/man3/pthread_attr_setscope.3:107
#: build/C/man3/pthread_attr_setstack.3:112
#: build/C/man3/pthread_attr_setstacksize.3:83
#: build/C/man3/pthread_cancel.3:122 build/C/man3/pthread_cleanup_push.3:125
#: build/C/man3/pthread_create.3:146 build/C/man3/pthread_detach.3:64
#: build/C/man3/pthread_equal.3:47 build/C/man3/pthread_exit.3:75
#: build/C/man3/pthread_getcpuclockid.3:65 build/C/man3/pthread_join.3:98
#: build/C/man3/pthread_kill.3:66 build/C/man3/pthread_self.3:50
#: build/C/man3/pthread_setcancelstate.3:113
#: build/C/man3/pthread_setconcurrency.3:83
#: build/C/man3/pthread_setschedparam.3:141
#: build/C/man3/pthread_setschedprio.3:83 build/C/man3/pthread_sigmask.3:57
#: build/C/man3/pthread_testcancel.3:58
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:85
msgid ""
"The I<pthread_attr_t> type should be treated as opaque: any access to the "
"object other than via pthreads functions is nonportable and produces "
"undefined results."
msgstr ""
"I<pthread_attr_t> 型の内部構造は意識すべきではない。\n"
"pthreads 関数経由以外でのオブジェクトへのアクセスは移植性がなく、\n"
"どのような結果が得られるかも分からない。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:94
msgid ""
"The program below optionally makes use of B<pthread_attr_init>()  and "
"various related functions to initialize a thread attributes object that is "
"used to create a single thread.  Once created, the thread uses the "
"B<pthread_getattr_np>(3)  function (a nonstandard GNU extension) to retrieve "
"the thread's attributes, and then displays those attributes."
msgstr ""
"下記のプログラムは、B<pthread_attr_init>() と種々の関連関数を使って、\n"
"スレッド属性オブジェクトの初期化を行い、\n"
"そのオブジェクトを使ってスレッドを一つ作成する。\n"
"作成されたスレッドは、作成後に B<pthread_getattr_np>(3) 関数 \n"
"(非標準の GNU 拡張) を使ってスレッドの属性を取得し、\n"
"取得した属性を表示する。"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:103
msgid ""
"If the program is run with no command-line argument, then it passes NULL as "
"the I<attr> argument of B<pthread_create>(3), so that the thread is created "
"with default attributes.  Running the program on Linux/x86-32 with the NPTL "
"threading implementation, we see the following:"
msgstr ""
"コマンドライン引き数なしでプログラムを実行した場合、\n"
"B<pthread_create>(3) の I<attr> 引き数には NULL が渡される。\n"
"この場合、スレッドはデフォルトの属性で作成される。\n"
"このプログラムを NPTL スレッド実装が使われている Linux/x86-32 で\n"
"動作させると、以下のような出力が得られる。"

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: build/C/man3/pthread_attr_init.3:119
#, no-wrap
msgid ""
"$B< ulimit -s>       # No stack imit ==E<gt> default stack size is 2MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"
msgstr ""
"$B< ulimit -s>       # No stack imit ==E<gt> default stack size is 2MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_JOINABLE\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_INHERIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000\n"
"        Stack size          = 0x201000 bytes\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:129
msgid ""
"When we supply a stack size as a command-line argument, the program "
"initializes a thread attributes object, sets various attributes in that "
"object, and passes a pointer to the object in the call to B<pthread_create>"
"(3).  Running the program on Linux/x86-32 with the NPTL threading "
"implementation, we see the following:"
msgstr ""
"コマンドライン引き数でスタックサイズが与えられた場合、\n"
"このプログラムは、スレッド属性オブジェクトを初期化し、\n"
"そのオブジェクトの各種属性を設定し、\n"
"B<pthread_create>(3) の呼び出しでこのオブジェクトへのポインタを渡す。\n"
"このプログラムを NPTL スレッド実装が使われている Linux/x86-32 で\n"
"動作させると、以下のような出力が得られる。"

#.  Results from glibc 2.8, SUSE 11.0; Oct 2008
#. type: Plain text
#: build/C/man3/pthread_attr_init.3:144
#, no-wrap
msgid ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"
msgstr ""
"$B< ./a.out 0x3000000>\n"
"posix_memalign() allocated at 0x40197000\n"
"Thread attributes:\n"
"        Detach state        = PTHREAD_CREATE_DETACHED\n"
"        Scope               = PTHREAD_SCOPE_SYSTEM\n"
"        Inherit scheduler   = PTHREAD_EXPLICIT_SCHED\n"
"        Scheduling policy   = SCHED_OTHER\n"
"        Scheduling priority = 0\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x40197000\n"
"        Stack size          = 0x3000000 bytes\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:155 build/C/man3/pthread_getattr_np.3:186
#, no-wrap
msgid ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE     /* To get pthread_getattr_np() declaration */\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:158 build/C/man3/pthread_cancel.3:157
#: build/C/man3/pthread_cleanup_push.3:237 build/C/man3/pthread_create.3:252
#: build/C/man3/pthread_getattr_np.3:189
#: build/C/man3/pthread_getcpuclockid.3:111
#: build/C/man3/pthread_setaffinity_np.3:170
#: build/C/man3/pthread_setschedparam.3:235 build/C/man3/pthread_sigmask.3:91
#, no-wrap
msgid ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error_en(en, msg) \\e\n"
"        do { errno = en; perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:166
#, no-wrap
msgid ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"
msgstr ""
"static void\n"
"display_pthread_attr(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s, i;\n"
"    size_t v;\n"
"    void *stkaddr;\n"
"    struct sched_param sp;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:174
#, no-wrap
msgid ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getdetachstate(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getdetachstate\");\n"
"    printf(\"%sDetach state        = %s\\en\", prefix,\n"
"            (i == PTHREAD_CREATE_DETACHED) ? \"PTHREAD_CREATE_DETACHED\" :\n"
"            (i == PTHREAD_CREATE_JOINABLE) ? \"PTHREAD_CREATE_JOINABLE\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:182
#, no-wrap
msgid ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getscope(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getscope\");\n"
"    printf(\"%sScope               = %s\\en\", prefix,\n"
"            (i == PTHREAD_SCOPE_SYSTEM)  ? \"PTHREAD_SCOPE_SYSTEM\" :\n"
"            (i == PTHREAD_SCOPE_PROCESS) ? \"PTHREAD_SCOPE_PROCESS\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:190
#, no-wrap
msgid ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getinheritsched(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getinheritsched\");\n"
"    printf(\"%sInherit scheduler   = %s\\en\", prefix,\n"
"            (i == PTHREAD_INHERIT_SCHED)  ? \"PTHREAD_INHERIT_SCHED\" :\n"
"            (i == PTHREAD_EXPLICIT_SCHED) ? \"PTHREAD_EXPLICIT_SCHED\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:199
#, no-wrap
msgid ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"
msgstr ""
"    s = pthread_attr_getschedpolicy(attr, &i);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
"    printf(\"%sScheduling policy   = %s\\en\", prefix,\n"
"            (i == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            (i == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (i == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            \"???\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:204
#, no-wrap
msgid ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"
msgstr ""
"    s = pthread_attr_getschedparam(attr, &sp);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"    printf(\"%sScheduling priority = %d\\en\", prefix, sp.sched_priority);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:209
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, v);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, v);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:216
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = 0x%x bytes\\en\", prefix, v);\n"
"}\n"
msgstr ""
"    s = pthread_attr_getstack(attr, &stkaddr, &v);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\\en\", prefix, stkaddr);\n"
"    printf(\"%sStack size          = 0x%x bytes\\en\", prefix, v);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:222
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t gattr;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:226
#, no-wrap
msgid ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"
msgstr ""
"    /* pthread_getattr_np() is a non-standard GNU extension that\n"
"       retrieves the attributes of the thread specified in its\n"
"       first argument */\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:230
#, no-wrap
msgid ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""
"    s = pthread_getattr_np(pthread_self(), &gattr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:233
#, no-wrap
msgid ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"
msgstr ""
"    printf(\"Thread attributes:\\en\");\n"
"    display_pthread_attr(&gattr, \"\\et\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:236 build/C/man3/pthread_getattr_np.3:238
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);         /* Terminate all threads */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:244
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;      /* NULL or &attr */\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:246
#: build/C/man3/pthread_setschedparam.3:353
#, no-wrap
msgid "    attrp = NULL;\n"
msgstr "    attrp = NULL;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:250
#, no-wrap
msgid ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"
msgstr ""
"    /* If a command-line argument was supplied, use it to set the\n"
"       stack-size attribute and set a few other thread attributes,\n"
"       and set attrp pointing to thread attributes object */\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:254
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        int stack_size;\n"
"        void *sp;\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        int stack_size;\n"
"        void *sp;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:256
#, no-wrap
msgid "        attrp = &attr;\n"
msgstr "        attrp = &attr;\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:260
#, no-wrap
msgid ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:264
#, no-wrap
msgid ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"
msgstr ""
"        s = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setdetachstate\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:268
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
msgstr ""
"        s = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:270
#, no-wrap
msgid "        stack_size = strtoul(argv[1], NULL, 0);\n"
msgstr "        stack_size = strtoul(argv[1], NULL, 0);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:274
#, no-wrap
msgid ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"
msgstr ""
"        s = posix_memalign(&sp, sysconf(_SC_PAGESIZE), stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"posix_memalign\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:276
#, no-wrap
msgid "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"
msgstr "        printf(\"posix_memalign() allocated at %p\\en\", sp);\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:281
#, no-wrap
msgid ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setstack(&attr, sp, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstack\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:285 build/C/man3/pthread_getattr_np.3:333
#, no-wrap
msgid ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:291 build/C/man3/pthread_getattr_np.3:339
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_destroy(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_destroy\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:294 build/C/man3/pthread_getattr_np.3:342
#, no-wrap
msgid ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"
msgstr ""
"    pause();    /* Terminates when other thread calls exit() */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_attr_init.3:309
msgid ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthread_getattr_np>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_setaffinity_np>(3), B<pthread_attr_setdetachstate>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_attr_setscope>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstackaddr>(3), B<pthread_attr_setstacksize>(3), "
"B<pthread_create>(3), B<pthread_getattr_np>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setaffinity_np.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETAFFINITY_NP"
msgstr "PTHREAD_ATTR_SETAFFINITY_NP"

#. type: TH
#: build/C/man3/pthread_attr_setaffinity_np.3:24
#: build/C/man3/pthread_getattr_np.3:24
#: build/C/man3/pthread_setaffinity_np.3:24
#: build/C/man3/pthread_tryjoin_np.3:24
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:28
msgid ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - set/get CPU "
"affinity attribute in thread attributes object"
msgstr ""
"pthread_attr_setaffinity_np, pthread_attr_getaffinity_np - \n"
"スレッド属性オブジェクトの CPU affinity 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:32
#: build/C/man3/pthread_getattr_np.3:31
#: build/C/man3/pthread_setaffinity_np.3:32
#: build/C/man3/pthread_tryjoin_np.3:32
#, no-wrap
msgid ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"
msgstr ""
"B<#define _GNU_SOURCE>             /* See feature_test_macros(7) */\n"
"B<#include E<lt>pthread.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:37
#, no-wrap
msgid ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""
"B<int pthread_attr_setaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_attr_getaffinity_np(pthread_attr_t *>I<attr>B<,>\n"
"B<                   size_t >I<cpusetsize>B<, cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:52
msgid ""
"The B<pthread_attr_setaffinity_np>()  function sets the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<cpuset>.  This attribute determines the CPU affinity "
"mask of a thread created using the thread attributes object I<attr>."
msgstr ""
"B<pthread_attr_setaffinity_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの CPU affinity マスク属性を\n"
"I<cpuset> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されたスレッドの CPU affinity マスクが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:61
msgid ""
"The B<pthread_attr_getaffinity_np>()  function returns the CPU affinity mask "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<cpuset>."
msgstr ""
"B<pthread_attr_getaffinity_np>() 関数は、 I<attr> が参照する\n"
"スレッド属性オブジェクトの CPU affinity マスク属性を\n"
"I<cpuset> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:68
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as I<sizeof"
"(cpu_set_t)>."
msgstr ""
"I<cpusetsize> 引き数は I<cpuset> が指すバッファの (バイト単位の)\n"
"大きさである。通常は、この引き数には I<sizeof(cpu_set_t)> を\n"
"指定することだろう。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:74
#: build/C/man3/pthread_setaffinity_np.3:65
msgid ""
"For more details on CPU affinity masks, see B<sched_setaffinity>(2).  For a "
"description of a set of macros that can be used to manipulate and inspect "
"CPU sets, see B<CPU_SET>(3)."
msgstr ""
"CPU affinity マスクの詳細については、 \n"
"B<sched_setaffinity>(2) を参照してほしい。\n"
"CPU 集合の操作や取得を行う際に利用できるマクロ群の説明は \n"
"B<CPU_SET>(3) を参照してほしい。"

#. type: TP
#: build/C/man3/pthread_attr_setaffinity_np.3:78
#: build/C/man3/pthread_attr_setaffinity_np.3:90
#: build/C/man3/pthread_attr_setdetachstate.3:81
#: build/C/man3/pthread_attr_setinheritsched.3:88
#: build/C/man3/pthread_attr_setschedpolicy.3:76
#: build/C/man3/pthread_attr_setscope.3:95
#: build/C/man3/pthread_attr_setstack.3:89
#: build/C/man3/pthread_attr_setstacksize.3:65
#: build/C/man3/pthread_create.3:135 build/C/man3/pthread_detach.3:53
#: build/C/man3/pthread_join.3:83 build/C/man3/pthread_join.3:87
#: build/C/man3/pthread_kill.3:56 build/C/man3/pthread_setaffinity_np.3:82
#: build/C/man3/pthread_setaffinity_np.3:91
#: build/C/man3/pthread_setaffinity_np.3:107
#: build/C/man3/pthread_setcancelstate.3:97
#: build/C/man3/pthread_setcancelstate.3:105
#: build/C/man3/pthread_setconcurrency.3:69
#: build/C/man3/pthread_setschedparam.3:120
#: build/C/man3/pthread_setschedprio.3:60 build/C/man3/pthread_sigqueue.3:75
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:90
msgid ""
"(B<pthread_attr_setaffinity_np>())  I<cpuset> specified a CPU that was "
"outside the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""
"(B<pthread_attr_setaffinity_np>())\n"
"I<cpuset> がカーネルがサポートする CPU 集合にない CPU を指定していた。\n"
"(CPU 集合を表現するのに使われるカーネルのデータ型がサポートする集合の範囲"
"は、\n"
"カーネルの設定オプション B<CONFIG_NR_CPUS> により定義される)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:100
msgid ""
"(B<pthread_attr_getaffinity_np>())  A CPU in the affinity mask of the thread "
"attributes object referred to by I<attr> lies outside the range specified by "
"I<cpusetsize> (i.e., I<cpuset>/I<cpusetsize> is too small)."
msgstr ""
"(B<pthread_attr_getaffinity_np>())\n"
"I<attr> が参照するスレッド属性オブジェクトの affinity マスク内の CPU が、\n"
"I<cpusetsize> により指定された範囲の中になかった\n"
"(すなわち、I<cpuset>/I<cpusetsize> が小さすぎる)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:104
msgid "(B<pthread_attr_setaffinity_np>())  Could not allocate memory."
msgstr ""
"(B<pthread_attr_setaffinity_np>()) メモリを割り当てることができなかった。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:106
#: build/C/man3/pthread_setaffinity_np.3:119
msgid "These functions are provided by glibc since version 2.3.4."
msgstr "これらの関数は glibc バージョン 2.3.4 以降で提供されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:109
#: build/C/man3/pthread_cleanup_push_defer_np.3:102
#: build/C/man3/pthread_setaffinity_np.3:122
#: build/C/man3/pthread_tryjoin_np.3:113
msgid ""
"These functions are nonstandard GNU extensions; hence the suffix \"_np"
"\" (nonportable) in the names."
msgstr ""
"これらの関数は非標準の GNU による拡張である。\n"
"そのため、名前に \"_np\" (nonportable; 移植性がない) という接尾辞が\n"
"付いている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:116
#: build/C/man3/pthread_setaffinity_np.3:148
msgid ""
"In glibc 2.3.3 only, versions of these functions were provided that did not "
"have a I<cpusetsize> argument.  Instead the CPU set size given to the "
"underlying system calls was always I<sizeof(cpu_set_t)>."
msgstr ""
"(このバージョンだけであるが) glibc 2.3.3 では、\n"
"これらの関数は I<cpusetsize> 引き数を持っていなかった。\n"
"内部で呼ばれるシステムコールに渡される CPU セットの大きさは\n"
"常に I<sizeof(cpu_set_t)> であった。"

#. type: Plain text
#: build/C/man3/pthread_attr_setaffinity_np.3:122
msgid ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), B<pthread_setaffinity_np>"
"(3), B<cpuset>(7), B<pthreads>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<pthread_attr_init>(3), B<pthread_setaffinity_np>"
"(3), B<cpuset>(7), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setdetachstate.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETDETACHSTATE"
msgstr "PTHREAD_ATTR_SETDETACHSTATE"

#. type: TH
#: build/C/man3/pthread_attr_setdetachstate.3:24
#: build/C/man3/pthread_attr_setschedpolicy.3:24
#, no-wrap
msgid "2010-02-03"
msgstr "2010-02-03"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:28
msgid ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - set/get detach "
"state attribute in thread attributes object"
msgstr ""
"pthread_attr_setdetachstate, pthread_attr_getdetachstate - \n"
"スレッド属性オブジェクトの detach state 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(pthread_attr_t *>I<attr>B<, int *>I<detachstate>B<);>\n"
msgstr ""
"B<int pthread_attr_setdetachstate(pthread_attr_t *>I<attr>B<, int >I<detachstate>B<);>\n"
"B<int pthread_attr_getdetachstate(pthread_attr_t *>I<attr>B<, int *>I<detachstate>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:51
msgid ""
"The B<pthread_attr_setdetachstate>()  function sets the detach state "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<detachstate>.  The detach state attribute determines "
"whether a thread created using the thread attributes object I<attr> will be "
"created in a joinable or a detached state."
msgstr ""
"B<pthread_attr_setdetachstate>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの detach state 属性を\n"
"I<detachstate> で指定された値に設定する。\n"
"detach state 属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが、 join 可能な状態で作成されるか、\n"
"detached (切り離された) 状態で作成されるかが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:54
msgid "The following values may be specified in I<detachstate>:"
msgstr "I<detachstate> には以下の値を指定できる。"

#. type: TP
#: build/C/man3/pthread_attr_setdetachstate.3:54
#, no-wrap
msgid "B<PTHREAD_CREATE_DETACHED>"
msgstr "B<PTHREAD_CREATE_DETACHED>"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:59
msgid ""
"Threads that are created using I<attr> will be created in a detached state."
msgstr "I<attr> を使って作成されるスレッドは detached 状態で作成される。"

#. type: TP
#: build/C/man3/pthread_attr_setdetachstate.3:59
#, no-wrap
msgid "B<PTHREAD_CREATE_JOINABLE>"
msgstr "B<PTHREAD_CREATE_JOINABLE>"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:64
msgid ""
"Threads that are created using I<attr> will be created in a joinable state."
msgstr "I<attr> を使って作成されるスレッドは join 可能な状態で作成される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:68
msgid ""
"The default setting of the detach state attribute in a newly initialized "
"thread attributes object is B<PTHREAD_CREATE_JOINABLE>."
msgstr ""
"新規に初期化されたスレッド属性オブジェクトの detach state 属性の\n"
"デフォルト設定は B<PTHREAD_CREATE_JOINABLE> である。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:75
msgid ""
"The B<pthread_attr_getdetachstate>()  returns the detach state attribute of "
"the thread attributes object I<attr> in the buffer pointed to by "
"I<detachstate>."
msgstr ""
"B<pthread_attr_getdetachstate>() は、\n"
"スレッド属性オブジェクト I<attr> の detach state 属性を\n"
"I<detachstate> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:81
msgid "B<pthread_attr_setdetachstate>()  can fail with the following error:"
msgstr "B<pthread_attr_setdetachstate>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:85
msgid "An invalid value was specified in I<detachstate>."
msgstr "無効な値が I<detachstate> で指定された。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:91
msgid ""
"See B<pthread_create>(3)  for more details on detached and joinable threads."
msgstr ""
"detached 状態のスレッド、join 可能状態のスレッドの詳細については、\n"
"B<pthread_create>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:99
msgid ""
"A thread that is created in a joinable state should eventually either be "
"joined using B<pthread_join>(3)  or detached using B<pthread_detach>(3); see "
"B<pthread_create>(3)."
msgstr ""
"join 可能状態で作成されたスレッドは、最終的に\n"
"B<pthread_join>(3) を使って join するか、\n"
"B<pthread_detach>(3) を使って切り離すか、\n"
"のどちらかを行うべきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:106
msgid ""
"It is an error to specify the thread ID of a thread that was created in a "
"detached state in a later call to B<pthread_detach>(3)  or B<pthread_join>"
"(3)."
msgstr ""
"detached 状態で作成されたスレッドのスレッド ID を指定して、\n"
"B<pthread_detach>(3) や B<pthread_join>(3) を後から呼び出すのは\n"
"エラーである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:109
#: build/C/man3/pthread_attr_setstack.3:154
msgid "See B<pthread_attr_init>(3)."
msgstr "B<pthread_attr_init>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setdetachstate.3:115
msgid ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setguardsize.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETGUARDSIZE"
msgstr "PTHREAD_ATTR_SETGUARDSIZE"

#. type: TH
#: build/C/man3/pthread_attr_setguardsize.3:24
#: build/C/man3/pthread_attr_setscope.3:24
#: build/C/man3/pthread_attr_setstack.3:24
#: build/C/man3/pthread_attr_setstackaddr.3:24 build/C/man3/pthread_self.3:24
#, no-wrap
msgid "2008-10-24"
msgstr "2008-10-24"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:28
msgid ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - set/get guard size "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setguardsize, pthread_attr_getguardsize - \n"
"スレッド属性オブジェクトの guard size 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(pthread_attr_t *>I<attr>B<, size_t *>I<guardsize>B<);>\n"
msgstr ""
"B<int pthread_attr_setguardsize(pthread_attr_t *>I<attr>B<, size_t >I<guardsize>B<);>\n"
"B<int pthread_attr_getguardsize(pthread_attr_t *>I<attr>B<, size_t *>I<guardsize>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:47
msgid ""
"The B<pthread_attr_setguardsize>()  function sets the guard size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<guardsize>."
msgstr ""
"B<pthread_attr_setguardsize>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの guard size 属性を\n"
"I<guardsize> で指定された値に設定する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:57
msgid ""
"If I<guardsize> is greater than 0, then for each new thread created using "
"I<attr> the system allocates an additional region of at least I<guardsize> "
"bytes at the end of the thread's stack to act as the guard area for the "
"stack (but see BUGS)."
msgstr ""
"I<guardsize> が 0 より大きい場合、\n"
"I<attr> を使って新しく作成された各スレッドに対して、\n"
"システムはスレッドのスタックの末尾に少なくとも I<guardsize> バイトの\n"
"追加領域を割り当てる。この追加領域はスタックに対するガード領域として\n"
"機能する (ただし「バグ」の節も参照)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:63
msgid ""
"If I<guardsize> is 0, then new threads created with I<attr> will not have a "
"guard area."
msgstr ""
"I<guardsize> が 0 の場合、\n"
"I<attr> を使って新しく作成されたスレッドはガード領域を持たない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:65
msgid "The default guard size is the same as the system page size."
msgstr "デフォルトの guard size はシステムのページサイズと同じである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:80
msgid ""
"If the stack address attribute has been set in I<attr> (using "
"B<pthread_attr_setstack>(3)  or B<pthread_attr_setstackaddr>(3)), meaning "
"that the caller is allocating the thread's stack, then the guard size "
"attribute is ignored (i.e., no guard area is created by the system): it is "
"the application's responsibility to handle stack overflow (perhaps by using "
"B<mprotect>(2)  to manually define a guard area at the end of the stack that "
"it has allocated)."
msgstr ""
"(B<pthread_attr_setstack>(3) や B<pthread_attr_setstackaddr>(3)を使って)\n"
"I<attr> でスタックアドレス属性が設定されている場合には、呼び出し側がそ\n"
"のスレッドのスタックを割り当てていることを意味するので、guard size 属性\n"
"は無視される (すなわち、システムによるガード領域の作成は行われない)。\n"
"この場合、スタックオーバーフローが起こらないように対処するのはアプリ\n"
"ケーション側の責任となる (おそらく B<mprotect>(2) を使って、割り当て\n"
"られたスタックの最後に手動でガード領域を定義することになるだろう)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:88
msgid ""
"The B<pthread_attr_getguardsize>()  function returns the guard size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<guardsize>."
msgstr ""
"B<pthread_attr_getguardsize>() は、\n"
"スレッド属性オブジェクト I<attr> の guard size 属性を\n"
"I<guardsize> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:102
msgid ""
"POSIX.1-2001 documents an B<EINVAL> error if I<attr> or I<guardsize> is "
"invalid.  On Linux these functions always succeed (but portable and future-"
"proof applications should nevertheless handle a possible error return)."
msgstr ""
"POSIX.1-2001 では、エラー B<EINVAL> が\n"
" I<attr> か I<guardsize> が無効な場合に対して規定されている。\n"
"Linux では、これらの関数は常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:104
#: build/C/man3/pthread_attr_setstackaddr.3:81
#: build/C/man3/pthread_attr_setstacksize.3:81
msgid "These functions are provided by glibc since version 2.1."
msgstr "これらの関数は glibc バージョン 2.1 以降で提供されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:120
msgid ""
"A guard area consists of virtual memory pages that are protected to prevent "
"read and write access.  If a thread overflows its stack into the guard area, "
"then, on most hard architectures, it receives a B<SIGSEGV> signal, thus "
"notifying it of the overflow.  Guard areas start on page boundaries, and the "
"guard size is internally rounded up to the system page size when creating a "
"thread.  (Nevertheless, B<pthread_attr_getguardsize>()  returns the guard "
"size that was set by B<pthread_attr_setguardsize>().)"
msgstr ""
"ガード領域は、読み出し/書き込みアクセスが行われないように保護がかけ\n"
"られた仮想メモリページで構成で構成される。スレッドがスタックをガード\n"
"領域までオーバーフローさせた場合、ほとんどのハードウェアアーキテクチャ\n"
"では、スレッドに B<SIGSEGV> シグナルが送られ、オーバーフローが発生した\n"
"ことが通知される。ガード領域はページ境界から開始され、ガード領域の\n"
"大きさはスレッド作成時に内部的にシステムのページサイズに切り上げられる\n"
"(その場合も B<pthread_attr_getguardsize>() では\n"
"B<pthread_attr_setguardsize>() で設定された guard size が返される)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:124
msgid ""
"Setting a guard size of 0 may be useful to save memory in an application "
"that creates many threads and knows that stack overflow can never occur."
msgstr ""
"多くのスレッドを作成するアプリケーションで、かつ、スタックオーバーフロー\n"
"が決して発生しないことが分かっている場合には、guard size を 0 に設定\n"
"することで、メモリを節約できることもある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:128
msgid ""
"Choosing a guard size larger than the default size may be necessary for "
"detecting stack overflows if a thread allocates large data structures on the "
"stack."
msgstr ""
"スレッドがスタックに大きなデータ構造を割り当てる場合には、\n"
"スタックオーバーフローを検出するためには、デフォルトサイズよりも\n"
"大きな guard size を選ぶ必要があるかもしれない。"

#. type: SH
#: build/C/man3/pthread_attr_setguardsize.3:128
#: build/C/man3/pthread_attr_setinheritsched.3:101
#: build/C/man3/pthread_attr_setstacksize.3:94
#: build/C/man3/pthread_create.3:194 build/C/man3/pthread_exit.3:91
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:139
msgid ""
"As at glibc 2.8, the NPTL threading implementation includes the guard area "
"within the stack size allocation, rather than allocating extra space at the "
"end of the stack, as POSIX.1 requires.  (This can result in an B<EINVAL> "
"error from B<pthread_create>(3)  if the guard size value is too large, "
"leaving no space for the actual stack.)"
msgstr ""
"glibc 2.8 の時点では、 NPTL スレッド実装ではガード領域はスタックサイズ\n"
"で割り当てられる領域の中に含まれている。一方、POSIX.1 では、スタックの\n"
"末尾に追加の領域を割り当てることが求められている。\n"
"(このため、ガード領域が大きすぎて、\n"
"実際のスタック用の場所がなくなってしまう場合、\n"
"B<pthread_create>(3) で B<EINVAL> エラーが発生することになる。)"

#.  glibc includes the guardsize within the allocated stack size,
#.  which looks pretty clearly to be in violation of POSIX.
#.  Filed bug, 22 Oct 2008:
#.  http://sources.redhat.com/bugzilla/show_bug.cgi?id=6973
#.  Older reports:
#.  https//bugzilla.redhat.com/show_bug.cgi?id=435337
#.  Reportedly, LinuxThreads did the right thing, allocating
#.  extra space at the end of the stack:
#.  http://sourceware.org/ml/libc-alpha/2008-05/msg00086.html
#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:153
msgid ""
"The obsolete LinuxThreads implementation did the right thing, allocating "
"extra space at the end of the stack for the guard area."
msgstr ""
"廃止予定の LinuxThreads 実装では、\n"
"POSIX.1 で求められている通りの動作で、\n"
"ガード領域がスタックの末尾に追加の領域が割り当てられる。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:156
msgid "See B<pthread_getattr_np>(3)."
msgstr "B<pthread_getattr_np>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setguardsize.3:164
msgid ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), B<pthread_attr_setstack>"
"(3), B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<mmap>(2), B<mprotect>(2), B<pthread_attr_init>(3), B<pthread_attr_setstack>"
"(3), B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setinheritsched.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETINHERITSCHED"
msgstr "PTHREAD_ATTR_SETINHERITSCHED"

#. type: TH
#: build/C/man3/pthread_attr_setinheritsched.3:24
#: build/C/man3/pthread_attr_setschedparam.3:24
#: build/C/man3/pthread_attr_setstacksize.3:24
#: build/C/man3/pthread_create.3:24
#, no-wrap
msgid "2012-03-15"
msgstr "2012-03-15"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:28
msgid ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - set/get inherit "
"scheduler attribute in thread attributes object"
msgstr ""
"pthread_attr_setinheritsched, pthread_attr_getinheritsched - \n"
"スレッド属性オブジェクトの inherit scheduler 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"
msgstr ""
"B<int pthread_attr_setinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int >I<inheritsched>B<);>\n"
"B<int pthread_attr_getinheritsched(pthread_attr_t *>I<attr>B<,>\n"
"B<                                 int *>I<inheritsched>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:53
msgid ""
"The B<pthread_attr_setinheritsched>()  function sets the inherit scheduler "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<inheritsched>.  The inherit scheduler attribute "
"determines whether a thread created using the thread attributes object "
"I<attr> will inherit its scheduling attributes from the calling thread or "
"whether it will take them from I<attr>."
msgstr ""
"B<pthread_attr_setinheritsched>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの inherit scheduler 属性を\n"
"I<inheritsched> で指定された値に設定する。\n"
"inherit scheduler 属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが、呼び出したスレッドのスケジューリング属性を継承\n"
"するか、I<attr> からスケジューリング属性を取得するかが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:56
msgid "The following values may be specified in I<inheritsched>:"
msgstr "以下の値を I<inheritsched> に指定できる。"

#. type: TP
#: build/C/man3/pthread_attr_setinheritsched.3:56
#, no-wrap
msgid "B<PTHREAD_INHERIT_SCHED>"
msgstr "B<PTHREAD_INHERIT_SCHED>"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:64
msgid ""
"Threads that are created using I<attr> inherit scheduling attributes from "
"the creating thread; the scheduling attributes in I<attr> are ignored."
msgstr ""
"I<attr> を使って作成されたスレッドは、\n"
"スレッドを作成するスレッドからスケジューリング属性を継承する。\n"
"I<attr> 内のスケジューリング属性は無視される。"

#. type: TP
#: build/C/man3/pthread_attr_setinheritsched.3:64
#, no-wrap
msgid "B<PTHREAD_EXPLICIT_SCHED>"
msgstr "B<PTHREAD_EXPLICIT_SCHED>"

#.  FIXME what are the defaults for scheduler settings?
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:71
msgid ""
"Threads that are created using I<attr> take their scheduling attributes from "
"the values specified by the attributes object."
msgstr ""
"I<attr> を使って作成されたスレッドは、スレッド属性オブジェクトで\n"
"指定された値からスケジューリング属性を取得する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:75
msgid ""
"The default setting of the inherit scheduler attribute in a newly "
"initialized thread attributes object is B<PTHREAD_INHERIT_SCHED>."
msgstr ""
"新たに初期化されたスレッド属性オブジェクトの inherit scheduler 属性の\n"
"デフォルト設定は B<PTHREAD_INHERIT_SCHED> である。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:82
msgid ""
"The B<pthread_attr_getinheritsched>()  returns the inherit scheduler "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<inheritsched>."
msgstr ""
"B<pthread_attr_getinheritsched>() は、\n"
"スレッド属性オブジェクト I<attr> の inherit scheduler 属性を\n"
"I<inheritsched> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:88
msgid "B<pthread_attr_setinheritsched>()  can fail with the following error:"
msgstr "B<pthread_attr_setinheritsched>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:92
msgid "Invalid value in I<inheritsched>."
msgstr "I<inheritsched> に無効な値が指定された。"

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:99
msgid ""
"POSIX.1-2001 also documents an optional B<ENOTSUP> error (\"attempt was made "
"to set the attribute to an unsupported value\") for "
"B<pthread_attr_setinheritsched>()."
msgstr ""
"POSIX.1-2001 では、 B<pthread_attr_setinheritsched>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値を属性に設定しようとした\")\n"
"も追加で規定されている。"

#.  FIXME . Track status of the following bug:
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7007
#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:117
msgid ""
"As at glibc 2.8, if a thread attributes object is initialized using "
"B<pthread_attr_init>(3), then the scheduling policy of the attributes object "
"is set to B<SCHED_OTHER> and the scheduling priority is set to 0.  However, "
"if the inherit scheduler attribute is then set to B<PTHREAD_EXPLICIT_SCHED>, "
"then a thread created using the attribute object wrongly inherits its "
"scheduling attributes from the creating thread.  This bug does not occur if "
"either the scheduling policy or scheduling priority attribute is explicitly "
"set in the thread attributes object before calling B<pthread_create>(3)."
msgstr ""
"glibc 2.8 の時点では、スレッド属性オブジェクトが\n"
"B<pthread_attr_init>(3) を使って初期化された場合、\n"
"スレッド属性オブジェクトのスケジューリングポリシーが B<SCHED_OTHER> に、\n"
"スケジューリング優先度が 0 に設定される。一方、その後 inherit\n"
"scheduling 属性に B<PTHREAD_EXPLICIT_SCHED> が設定されると、このスレッ\n"
"ド属性オブジェクトを使って作成されたスレッドでは、スレッドを作成するス\n"
"レッドのスケジューリング属性が間違って継承されてしまう。\n"
"B<pthread_create>(3) を呼び出す前にスケジューリングポリシー属性か\n"
"スケジューリング優先度属性のどちらかが明示的に設定された場合には、\n"
"このバグは発生しない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:120
#: build/C/man3/pthread_attr_setschedparam.3:96
#: build/C/man3/pthread_attr_setschedpolicy.3:92
msgid "See B<pthread_setschedparam>(3)."
msgstr "B<pthread_setschedparam>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setinheritsched.3:129
msgid ""
"B<sched_setscheduler>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>"
"(3), B<pthreads>(7)"
msgstr ""
"B<sched_setscheduler>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>"
"(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setschedparam.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPARAM"
msgstr "PTHREAD_ATTR_SETSCHEDPARAM"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:28
msgid ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - set/get scheduling "
"parameter attributes in thread attributes object"
msgstr ""
"pthread_attr_setschedparam, pthread_attr_getschedparam - \n"
"スレッド属性オブジェクトのスケジューリングパラメータ属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<int pthread_attr_setschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               const struct sched_param *>I<param>B<);>\n"
"B<int pthread_attr_getschedparam(pthread_attr_t *>I<attr>B<,>\n"
"B<                               struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:50
msgid ""
"The B<pthread_attr_setschedparam>()  function sets the scheduling parameter "
"attributes of the thread attributes object referred to by I<attr> to the "
"values specified in the buffer pointed to by I<param>.  These attributes "
"determine the scheduling parameters of a thread created using the thread "
"attributes object I<attr>."
msgstr ""
"B<pthread_attr_setschedparam>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスケジューリング\n"
"パラメータ属性を I<param> が指すバッファで指定された値に設定する。\n"
"これらの属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドのスケジューリングパラメータが決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:57
msgid ""
"The B<pthread_attr_getschedparam>()  returns the scheduling parameter "
"attributes of the thread attributes object I<attr> in the buffer pointed to "
"by I<param>."
msgstr ""
"B<pthread_attr_getschedparam>() は、\n"
"スレッド属性オブジェクト I<attr> のスケジューリングパラメータ属性を\n"
"I<param> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:59
msgid "Scheduling parameters are maintained in the following structure:"
msgstr "スケジューリングパラメータは以下の構造体で管理される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:65
#: build/C/man3/pthread_setschedparam.3:67
#, no-wrap
msgid ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"
msgstr ""
"struct sched_param {\n"
"    int sched_priority;     /* Scheduling priority */\n"
"};\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:72
#: build/C/man3/pthread_setschedparam.3:74
msgid ""
"As can be seen, only one scheduling parameter is supported.  For details of "
"the permitted ranges for scheduling priorities in each scheduling policy, "
"see B<sched_setscheduler>(2)."
msgstr ""
"見て分かる通り、サポートされているスケジューリングパラメータは一つだけ\n"
"である。各スケジューリングポリシーで許可されるスケジューリング優先度の\n"
"詳細については、B<sched_setscheduler>(2) を参照のこと。"

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:87
msgid ""
"POSIX.1 documents B<EINVAL> and B<ENOTSUP> errors for "
"B<pthread_attr_setschedparam>().  On Linux these functions always succeed "
"(but portable and future-proof applications should nevertheless handle a "
"possible error return)."
msgstr ""
"POSIX.1 では、\n"
"B<pthread_attr_setschedparam>() について\n"
"B<EINVAL> と B<ENOTSUP> が規定されている。\n"
"Linux では、これらの関数は常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:93
msgid ""
"See B<pthread_attr_setschedpolicy>(3)  for a list of the thread scheduling "
"policies supported on Linux."
msgstr ""
"Linux でサポートされているスレッドのスケジューリングポリシーのリストに\n"
"ついては、 B<pthread_attr_setschedpolicy>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedparam.3:106
msgid ""
"B<sched_get_priority_min>(2), B<sched_setscheduler>(2), B<pthread_attr_init>"
"(3), B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>"
"(3), B<pthreads>(7)"
msgstr ""
"B<sched_get_priority_min>(2), B<sched_setscheduler>(2), B<pthread_attr_init>"
"(3), B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>"
"(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setschedpolicy.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETSCHEDPOLICY"
msgstr "PTHREAD_ATTR_SETSCHEDPOLICY"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:28
msgid ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - set/get "
"scheduling policy attribute in thread attributes object"
msgstr ""
"pthread_attr_setschedpolicy, pthread_attr_getschedpolicy - スレッド属性\n"
"オブジェクトのスケジューリングポリシー属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"
msgstr ""
"B<int pthread_attr_setschedpolicy(pthread_attr_t *>I<attr>B<, int >I<policy>B<);>\n"
"B<int pthread_attr_getschedpolicy(pthread_attr_t *>I<attr>B<, int >I<*policy>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:50
msgid ""
"The B<pthread_attr_setschedpolicy>()  function sets the scheduling policy "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<policy>.  This attribute determines the scheduling "
"policy of a thread created using the thread attributes object I<attr>."
msgstr ""
"B<pthread_attr_setschedpolicy>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスケジューリング\n"
"ポリシー属性を I<policy> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドのスケジューリングポリシーが決定される。"

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:63
msgid ""
"The supported values for I<policy> are B<SCHED_FIFO>, B<SCHED_RR>, and "
"B<SCHED_OTHER>, with the semantics described in B<sched_setscheduler>(2)."
msgstr ""
"I<policy> に指定できる値は B<SCHED_FIFO>, B<SCHED_RR>, B<SCHED_OTHER>\n"
"である。それぞれの意味は B<sched_setscheduler>(2) で説明している通り\n"
"である。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:70
msgid ""
"The B<pthread_attr_getschedpolicy>()  returns the scheduling policy "
"attribute of the thread attributes object I<attr> in the buffer pointed to "
"by I<policy>."
msgstr ""
"B<pthread_attr_getschedpolicy>() は、\n"
"スレッド属性オブジェクト I<attr> のスケジューリングポリシー属性を\n"
"I<policy> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:76
msgid "B<pthread_attr_setschedpolicy>()  can fail with the following error:"
msgstr "B<pthread_attr_setschedpolicy>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:80
msgid "Invalid value in I<policy>."
msgstr "I<policy> に無効な値が指定された。"

#.  .SH VERSIONS
#.  Available since glibc 2.0.
#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:87
msgid ""
"POSIX.1-2001 also documents an optional B<ENOTSUP> error (\"attempt was made "
"to set the attribute to an unsupported value\") for "
"B<pthread_attr_setschedpolicy>()."
msgstr ""
"POSIX.1-2001 では、 B<pthread_attr_setschedpolicy>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値を属性に設定しようとした\")\n"
"も追加で規定されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setschedpolicy.3:101
msgid ""
"B<sched_setscheduler>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>"
"(3), B<pthreads>(7)"
msgstr ""
"B<sched_setscheduler>(2), B<pthread_attr_init>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_create>(3), B<pthread_setschedparam>(3), B<pthread_setschedprio>"
"(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setscope.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETSCOPE"
msgstr "PTHREAD_ATTR_SETSCOPE"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:28
msgid ""
"pthread_attr_setscope, pthread_attr_getscope - set/get contention scope "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setscope, pthread_attr_getscope - \n"
"スレッド属性オブジェクトの contention scope 属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"
msgstr ""
"B<int pthread_attr_setscope(pthread_attr_t *>I<attr>B<, int >I<scope>B<);>\n"
"B<int pthread_attr_getscope(pthread_attr_t *>I<attr>B<, int *>I<scope>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:51
msgid ""
"The B<pthread_attr_setscope>()  function sets the contention scope attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<scope>.  The contention scope attribute defines the set of "
"threads against which a thread competes for resources such as the CPU.  "
"POSIX.1-2001 specifies two possible values for I<scope>:"
msgstr ""
"B<pthread_attr_setscope>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトの contention scope\n"
"属性を I<scope> で指定された値に設定する。\n"
"contention scope 属性により、\n"
"スレッドが CPU などのリソースを取り合うスレッド集合が規定される。\n"
"POSIX.1-2001 では I<scope> に指定する値として 2 つの値が規定されている。"

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:51
#, no-wrap
msgid "B<PTHREAD_SCOPE_SYSTEM>"
msgstr "B<PTHREAD_SCOPE_SYSTEM>"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:59
msgid ""
"The thread competes for resources with all other threads in all processes on "
"the system that are in the same scheduling allocation domain (a group of one "
"or more processors).  B<PTHREAD_SCOPE_SYSTEM> threads are scheduled relative "
"to one another according to their scheduling policy and priority."
msgstr ""
"スレッドは、同じスケジューリング割り当てドメイン (一つ以上のプロセッサ\n"
"のグループ) にある、システム上の全てのプロセスの自分以外の全ての\n"
"スレッドとリソースを取り合う。 \n"
"B<PTHREAD_SCOPE_SYSTEM> のスレッドは、スケジューリングポリシーと\n"
"優先度に基づき、互いに相対的にスケジューリングされる。"

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:59
#, no-wrap
msgid "B<PTHREAD_SCOPE_PROCESS>"
msgstr "B<PTHREAD_SCOPE_PROCESS>"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:74
msgid ""
"The thread competes for resources with all other threads in the same process "
"that were also created with the B<PTHREAD_SCOPE_PROCESS> contention scope.  "
"B<PTHREAD_SCOPE_PROCESS> threads are scheduled relative to other threads in "
"the process according to their scheduling policy and priority.  POSIX.1-2001 "
"leaves it unspecified how these threads contend with other threads in other "
"process on the system or with other threads in the same process that were "
"created with the B<PTHREAD_SCOPE_SYSTEM> contention scope."
msgstr ""
"スレッドは、contention scope が B<PTHREAD_SCOPE_PROCESS> で作成された\n"
"同じプロセスの自分以外の全てのスレッドとリソースを取り合う。\n"
"B<PTHREAD_SCOPE_PROCESS> のスレッドは、スケジューリングポリシーと優先度\n"
"に基づき、同じプロセスの他のスレッドと相対的にスケジューリングされる。\n"
"POSIX.1-2001 では、これらのスレッドがシステム上の他のプロセスのスレッド\n"
"や同じプロセス内の contention scope が B<PTHREAD_SCOPE_SYSTEM> で作成\n"
"された他のスレッドとどのようにリソースを取り合うかは、\n"
"規定されないままになっている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:81
msgid ""
"POSIX.1-2001 only requires that an implementation support one of these "
"contention scopes, but permits both to be supported.  Linux supports "
"B<PTHREAD_SCOPE_SYSTEM>, but not B<PTHREAD_SCOPE_PROCESS>."
msgstr ""
"POSIX.1-2001 で求められているのは、スレッド実装がこれらの contention\n"
"scope のうち 1 つをサポートすることだけであるが、\n"
"両方をサポートすることも認めている。\n"
"Linux は B<PTHREAD_SCOPE_SYSTEM> をサポートしているが、\n"
"B<PTHREAD_SCOPE_PROCESS> はサポートしていない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:89
msgid ""
"The B<pthread_attr_getscope>()  function returns the contention scope "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<scope>."
msgstr ""
"B<pthread_attr_getscope>() は、\n"
"スレッド属性オブジェクト I<attr> の contention scope 属性を\n"
"I<scope> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:95
msgid "B<pthread_attr_setscope>()  can fail with the following errors:"
msgstr "B<pthread_attr_setscope>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:99
msgid "An invalid value was specified in I<scope>."
msgstr "I<scope> に無効な値が指定された。"

#. type: TP
#: build/C/man3/pthread_attr_setscope.3:99
#, no-wrap
msgid "B<ENOTSUP>"
msgstr "B<ENOTSUP>"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:105
msgid ""
"I<scope> specified the value B<PTHREAD_SCOPE_PROCESS>, which is not "
"supported on Linux."
msgstr ""
"I<scope> に値 B<PTHREAD_SCOPE_PROCESS> が指定された。\n"
"この値は Linux でサポートされていない。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:115
msgid ""
"The B<PTHREAD_SCOPE_SYSTEM> contention scope typically indicates that a "
"userspace thread is bound directly to a single kernel-scheduling entity.  "
"This is the case on Linux for the obsolete LinuxThreads implementation and "
"the modern NPTL implementation, which are both 1:1 threading implementations."
msgstr ""
"B<PTHREAD_SCOPE_SYSTEM> contention scope では、通常は、一つの\n"
"ユーザ空間スレッドは一つのカーネルスケジューリング・エンティティに\n"
"直接結び付けられる。\n"
"Linux では、廃止予定の LinuxThreads 実装も新しい NPTL 実装もこれに\n"
"該当し、両方とも 1:1 で結び付けられるスレッド実装となっている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:118
msgid ""
"POSIX.1-2001 specifies that the default contention scope is implementation-"
"defined."
msgstr ""
"POSIX.1-2001 では、 contention scope 属性のデフォルト値は\n"
"実装時で定義されるものと規定されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setscope.3:126
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setaffinity_np>(3), "
"B<pthread_attr_setinheritsched>(3), B<pthread_attr_setschedparam>(3), "
"B<pthread_attr_setschedpolicy>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setstack.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACK"
msgstr "PTHREAD_ATTR_SETSTACK"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:28
msgid ""
"pthread_attr_setstack, pthread_attr_getstack - set/get stack attributes in "
"thread attributes object"
msgstr ""
"pthread_attr_setstack, pthread_attr_getstack - \n"
"スレッド属性オブジェクトのスタック属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""
"B<int pthread_attr_setstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void *>I<stackaddr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstack(pthread_attr_t *>I<attr>B<,>\n"
"B<                          void **>I<stackaddr>B<, size_t *>I<stacksize>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:43 build/C/man3/pthread_sigqueue.3:39
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:48
msgid "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"
msgstr "B<pthread_attr_getstack>(), B<pthread_attr_setstack>():"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:50
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 200112L || _XOPEN_SOURCE\\ E<gt>=\\ 600"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:66
msgid ""
"The B<pthread_attr_setstack>()  function sets the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> to "
"the values specified in I<stackaddr> and I<stacksize>, respectively.  These "
"attributes specify the location and size of the stack that should be used by "
"a thread that is created using the thread attributes object I<attr>."
msgstr ""
"B<pthread_attr_setstack>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスタックアドレス属性と\n"
"スタックサイズ属性をそれぞれ I<stackaddr> と I<stacksize> で\n"
"指定された値に設定する。\n"
"これらの属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが使用すべきスタックの位置とサイズが指定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:72
msgid ""
"I<stackaddr> should point to the lowest addressable byte of a buffer of "
"I<stacksize> bytes that was allocated by the caller.  The pages of the "
"allocated buffer should be both readable and writable."
msgstr ""
"I<stackaddr> は、呼び出し側で割り当てた、大きさが I<stacksize> バイトの\n"
"バッファ内の指定できる最小のアドレスバイトを指すべきである。\n"
"割り当てられたバッファのページは読み書き両方が可能なページとなっている\n"
"べきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:83
msgid ""
"The B<pthread_attr_getstack>()  function returns the stack address and stack "
"size attributes of the thread attributes object referred to by I<attr> in "
"the buffers pointed to by I<stackaddr> and I<stacksize>, respectively."
msgstr ""
"B<pthread_attr_getstack>() 関数は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性と\n"
"スタックサイズ属性をそれぞれ I<stackaddr> と I<stacksize> が\n"
"指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:89
msgid "B<pthread_attr_setstack>()  can fail with the following error:"
msgstr "B<pthread_attr_setstack>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:100
msgid ""
"I<stacksize> is less than B<PTHREAD_STACK_MIN> (16384) bytes.  On some "
"systems, this error may also occur if I<stackaddr> or I<stackaddr\\ +\\ "
"stacksize> is not suitably aligned."
msgstr ""
"I<stacksize> が B<PTHREAD_STACK_MIN> (16384) よりも小さい。\n"
"システムによっては、 I<stackaddr> か\n"
"I<stackaddr\\ +\\ stacksize> のアライメントが適切でない場合にも\n"
"このエラーが発生する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:108
msgid ""
"POSIX.1-2001 also documents an B<EACCES> error if the stack area described "
"by I<stackaddr> and I<stacksize> is not both readable and writable by the "
"caller."
msgstr ""
"POSIX.1-2001 では エラー B<EACCES> も規定されており、\n"
"このエラーは I<stackaddr> と I<stacksize> で規定されるスタック領域に\n"
"呼び出し側から読み書き両方のアクセスができない状況を表す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:110
msgid "These functions are provided by glibc since version 2.2."
msgstr "これらの関数は glibc バージョン 2.2 以降で提供されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:120
msgid ""
"These functions are provided for applications that must ensure that a "
"thread's stack is placed in a particular location.  For most applications, "
"this is not necessary, and the use of these functions should be avoided.  "
"(Use B<pthread_attr_setstacksize>(3)  if an application simply requires a "
"stack size other than the default.)"
msgstr ""
"これらの関数は、スレッドのスタックが特定の場所に配置されることを保証\n"
"しなければならないアプリケーションのために提供されている。\n"
"ほとんどのアプリケーションでは、このようなことは必要なく、\n"
"これらの関数を使うのは避けるべきである。\n"
"(アプリケーションが単にスタックサイズだけをデフォルトの値から変更する\n"
"必要がある場合には B<pthread_attr_setstacksize>(3) を使うこと)"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:131
msgid ""
"When an application employs B<pthread_attr_setstack>(), it takes over the "
"responsibility of allocating the stack.  Any guard size value that was set "
"using B<pthread_attr_setguardsize>(3)  is ignored.  If deemed necessary, it "
"is the application's responsibility to allocate a guard area (one or more "
"pages protected against reading and writing)  to handle the possibility of "
"stack overflow."
msgstr ""
"アプリケーションが B<pthread_attr_setstack>() を利用する際には、\n"
"スタックの割り当てに責任を持つ必要がある。\n"
"B<pthread_attr_setguardsize>(3) を使って設定された\n"
"guard size の値は無視される。\n"
"必要と思われる場合は、アプリケーションが責任を持ってガード領域 (読み書\n"
"きが行われないように保護された 1 個かそれ以上のページ) の割り当てを行い、\n"
"スタックオーバーフローの可能性に対処するようにする必要がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:142
msgid ""
"The address specified in I<stackaddr> should be suitably aligned: for full "
"portability, align it on a page boundary (I<sysconf(_SC_PAGESIZE)>).  "
"B<posix_memalign>(3)  may be useful for allocation.  Probably, I<stacksize> "
"should also be a multiple of the system page size."
msgstr ""
"I<stackaddr> に指定するアドレスは適切なアライメントとなっているべきである。\n"
"完全な移植性を持たせるためには、\n"
"ページ境界 (I<sysconf(_SC_PAGESIZE)>) に揃えること。\n"
"割り当てには B<posix_memalign>(3) を使うとよい。\n"
"たいていは、 I<stacksize> はシステムのページサイズの倍数とすべきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:151
msgid ""
"If I<attr> is used to create multiple threads, then the caller must change "
"the stack address attribute between calls to B<pthread_create>(3); "
"otherwise, the threads will attempt to use the same memory area for their "
"stacks, and chaos will ensue."
msgstr ""
"一つの I<attr> を使って複数のスレッドを作成する場合、\n"
"B<pthread_create>(3) の次の呼び出しを行う前に、\n"
"呼び出し側でスタックアドレス属性を変更しなければならない。\n"
"さもなければ、複数のスレッドがスタックとして同じメモリ領域を\n"
"使おうとするため、訳の分からない状況が発生してしまう。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstack.3:164
msgid ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<mmap>(2), B<mprotect>(2), B<posix_memalign>(3), B<pthread_attr_init>(3), "
"B<pthread_attr_setguardsize>(3), B<pthread_attr_setstackaddr>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setstackaddr.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKADDR"
msgstr "PTHREAD_ATTR_SETSTACKADDR"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:28
msgid ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - set/get stack address "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstackaddr, pthread_attr_getstackaddr - \n"
"スレッド属性オブジェクトのスタックアドレス属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(pthread_attr_t *>I<attr>B<, void **>I<stackaddr>B<);>\n"
msgstr ""
"B<int pthread_attr_setstackaddr(pthread_attr_t *>I<attr>B<, void *>I<stackaddr>B<);>\n"
"B<int pthread_attr_getstackaddr(pthread_attr_t *>I<attr>B<, void **>I<stackaddr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:47
msgid ""
"These functions are obsolete: B<do not use them.> Use "
"B<pthread_attr_setstack>(3)  and B<pthread_attr_getstack>(3)  instead."
msgstr ""
"これらの関数は廃止予定であり、B<使用しないこと>。\n"
"代わりに Use B<pthread_attr_setstack>(3) と B<pthread_attr_getstack>(3) を使"
"うこと。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:58
msgid ""
"The B<pthread_attr_setstackaddr>()  function sets the stack address "
"attribute of the thread attributes object referred to by I<attr> to the "
"value specified in I<stackaddr>.  This attribute specifies the location of "
"the stack that should be used by a thread that is created using the thread "
"attributes object I<attr>."
msgstr ""
"B<pthread_attr_setstackaddr>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスタックアドレス\n"
"属性を I<stackaddr> で指定された値に設定する。\n"
"この属性により、スレッド属性オブジェクト I<attr> を使って\n"
"作成されるスレッドが使用すべきスタックの位置が指定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:64
msgid ""
"I<stackaddr> should point to a buffer of at least B<PTHREAD_STACK_MIN> bytes "
"that was allocated by the caller.  The pages of the allocated buffer should "
"be both readable and writable."
msgstr ""
"I<stackaddr> は呼び出し側が割り当てたバッファ (大きさは\n"
"少なくとも B<PTHREAD_STACK_MIN> バイト)を指すべきである。\n"
"割り当てられたバッファのページは読み書き両方が可能なページと\n"
"なっているべきである。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:72
msgid ""
"The B<pthread_attr_getstackaddr>()  function returns the stack address "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stackaddr>."
msgstr ""
"B<pthread_attr_getstackaddr>() は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性を\n"
"I<stackaddr> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:79
msgid ""
"No errors are defined (but applications should nevertheless handle a "
"possible error return)."
msgstr ""
"エラーは定義されていない (ただし、アプリケーションは正のエラーの\n"
"返り値を処理するようにすべきである)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:84
msgid ""
"POSIX.1-2001 specifies these functions but marks them as obsolete.  "
"POSIX.1-2008 removes the specification of these functions."
msgstr ""
"POSIX.1-2001 では、これらの関数が規定されているが、廃止予定となっている。\n"
"POSIX.1-2008 では、これらの関数の規定は削除されている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:108
msgid ""
"I<Do not use these functions!> They cannot be portably used, since they "
"provide no way of specifying the direction of growth or the range of the "
"stack.  For example, on architectures with a stack that grows downward, "
"I<stackaddr> specifies the next address past the I<highest> address of the "
"allocated stack area.  However, on architectures with a stack that grows "
"upward, I<stackaddr> specifies the I<lowest> address in the allocated stack "
"area.  By contrast, the I<stackaddr> used by B<pthread_attr_setstack>(3)  "
"and B<pthread_attr_getstack>(3), is always a pointer to the lowest address "
"in the allocated stack area (and the I<stacksize> argument specifies the "
"range of the stack)."
msgstr ""
"I<これらの関数を使用しないこと!> これらの関数は移植性がある形では使用で\n"
"きない。なぜなら、これらの関数ではスタック領域がどちらの方向に伸びるの\n"
"かを指定する手段が提供されていないからである。\n"
"例えば、スタックが下向き (アドレスが小さい方向) に伸びるアーキテクチャ\n"
"では、I<stackaddr> には割り当てられたスタック領域のI<最も大きな>アドレ\n"
"スの次のアドレスを指定する。一方、スタックが上向き (アドレスが大きい\n"
"方向) に伸びるアーキテクチャでは、I<stackaddr> には割り当てられた\n"
"スタック領域のI<最も小さい>アドレスを指定する。これに対して、\n"
"B<pthread_attr_setstack>(3) と B<pthread_attr_getstack>(3) が使用する\n"
"I<stackaddr> は、常に割り当てられたスタック領域の最も小さいアドレス\n"
"へのポインタである (I<stacksize> 引き数はスタックの範囲を指定する)。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstackaddr.3:114
msgid ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_init>(3), B<pthread_attr_setstack>(3), "
"B<pthread_attr_setstacksize>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_attr_setstacksize.3:24
#, no-wrap
msgid "PTHREAD_ATTR_SETSTACKSIZE"
msgstr "PTHREAD_ATTR_SETSTACKSIZE"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:28
msgid ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - set/get stack size "
"attribute in thread attributes object"
msgstr ""
"pthread_attr_setstacksize, pthread_attr_getstacksize - \n"
"スレッド属性オブジェクトのスタックサイズ属性の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:36
#, no-wrap
msgid ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(pthread_attr_t *>I<attr>B<, size_t *>I<stacksize>B<);>\n"
msgstr ""
"B<int pthread_attr_setstacksize(pthread_attr_t *>I<attr>B<, size_t >I<stacksize>B<);>\n"
"B<int pthread_attr_getstacksize(pthread_attr_t *>I<attr>B<, size_t *>I<stacksize>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:47
msgid ""
"The B<pthread_attr_setstacksize>()  function sets the stack size attribute "
"of the thread attributes object referred to by I<attr> to the value "
"specified in I<stacksize>."
msgstr ""
"B<pthread_attr_setstacksize>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトのスタックアドレス\n"
"属性を I<stacksize> で指定された値に設定する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:51
msgid ""
"The stack size attribute determines the minimum size (in bytes) that will be "
"allocated for threads created using the thread attributes object I<attr>."
msgstr ""
"スタックサイズ属性により、\n"
"スレッド属性オブジェクト I<attr> を使って作成されたスレッド\n"
"に割り当てられる最小サイズ (バイト単位) が決定される。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:59
msgid ""
"The B<pthread_attr_getstacksize>()  function returns the stack size "
"attribute of the thread attributes object referred to by I<attr> in the "
"buffer pointed to by I<stacksize>."
msgstr ""
"B<pthread_attr_getstacksize>() は、\n"
"スレッド属性オブジェクト I<attr> のスタックアドレス属性を\n"
"I<stacksize> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:65
msgid "B<pthread_attr_setstacksize>()  can fail with the following error:"
msgstr "B<pthread_attr_setstacksize>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:70
msgid "The stack size is less than B<PTHREAD_STACK_MIN> (16384) bytes."
msgstr "スタックサイズが B<PTHREAD_STACK_MIN> (16384) バイト未満である。"

#.  e.g., MacOS
#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:79
msgid ""
"On some systems, B<pthread_attr_setstacksize>()  can fail with the error "
"B<EINVAL> if I<stacksize> is not a multiple of the system page size."
msgstr ""
"いくつかのシステムでは、 B<pthread_attr_setstacksize>() は\n"
"I<stacksize> がシステムのページサイズの倍数でない場合にも\n"
"エラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:86
msgid ""
"For details on the default stack size of new threads, see B<pthread_create>"
"(3)."
msgstr ""
"新しいスレッドのデフォルトのスタックサイズの詳細については\n"
"B<pthread_create>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:89
msgid ""
"A thread's stack size is fixed at the time of thread creation.  Only the "
"main thread can dynamically grow its stack."
msgstr ""
"スレッドのスタックサイズは、スレッド作成時点では固定である。\n"
"メインスレッドだけがスタックを動的に伸ばすことができる。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:94
msgid ""
"The B<pthread_attr_setstack>(3)  function allows an application to set both "
"the size and location of a caller-allocated stack that is to be used by a "
"thread."
msgstr ""
"B<pthread_attr_setstack>(3) 関数を使うと、\n"
"アプリケーションは、スレッドが使用するスタックとして、\n"
"呼び出し側で割り当てたスタックのサイズと場所を指定できる。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:106
msgid ""
"As at glibc 2.8, if the specified I<stacksize> is not a multiple of "
"B<STACK_ALIGN> (16 bytes on most architectures), it may be rounded "
"I<downward>, in violation of POSIX.1-2001, which says that the allocated "
"stack will be at least I<stacksize> bytes."
msgstr ""
"glibc 2.8 の時点では、指定された I<stacksize> が B<STACK_ALIGN> \n"
"(ほとんどのアーキテクチャでは 16 バイト) の倍数でない場合、\n"
"I<stacksize> はI<小さくなる方向に>に丸められる。\n"
"これは POSIX.1-2001 に違反している。\n"
"POSIX.1-2001 では、割り当てらたスタックの大きさは\n"
"少なくとも I<stacksize> バイトになると書かれている。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:109
#: build/C/man3/pthread_join.3:125
msgid "See B<pthread_create>(3)."
msgstr "B<pthread_create>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_attr_setstacksize.3:116
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_attr_setguardsize>(3), "
"B<pthread_attr_setstack>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_cancel.3:24
#, no-wrap
msgid "PTHREAD_CANCEL"
msgstr "PTHREAD_CANCEL"

#. type: TH
#: build/C/man3/pthread_cancel.3:24 build/C/man3/pthread_setschedparam.3:24
#, no-wrap
msgid "2008-11-17"
msgstr "2008-11-17"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:27
msgid "pthread_cancel - send a cancellation request to a thread"
msgstr "pthread_cancel - スレッドにキャンセル要求を送る"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:32
#, no-wrap
msgid "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"
msgstr "B<int pthread_cancel(pthread_t >I<thread>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:44
msgid ""
"The B<pthread_cancel>()  function sends a cancellation request to the thread "
"I<thread>.  Whether and when the target thread reacts to the cancellation "
"request depends on two attributes that are under the control of that thread: "
"its cancelability I<state> and I<type>."
msgstr ""
"B<pthread_cancel>() 関数は指定されたスレッド I<thread> にキャンセル要求\n"
"を送信する。対象のスレッドがキャンセル要求に反応するかどうか、いつ反応\n"
"するかは対象のスレッドの制御下にある 2 つの属性、cancelability\n"
"I<state> と I<type>により決まる。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:56
msgid ""
"A thread's cancelability state, determined by B<pthread_setcancelstate>(3), "
"can be I<enabled> (the default for new threads) or I<disabled>.  If a thread "
"has disabled cancellation, then a cancellation request remains queued until "
"the thread enables cancellation.  If a thread has enabled cancellation, then "
"its cancelability type determines when cancellation occurs."
msgstr ""
"あるスレッドの cancelability state は B<pthread_setcancelstate>(3) で\n"
"設定され、I<enabled> と I<disabled> のいずれとなる (I<enabled> が新しい\n"
"スレッドのデフォルト値である)。スレッドがキャンセルを無効にしていた場合、\n"
"キャンセル要求はそのスレッドがキャンセルを有効にするまでキューに入れら\n"
"れたままになる。スレッドがキャンセルを有効にしていた場合、\n"
"cancelability type によって、いつキャンセルが発生するかが決まる。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:72
msgid ""
"A thread's cancellation type, determined by B<pthread_setcanceltype>(3), may "
"be either I<asynchronous> or I<deferred> (the default for new threads).  "
"Asynchronous cancelability means that the thread can be canceled at any time "
"(usually immediately, but the system does not guarantee this).  Deferred "
"cancelability means that cancellation will be delayed until the thread next "
"calls a function that is a I<cancellation point>.  A list of functions that "
"are or may be cancellation points is provided in I<pthreads>(7)."
msgstr ""
"スレッドの cancellation type は B<pthread_setcanceltype>(3) で設定され、\n"
"I<asynchronous> か I<deferred> のいずれかとなる(I<deferred> が新しいスレッ"
"ド\n"
"のデフォルト値である)。\n"
"非同期キャンセル (asynchronous cancelability) は、そのスレッドはいつでも\n"
"キャンセルされることを意味する (通常はすぐにキャンセルされるが、システムが\n"
"そのことを保証しているわけではない)。\n"
"遅延キャンセル (deferred cancelability) では、そのスレッドが I<cancellation\n"
"point> となっている関数を次に呼び出すまでキャンセルが遅延される。\n"
"取り消しポイント (cancellation point) に設定されていたり設定したりできる\n"
"関数のリストは I<pthreads>(7) に記載している。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:76
msgid ""
"When a cancellation requested is acted on, the following steps occur for "
"I<thread> (in this order):"
msgstr ""
"キャンセル要求が実行されると、\n"
"I<thread> では以下のステップが (この順序で) 行われる。"

#. type: IP
#: build/C/man3/pthread_cancel.3:76 build/C/man3/pthread_cleanup_push.3:67
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man3/pthread_cancel.3:81
msgid ""
"Cancellation clean-up handlers are popped (in the reverse of the order in "
"which they were pushed) and called.  (See B<pthread_cleanup_push>(3).)"
msgstr ""
"キャンセルクリーンアップハンドラが (push されたのと逆順で)\n"
"取り出され (pop され)、呼び出される。\n"
"(B<pthread_cleanup_push>(3) 参照)"

#. type: IP
#: build/C/man3/pthread_cancel.3:81 build/C/man3/pthread_cleanup_push.3:71
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man3/pthread_cancel.3:86
msgid ""
"Thread-specific data destructors are called, in an unspecified order.  (See "
"B<pthread_key_create>(3).)"
msgstr ""
"スレッド固有データのデストラクタ (destructor) が呼び出される。\n"
"呼び出し順序は規定されていない。\n"
"(B<pthread_key_create>(3) 参照)"

#. type: IP
#: build/C/man3/pthread_cancel.3:86 build/C/man3/pthread_cleanup_push.3:79
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man3/pthread_cancel.3:90
msgid "The thread is terminated.  (See B<pthread_exit>(3).)"
msgstr "スレッドが終了される。 (B<pthread_exit>(3) 参照)"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:98
msgid ""
"The above steps happen asynchronously with respect to the B<pthread_cancel>"
"()  call; the return status of B<pthread_cancel>()  merely informs the "
"caller whether the cancellation request was successfully queued."
msgstr ""
"上記のステップは B<pthread_cancel>() の呼び出しとは非同期に行われる。\n"
"B<pthread_cancel>() の返却ステータスは単にキャンセル要求が正常に\n"
"キューに入れられたかどうかを呼び出し元に示すだけのものである。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:107
msgid ""
"After a canceled thread has terminated, a join with that thread using "
"B<pthread_join>(3)  obtains B<PTHREAD_CANCELED> as the thread's exit "
"status.  (Joining with a thread is the only way to know that cancellation "
"has completed.)"
msgstr ""
"キャンセルされたスレッドが終了された後に、\n"
"B<pthread_join>(3) でそのスレッドを join すると、\n"
"そのスレッドの終了ステータスとして B<PTHREAD_CANCELED> が得られる。\n"
"(スレッドの join はキャンセルが完了したかを知る唯一の方法である)"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:112
msgid ""
"On success, B<pthread_cancel>()  returns 0; on error, it returns a nonzero "
"error number."
msgstr ""
"成功すると、 B<pthread_cancel>() は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。"

#. type: TP
#: build/C/man3/pthread_cancel.3:113 build/C/man3/pthread_detach.3:57
#: build/C/man3/pthread_getcpuclockid.3:56 build/C/man3/pthread_join.3:91
#: build/C/man3/pthread_kill.3:59 build/C/man3/pthread_setaffinity_np.3:112
#: build/C/man3/pthread_setschedparam.3:112
#: build/C/man3/pthread_setschedprio.3:68 build/C/man3/pthread_sigqueue.3:83
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:120 build/C/man3/pthread_detach.3:62
#: build/C/man3/pthread_getcpuclockid.3:61 build/C/man3/pthread_join.3:96
#: build/C/man3/pthread_kill.3:64 build/C/man3/pthread_setaffinity_np.3:117
#: build/C/man3/pthread_setschedparam.3:117
#: build/C/man3/pthread_setschedprio.3:73
msgid "No thread with the ID I<thread> could be found."
msgstr "ID が I<thread> のスレッドが見つからなかった。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:130
msgid ""
"On Linux, cancellation is implemented using signals.  Under the NPTL "
"threading implementation, the first real-time signal (i.e., signal 32) is "
"used for this purpose.  On LinuxThreads, the second real-time signal is "
"used, if real-time signals are available, otherwise B<SIGUSR2> is used."
msgstr ""
"Linux では、キャンセルはシグナルを使って実装されている。NPTL スレッド実装で"
"は、\n"
"最初のリアルタイムシグナル (つまり、シグナル 32)がこのために使用される。\n"
"LinuxThreads では、リアルタイムシグナルが利用可能な場合は2 番目のリアルタイ"
"ム\n"
"シグナルが使用され、そうでない場合は B<SIGUSR2> が使用される。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:136
msgid ""
"The program below creates a thread and then cancels it.  The main thread "
"joins with the canceled thread to check that its exit status was "
"B<PTHREAD_CANCELED>.  The following shell session shows what happens when we "
"run the program:"
msgstr ""
"以下のプログラムは、スレッドを一つ作成してから、そのスレッドをキャンセルす"
"る。\n"
"メインスレッドはキャンセルされたスレッドをジョインし、\n"
"キャンセルされたスレッドの終了ステータスが B<PTHREAD_CANCELED> かどうかを\n"
"確認する。以下のシェルセッションはこのプログラムを実行した際の実行例である。"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:144
#, no-wrap
msgid ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"
msgstr ""
"$ ./a.out\n"
"thread_func(): started; cancellation disabled\n"
"main(): sending cancellation request\n"
"thread_func(): about to enable cancellation\n"
"main(): thread was canceled\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:154
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:162
#, no-wrap
msgid ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"
msgstr ""
"static void *\n"
"thread_func(void *ignored_argument)\n"
"{\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:165
#, no-wrap
msgid ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"
msgstr ""
"    /* Disable cancellation for a while, so that we don\\(aqt\n"
"       immediately react to a cancellation request */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:169
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:173
#, no-wrap
msgid ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"
msgstr ""
"    printf(\"thread_func(): started; cancellation disabled\\en\");\n"
"    sleep(5);\n"
"    printf(\"thread_func(): about to enable cancellation\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:177
#, no-wrap
msgid ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"
msgstr ""
"    s = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setcancelstate\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:179
#, no-wrap
msgid "    /* sleep() is a cancellation point */\n"
msgstr "    /* sleep() is a cancellation point */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:181
#, no-wrap
msgid "    sleep(1000);        /* Should get canceled while we sleep */\n"
msgstr "    sleep(1000);        /* Should get canceled while we sleep */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:183
#, no-wrap
msgid "    /* Should never get here */\n"
msgstr "    /* Should never get here */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:187
#, no-wrap
msgid ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    printf(\"thread_func(): not canceled!\\en\");\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:194
#, no-wrap
msgid ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(void)\n"
"{\n"
"    pthread_t thr;\n"
"    void *res;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:196
#, no-wrap
msgid "    /* Start a thread and then send it a cancellation request */\n"
msgstr "    /* Start a thread and then send it a cancellation request */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:200
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, NULL, &thread_func, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:202
#, no-wrap
msgid "    sleep(2);           /* Give thread a chance to get started */\n"
msgstr "    sleep(2);           /* Give thread a chance to get started */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:207
#, no-wrap
msgid ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"
msgstr ""
"    printf(\"main(): sending cancellation request\\en\");\n"
"    s = pthread_cancel(thr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_cancel\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:209
#, no-wrap
msgid "    /* Join with thread to see what its exit status was */\n"
msgstr "    /* Join with thread to see what its exit status was */\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:213 build/C/man3/pthread_cleanup_push.3:301
#, no-wrap
msgid ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    s = pthread_join(thr, &res);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:220
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"main(): thread was canceled\\en\");\n"
"    else\n"
"        printf(\"main(): thread wasn\\(aqt canceled (shouldn\\(aqt happen!)\\en\");\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cancel.3:231
msgid ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cleanup_push>(3), B<pthread_create>(3), B<pthread_exit>(3), "
"B<pthread_join>(3), B<pthread_key_create>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_cleanup_push.3:24
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH"
msgstr "PTHREAD_CLEANUP_PUSH"

#. type: TH
#: build/C/man3/pthread_cleanup_push.3:24
#: build/C/man3/pthread_setcancelstate.3:24
#, no-wrap
msgid "2008-11-24"
msgstr "2008-11-24"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:28
msgid ""
"pthread_cleanup_push, pthread_cleanup_pop - push and pop thread cancellation "
"clean-up handlers"
msgstr ""
"pthread_cleanup_push, pthread_cleanup_pop - スレッドの\n"
"キャンセルクリーンアップハンドラの push/pop を行う"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:35
#, no-wrap
msgid ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"
msgstr ""
"B<void pthread_cleanup_push(void (*>I<routine>B<)(void *),>\n"
"B<                          void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop(int >I<execute>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:46
msgid ""
"These functions manipulate the calling thread's stack of thread-cancellation "
"clean-up handlers.  A clean-up handler is a function that is automatically "
"executed when a thread is canceled (or in various other circumstances "
"described below); it might, for example, unlock a mutex so that it becomes "
"available to other threads in the process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:57
msgid ""
"The B<pthread_cleanup_push>()  function pushes I<routine> onto the top of "
"the stack of clean-up handlers.  When I<routine> is later invoked, it will "
"be given I<arg> as its argument."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:64
msgid ""
"The B<pthread_cleanup_pop>()  function removes the routine at the top of the "
"stack of clean-up handlers, and optionally executes it if I<execute> is "
"nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:67
msgid ""
"A cancellation clean-up handler is popped from the stack and executed in the "
"following circumstances:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:71
msgid ""
"When a thread is canceled, all of the stacked clean-up handlers are popped "
"and executed in the reverse of the order in which they were pushed onto the "
"stack."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:79
msgid ""
"When a thread terminates by calling B<pthread_exit>(3), all clean-up "
"handlers are executed as described in the preceding point.  (Clean-up "
"handlers are I<not> called if the thread terminates by performing a "
"I<return> from the thread start function.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:85
msgid ""
"When a thread calls B<pthread_cleanup_pop>()  with a nonzero I<execute> "
"argument, the top-most clean-up handler is popped and executed."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:97
msgid ""
"POSIX.1 permits B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  to "
"be implemented as macros that expand to text containing \\(aqB<{>\\(aq and "
"\\(aqB<}>\\(aq, respectively.  For this reason, the caller must ensure that "
"calls to these functions are paired within the same function, and at the "
"same lexical nesting level.  (In other words, a clean-up handler is only "
"established during the execution of a specified section of code.)"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:117
msgid ""
"Calling B<longjmp>(3)  (B<siglongjmp>(3))  produces undefined results if any "
"call has been made to B<pthread_cleanup_push>()  or B<pthread_cleanup_pop>"
"()  without the matching call of the pair since the jump buffer was filled "
"by B<setjmp>(3)  (B<sigsetjmp>(3)).  Likewise, calling B<longjmp>(3)  "
"(B<siglongjmp>(3))  from inside a clean-up handler produces undefined "
"results unless the jump buffer was also filled by B<setjmp>(3)  (B<sigsetjmp>"
"(3))  inside the handler."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:119
msgid "These functions do not return a value."
msgstr "これらの関数は値を返さない。"

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:123
msgid "There are no errors."
msgstr "エラーはない。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:134
msgid ""
"On Linux, the B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>()  "
"functions I<are> implemented as macros that expand to text containing \\(aqB<"
"{>\\(aq and \\(aqB<}>\\(aq, respectively.  This means that variables "
"declared within the scope of paired calls to these functions will only be "
"visible within that scope."
msgstr ""

#.  The text was actually added in the 2004 TC2
#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:149
msgid ""
"POSIX.1 says that the effect of using I<return>, I<break>, I<continue>, or "
"I<goto> to prematurely leave a block bracketed B<pthread_cleanup_push>()  "
"and B<pthread_cleanup_pop>()  is undefined.  Portable applications should "
"avoid doing this."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:164
msgid ""
"The program below provides a simple example of the use of the functions "
"described in this page.  The program creates a thread that executes a loop "
"bracketed by B<pthread_cleanup_push>()  and B<pthread_cleanup_pop>().  This "
"loop increments a global variable, I<cnt>, once each second.  Depending on "
"what command-line arguments are supplied, the main thread sends the other "
"thread a cancellation request, or sets a global variable that causes the "
"other thread to exit its loop and terminate normally (by doing a I<return>)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:167
msgid ""
"In the following shell session, the main thread sends a cancellation request "
"to the other thread:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:177
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"
msgstr ""
"$ B<./a.out>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Canceling thread\n"
"Called clean-up handler\n"
"Thread was canceled; cnt = 0\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:185
msgid ""
"From the above, we see that the thread was canceled, and that the "
"cancellation clean-up handler was called and it reset the value of the "
"global variable I<cnt> to 0."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:188
msgid ""
"In the next run, the main program sets a global variable that causes other "
"thread to terminate normally:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:196
#, no-wrap
msgid ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"
msgstr ""
"$ B<./a.out x>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Thread terminated normally; cnt = 2\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:204
msgid ""
"From the above, we see that the clean-up handler was not executed (because "
"I<cleanup_pop_arg> was 0), and therefore the value of I<cnt> was not reset."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:209
msgid ""
"In the next run, the main program sets a global variable that causes the "
"other thread to terminate normally, and supplies a nonzero value for "
"I<cleanup_pop_arg>:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:218
#, no-wrap
msgid ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"
msgstr ""
"$ B<./a.out x 1>\n"
"New thread started\n"
"cnt = 0\n"
"cnt = 1\n"
"Called clean-up handler\n"
"Thread terminated normally; cnt = 0\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:225
msgid ""
"In the above, we see that although the thread was not canceled, the clean-up "
"handler was executed, because the argument given to B<pthread_cleanup_pop>"
"()  was nonzero."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:234
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>sys/types.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:241
#, no-wrap
msgid ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"
msgstr ""
"static int done = 0;\n"
"static int cleanup_pop_arg = 0;\n"
"static int cnt = 0;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:248
#, no-wrap
msgid ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"
msgstr ""
"static void\n"
"cleanup_handler(void *arg)\n"
"{\n"
"    printf(\"Called clean-up handler\\en\");\n"
"    cnt = 0;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:253
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    time_t start, curr;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:255
#, no-wrap
msgid "    printf(\"New thread started\\en\");\n"
msgstr "    printf(\"New thread started\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:257
#, no-wrap
msgid "    pthread_cleanup_push(cleanup_handler, NULL);\n"
msgstr "    pthread_cleanup_push(cleanup_handler, NULL);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:259
#, no-wrap
msgid "    curr = start = time(NULL);\n"
msgstr "    curr = start = time(NULL);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:268
#, no-wrap
msgid ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"
msgstr ""
"    while (!done) {\n"
"        pthread_testcancel();           /* A cancellation point */\n"
"        if (curr E<lt> time(NULL)) {\n"
"            curr = time(NULL);\n"
"            printf(\"cnt = %d\\en\", cnt);  /* A cancellation point */\n"
"            cnt++;\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:272
#, no-wrap
msgid ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"
msgstr ""
"    pthread_cleanup_pop(cleanup_pop_arg);\n"
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:279
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thr;\n"
"    int s;\n"
"    void *res;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:283
#, no-wrap
msgid ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thr, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:285
#, no-wrap
msgid "    sleep(2);           /* Allow new thread to run a while */\n"
msgstr "    sleep(2);           /* Allow new thread to run a while */\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:290
#, no-wrap
msgid ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"
msgstr ""
"    if (argc E<gt> 1) {\n"
"        if (argc E<gt> 2)\n"
"            cleanup_pop_arg = atoi(argv[2]);\n"
"        done = 1;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:297
#, no-wrap
msgid ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"
msgstr ""
"    } else {\n"
"        printf(\"Canceling thread\\en\");\n"
"        s = pthread_cancel(thr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_cancel\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:308
#, no-wrap
msgid ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    if (res == PTHREAD_CANCELED)\n"
"        printf(\"Thread was canceled; cnt = %d\\en\", cnt);\n"
"    else\n"
"        printf(\"Thread terminated normally; cnt = %d\\en\", cnt);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push.3:315
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push_defer_np>(3), "
"B<pthread_setcancelstate>(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_cleanup_push_defer_np.3:24
#, no-wrap
msgid "PTHREAD_CLEANUP_PUSH_DEFER_NP"
msgstr "PTHREAD_CLEANUP_PUSH_DEFER_NP"

#. type: TH
#: build/C/man3/pthread_cleanup_push_defer_np.3:24
#, no-wrap
msgid "2008-12-04"
msgstr "2008-12-04"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:28
msgid ""
"pthread_cleanup_push_defer_np, pthread_cleanup_pop_restore_np - push and pop "
"thread cancellation clean-up handlers while saving cancelability type"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:35
#, no-wrap
msgid ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"
msgstr ""
"B<void pthread_cleanup_push_defer_np(void (*>I<routine>B<)(void *),>\n"
"B<                                   void *>I<arg>B<);>\n"
"B<void pthread_cleanup_pop_restore_np(int >I<execute>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:38
#: build/C/man3/pthread_create.3:36 build/C/man3/pthread_detach.3:35
#: build/C/man3/pthread_join.3:35 build/C/man3/pthread_kill.3:35
#: build/C/man3/pthread_sigmask.3:36 build/C/man3/pthread_sigqueue.3:35
#: build/C/man3/pthread_tryjoin_np.3:40 build/C/man3/pthread_yield.3:34
msgid "Compile and link with I<-pthread>."
msgstr "I<-pthread> を付けてコンパイルとリンクを行う。"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:44
msgid ""
"These functions are the same as B<pthread_cleanup_push>(3)  and "
"B<pthread_cleanup_pop>(3), except for the differences noted on this page."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:57
msgid ""
"Like B<pthread_cleanup_push>(3), B<pthread_cleanup_push_defer_np>()  pushes "
"I<routine> onto the thread's stack of cancellation clean-up handlers.  In "
"addition, it also saves the thread's current cancelability type, and sets "
"the cancelability type to \"deferred\" (see B<pthread_setcanceltype>(3)); "
"this ensures that cancellation clean-up will occur even if the thread's "
"cancelability type was \"asynchronous\" before the call."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:66
msgid ""
"Like B<pthread_cleanup_pop>(3), B<pthread_cleanup_pop_restore_np>()  pops "
"the top-most clean-up handler from the thread's stack of cancellation clean-"
"up handlers.  In addition, it restores the thread's cancelability type to "
"its value at the time of the matching B<pthread_cleanup_push_defer_np>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:72
msgid ""
"The caller must ensure that calls to these functions are paired within the "
"same function, and at the same lexical nesting level.  Other restrictions "
"apply, as described in B<pthread_cleanup_push>(3)."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:74
msgid "This sequence of calls:"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:79
#, no-wrap
msgid ""
"pthread_cleanup_push_defer_np(routine, arg);\n"
"pthread_cleanup_pop_restore_np(execute);\n"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:83
msgid "is equivalent to (but shorter and more efficient than):"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:89
#, no-wrap
msgid "int oldtype;\n"
msgstr "int oldtype;\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:95
#, no-wrap
msgid ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"
msgstr ""
"pthread_cleanup_push(routine, arg);\n"
"pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, &oldtype);\n"
"\\&...\n"
"pthread_setcanceltype(oldtype, NULL);\n"
"pthread_cleanup_pop(execute);\n"

#. type: Plain text
#: build/C/man3/pthread_cleanup_push_defer_np.3:108
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_setcancelstate>"
"(3), B<pthread_testcancel>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_setcancelstate>"
"(3), B<pthread_testcancel>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_create.3:24
#, no-wrap
msgid "PTHREAD_CREATE"
msgstr "PTHREAD_CREATE"

#. type: Plain text
#: build/C/man3/pthread_create.3:27
msgid "pthread_create - create a new thread"
msgstr "pthread_create - 新しいスレッドを作成する"

#. type: Plain text
#: build/C/man3/pthread_create.3:33
#, no-wrap
msgid ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"
msgstr ""
"B<int pthread_create(pthread_t *>I<thread>B<, const pthread_attr_t *>I<attr>B<,>\n"
"B<                   void *(*>I<start_routine>B<) (void *), void *>I<arg>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:45
msgid ""
"The B<pthread_create>()  function starts a new thread in the calling "
"process.  The new thread starts execution by invoking I<start_routine>(); "
"I<arg> is passed as the sole argument of I<start_routine>()."
msgstr ""
"B<pthread_create>() 関数は、呼び出したプロセス内に新しいスレッドを作成す"
"る。\n"
"新しいスレッドの実行は、 I<start_routine>() を起動することで開始される。\n"
"I<start_routine>() は引き数を一つだけ取り、\n"
"I<arg> が I<start_routine>() の引き数として渡される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:47
msgid "The new thread terminates in one of the following ways:"
msgstr "新しく作成されたスレッドは、以下のいずれかで終了する。"

#. type: IP
#: build/C/man3/pthread_create.3:47 build/C/man3/pthread_create.3:53
#: build/C/man3/pthread_create.3:61 build/C/man3/pthread_create.3:64
#: build/C/man3/pthread_getattr_np.3:50 build/C/man3/pthread_getattr_np.3:53
#: build/C/man3/pthread_getattr_np.3:56
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man3/pthread_create.3:53
msgid ""
"It calls B<pthread_exit>(3), specifying an exit status value that is "
"available to another thread in the same process that calls B<pthread_join>"
"(3)."
msgstr ""
"スレッドが B<pthread_exit>(3) を呼び出す。\n"
"B<pthread_exit>(3) を呼び出す際には終了ステータス値を指定する。\n"
"この値は B<pthread_join>(3) を呼び出した同じプロセス内の\n"
"別のスレッドで参照できる。"

#. type: Plain text
#: build/C/man3/pthread_create.3:61
msgid ""
"It returns from I<start_routine>().  This is equivalent to calling "
"B<pthread_exit>(3)  with the value supplied in the I<return> statement."
msgstr ""
"スレッドが I<start_routine>() から返る。これは、\n"
"I<return> 文に渡した値で B<pthread_exit>(3) を呼び出すのと等価である。"

#. type: Plain text
#: build/C/man3/pthread_create.3:64
msgid "It is canceled (see B<pthread_cancel>(3))."
msgstr "スレッドがキャンセルされる (B<pthread_cancel>(3) 参照)。"

#. type: Plain text
#: build/C/man3/pthread_create.3:70
msgid ""
"Any of the threads in the process calls B<exit>(3), or the main thread "
"performs a return from I<main>().  This causes the termination of all "
"threads in the process."
msgstr ""
"プロセス内のいずれかのスレッドで B<exit>(3) が呼ばれるか、\n"
"メインスレッドで I<main>() 内で return が実行される。\n"
"この場合は、プロセス内の全てのスレッドが終了される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:84
msgid ""
"The I<attr> argument points to a I<pthread_attr_t> structure whose contents "
"are used at thread creation time to determine attributes for the new thread; "
"this structure is initialized using B<pthread_attr_init>(3)  and related "
"functions.  If I<attr> is NULL, then the thread is created with default "
"attributes."
msgstr ""
"I<attr> 引き数は I<pthread_attr_t> 構造体へのポインタであり、\n"
"I<pthread_attr_t> 構造体の内容を使用して、スレッド作成時に\n"
"新しいスレッドの属性が決定される。\n"
"この構造体は B<pthread_attr_init>(3) や関連の関数を使って初期化される。\n"
"I<attr> が NULL の場合、新しいスレッドはデフォルトの属性で作成される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:91
msgid ""
"Before returning, a successful call to B<pthread_create>()  stores the ID of "
"the new thread in the buffer pointed to by I<thread>; this identifier is "
"used to refer to the thread in subsequent calls to other pthreads functions."
msgstr ""
"成功した場合は、 B<pthread_create>() は返る前に新しいスレッドの ID を\n"
"I<thread> が指すバッファに格納する。この ID は、これ以降に他の\n"
"pthreads 関数の呼び出しでスレッドを参照するのに使用される。"

#. type: Plain text
#: build/C/man3/pthread_create.3:99
msgid ""
"The new thread inherits a copy of the creating thread's signal mask "
"(B<pthread_sigmask>(3)).  The set of pending signals for the new thread is "
"empty (B<sigpending>(2)).  The new thread does not inherit the creating "
"thread's alternate signal stack (B<sigaltstack>(2))."
msgstr ""
"新しいスレッドは、スレッドを作成したスレッドのシグナルマスク\n"
"(B<pthread_sigmask>(3) 参照) のコピーを継承する。\n"
"新しいスレッドの処理待ちシグナル (B<sigpending>(2)) の集合は空となる。\n"
"新しいスレッドはスレッドを作成したスレッドの代替シグナルスタック\n"
"(B<sigaltstack>(2)) を継承しない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:102
msgid ""
"The new thread inherits the calling thread's floating-point environment "
"(B<fenv>(3))."
msgstr ""
"新しいスレッドは呼び出したスレッドの浮動小数点環境 (B<fenv>(3))\n"
"を継承する。"

#.  CLOCK_THREAD_CPUTIME_ID in clock_gettime(2)
#. type: Plain text
#: build/C/man3/pthread_create.3:107
msgid ""
"The initial value of the new thread's CPU-time clock is 0 (see "
"B<pthread_getcpuclockid>(3))."
msgstr ""
"新しいスレッドの CPU 時間時計の初期値は 0 である\n"
"(B<pthread_getcpuclockid>(3) 参照)。"

#. type: SS
#: build/C/man3/pthread_create.3:107
#, no-wrap
msgid "Linux-specific details"
msgstr "Linux 固有の詳細"

#. type: Plain text
#: build/C/man3/pthread_create.3:113
msgid ""
"The new thread inherits copies of the calling thread's capability sets (see "
"B<capabilities>(7))  and CPU affinity mask (see B<sched_setaffinity>(2))."
msgstr ""
"新しいスレッドは、呼び出したスレッドの\n"
"ケーパビリティセット (B<capabilities>(7) 参照) と \n"
"CPU affinity マスク (B<sched_setaffinity>(2) 参照) の\n"
"コピーをを継承しない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:120
msgid ""
"On success, B<pthread_create>()  returns 0; on error, it returns an error "
"number, and the contents of I<*thread> are undefined."
msgstr ""
"成功すると、 B<pthread_create>() は 0 を返す。\n"
"エラーの場合は、エラー番号が返され、 I<*thread> の内容は不定である。"

#. type: TP
#: build/C/man3/pthread_create.3:121 build/C/man3/pthread_sigqueue.3:69
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man3/pthread_create.3:135
msgid ""
"Insufficient resources to create another thread, or a system-imposed limit "
"on the number of threads was encountered.  The latter case may occur in two "
"ways: the B<RLIMIT_NPROC> soft resource limit (set via B<setrlimit>(2)), "
"which limits the number of process for a real user ID, was reached; or the "
"kernel's system-wide limit on the number of threads, I</proc/sys/kernel/"
"threads-max>, was reached."
msgstr ""
"別のスレッドを作成するのに十分なリソースがないか、システムで設定された\n"
"スレッド数の上限に達していた。後者が起こるのは 2 つの場合がある。\n"
"一つは、実ユーザ ID 当たりのプロセス数の上限である、B<RLIMIT_NPROC> \n"
"ソフトリソース上限 (B<setrlimit>(2) で設定できる) に達していた場合\n"
"である。もう一つはカーネルのシステム全体のスレッド数の上限である\n"
"I</proc/sys/kernel/threads-max> が達していた場合である。"

#. type: Plain text
#: build/C/man3/pthread_create.3:139
msgid "Invalid settings in I<attr>."
msgstr "I<attr> で指定された設定が不正である。"

#. type: TP
#: build/C/man3/pthread_create.3:139 build/C/man3/pthread_setschedparam.3:127
#: build/C/man3/pthread_setschedprio.3:64
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man3/pthread_create.3:144
msgid ""
"No permission to set the scheduling policy and parameters specified in "
"I<attr>."
msgstr ""
"I<attr> に指定されたスケジューリングポリシーとパラメータを\n"
"設定する許可がない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:158
msgid ""
"See B<pthread_self>(3)  for further information on the thread ID returned in "
"I<*thread> by B<pthread_create>().  Unless real-time scheduling policies are "
"being employed, after a call to B<pthread_create>(), it is indeterminate "
"which thread\\(emthe caller or the new thread\\(emwill next execute."
msgstr ""
"B<pthread_create>() が I<*thread> で返すスレッド ID についての\n"
"詳しい情報は B<pthread_self>(3) を参照のこと。\n"
"リアルタイムスケジューリングポリシーが使用されない限り、\n"
"B<pthread_create>() の呼び出し後に、\n"
"どのスレッドが\\(em呼び出したスレッドか新しいスレッドか\\(em\n"
"次に実行されるかは決まっていない。"

#. type: Plain text
#: build/C/man3/pthread_create.3:178
msgid ""
"A thread may either be I<joinable> or I<detached>.  If a thread is joinable, "
"then another thread can call B<pthread_join>(3)  to wait for the thread to "
"terminate and fetch its exit status.  Only when a terminated joinable thread "
"has been joined are the last of its resources released back to the system.  "
"When a detached thread terminates, its resources are automatically released "
"back to the system: it is not possible to join with the thread in order to "
"obtain its exit status.  Making a thread detached is useful for some types "
"of daemon threads whose exit status the application does not need to care "
"about.  By default, a new thread is created in a joinable state, unless "
"I<attr> was set to create the thread in a detached state (using "
"B<pthread_attr_setdetachstate>(3))."
msgstr ""
"スレッドは I<join 可能>か I<detached (切り離された状態)> のどちらかに\n"
"することができる。スレッドが join 可能な場合、別のスレッドが\n"
"B<pthread_join>(3) を使って終了したスレッドを待ち、終了ステータスを取得\n"
"することができる。終了した join 可能なスレッドは join された場合にのみ、\n"
"そのスレッドの最後に残ったリソースが解放されシステムに戻される。\n"
"detached 状態のスレッドが終了すると、そのスレッドのリソースは自動的に\n"
"システムに戻される。detached 状態のスレッドを join して、その終了\n"
"ステータスを取得することはできない。スレッドを detached 状態にするのは、\n"
"その終了ステータスをアプリケーションが気にする必要がないある種の\n"
"デーモン (daemon) スレッドでは有用である。\n"
"デフォルトでは、新しいスレッドは join 可能な状態で作成される。\n"
"(B<pthread_attr_setdetachstate>(3) を使って) I<attr> でスレッドが\n"
"detached 状態で作成されるように設定されていない限り、join 可能な状態で\n"
"作成される。"

#.  FIXME . Perhaps some of the following detail should be in
#.  a future pthread_attr_setstacksize(3) page.
#. type: Plain text
#: build/C/man3/pthread_create.3:194
msgid ""
"On Linux/x86-32, the default stack size for a new thread is 2 megabytes.  "
"Under the NPTL threading implementation, if the B<RLIMIT_STACK> soft "
"resource limit I<at the time the program started> has any value other than "
"\"unlimited\", then it determines the default stack size of new threads.  "
"Using B<pthread_attr_setstacksize>(3), the stack size attribute can be "
"explicitly set in the I<attr> argument used to create a thread, in order to "
"obtain a stack size other than the default."
msgstr ""
"Linux/x86-32 では、新しいスレッドのデフォルトのスタックサイズは 2MB で\n"
"ある。NPTL スレッド実装の下では、I<プログラム開始時の> B<RLIMIT_STACK>\n"
"ソフトリソース上限が\"unlimited\" 以外の場合、その値が新しいスレッドのデ\n"
"フォルトのスタックサイズとなる。\n"
"B<pthread_attr_setstacksize>(3) を使って、スレッドを作成する際の\n"
"I<attr> 引き数に明示的にスタックサイズ属性を設定することで、\n"
"デフォルト値以外のスタックサイズを得ることができる。"

#. type: Plain text
#: build/C/man3/pthread_create.3:200
msgid ""
"In the obsolete LinuxThreads implementation, each of the threads in a "
"process has a different process ID.  This is in violation of the POSIX "
"threads specification, and is the source of many other nonconformances to "
"the standard; see B<pthreads>(7)."
msgstr ""
"廃止予定の LinuxThreads 実装では、プロセス内の各スレッドは異なる\n"
"プロセス ID を持つ。これは POSIX スレッドの規格に違反しており、\n"
"他の多くの標準非準拠の点の原因になっている。\n"
"B<pthreads>(7) を参照のこと。"

#. type: Plain text
#: build/C/man3/pthread_create.3:204
msgid ""
"The program below demonstrates the use of B<pthread_create>(), as well as a "
"number of other functions in the pthreads API."
msgstr ""
"以下のプログラムは、 B<pthread_create>() や\n"
"pthreads API の他のいろいろな関数の使用例を示している。"

#. type: Plain text
#: build/C/man3/pthread_create.3:209
msgid ""
"In the following run, on a system providing the NPTL threading "
"implementation, the stack size defaults to the value given by the \"stack "
"size\" resource limit:"
msgstr ""
"以下の実行例は、 NPTL スレッド実装が提供されているシステムでのもので、\n"
"スタックサイズがデフォルト値の \"stack size\" リソース上限で指定される値\n"
"になる。"

#. type: Plain text
#: build/C/man3/pthread_create.3:221
#, no-wrap
msgid ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x80000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""
"$B< ulimit -s>\n"
"8192            # The stack size limit is 8 MB (0x80000 bytes)\n"
"$B< ./a.out hola salut servus>\n"
"Thread 1: top of stack near 0xb7dd03b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb75cf3b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb6dce3b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:227
msgid ""
"In the next run, the program explicitly sets a stack size of 1MB (using "
"B<pthread_attr_setstacksize>(3))  for the created threads:"
msgstr ""
"次の実行例では、プログラム内で、作成されるスレッドに対して\n"
"(B<pthread_attr_setstacksize>(3) を使って1MB のスタックサイズを\n"
"明示的に設定している。"

#. type: Plain text
#: build/C/man3/pthread_create.3:237
#, no-wrap
msgid ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"
msgstr ""
"$B< ./a.out -s 0x100000 hola salut servus>\n"
"Thread 1: top of stack near 0xb7d723b8; argv_string=hola\n"
"Thread 2: top of stack near 0xb7c713b8; argv_string=salut\n"
"Thread 3: top of stack near 0xb7b703b8; argv_string=servus\n"
"Joined with thread 1; returned value was HOLA\n"
"Joined with thread 2; returned value was SALUT\n"
"Joined with thread 3; returned value was SERVUS\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:249
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
"#include E<lt>ctype.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:255 build/C/man3/pthread_getcpuclockid.3:108
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:261
#, no-wrap
msgid ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"
msgstr ""
"struct thread_info {    /* Used as argument to thread_start() */\n"
"    pthread_t thread_id;        /* ID returned by pthread_create() */\n"
"    int       thread_num;       /* Application-defined thread # */\n"
"    char     *argv_string;      /* From command-line argument */\n"
"};\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:264
#, no-wrap
msgid ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"
msgstr ""
"/* Thread start function: display address near top of our stack,\n"
"   and return upper-cased copy of argv_string */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:270
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = (struct thread_info *) arg;\n"
"    char *uargv, *p;\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    struct thread_info *tinfo = (struct thread_info *) arg;\n"
"    char *uargv, *p;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:273
#, no-wrap
msgid ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"
msgstr ""
"    printf(\"Thread %d: top of stack near %p; argv_string=%s\\en\",\n"
"            tinfo-E<gt>thread_num, &p, tinfo-E<gt>argv_string);\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:277
#, no-wrap
msgid ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"
msgstr ""
"    uargv = strdup(tinfo-E<gt>argv_string);\n"
"    if (uargv == NULL)\n"
"        handle_error(\"strdup\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:280
#, no-wrap
msgid ""
"    for (p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"
msgstr ""
"    for (p = uargv; *p != \\(aq\\e0\\(aq; p++)\n"
"        *p = toupper(*p);\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:283
#, no-wrap
msgid ""
"    return uargv;\n"
"}\n"
msgstr ""
"    return uargv;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:292
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, tnum, opt, num_threads;\n"
"    struct thread_info *tinfo;\n"
"    pthread_attr_t attr;\n"
"    int stack_size;\n"
"    void *res;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, tnum, opt, num_threads;\n"
"    struct thread_info *tinfo;\n"
"    pthread_attr_t attr;\n"
"    int stack_size;\n"
"    void *res;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:294
#, no-wrap
msgid "    /* The \"-s\" option specifies a stack size for our threads */\n"
msgstr "    /* The \"-s\" option specifies a stack size for our threads */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:301
#, no-wrap
msgid ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"
msgstr ""
"    stack_size = -1;\n"
"    while ((opt = getopt(argc, argv, \"s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqs\\(aq:\n"
"            stack_size = strtoul(optarg, NULL, 0);\n"
"            break;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:308
#, no-wrap
msgid ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"
msgstr ""
"        default:\n"
"            fprintf(stderr, \"Usage: %s [-s stack-size] arg...\\en\",\n"
"                    argv[0]);\n"
"            exit(EXIT_FAILURE);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:310
#, no-wrap
msgid "    num_threads = argc - optind;\n"
msgstr "    num_threads = argc - optind;\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:312
#, no-wrap
msgid "    /* Initialize thread creation attributes */\n"
msgstr "    /* Initialize thread creation attributes */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:316
#, no-wrap
msgid ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"
msgstr ""
"    s = pthread_attr_init(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_init\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:322
#, no-wrap
msgid ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""
"    if (stack_size E<gt> 0) {\n"
"        s = pthread_attr_setstacksize(&attr, stack_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:324
#, no-wrap
msgid "    /* Allocate memory for pthread_create() arguments */\n"
msgstr "    /* Allocate memory for pthread_create() arguments */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:328
#, no-wrap
msgid ""
"    tinfo = calloc(num_threads, sizeof(struct thread_info));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"
msgstr ""
"    tinfo = calloc(num_threads, sizeof(struct thread_info));\n"
"    if (tinfo == NULL)\n"
"        handle_error(\"calloc\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:330
#, no-wrap
msgid "    /* Create one thread for each command-line argument */\n"
msgstr "    /* Create one thread for each command-line argument */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:334
#, no-wrap
msgid ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"
msgstr ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        tinfo[tnum].thread_num = tnum + 1;\n"
"        tinfo[tnum].argv_string = argv[optind + tnum];\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:337
#, no-wrap
msgid ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"
msgstr ""
"        /* The pthread_create() call stores the thread ID into\n"
"           corresponding element of tinfo[] */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:343
#, no-wrap
msgid ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"
msgstr ""
"        s = pthread_create(&tinfo[tnum].thread_id, &attr,\n"
"                           &thread_start, &tinfo[tnum]);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_create\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:346
#, no-wrap
msgid ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"
msgstr ""
"    /* Destroy the thread attributes object, since it is no\n"
"       longer needed */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:350 build/C/man3/pthread_setschedparam.3:421
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
msgstr ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:352
#, no-wrap
msgid "    /* Now join with each thread, and display its returned value */\n"
msgstr "    /* Now join with each thread, and display its returned value */\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:357
#, no-wrap
msgid ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    for (tnum = 0; tnum E<lt> num_threads; tnum++) {\n"
"        s = pthread_join(tinfo[tnum].thread_id, &res);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:362
#, no-wrap
msgid ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"
msgstr ""
"        printf(\"Joined with thread %d; returned value was %s\\en\",\n"
"                tinfo[tnum].thread_num, (char *) res);\n"
"        free(res);      /* Free memory allocated by thread */\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:366
#, no-wrap
msgid ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    free(tinfo);\n"
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_create.3:378
msgid ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), B<pthreads>"
"(7)"
msgstr ""
"B<getrlimit>(2), B<pthread_attr_init>(3), B<pthread_cancel>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_getattr_np>(3), B<pthread_join>(3), B<pthread_self>(3), B<pthreads>"
"(7)"

#. type: TH
#: build/C/man3/pthread_detach.3:24
#, no-wrap
msgid "PTHREAD_DETACH"
msgstr "PTHREAD_DETACH"

#. type: TH
#: build/C/man3/pthread_detach.3:24 build/C/man3/pthread_join.3:24
#, no-wrap
msgid "2008-11-27"
msgstr "2008-11-27"

#. type: Plain text
#: build/C/man3/pthread_detach.3:27
msgid "pthread_detach - detach a thread"
msgstr "pthread_detach - スレッドを切り離す (detach する)"

#. type: Plain text
#: build/C/man3/pthread_detach.3:32
#, no-wrap
msgid "B<int pthread_detach(pthread_t >I<thread>B<);>\n"
msgstr "B<int pthread_detach(pthread_t >I<thread>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_detach.3:44
msgid ""
"The B<pthread_detach>()  function marks the thread identified by I<thread> "
"as detached.  When a detached thread terminates, its resources are "
"automatically released back to the system without the need for another "
"thread to join with the terminated thread."
msgstr ""
"B<pthread_detach>() 関数は I<thread> で識別されるスレッドに\n"
"detached (切り離された状態) という印を付ける。\n"
"detached 状態のスレッドが終了すると、\n"
"別のスレッドが終了されたスレッドを join しなくても、\n"
"そのスレッドのリソースは自動的に解放されてシステムに戻される。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:47
msgid ""
"Attempting to detach an already detached thread results in unspecified "
"behavior."
msgstr ""
"すでに detach 状態のスレッドを detach しようとした場合に\n"
"どのような結果となるかは規定されていない。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:52
msgid ""
"On success, B<pthread_detach>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、B<pthread_detach>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:57 build/C/man3/pthread_join.3:87
msgid "I<thread> is not a joinable thread."
msgstr "I<thread> が join 可能なスレッドではない。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:68
msgid ""
"Once a thread has been detached, it can't be joined with B<pthread_join>(3)  "
"or be made joinable again."
msgstr ""
"いったんスレッドを detached 状態にすると、\n"
"そのスレッドを B<pthread_join>(3) で join したり、\n"
"もう一度 join 可能にしたりすることはできない。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:75
msgid ""
"A new thread can be created in a detached state using "
"B<pthread_attr_setdetachstate>(3)  to set the detached attribute of the "
"I<attr> argument of B<pthread_create>(3)."
msgstr ""
"B<pthread_attr_setdetachstate>(3) を使って\n"
"B<pthread_create>(3) の I<attr> 引き数の detached 属性を設定することで、\n"
"新しいスレッドを detached 状態で作成することができる。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:82
msgid ""
"The detached attribute merely determines the behavior of the system when the "
"thread terminates; it does not prevent the thread from being terminated if "
"the process terminates using B<exit>(3)  (or equivalently, if the main "
"thread returns)."
msgstr ""
"detached 属性は、スレッドが終了した際のシステムの動作を決めるだけである。\n"
"プロセスが B<exit>(3) を使って終了した場合に、そのスレッドが終了され\n"
"なくなるようなことはない (なお、メインスレッドが return した場合も\n"
"プロセスが B<exit>(3) を使って終了した場合と全く同じである)。 "

#. type: Plain text
#: build/C/man3/pthread_detach.3:91
msgid ""
"Either B<pthread_join>(3)  or B<pthread_detach>()  should be called for each "
"thread that an application creates, so that system resources for the thread "
"can be released.  (But note that the resources of all threads are freed when "
"the process terminates.)"
msgstr ""
"アプリケーションが作成した各スレッドについて、そのスレッドが使用して\n"
"いるシステムリソースを解放できるように、B<pthread_join>(3) か\n"
"B<pthread_detach>() のどちらかを呼び出すべきである (ただし、プロセスが\n"
"終了するときには、全てのスレッドのリソースが解放される)。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:93
msgid "The following statement detaches the calling thread:"
msgstr "以下の文は、呼び出したスレッド自身を detach する。"

#. type: Plain text
#: build/C/man3/pthread_detach.3:95
#, no-wrap
msgid "    pthread_detach(pthread_self());\n"
msgstr "    pthread_detach(pthread_self());\n"

#. type: Plain text
#: build/C/man3/pthread_detach.3:102
msgid ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), B<pthread_create>"
"(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_setdetachstate>(3), B<pthread_cancel>(3), B<pthread_create>"
"(3), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_equal.3:24
#, no-wrap
msgid "PTHREAD_EQUAL"
msgstr "PTHREAD_EQUAL"

#. type: TH
#: build/C/man3/pthread_equal.3:24 build/C/man3/pthread_exit.3:24
#, no-wrap
msgid "2009-03-30"
msgstr "2009-03-30"

#. type: Plain text
#: build/C/man3/pthread_equal.3:27
msgid "pthread_equal - compare thread IDs"
msgstr "pthread_equal - スレッド ID を比較する"

#. type: Plain text
#: build/C/man3/pthread_equal.3:32
#, no-wrap
msgid "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"
msgstr "B<int pthread_equal(pthread_t >I<t1>B<, pthread_t >I<t2>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_equal.3:39
msgid "The B<pthread_equal>()  function compares two thread identifiers."
msgstr "B<pthread_equal>() 関数は 2 つのスレッド識別子の比較を行う。"

#. type: Plain text
#: build/C/man3/pthread_equal.3:43
msgid ""
"If the two thread IDs are equal, B<pthread_equal>()  returns a nonzero "
"value; otherwise, it returns 0."
msgstr ""
"B<pthread_equal>() は、2 つのスレッド ID が等しければ 0 以外の値を返し、\n"
"そうでなければ 0 を返す。"

#.  SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_equal.3:45 build/C/man3/pthread_exit.3:73
#: build/C/man3/pthread_self.3:48 build/C/man3/pthread_testcancel.3:56
msgid "This function always succeeds."
msgstr "この関数は常に成功する。"

#. type: Plain text
#: build/C/man3/pthread_equal.3:54
msgid ""
"The B<pthread_equal>()  function is necessary because thread IDs should be "
"considered opaque: there is no portable way for applications to directly "
"compare two I<pthread_t> values."
msgstr ""
"B<pthread_equal>() 関数が必要なのは、\n"
"スレッド ID はその内部構造を意識すべきではないためである。\n"
"アプリケーションが 2 つの I<pthread_t> の値を直接比較する場合、\n"
"移植性を確保できる形で比較する方法はない。"

#. type: Plain text
#: build/C/man3/pthread_equal.3:58
msgid "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_self>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_exit.3:24
#, no-wrap
msgid "PTHREAD_EXIT"
msgstr "PTHREAD_EXIT"

#. type: Plain text
#: build/C/man3/pthread_exit.3:27
msgid "pthread_exit - terminate calling thread"
msgstr "pthread_exit - 呼び出したスレッドを終了する"

#. type: Plain text
#: build/C/man3/pthread_exit.3:32
#, no-wrap
msgid "B<void pthread_exit(void *>I<retval>B<);>\n"
msgstr "B<void pthread_exit(void *>I<retval>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_exit.3:43
msgid ""
"The B<pthread_exit>()  function terminates the calling thread and returns a "
"value via I<retval> that (if the thread is joinable)  is available to "
"another thread in the same process that calls B<pthread_join>(3)."
msgstr ""
"B<pthread_exit>() 関数は、呼び出したスレッドを終了し、\n"
"I<retval> 経由で値を返す。\n"
"この値は (そのスレッドが join 可能な場合に) B<pthread_join>(3) を\n"
"呼び出した同じプロセス内の別のスレッドが参照できる値と同じである。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:53
msgid ""
"Any clean-up handlers established by B<pthread_cleanup_push>(3)  that have "
"not yet been popped, are popped (in the reverse of the order in which they "
"were pushed)  and executed.  If the thread has any thread-specific data, "
"then, after the clean-up handlers have been executed, the corresponding "
"destructor functions are called, in an unspecified order."
msgstr ""
"B<pthread_cleanup_push>(3) で設定されたクリーンアップハンドラのうち、\n"
"まだ pop (取り出されていない) ハンドラを (push されたのと逆の順序で)\n"
"取り出して実行する。そのスレッドがスレッド固有のデータを持っている\n"
"場合は、クリーンアップハンドラが実行された後に、スレッド固有のデータ\n"
"に対応するデストラクタ (destructor) 関数が呼び出される (呼び出し順序\n"
"は規定されていない)。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:60
msgid ""
"When a thread terminates, process-shared resources (e.g., mutexes, condition "
"variables, semaphores, and file descriptors) are not released, and functions "
"registered using B<atexit>(3)  are not called."
msgstr ""
"スレッドが終了する際に、プロセスの共有リソース (例えば、mutex、状態変数\n"
"(condition variables)、セマフォ、ファイルディスクリプタ)が解放される。\n"
"B<atexit>(3) を使って登録された関数は呼び出されない。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:69
msgid ""
"After the last thread in a process terminates, the process terminates as by "
"calling B<exit>(3)  with an exit status of zero; thus, process-shared "
"resources are released and functions registered using B<atexit>(3)  are "
"called."
msgstr ""
"プロセスの最後のスレッドが終了すると、そのプロセスは、終了ステータス 0\n"
"で B<exit>(3) を呼び出した場合と全く同じように終了する。したがって、\n"
"プロセスの共有リソースは解放され、B<atexit>(3) を使って登録された関数\n"
"が呼び出される。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:71
msgid "This function does not return to the caller."
msgstr "この関数は呼び出し側には返らない。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:80
msgid ""
"Performing a return from the start function of any thread other than the "
"main thread results in an implicit call to B<pthread_exit>(), using the "
"function's return value as the thread's exit status."
msgstr ""
"メインスレッド以外のスレッドの開始関数 (start function) がreturn を\n"
"行うと、暗黙のうちに B<pthread_exit>() が呼び出され、\n"
"関数の返り値がスレッドの終了ステータスとして使用される。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:86
msgid ""
"To allow other threads to continue execution, the main thread should "
"terminate by calling B<pthread_exit>()  rather than B<exit>(3)."
msgstr ""
"他のスレッドが実行を継続できるように、メインスレッドは B<exit>(3) では\n"
"なく B<pthread_exit>() を呼び出して終了すべきである。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:91
msgid ""
"The value pointed to by I<retval> should not be located on the calling "
"thread's stack, since the contents of that stack are undefined after the "
"thread terminates."
msgstr ""
"I<retval> が指す値は、呼び出したスレッドのスタックに置くべきではない。\n"
"呼び出したスレッドが終了した後は、そのスタックの内容が不定となるから\n"
"である。"

#.  Linux 2.6.27
#.  FIXME . review a later kernel to see if this gets fixed
#.  http://thread.gmane.org/gmane.linux.kernel/611611
#.  http://marc.info/?l=linux-kernel&m=122525468300823&w=2
#. type: Plain text
#: build/C/man3/pthread_exit.3:103
msgid ""
"Currently, there are limitations in the kernel implementation logic for "
"B<wait>(2)ing on a stopped thread group with a dead thread group leader.  "
"This can manifest in problems such as a locked terminal if a stop signal is "
"sent to a foreground process whose thread group leader has already called "
"B<pthread_exit>()."
msgstr ""
"現在のところ、停止 (stop) されたスレッドグループを、すでに終了した\n"
"(dead) スレッドグループリーダーで B<wait>(2) する場合の、\n"
"カーネル実装の論理には制限がある。\n"
"この制限は、すでにスレッドグループリーダーが B<pthread_exit>() を\n"
"呼び出しているようなフォアグラウンドプロセスにストップシグナルが送信\n"
"された場合に、端末がロックされてしまう、といった問題として表に見える\n"
"場合がある。"

#. type: Plain text
#: build/C/man3/pthread_exit.3:107
msgid "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_getattr_np.3:24
#, no-wrap
msgid "PTHREAD_GETATTR_NP"
msgstr "PTHREAD_GETATTR_NP"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:27
msgid "pthread_getattr_np - get attributes of created thread"
msgstr "pthread_getattr_np - 作成されたスレッドの属性を取得する"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:33
#, no-wrap
msgid "B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t *>I<attr>B<);>\n"
msgstr "B<int pthread_getattr_np(pthread_t >I<thread>B<, pthread_attr_t *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:43
msgid ""
"The B<pthread_getattr_np>()  function initializes the thread attributes "
"object referred to by I<attr> so that it contains actual attribute values "
"describing the running thread I<thread>."
msgstr ""
"B<pthread_getattr_np>() 関数は、\n"
"I<attr> が参照するスレッド属性オブジェクトを初期化し、\n"
"そのオブジェクトに実行中のスレッド I<thread> の実際の属性値を\n"
"格納して返す。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:50
msgid ""
"The returned attribute values may differ from the corresponding attribute "
"values passed in the I<attr> object that was used to create the thread using "
"B<pthread_create>(3).  In particular, the following attributes may differ:"
msgstr ""
"返される属性値は、B<pthread_create>(3) でスレッドを作成する際に\n"
"使われたI<attr> オブジェクトで渡された属性値と異なる場合がある。\n"
"特に、以下の属性は異なる場合がある。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:53
msgid ""
"the detach state, since a joinable thread may have detached itself after "
"creation;"
msgstr ""
"detach state. join 可能なスレッドは作成後に自分自身を\n"
"切り離す (detach する) ことができるからである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:56
msgid ""
"the stack size, which the implementation may align to a suitable boundary."
msgstr ""
"スタックサイズ。\n"
"スレッドの実装によって適切な境界に揃えられる可能があるためである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:61
msgid ""
"and the guard size, which the implementation may round upward to a multiple "
"of the page size, or ignore (i.e., treat as 0), if the application is "
"allocating its own stack."
msgstr ""
"guard size.\n"
"スレッドの実装によりページサイズの倍数に切り上げられたり、\n"
"アプリケーションが自分でスタックを割り当てる場合には無視される\n"
"(0 として扱われる) ことがあるからである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:66
msgid ""
"Furthermore, if the stack address attribute was not set in the thread "
"attributes object used to create the thread, then the returned thread "
"attributes object will report the actual stack address that the "
"implementation selected for the thread."
msgstr ""
"さらに、スレッドを作成する際に使用されたスレッド属性オブジェクトで\n"
"スタックアドレスが設定されていなかった場合、\n"
"返されたスレッド属性オブジェクトではスレッドの実装がそのスレッドに\n"
"割り当てた実際のスタックアドレスが報告される。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:71
msgid ""
"When the thread attributes object returned by B<pthread_getattr_np>()  is no "
"longer required, it should be destroyed using B<pthread_attr_destroy>(3)."
msgstr ""
"B<pthread_getattr_np>() が返したスレッド属性オブジェクトが\n"
"必要なくなった際には、  B<pthread_attr_destroy>(3) を使って\n"
"そのオブジェクトを破棄すべきである。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:74
#: build/C/man3/pthread_getcpuclockid.3:47
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number."
msgstr ""
"成功すると、この関数は 0 を返す。\n"
"エラーの場合、 0 以外のエラー番号を返す。"

#.  Can happen (but unlikely) while trying to allocate memory for cpuset
#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:79
msgid "Insufficient memory."
msgstr "メモリが十分になかった。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:94
msgid ""
"In addition, if I<thread> refers to the main thread, then "
"B<pthread_getattr_np>()  can fail because of errors from various underlying "
"calls: B<fopen>(3), if I</proc/self/maps> can't be opened; and B<getrlimit>"
"(2), if the B<RLIMIT_STACK> resource limit is not supported."
msgstr ""
"さらに、 I<thread> がメインスレッドを参照している場合には、\n"
"B<pthread_getattr_np>() は内部で行われる様々な呼び出しでの\n"
"エラーで失敗する可能性がある。\n"
"I</proc/self/maps> がオープンできない場合には B<fopen>(3)\n"
"でエラーが発生し、リソース上限 B<RLIMIT_STACK> が\n"
"サポートされていない場合には B<getrlimit>(2) でエラーが発生する。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:96
msgid "This function is available in glibc since version 2.2.3."
msgstr "この関数は glibc バージョン 2.2.3 以降で利用できる。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:99
#: build/C/man3/pthread_kill_other_threads_np.3:48
msgid ""
"This function is a nonstandard GNU extension; hence the suffix \"_np"
"\" (nonportable) in the name."
msgstr ""
"この関数は非標準の GNU による拡張である。\n"
"そのため、名前に \"_np\" (nonportable; 移植性がない) という接尾辞が\n"
"付いている。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:109
msgid ""
"The program below demonstrates the use of B<pthread_getattr_np>().  The "
"program creates a thread that then uses B<pthread_getattr_np>()  to retrieve "
"and display its guard size, stack address, and stack size attributes.  "
"Command-line arguments can be used to set these attributes to values other "
"than the default when creating the thread.  The shell sessions below "
"demonstrate the use of the program."
msgstr ""
"以下のプログラムは B<pthread_getattr_np>() の使用例を示したものである。\n"
"このプログラムは、スレッドを作成し、それから\n"
"B<pthread_getattr_np>() を使ってそのスレッドの属性 guard size、\n"
"スタックアドレス、スタックサイズを取得し表示する。\n"
"コマンドライン引き数での指定で、スレッドを作成する際に\n"
"上記の属性にデフォルト値以外の値を設定することができる。\n"
"下記のシェルのセッションはこのプログラムの使用例である。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:112
msgid ""
"In the first run, on an x86-32 system, a thread is created using default "
"attributes:"
msgstr ""
"最初の実行例は、デフォルトの属性でスレッドが作成されている\n"
"(x86-32 システム上で実行)。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:122
#, no-wrap
msgid ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""
"$B< ulimit -s>      # No stack limit ==E<gt> default stack size is 2MB\n"
"unlimited\n"
"$B< ./a.out>\n"
"Attributes of created thread:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:128
msgid ""
"In the following run, we see that if a guard size is specified, it is "
"rounded up to the next multiple of the system page size (4096 bytes on "
"x86-32):"
msgstr ""
"次の実行例では、guard size が指定された場合、\n"
"guard size はシステムのページサイズの倍数に切り上げられることが分かる\n"
"(x86-32 ではシステムのページサイズは 4096 バイトである)。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:136
#, no-wrap
msgid ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"
msgstr ""
"$B< ./a.out -g 4097>\n"
"Thread attributes object after initializations:\n"
"        Guard size          = 4097 bytes\n"
"        Stack address       = (nil)\n"
"        Stack size          = 0x0 (0) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:141
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"
msgstr ""
"Attributes of created thread:\n"
"        Guard size          = 8192 bytes\n"
"        Stack address       = 0x40196000 (EOS = 0x40397000)\n"
"        Stack size          = 0x201000 (2101248) bytes\n"

#. .in +4n
#. .nf
#. $ ./a.out \-s 0x8000
#. Thread attributes object after initializations:
#.         Guard size          = 4096 bytes
#.         Stack address       = 0xffff8000 (EOS = (nil))
#.         Stack size          = 0x8000 (32768) bytes
#. Attributes of created thread:
#.         Guard size          = 4096 bytes
#.         Stack address       = 0x4001e000 (EOS = 0x40026000)
#.         Stack size          = 0x8000 (32768) bytes
#. .fi
#. .in
#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:160
msgid ""
"In the last run, the program manually allocates a stack for the thread.  In "
"this case, the guard size attribute is ignored."
msgstr ""
"最後の実行例では、プログラムでスレッド用のスタックを手動で割り当てている。\n"
"この場合には、guard size 属性は無視される。"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:165
#, no-wrap
msgid ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"
msgstr ""
"$B< ./a.out -g 4096 -s 0x8000 -a>\n"
"Allocated thread stack at 0x804d000\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:170
#, no-wrap
msgid ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""
"Thread attributes object after initializations:\n"
"        Guard size          = 4096 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:175
#, no-wrap
msgid ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"
msgstr ""
"Attributes of created thread:\n"
"        Guard size          = 0 bytes\n"
"        Stack address       = 0x804d000 (EOS = 0x8055000)\n"
"        Stack size          = 0x8000 (32768) bytes\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:196
#, no-wrap
msgid ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"
msgstr ""
"static void\n"
"display_stack_related_attributes(pthread_attr_t *attr, char *prefix)\n"
"{\n"
"    int s;\n"
"    size_t stack_size, guard_size;\n"
"    void *stack_addr;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:201
#, no-wrap
msgid ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, guard_size);\n"
msgstr ""
"    s = pthread_attr_getguardsize(attr, &guard_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getguardsize\");\n"
"    printf(\"%sGuard size          = %d bytes\\en\", prefix, guard_size);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:212
#, no-wrap
msgid ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = 0x%x (%d) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"
msgstr ""
"    s = pthread_attr_getstack(attr, &stack_addr, &stack_size);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_getstack\");\n"
"    printf(\"%sStack address       = %p\", prefix, stack_addr);\n"
"    if (stack_size E<gt> 0)\n"
"        printf(\" (EOS = %p)\", (char *) stack_addr + stack_size);\n"
"    printf(\"\\en\");\n"
"    printf(\"%sStack size          = 0x%x (%d) bytes\\en\",\n"
"            prefix, stack_size, stack_size);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:218
#, no-wrap
msgid ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"
msgstr ""
"static void\n"
"display_thread_attributes(pthread_t thread, char *prefix)\n"
"{\n"
"    int s;\n"
"    pthread_attr_t attr;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:222
#, no-wrap
msgid ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"
msgstr ""
"    s = pthread_getattr_np(thread, &attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getattr_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:224
#, no-wrap
msgid "    display_stack_related_attributes(&attr, prefix);\n"
msgstr "    display_stack_related_attributes(&attr, prefix);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:229
#, no-wrap
msgid ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"
msgstr ""
"    s = pthread_attr_destroy(&attr);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_attr_destroy\");\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:235
#, no-wrap
msgid ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"
msgstr ""
"static void *           /* Start function for thread we create */\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Attributes of created thread:\\en\");\n"
"    display_thread_attributes(pthread_self(), \"\\et\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:249
#, no-wrap
msgid ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"static void\n"
"usage(char *pname, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
"    fprintf(stderr, \"Usage: %s [-s stack-size [-a]]\"\n"
"            \" [-g guard-size]\\en\", pname);\n"
"    fprintf(stderr, \"\\et\\et-a means program should allocate stack\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:262
#, no-wrap
msgid ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    long stack_size, guard_size;\n"
"            void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"
msgstr ""
"static pthread_attr_t *   /* Get thread attributes from command line */\n"
"get_thread_attributes_from_cl(int argc, char *argv[],\n"
"                              pthread_attr_t *attrp)\n"
"{\n"
"    int s, opt, allocate_stack;\n"
"    long stack_size, guard_size;\n"
"            void *stack_addr;\n"
"    pthread_attr_t *ret_attrp = NULL;   /* Set to attrp if we initialize\n"
"                                           a thread attributes object */\n"
"    allocate_stack = 0;\n"
"    stack_size = -1;\n"
"    guard_size = -1;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:271
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"ag:s:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq:   allocate_stack = 1;                     break;\n"
"        case \\(aqg\\(aq:   guard_size = strtoul(optarg, NULL, 0);  break;\n"
"        case \\(aqs\\(aq:   stack_size = strtoul(optarg, NULL, 0);  break;\n"
"        default:    usage(argv[0], NULL);\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:274
#, no-wrap
msgid ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"
msgstr ""
"    if (allocate_stack && stack_size == -1)\n"
"        usage(argv[0], \"Specifying -a without -s makes no sense\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:277
#, no-wrap
msgid ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"
msgstr ""
"    if (argc E<gt> optind)\n"
"        usage(argv[0], \"Extraneous command-line arguments\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:280
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"
msgstr ""
"    if (stack_size E<gt>= 0 || guard_size E<gt> 0) {\n"
"        ret_attrp = attrp;\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:285
#, no-wrap
msgid ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_init(attrp);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:297
#, no-wrap
msgid ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"
msgstr ""
"    if (stack_size E<gt>= 0) {\n"
"        if (!allocate_stack) {\n"
"            s = pthread_attr_setstacksize(attrp, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        } else {\n"
"            s = posix_memalign(&stack_addr, sysconf(_SC_PAGESIZE),\n"
"                               stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"posix_memalign\");\n"
"            printf(\"Allocated thread stack at %p\\en\\en\", stack_addr);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:303
#, no-wrap
msgid ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"
msgstr ""
"            s = pthread_attr_setstack(attrp, stack_addr, stack_size);\n"
"            if (s != 0)\n"
"                handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:309
#, no-wrap
msgid ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"
msgstr ""
"    if (guard_size E<gt>= 0) {\n"
"        s = pthread_attr_setguardsize(attrp, guard_size);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setstacksize\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:312
#, no-wrap
msgid ""
"    return ret_attrp;\n"
"}\n"
msgstr ""
"    return ret_attrp;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:321
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s;\n"
"    pthread_t thr;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp = NULL;    /* Set to &attr if we initialize\n"
"                                        a thread attributes object */\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:323
#, no-wrap
msgid "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"
msgstr "    attrp = get_thread_attributes_from_cl(argc, argv, &attr);\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:329
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        printf(\"Thread attributes object after initializations:\\en\");\n"
"        display_stack_related_attributes(attrp, \"\\et\");\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_getattr_np.3:357
msgid ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_attr_getaffinity_np>(3), B<pthread_attr_getdetachstate>(3), "
"B<pthread_attr_getguardsize>(3), B<pthread_attr_getinheritsched>(3), "
"B<pthread_attr_getschedparam>(3), B<pthread_attr_getschedpolicy>(3), "
"B<pthread_attr_getscope>(3), B<pthread_attr_getstack>(3), "
"B<pthread_attr_getstackaddr>(3), B<pthread_attr_getstacksize>(3), "
"B<pthread_attr_init>(3), B<pthread_create>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_getcpuclockid.3:24
#, no-wrap
msgid "PTHREAD_GETCPUCLOCKID"
msgstr "PTHREAD_GETCPUCLOCKID"

#. type: TH
#: build/C/man3/pthread_getcpuclockid.3:24
#, no-wrap
msgid "2009-02-08"
msgstr "2009-02-08"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:27
msgid "pthread_getcpuclockid - retrieve ID of a thread's CPU time clock"
msgstr "pthread_getcpuclockid - スレッドの CPU 時間時計の ID を取得する"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:31
#, no-wrap
msgid ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>pthread.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:33
#, no-wrap
msgid "B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t *>I<clock_id);>\n"
msgstr "B<int pthread_getcpuclockid(pthread_t >I<thread>B<, clockid_t *>I<clock_id);>\n"

#.  The clockid is constructed as follows:
#.  *clockid = CLOCK_THREAD_CPUTIME_ID | (pd->tid << CLOCK_IDFIELD_SIZE)
#.  where CLOCK_IDFIELD_SIZE is 3.
#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:44
msgid ""
"The B<pthread_getcpuclockid>()  function returns the clock ID for the CPU "
"time clock of the thread I<thread>."
msgstr ""
"B<pthread_getcpuclockid>() 関数は、\n"
"スレッド I<thread> の CPU 時間時計のクロック ID を返す。"

#. type: TP
#: build/C/man3/pthread_getcpuclockid.3:48
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#.  CLOCK_THREAD_CPUTIME_ID not defined
#.  Looking at nptl/pthread_getcpuclockid.c an ERANGE error would
#.  be possible if kernel thread IDs took more than 29 bits (which
#.  they currently cannot).
#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:56
msgid "Per-thread CPU time clocks are not supported by the system."
msgstr "スレッド単位の CPU 時間時計はこのシステムではサポートされていない。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:63
msgid "This function is available in glibc since version 2.2."
msgstr "この関数は glibc バージョン 2.2 以降で利用できる。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:76
msgid ""
"When I<thread> refers to the calling thread, this function returns an "
"identifier that refers to the same clock manipulated by B<clock_gettime>(2)  "
"and B<clock_settime>(2)  when given the clock ID B<CLOCK_THREAD_CPUTIME_ID>."
msgstr ""
"I<thread> が呼び出したスレッドを参照している場合、\n"
"クロック ID B<CLOCK_THREAD_CPUTIME_ID> が指定されていれば、\n"
"B<clock_gettime>(2) と B<clock_settime>(2) が操作するのと同じ時計\n"
"を参照する ID が返される。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:82
msgid ""
"The program below creates a thread and then uses B<clock_gettime>(2)  to "
"retrieve the total process CPU time, and the per-thread CPU time consumed by "
"the two threads.  The following shell session shows an example run:"
msgstr ""
"以下のプログラムは、スレッドを作成し、それから\n"
"B<clock_gettime>(2) を使ってプロセス全体の CPU 時間を取得し、\n"
"B<pthread_getcpuclockid>(3) を使って 2 つのスレッドが消費した\n"
"スレッド毎の CPU 時間を取得する。\n"
"下記のシェルのセッションは実行例である。"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:91
#, no-wrap
msgid ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"
msgstr ""
"$ B<./a.out>\n"
"Main thread sleeping\n"
"Subthread starting infinite loop\n"
"Main thread consuming some CPU time...\n"
"Process total CPU time:    1.368\n"
"Main thread CPU time:      0.376\n"
"Subthread CPU time:        0.992\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:97
#, no-wrap
msgid "/* Link with \"-lrt\" */\n"
msgstr "/* \"-lrt\" でリンクする */\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:105
#, no-wrap
msgid ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>time.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>string.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:119
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    printf(\"Subthread starting infinite loop\\en\");\n"
"    for (;;)\n"
"        continue;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:124
#, no-wrap
msgid ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"
msgstr ""
"static void\n"
"pclock(char *msg, clockid_t cid)\n"
"{\n"
"    struct timespec ts;\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:130
#, no-wrap
msgid ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4ld.%03ld\\en\", ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"
msgstr ""
"    printf(\"%s\", msg);\n"
"    if (clock_gettime(cid, &ts) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
"    printf(\"%4ld.%03ld\\en\", ts.tv_sec, ts.tv_nsec / 1000000);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:137
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int j, s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    clockid_t cid;\n"
"    int j, s;\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:141
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, NULL, thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:144
#, no-wrap
msgid ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"
msgstr ""
"    printf(\"Main thread sleeping\\en\");\n"
"    sleep(1);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:148
#, no-wrap
msgid ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"
msgstr ""
"    printf(\"Main thread consuming some CPU time...\\en\");\n"
"    for (j = 0; j E<lt> 2000000; j++)\n"
"        getppid();\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:150
#, no-wrap
msgid "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"
msgstr "    pclock(\"Process total CPU time: \", CLOCK_PROCESS_CPUTIME_ID);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:155
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"
msgstr ""
"    s = pthread_getcpuclockid(pthread_self(), &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Main thread CPU time:   \", cid);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:158
#, no-wrap
msgid ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"
msgstr ""
"    /* The preceding 4 lines of code could have been replaced by:\n"
"       pclock(\"Main thread CPU time:   \", CLOCK_THREAD_CPUTIME_ID); */\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:163
#, no-wrap
msgid ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"
msgstr ""
"    s = pthread_getcpuclockid(thread, &cid);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getcpuclockid\");\n"
"    pclock(\"Subthread CPU time: 1    \", cid);\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:166
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);         /* Terminates both threads */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_getcpuclockid.3:175
msgid ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<clock_settime>(2), B<timer_create>(2), "
"B<clock_getcpuclockid>(3), B<pthread_self>(3), B<pthreads>(7), B<time>(7)"

#. type: TH
#: build/C/man3/pthread_join.3:24
#, no-wrap
msgid "PTHREAD_JOIN"
msgstr "PTHREAD_JOIN"

#. type: Plain text
#: build/C/man3/pthread_join.3:27
msgid "pthread_join - join with a terminated thread"
msgstr "pthread_join - 終了したスレッドを join する"

#. type: Plain text
#: build/C/man3/pthread_join.3:32
#, no-wrap
msgid "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr "B<int pthread_join(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_join.3:47
msgid ""
"The B<pthread_join>()  function waits for the thread specified by I<thread> "
"to terminate.  If that thread has already terminated, then B<pthread_join>"
"()  returns immediately.  The thread specified by I<thread> must be joinable."
msgstr ""
"B<pthread_join>() 関数は、I<thread> で指定されたスレッドが\n"
"終了するのを待つ。そのスレッドがすでに終了している場合、\n"
"B<pthread_join>() はすぐに返る。\n"
"I<thread> で指定されたスレッドは join 可能でなければならない。"

#. type: Plain text
#: build/C/man3/pthread_join.3:61
msgid ""
"If I<retval> is not NULL, then B<pthread_join>()  copies the exit status of "
"the target thread (i.e., the value that the target thread supplied to "
"B<pthread_exit>(3))  into the location pointed to by I<*retval>.  If the "
"target thread was canceled, then B<PTHREAD_CANCELED> is placed in I<*retval>."
msgstr ""
"I<retval> が NULL でない場合、 B<pthread_join>() は対象スレッドの終了\n"
"ステータス (すなわち、対象スレッドが B<pthread_exit>(3) に渡した値) を\n"
"I<*retval> が指す場所にコピーする。対象スレッドがキャンセルされた場合、\n"
"I<*retval> には B<PTHREAD_CANCELED> が格納される。"

#. type: Plain text
#: build/C/man3/pthread_join.3:68
msgid ""
"If multiple threads simultaneously try to join with the same thread, the "
"results are undefined.  If the thread calling B<pthread_join>()  is "
"canceled, then the target thread will remain joinable (i.e., it will not be "
"detached)."
msgstr ""
"複数のスレッドが同時に同じスレッドを join しようとした場合、その結果\n"
"は不定である。B<pthread_join>() を呼び出しているスレッドがキャンセル\n"
"された場合、対象スレッドは join 可能のままとなる (detached 状態には\n"
"ならない)。"

#. type: Plain text
#: build/C/man3/pthread_join.3:73
msgid ""
"On success, B<pthread_join>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_join>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: TP
#: build/C/man3/pthread_join.3:74
#, no-wrap
msgid "B<EDEADLK>"
msgstr "B<EDEADLK>"

#.  The following verified by testing on glibc 2.8/NPTL:
#.  The following verified by testing on glibc 2.8/NPTL:
#. type: Plain text
#: build/C/man3/pthread_join.3:83
msgid ""
"A deadlock was detected (e.g., two threads tried to join with each other); "
"or I<thread> specifies the calling thread."
msgstr ""
"デッドロックが検出された (例えば、二つのスレッドが互いに join しようと\n"
"した場合)、または I<thread> に呼び出したスレッドが指定されている。"

#.  POSIX.1-2001 does not specify this error case.
#. type: Plain text
#: build/C/man3/pthread_join.3:91
msgid "Another thread is already waiting to join with this thread."
msgstr "別のスレッドがすでにこのスレッドの join 待ちである。"

#. type: Plain text
#: build/C/man3/pthread_join.3:102
msgid ""
"After a successful call to B<pthread_join>(), the caller is guaranteed that "
"the target thread has terminated."
msgstr ""
"B<pthread_join>() の呼び出しが成功した場合は、\n"
"呼び出し側には、対象スレッドが終了していることが保証される。"

#. type: Plain text
#: build/C/man3/pthread_join.3:105
msgid ""
"Joining with a thread that has previously been joined results in undefined "
"behavior."
msgstr "すでに join されたスレッドを join した場合の結果は不定である。"

#. type: Plain text
#: build/C/man3/pthread_join.3:113
msgid ""
"Failure to join with a thread that is joinable (i.e., one that is not "
"detached), produces a \"zombie thread\".  Avoid doing this, since each "
"zombie thread consumes some system resources, and when enough zombie threads "
"have accumulated, it will no longer be possible to create new threads (or "
"processes)."
msgstr ""
"join 可能なスレッド (detached 状態でないスレッド) の join に失敗した場合、\n"
"\"ゾンビスレッド (zombie thread)\" が生成される。\n"
"各ゾンビスレッドはシステムリソースをいくらかは消費し、\n"
"ゾンビスレッドがたくさん生成されてしまうと、\n"
"新しいスレッド (やプロセス) がそれ以上作成できなくなってしまうので、\n"
"このようなことが起きるのは避けること。"

#. type: Plain text
#: build/C/man3/pthread_join.3:119
msgid ""
"There is no pthreads analog of I<waitpid(-1,\\ &status,\\ 0)>, that is, "
"\"join with any terminated thread\".  If you believe you need this "
"functionality, you probably need to rethink your application design."
msgstr ""
"pthreads には、 I<waitpid(-1,\\ &status,\\ 0)>、つまり\n"
"\"終了されたスレッドのどれかを join する\" といった機能はない。\n"
"この機能が必要だと思うような場合には、おそらく\n"
"自分のアプリケーションの設計を考え直す必要があるだろう。"

#. type: Plain text
#: build/C/man3/pthread_join.3:122
msgid ""
"All of the threads in a process are peers: any thread can join with any "
"other thread in the process."
msgstr ""
"プロセス内の全てのスレッドは対等であり、\n"
"どのスレッドでもプロセス内の他のスレッドを join できる。"

#. type: Plain text
#: build/C/man3/pthread_join.3:132
msgid ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_create>(3), B<pthread_detach>(3), "
"B<pthread_exit>(3), B<pthread_tryjoin_np>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_kill.3:24
#, no-wrap
msgid "PTHREAD_KILL"
msgstr "PTHREAD_KILL"

#. type: TH
#: build/C/man3/pthread_kill.3:24
#, no-wrap
msgid "2009-01-28"
msgstr "2009-01-28"

#. type: Plain text
#: build/C/man3/pthread_kill.3:27
msgid "pthread_kill - send a signal to a thread"
msgstr "pthread_kill - スレッドにシグナルを送信する"

#. type: Plain text
#: build/C/man3/pthread_kill.3:30 build/C/man3/pthread_sigmask.3:30
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/pthread_kill.3:32
#, no-wrap
msgid "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"
msgstr "B<int pthread_kill(pthread_t >I<thread>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_kill.3:45
msgid ""
"The B<pthread_kill>()  function sends the signal I<sig> to I<thread>, "
"another thread in the same process as the caller.  The signal is "
"asynchronously directed to I<thread>."
msgstr ""
"B<pthread_kill>() 関数は、呼び出したスレッドと同じプロセスの\n"
"別のスレッド I<thread> にシグナル I<sig> を送信する。\n"
"シグナルは非同期に I<thread> へ直接送られる。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:50
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check for the existence of a thread ID."
msgstr ""
"I<sig> が 0 の場合、シグナルは送信されないが、\n"
"エラーチェックだけは実行される。\n"
"これを使うと、スレッド ID が存在するかの確認を行うことができる。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:55
msgid ""
"On success, B<pthread_kill>()  returns 0; on error, it returns an error "
"number, and no signal is sent."
msgstr ""
"成功すると、 B<pthread_kill>() は 0 を返す。\n"
"エラーの場合、エラー番号を返し、シグナルの送信は行わない。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:59
msgid "An invalid signal was specified."
msgstr "無効なシグナルが指定された。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:73
msgid ""
"Signal dispositions are process-wide: if a signal handler is installed, the "
"handler will be invoked in the thread I<thread>, but if the disposition of "
"the signal is \"stop\", \"continue\", or \"terminate\", this action will "
"affect the whole process."
msgstr ""
"シグナルの配送はプロセス全体で行われる。\n"
"シグナルハンドラが設定されている場合、\n"
"そのハンドラがスレッド I<thread> で起動されるが、\n"
"シグナルの配送が \"stop\", \"continue\", \"terminate\" のいずれかの場合、\n"
"シグナルに対するアクションはプロセス全体に影響がある。"

#. type: Plain text
#: build/C/man3/pthread_kill.3:82
msgid ""
"B<kill>(2)  B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<kill>(2)  B<sigaction>(2), B<sigpending>(2), B<pthread_self>(3), "
"B<pthread_sigmask>(3), B<raise>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/pthread_kill_other_threads_np.3:24
#, no-wrap
msgid "PTHREAD_KILL_OTHER_THREADS_NP"
msgstr "PTHREAD_KILL_OTHER_THREADS_NP"

#. type: TH
#: build/C/man3/pthread_kill_other_threads_np.3:24
#, no-wrap
msgid "2010-09-09"
msgstr "2010-09-09"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:27
msgid "pthread_kill_other_threads_np - terminate all other threads in process"
msgstr "pthread_kill_other_threads_np - プロセス内の他の全スレッドを終了する"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:32
#, no-wrap
msgid "B<void pthread_kill_other_threads_np(void);>\n"
msgstr "B<void pthread_kill_other_threads_np(void);>\n"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:45
msgid ""
"B<pthread_kill_other_threads_np>()  only has an effect in the LinuxThreads "
"threading implementation.  On that implementation, calling this function "
"causes the immediate termination of all threads in the application, except "
"the calling thread.  The cancellation state and cancellation type of the to-"
"be-terminated threads are ignored, and the cleanup handlers are not called "
"in those threads."
msgstr ""
"B<pthread_kill_other_threads_np>() は、\n"
"LinuxThreads スレッド実装においてのみ効果がある。\n"
"LinuxThreads スレッド実装では、この関数を呼び出すと\n"
"アプリケーション内の全てのスレッドがすぐに終了される。\n"
"終了対象のスレッドの cancellation state と cancellation type は\n"
"無視され、それらのスレッドのクリーンアップハンドラは呼び出されない。"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:57
msgid ""
"B<pthread_kill_other_threads_np>()  is intended to be called just before a "
"thread calls B<execve>(2)  or a similar function.  This function is designed "
"to address a limitation in the obsolete LinuxThreads implementation whereby "
"the other threads of an application are not automatically terminated (as "
"POSIX.1-2001 requires) during B<execve>(2)."
msgstr ""
"B<pthread_kill_other_threads_np>() は、\n"
"スレッドが B<execve>(2) や同様の関数を呼び出す直前に\n"
"呼ばれることを目的として用意されている。\n"
"この関数は、(廃止予定の) LinuxThreads スレッド実装における、\n"
"B<execve>(2) の際にアプリケーションの他のスレッドが自動的に\n"
"終了されないという制限を解決するために設計された。"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:64
msgid ""
"In the NPTL threading implementation, B<pthread_kill_other_threads_np>()  "
"exists, but does nothing.  (Nothing needs to be done, because the "
"implementation does the right thing during an B<execve>(2).)"
msgstr ""
"NPTL スレッド実装では、 B<pthread_kill_other_threads_np>() は存在するが、\n"
"何もしない(NPTL 実装は B<execve>(2) の際に適切な動作をするので、\n"
"何もする必要がないということだ)。"

#. type: Plain text
#: build/C/man3/pthread_kill_other_threads_np.3:70
msgid ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"
msgstr ""
"B<execve>(2), B<pthread_cancel>(3), B<pthread_setcancelstate>(3), "
"B<pthread_setcanceltype>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_self.3:24
#, no-wrap
msgid "PTHREAD_SELF"
msgstr "PTHREAD_SELF"

#. type: Plain text
#: build/C/man3/pthread_self.3:27
msgid "pthread_self - obtain ID of the calling thread"
msgstr "pthread_self - 呼び出したスレッドの ID を取得する"

#. type: Plain text
#: build/C/man3/pthread_self.3:32
#, no-wrap
msgid "B<pthread_t pthread_self(void);>\n"
msgstr "B<pthread_t pthread_self(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_self.3:44
msgid ""
"The B<pthread_self>()  function returns the ID of the calling thread.  This "
"is the same value that is returned in I<*thread> in the B<pthread_create>"
"(3)  call that created this thread."
msgstr ""
"B<pthread_self>() 関数は、呼び出したスレッドの ID を返す。\n"
"得られる ID は、このスレッドが作成された B<pthread_create>(3) の\n"
"呼び出しで I<*thread> で返されるのと同じ値である。"

#. type: Plain text
#: build/C/man3/pthread_self.3:46
msgid "This function always succeeds, returning the calling thread's ID."
msgstr "この関数は常に成功し、呼び出したスレッドの ID を返す。"

#. type: Plain text
#: build/C/man3/pthread_self.3:61
msgid ""
"POSIX.1 allows an implementation wide freedom in choosing the type used to "
"represent a thread ID; for example, representation using either an "
"arithmetic type or a structure is permitted.  Therefore, variables of type "
"I<pthread_t> can't portably be compared using the C equality operator "
"(B<==>); use B<pthread_equal>(3)  instead."
msgstr ""
"POSIX.1 では、スレッド ID を表現するのに使用する型は、\n"
"スレッド実装が完全に自由に選択してよいことになっている。\n"
"例えば、スレッド ID を表現するのに数値型を使っても構造体を使ってもよい。\n"
"そのため、移植性を確保しつつ、 C 言語の等価演算子 (B<==>) を使って、\n"
"I<pthread_t> 型の変数の比較を行うことはできない。\n"
"代わりに B<pthread_equal>(3) を使うこと。"

#. type: Plain text
#: build/C/man3/pthread_self.3:65
msgid ""
"Thread identifiers should be considered opaque: any attempt to use a thread "
"ID other than in pthreads calls is nonportable and can lead to unspecified "
"results."
msgstr ""
"スレッド識別子はその内部構造を意識すべきではない。\n"
"pthreads 関数以外でスレッド ID を利用しようとした場合、\n"
"移植性がなくなり、どのような結果が得られるかも分からない。"

#. type: Plain text
#: build/C/man3/pthread_self.3:69
msgid ""
"Thread IDs are only guaranteed to be unique within a process.  A thread ID "
"may be reused after a terminated thread has been joined, or a detached "
"thread has terminated."
msgstr ""
"スレッド ID の一意性が保証されるのは、あるプロセス内においてのみである。\n"
"終了したスレッドが join されたり、\n"
"切り離された (detached) スレッドが終了されたりした後は、\n"
"そのスレッド ID は再利用されることがある。"

#. type: Plain text
#: build/C/man3/pthread_self.3:74
msgid ""
"The thread ID returned by B<pthread_self>()  is not the same thing as the "
"kernel thread ID returned by a call to B<gettid>(2)."
msgstr ""
"B<pthread_self>() が返すスレッド ID は、\n"
"B<gettid>(2) が返すカーネルスレッド ID とは違うものである。"

#. type: Plain text
#: build/C/man3/pthread_self.3:78
msgid "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"
msgstr "B<pthread_create>(3), B<pthread_equal>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setaffinity_np.3:24
#, no-wrap
msgid "PTHREAD_SETAFFINITY_NP"
msgstr "PTHREAD_SETAFFINITY_NP"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:28
msgid ""
"pthread_setaffinity_np, pthread_getaffinity_np - set/get CPU affinity of a "
"thread"
msgstr ""
"pthread_setaffinity_np, pthread_getaffinity_np - スレッドの\n"
"CPU affinity の設定/取得を行う"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:37
#, no-wrap
msgid ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"
msgstr ""
"B<int pthread_setaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           const cpu_set_t *>I<cpuset>B<);>\n"
"B<int pthread_getaffinity_np(pthread_t >I<thread>B<, size_t >I<cpusetsize>B<,>\n"
"B<                           cpu_set_t *>I<cpuset>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:52
msgid ""
"The B<pthread_setaffinity_np>()  function sets the CPU affinity mask of the "
"thread I<thread> to the CPU set pointed to by I<cpuset>.  If the call is "
"successful, and the thread is not currently running on one of the CPUs in "
"I<cpuset>, then it is migrated to one of those CPUs."
msgstr ""
"B<pthread_setaffinity_np>() 関数は、スレッド I<thread> の CPU affinity\n"
"マスクに I<cpuset> が指す CPU 集合を設定する。呼び出しが成功し、\n"
"そのスレッドが現在 I<cpuset> で指定された CPU 上でが実行されていない\n"
"場合は、スレッドは指定された CPU のいずれかに移動される。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:59
msgid ""
"The B<pthread_getaffinity_np>()  function returns the CPU affinity mask of "
"the thread I<thread> in the buffer pointed to by I<cpuset>."
msgstr ""
"B<pthread_getaffinity_np>() 関数は、スレッド I<thread> の CPU affinity\n"
"マスクを、I<cpuset> が指すバッファに入れて返す。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:75
msgid ""
"The argument I<cpusetsize> is the length (in bytes) of the buffer pointed to "
"by I<cpuset>.  Typically, this argument would be specified as I<sizeof"
"(cpu_set_t)>.  (It may be some other value, if using the macros described in "
"B<CPU_SET>(3)  for dynamically allocating a CPU set.)"
msgstr ""
"引き数 I<cpusetsize> は I<cpuset> が指すバッファの長さ (バイト単位) で\n"
"ある。通常は、この引き数には I<sizeof(cpu_set_t)> を指定する\n"
"(B<CPU_SET>(3) に書かれているマクロを使って CPU 集合を動的に\n"
"割り当てている場合には、別の値になることもある)。"

#. type: TP
#: build/C/man3/pthread_setaffinity_np.3:79
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:82
msgid "A supplied memory address was invalid."
msgstr "指定されたメモリアドレスが無効である。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:91
msgid ""
"(B<pthread_setaffinity_np>())  The affinity bit mask I<mask> contains no "
"processors that are currently physically on the system and permitted to the "
"thread according to any restrictions that may be imposed by the \"cpuset\" "
"mechanism described in B<cpuset>(7)."
msgstr ""
"(B<pthread_setaffinity_np>()) affinity ビットマスク I<mask> に、\n"
"その時点でシステム上に物理的に存在して、かつそのスレッドに対して許可\n"
"されているプロセッサが一つも含まれていない。\n"
"スレッドに対してどのプロセッサの利用が許可されるかは、B<cpuset>(7) で\n"
"説明されている \"cpuset\" 機構に適用される制限に基づいて決まる。"

#.  FIXME . ?
#.  Loic Domaigne commented: it seems that in the future the
#.  kernel developers want to make cpumask_t dynamic, so
#.  CONFIG_NR_CPUS might become obsolete in the future.
#.  cpumask_t
#.  The raw sched_getaffinity() system call returns the size (in bytes)
#.  of the cpumask_t type.
#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:107
msgid ""
"(B<pthread_setaffinity_np>())  I<cpuset> specified a CPU that was outside "
"the set supported by the kernel.  (The kernel configuration option "
"B<CONFIG_NR_CPUS> defines the range of the set supported by the kernel data "
"type used to represent CPU sets.)"
msgstr ""
"(B<pthread_setaffinity_np>()) I<cpuset> が、カーネルがサポートする CPU\n"
"集合に含まれない CPU を指定していた。(カーネルの設定オプション\n"
"B<CONFIG_NR_CPUS> により、CPU 集合を表現するのに使われるカーネルの\n"
"データ型がサポートする CPU 集合の範囲が定義される。)"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:112
msgid ""
"(B<pthread_getaffinity_np>())  I<cpusetsize> is smaller than the size of the "
"affinity mask used by the kernel."
msgstr ""
"(B<pthread_getaffinity_np>()) I<cpusetsize> がカーネルが使用する\n"
"affinity マスクの大きさよりも小さい。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:135
msgid ""
"After a call to B<pthread_setaffinity_np>(), the set of CPUs on which the "
"thread will actually run is the intersection of the set specified in the "
"I<cpuset> argument and the set of CPUs actually present on the system.  The "
"system may further restrict the set of CPUs on which the thread runs if the "
"\"cpuset\" mechanism described in B<cpuset>(7)  is being used.  These "
"restrictions on the actual set of CPUs on which the thread will run are "
"silently imposed by the kernel."
msgstr ""
"B<pthread_setaffinity_np>() を呼び出した後、\n"
"そのスレッドが実際に実行される CPU 集合は、\n"
"I<cpuset> 引き数で指定された集合と\n"
"システムに実際に存在する CPU 集合の共通部分になる。\n"
"また、 B<cpuset>(7) で説明されている \"cpuset\" 機構が使われている場合\n"
"には、そのスレッドが実行される CPU 集合がシステムによってさらに制限\n"
"される場合がある。そのスレッドが実行される実際の CPU 集合に対する\n"
"これらの制限は、カーネルにより黙って適用される。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:141
msgid ""
"These functions are implemented on top of the B<sched_setaffinity>(2)  and "
"B<sched_getaffinity>(2)  system calls."
msgstr ""
"これらの関数は、システムコール B<sched_setaffinity>(2) と\n"
"B<sched_getaffinity>(2) を使って実装されている。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:152
msgid ""
"A new thread created by B<pthread_create>(3)  inherits a copy of its "
"creator's CPU affinity mask."
msgstr ""
"B<pthread_create>(3) で作成される新しいスレッドは、\n"
"作成者の CPU affinity マスクを継承する。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:160
msgid ""
"In the following program, the main thread uses B<pthread_setaffinity_np>()  "
"to set its CPU affinity mask to include CPUs 0 to 7 (which may not all be "
"available on the system), and then calls B<pthread_getaffinity_np>()  to "
"check the resulting CPU affinity mask of the thread."
msgstr ""
"以下のプログラムでは、メインスレッドは\n"
"B<pthread_setaffinity_np>() を使って自分の CPU affinity マスクに\n"
"CPU 0 から 7 が含まれるように設定し\n"
"(システム上には 0 から 7 に対応する CPU が全て存在するとは限らない)、\n"
"その後で B<pthread_getaffinity_np>() を使って\n"
"スレッドに実際に設定された CPU affinity マスクを確認している。"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:167
#, no-wrap
msgid ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#define _GNU_SOURCE\n"
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:177
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, j;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, j;\n"
"    cpu_set_t cpuset;\n"
"    pthread_t thread;\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:179
#, no-wrap
msgid "    thread = pthread_self();\n"
msgstr "    thread = pthread_self();\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:181
#, no-wrap
msgid "    /* Set affinity mask to include CPUs 0 to 7 */\n"
msgstr "    /* Set affinity mask to include CPUs 0 to 7 */\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:185
#, no-wrap
msgid ""
"    CPU_ZERO(&cpuset);\n"
"    for (j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"
msgstr ""
"    CPU_ZERO(&cpuset);\n"
"    for (j = 0; j E<lt> 8; j++)\n"
"        CPU_SET(j, &cpuset);\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:189
#, no-wrap
msgid ""
"    s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"
msgstr ""
"    s = pthread_setaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_setaffinity_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:191
#, no-wrap
msgid "    /* Check the actual affinity mask assigned to the thread */\n"
msgstr "    /* Check the actual affinity mask assigned to the thread */\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:195
#, no-wrap
msgid ""
"    s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"
msgstr ""
"    s = pthread_getaffinity_np(thread, sizeof(cpu_set_t), &cpuset);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getaffinity_np\");\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:200
#, no-wrap
msgid ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"
msgstr ""
"    printf(\"Set returned by pthread_getaffinity_np() contained:\\en\");\n"
"    for (j = 0; j E<lt> CPU_SETSIZE; j++)\n"
"        if (CPU_ISSET(j, &cpuset))\n"
"            printf(\"    CPU %d\\en\", j);\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:203
#: build/C/man3/pthread_setschedparam.3:428
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setaffinity_np.3:212
msgid ""
"B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<pthread_attr_setaffinity_np>(3), B<pthread_self>(3), B<sched_getcpu>(3), "
"B<cpuset>(7), B<pthreads>(7)"
msgstr ""
"B<sched_setaffinity>(2), B<sched_setscheduler>(2), "
"B<pthread_attr_setaffinity_np>(3), B<pthread_self>(3), B<sched_getcpu>(3), "
"B<cpuset>(7), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setcancelstate.3:24
#, no-wrap
msgid "PTHREAD_SETCANCELSTATE"
msgstr "PTHREAD_SETCANCELSTATE"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:28
msgid ""
"pthread_setcancelstate, pthread_setcanceltype - set cancelability state and "
"type"
msgstr ""
"pthread_setcancelstate, pthread_setcanceltype - cancelability state と\n"
"type を設定する"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:34
#, no-wrap
msgid ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"
msgstr ""
"B<int pthread_setcancelstate(int >I<state>B<, int *>I<oldstate>B<);>\n"
"B<int pthread_setcanceltype(int >I<type>B<, int *>I<oldtype>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:49
msgid ""
"The B<pthread_setcancelstate>()  sets the cancelability state of the calling "
"thread to the value given in I<state>.  The previous cancelability state of "
"the thread is returned in the buffer pointed to by I<oldstate>.  The "
"I<state> argument must have one of the following values:"
msgstr ""
"B<pthread_setcancelstate>() は、呼び出したスレッドの\n"
"cancelability state に I<state> で指定された値を設定する。\n"
"変更前のスレッドの cancelability state は\n"
"I<oldstate> が指すバッファで返される。\n"
"I<state> 引き数には以下の値のいずれか一つを指定しなければならない。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:49
#, no-wrap
msgid "B<PTHREAD_CANCEL_ENABLE>"
msgstr "B<PTHREAD_CANCEL_ENABLE>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:56
msgid ""
"The thread is cancelable.  This is the default cancelability state in all "
"new threads, including the initial thread.  The thread's cancelability type "
"determines when a cancelable thread will respond to a cancellation request."
msgstr ""
"スレッドは取り消し可能 (cancelable) である。\n"
"これが全ての新しく作成されるスレッドでのデフォルトの cancelability\n"
"state である。これには最初のスレッドも含まれる。\n"
"スレッドの cancelability type により、取り消し可能なスレッドが\n"
"取り消し要求にいつ反応するかが決まる。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:56
#, no-wrap
msgid "B<PTHREAD_CANCEL_DISABLE>"
msgstr "B<PTHREAD_CANCEL_DISABLE>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:61
msgid ""
"The thread is not cancelable.  If a cancellation request is received, it is "
"blocked until cancelability is enabled."
msgstr ""
"スレッドは取り消しできない。取り消し要求を受信した際は、\n"
"取り消し可能に設定されるまでその要求はブロックされる。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:73
msgid ""
"The B<pthread_setcanceltype>()  sets the cancelability type of the calling "
"thread to the value given in I<type>.  The previous cancelability type of "
"the thread is returned in the buffer pointed to by I<oldtype>.  The I<type> "
"argument must have one of the following values:"
msgstr ""
"B<pthread_setcanceltype>() は、呼び出したスレッドの\n"
"cancelability type に I<type> で指定された値を設定する。\n"
"変更前のスレッドの cancelability type は\n"
"I<oldtype> が指すバッファで返される。\n"
"I<type> 引き数には以下の値のいずれか一つを指定しなければならない。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:73
#, no-wrap
msgid "B<PTHREAD_CANCEL_DEFERRED>"
msgstr "B<PTHREAD_CANCEL_DEFERRED>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:80
msgid ""
"A cancellation request is deferred until the thread next calls a function "
"that is a cancellation point (see B<pthreads>(7)).  This is the default "
"cancelability type in all new threads, including the initial thread."
msgstr ""
"そのスレッドが次に取り消しポイント (cancellation point) の関数を\n"
"呼び出すまで取り消し要求が遅延される。これが全ての新しく作成される\n"
"スレッドでのデフォルトの cancellation type である。\n"
"これには最初のスレッドも含まれる。"

#. type: TP
#: build/C/man3/pthread_setcancelstate.3:80
#, no-wrap
msgid "B<PTHREAD_CANCEL_ASYNCHRONOUS>"
msgstr "B<PTHREAD_CANCEL_ASYNCHRONOUS>"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:86
msgid ""
"The thread can be canceled at any time.  (Typically, it will be canceled "
"immediately upon receiving a cancellation request, but the system doesn't "
"guarantee this.)"
msgstr ""
"スレッドはいつでも取り消すことができる (通常はすぐにキャンセルされるが、\n"
"システムがそのことを保証しているわけではない)。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:90
msgid ""
"The set-and-get operation performed by each of these functions is atomic "
"with respect to other threads in the process calling the same function."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:97
msgid "The B<pthread_setcancelstate>()  can fail with the following error:"
msgstr "B<pthread_setcancelstate>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:101
msgid "Invalid value for I<state>."
msgstr "I<state> に無効な値が指定された。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:105
msgid "The B<pthread_setcanceltype>()  can fail with the following error:"
msgstr "B<pthread_setcanceltype>() は以下のエラーで失敗する場合がある。"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:111
msgid "Invalid value for I<type>."
msgstr "I<type> に無効な値が指定された。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:116
msgid ""
"For details of what happens when a thread is canceled, see B<pthread_cancel>"
"(3)."
msgstr ""
"スレッドが取り消された場合に何が起こるかの詳細については\n"
"B<pthread_cancel>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:123
msgid ""
"Briefly disabling cancelability is useful if a thread performs some critical "
"action that must not be interrupted by a cancellation request.  Beware of "
"disabling cancelability for long periods, or around operations that may "
"block for long periods, since that will render the thread unresponsive to "
"cancellation requests."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:154
msgid ""
"Setting the cancelability type to B<PTHREAD_CANCEL_ASYNCHRONOUS> is rarely "
"useful.  Since the thread could be canceled at I<any> time, it cannot safely "
"reserve resources (e.g., allocating memory with B<malloc>(3)), acquire "
"mutexes, semaphores, or locks, and so on.  Reserving resources is unsafe "
"because the application has no way of knowing what the state of these "
"resources is when the thread is canceled; that is, did cancellation occur "
"before the resources were reserved, while they were reserved, or after they "
"were released? Furthermore, some internal data structures (e.g., the linked "
"list of free blocks managed by the B<malloc>(3)  family of functions) may be "
"left in an inconsistent state if cancellation occurs in the middle of the "
"function call.  Consequently, clean-up handlers cease to be useful.  "
"Functions that can be safely asynchronously canceled are called I<async-"
"cancel-safe functions>.  POSIX.1-2001 only requires that B<pthread_cancel>"
"(3), B<pthread_setcancelstate>(), and B<pthread_setcanceltype>()  be async-"
"cancel-safe.  In general, other library functions can't be safely called "
"from an asynchronously cancelable thread.  One of the few circumstances in "
"which asynchronous cancelability is useful is for cancellation of a thread "
"that is in a pure compute-bound loop."
msgstr ""

#.  It looks like at least Solaris, FreeBSD and Tru64 support this.
#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:172
msgid ""
"The Linux threading implementations permit the I<oldstate> argument of "
"B<pthread_setcancelstate>()  to be NULL, in which case the information about "
"the previous cancelability state is not returned to the caller.  Many other "
"implementations also permit a NULL I<oldstat> argument, but POSIX.1-2001 "
"does not specify this point, so portable applications should always specify "
"a non-NULL value in I<oldstate>.  A precisely analogous set of statements "
"applies for the I<oldtype> argument of B<pthread_setcanceltype>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:175
msgid "See B<pthread_cancel>(3)."
msgstr "B<pthread_cancel>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setcancelstate.3:180
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_testcancel>(3), "
"B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setconcurrency.3:23
#, no-wrap
msgid "PTHREAD_SETCONCURRENCY"
msgstr "PTHREAD_SETCONCURRENCY"

#. type: TH
#: build/C/man3/pthread_setconcurrency.3:23 build/C/man3/pthread_yield.3:23
#, no-wrap
msgid "2009-04-10"
msgstr "2009-04-10"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:27
msgid ""
"pthread_setconcurrency, pthread_getconcurrency - set/get the concurrency "
"level"
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:33
#, no-wrap
msgid ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(void);>\n"
msgstr ""
"B<int pthread_setconcurrency(int >I<new_level>B<);>\n"
"B<int pthread_getconcurrency(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:46
msgid ""
"The B<pthread_setconcurrency>()  function informs the implementation of the "
"application's desired concurrency level, specified in I<new_level>.  The "
"implementation only takes this as a hint: POSIX.1 does not specify the level "
"of concurrency that should be provided as a result of calling "
"B<pthread_setconcurrency>()."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:51
msgid ""
"Specifying I<new_level> as 0 instructs the implementation to manage the "
"concurrency level as it deems appropriate."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:54
msgid ""
"B<pthread_getconcurrency>()  returns the current value of the concurrency "
"level for this process."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:59
msgid ""
"On success, B<pthread_setconcurrency>()  returns 0; on error, it returns a "
"nonzero error number."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:66
msgid ""
"B<pthread_getconcurrency>()  always succeeds, returning the concurrency "
"level set by a previous call to B<pthread_setconcurrency>(), or 0, if "
"B<pthread_setconcurrency>()  has not previously been called."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:69
msgid "B<pthread_setconcurrency>()  can fail with the following error:"
msgstr "B<pthread_setconcurrency>() は以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:73
msgid "I<new_level> is negative."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:79
msgid ""
"POSIX.1-2001 also documents an B<EAGAIN> error (\"the value specified by "
"I<new_level> would cause a system resource to be exceeded\")."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:81
msgid "These functions are available in glibc since version 2.1."
msgstr "これらの関数は glibc バージョン 2.1 以降で利用できる。"

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:85
msgid "The default concurrency level is 0."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:92
msgid ""
"Concurrency levels are only meaningful for M:N threading implementations, "
"where at any moment a subset of a process's set of user-level threads may be "
"bound to a smaller number of kernel-scheduling entities.  Setting the "
"concurrency level allows the application to give the system a hint as to the "
"number of kernel-scheduling entities that should be provided for efficient "
"execution of the application."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:98
msgid ""
"Both LinuxThreads and NPTL are 1:1 threading implementations, so setting the "
"concurrency level has no meaning.  In other words, on Linux these functions "
"merely exist for compatibility with other systems, and they have no effect "
"on the execution of a program."
msgstr ""

#. type: Plain text
#: build/C/man3/pthread_setconcurrency.3:101
msgid "B<pthread_attr_setscope>(3), B<pthreads>(7)"
msgstr "B<pthread_attr_setscope>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setschedparam.3:24
#, no-wrap
msgid "PTHREAD_SETSCHEDPARAM"
msgstr "PTHREAD_SETSCHEDPARAM"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:28
msgid ""
"pthread_setschedparam, pthread_getschedparam - set/get scheduling policy and "
"parameters of a thread"
msgstr ""
"pthread_setschedparam, pthread_getschedparam - スレッドの\n"
"スケジューリングポリシーとパラメータを設定/取得する"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:36
#, no-wrap
msgid ""
"B<pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                      const struct sched_param *>I<param>B<);>\n"
"B<pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                      struct sched_param *>I<param>B<);>\n"
msgstr ""
"B<pthread_setschedparam(pthread_t >I<thread>B<, int >I<policy>B<,>\n"
"B<                      const struct sched_param *>I<param>B<);>\n"
"B<pthread_getschedparam(pthread_t >I<thread>B<, int *>I<policy>B<,>\n"
"B<                      struct sched_param *>I<param>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:44
msgid ""
"The B<pthread_setschedparam>()  function sets the scheduling policy and "
"parameters of the thread I<thread>."
msgstr ""
"B<pthread_setschedparam>() 関数は、スレッド I<thread> の\n"
"スケジューリングポリシーとスケジューリングパラメータを設定する。"

#.  FIXME . pthread_setschedparam() places no restriction on the policy,
#.  but pthread_attr_setschedpolicy() restricts policy to RR/FIFO/OTHER
#.  http://sourceware.org/bugzilla/show_bug.cgi?id=7013
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:55
msgid ""
"I<policy> specifies the new scheduling policy for I<thread>.  The supported "
"values for I<policy>, and their semantics, are described in "
"B<sched_setscheduler>(2)."
msgstr ""
"I<policy> は I<thread> の新しいスケジューリングポリシーを指定する。\n"
"I<policy> に指定できる値とその意味は B<sched_setscheduler>(2) で\n"
"説明されている。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:61
msgid ""
"The structure pointed to by I<param> specifies the new scheduling parameters "
"for I<thread>.  Scheduling parameters are maintained in the following "
"structure:"
msgstr ""
"I<param> が指す構造体は I<thread> の新しいスケジューリングパラメータを\n"
"指定する。スケジューリングパラメータは以下の構造体で管理される。"

#.  FIXME . nptl/pthread_setschedparam.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:102
msgid ""
"The B<pthread_getschedparam>()  function returns the scheduling policy and "
"parameters of the thread I<thread>, in the buffers pointed to by I<policy> "
"and I<param>, respectively.  The returned priority value is that set by the "
"most recent B<pthread_setschedparam>(), B<pthread_setschedprio>(3), or "
"B<pthread_create>(3)  call that affected I<thread>.  The returned priority "
"does not reflect any temporary priority adjustments as a result of calls to "
"any priority inheritance or priority ceiling functions (see, for example, "
"B<pthread_mutexattr_setprioceiling>(3)  and B<pthread_mutexattr_setprotocol>"
"(3))."
msgstr ""
"B<pthread_getschedparam>() 関数は、スレッド I<thread> の\n"
"スケジューリングポリシーとパラメータを、\n"
"それぞれ I<policy> と I<param> が指すバッファに入れて返す。\n"
"返された優先度の値は、最も最近実行した I<thread> に影響を与える\n"
"B<pthread_setschedparam>(), B<pthread_setschedprio>,\n"
"B<pthread_create> で設定された値となる。\n"
"返された優先度は、優先度の継承や優先度の上限を設定する関数\n"
"(例えば B<pthread_mutexattr_setprioceiling>(3) や\n"
"B<pthread_mutexattr_setprotocol>(3) を参照) の呼び出しの結果\n"
"行われる一時的な優先度の調整の影響を受けない。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:110
msgid ""
"On success, these functions return 0; on error, they return a nonzero error "
"number.  If B<pthread_setschedparam>()  fails, the scheduling policy and "
"parameters of I<thread> are not changed."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。\n"
"B<pthread_setschedparam>() が失敗した場合、 I<thread> の\n"
"スケジューリングポリシーとパラメータは変更されない。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:112
msgid "Both of these functions can fail with the following error:"
msgstr "これらの関数はどちらも以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:120
msgid ""
"B<pthread_setschedparam>()  may additionally fail with the following errors:"
msgstr "B<pthread_setschedparam>() はさらに以下のエラーで失敗する場合がある。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:127
msgid ""
"I<policy> is not a recognized policy, or I<param> does not make sense for "
"the I<policy>."
msgstr ""
"I<policy> が認識できないポリシーであるか、\n"
"I<param> が I<policy> では意味を持たない値である。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:131
msgid ""
"The caller does not have appropriate privileges to set the specified "
"scheduling policy and parameters."
msgstr ""
"呼び出し側が、指定されたスケジューリングポリシーやパラメータを設定する\n"
"のに必要な特権を持たない。"

#.  .SH VERSIONS
#.  Available since glibc 2.0
#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:139
msgid ""
"POSIX.1-2001 also documents an B<ENOTSUP> (\"attempt was made to set the "
"policy or scheduling parameters to an unsupported value\") error for "
"B<pthread_setschedparam>()."
msgstr ""
"POSIX.1-2001 では、 B<pthread_setschedparam>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値をスケジューリングポリシーや\n"
"パラメータに設定しようとした\") も追加で規定されている。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:147
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling policy and priority, and details of the "
"permitted ranges for priorities in each scheduling policy, see "
"B<sched_setscheduler>(2)."
msgstr ""
"スレッドのスケジューリングポリシーや優先度を変更するために必要な許可や\n"
"変更した場合の影響、および各スケジューリングポリシーで認められる優先度\n"
"の範囲の詳細については、 B<sched_setscheduler>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:154
msgid ""
"The program below demonstrates the use of B<pthread_setschedparam>()  and "
"B<pthread_getschedparam>(), as well as the use of a number of other "
"scheduling-related pthreads functions."
msgstr ""
"以下のプログラムは B<pthread_setschedparam>() と\n"
"B<pthread_getschedparam>() やスケジューリングに関連する pthreads の\n"
"他のいろいろな関数の使用例を示すものである。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:170
msgid ""
"In the following run, the main thread sets its scheduling policy to "
"B<SCHED_FIFO> with a priority of 10, and initializes a thread attributes "
"object with a scheduling policy attribute of B<SCHED_RR> and a scheduling "
"priority attribute of 20.  The program then sets (using "
"B<pthread_attr_setinheritsched>(3))  the inherit scheduler attribute of the "
"thread attributes object to B<PTHREAD_EXPLICIT_SCHED>, meaning that threads "
"created using this attributes object should take their scheduling attributes "
"from the thread attributes object.  The program then creates a thread using "
"the thread attributes object, and that thread displays its scheduling policy "
"and priority."
msgstr ""
"以下の実行例では、メインスレッドは、自分のスケジューリングポリシーを\n"
"優先度 10 の B<SCHED_FIFO> を設定し、スレッド属性オブジェクトを\n"
"スケジューリングポリシー属性 B<SCHED_RR> とスケジューリング優先度\n"
"属性 20 で初期化する。\n"
"次に、このプログラムは (B<pthread_attr_setinheritsched>(3) を使って) \n"
"そのスレッド属性オブジェクトの inherit scheduler 属性に\n"
"B<PTHREAD_EXPLICIT_SCHED> を設定する。B<PTHREAD_EXPLICIT_SCHED> は、\n"
"そのスレッド属性オブジェクトを使って作成されたスレッドはスレッド属性\n"
"オブジェクトからスケジューリング属性を取得して使うことを意味する。\n"
"それから、このスレッド属性オブジェクトを使ってスレッドを作成し、\n"
"作成したスレッドのスケジューリングポリシーと優先度を表示する。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:178
#, no-wrap
msgid ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"$ B<su>      # Need privilege to set real-time scheduling policies\n"
"Password:\n"
"# B<./a.out -mf10 -ar20 -i e>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:182
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"
msgstr ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is EXPLICIT\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:185
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"
msgstr ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_RR, priority=20\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:190
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the values specified in the thread attributes object."
msgstr ""
"上記の出力では、スケジューリングポリシーと優先度がスレッド属性\n"
"オブジェクトで指定された値から取られていることが分かる。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:197
msgid ""
"The next run is the same as the previous, except that the inherit scheduler "
"attribute is set to B<PTHREAD_INHERIT_SCHED>, meaning that threads created "
"using the thread attributes object should ignore the scheduling attributes "
"specified in the attributes object and instead take their scheduling "
"attributes from the creating thread."
msgstr ""
"次の実行例は前のものと同じだが、 inherit scheduler 属性が \n"
"B<PTHREAD_INHERIT_SCHED> に設定される点が異なる。\n"
"B<PTHREAD_INHERIT_SCHED> は、そのスレッド属性オブジェクトを使って作成\n"
"されたスレッドは、スレッド属性オブジェクトからスケジューリング属性を\n"
"無視し、代わりに呼び出したスレッドからスケジューリング属性を取得する\n"
"ことを意味する。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:203
#, no-wrap
msgid ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"# B<./a.out -mf10 -ar20 -i i>\n"
"Scheduler settings of main thread\n"
"    policy=SCHED_FIFO, priority=10\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:207
#, no-wrap
msgid ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"
msgstr ""
"Scheduler settings in \\(aqattr\\(aq\n"
"    policy=SCHED_RR, priority=20\n"
"    inheritsched is INHERIT\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:210
#, no-wrap
msgid ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"
msgstr ""
"Scheduler attributes of new thread\n"
"    policy=SCHED_FIFO, priority=10\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:216
msgid ""
"In the above output, one can see that the scheduling policy and priority "
"were taken from the creating thread, rather than the thread attributes "
"object."
msgstr ""
"上記の出力では、スケジューリングポリシーと優先度が、\n"
"スレッド属性オブジェクトからではなく、\n"
"スレッドを作成したスレッドから取れれていることが分かる。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:222
msgid ""
"Note that if we had omitted the I<-i\\ i> option, the output would have been "
"the same, since B<PTHREAD_INHERIT_SCHED> is the default for the inherit "
"scheduler attribute."
msgstr ""
"なお、 I<-i\\ i> を省略した場合でも、\n"
"B<PTHREAD_INHERIT_SCHED> が inherit scheduler 属性のデフォルト値なので、\n"
"出力は同じになる。"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:226
#, no-wrap
msgid "/* pthreads_sched_test.c */\n"
msgstr "/* pthreads_sched_test.c */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:232
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:241
#, no-wrap
msgid ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"
msgstr ""
"static void\n"
"usage(char *prog_name, char *msg)\n"
"{\n"
"    if (msg != NULL)\n"
"        fputs(msg, stderr);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:258
#, no-wrap
msgid ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|s}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"
msgstr ""
"    fprintf(stderr, \"Usage: %s [options]\\en\", prog_name);\n"
"    fprintf(stderr, \"Options are:\\en\");\n"
"#define fpe(msg) fprintf(stderr, \"\\et%s\", msg);          /* Shorter */\n"
"    fpe(\"-aE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority in\\en\");\n"
"    fpe(\"                 thread attributes object\\en\");\n"
"    fpe(\"                 E<lt>policyE<gt> can be\\en\");\n"
"    fpe(\"                     f  SCHED_FIFO\\en\");\n"
"    fpe(\"                     r  SCHED_RR\\en\");\n"
"    fpe(\"                     o  SCHED_OTHER\\en\");\n"
"    fpe(\"-A               Use default thread attributes object\\en\");\n"
"    fpe(\"-i {e|s}         Set inherit scheduler attribute to\\en\");\n"
"    fpe(\"                 \\(aqexplicit\\(aq or \\(aqinherit\\(aq\\en\");\n"
"    fpe(\"-mE<lt>policyE<gt>E<lt>prioE<gt> Set scheduling policy and priority on\\en\");\n"
"    fpe(\"                 main thread before pthread_create() call\\en\");\n"
"    exit(EXIT_FAILURE);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:269
#, no-wrap
msgid ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"
msgstr ""
"static int\n"
"get_policy(char p, int *policy)\n"
"{\n"
"    switch (p) {\n"
"    case \\(aqf\\(aq: *policy = SCHED_FIFO;     return 1;\n"
"    case \\(aqr\\(aq: *policy = SCHED_RR;       return 1;\n"
"    case \\(aqo\\(aq: *policy = SCHED_OTHER;    return 1;\n"
"    default:  return 0;\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:280
#, no-wrap
msgid ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"
msgstr ""
"static void\n"
"display_sched_attr(int policy, struct sched_param *param)\n"
"{\n"
"    printf(\"    policy=%s, priority=%d\\en\",\n"
"            (policy == SCHED_FIFO)  ? \"SCHED_FIFO\" :\n"
"            (policy == SCHED_RR)    ? \"SCHED_RR\" :\n"
"            (policy == SCHED_OTHER) ? \"SCHED_OTHER\" :\n"
"            \"???\",\n"
"            param-E<gt>sched_priority);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:286
#, no-wrap
msgid ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"
msgstr ""
"static void\n"
"display_thread_sched_attr(char *msg)\n"
"{\n"
"    int policy, s;\n"
"    struct sched_param param;\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:290
#, no-wrap
msgid ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"
msgstr ""
"    s = pthread_getschedparam(pthread_self(), &policy, &param);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_getschedparam\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:294
#, no-wrap
msgid ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"
msgstr ""
"    printf(\"%s\\en\", msg);\n"
"    display_sched_attr(policy, &param);\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:299
#, no-wrap
msgid ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"
msgstr ""
"static void *\n"
"thread_start(void *arg)\n"
"{\n"
"    display_thread_sched_attr(\"Scheduler attributes of new thread\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:302
#, no-wrap
msgid ""
"    return NULL;\n"
"}\n"
msgstr ""
"    return NULL;\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:312
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int s, opt, inheritsched, use_null_attrib, policy;\n"
"    pthread_t thread;\n"
"    pthread_attr_t attr;\n"
"    pthread_attr_t *attrp;\n"
"    char *attr_sched_str, *main_sched_str, *inheritsched_str;\n"
"    struct sched_param param;\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:314
#, no-wrap
msgid "    /* Process command-line options */\n"
msgstr "    /* Process command-line options */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:319
#, no-wrap
msgid ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"
msgstr ""
"    use_null_attrib = 0;\n"
"    attr_sched_str = NULL;\n"
"    main_sched_str = NULL;\n"
"    inheritsched_str = NULL;\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:329
#, no-wrap
msgid ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"
msgstr ""
"    while ((opt = getopt(argc, argv, \"a:Ai:m:\")) != -1) {\n"
"        switch (opt) {\n"
"        case \\(aqa\\(aq: attr_sched_str = optarg;      break;\n"
"        case \\(aqA\\(aq: use_null_attrib = 1;          break;\n"
"        case \\(aqi\\(aq: inheritsched_str = optarg;    break;\n"
"        case \\(aqm\\(aq: main_sched_str = optarg;      break;\n"
"        default:  usage(argv[0], \"Unrecognized option\\en\");\n"
"        }\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:333
#, no-wrap
msgid ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"
msgstr ""
"    if (use_null_attrib &&\n"
"            (inheritsched_str != NULL || attr_sched_str != NULL))\n"
"        usage(argv[0], \"Can\\(aqt specify -A with -i or -a\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:336
#, no-wrap
msgid ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"
msgstr ""
"    /* Optionally set scheduling attributes of main thread,\n"
"       and display the attributes */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:341
#, no-wrap
msgid ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-s)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"
msgstr ""
"    if (main_sched_str != NULL) {\n"
"        if (!get_policy(main_sched_str[0], &policy))\n"
"            usage(argv[0], \"Bad policy for main thread (-s)\\en\");\n"
"        param.sched_priority = strtol(&main_sched_str[1], NULL, 0);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:346
#, no-wrap
msgid ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"
msgstr ""
"        s = pthread_setschedparam(pthread_self(), policy, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_setschedparam\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:349
#, no-wrap
msgid ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"
msgstr ""
"    display_thread_sched_attr(\"Scheduler settings of main thread\");\n"
"    printf(\"\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:351
#, no-wrap
msgid "    /* Initialize thread attributes object according to options */\n"
msgstr "    /* Initialize thread attributes object according to options */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:360
#, no-wrap
msgid ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"
msgstr ""
"    if (!use_null_attrib) {\n"
"        s = pthread_attr_init(&attr);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_init\");\n"
"        attrp = &attr;\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:368
#, no-wrap
msgid ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or \\(aqi\\(aq\\en\");\n"
msgstr ""
"    if (inheritsched_str != NULL) {\n"
"        if (inheritsched_str[0] == \\(aqe\\(aq)\n"
"            inheritsched = PTHREAD_EXPLICIT_SCHED;\n"
"        else if (inheritsched_str[0] == \\(aqi\\(aq)\n"
"            inheritsched = PTHREAD_INHERIT_SCHED;\n"
"        else\n"
"            usage(argv[0], \"Value for -i must be \\(aqe\\(aq or \\(aqi\\(aq\\en\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:373
#, no-wrap
msgid ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setinheritsched(&attr, inheritsched);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setinheritsched\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:379
#, no-wrap
msgid ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"
msgstr ""
"    if (attr_sched_str != NULL) {\n"
"        if (!get_policy(attr_sched_str[0], &policy))\n"
"            usage(argv[0],\n"
"                    \"Bad policy for \\(aqattr\\(aq (-a)\\en\");\n"
"        param.sched_priority = strtol(&attr_sched_str[1], NULL, 0);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:387
#, no-wrap
msgid ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_setschedpolicy(&attr, policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedpolicy\");\n"
"        s = pthread_attr_setschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_setschedparam\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:390
#, no-wrap
msgid ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"
msgstr ""
"    /* If we initialized a thread attributes object, display\n"
"       the scheduling attributes that were set in the object */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:398
#, no-wrap
msgid ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"
msgstr ""
"    if (attrp != NULL) {\n"
"        s = pthread_attr_getschedparam(&attr, &param);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedparam\");\n"
"        s = pthread_attr_getschedpolicy(&attr, &policy);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"pthread_attr_getschedpolicy\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:401
#, no-wrap
msgid ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"
msgstr ""
"        printf(\"Scheduler settings in \\(aqattr\\(aq\\en\");\n"
"        display_sched_attr(policy, &param);\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:409
#, no-wrap
msgid ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"
msgstr ""
"        s = pthread_attr_getinheritsched(&attr, &inheritsched);\n"
"        printf(\"    inheritsched is %s\\en\",\n"
"                (inheritsched == PTHREAD_INHERIT_SCHED)  ? \"INHERIT\" :\n"
"                (inheritsched == PTHREAD_EXPLICIT_SCHED) ? \"EXPLICIT\" :\n"
"                \"???\");\n"
"        printf(\"\\en\");\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:411
#, no-wrap
msgid "    /* Create a thread that will display its scheduling attributes */\n"
msgstr "    /* Create a thread that will display its scheduling attributes */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:415
#, no-wrap
msgid ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, attrp, &thread_start, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:417
#, no-wrap
msgid "    /* Destroy unneeded thread attributes object */\n"
msgstr "    /* Destroy unneeded thread attributes object */\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:425
#, no-wrap
msgid ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"
msgstr ""
"    s = pthread_join(thread, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_join\");\n"

#. type: Plain text
#: build/C/man3/pthread_setschedparam.3:441
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<sched_setscheduler>(2), "
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_self>(3), B<pthread_setschedprio>(3), "
"B<pthreads>(7)"
msgstr ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<sched_setscheduler>(2), "
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_self>(3), B<pthread_setschedprio>(3), "
"B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_setschedprio.3:24
#, no-wrap
msgid "PTHREAD_SETSCHEDPRIO"
msgstr "PTHREAD_SETSCHEDPRIO"

#. type: TH
#: build/C/man3/pthread_setschedprio.3:24
#, no-wrap
msgid "2008-11-06"
msgstr "2008-11-06"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:27
msgid "pthread_setschedprio - set scheduling priority of a thread"
msgstr "pthread_setschedprio - スレッドのスケジューリング優先度を設定する"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:32
#, no-wrap
msgid "B<pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"
msgstr "B<pthread_setschedprio(pthread_t >I<thread>B<, int >I<prio>B<);>\n"

#.  FIXME . nptl/pthread_setschedprio.c has the following
#.    /* If the thread should have higher priority because of some
#.       PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority. */
#.  Eventually (perhaps after writing the mutexattr pages), we
#.  may want to add something on the topic to this page.
#.  nptl/pthread_setschedparam.c has a similar case.
#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:51
msgid ""
"The B<pthread_setschedprio>()  function sets the scheduling priority of the "
"thread I<thread> to the value specified in I<prio>.  (By contrast "
"B<pthread_setschedparam>(3)  changes both the scheduling policy and priority "
"of a thread.)"
msgstr ""
"B<pthread_setschedprio>() 関数は、スレッド I<thread> のスケジューリング\n"
"優先度に I<prio> で指定された値を設定する\n"
"(一方、B<pthread_setschedparam>(3) はスレッドのスケジューリングポリシー\n"
"と優先度の両方を変更する)。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:59
msgid ""
"On success, this function returns 0; on error, it returns a nonzero error "
"number.  If B<pthread_setschedprio>()  fails, the scheduling priority of "
"I<thread> is not changed."
msgstr ""
"成功すると、この関数は 0 を返す。\n"
"エラーの場合、0 以外のエラー番号を返す。\n"
"B<pthread_setschedprio>() が失敗した場合、 I<thread> の\n"
"スケジューリング優先度は変更されない。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:64
msgid "I<prio> is not valid for the scheduling policy of the specified thread."
msgstr ""
"指定されたスレッドのスケジューリングポリシーでは、 I<prio> は無効である。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:68
msgid ""
"The caller does not have appropriate privileges to set the specified "
"priority."
msgstr "呼び出し側が、指定された優先度を設定するのに必要な特権を持っていない。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:79
msgid ""
"POSIX.1-2001 also documents an B<ENOTSUP> (\"attempt was made to set the "
"priority to an unsupported value\") error for B<pthread_setschedparam>(3)."
msgstr ""
"POSIX.1-2001 では、 B<pthread_setschedprio>() に関して\n"
"エラー B<ENOTSUP> (\"サポートされていない値を優先度\n"
"に設定しようとした\") も追加で規定されている。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:81
msgid "This function is available in glibc since version 2.3.4."
msgstr "この関数は glibc バージョン 2.3.4 以降で利用できる。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:89
msgid ""
"For a description of the permissions required to, and the effect of, "
"changing a thread's scheduling priority, and details of the permitted ranges "
"for priorities in each scheduling policy, see B<sched_setscheduler>(2)."
msgstr ""
"スレッドのスケジューリング優先度を変更するために必要な許可や\n"
"変更した場合の影響、および各スケジューリングポリシーで認められる優先度\n"
"の範囲の詳細については、 B<sched_setscheduler>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_setschedprio.3:101
msgid ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<sched_setscheduler>(2), "
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_self>(3), B<pthread_setschedparam>(3), "
"B<pthreads>(7)"
msgstr ""
"B<getrlimit>(2), B<sched_get_priority_min>(2), B<sched_setscheduler>(2), "
"B<pthread_attr_init>(3), B<pthread_attr_setinheritsched>(3), "
"B<pthread_attr_setschedparam>(3), B<pthread_attr_setschedpolicy>(3), "
"B<pthread_create>(3), B<pthread_self>(3), B<pthread_setschedparam>(3), "
"B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_sigmask.3:24
#, no-wrap
msgid "PTHREAD_SIGMASK"
msgstr "PTHREAD_SIGMASK"

#. type: TH
#: build/C/man3/pthread_sigmask.3:24
#, no-wrap
msgid "2011-10-16"
msgstr "2011-10-16"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:27
msgid "pthread_sigmask - examine and change mask of blocked signals"
msgstr "pthread_sigmask - 禁止するシグナルマスクの確認と変更を行う"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:33
#, no-wrap
msgid "B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"
msgstr "B<int pthread_sigmask(int >I<how>B<, const sigset_t *>I<set>B<, sigset_t *>I<oldset>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:44
msgid ""
"The B<pthread_sigmask>()  function is just like B<sigprocmask>(2), with the "
"difference that its use in multithreaded programs is explicitly specified by "
"POSIX.1-2001.  Other differences are noted in this page."
msgstr ""
"B<pthread_sigmask>() 関数は B<sigprocmask>(2) と全く同様だが、\n"
"マルチスレッドプログラムでの利用が POSIX.1-2001 で明示的に規定されて\n"
"いる点が異なる。他の違いはこのマニュアルページで説明する。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:47
msgid ""
"For a description of the arguments and operation of this function, see "
"B<sigprocmask>(2)."
msgstr "この関数の引き数と動作の説明は B<sigprocmask>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:52
msgid ""
"On success, B<pthread_sigmask>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_sigmask>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:55
msgid "See B<sigprocmask>(2)."
msgstr "B<sigprocmask>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:59
msgid "A new thread inherits a copy of its creator's signal mask."
msgstr ""
"新しいスレッドは、スレッドを作成したスレッドのシグナルマスクのコピーを\n"
"継承する。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:64
msgid ""
"The program below blocks some signals in the main thread, and then creates a "
"dedicated thread to fetch those signals via B<sigwait>(3).  The following "
"shell session demonstrates its use:"
msgstr ""
"以下のプログラムは、メインスレッドでシグナルのいくつかを禁止 (block)\n"
"するように設定を行い、 B<sigwait>(3) 経由でそれらのシグナルを集める\n"
"専用のスレッドを作成する。\n"
"下記のシェルのセッションはその利用例を示したものである。"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:75
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"
msgstr ""
"$B< ./a.out &>\n"
"[1] 5423\n"
"$B< kill -QUIT %1>\n"
"Signal handling thread got signal 3\n"
"$B< kill -USR1 %1>\n"
"Signal handling thread got signal 10\n"
"$B< kill -TERM %1>\n"
"[1]+  Terminated              ./a.out\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:86
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>errno.hE<gt>\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:88
#, no-wrap
msgid "/* Simple error handling functions */\n"
msgstr "/* Simple error handling functions */\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:97
#, no-wrap
msgid ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = (sigset_t *) arg;\n"
"    int s, sig;\n"
msgstr ""
"static void *\n"
"sig_thread(void *arg)\n"
"{\n"
"    sigset_t *set = (sigset_t *) arg;\n"
"    int s, sig;\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:105
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"
msgstr ""
"    for (;;) {\n"
"        s = sigwait(set, &sig);\n"
"        if (s != 0)\n"
"            handle_error_en(s, \"sigwait\");\n"
"        printf(\"Signal handling thread got signal %d\\en\", sig);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:112
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pthread_t thread;\n"
"    sigset_t set;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:115
#, no-wrap
msgid ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"
msgstr ""
"    /* Block SIGQUIT and SIGUSR1; other threads created by main()\n"
"       will inherit a copy of the signal mask. */\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:122
#, no-wrap
msgid ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"
msgstr ""
"    sigemptyset(&set);\n"
"    sigaddset(&set, SIGQUIT);\n"
"    sigaddset(&set, SIGUSR1);\n"
"    s = pthread_sigmask(SIG_BLOCK, &set, NULL);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_sigmask\");\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:126
#, no-wrap
msgid ""
"    s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"
msgstr ""
"    s = pthread_create(&thread, NULL, &sig_thread, (void *) &set);\n"
"    if (s != 0)\n"
"        handle_error_en(s, \"pthread_create\");\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:129
#, no-wrap
msgid ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"
msgstr ""
"    /* Main thread carries on to create other threads and/or do\n"
"       other work */\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:132
#, no-wrap
msgid ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"
msgstr ""
"    pause();            /* Dummy pause so we can test program */\n"
"}\n"

#. type: Plain text
#: build/C/man3/pthread_sigmask.3:142
msgid ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2)  B<pthread_create>(3), "
"B<pthread_kill>(3), B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2)  B<pthread_create>(3), "
"B<pthread_kill>(3), B<sigsetops>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/pthread_sigqueue.3:23
#, no-wrap
msgid "PTHREAD_SIGQUEUE"
msgstr "PTHREAD_SIGQUEUE"

#. type: TH
#: build/C/man3/pthread_sigqueue.3:23
#, no-wrap
msgid "2011-09-23"
msgstr "2011-09-23"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:26
msgid "pthread_sigqueue - queue a signal and data to a thread"
msgstr "pthread_sigqueue - スレッドに対するシグナルとデータをキューに入れる"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:32
#, no-wrap
msgid ""
"B<int pthread_sigqueue(pthread_t *>I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"
msgstr ""
"B<int pthread_sigqueue(pthread_t *>I<thread>B<, int >I<sig>B<,>\n"
"B<                     const union sigval >I<value>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:43
msgid "B<pthread_sigqueue>(): _GNU_SOURCE"
msgstr "B<pthread_sigqueue>(): _GNU_SOURCE"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:51
msgid ""
"The B<pthread_sigqueue>()  function performs a similar task to B<sigqueue>"
"(3), but, rather than sending a signal to another process, it sends a signal "
"to another thread in the same process as the calling thread."
msgstr ""
"B<pthread_sigqueue>() 関数は B<sigqueue>(3) と同様の処理を実行するが、\n"
"別のプロセスにシグナルを送信するのではなく、呼び出したスレッドと\n"
"同じプロセス内の他のスレッドにシグナルを送信する。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:63
msgid ""
"The I<thread> argument is the ID of another thread in the same process as "
"the caller.  The I<sig> argument specifies the signal to be sent.  The "
"I<value> argument specifies data to accompany the signal; see B<sigqueue>"
"(3)  for details."
msgstr ""
"I<thread> 引き数は、呼び出し側と同じプロセスの別のスレッドの ID である。\n"
"I<sig> 引き数は送信するシグナルを指定する。\n"
"I<value> 引き数はシグナルと一緒に渡すデータを指定する。\n"
"詳細は B<sigqueue>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:68
msgid ""
"On success, B<pthread_sigqueue>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_sigmask>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:75
msgid ""
"The limit of signals which may be queued has been reached.  (See B<signal>"
"(7)  for further information.)"
msgstr ""
"キューに入れられるシグナル数が上限に達していた\n"
"(詳しい情報は (B<signal>(7) を参照)。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:79
msgid "I<sig> was invalid."
msgstr "I<sig> が無効であった。"

#. type: TP
#: build/C/man3/pthread_sigqueue.3:79
#, no-wrap
msgid "B<ENOSYS>"
msgstr "B<ENOSYS>"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:83
msgid "B<pthread_sigqueue>()  is not supported on this system."
msgstr "B<pthread_sigqueue>() がこのシステムではサポートされていない。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:87
msgid "I<thread> is not valid."
msgstr "I<thread> が無効である。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:91
msgid "The B<pthread_sigqueue>()  function first appeared in glibc 2.11."
msgstr "B<pthread_sigqueue>() 関数は glibc 2.11 で初めて登場した。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:93
msgid "This function is a GNU extension."
msgstr "この関数は GNU による拡張である。"

#. type: Plain text
#: build/C/man3/pthread_sigqueue.3:101
msgid ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), B<sigqueue>"
"(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"
msgstr ""
"B<rt_tgsigqueueinfo>(2), B<sigaction>(2), B<pthread_sigmask>(3), \n"
"B<sigqueue>(3), B<sigwait>(3), B<pthreads>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/pthread_testcancel.3:24
#, no-wrap
msgid "PTHREAD_TESTCANCEL"
msgstr "PTHREAD_TESTCANCEL"

#. type: TH
#: build/C/man3/pthread_testcancel.3:24
#, no-wrap
msgid "2012-04-14"
msgstr "2012-04-14"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:27
msgid ""
"pthread_testcancel - request delivery of any pending cancellation request"
msgstr "pthread_testcancel - 処理待ちの取り消し要求の配送を要求する"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:32
#, no-wrap
msgid "B<void pthread_testcancel(void);>\n"
msgstr "B<void pthread_testcancel(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:41
msgid ""
"Calling B<pthread_testcancel>()  creates a cancellation point within the "
"calling thread, so that a thread that is otherwise executing code that "
"contains no cancellation points will respond to a cancellation request."
msgstr ""
"B<pthread_testcancel>() を呼び出すと、呼び出したスレッド内に取り消し\n"
"ポイント (cancellation point) が作成される。\n"
"これにより、これ以外には取り消しポイントを含まないコードを実行して\n"
"いるスレッドが取り消し要求に対応することができるようになる。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:48
msgid ""
"If cancelability is disabled (using B<pthread_setcancelstate>(3)), or no "
"cancellation request is pending, then a call to B<pthread_testcancel>(3)  "
"has no effect."
msgstr ""
"(B<pthread_setcancelstate>(3) を使って) キャンセルが無効になっている\n"
"場合や処理待ちの取り消し要求がない場合は、B<pthread_testcancel>(3) を\n"
"呼び出しても何の影響もない。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:52
msgid ""
"This function does not return a value.  If the calling thread is canceled as "
"a consequence of a call to this function, then the function does not return."
msgstr ""
"この関数は値を返さない。この関数の呼び出しの結果、呼び出したスレッドが\n"
"キャンセルされた場合、この関数が返ることはない。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:61
msgid "See B<pthread_cleanup_push>(3)."
msgstr "B<pthread_cleanup_push>(3) を参照。"

#. type: Plain text
#: build/C/man3/pthread_testcancel.3:66
msgid ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_setcancelstate>"
"(3), B<pthreads>(7)"
msgstr ""
"B<pthread_cancel>(3), B<pthread_cleanup_push>(3), B<pthread_setcancelstate>"
"(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_tryjoin_np.3:24
#, no-wrap
msgid "PTHREAD_TRYJOIN_NP"
msgstr "PTHREAD_TRYJOIN_NP"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:28
msgid ""
"pthread_tryjoin_np, pthread_timedjoin_np - try to join with a terminated "
"thread"
msgstr ""
"pthread_tryjoin_np, pthread_timedjoin_np - 終了したスレッドの join を\n"
"試みる"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:34
#, no-wrap
msgid "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"
msgstr "B<int pthread_tryjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:37
#, no-wrap
msgid ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"
msgstr ""
"B<int pthread_timedjoin_np(pthread_t >I<thread>B<, void **>I<retval>B<,>\n"
"B<                         const struct timespec *>I<abstime>B<);>\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:44
msgid ""
"These functions operate in the same way as B<pthread_join>(3), except for "
"the differences described on this page."
msgstr ""
"これらの関数は B<pthread_join>(3) と同じように動作するが、\n"
"このページで説明する違いがある。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:56
msgid ""
"The B<pthread_tryjoin_np>()  function performs a nonblocking join with the "
"thread I<thread>, returning the exit status of the thread in I<*retval>.  If "
"I<thread> has not yet terminated, then instead of blocking, as is done by "
"B<pthread_join>(3), the call returns an error."
msgstr ""
"B<pthread_tryjoin_np>() 関数は、スレッド I<thread> の非停止\n"
"(nonblocking) での join を実行し、スレッドの終了ステータスを\n"
"I<*retval> に入れて返す。I<thread> がまだ終了していない場合は、\n"
"B<pthread_join>(3) のように停止 (block) せずに、エラーを返す。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:74
msgid ""
"The B<pthread_timedjoin_np>()  function performs a join-with-timeout.  If "
"I<thread> has not yet terminated, then the call blocks until a maximum time, "
"specified in I<abstime>.  If the timeout expires before I<thread> "
"terminates, the call returns an error.  The I<abstime> argument is a "
"structure of the following form, specifying an absolute time measured since "
"the Epoch (see B<time>(2)):"
msgstr ""
"B<pthread_timedjoin_np>() 関数は、タイムアウト付きの join を行う。\n"
"I<thread> がまだ終了していない場合、 I<abstime> で指定された最大時間\n"
"まで停止する。 I<thread> が終了する前にタイムアウト時間が経過した場合は、\n"
"エラーを返す。I<abstime> 引き数は以下に示す構造体であり、\n"
"Epoch (時刻紀元; B<time>(2) 参照) から測った絶対時刻を指定する。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:81
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;     /* seconds */\n"
"    long   tv_nsec;    /* nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:87
msgid ""
"On success, these functions return 0; on error, they return an error number."
msgstr ""
"成功すると、これらの関数は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:92
msgid ""
"These functions can fail with the same errors as B<pthread_join>(3).  "
"B<pthread_tryjoin_np>()  can in addition fail with the following error:"
msgstr ""
"これらの関数は B<pthread_join>(3) と同じエラーで失敗する。\n"
"B<pthread_tryjoin_np>() はさらに以下のエラーで失敗する場合がある。"

#. type: TP
#: build/C/man3/pthread_tryjoin_np.3:92
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:96
msgid "I<thread> had not yet terminated at the time of the call."
msgstr "呼び出しを行った時点では I<thread> はまだ終了していない。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:99
msgid ""
"B<pthread_timedjoin_np>()  can in addition fail with the following error:"
msgstr "B<pthread_timedjoin_np>() はさらに以下のエラーで失敗する場合がある。"

#. type: TP
#: build/C/man3/pthread_tryjoin_np.3:99
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:104
msgid "The call timed out before I<thread> terminated."
msgstr "I<thread> が終了する前に呼び出しがタイムアウトとなった。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:108
msgid "B<pthread_timedjoin_np>()  never returns the error B<EINTR>."
msgstr "B<pthread_timedjoin_np>() がエラー B<EINTR> を返すことはない。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:110
msgid "These functions first appeared in glibc in version 2.3.3."
msgstr "これらの関数は glibc バージョン 2.3.3 で初めて登場した。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:115
msgid "The following code waits to join for up to 5 seconds:"
msgstr "以下のコードは、最大 5 秒まで join を待つ。"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:119
#, no-wrap
msgid ""
"    struct timespec ts;\n"
"    int s;\n"
msgstr ""
"    struct timespec ts;\n"
"    int s;\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:121
#, no-wrap
msgid "    ...\n"
msgstr "    ...\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:125
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"\t/* Handle error */\n"
"    }\n"
msgstr ""
"    if (clock_gettime(CLOCK_REALTIME, &ts) == -1) {\n"
"\t/* Handle error */\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:127
#, no-wrap
msgid "    ts.tv_sec += 5;\n"
msgstr "    ts.tv_sec += 5;\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:132
#, no-wrap
msgid ""
"    s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"    if (s != 0) {\n"
"        /* Handle error */\n"
"    }\n"
msgstr ""
"    s = pthread_timedjoin_np(thread, NULL, &ts);\n"
"    if (s != 0) {\n"
"        /* Handle error */\n"
"    }\n"

#. type: Plain text
#: build/C/man3/pthread_tryjoin_np.3:138
msgid ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"
msgstr ""
"B<clock_gettime>(2), B<pthread_exit>(3), B<pthread_join>(3), B<pthreads>(7)"

#. type: TH
#: build/C/man3/pthread_yield.3:23
#, no-wrap
msgid "PTHREAD_YIELD"
msgstr "PTHREAD_YIELD"

#. type: Plain text
#: build/C/man3/pthread_yield.3:26
msgid "pthread_yield - yield the processor"
msgstr "pthread_yield - プロセッサを明け渡す (yield)"

#. type: Plain text
#: build/C/man3/pthread_yield.3:31
#, no-wrap
msgid "B<int pthread_yield(void);>\n"
msgstr "B<int pthread_yield(void);>\n"

#. type: Plain text
#: build/C/man3/pthread_yield.3:41
msgid ""
"B<pthread_yield>()  causes the calling thread to relinquish the CPU.  The "
"thread is placed at the end of the run queue for its static priority and "
"another thread is scheduled to run.  For further details, see B<sched_yield>"
"(2)"
msgstr ""
"B<pthread_yield>() を呼び出すと、呼び出したスレッドは CPU を手放す。\n"
"スレッドはそのスレッドの静的優先度の実行キューの末尾に回り、\n"
"別のスレッドが実行されるようにスケジューリングされる。\n"
"詳細は B<sched_yield>(2) を参照。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:46
msgid ""
"On success, B<pthread_yield>()  returns 0; on error, it returns an error "
"number."
msgstr ""
"成功すると、 B<pthread_yield>() は 0 を返す。\n"
"エラーの場合、エラー番号を返す。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:50
msgid ""
"On Linux, this call always succeeds (but portable and future-proof "
"applications should nevertheless handle a possible error return)."
msgstr ""
"Linux では、この関数の呼び出しは常に成功する\n"
"(ただし、移植性や将来も動作することを保証したいアプリケーションでは\n"
"正のエラーの返り値を処理するようにすべきである)。"

#.  e.g., the BSDs, Tru64, AIX, and Irix.
#. type: Plain text
#: build/C/man3/pthread_yield.3:56
msgid ""
"This call is nonstandard, but present on several other systems.  Use the "
"standardized B<sched_yield>(2)  instead."
msgstr ""
"この関数は非標準だが、他のいくつかのシステムにも存在する。\n"
"代わりに、標準化されている B<sched_yield>(2) を使うこと。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:59
msgid "On Linux, this function is implemented as a call to B<sched_yield>(2)."
msgstr ""
"Linux では、この関数は B<sched_yield>(2) を呼び出す形で実装されている。"

#. type: Plain text
#: build/C/man3/pthread_yield.3:63
msgid "B<sched_setscheduler>(2), B<sched_yield>(2)  B<pthreads>(7)"
msgstr "B<sched_setscheduler>(2), B<sched_yield>(2)  B<pthreads>(7)"

#. type: TH
#: build/C/man7/pthreads.7:24
#, no-wrap
msgid "PTHREADS"
msgstr "PTHREADS"

#. type: TH
#: build/C/man7/pthreads.7:24
#, no-wrap
msgid "2010-11-14"
msgstr "2010-11-14"

#. type: Plain text
#: build/C/man7/pthreads.7:27
msgid "pthreads - POSIX threads"
msgstr "pthreads - POSIX スレッド"

#. type: Plain text
#: build/C/man7/pthreads.7:34
msgid ""
"POSIX.1 specifies a set of interfaces (functions, header files) for threaded "
"programming commonly known as POSIX threads, or Pthreads.  A single process "
"can contain multiple threads, all of which are executing the same program.  "
"These threads share the same global memory (data and heap segments), but "
"each thread has its own stack (automatic variables)."
msgstr ""
"POSIX.1 は、一般に POSIX スレッドや Pthreads として知られる スレッド・プログ"
"ラミングのインタフェース群 (関数、ヘッダファイル)  を規定している。一つのプロ"
"セスは複数のスレッドを持つことができ、 全てのスレッドは同じプログラムを実行す"
"る。 これらのスレッドは同じ大域メモリ (データとヒープ領域) を共有するが、 各"
"スレッドは自分専用のスタック (自動変数) を持つ。"

#. type: Plain text
#: build/C/man7/pthreads.7:37
msgid ""
"POSIX.1 also requires that threads share a range of other attributes (i.e., "
"these attributes are process-wide rather than per-thread):"
msgstr ""
"POSIX.1 はスレッド間でどのような属性を共有するかについても定めている (つま"
"り、これらの属性はスレッド単位ではなくプロセス全体で共通である):"

#. type: IP
#: build/C/man7/pthreads.7:37 build/C/man7/pthreads.7:39
#: build/C/man7/pthreads.7:41 build/C/man7/pthreads.7:43
#: build/C/man7/pthreads.7:45 build/C/man7/pthreads.7:47
#: build/C/man7/pthreads.7:49 build/C/man7/pthreads.7:52
#: build/C/man7/pthreads.7:54 build/C/man7/pthreads.7:57
#: build/C/man7/pthreads.7:63 build/C/man7/pthreads.7:68
#: build/C/man7/pthreads.7:71 build/C/man7/pthreads.7:74
#: build/C/man7/pthreads.7:82 build/C/man7/pthreads.7:86
#: build/C/man7/pthreads.7:89 build/C/man7/pthreads.7:93
#: build/C/man7/pthreads.7:96 build/C/man7/pthreads.7:103
#: build/C/man7/pthreads.7:106 build/C/man7/pthreads.7:683
#: build/C/man7/pthreads.7:690 build/C/man7/pthreads.7:702
#: build/C/man7/pthreads.7:712 build/C/man7/pthreads.7:716
#: build/C/man7/pthreads.7:725 build/C/man7/pthreads.7:735
#: build/C/man7/pthreads.7:742 build/C/man7/pthreads.7:749
#: build/C/man7/pthreads.7:751 build/C/man7/pthreads.7:754
#: build/C/man7/pthreads.7:760 build/C/man7/pthreads.7:763
#: build/C/man7/pthreads.7:765 build/C/man7/pthreads.7:767
#: build/C/man7/pthreads.7:777 build/C/man7/pthreads.7:797
#: build/C/man7/pthreads.7:806 build/C/man7/pthreads.7:812
#: build/C/man7/pthreads.7:814 build/C/man7/pthreads.7:816
#: build/C/man7/pthreads.7:820 build/C/man7/pthreads.7:825
#: build/C/man7/pthreads.7:833
#, no-wrap
msgid "-"
msgstr "-"

#. type: Plain text
#: build/C/man7/pthreads.7:39
msgid "process ID"
msgstr "プロセス ID"

#. type: Plain text
#: build/C/man7/pthreads.7:41
msgid "parent process ID"
msgstr "親プロセス ID"

#. type: Plain text
#: build/C/man7/pthreads.7:43
msgid "process group ID and session ID"
msgstr "プロセスグループ ID とセッション ID"

#. type: Plain text
#: build/C/man7/pthreads.7:45
msgid "controlling terminal"
msgstr "制御端末"

#. type: Plain text
#: build/C/man7/pthreads.7:47
msgid "user and group IDs"
msgstr "ユーザ ID とグループ ID"

#. type: Plain text
#: build/C/man7/pthreads.7:49
msgid "open file descriptors"
msgstr "オープンするファイルディスクリプタ"

#. type: Plain text
#: build/C/man7/pthreads.7:52
msgid "record locks (see B<fcntl>(2))"
msgstr "レコードのロック (B<fcntl>(3)  参照)"

#. type: Plain text
#: build/C/man7/pthreads.7:54
msgid "signal dispositions"
msgstr "シグナルの配置"

#. type: Plain text
#: build/C/man7/pthreads.7:57
msgid "file mode creation mask (B<umask>(2))"
msgstr "ファイルモード作成マスク (B<umask>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:63
msgid "current directory (B<chdir>(2))  and root directory (B<chroot>(2))"
msgstr ""
"カレント・ディレクトリ (B<chdir>(2))  とルート・ディレクトリ (B<chroot>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:68
msgid ""
"interval timers (B<setitimer>(2))  and POSIX timers (B<timer_create>(2))"
msgstr ""
"インターバル・タイマ (B<setitimer>(2))  と POSIX タイマ (B<timer_create>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:71
msgid "nice value (B<setpriority>(2))"
msgstr "nice 値 (B<setpriority>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:74
msgid "resource limits (B<setrlimit>(2))"
msgstr "リソース制限 (B<setrlimit>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:79
msgid ""
"measurements of the consumption of CPU time (B<times>(2))  and resources "
"(B<getrusage>(2))"
msgstr "CPU 時間 (B<times>(2))  とリソース (B<getrusage>(2))  の消費状況の計測"

#. type: Plain text
#: build/C/man7/pthreads.7:82
msgid ""
"As well as the stack, POSIX.1 specifies that various other attributes are "
"distinct for each thread, including:"
msgstr ""
"スタックについても、POSIX.1 はどのような属性が 個々のスレッドで独立に管理され"
"るかを規定している:"

#. type: Plain text
#: build/C/man7/pthreads.7:86
msgid "thread ID (the I<pthread_t> data type)"
msgstr "スレッド ID (B<pthread_t> データ型)"

#. type: Plain text
#: build/C/man7/pthreads.7:89
msgid "signal mask (B<pthread_sigmask>(3))"
msgstr "シグナルマスク (B<pthread_sigmask>(3))"

#. type: Plain text
#: build/C/man7/pthreads.7:93
msgid "the I<errno> variable"
msgstr "I<errno> 変数"

#. type: Plain text
#: build/C/man7/pthreads.7:96
msgid "alternate signal stack (B<sigaltstack>(2))"
msgstr "代替シグナルスタック (B<sigaltstack>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:101
msgid ""
"real-time scheduling policy and priority (B<sched_setscheduler>(2)  and "
"B<sched_setparam>(2))"
msgstr ""
"リアルタイム・スケジューリングのポリシーと優先度 (B<sched_setscheduler>(2)  "
"と B<sched_setparam>(2))"

#. type: Plain text
#: build/C/man7/pthreads.7:103
msgid "The following Linux-specific features are also per-thread:"
msgstr "以下の Linux 特有の機能もスレッド単位である:"

#. type: Plain text
#: build/C/man7/pthreads.7:106
msgid "capabilities (see B<capabilities>(7))"
msgstr "ケーパビリティ (B<capabilities>(7)  参照)"

#. type: Plain text
#: build/C/man7/pthreads.7:109
msgid "CPU affinity (B<sched_setaffinity>(2))"
msgstr "CPU affinity (親和度)  (B<sched_setaffinity>(2))"

#. type: SS
#: build/C/man7/pthreads.7:109
#, no-wrap
msgid "Pthreads function return values"
msgstr "pthreads 関数の返り値"

#. type: Plain text
#: build/C/man7/pthreads.7:116
msgid ""
"Most pthreads functions return 0 on success, and an error number of "
"failure.  Note that the pthreads functions do not set I<errno>.  For each of "
"the pthreads functions that can return an error, POSIX.1-2001 specifies that "
"the function can never fail with the error B<EINTR>."
msgstr ""
"ほとんどの pthreads 関数は成功すると 0 を返し、 失敗した場合エラー番号を返"
"す。 pthreads 関数は I<errno> をセットしない点に注意すること。 POSIX.1-2001 "
"では、 エラーを返す可能性のある pthreads 関数がエラー B<EINTR> で失敗すること"
"は決してないと規定している。"

#. type: SS
#: build/C/man7/pthreads.7:116
#, no-wrap
msgid "Thread IDs"
msgstr "スレッド ID"

#. type: Plain text
#: build/C/man7/pthreads.7:130
msgid ""
"Each of the threads in a process has a unique thread identifier (stored in "
"the type I<pthread_t>).  This identifier is returned to the caller of "
"B<pthread_create>(3), and a thread can obtain its own thread identifier "
"using B<pthread_self>(3).  Thread IDs are only guaranteed to be unique "
"within a process.  A thread ID may be reused after a terminated thread has "
"been joined, or a detached thread has terminated.  In all pthreads functions "
"that accept a thread ID as an argument, that ID by definition refers to a "
"thread in the same process as the caller."
msgstr ""
"あるプロセス内の各スレッドは (I<pthread_t> 型の) 一意なスレッド識別子を持"
"つ。 この識別子は、 B<pthread_create>(3)  の呼び出し元に返される。また、ス"
"レッドは自身のスレッド識別子を B<pthread_self>(3)  を使って取得できる。 ス"
"レッド ID の一意性が保証されるのは、一つのプロセス内においてのみである。 終了"
"したスレッドが join された後では、スレッド ID は再利用される可能性がある。 ス"
"レッド ID を引き数に取る全てのスレッド関数において、 その ID は呼び出し元と同"
"じプロセス内の一つのスレッドを参照する。"

#. type: SS
#: build/C/man7/pthreads.7:130
#, no-wrap
msgid "Thread-safe functions"
msgstr "スレッドセーフな関数"

#. type: Plain text
#: build/C/man7/pthreads.7:134
msgid ""
"A thread-safe function is one that can be safely (i.e., it will deliver the "
"same results regardless of whether it is)  called from multiple threads at "
"the same time."
msgstr ""
"スレッドセーフな関数は、複数のスレッドから同時に呼び出しても安全な (すなわ"
"ち、同時に呼び出されたかに関わらず、同じ結果を返す) 関数のことである。"

#. type: Plain text
#: build/C/man7/pthreads.7:138
msgid ""
"POSIX.1-2001 and POSIX.1-2008 require that all functions specified in the "
"standard shall be thread-safe, except for the following functions:"
msgstr ""
"POSIX.1-2001 と POSIX.1-2008では、一部の例外を除き、 標準で規定されている全て"
"の関数がスレッドセーフであることを要求している。 以下の関数が例外である。"

#. type: Plain text
#: build/C/man7/pthreads.7:232
#, no-wrap
msgid ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() if passed a non-NULL argument\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"gethostbyname() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [Added in POSIX.1-2008]\n"
"strtok()\n"
"system() [Added in POSIX.1-2008]\n"
"tmpnam() if passed a non-NULL argument\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() if its final argument is NULL\n"
"wcsrtombs() if its final argument is NULL\n"
"wcstombs()\n"
"wctomb()\n"
msgstr ""
"asctime()\n"
"basename()\n"
"catgets()\n"
"crypt()\n"
"ctermid() (NULL でない引き数を渡された場合)\n"
"ctime()\n"
"dbm_clearerr()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_error()\n"
"dbm_fetch()\n"
"dbm_firstkey()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dirname()\n"
"dlerror()\n"
"drand48()\n"
"ecvt() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"encrypt()\n"
"endgrent()\n"
"endpwent()\n"
"endutxent()\n"
"fcvt() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"ftw()\n"
"gcvt() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"getc_unlocked()\n"
"getchar_unlocked()\n"
"getdate()\n"
"getenv()\n"
"getgrent()\n"
"getgrgid()\n"
"getgrnam()\n"
"gethostbyaddr() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"gethostbyname() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"gethostent()\n"
"getlogin()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt()\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwuid()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"gmtime()\n"
"hcreate()\n"
"hdestroy()\n"
"hsearch()\n"
"inet_ntoa()\n"
"l64a()\n"
"lgamma()\n"
"lgammaf()\n"
"lgammal()\n"
"localeconv()\n"
"localtime()\n"
"lrand48()\n"
"mrand48()\n"
"nftw()\n"
"nl_langinfo()\n"
"ptsname()\n"
"putc_unlocked()\n"
"putchar_unlocked()\n"
"putenv()\n"
"pututxline()\n"
"rand()\n"
"readdir()\n"
"setenv()\n"
"setgrent()\n"
"setkey()\n"
"setpwent()\n"
"setutxent()\n"
"strerror()\n"
"strsignal() [POSIX.1-2008 で追加された]\n"
"strtok()\n"
"system() [POSIX.1-2008 で追加された]\n"
"tmpnam() (NULL でない引き数を渡された場合)\n"
"ttyname()\n"
"unsetenv()\n"
"wcrtomb() (最後の引き数が NULL の場合)\n"
"wcsrtombs() (最後の引き数が NULL の場合)\n"
"wcstombs()\n"
"wctomb()\n"

#. type: SS
#: build/C/man7/pthreads.7:234
#, no-wrap
msgid "Async-cancel-safe functions"
msgstr "async-cancel-safe 関数"

#. type: Plain text
#: build/C/man7/pthreads.7:238
msgid ""
"An async-cancel-safe function is one that can be safely called in an "
"application where asynchronous cancelability is enabled (see "
"B<pthread_setcancelstate>(3))."
msgstr ""
"async-cancel-safe 関数は、\n"
"非同期キャンセル機能が有効になっているアプリケーションで\n"
"安全に呼び出すことができる関数のことである\n"
"(B<pthread_setcancelstate>(3) を参照)。"

#. type: Plain text
#: build/C/man7/pthreads.7:241
msgid ""
"Only the following functions are required to be async-cancel-safe by "
"POSIX.1-2001 and POSIX.1-2008:"
msgstr ""
"以下の関数だけが、POSIX.1-2001 と POSIX.1-2008 で async-cancel-safe で\n"
"なければならないとされている。"

#. type: Plain text
#: build/C/man7/pthreads.7:247
#, no-wrap
msgid ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"
msgstr ""
"pthread_cancel()\n"
"pthread_setcancelstate()\n"
"pthread_setcanceltype()\n"

#. type: SS
#: build/C/man7/pthreads.7:249
#, no-wrap
msgid "Cancellation Points"
msgstr "取り消しポイント (cancellation points)"

#. type: Plain text
#: build/C/man7/pthreads.7:256
msgid ""
"POSIX.1 specifies that certain functions must, and certain other functions "
"may, be cancellation points.  If a thread is cancelable, its cancelability "
"type is deferred, and a cancellation request is pending for the thread, then "
"the thread is canceled when it calls a function that is a cancellation point."
msgstr ""
"POSIX.1 の規定では、特定の関数は取り消しポイントでなければならず、 他の特定の"
"関数は取り消しポイントであってもよいとされている。 あるスレッドが取り消し可能"
"で、その取り消し種別 (cancelability type)  が延期 (deferred) で、そのスレッド"
"に対する取り消し要求が処理待ちの場合、 取り消しポイントである関数を呼び出した"
"時点で、そのスレッドのキャンセルが 行われる。"

#. type: Plain text
#: build/C/man7/pthreads.7:259
msgid ""
"The following functions are required to be cancellation points by "
"POSIX.1-2001 and/or POSIX.1-2008:"
msgstr ""
"POSIX.1-2001 と POSIX.1-2008 の両方、もしくはいずれか一方では、 以下の関数"
"は、取り消しポイント (cancellation points) で あることが必須となっている。"

#. type: Plain text
#: build/C/man7/pthreads.7:322
#, no-wrap
msgid ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [Added in POSIX.1-2008]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 only (function removed in POSIX.1-2008)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"
msgstr ""
"accept()\n"
"aio_suspend()\n"
"clock_nanosleep()\n"
"close()\n"
"connect()\n"
"creat()\n"
"fcntl() F_SETLKW\n"
"fdatasync()\n"
"fsync()\n"
"getmsg()\n"
"getpmsg()\n"
"lockf() F_LOCK\n"
"mq_receive()\n"
"mq_send()\n"
"mq_timedreceive()\n"
"mq_timedsend()\n"
"msgrcv()\n"
"msgsnd()\n"
"msync()\n"
"nanosleep()\n"
"open()\n"
"openat() [POSIX.1-2008 で追加された]\n"
"pause()\n"
"poll()\n"
"pread()\n"
"pselect()\n"
"pthread_cond_timedwait()\n"
"pthread_cond_wait()\n"
"pthread_join()\n"
"pthread_testcancel()\n"
"putmsg()\n"
"putpmsg()\n"
"pwrite()\n"
"read()\n"
"readv()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"select()\n"
"sem_timedwait()\n"
"sem_wait()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"sigpause() [POSIX.1-2001 only (moves to \"may\" list in POSIX.1-2008)]\n"
"sigsuspend()\n"
"sigtimedwait()\n"
"sigwait()\n"
"sigwaitinfo()\n"
"sleep()\n"
"system()\n"
"tcdrain()\n"
"usleep() [POSIX.1-2001 のみ (POSIX.1-2008 で削除された)]\n"
"wait()\n"
"waitid()\n"
"waitpid()\n"
"write()\n"
"writev()\n"

#. type: Plain text
#: build/C/man7/pthreads.7:327
msgid ""
"The following functions may be cancellation points according to POSIX.1-2001 "
"and/or POSIX.1-2008:"
msgstr ""
"POSIX.1-2001 と POSIX.1-2008 の両方、もしくはいずれか一方では、 以下の関数"
"は、取り消しポイント (cancellation points) で あってもよいことになっている。"

#. type: Plain text
#: build/C/man7/pthreads.7:555
#, no-wrap
msgid ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [Added in POSIX.1-2008]\n"
"chown() [Added in POSIX.1-2008]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [Added in POSIX.1-2008]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [Added in POSIX.1-2008]\n"
"fchmod() [Added in POSIX.1-2008]\n"
"fchmodat() [Added in POSIX.1-2008]\n"
"fchown() [Added in POSIX.1-2008]\n"
"fchownat() [Added in POSIX.1-2008]\n"
"fclose()\n"
"fcntl() (for any value of cmd argument)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [Added in POSIX.1-2008]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [Added in POSIX.1-2008]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [Added in POSIX.1-2008]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"gethostbyname() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [Added in POSIX.1-2008]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (if opterr is nonzero)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [SUSv3 only (function removed in POSIX.1-2008)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [Added in POSIX.1-2008]\n"
"lio_listio() [Added in POSIX.1-2008]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [Added in POSIX.1-2008]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [Added in POSIX.1-2008]\n"
"mkdirat() [Added in POSIX.1-2008]\n"
"mkdtemp() [Added in POSIX.1-2008]\n"
"mkfifo() [Added in POSIX.1-2008]\n"
"mkfifoat() [Added in POSIX.1-2008]\n"
"mknod() [Added in POSIX.1-2008]\n"
"mknodat() [Added in POSIX.1-2008]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [Added in POSIX.1-2008]\n"
"psignal() [Added in POSIX.1-2008]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [Added in POSIX.1-2008]\n"
"readlinkat() [Added in POSIX.1-2008]\n"
"remove()\n"
"rename()\n"
"renameat() [Added in POSIX.1-2008]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [Added in POSIX.1-2008]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [Added in POSIX.1-2008]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [Added in POSIX.1-2008]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [Added in POSIX.1-2008]\n"
"utime() [Added in POSIX.1-2008]\n"
"utimensat() [Added in POSIX.1-2008]\n"
"utimes() [Added in POSIX.1-2008]\n"
"vdprintf() [Added in POSIX.1-2008]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"
msgstr ""
"access()\n"
"asctime()\n"
"asctime_r()\n"
"catclose()\n"
"catgets()\n"
"catopen()\n"
"chmod() [POSIX.1-2008 で追加された]\n"
"chown() [POSIX.1-2008 で追加された]\n"
"closedir()\n"
"closelog()\n"
"ctermid()\n"
"ctime()\n"
"ctime_r()\n"
"dbm_close()\n"
"dbm_delete()\n"
"dbm_fetch()\n"
"dbm_nextkey()\n"
"dbm_open()\n"
"dbm_store()\n"
"dlclose()\n"
"dlopen()\n"
"dprintf() [POSIX.1-2008 で追加された]\n"
"endgrent()\n"
"endhostent()\n"
"endnetent()\n"
"endprotoent()\n"
"endpwent()\n"
"endservent()\n"
"endutxent()\n"
"faccessat() [POSIX.1-2008 で追加された]\n"
"fchmod() [POSIX.1-2008 で追加された]\n"
"fchmodat() [POSIX.1-2008 で追加された]\n"
"fchown() [POSIX.1-2008 で追加された]\n"
"fchownat() [POSIX.1-2008 で追加された]\n"
"fclose()\n"
"fcntl() (cmd 引き数が何であっても)\n"
"fflush()\n"
"fgetc()\n"
"fgetpos()\n"
"fgets()\n"
"fgetwc()\n"
"fgetws()\n"
"fmtmsg()\n"
"fopen()\n"
"fpathconf()\n"
"fprintf()\n"
"fputc()\n"
"fputs()\n"
"fputwc()\n"
"fputws()\n"
"fread()\n"
"freopen()\n"
"fscanf()\n"
"fseek()\n"
"fseeko()\n"
"fsetpos()\n"
"fstat()\n"
"fstatat() [POSIX.1-2008 で追加された]\n"
"ftell()\n"
"ftello()\n"
"ftw()\n"
"futimens() [POSIX.1-2008 で追加された]\n"
"fwprintf()\n"
"fwrite()\n"
"fwscanf()\n"
"getaddrinfo()\n"
"getc()\n"
"getc_unlocked()\n"
"getchar()\n"
"getchar_unlocked()\n"
"getcwd()\n"
"getdate()\n"
"getdelim() [POSIX.1-2008 で追加された]\n"
"getgrent()\n"
"getgrgid()\n"
"getgrgid_r()\n"
"getgrnam()\n"
"getgrnam_r()\n"
"gethostbyaddr() [SUSv3 のみ (この関数は POSIX.1-2008 で削除されている)]\n"
"gethostbyname() [SUSv3 のみ (この関数は POSIX.1-2008 で削除されている)]\n"
"gethostent()\n"
"gethostid()\n"
"gethostname()\n"
"getline() [POSIX.1-2008 で追加された]\n"
"getlogin()\n"
"getlogin_r()\n"
"getnameinfo()\n"
"getnetbyaddr()\n"
"getnetbyname()\n"
"getnetent()\n"
"getopt() (opterr が 0 以外の場合)\n"
"getprotobyname()\n"
"getprotobynumber()\n"
"getprotoent()\n"
"getpwent()\n"
"getpwnam()\n"
"getpwnam_r()\n"
"getpwuid()\n"
"getpwuid_r()\n"
"gets()\n"
"getservbyname()\n"
"getservbyport()\n"
"getservent()\n"
"getutxent()\n"
"getutxid()\n"
"getutxline()\n"
"getwc()\n"
"getwchar()\n"
"getwd() [SUSv3 のみ (この関数は POSIX.1-2008 で削除されている)]\n"
"glob()\n"
"iconv_close()\n"
"iconv_open()\n"
"ioctl()\n"
"link()\n"
"linkat() [POSIX.1-2008 で追加された]\n"
"lio_listio() [POSIX.1-2008 で追加された]\n"
"localtime()\n"
"localtime_r()\n"
"lockf() [POSIX.1-2008 で追加された]\n"
"lseek()\n"
"lstat()\n"
"mkdir() [POSIX.1-2008 で追加された]\n"
"mkdirat() [POSIX.1-2008 で追加された]\n"
"mkdtemp() [POSIX.1-2008 で追加された]\n"
"mkfifo() [POSIX.1-2008 で追加された]\n"
"mkfifoat() [POSIX.1-2008 で追加された]\n"
"mknod() [POSIX.1-2008 で追加された]\n"
"mknodat() [POSIX.1-2008 で追加された]\n"
"mkstemp()\n"
"mktime()\n"
"nftw()\n"
"opendir()\n"
"openlog()\n"
"pathconf()\n"
"pclose()\n"
"perror()\n"
"popen()\n"
"posix_fadvise()\n"
"posix_fallocate()\n"
"posix_madvise()\n"
"posix_openpt()\n"
"posix_spawn()\n"
"posix_spawnp()\n"
"posix_trace_clear()\n"
"posix_trace_close()\n"
"posix_trace_create()\n"
"posix_trace_create_withlog()\n"
"posix_trace_eventtypelist_getnext_id()\n"
"posix_trace_eventtypelist_rewind()\n"
"posix_trace_flush()\n"
"posix_trace_get_attr()\n"
"posix_trace_get_filter()\n"
"posix_trace_get_status()\n"
"posix_trace_getnext_event()\n"
"posix_trace_open()\n"
"posix_trace_rewind()\n"
"posix_trace_set_filter()\n"
"posix_trace_shutdown()\n"
"posix_trace_timedgetnext_event()\n"
"posix_typed_mem_open()\n"
"printf()\n"
"psiginfo() [POSIX.1-2008 で追加された]\n"
"psignal() [POSIX.1-2008 で追加された]\n"
"pthread_rwlock_rdlock()\n"
"pthread_rwlock_timedrdlock()\n"
"pthread_rwlock_timedwrlock()\n"
"pthread_rwlock_wrlock()\n"
"putc()\n"
"putc_unlocked()\n"
"putchar()\n"
"putchar_unlocked()\n"
"puts()\n"
"pututxline()\n"
"putwc()\n"
"putwchar()\n"
"readdir()\n"
"readdir_r()\n"
"readlink() [POSIX.1-2008 で追加された]\n"
"readlinkat() [POSIX.1-2008 で追加された]\n"
"remove()\n"
"rename()\n"
"renameat() [POSIX.1-2008 で追加された]\n"
"rewind()\n"
"rewinddir()\n"
"scandir() [POSIX.1-2008 で追加された]\n"
"scanf()\n"
"seekdir()\n"
"semop()\n"
"setgrent()\n"
"sethostent()\n"
"setnetent()\n"
"setprotoent()\n"
"setpwent()\n"
"setservent()\n"
"setutxent()\n"
"sigpause() [POSIX.1-2008 で追加された]\n"
"stat()\n"
"strerror()\n"
"strerror_r()\n"
"strftime()\n"
"symlink()\n"
"symlinkat() [POSIX.1-2008 で追加された]\n"
"sync()\n"
"syslog()\n"
"tmpfile()\n"
"tmpnam()\n"
"ttyname()\n"
"ttyname_r()\n"
"tzset()\n"
"ungetc()\n"
"ungetwc()\n"
"unlink()\n"
"unlinkat() [POSIX.1-2008 で追加された]\n"
"utime() [POSIX.1-2008 で追加された]\n"
"utimensat() [POSIX.1-2008 で追加された]\n"
"utimes() [POSIX.1-2008 で追加された]\n"
"vdprintf() [POSIX.1-2008 で追加された]\n"
"vfprintf()\n"
"vfwprintf()\n"
"vprintf()\n"
"vwprintf()\n"
"wcsftime()\n"
"wordexp()\n"
"wprintf()\n"
"wscanf()\n"

#.  So, scanning "cancellation point" comments in the glibc 2.8 header
#.  files, it looks as though at least the following nonstandard
#.  functions are cancellation points:
#.  endnetgrent
#.  endspent
#.  epoll_pwait
#.  epoll_wait
#.  fcloseall
#.  fdopendir
#.  fflush_unlocked
#.  fgetc_unlocked
#.  fgetgrent
#.  fgetgrent_r
#.  fgetpwent
#.  fgetpwent_r
#.  fgets_unlocked
#.  fgetspent
#.  fgetspent_r
#.  fgetwc_unlocked
#.  fgetws_unlocked
#.  fputc_unlocked
#.  fputs_unlocked
#.  fputwc_unlocked
#.  fputws_unlocked
#.  fread_unlocked
#.  fwrite_unlocked
#.  gai_suspend
#.  getaddrinfo_a
#.  getdate_r
#.  getgrent_r
#.  getgrouplist
#.  gethostbyaddr_r
#.  gethostbyname2
#.  gethostbyname2_r
#.  gethostbyname_r
#.  gethostent_r
#.  getnetbyaddr_r
#.  getnetbyname_r
#.  getnetent_r
#.  getnetgrent
#.  getnetgrent_r
#.  getprotobyname_r
#.  getprotobynumber_r
#.  getprotoent_r
#.  getpw
#.  getpwent_r
#.  getservbyname_r
#.  getservbyport_r
#.  getservent_r
#.  getspent
#.  getspent_r
#.  getspnam
#.  getspnam_r
#.  getutmp
#.  getutmpx
#.  getw
#.  getwc_unlocked
#.  getwchar_unlocked
#.  initgroups
#.  innetgr
#.  mkostemp
#.  mkostemp64
#.  mkstemp64
#.  ppoll
#.  pthread_timedjoin_np
#.  putgrent
#.  putpwent
#.  putspent
#.  putw
#.  putwc_unlocked
#.  putwchar_unlocked
#.  rcmd
#.  rcmd_af
#.  rexec
#.  rexec_af
#.  rresvport
#.  rresvport_af
#.  ruserok
#.  ruserok_af
#.  setnetgrent
#.  setspent
#.  sgetspent
#.  sgetspent_r
#.  updwtmpx
#.  utmpxname
#.  vfscanf
#.  vfwscanf
#.  vscanf
#.  vsyslog
#.  vwscanf
#. type: Plain text
#: build/C/man7/pthreads.7:653
msgid ""
"An implementation may also mark other functions not specified in the "
"standard as cancellation points.  In particular, an implementation is likely "
"to mark any nonstandard function that may block as a cancellation point.  "
"(This includes most functions that can touch files.)"
msgstr ""
"実装時に、標準規格で規定されていないその他の関数を取り消しポイント とすること"
"も認められている。 特に、停止 (block) する可能性がある非標準の関数を取り消し"
"ポイントと する実装はあり得ることだろう (ファイルを扱う可能性のあるほとんどの"
"関数がこれに含まれる)。"

#. type: SS
#: build/C/man7/pthreads.7:653
#, no-wrap
msgid "Compiling on Linux"
msgstr "Linux でのコンパイル"

#. type: Plain text
#: build/C/man7/pthreads.7:656
msgid ""
"On Linux, programs that use the Pthreads API should be compiled using I<cc -"
"pthread>."
msgstr ""
"Linux では、Pthreads API を用いたプログラムは I<cc -pthread> でコンパイルすべ"
"きである。"

#. type: SS
#: build/C/man7/pthreads.7:656
#, no-wrap
msgid "Linux Implementations of POSIX Threads"
msgstr "POSIX スレッドの Linux での実装"

#. type: Plain text
#: build/C/man7/pthreads.7:659
msgid ""
"Over time, two threading implementations have been provided by the GNU C "
"library on Linux:"
msgstr ""
"これまで、2つのスレッドの実装が Linux の GNU C ライブラリにより 提供されてき"
"た。"

#. type: TP
#: build/C/man7/pthreads.7:659
#, no-wrap
msgid "B<LinuxThreads>"
msgstr "B<LinuxThreads>"

#. type: Plain text
#: build/C/man7/pthreads.7:663
msgid ""
"This is the original Pthreads implementation.  Since glibc 2.4, this "
"implementation is no longer supported."
msgstr ""
"最初の Pthreads の実装。\n"
"glibc 2.4 以降は、この実装はもはやサポートされていない。"

#. type: TP
#: build/C/man7/pthreads.7:663
#, no-wrap
msgid "B<NPTL> (Native POSIX Threads Library)"
msgstr "B<NPTL> (Native POSIX Threads Library)"

#. type: Plain text
#: build/C/man7/pthreads.7:671
msgid ""
"This is the modern Pthreads implementation.  By comparison with "
"LinuxThreads, NPTL provides closer conformance to the requirements of the "
"POSIX.1 specification and better performance when creating large numbers of "
"threads.  NPTL is available since glibc 2.3.2, and requires features that "
"are present in the Linux 2.6 kernel."
msgstr ""
"新しい Pthreads の実装。LinuxThreads と比べると、 NPTL は POSIX.1 の要求仕様"
"への準拠の度合いが高く、 多数のスレッドを作成した際の性能も高い。 NPTL は "
"glibc 2.3.2 以降で利用可能である。 NPTL を利用するには Linux 2.6 カーネルに実"
"装されている機能が必要である。"

#. type: Plain text
#: build/C/man7/pthreads.7:681
msgid ""
"Both of these are so-called 1:1 implementations, meaning that each thread "
"maps to a kernel scheduling entity.  Both threading implementations employ "
"the Linux B<clone>(2)  system call.  In NPTL, thread synchronization "
"primitives (mutexes, thread joining, and so on) are implemented using the "
"Linux B<futex>(2)  system call."
msgstr ""
"どちらの実装もいわゆる 1:1 実装、すなわち個々のスレッドが カーネルのスケ"
"ジューリング実体にマッピングされる。 どちらのスレッドの実装も Linux の "
"B<clone>(2)  システムコールを利用している。 NPTL では、スレッド同期の基本機"
"構 (mutex や スレッドの join 等) は Linux の B<futex>(2)  システムコールを"
"使って実装されている。"

#. type: SS
#: build/C/man7/pthreads.7:681
#, no-wrap
msgid "LinuxThreads"
msgstr "LinuxThreads"

#. type: Plain text
#: build/C/man7/pthreads.7:683
msgid "The notable features of this implementation are the following:"
msgstr "この実装の大きな特徴は以下の通りである:"

#. type: Plain text
#: build/C/man7/pthreads.7:690
msgid ""
"In addition to the main (initial) thread, and the threads that the program "
"creates using B<pthread_create>(3), the implementation creates a \"manager\" "
"thread.  This thread handles thread creation and termination.  (Problems can "
"result if this thread is inadvertently killed.)"
msgstr ""
"メインスレッド (最初のスレッド) とプログラムが B<pthread_create>(3)  を使って"
"作成したスレッドに加え、 この実装では「管理 (manager)」スレッドが作成され"
"る。 管理スレッドはスレッドの作成と終了を取り扱う (このスレッドがうっかり "
"kill されると、問題が起こることがある)。"

#. type: Plain text
#: build/C/man7/pthreads.7:702
msgid ""
"Signals are used internally by the implementation.  On Linux 2.2 and later, "
"the first three real-time signals are used (see also B<signal>(7)).  On "
"older Linux kernels, B<SIGUSR1> and B<SIGUSR2> are used.  Applications must "
"avoid the use of whichever set of signals is employed by the implementation."
msgstr ""
"この実装では内部でシグナルを使用している。 Linux 2.2 以降では、リアルタイムシ"
"グナルのうち最初の 3つが使われる (B<signal>(7)  参照)。 それ以前のカーネルで"
"は B<SIGUSR1> と B<SIGUSR2> が使われる。 アプリケーションは、スレッド実装で利"
"用されているシグナルを どれも使わないようにしなければならない。"

#. type: Plain text
#: build/C/man7/pthreads.7:709
msgid ""
"Threads do not share process IDs.  (In effect, LinuxThreads threads are "
"implemented as processes which share more information than usual, but which "
"do not share a common process ID.)  LinuxThreads threads (including the "
"manager thread)  are visible as separate processes using B<ps>(1)."
msgstr ""
"スレッド間でプロセス ID を共有しない (実際には LinuxThreads のスレッドは通常"
"よりは情報を共有するプロセスとして 実装されているが、一つの共通のプロセス ID "
"を共有してはいない)。 (管理スレッドを含む) LinuxThreads スレッドは B<ps>(1)  "
"を使うと別のプロセスのように見える。"

#. type: Plain text
#: build/C/man7/pthreads.7:712
msgid ""
"The LinuxThreads implementation deviates from the POSIX.1 specification in a "
"number of ways, including the following:"
msgstr ""
"LinuxThreads の実装では POSIX.1 仕様から逸脱している点が いくつかある。以下に"
"示すような点がある:"

#. type: Plain text
#: build/C/man7/pthreads.7:716
msgid "Calls to B<getpid>(2)  return a different value in each thread."
msgstr "B<getpid>(2)  を呼び出したときに、スレッド毎に異なる値が返される。"

#. type: Plain text
#: build/C/man7/pthreads.7:725
msgid ""
"Calls to B<getppid>(2)  in threads other than the main thread return the "
"process ID of the manager thread; instead B<getppid>(2)  in these threads "
"should return the same value as B<getppid>(2)  in the main thread."
msgstr ""
"メインスレッド以外のスレッドで B<getppid>(2)  を呼び出すと、管理スレッドのプ"
"ロセス ID が返される。 本当は、これらのスレッドで B<getppid>(2)  を呼んだ場合"
"にはメインスレッドでの B<getppid>(2)  と同じ値が返るべきである。"

#. type: Plain text
#: build/C/man7/pthreads.7:735
msgid ""
"When one thread creates a new child process using B<fork>(2), any thread "
"should be able to B<wait>(2)  on the child.  However, the implementation "
"only allows the thread that created the child to B<wait>(2)  on it."
msgstr ""
"あるスレッドが B<fork>(2)  を使って新しい子プロセスを作成した場合、 どのス"
"レッドでもこの子プロセスを B<wait>(2)  できるべきである。しかしながら、この実"
"装では子プロセスを作成した スレッドだけがこの子プロセスを B<wait>(2)  でき"
"る。"

#. type: Plain text
#: build/C/man7/pthreads.7:742
msgid ""
"When a thread calls B<execve>(2), all other threads are terminated (as "
"required by POSIX.1).  However, the resulting process has the same PID as "
"the thread that called B<execve>(2): it should have the same PID as the main "
"thread."
msgstr ""
"あるスレッドが B<execve>(2)  を呼び出した場合、他のスレッドは全て終了される "
"(POSIX.1 の仕様通り)。 しかしながら、新しいプロセスは B<execve>(2)  を呼んだ"
"スレッドと同じ PID を持つ。正しくは メインスレッドと同じ PID を持つべきであ"
"る。"

#. type: Plain text
#: build/C/man7/pthreads.7:749
msgid ""
"Threads do not share user and group IDs.  This can cause complications with "
"set-user-ID programs and can cause failures in Pthreads functions if an "
"application changes its credentials using B<seteuid>(2)  or similar."
msgstr ""
"スレッド間でユーザ ID とグループ ID が共有されない このことは、set-user-ID プ"
"ログラムで面倒な事態を招いたり、 アプリケーションが B<seteuid>(2)  などを使っ"
"て信用情報 (credentials) を変更した場合に Pthreads 関数が失敗する原因となる。"

#. type: Plain text
#: build/C/man7/pthreads.7:751
msgid "Threads do not share a common session ID and process group ID."
msgstr "スレッド間で共通のセッション ID やプロセスグループ ID を共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:754
msgid "Threads do not share record locks created using B<fcntl>(2)."
msgstr ""
"スレッド間で B<fcntl>(2)  を使って作成されるレコード・ロックを共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:760
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide."
msgstr ""
"B<times>(2)  と B<getrusage>(2)  が返す情報がプロセス全体の情報でなくスレッド"
"単位の情報である。"

#. type: Plain text
#: build/C/man7/pthreads.7:763
msgid "Threads do not share semaphore undo values (see B<semop>(2))."
msgstr "スレッド間でセマフォのアンドゥ値 (B<semop>(2)  参照) を共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:765
msgid "Threads do not share interval timers."
msgstr "スレッド間でインターバル・タイマを共有しない。"

#.  FIXME . bug report filed for NPTL nice nonconformance
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6258
#.  Sep 08: there is a patch by Denys Vlasenko to address this
#.  "make setpriority POSIX compliant; introduce PRIO_THREAD extension"
#.  Monitor this to see if it makes it into mainline.
#. type: Plain text
#: build/C/man7/pthreads.7:767 build/C/man7/pthreads.7:804
msgid "Threads do not share a common nice value."
msgstr "スレッドは共通の nice 値を共有しない。"

#. type: Plain text
#: build/C/man7/pthreads.7:777
msgid ""
"POSIX.1 distinguishes the notions of signals that are directed to the "
"process as a whole and signals that are directed to individual threads.  "
"According to POSIX.1, a process-directed signal (sent using B<kill>(2), for "
"example) should be handled by a single, arbitrarily selected thread within "
"the process.  LinuxThreads does not support the notion of process-directed "
"signals: signals may only be sent to specific threads."
msgstr ""
"POSXI.1 では、全体としてのプロセスに送られるシグナルと、 個別のスレッドに送ら"
"れるシグナルを区別して考えている。 POSIX.1 によると、プロセスに送られたシグナ"
"ル (例えば B<kill>(2)  を使って送る) は、そのプロセスに属すスレッドのうち 勝"
"手に (arbitrarily) に選択された一つのスレッドにより処理される ことになってい"
"る。LinuxThreads はプロセスに送られるシグナルの 概念に対応しておらず、シグナ"
"ルは特定のスレッドにだけ送ることができる。"

#. type: Plain text
#: build/C/man7/pthreads.7:786
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack.  "
"(A new thread should start with no alternate signal stack defined.  If two "
"threads handle signals on their shared alternate signal stack at the same "
"time, unpredictable program failures are likely to occur.)"
msgstr ""
"スレッドはそれぞれの独自の代替シグナルスタックの設定を持つ。 しかし、新しいス"
"レッドの代替シグナルスタックの設定は そのスレッドを作成したスレッドからコピー"
"され、そのため スレッドは最初は一つの代替シグナルスタックを共有する。 (仕様で"
"は、新しいスレッドは代替シグナルスタックが定義されていない状態 で開始されるべ"
"きとされている。 2つのスレッドが共有されている代替シグナルスタック上で同時に "
"シグナルの処理を行った場合、予測不可能なプログラムのエラーが 起こり得る。)"

#. type: SS
#: build/C/man7/pthreads.7:786
#, no-wrap
msgid "NPTL"
msgstr "NPTL"

#. type: Plain text
#: build/C/man7/pthreads.7:795
msgid ""
"With NPTL, all of the threads in a process are placed in the same thread "
"group; all members of a thread group share the same PID.  NPTL does not "
"employ a manager thread.  NPTL makes internal use of the first two real-time "
"signals (see also B<signal>(7)); these signals cannot be used in "
"applications."
msgstr ""
"NPTL では、一つのプロセスの全てのスレッドは同じスレッド・グループ に属する; "
"スレッド・グループの全メンバーは同じ PID を共有する。 NPTL は管理スレッド "
"(manager thread) を利用しない。 NPTL は内部でリアルタイムシグナルのうち最初"
"の 2つの番号を使用しており (B<signal>(7)  参照)、これらのシグナルはアプリケー"
"ションでは使用できない。"

#. type: Plain text
#: build/C/man7/pthreads.7:797
msgid "NPTL still has at least one nonconformance with POSIX.1:"
msgstr "NPTL にも POSIX.1 に準拠していない点が少なくとも一つある:"

#. type: Plain text
#: build/C/man7/pthreads.7:806
msgid "Some NPTL nonconformances only occur with older kernels:"
msgstr "NPTL の標準非準拠な点のうちいくつかは以前のカーネルでのみ発生する:"

#. type: Plain text
#: build/C/man7/pthreads.7:812
msgid ""
"The information returned by B<times>(2)  and B<getrusage>(2)  is per-thread "
"rather than process-wide (fixed in kernel 2.6.9)."
msgstr ""
"B<times>(2)  と B<getrusage>(2)  が返す情報がプロセス全体の情報でなくスレッド"
"単位の情報である (カーネル 2.6.9 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:814
msgid "Threads do not share resource limits (fixed in kernel 2.6.10)."
msgstr "スレッド間でリソース制限を共有しない (カーネル 2.6.10 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:816
msgid "Threads do not share interval timers (fixed in kernel 2.6.12)."
msgstr ""
"スレッド間でインターバル・タイマを共有しない (カーネル 2.6.12 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:820
msgid ""
"Only the main thread is permitted to start a new session using B<setsid>(2)  "
"(fixed in kernel 2.6.16)."
msgstr ""
"メインスレッドだけが B<setsid>(2)  を使って新しいセッションを開始することがで"
"きる (カーネル 2.6.16 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:825
msgid ""
"Only the main thread is permitted to make the process into a process group "
"leader using B<setpgid>(2)  (fixed in kernel 2.6.16)."
msgstr ""
"メインスレッドだけが B<setpgid>(2)  を使ってそのプロセスをプロセス・グルー"
"プ・リーダーにすることができる (カーネル 2.6.16 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:831
msgid ""
"Threads have distinct alternate signal stack settings.  However, a new "
"thread's alternate signal stack settings are copied from the thread that "
"created it, so that the threads initially share an alternate signal stack "
"(fixed in kernel 2.6.16)."
msgstr ""
"スレッドはそれぞれの独自の代替シグナルスタックの設定を持つ。 しかし、新しいス"
"レッドの代替シグナルスタックの設定は そのスレッドを作成したスレッドからコピー"
"され、そのため スレッドは最初は一つの代替シグナルスタックを共有する (カーネ"
"ル 2.6.16 で修正された)。"

#. type: Plain text
#: build/C/man7/pthreads.7:833
msgid "Note the following further points about the NPTL implementation:"
msgstr "NPTL の実装では以下の点についても注意すること:"

#. type: Plain text
#: build/C/man7/pthreads.7:847
msgid ""
"If the stack size soft resource limit (see the description of "
"B<RLIMIT_STACK> in B<setrlimit>(2))  is set to a value other than "
"I<unlimited>, then this value defines the default stack size for new "
"threads.  To be effective, this limit must be set before the program is "
"executed, perhaps using the I<ulimit -s> shell built-in command (I<limit "
"stacksize> in the C shell)."
msgstr ""
"スタックサイズのリソースのソフト・リミット (B<setrlimit>(2)  の "
"B<RLIMIT_STACK> の説明を参照) が I<unlimited> 以外の値に設定されている場合、"
"ソフト・リミットの値が 新しいスレッドのデフォルトのスタックサイズとなる。 設"
"定を有効にするためには、プログラムを実行する前にリミット値を 設定しておかなけ"
"ればならない。たいていは、シェルの組み込みコマンドの I<ulimit -s> (C シェルで"
"は I<limit stacksize>)  を使って設定する。"

#. type: SS
#: build/C/man7/pthreads.7:847
#, no-wrap
msgid "Determining the Threading Implementation"
msgstr "スレッド実装の判定"

#. type: Plain text
#: build/C/man7/pthreads.7:852
msgid ""
"Since glibc 2.3.2, the B<getconf>(1)  command can be used to determine the "
"system's threading implementation, for example:"
msgstr ""
"glibc 2.3.2 以降では、 B<getconf>(1)  コマンドを使って、 システムのスレッド実"
"装を判定することができる。 以下に例を示す:"

#. type: Plain text
#: build/C/man7/pthreads.7:857
#, no-wrap
msgid ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"
msgstr ""
"bash$ getconf GNU_LIBPTHREAD_VERSION\n"
"NPTL 2.3.4\n"

#. type: Plain text
#: build/C/man7/pthreads.7:862
msgid ""
"With older glibc versions, a command such as the following should be "
"sufficient to determine the default threading implementation:"
msgstr ""
"ぞれ以前の glibc のバージョンでは、以下のようなコマンドで デフォルトのスレッ"
"ド実装を判定することができる。"

#. type: Plain text
#: build/C/man7/pthreads.7:868
#, no-wrap
msgid ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|nptl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"
msgstr ""
"bash$ $( ldd /bin/ls | grep libc.so | awk \\(aq{print $3}\\(aq ) | \\e\n"
"                egrep -i \\(aqthreads|ntpl\\(aq\n"
"        Native POSIX Threads Library by Ulrich Drepper et al\n"

#. type: SS
#: build/C/man7/pthreads.7:870
#, no-wrap
msgid "Selecting the Threading Implementation: LD_ASSUME_KERNEL"
msgstr "スレッドの実装の選択: LD_ASSUME_KERNEL"

#. type: Plain text
#: build/C/man7/pthreads.7:885
msgid ""
"On systems with a glibc that supports both LinuxThreads and NPTL (i.e., "
"glibc 2.3.I<x>), the B<LD_ASSUME_KERNEL> environment variable can be used to "
"override the dynamic linker's default choice of threading implementation.  "
"This variable tells the dynamic linker to assume that it is running on top "
"of a particular kernel version.  By specifying a kernel version that does "
"not provide the support required by NPTL, we can force the use of "
"LinuxThreads.  (The most likely reason for doing this is to run a (broken) "
"application that depends on some nonconformant behavior in LinuxThreads.)  "
"For example:"
msgstr ""
"LinuxThreads と NPTL の両方をサポートしている glibc (glibc 2.3.I<x>) があるシ"
"ステムでは、 B<LD_ASSUME_KERNEL> 環境変数を使うことで、動的リンカがデフォルト"
"で 選択するスレッド実装を上書きすることができる。 この変数により、動的リンカ"
"が特定のバージョンのカーネル上で 動作していると仮定するように指定する。 NPTL "
"が必要とするサポート機能を提供していないカーネルバージョンを 指定することで、"
"強制的に LinuxThreads を使うことができる (このようなことをする最もありそうな"
"場面は、 LinuxThreads の標準非準拠な振舞いに依存する (壊れた) アプリケーショ"
"ン を動作させる場合だろう)。 以下に例を示す:"

#. type: Plain text
#: build/C/man7/pthreads.7:891
#, no-wrap
msgid ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|ntpl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"
msgstr ""
"bash$ $( LD_ASSUME_KERNEL=2.2.5 ldd /bin/ls | grep libc.so | \\e\n"
"                awk \\(aq{print $3}\\(aq ) | egrep -i \\(aqthreads|ntpl\\(aq\n"
"        linuxthreads-0.10 by Xavier Leroy\n"

#. type: Plain text
#: build/C/man7/pthreads.7:903
msgid ""
"B<clone>(2), B<futex>(2), B<gettid>(2), B<proc>(5), B<futex>(7), B<sigevent>"
"(7), B<signal>(7),"
msgstr ""
"B<clone>(2), B<futex>(2), B<gettid>(2), B<futex>(7), B<sigevent>(7), "
"B<signal>(7),"

#. type: Plain text
#: build/C/man7/pthreads.7:927
msgid ""
"and various Pthreads manual pages, for example: B<pthread_attr_init>(3), "
"B<pthread_atfork>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3), "
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3), "
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3), "
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3), "
"B<pthread_mutex_unlock>(3), B<pthread_once>(3), B<pthread_setcancelstate>"
"(3), B<pthread_setcanceltype>(3), B<pthread_setspecific>(3), "
"B<pthread_sigmask>(3), B<pthread_sigqueue>(3), and B<pthread_testcancel>(3)"
msgstr ""
"および Pthreads の各種マニュアルページ、例えば: B<pthread_attr_init>(3),\n"
"B<pthread_atfork>(3), B<pthread_cancel>(3), B<pthread_cleanup_push>(3),\n"
"B<pthread_cond_signal>(3), B<pthread_cond_wait>(3), B<pthread_create>(3),\n"
"B<pthread_detach>(3), B<pthread_equal>(3), B<pthread_exit>(3),\n"
"B<pthread_key_create>(3), B<pthread_kill>(3), B<pthread_mutex_lock>(3),\n"
"B<pthread_mutex_unlock>(3), B<pthread_once>(3),\n"
"B<pthread_setcancelstate>(3), B<pthread_setcanceltype>(3),\n"
"B<pthread_setspecific>(3), B<pthread_sigmask>(3), B<pthread_sigqueue>(3),\n"
"and B<pthread_testcancel>(3)"

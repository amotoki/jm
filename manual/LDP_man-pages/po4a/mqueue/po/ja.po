# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-04-17 13:14+0900\n"
"PO-Revision-Date: 2014-04-17 03:40+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/mq_close.3:26
#, no-wrap
msgid "MQ_CLOSE"
msgstr "MQ_CLOSE"

#. type: TH
#: build/C/man3/mq_close.3:26 build/C/man3/mq_getattr.3:26
#: build/C/man3/mq_unlink.3:26
#, no-wrap
msgid "2010-08-29"
msgstr "2010-08-29"

#. type: TH
#: build/C/man3/mq_close.3:26 build/C/man3/mq_getattr.3:26
#: build/C/man2/mq_getsetattr.2:26 build/C/man3/mq_notify.3:26
#: build/C/man3/mq_open.3:26 build/C/man7/mq_overview.7:26
#: build/C/man3/mq_receive.3:26 build/C/man3/mq_send.3:26
#: build/C/man3/mq_unlink.3:26 build/C/man2/msgctl.2:37
#: build/C/man2/msgget.2:35 build/C/man2/msgop.2:40
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: TH
#: build/C/man3/mq_close.3:26 build/C/man3/mq_getattr.3:26
#: build/C/man2/mq_getsetattr.2:26 build/C/man3/mq_notify.3:26
#: build/C/man3/mq_open.3:26 build/C/man7/mq_overview.7:26
#: build/C/man3/mq_receive.3:26 build/C/man3/mq_send.3:26
#: build/C/man3/mq_unlink.3:26 build/C/man2/msgctl.2:37
#: build/C/man2/msgget.2:35 build/C/man2/msgop.2:40
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/mq_close.3:27 build/C/man3/mq_getattr.3:27
#: build/C/man2/mq_getsetattr.2:27 build/C/man3/mq_notify.3:27
#: build/C/man3/mq_open.3:27 build/C/man7/mq_overview.7:27
#: build/C/man3/mq_receive.3:27 build/C/man3/mq_send.3:27
#: build/C/man3/mq_unlink.3:27 build/C/man2/msgctl.2:38
#: build/C/man2/msgget.2:36 build/C/man2/msgop.2:41
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/mq_close.3:29
msgid "mq_close - close a message queue descriptor"
msgstr "mq_close - メッセージキュー記述子をクローズする"

#. type: SH
#: build/C/man3/mq_close.3:29 build/C/man3/mq_getattr.3:29
#: build/C/man2/mq_getsetattr.2:29 build/C/man3/mq_notify.3:29
#: build/C/man3/mq_open.3:29 build/C/man3/mq_receive.3:29
#: build/C/man3/mq_send.3:29 build/C/man3/mq_unlink.3:29
#: build/C/man2/msgctl.2:40 build/C/man2/msgget.2:38 build/C/man2/msgop.2:43
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/mq_close.3:32 build/C/man3/mq_getattr.3:32
#: build/C/man3/mq_notify.3:32 build/C/man3/mq_receive.3:32
#: build/C/man3/mq_send.3:32 build/C/man3/mq_unlink.3:32
#, no-wrap
msgid "B<#include E<lt>mqueue.hE<gt>>\n"
msgstr "B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mq_close.3:34
#, no-wrap
msgid "B<int mq_close(mqd_t >I<mqdes>B<);>\n"
msgstr "B<int mq_close(mqd_t >I<mqdes>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_close.3:37 build/C/man3/mq_getattr.3:40
#: build/C/man3/mq_notify.3:37 build/C/man3/mq_open.3:41
#: build/C/man3/mq_receive.3:45 build/C/man3/mq_send.3:45
#: build/C/man3/mq_unlink.3:37
msgid "Link with I<-lrt>."
msgstr "I<-lrt> でリンクする。"

#. type: SH
#: build/C/man3/mq_close.3:37 build/C/man3/mq_getattr.3:40
#: build/C/man2/mq_getsetattr.2:40 build/C/man3/mq_notify.3:37
#: build/C/man3/mq_open.3:41 build/C/man7/mq_overview.7:29
#: build/C/man3/mq_receive.3:57 build/C/man3/mq_send.3:57
#: build/C/man3/mq_unlink.3:37 build/C/man2/msgctl.2:48
#: build/C/man2/msgget.2:46 build/C/man2/msgop.2:56
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/mq_close.3:41
msgid "B<mq_close>()  closes the message queue descriptor I<mqdes>."
msgstr ""
"B<mq_close>()  はメッセージキュー記述子 (message queue descriptor)  I<mqdes> "
"をクローズする。"

#. type: Plain text
#: build/C/man3/mq_close.3:47
msgid ""
"If the calling process has attached a notification request to this message "
"queue via I<mqdes>, then this request is removed, and another process can "
"now attach a notification request."
msgstr ""
"呼び出し元のプロセスが I<mqdes> 経由でこのメッセージキューに通知要求 "
"(notification request)  を設定している場合、通知要求は削除され、他のプロセス"
"がそのキューに 対して通知要求を設定できるようになる。"

#. type: SH
#: build/C/man3/mq_close.3:47 build/C/man3/mq_getattr.3:118
#: build/C/man3/mq_notify.3:134 build/C/man3/mq_open.3:123
#: build/C/man3/mq_receive.3:113 build/C/man3/mq_send.3:119
#: build/C/man3/mq_unlink.3:44 build/C/man2/msgctl.2:229
#: build/C/man2/msgget.2:137 build/C/man2/msgop.2:321
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/mq_close.3:53
msgid ""
"On success B<mq_close>()  returns 0; on error, -1 is returned, with I<errno> "
"set to indicate the error."
msgstr ""
"成功すると、 B<mq_close>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値を設定する。"

#. type: SH
#: build/C/man3/mq_close.3:53 build/C/man3/mq_getattr.3:126
#: build/C/man3/mq_notify.3:140 build/C/man3/mq_open.3:135
#: build/C/man3/mq_receive.3:122 build/C/man3/mq_send.3:127
#: build/C/man3/mq_unlink.3:50 build/C/man2/msgctl.2:254
#: build/C/man2/msgget.2:143 build/C/man2/msgop.2:334
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: TP
#: build/C/man3/mq_close.3:54 build/C/man3/mq_getattr.3:127
#: build/C/man3/mq_notify.3:141 build/C/man3/mq_receive.3:129
#: build/C/man3/mq_send.3:134
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man3/mq_close.3:59 build/C/man3/mq_getattr.3:132
#: build/C/man3/mq_notify.3:146
msgid "The descriptor specified in I<mqdes> is invalid."
msgstr "I<mqdes> に指定されたディスクリプタが不正である。"

#. type: SH
#: build/C/man3/mq_close.3:59 build/C/man3/mq_getattr.3:137
#: build/C/man2/mq_getsetattr.2:50 build/C/man3/mq_notify.3:174
#: build/C/man3/mq_open.3:224 build/C/man7/mq_overview.7:263
#: build/C/man3/mq_receive.3:156 build/C/man3/mq_send.3:161
#: build/C/man3/mq_unlink.3:62 build/C/man2/msgctl.2:325
#: build/C/man2/msgget.2:183 build/C/man2/msgop.2:464
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/mq_close.3:61 build/C/man3/mq_getattr.3:139
#: build/C/man3/mq_notify.3:176 build/C/man3/mq_open.3:226
#: build/C/man7/mq_overview.7:265 build/C/man3/mq_receive.3:158
#: build/C/man3/mq_send.3:163 build/C/man3/mq_unlink.3:64
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: SH
#: build/C/man3/mq_close.3:61 build/C/man3/mq_getattr.3:139
#: build/C/man2/mq_getsetattr.2:52 build/C/man7/mq_overview.7:265
#: build/C/man3/mq_receive.3:158 build/C/man3/mq_send.3:163
#: build/C/man2/msgctl.2:328 build/C/man2/msgget.2:185
#: build/C/man2/msgop.2:476
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/mq_close.3:65
msgid ""
"All open message queues are automatically closed on process termination, or "
"upon B<execve>(2)."
msgstr ""
"プロセス終了時、もしくは B<execve>(2)  実行時に、全てのオープンされたメッセー"
"ジキューは自動的にクローズされる。"

#. type: SH
#: build/C/man3/mq_close.3:65 build/C/man3/mq_getattr.3:147
#: build/C/man2/mq_getsetattr.2:56 build/C/man3/mq_notify.3:243
#: build/C/man3/mq_open.3:230 build/C/man7/mq_overview.7:281
#: build/C/man3/mq_receive.3:164 build/C/man3/mq_send.3:169
#: build/C/man3/mq_unlink.3:64 build/C/man2/msgctl.2:367
#: build/C/man2/msgget.2:230 build/C/man2/msgop.2:557
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/mq_close.3:73
msgid ""
"B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: SH
#: build/C/man3/mq_close.3:73 build/C/man3/mq_getattr.3:155
#: build/C/man2/mq_getsetattr.2:59 build/C/man3/mq_notify.3:252
#: build/C/man3/mq_open.3:238 build/C/man7/mq_overview.7:294
#: build/C/man3/mq_receive.3:173 build/C/man3/mq_send.3:178
#: build/C/man3/mq_unlink.3:72 build/C/man2/msgctl.2:374
#: build/C/man2/msgget.2:238 build/C/man2/msgop.2:563
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/mq_close.3:80 build/C/man3/mq_getattr.3:162
#: build/C/man2/mq_getsetattr.2:66 build/C/man3/mq_notify.3:259
#: build/C/man3/mq_open.3:245 build/C/man7/mq_overview.7:301
#: build/C/man3/mq_receive.3:180 build/C/man3/mq_send.3:185
#: build/C/man3/mq_unlink.3:79 build/C/man2/msgctl.2:381
#: build/C/man2/msgget.2:245 build/C/man2/msgop.2:570
#, fuzzy
#| msgid ""
#| "This page is part of release 3.63 of the Linux I<man-pages> project.  A "
#| "description of the project, and information about reporting bugs, can be "
#| "found at \\%http://www.kernel.org/doc/man-pages/."
msgid ""
"This page is part of release 3.64 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at \\%http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.63 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man3/mq_getattr.3:26
#, no-wrap
msgid "MQ_GETATTR"
msgstr "MQ_GETATTR"

#. type: Plain text
#: build/C/man3/mq_getattr.3:29
msgid "mq_getattr, mq_setattr - get/set message queue attributes"
msgstr "mq_getattr, mq_setattr - メッセージキューの属性を設定/取得する"

#. type: Plain text
#: build/C/man3/mq_getattr.3:34
#, no-wrap
msgid "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"
msgstr "B<int mq_getattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:37
#, no-wrap
msgid ""
"B<int mq_setattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""
"B<int mq_setattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:47
msgid ""
"B<mq_getattr>()  and B<mq_setattr>()  respectively retrieve and modify "
"attributes of the message queue referred to by the descriptor I<mqdes>."
msgstr ""
"B<mq_getattr>()  と B<mq_setattr>()  は、記述子 I<mqdes> で参照されるメッセー"
"ジキューの属性の取得と変更をそれぞれ行う。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:54
msgid ""
"B<mq_getattr>()  returns an I<mq_attr> structure in the buffer pointed by "
"I<attr>.  This structure is defined as:"
msgstr ""
"B<mq_getattr>()  は、 I<attr> が指すバッファに I<mq_attr> 構造体を格納して返"
"す。この構造体は以下のように定義されている:"

#. type: Plain text
#: build/C/man3/mq_getattr.3:63
#, no-wrap
msgid ""
"struct mq_attr {\n"
"    long mq_flags;       /* Flags: 0 or O_NONBLOCK */\n"
"    long mq_maxmsg;      /* Max. # of messages on queue */\n"
"    long mq_msgsize;     /* Max. message size (bytes) */\n"
"    long mq_curmsgs;     /* # of messages currently in queue */\n"
"};\n"
msgstr ""
"struct mq_attr {\n"
"    long mq_flags;       /* フラグ: 0 か O_NONBLOCK */\n"
"    long mq_maxmsg;      /* キューの最大メッセージ数 */\n"
"    long mq_msgsize;     /* 最大メッセージサイズ (バイト単位) */\n"
"    long mq_curmsgs;     /* キューに現在入っているメッセージ数 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mq_getattr.3:73
msgid ""
"The I<mq_flags> field contains flags associated with the open message queue "
"description.  This field is initialized when the queue is created by "
"B<mq_open>(3).  The only flag that can appear in this field is B<O_NONBLOCK>."
msgstr ""
"I<mq_flags> フィールドには、オープンメッセージキュー記述 (open message queue "
"description) に関連付けられているフラグが格納される。 このフィールドは "
"B<mq_open>(3)  でキューが作成される際に初期化される。 このフィールドに現れる"
"フラグは B<O_NONBLOCK> だけである。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:94
msgid ""
"The I<mq_maxmsg> and I<mq_msgsize> fields are set when the message queue is "
"created by B<mq_open>(3).  The I<mq_maxmsg> field is an upper limit on the "
"number of messages that may be placed on the queue using B<mq_send>(3).  The "
"I<mq_msgsize> field is an upper limit on the size of messages that may be "
"placed on the queue.  Both of these fields must have a value greater than "
"zero.  Two I</proc> files that place ceilings on the values for these fields "
"are described in B<mq_open>(3)."
msgstr ""
"I<mq_maxmsg> と I<mq_msgsize> フィールドは B<mq_open>(3)  でメッセージキュー"
"が作成される際にセットされる。 I<mq_maxmsg> フィールドは、 B<mq_send>(3)  を"
"使ってキューに入れることができるメッセージ数の上限である。 I<mq_msgsize> "
"フィールドは、キューに入れることができるメッセージの 上限サイズである。 これ"
"らのフィールドはどちらも 0 より大きな値でなければならない。 これらのフィール"
"ドに設定できる値の上限は I</proc> ファイルにより決まる。 I</proc> ファイルの"
"詳細は B<mq_open>(3)  に説明されている。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:98
msgid ""
"The I<mq_curmsgs> field returns the number of messages currently held in the "
"queue."
msgstr ""
"I<mq_curmsgs> フィールドはキューに現在格納されているメッセージ数を返す。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:118
msgid ""
"B<mq_setattr>()  sets message queue attributes using information supplied in "
"the I<mq_attr> structure pointed to by I<newattr>.  The only attribute that "
"can be modified is the setting of the B<O_NONBLOCK> flag in I<mq_flags>.  "
"The other fields in I<newattr> are ignored.  If the I<oldattr> field is not "
"NULL, then the buffer that it points to is used to return an I<mq_attr> "
"structure that contains the same information that is returned by "
"B<mq_getattr>()."
msgstr ""
"B<mq_setattr>()  は、 I<newattr> が指す I<mq_attr> 構造体で与えられた情報を"
"使って、メッセージキューの属性を設定する。 変更することができる属性は、 "
"I<mq_flags> の B<O_NONBLOCK> フラグの設定だけである。 I<newattr> の他のフィー"
"ルドは無視される。 I<oldattr> フィールドが NULL 以外の場合、 B<mq_getattr>"
"()  が返すのと同じ情報を格納した I<mq_attr> 構造体を I<oldattr> が指すバッ"
"ファに入れて返す。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:126
msgid ""
"On success B<mq_getattr>()  and B<mq_setattr>()  return 0; on error, -1 is "
"returned, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 I<mq_getattr ()> と I<mq_setattr ()> は 0 を返す。エラーの場"
"合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/mq_getattr.3:132 build/C/man3/mq_notify.3:150
#: build/C/man3/mq_open.3:156 build/C/man3/mq_receive.3:138
#: build/C/man3/mq_send.3:143 build/C/man2/msgctl.2:285
#: build/C/man2/msgop.2:365 build/C/man2/msgop.2:421
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man3/mq_getattr.3:137
msgid "I<newattr-E<gt>mq_flags> contained set bits other than B<O_NONBLOCK>."
msgstr ""
"I<newattr-E<gt>mq_flags> に B<O_NONBLOCK> 以外のビットがセットされていた。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:147
msgid ""
"On Linux, B<mq_getattr>()  and B<mq_setattr>()  are library functions "
"layered on top of the B<mq_getsetattr>(2)  system call."
msgstr ""
"Linux では、 B<mq_getattr>()  と B<mq_setattr>()  はライブラリ関数であり、 "
"B<mq_getsetattr>(2)  システムコールを用いて実装されている。"

#. type: Plain text
#: build/C/man3/mq_getattr.3:155
msgid ""
"B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>"
"(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_close>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>"
"(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man2/mq_getsetattr.2:26
#, no-wrap
msgid "MQ_GETSETATTR"
msgstr "MQ_GETSETATTR"

#. type: TH
#: build/C/man2/mq_getsetattr.2:26
#, no-wrap
msgid "2012-07-13"
msgstr "2012-07-13"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:29
msgid "mq_getsetattr - get/set message queue attributes"
msgstr "mq_getsetattr - メッセージキューの属性を設定/取得する"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:33
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:36
#, no-wrap
msgid ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"
msgstr ""
"B<int mq_getsetattr(mqd_t >I<mqdes>B<, struct mq_attr *>I<newattr>B<,>\n"
"B<                 struct mq_attr *>I<oldattr>B<);>\n"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:40
msgid "I<Note>: There is no glibc wrapper for this system call; see NOTES."
msgstr ""
"I<注>: このシステムコールには glibc のラッパー関数は存在しない。「注意」の節"
"を参照。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:42
msgid "Do not use this system call."
msgstr "このシステムコールを使用しないこと。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:50
msgid ""
"This is the low-level system call used to implement B<mq_getattr>(3)  and "
"B<mq_setattr>(3).  For an explanation of how this system call operates, see "
"the description of B<mq_setattr>(3)."
msgstr ""
"B<mq_getattr>(3)  と B<mq_setattr>(3)  の実装に使用される低レベルのシステム"
"コールである。 このシステムコールがどのように動作するかは B<mq_setattr>(3)  "
"の説明を参照のこと。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:52
msgid "This interface is nonstandard; avoid its use."
msgstr "このインタフェースは非標準である。使用を避けること。"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:56
msgid ""
"Glibc does not provide a wrapper for this system call; call it using "
"B<syscall>(2).  (Actually, never call it unless you are writing a C library!)"
msgstr ""
"glibc はこのシステムコールに対するラッパー関数を提供していない。 B<syscall>"
"(2)  を使って呼び出すこと。 (実のところ、C ライブラリを書いているのでない限"
"り、 決してこのシステムコールを呼び出さないこと!)"

#. type: Plain text
#: build/C/man2/mq_getsetattr.2:59
msgid "B<mq_getattr>(3), B<mq_overview>(7)"
msgstr "B<mq_getattr>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man3/mq_notify.3:26
#, no-wrap
msgid "MQ_NOTIFY"
msgstr "MQ_NOTIFY"

#. type: TH
#: build/C/man3/mq_notify.3:26
#, fuzzy, no-wrap
#| msgid "2014-01-05"
msgid "2014-04-06"
msgstr "2014-01-05"

#. type: Plain text
#: build/C/man3/mq_notify.3:29
msgid "mq_notify - register for notification when a message is available"
msgstr "mq_notify - メッセージ到着時に通知を行うよう登録する"

#. type: Plain text
#: build/C/man3/mq_notify.3:34
#, no-wrap
msgid "B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<sevp>B<);>\n"
msgstr "B<int mq_notify(mqd_t >I<mqdes>B<, const struct sigevent *>I<notification>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:43
msgid ""
"B<mq_notify>()  allows the calling process to register or unregister for "
"delivery of an asynchronous notification when a new message arrives on the "
"empty message queue referred to by the descriptor I<mqdes>."
msgstr ""
"B<mq_notify>()  を使うと、ディスクリプタ I<mqdes> で参照される空のメッセージ"
"キューに新しくメッセージが到着した時に 非同期の通知 (notification) の配送が行"
"われるように登録したり、 その解除を行ったりできる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:51
msgid ""
"The I<sevp> argument is a pointer to a I<sigevent> structure.  For the "
"definition and general details of this structure, see B<sigevent>(7)."
msgstr ""
"I<sevp> 引き数は I<sigevent> 構造体へのポインタである。 この構造体の定義と一"
"般的な詳細については B<sigevent>(7)  を参照。"

#. type: Plain text
#: build/C/man3/mq_notify.3:65
msgid ""
"If I<sevp> is a non-null pointer, then B<mq_notify>()  registers the calling "
"process to receive message notification.  The I<sigev_notify> field of the "
"I<sigevent> structure to which I<sevp> points specifies how notification is "
"to be performed.  This field has one of the following values:"
msgstr ""
"I<sevp> が NULL でないポインタであれば、 B<mq_notify>()  はメッセージ通知を受"
"け取るように呼び出し元のプロセスを登録する。 I<sevp> が指す I<sigevent> 構造"
"体の I<sigev_notify> フィールドは、どのような通知を行うのかを指定する。 この"
"フィールドは以下の値のいずれかを持つ。"

#. type: TP
#: build/C/man3/mq_notify.3:65
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#.  When is SIGEV_NONE useful?
#. type: Plain text
#: build/C/man3/mq_notify.3:70
msgid ""
"A \"null\" notification: the calling process is registered as the target for "
"notification, but when a message arrives, no notification is sent."
msgstr ""
"「空の (null)」の通知: 呼び出し元のプロセスを通知の宛先として登録するが、 実"
"際にはメッセージが到着した時に通知は送られない。"

#. type: TP
#: build/C/man3/mq_notify.3:70
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#.  I don't know of other implementations that set
#.  si_pid and si_uid -- MTK
#. type: Plain text
#: build/C/man3/mq_notify.3:90
msgid ""
"Notify the process by sending the signal specified in I<sigev_signo>.  See "
"B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_MESGQ>.  In addition, I<si_pid> "
"will be set to the PID of the process that sent the message, and I<si_uid> "
"will be set to the real user ID of the sending process."
msgstr ""
"I<sigev_signo> で指定されたシグナルを送って、プロセスに通知する。 一般的な詳"
"細については B<sigevent>(7)  を参照。 I<siginfo_t> 構造体の I<si_code> フィー"
"ルドには B<SI_MESGQ> が設定される。 さらに、 I<si_pid> にはメッセージを送信し"
"たプロセスの PID が、 I<si_uid> には送信プロセスの実ユーザ ID が設定される。"

#. type: TP
#: build/C/man3/mq_notify.3:90
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: build/C/man3/mq_notify.3:98
msgid ""
"Upon message delivery, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""
"メッセージの配送時には、 I<sigev_notify_function> があたかも新しいスレッドの"
"開始関数であるかのように起動される。 詳細は B<sigevent>(7)  を参照。"

#. type: Plain text
#: build/C/man3/mq_notify.3:101
msgid ""
"Only one process can be registered to receive notification from a message "
"queue."
msgstr ""
"一つのメッセージキューから通知を受信するように登録できるプロセスは 一つだけで"
"ある。"

#. type: Plain text
#: build/C/man3/mq_notify.3:108
msgid ""
"If I<sevp> is NULL, and the calling process is currently registered to "
"receive notifications for this message queue, then the registration is "
"removed; another process can then register to receive a message notification "
"for this queue."
msgstr ""
"I<sevp> が NULL で、かつ呼び出し元のプロセスがこのメッセージキューからの 通知"
"を受信するに現在登録している場合、登録を削除する。 これ以降、別のプロセスがこ"
"のメッセージキューから通知を受信するように 登録できるようになる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:115
msgid ""
"Message notification occurs only when a new message arrives and the queue "
"was previously empty.  If the queue was not empty at the time B<mq_notify>"
"()  was called, then a notification will occur only after the queue is "
"emptied and a new message arrives."
msgstr ""
"メッセージ通知は、それまで空のキューに新しいメッセージが到着した 場合にのみ行"
"われる。 B<mq_notify>()  が呼び出された時にそのキューが空でない場合、 その"
"キューが空になり、その後新しいメッセージが到着した時に 初めて通知が行われるこ"
"とになる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:123
msgid ""
"If another process or thread is waiting to read a message from an empty "
"queue using B<mq_receive>(3), then any message notification registration is "
"ignored: the message is delivered to the process or thread calling "
"B<mq_receive>(3), and the message notification registration remains in "
"effect."
msgstr ""
"別のプロセスやスレッドが B<mq_receive>(3)  を使って、空のキューからメッセージ"
"の読み出しを待っている場合、 メッセージ通知の登録は全て無視される。 メッセー"
"ジは B<mq_receive>(3)  を呼び出しているプロセスやスレッドに配送され、 メッ"
"セージ通知の登録は効力を持ったままとなる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:134
msgid ""
"Notification occurs once: after a notification is delivered, the "
"notification registration is removed, and another process can register for "
"message notification.  If the notified process wishes to receive the next "
"notification, it can use B<mq_notify>()  to request a further notification.  "
"This should be done before emptying all unread messages from the queue.  "
"(Placing the queue in nonblocking mode is useful for emptying the queue of "
"messages without blocking once it is empty.)"
msgstr ""
"通知は一度だけ行われる。通知が送られた後は、通知要求の登録は削除され、 別のプ"
"ロセスがメッセージ通知を受信するように登録できるようになる。 通知を受けたプロ"
"セスが次の通知も受信したい場合は、 B<mq_notify>()  を使ってその後の通知も受け"
"るように要求することができる。 B<mq_notify>()  を再度呼び出すのは、読み出して"
"いないメッセージを全部読み出して キューが空になる前にすべきである (キューから"
"のメッセージ読み出しをキューが空になった時に 停止 (block) せずに行うには、"
"キューを非停止モード (non-blocking mode)  に設定しておくとよい)。"

#. type: Plain text
#: build/C/man3/mq_notify.3:140
msgid ""
"On success B<mq_notify>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_notify>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"をエラーを示す値に設定する。"

#. type: TP
#: build/C/man3/mq_notify.3:146
#, no-wrap
msgid "B<EBUSY>"
msgstr "B<EBUSY>"

#. type: Plain text
#: build/C/man3/mq_notify.3:150
msgid ""
"Another process has already registered to receive notification for this "
"message queue."
msgstr ""
"別のプロセスがすでに このメッセージキューに対する通知を受信するように登録して"
"いる。"

#. type: Plain text
#: build/C/man3/mq_notify.3:160
msgid ""
"I<sevp-E<gt>sigev_notify> is not one of the permitted values; or I<sevp-"
"E<gt>sigev_notify> is B<SIGEV_SIGNAL> and I<sevp-E<gt>sigev_signo> is not a "
"valid signal number."
msgstr ""
"I<sevp-E<gt>sigev_notify> が許可された値のいずれでもない。もしくは I<sevp-"
"E<gt>sigev_notify> が B<SIGEV_SIGNAL> だが I<sevp-E<gt>sigev_signo> が有効な"
"シグナル番号ではない。"

#. type: TP
#: build/C/man3/mq_notify.3:160 build/C/man3/mq_open.3:214
#: build/C/man2/msgget.2:173 build/C/man2/msgop.2:376
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man3/mq_notify.3:163 build/C/man3/mq_open.3:217
msgid "Insufficient memory."
msgstr "十分なメモリがない。"

#.  Linux does not do this
#. type: Plain text
#: build/C/man3/mq_notify.3:174
msgid ""
"POSIX.1-2008 says that an implementation I<may> generate an B<EINVAL> error "
"if I<sevp> is NULL, and the caller is not currently registered to receive "
"notifications for the queue I<mqdes>."
msgstr ""
"POSIX.1-2008 では、 I<sevp> が NULL で、呼び出し元のプロセスがキュー "
"I<mqdes> に関する通知を受信するように登録されていない場合、エラー B<EINVAL> "
"を生成するような実装を行っても「よい」ことになっている。"

#. type: SH
#: build/C/man3/mq_notify.3:176 build/C/man7/mq_overview.7:278
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man3/mq_notify.3:182
msgid ""
"The following program registers a notification request for the message queue "
"named in its command-line argument.  Notification is performed by creating a "
"thread.  The thread executes a function which reads one message from the "
"queue and then terminates the process."
msgstr ""
"以下のプログラムは、 コマンドライン引き数で指定された名前のメッセージキューへ"
"の 通知要求を登録し、通知はスレッドの作成によって行われる。 そのスレッドは、"
"そのキューからメッセージを一つ読み出してから、 プロセスを終了する関数を実行す"
"る。"

#. type: SS
#: build/C/man3/mq_notify.3:182
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man3/mq_notify.3:189
#, no-wrap
msgid ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
msgstr ""
"#include E<lt>pthread.hE<gt>\n"
"#include E<lt>mqueue.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:192
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:200
#, no-wrap
msgid ""
"static void                     /* Thread start function */\n"
"tfunc(union sigval sv)\n"
"{\n"
"    struct mq_attr attr;\n"
"    ssize_t nr;\n"
"    void *buf;\n"
"    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"
msgstr ""
"static void                     /* スレッド開始関数 */\n"
"tfunc(union sigval sv)\n"
"{\n"
"    struct mq_attr attr;\n"
"    ssize_t nr;\n"
"    void *buf;\n"
"    mqd_t mqdes = *((mqd_t *) sv.sival_ptr);\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:202
#, no-wrap
msgid "    /* Determine max. msg size; allocate buffer to receive msg */\n"
msgstr ""
"    /* 最大メッセージサイズを決定し、\n"
"       メッセージ受信用のバッファを確保する */\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:208
#, no-wrap
msgid ""
"    if (mq_getattr(mqdes, &attr) == -1)\n"
"        handle_error(\"mq_getattr\");\n"
"    buf = malloc(attr.mq_msgsize);\n"
"    if (buf == NULL)\n"
"        handle_error(\"malloc\");\n"
msgstr ""
"    if (mq_getattr(mqdes, &attr) == -1)\n"
"        handle_error(\"mq_getattr\");\n"
"    buf = malloc(attr.mq_msgsize);\n"
"    if (buf == NULL)\n"
"        handle_error(\"malloc\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:212
#, no-wrap
msgid ""
"    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n"
"    if (nr == -1)\n"
"        handle_error(\"mq_receive\");\n"
msgstr ""
"    nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);\n"
"    if (nr == -1)\n"
"        handle_error(\"mq_receive\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:217
#, fuzzy, no-wrap
#| msgid ""
#| "    printf(\"Read %ld bytes from MQ\\en\", (long) nr);\n"
#| "    free(buf);\n"
#| "    exit(EXIT_SUCCESS);         /* Terminate the process */\n"
#| "}\n"
msgid ""
"    printf(\"Read %zd bytes from MQ\\en\", nr);\n"
"    free(buf);\n"
"    exit(EXIT_SUCCESS);         /* Terminate the process */\n"
"}\n"
msgstr ""
"    printf(\"Read %ld bytes from MQ\\en\", (long) nr);\n"
"    free(buf);\n"
"    exit(EXIT_SUCCESS);         /* プロセスを終了する */\n"
"}\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:223
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqdes;\n"
"    struct sigevent sev;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    mqd_t mqdes;\n"
"    struct sigevent sev;\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:228
#, no-wrap
msgid ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>mq-nameE<gt>\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:232
#, no-wrap
msgid ""
"    mqdes = mq_open(argv[1], O_RDONLY);\n"
"    if (mqdes == (mqd_t) -1)\n"
"        handle_error(\"mq_open\");\n"
msgstr ""
"    mqdes = mq_open(argv[1], O_RDONLY);\n"
"    if (mqdes == (mqd_t) -1)\n"
"        handle_error(\"mq_open\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:239
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_THREAD;\n"
"    sev.sigev_notify_function = tfunc;\n"
"    sev.sigev_notify_attributes = NULL;\n"
"    sev.sigev_value.sival_ptr = &mqdes;   /* Arg. to thread func. */\n"
"    if (mq_notify(mqdes, &sev) == -1)\n"
"        handle_error(\"mq_notify\");\n"
msgstr ""
"    sev.sigev_notify = SIGEV_THREAD;\n"
"    sev.sigev_notify_function = tfunc;\n"
"    sev.sigev_notify_attributes = NULL;\n"
"    sev.sigev_value.sival_ptr = &mqdes;   /* スレッド関数に渡す引き数 */\n"
"    if (mq_notify(mqdes, &sev) == -1)\n"
"        handle_error(\"mq_notify\");\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:242
#, no-wrap
msgid ""
"    pause();    /* Process will be terminated by thread function */\n"
"}\n"
msgstr ""
"    pause();    /* プロセスはスレッド関数により終了される */\n"
"}\n"

#. type: Plain text
#: build/C/man3/mq_notify.3:252
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>"
"(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_open>(3), B<mq_receive>(3), B<mq_send>"
"(3), B<mq_unlink>(3), B<mq_overview>(7), B<sigevent>(7)"

#. type: TH
#: build/C/man3/mq_open.3:26
#, no-wrap
msgid "MQ_OPEN"
msgstr "MQ_OPEN"

#. type: TH
#: build/C/man3/mq_open.3:26
#, no-wrap
msgid "2009-02-20"
msgstr "2009-02-20"

#. type: Plain text
#: build/C/man3/mq_open.3:29
msgid "mq_open - open a message queue"
msgstr "mq_open - メッセージキューをオープンする"

#. type: Plain text
#: build/C/man3/mq_open.3:34
#, no-wrap
msgid ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""
"B<#include E<lt>fcntl.hE<gt>>           /* For O_* constants */\n"
"B<#include E<lt>sys/stat.hE<gt>>        /* For mode constants */\n"
"B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mq_open.3:38
#, no-wrap
msgid ""
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\n"
"B<              struct mq_attr *>I<attr>B<);>\n"
msgstr ""
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<);>\n"
"B<mqd_t mq_open(const char *>I<name>B<, int >I<oflag>B<, mode_t >I<mode>B<,>\n"
"B<              struct mq_attr *>I<attr>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_open.3:50
msgid ""
"B<mq_open>()  creates a new POSIX message queue or opens an existing queue.  "
"The queue is identified by I<name>.  For details of the construction of "
"I<name>, see B<mq_overview>(7)."
msgstr ""
"B<mq_open>()  は、新しい POSIX メッセージキューを作成するか、既存のキューを "
"オープンする。キューは I<name> で識別される。 I<name> の構成の詳細については "
"B<mq_overview (7)> を参照。"

#. type: Plain text
#: build/C/man3/mq_open.3:58
msgid ""
"The I<oflag> argument specifies flags that control the operation of the "
"call.  (Definitions of the flags values can be obtained by including "
"I<E<lt>fcntl.hE<gt>>.)  Exactly one of the following must be specified in "
"I<oflag>:"
msgstr ""
"I<oflag> 引き数には、関数呼び出しの操作を制御するフラグを指定する (oflag の値"
"の定義は I<E<lt>fcntl.hE<gt>> のインクルードにより得られる)。 I<oflag> には、"
"以下のうちいずれか一つを必ず指定しなければならない。"

#. type: TP
#: build/C/man3/mq_open.3:58
#, no-wrap
msgid "B<O_RDONLY>"
msgstr "B<O_RDONLY>"

#. type: Plain text
#: build/C/man3/mq_open.3:61
msgid "Open the queue to receive messages only."
msgstr "メッセージの受信専用としてキューをオープンする。"

#. type: TP
#: build/C/man3/mq_open.3:61
#, no-wrap
msgid "B<O_WRONLY>"
msgstr "B<O_WRONLY>"

#. type: Plain text
#: build/C/man3/mq_open.3:64
msgid "Open the queue to send messages only."
msgstr "メッセージの送信専用としてキューをオープンする。"

#. type: TP
#: build/C/man3/mq_open.3:64
#, no-wrap
msgid "B<O_RDWR>"
msgstr "B<O_RDWR>"

#. type: Plain text
#: build/C/man3/mq_open.3:67
msgid "Open the queue to both send and receive messages."
msgstr "メッセージの送受信両用としてキューをオープンする。"

#. type: Plain text
#: build/C/man3/mq_open.3:72
msgid ""
"Zero or more of the following flags can additionally be I<OR>ed in I<oflag>:"
msgstr ""
"0 個以上の下記のフラグを、ビット単位の OR (論理和) で I<oflag> に追加で指定で"
"きる。"

#. type: TP
#: build/C/man3/mq_open.3:72
#, no-wrap
msgid "B<O_NONBLOCK>"
msgstr "B<O_NONBLOCK>"

#. type: Plain text
#: build/C/man3/mq_open.3:81
msgid ""
"Open the queue in nonblocking mode.  In circumstances where B<mq_receive>"
"(3)  and B<mq_send>(3)  would normally block, these functions instead fail "
"with the error B<EAGAIN>."
msgstr ""
"非停止 (nonblocking) モードでキューをオープンする。 B<mq_receive>(3)  と "
"B<mq_send>(3)  は、通常は停止 (block) する状況において、エラー B<EAGAIN> で失"
"敗するようになる。"

#. type: TP
#: build/C/man3/mq_open.3:81
#, no-wrap
msgid "B<O_CREAT>"
msgstr "B<O_CREAT>"

#.  In reality the filesystem IDs are used on Linux.
#. type: Plain text
#: build/C/man3/mq_open.3:89
msgid ""
"Create the message queue if it does not exist.  The owner (user ID) of the "
"message queue is set to the effective user ID of the calling process.  The "
"group ownership (group ID) is set to the effective group ID of the calling "
"process."
msgstr ""
"存在しない場合、メッセージキューを作成する。 メッセージキューの所有者 (ユー"
"ザ ID) とグループ所有権 (グループ ID) は、 それぞれ呼び出し元プロセスの実効"
"ユーザ ID と実効グループ ID に設定される。"

#. type: TP
#: build/C/man3/mq_open.3:89
#, no-wrap
msgid "B<O_EXCL>"
msgstr "B<O_EXCL>"

#. type: Plain text
#: build/C/man3/mq_open.3:99
msgid ""
"If B<O_CREAT> was specified in I<oflag>, and a queue with the given I<name> "
"already exists, then fail with the error B<EEXIST>."
msgstr ""
"B<O_CREAT> が I<oflag> に指定され、かつ指定された名前 I<name> を持つキューが"
"すでに存在する場合、エラー B<EEXIST> で失敗する。"

#. type: Plain text
#: build/C/man3/mq_open.3:123
msgid ""
"If B<O_CREAT> is specified in I<oflag>, then two additional arguments must "
"be supplied.  The I<mode> argument specifies the permissions to be placed on "
"the new queue, as for B<open>(2).  (Symbolic definitions for the permissions "
"bits can be obtained by including I<E<lt>sys/stat.hE<gt>>.)  The permissions "
"settings are masked against the process umask.  The I<attr> argument "
"specifies attributes for the queue.  See B<mq_getattr>(3)  for details.  If "
"I<attr> is NULL, then the queue is created with implementation-defined "
"default attributes."
msgstr ""
"I<oflag> に B<O_CREAT> を指定する場合、追加で 2つの引き数を与える必要があ"
"る。 I<mode> 引き数は、新しいキューに適用される許可設定 (permission) を、 "
"B<open>(2)  と同じように指定する (許可ビットのシンボル定義は I<E<lt>sys/stat."
"hE<gt>> のインクルードにより得られる)。 許可設定はプロセスの umask でマスクさ"
"れる。 I<attr> 引き数は、キューの属性を指定する。詳細は、 B<mq_getattr>(3)  "
"を参照。 I<attr> が NULL の場合、キューは実装で定義されたデフォルト属性で作成"
"される。"

#. type: Plain text
#: build/C/man3/mq_open.3:135
msgid ""
"On success, B<mq_open>()  returns a message queue descriptor for use by "
"other message queue functions.  On error, B<mq_open>()  returns I<(mqd_t)\\ "
"-1>, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_open>()  はメッセージキュー記述子 (message queue "
"descriptor) を返す。 メッセージキュー記述子は他のメッセージキュー関連の関数で"
"使用される。 エラーの場合、 B<mq_open>()  は I<(mqd_t)\\ -1> を返し、 "
"I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man3/mq_open.3:136 build/C/man3/mq_open.3:140
#: build/C/man3/mq_unlink.3:51 build/C/man2/msgctl.2:258
#: build/C/man2/msgget.2:147 build/C/man2/msgop.2:340 build/C/man2/msgop.2:395
#, no-wrap
msgid "B<EACCES>"
msgstr "B<EACCES>"

#. type: Plain text
#: build/C/man3/mq_open.3:140
msgid ""
"The queue exists, but the caller does not have permission to open it in the "
"specified mode."
msgstr ""
"キューは存在するが、呼び出し元が指定されたモードでそのキュー をオープンする許"
"可を持たない。"

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: build/C/man3/mq_open.3:145
msgid "I<name> contained more than one slash."
msgstr "I<name> にスラッシュが 2 個以上含まれていた。"

#. type: TP
#: build/C/man3/mq_open.3:145 build/C/man2/msgget.2:155
#, no-wrap
msgid "B<EEXIST>"
msgstr "B<EEXIST>"

#. type: Plain text
#: build/C/man3/mq_open.3:156
msgid ""
"Both B<O_CREAT> and B<O_EXCL> were specified in I<oflag>, but a queue with "
"this I<name> already exists."
msgstr ""
"I<oflag> に B<O_CREAT> と B<O_EXCL> の両方が指定されたが、指定された名前 "
"I<name> を持つキューがすでに存在する。"

#. type: Plain text
#: build/C/man3/mq_open.3:188
msgid ""
"B<O_CREAT> was specified in I<oflag>, and I<attr> was not NULL, but I<attr-"
"E<gt>mq_maxmsg> or I<attr-E<gt>mq_msqsize> was invalid.  Both of these "
"fields must be greater than zero.  In a process that is unprivileged (does "
"not have the B<CAP_SYS_RESOURCE> capability), I<attr-E<gt>mq_maxmsg> must be "
"less than or equal to the I<msg_max> limit, and I<attr-E<gt>mq_msgsize> must "
"be less than or equal to the I<msgsize_max> limit.  In addition, even in a "
"privileged process, I<attr-E<gt>mq_maxmsg> cannot exceed the B<HARD_MAX> "
"limit.  (See B<mq_overview>(7)  for details of these limits.)"
msgstr ""
"I<oflag> に B<O_CREAT> が指定され、かつ I<attr> が NULL 以外だが、 I<attr-"
"E<gt>mq_maxmsg> か I<attr-E<gt>mq_msqsize> が不正であった。 これらのフィール"
"ドは両方とも 0 より大きくなければならない。 プロセスが特権を持たない "
"(B<CAP_SYS_RESOURCE> ケーパビリティを持たない) 場合、 I<attr-E<gt>mq_maxmsg> "
"と I<attr-E<gt>mq_msgsize> は、それぞれ上限 I<msg_max>、 I<msgsize_max> 以下"
"でなければならない。 また、特権プロセスの場合でも、 I<attr-E<gt>mq_maxmsg> "
"は B<HARD_MAX> 上限を超えることはできない。 (これらの上限に関する詳細は "
"B<mq_overview>(7)  を参照。)"

#. type: TP
#: build/C/man3/mq_open.3:188
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man3/mq_open.3:192
msgid ""
"The process already has the maximum number of files and message queues open."
msgstr ""
"そのプロセスがオープンしているファイルとメッセージキューの数が プロセス毎の上"
"限に達している。"

#. type: TP
#: build/C/man3/mq_open.3:192 build/C/man3/mq_unlink.3:54
#, no-wrap
msgid "B<ENAMETOOLONG>"
msgstr "B<ENAMETOOLONG>"

#. type: Plain text
#: build/C/man3/mq_open.3:196 build/C/man3/mq_unlink.3:58
msgid "I<name> was too long."
msgstr "I<name> が長過ぎる。"

#. type: TP
#: build/C/man3/mq_open.3:196
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man3/mq_open.3:200
msgid ""
"The system limit on the total number of open files and message queues has "
"been reached."
msgstr ""
"システム全体でオープンしているファイルとメッセージキューの合計数が システム上"
"限に達している。"

#. type: TP
#: build/C/man3/mq_open.3:200 build/C/man3/mq_open.3:209
#: build/C/man3/mq_unlink.3:58 build/C/man2/msgget.2:165
#, no-wrap
msgid "B<ENOENT>"
msgstr "B<ENOENT>"

#. type: Plain text
#: build/C/man3/mq_open.3:209
msgid ""
"The B<O_CREAT> flag was not specified in I<oflag>, and no queue with this "
"I<name> exists."
msgstr ""
"B<O_CREAT> フラグが I<oflag> に指定されなかったが、指定された名前 I<name> を"
"持つキューが存在しない。"

#.  Note that this isn't consistent with the same case for sem_open()
#. type: Plain text
#: build/C/man3/mq_open.3:214
msgid "I<name> was just \"/\" followed by no other characters."
msgstr "I<name> が \"/\" だけで、その後ろに他の文字が続いていなかった。"

#. type: TP
#: build/C/man3/mq_open.3:217 build/C/man2/msgget.2:177
#, no-wrap
msgid "B<ENOSPC>"
msgstr "B<ENOSPC>"

#. type: Plain text
#: build/C/man3/mq_open.3:224
msgid ""
"Insufficient space for the creation of a new message queue.  This probably "
"occurred because the I<queues_max> limit was encountered; see B<mq_overview>"
"(7)."
msgstr ""
"新しいメッセージキューを作成するのに十分な空間がない。 このエラーはおそらく "
"I<queues_max> 上限に抵触したため起こったのだろう。 B<mq_overview>(7)  を参"
"照。"

#. type: SH
#: build/C/man3/mq_open.3:226 build/C/man2/msgget.2:224
#: build/C/man2/msgop.2:521
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man3/mq_open.3:230
msgid ""
"In kernels before 2.6.14, the process umask was not applied to the "
"permissions specified in I<mode>."
msgstr ""
"2.6.14 より前のカーネルには、 プロセスの umask が I<mode> で指定された許可設"
"定に適用されなかった。"

#. type: Plain text
#: build/C/man3/mq_open.3:238
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man7/mq_overview.7:26
#, no-wrap
msgid "MQ_OVERVIEW"
msgstr "MQ_OVERVIEW"

#. type: TH
#: build/C/man7/mq_overview.7:26
#, no-wrap
msgid "2009-09-27"
msgstr "2009-09-27"

#. type: Plain text
#: build/C/man7/mq_overview.7:29
msgid "mq_overview - overview of POSIX message queues"
msgstr "mq_overview - POSIX メッセージキューの概要"

#. type: Plain text
#: build/C/man7/mq_overview.7:37
msgid ""
"POSIX message queues allow processes to exchange data in the form of "
"messages.  This API is distinct from that provided by System V message "
"queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.), but provides "
"similar functionality."
msgstr ""
"POSIX メッセージキューを使用すると、プロセス間で メッセージの形でのデータのや"
"り取りを行うことができる。 この API は System V メッセージキューの API "
"(B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2)  など) とは異なるものだが、同様の機"
"能を提供する。"

#. type: Plain text
#: build/C/man7/mq_overview.7:52
msgid ""
"Message queues are created and opened using B<mq_open>(3); this function "
"returns a I<message queue descriptor> (I<mqd_t>), which is used to refer to "
"the open message queue in later calls.  Each message queue is identified by "
"a name of the form I</somename>; that is, a null-terminated string of up to "
"B<NAME_MAX> (i.e., 255) characters consisting of an initial slash, followed "
"by one or more characters, none of which are slashes.  Two processes can "
"operate on the same queue by passing the same name to B<mq_open>(3)."
msgstr ""
"メッセージキューの作成とオープンは B<mq_open>(3)  を使って行う。この関数は I<"
"メッセージキュー記述子 (message queue descriptor)> (I<mqd_t>)  を返す。これ以"
"降のコールでは、オープンされたメッセージキューは I<メッセージキュー記述子> を"
"使って参照される。 各メッセージキューは I</somename> の形の名前で区別すること"
"ができる。 その名前は、最大で B<NAME_MAX> (すなわち 255) 文字の NULL 終端され"
"た文字列で、 スラッシュで始まり、スラッシュ以外の文字が 1 文字以上続く形式で"
"ある。 B<mq_open>(3)  に同じ名前を渡すことで、2つのプロセスで同一のキューを "
"操作することができる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:68
msgid ""
"Messages are transferred to and from a queue using B<mq_send>(3)  and "
"B<mq_receive>(3).  When a process has finished using the queue, it closes it "
"using B<mq_close>(3), and when the queue is no longer required, it can be "
"deleted using B<mq_unlink>(3).  Queue attributes can be retrieved and (in "
"some cases) modified using B<mq_getattr>(3)  and B<mq_setattr>(3).  A "
"process can request asynchronous notification of the arrival of a message on "
"a previously empty queue using B<mq_notify>(3)."
msgstr ""
"メッセージのキューへの送受信は B<mq_send>(3)  と B<mq_receive>(3)  を使って行"
"う。プロセスがキューの使用を終えるときには、 B<mq_close>(3)  を使ってキューを"
"クローズする。キューがもはや不要となった場合には、 B<mq_unlink>(3)  を使って"
"キューを削除できる。キューの属性は B<mq_getattr>(3)  で取得でき、 (制限はある"
"が)  B<mq_setattr>(3)  で変更できる。 B<mq_notify>(3)  を使うことで、空の"
"キューへのメッセージ到着を非同期で 通知するように要求することもできる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:81
msgid ""
"A message queue descriptor is a reference to an I<open message queue "
"description> (cf.  B<open>(2)).  After a B<fork>(2), a child inherits copies "
"of its parent's message queue descriptors, and these descriptors refer to "
"the same open message queue descriptions as the corresponding descriptors in "
"the parent.  Corresponding descriptors in the two processes share the flags "
"(I<mq_flags>)  that are associated with the open message queue description."
msgstr ""
"メッセージキュー記述子は I<オープンメッセージキュー記述 (open message queue "
"description)> への参照である (B<open>(2)  も参照)。 B<fork>(2)  実行後は、子"
"プロセスは親プロセスのメッセージキュー記述子のコピーを継承する。 これらの記述"
"子は、親プロセスの対応する記述子と同じオープンメッセージキュー 記述を参照して"
"いる。親プロセスと子プロセスの対応する記述子は、フラグ (I<mq_flags>)  を共有"
"する。なぜなら、フラグはオープンメッセージキュー記述に 関連付けられているから"
"である。"

#. type: Plain text
#: build/C/man7/mq_overview.7:94
msgid ""
"Each message has an associated I<priority>, and messages are always "
"delivered to the receiving process highest priority first.  Message "
"priorities range from 0 (low) to I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> "
"(high).  On Linux, I<sysconf(_SC_MQ_PRIO_MAX)> returns 32768, but "
"POSIX.1-2001 requires only that an implementation support at least "
"priorities in the range 0 to 31; some implementations provide only this "
"range."
msgstr ""
"各メッセージにはそれぞれ I<優先度 (priority)> があり、メッセージの受信プロセ"
"スへの配送は常に 優先度の高いメッセージから順に行われる。 メッセージの優先度"
"は 0 (低優先) から I<sysconf(_SC_MQ_PRIO_MAX)\\ -\\ 1> (高優先) の値を持つ。 "
"Linux では、 I<sysconf(_SC_MQ_PRIO_MAX)> は 32768 を返すが、 POSIX.1-2001 で"
"要求されているのは最低限 0 から 31 までの優先度を実装することだけであり、実装"
"によってはこの範囲の優先度しかサポートされていない。"

#. type: Plain text
#: build/C/man7/mq_overview.7:97
msgid ""
"The remainder of this section describes some specific details of the Linux "
"implementation of POSIX message queues."
msgstr ""
"この節の残りでは、POSIX メッセージキューの Linux の実装の詳細 について説明す"
"る。"

#. type: SS
#: build/C/man7/mq_overview.7:97
#, no-wrap
msgid "Library interfaces and system calls"
msgstr "ライブラリインタフェースとシステムコール"

#. type: Plain text
#: build/C/man7/mq_overview.7:103
msgid ""
"In most cases the B<mq_*>()  library interfaces listed above are implemented "
"on top of underlying system calls of the same name.  Deviations from this "
"scheme are indicated in the following table:"
msgstr ""
"ほとんどの場合、上記の B<mq_*>() ライブラリインタフェースは、同じ名前の下位層"
"のシステムコールを 使って実装されている。この枠組みにあてはまらないものを 以"
"下の表に示す。"

#. type: tbl table
#: build/C/man7/mq_overview.7:107
#, no-wrap
msgid "Library interface\tSystem call\n"
msgstr "Library interface\tSystem call\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:108
#, no-wrap
msgid "mq_close(3)\tclose(2)\n"
msgstr "mq_close(3)\tclose(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:109
#, no-wrap
msgid "mq_getattr(3)\tmq_getsetattr(2)\n"
msgstr "mq_getattr(3)\tmq_getsetattr(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:110
#, no-wrap
msgid "mq_notify(3)\tmq_notify(2)\n"
msgstr "mq_notify(3)\tmq_notify(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:111
#, no-wrap
msgid "mq_open(3)\tmq_open(2)\n"
msgstr "mq_open(3)\tmq_open(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:112
#, no-wrap
msgid "mq_receive(3)\tmq_timedreceive(2)\n"
msgstr "mq_receive(3)\tmq_timedreceive(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:113
#, no-wrap
msgid "mq_send(3)\tmq_timedsend(2)\n"
msgstr "mq_send(3)\tmq_timedsend(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:114
#, no-wrap
msgid "mq_setattr(3)\tmq_getsetattr(2)\n"
msgstr "mq_setattr(3)\tmq_getsetattr(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:115
#, no-wrap
msgid "mq_timedreceive(3)\tmq_timedreceive(2)\n"
msgstr "mq_timedreceive(3)\tmq_timedreceive(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:116
#, no-wrap
msgid "mq_timedsend(3)\tmq_timedsend(2)\n"
msgstr "mq_timedsend(3)\tmq_timedsend(2)\n"

#. type: tbl table
#: build/C/man7/mq_overview.7:117
#, no-wrap
msgid "mq_unlink(3)\tmq_unlink(2)\n"
msgstr "mq_unlink(3)\tmq_unlink(2)\n"

#. type: SS
#: build/C/man7/mq_overview.7:120
#, no-wrap
msgid "Versions"
msgstr "バージョン"

#. type: Plain text
#: build/C/man7/mq_overview.7:123
msgid ""
"POSIX message queues have been supported on Linux since kernel 2.6.6.  Glibc "
"support has been provided since version 2.3.4."
msgstr ""
"Linux では POSIX メッセージキューはカーネル 2.6.6 以降でサポートされている。 "
"glibc ではバージョン 2.3.4 以降でサポートされている。"

#. type: SS
#: build/C/man7/mq_overview.7:123
#, no-wrap
msgid "Kernel configuration"
msgstr "カーネルの設定"

#. type: Plain text
#: build/C/man7/mq_overview.7:128
msgid ""
"Support for POSIX message queues is configurable via the "
"B<CONFIG_POSIX_MQUEUE> kernel configuration option.  This option is enabled "
"by default."
msgstr ""
"POSIX メッセージキューのサポートは、カーネルの設定 (configuration)  オプショ"
"ン B<CONFIG_POSIX_MQUEUE> で設定可能である。このオプションはデフォルトでは有"
"効である。"

#. type: SS
#: build/C/man7/mq_overview.7:128
#, no-wrap
msgid "Persistence"
msgstr "持続性"

#. type: Plain text
#: build/C/man7/mq_overview.7:133
msgid ""
"POSIX message queues have kernel persistence: if not removed by B<mq_unlink>"
"(3), a message queue will exist until the system is shut down."
msgstr ""
"POSIX メッセージキューはカーネル内で保持される。 B<mq_unlink>(3)  で削除され"
"なければ、メッセージキューは システムがシャットダウンされるまで存在し続ける。"

#. type: SS
#: build/C/man7/mq_overview.7:133
#, no-wrap
msgid "Linking"
msgstr "リンク"

#. type: Plain text
#: build/C/man7/mq_overview.7:138
msgid ""
"Programs using the POSIX message queue API must be compiled with I<cc -lrt> "
"to link against the real-time library, I<librt>."
msgstr ""
"POSIX メッセージキュー API を使用したプログラムは I<cc -lrt> でコンパイルし、"
"リアルタイムライブラリ I<librt> とリンクしなければならない。"

#. type: SS
#: build/C/man7/mq_overview.7:138
#, no-wrap
msgid "/proc interfaces"
msgstr "/proc インタフェース"

#. type: Plain text
#: build/C/man7/mq_overview.7:141
msgid ""
"The following interfaces can be used to limit the amount of kernel memory "
"consumed by POSIX message queues:"
msgstr ""
"以下のインタフェースを使って、POSIX メッセージキューが消費するカーネル メモリ"
"の量を制限することができる。"

#. type: TP
#: build/C/man7/mq_overview.7:141
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msg_max>"
msgstr "I</proc/sys/fs/mqueue/msg_max>"

#. type: Plain text
#: build/C/man7/mq_overview.7:162
msgid ""
"This file can be used to view and change the ceiling value for the maximum "
"number of messages in a queue.  This value acts as a ceiling on the I<attr-"
"E<gt>mq_maxmsg> argument given to B<mq_open>(3).  The default value for "
"I<msg_max> is 10.  The minimum value is 1 (10 in kernels before 2.6.28).  "
"The upper limit is B<HARD_MAX>: I<(131072\\ /\\ sizeof(void\\ *))> (32768 on "
"Linux/86).  This limit is ignored for privileged processes "
"(B<CAP_SYS_RESOURCE>), but the B<HARD_MAX> ceiling is nevertheless imposed."
msgstr ""
"このファイルを使って、一つのキューに入れられるメッセージの最大数の 上限値を参"
"照したり変更したりできる。この値は、 B<mq_open>(3)  に渡す I<attr-"
"E<gt>mq_maxmsg> 引き数に対する上限値として機能する。 I<msg_max> のデフォルト"
"値は 10 で、 最小値は 1 (2.6.28 より前のカーネルでは 10) である。 上限は「埋"
"め込みの固定値」 (B<HARD_MAX>)  で I<(131072\\ /\\ sizeof(void\\ *))> "
"(Linux/86 では 32768) である。 この上限は特権プロセス (B<CAP_SYS_RESOURCE>)  "
"では無視されるが、埋め込みの固定値による上限は どんな場合にでも適用される。"

#. type: TP
#: build/C/man7/mq_overview.7:162
#, no-wrap
msgid "I</proc/sys/fs/mqueue/msgsize_max>"
msgstr "I</proc/sys/fs/mqueue/msgsize_max>"

#. type: Plain text
#: build/C/man7/mq_overview.7:181
msgid ""
"This file can be used to view and change the ceiling on the maximum message "
"size.  This value acts as a ceiling on the I<attr-E<gt>mq_msgsize> argument "
"given to B<mq_open>(3).  The default value for I<msgsize_max> is 8192 "
"bytes.  The minimum value is 128 (8192 in kernels before 2.6.28).  The upper "
"limit for I<msgsize_max> is 1,048,576 (in kernels before 2.6.28, the upper "
"limit was B<INT_MAX>; that is, 2,147,483,647 on Linux/86).  This limit is "
"ignored for privileged processes (B<CAP_SYS_RESOURCE>)."
msgstr ""
"このファイルを使って、メッセージの最大サイズの上限値を\t 参照したり変更したり"
"できる。\t この値は、\t B<mq_open>(3)\t に渡す\t I<attr-E<gt>mq_msgsize> 引き"
"数に対する上限値として機能する。\t I<msgsize_max\t> のデフォルト値は 8192 バ"
"イトで、 最小値は 128 (2.6.28 より前のカーネルでは 8192) である。 "
"I<msgsize_max> の上限は 1,048,576 である (2.6.28 より前のカーネルでは、上限"
"は B<INT_MAX> (Linux/86 では 2,147,483,647) であった)。 この上限は特権プロセ"
"ス\t (B<CAP_SYS_RESOURCE>)\t では無視される。"

#. type: TP
#: build/C/man7/mq_overview.7:181
#, no-wrap
msgid "I</proc/sys/fs/mqueue/queues_max>"
msgstr "I</proc/sys/fs/mqueue/queues_max>"

#. type: Plain text
#: build/C/man7/mq_overview.7:191
msgid ""
"This file can be used to view and change the system-wide limit on the number "
"of message queues that can be created.  Only privileged processes "
"(B<CAP_SYS_RESOURCE>)  can create new message queues once this limit has "
"been reached.  The default value for I<queues_max> is 256; it can be changed "
"to any value in the range 0 to INT_MAX."
msgstr ""
"このファイルを使って、作成することができるメッセージキューの数に\t 対するシス"
"テム全体での制限を参照したり変更したりできる。\t 一度この上限に達すると、新し"
"いメッセージキューを作成できるのは\t 特権プロセス\t (B<CAP_SYS_RESOURCE>)\t "
"だけとなる。\t I<queues_max\t> のデフォルト値は 256 であり、\t 0 から "
"INT_MAX の範囲の任意の値に変更することができる。"

#. type: SS
#: build/C/man7/mq_overview.7:191
#, no-wrap
msgid "Resource limit"
msgstr "リソース制限"

#. type: Plain text
#: build/C/man7/mq_overview.7:198
msgid ""
"The B<RLIMIT_MSGQUEUE> resource limit, which places a limit on the amount of "
"space that can be consumed by all of the message queues belonging to a "
"process's real user ID, is described in B<getrlimit>(2)."
msgstr ""
"リソース上限 B<RLIMIT_MSGQUEUE> は、プロセスの実 UID に対応する全メッセージ"
"キューが消費する メモリ空間の量に対して上限を設定する。 B<getrlimit>(2)  を参"
"照。"

#. type: SS
#: build/C/man7/mq_overview.7:198
#, no-wrap
msgid "Mounting the message queue filesystem"
msgstr "メッセージキュー・ファイルシステムのマウント"

#. type: Plain text
#: build/C/man7/mq_overview.7:204
msgid ""
"On Linux, message queues are created in a virtual filesystem.  (Other "
"implementations may also provide such a feature, but the details are likely "
"to differ.)  This filesystem can be mounted (by the superuser) using the "
"following commands:"
msgstr ""
"Linux では、メッセージキューは仮想ファイルシステム内に作成される (他の実装で"
"も同様の機能が提供されているものもあるが、 詳細は違っているだろう)。 以下のコ"
"マンドを使うことで (スーパーユーザは)  このファイルシステムをマウントできる:"

#. type: Plain text
#: build/C/man7/mq_overview.7:209
#, no-wrap
msgid ""
"#B< mkdir /dev/mqueue>\n"
"#B< mount -t mqueue none /dev/mqueue>\n"
msgstr ""
"#B< mkdir /dev/mqueue>\n"
"#B< mount -t mqueue none /dev/mqueue>\n"

#. type: Plain text
#: build/C/man7/mq_overview.7:213
msgid "The sticky bit is automatically enabled on the mount directory."
msgstr ""
"マウントしたディレクトリのスティッキービット (sticky bit) は 自動的にオンとな"
"る。"

#. type: Plain text
#: build/C/man7/mq_overview.7:220
msgid ""
"After the filesystem has been mounted, the message queues on the system can "
"be viewed and manipulated using the commands usually used for files (e.g., "
"B<ls>(1)  and B<rm>(1))."
msgstr ""
"メッセージキュー・ファイルシステムのマウント後は、ファイルに対して 通常使うコ"
"マンド (例えば B<ls>(1)  や B<rm>(1))  を使って、システム上のメッセージキュー"
"を表示したり 操作したりできる。"

#. type: Plain text
#: build/C/man7/mq_overview.7:223
msgid ""
"The contents of each file in the directory consist of a single line "
"containing information about the queue:"
msgstr ""
"ディレクトリ内の各ファイルの内容は 1行であり、 キューに関する情報が表示され"
"る。"

#. type: Plain text
#: build/C/man7/mq_overview.7:228
#, no-wrap
msgid ""
"$B< cat /dev/mqueue/mymq>\n"
"QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"
msgstr ""
"$B< cat /dev/mqueue/mymq>\n"
"QSIZE:129     NOTIFY:2    SIGNO:0    NOTIFY_PID:8260\n"

#. type: Plain text
#: build/C/man7/mq_overview.7:232
msgid "These fields are as follows:"
msgstr "各フィールドの詳細は以下の通りである:"

#. type: TP
#: build/C/man7/mq_overview.7:232
#, no-wrap
msgid "B<QSIZE>"
msgstr "B<QSIZE>"

#. type: Plain text
#: build/C/man7/mq_overview.7:235
msgid "Number of bytes of data in all messages in the queue."
msgstr "キューに入っている全メッセージの合計バイト数。"

#. type: TP
#: build/C/man7/mq_overview.7:235
#, no-wrap
msgid "B<NOTIFY_PID>"
msgstr "B<NOTIFY_PID>"

#. type: Plain text
#: build/C/man7/mq_overview.7:241
msgid ""
"If this is nonzero, then the process with this PID has used B<mq_notify>(3)  "
"to register for asynchronous message notification, and the remaining fields "
"describe how notification occurs."
msgstr ""
"この値が 0 以外の場合、この値の PID を持つプロセスが B<mq_notify>(3)  を使っ"
"て、非同期のメッセージ通知を行うように設定したことを示す。 どのように通知が行"
"われるかは、以下のフィールドにより決定される。"

#. type: TP
#: build/C/man7/mq_overview.7:241
#, no-wrap
msgid "B<NOTIFY>"
msgstr "B<NOTIFY>"

#. type: Plain text
#: build/C/man7/mq_overview.7:251
msgid ""
"Notification method: 0 is B<SIGEV_SIGNAL>; 1 is B<SIGEV_NONE>; and 2 is "
"B<SIGEV_THREAD>."
msgstr ""
"通知方法: 0 は B<SIGEV_SIGNAL>; 1 は B<SIGEV_NONE>; 2 は B<SIGEV_THREAD>"

#. type: TP
#: build/C/man7/mq_overview.7:251
#, no-wrap
msgid "B<SIGNO>"
msgstr "B<SIGNO>"

#. type: Plain text
#: build/C/man7/mq_overview.7:255
msgid "Signal number to be used for B<SIGEV_SIGNAL>."
msgstr "B<SIGEV_SIGNAL> に使用されるシグナル番号。"

#. type: SS
#: build/C/man7/mq_overview.7:255
#, no-wrap
msgid "Polling message queue descriptors"
msgstr "メッセージキュー記述子のポーリング"

#. type: Plain text
#: build/C/man7/mq_overview.7:263
msgid ""
"On Linux, a message queue descriptor is actually a file descriptor, and can "
"be monitored using B<select>(2), B<poll>(2), or B<epoll>(7).  This is not "
"portable."
msgstr ""
"Linux では、メッセージキュー記述子は実際はファイル記述子 (file descriptor)  "
"であり、 B<select>(2), B<poll>(2), B<epoll>(7)  を使って監視することができ"
"る。 この機能の移植性はない。"

#. type: Plain text
#: build/C/man7/mq_overview.7:275
msgid ""
"System V message queues (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2), etc.) are "
"an older API for exchanging messages between processes.  POSIX message "
"queues provide a better designed interface than System V message queues; on "
"the other hand POSIX message queues are less widely available (especially on "
"older systems) than System V message queues."
msgstr ""
"System V メッセージキュー (B<msgget>(2), B<msgsnd>(2), B<msgrcv>(2)  など) は"
"プロセス間でメッセージをやり取りするための古い API である。 POSIX メッセージ"
"キューは System V メッセージキューよりもうまく 設計されたインタフェースを提供"
"している。 一方で、POSIX メッセージキューは System V メッセージキューと比べる"
"と 利用できるシステムが少ない (特に、古いシステムでは少ない)。"

#. type: Plain text
#: build/C/man7/mq_overview.7:278
msgid ""
"Linux does not currently (2.6.26) support the use of access control lists "
"(ACLs) for POSIX message queues."
msgstr ""
"現在のことろ (バージョン 2.6.26 時点)、 Linux は POSIX メッセージキューに対す"
"るアクセス制御リスト (ACL) に 対応していない。"

#. type: Plain text
#: build/C/man7/mq_overview.7:281
msgid ""
"An example of the use of various message queue functions is shown in "
"B<mq_notify>(3)."
msgstr ""
"各種のメッセージキュー関数を使用した例が B<mq_notify>(3)  に記載されている。"

#. type: Plain text
#: build/C/man7/mq_overview.7:294
msgid ""
"B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), B<mq_close>"
"(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7)"
msgstr ""
"B<getrlimit>(2), B<mq_getsetattr>(2), B<poll>(2), B<select>(2), B<mq_close>"
"(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_receive>(3), "
"B<mq_send>(3), B<mq_unlink>(3), B<epoll>(7)"

#. type: TH
#: build/C/man3/mq_receive.3:26
#, no-wrap
msgid "MQ_RECEIVE"
msgstr "MQ_RECEIVE"

#. type: TH
#: build/C/man3/mq_receive.3:26 build/C/man3/mq_send.3:26
#, no-wrap
msgid "2014-01-18"
msgstr "2014-01-18"

#. type: Plain text
#: build/C/man3/mq_receive.3:29
msgid "mq_receive, mq_timedreceive - receive a message from a message queue"
msgstr "mq_receive, mq_timedreceive - メッセージキューからメッセージを受信する"

#. type: Plain text
#: build/C/man3/mq_receive.3:35
#, no-wrap
msgid ""
"B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"
msgstr ""
"B<ssize_t mq_receive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:38 build/C/man3/mq_send.3:38
#, no-wrap
msgid ""
"B<#include E<lt>time.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"
msgstr ""
"B<#include E<lt>time.hE<gt>>\n"
"B<#include E<lt>mqueue.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:42
#, no-wrap
msgid ""
"B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\n"
"B<                   const struct timespec *>I<abs_timeout>B<);>\n"
msgstr ""
"B<ssize_t mq_timedreceive(mqd_t >I<mqdes>B<, char *>I<msg_ptr>B<,>\n"
"B<                   size_t >I<msg_len>B<, unsigned int *>I<msg_prio>B<,>\n"
"B<                   const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:50 build/C/man3/mq_send.3:50
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/mq_receive.3:53
msgid "B<mq_timedreceive>():"
msgstr "B<mq_timedreceive>():"

#. type: Plain text
#: build/C/man3/mq_receive.3:55 build/C/man3/mq_send.3:55
msgid "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"
msgstr "_XOPEN_SOURCE\\ E<gt>=\\ 600 || _POSIX_C_SOURCE\\ E<gt>=\\ 200112L"

#. type: Plain text
#: build/C/man3/mq_receive.3:76
msgid ""
"B<mq_receive>()  removes the oldest message with the highest priority from "
"the message queue referred to by the descriptor I<mqdes>, and places it in "
"the buffer pointed to by I<msg_ptr>.  The I<msg_len> argument specifies the "
"size of the buffer pointed to by I<msg_ptr>; this must be greater than or "
"equal to the I<mq_msgsize> attribute of the queue (see B<mq_getattr>(3)).  "
"If I<msg_prio> is not NULL, then the buffer to which it points is used to "
"return the priority associated with the received message."
msgstr ""
"B<mq_receive>()  は、記述子 I<mqdes> で参照されるメッセージキューから最も高い"
"優先度を持つ 最も古いメッセージを削除し、そのメッセージを I<msg_ptr> が指す"
"バッファに格納する。 I<msg_len> 引き数は、 I<msg_ptr> が指すバッファの大きさ"
"を示す。この値はキューの I<mq_msgsize> 属性以上でなければならない "
"(B<mq_getattr>(3)  参照)。 I<msg_prio> が NULL 以外の場合、 I<msg_prio> が指"
"すバッファに受信したメッセージの優先度が格納される。"

#. type: Plain text
#: build/C/man3/mq_receive.3:86
msgid ""
"If the queue is empty, then, by default, B<mq_receive>()  blocks until a "
"message becomes available, or the call is interrupted by a signal handler.  "
"If the B<O_NONBLOCK> flag is enabled for the message queue description, then "
"the call instead fails immediately with the error B<EAGAIN>."
msgstr ""
"キューが空の場合、デフォルトでは、 B<mq_receive>()  は、新しいメッセージが届"
"くか、関数呼び出しがシグナルハンドラにより 中断されるまで、停止 (block) す"
"る。 メッセージキュー記述 (message queue description) で B<O_NONBLOCK> フラグ"
"が有効になっている場合は、 B<mq_receive>()  はエラー B<EAGAIN> ですぐに失敗す"
"る。"

#. type: Plain text
#: build/C/man3/mq_receive.3:99
msgid ""
"B<mq_timedreceive>()  behaves just like B<mq_receive>(), except that if the "
"queue is empty and the B<O_NONBLOCK> flag is not enabled for the message "
"queue description, then I<abs_timeout> points to a structure which specifies "
"a ceiling on the time for which the call will block.  This ceiling is an "
"absolute timeout in seconds and nanoseconds since the Epoch, 1970-01-01 "
"00:00:00 +0000 (UTC), and it is specified in the following structure:"
msgstr ""
"B<mq_timedreceive>()  は B<mq_receive>()  と全く同じ動作をするが、 メッセージ"
"キューが空で、メッセージキュー記述で B<O_NONBLOCK> フラグが有効になっていない"
"場合に、この呼び出しが停止する時間の上限を I<abs_timeout> が指す構造体で指定"
"する点が異なる。この上限は、タイムアウトの時刻を、 時刻紀元 (Epoch; "
"1970-01-01 00:00:00 +0000 (UTC)) からの経過時間 (秒とナノ秒の組) で指定する。"
"タイムアウト時刻は以下の構造体で指定する:"

#. type: Plain text
#: build/C/man3/mq_receive.3:106 build/C/man3/mq_send.3:112
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;        /* seconds */\n"
"    long   tv_nsec;       /* nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;        /* 秒 */\n"
"    long   tv_nsec;       /* ナノ秒 */\n"
"};\n"

#. type: Plain text
#: build/C/man3/mq_receive.3:113
msgid ""
"If no message is available, and the timeout has already expired by the time "
"of the call, B<mq_timedreceive>()  returns immediately."
msgstr ""
"メッセージがキューになく、関数呼び出し時にすでにタイムアウト時刻が 過ぎている"
"場合、 B<mq_timedreceive>()  はすぐに返る。"

#. type: Plain text
#: build/C/man3/mq_receive.3:122
msgid ""
"On success, B<mq_receive>()  and B<mq_timedreceive>()  return the number of "
"bytes in the received message; on error, -1 is returned, with I<errno> set "
"to indicate the error."
msgstr ""
"成功すると、 B<mq_receive>()  と B<mq_timedreceive>()  は受信したメッセージの"
"バイト数を返す。 エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定す"
"る。"

#. type: TP
#: build/C/man3/mq_receive.3:123 build/C/man3/mq_send.3:128
#: build/C/man2/msgop.2:346 build/C/man2/msgop.2:401
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man3/mq_receive.3:129
msgid ""
"The queue was empty, and the B<O_NONBLOCK> flag was set for the message "
"queue description referred to by I<mqdes>."
msgstr ""
"キューが空で、かつ I<mqdes> で参照されるメッセージキュー記述で B<O_NONBLOCK> "
"フラグがセットされていた。"

#. type: Plain text
#: build/C/man3/mq_receive.3:134 build/C/man3/mq_send.3:139
msgid "The descriptor specified in I<mqdes> was invalid."
msgstr "I<mqdes> で指定された記述子が不正である。"

#. type: TP
#: build/C/man3/mq_receive.3:134 build/C/man3/mq_send.3:139
#: build/C/man2/msgop.2:362 build/C/man2/msgop.2:416
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man3/mq_receive.3:138 build/C/man3/mq_send.3:143
msgid "The call was interrupted by a signal handler; see B<signal>(7)."
msgstr "関数呼び出しがシグナルハンドラにより中断された。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man3/mq_receive.3:147 build/C/man3/mq_send.3:152
msgid ""
"The call would have blocked, and I<abs_timeout> was invalid, either because "
"I<tv_sec> was less than zero, or because I<tv_nsec> was less than zero or "
"greater than 1000 million."
msgstr ""
"関数呼び出しは停止するはずであったが、 I<abs_timeout> が不正であった。 "
"I<abs_timeout> が不正とは、 I<tv_sec> が 0 未満、もしくは I<tv_nsec> が 0 未"
"満か 1,000,000,000 より大きい、ということである。"

#. type: TP
#: build/C/man3/mq_receive.3:147 build/C/man3/mq_send.3:152
#, no-wrap
msgid "B<EMSGSIZE>"
msgstr "B<EMSGSIZE>"

#. type: Plain text
#: build/C/man3/mq_receive.3:153
msgid ""
"I<msg_len> was less than the I<mq_msgsize> attribute of the message queue."
msgstr "I<msg_len> がメッセージキューの I<mq_msgsize> 属性よりも小さかった。"

#. type: TP
#: build/C/man3/mq_receive.3:153 build/C/man3/mq_send.3:158
#, no-wrap
msgid "B<ETIMEDOUT>"
msgstr "B<ETIMEDOUT>"

#. type: Plain text
#: build/C/man3/mq_receive.3:156 build/C/man3/mq_send.3:161
msgid "The call timed out before a message could be transferred."
msgstr "メッセージが転送される前に関数呼び出しがタイムアウトした。"

#. type: Plain text
#: build/C/man3/mq_receive.3:164
msgid ""
"On Linux, B<mq_timedreceive>()  is a system call, and B<mq_receive>()  is a "
"library function layered on top of that system call."
msgstr ""
"Linux では、 B<mq_timedreceive>()  はシステムコールである。 B<mq_receive>()  "
"はライブラリ関数で、 B<mq_timedreceive>()  システムコールを用いて実装されてい"
"る。"

#. type: Plain text
#: build/C/man3/mq_receive.3:173
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_send>"
"(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), B<mq_send>"
"(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"

#. type: TH
#: build/C/man3/mq_send.3:26
#, no-wrap
msgid "MQ_SEND"
msgstr "MQ_SEND"

#. type: Plain text
#: build/C/man3/mq_send.3:29
msgid "mq_send, mq_timedsend - send a message to a message queue"
msgstr "mq_send, mq_timedsend - メッセージキューにメッセージを送信する"

#. type: Plain text
#: build/C/man3/mq_send.3:35
#, no-wrap
msgid ""
"B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"
msgstr ""
"B<int mq_send(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_send.3:42
#, no-wrap
msgid ""
"B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\n"
"B<              const struct timespec *>I<abs_timeout>B<);>\n"
msgstr ""
"B<int mq_timedsend(mqd_t >I<mqdes>B<, const char *>I<msg_ptr>B<,>\n"
"B<              size_t >I<msg_len>B<, unsigned int >I<msg_prio>B<,>\n"
"B<              const struct timespec *>I<abs_timeout>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_send.3:53
msgid "B<mq_timedsend>():"
msgstr "B<mq_timedsend>():"

#. type: Plain text
#: build/C/man3/mq_send.3:71
msgid ""
"B<mq_send>()  adds the message pointed to by I<msg_ptr> to the message queue "
"referred to by the descriptor I<mqdes>.  The I<msg_len> argument specifies "
"the length of the message pointed to by I<msg_ptr>; this length must be less "
"than or equal to the queue's I<mq_msgsize> attribute.  Zero-length messages "
"are allowed."
msgstr ""
"B<mq_send>()  は、記述子 I<mqdes> で参照されるメッセージキューに I<msg_ptr> "
"が指すメッセージを追加する。 I<msg_len> 引き数は、 I<msg_ptr> が指すメッセー"
"ジの長さを示す。この長さはキューの I<mq_msgsize> 属性以下でなければならな"
"い。 長さが 0 のメッセージも認められている。"

#. type: Plain text
#: build/C/man3/mq_send.3:79
msgid ""
"The I<msg_prio> argument is a nonnegative integer that specifies the "
"priority of this message.  Messages are placed on the queue in decreasing "
"order of priority, with newer messages of the same priority being placed "
"after older messages with the same priority."
msgstr ""
"I<msg_prio> 引き数は、メッセージの優先度を指定する負でない整数である。 メッ"
"セージは優先度の降順でキューに格納され、同じ優先度の新しいメッセージは 同じ優"
"先度の古いメッセージの後ろに格納される。"

#. type: Plain text
#: build/C/man3/mq_send.3:92
msgid ""
"If the message queue is already full (i.e., the number of messages on the "
"queue equals the queue's I<mq_maxmsg> attribute), then, by default, "
"B<mq_send>()  blocks until sufficient space becomes available to allow the "
"message to be queued, or until the call is interrupted by a signal handler.  "
"If the B<O_NONBLOCK> flag is enabled for the message queue description, then "
"the call instead fails immediately with the error B<EAGAIN>."
msgstr ""
"メッセージキューがすでに一杯の場合 (すなわち、キューに入っているメッセージ数"
"がキューの I<mq_maxmsg> 属性と等しい場合)、デフォルトでは、 B<mq_send ()> "
"は、メッセージをキューイングするのに十分な空間ができるか、 関数呼び出しがシグ"
"ナルハンドラにより中断されるまで、停止 (block) する。 メッセージキュー記述 "
"(message queue description) で B<O_NONBLOCK> フラグが有効になっている場合"
"は、 B<mq_send>()  はエラー B<EAGAIN> ですぐに失敗する。"

#. type: Plain text
#: build/C/man3/mq_send.3:105
msgid ""
"B<mq_timedsend>()  behaves just like B<mq_send>(), except that if the queue "
"is full and the B<O_NONBLOCK> flag is not enabled for the message queue "
"description, then I<abs_timeout> points to a structure which specifies a "
"ceiling on the time for which the call will block.  This ceiling is an "
"absolute timeout in seconds and nanoseconds since the Epoch, 1970-01-01 "
"00:00:00 +0000 (UTC), and it is specified in the following structure:"
msgstr ""
"B<mq_timedsend>()  は B<mq_send>()  と全く同じ動作をするが、 メッセージキュー"
"が一杯で、メッセージキュー記述で B<O_NONBLOCK> フラグが有効になっていない場合"
"に、この呼び出しが停止する時間の上限を I<abs_timeout> が指す構造体で指定する"
"点が異なる。この上限は、タイムアウトの時刻を 時刻紀元 (Epoch; 1970-01-01 "
"00:00:00 +0000 (UTC)) からの経過時間 (秒とナノ秒の組) で指定する。タイムアウ"
"ト時刻は以下の構造体で指定する:"

#. type: Plain text
#: build/C/man3/mq_send.3:119
msgid ""
"If the message queue is full, and the timeout has already expired by the "
"time of the call, B<mq_timedsend>()  returns immediately."
msgstr ""
"メッセージキューが一杯で、関数呼び出し時にすでにタイムアウト時刻が 過ぎている"
"場合、 B<mq_timedsend>()  はすぐに返る。"

#. type: Plain text
#: build/C/man3/mq_send.3:127
msgid ""
"On success, B<mq_send>()  and B<mq_timedsend>()  return zero; on error, -1 "
"is returned, with I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_send>()  と B<mq_timedsend>()  は 0 を返す。 エラーの場"
"合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/mq_send.3:134
msgid ""
"The queue was full, and the B<O_NONBLOCK> flag was set for the message queue "
"description referred to by I<mqdes>."
msgstr ""
"キューが一杯で、かつ I<mqdes> で参照されるメッセージキュー記述で "
"B<O_NONBLOCK> フラグがセットされていた。"

#. type: Plain text
#: build/C/man3/mq_send.3:158
msgid ""
"I<msg_len> was greater than the I<mq_msgsize> attribute of the message queue."
msgstr "I<msg_len> がメッセージキューの I<mq_msgsize> 属性よりも大きかった。"

#. type: Plain text
#: build/C/man3/mq_send.3:169
msgid ""
"On Linux, B<mq_timedsend>()  is a system call, and B<mq_send>()  is a "
"library function layered on top of that system call."
msgstr ""
"Linux では、 B<mq_timedsend>()  はシステムコールである。 B<mq_send>()  はライ"
"ブラリ関数で、 B<mq_timedsend>()  システムコールを用いて実装されている。"

#. type: Plain text
#: build/C/man3/mq_send.3:178
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_unlink>(3), B<mq_overview>(7), B<time>(7)"

#. type: TH
#: build/C/man3/mq_unlink.3:26
#, no-wrap
msgid "MQ_UNLINK"
msgstr "MQ_UNLINK"

#. type: Plain text
#: build/C/man3/mq_unlink.3:29
msgid "mq_unlink - remove a message queue"
msgstr "mq_unlink - メッセージキューを削除する"

#. type: Plain text
#: build/C/man3/mq_unlink.3:34
#, no-wrap
msgid "B<int mq_unlink(const char *>I<name>B<);>\n"
msgstr "B<int mq_unlink(const char *>I<name>B<);>\n"

#. type: Plain text
#: build/C/man3/mq_unlink.3:44
msgid ""
"B<mq_unlink>()  removes the specified message queue I<name>.  The message "
"queue name is removed immediately.  The queue itself is destroyed once any "
"other processes that have the queue open close their descriptors referring "
"to the queue."
msgstr ""
"B<mq_unlink>()  は指定されたメッセージキュー I<name> を削除する。 メッセージ"
"キュー名は直ちに削除される。 キュー自体は、そのキューをオープンした他のすべて"
"のプロセスが そのキューを参照する記述子をクローズした時点で破棄される。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:50
msgid ""
"On success B<mq_unlink>()  returns 0; on error, -1 is returned, with "
"I<errno> set to indicate the error."
msgstr ""
"成功すると、 B<mq_unlink>()  は 0 を返す。エラーの場合、-1 を返し、 I<errno> "
"にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:54
msgid "The caller does not have permission to unlink this message queue."
msgstr ""
"呼び出し元プロセスがこのメッセージキューを削除 (unlink) する 許可を持たない。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:62
msgid "There is no message queue with the given I<name>."
msgstr "指定された名前 I<name> を持つメッセージキューが存在しない。"

#. type: Plain text
#: build/C/man3/mq_unlink.3:72
msgid ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"
msgstr ""
"B<mq_close>(3), B<mq_getattr>(3), B<mq_notify>(3), B<mq_open>(3), "
"B<mq_receive>(3), B<mq_send>(3), B<mq_overview>(7)"

#. type: TH
#: build/C/man2/msgctl.2:37
#, no-wrap
msgid "MSGCTL"
msgstr "MSGCTL"

#. type: TH
#: build/C/man2/msgctl.2:37
#, no-wrap
msgid "2014-02-24"
msgstr "2014-02-24"

#. type: Plain text
#: build/C/man2/msgctl.2:40
msgid "msgctl - System V message control operations"
msgstr "msgctl - System V メッセージ制御操作"

#. type: Plain text
#: build/C/man2/msgctl.2:45 build/C/man2/msgget.2:43 build/C/man2/msgop.2:48
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/ipc.hE<gt>>\n"
"B<#include E<lt>sys/msg.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/msgctl.2:47
#, no-wrap
msgid "B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"
msgstr "B<int msgctl(int >I<msqid>B<, int >I<cmd>B<, struct msqid_ds *>I<buf>B<);>\n"

#. type: Plain text
#: build/C/man2/msgctl.2:54
msgid ""
"B<msgctl>()  performs the control operation specified by I<cmd> on the "
"System V message queue with identifier I<msqid>."
msgstr ""
"B<msgctl>()  はメッセージ・キュー識別子 I<msqid> で指定された System V メッ"
"セージ・キュー (message queue) に対して I<cmd> で指定された制御操作を行なう。"

#. type: Plain text
#: build/C/man2/msgctl.2:58
msgid ""
"The I<msqid_ds> data structure is defined in I<E<lt>sys/msg.hE<gt>> as "
"follows:"
msgstr ""
"I<msqid_ds> データ構造体は I<E<lt>sys/msg.hE<gt>> で以下のように定義されてい"
"る:"

#. type: Plain text
#: build/C/man2/msgctl.2:75
#, no-wrap
msgid ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;     /* Ownership and permissions */\n"
"    time_t          msg_stime;    /* Time of last msgsnd(2) */\n"
"    time_t          msg_rtime;    /* Time of last msgrcv(2) */\n"
"    time_t          msg_ctime;    /* Time of last change */\n"
"    unsigned long   __msg_cbytes; /* Current number of bytes in\n"
"                                     queue (nonstandard) */\n"
"    msgqnum_t       msg_qnum;     /* Current number of messages\n"
"                                     in queue */\n"
"    msglen_t        msg_qbytes;   /* Maximum number of bytes\n"
"                                     allowed in queue */\n"
"    pid_t           msg_lspid;    /* PID of last msgsnd(2) */\n"
"    pid_t           msg_lrpid;    /* PID of last msgrcv(2) */\n"
"};\n"
msgstr ""
"struct msqid_ds {\n"
"    struct ipc_perm msg_perm;     /* 所有権と許可 */\n"
"    time_t          msg_stime;    /* 最後の msgsnd(2) の時刻 */\n"
"    time_t          msg_rtime;    /* 最後の msgrcv(2) の時刻 */\n"
"    time_t          msg_ctime;    /* 最後に変更が行われた時刻 */\n"
"    unsigned long   __msg_cbytes; /* キューにある現在のバイト数\n"
"                                     (非標準) */\n"
"    msgqnum_t       msg_qnum;     /* キューにある現在入っている\n"
"                                     メッセージの数 */\n"
"    msglen_t        msg_qbytes;   /* キューに許可されている\n"
"                                     最大バイト数 */\n"
"    pid_t           msg_lspid;    /* 最後の msgsnd(2) の PID */\n"
"    pid_t           msg_lrpid;    /* 最後の msgrcv(2) の PID */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgctl.2:83
msgid ""
"The I<ipc_perm> structure is defined as follows (the highlighted fields are "
"settable using B<IPC_SET>):"
msgstr ""
"I<ipc_perm> 構造体は以下のように定義されている (強調されたフィールドは "
"B<IPC_SET> を使って設定可能である):"

#. type: Plain text
#: build/C/man2/msgctl.2:95
#, no-wrap
msgid ""
"struct ipc_perm {\n"
"    key_t          __key;       /* Key supplied to msgget(2) */\n"
"    uid_t          B<uid>;         /* Effective UID of owner */\n"
"    gid_t          B<gid>;         /* Effective GID of owner */\n"
"    uid_t          cuid;        /* Effective UID of creator */\n"
"    gid_t          cgid;        /* Effective GID of creator */\n"
"    unsigned short B<mode>;        /* Permissions */\n"
"    unsigned short __seq;       /* Sequence number */\n"
"};\n"
msgstr ""
"struct ipc_perm {\n"
"    key_t          __key;       /* msgget(2) に与えるキー */\n"
"    uid_t          B<uid>;         /* 所有者の実効 UID */\n"
"    gid_t          B<gid>;         /* 所有者の実効 GID */\n"
"    uid_t          cuid;        /* 作成者の実効 UID */\n"
"    gid_t          cgid;        /* 作成者の実効 GID */\n"
"    unsigned short B<mode>;        /* 許可 */\n"
"    unsigned short __seq;       /* シーケンス番号 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgctl.2:101
msgid "Valid values for I<cmd> are:"
msgstr "I<cmd> として有効な値は:"

#. type: TP
#: build/C/man2/msgctl.2:101
#, no-wrap
msgid "B<IPC_STAT>"
msgstr "B<IPC_STAT>"

#. type: Plain text
#: build/C/man2/msgctl.2:110
msgid ""
"Copy information from the kernel data structure associated with I<msqid> "
"into the I<msqid_ds> structure pointed to by I<buf>.  The caller must have "
"read permission on the message queue."
msgstr ""
"I<msqid> に関連づけられたメッセージ・キュー・データ構造体から、ポインタ "
"I<buf> が指し示す I<msqid_ds> 構造体に情報をコピーする。 呼び出し側はメッセー"
"ジ・キューに対する読み込み許可を持っていなければならない。"

#. type: TP
#: build/C/man2/msgctl.2:110
#, no-wrap
msgid "B<IPC_SET>"
msgstr "B<IPC_SET>"

#. type: Plain text
#: build/C/man2/msgctl.2:137
msgid ""
"Write the values of some members of the I<msqid_ds> structure pointed to by "
"I<buf> to the kernel data structure associated with this message queue, "
"updating also its I<msg_ctime> member.  The following members of the "
"structure are updated: I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid>, and "
"(the least significant 9 bits of)  I<msg_perm.mode>.  The effective UID of "
"the calling process must match the owner (I<msg_perm.uid>)  or creator "
"(I<msg_perm.cuid>)  of the message queue, or the caller must be privileged.  "
"Appropriate privilege (Linux: the B<CAP_SYS_RESOURCE> capability) is "
"required to raise the I<msg_qbytes> value beyond the system parameter "
"B<MSGMNB>."
msgstr ""
"ポインタ I<buf> が指し示す I<msqid_ds> 構造体のメンバーの値を、メッセージ・"
"キューに関連づけられた カーネル・データ構造体に書き込み、 I<msg_ctime> メン"
"バーも更新する。 構造体のメンバーのうち、更新されるものを以下に示す: "
"I<msg_qbytes>, I<msg_perm.uid>, I<msg_perm.gid>, I<msg_perm.mode> (の下位 9 "
"ビット)。 呼び出したプロセスの実効ユーザ ID が、メッセージ・キューの所有者 "
"(I<msg_perm.uid>)  または作成者 (I<msg_perm.cuid>)  と一致するか、呼び出し元"
"が特権を持たなければならない。 I<msg_qbytes> をシステム・パラメータの "
"B<MSGMNB> を超えて設定するには、適切な特権 (Linux では B<CAP_SYS_RESOURCE> "
"ケーパビリティ (capability)) が必要である。"

#. type: TP
#: build/C/man2/msgctl.2:137
#, no-wrap
msgid "B<IPC_RMID>"
msgstr "B<IPC_RMID>"

#. type: Plain text
#: build/C/man2/msgctl.2:151
msgid ""
"Immediately remove the message queue, awakening all waiting reader and "
"writer processes (with an error return and I<errno> set to B<EIDRM>).  The "
"calling process must have appropriate privileges or its effective user ID "
"must be either that of the creator or owner of the message queue.  The third "
"argument to B<msgctl>()  is ignored in this case."
msgstr ""
"メッセージ・キューをただちに削除する。 同時にその構造体の読み書きの待ち状態に"
"あったプロセスに通知する (エラーが返り、 I<errno> が B<EIDRM> に設定され"
"る)。 呼び出したプロセスが適切な特権を持っているか、 呼び出したプロセスの実効"
"ユーザ ID がメッセージ・キューの作成者か 所有者の実効ユーザ ID でなければなら"
"ない。この場合、 B<msgctl>() の第 3 引き数は無視される。"

#. type: TP
#: build/C/man2/msgctl.2:151
#, no-wrap
msgid "B<IPC_INFO> (Linux-specific)"
msgstr "B<IPC_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/msgctl.2:164
msgid ""
"Returns information about system-wide message queue limits and parameters in "
"the structure pointed to by I<buf>.  This structure is of type I<msginfo> "
"(thus, a cast is required), defined in I<E<lt>sys/msg.hE<gt>> if the "
"B<_GNU_SOURCE> feature test macro is defined:"
msgstr ""
"システム全体でのメッセージ・キューの制限とパラメータに関する情報を、 I<buf> "
"が指す構造体に入れて返す。 この構造体は I<msginfo> 型である (そのためキャスト"
"が必要である)。 I<msginfo> は B<_GNU_SOURCE> 機能検査マクロが定義された場合"
"に I<E<lt>sys/msg.hE<gt>> で以下のように定義される:"

#. type: Plain text
#: build/C/man2/msgctl.2:188
#, no-wrap
msgid ""
"struct msginfo {\n"
"    int msgpool; /* Size in kibibytes of buffer pool\n"
"                    used to hold message data;\n"
"                    unused within kernel */\n"
"    int msgmap;  /* Maximum number of entries in message\n"
"                    map; unused within kernel */\n"
"    int msgmax;  /* Maximum number of bytes that can be\n"
"                    written in a single message */\n"
"    int msgmnb;  /* Maximum number of bytes that can be\n"
"                    written to queue; used to initialize\n"
"                    msg_qbytes during queue creation\n"
"                    (msgget(2)) */\n"
"    int msgmni;  /* Maximum number of message queues */\n"
"    int msgssz;  /* Message segment size;\n"
"                    unused within kernel */\n"
"    int msgtql;  /* Maximum number of messages on all queues\n"
"                    in system; unused within kernel */\n"
"    unsigned short int msgseg;\n"
"                 /* Maximum number of segments;\n"
"                    unused within kernel */\n"
"};\n"
msgstr ""
"struct msginfo {\n"
"    int msgpool; /* メッセージ・データの保持に使用される\n"
"                    バッファ・プールの大きさ (1024 バイト単位);\n"
"                    カーネル内では未使用 */\n"
"    int msgmap;  /* メッセージ・マップの最大エントリ数;\n"
"                    カーネル内では未使用 */\n"
"    int msgmax;  /* 一つのメッセージに書き込み可能な\n"
"                    最大バイト数 */\n"
"    int msgmnb;  /* 一つのキューに書き込み可能な最大バイト数;\n"
"                    (msgget(2) での) キュー作成中の msg_qbytes\n"
"                    の初期化に使用される */\n"
"    int msgmni;  /* メッセージ・キューの数の最大値 */\n"
"    int msgssz;  /* メッセージ・セグメントのサイズ;\n"
"                    カーネル内では未使用 */\n"
"    int msgtql;  /* システム上の全キューの最大メッセージ数;\n"
"                    カーネル内では未使用 */\n"
"    unsigned short int msgseg;\n"
"                 /* 最大セグメント数; カーネル内では未使用 */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgctl.2:201
msgid ""
"The I<msgmni>, I<msgmax>, and I<msgmnb> settings can be changed via I</proc> "
"files of the same name; see B<proc>(5)  for details."
msgstr ""
"設定 I<msgmni ,> I<msgmax ,> I<msgmnb> は I</proc> にある同じ名前のファイル経"
"由で変更可能である。 詳しくは B<proc>(5)  を参照。"

#. type: TP
#: build/C/man2/msgctl.2:201
#, no-wrap
msgid "B<MSG_INFO> (Linux-specific)"
msgstr "B<MSG_INFO> (Linux 固有)"

#. type: Plain text
#: build/C/man2/msgctl.2:218
msgid ""
"Returns a I<msginfo> structure containing the same information as for "
"B<IPC_INFO>, except that the following fields are returned with information "
"about system resources consumed by message queues: the I<msgpool> field "
"returns the number of message queues that currently exist on the system; the "
"I<msgmap> field returns the total number of messages in all queues on the "
"system; and the I<msgtql> field returns the total number of bytes in all "
"messages in all queues on the system."
msgstr ""
"B<IPC_INFO> のときと同じ情報を格納した I<msginfo> 構造体を返す。 但し、以下の"
"フィールドにはメッセージ・キューが 消費しているシステム資源に関する情報が格納"
"される点が異なる。 I<msgpool> フィールドは現在システム上に存在するメッセー"
"ジ・キューの数を返す。 I<msgmap> フィールドはシステム上の全てのキューに入って"
"いるメッセージ総数を返す。 I<msgtql> フィールドはシステム上の全てのキューに"
"入っている全メッセージの 総バイト数を返す。"

#. type: TP
#: build/C/man2/msgctl.2:218
#, no-wrap
msgid "B<MSG_STAT> (Linux-specific)"
msgstr "B<MSG_STAT> (Linux 固有)"

#. type: Plain text
#: build/C/man2/msgctl.2:229
msgid ""
"Returns a I<msqid_ds> structure as for B<IPC_STAT>.  However, the I<msqid> "
"argument is not a queue identifier, but instead an index into the kernel's "
"internal array that maintains information about all message queues on the "
"system."
msgstr ""
"B<IPC_STAT> と同じく I<msqid_ds> 構造体を返す。 但し、 I<msqid> 引き数は、"
"キュー識別子ではなく、システム上の全てのメッセージ・キュー に関する情報を管理"
"するカーネルの内部配列へのインデックスである。"

#. type: Plain text
#: build/C/man2/msgctl.2:250
msgid ""
"On success, B<IPC_STAT>, B<IPC_SET>, and B<IPC_RMID> return 0.  A successful "
"B<IPC_INFO> or B<MSG_INFO> operation returns the index of the highest used "
"entry in the kernel's internal array recording information about all message "
"queues.  (This information can be used with repeated B<MSG_STAT> operations "
"to obtain information about all queues on the system.)  A successful "
"B<MSG_STAT> operation returns the identifier of the queue whose index was "
"given in I<msqid>."
msgstr ""
"成功すると、 B<IPC_STAT>, B<IPC_SET>, B<IPC_RMID> は 0 を返す。 B<IPC_INFO> "
"と B<MSG_INFO> 操作は、成功すると、全てのメッセージ・キューに関する情報を 管"
"理しているカーネルの内部配列の使用中エントリのインデックスの うち最大値を返"
"す (この情報は、システムの全てのメッセージ・キューに関する情報を 取得するため"
"に、 B<MSG_STAT> 操作を繰り返し実行する際に使用できる)。 B<MSG_STAT> 操作は、"
"成功すると、 I<msqid> で指定されたインデックスを持つメッセージ・キューの識別"
"子を返す。"

#. type: Plain text
#: build/C/man2/msgctl.2:254
msgid "On error, -1 is returned with I<errno> indicating the error."
msgstr "エラーの場合は -1 を返し、 I<errno> を適切に設定する。"

#. type: Plain text
#: build/C/man2/msgctl.2:258
msgid "On failure, I<errno> is set to one of the following:"
msgstr "失敗した場合、 I<errno> は以下の値の中のどれか一つに設定される:"

#. type: Plain text
#: build/C/man2/msgctl.2:271
msgid ""
"The argument I<cmd> is equal to B<IPC_STAT> or B<MSG_STAT>, but the calling "
"process does not have read permission on the message queue I<msqid>, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr ""
"引き数 I<cmd> が B<IPC_STAT> または B<MSG_STAT> に等しいが、呼び出したプロセ"
"スがメッセージ・キュー I<msqid> に対する読み込み許可を持っておらず、かつ "
"B<CAP_IPC_OWNER> ケーパビリティを持っていない。"

#. type: TP
#: build/C/man2/msgctl.2:271 build/C/man2/msgop.2:354 build/C/man2/msgop.2:407
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/msgctl.2:282
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_STAT>, but the address "
"pointed to by I<buf> isn't accessible."
msgstr ""
"引き数 I<cmd> が B<IPC_SET> か B<IPC_STAT> で、ポインタ I<buf> で指されている"
"アドレスがアクセス可能でない。"

#. type: TP
#: build/C/man2/msgctl.2:282 build/C/man2/msgop.2:359 build/C/man2/msgop.2:412
#, no-wrap
msgid "B<EIDRM>"
msgstr "B<EIDRM>"

#. type: Plain text
#: build/C/man2/msgctl.2:285 build/C/man2/msgop.2:362
msgid "The message queue was removed."
msgstr "メッセージ・キューが削除された。"

#. type: Plain text
#: build/C/man2/msgctl.2:296
msgid ""
"Invalid value for I<cmd> or I<msqid>.  Or: for a B<MSG_STAT> operation, the "
"index value specified in I<msqid> referred to an array slot that is "
"currently unused."
msgstr ""
"I<cmd> または I<msqid> に不正な値が設定された。 もしくは、 B<MSG_STAT> 操作の"
"場合に、 I<msqid> で指定されたインデックス値が現在未使用の配列のスロットを参"
"照いていた。"

#. type: TP
#: build/C/man2/msgctl.2:296 build/C/man2/msgctl.2:314
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/msgctl.2:314
msgid ""
"The argument I<cmd> has the value B<IPC_SET> or B<IPC_RMID>, but the "
"effective user ID of the calling process is not the creator (as found in "
"I<msg_perm.cuid>)  or the owner (as found in I<msg_perm.uid>)  of the "
"message queue, and the caller is not privileged (Linux: does not have the "
"B<CAP_SYS_ADMIN> capability)."
msgstr ""
"引き数 I<cmd> が B<IPC_SET> か B<IPC_RMID> であるが、呼び出したプロセスの実効"
"ユーザ ID がメッセージキューの (I<msg_perm.cuid> として見つかる) 作成者 と "
"(I<msg_perm.uid> として見つかる) 所有者のいずれでもなく、 かつ呼び出し者に特"
"権がない (Linux では B<CAP_SYS_ADMIN> ケーパビリティがない)。"

#. type: Plain text
#: build/C/man2/msgctl.2:325
msgid ""
"An attempt (B<IPC_SET>)  was made to increase I<msg_qbytes> beyond the "
"system parameter B<MSGMNB>, but the caller is not privileged (Linux: does "
"not have the B<CAP_SYS_RESOURCE> capability)."
msgstr ""
"B<IPC_SET> で I<msg_qbytes> をシステムパラメーター B<MSGMNB> より大きな値に設"
"定しようとしたが、呼び出し元が特権を持っていなかった (Linux では、 "
"B<CAP_SYS_RESOURCE> ケーパビリティを持っていなかった)。"

#. type: Plain text
#: build/C/man2/msgctl.2:328 build/C/man2/msgget.2:185
#: build/C/man2/msgop.2:466
msgid "SVr4, POSIX.1-2001."
msgstr "SVr4, POSIX.1-2001."

#.  Like Linux, the FreeBSD man pages still document
#.  the inclusion of these header files.
#. type: Plain text
#: build/C/man2/msgctl.2:341 build/C/man2/msgget.2:198
#: build/C/man2/msgop.2:489
msgid ""
"The inclusion of I<E<lt>sys/types.hE<gt>> and I<E<lt>sys/ipc.hE<gt>> isn't "
"required on Linux or by any version of POSIX.  However, some old "
"implementations required the inclusion of these header files, and the SVID "
"also documented their inclusion.  Applications intended to be portable to "
"such old systems may need to include these header files."
msgstr ""
"Linux や POSIX の全てのバージョンでは、 I<E<lt>sys/types.hE<gt>> と "
"I<E<lt>sys/ipc.hE<gt>> のインクルードは必要ない。しかしながら、いくつかの古い"
"実装ではこれらのヘッダファイルのインクルードが必要であり、 SVID でもこれらの"
"インクルードをするように記載されている。このような古いシステムへの移植性を意"
"図したアプリケーションではこれらのファイルをインクルードする必要があるかもし"
"れない。"

#. type: Plain text
#: build/C/man2/msgctl.2:353
msgid ""
"The B<IPC_INFO>, B<MSG_STAT> and B<MSG_INFO> operations are used by the "
"B<ipcs>(1)  program to provide information on allocated resources.  In the "
"future these may modified or moved to a I</proc> filesystem interface."
msgstr ""
"B<IPC_INFO>, B<MSG_STAT>, B<MSG_INFO> 操作は、 B<ipcs>(1)  プログラムで割り当"
"て済の資源に関する情報を提供するために 使用されている。将来、これらの操作は変"
"更されたり、 I</proc> ファイルシステムのインタフェースに移動されるかもしれな"
"い。"

#. type: Plain text
#: build/C/man2/msgctl.2:367
msgid ""
"Various fields in the I<struct msqid_ds> were typed as I<short> under Linux "
"2.2 and have become I<long> under Linux 2.4.  To take advantage of this, a "
"recompilation under glibc-2.1.91 or later should suffice.  (The kernel "
"distinguishes old and new calls by an B<IPC_64> flag in I<cmd>.)"
msgstr ""
"I<struct msqid_ds> 内の多くのフィールドは、 Linux 2.2 では I<short> だった"
"が、Linux 2.4 では I<long> になった。 この利点を生かすには、glibc-2.1.91 以降"
"の環境下で 再コンパイルすれば十分である。 (カーネルは新しい形式の呼び出しと古"
"い形式の呼び出しを I<cmd> 内の B<IPC_64> フラグで区別する。)"

#. type: Plain text
#: build/C/man2/msgctl.2:374
msgid ""
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), B<mq_overview>"
"(7), B<svipc>(7)"
msgstr ""
"B<msgget>(2), B<msgrcv>(2), B<msgsnd>(2), B<capabilities>(7), B<mq_overview>"
"(7), B<svipc>(7)"

#. type: TH
#: build/C/man2/msgget.2:35
#, no-wrap
msgid "MSGGET"
msgstr "MSGGET"

#. type: TH
#: build/C/man2/msgget.2:35
#, no-wrap
msgid "2012-05-31"
msgstr "2012-05-31"

#. type: Plain text
#: build/C/man2/msgget.2:38
msgid "msgget - get a System V message queue identifier"
msgstr "msgget - System V メッセージ・キュー識別子を取得する"

#. type: Plain text
#: build/C/man2/msgget.2:45
#, no-wrap
msgid "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"
msgstr "B<int msgget(key_t >I<key>B<, int >I<msgflg>B<);>\n"

#. type: Plain text
#: build/C/man2/msgget.2:67
msgid ""
"The B<msgget>()  system call returns the System V message queue identifier "
"associated with the value of the I<key> argument.  A new message queue is "
"created if I<key> has the value B<IPC_PRIVATE> or I<key> isn't "
"B<IPC_PRIVATE>, no message queue with the given key I<key> exists, and "
"B<IPC_CREAT> is specified in I<msgflg>."
msgstr ""
"B<msgget>()  システムコールは I<key> 引き数の値に対応する System V メッセー"
"ジ・キューの識別子を返す。 I<key> の値が B<IPC_PRIVATE> の場合、または "
"I<key> が B<IPC_PRIVATE> でなくても、 I<key> に対応するメッセージ・キューが存"
"在せず、 I<msgflg> に B<IPC_CREAT> が指定されている場合、 新しいメッセージ・"
"キューが作成される。"

#. type: Plain text
#: build/C/man2/msgget.2:86
msgid ""
"If I<msgflg> specifies both B<IPC_CREAT> and B<IPC_EXCL> and a message queue "
"already exists for I<key>, then B<msgget>()  fails with I<errno> set to "
"B<EEXIST>.  (This is analogous to the effect of the combination B<O_CREAT | "
"O_EXCL> for B<open>(2).)"
msgstr ""
"I<msgflg> に B<IPC_CREAT> と B<IPC_EXCL> の両方が指定された場合、 I<key> に対"
"応するメッセージ・キューが既に存在すると、 B<msgget>()  は失敗し、 I<errno> "
"に B<EEXIST> が設定される。 (これは B<open>(2)  に B<O_CREAT | O_EXCL> を指定"
"した場合の動作と同じである)"

#. type: Plain text
#: build/C/man2/msgget.2:96
msgid ""
"Upon creation, the least significant bits of the argument I<msgflg> define "
"the permissions of the message queue.  These permission bits have the same "
"format and semantics as the permissions specified for the I<mode> argument "
"of B<open>(2).  (The execute permissions are not used.)"
msgstr ""
"メッセージ・キューの作成時に、 I<msgflg> 引き数の下位 9 ビットは、 そのメッ"
"セージ・キューのアクセス許可の定義として使用される。 これらの許可ビットは "
"B<open>(2)  の引き数 I<mode> と同じ形式で同じ意味である。 や B<creat>(2)  シ"
"ステム・コールのアクセス許可パラメータと同じ形式で、同じ意味を持つ。 (但し、"
"実行 (execute) 許可は使用されない。)"

#. type: Plain text
#: build/C/man2/msgget.2:103
msgid ""
"If a new message queue is created, then its associated data structure "
"I<msqid_ds> (see B<msgctl>(2))  is initialized as follows:"
msgstr ""
"新規のメッセージ・キューを作成する際、 B<msgget>()  システム・コールはメッ"
"セージ・キューのデータ構造体 I<msqid_ds> を以下のように初期化する "
"(I<msqid_ds> については B<msgctl>(2)  を参照):"

#. type: Plain text
#: build/C/man2/msgget.2:108
msgid ""
"I<msg_perm.cuid> and I<msg_perm.uid> are set to the effective user ID of the "
"calling process."
msgstr ""
"I<msg_perm.cuid> と I<msg_perm.uid> に呼び出し元プロセスの実効 (effective) "
"ユーザーID を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:113
msgid ""
"I<msg_perm.cgid> and I<msg_perm.gid> are set to the effective group ID of "
"the calling process."
msgstr ""
"I<msg_perm.cgid> と I<msg_perm.gid> に呼び出し元プロセスの実効 (effective) グ"
"ループID を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:118
msgid ""
"The least significant 9 bits of I<msg_perm.mode> are set to the least "
"significant 9 bits of I<msgflg>."
msgstr ""
"I<msg_perm.mode> の下位 9 ビットは I<msgflg> の下位 9 ビットを設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:126
msgid ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, and I<msg_rtime> are "
"set to 0."
msgstr ""
"I<msg_qnum>, I<msg_lspid>, I<msg_lrpid>, I<msg_stime>, I<msg_rtime> に 0 を設"
"定される。"

#. type: Plain text
#: build/C/man2/msgget.2:129
msgid "I<msg_ctime> is set to the current time."
msgstr "I<msg_ctime> に現在の時刻を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:133
msgid "I<msg_qbytes> is set to the system limit B<MSGMNB>."
msgstr ""
"I<msg_qbytes> に、システムで決められたメッセージ・キューの最大サイズ "
"B<MSGMNB> を設定する。"

#. type: Plain text
#: build/C/man2/msgget.2:137
msgid ""
"If the message queue already exists the permissions are verified, and a "
"check is made to see if it is marked for destruction."
msgstr ""
"メッセージ・キューがすでに存在する場合は、アクセス許可の検査と、 破棄 "
"(destruction) マークがないかの確認が行われる。"

#. type: Plain text
#: build/C/man2/msgget.2:143
msgid ""
"If successful, the return value will be the message queue identifier (a "
"nonnegative integer), otherwise -1 with I<errno> indicating the error."
msgstr ""
"成功した場合、返り値はメッセージ・キュー識別子 (非負の整数) となる。 失敗した"
"場合は -1 が返され、 I<errno> にそのエラーが示される。"

#. type: Plain text
#: build/C/man2/msgget.2:147
msgid "On failure, I<errno> is set to one of the following values:"
msgstr "失敗した場合、 I<errno> に以下の値のいずれか一つが設定される:"

#. type: Plain text
#: build/C/man2/msgget.2:155
msgid ""
"A message queue exists for I<key>, but the calling process does not have "
"permission to access the queue, and does not have the B<CAP_IPC_OWNER> "
"capability."
msgstr ""
"I<key> に対応するメッセージ・キューは存在するが、 呼び出し元プロセスはその"
"キューに対するアクセス許可がなく、 B<CAP_IPC_OWNER> ケーパビリティも持ってい"
"ない。"

#. type: Plain text
#: build/C/man2/msgget.2:165
msgid ""
"A message queue exists for I<key> and I<msgflg> specified both B<IPC_CREAT> "
"and B<IPC_EXCL>."
msgstr ""
"I<key> に対応するメッセージ・キューが存在し、 I<msgflg> に B<IPC_CREAT> と "
"B<IPC_EXCL> が指定されていた。"

#. type: Plain text
#: build/C/man2/msgget.2:173
msgid ""
"No message queue exists for I<key> and I<msgflg> did not specify "
"B<IPC_CREAT>."
msgstr ""
"I<key> に対応するメッセージ・キューが存在せず、 I<msgflg> に B<IPC_CREAT> が"
"指定されていなかった。"

#. type: Plain text
#: build/C/man2/msgget.2:177
msgid ""
"A message queue has to be created but the system does not have enough memory "
"for the new data structure."
msgstr ""
"メッセージ・キューを作成しようとしたが、新しいデータ構造体を作成 するのに十分"
"なメモリがシステムに存在しない。"

#. type: Plain text
#: build/C/man2/msgget.2:183
msgid ""
"A message queue has to be created but the system limit for the maximum "
"number of message queues (B<MSGMNI>)  would be exceeded."
msgstr ""
"メッセージ・キューを作成しようとしたが、作成すると システム全体のメッセージ・"
"キュー数の最大値 (B<MSGMNI>)  を超えてしまう。"

#. type: Plain text
#: build/C/man2/msgget.2:208
msgid ""
"B<IPC_PRIVATE> isn't a flag field but a I<key_t> type.  If this special "
"value is used for I<key>, the system call ignores everything but the least "
"significant 9 bits of I<msgflg> and creates a new message queue (on success)."
msgstr ""
"B<IPC_PRIVATE> はフラグではなく、 I<key_t> 型である。 この特別な値が I<key> "
"として使用された場合、 B<msgget>()  システムコールは I<msgflg> の下位 9 ビッ"
"ト以外の全てを無視して (成功した場合は) 新しいメッセージ・キューを作成する。"

#. type: Plain text
#: build/C/man2/msgget.2:212
msgid ""
"The following is a system limit on message queue resources affecting a "
"B<msgget>()  call:"
msgstr ""
"B<msgget>()  システムコールに影響を及ぼすメッセージ・キューの資源の システム"
"としての制限を以下に示す:"

#. type: TP
#: build/C/man2/msgget.2:212
#, no-wrap
msgid "B<MSGMNI>"
msgstr "B<MSGMNI>"

#. type: Plain text
#: build/C/man2/msgget.2:218
msgid ""
"System wide maximum number of message queues: policy dependent (on Linux, "
"this limit can be read and modified via I</proc/sys/kernel/msgmni>)."
msgstr ""
"システム全体のメッセージ・キュー数の最大値: 方針依存 (Linux では、この制限値"
"は I</proc/sys/kernel/msgmni> 経由で参照したり、変更したりできる)。"

#. type: SS
#: build/C/man2/msgget.2:218
#, no-wrap
msgid "Linux notes"
msgstr "Linux での注意"

#. type: Plain text
#: build/C/man2/msgget.2:224
msgid ""
"Until version 2.3.20 Linux would return B<EIDRM> for a B<msgget>()  on a "
"message queue scheduled for deletion."
msgstr ""
"Linux 2.3.20 までは、削除が予定されているメッセージ・キューに対して B<msgget>"
"()  を行うと B<EIDRM> がエラーとして返されるようになっていた。"

#. type: Plain text
#: build/C/man2/msgget.2:230
msgid ""
"The name choice B<IPC_PRIVATE> was perhaps unfortunate, B<IPC_NEW> would "
"more clearly show its function."
msgstr ""
"B<IPC_PRIVATE> という名前を選んだのはおそらく失敗であろう。 B<IPC_NEW> の方が"
"より明確にその機能を表しているだろう。"

#. type: Plain text
#: build/C/man2/msgget.2:238
msgid ""
"B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), "
"B<mq_overview>(7), B<svipc>(7)"
msgstr ""
"B<msgctl>(2), B<msgrcv>(2), B<msgsnd>(2), B<ftok>(3), B<capabilities>(7), "
"B<mq_overview>(7), B<svipc>(7)"

#. type: TH
#: build/C/man2/msgop.2:40
#, no-wrap
msgid "MSGOP"
msgstr "MSGOP"

#. type: TH
#: build/C/man2/msgop.2:40
#, no-wrap
msgid "2014-03-17"
msgstr "2014-03-17"

#. type: Plain text
#: build/C/man2/msgop.2:43
msgid "msgrcv, msgsnd - System V message queue operations"
msgstr "msgrcv, msgsnd - System V メッセージキュー操作"

#. type: Plain text
#: build/C/man2/msgop.2:51
#, no-wrap
msgid "B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, int >I<msgflg>B<);>\n"
msgstr "B<int msgsnd(int >I<msqid>B<, const void *>I<msgp>B<, size_t >I<msgsz>B<, int >I<msgflg>B<);>\n"

#. type: Plain text
#: build/C/man2/msgop.2:55
#, no-wrap
msgid ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"
msgstr ""
"B<ssize_t msgrcv(int >I<msqid>B<, void *>I<msgp>B<, size_t >I<msgsz>B<, long >I<msgtyp>B<,>\n"
"B<               int >I<msgflg>B<);>\n"

#. type: Plain text
#: build/C/man2/msgop.2:65
msgid ""
"The B<msgsnd>()  and B<msgrcv>()  system calls are used, respectively, to "
"send messages to, and receive messages from, a System V message queue.  The "
"calling process must have write permission on the message queue in order to "
"send a message, and read permission to receive a message."
msgstr ""
"システムコール B<msgsnd>()  と B<msgrcv>()  はそれぞれ、 System V メッセー"
"ジ・キューへのメッセージの送信と、 メッセージの受信に使用される。呼び出し元プ"
"ロセスは、 メッセージを送信するためにはメッセージ・キューに対する書き込み許可"
"を、 メッセージを受信するためには読み出し許可を持っていなければならない。"

#. type: Plain text
#: build/C/man2/msgop.2:70
msgid ""
"The I<msgp> argument is a pointer to a caller-defined structure of the "
"following general form:"
msgstr ""
"呼び出し元プロセスは以下に示す構造体を用意し、この構造体への ポインタを "
"I<msgp> 引き数として渡す。"

#. type: Plain text
#: build/C/man2/msgop.2:77
#, no-wrap
msgid ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"
msgstr ""
"struct msgbuf {\n"
"    long mtype;       /* message type, must be E<gt> 0 */\n"
"    char mtext[1];    /* message data */\n"
"};\n"

#. type: Plain text
#: build/C/man2/msgop.2:96
msgid ""
"The I<mtext> field is an array (or other structure) whose size is specified "
"by I<msgsz>, a nonnegative integer value.  Messages of zero length (i.e., no "
"I<mtext> field) are permitted.  The I<mtype> field must have a strictly "
"positive integer value.  This value can be used by the receiving process for "
"message selection (see the description of B<msgrcv>()  below)."
msgstr ""
"I<mtext> フィールドは配列 (または他の構造体) で、その大きさは 非負の整数であ"
"る I<msgsz> で指定される。 長さ 0 のメッセージ (つまり I<mtext> フィールドが"
"ないメッセージ) も認められている。 B<mtype> フィールドは厳密に正の整数でなけ"
"ればならない。 この値は、メッセージを受信するプロセスでメッセージを選択するた"
"めに 使用される (下記の B<msgrcv>()  の説明を参照のこと)。"

#. type: SS
#: build/C/man2/msgop.2:96
#, no-wrap
msgid "msgsnd()"
msgstr "msgsnd()"

#. type: Plain text
#: build/C/man2/msgop.2:104
msgid ""
"The B<msgsnd>()  system call appends a copy of the message pointed to by "
"I<msgp> to the message queue whose identifier is specified by I<msqid>."
msgstr ""
"B<msgsnd>()  システムコールは I<msgp> 引き数で指定されたメッセージのコピーを "
"I<msqid> で指定された識別子を持つメッセージ・キューへ追加する。"

#. type: Plain text
#: build/C/man2/msgop.2:125
msgid ""
"If sufficient space is available in the queue, B<msgsnd>()  succeeds "
"immediately.  (The queue capacity is defined by the I<msg_qbytes> field in "
"the associated data structure for the message queue.  During queue creation "
"this field is initialized to B<MSGMNB> bytes, but this limit can be modified "
"using B<msgctl>(2).)  If insufficient space is available in the queue, then "
"the default behavior of B<msgsnd>()  is to block until space becomes "
"available.  If B<IPC_NOWAIT> is specified in I<msgflg>, then the call "
"instead fails with the error B<EAGAIN>."
msgstr ""
"キューに十分な空き容量がある場合、 B<msgsnd>()  は直ちに成功する。 (キューの"
"容量は、メッセージ・キューのデータ構造体の I<msg_qbytes> フィールドで定義され"
"る。 キュー作成時にこのフィールドは B<MSGMNB> に初期化されるが、この制限は "
"B<msgctl>(2)  を使って変更できる。)  キューに十分な空き容量がない場合、 デ"
"フォルトでは B<msgsnd>()  は空き容量ができるまで停止 (block) する。 "
"I<msgflg> に B<IPC_NOWAIT> が指定された場合は、エラー B<EAGAIN> で失敗する。"

#. type: Plain text
#: build/C/man2/msgop.2:129
msgid "A blocked B<msgsnd>()  call may also fail if:"
msgstr "停止している B<msgsnd>()  は以下の場合にも失敗する。"

#. type: IP
#: build/C/man2/msgop.2:129 build/C/man2/msgop.2:136 build/C/man2/msgop.2:203
#: build/C/man2/msgop.2:208 build/C/man2/msgop.2:222 build/C/man2/msgop.2:290
#: build/C/man2/msgop.2:292 build/C/man2/msgop.2:298
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/msgop.2:136
msgid ""
"the queue is removed, in which case the system call fails with I<errno> set "
"to B<EIDRM>; or"
msgstr "キューが削除された。 この場合、 I<errno> は B<EIDRM> に設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:148
msgid ""
"a signal is caught, in which case the system call fails with I<errno> set to "
"B<EINTR>;B<see> B<signal>(7).  (B<msgsnd>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""
"シグナルが捕捉された。 この場合、 I<errno> は B<EINTR> に設定される。 "
"B<signal>(7)  参照。 (B<msgsnd>()  は、たとえシグナルハンドラの設定時に "
"B<SA_RESTART> を指定していたとしても、シグナルハンドラによって割り込まれた後"
"で 自動的に再スタートすることは決してない。)"

#. type: Plain text
#: build/C/man2/msgop.2:151 build/C/man2/msgop.2:312
msgid ""
"Upon successful completion the message queue data structure is updated as "
"follows:"
msgstr ""
"正常に終了した場合、メッセージ・キューのデータ構造体は以下のように 更新され"
"る:"

#. type: Plain text
#: build/C/man2/msgop.2:154
msgid "I<msg_lspid> is set to the process ID of the calling process."
msgstr "I<msg_lspid> には呼び出し元プロセスのプロセス ID が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:157
msgid "I<msg_qnum> is incremented by 1."
msgstr "I<msg_qnum> は 1 増加する。"

#. type: Plain text
#: build/C/man2/msgop.2:160
msgid "I<msg_stime> is set to the current time."
msgstr "I<msg_stime> には現在時刻が設定される。"

#. type: SS
#: build/C/man2/msgop.2:160
#, no-wrap
msgid "msgrcv()"
msgstr "msgrcv()"

#. type: Plain text
#: build/C/man2/msgop.2:168
msgid ""
"The B<msgrcv>()  system call removes a message from the queue specified by "
"I<msqid> and places it in the buffer pointed to by I<msgp>."
msgstr ""
"B<msgrcv>()  システムコールは I<msqid> で指定されたキューからメッセージを削除"
"し、 I<msgp> で指定されたバッファにそのメッセージを格納する。"

#. type: Plain text
#: build/C/man2/msgop.2:194
msgid ""
"The argument I<msgsz> specifies the maximum size in bytes for the member "
"I<mtext> of the structure pointed to by the I<msgp> argument.  If the "
"message text has length greater than I<msgsz>, then the behavior depends on "
"whether B<MSG_NOERROR> is specified in I<msgflg>.  If B<MSG_NOERROR> is "
"specified, then the message text will be truncated (and the truncated part "
"will be lost); if B<MSG_NOERROR> is not specified, then the message isn't "
"removed from the queue and the system call fails returning -1 with I<errno> "
"set to B<E2BIG>."
msgstr ""
"I<msgsz> 引き数には I<msgp> 引き数で指定された構造体の I<mtext> メンバーの最"
"大のバイト数を指定する。 メッセージのテキストの長さが I<msgsz> より大きい場合"
"の動作は、 I<msgflg> に B<MSG_NOERROR> が指定されているかどうかで決まる。 "
"B<MSG_NOERROR> が指定されていれば、メッセージのテキストは切り詰められる (切り"
"捨てられた部分は失われる)。 B<MSG_NOERROR> が指定されていなければ、メッセージ"
"はキューから削除されず、 システムコールは -1 を返して失敗し、 I<errno> に "
"B<E2BIG> が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:203
#, fuzzy
#| msgid ""
#| "The argument I<msgtyp> specifies the type of message requested as follows:"
msgid ""
"Unless B<MSG_COPY> is specified in I<msgflg> (see below), the I<msgtyp> "
"argument specifies the type of message requested, as follows:"
msgstr ""
"I<msgtyp> 引き数には要求するメッセージの型を指定する。 型は以下のように指定す"
"る:"

#. type: Plain text
#: build/C/man2/msgop.2:208
msgid "If I<msgtyp> is 0, then the first message in the queue is read."
msgstr "I<msgtyp> が 0 ならば、キューの最初にあるメッセージが読み込まれる。"

#. type: Plain text
#: build/C/man2/msgop.2:222
msgid ""
"If I<msgtyp> is greater than 0, then the first message in the queue of type "
"I<msgtyp> is read, unless B<MSG_EXCEPT> was specified in I<msgflg>, in which "
"case the first message in the queue of type not equal to I<msgtyp> will be "
"read."
msgstr ""
"I<msgtyp> が 0 より大きい場合、 I<msgflg> に B<MSG_EXCEPT> が指定されていなけ"
"れば、 I<msgtyp> 型のキューの最初のメッセージが読み込まれる。 B<MSG_EXCEPT> "
"が指定された場合は、 I<msgtyp> 型以外のキューの最初のメッセージが読み込まれ"
"る。"

#. type: Plain text
#: build/C/man2/msgop.2:230
msgid ""
"If I<msgtyp> is less than 0, then the first message in the queue with the "
"lowest type less than or equal to the absolute value of I<msgtyp> will be "
"read."
msgstr ""
"I<msgtyp> が 0 より小さければ、 I<msgtyp> の絶対値以下で最も小さい型を持つ"
"キューの最初のメッセージが読み込まれる。"

#. type: Plain text
#: build/C/man2/msgop.2:235
msgid ""
"The I<msgflg> argument is a bit mask constructed by ORing together zero or "
"more of the following flags:"
msgstr ""
"I<msgflg> 引き数には、以下のフラグを任意の数だけ (0個も可)、これらの OR で指"
"定する:"

#. type: TP
#: build/C/man2/msgop.2:235
#, no-wrap
msgid "B<IPC_NOWAIT>"
msgstr "B<IPC_NOWAIT>"

#. type: Plain text
#: build/C/man2/msgop.2:242
msgid ""
"Return immediately if no message of the requested type is in the queue.  The "
"system call fails with I<errno> set to B<ENOMSG>."
msgstr ""
"キューに要求された型のメッセージがない場合には直ちに返る。 システムコールは失"
"敗し、 I<errno> には B<ENOMSG> が設定される。"

#. type: TP
#: build/C/man2/msgop.2:242
#, no-wrap
msgid "B<MSG_COPY> (since Linux 3.8)"
msgstr "B<MSG_COPY> (Linux 3.8 以降)"

#.  commit 4a674f34ba04a002244edaf891b5da7fc1473ae8
#. type: Plain text
#: build/C/man2/msgop.2:249
msgid ""
"Nondestructively fetch a copy of the message at the ordinal position in the "
"queue specified by I<msgtyp> (messages are considered to be numbered "
"starting at 0)."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:263
msgid ""
"This flag must be specified in conjunction with B<IPC_NOWAIT>, with the "
"result that, if there is no message available at the given position, the "
"call fails immediately with the error B<ENOMSG>.  Because they alter the "
"meaning of I<msgtyp> in orthogonal ways, B<MSG_COPY> and B<MSG_EXCEPT> may "
"not both be specified in I<msgflg>."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:271
msgid ""
"The B<MSG_COPY> flag was added for the implementation of the kernel "
"checkpoint-restore facility and is available only if the kernel was built "
"with the B<CONFIG_CHECKPOINT_RESTORE> option."
msgstr ""

#. type: TP
#: build/C/man2/msgop.2:271
#, no-wrap
msgid "B<MSG_EXCEPT>"
msgstr "B<MSG_EXCEPT>"

#. type: Plain text
#: build/C/man2/msgop.2:279
msgid ""
"Used with I<msgtyp> greater than 0 to read the first message in the queue "
"with message type that differs from I<msgtyp>."
msgstr ""
"0 より大きな I<msgtyp> と一緒に使用して、 I<msgtyp> 以外のキューの最初のメッ"
"セージを読み込む。"

#. type: TP
#: build/C/man2/msgop.2:279
#, no-wrap
msgid "B<MSG_NOERROR>"
msgstr "B<MSG_NOERROR>"

#. type: Plain text
#: build/C/man2/msgop.2:284
msgid "To truncate the message text if longer than I<msgsz> bytes."
msgstr "I<msgsz> バイトよりも長かった場合はメッセージのテキストを切り詰める。"

#. type: Plain text
#: build/C/man2/msgop.2:290
msgid ""
"If no message of the requested type is available and B<IPC_NOWAIT> isn't "
"specified in I<msgflg>, the calling process is blocked until one of the "
"following conditions occurs:"
msgstr ""
"要求された型のメッセージが存在せず、 I<msgflg> に B<IPC_NOWAIT> が指定されて"
"いなかった場合、呼び出し元プロセスは 以下のいずれかの状況になるまで停止 "
"(block) される:"

#. type: Plain text
#: build/C/man2/msgop.2:292
msgid "A message of the desired type is placed in the queue."
msgstr "要求している型のメッセージがキューへ入れられた。"

#. type: Plain text
#: build/C/man2/msgop.2:298
#, fuzzy
#| msgid ""
#| "The message queue is removed from the system.  In this case the system "
#| "call fails with I<errno> set to B<EIDRM>."
msgid ""
"The message queue is removed from the system.  In this case, the system call "
"fails with I<errno> set to B<EIDRM>."
msgstr ""
"メッセージ・キューがシステムから削除された。 この場合、システムコールは失敗"
"し、 I<errno> に B<EIDRM> が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:309
#, fuzzy
#| msgid ""
#| "The calling process catches a signal.  In this case the system call fails "
#| "with I<errno> set to B<EINTR>.  (B<msgrcv>()  is never automatically "
#| "restarted after being interrupted by a signal handler, regardless of the "
#| "setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgid ""
"The calling process catches a signal.  In this case, the system call fails "
"with I<errno> set to B<EINTR>.  (B<msgrcv>()  is never automatically "
"restarted after being interrupted by a signal handler, regardless of the "
"setting of the B<SA_RESTART> flag when establishing a signal handler.)"
msgstr ""
"呼び出し元プロセスがシグナルを捕獲した。 この場合、システムコールは失敗し、 "
"I<errno> に B<EINTR> が設定される。 (B<msgrcv>()  は、たとえシグナルハンドラ"
"の設定時に B<SA_RESTART> を指定していたとしても、シグナルハンドラによって割り"
"込まれた後で 自動的に再スタートすることは決してない。)"

#. type: Plain text
#: build/C/man2/msgop.2:315
msgid "I<msg_lrpid> is set to the process ID of the calling process."
msgstr "I<msg_lrpid> には呼び出し元プロセスのプロセス ID が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:318
msgid "I<msg_qnum> is decremented by 1."
msgstr "I<msg_qnum> は 1 減算される。"

#. type: Plain text
#: build/C/man2/msgop.2:321
msgid "I<msg_rtime> is set to the current time."
msgstr "I<msg_rtime> には現在の時刻が設定される。"

#. type: Plain text
#: build/C/man2/msgop.2:334
msgid ""
"On failure both functions return -1 with I<errno> indicating the error, "
"otherwise B<msgsnd>()  returns 0 and B<msgrcv>()  returns the number of "
"bytes actually copied into the I<mtext> array."
msgstr ""
"失敗した場合は、どちらの関数も -1 を返し、エラーを I<errno> に表示する。成功"
"した場合、 B<msgsnd>()  は 0 を返し、 B<msgrcv>()  は I<mtext> 配列に実際にコ"
"ピーしたバイト数を返す。"

#. type: Plain text
#: build/C/man2/msgop.2:340
msgid ""
"When B<msgsnd>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""
"B<msgsnd>()  が失敗した場合、 B<errno> に以下の値のいずれかが設定される:"

#. type: Plain text
#: build/C/man2/msgop.2:346
msgid ""
"The calling process does not have write permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr ""
"呼び出し元プロセスにはメッセージ・キューに対する書き込み許可がなく、 "
"B<CAP_IPC_OWNER> ケーパビリティもない。"

#. type: Plain text
#: build/C/man2/msgop.2:354
msgid ""
"The message can't be sent due to the I<msg_qbytes> limit for the queue and "
"B<IPC_NOWAIT> was specified in I<msgflg>."
msgstr ""
"I<msg_qbytes> がキューの制限を超えていたため、メッセージを送ることができず、"
"かつ I<msgflg> に B<IPC_NOWAIT> が指定されていた。"

#. type: Plain text
#: build/C/man2/msgop.2:359 build/C/man2/msgop.2:412
msgid "The address pointed to by I<msgp> isn't accessible."
msgstr "I<msgp> が指しているアドレスがアクセス可能でない。"

#. type: Plain text
#: build/C/man2/msgop.2:365
msgid ""
"Sleeping on a full message queue condition, the process caught a signal."
msgstr ""
"メッセージ・キューが要求した条件を満たすまで停止している時に、 プロセスがシグ"
"ナルを捕獲した。"

#. type: Plain text
#: build/C/man2/msgop.2:376
msgid ""
"Invalid I<msqid> value, or nonpositive I<mtype> value, or invalid I<msgsz> "
"value (less than 0 or greater than the system value B<MSGMAX>)."
msgstr ""
"I<msqid> が不適切な値であるか、 I<mtype> が正の値でないか、 I<msgsz> が不適切"
"な値 (0 以下か、システムで決まる値 B<MSGMAX> よりも大きい値) である。"

#. type: Plain text
#: build/C/man2/msgop.2:381
msgid ""
"The system does not have enough memory to make a copy of the message pointed "
"to by I<msgp>."
msgstr ""
"I<msgp> が指すメッセージのコピーを作成するのに十分なメモリがシステムに存在し"
"ない。"

#. type: Plain text
#: build/C/man2/msgop.2:387
msgid ""
"When B<msgrcv>()  fails, I<errno> will be set to one among the following "
"values:"
msgstr ""
"B<msgrcv>()  が失敗した場合には I<errno> に以下の値のいずれかが設定される:"

#. type: TP
#: build/C/man2/msgop.2:387
#, no-wrap
msgid "B<E2BIG>"
msgstr "B<E2BIG>"

#. type: Plain text
#: build/C/man2/msgop.2:395
msgid ""
"The message text length is greater than I<msgsz> and B<MSG_NOERROR> isn't "
"specified in I<msgflg>."
msgstr ""
"メッセージのテキストの長さが I<msgsz> よりも大きく、 I<msgflg> に "
"B<MSG_NOERROR> が設定されていなかった。"

#. type: Plain text
#: build/C/man2/msgop.2:401
msgid ""
"The calling process does not have read permission on the message queue, and "
"does not have the B<CAP_IPC_OWNER> capability."
msgstr ""
"呼び出し元プロセスにはメッセージ・キューに対する読み込み許可がなく、 "
"B<CAP_IPC_OWNER> ケーパビリティもない。"

#. type: Plain text
#: build/C/man2/msgop.2:407
msgid ""
"No message was available in the queue and B<IPC_NOWAIT> was specified in "
"I<msgflg>."
msgstr "キューにはメッセージがなく、 I<msgflg> に B<IPC_NOWAIT> が指定された。"

#. type: Plain text
#: build/C/man2/msgop.2:416
msgid ""
"While the process was sleeping to receive a message, the message queue was "
"removed."
msgstr ""
"メッセージを受信するためにプロセスが停止している間に、 メッセージ・キューが削"
"除された。"

#. type: Plain text
#: build/C/man2/msgop.2:421
msgid ""
"While the process was sleeping to receive a message, the process caught a "
"signal; see B<signal>(7)."
msgstr ""
"メッセージを受けるためにプロセスが停止している間に、 プロセスがシグナルを捕獲"
"した。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/msgop.2:427
msgid "I<msgqid> was invalid, or I<msgsz> was less than 0."
msgstr "I<msgqid> が不正か、 I<msgsz> が 0 より小さい。"

#. type: TP
#: build/C/man2/msgop.2:427 build/C/man2/msgop.2:434
#, no-wrap
msgid "B<EINVAL> (since Linux 3.14)"
msgstr "B<EINVAL> (Linux 3.14 以降)"

#. type: Plain text
#: build/C/man2/msgop.2:434
msgid "I<msgflg> specified B<MSG_COPY>, but not B<IPC_NOWAIT>."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:441
msgid "I<msgflg> specified both B<MSG_COPY> and B<MSG_EXCEPT>."
msgstr ""

#. type: TP
#: build/C/man2/msgop.2:441 build/C/man2/msgop.2:447
#, no-wrap
msgid "B<ENOMSG>"
msgstr "B<ENOMSG>"

#. type: Plain text
#: build/C/man2/msgop.2:447
msgid ""
"B<IPC_NOWAIT> was specified in I<msgflg> and no message of the requested "
"type existed on the message queue."
msgstr ""
"I<msgflg> に B<IPC_NOWAIT> が設定されており、 メッセージ・キューに要求された"
"型のメッセージが存在しなかった。"

#. type: Plain text
#: build/C/man2/msgop.2:457
#, fuzzy
#| msgid ""
#| "B<IPC_NOWAIT> was specified in I<msgflg> and no message of the requested "
#| "type existed on the message queue."
msgid ""
"B<IPC_NOWAIT> and B<MSG_COPY> were specified in I<msgflg> and the queue "
"contains less than I<msgtyp> messages."
msgstr ""
"I<msgflg> に B<IPC_NOWAIT> が設定されており、 メッセージ・キューに要求された"
"型のメッセージが存在しなかった。"

#. type: TP
#: build/C/man2/msgop.2:457
#, no-wrap
msgid "B<ENOSYS> (since Linux 3.8)"
msgstr "B<ENOSYS> (Linux 3.8 以降)"

#. type: Plain text
#: build/C/man2/msgop.2:464
msgid ""
"I<MSG_COPY> was specified in I<msgflg>, and this kernel was configured "
"without B<CONFIG_CHECKPOINT_RESTORE>."
msgstr ""

#.  MSG_COPY since glibc 2.18
#. type: Plain text
#: build/C/man2/msgop.2:476
msgid ""
"The B<MSG_EXCEPT> and B<MSG_COPY> flags are Linux-specific; their "
"definitions can be obtained by defining the B<_GNU_SOURCE> feature test "
"macro."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:496
msgid ""
"The I<msgp> argument is declared as I<struct msgbuf *> with libc4, libc5, "
"glibc 2.0, glibc 2.1.  It is declared as I<void *> with glibc 2.2 and later, "
"as required by SUSv2 and SUSv3."
msgstr ""
"I<msgp> 引き数は、 libc4, libc5, glibc 2.0, glibc 2.1 では I<struct msgbuf "
"*> と宣言されている。glibc 2.2 以降では、 SUSv2 と SUSv3 の要求通り、I<void "
"*> と宣言されている。"

#. type: Plain text
#: build/C/man2/msgop.2:500
msgid ""
"The following limits on message queue resources affect the B<msgsnd>()  call:"
msgstr "以下は B<msgsnd> システムコールに影響するシステム制限である:"

#. type: TP
#: build/C/man2/msgop.2:500
#, no-wrap
msgid "B<MSGMAX>"
msgstr "B<MSGMAX>"

#. type: Plain text
#: build/C/man2/msgop.2:505
msgid ""
"Maximum size for a message text: 8192 bytes (on Linux, this limit can be "
"read and modified via I</proc/sys/kernel/msgmax>)."
msgstr ""
"メッセージのテキストの最大サイズ: 8192 バイト (Linux では、この制限値は I</"
"proc/sys/kernel/msgmax> 経由で読み出したり変更したりできる)。"

#. type: TP
#: build/C/man2/msgop.2:505
#, no-wrap
msgid "B<MSGMNB>"
msgstr "B<MSGMNB>"

#. type: Plain text
#: build/C/man2/msgop.2:515
msgid ""
"Default maximum size in bytes of a message queue: 16384 bytes (on Linux, "
"this limit can be read and modified via I</proc/sys/kernel/msgmnb>).  The "
"superuser can increase the size of a message queue beyond B<MSGMNB> by a "
"B<msgctl>(2)  system call."
msgstr ""
"バイト単位でのメッセージ・キューのデフォルトの最大サイズ : 16384 バイト。 "
"(Linux では、この制限値は I</proc/sys/kernel/msgmnb> 経由で読み出したり変更し"
"たりできる)。 スーパーユーザーは B<msgctl>(2)  システムコールでメッセージ・"
"キューのサイズを B<MSGMNB> よりも大きい値に増やすことができる。"

#. type: Plain text
#: build/C/man2/msgop.2:521
msgid ""
"The implementation has no intrinsic limits for the system wide maximum "
"number of message headers (B<MSGTQL>)  and for the system wide maximum size "
"in bytes of the message pool (B<MSGPOOL>)."
msgstr ""
"現在の実装では、システム全体のメッセージ・ヘッダーの最大数 (B<MSGTQL>)  と、"
"システム全体のメッセージ・プールの最大バイト数 (B<MSGPOOL>)  に関して実装依存"
"の制限はない。"

#.  FIXME http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: build/C/man2/msgop.2:541
msgid ""
"In Linux 3.13 and earlier, if B<msgrcv>()  was called with the B<MSG_COPY> "
"flag, but without B<IPC_NOWAIT>, and the message queue contained less than "
"I<msgtyp> messages, then the call would block until the next message is "
"written to the queue.  At that point, the call would return a copy of the "
"message, I<regardless> of whether that message was at the ordinal position "
"I<msgtyp>.  This bug is fixed in Linux 3.14."
msgstr ""

#.  FIXME http://marc.info/?l=linux-kernel&m=139048542803605&w=2
#.  commit 4f87dac386cc43d5525da7a939d4b4e7edbea22c
#. type: Plain text
#: build/C/man2/msgop.2:557
msgid ""
"Specifying both B<MSG_COPY> and B<MSC_EXCEPT> in I<msgflg> is a logical "
"error (since these flags impose different interpretations on I<msgtyp>).  In "
"Linux 3.13 and earlier, this error was not diagnosed by B<msgrcv>().  This "
"bug is fixed in Linux 3.14."
msgstr ""

#. type: Plain text
#: build/C/man2/msgop.2:563
msgid ""
"B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), B<svipc>"
"(7)"
msgstr ""
"B<msgctl>(2), B<msgget>(2), B<capabilities>(7), B<mq_overview>(7), B<svipc>"
"(7)"

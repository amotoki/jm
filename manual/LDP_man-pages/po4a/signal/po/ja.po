# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2012-05-28 07:17+0900\n"
"PO-Revision-Date: 2012-05-28 20:56+0900\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: TH
#: build/C/man3/bsd_signal.3:23
#, no-wrap
msgid "BSD_SIGNAL"
msgstr "BSD_SIGNAL"

#. type: TH
#: build/C/man3/bsd_signal.3:23 build/C/man2/getitimer.2:7
#, no-wrap
msgid "2009-03-15"
msgstr "2009-03-15"

#. type: TH
#: build/C/man3/bsd_signal.3:23 build/C/man2/eventfd.2:21
#: build/C/man2/getitimer.2:7 build/C/man3/gsignal.3:25 build/C/man2/kill.2:44
#: build/C/man2/killpg.2:40 build/C/man2/pause.2:30 build/C/man2/prctl.2:48
#: build/C/man3/profil.3:28 build/C/man3/psignal.3:28 build/C/man3/raise.3:27
#: build/C/man2/rt_sigqueueinfo.2:23 build/C/man2/sgetmask.2:24
#: build/C/man2/sigaction.2:45 build/C/man2/sigaltstack.2:25
#: build/C/man7/sigevent.7:24 build/C/man3/siginterrupt.3:29
#: build/C/man2/signal.2:34 build/C/man7/signal.7:44
#: build/C/man2/signalfd.2:19 build/C/man3/sigpause.3:23
#: build/C/man2/sigpending.2:27 build/C/man2/sigprocmask.2:27
#: build/C/man3/sigqueue.3:26 build/C/man2/sigreturn.2:27
#: build/C/man3/sigset.3:24 build/C/man3/sigsetops.3:29
#: build/C/man2/sigsuspend.2:27 build/C/man3/sigvec.3:24
#: build/C/man3/sigwait.3:24 build/C/man2/sigwaitinfo.2:23
#: build/C/man3/sysv_signal.3:23 build/C/man2/timer_create.2:29
#: build/C/man2/timer_delete.2:23 build/C/man2/timer_getoverrun.2:23
#: build/C/man2/timer_settime.2:23 build/C/man2/timerfd_create.2:20
#: build/C/man2/tkill.2:29 build/C/man2/wait.2:50 build/C/man2/wait4.2:34
#, no-wrap
msgid "Linux Programmer's Manual"
msgstr "Linux Programmer's Manual"

#. type: SH
#: build/C/man3/bsd_signal.3:24 build/C/man2/eventfd.2:22
#: build/C/man2/getitimer.2:8 build/C/man3/gsignal.3:26 build/C/man2/kill.2:45
#: build/C/man2/killpg.2:41 build/C/man2/pause.2:31 build/C/man2/prctl.2:49
#: build/C/man3/profil.3:29 build/C/man3/psignal.3:29 build/C/man3/raise.3:28
#: build/C/man2/rt_sigqueueinfo.2:24 build/C/man2/sgetmask.2:25
#: build/C/man2/sigaction.2:46 build/C/man2/sigaltstack.2:26
#: build/C/man7/sigevent.7:25 build/C/man3/siginterrupt.3:30
#: build/C/man2/signal.2:35 build/C/man7/signal.7:45
#: build/C/man2/signalfd.2:20 build/C/man3/sigpause.3:24
#: build/C/man2/sigpending.2:28 build/C/man2/sigprocmask.2:28
#: build/C/man3/sigqueue.3:27 build/C/man2/sigreturn.2:28
#: build/C/man3/sigset.3:25 build/C/man3/sigsetops.3:30
#: build/C/man2/sigsuspend.2:28 build/C/man3/sigvec.3:25
#: build/C/man3/sigwait.3:25 build/C/man2/sigwaitinfo.2:24
#: build/C/man3/sysv_signal.3:24 build/C/man2/timer_create.2:30
#: build/C/man2/timer_delete.2:24 build/C/man2/timer_getoverrun.2:24
#: build/C/man2/timer_settime.2:24 build/C/man2/timerfd_create.2:21
#: build/C/man2/tkill.2:30 build/C/man2/wait.2:51 build/C/man2/wait4.2:35
#, no-wrap
msgid "NAME"
msgstr "名前"

#. type: Plain text
#: build/C/man3/bsd_signal.3:26
msgid "bsd_signal - signal handling with BSD semantics"
msgstr "bsd_signal - BSD 方式のシグナル処理"

#. type: SH
#: build/C/man3/bsd_signal.3:26 build/C/man2/eventfd.2:24
#: build/C/man2/getitimer.2:10 build/C/man3/gsignal.3:28
#: build/C/man2/kill.2:47 build/C/man2/killpg.2:43 build/C/man2/pause.2:33
#: build/C/man2/prctl.2:51 build/C/man3/profil.3:31 build/C/man3/psignal.3:31
#: build/C/man3/raise.3:30 build/C/man2/rt_sigqueueinfo.2:26
#: build/C/man2/sgetmask.2:27 build/C/man2/sigaction.2:48
#: build/C/man2/sigaltstack.2:28 build/C/man7/sigevent.7:27
#: build/C/man3/siginterrupt.3:32 build/C/man2/signal.2:37
#: build/C/man2/signalfd.2:22 build/C/man3/sigpause.3:26
#: build/C/man2/sigpending.2:30 build/C/man2/sigprocmask.2:30
#: build/C/man3/sigqueue.3:29 build/C/man2/sigreturn.2:30
#: build/C/man3/sigset.3:27 build/C/man3/sigsetops.3:33
#: build/C/man2/sigsuspend.2:30 build/C/man3/sigvec.3:27
#: build/C/man3/sigwait.3:27 build/C/man2/sigwaitinfo.2:26
#: build/C/man3/sysv_signal.3:26 build/C/man2/timer_create.2:32
#: build/C/man2/timer_delete.2:26 build/C/man2/timer_getoverrun.2:26
#: build/C/man2/timer_settime.2:27 build/C/man2/timerfd_create.2:24
#: build/C/man2/tkill.2:32 build/C/man2/wait.2:53 build/C/man2/wait4.2:37
#, no-wrap
msgid "SYNOPSIS"
msgstr "書式"

#. type: Plain text
#: build/C/man3/bsd_signal.3:28
msgid "B<#define _XOPEN_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _XOPEN_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/bsd_signal.3:30 build/C/man2/killpg.2:45
#: build/C/man2/sigaltstack.2:30 build/C/man2/signal.2:39
#: build/C/man2/sigpending.2:32 build/C/man2/sigprocmask.2:32
#: build/C/man3/sigqueue.3:31 build/C/man3/sigset.3:29
#: build/C/man3/sigsetops.3:35 build/C/man2/sigsuspend.2:32
#: build/C/man3/sigvec.3:29 build/C/man3/sysv_signal.3:30
msgid "B<#include E<lt>signal.hE<gt>>"
msgstr "B<#include E<lt>signal.hE<gt>>"

#. type: Plain text
#: build/C/man3/bsd_signal.3:32 build/C/man2/signal.2:41
#: build/C/man3/sigset.3:31 build/C/man3/sysv_signal.3:32
msgid "B<typedef void (*sighandler_t)(int);>"
msgstr "B<typedef void (*sighandler_t)(int);>"

#. type: Plain text
#: build/C/man3/bsd_signal.3:34
msgid ""
"B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t bsd_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: SH
#: build/C/man3/bsd_signal.3:34 build/C/man2/eventfd.2:28
#: build/C/man2/getitimer.2:19 build/C/man3/gsignal.3:47
#: build/C/man2/kill.2:65 build/C/man2/killpg.2:59 build/C/man2/pause.2:37
#: build/C/man2/prctl.2:58 build/C/man3/profil.3:44 build/C/man3/psignal.3:54
#: build/C/man3/raise.3:36 build/C/man2/rt_sigqueueinfo.2:33
#: build/C/man2/sgetmask.2:31 build/C/man2/sigaction.2:65
#: build/C/man2/sigaltstack.2:49 build/C/man7/sigevent.7:50
#: build/C/man3/siginterrupt.3:53 build/C/man2/signal.2:43
#: build/C/man7/signal.7:47 build/C/man2/signalfd.2:26
#: build/C/man3/sigpause.3:34 build/C/man2/sigpending.2:44
#: build/C/man2/sigprocmask.2:45 build/C/man3/sigqueue.3:41
#: build/C/man2/sigreturn.2:32 build/C/man3/sigset.3:56
#: build/C/man3/sigsetops.3:61 build/C/man2/sigsuspend.2:44
#: build/C/man3/sigvec.3:47 build/C/man3/sigwait.3:43
#: build/C/man2/sigwaitinfo.2:44 build/C/man3/sysv_signal.3:34
#: build/C/man2/timer_create.2:50 build/C/man2/timer_delete.2:42
#: build/C/man2/timer_getoverrun.2:42 build/C/man2/timer_settime.2:47
#: build/C/man2/timerfd_create.2:36 build/C/man2/tkill.2:38
#: build/C/man2/wait.2:82 build/C/man2/wait4.2:68
#, no-wrap
msgid "DESCRIPTION"
msgstr "説明"

#. type: Plain text
#: build/C/man3/bsd_signal.3:39
msgid ""
"The B<bsd_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""
"B<bsd_signal>()  関数は B<signal>(2)  と同じ引き数をとり、同じ処理を実行す"
"る。"

#. type: Plain text
#: build/C/man3/bsd_signal.3:52
msgid ""
"The difference between the two is that B<bsd_signal>()  is guaranteed to "
"provide reliable signal semantics, that is: a) the disposition of the signal "
"is not reset to the default when the handler is invoked; b) delivery of "
"further instances of the signal is blocked while the signal handler is "
"executing; and c) if the handler interrupts a blocking system call, then the "
"system call is automatically restarted.  A portable application cannot rely "
"on B<signal>(2)  to provide these guarantees."
msgstr ""
"両者の違いは、 B<bsd_signal>()  では信頼性のあるシグナル処理方式の提供が保証"
"されていることである。 信頼性のあるシグナル処理方式は以下の特徴を持つ。 a) ハ"
"ンドラが起動された場合に、シグナルの処理方法 (disposition) が デフォルトにリ"
"セットされない、 b) シグナルハンドラの実行中は、それ以降に発生した同じシグナ"
"ルの配送が ブロックされない、 c) ハンドラが停止中の (blocking している) シス"
"テムコールを 中断した場合、そのシステムコールが自動的に再開される。 移植性が"
"必要なアプリケーションでは、 B<signal>(2)  でこれらが保証されることを前提にす"
"べきではない。"

#. type: SH
#: build/C/man3/bsd_signal.3:52 build/C/man2/eventfd.2:222
#: build/C/man2/getitimer.2:117 build/C/man2/kill.2:99
#: build/C/man2/killpg.2:88 build/C/man2/pause.2:42 build/C/man2/prctl.2:546
#: build/C/man3/profil.3:66 build/C/man3/psignal.3:87 build/C/man3/raise.3:59
#: build/C/man2/rt_sigqueueinfo.2:124 build/C/man2/sgetmask.2:54
#: build/C/man2/sigaction.2:656 build/C/man2/sigaltstack.2:131
#: build/C/man3/siginterrupt.3:71 build/C/man2/signal.2:95
#: build/C/man2/signalfd.2:248 build/C/man3/sigpause.3:46
#: build/C/man2/sigpending.2:51 build/C/man2/sigprocmask.2:91
#: build/C/man3/sigqueue.3:81 build/C/man2/sigreturn.2:51
#: build/C/man3/sigset.3:127 build/C/man3/sigsetops.3:105
#: build/C/man2/sigsuspend.2:68 build/C/man3/sigvec.3:197
#: build/C/man3/sigwait.3:66 build/C/man2/sigwaitinfo.2:101
#: build/C/man3/sysv_signal.3:49 build/C/man2/timer_create.2:165
#: build/C/man2/timer_delete.2:50 build/C/man2/timer_getoverrun.2:79
#: build/C/man2/timer_settime.2:169 build/C/man2/timerfd_create.2:286
#: build/C/man2/tkill.2:69 build/C/man2/wait.2:354 build/C/man2/wait4.2:127
#, no-wrap
msgid "RETURN VALUE"
msgstr "返り値"

#. type: Plain text
#: build/C/man3/bsd_signal.3:58
msgid ""
"The B<bsd_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""
"B<bsd_signal>()  関数はシグナルハンドラの直前の値を返す。 エラーの場合、 "
"B<SIG_ERR> を返す。"

#. type: SH
#: build/C/man3/bsd_signal.3:58 build/C/man2/eventfd.2:229
#: build/C/man2/getitimer.2:122 build/C/man2/kill.2:104
#: build/C/man2/killpg.2:93 build/C/man2/pause.2:53 build/C/man2/prctl.2:563
#: build/C/man2/rt_sigqueueinfo.2:129 build/C/man2/sgetmask.2:59
#: build/C/man2/sigaction.2:659 build/C/man2/sigaltstack.2:135
#: build/C/man3/siginterrupt.3:76 build/C/man2/signal.2:100
#: build/C/man2/signalfd.2:262 build/C/man2/sigpending.2:54
#: build/C/man2/sigprocmask.2:94 build/C/man3/sigqueue.3:89
#: build/C/man3/sigset.3:152 build/C/man3/sigsetops.3:121
#: build/C/man2/sigsuspend.2:72 build/C/man3/sigvec.3:214
#: build/C/man3/sigwait.3:71 build/C/man2/sigwaitinfo.2:110
#: build/C/man3/sysv_signal.3:55 build/C/man2/timer_create.2:173
#: build/C/man2/timer_delete.2:57 build/C/man2/timer_getoverrun.2:87
#: build/C/man2/timer_settime.2:178 build/C/man2/timerfd_create.2:301
#: build/C/man2/tkill.2:73 build/C/man2/wait.2:383 build/C/man2/wait4.2:130
#, no-wrap
msgid "ERRORS"
msgstr "エラー"

#. type: Plain text
#: build/C/man3/bsd_signal.3:61 build/C/man3/sysv_signal.3:58
msgid "As for B<signal>(2)."
msgstr "B<signal>(2)  と同じ。"

#. type: SH
#: build/C/man3/bsd_signal.3:61 build/C/man2/eventfd.2:266
#: build/C/man2/getitimer.2:143 build/C/man3/gsignal.3:93
#: build/C/man2/kill.2:120 build/C/man2/killpg.2:110 build/C/man2/pause.2:57
#: build/C/man2/prctl.2:725 build/C/man3/profil.3:68 build/C/man3/psignal.3:97
#: build/C/man3/raise.3:62 build/C/man2/rt_sigqueueinfo.2:171
#: build/C/man2/sgetmask.2:61 build/C/man2/sigaction.2:671
#: build/C/man2/sigaltstack.2:154 build/C/man7/sigevent.7:128
#: build/C/man3/siginterrupt.3:80 build/C/man2/signal.2:105
#: build/C/man7/signal.7:836 build/C/man2/signalfd.2:304
#: build/C/man3/sigpause.3:54 build/C/man2/sigpending.2:59
#: build/C/man2/sigprocmask.2:107 build/C/man3/sigqueue.3:112
#: build/C/man2/sigreturn.2:58 build/C/man3/sigset.3:171
#: build/C/man3/sigsetops.3:126 build/C/man2/sigsuspend.2:80
#: build/C/man3/sigvec.3:219 build/C/man3/sigwait.3:77
#: build/C/man2/sigwaitinfo.2:129 build/C/man3/sysv_signal.3:58
#: build/C/man2/timer_create.2:191 build/C/man2/timer_delete.2:64
#: build/C/man2/timer_getoverrun.2:94 build/C/man2/timer_settime.2:203
#: build/C/man2/timerfd_create.2:370 build/C/man2/tkill.2:90
#: build/C/man2/wait.2:421 build/C/man2/wait4.2:133
#, no-wrap
msgid "CONFORMING TO"
msgstr "準拠"

#. type: Plain text
#: build/C/man3/bsd_signal.3:68
msgid ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 removes the specification of "
"B<bsd_signal>(), recommending the use of B<sigaction>(2)  instead."
msgstr ""
"4.2BSD, POSIX.1-2001.  POSIX.1-2008 では B<bsd_signal>()  の仕様が削除されて"
"いる。 代わりに、 B<sigaction>(2)  の使用が推奨されている。"

#. type: SH
#: build/C/man3/bsd_signal.3:68 build/C/man2/eventfd.2:271
#: build/C/man2/getitimer.2:153 build/C/man2/kill.2:122
#: build/C/man2/killpg.2:114 build/C/man3/raise.3:64
#: build/C/man2/rt_sigqueueinfo.2:173 build/C/man2/sgetmask.2:63
#: build/C/man2/sigaction.2:674 build/C/man2/sigaltstack.2:156
#: build/C/man2/signal.2:107 build/C/man2/signalfd.2:309
#: build/C/man3/sigpause.3:58 build/C/man2/sigpending.2:61
#: build/C/man2/sigprocmask.2:109 build/C/man3/sigqueue.3:114
#: build/C/man2/sigreturn.2:62 build/C/man3/sigset.3:188
#: build/C/man3/sigsetops.3:128 build/C/man2/sigsuspend.2:82
#: build/C/man3/sigvec.3:225 build/C/man3/sigwait.3:79
#: build/C/man2/sigwaitinfo.2:131 build/C/man3/sysv_signal.3:60
#: build/C/man2/timer_create.2:193 build/C/man2/timer_getoverrun.2:96
#: build/C/man2/tkill.2:96 build/C/man2/wait.2:423 build/C/man2/wait4.2:135
#, no-wrap
msgid "NOTES"
msgstr "注意"

#. type: Plain text
#: build/C/man3/bsd_signal.3:74
msgid ""
"Use of B<bsd_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""
"B<bsd_signal>()  の使用は避けるべきである。代わりに B<sigaction>(2)  を使うこ"
"と。"

#. type: Plain text
#: build/C/man3/bsd_signal.3:85
msgid ""
"On modern Linux systems, B<bsd_signal>()  and B<signal>(2)  are equivalent.  "
"But on older systems, B<signal>(2)  provided unreliable signal semantics; "
"see B<signal>(2)  for details."
msgstr ""
"最近の Linux システムでは、 B<bsd_signal>()  と B<signal>(2)  は等価である。"
"しかし、以前のシステムでは、 B<signal>(2)  は信頼性に欠けるシグナル処理方式を"
"提供していた。 詳細は B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/bsd_signal.3:92 build/C/man3/sysv_signal.3:85
msgid ""
"The use of I<sighandler_t> is a GNU extension; this type is only defined if "
"the B<_GNU_SOURCE> feature test macro is defined."
msgstr ""
"I<sighandler_t> を使っているのは GNU による拡張である。 この型は機能検査マク"
"ロ B<_GNU_SOURCE> を定義した場合にのみ定義される。"

#. type: SH
#: build/C/man3/bsd_signal.3:92 build/C/man2/eventfd.2:417
#: build/C/man2/getitimer.2:219 build/C/man3/gsignal.3:101
#: build/C/man2/kill.2:170 build/C/man2/killpg.2:133 build/C/man2/pause.2:59
#: build/C/man2/prctl.2:739 build/C/man3/profil.3:79
#: build/C/man3/psignal.3:111 build/C/man3/raise.3:75
#: build/C/man2/rt_sigqueueinfo.2:183 build/C/man2/sgetmask.2:74
#: build/C/man2/sigaction.2:787 build/C/man2/sigaltstack.2:230
#: build/C/man7/sigevent.7:130 build/C/man3/siginterrupt.3:89
#: build/C/man2/signal.2:260 build/C/man7/signal.7:848
#: build/C/man2/signalfd.2:430 build/C/man3/sigpause.3:96
#: build/C/man2/sigpending.2:82 build/C/man2/sigprocmask.2:139
#: build/C/man3/sigqueue.3:147 build/C/man2/sigreturn.2:72
#: build/C/man3/sigset.3:264 build/C/man3/sigsetops.3:166
#: build/C/man2/sigsuspend.2:104 build/C/man3/sigvec.3:250
#: build/C/man3/sigwait.3:86 build/C/man2/sigwaitinfo.2:182
#: build/C/man3/sysv_signal.3:85 build/C/man2/timer_create.2:397
#: build/C/man2/timer_delete.2:66 build/C/man2/timer_getoverrun.2:128
#: build/C/man2/timer_settime.2:208 build/C/man2/timerfd_create.2:540
#: build/C/man2/tkill.2:105 build/C/man2/wait.2:605 build/C/man2/wait4.2:153
#, no-wrap
msgid "SEE ALSO"
msgstr "関連項目"

#. type: Plain text
#: build/C/man3/bsd_signal.3:97
msgid "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<signal>(2), B<sysv_signal>(3), B<signal>(7)"

#. type: SH
#: build/C/man3/bsd_signal.3:97 build/C/man2/eventfd.2:428
#: build/C/man2/getitimer.2:226 build/C/man3/gsignal.3:105
#: build/C/man2/kill.2:180 build/C/man2/killpg.2:139 build/C/man2/pause.2:64
#: build/C/man2/prctl.2:742 build/C/man3/profil.3:84
#: build/C/man3/psignal.3:116 build/C/man3/raise.3:82
#: build/C/man2/rt_sigqueueinfo.2:191 build/C/man2/sgetmask.2:77
#: build/C/man2/sigaction.2:806 build/C/man2/sigaltstack.2:237
#: build/C/man7/sigevent.7:140 build/C/man3/siginterrupt.3:91
#: build/C/man2/signal.2:279 build/C/man7/signal.7:881
#: build/C/man2/signalfd.2:443 build/C/man3/sigpause.3:104
#: build/C/man2/sigpending.2:90 build/C/man2/sigprocmask.2:150
#: build/C/man3/sigqueue.3:155 build/C/man2/sigreturn.2:77
#: build/C/man3/sigset.3:274 build/C/man3/sigsetops.3:171
#: build/C/man2/sigsuspend.2:114 build/C/man3/sigvec.3:260
#: build/C/man3/sigwait.3:94 build/C/man2/sigwaitinfo.2:194
#: build/C/man3/sysv_signal.3:90 build/C/man2/timer_create.2:410
#: build/C/man2/timer_delete.2:72 build/C/man2/timer_getoverrun.2:138
#: build/C/man2/timer_settime.2:212 build/C/man2/timerfd_create.2:552
#: build/C/man2/tkill.2:110 build/C/man2/wait.2:617 build/C/man2/wait4.2:160
#, no-wrap
msgid "COLOPHON"
msgstr "この文書について"

#. type: Plain text
#: build/C/man3/bsd_signal.3:104 build/C/man2/eventfd.2:435
#: build/C/man2/getitimer.2:233 build/C/man3/gsignal.3:112
#: build/C/man2/kill.2:187 build/C/man2/killpg.2:146 build/C/man2/pause.2:71
#: build/C/man2/prctl.2:749 build/C/man3/profil.3:91
#: build/C/man3/psignal.3:123 build/C/man3/raise.3:89
#: build/C/man2/rt_sigqueueinfo.2:198 build/C/man2/sgetmask.2:84
#: build/C/man2/sigaction.2:813 build/C/man2/sigaltstack.2:244
#: build/C/man7/sigevent.7:147 build/C/man3/siginterrupt.3:98
#: build/C/man2/signal.2:286 build/C/man7/signal.7:888
#: build/C/man2/signalfd.2:450 build/C/man3/sigpause.3:111
#: build/C/man2/sigpending.2:97 build/C/man2/sigprocmask.2:157
#: build/C/man3/sigqueue.3:162 build/C/man2/sigreturn.2:84
#: build/C/man3/sigset.3:281 build/C/man3/sigsetops.3:178
#: build/C/man2/sigsuspend.2:121 build/C/man3/sigvec.3:267
#: build/C/man3/sigwait.3:101 build/C/man2/sigwaitinfo.2:201
#: build/C/man3/sysv_signal.3:97 build/C/man2/timer_create.2:417
#: build/C/man2/timer_delete.2:79 build/C/man2/timer_getoverrun.2:145
#: build/C/man2/timer_settime.2:219 build/C/man2/timerfd_create.2:559
#: build/C/man2/tkill.2:117 build/C/man2/wait.2:624 build/C/man2/wait4.2:167
msgid ""
"This page is part of release 3.41 of the Linux I<man-pages> project.  A "
"description of the project, and information about reporting bugs, can be "
"found at http://www.kernel.org/doc/man-pages/."
msgstr ""
"この man ページは Linux I<man-pages> プロジェクトのリリース 3.41 の一部\n"
"である。プロジェクトの説明とバグ報告に関する情報は\n"
"http://www.kernel.org/doc/man-pages/ に書かれている。"

#. type: TH
#: build/C/man2/eventfd.2:21
#, no-wrap
msgid "EVENTFD"
msgstr "EVENTFD"

#. type: TH
#: build/C/man2/eventfd.2:21
#, no-wrap
msgid "2010-08-30"
msgstr "2010-08-30"

#. type: TH
#: build/C/man2/eventfd.2:21 build/C/man2/getitimer.2:7 build/C/man2/kill.2:44
#: build/C/man2/killpg.2:40 build/C/man2/pause.2:30 build/C/man2/prctl.2:48
#: build/C/man3/profil.3:28 build/C/man2/rt_sigqueueinfo.2:23
#: build/C/man2/sgetmask.2:24 build/C/man2/sigaction.2:45
#: build/C/man2/sigaltstack.2:25 build/C/man2/signal.2:34
#: build/C/man7/signal.7:44 build/C/man2/signalfd.2:19
#: build/C/man3/sigpause.3:23 build/C/man2/sigpending.2:27
#: build/C/man2/sigprocmask.2:27 build/C/man3/sigqueue.3:26
#: build/C/man2/sigreturn.2:27 build/C/man3/sigset.3:24
#: build/C/man3/sigsetops.3:29 build/C/man2/sigsuspend.2:27
#: build/C/man3/sigvec.3:24 build/C/man3/sigwait.3:24
#: build/C/man2/sigwaitinfo.2:23 build/C/man2/timer_create.2:29
#: build/C/man2/timer_delete.2:23 build/C/man2/timer_getoverrun.2:23
#: build/C/man2/timer_settime.2:23 build/C/man2/timerfd_create.2:20
#: build/C/man2/tkill.2:29 build/C/man2/wait.2:50 build/C/man2/wait4.2:34
#, no-wrap
msgid "Linux"
msgstr "Linux"

#. type: Plain text
#: build/C/man2/eventfd.2:24
msgid "eventfd - create a file descriptor for event notification"
msgstr "eventfd - イベント通知用のファイルディスクリプタを生成する"

#. type: Plain text
#: build/C/man2/eventfd.2:26
msgid "B<#include E<lt>sys/eventfd.hE<gt>>"
msgstr "B<#include E<lt>sys/eventfd.hE<gt>>"

#. type: Plain text
#: build/C/man2/eventfd.2:28
msgid "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"
msgstr "B<int eventfd(unsigned int >I<initval>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/eventfd.2:38
msgid ""
"B<eventfd>()  creates an \"eventfd object\" that can be used as an event "
"wait/notify mechanism by userspace applications, and by the kernel to notify "
"userspace applications of events.  The object contains an unsigned 64-bit "
"integer (I<uint64_t>)  counter that is maintained by the kernel.  This "
"counter is initialized with the value specified in the argument I<initval>."
msgstr ""
"B<eventfd>()  は \"eventfd オブジェクト\" を生成する。 eventfd オブジェクトは"
"ユーザ空間アプリケーションがイベント待ち受け/通知用の 仕組みとして使うことが"
"できる。また、カーネルがユーザ空間アプリケーションに イベントを通知するために"
"も使うことができる。 このオブジェクトには、unsigned の 64 ビット整数 "
"(I<uint64_t>)  型のカウンタが含まれており、このカウンタはカーネルにより管理さ"
"れる。 このカウンタは I<initval> 引き数で指定された値で初期化される。"

#. type: Plain text
#: build/C/man2/eventfd.2:43
msgid ""
"The following values may be bitwise ORed in I<flags> to change the behaviour "
"of B<eventfd>():"
msgstr ""
"以下の値のいくつかをビット単位の論理和 (OR) で指定することで、\n"
"B<eventfd>() の振舞いを変更することができる。"

#. type: TP
#: build/C/man2/eventfd.2:43
#, no-wrap
msgid "B<EFD_CLOEXEC> (since Linux 2.6.27)"
msgstr "B<EFD_CLOEXEC> (Linux 2.6.27 以降)"

#. type: Plain text
#: build/C/man2/eventfd.2:53 build/C/man2/signalfd.2:94
#: build/C/man2/timerfd_create.2:102
msgid ""
"Set the close-on-exec (B<FD_CLOEXEC>)  flag on the new file descriptor.  See "
"the description of the B<O_CLOEXEC> flag in B<open>(2)  for reasons why this "
"may be useful."
msgstr ""
"新しいファイルディスクリプタに対して close-on-exec (B<FD_CLOEXEC>)  フラグを"
"セットする。 このフラグが役に立つ理由については、 B<open>(2)  の "
"B<O_CLOEXEC> フラグの説明を参照のこと。"

#. type: TP
#: build/C/man2/eventfd.2:53
#, no-wrap
msgid "B<EFD_NONBLOCK> (since Linux 2.6.27)"
msgstr "B<EFD_NONBLOCK> (Linux 2.6.27 以降)"

#. type: Plain text
#: build/C/man2/eventfd.2:61 build/C/man2/signalfd.2:84
#: build/C/man2/timerfd_create.2:92
msgid ""
"Set the B<O_NONBLOCK> file status flag on the new open file description.  "
"Using this flag saves extra calls to B<fcntl>(2)  to achieve the same result."
msgstr ""
"新しく生成されるオープンファイル記述 (open file description) の "
"B<O_NONBLOCK> ファイルステータスフラグをセットする。 このフラグを使うこと"
"で、 B<O_NONBLOCK> をセットするために B<fcntl>(2)  を追加で呼び出す必要がなく"
"なる。"

#. type: TP
#: build/C/man2/eventfd.2:61
#, no-wrap
msgid "B<EFD_SEMAPHORE> (since Linux 2.6.30)"
msgstr "B<EFD_SEMAPHORE> (Linux 2.6.30 以降)"

#. type: Plain text
#: build/C/man2/eventfd.2:65
msgid ""
"Provide semaphore-like semantics for reads from the new file descriptor.  "
"See below."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:69 build/C/man2/signalfd.2:98
msgid ""
"In Linux up to version 2.6.26, the I<flags> argument is unused, and must be "
"specified as zero."
msgstr ""
"バージョン 2.6.26 以前の Linux では、 I<flags> 引き数は未使用であり、0 を指定"
"しなければならない。"

#. type: Plain text
#: build/C/man2/eventfd.2:75
msgid ""
"As its return value, B<eventfd>()  returns a new file descriptor that can be "
"used to refer to the eventfd object.  The following operations can be "
"performed on the file descriptor:"
msgstr ""
"B<eventfd>()  は eventfd オブジェクトを参照するのに使用できる新しいファイル"
"ディスクリプタ を返す。返されたファイルディスクリプタに対しては以下の操作を実"
"行できる。"

#. type: TP
#: build/C/man2/eventfd.2:75 build/C/man2/signalfd.2:101
#: build/C/man2/timerfd_create.2:210
#, no-wrap
msgid "B<read>(2)"
msgstr "B<read>(2)"

#. type: Plain text
#: build/C/man2/eventfd.2:85
msgid ""
"Each successful B<read>(2)  returns an 8-byte integer.  A B<read>(2)  will "
"fail with the error B<EINVAL> if the size of the supplied buffer is less "
"than 8 bytes."
msgstr ""
"B<read>(2) は成功すると、8 バイトの整数を返す。\n"
"渡されたバッファの大きさが 8 バイト未満の場合、\n"
"B<read>(2)  はエラー B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/eventfd.2:90
msgid ""
"The value returned by B<read>(2)  is in host byte order, i.e., the native "
"byte order for integers on the host machine."
msgstr ""

#. type: Plain text
#: build/C/man2/eventfd.2:97
msgid ""
"The semantics of B<read>(2)  depend on whether the eventfd counter currently "
"has a nonzero value and whether the B<EFD_SEMAPHORE> flag was specified when "
"creating the eventfd file descriptor:"
msgstr ""

#. type: IP
#: build/C/man2/eventfd.2:98 build/C/man2/eventfd.2:105
#: build/C/man2/eventfd.2:112 build/C/man2/eventfd.2:157
#: build/C/man2/eventfd.2:167 build/C/man2/eventfd.2:177
#: build/C/man2/prctl.2:606 build/C/man2/prctl.2:611 build/C/man2/prctl.2:616
#: build/C/man2/prctl.2:626 build/C/man3/psignal.3:103
#: build/C/man3/psignal.3:107 build/C/man2/sigaction.2:294
#: build/C/man2/sigaction.2:309 build/C/man2/sigaction.2:325
#: build/C/man2/sigaction.2:340 build/C/man2/sigaction.2:387
#: build/C/man2/sigaction.2:423 build/C/man2/signal.2:66
#: build/C/man2/signal.2:71 build/C/man2/signal.2:78 build/C/man2/signal.2:206
#: build/C/man2/signal.2:210 build/C/man2/signal.2:249
#: build/C/man7/signal.7:147 build/C/man7/signal.7:155
#: build/C/man7/signal.7:613 build/C/man7/signal.7:615
#: build/C/man7/signal.7:636 build/C/man7/signal.7:651
#: build/C/man7/signal.7:655 build/C/man7/signal.7:662
#: build/C/man7/signal.7:678 build/C/man7/signal.7:684
#: build/C/man7/signal.7:691 build/C/man7/signal.7:696
#: build/C/man7/signal.7:715 build/C/man7/signal.7:734
#: build/C/man7/signal.7:741 build/C/man7/signal.7:750
#: build/C/man7/signal.7:758 build/C/man7/signal.7:764
#: build/C/man7/signal.7:769 build/C/man7/signal.7:789
#: build/C/man7/signal.7:808 build/C/man7/signal.7:811
#: build/C/man7/signal.7:814 build/C/man7/signal.7:817
#: build/C/man7/signal.7:822 build/C/man7/signal.7:828
#: build/C/man7/signal.7:832 build/C/man3/sigwait.3:59
#: build/C/man3/sigwait.3:64 build/C/man2/timer_create.2:214
#: build/C/man2/timer_create.2:217 build/C/man2/timer_create.2:220
#: build/C/man2/timer_create.2:224 build/C/man2/timer_create.2:227
#: build/C/man2/timer_create.2:233 build/C/man2/timer_create.2:237
#, no-wrap
msgid "*"
msgstr "*"

#. type: Plain text
#: build/C/man2/eventfd.2:105
msgid ""
"If B<EFD_SEMAPHORE> was not specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing that value, and the "
"counter's value is reset to zero."
msgstr ""
"B<EFD_SEMAPHORE> が指定されておらず、eventfd カウンタが 0 以外の値\n"
"の場合、 B<read>(2) はカウンタ値を格納した 8 バイトの値を返し、\n"
"カウンタ値は 0 にリセットされる。"

#. type: Plain text
#: build/C/man2/eventfd.2:112
msgid ""
"If B<EFD_SEMAPHORE> was specified and the eventfd counter has a nonzero "
"value, then a B<read>(2)  returns 8 bytes containing the value 1, and the "
"counter's value is decremented by 1."
msgstr ""
"B<EFD_SEMAPHORE> が指定されていて eventfd カウンタが 0 以外の値の場合、\n"
"B<read>(2) は値 1 の 8 バイト値を返し、カウンタ値は 1 減算される。"

#. type: Plain text
#: build/C/man2/eventfd.2:122
msgid ""
"If the eventfd counter is zero at the time of the call to B<read>(2), then "
"the call either blocks until the counter becomes nonzero (at which time, the "
"B<read>(2)  proceeds as described above)  or fails with the error B<EAGAIN> "
"if the file descriptor has been made nonblocking."
msgstr ""
"B<read>(2) を呼び出した時点で eventfd カウンタが 0 の場合、 B<read>(2)\n"
"はカウンタが 0 以外になるまで停止 (block) する (0 以外になった時点で\n"
"B<read>(2) は上記で述べた通り実行を再開する)、 もしくはファイルディスク\n"
"リプタが非停止 (nonblocking) に設定されている場合はエラー B<EAGAIN>で\n"
"失敗する。"

#. type: TP
#: build/C/man2/eventfd.2:123
#, no-wrap
msgid "B<write>(2)"
msgstr "B<write>(2)"

#. type: Plain text
#: build/C/man2/eventfd.2:140
msgid ""
"A B<write>(2)  call adds the 8-byte integer value supplied in its buffer to "
"the counter.  The maximum value that may be stored in the counter is the "
"largest unsigned 64-bit value minus 1 (i.e., 0xfffffffffffffffe).  If the "
"addition would cause the counter's value to exceed the maximum, then the "
"B<write>(2)  either blocks until a B<read>(2)  is performed on the file "
"descriptor, or fails with the error B<EAGAIN> if the file descriptor has "
"been made nonblocking."
msgstr ""
"B<write>(2)  は、引き数のバッファで渡された 8 バイトの整数値をカウンタに加算"
"する。 カウンタに格納可能な最大値は unsigned の 64 ビット整数の最大値から 1 "
"を引いた値 (すなわち 0xfffffffffffffffe) である。 加算を行うとカウンタ値が最"
"大値を超過する場合には、 そのファイルディスクリプタに対して B<read>(2)  が実"
"行されるまで、 B<write>(2)  は停止 (block) する、 もしくはファイルディスクリ"
"プタが非停止 (nonblocking)  に設定されている場合はエラー B<EAGAIN> で失敗す"
"る。"

#. type: Plain text
#: build/C/man2/eventfd.2:147
msgid ""
"A B<write>(2)  will fail with the error B<EINVAL> if the size of the "
"supplied buffer is less than 8 bytes, or if an attempt is made to write the "
"value 0xffffffffffffffff."
msgstr ""
"渡されたバッファの大きさが 8 バイト未満の場合、もしくは 値 "
"0xffffffffffffffff を書き込もうとした場合、 B<write>(2)  はエラー B<EINVAL> "
"で失敗する。"

#. type: TP
#: build/C/man2/eventfd.2:147 build/C/man2/signalfd.2:139
#: build/C/man2/timerfd_create.2:243
#, no-wrap
msgid "B<poll>(2), B<select>(2) (and similar)"
msgstr "B<poll>(2), B<select>(2) (と同様の操作)"

#. type: Plain text
#: build/C/man2/eventfd.2:156
msgid ""
"The returned file descriptor supports B<poll>(2)  (and analogously B<epoll>"
"(7))  and B<select>(2), as follows:"
msgstr ""
"返されたファイルディスクリプタは、 B<poll>(2)  (B<epoll>(7)  も同じ) や "
"B<select>(2)  をサポートしており、以下のような動作をする。"

#. type: Plain text
#: build/C/man2/eventfd.2:167
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if the counter has a value greater than 0."
msgstr ""
"カウンタが 0 より大きい値の場合、 ファイルディスクリプタは読み出し可能となる "
"(B<select>(2)  の I<readfds> 引き数や B<poll>(2)  の B<POLLIN> フラグ)。"

#. type: Plain text
#: build/C/man2/eventfd.2:177
msgid ""
"The file descriptor is writable (the B<select>(2)  I<writefds> argument; the "
"B<poll>(2)  B<POLLOUT> flag)  if it is possible to write a value of at least "
"\"1\" without blocking."
msgstr ""
"少なくとも値 \"1\" を、停止 (block) を伴わずに書き込める場合、 ファイルディス"
"クリプタは書き込み可能となる (B<select>(2)  の I<writefds> 引き数や B<poll>"
"(2)  の B<POLLOUT> フラグ)。"

#. type: Plain text
#: build/C/man2/eventfd.2:197
msgid ""
"If an overflow of the counter value was detected, then B<select>(2)  "
"indicates the file descriptor as being both readable and writable, and "
"B<poll>(2)  returns a B<POLLERR> event.  As noted above, B<write>(2)  can "
"never overflow the counter.  However an overflow can occur if 2^64 eventfd "
"\"signal posts\" were performed by the KAIO subsystem (theoretically "
"possible, but practically unlikely).  If an overflow has occurred, then "
"B<read>(2)  will return that maximum I<uint64_t> value (i.e., "
"0xffffffffffffffff)."
msgstr ""
"カウンタ値のオーバーフローが検出された場合、 B<select>(2)  はファイルディスク"
"リプタは読み出し可能と書き込み可能の両方を通知し、 B<poll>(2)  は B<POLLERR> "
"イベントを返す。 上述の通り、 B<write>(2)  でカウンタがオーバーフローすること"
"は決してない。 しかしながら、 KAIO サブシステムによって 2^64 回の eventfd "
"\"signal posts\" が 実行された場合にはオーバーフローが起こり得る (理論的には"
"あり得るが、実用的にはあり得ない)。 オーバーフローが発生した場合、 B<read>"
"(2)  は I<uint64_t> の最大値 (すなわち 0xffffffffffffffff) を返す。"

#. type: Plain text
#: build/C/man2/eventfd.2:205
msgid ""
"The eventfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""
"eventfd ファイルディスクリプタは、これ以外のファイルディスクリプタ 多重 API "
"である B<pselect>(2), B<ppoll>(2), B<epoll>(7)  もサポートしている。"

#. type: TP
#: build/C/man2/eventfd.2:205 build/C/man2/signalfd.2:159
#: build/C/man2/timerfd_create.2:261
#, no-wrap
msgid "B<close>(2)"
msgstr "B<close>(2)"

#. type: Plain text
#: build/C/man2/eventfd.2:210
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same eventfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"ファイルディスクリプタがそれ以降は必要なくなった際には、クローズすべきであ"
"る。 同じ eventfd オブジェクトに関連付けられたファイルディスクリプタが全て ク"
"ローズされると、そのオブジェクト用の資源がカーネルにより解放される。"

#. type: Plain text
#: build/C/man2/eventfd.2:222
msgid ""
"A copy of the file descriptor created by B<eventfd>()  is inherited by the "
"child produced by B<fork>(2).  The duplicate file descriptor is associated "
"with the same eventfd object.  File descriptors created by B<eventfd>()  are "
"preserved across B<execve>(2), unless the close-on-exec flag has been set."
msgstr ""
"B<fork>(2) で生成された子プロセスは、 B<eventfd>() で生成されたファイル\n"
"ディスクリプタのコピーを継承する。 複製されたファイルディスクリプタは同\n"
"じ eventfd オブジェクトに関連付けられる。\n"
"close-on-exec フラグが設定されていない場合、 B<execve>(2) の前後で\n"
"B<eventfd>() で生成されたファイルディスクリプタは保持される。"

#. type: Plain text
#: build/C/man2/eventfd.2:229
msgid ""
"On success, B<eventfd>()  returns a new eventfd file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<eventfd>()  は新規の eventfd ファイルディスクリプタを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/eventfd.2:230 build/C/man2/getitimer.2:130
#: build/C/man2/kill.2:105 build/C/man2/killpg.2:94 build/C/man2/prctl.2:568
#: build/C/man2/prctl.2:573 build/C/man2/prctl.2:585 build/C/man2/prctl.2:590
#: build/C/man2/prctl.2:599 build/C/man2/rt_sigqueueinfo.2:136
#: build/C/man2/sigaction.2:664 build/C/man2/sigaltstack.2:140
#: build/C/man3/siginterrupt.3:77 build/C/man2/signal.2:101
#: build/C/man2/signalfd.2:268 build/C/man2/signalfd.2:276
#: build/C/man2/sigprocmask.2:102 build/C/man3/sigqueue.3:96
#: build/C/man3/sigsetops.3:122 build/C/man3/sigwait.3:72
#: build/C/man2/sigwaitinfo.2:125 build/C/man2/timer_create.2:177
#: build/C/man2/timer_delete.2:58 build/C/man2/timer_getoverrun.2:88
#: build/C/man2/timer_settime.2:187 build/C/man2/timer_settime.2:195
#: build/C/man2/timerfd_create.2:304 build/C/man2/timerfd_create.2:312
#: build/C/man2/timerfd_create.2:348 build/C/man2/timerfd_create.2:355
#: build/C/man2/timerfd_create.2:361 build/C/man2/tkill.2:74
#: build/C/man2/wait.2:416
#, no-wrap
msgid "B<EINVAL>"
msgstr "B<EINVAL>"

#. type: Plain text
#: build/C/man2/eventfd.2:234
msgid "An unsupported value was specified in I<flags>."
msgstr ""

#. type: TP
#: build/C/man2/eventfd.2:234 build/C/man2/signalfd.2:283
#: build/C/man2/timerfd_create.2:319
#, no-wrap
msgid "B<EMFILE>"
msgstr "B<EMFILE>"

#. type: Plain text
#: build/C/man2/eventfd.2:237
msgid "The per-process limit on open file descriptors has been reached."
msgstr ""
"オープン済みのファイルディスクリプタの数がプロセスあたりの上限に 達していた。"

#. type: TP
#: build/C/man2/eventfd.2:237 build/C/man2/signalfd.2:286
#: build/C/man2/timerfd_create.2:322
#, no-wrap
msgid "B<ENFILE>"
msgstr "B<ENFILE>"

#. type: Plain text
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:290
#: build/C/man2/timerfd_create.2:326
msgid ""
"The system-wide limit on the total number of open files has been reached."
msgstr "オープン済みのファイル総数がシステム全体の上限に達していた。"

#. type: TP
#: build/C/man2/eventfd.2:241 build/C/man2/signalfd.2:290
#: build/C/man2/timerfd_create.2:326
#, no-wrap
msgid "B<ENODEV>"
msgstr "B<ENODEV>"

#. type: Plain text
#: build/C/man2/eventfd.2:249 build/C/man2/signalfd.2:293
#: build/C/man2/timerfd_create.2:329
msgid "Could not mount (internal) anonymous inode device."
msgstr "(カーネル内の) 無名 inode デバイスをマウントできなかった。"

#. type: TP
#: build/C/man2/eventfd.2:249 build/C/man2/sigaltstack.2:145
#: build/C/man2/signalfd.2:293 build/C/man2/timer_create.2:185
#: build/C/man2/timerfd_create.2:329
#, no-wrap
msgid "B<ENOMEM>"
msgstr "B<ENOMEM>"

#. type: Plain text
#: build/C/man2/eventfd.2:253
msgid "There was insufficient memory to create a new eventfd file descriptor."
msgstr ""
"新しい eventfd ファイルディスクリプタを生成するのに十分なメモリがなかった。"

#. type: SH
#: build/C/man2/eventfd.2:253 build/C/man2/prctl.2:720
#: build/C/man3/psignal.3:93 build/C/man2/rt_sigqueueinfo.2:164
#: build/C/man2/signalfd.2:296 build/C/man3/sigqueue.3:110
#: build/C/man2/timer_create.2:189 build/C/man2/timer_delete.2:62
#: build/C/man2/timer_getoverrun.2:92 build/C/man2/timer_settime.2:201
#: build/C/man2/timerfd_create.2:367 build/C/man2/tkill.2:85
#, no-wrap
msgid "VERSIONS"
msgstr "バージョン"

#.  eventfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/eventfd.2:266
msgid ""
"B<eventfd>()  is available on Linux since kernel 2.6.22.  Working support is "
"provided in glibc since version 2.8.  The B<eventfd2>()  system call (see "
"NOTES) is available on Linux since kernel 2.6.27.  Since version 2.9, the "
"glibc B<eventfd>()  wrapper will employ the B<eventfd2>()  system call, if "
"it is supported by the kernel."
msgstr ""
"B<eventfd>()  はカーネル 2.6.22 以降の Linux で利用可能である。 正しく動作す"
"る glibc 側のサポートはバージョン 2.8 以降で提供されている。 B<eventfd2>()  "
"システムコール (「注意」参照) は カーネル 2.6.27 以降の Linux で利用可能であ"
"る。 バージョン 2.9 以降では、glibc の B<eventfd>()  のラッパー関数は、カーネ"
"ルが対応していれば B<eventfd2>()  システムコールを利用する。"

#. type: Plain text
#: build/C/man2/eventfd.2:271
msgid "B<eventfd>()  and B<eventfd2>()  are Linux-specific."
msgstr "B<eventfd>()  と B<eventfd2>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/eventfd.2:279
msgid ""
"Applications can use an eventfd file descriptor instead of a pipe (see "
"B<pipe>(2))  in all cases where a pipe is used simply to signal events.  The "
"kernel overhead of an eventfd file descriptor is much lower than that of a "
"pipe, and only one file descriptor is required (versus the two required for "
"a pipe)."
msgstr ""
"アプリケーションは、パイプをイベントを通知するためだけに使用している 全ての場"
"面において、パイプの代わりに eventfd ファイルディスクリプタを 使用することが"
"できる。 eventfd ファイルディスクリプタを使う方が、パイプを使う場合に比べて "
"カーネルでのオーバヘッドは比べるとずっと小さく、ファイルディスクリプタも 一つ"
"しか必要としない (パイプの場合は二つ必要である)。"

#.  or eventually syslets/threadlets
#. type: Plain text
#: build/C/man2/eventfd.2:285
msgid ""
"When used in the kernel, an eventfd file descriptor can provide a kernel-"
"userspace bridge allowing, for example, functionalities like KAIO (kernel "
"AIO)  to signal to a file descriptor that some operation is complete."
msgstr ""
"カーネル内で使用すると、eventfd ファイルディスクリプタは カーネル空間とユーザ"
"空間のブリッジ機能を提供することができ、 例えば KAIO (kernel AIO)  のような機"
"能が、あるファイルディスクリプタに何らかの操作が完了したことを 通知することが"
"できる。"

#. type: Plain text
#: build/C/man2/eventfd.2:302
msgid ""
"A key point about an eventfd file descriptor is that it can be monitored "
"just like any other file descriptor using B<select>(2), B<poll>(2), or "
"B<epoll>(7).  This means that an application can simultaneously monitor the "
"readiness of \"traditional\" files and the readiness of other kernel "
"mechanisms that support the eventfd interface.  (Without the B<eventfd>()  "
"interface, these mechanisms could not be multiplexed via B<select>(2), "
"B<poll>(2), or B<epoll>(7).)"
msgstr ""
"eventfd ファイルディスクリプタの重要な点は、 eventfd ファイルディスクリプタ"
"が B<select>(2), B<poll>(2), B<epoll>(7)  を使って他のファイルディスクリプタ"
"と全く同様に監視できる点である。 このことは、アプリケーションは「従来の "
"(traditional)」 ファイルの状態変化と eventfd インタフェースをサポートする他の"
"カーネル機構の状態変化を同時に監視 できることを意味する (B<eventfd>()  インタ"
"フェースがない時には、これらのカーネル機構は B<select>(2), B<poll>(2), "
"B<epoll>(7)  経由で多重することはできなかった)。"

#. type: SS
#: build/C/man2/eventfd.2:302 build/C/man2/signalfd.2:333
#, no-wrap
msgid "Underlying Linux system calls"
msgstr "下層にある Linux のシステムコール"

#. type: Plain text
#: build/C/man2/eventfd.2:316
msgid ""
"There are two underlying Linux system calls: B<eventfd>()  and the more "
"recent B<eventfd2>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  The glibc wrapper function will use B<eventfd2>()  where it is "
"available."
msgstr ""
"下層にある Linux システムコールは二種類あり、 B<eventfd>()  と、もっと新しい "
"B<eventfd2>()  である。 B<eventfd>()  は I<flags> 引き数を実装していない。 "
"B<eventfd2>()  では上記の値の I<flags> が実装されている。 glibc のラッパー関"
"数は、 B<eventfd2>()  が利用可能であれば、これを使用する。"

#. type: SS
#: build/C/man2/eventfd.2:316
#, no-wrap
msgid "Additional glibc features"
msgstr "glibc の追加機能"

#. type: Plain text
#: build/C/man2/eventfd.2:320
msgid ""
"The GNU C library defines an additional type, and two functions that attempt "
"to abstract some of the details of reading and writing on an eventfd file "
"descriptor:"
msgstr ""
"GNU C ライブラリは、eventfd ファイルディスクリプタの読み出しと書き込みに を関"
"する詳細のいくつか抽象化するために、一つの型と、二つの関数を追加で 定義してい"
"る。"

#. type: Plain text
#: build/C/man2/eventfd.2:324
#, no-wrap
msgid "typedef uint64_t eventfd_t;\n"
msgstr "typedef uint64_t eventfd_t;\n"

#. type: Plain text
#: build/C/man2/eventfd.2:327
#, no-wrap
msgid ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"
msgstr ""
"int eventfd_read(int fd, eventfd_t *value);\n"
"int eventfd_write(int fd, eventfd_t value);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:334
msgid ""
"The functions perform the read and write operations on an eventfd file "
"descriptor, returning 0 if the correct number of bytes was transferred, or "
"-1 otherwise."
msgstr ""
"これらの関数は、eventfd ファイルディスクリプタに対する読み出しと 書き込みの操"
"作を実行し、正しいバイト数が転送された場合には 0 を返し、そうでない場合は -1 "
"を返す。"

#. type: SH
#: build/C/man2/eventfd.2:334 build/C/man2/sigaction.2:784
#: build/C/man2/sigaltstack.2:213 build/C/man2/signalfd.2:357
#: build/C/man3/sigwait.3:83 build/C/man2/timer_create.2:251
#: build/C/man2/timer_getoverrun.2:125 build/C/man2/timer_settime.2:205
#: build/C/man2/timerfd_create.2:372 build/C/man2/wait.2:522
#, no-wrap
msgid "EXAMPLE"
msgstr "例"

#. type: Plain text
#: build/C/man2/eventfd.2:343
msgid ""
"The following program creates an eventfd file descriptor and then forks to "
"create a child process.  While the parent briefly sleeps, the child writes "
"each of the integers supplied in the program's command-line arguments to the "
"eventfd file descriptor.  When the parent has finished sleeping, it reads "
"from the eventfd file descriptor."
msgstr ""
"以下のプログラムは eventfd ファイルディスクリプタを生成し、 その後 fork を実"
"行して子プロセスを生成する。 親プロセスが少しの間 sleep する間に、子プロセス"
"は プログラムのコマンドライン引き数で指定された整数(列)をそれぞれ eventfd "
"ファイルディスクリプタに書き込む。 親プロセスは sleep を完了すると eventfd "
"ファイルディスクリプタから 読み出しを行う。"

#. type: Plain text
#: build/C/man2/eventfd.2:345
msgid "The following shell session shows a sample run of the program:"
msgstr "以下に示すシェルセッションにこのプログラムの使い方を示す。"

#. type: Plain text
#: build/C/man2/eventfd.2:357
#, no-wrap
msgid ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"
msgstr ""
"$B< ./a.out 1 2 4 7 14>\n"
"Child writing 1 to efd\n"
"Child writing 2 to efd\n"
"Child writing 4 to efd\n"
"Child writing 7 to efd\n"
"Child writing 14 to efd\n"
"Child completed write loop\n"
"Parent about to read\n"
"Parent read 28 (0x1c) from efd\n"

#. type: SS
#: build/C/man2/eventfd.2:359 build/C/man2/signalfd.2:380
#: build/C/man2/timerfd_create.2:400 build/C/man2/wait.2:557
#, no-wrap
msgid "Program source"
msgstr "プログラムのソース"

#. type: Plain text
#: build/C/man2/eventfd.2:367
#, no-wrap
msgid ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"
msgstr ""
"#include E<lt>sys/eventfd.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>             /* Definition of uint64_t */\n"

#. type: Plain text
#: build/C/man2/eventfd.2:370 build/C/man2/signalfd.2:391
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"    do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/eventfd.2:377
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    int efd, j;\n"
"    uint64_t u;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/eventfd.2:382
#, no-wrap
msgid ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc E<lt> 2) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>numE<gt>...\\en\", argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/eventfd.2:386
#, no-wrap
msgid ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"
msgstr ""
"    efd = eventfd(0, 0);\n"
"    if (efd == -1)\n"
"        handle_error(\"eventfd\");\n"

#. type: Plain text
#: build/C/man2/eventfd.2:398
#, no-wrap
msgid ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"
msgstr ""
"    switch (fork()) {\n"
"    case 0:\n"
"        for (j = 1; j E<lt> argc; j++) {\n"
"            printf(\"Child writing %s to efd\\en\", argv[j]);\n"
"            u = strtoull(argv[j], NULL, 0);\n"
"                    /* strtoull() allows various bases */\n"
"            s = write(efd, &u, sizeof(uint64_t));\n"
"            if (s != sizeof(uint64_t))\n"
"                handle_error(\"write\");\n"
"        }\n"
"        printf(\"Child completed write loop\\en\");\n"

#. type: Plain text
#: build/C/man2/eventfd.2:400
#, no-wrap
msgid "        exit(EXIT_SUCCESS);\n"
msgstr "        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:403
#, no-wrap
msgid ""
"    default:\n"
"        sleep(2);\n"
msgstr ""
"    default:\n"
"        sleep(2);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:411
#, no-wrap
msgid ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"
msgstr ""
"        printf(\"Parent about to read\\en\");\n"
"        s = read(efd, &u, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
"        printf(\"Parent read %llu (0x%llx) from efd\\en\",\n"
"                (unsigned long long) u, (unsigned long long) u);\n"
"        exit(EXIT_SUCCESS);\n"

#. type: Plain text
#: build/C/man2/eventfd.2:416
#, no-wrap
msgid ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"
msgstr ""
"    case -1:\n"
"        handle_error(\"fork\");\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/eventfd.2:428
msgid ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), B<signalfd>"
"(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), B<sem_overview>(7)"
msgstr ""
"B<futex>(2), B<pipe>(2), B<poll>(2), B<read>(2), B<select>(2), B<signalfd>"
"(2), B<timerfd_create>(2), B<write>(2), B<epoll>(7), B<sem_overview>(7)"

#. type: TH
#: build/C/man2/getitimer.2:7
#, no-wrap
msgid "GETITIMER"
msgstr "GETITIMER"

#. type: Plain text
#: build/C/man2/getitimer.2:10
msgid "getitimer, setitimer - get or set value of an interval timer"
msgstr "getitimer, setitimer - インターバル・タイマーの値を取得または設定する"

#. type: Plain text
#: build/C/man2/getitimer.2:13
#, no-wrap
msgid "B<#include E<lt>sys/time.hE<gt>>\n"
msgstr "B<#include E<lt>sys/time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/getitimer.2:15
#, no-wrap
msgid "B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"
msgstr "B<int getitimer(int >I<which>B<, struct itimerval *>I<curr_value>B<);>\n"

#. type: Plain text
#: build/C/man2/getitimer.2:18
#, no-wrap
msgid ""
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"
msgstr ""
"B<int setitimer(int >I<which>B<, const struct itimerval *>I<new_value>B<,>\n"
"B<              struct itimerval *>I<old_value>B<);>\n"

#. type: Plain text
#: build/C/man2/getitimer.2:24
msgid ""
"The system provides each process with three interval timers, each "
"decrementing in a distinct time domain.  When any timer expires, a signal is "
"sent to the process, and the timer (potentially) restarts."
msgstr ""
"システムは 1 個のプロセスにつき 3 個のインターバル・タイマーを提供する。 それ"
"ぞれのタイマーは別々の時間領域で減少する。 どのタイマーも満了するとプロセスに"
"シグナルが送られ、 タイマーは (設定によっては) 再び開始される。"

#. type: TP
#: build/C/man2/getitimer.2:24
#, no-wrap
msgid "B<ITIMER_REAL>"
msgstr "B<ITIMER_REAL>"

#. type: Plain text
#: build/C/man2/getitimer.2:29
msgid "decrements in real time, and delivers B<SIGALRM> upon expiration."
msgstr "実時間 (real time) で減少し、満了すると B<SIGALRM> が送られる。"

#. type: TP
#: build/C/man2/getitimer.2:29
#, no-wrap
msgid "B<ITIMER_VIRTUAL>"
msgstr "B<ITIMER_VIRTUAL>"

#. type: Plain text
#: build/C/man2/getitimer.2:34
msgid ""
"decrements only when the process is executing, and delivers B<SIGVTALRM> "
"upon expiration."
msgstr ""
"プロセスが実行されている間のみ減少し、満了すると B<SIGVTALRM> が送られる。"

#. type: TP
#: build/C/man2/getitimer.2:34
#, no-wrap
msgid "B<ITIMER_PROF>"
msgstr "B<ITIMER_PROF>"

#. type: Plain text
#: build/C/man2/getitimer.2:44
msgid ""
"decrements both when the process executes and when the system is executing "
"on behalf of the process.  Coupled with B<ITIMER_VIRTUAL>, this timer is "
"usually used to profile the time spent by the application in user and kernel "
"space.  B<SIGPROF> is delivered upon expiration."
msgstr ""
"プロセスが実行されていて、 かつシステムがそのプロセスのために処理を行なってい"
"る間に減少する。 多くの場合、このタイマーは B<ITIMER_VIRTUAL> と組み合わされ"
"て、アプリケーションがカーネル空間とユーザー空間で どれだけの時間を過ごしたか"
"をプロファイルするのに使用される。 満了すると B<SIGPROF> が送られる。"

#. type: Plain text
#: build/C/man2/getitimer.2:46
msgid "Timer values are defined by the following structures:"
msgstr "タイマーの値は以下の構造体によって定義される:"

#. type: Plain text
#: build/C/man2/getitimer.2:54
#, no-wrap
msgid ""
"struct itimerval {\n"
"    struct timeval it_interval; /* next value */\n"
"    struct timeval it_value;    /* current value */\n"
"};\n"
msgstr ""
"struct itimerval {\n"
"    struct timeval it_interval; /* next value */\n"
"    struct timeval it_value;    /* current value */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getitimer.2:59
#, no-wrap
msgid ""
"struct timeval {\n"
"    long tv_sec;                /* seconds */\n"
"    long tv_usec;               /* microseconds */\n"
"};\n"
msgstr ""
"struct timeval {\n"
"    long tv_sec;                /* seconds */\n"
"    long tv_usec;               /* microseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man2/getitimer.2:81
msgid ""
"The function B<getitimer>()  fills the structure pointed to by I<curr_value> "
"with the current setting for the timer specified by I<which> (one of "
"B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>).  The element "
"I<it_value> is set to the amount of time remaining on the timer, or zero if "
"the timer is disabled.  Similarly, I<it_interval> is set to the reset value."
msgstr ""
"B<getitimer>()  関数は、 I<which> で指定されたタイマー (B<ITIMER_REAL>, "
"B<ITIMER_VIRTUAL>, B<ITIMER_PROF> のどれか) の現在の設定を、 I<curr_value> で"
"指定された構造体に格納する。 I<it_value> 要素にはタイマーの残り時間が設定され"
"る。タイマーがオフの場合は ゼロが設定される。同様に I<it_interval> には初期値"
"が設定される。"

#. type: Plain text
#: build/C/man2/getitimer.2:89
msgid ""
"The function B<setitimer>()  sets the specified timer to the value in "
"I<new_value>.  If I<old_value> is non-NULL, the old value of the timer is "
"stored there."
msgstr ""
"B<setitimer>()  関数は指定されたタイマーに I<new_value> の値を設定する。 "
"I<old_value> が NULL 以外の場合、タイマーの古い値が I<old_value> に格納され"
"る。"

#. type: Plain text
#: build/C/man2/getitimer.2:99
msgid ""
"Timers decrement from I<it_value> to zero, generate a signal, and reset to "
"I<it_interval>.  A timer which is set to zero (I<it_value> is zero or the "
"timer expires and I<it_interval> is zero) stops."
msgstr ""
"タイマーは I<it_value> からゼロへ向けて減っていき、シグナルを生成し、 "
"I<it_interval> に初期化される。 タイマーがゼロに設定された場合 (I<it_value> "
"がゼロか、タイマーが満了した時に I<it_interval> がゼロの場合) は停止する。"

#. type: Plain text
#: build/C/man2/getitimer.2:105
msgid ""
"Both I<tv_sec> and I<tv_usec> are significant in determining the duration of "
"a timer."
msgstr "タイマーの期間は I<tv_sec> と I<tv_usec> の両方により決定される。"

#. type: Plain text
#: build/C/man2/getitimer.2:117
msgid ""
"Timers will never expire before the requested time, but may expire some "
"(short) time afterward, which depends on the system timer resolution and on "
"the system load; see B<time>(7).  (But see BUGS below.)  Upon expiration, a "
"signal will be generated and the timer reset.  If the timer expires while "
"the process is active (always true for B<ITIMER_VIRTUAL>)  the signal will "
"be delivered immediately when generated.  Otherwise the delivery will be "
"offset by a small time dependent on the system loading."
msgstr ""
"要求した時間がくる前にタイマーが満了することはないが、 逆にある (短い) 時間だ"
"け満了が遅れることはある。 どれだけ遅れるかはシステムの時間分解能とシステムの"
"負荷に依存する (B<time>(7)  参照; 但し、バグの項も参照のこと)。 タイマーが満"
"了するとシグナルが生成され、タイマーは初期化される。 プロセスがアクティブな"
"時 (B<ITIMER_VIRTUAL> の場合には常にそうである) にタイマーが満了した場合、生"
"成されたシグナルは すぐに配送される。それ以外の場合は、システムの負荷により少"
"しの時間だけ 遅れて配送される。"

#. type: Plain text
#: build/C/man2/getitimer.2:122 build/C/man2/killpg.2:93
#: build/C/man2/tkill.2:73
msgid ""
"On success, zero is returned.  On error, -1 is returned, and I<errno> is set "
"appropriately."
msgstr ""
"成功した場合、0 が返される。エラーが発生した場合、-1 が返され、 I<errno> が適"
"切に設定される。"

#. type: TP
#: build/C/man2/getitimer.2:123 build/C/man2/prctl.2:564
#: build/C/man2/sigaction.2:660 build/C/man2/sigaltstack.2:136
#: build/C/man2/sigpending.2:55 build/C/man2/sigprocmask.2:95
#: build/C/man2/sigsuspend.2:73 build/C/man2/timer_settime.2:180
#: build/C/man2/timerfd_create.2:341
#, no-wrap
msgid "B<EFAULT>"
msgstr "B<EFAULT>"

#. type: Plain text
#: build/C/man2/getitimer.2:130 build/C/man2/timerfd_create.2:348
msgid "I<new_value>, I<old_value>, or I<curr_value> is not valid a pointer."
msgstr "I<new_value>, I<old_value>, I<curr_value> が有効なポインタではない。"

#. type: Plain text
#: build/C/man2/getitimer.2:143
msgid ""
"I<which> is not one of B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, or B<ITIMER_PROF>; "
"or (since Linux 2.6.22) one of the I<tv_usec> fields in the structure "
"pointed to by I<new_value> contains a value outside the range 0 to 999999."
msgstr ""
"I<which> が B<ITIMER_REAL>, B<ITIMER_VIRTUAL>, B<ITIMER_PROF> のどれでもな"
"い。 または (Linux 2.6.22 以降で)  I<new_value> で指定された構造体の "
"I<tv_usec> フィールドの一つが 0 以上 999999 以下の範囲に入らない値である。"

#. type: Plain text
#: build/C/man2/getitimer.2:153
msgid ""
"POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).  "
"POSIX.1-2008 marks B<getitimer>()  and B<setitimer>()  obsolete, "
"recommending the use of the POSIX timers API (B<timer_gettime>(2), "
"B<timer_settime>(2), etc.) instead."
msgstr ""
"POSIX.1-2001, SVr4, 4.4BSD (このコールは 4.2BSD で始めて現われた).  "
"POSIX.1-2008 では、 B<getitimer>()  と B<setitimer>()  は廃止予定とされてお"
"り、 代わりに POSIX タイマー API (B<timer_gettime>(2), B<timer_settime>(2)  "
"など) を使うことが推奨されている。"

#. type: Plain text
#: build/C/man2/getitimer.2:159
msgid ""
"A child created via B<fork>(2)  does not inherit its parent's interval "
"timers.  Interval timers are preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  で作成された子プロセスは、 親プロセスのインターバル・タイマーを継"
"承しない。 B<execve>(2)  の前後ではインターバル・タイマーは保存される。"

#. type: Plain text
#: build/C/man2/getitimer.2:169
msgid ""
"POSIX.1 leaves the interaction between B<setitimer>()  and the three "
"interfaces B<alarm>(2), B<sleep>(3), and B<usleep>(3)  unspecified."
msgstr ""
"POSIX.1 では、 B<setitimer>()  と、 B<alarm>(2), B<sleep>(3), B<usleep>(3)  "
"という 3 つのインタフェースとの相互の影響については規定していない。"

#. type: SH
#: build/C/man2/getitimer.2:169 build/C/man2/kill.2:160
#: build/C/man3/profil.3:70 build/C/man3/psignal.3:99
#: build/C/man2/sigaction.2:775 build/C/man2/signalfd.2:349
#: build/C/man2/sigpending.2:76 build/C/man3/sigset.3:230
#: build/C/man2/timer_getoverrun.2:112 build/C/man2/timerfd_create.2:534
#, no-wrap
msgid "BUGS"
msgstr "バグ"

#. type: Plain text
#: build/C/man2/getitimer.2:178
msgid ""
"The generation and delivery of a signal are distinct, and only one instance "
"of each of the signals listed above may be pending for a process.  Under "
"very heavy loading, an B<ITIMER_REAL> timer may expire before the signal "
"from a previous expiration has been delivered.  The second signal in such an "
"event will be lost."
msgstr ""
"シグナルの生成と配送は別個のものであり、 前述のシグナルのそれぞれについて一つ"
"だけがプロセスのために 待機する。 非常に重い負荷の下では、 B<ITIMER_REAL> タ"
"イマーでは、時間切れにより生成された一つ前のシグナルが配送される前に、 次の時"
"間切れが起こる場合がある。 そのような場合、 2 個めのイベントに対するシグナル"
"は失われてしまう。"

#. type: Plain text
#: build/C/man2/getitimer.2:193
msgid ""
"On Linux kernels before 2.6.16, timer values are represented in jiffies.  If "
"a request is made set a timer with a value whose jiffies representation "
"exceeds B<MAX_SEC_IN_JIFFIES> (defined in I<include/linux/jiffies.h>), then "
"the timer is silently truncated to this ceiling value.  On Linux/i386 "
"(where, since Linux 2.6.13, the default jiffy is 0.004 seconds), this means "
"that the ceiling value for a timer is approximately 99.42 days.  Since Linux "
"2.6.16, the kernel uses a different internal representation for times, and "
"this ceiling is removed."
msgstr ""
"バージョン 2.6.16 より前の Linux カーネルでは、 タイマーの値は jiffy で表現さ"
"れる。 要求が jiffy 表現で (I<include/linux/jiffies.h> で定義されている)  "
"B<MAX_SEC_IN_JIFFIES> を越える値をタイマーに設定しようとするものの場合、 タイ"
"マーは暗黙にこの上限値に切り詰められる。 Linux/i386 の場合 (Linux 2.6.13 以降"
"では jiffy は 0.004 秒) の場合、 これはタイマーの上限値がおよそ 99.42 日にな"
"ることを意味する。 Linux 2.6.16 以降では、カーネルは時間に関する内部表現とし"
"て 異なる表現を使うようになっており、この上限はなくなった。"

#.  4 Jul 2005: It looks like this bug may remain in 2.4.x.
#. 	http://lkml.org/lkml/2005/7/1/165
#. type: Plain text
#: build/C/man2/getitimer.2:200
msgid ""
"On certain systems (including i386), Linux kernels before version 2.6.12 "
"have a bug which will produce premature timer expirations of up to one jiffy "
"under some circumstances.  This bug is fixed in kernel 2.6.12."
msgstr ""
"(i386 を含む) いくつかのシステムでは、 バージョン 2.6.12 以前の Linux カーネ"
"ルは ある種の状況では 1 jiffy 早くタイマーが終了してしまうというバグがあっ"
"た。 このバグはカーネル 2.6.12 で修正された。"

#.  Bugzilla report 25 Apr 2006:
#.  http://bugzilla.kernel.org/show_bug.cgi?id=6443
#.  "setitimer() should reject noncanonical arguments"
#. type: Plain text
#: build/C/man2/getitimer.2:219
msgid ""
"POSIX.1-2001 says that B<setitimer>()  should fail if a I<tv_usec> value is "
"specified that is outside of the range 0 to 999999.  However, in kernels up "
"to and including 2.6.21, Linux does not give an error, but instead silently "
"adjusts the corresponding seconds value for the timer.  From kernel 2.6.22 "
"onward, this nonconformance has been repaired: an improper I<tv_usec> value "
"results in an B<EINVAL> error."
msgstr ""
"POSIX.1-2001 では B<setitimer>()  は I<tv_usec> の値が 0 から 999999 の範囲外"
"である場合には失敗するべきだとしている。 しかし、2.6.21 以前のカーネルの "
"Linux ではエラーにならず、 対応する秒数の分だけそのタイマーの秒の値が暗黙に調"
"整される。 カーネル 2.6.22 以降では、この標準非準拠の動作は修正され、 "
"I<tv_usec> の値が不適切な場合には B<EINVAL> エラーとなる。"

#. type: Plain text
#: build/C/man2/getitimer.2:226
msgid ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"
msgstr ""
"B<gettimeofday>(2), B<sigaction>(2), B<signal>(2), B<timer_create>(2), "
"B<timerfd_create>(2), B<time>(7)"

#. type: TH
#: build/C/man3/gsignal.3:25
#, no-wrap
msgid "GSIGNAL"
msgstr "GSIGNAL"

#. type: TH
#: build/C/man3/gsignal.3:25 build/C/man3/profil.3:28 build/C/man3/sigvec.3:24
#, no-wrap
msgid "2007-07-26"
msgstr "2007-07-26"

#. type: Plain text
#: build/C/man3/gsignal.3:28
msgid "gsignal, ssignal - software signal facility"
msgstr "gsignal, ssignal - ソフトウェア・シグナル機能"

#. type: Plain text
#: build/C/man3/gsignal.3:31 build/C/man2/kill.2:52 build/C/man3/psignal.3:34
#: build/C/man3/raise.3:33 build/C/man2/sigaction.2:51
#: build/C/man3/siginterrupt.3:35 build/C/man3/sigpause.3:29
#: build/C/man3/sigwait.3:30 build/C/man2/sigwaitinfo.2:29
#, no-wrap
msgid "B<#include E<lt>signal.hE<gt>>\n"
msgstr "B<#include E<lt>signal.hE<gt>>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:33
#, no-wrap
msgid "B<typedef void (*sighandler_t)(int);>\n"
msgstr "B<typedef void (*sighandler_t)(int);>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:35
#, no-wrap
msgid "B<int gsignal(int >I<signum>B<);>\n"
msgstr "B<int gsignal(int >I<signum>B<);>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:37
#, no-wrap
msgid "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"
msgstr "B<sighandler_t ssignal(int >I<signum>B<, sighandler_t >I<action>B<);>\n"

#. type: Plain text
#: build/C/man3/gsignal.3:42 build/C/man2/kill.2:59 build/C/man2/killpg.2:51
#: build/C/man3/profil.3:40 build/C/man3/psignal.3:44
#: build/C/man2/sigaction.2:59 build/C/man2/sigaltstack.2:36
#: build/C/man3/siginterrupt.3:42 build/C/man2/sigpending.2:38
#: build/C/man2/sigprocmask.2:39 build/C/man3/sigqueue.3:37
#: build/C/man3/sigset.3:43 build/C/man3/sigsetops.3:49
#: build/C/man2/sigsuspend.2:38 build/C/man3/sigvec.3:43
#: build/C/man3/sigwait.3:37 build/C/man2/sigwaitinfo.2:39
#: build/C/man2/timer_create.2:46 build/C/man2/timer_delete.2:38
#: build/C/man2/timer_getoverrun.2:38 build/C/man2/timer_settime.2:42
#: build/C/man2/wait.2:68 build/C/man2/wait4.2:54
msgid ""
"Feature Test Macro Requirements for glibc (see B<feature_test_macros>(7)):"
msgstr "glibc 向けの機能検査マクロの要件 (B<feature_test_macros>(7)  参照):"

#. type: Plain text
#: build/C/man3/gsignal.3:47
msgid "B<gsignal>(), B<ssignal>(): _SVID_SOURCE"
msgstr "B<gsignal>(), B<ssignal>(): _SVID_SOURCE"

#. type: Plain text
#: build/C/man3/gsignal.3:55
msgid ""
"Don't use these functions under Linux.  Due to a historical mistake, under "
"Linux these functions are aliases for B<raise>(3)  and B<signal>(2), "
"respectively."
msgstr ""
"Linux ではこれらの関数を使用しないこと。 過去に間違いがあり、Linux では "
"B<gsignal>()  と B<ssignal>()  はそれぞれ B<raise>(3)  と B<signal>(2)  の別"
"名になっている。"

#. type: Plain text
#: build/C/man3/gsignal.3:93
msgid ""
"Elsewhere, on System V-like systems, these functions implement software "
"signaling, entirely independent of the classical B<signal>(2)  and B<kill>"
"(2)  functions.  The function B<ssignal>()  defines the action to take when "
"the software signal with number I<signum> is raised using the function "
"B<gsignal>(), and returns the previous such action or B<SIG_DFL>.  The "
"function B<gsignal>()  does the following: if no action (or the action "
"B<SIG_DFL>)  was specified for I<signum>, then it does nothing and returns "
"0.  If the action B<SIG_IGN> was specified for I<signum>, then it does "
"nothing and returns 1.  Otherwise, it resets the action to B<SIG_DFL> and "
"calls the action function with argument I<signum>, and returns the value "
"returned by that function.  The range of possible values I<signum> varies "
"(often 1-15 or 1-17)."
msgstr ""
"一方、System V 風のシステムでは、これらの関数で、 従来の B<signal>(2)  や "
"B<kill>(2)  の関数群とは完全に独立な、 ソフトウェア・シグナリングを実現してい"
"る。 B<ssignal>()  関数は、番号 I<signum> のソフトウェア・シグナルが "
"B<gsignal>()  関数を使って発生された時にとるべきアクションを定義する。 "
"B<gsignal>()  の返り値は、一つ前に指定されていたアクション、もしくは "
"B<SIG_DFL> である。 B<gsignal>()  は以下のような動作を行う: I<signum> に対し"
"てアクションが指定されていないか、アクション B<SIG_DFL> が指定されていた場"
"合、何もせずに 0 を返す。 I<signum> に対して アクション B<SIG_IGN> が指定され"
"ていた場合、何もせずに 1 を返す。 それ以外の場合、アクションを B<SIG_DFL> に"
"リセットし、引き数に I<signum> を指定してアクション関数を呼び出して、アクショ"
"ン関数の返り値を返す。 I<signum> がとり得る値の範囲は実装により異なる (多くの"
"場合 1〜15 か 1〜17 である)。"

#. type: Plain text
#: build/C/man3/gsignal.3:101
msgid ""
"These functions are available under AIX, DG/UX, HP-UX, SCO, Solaris, Tru64.  "
"They are called obsolete under most of these systems, and are broken under "
"Linux libc and glibc.  Some systems also have B<gsignal_r>()  and "
"B<ssignal_r>()."
msgstr ""
"これらの関数は、AIX, DG/UX, HP-UX, SCO, Solaris, Tru64 で使用可能である。 こ"
"れらのシステムのほとんどで廃止されたことになっており、 Linux の libc および "
"glibc では正しく実装されていない。 B<gsignal_r>()  と B<ssignal_r>()  が実装"
"されているシステムもある。"

#. type: Plain text
#: build/C/man3/gsignal.3:105
msgid "B<kill>(2), B<signal>(2), B<raise>(3)"
msgstr "B<kill>(2), B<signal>(2), B<raise>(3)"

#. type: TH
#: build/C/man2/kill.2:44
#, no-wrap
msgid "KILL"
msgstr "KILL"

#. type: TH
#: build/C/man2/kill.2:44
#, no-wrap
msgid "2009-09-15"
msgstr "2009-09-15"

#. type: Plain text
#: build/C/man2/kill.2:47
msgid "kill - send signal to a process"
msgstr "kill - プロセスにシグナルを送る"

#. type: Plain text
#: build/C/man2/kill.2:50
#, no-wrap
msgid "B<#include E<lt>sys/types.hE<gt>>\n"
msgstr "B<#include E<lt>sys/types.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/kill.2:54
#, no-wrap
msgid "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"
msgstr "B<int kill(pid_t >I<pid>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man2/kill.2:64
msgid ""
"B<kill>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<kill>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man2/kill.2:70
msgid ""
"The B<kill>()  system call can be used to send any signal to any process "
"group or process."
msgstr ""
"システムコールの B<kill>()  は、任意のプロセス・グループもしくはプロセスにシ"
"グナルを 送るのに使われる。"

#. type: Plain text
#: build/C/man2/kill.2:73
msgid ""
"If I<pid> is positive, then signal I<sig> is sent to the process with the ID "
"specified by I<pid>."
msgstr ""
"I<pid> に正の値を指定した場合、シグナル I<sig> が I<pid> で指定された ID を持"
"つプロセスに送られる。"

#. type: Plain text
#: build/C/man2/kill.2:76
msgid ""
"If I<pid> equals 0, then I<sig> is sent to every process in the process "
"group of the calling process."
msgstr ""
"I<pid> に 0 を指定した場合、 呼び出し元のプロセスのプロセス・グループに属する"
"すべてのプロセスに I<sig> で指定したシグナルが送られる。"

#. type: Plain text
#: build/C/man2/kill.2:80
msgid ""
"If I<pid> equals -1, then I<sig> is sent to every process for which the "
"calling process has permission to send signals, except for process 1 "
"(I<init>), but see below."
msgstr ""
"I<pid> に -1 を指定した場合、 I<sig> で指定したシグナルが、 呼び出し元のプロ"
"セスがシグナルを送る許可を持つ全てのプロセスに 送られる。但し、プロセス番号 "
"1 (I<init>) へはシグナルは送られない。 以下の関連部分も参照のこと。"

#. type: Plain text
#: build/C/man2/kill.2:83
msgid ""
"If I<pid> is less than -1, then I<sig> is sent to every process in the "
"process group whose ID is I<-pid>."
msgstr ""
"I<pid> に -1 より小さな値を指定した場合、 ID が I<-pid> のプロセス・グループ"
"に属するすべてのプロセスに I<sig> で指定したシグナルが送られる。"

#. type: Plain text
#: build/C/man2/kill.2:88
msgid ""
"If I<sig> is 0, then no signal is sent, but error checking is still "
"performed; this can be used to check for the existence of a process ID or "
"process group ID."
msgstr ""
"I<sig> に 0 を指定した場合、シグナルは送られないが、 エラーのチェックは行われ"
"る。これを使って、プロセス ID や プロセスグループ ID の存在確認を行うことがで"
"きる。"

#. type: Plain text
#: build/C/man2/kill.2:99 build/C/man2/killpg.2:88
msgid ""
"For a process to have permission to send a signal it must either be "
"privileged (under Linux: have the B<CAP_KILL> capability), or the real or "
"effective user ID of the sending process must equal the real or saved set-"
"user-ID of the target process.  In the case of B<SIGCONT> it suffices when "
"the sending and receiving processes belong to the same session."
msgstr ""
"プロセスがシグナルを送信する許可を持つためには、 プロセスが特権 (Linux では "
"B<CAP_KILL> ケーパビリティ (capability)) を持つか、 送信元プロセスの実ユー"
"ザー ID または実効ユーザー ID が 送信先プロセスの実 set-user-ID または保存 "
"set-user-ID と 等しくなければならない。 B<SIGCONT> の場合、送信プロセスと受信"
"プロセスが 同じセッションに属していれば十分である。"

#. type: Plain text
#: build/C/man2/kill.2:104
msgid ""
"On success (at least one signal was sent), zero is returned.  On error, -1 "
"is returned, and I<errno> is set appropriately."
msgstr ""
"成功した場合 (少なくとも一つのシグナルが送信された場合)、 0 が返される。エ"
"ラーの場合 -1 が返され、 I<errno> が適切に設定される。"

#. type: Plain text
#: build/C/man2/kill.2:108
msgid "An invalid signal was specified."
msgstr "無効なシグナルを指定した。"

#. type: TP
#: build/C/man2/kill.2:108 build/C/man2/killpg.2:98 build/C/man2/prctl.2:639
#: build/C/man2/prctl.2:651 build/C/man2/prctl.2:661 build/C/man2/prctl.2:669
#: build/C/man2/rt_sigqueueinfo.2:143 build/C/man2/sigaltstack.2:149
#: build/C/man3/sigqueue.3:100 build/C/man2/tkill.2:77
#, no-wrap
msgid "B<EPERM>"
msgstr "B<EPERM>"

#. type: Plain text
#: build/C/man2/kill.2:112 build/C/man2/killpg.2:102
msgid ""
"The process does not have permission to send the signal to any of the target "
"processes."
msgstr ""
"プロセスが、受信するプロセスのいずれに対しても シグナルを送る許可を持っていな"
"い。"

#. type: TP
#: build/C/man2/kill.2:112 build/C/man2/killpg.2:102 build/C/man2/killpg.2:106
#: build/C/man2/rt_sigqueueinfo.2:151 build/C/man3/sigqueue.3:106
#: build/C/man2/tkill.2:82
#, no-wrap
msgid "B<ESRCH>"
msgstr "B<ESRCH>"

#. type: Plain text
#: build/C/man2/kill.2:120
msgid ""
"The pid or process group does not exist.  Note that an existing process "
"might be a zombie, a process which already committed termination, but has "
"not yet been B<wait>(2)ed for."
msgstr ""
"指定したプロセスまたはプロセス・グループが存在しなかった。 ゾンビプロセスは存"
"在するプロセスとしてみなされる。 ゾンビプロセスとはすでに処理は終了している"
"が、親プロセスによる B<wait>()  処理が行われていないプロセスのことである。"

#. type: Plain text
#: build/C/man2/kill.2:122 build/C/man2/pause.2:59 build/C/man2/wait.2:423
msgid "SVr4, 4.3BSD, POSIX.1-2001."
msgstr "SVr4, 4.3BSD, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/kill.2:130
msgid ""
"The only signals that can be sent to process ID 1, the I<init> process, are "
"those for which I<init> has explicitly installed signal handlers.  This is "
"done to assure the system is not brought down accidentally."
msgstr ""
"プロセス番号 1 の I<init> プロセスに送ることができるシグナルは、 I<init> が明"
"示的にシグナルハンドラを設定したシグナルだけである。 こうなっているのは、誤っ"
"てシステムをダウンさせないようにするためである。"

#. type: Plain text
#: build/C/man2/kill.2:136
msgid ""
"POSIX.1-2001 requires that I<kill(-1,sig)> send I<sig> to all processes that "
"the calling process may send signals to, except possibly for some "
"implementation-defined system processes.  Linux allows a process to signal "
"itself, but on Linux the call I<kill(-1,sig)> does not signal the calling "
"process."
msgstr ""
"POSIX.1-2001 では、 I<kill(-1,sig)> が 呼び出し元のプロセスがシグナルを送るこ"
"とが出来るプロセス全てに I<sig> を送ることを要求している。 但し、システム実装"
"時に定められたシステムプロセスは シグナルの送信対象から除外される。 Linux で"
"は、プロセスが自分自身にシグナルを送れるようになっているが、 Linux の I<kill"
"(-1,sig)> は呼び出し元のプロセスにはシグナルを送らない。"

#. type: Plain text
#: build/C/man2/kill.2:146
msgid ""
"POSIX.1-2001 requires that if a process sends a signal to itself, and the "
"sending thread does not have the signal blocked, and no other thread has it "
"unblocked or is waiting for it in B<sigwait>(3), at least one unblocked "
"signal must be delivered to the sending thread before the B<kill>()  returns."
msgstr ""
"POSIX.1-2001 では以下の動作になることを要求している。 自分自身にシグナルを送"
"ると、シグナルを送ったスレッドがそのシグナルをブロック しておらず、他のどのス"
"レッドもそのシグナルを受ける状態にもなく B<sigwait>(3)  でそのシグナルを待っ"
"てもいない場合、 B<kill>()  が返る前に少なくとも一つのブロックされていない シ"
"グナルがシグナルを送ったスレッドに配送されなければならない。"

#. type: SS
#: build/C/man2/kill.2:146 build/C/man3/sigpause.3:75 build/C/man2/wait.2:477
#, no-wrap
msgid "Linux Notes"
msgstr "Linux での注意"

#.  In the 0.* kernels things chopped and changed quite
#.  a bit - MTK, 24 Jul 02
#. type: Plain text
#: build/C/man2/kill.2:160
msgid ""
"Across different kernel versions, Linux has enforced different rules for the "
"permissions required for an unprivileged process to send a signal to another "
"process.  In kernels 1.0 to 1.2.2, a signal could be sent if the effective "
"user ID of the sender matched that of the receiver, or the real user ID of "
"the sender matched that of the receiver.  From kernel 1.2.3 until 1.3.77, a "
"signal could be sent if the effective user ID of the sender matched either "
"the real or effective user ID of the receiver.  The current rules, which "
"conform to POSIX.1-2001, were adopted in kernel 1.3.78."
msgstr ""
"Linux では、特権のないプロセスが他のプロセスにシグナルを送信するために 必要な"
"権限についてのルールが、カーネルバージョンにより違っている。 カーネル 1.0 か"
"ら 1.2.2 では、送信側の実効ユーザーID が受信側の 実効ユーザー IDと一致すれば"
"シグナルを送信できた。 カーネル 1.2.3 から 1.3.77では、送信側の実効ユーザー"
"ID が受信側の 実ユーザーID か実効ユーザーID のいずれかと一致すればシグナルを"
"送信できた。 現在のルールは、POSIX.1-2001 に準拠しており、カーネル 1.3.78 以"
"降で 適用されている。"

#. type: Plain text
#: build/C/man2/kill.2:170
msgid ""
"In 2.6 kernels up to and including 2.6.7, there was a bug that meant that "
"when sending signals to a process group, B<kill>()  failed with the error "
"B<EPERM> if the caller did have permission to send the signal to I<any> "
"(rather than I<all>) of the members of the process group.  Notwithstanding "
"this error return, the signal was still delivered to all of the processes "
"for which the caller had permission to signal."
msgstr ""
"バージョン 2.6.7 以前の 2.6 系のカーネルには、 プロセスグループにシグナルを"
"送ったときに、 呼び出し元のプロセスがプロセスグループの (全メンバーではなく) "
"一部のメンバー に対してのみシグナルを送る許可を持っている場合に、 B<kill>()  "
"がエラー B<EPERM> で失敗するというバグがある。 このエラーが返るにもかかわら"
"ず、そのシグナルは呼び出し元が シグナルを送る許可を持つ全てのプロセスへ送られ"
"る。"

#. type: Plain text
#: build/C/man2/kill.2:180
msgid ""
"B<_exit>(2), B<killpg>(2), B<signal>(2), B<tkill>(2), B<exit>(3), B<sigqueue>"
"(3), B<capabilities>(7), B<credentials>(7), B<signal>(7)"
msgstr ""
"B<_exit>(2), B<killpg>(2), B<signal>(2), B<tkill>(2), B<exit>(3), B<sigqueue>"
"(3), B<credentials>(7), B<capabilities>(7), B<signal>(7)"

#. type: TH
#: build/C/man2/killpg.2:40
#, no-wrap
msgid "KILLPG"
msgstr "KILLPG"

#. type: TH
#: build/C/man2/killpg.2:40 build/C/man3/sigset.3:24 build/C/man2/wait4.2:34
#, no-wrap
msgid "2010-09-20"
msgstr "2010-09-20"

#. type: Plain text
#: build/C/man2/killpg.2:43
msgid "killpg - send signal to a process group"
msgstr "killpg - シグナルをプロセス・グループに送る"

#. type: Plain text
#: build/C/man2/killpg.2:47
msgid "B<int killpg(int >I<pgrp>B<, int >I<sig>B<);>"
msgstr "B<int killpg(int >I<pgrp>B<, int >I<sig>B<);>"

#. type: TP
#: build/C/man2/killpg.2:54
#, no-wrap
msgid "B<killpg>():"
msgstr "B<killpg>():"

#. type: Plain text
#: build/C/man2/killpg.2:58 build/C/man2/sigaltstack.2:44
#: build/C/man3/siginterrupt.3:49 build/C/man2/wait4.2:61
msgid ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_BSD_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/killpg.2:68
msgid ""
"B<killpg>()  sends the signal I<sig> to the process group I<pgrp>.  See "
"B<signal>(7)  for a list of signals."
msgstr ""
"B<killpg>()  は I<sig> で指定したシグナルを I<pgrp> で指定したプロセス・グ"
"ループに送る。 シグナルの定義の一覧は B<signal>(7)  を参照のこと。"

#. type: Plain text
#: build/C/man2/killpg.2:77
msgid ""
"If I<pgrp> is 0, B<killpg>()  sends the signal to the calling process's "
"process group.  (POSIX says: If I<pgrp> is less than or equal to 1, the "
"behavior is undefined.)"
msgstr ""
"引き数 I<pgrp> に 0 を指定した場合には B<killpg>()  は呼び出し元のプロセスが"
"属しているプロセス・グループに対してシグナルを送る。 (POSIX では以下のように"
"記述されている: I<pgrp> が 1 以下である場合、動作は未定義である。)"

#. type: Plain text
#: build/C/man2/killpg.2:98
msgid "I<Sig> is not a valid signal number."
msgstr "I<sig> で指定された値は無効なシグナル番号である。"

#. type: Plain text
#: build/C/man2/killpg.2:106
msgid "No process can be found in the process group specified by I<pgrp>."
msgstr ""
"I<pgrp> で指定されたプロセス・グループに属するプロセスが存在しなかった。"

#. type: Plain text
#: build/C/man2/killpg.2:110
msgid ""
"The process group was given as 0 but the sending process does not have a "
"process group."
msgstr ""
"プロセス・グループとして 0 が指定されたが、送信プロセスは プロセス・グループ"
"を持っていない。"

#. type: Plain text
#: build/C/man2/killpg.2:114
msgid ""
"SVr4, 4.4BSD (the B<killpg>()  function call first appeared in 4BSD), "
"POSIX.1-2001."
msgstr "SVr4, 4.4BSD (B<killpg>()  は 4BSD で初めて追加された), POSIX.1-2001。"

#. type: Plain text
#: build/C/man2/killpg.2:128
msgid ""
"There are various differences between the permission checking in BSD-type "
"systems and System V-type systems.  See the POSIX rationale for B<kill>().  "
"A difference not mentioned by POSIX concerns the return value B<EPERM>: BSD "
"documents that no signal is sent and B<EPERM> returned when the permission "
"check failed for at least one target process, while POSIX documents B<EPERM> "
"only when the permission check failed for all target processes."
msgstr ""
"BSD 系システムと System V 系システムでは、 許可のチェックに様々な違いがあ"
"る。 B<kill>(2)  についての POSIX の原理 (rationale) を参照すること。 POSIX "
"で記述されていない違いとしては、返り値 B<EPERM> がある。 BSD では「送信先プロ"
"セスの許可のチェックが 1 つでも失敗した場合は、 シグナルが送信されず、 "
"B<EPERM> が返される」と記述されている。 POSIX では「送信先プロセスの許可の"
"チェックが全て失敗した場合にのみ、 B<EPERM> が返される」と記述されている。"

#. type: Plain text
#: build/C/man2/killpg.2:133
msgid ""
"On Linux, B<killpg>()  is implemented as a library function that makes the "
"call I<kill(-pgrp,\\ sig)>."
msgstr ""
"Linux では、 B<killpg>()  はライブラリ関数として実装されており、 I<kill(-"
"pgrp,\\ sig)> の呼び出しが行われる。"

#. type: Plain text
#: build/C/man2/killpg.2:139
msgid ""
"B<getpgrp>(2), B<kill>(2), B<signal>(2), B<capabilities>(7), B<credentials>"
"(7)"
msgstr ""
"B<getpgrp>(2), B<kill>(2), B<signal>(2), B<credentials>(7), B<capabilities>"
"(7)"

#. type: TH
#: build/C/man2/pause.2:30
#, no-wrap
msgid "PAUSE"
msgstr "PAUSE"

#. type: TH
#: build/C/man2/pause.2:30
#, no-wrap
msgid "2008-10-06"
msgstr "2008-10-06"

#. type: Plain text
#: build/C/man2/pause.2:33
msgid "pause - wait for signal"
msgstr "pause - シグナルを待つ"

#. type: Plain text
#: build/C/man2/pause.2:35 build/C/man3/profil.3:33
msgid "B<#include E<lt>unistd.hE<gt>>"
msgstr "B<#include E<lt>unistd.hE<gt>>"

#. type: Plain text
#: build/C/man2/pause.2:37
msgid "B<int pause(void);>"
msgstr "B<int pause(void);>"

#. type: Plain text
#: build/C/man2/pause.2:42
msgid ""
"B<pause>()  causes the calling process (or thread) to sleep until a signal "
"is delivered that either terminates the process or causes the invocation of "
"a signal-catching function."
msgstr ""
"B<pause>()  は、呼び出したプロセス (またはスレッド) を、 そのプロセスを終了さ"
"せたり、シグナル捕捉関数が起動されるような シグナルが配送されるまで、スリープ"
"させる。"

#.  .BR ERESTARTNOHAND .
#. type: Plain text
#: build/C/man2/pause.2:53
msgid ""
"B<pause>()  only returns when a signal was caught and the signal-catching "
"function returned.  In this case B<pause>()  returns -1, and I<errno> is set "
"to B<EINTR>."
msgstr ""
"B<pause>()  が返るのは、シグナルを受け取りシグナル捕獲関数から返った場合だけ"
"である。 この場合は B<pause>()  は -1 を返し、 I<errno> に B<EINTR> が設定さ"
"れる。"

#. type: TP
#: build/C/man2/pause.2:54 build/C/man2/sigsuspend.2:77
#: build/C/man2/sigwaitinfo.2:119 build/C/man2/wait.2:409
#, no-wrap
msgid "B<EINTR>"
msgstr "B<EINTR>"

#. type: Plain text
#: build/C/man2/pause.2:57
msgid "a signal was caught and the signal-catching function returned."
msgstr "シグナルを受け取り、シグナル捕獲関数から帰ってきた。"

#. type: Plain text
#: build/C/man2/pause.2:64
msgid "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"
msgstr "B<kill>(2), B<select>(2), B<signal>(2), B<sigsuspend>(2)"

#. type: TH
#: build/C/man2/prctl.2:48
#, no-wrap
msgid "PRCTL"
msgstr "PRCTL"

#. type: TH
#: build/C/man2/prctl.2:48
#, no-wrap
msgid "2012-04-23"
msgstr "2012-04-23"

#. type: Plain text
#: build/C/man2/prctl.2:51
msgid "prctl - operations on a process"
msgstr "prctl - プロセスの操作を行なう"

#. type: Plain text
#: build/C/man2/prctl.2:54
#, no-wrap
msgid "B<#include E<lt>sys/prctl.hE<gt>>\n"
msgstr "B<#include E<lt>sys/prctl.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/prctl.2:57
#, no-wrap
msgid ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"
msgstr ""
"B<int prctl(int >I<option>B<, unsigned long >I<arg2>B<, unsigned long >I<arg3>B<,>\n"
"B<          unsigned long >I<arg4>B<, unsigned long >I<arg5>B<);>\n"

#. type: Plain text
#: build/C/man2/prctl.2:64
msgid ""
"B<prctl>()  is called with a first argument describing what to do (with "
"values defined in I<E<lt>linux/prctl.hE<gt>>), and further arguments with a "
"significance depending on the first one.  The first argument can be:"
msgstr ""
"B<prctl>()  の動作は最初の引き数によって決定される (この値は I<E<lt>linux/"
"prctl.hE<gt>> に定義されている)。 残りの引き数は最初の引き数によって変化す"
"る。 一番目の引き数として以下のものを指定できる:"

#. type: TP
#: build/C/man2/prctl.2:64
#, no-wrap
msgid "B<PR_CAPBSET_READ> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_READ> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:76
msgid ""
"Return (as the function result) 1 if the capability specified in I<arg2> is "
"in the calling thread's capability bounding set, or 0 if it is not.  (The "
"capability constants are defined in I<E<lt>linux/capability.hE<gt>>.)  The "
"capability bounding set dictates whether the process can receive the "
"capability through a file's permitted capability set on a subsequent call to "
"B<execve>(2)."
msgstr ""
"で指定されたケーパビリティが呼び出したスレッドのケーパビリティ バインディング"
"セット (capability bounding set) に含まれている場合、 (関数の返り値として) 1 "
"を返し、そうでない場合 0 を返す (ケーパビリティ定数は I<E<lt>linux/"
"capability.hE<gt>> で定義されている)。 ケーパビリティバウンディングセット"
"は、 B<execve>(2)  を呼び出した際に、ファイルの許可 (permitted) ケーパビリ"
"ティの中で そのプロセスが獲得できるケーパビリティを指示するものである。"

#. type: Plain text
#: build/C/man2/prctl.2:81
msgid ""
"If the capability specified in I<arg2> is not valid, then the call fails "
"with the error B<EINVAL>."
msgstr ""
"I<arg2> に指定されたケーパビリティが有効でない場合、 呼び出しはエラー "
"B<EINVAL> で失敗する。"

#. type: TP
#: build/C/man2/prctl.2:81
#, no-wrap
msgid "B<PR_CAPBSET_DROP> (since Linux 2.6.25)"
msgstr "B<PR_CAPBSET_DROP> (Linux 2.6.25 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:90
msgid ""
"If the calling thread has the B<CAP_SETPCAP> capability, then drop the "
"capability specified by I<arg2> from the calling thread's capability "
"bounding set.  Any children of the calling thread will inherit the newly "
"reduced bounding set."
msgstr ""
"呼び出したスレッドがケーパビリティ B<CAP_SETPCAP> を持っている場合、 呼び出し"
"たスレッドのケーパビリティバウンディングセットから I<arg2> で指定されたケーパ"
"ビリティを外す。 呼び出したスレッドの子プロセスは変更後のバウンディングセット"
"を 継承する。"

#. type: Plain text
#: build/C/man2/prctl.2:102
msgid ""
"The call fails with the error: B<EPERM> if the calling thread does not have "
"the B<CAP_SETPCAP>; B<EINVAL> if I<arg2> does not represent a valid "
"capability; or B<EINVAL> if file capabilities are not enabled in the kernel, "
"in which case bounding sets are not supported."
msgstr ""
"呼び出したスレッドが B<CAP_SETPCAP> を持っていない場合、呼び出しはエラー "
"B<EPERM> で失敗する。 I<arg2> に指定されたケーパビリティが有効でない場合、 "
"B<EINVAL> で失敗する。 ファイルケーパビリティがカーネルで有効になっていない場"
"合 (この場合にはバウンディングセットがサポートされない)、 B<EINVAL> で失敗す"
"る。"

#. type: TP
#: build/C/man2/prctl.2:102
#, no-wrap
msgid "B<PR_SET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_SET_DUMPABLE> (Linux 2.3.20 以降)"

#.  See http://marc.theaimsgroup.com/?l=linux-kernel&m=115270289030630&w=2
#.  Subject:    Fix prctl privilege escalation (CVE-2006-2451)
#.  From:       Marcel Holtmann <marcel () holtmann ! org>
#.  Date:       2006-07-12 11:12:00
#. type: Plain text
#: build/C/man2/prctl.2:128
msgid ""
"Set the state of the flag determining whether core dumps are produced for "
"this process upon delivery of a signal whose default behavior is to produce "
"a core dump.  (Normally this flag is set for a process by default, but it is "
"cleared when a set-user-ID or set-group-ID program is executed and also by "
"various system calls that manipulate process UIDs and GIDs).  In kernels up "
"to and including 2.6.12, I<arg2> must be either 0 (process is not dumpable) "
"or 1 (process is dumpable).  Between kernels 2.6.13 and 2.6.17, the value 2 "
"was also permitted, which caused any binary which normally would not be "
"dumped to be dumped readable by root only; for security reasons, this "
"feature has been removed.  (See also the description of I</proc/sys/fs/"
"suid_dumpable> in B<proc>(5).)  Processes that are not dumpable can not be "
"attached via B<ptrace(2)> B<PTRACE_ATTACH>."
msgstr ""
"(Linux 2.3.20 以降) デフォルトの振る舞いではコアダンプを引き起こすよう\n"
"なシグナルを受信したときに、 コアダンプするかどうかを決定するフラグを\n"
"設定する (通常このフラグは、デフォルトではセットされているが、\n"
"set-user-ID あるいは set-group-ID プログラムが実行されたり、 さまざまな\n"
"システムコールによってプロセスの UID や GID が操作されたときに クリアさ\n"
"れる)。 2.6.12 以前のカーネルでは、 I<arg2> は 0 (プロセスはダンプ不可)\n"
"あるいは 1 (プロセスはダンプ可能) の どちらかでなければならない。\n"
"2.6.13 から 2.6.17 までのカーネルでは、値 2 も認められていた。 この値を\n"
"指定すると、通常はダンプされないバイナリが root だけが 読み込み可能な形\n"
"でダンプされた。 セキュリティ上の理由から、この機能は削除された\n"
"(B<proc>(5) の I</proc/sys/fs/suid_dumpable> の説明も参照)。\n"
"ダンプ不可のプロセスを B<ptrace(2)> B<PTRACE_ATTACH> 経由で接続すること\n"
"はできない。"

#. type: TP
#: build/C/man2/prctl.2:128
#, no-wrap
msgid "B<PR_GET_DUMPABLE> (since Linux 2.3.20)"
msgstr "B<PR_GET_DUMPABLE> (Linux 2.3.20 以降)"

#.  Since Linux 2.6.13, the dumpable flag can have the value 2,
#.  but in 2.6.13 PR_GET_DUMPABLE simply returns 1 if the dumpable
#.  flags has a nonzero value.  This was fixed in 2.6.14.
#. type: Plain text
#: build/C/man2/prctl.2:135
msgid ""
"Return (as the function result) the current state of the calling process's "
"dumpable flag."
msgstr ""
"(Linux 2.3.20 以降)  呼び出し元プロセスにおけるダンプ可能フラグの 現在の状態"
"を (関数の返り値として) 返す。"

#. type: TP
#: build/C/man2/prctl.2:135
#, no-wrap
msgid "B<PR_SET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_SET_ENDIAN> (Linux 2.6.18 以降、PowerPC のみ)"

#.  Respectively 0, 1, 2
#. type: Plain text
#: build/C/man2/prctl.2:145
msgid ""
"Set the endian-ness of the calling process to the value given in I<arg2>, "
"which should be one of the following: B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"or B<PR_ENDIAN_PPC_LITTLE> (PowerPC pseudo little endian)."
msgstr ""
"呼び出し元プロセスのエンディアン設定 (endian-ness) を I<arg2> で指定された値"
"に設定する。 指定できる値は B<PR_ENDIAN_BIG>, B<PR_ENDIAN_LITTLE>, "
"B<PR_ENDIAN_PPC_LITTLE> (PowerPC 擬似リトルエンディアン)  のいずれか一つであ"
"る。"

#. type: TP
#: build/C/man2/prctl.2:145
#, no-wrap
msgid "B<PR_GET_ENDIAN> (since Linux 2.6.18, PowerPC only)"
msgstr "B<PR_GET_ENDIAN> (Linux 2.6.18 以降、PowerPC のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:150
msgid ""
"Return the endian-ness of the calling process, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""
"呼び出し元プロセスのエンディアン設定 (endian-ness) を I<(int\\ *) arg2> が指"
"す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:150
#, no-wrap
msgid "B<PR_SET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_SET_FPEMU> (Linux 2.4.18 以降, 2.5.9, ia64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:157
msgid ""
"Set floating-point emulation control bits to I<arg2>.  Pass "
"B<PR_FPEMU_NOPRINT> to silently emulate fp operations accesses, or "
"B<PR_FPEMU_SIGFPE> to not emulate fp operations and send B<SIGFPE> instead."
msgstr ""
"浮動小数点エミュレーション (floating-point emulation) 制御ビットを I<arg2> で"
"指定された値に設定する。 指定できる値は B<PR_FPEMU_NOPRINT> (浮動小数点命令ア"
"クセスを黙って エミュレートする) か B<PR_FPEMU_SIGFPE> (浮動小数点命令をエ"
"ミュレートせず、 代わりに B<SIGFPE> を送る) である。"

#. type: TP
#: build/C/man2/prctl.2:157
#, no-wrap
msgid "B<PR_GET_FPEMU> (since Linux 2.4.18, 2.5.9, only on ia64)"
msgstr "B<PR_GET_FPEMU> (Linux 2.4.18 以降, 2.5.9, ia64 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:162
msgid ""
"Return floating-point emulation control bits, in the location pointed to by "
"I<(int\\ *) arg2>."
msgstr ""
"浮動小数点エミュレーション制御ビットの値を I<(int\\ *) arg2> が指す場所に格納"
"して返す。"

#. type: TP
#: build/C/man2/prctl.2:162
#, no-wrap
msgid "B<PR_SET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_SET_FPEXC> (Linux 2.4.21 および 2.5.32 以降、PowerPC のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:175
msgid ""
"Set floating-point exception mode to I<arg2>.  Pass B<PR_FP_EXC_SW_ENABLE> "
"to use FPEXC for FP exception enables, B<PR_FP_EXC_DIV> for floating-point "
"divide by zero, B<PR_FP_EXC_OVF> for floating-point overflow, "
"B<PR_FP_EXC_UND> for floating-point underflow, B<PR_FP_EXC_RES> for floating-"
"point inexact result, B<PR_FP_EXC_INV> for floating-point invalid operation, "
"B<PR_FP_EXC_DISABLED> for FP exceptions disabled, B<PR_FP_EXC_NONRECOV> for "
"async nonrecoverable exception mode, B<PR_FP_EXC_ASYNC> for async "
"recoverable exception mode, B<PR_FP_EXC_PRECISE> for precise exception mode."
msgstr ""
"浮動小数点例外モード (floating-point exception mode) を I<arg2> で指定された"
"値に設定する。 指定できるのは以下の値である: B<PR_FP_EXC_SW_ENABLE> (FPEXC で"
"浮動小数点例外を有効にする)、 B<PR_FP_EXC_DIV> (0 除算)、 B<PR_FP_EXC_OVF> "
"(オーバーフロー)、 B<PR_FP_EXC_UND> (アンダーフロー)、 B<PR_FP_EXC_RES> (不正"
"確な結果 (inexact result))、 B<PR_FP_EXC_INV> (不正な命令 (invalid "
"operation))、 B<PR_FP_EXC_DISABLED> (浮動小数点例外を無効にする)、 "
"B<PR_FP_EXC_NONRECOV> (async nonrecoverable exception mode)、 "
"B<PR_FP_EXC_ASYNC> (async recoverable exception mode)、 B<PR_FP_EXC_PRECISE> "
"(precise exception mode)。"

#. type: TP
#: build/C/man2/prctl.2:175
#, no-wrap
msgid "B<PR_GET_FPEXC> (since Linux 2.4.21, 2.5.32, only on PowerPC)"
msgstr "B<PR_GET_FPEXC>(Linux 2.4.21 および 2.5.32 以降、PowerPC のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:180
msgid ""
"Return floating-point exception mode, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""
"浮動小数点例外モードの値を I<(int\\ *) arg2> が指す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:180
#, no-wrap
msgid "B<PR_SET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_SET_KEEPCAPS> (Linux 2.2.18 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:198
msgid ""
"Set the state of the thread's \"keep capabilities\" flag, which determines "
"whether the threads's permitted capability set is cleared when a change is "
"made to the threads's user IDs such that the threads's real UID, effective "
"UID, and saved set-user-ID all become nonzero when at least one of them "
"previously had the value 0.  By default, the permitted capability set is "
"cleared when such a change is made; setting the \"keep capabilities\" flag "
"prevents it from being cleared.  I<arg2> must be either 0 (permitted "
"capabilities are cleared)  or 1 (permitted capabilities are kept).  (A "
"thread's I<effective> capability set is always cleared when such a "
"credential change is made, regardless of the setting of the \"keep "
"capabilities\" flag.)  The \"keep capabilities\" value will be reset to 0 on "
"subsequent calls to B<execve>(2)."
msgstr ""
"スレッドの「ケーパビリティ保持」フラグを設定する。\n"
"このフラグは、スレッドの実 UID、実効 UID、保存 set-user-ID のうち少なく\n"
"とも一つが 0 であった状態から、これら全てが 0 以外に変更されたとき、\n"
"スレッドの許可ケーパビリティ集合がクリアされるかどうかを決定する。\n"
"デフォルトでは、このような変更が行われた場合、許可ケーパビリティセット\n"
"はクリアされる。「ケーパビリティ保持」フラグを設定すると、\n"
"許可ケーパビリティセットはクリアされなくなる。\n"
"I<arg2> は 0 (許可ケーパビリティをクリアする) か 1 (許可ケーパビリティ\n"
"を保持する) の どちらかでなければならない。\n"
"(このような ID の変更が行われた場合、「ケーパビリティ保持」フラグの設定\n"
"に関わらず、スレッドのI<実効>ケーパビリティセットは常にクリアされる。)\n"
"B<execve>(2) が呼び出されると、「ケーパビリティ保持」フラグは 0\n"
"にリセットされる。"

#. type: TP
#: build/C/man2/prctl.2:198
#, no-wrap
msgid "B<PR_GET_KEEPCAPS> (since Linux 2.2.18)"
msgstr "B<PR_GET_KEEPCAPS> (Linux 2.2.18 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:202
msgid ""
"Return (as the function result) the current state of the calling threads's "
"\"keep capabilities\" flag."
msgstr ""
"呼び出し元スレッドにおける「ケーパビリティ保持」フラグの 現在の状態を (関数の"
"返り値として) 返す。"

#. type: TP
#: build/C/man2/prctl.2:202
#, no-wrap
msgid "B<PR_SET_NAME> (since Linux 2.6.9)"
msgstr "B<PR_SET_NAME> (Linux 2.6.9 以降)"

#.  TASK_COMM_LEN in include/linux/sched.h
#. type: Plain text
#: build/C/man2/prctl.2:210
msgid ""
"Set the process name for the calling process, using the value in the "
"location pointed to by I<(char\\ *) arg2>.  The name can be up to 16 bytes "
"long, and should be null-terminated if it contains fewer bytes."
msgstr ""
"呼び出し元プロセスのプロセス名を I<(char\\ *) arg2> が指す場所に格納された値"
"を使って設定する。 名前は最大で 16 バイトであり、 それより少ないバイト数の場"
"合は NULL で終端すべきである。"

#. type: TP
#: build/C/man2/prctl.2:210
#, no-wrap
msgid "B<PR_GET_NAME> (since Linux 2.6.11)"
msgstr "B<PR_GET_NAME> (Linux 2.6.11 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:217
msgid ""
"Return the process name for the calling process, in the buffer pointed to by "
"I<(char\\ *) arg2>.  The buffer should allow space for up to 16 bytes; the "
"returned string will be null-terminated if it is shorter than that."
msgstr ""
"呼び出し元プロセスのプロセス名を I<(char\\ *) arg2> が指す場所に格納して返"
"す。 バッファは最大で 16 バイトを格納できるようにすべきである。 返される文字"
"列は、長さが 16 バイトより短い場合は NULL 終端される。"

#. type: TP
#: build/C/man2/prctl.2:217
#, no-wrap
msgid "B<PR_SET_PDEATHSIG> (since Linux 2.1.57)"
msgstr "B<PR_SET_PDEATHSIG> (Linux 2.1.57 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:228
msgid ""
"Set the parent process death signal of the calling process to I<arg2> "
"(either a signal value in the range 1..maxsig, or 0 to clear).  This is the "
"signal that the calling process will get when its parent dies.  This value "
"is cleared for the child of a B<fork>(2)  and (since Linux 2.5.36 / 2.6.23)  "
"when executing a set-user_ID or set-group-ID binary."
msgstr ""
"親プロセス死亡シグナル (parent process death signal) を I<arg2> に設定\n"
"する (設定できるシグナル値の範囲は 1..maxsig であり、0 は通知の解除であ\n"
"る)。 呼び出し元プロセスの親プロセスが死んだ際に、ここで設定した値が シ\n"
"グナルとして通知される。この値は B<fork>(2) の子プロセスでは解除される。\n"
"(Linux 2.5.36 以降および 2.6.23 以降では) set-user-ID もしくは\n"
"set-group-ID されたバイナリを実行した場合にも、このフラグは解除される。"

#. type: TP
#: build/C/man2/prctl.2:228
#, no-wrap
msgid "B<PR_GET_PDEATHSIG> (since Linux 2.3.15)"
msgstr "B<PR_GET_PDEATHSIG> (Linux 2.3.15 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:233
msgid ""
"Return the current value of the parent process death signal, in the location "
"pointed to by I<(int\\ *) arg2>."
msgstr ""
"親プロセス死亡シグナルの現在の値を I<(int\\ *) arg2> が指す場所に格納して返"
"す。"

#. type: TP
#: build/C/man2/prctl.2:233
#, no-wrap
msgid "B<PR_SET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_SET_SECCOMP> (Linux 2.6.23 以降)"

#.  See http://thread.gmane.org/gmane.linux.kernel/542632
#.  [PATCH 0 of 2] seccomp updates
#.  andrea@cpushare.com
#. type: Plain text
#: build/C/man2/prctl.2:257
msgid ""
"Set the secure computing mode for the calling thread.  In the current "
"implementation, I<arg2> must be 1.  After the secure computing mode has been "
"set to 1, the only system calls that the thread is permitted to make are "
"B<read>(2), B<write>(2), B<_exit>(2), and B<sigreturn>(2).  Other system "
"calls result in the delivery of a B<SIGKILL> signal.  Secure computing mode "
"is useful for number-crunching applications that may need to execute "
"untrusted byte code, perhaps obtained by reading from a pipe or socket.  "
"This operation is only available if the kernel is configured with "
"CONFIG_SECCOMP enabled."
msgstr ""
"呼び出したスレッドの secure computing モードを設定する。 現在の実装では、 "
"I<arg2> は 1 にしなければならない。 secure computing モードを 1 に設定する"
"と、 そのスレッドが呼び出しを許可されるシステムコールは B<read>(2), B<write>"
"(2), B<_exit>(2), B<sigreturn>(2)  だけになる。 それ以外のシステムコールを呼"
"び出すと、シグナル B<SIGKILL> が配送される。 パイプやソケットから読み込んだ、"
"信頼できないバイトコードを実行する 必要がある大量の演算を行うアプリケーション"
"において、 secure computing モードは役立つ。 この操作は利用できるのは、カーネ"
"ルが CONFIG_SECCOMP を有効にして 作成されている場合だけである。"

#. type: TP
#: build/C/man2/prctl.2:257
#, no-wrap
msgid "B<PR_GET_SECCOMP> (since Linux 2.6.23)"
msgstr "B<PR_GET_SECCOMP> (Linux 2.6.23 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:270
msgid ""
"Return the secure computing mode of the calling thread.  Not very useful for "
"the current implementation (mode equals 1), but may be useful for other "
"possible future modes: if the caller is not in secure computing mode, this "
"operation returns 0; if the caller is in secure computing mode, then the "
"B<prctl>()  call will cause a B<SIGKILL> signal to be sent to the process.  "
"This operation is only available if the kernel is configured with "
"CONFIG_SECCOMP enabled."
msgstr ""
"呼び出したスレッドの secure computing モードを返す。 現在の実装 (モードは 1 "
"固定) はあまり役に立たないが、 将来他のモードが実装されると役立つようになるか"
"もしれない。 呼び出したスレッドが secure computing モードでなかった場合、 こ"
"の操作は 0 を返す。 呼び出したスレッドが secure computing モードの場合、 "
"B<prctl>()  を呼び出すとシグナル B<SIGKILL> がそのプロセスに送信される。 この"
"操作が利用できるのは、カーネルが CONFIG_SECCOMP を有効にして 作成されている場"
"合だけである。"

#. type: TP
#: build/C/man2/prctl.2:270
#, no-wrap
msgid "B<PR_SET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_SET_SECUREBITS> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:276
msgid ""
"Set the \"securebits\" flags of the calling thread to the value supplied in "
"I<arg2>.  See B<capabilities>(7)."
msgstr ""
"呼び出したスレッドの \"securebits\" フラグを I<arg2> で渡された値に設定す"
"る。 B<capabilities>(7)  参照。"

#. type: TP
#: build/C/man2/prctl.2:276
#, no-wrap
msgid "B<PR_GET_SECUREBITS> (since Linux 2.6.26)"
msgstr "B<PR_GET_SECUREBITS> (Linux 2.6.26 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:282
msgid ""
"Return (as the function result)  the \"securebits\" flags of the calling "
"thread.  See B<capabilities>(7)."
msgstr ""
"呼び出したスレッドの \"securebits\" フラグを (関数の返り値として) 返す。 "
"B<capabilities>(7)  参照。"

#. type: TP
#: build/C/man2/prctl.2:282
#, no-wrap
msgid "B<PR_SET_TIMING> (since Linux 2.6.0-test4)"
msgstr "B<PR_SET_TIMING> (Linux 2.6.0-test4 以降)"

#.  0
#.  1
#.  PR_TIMING_TIMESTAMP doesn't do anything in 2.6.26-rc8,
#.  and looking at the patch history, it appears
#.  that it never did anything.
#. type: Plain text
#: build/C/man2/prctl.2:299
msgid ""
"Set whether to use (normal, traditional) statistical process timing or "
"accurate timestamp-based process timing, by passing B<PR_TIMING_STATISTICAL> "
"or B<PR_TIMING_TIMESTAMP> to I<arg2>.  B<PR_TIMING_TIMESTAMP> is not "
"currently implemented (attempting to set this mode will yield the error "
"B<EINVAL>)."
msgstr ""
"(通常の、伝統的に使われてきた) 統計的なプロセスタイミングを使用するか、\n"
"正確なタイムスタンプに基づくプロセスタイミングを使用するかを設定する。\n"
"I<arg2> に指定できる値は B<PR_TIMING_STATISTICAL> か\n"
"B<PR_TIMING_TIMESTAMP> である。 B<PR_TIMING_TIMESTAMP> は現在のところ実\n"
"装されていない (このモードに設定しようとするとエラー B<EINVAL> が起こる\n"
"ことだろう)。"

#. type: TP
#: build/C/man2/prctl.2:299
#, no-wrap
msgid "B<PR_GET_TIMING> (since Linux 2.6.0-test4)"
msgstr "B<PR_GET_TIMING> (Linux 2.6.0-test4 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:303
msgid ""
"Return (as the function result) which process timing method is currently in "
"use."
msgstr "現在使用中のプロセスタイミングを決める方法を返す。"

#. type: TP
#: build/C/man2/prctl.2:303
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_DISABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_DISABLE> (Linux 2.6.31 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:312
msgid ""
"Disable all performance counters attached to the calling process, regardless "
"of whether the counters were created by this process or another process.  "
"Performance counters created by the calling process for other processes are "
"unaffected.  For more information on performance counters, see the kernel "
"source file I<tools/perf/design.txt>."
msgstr ""

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#. type: Plain text
#: build/C/man2/prctl.2:318
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_DISABLE>; renamed (with same "
"numerical value)  in Linux 2.6.32."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:318
#, no-wrap
msgid "B<PR_TASK_PERF_EVENTS_ENABLE> (since Linux 2.6.31)"
msgstr "B<PR_TASK_PERF_EVENTS_ENABLE> (Linux 2.6.31 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:323
msgid ""
"The converse of B<PR_TASK_PERF_EVENTS_DISABLE>; enable performance counters "
"attached to the calling process."
msgstr ""

#.  commit 1d1c7ddbfab358445a542715551301b7fc363e28
#.  commit cdd6c482c9ff9c55475ee7392ec8f672eddb7be6
#. type: Plain text
#: build/C/man2/prctl.2:330
msgid ""
"Originally called B<PR_TASK_PERF_COUNTERS_ENABLE>; renamed in Linux 2.6.32."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:330
#, no-wrap
msgid "B<PR_SET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_SET_TSC> (Linux 2.6.26 以降, x86 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:343
msgid ""
"Set the state of the flag determining whether the timestamp counter can be "
"read by the process.  Pass B<PR_TSC_ENABLE> to I<arg2> to allow it to be "
"read, or B<PR_TSC_SIGSEGV> to generate a B<SIGSEGV> when the process tries "
"to read the timestamp counter."
msgstr ""
"そのプロセスがタイムスタンプ・カウンタを読み出せるかを決定する フラグの状態を"
"設定する。 読み出しを許可する場合は I<arg2> に B<PR_TSC_ENABLE> を、そのプロ"
"セスがタイムスタンプ・カウンタを読み出そうとした際に B<SIGSEGV> を発生させる"
"場合には B<PR_TSC_SIGSEGV> を渡す。"

#. type: TP
#: build/C/man2/prctl.2:343
#, no-wrap
msgid "B<PR_GET_TSC> (since Linux 2.6.26, x86 only)"
msgstr "B<PR_GET_TSC> (Linux 2.6.26 以降, x86 のみ)"

#. type: Plain text
#: build/C/man2/prctl.2:349
msgid ""
"Return the state of the flag determining whether the timestamp counter can "
"be read, in the location pointed to by I<(int\\ *) arg2>."
msgstr ""
"そのプロセスがタイムスタンプ・カウンタを読み出せるかを決定する フラグの状態"
"を I<(int\\ *) arg2> が指す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:349
#, no-wrap
msgid "B<PR_SET_UNALIGN>"
msgstr "B<PR_SET_UNALIGN>"

#. type: Plain text
#: build/C/man2/prctl.2:359
msgid ""
"(Only on: ia64, since Linux 2.3.48; parisc, since Linux 2.6.15; PowerPC, "
"since Linux 2.6.18; Alpha, since Linux 2.6.22)  Set unaligned access control "
"bits to I<arg2>.  Pass B<PR_UNALIGN_NOPRINT> to silently fix up unaligned "
"user accesses, or B<PR_UNALIGN_SIGBUS> to generate B<SIGBUS> on unaligned "
"user access."
msgstr ""
"(ia64 では Linux 2.3.48 以降; parisc では Linux 2.6.15 以降; PowerPC では "
"Linux 2.6.18 以降; Alpha では　Linux 2.6.22 以降; これらのアーキテクチャの"
"み)  unaligned アクセス制御ビットを I<arg2> で指定された値に設定する。 指定で"
"きる値は B<PR_UNALIGN_NOPRINT> (unaligned なユーザアクセスを黙って 修正する) "
"か B<PR_UNALIGN_SIGBUS> (unaligned なユーザアクセスがあった場合 B<SIGBUS> を"
"生成する) である。"

#. type: TP
#: build/C/man2/prctl.2:359
#, no-wrap
msgid "B<PR_GET_UNALIGN>"
msgstr "B<PR_GET_UNALIGN>"

#. type: Plain text
#: build/C/man2/prctl.2:366
msgid ""
"(see B<PR_SET_UNALIGN> for information on versions and architectures)  "
"Return unaligned access control bits, in the location pointed to by I<(int\\ "
"*) arg2>."
msgstr ""
"(バージョンとアーキテクチャの情報は B<PR_SET_UNALIGN> 参照)  unaligned アクセ"
"ス制御ビットの値を I<(int\\ *) arg2> が指す場所に格納して返す。"

#. type: TP
#: build/C/man2/prctl.2:366
#, no-wrap
msgid "B<PR_MCE_KILL> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:406
msgid ""
"Set the machine check memory corruption kill policy for the current thread.  "
"If I<arg2> is B<PR_MCE_KILL_CLEAR>, clear the thread memory corruption kill "
"policy and use the system-wide default.  (The system-wide default is defined "
"by I</proc/sys/vm/memory_failure_early_kill>; see B<proc>(5).)  If I<arg2> "
"is B<PR_MCE_KILL_SET>, use a thread-specific memory corruption kill policy.  "
"In this case, I<arg3> defines whether the policy is I<early kill> "
"(B<PR_MCE_KILL_EARLY>), I<late kill> (B<PR_MCE_KILL_LATE>), or the system-"
"wide default (B<PR_MCE_KILL_DEFAULT>).  Early kill means that the thread "
"receives a B<SIGBUS> signal as soon as hardware memory corruption is "
"detected inside its address space.  In late kill mode, the process is only "
"killed when it accesses a corrupted page.  See B<sigaction>(2)  for more "
"information on the B<SIGBUS> signal.  The policy is inherited by children.  "
"The remaining unused B<prctl>()  arguments must be zero for future "
"compatibility."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:406
#, no-wrap
msgid "B<PR_MCE_KILL_GET> (since Linux 2.6.32)"
msgstr "B<PR_MCE_KILL_GET> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:412
msgid ""
"Return the current per-process machine check kill policy.  All unused "
"B<prctl>()  arguments must be zero."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:412
#, no-wrap
msgid "B<PR_SET_MM> (since Linux 3.3)"
msgstr "B<PR_SET_MM> (Linux 3.3 以降)"

#. type: Plain text
#: build/C/man2/prctl.2:432
msgid ""
"Modify certain kernel memory map descriptor fields of the calling process.  "
"Usually these fields are set by the kernel and dynamic loader (see B<ld.so>"
"(8)  for more information) and a regular application should not use this "
"feature.  However, there are cases, such as self-modifying programs, where a "
"program might find it useful to change its own memory map.  This feature is "
"available only if the kernel is built with the B<CONFIG_CHECKPOINT_RESTORE> "
"option enabled.  The calling process must have the B<CAP_SYS_RESOURCE> "
"capability.  The value in I<arg2> is one of the options below, while I<arg3> "
"provides a new value for the option."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:433
#, no-wrap
msgid "B<PR_SET_MM_START_CODE>"
msgstr "B<PR_SET_MM_START_CODE>"

#. type: Plain text
#: build/C/man2/prctl.2:442
msgid ""
"Set the address above which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or sharable "
"(see B<mprotect>(2)  and B<mmap>(2)  for more information)."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:442
#, no-wrap
msgid "B<PR_SET_MM_END_CODE>"
msgstr "B<PR_SET_MM_END_CODE>"

#. type: Plain text
#: build/C/man2/prctl.2:447
msgid ""
"Set the address below which the program text can run.  The corresponding "
"memory area must be readable and executable, but not writable or sharable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:447
#, no-wrap
msgid "B<PR_SET_MM_START_DATA>"
msgstr "B<PR_SET_MM_START_DATA>"

#. type: Plain text
#: build/C/man2/prctl.2:453
msgid ""
"Set the address above which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or sharable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:453
#, no-wrap
msgid "B<PR_SET_MM_END_DATA>"
msgstr "B<PR_SET_MM_END_DATA>"

#. type: Plain text
#: build/C/man2/prctl.2:459
msgid ""
"Set the address below which initialized and uninitialized (bss) data are "
"placed.  The corresponding memory area must be readable and writable, but "
"not executable or sharable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:459
#, no-wrap
msgid "B<PR_SET_MM_START_STACK>"
msgstr "B<PR_SET_MM_START_STACK>"

#. type: Plain text
#: build/C/man2/prctl.2:463
msgid ""
"Set the start address of the stack.  The corresponding memory area must be "
"readable and writable."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:463
#, no-wrap
msgid "B<PR_SET_MM_START_BRK>"
msgstr "B<PR_SET_MM_START_BRK>"

#. type: Plain text
#: build/C/man2/prctl.2:475
msgid ""
"Set the address above which the program heap can be expanded with B<brk>(2)  "
"call.  The address must be greater than the ending address of the current "
"program data segment.  In addition, the combined size of the resulting heap "
"and the size of the data segment can't exceed the B<RLIMIT_DATA> resource "
"limit (see B<setrlimit>(2))."
msgstr ""

#. type: TP
#: build/C/man2/prctl.2:475
#, no-wrap
msgid "B<PR_SET_MM_BRK>"
msgstr "B<PR_SET_MM_BRK>"

#.  FIXME The following (until ========) is not yet in mainline kernel,
#.  so commented out for the moment.
#.  .TP
#.  .BR PR_SET_MM_ARG_START
#.  Set the address above which the program command line is placed.
#.  .TP
#.  .BR PR_SET_MM_ARG_END
#.  Set the address below which the program command line is placed.
#.  .TP
#.  .BR PR_SET_MM_ENV_START
#.  Set the address above which the program environment is placed.
#.  .TP
#.  .BR PR_SET_MM_ENV_END
#.  Set the address below which the program environment is placed.
#.  .IP
#.  The address passed with
#.  .BR PR_SET_MM_ARG_START ,
#.  .BR PR_SET_MM_ARG_END ,
#.  .BR PR_SET_MM_ENV_START ,
#.  and
#.  .BR PR_SET_MM_ENV_END
#.  should belong to a process stack area.
#.  Thus, the corresponding memory area must be readable, writable, and
#.  (depending on the kernel configuration) have the
#.  .BR MAP_GROWSDOWN
#.  attribute set (see
#.  .BR mmap (2)).
#.  .TP
#.  .BR PR_SET_MM_AUXV
#.  Set a new auxiliary vector.
#.  The
#.  .I arg3
#.  argument should provide the address of the vector.
#.  The
#.  .I arg4
#.  is the size of the vector.
#.  .TP
#.  .BR PR_SET_MM_EXE_FILE
#.  Supersede the
#.  .IR /proc/pid/exe
#.  symbolic link with a new one pointing to a new executable file
#.  identified by the file descriptor provided in
#.  .I arg3
#.  argument.
#.  The file descriptor should be obtained with a regular
#.  .BR open (2)
#.  call.
#.  .IP
#.  To change the symbolic link, one needs to unmap all existing
#.  executable memory areas, including those created by the kernel itself
#.  (for example the kernel usually creates at least one executable
#.  memory area for the ELF
#.  .IR .text
#.  section).
#.  .IP
#.  The second limitation is that such transitions can be done only once
#.  in a process life time.
#.  Any further attempts will be rejected.
#.  This should help system administrators to monitor unusual
#.  symbolic-link transitions over all process running in a system.
#.  ========== END FIXME
#. type: Plain text
#: build/C/man2/prctl.2:544
msgid ""
"Set the current B<brk>(2)  value.  The requirements for the address are the "
"same as for the B<PR_SET_MM_START_BRK> option."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:563
msgid ""
"On success, B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>, B<PR_CAPBSET_READ>, "
"B<PR_GET_TIMING>, B<PR_GET_SECUREBITS>, B<PR_MCE_KILL_GET>, and (if it "
"returns)  B<PR_GET_SECCOMP> return the nonnegative values described above.  "
"All other I<option> values return 0 on success.  On error, -1 is returned, "
"and I<errno> is set appropriately."
msgstr ""
"成功すると、 B<PR_GET_DUMPABLE>, B<PR_GET_KEEPCAPS>,\n"
"B<PR_CAPBSET_READ>, B<PR_GET_TIMING>, B<PR_GET_SECUREBITS>,\n"
"B<PR_MCE_KILL_GET>, B<PR_GET_SECCOMP> は上述の負でない値を返す (なお、\n"
"B<PR_GET_SECCOMP> は返らない場合もある)。 I<option> が他の値の場合は\n"
"成功時に 0 を返す。\n"
"エラーの場合、-1 を返し、 I<errno> に適切な値を設定する。"

#. type: Plain text
#: build/C/man2/prctl.2:568
msgid "I<arg2> is an invalid address."
msgstr "I<arg2> が不正なアドレスである。"

#. type: Plain text
#: build/C/man2/prctl.2:573
msgid "The value of I<option> is not recognized."
msgstr "I<option> の値が理解できない。"

#. type: Plain text
#: build/C/man2/prctl.2:585
msgid ""
"I<option> is B<PR_MCE_KILL> or B<PR_MCE_KILL_GET> or B<PR_SET_MM>, and "
"unused B<prctl>()  arguments were not specified as zero."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:590
msgid "I<arg2> is not valid value for this I<option>."
msgstr "I<arg2> が指定された I<option> で有効な値ではない。"

#. type: Plain text
#: build/C/man2/prctl.2:599
msgid ""
"I<option> is B<PR_SET_SECCOMP> or B<PR_SET_SECCOMP>, and the kernel was not "
"configured with B<CONFIG_SECCOMP>."
msgstr ""
"I<option> が B<PR_SET_SECCOMP> か B<PR_GET_SECCOMP> だが、カーネルが "
"B<CONFIG_SECCOMP> を有効にして作成されていなかった。"

#. type: Plain text
#: build/C/man2/prctl.2:605
msgid "I<option> is B<PR_SET_MM>, and one of the following is true"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:611
msgid "I<arg4> or I<arg5> is nonzero;"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:616
msgid ""
"I<arg3> is greater than B<TASK_SIZE> (the limit on the size of the user "
"address space for this architecture);"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:626
msgid ""
"I<arg2> is B<PR_SET_MM_START_CODE>, B<PR_SET_MM_END_CODE>, "
"B<PR_SET_MM_START_DATA>, B<PR_SET_MM_END_DATA>, or B<PR_SET_MM_START_STACK,> "
"and the permissions of the corresponding memory area are not as required;"
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:638
msgid ""
"I<arg2> is B<PR_SET_MM_START_BRK> or B<PR_SET_MM_BRK>, and I<arg3> is less "
"than or equal to the end of the data segment or specifies a value that would "
"cause the B<RLIMIT_DATA> resource limit to be exceeded."
msgstr ""

#. type: Plain text
#: build/C/man2/prctl.2:651
msgid ""
"I<option> is B<PR_SET_SECUREBITS>, and the caller does not have the "
"B<CAP_SETPCAP> capability, or tried to unset a \"locked\" flag, or tried to "
"set a flag whose corresponding locked flag was set (see B<capabilities>(7))."
msgstr ""
"I<option> が B<PR_SET_SECUREBITS> で、呼び出し元がケーパビリティ "
"B<CAP_SETPCAP> を持っていない。 または、\"locked\" フラグを解除しようとし"
"た。 または、locked フラグがセットされているフラグをセットしようとした "
"(B<capabilities>(7)  参照)。"

#. type: Plain text
#: build/C/man2/prctl.2:661
msgid ""
"I<option> is B<PR_SET_KEEPCAPS>, and the callers's "
"B<SECURE_KEEP_CAPS_LOCKED> flag is set (see B<capabilities>(7))."
msgstr ""
"I<option> が B<PR_SET_KEEPCAPS> で、呼び出し元のフラグ "
"B<SECURE_KEEP_CAPS_LOCKED> がセットされている (B<capabilities>(7)  参照)。"

#. type: Plain text
#: build/C/man2/prctl.2:669
msgid ""
"I<option> is B<PR_CAPBSET_DROP>, and the caller does not have the "
"B<CAP_SETPCAP> capability."
msgstr ""
"I<option> が B<PR_CAPBSET_DROP> で、呼び出し元がケーパビリティ "
"B<CAP_SETPCAP> を持っていない。"

#.  FIXME The following (until ========) is not yet in mainline kernel,
#.  so commented out for the moment.
#.  .TP
#.  .B EACCES
#.  .I option
#.  is
#.  .BR PR_SET_MM ,
#.  and
#.  .I arg3
#.  is
#.  .BR PR_SET_MM_EXE_FILE ,
#.  the file is not executable.
#.  .TP
#.  .B EBUSY
#.  .I option
#.  is
#.  .BR PR_SET_MM ,
#.  .I arg3
#.  is
#.  .BR PR_SET_MM_EXE_FILE ,
#.  and this the second attempt to change the
#.  .I /proc/pid/exe
#.  symbolic link, which is prohibited.
#.  .TP
#.  .B EBADF
#.  .I option
#.  is
#.  .BR PR_SET_MM ,
#.  .I arg3
#.  is
#.  .BR PR_SET_MM_EXE_FILE ,
#.  and the file descriptor passed in
#.  .I arg4
#.  is not valid.
#.  ========== END FIXME
#.  The following can't actually happen, because prctl() in
#.  seccomp mode will cause SIGKILL.
#.  .TP
#.  .B EPERM
#.  .I option
#.  is
#.  .BR PR_SET_SECCOMP ,
#.  and secure computing mode is already 1.
#. type: Plain text
#: build/C/man2/prctl.2:720
msgid ""
"I<option> is B<PR_SET_MM>, and the caller does not have the "
"B<CAP_SYS_RESOURCE> capability."
msgstr ""
"I<option> が B<PR_SET_MM> で、呼び出し元がケーパビリティ\n"
"B<CAP_SYS_RESOURCE> を持っていない。"

#.  The library interface was added in glibc 2.0.6
#. type: Plain text
#: build/C/man2/prctl.2:725
msgid "The B<prctl>()  system call was introduced in Linux 2.1.57."
msgstr "B<prctl>()  システムコールは Linux 2.1.57 で導入された。"

#. type: Plain text
#: build/C/man2/prctl.2:732
msgid ""
"This call is Linux-specific.  IRIX has a B<prctl>()  system call (also "
"introduced in Linux 2.1.44 as irix_prctl on the MIPS architecture), with "
"prototype"
msgstr ""
"このコールは Linux 特有である。 IRIX には B<prctl>()  システム・コールがある"
"が (MIPS アーキテクチャにおいて irix_prctl として Linux 2.1.44 で同様に導入さ"
"れた)、 そのプロトタイプは"

#. type: Plain text
#: build/C/man2/prctl.2:734
msgid "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>"
msgstr "B<ptrdiff_t prctl(int >I<option>B<, int >I<arg2>B<, int >I<arg3>B<);>"

#. type: Plain text
#: build/C/man2/prctl.2:739
msgid ""
"and options to get the maximum number of processes per user, get the maximum "
"number of processors the calling process can use, find out whether a "
"specified process is currently blocked, get or set the maximum stack size, "
"and so on."
msgstr ""
"である。ユーザー当りのプロセス最大数を取得するオプション、 プロセスの使用でき"
"る最大プロッサー数を取得するオプション、 現在特定のプロセスが停止(block)させ"
"られているかどうか調べるオプション、 スタックサイズの最大値の取得や設定を行な"
"うオプションなどがある。"

#. type: Plain text
#: build/C/man2/prctl.2:742
msgid "B<signal>(2), B<core>(5)"
msgstr "B<signal>(2), B<core>(5)"

#. type: TH
#: build/C/man3/profil.3:28
#, no-wrap
msgid "PROFIL"
msgstr "PROFIL"

#. type: Plain text
#: build/C/man3/profil.3:31
msgid "profil - execution time profile"
msgstr "profil - 実行時間プロファイル (profile)"

#. type: Plain text
#: build/C/man3/profil.3:36
msgid ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<, size_t "
">I<offset>B<, unsigned int >I<scale>B<);>"
msgstr ""
"B<int profil(unsigned short *>I<buf>B<, size_t >I<bufsiz>B<, size_t "
">I<offset>B<, unsigned int >I<scale>B<);>"

#. type: Plain text
#: build/C/man3/profil.3:44
msgid ""
"B<profil>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"
msgstr ""
"B<profil>(): _BSD_SOURCE || (_XOPEN_SOURCE && _XOPEN_SOURCE\\ E<lt>\\ 500)"

#. type: Plain text
#: build/C/man3/profil.3:66
msgid ""
"This routine provides a means to find out in what areas your program spends "
"most of its time.  The argument I<buf> points to I<bufsiz> bytes of core.  "
"Every virtual 10 milliseconds, the user's program counter (PC)  is examined: "
"I<offset> is subtracted and the result is multiplied by I<scale> and divided "
"by 65536.  If the resulting value is less than I<bufsiz>, then the "
"corresponding entry in I<buf> is incremented.  If I<buf> is NULL, profiling "
"is disabled."
msgstr ""
"このルーティンはプログラムのどこの部分で時間を費やしているかを調べる 手段を提"
"供する。引き数 I<buf> は I<bufsiz> バイトのメモリを指している。仮想の 10 ミリ"
"秒ごとに、ユーザーの プログラム・カウンター (PC) が検査される: I<offset> が引"
"かれ、その結果が I<scale> 倍され 65536 で割られる。 結果が I<bufsiz> より小さ"
"い場合は I<buf> の対応するエントリがインクリメントされる。 I<buf> が NULL な"
"らば、プロファイル (profile) は無効にされる。"

#. type: Plain text
#: build/C/man3/profil.3:68
msgid "Zero is always returned."
msgstr "常に 0 が返される。"

#. type: Plain text
#: build/C/man3/profil.3:70
msgid "Similar to a call in SVr4 (but not POSIX.1-2001)."
msgstr "SVr4 のコールに似ている (しかし POSIX.1-2001 ではない)。"

#. type: Plain text
#: build/C/man3/profil.3:76
msgid ""
"B<profil>()  cannot be used on a program that also uses B<ITIMER_PROF> "
"interval timers (see B<setitimer>(2))."
msgstr ""
"B<profil>()  は B<ITIMER_PROF> インターバル・タイマーも使用しているプログラム"
"では使用できない (B<setitimer>(2)  参照)。"

#. type: Plain text
#: build/C/man3/profil.3:79
msgid ""
"True kernel profiling provides more accurate results.  Libc 4.4 contained a "
"kernel patch providing a system call profil."
msgstr ""
"本当のカーネル・プロファイルはより正確な結果を与える。 libc 4.4 にはシステム"
"コール profil を提供するための カーネルパッチが含まれていた。"

#. type: Plain text
#: build/C/man3/profil.3:84
msgid "B<gprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"
msgstr "B<gprof>(1), B<setitimer>(2), B<sigaction>(2), B<signal>(2)"

#. type: TH
#: build/C/man3/psignal.3:28
#, no-wrap
msgid "PSIGNAL"
msgstr "PSIGNAL"

#. type: TH
#: build/C/man3/psignal.3:28
#, no-wrap
msgid "2010-10-06"
msgstr "2010-10-06"

#. type: TH
#: build/C/man3/psignal.3:28 build/C/man3/raise.3:27
#: build/C/man7/sigevent.7:24
#, no-wrap
msgid "GNU"
msgstr "GNU"

#. type: Plain text
#: build/C/man3/psignal.3:31
msgid "psignal, psiginfo - print signal message"
msgstr "psignal, psiginfo - シグナルメッセージを表示"

#. type: Plain text
#: build/C/man3/psignal.3:37
#, no-wrap
msgid ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"
msgstr ""
"B<void psignal(int >I<sig>B<, const char *>I<s>B<);>\n"
"B<void psiginfo(const siginfo_t *>I<pinfo>B<, const char *>I<s>B<);>\n"

#. type: Plain text
#: build/C/man3/psignal.3:39
#, no-wrap
msgid "B<extern const char *const >I<sys_siglist>B<[];>\n"
msgstr "B<extern const char *const >I<sys_siglist>B<[];>\n"

#. type: Plain text
#: build/C/man3/psignal.3:48
msgid "B<psignal>(): _SVID_SOURCE || _BSD_SOURCE"
msgstr "B<psignal>(): _SVID_SOURCE || _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/psignal.3:51
msgid ""
"B<psiginfo>(): _XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200809L"
msgstr ""
"B<psiginfo>(): _XOPEN_SOURCE\\ E<gt>=\\ 700 || _POSIX_C_SOURCE\\ E<gt>=\\ "
"200809L"

#. type: Plain text
#: build/C/man3/psignal.3:54
msgid "I<sys_siglist>: _BSD_SOURCE"
msgstr "I<sys_siglist>: _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/psignal.3:63
msgid ""
"The B<psignal>()  function displays a message on I<stderr> consisting of the "
"string I<s>, a colon, a space, a string describing the signal number I<sig>, "
"and a trailing newline.  If the string I<s> is NULL or empty, the colon and "
"space are omitted.  If I<sig> is invalid, the message displayed will "
"indicate an unknown signal."
msgstr ""
"B<psignal>() 関数は、文字列 I<s>、コロン、スペース、\n"
"シグナル番号 I<sig> を説明する文字列、終端の改行から\n"
"構成されるメッセージを I<stderr> に表示する。\n"
"文字列 I<s> が NULL か空の場合、コロンとスペースは省略される。\n"
"I<sig> が不正ならば、表示される メッセージは未知のシグナルを示す。"

#. type: Plain text
#: build/C/man3/psignal.3:84
msgid ""
"The B<psiginfo>()  function is like B<psignal>(), except that it displays "
"information about the signal described by I<pinfo>, which should point to a "
"valid I<siginfo_t> structure.  As well as the signal description, B<psiginfo>"
"()  displays information about the origin of the signal, and other "
"information relevant to the signal (e.g., the relevant memory address for "
"hardware-generated signals, the child process ID for B<SIGCHLD>, and the "
"user ID and process ID of the sender, for signals set using B<kill>(2)  or "
"B<sigqueue>(3))."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:87
msgid ""
"The array I<sys_siglist> holds the signal description strings indexed by "
"signal number."
msgstr ""
"配列 I<sys_siglist> はシグナルを説明する文字列を保持しており、 配列へのアクセ"
"スにはシグナル番号を添え字として用いる事ができる。"

#. type: Plain text
#: build/C/man3/psignal.3:93
msgid "The B<psignal>()  and B<psiginfo>()  functions return no value."
msgstr "関数 B<psignal>() と B<psiginfo>() は、値を返さない。"

#. type: Plain text
#: build/C/man3/psignal.3:97
msgid "The B<psiginfo>()  function was added to glibc in version 2.10."
msgstr "B<psiginfo>() 関数は glibc バージョン 2.10 で追加された。"

#. type: Plain text
#: build/C/man3/psignal.3:99
msgid "POSIX.1-2008, 4.3BSD."
msgstr "POSIX.1-2008, 4.3BSD."

#. type: Plain text
#: build/C/man3/psignal.3:103
msgid "In glibc versions up to 2.12, B<psiginfo>()  had the following bugs:"
msgstr ""
"バージョン 2.12 までの glibc では B<psiginfo>() には以下のバグがあった。"

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12107
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:107
msgid "In some circumstances, a trailing newline is not printed."
msgstr ""

#.  FIXME http://sourceware.org/bugzilla/show_bug.cgi?id=12108
#.  Reportedly now fixed; check glibc 2.13
#. type: Plain text
#: build/C/man3/psignal.3:111
msgid "Additional details are not displayed for real-time signals."
msgstr ""

#. type: Plain text
#: build/C/man3/psignal.3:116
msgid "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<perror>(3), B<strsignal>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/raise.3:27
#, no-wrap
msgid "RAISE"
msgstr "RAISE"

#. type: TH
#: build/C/man3/raise.3:27
#, no-wrap
msgid "2012-04-20"
msgstr "2012-04-20"

#. type: Plain text
#: build/C/man3/raise.3:30
msgid "raise - send a signal to the caller"
msgstr "raise - 呼び出し元にシグナルを送る"

#. type: Plain text
#: build/C/man3/raise.3:35
#, no-wrap
msgid "B<int raise(int >I<sig>B<);>\n"
msgstr "B<int raise(int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/raise.3:41
msgid ""
"The B<raise>()  function sends a signal to the calling process or thread.  "
"In a single-threaded program it is equivalent to"
msgstr ""
"B<raise>()  関数は、呼び出し元のプロセスもしくはスレッドにシグナルを送る。 シ"
"ングルスレッドのプログラムでは、以下と等価である。"

#. type: Plain text
#: build/C/man3/raise.3:45
#, no-wrap
msgid "kill(getpid(), sig);\n"
msgstr "kill(getpid(), sig);\n"

#. type: Plain text
#: build/C/man3/raise.3:49
msgid "In a multithreaded program it is equivalent to"
msgstr "マルチスレッドのプログラムでは、以下と等価である。"

#. type: Plain text
#: build/C/man3/raise.3:53
#, no-wrap
msgid "pthread_kill(pthread_self(), sig);\n"
msgstr "pthread_kill(pthread_self(), sig);\n"

#. type: Plain text
#: build/C/man3/raise.3:59
msgid ""
"If the signal causes a handler to be called, B<raise>()  will only return "
"after the signal handler has returned."
msgstr ""
"シグナルに起因してシグナル・ハンドラが呼び出される場合には、 B<raise>()  が返"
"るのは必ずシグナル・ハンドラが返った後になる。"

#. type: Plain text
#: build/C/man3/raise.3:62
msgid "B<raise>()  returns 0 on success, and nonzero for failure."
msgstr "成功した場合は 0 を、失敗した場合は 0 以外の値を返す。"

#. type: Plain text
#: build/C/man3/raise.3:64 build/C/man2/signal.2:107
msgid "C89, C99, POSIX.1-2001."
msgstr "C89, C99, POSIX.1-2001."

#.  2.3.2 used the obsolete tkill(), if available.
#. type: Plain text
#: build/C/man3/raise.3:75
msgid ""
"Since version 2.3.3, glibc implements B<raise>()  by calling B<tgkill>(2), "
"if the kernel supports that system call.  Older glibc versions implemented "
"B<raise>()  using B<kill>(2)."
msgstr ""
"glibc バージョン 2.3.3 以降では、カーネルが B<tgkill>(2) システムコール\n"
"をサポートしている場合はB<raise>() は B<tgkill>(2) を使って実装されて\n"
"いる。古いバージョンの glibc では、B<raise>() は B<kill>(2) を使って\n"
"実装されている。"

#. type: Plain text
#: build/C/man3/raise.3:82
msgid ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"
msgstr ""
"B<getpid>(2), B<kill>(2), B<sigaction>(2), B<signal>(2), B<pthread_kill>(3), "
"B<signal>(7)"

#. type: TH
#: build/C/man2/rt_sigqueueinfo.2:23
#, no-wrap
msgid "RT_SIGQUEUEINFO"
msgstr "RT_SIGQUEUEINFO"

#. type: TH
#: build/C/man2/rt_sigqueueinfo.2:23 build/C/man2/tkill.2:29
#, no-wrap
msgid "2011-09-18"
msgstr "2011-09-18"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:26
msgid "rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data"
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:29
#, no-wrap
msgid "B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<uinfo>B<);>\n"
msgstr "B<int rt_sigqueueinfo(pid_t >I<tgid>B<, int >I<sig>B<, siginfo_t *>I<uinfo>B<);>\n"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:32
#, no-wrap
msgid ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"
msgstr ""
"B<int rt_tgsigqueueinfo(pid_t >I<tgid>B<, pid_t >I<tid>B<, int >I<sig>B<,>\n"
"B<                      siginfo_t *>I<uinfo>B<);>\n"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:45
msgid ""
"The B<rt_sigqueueinfo>()  and B<rt_tgsigqueueinfo>()  system calls are the "
"low-level interfaces used to send a signal plus data to a process or "
"thread.  The receiver of the signal can obtain the accompanying data by "
"establishing a signal handler with the B<sigaction>(2)  B<SA_SIGINFO> flag."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:51
msgid ""
"These system calls are not intended for direct application use; they are "
"provided to allow the implementation of B<sigqueue>(3)  and "
"B<pthread_sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:63
msgid ""
"The B<rt_sigqueueinfo>()  system call sends the signal I<sig> to the thread "
"group with the ID I<tgid>.  (The term \"thread group\" is synonymous with "
"\"process\", and I<tid> corresponds to the traditional UNIX process ID.)  "
"The signal will be delivered to an arbitrary member of the thread group (i."
"e., one of the threads that is not currently blocking the signal)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:74
msgid ""
"The I<uinfo> argument specifies the data to accompany the signal.  This "
"argument is a pointer to a structure of type I<siginfo_t>, described in "
"B<sigaction>(2)  (and defined by including I<E<lt>sigaction.hE<gt>>).  The "
"caller should set the following fields in this structure:"
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:74 build/C/man7/sigevent.7:86
#: build/C/man2/wait.2:315
#, no-wrap
msgid "I<si_code>"
msgstr "I<si_code>"

#.  tkill(2) or
#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:90
msgid ""
"This must be one of the B<SI_*> codes in the kernel source file I<include/"
"asm-generic/siginfo.h>, with the restriction that the code must be negative "
"(i.e., cannot be B<SI_USER>, which is used by the kernel to indicate a "
"signal sent by B<kill>(2))  and cannot (since Linux 2.6.39) be B<SI_TKILL> "
"(which is used by the kernel to indicate a signal sent using B<tgkill>(2))."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:90 build/C/man2/wait.2:294
#, no-wrap
msgid "I<si_pid>"
msgstr "I<si_pid>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:94
msgid ""
"This should be set to a process ID, typically the process ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:94 build/C/man2/wait.2:297
#, no-wrap
msgid "I<si_uid>"
msgstr "I<si_uid>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:98
msgid ""
"This should be set to a user ID, typically the real user ID of the sender."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:98 build/C/man7/sigevent.7:94
#, no-wrap
msgid "I<si_value>"
msgstr "I<si_value>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:105
msgid ""
"This field contains the user data to accompany the signal.  For more "
"information, see the description of the last (I<union sigval>)  argument of "
"B<sigqueue>(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:112
msgid ""
"Internally, the kernel sets the I<si_signo> field to the value specified in "
"I<sig>, so that the receiver of the signal can also obtain the signal number "
"via that field."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:124
msgid ""
"The B<rt_tgsigqueueinfo>()  system call is like B<rt_sigqueueinfo>(), but "
"sends the signal and data to the single thread specified by the combination "
"of I<tgid>, a thread group ID, and I<tid>, a thread in that thread group."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:129
msgid ""
"On success, these system calls return 0.  On error, they return -1 and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: TP
#: build/C/man2/rt_sigqueueinfo.2:130 build/C/man3/sigqueue.3:90
#: build/C/man2/sigwaitinfo.2:111 build/C/man2/timer_create.2:174
#, no-wrap
msgid "B<EAGAIN>"
msgstr "B<EAGAIN>"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:136 build/C/man3/sigqueue.3:96
msgid ""
"The limit of signals which may be queued has been reached.  (See B<signal>"
"(7)  for further information.)"
msgstr ""
"待ち行列に入れられるシグナルの最大数に達した (より詳しい情報は B<signal>(7)  "
"を参照すること)。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:143
msgid "I<sig>, I<tgid>, or I<tid> was invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:151
msgid ""
"The caller does not have permission to send the signal to the target.  For "
"the required permissions, see B<kill>(2).  Or: I<uinfo-E<gt>si_code> is "
"invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:157
msgid "B<rt_sigqueueinfo>(): No thread group matching I<tgid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:164
msgid "B<rt_tgsigqueinfo>(): No thread matching I<tgid> and I<tid> was found."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:171
msgid ""
"The B<rt_sigqueueinfo>()  system call was added to Linux in version 2.2.  "
"The B<rt_tgsigqueueinfo>()  system call was added to Linux in version 2.6.31."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:173 build/C/man2/sgetmask.2:63
#: build/C/man2/timerfd_create.2:372
msgid "These system calls are Linux-specific."
msgstr "これらのシステムコールは Linux 固有である。"

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:178
msgid ""
"Since these system calls are not intended for application use, there are no "
"glibc wrapper functions; use B<syscall>(2)  in the unlikely case that you "
"want to call them directly."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:183
msgid ""
"As with B<kill>(2), the null signal (0) can be used to check if the "
"specified process or thread exists."
msgstr ""

#. type: Plain text
#: build/C/man2/rt_sigqueueinfo.2:191
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<tgkill>(2), "
"B<pthread_sigqueue>(3), B<sigqueue>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sgetmask.2:24
#, no-wrap
msgid "SGETMASK"
msgstr "SGETMASK"

#. type: TH
#: build/C/man2/sgetmask.2:24
#, no-wrap
msgid "2007-07-05"
msgstr "2007-07-05"

#. type: Plain text
#: build/C/man2/sgetmask.2:27
msgid "sgetmask, ssetmask - manipulation of signal mask (obsolete)"
msgstr "sgetmask, ssetmask - シグナルマスクの操作 (廃止予定)"

#. type: Plain text
#: build/C/man2/sgetmask.2:29
msgid "B<long sgetmask(void);>"
msgstr "B<long sgetmask(void);>"

#. type: Plain text
#: build/C/man2/sgetmask.2:31
msgid "B<long ssetmask(long >I<newmask>B<);>"
msgstr "B<long ssetmask(long >I<newmask>B<);>"

#. type: Plain text
#: build/C/man2/sgetmask.2:37
msgid ""
"These system calls are obsolete.  I<Do not use them>; use B<sigprocmask>(2)  "
"instead."
msgstr ""
"これらのシステムコールは廃止予定であり、 「使用しないこと」。 代わりに "
"B<sigprocmask>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/sgetmask.2:40
msgid "B<sgetmask>()  returns the signal mask of the calling process."
msgstr "B<sgetmask>()  は、呼び出し元プロセスのシグナルマスクを返す。"

#. type: Plain text
#: build/C/man2/sgetmask.2:45
msgid ""
"B<ssetmask>()  sets the signal mask of the calling process to the value "
"given in I<newmask>.  The previous signal mask is returned."
msgstr ""
"B<ssetmask>()  は、呼び出し元プロセスのシグナルマスクを I<newmask> で指定され"
"た値に設定し、変更前のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man2/sgetmask.2:54
msgid ""
"The signal masks dealt with by these two system calls are plain bit masks "
"(unlike the I<sigset_t> used by B<sigprocmask>(2)); use B<sigmask>(3)  to "
"create and inspect these masks."
msgstr ""
"これら二つのシステムコールが扱うシグナルマスクは、 単純なビットマスクである "
"(この点が B<sigprocmask>(2)  で使用される I<sigset_t> と異なる)。 これらのマ"
"スクを作成したり検査するには B<sigmask>(3)  を使用すること。"

#. type: Plain text
#: build/C/man2/sgetmask.2:59
msgid ""
"B<sgetmask>()  always successfully returns the signal mask.  B<ssetmask>()  "
"always succeeds, and returns the previous signal mask."
msgstr ""
"B<sgetmask>()  は常に成功し、シグナルマスクを返す。 B<ssetmask>()  は常に成功"
"し、直前のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man2/sgetmask.2:61
msgid "These system calls always succeed."
msgstr "これらのシステムコールは常に成功する。"

#. type: Plain text
#: build/C/man2/sgetmask.2:66
msgid ""
"Glibc does not provide wrappers for these system calls; use B<syscall>(2)."
msgstr ""
"glibc はこれらのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使用すること。"

#. type: Plain text
#: build/C/man2/sgetmask.2:69
msgid ""
"These system calls are unaware of signal numbers greater than 31 (i.e., real-"
"time signals)."
msgstr ""
"これらのシステムコールは、 31 より大きいシグナル番号 (つまり、リアルタイムシ"
"グナル) を扱えない。"

#. type: Plain text
#: build/C/man2/sgetmask.2:74
msgid "It is not possible to block B<SIGSTOP> or B<SIGKILL>."
msgstr "B<SIGSTOP> や B<SIGKILL> をブロックすることはできない。"

#. type: Plain text
#: build/C/man2/sgetmask.2:77
msgid "B<sigprocmask>(2), B<signal>(7)"
msgstr "B<sigprocmask>(2), B<signal>(7)"

#. type: TH
#: build/C/man2/sigaction.2:45
#, no-wrap
msgid "SIGACTION"
msgstr "SIGACTION"

#. type: TH
#: build/C/man2/sigaction.2:45
#, no-wrap
msgid "2012-04-26"
msgstr "2012-04-26"

#. type: Plain text
#: build/C/man2/sigaction.2:48
msgid "sigaction - examine and change a signal action"
msgstr "sigaction - シグナルの動作の確認と変更"

#. type: Plain text
#: build/C/man2/sigaction.2:54
#, no-wrap
msgid ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"
msgstr ""
"B<int sigaction(int >I<signum>B<, const struct sigaction *>I<act>B<,>\n"
"B<              struct sigaction *>I<oldact>B<);>\n"

#. type: Plain text
#: build/C/man2/sigaction.2:64
msgid ""
"B<sigaction>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""
"B<sigaction>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"

#. type: Plain text
#: build/C/man2/sigaction.2:73
msgid ""
"The B<sigaction>()  system call is used to change the action taken by a "
"process on receipt of a specific signal.  (See B<signal>(7)  for an overview "
"of signals.)"
msgstr ""
"B<sigaction>()  システムコールは、特定のシグナルを受信した際の プロセスの動作"
"を変更するのに使用される (シグナルの概要については B<signal>(7)  を参照)。"

#. type: Plain text
#: build/C/man2/sigaction.2:79
msgid ""
"I<signum> specifies the signal and can be any valid signal except B<SIGKILL> "
"and B<SIGSTOP>."
msgstr ""
"I<signum> には、 B<SIGKILL> と B<SIGSTOP> 以外の有効なシグナルをどれでも指定"
"できる。"

#. type: Plain text
#: build/C/man2/sigaction.2:90
msgid ""
"If I<act> is non-NULL, the new action for signal I<signum> is installed from "
"I<act>.  If I<oldact> is non-NULL, the previous action is saved in I<oldact>."
msgstr ""
"I<act> が NULL 以外であれば、シグナル I<signum> の新しい動作 (action) として "
"I<act> が設定される。 I<oldact> が NULL でなければ、今までの動作が I<oldact> "
"に格納される。"

#. type: Plain text
#: build/C/man2/sigaction.2:94
msgid "The I<sigaction> structure is defined as something like:"
msgstr "I<sigaction> 構造体は以下のような感じに定義される。"

#. type: Plain text
#: build/C/man2/sigaction.2:104
#, no-wrap
msgid ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"
msgstr ""
"struct sigaction {\n"
"    void     (*sa_handler)(int);\n"
"    void     (*sa_sigaction)(int, siginfo_t *, void *);\n"
"    sigset_t   sa_mask;\n"
"    int        sa_flags;\n"
"    void     (*sa_restorer)(void);\n"
"};\n"

#. type: Plain text
#: build/C/man2/sigaction.2:111
msgid ""
"On some architectures a union is involved: do not assign to both "
"I<sa_handler> and I<sa_sigaction>."
msgstr ""
"アーキテクチャによっては共用体 (union) が用いられており、その場合には "
"I<sa_handler> と I<sa_sigaction> の両方を同時に割り当てることはできない。"

#. type: Plain text
#: build/C/man2/sigaction.2:118
msgid ""
"The I<sa_restorer> element is obsolete and should not be used.  POSIX does "
"not specify a I<sa_restorer> element."
msgstr ""
"I<sa_restorer> 要素は廃止予定であり使用すべきではない。 POSIX には "
"I<sa_restorer> 要素に関する規定はない。"

#. type: Plain text
#: build/C/man2/sigaction.2:128
msgid ""
"I<sa_handler> specifies the action to be associated with I<signum> and may "
"be B<SIG_DFL> for the default action, B<SIG_IGN> to ignore this signal, or a "
"pointer to a signal handling function.  This function receives the signal "
"number as its only argument."
msgstr ""
"I<sa_handler> は I<signum> に対応する動作を指定するもので、 デフォルトの動作"
"を行う B<SIG_DFL>、 そのシグナルを無視する B<SIG_IGN>、 シグナルハンドラ関数"
"へのポインタが設定できる。 シグナルハンドラ関数の引き数は一つであり、シグナル"
"番号が引き数として 渡される。"

#. type: Plain text
#: build/C/man2/sigaction.2:150
msgid ""
"If B<SA_SIGINFO> is specified in I<sa_flags>, then I<sa_sigaction> (instead "
"of I<sa_handler>)  specifies the signal-handling function for I<signum>.  "
"This function receives the signal number as its first argument, a pointer to "
"a I<siginfo_t> as its second argument and a pointer to a I<ucontext_t> (cast "
"to I<void\\ *>) as its third argument.  (Commonly, the handler function "
"doesn't make any use of the third argument.  See B<getcontext>(2)  for "
"further information about I<ucontext_t>.)"
msgstr ""
"I<sa_flags> に B<SA_SIGINFO> が指定された場合、 (I<sa_handler> ではなく)\n"
"I<sa_sigaction> により I<signum> に対応するシグナルハンドラ関数が指定さ\n"
"れる。指定される関数は、最初の引き数としてシグナル番号を、二番目の引き\n"
"数として I<siginfo_t> へのポインタを、三番目の引き数として (I<void\\ *>\n"
"にキャストした) I<ucontext_t> へのポインタを受けとる。 (一般的には、\n"
"ハンドラ関数の三番目の引き数が使用されない。I<ucontext_t> についての\n"
"詳しい情報は B<getcontext>(2) を参照。)"

#. type: Plain text
#: build/C/man2/sigaction.2:160
msgid ""
"I<sa_mask> specifies a mask of signals which should be blocked (i.e., added "
"to the signal mask of the thread in which the signal handler is invoked)  "
"during execution of the signal handler.  In addition, the signal which "
"triggered the handler will be blocked, unless the B<SA_NODEFER> flag is used."
msgstr ""
"I<sa_mask> は、シグナル・ハンドラ実行中に禁止 (block) すべきシグナルのマスク"
"を指定する (ハンドラ実行中のシグナルの禁止は、シグナル・ハンドラが起動された"
"スレッド のシグナルのマスクに追加することで行われる)。 さらに、 "
"B<SA_NODEFER> フラグが指定されていない場合は、ハンドラを起動するきっかけとな"
"る シグナルにも I<sa_mask> が適用される。"

#. type: Plain text
#: build/C/man2/sigaction.2:164
msgid ""
"I<sa_flags> specifies a set of flags which modify the behavior of the "
"signal.  It is formed by the bitwise OR of zero or more of the following:"
msgstr ""
"I<sa_flags> はシグナル・ハンドラの動作を変更するためのフラグの集合を指定す"
"る。 I<sa_flags> には、以下に示すフラグの (0 個以上の) 論理和をとったものを指"
"定する。"

#. type: TP
#: build/C/man2/sigaction.2:165
#, no-wrap
msgid "B<SA_NOCLDSTOP>"
msgstr "B<SA_NOCLDSTOP>"

#. type: Plain text
#: build/C/man2/sigaction.2:182
msgid ""
"If I<signum> is B<SIGCHLD>, do not receive notification when child processes "
"stop (i.e., when they receive one of B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN> or "
"B<SIGTTOU>)  or resume (i.e., they receive B<SIGCONT>)  (see B<wait>(2)).  "
"This flag is only meaningful when establishing a handler for B<SIGCHLD>."
msgstr ""
"I<signum> が B<SIGCHLD> の場合、 子プロセスが停止したり (子プロセスが "
"B<SIGSTOP>, B<SIGTSTP>, B<SIGTTIN>, B<SIGTTOU> を受けたとき) 再開したり (子プ"
"ロセスが B<SIGCONT> を受けたとき) したときに B<SIGCHLD> の通知を受けない。 こ"
"のフラグは、 B<SIGCHLD> に対してハンドラを設定する際にのみ意味を持つ。"

#. type: TP
#: build/C/man2/sigaction.2:182
#, no-wrap
msgid "B<SA_NOCLDWAIT> (since Linux 2.6)"
msgstr "B<SA_NOCLDWAIT> (Linux 2.6 以降)"

#.  To be precise: Linux 2.5.60 -- MTK
#. type: Plain text
#: build/C/man2/sigaction.2:196
msgid ""
"If I<signum> is B<SIGCHLD>, do not transform children into zombies when they "
"terminate.  See also B<waitpid>(2).  This flag is only meaningful when "
"establishing a handler for B<SIGCHLD>, or when setting that signal's "
"disposition to B<SIG_DFL>."
msgstr ""
"(Linux 2.6 以降)  I<signum> が B<SIGCHLD> の場合、子プロセスが終了したときに "
"子プロセスをゾンビプロセスに変化させない (B<waitpid>(2)  も参照)。 このフラグ"
"は、 B<SIGCHLD> に対してハンドラを設定する際、もしくはそのシグナルの処理方法"
"を B<SIG_DFL> に設定する際にのみ意味を持つ。"

#. type: Plain text
#: build/C/man2/sigaction.2:208
msgid ""
"If the B<SA_NOCLDWAIT> flag is set when establishing a handler for "
"B<SIGCHLD>, POSIX.1 leaves it unspecified whether a B<SIGCHLD> signal is "
"generated when a child process terminates.  On Linux, a B<SIGCHLD> signal is "
"generated in this case; on some other implementations, it is not."
msgstr ""
"B<SIGCHLD> に対してハンドラを設定する際に B<SA_NOCLDWAIT> フラグをセットした"
"場合、 子プロセスが終了した際に B<SIGCHLD> シグナルが生成されるかどうかは、 "
"POSIX.1 では規定されていない。 Linux では、この状況で B<SIGCHLD> シグナルは生"
"成される。 いくつかの他の実装では生成されない。"

#. type: TP
#: build/C/man2/sigaction.2:208
#, no-wrap
msgid "B<SA_NODEFER>"
msgstr "B<SA_NODEFER>"

#. type: Plain text
#: build/C/man2/sigaction.2:215
msgid ""
"Do not prevent the signal from being received from within its own signal "
"handler.  This flag is only meaningful when establishing a signal handler.  "
"B<SA_NOMASK> is an obsolete, nonstandard synonym for this flag."
msgstr ""
"それ自身のシグナル・ハンドラーの内部にいる時でも そのシグナルをマスクしないよ"
"うにする。 このフラグはシグナルハンドラを設定する際にのみ意味を持つ。 "
"B<SA_NOMASK> はこのフラグと同じ意味だが、廃止されており、非標準である。"

#. type: TP
#: build/C/man2/sigaction.2:215
#, no-wrap
msgid "B<SA_ONSTACK>"
msgstr "B<SA_ONSTACK>"

#. type: Plain text
#: build/C/man2/sigaction.2:221
msgid ""
"Call the signal handler on an alternate signal stack provided by "
"B<sigaltstack>(2).  If an alternate stack is not available, the default "
"stack will be used.  This flag is only meaningful when establishing a signal "
"handler."
msgstr ""
"B<sigaltstack>(2)  で提供される別のシグナル・スタックでシグナルハンドラを呼び"
"出す。 別のシグナル・スタックが利用可能でなければ、デフォルトのスタックが 使"
"用される。 このフラグはシグナルハンドラを設定する際にのみ意味を持つ。"

#. type: TP
#: build/C/man2/sigaction.2:221
#, no-wrap
msgid "B<SA_RESETHAND>"
msgstr "B<SA_RESETHAND>"

#. type: Plain text
#: build/C/man2/sigaction.2:228
msgid ""
"Restore the signal action to the default state once the signal handler has "
"been called.  This flag is only meaningful when establishing a signal "
"handler.  B<SA_ONESHOT> is an obsolete, nonstandard synonym for this flag."
msgstr ""
"シグナルハンドラが呼ばれる度に、シグナルの動作をデフォルトに戻す。 このフラグ"
"はシグナルハンドラを設定する際にのみ意味を持つ。 B<SA_ONESHOT> はこのフラグと"
"同じ意味だが、廃止されており、非標準である。"

#. type: TP
#: build/C/man2/sigaction.2:228
#, no-wrap
msgid "B<SA_RESTART>"
msgstr "B<SA_RESTART>"

#. type: Plain text
#: build/C/man2/sigaction.2:236
msgid ""
"Provide behavior compatible with BSD signal semantics by making certain "
"system calls restartable across signals.  This flag is only meaningful when "
"establishing a signal handler.  See B<signal>(7)  for a discussion of system "
"call restarting."
msgstr ""
"いくつかのシステムコールをシグナルの通知の前後で再開できるようにして、 BSD シ"
"グナル方式 (semantics) と互換性のある動作を提供する。 このフラグはシグナルハ"
"ンドラを設定する際にのみ意味を持つ。 B<signal>(7)  に書かれているシステムコー"
"ルの再開に関する議論を参照のこと。"

#. type: TP
#: build/C/man2/sigaction.2:236
#, no-wrap
msgid "B<SA_SIGINFO> (since Linux 2.2)"
msgstr "B<SA_SIGINFO> (Linux 2.2 以降)"

#.  (The
#.  .I sa_sigaction
#.  field was added in Linux 2.1.86.)
#. type: Plain text
#: build/C/man2/sigaction.2:247
msgid ""
"The signal handler takes 3 arguments, not one.  In this case, "
"I<sa_sigaction> should be set instead of I<sa_handler>.  This flag is only "
"meaningful when establishing a signal handler."
msgstr ""
"シグナルハンドラは一つではなく、三つの引き数を持つ。この場合は I<sa_handler> "
"のかわりに I<sa_sigaction> を設定しなければならない このフラグはシグナルハン"
"ドラを設定する際にのみ意味を持つ。"

#. type: Plain text
#: build/C/man2/sigaction.2:254
msgid ""
"The I<siginfo_t> argument to I<sa_sigaction> is a struct with the following "
"elements:"
msgstr ""
"I<sa_sigaction> のパラメータ I<siginfo_t> は以下の要素を持つ構造体である:"

#.  FIXME
#.  si_trapno seems to be only used on SPARC and Alpha;
#.  this page could use a little more detail on its purpose there.
#.  In the kernel: si_tid
#. type: Plain text
#: build/C/man2/sigaction.2:285
#, no-wrap
msgid ""
"siginfo_t {\n"
"    int      si_signo;    /* Signal number */\n"
"    int      si_errno;    /* An errno value */\n"
"    int      si_code;     /* Signal code */\n"
"    int      si_trapno;   /* Trap number that caused\n"
"                             hardware-generated signal\n"
"                             (unused on most architectures) */\n"
"    pid_t    si_pid;      /* Sending process ID */\n"
"    uid_t    si_uid;      /* Real user ID of sending process */\n"
"    int      si_status;   /* Exit value or signal */\n"
"    clock_t  si_utime;    /* User time consumed */\n"
"    clock_t  si_stime;    /* System time consumed */\n"
"    sigval_t si_value;    /* Signal value */\n"
"    int      si_int;      /* POSIX.1b signal */\n"
"    void    *si_ptr;      /* POSIX.1b signal */\n"
"    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */\n"
"    int      si_timerid;  /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;     /* Memory location which caused fault */\n"
"    long     si_band;     /* Band event (was I<int> in\n"
"                             glibc 2.3.2 and earlier) */\n"
"    int      si_fd;       /* File descriptor */\n"
"    short    si_addr_lsb; /* Least significant bit of address\n"
"                             (since kernel 2.6.32) */\n"
"}\n"
msgstr ""
"siginfo_t {\n"
"    int      si_signo;    /* Signal number */\n"
"    int      si_errno;    /* An errno value */\n"
"    int      si_code;     /* Signal code */\n"
"    int      si_trapno;   /* Trap number that caused\n"
"                             hardware-generated signal\n"
"                             (unused on most architectures) */\n"
"    pid_t    si_pid;      /* Sending process ID */\n"
"    uid_t    si_uid;      /* Real user ID of sending process */\n"
"    int      si_status;   /* Exit value or signal */\n"
"    clock_t  si_utime;    /* User time consumed */\n"
"    clock_t  si_stime;    /* System time consumed */\n"
"    sigval_t si_value;    /* Signal value */\n"
"    int      si_int;      /* POSIX.1b signal */\n"
"    void    *si_ptr;      /* POSIX.1b signal */\n"
"    int      si_overrun;  /* Timer overrun count; POSIX.1b timers */\n"
"    int      si_timerid;  /* Timer ID; POSIX.1b timers */\n"
"    void    *si_addr;     /* Memory location which caused fault */\n"
"    long     si_band;     /* Band event (was I<int> in\n"
"                             glibc 2.3.2 and earlier) */\n"
"    int      si_fd;       /* File descriptor */\n"
"    short    si_addr_lsb; /* Least significant bit of address\n"
"                             (since kernel 2.6.32) */\n"
"}\n"

#. type: Plain text
#: build/C/man2/sigaction.2:294
msgid ""
"I<si_signo>, I<si_errno> and I<si_code> are defined for all signals.  "
"(I<si_errno> is generally unused on Linux.)  The rest of the struct may be a "
"union, so that one should only read the fields that are meaningful for the "
"given signal:"
msgstr ""
"I<si_signo>, I<si_errno>, I<si_code> は全てのシグナルに対して定義されている "
"(I<si_errno> は Linux では一般的には使用されない)。 構造体の残りの部分は、共"
"用体 (union) になっているかもしれない。 その場合は該当するシグナルにおいて意"
"味のあるフィールドのみを読み込む ことができる。"

#. type: Plain text
#: build/C/man2/sigaction.2:309
msgid ""
"Signals sent with B<kill>(2)  and B<sigqueue>(3)  fill in I<si_pid> and "
"I<si_uid>.  In addition, signals sent with B<sigqueue>(3)  fill in I<si_int> "
"and I<si_ptr> with the values specified by the sender of the signal; see "
"B<sigqueue>(3)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:325
msgid ""
"Signals sent by POSIX.1b timers (since Linux 2.6) fill in I<si_overrun> and "
"I<si_timerid>.  The I<si_timerid> field is an internal ID used by the kernel "
"to identify the timer; it is not the same as the timer ID returned by "
"B<timer_create>(2).  The I<si_overrun> field is the timer overrun count; "
"this is the same information as is obtained by a call to B<timer_getoverrun>"
"(2).  These fields are nonstandard Linux extensions."
msgstr ""
"POSIX.1b タイマ (Linux 2.6 以降) は I<si_overrun> と I<si_timerid> を\n"
"設定する。 I<si_timerid> フィールドはカーネルがタイマを特定するのに\n"
"使用する内部 ID であり、 B<timer_create>(2) が返すタイマ ID と同じではな"
"い。\n"
"I<si_overrun> フィールドはタイマが回り切った回数である。\n"
"これは B<timer_getoverrun>(2) の呼び出しで取得できる情報と同じである。\n"
"これらのフィールドは非標準で Linux による拡張である。"

#. type: Plain text
#: build/C/man2/sigaction.2:340
msgid ""
"Signals sent for message queue notification (see the description of "
"B<SIGEV_SIGNAL> in B<mq_notify>(3))  fill in I<si_int>/I<si_ptr>, with the "
"I<sigev_value> supplied to B<mq_notify>(3); I<si_pid>, with the process ID "
"of the message sender; and I<si_uid>, with the real user ID of the message "
"sender."
msgstr ""

#.  FIXME .
#.  When si_utime and si_stime where originally implemented, the
#.  measurement unit was HZ, which was the same as clock ticks
#.  (sysconf(_SC_CLK_TCK)).  In 2.6, HZ became configurable, and
#.  was *still* used as the unit to return the info these fields,
#.  with the result that the field values depended on the the
#.  configured HZ.  Of course, the should have been measured in
#.  USER_HZ instead, so that sysconf(_SC_CLK_TCK) could be used to
#.  convert to seconds.  I have a queued patch to fix this:
#.  http://thread.gmane.org/gmane.linux.kernel/698061/ .
#.  This patch made it into 2.6.27.
#.  But note that these fields still don't return the times of
#.  waited-for children (as is done by getrusage() and times()
#.  and wait4()).  Solaris 8 does include child times.
#. type: Plain text
#: build/C/man2/sigaction.2:387
msgid ""
"B<SIGCHLD> fills in I<si_pid>, I<si_uid>, I<si_status>, I<si_utime> and "
"I<si_stime>, providing information about the child.  The I<si_pid> field is "
"the process ID of the child; I<si_uid> is the child's real user ID.  The "
"I<si_status> field contains the exit status of the child (if I<si_code> is "
"B<CLD_EXITED>), or the signal number that caused the process to change "
"state.  The I<si_utime> and I<si_stime> contain the user and system CPU time "
"used by the child process; these fields do not include the times used by "
"waited-for children (unlike B<getrusage>(2)  and B<time>(2)).  In kernels up "
"to 2.6, and since 2.6.27, these fields report CPU time in units of I<sysconf"
"(_SC_CLK_TCK)>.  In 2.6 kernels before 2.6.27, a bug meant that these fields "
"reported time in units of the (configurable) system jiffy (see B<time>(7))."
msgstr ""
"B<SIGCHLD> は I<si_pid>, I<si_uid>, I<si_status>, I<si_utime>,\n"
"I<si_stime> を設定し、子プロセスに関する情報を提供する。\n"
"I<si_pid> フィールドは子プロセスのプロセス ID で、\n"
"I<si_uid> フィールドは子プロセスの実ユーザ ID である。\n"
"I<si_stime> フィールドには、 (I<si_code> が B<CLD_EXITED> の場合は) \n"
"子プロセスの終了ステータスが、それ以外の場合は状態が変化する原因と\n"
"なったシグナル番号が格納される。\n"
"I<si_utime> と I<si_stime> には子プロセスが使用したユーザ CPU 時間とシ\n"
"ステム CPU 時間がそれぞれ格納される。(B<getrusage>(2) や B<time>(2) と\n"
"異なり) これらのフィールドには wait 待ちの子プロセスにより使用された時\n"
"間は含まれない。 2.6 より前と 2.6.27 以降のカーネルでは、 これらのフィー\n"
"ルドに格納される CPU 時間の単位は I<sysconf(_SC_CLK_TCK)> である。\n"
"2.6.27 より前の 2.6 系のカーネルでは、バグがあり、 これらのフィールドの\n"
"CPU 時間の単位が (カーネルのコンフィグで指定される) システムの jiffy で\n"
"あった (B<time>(7) 参照)。"

#.  FIXME SIGTRAP also sets the following for ptrace_notify() ?
#.      info.si_code = exit_code;
#.      info.si_pid = task_pid_vnr(current);
#.      info.si_uid = current_uid();  /* Real UID */
#. type: Plain text
#: build/C/man2/sigaction.2:423
msgid ""
"B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS>, and B<SIGTRAP> fill in "
"I<si_addr> with the address of the fault.  On some architectures, these "
"signals also fill in the I<si_trapno> filed.  Some suberrors of B<SIGBUS>, "
"in particular B<BUS_MCEERR_AO> and B<BUS_MCEERR_AR>, also fill in "
"I<si_addr_lsb>.  This field indicates the least significant bit of the "
"reported address and therefore the extent of the corruption.  For example, "
"if a full page was corrupted, I<si_addr_lsb> contains I<log2(sysconf"
"(_SC_PAGESIZE))>.  B<BUS_MCERR_*> and I<si_addr_lsb> are Linux-specific "
"extensions."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:437
msgid ""
"B<SIGIO>/B<SIGPOLL> (the two names are synonyms on Linux)  fills in "
"I<si_band> and I<si_fd>.  The I<si_band> event is a bit mask containing the "
"same values as are filled in the I<revents> field by B<poll>(2).  The "
"I<si_fd> field indicates the file descriptor for which the I/O event "
"occurred."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:444
msgid ""
"I<si_code> is a value (not a bit mask)  indicating why this signal was "
"sent.  The following list shows the values which can be placed in I<si_code> "
"for any signal, along with reason that the signal was generated."
msgstr ""
"I<si_code> は、そのシグナルが送信された理由を示す値である (ビットマスクではな"
"い)。 以下のリストに、どのシグナルの場合でも I<si_code> に入りうる値を、シグ"
"ナルが生成された理由とともに記載する。"

#. type: TP
#: build/C/man2/sigaction.2:445
#, no-wrap
msgid "B<SI_USER>"
msgstr "B<SI_USER>"

#. type: TP
#: build/C/man2/sigaction.2:448 build/C/man7/signal.7:109
#, no-wrap
msgid "B<kill>(2)"
msgstr "B<kill>(2)"

#. type: TP
#: build/C/man2/sigaction.2:448
#, no-wrap
msgid "B<SI_KERNEL>"
msgstr "B<SI_KERNEL>"

#. type: Plain text
#: build/C/man2/sigaction.2:451
msgid "Sent by the kernel."
msgstr "カーネルにより送信された"

#. type: TP
#: build/C/man2/sigaction.2:451
#, no-wrap
msgid "B<SI_QUEUE>"
msgstr "B<SI_QUEUE>"

#. type: TP
#: build/C/man2/sigaction.2:454 build/C/man7/signal.7:126
#, no-wrap
msgid "B<sigqueue>(3)"
msgstr "B<sigqueue>(3)"

#. type: TP
#: build/C/man2/sigaction.2:454
#, no-wrap
msgid "B<SI_TIMER>"
msgstr "B<SI_TIMER>"

#. type: Plain text
#: build/C/man2/sigaction.2:457
msgid "POSIX timer expired"
msgstr "POSIX タイマが満了した"

#. type: TP
#: build/C/man2/sigaction.2:457
#, no-wrap
msgid "B<SI_MESGQ>"
msgstr "B<SI_MESGQ>"

#. type: Plain text
#: build/C/man2/sigaction.2:461
msgid ""
"POSIX message queue state changed (since Linux 2.6.6); see B<mq_notify>(3)"
msgstr ""
"POSIX メッセージキューの状態が変化した (Linux 2.6.6 以降)。 B<mq_notify>(3)B<"
"参照。>"

#. type: TP
#: build/C/man2/sigaction.2:461
#, no-wrap
msgid "B<SI_ASYNCIO>"
msgstr "B<SI_ASYNCIO>"

#. type: Plain text
#: build/C/man2/sigaction.2:464
msgid "AIO completed"
msgstr "非同期 IO (AIO) が完了した"

#. type: TP
#: build/C/man2/sigaction.2:464
#, no-wrap
msgid "B<SI_SIGIO>"
msgstr "B<SI_SIGIO>"

#. type: Plain text
#: build/C/man2/sigaction.2:473
msgid ""
"Queued B<SIGIO> (only in kernels up to Linux 2.2; from Linux 2.4 onward "
"B<SIGIO>/B<SIGPOLL> fills in I<si_code> as described below)."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:473
#, no-wrap
msgid "B<SI_TKILL>"
msgstr "B<SI_TKILL>"

#.  SI_DETHREAD is defined in 2.6.9 sources, but isn't implemented
#.  It appears to have been an idea that was tried during 2.5.6
#.  through to 2.5.24 and then was backed out.
#. type: Plain text
#: build/C/man2/sigaction.2:482
msgid "B<tkill>(2)  or B<tgkill>(2)  (since Linux 2.4.19)"
msgstr "B<tkill>(2)  または B<tgkill>(2)  (Linux 2.4.19 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:489
msgid ""
"The following values can be placed in I<si_code> for a B<SIGILL> signal:"
msgstr "B<SIGILL> シグナルの場合、 I<si_code> には以下の値を指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:490
#, no-wrap
msgid "B<ILL_ILLOPC>"
msgstr "B<ILL_ILLOPC>"

#. type: Plain text
#: build/C/man2/sigaction.2:493
msgid "illegal opcode"
msgstr "不正な命令コード (opcode)"

#. type: TP
#: build/C/man2/sigaction.2:493
#, no-wrap
msgid "B<ILL_ILLOPN>"
msgstr "B<ILL_ILLOPN>"

#. type: Plain text
#: build/C/man2/sigaction.2:496
msgid "illegal operand"
msgstr "不正なオペランド"

#. type: TP
#: build/C/man2/sigaction.2:496
#, no-wrap
msgid "B<ILL_ILLADR>"
msgstr "B<ILL_ILLADR>"

#. type: Plain text
#: build/C/man2/sigaction.2:499
msgid "illegal addressing mode"
msgstr "不正なアドレッシングモード"

#. type: TP
#: build/C/man2/sigaction.2:499
#, no-wrap
msgid "B<ILL_ILLTRP>"
msgstr "B<ILL_ILLTRP>"

#. type: Plain text
#: build/C/man2/sigaction.2:502
msgid "illegal trap"
msgstr "不正なトラップ"

#. type: TP
#: build/C/man2/sigaction.2:502
#, no-wrap
msgid "B<ILL_PRVOPC>"
msgstr "B<ILL_PRVOPC>"

#. type: Plain text
#: build/C/man2/sigaction.2:505
msgid "privileged opcode"
msgstr "特権が必要な命令コード (opcode)"

#. type: TP
#: build/C/man2/sigaction.2:505
#, no-wrap
msgid "B<ILL_PRVREG>"
msgstr "B<ILL_PRVREG>"

#. type: Plain text
#: build/C/man2/sigaction.2:508
msgid "privileged register"
msgstr "特権が必要なレジスタ"

#. type: TP
#: build/C/man2/sigaction.2:508
#, no-wrap
msgid "B<ILL_COPROC>"
msgstr "B<ILL_COPROC>"

#. type: Plain text
#: build/C/man2/sigaction.2:511
msgid "coprocessor error"
msgstr "コプロセッサのエラー"

#. type: TP
#: build/C/man2/sigaction.2:511
#, no-wrap
msgid "B<ILL_BADSTK>"
msgstr "B<ILL_BADSTK>"

#. type: Plain text
#: build/C/man2/sigaction.2:514
msgid "internal stack error"
msgstr "内部スタックエラー"

#. type: Plain text
#: build/C/man2/sigaction.2:521
msgid ""
"The following values can be placed in I<si_code> for a B<SIGFPE> signal:"
msgstr "B<SIGFPE> シグナルの場合、 I<si_code> には以下の値を指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:522
#, no-wrap
msgid "B<FPE_INTDIV>"
msgstr "B<FPE_INTDIV>"

#. type: Plain text
#: build/C/man2/sigaction.2:525
msgid "integer divide by zero"
msgstr "整数の 0 による除算"

#. type: TP
#: build/C/man2/sigaction.2:525
#, no-wrap
msgid "B<FPE_INTOVF>"
msgstr "B<FPE_INTOVF>"

#. type: Plain text
#: build/C/man2/sigaction.2:528
msgid "integer overflow"
msgstr "整数のオーバーフロー"

#. type: TP
#: build/C/man2/sigaction.2:528
#, no-wrap
msgid "B<FPE_FLTDIV>"
msgstr "B<FPE_FLTDIV>"

#. type: Plain text
#: build/C/man2/sigaction.2:531
msgid "floating-point divide by zero"
msgstr "浮動小数点の 0 による除算"

#. type: TP
#: build/C/man2/sigaction.2:531
#, no-wrap
msgid "B<FPE_FLTOVF>"
msgstr "B<FPE_FLTOVF>"

#. type: Plain text
#: build/C/man2/sigaction.2:534
msgid "floating-point overflow"
msgstr "浮動小数点のオーバーフロー"

#. type: TP
#: build/C/man2/sigaction.2:534
#, no-wrap
msgid "B<FPE_FLTUND>"
msgstr "B<FPE_FLTUND>"

#. type: Plain text
#: build/C/man2/sigaction.2:537
msgid "floating-point underflow"
msgstr "浮動小数点のアンダーフロー"

#. type: TP
#: build/C/man2/sigaction.2:537
#, no-wrap
msgid "B<FPE_FLTRES>"
msgstr "B<FPE_FLTRES>"

#. type: Plain text
#: build/C/man2/sigaction.2:540
msgid "floating-point inexact result"
msgstr "浮動小数点の不正確な演算結果 (inexact result)"

#. type: TP
#: build/C/man2/sigaction.2:540
#, no-wrap
msgid "B<FPE_FLTINV>"
msgstr "B<FPE_FLTINV>"

#. type: Plain text
#: build/C/man2/sigaction.2:543
msgid "floating-point invalid operation"
msgstr "浮動小数点の不正な操作"

#. type: TP
#: build/C/man2/sigaction.2:543
#, no-wrap
msgid "B<FPE_FLTSUB>"
msgstr "B<FPE_FLTSUB>"

#. type: Plain text
#: build/C/man2/sigaction.2:546
msgid "subscript out of range"
msgstr "範囲外の添字 (subscript)"

#. type: Plain text
#: build/C/man2/sigaction.2:553
msgid ""
"The following values can be placed in I<si_code> for a B<SIGSEGV> signal:"
msgstr "B<SIGSEGV> シグナルの場合、 I<si_code> には以下の値を指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:554
#, no-wrap
msgid "B<SEGV_MAPERR>"
msgstr "B<SEGV_MAPERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:557
msgid "address not mapped to object"
msgstr "オブジェクトにマッピングされていないアドレス"

#. type: TP
#: build/C/man2/sigaction.2:557
#, no-wrap
msgid "B<SEGV_ACCERR>"
msgstr "B<SEGV_ACCERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:560
msgid "invalid permissions for mapped object"
msgstr "マッピングされたオブジェクトに対するアクセス許可がない"

#. type: Plain text
#: build/C/man2/sigaction.2:567
msgid ""
"The following values can be placed in I<si_code> for a B<SIGBUS> signal:"
msgstr "B<SIGBUS> シグナルの場合、 I<si_code> には以下の値を指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:568
#, no-wrap
msgid "B<BUS_ADRALN>"
msgstr "B<BUS_ADRALN>"

#. type: Plain text
#: build/C/man2/sigaction.2:571
msgid "invalid address alignment"
msgstr "不正なアドレス・アライメント (alignment)"

#. type: TP
#: build/C/man2/sigaction.2:571
#, no-wrap
msgid "B<BUS_ADRERR>"
msgstr "B<BUS_ADRERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:574
msgid "nonexistent physical address"
msgstr "存在しない物理アドレス"

#. type: TP
#: build/C/man2/sigaction.2:574
#, no-wrap
msgid "B<BUS_OBJERR>"
msgstr "B<BUS_OBJERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:577
msgid "object-specific hardware error"
msgstr "オブジェクト固有のハードウェアエラー"

#. type: TP
#: build/C/man2/sigaction.2:577
#, no-wrap
msgid "B<BUS_MCEERR_AR> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AR> (Linux 2.6.32 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:580
msgid "Hardware memory error consumed on a machine check; action required."
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:580
#, no-wrap
msgid "B<BUS_MCEERR_AO> (since Linux 2.6.32)"
msgstr "B<BUS_MCEERR_AO> (Linux 2.6.32  以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:583
msgid ""
"Hardware memory error detected in process but not consumed; action optional."
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:590
msgid ""
"The following values can be placed in I<si_code> for a B<SIGTRAP> signal:"
msgstr "B<SIGTRAP> シグナルの場合、 I<si_code> には以下の値を指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:591
#, no-wrap
msgid "B<TRAP_BRKPT>"
msgstr "B<TRAP_BRKPT>"

#. type: Plain text
#: build/C/man2/sigaction.2:594
msgid "process breakpoint"
msgstr "プロセスのブレークポイント"

#. type: TP
#: build/C/man2/sigaction.2:594
#, no-wrap
msgid "B<TRAP_TRACE>"
msgstr "B<TRAP_TRACE>"

#. type: Plain text
#: build/C/man2/sigaction.2:597
msgid "process trace trap"
msgstr "プロセスのトレース・トラップ"

#. type: TP
#: build/C/man2/sigaction.2:597
#, no-wrap
msgid "B<TRAP_BRANCH> (since Linux 2.4)"
msgstr "B<TRAP_BRANCH> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:600
msgid "process taken branch trap"
msgstr ""

#. type: TP
#: build/C/man2/sigaction.2:600
#, no-wrap
msgid "B<TRAP_HWBKPT> (since Linux 2.4)"
msgstr "B<TRAP_HWBKPT> (Linux 2.4 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:603
msgid "hardware breakpoint/watchpoint"
msgstr ""

#. type: Plain text
#: build/C/man2/sigaction.2:610
msgid ""
"The following values can be placed in I<si_code> for a B<SIGCHLD> signal:"
msgstr "B<SIGCHLD> シグナルの場合、 I<si_code> には以下の値を指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:611
#, no-wrap
msgid "B<CLD_EXITED>"
msgstr "B<CLD_EXITED>"

#. type: Plain text
#: build/C/man2/sigaction.2:614
msgid "child has exited"
msgstr "子プロセスが終了した (exited)"

#. type: TP
#: build/C/man2/sigaction.2:614
#, no-wrap
msgid "B<CLD_KILLED>"
msgstr "B<CLD_KILLED>"

#. type: Plain text
#: build/C/man2/sigaction.2:617
msgid "child was killed"
msgstr "子プロセスが kill された"

#. type: TP
#: build/C/man2/sigaction.2:617
#, no-wrap
msgid "B<CLD_DUMPED>"
msgstr "B<CLD_DUMPED>"

#. type: Plain text
#: build/C/man2/sigaction.2:620
msgid "child terminated abnormally"
msgstr "子プロセスが異常終了した"

#. type: TP
#: build/C/man2/sigaction.2:620
#, no-wrap
msgid "B<CLD_TRAPPED>"
msgstr "B<CLD_TRAPPED>"

#. type: Plain text
#: build/C/man2/sigaction.2:623
msgid "traced child has trapped"
msgstr "トレース対象の子プロセスがトラップを上げた"

#. type: TP
#: build/C/man2/sigaction.2:623
#, no-wrap
msgid "B<CLD_STOPPED>"
msgstr "B<CLD_STOPPED>"

#. type: Plain text
#: build/C/man2/sigaction.2:626
msgid "child has stopped"
msgstr "子プロセスが停止 (stop) した"

#. type: TP
#: build/C/man2/sigaction.2:626
#, no-wrap
msgid "B<CLD_CONTINUED>"
msgstr "B<CLD_CONTINUED>"

#. type: Plain text
#: build/C/man2/sigaction.2:629
msgid "stopped child has continued (since Linux 2.6.9)"
msgstr "停止していた子プロセスが再開した (Linux 2.6.9 以降)"

#. type: Plain text
#: build/C/man2/sigaction.2:636
msgid ""
"The following values can be placed in I<si_code> for a B<SIGIO>/B<SIGPOLL> "
"signal:"
msgstr ""
"B<SIGIO>/B<SIGPOLL> シグナルの場合、 I<si_code> には以下の値を\n"
"指定できる:"

#. type: TP
#: build/C/man2/sigaction.2:637
#, no-wrap
msgid "B<POLL_IN>"
msgstr "B<POLL_IN>"

#. type: Plain text
#: build/C/man2/sigaction.2:640
msgid "data input available"
msgstr "入力データが利用可能"

#. type: TP
#: build/C/man2/sigaction.2:640
#, no-wrap
msgid "B<POLL_OUT>"
msgstr "B<POLL_OUT>"

#. type: Plain text
#: build/C/man2/sigaction.2:643
msgid "output buffers available"
msgstr "出力バッファが利用可能"

#. type: TP
#: build/C/man2/sigaction.2:643
#, no-wrap
msgid "B<POLL_MSG>"
msgstr "B<POLL_MSG>"

#. type: Plain text
#: build/C/man2/sigaction.2:646
msgid "input message available"
msgstr "入力メッセージが利用可能"

#. type: TP
#: build/C/man2/sigaction.2:646
#, no-wrap
msgid "B<POLL_ERR>"
msgstr "B<POLL_ERR>"

#. type: Plain text
#: build/C/man2/sigaction.2:649
msgid "I/O error"
msgstr "I/O エラー"

#. type: TP
#: build/C/man2/sigaction.2:649
#, no-wrap
msgid "B<POLL_PRI>"
msgstr "B<POLL_PRI>"

#. type: Plain text
#: build/C/man2/sigaction.2:652
msgid "high priority input available"
msgstr "高優先の入力が利用可能"

#. type: TP
#: build/C/man2/sigaction.2:652
#, no-wrap
msgid "B<POLL_HUP>"
msgstr "B<POLL_HUP>"

#. type: Plain text
#: build/C/man2/sigaction.2:655
msgid "device disconnected"
msgstr "デバイスが接続されていない"

#. type: Plain text
#: build/C/man2/sigaction.2:659
msgid "B<sigaction>()  returns 0 on success and -1 on error."
msgstr "B<sigaction>()  は成功すれば 0 を返し、エラーならば -1 を返す。"

#. type: Plain text
#: build/C/man2/sigaction.2:664
msgid ""
"I<act> or I<oldact> points to memory which is not a valid part of the "
"process address space."
msgstr ""
"I<act> か I<oldact> が指しているメモリが正しいプロセスのアドレス空間にない。"

#. type: Plain text
#: build/C/man2/sigaction.2:671
msgid ""
"An invalid signal was specified.  This will also be generated if an attempt "
"is made to change the action for B<SIGKILL> or B<SIGSTOP>, which cannot be "
"caught or ignored."
msgstr ""
"無効なシグナルが指定された。補足 (catch) したり無視したりできない シグナルで"
"ある B<SIGKILL> や B<SIGSTOP> に対する動作を変更しようとした場合にも発生す"
"る。"

#.  SVr4 does not document the EINTR condition.
#. type: Plain text
#: build/C/man2/sigaction.2:674
msgid "POSIX.1-2001, SVr4."
msgstr "POSIX.1-2001, SVr4."

#. type: Plain text
#: build/C/man2/sigaction.2:682 build/C/man7/signal.7:103
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal "
"dispositions.  During an B<execve>(2), the dispositions of handled signals "
"are reset to the default; the dispositions of ignored signals are left "
"unchanged."
msgstr ""
"B<fork>(2) 経由で作成された子プロセスは、親プロセスのシグナルの処理方法の コ"
"ピーを継承する。\n"
"B<execve>(2) の前後で、ハンドラが設定されているシグナルの処理方法はデフォルト"
"にリセットされ、\n"
"無視が設定されているシグナルの処理方法は変更されずそのままとなる。"

#. type: Plain text
#: build/C/man2/sigaction.2:700 build/C/man2/signal.2:129
msgid ""
"According to POSIX, the behavior of a process is undefined after it ignores "
"a B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> signal that was not generated by "
"B<kill>(2)  or B<raise>(3).  Integer division by zero has undefined result.  "
"On some architectures it will generate a B<SIGFPE> signal.  (Also dividing "
"the most negative integer by -1 may generate B<SIGFPE>.)  Ignoring this "
"signal might lead to an endless loop."
msgstr ""
"POSIX では、 B<kill>(2)  や B<raise>(3)  で生成できないシグナル B<SIGFPE>, "
"B<SIGILL>, B<SIGSEGV> を無視 (ignore) した場合、その後の動作は未定義である。 "
"ゼロによる整数割り算の結果は未定義となる。 アーキテクチャーによっては、このと"
"き B<SIGFPE> シグナルが生成される。 (同様に負の最大整数を -1 で割ると "
"B<SIGFPE> が生成されるかもしれない)  このシグナルを無視すると無限ループに陥る"
"かもしれない。"

#. type: Plain text
#: build/C/man2/sigaction.2:717
msgid ""
"POSIX.1-1990 disallowed setting the action for B<SIGCHLD> to B<SIG_IGN>.  "
"POSIX.1-2001 allows this possibility, so that ignoring B<SIGCHLD> can be "
"used to prevent the creation of zombies (see B<wait>(2)).  Nevertheless, the "
"historical BSD and System V behaviors for ignoring B<SIGCHLD> differ, so "
"that the only completely portable method of ensuring that terminated "
"children do not become zombies is to catch the B<SIGCHLD> signal and perform "
"a B<wait>(2)  or similar."
msgstr ""
"POSIX.1-1990 では B<SIGCHLD> に B<SIG_IGN> を設定することを認めていない。 "
"POSIX.1-2001 では認められており、 B<SIGCHLD> を無視することでゾンビプロセスの"
"生成を防止することができる (B<wait>(2)  を参照)。 さらに、BSD と SystemV で"
"は B<SIGCHLD> を無視した際の動作が異なっている。 そのため、完全に移植性がある"
"方法で、終了した子プロセスがゾンビにならないこと を保証するには、 B<SIGCHLD> "
"シグナルを補足し、 B<wait>(2)  などを実行するしかない。"

#. type: Plain text
#: build/C/man2/sigaction.2:730
msgid ""
"POSIX.1-1990 only specified B<SA_NOCLDSTOP>.  POSIX.1-2001 added "
"B<SA_NOCLDWAIT>, B<SA_RESETHAND>, B<SA_NODEFER>, and B<SA_SIGINFO>.  Use of "
"these latter values in I<sa_flags> may be less portable in applications "
"intended for older UNIX implementations."
msgstr ""
"POSIX.1-1990 の仕様では B<SA_NOCLDSTOP> のみが定義されている。\n"
"POSIX.1-2001 では B<SA_NOCLDWAIT>, B<SA_RESETHAND>, B<SA_NODEFER>,\n"
"B<SA_SIGINFO> が追加された。 UNIX の古い実装で動かすアプリケーションで、\n"
"他の I<sa_flags> フラグを使用すると移植性が下がる。"

#. type: Plain text
#: build/C/man2/sigaction.2:734
msgid ""
"The B<SA_RESETHAND> flag is compatible with the SVr4 flag of the same name."
msgstr "B<SA_RESETHAND> フラグは SVr4 の同じ名前のフラグと互換性がある。"

#. type: Plain text
#: build/C/man2/sigaction.2:744
msgid ""
"The B<SA_NODEFER> flag is compatible with the SVr4 flag of the same name "
"under kernels 1.3.9 and newer.  On older kernels the Linux implementation "
"allowed the receipt of any signal, not just the one we are installing "
"(effectively overriding any I<sa_mask> settings)."
msgstr ""
"B<SA_NODEFER> フラグは 1.3.9 以降のカーネルでは同じ名前の SVr4 のフラグと互換"
"性がある。 ぞれ以前の Linux カーネルの実装では、このフラグを設定しているシグ"
"ナル だけでなく、どのシグナルでも受けることを許していた (実際には I<sa_mask> "
"の設定により無効にできる)。"

#. type: Plain text
#: build/C/man2/sigaction.2:750
msgid ""
"B<sigaction>()  can be called with a NULL second argument to query the "
"current signal handler.  It can also be used to check whether a given signal "
"is valid for the current machine by calling it with NULL second and third "
"arguments."
msgstr ""
"B<sigaction>()  の二番目の引き数に NULL を指定して呼び出すと、現在のシグナル"
"ハンドラを確認する ことができる。また、二番目と三番目の引き数を NULL にて呼び"
"出すことで、 指定されたシグナルが現在のマシンで使えるかどうかチェックできる。"

#. type: Plain text
#: build/C/man2/sigaction.2:756
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP> (by specifying them in "
"I<sa_mask>).  Attempts to do so are silently ignored."
msgstr ""
"B<SIGKILL> や B<SIGSTOP> を (I<sa_mask> に指定して) 禁止することはできない。 "
"禁止しようとしても黙って無視される。"

#. type: Plain text
#: build/C/man2/sigaction.2:760 build/C/man2/sigpending.2:65
#: build/C/man2/sigprocmask.2:139 build/C/man2/sigsuspend.2:104
msgid "See B<sigsetops>(3)  for details on manipulating signal sets."
msgstr "シグナル集合の操作に関する詳細は B<sigsetops>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sigaction.2:765
msgid ""
"See B<signal>(7)  for a list of the async-signal-safe functions that can be "
"safely called inside from inside a signal handler."
msgstr ""
"シグナルハンドラ内から安全に呼び出すことができる、 async-signal-safe "
"functions (非同期シングルで安全な関数) の リストについては B<signal>(7)  を参"
"照。"

#. type: SS
#: build/C/man2/sigaction.2:765
#, no-wrap
msgid "Undocumented"
msgstr "非公式"

#. type: Plain text
#: build/C/man2/sigaction.2:775
msgid ""
"Before the introduction of B<SA_SIGINFO> it was also possible to get some "
"additional information, namely by using a I<sa_handler> with second argument "
"of type I<struct sigcontext>.  See the relevant kernel sources for details.  "
"This use is obsolete now."
msgstr ""
"B<SA_SIGINFO> が導入される前は、 I<struct sigcontext> 型の二番目の引き数と一"
"緒に I<sa_handler> を使用することで、 いくつかの追加の情報を入手することがで"
"きた。 詳細についてはカーネルソースの関連部分を見てほしい。 現在はこの使用法"
"は廃止されている。"

#. type: Plain text
#: build/C/man2/sigaction.2:784
msgid ""
"In kernels up to and including 2.6.13, specifying B<SA_NODEFER> in "
"I<sa_flags> prevents not only the delivered signal from being masked during "
"execution of the handler, but also the signals specified in I<sa_mask>.  "
"This bug was fixed in kernel 2.6.14."
msgstr ""
"2.6.13 以前のカーネルでは、 I<sa_flags> に B<SA_NODEFER> を指定した場合、 ハ"
"ンドラが実行中に配送されたシグナル自身がマスクされなくなるだけでなく、 "
"I<sa_mask> に指定されたシグナルもマスクされなくなる。 このバグは、カーネル "
"2.6.14 で修正された。"

#. type: Plain text
#: build/C/man2/sigaction.2:787
msgid "See B<mprotect>(2)."
msgstr "B<mprotect>(2)  参照。"

#. type: Plain text
#: build/C/man2/sigaction.2:806
msgid ""
"B<kill>(1), B<kill>(2), B<killpg>(2), B<pause>(2), B<sigaltstack>(2), "
"B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), "
"B<sigsuspend>(2), B<wait>(2), B<raise>(3), B<siginterrupt>(3), B<sigqueue>"
"(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5), B<signal>(7)"
msgstr ""
"B<kill>(1), B<kill>(2), B<killpg>(2), B<pause>(2), B<sigaltstack>(2),\n"
"B<signal>(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2),\n"
"B<sigsuspend>(2), B<wait>(2), B<raise>(3), B<siginterrupt>(3),\n"
"B<sigqueue>(3), B<sigsetops>(3), B<sigvec>(3), B<core>(5),\n"
"B<signal>(7)"

#. type: TH
#: build/C/man2/sigaltstack.2:25
#, no-wrap
msgid "SIGALTSTACK"
msgstr "SIGALTSTACK"

#. type: TH
#: build/C/man2/sigaltstack.2:25 build/C/man2/wait.2:50
#, no-wrap
msgid "2010-09-26"
msgstr "2010-09-26"

#. type: Plain text
#: build/C/man2/sigaltstack.2:28
msgid "sigaltstack - set and/or get signal stack context"
msgstr "sigaltstack - シグナルスタックのコンテキストを設定・取得する"

#. type: Plain text
#: build/C/man2/sigaltstack.2:32
msgid "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<oss>B<);>"
msgstr "B<int sigaltstack(const stack_t *>I<ss>B<, stack_t *>I<oss>B<);>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:39
msgid "B<sigaltstack>():"
msgstr "B<sigaltstack>():"

#. type: Plain text
#: build/C/man2/sigaltstack.2:46 build/C/man3/siginterrupt.3:51
#: build/C/man2/wait.2:79
msgid "|| /* Since glibc 2.12: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"
msgstr "|| /* glibc 2.12 以降: */ _POSIX_C_SOURCE\\ E<gt>=\\ 200809L"

#. type: Plain text
#: build/C/man2/sigaltstack.2:58
msgid ""
"B<sigaltstack>()  allows a process to define a new alternate signal stack "
"and/or retrieve the state of an existing alternate signal stack.  An "
"alternate signal stack is used during the execution of a signal handler if "
"the establishment of that handler (see B<sigaction>(2))  requested it."
msgstr ""
"B<sigaltstack>()  を使うと、 プロセスは新しい代替シグナルスタックを定義した"
"り、 既存の代替シグナルスタックの状態を取得できる。 シグナルハンドラが代替シ"
"グナルスタックを要求するように設定されていると (B<sigaction>(2)  参照)、ハン"
"ドラの実行中はそのシグナルスタックが使われる。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:61
msgid ""
"The normal sequence of events for using an alternate signal stack is the "
"following:"
msgstr "代替シグナルスタックを使う際の一般的な手順は、以下の通りである:"

#. type: IP
#: build/C/man2/sigaltstack.2:61 build/C/man7/signal.7:385
#, no-wrap
msgid "1."
msgstr "1."

#. type: Plain text
#: build/C/man2/sigaltstack.2:65
msgid "Allocate an area of memory to be used for the alternate signal stack."
msgstr "代替シグナルスタックで使うメモリ領域を確保する。"

#. type: IP
#: build/C/man2/sigaltstack.2:65 build/C/man7/signal.7:389
#, no-wrap
msgid "2."
msgstr "2."

#. type: Plain text
#: build/C/man2/sigaltstack.2:71
msgid ""
"Use B<sigaltstack>()  to inform the system of the existence and location of "
"the alternate signal stack."
msgstr ""
"B<sigaltstack>()  を使って、 代替シグナルスタックの存在と場所をシステムに知ら"
"せる。"

#. type: IP
#: build/C/man2/sigaltstack.2:71 build/C/man7/signal.7:409
#, no-wrap
msgid "3."
msgstr "3."

#. type: Plain text
#: build/C/man2/sigaltstack.2:78
msgid ""
"When establishing a signal handler using B<sigaction>(2), inform the system "
"that the signal handler should be executed on the alternate signal stack by "
"specifying the B<SA_ONSTACK> flag."
msgstr ""
"B<sigaction>(2)  を使ってシグナルハンドラを確立する際、 B<SA_ONSTACK> フラグ"
"を指定することにより、 そのシグナルハンドラを代替シグナルスタック上で実行する"
"ことを システムに知らせる。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:86
msgid ""
"The I<ss> argument is used to specify a new alternate signal stack, while "
"the I<oss> argument is used to retrieve information about the currently "
"established signal stack.  If we are interested in performing just one of "
"these tasks then the other argument can be specified as NULL.  Each of these "
"arguments is a structure of the following type:"
msgstr ""
"I<ss> 引き数は、新しいシグナルスタックを指定するために使う。 また I<oss> 引き"
"数は、現在確立されている シグナルスタックの情報を取得するために使う。 この操"
"作のうち 1 つだけを実行させるには、 使用しない引き数を NULL に指定すればよ"
"い。 引き数となる構造体は、以下のような型である:"

#. type: Plain text
#: build/C/man2/sigaltstack.2:94
#, no-wrap
msgid ""
"typedef struct {\n"
"    void  *ss_sp;     /* Base address of stack */\n"
"    int    ss_flags;  /* Flags */\n"
"    size_t ss_size;   /* Number of bytes in stack */\n"
"} stack_t;\n"
msgstr ""
"typedef struct {\n"
"    void  *ss_sp;     /* スタックのベースアドレス */\n"
"    int    ss_flags;  /* フラグ */\n"
"    size_t ss_size;   /* スタックのバイト数 */\n"
"} stack_t;\n"

#. type: Plain text
#: build/C/man2/sigaltstack.2:105
msgid ""
"To establish a new alternate signal stack, I<ss.ss_flags> is set to zero, "
"and I<ss.ss_sp> and I<ss.ss_size> specify the starting address and size of "
"the stack.  The constant B<SIGSTKSZ> is defined to be large enough to cover "
"the usual size requirements for an alternate signal stack, and the constant "
"B<MINSIGSTKSZ> defines the minimum size required to execute a signal handler."
msgstr ""
"新規の代替シグナルスタックを確立するには、 I<ss.ss_flags> を 0 に設定し、 "
"I<ss.ss_sp> と I<ss.ss_size> に スタックの開始アドレスとスタックサイズを指定"
"する。 定数 B<SIGSTKSZ> は、代替シグナルスタックが通常必要する サイズよりも充"
"分大きく定義されている。 また定数 B<MINSIGSTKSZ> は、 シグナルハンドラの実行"
"に必要な最小サイズに定義されている。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:109
msgid ""
"When a signal handler is invoked on the alternate stack, the kernel "
"automatically aligns the address given in I<ss.ss_sp> to a suitable address "
"boundary for the underlying hardware architecture."
msgstr ""
"代替スタックでシグナルハンドラが起動された場合には、 カーネルにより自動的に、"
"I<ss.ss_sp> で指定されたアドレスは 動作しているハードウェアアーキテクチャに適"
"したアドレス境界に 調整される。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:114
msgid ""
"To disable an existing stack, specify I<ss.ss_flags> as B<SS_DISABLE>.  In "
"this case, the remaining fields in I<ss> are ignored."
msgstr ""
"既存のスタックを無効にするには、 I<ss.ss_flags> を B<SS_DISABLE> に指定す"
"る。 この場合、I<ss> の他のフィールドは無視される。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:122
msgid ""
"If I<oss> is not NULL, then it is used to return information about the "
"alternate signal stack which was in effect prior to the call to "
"B<sigaltstack>().  The I<oss.ss_sp> and I<oss.ss_size> fields return the "
"starting address and size of that stack.  The I<oss.ss_flags> may return "
"either of the following values:"
msgstr ""
"I<oss> が NULL 以外の場合、 I<oss> に代替シグナルスタックの情報が返される。 "
"これは (実質的に)  B<sigaltstack>()  の呼び出しより先に行われる。 I<oss."
"ss_sp> と I<oss.ss_size> フィールドに スタックの開始アドレスとスタックサイズ"
"が返される。 I<oss.ss_flags> には以下のどちらかの値が返される:"

#. type: TP
#: build/C/man2/sigaltstack.2:122
#, no-wrap
msgid "B<SS_ONSTACK>"
msgstr "B<SS_ONSTACK>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:128
msgid ""
"The process is currently executing on the alternate signal stack.  (Note "
"that it is not possible to change the alternate signal stack if the process "
"is currently executing on it.)"
msgstr ""
"プロセスが代替シグナルスタック上で実行されている (プロセスが既にそのシグナル"
"スタック上で実行されている場合は、 それと同じシグナルスタックには変更できない"
"点に注意すること)。"

#. type: TP
#: build/C/man2/sigaltstack.2:128
#, no-wrap
msgid "B<SS_DISABLE>"
msgstr "B<SS_DISABLE>"

#. type: Plain text
#: build/C/man2/sigaltstack.2:131
msgid "The alternate signal stack is currently disabled."
msgstr "代替シグナルスタックが現在無効になっている。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:135
msgid ""
"B<sigaltstack>()  returns 0 on success, or -1 on failure with I<errno> set "
"to indicate the error."
msgstr ""
"B<sigaltstack>()  は成功した場合 0 を返す。 失敗した場合は -1 を返して、 エ"
"ラーを示す値に I<errno> を設定する。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:140
msgid ""
"Either I<ss> or I<oss> is not NULL and points to an area outside of the "
"process's address space."
msgstr ""
"I<ss> または I<oss> のどちらが、NULL 以外で、 かつプロセスのアドレス空間の外"
"を指している。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:145
msgid ""
"I<ss> is not NULL and the I<ss_flags> field contains a nonzero value other "
"than B<SS_DISABLE>."
msgstr ""
"I<ss> が NULL 以外で、I<ss_flags> フィールドが B<SS_DISABLE> 以外の 0 でない"
"値になっている。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:149
msgid ""
"The specified size of the new alternate signal stack (I<ss.ss_size>) was "
"less than B<MINSTKSZ>."
msgstr ""
"新しい代替シグナルスタック (I<ss.ss_size>) に指定したサイズが B<MINSTKSZ> よ"
"り小さい。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:154
msgid ""
"An attempt was made to change the alternate signal stack while it was active "
"(i.e., the process was already executing on the current alternate signal "
"stack)."
msgstr ""
"代替シグナルスタックが有効であるときに変更を行おうとした (つまり、プロセスが"
"既に現在の代替シグナルスタック上で実行されていた)。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:156
msgid "SUSv2, SVr4, POSIX.1-2001."
msgstr "SUSv2, SVr4, POSIX.1-2001."

#. type: Plain text
#: build/C/man2/sigaltstack.2:164
msgid ""
"The most common usage of an alternate signal stack is to handle the "
"B<SIGSEGV> signal that is generated if the space available for the normal "
"process stack is exhausted: in this case, a signal handler for B<SIGSEGV> "
"cannot be invoked on the process stack; if we wish to handle it, we must use "
"an alternate signal stack."
msgstr ""
"代替シグナルスタックを使用する最もよくある場面は、 B<SIGSEGV> シグナルを扱う"
"ときである。 B<SIGSEGV> はプロセスの通常のスタックが利用できる空間が使い果た"
"された際に 生成されるシグナルである。この場合には、 B<SIGSEGV> 用のシグナルハ"
"ンドラをプロセスのスタック上では起動することができない。 そのため、このシグナ"
"ルを扱おうとする場合には、 代替シグナルスタックを使用しなければならない。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:174
msgid ""
"Establishing an alternate signal stack is useful if a process expects that "
"it may exhaust its standard stack.  This may occur, for example, because the "
"stack grows so large that it encounters the upwardly growing heap, or it "
"reaches a limit established by a call to B<setrlimit(RLIMIT_STACK, &rlim)>.  "
"If the standard stack is exhausted, the kernel sends the process a "
"B<SIGSEGV> signal.  In these circumstances the only way to catch this signal "
"is on an alternate signal stack."
msgstr ""
"プロセスが標準のシグナルスタックを使い果たすことが予想される場合は、 代替シグ"
"ナルスタックを確立すると便利である。 例えば、スタックが最上位アドレスから 下"
"位アドレス方向に非常にたくさん積まれてしまうことで、 最下位アドレスから上位ア"
"ドレス方向に積まれるヒープとぶつかってしまう場合や、 B<setrlimit"
"(RLIMIT_STACK, &rlim)> の呼び出しで確立された 制限に達してしまった場合に、こ"
"の様な事が起こる。 標準のスタックを使い果たしてしまうと、 カーネルはプロセス"
"に B<SIGSEGV> シグナルを送る。 このような状況では、代替シグナルスタック上でし"
"かシグナルをキャッチできない。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:180
msgid ""
"On most hardware architectures supported by Linux, stacks grow downward.  "
"B<sigaltstack>()  automatically takes account of the direction of stack "
"growth."
msgstr ""
"Linux がサポートする多くのハードウェアアーキテクチャでは、 スタックは下位アド"
"レス方向に積まれる。 B<sigaltstack>()  はスタックが積まれる方向を自動的に決定"
"する。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:189
msgid ""
"Functions called from a signal handler executing on an alternate signal "
"stack will also use the alternate signal stack.  (This also applies to any "
"handlers invoked for other signals while the process is executing on the "
"alternate signal stack.)  Unlike the standard stack, the system does not "
"automatically extend the alternate signal stack.  Exceeding the allocated "
"size of the alternate signal stack will lead to unpredictable results."
msgstr ""
"代替シグナルスタック上で実行されている シグナルハンドラから呼ばれる関数も、代"
"替シグナルハンドラを使う (プロセスが代替シグナルスタック上で実行されている場"
"合、 他のシグナルで呼び出されるハンドラもこの代替シグナルハンドラを使う)。 標"
"準のスタックとは異なり、 システムは代替シグナルスタックを自動的に拡張しな"
"い。 代替シグナルスタック用に確保したサイズを越えた場合、 結果は予想できな"
"い。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:197
msgid ""
"A successful call to B<execve>(2)  removes any existing alternate signal "
"stack.  A child process created via B<fork>(2)  inherits a copy of its "
"parent's alternate signal stack settings."
msgstr ""
"B<execve>(2)  の呼び出しが成功すると、 既存の全ての代替シグナルスタックが削除"
"される。 B<fork>(2)  経由で作成された子プロセスは、親プロセスの代替シグナルス"
"タックの 設定のコピーを継承する。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:206
msgid ""
"B<sigaltstack>()  supersedes the older B<sigstack>()  call.  For backward "
"compatibility, glibc also provides B<sigstack>().  All new applications "
"should be written using B<sigaltstack>()."
msgstr ""
"B<sigaltstack>()  は以前の B<sigstack>()  を置き換えるものである。 過去プログ"
"ラムとの互換性のため、glibc では B<sigstack>()  も提供している。 新しいのアプ"
"リケーションは全て B<sigaltstack>()  を使って書くべきである。"

#. type: SS
#: build/C/man2/sigaltstack.2:206 build/C/man3/sigpause.3:59
#, no-wrap
msgid "History"
msgstr "歴史"

#. type: Plain text
#: build/C/man2/sigaltstack.2:213
msgid ""
"4.2BSD had a B<sigstack>()  system call.  It used a slightly different "
"struct, and had the major disadvantage that the caller had to know the "
"direction of stack growth."
msgstr ""
"4.2BSD には B<sigstack>()  システムコールがあった。 この関数は少し異なった構"
"造体を使っており、 呼び出した側がスタックの積まれる方向を知っていなければなら"
"ないという 大きな欠点があった。"

#. type: Plain text
#: build/C/man2/sigaltstack.2:216
msgid "The following code segment demonstrates the use of B<sigaltstack>():"
msgstr "以下のコードで B<sigaltstack>()  の使用法の一部を示す:"

#. type: Plain text
#: build/C/man2/sigaltstack.2:220
#, no-wrap
msgid "stack_t ss;\n"
msgstr "stack_t ss;\n"

#. type: Plain text
#: build/C/man2/sigaltstack.2:228
#, no-wrap
msgid ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL)\n"
"    /* Handle error */;\n"
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1)\n"
"    /* Handle error */;\n"
msgstr ""
"ss.ss_sp = malloc(SIGSTKSZ);\n"
"if (ss.ss_sp == NULL)\n"
"    /* ハンドルエラー */;\n"
"ss.ss_size = SIGSTKSZ;\n"
"ss.ss_flags = 0;\n"
"if (sigaltstack(&ss, NULL) == -1)\n"
"    /* ハンドルエラー */;\n"

#. type: Plain text
#: build/C/man2/sigaltstack.2:237
msgid ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"
msgstr ""
"B<execve>(2), B<setrlimit>(2), B<sigaction>(2), B<siglongjmp>(3), "
"B<sigsetjmp>(3), B<signal>(7)"

#. type: TH
#: build/C/man7/sigevent.7:24
#, no-wrap
msgid "SIGEVENT"
msgstr "SIGEVENT"

#. type: TH
#: build/C/man7/sigevent.7:24 build/C/man3/siginterrupt.3:29
#, no-wrap
msgid "2011-09-09"
msgstr "2011-09-09"

#. type: Plain text
#: build/C/man7/sigevent.7:27
msgid "sigevent - structure for notification from asynchronous routines"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:34
#, no-wrap
msgid ""
"union sigval {          /* Data passed with notification */\n"
"    int     sival_int;         /* Integer value */\n"
"    void   *sival_ptr;         /* Pointer value */\n"
"};\n"
msgstr ""
"union sigval {          /* Data passed with notification */\n"
"    int     sival_int;         /* Integer value */\n"
"    void   *sival_ptr;         /* Pointer value */\n"
"};\n"

#. type: Plain text
#: build/C/man7/sigevent.7:49
#, no-wrap
msgid ""
"struct sigevent {\n"
"    int          sigev_notify; /* Notification method */\n"
"    int          sigev_signo;  /* Notification signal */\n"
"    union sigval sigev_value;  /* Data passed with\n"
"                                  notification */\n"
"    void       (*sigev_notify_function) (union sigval);\n"
"                     /* Function used for thread\n"
"                        notification (SIGEV_THREAD) */\n"
"    void        *sigev_notify_attributes;\n"
"                     /* Attributes for notification thread\n"
"                        (SIGEV_THREAD) */\n"
"    pid_t        sigev_notify_thread_id;\n"
"                     /* ID of thread to signal (SIGEV_THREAD_ID) */\n"
"};\n"
msgstr ""
"struct sigevent {\n"
"    int          sigev_notify; /* Notification method */\n"
"    int          sigev_signo;  /* Notification signal */\n"
"    union sigval sigev_value;  /* Data passed with\n"
"                                  notification */\n"
"    void       (*sigev_notify_function) (union sigval);\n"
"                     /* Function used for thread\n"
"                        notification (SIGEV_THREAD) */\n"
"    void        *sigev_notify_attributes;\n"
"                     /* Attributes for notification thread\n"
"                        (SIGEV_THREAD) */\n"
"    pid_t        sigev_notify_thread_id;\n"
"                     /* ID of thread to signal (SIGEV_THREAD_ID) */\n"
"};\n"

#. type: Plain text
#: build/C/man7/sigevent.7:58
msgid ""
"The I<sigevent> structure is used by various APIs to describe the way a "
"process is to be notified about an event (e.g., completion of an "
"asynchronous request, expiration of a timer, or the arrival of a message)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:66
msgid ""
"The definition shown in the SYNOPSIS is approximate: some of the fields in "
"the I<sigevent> structure may be defined as part of a union.  Programs "
"should only employ those fields relevant to the value specified in "
"I<sigev_notify>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:71
msgid ""
"The I<sigev_notify> field specifies how notification is to be performed.  "
"This field can have one of the following values:"
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:71 build/C/man2/timer_create.2:105
#, no-wrap
msgid "B<SIGEV_NONE>"
msgstr "B<SIGEV_NONE>"

#. type: Plain text
#: build/C/man7/sigevent.7:74
msgid "A \"null\" notification: don't do anything when the event occurs."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:74 build/C/man2/timer_create.2:110
#, no-wrap
msgid "B<SIGEV_SIGNAL>"
msgstr "B<SIGEV_SIGNAL>"

#. type: Plain text
#: build/C/man7/sigevent.7:78
msgid "Notify the process by sending the signal specified in I<sigev_signo>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:85
msgid ""
"If the signal is caught with a signal handler that was registered using the "
"B<sigaction>(2)  B<SA_SIGINFO> flag, then the following fields are set in "
"the I<siginfo_t> structure that is passed as the second argument of the "
"handler:"
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:90
msgid ""
"This field is set to a value that depends on the API delivering the "
"notification."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:90 build/C/man2/wait.2:301
#, no-wrap
msgid "I<si_signo>"
msgstr "I<si_signo>"

#. type: Plain text
#: build/C/man7/sigevent.7:94
msgid ""
"This field is set to the signal number (i.e., the same value as in "
"I<sigev_signo>)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:98
msgid "This field is set to the value specified in I<sigev_value>."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:103
msgid ""
"Depending on the API, other fields may also be set in the I<siginfo_t> "
"structure."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:106
msgid ""
"The same information is also available if the signal is accepted using "
"B<sigwaitinfo>(2)."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:106 build/C/man2/timer_create.2:128
#, no-wrap
msgid "B<SIGEV_THREAD>"
msgstr "B<SIGEV_THREAD>"

#. type: Plain text
#: build/C/man7/sigevent.7:123
msgid ""
"Notify the process by invoking I<sigev_notify_function> \"as if\" it were "
"the start function of a new thread.  (Among the implementation possibilities "
"here are that each timer notification could result in the creation of a new "
"thread, or that a single thread is created to receive all notifications.)  "
"The function is invoked with I<sigev_value> as its sole argument.  If "
"I<sigev_notify_attributes> is not NULL, it should point to a "
"I<pthread_attr_t> structure that defines attributes for the new thread (see "
"B<pthread_attr_init>(3))."
msgstr ""

#. type: TP
#: build/C/man7/sigevent.7:123 build/C/man2/timer_create.2:136
#, no-wrap
msgid "B<SIGEV_THREAD_ID> (Linux-specific)"
msgstr ""

#.  | SIGEV_SIGNAL vs not?
#. type: Plain text
#: build/C/man7/sigevent.7:128
msgid "Currently used only by POSIX timers; see B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man7/sigevent.7:130 build/C/man2/sigpending.2:61
#: build/C/man2/sigprocmask.2:109 build/C/man3/sigqueue.3:114
#: build/C/man3/sigsetops.3:128 build/C/man2/sigsuspend.2:82
#: build/C/man3/sigwait.3:79 build/C/man2/sigwaitinfo.2:131
#: build/C/man2/timer_create.2:193 build/C/man2/timer_delete.2:66
#: build/C/man2/timer_getoverrun.2:96 build/C/man2/timer_settime.2:205
msgid "POSIX.1-2001."
msgstr "POSIX.1-2001."

#. type: Plain text
#: build/C/man7/sigevent.7:140
msgid ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"
msgstr ""
"B<timer_create>(2), B<aio_fsync>(3), B<aio_read>(3), B<aio_write>(3), "
"B<getaddrinfo_a>(3), B<lio_listio>(3), B<mq_notify>(3), B<aio>(7), "
"B<pthreads>(7)"

#. type: TH
#: build/C/man3/siginterrupt.3:29
#, no-wrap
msgid "SIGINTERRUPT"
msgstr "SIGINTERRUPT"

#. type: Plain text
#: build/C/man3/siginterrupt.3:32
msgid "siginterrupt - allow signals to interrupt system calls"
msgstr "siginterrupt - シグナルでシステム・コールに割り込むことを許す"

#. type: Plain text
#: build/C/man3/siginterrupt.3:37
#, no-wrap
msgid "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"
msgstr "B<int siginterrupt(int >I<sig>B<, int >I<flag>B<);>\n"

#. type: Plain text
#: build/C/man3/siginterrupt.3:45
msgid "B<siginterrupt>():"
msgstr "B<siginterrupt>():"

#. type: Plain text
#: build/C/man3/siginterrupt.3:62
msgid ""
"The B<siginterrupt>()  function changes the restart behavior when a system "
"call is interrupted by the signal I<sig>.  If the I<flag> argument is false "
"(0), then system calls will be restarted if interrupted by the specified "
"signal I<sig>.  This is the default behavior in Linux."
msgstr ""
"B<siginterrupt>()  関数は、システム・コールがシグナル I<sig> によって割り込ま"
"れた後、再実行の際の振る舞いを変更する。 I<flag> 引き数が偽 (0) ならば、シス"
"テム・コールが指定した シグナル I<sig> によって割り込まれた後に、そのシステ"
"ム・コールは 再実行される。これは Linux においてデフォルトの動作である。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:67
msgid ""
"If the I<flag> argument is true (1) and no data has been transferred, then a "
"system call interrupted by the signal I<sig> will return -1 and I<errno> "
"will be set to B<EINTR>."
msgstr ""
"I<flag> 引き数が真 (1) でデータの転送が全く行なわれていないならば、 シグナル "
"I<sig> でシステム・コールは中断されて、-1 が返され、 I<errno> に B<EINTR> が"
"設定される。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:71
msgid ""
"If the I<flag> argument is true (1) and data transfer has started, then the "
"system call will be interrupted and will return the actual amount of data "
"transferred."
msgstr ""
"I<flag> 引き数が真 (1) でデータの転送が開始されていれば、 システム・コールは"
"中断され、それまでに実際に転送されたデータ の量が返される。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:76
msgid ""
"The B<siginterrupt>()  function returns 0 on success, or -1 if the signal "
"number I<sig> is invalid."
msgstr ""
"B<siginterrupt>()  関数は成功した場合 0 を返す。 シグナル番号 I<sig> が不正な"
"場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:80
msgid "The specified signal number is invalid."
msgstr "指定したシグナル番号が不正である。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:89
msgid ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 marks B<siginterrupt>()  as obsolete, "
"recommending the use of B<sigaction>(2)  with the B<SA_RESTART> flag instead."
msgstr ""
"4.3BSD, POSIX.1-2001.  POSIX.1-2008 は、 B<siginterrupt>()  を廃止予定として"
"いる。 代わりに、 B<sigaction>(2)  に B<SA_RESTART> フラグを指定して使うこと"
"を推奨している。"

#. type: Plain text
#: build/C/man3/siginterrupt.3:91
msgid "B<signal>(2)"
msgstr "B<signal>(2)"

#. type: TH
#: build/C/man2/signal.2:34 build/C/man7/signal.7:44
#, no-wrap
msgid "SIGNAL"
msgstr "SIGNAL"

#. type: TH
#: build/C/man2/signal.2:34
#, no-wrap
msgid "2012-05-05"
msgstr "2012-05-05"

#. type: Plain text
#: build/C/man2/signal.2:37
msgid "signal - ANSI C signal handling"
msgstr "signal - ANSI C シグナル操作"

#. type: Plain text
#: build/C/man2/signal.2:43
msgid "B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t signal(int >I<signum>B<, sighandler_t >I<sighandler>B<);>"

#. type: Plain text
#: build/C/man2/signal.2:52
msgid ""
"The behavior of B<signal>()  varies across UNIX versions, and has also "
"varied historically across different versions of Linux.  B<Avoid its use>: "
"use B<sigaction>(2)  instead.  See I<Portability> below."
msgstr ""
"B<signal>()  の動作は UNIX のバージョンにより異なる。 また、歴史的に見て "
"Linux のバージョンによっても異なっている。 B<このシステムコールの使用は避け、"
"> 代わりに B<sigaction>(2)  を使用すること。 下記の「移植性」を参照。"

#. type: Plain text
#: build/C/man2/signal.2:62
msgid ""
"B<signal>()  sets the disposition of the signal I<signum> to I<handler>, "
"which is either B<SIG_IGN>, B<SIG_DFL>, or the address of a programmer-"
"defined function (a \"signal handler\")."
msgstr ""
"B<signal>()  はシグナル I<signum> の処理方法を I<handler> に設定する。 "
"I<handler> には、 B<SIG_IGN>、 B<SIG_DFL>、 プログラマが定義した関数 (「シグ"
"ナル・ハンドラ」) のアドレスの いずれかを指定する。"

#. type: Plain text
#: build/C/man2/signal.2:66
msgid ""
"If the signal I<signum> is delivered to the process, then one of the "
"following happens:"
msgstr ""
"シグナル I<signum> がプロセスに配送されると、以下のいずれかが発生する。"

#. type: Plain text
#: build/C/man2/signal.2:71
msgid "If the disposition is set to B<SIG_IGN>, then the signal is ignored."
msgstr "処理方法が B<SIG_IGN> に設定されている場合、そのシグナルは無視される。"

#. type: Plain text
#: build/C/man2/signal.2:78
msgid ""
"If the disposition is set to B<SIG_DFL>, then the default action associated "
"with the signal (see B<signal>(7))  occurs."
msgstr ""
"処理方法が B<SIG_DFL> に設定されている場合、シグナルに関連づけられた デフォル"
"トの動作が行われる (B<signal>(7)  参照)。"

#. type: Plain text
#: build/C/man2/signal.2:89
msgid ""
"If the disposition is set to a function, then first either the disposition "
"is reset to B<SIG_DFL>, or the signal is blocked (see I<Portability> below), "
"and then I<handler> is called with argument I<signum>.  If invocation of the "
"handler caused the signal to be blocked, then the signal is unblocked upon "
"return from the handler."
msgstr ""
"処理方法として関数が設定されている場合、 まず最初に処理方法が B<SIG_DFL> にリ"
"セットされるかそのシグナルのブロックが実行された後、 I<signum> を引き数とし"
"て I<handler> が呼び出される。 ハンドラが起動される際にシグナルがブロックされ"
"た場合、 ハンドラが返る際にそのシグナルのブロックが解除される。"

#. type: Plain text
#: build/C/man2/signal.2:95
msgid "The signals B<SIGKILL> and B<SIGSTOP> cannot be caught or ignored."
msgstr ""
"シグナル B<SIGKILL> と B<SIGSTOP> は捕捉できず、無視することもできない。"

#. type: Plain text
#: build/C/man2/signal.2:100
msgid ""
"B<signal>()  returns the previous value of the signal handler, or B<SIG_ERR> "
"on error."
msgstr ""
"B<signal>()  は、今までのシグナル・ハンドラの値を返す。エラーの場合は "
"B<SIG_ERR> を返す。"

#. type: Plain text
#: build/C/man2/signal.2:105
msgid "I<signum> is invalid."
msgstr "I<signum> が不正である。"

#. type: Plain text
#: build/C/man2/signal.2:111
msgid "The effects of B<signal>()  in a multithreaded process are unspecified."
msgstr ""
"マルチスレッドプロセスにおける B<signal>()  の結果は、指定されていない。"

#. type: Plain text
#: build/C/man2/signal.2:136
msgid ""
"See B<sigaction>(2)  for details on what happens when B<SIGCHLD> is set to "
"B<SIG_IGN>."
msgstr ""
"B<SIGCHLD> の動作として B<SIG_IGN> を設定した場合の詳細な動作については、 "
"B<sigaction>(2)  を参照すること。"

#. type: Plain text
#: build/C/man2/signal.2:141
msgid ""
"See B<signal>(7)  for a list of the async-signal-safe functions that can be "
"safely called from inside a signal handler."
msgstr ""
"シグナル・ハンドラ内から安全に呼び出すことができる、 async-signal-safe "
"functions (非同期シングルで安全な関数) の リストについては B<signal>(7)  を参"
"照。"

#.  libc4 and libc5 define
#.  .IR SignalHandler ;
#. type: Plain text
#: build/C/man2/signal.2:157
msgid ""
"The use of I<sighandler_t> is a GNU extension, exposed if B<_GNU_SOURCE> is "
"defined; glibc also defines (the BSD-derived)  I<sig_t> if B<_BSD_SOURCE> is "
"defined.  Without use of such a type, the declaration of B<signal>()  is the "
"somewhat harder to read:"
msgstr ""
"I<sighandler_t> の使用は GNU 拡張であり、 B<_GNU_SOURCE> が定義された\n"
"場合に公開される。glibc では B<_BSD_SOURCE> が定義された場合には (BSD\n"
"由来の) I<sig_t> も定義される。このような型を使用しないと、\n"
"B<signal>() の宣言は読みにくいものとなる。"

#. type: Plain text
#: build/C/man2/signal.2:161
#, no-wrap
msgid "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"
msgstr "B<void ( *>I<signal>B<(int >I<signum>B<, void (*>I<handler>B<)(int)) ) (int);>\n"

#. type: SS
#: build/C/man2/signal.2:163
#, no-wrap
msgid "Portability"
msgstr "移植性"

#. type: Plain text
#: build/C/man2/signal.2:175
msgid ""
"The only portable use of B<signal>()  is to set a signal's disposition to "
"B<SIG_DFL> or B<SIG_IGN>.  The semantics when using B<signal>()  to "
"establish a signal handler vary across systems (and POSIX.1 explicitly "
"permits this variation); B<do not use it for this purpose.>"
msgstr ""
"移植性のある B<signal>()  の使い方は、シグナルの処理方法を B<SIG_DFL> か "
"B<SIG_IGN> に設定する方法だけである。 シグナル・ハンドラを設定するのに "
"B<signal>()  を使ったときの動作はシステムにより異なる (POSIX.1 は明示的にこの"
"違いを認めている)。 B<移植性が必要なときはこのシステムコールを使用しないこ"
"と。>"

#. type: Plain text
#: build/C/man2/signal.2:181
msgid ""
"POSIX.1 solved the portability mess by specifying B<sigaction>(2), which "
"provides explicit control of the semantics when a signal handler is invoked; "
"use that interface instead of B<signal>()."
msgstr ""
"POSIX.1 は、 B<sigaction>(2)  を規定することで移植性に関する混乱を解決した。 "
"B<sigaction>(2)  はシグナル・ハンドラが起動される際の挙動を明示的に制御でき"
"る。 B<signal>()  の代わりにこのインターフェイスを使うこと。"

#. type: Plain text
#: build/C/man2/signal.2:194
msgid ""
"In the original UNIX systems, when a handler that was established using "
"B<signal>()  was invoked by the delivery of a signal, the disposition of the "
"signal would be reset to B<SIG_DFL>, and the system did not block delivery "
"of further instances of the signal.  System V also provides these semantics "
"for B<signal>().  This was bad because the signal might be delivered again "
"before the handler had a chance to reestablish itself.  Furthermore, rapid "
"deliveries of the same signal could result in recursive invocations of the "
"handler."
msgstr ""
"オリジナルの UNIX システムでは、 B<signal>()  を使って設定されたハンドラがシ"
"グナルの配送により起動されると、 そのシグナルの処理方法は B<SIG_DFL> にリセッ"
"トされ、システムは同じシグナルがさらに生成されても シグナルの配送をブロックし"
"なかった。 System V でも、 B<signal>()  に対してこれらの挙動を規定している。 "
"こうした挙動はまずく、ハンドラがハンドラ自身を再設定する機会が 来るより前に、"
"同じシグナルがまた配送される可能性がある。 さらに、同じシグナルが立て続けに配"
"送されると、同じシグナルが ハンドラを繰り返し起動されることになる。"

#. type: Plain text
#: build/C/man2/signal.2:204
msgid ""
"BSD improved on this situation by changing the semantics of signal handling "
"(but, unfortunately, silently changed the semantics when establishing a "
"handler with B<signal>()).  On BSD, when a signal handler is invoked, the "
"signal disposition is not reset, and further instances of the signal are "
"blocked from being delivered while the handler is executing."
msgstr ""
"BSD では、シグナル処理の挙動を変更することで、この状況を改善した (しかし、残"
"念なことに、 B<signal>()  を使ってハンドラを設定する際に挙動が黙って変更され"
"る)。 BSD では、シグナルハンドラが起動された際、 シグナルの処理方法はリセット"
"されず、 ハンドラの実行中は、同じシグナルのさらなる生成は配送がブロックされ"
"る。"

#. type: Plain text
#: build/C/man2/signal.2:206
msgid "The situation on Linux is as follows:"
msgstr "Linux での状況は以下の通りである。"

#. type: Plain text
#: build/C/man2/signal.2:210
msgid "The kernel's B<signal>()  system call provides System V semantics."
msgstr "カーネルの B<signal>()  システムコールは System V 方式を提供している。"

#. type: Plain text
#: build/C/man2/signal.2:226
msgid ""
"By default, in glibc 2 and later, the B<signal>()  wrapper function does not "
"invoke the kernel system call.  Instead, it calls B<sigaction>(2)  using "
"flags that supply BSD semantics.  This default behavior is provided as long "
"as the B<_BSD_SOURCE> feature test macro is defined.  By default, "
"B<_BSD_SOURCE> is defined; it is also implicitly defined if one defines "
"B<_GNU_SOURCE>, and can of course be explicitly defined."
msgstr ""
"デフォルトでは、glibc 2 以降では、 B<signal>()  ラッパー関数はカーネルのシス"
"テムコールを起動しない。 代わりに、ラッパー関数は BSD 方式を示すフラグを使っ"
"て B<sigaction>(2)  を呼び出す。 機能検査マクロ B<_BSD_SOURCE> を定義していれ"
"ば、このデフォルトの動作となる。 デフォルトでは、 B<_BSD_SOURCE> が定義され"
"る。 B<_BSD_SOURCE> は B<_GNU_SOURCE> が定義された場合には暗黙のうちに定義さ"
"れ、 もちろん明示的に定義することもできる。"

#.  System V semantics are also provided if one uses the separate
#.  .BR sysv_signal (3)
#.  function.
#. type: Plain text
#: build/C/man2/signal.2:249
msgid ""
"On glibc 2 and later, if the B<_BSD_SOURCE> feature test macro is not "
"defined, then B<signal>()  provides System V semantics.  (The default "
"implicit definition of B<_BSD_SOURCE> is not provided if one invokes B<gcc>"
"(1)  in one of its standard modes (I<-std=xxx> or I<-ansi>)  or defines "
"various other feature test macros such as B<_POSIX_SOURCE>, "
"B<_XOPEN_SOURCE>, or B<_SVID_SOURCE>; see B<feature_test_macros>(7).)"
msgstr ""
"glibc 2 以降では、機能検査マクロ B<_BSD_SOURCE> が定義されていなければ、 "
"B<signal>()  は System V 方式となる。 (B<gcc>(1)  が標準指定モード (I<-"
"std=xxx> or I<-ansi>)  で起動された場合、もしくは B<_POSIX_SOURCE>, "
"B<_XOPEN_SOURCE>, B<_SVID_SOURCE> といった他の様々な機能検査マクロが定義され"
"た場合、 デフォルトの B<_BSD_SOURCE> の暗黙の定義は行われない。 "
"B<feature_test_macros>(7)  を参照のこと。)"

#. type: Plain text
#: build/C/man2/signal.2:260
msgid ""
"The B<signal>()  function in Linux libc4 and libc5 provide System V "
"semantics.  If one on a libc5 system includes I<E<lt>bsd/signal.hE<gt>> "
"instead of I<E<lt>signal.hE<gt>>, then B<signal>()  provides BSD semantics."
msgstr ""
"Linux の libc4 と libc5 の B<signal>()  関数は System V 方式である。 libc5 シ"
"ステムにおいて I<E<lt>signal.hE<gt>> のかわりに I<E<lt>bsd/signal.hE<gt>> を"
"インクルードすると、 B<signal>()  は B<__bsd_signal>()  に再定義され、 "
"B<signal>()  は BSD 方式となる。"

#. type: Plain text
#: build/C/man2/signal.2:279
msgid ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<killpg>(2), B<pause>(2), B<sigaction>"
"(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), "
"B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), B<signal>(7)"
msgstr ""
"B<kill>(1), B<alarm>(2), B<kill>(2), B<killpg>(2), B<pause>(2), B<sigaction>"
"(2), B<signalfd>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2), "
"B<bsd_signal>(3), B<raise>(3), B<siginterrupt>(3), B<sigqueue>(3), "
"B<sigsetops>(3), B<sigvec>(3), B<sysv_signal>(3), B<signal>(7)"

#. type: TH
#: build/C/man7/signal.7:44
#, no-wrap
msgid "2012-05-01"
msgstr "2012-05-01"

#. type: Plain text
#: build/C/man7/signal.7:47
msgid "signal - overview of signals"
msgstr "signal - シグナルの概要"

#. type: Plain text
#: build/C/man7/signal.7:50
msgid ""
"Linux supports both POSIX reliable signals (hereinafter \"standard signals"
"\") and POSIX real-time signals."
msgstr ""
"Linux は POSIX 信頼シグナル (reliable signal; 以後 \"標準シグナル\"と表記)  "
"と POSIX リアルタイムシグナルの両方に対応している。"

#. type: SS
#: build/C/man7/signal.7:50
#, no-wrap
msgid "Signal Dispositions"
msgstr "シグナル処理方法"

#. type: Plain text
#: build/C/man7/signal.7:55
msgid ""
"Each signal has a current I<disposition>, which determines how the process "
"behaves when it is delivered the signal."
msgstr ""
"シグナルはそれぞれ現在の「処理方法 (disposition)」を保持しており、 この処理方"
"法によりシグナルが配送された際にプロセスが どのような振舞いをするかが決まる。"

#. type: Plain text
#: build/C/man7/signal.7:58
msgid ""
"The entries in the \"Action\" column of the tables below specify the default "
"disposition for each signal, as follows:"
msgstr ""
"後述の表の \"動作\" の欄のエントリは各シグナルのデフォルトの 処理方法を示して"
"おり、以下のような意味を持つ。"

#. type: IP
#: build/C/man7/signal.7:58
#, no-wrap
msgid "Term"
msgstr "Term"

#. type: Plain text
#: build/C/man7/signal.7:60
msgid "Default action is to terminate the process."
msgstr "デフォルトの動作はプロセス終了。"

#. type: IP
#: build/C/man7/signal.7:60
#, no-wrap
msgid "Ign"
msgstr "Ign"

#. type: Plain text
#: build/C/man7/signal.7:62
msgid "Default action is to ignore the signal."
msgstr "デフォルトの動作はこのシグナルの無視。"

#. type: IP
#: build/C/man7/signal.7:62
#, no-wrap
msgid "Core"
msgstr "Core"

#. type: Plain text
#: build/C/man7/signal.7:65
msgid ""
"Default action is to terminate the process and dump core (see B<core>(5))."
msgstr "デフォルトの動作はプロセス終了とコアダンプ出力 (B<core>(5)  参照)。"

#. type: IP
#: build/C/man7/signal.7:65
#, no-wrap
msgid "Stop"
msgstr "Stop"

#. type: Plain text
#: build/C/man7/signal.7:67
msgid "Default action is to stop the process."
msgstr "デフォルトの動作はプロセスの一時停止。"

#. type: IP
#: build/C/man7/signal.7:67
#, no-wrap
msgid "Cont"
msgstr "Cont"

#. type: Plain text
#: build/C/man7/signal.7:69
msgid "Default action is to continue the process if it is currently stopped."
msgstr "デフォルトの動作は、プロセスが停止中の場合にその実行の再開。"

#. type: Plain text
#: build/C/man7/signal.7:91
msgid ""
"A process can change the disposition of a signal using B<sigaction>(2)  or "
"B<signal>(2).  (The latter is less portable when establishing a signal "
"handler; see B<signal>(2)  for details.)  Using these system calls, a "
"process can elect one of the following behaviors to occur on delivery of the "
"signal: perform the default action; ignore the signal; or catch the signal "
"with a I<signal handler>, a programmer-defined function that is "
"automatically invoked when the signal is delivered.  (By default, the signal "
"handler is invoked on the normal process stack.  It is possible to arrange "
"that the signal handler uses an alternate stack; see B<sigaltstack>(2)  for "
"a discussion of how to do this and when it might be useful.)"
msgstr ""
"プロセスは、 B<sigaction>(2)  や B<signal>(2)  を使って、シグナルの処理方法を"
"変更することができる (B<signal>(2)  の方がシグナルハンドラを設定する際の移植"
"性が低い; 詳細は B<signal>(2)  を参照)。 シグナルの配送時に起こる動作として "
"プロセスが選択できるのは、次のいずれか一つである。 デフォルトの動作を実行す"
"る、シグナルを無視する、 I<シグナルハンドラ (signal handler)> でシグナルを捕"
"捉する。シグナルハンドラとは、シグナル配送時に 自動的に起動されるプログラマ定"
"義の関数である。 (デフォルトでは、シグナルハンドラは通常のプロセスのスタック"
"上で起動される。 シグナルハンドラが代替スタック (alternate stack) を使用する"
"ように設定する こともできる。代替スタックを使用するように設定する方法と、どの"
"ような際に 代替スタックが役に立つかについての議論については B<sigaltstack>"
"(2)  を参照のこと。"

#. type: Plain text
#: build/C/man7/signal.7:95
msgid ""
"The signal disposition is a per-process attribute: in a multithreaded "
"application, the disposition of a particular signal is the same for all "
"threads."
msgstr ""
"シグナルの処理方法はプロセス単位の属性である。 マルチスレッドのアプリケーショ"
"ンでは、あるシグナルの処理方法は 全てのスレッドで同じである。"

#. type: SS
#: build/C/man7/signal.7:103
#, no-wrap
msgid "Sending a Signal"
msgstr "シグナルの送信"

#. type: Plain text
#: build/C/man7/signal.7:106
msgid ""
"The following system calls and library functions allow the caller to send a "
"signal:"
msgstr ""
"以下のシステムコールとライブラリ関数を使って、 呼び出し者はシグナルを送信する"
"ことができる。"

#. type: TP
#: build/C/man7/signal.7:106
#, no-wrap
msgid "B<raise>(3)"
msgstr "B<raise>(3)"

#. type: Plain text
#: build/C/man7/signal.7:109
msgid "Sends a signal to the calling thread."
msgstr "呼び出したスレッドにシグナルを送る。"

#. type: Plain text
#: build/C/man7/signal.7:114
msgid ""
"Sends a signal to a specified process, to all members of a specified process "
"group, or to all processes on the system."
msgstr ""
"指定されたプロセスや、指定されたプロセスグループの全メンバー、 システムの全プ"
"ロセスにシグナルを送る。"

#. type: TP
#: build/C/man7/signal.7:114
#, no-wrap
msgid "B<killpg>(2)"
msgstr "B<killpg>(2)"

#. type: Plain text
#: build/C/man7/signal.7:117
msgid "Sends a signal to all of the members of a specified process group."
msgstr "指定されたプロセスグループの全メンバーにシグナルを送る。"

#. type: TP
#: build/C/man7/signal.7:117
#, no-wrap
msgid "B<pthread_kill>(3)"
msgstr "B<pthread_kill>(3)"

#. type: Plain text
#: build/C/man7/signal.7:121
msgid ""
"Sends a signal to a specified POSIX thread in the same process as the caller."
msgstr ""
"呼び出し者と同じプロセス内の指定された POSIX スレッドにシグナルを送る。"

#. type: TP
#: build/C/man7/signal.7:121
#, no-wrap
msgid "B<tgkill>(2)"
msgstr "B<tgkill>(2)"

#. type: Plain text
#: build/C/man7/signal.7:126
msgid ""
"Sends a signal to a specified thread within a specific process.  (This is "
"the system call used to implement B<pthread_kill>(3).)"
msgstr ""
"指定されたプロセス内の指定されたスレッドにシグナルを送る (このシステムコール"
"を使って B<pthread_kill>(3)  は実装されている)。"

#. type: Plain text
#: build/C/man7/signal.7:129
msgid "Sends a real-time signal with accompanying data to a specified process."
msgstr "指定されたプロセスに付属データとともにリアルタイムシグナルを送る。"

#. type: SS
#: build/C/man7/signal.7:129
#, no-wrap
msgid "Waiting for a Signal to be Caught"
msgstr "シグナルが捕捉されるのを待つ"

#. type: Plain text
#: build/C/man7/signal.7:133
msgid ""
"The following system calls suspend execution of the calling process or "
"thread until a signal is caught (or an unhandled signal terminates the "
"process):"
msgstr ""
"以下のシステムコールを使って、シグナルが捕捉されるまで 呼び出したプロセスやス"
"レッドの実行を中断 (suspend) することができる (ハンドラが設定されていないシグ"
"ナルによりそのプロセスが終了した 場合にも実行の停止は終了する)。"

#. type: TP
#: build/C/man7/signal.7:133
#, no-wrap
msgid "B<pause>(2)"
msgstr "B<pause>(2)"

#. type: Plain text
#: build/C/man7/signal.7:136
msgid "Suspends execution until any signal is caught."
msgstr "何かシグナルが捕捉されるまで実行を停止する。"

#. type: TP
#: build/C/man7/signal.7:136
#, no-wrap
msgid "B<sigsuspend>(2)"
msgstr "B<sigsuspend>(2)"

#. type: Plain text
#: build/C/man7/signal.7:140
msgid ""
"Temporarily changes the signal mask (see below) and suspends execution until "
"one of the unmasked signals is caught."
msgstr ""
"一時的にシグナルマスク (下記参照) を変更し、 マスクされていないシグナルのいず"
"れかが捕捉されるまで 実行を中断する。"

#. type: SS
#: build/C/man7/signal.7:140
#, no-wrap
msgid "Synchronously Accepting a Signal"
msgstr "シグナルの同期受信"

#. type: Plain text
#: build/C/man7/signal.7:147
msgid ""
"Rather than asynchronously catching a signal via a signal handler, it is "
"possible to synchronously accept the signal, that is, to block execution "
"until the signal is delivered, at which point the kernel returns information "
"about the signal to the caller.  There are two general ways to do this:"
msgstr ""
"シグナルハンドラ経由でシグナルを非同期 (asynchronously) で捕捉する以外にも、 "
"シグナルを同期 (synchronously) して受け付けることもできる。 同期して受け付け"
"るとは、シグナルが配送されるまで実行を停止 (block)  するということである。シ"
"グナルを受け付けた際に、カーネルは そのシグナルに関する情報を呼び出し者に返"
"す。 これを行う一般的な方法が二つある。"

#. type: Plain text
#: build/C/man7/signal.7:155
msgid ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), and B<sigwait>(3)  suspend execution "
"until one of the signals in a specified set is delivered.  Each of these "
"calls returns information about the delivered signal."
msgstr ""
"B<sigwaitinfo>(2), B<sigtimedwait>(2), B<sigwait>(3)  は、指定されたシグナル"
"集合のシグナルの一つが配送されるまで実行を中断する。 どのシステムコールや関数"
"でも、配送されたシグナルに関する情報が返される。"

#. type: Plain text
#: build/C/man7/signal.7:168
msgid ""
"B<signalfd>(2)  returns a file descriptor that can be used to read "
"information about signals that are delivered to the caller.  Each B<read>"
"(2)  from this file descriptor blocks until one of the signals in the set "
"specified in the B<signalfd>(2)  call is delivered to the caller.  The "
"buffer returned by B<read>(2)  contains a structure describing the signal."
msgstr ""
"B<signalfd>(2)  が返すファイルディスクリプタを使うと、呼び出し元に配送された "
"シグナルに関する情報を読み出すことができる。 このファイルディスクリプタから"
"の B<read>(2)  は、 B<signalfd>(2)  の呼び出し時に指定されたシグナル集合のシ"
"グナルの一つが呼び出し元に 配送されるまで停止 (block) する。 B<read>(2)  が返"
"すバッファにはシグナルに関する情報を格納した構造体が入っている。"

#. type: SS
#: build/C/man7/signal.7:168
#, no-wrap
msgid "Signal Mask and Pending Signals"
msgstr "シグナルマスクと処理待ちシグナル"

#. type: Plain text
#: build/C/man7/signal.7:175
msgid ""
"A signal may be I<blocked>, which means that it will not be delivered until "
"it is later unblocked.  Between the time when it is generated and when it is "
"delivered a signal is said to be I<pending>."
msgstr ""
"シグナルは I<ブロック (block)> されることがある。ブロックされると、そのシグナ"
"ルは その後ブロックを解除されるまで配送されなくなる。 シグナルが生成されてか"
"ら配送されるまでの間、そのシグナルは I<処理待ち (pending)> であると呼ばれる。"

#. type: Plain text
#: build/C/man7/signal.7:184
msgid ""
"Each thread in a process has an independent I<signal mask>, which indicates "
"the set of signals that the thread is currently blocking.  A thread can "
"manipulate its signal mask using B<pthread_sigmask>(3).  In a traditional "
"single-threaded application, B<sigprocmask>(2)  can be used to manipulate "
"the signal mask."
msgstr ""
"プロセス内の各スレッドは、それぞれ独立な I<シグナルマスク (signal mask)> を持"
"つ。シグナルマスクはそのスレッドが現在ブロックしている シグナル集合を示すもの"
"である。 スレッドは、 B<pthread_sigmask>(3)  を使って自分のシグナルマスクを操"
"作できる。 伝統的なシングルスレッドのアプリケーションでは、 B<sigprocmask>"
"(2)  を使って、シグナルマスクを操作できる。"

#. type: Plain text
#: build/C/man7/signal.7:190 build/C/man2/sigprocmask.2:121
msgid ""
"A child created via B<fork>(2)  inherits a copy of its parent's signal mask; "
"the signal mask is preserved across B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で作成された子プロセスは親プロセスのシグナルマスクのコピーを"
"継承する。 B<execve>(2)  の前後でシグナルマスクは保持される。"

#. type: Plain text
#: build/C/man7/signal.7:207
msgid ""
"A signal may be generated (and thus pending)  for a process as a whole (e."
"g., when sent using B<kill>(2))  or for a specific thread (e.g., certain "
"signals, such as B<SIGSEGV> and B<SIGFPE>, generated as a consequence of "
"executing a specific machine-language instruction are thread directed, as "
"are signals targeted at a specific thread using B<pthread_kill>(3)).  A "
"process-directed signal may be delivered to any one of the threads that does "
"not currently have the signal blocked.  If more than one of the threads has "
"the signal unblocked, then the kernel chooses an arbitrary thread to which "
"to deliver the signal."
msgstr ""
"生成されるシグナル (したがって処理待ちとなるシグナル) には、 プロセス全体宛て"
"と特定のスレッド宛てがある。 例えば、プロセス全体宛てのシグナルは B<kill>"
"(2)  を使って送信される。 特定のマシン語の命令の実行の結果として生成される、 "
"B<SIGSEGV> や B<SIGFPE> などのシグナルは、スレッド宛てとなる。 また、 "
"B<pthread_kill>(3)  を使って特定のスレッド宛てに生成されたシグナルも スレッド"
"宛てとなる。 プロセス宛てのシグナルは、そのシグナルをブロックしていないスレッ"
"ドのうち いずれかの一つに配送することができる。そのシグナルをブロックしていな"
"い スレッドが複数ある場合、シグナルを配送するスレッドはカーネルが 無作為に選"
"択する。"

#. type: Plain text
#: build/C/man7/signal.7:214
msgid ""
"A thread can obtain the set of signals that it currently has pending using "
"B<sigpending>(2).  This set will consist of the union of the set of pending "
"process-directed signals and the set of signals pending for the calling "
"thread."
msgstr ""
"スレッドは、 B<sigpending>(2)  を使って、現在処理待ちのシグナル集合を取得する"
"ことができる。 この集合は、プロセス宛ての処理待ちシグナルと 呼び出したスレッ"
"ド宛てのシグナルの両方から構成される。"

#. type: Plain text
#: build/C/man7/signal.7:220 build/C/man2/sigpending.2:76
msgid ""
"A child created via B<fork>(2)  initially has an empty pending signal set; "
"the pending signal set is preserved across an B<execve>(2)."
msgstr ""
"B<fork>(2)  経由で作成された子プロセスでは、処理待ちのシグナル集合は空の集合"
"で初期化される。 B<execve>(2)  の前後で、処理待ちのシグナル集合は保持される。"

#. type: SS
#: build/C/man7/signal.7:220
#, no-wrap
msgid "Standard Signals"
msgstr "標準シグナル"

#. type: Plain text
#: build/C/man7/signal.7:232
msgid ""
"Linux supports the standard signals listed below.  Several signal numbers "
"are architecture-dependent, as indicated in the \"Value\" column.  (Where "
"three values are given, the first one is usually valid for alpha and sparc, "
"the middle one for x86, arm, and most other architectures, and the last one "
"for mips.  (Values for parisc are I<not> shown; see the kernel source for "
"signal numbering on that architecture.)  A - denotes that a signal is absent "
"on the corresponding architecture.)"
msgstr ""
"Linux は以下に示す標準シグナルに対応している。シグナル番号の一部はアー\n"
"キテクチャ依存であり、\"値\" 欄に示す通りである。 (3つの値が書かれている\n"
"ものは、 1つ目が alpha と sparc で通常有効な値、 真ん中が x86, arm や\n"
"他のほとんどのアーキテクチャでの有効な値、最後が mips での値である。\n"
"(parisc での値は記載されてI<いない>。 parisc でのシグナル番号は\n"
"カーネルソースを参照してほしい)。 - はそのアーキテ\n"
"クチャにおいて対応するシグナルがないことを示す。)"

#. type: Plain text
#: build/C/man7/signal.7:234
msgid "First the signals described in the original POSIX.1-1990 standard."
msgstr "最初に、POSIX.1-1990 に定義されているシグナルを示す。"

#. type: tbl table
#: build/C/man7/signal.7:238 build/C/man7/signal.7:274
#: build/C/man7/signal.7:303
#, no-wrap
msgid "Signal\tValue\tAction\tComment\n"
msgstr "シグナル\t値\t動作\tコメント\n"

#. type: tbl table
#: build/C/man7/signal.7:239
#, no-wrap
msgid "SIGHUP\t\\01\tTerm\tHangup detected on controlling terminal\n"
msgstr "SIGHUP\t\\01\tTerm\t制御端末(controlling terminal)のハングアップ検出、\n"

#. type: tbl table
#: build/C/man7/signal.7:240
#, no-wrap
msgid "\t\t\tor death of controlling process\n"
msgstr "\t\t\tまたは制御しているプロセスの死\n"

#. type: tbl table
#: build/C/man7/signal.7:241
#, no-wrap
msgid "SIGINT\t\\02\tTerm\tInterrupt from keyboard\n"
msgstr "SIGINT\t\\02\tTerm\tキーボードからの割り込み (Interrupt)\n"

#. type: tbl table
#: build/C/man7/signal.7:242
#, no-wrap
msgid "SIGQUIT\t\\03\tCore\tQuit from keyboard\n"
msgstr "SIGQUIT\t\\03\tCore\tキーボードによる中止 (Quit)\n"

#. type: tbl table
#: build/C/man7/signal.7:243
#, no-wrap
msgid "SIGILL\t\\04\tCore\tIllegal Instruction\n"
msgstr "SIGILL\t\\04\tCore\t不正な命令\n"

#. type: tbl table
#: build/C/man7/signal.7:244
#, no-wrap
msgid "SIGABRT\t\\06\tCore\tAbort signal from B<abort>(3)\n"
msgstr "SIGABRT\t\\06\tCore\tB<abort>(3) からの中断 (Abort) シグナル\n"

#. type: tbl table
#: build/C/man7/signal.7:245
#, no-wrap
msgid "SIGFPE\t\\08\tCore\tFloating point exception\n"
msgstr "SIGFPE\t\\08\tCore\t浮動小数点例外\n"

#. type: tbl table
#: build/C/man7/signal.7:246
#, no-wrap
msgid "SIGKILL\t\\09\tTerm\tKill signal\n"
msgstr "SIGKILL\t\\09\tTerm\tKill シグナル\n"

#. type: tbl table
#: build/C/man7/signal.7:247
#, no-wrap
msgid "SIGSEGV\t11\tCore\tInvalid memory reference\n"
msgstr "SIGSEGV\t11\tCore\t不正なメモリ参照\n"

#. type: tbl table
#: build/C/man7/signal.7:248
#, no-wrap
msgid "SIGPIPE\t13\tTerm\tBroken pipe: write to pipe with no\n"
msgstr "SIGPIPE\t13\tTerm\tパイプ破壊:\n"

#. type: tbl table
#: build/C/man7/signal.7:249
#, no-wrap
msgid "\t\t\treaders\n"
msgstr "\t\t\t読み手の無いパイプへの書き出し\n"

#. type: tbl table
#: build/C/man7/signal.7:250
#, no-wrap
msgid "SIGALRM\t14\tTerm\tTimer signal from B<alarm>(2)\n"
msgstr "SIGALRM\t14\tTerm\tB<alarm>(2) からのタイマーシグナル\n"

#. type: tbl table
#: build/C/man7/signal.7:251
#, no-wrap
msgid "SIGTERM\t15\tTerm\tTermination signal\n"
msgstr "SIGTERM\t15\tTerm\t終了 (termination) シグナル\n"

#. type: tbl table
#: build/C/man7/signal.7:252
#, no-wrap
msgid "SIGUSR1\t30,10,16\tTerm\tUser-defined signal 1\n"
msgstr "SIGUSR1\t30,10,16\tTerm\tユーザ定義シグナル 1\n"

#. type: tbl table
#: build/C/man7/signal.7:253
#, no-wrap
msgid "SIGUSR2\t31,12,17\tTerm\tUser-defined signal 2\n"
msgstr "SIGUSR2\t31,12,17\tTerm\tユーザ定義シグナル 2\n"

#. type: tbl table
#: build/C/man7/signal.7:254
#, no-wrap
msgid "SIGCHLD\t20,17,18\tIgn\tChild stopped or terminated\n"
msgstr "SIGCHLD\t20,17,18\tIgn\t子プロセスの一時停止 (stop) または終了\n"

#. type: tbl table
#: build/C/man7/signal.7:255
#, no-wrap
msgid "SIGCONT\t19,18,25\tCont\tContinue if stopped\n"
msgstr "SIGCONT\t19,18,25\tCont\t一時停止 (stop) からの再開\n"

#. type: tbl table
#: build/C/man7/signal.7:256
#, no-wrap
msgid "SIGSTOP\t17,19,23\tStop\tStop process\n"
msgstr "SIGSTOP\t17,19,23\tStop\tプロセスの一時停止 (stop)\n"

#. type: tbl table
#: build/C/man7/signal.7:257
#, no-wrap
msgid "SIGTSTP\t18,20,24\tStop\tStop typed at tty\n"
msgstr "SIGTSTP\t18,20,24\tStop\t端末 (tty) より入力された一時停止 (stop)\n"

#. type: tbl table
#: build/C/man7/signal.7:258
#, no-wrap
msgid "SIGTTIN\t21,21,26\tStop\ttty input for background process\n"
msgstr "SIGTTIN\t21,21,26\tStop\tバックグランドプロセスの tty 入力\n"

#. type: tbl table
#: build/C/man7/signal.7:259
#, no-wrap
msgid "SIGTTOU\t22,22,27\tStop\ttty output for background process\n"
msgstr "SIGTTOU\t22,22,27\tStop\tバックグランドプロセスの tty 出力\n"

#. type: Plain text
#: build/C/man7/signal.7:267
msgid ""
"The signals B<SIGKILL> and B<SIGSTOP> cannot be caught, blocked, or ignored."
msgstr "シグナル B<SIGKILL> と B<SIGSTOP> はキャッチ、ブロック、無視できない。"

#. type: Plain text
#: build/C/man7/signal.7:270
msgid ""
"Next the signals not in the POSIX.1-1990 standard but described in SUSv2 and "
"POSIX.1-2001."
msgstr ""
"次に、 POSIX.1-1990 標準にはないが、 SUSv2 と POSIX.1-2001 に記述されているシ"
"グナルを示す。"

#. type: tbl table
#: build/C/man7/signal.7:275
#, no-wrap
msgid "SIGBUS\t10,7,10\tCore\tBus error (bad memory access)\n"
msgstr "SIGBUS\t10,7,10\tCore\tバスエラー (不正なメモリアクセス)\n"

#. type: tbl table
#: build/C/man7/signal.7:276
#, no-wrap
msgid "SIGPOLL\t\tTerm\tPollable event (Sys V).\n"
msgstr "SIGPOLL\t\tTerm\tポーリング可能なイベント (Sys V)。\n"

#. type: tbl table
#: build/C/man7/signal.7:277
#, no-wrap
msgid "\t\t\tSynonym for B<SIGIO>\n"
msgstr "\t\t\tB<SIGIO> と同義\n"

#. type: tbl table
#: build/C/man7/signal.7:278
#, no-wrap
msgid "SIGPROF\t27,27,29\tTerm\tProfiling timer expired\n"
msgstr "SIGPROF\t27,27,29\tTerm\tprofiling タイマの時間切れ\n"

#. type: tbl table
#: build/C/man7/signal.7:279
#, no-wrap
msgid "SIGSYS\t12,31,12\tCore\tBad argument to routine (SVr4)\n"
msgstr "SIGSYS\t12,31,12\tCore\tルーチンへの引き数が不正 (SVr4)\n"

#. type: tbl table
#: build/C/man7/signal.7:280
#, no-wrap
msgid "SIGTRAP\t5\tCore\tTrace/breakpoint trap\n"
msgstr "SIGTRAP\t5\tCore\tトレース/ブレークポイント トラップ\n"

#. type: tbl table
#: build/C/man7/signal.7:281
#, no-wrap
msgid "SIGURG\t16,23,21\tIgn\tUrgent condition on socket (4.2BSD)\n"
msgstr "SIGURG\t16,23,21\tIgn\tソケットの緊急事態 (urgent condition) (4.2BSD)\n"

#. type: tbl table
#: build/C/man7/signal.7:282
#, no-wrap
msgid "SIGVTALRM\t26,26,28\tTerm\tVirtual alarm clock (4.2BSD)\n"
msgstr "SIGVTALRM\t26,26,28\tTerm\t仮想アラームクロック (4.2BSD)\n"

#. type: tbl table
#: build/C/man7/signal.7:283
#, no-wrap
msgid "SIGXCPU\t24,24,30\tCore\tCPU time limit exceeded (4.2BSD)\n"
msgstr "SIGXCPU\t24,24,30\tCore\tCPU時間制限超過 (4.2BSD)\n"

#. type: tbl table
#: build/C/man7/signal.7:284
#, no-wrap
msgid "SIGXFSZ\t25,25,31\tCore\tFile size limit exceeded (4.2BSD)\n"
msgstr "SIGXFSZ\t25,25,31\tCore\tファイルサイズ制限の超過 (4.2BSD)\n"

#. type: Plain text
#: build/C/man7/signal.7:297
msgid ""
"Up to and including Linux 2.2, the default behavior for B<SIGSYS>, "
"B<SIGXCPU>, B<SIGXFSZ>, and (on architectures other than SPARC and MIPS)  "
"B<SIGBUS> was to terminate the process (without a core dump).  (On some "
"other UNIX systems the default action for B<SIGXCPU> and B<SIGXFSZ> is to "
"terminate the process without a core dump.)  Linux 2.4 conforms to the "
"POSIX.1-2001 requirements for these signals, terminating the process with a "
"core dump."
msgstr ""
"Linux 2.2 以前では、 B<SIGSYS>, B<SIGXCPU>, B<SIGXFSZ> および SPARC と MIPS "
"以外のアーキテクチャでの B<SIGBUS> のデフォルトの振る舞いは (コアダンプ出力な"
"しの) プロセス終了であった。 (他の UNIX システムにも B<SIGXCPU> と "
"B<SIGXFSZ> のデフォルトの動作がコアダンプなしのプロセス終了のものがある。)  "
"Linux 2.4 では、POSIX.1-2001 での要求仕様に準拠して、 これらのシグナルで、プ"
"ロセスを終了させ、コアダンプを出力する ようになっている。"

#. type: Plain text
#: build/C/man7/signal.7:299
msgid "Next various other signals."
msgstr "次にその他の各種シグナルを示す。"

#. type: tbl table
#: build/C/man7/signal.7:304
#, no-wrap
msgid "SIGIOT\t6\tCore\tIOT trap. A synonym for B<SIGABRT>\n"
msgstr "SIGIOT\t6\tCore\tIOT トラップ。B<SIGABRT> と同義\n"

#. type: tbl table
#: build/C/man7/signal.7:305
#, no-wrap
msgid "SIGEMT\t7,-,7\tTerm\n"
msgstr "SIGEMT\t7,-,7\tTerm\n"

#. type: tbl table
#: build/C/man7/signal.7:306
#, no-wrap
msgid "SIGSTKFLT\t-,16,-\tTerm\tStack fault on coprocessor (unused)\n"
msgstr "SIGSTKFLT\t-,16,-\tA\t数値演算プロセッサにおけるスタックフォルト (未使用)\n"

#. type: tbl table
#: build/C/man7/signal.7:307
#, no-wrap
msgid "SIGIO\t23,29,22\tTerm\tI/O now possible (4.2BSD)\n"
msgstr "SIGIO\t23,29,22\tTerm\t入出力が可能になった (4.2BSD)\n"

#. type: tbl table
#: build/C/man7/signal.7:308
#, no-wrap
msgid "SIGCLD\t-,-,18\tIgn\tA synonym for B<SIGCHLD>\n"
msgstr "SIGCLD\t-,-,18\tIgn\tB<SIGCHLD> と同義\n"

#. type: tbl table
#: build/C/man7/signal.7:309
#, no-wrap
msgid "SIGPWR\t29,30,19\tTerm\tPower failure (System V)\n"
msgstr "SIGPWR\t29,30,19\tTerm\t電源喪失 (Power failure) (System V)\n"

#. type: tbl table
#: build/C/man7/signal.7:310
#, no-wrap
msgid "SIGINFO\t29,-,-\t\tA synonym for B<SIGPWR>\n"
msgstr "SIGINFO\t29,-,-\t \tB<SIGPWR> と同義\n"

#. type: tbl table
#: build/C/man7/signal.7:311
#, no-wrap
msgid "SIGLOST\t-,-,-\tTerm\tFile lock lost (unused)\n"
msgstr "SIGLOST\t-,-,-\tTerm\tファイルロックが失われた (未使用)\n"

#. type: tbl table
#: build/C/man7/signal.7:312
#, no-wrap
msgid "SIGWINCH\t28,28,20\tIgn\tWindow resize signal (4.3BSD, Sun)\n"
msgstr "SIGWINCH\t28,28,20\tIgn\tウィンドウ リサイズ シグナル (4.3BSD, Sun)\n"

#. type: tbl table
#: build/C/man7/signal.7:313
#, no-wrap
msgid "SIGUNUSED\t-,31,-\tCore\tSynonymous with B<SIGSYS>\n"
msgstr "SIGUNUSED\t-,31,-\tCore\tB<SIGSYS> と同義\n"

#. type: Plain text
#: build/C/man7/signal.7:323
msgid ""
"(Signal 29 is B<SIGINFO> / B<SIGPWR> on an alpha but B<SIGLOST> on a sparc.)"
msgstr ""
"(シグナル 29 は alpha では B<SIGINFO> / B<SIGPWR> だが、sparc では "
"B<SIGLOST> である。)"

#. type: Plain text
#: build/C/man7/signal.7:329
msgid ""
"B<SIGEMT> is not specified in POSIX.1-2001, but nevertheless appears on most "
"other UNIX systems, where its default action is typically to terminate the "
"process with a core dump."
msgstr ""
"B<SIGEMT> は POSIX.1-2001 に規定されていないが、 その他の多くの UNIX システム"
"に存在する。 デフォルトの動作は多くの場合、コアダンプ出力を伴うプロセスの終了"
"である。"

#. type: Plain text
#: build/C/man7/signal.7:333
msgid ""
"B<SIGPWR> (which is not specified in POSIX.1-2001) is typically ignored by "
"default on those other UNIX systems where it appears."
msgstr ""
"B<SIGPWR> は (POSIX.1-2001 に規定されていないが) このシグナルが存在する 他の "
"UNIX システムでは多くの場合、デフォルト動作は無視である。"

#. type: Plain text
#: build/C/man7/signal.7:337
msgid ""
"B<SIGIO> (which is not specified in POSIX.1-2001) is ignored by default on "
"several other UNIX systems."
msgstr ""
"B<SIGIO> は (POSIX.1-2001 に規定されていないが) いくつかの他の UNIX システム"
"では デフォルト動作は無視である。"

#.  parisc is the only exception: SIGSYS is 12, SIGUNUSED is 31
#. type: Plain text
#: build/C/man7/signal.7:344
msgid ""
"Where defined, B<SIGUNUSED> is synonymous with B<SIGSYS> on most "
"architectures."
msgstr ""
"B<SIGUNUSED> が定義されている場合には、ほとんどのアーキテクチャで B<SIGSYS> "
"の同義語となっている。"

#. type: SS
#: build/C/man7/signal.7:344
#, no-wrap
msgid "Real-time Signals"
msgstr "リアルタイムシグナル"

#. type: Plain text
#: build/C/man7/signal.7:354
msgid ""
"Linux supports real-time signals as originally defined in the POSIX.1b real-"
"time extensions (and now included in POSIX.1-2001).  The range of supported "
"real-time signals is defined by the macros B<SIGRTMIN> and B<SIGRTMAX>.  "
"POSIX.1-2001 requires that an implementation support at least "
"B<_POSIX_RTSIG_MAX> (8) real-time signals."
msgstr ""
"Linux はリアルタイムシグナルをサポートしている。 リアルタイムシグナルは元々 "
"POSIX.1b のリアルタイム拡張で定義されて いるものであり、現在では "
"POSIX.1-2001 に含まれている。 対応しているリアルタイムシグナルの範囲は、マク"
"ロ B<SIGRTMIN> と B<SIGRTMAX> で定義される。 POSIX.1-2001 では、少なくとも "
"B<_POSIX_RTSIG_MAX> (8) 個のリアルタイムシグナルに対応した実装が要求されてい"
"る。"

#. type: Plain text
#: build/C/man7/signal.7:376
msgid ""
"The Linux kernel supports a range of 32 different real-time signals, "
"numbered 33 to 64.  However, the glibc POSIX threads implementation "
"internally uses two (for NPTL) or three (for LinuxThreads) real-time signals "
"(see B<pthreads>(7)), and adjusts the value of B<SIGRTMIN> suitably (to 34 "
"or 35).  Because the range of available real-time signals varies according "
"to the glibc threading implementation (and this variation can occur at run "
"time according to the available kernel and glibc), and indeed the range of "
"real-time signals varies across UNIX systems, programs should I<never refer "
"to real-time signals using hard-coded numbers>, but instead should always "
"refer to real-time signals using the notation B<SIGRTMIN>+n, and include "
"suitable (run-time) checks that B<SIGRTMIN>+n does not exceed B<SIGRTMAX>."
msgstr ""
"Linux は、32 個の異なるリアルタイムシグナルに対応しており、 その番号は 33 か"
"ら 64 である。 しかしながら、glibc の POSIX スレッド実装は、 内部で 2個 "
"(NPTL の場合) か 3個 (LinuxThreads の場合) の リアルタイムシグナルを使用して"
"おり (B<pthreads>(7)  参照)、 B<SIGRTMIN> の値を適切に (34 か 35 に) 調整す"
"る。 利用可能なリアルタイムシグナルの範囲は glibc のスレッド実装により 異なる"
"し (使用するカーネルと glibc により実行時にも変化する)、 UNIX システムの種類"
"によっても異なる。したがって、 プログラムでは「ハードコーディングした数字を"
"使ってのリアルタイムシグナルの 参照は決してすべきではなく」、代わりに "
"B<SIGRTMIN>+n の形で参照すべきである。また、 B<SIGRTMIN>+n が B<SIGRTMAX> を"
"超えていないかのチェックを (実行時に) 適切に行うべきである。"

#. type: Plain text
#: build/C/man7/signal.7:380
msgid ""
"Unlike standard signals, real-time signals have no predefined meanings: the "
"entire set of real-time signals can be used for application-defined purposes."
msgstr ""
"標準シグナルと異なり、リアルタイムシグナルには 事前に定義された意味はない。 "
"リアルタイムシグナルの全部をアプリケーションで定義した用途に使える。"

#. type: Plain text
#: build/C/man7/signal.7:383
msgid ""
"The default action for an unhandled real-time signal is to terminate the "
"receiving process."
msgstr ""
"ハンドリングしないリアルタイムシグナルのデフォルトの動作は 受信したプロセスの"
"終了である。"

#. type: Plain text
#: build/C/man7/signal.7:385
msgid "Real-time signals are distinguished by the following:"
msgstr "リアルタイムシグナルは以下の特徴がある:"

#. type: Plain text
#: build/C/man7/signal.7:389
msgid ""
"Multiple instances of real-time signals can be queued.  By contrast, if "
"multiple instances of a standard signal are delivered while that signal is "
"currently blocked, then only one instance is queued."
msgstr ""
"リアルタイムシグナルは複数の実体をキューに入れることができる。 一方、標準シグ"
"ナルの場合、そのシグナルがブロックされている間に 同じシグナルの複数のインスタ"
"ンスが配送されても、 1 つだけがキューに入れられる。"

#. type: Plain text
#: build/C/man7/signal.7:409
msgid ""
"If the signal is sent using B<sigqueue>(3), an accompanying value (either an "
"integer or a pointer) can be sent with the signal.  If the receiving process "
"establishes a handler for this signal using the B<SA_SIGINFO> flag to "
"B<sigaction>(2)  then it can obtain this data via the I<si_value> field of "
"the I<siginfo_t> structure passed as the second argument to the handler.  "
"Furthermore, the I<si_pid> and I<si_uid> fields of this structure can be "
"used to obtain the PID and real user ID of the process sending the signal."
msgstr ""
"シグナルが B<sigqueue>(3)  を用いて送信された場合、 付属データ (整数かポイン"
"タ) をシグナルと共に送信できる。 受信側プロセスが B<sigaction>(2)  に "
"B<SA_SIGINFO> フラグを指定してシグナルハンドラを設定した場合、 このデータは "
"I<siginfo_t> 構造体の I<si_value> フィールド経由でハンドラの第 2 引き数として"
"渡され、 利用することができる。 さらに、この構造体の I<si_pid> と I<si_uid> "
"フィールドでシグナルを送信したプロセスの PID と実ユーザ ID を 得ることができ"
"る。"

#. type: Plain text
#: build/C/man7/signal.7:418
msgid ""
"Real-time signals are delivered in a guaranteed order.  Multiple real-time "
"signals of the same type are delivered in the order they were sent.  If "
"different real-time signals are sent to a process, they are delivered "
"starting with the lowest-numbered signal.  (I.e., low-numbered signals have "
"highest priority.)  By contrast, if multiple standard signals are pending "
"for a process, the order in which they are delivered is unspecified."
msgstr ""
"リアルタイムシグナルでは配送される順序が保証される。 同じタイプのリアルタイム"
"シグナルは送信された順番に到着する。 異なるリアルタイムシグナルが一つのプロセ"
"スに送信された場合、 番号の小さいシグナルから先に到着する。 (つまり小さい番号"
"のシグナルが高い優先順位を持つ。)  対照的に、一つのプロセスに対して複数の標準"
"シグナルが処理待ちとなった場合、 これらのシグナルが配送される順序は不定であ"
"る。"

#. type: Plain text
#: build/C/man7/signal.7:423
msgid ""
"If both standard and real-time signals are pending for a process, POSIX "
"leaves it unspecified which is delivered first.  Linux, like many other "
"implementations, gives priority to standard signals in this case."
msgstr ""
"一つのプロセスに対して標準シグナルとリアルタイムシグナルの両方が 処理待ちの場"
"合、POSIX はどちらが先に配送されるかを規定していない。 Linux では、他の多くの"
"実装と同様、このような場合には 標準シグナルが優先される。"

#. type: Plain text
#: build/C/man7/signal.7:446
msgid ""
"According to POSIX, an implementation should permit at least "
"B<_POSIX_SIGQUEUE_MAX> (32) real-time signals to be queued to a process.  "
"However, Linux does things differently.  In kernels up to and including "
"2.6.7, Linux imposes a system-wide limit on the number of queued real-time "
"signals for all processes.  This limit can be viewed and (with privilege) "
"changed via the I</proc/sys/kernel/rtsig-max> file.  A related file, I</proc/"
"sys/kernel/rtsig-nr>, can be used to find out how many real-time signals are "
"currently queued.  In Linux 2.6.8, these I</proc> interfaces were replaced "
"by the B<RLIMIT_SIGPENDING> resource limit, which specifies a per-user limit "
"for queued signals; see B<setrlimit>(2)  for further details."
msgstr ""
"POSIX によれば、1 プロセス毎に最低 B<_POSIX_SIGQUEUE_MAX> (32) 個のリアルタイ"
"ムシグナルをキューに入れられるべきとしている。 しかし、 Linux では違った実装"
"になっている。カーネル 2.6.7 までは (2.6.7 を含む)、全プロセスでキューに入っ"
"ているリアルタイムシグナル の数の合計についてシステム全体での制限がある。 こ"
"の制限は I</proc/sys/kernel/rtsig-max> ファイルで見ることができ、 (権限があれ"
"ば) 変更もできる。 関係するファイルとして、 I</proc/sys/kernel/rtsig-nr> を見"
"ることで、いくつのリアルタイムシグナルが現在キューに入っているかを 知ることが"
"できる。 Linux 2.6.8 で、これらの I</proc> 経由のインターフェースは、 "
"B<RLIMIT_SIGPENDING> リソース制限に置き換えられた。 これは、キューに入るシグ"
"ナル数に関してユーザ単位に 上限を指定するものである。 詳しくは B<setrlimit>"
"(2)  を参照。"

#. type: SS
#: build/C/man7/signal.7:446
#, no-wrap
msgid "Async-signal-safe functions"
msgstr "非同期シグナルで安全な関数 (async-signal-safe functions)"

#. type: Plain text
#: build/C/man7/signal.7:455
msgid ""
"A signal handler function must be very careful, since processing elsewhere "
"may be interrupted at some arbitrary point in the execution of the program.  "
"POSIX has the concept of \"safe function\".  If a signal interrupts the "
"execution of an unsafe function, and I<handler> calls an unsafe function, "
"then the behavior of the program is undefined."
msgstr ""
"シグナルハンドラ関数には非常に注意しなければならない。 他の場所の処理はプログ"
"ラム実行の任意の箇所で中断される可能性があるためである。 POSIX には「安全な関"
"数 (safe function)」という概念がある。 シグナルが安全でない関数の実行を中断"
"し、かつ I<handler> が安全でない関数を呼び出した場合、プログラムの挙動は未定"
"義である。"

#. type: Plain text
#: build/C/man7/signal.7:459
msgid ""
"POSIX.1-2004 (also known as POSIX.1-2001 Technical Corrigendum 2)  requires "
"an implementation to guarantee that the following functions can be safely "
"called inside a signal handler:"
msgstr ""
"POSIX.1-2004 (POSIX.1-2001 Technical Corrigendum (正誤表) 2 とも言う) では、 "
"シグナルハンドラ内での安全な呼び出しを保証することが必須の関数として 以下が規"
"定されている。"

#. type: Plain text
#: build/C/man7/signal.7:580
#, no-wrap
msgid ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"
msgstr ""
"_Exit()\n"
"_exit()\n"
"abort()\n"
"accept()\n"
"access()\n"
"aio_error()\n"
"aio_return()\n"
"aio_suspend()\n"
"alarm()\n"
"bind()\n"
"cfgetispeed()\n"
"cfgetospeed()\n"
"cfsetispeed()\n"
"cfsetospeed()\n"
"chdir()\n"
"chmod()\n"
"chown()\n"
"clock_gettime()\n"
"close()\n"
"connect()\n"
"creat()\n"
"dup()\n"
"dup2()\n"
"execle()\n"
"execve()\n"
"fchmod()\n"
"fchown()\n"
"fcntl()\n"
"fdatasync()\n"
"fork()\n"
"fpathconf()\n"
"fstat()\n"
"fsync()\n"
"ftruncate()\n"
"getegid()\n"
"geteuid()\n"
"getgid()\n"
"getgroups()\n"
"getpeername()\n"
"getpgrp()\n"
"getpid()\n"
"getppid()\n"
"getsockname()\n"
"getsockopt()\n"
"getuid()\n"
"kill()\n"
"link()\n"
"listen()\n"
"lseek()\n"
"lstat()\n"
"mkdir()\n"
"mkfifo()\n"
"open()\n"
"pathconf()\n"
"pause()\n"
"pipe()\n"
"poll()\n"
"posix_trace_event()\n"
"pselect()\n"
"raise()\n"
"read()\n"
"readlink()\n"
"recv()\n"
"recvfrom()\n"
"recvmsg()\n"
"rename()\n"
"rmdir()\n"
"select()\n"
"sem_post()\n"
"send()\n"
"sendmsg()\n"
"sendto()\n"
"setgid()\n"
"setpgid()\n"
"setsid()\n"
"setsockopt()\n"
"setuid()\n"
"shutdown()\n"
"sigaction()\n"
"sigaddset()\n"
"sigdelset()\n"
"sigemptyset()\n"
"sigfillset()\n"
"sigismember()\n"
"signal()\n"
"sigpause()\n"
"sigpending()\n"
"sigprocmask()\n"
"sigqueue()\n"
"sigset()\n"
"sigsuspend()\n"
"sleep()\n"
"sockatmark()\n"
"socket()\n"
"socketpair()\n"
"stat()\n"
"symlink()\n"
"sysconf()\n"
"tcdrain()\n"
"tcflow()\n"
"tcflush()\n"
"tcgetattr()\n"
"tcgetpgrp()\n"
"tcsendbreak()\n"
"tcsetattr()\n"
"tcsetpgrp()\n"
"time()\n"
"timer_getoverrun()\n"
"timer_gettime()\n"
"timer_settime()\n"
"times()\n"
"umask()\n"
"uname()\n"
"unlink()\n"
"utime()\n"
"wait()\n"
"waitpid()\n"
"write()\n"

#. type: Plain text
#: build/C/man7/signal.7:585
msgid ""
"POSIX.1-2008 removes fpathconf(), pathconf(), and sysconf()  from the above "
"list, and adds the following functions:"
msgstr ""
"POSIX.1-2008 では、上記のリストのうち fpathconf(), pathconf(), sysconf()  が"
"削除され、以下の関数が追加された。"

#. type: Plain text
#: build/C/man7/signal.7:608
#, no-wrap
msgid ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"
msgstr ""
"execl()\n"
"execv()\n"
"faccessat()\n"
"fchmodat()\n"
"fchownat()\n"
"fexecve()\n"
"fstatat()\n"
"futimens()\n"
"linkat()\n"
"mkdirat()\n"
"mkfifoat()\n"
"mknod()\n"
"mknodat()\n"
"openat()\n"
"readlinkat()\n"
"renameat()\n"
"symlinkat()\n"
"unlinkat()\n"
"utimensat()\n"
"utimes()\n"

#. type: SS
#: build/C/man7/signal.7:610
#, no-wrap
msgid "Interruption of System Calls and Library Functions by Signal Handlers"
msgstr "シグナルハンドラによるシステムコールやライブラリ関数への割り込み"

#. type: Plain text
#: build/C/man7/signal.7:613
msgid ""
"If a signal handler is invoked while a system call or library function call "
"is blocked, then either:"
msgstr ""
"システムコールやライブラリが停止 (block) している間にシグナルハンドラが 起動"
"されると、以下のどちらかとなる。"

#. type: Plain text
#: build/C/man7/signal.7:615
msgid ""
"the call is automatically restarted after the signal handler returns; or"
msgstr "シグナルが返った後、呼び出しは自動的に再スタートされる。"

#. type: Plain text
#: build/C/man7/signal.7:618
msgid "the call fails with the error B<EINTR>."
msgstr "呼び出しはエラー B<EINTR> で失敗する。"

#. type: Plain text
#: build/C/man7/signal.7:626
msgid ""
"Which of these two behaviors occurs depends on the interface and whether or "
"not the signal handler was established using the B<SA_RESTART> flag (see "
"B<sigaction>(2)).  The details vary across UNIX systems; below, the details "
"for Linux."
msgstr ""
"これらの二つの挙動のうちどちらが起こるかは、インターフェイスにより依存し、 シ"
"グナルハンドラが B<SA_RESTART> フラグ (B<sigaction>(2)  参照) を使って設定さ"
"れていたかにも依存する。 詳細は UNIX システムによって異なる。 Linux における"
"詳細を以下で説明する。"

#.  The following system calls use ERESTARTSYS,
#.  so that they are restartable
#. type: Plain text
#: build/C/man7/signal.7:635
msgid ""
"If a blocked call to one of the following interfaces is interrupted by a "
"signal handler, then the call will be automatically restarted after the "
"signal handler returns if the B<SA_RESTART> flag was used; otherwise the "
"call will fail with the error B<EINTR>:"
msgstr ""
"以下のインターフェイスのいずれかの呼び出しが停止している間に シグナルハンドラ"
"により割り込まれた場合、 B<SA_RESTART> フラグが使用されていれば、シグナルハン"
"ドラが返った後に その呼び出しは自動的に再スタートされることになる。 それ以外"
"の場合は、その呼び出しはエラー B<EINTR> で失敗することになる。"

#. type: Plain text
#: build/C/man7/signal.7:651
msgid ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), and B<ioctl>(2)  calls "
"on \"slow\" devices.  A \"slow\" device is one where the I/O call may block "
"for an indefinite time, for example, a terminal, pipe, or socket.  (A disk "
"is not a slow device according to this definition.)  If an I/O call on a "
"slow device has already transferred some data by the time it is interrupted "
"by a signal handler, then the call will return a success status (normally, "
"the number of bytes transferred)."
msgstr ""
"B<read>(2), B<readv>(2), B<write>(2), B<writev>(2), B<ioctl>(2)  の「遅い "
"(slow)」デバイスに対する呼び出し。 ここでいう「遅い」デバイスとは、I/O 呼び出"
"しが無期限に停止 (block) する 可能性のあるデバイスのことで、例としては端末、"
"パイプ、ソケットがある (この定義では、ディスクは遅いデバイスではない)。 遅い"
"デバイスに対する I/O 呼び出しが、 シグナルハンドラにより割り込まれた時点まで"
"に何らかのデータを すでに転送していれば、呼び出しは成功ステータス (通常は、転"
"送されたバイト数) を返すことだろう。"

#. type: Plain text
#: build/C/man7/signal.7:655
msgid ""
"B<open>(2), if it can block (e.g., when opening a FIFO; see B<fifo>(7))."
msgstr ""
"停止 (block) する可能性のある B<open>(2)  (例えば、FIFO のオープン時; B<fifo>"
"(7)  参照)。"

#. type: Plain text
#: build/C/man7/signal.7:662
msgid "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), and B<waitpid>(2)."
msgstr "B<wait>(2), B<wait3>(2), B<wait4>(2), B<waitid>(2), B<waitpid>(2)."

#.  If a timeout (setsockopt()) is in effect on the socket, then these
#.  system calls switch to using EINTR.  Consequently, they and are not
#.  automatically restarted, and they show the stop/cont behavior
#.  described below.  (Verified from 2.6.26 source, and by experiment; mtk)
#. type: Plain text
#: build/C/man7/signal.7:678
msgid ""
"Socket interfaces: B<accept>(2), B<connect>(2), B<recv>(2), B<recvfrom>(2), "
"B<recvmsg>(2), B<send>(2), B<sendto>(2), and B<sendmsg>(2), unless a timeout "
"has been set on the socket (see below)."
msgstr ""
"ソケットインターフェイス: B<accept>(2), B<connect>(2), B<recv>(2), "
"B<recvfrom>(2), B<recvmsg>(2), B<send>(2), B<sendto>(2), B<sendmsg>(2).  但"
"し、ソケットにタイムアウトが設定されていない場合 (下記参照)。"

#. type: Plain text
#: build/C/man7/signal.7:684
msgid "File locking interfaces: B<flock>(2)  and B<fcntl>(2)  B<F_SETLKW>."
msgstr ""
"ファイルロック用インターフェイス: B<flock>(2), B<fcntl>(2)  B<F_SETLKW>."

#. type: Plain text
#: build/C/man7/signal.7:691
msgid ""
"POSIX message queue interfaces: B<mq_receive>(3), B<mq_timedreceive>(3), "
"B<mq_send>(3), and B<mq_timedsend>(3)."
msgstr ""
"POSIX メッセージキューインターフェイス: B<mq_receive>(3), B<mq_timedreceive>"
"(3), B<mq_send>(3), B<mq_timedsend>(3)."

#. type: Plain text
#: build/C/man7/signal.7:696
msgid ""
"B<futex>(2)  B<FUTEX_WAIT> (since Linux 2.6.22; beforehand, always failed "
"with B<EINTR>)."
msgstr ""
"B<futex>(2)  B<FUTEX_WAIT> (Linux 2.6.22 以降; それ以前は常に B<EINTR> で失敗"
"していた)。"

#. type: Plain text
#: build/C/man7/signal.7:703
msgid ""
"POSIX semaphore interfaces: B<sem_wait>(3)  and B<sem_timedwait>(3)  (since "
"Linux 2.6.22; beforehand, always failed with B<EINTR>)."
msgstr ""
"POSIX セマフォインターフェイス: B<sem_wait>(3), B<sem_timedwait>(3)  (Linux "
"2.6.22 以降; それ以前は常に B<EINTR> で失敗していた)。"

#.  These are the system calls that give EINTR or ERESTARTNOHAND
#.  on interruption by a signal handler.
#. type: Plain text
#: build/C/man7/signal.7:714
msgid ""
"The following interfaces are never restarted after being interrupted by a "
"signal handler, regardless of the use of B<SA_RESTART>; they always fail "
"with the error B<EINTR> when interrupted by a signal handler:"
msgstr ""
"以下のインターフェイスは、 B<SA_RESTART> を使っているどうかに関わらず、シグナ"
"ルハンドラにより割り込まれた後、 再スタートすることは決してない。 これらは、"
"シグナルハンドラにより割り込まれると、常にエラー B<EINTR> で失敗する。"

#. type: Plain text
#: build/C/man7/signal.7:734 build/C/man7/signal.7:808
msgid ""
"Socket interfaces, when a timeout has been set on the socket using "
"B<setsockopt>(2): B<accept>(2), B<recv>(2), B<recvfrom>(2), and B<recvmsg>"
"(2), if a receive timeout (B<SO_RCVTIMEO>)  has been set; B<connect>(2), "
"B<send>(2), B<sendto>(2), and B<sendmsg>(2), if a send timeout "
"(B<SO_SNDTIMEO>)  has been set."
msgstr ""
"B<setsockopt>(2)  を使ってタイムアウトが設定されているソケットインターフェー"
"ス: B<accept>(2), B<recv>(2), B<recvfrom>(2), B<recvmsg>(2)  で受信タイムアウ"
"ト (B<SO_RCVTIMEO>)  が設定されている場合と、 B<connect>(2), B<send>(2), "
"B<sendto>(2), B<sendmsg>(2)  で送信タイムアウト (B<SO_SNDTIMEO>)  が設定され"
"ている場合。"

#. type: Plain text
#: build/C/man7/signal.7:741
msgid ""
"Interfaces used to wait for signals: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), and B<sigwaitinfo>(2)."
msgstr ""
"シグナル待ちに使われるインターフェイス: B<pause>(2), B<sigsuspend>(2), "
"B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#. type: Plain text
#: build/C/man7/signal.7:750
msgid ""
"File descriptor multiplexing interfaces: B<epoll_wait>(2), B<epoll_pwait>"
"(2), B<poll>(2), B<ppoll>(2), B<select>(2), and B<pselect>(2)."
msgstr ""
"ファイルディスクリプタ多重インターフェイス: B<epoll_wait>(2), B<epoll_pwait>"
"(2), B<poll>(2), B<ppoll>(2), B<select>(2), B<pselect>(2)."

#.  On some other systems, SA_RESTART does restart these system calls
#. type: Plain text
#: build/C/man7/signal.7:758
msgid ""
"System V IPC interfaces: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), and "
"B<semtimedop>(2)."
msgstr ""
"System V IPC インターフェイス: B<msgrcv>(2), B<msgsnd>(2), B<semop>(2), "
"B<semtimedop>(2)."

#. type: Plain text
#: build/C/man7/signal.7:764
msgid ""
"Sleep interfaces: B<clock_nanosleep>(2), B<nanosleep>(2), and B<usleep>(3)."
msgstr ""
"スリープ用のインターフェイス: B<clock_nanosleep>(2), B<nanosleep>(2), "
"B<usleep>(3)."

#. type: Plain text
#: build/C/man7/signal.7:769 build/C/man7/signal.7:822
msgid "B<read>(2)  from an B<inotify>(7)  file descriptor."
msgstr "B<inotify>(7)  ファイルディスクリプタからの B<read>(2)."

#. type: Plain text
#: build/C/man7/signal.7:771
msgid "B<io_getevents>(2)."
msgstr "B<io_getevents>(2)."

#. type: Plain text
#: build/C/man7/signal.7:777
msgid ""
"The B<sleep>(3)  function is also never restarted if interrupted by a "
"handler, but gives a success return: the number of seconds remaining to "
"sleep."
msgstr ""
"B<sleep>(3)  関数も、ハンドラにより割り込まれた場合、決して再スタートされるこ"
"とはない。 しかし、成功となり、残っている停止時間を返す。"

#. type: SS
#: build/C/man7/signal.7:777
#, no-wrap
msgid "Interruption of System Calls and Library Functions by Stop Signals"
msgstr "一時停止シグナルによるシステムコールやライブラリ関数への割り込み"

#. type: Plain text
#: build/C/man7/signal.7:786
msgid ""
"On Linux, even in the absence of signal handlers, certain blocking "
"interfaces can fail with the error B<EINTR> after the process is stopped by "
"one of the stop signals and then resumed via B<SIGCONT>.  This behavior is "
"not sanctioned by POSIX.1, and doesn't occur on other systems."
msgstr ""
"Linux では、シグナルハンドラが設定されていない場合でも、 いくつかのブロッキン"
"グ型のインターフェイスは、 プロセスが一時停止 (stop) シグナルの一つにより停止"
"され、 B<SIGCONT> により再開された後に、エラー B<EINTR> で失敗する可能性があ"
"る。 この挙動は POSIX.1 で認められておらず、他のシステムでは起こらない。"

#. type: Plain text
#: build/C/man7/signal.7:788
msgid "The Linux interfaces that display this behavior are:"
msgstr "この挙動を示す Linux のインターフェイスは以下の通りである。"

#. type: Plain text
#: build/C/man7/signal.7:811
msgid "B<epoll_wait>(2), B<epoll_pwait>(2)."
msgstr "B<epoll_wait>(2), B<epoll_pwait>(2)."

#. type: Plain text
#: build/C/man7/signal.7:814
msgid "B<semop>(2), B<semtimedop>(2)."
msgstr "B<semop>(2), B<semtimedop>(2)."

#. type: Plain text
#: build/C/man7/signal.7:817
msgid "B<sigtimedwait>(2), B<sigwaitinfo>(2)."
msgstr "B<sigtimedwait>(2), B<sigwaitinfo>(2)."

#. type: Plain text
#: build/C/man7/signal.7:828
msgid ""
"Linux 2.6.21 and earlier: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."
msgstr ""
"Linux 2.6.21 以前: B<futex>(2)  B<FUTEX_WAIT>, B<sem_timedwait>(3), "
"B<sem_wait>(3)."

#. type: Plain text
#: build/C/man7/signal.7:832
msgid "Linux 2.6.8 and earlier: B<msgrcv>(2), B<msgsnd>(2)."
msgstr "Linux 2.6.8 以前: B<msgrcv>(2), B<msgsnd>(2)."

#. type: Plain text
#: build/C/man7/signal.7:835
msgid "Linux 2.4 and earlier: B<nanosleep>(2)."
msgstr "Linux 2.4 以前: B<nanosleep>(2)."

#.  It must be a *very* long time since this was true:
#.  .SH BUGS
#.  .B SIGIO
#.  and
#.  .B SIGLOST
#.  have the same value.
#.  The latter is commented out in the kernel source, but
#.  the build process of some software still thinks that
#.  signal 29 is
#.  .BR SIGLOST .
#. type: Plain text
#: build/C/man7/signal.7:848
msgid "POSIX.1, except as noted."
msgstr "POSIX.1 (注記した内容以外)。"

#. type: Plain text
#: build/C/man7/signal.7:881
msgid ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), B<rt_sigqueueinfo>"
"(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), "
"B<bsd_signal>(3), B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), "
"B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), "
"B<strsignal>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<pthreads>(7), "
"B<sigevent>(7)"
msgstr ""
"B<kill>(1), B<getrlimit>(2), B<kill>(2), B<killpg>(2), B<rt_sigqueueinfo>"
"(2), B<setitimer>(2), B<setrlimit>(2), B<sgetmask>(2), B<sigaction>(2), "
"B<sigaltstack>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigsuspend>(2), B<sigwaitinfo>(2), B<abort>(3), "
"B<bsd_signal>(3), B<longjmp>(3), B<raise>(3), B<pthread_sigqueue>(3), "
"B<sigqueue>(3), B<sigset>(3), B<sigsetops>(3), B<sigvec>(3), B<sigwait>(3), "
"B<strsignal>(3), B<sysv_signal>(3), B<core>(5), B<proc>(5), B<pthreads>(7), "
"B<sigevent>(7)"

#. type: TH
#: build/C/man2/signalfd.2:19
#, no-wrap
msgid "SIGNALFD"
msgstr "SIGNALFD"

#. type: TH
#: build/C/man2/signalfd.2:19
#, no-wrap
msgid "2009-01-13"
msgstr "2009-01-13"

#. type: Plain text
#: build/C/man2/signalfd.2:22
msgid "signalfd - create a file descriptor for accepting signals"
msgstr "signalfd - シグナル受け付け用のファイルディスクリプタを生成する"

#. type: Plain text
#: build/C/man2/signalfd.2:24
msgid "B<#include E<lt>sys/signalfd.hE<gt>>"
msgstr "B<#include E<lt>sys/signalfd.hE<gt>>"

#. type: Plain text
#: build/C/man2/signalfd.2:26
msgid ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"
msgstr ""
"B<int signalfd(int >I<fd>B<, const sigset_t *>I<mask>B<, int >I<flags>B<);>"

#. type: Plain text
#: build/C/man2/signalfd.2:37
msgid ""
"B<signalfd>()  creates a file descriptor that can be used to accept signals "
"targeted at the caller.  This provides an alternative to the use of a signal "
"handler or B<sigwaitinfo>(2), and has the advantage that the file descriptor "
"may be monitored by B<select>(2), B<poll>(2), and B<epoll>(7)."
msgstr ""
"B<signalfd>()  は、呼び出し元宛てのシグナルを受け付けるために使用されるファイ"
"ル ディスクリプタを生成する。 この方法はシグナルハンドラや B<sigwaitinfo>"
"(2)  を用いる方法の代わりとなるものであり、このファイルディスクリプタを "
"B<select>(2), B<poll>(2), B<epoll>(7)  で監視できるという利点がある。"

#. type: Plain text
#: build/C/man2/signalfd.2:57
msgid ""
"The I<mask> argument specifies the set of signals that the caller wishes to "
"accept via the file descriptor.  This argument is a signal set whose "
"contents can be initialized using the macros described in B<sigsetops>(3).  "
"Normally, the set of signals to be received via the file descriptor should "
"be blocked using B<sigprocmask>(2), to prevent the signals being handled "
"according to their default dispositions.  It is not possible to receive "
"B<SIGKILL> or B<SIGSTOP> signals via a signalfd file descriptor; these "
"signals are silently ignored if specified in I<mask>."
msgstr ""
"I<mask> 引き数には、呼び出し元がこのファイルディスクリプタ経由で受け付けたい "
"シグナル集合を指定する。この引き数で指定するシグナル集合の内容は、 "
"B<sigsetops>(3)  で説明されているマクロを使って初期化することができる。 通"
"常、ファイルディスクリプタ経由で受信するシグナル集合は、 そのシグナルがデフォ"
"ルトの配送方法に基いて処理されるのを防ぐために、 B<sigprocmask>(2)  を使って"
"ブロックしておくべきである。 シグナル B<SIGKILL> と B<SIGSTOP> を signalfd "
"ファイルディスクリプタ経由で受信することはできない。 これらのシグナルが "
"I<mask> で指定された場合には黙って無視される。"

#. type: Plain text
#: build/C/man2/signalfd.2:71
msgid ""
"If the I<fd> argument is -1, then the call creates a new file descriptor and "
"associates the signal set specified in I<mask> with that descriptor.  If "
"I<fd> is not -1, then it must specify a valid existing signalfd file "
"descriptor, and I<mask> is used to replace the signal set associated with "
"that descriptor."
msgstr ""
"I<fd> 引き数が -1 の場合、 B<signalfd>()  は新しいファイルディスクリプタを生"
"成し、 I<mask> で指定されたシグナル集合をそのファイルディスクリプタに関連付け"
"る。 I<fd> 引き数が -1 以外の場合、 I<fd> には有効な既存の signalfd ファイル"
"ディスクリプタを指定しなければならず、 そのディスクリプタに関連付けられている"
"シグナル集合は I<mask> を使って置き換えられる。"

#. type: Plain text
#: build/C/man2/signalfd.2:76
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behaviour of B<signalfd>():"
msgstr ""
"Linux 2.6.27 以降では、 以下の値のいくつかをビット単位の論理和 (OR) で指定す"
"ることで、 B<signalfd>()  の振舞いを変更することができる。"

#. type: TP
#: build/C/man2/signalfd.2:76
#, no-wrap
msgid "B<SFD_NONBLOCK>"
msgstr "B<SFD_NONBLOCK>"

#. type: TP
#: build/C/man2/signalfd.2:84
#, no-wrap
msgid "B<SFD_CLOEXEC>"
msgstr "B<SFD_CLOEXEC>"

#. type: Plain text
#: build/C/man2/signalfd.2:101
msgid ""
"B<signalfd>()  returns a file descriptor that supports the following "
"operations:"
msgstr ""
"B<signalfd>()  が返すファイルディスクリプタは以下の操作をサポートしている。"

#. type: Plain text
#: build/C/man2/signalfd.2:120
msgid ""
"If one or more of the signals specified in I<mask> is pending for the "
"process, then the buffer supplied to B<read>(2)  is used to return one or "
"more I<signalfd_siginfo> structures (see below) that describe the signals.  "
"The B<read>(2)  returns information for as many signals as are pending and "
"will fit in the supplied buffer.  The buffer must be at least I<sizeof"
"(struct signalfd_siginfo)> bytes.  The return value of the B<read>(2)  is "
"the total number of bytes read."
msgstr ""
"I<mask> に指定されているシグナルのうち一つ以上がそのプロセスに対して 処理待"
"ち (pending) であれば、それらのシグナルの情報が B<read>(2)  に渡されたバッ"
"ファを使って、 I<signalfd_siginfo> 構造体に格納されて返される。 B<read>(2)  "
"は、バッファに格納可能な範囲でできるだけ多くの処理待ちのシグナルに ついての情"
"報を返す。 バッファは最低でも I<sizeof(struct signalfd_siginfo)> バイトの大き"
"さがなければならない。 B<read>(2)  の返り値は読み出されたトータルのバイト数で"
"ある。"

#. type: Plain text
#: build/C/man2/signalfd.2:128
msgid ""
"As a consequence of the B<read>(2), the signals are consumed, so that they "
"are no longer pending for the process (i.e., will not be caught by signal "
"handlers, and cannot be accepted using B<sigwaitinfo>(2))."
msgstr ""
"B<read>(2)  が行われた結果、シグナルは消費され、 これらのシグナルはそのプロセ"
"スに対しては処理待ちではなくなる (つまり、シグナルハンドラで捕捉されることも"
"なく、 B<sigwaitinfo>(2)  を使って受け取ることもできなくなる)。"

#. type: Plain text
#: build/C/man2/signalfd.2:139
msgid ""
"If none of the signals in I<mask> is pending for the process, then the "
"B<read>(2)  either blocks until one of the signals in I<mask> is generated "
"for the process, or fails with the error B<EAGAIN> if the file descriptor "
"has been made nonblocking."
msgstr ""
"I<mask> に指定されているシグナルがそのプロセスに対して一つも処理待ちでなけれ"
"ば、 B<read>(2)  は、 I<mask> で指定されたシグナルのうちいずれか一つがそのプ"
"ロセスに対して発生するまで 停止 (block) する、もしくはファイルディスクリプタ"
"が非停止 (nonblocking)  に設定されている場合はエラー B<EAGAIN> で失敗する。"

#. type: Plain text
#: build/C/man2/signalfd.2:152
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more of the signals in I<mask> is "
"pending for the process."
msgstr ""
"I<mask> に指定されたシグナルのうち一つ以上がそのプロセスに対して処理待ちであ"
"れば、 ファイルディスクリプタは読み出し可能となる (B<select>(2)  の "
"I<readfds> 引き数や B<poll>(2)  の B<POLLIN> フラグ)。"

#. type: Plain text
#: build/C/man2/signalfd.2:159
msgid ""
"The signalfd file descriptor also supports the other file-descriptor "
"multiplexing APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""
"signalfd ファイルディスクリプタは、これ以外のファイルディスクリプタ 多重 API "
"である B<pselect>(2), B<ppoll>(2), B<epoll>(7)  もサポートしている。"

#. type: Plain text
#: build/C/man2/signalfd.2:164
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same signalfd object have been "
"closed, the resources for object are freed by the kernel."
msgstr ""
"ファイルディスクリプタがそれ以降は必要なくなった際には、クローズすべきであ"
"る。 同じ signalfd オブジェクトに関連付けられたファイルディスクリプタが全て "
"クローズされると、そのオブジェクト用の資源がカーネルにより解放される。"

#. type: SS
#: build/C/man2/signalfd.2:164
#, no-wrap
msgid "The signalfd_siginfo structure"
msgstr "signalfd_siginfo 構造体"

#. type: Plain text
#: build/C/man2/signalfd.2:170
msgid ""
"The format of the I<signalfd_siginfo> structure(s) returned by B<read>(2)s "
"from a signalfd file descriptor is as follows:"
msgstr ""
"signalfd ファイルディスクリプタからの B<read>(2)  で返される "
"I<signalfd_siginfo> 構造体のフォーマットは以下の通りである。"

#.  ssi_trapno is unused on most arches
#. type: Plain text
#: build/C/man2/signalfd.2:195
#, no-wrap
msgid ""
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;   /* Signal number */\n"
"    int32_t  ssi_errno;   /* Error number (unused) */\n"
"    int32_t  ssi_code;    /* Signal code */\n"
"    uint32_t ssi_pid;     /* PID of sender */\n"
"    uint32_t ssi_uid;     /* Real UID of sender */\n"
"    int32_t  ssi_fd;      /* File descriptor (SIGIO) */\n"
"    uint32_t ssi_tid;     /* Kernel timer ID (POSIX timers)\n"
"    uint32_t ssi_band;    /* Band event (SIGIO) */\n"
"    uint32_t ssi_overrun; /* POSIX timer overrun count */\n"
"    uint32_t ssi_trapno;  /* Trap number that caused signal */\n"
"    int32_t  ssi_status;  /* Exit status or signal (SIGCHLD) */\n"
"    int32_t  ssi_int;     /* Integer sent by sigqueue(3) */\n"
"    uint64_t ssi_ptr;     /* Pointer sent by sigqueue(3) */\n"
"    uint64_t ssi_utime;   /* User CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_stime;   /* System CPU time consumed (SIGCHLD) */\n"
"    uint64_t ssi_addr;    /* Address that generated signal\n"
"                             (for hardware-generated signals) */\n"
"    uint8_t  pad[I<X>];      /* Pad size to 128 bytes (allow for\n"
"                              additional fields in the future) */\n"
"};\n"
msgstr ""
"struct signalfd_siginfo {\n"
"struct signalfd_siginfo {\n"
"    uint32_t ssi_signo;   /* シグナル番号 */\n"
"    int32_t  ssi_errno;   /* エラー番号 (未使用) */\n"
"    int32_t  ssi_code;    /* シグナルコード */\n"
"    uint32_t ssi_pid;     /* 送信元の PID */\n"
"    uint32_t ssi_uid;     /* 送信元の実 UID */\n"
"    int32_t  ssi_fd;      /* ファイルディスクリプタ (SIGIO) */\n"
"    uint32_t ssi_tid;     /* カーネルタイマ ID (POSIX タイマ)\n"
"    uint32_t ssi_band;    /* Band イベント (SIGIO) */\n"
"    uint32_t ssi_overrun; /* POSIX タイマのオーバーラン回数 */\n"
"    uint32_t ssi_trapno;  /* シグナルの原因となったトラップ番号 */\n"
"    int32_t  ssi_status;  /* 終了ステータスかシグナル (SIGCHLD) */\n"
"    int32_t  ssi_int;     /* sigqueue(3) から送られた整数 */\n"
"    uint64_t ssi_ptr;     /* sigqueue(3) から送られたポインタ */\n"
"    uint64_t ssi_utime;   /* 消費したユーザ CPU 時間 (SIGCHLD) */\n"
"    uint64_t ssi_stime;   /* 消費したシステム CPU 時間 (SIGCHLD) */\n"
"    uint64_t ssi_addr;    /* シグナルを生成したアドレス\n"
"                             (ハードウェアが生成したシグナルの場合) */\n"
"    uint8_t  pad[I<X>];      /* pad の大きさは 128 バイト\n"
"                             (将来のフィールド追加用の場所の確保) */\n"
"};\n"

#. type: Plain text
#: build/C/man2/signalfd.2:218
msgid ""
"Each of the fields in this structure is analogous to the similarly named "
"field in the I<siginfo_t> structure.  The I<siginfo_t> structure is "
"described in B<sigaction>(2).  Not all fields in the returned "
"I<signalfd_siginfo> structure will be valid for a specific signal; the set "
"of valid fields can be determined from the value returned in the I<ssi_code> "
"field.  This field is the analog of the I<siginfo_t> I<si_code> field; see "
"B<sigaction>(2)  for details."
msgstr ""
"I<signalfd_siginfo> 構造体の各フィールドは、 I<siginfo_t> 構造体の同じような"
"名前のフィールドと同様である。 I<siginfo_t> 構造体については B<sigaction>"
"(2)  に説明がある。 返された I<signalfd_siginfo> 構造体の全てのフィールドがあ"
"るシグナルに対して有効なわけではない。 どのフィールドが有効かは、 "
"I<ssi_code> フィールドで返される値から判定することができる。 このフィールド"
"は I<siginfo_t> の I<si_code> フィールドと同様である。詳細は B<sigaction>"
"(2)  を参照。"

#. type: SS
#: build/C/man2/signalfd.2:218 build/C/man2/timerfd_create.2:268
#, no-wrap
msgid "fork(2) semantics"
msgstr "fork(2) での扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:226
msgid ""
"After a B<fork>(2), the child inherits a copy of the signalfd file "
"descriptor.  A B<read>(2)  from the file descriptor in the child will return "
"information about signals queued to the child."
msgstr ""
"B<fork>(2)  が行われると、子プロセスは signalfd ファイルディスクリプタのコ"
"ピーを 継承する。 子プロセスでこのファイルディスクリプタから B<read>(2)  を行"
"うと、子プロセスに対するキューに入っているシグナルに関する 情報が返される。"

#. type: SS
#: build/C/man2/signalfd.2:226 build/C/man2/timerfd_create.2:280
#, no-wrap
msgid "execve(2) semantics"
msgstr "execve(2) での扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:238
msgid ""
"Just like any other file descriptor, a signalfd file descriptor remains open "
"across an B<execve>(2), unless it has been marked for close-on-exec (see "
"B<fcntl>(2)).  Any signals that were available for reading before the "
"B<execve>(2)  remain available to the newly loaded program.  (This is "
"analogous to traditional signal semantics, where a blocked signal that is "
"pending remains pending across an B<execve>(2).)"
msgstr ""
"他のファイルディスクリプタと全く同様に、 signalfd ファイルディスクリプタも "
"B<execve>(2)  の前後でオープンされたままとなる。但し、そのファイルディスクリ"
"プタに close-on-exec のマーク (B<fcntl>(2)  参照) が付いている場合はクローズ"
"される。 B<execve>(2)  の前に読み出し可能となっていた全てのシグナルは新しく起"
"動されたプログラム でも引き続き読み出し可能である (これは伝統的なシグナルの扱"
"いと同じであり、 処理待ちのブロックされたシグナルは B<execve>(2)  の前後で処"
"理待ちのままとなる)。"

#. type: SS
#: build/C/man2/signalfd.2:238
#, no-wrap
msgid "Thread semantics"
msgstr "スレッドでの扱い"

#. type: Plain text
#: build/C/man2/signalfd.2:248
msgid ""
"The semantics of signalfd file descriptors in a multithreaded program mirror "
"the standard semantics for signals.  In other words, when a thread reads "
"from a signalfd file descriptor, it will read the signals that are directed "
"to the thread itself and the signals that are directed to the process (i.e., "
"the entire thread group).  (A thread will not be able to read signals that "
"are directed to other threads in the process.)"
msgstr ""
"マルチスレッドプログラムにおける signalfd ファイルディスクリプタの扱いは シグ"
"ナルの標準的な扱いと全く同じである。 言い換えると、あるスレッドが signalfd "
"ファイルディスクリプタから 読み出しを行うと、そのスレッド自身宛てのシグナルと"
"プロセス (すなわち スレッドグループ全体) 宛てのシグナルが読み出される。 (ス"
"レッドは同じプロセスの他のスレッド宛てのシグナルを読み出すことはできない。)"

#. type: Plain text
#: build/C/man2/signalfd.2:262
msgid ""
"On success, B<signalfd>()  returns a signalfd file descriptor; this is "
"either a new file descriptor (if I<fd> was -1), or I<fd> if I<fd> was a "
"valid signalfd file descriptor.  On error, -1 is returned and I<errno> is "
"set to indicate the error."
msgstr ""
"成功すると、 B<signalfd>()  は signalfd ファイルディスクリプタを返す。 返され"
"るファイルディスクリプタは、 I<fd> が -1 の場合は新規のファイルディスクリプタ"
"であり、 I<fd> が有効な signalfd ファイルディスクリプタだった場合は I<fd> 自"
"身である。 エラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: TP
#: build/C/man2/signalfd.2:263 build/C/man2/timerfd_create.2:337
#, no-wrap
msgid "B<EBADF>"
msgstr "B<EBADF>"

#. type: Plain text
#: build/C/man2/signalfd.2:268
msgid "The I<fd> file descriptor is not a valid file descriptor."
msgstr "ファイルディスクリプタ I<fd> が有効なファイルディスクリプタでない。"

#.  or, the
#.  .I sizemask
#.  argument is not equal to
#.  .IR sizeof(sigset_t) ;
#. type: Plain text
#: build/C/man2/signalfd.2:276
msgid "I<fd> is not a valid signalfd file descriptor."
msgstr "I<fd> が有効な signalfd ファイルディスクリプタではない。"

#. type: Plain text
#: build/C/man2/signalfd.2:283 build/C/man2/timerfd_create.2:319
msgid ""
"I<flags> is invalid; or, in Linux 2.6.26 or earlier, I<flags> is nonzero."
msgstr ""
"I<flags> が無効である。もしくは、Linux 2.6.26 以前の場合には I<flags> が 0 以"
"外である。"

#. type: Plain text
#: build/C/man2/signalfd.2:286 build/C/man2/timerfd_create.2:322
msgid "The per-process limit of open file descriptors has been reached."
msgstr ""
"オープン済みのファイルディスクリプタの数がプロセスあたりの上限に 達していた。"

#. type: Plain text
#: build/C/man2/signalfd.2:296
msgid "There was insufficient memory to create a new signalfd file descriptor."
msgstr ""
"新しい signalfd ファイルディスクリプタを生成するのに十分なメモリがなかった。"

#.  signalfd() is in glibc 2.7, but reportedly does not build
#. type: Plain text
#: build/C/man2/signalfd.2:304
msgid ""
"B<signalfd>()  is available on Linux since kernel 2.6.22.  Working support "
"is provided in glibc since version 2.8.  The B<signalfd4>()  system call "
"(see NOTES) is available on Linux since kernel 2.6.27."
msgstr ""
"B<signalfd>()  はカーネル 2.6.22 以降の Linux で利用可能である。 正しく動作す"
"る glibc 側のサポートはバージョン 2.8 以降で提供されている。 B<signalfd4>()  "
"システムコール (「注意」参照) は カーネル 2.6.27 以降の Linux で利用可能であ"
"る。"

#. type: Plain text
#: build/C/man2/signalfd.2:309
msgid "B<signalfd>()  and B<signalfd4>()  are Linux-specific."
msgstr "B<signalfd>()  と B<signalfd4>()  は Linux 固有である。"

#. type: Plain text
#: build/C/man2/signalfd.2:319
msgid ""
"The underlying Linux system call requires an additional argument, I<size_t "
"sizemask>, which specifies the size of the I<mask> argument.  The glibc "
"B<signalfd>()  wrapper function does not include this argument, since it "
"provides the required value for the underlying system call."
msgstr ""
"実際の Linux のシステムコールでは I<size_t sizemask> という引き数が追加で必要"
"である。この引き数で I<mask> のサイズを指定する。 glibc の B<signalfd>()  "
"ラッパー関数にはこの引き数は含まれず、 ラッパー関数が必要な値を計算して内部で"
"呼び出すシステムコールに提供する。"

#. type: Plain text
#: build/C/man2/signalfd.2:333
msgid ""
"A process can create multiple signalfd file descriptors.  This makes it "
"possible to accept different signals on different file descriptors.  (This "
"may be useful if monitoring the file descriptors using B<select>(2), B<poll>"
"(2), or B<epoll>(7): the arrival of different signals will make different "
"descriptors ready.)  If a signal appears in the I<mask> of more than one of "
"the file descriptors, then occurrences of that signal can be read (once) "
"from any one of the descriptors."
msgstr ""
"一つのプロセスは複数の signalfd ファイルディスクリプタを生成することができ"
"る。 これにより、異なるファイルディスクリプタで異なるシグナルを受け取ること"
"が できる (この機能は B<select>(2), B<poll>(2), B<epoll>(7)  を使ってファイル"
"ディスクリプタを監視する場合に有用かもしれない。 異なるシグナルが到着すると、"
"異なるファイルディスクリプタが利用可能に なるからだ)。 一つのシグナルが二つ以"
"上のファイルディスクリプタの I<mask> に含まれている場合、そのシグナルの発生は"
"そのシグナルを I<mask> に含むファイルディスクリプタのうちいずれか一つから読み"
"出すことができる。"

#. type: Plain text
#: build/C/man2/signalfd.2:349
msgid ""
"There are two underlying Linux system calls: B<signalfd>()  and the more "
"recent B<signalfd4>().  The former system call does not implement a I<flags> "
"argument.  The latter system call implements the I<flags> values described "
"above.  Starting with glibc 2.9, the B<signalfd>()  wrapper function will "
"use B<signalfd4>()  where it is available."
msgstr ""
"下層にある Linux システムコールは二種類あり、 B<signalfd>()  と、もっと新し"
"い B<signalfd4>()  である。 B<signalfd>()  は I<flags> 引き数を実装していな"
"い。 B<signalfd4>()  では上記の値の I<flags> が実装されている。 glibc 2.9 以"
"降では、 B<signalfd>()  のラッパー関数は、 B<signalfd4>()  が利用可能であれ"
"ば、これを使用する。"

#.  The fix also was put into 2.6.24.5
#. type: Plain text
#: build/C/man2/signalfd.2:357
msgid ""
"In kernels before 2.6.25, the I<ssi_ptr> and I<ssi_int> fields are not "
"filled in with the data accompanying a signal sent by B<sigqueue>(3)."
msgstr ""
"カーネル 2.6.25 より前では、 B<sigqueue>(3)  により送信されたシグナルと一緒に"
"渡されるデータでは、フィールド I<ssi_ptr> と I<ssi_int> は設定されない。"

#. type: Plain text
#: build/C/man2/signalfd.2:367
msgid ""
"The program below accepts the signals B<SIGINT> and B<SIGQUIT> via a "
"signalfd file descriptor.  The program terminates after accepting a "
"B<SIGQUIT> signal.  The following shell session demonstrates the use of the "
"program:"
msgstr ""
"下記のプログラムは、シグナル B<SIGINT> と B<SIGQUIT> を signalfd ファイルディ"
"スクリプタ経由で受信する。 シグナル B<SIGQUIT> 受信後にプログラムは終了す"
"る。 以下に示すシェルセッションにこのプログラムの使い方を示す。"

#. type: Plain text
#: build/C/man2/signalfd.2:378
#, no-wrap
msgid ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<^C>\n"
"Got SIGINT\n"
"B<^\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"
msgstr ""
"$B< ./signalfd_demo>\n"
"B<^C>                   # Control-C generates SIGINT\n"
"Got SIGINT\n"
"B<^C>\n"
"Got SIGINT\n"
"B<^\\e>                    # Control-\\e generates SIGQUIT\n"
"Got SIGQUIT\n"
"$\n"

#. type: Plain text
#: build/C/man2/signalfd.2:388
#, no-wrap
msgid ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>sys/signalfd.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/signalfd.2:399
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    sigset_t mask;\n"
"    int sfd;\n"
"    struct signalfd_siginfo fdsi;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/signalfd.2:403
#, no-wrap
msgid ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"
msgstr ""
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIGINT);\n"
"    sigaddset(&mask, SIGQUIT);\n"

#. type: Plain text
#: build/C/man2/signalfd.2:406
#, no-wrap
msgid ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"
msgstr ""
"    /* Block signals so that they aren\\(aqt handled\n"
"       according to their default dispositions */\n"

#. type: Plain text
#: build/C/man2/signalfd.2:409
#, no-wrap
msgid ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"
msgstr ""
"    if (sigprocmask(SIG_BLOCK, &mask, NULL) == -1)\n"
"        handle_error(\"sigprocmask\");\n"

#. type: Plain text
#: build/C/man2/signalfd.2:413
#, no-wrap
msgid ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"
msgstr ""
"    sfd = signalfd(-1, &mask, 0);\n"
"    if (sfd == -1)\n"
"        handle_error(\"signalfd\");\n"

#. type: Plain text
#: build/C/man2/signalfd.2:418
#, no-wrap
msgid ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"
msgstr ""
"    for (;;) {\n"
"        s = read(sfd, &fdsi, sizeof(struct signalfd_siginfo));\n"
"        if (s != sizeof(struct signalfd_siginfo))\n"
"            handle_error(\"read\");\n"

#. type: Plain text
#: build/C/man2/signalfd.2:429
#, no-wrap
msgid ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"
msgstr ""
"        if (fdsi.ssi_signo == SIGINT) {\n"
"            printf(\"Got SIGINT\\en\");\n"
"        } else if (fdsi.ssi_signo == SIGQUIT) {\n"
"            printf(\"Got SIGQUIT\\en\");\n"
"            exit(EXIT_SUCCESS);\n"
"        } else {\n"
"            printf(\"Read unexpected signal\\en\");\n"
"        }\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/signalfd.2:443
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"
msgstr ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<sigaction>(2), "
"B<sigprocmask>(2), B<sigwaitinfo>(2), B<timerfd_create>(2), B<sigsetops>(3), "
"B<sigwait>(3), B<epoll>(7), B<signal>(7)"

#. type: TH
#: build/C/man3/sigpause.3:23
#, no-wrap
msgid "SIGPAUSE"
msgstr "SIGPAUSE"

#. type: TH
#: build/C/man3/sigpause.3:23
#, no-wrap
msgid "2010-09-12"
msgstr "2010-09-12"

#. type: Plain text
#: build/C/man3/sigpause.3:26
msgid "sigpause - atomically release blocked signals and wait for interrupt"
msgstr "sigpause - ブロックされたシグナルをアトミックに解放して割り込みを待つ"

#. type: Plain text
#: build/C/man3/sigpause.3:31
#, no-wrap
msgid "B<int sigpause(int >I<sigmask>B<);  /* BSD */>\n"
msgstr "B<int sigpause(int >I<sigmask>B<);  /* BSD */>\n"

#. type: Plain text
#: build/C/man3/sigpause.3:33
#, no-wrap
msgid "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"
msgstr "B<int sigpause(int >I<sig>B<);      /* System V / UNIX 95 */>\n"

#. type: Plain text
#: build/C/man3/sigpause.3:39
msgid "Don't use this function.  Use B<sigsuspend>(2)  instead."
msgstr "この関数を使わないこと。 代わりに B<sigsuspend>(2)  を使うこと。"

#. type: Plain text
#: build/C/man3/sigpause.3:46
msgid ""
"The function B<sigpause>()  is designed to wait for some signal.  It changes "
"the process's signal mask (set of blocked signals), and then waits for a "
"signal to arrive.  Upon arrival of a signal, the original signal mask is "
"restored."
msgstr ""
"関数 B<sigpause>()  はシグナルを待つように設計されている。 この関数はプロセス"
"のシグナルマスク (ブロックされたシグナルのセット) を変更し、 シグナルが到着す"
"るのを待つ。 シグナルが到着すると、シグナルマスクは元に戻される。"

#. type: Plain text
#: build/C/man3/sigpause.3:54
msgid ""
"If B<sigpause>()  returns, it was interrupted by a signal and the return "
"value is -1 with I<errno> set to B<EINTR>."
msgstr ""
"B<sigpause>()  が返った場合、この関数はシグナルによって割り込まれている。 返"
"り値は -1 で、 I<errno> は B<EINTR> に設定される。"

#. type: Plain text
#: build/C/man3/sigpause.3:58
msgid "The System V version of B<sigpause>()  is standardized in POSIX.1-2001."
msgstr "System V 版の B<sigpause>()  は POSIX.1-2001 で標準化されている。"

#.  __xpg_sigpause: UNIX 95, spec 1170, SVID, SVr4, XPG
#. type: Plain text
#: build/C/man3/sigpause.3:75
msgid ""
"The classical BSD version of this function appeared in 4.2BSD.  It sets the "
"process's signal mask to I<sigmask>.  UNIX 95 standardized the incompatible "
"System V version of this function, which removes only the specified signal "
"I<sig> from the process's signal mask.  The unfortunate situation with two "
"incompatible functions with the same name was solved by the B<\\%sigsuspend>"
"(2)  function, that takes a I<sigset_t *> argument (instead of an I<int>)."
msgstr ""
"この関数の古典的な BSD 版は 4.2BSD で登場した。 この関数はプロセスのシグナル"
"マスクを I<sigmask> に設定する。 UNIX 95 では BSD 版と互換性のない System V "
"版のこの関数が標準化された。 UNIX 95 版は、指定されたシグナル I<sig> をプロセ"
"スのシグナルマスクから削除するだけである。 同じ名前で互換性のない 2 つの関数"
"があるという不幸な事態は、 B<\\%sigsuspend>(2)  関数によって解消された。 この"
"関数は (I<int> の代わりに)  B<sigset_t *> 引き数をとる。"

#. type: Plain text
#: build/C/man3/sigpause.3:78
msgid ""
"On Linux, this routine is a system call only on the Sparc (sparc64)  "
"architecture."
msgstr ""
"Linux では、このルーチンは Sparc (sparc64) アーキテクチャでのみ システムコー"
"ルとなっている。"

#. type: Plain text
#: build/C/man3/sigpause.3:80
msgid "Libc4 and libc5 only know about the BSD version."
msgstr "libc4 と libc5 には BSD 版しかない。"

#.  For the BSD version, one usually uses a zero
#.  .I sigmask
#.  to indicate that no signals are to be blocked.
#. type: Plain text
#: build/C/man3/sigpause.3:96
msgid ""
"Glibc uses the BSD version if the B<_BSD_SOURCE> feature test macro is "
"defined and none of B<_POSIX_SOURCE>, B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, "
"B<_GNU_SOURCE>, or B<_SVID_SOURCE> is defined.  Otherwise, the System V "
"version is used."
msgstr ""
"機能検査マクロ B<_BSD_SOURCE> が定義され、 B<_POSIX_SOURCE>, "
"B<_POSIX_C_SOURCE>, B<_XOPEN_SOURCE>, B<_GNU_SOURCE>, B<_SVID_SOURCE> のいず"
"れも定義されていない場合、 glibc は BSD 版を使う。 それ以外の場合には、"
"System V 版を使用する。"

#. type: Plain text
#: build/C/man3/sigpause.3:104
msgid ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<sigblock>"
"(3), B<sigvec>(3), B<feature_test_macros>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<sigprocmask>(2), B<sigsuspend>(2), B<sigblock>"
"(3), B<sigvec>(3), B<feature_test_macros>(7)"

#. type: TH
#: build/C/man2/sigpending.2:27
#, no-wrap
msgid "SIGPENDING"
msgstr "SIGPENDING"

#. type: TH
#: build/C/man2/sigpending.2:27
#, no-wrap
msgid "2008-10-04"
msgstr "2008-10-04"

#. type: Plain text
#: build/C/man2/sigpending.2:30
msgid "sigpending - examine pending signals"
msgstr "sigpending - 処理待ちのシグナルの検査"

#. type: Plain text
#: build/C/man2/sigpending.2:34
msgid "B<int sigpending(sigset_t *>I<set>B<);>"
msgstr "B<int sigpending(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man2/sigpending.2:43
msgid ""
"B<sigpending>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""
"B<sigpending>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"

#. type: Plain text
#: build/C/man2/sigpending.2:51
msgid ""
"B<sigpending>()  returns the set of signals that are pending for delivery to "
"the calling thread (i.e., the signals which have been raised while "
"blocked).  The mask of pending signals is returned in I<set>."
msgstr ""
"B<sigpending>()  は、呼び出し元のスレッドへの配送を待っている (pending) シグ"
"ナル集合 (すなわち、禁止中に発生したシグナル) を返す。 処理待ちのシグナルのマ"
"スクが I<set> に格納される。"

#. type: Plain text
#: build/C/man2/sigpending.2:54
msgid "B<sigpending>()  returns 0 on success and -1 on error."
msgstr "B<sigpending>()  は成功すれば 0 を返し、エラーならば -1 を返す。"

#. type: Plain text
#: build/C/man2/sigpending.2:59
msgid ""
"I<set> points to memory which is not a valid part of the process address "
"space."
msgstr ""
"I<set> が指しているメモリが、プロセスのアドレス空間の有効な部分ではない。"

#. type: Plain text
#: build/C/man2/sigpending.2:70
msgid ""
"The set of signals that is pending for a thread is the union of the set of "
"signals that is pending for that thread and the set of signals that is "
"pending for the process as a whole; see B<signal>(7)."
msgstr ""
"あるスレッドに対する処理待ちのシグナルの集合は、 そのスレッド自体への処理待ち"
"のシグナル集合と、プロセス全体への処理待ちの シグナル集合をあわせたものであ"
"る。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/sigpending.2:82
msgid ""
"In versions of glibc up to and including 2.2.1, there is a bug in the "
"wrapper function for B<sigpending>()  which means that information about "
"pending real-time signals is not correctly returned."
msgstr ""
"バージョン 2.2.1 以前の glibc では、 B<sigpending>()  のラッパー関数に、処理"
"待ちのリアルタイムシグナルに関する情報が 正しく返されないというバグがある。"

#. type: Plain text
#: build/C/man2/sigpending.2:90
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), B<sigsuspend>"
"(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), B<sigsuspend>"
"(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sigprocmask.2:27
#, no-wrap
msgid "SIGPROCMASK"
msgstr "SIGPROCMASK"

#. type: TH
#: build/C/man2/sigprocmask.2:27
#, no-wrap
msgid "2012-04-15"
msgstr "2012-04-15"

#. type: Plain text
#: build/C/man2/sigprocmask.2:30
msgid "sigprocmask - examine and change blocked signals"
msgstr "sigprocmask - 禁止するシグナルの確認と変更"

#. type: Plain text
#: build/C/man2/sigprocmask.2:35
msgid ""
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<,> B<sigset_t "
"*>I<oldset>B<);>"
msgstr ""
"B<int sigprocmask(int >I<how>B<, const sigset_t *>I<set>B<,> B<sigset_t "
"*>I<oldset>B<);>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:44
msgid ""
"B<sigprocmask>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""
"B<sigprocmask>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"

#. type: Plain text
#: build/C/man2/sigprocmask.2:53
msgid ""
"B<sigprocmask>()  is used to fetch and/or change the signal mask of the "
"calling thread.  The signal mask is the set of signals whose delivery is "
"currently blocked for the caller (see also B<signal>(7)  for more details)."
msgstr ""
"B<sigprocmask>()  を使うと、呼び出したスレッドのシグナルマスクの取得/変更がで"
"きる。 シグナルマスクは、呼び出し元に対して現在配送が禁止されているシグナル"
"の 集合のことである (詳細については B<signal>(7)  も参照のこと)。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:57
msgid ""
"The behavior of the call is dependent on the value of I<how>, as follows."
msgstr "このコールの動作は I<how> の値によって決まる:"

#. type: TP
#: build/C/man2/sigprocmask.2:57
#, no-wrap
msgid "B<SIG_BLOCK>"
msgstr "B<SIG_BLOCK>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:62
msgid ""
"The set of blocked signals is the union of the current set and the I<set> "
"argument."
msgstr ""
"禁止されたシグナルの集合は現在の値と I<set> 引き数を結合したものとなる。"

#. type: TP
#: build/C/man2/sigprocmask.2:62
#, no-wrap
msgid "B<SIG_UNBLOCK>"
msgstr "B<SIG_UNBLOCK>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:68
msgid ""
"The signals in I<set> are removed from the current set of blocked signals.  "
"It is permissible to attempt to unblock a signal which is not blocked."
msgstr ""
"現在禁止されているシグナルの集合から I<set> にあるシグナルを取り除く。禁止さ"
"れていないシグナルを取り除こうと することも認められている。"

#. type: TP
#: build/C/man2/sigprocmask.2:68
#, no-wrap
msgid "B<SIG_SETMASK>"
msgstr "B<SIG_SETMASK>"

#. type: Plain text
#: build/C/man2/sigprocmask.2:72
msgid "The set of blocked signals is set to the argument I<set>."
msgstr "禁止されているシグナルの集合に I<set> 引き数を設定する。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:77
msgid ""
"If I<oldset> is non-NULL, the previous value of the signal mask is stored in "
"I<oldset>."
msgstr ""
"I<oldset> が NULL でなければ、シグナルマスクの今までの値を I<oldset> に格納す"
"る。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:86
msgid ""
"If I<set> is NULL, then the signal mask is unchanged (i.e., I<how> is "
"ignored), but the current value of the signal mask is nevertheless returned "
"in I<oldset> (if it is not NULL)."
msgstr ""
"I<set> が NULL であれば、シグナルマスクは変更されない (すなわち、 I<how> は無"
"視される)。 I<set> の値にかかわらず、現在のシグナルマスクの値は I<oldset> に"
"入れて返される (但し、 I<oldset> が NULL でない場合)。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:91
msgid ""
"The use of B<sigprocmask>()  is unspecified in a multithreaded process; see "
"B<pthread_sigmask>(3)."
msgstr ""
"マルチスレッドのプロセスで B<sigprocmask>()  を使用した場合の動作は規定されて"
"いない。 B<pthread_sigmask>(3)  を参照のこと。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:94
msgid "B<sigprocmask>()  returns 0 on success and -1 on error."
msgstr "B<sigprocmask>()  は成功すれば 0 を返し、エラーならば -1 を返す。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:102
msgid ""
"the I<set> or I<oldset> argument points outside the process's allocated "
"address space."
msgstr ""
"引き数 I<set> か I<oldset> がプロセスに割り当てられた\n"
"アドレス空間の外を指している。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:107
msgid "The value specified in I<how> was invalid."
msgstr "I<how> に指定された値が有効ではない。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:113
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>.  Attempts to do so are "
"silently ignored."
msgstr ""
"B<SIGKILL> や B<SIGSTOP> を禁止することはできない。 禁止しようとしても黙って"
"無視される。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:115
msgid "Each of the threads in a process has its own signal mask."
msgstr "プロセス内の各スレッドはそれぞれ専用のシグナルマスクを持つ。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:135
msgid ""
"If B<SIGBUS>, B<SIGFPE>, B<SIGILL>, or B<SIGSEGV> are generated while they "
"are blocked, the result is undefined, unless the signal was generated by "
"B<kill>(2), B<sigqueue>(3), or B<raise>(3)."
msgstr ""
"シグナル B<SIGBUS>, B<SIGFPE>, B<SIGILL>, B<SIGSEGV> が禁止されている間に生成"
"された場合で、 そのシグナルが B<kill>(2), B<sigqueue>(3), B<raise>(3)  によっ"
"て生成されたものでないときには、 その後の動作は未定義である。"

#. type: Plain text
#: build/C/man2/sigprocmask.2:150
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigpending>(2), "
"B<sigsuspend>(2), B<pthread_sigmask>(3), B<sigqueue>(3), B<sigsetops>(3), "
"B<signal>(7)"

#. type: TH
#: build/C/man3/sigqueue.3:26
#, no-wrap
msgid "SIGQUEUE"
msgstr "SIGQUEUE"

#. type: TH
#: build/C/man3/sigqueue.3:26
#, no-wrap
msgid "2012-03-25"
msgstr "2012-03-25"

#. type: Plain text
#: build/C/man3/sigqueue.3:29
msgid "sigqueue - queue a signal and data to a process"
msgstr "sigqueue - シグナルとデータをプロセスに送る"

#. type: Plain text
#: build/C/man3/sigqueue.3:33
msgid ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"
msgstr ""
"B<int sigqueue(pid_t >I<pid>B<, int >I<sig>B<, const union sigval "
">I<value>B<);>"

#. type: Plain text
#: build/C/man3/sigqueue.3:41
msgid "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<sigqueue>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man3/sigqueue.3:53
msgid ""
"B<sigqueue>()  sends the signal specified in I<sig> to the process whose PID "
"is given in I<pid>.  The permissions required to send a signal are the same "
"as for B<kill>(2).  As with B<kill>(2), the null signal (0) can be used to "
"check if a process with a given PID exists."
msgstr ""
"B<sigqueue>()  は I<sig> で指定されたシグナルを、PID が I<pid> であるプロセス"
"に送る。 シグナルを送るのに必要な権限は B<kill>(2)  と同じである。 B<kill>"
"(2)  と同様に、ヌル・シグナル (0) を使って 指定した PID のプロセスが存在する"
"かをチェックすることができる。"

#. type: Plain text
#: build/C/man3/sigqueue.3:58
msgid ""
"The I<value> argument is used to specify an accompanying item of data "
"(either an integer or a pointer value) to be sent with the signal, and has "
"the following type:"
msgstr ""
"I<value> 引き数はシグナルと一緒に送るデータの付属アイテムを指定する。 "
"I<value> は (整数またはポインタの値であり) 以下のような型である。"

#. type: Plain text
#: build/C/man3/sigqueue.3:65
#, no-wrap
msgid ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"
msgstr ""
"union sigval {\n"
"    int   sival_int;\n"
"    void *sival_ptr;\n"
"};\n"

#. type: Plain text
#: build/C/man3/sigqueue.3:81
msgid ""
"If the receiving process has installed a handler for this signal using the "
"B<SA_SIGINFO> flag to B<sigaction>(2), then it can obtain this data via the "
"I<si_value> field of the I<siginfo_t> structure passed as the second "
"argument to the handler.  Furthermore, the I<si_code> field of that "
"structure will be set to B<SI_QUEUE>."
msgstr ""
"受取先のプロセスに、このシグナルに対するハンドラを (B<sigaction>(2)  に "
"B<SA_SIGINFO> を指定して) インストールしておくと、 そのハンドラの第 2 引き数"
"に渡される I<siginfo_t> 構造体の I<si_value> フィールドによって、このデータを"
"取得できる。 さらに、この構造体の I<si_code> フィールドは B<SI_QUEUE> に設定"
"される。"

#. type: Plain text
#: build/C/man3/sigqueue.3:89
msgid ""
"On success, B<sigqueue>()  returns 0, indicating that the signal was "
"successfully queued to the receiving process.  Otherwise -1 is returned and "
"I<errno> is set to indicate the error."
msgstr ""
"成功した場合、 B<sigqueue>()  は 0 を返す。 これは受け取り側プロセスの待ち行"
"列に シグナルが正しく入れられたことを示す。 失敗した場合は -1 が返され、 "
"I<errno> がエラーを表す値に設定される。"

#. type: Plain text
#: build/C/man3/sigqueue.3:100
msgid "I<sig> was invalid."
msgstr "I<sig> が不正である。"

#. type: Plain text
#: build/C/man3/sigqueue.3:106
msgid ""
"The process does not have permission to send the signal to the receiving "
"process.  For the required permissions, see B<kill>(2)."
msgstr ""
"このプロセスには、受け取り側プロセスにシグナルを送る権限がない。 必要な権限に"
"ついては、 B<kill>(2)  を参照すること。"

#. type: Plain text
#: build/C/man3/sigqueue.3:110
msgid "No process has a PID matching I<pid>."
msgstr "I<pid> にマッチする PID のプロセスがない。"

#. type: Plain text
#: build/C/man3/sigqueue.3:112
msgid "This system call first appeared in Linux 2.2."
msgstr "このシステムコールは Linux 2.2 で初めて登場した。"

#. type: Plain text
#: build/C/man3/sigqueue.3:122
msgid ""
"If this function results in the sending of a signal to the process that "
"invoked it, and that signal was not blocked by the calling thread, and no "
"other threads were willing to handle this signal (either by having it "
"unblocked, or by waiting for it using B<sigwait>(3)), then at least some "
"signal must be delivered to this thread before this function returns."
msgstr ""
"この関数を呼び出したプロセスにこの関数がシグナルを送ったときに、 シグナルが呼"
"び出し側スレッドにブロックされず、 かつ (シグナルがブロックされなかった、また"
"は B<sigwait>(3)  を使用するのを待っていることにより)  このシグナルを扱うス"
"レッドが何もない場合は、 この関数がリターンする前に、少なくとも そのスレッド"
"に対してシグナルが配送されていなければならない。"

#. type: Plain text
#: build/C/man3/sigqueue.3:137
msgid ""
"On Linux, this function is implemented using the B<rt_sigqueueinfo>(2)  "
"system call.  The system call differs in its third argument, which is the "
"I<siginfo_t> structure that will be supplied to the receiving process's "
"signal handler or returned by the receiving process's B<sigtimedwait>(2)  "
"call.  Inside the glibc B<sigqueue>()  wrapper, this argument, I<uinfo>, is "
"initialized as follows:"
msgstr ""
"Linux では、この関数は B<rt_sigqueueinfo>(2)  システムコールを使って実装され"
"ている。 両者には 3 番目の引き数に違いがあり、 B<rt_sigqueueinfo>(2)  では 3 "
"番目の引き数は I<siginfo_t> 構造体である。 I<siginfo_t> 構造体は、シグナルを"
"受信するプロセスのシグナルハンドラに渡されたり、 シグナル受信プロセスの "
"B<sigtimedwait>(2)  システムコールから返されたりする。 glibc の B<sigqueue>"
"()  ラッパー関数内部では、 この引き数 I<uinfo> は以下のように初期化される。"

#. type: Plain text
#: build/C/man3/sigqueue.3:145
#, no-wrap
msgid ""
"uinfo.si_signo = sig;      /* argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* argument supplied to sigqueue() */\n"
msgstr ""
"uinfo.si_signo = sig;      /* argument supplied to sigqueue() */\n"
"uinfo.si_code = SI_QUEUE;\n"
"uinfo.si_pid = getpid();   /* Process ID of sender */\n"
"uinfo.si_uid = getuid();   /* Real UID of sender */\n"
"uinfo.si_value = val;      /* argument supplied to sigqueue() */\n"

#. type: Plain text
#: build/C/man3/sigqueue.3:155
msgid ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<rt_sigqueueinfo>(2), B<sigaction>(2), B<signal>(2), "
"B<pthread_sigqueue>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sigreturn.2:27
#, no-wrap
msgid "SIGRETURN"
msgstr "SIGRETURN"

#. type: TH
#: build/C/man2/sigreturn.2:27
#, no-wrap
msgid "2008-06-26"
msgstr "2008-06-26"

#. type: Plain text
#: build/C/man2/sigreturn.2:30
msgid "sigreturn - return from signal handler and cleanup stack frame"
msgstr "sigreturn - シグナル・ハンドラから返り、スタックを掃除する"

#. type: Plain text
#: build/C/man2/sigreturn.2:32
msgid "B<int sigreturn(unsigned long >I<__unused>B<);>"
msgstr "B<int sigreturn(unsigned long >I<__unused>B<);>"

#. type: Plain text
#: build/C/man2/sigreturn.2:40
msgid ""
"When the Linux kernel creates the stack frame for a signal handler, a call "
"to B<sigreturn>()  is inserted into the stack frame so that upon return from "
"the signal handler, B<sigreturn>()  will be called."
msgstr ""
"Linux カーネルは、 シグナル・ハンドラ用にスタック・フレームを作成する際、 "
"B<sigreturn>()  をスタック・フレームに挿入し、シグナル・ハンドラが返るときに "
"B<sigreturn>()  が呼ばれるようにする。"

#. type: Plain text
#: build/C/man2/sigreturn.2:51
msgid ""
"This B<sigreturn>()  call undoes everything that was done\\(emchanging the "
"process's signal mask, switching stacks (see B<sigaltstack>(2))\\(emin order "
"to invoke the signal handler: it restores the process's signal mask, "
"switches stacks, and restores the process's context (registers, processor "
"flags), so that the process directly resumes execution at the point where it "
"was interrupted by the signal."
msgstr ""
"B<sigreturn>()  は、シグナル・ハンドラを起動するために行ったことの全て \\(em "
"プロセスのシグナルマスクの変更、スタックの切り替え (B<sigaltstack>(2)  参照) "
"\\(em の取り消しを行う。 プロセスのシグナルマスクの復元、スタックの切り替"
"え、 プロセスのコンテキスト (レジスタ、プロセッサ・フラグ) の復元を行い、 プ"
"ロセスがシグナルにより割り込まれた場所からそのまま実行を 再開できるようにす"
"る。"

#. type: Plain text
#: build/C/man2/sigreturn.2:54
msgid "B<sigreturn>()  never returns."
msgstr "B<sigreturn>()  が返ることはない。"

#. type: SH
#: build/C/man2/sigreturn.2:54
#, no-wrap
msgid "FILES"
msgstr "ファイル"

#. type: Plain text
#: build/C/man2/sigreturn.2:56
msgid "/usr/src/linux/arch/i386/kernel/signal.c"
msgstr "/usr/src/linux/arch/i386/kernel/signal.c"

#. type: Plain text
#: build/C/man2/sigreturn.2:58
msgid "/usr/src/linux/arch/alpha/kernel/entry.S"
msgstr "/usr/src/linux/arch/alpha/kernel/entry.S"

#. type: Plain text
#: build/C/man2/sigreturn.2:62
msgid ""
"B<sigreturn>()  is specific to Linux and should not be used in programs "
"intended to be portable."
msgstr ""
"B<sigreturn>()  は Linux 特有であり、移植を意図したプログラムでは使用してはい"
"けない。"

#. type: Plain text
#: build/C/man2/sigreturn.2:72
msgid ""
"The B<sigreturn>()  call is used by the kernel to implement signal "
"handlers.  It should B<never> be called directly.  Better yet, the specific "
"use of the I<__unused> argument varies depending on the architecture."
msgstr ""
"B<sigreturn>()  コールは、シグナル・ハンドラを実装するためにカーネルにより使"
"用される。 これを直接呼び出しては B<決して> いけない。さらに I<__unused> 引き"
"数がどのように使われるかはそのアーキテクチャに依存して変化する。"

#. type: Plain text
#: build/C/man2/sigreturn.2:77
msgid "B<kill>(2), B<sigaltstack>(2), B<signal>(2), B<signal>(7)"
msgstr "B<kill>(2), B<sigaltstack>(2), B<signal>(2), B<signal>(7)"

#. type: TH
#: build/C/man3/sigset.3:24
#, no-wrap
msgid "SIGSET"
msgstr "SIGSET"

#. type: Plain text
#: build/C/man3/sigset.3:27
msgid "sigset, sighold, sigrelse, sigignore - System V signal API"
msgstr "sigset, sighold, sigrelse, sigignore - System V 版シグナル API"

#. type: Plain text
#: build/C/man3/sigset.3:33
msgid "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"
msgstr "B<sighandler_t sigset(int >I<sig>B<, sighandler_t >I<disp>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:35
msgid "B<int sighold(int >I<sig>B<);>"
msgstr "B<int sighold(int >I<sig>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:37
msgid "B<int sigrelse(int >I<sig>B<);>"
msgstr "B<int sigrelse(int >I<sig>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:39
msgid "B<int sigignore(int >I<sig>B<);>"
msgstr "B<int sigignore(int >I<sig>B<);>"

#. type: Plain text
#: build/C/man3/sigset.3:50
msgid "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"
msgstr "B<sigset>(), B<sighold>(), B<sigrelse>(), B<sigignore>():"

#. type: Plain text
#: build/C/man3/sigset.3:54
msgid ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"
msgstr ""
"_XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ _XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man3/sigset.3:63
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical System V signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""
"これらの関数は、昔ながらの System V 版シグナル API を使用しているプログラム "
"に対して互換性のあるインタフェースを glibc で提供するものである。 この API は"
"過去のものであり、新しいアプリケーションでは POSIX シグナル API (B<sigaction>"
"(2), B<sigprocmask>(2)  など) を使用すべきである。"

#. type: Plain text
#: build/C/man3/sigset.3:72
msgid ""
"The B<sigset>()  function modifies the disposition of the signal I<sig>.  "
"The I<disp> argument can be the address of a signal handler function, or one "
"of the following constants:"
msgstr ""
"関数 B<sigset>()  はシグナル I<sig> のシグナルハンドラの動作を変更する。 "
"I<disp> 引き数には、シグナルハンドラ関数のアドレスか、 以下の定数のいずれか一"
"つを指定できる。"

#. type: TP
#: build/C/man3/sigset.3:72
#, no-wrap
msgid "B<SIG_DFL>"
msgstr "B<SIG_DFL>"

#. type: Plain text
#: build/C/man3/sigset.3:77
msgid "Reset the disposition of I<sig> to the default."
msgstr "I<sig> の動作をデフォルトにリセットする。"

#. type: TP
#: build/C/man3/sigset.3:77
#, no-wrap
msgid "B<SIG_IGN>"
msgstr "B<SIG_IGN>"

#. type: Plain text
#: build/C/man3/sigset.3:81
msgid "Ignore I<sig>."
msgstr "I<sig> を無視する。"

#. type: TP
#: build/C/man3/sigset.3:81
#, no-wrap
msgid "B<SIG_HOLD>"
msgstr "B<SIG_HOLD>"

#. type: Plain text
#: build/C/man3/sigset.3:88
msgid ""
"Add I<sig> to the process's signal mask, but leave the disposition of I<sig> "
"unchanged."
msgstr ""
"そのプロセスのシグナルマスクに I<sig> を追加するが、 I<sig> の動作は変更しな"
"い。"

#. type: Plain text
#: build/C/man3/sigset.3:94
msgid ""
"If I<disp> specifies the address of a signal handler, then I<sig> is added "
"to the process's signal mask during execution of the handler."
msgstr ""
"I<disp> にシグナルハンドラのアドレスが指定された場合、 シグナルハンドラの実行"
"中は、そのプロセスのシグナルマスクに I<sig> が追加される。"

#. type: Plain text
#: build/C/man3/sigset.3:102
msgid ""
"If I<disp> was specified as a value other than B<SIG_HOLD>, then I<sig> is "
"removed from the process's signal mask."
msgstr ""
"I<disp> に B<SIG_HOLD> 以外の値が指定された場合、 そのプロセスのシグナルマス"
"クから I<sig> が削除される。"

#. type: Plain text
#: build/C/man3/sigset.3:108 build/C/man3/sigvec.3:85
msgid "The dispositions for B<SIGKILL> and B<SIGSTOP> cannot be changed."
msgstr "シグナル B<SIGKILL> と B<SIGSTOP> に対する動作は変更できない。"

#. type: Plain text
#: build/C/man3/sigset.3:114
msgid ""
"The B<sighold>()  function adds I<sig> to the calling process's signal mask."
msgstr ""
"関数 B<sighold>()  は、呼び出し元プロセスのシグナルマスクに I<sig> を追加す"
"る。"

#. type: Plain text
#: build/C/man3/sigset.3:120
msgid ""
"The B<sigrelse>()  function removes I<sig> from the calling process's signal "
"mask."
msgstr ""
"関数 B<sigrelse>()  は、呼び出し元プロセスのシグナルマスクから I<sig> を削除"
"する。"

#. type: Plain text
#: build/C/man3/sigset.3:127
msgid ""
"The B<sigignore>()  function sets the disposition of I<sig> to B<SIG_IGN>."
msgstr "関数 B<sigignore>()  は、 I<sig> の動作を B<SIG_IGN> に設定する。"

#. type: Plain text
#: build/C/man3/sigset.3:143
msgid ""
"On success, B<sigset>()  returns B<SIG_HOLD> if I<sig> was blocked before "
"the call, or the signal's previous disposition if it was not blocked before "
"the call.  On error, B<sigset>()  returns -1, with I<errno> set to indicate "
"the error.  (But see BUGS below.)"
msgstr ""
"B<sigset>()  は成功すると、 呼び出し前に I<sig> がブロックされていた場合には "
"B<SIG_HOLD> を返し、 ブロックされていなかった場合には 変更前のそのシグナルの"
"動作を返す。 エラーの場合、 B<sigset>()  は -1 を返し、 I<errno> にエラーを示"
"す値をセットする。 但し、以下の「バグ」の節も参照のこと。"

#. type: Plain text
#: build/C/man3/sigset.3:152
msgid ""
"The B<sighold>(), B<sigrelse>(), and B<sigignore>()  functions return 0 on "
"success; on error, these functions return -1 and set I<errno> to indicate "
"the error."
msgstr ""
"関数 B<sighold>(), B<sigrelse>(), B<sigignore>()  は成功すると 0 を返す。エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sigset.3:159
msgid ""
"For B<sigset>()  see the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr ""
"B<sigset>()  に関しては、 B<sigaction>(2)  と B<sigprocmask>(2)  の「エラー」"
"の節を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:166
msgid ""
"For B<sighold>()  and B<sigrelse>()  see the ERRORS under B<sigprocmask>(2)."
msgstr ""
"B<sighold>()  と B<sigrelse>()  に関しては、 B<sigprocmask>(2)  の「エラー」"
"の節を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:171
msgid "For B<sigignore>(), see the errors under B<sigaction>(2)."
msgstr "B<sigignore>()  に関しては、 B<sigaction>(2)  の「エラー」の節を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:188
msgid ""
"SVr4, POSIX.1-2001.  These functions are obsolete: do not use them in new "
"programs.  POSIX.1-2008 marks B<sighold>(), B<sigignore>(), B<sigpause>(), "
"B<sigrelse>(), and B<sigset>()  as obsolete, recommending the use of "
"B<sigaction>(2), B<sigprocmask>(2), B<pthread_sigmask>(3), and B<sigsuspend>"
"(2)  instead."
msgstr ""
"SVr4, POSIX.1-2001.  これらの関数は廃止予定である。新しいプログラムでは使用し"
"ないこと。 POSIX.1-2008 は、 B<sighold>(), B<sigignore>(), B<sigpause>(), "
"B<sigrelse>(), B<sigset>()  を廃止予定としている。 代わりに、 B<sigaction>"
"(2), B<sigprocmask>(2), B<pthread_sigmask>(3), B<sigsuspend>(2)  の使用が推奨"
"されている。"

#. type: Plain text
#: build/C/man3/sigset.3:190
msgid "These functions appeared in glibc version 2.1."
msgstr "これらの関数は glibc 2.1 で登場した。"

#. type: Plain text
#: build/C/man3/sigset.3:196
msgid ""
"The I<sighandler_t> type is a GNU extension; it is only used on this page to "
"make the B<sigset>()  prototype more easily readable."
msgstr ""
"I<sighandler_t> 型は GNU による拡張であり、この man page で B<sigset>()  のプ"
"ロトタイプをより読みやすくするために使われているだけである。"

#. type: Plain text
#: build/C/man3/sigset.3:204
msgid ""
"The B<sigset>()  function provides reliable signal handling semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to 0)."
msgstr ""
"関数 B<sigset>()  は信頼性のあるシグナル処理機構を提供する (I<sa_mask> を 0 "
"で B<sigaction>(2)  を呼び出したときと同様)。"

#. type: Plain text
#: build/C/man3/sigset.3:222
msgid ""
"On System V, the B<signal>()  function provides unreliable semantics (as "
"when calling B<sigaction>(2)  with I<sa_mask> equal to I<SA_RESETHAND | "
"SA_NODEFER>).  On BSD, B<signal>()  provides reliable semantics.  "
"POSIX.1-2001 leaves these aspects of B<signal>()  unspecified.  See B<signal>"
"(2)  for further details."
msgstr ""
"System V では、関数 B<signal>()  が提供する処理機構は信頼性のないものである "
"(I<sa_mask> を I<SA_RESETHAND | SA_NODEFER> として B<sigaction>(2)  を呼び出"
"したときと同様)。 BSD では、 B<signal>()  は信頼性のある処理機構を提供する。 "
"POSIX.1-2001 では、 B<signal>()  のこの点は規定しないままとなっている。 さら"
"なる詳細については B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:230 build/C/man3/sigvec.3:250
msgid ""
"In order to wait for a signal, BSD and System V both provided a function "
"named B<sigpause>(3), but this function has a different argument on the two "
"systems.  See B<sigpause>(3)  for details."
msgstr ""
"BSD と System V のどちらのシステムでも シグナルを待つために、 B<sigpause>"
"(3)  という名前の関数が提供されているが、 この関数の引き数は両方のシステムで"
"異なる。 詳細は B<sigpause>(3)  を参照。"

#. type: Plain text
#: build/C/man3/sigset.3:239
msgid ""
"In versions of glibc before 2.2, B<sigset>()  did not unblock I<sig> if "
"I<disp> was specified as a value other than B<SIG_HOLD>."
msgstr ""
"2.2 より前のバージョンの glibc では、 I<disp> に B<SIG_HOLD> 以外の値が指定さ"
"れた場合、 I<sig> のブロック解除を行っていなかった。"

#.  See http://sourceware.org/bugzilla/show_bug.cgi?id=1951
#. type: Plain text
#: build/C/man3/sigset.3:264
msgid ""
"In versions of glibc before 2.5, B<sigset>()  does not correctly return the "
"previous disposition of the signal in two cases.  First, if I<disp> is "
"specified as B<SIG_HOLD>, then a successful B<sigset>()  always returns "
"B<SIG_HOLD>.  Instead, it should return the previous disposition of the "
"signal (unless the signal was blocked, in which case B<SIG_HOLD> should be "
"returned).  Second, if the signal is currently blocked, then the return "
"value of a successful B<sigset>()  should be B<SIG_HOLD>.  Instead, the "
"previous disposition of the signal is returned.  These problems have been "
"fixed since glibc 2.5."
msgstr ""
"2.3.5 以前の全てのバージョンの glibc では、 B<sigset>()  が変更前のシグナルの"
"動作を正しく返さない場合が 2つある。 一つめは、 I<disp> に B<SIG_HOLD> が指定"
"されると、成功した場合 B<sigset>()  は常に B<SIG_HOLD> を返すことである。 正"
"しくは、(シグナルがブロックされていなかった場合には)  変更前のシグナルの動作"
"を返すべきである (シグナルがブロックされていた場合には、 B<SIG_HOLD> が返され"
"る)。 もう一つは、シグナルが現在ブロックされている場合には、 成功した場合の "
"B<sigset>()  の返り値は B<SIG_HOLD> になるべきであるが、実際には 変更前のシグ"
"ナルの動作が返されることである。 これらの問題は glibc 2.5 以降で修正されてい"
"る。"

#. type: Plain text
#: build/C/man3/sigset.3:274
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigvec>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/sigsetops.3:29
#, no-wrap
msgid "SIGSETOPS"
msgstr "SIGSETOPS"

#. type: TH
#: build/C/man3/sigsetops.3:29
#, no-wrap
msgid "2008-09-01"
msgstr "2008-09-01"

#. type: Plain text
#: build/C/man3/sigsetops.3:33
msgid ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX signal "
"set operations."
msgstr ""
"sigemptyset, sigfillset, sigaddset, sigdelset, sigismember - POSIX シグナル集"
"合の操作"

#. type: Plain text
#: build/C/man3/sigsetops.3:37
msgid "B<int sigemptyset(sigset_t *>I<set>B<);>"
msgstr "B<int sigemptyset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:39
msgid "B<int sigfillset(sigset_t *>I<set>B<);>"
msgstr "B<int sigfillset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:41
msgid "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigaddset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:43
msgid "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigdelset(sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:45
msgid "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"
msgstr "B<int sigismember(const sigset_t *>I<set>B<, int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:57
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"
msgstr ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>():"

#. type: Plain text
#: build/C/man3/sigsetops.3:59
msgid "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr "_POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/sigsetops.3:63
msgid "These functions allow the manipulation of POSIX signal sets."
msgstr "これらの関数は POSIX シグナル集合(signal set)を操作するため使用する。"

#. type: Plain text
#: build/C/man3/sigsetops.3:68
msgid ""
"B<sigemptyset>()  initializes the signal set given by I<set> to empty, with "
"all signals excluded from the set."
msgstr ""
"B<sigemptyset>()  は I<set> で与えられたシグナル集合を空に初期化し、シグナル"
"が一つも 含まれていない状態にする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:73
msgid "B<sigfillset>()  initializes I<set> to full, including all signals."
msgstr ""
"B<sigfillset>()  は I<set> で与えられたシグナル集合が全てのシグナルを含むよう"
"にする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:81
msgid ""
"B<sigaddset>()  and B<sigdelset>()  add and delete respectively signal "
"I<signum> from I<set>."
msgstr ""
"B<sigaddset>()  と B<sigdelset>()  は I<set> に I<signum> シグナルをそれぞれ"
"加えたり、削除したりする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:87
msgid "B<sigismember>()  tests whether I<signum> is a member of I<set>."
msgstr ""
"B<sigismember>()  は I<signum> が I<set> に含まれているかどうかをテストする。"

#. type: Plain text
#: build/C/man3/sigsetops.3:105
msgid ""
"Objects of type I<sigset_t> must be initialized by a call to either "
"B<sigemptyset>()  or B<sigfillset>()  before being passed to the functions "
"B<sigaddset>(), B<sigdelset>()  and B<sigismember>()  or the additional "
"glibc functions described below (B<sigisemptyset>(), B<sigandset>(), and "
"B<sigorset>()).  The results are undefined if this is not done."
msgstr ""
"I<sigset_t> 型のオブジェクトは、関数 B<sigaddset>(), B<sigdelset>(), "
"B<sigismember>()  や後述の glibc の追加関数 (B<sigisemptyset>(), B<sigandset>"
"(), B<sigorset>())  に渡す前に、 B<sigemptyset>()  か B<sigfillset>()  を呼び"
"出して初期化しなければならない。 初期化しなかった場合の結果は未定義である。"

#. type: Plain text
#: build/C/man3/sigsetops.3:112
msgid ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), and B<sigdelset>()  "
"return 0 on success and -1 on error."
msgstr ""
"B<sigemptyset>(), B<sigfillset>(), B<sigaddset>(), B<sigdelset>()  は成功すれ"
"ば 0 を、エラーの場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:121
msgid ""
"B<sigismember>()  returns 1 if I<signum> is a member of I<set>, 0 if "
"I<signum> is not a member, and -1 on error."
msgstr ""
"B<sigismember>()  は I<signum> が I<set> に含まれていれば 1 を返し、含まれて"
"いなければ 0 を返す。 エラーの場合は -1 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:126
msgid "I<sig> is not a valid signal."
msgstr "I<sig> が有効なシグナルではない。"

#. type: SS
#: build/C/man3/sigsetops.3:129
#, no-wrap
msgid "Glibc Notes"
msgstr "glibc での注意"

#. type: Plain text
#: build/C/man3/sigsetops.3:135
msgid ""
"If the B<_GNU_SOURCE> feature test macro is defined, then I<E<lt>signal."
"hE<gt>> exposes three other functions for manipulating signal sets."
msgstr ""
"B<_GNU_SOURCE> 機能検査マクロが定義されていると、 I<E<lt>signal.hE<gt>> でシ"
"グナル集合を操作する 3つの関数が追加で公開される。"

#. type: TP
#: build/C/man3/sigsetops.3:135
#, no-wrap
msgid "B<int sigisemptyset(sigset_t *>I<set>B<);>"
msgstr "B<int sigisemptyset(sigset_t *>I<set>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:140
msgid "returns 1 if I<set> contains no signals, and 0 otherwise."
msgstr ""
"I<set> にシグナルが一つも含まれていなければ 1 を返し、 それ以外は 0 を返す。"

#. type: TP
#: build/C/man3/sigsetops.3:140
#, no-wrap
msgid "B<int sigorset(sigset_t *>I<dest>B<, sigset_t *>I<left>B<, sigset_t *>I<right>B<);>"
msgstr "B<int sigorset(sigset_t *>I<dest>B<, sigset_t *>I<left>B<, sigset_t *>I<right>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:149
msgid "places the union of the sets I<left> and I<right> in I<dest>."
msgstr "シグナル集合 I<left> と I<left> の和集合を I<dest> に書き込む。"

#. type: TP
#: build/C/man3/sigsetops.3:149
#, no-wrap
msgid "B<int sigandset(sigset_t *>I<dest>B<, sigset_t *>I<left>B<, sigset_t *>I<right>B<);>"
msgstr "B<int sigandset(sigset_t *>I<dest>B<, sigset_t *>I<left>B<, sigset_t *>I<right>B<);>"

#. type: Plain text
#: build/C/man3/sigsetops.3:158
msgid "places the intersection of the sets I<left> and I<right> in I<dest>."
msgstr "シグナル集合 I<left> と I<left> の積集合を I<dest> に書き込む。"

#. type: Plain text
#: build/C/man3/sigsetops.3:163
msgid ""
"B<sigorset>()  and B<sigandset>()  return 0 on success, and -1 on failure."
msgstr ""
"B<sigorset>()  と B<sigandset>()  は成功すると 0 を、失敗すると -1 を返す。"

#. type: Plain text
#: build/C/man3/sigsetops.3:166
msgid ""
"These functions are nonstandard (a few other systems provide similar "
"functions) and their use should be avoided in portable applications."
msgstr ""
"これらの関数は非標準であり、(他にも同様の関数を提供しているシステムも いくつ"
"かはあるが) 移植性を考慮したアプリケーションでは使用を避けるべき である。"

#. type: Plain text
#: build/C/man3/sigsetops.3:171
msgid "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"
msgstr "B<sigaction>(2), B<sigpending>(2), B<sigprocmask>(2), B<sigsuspend>(2)"

#. type: TH
#: build/C/man2/sigsuspend.2:27
#, no-wrap
msgid "SIGSUSPEND"
msgstr "SIGSUSPEND"

#. type: TH
#: build/C/man2/sigsuspend.2:27
#, no-wrap
msgid "2008-08-29"
msgstr "2008-08-29"

#. type: Plain text
#: build/C/man2/sigsuspend.2:30
msgid "sigsuspend - wait for a signal"
msgstr "sigsuspend - シグナルを待つ"

#. type: Plain text
#: build/C/man2/sigsuspend.2:34
msgid "B<int sigsuspend(const sigset_t *>I<mask>B<);>"
msgstr "B<int sigsuspend(const sigset_t *>I<mask>B<);>"

#. type: Plain text
#: build/C/man2/sigsuspend.2:43
msgid ""
"B<sigsuspend>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"
msgstr ""
"B<sigsuspend>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || "
"_POSIX_SOURCE"

#. type: Plain text
#: build/C/man2/sigsuspend.2:51
msgid ""
"B<sigsuspend>()  temporarily replaces the signal mask of the calling process "
"with the mask given by I<mask> and then suspends the process until delivery "
"of a signal whose action is to invoke a signal handler or to terminate a "
"process."
msgstr ""
"B<sigsuspend>()  は、呼び出し元プロセスのシグナルマスクを I<mask> で指定され"
"たマスクに一時的に置き換え、 シグナルハンドラの起動もしくはプロセスの終了がア"
"クションとして 設定されたシグナルが配送されるまで、そのプロセスを停止する。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:60
msgid ""
"If the signal terminates the process, then B<sigsuspend>()  does not "
"return.  If the signal is caught, then B<sigsuspend>()  returns after the "
"signal handler returns, and the signal mask is restored to the state before "
"the call to B<sigsuspend>()."
msgstr ""
"シグナルがプロセスを終了させるものの場合、 B<sigsuspend>()  は返らない。シグ"
"ナルが捕捉された場合、 シグナルハンドラの処理が終わった後に B<sigsuspend>()  "
"は返り、シグナルマスクは B<sigsuspend>()  が呼び出される前の状態に復元され"
"る。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:68
msgid ""
"It is not possible to block B<SIGKILL> or B<SIGSTOP>; specifying these "
"signals in I<mask>, has no effect on the process's signal mask."
msgstr ""
"B<SIGKILL> と B<SIGSTOP> を禁止 (block) することはできない; これらのシグナル"
"を I<mask> に指定しても、プロセスのシグナルマスクは影響を受けない。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:72
msgid "B<sigsuspend>()  always returns -1, normally with the error B<EINTR>."
msgstr "B<sigsuspend>()  は常に -1 を返し、通常は B<EINTR> エラーが発生する。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:77
msgid ""
"I<mask> points to memory which is not a valid part of the process address "
"space."
msgstr ""
"I<mask> が指しているメモリが、プロセスのアドレス空間の有効な部分ではない。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:80
msgid "The call was interrupted by a signal."
msgstr "システムコールはシグナルにより割り込まれた。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:100
msgid ""
"Normally, B<sigsuspend>()  is used in conjunction with B<sigprocmask>(2)  in "
"order to prevent delivery of a signal during the execution of a critical "
"code section.  The caller first blocks the signals with B<sigprocmask>(2).  "
"When the critical code has completed, the caller then waits for the signals "
"by calling B<sigsuspend>()  with the signal mask that was returned by "
"B<sigprocmask>(2)  (in the I<oldset> argument)."
msgstr ""
"B<sigsuspend>()  は、通常、クリティカル・コード・セクション (critical code "
"section) の 実行中にシグナルが配送されるのを防止するために、 B<sigprocmask>"
"(2)  と組み合わせて使用される。 まず最初に、呼び出し元は B<sigprocmask>(2)  "
"を使ってシグナルを禁止する。 クリティカル・コードが完了すると、呼び出し元は "
"B<sigprocmask>(2)  が (I<oldset> 引き数で) 返すシグナルマスクを指定して "
"B<sigsuspend>()  を呼び出すことで、クリティカル・コード実行中に発生した シグ"
"ナルを待つことができる。"

#. type: Plain text
#: build/C/man2/sigsuspend.2:114
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<sigwait>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/sigvec.3:24
#, no-wrap
msgid "SIGVEC"
msgstr "SIGVEC"

#. type: Plain text
#: build/C/man3/sigvec.3:27
msgid "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD signal API"
msgstr "sigvec, sigblock, sigsetmask, siggetmask, sigmask - BSD 版シグナル API"

#. type: Plain text
#: build/C/man3/sigvec.3:31
msgid ""
"B<int sigvec(int >I<sig>B<, struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"
msgstr ""
"B<int sigvec(int >I<sig>B<, struct sigvec *>I<vec>B<, struct sigvec "
"*>I<ovec>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:33
msgid "B<int sigmask(int >I<signum>B<);>"
msgstr "B<int sigmask(int >I<signum>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:35
msgid "B<int sigblock(int >I<mask>B<);>"
msgstr "B<int sigblock(int >I<mask>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:37
msgid "B<int sigsetmask(int >I<mask>B<);>"
msgstr "B<int sigsetmask(int >I<mask>B<);>"

#. type: Plain text
#: build/C/man3/sigvec.3:39
msgid "B<int siggetmask(void);>"
msgstr "B<int siggetmask(void);>"

#. type: Plain text
#: build/C/man3/sigvec.3:47
msgid "All functions shown above: _BSD_SOURCE"
msgstr "上記の全ての関数: _BSD_SOURCE"

#. type: Plain text
#: build/C/man3/sigvec.3:54
msgid ""
"These functions are provided in glibc as a compatibility interface for "
"programs that make use of the historical BSD signal API.  This API is "
"obsolete: new applications should use the POSIX signal API (B<sigaction>(2), "
"B<sigprocmask>(2), etc.)"
msgstr ""
"これらの関数は、昔ながらの BSD 版シグナル API を使用しているプログラム に対し"
"て互換性のあるインタフェースを glibc で提供するものである。 この API は過去の"
"ものであり、新しいアプリケーションでは POSIX シグナル API (B<sigaction>(2), "
"B<sigprocmask>(2)  など) を使用すべきである。"

#. type: Plain text
#: build/C/man3/sigvec.3:79
msgid ""
"The B<sigvec>()  function sets and/or gets the disposition of the signal "
"I<sig> (like the POSIX B<sigaction>(2)).  If I<vec> is not NULL, it points "
"to a I<sigvec> structure that defines the new disposition for I<sig>.  If "
"I<ovec> is not NULL, it points to a I<sigvec> structure that is used to "
"return the previous disposition of I<sig>.  To obtain the current "
"disposition of I<sig> without changing it, specify NULL for I<vec>, and a "
"non-NULL pointer for I<ovec>."
msgstr ""
"関数 B<sigvec>()  は、(POSIX の B<sigaction>(2)  と同様に) シグナル I<sig> の"
"動作の設定・取得を行う。 I<vec> は、NULL 以外の場合、 I<sig> の新しい動作を定"
"義した I<sigvec> 構造体へのポインタである。 I<ovec> は、NULL 以外の場合、 "
"I<sig> の変更前の動作を返すために使用される I<sigvec> 構造体へのポインタであ"
"る。 I<sig> の動作を変更せずに現在の動作を取得するためには、 I<vec> に NULL "
"を指定し、 I<ovec> に NULL でないポインタを指定すればよい。"

#. type: Plain text
#: build/C/man3/sigvec.3:89
msgid "The I<sigvec> structure has the following form:"
msgstr "I<sigvec> 構造体は以下の通りである:"

#. type: Plain text
#: build/C/man3/sigvec.3:97
#, no-wrap
msgid ""
"struct sigvec {\n"
"    void (*sv_handler)();  /* Signal disposition */\n"
"    int    sv_mask;        /* Signals to be blocked in handler */\n"
"    int    sv_flags;       /* Flags */\n"
"};\n"
msgstr ""
"struct sigvec {\n"
"    void (*sv_handler)();  /* Signal disposition */\n"
"    int    sv_mask;        /* Signals to be blocked in handler */\n"
"    int    sv_flags;       /* Flags */\n"
"};\n"

#. type: Plain text
#: build/C/man3/sigvec.3:108
msgid ""
"The I<sv_handler> field specifies the disposition of the signal, and is "
"either: the address of a signal handler function; or B<SIG_DFL> meaning the "
"default disposition applies for the signal; or B<SIG_IGN> meaning that the "
"signal is ignored."
msgstr ""
"I<sv_handler> フィールドはシグナルの動作を指定するもので、 シグナルハンドラ関"
"数のアドレスか、 B<SIG_DFL> と B<SIG_IGN> のいずれかを指定できる。 "
"B<SIG_DFL> はシグナルに適用されるデフォルトの動作を意味し、 B<SIG_IGN> はシグ"
"ナルを無視することを意味する。"

#. type: Plain text
#: build/C/man3/sigvec.3:122
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then I<sv_mask> "
"specifies a mask of signals that are to be blocked while the handler is "
"executing.  In addition, the signal for which the handler is invoked is also "
"blocked by default.  Attempts to block B<SIGKILL> or B<SIGSTOP> are silently "
"ignored."
msgstr ""
"I<sv_handler> にシグナルハンドラのアドレスを指定した場合、 I<sv_mask> はハン"
"ドラが実行中にブロックされるべきシグナルのマスクを指定する。 また、ハンドラを"
"起動したシグナル自身はデフォルトでブロックされる。 B<SIGKILL> か B<SIGSTOP> "
"をブロックしようとした場合には、黙って無視される。"

#. type: Plain text
#: build/C/man3/sigvec.3:129
msgid ""
"If I<sv_handler> specifies the address of a signal handler, then the "
"I<sv_flags> field specifies flags controlling what happens when the handler "
"is called.  This field may contain zero or more of the following flags:"
msgstr ""
"I<sv_handler> にシグナルハンドラのアドレスを指定した場合、 I<sv_flags> フィー"
"ルドはハンドラが呼ばれた際の挙動を制御するフラグを指定する。 このフィールドに"
"は、0 か、以下のフラグを 1個以上指定できる:"

#. type: TP
#: build/C/man3/sigvec.3:129
#, no-wrap
msgid "B<SV_INTERRUPT>"
msgstr "B<SV_INTERRUPT>"

#. type: Plain text
#: build/C/man3/sigvec.3:137
msgid ""
"If the signal handler interrupts a blocking system call, then upon return "
"from the handler the system call will not be restarted: instead it will fail "
"with the error B<EINTR>.  If this flag is not specified, then system calls "
"are restarted by default."
msgstr ""
"シグナルハンドラが停止中のシステムコールを中断した場合、 ハンドラから復帰して"
"も、システムコールは再開されず、 エラー B<EINTR> で失敗する。 このフラグを指"
"定しなかった場合、システムコールは デフォルトで再開される。"

#. type: TP
#: build/C/man3/sigvec.3:137
#, no-wrap
msgid "B<SV_RESETHAND>"
msgstr "B<SV_RESETHAND>"

#. type: Plain text
#: build/C/man3/sigvec.3:146
msgid ""
"Reset the disposition of the signal to the default before calling the signal "
"handler.  If this flag is not specified, then the handler remains "
"established until explicitly removed by a later call to B<sigvec>()  or "
"until the process performs an B<execve>(2)."
msgstr ""
"シグナルハンドラを呼び出す前にシグナルの動作を デフォルトにリセットする。 こ"
"のフラグを指定しなかった場合、もう一度 B<sigvec>()  を呼び出して明示的に削除"
"されるか、プロセスが B<execve>(2)  を実行するまで、ハンドラは設定されたままと"
"なる。"

#. type: TP
#: build/C/man3/sigvec.3:146
#, no-wrap
msgid "B<SV_ONSTACK>"
msgstr "B<SV_ONSTACK>"

#. type: Plain text
#: build/C/man3/sigvec.3:153
msgid ""
"Handle the signal on the alternate signal stack (historically established "
"under BSD using the obsolete B<sigstack>()  function; the POSIX replacement "
"is B<sigaltstack>(2))."
msgstr ""
"代替シグナルスタック上でシグナルハンドラを実行する (歴史的に、BSD では代替シ"
"グナルスタックは廃止された関数 B<sigstack>()  を使って設定する。POSIX では、"
"代わりに B<sigaltstack>(2)  を使用する)。"

#. type: Plain text
#: build/C/man3/sigvec.3:163
msgid ""
"The B<sigmask>()  function constructs and returns a \"signal mask\" for "
"I<signum>.  For example, we can initialize the I<vec.sv_mask> field given to "
"B<sigvec>()  using code such as the following:"
msgstr ""
"関数 B<sigmask>()  は I<signum> に対する「シグナルマスク」を構成して返す。 例"
"えば、以下のようなコードを使うと、 B<sigvec>()  に渡す I<vec.sv_mask> を初期"
"化できる。"

#. type: Plain text
#: build/C/man3/sigvec.3:168
#, no-wrap
msgid ""
"    vec.sv_mask = sigmask(SIGQUIT) | sigpause(SIGABRT);\n"
"                /* Block SIGQUIT and SIGABRT during\n"
"                   handler execution */\n"
msgstr ""
"    vec.sv_mask = sigmask(SIGQUIT) | sigpause(SIGABRT);\n"
"                /* Block SIGQUIT and SIGABRT during\n"
"                   handler execution */\n"

#. type: Plain text
#: build/C/man3/sigvec.3:183
msgid ""
"The B<sigblock>()  function adds the signals in I<mask> to the process's "
"signal mask (like POSIX I<sigprocmask(SIG_BLOCK)>), and returns the "
"process's previous signal mask.  Attempts to block B<SIGKILL> or B<SIGSTOP> "
"are silently ignored."
msgstr ""
"B<sigblock>()  関数は、 I<mask> にあるシグナルをプロセスのシグナルマスクに追"
"加し (POSIX の I<sigprocmask(SIG_BLOCK)> と同様)、変更前のプロセスのシグナル"
"マスクを返す。 B<SIGKILL> や B<SIGSTOP> をブロックしようとした場合には、黙っ"
"て無視される。"

#. type: Plain text
#: build/C/man3/sigvec.3:191
msgid ""
"The B<sigsetmask>()  function sets the process's signal mask to the value "
"given in I<mask> (like POSIX I<sigprocmask(SIG_SETMASK)>), and returns the "
"process's previous signal mask."
msgstr ""
"B<sigsetmask>()  関数はプロセスのシグナルマスクを I<mask> で指定された値に設"
"定し (POSIX の I<sigprocmask(SIG_SETMASK)> と同様)、変更前のプロセスのシグナ"
"ルマスクを返す。"

#. type: Plain text
#: build/C/man3/sigvec.3:197
msgid ""
"The B<siggetmask>()  function returns the process's current signal mask.  "
"This call is equivalent to I<sigblock(0)>."
msgstr ""
"B<siggetmask>()  関数はプロセスの現在のシグナルマスクを返す。この関数は "
"I<sigblock(0)> と等価である。"

#. type: Plain text
#: build/C/man3/sigvec.3:203
msgid ""
"The B<sigvec>()  function returns 0 on success; on error, it returns -1 and "
"sets I<errno> to indicate the error."
msgstr ""
"B<sigvec>()  関数は成功すると 0 を返す。エラーの場合、-1 を返し、 I<errno> に"
"エラーを示す値をセットする。"

#. type: Plain text
#: build/C/man3/sigvec.3:209
msgid ""
"The B<sigblock>()  and B<sigsetmask>()  functions return the previous signal "
"mask."
msgstr "B<sigblock>()  と B<sigsetmask>()  は変更前のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man3/sigvec.3:214
msgid "The B<sigmask>()  function returns the signal mask for I<signum>."
msgstr "B<sigmask>()  関数は I<signum> のシグナルマスクを返す。"

#. type: Plain text
#: build/C/man3/sigvec.3:219
msgid "See the ERRORS under B<sigaction>(2)  and B<sigprocmask>(2)."
msgstr "B<sigaction>(2)  と B<sigprocmask>(2)  の「エラー」の節を参照。"

#. type: Plain text
#: build/C/man3/sigvec.3:225
msgid ""
"All of these functions were in 4.3BSD, except B<siggetmask>(), whose origin "
"is unclear.  These functions are obsolete: do not use them in new programs."
msgstr ""
"これらの関数のうち B<siggetmask>()  以外の全ては 4.3BSD にあった。 "
"B<siggetmask>()  の出自ははっきりしない。 これらの関数は廃止予定であり、新し"
"いプログラムでは使用しないこと。"

#. type: Plain text
#: build/C/man3/sigvec.3:242
msgid ""
"On 4.3BSD, the B<signal>()  function provided reliable semantics (as when "
"calling B<sigvec>()  with I<vec.sv_mask> equal to 0).  On System V, B<signal>"
"()  provides unreliable semantics.  POSIX.1-2001 leaves these aspects of "
"B<signal>()  unspecified.  See B<signal>(2)  for further details."
msgstr ""
"4.3BSD では、信頼性のあるシグナル処理機構を提供する (I<vec.sv_mask> を 0 で "
"B<sigvec>()  を呼び出したときと同様)。 System V が提供する処理機構は信頼性の"
"ないものである。 POSIX.1-2001 では、 B<signal>()  のこの点は規定しないままと"
"なっている。 さらなる詳細については B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/sigvec.3:260
msgid ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"
msgstr ""
"B<kill>(2), B<pause>(2), B<sigaction>(2), B<signal>(2), B<sigprocmask>(2), "
"B<raise>(3), B<sigpause>(3), B<sigset>(3), B<signal>(7)"

#. type: TH
#: build/C/man3/sigwait.3:24
#, no-wrap
msgid "SIGWAIT"
msgstr "SIGWAIT"

#. type: TH
#: build/C/man3/sigwait.3:24
#, no-wrap
msgid "2010-09-10"
msgstr "2010-09-10"

#. type: Plain text
#: build/C/man3/sigwait.3:27
msgid "sigwait - wait for a signal"
msgstr "sigwait - シグナルを待つ"

#. type: Plain text
#: build/C/man3/sigwait.3:32
#, no-wrap
msgid "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"
msgstr "B< int sigwait(const sigset_t *>I<set>B<, int *>I<sig>B<);>\n"

#. type: Plain text
#: build/C/man3/sigwait.3:42
msgid ""
"B<sigwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"
msgstr ""
"B<sigwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 1 || _XOPEN_SOURCE || _POSIX_SOURCE"

#. type: Plain text
#: build/C/man3/sigwait.3:53
msgid ""
"The B<sigwait>()  function suspends execution of the calling thread until "
"the delivery of one of the signals specified in the signal set I<set>.  The "
"function accepts the signal (removes it from the pending list of signals), "
"and returns the signal number in I<sig>."
msgstr ""
"B<sigwait>()  関数は、シグナル集合 I<set> で指定されたシグナルの一つが配送さ"
"れるまで、 呼び出したスレッドの実行を中断する。 この関数はそのシグナルを受け"
"取り (つまり、処理待ちのシグナルのリスト からそのシグナルを削除し)、そのシグ"
"ナル番号を I<sig> に格納して返す。"

#. type: Plain text
#: build/C/man3/sigwait.3:59
msgid ""
"The operation of B<sigwait>()  is the same as B<sigwaitinfo>(2), except that:"
msgstr ""
"B<sigwait>()  の動作は B<sigwaitinfo>(2)  と同じだが、以下の点が異なる。"

#. type: Plain text
#: build/C/man3/sigwait.3:64
msgid ""
"B<sigwait>()  only returns the signal number, rather than a I<siginfo_t> "
"structure describing the signal."
msgstr ""
"B<sigwait>()  は、シグナルの内容を表す I<siginfo_t> 構造体を返すのではなく、"
"単にシグナル番号を返す。"

#. type: Plain text
#: build/C/man3/sigwait.3:66
msgid "The return values of the two functions are different."
msgstr "返り値が B<sigwaitinfo>(2)  とは異なる。"

#. type: Plain text
#: build/C/man3/sigwait.3:71
msgid ""
"On success, B<sigwait>()  returns 0.  On error, it returns a positive error "
"number (listed in ERRORS)."
msgstr ""
"成功すると、 B<sigwait>()  は 0 を返す。 エラーの場合、(「エラー」の節のリス"
"トにある) 正のエラー番号を返す。"

#.  Does not occur for glibc.
#. type: Plain text
#: build/C/man3/sigwait.3:77
msgid "I<set> contains an invalid signal number."
msgstr "I<set> に無効なシグナル番号が入っている。"

#. type: Plain text
#: build/C/man3/sigwait.3:83
msgid "B<sigwait>()  is implemented using B<sigtimedwait>(2)."
msgstr "B<sigwait>()  は B<sigtimedwait>(2)  を使って実装されている。"

#. type: Plain text
#: build/C/man3/sigwait.3:86
msgid "See B<pthread_sigmask>(3)."
msgstr "B<pthread_sigmask>(3)  を参照。"

#. type: Plain text
#: build/C/man3/sigwait.3:94
msgid ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"
msgstr ""
"B<sigaction>(2), B<signalfd>(2), B<sigpending>(2), B<sigsuspend>(2), "
"B<sigwaitinfo>(2), B<sigsetops>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/sigwaitinfo.2:23
#, no-wrap
msgid "SIGWAITINFO"
msgstr "SIGWAITINFO"

#. type: TH
#: build/C/man2/sigwaitinfo.2:23
#, no-wrap
msgid "2012-05-02"
msgstr "2012-05-02"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:26
msgid "sigwaitinfo, sigtimedwait - synchronously wait for queued signals"
msgstr "sigwaitinfo, sigtimedwait - キューに入れられたシグナルを同期して待つ"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:31
#, no-wrap
msgid "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"
msgstr "B<int sigwaitinfo(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<);>\n"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:34
#, no-wrap
msgid ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"
msgstr ""
"B<int sigtimedwait(const sigset_t *>I<set>B<, siginfo_t *>I<info>B<, >\n"
"B<                 const struct timespec *>I<timeout>B<);>\n"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:44
msgid "B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""
"B<sigwaitinfo>(), B<sigtimedwait>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:54
msgid ""
"B<sigwaitinfo>()  suspends execution of the calling thread until one of the "
"signals in I<set> is delivered.  (If one of the signals in I<set> is already "
"pending for the calling thread, B<sigwaitinfo>()  will return immediately "
"with information about that signal.)"
msgstr ""
"B<sigwaitinfo>()  は I<set> のうちのどれかのシグナルが配送されるまで、 呼び出"
"しスレッドの実行を一時停止する (呼び出しスレッドに対して I<set> のうちのどれ"
"かのシグナルが既に待機中 (pending) である場合、 B<sigwaitinfo>()  はそのシグ"
"ナルの情報を返してすぐに戻る)。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:66
msgid ""
"B<sigwaitinfo>()  removes the delivered signal from the set of pending "
"signals and returns the signal number as its function result.  If the "
"I<info> argument is not NULL, then it returns a structure of type "
"I<siginfo_t> (see B<sigaction>(2))  containing information about the signal."
msgstr ""
"B<sigwaitinfo>()  は配送されたシグナルを待機中のシグナルの集合から削除し、 関"
"数の結果としてシグナル番号を返す。 I<info> 引き数が NULL でない場合、配送され"
"たシグナルの情報が入った I<siginfo_t> 型 (B<sigaction>(2)  を参照) の構造体を"
"返す。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:72
msgid ""
"Signals returned via B<sigwaitinfo>()  are delivered in the usual order; see "
"B<signal>(7)  for further details."
msgstr ""
"B<sigwaitinfo>()  で返されるシグナルは、通常の順番で配送される。 詳細は "
"B<signal>(7)  を参照すること。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:84
msgid ""
"B<sigtimedwait>()  operates in exactly the same way as B<sigwaitinfo>()  "
"except that it has an additional argument, I<timeout>, which specifies a "
"minimum interval for which the thread is suspended waiting for a signal.  "
"(This interval will be rounded up to the system clock granularity, and "
"kernel scheduling delays mean that the interval may overrun by a small "
"amount.)  This argument is of the following type:"
msgstr ""
"B<sigtimedwait>() は、 B<sigwaitinfo>() と次の点を除いて全く同じように\n"
"動作する。この関数にはもう 1 つの引き数 I<timeout> があり、シグナル待ち\n"
"でスレッドが一時停止する最小時間を指定することができる(この時間はシステ\n"
"ムクロックの粒度に切り上げられ、カーネルのスケジューリング遅延により\n"
"少しだけ長くなる可能性がある)。この引き数の型は以下のとおりである:"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:91
#, no-wrap
msgid ""
"struct timespec {\n"
"    long    tv_sec;         /* seconds */\n"
"    long    tv_nsec;        /* nanoseconds */\n"
"}\n"
msgstr ""
"struct timespec {\n"
"    long    tv_sec;         /* 秒 */\n"
"    long    tv_nsec;        /* ナノ秒 */\n"
"}\n"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:101
msgid ""
"If both fields of this structure are specified as 0, a poll is performed: "
"B<sigtimedwait>()  returns immediately, either with information about a "
"signal that was pending for the caller, or with an error if none of the "
"signals in I<set> was pending."
msgstr ""
"この構造体の 2 つのフィールドがともに 0 の場合、ポーリングが行われる: "
"B<sigtimedwait>()  は、呼び出し側プロセスに対して 待機しているシグナルの情報"
"を返して戻るか、 I<set> のうちのどのシグナルも待機していない場合はエラーを返"
"して戻る。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:110
msgid ""
"On success, both B<sigwaitinfo>()  and B<sigtimedwait>()  return a signal "
"number (i.e., a value greater than zero).  On failure both calls return -1, "
"with I<errno> set to indicate the error."
msgstr ""
"成功した場合、 B<sigwaitinfo>()  と B<sigtimedwait>()  はシグナル番号 (すなわ"
"ち 0 より大きい数) を返す。 失敗した場合、2 つの関数は -1 を返し、 I<errno> "
"はエラーを表す値に設定される。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:119
msgid ""
"No signal in I<set> was delivered within the I<timeout> period specified to "
"B<sigtimedwait>()."
msgstr ""
"I<set> のうちのどのシグナルも B<sigtimedwait>()  に指定された I<timeout> の期"
"間内に配送されなかった。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:125
msgid ""
"The wait was interrupted by a signal handler; see B<signal>(7).  (This "
"handler was for a signal other than one of those in I<set>.)"
msgstr ""
"シグナル待ちがシグナルハンドラによって中断 (interrupt) された (このハンドラ"
"は I<set> にあるシグナル以外のものである)。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:129
msgid "I<timeout> was invalid."
msgstr "I<timeout> が不正である。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:148
msgid ""
"In normal usage, the calling program blocks the signals in I<set> via a "
"prior call to B<sigprocmask>(2)  (so that the default disposition for these "
"signals does not occur if they are delivered between successive calls to "
"B<sigwaitinfo>()  or B<sigtimedwait>())  and does not establish handlers for "
"these signals.  In a multithreaded program, the signal should be blocked in "
"all threads to prevent the signal being delivered to a thread other than the "
"one calling B<sigwaitinfo>()  or B<sigtimedwait>())."
msgstr ""
"通常の使用法では、呼び出し側プロセスはこれらの関数より先に B<sigprocmask>"
"(2)  の呼び出すことにより I<set> に含まれるシグナルをブロックし (そのためにこ"
"れらのシグナルがこの後に続く B<sigwaitinfo>()  や B<sigtimedwait>()  の呼び出"
"しの間に配送された場合には、 デフォルトの配置は行われず)、 これらのシグナルに"
"対するハンドラは設定しない。 マルチスレッドプログラムでは、 B<sigwaitinfo>"
"()  や B<sigtimedwait>()  を呼び出したスレッド以外のスレッドにそのシグナルが"
"配送されないように、 全てのスレッドで該当シグナルをブロックすべきである。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:153
msgid ""
"The set of signals that is pending for a given thread is the union of the "
"set of signals that is pending specifically for that thread and the set of "
"signals that is pending for the process as a whole (see B<signal>(7))."
msgstr ""
"指定されたスレッドに対する処理待ちのシグナルの集合は、 そのスレッド自体宛ての"
"処理待ちのシグナル集合と、プロセス全体宛ての 処理待ちのシグナル集合をあわせた"
"ものである (B<signal>(7)  参照)。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:159
msgid "Attempts to wait for B<SIGKILL> and B<SIGSTOP> are silently ignored."
msgstr "B<SIGKILL> と B<SIGSTOP> を待とうとした場合、黙って無視される。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:168
msgid ""
"If multiple threads of a process are blocked waiting for the same signal(s) "
"in B<sigwaitinfo>()  or B<sigtimedwait>(), then exactly one of the threads "
"will actually receive the signal if it is delivered to the process as a "
"whole; which of the threads receives the signal is indeterminate."
msgstr ""
"一つのプロセス内の複数のスレッドが B<sigwaitinfo>()  や B<sigtimedwait>()  で"
"同じシグナルを待って停止した場合、 プロセス全体宛てのシグナルが配送されると、"
"複数のスレッドのうち一つだけが 実際にそのシグナルを受信することになる。 どの"
"スレッドがシグナルを受信するかは決まっていない。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:177
msgid ""
"POSIX leaves the meaning of a NULL value for the I<timeout> argument of "
"B<sigtimedwait>()  unspecified, permitting the possibility that this has the "
"same meaning as a call to B<sigwaitinfo>(), and indeed this is what is done "
"on Linux."
msgstr ""
"POSIX では B<sigtimedwait>()  の引き数 I<timeout> の値を NULL にした場合の意"
"味を未定義としている。 B<sigwaitinfo>()  を呼び出したのと同じ意味としてもよい"
"ことになっており、 実際 Linux ではこのように動作する。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:182
msgid ""
"On Linux, B<sigwaitinfo>()  is a library function implemented on top of "
"B<sigtimedwait>()."
msgstr ""
"Linux では、 B<sigwaitinfo>()  は B<sigtimedwait>()  を用いて実装されたライブ"
"ラリ関数である。"

#. type: Plain text
#: build/C/man2/sigwaitinfo.2:194
msgid ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), B<signal>"
"(7), B<time>(7)"
msgstr ""
"B<kill>(2), B<sigaction>(2), B<signal>(2), B<signalfd>(2), B<sigpending>(2), "
"B<sigprocmask>(2), B<sigqueue>(3), B<sigsetops>(3), B<sigwait>(3), B<signal>"
"(7), B<time>(7)"

#. type: TH
#: build/C/man3/sysv_signal.3:23
#, no-wrap
msgid "SYSV_SIGNAL"
msgstr "SYSV_SIGNAL"

#. type: TH
#: build/C/man3/sysv_signal.3:23
#, no-wrap
msgid "2007-05-04"
msgstr "2007-05-04"

#. type: Plain text
#: build/C/man3/sysv_signal.3:26
msgid "sysv_signal - signal handling with System V semantics"
msgstr "sysv_signal - System V 方式のシグナル処理"

#. type: Plain text
#: build/C/man3/sysv_signal.3:28
msgid "B<#define _GNU_SOURCE> /* See feature_test_macros(7) */"
msgstr "B<#define _GNU_SOURCE> /* feature_test_macros(7) 参照 */"

#. type: Plain text
#: build/C/man3/sysv_signal.3:34
msgid ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"
msgstr ""
"B<sighandler_t sysv_signal(int >I<signum>B<, sighandler_t >I<handler>B<);>"

#. type: Plain text
#: build/C/man3/sysv_signal.3:39
msgid ""
"The B<sysv_signal>()  function takes the same arguments, and performs the "
"same task, as B<signal>(2)."
msgstr ""
"B<sysv_signal>()  関数は B<signal>(2)  と同じ引き数をとり、同じ処理を実行す"
"る。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:49
msgid ""
"However B<sysv_signal>()  provides the System V unreliable signal semantics, "
"that is: a) the disposition of the signal is reset to the default when the "
"handler is invoked; b) delivery of further instances of the signal is not "
"blocked while the signal handler is executing; and c) if the handler "
"interrupts (certain) blocking system calls, then the system call is not "
"automatically restarted."
msgstr ""
"しかしながら、 B<sysv_signal>()  は System V の信頼性に欠けるシグナル処理方式"
"を提供している。 信頼性に欠けるシグナル処理方式は以下の特徴を持つ。 a) ハンド"
"ラが起動されると、シグナルの処理方法 (disposition) が デフォルトにリセットさ"
"れる、 b) シグナルハンドラの実行中は、それ以降に発生した同じシグナルの配送が "
"ブロックされない、 c) ハンドラが停止中の (blocking している) システムコールを"
"中断した場合、 自動的に再開されないシステムコールがある。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:55
msgid ""
"The B<sysv_signal>()  function returns the previous value of the signal "
"handler, or B<SIG_ERR> on error."
msgstr ""
"B<sysv_signal>()  関数はシグナルハンドラの直前の値を返す。 エラーの場合、 "
"B<SIG_ERR> を返す。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:60
msgid "This function is nonstandard."
msgstr "この関数は非標準である。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:66
msgid ""
"Use of B<sysv_signal>()  should be avoided; use B<sigaction>(2)  instead."
msgstr ""
"B<sysv_signal>()  の使用は避けるべきである。代わりに B<sigaction>(2)  を使う"
"こと。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:77
msgid ""
"On older Linux systems, B<sysv_signal>()  and B<signal>(2)  were "
"equivalent.  But on newer systems, B<signal>(2)  provides reliable signal "
"semantics; see B<signal>(2)  for details."
msgstr ""
"以前の Linux システムでは、 B<sysv_signal>()  と B<signal>(2)  は等価であっ"
"た。しかし、新しめのシステムでは、 B<signal>(2)  は信頼性のあるシグナル処理方"
"式を提供している。 詳細は B<signal>(2)  を参照。"

#. type: Plain text
#: build/C/man3/sysv_signal.3:90
msgid "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"
msgstr "B<sigaction>(2), B<signal>(2), B<bsd_signal>(3), B<signal>(7)"

#. type: TH
#: build/C/man2/timer_create.2:29
#, no-wrap
msgid "TIMER_CREATE"
msgstr "TIMER_CREATE"

#. type: TH
#: build/C/man2/timer_create.2:29
#, no-wrap
msgid "2010-09-27"
msgstr "2010-09-27"

#. type: Plain text
#: build/C/man2/timer_create.2:32
msgid "timer_create - create a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:36
#, no-wrap
msgid ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"
msgstr ""
"B<#include E<lt>signal.hE<gt>>\n"
"B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/timer_create.2:39
#, no-wrap
msgid ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"
msgstr ""
"B<int timer_create(clockid_t >I<clockid>B<, struct sigevent *>I<sevp>B<,>\n"
"B<                 timer_t *>I<timerid>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_create.2:42 build/C/man2/timer_delete.2:34
#: build/C/man2/timer_getoverrun.2:34 build/C/man2/timer_settime.2:38
msgid "Link with I<-lrt>."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:50
msgid "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<timer_create>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_create.2:58
msgid ""
"B<timer_create>()  creates a new per-process interval timer.  The ID of the "
"new timer is returned in the buffer pointed to by I<timerid>, which must be "
"a non-NULL pointer.  This ID is unique within the process, until the timer "
"is deleted.  The new timer is initially disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:63
msgid ""
"The I<clockid> argument specifies the clock that the new timer uses to "
"measure time.  It can be specified as one of the following values:"
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:63
#, no-wrap
msgid "B<CLOCK_REALTIME>"
msgstr "B<CLOCK_REALTIME>"

#. type: Plain text
#: build/C/man2/timer_create.2:66
msgid "A settable system-wide real-time clock."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:66
#, no-wrap
msgid "B<CLOCK_MONOTONIC>"
msgstr "B<CLOCK_MONOTONIC>"

#.  Note: the CLOCK_MONOTONIC_RAW clock added for clock_gettime()
#.  in 2.6.28 is not supported for POSIX timers -- mtk, Feb 2009
#. type: Plain text
#: build/C/man2/timer_create.2:73
msgid ""
"A nonsettable monotonically increasing clock that measures time from some "
"unspecified point in the past that does not change after system startup."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:73
#, no-wrap
msgid "B<CLOCK_PROCESS_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:77
msgid ""
"A clock that measures (user and system) CPU time consumed by (all of the "
"threads in) the calling process."
msgstr ""

#. type: TP
#: build/C/man2/timer_create.2:77
#, no-wrap
msgid "B<CLOCK_THREAD_CPUTIME_ID> (since Linux 2.6.12)"
msgstr ""

#.  The CLOCK_MONOTONIC_RAW that was added in 2.6.28 can't be used
#.  to create a timer -- mtk, Feb 2009
#. type: Plain text
#: build/C/man2/timer_create.2:83
msgid ""
"A clock that measures (user and system) CPU time consumed by the calling "
"thread."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:92
msgid ""
"As well as the above values, I<clockid> can be specified as the I<clockid> "
"returned by a call to B<clock_getcpuclockid>(3)  or B<pthread_getcpuclockid>"
"(3)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:101
msgid ""
"The I<sevp> argument points to a I<sigevent> structure that specifies how "
"the caller should be notified when the timer expires.  For the definition "
"and general details of this structure, see B<sigevent>(7)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:105
msgid "The I<sevp.sigev_notify> field can have the following values:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:110
msgid ""
"Don't asynchronously notify when the timer expires.  Progress of the timer "
"can be monitored using B<timer_gettime>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:128
msgid ""
"Upon timer expiration, generate the signal I<sigev_signo> for the process.  "
"See B<sigevent>(7)  for general details.  The I<si_code> field of the "
"I<siginfo_t> structure will be set to B<SI_TIMER>.  At any point in time, at "
"most one signal is queued to the process for a given timer; see "
"B<timer_getoverrun>(2)  for more details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:136
msgid ""
"Upon timer expiration, invoke I<sigev_notify_function> as if it were the "
"start function of a new thread.  See B<sigevent>(7)  for details."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:150
msgid ""
"As for B<SIGEV_SIGNAL>, but the signal is targeted at the thread whose ID is "
"given in I<sigev_notify_thread_id>, which must be a thread in the same "
"process as the caller.  The I<sigev_notify_thread_id> field specifies a "
"kernel thread ID, that is, the value returned by B<clone>(2)  or B<gettid>"
"(2).  This flag is only intended for use by threading libraries."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:165
msgid ""
"Specifying I<sevp> as NULL is equivalent to specifying a pointer to a "
"I<sigevent> structure in which I<sigev_notify> is B<SIGEV_SIGNAL>, "
"I<sigev_signo> is B<SIGALRM>, and I<sigev_value.sival_int> is the timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:173
msgid ""
"On success, B<timer_create>()  returns 0, and the ID of the new timer is "
"placed in I<*timerid>.  On failure, -1 is returned, and I<errno> is set to "
"indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:177
msgid "Temporary error during kernel allocation of timer structures."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:185
msgid ""
"Clock ID, I<sigev_notify>, I<sigev_signo>, or I<sigev_notify_thread_id> is "
"invalid."
msgstr ""

#.  glibc layer: malloc()
#. type: Plain text
#: build/C/man2/timer_create.2:189
msgid "Could not allocate memory."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:191 build/C/man2/timer_delete.2:64
#: build/C/man2/timer_getoverrun.2:94
msgid "This system call is available since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:196
msgid "A program may create multiple interval timers using B<timer_create>()."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:201
msgid ""
"Timers are not inherited by the child of a B<fork>(2), and are disarmed and "
"deleted during an B<execve>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:209
msgid ""
"The kernel preallocates a \"queued real-time signal\" for each timer created "
"using B<timer_create>().  Consequently, the number of timers is limited by "
"the B<RLIMIT_SIGPENDING> resource limit (see B<setrlimit>(2))."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:214
msgid ""
"The timers created by B<timer_create>()  are commonly known as \"POSIX "
"(interval) timers\".  The POSIX timers API consists of the following "
"interfaces:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:217
msgid "B<timer_create>(): Create a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:220
msgid "B<timer_settime>(2): Arm (start) or disarm (stop) a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:224
msgid ""
"B<timer_gettime>(2): Fetch the time remaining until the next expiration of a "
"timer, along with the interval setting of the timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:227
msgid ""
"B<timer_getoverrun>(2): Return the overrun count for the last timer "
"expiration."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:230
msgid "B<timer_delete>(2): Disarm and delete a timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:233
msgid ""
"Part of the implementation of the POSIX timers API is provided by glibc.  In "
"particular:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:237
msgid ""
"The functionality for B<SIGEV_THREAD> is implemented within glibc, rather "
"than the kernel."
msgstr ""

#.  See the glibc source file kernel-posix-timers.h for the structure
#.  that glibc uses to map userspace timer IDs to kernel timer IDs
#.  The kernel-level timer ID is exposed via siginfo.si_tid.
#. type: Plain text
#: build/C/man2/timer_create.2:243
msgid ""
"The timer IDs presented at user level are maintained by glibc, which maps "
"these IDs to the timer IDs employed by the kernel."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:251
msgid ""
"The POSIX timers system calls first appeared in Linux 2.6.  Prior to this, "
"glibc provided an incomplete userspace implementation (B<CLOCK_REALTIME> "
"timers only) using POSIX threads, and current glibc falls back to this "
"implementation on systems running pre-2.6 Linux kernels."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:263
msgid ""
"The program below takes two arguments: a sleep period in seconds, and a "
"timer frequency in nanoseconds.  The program establishes a handler for the "
"signal it uses for the timer, blocks that signal, creates and arms a timer "
"that expires with the given frequency, sleeps for the specified number of "
"seconds, and then unblocks the timer signal.  Assuming that the timer "
"expired at least once while the program slept, the signal handler will be "
"invoked, and the handler displays some information about the timer "
"notification.  The program terminates after one invocation of the signal "
"handler."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:268
msgid ""
"In the following example run, the program sleeps for 1 second, after "
"creating a timer that has a frequency of 100 nanoseconds.  By the time the "
"signal is unblocked and delivered, there have been around ten million "
"overruns."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:280
#, no-wrap
msgid ""
"$ B<./a.out 1 100>\n"
"Establishing handler for signal 34\n"
"Blocking signal 34\n"
"timer ID is 0x804c008\n"
"Sleeping for 1 seconds\n"
"Unblocking signal 34\n"
"Caught signal 34\n"
"    sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008\n"
"    overrun count = 10004886\n"
msgstr ""

#. type: SS
#: build/C/man2/timer_create.2:282
#, no-wrap
msgid "Program Source"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_create.2:290
#, no-wrap
msgid ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
msgstr ""
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>signal.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"

#. type: Plain text
#: build/C/man2/timer_create.2:293
#, no-wrap
msgid ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"
msgstr ""
"#define CLOCKID CLOCK_REALTIME\n"
"#define SIG SIGRTMIN\n"

#. type: Plain text
#: build/C/man2/timer_create.2:296
#, no-wrap
msgid ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"
msgstr ""
"#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\e\n"
"                        } while (0)\n"

#. type: Plain text
#: build/C/man2/timer_create.2:302
#, no-wrap
msgid ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"
msgstr ""
"static void\n"
"print_siginfo(siginfo_t *si)\n"
"{\n"
"    timer_t *tidp;\n"
"    int or;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:304
#, no-wrap
msgid "    tidp = si-E<gt>si_value.sival_ptr;\n"
msgstr "    tidp = si-E<gt>si_value.sival_ptr;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:307
#, no-wrap
msgid ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = 0x%lx\\en\", (long) *tidp);\n"
msgstr ""
"    printf(\"    sival_ptr = %p; \", si-E<gt>si_value.sival_ptr);\n"
"    printf(\"    *sival_ptr = 0x%lx\\en\", (long) *tidp);\n"

#. type: Plain text
#: build/C/man2/timer_create.2:314
#, no-wrap
msgid ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"
msgstr ""
"    or = timer_getoverrun(*tidp);\n"
"    if (or == -1)\n"
"        errExit(\"timer_getoverrun\");\n"
"    else\n"
"        printf(\"    overrun count = %d\\en\", or);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timer_create.2:321
#, no-wrap
msgid ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not\n"
"       strictly correct, since printf() is not async-signal-safe;\n"
"       see signal(7) */\n"
msgstr ""
"static void\n"
"handler(int sig, siginfo_t *si, void *uc)\n"
"{\n"
"    /* Note: calling printf() from a signal handler is not\n"
"       strictly correct, since printf() is not async-signal-safe;\n"
"       see signal(7) */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:326
#, no-wrap
msgid ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"
msgstr ""
"    printf(\"Caught signal %d\\en\", sig);\n"
"    print_siginfo(si);\n"
"    signal(sig, SIG_IGN);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timer_create.2:336
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    timer_t timerid;\n"
"    struct sigevent sev;\n"
"    struct itimerspec its;\n"
"    long long freq_nanosecs;\n"
"    sigset_t mask;\n"
"    struct sigaction sa;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:342
#, no-wrap
msgid ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if (argc != 3) {\n"
"        fprintf(stderr, \"Usage: %s E<lt>sleep-secsE<gt> E<lt>freq-nanosecsE<gt>\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timer_create.2:344
#, no-wrap
msgid "    /* Establish handler for timer signal */\n"
msgstr "    /* Establish handler for timer signal */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:351
#, no-wrap
msgid ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"
msgstr ""
"    printf(\"Establishing handler for signal %d\\en\", SIG);\n"
"    sa.sa_flags = SA_SIGINFO;\n"
"    sa.sa_sigaction = handler;\n"
"    sigemptyset(&sa.sa_mask);\n"
"    if (sigaction(SIG, &sa, NULL) == -1)\n"
"        errExit(\"sigaction\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:353
#, no-wrap
msgid "    /* Block timer signal temporarily */\n"
msgstr "    /* Block timer signal temporarily */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:359
#, no-wrap
msgid ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""
"    printf(\"Blocking signal %d\\en\", SIG);\n"
"    sigemptyset(&mask);\n"
"    sigaddset(&mask, SIG);\n"
"    if (sigprocmask(SIG_SETMASK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:361
#, no-wrap
msgid "    /* Create the timer */\n"
msgstr "    /* Create the timer */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:367
#, no-wrap
msgid ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"
msgstr ""
"    sev.sigev_notify = SIGEV_SIGNAL;\n"
"    sev.sigev_signo = SIG;\n"
"    sev.sigev_value.sival_ptr = &timerid;\n"
"    if (timer_create(CLOCKID, &sev, &timerid) == -1)\n"
"        errExit(\"timer_create\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:369
#, no-wrap
msgid "    printf(\"timer ID is 0x%lx\\en\", (long) timerid);\n"
msgstr "    printf(\"timer ID is 0x%lx\\en\", (long) timerid);\n"

#. type: Plain text
#: build/C/man2/timer_create.2:371
#, no-wrap
msgid "    /* Start the timer */\n"
msgstr "    /* Start the timer */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:377
#, no-wrap
msgid ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"
msgstr ""
"    freq_nanosecs = atoll(argv[2]);\n"
"    its.it_value.tv_sec = freq_nanosecs / 1000000000;\n"
"    its.it_value.tv_nsec = freq_nanosecs % 1000000000;\n"
"    its.it_interval.tv_sec = its.it_value.tv_sec;\n"
"    its.it_interval.tv_nsec = its.it_value.tv_nsec;\n"

#. type: Plain text
#: build/C/man2/timer_create.2:380
#, no-wrap
msgid ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"
msgstr ""
"    if (timer_settime(timerid, 0, &its, NULL) == -1)\n"
"         errExit(\"timer_settime\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:383
#, no-wrap
msgid ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"
msgstr ""
"    /* Sleep for a while; meanwhile, the timer may expire\n"
"       multiple times */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:386
#, no-wrap
msgid ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"
msgstr ""
"    printf(\"Sleeping for %d seconds\\en\", atoi(argv[1]));\n"
"    sleep(atoi(argv[1]));\n"

#. type: Plain text
#: build/C/man2/timer_create.2:389
#, no-wrap
msgid ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"
msgstr ""
"    /* Unlock the timer signal, so that timer notification\n"
"       can be delivered */\n"

#. type: Plain text
#: build/C/man2/timer_create.2:393
#, no-wrap
msgid ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"
msgstr ""
"    printf(\"Unblocking signal %d\\en\", SIG);\n"
"    if (sigprocmask(SIG_UNBLOCK, &mask, NULL) == -1)\n"
"        errExit(\"sigprocmask\");\n"

#. type: Plain text
#: build/C/man2/timer_create.2:396 build/C/man2/timerfd_create.2:533
#, no-wrap
msgid ""
"    exit(EXIT_SUCCESS);\n"
"}\n"
msgstr ""
"    exit(EXIT_SUCCESS);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timer_create.2:410
msgid ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), B<timer_getoverrun>"
"(2), B<timer_settime>(2), B<timerfd_create>(2), B<clock_getcpuclockid>(3), "
"B<pthread_getcpuclockid>(3), B<pthreads>(7), B<sigevent>(7), B<signal>(7), "
"B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<setitimer>(2), B<timer_delete>(2), B<timer_getoverrun>"
"(2), B<timer_settime>(2), B<timerfd_create>(2), B<clock_getcpuclockid>(3), "
"B<pthread_getcpuclockid>(3), B<pthreads>(7), B<sigevent>(7), B<signal>(7), "
"B<time>(7)"

#. type: TH
#: build/C/man2/timer_delete.2:23
#, no-wrap
msgid "TIMER_DELETE"
msgstr "TIMER_DELETE"

#. type: TH
#: build/C/man2/timer_delete.2:23 build/C/man2/timer_getoverrun.2:23
#: build/C/man2/timer_settime.2:23
#, no-wrap
msgid "2009-02-20"
msgstr "2009-02-20"

#. type: Plain text
#: build/C/man2/timer_delete.2:26
msgid "timer_delete - delete a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:29 build/C/man2/timer_getoverrun.2:29
#: build/C/man2/timer_settime.2:30
#, no-wrap
msgid "B<#include E<lt>time.hE<gt>>\n"
msgstr "B<#include E<lt>time.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/timer_delete.2:31
#, no-wrap
msgid "B<int timer_delete(timer_t >I<timerid>B<);>\n"
msgstr "B<int timer_delete(timer_t >I<timerid>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_delete.2:42
msgid "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<timer_delete>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_delete.2:50
msgid ""
"B<timer_delete>()  deletes the timer whose ID is given in I<timerid>.  If "
"the timer was armed at the time of this call, it is disarmed before being "
"deleted.  The treatment of any pending signal generated by the deleted timer "
"is unspecified."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:57
msgid ""
"On success, B<timer_delete>()  returns 0.  On failure, -1 is returned, and "
"I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:62 build/C/man2/timer_getoverrun.2:92
msgid "I<timerid> is not a valid timer ID."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_delete.2:72
msgid ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<timer_create>(2), B<timer_getoverrun>(2), "
"B<timer_settime>(2), B<time>(7)"

#. type: TH
#: build/C/man2/timer_getoverrun.2:23
#, no-wrap
msgid "TIMER_GETOVERRUN"
msgstr "TIMER_GETOVERRUN"

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:26
msgid "timer_getoverrun - get overrun count for a POSIX per-process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:31
#, no-wrap
msgid "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"
msgstr "B<int timer_getoverrun(timer_t >I<timerid>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:42
msgid "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr "B<timer_getoverrun>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:53
msgid ""
"B<timer_getoverrun>()  returns the \"overrun count\" for the timer referred "
"to by I<timerid>.  An application can use the overrun count to accurately "
"calculate the number of timer expirations that would have occurred over a "
"given time interval.  Timer overruns can occur both when receiving "
"expiration notifications via signals (B<SIGEV_SIGNAL>), and via threads "
"(B<SIGEV_THREAD>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:73
msgid ""
"When expiration notifications are delivered via a signal, overruns can occur "
"as follows.  Regardless of whether or not a real-time signal is used for "
"timer notifications, the system queues at most one signal per timer.  (This "
"is the behavior specified by POSIX.1-2001.  The alternative, queuing one "
"signal for each timer expiration, could easily result in overflowing the "
"allowed limits for queued signals on the system.)  Because of system "
"scheduling delays, or because the signal may be temporarily blocked, there "
"can be a delay between the time when the notification signal is generated "
"and the time when it is delivered (e.g., caught by a signal handler) or "
"accepted (e.g., using B<sigwaitinfo>(2)).  In this interval, further timer "
"expirations may occur.  The timer overrun count is the number of additional "
"timer expirations that occurred between the time when the signal was "
"generated and when it was delivered or accepted."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:79
msgid ""
"Timer overruns can also occur when expiration notifications are delivered "
"via invocation of a thread, since there may be an arbitrary delay between an "
"expiration of the timer and the invocation of the notification thread, and "
"in that delay interval, additional timer expirations may occur"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:87
msgid ""
"On success, B<timer_getoverrun>()  returns the overrun count of the "
"specified timer; this count may be 0 if no overruns have occurred.  On "
"failure, -1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:108
msgid ""
"When timer notifications are delivered via signals (B<SIGEV_SIGNAL>), on "
"Linux it is also possible to obtain the overrun count via the I<si_overrun> "
"field of the I<siginfo_t> structure (see B<sigaction>(2)).  This allows an "
"application to avoid the overhead of making a system call to obtain the "
"overrun count, but is a nonportable extension to POSIX.1-2001."
msgstr ""

#.  FIXME . Austin bug filed, 11 Feb 09
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:112
msgid ""
"POSIX.1-2001 only discusses timer overruns in the context of timer "
"notifications using signals."
msgstr ""

#.  Bug filed: http://bugzilla.kernel.org/show_bug.cgi?id=12665
#.  http://thread.gmane.org/gmane.linux.kernel/113276/
#. type: Plain text
#: build/C/man2/timer_getoverrun.2:125
msgid ""
"POSIX.1-2001 specifies that if the timer overrun count is equal to or "
"greater than an implementation-defined maximum, B<DELAYTIMER_MAX>, then "
"B<timer_getoverrun>()  should return B<DELAYTIMER_MAX>.  However, Linux does "
"not implement this feature: instead, if the timer overrun value exceeds the "
"maximum representable integer, the counter cycles, starting once more from "
"low values."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:128 build/C/man2/timer_settime.2:208
msgid "See B<timer_create>(2)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_getoverrun.2:138
msgid ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"
msgstr ""
"B<clock_gettime>(2), B<sigaction>(2), B<signalfd>(2), B<sigwaitinfo>(2), "
"B<timer_create>(2), B<timer_delete>(2), B<timer_settime>(2), B<signal>(7), "
"B<time>(7)"

#. type: TH
#: build/C/man2/timer_settime.2:23
#, no-wrap
msgid "TIMER_SETTIME"
msgstr "TIMER_SETTIME"

#. type: Plain text
#: build/C/man2/timer_settime.2:27
msgid ""
"timer_settime, timer_gettime - arm/disarm and fetch state of POSIX per-"
"process timer"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:35
#, no-wrap
msgid ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec * >I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr ""
"B<int timer_settime(timer_t >I<timerid>B<, int >I<flags>B<,>\n"
"B<                  const struct itimerspec *>I<new_value>B<,>\n"
"B<                  struct itimerspec * >I<old_value>B<);>\n"
"B<int timer_gettime(timer_t >I<timerid>B<, struct itimerspec *>I<curr_value>B<);>\n"

#. type: Plain text
#: build/C/man2/timer_settime.2:47
msgid ""
"B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"
msgstr ""
"B<timer_settime>(), B<timer_gettime>(): _POSIX_C_SOURCE\\ E<gt>=\\ 199309L"

#. type: Plain text
#: build/C/man2/timer_settime.2:60
msgid ""
"B<timer_settime>()  arms or disarms the timer identified by I<timerid>.  The "
"I<new_value> argument is an I<itimerspec> structure that specifies the new "
"initial value and the new interval for the timer.  The I<itimerspec> "
"structure is defined as follows:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:67 build/C/man2/timerfd_create.2:127
#, no-wrap
msgid ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"
msgstr ""
"struct timespec {\n"
"    time_t tv_sec;                /* Seconds */\n"
"    long   tv_nsec;               /* Nanoseconds */\n"
"};\n"

#. type: Plain text
#: build/C/man2/timer_settime.2:72
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Timer interval */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"

#. type: Plain text
#: build/C/man2/timer_settime.2:84
msgid ""
"Each of the substructures of the I<itimerspec> structure is a I<timespec> "
"structure that allows a time value to be specified in seconds and "
"nanoseconds.  These time values are measured according to the clock that was "
"specified when the timer was created by B<timer_create>(2)"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:98
msgid ""
"If I<new_value-E<gt>it_value> specifies a nonzero value (i.e., either "
"subfield is nonzero), then B<timer_settime>()  arms (starts) the timer, "
"setting it to initially expire at the given time.  (If the timer was already "
"armed, then the previous settings are overwritten.)  If I<new_value-"
"E<gt>it_value> specifies a zero value (i.e., both subfields are zero), then "
"the timer is disarmed."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:110
msgid ""
"The I<new_value-E<gt>it_interval> field specifies the period of the timer, "
"in seconds and nanoseconds.  If this field is nonzero, then each time that "
"an armed timer expires, the timer is reloaded from the value specified in "
"I<new_value-E<gt>it_interval>.  If I<new_value-E<gt>it_interval> specifies a "
"zero value then the timer expires just once, at the time specified by "
"I<it_value>."
msgstr ""

#.  By experiment: the overrun count is set correctly, for CLOCK_REALTIME.
#. type: Plain text
#: build/C/man2/timer_settime.2:131
msgid ""
"By default, the initial expiration time specified in I<new_value-"
"E<gt>it_value> is interpreted relative to the current time on the timer's "
"clock at the time of the call.  This can be modified by specifying "
"B<TIMER_ABSTIME> in I<flags>, in which case I<new_value-E<gt>it_value> is "
"interpreted as an absolute value as measured on the timer's clock; that is, "
"the timer will expire when the clock value reaches the value specified by "
"I<new_value-E<gt>it_value>.  If the specified absolute time has already "
"passed, then the timer expires immediately, and the overrun count (see "
"B<timer_getoverrun>(2))  will be set correctly."
msgstr ""

#.  Similar remarks might apply with respect to process and thread CPU time
#.  clocks, but these clocks are not currently (2.6.28) settable on Linux.
#. type: Plain text
#: build/C/man2/timer_settime.2:141
msgid ""
"If the value of the B<CLOCK_REALTIME> clock is adjusted while an absolute "
"timer based on that clock is armed, then the expiration of the timer will be "
"appropriately adjusted.  Adjustments to the B<CLOCK_REALTIME> clock have no "
"effect on relative timers based on that clock."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:149
msgid ""
"If I<old_value> is not NULL, then it returns the previous interval of the "
"timer (in I<old_value-E<gt>it_interval>)  and the amount of time until the "
"timer would previously have next expired (in I<old_value-E<gt>it_value>)."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:169
msgid ""
"B<timer_gettime>()  returns the time until next expiration, and the "
"interval, for the timer specified by I<timerid>, in the buffer pointed to by "
"I<curr_value>.  The time remaining until the next timer expiration is "
"returned in I<curr_value-E<gt>it_value>; this is always a relative value, "
"regardless of whether the B<TIMER_ABSTIME> flag was used when arming the "
"timer.  If the value returned in I<curr_value-E<gt>it_value> is zero, then "
"the timer is currently disarmed.  The timer interval is returned in "
"I<curr_value-E<gt>it_interval>.  If the value returned in I<curr_value-"
"E<gt>it_interval> is zero, then this is a \"one-shot\" timer."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:178
msgid ""
"On success, B<timer_settime>()  and B<timer_gettime>()  return 0.  On error, "
"-1 is returned, and I<errno> is set to indicate the error."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:180
msgid "These functions may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:187
msgid "I<new_value>, I<old_value>, or I<curr_value> is not a valid pointer."
msgstr ""

#.  FIXME . eventually: invalid value in flags
#. type: Plain text
#: build/C/man2/timer_settime.2:192
msgid "I<timerid> is invalid."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:195
msgid "B<timer_settime>()  may fail with the following errors:"
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:201
msgid ""
"I<new_value.it_value> is negative; or I<new_value.it_value.tv_nsec> is "
"negative or greater than 999,999,999."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:203
msgid "These system calls are available since Linux 2.6."
msgstr ""

#. type: Plain text
#: build/C/man2/timer_settime.2:212
msgid "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"
msgstr "B<timer_create>(2), B<timer_getoverrun>(2), B<time>(7)"

#. type: TH
#: build/C/man2/timerfd_create.2:20
#, no-wrap
msgid "TIMERFD_CREATE"
msgstr "TIMERFD_CREATE"

#. type: TH
#: build/C/man2/timerfd_create.2:20
#, no-wrap
msgid "2011-09-14"
msgstr "2011-09-14"

#. type: Plain text
#: build/C/man2/timerfd_create.2:24
msgid ""
"timerfd_create, timerfd_settime, timerfd_gettime - timers that notify via "
"file descriptors"
msgstr ""
"timerfd_create, timerfd_settime, timerfd_gettime - ファイルディスクリプタ経由"
"で通知するタイマー"

#. type: Plain text
#: build/C/man2/timerfd_create.2:27
#, no-wrap
msgid "B<#include E<lt>sys/timerfd.hE<gt>>\n"
msgstr "B<#include E<lt>sys/timerfd.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:29
#, no-wrap
msgid "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"
msgstr "B<int timerfd_create(int >I<clockid>B<, int >I<flags>B<);>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:33
#, no-wrap
msgid ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"
msgstr ""
"B<int timerfd_settime(int >I<fd>B<, int >I<flags>B<,>\n"
"B<                    const struct itimerspec *>I<new_value>B<,>\n"
"B<                    struct itimerspec *>I<old_value>B<);>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:35
#, no-wrap
msgid "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"
msgstr "B<int timerfd_gettime(int >I<fd>B<, struct itimerspec *>I<curr_value>B<);>\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:48
msgid ""
"These system calls create and operate on a timer that delivers timer "
"expiration notifications via a file descriptor.  They provide an alternative "
"to the use of B<setitimer>(2)  or B<timer_create>(2), with the advantage "
"that the file descriptor may be monitored by B<select>(2), B<poll>(2), and "
"B<epoll>(7)."
msgstr ""
"これらのシステムコールは、満了通知をファイルディスクリプタ経由で配送する タイ"
"マーの生成と操作を行う。 これらは、 B<setitimer>(2)  や B<timer_create>(2)  "
"を用いる方法の代わりとなるものであり、このファイルディスクリプタを B<select>"
"(2), B<poll>(2), B<epoll>(7)  で監視できるという利点がある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:60
msgid ""
"The use of these three system calls is analogous to the use of "
"B<timer_create>(2), B<timer_settime>(2), and B<timer_gettime>(2).  (There is "
"no analog of B<timer_getoverrun>(2), since that functionality is provided by "
"B<read>(2), as described below.)"
msgstr ""
"これらのシステムコールを使うのは、それぞれ B<timer_create>(2), "
"B<timer_settime>(2), B<timer_gettime>(2)  を使うのと同様である "
"(B<timer_getoverrun>(2)  に対応するものはなく、以下で説明するように この機能"
"は B<read>(2)  により提供される)。"

#. type: SS
#: build/C/man2/timerfd_create.2:60
#, no-wrap
msgid "timerfd_create()"
msgstr "timerfd_create()"

#. type: Plain text
#: build/C/man2/timerfd_create.2:79
msgid ""
"B<timerfd_create>()  creates a new timer object, and returns a file "
"descriptor that refers to that timer.  The I<clockid> argument specifies the "
"clock that is used to mark the progress of the timer, and must be either "
"B<CLOCK_REALTIME> or B<CLOCK_MONOTONIC>.  B<CLOCK_REALTIME> is a settable "
"system-wide clock.  B<CLOCK_MONOTONIC> is a nonsettable clock that is not "
"affected by discontinuous changes in the system clock (e.g., manual changes "
"to system time).  The current value of each of these clocks can be retrieved "
"using B<clock_gettime>(2)."
msgstr ""
"B<timerfd_create>()  は新規のタイマーオブジェクトを生成し、そのタイマーを参照"
"するファイル ディスクリプタを返す。 I<clockid> 引き数は、タイマーの進捗を管理"
"するためのクロックを指定するもので、 B<CLOCK_REALTIME> か B<CLOCK_MONOTONIC> "
"のいずれかでなければならない。 B<CLOCK_REALTIME> はシステム全体で使用されるク"
"ロックで、このクロックは変更可能である。 B<CLOCK_MONOTONIC> は変更されること"
"のないクロックで、(システム時刻の手動での変更などの)  システムクロックの不連"
"続な変化の影響を受けない。 これらのクロックの現在の値は B<clock_gettime>(2)  "
"を使って取得できる。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:84
msgid ""
"Starting with Linux 2.6.27, the following values may be bitwise ORed in "
"I<flags> to change the behavior of B<timerfd_create>():"
msgstr ""
"Linux 2.6.27 以降では、 以下の値のいくつかをビット単位の論理和 (OR) で指定す"
"ることで、 B<timerfd_create>()  の振舞いを変更することができる。"

#. type: TP
#: build/C/man2/timerfd_create.2:84
#, no-wrap
msgid "B<TFD_NONBLOCK>"
msgstr "B<TFD_NONBLOCK>"

#. type: TP
#: build/C/man2/timerfd_create.2:92
#, no-wrap
msgid "B<TFD_CLOEXEC>"
msgstr "B<TFD_CLOEXEC>"

#. type: Plain text
#: build/C/man2/timerfd_create.2:106
msgid ""
"In Linux versions up to and including 2.6.26, I<flags> must be specified as "
"zero."
msgstr ""
"バージョン 2.6.26 以前の Linux では、 I<flags> 引き数は未使用であり、0 を指定"
"しなければならない。"

#. type: SS
#: build/C/man2/timerfd_create.2:106
#, no-wrap
msgid "timerfd_settime()"
msgstr "timerfd_settime()"

#. type: Plain text
#: build/C/man2/timerfd_create.2:111
msgid ""
"B<timerfd_settime>()  arms (starts) or disarms (stops)  the timer referred "
"to by the file descriptor I<fd>."
msgstr ""
"B<timerfd_settime>()  は、ファイルディスクリプタ I<fd> により参照されるタイ"
"マーを開始したり停止したりする。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:120
msgid ""
"The I<new_value> argument specifies the initial expiration and interval for "
"the timer.  The I<itimer> structure used for this argument contains two "
"fields, each of which is in turn a structure of type I<timespec>:"
msgstr ""
"I<new_value> 引き数は、タイマーの満了時間 (expiration) の初期値と間隔 "
"(interval) を 指定する。この引き数で使用されている I<itimerspec> 構造体には "
"2 つのフィールドがあり、各フィールドは I<timespec> 型の構造体である。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:132
#, no-wrap
msgid ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"
msgstr ""
"struct itimerspec {\n"
"    struct timespec it_interval;  /* Interval for periodic timer */\n"
"    struct timespec it_value;     /* Initial expiration */\n"
"};\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:144
msgid ""
"I<new_value.it_value> specifies the initial expiration of the timer, in "
"seconds and nanoseconds.  Setting either field of I<new_value.it_value> to a "
"nonzero value arms the timer.  Setting both fields of I<new_value.it_value> "
"to zero disarms the timer."
msgstr ""
"I<new_value.it_value> はタイマーの満了時間の初期値を、秒とナノ秒で指定する。 "
"I<new_value.it_value> のフィールドのうち少なくとも一方に 0 以外の値を設定する"
"と、 タイマーが開始される。 両方のフィールドに 0 を設定すると、タイマーが停止"
"する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:153
msgid ""
"Setting one or both fields of I<new_value.it_interval> to nonzero values "
"specifies the period, in seconds and nanoseconds, for repeated timer "
"expirations after the initial expiration.  If both fields of I<new_value."
"it_interval> are zero, the timer expires just once, at the time specified by "
"I<new_value.it_value>."
msgstr ""
"I<new_value.it_interval> はタイマーの一回目の満了後に繰り返しタイマーの満了間"
"隔を、秒とナノ秒で指定する。 I<new_value.it_interval> のフィールドのうち少な"
"くとも一方に 0 以外の値を設定すると、 繰り返しタイマーが有効になる。 両方の"
"フィールドに 0 を設定した場合、タイマーは I<new_value.it_value> で指定された"
"時間後に、一回だけ満了して停止する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:169
msgid ""
"The I<flags> argument is either 0, to start a relative timer (I<new_value."
"it_value> specifies a time relative to the current value of the clock "
"specified by I<clockid>), or B<TFD_TIMER_ABSTIME>, to start an absolute "
"timer (I<new_value.it_value> specifies an absolute time for the clock "
"specified by I<clockid>; that is, the timer will expire when the value of "
"that clock reaches the value specified in I<new_value.it_value>)."
msgstr ""
"I<flags> 引き数には 0 か B<TFD_TIMER_ABSTIME> を指定する。 0 は相対時刻\n"
"タイマーを意味し、 I<new_value.it_value> では I<clockid> で指定された\n"
"クロックの現在の値からの相対的な時刻を指定する。 B<TFD_TIMER_ABSTIME>\n"
"は絶対時刻タイマーを意味し、 I<new_value.it_interval> では I<clockid>\n"
"で指定されたクロックの絶対時刻を指定する。\n"
"つまり、クロックの値が I<new_value.it_interval> で指定された時刻に\n"
"達したら、タイマーが満了する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:180
msgid ""
"If the I<old_value> argument is not NULL, then the I<itimerspec> structure "
"that it points to is used to return the setting of the timer that was "
"current at the time of the call; see the description of B<timerfd_gettime>"
"()  following."
msgstr ""
"I<old_value> 引き数が NULL でない場合、 I<old_value> 引き数が指す\n"
"I<itimerspec> 構造体は、 B<timerfd_settime>() を呼び出した時点での\n"
"タイマーの設定を返すのに使用される。\n"
"下記の B<timerfd_gettime>() の説明を参照。"

#. type: SS
#: build/C/man2/timerfd_create.2:180
#, no-wrap
msgid "timerfd_gettime()"
msgstr "timerfd_gettime()"

#. type: Plain text
#: build/C/man2/timerfd_create.2:189
msgid ""
"B<timerfd_gettime>()  returns, in I<curr_value>, an I<itimerspec> structure "
"that contains the current setting of the timer referred to by the file "
"descriptor I<fd>."
msgstr ""
"B<timerfd_gettime>()  は、ファイルディスクリプタ I<fd> で参照されるタイマーの"
"現在の設定が入った I<itimerspec> 構造体を、 I<curr_value> に格納して返す。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:199
msgid ""
"The I<it_value> field returns the amount of time until the timer will next "
"expire.  If both fields of this structure are zero, then the timer is "
"currently disarmed.  This field always contains a relative value, regardless "
"of whether the B<TFD_TIMER_ABSTIME> flag was specified when setting the "
"timer."
msgstr ""
"I<it_value> フィールドは、タイマーが次に満了するまでの残り時間を返す。 この構"
"造体の両方のフィールドが 0 であれば、タイマーは現在停止している。 タイマー設"
"定時に B<TFD_TIMER_ABSTIME> フラグが指定されたかに関わらず、このフィールドは"
"常に相対値が格納される。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:206
msgid ""
"The I<it_interval> field returns the interval of the timer.  If both fields "
"of this structure are zero, then the timer is set to expire just once, at "
"the time specified by I<curr_value.it_value>."
msgstr ""
"I<it_interval> フィールドは、タイマーの間隔を返す。 この構造体の両方のフィー"
"ルドが 0 であれば、タイマーは I<new_value.it_value> で指定された時間後に一回"
"だけ満了して停止するように設定されている。"

#. type: SS
#: build/C/man2/timerfd_create.2:206
#, no-wrap
msgid "Operating on a timer file descriptor"
msgstr "タイマー・ファイルディスクリプタに対する操作"

#. type: Plain text
#: build/C/man2/timerfd_create.2:210
msgid ""
"The file descriptor returned by B<timerfd_create>()  supports the following "
"operations:"
msgstr ""
"B<timerfd_create>()  が返すファイルディスクリプタは以下の操作をサポートしてい"
"る。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:224
msgid ""
"If the timer has already expired one or more times since its settings were "
"last modified using B<timerfd_settime>(), or since the last successful "
"B<read>(2), then the buffer given to B<read>(2)  returns an unsigned 8-byte "
"integer (I<uint64_t>)  containing the number of expirations that have "
"occurred.  (The returned value is in host byte order, i.e., the native byte "
"order for integers on the host machine.)"
msgstr ""
"B<timerfd_settime>()  を使ってタイマーの設定が最後変更されて以降、または "
"B<read>(2)  の呼び出しに最後に成功して以降に、タイマーの満了が一回以上発生し"
"ていれば、 B<read>(2)  に渡されたバッファに、タイマー満了回数を示す 8 バイト"
"の unsigned 型の整数 (I<uint64_t>)  が返される (返される値はホストバイトオー"
"ダ、つまりそのホストマシンにおける 整数の通常のバイトオーダである)。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:237
msgid ""
"If no timer expirations have occurred at the time of the B<read>(2), then "
"the call either blocks until the next timer expiration, or fails with the "
"error B<EAGAIN> if the file descriptor has been made nonblocking (via the "
"use of the B<fcntl>(2)  B<F_SETFL> operation to set the B<O_NONBLOCK> flag)."
msgstr ""
"B<read>(2)  を行った時点でタイマーの満了が発生していなければ、 B<read>(2)  は"
"停止 (block) する、もしくはファイルディスクリプタが 非停止 (nonblocking) に設"
"定されている場合はエラー B<EAGAIN> で失敗する (非停止モードにするには、 "
"B<fcntl>(2)  の B<F_SETFL> 命令で B<O_NONBLOCK> フラグをセットする)。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:243
msgid ""
"A B<read>(2)  will fail with the error B<EINVAL> if the size of the supplied "
"buffer is less than 8 bytes."
msgstr ""
"渡されたバッファの大きさが 8 バイト未満の場合、 B<read>(2)  はエラー "
"B<EINVAL> で失敗する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:254
msgid ""
"The file descriptor is readable (the B<select>(2)  I<readfds> argument; the "
"B<poll>(2)  B<POLLIN> flag)  if one or more timer expirations have occurred."
msgstr ""
"一つ以上のタイマー満了が発生していれば、 ファイルディスクリプタは読み出し可能"
"となる (B<select>(2)  の I<readfds> 引き数や B<poll>(2)  の B<POLLIN> フラ"
"グ)。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:261
msgid ""
"The file descriptor also supports the other file-descriptor multiplexing "
"APIs: B<pselect>(2), B<ppoll>(2), and B<epoll>(7)."
msgstr ""
"このファイルディスクリプタは、他のファイルディスクリプタ多重 API である "
"B<pselect>(2), B<ppoll>(2), B<epoll>(7)  もサポートしている。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:268
msgid ""
"When the file descriptor is no longer required it should be closed.  When "
"all file descriptors associated with the same timer object have been closed, "
"the timer is disarmed and its resources are freed by the kernel."
msgstr ""
"ファイルディスクリプタがそれ以降は必要なくなった際には、クローズすべきであ"
"る。 同じ timer オブジェクトに関連付けられたファイルディスクリプタが全て ク"
"ローズされると、そのタイマーは解除され、 そのオブジェクト用の資源がカーネルに"
"より解放される。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:280
msgid ""
"After a B<fork>(2), the child inherits a copy of the file descriptor created "
"by B<timerfd_create>().  The file descriptor refers to the same underlying "
"timer object as the corresponding file descriptor in the parent, and B<read>"
"(2)s in the child will return information about expirations of the timer."
msgstr ""
"B<fork>(2)  が行われると、子プロセスは B<timerfd_create>()  により生成された"
"ファイルディスクリプタのコピーを 継承する。そのファイルディスクリプタは、親プ"
"ロセスの対応する ファイルディスクリプタと同じタイマーオブジェクトを参照してお"
"り、 子プロセスの B<read>(2)  でも同じタイマーの満了に関する情報が返される。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:286
msgid ""
"A file descriptor created by B<timerfd_create>()  is preserved across "
"B<execve>(2), and continues to generate timer expirations if the timer was "
"armed."
msgstr ""
"B<execve>(2)  の前後で B<timerfd_create>()  により生成されたファイルディスク"
"リプタは保持され、 タイマーが開始されていた場合にはタイマーの満了が発生し続け"
"る。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:293
msgid ""
"On success, B<timerfd_create>()  returns a new file descriptor.  On error, "
"-1 is returned and I<errno> is set to indicate the error."
msgstr ""
"成功すると、 B<timerfd_create>()  は新しいファイルディスクリプタを返す。 エ"
"ラーの場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:301
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  return 0 on success; on "
"error they return -1, and set I<errno> to indicate the error."
msgstr ""
"B<timerfd_settime>()  と B<timerfd_gettime>()  は成功すると 0 を返す。 エラー"
"の場合、-1 を返し、 I<errno> にエラーを示す値を設定する。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:304
msgid "B<timerfd_create>()  can fail with the following errors:"
msgstr "B<timerfd_create>()  は以下のエラーで失敗する可能性がある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:312
msgid ""
"The I<clockid> argument is neither B<CLOCK_MONOTONIC> nor B<CLOCK_REALTIME>;"
msgstr ""
"I<clockid> 引き数が B<CLOCK_MONOTONIC> でも B<CLOCK_REALTIME> でもない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:332
msgid "There was insufficient kernel memory to create the timer."
msgstr "タイマーを作成するのに十分なカーネルメモリがなかった。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:337
msgid ""
"B<timerfd_settime>()  and B<timerfd_gettime>()  can fail with the following "
"errors:"
msgstr ""
"B<timerfd_settime>()  と B<timerfd_gettime>()  は以下のエラーで失敗する可能性"
"がある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:341
msgid "I<fd> is not a valid file descriptor."
msgstr "I<fd> が有効なファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:352
msgid "I<fd> is not a valid timerfd file descriptor."
msgstr "I<fd> が有効な timerfd ファイルディスクリプタでない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:355
msgid "B<timerfd_settime>()  can also fail with the following errors:"
msgstr "B<timerfd_settime>()  は以下のエラーで失敗することもある。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:361
msgid ""
"I<new_value> is not properly initialized (one of the I<tv_nsec> falls "
"outside the range zero to 999,999,999)."
msgstr ""
"I<new_value> が適切に初期化されていない (I<tv_nsec> の一つが 0 から "
"999,999,999 までの範囲に入っていない)。"

#.  This case only checked since 2.6.29, and 2.2.2[78].some-stable-version.
#.  In older kernel versions, no check was made for invalid flags.
#. type: Plain text
#: build/C/man2/timerfd_create.2:367
msgid "I<flags> is invalid."
msgstr "I<flags> が無効である。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:370
msgid ""
"These system calls are available on Linux since kernel 2.6.25.  Library "
"support is provided by glibc since version 2.8."
msgstr ""
"これらのシステムコールはカーネル 2.6.25 以降の Linux で利用可能である。 ライ"
"ブラリ側のサポートはバージョン 2.8 以降の glibc で提供されている。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:381
msgid ""
"The following program creates a timer and then monitors its progress.  The "
"program accepts up to three command-line arguments.  The first argument "
"specifies the number of seconds for the initial expiration of the timer.  "
"The second argument specifies the interval for the timer, in seconds.  The "
"third argument specifies the number of times the program should allow the "
"timer to expire before terminating.  The second and third command-line "
"arguments are optional."
msgstr ""
"以下のプログラムは、タイマーを作成し、その進捗をモニターするものである。 この"
"プログラムは最大で 3 個のコマンドライン引き数を取り、 第一引き数ではタイマー"
"の満了時間の初期値 (秒数単位) を、 第二引き数ではタイマーの間隔 (秒数単位) "
"を、 第三引き数ではタイマーが何回満了したらプログラムが終了するかを指定す"
"る。 第二引き数と第三引き数は省略可能である。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:383 build/C/man2/wait.2:541
msgid "The following shell session demonstrates the use of the program:"
msgstr "以下のシェルのセッションはこのプログラムの使用例を示したものである。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:398
#, no-wrap
msgid ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<^Z >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<^C >                 # type control-C to suspend the program\n"
msgstr ""
"$B< a.out 3 1 100>\n"
"0.000: timer started\n"
"3.000: read: 1; total=1\n"
"4.000: read: 1; total=2\n"
"B<^Z >                 # type control-Z to suspend the program\n"
"[1]+  Stopped                 ./timerfd3_demo 3 1 100\n"
"$ B<fg>                # Resume execution after a few seconds\n"
"a.out 3 1 100\n"
"9.660: read: 5; total=7\n"
"10.000: read: 1; total=8\n"
"11.000: read: 1; total=9\n"
"B<^C >                 # type control-C to suspend the program\n"

#.  The commented out code here is what we currently need until
#.  the required stuff is in glibc
#. /* Link with -lrt */
#. #define _GNU_SOURCE
#. #include <sys/syscall.h>
#. #include <unistd.h>
#. #include <time.h>
#. #if defined(__i386__)
#. #define __NR_timerfd_create 322
#. #define __NR_timerfd_settime 325
#. #define __NR_timerfd_gettime 326
#. #endif
#. static int
#. timerfd_create(int clockid, int flags)
#. {
#.     return syscall(__NR_timerfd_create, clockid, flags);
#. }
#. static int
#. timerfd_settime(int fd, int flags, struct itimerspec *new_value,
#.         struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_settime, fd, flags, new_value,
#.                    curr_value);
#. }
#. static int
#. timerfd_gettime(int fd, struct itimerspec *curr_value)
#. {
#.     return syscall(__NR_timerfd_gettime, fd, curr_value);
#. }
#. #define TFD_TIMER_ABSTIME (1 << 0)
#. ////////////////////////////////////////////////////////////
#. type: Plain text
#: build/C/man2/timerfd_create.2:447
#, no-wrap
msgid ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"
msgstr ""
"#include E<lt>sys/timerfd.hE<gt>\n"
"#include E<lt>time.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
"#include E<lt>stdint.hE<gt>        /* Definition of uint64_t */\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:450
#, no-wrap
msgid ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"
msgstr ""
"#define handle_error(msg) \\e\n"
"        do { perror(msg); exit(EXIT_FAILURE); } while (0)\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:458
#, no-wrap
msgid ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"
msgstr ""
"static void\n"
"print_elapsed_time(void)\n"
"{\n"
"    static struct timespec start;\n"
"    struct timespec curr;\n"
"    static int first_call = 1;\n"
"    int secs, nsecs;\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:464
#, no-wrap
msgid ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"
msgstr ""
"    if (first_call) {\n"
"        first_call = 0;\n"
"        if (clock_gettime(CLOCK_MONOTONIC, &start) == -1)\n"
"            handle_error(\"clock_gettime\");\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:467
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""
"    if (clock_gettime(CLOCK_MONOTONIC, &curr) == -1)\n"
"        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:476
#, no-wrap
msgid ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"
msgstr ""
"    secs = curr.tv_sec - start.tv_sec;\n"
"    nsecs = curr.tv_nsec - start.tv_nsec;\n"
"    if (nsecs E<lt> 0) {\n"
"        secs--;\n"
"        nsecs += 1000000000;\n"
"    }\n"
"    printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);\n"
"}\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:485
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    struct itimerspec new_value;\n"
"    int max_exp, fd;\n"
"    struct timespec now;\n"
"    uint64_t exp, tot_exp;\n"
"    ssize_t s;\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:491
#, no-wrap
msgid ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    if ((argc != 2) && (argc != 4)) {\n"
"        fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\en\",\n"
"                argv[0]);\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:494
#, no-wrap
msgid ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"
msgstr ""
"    if (clock_gettime(CLOCK_REALTIME, &now) == -1)\n"
"        handle_error(\"clock_gettime\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:497
#, no-wrap
msgid ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"
msgstr ""
"    /* Create a CLOCK_REALTIME absolute timer with initial\n"
"       expiration and interval as specified in command line */\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:508
#, no-wrap
msgid ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"
msgstr ""
"    new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);\n"
"    new_value.it_value.tv_nsec = now.tv_nsec;\n"
"    if (argc == 2) {\n"
"        new_value.it_interval.tv_sec = 0;\n"
"        max_exp = 1;\n"
"    } else {\n"
"        new_value.it_interval.tv_sec = atoi(argv[2]);\n"
"        max_exp = atoi(argv[3]);\n"
"    }\n"
"    new_value.it_interval.tv_nsec = 0;\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:512
#, no-wrap
msgid ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"
msgstr ""
"    fd = timerfd_create(CLOCK_REALTIME, 0);\n"
"    if (fd == -1)\n"
"        handle_error(\"timerfd_create\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:515
#, no-wrap
msgid ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"
msgstr ""
"    if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &new_value, NULL) == -1)\n"
"        handle_error(\"timerfd_settime\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:518
#, no-wrap
msgid ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"
msgstr ""
"    print_elapsed_time();\n"
"    printf(\"timer started\\en\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:523
#, no-wrap
msgid ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"
msgstr ""
"    for (tot_exp = 0; tot_exp E<lt> max_exp;) {\n"
"        s = read(fd, &exp, sizeof(uint64_t));\n"
"        if (s != sizeof(uint64_t))\n"
"            handle_error(\"read\");\n"

#. type: Plain text
#: build/C/man2/timerfd_create.2:530
#, no-wrap
msgid ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %llu; total=%llu\\en\",\n"
"                (unsigned long long) exp,\n"
"                (unsigned long long) tot_exp);\n"
"    }\n"
msgstr ""
"        tot_exp += exp;\n"
"        print_elapsed_time();\n"
"        printf(\"read: %llu; total=%llu\\en\",\n"
"                (unsigned long long) exp,\n"
"                (unsigned long long) tot_exp);\n"
"    }\n"

#.  2.6.29
#. type: Plain text
#: build/C/man2/timerfd_create.2:540
msgid ""
"Currently, B<timerfd_create>()  supports fewer types of clock IDs than "
"B<timer_create>(2)."
msgstr ""
"現在のところ、 B<timerfd_create>()  が対応している clockid の種類は "
"B<timer_create>(2)  よりも少ない。"

#. type: Plain text
#: build/C/man2/timerfd_create.2:552
msgid ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), B<timer_settime>"
"(2), B<epoll>(7), B<time>(7)"
msgstr ""
"B<eventfd>(2), B<poll>(2), B<read>(2), B<select>(2), B<setitimer>(2), "
"B<signalfd>(2), B<timer_create>(2), B<timer_gettime>(2), B<timer_settime>"
"(2), B<epoll>(7), B<time>(7)"

#. type: TH
#: build/C/man2/tkill.2:29
#, no-wrap
msgid "TKILL"
msgstr "TKILL"

#. type: Plain text
#: build/C/man2/tkill.2:32
msgid "tkill, tgkill - send a signal to a thread"
msgstr "tkill, tgkill - スレッドにシグナルを送る"

#. type: Plain text
#: build/C/man2/tkill.2:35
#, no-wrap
msgid "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"
msgstr "B<int tkill(int >I<tid>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man2/tkill.2:37
#, no-wrap
msgid "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"
msgstr "B<int tgkill(int >I<tgid>B<, int >I<tid>B<, int >I<sig>B<);>\n"

#. type: Plain text
#: build/C/man2/tkill.2:51
msgid ""
"B<tgkill>()  sends the signal I<sig> to the thread with the thread ID I<tid> "
"in the thread group I<tgid>.  (By contrast, B<kill>(2)  can only be used to "
"send a signal to a process (i.e., thread group)  as a whole, and the signal "
"will be delivered to an arbitrary thread within that process.)"
msgstr ""
"B<tgkill>()  はスレッド・グループ I<tgid> に属するスレッド ID が I<tid> のス"
"レッドにシグナル I<sig> を送る。 (これに対し、 B<kill>(2)  は一つのプロセス "
"(すなわち、スレッド・グループ) にまとめてシグナルを 送るのにだけ利用できる。 "
"B<kill>(2)  で送信されたシグナルはプロセス内の任意のスレッドに配送される。)"

#. type: Plain text
#: build/C/man2/tkill.2:59
msgid ""
"B<tkill>()  is an obsolete predecessor to B<tgkill>().  It only allows the "
"target thread ID to be specified, which may result in the wrong thread being "
"signaled if a thread terminates and its thread ID is recycled.  Avoid using "
"this system call."
msgstr ""
"B<tkill>()  はもう使われなくなった B<tgkill>()  の先祖である。 B<tkill>()  で"
"はシグナルの送り先のスレッド ID しか指定できない。 そのため、スレッドが終了し"
"て、そのスレッド ID が再利用される場合に、 意図しないスレッドにシグナルが送ら"
"れる可能性がある。 このシステムコールの使用は避けること。"

#. type: Plain text
#: build/C/man2/tkill.2:66
msgid ""
"If I<tgid> is specified as -1, B<tgkill>()  is equivalent to B<tkill>()."
msgstr ""
"I<tgid> に -1 が指定された場合、 B<tgkill>()  は B<tkill>()  と等価である。"

#. type: Plain text
#: build/C/man2/tkill.2:69
msgid ""
"These are the raw system call interfaces, meant for internal thread library "
"use."
msgstr ""
"これらはシステムコールへの直接のインターフェースであり、 スレッド・ライブラリ"
"内部での使用を意図したものである。"

#. type: Plain text
#: build/C/man2/tkill.2:77
msgid "An invalid thread ID, thread group ID, or signal was specified."
msgstr "指定されたスレッド ID、スレッドグループ ID、シグナルが不正であった。"

#. type: Plain text
#: build/C/man2/tkill.2:82
msgid "Permission denied.  For the required permissions, see B<kill>(2)."
msgstr ""
"許可がなかった。どのような許可が必要かについては、 B<kill>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/tkill.2:85
msgid "No process with the specified thread ID (and thread group ID) exists."
msgstr ""
"指定されたスレッドID (とスレッド・グループID) を持つプロセスが存在しない。"

#. type: Plain text
#: build/C/man2/tkill.2:90
msgid ""
"B<tkill>()  is supported since Linux 2.4.19 / 2.5.4.  B<tgkill>()  was added "
"in Linux 2.5.75."
msgstr ""
"B<tkill>()  は Linux 2.4.19 / 2.5.4 以降でサポートされ、 B<tgkill>()  は "
"Linux 2.5.75 で追加された。"

#. type: Plain text
#: build/C/man2/tkill.2:96
msgid ""
"B<tkill>()  and B<tgkill>()  are Linux-specific and should not be used in "
"programs that are intended to be portable."
msgstr ""
"B<tkill>()  と B<tgkill>()  は Linux 固有であり、 移植を想定したプログラムで"
"は使用すべきではない。"

#. type: Plain text
#: build/C/man2/tkill.2:102
msgid ""
"See the description of B<CLONE_THREAD> in B<clone>(2)  for an explanation of "
"thread groups."
msgstr ""
"スレッド・グループの説明については B<clone>(2)  の B<CLONE_THREAD> の説明を参"
"照のこと。"

#. type: Plain text
#: build/C/man2/tkill.2:105
msgid ""
"Glibc does not provide wrappers for these system calls; call them using "
"B<syscall>(2)."
msgstr ""
"glibc はこれらのシステムコールに対するラッパー関数を提供していない。 "
"B<syscall>(2)  を使って呼び出すこと。"

#. type: Plain text
#: build/C/man2/tkill.2:110
msgid "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"
msgstr "B<clone>(2), B<gettid>(2), B<kill>(2), B<rt_sigqueueinfo>(2)"

#. type: TH
#: build/C/man2/wait.2:50
#, no-wrap
msgid "WAIT"
msgstr "WAIT"

#. type: Plain text
#: build/C/man2/wait.2:53
msgid "wait, waitpid, waitid - wait for process to change state"
msgstr "wait, waitpid, waitid - プロセスの状態変化を待つ"

#. type: Plain text
#: build/C/man2/wait.2:55
msgid "B<#include E<lt>sys/types.hE<gt>>"
msgstr "B<#include E<lt>sys/types.hE<gt>>"

#. type: Plain text
#: build/C/man2/wait.2:57
msgid "B<#include E<lt>sys/wait.hE<gt>>"
msgstr "B<#include E<lt>sys/wait.hE<gt>>"

#. type: Plain text
#: build/C/man2/wait.2:59
msgid "B<pid_t wait(int *>I<status>B<);>"
msgstr "B<pid_t wait(int *>I<status>B<);>"

#. type: Plain text
#: build/C/man2/wait.2:61
msgid ""
"B<pid_t waitpid(pid_t >I<pid>B<, int *>I<status>B<, int >I<options>B<);>"
msgstr ""
"B<pid_t waitpid(pid_t >I<pid>B<, int *>I<status>B<, int >I<options>B<);>"

#. type: Plain text
#: build/C/man2/wait.2:64
msgid ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, "
"int >I<options>B<);>"
msgstr ""
"B<int waitid(idtype_t >I<idtype>B<, id_t >I<id>B<, siginfo_t *>I<infop>B<, "
"int >I<options>B<);>"

#. type: Plain text
#: build/C/man2/wait.2:73
msgid "B<waitid>():"
msgstr "B<waitid>():"

#. type: Plain text
#: build/C/man2/wait.2:77
msgid ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"
msgstr ""
"_SVID_SOURCE || _XOPEN_SOURCE\\ E<gt>=\\ 500 || _XOPEN_SOURCE\\ &&\\ "
"_XOPEN_SOURCE_EXTENDED"

#. type: Plain text
#: build/C/man2/wait.2:92
msgid ""
"All of these system calls are used to wait for state changes in a child of "
"the calling process, and obtain information about the child whose state has "
"changed.  A state change is considered to be: the child terminated; the "
"child was stopped by a signal; or the child was resumed by a signal.  In the "
"case of a terminated child, performing a wait allows the system to release "
"the resources associated with the child; if a wait is not performed, then "
"the terminated child remains in a \"zombie\" state (see NOTES below)."
msgstr ""
"これらのシステムコールはいずれも、呼び出し元プロセスの子プロセスの 状態変化を"
"待ち、状態が変化したその子プロセスの情報を取得するのに 使用される。 状態変化"
"とは以下のいずれかである: 子プロセスの終了、シグナルによる子プロセスの停止、 "
"シグナルによる子プロセスの再開。 子プロセスが終了した場合は、wait を実行する"
"ことで、 システムがその子プロセスに関連するリソースを解放できるようになる。 "
"wait が実行されなかった場合には、終了した子プロセスは 「ゾンビ」状態で残り続"
"ける (下記の注意の章を参照のこと)。"

#. type: Plain text
#: build/C/man2/wait.2:104
msgid ""
"If a child has already changed state, then these calls return immediately.  "
"Otherwise they block until either a child changes state or a signal handler "
"interrupts the call (assuming that system calls are not automatically "
"restarted using the B<SA_RESTART> flag of B<sigaction>(2)).  In the "
"remainder of this page, a child whose state has changed and which has not "
"yet been waited upon by one of these system calls is termed I<waitable>."
msgstr ""
"子プロセスの状態変化がすでに発生していた場合、これらのコールは すぐに復帰す"
"る。それ以外の場合は、子プロセスの状態変化が起こるか、 シグナルハンドラにより"
"システムコールが中断されるまで、 停止 (block) する (後者は、 B<sigaction>"
"(2)  の B<SA_RESTART> フラグによりシステムコールが自動的に再スタートするよう"
"になっていない 場合の動作である)。 以下の説明では、状態変化が起こったがこれら"
"のシステムコールのいずれかに よって待たれていない子プロセスを I<waitable> (待"
"ち可能) と呼ぶ。"

#. type: SS
#: build/C/man2/wait.2:104
#, no-wrap
msgid "wait() and waitpid()"
msgstr "wait() と waitpid()"

#. type: Plain text
#: build/C/man2/wait.2:112
msgid ""
"The B<wait>()  system call suspends execution of the calling process until "
"one of its children terminates.  The call I<wait(&status)> is equivalent to:"
msgstr ""
"B<wait>()  システムコールは、子プロセスのいずれかが終了するまで 呼び出し元の"
"プロセスの実行を一時停止する。 呼び出し I<wait(&status)> は以下と等価である:"

#. type: Plain text
#: build/C/man2/wait.2:115
#, no-wrap
msgid "    waitpid(-1, &status, 0);\n"
msgstr "    waitpid(-1, &status, 0);\n"

#. type: Plain text
#: build/C/man2/wait.2:129
msgid ""
"The B<waitpid>()  system call suspends execution of the calling process "
"until a child specified by I<pid> argument has changed state.  By default, "
"B<waitpid>()  waits only for terminated children, but this behavior is "
"modifiable via the I<options> argument, as described below."
msgstr ""
"B<waitpid>()  システムコールは、 I<pid> 引き数で指定した子プロセスの状態変化"
"が起こるまで、 呼び出し元のプロセスの実行を一時停止する。デフォルトでは、 "
"B<waitpid>()  は子プロセスの終了だけを待つが、この動作は I<options> 引き数に"
"より変更可能である。"

#. type: Plain text
#: build/C/man2/wait.2:133
msgid "The value of I<pid> can be:"
msgstr "I<pid> に指定できる値は以下の通り:"

#. type: IP
#: build/C/man2/wait.2:133
#, no-wrap
msgid "E<lt> -1"
msgstr "E<lt> -1"

#. type: Plain text
#: build/C/man2/wait.2:137
msgid ""
"meaning wait for any child process whose process group ID is equal to the "
"absolute value of I<pid>."
msgstr ""
"プロセスグループID が I<pid> の絶対値に等しい子プロセスのいずれかが終了するま"
"でを待つ。"

#. type: IP
#: build/C/man2/wait.2:137
#, no-wrap
msgid "-1"
msgstr "-1"

#. type: Plain text
#: build/C/man2/wait.2:139
msgid "meaning wait for any child process."
msgstr "子プロセスのどれかが終了するまで待つ。"

#. type: IP
#: build/C/man2/wait.2:139
#, no-wrap
msgid "0"
msgstr "0"

#. type: Plain text
#: build/C/man2/wait.2:142
msgid ""
"meaning wait for any child process whose process group ID is equal to that "
"of the calling process."
msgstr ""
"プロセスグループID が呼び出したプロセスのものと等しい 子プロセスを待つ。"

#. type: IP
#: build/C/man2/wait.2:142
#, no-wrap
msgid "E<gt> 0"
msgstr "E<gt> 0"

#. type: Plain text
#: build/C/man2/wait.2:146
msgid ""
"meaning wait for the child whose process ID is equal to the value of I<pid>."
msgstr "プロセスID が I<pid> に等しい子プロセスを待つ。"

#. type: Plain text
#: build/C/man2/wait.2:150
msgid ""
"The value of I<options> is an OR of zero or more of the following constants:"
msgstr "I<options> の値は次の定数の 0 個以上の論理和である:"

#. type: TP
#: build/C/man2/wait.2:150 build/C/man2/wait.2:279
#, no-wrap
msgid "B<WNOHANG>"
msgstr "B<WNOHANG>"

#. type: Plain text
#: build/C/man2/wait.2:153
msgid "return immediately if no child has exited."
msgstr "状態変化が起こった子プロセスがない場合にすぐに復帰する。"

#. type: TP
#: build/C/man2/wait.2:153
#, no-wrap
msgid "B<WUNTRACED>"
msgstr "B<WUNTRACED>"

#. type: Plain text
#: build/C/man2/wait.2:162
msgid ""
"also return if a child has stopped (but not traced via B<ptrace>(2)).  "
"Status for I<traced> children which have stopped is provided even if this "
"option is not specified."
msgstr ""
"子プロセスが停止した場合にも復帰する (子プロセスが B<ptrace>(2)  でトレースさ"
"れている場合は除く)。 このオプションが指定されていない場合でも、停止したプロ"
"セスが 「トレース (traced)」されていれば、子プロセスの状態が報告される。"

#. type: TP
#: build/C/man2/wait.2:162
#, no-wrap
msgid "B<WCONTINUED> (since Linux 2.6.10)"
msgstr "B<WCONTINUED> (Linux 2.6.10 以降)"

#. type: Plain text
#: build/C/man2/wait.2:166
msgid ""
"also return if a stopped child has been resumed by delivery of B<SIGCONT>."
msgstr "停止した子プロセスが B<SIGCONT> の配送により再開した場合にも復帰する。"

#. type: Plain text
#: build/C/man2/wait.2:168
msgid "(For Linux-only options, see below.)"
msgstr "(Linux 専用オプションについては後述する)"

#. type: Plain text
#: build/C/man2/wait.2:182
msgid ""
"If I<status> is not NULL, B<wait>()  and B<waitpid>()  store status "
"information in the I<int> to which it points.  This integer can be inspected "
"with the following macros (which take the integer itself as an argument, not "
"a pointer to it, as is done in B<wait>()  and B<waitpid>()!):"
msgstr ""
"I<status> が NULL でなければ、 B<wait>()  や B<waitpid>()  は I<status> で指"
"す I<int> に状態情報を格納する。 この整数は以下のマクロを使って検査できる。 "
"(これらのマクロの引き数には、 B<wait>()  や B<waitpid>()  が書き込んだ整数そ"
"のものを指定する。ポインタではない!)"

#. type: TP
#: build/C/man2/wait.2:182
#, no-wrap
msgid "B<WIFEXITED(>I<status>B<)>"
msgstr "B<WIFEXITED(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:190
msgid ""
"returns true if the child terminated normally, that is, by calling B<exit>"
"(3)  or B<_exit>(2), or by returning from main()."
msgstr ""
"子プロセスが正常に終了した場合に真を返す。 「正常に」とは、 B<exit>(3)  か "
"B<_exit>(2)  が呼び出された場合、もしくは main() から復帰した場合である。"

#. type: TP
#: build/C/man2/wait.2:190
#, no-wrap
msgid "B<WEXITSTATUS(>I<status>B<)>"
msgstr "B<WEXITSTATUS(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:203
msgid ""
"returns the exit status of the child.  This consists of the least "
"significant 8 bits of the I<status> argument that the child specified in a "
"call to B<exit>(3)  or B<_exit>(2)  or as the argument for a return "
"statement in main().  This macro should only be employed if B<WIFEXITED> "
"returned true."
msgstr ""
"子プロセスの終了ステータスを返す。 終了ステータスは I<status> 引き数の下位 8"
"ビットで構成されており、 B<exit>(3)  や B<_exit>(2)  の呼び出し時に渡された"
"値、もしくは main() の return 文の 引き数として指定された値である。 このマク"
"ロを使用するのは B<WIFEXITED> が真を返した場合だけにすべきである。"

#. type: TP
#: build/C/man2/wait.2:203
#, no-wrap
msgid "B<WIFSIGNALED(>I<status>B<)>"
msgstr "B<WIFSIGNALED(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:206
msgid "returns true if the child process was terminated by a signal."
msgstr "子プロセスがシグナルにより終了した場合に真を返す。"

#. type: TP
#: build/C/man2/wait.2:206
#, no-wrap
msgid "B<WTERMSIG(>I<status>B<)>"
msgstr "B<WTERMSIG(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:213
msgid ""
"returns the number of the signal that caused the child process to "
"terminate.  This macro should only be employed if B<WIFSIGNALED> returned "
"true."
msgstr ""
"子プロセス終了の原因となったシグナルの番号を返す。 このマクロを使用するのは "
"B<WIFSIGNALED> が真を返した場合だけにすべきである。"

#. type: TP
#: build/C/man2/wait.2:213
#, no-wrap
msgid "B<WCOREDUMP(>I<status>B<)>"
msgstr "B<WCOREDUMP(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:222
msgid ""
"returns true if the child produced a core dump.  This macro should only be "
"employed if B<WIFSIGNALED> returned true.  This macro is not specified in "
"POSIX.1-2001 and is not available on some UNIX implementations (e.g., AIX, "
"SunOS).  Only use this enclosed in #ifdef WCOREDUMP ... #endif."
msgstr ""
"子プロセスがコアダンプを生成した場合に真を返す。 このマクロを使用するのは "
"B<WIFSIGNALED> が真を返した場合だけにすべきである。 このマクロは "
"POSIX.1-2001 では規定されておらず、 (AIX, SunOS などの) いくつかの UNIX の実"
"装では利用できない。 必ず #ifdef WCOREDUMP ... #endif で括って使用すること。"

#. type: TP
#: build/C/man2/wait.2:222
#, no-wrap
msgid "B<WIFSTOPPED(>I<status>B<)>"
msgstr "B<WIFSTOPPED(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:229
msgid ""
"returns true if the child process was stopped by delivery of a signal; this "
"is only possible if the call was done using B<WUNTRACED> or when the child "
"is being traced (see B<ptrace>(2))."
msgstr ""
"子プロセスがシグナルの配送により停止した場合に真を返す。 これが真になるのは、"
"システムコールが B<WUNTRACED> を指定して呼び出された場合か、子プロセスがト"
"レースされている場合 (B<ptrace>(2)  参照) だけである。"

#. type: TP
#: build/C/man2/wait.2:229
#, no-wrap
msgid "B<WSTOPSIG(>I<status>B<)>"
msgstr "B<WSTOPSIG(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:235
msgid ""
"returns the number of the signal which caused the child to stop.  This macro "
"should only be employed if B<WIFSTOPPED> returned true."
msgstr ""
"子プロセスを停止させたシグナルの番号を返す。 このマクロを使用するのは "
"B<WIFSTOPPED> が 0 以外を返した場合だけにすべきである。"

#. type: TP
#: build/C/man2/wait.2:235
#, no-wrap
msgid "B<WIFCONTINUED(>I<status>B<)>"
msgstr "B<WIFCONTINUED(>I<status>B<)>"

#. type: Plain text
#: build/C/man2/wait.2:240
msgid ""
"(since Linux 2.6.10)  returns true if the child process was resumed by "
"delivery of B<SIGCONT>."
msgstr ""
"(Linux 2.6.10 以降)  子プロセスが B<SIGCONT> の配送により再開した場合に真を返"
"す。"

#. type: SS
#: build/C/man2/wait.2:240
#, no-wrap
msgid "waitid()"
msgstr "waitid()"

#. type: Plain text
#: build/C/man2/wait.2:245
msgid ""
"The B<waitid>()  system call (available since Linux 2.6.9) provides more "
"precise control over which child state changes to wait for."
msgstr ""
"B<waitid>()  システムコール (Linux 2.6.9 以降で利用可能) を使うと、 子プロセ"
"スのどの状態変化を待つかについてより細かな制御ができる。"

#. type: Plain text
#: build/C/man2/wait.2:251
msgid ""
"The I<idtype> and I<id> arguments select the child(ren) to wait for, as "
"follows:"
msgstr "引き数 I<idtype> と I<id> でどの子プロセスを待つかを選択する:"

#. type: IP
#: build/C/man2/wait.2:251
#, no-wrap
msgid "I<idtype> == B<P_PID>"
msgstr "I<idtype> == B<P_PID>"

#. type: Plain text
#: build/C/man2/wait.2:254
msgid "Wait for the child whose process ID matches I<id>."
msgstr "プロセスID が I<id> と一致する子プロセスを待つ。"

#. type: IP
#: build/C/man2/wait.2:254
#, no-wrap
msgid "I<idtype> == B<P_PGID>"
msgstr "I<idtype> == B<P_PGID>"

#. type: Plain text
#: build/C/man2/wait.2:257
msgid "Wait for any child whose process group ID matches I<id>."
msgstr "プロセスグループID が I<id> と一致する子プロセスを待つ。"

#. type: IP
#: build/C/man2/wait.2:257
#, no-wrap
msgid "I<idtype> == B<P_ALL>"
msgstr "I<idtype> == B<P_ALL>"

#. type: Plain text
#: build/C/man2/wait.2:261
msgid "Wait for any child; I<id> is ignored."
msgstr "子プロセス全部を対象に待つ。 I<id> は無視される。"

#. type: Plain text
#: build/C/man2/wait.2:265
msgid ""
"The child state changes to wait for are specified by ORing one or more of "
"the following flags in I<options>:"
msgstr ""
"子プロセスのどの状態変化を待つかは以下のフラグで指定する (I<options> には 1個"
"以上のフラグの論理和をとって指定する):"

#. type: TP
#: build/C/man2/wait.2:265
#, no-wrap
msgid "B<WEXITED>"
msgstr "B<WEXITED>"

#. type: Plain text
#: build/C/man2/wait.2:268
msgid "Wait for children that have terminated."
msgstr "子プロセスの終了を待つ。"

#. type: TP
#: build/C/man2/wait.2:268
#, no-wrap
msgid "B<WSTOPPED>"
msgstr "B<WSTOPPED>"

#. type: Plain text
#: build/C/man2/wait.2:271
msgid "Wait for children that have been stopped by delivery of a signal."
msgstr "子プロセスがシグナルの配送により停止するのを待つ。"

#. type: TP
#: build/C/man2/wait.2:271
#, no-wrap
msgid "B<WCONTINUED>"
msgstr "B<WCONTINUED>"

#. type: Plain text
#: build/C/man2/wait.2:276
msgid ""
"Wait for (previously stopped) children that have been resumed by delivery of "
"B<SIGCONT>."
msgstr "(停止していた) 子プロセスが B<SIGCONT> が配送されて再開するのを待つ。"

#. type: Plain text
#: build/C/man2/wait.2:279
msgid "The following flags may additionally be ORed in I<options>:"
msgstr "さらに以下のフラグを論理和の形で I<options> に指定できる:"

#. type: Plain text
#: build/C/man2/wait.2:283
msgid "As for B<waitpid>()."
msgstr "B<waitpid>()  と同様。"

#. type: TP
#: build/C/man2/wait.2:283
#, no-wrap
msgid "B<WNOWAIT>"
msgstr "B<WNOWAIT>"

#. type: Plain text
#: build/C/man2/wait.2:287
msgid ""
"Leave the child in a waitable state; a later wait call can be used to again "
"retrieve the child status information."
msgstr ""
"waitable 状態のプロセスをそのままにする。この後で wait コールを 使って、同じ"
"子プロセスの状態情報をもう一度取得することができる。"

#. type: Plain text
#: build/C/man2/wait.2:294
msgid ""
"Upon successful return, B<waitid>()  fills in the following fields of the "
"I<siginfo_t> structure pointed to by I<infop>:"
msgstr ""
"成功した場合には、 B<waitid>()  は I<infop> が指す I<siginfo_t> 構造体の以下"
"のフィールドを設定する:"

#. type: Plain text
#: build/C/man2/wait.2:297
msgid "The process ID of the child."
msgstr "子プロセスのプロセスID。"

#. type: Plain text
#: build/C/man2/wait.2:301
msgid ""
"The real user ID of the child.  (This field is not set on most other "
"implementations.)"
msgstr ""
"子プロセスの実ユーザID (このフィールドは他のほとんどの実装では設定されない)。"

#. type: Plain text
#: build/C/man2/wait.2:305
msgid "Always set to B<SIGCHLD>."
msgstr "常に B<SIGCHLD> が設定される。"

#. type: TP
#: build/C/man2/wait.2:305
#, no-wrap
msgid "I<si_status>"
msgstr "I<si_status>"

#. type: Plain text
#: build/C/man2/wait.2:315
msgid ""
"Either the exit status of the child, as given to B<_exit>(2)  (or B<exit>"
"(3)), or the signal that caused the child to terminate, stop, or continue.  "
"The I<si_code> field can be used to determine how to interpret this field."
msgstr ""
"B<_exit>(2)  (か B<exit>(3))  に指定された子プロセスの終了ステータス、もしく"
"は 子プロセスの終了、停止、再開の原因となったシグナルが設定される。 この"
"フィールドをどう解釈するかは、 I<si_code> フィールドを参照して決めることがで"
"きる。"

#. type: Plain text
#: build/C/man2/wait.2:332
msgid ""
"Set to one of: B<CLD_EXITED> (child called B<_exit>(2)); B<CLD_KILLED> "
"(child killed by signal); B<CLD_DUMPED> (child killed by signal, and dumped "
"core); B<CLD_STOPPED> (child stopped by signal); B<CLD_TRAPPED> (traced "
"child has trapped); or B<CLD_CONTINUED> (child continued by B<SIGCONT>)."
msgstr ""
"以下のいずれかが設定される: B<CLD_EXITED> (子プロセスが B<_exit>(2)  を呼び出"
"した); B<CLD_KILLED> (シグナルにより子プロセスが kill された); B<CLD_DUMPED> "
"(シグナルにより子プロセスが kill され、コア・ダンプが行われた); "
"B<CLD_STOPPED> (シグナルにより子プロセスが停止した); B<CLD_TRAPPED> (トレース"
"されていた子プロセスがトラップを受信した); B<CLD_CONTINUED> (B<SIGCONT> によ"
"り子プロセスが再開された)。"

#.  POSIX.1-2001 leaves this possibility unspecified; most
#.  implementations (including Linux) zero out the structure
#.  in this case, but at least one implementation (AIX 5.1)
#.  does not -- MTK Nov 04
#. type: Plain text
#: build/C/man2/wait.2:354
msgid ""
"If B<WNOHANG> was specified in I<options> and there were no children in a "
"waitable state, then B<waitid>()  returns 0 immediately and the state of the "
"I<siginfo_t> structure pointed to by I<infop> is unspecified.  To "
"distinguish this case from that where a child was in a waitable state, zero "
"out the I<si_pid> field before the call and check for a nonzero value in "
"this field after the call returns."
msgstr ""
"B<WNOHANG> が I<options> に指定されていて、 waitable 状態の子プロセスがなかっ"
"た場合には、 B<waitid>()  はすぐに 0 を返す。このとき、 I<infop> が指す "
"I<siginfo_t> 構造体の内容は不定である。 この場合を waitable 状態の子プロセス"
"があった場合と区別するには、 B<waitid>()  を呼び出す前に I<si_pid> を 0 にし"
"ておき、コールが復帰した後でこのフィールドが 0 以外の値かどうか をチェックす"
"ればよい。"

#. type: Plain text
#: build/C/man2/wait.2:358
msgid ""
"B<wait>(): on success, returns the process ID of the terminated child; on "
"error, -1 is returned."
msgstr ""
"B<wait>(): 成功すると、終了した子プロセスのプロセスID を返す。 エラーの場合 "
"-1 を返す。"

#. type: Plain text
#: build/C/man2/wait.2:367
msgid ""
"B<waitpid>(): on success, returns the process ID of the child whose state "
"has changed; if B<WNOHANG> was specified and one or more child(ren) "
"specified by I<pid> exist, but have not yet changed state, then 0 is "
"returned.  On error, -1 is returned."
msgstr ""
"B<waitpid>(): 成功すると、状態が変化した子プロセスのプロセスID を返す。 "
"B<WNOHANG> が指定されていて、 I<pid> で指示された子プロセスが一つ以上存在する"
"が、どの子プロセスでも 状態変化が起こっていなかった場合は、 0 を返す。 エラー"
"の場合 -1 を返す。"

#.  FIXME: As reported by Vegard Nossum, if infop is NULL, then waitid()
#.  returns the PID of the child.  Either this is a bug, or it is intended
#.  behavior that needs to be documented.  See my Jan 2009 LKML mail
#.  "waitid() return value strangeness when infop is NULL".
#. type: Plain text
#: build/C/man2/wait.2:383
msgid ""
"B<waitid>(): returns 0 on success or if B<WNOHANG> was specified and no child"
"(ren) specified by I<id> has yet changed state; on error, -1 is returned.  "
"Each of these calls sets I<errno> to an appropriate value in the case of an "
"error."
msgstr ""
"B<waitid>(): 成功すると 0 を返す。 B<WNOHANG> が指定されていて、 I<pid> で指"
"示された子プロセスで状態変化が起こっていなかった場合にも 0 を返す。 エラーの"
"場合 -1 を返す。 エラーの場合、これらのシステムコールはいずれも I<errno> に適"
"切な値を設定する。"

#. type: TP
#: build/C/man2/wait.2:384 build/C/man2/wait.2:389
#, no-wrap
msgid "B<ECHILD>"
msgstr "B<ECHILD>"

#. type: Plain text
#: build/C/man2/wait.2:389
msgid ""
"(for B<wait>())  The calling process does not have any unwaited-for children."
msgstr ""
"(B<wait>()  の場合)  呼び出し元プロセスには、wait を行っていない子プロセスは"
"ない。"

#. type: Plain text
#: build/C/man2/wait.2:409
msgid ""
"(for B<waitpid>()  or B<waitid>())  The process specified by I<pid> "
"(B<waitpid>())  or I<idtype> and I<id> (B<waitid>())  does not exist or is "
"not a child of the calling process.  (This can happen for one's own child if "
"the action for B<SIGCHLD> is set to B<SIG_IGN>.  See also the I<Linux Notes> "
"section about threads.)"
msgstr ""
"(B<waitpid>()  か B<waitid>()  の場合)  I<pid> (B<waitpid>())  か I<idtype> "
"と I<id> (B<waitid>())  で指定したプロセスが存在しないか、呼び出し元プロセス"
"の子プロセスでない (B<SIGCHLD> の動作に B<SIG_IGN> を設定した場合には、自分自"
"身の子プロセスでも起こりうる。 スレッドに関しては「Linux での注意」の節も参照"
"すること)。"

#. type: Plain text
#: build/C/man2/wait.2:416
msgid ""
"B<WNOHANG> was not set and an unblocked signal or a B<SIGCHLD> was caught; "
"see B<signal>(7)."
msgstr ""
"B<WNOHANG> が設定されておらず、禁止 (block) されていないシグナルや "
"B<SIGCHLD> を受信した。 B<signal>(7)  参照。"

#. type: Plain text
#: build/C/man2/wait.2:421
msgid "The I<options> argument was invalid."
msgstr "I<options> 引き数が不正である。"

#. type: Plain text
#: build/C/man2/wait.2:436
msgid ""
"A child that terminates, but has not been waited for becomes a \"zombie\".  "
"The kernel maintains a minimal set of information about the zombie process "
"(PID, termination status, resource usage information)  in order to allow the "
"parent to later perform a wait to obtain information about the child.  As "
"long as a zombie is not removed from the system via a wait, it will consume "
"a slot in the kernel process table, and if this table fills, it will not be "
"possible to create further processes.  If a parent process terminates, then "
"its \"zombie\" children (if any)  are adopted by B<init>(8), which "
"automatically performs a wait to remove the zombies."
msgstr ""
"終了したが、wait されていない子プロセスは「ゾンビ」になる。 後で親プロセスが "
"wait を実行して子プロセスについての情報を取得できるように、 カーネルはゾンビ"
"プロセスについて最小限の情報 (PID、終了ステータス、 リソース使用状況) を保持"
"する。 ゾンビプロセスは、 wait によってシステムから削除されない限り、 カーネ"
"ルのプロセステーブルの 1 エントリを消費する。このプロセステーブルが 一杯にな"
"ると、新たにプロセスを作ることができなくなる。 親プロセスが終了すると、その親"
"プロセスの「ゾンビ」の 子プロセスは (もしあれば)  B<init>(8)  の養子となる。 "
"B<init>(8)  は wait を自動的に実行し、ゾンビを削除する。"

#. type: Plain text
#: build/C/man2/wait.2:477
msgid ""
"POSIX.1-2001 specifies that if the disposition of B<SIGCHLD> is set to "
"B<SIG_IGN> or the B<SA_NOCLDWAIT> flag is set for B<SIGCHLD> (see "
"B<sigaction>(2)), then children that terminate do not become zombies and a "
"call to B<wait>()  or B<waitpid>()  will block until all children have "
"terminated, and then fail with I<errno> set to B<ECHILD>.  (The original "
"POSIX standard left the behavior of setting B<SIGCHLD> to B<SIG_IGN> "
"unspecified.  Note that even though the default disposition of B<SIGCHLD> is "
"\"ignore\", explicitly setting the disposition to B<SIG_IGN> results in "
"different treatment of zombie process children.)  Linux 2.6 conforms to this "
"specification.  However, Linux 2.4 (and earlier) does not: if a B<wait>()  "
"or B<waitpid>()  call is made while B<SIGCHLD> is being ignored, the call "
"behaves just as though B<SIGCHLD> were not being ignored, that is, the call "
"blocks until the next child terminates and then returns the process ID and "
"status of that child."
msgstr ""
"POSIX.1-2001 では以下のように規定されている。 B<SIGCHLD> の動作が B<SIG_IGN> "
"に設定されたか、 B<SIGCHLD> に対して B<SA_NOCLDWAIT> フラグが設定された場合 "
"(B<sigaction>(2)  参照)、終了した子プロセスはゾンビにはならず、 B<wait>()  "
"や B<waitpid>()  の呼び出しは全ての子プロセスが終了するまで停止し、 子プロセ"
"スが全部終了した後 I<errno> に B<ECHILD> を設定して失敗する。 (もともとの "
"POSIX 標準は B<SIGCHLD> に B<SIG_IGN> を設定した場合の振る舞いを未規定のまま"
"にしている。 B<SIGCHLD> のデフォルトの動作が「無視」であるにもかかわらず、 "
"B<SIGCHLD> の動作として B<SIG_IGN> を明示的に設定した場合にはゾンビプロセスの"
"子プロセスの扱いが 異なる点に注意すること。)  Linux 2.6 はこの仕様に準拠して"
"いる。 しかし、Linux 2.4 (とそれ以前のバージョン) はそうではない: B<SIGCHLD> "
"が無視される状態で B<wait>()  または B<waitpid>()  が呼び出された場合、 "
"B<SIGCHLD> が無視されていないかのように振る舞う。 つまり、呼び出しによって次"
"の子プロセスの終了までブロックされ、 終了した子プロセスの PID と状態が返され"
"る。"

#. type: Plain text
#: build/C/man2/wait.2:493
msgid ""
"In the Linux kernel, a kernel-scheduled thread is not a distinct construct "
"from a process.  Instead, a thread is simply a process that is created using "
"the Linux-unique B<clone>(2)  system call; other routines such as the "
"portable B<pthread_create>(3)  call are implemented using B<clone>(2).  "
"Before Linux 2.4, a thread was just a special case of a process, and as a "
"consequence one thread could not wait on the children of another thread, "
"even when the latter belongs to the same thread group.  However, POSIX "
"prescribes such functionality, and since Linux 2.4 a thread can, and by "
"default will, wait on children of other threads in the same thread group."
msgstr ""
"Linux カーネルでは、カーネルによってスケジュールされるスレッドは プロセスと明"
"確に区別できる構成要素ではない。スレッドは Linux 固有の B<clone>(2)  システム"
"コールを使用して生成されるプロセスに過ぎない。 移植性のある B<pthread_create>"
"(3)  コールのような他のルーチンは B<clone>(2)  を使用して実装されている; これ"
"らでは B<waitid>()  を使うことはできない。 Linux 2.4 より前では、スレッドは単"
"に特殊なプロセスであったので、 例え同じスレッドグループであっても、 あるス"
"レッドが別のスレッドの子プロセスが終了するのを待つことは出来なかった。 しか"
"し、POSIX ではこのような機能を規定しており、 Linux 2.4 以降では、あるスレッド"
"が同じスレッドグループの他のスレッドの 子プロセスが終了するのを待つことができ"
"るようになった。 そして将来はこれがデフォルトの動作になるであろう。"

#. type: Plain text
#: build/C/man2/wait.2:500
msgid ""
"The following Linux-specific I<options> are for use with children created "
"using B<clone>(2); they cannot be used with B<waitid>():"
msgstr ""
"B<clone>(2)  を用いて作られた子プロセスには、以下の Linux 固有の I<options> "
"が使用できる。"

#. type: TP
#: build/C/man2/wait.2:500
#, no-wrap
msgid "B<__WCLONE>"
msgstr "B<__WCLONE>"

#.  since 0.99pl10
#. type: Plain text
#: build/C/man2/wait.2:511
msgid ""
"Wait for \"clone\" children only.  If omitted then wait for \"non-clone\" "
"children only.  (A \"clone\" child is one which delivers no signal, or a "
"signal other than B<SIGCHLD> to its parent upon termination.)  This option "
"is ignored if B<__WALL> is also specified."
msgstr ""
"\"clone\" な子プロセスだけを待つ。 指定されなかった場合は非 \"clone\" な子プ"
"ロセスだけを待つ (\"clone\" な子プロセスは、終了時に親プロセスへ全くシグナル"
"を送らないか、 B<SIGCHLD> 以外のシグナルを送る)。 このオプションは B<__WALL> "
"も指定された場合は無視される。"

#. type: TP
#: build/C/man2/wait.2:511
#, no-wrap
msgid "B<__WALL> (since Linux 2.4)"
msgstr "B<__WALL> (Linux 2.4 以降)"

#.  since patch-2.3.48
#. type: Plain text
#: build/C/man2/wait.2:516
msgid "Wait for all children, regardless of type (\"clone\" or \"non-clone\")."
msgstr "\"clone\" であるかないかに関わらず、 全ての子プロセスを待つ。"

#. type: TP
#: build/C/man2/wait.2:516
#, no-wrap
msgid "B<__WNOTHREAD> (since Linux 2.4)"
msgstr "B<__WNOTHREAD> (Linux 2.4 以降)"

#.  since patch-2.4.0-test8
#. type: Plain text
#: build/C/man2/wait.2:522
msgid ""
"Do not wait for children of other threads in the same thread group.  This "
"was the default before Linux 2.4."
msgstr ""
"同じスレッドグループの他のスレッドの子プロセスは待たない。 Linux 2.4 より前で"
"はデフォルトであった。"

#.  fork.2 refers to this example program.
#. type: Plain text
#: build/C/man2/wait.2:539
msgid ""
"The following program demonstrates the use of B<fork>(2)  and B<waitpid>().  "
"The program creates a child process.  If no command-line argument is "
"supplied to the program, then the child suspends its execution using B<pause>"
"(2), to allow the user to send signals to the child.  Otherwise, if a "
"command-line argument is supplied, then the child exits immediately, using "
"the integer supplied on the command line as the exit status.  The parent "
"process executes a loop that monitors the child using B<waitpid>(), and uses "
"the W*() macros described above to analyze the wait status value."
msgstr ""
"以下のプログラムは、 B<fork>(2)  と B<waitpid>()  の使用方法の例を示してい"
"る。 このプログラムでは子プロセスを生成する。 コマンドライン引き数が指定され"
"なかったときは、 子プロセスは B<pause>(2)  を使ってその実行を一時停止し、ユー"
"ザがその子プロセスに シグナルを送信できるようにする。 コマンドライン引き数が"
"指定された場合は、 子プロセスは直ちに終了し、 コマンドラインで指定された整数"
"を終了ステータスとして使用する。 親プロセスは、 B<waitpid>()  を使って子プロ"
"セスを監視し、 wait のステータス値を上記の W*() マクロを使って解析するという "
"ループを実行する。"

#. type: Plain text
#: build/C/man2/wait.2:555
#, no-wrap
msgid ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"
msgstr ""
"$B< ./a.out &>\n"
"Child PID is 32360\n"
"[1] 32359\n"
"$B< kill -STOP 32360>\n"
"stopped by signal 19\n"
"$B< kill -CONT 32360>\n"
"continued\n"
"$B< kill -TERM 32360>\n"
"killed by signal 15\n"
"[1]+  Done                    ./a.out\n"
"$\n"

#. type: Plain text
#: build/C/man2/wait.2:564
#, no-wrap
msgid ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"
msgstr ""
"#include E<lt>sys/wait.hE<gt>\n"
"#include E<lt>stdlib.hE<gt>\n"
"#include E<lt>unistd.hE<gt>\n"
"#include E<lt>stdio.hE<gt>\n"

#. type: Plain text
#: build/C/man2/wait.2:570
#, no-wrap
msgid ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int status;\n"
msgstr ""
"int\n"
"main(int argc, char *argv[])\n"
"{\n"
"    pid_t cpid, w;\n"
"    int status;\n"

#. type: Plain text
#: build/C/man2/wait.2:576
#, no-wrap
msgid ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"
msgstr ""
"    cpid = fork();\n"
"    if (cpid == -1) {\n"
"        perror(\"fork\");\n"
"        exit(EXIT_FAILURE);\n"
"    }\n"

#. type: Plain text
#: build/C/man2/wait.2:582
#, no-wrap
msgid ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %ld\\en\", (long) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"
msgstr ""
"    if (cpid == 0) {            /* Code executed by child */\n"
"        printf(\"Child PID is %ld\\en\", (long) getpid());\n"
"        if (argc == 1)\n"
"            pause();                    /* Wait for signals */\n"
"        _exit(atoi(argv[1]));\n"

#. type: Plain text
#: build/C/man2/wait.2:590
#, no-wrap
msgid ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &status, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"
msgstr ""
"    } else {                    /* Code executed by parent */\n"
"        do {\n"
"            w = waitpid(cpid, &status, WUNTRACED | WCONTINUED);\n"
"            if (w == -1) {\n"
"                perror(\"waitpid\");\n"
"                exit(EXIT_FAILURE);\n"
"            }\n"

#. type: Plain text
#: build/C/man2/wait.2:604
#, no-wrap
msgid ""
"            if (WIFEXITED(status)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"            } else if (WIFSIGNALED(status)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"            } else if (WIFSTOPPED(status)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"            } else if (WIFCONTINUED(status)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"
msgstr ""
"            if (WIFEXITED(status)) {\n"
"                printf(\"exited, status=%d\\en\", WEXITSTATUS(status));\n"
"            } else if (WIFSIGNALED(status)) {\n"
"                printf(\"killed by signal %d\\en\", WTERMSIG(status));\n"
"            } else if (WIFSTOPPED(status)) {\n"
"                printf(\"stopped by signal %d\\en\", WSTOPSIG(status));\n"
"            } else if (WIFCONTINUED(status)) {\n"
"                printf(\"continued\\en\");\n"
"            }\n"
"        } while (!WIFEXITED(status) && !WIFSIGNALED(status));\n"
"        exit(EXIT_SUCCESS);\n"
"    }\n"
"}\n"

#. type: Plain text
#: build/C/man2/wait.2:617
msgid ""
"B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), B<sigaction>"
"(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), B<credentials>(7), "
"B<signal>(7)"
msgstr ""
"B<_exit>(2), B<clone>(2), B<fork>(2), B<kill>(2), B<ptrace>(2), B<sigaction>"
"(2), B<signal>(2), B<wait4>(2), B<pthread_create>(3), B<credentials>(7), "
"B<signal>(7)"

#. type: TH
#: build/C/man2/wait4.2:34
#, no-wrap
msgid "WAIT4"
msgstr "WAIT4"

#. type: Plain text
#: build/C/man2/wait4.2:37
msgid "wait3, wait4 - wait for process to change state, BSD style"
msgstr "wait3, wait4 - BSD スタイルでプロセスの状態変化を待つ"

#. type: Plain text
#: build/C/man2/wait4.2:43
#, no-wrap
msgid ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"
msgstr ""
"B<#include E<lt>sys/types.hE<gt>>\n"
"B<#include E<lt>sys/time.hE<gt>>\n"
"B<#include E<lt>sys/resource.hE<gt>>\n"
"B<#include E<lt>sys/wait.hE<gt>>\n"

#. type: Plain text
#: build/C/man2/wait4.2:46
#, no-wrap
msgid ""
"B<pid_t wait3(int *>I<status>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""
"B<pid_t wait3(int *>I<status>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"

#. type: Plain text
#: build/C/man2/wait4.2:49
#, no-wrap
msgid ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<status>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"
msgstr ""
"B<pid_t wait4(pid_t >I<pid>B<, int *>I<status>B<, int >I<options>B<,>\n"
"B<            struct rusage *>I<rusage>B<);>\n"

#. type: Plain text
#: build/C/man2/wait4.2:58
msgid "B<wait3>():"
msgstr "B<wait3>():"

#. type: Plain text
#: build/C/man2/wait4.2:64
msgid "B<wait4>():"
msgstr "B<wait4>():"

#. type: Plain text
#: build/C/man2/wait4.2:66
msgid "_BSD_SOURCE"
msgstr "_BSD_SOURCE"

#. type: Plain text
#: build/C/man2/wait4.2:78
msgid ""
"The B<wait3>()  and B<wait4>()  system calls are similar to B<waitpid>(2), "
"but additionally return resource usage information about the child in the "
"structure pointed to by I<rusage>."
msgstr ""
"システムコール B<wait3>()  と B<wait4>()  は B<waitpid>(2)  と同様の動作をす"
"る。それに加え、子プロセスのリソース使用状況の情報を I<rusage> が指す構造体に"
"入れて返す。"

#. type: Plain text
#: build/C/man2/wait4.2:84
msgid ""
"Other than the use of the I<rusage> argument, the following B<wait3>()  call:"
msgstr "I<rusage> を使用する点を除けば、次の B<wait3>()  の呼び出し"

#. type: Plain text
#: build/C/man2/wait4.2:87
#, no-wrap
msgid "    wait3(status, options, rusage);\n"
msgstr "    wait3(status, options, rusage);\n"

#. type: Plain text
#: build/C/man2/wait4.2:90 build/C/man2/wait4.2:104
msgid "is equivalent to:"
msgstr "は以下と等価である。"

#. type: Plain text
#: build/C/man2/wait4.2:93
#, no-wrap
msgid "    waitpid(-1, status, options);\n"
msgstr "    waitpid(-1, status, options);\n"

#. type: Plain text
#: build/C/man2/wait4.2:98
msgid "Similarly, the following B<wait4>()  call:"
msgstr "同様に、次の B<wait4>()  の呼び出し"

#. type: Plain text
#: build/C/man2/wait4.2:101
#, no-wrap
msgid "    wait4(pid, status, options, rusage);\n"
msgstr "    wait4(pid, status, options, rusage);\n"

#. type: Plain text
#: build/C/man2/wait4.2:107
#, no-wrap
msgid "    waitpid(pid, status, options);\n"
msgstr "    waitpid(pid, status, options);\n"

#. type: Plain text
#: build/C/man2/wait4.2:117
msgid ""
"In other words, B<wait3>()  waits of any child, while B<wait4>()  can be "
"used to select a specific child, or children, on which to wait.  See B<wait>"
"(2)  for further details."
msgstr ""
"言い換えると、 B<wait3>()  は全ての子プロセスを対象に待つが、 B<wait4>()  で"
"は特定の子プロセス (複数可) を選んで待つことができる。"

#. type: Plain text
#: build/C/man2/wait4.2:127
msgid ""
"If I<rusage> is not NULL, the I<struct rusage> to which it points will be "
"filled with accounting information about the child.  See B<getrusage>(2)  "
"for details."
msgstr ""
"I<rusage> が NULL でない場合、 I<rusage> が指す I<rusage 構造体> には子プロセ"
"スのアカウント情報が格納される。 詳しくは B<getrusage>(2)  を参照のこと。"

#. type: Plain text
#: build/C/man2/wait4.2:130 build/C/man2/wait4.2:133
msgid "As for B<waitpid>(2)."
msgstr "B<waitpid>(2)  と同様。"

#. type: Plain text
#: build/C/man2/wait4.2:135
msgid "4.3BSD."
msgstr "4.3BSD."

#. type: Plain text
#: build/C/man2/wait4.2:147
msgid ""
"Including I<E<lt>sys/time.hE<gt>> is not required these days, but increases "
"portability.  (Indeed, I<E<lt>sys/resource.hE<gt>> defines the I<rusage> "
"structure with fields of type I<struct timeval> defined in I<E<lt>sys/time."
"hE<gt>>.)"
msgstr ""
"現在では I<E<lt>sys/time.hE<gt>> をインクルードする必要はないが、インクルード"
"しておくと 移植性を高めることができる (実際には I<E<lt>sys/resource.hE<gt>> "
"で I<rusage> 構造体が定義されているが、そのフィールドで使用されている "
"I<struct timeval> 型は I<E<lt>sys/time.hE<gt>> で定義されている)。"

#. type: Plain text
#: build/C/man2/wait4.2:153
msgid ""
"On Linux, B<wait3>()  is a library function implemented on top of the "
"B<wait4>()  system call."
msgstr ""
"Linux では、 B<wait3>()  はライブラリ関数であり、 B<wait4>()  システムコール"
"を使って実装されている。"

#. type: Plain text
#: build/C/man2/wait4.2:160
msgid ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"
msgstr ""
"B<fork>(2), B<getrusage>(2), B<sigaction>(2), B<signal>(2), B<wait>(2), "
"B<signal>(7)"

#~ msgid "2008-07-11"
#~ msgstr "2008-07-11"

#~ msgid ""
#~ "B<SIGIO> and B<SIGLOST> have the same value.  The latter is commented out "
#~ "in the kernel source, but the build process of some software still thinks "
#~ "that signal 29 is B<SIGLOST>."
#~ msgstr ""
#~ "B<SIGIO> と B<SIGLOST> は同じ値を持っている。 B<SIGLOST> はカーネルのソー"
#~ "スではコメントアウトされている。 しかし、ソフトウェアによってはビルドの過"
#~ "程でシグナル 29 を B<SIGLOST> とみなしてしまうものがある。"

#~ msgid "2011-10-03"
#~ msgstr "2011-10-03"

#~ msgid "B<kill>(2)  or B<raise>(3)"
#~ msgstr "B<kill>(2)  または B<raise>(3)"

#~ msgid "queued SIGIO"
#~ msgstr "キューイングされた SIGIO"

#~ msgid "EXAMPLES"
#~ msgstr "例"

#~ msgid "POSIX.1b signals and B<SIGCHLD> fill in I<si_pid> and I<si_uid>."
#~ msgstr ""
#~ "POSIX.1b シグナルと B<SIGCHLD> は I<si_pid> と I<si_uid> を設定する。"

#~ msgid ""
#~ "I<si_int> and I<si_ptr> are specified by the sender of the POSIX.1b "
#~ "signal.  See B<sigqueue>(2)  for more details."
#~ msgstr ""
#~ "I<si_int> と I<si_ptr> は POSIX.1b シグナルの送信者によって指定される。 詳"
#~ "細は B<sigqueue>(2)  を参照のこと。"

#~ msgid ""
#~ "B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, and B<SIGBUS> fill in I<si_addr> with "
#~ "the address of the fault.  B<SIGPOLL> fills in I<si_band> and I<si_fd>."
#~ msgstr ""
#~ "B<SIGILL>, B<SIGFPE>, B<SIGSEGV>, B<SIGBUS> は I<si_addr> にエラーが発生し"
#~ "たアドレスを設定する。 SIGPOLL は I<si_band> と I<si_fd> を設定する。"
